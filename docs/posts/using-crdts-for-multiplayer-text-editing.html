<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zed.dev/blog/crdts">Original</a>
    <h1>Using CRDTs for multiplayer text editing</h1>
    
    <div id="readability-page-1" class="page"><div><div><header><p>December 1st, 2022</p></header><p><span><span><img src="https://zed.dev/img/post/crdts/crdt-preview.jpg" alt=""/></span></span></p>
<p>Programmers spend countless hours interacting with one fundamental tool: their text editor. Before you commit, push, or ship a single line of code, you must first put your hands on the keyboard and type it into the machine. No tool has a bigger impact on the visceral and tactile experience of creating software.</p>
<p>Yet despite the critical role that editors play in my life as a programmer, I have never found an editor that I truly love. So 16 years ago, I decided to build one. It took a failed attempt, many hard lessons, and the help of some talented friends, but the tool I&#39;ve been striving to create is finally emerging in the 135k lines of Rust that constitute Zed.</p>
<p>Our first goal with Zed is simple: to build an editor that we love using. A tool with consistent high performance. A tool that assists us, but also stays out of our way. A tool that looks great, but also disappears. We want Zed to advance the state of the art for text editing, combining the strengths of other editors while avoiding their weaknesses, then going further. Anything less isn&#39;t worth building.</p>
<p>But beyond executing on the fundamentals, we also see an opportunity to radically improve the way developers collaborate on software. By integrating collaboration as a first-class concern of the code authoring environment itself, Zed will make it easier to link conversations to any piece of text, regardless of whether it was committed last year or just written moments ago. Zed will also make it seamless to write and discuss code with fellow developers in real time.</p>
<p>This focus on collaboration is one of Zed&#39;s defining characteristics, so with our first blog post, we&#39;d like to explore the technology we&#39;ve built into the core of the editor to make it possible.</p>
<div><h2 level="2">The pre-history of collaborative editing</h2></div>
<p>In December of 1968, Douglas Englebart demonstrated a host of technologies in front of a standing-room-only audience in San Francisco, including interactive editing, hypertext, and the mouse. The ideas he presented went on to shape modern computing, but when I first watched his famous demo, I was surprised to learn that the system that amazed everyone was actually <a href="https://youtu.be/8UQyQ7Gvi4U?t=286">a collaborative text editor</a>. The very thing I had been trying to build! <em>In 1968.</em></p>
<p><span><span><img src="https://user-images.githubusercontent.com/1789/199089574-148fdec3-7b8c-476b-b29f-7d398887907d.png" alt="Bill Paxton video chats and collaboratively edits text with Douglas Englebart at the dawn of interactive computing. "/></span><span>Bill Paxton video chats and collaboratively edits text with Douglas Englebart at the dawn of interactive computing. </span></span></p>
<p>To build their collaborative editor, Englebart&#39;s team needed to create their own programming language, time-sharing operating system, and cathode ray tube displays. As we set out to build Zed, our task was obviously vastly easier than theirs in almost every way, but we did face one problem that they did not: asynchronous coordination.</p>
<p>In Englebart&#39;s system, collaborators were all connected to the same physical machine via individual terminals. I&#39;m unsure whether their tool ever supported fine-grained concurrent editing, but at least in theory, it would have been possible in this setup to synchronize edits to a shared buffer with a mutex. But this isn&#39;t how computers are organized today. Instead of sharing a single machine via directly-connected terminals, we use personal computers that are connected via the internet. And we collaborate over much greater distances. Even at the speed of light, synchronizing access to a shared buffer between two different continents would introduce prohibitive editing latency.</p>
<div><h2 level="2">The challenge of asynchronous coordination</h2></div>
<p>To collaborate over the internet, we need an approach that allows individuals to edit their own replicas of a document independently and have their documents converge to the same contents after they exchange data asynchronously. It turns out this is a hard problem.</p>
<p>The animation below illustrates the basic challenge. We start with two replicas of the text <code>In 1968,</code>. We then concurrently insert different text into each replica and transmit a description of our edits to the other replica. But if we naively apply a remote edit without accounting for concurrent changes, we can end up applying it to an invalid location, causing the contents of the replicas to diverge.</p>
<p><span><span><video loop="" muted="" controls="" playsinline=""><source src="/img/post/crdts/divergence.webm" type="video/webm; codecs=&#34;vp8.0, vorbis&#34;"/><source src="/img/post/crdts/divergence.mp4" type="video/mp4; codecs=&#34;avc1.4D401E, mp4a.40.2&#34;"/></video></span><span>Naive operation replication leads to divergence in the presence of concurrency.</span></span></p>
<div><h2 level="2">Eventually-consistent text editing with CRDTs</h2></div>
<p>One solution is to somehow <em>transform</em> incoming edits to reflect concurrent changes. In the animation below, you can see how we transform the blue insertion, changing its position from 8 to 20.</p>
<p><span><span><video loop="" muted="" controls="" playsinline=""><source src="/img/post/crdts/ot.webm" type="video/webm; codecs=&#34;vp8.0, vorbis&#34;"/><source src="/img/post/crdts/ot.mp4" type="video/mp4; codecs=&#34;avc1.4D401E, mp4a.40.2&#34;"/></video></span><span>Operational Transformation focuses on transforming incoming operations to account for concurrent edits.</span></span></p>
<p>This is simple in concept, but defining a correct and performant function that can transform operations is non-trivial, and was the subject of a whole subdiscipline of computer science research known as Operational Transformation, or OT. We experimented with this approach when we first explored collaborative editing back in 2017, but we ultimately chose to work with an alternative theoretical framework called Conflict-Free Replicated Data Types (CRDTs), which we found to be more powerful and intuitive.</p>
<p>With CRDTs, instead of <em>transforming</em> concurrent operations so they can be applied in a different order, we structure our data so that concurrent operations are <em>inherently commutative</em>, allowing us to apply them directly on any replica without transformation. But how do we make text edits commutative?</p>
<p>The key is to express edits in terms of logical locations rather than absolute offsets. In the examples above, what if instead of referring to insertion locations in terms of numeric offsets, we described them via content instead. Then it wouldn&#39;t matter that concurrent edits have shifted the text, because we only depend on content to resolve the location of the remote edit.</p>
<p><span><span><video loop="" muted="" controls="" playsinline=""><source src="/img/post/crdts/content-based-addresses.webm" type="video/webm; codecs=&#34;vp8.0, vorbis&#34;"/><source src="/img/post/crdts/content-based-addresses.mp4" type="video/mp4; codecs=&#34;avc1.4D401E, mp4a.40.2&#34;"/></video></span><span>If we could base the location of edits on the content, we could apply operations directly without transformation.</span></span></p>
<p>This approach obviously wouldn&#39;t work in practice. The text <code>68,</code> might appear multiple times, or a concurrent edit may have completely deleted it. To use this sort of content-based logical addressing, we need to do it in a way that&#39;s durable in the presence of concurrent changes. But how?</p>
<div><h2 level="2">Stable references in unstable text</h2></div>
<p>The problem with expressing logical positions in terms of the buffer&#39;s current content is that the text isn&#39;t stable. But one thing that <em>is</em> stable is the editing <em>history</em>. We can treat every piece of text that&#39;s ever been inserted as immutable. Subsequent edits might split that text apart or delete portions of it, but this doesn&#39;t change the text that was originally inserted. If we assign a unique identifier to every insertion, we can now unambiguously refer to a logical location using this identifier combined with an offset into the inserted text. We refer to these (insertion id, offset) pairs as <em>anchors</em>.</p>
<p>To generate these unique identifiers, we centrally assign each replica a unique id when it&#39;s created, then combine it with an incrementing sequence number. By inheriting uniqueness from the replica id, replicas can generate ids concurrently without risk of collision.</p>
<p><span><span><video loop="" muted="" controls="" playsinline=""><source src="/img/post/crdts/id-distribution.webm" type="video/webm; codecs=&#34;vp8.0, vorbis&#34;"/><source src="/img/post/crdts/id-distribution.mp4" type="video/mp4; codecs=&#34;avc1.4D401E, mp4a.40.2&#34;"/></video></span><span>After replica ids are centrally assigned, each replica can generate unique ids independently.</span></span></p>
<p>At the start of a collaboration session, participants are assigned replica ids. Replica 0 assigns an identifier of <code>0.0</code> to the buffer&#39;s initial text, then transmits a copy to replica 1. This initial fragment of text, <code>0.0</code>, is the first <em>insertion</em>, and it will remain immutable for the life of the buffer.</p>
<p><span><span><video loop="" muted="" controls="" playsinline=""><source src="/img/post/crdts/crdt-start-collaborating.webm" type="video/webm; codecs=&#34;vp8.0, vorbis&#34;"/><source src="/img/post/crdts/crdt-start-collaborating.mp4" type="video/mp4; codecs=&#34;avc1.4D401E, mp4a.40.2&#34;"/></video></span><span>The initial text of the buffer is always assigned the id 0.0 by the host. The host is replica 0, and they send a copy of the buffer to joining collaborators.</span></span></p>
<p>Now each participant inserts text concurrently, describing the insertion location with offsets relative to insertion <code>0.0</code>. Each new insertion is assigned its own unique id. When replica 0 inserts <code>December of </code> within insertion <code>0.0</code> at offset <code>3</code>, the fragment labeled <code>0.0</code> is split into two pieces. Replica 1 appends <code> Douglas Englebart</code> at the end of insertion <code>0.0</code>, at offset <code>8</code>. Both participants also transmit their operations to the other party.</p>
<p><span><span><video loop="" muted="" controls="" playsinline=""><source src="/img/post/crdts/crdt-concurrent-insertion-part-1.webm" type="video/webm; codecs=&#34;vp8.0, vorbis&#34;"/><source src="/img/post/crdts/crdt-concurrent-insertion-part-1.mp4" type="video/mp4; codecs=&#34;avc1.4D401E, mp4a.40.2&#34;"/></video></span><span>Insertions are assigned unique ids and express their location relative to an existing insertion, in this case the initial insertion 0.0.</span></span></p>
<p>Now the replicas apply each other&#39;s operations. First, replica 1 incorporates the red insertion with id <code>0.1</code>, splitting insertion <code>0.0</code> in two just as occurred when replica 0 originally inserted this text. Then replica 0 incorporates the blue insertion with id <code>1.0</code>.</p>
<p>It scans through its fragments, searching for offset <code>8</code> of insertion <code>0.0</code>. The first fragment belongs to <code>0.0</code>, but it&#39;s only 3 characters long. The second fragment belongs to a different insertion, <code>0.1</code>, and is skipped. Finally, we reach the second fragment containing text from insertion <code>0.0</code>. This one contains offset <code>8</code>, and so we insert the blue text there. The replicas converge.</p>
<p><span><span><video loop="" muted="" controls="" playsinline=""><source src="/img/post/crdts/crdt-concurrent-insertion-part-2.webm" type="video/webm; codecs=&#34;vp8.0, vorbis&#34;"/><source src="/img/post/crdts/crdt-concurrent-insertion-part-2.mp4" type="video/mp4; codecs=&#34;avc1.4D401E, mp4a.40.2&#34;"/></video></span><span>To apply a remote operation, we scan the local document for the fragment containing the specified offset of the parent insertion.</span></span></p>
<p>This process can continue recursively, with insertions building upon each other in a tree. In the animation below, both replicas insert additional text at different offsets within the blue insertion with id <code>1.0</code>. To apply the remote operations, we again scan through the document looking for the fragment of insertion <code>1.0</code> that contains the specified offset.</p>
<p><span><span><video loop="" muted="" controls="" playsinline=""><source src="/img/post/crdts/crdt-concurrent-insertion-part-3.webm" type="video/webm; codecs=&#34;vp8.0, vorbis&#34;"/><source src="/img/post/crdts/crdt-concurrent-insertion-part-3.mp4" type="video/mp4; codecs=&#34;avc1.4D401E, mp4a.40.2&#34;"/></video></span><span>Past insertions can become the parent of new insertions.</span></span></p>
<p>In these examples, we&#39;re inserting multiple characters at a time, but it&#39;s worth noting that in practice, collaborators are often inserting individual characters rather than pasting whole words from their clipboard. Tracking all of this metadata per-character may seem like a lot of overhead, but in practice it isn&#39;t an issue on modern computing hardware. Even long edit histories barely compare to the memory savings Zed obtains from not being built with Electron.</p>
<p>You may also be asking: Isn&#39;t scanning through the entire document like this to apply every remote edit insanely slow? In a future post, I&#39;ll explain how we use a copy-on-write B-tree to index these fragments in order to avoid linear scans, but this simplified explanation should give you a basic framework to understand how collaborative editing works in Zed.</p>

<p>If every insertion is immutable, how do we remove text from the document when a user deletes? Rather than mutating inserted text, we instead mark deleted fragments with <em>tombstones</em>. Fragments with tombstones are hidden in the text we display for the user, but they can still be used to resolve logical anchors to concrete locations in the document.</p>
<p>In the animation below, we insert text in replica 1 at a position that is concurrently deleted in replica 0. Because the deleted text is merely hidden rather than actually thrown away, we can still apply the insertion when it arrives at replica 0.</p>
<p><span><span><video loop="" muted="" controls="" playsinline=""><source src="/img/post/crdts/insert-delete.webm" type="video/webm; codecs=&#34;vp8.0, vorbis&#34;"/><source src="/img/post/crdts/insert-delete.mp4" type="video/mp4; codecs=&#34;avc1.4D401E, mp4a.40.2&#34;"/></video></span><span>Deleted fragments are hidden with tombstones.</span></span></p>
<p>If deletions only encode a range, divergence can occur if text is concurrently inserted inside the deleted range. In the example below, note how the yellow <code>C. </code> is visible in replica 0 but hidden in replica 1.</p>
<p><span><span><video loop="" muted="" controls="" playsinline=""><source src="/img/post/crdts/delete-divergence.webm" type="video/webm; codecs=&#34;vp8.0, vorbis&#34;"/><source src="/img/post/crdts/delete-divergence.mp4" type="video/mp4; codecs=&#34;avc1.4D401E, mp4a.40.2&#34;"/></video></span><span>Inserting text within a concurrently deleted range will cause divergence if we don&#39;t express what operations were visible at the time of the deletion.</span></span></p>
<p>To avoid this issue, we also associate deletions with a <em>vector timestamp</em> that encodes the latest observed sequence number for each replica. Using this, we can exclude insertions that occurred concurrently, only hiding text that was actually visible to the user performing the deletion.</p>
<p>The animation below is much like the one above, except this time we augment the deletion operation with a version vector. When we apply the deletion on replica 1, we <em>exclude</em> the yellow insertion because its id contains a sequence number that isn&#39;t included in the deletion&#39;s version. This causes the yellow insertion to remain visible on both replicas, preserving the deleting user&#39;s intent.</p>
<p><span><span><video loop="" muted="" controls="" playsinline=""><source src="/img/post/crdts/delete-convergence.webm" type="video/webm; codecs=&#34;vp8.0, vorbis&#34;"/><source src="/img/post/crdts/delete-convergence.mp4" type="video/mp4; codecs=&#34;avc1.4D401E, mp4a.40.2&#34;"/></video></span><span>Associating deletions with a version vector allows us to exclude concurrent insertions from being tombstoned.</span></span></p>
<p>Like insertions, deletions are associated with unique identifiers, which we record on the tombstone. We&#39;ll see how these deletion identifiers are used later when we discuss undo and redo operations.</p>
<div><h2 level="2">Concurrent insertions at the same location</h2></div>
<p>When concurrent insertions occur at the same location, it doesn&#39;t matter how we order the insertions, but it definitely does matter that their ordering is consistent across all replicas. One way to achieve consistency is to order all insertions at the same location by their id.</p>
<p><span><span><video loop="" muted="" controls="" playsinline=""><source src="/img/post/crdts/order-insertions-by-id.webm" type="video/webm; codecs=&#34;vp8.0, vorbis&#34;"/><source src="/img/post/crdts/order-insertions-by-id.mp4" type="video/mp4; codecs=&#34;avc1.4D401E, mp4a.40.2&#34;"/></video></span><span>Ordering insertions at the same location by their id achieves a consistent order on all replicas.</span></span></p>
<p>However, the problem with this approach is that it can become impossible for certain replicas to insert text prior to an insertion they have already observed.</p>
<p><span><span><video loop="" muted="" controls="" playsinline=""><source src="/img/post/crdts/order-by-id-intention-violation.webm" type="video/webm; codecs=&#34;vp8.0, vorbis&#34;"/><source src="/img/post/crdts/order-by-id-intention-violation.mp4" type="video/mp4; codecs=&#34;avc1.4D401E, mp4a.40.2&#34;"/></video></span><span>Ordering insertions at the same location by their id does not preserve the user&#39;s intentions when inserting prior to an existing insertion.</span></span></p>
<p>We need a consistent ordering of these insertions that respects <em>causality</em>. Our solution is to augment insertions with <em>Lamport timestamps</em>. These logical timestamps are derived from a scalar-valued <em>Lamport clock</em> that is maintained on every replica. Whenever a replica generates an operation, it derives a Lamport timestamp by incrementing its Lamport clock. Whenever a replica <em>receives</em> an operation, it sets the Lamport clock to the greater of its current value and the timestamp of the incoming operation.</p>
<p><span><span><video loop="" muted="" controls="" playsinline=""><source src="/img/post/crdts/lamport-clock.webm" type="video/webm; codecs=&#34;vp8.0, vorbis&#34;"/><source src="/img/post/crdts/lamport-clock.mp4" type="video/mp4; codecs=&#34;avc1.4D401E, mp4a.40.2&#34;"/></video></span><span>If an operation is generated after another operation has been observed, then it is guaranteed to have a higher Lamport timestamp.</span></span></p>
<p>This scheme guarantees that if an operation was present at the time of another operation, then it will have a lower timestamp. Another way of phrasing that is that the Lamport timestamp allows us to sort the operations in <em>causal order</em>. The inverse isn&#39;t true. Just because operation A has a lower Lamport timestamp than operation B, it doesn&#39;t necessarily mean that it causally preceded operation B, because we have no guarantees about the relationship between the Lamport timestamps of <em>concurrent</em> operations. But we&#39;ve already established that we don&#39;t care how concurrent insertions are ordered, so long as our ordering is consistent.</p>
<p>By sorting insertions descending by their Lamport timestamp and breaking any ties based on their replica id, we achieve a consistent ordering scheme that respects causality.</p>
<p><span><span><video loop="" muted="" controls="" playsinline=""><source src="/img/post/crdts/order-by-lamport.webm" type="video/webm; codecs=&#34;vp8.0, vorbis&#34;"/><source src="/img/post/crdts/order-by-lamport.mp4" type="video/mp4; codecs=&#34;avc1.4D401E, mp4a.40.2&#34;"/></video></span><span>If we sort insertions occurring at the same location descending by their Lamport timestamps, we preserve the user&#39;s intent while still providing a consistent ordering across all replicas.</span></span></p>

<p>In non-collaborative systems, the undo and redo history can be represented as stacks of simple edit operations. When you want to undo something, you simply pop the edit on the top of the undo stack, apply its inverse to the current text, and push it to the redo stack. But this only allows for a single global undo history for the entire document. The offset of any operation in the history is only valid for the specific state of the document in which that operation was originally implied. This means that operations must always be undone in the exact reverse order in which they were applied.</p>
<p>But when collaborative editing, a single undo history for the entire buffer doesn&#39;t work. When you undo, you expect to undo text that <em>you yourself typed</em>. Each participant needs their own undo stack. This means we need to be capable of undoing and redoing operations in an arbitrary order. A shared global stack of edit operations isn&#39;t enough.</p>
<p>Instead, we maintain an <em>undo map</em>, which associates operation ids with a count. If the count is zero, the operation has not been undone. If the count is odd, the operation has been undone. If it&#39;s even, the operation has been redone. Undo and redo operations simply update counts in this map for specific operation ids. Then, when we&#39;re deciding whether a certain fragment is visible, we first check if that insertion has been undone (its undo count is odd). We then check if it has any deletion tombstones, and whether the undo count of any of those deletions is even.</p>
<p>When sending undo/redo operations, it&#39;s fine to assign these undo counts directly. If two users both undo the same operation concurrently, they&#39;ll end up setting its undo count to the same value. This preserves their intent, since they both wanted to undo or redo it. In practice, we currently only allow users to undo their own operations, but we may eventually introduce the ability to undo operations of collaborators.</p>

<p>There&#39;s obviously a lot more to cover. How do we actually implement this scheme so that it&#39;s efficient? How do we integrate CRDTs into a broader system that creates the illusion of a shared workspace? How do we make this complex distributed system reliable? And what else can we do with CRDTs other than collaborate? Then there&#39;s the rest of the editor. Ropes. Our GPU-accelerated UI framework. Tree-sitter. The integrated terminal. And much, much more.</p>
<p>We&#39;re looking forward to talking about all of it in the months and years to come. And more importantly, we&#39;re looking forward to applying this technology to ship an editor that makes you happier and more productive. Thanks for reading!</p></div></div></div>
  </body>
</html>
