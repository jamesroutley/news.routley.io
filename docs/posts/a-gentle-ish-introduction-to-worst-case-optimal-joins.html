<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://justinjaffray.com/a-gentle-ish-introduction-to-worst-case-optimal-joins/?try=2">Original</a>
    <h1>A gentle-ish introduction to worst-case optimal joins</h1>
    
    <div id="readability-page-1" class="page"><div>
    

<p><small>30 May 2022</small></p><p>If you’ve been following databases in the past couple years, you’ve probably encountered the term
“worst-case optimal joins.”
These are supposedly a big deal, since joins have been studied for a long time,
and the prospect of a big shift in the way they’re thought about is very
exciting to a lot of people.</p>
<p>The literature around them, however, is primiarly aimed at theorists.
This post is as gentle and bottom-up as I can manage of an introduction to the main ideas behind them.
I am decidedly <em>not</em> a theorist, so much of this is probably oversimplified, but I hope the
perspective of someone whose background is in traditional query processing can provide some
useful insight to people outside the sphere of researchers working on this stuff.</p>
<p>A <em>relation</em> is a set of column names combined with a set of <em>rows</em>, where each row has a value for each column name.</p>
<p>This is a relation \(R\) with three rows, whose column names are \(\{\texttt{a}, \texttt{b}\}\).</p>
<table>
<thead>
<tr>
<th>\(\texttt a\)</th>
<th>\(\texttt b\)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>This is a relation \(S\) with four rows, whose column names are \(\{\texttt{b}, \texttt{c}\}\).</p>
<table>
<thead>
<tr>
<th>\(\texttt b\)</th>
<th>\(\texttt c\)</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>2</td>
<td>5</td>
</tr>
<tr>
<td>3</td>
<td>6</td>
</tr>
<tr>
<td>3</td>
<td>7</td>
</tr>
</tbody>
</table>
<p>The <em>join</em> of two relations is computed by taking every pair of rows from the
two relations and keeping the ones that agree on all columns with the same name.
The join’s column set is the union of the two input column sets.</p>
<p>The join of \(R\) and \(S\), written \(R \bowtie S\), is</p>
<table>
<thead>
<tr>
<th>\(\texttt a\)</th>
<th>\(\texttt b\)</th>
<th>\(\texttt c\)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>5</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>5</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td>6</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td>7</td>
</tr>
</tbody>
</table>
<p>There’s a bunch of equivalent ways to define the join of two relations,
but this one will work for us.
Joins are nice because they’re a way to algebraically represent the act of “looking things
up”: “for each row in side A, look up the corresponding value in side B that has the same column values.”</p>
<p>Here are some useful properties of joins:</p>
<ol>
<li>A join is commutative: \(R \bowtie S = S \bowtie R\).</li>
<li>A join is associative: \((R \bowtie S) \bowtie T = R \bowtie (S \bowtie T)\).</li>
</ol>
<p>Hopefully you don’t find these too hard to convince yourself of, but try running through some examples
if you don’t see why these should be true (remember we don’t care about the <em>order</em> of the columns in a relation).</p>
<p>There’s a natural way to extend the idea of a join to more than two tables: just
join them one at a time.
Since the operation is commutative and associative (useful properties 1 and 2), it doesn’t matter what order you do this in,
the result is well-defined.</p>
<p>A set of tables we wish to join this way is called a <em>join query</em>.</p>
<h2 id="answering-join-queries">Answering Join Queries</h2>
<p>Traditional database systems are typically only able to join two tables at once.
Since, as we saw, joins are commutative and associative, this is sufficient for them
to be able to answer join queries comprised of <em>many</em> tables: pick your two favourite tables
and join them
to get an <em>intermediate relation</em>, then join that with another table, and so on, until you’re left with
a single table, which is the result of the join query.</p>
<p>We represent this process of joining pairs of tables as a <em>join tree</em>, or <em>query plan</em>.</p>
<p><img src="http://justinjaffray.com/images/agm_tree1.png"/></p><p>This strategy of computing a join is called <em>binary joins</em>.
A well known fact among database people is that not all join trees are created equal.
Depending on the size of the intermediate relations, one join tree might be much more efficient to
compute than another.</p>
<p>If the intermediate join \(A \bowtie B\) is very large (say, if they had no columns in common),
we might compute a lot of rows that will end up getting discarded by the subsequent join with \(C\).</p>
<p>This discrepancy can be seen if we write out a hypothetical size for each possible intermediate join (\(I\) is the
<em>join identity</em>, having zero columns and one row):</p>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Row Count</th>
</tr>
</thead>
<tbody>
<tr>
<td>\(I\)</td>
<td>1</td>
</tr>
<tr>
<td>\(A\)</td>
<td>100</td>
</tr>
<tr>
<td>\(B\)</td>
<td>1000</td>
</tr>
<tr>
<td>\(C\)</td>
<td>2000</td>
</tr>
<tr>
<td>\(A \bowtie B \)</td>
<td>100000</td>
</tr>
<tr>
<td>\(B \bowtie C \)</td>
<td>10000</td>
</tr>
<tr>
<td>\(A \bowtie C \)</td>
<td>20</td>
</tr>
<tr>
<td>\(A \bowtie B \bowtie C \)</td>
<td>100</td>
</tr>
</tbody>
</table>
<p>While not a perfect indicator, this suggests that if we compute the total join by first computing \(A \bowtie C\), rather than
\(A \bowtie B\), we’ll probably end up processing fewer rows total.</p>
<p>Much work, both industrial and academic, has been done on the topic of picking the best join tree for
a given join query (I myself have <a href="https://www.cockroachlabs.com/blog/join-ordering-pt1/">written</a> about it
<a href="https://www.cockroachlabs.com/blog/join-ordering-ii-the-ikkbz-algorithm/">twice</a> already).</p>
<h2 id="joins-are-secretly-graph-processing-algorithms">Joins are Secretly Graph Processing Algorithms</h2>
<p>Here’s another perspective on joins: that they’re graph processing algorithms.</p>
<p>Say we had the same relations as before:</p>
<h3 id="r">\(R\)</h3>
<table>
<thead>
<tr>
<th>\(\texttt a\)</th>
<th>\(\texttt b\)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
</tr>
</tbody>
</table>
<h3 id="s">\(S\)</h3>
<table>
<thead>
<tr>
<th>\(\texttt b\)</th>
<th>\(\texttt c\)</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>2</td>
<td>5</td>
</tr>
<tr>
<td>3</td>
<td>6</td>
</tr>
<tr>
<td>3</td>
<td>7</td>
</tr>
</tbody>
</table>
<p>We can represent these tables as a graph with three independent sets of vertices:</p>
<p><img src="http://justinjaffray.com/images/agm_graph.png"/></p><p>If you enumerate all the paths that start from a vertex in \(\texttt{a}\), go to a vertex in \(\texttt{b}\),
and wind up on a vertex in \(\texttt{c}\), you’ll find that set of such paths is precisely \(R \bowtie S\).</p>
<p>What this means is that we can use joins to find structures in graphs.</p>
<p>Say I have the following graph:</p>
<p><img src="http://justinjaffray.com/images/agm_graph2.png"/></p><p>and I want to compute all the triangles (triplets of vertices which are all
connected to each other) in this graph.</p>
<p>We can represent this graph as a table containing its edge set:</p>
<h3 id="g">\(G\)</h3>
<table>
<thead>
<tr>
<th>\(\texttt{from}\)</th>
<th>\(\texttt{to}\)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>2</td>
<td>5</td>
</tr>
<tr>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>3</td>
<td>6</td>
</tr>
<tr>
<td>3</td>
<td>7</td>
</tr>
<tr>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>4</td>
<td>7</td>
</tr>
<tr>
<td>4</td>
<td>8</td>
</tr>
<tr>
<td>5</td>
<td>8</td>
</tr>
<tr>
<td>6</td>
<td>7</td>
</tr>
<tr>
<td>7</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>Now here’s the clever trick: we can join this table <em>with itself</em> twice, and, if we rename the columns appropriately,
out pops the set of triangles.</p>
<p>To prove this trick actually works, here it is in Postgres:</p>
<div><pre><code data-lang="sql"><span>CREATE</span><span> </span><span>TABLE</span><span> </span><span>g</span>(f<span> </span><span>INT</span>,<span> </span>t<span> </span><span>INT</span>);<span>
</span><span></span><span>INSERT</span><span> </span><span>INTO</span><span> </span><span>g</span><span>
</span><span></span><span>VALUES</span><span>
</span><span>        </span>(<span>1</span>,<span> </span><span>2</span>),<span> </span>(<span>1</span>,<span> </span><span>3</span>),<span> </span>(<span>1</span>,<span> </span><span>4</span>),<span> </span>(<span>2</span>,<span> </span><span>4</span>),<span> </span>(<span>2</span>,<span> </span><span>5</span>),<span>
</span><span>        </span>(<span>3</span>,<span> </span><span>4</span>),<span> </span>(<span>3</span>,<span> </span><span>6</span>),<span> </span>(<span>3</span>,<span> </span><span>7</span>),<span> </span>(<span>4</span>,<span> </span><span>5</span>),<span> </span>(<span>4</span>,<span> </span><span>7</span>),<span>
</span><span>        </span>(<span>4</span>,<span> </span><span>8</span>),<span> </span>(<span>5</span>,<span> </span><span>8</span>),<span> </span>(<span>6</span>,<span> </span><span>7</span>),<span> </span>(<span>7</span>,<span> </span><span>8</span>);<span>
</span><span></span><span>SELECT</span><span>
</span><span>    </span>g1.f<span> </span><span>AS</span><span> </span>a,<span> </span>g1.t<span> </span><span>AS</span><span> </span>b,<span> </span>g2.t<span> </span><span>AS</span><span> </span><span>c</span><span>
</span><span></span><span>FROM</span><span>
</span><span>    </span><span>g</span><span> </span><span>AS</span><span> </span>g1,<span> </span><span>g</span><span> </span><span>AS</span><span> </span>g2,<span> </span><span>g</span><span> </span><span>AS</span><span> </span>g3<span>
</span><span></span><span>WHERE</span><span>
</span><span>    </span>g1.t<span> </span><span>=</span><span> </span>g2.f<span> </span><span>AND</span><span> </span>g2.t<span> </span><span>=</span><span> </span>g3.t<span> </span><span>AND</span><span> </span>g1.f<span> </span><span>=</span><span> </span>g3.f;<span>
</span></code></pre></div><p>to which the answer is:</p>
<pre><code> a | b | c
---+---+---
 1 | 3 | 4
 1 | 2 | 4
 2 | 4 | 5
 3 | 6 | 7
 3 | 4 | 7
 4 | 7 | 8
 4 | 5 | 8
(7 rows)
</code></pre><p>Note that we oriented all the edges to point the same direction, from lower numbered vertices to higher, so
we don’t need to divide out by any kind of symmetry to get the distinct triangles.
You could also include each edge twice, once pointing each direction, and you’d get
each triangle six times in the output.</p>
<p>If we look at the query plan for how Postgres computed this result by running it
with <code>EXPLAIN</code>, we see that it used a binary join plan like we talked about
earlier (I cut out a lot of gunk to make this easier to read):</p>
<pre><code>               QUERY PLAN
----------------------------------------
Join ((g2.t = g3.t) AND (g1.f = g3.f))
    -&gt;  Join (g1.t = g2.f)
        -&gt;  Seq Scan on g g1
        -&gt;  Seq Scan on g g2
    -&gt;  Seq Scan on g g3
</code></pre><p>So it first joins <code>g1</code> and <code>g2</code>, then joins that with <code>g3</code>.</p>
<p>Now here’s the point of this whole exercise:</p>
<ul>
<li>it turns out that a graph with \(n\) edges will have no more than
\(O(n^{1.5})\) triangles in it (we’ll see why in a bit).</li>
<li>there are graphs where that first intermediate join will <em>always</em> have \(O(n^2)\) rows in it, <em>no matter which two tables we choose to join first</em>.</li>
</ul>
<p>What this means is that for this problem, <em>any</em> binary join
strategy will necessarily do more work than the theoretical minimum (where the
“theoretical minimum” is “the number of results we might have to emit”)
in some cases.</p>
<p>Resolving this issue is the crux of “worst-case optimal joins:” a “worst-case
optimal join algorithm” is one that asymptotically does no more work than the
maximum number of tuples that could be emitted from a join query.</p>
<p>As it turns out, such algorithms exist and
I’ve described one simple one in the appendix of this post.
As you might guess, the main idea is that instead of joining two tables at a time (since we’ve
seen that approach is doomed), we’re going to join all of the tables at once.
For the rest of this post I’d like to focus on something I think is more
interesting: <em>what is the worst-case runtime for any given join query</em>?</p>
<h2 id="what-_is_-the-theoretical-minimum">What <em>is</em> the Theoretical Minimum?</h2>
<p>Let’s try to come up with an easy bound on the number of rows a
join query can output.</p>
<p>The <em>query graph</em> of a join query has a vertex for every column name and an edge for every relation,
and that edge connects all the vertices in that relation (thus, it might be a “hyperedge,” connecting more than two
vertices).</p>
<p>Say I’m joining three tables, \(R\), \(S\), and \(T\), whose vertex sets are \(\{\texttt a,\texttt b\}\) for \(R\), \(\{\texttt b,\texttt c\}\) for \(S\), and \(\{\texttt a,\texttt c\}\) for \(T\).
The query graph for this query would look like this:</p>
<p><img src="http://justinjaffray.com/images/triangle_agm.png"/></p><p>(Observe that if we set \(R = S = T = G\) this is once again our triangle-finding join.)</p>
<p>In additional to the ones from before, let’s note some additional properties of joins:</p>
<ol start="3">
<li>The number of rows in a given join (written \(|R \bowtie S|\)) is no larger
than the product of the sizes of the two inputs (\(|R||S||\)), since in the
worst case, every pair of rows agree on their common columns: \(|R \bowtie S| \le |R||S|\).</li>
<li>If the column set of \(R\) is a subset of the column set in \(S\), then \(|R \bowtie S| \le |S|\).</li>
</ol>
<p>The first of these should be pretty easy to convince yourself of.
The second one is a little less obvious but still easy:
a given row from the table with more columns can match with at most one row in the table with fewer columns (since,
unlike in SQL, we’re requiring all of our rows here to be distinct),
so the join can only get smaller (because some rows didn’t have a match) or stay the same size (because every row had exactly one match).
To convince yourself of this, try joining the examples \(R \bowtie S\) and \(R\) above.</p>
<p>Because of property 3 above, we know the number of rows in \(R \bowtie S \bowtie T\) cannot be larger than \(|R||S||T|\).
But actually, we can do a little better.
If we join any two relations, say \(R\) and \(S\), that gives us the entire column set: \(R \bowtie S\) has column set
\(\{\texttt a, \texttt b,\texttt c\}\). And so by property 4, \(|R \bowtie S \bowtie T| \le |R \bowtie S| \le |R||S|\) (and the same is true for \(|R||T|\) and \(|S||T|\)).</p>
<p>In general, given a join query, once we’ve picked a set of relations that give the entire column set, joining in
the remaining relations <em>can only reduce the size of the result</em> due to property 4.</p>
<p>In the language of our query graph, such a set of relations is called an <em>edge covering</em>. We want to
choose some set of edges/relations \(E\) such that every vertex is incident to at least
one \(e \in E\).
If every vertex is adjacent to some relation, we’ve introduced every column to our query.
Then, the final size of our join can be no larger than the product of the sizes of the relations we picked (because of property 3).</p>
<p>We can express this symbolically.
This symbolic representation is going to look a bit unmotivated at first, but will make more sense
when we see how we’re going to generalize it.</p>
<p>If we are joining \(R_1, \ldots, R_n\), define \(x_i\) to be 1 if we picked \(R_i\), and 0 otherwise.
This is convenient since we can use \(|R_i|^{x_i}\) to be the size of \(R_i\) if we picked it and 1 otherwise.
For some column \(c\), let \(E_c\) be the set of relations that include \(c\).</p>
<p>So.
For each \(x_i\) we want
\[
x_i \in \{0, 1\}
\]
(“we either pick a relation, or we don’t”)</p>
<p>Then for each \(c\) we want
\[
\sum_{i \in E_c} x_i \ge 1
\]
(“each column is present in at least one picked relation”).</p>
<p>Then our bound is
\[
|R_1 \bowtie \ldots \bowtie R_n| \le \prod_{i = 1}^n |R_i|^{x_i}
\]
(“the number of rows in the result is no larger than the product of the sizes of the picked relations”)</p>
<p>This bound is not particularly tight: when applied to our triangle query, it only gets us to the
fact that the output is no more than \(n^2\) tuples.</p>
<p>Here’s the thing: there’s a natural but surprising generalization of this bound.
If this were a lecture, here’s the part where I would walk over to where I wrote
\[
x \in \{0, 1\},
\]
erase it, and rewrite
\[
x \in [0, 1].
\]</p>
<p>(that is, \(x\) need not be either 0 or 1, but can also be <em>any real number in between</em>)
A <em>fractional edge cover</em> is an assignment of values in \([0, 1]\) to each edge in a graph, such
that the sum of all weights adjacent to every vertex is at least 1.
If instead of finding an edge cover, we relax to allow a fractional edge cover, the bound <em>still holds</em>.
That is, we can change our decision for a given relation to be not just “take or not take” but “how much to take.”
This, in, theory, should allow us to get a tighter bound, since we now have strictly more options.</p>
<p>And indeed, this change allows us to get to the tight bound of our triangle query.
Rather than taking \(x_R = 1, x_S = 1, x_T = 0\), say,
we can take \(x_R = \frac12, x_S = \frac12, x_T = \frac12\).</p>
<p><img src="http://justinjaffray.com/images/triangle_agm.png"/></p><p>Now \(\texttt{a}\) gets \(\frac12\) weight from each of \(R\) and \(T\), for a total of 1,
\(\texttt{b}\) gets it from \(R\) and \(S\),
and
\(\texttt{c}\) gets it from \(S\) and \(T\).</p>
<p>We’ve still covered every vertex, but now this gives us that
\[
|R \bowtie S \bowtie T| \le
|R|^{\frac12}
|S|^{\frac12}
|T|^{\frac12}
= \sqrt { |R| |S| |T|},
\]</p>
<p>which, if as before, we set them all equal to our graph \(G\), gives us the \(n^{1.5}\) bound:
\[
\sqrt { |R| |S| |T|} = |G|^{1.5}
\]</p>
<p>This bound, where we permit a fractional edge cover, is called the <em>AGM Bound</em>, and it holds for any query graph.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I hope this post has made WCOJs a little less scary—it’s very cool to see new research in an area
that’s been around for so long.</p>
<p>But what’s the status of the hype?
If these things are so great, why haven’t we seen more widespread adoption?
Why has there not been a push to get WCOJs into something like Postgres, and
why aren’t more vendors loudly advertising their support of them?
Well, probably a bunch of confounding factors.</p>
<ul>
<li>The literature is pretty impenetrable. If you’re not willing to wade through a
lot of dense notation (or in my case, have friends who will help you do it),
it’s going to be very hard to get a grasp on what exactly is going on here.</li>
<li>Their applications are a bit unclear. The distribution of the various
shapes of query graphs and the level of speedups WCOJ algorithms get on them in
the real world is not obvious to me (though anecdotally, they’re not unheard of,
and queries that benefit show up in things like the Join Order Benchmark).
Places like RelationalAI are betting that people are going to want to query
knowledge graphs in particular, and these algorithms make those sorts of
queries tenable.</li>
<li>They require a lot of indexes. The Leapfrog Triejoin paper explicitly calls
out that they automatically install the requisite indexes for a given query in
their system, but this is not tenable for a lot of systems, like Postgres which
are used as a transactional system as well as an ad-hoc analytic database.
You really only want to use these in a dedicated analytic database.</li>
<li>They’re still young! There are very few systems making use of them at the moment
and whether or not they’ll prove to have been a good bet remains to be seen.</li>
</ul>
<p>At any rate, they’re a fun thing to think about.
If you like thinking about joins and databases and query languages you can have
a great time messing around with fancy, modern algorithms.</p>
<h2 id="appendix-proof-of-the-agm-bound">Appendix: Proof of the AGM bound</h2>
<p>Obviously none of the results I’m presenting here are novel, but it was a bit of a slog
for me to track down all the dependencies in the proofs I found in order to
follow the whole proof for myself (plus I read two or three version of
each to find one I liked), so included here is the “full” proof, where the bar
for inclusion was approximately “did I know this when I started researching this
or not.”</p>
<h3 id="random-variables-and-entropy">Random Variables and Entropy</h3>
<p>A <em>random variable</em> is an object that represents a distribution over some set of values.
You might think of it as something which permits you to “sample” it, and will
hand you objects according to some distribution, like how if you roll a six-sided die it will
hand you one of the values in \(\{1,2,3,4,5,6\}\) with uniform probability.</p>
<p>The <em>entropy</em> of a random variable is “the average information you get from observing one of these values.”
If an event \(e\) has probability \(p\) of occurring, the amount of information you learn from observing it is
\[
\log \frac1p
\]
and so the entropy of a given random variable \(R\), written \(H[R]\) is the average over all such events, weighted by how likely they are to occur:
\[
H[R] = \sum_{e \in R} p(e)\log \frac1{p(e)}
\]</p>
<p>(note that all the logarithms used here are base-2 logs.)</p>
<p>Why am I talking about entropy here, where we’re doing nothing random?
Well, it just turns out to be useful in this kind of problem where we’re trying
to bound how complex something can be, and in combinatorics in general.
Check out <a href="https://www.youtube.com/watch?v=qYmsdwQ6WLA">Tim Gowers&#39;</a> video series if you’d like to see
someone much smarter than me talk about it.</p>
<p>We really only need one important fact about entropy that you can take on faith (but is not too hard to be convinced of):</p>
<p>If a discrete random variable \(R\) has \(n\) potential outcomes, its entropy \(H[R]\) is maximized when \(R\)
follows a uniform distribution.
That is, every outcome is equally likely.</p>
<h3 id="conditional-entropy-and-the-chain-rule">Conditional Entropy and the Chain Rule</h3>
<p>Say I have two random variables which are not necessarily independent.</p>
<p>The <em>conditional entropy of \(X\) given \(Y\)</em>, written \(H[X|Y]\),
is the entropy of \(X\) assuming we already know the value of \(Y\),
and it is defined as
\[
\begin{aligned}
H[X | Y]
&amp;=
\sum_{y \in Y}
P(Y = y)
H[X | Y =y] \cr
&amp;= H[X, Y] - H[Y]
\end{aligned}
\]</p>
<p>Another way to think of this is that sampling \((X, Y)\) is equivalent to sampling \(Y\) and then \(X\).
So the entropy of \((X, Y)\) is the entropy of \(Y\), plus the entropy of \(X\) given that we know \(Y\) already.
\[
\begin{aligned}
H[X, Y] &amp;= H[Y] + H[X | Y] \cr
H[X|Y] &amp;= H[X,Y] - H[Y] \cr
\end{aligned}
\]</p>
<p>The <em>chain rule for entropy</em> is just repeated application of this to a set of random variables:
\[
H[X_1, \ldots, X_n]
= \sum_{i=1}^n H[X_i|X_1, \ldots, X_{i-1}]
= \sum_{i=1}^n H[X_i|X_{&lt;i}]
\]</p>
<h3 id="shearer">Shearer</h3>
<p>Say I take a random variable and split it up.
Like, if I roll a six-sided die, and I tell Alice whether it was greater than 3, and I tell Bob
what its value modulo 3 was.
Together, Alice and Bob can reconstruct the original roll of the die:</p>
<table>
<thead>
<tr>
<th>Roll</th>
<th>Alice</th>
<th>Bob</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>&lt;</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>&lt;</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>&lt;</td>
<td>0</td>
</tr>
<tr>
<td>4</td>
<td>&gt;</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>&gt;</td>
<td>2</td>
</tr>
<tr>
<td>6</td>
<td>&gt;</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>So, we can split up this die random variable \(R\) into \(R_1, R_2\), where \(R_1\)
is the value Alice sees, and \(R_2\) is the value Bob sees.</p>
<p>It stands to reason that the amount of information learned by Alice plus the amount of information learned by Bob
is no less than the information learned by someone with the original value, since they together can
reconstruct that original value.</p>
<p>So, that is,
\[
H[R] \le H[R_1] + H[R_2]
\]</p>
<p>I might give them <em>more</em> information than necessary. I might also tell Alice if the value was even or odd.
In this case, \(H[R] &lt; H[R_1] + H[R_2]\).</p>
<p>In general, if I can split up a random variable \(R\) into a bunch of parts \(R_1, \ldots, R_n\) that imply the original random variable,
\[
H[R] \le \sum_{i = 1}^n H[R_i].
\]</p>
<p>This is nothing surprising: it just says if I split up a piece of information
into a bunch of smaller pieces of information that might overlap, the sum of the
information contained in each of those is at least as much as the original
piece.</p>
<p>Now once again, take a random variable \(R\) and split it up this way into \(R_1, \ldots, R_n\),
and say we have a hypergraph with \(R_1, \ldots, R_n\) as its vertex set and \(\mathcal{E}\) as its
edge set.
To be clear, I’m saying that we have \(\mathcal E\) which is a set of subsets of \(\{R_1, \ldots, R_n\}\).
This is analogous to our query graph, where each \(R_i\) is a vertex and each \(e \in \mathcal E\) is a relation.</p>
<p>Now say we have a fractional cover of \(R\).
That is, an assignments \(w_e \in [0, 1]\) to each \(e \in \mathcal E\) such that
every \(R_i\) is “covered” by at least 1 total weight.
For each \(i\) let \(\mathcal E_i\) be the set of edges containing \(R_i\), then for every \(i\) we require:
\[
\sum_{e \in \mathcal E_i} w_e \ge 1
\]</p>
<p>For example, say we had the following set of hyperedges for \(R = (R_1, R_2, R_3, R_4, R_5)\):
\[
\begin{aligned}
a &amp;= \{R_1, R_3\} \cr
b &amp;= \{R_2, R_5\} \cr
c &amp;= \{R_1, R_2\} \cr
d &amp;= \{R_4, R_3, R_5\} \cr
\end{aligned}
\]</p>
<p>You might think of this like a table:</p>
<table>
<thead>
<tr>
<th>\(e\)</th>
<th>\(R_1\)</th>
<th>\(R_2\)</th>
<th>\(R_3\)</th>
<th>\(R_4\)</th>
<th>\(R_5\)</th>
</tr>
</thead>
<tbody>
<tr>
<td>\(a\)</td>
<td>X</td>
<td></td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>\(b\)</td>
<td></td>
<td>X</td>
<td></td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>\(c\)</td>
<td>X</td>
<td>X</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>\(d\)</td>
<td></td>
<td></td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
</tbody>
</table>
<p>or a picture:</p>
<p><img src="http://justinjaffray.com/images/agm_hypergraph.png"/></p><p>If \(w\) is such a covering, then <strong>Shearer’s Inequality</strong> states</p>
<p>\[
H[R] \le \sum_{e \in \mathcal{E}} w_e H[e]
\]</p>
<p>where \(H[e]\) is the entropy of the random variables present in \(e\).
Basically this says that if we’ve covered every constituent random variable,
then taking the sum of all edges weighted by their assigned weights gives us
an upper bound to the entropy in the original random variable.</p>
<h4 id="proof-of-shearers-lemma">Proof of Shearer’s Lemma</h4>
<p>By the chain rule, for each \(e = \{q_1, \ldots, q_m\} \in \mathcal E\)
(where each \(q_i\) is an index of an \(R_j\), and the \(q_i\)s themselves
are increasing.
\[
H[e] =
\sum_{i=1}^m H[R_{q_i} | R_{q_{&lt;i}}] \ge
\sum_{i=1}^m H[R_{q_i} | R_{&lt;q_i}]
\]</p>
<p>The inequality holds because we are conditioning on more things in each term, which cannot increase the entropy.</p>
<p>Coming back to what we are trying to prove,</p>
<p>\[
H[R] \le \sum_{e \in \mathcal{E}} w_e H[e]
\]</p>
<p>If we were to expand the LHS according to our other inequality, we would find that each \(H[R_i | R_{&lt;i}]\) occurs
exactly once.
If we were to expand the RHS, since \(w\) is a cover, each \(H[R_i | R_{&lt;i}]\) would occur with coefficient _at least_ 1,
which prove Shearer.</p>
<h3 id="putting-it-all-together">Putting it all Together</h3>
<p>For a relation \(X\), let \(R_X\) be a random variable representing selecting a row from \(X\)
uniformly at random. Then</p>
<p>\[
H[R_X] = \sum_{x \in X} p(x) \log \frac1{p(x)} = \log |R_X|
\]</p>
<p>Now take the join \(Q = X_1 \bowtie \ldots \bowtie X_n\).
Projecting to the subset of the columns in \(Q\) which are in \(X_i\) gives
a row from \(X_i\), due to the way the join works.
So this is a new random variable which gives a row from \(R_i\).
This one might not be uniform, but recall that entropy is maximized when we <em>do</em>
have a uniform distribution, so we still have an upper bound.</p>
<p>Thus, we can partition up \(R_Q\) into a set of random variables like we
did with Shearer, into the join tables:
\[
R_Q = (R_{X_1}, \ldots, R_{X_n})
\]
Like before, the right hand side contains all the information in the left hand side: since every column is present
we can determine what the original row in \(Q\) was.</p>
<p>So, take a fractional edge cover \(w\) of the query graph,
then, by Shearer:
\[
\begin{aligned}
H(R_Q)
&amp;= H(R_{X_1}, \ldots, R_{X_n}) \cr
&amp;\le \sum_{i=1}^n w_i H(R_{X_i}) \cr
&amp;\le \sum_{i=1}^n w_i \log |R_i| \cr
&amp;= \sum_{i=1}^n \log |R_i|^{w_i} \cr
&amp;= \log \prod_{i=1}^n |R_i|^{w_i} \cr
\end{aligned}
\]</p>
<p>so</p>
<p>\[
\begin{aligned}
H(R_Q) &amp;\le \log \prod_{i=1}^n |R_{X_i}|^{w_i} \cr
\log|R_Q| &amp;\le \log \prod_{i=1}^n |R_{X_i}|^{w_i} \cr
|R_Q| &amp;\le \prod_{i=1}^n |R_{X_i}|^{w_i} \cr
\end{aligned}
\]
which is exactly the AGM bound.</p>
<h2 id="appendix-a-worst-case-optimal-triangle-finder">Appendix: A Worst-Case Optimal Triangle Finder</h2>
<p>A fully generic implementation of WCOJs has a lot of tedious bookkeeping, so we’ll just
talk about a very simple triangle counter that doesn’t generalize (but could, with some
elbow grease).</p>
<p>The simplest algorithm I’ve seen is
“Algorithm 2” from <a href="https://arxiv.org/pdf/1310.3314.pdf">Skew Strikes Back</a>.
It’s more or less the same as the presentation as in <a href="https://arxiv.org/pdf/1210.0481.pdf">Leapfrog Triejoin</a>.</p>
<p>To compute the query
\[
Q(a, b, c) \leftarrow R(a, b), S(b, c), T(a, c).
\]
We’re going to first iterate over the values of \(a\) which are present in both \(R\) and \(T\),
then for those values of \(a\) we will iterate over the values of \(b\) which are present in both \(R\) and \(S\) given
that value of \(a\),
and then finally iterate over the values of \(c\) which are present in \(S\) and \(T\) for those values of \(a\) and \(b\).</p>
<p>The algorithm is approximately this:</p>
<pre><code>for each a in intersect(R, T):
  for each b in intersect(R[a], S):
    for each c in intersect(S[b], T[a]):
      emit((a, b, c))
</code></pre><p>The thing we’re doing here that’s different from a binary join approach is that
we’re proceeding not by a <em>relation</em> at a time, but a <em>variable</em> at a time.
We first fix \(a\), then \(b\), then \(c\), and then once there’s nothing left to fix, we must have found a triangle.</p>
<p>We could fix them in a different orders, which might have an impact on the runtime, but it turns out regardless of the ordering,
this algorithm is worst-case optimal (and I point you at either of the two linked papers if you want more proof of that fact).</p>
<p>You can see an implementation
<a href="https://github.com/justinj/triangle-counter/blob/master/src/main.rs">here</a>.</p>
<p>On my laptop this implementation ran about three times as fast as Postgres
for a 2000 vertex random graph (and the gap only widens from there).</p>
<h2 id="references">References</h2>
<ul>
<li>Leapfrog Triejoin <a href="https://arxiv.org/abs/1210.0481">https://arxiv.org/abs/1210.0481</a></li>
<li>Skew Strikes Back <a href="https://arxiv.org/abs/1310.3314">https://arxiv.org/abs/1310.3314</a></li>
</ul>


  </div></div>
  </body>
</html>
