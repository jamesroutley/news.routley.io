<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://freeman.vc/notes/falling-for-kubernetes">Original</a>
    <h1>Falling for Kubernetes</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p>I&#39;ve considered myself a strong kubernetes skeptic in the past. Bare metal is always my first choice both for projects and startups. That includes the <a href="https://freeman.vc/notes/architecting-a-blog">stack</a> that runs this blog. Calling it a stack might even be an exaggeration. It&#39;s a CI toolchain with an nginx configuration on the host. But it does its job, can handle surprising concurrent load, and is cheap to host. It costs just $10 a month and can likely go side by side with corporate blogging platforms that cost two orders of magnitude more to host. Premature optimization might be the root of all evil but so is premature scale.</p>
<p>I&#39;m convinced that companies over complicate their architecture prematurely, which leads to headaches for engineers and instability for users. A monorepo with a simple server should be the default place to start. Run a basic docker instance to minimize dependency hell and make sure your remote configuration is reproducible on your local development machines. Run a few daemons either in Docker or with cron scripts. Set and forget your iptables and firewall to something reasonable. If you need to grow your traffic rent a more powerful server. When that <em>really</em> doesn&#39;t cut it, deploy a simple load balancer that routes to a few backend boxes. In the early days that can and should be it.</p>
<p>But recently I&#39;ve grown out of a physical server behind a load balancer for a few side projects. The specific friction came from needing to spin up and spin down a data processing cluster. It would be idle for the majority of its lifespan but needs to burst to tens of VMs with attached GPUs. This forced my hand to adopt a more complicated server management solution. And after a couple months of building for kubernetes, I must admit I&#39;m falling for it more every day.</p>
<h2>Day 1: Playing hard to get</h2>
<p>I already had a fully functioning backend application on bare metal. Was I really going to re-architect my stack with something different? Especially an over-powered solution like k8? Not if I had anything to say about it.</p>
<p>I instead tried to setup a cluster using instance templates and managed groups, Google&#39;s equivalent to Amazon&#39;s ECS. Spinning up a basic cluster from the console was relatively straightforward, but I needed some custom logic to handle the spinning up and spinning down while updating shas. I switched this to a Github Actions pipeline written as a python library. After grueling over the GCP documentation, I got a solution working but it definitely had some quirks.</p>
<ol>
<li>
<p>The lion-share of the necessary deployment code could be implemented with standard google client library functions. This was nice for the parameter type checking and object orientation. However there were some commands that were unsupported in the <code>pypi</code> library. For these I proxied to the direct REST webservice that GCP exposes. Why this mismatch exists, I&#39;m not sure. But confusing during development to juggle between two similar yet different API formats. Still not a crazy compromise to make.</p>
</li>
<li>
<p>This deployment needed to serve docker images on boot-up, which instance templates <em>do</em> support. However they <em>don&#39;t</em> support them via API, only in the web console or the CLI. Implementing container services through REST calls required inspecting the gcloud network traffic and copying a yaml file that&#39;s included in the instance creation payload. It came with a comment warning that this yaml should not be copied since changes are not semantically versioned and can change at any time. A bit risky but probably okay.</p>
</li>
<li>
<p>It started feeling like I was re-implementing core server logic. Someone has <em>definitely</em> solved this before. Probably a thousand times. I was able to shrug that off given the relatively simple scope but it kept nagging at me.</p>
</li>
</ol>
<p>The dealbreaker was the price tag. I needed to deploy two of these clusters with different containers, which needed to be fronted by internal load balancers. This allowed the main backend server to communicate with a static API endpoint and distribute load. These two load balancers were in addition to the existing load balancer that routes the backend traffic. Storage costs also started multiplying since I needed to leave some buffer on top of the default provisioned hard-drive. Run rate during the testing of this infrastructure spiked to $28 a day even with zero active data processing machines running. Trivial for a company with funding to burn, unsustainable for my wallet.</p>
<h2>Day 2: Kubernetes, how do you do?</h2>
<p>Clearly, the Google bare metal approach wasn&#39;t looking promising. It required too much manual glue and was too expensive for this particular project. I started looking at other hosted offerings.</p>
<p>If I refactored the compute heavy portion of this separate data management cluster, I could probably separate the data processing from the ML. However, all offerings I looked at only offered reserved GPUs. You select the hardware configuration and they spawn a VM or dedicated server. There was no notion of dynamic scaling when you have requests pending. They had better chips per dollar than Google does but otherwise it&#39;s the same structure of dedicated compute. For this deployment there would be more idleness than utilization, so that was a non-starter.</p>
<p>I reluctantly dove into the kubernetes stack, starting with the docs and then building out a POC cluster with the core elements of the scaling logic. I didn&#39;t even focus on getting the actual applications deployed; I was only prioritizing the infrastructure configuration. This was a great way to get my hands dirty with the design decisions that k8 makes.</p>
<h2>Day 3: The cost of dinner</h2>
<p><img alt="" src="https://freeman.vc/images/falling-for-kubernetes-billing.png"/></p>
<p>Both GCP and AWS charge around $70 a month for the kubernetes control panel. Each managed kubernetes cluster bundles a control panel, so it sets a floor on the cost of doing business even before compute. This caused an <a href="https://news.ycombinator.com/item?id=22485625">uproar</a> when GCP added this paid management fee, since many organizations spun up separate clusters for staging, testing, etc. and the costs multiplied accordingly. Azure is the only major provider that still has free control panels but I found its managed offering to have fewer features than the other two. Also, cartels being what they are, I wouldn&#39;t count on their control panels staying free forever.</p>
<p>GCP still offers one free control panel in a single zone. You don&#39;t have the redundancy of multi-zone fallback so it&#39;s advertised mainly for beta testing. That said - this single zonal support is the same as dedicated servers. With bare metal you&#39;re hosted out of whatever zone hosts your box. If that zone has an issue (or if your underlying server does), you&#39;re out of luck. The second you need multiple region load balancing on bare metal because of user or client commitments to reliability, you&#39;re looking at doubling your hardware costs. In this setting a management fee is likely a small overall piece of your spend.</p>
<p>Even with the management fees, setting up a managed cluster can still be meaningfully less expensive than rolling your own cluster with cloud specific offerings. An internal load balancer on GCP will cost $18 a month, and rolled out to 4 services to create an internal DNS mesh will already beat the cost of the control panel. I got close to that with my from-scratch prototype just using a simple combination of google offerings.</p>
<p>I&#39;ve started hosting all of my projects in this free zonal cluster and adding namespaces where I want to compartmentalize between them. So far it&#39;s been fully reliable with no downtime. Costs average around $6 a day without ML compute. The bulk of this (85%) is compute, memory, and storage for a 3x CPU, 11.25GB memory cluster. The remainder is bucket storage and docker image artifact hosting. Once it hits the <a href="https://cloud.google.com/compute/docs/instances/signing-up-committed-use-discounts">sustained use</a> threshold, this should be comparable to a dedicated box from a host like <a href="https://www.linode.com/pricing/">linode</a>.</p>
<h2>Day 4: A dictionary date</h2>
<p>I found a helpful mental model for kubernetes is thinking of container orchestration as actions placed on different primitives. Some primitives:</p>
<ul>
<li>A <strong>pod</strong> is a docker container, or containerized application logic.</li>
<li>A <strong>service</strong> controls duplicate copies of the same pod, so you&#39;re ensured redundancy if one pod crashes during hosting.</li>
<li>An <strong>ingress</strong> controller defines how exterior connections, like a regular web request, flow into the cluster and to the correct service.</li>
<li>A <strong>node</strong> is the physical hardware, an actual server running 1+ pods.</li>
<li>A <strong>cluster</strong> is a grouping of one or more nodes that share similar characteristics, which pods to place where and so forth.</li>
</ul>
<p>And some actions:</p>
<ul>
<li>To <strong>get</strong> a list of the instances available under one primitive.</li>
<li>To <strong>describe</strong> the definition of these elements and view the current status.</li>
<li>To view <strong>logs</strong> of an active or failed object.</li>
</ul>
<p>Everything resolves around these logical objects. Most of these entities have the same CLI behavior associated with them:</p>
<div><pre><span></span><span>$</span> kubectl get pod
<span>NAME                                           READY   STATUS    RESTARTS   AGE</span>
<span>backend-deployment-6d985b8854-45wfr            1/1     Running   0          18h</span>
<span>backend-deployment-6d985b8854-g7cph            1/1     Running   0          18h</span>
<span>backend-deployment-6d985b8854-mqtdc            1/1     Running   0          18h</span>
<span>frontend-deployment-5576fb487-7xj5r            1/1     Running   0          27h</span>
<span>frontend-deployment-5576fb487-8dkvx            1/1     Running   0          27h</span>
<span>frontend-deployment-5576fb487-q6b2s            1/1     Running   0          27h</span>

<span>$</span> kubectl get service
<span>NAME               TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE</span>
<span>backend            ClusterIP   10.171.351.3     &lt;none&gt;        80/TCP     34h</span>
<span>frontend           ClusterIP   10.171.334.28    &lt;none&gt;        80/TCP     34h</span>
<span>kubernetes         ClusterIP   10.171.310.1     &lt;none&gt;        443/TCP    4d23h</span>
</pre></div>
<p>Naturally each command will show different metadata depending on the logical object. Inspecting pods will show the running docker container version and the healthcheck result. Deployments will show the current redundancy of images and the health of the cluster. Services will provide the DNS address for other services to access the internal load balancer. The advantage of this logical object approach is that it makes API discovery accessible. You can avoid the combinatoric explosion by memorizing the actions (get, describe) and the objects (pods, services) and combine them to access the data you want.</p>
<p>The primitives that kubernetes provides have some opinionation as to how servers typically operate. There&#39;s a separate notion of pods and services, for instance, since services provide some built in load balancing across multiple pods. You could easily write this logic yourself with a separate pod and sniffing the local kubernetes API for the IP addresses of pods within the same group. But services are commonly used enough that kubernetes refactors this into a separate object type. In general, the abstractions are small shims on top of the most common of server functionalities: running processes, accepting inbound connections, running daemons. This makes it easy to do what you&#39;re already doing within the new tooling. There&#39;s a leaning curve to the terms but not the core concepts.</p>
<h2>Day 5: Meet the friends</h2>
<p>My strongest appreciation for kubernetes is it abstracts server concepts across cloud hosts. Whether you host with GCP, AWS, or Azure, you&#39;re going to have raw compute (nodes) where you want to run containers (pods) and occasionally one-off scripts (jobs). Especially with managed kubernetes configurations, a cloud provider takes care of writing the translation layer between the kubernetes logical objects and the physical hardware. If you want a new box spun up, you can push a helm configuration for a new node in your cluster and the cloud provider will take care of the rest. While it doesn&#39;t make cloud migrations completely seamless, it certainly treats cloud hosting as a more commoditized utility and avoids some vendor lock-in of writing custom cloud integration code.</p>
<p>Everything comes down to the kubernetes API. From my experience, this interface layer is at the perfect level of abstraction regardless of your size. You don&#39;t have to worry about the underlying management utilities that are themselves bootstrapping the disk or machine. The APIs follow a clear <a href="https://kubernetes.io/docs/reference/using-api/deprecation-policy/">deprecation</a> schedule so you can reliably integrate business logic within a larger pipeline. Push deployment changes in CI, spin up nodes via cron jobs, etc. All has the same conventional API behind it.</p>
<p><em>Everything</em> is programatic. Even kubectl (the local cluster management utility) is just an abstraction layer on top of the APIs that are hosted within the cluster. This means that you can program anything you can do manually, and if you can program it, you can automate it. Most of the servers that I&#39;ve managed before have been ~95% automated. There&#39;s a primary bash script that does most of the environment setup. But there&#39;s still some manual work you need to do: updating nginx filesystem configurations, configuring iptables, etc. Since every linux version is a bit different you also end up changing this script when you periodically upgrade the underlying OS.</p>
<p>The API lets your runbooks become completely programatic. Instead of writing documentation to triage well-known issues or run commands with the cluster, you can walk on-call/SRE engineers through a programatic guide. One common need is checking whether git branches have been successfully deployed. If you tag your docker images with the sha, the easy way is checking whether the shas are identical. Normally, this would require some remote <code>ssh/docker</code> wrangling or exposing the hosted sha within some API endpoint. Automatable? Sure. Trivial? Not so much. And if it&#39;s not trivial it&#39;s probably going to end up buried in a confluence doc.</p>
<p>Instead, the kubernetes API makes it <em>much</em> easier to write logic like this and bundle these into an installable package. This makes on-call common triage actions discoverable and walks users through the commands themselves. Here&#39;s an example from my utilities:</p>
<div><pre><span></span><span>$</span> on-call

<span>Usage: on-call [OPTIONS] COMMAND [ARGS]...</span>

<span>Options:</span>
<span>  --help  Show this message and exit.</span>

<span>Commands:</span>
<span>  check-health                      Check service health</span>
<span>  bootstrap-database                Run initial database setup</span>
<span>  ...</span>
</pre></div>
<div><pre><span></span>$ on-call check-health --app frontend

1. Checking uptime (`yes` to confirm):
&gt; yes
<span>The application has been stable for 465 minutes.</span>

2. Checking sha matches (`yes` to confirm):
&gt; yes
Latest github sha: 86597fa
Latest deployed sha: 8d3f42e
<span>Mismatching shas...</span>
</pre></div>
<p>Most organizations don&#39;t have a strong programatic culture with internal tools. This is typically more about the <a href="https://freeman.vc/notes/treat-engineers-as-users">friction</a> of solving the problem than the cultural commitment or technical skill itself. Kubernetes&#39; intuitive and well documented APIs decrease this friction to the point where it is realistic to automate much of the repetitive deployment and triage processes.</p>
<h2>Day 6: Specialization of labor</h2>
<p>Architecturally, I still think monolith architectures are the ways to go. But that&#39;s a topic for another day. Even microservice fanatics would cede the point that sometimes you need services to be bound to the underlying compute. This is especially true in ML distributions that are hardware accelerated on a GPU. You can typically only mount one cluster of GPUs per hardware box, so the constraint is at the node level not for the pod.</p>
<p>With the combination of taints and tolerances, it&#39;s easy enough to assign a pod to an independent hardware instance. By default, pods will be placed wherever there is appropriate memory and CPU space. Taints and tolerances customize this behavior. I think of taints as oil and water because they repel default pod assignments. Tolerances are more like oil and oil where they can permit pods to launch on those nodes with taints. Configuring taints and tolerances in the right way can bijectively lock 1 pod to 1 node.</p>
<p>This returns us fully to the paradigm that bare metal hosts one service and that&#39;s it. This is a useful mental model when you&#39;re designing for containers that should use the full resources of the box that they&#39;re running on. At the extreme it allows us to only use kubernetes as the load balancing layer that connects services and for the abstraction layers for the management APIs. You can keep the monoliths and delegate other tasks more easily.</p>
<h2>Conclusion</h2>
<p>I remain bullish on monoliths on bare metal, powerful servers. But after this initial dive into k8, I&#39;m tempted to say that whenever you <em>need</em> multiple servers working in tandem, you should use kubernetes. Keep it managed since that legitimately becomes a reliability headache. But fears of kubernetes being overkill seem overblown. Concerns instead seems tied to a more fundamental concern with writing microservice architectures.</p>
<p>There I agree. But by separating the two, you can get the best of both worlds. A simple codebase to prioritize feature delivery. A flexible yet programmatically controllable hardware architecture. Kubernetes can fade into the background more easily than I expected. That lets us focus on delivering the primary value: our application.</p>
        </div></div>
  </body>
</html>
