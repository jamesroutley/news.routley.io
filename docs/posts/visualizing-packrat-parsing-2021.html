<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dubroy.com/blog/visualizing-packrat-parsing/">Original</a>
    <h1>Visualizing Packrat Parsing (2021)</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
		<div>
			
			<p><small>January 10, 2021
            </small></p><p><a href="https://ohmlang.github.io/">Ohm</a> is an open-source parsing toolkit for JavaScript which <a href="http://www.tinlizzie.org/~awarth/">Alex Warth</a> and I have been working on since 2014. You can use it to parse custom file formats or quickly build parsers, interpreters, and compilers for programming languages.</p>
<p>This article is not about Ohm itself, but about the <strong>Ohm visualizer</strong>, which I designed and built in 2015 while working on Alex‚Äôs team at CDG.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> Later, the team expanded the visualizer into the <a href="https://ohmlang.github.io/editor/#30325d346a6e803cc35344ca218d8636">Ohm Editor</a>, which we continued to actively develop over the years. The editor itself has been <a href="https://ohmlang.github.io/pubs/live2016/">presented before</a>, so I‚Äôll focus specifically on the visualization here.</p>
<p>Creating the visualization was one of the most difficult and interesting design challenges I‚Äôve ever tackled ‚Äî so it‚Äôs been rewarding to hear from people who have found it to be helpful:</p>
<blockquote data-conversation="none" data-theme="light"><p lang="en" dir="ltr">Hey, I used Ohm for the first time a couple days ago.</p>‚Äî Anselm Eickhoff (@ae_play) <a href="https://twitter.com/ae_play/status/1347325515770826757?ref_src=twsrc%5Etfw">January 7, 2021</a></blockquote>


<h2>The Problem</h2>
<p>Ohm is based on <a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar">parsing expression grammars</a> (PEGs), which are a formal way of describing syntax, similar to regular expressions and context-free grammars. Like other PEG-based tools, it uses <em>packrat parsing</em>, a form of top-down parsing with unlimited lookahead.</p>
<p>One of Ohm‚Äôs main goals is ease-of-use ‚Äî¬†not only for the end users of languages, but also for grammar authors. And debugging grammars can be a notoriously painful. So I designed and built an interactive visualization that makes the entire execution of the parser visible and tangible. This lets grammar authors <em>follow the flow</em><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> rather than ‚Äúplaying computer‚Äù and trying to simulate the execution in their head.</p>
<p>When creating or debugging a grammar, there are a few things you might be interested in:</p>
<ul>
<li>If the parse succeeded‚Ä¶<ul>
<li>‚Ä¶what does the parse tree look like?</li>
<li>Did it parse the input the way I intended? If not, why not?</li>
</ul>
</li>
<li>If the parse failed, why did it fail?</li>
</ul>
<p>Initially, I explored two different design directions: one focused on the output (the parse tree), and another that focused on the algorithm execution. The big challenge was to come up with a design that could do both.</p>
<p><em><strong>Note:</strong> You can try out all the examples here online in the <a href="https://ohmlang.github.io/editor/">Ohm Editor</a>.</em></p>
<h2>Visualizing Parse Trees</h2>
<p>To visualize the parse tree, I chose a variant of the icicle plot (<a href="http://www.jstor.org/stable/2685881?seq=1">Kruskal and Landwehr 1983</a>). Some people may be more familiar with the <a href="http://www.brendangregg.com/flamegraphs.html">flame graphs</a> used in software profilers, which are basically inverted icicle plots.</p>
<p>Each node is represented by a <span>gray rectangle</span>, with its children directly below it. A <span>dashed bottom border</span> indicates a node with hidden children. You can click on a node to show or hide its children.</p>
<p>Unlike most icicle plots, the absolute width of a box is not meaningful ‚Äî only its width and position relative to the input text. Nodes always sit directly below the input text they consumed.<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> This is emphasized by highlighting the relevant portion of the input when the cursor is over the node:</p>
<p><img src="https://dubroy.com/blog/images/arithmetic-parse-tree-hover.png" width="320px"/></p>
<p>This means that the node must be at least as wide as its consumed input. We also ensure that the nodes are always wide enough to display the full label. So unlike most hierarchicial visualizations, there‚Äôs no need to hover over a node to see its label.</p>
<p>To satisfy both of these width constraints, the layout algorithm will expand the letter spacing of the input text where required:</p>
<figure>
<img src="https://dubroy.com/blog/images/expand-collapse-node.gif"/>
<figcaption>Expanding and collapsing a node.</figcaption>
</figure>

<h2>Visualizing the parser execution</h2>
<p>A parse tree visualization can help you understand what the parse tree looks like, but only if the parse succeeded. If the input failed to parse, or if the parse tree is not what you intended, you‚Äôll want to understand <em>why</em>.</p>
<p>To answer this question, I designed the ‚Äúexplain parse‚Äù feature, which shows a visual explanation of the parser‚Äôs execution. This can be enabled via the option panel in the lower right corner:</p>
<p><img src="https://dubroy.com/blog/images/explain-parse-checkbox.png"/></p>
<p>Like other PEG-based tools, Ohm uses <a href="https://en.wikipedia.org/wiki/Recursive_descent_parser">recursive-descent parsing</a>. A useful property of recursive-descent parsing is that parser‚Äôs execution (e.g. as represented by a dynamic call graph) has a very similar structure to the parse tree. This made it possible to design a single visualization that serves both purposes.</p>
<p>Let‚Äôs take a simple grammar for parsing credit card expiry dates. The animation below shows a trace of the logical steps taken to parse the input ‚Äú08/24‚Äù.</p>
<figure>
<img src="https://dubroy.com/blog/images/explain-parse-expiry.gif"/>
<figcaption>Stepping through the parse of ‚Äú08/24‚Äù.</figcaption>
</figure>

<p>You can see that the tree is built in a top-down, left-to-right manner. Each non-leaf node is visited twice: once on the way down, and again on the way up. This is the basic structure of recursive-descent parsing. </p>
<p>In this extremely simple example, every step taken by the parser succeeds. So the execution trace looks <em>exactly</em> like the parse tree. This is not usually the case. Let‚Äôs take a look at a more complex example:</p>
<p><img src="https://dubroy.com/blog/images/parse-tree-and-grammar.png"/></p>
<p>In this example, several steps in the parsing failed to match any input (shown with <span>red labels</span>). This doesn‚Äôt mean something went wrong ‚Äî this is just part of the way that a packrat parser works. The screenshot above shows two different types of match failure that can happen:</p>
<ol>
<li>Failed branches of an <a href="https://github.com/harc/ohm/blob/master/doc/syntax-reference.md#alternation">alternation expression</a>, as seen under <code>idFirst</code>. The parser first attempts to match an underscore (<code>&#34;_&#34;</code>), which fails, before successfully matching <code>letter</code> on the second branch.</li>
<li>The last child of an <a href="https://github.com/harc/ohm/blob/master/doc/syntax-reference.md#repetition-operators---">repetition expression</a>. The repetition expression <code>idRest*</code> means  to match <code>idRest</code> as many times as possible; the last attempt will always fail by definition.</li>
</ol>
<p><img src="https://dubroy.com/blog/images/highlighted-failures.png"/></p>
<h3>Backtracking</h3>
<p>Another challenge in designing the visualization was how to deal with <a href="https://en.wikipedia.org/wiki/Backtracking">backtracking</a>. In a packrat parser, backtracking happens when a successful match is part of a larger expression which fails.</p>
<p>For example, many programming languages contain <em>keywords</em> (e.g. <code>function</code>) which can appear in the same position as a variable name. A common way to handle this is to use <a href="https://github.com/harc/ohm/blob/master/doc/syntax-reference.md#negative-lookahead-"><em>negative lookahead</em></a> to prevent incorrectly matching a keyword at the beginning of an identifier like ‚Äúfunctional‚Äù.</p>
<p>Here is the same grammar from before, modified to include a <em>functionKeyword</em> rule. And here is the visual explanation of matching the the input ‚Äúfunctional‚Äù:</p>
<p><img src="https://dubroy.com/blog/images/functional-parse-tree-and-grammar.png"/></p>
<p>The nodes with a <span>pink background</span> are nodes which successfully matched some portion of the input, but were ultimately discarded during backtracking.</p>
<h3>Left recursion</h3>
<p>One thing in Ohm that‚Äôs different from many similar tools is its special support for <em>left recursion</em>. The <a href="https://ohmlang.github.io/editor/#30325d346a6e803cc35344ca218d8636">arithmetic grammar</a> included in the Ohm Editor has some examples of left-recursive rules:</p>
<pre><code>  AddExp
    = AddExp &#34;+&#34; MulExp  -- plus
    | AddExp &#34;-&#34; MulExp  -- minus
    | MulExp</code></pre>


<p>Notice that the first two branches of <em>AddExp</em> begin with a recursive application of <em>AddExp</em> itself ‚Äî that‚Äôs left recursion. In a typical recursive-descent parser, this would result in infinite recursion. However, since it‚Äôs so convenient to define left-associative operators this way, the Ohm parsing algorithm detects these rules and handles them specially.<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></p>
<p>Ohm handles left recursion by iteratively trying to expand the input consumed by the left-recursive rule, and stopping when it can‚Äôt be expanded any further. As a grammar author, you might sometimes wonder why it stopped when it did. To find out, you can look at the special <span>[Grow LR]</span> node that appears as the last child of any left-recursive rule application:</p>
<p><img src="https://dubroy.com/blog/images/grow-left-recursion.png"/></p>
<h2>Single-stepping</h2>
<p>One other feature of the visual parse explanation is the ability to single-step through the parser‚Äôs execution. In terms of information content, it doesn‚Äôt show anything that‚Äôs not already visible in the full visualization ‚Äî so in a sense, it‚Äôs not strictly necessary. However, I hoped that it might help new users learn how the visualization works.</p>
<p>Single-stepping can be controlled through the buttons in the option panel:</p>
<p><img src="https://dubroy.com/blog/images/step-controls.png"/></p>
<p>You can also right-click on any node and choose ‚Äústep into‚Äù or ‚Äústep out‚Äù:</p>
<p><img src="https://dubroy.com/blog/images/step-into.png"/></p>
<p>From there, you can use the arrow keys to step forwards (‚Üí) or backwards (‚Üê) through the logical steps of the parser execution:</p>
<figure>
<img src="https://dubroy.com/blog/images/step-through-ident.gif"/>
<figcaption>Single-stepping through the parsing process</figcaption>
</figure>



<p>As I explained at the beginning, my goal with the Ohm visualizer was <strong>to make entire execution of the parser visible and tangible</strong>. In the end, I think I was able to achieve that ‚Äî but I‚Äôm sure there are also many aspects of the design that could be improved. If you have ideas, please feel free to get in touch!</p>
<h2>Further Reading</h2>
<p>Here are some links if you are interested in learning more about the Ohm Editor or Ohm itself:</p>
<ul>
<li><a href="https://ohmlang.github.io/">Ohm project page</a></li>
<li><a href="https://github.com/harc/ohm-editor">Github repo for the Ohm Editor</a>. PRs and bug reports are always welcome! üôÇ</li>
<li><a href="https://ohmlang.github.io/pubs/live2016/">Language Hacking in a Live Programming Environment</a> is a web essay where we presented an earlier version of the Ohm Editor.</li>
</ul>



		</div>	</div></div>
  </body>
</html>
