<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://markphelps.me/posts/trying-out-generics-in-go/">Original</a>
    <h1>Trying Out Generics in Go</h1>
    
    <div id="readability-page-1" class="page"><div><p>In case you‚Äôve been living under a rock these past couple of years, you might not know that Go is <a href="https://go.dev/blog/why-generics">getting generics in version 1.18</a>. If you were aware of this, you still may not have been giving it much attention like myself.</p>
<p>The other night I saw this tweet from the Go team which gave me the motivation to try using generics myself:</p>
<blockquote><p lang="en" dir="ltr">üß™ Go 1.18 Beta 1 is released!</p>‚Äî Go (@golang) <a href="https://twitter.com/golang/status/1470844696893263873?ref_src=twsrc%5Etfw">December 14, 2021</a></blockquote>

<p>This post aims to describe my initial experience converting my <a href="https://github.com/markphelps/optional">markphelps/optional</a> library from using code generation to using generics instead. Hopefully, after reading this post you‚Äôll have a better understanding of what generics can do for you and what they can‚Äôt.</p>
<h2 id="some-background">Some Background</h2>
<p>My first response when the plan to add generics was announced was ‚Äúmeh‚Äù. In my 5+ years working in Go, I can probably count on one hand the number of times that I felt like I really needed generics. Most of the code I write in my day job is very specific to the domain and doesn‚Äôt fit the use case that generics aim to fill. That being said, I still wanted to play with the shiny new thing and at least get a handle on the syntax before 1.18 is released.</p>

<p>I quickly realized that I already had an existing library that would likely benefit from being updated to use generics, <a href="https://github.com/markphelps/optional">markphelps/optional</a>.</p>
<p>If you want to read more about why and how <a href="https://github.com/markphelps/optional">markphelps/optional</a> was created, check out <a href="https://markphelps.me/posts/option-types-with-go-generate/">my previous post</a></p>
<p>The <strong>tl;dr</strong> of it is that I used <a href="https://go.dev/blog/generate">code generation</a> and Go‚Äôs <a href="https://pkg.go.dev/text/template">text/template</a> library to support both primitive and custom types. This is what I wanted to try to replace with generics.</p>
<h2 id="generics-to-the-rescue">Generics to the Rescue</h2>
<p>Before jumping into code I took another quick read-through of the very detailed <a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md">proposal</a> to refresh my knowledge of the basic syntax.</p>
<p>The basic syntax is this:</p>
<pre><code>// Print prints the elements of any slice.
// Print has a type parameter T and has a single (non-type)
// parameter s which is a slice of that type parameter.
func Print[T any](s []T) {
   // same as above
}
</code></pre>
<p>Where the <code>[T any]</code> after the function name specifies that <code>T</code> can be any type (<code>any</code> is basically <code>interface{}</code>). Seems simple enough, so I created a new branch and got to deleting some code.</p>
<p>I no longer needed any of the pre-generated optional types like <code>byte</code>, <code>string</code>, <code>int</code>, etc that are present in the <a href="https://github.com/markphelps/optional">main branch</a>.</p>
<p>This took the library from:</p>
<pre><code>‚ú¶ ‚ûú ls
CONTRIBUTING.md README.md       cmd             error.go        float64.go      go.sum          int32.go        int_test.go     string_test.go  uint32.go       uintptr.go
LICENSE.md      bool.go         complex128.go   example_test.go generate.go     int.go          int64.go        rune.go         uint.go         uint64.go
Makefile        byte.go         complex64.go    float32.go      go.mod          int16.go        int8.go         string.go       uint16.go       uint8.go
</code></pre>
<p>To:</p>
<pre><code>‚ú¶ ‚ûú ls
CONTRIBUTING.md  LICENSE.md       Makefile         README.md        example_test.go  go.mod           go.sum           optional.go      optional_test.go
</code></pre>
<p>Much better.</p>
<p>I created <code>optional.go</code> to contain the generic code and got to writing. I should say I got to copying, as I simply inserted the code from one of the previously generated files and replaced the type names.</p>
<div>
<div>
<p><strong>tip:</strong> I find that it&#39;s much easier to extract/replace previously typed code with generic code than it is to write the code generically from scratch.
</p>
</div>
</div>
<p>The code now looks like this:</p>
<pre><code>// Optional is an optional T.
type Optional[T any] struct {
   value *T
}

// New creates an optional T from a T.
func New[T any](v T) Optional[T] {
   o := Optional[T]{value: &amp;v}
   return o
}

// Set sets the value.
func (o *Optional[T]) Set(v T) {
   o.value = &amp;v
}
</code></pre>
<p>Now the user of my library could write code like this:</p>
<pre><code>o := New(42)

v, err := o.Get()
if err != nil {
   return err
}
</code></pre>
<p>I like the <a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md#type-inference">type inference</a> here as well so that users don‚Äôt have to write something like:</p>
<pre><code>o := New[int](42)
</code></pre>
<p>You do have to add the type though when you just want to declare a new variable like:</p>
<pre><code>var o optional.Optional[int]
</code></pre>
<p>This is not as nice looking, but I understand the necessity.</p>
<p>I‚Äôll have to admit that overall the syntax was and still is a bit jarring to me. What are all these brackets doing here?! Over time I‚Äôm sure that I will get used to it, but I did notice that it took me longer to grok this code than normal.</p>
<h2 id="trying-out-constraints">Trying Out Constraints</h2>
<p>Generics wouldn‚Äôt be as useful as they are if there wasn‚Äôt a way to guard which types can actually use your generic code. The classic example is calling the <code>String()</code> method on a type <code>T any</code> like:</p>
<pre><code>// This function is INVALID.
func Stringify[T any](s []T) (ret []string) {
   for _, v := range s {
       ret = append(ret, v.String()) // INVALID
   }
   return ret
}
</code></pre>
<p>This is invalid and will not compile because <code>T</code> being an <code>any</code> or <code>interface{}</code> doesn‚Äôt guarantee that it will have a <code>String()</code> method.</p>
<p>The fix here is to use <a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md#constraints">constraints</a>, which define which types are allowed to be used. Constraints are interfaces that can also contain <a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md#type-sets-of-constraints">type sets</a> such as:</p>
<pre><code>// SignedInteger is a constraint that matches any signed integer type.
type SignedInteger interface {
   ~int | ~int8 | ~int16 | ~int32 | ~int64
}
</code></pre>
<p>For the above case, we can get by with using the existing <a href="https://pkg.go.dev/fmt#Stringer">fmt.Stringer</a> interface like:</p>
<pre><code>// This function is valid.
func Stringify[T fmt.Stringer](s []T) (ret []string) {
   for _, v := range s {
       ret = append(ret, v.String())
   }
   return ret
}
</code></pre>
<p>At first, I tried to use constraints in my rewrite in order to not re-introduce this <a href="https://github.com/markphelps/optional/issues/13">previously fixed bug</a>.</p>
<p>Not all types can marshall/unmarshall to and from JSON per <a href="https://github.com/golang/go/blob/129bb1917b4914f0743ec9b4ef0dfb74df39c07d/src/encoding/json/encode.go#L150">this comment</a> in the <code>encoding/json</code> source.</p>
<p>In the pre-generics version I fixed this by simply not generating code for complex types such as <code>complex64/complex128</code>, but this wouldn‚Äôt work in the generic version.</p>
<p>Initially, I thought about using a constraint like:</p>
<pre><code>type marshallable interface {
   constraints.Integer | constraints.Float | ~string | json.Marshaler
}
</code></pre>
<p>This would work for most use cases and prevent anyone from using the library with complex types such as <code>complex64</code>, but what about if they weren‚Äôt using JSON at all and just wanted to do something like creating an optional of a <code>func</code>:</p>
<pre><code>o := New(func()int{
   return 42
})
</code></pre>
<p>Using the above constraint when defining <code>Optional</code> would prevent this invocation because of the <code>marshallable</code> constraint.</p>
<p>In the end, I decided to relax the constraints and just use <code>any</code> when defining <code>T</code>. This would allow the user to write the above, however, if they were to call <code>json.Marshal(o)</code> with <code>o</code> being a <code>func</code>, they would get the error:</p>
<pre><code>json: error calling MarshalJSON for type optional.Optional[func() int]: json: unsupported type: func()
</code></pre>
<p>I think this is ok from a library perspective to return the error at runtime instead of guarding against it at compile-time, since after all, that‚Äôs why <code>json.Marshal</code> can return this error in the first place.</p>
<p><strong>update:</strong> I removed the section on build tags because I realized I was using them incorrectly.</p>
<h2 id="a-few-tips">A Few Tips</h2>
<p>Before wrapping up, I‚Äôd like to provide a few tips for those getting started with 1.18 and generics:</p>
<ol>
<li>As stated earlier, it‚Äôs usually easier to replace typed code with generics than to write it using generics from the beginning. Start with a sample implementation using any type, then replace that type with generics.</li>
<li>Read the <a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md">proposal/spec</a>! It is pretty dense, but at least skim through it before starting to write code with generics. It helped me out a few times in this experiment with examples and explanations when I got stuck.</li>
<li>Constraints can be tricky. They are often necessary to prevent compile-time errors, but can also introduce runtime errors. Thankfully the proposal authors thought of this and provided some <a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md#pointer-method-example">suggestions</a> on dealing with this problem.</li>
<li>Remember, it‚Äôs still in beta, so I wouldn‚Äôt go updating your production code to use generics just yet üòâ</li>
</ol>
<h2 id="in-closing">In Closing</h2>
<p>I ‚ù§Ô∏è that I was able to delete 95% of my code because of generics.</p>
<p>I think that generics will be very beneficial to maintainers who create libraries for things like my own as well as for searching, sorting, transformations, and the like. I can also see some them being extremely helpful for creating well-tested libraries around the various concurrency patterns that are sometimes tricky to get right. I‚Äôm also personally excited to never have to write <code>min/max</code> type functions for the various primitive types ever again.</p>
<p>I‚Äôm not sure that most Go developers will be using generics daily, but it‚Äôs nice to know that they exist if we need them.</p>
<p>What do you think about the addition of generics to Go? Do you see yourself using them regularly or just occasionally? Are you looking forward to generics solving certain code duplication in your own code? Reach out to me on <a href="https://twitter.com/mark_a_phelps">Twitter</a> and let me know!</p>
<p><strong>fyi:</strong> If you want to checkout the 1.18 branch of <a href="https://github.com/markphelps/optional">markphelps/optional</a> and see the code it‚Äôs available <a href="https://github.com/markphelps/optional/tree/1.18">here</a>. I‚Äôll likely create a new release once 1.18 is released.</p>
</div></div>
  </body>
</html>
