<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mcyoung.xyz/2022/07/24/curta/">Original</a>
    <h1>3Hz Computer, Hold the Transistors</h1>
    
    <div id="readability-page-1" class="page"><div> <p><span> <span> <a href="https://mcyoung.xyz/tags.html#etc">#etc</a> <a href="https://mcyoung.xyz/tags.html#assembly">#assembly</a> </span> <span> 2022-07-24 </span> </span></p> <p>I’m not really one to brag publicly about expensive toys, but a few weeks ago I managed to get one that’s really something special. It is a <em>Curta Type II</em>, a mechanical digital<sup id="fnref:mech-digital" role="doc-noteref"><a href="#fn:mech-digital" rel="footnote">1</a></sup> calculator manufactured in Liechtenstein between the 50s and 70s, before solid-state calculators killed them and the likes of slide-rules.</p> <p>I have wanted one since I was a kid, and I managed to win an eBay auction for one.</p> <figure> <p><img src="https://mcyoung.xyz/public/curta/with_case.jpg" alt="The Curta"/></p> <figcaption>The Curta Type II (and Solomon the cat)</figcaption> </figure> <p>It’s a funny looking device, somewhere between a peppermill and a scifi grenade. Mine has serial number 544065, for those keeping score, and comes in a cute little bakelite pod (which has left hand thread?!).</p> <p>I wanna talk about this thing because unlike something like a slide rule, it shares many features with modern computers. It has operations, flags, and registers. Its core primitive is an adder, but many other operations can be built on top of it: it is very much a platform for complex calculations.</p> <p>I’m the sort of person who read <em>Hacker’s Delight</em> for fun, so I really like simple numerical algorithms. This article is a survey of the operation of a Curta calculator and algorithms you can implement on it, from the perspective of a professional assembly programmer.</p> <p>Many of the algorithms I’m going to describe here exist online, but I’ve found them to be a bit difficult to wrap my head around, so this article is also intended as a reference card for myself.</p> <p>Let’s dive in!</p> <h2 id="a-well-lubricated-alu"><a href="#a-well-lubricated-alu">A Well-Lubricated ALU</a></h2> <p>There are two Curta models, Type I and Type II, which primarily differ in the sizes of their registers. I have a Type II, so I will focus on the layout of that one.</p> <p>The Curta is not a <em>stored program</em> computer like the one you’re reading this article on. An operator needs to manually execute operations. It is as if we had taken a CPU and pared it down to two of its most basic components: a register file and an arithmetic logic unit (ALU).</p> <h3 id="the-register-file"><a href="#the-register-file">The Register File</a></h3> <p>The Curta’s register file consists of three digital registers, each of which contains a decimal integer (i.e., each digit is from <code>0</code> to <code>9</code>, rather than <code>0</code> to <code>1</code> like on a binary computer):</p> <ul> <li><code>sr</code>, the <em>setting register</em>, is located on the side of the device. The value in <code>sr</code> can be set manually by the operator using a set of knobs on the side of the device. The machine will never write to it, only read from it. It has 11 digits.</li> <li><code>rr</code>, the <em>results register</em>, is located at the top of the device along the black part of the dial. It is readable and writable by the machine, but not directly modifiable by the operator. It has 15 digits.</li> <li><code>cr</code>, the <em>counting register</em>, is located next to <code>rr</code> along the silver part of the dial. Like <code>rr</code>, it is only machine-modifiable. It has 8 digits.</li> </ul> <figure> <p><img src="https://mcyoung.xyz/public/curta/sr.jpg" alt=""/></p> <figcaption> <p><code>sr</code>, set to <code>1997</code>.</p> </figcaption> </figure> <figure> <p><img src="https://mcyoung.xyz/public/curta/cr_rr.jpg" alt=""/></p> <figcaption> <p><code>rr</code> is the black dial; <code>cr</code> is the silver one.</p> </figcaption> </figure> <p>There are also two settings on the device that aren’t really registers, but, since they are changed as part of operation, they are a lot like the control registers of a modern computer.</p> <p>The <em>carriage</em> (there isn’t an abbreviation for this one, so I’ll call it <code>ca</code>) is the upper knurled ring on the machine. It can be set to a value from <code>0</code> to <code>7</code><sup id="fnref:one-index" role="doc-noteref"><a href="#fn:one-index" rel="footnote">2</a></sup>. To set it, the operator lifts the ring up (against spring tension), twists it, and lets it spring back into the detent for the chosen value. This is a one-hand motion.</p> <p>There is a small triangle in the middle of the top of the device that points at which of the digits in <code>cr</code> will get incremented.</p> <figure> <p><img src="https://mcyoung.xyz/public/curta/ca.jpg" alt=""/></p> <figcaption> <p><code>ca</code> raised and in motion.</p> </figcaption> </figure> <p>Finally, <code>rl</code>, the <em>reversing lever</em>, is a small switch near the back of the device that can be in the up or down position. This is like a flag register: up is cleared, down is set.</p> <figure> <p><img src="https://mcyoung.xyz/public/curta/rl.jpg" alt=""/></p> <figcaption> <p><code>rl</code> in the up position.</p> </figcaption> </figure> <h3 id="the-instruction-set"><a href="#the-instruction-set">The Instruction Set</a></h3> <p>We have all this memory, but the meat of a machine is what it can <em>do</em>. I will provide an <em>instruction set</em> for the Curta to aid in giving rigorous descriptions of operations you can perform with it.</p> <p>The core operation of the Curta is “add-with-shift-and-increment”. This is a mouthful. At the very top of the machine is the handle, which is analogous to a clock signal pin. Every clockwise turn of this handle executes one of these operations. Internally, this is implemented using a variation on the <a href="https://en.wikipedia.org/wiki/Leibniz_wheel">Leibniz gear</a>, a common feature of mechanical calculators.</p> <figure> <p><img src="https://mcyoung.xyz/public/curta/pturn.jpg" alt=""/></p> <figcaption>The handle in &#34;addition&#34; mode.</figcaption> </figure> <p>This operation is not that complicated, it just does a lot of stuff. It takes the value of <code>sr</code>, left-shifts it (in decimal) by the value in <code>ca</code>, and adds it to <code>rr</code>. Also, it increments <code>CR</code> by <code>1</code> shifted by <code>ca</code>. In other words:</p> <div><figure><pre><code data-lang="text">rr += sr &lt;&lt; ca
cr += 1 &lt;&lt; ca</code></pre></figure></div> <p>Recall that this is a decimal machine, so <code>&lt;&lt;</code> is the same as multiplication by a power of 10, not a power of 2.</p> <p>Addition can overflow, and it wraps around as expected: adding one to <code>999_999_999_999_999_999</code> already in <code>rr</code> will fill it with zeroes.</p> <p>Pulling the handle up reveals a red ring, indicating the machine is in <em>subtraction mode</em>. This flips the signs of both the <code>rr</code> and <code>cr</code> modifications:</p> <div><figure><pre><code data-lang="text">rr -= sr &lt;&lt; ca
cr -= 1 &lt;&lt; ca</code></pre></figure></div> <figure> <p><img src="https://mcyoung.xyz/public/curta/mturn.jpg" alt=""/></p> <figcaption>The handle in &#34;subtraction&#34; mode.</figcaption> </figure> <p>The Curta cannot handle negative numbers, so it will instead display the ten’s complement<sup id="fnref:10s-cmp" role="doc-noteref"><a href="#fn:10s-cmp" rel="footnote">3</a></sup> of a negative result. For example, subtracting <code>1</code> from <code>0</code> will produce all-nines.</p> <p>You can detect when underflow or overflow occurs when the resulting value is unexpectedly larger or smaller than the prior value in <code>rr</code>, respectively. (This trick is necessary on architectures that lack a carry flags register, like RISC-V.)</p> <p>Setting <code>rl</code> will reverse the sign of the operation done on <code>cr</code> during a turn of the handle. In addition mode, it will cause <code>cr</code> to be subtracted from, while in subtraction mode, it will cause it to be added to. Some complex algorithms make use of this.</p> <p>Finally, the <em>clearing lever</em> can be used to clear (to zero) <code>sr</code> or <code>rr</code>, independently. It is a small ring-shaped lever that, while the carriage is raised, can be wiped past digits to clear them. Registers cannot be partially cleared.</p> <figure> <p><img src="https://mcyoung.xyz/public/curta/pturn.jpg" alt=""/></p> <figcaption>The clearing lever.</figcaption> </figure> <h3 id="notation"><a href="#notation">Notation</a></h3> <p>Let’s give names to all the instructions the operator needs to follow, so we can write some assembly:</p> <ul> <li><code>mr</code>, or <em>Machine Ready!</em>, means to clear/zero every register. All Curta instructions use the term “Machine Ready” to indicate the beginning of a calculation session.</li> <li><code>pturn</code> is the core addition operation, a “plus turn”.</li> <li><code>mturn</code> is its subtraction twin, a “minus turn”.</li> <li><code>set &lt;flag&gt;</code> requests the operator set one of <code>rl</code> or <code>sm</code>.</li> <li><code>clr &lt;flag&gt;</code> is the opposite of <code>set</code>.</li> <li><code>zero &lt;reg&gt;</code> request a clear of one of <code>rr</code> or <code>cr</code> using the clearing lever.</li> <li><code>add &lt;reg&gt;, &lt;imm&gt;</code> requests manual addition of an immediate to <code>sr</code> or <code>ca</code>. This is limited by what mental math we can ask of the operator.</li> <li><code>copy &lt;reg&gt;, sr</code> requests a copy of the value in <code>rr</code> or <code>cr</code> to <code>sr</code>.</li> <li><code>wrnp &lt;reg&gt;, &lt;symbol&gt;</code> indicates we need to write down a value in any register to a handy notepad (hence <code>wr</code>ite <code>n</code>ote<code>p</code>ad), marked with <code>&lt;symbol&gt;</code>.</li> <li><code>rdnp &lt;reg&gt;, &lt;symbol&gt;</code> asks the operator to <code>re</code>ad a value recorded with <code>wrnp</code>.</li> <li><code>if &lt;cond&gt;, &lt;label&gt;</code> asks the operator to check a condition (in terms of <code>cr</code>, <code>rr</code>, and <code>sr</code>) and, if true, proceed to the instruction at the given <code>label:</code>. Here’s some examples of conditions we’ll use: <ul> <li><code>rr == 42</code>, i.e., <code>rr</code> equals some constant value.</li> <li><code>rr.ovflow</code>, i.e., <code>rr</code> overflowed/underflowed due to the most recent <code>pturn</code>/<code>mturn</code>.</li> <li><code>cr[1] == 9</code>, i.e. <code>cr</code>’s second digit (zero-indexed, not like the physical device!) equals <code>9</code>.</li> <li><code>cr[0..ca] &lt; sr[0..ca]</code>, i.e., <code>cr</code>, considering only the digits up to the setting of <code>ca</code>, is less than those same digits in <code>sr</code>.</li> </ul> </li> <li><code>goto &lt;label&gt;</code> is like <code>if</code> without a condition.</li> <li><code>done</code> means we’re done and the result can be read off of <code>rr</code> (or <code>cr</code>).</li> </ul> <p>Note that there is a lot of mental math in some of the conditions. Algorithms on the Curta are aimed to minimize what work the operator needs to do to compute a result, but remember that it is only an ALU: all of the control flow logic needs to be provided by the human operator.</p> <p>None of this is real code, and it is specifically for the benefit of readers.</p> <h2 id="some-algorithms"><a href="#some-algorithms">Some Algorithms</a></h2> <p>So, addition and subtraction are easy, because there are hardware instructions for those. There is, however, no direct way to do multiplication or division. Let’s take a look at some of our options.</p> <p>Given that a Curta is kinda expensive, you can try out an online simulator if you want to follow along. <a href="https://www.cailliau.org/en/Alphabetical/C/Computing/Curta/Simulator/">This one</a> is pretty simple and runs in your browser.</p> <h3 id="multiplication"><a href="#multiplication">Multiplication</a></h3> <p>The easiest way to do multiplication is by repeated addition; <code>cr</code> helps us check our work.</p> <p>Given a value like <code>8364</code>, we can multiply it by <code>5</code> like so:</p> <div><figure><pre><code data-lang="cpp"><span>mul_by_5:</span>
  <span>mr</span>
  <span>add</span>   <span>sr</span><span>,</span> <span>8364</span>
<span>loop</span><span>:</span>
    <span>if</span>    <span>cr</span> <span>==</span> <span>5</span><span>,</span> <span>end</span>
    <span>pturn</span>
    <span>goto</span>  <span>loop</span>
<span>end</span><span>:</span>
  <span>done</span></code></pre></figure></div> <p>Here, we input the larger factor into <code>sr</code>, and then keep turning until <code>cr</code> contains the other factor. The result is <code>41820</code>:</p> <figure> <p><img src="https://mcyoung.xyz/public/curta/mul.jpg" alt=""/></p> <figcaption> <p><code>8364 * 5 == 41820</code></p> </figcaption> </figure> <p>Of course, this does not work well for complex products, such as squaring <code>41820</code>. You could sit there and turn the handle forty thousand times if you wanted to, or you might decided that you should get a better hobby, since modern silicon can do this in nanoseconds.</p> <p>We can speed this up exponentially by making use of the distributive property and the fact that <code>turn</code> can incorporate multiplication by a power of <code>10</code>.</p> <p>Consider:</p> <div><figure><pre><code data-lang="text">41820 * 41820
= 41820 * (40000 + 1000 + 800 + 20)
= 41820 * 40000 + 41820 * 1000 + 41820 * 800 + 41820 * 20</code></pre></figure></div> <p>Each nice round number here can be achieved in <code>cr</code> by use of <code>ca</code>. Our algorithm will look a bit like this:</p> <div><figure><pre><code data-lang="cpp"><span>square:</span>
  <span>mr</span>
  <span>add</span>   <span>sr</span><span>,</span> <span>41820</span>
<span>loop</span><span>:</span>
    <span>// Check if we&#39;re done.</span>
    <span>if</span>    <span>cr</span> <span>==</span> <span>41820</span><span>,</span> <span>end</span>
  <span>inner</span><span>:</span>
      <span>// Turn until the first `ca` digits of `cr` and the</span>
      <span>// other factor match.</span>
      <span>if</span>    <span>cr</span><span>[</span><span>1.</span><span>.</span><span>ca</span><span>]</span> <span>==</span> <span>41802</span><span>[</span><span>1.</span><span>.</span><span>ca</span><span>],</span> <span>inner_end</span>
      <span>pturn</span>
      <span>goto</span>  <span>inner</span>
  <span>inner_end</span><span>:</span>
    <span>// Increment `ca` and repeat until done.</span>
    <span>add</span>   <span>ca</span><span>,</span> <span>1</span> 
    <span>goto</span>  <span>loop</span>
<span>end</span><span>:</span>
  <span>done</span></code></pre></figure></div> <p>There are two loops. The inner loop runs as many turns as is necessary to get the next prefix of the factor into <code>cr</code>, then incrementing <code>ca</code> to do the next digit, and on and on until <code>cr</code> contains the entire other factor, at which point we can read off the result.</p> <p>The actual trace of operations (omitting control flow), and the resulting contents of the registers <code>sr/rr/mr/ca</code> at each step, looks something like this:</p> <div><figure><pre><code data-lang="cpp"><span>mr</span>
<span>// 00000000000/000000000000000/00000000/0</span>
<span>add</span>   <span>sr</span><span>,</span> <span>41820</span>
<span>// 00000041820/000000000000000/00000000/0</span>
<span>add</span>   <span>ca</span><span>,</span> <span>1</span>
<span>// 00000041820/000000000000000/00000000/1</span>
<span>pturn</span>
<span>// 00000041820/000000000418200/00000010/1</span>
<span>pturn</span>
<span>// 00000041820/000000000083640/00000020/1</span>
<span>add</span>   <span>ca</span><span>,</span> <span>1</span>
<span>// 00000041820/000000000083640/00000020/2</span>
<span>pturn</span>
<span>// 00000041820/000000005018400/00000120/2</span>
<span>pturn</span>
<span>// 00000041820/000000009200400/00000220/2</span>
<span>pturn</span>
<span>// 00000041820/000000013382400/00000320/2</span>
<span>pturn</span>
<span>// 00000041820/000000017564400/00000420/2</span>
<span>pturn</span>
<span>// 00000041820/000000021746400/00000520/2</span>
<span>pturn</span>
<span>// 00000041820/000000025928400/00000620/2</span>
<span>pturn</span>
<span>// 00000041820/000000030110400/00000720/2</span>
<span>pturn</span>
<span>// 00000041820/000000034292400/00000820/2</span>
<span>add</span>   <span>ca</span><span>,</span> <span>1</span>
<span>// 00000041820/000000034292400/00000820/3</span>
<span>pturn</span>
<span>// 00000041820/000000076112400/00001820/3</span>
<span>add</span>   <span>ca</span><span>,</span> <span>1</span>
<span>// 00000041820/000000494312400/00011820/4</span>
<span>pturn</span>
<span>// 00000041820/000000912512400/00021820/4</span>
<span>pturn</span>
<span>// 00000041820/000001330712400/00031820/4</span>
<span>pturn</span>
<span>// 00000041820/000001748912400/00041820/4</span>
<span>pturn</span></code></pre></figure></div> <p>The result can be read off from <code>rr</code>: <code>1748912400</code>. In the trace, you can see <code>cr</code> get built up digit by digit, making this operation rather efficient.</p> <figure> <p><img src="https://mcyoung.xyz/public/curta/square.jpg" alt=""/></p> <figcaption> <p><code>41820 * 41820 == 1748912400</code></p> </figcaption> </figure> <p>We can do even better, if we use subtraction. For example, note that <code>18 = 20 - 2</code>; we can build up <code>18</code> in <code>cr</code> by doing only 4 turns rather than nine, according to this formula. Here’s the general algorithm for <code>n * m</code>:</p> <div><figure><pre><code data-lang="cpp"><span>mul:</span>
  <span>mr</span>
  <span>add</span>   <span>sr</span><span>,</span> <span>n</span>
<span>loop</span><span>:</span>
    <span>if</span>    <span>cr</span> <span>==</span> <span>m</span><span>,</span> <span>end</span>
    <span>// Same as before, but if the next digit is large,</span>
    <span>// go into subtraction mode.</span>
    <span>if</span>    <span>m</span><span>[</span><span>ca</span><span>]</span> <span>&gt;</span> <span>5</span><span>,</span> <span>by_sub</span>
  <span>inner</span><span>:</span>
      <span>if</span>    <span>cr</span><span>[</span><span>0.</span><span>.</span><span>ca</span><span>]</span> <span>==</span> <span>m</span><span>[</span><span>0.</span><span>.</span><span>ca</span><span>],</span> <span>inner_end</span>
      <span>pturn</span>
      <span>goto</span>  <span>inner</span>
  <span>by_sub</span><span>:</span>
    <span>// Store the current `ca` position.</span>
    <span>wrnp</span>  <span>ca</span><span>,</span>   <span>sub_from</span>
    <span>// Find the next small digit (eg. imagine n * 199, we</span>
    <span>// want to find the 1).</span>
  <span>find_small</span><span>:</span>
    <span>add</span>   <span>ca</span><span>,</span>   <span>1</span>
    <span>if</span>    <span>m</span><span>[</span><span>ca</span><span>]</span> <span>&gt;</span> <span>5</span><span>,</span> <span>find_small</span>
    <span>// Set the digit to one plus the desired value for that</span>
    <span>// digit.</span>
  <span>outer_turns</span><span>:</span>
    <span>pturn</span>
    <span>if</span>    <span>cr</span><span>[</span><span>ca</span><span>]</span> <span>!=</span> <span>m</span><span>[</span><span>ca</span><span>]</span> <span>+</span> <span>1</span><span>,</span> <span>outer_turns</span>
    <span>// Store how far we need to re-advance `ca`.</span>
    <span>wrnp</span>  <span>ca</span><span>,</span>   <span>continue_from</span>
    <span>// Go back to the original `ca` position and enter</span>
    <span>// subtraction mode.</span>
    <span>rdnp</span>  <span>ca</span><span>,</span>   <span>sub_from</span>
  <span>subs</span><span>:</span>
  <span>subs_inner</span><span>:</span>
      <span>// Perform subtractions until we get the value we want.</span>
      <span>if</span>    <span>cr</span><span>[</span><span>ca</span><span>]</span> <span>==</span> <span>m</span><span>[</span><span>ca</span><span>],</span>  <span>subs_end</span>
      <span>mturn</span>
      <span>goto</span>  <span>subs_inner</span>
  <span>subs_end</span><span>:</span>
    <span>// Advance `ca` and keep going until we&#39;re done.</span>
    <span>add</span>   <span>ca</span><span>,</span>   <span>1</span>
    <span>if</span>    <span>ca</span> <span>!=</span> <span>continue_from</span><span>,</span> <span>subs</span>
    <span>goto</span>  <span>loop</span>
  <span>inner_end</span><span>:</span>
    <span>add</span>   <span>ca</span><span>,</span>   <span>1</span> 
    <span>goto</span>  <span>loop</span>
<span>end</span><span>:</span>
  <span>done</span></code></pre></figure></div> <p>Although more complicated, if we execute it step by step, we’ll see we get to our answer in fewer turns:</p> <div><figure><pre><code data-lang="cpp"><span>mr</span>
<span>// 00000000000/000000000000000/00000000/0</span>
<span>add</span>   <span>sr</span><span>,</span> <span>41820</span>
<span>// 00000041820/000000000000000/00000000/0</span>
<span>add</span>   <span>ca</span><span>,</span> <span>1</span>
<span>// 00000041820/000000000000000/00000000/1</span>
<span>pturn</span>
<span>// 00000041820/000000000418200/00000010/1</span>
<span>pturn</span>
<span>// 00000041820/000000000835400/00000020/1</span>
<span>add</span>   <span>ca</span><span>,</span> <span>2</span>
<span>// 00000041820/000000000835400/00000020/3</span>
<span>pturn</span>
<span>// 00000041820/000000042656400/00001020/3</span>
<span>pturn</span>
<span>// 00000041820/000000084476400/00002020/3</span>
<span>add</span>   <span>ca</span><span>,</span> <span>-</span><span>1</span>
<span>// 00000041820/000000084476400/00002020/2</span>
<span>mturn</span>
<span>// 00000041820/000000080294400/00001920/2</span>
<span>mturn</span>
<span>// 00000041820/000000076112400/00001820/2</span>
<span>add</span>   <span>ca</span><span>,</span> <span>2</span>
<span>// 00000041820/000000494312400/00011820/4</span>
<span>pturn</span>
<span>// 00000041820/000000912512400/00021820/4</span>
<span>pturn</span>
<span>// 00000041820/000001330712400/00031820/4</span>
<span>pturn</span>
<span>// 00000041820/000001748912400/00041820/4</span>
<span>pturn</span></code></pre></figure></div> <p>In exchange for a little overhead, the number of turns drops from 15 to 10. This is the fastest <em>general</em> algorithm, but some techniques from <em>Hacker’s Delight</em> can likely be applied here to make it faster for some products.</p> <h4 id="cubes"><a href="#cubes">Cubes</a></h4> <p>As a quick note, computing the cube of a number without taking extra notes is easy, so long as the number is already written down somewhere you can already see it. After computing <code>n^2</code> by any of the methods above, we can do</p> <div><figure><pre><code data-lang="cpp"><span>cube:</span>
  <span>mr</span>
  <span>add</span>   <span>sr</span><span>,</span>   <span>n</span>
  <span>// Perform a multiplication by `n`, then copy the result</span>
  <span>// into `sr`.</span>
  <span>copy</span>  <span>sr</span><span>,</span>   <span>rr</span>
  <span>zero</span>  <span>rr</span>
  <span>zero</span>  <span>cr</span>
  <span>// Perform another multiplication by `n`, but now with</span>
  <span>// its square in `sr`.</span>
  <span>done</span></code></pre></figure></div> <p>This sequence can be repeated over and over to produce higher powers, and is only limited by the size of <code>rr</code>.</p> <h3 id="division"><a href="#division">Division</a></h3> <p>Division is way more interesting, because it can be <em>inexact</em>, and thus produces a <em>remainder</em> in addition to the quotient. There are a few different algorithms, but the simplest one is division by repeated subtraction. Some literature calls this “division by breaking down”.</p> <p>For small numbers, this is quite simple, such as <code>21 / 4</code>:</p> <div><figure><pre><code data-lang="cpp"><span>div_by_4:</span>
  <span>mr</span>
  <span>add</span>   <span>sr</span><span>,</span>   <span>21</span>
  <span>pturn</span>
  <span>zero</span>  <span>cr</span>
  <span>zero</span>  <span>sr</span>
  <span>add</span>   <span>sr</span><span>,</span>   <span>4</span>
  <span>set</span>   <span>rl</span>
<span>loop</span><span>:</span>
    <span>if</span>    <span>rr</span><span>.</span><span>oflow</span><span>,</span> <span>end</span>
    <span>mturn</span>
    <span>goto</span>  <span>loop</span>
<span>end</span><span>:</span>
  <span>pturn</span>
  <span>done</span></code></pre></figure></div> <p>This works by first getting the dividend into <code>rr</code> and resetting the rest of the machine. Then, with <code>rl</code> set, we subtract the divisor from <code>rr</code> until we get overflow, at which point we add to undo the overflow. The quotient will appear in <code>cr</code>: we set <code>rl</code>, so each subtraction <em>increments</em> <code>cr</code>, giving us a count of <code>mturn</code>s executed. The remainder appears in <code>rr</code>.</p> <p>In this case, we get down to <code>1</code> before the next <code>mturn</code> underflows; the result of that underflow is to <code>99...97</code>, the ten’s complement of -3. We then undo the last operation by <code>pturn</code>ing, getting <code>5</code> in <code>cr</code>: this is our quotient. <code>1</code> in <code>rr</code> is the remainder.</p> <p>The same tricks from earlier work here, using <code>ca</code> to make less work, effectively implementing decimal long division of <code>n/m</code>:</p> <div><figure><pre><code data-lang="cpp"><span>div:</span>
  <span>// Set up the registers.</span>
  <span>mr</span>
  <span>add</span>   <span>sr</span><span>,</span>   <span>n</span>
  <span>pturn</span>
  <span>zero</span>  <span>cr</span>
  <span>zero</span>  <span>sr</span>
  <span>add</span>   <span>sr</span><span>,</span>   <span>m</span>
  <span>set</span>   <span>rl</span>
  <span>// Move `ca` to be such that the highest digit of</span>
  <span>// `sr` lines up with the highest digit of `rr`.</span>
  <span>add</span>   <span>ca</span><span>,</span>   <span>log</span><span>(</span><span>m</span><span>)</span> <span>-</span> <span>log</span><span>(</span><span>n</span><span>)</span> <span>+</span> <span>1</span>
<span>loop</span><span>:</span>
  <span>// Make subtractive turns until we underflow.</span>
  <span>inner</span><span>:</span>
    <span>mturn</span>
    <span>if</span>    <span>!</span><span>rr</span><span>.</span><span>ovflow</span><span>,</span> <span>inner</span>
  <span>// Undo the turn that underflowed by doing an addition.</span>
  <span>// Because `rl` is set, this will also conveniently subtract</span>
  <span>// from `cr`, to remove the extra count from the</span>
  <span>// underflowing turn.</span>
  <span>pturn</span>
  <span>// We&#39;re done if this is the last digit we can be subtracting.</span>
  <span>// Otherwise, decrement `ca` and start over.</span>
  <span>if</span>    <span>ca</span> <span>==</span> <span>0</span><span>,</span> <span>done</span>
  <span>add</span>   <span>ca</span><span>,</span>   <span>-</span><span>1</span>
  <span>goto</span>  <span>loop</span>
<span>end</span><span>:</span>
  <span>done</span></code></pre></figure></div> <p>Let’s execute this on <code>3141592653 / 137</code>, with an instruction trace as before.</p> <div><figure><pre><code data-lang="cpp"><span>mr</span>
<span>// 00000000000/000000000000000/00000000/0</span>
<span>add</span>   <span>sr</span><span>,</span> <span>3141592653</span>
<span>// 03141592653/000000000000000/00000000/0</span>
<span>pturn</span>
<span>// 03141592653/000003141592653/00000001/0</span>
<span>zero</span>  <span>cr</span>
<span>// 03141592653/000003141592653/00000000/0</span>
<span>zero</span>  <span>sr</span>
<span>// 00000000000/000003141592653/00000000/0</span>
<span>add</span>   <span>sr</span><span>,</span>   <span>137</span>
<span>// 00000000137/000003141592653/00000000/0</span>
<span>add</span>   <span>ca</span><span>,</span>   <span>7</span>
<span>// 00000000137/000003141592653/00000000/7</span>
<span>mturn</span>
<span>// 00000000137/000001771592653/10000000/7</span>
<span>turn</span>
<span>// 00000000137/000000401592653/20000000/7</span>
<span>turn</span>
<span>// 00000000137/999990031592653/30000000/7</span>
<span>pturn</span>
<span>// 00000000137/000000401592653/20000000/7</span>
<span>add</span>   <span>ca</span><span>,</span>   <span>-</span><span>1</span>
<span>// 00000000137/000000401592653/20000000/6</span>
<span>mturn</span>
<span>// 00000000137/000000264592653/21000000/6</span>
<span>mturn</span>
<span>// 00000000137/000000127592653/22000000/6</span>
<span>mturn</span>
<span>// 00000000137/999999990592653/23000000/6</span>
<span>pturn</span>
<span>// 00000000137/000000127592653/22000000/6</span>
<span>add</span> <span>ca</span><span>,</span>   <span>-</span><span>1</span>
<span>// 00000000137/000000127592653/22000000/5</span>
<span>// More turns...</span>
<span>add</span> <span>ca</span><span>,</span>   <span>-</span><span>1</span>
<span>// 00000000137/000000004292653/22900000/4</span>
<span>// More turns...</span>
<span>add</span> <span>ca</span><span>,</span>   <span>-</span><span>1</span>
<span>// 00000000137/000000000182653/22930000/3</span>
<span>// ...</span>
<span>add</span> <span>ca</span><span>,</span>   <span>-</span><span>1</span>
<span>// 00000000137/000000000045653/22931000/2</span>
<span>// ...</span>
<span>add</span> <span>ca</span><span>,</span>   <span>-</span><span>1</span>
<span>// 00000000137/000000000004553/22931300/1</span>
<span>// ...</span>
<span>add</span> <span>ca</span><span>,</span>   <span>-</span><span>1</span>
<span>// 00000000137/000000000000443/22931330/0</span>
<span>// ...</span>
<span>done</span>
<span>// 00000000137/000000000000032/22931333/0</span></code></pre></figure></div> <p>For a quotient this big, you’ll need to work through all eight <code>cr</code> digits, which is a ton of work. At the end, we get a quotient of <code>22931333</code> and reminder <code>32</code>.</p> <figure> <p><img src="https://mcyoung.xyz/public/curta/quot.jpg" alt=""/></p> <figcaption> <p><code>3141592653 / 137 == 22931333, rem 32</code></p> </figcaption> </figure> <p>Unfortunately, we can’t as easily “cheat” with subtraction as we did with multiplication, because we don’t know the value that needs to appear in <code>cr</code>.</p> <h3 id="square-roots"><a href="#square-roots">Square Roots</a></h3> <p>Computing square roots by approximation is one of the premiere operations on the Curta. There’s a number of approaches. Newton’s method is the classic, but requires a prior approximation, access to lookup tables, or a lot of multiplication.</p> <p>A slower, but much more mechanical approach is to use <em>Töpler’s method</em>. This consists of observing that the sum of the first <code>n</code> odd numbers is the square of <code>n</code>. Thus, we can use an approach similar to that for division, only that we now subtract off consecutive odd numbers. Let’s take the square root of <code>92</code>:</p> <div><figure><pre><code data-lang="cpp"><span>sqrt_of_92:</span>
  <span>mr</span>
  <span>add</span>   <span>sr</span><span>,</span>   <span>92</span>
  <span>pturn</span>
  <span>zero</span>  <span>cr</span>
  <span>zero</span>  <span>sr</span>
  <span>add</span>   <span>sr</span><span>,</span>   <span>1</span>
  <span>set</span>   <span>rl</span>
<span>loop</span><span>:</span>
  <span>mturn</span>
  <span>if</span>    <span>rr</span><span>.</span><span>ovflow</span><span>,</span> <span>end</span>
  <span>add</span>   <span>sr</span><span>,</span>  
  <span>goto</span>  <span>loop</span> 
<span>end</span><span>:</span>
  <span>pturn</span>
  <span>done</span></code></pre></figure></div> <p>We get <code>9</code> as our result, but that’s pretty awful precision. We can improve precision by multiplying <code>92</code> by a large, even power of ten, and then dividing the result by that power of ten’s square root (half the zeroes).</p> <p>Unfortunately, this runs into the same problem as naive multiplication: we have to turn the handle <em>a lot</em>. Turning this algorithm into something that can be done exponentially faster is a bit fussier.</p> <p>One approach (which I found on <curta.org>) allows us to compute the root by shifting. Several programmers appear to have independently discovered this in the 70s or 80s.</curta.org></p> <p>It is based on the so-called <a href="https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Digit-by-digit_calculation">“digit-by-digit”</a> algorithm, dating back to at least the time of Napier. Wikipedia provides a good explanation of why this method works. However, I have not been able to write down a proof that this specific version works, since it incorporates borrowing to compute intermediate terms with successive odd numbers in a fairly subtle way. I would really appreciate a proof, if anyone knows of one!</p> <p>The algorithm is thus, for a radicand <code>n</code>:</p> <div><figure><pre><code data-lang="cpp"><span>sqrt:</span>
  <span>mr</span>
  <span>// Put `ca` as far as it will go, and then enter</span>
  <span>// the radicand as far right as it will go, so you</span>
  <span>// get as many digits as possible to work with.</span>
  <span>add</span>   <span>ca</span><span>,</span>   <span>8</span>
  <span>add</span>   <span>sr</span><span>,</span>   <span>n</span> <span>&lt;&lt;</span> <span>(</span><span>8</span> <span>-</span> <span>log</span><span>(</span><span>n</span><span>))</span>
  <span>pturn</span>
  <span>zero</span>  <span>cr</span>
  <span>zero</span>  <span>sr</span>
  <span>// Put a 1 under the leftmost pair of digits. This</span>
  <span>// assumes a number with an even number of digits.</span>
  <span>add</span>   <span>sr</span><span>,</span>   <span>1</span> <span>&lt;&lt;</span> <span>(</span><span>ca</span> <span>-</span> <span>1</span><span>)</span>
  <span>set</span>   <span>rl</span>
<span>loop</span><span>:</span>
  <span>sqrt_loop</span><span>:</span>
      <span>// Add an odd number (with a bunch of zeros</span>
      <span>// after it.)</span>
      <span>mturn</span>
      <span>if</span>    <span>rr</span><span>.</span><span>ovflow</span><span>,</span>  <span>sqrt_end</span>
      <span>// Increment sr by 2 (again, with a bunch of</span>
      <span>// zeros after it). This gives us our next odd</span>
      <span>// number.</span>
      <span>add</span>   <span>sr</span><span>,</span>   <span>2</span> <span>&lt;&lt;</span> <span>(</span><span>ca</span> <span>-</span> <span>1</span><span>)</span>
      <span>goto</span>  <span>sqrt_loop</span>
  <span>sqrt_end</span><span>:</span>
    <span>// Note that we do NOT undo the increment of `sr`</span>
    <span>// that caused overflow, but we do undo the last</span>
    <span>// mturn.</span>
    <span>pturn</span>
    <span>// If `ca` is all the way to the right, we&#39;re out of</span>
    <span>// space, so these are all the digits we&#39;re getting.</span>
    <span>// Zeroing out `rr` also means we&#39;re done.</span>
    <span>if</span>    <span>ca</span> <span>==</span> <span>1</span> <span>||</span> <span>rr</span> <span>==</span> <span>0</span><span>,</span> <span>end</span>
    <span>// Subtract ONE from the digit in `sr` we were</span>
    <span>// incrementing in the loop. This results in an even</span>
    <span>// number.</span>
    <span>add</span>   <span>sr</span><span>,</span>   <span>-</span><span>(</span><span>1</span> <span>&lt;&lt;</span> <span>(</span><span>ca</span> <span>-</span> <span>1</span><span>))</span>
    <span>// Decrement `ca` and keep cranking. </span>
    <span>add</span>   <span>ca</span><span>,</span>   <span>-</span><span>1</span>
    <span>add</span>   <span>sr</span><span>,</span>   <span>1</span> <span>&lt;&lt;</span> <span>(</span><span>ca</span> <span>-</span> <span>1</span><span>)</span>
    <span>goto</span> <span>loop</span>
<span>end</span><span>:</span>
  <span>done</span></code></pre></figure></div> <p>Let’s compute some digits of <code>sqrt(2)</code>. Here’s the instruction trace.</p> <div><figure><pre><code data-lang="cpp"><span>mr</span>
<span>// 00000000000/000000000000000/00000000/0</span>
<span>add</span>   <span>ca</span><span>,</span>   <span>7</span>
<span>// 00000000000/000000000000000/00000000/7</span>
<span>add</span>   <span>sr</span><span>,</span>   <span>2</span> <span>&lt;&lt;</span> <span>(</span><span>8</span> <span>-</span> <span>log</span><span>(</span><span>n</span><span>))</span>
<span>// 00020000000/000000000000000/00000000/7</span>
<span>pturn</span>
<span>// 00020000000/200000000000000/10000000/7</span>
<span>zero</span>  <span>cr</span>
<span>// 00020000000/200000000000000/00000000/7</span>
<span>zero</span>  <span>sr</span>
<span>// 00000000000/200000000000000/00000000/7</span>
<span>add</span>   <span>sr</span><span>,</span>   <span>1</span> <span>&lt;&lt;</span> <span>(</span><span>ca</span> <span>-</span> <span>2</span><span>)</span>
<span>// 00010000000/200000000000000/00000000/7</span>
<span>mturn</span>
<span>// 00010000000/100000000000000/10000000/7</span>
<span>add</span>   <span>sr</span><span>,</span>   <span>2</span> <span>&lt;&lt;</span> <span>(</span><span>ca</span> <span>-</span> <span>2</span><span>)</span>
<span>// 00030000000/100000000000000/10000000/7</span>
<span>mturn</span>
<span>// 00030000000/800000000000000/10000000/7</span>
<span>pturn</span>
<span>// 00030000000/100000000000000/10000000/7</span>
<span>add</span>   <span>sr</span><span>,</span>   <span>-</span><span>(</span><span>1</span> <span>&lt;&lt;</span> <span>(</span><span>ca</span> <span>-</span> <span>2</span><span>))</span>
<span>// 00020000000/100000000000000/10000000/7</span>
<span>add</span>   <span>ca</span><span>,</span>   <span>-</span><span>1</span>
<span>// 00020000000/100000000000000/10000000/6</span>
<span>add</span>   <span>sr</span><span>,</span>   <span>1</span> <span>&lt;&lt;</span> <span>(</span><span>ca</span> <span>-</span> <span>2</span><span>)</span>
<span>// 00021000000/100000000000000/10000000/6</span>
<span>mturn</span>
<span>// 00021000000/079000000000000/11000000/6</span>
<span>add</span>   <span>sr</span><span>,</span>   <span>2</span> <span>&lt;&lt;</span> <span>(</span><span>ca</span> <span>-</span> <span>2</span><span>)</span>
<span>// 00023000000/079000000000000/11000000/6</span>
<span>mturn</span>
<span>// 00023000000/056000000000000/12000000/6</span>
<span>add</span>   <span>sr</span><span>,</span>   <span>2</span> <span>&lt;&lt;</span> <span>(</span><span>ca</span> <span>-</span> <span>2</span><span>)</span>
<span>// 00025000000/056000000000000/12000000/6</span>
<span>mturn</span>
<span>// 00025000000/031000000000000/13000000/6</span>
<span>add</span>   <span>sr</span><span>,</span>   <span>2</span> <span>&lt;&lt;</span> <span>(</span><span>ca</span> <span>-</span> <span>2</span><span>)</span>
<span>// 00027000000/031000000000000/13000000/6</span>
<span>mturn</span>
<span>// 00027000000/004000000000000/14000000/6</span>
<span>add</span>   <span>sr</span><span>,</span>   <span>2</span> <span>&lt;&lt;</span> <span>(</span><span>ca</span> <span>-</span> <span>2</span><span>)</span>
<span>// 00029000000/004000000000000/14000000/6</span>
<span>mturn</span>
<span>// 00029000000/975000000000000/15000000/6</span>
<span>pturn</span>
<span>// 00029000000/004000000000000/14000000/6</span>
<span>add</span>   <span>sr</span><span>,</span>   <span>-</span><span>(</span><span>1</span> <span>&lt;&lt;</span> <span>(</span><span>ca</span> <span>-</span> <span>2</span><span>))</span>
<span>// 00028000000/004000000000000/14000000/6</span>
<span>add</span>   <span>ca</span><span>,</span>   <span>-</span><span>1</span>
<span>// 00028000000/004000000000000/14000000/5</span>
<span>// More of the same...</span></code></pre></figure></div> <p>Over time, the digits <code>14121356</code> will appear in <code>cr</code>. This is the square root (although we do need to place the decimal point; the number of digits before it will be half of what we started with, rounded up).</p> <figure> <p><img src="https://mcyoung.xyz/public/curta/sqrt.jpg" alt=""/></p> <figcaption> <p><code>sqrt(2) ~ 1.4121356</code></p> </figcaption> </figure> <h2 id="wrap-up"><a href="#wrap-up">Wrap-up</a></h2> <p>There’s a quite a few other algorithms out there, but most of them boil down to clever use of lookup tables and combinations of the above techniques. For example, the so-called “rule of 3” is simply performing a multiplication to get a product into <code>rr</code>, and then using it as the dividend to produce a quotient of the form <code>a * b / c</code> in <code>cr</code>.</p> <p>I hope that these simple numeric algorithms, presented in a style resembling assembly, helps illustrate that programming at such a low level is not <em>hard</em>, but merely requires learning a different bag of tricks. ◼</p>  </div><div>   <div> <div> <div> <p><span> <span> <a href="https://mcyoung.xyz/tags.html#etc">#etc</a> <a href="https://mcyoung.xyz/tags.html#assembly">#assembly</a> </span> <span> 2022-07-24 </span> </span></p> <p>I’m not really one to brag publicly about expensive toys, but a few weeks ago I managed to get one that’s really something special. It is a <em>Curta Type II</em>, a mechanical digital<sup id="fnref:mech-digital" role="doc-noteref"><a href="#fn:mech-digital" rel="footnote">1</a></sup> calculator manufactured in Liechtenstein between the 50s and 70s, before solid-state calculators killed them and the likes of slide-rules.</p> <p>I have wanted one since I was a kid, and I managed to win an eBay auction for one.</p> <figure> <p><img src="https://mcyoung.xyz/public/curta/with_case.jpg" alt="The Curta"/></p> <figcaption>The Curta Type II (and Solomon the cat)</figcaption> </figure> <p>It’s a funny looking device, somewhere between a peppermill and a scifi grenade. Mine has serial number 544065, for those keeping score, and comes in a cute little bakelite pod (which has left hand thread?!).</p> <p>I wanna talk about this thing because unlike something like a slide rule, it shares many features with modern computers. It has operations, flags, and registers. Its core primitive is an adder, but many other operations can be built on top of it: it is very much a platform for complex calculations.</p> <p>I’m the sort of person who read <em>Hacker’s Delight</em> for fun, so I really like simple numerical algorithms. This article is a survey of the operation of a Curta calculator and algorithms you can implement on it, from the perspective of a professional assembly programmer.</p> <p>Many of the algorithms I’m going to describe here exist online, but I’ve found them to be a bit difficult to wrap my head around, so this article is also intended as a reference card for myself.</p> <p>Let’s dive in!</p> <h2 id="a-well-lubricated-alu"><a href="#a-well-lubricated-alu">A Well-Lubricated ALU</a></h2> <p>There are two Curta models, Type I and Type II, which primarily differ in the sizes of their registers. I have a Type II, so I will focus on the layout of that one.</p> <p>The Curta is not a <em>stored program</em> computer like the one you’re reading this article on. An operator needs to manually execute operations. It is as if we had taken a CPU and pared it down to two of its most basic components: a register file and an arithmetic logic unit (ALU).</p> <h3 id="the-register-file"><a href="#the-register-file">The Register File</a></h3> <p>The Curta’s register file consists of three digital registers, each of which contains a decimal integer (i.e., each digit is from <code>0</code> to <code>9</code>, rather than <code>0</code> to <code>1</code> like on a binary computer):</p> <ul> <li><code>sr</code>, the <em>setting register</em>, is located on the side of the device. The value in <code>sr</code> can be set manually by the operator using a set of knobs on the side of the device. The machine will never write to it, only read from it. It has 11 digits.</li> <li><code>rr</code>, the <em>results register</em>, is located at the top of the device along the black part of the dial. It is readable and writable by the machine, but not directly modifiable by the operator. It has 15 digits.</li> <li><code>cr</code>, the <em>counting register</em>, is located next to <code>rr</code> along the silver part of the dial. Like <code>rr</code>, it is only machine-modifiable. It has 8 digits.</li> </ul> <figure> <p><img src="https://mcyoung.xyz/public/curta/sr.jpg" alt=""/></p> <figcaption> <p><code>sr</code>, set to <code>1997</code>.</p> </figcaption> </figure> <figure> <p><img src="https://mcyoung.xyz/public/curta/cr_rr.jpg" alt=""/></p> <figcaption> <p><code>rr</code> is the black dial; <code>cr</code> is the silver one.</p> </figcaption> </figure> <p>There are also two settings on the device that aren’t really registers, but, since they are changed as part of operation, they are a lot like the control registers of a modern computer.</p> <p>The <em>carriage</em> (there isn’t an abbreviation for this one, so I’ll call it <code>ca</code>) is the upper knurled ring on the machine. It can be set to a value from <code>0</code> to <code>7</code><sup id="fnref:one-index" role="doc-noteref"><a href="#fn:one-index" rel="footnote">2</a></sup>. To set it, the operator lifts the ring up (against spring tension), twists it, and lets it spring back into the detent for the chosen value. This is a one-hand motion.</p> <p>There is a small triangle in the middle of the top of the device that points at which of the digits in <code>cr</code> will get incremented.</p> <figure> <p><img src="https://mcyoung.xyz/public/curta/ca.jpg" alt=""/></p> <figcaption> <p><code>ca</code> raised and in motion.</p> </figcaption> </figure> <p>Finally, <code>rl</code>, the <em>reversing lever</em>, is a small switch near the back of the device that can be in the up or down position. This is like a flag register: up is cleared, down is set.</p> <figure> <p><img src="https://mcyoung.xyz/public/curta/rl.jpg" alt=""/></p> <figcaption> <p><code>rl</code> in the up position.</p> </figcaption> </figure> <h3 id="the-instruction-set"><a href="#the-instruction-set">The Instruction Set</a></h3> <p>We have all this memory, but the meat of a machine is what it can <em>do</em>. I will provide an <em>instruction set</em> for the Curta to aid in giving rigorous descriptions of operations you can perform with it.</p> <p>The core operation of the Curta is “add-with-shift-and-increment”. This is a mouthful. At the very top of the machine is the handle, which is analogous to a clock signal pin. Every clockwise turn of this handle executes one of these operations. Internally, this is implemented using a variation on the <a href="https://en.wikipedia.org/wiki/Leibniz_wheel">Leibniz gear</a>, a common feature of mechanical calculators.</p> <figure> <p><img src="https://mcyoung.xyz/public/curta/pturn.jpg" alt=""/></p> <figcaption>The handle in &#34;addition&#34; mode.</figcaption> </figure> <p>This operation is not that complicated, it just does a lot of stuff. It takes the value of <code>sr</code>, left-shifts it (in decimal) by the value in <code>ca</code>, and adds it to <code>rr</code>. Also, it increments <code>CR</code> by <code>1</code> shifted by <code>ca</code>. In other words:</p> <div><figure><pre><code data-lang="text">rr += sr &lt;&lt; ca
cr += 1 &lt;&lt; ca</code></pre></figure></div> <p>Recall that this is a decimal machine, so <code>&lt;&lt;</code> is the same as multiplication by a power of 10, not a power of 2.</p> <p>Addition can overflow, and it wraps around as expected: adding one to <code>999_999_999_999_999_999</code> already in <code>rr</code> will fill it with zeroes.</p> <p>Pulling the handle up reveals a red ring, indicating the machine is in <em>subtraction mode</em>. This flips the signs of both the <code>rr</code> and <code>cr</code> modifications:</p> <div><figure><pre><code data-lang="text">rr -= sr &lt;&lt; ca
cr -= 1 &lt;&lt; ca</code></pre></figure></div> <figure> <p><img src="https://mcyoung.xyz/public/curta/mturn.jpg" alt=""/></p> <figcaption>The handle in &#34;subtraction&#34; mode.</figcaption> </figure> <p>The Curta cannot handle negative numbers, so it will instead display the ten’s complement<sup id="fnref:10s-cmp" role="doc-noteref"><a href="#fn:10s-cmp" rel="footnote">3</a></sup> of a negative result. For example, subtracting <code>1</code> from <code>0</code> will produce all-nines.</p> <p>You can detect when underflow or overflow occurs when the resulting value is unexpectedly larger or smaller than the prior value in <code>rr</code>, respectively. (This trick is necessary on architectures that lack a carry flags register, like RISC-V.)</p> <p>Setting <code>rl</code> will reverse the sign of the operation done on <code>cr</code> during a turn of the handle. In addition mode, it will cause <code>cr</code> to be subtracted from, while in subtraction mode, it will cause it to be added to. Some complex algorithms make use of this.</p> <p>Finally, the <em>clearing lever</em> can be used to clear (to zero) <code>sr</code> or <code>rr</code>, independently. It is a small ring-shaped lever that, while the carriage is raised, can be wiped past digits to clear them. Registers cannot be partially cleared.</p> <figure> <p><img src="https://mcyoung.xyz/public/curta/pturn.jpg" alt=""/></p> <figcaption>The clearing lever.</figcaption> </figure> <h3 id="notation"><a href="#notation">Notation</a></h3> <p>Let’s give names to all the instructions the operator needs to follow, so we can write some assembly:</p> <ul> <li><code>mr</code>, or <em>Machine Ready!</em>, means to clear/zero every register. All Curta instructions use the term “Machine Ready” to indicate the beginning of a calculation session.</li> <li><code>pturn</code> is the core addition operation, a “plus turn”.</li> <li><code>mturn</code> is its subtraction twin, a “minus turn”.</li> <li><code>set &lt;flag&gt;</code> requests the operator set one of <code>rl</code> or <code>sm</code>.</li> <li><code>clr &lt;flag&gt;</code> is the opposite of <code>set</code>.</li> <li><code>zero &lt;reg&gt;</code> request a clear of one of <code>rr</code> or <code>cr</code> using the clearing lever.</li> <li><code>add &lt;reg&gt;, &lt;imm&gt;</code> requests manual addition of an immediate to <code>sr</code> or <code>ca</code>. This is limited by what mental math we can ask of the operator.</li> <li><code>copy &lt;reg&gt;, sr</code> requests a copy of the value in <code>rr</code> or <code>cr</code> to <code>sr</code>.</li> <li><code>wrnp &lt;reg&gt;, &lt;symbol&gt;</code> indicates we need to write down a value in any register to a handy notepad (hence <code>wr</code>ite <code>n</code>ote<code>p</code>ad), marked with <code>&lt;symbol&gt;</code>.</li> <li><code>rdnp &lt;reg&gt;, &lt;symbol&gt;</code> asks the operator to <code>re</code>ad a value recorded with <code>wrnp</code>.</li> <li><code>if &lt;cond&gt;, &lt;label&gt;</code> asks the operator to check a condition (in terms of <code>cr</code>, <code>rr</code>, and <code>sr</code>) and, if true, proceed to the instruction at the given <code>label:</code>. Here’s some examples of conditions we’ll use: <ul> <li><code>rr == 42</code>, i.e., <code>rr</code> equals some constant value.</li> <li><code>rr.ovflow</code>, i.e., <code>rr</code> overflowed/underflowed due to the most recent <code>pturn</code>/<code>mturn</code>.</li> <li><code>cr[1] == 9</code>, i.e. <code>cr</code>’s second digit (zero-indexed, not like the physical device!) equals <code>9</code>.</li> <li><code>cr[0..ca] &lt; sr[0..ca]</code>, i.e., <code>cr</code>, considering only the digits up to the setting of <code>ca</code>, is less than those same digits in <code>sr</code>.</li> </ul> </li> <li><code>goto &lt;label&gt;</code> is like <code>if</code> without a condition.</li> <li><code>done</code> means we’re done and the result can be read off of <code>rr</code> (or <code>cr</code>).</li> </ul> <p>Note that there is a lot of mental math in some of the conditions. Algorithms on the Curta are aimed to minimize what work the operator needs to do to compute a result, but remember that it is only an ALU: all of the control flow logic needs to be provided by the human operator.</p> <p>None of this is real code, and it is specifically for the benefit of readers.</p> <h2 id="some-algorithms"><a href="#some-algorithms">Some Algorithms</a></h2> <p>So, addition and subtraction are easy, because there are hardware instructions for those. There is, however, no direct way to do multiplication or division. Let’s take a look at some of our options.</p> <p>Given that a Curta is kinda expensive, you can try out an online simulator if you want to follow along. <a href="https://www.cailliau.org/en/Alphabetical/C/Computing/Curta/Simulator/">This one</a> is pretty simple and runs in your browser.</p> <h3 id="multiplication"><a href="#multiplication">Multiplication</a></h3> <p>The easiest way to do multiplication is by repeated addition; <code>cr</code> helps us check our work.</p> <p>Given a value like <code>8364</code>, we can multiply it by <code>5</code> like so:</p> <div><figure><pre><code data-lang="cpp"><span>mul_by_5:</span>
  <span>mr</span>
  <span>add</span>   <span>sr</span><span>,</span> <span>8364</span>
<span>loop</span><span>:</span>
    <span>if</span>    <span>cr</span> <span>==</span> <span>5</span><span>,</span> <span>end</span>
    <span>pturn</span>
    <span>goto</span>  <span>loop</span>
<span>end</span><span>:</span>
  <span>done</span></code></pre></figure></div> <p>Here, we input the larger factor into <code>sr</code>, and then keep turning until <code>cr</code> contains the other factor. The result is <code>41820</code>:</p> <figure> <p><img src="https://mcyoung.xyz/public/curta/mul.jpg" alt=""/></p> <figcaption> <p><code>8364 * 5 == 41820</code></p> </figcaption> </figure> <p>Of course, this does not work well for complex products, such as squaring <code>41820</code>. You could sit there and turn the handle forty thousand times if you wanted to, or you might decided that you should get a better hobby, since modern silicon can do this in nanoseconds.</p> <p>We can speed this up exponentially by making use of the distributive property and the fact that <code>turn</code> can incorporate multiplication by a power of <code>10</code>.</p> <p>Consider:</p> <div><figure><pre><code data-lang="text">41820 * 41820
= 41820 * (40000 + 1000 + 800 + 20)
= 41820 * 40000 + 41820 * 1000 + 41820 * 800 + 41820 * 20</code></pre></figure></div> <p>Each nice round number here can be achieved in <code>cr</code> by use of <code>ca</code>. Our algorithm will look a bit like this:</p> <div><figure><pre><code data-lang="cpp"><span>square:</span>
  <span>mr</span>
  <span>add</span>   <span>sr</span><span>,</span> <span>41820</span>
<span>loop</span><span>:</span>
    <span>// Check if we&#39;re done.</span>
    <span>if</span>    <span>cr</span> <span>==</span> <span>41820</span><span>,</span> <span>end</span>
  <span>inner</span><span>:</span>
      <span>// Turn until the first `ca` digits of `cr` and the</span>
      <span>// other factor match.</span>
      <span>if</span>    <span>cr</span><span>[</span><span>1.</span><span>.</span><span>ca</span><span>]</span> <span>==</span> <span>41802</span><span>[</span><span>1.</span><span>.</span><span>ca</span><span>],</span> <span>inner_end</span>
      <span>pturn</span>
      <span>goto</span>  <span>inner</span>
  <span>inner_end</span><span>:</span>
    <span>// Increment `ca` and repeat until done.</span>
    <span>add</span>   <span>ca</span><span>,</span> <span>1</span> 
    <span>goto</span>  <span>loop</span>
<span>end</span><span>:</span>
  <span>done</span></code></pre></figure></div> <p>There are two loops. The inner loop runs as many turns as is necessary to get the next prefix of the factor into <code>cr</code>, then incrementing <code>ca</code> to do the next digit, and on and on until <code>cr</code> contains the entire other factor, at which point we can read off the result.</p> <p>The actual trace of operations (omitting control flow), and the resulting contents of the registers <code>sr/rr/mr/ca</code> at each step, looks something like this:</p> <div><figure><pre><code data-lang="cpp"><span>mr</span>
<span>// 00000000000/000000000000000/00000000/0</span>
<span>add</span>   <span>sr</span><span>,</span> <span>41820</span>
<span>// 00000041820/000000000000000/00000000/0</span>
<span>add</span>   <span>ca</span><span>,</span> <span>1</span>
<span>// 00000041820/000000000000000/00000000/1</span>
<span>pturn</span>
<span>// 00000041820/000000000418200/00000010/1</span>
<span>pturn</span>
<span>// 00000041820/000000000083640/00000020/1</span>
<span>add</span>   <span>ca</span><span>,</span> <span>1</span>
<span>// 00000041820/000000000083640/00000020/2</span>
<span>pturn</span>
<span>// 00000041820/000000005018400/00000120/2</span>
<span>pturn</span>
<span>// 00000041820/000000009200400/00000220/2</span>
<span>pturn</span>
<span>// 00000041820/000000013382400/00000320/2</span>
<span>pturn</span>
<span>// 00000041820/000000017564400/00000420/2</span>
<span>pturn</span>
<span>// 00000041820/000000021746400/00000520/2</span>
<span>pturn</span>
<span>// 00000041820/000000025928400/00000620/2</span>
<span>pturn</span>
<span>// 00000041820/000000030110400/00000720/2</span>
<span>pturn</span>
<span>// 00000041820/000000034292400/00000820/2</span>
<span>add</span>   <span>ca</span><span>,</span> <span>1</span>
<span>// 00000041820/000000034292400/00000820/3</span>
<span>pturn</span>
<span>// 00000041820/000000076112400/00001820/3</span>
<span>add</span>   <span>ca</span><span>,</span> <span>1</span>
<span>// 00000041820/000000494312400/00011820/4</span>
<span>pturn</span>
<span>// 00000041820/000000912512400/00021820/4</span>
<span>pturn</span>
<span>// 00000041820/000001330712400/00031820/4</span>
<span>pturn</span>
<span>// 00000041820/000001748912400/00041820/4</span>
<span>pturn</span></code></pre></figure></div> <p>The result can be read off from <code>rr</code>: <code>1748912400</code>. In the trace, you can see <code>cr</code> get built up digit by digit, making this operation rather efficient.</p> <figure> <p><img src="https://mcyoung.xyz/public/curta/square.jpg" alt=""/></p> <figcaption> <p><code>41820 * 41820 == 1748912400</code></p> </figcaption> </figure> <p>We can do even better, if we use subtraction. For example, note that <code>18 = 20 - 2</code>; we can build up <code>18</code> in <code>cr</code> by doing only 4 turns rather than nine, according to this formula. Here’s the general algorithm for <code>n * m</code>:</p> <div><figure><pre><code data-lang="cpp"><span>mul:</span>
  <span>mr</span>
  <span>add</span>   <span>sr</span><span>,</span> <span>n</span>
<span>loop</span><span>:</span>
    <span>if</span>    <span>cr</span> <span>==</span> <span>m</span><span>,</span> <span>end</span>
    <span>// Same as before, but if the next digit is large,</span>
    <span>// go into subtraction mode.</span>
    <span>if</span>    <span>m</span><span>[</span><span>ca</span><span>]</span> <span>&gt;</span> <span>5</span><span>,</span> <span>by_sub</span>
  <span>inner</span><span>:</span>
      <span>if</span>    <span>cr</span><span>[</span><span>0.</span><span>.</span><span>ca</span><span>]</span> <span>==</span> <span>m</span><span>[</span><span>0.</span><span>.</span><span>ca</span><span>],</span> <span>inner_end</span>
      <span>pturn</span>
      <span>goto</span>  <span>inner</span>
  <span>by_sub</span><span>:</span>
    <span>// Store the current `ca` position.</span>
    <span>wrnp</span>  <span>ca</span><span>,</span>   <span>sub_from</span>
    <span>// Find the next small digit (eg. imagine n * 199, we</span>
    <span>// want to find the 1).</span>
  <span>find_small</span><span>:</span>
    <span>add</span>   <span>ca</span><span>,</span>   <span>1</span>
    <span>if</span>    <span>m</span><span>[</span><span>ca</span><span>]</span> <span>&gt;</span> <span>5</span><span>,</span> <span>find_small</span>
    <span>// Set the digit to one plus the desired value for that</span>
    <span>// digit.</span>
  <span>outer_turns</span><span>:</span>
    <span>pturn</span>
    <span>if</span>    <span>cr</span><span>[</span><span>ca</span><span>]</span> <span>!=</span> <span>m</span><span>[</span><span>ca</span><span>]</span> <span>+</span> <span>1</span><span>,</span> <span>outer_turns</span>
    <span>// Store how far we need to re-advance `ca`.</span>
    <span>wrnp</span>  <span>ca</span><span>,</span>   <span>continue_from</span>
    <span>// Go back to the original `ca` position and enter</span>
    <span>// subtraction mode.</span>
    <span>rdnp</span>  <span>ca</span><span>,</span>   <span>sub_from</span>
  <span>subs</span><span>:</span>
  <span>subs_inner</span><span>:</span>
      <span>// Perform subtractions until we get the value we want.</span>
      <span>if</span>    <span>cr</span><span>[</span><span>ca</span><span>]</span> <span>==</span> <span>m</span><span>[</span><span>ca</span><span>],</span>  <span>subs_end</span>
      <span>mturn</span>
      <span>goto</span>  <span>subs_inner</span>
  <span>subs_end</span><span>:</span>
    <span>// Advance `ca` and keep going until we&#39;re done.</span>
    <span>add</span>   <span>ca</span><span>,</span>   <span>1</span>
    <span>if</span>    <span>ca</span> <span>!=</span> <span>continue_from</span><span>,</span> <span>subs</span>
    <span>goto</span>  <span>loop</span>
  <span>inner_end</span><span>:</span>
    <span>add</span>   <span>ca</span><span>,</span>   <span>1</span> 
    <span>goto</span>  <span>loop</span>
<span>end</span><span>:</span>
  <span>done</span></code></pre></figure></div> <p>Although more complicated, if we execute it step by step, we’ll see we get to our answer in fewer turns:</p> <div><figure><pre><code data-lang="cpp"><span>mr</span>
<span>// 00000000000/000000000000000/00000000/0</span>
<span>add</span>   <span>sr</span><span>,</span> <span>41820</span>
<span>// 00000041820/000000000000000/00000000/0</span>
<span>add</span>   <span>ca</span><span>,</span> <span>1</span>
<span>// 00000041820/000000000000000/00000000/1</span>
<span>pturn</span>
<span>// 00000041820/000000000418200/00000010/1</span>
<span>pturn</span>
<span>// 00000041820/000000000835400/00000020/1</span>
<span>add</span>   <span>ca</span><span>,</span> <span>2</span>
<span>// 00000041820/000000000835400/00000020/3</span>
<span>pturn</span>
<span>// 00000041820/000000042656400/00001020/3</span>
<span>pturn</span>
<span>// 00000041820/000000084476400/00002020/3</span>
<span>add</span>   <span>ca</span><span>,</span> <span>-</span><span>1</span>
<span>// 00000041820/000000084476400/00002020/2</span>
<span>mturn</span>
<span>// 00000041820/000000080294400/00001920/2</span>
<span>mturn</span>
<span>// 00000041820/000000076112400/00001820/2</span>
<span>add</span>   <span>ca</span><span>,</span> <span>2</span>
<span>// 00000041820/000000494312400/00011820/4</span>
<span>pturn</span>
<span>// 00000041820/000000912512400/00021820/4</span>
<span>pturn</span>
<span>// 00000041820/000001330712400/00031820/4</span>
<span>pturn</span>
<span>// 00000041820/000001748912400/00041820/4</span>
<span>pturn</span></code></pre></figure></div> <p>In exchange for a little overhead, the number of turns drops from 15 to 10. This is the fastest <em>general</em> algorithm, but some techniques from <em>Hacker’s Delight</em> can likely be applied here to make it faster for some products.</p> <h4 id="cubes"><a href="#cubes">Cubes</a></h4> <p>As a quick note, computing the cube of a number without taking extra notes is easy, so long as the number is already written down somewhere you can already see it. After computing <code>n^2</code> by any of the methods above, we can do</p> <div><figure><pre><code data-lang="cpp"><span>cube:</span>
  <span>mr</span>
  <span>add</span>   <span>sr</span><span>,</span>   <span>n</span>
  <span>// Perform a multiplication by `n`, then copy the result</span>
  <span>// into `sr`.</span>
  <span>copy</span>  <span>sr</span><span>,</span>   <span>rr</span>
  <span>zero</span>  <span>rr</span>
  <span>zero</span>  <span>cr</span>
  <span>// Perform another multiplication by `n`, but now with</span>
  <span>// its square in `sr`.</span>
  <span>done</span></code></pre></figure></div> <p>This sequence can be repeated over and over to produce higher powers, and is only limited by the size of <code>rr</code>.</p> <h3 id="division"><a href="#division">Division</a></h3> <p>Division is way more interesting, because it can be <em>inexact</em>, and thus produces a <em>remainder</em> in addition to the quotient. There are a few different algorithms, but the simplest one is division by repeated subtraction. Some literature calls this “division by breaking down”.</p> <p>For small numbers, this is quite simple, such as <code>21 / 4</code>:</p> <div><figure><pre><code data-lang="cpp"><span>div_by_4:</span>
  <span>mr</span>
  <span>add</span>   <span>sr</span><span>,</span>   <span>21</span>
  <span>pturn</span>
  <span>zero</span>  <span>cr</span>
  <span>zero</span>  <span>sr</span>
  <span>add</span>   <span>sr</span><span>,</span>   <span>4</span>
  <span>set</span>   <span>rl</span>
<span>loop</span><span>:</span>
    <span>if</span>    <span>rr</span><span>.</span><span>oflow</span><span>,</span> <span>end</span>
    <span>mturn</span>
    <span>goto</span>  <span>loop</span>
<span>end</span><span>:</span>
  <span>pturn</span>
  <span>done</span></code></pre></figure></div> <p>This works by first getting the dividend into <code>rr</code> and resetting the rest of the machine. Then, with <code>rl</code> set, we subtract the divisor from <code>rr</code> until we get overflow, at which point we add to undo the overflow. The quotient will appear in <code>cr</code>: we set <code>rl</code>, so each subtraction <em>increments</em> <code>cr</code>, giving us a count of <code>mturn</code>s executed. The remainder appears in <code>rr</code>.</p> <p>In this case, we get down to <code>1</code> before the next <code>mturn</code> underflows; the result of that underflow is to <code>99...97</code>, the ten’s complement of -3. We then undo the last operation by <code>pturn</code>ing, getting <code>5</code> in <code>cr</code>: this is our quotient. <code>1</code> in <code>rr</code> is the remainder.</p> <p>The same tricks from earlier work here, using <code>ca</code> to make less work, effectively implementing decimal long division of <code>n/m</code>:</p> <div><figure><pre><code data-lang="cpp"><span>div:</span>
  <span>// Set up the registers.</span>
  <span>mr</span>
  <span>add</span>   <span>sr</span><span>,</span>   <span>n</span>
  <span>pturn</span>
  <span>zero</span>  <span>cr</span>
  <span>zero</span>  <span>sr</span>
  <span>add</span>   <span>sr</span><span>,</span>   <span>m</span>
  <span>set</span>   <span>rl</span>
  <span>// Move `ca` to be such that the highest digit of</span>
  <span>// `sr` lines up with the highest digit of `rr`.</span>
  <span>add</span>   <span>ca</span><span>,</span>   <span>log</span><span>(</span><span>m</span><span>)</span> <span>-</span> <span>log</span><span>(</span><span>n</span><span>)</span> <span>+</span> <span>1</span>
<span>loop</span><span>:</span>
  <span>// Make subtractive turns until we underflow.</span>
  <span>inner</span><span>:</span>
    <span>mturn</span>
    <span>if</span>    <span>!</span><span>rr</span><span>.</span><span>ovflow</span><span>,</span> <span>inner</span>
  <span>// Undo the turn that underflowed by doing an addition.</span>
  <span>// Because `rl` is set, this will also conveniently subtract</span>
  <span>// from `cr`, to remove the extra count from the</span>
  <span>// underflowing turn.</span>
  <span>pturn</span>
  <span>// We&#39;re done if this is the last digit we can be subtracting.</span>
  <span>// Otherwise, decrement `ca` and start over.</span>
  <span>if</span>    <span>ca</span> <span>==</span> <span>0</span><span>,</span> <span>done</span>
  <span>add</span>   <span>ca</span><span>,</span>   <span>-</span><span>1</span>
  <span>goto</span>  <span>loop</span>
<span>end</span><span>:</span>
  <span>done</span></code></pre></figure></div> <p>Let’s execute this on <code>3141592653 / 137</code>, with an instruction trace as before.</p> <div><figure><pre><code data-lang="cpp"><span>mr</span>
<span>// 00000000000/000000000000000/00000000/0</span>
<span>add</span>   <span>sr</span><span>,</span> <span>3141592653</span>
<span>// 03141592653/000000000000000/00000000/0</span>
<span>pturn</span>
<span>// 03141592653/000003141592653/00000001/0</span>
<span>zero</span>  <span>cr</span>
<span>// 03141592653/000003141592653/00000000/0</span>
<span>zero</span>  <span>sr</span>
<span>// 00000000000/000003141592653/00000000/0</span>
<span>add</span>   <span>sr</span><span>,</span>   <span>137</span>
<span>// 00000000137/000003141592653/00000000/0</span>
<span>add</span>   <span>ca</span><span>,</span>   <span>7</span>
<span>// 00000000137/000003141592653/00000000/7</span>
<span>mturn</span>
<span>// 00000000137/000001771592653/10000000/7</span>
<span>turn</span>
<span>// 00000000137/000000401592653/20000000/7</span>
<span>turn</span>
<span>// 00000000137/999990031592653/30000000/7</span>
<span>pturn</span>
<span>// 00000000137/000000401592653/20000000/7</span>
<span>add</span>   <span>ca</span><span>,</span>   <span>-</span><span>1</span>
<span>// 00000000137/000000401592653/20000000/6</span>
<span>mturn</span>
<span>// 00000000137/000000264592653/21000000/6</span>
<span>mturn</span>
<span>// 00000000137/000000127592653/22000000/6</span>
<span>mturn</span>
<span>// 00000000137/999999990592653/23000000/6</span>
<span>pturn</span>
<span>// 00000000137/000000127592653/22000000/6</span>
<span>add</span> <span>ca</span><span>,</span>   <span>-</span><span>1</span>
<span>// 00000000137/000000127592653/22000000/5</span>
<span>// More turns...</span>
<span>add</span> <span>ca</span><span>,</span>   <span>-</span><span>1</span>
<span>// 00000000137/000000004292653/22900000/4</span>
<span>// More turns...</span>
<span>add</span> <span>ca</span><span>,</span>   <span>-</span><span>1</span>
<span>// 00000000137/000000000182653/22930000/3</span>
<span>// ...</span>
<span>add</span> <span>ca</span><span>,</span>   <span>-</span><span>1</span>
<span>// 00000000137/000000000045653/22931000/2</span>
<span>// ...</span>
<span>add</span> <span>ca</span><span>,</span>   <span>-</span><span>1</span>
<span>// 00000000137/000000000004553/22931300/1</span>
<span>// ...</span>
<span>add</span> <span>ca</span><span>,</span>   <span>-</span><span>1</span>
<span>// 00000000137/000000000000443/22931330/0</span>
<span>// ...</span>
<span>done</span>
<span>// 00000000137/000000000000032/22931333/0</span></code></pre></figure></div> <p>For a quotient this big, you’ll need to work through all eight <code>cr</code> digits, which is a ton of work. At the end, we get a quotient of <code>22931333</code> and reminder <code>32</code>.</p> <figure> <p><img src="https://mcyoung.xyz/public/curta/quot.jpg" alt=""/></p> <figcaption> <p><code>3141592653 / 137 == 22931333, rem 32</code></p> </figcaption> </figure> <p>Unfortunately, we can’t as easily “cheat” with subtraction as we did with multiplication, because we don’t know the value that needs to appear in <code>cr</code>.</p> <h3 id="square-roots"><a href="#square-roots">Square Roots</a></h3> <p>Computing square roots by approximation is one of the premiere operations on the Curta. There’s a number of approaches. Newton’s method is the classic, but requires a prior approximation, access to lookup tables, or a lot of multiplication.</p> <p>A slower, but much more mechanical approach is to use <em>Töpler’s method</em>. This consists of observing that the sum of the first <code>n</code> odd numbers is the square of <code>n</code>. Thus, we can use an approach similar to that for division, only that we now subtract off consecutive odd numbers. Let’s take the square root of <code>92</code>:</p> <div><figure><pre><code data-lang="cpp"><span>sqrt_of_92:</span>
  <span>mr</span>
  <span>add</span>   <span>sr</span><span>,</span>   <span>92</span>
  <span>pturn</span>
  <span>zero</span>  <span>cr</span>
  <span>zero</span>  <span>sr</span>
  <span>add</span>   <span>sr</span><span>,</span>   <span>1</span>
  <span>set</span>   <span>rl</span>
<span>loop</span><span>:</span>
  <span>mturn</span>
  <span>if</span>    <span>rr</span><span>.</span><span>ovflow</span><span>,</span> <span>end</span>
  <span>add</span>   <span>sr</span><span>,</span>  
  <span>goto</span>  <span>loop</span> 
<span>end</span><span>:</span>
  <span>pturn</span>
  <span>done</span></code></pre></figure></div> <p>We get <code>9</code> as our result, but that’s pretty awful precision. We can improve precision by multiplying <code>92</code> by a large, even power of ten, and then dividing the result by that power of ten’s square root (half the zeroes).</p> <p>Unfortunately, this runs into the same problem as naive multiplication: we have to turn the handle <em>a lot</em>. Turning this algorithm into something that can be done exponentially faster is a bit fussier.</p> <p>One approach (which I found on <curta.org>) allows us to compute the root by shifting. Several programmers appear to have independently discovered this in the 70s or 80s.</curta.org></p> <p>It is based on the so-called <a href="https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Digit-by-digit_calculation">“digit-by-digit”</a> algorithm, dating back to at least the time of Napier. Wikipedia provides a good explanation of why this method works. However, I have not been able to write down a proof that this specific version works, since it incorporates borrowing to compute intermediate terms with successive odd numbers in a fairly subtle way. I would really appreciate a proof, if anyone knows of one!</p> <p>The algorithm is thus, for a radicand <code>n</code>:</p> <div><figure><pre><code data-lang="cpp"><span>sqrt:</span>
  <span>mr</span>
  <span>// Put `ca` as far as it will go, and then enter</span>
  <span>// the radicand as far right as it will go, so you</span>
  <span>// get as many digits as possible to work with.</span>
  <span>add</span>   <span>ca</span><span>,</span>   <span>8</span>
  <span>add</span>   <span>sr</span><span>,</span>   <span>n</span> <span>&lt;&lt;</span> <span>(</span><span>8</span> <span>-</span> <span>log</span><span>(</span><span>n</span><span>))</span>
  <span>pturn</span>
  <span>zero</span>  <span>cr</span>
  <span>zero</span>  <span>sr</span>
  <span>// Put a 1 under the leftmost pair of digits. This</span>
  <span>// assumes a number with an even number of digits.</span>
  <span>add</span>   <span>sr</span><span>,</span>   <span>1</span> <span>&lt;&lt;</span> <span>(</span><span>ca</span> <span>-</span> <span>1</span><span>)</span>
  <span>set</span>   <span>rl</span>
<span>loop</span><span>:</span>
  <span>sqrt_loop</span><span>:</span>
      <span>// Add an odd number (with a bunch of zeros</span>
      <span>// after it.)</span>
      <span>mturn</span>
      <span>if</span>    <span>rr</span><span>.</span><span>ovflow</span><span>,</span>  <span>sqrt_end</span>
      <span>// Increment sr by 2 (again, with a bunch of</span>
      <span>// zeros after it). This gives us our next odd</span>
      <span>// number.</span>
      <span>add</span>   <span>sr</span><span>,</span>   <span>2</span> <span>&lt;&lt;</span> <span>(</span><span>ca</span> <span>-</span> <span>1</span><span>)</span>
      <span>goto</span>  <span>sqrt_loop</span>
  <span>sqrt_end</span><span>:</span>
    <span>// Note that we do NOT undo the increment of `sr`</span>
    <span>// that caused overflow, but we do undo the last</span>
    <span>// mturn.</span>
    <span>pturn</span>
    <span>// If `ca` is all the way to the right, we&#39;re out of</span>
    <span>// space, so these are all the digits we&#39;re getting.</span>
    <span>// Zeroing out `rr` also means we&#39;re done.</span>
    <span>if</span>    <span>ca</span> <span>==</span> <span>1</span> <span>||</span> <span>rr</span> <span>==</span> <span>0</span><span>,</span> <span>end</span>
    <span>// Subtract ONE from the digit in `sr` we were</span>
    <span>// incrementing in the loop. This results in an even</span>
    <span>// number.</span>
    <span>add</span>   <span>sr</span><span>,</span>   <span>-</span><span>(</span><span>1</span> <span>&lt;&lt;</span> <span>(</span><span>ca</span> <span>-</span> <span>1</span><span>))</span>
    <span>// Decrement `ca` and keep cranking. </span>
    <span>add</span>   <span>ca</span><span>,</span>   <span>-</span><span>1</span>
    <span>add</span>   <span>sr</span><span>,</span>   <span>1</span> <span>&lt;&lt;</span> <span>(</span><span>ca</span> <span>-</span> <span>1</span><span>)</span>
    <span>goto</span> <span>loop</span>
<span>end</span><span>:</span>
  <span>done</span></code></pre></figure></div> <p>Let’s compute some digits of <code>sqrt(2)</code>. Here’s the instruction trace.</p> <div><figure><pre><code data-lang="cpp"><span>mr</span>
<span>// 00000000000/000000000000000/00000000/0</span>
<span>add</span>   <span>ca</span><span>,</span>   <span>7</span>
<span>// 00000000000/000000000000000/00000000/7</span>
<span>add</span>   <span>sr</span><span>,</span>   <span>2</span> <span>&lt;&lt;</span> <span>(</span><span>8</span> <span>-</span> <span>log</span><span>(</span><span>n</span><span>))</span>
<span>// 00020000000/000000000000000/00000000/7</span>
<span>pturn</span>
<span>// 00020000000/200000000000000/10000000/7</span>
<span>zero</span>  <span>cr</span>
<span>// 00020000000/200000000000000/00000000/7</span>
<span>zero</span>  <span>sr</span>
<span>// 00000000000/200000000000000/00000000/7</span>
<span>add</span>   <span>sr</span><span>,</span>   <span>1</span> <span>&lt;&lt;</span> <span>(</span><span>ca</span> <span>-</span> <span>2</span><span>)</span>
<span>// 00010000000/200000000000000/00000000/7</span>
<span>mturn</span>
<span>// 00010000000/100000000000000/10000000/7</span>
<span>add</span>   <span>sr</span><span>,</span>   <span>2</span> <span>&lt;&lt;</span> <span>(</span><span>ca</span> <span>-</span> <span>2</span><span>)</span>
<span>// 00030000000/100000000000000/10000000/7</span>
<span>mturn</span>
<span>// 00030000000/800000000000000/10000000/7</span>
<span>pturn</span>
<span>// 00030000000/100000000000000/10000000/7</span>
<span>add</span>   <span>sr</span><span>,</span>   <span>-</span><span>(</span><span>1</span> <span>&lt;&lt;</span> <span>(</span><span>ca</span> <span>-</span> <span>2</span><span>))</span>
<span>// 00020000000/100000000000000/10000000/7</span>
<span>add</span>   <span>ca</span><span>,</span>   <span>-</span><span>1</span>
<span>// 00020000000/100000000000000/10000000/6</span>
<span>add</span>   <span>sr</span><span>,</span>   <span>1</span> <span>&lt;&lt;</span> <span>(</span><span>ca</span> <span>-</span> <span>2</span><span>)</span>
<span>// 00021000000/100000000000000/10000000/6</span>
<span>mturn</span>
<span>// 00021000000/079000000000000/11000000/6</span>
<span>add</span>   <span>sr</span><span>,</span>   <span>2</span> <span>&lt;&lt;</span> <span>(</span><span>ca</span> <span>-</span> <span>2</span><span>)</span>
<span>// 00023000000/079000000000000/11000000/6</span>
<span>mturn</span>
<span>// 00023000000/056000000000000/12000000/6</span>
<span>add</span>   <span>sr</span><span>,</span>   <span>2</span> <span>&lt;&lt;</span> <span>(</span><span>ca</span> <span>-</span> <span>2</span><span>)</span>
<span>// 00025000000/056000000000000/12000000/6</span>
<span>mturn</span>
<span>// 00025000000/031000000000000/13000000/6</span>
<span>add</span>   <span>sr</span><span>,</span>   <span>2</span> <span>&lt;&lt;</span> <span>(</span><span>ca</span> <span>-</span> <span>2</span><span>)</span>
<span>// 00027000000/031000000000000/13000000/6</span>
<span>mturn</span>
<span>// 00027000000/004000000000000/14000000/6</span>
<span>add</span>   <span>sr</span><span>,</span>   <span>2</span> <span>&lt;&lt;</span> <span>(</span><span>ca</span> <span>-</span> <span>2</span><span>)</span>
<span>// 00029000000/004000000000000/14000000/6</span>
<span>mturn</span>
<span>// 00029000000/975000000000000/15000000/6</span>
<span>pturn</span>
<span>// 00029000000/004000000000000/14000000/6</span>
<span>add</span>   <span>sr</span><span>,</span>   <span>-</span><span>(</span><span>1</span> <span>&lt;&lt;</span> <span>(</span><span>ca</span> <span>-</span> <span>2</span><span>))</span>
<span>// 00028000000/004000000000000/14000000/6</span>
<span>add</span>   <span>ca</span><span>,</span>   <span>-</span><span>1</span>
<span>// 00028000000/004000000000000/14000000/5</span>
<span>// More of the same...</span></code></pre></figure></div> <p>Over time, the digits <code>14121356</code> will appear in <code>cr</code>. This is the square root (although we do need to place the decimal point; the number of digits before it will be half of what we started with, rounded up).</p> <figure> <p><img src="https://mcyoung.xyz/public/curta/sqrt.jpg" alt=""/></p> <figcaption> <p><code>sqrt(2) ~ 1.4121356</code></p> </figcaption> </figure> <h2 id="wrap-up"><a href="#wrap-up">Wrap-up</a></h2> <p>There’s a quite a few other algorithms out there, but most of them boil down to clever use of lookup tables and combinations of the above techniques. For example, the so-called “rule of 3” is simply performing a multiplication to get a product into <code>rr</code>, and then using it as the dividend to produce a quotient of the form <code>a * b / c</code> in <code>cr</code>.</p> <p>I hope that these simple numeric algorithms, presented in a style resembling assembly, helps illustrate that programming at such a low level is not <em>hard</em>, but merely requires learning a different bag of tricks. ◼</p>  </div>  </div> </div> </div></div>
  </body>
</html>
