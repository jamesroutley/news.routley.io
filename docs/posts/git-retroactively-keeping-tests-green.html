<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://slinkp.com/2024-10-27-git-keep-tests-passing.html">Original</a>
    <h1>Git: retroactively keeping tests green</h1>
    
    <div id="readability-page-1" class="page"><div>
              <p>I love using <code>git bisect</code> and <code>git bisect run</code> to know when things broke, but that only works if the commit history is generally clean - ie there are aren&#39;t commits with broken tests.</p>
<p>The basic idea, given a failing test, and a test command (for the sake of
illustration let&#39;s call it just <code>pytest</code>) is this:</p>
<div><pre><span></span><code>git<span> </span>bisect<span> </span>start
git<span> </span>bisect<span> </span>bad<span>  </span><span># Mark the current commit as bad</span>
git<span> </span>bisect<span> </span>good<span> </span><span>$COMMIT_HASH</span><span>  </span><span># Mark an earlier, known good commit</span>

git<span> </span>bisect<span> </span>run<span> </span>pytest
</code></pre></div>

<p>That will automatically run until it finds the first commit where <code>pytest</code> fails.
It&#39;s a beautiful tool.</p>
<p>It&#39;s often desirable to run your test command with more specific args to narrow
down to the problem you care about.  Or, if it&#39;s a newly discovered problem,
write a new failing test in a file that <em>isn&#39;t added to the repo</em> - that way
you can test it against any commit.</p>
<p>Recently on a personal project, I realized I had gotten out of the habit of
running the test suite at all<sup id="fnref:1"><a href="#fn:1" rel="nofollow">1</a></sup> before committing. Predictably, several tests were
failing. I wanted to fix this, but as long as I was of a mind to be cleaning up
and fixing, I didn&#39;t like the idea of committing test fixes far removed from
the original commit that broke them.</p>
<p>Why? Because if I left those commits bad, then I wouldn&#39;t be able to usefully
run <code>git bisect run</code> on that range of commits in the future, since they would all be bad.</p>
<p>Today&#39;s happy realization was that by combining several familiar git features,
this was easy enough to address that it didn&#39;t feel like more
trouble than it was worth. It was surprisingly smooth.</p>
<p>This assumes you&#39;re already familiar with <code>git rebase</code>.</p>
<h2>TL;DR the recipe</h2>
<ol>
<li>Use <code>git bisect run</code> to find the commit that broke the tests, as above.
   Let&#39;s call this <code>$FIRST_BAD_COMMIT</code>.</li>
<li>Check out HEAD of your branch again and fix the code or test code as needed.
   (If this involves adding a new test case, do that now.)</li>
<li>Use <code>git commit --fixup $FIRST_BAD_COMMIT</code> to create a fixup commit.
   This will be added to the end of your commit history, as usual.</li>
<li><code>git rebase -i --autosquash $FIRST_BAD_COMMIT~1</code>
   This will move the changes from the fixup commit to just after the bad
   commit, and squash them together, and rewrite all the following commits to
   be based on those changes.</li>
</ol>
<p>Result: We have rewritten history so that the test never failed.</p>
<p>Individually, those are all familiar git commands. But I hadn&#39;t ever combined
<code>fixup</code> and <code>bisect run</code> before.</p>
<h2>Further Reading</h2>
<p><a href="https://jesseduffield.com/Bisect/" rel="nofollow">Blog post by Jesse Duffield about git bisect run</a></p>
<p><a href="https://jordanelver.co.uk/blog/2020/06/04/fixing-commits-with-git-commit-fixup-and-git-rebase-autosquash/" rel="nofollow">Blog post by Jordan Elver about git commit --fixup</a></p>
<h2>When and why to do this?</h2>
<p>Probably rarely!</p>
<p>In a personal project like this, I wouldn&#39;t have bothered - before I
realized how easy it was to do!</p>
<p>If it went south - as history rewriting sometimes can - I probably would have
just left the fixes where they originally landed.</p>
<h3>What about at work?</h3>
<p>In any of my usual at-work workflows, this trick is very unlikely to
apply. I&#39;ll be working on a branch that will end up as one or a few commits
that I&#39;m merging anyway, and all of them will be green.</p>
<p>In a shared repo, we shouldn&#39;t rewrite commit history that anybody else depends on.
It&#39;s extremely disruptive. Doing it on eg a feature branch or chain of branches
that a couple of colleagues are contributing may be fine, but usually takes some direct communication to coordinate (&#34;Hey I&#39;m rebasing the branch again&#34;).</p>
<p>In a work context, I most liberally rewrite <em>my own</em> history <em>before</em> merging it to
the main branch; never after. Especially prior to asking for code review. If
I&#39;m doing something tricky, I want my commit history to be logical and easy to
follow - a help to reviewers. Commits like <code>&#34;try to fix the broken thing yet again&#34;</code>
are just distracting and confusing.</p>
<p>Sometimes - depending on team culture - I&#39;ll also do some commit history
cleanup after code review and before merge, because nobody in the future will
need to see 3 separate commits like &#34;address review feedback round 3&#34;.</p>
<p>Some teams enforce that all branch work gets squashed to a single commit before
merging to main, in which case it&#39;s moot.</p>
<p>Some teams let folks merge as many commits as they feel like, which is fine;
and only require the final one to be green, which is <em>not</em> fine - precisely
because it introduces noise when trying to use <code>git bisect run</code>.
I&#39;ll argue against that practice when I see it.</p>

            </div></div>
  </body>
</html>
