<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.frankdejonge.nl/the-different-types-of-events-in-event-driven-systems/">Original</a>
    <h1>Types of events in event-driven systems</h1>
    
    <div id="readability-page-1" class="page"><article>

            

            <section>
                <p>Event-driven systems come in all sorts of shapes and sizes. The obvious commonality is; they all use events to communicate information. These events come in many shapes and sizes, and determining what goes into an event has an immense impact on the design of your system.</p><p>In this post I&#39;d like to go over three different types of events. I hope clarifying these types will allow you to have better discussions about event-driven architectures and integrations.</p><h2 id="three-event-archetypes">Three event archetypes</h2><p>When I discuss events with my fellow developers I distinguish between three types of events. Each type has its own unique characteristics, strengths, and weaknesses. None of these types of events is necessarily better than the other, but given a situation, a particular type may be the better fit.</p><p>These types of events are:</p><ol><li><a href="#the-domain-event">The Domain Event</a></li><li><a href="#the-trigger-or-signal-event">The Trigger or Signal Event</a></li><li><a href="#the-restful-or-fat-event">The RESTful or &#34;Fat&#34; Event</a></li></ol><p>Let&#39;s go over each of them to see what they are, and when they are useful.</p><h2 id="the-domain-event">The Domain Event</h2><p>For anybody who has an interest in Domain-Driven Design, this will be the most familiar type of event. A domain events is a record of history, capturing the intent and any relevant context about an important moment in time. Domain events focus on the &#34;domain&#34;, which means they focus on things that are relevant to the business. Because they record history, they are expressed in the past tense.</p><p>Domain events are named in a way that the intent is clearly expressed. It is advised to use human language to name these events, try to avoid &#34;beep boop&#34; language. Instead of naming the event <code>OrderStateChanged</code> or <code>OrderEvent</code>, use something like <code>OrderWasShipped</code>. </p><p>Unlike the other event types, domain events are great for capturing intent. Because domain events only capture the relevant context of an important moment, they are also great for capturing change. This gives event consumers great insights into what is going on. Event-sourced systems take this a step further, making domain events are the corner-stone of the software model.</p><p>Domain events are particularly well suited to use in the creation of read models. In situations where the read-case requirements are very different from the data model useful to make decisions. The change and intent centric representation is great for aggregation, both in the creation of read models and in analytical data models.</p><h3 id="example">Example</h3><pre><code>class OrderWasShipped
{
    public function __construct(
        private OrderId $orderId,
        private MomentOfSchipment $shippedAt,
        private ShipmentAddresss $shipmentAddress,
    );
   
    public function orderId(): OrderId
    {
    	return $this-&gt;orderId;
    }
   
    public function shippedAt(): MomentOfSchipment
    {
    	return $this-&gt;skippedAt;
    }
   
    public function shipmentAddress(): ShipmentAddresss
    {
    	return $this-&gt;shipmentAddress;
    }
}</code></pre><h3 id="up-sides">Up-sides</h3><p>Domain events are great for capturing intent and &#34;change&#34;. They allow you to build powerful read models that scale much better than complex queries on the original data model. Domain intents are powerful for creating analytical models, which can provide great insights into what is going on in the business.</p><h3 id="down-sides">Down-sides</h3><p>Domain events expose what goes on inside a domain. If a consumer relies on this information, they are coupled to it. If domain events are used to create decision models, coupling on these events can put a strain on the development velocity. Coupling increases the cost of change, so it&#39;s always good to know what you expose and to whom. As a default practice, consider every domain event &#34;private&#34;, only meant for internal consumption. Only through deliberate exposure consumers get access to the events, similar to how APIs are used instead of direct database access.</p><h2 id="the-trigger-or-signal-event">The Trigger or Signal Event</h2><p>The <em>trigger</em> or <em>signal</em> event is a the tiniest event there is. This event usually consists of only an ID to reference an aggregate or entity, and maybe a timestamp. As the name <em>trigger</em> suggests, these events are used to trigger a reaction on the consuming side. Triggers are most often used to notify <em>other</em> business processes of a change. In cases where you&#39;re storing sensitive data (looking at you, GDPR) the use of triggers can help prevent exposing event infrastructure to challenging requirements.</p><h3 id="example-1">Example</h3><pre><code>class OrderWasShipped
{
    public function __construct(
        private OrderId $orderId
    );
   
    public function orderId(): OrderId
    {
    	return $this-&gt;orderId;
    }
}</code></pre><h3 id="up-sides-1">Up-sides</h3><p>Trigger are useful when a domain event could contain sensitive data. In these cases, the producer sends out a signal and expects the consumer to use a secure API to fetch the corresponding ID. Triggers do not easily cause information-level coupling, simply because they don&#39;t contain any.</p><h3 id="down-sides-1">Down-sides</h3><p>Since triggers do not contain any information, consumers are always reliant on an API. When many consumers consume many events, this can put some unexpected load on your systems. The absence of information also limits the ability to aggregate data.</p><p>Because events are processed asynchronously, the data retrieved by from the API might be in a different state that the consumer expects. A consumer must always check if the resource retrieves from the API is what they expect and be prepared to handle any of the possible states a resource may be in. For example, if an order is shipped, but the merchant immediately cancels the shipment, the consumer may retrieve a shipment resource that doesn&#39;t match the status the event name suggests. When delayed processing of events occurs, this can create unexpected results.</p><h2 id="the-restful-or-fat-event">The RESTful or &#34;Fat&#34; Event</h2><p>The last archetype is the &#34;fat&#34; event. I personally prefer the term RESTful event, because it describes better what is in the payload. This type of event contains the full resource representation as you would retrieve from a RESTful API. It is an excellent integration event and is most useful for <em>outside</em> consumers. </p><p>When compared to triggers, RESTful events prevent consumers from making a roundtrip to the API. If you compare it the domain event, it prevents a consumer Â having to combine multiple events to get the full picture.</p><h3 id="example-2">Example</h3><pre><code>class OrderWasShipped
{
    public function __construct(
        private OrderId $orderId,
        private OrderLines $orderLines,
        private DiscountCodes $discountCodes,
        private OrderAmount $orderAmount,
        private MomentOfSchipment $shippedAt,
        private ShipmentAddresss $shipmentAddress,
    );
   
    public function orderId(): OrderId
    {
    	return $this-&gt;orderId;
    }
   
    public function orderLines(): OrderLines
    {
    	return $this-&gt;orderLines;
    }
   
    public function discountCodes(): DiscountCodes
    {
    	return $this-&gt;discountCodes;
    }
   
    public function orderAmount(): OrderAmount
    {
    	return $this-&gt;orderAmount;
    }
   
    public function shippedAt(): MomentOfSchipment
    {
    	return $this-&gt;skippedAt;
    }
   
    public function shipmentAddress(): ShipmentAddresss
    {
    	return $this-&gt;shipmentAddress;
    }
}</code></pre><h3 id="up-sides-2">Up-sides</h3><p>RESTful events are great for <em>pushing</em> state out to consumers. In one event, consumers know everything about the resource. Per resource, only the last event is needed to be back up to date, which is great for disaster recovery. In cases where another service is dependent on state from your service, the use of RESTful events is a great way to push the state there. Doing so will remove the direct dependency on the service in cases where eventual consistency is acceptable.</p><h3 id="down-sides-2">Down-sides</h3><p>In my experience, RESTful events have only been useful as an integration tool for &#34;outside&#34; consumers. They are not useful for internal modelling. They are big, and more anonymous, and convey less intent, making them less suitable for internal modelling. RESTful events often require you to build an anti-corruption layer to translate other types of events into RESTful ones, which is &#34;extra&#34; work.</p><h2 id="having-meaningful-discussions-about-events">Having meaningful discussions about events</h2><p>During technical discussions, it&#39;s tempting to jump to solutions. Just add the field, just expose this internal event to an external consumer, fix the problem. I&#39;d hope by having identified a couple of types of events, you can take this information into the discussions you&#39;re having. Try to identify which type of events are at plan, what characteristics they have, and how those affect the situation in which you apply them. Exposing a domain event? Be mindful of information-level coupling. Adding more and more information into an event because a consumer needs them? Perhaps switch to a RESTful event. In the end, just keep in mind that the different styles of communication work best if they are applied in the right context. It&#39;s up to you to be aware of this and make the right choice.</p><h2 id="bonus-transforming-events-in-an-acl">Bonus: Transforming events in an ACL</h2><p>One of the beautiful qualities of event- and message-based designs is the possibility of translation. Translation layers, often referred to as anti-corruption layers, facilitate decoupling at information-level. ACLs filter and transform information. This can be done at either side of the integration, producer or consumer. ACLs can also be implemented as relays, pieces of logic that consume and forward (produce) messages. EventSauce recently shipped with a comprehensive toolset to build your own ACLs. Read all about them in <a href="https://eventsauce.io/docs/advanced/anti-corruption-layer/">the docs</a>.</p><p>I hope this was useful for you. If you have any questions or like to get a follow up on one of the items highlighted in the post, <a href="https://twitter.com/frankdejonge">tweet me a question</a>.</p>
            </section>

        </article></div>
  </body>
</html>
