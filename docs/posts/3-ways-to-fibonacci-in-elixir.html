<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://joseph.yiasemides.com/posts/3-ways-to-fibonacci">Original</a>
    <h1>3 Ways To Fibonacci In Elixir</h1>
    
    <div id="readability-page-1" class="page"><div id="post-content">
<h2>
Introduction</h2>
<p>
About 10 years ago, when I was learning to code, I read a post listing five ways to code the Fibonacci Sequence in Python.
I wrote more or less the same thing in Elixir a few years ago but never published it.<a href="#fn:1" id="fnref:1" title="see footnote">1</a>
Here’s a heavily revised version.</p>
<p>
I consider the <a href="https://en.wikipedia.org/wiki/Fibonacci_sequence">Fibonacci Sequence</a> an analogue to the C classic, <em>Hello World</em>, but for Functional Programming.
It’s one of the first things I code up when I come to a new language.
Here’s its definition:</p>
<p><samp>
    <em>F<sub>n</sub></em> = <em>F<sub>n-1</sub></em> + <em>F<sub>n-2</sub></em>
  </samp>
  with
  <samp>
    <em>F<sub>0</sub></em> = 0, <em>F<sub>1</sub></em> = 1
  </samp>
  , and
  <samp>
    n &gt; 1
  </samp></p>
<p>
Of course, the formula isn’t what I want to show, it just helps to have it here for reference.</p>
<h2>
Plain &amp; Simple</h2>
<p>
Our first version is as simple as we can get it.</p>
<pre><code><span>defmodule</span><span> </span><span>Math.V1</span><span> </span><span data-group-id="3119144871-1">do</span><span>
  </span><span>def</span><span> </span><span>f</span><span data-group-id="3119144871-2">(</span><span>0</span><span data-group-id="3119144871-2">)</span><span>,</span><span> </span><span>do</span><span>:</span><span> </span><span>0</span><span>
  </span><span>def</span><span> </span><span>f</span><span data-group-id="3119144871-3">(</span><span>1</span><span data-group-id="3119144871-3">)</span><span>,</span><span> </span><span>do</span><span>:</span><span> </span><span>1</span><span>
  </span><span>def</span><span> </span><span>f</span><span data-group-id="3119144871-4">(</span><span>n</span><span data-group-id="3119144871-4">)</span><span> </span><span>when</span><span> </span><span>n</span><span> </span><span>&gt;</span><span> </span><span>1</span><span>,</span><span> </span><span>do</span><span>:</span><span> </span><span>f</span><span data-group-id="3119144871-5">(</span><span>n</span><span> </span><span>-</span><span> </span><span>1</span><span data-group-id="3119144871-5">)</span><span> </span><span>+</span><span> </span><span>f</span><span data-group-id="3119144871-6">(</span><span>n</span><span> </span><span>-</span><span> </span><span>2</span><span data-group-id="3119144871-6">)</span><span>
</span><span data-group-id="3119144871-1">end</span></code></pre>
<p>
I was going to say it’s similar to the formula above but the <code>def</code>s and <code>do</code>s make me think again.
One thing is for sure, out of all the examples, it’s most clear <em>what</em> it does because it’s a translation of the formula into code directly.
There’s no <em>how</em> it does it to get in the way of clarity or obscure <em>what</em> it does.</p>
<p>
To calculate a term (i.e. <code>f(n)</code>) with <code>V1</code> we have to compute the entire tree that grows out of <code>f(n - 1) + f(n - 2)</code>.
Let’s see an example.
To calculate <code>f(4)</code> we have to calculate <code>f(4 - 1) = f(3)</code> and <code>f(4 - 2) = f(2)</code>, to calculate <code>f(3)</code> we have to calculate <code>f(3 - 1) = f(2)</code>, and so on (see below).
In doing so, we repeat lots of the calculation, paying the same term a visit at different parts of the tree.
We end up calculating <code>f(2)</code> twice:</p>
<pre><code>f(4)
┣ f(3)
┃ ┣ f(2) ## 1st
┃ ┃ ┣ f(1)
┃ ┃ ┗ f(0)
┃ ┗ f(1)
┗ f(2)   ## 2nd
  ┣ f(1)
  ┗ f(0)</code></pre>
<p>
The bigger the <code>n</code> we pass to <code>f(n)</code>, the bigger the tree, and the more the repetition.
How can we do better while showing-off some neat code in Elixir?</p>
<h2>
Don’t Repeat</h2>
<p>
As per the section title, we’ll store our calculations, so that we don’t repeat them.
It was more challenging, and more fun, to write this <a href="https://en.wikipedia.org/wiki/Memoization">memoized</a> code than I thought it’d be.
Here’s my code after a few attempts:</p>
<pre><code><span>defmodule</span><span> </span><span>Math.V2</span><span> </span><span data-group-id="4000302967-1">do</span><span>
  </span><span>def</span><span> </span><span>f</span><span data-group-id="4000302967-2">(</span><span>n</span><span data-group-id="4000302967-2">)</span><span> </span><span>when</span><span> </span><span>n</span><span> </span><span>&gt;=</span><span> </span><span>0</span><span> </span><span data-group-id="4000302967-3">do</span><span>
    </span><span>memo</span><span> </span><span>=</span><span> </span><span data-group-id="4000302967-4">%{</span><span>0</span><span> </span><span>=&gt;</span><span> </span><span>0</span><span>,</span><span> </span><span>1</span><span> </span><span>=&gt;</span><span> </span><span>1</span><span data-group-id="4000302967-4">}</span><span>

    </span><span>memo</span><span>
    </span><span>|&gt;</span><span> </span><span>f</span><span data-group-id="4000302967-5">(</span><span>n</span><span data-group-id="4000302967-5">)</span><span>
    </span><span>|&gt;</span><span> </span><span>Map</span><span>.</span><span>fetch!</span><span data-group-id="4000302967-6">(</span><span>n</span><span data-group-id="4000302967-6">)</span><span>
  </span><span data-group-id="4000302967-3">end</span><span>

  </span><span>defp</span><span> </span><span>f</span><span data-group-id="4000302967-7">(</span><span>memo</span><span>,</span><span> </span><span>n</span><span data-group-id="4000302967-7">)</span><span> </span><span>when</span><span> </span><span>is_map_key</span><span data-group-id="4000302967-8">(</span><span>memo</span><span>,</span><span> </span><span>n</span><span data-group-id="4000302967-8">)</span><span> </span><span data-group-id="4000302967-9">do</span><span>
    </span><span>memo</span><span>
  </span><span data-group-id="4000302967-9">end</span><span>

  </span><span>defp</span><span> </span><span>f</span><span data-group-id="4000302967-10">(</span><span>memo</span><span>,</span><span> </span><span>n</span><span data-group-id="4000302967-10">)</span><span> </span><span data-group-id="4000302967-11">do</span><span>
    </span><span>memo</span><span>
    </span><span>|&gt;</span><span> </span><span>f</span><span data-group-id="4000302967-12">(</span><span>n</span><span> </span><span>-</span><span> </span><span>1</span><span data-group-id="4000302967-12">)</span><span>
    </span><span>|&gt;</span><span> </span><span>f</span><span data-group-id="4000302967-13">(</span><span>n</span><span> </span><span>-</span><span> </span><span>2</span><span data-group-id="4000302967-13">)</span><span>
    </span><span>|&gt;</span><span> </span><span>then</span><span data-group-id="4000302967-14">(</span><span>&amp;</span><span>Map</span><span>.</span><span>put_new</span><span data-group-id="4000302967-15">(</span><span>&amp;1</span><span>,</span><span> </span><span>n</span><span>,</span><span> </span><span>&amp;1</span><span data-group-id="4000302967-16">[</span><span>n</span><span> </span><span>-</span><span> </span><span>1</span><span data-group-id="4000302967-16">]</span><span> </span><span>+</span><span> </span><span>&amp;1</span><span data-group-id="4000302967-17">[</span><span>n</span><span> </span><span>-</span><span> </span><span>2</span><span data-group-id="4000302967-17">]</span><span data-group-id="4000302967-15">)</span><span data-group-id="4000302967-14">)</span><span>
  </span><span data-group-id="4000302967-11">end</span><span>
</span><span data-group-id="4000302967-1">end</span></code></pre>
<p>
In <code>V2</code> we store Fibonacci terms that we’d calculate again and again in <code>memo</code>.
It still bares a lot of resemblance to the formula: (1) the initial memo lists the initial terms for <code>n = 0</code> and <code>n = 1</code>, and (2) we can clearly see a variation of <code>f(n - 1) + f(n - 2)</code> in <code>f/2</code>.<a href="#fn:2" id="fnref:2" title="see footnote">2</a></p>
<p>
My first attempts at <code>f/2</code> returned a tuple of <code>{nth, memo}</code> for the <code>nth</code> term and the memo, the result and the accumulator respectively, much like Elixir’s <code>get_and_update/3</code>s.
Instead, returning just the memo means that we can pipe the result through, rather than juggle four more variables.<a href="#fn:3" id="fnref:3" title="see footnote">3</a></p>
<h2>
Bottom-Up -v- Top-Down</h2>
<p>
The examples above work top-down.
They start at <code>f(n)</code>, work their way through their definitions, till they bottom-out at <code>f(1)</code> and <code>f(0)</code>.
They start at a recursive case (<code>f(n)</code>) and work their way to a base case (either <code>f(0)</code> or <code>f(1)</code>), before the stack unwinds, adding up the terms either side of the <code>+</code> in <code>f(n - 1) + f(n - 2)</code>.</p>
<p>
A different approach is to start with a base-case, <code>f(0)</code> and <code>f(1)</code>, and make our way to the recursive case we want, <code>f(n)</code>.<a href="#fn:3" id="fnref:3" title="see footnote">3</a>
A bottom-up approach.
Let’s see what I mean in the trace below.
We only ever need the two preceding Fibonacci terms to calculate the next:</p>
<div>
    <p>
    <samp><u>0</u>, <u>1</u>, ...</samp>The first two terms.
  </p>

  <p>
    <samp><u>0</u>, <u>1</u>, <strong>1</strong>, ...</samp> <span>0 + 1 = 1.</span>
  </p>

  <p>
    <samp>0, <u>1</u>, <u>1</u>, <strong>2</strong>, ...</samp> <span>1 + 1 = 2.</span>
  </p>

  <p>
    <samp>0, 1, <u>1</u>, <u>2</u>, <strong>3</strong>, ...</samp> <span>1 + 2 = 3.</span>
  </p>

  <p>
    <samp>0, 1, 1, <u>2</u>, <u>3</u>, <strong>5</strong>, ...</samp> <span>2 + 3 = 5.</span>
  </p></div>
<p>
So, starting with the base terms of <code>0</code> and <code>1</code>, we can iterate our way to successive values in chunks of two terms at a time.
It’s important to see that in this version evaluation starts at the base cases of <code>f(0)</code> and <code>f(1)</code> building up to <code>f(n)</code>, which is confusing, because our previous versions started evaluation at the recursive case <code>f(n)</code> breaking it down with <code>f(n - 1)</code>s and <code>f(n - 2)</code>s (even though their definitions started with the base case).<a href="#fn:4" id="fnref:4" title="see footnote">4</a></p>
<p>
You can read more on <a href="https://en.wikipedia.org/wiki/Corecursion">Wikipedia</a>.
In Elixir:</p>
<pre><code><span>defmodule</span><span> </span><span>Math.V3</span><span> </span><span data-group-id="3228803276-1">do</span><span>
  </span><span>def</span><span> </span><span>f</span><span data-group-id="3228803276-2">(</span><span>n</span><span data-group-id="3228803276-2">)</span><span> </span><span data-group-id="3228803276-3">do</span><span>
    </span><span data-group-id="3228803276-4">{</span><span>0</span><span>,</span><span> </span><span>1</span><span data-group-id="3228803276-4">}</span><span>
    </span><span>|&gt;</span><span> </span><span>Stream</span><span>.</span><span>iterate</span><span data-group-id="3228803276-5">(</span><span data-group-id="3228803276-6">fn</span><span> </span><span data-group-id="3228803276-7">{</span><span>a</span><span>,</span><span> </span><span>b</span><span data-group-id="3228803276-7">}</span><span> </span><span>-&gt;</span><span> </span><span data-group-id="3228803276-8">{</span><span>b</span><span>,</span><span> </span><span>a</span><span> </span><span>+</span><span> </span><span>b</span><span data-group-id="3228803276-8">}</span><span> </span><span data-group-id="3228803276-6">end</span><span data-group-id="3228803276-5">)</span><span>
    </span><span>|&gt;</span><span> </span><span>Enum</span><span>.</span><span>at</span><span data-group-id="3228803276-9">(</span><span>n</span><span data-group-id="3228803276-9">)</span><span>
    </span><span>|&gt;</span><span> </span><span>then</span><span data-group-id="3228803276-10">(</span><span data-group-id="3228803276-11">fn</span><span> </span><span data-group-id="3228803276-12">{</span><span>a</span><span>,</span><span> </span><span>_</span><span data-group-id="3228803276-12">}</span><span> </span><span>-&gt;</span><span> </span><span>a</span><span> </span><span data-group-id="3228803276-11">end</span><span data-group-id="3228803276-10">)</span><span>
  </span><span data-group-id="3228803276-3">end</span><span>
</span><span data-group-id="3228803276-1">end</span></code></pre>
<p>
<code>V3</code> is most efficient but most cryptic in some ways.
It keeps the bare minimum of two terms in memory, but you can’t see much that resembles the formula.
It’s all about the <em>how</em>, i.e. this particular method for generating the sequence, so the <em>what</em> is lost but the method is revealed instead.</p>
<h2>
Conclusion</h2>
<p>
Considering all the interesting twists and turns in all these versions and others, this post could easily have been about two-dozen variations on Fibonacci, or all the iterations it took to get to the code here.
It’s a shame because nice code takes a lot of work, but we only see the end result in a post, we don’t experience the journey with the author.
I’ve been tinkering with these on and off for what must total a few days over a few years.
How to better share the journey?</p>


  </div></div>
  </body>
</html>
