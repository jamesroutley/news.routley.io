<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.scattered-thoughts.net/log/0053/">Original</a>
    <h1>0053: consulting, go tips, benchmark_mode, niri, linkrot, sea of nos, llm outsourcing, books</h1>
    
    <div id="readability-page-1" class="page"><article>
  <p>I missed a couple of months. I&#39;ve been busy consulting rather than working on zest (other than writing <a href="https://www.swift.org/writing/a-rough-survey-of-compilation-recompilation-and-compile-time-evaluation">a rough survey of compilation, recompilation, and compile-time evaluation</a>. Reading talk of global recession every week made me want to refill my savings instead of running them down more.</p>
<p>It is nice to be working again for a while. Mostly to have simple, immediate goals. Working on zest is always a little angsty because there are so many things I want to do with it and not enough lifetimes to do them in. But when I&#39;m consulting the horizon is only a few months out and success is clearly defined.</p>
<p>I had a short writing gig, which I&#39;ve never done before. That may get published sometime in the future, or may just stay internal.</p>
<p>But the main gig at the moment is speeding up a big go codebase. I like optimization gigs because the goal is so clearly defined - it just needs to do the same thing but faster. That means I can work fairly independently and at my own pace. I spend a lot of time looking at different profiles, single-stepping through hot code, trying out quick experiments. I throw away most of the code I write.</p>
<p>My experience of optimization never matches up to what I was taught or what I see online. There&#39;s never any obvious bottleneck in the profiles, because if there was they would just fix it instead of hiring me.</p>
<p>The fixes are rarely clever algorithms or micro-optimizations either. Much more often the problem is that huge swathes of code were written in a style that was fine when it was being hit 10s or 100s of times per api call, but is really not fine now that datasets are bigger and the code is being hit 1000000s of times per api call. Suddenly the closure that made the code more readable is responsible for millions of heap allocations, the constant string keys that print nicely when debugging are causing map hashes to show up in the profile, the slice that was defensively copied is drowning you in garbage collection etc.</p>
<p>Often fixing one problem doesn&#39;t work out because it puts more weight through another problem. And fixing that problem won&#39;t work because a third problem would also have to be fixed at the same time. It feels like untangling a huge knot. You can&#39;t just look at the knot and solve it - it&#39;s way too big. You just have to patiently tug on different parts of the rope until you find something that can come loose. Hence all the code I&#39;m throwing away. Even if a given change would be an improvement in isolation, it might just be too tangled up to come loose yet.</p>
<p>But when you do finally find a loose end, it&#39;s really satisfing.</p>
<h2 id="go-tips">go tips</h2>
<p>I&#39;ve done very little work in go before so I&#39;ve learned a lot in the last few weeks. Much of this was hard to find online - or hard to find answers to at least. I find plenty of people asking questions and usually the reply is &#34;you don&#39;t want to do/know this, just do the idiomatic thing, performance doesn&#39;t really matter, the compiler might change tomorrow anyway&#34;.</p>
<h3 id="perf">perf</h3>
<p>The goto profiling tool for go is pprof, but I haven&#39;t found it very useful. The cpu profiling is too low resolution, it doesn&#39;t capture kernel code, and it doesn&#39;t understand performance counters. The memory profiling is useful sometimes, but the biasing towards allocation size is actually the opposite of what I usually want - I&#39;m trying to improve throughput rather than reduce the heap size, so I&#39;m much more concerned about millions of small allocations than a few big allocations.</p>
<p>So I&#39;ve been mostly been using perf. <code>go run</code> omits debug symbols, so you have to <code>go build foo.go &amp;&amp; perf record ./foo</code>. <code>--call-graph fp</code> seems to produce the most accurate results, although it does chop the top off really deep stack traces.</p>
<p>I&#39;ve been using <a href="https://github.com/KDAB/hotspot">hotspot</a> for viewing the traces. It&#39;s much nicer than <code>perf report</code>. I do occasionally see some nonsensical results but I haven&#39;t spent the time to investigate whether they are coming from hotspot, perf, or go debug info.</p>
<p>Filtering in/out by symbol is incredibly useful. Eg I&#39;ll usually filter out the setup work in the benchmark, and then if I filter in <code>runtime.mallocgc</code> and switch back to the flame graph I can see a breakdown of where time is spent in allocation.</p>
<p>One thing I haven&#39;t figured out how to do in go is to get a list of allocations grouped by type. Go is mostly type-erased so there aren&#39;t any convenient type tags hanging around on the heap. I think I might be able to get something out of perf by putting an ebpf probe on <code>mallocgc</code> and picking out the type argument. But I don&#39;t have any experience with ebpf so it&#39;ll have to wait until I can interrogate an ebpf friend.</p>
<h3 id="enums">enums</h3>
<p>Go doesn&#39;t have a builtin in concept of enums. The language docs encourage doing something like this:</p>
<pre data-lang="go"><code data-lang="go"><span>type </span><span>Flavour </span><span>uint8
</span><span>
</span><span>const </span><span>(
</span><span>    FlavourSalty </span><span>Flavour </span><span>= </span><span>iota
</span><span>    FlavourSweet
</span><span>    FlavourSour
</span><span>)
</span></code></pre>
<p>But the names are just variables, not part of the data, so if you print these you just get numbers:</p>
<pre data-lang="go"><code data-lang="go"><span>func </span><span>main</span><span>() {
</span><span>    fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;</span><span>%s</span><span>\n</span><span>&#34;</span><span>, </span><span>FlavourSweet)
</span><span>    </span><span>// prints: %!s(main.Flavour=1)
</span><span>
</span><span>    fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;</span><span>%v</span><span>\n</span><span>&#34;</span><span>, </span><span>FlavourSweet)
</span><span>    </span><span>// prints: 1
</span><span>
</span><span>    fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;</span><span>%#v</span><span>\n</span><span>&#34;</span><span>, </span><span>FlavourSweet)
</span><span>    </span><span>// prints: 0x1
</span><span>}
</span></code></pre>
<p>So we need to do a bit more work:</p>
<pre data-lang="go"><code data-lang="go"><span>var </span><span>FlavourNames </span><span>= </span><span>[]</span><span>string</span><span>{
</span><span>    </span><span>&#34;Salty&#34;</span><span>,
</span><span>    </span><span>&#34;Sweet&#34;</span><span>,
</span><span>    </span><span>&#34;Sour&#34;</span><span>,
</span><span>}
</span><span>
</span><span>func </span><span>(</span><span>f </span><span>Flavour</span><span>) </span><span>String</span><span>() </span><span>string </span><span>{
</span><span>    </span><span>return </span><span>FlavourNames[</span><span>uint8</span><span>(f)]
</span><span>}
</span><span>
</span><span>func </span><span>main</span><span>() {
</span><span>    fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;</span><span>%s</span><span>\n</span><span>&#34;</span><span>, </span><span>FlavourSweet)
</span><span>    </span><span>// prints: Sweet
</span><span>
</span><span>    fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;</span><span>%v</span><span>\n</span><span>&#34;</span><span>, </span><span>FlavourSweet)
</span><span>    </span><span>// prints: Sweet
</span><span>
</span><span>    fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;</span><span>%#v</span><span>\n</span><span>&#34;</span><span>, </span><span>FlavourSweet)
</span><span>    </span><span>// prints: 0x1
</span><span>}
</span></code></pre>
<p>But the default methods for printing composite types ignore <code>String</code>, so this still kinda sucks:</p>
<pre data-lang="go"><code data-lang="go"><span>type </span><span>PersonInfo </span><span>struct </span><span>{
</span><span>    likes </span><span>Flavour
</span><span>    hates </span><span>Flavour
</span><span>}
</span><span>
</span><span>func </span><span>main</span><span>() {
</span><span>    fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;</span><span>%s</span><span>\n</span><span>&#34;</span><span>, </span><span>PersonInfo{likes</span><span>: </span><span>FlavourSweet</span><span>, </span><span>hates</span><span>: </span><span>FlavourSour})
</span><span>    </span><span>// prints: {%!s(main.Flavour=1) %!s(main.Flavour=2)}
</span><span>
</span><span>    fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;</span><span>%v</span><span>\n</span><span>&#34;</span><span>, </span><span>PersonInfo{likes</span><span>: </span><span>FlavourSweet</span><span>, </span><span>hates</span><span>: </span><span>FlavourSour})
</span><span>    </span><span>// prints: {1 2}
</span><span>
</span><span>    fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;</span><span>%#v</span><span>\n</span><span>&#34;</span><span>, </span><span>PersonInfo{likes</span><span>: </span><span>FlavourSweet</span><span>, </span><span>hates</span><span>: </span><span>FlavourSour})
</span><span>    </span><span>// prints: main.PersonInfo{likes:0x1, hates:0x2}
</span><span>}
</span></code></pre>
<p>The more ergonomic solution is:</p>
<pre><code><span>type Flavour string
</span><span>
</span><span>const (
</span><span>    FlavourSalty Flavour = &#34;Salty&#34;
</span><span>    FlavourSweet = &#34;Sweet&#34;
</span><span>    FlavourSour = &#34;Sour&#34;
</span><span>)
</span><span>
</span><span>func main() {
</span><span>    fmt.Printf(&#34;%s\n&#34;, PersonInfo{likes: FlavourSweet, hates: FlavourSour})
</span><span>    // prints: {Sweet Sour}
</span><span>
</span><span>    fmt.Printf(&#34;%v\n&#34;, PersonInfo{likes: FlavourSweet, hates: FlavourSour})
</span><span>    // prints: {Sweet Sour}
</span><span>
</span><span>    fmt.Printf(&#34;%#v\n&#34;, PersonInfo{likes: FlavourSweet, hates: FlavourSour})
</span><span>    // prints: main.PersonInfo{likes:&#34;Sweet&#34;, hates:&#34;Sour&#34;}
</span><span>}
</span></code></pre>
<p>But now <code>Flavour</code> is more expensive to compare and hash, and can&#39;t easily be used as an array index - if we were tallying who likes which flavours we could have used <code>[3]int64</code> before and now we&#39;ll probably end up with <code>map[Flavour]int64</code> instead.</p>
<p>Worse is that if you&#39;re deserializing data and you have a string, the temptation is to just write <code>Flavour(s)</code> to convert it. But that doesn&#39;t check that it&#39;s one of the enum options. Libraries that use codegen or reflection for deserialization will do the same thing, because there is no way for them to know that <code>Flavour</code> is supposed to be an enum.</p>
<p>This bit me last week when I was converting one such enum from strings to uint8 and discovered uncomfortably late in the process that <code>&#34;&#34;</code> was an oft-used value.</p>
<p>It&#39;s frustrating how avoidable this was. There are valid reasons why go can&#39;t have general sum types, but enums would have been easy and would have been more ergonomic, safer, and faster than either of the above options.</p>
<h3 id="field-order-matters">field order matters</h3>
<p>The compiler doesn&#39;t reorder struct fields.</p>
<pre data-lang="go"><code data-lang="go"><span>type </span><span>Eg1 </span><span>struct </span><span>{
</span><span>    a </span><span>uint8
</span><span>    b </span><span>int64
</span><span>    c </span><span>uint8
</span><span>}
</span><span>
</span><span>type </span><span>Eg2 </span><span>struct </span><span>{
</span><span>    b </span><span>int64
</span><span>    a </span><span>uint8
</span><span>    c </span><span>uint8
</span><span>}
</span><span>
</span><span>func </span><span>main</span><span>() {
</span><span>    </span><span>var </span><span>eg1 </span><span>Eg1
</span><span>    </span><span>var </span><span>eg2 </span><span>Eg2
</span><span>
</span><span>    fmt</span><span>.</span><span>Println</span><span>(unsafe</span><span>.</span><span>Sizeof</span><span>(eg1))
</span><span>    </span><span>// prints 24
</span><span>
</span><span>    fmt</span><span>.</span><span>Println</span><span>(unsafe</span><span>.</span><span>Sizeof</span><span>(eg2))
</span><span>    </span><span>// prints 16
</span><span>}
</span></code></pre>
<p>This only occasionally matters because most types are 8-byte aligned anyway, but it does come up.</p>
<h3 id="sum-types">sum types</h3>
<p>Suppose we have an interpreter where values can either be strings, decimals, or times. The idiomatic way to deal with this in go is to make an interface:</p>
<pre data-lang="go"><code data-lang="go"><span>type </span><span>Value </span><span>interface </span><span>{
</span><span>    </span><span>isValue</span><span>()
</span><span>}
</span><span>
</span><span>type </span><span>NumberValue </span><span>struct </span><span>{
</span><span>    Val udecimal</span><span>.</span><span>Decimal
</span><span>}
</span><span>
</span><span>type </span><span>StringValue </span><span>struct </span><span>{
</span><span>    Val </span><span>string
</span><span>}
</span><span>
</span><span>type </span><span>TimeValue </span><span>struct </span><span>{
</span><span>    Val time</span><span>.</span><span>Time
</span><span>}
</span><span>
</span><span>func </span><span>(</span><span>v </span><span>NumberValue</span><span>) </span><span>isValue</span><span>() {}
</span><span>func </span><span>(</span><span>v </span><span>StringValue</span><span>) </span><span>isValue</span><span>() {}
</span><span>func </span><span>(</span><span>v </span><span>TimeValue</span><span>) </span><span>isValue</span><span>()   {}
</span></code></pre>
<p>Unfortunately, this means that converting eg a <code>NumberValue</code> to <code>Value</code> requires a heap-allocation, and reading a <code>NumberValue</code> from a <code>Value</code> requires following a pointer. This can get expensive.</p>
<p>The advice I found on the go mailing list is to pack them all into one struct:</p>
<pre data-lang="go"><code data-lang="go"><span>type </span><span>ValueTag </span><span>int64
</span><span>
</span><span>const </span><span>(
</span><span>    ValueTagNumber </span><span>ValueTag </span><span>= </span><span>iota
</span><span>    ValueTagString
</span><span>    ValueTagTime
</span><span>)
</span><span>
</span><span>type </span><span>Value </span><span>struct </span><span>{
</span><span>    tag    </span><span>ValueTag
</span><span>    number udecimal</span><span>.</span><span>Decimal
</span><span>    string </span><span>string
</span><span>    time   time</span><span>.</span><span>Time
</span><span>}
</span></code></pre>
<p>Unfortunately if you have more kinds of values, or more data in each kind of value, then this struct gets really big. Also it&#39;s hard to pass it around by reference without heap-allocating it, and then we&#39;re back to the original problem. But passing it around by value requires a lot of copying.</p>
<p>There is a good reason that go can&#39;t have inline sum types. It would complicate garbage collection and make it easy to violate memory safety by holding on to an interior pointer while changing the sum type.</p>
<p>But if we&#39;re willing to be unsafe (within a small package exporting a safe interface) we can work around the garbage collector. All the gc requires is that:</p>
<ul>
<li>Any field that is set in the gc bitset for the type always contains either a valid pointer or nil.</li>
<li>Any field that is not set in the gc bitset for the type never contains a pointer.</li>
</ul>
<p>So I <em>believe</em> that it&#39;s safe to do this:</p>
<pre data-lang="go"><code data-lang="go"><span>type </span><span>ValueTag </span><span>uint8
</span><span>
</span><span>const </span><span>(
</span><span>    ValueTagNumber </span><span>ValueTag </span><span>= </span><span>iota
</span><span>    ValueTagString
</span><span>    ValueTagTime
</span><span>)
</span><span>
</span><span>type </span><span>Value </span><span>struct </span><span>{
</span><span>    p0    unsafe</span><span>.</span><span>Pointer
</span><span>    data0 </span><span>uint64
</span><span>    data1 </span><span>uint64
</span><span>    data2 </span><span>uint8
</span><span>    data3 </span><span>uint8
</span><span>    Tag   </span><span>ValueTag
</span><span>}
</span><span>
</span><span>func </span><span>FromString</span><span>(</span><span>s </span><span>string</span><span>) </span><span>Value </span><span>{
</span><span>    </span><span>return </span><span>Value{
</span><span>        p0</span><span>:    </span><span>unsafe</span><span>.</span><span>Pointer</span><span>(unsafe</span><span>.</span><span>StringData</span><span>(s))</span><span>,
</span><span>        data0</span><span>: </span><span>uint64</span><span>(</span><span>len</span><span>(s))</span><span>,
</span><span>        Tag</span><span>:   </span><span>ValueTagString</span><span>,
</span><span>    }
</span><span>}
</span><span>
</span><span>func </span><span>(</span><span>v </span><span>Value</span><span>) </span><span>ToString</span><span>() (</span><span>string</span><span>, </span><span>bool</span><span>) {
</span><span>    </span><span>if </span><span>v</span><span>.</span><span>Tag </span><span>!= </span><span>ValueTagString {
</span><span>        </span><span>return </span><span>&#34;&#34;</span><span>, </span><span>false
</span><span>    }
</span><span>    s </span><span>:= </span><span>unsafe</span><span>.</span><span>String</span><span>(
</span><span>        (</span><span>*</span><span>byte</span><span>)(v</span><span>.</span><span>p0)</span><span>,
</span><span>        </span><span>int</span><span>(v</span><span>.</span><span>data0)</span><span>,
</span><span>    )
</span><span>    </span><span>return </span><span>s</span><span>, </span><span>true
</span><span>}
</span></code></pre>
<p>Unfortunately for the actual case I tried this on, it didn&#39;t have enough of a benefit to be worth the api change. But I hope to be able to come back to it once the surrounding overhead has been cleared out.</p>
<h3 id="defer">defer</h3>
<p>Defer can be surprisingly expensive. The rules that I&#39;ve read are:</p>
<ul>
<li>If all defers are statically guaranteed to be hit at most once, and if there are at most 8 defers, then they can be open-coded. Otherwise all defers will be added to a linked list which gets traversed at function exit (because the language guarantees that they will be executed in reverse order).</li>
<li>If a defer is statically guaranteed to be hit at most once (eg inside an if) then its linked list node will be stack-allocated.</li>
<li>If a defer may be hit more than once (eg inside a loop) then its linked list node will be heap-allocated. To reduce allocation pressure these will be allocated from a thread-local pool, with a fallback to global pool behind a mutex(!).</li>
</ul>
<p>However, even in the open-coded case there is still a lot of overhead eg calls to <a href="https://github.com/golang/go/blob/a8e99ab19cbf8568cb452b899d0ed3f0d65848c5/src/runtime/panic.go#L579-L591">runtime.deferreturn</a> for each defer (I think this is because defers are still executed when unwinding from panics so they can&#39;t just be open-coded into the control-flow graph like in zig). And many cases will allocate a closure for the defer too.</p>
<pre data-lang="go"><code data-lang="go"><span>//go:noinline
</span><span>func </span><span>foo</span><span>() </span><span>int64 </span><span>{
</span><span>    </span><span>var </span><span>i </span><span>int64
</span><span>    i </span><span>+= </span><span>1
</span><span>    </span><span>return </span><span>i
</span><span>}
</span><span>
</span><span>//go:noinline
</span><span>func </span><span>bar</span><span>() </span><span>int64 </span><span>{
</span><span>    </span><span>var </span><span>i </span><span>int64
</span><span>    </span><span>defer </span><span>(</span><span>func</span><span>() {
</span><span>        i </span><span>+= </span><span>1
</span><span>    })()
</span><span>    </span><span>return </span><span>i
</span><span>}
</span></code></pre>
<pre><code><span>0000000000491ac0 &lt;main.foo&gt;:
</span><span>  491ac0:	b8 01 00 00 00       	mov    $0x1,%eax
</span><span>  491ac5:	c3                   	ret
</span><span>
</span><span>0000000000491ae0 &lt;main.bar&gt;:
</span><span>  491ae0:	49 3b 66 10          	cmp    0x10(%r14),%rsp
</span><span>  491ae4:	76 7f                	jbe    491b65 &lt;main.bar+0x85&gt;
</span><span>  491ae6:	55                   	push   %rbp
</span><span>  491ae7:	48 89 e5             	mov    %rsp,%rbp
</span><span>  491aea:	48 83 ec 30          	sub    $0x30,%rsp
</span><span>  491aee:	66 44 0f d6 7c 24 28 	movq   %xmm15,0x28(%rsp)
</span><span>  491af5:	c6 44 24 07 00       	movb   $0x0,0x7(%rsp)
</span><span>  491afa:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
</span><span>  491b01:	00 00 
</span><span>  491b03:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
</span><span>  491b0a:	00 00 
</span><span>  491b0c:	48 8d 05 6d 00 00 00 	lea    0x6d(%rip),%rax        # 491b80 &lt;main.bar.func1&gt;
</span><span>  491b13:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
</span><span>  491b18:	48 8d 44 24 10       	lea    0x10(%rsp),%rax
</span><span>  491b1d:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
</span><span>  491b22:	48 8d 44 24 18       	lea    0x18(%rsp),%rax
</span><span>  491b27:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
</span><span>  491b2c:	c6 44 24 07 01       	movb   $0x1,0x7(%rsp)
</span><span>  491b31:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
</span><span>  491b36:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
</span><span>  491b3b:	c6 44 24 07 00       	movb   $0x0,0x7(%rsp)
</span><span>  491b40:	48 8b 54 24 28       	mov    0x28(%rsp),%rdx
</span><span>  491b45:	48 8b 02             	mov    (%rdx),%rax
</span><span>  491b48:	ff d0                	call   *%rax
</span><span>  491b4a:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
</span><span>  491b4f:	48 83 c4 30          	add    $0x30,%rsp
</span><span>  491b53:	5d                   	pop    %rbp
</span><span>  491b54:	c3                   	ret
</span><span>  491b55:	e8 66 36 fa ff       	call   4351c0 &lt;runtime.deferreturn&gt;
</span><span>  491b5a:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
</span><span>  491b5f:	48 83 c4 30          	add    $0x30,%rsp
</span><span>  491b63:	5d                   	pop    %rbp
</span><span>  491b64:	c3                   	ret
</span><span>  491b65:	e8 16 a3 fd ff       	call   46be80 &lt;runtime.morestack_noctxt.abi0&gt;
</span><span>  491b6a:	e9 71 ff ff ff       	jmp    491ae0 &lt;main.bar&gt;
</span></code></pre>
<p>(In this case I don&#39;t think that <code>deferreturn</code> is even reachable, but in real code I think it typically is.)</p>
<p>This can all get pretty expensive in short hot functions. In the case where defer is being used because there are a lot of exit points rather than for panic safety, one option is to manually open-code the defer.</p>
<p>Before:</p>
<pre><code><span>func doStuff() {
</span><span>  start := setup()
</span><span>  defer teardown(state)
</span><span>  if foo(state) {
</span><span>    return
</span><span>  } else if bar(state) {
</span><span>    return
</span><span>  } else {
</span><span>    return
</span><span>  }
</span><span>}
</span></code></pre>
<p>After:</p>
<pre><code><span>func doStuff() {
</span><span>  start := setup()
</span><span>  result := doStuffInner(state)
</span><span>  teardown(state)
</span><span>  return result
</span><span>}
</span><span>
</span><span>func doStuffInner(state State) {
</span><span>  if foo(state) {
</span><span>    return
</span><span>  } else if bar(state) {
</span><span>    return
</span><span>  } else {
</span><span>    return
</span><span>  }
</span><span>}
</span></code></pre>
<p>Sadly we&#39;re then at the mercy of inlining heuristics for <code>doStuffInner()</code>, but even un-inlined we&#39;re replacing a bunch of overhead and indirect function callsw with a single direct function call.</p>
<h3 id="slice-scanning">slice scanning</h3>
<p>For a function that operates on a stack or appends to some growable array, it&#39;s often worth pre-allocating an array with enough capacity that it will never have to grow.</p>
<p>I tried this for some hot code and it did indeed get faster, but then spent more time in garbage collection.</p>
<p>I <em>think</em> that the reason for this is that go doesn&#39;t distinguish between constant slices and growable arrays. Instead both are represent by the same <code>(ptr, len, cap)</code> struct and the underlying allocation only stores the data and doesn&#39;t have a len field (unlike eg julia). This means that the garbage collector always has to scan the whole allocation, even if the length of every slice referring to it is zero.</p>
<h2 id="benchmark-mode">benchmark_mode</h2>
<p>On the one hand you shouldn&#39;t run benchmarks on a laptop. On the other hand I only have a laptop.</p>
<p>I have a script that reduces the noise a fair amount. For a while it was broken when everything moved to cgroups_v2, but I finally got around to fixing it. It&#39;s split into two to make the sudoing easier:</p>
<p><code>benchmark</code>:</p>
<pre data-lang="bash"><code data-lang="bash"><span>#!/usr/bin/env bash
</span><span>
</span><span>set </span><span>-e
</span><span>
</span><span>if </span><span>[ </span><span>&#34;$</span><span>(</span><span>cat</span><span> /sys/class/power_supply/ACAD/online</span><span>)</span><span>&#34; </span><span>!=</span><span> 1 </span><span>]
</span><span>then
</span><span>  </span><span>echo </span><span>&#34;Don&#39;t benchmark on battery power&#34;
</span><span>  </span><span>exit</span><span> 1
</span><span>fi
</span><span>
</span><span>sudo</span><span> benchmark_mode
</span><span>
</span><span># Run on reserved cpus
</span><span># High priority
</span><span># Record perf counters
</span><span>sudo </span><span>\
</span><span>cgexec</span><span> -g</span><span> cpuset:benchmark </span><span>\
</span><span>nice</span><span> -n -20 </span><span>\
</span><span>perf stat </span><span>\
</span><span>sudo</span><span> -u</span><span> jamie </span><span>\
</span><span>&#34;$</span><span>@</span><span>&#34;
</span></code></pre>
<p><code>benchmark_mode</code>:</p>
<pre data-lang="bash"><code data-lang="bash"><span>#!/usr/bin/env bash
</span><span>
</span><span>set </span><span>-e
</span><span>
</span><span># Setup benchmark cpus
</span><span>if </span><span>[ </span><span>! </span><span>-d</span><span> /sys/fs/cgroup/benchmark </span><span>]
</span><span>then
</span><span>    </span><span>mkdir</span><span> /sys/fs/cgroup/benchmark
</span><span>fi
</span><span>echo </span><span>&#39;root&#39; </span><span>&gt;</span><span> /sys/fs/cgroup/benchmark/cpuset.cpus.partition
</span><span>for</span><span> f </span><span>in</span><span> /sys/fs/cgroup/</span><span>*</span><span>/cpuset.cpus</span><span>; </span><span>do </span><span>echo </span><span>&#39;2-15&#39; </span><span>&gt; </span><span>$f</span><span>; </span><span>done
</span><span>echo </span><span>&#39;0-1&#39; </span><span>&gt;</span><span> /sys/fs/cgroup/benchmark/cpuset.cpus
</span><span>
</span><span># Set scaling_governer to performance on benchmark cores
</span><span>echo</span><span> performance </span><span>&gt;</span><span> /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
</span><span>echo</span><span> performance </span><span>&gt;</span><span> /sys/devices/system/cpu/cpu1/cpufreq/scaling_governor
</span><span>
</span><span># Turn off turbo mode on all cpus
</span><span>echo</span><span> 1 </span><span>&gt;</span><span> /sys/devices/system/cpu/intel_pstate/no_turbo
</span><span>
</span><span># Disable ASLR
</span><span>echo</span><span> 0 </span><span>&gt;</span><span> /proc/sys/kernel/randomize_va_space‚èé 
</span></code></pre>
<p>I still have to be careful with everything else. Make sure nothing is running in the background. Watch the cpu temperature to make sure I&#39;m not getting thermal throttling. But it&#39;s good enough for most work.</p>
<h2 id="niri">niri</h2>
<p>I switched from <a href="https://github.com/swaywm/sway/">sway</a> to <a href="https://github.com/YaLTeR/niri">niri</a>. It&#39;s worth it for the <a href="https://github.com/YaLTeR/niri/releases/tag/v25.05">overview</a> feature alone (I&#39;m always losing my video call window during meetings), but the sideways-scrolling model also works a bit better for me than tiling a single screen and the builtin screenshotting/casting tools work better than what I cobbled together for sway.</p>
<p>The only thing I don&#39;t like is that it automatically deletes any empty workspace and moves the others up. This makes it hard to use absolute shortcuts (mod + 1-9) for workspaces because they&#39;re always changing position. In sway I just had muscle memory that eg my work notes are always on workspace 9.</p>
<h2 id="linkrot">linkrot</h2>
<p>I run a linkchecker on this site and found 313 broken links. A big chunk of those were from citeseer changing their permalink scheme (you had one job) and from academic department sites getting reorganized.</p>
<p>One of the arguments I&#39;ve heard for the academic publishing system is that it&#39;s better at preserving citations, but that&#39;s only true if you cite by doi and indirect through google scholar. In terms of actual urls, I&#39;ve found that linking to the authors blog is much more reliable than linking directly to a paper.</p>
<h2 id="sea-of-nos">sea of nos</h2>
<p>There is often a <a href="https://en.wikipedia.org/wiki/Missing_stair">missing stair</a> kind of effect in niche technical topics where the mainstream consensus on techniques doesn&#39;t reflect what experts are actually doing.</p>
<p>For example, if you study cs in school you&#39;ll learn all about various kinds of grammars and clever ways to parse them. If you read books about compilers they&#39;ll spend a bunch of time on table-driven parser generators. If you read PL blogs everyone is really into parser combinators. And then you work on a real project and try to do what seems like the standard thing and... it&#39;s awful. And you look around at <a href="https://notes.eatonphil.com/parser-generators-vs-handwritten-parsers-survey-2021.html">real industrial programming language implementations</a> and find that almost all of them write their own parsers by hand because that is by far the easiest and most effective option. Everyone who actually works on real compilers knows this, but somehow the knowledge doesn&#39;t filter out.</p>
<p>So anyway V8 used <a href="https://en.wikipedia.org/wiki/Sea_of_nodes">sea of nodes</a> for a long time but recently <a href="https://v8.dev/blog/leaving-the-sea-of-nodes">switched back to a traditional CFG</a>. This prompted a <a href="https://github.com/SeaOfNodes/Simple/blob/main/ASimpleReply/ASimpleReplyChain.md">long back-and-forth</a> between the V8 folks and Cliff Click, the inventor of sea of nodes, about why exactly it wasn&#39;t a good fit for V8. The normal course of things would have been for V8 to make this change quietly and for the discussion to have happened in private, so that you&#39;d only learn about it if you happended to already be part of the tiny network of industrial compiler engineers. Kudos to everyone involved for doing it in public.</p>
<h2 id="llm-outsourcing">llm outsourcing</h2>
<p>I&#39;ve seen a lot of people confident that companies won&#39;t replace programmers with llms because llms produce poor quality code.</p>
<p>Early in my career I consulted for a company who outsourced most of their software development. I once spent several weeks of back-and-forth trying to get their outsourcerse to correctly url-escape their api calls to the service I was responsible for. The resulting code included this gem:</p>
<pre><code><span>//*********************************************
</span><span>// this function trims the trailing spaces on both the sides
</span><span>//*********************************************
</span><span>function trim(TRIM_VALUE) {
</span><span>	if(TRIM_VALUE.length &lt; 1) {
</span><span>		return&#34;&#34;;
</span><span>	}
</span><span>	TRIM_VALUE = RTrim(TRIM_VALUE);
</span><span>	TRIM_VALUE = LTrim(TRIM_VALUE);
</span><span>	if(TRIM_VALUE == &#34;&#34;) {
</span><span>		return &#34;&#34;;
</span><span>	} else {
</span><span>		return TRIM_VALUE;
</span><span>	}
</span><span>}//End Function
</span><span>
</span><span>//*********************************************	
</span><span>/*Function for Trimming spaces from right side of a String*/
</span><span>//*********************************************
</span><span>function RTrim(VALUE) {
</span><span>	var w_space = String.fromCharCode(32);
</span><span>	var v_length = VALUE.length;
</span><span>	var strTemp = &#34;&#34;;
</span><span>	if(v_length &lt; 0) {
</span><span>		return&#34;&#34;;
</span><span>	}
</span><span>	var iTemp = v_length -1;
</span><span>	while(iTemp &gt; -1) {
</span><span>	    if(VALUE.charAt(iTemp) == w_space) {
</span><span>	    } else {
</span><span>	    	strTemp = VALUE.substring(0,iTemp +1);
</span><span>	     	break;
</span><span>	    }
</span><span>	    iTemp = iTemp-1;
</span><span>	} //End While
</span><span>	return strTemp;
</span><span>} //End Function
</span><span>
</span><span>//*********************************************		
</span><span>/*Function for Trimming spaces from left side of a String*/
</span><span>//*********************************************
</span><span>function LTrim(VALUE) {
</span><span>	var w_space = String.fromCharCode(32);
</span><span>	if(v_length &lt; 1) {
</span><span>		return&#34;&#34;;
</span><span>	}
</span><span>	var v_length = VALUE.length;
</span><span>	var strTemp = &#34;&#34;;
</span><span>	var iTemp = 0;
</span><span>	while(iTemp &lt; v_length) {
</span><span>		if(VALUE.charAt(iTemp) == w_space) {
</span><span>		} else {
</span><span>			strTemp = VALUE.substring(iTemp,v_length);
</span><span>			break;
</span><span>		}
</span><span>		iTemp = iTemp + 1;
</span><span>	} //End While
</span><span>	return strTemp;
</span><span>} //End Function
</span></code></pre>
<p>This is not atypical for code that I&#39;ve seen from outsourcing, or even from big domestic consulting companies. If companies are willing to pay for this, they will be willing to pay for something that is cheaper, higher-quality, and has faster turnaround times.</p>
<p>(The company in question did eventually create their own internal software team, and one of their first hires was the one person at the outsourcing company who, at one end of a long game of telephone through multiple layers of managers, was actually doing all the work.)</p>
<p>In the short term this might actually mean more work for me. My hunch is that llms are going to be much better at digging their way into performance holes than they are at climbing out of them, because the latter requires a lot of non-local reasoning and complex tool use.</p>
<p>I can&#39;t actually test at the moment (feeding my clients proprietary code and production data into a third-party system under a personal account would be questionable at best). But after this contract I&#39;d be interested in collaborating with someone who is proficient with llm tools to see if they&#39;re at all useful for optimizing some large open-source codebase.</p>
<h2 id="books">books</h2>
<p><a href="https://www.goodreads.com/book/show/36606264-human-errors">Human errors</a>. The first few chapters were good and then the rest felt like filler. But lots of good party factoids. Did you know that humans are way more prone to head-colds than other animals - in part because when we became bipedal our sinuses did not reorient, so now they don&#39;t drain properly.</p>
<p><a href="https://www.goodreads.com/book/show/17736859-the-story-of-the-human-body">The story of the human body</a>. Really repetitive and full of filler, but was worth reading to catch up on the last decade or two of discoveries. Eg bipedalism came long before serious tool use, so may have been driven more by caloric efficiency moving between receding patches of rainforest.</p>
<p><a href="https://www.goodreads.com/book/show/25852784-evicted">Evicted</a>. Depressing as hell, but an incredible work. The author spent years living in the poorest neighbourhoods in Milwaukee, making friends with residents and shadowing landlords while they worked, and then used all of that knowledge to know what questions to ask and how to understand the answers when doing wide-scale quantitative research. I also really appreciated the way the book itself was written - any text in quote marks was transcribed from a recording, anything the author didn&#39;t directly witness is labeled in footnotes, any time they describe someone as thinking or feeling something it was reported by that person rather than inferred. They also hired a fact-checker to randomly sample claims and match them to sources in their notes/recordings. I wish everything was reported this way.</p>
<p><a href="https://www.goodreads.com/book/show/209543060-character-limit">Character limit</a>. I enjoyed all the crazy stories, but I can&#39;t help contrasting it to Evicted. So many times they describe Elons thoughts or feelings and it&#39;s really not clear where that is coming from. They also don&#39;t clearly distinguish between directly recorded events and distant recollections of witnesses. Evicted proved that you can be really rigorous about reporting without it hurting the writing at all. And I don&#39;t think the embellishment is necessary at all - Elons actions speak for themselves.</p>

</article></div>
  </body>
</html>
