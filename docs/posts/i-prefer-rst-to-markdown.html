<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://buttondown.email/hillelwayne/archive/why-i-prefer-rst-to-markdown/">Original</a>
    <h1>I prefer rST to Markdown</h1>
    
    <div id="readability-page-1" class="page"><div>
                
                    <date>
                        
                            July 31, 2024
                        </date>
                
                
                
                    <h2>
                        I will never stop dying on this hill
                    </h2>
                

                

                
                    
                        <p>I just published a new version of <a href="https://leanpub.com/logic/" target="_blank">Logic for Programmers</a>! v0.2 has epub support, content on constraint solving and formal specification, and more! Get it <a href="https://leanpub.com/logic/" target="_blank">here</a>.</p>
<p>This is my second book written with <a href="https://www.sphinx-doc.org/en/master/" target="_blank">Sphinx</a>, after the new <a href="https://www.learntla.com/" target="_blank">Learn TLA+</a>. Sphinx uses a peculiar markup called <a href="https://docutils.sourceforge.io/rst.html" target="_blank">reStructured Text</a> (rST), which has a steeper learning curve than markdown. I only switched to it <em>after</em> writing a couple of books in markdown and deciding I needed something better. So I want to talk about why rst was that something.<sup id="fnref:rst"><a href="#fn:rst">1</a></sup></p>
<h2>Why rst is better</h2>
<p>The most important difference between rst and markdown is that markdown is a lightweight representation of html, while rst is a midweight representation of an abstract documentation tree.</p>
<p>It&#39;s easiest to see this with a comparison. Here&#39;s how to make an image in html:</p>

<p>Technically, you don&#39;t even need a parser for this. You just need a regex to transform it into  <code>&lt;img alt=&#34;alttext&#34; src=&#34;example.jpg&#34;/&gt;</code>. Most modern markdown engines <em>do</em> parse this into an intermediate representation, but the <em>essence</em> of markdown is that it&#39;s a lightweight html notation.</p>
<p>Now here&#39;s how to make an image in rst:</p>
<div><pre><span></span><code><span>..</span> <span>image</span><span>::</span> example.jpg
  <span>:alt:</span> alttext
</code></pre></div>
<p><code>.. image::</code> defines the image &#34;directive&#34;. When Sphinx reads it, it looks up the registered handler for the directive, finds <code>ImageDirective</code>, invokes <code>ImageDirective.run</code>, which returns an <code>image_node</code>, which is an object with an <code>alt</code> field containing &#34;alttext&#34;. Once Sphinx&#39;s processed all nodes, it passes the whole doctree to the HTML Writer, which looks up the rendering function for <code>image_node</code>, which tells it to output an <code>&lt;image&gt;</code> tag.</p>
<p>Whew that&#39;s a mouthful. And for all that implementation complexity, we getâ€¦  an interface that has 3x the boilerplate as markdown.</p>
<p>On the other hand, the markdown image is hardcoded as a special case in the parser, while the rst image is not. It was added in the exact same way as every other directive in rst: register a handler for the directive, have the handler output a specific kind of node, and then register a renderer for that node for each builder you want.</p>
<p>This means you can extend Sphinx with new text objects! Say you that instead of an <code>&lt;image&gt;</code>, you want a <code>&lt;figure&gt;</code> with a <code>&lt;figcaption&gt;</code>. In basic markdown you have to manually insert the html, with Sphinx you can just register a new <code>figure</code> directive. You can even make your <code>FigureDirective</code> subclass <code>ImageDirective</code> and have it do most of the heavy lifting.</p>
<p>The second benefit is more subtle: you can transform the doctree before rendering it. This is how Sphinx handles cross-referencing: if I put a <code>foo</code> anchor in one document and <code>:ref:`image &lt;foo&gt;`</code> in another, Sphinx will insert the right URL during postprocessing. The transformation code is also first-class with the rest of the build process: I can configure a transform to only apply when I&#39;m outputting html, have it trigger in a certain stage of building, or even remove a builtin transform I don&#39;t want to run.</p>
<p>Now, most people may not need this kind of power! Markdown is ubiquitous because it&#39;s lightweight and portable, and rst is anything but. But <em>I</em> need that power.</p>

<h3>One use case</h3>
<p><em>Logic for Programmers</em> is a math-adjacent book, and all good math books need exercises for the reader. It&#39;s easier to write an exercise if I can put it and the solution right next to each other in the document. But for readers, I want the solutions to show up in the back of the book. I also want to link the two together, and since I might want to eventually print the book, the pdfs should also include page references. Plus they need to be rendered in different ways for latex (pdf) output and epub output. Overall lots of moving parts.</p>
<p>To handle this I wrote my own exercise extension.</p>
<div><pre><span></span><code><span>.. in chapter.rst</span>
<span>..</span> <span>exercise</span><span>::</span> Fizzbuzz
  <span>:name:</span> ex-fizzbuzz

  An exercise

<span>..</span> <span>solution</span><span>::</span> ex-fizzbuzz

  A solution

<span>.. in answers.rst</span>

<span>..</span> <span>solutionlist</span><span>::</span>
</code></pre></div>
<p>How these nodes are processed depends on my compilation target. I like to debug in HTML, so for HTML it just renders the exercise and solution inline.</p>
<p>When generating epub and latex, though, things works a little differently. After generating the whole doctree, I run a transform that moves every solution node from its original location to under <code>solutionlist</code>. Then it attaches a reference node to every exercise, linking it to the <em>new</em> solution location, and vice versa. So it starts like this (using Sphinx&#39;s &#34;pseudoxml&#34; format): </p>
<div><pre><span></span><code>--<span> </span>chapter.rst
<span>&lt;exercise_node</span><span> </span><span>ids=</span><span>&#34;ex-fizzbuzz&#34;</span><span>&gt;</span>
<span>  </span><span>&lt;title&gt;</span>
<span>    </span>Fizzbuzz
<span>  </span><span>&lt;paragraph&gt;</span>
<span>    </span>An<span> </span>exercise
<span>&lt;solution_node</span><span> </span><span>ids=</span><span>&#34;ex-fizzbuzz-sol&#34;</span><span>&gt;</span>
<span>  </span><span>&lt;paragraph&gt;</span>
<span>    </span>A<span> </span>solution

--<span> </span>answers.rst
<span>&lt;solutionlist_node&gt;</span>
</code></pre></div>
<p>And it becomes this:</p>
<div><pre><span></span><code>--<span> </span>chapter.rst
<span>&lt;exercise_node</span><span> </span><span>ids=</span><span>&#34;ex-fizzbuzz&#34;</span><span>&gt;</span>
<span>  </span><span>&lt;title&gt;</span>
<span>    </span>Fizzbuzz
<span>  </span><span>&lt;paragraph&gt;</span>
<span>    </span>An<span> </span>exercise
<span>    </span><span>&lt;exsol_ref_node</span><span> </span><span>refuri=</span><span>&#34;/path/to/answers#ex-fizzbuzz-sol&#34;</span><span>&gt;</span>
<span>      </span>Solution

--<span> </span>answers.rst
<span>&lt;solutionlist_node&gt;</span>
<span>  </span><span>&lt;solution_node</span><span> </span><span>ids=</span><span>&#34;ex-fizzbuzz-sol&#34;</span><span>&gt;</span>
<span>    </span><span>&lt;paragraph&gt;</span>
<span>      </span>A<span> </span>solution
<span>      </span><span>&lt;exsol_ref_node</span><span> </span><span>refuri=</span><span>&#34;/path/to/chapter#ex-fizzbuzz&#34;</span><span>&gt;</span>
<span>        </span>(back)
</code></pre></div>

<p>The Latex builder renders this by wrapping each exercise and solution in an <a href="https://ctan.org/pkg/exercise" target="_blank">answers environment</a>, while the epub builder renders the solution as a <a href="https://help.apple.com/itc/booksassetguide/en.lproj/itccf8ecf5c8.html" target="_blank">popup footnote</a>.<sup id="fnref:exsol_ref"><a href="#fn:exsol_ref">2</a></sup> Making this work:</p>
<p><img alt="An example of solution popups on an epub reader" src="https://assets.buttondown.email/images/8a7d66e3-56bd-4b7a-95ac-d4fdf88047c7.png?w=960&amp;fit=max"/> </p>
<p>It&#39;s a complex dance of operations, but it works enormously well. It even helps with creating a &#34;free sample&#34; subset of the book: the back of the free sample only includes the solutions from the included subset, not the whole book!</p>
<h3>&#34;But I hate the syntax&#34;</h3>
<p>When I gush about rST to other programmers, this is the objection I hear the most: it&#39;s ugly. </p>
<p>To which I say, are you really going to avoid using a good tool just because it makes you puke? Because looking at it makes your stomach churn? Because it offends every fiber of your being?</p>
<p>...Okay yeah that&#39;s actually a pretty good reason not to use it. I can&#39;t get into lisps for the same reason. I&#39;m not going to begrudge anybody who avoids a tool because it&#39;s ugly.</p>
<p>Maybe you&#39;d find <a href="https://github.com/asciidoctor/asciidoctor" target="_blank">asciidoc</a> more aesthetically pleasing? Or <a href="https://mystmd.org/spec" target="_blank">MyST</a>? Or <a href="https://github.com/typst/typst" target="_blank">Typst</a>? Or <a href="https://docs.racket-lang.org/pollen/" target="_blank">Pollen</a>? Or even <a href="https://pandoc.org/MANUAL.html#extension-attributes" target="_blank">pandoc-extended markdown</a>? There are lots of solid document builders out there! My point isn&#39;t that sphinx/rst is exceptionally <em>good</em> for largescale documentation, it&#39;s that simple markdown is exceptionally <em>bad</em>. It doesn&#39;t have a uniform extension syntax or native support for pre-render transforms.</p>
<p>This is why a lot of markdown-based documentation generators kind of hack on their own preprocessing step to support new use-cases, which works for the most part (unless you&#39;re trying to do something really crazy). But they have to work around the markdown, not in it, which limits how powerful they can be. It also means that most programmer tooling can&#39;t understand it well. There&#39;s LSP and treesitter for markdown and rst but not for gitbook-markdown or md-markdown or leanpub-markdown.<sup id="fnref:treesitter"><a href="#fn:treesitter">3</a></sup></p>
<p>But if you find a builder that uses markdown and satisfies your needs, more power to you! I just want to expose people to the idea that doc builders can be a lot more powerful than they might otherwise expect.</p>
<hr/>
<h3>No newsletter next week</h3>
<p>I&#39;ll be in Hong Kong.</p>
<h2>Update 2024-07-31</h2>
<p>Okay since this is blowing up online I&#39;m going to throw in a quick explanation of <em>Logic for Programmers</em> for all of the non-regulars here. I&#39;m working on a book about how formal logic is useful in day-to-day software engineering. It starts with a basic rundown of the math and then goes into eight different applications, such as property testing, database constraints, and decision tables. It&#39;s still in the alpha stages but already 20k words and has a lot of useful content. You can find it <a href="https://leanpub.com/logic" target="_blank">here</a>. Reader feedback highly appreciated!</p>

                    
                

                
                    <p><em>If you&#39;re reading this on the web, you can subscribe <a href="https://buttondown.email/hillelwayne" target="_blank">here</a>. Updates are once a week. My main website is <a href="https://www.hillelwayne.com" target="_blank">here</a>.</em></p>
                

            </div></div>
  </body>
</html>
