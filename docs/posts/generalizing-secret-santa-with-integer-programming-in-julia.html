<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://paulbutler.org/2022/generalizing-secret-santa-with-integer-programming-in-julia/">Original</a>
    <h1>Generalizing Secret Santa with integer programming in Julia</h1>
    
    <div id="readability-page-1" class="page"><div><p>You might know Secret Santa as the gifting game where each person in a group is assigned another person in the group to give a gift to.</p>
<p>For three years in a row, I’ve organized a post card exchange for plotter enthusiasts called <a href="https://twitter.com/search?q=%23ptpx&amp;src=typed_query&amp;f=live"><strong>#ptpx</strong></a>, which I think of as a sort of “generalized Secret Santa”. Instead of just sending and receiving one gift, participants choose how many postcards they’d like to make and send.</p>
<p>To give you an idea, here are some cards I received last year from <a href="https://www.pentronik.net/">@pentronik</a> and <a href="https://twitter.com/Aldernero">@aldernero</a>:</p>
<p><img src="https://social.afront.org/@kwf/postcards.jpeg"/></p>
<p>You can think of any gift exchange as a directed graph, with each node representing a participant, and edges going from senders to receivers. A traditional, 1:1 Secret Santa could be organized by shuffling all of the participants, and having each send a gift to the next person in order (wrapping around at the end).</p>
<p>The generalized variant of Secret Santa has no such trivial construction, so instead I’ve turned to <strong>integer programming</strong>.</p>
<p>Integer programming, and optimization in general, can seem a bit scary to people (like myself) who have no formal background in it, so I wanted to demystify it by showing how I use it to solve a real-world problem.</p>
<h2 id="constraints">Constraints</h2>
<p>We’ve established that we need to generate a graph, so let’s formalize the constraints in terms of a graph:</p>
<ul>
<li>Each participant sends as many cards as they signed up for. <strong>This is a constraint on the out-degree of each node.</strong></li>
<li>Each participant receives as many cards as they signed up for. <strong>This is a constraint on the in-degree of each node.</strong></li>
<li>No participant sends a card to themselves. <strong>There are no self-loops.</strong></li>
<li>To keep things interesting, there are no direct mutual exchanges in which a participant both sends and receives a card from the same other participant. <strong>The graph has a minimum <a href="https://mathworld.wolfram.com/Girth.html">girth</a> of three.</strong></li>
</ul>
<p>Here’s a diagram of some graphs these constraints prevent:</p>
<p><img src="https://social.afront.org/@kwf/invalid-graphs.png"/></p>
<h2 id="matrix-form">Matrix form</h2>
<p>A directed graph can be expressed as a square matrix <em>A</em> in which the <em>i<sup>th</sup></em> node corresponds to both the <em>i<sup>th</sup></em> row and the <em>i<sup>th</sup></em> column. The matrix cell <em>A<sub>jk</sub></em> contains a <code>1</code> if the corresponding graph node <em>j</em> has an out-edge to graph node <em>k</em>; otherwise it contains a <code>0</code>.</p>
<p>Our constraints can be translated into this matrix form.</p>
<ul>
<li>Each participant sends as many cards as they signed up for. <strong>The sums of each row equal (element-wise) the cards to be sent by each participant.</strong></li>
<li>Each participant receives as many cards as they signed up for. <strong>The sum of each column (element-wise) equals the number of cards to be received by each participant.</strong></li>
<li>No participant sends a card to themselves. <strong>The diagonal entries of the matrix are all zero.</strong></li>
<li>No mutual exchanges. <strong>For all nodes <em>j</em> and <em>k</em>, the entry at <em>A<sub>jk</sub></em> and <em>A<sub>kj</sub></em> are mutually exclusive.</strong></li>
</ul>
<p>Here are some examples of adjacency matrices that violate these constraints:</p>
<p><img src="https://social.afront.org/@kwf/invalid-matrix.png"/></p>
<h2 id="linear-optimization">Linear optimization</h2>
<p>For the purpose of generating the adjacency matrix, the only information we need is an array with the desired number of cards for each participant. For example, if we have  five participants who want to send three cards and four participants who want to send two cards, we could represent that as:</p>
<div><pre tabindex="0"><code data-lang="julia">node_degrees <span>=</span> [<span>3</span>, <span>3</span>, <span>3</span>, <span>3</span>, <span>3</span>, <span>2</span>, <span>2</span>, <span>2</span>, <span>2</span>]
</code></pre></div><p>We could order these however we want, as long as we preserve a mapping so that we know which participant each entry refers to.</p>
<p>Our job is then take a list in this form, and return an adjacency matrix that satisfies the four properties mentioned above.</p>
<p>I’ve chosen to use <a href="https://julialang.org/">Julia</a> for this, because of its excellent <a href="https://jump.dev/JuMP.jl/stable/">JuMP</a> optimization library.</p>
<p>JuMP does not implement a solver itself, but instead provides a friendly Julia-based interface that can map to <a href="https://jump.dev/JuMP.jl/stable/installation/#Supported-solvers">a variety of solvers</a> which must be installed separately.</p>
<p>There are different types of solvers which support different types of constraints. Because my constraints aren’t very fancy, and I don’t know much about this stuff, I didn’t put too much thought into selecting a solver. I picked <code>SCIP</code> because it was free and easy to install.</p>
<p>JuMP is fairly straightforward to use. The steps are:</p>
<h3 id="1-create-a-model-object-and-select-an-optimizer">1: Create a model object and select an optimizer.</h3>
<div><pre tabindex="0"><code data-lang="julia">model <span>=</span> Model(SCIP<span>.</span>Optimizer)
</code></pre></div><h3 id="2-define-the-variables-you-want-to-optimize-over">2: Define the variables you want to optimize over.</h3>
<p>In our case, this means one binary variable for each cell in the adjacency matrix.</p>
<div><pre tabindex="0"><code data-lang="julia">N <span>=</span> length(node_degrees)

<span>@variable</span>(model, x[s<span>=</span><span>1</span><span>:</span>N, r<span>=</span><span>1</span><span>:</span>N], Bin)
</code></pre></div><p>JuMP uses Julia macros (which start with <code>@</code>) to create a sort of <a href="https://en.wikipedia.org/wiki/Domain-specific_language">domain-specific language</a> for specifying models within Julia.</p>
<p>In this case, I’m telling it to create a variable called <code>x</code>, attached to the <code>model</code> we just created, representing an <code>N</code>-by-<code>N</code> matrix of binary (<code>Bin</code>) values. We’ve defined <code>N</code> to be the number of participants in the exchange.</p>
<h3 id="3-define-the-constraints-you-want-the-solution-to-satisfy">3: Define the constraints you want the solution to satisfy.</h3>
<div><pre tabindex="0"><code data-lang="julia"><span>@constraint</span>(model,
    cards_sent[i<span>=</span><span>1</span><span>:</span>N], sum(x[i,<span>:</span>]) <span>==</span> node_degrees[i])
</code></pre></div><p>This creates an array of <code>N</code> constraints called <code>cards_sent</code> that ensures that the sum of the <em>i<sup>th</sup></em> row is equal to the number of cards that the <em>i<sup>th</sup></em> participant signed up to send.</p>
<div><pre tabindex="0"><code data-lang="julia"><span>@constraint</span>(model,
    cards_received[i<span>=</span><span>1</span><span>:</span>N], sum(x[<span>:</span>,i]) <span>==</span> node_degrees[i])
</code></pre></div><p>Similarly, this creates an array of <code>N</code> constraints called <code>cards_received</code> that ensures that the sum of the <em>i<sup>th</sup></em> <strong>column</strong> is equal to the number of cards that the <em>i<sup>th</sup></em> participant should receive.</p>
<div><pre tabindex="0"><code data-lang="julia"><span>@constraint</span>(model, no_mutual_exchange[i<span>=</span><span>1</span><span>:</span>N,j<span>=</span><span>1</span><span>:</span>i], x[i,j] <span>+</span> x[j,i] <span>&lt;=</span> <span>1</span>)
</code></pre></div><p>This creates more constraints called <code>no_mutual_exchange</code> which ensure that each participant can either be a sender or receiver to a given other participant, but not both.</p>
<p>We could also specify a condition to explicitly prohibit self-loops:</p>
<div><pre tabindex="0"><code data-lang="julia"><span>@constraint</span>(model, no_self_loop[i<span>=</span><span>1</span><span>:</span>N], x[i,i] <span>==</span> <span>0</span>)
</code></pre></div><p>But we don’t actually need to. A self-loop would be considered a mutual exchange by the definition we used above, since if <code>x[k, k] == 1</code>, <code>x[k, k] + x[k, k] &gt; 1</code> in violation of <code>no_mutual_exchange[k, k]</code>.</p>
<h3 id="4-optionally-define-an-objective-you-want-the-solver-to-maximize">4: Optionally, define an objective you want the solver to maximize.</h3>
<p>We can skip this, because we don’t have an objective to optimize for.</p>
<h3 id="5-run-the-solver">5: Run the solver.</h3>
<p>Tell JuMP that you’re done specifying the model and ready to run it, then wait and retrieve the result.</p>
<div><pre tabindex="0"><code data-lang="julia">optimize!(model)
</code></pre></div><p>This attempts to find a value of the variable(s) in question that satisfy the constraints and (if there is one) maximize the objective.</p>
<div><pre tabindex="0"><code data-lang="julia">result <span>=</span> JuMP<span>.</span>value<span>.</span>(x) <span>.==</span> <span>1.0</span>
</code></pre></div><p>Finally, we pull the resulting value assigned to the variable. Even though we declared <code>x</code> as binary, JuMP returns it as a <code>Matrix{Float64}</code>, so we use element-wise equality with <code>1.0</code> to get back a <code>BitMatrix</code>.</p>
<p>Here’s an example value of <code>result</code> for the example input above, <code>[3, 3, 3, 3, 3, 2, 2, 2, 2]</code>:</p>
<div><pre tabindex="0"><code data-lang="text"> 0  0  0  0  0  1  0  1  1
 1  0  0  0  0  1  0  1  0
 1  1  0  0  0  0  0  0  1
 1  1  1  0  0  0  0  0  0
 0  1  1  1  0  0  0  0  0
 0  0  1  0  1  0  0  0  0
 0  0  0  1  1  0  0  0  0
 0  0  0  0  1  0  1  0  0
 0  0  0  1  0  0  1  0  0
</code></pre></div><p>We can verify by hand that:</p>
<ul>
<li>The first five columns and five rows sum to 3, and the remaining rows and columns sum to 2, matching the desired number of cards sent/received in the input vector.</li>
<li>There are no <code>1</code>s along the diagonal, so nobody sends a card to themselves.</li>
</ul>
<p>It’s harder by eyeball to ensure that there are no mutual exchanges, but it’s a one-liner to test:</p>
<div><pre tabindex="0"><code data-lang="julia">result <span>.&amp;</span> result<span>&#39;</span>
</code></pre></div><p>This does an element-wise <code>AND</code> between the matrix and its transpose. This will leave a <code>1</code> for every exchange pair that is mutual, so if the result is a zero matrix (as it is in this case), there are no mutual exchanges.</p>
<h2 id="performance">Performance</h2>
<p>I’m not sure what the runtime complexity of <code>SCIP</code>’s solving function is, but I know the overall algorithm is at least <code>O(n^2)</code> on the number of participants <code>n</code>, because the size of the output matrix is <code>n</code>-by-<code>n</code>.</p>
<p>The exchange I organized in 2020 had 22 participants. In 2021, we had 40. This year, the number grew to 76. So I’ve been wondering, how big would it have to get before I can’t use my program to solve it?</p>
<p>To answer this, I generated simulated exchanges with different numbers of participants. Although the runtime is worse than linear, I can still solve exchanges with up to 1,200 participants in under five minutes on my M1 mac.</p>
<p><img src="https://social.afront.org/@kwf/runtime.png"/></p>
<h2 id="further-reading">Further Reading</h2>
<ul>
<li>If you like the combination of Julia and Plotting, you might enjoy my talk from <a href="https://www.youtube.com/watch?v=L2KdOJRR3Vo">PlutoCon</a>.</li>
<li>If you like the application of mathematical optimization to a real-world problem, you might also enjoy <a href="https://nb.paulbutler.org/optimizing-plots-with-tsp-solver/">Optimizing Plots with a TSP Solver</a>.</li>
<li>If you want a not-so-scary and artsy introduction to optimization, I loved <a href="https://press.princeton.edu/books/hardcover/9780691164069/opt-art">Opt Art</a> by Robert Bosch.</li>
<li>To participate in the next #ptpx, sign up for the <a href="https://buttondown.email/ptpx">mailing list</a>.</li>
</ul>
</div></div>
  </body>
</html>
