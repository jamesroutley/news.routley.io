<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.executeprogram.com/blog/the-code-is-the-to-do-list">Original</a>
    <h1>The Code Is the To-Do List</h1>
    
    <div id="readability-page-1" class="page"><div><p>Managing our focus during development can be a challenge.
Here&#39;s a common scenario: we&#39;re in the middle of working on <code>user.ts</code> when we find ourselves thinking: &#34;I really need to go change this other thing in <code>login.ts</code>&#34;.
But it&#39;s rarely a good idea to interrupt ourselves during a complex change.
We have a lot of context in our heads that we don&#39;t want to lose.</p>
<p>There are two common ways to deal with this: we can write down a note that reminds us to do it later, or we can write a quick failing (or pending) test that forces us to do it later.</p>
<p>Both approaches work just fine.
However, there&#39;s a third way that&#39;s superior to both in some situations: we can use the code itself as a to-do list.
Specifically, we can use the linter to enforce our to-dos.</p>
<p>In <a href="https://www.executeprogram.com/" target="_blank">Execute Program</a>, we use <a href="https://eslint.org/" target="_blank">ESLint</a> with the &#34;no-warning-comments&#34; lint rule enabled:</p>
<pre>module.exports = {
  &#34;rules&#34;: {
    &#34;no-warning-comments&#34;: [&#34;error&#34;, {terms: [&#34;xxx&#34;], location: &#34;anywhere&#34;}],
    ...
  },
  ...
}
</pre>
<p>This configuration makes any comment containing &#34;XXX&#34; an error.
Lint errors cause our <a href="https://en.wikipedia.org/wiki/Continuous_integration" target="_blank">CI</a> builds to fail, which means our XXX comments block deployment to production.
As a result, we can now use XXX comments to mark critical problems that should never reach production.</p>
<p>(We could also use TODO comments instead of XXX by changing the ESLint configuration above.
But our convention is that TODO comments are for longer-term deferred maintenance like &#34;remove this old API endpoint&#34; and XXX means &#34;do not let this go to production&#34;.
The particular string &#34;XXX&#34; isn&#39;t important here.)</p>
<p>This approach is often better than separate to-do lists and failing tests because:</p>
<ol>
<li>Blocking deployment makes XXX comments more reliable than separate notes.
We might accidentally deploy code without addressing notes in a separate system, but the ESLint rule above prevents deploys that contain &#34;XXX&#34; comments.</li>
<li>Not all changes are easily expressed as tests.</li>
<li>Leaving a comment in the code is usually faster than writing a test or switching to a note-taking app.</li>
<li>Everyone working in the code can see the XXX comments, with no need to agree on a shared note-taking system.</li>
</ol>
<p>In the rest of this post, we&#39;ll see how XXX comments have helped our development process.
We&#39;ll review four real examples from the <a href="https://www.executeprogram.com/" target="_blank">Execute Program</a> codebase, ordered from simplest to most complex.
These examples come from a feature branch that&#39;s diverged from our main branch by about 3,500 lines.</p>
<pre>$ git diff main --stat | tail -1
 40 files changed, 2448 insertions(+), 1155 deletions(-)
</pre>
<p>There are a lot of moving parts in this release, so it&#39;s crucial to keep track of all the changes we need to make as we develop!</p>
<p><strong>1. Simplifying code</strong></p>
<pre>// XXX: Remove this module; it&#39;s trivial now.
</pre>
<p>We have a module that used to export several <a href="https://www.executeprogram.com/courses/typescript" target="_blank">TypeScript</a> types.
On this branch, all but one of those types are now gone.
We don&#39;t need this whole module to export one small type.
The type can live in the subsystem&#39;s top-level module instead.</p>
<p>This change feels quick, so it&#39;s tempting to make it immediately.
But it will be just as fast if we do it tomorrow.
We don&#39;t have any special context in our heads that makes this change faster today.</p>
<p>On the other hand, we probably have a lot of context in our heads about the bigger change that we were making when we noticed this.
Programming is highly dependent on short-term memory, and any distraction is a chance for us to forget details that may be important.
Leaving an XXX comment only takes a few seconds, keeps our attention on the current task, and ensures that we&#39;ll remember to remove this module later.</p>
<p><strong>2. Deferring a data format change</strong></p>
<pre>// XXX: This is inserting &#34;Start Case&#34; property names. They should be &#34;camelCase&#34;.
</pre>
<p>While working on this branch, we needed to change a data format.
Unlike the type definition change above, updating the rest of the code to match the new format will take a substantial amount of work.
This change will also impact some other parts of the system, so we&#39;d rather isolate it in a separate commit.</p>
<p>Like the module removal example, we don&#39;t want to distract ourselves.
And the need for a separate commit makes deferring this change an even easier decision.</p>
<p>Sometimes, the fine-grained version control details also matter.
You might think: Why not make the change now, then tease the two changes apart after the fact with <code>git add -p</code> or an interactive rebase?
In this case, many of the affected lines are very close to lines that we&#39;ve already changed.
Individual modifications from both of our changes would end up in the same <a href="https://www.gnu.org/software/diffutils/manual/html_node/Hunks.html" target="_blank">diff hunks</a>, which makes teasing them apart much more difficult.
The version control wrangling could end up taking longer than the change itself.</p>
<p><strong>3. Managing temporary environment changes</strong></p>
<pre>// XXX: Changed the number here for faster testing. Change it back.
</pre>
<p>Our code has an event-triggering threshold: when event A happens enough times, it triggers event B.
On this branch, we sometimes want to manually trigger event B after only a few occurrences of A, so we&#39;ve temporarily lowered this threshold.
But we don&#39;t want to accidentally push that change out, so we added an XXX comment.</p>
<p>Because we&#39;re working on a very stable part of the system, it doesn&#39;t make sense to lower the threshold permanently for our development environment.
Changing the threshold based on the environment adds application complexity.
Worse, it&#39;s yet another way that dev diverges from production, which is never desirable.
We decided that it was better for this branch to diverge temporarily than for the dev environment to diverge permanently.</p>
<p>An XXX comment allows us to keep using the lower threshold, and gives us peace of mind that we won&#39;t accidentally push this dangerous change to production.</p>
<p><strong>4. Documenting our work</strong></p>
<p>The application-specific details are removed from this example.
But its structure is as we wrote it in the real code.</p>
<pre>/* XXX: Write summary comment explaining this module
 *   - Mention that the foo() function is responsible for frobbing.
 *   - Mention that bar() hits Stripe, so avoid multiple calls to it. But none
 *     of the other functions is allowed to hit Stripe, so call them at will.
</pre>
<p>This branch introduces a major new module to the system.
The module will need a summary comment, so it&#39;s tempting to write it right away.
But writing module-level comments early on can be risky.</p>
<p>First, we may end up reverting our current changes, and this module may not even exist when the branch lands.
If we write a perfect, nicely-formed comment, that effort might be wasted.</p>
<p>Second, this module or the other modules around it might change during the lifetime of our branch.
We&#39;ll have a better sense for how the module fits into the system once the branch is stabilized, so that&#39;s a better time to finalize a high-level comment.</p>
<p>Finally, even if neither of those apply, the usual reasoning does still apply: we don&#39;t want to interrupt the change that we&#39;re making right now.</p>
<p>Even if we don&#39;t write the big comment up front, we can still make notes about what to include in it.
Using a bulleted list lets us capture notes in the moment, without needing to take the time to write a full, nicely-formatted comment.
This is a great example of how using the code as a to-do list balances tracking future work vs. interrupting our current task.</p>
<p><strong>ESLint in action</strong></p>
<p>Once the comments are in place, we can see them in our ESLint output.
Our dev script automatically runs ESLint on every source file change, so we&#39;ll see this continually.
This is also the output that will show up in CI, blocking deploys to production.</p>
<p>(The filenames are anonymized here because the exact details of the new subsystem aren&#39;t important.)</p>
<pre>[eslint:server] src/server/old-subsystem/old-file.ts
[eslint:server]   63:13  warning  Unexpected &#39;xxx&#39; comment: &#39;XXX: This is inserting &#34;Start Case&#34;...&#39;  no-warning-comments
[eslint:server]
[eslint:server] src/server/new-subsystem/types.d.ts
[eslint:server]   5:1  warning  Unexpected &#39;xxx&#39; comment: &#39;XXX: Remove this module; it&#39;s trivial...&#39;  no-warning-comments
[eslint:server]
[eslint:server] src/server/new-subsystem/index.ts
[eslint:server]    7:1   warning  Unexpected &#39;xxx&#39; comment: &#39;XXX: Write summary comment explaining...&#39;    no-warning-comments
[eslint:server]   94:11  warning  Unexpected &#39;xxx&#39; comment: &#39;XXX: Changed the number here for faster...&#39;  no-warning-comments
[eslint:server]
[eslint:server] ✖ 4 problems (0 errors, 4 warnings)
[eslint:server]
[eslint:server] ESLint found too many warnings (maximum: 0).
</pre>
<p><strong>Development flow</strong></p>
<p>In large changes, it&#39;s common for us to have dozens of these XXX lint errors live at once.
Usually, the arc of a large change is:</p>
<ul>
<li>Begin with the most risky parts of the change.
It&#39;s usually best to start with the riskiest part.
If the risks turn into serious problems, we may reprioritize or even cancel this project.
We want that to happen at the beginning, rather than after we&#39;ve spent a lot of effort on it.</li>
<li>As we do the most risky work, we defer other work that we encounter along the way, adding XXX comments.</li>
<li>At some point, we reach &#34;peak XXX&#34;, which is often dozens of XXX comments at once.</li>
<li>Then we begin resolving them until there are none left.</li>
</ul>
<p>By the time we&#39;re resolving XXX comments, some will be outdated due to other changes made after we added the comment.
That&#39;s fine; it&#39;s just a comment, and we can delete it.
(But if we&#39;d made the change at the time, that work would&#39;ve been wasted!)</p>
<p>Even when the comments are still current, they&#39;re often quick changes that were just a bit too big to distract ourselves with at the time.
We estimate that the downward slope from &#34;peak XXX&#34; to &#34;0 XXX&#34; is usually around 10% of the total development time for a branch.
All of that work was going to happen one way or another; we just shifted it in time to aid our concentration and to allow better risk prioritization.</p>
<p>Using the linter to block XXXs from going to production is a great alternative to keeping a separate to-do list, or writing a test for every change we think of.
Writing XXX comments isn&#39;t just faster; it protects our focus and prioritizes our attention.
Give this approach a try on your next project!</p>
</div></div>
  </body>
</html>
