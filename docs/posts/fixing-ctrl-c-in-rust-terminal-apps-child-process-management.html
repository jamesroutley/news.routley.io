<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.fiveonefour.com/blog/Fixing-ctrl-c-in-terminal-apps-child-process-management">Original</a>
    <h1>Fixing Ctrl&#43;C in Rust terminal apps: Child process management</h1>
    
    <div id="readability-page-1" class="page"><div><section><div><div><h2>Published Tue, July 29, 2025 ∙ Product, Update ∙ by Nicolas Joseph</h2></div></div></section><section><div><p>When a terminal application that spawns child processes doesn&#39;t exit cleanly after a <code>Ctrl+C</code>, the user is left with a corrupted terminal. Instead of a clean prompt, you get garbled output and a non-functional shell. This post covers how to solve these issues, with examples from the <a href="https://github.com/514-labs/moose/">Moose CLI</a> (for the PR that fixed many of these issues, see <a href="https://github.com/514-labs/moose/pull/2561">here</a>).</p>
<!--$--><!--/$-->
<p>In this post, you’ll read learnings from solving these issues in the Moose CLI— terminal application that manages multiple child processes, including Docker containers, TypeScript compilers, and background workers.</p>
<h2>The Problems: Terminal Corruption and Hanging Processes</h2>
<p>Terminal corruption manifests in several ways:</p>
<ol>
<li><strong>Terminal State Corruption</strong>: After Ctrl+C, the terminal cursor might be hidden, raw mode might still be enabled, or the alternate screen buffer might still be active</li>
<li><strong>Child Process Output Interference</strong>: Child processes continue writing to stdout/stderr, mixing with your shell prompt</li>
<li><strong>Hanging Background Processes</strong>: Child processes don&#39;t receive proper termination signals and continue running</li>
<li><strong>Race Conditions</strong>: Cleanup code races with child process output, leading to unpredictable terminal state</li>
</ol>
<h2>How We Solved It</h2>
<h3>1. Process Output Proxying</h3>
<p>Child process output must be completely isolated from the terminal. Direct child process output to the terminal creates race conditions and corruption.</p>
<!--$--><!--/$-->
<p><strong>Key principles:</strong></p>
<ul>
<li><strong>Pipe all child process stdio</strong>: Use <code>Stdio::piped()</code> for stdout/stderr and <code>Stdio::null()</code> for stdin. <code>Stdio::piped()</code> will create a new pipe that is going to be readable by the parent process but will only be written to the stdout of the parent if explicitly done. And <code>Stdio::null()</code> will enable to ignore the inputs.</li>
<li><strong>Proxy to logging system</strong>: Forward child process output to your logging system instead of directly to terminal</li>
<li><strong>Handle I/O errors gracefully</strong>: child process streams can fail; don&#39;t let that crash your proxy</li>
<li><strong>Wait for completion</strong>: Ensure all output is read before proceeding with cleanup</li>
</ul>
<h3>2. Terminal State Management</h3>
<p>Terminal applications need explicit cleanup to restore the terminal to its original state:</p>
<!--$--><!--/$-->
<p><strong>Key principles:</strong></p>
<ul>
<li><strong>Always cleanup on exit</strong>: Call cleanup in both success and error paths</li>
<li><strong>Use</strong> <code>crossterm</code> <strong>for consistency</strong>: Crossterm provides cross-platform terminal manipulation</li>
<li><strong>Ignore cleanup errors</strong>: Terminal might already be in the desired state</li>
<li><strong>Follow the standard cleanup sequence</strong>: Raw mode, alternate screen, cursor visibility</li>
</ul>
<h3>3. Graceful Process Termination</h3>
<p>Proper child process lifecycle management prevents hanging processes:</p>
<!--$--><!--/$-->
<p><strong>Key principles:</strong></p>
<ul>
<li><strong>Graceful before forceful</strong>: Attempt graceful shutdown with <code>SIGTERM</code> before forcing termination with <code>SIGKILL</code>.</li>
<li><strong>Use timeouts</strong>: Don&#39;t wait forever for processes to stop</li>
<li><strong>Track all processes</strong>: Maintain a registry of spawned processes</li>
<li><strong>Handle partial failures</strong>: Some processes might fail to stop cleanly</li>
</ul>
<h3>4. Thread-Safe Spinner Management</h3>
<p>Interactive elements like spinners need careful coordination with child process output to prevent both from writing to the terminal simultaneously, which misformats characters in the terminal display.</p>
<!--$--><!--/$-->
<!--$--><!--/$-->
<p><strong>Key principles:</strong></p>
<ul>
<li><strong>Reserve terminal lines</strong>: Capture cursor position to reserve lines for updates</li>
<li><strong>Synchronize thread termination</strong>: Wait for animation threads to fully stop before cleanup</li>
<li><strong>Use atomic signals</strong>: Coordinate between threads with atomic operations</li>
<li><strong>Clean up reserved space</strong>: Clear spinner lines completely when stopping</li>
</ul>
<h2>Testing Strategies</h2>
<ol>
<li><strong>Signal Handling Tests</strong>: Verify proper cleanup when receiving SIGINT/SIGTERM</li>
<li><strong>Race Condition Tests</strong>: Use tools like <code>tokio-test</code> to simulate timing issues</li>
<li><strong>Terminal State Tests</strong>: Verify terminal state before and after operations</li>
</ol>
<h2>Common Pitfalls to Avoid</h2>
<ol>
<li><strong>Direct child process output to terminal</strong>: Always proxy through your logging system</li>
<li><strong>Forgetting stdin</strong>: Set <code>stdin(Stdio::null())</code> to prevent child processes from reading terminal input</li>
<li><strong>Not waiting for threads</strong>: Always join/await background threads before cleanup</li>
<li><strong>Ignoring partial failures</strong>: Handle cases where some processes fail to stop</li>
<li><strong>Platform-specific assumptions</strong>: Use cross-platform libraries like crossterm</li>
<li><strong>Blocking cleanup</strong>: Keep cleanup operations non-blocking where possible</li>
</ol>
<h2>Conclusion</h2>
<p>Building robust terminal applications requires careful child process management. To provide a clean user experience, especially when handling Ctrl+C:</p>
<ul>
<li>Isolate child process output.</li>
<li>Implement comprehensive terminal cleanup on exit.</li>
<li>Use graceful shutdown patterns with timeouts.</li>
<li>Coordinate interactive elements with the process lifecycle.</li>
</ul>
<p>Implementing these patterns from the start will save you from dealing with frustrated users and terminal issues down the line.</p>
<h2>Appendix: Implementation Patterns</h2>
<h3>Pattern 1: Output Isolation</h3>
<!--$--><!--/$-->
<h3>Pattern 2: Graceful Shutdown with Timeout</h3>
<!--$--><!--/$-->
<h3>Pattern 3: Component-Based Terminal Management</h3>
<!--$--><!--/$--></div></section><!--$--><!--/$--><!--$--><!--/$--></div></div>
  </body>
</html>
