<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blogs.gentoo.org/mgorny/2021/11/07/the-future-of-python-build-systems-and-gentoo/">Original</a>
    <h1>The future of Python build systems and Gentoo</h1>
    
    <div id="readability-page-1" class="page"><article id="post-1645">
		<!-- .entry-header -->

	
	<div>
		<p>Anyone following <a rel="external" href="https://twitter.com/mgorny_gentoo">my Twitter</a> could have seen me complaining about things happening around Python build systems frequently.  The late changes feel like people around the Python packaging ecosystem have been strongly focused on building a new infrastructure focused on Python-specific package manages such as pip and flit.  Unfortunately, there seems to be very little concern on distribution packagers or backwards compatibility in this process.</p>
<p>In this post, I’d like to discuss how the Python packaging changes are going to affect Gentoo, and what is my suggested plan on dealing with them.  In particular, I’d like to focus on three important changes:</p>
<ol>
<li>Python upstream deprecating the <kbd>distutils</kbd> module (and build system), and planning to remove it in Python 3.12.</li>
<li>The overall rise of <a rel="external" href="https://www.python.org/dev/peps/pep-0517/">PEP 517</a>-based build systems and the potential for setuptools dropping UI entirely.</li>
<li>Setuptools upstream deprecating the <kbd>setup.py install</kbd> command, and potentially removing it in the future.</li>
</ol>

<h2>distutils deprecation</h2>
<p>Over the years, the <a rel="external" href="https://docs.python.org/3.10/library/distutils.html">distutils</a> stdlib module has been used to build <kbd>setup.py</kbd> scripts for Python packages.  In addition to the baseline functions providing a build system CLI for the package, it provided the ability to easily extend the build system.  This led both to growth of heavily customized <kbd>setup.py</kbd> scripts as part of some packages, as well as third-party build systems based on distutils, most notably <a rel="external" href="https://github.com/pypa/setuptools/">setuptools</a>.</p>
<p>This eventually led to deprecation of distutils themselves (see: <a rel="external" href="https://www.python.org/dev/peps/pep-0632/">PEP 632</a>).  Python 3.10 is already warning of distutils deprecation, and the current plan is to remove it in Python 3.12.  Ahead of that, the development has moved to a dedicated <a rel="external" href="https://github.com/pypa/distutils/">pypa/distutils</a> repository, and the copy of that is bundled within setuptools.</p>
<p>setuptools still uses the stdlib distutils by default.  However, some packages already switch to the bundled copy, and upstream plans on using it by default in the future (see: <a rel="external" href="https://github.com/pypa/setuptools/blob/eca0111c29721056e8af7ac0d08d5f678fe7473e/docs/deprecated/distutils-legacy.rst">Porting from Distutils</a>).</p>
<p>At this point, I don’t think there is an explicit need for Gentoo to act here.  However, it seems reasonable to avoid using distutils as the build system for Gentoo projects.  Since the setuptools copy of distutils is different from the one included in CPython (and PyPy) and at the moment it does not carry the full set of historical Gentoo patches, it probably makes sense to test package compatibility with it nevertheless.</p>
<p>The use of bundled distutils copy can be forced using the following environment variable:</p>
<pre><code>SETUPTOOLS_USE_DISTUTILS=local</code></pre>
<p>This can be set both in the specific ebuild or in <kbd>make.conf</kbd> to force globally.  However, please note that you can’t change the variable in place without a <em>version bump</em> (revision bump is insufficient).  This is because switching to the <em>local</em> variant involves replacing the .egg-info file with a directory that is not supported by the PMS and not handled well by Portage.</p>
<p>Presuming that upstream is going to change the default sooner than later (and therefore unleash the breakage upon us), I think the cleanest way forward is to:</p>
<ol>
<li>Perform some initial testing (via tinderboxes).</li>
<li>Enable <kbd>SETUPTOOLS_USE_DISTUTILS=local</kbd> when <kbd>DISTUTILS_USE_SETUPTOOLS!=no</kbd> (variable name similarity is coincidental) via eclass.</li>
<li>Deprecate <kbd>DISTUTILS_USE_SETUPTOOLS=no</kbd>, requesting maintainers to switch when bumping packages to new versions.</li>
</ol>
<p>The purpose of this plan is to have a good chance of testing the new default and migrating as many packages as possible before upstream forces it in place.  The change of distutils provider on packages already using setuptools should be relatively safe.  On the other hand, for packages using pure distutils it should happen through version bumps, in order to avoid file-directory collisions mentioned before.  At the same time, the change of <kbd>DISTUTILS_USE_SETUPTOOLS</kbd> value will be necessary since setuptools dependency will now be necessary to provide the distutils override.</p>
<p>I have requested the initial tinderbox testing already.  If everything goes good and we decide to follow with the plan, I will provide detailed instructions later.  <em>Please do not update the ebuilds yet.</em></p>
<h2>The rise of PEP 517</h2>
<p><a rel="external" href="https://www.python.org/dev/peps/pep-0517/">PEP 517</a> (and a few more related PEPs) define a new infrastructure for installing Python packages.  Long story short, they define a consistent API that can be exposed by an arbitrary build system to support using it from any package manager.  Sounds great, right?  Well, I’m not that enthusiastic.</p>
<p>Before I get to my reasons, let’s shortly summarize how building packages is supposed to work in PEP 517 world.  Every project supplies at least a minimal <kbd>pyproject.toml</kbd> file that specifies the package providing the build system and the path to a module providing its entry points.  You read that file, install the necessary packages, then call the appropriate entry point to get a wheel.  Then you install the wheel.  Roughly.</p>
<p>Firstly, TOML.  This is something I’ve been repeating for quite some time already, so I’ll just quickly go over it.  I like TOML, I think it’s a reasonable choice for markup.  However, without a TOML parser in stdlib (and there’s no progress in providing one), this means that every single build system now depends on <kbd>tomli</kbd>, and involves a circular dependency.  A few months back, every single build system depended on <kbd>toml</kbd> instead but that package became unmaintained.  Does that make you feel confident?</p>
<p>Secondly, customization.  We do pretty heavy customization of distutils/setuptools behavior at this point — build paths, install paths, the toolchain.  It is understandable that PEP 517 utilizes the black box approach and doesn’t attempt to do it all.  Unfortunately, the build systems built on top of PEP 517 so far seem to focus on providing an all-in-one package manager rather than a good build tool with customization support.</p>
<p>Thirdly, wheels.  PEP 517 pretty much forces everyone into using the wheel package format, completely ignoring the fact that it’s neither the simplest solution, nor a good fit for distributions.  What we lack is a trivial “put all files into a directory” entry point.  What we get instead if “pack everything into a zip, and then use the next tool to unzip them”.  Sure, that’s not a big deal for most packages but I just hate the idea of wasting electricity and user’s time to compress something just so it gets uncompressed back afterwards.</p>
<p><a rel="external" href="https://www.python.org/dev/peps/pep-0660/">PEP 660</a> gives some hope of avoiding that by providing “editable install” support.  Unfortunately, it’s so bleak it practically doesn’t specify anything.  In practice, a PEP 660 editable install is usually a .dist-info + .pth file that adds source directory to <kbd>sys.path</kbd> — which means no files are actually installed, and it does not make it any easier for us to find the right files to install.  In other words, it’s completely useless.</p>
<p>I have spent significant time looking for a good solution and found none so far.  Back in the day, I wrote <a rel="external" href="https://github.com/mgorny/pyproject2setuppy">pyproject2setuppy</a> as a stop-gap solution to install PEP 517-based packages via setuptools without having to package the new build systems (including their <abbr title="Not Invented Here">NIH</abbr> dependencies) and figure out how to make them work sanely within our package framework.  As of today, I still don’t see a better solution.</p>
<p>Given that setuptools seems to be aiming towards removing the CLI entirely and distutils is no longer maintained, I suspect that it is inevitable that at some point we’re going to have to bite the bullet one way or another.  However, I don’t plan on making any changes for the time being — as long as <kbd>setup.py install</kbd> continues working, that is.  When this is no longer feasible, we can research our options again.</p>
<h2>setup.py install deprecation</h2>
<p>At last, the final event that puts everything else into perspective: the setuptools upstream has <a rel="external" href="https://github.com/pypa/setuptools/commit/fc5c3083908170e1cbfd1dec91f87a3e2707e3fa">deprecated the <kbd>install</kbd> command</a>.  While normally I would say “it’s not going to be removed anytime soon”, the indiscriminate <a rel="external" href="https://github.com/pypa/setuptools/commit/1ba66c1d79bf2e89d1d7be426bde60298c9439cd">use_2to3 removal</a> suggests otherwise.</p>
<p>Just a quick recap: setuptools removed the <kbd>use_2to3</kbd> support after it being deprecated for some time, summarizing it with “projects should port to a unified codebase or pin to an older version of Setuptools”.  Surely, <a rel="external" href="https://github.com/nose-devs/nose">nose</a>, a project that hasn’t seen a single commit (or accepted user patches) since 2016 is going to suddenly make a release to fix this.  In the end, all the breakage is dumped on distribution packagers.</p>
<p>The <kbd>install</kbd> command removal is a bigger deal than that.  It’s not just few old packages being broken, it’s whole workflows.  I’ve been considering switching Gentoo to a different workflow for some time, without much effect.  Even if we bite the bullet and go full PEP 517, there’s another major problem: there are projects that override the <kbd>install</kbd> command.</p>
<p>I mean, if we indiscriminately switched to installing without the <kbd>install</kbd> command, some packages would effectively be broken silently — they would e.g. stop installing some files.  The biggest issue is that it’s non-trivial to find such packages.  One I know about is called Portage.</p>
<p>At this point, I don’t think it’s worthwhile to put our effort into finding a replacement for <kbd>setup.py install</kbd>.  We can cross that bridge when we get to it.  Until then, it seems an unnecessary work with a fair breakage potential.</p>
<p>In the end, it’s still unclear what would be the best solution.  It is possible we’re going to continue converting flit and poetry into setuptools to avoid having to maintain support for multiple build processes.  It is possible we’re going to hack on top of existing PEP 517 tooling, or build something or own.  It’s quite probable that if I find no other solution, I’m going to try monkey-patching the build system to copy files instead of zipping them, or at least disable compression.</p>
<h2>Summary</h2>
<p>The Python ecosystem is changing constantly, and the packaging aspect of it is no different.  The original distutils build system has eventually evolved into setuptools, and is now being subsumed by it.  Setuptools seems to be moving in the direction of becoming yet another PEP 517 build backend and indiscriminately removing features.</p>
<p>Unfortunately, this is all happening without much of a concern for backwards compatibility or feature parity.  The Python developers are focused on building their own packaging infrastructure and have no interest in providing a single good workflow for distribution packagers.  It is really unfortunate given that many of them rely on our work to build the environments they use to work.</p>
<p>At this point, our immediate goal is to get ready for distutils removal and the setuptools switch to the bundled distutils copy.  This switch has real breakage potential for Gentoo users (because of the egg-info file/directory collision), and we need to handle the migration gracefully ahead of time.  The other issues. notably <kbd>setup.py install</kbd> removal will also need to be handled in the future but right now the gain does not justify the effort.</p>
<h2>Update (2021-11-10): data file support</h2>
<p>While writing this post, I have missed an important limitation of PEP 517 builds.  Distutils and setuptools both have a <kbd>data_files</kbd> feature that can be used to install arbitrary files into the system — either into subdirectories of <kbd>sys.prefix</kbd> (i.e. <kbd>/usr</kbd>) or via absolute paths.  This was often used to install data files for the package but also to install manpages, .desktop files and so on.</p>
<p><a rel="external" href="https://packaging.python.org/specifications/binary-distribution-format/">The wheel specification</a> as of today simply doesn’t support installing files outside the few Python-specific directories.  Setuptools/wheel/pip seem to include them in wheels but it’s outside the specification and therefore likely to suffer from portability problems.</p>
<p>Unfortunately, there doesn’t seem to be an interest to actually resolve this.  Unless I’m mistaken, both flit and poetry do not support installing files outside standard Python directories.</p>
	</div><!-- .entry-content -->

	 <!-- .entry-footer -->
</article></div>
  </body>
</html>
