<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sector7.computest.nl/post/2022-08-process-injection-breaking-all-macos-security-layers-with-a-single-vulnerability/">Original</a>
    <h1>Breaking all macOS security layers with a single vulnerability</h1>
    
    <div id="readability-page-1" class="page"><div id="main">

						
                        <section>
                            <header>
                                
                                <span>August 12, 2022</span>
                                
                                
                                
                            </header>
                            
                            <p>If you have created a new macOS app with Xcode 13.2, you may noticed this new method in the template:</p>
<div><pre tabindex="0"><code data-lang="objective-c"><span><span><span>-</span> <span>(</span><span>BOOL</span><span>)</span><span>applicationSupportsSecureRestorableState:</span><span>(</span><span>NSApplication</span> <span>*</span><span>)</span><span>app</span> <span>{</span>
</span></span><span><span>	<span>return</span> <span>YES</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>This was added to the Xcode template to address a process injection vulnerability we reported!</p>
<p>In macOS 12.0.1 Monterey, Apple fixed CVE-2021-30873. This was a process injection vulnerability affecting (essentially) all macOS AppKit-based applications. We reported this vulnerability to Apple, along with methods to use this vulnerability to escape the sandbox, elevate privileges to root and bypass the filesystem restrictions of SIP. In this post, we will first describe what process injection is, then the details of this vulnerability and finally how we abused it.</p>

<p>Process injection is the ability for one process to execute code in a different process. In Windows, one reason this is used is to evade detection by antivirus scanners, for example by a technique known as DLL hijacking. This allows malicious code to pretend to be part of a different executable. In macOS, this technique can have significantly more impact than that due to the difference in permissions two applications can have.</p>
<p>In the classic Unix security model, each process runs as a specific user. Each file has an owner, group and flags that determine which users are allowed to read, write or execute that file. Two processes running as the same user have the same permissions: it is assumed there is no security boundary between them. Users are security boundaries, processes are not. If two processes are running as the same user, then one process could attach to the other as a debugger, allowing it to read or write the memory and registers of that other process. The root user is an exception, as it has access to all files and processes. Thus, root can always access all data on the computer, whether on disk or in RAM.</p>
<p>This was, in essence, the same security model as macOS until the introduction of SIP, also known as “rootless”. This name doesn’t mean that there is no root user anymore, but it is now less powerful on its own. For example, certain files can no longer be read by the root user unless the process also has specific entitlements. Entitlements are metadata that is included when generating the code signature for an executable. Checking if a process has a certain entitlement is an essential part of many security measures in macOS. The Unix ownership rules are still present, this is an additional layer of permission checks on top of them. Certain sensitive files (e.g. the Mail.app database) and features (e.g. the webcam) are no longer possible with only root privileges but require an additional entitlement. In other words, privilege escalation is not enough to fully compromise the sensitive data on a Mac.</p>
<p>For example, using the following command we can see the entitlements of Mail.app:</p>
<pre tabindex="0"><code>$ codesign -dvvv --entitlements - /System/Applications/Mail.app
</code></pre><p>In the output, we see the following entitlement:</p>
<pre tabindex="0"><code>...
	[Key] com.apple.rootless.storage.Mail
	[Value]
		[Bool] true
...
</code></pre><p>This is what grants Mail.app the permission to read the SIP protected mail database, while other malware will not be able to read it.</p>
<p>Aside from entitlements, there are also the permissions handled by Trust, Transparency and Control (TCC). This is the mechanism by which applications can request access to, for example, the webcam, microphone and (in recent macOS versions) also files such as those in the Documents and Download folders. This means that even applications that do not use the Mac Application sandbox might not have access to certain features or files.</p>
<p>Of course entitlements and TCC permissions would be useless if any process can just attach as a debugger to another process of the same user. If one application has access to the webcam, but the other doesn’t, then one process could attach as a debugger to the other process and inject some code to steal the webcam video. To fix this, the ability to debug other applications has been heavily restricted.</p>
<p>Changing a security model that has been used for decades to a more restrictive model is difficult, especially in something as complicated as macOS. Attaching debuggers is just one example, there are many similar techniques that could be used to inject code into a different process. Apple has squashed many of these techniques, but many other ones are likely still undiscovered.</p>
<p>Aside from Apple’s own code, these vulnerabilities could also occur in third-party software. It’s quite common to find a process injection vulnerability in a specific application, which means that the permissions (TCC permissions and entitlements) of that application are up for grabs for all other processes. Getting those fixed is a difficult process, because many third-party developers are not familiar with this new security model. Reporting these vulnerabilities often requires fully explaining this new model! Especially Electron applications are <a href="https://wojciechregula.blog/post/abusing-electron-apps-to-bypass-macos-security-controls/">infamous</a> for being easy to inject into, as it is possible to replace their JavaScript files without invalidating the code signature.</p>
<p>More dangerous than a process injection vulnerability in one application is a process injection technique that affects multiple, or even <em>all</em>, applications. This would give access to a large number of different entitlements and TCC permissions. A generic process injection vulnerability affecting all applications is a very powerful tool, as we’ll demonstrate in this post.</p>

<p>When shutting down a Mac, it will prompt you to ask if the currently open windows should be reopened the next time you log in. This is a part of functionally called “saved state” or “persistent UI”.</p>
<p><img src="https://sector7.computest.nl/post/2022-08-process-injection-breaking-all-macos-security-layers-with-a-single-vulnerability/shutdown.png#center" alt=""/></p>
<p>When reopening the windows, it can even restore new documents that were not yet saved in some applications.</p>
<p>It is used in more places than just at shutdown. For example, it is also used for a feature called App Nap. When application has been inactive for a while (has not been the focused application, not playing audio, etc.), then the system can tell it to save its state and terminates the process. macOS keeps showing a static image of the application’s windows and in the Dock it still appears to be running, while it is not. When the user switches back to the application, it is quickly launched and resumes its state. Internally, this also uses the same saved state functionality.</p>
<p>When building an application using AppKit, support for saving the state is for a large part automatic. In some cases the application needs to include its own objects in the saved state to ensure the full state can be recovered, for example in a document-based application.</p>
<p>Each time an application loses focus, it writes to the files:</p>
<pre tabindex="0"><code>~/Library/Saved Application State/&lt;Bundle ID&gt;.savedState/windows.plist
~/Library/Saved Application State/&lt;Bundle ID&gt;.savedState/data.data
</code></pre><p>The <code>windows.plist</code> file contains a list of all of the application’s open windows. (And some other things that don’t look like windows, such as the menu bar and the Dock menu.)</p>
<p>For example, a <code>windows.plist</code> for TextEdit.app could look like this:</p>
<div><pre tabindex="0"><code data-lang="xml"><span><span><span>&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
</span></span><span><span><span>&lt;!DOCTYPE plist PUBLIC &#34;-//Apple//DTD PLIST 1.0//EN&#34; &#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd&#34;&gt;</span>
</span></span><span><span><span>&lt;plist</span> <span>version=</span><span>&#34;1.0&#34;</span><span>&gt;</span>
</span></span><span><span><span>&lt;array&gt;</span>
</span></span><span><span>	<span>&lt;dict&gt;</span>
</span></span><span><span>		<span>&lt;key&gt;</span>MenuBar AvailableSpace<span>&lt;/key&gt;</span>
</span></span><span><span>		<span>&lt;real&gt;</span>1248<span>&lt;/real&gt;</span>
</span></span><span><span>		<span>&lt;key&gt;</span>NSDataKey<span>&lt;/key&gt;</span>
</span></span><span><span>		<span>&lt;data&gt;</span>
</span></span><span><span>		Ay1IqBriwup4bKAanpWcEw==
</span></span><span><span>		<span>&lt;/data&gt;</span>
</span></span><span><span>		<span>&lt;key&gt;</span>NSIsMainMenuBar<span>&lt;/key&gt;</span>
</span></span><span><span>		<span>&lt;true/&gt;</span>
</span></span><span><span>		<span>&lt;key&gt;</span>NSWindowID<span>&lt;/key&gt;</span>
</span></span><span><span>		<span>&lt;integer&gt;</span>1<span>&lt;/integer&gt;</span>
</span></span><span><span>		<span>&lt;key&gt;</span>NSWindowNumber<span>&lt;/key&gt;</span>
</span></span><span><span>		<span>&lt;integer&gt;</span>5978<span>&lt;/integer&gt;</span>
</span></span><span><span>	<span>&lt;/dict&gt;</span>
</span></span><span><span>	<span>&lt;dict&gt;</span>
</span></span><span><span>		<span>&lt;key&gt;</span>NSDataKey<span>&lt;/key&gt;</span>
</span></span><span><span>		<span>&lt;data&gt;</span>
</span></span><span><span>		5lyzOSsKF24yEcwAKTBSVw==
</span></span><span><span>		<span>&lt;/data&gt;</span>
</span></span><span><span>		<span>&lt;key&gt;</span>NSDragRegion<span>&lt;/key&gt;</span>
</span></span><span><span>		<span>&lt;data&gt;</span>
</span></span><span><span>		AAAAgAIAAADAAQAABAAAAAMAAABHAgAAxgEAAAoAAAADAAAABwAAABUAAAAb
</span></span><span><span>		AAAAKQAAAC8AAAA9AAAARwIAAMcBAAAMAAAAAwAAAAcAAAAVAAAAGwAAACkA
</span></span><span><span>		AAAvAAAAPQAAAAkBAABLAQAARwIAANABAAAKAAAAFQAAABsAAAApAAAALwAA
</span></span><span><span>		AD0AAAAJAQAASwEAAD4CAADWAQAABgAAAAwAAAAJAQAASwEAAD4CAADXAQAA
</span></span><span><span>		BAAAAAwAAAA+AgAA2QEAAAIAAAD///9/
</span></span><span><span>		<span>&lt;/data&gt;</span>
</span></span><span><span>		<span>&lt;key&gt;</span>NSTitle<span>&lt;/key&gt;</span>
</span></span><span><span>		<span>&lt;string&gt;</span>Untitled<span>&lt;/string&gt;</span>
</span></span><span><span>		<span>&lt;key&gt;</span>NSUIID<span>&lt;/key&gt;</span>
</span></span><span><span>		<span>&lt;string&gt;</span>_NS:34<span>&lt;/string&gt;</span>
</span></span><span><span>		<span>&lt;key&gt;</span>NSWindowCloseButtonFrame<span>&lt;/key&gt;</span>
</span></span><span><span>		<span>&lt;string&gt;</span>{{7, 454}, {14, 16}}<span>&lt;/string&gt;</span>
</span></span><span><span>		<span>&lt;key&gt;</span>NSWindowFrame<span>&lt;/key&gt;</span>
</span></span><span><span>		<span>&lt;string&gt;</span>177 501 586 476 0 0 1680 1025 <span>&lt;/string&gt;</span>
</span></span><span><span>		<span>&lt;key&gt;</span>NSWindowID<span>&lt;/key&gt;</span>
</span></span><span><span>		<span>&lt;integer&gt;</span>2<span>&lt;/integer&gt;</span>
</span></span><span><span>		<span>&lt;key&gt;</span>NSWindowLevel<span>&lt;/key&gt;</span>
</span></span><span><span>		<span>&lt;integer&gt;</span>0<span>&lt;/integer&gt;</span>
</span></span><span><span>		<span>&lt;key&gt;</span>NSWindowMiniaturizeButtonFrame<span>&lt;/key&gt;</span>
</span></span><span><span>		<span>&lt;string&gt;</span>{{27, 454}, {14, 16}}<span>&lt;/string&gt;</span>
</span></span><span><span>		<span>&lt;key&gt;</span>NSWindowNumber<span>&lt;/key&gt;</span>
</span></span><span><span>		<span>&lt;integer&gt;</span>5982<span>&lt;/integer&gt;</span>
</span></span><span><span>		<span>&lt;key&gt;</span>NSWindowWorkspaceID<span>&lt;/key&gt;</span>
</span></span><span><span>		<span>&lt;string&gt;&lt;/string&gt;</span>
</span></span><span><span>		<span>&lt;key&gt;</span>NSWindowZoomButtonFrame<span>&lt;/key&gt;</span>
</span></span><span><span>		<span>&lt;string&gt;</span>{{47, 454}, {14, 16}}<span>&lt;/string&gt;</span>
</span></span><span><span>	<span>&lt;/dict&gt;</span>
</span></span><span><span>	<span>&lt;dict&gt;</span>
</span></span><span><span>		<span>&lt;key&gt;</span>CFBundleVersion<span>&lt;/key&gt;</span>
</span></span><span><span>		<span>&lt;string&gt;</span>378<span>&lt;/string&gt;</span>
</span></span><span><span>		<span>&lt;key&gt;</span>NSDataKey<span>&lt;/key&gt;</span>
</span></span><span><span>		<span>&lt;data&gt;</span>
</span></span><span><span>		P7BYxMryj6Gae9Q76wpqVw==
</span></span><span><span>		<span>&lt;/data&gt;</span>
</span></span><span><span>		<span>&lt;key&gt;</span>NSDockMenu<span>&lt;/key&gt;</span>
</span></span><span><span>		<span>&lt;array&gt;</span>
</span></span><span><span>			<span>&lt;dict&gt;</span>
</span></span><span><span>				<span>&lt;key&gt;</span>command<span>&lt;/key&gt;</span>
</span></span><span><span>				<span>&lt;integer&gt;</span>1<span>&lt;/integer&gt;</span>
</span></span><span><span>				<span>&lt;key&gt;</span>mark<span>&lt;/key&gt;</span>
</span></span><span><span>				<span>&lt;integer&gt;</span>2<span>&lt;/integer&gt;</span>
</span></span><span><span>				<span>&lt;key&gt;</span>name<span>&lt;/key&gt;</span>
</span></span><span><span>				<span>&lt;string&gt;</span>Untitled<span>&lt;/string&gt;</span>
</span></span><span><span>				<span>&lt;key&gt;</span>system-icon<span>&lt;/key&gt;</span>
</span></span><span><span>				<span>&lt;integer&gt;</span>1735879022<span>&lt;/integer&gt;</span>
</span></span><span><span>				<span>&lt;key&gt;</span>tag<span>&lt;/key&gt;</span>
</span></span><span><span>				<span>&lt;integer&gt;</span>2<span>&lt;/integer&gt;</span>
</span></span><span><span>			<span>&lt;/dict&gt;</span>
</span></span><span><span>			<span>&lt;dict&gt;</span>
</span></span><span><span>				<span>&lt;key&gt;</span>separator<span>&lt;/key&gt;</span>
</span></span><span><span>				<span>&lt;true/&gt;</span>
</span></span><span><span>			<span>&lt;/dict&gt;</span>
</span></span><span><span>			<span>&lt;dict&gt;</span>
</span></span><span><span>				<span>&lt;key&gt;</span>command<span>&lt;/key&gt;</span>
</span></span><span><span>				<span>&lt;integer&gt;</span>2<span>&lt;/integer&gt;</span>
</span></span><span><span>				<span>&lt;key&gt;</span>indent<span>&lt;/key&gt;</span>
</span></span><span><span>				<span>&lt;integer&gt;</span>0<span>&lt;/integer&gt;</span>
</span></span><span><span>				<span>&lt;key&gt;</span>name<span>&lt;/key&gt;</span>
</span></span><span><span>				<span>&lt;string&gt;</span>New Document<span>&lt;/string&gt;</span>
</span></span><span><span>				<span>&lt;key&gt;</span>tag<span>&lt;/key&gt;</span>
</span></span><span><span>				<span>&lt;integer&gt;</span>0<span>&lt;/integer&gt;</span>
</span></span><span><span>			<span>&lt;/dict&gt;</span>
</span></span><span><span>		<span>&lt;/array&gt;</span>
</span></span><span><span>		<span>&lt;key&gt;</span>NSExecutableInode<span>&lt;/key&gt;</span>
</span></span><span><span>		<span>&lt;integer&gt;</span>1152921500311961010<span>&lt;/integer&gt;</span>
</span></span><span><span>		<span>&lt;key&gt;</span>NSIsGlobal<span>&lt;/key&gt;</span>
</span></span><span><span>		<span>&lt;true/&gt;</span>
</span></span><span><span>		<span>&lt;key&gt;</span>NSSystemAppearance<span>&lt;/key&gt;</span>
</span></span><span><span>		<span>&lt;data&gt;</span>
</span></span><span><span>		YnBsaXN0MDDUAQIDBAUGBwpYJHZlcnNpb25ZJGFyY2hpdmVyVCR0b3BYJG9i
</span></span><span><span>		amVjdHMSAAGGoF8QD05TS2V5ZWRBcmNoaXZlctEICVRyb290gAGkCwwRElUk
</span></span><span><span>		bnVsbNINDg8QViRjbGFzc18QEE5TQXBwZWFyYW5jZU5hbWWAA4ACXxAUTlNB
</span></span><span><span>		cHBlYXJhbmNlTmFtZUFxdWHSExQVFlokY2xhc3NuYW1lWCRjbGFzc2VzXE5T
</span></span><span><span>		QXBwZWFyYW5jZaIVF1hOU09iamVjdAgRGiQpMjdJTFFTWF5jan1/gZidqLG+
</span></span><span><span>		wQAAAAAAAAEBAAAAAAAAABgAAAAAAAAAAAAAAAAAAADK
</span></span><span><span>		<span>&lt;/data&gt;</span>
</span></span><span><span>		<span>&lt;key&gt;</span>NSSystemVersion<span>&lt;/key&gt;</span>
</span></span><span><span>		<span>&lt;array&gt;</span>
</span></span><span><span>			<span>&lt;integer&gt;</span>12<span>&lt;/integer&gt;</span>
</span></span><span><span>			<span>&lt;integer&gt;</span>2<span>&lt;/integer&gt;</span>
</span></span><span><span>			<span>&lt;integer&gt;</span>1<span>&lt;/integer&gt;</span>
</span></span><span><span>		<span>&lt;/array&gt;</span>
</span></span><span><span>		<span>&lt;key&gt;</span>NSWindowID<span>&lt;/key&gt;</span>
</span></span><span><span>		<span>&lt;integer&gt;</span>4294967295<span>&lt;/integer&gt;</span>
</span></span><span><span>		<span>&lt;key&gt;</span>NSWindowZOrder<span>&lt;/key&gt;</span>
</span></span><span><span>		<span>&lt;array&gt;</span>
</span></span><span><span>			<span>&lt;integer&gt;</span>5982<span>&lt;/integer&gt;</span>
</span></span><span><span>		<span>&lt;/array&gt;</span>
</span></span><span><span>	<span>&lt;/dict&gt;</span>
</span></span><span><span><span>&lt;/array&gt;</span>
</span></span><span><span><span>&lt;/plist&gt;</span>
</span></span></code></pre></div><p>The <code>data.data</code> file contains a custom binary format. It consists of a list of records, each record contains an AES-CBC encrypted serialized object. The <code>windows.plist</code> file contains the key (<code>NSDataKey</code>) and a ID (<code>NSWindowID</code>) for the record from <code>data.data</code> it corresponds to.<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup></p>
<p>For example:</p>
<pre tabindex="0"><code>00000000  4e 53 43 52 31 30 30 30  00 00 00 01 00 00 01 b0  |NSCR1000........|
00000010  ec f2 26 b9 8b 06 c8 d0  41 5d 73 7a 0e cc 59 74  |..&amp;.....A]sz..Yt|
00000020  89 ac 3d b3 b6 7a ab 1b  bb f7 84 0c 05 57 4d 70  |..=..z.......WMp|
00000030  cb 55 7f ee 71 f8 8b bb  d4 fd b0 c6 28 14 78 23  |.U..q.......(.x#|
00000040  ed 89 30 29 92 8c 80 bf  47 75 28 50 d7 1c 9a 8a  |..0)....Gu(P....|
00000050  94 b4 d1 c1 5d 9e 1a e0  46 62 f5 16 76 f5 6f df  |....]...Fb..v.o.|
00000060  43 a5 fa 7a dd d3 2f 25  43 04 ba e2 7c 59 f9 e8  |C..z../%C...|Y..|
00000070  a4 0e 11 5d 8e 86 16 f0  c5 1d ac fb 5c 71 fd 9d  |...]........\q..|
00000080  81 90 c8 e7 2d 53 75 43  6d eb b6 aa c7 15 8b 1a  |....-SuCm.......|
00000090  9c 58 8f 19 02 1a 73 99  ed 66 d1 91 8a 84 32 7f  |.X....s..f....2.|
000000a0  1f 5a 1e e8 ae b3 39 a8  cf 6b 96 ef d8 7b d1 46  |.Z....9..k...{.F|
000000b0  0c e2 97 d5 db d4 9d eb  d6 13 05 7d e0 4a 89 a4  |...........}.J..|
000000c0  d0 aa 40 16 81 fc b9 a5  f5 88 2b 70 cd 1a 48 94  |..@.......+p..H.|
000000d0  47 3d 4f 92 76 3a ee 34  79 05 3f 5d 68 57 7d b0  |G=O.v:.4y.?]hW}.|
000000e0  54 6f 80 4e 5b 3d 53 2a  6d 35 a3 c9 6c 96 5f a5  |To.N[=S*m5..l._.|
000000f0  06 ec 4c d3 51 b9 15 b8  29 f0 25 48 2b 6a 74 9f  |..L.Q...).%H+jt.|
00000100  1a 5b 5e f1 14 db aa 8d  13 9c ef d6 f5 53 f1 49  |.[^..........S.I|
00000110  4d 78 5a 89 79 f8 bd 68  3f 51 a2 a4 04 ee d1 45  |MxZ.y..h?Q.....E|
00000120  65 ba c4 40 ad db e3 62  55 59 9a 29 46 2e 6c 07  |e..@...bUY.)F.l.|
00000130  34 68 e9 00 89 15 37 1c  ff c8 a5 d8 7c 8d b2 f0  |4h....7.....|...|
00000140  4b c3 26 f9 91 f8 c4 2d  12 4a 09 ba 26 1d 00 13  |K.&amp;....-.J..&amp;...|
00000150  65 ac e7 66 80 c0 e2 55  ec 9a 8e 09 cb 39 26 d4  |e..f...U.....9&amp;.|
00000160  c8 15 94 d8 2c 8b fa 79  5f 62 18 39 f0 a5 df 0b  |....,..y_b.9....|
00000170  3d a4 5c bc 30 d5 2b cc  08 88 c8 49 d6 ab c0 e1  |=.\.0.+....I....|
00000180  c1 e5 41 eb 3e 2b 17 80  c4 01 64 3d 79 be 82 aa  |..A.&gt;+....d=y...|
00000190  3d 56 8d bb e5 7a ea 89  0f 4c dc 16 03 e9 2a d8  |=V...z...L....*.|
000001a0  c5 3e 25 ed c2 4b 65 da  8a d9 0d d9 23 92 fd 06  |.&gt;%..Ke.....#...|
[...]
</code></pre><p>Whenever an application is launched, AppKit will read these files and restore the windows of the application. This happens automatically, without the app needing to implement anything. The code for reading these files is quite careful: if the application crashed, then maybe the state is corrupted too. If the application crashes while restoring the state, then the next time the state is discarded and it does a fresh start.</p>
<p>The vulnerability we found is that the encrypted serialized object stored in the <code>data.data</code> file was <em>not</em> using “secure coding”. To explain what that means, we’ll first explain serialization vulnerabilities, in particular on macOS.</p>
<h2 id="serialized-objects">Serialized objects</h2>
<p>Many object-oriented programming languages have added support for binary serialization, which turns an object into a bytestring and back. Contrary to XML and JSON, these are custom, language specific formats. In some programming languages, serialization support for classes is automatic, in other languages classes can opt-in.</p>
<p>In many of those languages these features have lead to vulnerabilities. The problem in many implementations is that an object is created first, and <em>then</em> its type is checked. Methods may be called on these objects when creating or destroying them. By combining objects in unusual ways, it is sometimes possible to gain remote code execution when a malicious object is deserialized. It is, therefore, not a good idea to use these serialization functions for any data that might be received over the network from an untrusted party.</p>
<p>For Python <code>pickle</code> and Ruby <code>Marshall.load</code> remote code execution is straightforward. In Java <code>ObjectInputStream.readObject</code> and C#, RCE is possible if certain commonly used libraries are used. The <a href="https://github.com/frohoff/ysoserial">ysoserial</a> and <a href="https://github.com/pwntester/ysoserial.net">ysoserial.net</a> tools can be used to generate a payload depending on the libraries in use. In PHP, exploitability for RCE is rare.</p>
<h3 id="objective-c-serialization">Objective-C serialization</h3>
<p>In Objective-C, classes can implement the <code>NSCoding</code> protocol to be serializable. Subclasses of <code>NSCoder</code>, such as <code>NSKeyedArchiver</code> and <code>NSKeyedUnarchiver</code>, can be used to serialize and deserialize these objects.</p>
<p>How this works in practice is as follows. A class that implements <code>NSCoding</code> must include a method:</p>
<div><pre tabindex="0"><code data-lang="objective-c"><span><span><span>-</span> <span>(</span><span>id</span><span>)</span><span>initWithCoder:</span><span>(</span><span>NSCoder</span> <span>*</span><span>)</span><span>coder</span><span>;</span>
</span></span></code></pre></div><p>In this method, this object can use <code>coder</code> to decode its instance variables, using methods such as <code>-decodeObjectForKey:</code>, <code>-decodeIntegerForKey:</code>, <code>-decodeDoubleForKey:</code>, etc. When it uses <code>-decodeObjectForKey:</code>, the coder will recursively call <code>-initWithCoder:</code> on that object, eventually decoding the entire graph of objects.</p>
<p>Apple has also realized the risk of deserializing untrusted input, so in 10.8, the <code>NSSecureCoding</code> protocol was added. The <a href="https://developer.apple.com/documentation/foundation/nssecurecoding?language=objc">documentation</a> for this protocol states:</p>
<blockquote>
<p>A protocol that enables encoding and decoding in a manner that is robust against object substitution attacks.</p>
</blockquote>
<p>This means that instead of creating an object first and then checking its type, a set of allowed classes needs to be included  when decoding an object.</p>
<p>So instead of the unsafe construction:</p>
<div><pre tabindex="0"><code data-lang="objective-c"><span><span><span>id</span> <span>obj</span> <span>=</span> <span>[</span><span>decoder</span> <span>decodeObjectForKey</span><span>:</span><span>@&#34;myKey&#34;</span><span>];</span>
</span></span><span><span><span>if</span> <span>(</span><span>!</span><span>[</span><span>obj</span> <span>isKindOfClass</span><span>:[</span><span>MyClass</span> <span>class</span><span>]])</span> <span>{</span> <span>/* ...fail... */</span> <span>}</span>
</span></span></code></pre></div><p>The following must be used:</p>
<div><pre tabindex="0"><code data-lang="objective-c"><span><span><span>id</span> <span>obj</span> <span>=</span> <span>[</span><span>decoder</span> <span>decodeObjectOfClass</span><span>:[</span><span>MyClass</span> <span>class</span><span>]</span> <span>forKey</span><span>:</span><span>@&#34;myKey&#34;</span><span>];</span>
</span></span></code></pre></div><p>This means that when a secure coder is created, <code>-decodeObjectForKey:</code> is no longer allowed, but <code>-decodeObjectOfClass:forKey:</code> must be used.</p>
<p>That makes exploitable vulnerabilities significantly harder, but it could still happen. One thing to note here is that subclasses of the specified class are allowed. If, for example, the <code>NSObject</code> class is specified, then all classes implementing <code>NSCoding</code> are still allowed. If only <code>NSDictionary</code> are expected and an imported framework contains a rarely used and vulnerable subclass of <code>NSDictionary</code>, then this could also create a vulnerability.</p>
<p>In all of Apple’s operating systems, these serialized objects are used all over the place, often for inter-process exchange of data. For example, <code>NSXPCConnection</code> heavily relies on secure serialization for implementing remote method calls. In iMessage, these serialized objects are even exchanged with other users over the network. In such cases it is very important that secure coding is always enabled.</p>
<h2 id="creating-a-malicious-serialized-object">Creating a malicious serialized object</h2>
<p>In the <code>data.data</code> file for saved states, objects were stored using an <code>NSKeyedArchiver</code> without secure coding enabled. This means we could include objects of any class that implements the <code>NSCoding</code> protocol. The likely reason for this is that applications can extend the saved state with their own objects, and because the saved state functionality is older than <code>NSSecureCoding</code>, Apple couldn’t just upgrade this to secure coding, as this could break third-party applications.</p>
<p>To exploit this, we wanted a method for constructing a chain of objects that could allows us to execute arbitrary code. However, no project similar to ysoserial for Objective-C appears to exist and we could not find other examples of abusing insecure deserialization in macOS. In <a href="https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-1.html">Remote iPhone Exploitation Part 1: Poking Memory via iMessage and CVE-2019-8641</a> Samuel Groß of Google Project Zero describes an attack against a <em>secure</em> coder by abusing a vulnerability in <code>NSSharedKeyDictionary</code>, an uncommon subclass of <code>NSDictionary</code>. As this vulnerability is now fixed, we couldn’t use this.</p>
<p>By decompiling a large number of <code>-initWithCoder:</code> methods in AppKit, we eventually found a combination of 2 objects that we could use to call arbitrary Objective-C methods on another deserialized object.</p>
<p>We start with <code>NSRuleEditor</code>. The <code>-initWithCoder:</code> method of this class creates a binding to an object from the same archive with a key path also obtained from the archive.</p>
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CocoaBindings/CocoaBindings.html">Bindings</a> are a reactive programming technique in Cocoa. It makes it possible to directly bind a model to a view, without the need for the boilerplate code of a controller. Whenever a value in the model changes, or the user makes a change in the view, the changes are automatically propagated.</p>
<p>A binding is created calling the <a href="https://developer.apple.com/documentation/objectivec/nsobject/1458185-bind?language=objc">method</a>:</p>
<div><pre tabindex="0"><code data-lang="objective-c"><span><span><span>-</span> <span>(</span><span>void</span><span>)</span><span>bind:</span><span>(</span><span>NSBindingName</span><span>)</span><span>binding</span> 
</span></span><span><span>    <span>toObject:</span><span>(</span><span>id</span><span>)</span><span>observable</span> 
</span></span><span><span> <span>withKeyPath:</span><span>(</span><span>NSString</span> <span>*</span><span>)</span><span>keyPath</span> 
</span></span><span><span>     <span>options:</span><span>(</span><span>NSDictionary</span><span>&lt;</span><span>NSBindingOption</span><span>,</span> <span>id</span><span>&gt;</span> <span>*</span><span>)</span><span>options</span><span>;</span>
</span></span></code></pre></div><p>This binds the property <code>binding</code> of the receiver to the <code>keyPath</code> of <code>observable</code>. A <em>keypath</em> a string that can be used, for example, to access nested properties of the object. But the more common method for creating bindings is by creating them as part of a XIB file in Xcode.</p>
<p>For example, suppose the model is a class <code>Person</code>, which has a property <code>@property (readwrite, copy) NSString *name;</code>. Then you could bind the “value” of a text field to the “name” keypath of a Person to create a field that shows (and can edit) the person’s name.</p>
<p>In the XIB editor, this would be created as follows:</p>
<p><img src="https://sector7.computest.nl/post/2022-08-process-injection-breaking-all-macos-security-layers-with-a-single-vulnerability/binding.png#center" alt=""/></p>
<p>The different options for what a keypath can mean are actually <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/SearchImplementation.html#//apple_ref/doc/uid/20000955">quite complicated</a>. For example, when binding with a keypath of “foo”, it would first check if one the methods <code>getFoo</code>, <code>foo</code>, <code>isFoo</code> and <code>_foo</code> exists. This would usually be used to access a property of the object, but this is not required. When a binding is created, the method will be called immediately when creating the binding, to provide an initial value. It does not matter if that method actually returns void. This means that by creating a binding during deserialization, we can use this to call zero-argument methods on other deserialized objects!</p>
<div><pre tabindex="0"><code data-lang="objective-c"><span><span><span>ID</span> <span>NSRuleEditor</span><span>::</span><span>initWithCoder</span><span>:(</span><span>ID</span> <span>param_1</span><span>,</span><span>SEL</span> <span>param_2</span><span>,</span><span>ID</span> <span>unarchiver</span><span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>	<span>...</span>
</span></span><span><span>
</span></span><span><span>	<span>id</span> <span>arrayOwner</span> <span>=</span> <span>[</span><span>unarchiver</span> <span>decodeObjectForKey</span><span>:</span><span>@&#34;NSRuleEditorBoundArrayOwner&#34;</span><span>];</span>
</span></span><span><span>
</span></span><span><span>	<span>...</span>
</span></span><span><span>
</span></span><span><span>	<span>if</span> <span>(</span><span>arrayOwner</span><span>)</span> <span>{</span>
</span></span><span><span>	  <span>keyPath</span> <span>=</span> <span>[</span><span>unarchiver</span> <span>decodeObjectForKey</span><span>:</span><span>@&#34;NSRuleEditorBoundArrayKeyPath&#34;</span><span>];</span>
</span></span><span><span>	  <span>[</span><span>self</span> <span>bind</span><span>:</span><span>@&#34;rows&#34;</span> <span>toObject</span><span>:</span><span>arrayOwner</span> <span>withKeyPath</span><span>:</span><span>keyPath</span> <span>options</span><span>:</span><span>nil</span><span>];</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>	<span>...</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>In this case we use it to call <code>-draw</code> on the next object.</p>
<p>The next object we use is an <code>NSCustomImageRep</code> object. This obtains a selector (a method name) as a string and an object from the archive. When the <code>-draw</code> method is called, it invokes the method from the selector on the object. It passes itself as the first argument:</p>
<div><pre tabindex="0"><code data-lang="objective-c"><span><span>
</span></span><span><span><span>ID</span> <span>NSCustomImageRep</span><span>::</span><span>initWithCoder</span><span>:(</span><span>ID</span> <span>param_1</span><span>,</span><span>SEL</span> <span>param_2</span><span>,</span><span>ID</span> <span>unarchiver</span><span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>	<span>...</span>
</span></span><span><span>	<span>id</span> <span>drawObject</span> <span>=</span> <span>[</span><span>unarchiver</span> <span>decodeObjectForKey</span><span>:</span><span>@&#34;NSDrawObject&#34;</span><span>];</span>
</span></span><span><span>	<span>self</span><span>.</span><span>drawObject</span> <span>=</span> <span>drawObject</span><span>;</span>
</span></span><span><span>	<span>id</span> <span>drawMethod</span> <span>=</span> <span>[</span><span>unarchiver</span> <span>decodeObjectForKey</span><span>:</span><span>@&#34;NSDrawMethod&#34;</span><span>];</span>
</span></span><span><span>	<span>SEL</span> <span>selector</span> <span>=</span> <span>NSSelectorFromString</span><span>(</span><span>drawMethod</span><span>);</span>
</span></span><span><span>	<span>self</span><span>.</span><span>drawMethod</span> <span>=</span> <span>selector</span><span>;</span>
</span></span><span><span>	<span>...</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>...</span>
</span></span><span><span>
</span></span><span><span><span>void</span> <span>___24</span><span>-</span><span>[</span><span>NSCustomImageRep_draw</span><span>]</span><span>_block_invoke</span><span>(</span><span>long</span> <span>param_1</span><span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>  <span>...</span>
</span></span><span><span>  <span>[</span><span>self</span><span>.</span><span>drawObject</span> <span>performSelector</span><span>:</span><span>self</span><span>.</span><span>drawMethod</span> <span>withObject</span><span>:</span><span>self</span><span>];</span>
</span></span><span><span>  <span>...</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>By deserializing these two classes we can now call zero-argument methods and multiple argument methods, although the first argument will be an <code>NSCustomImageRep</code> object and the remaining arguments will be whatever happens to still be in those registers. Nevertheless, is a very powerful primitive. We’ll cover the rest of the chain we used in a future blog post.</p>

<h2 id="sandbox-escape">Sandbox escape</h2>
<p>First of all, we escaped the Mac Application sandbox with this vulnerability. To explain that, some more background on the saved state is necessary.</p>
<p>In a sandboxed application, many files that would be stored in <code>~/Library</code> are stored in a separate container instead. So instead of saving its state in:</p>
<pre tabindex="0"><code>~/Library/Saved Application State/&lt;Bundle ID&gt;.savedState/
</code></pre><p>Sandboxed applications save their state to:</p>
<pre tabindex="0"><code>~/Library/Containers/&lt;Bundle ID&gt;/Data/Library/Saved Application State/&lt;Bundle ID&gt;.savedState/
</code></pre><p>Apparently, when the system is shut down while an application is still running (when the prompt is shown asking the user whether to reopen the windows the next time), the first location is symlinked to the second one by <code>talagent</code>. We are unsure of why, it might have something to do with upgrading an application to a new version which is sandboxed.</p>
<p>Secondly, most applications do not have access to all files. Sandboxed applications are very restricted of course, but with the addition of TCC even accessing the Downloads, Documents, etc. folders require user approval. If the application would open an open or save panel, it would be quite inconvenient if the user could only see the files that that application has access to. To solve this, a different process is launched when opening such a panel: <code>com.apple.appkit.xpc.openAndSavePanelService</code>. Even though the window itself is part of the application, its contents are drawn by openAndSavePanelService. This is an XPC service which has full access to all files. When the user selects a file in the panel, the application gains temporary access to that file. This way, users can still browse their entire disk even in applications that do not have permission to list those files.</p>
<p><img src="https://sector7.computest.nl/post/2022-08-process-injection-breaking-all-macos-security-layers-with-a-single-vulnerability/openpanel.png#center" alt=""/></p>
<p>As it is an XPC service with service type Application, it is launched separately for each app.</p>
<p>What we noticed is that this XPC Service reads its saved state, but using the bundle ID of the app that launched it! As this panel might be part of the saved state of multiple applications, it does make some sense that it would need to separate its state per application.</p>
<p>As it turns out, it reads its saved state from the location <em>outside</em> of the container, but with the application’s bundle ID:</p>
<pre tabindex="0"><code>~/Library/Saved Application State/&lt;Bundle ID&gt;.savedState/
</code></pre><p>But as we mentioned if the app was ever open when the user shut down their computer, then this will be a symlink to the container path.</p>
<p>Thus, we can escape the sandbox in the following way:</p>
<ol>
<li>Wait for the user to shut down while the app is open, if the symlink does not yet exist.</li>
<li>Write malicious <code>data.data</code> and <code>windows.plist</code> files inside the app’s own container.</li>
<li>Open an <code>NSOpenPanel</code> or <code>NSSavePanel</code>.</li>
</ol>
<p>The <code>com.apple.appkit.xpc.openAndSavePanelService</code> process will now deserialize the malicious object, giving us code execution in a non-sandboxed process.</p>
<p>This was fixed earlier than the other issues, as CVE-2021-30659 in macOS 11.3. Apple addressed this by no longer loading the state from the same location in <code>com.apple.appkit.xpc.openAndSavePanelService</code>.</p>
<h2 id="privilege-escalation">Privilege escalation</h2>
<p>By injecting our code into an application with a specific entitlement, we can elevate our privileges to root. For this, we could apply the technique explained by A2nkF in <a href="https://a2nkf.github.io/unauthd_Logic_bugs_FTW/">Unauthd - Logic bugs FTW</a>.</p>
<p>Some applications have an entitlement of <code>com.apple.private.AuthorizationServices</code> containing the value <code>system.install.apple-software</code>. This means that this application is allowed to install packages that have a signature generated by Apple without authorization from the user. For example, “Install Command Line Developer Tools.app” and “Bootcamp Assistant.app” have this entitlement. A2nkF also found a package signed by Apple that contains a vulnerability: <code>macOSPublicBetaAccessUtility.pkg</code>. When this package is installed to a specific disk, it will run (as root) a post-install script from that disk. The script assumes it is being installed to a disk containing macOS, but this is not checked. Therefore, by creating a malicious script at the same location it is possible to execute code as root by installing this package.</p>
<p>The exploitation steps are as follows:</p>
<ol>
<li>Create a RAM disk and copy a malicious script to the path that will be executed by <code>macOSPublicBetaAccessUtility.pkg</code>.</li>
<li>Inject our code into an application with the <code>com.apple.private.AuthorizationServices</code> entitlement containing <code>system.install.apple-software</code> by creating the <code>windows.plist</code> and <code>data.data</code> files for that application and then launching it.</li>
<li>Use the injected code to install the <code>macOSPublicBetaAccessUtility.pkg</code> package to the RAM disk.</li>
<li>Wait for the post-install script to run.</li>
</ol>
<p>In the writeup from A2nkF, the post-install script ran without the filesystem restrictions of SIP. It inherited this from the installation process, which needs it as package installation might need to write to SIP protected locations. This was fixed by Apple: post- and pre-install scripts are no longer SIP exempt. The package and its privilege escalation can still be used, however, as Apple still uses the same vulnerable installer package.</p>
<h2 id="sip-filesystem-bypass">SIP filesystem bypass</h2>
<p>Now that we have escaped the sandbox and elevated our privilages to root, we did want to bypass SIP as well. To do this, we looked around at all available applications to find one with a suitable entitlement. Eventually, we found something on the macOS Big Sur Beta installation disk image: “macOS Update Assistant.app” has the <code>com.apple.rootless.install.heritable</code> entitlement. This means that this process can write to all SIP protected locations (and it is heritable, which is convenient because we can just spawn a shell). Although it is supposed to be used only during the beta installation, we can just copy it to a normal macOS environment and run it there.</p>
<p>The exploitation for this is quite simple:</p>
<ol>
<li>Create malicious <code>windows.plist</code> and <code>data.data</code> files for “macOS Update Assistant.app”.</li>
<li>Launch “macOS Update Assistant.app”.</li>
</ol>
<p>When exempt from SIP’s filesystem restrictions, we can read all files from protected locations, such as the user’s Mail.app mailbox. We can also modify the TCC database, which means we can grant ourself permission to access the webcam, microphone, etc. We could also persist our malware on locations which are protected by SIP, making it very difficult to remove by anyone other than Apple. Finally, we can change the database of approved kernel extensions. This means that we could load a new kernel extension silently, without user approval. When combined with a vulnerable kernel extension (or a codesigning certificate that allows signing kernel extensions), we would have been able to gain kernel code execution, which would allow disabling all other restrictions too.</p>

<p>We recorded the following video to demonstrate the different steps. It first shows that the application “Sandbox” is sandboxed, then it escapes its sandbox and launches “Privesc”. This elevates privileges to root and launches “SIP Bypass”. Finally, this opens a reverse shell that is exempt from SIP’s filesystem restrictions, which is demonstrated by writing a file in <code>/var/db/SystemPolicyConfiguration</code> (the location where the database of approved kernel modules is stored):</p>
<video controls="" preload="auto" width="100%" playsinline="">
    <source src="/post/2022-08-process-injection-breaking-all-macos-security-layers-with-a-single-vulnerability/demo.webm" type="video/webm"/>
  <span>Your browser doesn&#39;t support embedded videos, but don&#39;t worry, you can <a href="https://sector7.computest.nl/post/2022-08-process-injection-breaking-all-macos-security-layers-with-a-single-vulnerability/demo.webm">download it</a> and watch it with your favorite video player!</span>
</video>

<p>Apple first fixed the sandbox escape in 11.3, by no longer reading the saved state of the application in <code>com.apple.appkit.xpc.openAndSavePanelService</code> (CVE-2021-30659).</p>
<p>Fixing the rest of the vulnerability was more complicated. Third-party applications may store their own objects in the saved state and these objects might not support secure coding. This brings us back to the method from the introduction: <code>-applicationSupportsSecureRestorableState:</code>. Applications can now opt-in to requiring secure coding for their saved state by returning <code>TRUE</code> from this method. Unless an app opts in, it will keep allowing non-secure coding, which means process injection might remain possible.</p>
<p>This does highlight one issue with the current design of these security measures: downgrade attacks. The code signature (and therefore entitlements) of an application will remain valid for a long time, and the TCC permissions of an application will still work if the application is downgraded. A non-sandboxed application could just silently download an older, vulnerable version of an application and exploit that. For the SIP bypass this would not work, as “macOS Update Assistant.app” does not run on macOS Monterey because certain private frameworks no longer contain the necessary symbols. But that is a coincidental fix, in many other cases older applications may still run fine. This vulnerability will therefore be present for as long as there is backwards compatibility with older macOS applications!</p>
<p>Nevertheless, if you write an Objective-C application, please make sure you add <code>-applicationSupportsSecureRestorableState:</code> to return <code>TRUE</code> and to adapt secure coding for all classes used for your saved states!</p>

<p>In the current security architecture of macOS, process injection is a powerful technique. A generic process injection vulnerability can be used to escape the sandbox, elevate privileges to root and to bypass SIP’s filesystem restrictions. We have demonstrated how we used the use of insecure deserialization in the loading of an application’s saved state to inject into any Cocoa process. This was addressed by Apple in the macOS Monterey update.</p>



                            
                            
                            
                            
                            
                            
                            
                            
                        </section>

					</div></div>
  </body>
</html>
