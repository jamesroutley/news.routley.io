<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.bugsink.com/blog/track-errors-first/">Original</a>
    <h1>Track Errors First</h1>
    
    <div id="readability-page-1" class="page"><div>
        
        

        <div>
          

          <section>
            <div>
              <div>
                <div>
                




          <div>
            <div>
              <div>
                <p><img src="https://www.bugsink.com/static/images/klaas.beec86a2df8b.webp" alt="Klaas van Schelven"/>
                </p>
                <p><span>
                    Klaas van Schelven;
                  </span>
                  <span>
                    June 4 - 5 min read
                  </span>
                </p>
              </div>
            </div>
          </div>


          <figure>
            <p><img src="https://www.bugsink.com/static/images/observability-temple-cropped-big.8777037b4b30.webp" alt="Temple of Observability, Errors to the Side"/>
            </p>
          </figure>

<p>Observability usually means collecting dashboards, traces, metrics, and logs — or at least, that’s how it’s sold.
What’s often missing from that conversation is <strong>the most valuable signal</strong> of all: <strong>errors.</strong></p>
<p>When an exception is raised, your code is telling you: <em>this was not supposed to happen</em>. Not just that something is
slow, or that usage is spiking — but that <strong>your assumptions, as a programmer, just failed</strong>.</p>
<p>That makes an exception — a real, raised error — the single most useful event you can track.
If you’re building out observability, whether for the first time or revisiting an existing setup, <strong>start with that</strong>.</p>
<h3 id="the-three-pillars-of-observability">The three pillars of observability</h3>
<p>The standard model splits observability into three pillars: <strong>logs, metrics, and traces</strong>. They’re helpful, but something
is missing — and if you only follow this model, you’ll miss it too.</p>
<ul>
<li><strong>Logs</strong> tell you what the system thought was worth noting.</li>
<li><strong>Metrics</strong> show trends over time: request duration, error rates, cache hit ratios.</li>
<li><strong>Traces</strong> give a sense of flow: what did this request call, and how long did it take?</li>
</ul>
<p>All of those are useful. But none of them tell you <strong>where the code broke</strong>. For that, you need proper error tracking.</p>
<h3 id="signal-over-noise">Signal Over Noise</h3>
<p>There’s nothing more direct than a thrown exception. You don’t have to guess whether it’s important.
It’s the system saying: <em>this should not have happened, and here’s the line where it went wrong.</em></p>
          <figure>
            <p><img src="https://www.bugsink.com/static/images/JsonSchemaDefinitionException.654fa0b5af76.webp" alt="Example of a stacktrace in Bugsink" onclick="showModal(&#39;/static/images/JsonSchemaDefinitionException.654fa0b5af76.webp&#39;)"/>
            </p>
          </figure>
          <figcaption>
             Right to the heart of the problem: a stacktrace with local variables
          </figcaption>
<p>And because exceptions are so rare – so high-signal – it’s worth going deep when they happen. You want to capture:</p>
<ul>
<li><strong>The full stacktrace</strong> — readable, with line numbers and source references</li>
<li><strong>Local variables</strong> — so you know what was actually passed in</li>
<li><strong>Request data</strong> — like URL paths, headers, or session info</li>
<li><strong>User context</strong> — who was affected, what were they doing?</li>
</ul>
<p>You can’t get this from a metric. And you usually don’t get it from a log line unless you’ve done a <a href="https://www.bugsink.com/blog/capture-stacktrace-no-exception/">lot of extra
work</a>.</p>
<p>So instead of collecting a little information about everything that works — one trace here, one log line there — you’re
better off collecting <strong>as much context as possible</strong> at the moment your system breaks.</p>
<p>As one developer put it: <strong>“One exception is worth a thousand logs.”</strong></p>
<h3 id="missing-from-the-diagram">Missing from the Diagram</h3>
<p>The canonical “three pillars” of observability are logs, metrics, and traces.
But <strong>error tracking isn’t even mentioned</strong>.</p>
<p>If you believe exceptions are your highest-signal events — and you probably should — then this model doesn’t just feel
incomplete. <strong>It’s actively misleading.</strong></p>
<p>It reflects what’s easy to generalize, easy to collect, and easy to sell — not necessarily what’s most useful when your
code breaks.</p>
          <figure>
            <p><img src="https://www.bugsink.com/static/images/observability-temple.c491687e2594.webp" alt="Temple of Observability, Errors to the Side"/>
            </p>
          </figure>
          <figcaption>
            The Temple of Observability, with Errors fallen to the side
          </figcaption>
<h3 id="technically-covered">Technically Covered</h3>
<p>In most observability platforms, errors are not missing — just abstracted.
They show up in logs, get counted in metrics, or appear as failed spans in traces. Some platforms file them under
generic “events,” alongside cache misses, deployments, and GC pauses.</p>
<p>This flattening makes implementation easier. Everything becomes a stream of telemetry — uniform, processable, and easy
to route.</p>
<p>But that abstraction comes at a cost. An exception isn’t just another event.  It’s your code <strong>telling you it failed</strong>,
in a specific place, with a specific context. If the system treats that like just another row in a data pipeline, you’ll
likely get the minimum: a message string, maybe a timestamp, maybe a partial trace.</p>
<p><strong>Error tracking requires collecting more.</strong> Stack traces, local variables, request metadata, user context — details
that rarely make it into standard logs or metric counters.</p>
<p>So yes, errors are technically covered. But they’re not treated as meaningful failures. Just another data point, in a
sea of unrelated ones.</p>
<h3 id="youre-probably-not-google">You’re (probably) not Google</h3>
<p>You’re probably not Google. And even if you are, <strong>errors should come first — APM second.</strong>
Exceptions give you the clearest, most actionable signal when something breaks. You want full context, not a red dot on a
dashboard.</p>
<p>Plenty of APM tools claim to track errors — but often that just means counting them.
You get a spike on a chart, maybe a summary, rarely the full story. If exceptions are your highest-signal events, that
shouldn’t be an afterthought.</p>
<p>And watch out even with dedicated error tracking tools. Some of them started strong, fast, focused, developer-first,
but have since drifted into full observability platforms. Dashboards got added, then tracing, then metrics pipelines.
More tabs, more noise, more clicks.</p>
<p>So take a moment to check: Are errors still first-class in your stack? Or just another checkbox on a sales sheet?</p>
<h3 id="not-your-neutral-observer">Not your Neutral Observer</h3>
<p>So who’s your friendly author? I’m Klaas,
the founder of <a href="https://www.bugsink.com/">Bugsink</a>: an error tracking tool.</p>
<p>So yes, I have a stake in this – but not by accident.</p>
<p>I built a tool around this belief, not the other way around. And I think the current ecosystem, with its emphasis on
full-stack APM suites and dashboard-driven ops, tends to push errors to the background. That’s a mistake.</p>
<p>Track errors first.</p>

    <!-- The Modal -->
    

    


                </div>
              </div>
            </div>
          </section>
        </div>
        
      </div></div>
  </body>
</html>
