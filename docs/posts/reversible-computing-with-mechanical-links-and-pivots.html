<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tennysontbardwell.com/blog/2025/04/30/mechanical-computing/index.html">Original</a>
    <h1>Reversible computing with mechanical links and pivots</h1>
    
    <div id="readability-page-1" class="page"><div id="content">




<div id="outline-container-org1dc929b">
<h2 id="org1dc929b">Intro</h2>
<div id="text-org1dc929b">
<p>
With the concern that “Moore’s Law is dead,” new interest has grown for unconventional forms of computing. This includes:
</p>

<ul>
<li><a href="https://en.wikipedia.org/wiki/Quantum_computing">quantum computing</a> (for atomic simulations and specific NP approximation algorithms)</li>
<li><a href="https://en.wikipedia.org/wiki/Analog_computer">analog computing</a> (for fast-and-efficient-but-error-prone computation, such as neural net inference)</li>
<li><a href="https://en.wikipedia.org/wiki/Reversible_computing">reversible computing</a> (for maximum energy efficiency)</li>
</ul>

<p>
It is believed that the most efficient computing devices would use little or no entropy during reversible computations, and only consume energy during non-reversible parts of computation. Specifically, the <a href="https://en.wikipedia.org/wiki/Landauer%27s_principle">Landauer’s principle</a> states that all non-physically-reversible computation operations consume at least \(2.9 \times 10^{-21}\) J of energy at room temperature (and less as the temperature drops).
</p>

<p>
Are we at the theoretical maximum efficiency yet? No. Using some back-of-the-napkin math:
</p>

<ul>
<li>AMD Ryzen Threadripper 7995WX has about 12 TFLOPS of FP32 (single-precision) compute (<a href="https://wccftech.com/amd-ryzen-threadripper-7995wx-cpu-more-fp32-tflops-than-xbox-series-x-ps5-on-par-rtx-3060-gpu/">link</a>)</li>
<li>Assuming 30 irreversible computations per FP32 operation (from Claude), we have 10<sup>14.5</sup> irreversible computations per second</li>
<li>At 350 W this is about \(10^{-12}\) J per irreversible computation, or about <i>9 orders of magnitude</i> less efficient than the theoretical maximum</li>
</ul>

<p>
Even if a CPU like the AMD Ryzen Z1 Extreme or Apple M4 can improve this efficiency by a factor of 10 (which is too generous), we’re still a long way out from hitting the theoretical wall.
</p>

<p>
Nevertheless, it is both fun and prudent to imagine how different paradigms of computing would work. These different paradigms might even be competitive in certain niches long before transistors hit a wall. My favorite reversible computing scheme comes from a paper named <a href="https://doi.org/10.48550/arXiv.1801.03534">Mechanical Computing Systems Using Only Links and Rotary Joint</a>. In it, they use <i>links</i> and <i>rotary joints</i> (hinges) to build Turing-complete computing machines.
</p>
</div>
</div>
<div id="outline-container-orged82550">
<h2 id="orged82550">The “Lock”</h2>
<div id="text-orged82550">
<p>
The most basic element is a “lock.” It’s constructed with two triangles that are allowed to slide back and forth. However, once the top triangle has been pushed forward, it prevents the bottom triangle from being pushed forward (and vice versa). It’s called a “lock” because the first triangle to get pushed forward will “lock out” the other.
</p>

<p>
The demo below is made from springs and pivot points. Drag the sliders to engage the top and bottom parts of a lock.
</p>



<p><label for="slider-a">Top Input:</label>
  
</p>
<p><label for="slider-b">Bottom Input:</label>
  
</p>

<canvas id="sim1" width="750" height="230"></canvas>



<p>
In principle, these locks could be constructed out of physical materials on very small scales. The authors of the original paper provided this example schematic of a 30 x 30 x 7 nm lock constructed out of carbon:
</p>


<p><img src="https://tennysontbardwell.com/blog/2025/04/30/mechanical-computing/atomic.png" alt="atomic.png"/>
</p>
</div>
</div>
<div id="outline-container-org85972e1">
<h2 id="org85972e1">The “Balance”</h2>
<div id="text-org85972e1">
<p>
Ultimately, our binary convention will be that either the “1” line or the “0” line of a bit will always be engaged. A balance helps make this happen. It consists of two locks and a lever before them. On the forward edge of a clock, it forces a horizontal translation through whichever lock is not already engaged.
</p>

<p>
Try engaging only one of the two locks (top or bottom) and then engaging the clock. The clock will “flow through” whichever lock has not already been engaged by the inputs:
</p>



<p><label>Top Input:</label>
  
</p>
<p><label>Bottom Input:</label>
  
</p>
<p><label>Clock Input:</label>
  
</p>

<canvas id="sim2" width="750" height="280"></canvas>


</div>
</div>
<div id="outline-container-org61cfdc6">
<h2 id="org61cfdc6">Bellcrank</h2>
<div id="text-org61cfdc6">
<p>
The last thing that we will need to construct a NAND gate is a way to route and split signals. It turns out to be relatively simple:
</p>


<p><label>Input:</label>
  
</p>

<canvas id="sim3" width="750" height="450"></canvas>


</div>
</div>
<div id="outline-container-org627b816">
<h2 id="org627b816">NAND Simulation</h2>
<div id="text-org627b816">
<p>
And now we are ready to construct a NAND gate, which is a “universal gate” (i.e., you can implement any truth table using only NAND gates). We first use two “wires” for each input. If <code>A</code> is <code>TRUE</code>, then the first wire is pushed forward. If <code>A</code> is <code>FALSE</code>, then the second wire is pushed forward. Likewise, if <code>B</code> is <code>TRUE</code> then the third wire is pushed forward, and the fourth wire is pushed forward if <code>B</code> is <code>FALSE</code>.
</p>

<p>
We expect to always have exactly two of these wires push forward for any computation. Following these input wires, we see that each individual wire engages exactly two locks, preventing the thrust of the clock from flowing through that pathway. Since there are four pathways, we must make sure that only one pathway is unlocked at any time. Then, when the clock arrives, that pathway will receive the forward thrust.
</p>


</div>


<canvas id="simulator" width="750" height="380"></canvas>



<p>
If you’re interested in learning more, one of the authors gave a 20 minute overview of this paper at the CCC Workshop on Reversible Computing: <a href="https://www.youtube.com/watch?v=yVX9Ob4SjGA">Ralph Merkle: Molecular Mechanical Computing</a>.
</p>
</div>
</div></div>
  </body>
</html>
