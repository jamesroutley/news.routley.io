<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://theor.xyz/doom-maps-laser-cut/">Original</a>
    <h1>DOOM maps to SVG to laser cutter</h1>
    
    <div id="readability-page-1" class="page"><div>
      <article>
        
        
        
        


        <!-- {JSON.stringify(Astro.props)} -->
        <!-- {pubDate && <FormattedDate date={pubDate} />}
        {
          updatedDate && (
            <div class="last-updated-on">
              Last updated on <FormattedDate date={updatedDate} />
            </div>
          )
        } -->
        <hr/>
        <p>I’ve heard a lot about classic Doom’s data format and decided to write some Rust code to extract its maps and convert that to vector graphics I could laser cut.</p>
<p>I’ll go through the process, from the data extraction to the geometry reconstruction to outputting laser-cuttable SVGs, including the geometrical dead end I enthusiastically ran to when I tried to preview the result using <a href="https://bevyengine.org/">bevy</a>.</p>
<p><img src="https://theor.xyz/_astro/banner.f008b8a1.webp" alt="3D render of a doom map, e1m1"/></p>

<p>DOOM’s data was designed with modding as a goal : the entire game is an executable and a <code>.WAD</code> data pack. The shareware/demo version shipped with DOOM1.WAD, which is still available freely.</p>
<div>
  <video onclick="this.play()" src="/_astro/wad.438735e7.m4v" autoplay="" muted="" controls="" loop=""></video>
  <p><span>Doom WAD format, illustrated with MotionCanvas</span>
</p></div>
<p>The WAD format is well documented - see the <a href="https://www.gamers.org/dhs/helpdocs/dmsp1666.html">Unofficial DOOM spec</a> or the <a href="https://zdoom.org/wiki/WAD">ZDoom wiki</a>. The gist of it is :</p>
<ul>
<li>the WAD file starts with a header follow by the actual data, ends with directory entries describing that data</li>
<li>the header contains a pointer to the first directory entry and the entry count</li>
<li>each directory entry contains a pointer to the data and its size</li>
</ul>
<p>I’ll skip some (fascinating!) details, as the <a href="https://fabiensanglard.net/gebbdoom/">DOOM game engine black book</a> of the wonderful Fabien Sanglard already covers all of that.</p>
<p>Those data items are called “lumps” in doom parlance. Some contains map geometry, others textures, sounds, text, … everything needed for a game.</p>
<p>A map is described by multiple lumps</p>
<ul>
<li><code>VERTEXES</code> is a list of world positions</li>
<li><code>LINEDEFS</code> describes lines joining two segments and references one SIDEDEF per line “side”</li>
<li><code>SIDEDEFS</code> are “walls”, textures for a line, and belong to a SECTOR</li>
<li><code>SECTORS</code> are polygons with a floor and ceiling height</li>
</ul>
<p>The map data also includes a BSP tree whose leaves are subsectors, sectors split to be convex polygons, but also texture definitions compositing multiple sprites and much more.</p>
<h2 id="implementation"><a data-link="" href="#implementation"><span></span></a>Implementation</h2>
<p>I used <a href="https://github.com/rust-bakery/nom">nom</a>, a rust parser combinators library that can parse text and binary formats. Here is a typical usage: parsing <code>THINGS</code>, the map items/power ups:</p>
<pre><code><span><span>pub</span><span> </span><span>struct</span><span> </span><span>Thing</span><span> </span><span>{</span></span>
<span><span>    </span><span>pub</span><span> </span><span>pos_x</span><span>:</span><span> </span><span>i16</span><span>,</span></span>
<span><span>    </span><span>pub</span><span> </span><span>pos_y</span><span>:</span><span> </span><span>i16</span><span>,</span></span>
<span><span>    </span><span>pub</span><span> </span><span>angle</span><span>:</span><span> </span><span>i16</span><span>,</span></span>
<span><span>    </span><span>pub</span><span> </span><span>thing_type</span><span>:</span><span> </span><span>u16</span><span>,</span></span>
<span><span>    </span><span>pub</span><span> </span><span>flags</span><span>:</span><span> </span><span>ThingFlags</span><span>,</span></span>
<span><span>}</span></span>
<span></span>
<span><span>impl</span><span> </span><span>Lump</span><span> </span><span>for</span><span> </span><span>Thing</span><span> </span><span>{</span></span>
<span><span>    // used to determine how many items in a lump</span></span>
<span><span>    </span><span>const</span><span> SIZE</span><span>:</span><span> </span><span>usize</span><span> </span><span>=</span><span> </span><span>10</span><span>;</span></span>
<span><span>}</span></span>
<span></span>
<span><span>pub</span><span> </span><span>fn</span><span> </span><span>parse_thing</span><span>(</span><span>input</span><span>:</span><span> </span><span>&amp;</span><span>[</span><span>u8</span><span>])</span><span> </span><span>-&gt;</span><span> </span><span>IResult</span><span>&lt;</span><span>&amp;</span><span>[</span><span>u8</span><span>],</span><span> </span><span>Thing</span><span>&gt;</span><span> </span><span>{</span></span>
<span><span>    </span><span>map</span><span>(</span></span>
<span><span>        // parse 5 unsigned shorts</span></span>
<span><span>        </span><span>tuple</span><span>((</span><span>le_i16</span><span>,</span><span> </span><span>le_i16</span><span>,</span><span> </span><span>le_i16</span><span>,</span><span> </span><span>le_u16</span><span>,</span><span> </span><span>le_u16</span><span>)),</span></span>
<span><span>        // map them to the struct fields</span></span>
<span><span>        </span><span>|</span><span>(</span><span>pos_x</span><span>,</span><span> </span><span>pos_y</span><span>,</span><span> </span><span>angle</span><span>,</span><span> </span><span>thing_type</span><span>,</span><span> </span><span>flags</span><span>)</span><span>|</span><span> </span><span>Thing</span><span> </span><span>{</span></span>
<span><span>            </span><span>pos_x</span><span>,</span></span>
<span><span>            </span><span>pos_y</span><span>,</span></span>
<span><span>            </span><span>angle</span><span>,</span></span>
<span><span>            </span><span>thing_type</span><span>,</span></span>
<span><span>            </span><span>flags</span><span>:</span><span> </span><span>ThingFlags</span><span>::</span><span>from_bits</span><span>(</span><span>flags</span><span>)</span><span>.</span><span>unwrap</span><span>(),</span></span>
<span><span>        </span><span>},</span></span>
<span><span>    </span><span>)(</span><span>input</span><span>)</span></span>
<span><span>}</span></span></code></pre>
<p>I have a nice <code>parse_lump</code> function in a WAD struct, taking the lump name and the parsing function :</p>
<pre><code><span><span>let</span><span> </span><span>things</span><span>:</span><span> </span><span>Vec</span><span>&lt;</span><span>Thing</span><span>&gt;</span><span> </span><span>=</span><span> </span><span>wad</span><span>.</span><span>parse_lump</span><span>(</span><span>&#34;</span><span>THINGS</span><span>&#34;</span><span>,</span><span> thing</span><span>::</span><span>parse_thing</span><span>);</span></span></code></pre>

<p>Getting line segments is relatively easy (group <code>linedefs</code> by <code>sidedef.sector</code>). However, I also intend to group sectors by similar floor heights to reduce the layer count and I need to mark edges as cut or engrave lines if they are polygon borders or internal lines.</p>
<p>The parsed WAD data is an unordered collection of edges. We have a guarantee that edges won’t cross. Merging polygons is just a set union, and removing internal lines is a matter of finding duplicate edges in a polygon.</p>
<p>Strictly speaking, this is enough to produce a SVG that can be laser cut.</p>

<p>It is now time to separate sectors into layers, according to their floor height. This is done by providing an array of heights and grouping sectors by the smallest upper bound, eg. I used <code>[-70, -24, 0, 40]</code> for E1M1.</p>
<p>It could be automated, but I went for artistic control. Sectors could be sorted by ascending height, then split into groups of similar size. That group size could be in function of sector counts or areas. Another criteria could be the sector properties - if a sector is flagged as causing damage (acid, lava…) it could deserve its own layer.</p>
<p>Mayne I’ll investigate later ; my gut feeling is that this problem is related to <a href="https://en.wikipedia.org/wiki/Map_coloring">Map coloring</a>.</p>

<p>I’ve used the <a href="https://crates.io/crates/svg">svg crate</a> in previous experiments. It is barebone, with no attribute type, but works.</p>
<p>For laser cutting, I need :</p>
<ul>
<li>one color for each layer</li>
<li>another for <em>internal lines</em> that I intend to engrave</li>
<li>another for <em>positioning lines</em>. Some layers contain loose parts I’ll need to correctly position before glueing them ; the positioning lines draw those pieces’position on the layer underneath.</li>
</ul>
<p>This is the result for E1M1, with the internal lines in red and the positioning lines in cyan:</p>
<img src="https://theor.xyz/_astro/E1M1.d6193e1e.svg"/>
<h2 id="interlude-halton-sequence"><a data-link="" href="#interlude-halton-sequence"><span></span></a>Interlude: Halton sequence</h2>
<p>I spent a lot of time generating svgs with various colors to validate my work. I reused a trick I’m fond of to generate semi-random colors: using a Halton sequence output as the hue of a <code>HSL</code> color.</p>
<pre><code><span><span>// base, f are parameters here</span></span>
<span><span>let</span><span> </span><span>mut</span><span> </span><span>halton</span><span> </span><span>=</span><span> halton</span><span>::</span><span>Sequence</span><span>::</span><span>new</span><span>(</span><span>base</span><span>);</span></span>
<span></span>
<span><span>for</span><span> </span><span>i</span><span> </span><span>in</span><span> </span><span>0</span><span>..</span><span>sectors</span><span>.</span><span>len</span><span>()</span><span> </span><span>{</span></span>
<span><span>    </span><span>let</span><span> </span><span>color</span><span> </span><span>=</span><span> colorsys</span><span>::</span><span>Hsl</span><span>::</span><span>from</span><span>((</span></span>
<span><span>        // hue 0-360</span></span>
<span><span>        </span><span>(</span><span>h</span><span> </span><span>*</span><span> </span><span>360</span><span>.</span><span>0</span><span> </span><span>*</span><span> </span><span>f</span><span>)</span><span> </span><span>%</span><span> </span><span>360</span><span>.</span><span>0</span><span>,</span></span>
<span><span>        // saturation 0-100</span></span>
<span><span>        </span><span>80</span><span>.</span><span>0</span><span>,</span></span>
<span><span>        // lightness 0-100</span></span>
<span><span>        </span><span>50</span><span>.</span><span>0</span></span>
<span><span>    </span><span>))</span><span>.</span><span>to_css_string</span><span>();</span></span>
<span><span>}</span></span></code></pre>
<p>It is similar to using a pseudorandom generator with a fixed seed, but the Halton sequence is more evenly distributed. Here is the result for 100 values with a few base/f combinations :</p>


<p>Things were too simple at this point, so, of course, I found something. It all started when I thought, “wouldn’t it be great if I could preview the stacked laser cut layers in 3D”.</p>
<p>I bootstrapped a simple Bevy app. To render the layers, I need to triangulate them. It happens there’s a <a href="https://crates.io/crates/triangulate">triangulate crate</a>, but it comes with constraints.</p>
<p>First, let’s look at the DOOM polygons three cases:</p>
<ol>
<li>a <em>simple</em> polygon, which has a specific definition (<a href="https://en.wikipedia.org/wiki/Simple_polygon">Wikipedia</a>) :
<ul>
<li>exactly two edges meet at each vertex</li>
<li>the number of edges equals the number of vertices</li>
</ul>
</li>
</ol>
<img src="https://theor.xyz/_astro/case1.4f5a2c2f.webp" alt="Case 1, a simple polygon" width="30%"/>
<ol start="2">
<li>one polygon with holes (called “weakly simple polygons” in the most basic case akin to a disc). This means the sector represents multiple polygons where one contains the others</li>
</ol>
<img src="https://theor.xyz/_astro/case2.faf55a6a.webp" alt="Case 1, a simple polygon" width="30%"/>
<ol start="3">
<li>multiple polygons sharing one vertex - to be accurate multiple polygons where each pair share at most <em>one</em> contiguous vertex, which makes it a <em>complex</em> polygon. The fact that the edges intersections are vertices means the polygon can be split into simple polygons.</li>
</ol>
<img src="https://theor.xyz/_astro/case3.83ad86e6.webp" alt="Case 1, a simple polygon" width="30%"/>
<p>The <code>triangulate</code> crate (and, AFAIK, all other implementations) needs actual paths - an <em>ordered</em> list of vertices. It also does not support non-simple polygons, which excludes case 3.</p>
<p>To rebuild a path from the unordered list of edges, my initial approach was to pick an edge, then find any edge connected to it. This works for cases 1 and 2, but not for the last one, as those polygons have more than two edges meeting at some vertices.</p>

<p>The solution to that problem is to rebuild paths by repeatedly finding the shortest loop from an edge, which is equivalent to finding all loops where no vertex is used more than once per loop:</p>

<p>If a doom sector contains multiple loops, it means it falls either in case 2 or 3. To figure it out, we can rely on empiric assumptions :</p>
<ul>
<li>Cases 2 and 3 are exclusive - meaning if a vertex is shared, it must not be a hole. only I’m not <em>sure</em> this is true</li>
<li>it also means that if a loop contains another, it is the outer loop of a polygon with holes</li>
</ul>
<p>I went with the latter, using the <a href="https://crates.io/crates/geo">geo rust crate</a> which has extensive support for polygon operations.</p>
<p>I got that to work eventually:</p>
<p><img src="https://theor.xyz/_astro/triangulation.76136dfe.png" alt="Sector triangulation in bevy"/></p>
<p>The issue is that I now need to invert those polygons, as I want to subtract them to an enclosing rectangle - meaning boolean operations (also supported by <code>geo</code>), but now the triangulation fails.</p>
<h2 id="subsector-attempt"><a data-link="" href="#subsector-attempt"><span></span></a>Subsector attempt</h2>
<p>But wait, the WAD does contain simple, convex polygons, right ? The result of the binary space partitioning. It does, but those polygons sometimes have <em>implicit</em> edges defined by the partition lines. I started working on that, then realized that was too much sidetracking. It should work however. Maybe later…</p>
<h2 id="backtracking"><a data-link="" href="#backtracking"><span></span></a>Backtracking</h2>
<p>I gave up on that approach at this point. The solution to the preview, a very valid problem, was simpler: use <a href="https://www.tinkercad.com/">TinkerCad</a> to import the svg layers, extrude them, stack them export a .glb I could render in blender. That’s how I rendered the banner of this article. Note that tinkercad’s SVG import do expect proper SVG paths and not disjoint lines ; so part of that work did serve to produce a cute render.</p>
<p><img src="https://theor.xyz/_astro/doom-render.7f5ff2dc.png" alt="Blender render of E1M1"/>
<img src="https://theor.xyz/_astro/doom-render3.35cc71e8.webp" alt="Blender render of E1M2"/>
<img src="https://theor.xyz/_astro/doom-render4.2135f73b.webp" alt="Blender render of E1M2"/></p>

<p>Just have to glue it now ! I definitely need to try it with clear acry lic or with multiple colors.</p>
<p><img src="https://theor.xyz/_astro/laser.68e52b48.jpg" alt="result"/></p>
      </article>
    </div></div>
  </body>
</html>
