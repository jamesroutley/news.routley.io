<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://uploadcare.com/blog/fighting-jpeg-color-banding/">Original</a>
    <h1>Fighting JPEG color banding</h1>
    
    <div id="readability-page-1" class="page"><article><p>If you ever tried to save photos to JPEG format, you probably know how bad JPEGs can look.
Decades of domination of this format has led to most internet users having an allergy to effects called “JPEG artifacts.”</p><p><em>TL;DR: Even 30 years after JPEG was created, it may still surprise you.
By using low level encoder settings, you can reduce the file size by up to 33% when preparing images for double pixel density.</em></p><figure><img src="https://ucarecdn.com/ba3f489d-1abc-4aeb-aea6-3419327fce41/x480q20.jpg" alt="Louvre. 480×245px, heavily compressed JPEG" width="600"/><figcaption>Louvre. 480×245px, heavily compressed JPEG</figcaption></figure><p>No doubt, no one wants to share such a mess with someone else.
If you ask me what exactly is wrong with the image, I’d probably say that in general it looks very close to the original:
no significant color shift, all objects are distinguishable. However, I’d say there are two major problems:</p><div><ol><li><p>Soft gradients look like separate blocks or bands. That is why it is called color banding.
This is especially noticeable on the sky, but you can see the same on the ground.</p></li><li><p>There are parasite color gradients around sharp objects (look at the roof), and other tiny elements.
This effect is called ringing.</p></li></ol></div><p>Let me show you some magic. I’d like to apply these effects separately.</p><p>So, the left image is a reference with perfect quality.
The center image is heavily compressed, but only has ringing artifacts, while the image on the right has only color banding.
All three images are actual JPEGs, crafted with the unmodified <a target="_blank" href="https://en.wikipedia.org/wiki/Libjpeg" aria-label="opens in a new tab" rel="noopener noreferrer">libjpeg library</a>, no Photoshop involved.</p><p>Both ringing, and banding images are still looking unacceptable.
However, there is a trick, I actually slightly scaled the samples on the page.
You are looking at 480 pixels wide image in total, while it occupies 600 CSS pixels (if you’re reading this on a desktop).
So the pixel density is 0.8x. Modern screens often have pixel density 2x and more.
A common technique is delivering an image with a 2x density (compared to CSS pixels), with minimum possible quality.</p><p>So what’ll be changed if we try to do the same for 2x pixels density?
The samples are the same but with higher resolution: original, heavily compressed with ringing only artifacts, and banding only.</p><p>I’m wondering, have you thought there is a mistake for a second?
There is no mistake, the center sample indeed looks perfect, like the original.
In contrast, the right sample looks as ugly as it was on 0.8x density.</p><p>It’s amazing that the human eye is not sensitive to ringing on a small scales.
If you zoom in the page you’ll see that heavy ringing is still here.
We just don’t see the effect.</p><h2 id="the-problem"><a href="#the-problem">The problem</a></h2><p>The fact that we don’t see ringing is quite interesting, what value can we get here?
The key is above.
For 2x density we need to choose “minimum possible quality” (this is also true for any density).
We have to choose a quality which will not introduce significant artifacts.</p><p>The problem is when reducing quality, both ringing and color banding appears on the image.
In practice, for 2x density it means that we often have to choose a quality which will not introduce significant color banding.</p><p>What if we could reduce quality, and bitrate even more without introducing significant color banding?</p><p>To answer this question, we need to dive into how JPEG compression works first.
Don’t worry, this topic will be extremely simplified.</p><h2 id="jpeg-compression-quick-tour"><a href="#jpeg-compression-quick-tour">JPEG compression quick tour</a></h2><p>First you need to know, JPEG compresses an image by small blocks, 8×8 pixels.
You can even notice blocks on any heavily compressed sample on this page.
Also yes, banding boundaries are always 8 pixels size.</p><p>The JPEG codec doesn’t store pixels’ values directly.
Instead, each block is compared to 64 possible frequency patterns, and only coefficients per pattern per color channel is stored in the file.
You can read the <a target="_blank" href="https://uploadcare.com/blog/jpeg-quality-loss/" aria-label="opens in a new tab" rel="noopener noreferrer">JPEG Quality Loss</a> article if you need further explanation.</p><p>So, look at the table:</p><figure><img src="https://ucarecdn.com/ce1331bb-729d-416b-804e-2f6c86406829/dctjpeg.png" alt="The frequency patterns for 8×8 block" width="540"/><figcaption>The frequency patterns for 8×8 block</figcaption></figure><p>Each cell can have up to 7 transitions from top to bottom, and also 7 from left to right.
The cells in the first row have no transitions from top to bottom.
Each cell in the second row has only one vertical transition, and so on.
The same is true for columns and horizontal transitions.</p><p>You can decompose any 8×8 image pixels block using coefficients for each cell.
For example, if within the block all pixels have the same color, you only need a coefficient for the first cell, all other coefficients will be zero.
To represent more complex patterns, you’ll need the coefficients for several cells.
This decomposition is called Discrete Cosine Transform (DCT).</p><p>Up to this point, no actual compression happens. You can perfectly restore any block using DCT coefficients.
To reduce the actual amount of data you need to store in the file, a quantization table is used.
This table simply tells the encoder how much data it should strip from each coefficient.
For example, here is the base quantization table from libjpeg:</p><div data-language="cpp"><pre><code tabindex="0"><span>static</span> <span>const</span> <span>unsigned</span> <span>int</span> std_luminance_quant_tbl<span>[</span>DCTSIZE2<span>]</span> <span>=</span> <span>{</span>
  <span>16</span><span>,</span>  <span>11</span><span>,</span>  <span>10</span><span>,</span>  <span>16</span><span>,</span>  <span>24</span><span>,</span>  <span>40</span><span>,</span>  <span>51</span><span>,</span>  <span>61</span><span>,</span>
  <span>12</span><span>,</span>  <span>12</span><span>,</span>  <span>14</span><span>,</span>  <span>19</span><span>,</span>  <span>26</span><span>,</span>  <span>58</span><span>,</span>  <span>60</span><span>,</span>  <span>55</span><span>,</span>
  <span>14</span><span>,</span>  <span>13</span><span>,</span>  <span>16</span><span>,</span>  <span>24</span><span>,</span>  <span>40</span><span>,</span>  <span>57</span><span>,</span>  <span>69</span><span>,</span>  <span>56</span><span>,</span>
  <span>14</span><span>,</span>  <span>17</span><span>,</span>  <span>22</span><span>,</span>  <span>29</span><span>,</span>  <span>51</span><span>,</span>  <span>87</span><span>,</span>  <span>80</span><span>,</span>  <span>62</span><span>,</span>
  <span>18</span><span>,</span>  <span>22</span><span>,</span>  <span>37</span><span>,</span>  <span>56</span><span>,</span>  <span>68</span><span>,</span> <span>109</span><span>,</span> <span>103</span><span>,</span>  <span>77</span><span>,</span>
  <span>24</span><span>,</span>  <span>35</span><span>,</span>  <span>55</span><span>,</span>  <span>64</span><span>,</span>  <span>81</span><span>,</span> <span>104</span><span>,</span> <span>113</span><span>,</span>  <span>92</span><span>,</span>
  <span>49</span><span>,</span>  <span>64</span><span>,</span>  <span>78</span><span>,</span>  <span>87</span><span>,</span> <span>103</span><span>,</span> <span>121</span><span>,</span> <span>120</span><span>,</span> <span>101</span><span>,</span>
  <span>72</span><span>,</span>  <span>92</span><span>,</span>  <span>95</span><span>,</span>  <span>98</span><span>,</span> <span>112</span><span>,</span> <span>100</span><span>,</span> <span>103</span><span>,</span>  <span>99</span>
<span>}</span><span>;</span></code></pre></div><p>The first element, 16 means that the encoder should divide the first coefficient by 16, before storing it in the file.
Thus, instead of storing values from 0 to 255, we only need to store values from 0 to 15, which is significantly less information.</p><p>It turns out the higher the values in this table, the more compression is applied, and the lower the image quality is.</p><h2 id="how-jpeg-quality-works"><a href="#how-jpeg-quality-works">How JPEG quality works</a></h2><p>Ok, but where does this table come from when we need to save a file?
It would be a big complication if you had to construct, and transmit 64 independent numbers as a parameter.
Instead, most encoders provide a simple interface to set all 64 values simultaneously.
This is the well known “quality,” which value could be from 0 to 100.
So, we just provide the encoder desired quality and it scales some “base” quantization table.
The higher quality, the lower values in quantization table.</p><p>Now we know how compression works.
We can finally say that color banding is a result of too heavy quantization of low-frequency coefficients, i.e. too high top-left values in the quantization table.</p><p>The good news is while most encoders provide you with a “quality” interface, some of them still allow you to set a custom quantization table.
Also, you can read actual quantization table from a JPEG file.
This means you can get encoder’s default quantization tables for each quality level, and then alter it how you like, without reinventing the wheel:</p><div data-language="python"><pre><code tabindex="0"><span>from</span> io <span>import</span> BytesIO
<span>from</span> PIL <span>import</span> Image

qtables_by_q <span>=</span> <span>[</span><span>]</span>
empty <span>=</span> Image<span>.</span>new<span>(</span><span>&#39;RGB&#39;</span><span>,</span> <span>(</span><span>8</span><span>,</span> <span>8</span><span>)</span><span>)</span>
<span>for</span> q <span>in</span> <span>range</span><span>(</span><span>101</span><span>)</span><span>:</span>
    <span>with</span> BytesIO<span>(</span><span>)</span> <span>as</span> buf<span>:</span>
        empty<span>.</span>save<span>(</span>buf<span>,</span> <span>format</span><span>=</span><span>&#39;JPEG&#39;</span><span>,</span> quality<span>=</span>q<span>)</span>
        qtables <span>=</span> Image<span>.</span><span>open</span><span>(</span>buf<span>)</span><span>.</span>quantization
    qtables_by_q<span>.</span>append<span>(</span>qtables<span>)</span>

Image<span>.</span><span>open</span><span>(</span><span>&#39;in.jpg&#39;</span><span>)</span><span>.</span>save<span>(</span><span>&#39;out.jpg&#39;</span><span>,</span> qtables<span>=</span>qtables_by_q<span>[</span><span>10</span><span>]</span><span>)</span></code></pre></div><h2 id="the-solution"><a href="#the-solution">The solution</a></h2><p>We’ve already learned that we need to fix low-frequency values in the upper-left corner of the quantization table.
But which values, and how to fix them?</p><p>After experimenting a lot, my conclusion is only the first element in the table significantly affects color banding.
For the tests I’ve limited the maximum value with 10 for the luma channel, and 16 for the chroma channels.
Such values make banding hardly visible to me.</p><p>I’ve made some examples, where the left image is a minimally acceptable quality with default quantization tables,
the center image is minimally acceptable quality with altered quantization tables.
The right image has the default quantization tables with the closest bitrate to the altered version.</p><p>Obviously, the result differs from picture to picture.
In some cases results with altered tables may be comparable, or even slightly larger than default tables.</p><p>However, there is no doubt that the image patterns which are influenced by this fix are widely spread across different images.
Without the fix, it is necessary to significantly overrate the image quality, so that such patterns look acceptable to the retina.</p><p>In practice, you often don’t have an option to manually choose the best quality for each image.
You have to choose some base quality that will not spoil most of the images.
Without the fix, this base quality is about 50, while with the fix, it reduces down to 25.
On average, the file size is reduced by 33%, which is a huge win.</p><h2 id="deploying-status"><a href="#deploying-status">Deploying status</a></h2><p>At Uploadcare from the very beginning, we don’t let the user set quality by number for a variety of reasons.
The quality numbers mean different things for different formats, and even codecs.
The quality numbers don’t allow you to set other compression parameters, like <a target="_blank" href="https://uploadcare.com/blog/jpeg-quality-loss/#chroma-subsampling" aria-label="opens in a new tab" rel="noopener noreferrer">subsampling</a>.
Also possibly the most significant, it is not compatible with <a target="_blank" href="https://uploadcare.com/docs/transformations/image/compression/#how-auto-works-and-prioritize-image-formats" aria-label="opens in a new tab" rel="noopener noreferrer">auto-format</a>, when one URL could return different formats for different clients.</p><p>Instead, we offer five base <a target="_blank" href="https://uploadcare.com/docs/transformations/image/compression/#operation-quality" aria-label="opens in a new tab" rel="noopener noreferrer">quality levels</a> for different purposes,
and two “smart” levels, when appropriate image quality is chosen using computer vision.</p><p>Today is another day when we can make sure that such an approach is right.</p><p>For now, we have limited the first element of quantization tables without other changes.
This limiting could increase files size for <code tabindex="0">lightest</code> and <code tabindex="0">smart_retina</code> quality levels from 2% to 5%, but it completely eliminates color banding on the retina displays.</p><p>We have plans for further experiments with quantization tables, to decrease file size for the <code tabindex="0">lightest</code> and <code tabindex="0">smart_retina</code> quality levels without significant visual quality loss.</p><p>Feel free to discuss the article on <a target="_blank" href="https://www.reddit.com/r/webdev/comments/virvv1/fighting_jpeg_color_banding_or_how_to_compress/" aria-label="opens in a new tab" rel="noopener noreferrer"><svg viewBox="0 0 24 24" height="26" width="26" aria-hidden="true" focusable="false" fill="currentColor" xmlns="http://www.w3.org/2000/svg" style="vertical-align: -6px; margin-right: 1px;"><circle cx="9.67" cy="13" r="1.001"></circle><path d="M14.09 15.391A3.28 3.28 0 0 1 12 16a3.271 3.271 0 0 1-2.081-.63.27.27 0 0 0-.379.38c.71.535 1.582.809 2.471.77a3.811 3.811 0 0 0 2.469-.77v.04a.284.284 0 0 0 .006-.396.28.28 0 0 0-.396-.003zm.209-3.351a1 1 0 0 0 0 2l-.008.039c.016.002.033 0 .051 0a1 1 0 0 0 .958-1.038 1 1 0 0 0-1.001-1.001z"></path><path d="M12 2C6.479 2 2 6.477 2 12c0 5.521 4.479 10 10 10s10-4.479 10-10c0-5.523-4.479-10-10-10zm5.859 11.33c.012.146.012.293 0 .439 0 2.24-2.609 4.062-5.83 4.062s-5.83-1.82-5.83-4.062a2.681 2.681 0 0 1 0-.439 1.46 1.46 0 0 1-.455-2.327 1.458 1.458 0 0 1 2.063-.063 7.145 7.145 0 0 1 3.899-1.23l.743-3.47v-.004A.313.313 0 0 1 12.82 6l2.449.49a1.001 1.001 0 1 1-.131.61L13 6.65l-.649 3.12a7.123 7.123 0 0 1 3.85 1.23 1.46 1.46 0 0 1 2.469 1c.01.563-.307 1.08-.811 1.33z"></path></svg>Reddit</a> and <a target="_blank" href="https://news.ycombinator.com/item?id=31846284" aria-label="opens in a new tab" rel="noopener noreferrer"><svg viewBox="0 0 448 512" height="22" width="22" aria-hidden="true" focusable="false" fill="currentColor" xmlns="http://www.w3.org/2000/svg" style="vertical-align: -4px; margin-right: 2px;"><path fill="currentColor" d="M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zM21.2 229.2H21c.1-.1.2-.3.3-.4 0 .1 0 .3-.1.4zm218 53.9V384h-31.4V281.3L128 128h37.3c52.5 98.3 49.2 101.2 59.3 125.6 12.3-27 5.8-24.4 60.6-125.6H320l-80.8 155.1z"></path></svg>HackerNews</a>.</p><p><em>The Louvre photo is shot by <a target="_blank" href="https://commons.wikimedia.org/wiki/File:Louvre_Cour_Carree.jpg" aria-label="opens in a new tab" rel="noopener noreferrer">Benh LIEU SONG</a>.</em></p></article></div>
  </body>
</html>
