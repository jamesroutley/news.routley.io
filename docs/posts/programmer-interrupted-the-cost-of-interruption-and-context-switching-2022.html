<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://contextkeeper.io/blog/the-real-cost-of-an-interruption-and-context-switching/">Original</a>
    <h1>Programmer interrupted: The cost of interruption and context switching (2022)</h1>
    
    <div id="readability-page-1" class="page"><div id="site-main">
    <div>

        <article>

            

            <figure>
            </figure>

            <section>
                <div>
                    <p>Interruptions and context switching are the two most costly factors that directly impact a programmer&#39;s daily productivity. Although there is no permanent way to avoid them, there are some interesting strategies to minimize their impact.</p>
<h2 id="thecostofaninterruption">The Cost of an Interruption</h2>
<p>Based on various scientific studies, it takes at least 10-15 minutes to get back into the &#34;zone&#34; after an interruption (<a href="http://www.chrisparnin.me/pdf/parnin-sqj11.pdf">Parnin:10</a>, <a href="https://www.researchgate.net/publication/220093595_Interrupts_Just_a_Minute_Never_Is">vanSolingen:98</a>). Depending on the complexity of the task and your mental energy, it can definitely take more than just 15 minutes:</p>
<p><a href="https://heeris.id.au/2013/this-is-why-you-shouldnt-interrupt-a-programmer/">
<img src="https://embed.filekitcdn.com/e/ta2FHAgWPvhq7wYzRrVqfZ/wSrVBwzBiivGtC7vxxFkXK/email" alt="Why you shouldn&#39;t interrupt a programmer."/> 
        </a>
</p><p>If an interruption occurs when you have a lot of balls in the air -  multiple pieces of unfinished code fitting together in a complex way -  then returning to the flow state can be more challenging. This concept  is well-known to every programmer, but probably only a few have heard  about <a href="http://en.citizendium.org/wiki/Parable_of_the_two_watchmakers"><em>The Parable of the Two Watchmakers</em></a>, which perfectly captures all those details in a comprehensible form, even for non-programmers:</p>
<blockquote>
<p>There once were two watchmakers, named Hora and Tempus, who made very fine watches. The phones in their workshops rang frequently and new customers were constantly calling them. However, Hora prospered while Tempus became poorer and poorer. In the end, Tempus lost his shop. What was the reason behind this?</p>
<p>The watches consisted of about 1000 parts each. The watches that Tempus made were designed such that, when he had to put down a partly assembled watch, it immediately fell into pieces and had to be reassembled from the basic elements. Hora had designed his watches so that he could put together sub-assemblies of about ten components each, and each sub-assembly could be put down without falling apart. Ten of these sub-assemblies could be put together to make a larger sub-assembly, and ten of the larger sub-assemblies constituted the whole watch.</p>
</blockquote>
<h2 id="thecostofcontextswitching">The Cost of Context Switching</h2>
<p>When switching between complex programming tasks, it is typically more mentally challenging to return to the flow state than it is from a &#34;simple&#34; interruption. Fully switching to something else requires flushing the cache (short-term memory) and loading an entirely new context. This process takes time, effort, and mental energy, which is <a href="https://youtu.be/FKTxC9pl-WM?t=385">finite and depletes throughout the day</a>. These hard limitations are imposed by the human brain.</p>
<p>There is an exceptional book written by David Rock, called <a href="https://davidrock.net/portfolio-items/your-brain-at-work/">Your Brain at Work</a>, that I highly recommend if you are interested in improving how you spend your mental energy throughout the day. The gist is to treat your brain, during a deep work session, as a stage. As a session starts, you slowly introduce essential actors (objects, tasks, and pieces of  information) into a scene (short-term memory aka cache). To properly light up a scene, you need to use some energy - mental energy.</p>
<div> 
<figure>
<img src="https://embed.filekitcdn.com/e/ta2FHAgWPvhq7wYzRrVqfZ/6DjR9Q9mjXMH9acNE1ijm2/email" alt="Mind as a stage during deep work"/> 
        <figcaption>Mind as a stage, during a long deep work session</figcaption>
</figure>

</div><p>When you get distracted, the entire stage collapses, and it takes effort to rebuild it from the ground up. However, there are some handy techniques to rebuild it faster.</p>
<h2 id="rebuildingthecontext">Rebuilding The Context</h2>
<p>For programmers, rebuilding the context after a task switch usually involves going back to old code that was previously edited or debugged. Before editing starts, programmers navigate to several locations to rebuild the context (<a href="http://www.chrisparnin.me/pdf/parnin-sqj11.pdf">Parnin:10</a>). However, task resumption can become much more painful if an IDE doesn&#39;t remember the previous working state. This usually means:</p>
<ul>
<li>last opened files,</li>
<li>cursor position (line &amp; column) for every opened file,</li>
<li>breakpoints, watch variables and expressions,</li>
<li>bookmarks,</li>
<li>windows positions with the same layout (including tab&#39;s splits).</li>
</ul>
<p>Rebuilding the last working state in an IDE <strong>manually</strong> is usually <a href="https://developercommunity.visualstudio.com/t/vs2017-1552-does-not-restore-open-documents/175923#T-N177842-N178047">a real pain and mentally challenging</a>:</p>
<blockquote>
<p>Losing this functionality interrupts my workflow beyond imagination. The opened documents represent a &#34;bookmark&#34; for me and I&#39;m barely able to pick up work again without them.</p>
<p>Every time this happens (...) I am willing to put hours into finding a solution, because <strong>the thought of losing my opened document state once more</strong> after a work session <strong>is terrifying</strong>. But this time around (...) nothing of the usual remedies helps (...) This has added another 20 minutes and counting to my <strong>two hours</strong> put into solving this.</p>
</blockquote>
<p>and programmers are perfectly aware of the problem:</p>
<blockquote>
<p>This is a <strong>much bigger problem than it sounds</strong> as you then need to use other ways to remember what you were working on. <strong>This causes A LOT of lost time</strong> - <a href="https://developercommunity.visualstudio.com/t/visual-studio-reopens-with-no-windows-open/196306"><em>source</em></a>.</p>
</blockquote>
<blockquote>
<p>Itâ€™s so <strong>frustrating</strong> to have to keep pinning the same tabs over &amp; over &amp; over &amp; over &amp; over &amp; over (I think you get the point). (...) My <strong>productivity goes down</strong>, and <strong>my stress level goes up!</strong> - <em><a href="https://developercommunity.visualstudio.com/t/vs-2019-constantly-forgets-pinned-tabs-after-exiti/517954">source</a></em>.</p>
</blockquote>
<p>Which is why, the ability to save working state is now considered a fundamental feature of every good IDE nowadays. However, this was not always the case. Vim introduced <a href="http://vimdoc.sourceforge.net/htmldoc/starting.html#views-sessions"><code>:mksession</code></a> command in the v5.2 around <a href="https://github.com/vim/vim-history/commit/2b6ade85b98b1018fcb120b1b9c982b6917a8c49#diff-e87cb37ae2c2735925ec5c4eaf80928058595bfef42f10ddc4690fa0cae13a83">1998</a>:</p>
<blockquote>
<p>A Session keeps the Views for all windows, plus the global settings. You can save a Session and when you restore it later the window layout looks the same. You can use a Session to quickly switch between different projects, automatically loading the files you were last working on in that project.</p>
</blockquote>
<p>The 640 x 480 resolution was <a href="https://en.wikipedia.org/wiki/Display_resolution">the standard from 1990 to around 1996</a>, but it was possible to get more screen real estate back then. There is a famous photo of John Carmack working on Quake using a 28-inch 1080p monitor in 1995.</p>
<div> 
<figure>
    <img src="https://embed.filekitcdn.com/e/ta2FHAgWPvhq7wYzRrVqfZ/x5HeHRppTqpkVBzjUPgPA6/email" alt="John Carmack and 28-inch 1080p monitor"/> 
        <figcaption>John Carmack and 28-inch 1080p monitor<figcaption>
</figcaption></figcaption></figure>
</div><p>Why did he choose <a href="https://web.archive.org/web/20111010222154/https://geek.com/articles/games/john-carmack-coded-quake-on-a-28-inch-169-1080p-monitor-in-1995-20110920/">45 kg monitor</a> for about $10k in 1995? The higher screen real estate allowed for more code to be visible at once, resulting in a more dense context. Productivity greatly increases when you have the ability to store and access more detailed context. It&#39;s like having a larger desk to hold documents when studying for an exam or doing any task that requires the use of multiple sources of information from a common domain, such as solving puzzles.</p>
<p>I still remember working on my Amiga 1200 in the early 90s, using <a href="https://amiga.lychesis.net/knowledge/ScreenModes.html">HiRes resolution (640x256)</a> and coding in C using <a href="https://www.youtube.com/watch?v=L41oIvre9K0">CygnusED editor</a>.</p>
<div> 
<figure>
    <img src="https://embed.filekitcdn.com/e/ta2FHAgWPvhq7wYzRrVqfZ/nVu53wQfVVbLwg8SnQ6McK/email" alt="CygnusEd on Amiga 2000"/> 
        <figcaption>CygnusED on Amiga 2000<figcaption>
</figcaption></figcaption></figure>
</div><p>Only one file can be opened at a time on this screen, and it does not offer as much real estate as my primary 4K monitor does these days. From a developer&#39;s standpoint, the effect and advancements of <a href="https://en.wikipedia.org/wiki/Display_resolution">display resolutions</a> on daily productivity are immense. Let us attempt to define this observation.</p>
<h4 id="thelawofcontextdensity">The Law of Context Density</h4>
<blockquote>
<p>A larger context naturally emerges with a bigger screen real estate.</p>
</blockquote>
<h2 id="theroleofprospectivememory">The Role of Prospective Memory</h2>
<p>Why is it so important for programmers to have access to their last working context? Let&#39;s start with the definition of <a href="https://en.wikipedia.org/wiki/Prospective_memory"><em>prospective memory</em></a> by John A. Meacham:</p>
<blockquote>
<p><em>Prospective Memory</em> - information with implications for actions to be performed in the future.</p>
</blockquote>
<p>Prospective memory is akin to a sticky note posted on a fridge with a reminder to buy milk after work, or an important document placed near an exit door so that you won&#39;t forget it when leaving the next morning.</p>
<p>A last working context is a form of prospective memory task, so a resumption failure is also a prospective memory failure (<a href="https://hsi.arc.nasa.gov/flightcognition/Publications/Dodhia_SARMAC&#39;05.pdf">Dodhia:05</a>). Have you ever tried to remember a shopping list by only memorizing it? It can be a nightmare, unless you know how to do it properly (e.g., through visualization techniques). Even a short list is hard to remember. That&#39;s why we constantly help our prospective memory by storing bits of information here and there, acting like anchors. When you enter your (remote) office in the morning, there are visual anchors that automatically trigger certain areas of your prospective memory, such as flowers that need to be watered or a document lying on the desk that needs to be processed today. Opening an IDE allows another set of anchors to fire up prospective memory-related tasks.</p>
<p>While modern IDEs can be fairly good at remembering the last working state, they usually lack the ability to switch between them easily. There are few exceptions. Vim with <a href="http://vimdoc.sourceforge.net/htmldoc/starting.html#views-sessions"><code>:mksession</code></a>, Emacs with support for <a href="https://www.emacswiki.org/emacs/EmacsSession">sessions via different packages</a>, Qt Creator with <a href="https://doc.qt.io/qtcreator/creator-project-managing-sessions.html">similar functionality</a>, and IntelliJ-based IDEs with <a href="https://www.jetbrains.com/help/idea/managing-tasks-and-context.html">task and contexts support</a>.</p>
<blockquote>
<p>Looking for a way to <strong>save working state</strong> in <strong>Visual Studio</strong>? Check out my <a href="https://contextkeeper.io/"><strong>ContextKeeper</strong></a> <strong>plugin</strong> with <a href="https://contextkeeper.io/blog/automatic-snapshot-switching-when-changing-branches-v1/"><em>automatic working state switching when changing branches</em></a>.</p>
</blockquote>
<h2 id="references">References</h2>
<ul>
<li>
<p><a href="http://www.chrisparnin.me/pdf/parnin-sqj11.pdf">Parnin:10</a> Resumption strategies for interrupted programming tasks</p>
<ul>
<li>also highly recommend reading <a href="http://blog.ninlabs.com/2013/01/programmer-interrupted/">Programmer Interrupted</a> which summarizes various research papers</li>
</ul>
</li>
<li>
<p><a href="https://www.researchgate.net/publication/220093595_Interrupts_Just_a_Minute_Never_Is">vanSolingen:98</a> Interrupts: Just a Minute Never Is</p>
</li>
<li>
<p><a href="https://hsi.arc.nasa.gov/flightcognition/Publications/Dodhia_SARMAC&#39;05.pdf">Dodhia:05</a> A Task Interrupted Becomes a Prospective Memory Task</p>
</li>
<li>
<p><a href="https://heeris.id.au/2013/this-is-why-you-shouldnt-interrupt-a-programmer/">This Is Why You Shouldn&#39;t Interrupt a Programmer</a></p>
</li>
<li>
<p><a href="http://en.citizendium.org/wiki/Parable_of_the_two_watchmakers">Parable of The Two Watchmakers</a></p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=FKTxC9pl-WM&amp;t=385s">Making Badass Developers - Kathy Sierra</a></p>
</li>
<li>
<p><a href="https://web.archive.org/web/20111010222154/https://geek.com/articles/games/john-carmack-coded-quake-on-a-28-inch-169-1080p-monitor-in-1995-20110920/">John Carmack coded Quake on a 28-inch 16:9 1080p monitor in 1995</a></p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=L41oIvre9K0">CygnusEd Professional in Action on an Amiga 2000</a> with exceptional fluent scrolling, video by <a href="https://caseymuratori.com/about">Casey Muratori</a></p>
</li>
<li>
<p><a href="https://amiga.lychesis.net/knowledge/ScreenModes.html">Amiga screen modes</a></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Prospective_memory">Prospective Memory</a></p>
</li>
<li>
<p><a href="http://vimdoc.sourceforge.net/htmldoc/starting.html#views-sessions">Vim and <code>:mksession</code></a></p>
</li>
<li>
<p><a href="https://www.emacswiki.org/emacs/EmacsSession">Emacs session management</a></p>
</li>
<li>
<p><a href="https://doc.qt.io/qtcreator/creator-project-managing-sessions.html">Qt Creator and managing sessions</a></p>
</li>
<li>
<p><a href="https://www.jetbrains.com/help/idea/managing-tasks-and-context.html">IntelliJ IDEA</a></p>
</li>
<li>
<p><a href="https://contextkeeper.io/">ContextKeeper</a> with <a href="https://contextkeeper.io/blog/automatic-snapshot-switching-when-changing-branches-v1/">automatic snapshot switching when changing branches</a> and <a href="https://contextkeeper.io/blog/relative-paths-support-in-v1-8-and-contextkeeper-mentioned-on-the-jesse-libertys-podcast/">relative paths support</a></p>
</li>
</ul>

                </div>
            </section>

            <section>
                <h3>Subscribe to ContextKeeper</h3>
                <p>Get the latest posts delivered right to your inbox</p>
                


            </section>

            


        </article>

    </div>
</div></div>
  </body>
</html>
