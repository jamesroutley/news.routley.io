<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://alanza.xyz/devlog/2025/#2025-01-05">Original</a>
    <h1>250104 – Please clap</h1>
    
    <div id="readability-page-1" class="page"><div id="page"><div id="2025-01-05"><p><a href="https://github.com/robbielyman/seamstress">Seamstress</a>, until recently, had a pretty simple approach to command-line arguments: if you fed it <code>-v</code> or <code>--version</code> or <code>-h</code> or <code>--help</code> it would print a short message and exit. I realized the other day that of course Lua&#39;s approach to command-line arguments is a detail of the interpreter implementation and not the language&#39;s doing. In anticipation of making more of that goodness available from the Seamstress command-line tool, I figured it might be good to get a better parser going.</p><p>Here&#39;s where we&#39;re at today:</p>
<p>Here&#39;s what my code does: we declare a bunch of optional things we want to pull out of the arguments. Then we loop through the arguments (using a <code>while</code> loop so that we can alter the index mid-flight) and attempt to match against the flags we accept. Since the arguments are strings, the way to match is just a bunch of <code>if</code> statements. Obviously something like Rust&#39;s <code>match</code> would feel nicer to write, but I appreciate the honesty of the <code>if</code> statement, since it&#39;s not like there&#39;s an a priori obvious way to magic up a jump table in assembly out of these conditions. If none of the flags match, we treat the argument as a filename. Since we declared our arguments as optionals, we know that if the optional is already populated, there&#39;s a duplicate arguent, so we can fail in that case. Finally we package all of what we got up into our <code>Args</code> type and return that.</p><p>Processing command line arguments appears to be a common place where people shell out to a package for the actual parsing code. I frankly haven&#39;t the foggiest idea why.</p></div><div id="2025-01-03"><p>A month or so ago I was talking with <a href="https://jdkaplan.dev">Jeremy</a> about how there really are only so many kinds of programs. I’ve forgotten the list we made of them, and I think part of the fun of it is that every program is a little bit many of them anyway.</p><p>Anyway the point of this post is that the Zig compiler and standard library is a great resource for learning the basics of how to interact with a computer when you don’t have that kind of computer ready to play with.</p><p>I realized the other day that in its current state, with Lua itself being the only “external” (which is to say, non-Zig) dependency, attempting building Seamstress for Windows is surely much easier than it would be later on.</p><p>Anyway, compiling turned out to not be so difficult. Here are some things I learned: It turns out Windows (at least, the GitHub CI machine I was interacting with) does not have a <code>$HOME</code> environment variable. Creating <code>/tmp/seamstress.log</code> won’t work because a Unix-style absolute path is no good. Under POSIX (apparently), environment variables are present in a memory structure whose type in Zig is <code>[*:null]?[*:0]u8</code>, which is to say, an array of pointers, each of which is a C-style string (that is, a pointer to bytes; you know when you’re at the end of the string because you’ll hit a character with ASCII value <code>0</code>.) This memory structure is available at the global (extern) variable <code>environ</code> when linking against POSIX libc.</p><p>In order for Seamstress to find and access <code>luarocks</code> modules, in particular <code>busted</code>, which I’m using for Lua unit tests, it needs to set some environment variables that result from running <code>luarocks path</code>. (It’s not enough to use Zig’s cross-platform <code>EnvMap</code> abstraction, though, because ultimately it is Lua code that will need to access these environment variables.) It occurred to me that because the Zig Build system needs to be able to spawn child processes and exposes the ability to set their environment variables that of course the Zig standard library must contain a solution for getting and setting environment variables on Windows.</p><p>Indeed it does: <code>std.process.createWindowsEnvBlock</code> creates such an environment from a <code>std.process.EnvMap</code>. It returns a slice of type <code>[]u16</code> (really <code>[:0]u16</code>). In Zig code at least, to set the environment one interacts (apparently) with the variable <code>std.os.windows.peb().ProcessParameters.Environment</code>. It’s not clear to me how successful or correct this understanding is, since currently my GitHub CI machine neither crashes nor completes on Windows, just hangs, but I’m pretty excited nonetheless.</p></div></div></div>
  </body>
</html>
