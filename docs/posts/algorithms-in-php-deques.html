<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://withinboredom.info/blog/2022/09/12/algorithms-in-php-deques-circular-buffers-linked-lists/">Original</a>
    <h1>Algorithms in PHP: Deques</h1>
    
    <div id="readability-page-1" class="page"><div>
<p><a href="https://withinboredom.info/blog/2022/09/04/algorithms-in-php-priority-queues-and-heaps/">In the previous post</a>, I talked about priority queues. But in my explanation of an alternative implementation, I neglected to mention a few things:</p>



<ol><li>The alternative implementation isn’t for production; there are edge cases and unhandled errors.</li><li>The alternative implementation is meant for a short queue, not an infinite one, such as the one you may deal with in a single request.</li><li>The performance of the alternative implementation may be misleading, in the worst case, it would perform far worse than the STL implementation. However, in my experience, priorities tend to bunch up vs. complete random priorities.</li></ol>



<p>In this post, we’re going to go into Deques (pronounced “decks”), how they are usually implemented, and an alternative implementation that is specific to PHP. If you aren’t aware, PHP is getting a native Deque implementation in 8.2. A Deque is a double-ended queue that you can insert and remove from either end.</p>



<p>Deques are extremely powerful anytime you require a “queue of a bounded length” where the older items are dropped (like an undo buffer). However, this is one of those things where you really shouldn’t implement this in native PHP. STL Queues and Stacks can be used as a Deque and perform far better than anything you can implement in PHP. The reason for this should be evident if you’ve ever tried to prepend to an array; it is slow and <em>gets slower the more items you add to the array</em>.</p>



<h2>A nieve implementation</h2>



<p>A nieve PHP implementation of a Deque would probably look something like this:</p>


<div><pre title="">&lt;?php

namespace Withinboredom\Algorithms\Deque;

class Nieve
{
    private array $buffer = [];

    /**
     * Append to the end
     *
     * @param mixed $value
     *
     * @return void
     */
    public function push(mixed $value): void
    {
        array_push($this-&gt;buffer, $value);
    }

    /**
     * Get from the end of the array
     * @return mixed
     */
    public function pop(): mixed
    {
        return array_pop($this-&gt;buffer);
    }

    /**
     * Get from the beginning
     * @return mixed
     */
    public function shift(): mixed
    {
        return array_shift($this-&gt;buffer);
    }

    /**
     * Append to the beginning
     *
     * @param mixed $value
     *
     * @return void
     */
    public function unshift(mixed $value): void
    {
        array_unshift($this-&gt;buffer, $value);
    }
}
</pre></div>


<p>This nieve implementation is so bad that I wouldn’t use it unless I dealt with less than a few dozen items. Here’s a chart of how bad it gets as the number of items gets larger:</p>



<figure><img src="https://github.com/withinboredom/algorithms/blob/main/src/Algorithms/Deque/nieve.png?raw=true" alt="" data-lazy-src="https://github.com/withinboredom/algorithms/blob/main/src/Algorithms/Deque/nieve.png?raw=true&amp;is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></figure>



<h2>Deques using circular buffers</h2>



<p>Highly performant Deques use circular buffers to accomplish their goals, along with sophisticated logic to automatically grow and shrink the buffers to allow for an infinite number of items. You can imagine a circular buffer as being a clock-type structure. If you were to insert 12 items, it would look like a clock. For a Deque, we’d want two “pointers” to represent the “head” and the “tail” of our Deque, much like the hands on a clock.</p>



<p>We’ll imagine the hour hand to be our “head” and the minute hand to be our “tail” while discussing insertions and deletions. To prepend, we move the hour hand back and insert our new value. To append, we move the minute hand forward and insert our value. To remove from the head, we take the value from the hour hand and move it forward. To remove the tail, we take the value from the minute hand and move it backward.</p>



<p>We aren’t going to cover growing or shrinking circular buffers here to keep it simple.</p>



<p>So, let’s build our class:</p>


<div><pre title="">&lt;?php

namespace Withinboredom\Algorithms\Deque;

class CircularBuffer
{
    private array $buffer = [];
    private int $head = -1;
    private int $tail = 0;

    public function __construct(private int $size)
    {
    }
}
</pre></div>


<p>First thing, we need a buffer to store items in, a head/tail pointer, and a max-size of the buffer. The reason for the strange head/tail initial values is to give us an easy way to tell whether we’re inserting an initial value or whether or not the buffer is full. Here’s how that works:</p>


<div><pre title="">    public function isFull(): bool
    {
        return ($this-&gt;head === 0 &amp;&amp; $this-&gt;tail === $this-&gt;size - 1) || $this-&gt;head === $this-&gt;tail + 1;
    }

    public function isEmpty(): bool
    {
        return $this-&gt;head === -1;
    }
</pre></div>


<h3>Push</h3>



<p>To push onto the buffer, we need to handle several states:</p>


<div><pre title="">    public function push(mixed $value): void
    {
        if ($this-&gt;isFull()) {
            throw new \Exception();
        }

        if ($this-&gt;head === -1) {
            $this-&gt;head = 0;
            $this-&gt;tail = 0;
        } elseif ($this-&gt;tail === $this-&gt;size - 1) {
            $this-&gt;tail = 0;just a tiny
        } else {
            $this-&gt;tail += 1;
        }
        $this-&gt;buffer[$this-&gt;tail] = $value;
    }
</pre></div>


<ol><li>our initial state</li><li>wrapping around the circular buffer</li><li>appending normally</li></ol>



<h3>Pop</h3>



<p>To pop, we also need to handle several states:</p>


<div><pre title="">    public function pop(): mixed
    {
        if ($this-&gt;isEmpty()) {
            throw new \Exception();
        }

        $return = $this-&gt;buffer[$this-&gt;tail];

        if ($this-&gt;head === $this-&gt;tail) {
            $this-&gt;head -= 1;
            $this-&gt;tail -= 1;
        } elseif ($this-&gt;tail === 0) {
            $this-&gt;tail = $this-&gt;size - 1;
        } else {
            $this-&gt;tail -= 1;
        }

        return $return;
    }
</pre></div>


<ol><li>when the buffer is full</li><li>wrapping around the circular buffer</li><li>popping normally</li></ol>



<h3>Shift and Unshift</h3>



<p>Shifting and unshifting are handled the same, but in reverse:</p>


<div><pre title="">    public function shift(): mixed
    {
        if ($this-&gt;isEmpty()) {
            throw new \Exception();
        }

        $return = $this-&gt;buffer[$this-&gt;head];

        if ($this-&gt;head === $this-&gt;tail) {
            $this-&gt;head -= 1;
            $this-&gt;tail -= 1;
        } elseif ($this-&gt;head === $this-&gt;size - 1) {
            $this-&gt;head = 0;
        } else {
            $this-&gt;head += 1;
        }

        return $return;
    }

    public function unshift(mixed $value): void
    {
        if ($this-&gt;isFull()) {
            throw new \Exception();
        }

        if ($this-&gt;head === -1) {
            $this-&gt;head = 0;
            $this-&gt;tail = 0;
        } elseif ($this-&gt;head === 0) {
            $this-&gt;head = $this-&gt;size - 1;
        } else {
            $this-&gt;head -= 1;
        }
        $this-&gt;buffer[$this-&gt;head] = $value;
    }
</pre></div>


<p>The downside to this implementation is that a pre-determined size limits it, however, it is still pretty performant:</p>



<figure><img src="https://github.com/withinboredom/algorithms/blob/main/src/Algorithms/Deque/circ.png?raw=true" alt="" data-lazy-src="https://github.com/withinboredom/algorithms/blob/main/src/Algorithms/Deque/circ.png?raw=true&amp;is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></figure>







<ul><li>ArrayAccess to access arbitrary elements</li><li>Growing/shrinking the circular buffer</li></ul>



<h2>Linked Lists</h2>



<p>Another potential possibility to traditionally implement a Deque is to use a doubly linked list. To accomplish that, we’ll need a “Node” class to represent each item in the list:</p>


<div><pre title="">&lt;?php

namespace Withinboredom\Algorithms\Deque;

class Node
{
    public function __construct(public Node|null $previous, public Node|null $next, public mixed $value)
    {
    }
}
</pre></div>


<p>We can also add a few helpful behaviors: <code>setNext()</code>, <code>setPrevious()</code>, <code>resetNext()</code>, <code>resetPrevious()</code>, <code>removeMeNext()</code> and <code>removeMePrevious()</code>.</p>



<p><code>setNext()</code> and <code>setPrevious()</code> set the <code>$next</code>/<code>$previous</code> variable and return <code>$this</code>:</p>


<div><pre title="">    public function setNext(Node $next): Node
    {
        $this-&gt;next = $next;
        return $this;
    }

    public function setPrevious(Node $previous): Node
    {
        $this-&gt;previous = $previous;
        return $this;
    }
</pre></div>


<p><code>resetNext()</code> and <code>resetPrevious()</code> both unset next/previous:</p>


<div><pre title="">    public function resetPrevious(): Node
    {
        $this-&gt;previous = null;
        return $this;
    }

    public function resetNext(): Node
    {
        $this-&gt;next = null;
        return $this;
    }
</pre></div>


<p><code>removeMeNext()</code> and <code>removeMePrevious()</code> deletes itself from the chain and returns the next/previous Node:</p>


<div><pre title="">    public function removeMeNext(): Node|null
    {
        $return = $this-&gt;next?-&gt;resetPrevious();
        $this-&gt;resetNext();
        return $return;
    }

    public function removeMePrevious(): Node|null
    {
        $return = $this-&gt;previous?-&gt;resetNext();
        $this-&gt;resetPrevious();
        return $return;
    }
</pre></div>


<p>From there, the operations a pretty straightforward:</p>


<div><pre title="">class LinkedList
{
    public Node|null $head = null;
    public Node|null $tail = null;

    /**
     * Append to the tail
     *
     * @param mixed $value
     * @return void
     */
    public function push(mixed $value): void
    {
        $this-&gt;tail =
            $this-&gt;tail?-&gt;setNext(new Node($this-&gt;tail, null, $value))-&gt;next
            ?? $this-&gt;head = new Node(null, null, $value);
    }

    /**
     * Get from the end of the array
     *
     * @return mixed
     */
    public function pop(): mixed
    {
        $return = $this-&gt;tail?-&gt;value ?? throw new \Exception();
        $this-&gt;tail = $this-&gt;tail-&gt;removeMePrevious();
        return $return;
    }

    /**
     * Prepend
     *
     * @return mixed
     */
    public function unshift(mixed $value): void
    {
        $this-&gt;head =
            $this-&gt;head?-&gt;setPrevious(new Node(null, $this-&gt;head, $value))-&gt;previous
            ?? $this-&gt;tail = new Node(null, $this, $value);
    }

    /**
     * Get from the beginning of the array
     *
     * @return mixed
     */
    public function shift(): mixed
    {
        $return = $this-&gt;head?-&gt;value ?? throw new \Exception();
        $this-&gt;head = $this-&gt;head-&gt;removeMeNext();
        return $return;
    }
}
</pre></div>


<p>The performance is linear, just like before:</p>



<figure><img src="https://github.com/withinboredom/algorithms/blob/main/src/Algorithms/Deque/linked-list.png?raw=true" alt="" data-lazy-src="https://github.com/withinboredom/algorithms/blob/main/src/Algorithms/Deque/linked-list.png?raw=true&amp;is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></figure>



<p>However, it still performs worse than a circular buffer or any STL implementation.</p>



<h2>Php Specific implementation</h2>



<p>If you’ve had to work extensively with PHP arrays, you’d probably guess why the naive implementation is so terrible. It’s not that bad, as long as you never unshift the array. Shifting/unshifting to a PHP array has terrible performance implications and should be avoided as much as possible. If you a bulk-prepending, it is usually faster to reverse the array, append your values, then flip the array again.</p>



<p>To avoid prepending to an array, we will use two arrays and only append to them. We’ll call these arrays “front” and “back”; appending to the “front” array is like prepending, and appending to the “back” array is just like regular appending. We pull from the end of each array to take from the “front” and “back,” respectively. Once the appropriate array is empty, we shift from the beginning of the other array until it is empty, which is still incredibly performant.</p>



<p>This implementation is really for when you need something custom, and the other types of algorithms wouldn’t work.</p>


<div><pre title="">&lt;?php

namespace Withinboredom\Algorithms\Deque;

class DoubleList
{
    private array $front = [];
    private array $back = [];
}
</pre></div>


<p>To prepend, we append to <code>$front</code>, and to append; we append to <code>$back</code>:</p>


<div><pre title="">    public function unshift(mixed $value): void
    {
        $this-&gt;front[] = $value;
    }

    public function push(mixed $value): void
    {
        $this-&gt;back[] = $value;
    }
</pre></div>


<p>When we pop, we check to see if <code>$back</code> is empty; if it is, we take it from the start of $front. Otherwise, we take it from the back of <code>$back</code>:</p>


<div><pre title="">    public function pop(): mixed
    {
        if (empty($this-&gt;back)) {
            // take the first item from the front and remove the item
            return array_shift($this-&gt;front);
        }
        return array_pop($this-&gt;back);
    }
</pre></div>






<p>We similarly do the reverse for the shift:</p>


<div><pre title="">    public function shift(): mixed
    {
        if (empty($this-&gt;front)) {
            // take the first item from the back and remove the item
            return array_shift($this-&gt;back);
        }
        return array_pop($this-&gt;front);
    }
</pre></div>


<p>This allows us to get around prepending by appending, almost as performant as the circular buffer implementation.</p>



<figure><img src="https://github.com/withinboredom/algorithms/blob/main/src/Algorithms/Deque/double-list.png?raw=true" alt="" data-lazy-src="https://github.com/withinboredom/algorithms/blob/main/src/Algorithms/Deque/double-list.png?raw=true&amp;is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></figure>



<h2>STL and when to use it</h2>



<p>The STL implementations of Stacks and Queues can be used as Deque. Their performance (wall-clock time) will beat the crap out of these implementations; alternatively, if you are targeting PHP 8.2+, using the native Deque would be an even better solution — though we don’t know what that performance will look like yet.</p>



<p>For 99% of cases, you won’t need to implement your own Deque or any other basic algorithms. However, there are times when implementing your own can allow more business freedoms. For example, Beanstalkd implements its Priority Queue to do some things, such as removing items from the middle of the queue and adding a TTL for jobs. WordPress implements its Priority Queue (actions/filters) to support removal/insertion while iterating the queue and preventing infinite loops. Many other projects also end up embedding certain logic into these algorithms to support business logic in a performant way.</p>



<h2>DS\Deque</h2>



<p>There’s also the <a rel="noreferrer noopener" href="https://www.php.net/manual/en/class.ds-deque.php" target="_blank">DS\Deque class</a>, which is a proper Deque implementation; however, it requires being installed separately and does not come bundled with PHP. It is a little faster than using the STL libraries as a Deque. If you are looking for raw speed, this is the one you’re looking for.</p>



<h2>When to use these algorithms</h2>



<p>As I mentioned, sometimes you need to implement low-level algorithms to support high-performance business cases. It’s unlikely, but knowing how they work and some PHP-specific implementations can significantly impact when it matters.</p>

</div></div>
  </body>
</html>
