<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.moderndescartes.com/essays/optimal_bureaucracy">Original</a>
    <h1>Optimal Bureaucracy</h1>
    
    <div id="readability-page-1" class="page"><div>
    <div>
	

<p> Originally posted 2023-09-12</p>
<p> Tagged: <a href="https://tails.net/essays/tags/math">math</a>, <a href="https://tails.net/essays/tags/software_engineering">software_engineering</a>, <a href="https://tails.net/essays/tags/system_dynamics">system_dynamics</a></p>
<p> <em>Obligatory disclaimer: all opinions are mine and not of my employer </em></p>
<hr/>

<p>This past week, I ended up annoyed with continuous integration
systems. In short: the CI consisted of three stages in the following
order: basic linters/formatters (10 minutes, 90% pass rate), unit tests
(25 minutes, 95% pass rate), and SonarQube (5 minutes, 95% pass rate).
You would think linters/unit tests should have 100% pass rate, but hey,
developers are lazy and they push minor edits and hit the merge button,
without bothering to run the tests locally first. I happened to run into
a SonarQube issue (and it wasn’t locally reproducible), so I had to wait
for this long pipeline to iterate on the fix. This was frustrating and I
had the vague intuition that SonarQube <em>shouldn’t be at the end of
the CI pipeline</em>. But was that actually true, or was I just unlucky
that it was the last step that was failing?</p>
<p>It turns out that this type of question occurs in many different
settings.</p>
<ul>
<li>In drug development, drugs go through multiple optimization stages -
first, the molecular structure is optimized for drug activity; then it
is tweaked for <a href="https://en.wikipedia.org/wiki/ADME">ADME
properties</a>; then it’s tested in animals for toxicity; then it goes
through a series of clinical trials. Is this the right ordering?</li>
<li>At Google, project launches had to go through multiple reviews:
security review, legal, regulatory, SRE, product, (and probably more I’m
forgetting). One typical failure mode of this process is that the
engineering is done up front and then engineers get annoyed and push
back when a reviewer tells them that their product is fundamentally
illegal/insecure/doesn’t fit with the product portfolio. Should the
engineers have instead worked to satisfy some subset of the reviewers
before even starting on their work?</li>
<li>You’re trying to figure out where a group of family/friends will get
together for a big reunion. Everybody has their own constraints and
preferences for where/when/how this should happen. In what order should
you check your suggested plan with everyone?</li>
<li>Any <a href="https://en.wikipedia.org/wiki/Waterfall_model">waterfall</a>
project has to choose the order in which they address requirements
and/or stakeholders.</li>
</ul>
<p>Let’s formalize the CI question to a more general setting and solve
that problem.</p>
<h2 id="the-math">The Math</h2>
<p>Here’s how you might formalize this problem.</p>
<p>You have <span>\(n\)</span> requirements, each
with some cost <span>\(C_i\)</span> and probability
of success <span>\(P_i\)</span>. The probabilities
are all independent. You must complete all requirements in sequence; if
any requirement fails you must start over from scratch. What ordering of
requirements will minimize the total expected cost of the process?</p>
<h3 id="solution">Solution</h3>
<p>Let <span>\(E_i\)</span> indicate the cost up to
some step <span>\(i\)</span>, then</p>
<p><span>\[E_i = \frac{E_{i-1} + C_i}{P_i}\]</span>
<span>\[E_n = \frac{C_1}{P_1P_2P_3\ldots P_n} +
\frac{C_2}{P_2P_3\ldots P_n} + \frac{C_3}{P_3\ldots P_n} + \ldots +
\frac{C_n}{P_n}\]</span></p>
<p>We could brute force over all <span>\(n!\)</span>
possible orderings and pick the one with lowest cost - but hey, if this
were the best solution available, I wouldn’t be writing about it :D</p>
<p>What would a more elegant solution look like? Some wishful thinking
says that if we found some function <span>\(F(C_i,
P_i)\)</span>, and sorted the tasks by this function, then we could
achieve <span>\(O(n \log n)\)</span>.</p>
<p>If we try solving the case with <span>\(n=2\)</span>, we’ll find that we end up with a
candidate function <span>\(F =
\frac{C_i}{1-P_i}\)</span>. (I use <span>\(\stackrel{?}{&lt;}\)</span> to denote unknown
ordering)</p>
<p><span>\[
\begin{align*}
\frac{C_1}{P_1P_2} + \frac{C_2}{P_2} \stackrel{?}{&lt;}&amp;
\frac{C_2}{P_1P_2} + \frac{C_1}{P_1} \\
C_1\frac{1-P_2}{P_1P_2} \stackrel{?}{&lt;}&amp; C_2\frac{1-P_1}{P_1P_2}
\\
\frac{C_1}{1 - P_1} \stackrel{?}{&lt;}&amp; \frac{C_2}{1-P_2}
\end{align*}
\]</span></p>
<p>The implication is that the ordering <span>\(1,
2\)</span> is more efficient than <span>\(2,
1\)</span> only if <span>\(F(1) &lt;
F(2)\)</span>.</p>
<p>Does sorting by <span>\(F\)</span> yield an
optimal solution? Yes. Consider any two adjacent steps <span>\(i\)</span> and <span>\(i+1\)</span>. The cost up through <span>\(i-1\)</span> does not depend on <span>\(i, i+1\)</span>, and the specific ordering of
<span>\((i, i+1)\)</span> vs <span>\((i+1, i)\)</span> does not constrain steps <span>\(i+2...\)</span> in any way. So we are free to
optimize the ordering of <span>\(i\)</span> and
<span>\(i+1\)</span> without regard to the rest of
the sequence. The optimal ordering of <span>\(i\)</span> and <span>\(i+1\)</span> turns out to be identical to the
solved case of <span>\(n=2\)</span> - sort by <span>\(F\)</span>!. Any order inversions can be made more
efficient by flipping the two elements. Writ large, this implies that
you can bubble sort your list.</p>
<p>The conclusion: optimal ordering is accomplished by sorting
requirements by <span>\(F(i) = \frac{C_i}{1 -
P_i}\)</span>.</p>
<h2 id="optimizing-ci">Optimizing CI</h2>
<p>Recall that we had basic linters/formatters (10 minutes, 90% pass
rate), unit tests (25 minutes, 95% pass rate), and SonarQube (5 minutes,
95% pass rate). The function F for these three stages evaluates to 100,
500, and 100. So we can say that SonarQube should always happen before
unit tests, and is tied with the linters/formatters. However, in the
scenario where SonarQube is already failing, then the probability of
passing it with your fixes is something lower, perhaps 50-75%. In this
scenario, SonarQube clearly belongs at the start of the CI pipeline,
with a score of 10-20.</p>
<p>In this toy example, I use time as a cost metric, but it can of
course encompass compute or SaaS costs as well.</p>
<p>I’d love to see CI platforms allow the flexibility to reorder stages
according to which one failed most recently, or to have more intelligent
ordering according to empirically observed failure rates and durations.
One could argue that SonarQube should be made available locally, but
there are many valid CI use cases that can’t be run locally - for
example TensorFlow’s CI used to run against {Windows, Linux} X {CPU,
GPU, TPU} targets, with corresponding hardware/OS maintenance
requirements. (This CI burden is the primary reason why TensorFlow <a href="https://discuss.tensorflow.org/t/2-10-last-version-to-support-native-windows-gpu/12404">dropped
native Windows support</a>!) As it is, most CI configurations are done
by hand and don’t ever change.</p>
<h2 id="acknowledgments">Acknowledgments</h2>
<p>Thanks to <a href="https://www.linkedin.com/in/jay-leeds-6a588919a/">Jay Leeds</a>
for providing a solution and alerting me that a close variation of this
problem was posed in <a href="https://www.youtube.com/watch?v=c_ilfGOnBtE">2023’s ICPC NAC</a>.
(It seems the author of that problem was similarly frustrated with their
CI!)</p>


    </div>
</div></div>
  </body>
</html>
