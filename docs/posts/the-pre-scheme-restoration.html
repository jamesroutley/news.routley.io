<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://prescheme.org/posts/announcing-the-pre-scheme-restoration.html">Original</a>
    <h1>The Pre-Scheme Restoration</h1>
    
    <div id="readability-page-1" class="page"><div><p><img src="https://prescheme.org/images/prescheme-restoration-r7rs.png" alt="Pre-Scheme Restoration (R7RS)"/></p><p>I&#39;m thrilled to announce that the Pre-Scheme Restoration project is now
underway, thanks to a generous grant from the <a href="https://nlnet.nl/">NLnet</a> foundation
under the <a href="https://nlnet.nl/core/">NGI Zero Core</a> program.  This project is
primarily an exercise in software archaeology, bringing an obscure yet
important compiler to a wider audience, and using it as the basis for a
modern, statically-typed, low-level functional programming language.  In
this article I&#39;ll provide some background on Scheme and Pre-Scheme, and
discuss the objectives of this project over the coming months.</p><h2>What is Scheme?</h2><p><a href="https://www.scheme.org/">Scheme</a> is a programming language in the Lisp family, born out
of the research efforts of Gerald Jay Sussman and Guy L. Steele Jr. at
MIT in the mid-to-late 1970s.  Their findings were published in a series
of AI memos collectively known as the <a href="https://en.wikisource.org/wiki/Lambda_Papers">&#34;Lambda Papers&#34;</a>,
which have influenced the design and implementation of programming
languages for nearly 50 years.  During that time, Scheme has been
<a href="https://standards.scheme.org/">revised and standardized</a>, inspired many <a href="https://books.scheme.org/">famous
books</a>, served as a foundation for a huge <a href="https://conservatory.scheme.org/readscheme/">body of
research</a>, and spawned many <a href="https://get.scheme.org/">excellent
implementations</a>.  Perhaps most importantly, Scheme has
been used to introduce computer science principles to multiple
generations of students and programmers around the world.</p><p>Outside of academia, there are a number of active <a href="https://community.scheme.org/">Scheme
communities</a>, mostly organized around particular
implementations.  A fun way that Scheme and Lisp communities come
together is through the regular <a href="https://itch.io/jam/spring-lisp-game-jam-2024/results">Lisp Game Jam</a>, which
saw 48 complete entries in the Spring 2024 competition, half of which
were implemented in Scheme.  The team at the <a href="https://spritely.institute/">Spritely
Institute</a> built an impressive entry called
<a href="https://spritely.institute/news/cirkoban-sokoban-meets-cellular-automata-written-in-scheme.html">Cirkoban</a>, which serves as a tech demo for their work in
porting the <a href="https://spritely.institute/goblins/">Goblins</a> distributed programming environment to
<a href="https://spritely.institute/hoot/">Hoot</a>, a Scheme to WebAssembly compiler.  On another front, the
<a href="https://guix.gnu.org/">Guix project</a> is a major force bringing new users to Scheme,
providing an unparalleled foundation for free and reproducible
computing.  In 2023 they achieved a historic <a href="https://guix.gnu.org/blog/2023/the-full-source-bootstrap-building-from-source-all-the-way-down/">full-source
bootstrap</a>, and in 2024 are making excellent progress
towards the same for RISC-V.  For newcomers to the language, the <a href="https://spritely.institute/static/papers/scheme-primer.html">Scheme
Primer</a> offers an accessible hands-on introduction.</p><h2>What is Pre-Scheme?</h2><p>One influential Scheme implementation is <a href="https://www.s48.org/">Scheme 48</a>, written
by Richard Kelsey and Jonathan Rees in the late 80s.  Frustrated with
the complexity of existing Lisp implementations at the time, they set
out to write <a href="http://mumble.net/~jar/s48/">something simpler</a>.  To bootstrap the virtual
machine and garbage collector, they wrote in a restricted subset of
Scheme which could be easily ported between host environments.  This
subset was dubbed Pre-Scheme, and a few years later Richard Kelsey
developed a compiler for Pre-Scheme based on the techniques described in
<a href="https://prescheme.org/papers/kelsey-diss-2012.pdf">his dissertation</a> and earlier work on a compiler for the
<a href="https://paulgraham.com/thist.html">T Project</a>.</p><p>As described in the <a href="https://prescheme.org/papers/prescheme.pdf">Pre-Scheme paper</a>, the language
offers a unique combination of features:</p><ul><li>Scheme syntax, with full support for macros, and a compatibility
library to run Pre-Scheme code in a Scheme interpreter.  The compiler
is also implemented in Scheme, enabling both interactive development
and compile-time evaluation.</li><li>A static type system based on Hindley/Milner type reconstruction, as
used in the ML family of languages (eg. Standard ML, OCaml, Haskell).
Pre-Scheme supports parametric polymorphism, and has nascent support
for algebraic data types and pattern matching, which are recently
gaining popularity in mainstream languages.</li><li>An optimizing compiler targeting C, allowing for efficient native
code generation and portable low-level machine access.  C remains the
common interface language for operating system facilities, and
compatibility at this level is essential for modern systems
languages.</li></ul><p>Due to the restrictions of static typing and the C runtime model,
Pre-Scheme does not (currently) support many of Scheme&#39;s high-level
features, such as garbage collection, universal tail-call optimization,
heap-allocated runtime closures, first-class continuations, runtime type
checks, heterogenous lists, and the full numeric tower.  Even with these
limitations, Pre-Scheme enables a programming style that is familiar to
Scheme programmers and more expressive than writing directly in C.</p><p>Pre-Scheme remains the bootstrapping mechanism for Scheme 48, but didn&#39;t
see much adoption outside of this use-case.  One reason for this is that
the Pre-Scheme compiler wasn&#39;t exposed as part of an installed Scheme 48
distribution, it needs to be loaded from the source tree, making it an
awkward dependency for other projects.  Another reason is that the
language and compiler interface weren&#39;t fully documented until the mid
2000s, when Taylor Campbell wrote <a href="https://prescheme.org/papers/s48-refman.pdf">&#34;The Nearly Complete Scheme48
Reference Manual&#34;</a> with a detailed description of Pre-Scheme
tucked away in Chapter 9.  In the time since, most development in Scheme
has been focused on other implementations, and the innovations of Scheme
48 are mostly viewed as artifacts of history.</p><h2>Pre-Scheme Restoration</h2><p>Given the rise of modern low-level systems languages like Rust and Zig,
increased recognition of statically-typed functional programming
techniques thanks to the influence of Haskell, and the steady growth of
a Scheme community interested in systems-level development driven by the
Guix project, it seems clear that there is latent demand for a language
like Pre-Scheme.  Scheme offers an expressive and flexible language with
good performance for general-purpose programming tasks, but there remain
use-cases where dropping down to a lower-level language is beneficial,
such as when interfacing with external libraries or writing
performance-critical components.  There are also applications where
Scheme is not generally considered suitable, such as in writing virtual
machines, garbage collectors, operating systems, and embedded systems.
While there <a href="https://prescheme.org/papers/scheme-mobile-robots.pdf">is precedent</a> for using Scheme at this
level, the use of C or other low-level languages remains common
practice.</p><p>The primary objective of the Pre-Scheme Restoration project is to make
Pre-Scheme available as a practical alternative to C for the wider
Scheme community.  This means bringing the Pre-Scheme compiler to as
many Scheme implementations as possible, improving tooling so that it
integrates smoothly with existing development workflows, revising the
Pre-Scheme language to improve compatibility with both Scheme and C, and
investing in documentation and examples so that it&#39;s easy to adopt.  Due
to the age and lack of exposure of the existing implementation, there
are also open questions about compiler performance and correctness which
will need to be addressed.</p><p>Thanks to the grant from NLnet, resources are now available to make
significant progress towards meeting these objectives.  A detailed plan
can be found on <a href="https://prescheme.org/roadmap.html">the roadmap</a>, but the main points
are as follows:</p><ol><li>Port the Pre-Scheme compiler to a selection of R7RS-compatible
Scheme implementations, replacing the Scheme 48 dependency with a
portable reader &amp; macro expander.</li><li>Document the compiler architecture and develop an initial test suite
to aid in further porting and regression testing.</li><li>Extend the language and type system to support the set of sized
numeric types commonly found in systems languages.</li><li>Complete support for sum types (tagged unions), and implement syntax
for algebraic data-types and pattern matching.</li><li>Replace the default string type with a length-prefixed UTF-8
representation.</li><li>Revise other parts of the core language to improve R7RS
compatibility, and implement a standard library covering as much of
R7RS and relevant SRFIs as possible.</li><li>Implement a conventional command-line compiler interface, and an
Emacs plugin to support interactive development.</li><li>Document the language, write tutorials, and develop some example
projects.</li></ol><p>If you are interested in following this project, you can <a href="https://functional.cafe/@flatwhatson">follow
me</a> or <a href="https://fosstodon.org/tags/prescheme">#prescheme</a> on the fediverse,
subscribe to the <a href="https://prescheme.org/atom.xml">Atom feed</a> or <a href="https://prescheme.org/rss.xml">RSS
feed</a>, or join us in the <a href="https://web.libera.chat/#guile-steel">#guile-steel</a>
channel on IRC.  Repositories for the port, this website, and related
projects can be found <a href="https://codeberg.org/prescheme/">on Codeberg</a>.</p><h2>Acknowledgements</h2><p>This project is the continuation of my earlier efforts in porting the
Pre-Scheme compiler to Guile, which were inspired by Christine
Lemmer-Webber&#39;s post <a href="https://dustycloud.org/blog/guile-steel-proposal/">&#34;Guile Steel: a proposal for a systems
lisp&#34;</a>.  Christine has been a driving force behind this
project from the beginning, cheering on those efforts, encouraging me to
present at FOSDEM, and pushing me to apply for an NLnet grant.  Her role
in the current Scheme renaissance cannot be overstated.  I&#39;m grateful to
everyone in the Scheme community who has expressed interest and support
for this project, it means a lot, and I&#39;m looking forward to future
conversations and projects together.  I would also like to thank Luis
Filipe for the beautiful artwork, which is made available under CC BY-SA
4.0, and can be found in the <a href="https://codeberg.org/prescheme/prescheme-dot-org/">website repository</a>.</p></div></div>
  </body>
</html>
