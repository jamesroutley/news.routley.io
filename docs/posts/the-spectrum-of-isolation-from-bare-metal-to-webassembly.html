<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://buildsoftwaresystems.com/post/guide-to-execution-environments/">Original</a>
    <h1>The spectrum of isolation: From bare metal to WebAssembly</h1>
    
    <div id="readability-page-1" class="page"><div>
            
            
              

 
  

<details open="">
  <summary>
    
      Table of Contents
    
  </summary>
  <nav id="TableOfContents">
  <ul>
    <li><a href="#the-journey-toward-lightweight-isolation">The Journey Toward Lightweight Isolation</a>
      <ul>
        <li><a href="#1-physical-machine-bare-metal">1. Physical Machine (Bare Metal)</a></li>
        <li><a href="#2-virtual-machine-vm">2. Virtual Machine (VM)</a></li>
        <li><a href="#3-container">3. Container</a></li>
        <li><a href="#4-process-sandbox">4. Process Sandbox</a>
          <ul>
            <li><a href="#the-sandboxing-toolbox--mechanisms">The Sandboxing Toolbox &amp; Mechanisms</a></li>
          </ul>
        </li>
        <li><a href="#5-virtual-environment">5. Virtual Environment</a>
          <ul>
            <li><a href="#how-modern-isolation-works">How Modern Isolation Works</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#combining-environments-the-best-of-all-worlds">Combining Environments: The Best of All Worlds</a></li>
    <li><a href="#the-future-abstraction-without-losing-the-mental-model">The Future: Abstraction Without Losing the Mental Model</a>
      <ul>
        <li><a href="#containers-as-the-default-interface">Containers as the Default Interface</a></li>
        <li><a href="#serverless-fixing-the-boundary-at-the-function-level">Serverless: Fixing the Boundary at the Function Level</a></li>
        <li><a href="#webassembly-wasm-a-new-isolation-primitive">WebAssembly (Wasm): A New Isolation Primitive</a></li>
      </ul>
    </li>
    <li><a href="#final-thought">Final Thought</a></li>
  </ul>
</nav>
</details>

            
            
            <p>Ever had that dreaded “but it works on my machine!” moment?</p>
<p>The culprit is often a subtle difference in the <strong>execution environment</strong>—the “stage” where your code performs.
You might be dealing with a binary linked against the wrong <a href="https://www.gnu.org/software/libc/" target="_blank">glibc</a>, a <a href="https://packaging.python.org/en/latest/specifications/binary-distribution-format/#binary-distribution-format" target="_blank">Python wheel</a> built for a different architecture, or a kernel feature quietly missing in production.
These invisible discrepancies are what turn a successful local build into a deployment disaster.</p>
<p>Getting the environment right is crucial for writing, testing, and shipping software reliably.
But the landscape is crowded with terms like <em>virtual machines (VM)</em>, <em>containers</em>, <em>virtual environments</em>, and more.
What’s the difference, and which one should you use?</p>
<p>We’re going to trace the evolution of the execution environment.
We’ll start with raw hardware and work through VMs, containers, and the various ways we isolate code at the operating system (OS) and language level.
Along the way, we’ll break down the trade-offs for each approach.
By the end, you’ll know exactly which tool to grab for your next project.</p>


<h2 id="the-journey-toward-lightweight-isolation">
    <a href="#the-journey-toward-lightweight-isolation">
        
        The Journey Toward Lightweight Isolation
    </a>
</h2>
<p>The history of computing is largely a history of <em>resource sharing without chaos</em>.</p>
<p>Early systems ran one workload per machine. Today, a single server might host thousands of isolated applications owned by different teams. The unifying idea behind this evolution is <em>isolation</em>: separating code, dependencies, and resources so they don’t interfere with one another.</p>
<p>But isolation is not binary. It exists on a spectrum—hardware, kernel, process, filesystem, language runtime. Each execution paradigm chooses a different point on that spectrum.</p>
<p><strong>Rule of thumb:</strong> any layer below your chosen isolation boundary must already be compatible—containers won’t fix a kernel mismatch, and virtual environments won’t fix a missing system library.</p>
<p>We’ll move from the heaviest to the lightest abstractions.</p>


<h3 id="1-physical-machine-bare-metal">
    <a href="#1-physical-machine-bare-metal">
        
        1. Physical Machine (Bare Metal)
    </a>
</h3>
<p>This is the foundation. One machine, one operating system, running your code directly on the hardware.</p>
<blockquote>
<p><strong>Hardware (CPU, memory, Disk,…):</strong> Uniquely provided by a physical machine. Two separate environments imply two separate physical machines, each with its own dedicated hardware resources like CPU, memory, and disk.</p></blockquote>
<p>Think of it as a detached house. You have all the resources to yourself, with no neighbors to bother you.</p>
<ul>
<li><strong>Pros:</strong> Maximum performance, full control over hardware.</li>
<li><strong>Cons:</strong> Expensive (you pay for idle resources), slow to provision, inflexible.</li>
<li><strong>Use Case:</strong> High-performance computing (HPC), large databases, or legacy systems that require direct hardware access.</li>
</ul>


<h3 id="2-virtual-machine-vm">
    <a href="#2-virtual-machine-vm">
        
        2. Virtual Machine (VM)
    </a>
</h3>
<p>VMs were the first major leap in efficiency. A piece of software called a <a href="https://en.wikipedia.org/wiki/Hypervisor" target="_blank"><strong>hypervisor</strong></a> carves up a single physical machine into multiple, independent virtual ones.</p>
<blockquote>
<p><strong>Operating System:</strong> Uniquely provided by virtual machines. Two environments can run on the same hardware but will have their own separate, full-fledged operating systems.</p></blockquote>
<p>This is like an apartment building. You still have your own private space (kitchen, bathroom, <em>Operating System</em>), but you share the building’s underlying infrastructure (hardware).</p>
<ul>
<li><strong>Pros:</strong> Strong isolation, can run different operating systems on one host (e.g., Windows and Linux).</li>
<li><strong>Cons:</strong> Significant overhead (each VM has a full OS), slower to start than containers.</li>
<li><strong>Common Tools:</strong>
<ul>
<li><a href="https://www.virtualbox.org/" target="_blank"><em>VirtualBox</em></a>: Great for desktop virtualization.</li>
<li><a href="https://en.wikipedia.org/wiki/Hyper-V" target="_blank"><em>Hyper-V</em></a>: Microsoft’s native hypervisor for Windows.</li>
<li><a href="https://linux-kvm.org/page/Main_Page" target="_blank"><em>KVM</em></a>: The go-to hypervisor for Linux.</li>
<li><a href="https://www.qemu.org/" target="_blank"><em>QEMU</em></a>: A powerful machine emulator and virtualizer.</li>
<li><a href="https://canonical.com/lxd" target="_blank"><em>LXD</em></a>: While primarily a container manager, recent versions can also manage full virtual machines, offering a unified tool for both.</li>
</ul>
</li>
</ul>


<h3 id="3-container">
    <a href="#3-container">
        
        3. Container
    </a>
</h3>
<p>Containers revolutionized modern software development. They bundle an application and its dependencies, but—here’s the key difference—they share the host machine’s operating system kernel.</p>
<blockquote>
<p><strong>Application and Dependencies:</strong> Characterized by packaging an application along with all its dependencies. Multiple containerized environments share the host OS kernel but run in isolated user spaces.</p></blockquote>
<p>Think of containers as hotel rooms. Each is a self-contained, identical unit, but they all rely on the hotel’s core services (the host OS kernel). This makes them incredibly lightweight and fast.</p>
<p>Under the hood, this isolation is enforced by <a href="https://man7.org/linux/man-pages/man7/namespaces.7.html" target="_blank">Linux <em>namespaces</em></a> (which give each container its own view of processes, networking, and the filesystem) and <a href="https://man7.org/linux/man-pages/man7/cgroups.7.html" target="_blank"><em>cgroups</em></a> (which strictly control how much CPU, memory, and I/O it can consume).</p>
<ul>
<li><strong>Pros:</strong> Extremely fast startup, low overhead, highly portable, perfect for microservices.</li>
<li><strong>Cons:</strong> Weaker isolation than VMs (shared kernel can be a security concern).</li>
<li><strong>Common Tools:</strong>
<ul>
<li><a href="https://www.docker.com/" target="_blank"><em>Docker</em></a> The tool that made containers mainstream, ideal for single applications.</li>
<li><a href="https://podman.io/" target="_blank"><em>Podman</em></a>: A popular daemonless alternative to Docker (it runs containers as direct processes without a central background service).</li>
<li><a href="https://canonical.com/lxd" target="_blank"><em>LXD</em></a>: A powerful manager for <a href="https://linuxcontainers.org/lxc/" target="_blank"><em>LXC</em></a> (Linux Containers).</li>
</ul>
</li>
</ul>



  





  


<div>
  
  <div><p><strong>LXD’s Dual Nature:</strong></p>
<p>LXD is a unique tool that intentionally blurs the lines.
Its primary strength is managing <em>LXC system containers</em>, which feel like ultra-fast VMs but are technically containers.</p>
<p>However, as we’ve listed, LXD can <em>also</em> manage full virtual machines.
This makes it a powerful, unified tool for developers who want a single interface for both environment types.</p>
</div>
</div>

<p><strong>What About Managing Many Containers? Orchestration</strong></p>
<p>Tools like Docker and LXD are great for running containers on a single machine.
<a href="https://docs.docker.com/compose/" target="_blank">Docker Compose</a> builds on this by managing multi-container applications as a single unit.
It allows you to define services like a web server and a database together, though it still operates on a single host.</p>
<p>When you need to manage applications across many machines, you move to <em>container orchestrators</em> like <a href="https://kubernetes.io/" target="_blank"><em>Kubernetes</em></a>, <a href="https://docs.docker.com/engine/swarm/" target="_blank"><em>Docker Swarm</em></a>, or <a href="https://www.nomadproject.io/" target="_blank"><em>Nomad</em></a>.
Orchestration is not isolation.
They are the next layer of management for handling scheduling, scaling, and networking at scale.
They do not solve environment drift, dependency mismatches, or build reproducibility.</p>
<p>While orchestration is a deep topic for its own article, it’s the logical next step after adopting containers.</p>


<h3 id="4-process-sandbox">
    <a href="#4-process-sandbox">
        
        4. Process Sandbox
    </a>
</h3>
<p>This is a more specialized form of isolation, often used for security. It “jails” a process, restricting its view of system resources.</p>
<blockquote>
<p><strong>Interface-Level Isolation:</strong> Defined by filtering a process’s interaction with the Linux Kernel. </p></blockquote>
<p>This is like putting a specific activity into a “Safety Cabinet.” You aren’t building a new room; you are simply limiting what the process is allowed to do within your existing system through thick glass and heavy gloves.</p>
<ul>
<li><strong>Pros:</strong> Very lightweight, OS-native security feature.</li>
<li><strong>Cons:</strong> Can be complex to configure correctly, less feature-rich than full container runtimes.</li>
</ul>
<p>Sandboxes shine when you want to <em>reduce the blast radius</em> of a single process—not when you need a reproducible environment.
They are about <em>limiting damage</em>, not standardizing execution.</p>
<p>To build a proper sandbox, we control three specific dimensions:</p>
<ul>
<li><em>Where</em> (Filesystem): Limiting the reach to specific folders.</li>
<li><em>What</em> (Privileges): Limiting the authority to specific actions.</li>
<li><em>How</em> (System Calls): Limiting the communication with the OS kernel.</li>
</ul>


<h4 id="the-sandboxing-toolbox--mechanisms">
    <a href="#the-sandboxing-toolbox--mechanisms">
        
        The Sandboxing Toolbox &amp; Mechanisms
    </a>
</h4>
<p>You can combine the following mechanisms (to create a robust sandbox), or use them individually:</p>
<ul>
<li>
<p><strong>Filesystem Jails (Where)</strong>: Restricts the process to a specific directory tree.</p>
<ul>
<li><a href="https://man7.org/linux/man-pages/man1/chroot.1.html" target="_blank"><em>chroot</em></a> A classic UNIX utility that changes the (perceived) top-level root directory of a process. E.g.: make the process see <code>/tmp/jail</code> as <code>/</code>.</li>
<li><a href="https://proot-me.github.io/" target="_blank"><em>proot</em></a> An implementation of <code>chroot</code> that works without root privileges. It’s a user-space implementation that uses ptrace to fake a root directory without requiring administrative privileges.</li>
</ul>
</li>
<li>
<p><strong>Privilege Dividers (What):</strong> Breaks “Root” powers into small pieces. Instead of giving a process full administrative power, you give it only the specific power it needs (like <code>CAP_NET_BIND_SERVICE</code> just to open a port).</p>
<ul>
<li><a href="https://man7.org/linux/man-pages/man3/libcap.3.html" target="_blank"><em>libcap</em></a>: Manages <a href="https://man7.org/linux/man-pages/man7/capabilities.7.html" target="_blank">Linux Capabilities</a>. Instead of a binary “Root vs. User” choice, it breaks root powers into 40+ granular bits (e.g., <code>CAP_NET_ADMIN</code> to manage networks without being able to read everyone’s files).</li>
<li><a href="https://man7.org/linux/man-pages/man8/setcap.8.html" target="_blank"><em>setcap</em></a> / <a href="https://man7.org/linux/man-pages/man8/getcap.8.html" target="_blank"><em>getcap</em></a>: The command-line utilities used to assign these specific powers to processes.</li>
</ul>
</li>
<li>
<p><strong>System Call Filtering (How)</strong>: A firewall for the Kernel. It prevents a process from executing dangerous commands (like reboot or ptrace) even if it has root privileges.</p>
<ul>
<li><a href="https://man7.org/linux/man-pages/man2/seccomp.2.html" target="_blank"><em>seccomp</em></a>: A Linux kernel feature that filters system calls. For example, if a process tries to use an unapproved call (like <code>execve</code> to start a shell), the kernel kills it instantly.</li>
</ul>
</li>
</ul>
<p><a href="https://github.com/containers/bubblewrap" target="_blank"><em>bubblewrap</em></a> and <a href="https://github.com/netblue30/firejail" target="_blank"><em>Firejail</em></a> are high-level “wrappers” that combine all the above.
They are the engines behind modern “Sandboxed” apps like <a href="https://flatpak.org/" target="_blank">Flatpaks</a>.</p>



  





  


<div>
  
  <p>While these tools provide “surgical” isolation for individual processes, they are also the primary technologies that <em>Containers</em> (like Docker) automate and bundle into a single, portable package.</p>
</div>



<h3 id="5-virtual-environment">
    <a href="#5-virtual-environment">
        
        5. Virtual Environment
    </a>
</h3>
<p>This type of isolation is probably the one you use daily as a developer. It doesn’t isolate the OS or hardware, but rather the <em>dependencies of a programming language</em>.</p>
<blockquote>
<p><strong>Language-Specific Workspace:</strong> Focused on isolating the dependencies of a specific programming language. This allows multiple projects on the same machine to use different versions of the same language and library without conflict.</p></blockquote>
<p>This is your workshop organizer. You have one project that needs an old version of a library and another that needs the latest version. A virtual environment keeps their tools (dependencies) in separate, labeled drawers so they don’t get mixed up. This prevents “dependency hell.”</p>
<ul>
<li><strong>Pros:</strong> Essential for managing project dependencies, simple to use, developer-focused, Zero performance overhead.</li>
<li><strong>Cons:</strong> Provides no OS-level or security isolation; the code still has full access to your user files, network, and system hardware.</li>
</ul>
<p>A critical limitation to remember: virtual environments solve <em>dependency conflicts</em>, not <em>system compatibility</em>.
If your code depends on a specific <em>libc</em> version, OS package, kernel feature, or external binary, a <code>venv</code> alone is no longer sufficient.</p>



  





  


<div>
  
  <p><strong>Blunt heuristic:</strong> if your build or runtime depends on <em>ambient system state</em> you don’t explicitly control—system libraries, OS packages, kernel features—a virtual environment is already too weak.</p>
</div>



<h4 id="how-modern-isolation-works">
    <a href="#how-modern-isolation-works">
        
        How Modern Isolation Works
    </a>
</h4>
<p>To build a clean workspace, we have to solve three problems. Historically, we needed a different tool for each, but modern <em>unified Toolchains</em> are merging them into one.</p>
<ol>
<li>
<p><strong>The Runtime (Runtime Managers):</strong>
These tools handle the language version itself. They allow you to run Python 3.8 for a legacy project while using Python 3.14 for a new one.
</p>
</li>
<li>
<p><strong>The Environment (Path Isolation):</strong>
This tells the system where to look for libraries. In Python, tools like <a href="https://docs.python.org/3/library/venv.html" target="_blank"><code>venv</code></a> or <a href="https://virtualenv.pypa.io/en/latest/" target="_blank"><code>virtualenv</code></a> create a folder to store libraries. In <em>Node.js</em> and <em>Rust</em>, this is handled implicitly by looking for a local <code>node_modules/</code> or a project-specific build directory (<code>target/</code>) relative to your code.</p>
</li>
<li>
<p><strong>The Dependencies (Package Management):</strong>
These tools download and manage the actual libraries (dependencies) versions your code needs to run.
</p>
</li>
</ol>
<p><strong>The Rise of the “All-in-Ones”</strong></p>
<p>The modern trend is the move away from fragmented tools toward <em>Context-Aware</em> toolchains.
These tools detect your project settings and automatically align the Runtime, Environment, and Dependencies.</p>
<ul>
<li><a href="https://docs.astral.sh/uv/pip/environments/" target="_blank"><code>uv</code></a> (Python): An extremely fast, single binary that replaces <code>pyenv</code>, <code>venv</code>, and <code>pip</code>. It can install Python versions and manage libraries in one go.</li>
<li><a href="https://anaconda.org/" target="_blank"><code>Conda</code></a> (Data Science): A heavyweight manager that handles language versions, libraries, and even system-level dependencies like C++ compilers or GPU drivers.</li>
<li><a href="https://github.com/rust-lang/rustup" target="_blank"><code>Rustup</code></a> + <a href="https://doc.rust-lang.org/cargo/reference/manifest.html" target="_blank"><code>Cargo</code></a> (Rust): The gold standard of integration. While technically two tools, they work as one. You can use <code>cargo +nightly build</code> to swap the compiler on the fly, or a <a href="https://rust-lang.github.io/rustup/overrides.html#the-toolchain-file" target="_blank"><code>rust-toolchain.toml</code></a> file to pin the version for everyone on the team.</li>
</ul>


<h2 id="combining-environments-the-best-of-all-worlds">
    <a href="#combining-environments-the-best-of-all-worlds">
        
        Combining Environments: The Best of All Worlds
    </a>
</h2>
<p>A key insight is that these environments are not mutually exclusive. In fact, they are often layered to create robust, professional workflows.</p>
<p>A common setup looks like this:</p>
<ul>
<li>You start with a <em>Virtual Machine</em> from a cloud provider like AWS or Google Cloud.</li>
<li>On that VM, you install <em>Docker</em> to manage <em>Containers</em>.</li>
<li>Inside a container, your application runs, using a language-specific <em>Virtual Environment</em> (like Python’s <code>venv</code>) to manage its dependencies.</li>
</ul>
<p>This layered approach gives you the hardware isolation of a VM, the packaging benefits of containers, and the clean dependency management of a virtual environment.</p>







    
        <div>
            








<div id="mlb2-11590454">
  <div>
    <div>
      <h4>
        
          Newsletter
        
      </h4>
      <p>
        
          Subscribe to our newsletter and stay updated.
        
      </p>
      
    </div>

    
  </div>

  <div>
    <h4>Thank you!</h4>
    <p>Thanks for signing up! Please confirm your subscription via the email we just sent you. Didn&#39;t get the email? Check your spam or promotions folder..</p>
  </div>
</div>







        </div>
    



<h2 id="the-future-abstraction-without-losing-the-mental-model">
    <a href="#the-future-abstraction-without-losing-the-mental-model">
        
        The Future: Abstraction Without Losing the Mental Model
    </a>
</h2>
<p>The direction of travel is clear: execution environments are becoming more abstract—but not simpler.</p>
<p>Each new paradigm removes a layer of responsibility from the developer while <em>fixing the isolation boundary at a higher level</em>.
The trade-offs don’t disappear; they just move.</p>


<h3 id="containers-as-the-default-interface">
    <a href="#containers-as-the-default-interface">
        
        Containers as the Default Interface
    </a>
</h3>
<p>Containers have effectively become the standard unit of execution.
Tools like <a href="https://containers.dev/" target="_blank"><em>Dev Containers</em></a> formalize this by shifting the development environment itself into a container.</p>
<!--
If you're looking for a starting point, I've put together a [universal dev container skeleton]({{ ref "post/software_platform/docker/universal-devcontainer-skeleton-core-config/" >}}) that handles the tricky parts—like syncing your host user and managing proxies—so you don't have to rebuild your config from scratch for every project.
-->
<p>The isolation boundary here sits squarely at the <em>OS-kernel interface</em>.
You share the kernel, but everything above it—filesystem, dependencies, tooling—is locked down and reproducible.</p>
<p>However, this boundary still leaks. Containers built for <em>cgroups v2</em> or specific syscalls will fail on older hosts. When the container assumes kernel features the host lacks, the result is often a silent or catastrophic failure.</p>
<p>In these moments, the “universal” container abstraction breaks: you aren’t just running an image; you are still tethered to the underlying hardware and kernel.</p>


<h3 id="serverless-fixing-the-boundary-at-the-function-level">
    <a href="#serverless-fixing-the-boundary-at-the-function-level">
        
        Serverless: Fixing the Boundary at the Function Level
    </a>
</h3>
<p>Serverless platforms push the isolation boundary even higher. You no longer manage machines, operating systems, or even containers directly. Instead, you hand over a function and accept a tightly constrained execution contract.</p>
<p>This is powerful, but opinionated: cold starts, execution time limits, and restricted system access are not incidental—they are the <em>price of abstraction</em>. Serverless is ideal when you can fully live inside that contract, and painful when you can’t.</p>


<h3 id="webassembly-wasm-a-new-isolation-primitive">
    <a href="#webassembly-wasm-a-new-isolation-primitive">
        
        WebAssembly (Wasm): A New Isolation Primitive
    </a>
</h3>
<p><a href="https://webassembly.org/" target="_blank">Wasm</a> is interesting not because it replaces containers, but because it introduces a new kind of boundary. Instead of isolating at the kernel or process level, Wasm sandboxes execution at the <em>instruction and capability level</em>.</p>
<p>The result is a portable, secure runtime that can run consistently across browsers, servers, and edge environments. If containers standardized <em>how we package software</em>, Wasm is attempting to standardize <em>how software executes</em>.</p>
<p>The common thread is this: progress doesn’t eliminate isolation—it chooses it more deliberately.</p>


<h2 id="final-thought">
    <a href="#final-thought">
        
        Final Thought
    </a>
</h2>
<p>Every execution environment is a trade-off between <strong>control</strong>, <strong>isolation</strong>, <strong>performance</strong>, and <strong>convenience</strong>. Problems arise when we treat these tools as interchangeable—or worse, when we use them without understanding <em>what they isolate and what they don’t</em>.</p>
<p>When in doubt, ask a single question: <em><strong>what is the lowest layer that must be identical for this code to behave correctly?</strong></em> Hardware, kernel, OS packages, or just language dependencies.
The answer points directly to the right execution environment.</p>
<p>As we saw with containers and process sandboxes, choosing the wrong boundary doesn’t fail gracefully.
It fails in ways that are subtle, security-sensitive, or painfully non-obvious.</p>
<p><strong>Practical decision shortcuts:</strong></p>
<ul>
<li>Use a virtual environment when only language-level dependencies vary.</li>
<li>Use a container when system libraries, tooling, or runtime assumptions must be identical.</li>
<li>Use a VM when kernel behavior, OS policies, or security boundaries must not be shared.</li>
</ul>
<p>Once you see execution environments as layered abstractions rather than competing products, architectural decisions become clearer—and “it works on my machine” becomes a relic of the past.</p>
<p>This is why confusing language-level isolation (like <code>venv</code>) with OS-level isolation (containers or sandboxes) is so costly: they sit on entirely different points of the isolation spectrum, and they fail in fundamentally different ways.</p>
<p>If you’re ready to put this into practice with Docker, you might want to explore how to <a href="https://buildsoftwaresystems.com/post/docker-build-target-dev-prod/">merge your Dev and Production environments into a single Dockerfile</a> to eliminate drift entirely.</p>
<p>If you’d like to be notified when I publish pieces like this, you can <a href="https://buildsoftwaresystems.com/contact/#subscription_form">subscribe by email</a>.</p>

          </div></div>
  </body>
</html>
