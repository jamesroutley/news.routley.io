<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://erlangforums.com/t/in-erlang-otp-27-0-0-will-no-longer-be-exactly-equal-to-0-0/2586">Original</a>
    <h1>In Erlang/OTP 27, &#43;0.0 will no longer be exactly equal to -0.0</h1>
    
    <div id="readability-page-1" class="page"><div id="main-outlet" role="main">
        

  

    <div itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
      <meta itemprop="headline" content="In Erlang/OTP 27, +0.0 will no longer be exactly equal to -0.0"/>
        <meta itemprop="articleSection" content="Erlang Notices"/>
      <meta itemprop="keywords" content="float, incompatible"/>
      

          <div id="post_1">
            
            <div itemprop="articleBody">
              <p>Currently, the floating point numbers <code>0.0</code> and <code>-0.0</code> have distinct internal representations. That can be seen if they are converted to binaries:</p>
<pre><code>1&gt; &lt;&lt;0.0/float&gt;&gt;.
&lt;&lt;0,0,0,0,0,0,0,0&gt;&gt;
2&gt; &lt;&lt;-0.0/float&gt;&gt;.
&lt;&lt;128,0,0,0,0,0,0,0&gt;&gt;
</code></pre>
<p>However, when they are matched against each other or compared using the <code>=:=</code> operator, they are considered to be equal. Thus, <code>0.0 =:= -0.0</code> currently returns true.</p>
<p><a href="https://erlangforums.com/u/nzok">@nzok</a> considers this behaviour to <a href="https://erlangforums.com/t/total-term-order/2477/41">be a bug</a>. We also consider it a bug, but until recently we were not sure that fixing and introducing an incompatibility would be be worth it.</p>
<p>A <a href="https://github.com/erlang/otp/issues/7168">recent bug</a> found by <a href="https://erlangforums.com/t/open-sourcing-erlfuzz/2562">erlfuzz</a> made us reconsider. An optimization in the compiler to share identical code would consider the code for the two clauses in this function to be identical:</p>
<pre><code>f(_V0, _V0) -&gt;
    -0.0;
f(_, _) -&gt;
    0.0.
</code></pre>
<p>and essentially rewrite it to:</p>
<pre><code>f(_, _) -&gt;
    0.0.
</code></pre>
<p>To fix this optimization when <code>=:=</code> considers <code>0.0</code> and <code>-0.0</code> to be equal would be cumbersome and could  make the compiler slower. It also likely that other optimizations in the compiler could be affected and would have to be fixed in similarly cumbersome ways.</p>
<p>Therefore, the OTP Technical Board decided that in Erlang/OTP 27, we will change <code>+0.0 =:= -0.0</code> so that it will return <code>false</code>, and matching positive and negative <code>0.0</code> against each other will also fail. When used as map keys, <code>0.0</code> and <code>-0.0</code> will be considered to be distinct.</p>
<p>The <code>==</code> operator will continue to return <code>true</code> for <code>0.0 == -0.0</code>.</p>
<p>To help to find code that might need to be revised, in OTP 27 there will be a new compiler warning when matching against <code>0.0</code> or comparing to that value using the <code>=:=</code> operator. The warning can be suppressed by matching against <code>+0.0</code> instead of <code>0.0</code>.</p>
<p>We also plan to introduce the same warning in OTP 26.1, but by default it will be disabled. Anyone that suspect they have code that might be affected can turn on that warning in OTP 26.1.</p>
            </div>

            

            

          </div>
          <div id="post_2" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://erlangforums.com/u/bjorng"><span itemprop="name">bjorng</span></a>
                
                  Pinned 
              </span></p>


              <p><span>
                  <time itemprop="datePublished" datetime="2023-05-05T08:26:35Z">
                    May 5, 2023,  8:26am
                  </time>
                  <meta itemprop="dateModified" content="2023-05-05T08:26:35Z"/>
              <span itemprop="position">2</span>
              </span>
            </p></div>
            

            

            

          </div>
          <div id="post_3" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://erlangforums.com/u/eiji7"><span itemprop="name">eiji7</span></a>
                
              </span></p>


              <p><span>
                  <time itemprop="datePublished" datetime="2023-05-06T12:54:07Z">
                    May 6, 2023, 12:54pm
                  </time>
                  <meta itemprop="dateModified" content="2023-05-06T12:54:07Z"/>
              <span itemprop="position">3</span>
              </span>
            </p></div>
            <div itemprop="text">
              <p>Interesting … for people not in topic could you also please describe (or link to some article) why <code>&lt;&lt;-0.0/float&gt;&gt;</code> is represented as <code>&lt;&lt;128,0,0,0,0,0,0,0&gt;&gt;</code>? I think that many people and especially newbies would be confused and assume that <code>-0.0</code> and <code>+0.0</code> is always <strong>seen</strong> the same i.e. <code>0.0</code>.</p>
<p>If I understand correctly regardless of <code>value</code> (0.0, 12.34, -98.76, …) first <code>bit</code> of every <code>float</code> is <code>0</code> (positive) or <code>128</code> (negative) and <code>Erlang</code> previously saw that <strong>like</strong>:</p>
<pre data-code-wrap="elixir"><code>defmodule Example do
  def negative?(&lt;&lt;128, _data::8*7&gt;&gt;), do: true
  def negative?(&lt;&lt;_sign, _data::8*7&gt;&gt;), do: false

  def positive?(&lt;&lt;0, _data::8*7&gt;&gt;), do: true
  def positive?(&lt;&lt;_sign, _data::8*7&gt;&gt;), do: false

  def same?(&lt;&lt;_first_sign, 0::8*7&gt;&gt;, &lt;&lt;_second_sign, 0::8*7&gt;&gt;), do: true
  def same?(same, same), do: true
  def same?(_left, _right), do: false
end
</code></pre>
<p>and the change is <strong>like</strong> about removing first clause of <code>Example.same?/2</code> function, right?</p>
            </div>

            

            

          </div>
          <div id="post_4" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            
            <div itemprop="text">
              
<p>Here is a link to Wikipedia’s description:</p>


<p>Yes, the most significant bit is the sign bit. Your example have the wrong sizes for the segments, but it does seem that you have correctly understood both the current behavior and the new behavior. Here is a corrected Erlang version of your <code>same?/2</code> function:</p>
<pre><code>is_same(&lt;&lt;_:1, 0:63&gt;&gt;, &lt;&lt;_:1, 0:63&gt;&gt;) -&gt; true;
is_same(Same, Same) -&gt; true;
is_same(_, _) -&gt; false.
</code></pre>
            </div>

            

            

          </div>
          <div id="post_5" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://erlangforums.com/u/eiji7"><span itemprop="name">eiji7</span></a>
                
              </span></p>


              <p><span>
                  <time itemprop="datePublished" datetime="2023-05-06T14:21:17Z">
                    May 6, 2023,  2:21pm
                  </time>
                  <meta itemprop="dateModified" content="2023-05-06T14:32:47Z"/>
              <span itemprop="position">5</span>
              </span>
            </p></div>
            <div itemprop="text">
              
<p>Since <code>8-bit 0</code> is <code>00000000</code> and <code>128</code> is <code>10000000</code> both examples are good. The <code>&lt;&lt;0&gt;&gt;</code> is <code>&lt;&lt;0:8&gt;&gt;</code> and <code>&lt;&lt;128&gt;&gt;</code> is <code>&lt;&lt;1:1, 0:7&gt;&gt;</code></p>
<pre><code>1&gt; &lt;&lt;0, 0:56&gt;&gt; =:= &lt;&lt;0.0/float&gt;&gt;.             
true
2&gt; &lt;&lt;128, 0:56&gt;&gt; =:= &lt;&lt;-0.0/float&gt;&gt;.
true
3&gt; &lt;&lt;0:1, 0:63&gt;&gt; =:= &lt;&lt;0.0/float&gt;&gt;. 
true
4&gt; &lt;&lt;1:1, 0:63&gt;&gt; =:= &lt;&lt;-0.0/float&gt;&gt;.  
true
5&gt; &lt;&lt;0, 0:56&gt;&gt; == &lt;&lt;0:1, 0:63&gt;&gt;.
true
6&gt; &lt;&lt;128, 0:56&gt;&gt; == &lt;&lt;1:1, 0:63&gt;&gt;.
true
</code></pre>
<p>For those who do not understand:</p>
<ol>
<li>My example have:</li>
<li>Your example have:</li>
</ol>
<p>So:</p>
<pre><code>1&gt; &lt;&lt;0&gt;&gt; =:= &lt;&lt;0:8&gt;&gt;.
true
2&gt; &lt;&lt;128&gt;&gt; =:= &lt;&lt;1:1, 0:7&gt;&gt;.
true
3&gt; &lt;&lt;0, 0:56&gt;&gt; =:= &lt;&lt;0:1, 0:63&gt;&gt;.
true
4&gt; &lt;&lt;128, 0:56&gt;&gt; =:= &lt;&lt;1:1, 0:7, 0:56&gt;&gt;.
true
5&gt; &lt;&lt;1:1, 0:7, 0:56&gt;&gt; =:= &lt;&lt;1:1, 0:63&gt;&gt;.
true
</code></pre>
<p>Also this article may be helpful especially for new developers:</p>

            </div>

            

            

          </div>
          <div id="post_6" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            
            <div itemprop="text">
              
<p>No, they work for <code>0.0</code> but to be picky they drag in another 7 bits that will either be significant (<code>positive?</code> and <code>negative?</code>) or insignificant (<code>same?</code>) which will give funny results for other numbers. For example, <code>-2.0</code> would be considered non-negative by <code>negative?</code>, and equal to <code>2.0</code> according to <code>same?</code>.</p>
            </div>

            

            

          </div>
          <div id="post_7" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://erlangforums.com/u/eiji7"><span itemprop="name">eiji7</span></a>
                
              </span></p>

                

              <p><span>
                  <time itemprop="datePublished" datetime="2023-05-08T08:28:07Z">
                    May 8, 2023,  8:28am
                  </time>
                  <meta itemprop="dateModified" content="2023-05-08T08:28:07Z"/>
              <span itemprop="position">7</span>
              </span>
            </p></div>
            <div itemprop="text">
              <p>ok, now I understand why my code was wrong</p>
<p>I was thinking in good way, but I assumed that all first <code>8 bits</code> are used to store a sign. It’s why I asked if it would be always <code>0</code> or <code>128</code>. That’s obvious waste of memory, the only relevant is the first bit i.e. <code>&lt;&lt;relevant::1, rest::63&gt;&gt;</code>.</p>
<p>The image says more than thousands words! <img src="https://erlangforums.com/images/emoji/apple/smiling_imp.png?v=12" title=":smiling_imp:" alt=":smiling_imp:" loading="lazy" width="20" height="20"/><br/>
</p><div><a href="https://erlangforums.com/uploads/default/original/2X/8/8559105c013404742edb0a67a4f3ebc428da71fd.jpeg" data-download-href="https://erlangforums.com/uploads/default/8559105c013404742edb0a67a4f3ebc428da71fd" title="image"><img src="https://erlangforums.com/uploads/default/original/2X/8/8559105c013404742edb0a67a4f3ebc428da71fd.jpeg" alt="image" data-base62-sha1="j1EjYal7jMiYU69qyE9TXc0Zpbn" width="690" height="486" data-dominant-color="F6F8F8"/></a></div>
            </div>

            

            

          </div>
    </div>






    </div></div>
  </body>
</html>
