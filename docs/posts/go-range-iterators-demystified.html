<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.dolthub.com/blog/2024-07-12-golang-range-iters-demystified/">Original</a>
    <h1>Go range iterators demystified</h1>
    
    <div id="readability-page-1" class="page"><div data-cy="blog-post-text">
<p>We&#39;re using Go to write <a href="https://doltdb.com">Dolt</a>, the world&#39;s first version-controlled SQL
database. Like most large Go codebases, we have a lot of collection types that we iterate over. <a href="https://tip.golang.org/doc/go1.23">New
in Go 1.23</a>, you can now use the <code>range</code> keyword to iterate over
custom collection types.</p>
<p>How does that work? Is it a good idea? Let&#39;s dive in.</p>
<p>If you want to run any of the code in this tutorial, you&#39;ll need to <a href="https://groups.google.com/g/golang-announce/c/8ciOP5ve_CM/m/fg9_BQpdFgA?pli=1">install the Go 1.23 release
candidate</a>, or run Go
1.22 with this in your environment:</p>
<div data-language="bash"><pre><code><span>export</span> <span>GOEXPERIMENT</span><span>=</span>rangefunc</code></pre></div>

<p>I don&#39;t know about you, but I found the explanation and examples from the <a href="https://tip.golang.org/wiki/RangefuncExperiment">experiment
documentation</a> very confusing. But the <a href="https://tip.golang.org/doc/go1.23">release
notes for 1.23</a> do a much better job summarizing the feature
(although not of providing examples).</p>
<p>Range iterators are function types you can use with the built-in <code>range</code> keyword starting in Go
1.23. From the <a href="https://tip.golang.org/doc/go1.23">release notes</a>:</p>
<blockquote>
<p>The “range” clause in a “for-range” loop now accepts iterator functions of the following types:</p>
</blockquote>
<div data-language="go"><pre><code><span>func</span><span>(</span><span>func</span><span>(</span><span>)</span> <span>bool</span><span>)</span>
<span>func</span><span>(</span><span>func</span><span>(</span>K<span>)</span> <span>bool</span><span>)</span>
<span>func</span><span>(</span><span>func</span><span>(</span>K<span>,</span> V<span>)</span> <span>bool</span><span>)</span></code></pre></div>
<p>These correpond to the 3 kinds of simple loops you can write with <code>range</code> (ignoring channels):</p>
<div data-language="go"><pre><code>
<span>for</span> i <span>:=</span> <span>range</span> <span>10</span> <span>{</span> <span>...</span> <span>}</span>


<span>for</span> i <span>:=</span> <span>range</span> mySlice <span>{</span> <span>...</span> <span>}</span>


<span>for</span> i<span>,</span> s <span>:=</span> <span>range</span> mySlice <span>{</span> <span>...</span> <span>}</span></code></pre></div>
<p>Prior to Go 1.23, the <code>range</code> keyword only worked with slices or maps (let&#39;s keep ignoring
channels). Now it works with these special function types as well.</p>
<p>Here&#39;s a simple example:</p>
<div data-language="go"><pre><code><span>func</span> <span>iter1</span><span>(</span>yield <span>func</span><span>(</span>i <span>int</span><span>)</span> <span>bool</span><span>)</span> <span>{</span>
	<span>for</span> i <span>:=</span> <span>range</span> <span>3</span> <span>{</span>
		<span>if</span> <span>!</span><span>yield</span><span>(</span>i<span>)</span> <span>{</span>
			<span>return</span>
		<span>}</span>
	<span>}</span>
<span>}</span></code></pre></div>
<p><code>iter1</code> is a range iterator that will run three times. You use it like this:</p>
<div data-language="go"><pre><code><span>func</span> <span>testFuncRange1</span><span>(</span><span>)</span> <span>{</span>
	<span>for</span> i <span>:=</span> <span>range</span> iter1 <span>{</span>
		fmt<span>.</span><span>Println</span><span>(</span><span>&#34;iter1&#34;</span><span>,</span> i<span>)</span>
	<span>}</span>
<span>}</span></code></pre></div>
<p>When you run this code, it prints the following:</p>


<p>There are three types of range iterator functions, one for each form of the <code>range</code> loop. So they
take 0, 1, or 2 arguments. The one above takes 1 argument. Here&#39;s one that takes 0 arguments:</p>
<div data-language="go"><pre><code><span>func</span> <span>iter0</span><span>(</span>yield <span>func</span><span>(</span><span>)</span> <span>bool</span><span>)</span> <span>{</span>
	<span>for</span> <span>range</span> <span>3</span> <span>{</span>
		<span>if</span> <span>!</span><span>yield</span><span>(</span><span>)</span> <span>{</span>
			<span>return</span>
		<span>}</span>
	<span>}</span>
<span>}</span>

<span>func</span> <span>testFuncRange0</span><span>(</span><span>)</span> <span>{</span>
	<span>for</span> <span>range</span> iter0 <span>{</span>
		fmt<span>.</span><span>Println</span><span>(</span><span>&#34;iter0&#34;</span><span>)</span>
	<span>}</span>
<span>}</span></code></pre></div>
<p>If you run this, it prints:</p>

<p>Here&#39;s an example that takes 2 arguments:</p>
<div data-language="go"><pre><code><span>func</span> <span>iter2</span><span>(</span>yield <span>func</span><span>(</span><span>int</span><span>,</span> <span>int</span><span>)</span> <span>bool</span><span>)</span> <span>{</span>
	<span>for</span> i <span>:=</span> <span>range</span> <span>3</span> <span>{</span>
		<span>if</span> <span>!</span><span>yield</span><span>(</span>i<span>,</span> i<span>+</span><span>1</span><span>)</span> <span>{</span>
			<span>return</span>
		<span>}</span>
	<span>}</span>
<span>}</span>

<span>func</span> <span>testFuncRange2</span><span>(</span><span>)</span> <span>{</span>
	<span>for</span> i<span>,</span> e <span>:=</span> <span>range</span> iter2 <span>{</span>
		fmt<span>.</span><span>Println</span><span>(</span><span>&#34;iter2&#34;</span><span>,</span> i<span>,</span> e<span>)</span>
	<span>}</span>
<span>}</span></code></pre></div>
<p>If you run this, it prints:</p>
<div data-language="text"><pre><code>iter2 0 1
iter2 1 2
iter2 2 3</code></pre></div>

<p>The <code>yield</code> function accepted by a range iterator is what invokes the body of the loop. When you
write a <code>range</code> loop with an iterator, the Go compiler converts it into function calls for you. So
this code:</p>
<div data-language="go"><pre><code><span>func</span> <span>testFuncRange2</span><span>(</span><span>)</span> <span>{</span>
	<span>for</span> i<span>,</span> e <span>:=</span> <span>range</span> iter2 <span>{</span>
		fmt<span>.</span><span>Println</span><span>(</span><span>&#34;iter2&#34;</span><span>,</span> i<span>,</span> e<span>)</span>
	<span>}</span>
<span>}</span></code></pre></div>
<p>Gets implicitly converted by the compiler to something like this code:</p>
<div data-language="go"><pre><code><span>func</span> <span>testFuncRange2</span><span>(</span><span>)</span> <span>{</span>
    <span>iter2</span><span>(</span><span>func</span><span>(</span>i <span>int</span><span>,</span> e <span>int</span><span>)</span> <span>{</span>
		fmt<span>.</span><span>Println</span><span>(</span><span>&#34;iter2&#34;</span><span>,</span> i<span>,</span> e<span>)</span>
        <span>return</span> <span>true</span>
	<span>}</span><span>)</span>
<span>}</span></code></pre></div>
<p>When you call <code>yield()</code> in your range iter function, that&#39;s you invoking the body of the loop. When
you check the return value of <code>yield</code>, that&#39;s you checking to see if the loop should continue or not
-- there might have been a <code>break</code> or <code>return</code> statement.</p>
<p>What if you don&#39;t check the result of <code>yield()</code>?  Then your program will panic in the result there
is a <code>break</code>:</p>
<div data-language="go"><pre><code><span>func</span> <span>brokenIter</span><span>(</span>yield <span>func</span><span>(</span>i <span>int</span><span>)</span> <span>bool</span><span>)</span> <span>{</span>
	<span>for</span> i <span>:=</span> <span>range</span> <span>3</span> <span>{</span>
		<span>yield</span><span>(</span>i<span>+</span><span>1</span><span>)</span>
	<span>}</span>
<span>}</span>

<span>func</span> <span>testBrokenIter</span><span>(</span><span>)</span> <span>{</span>
	<span>for</span> i <span>:=</span> <span>range</span> brokenIter <span>{</span>
		fmt<span>.</span><span>Println</span><span>(</span><span>&#34;brokenIter&#34;</span><span>,</span> i<span>)</span>
		<span>if</span> i <span>&gt;</span> <span>1</span> <span>{</span>
			<span>break</span>
		<span>}</span>
	<span>}</span>
<span>}</span></code></pre></div>
<p>When you run this, you get this panic:</p>
<div data-language="text"><pre><code>brokenIter 1
brokenIter 2
panic: runtime error: range function continued iteration after function for loop body returned false</code></pre></div>
<p>What if you want to not call <code>yield()</code> for every element, or call it more than once, or call it with
different arguments? Well, you can, nothing stops you, and this leads to some interesting use cases.</p>

<p>So why would would you use a range iterator? Basically: so that you can use the <code>range</code> keyword to
iterate over a collection that isn&#39;t a <code>map</code> or a <code>slice</code>. If you don&#39;t want to do that, there&#39;s no
reason to use them.</p>
<p>That said, there are some interesting things you can use them for. Let&#39;s look at a couple.</p>
<p>For all these examples, we&#39;ll define a basic type alias just so that we can define methods on
it. Since the main use case of range iterators is custom collection types, we expect you&#39;ll mostly
see them as methods invoked on a collection object.</p>

<p>For all of our examples, we&#39;ll make sure to conditionally break iteration to test that our iterators
handle that correctly.</p>
<h2 id="using-the-range-keyword-with-a-custom-collection"><a href="#using-the-range-keyword-with-a-custom-collection" aria-label="using the range keyword with a custom collection permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Using the <code>range</code> keyword with a custom collection</h2>
<p>Maybe you just want to use the range keyword to iterate over every element of your collection. Easy
enough.</p>
<div data-language="go"><pre><code><span>func</span> <span>(</span>s Slice<span>)</span> <span>All</span><span>(</span><span>)</span> <span>func</span><span>(</span>yield <span>func</span><span>(</span>i <span>int</span><span>)</span> <span>bool</span><span>)</span> <span>{</span>
	<span>return</span> <span>func</span><span>(</span>yield <span>func</span><span>(</span>i <span>int</span><span>)</span> <span>bool</span><span>)</span> <span>{</span>
		<span>for</span> i <span>:=</span> <span>range</span> s <span>{</span>
			<span>if</span> <span>!</span><span>yield</span><span>(</span>s<span>[</span>i<span>]</span><span>)</span> <span>{</span>
				<span>return</span>
			<span>}</span>
		<span>}</span>
	<span>}</span>
<span>}</span></code></pre></div>
<p>Call it like this:</p>
<div data-language="go"><pre><code><span>func</span> <span>iterAll</span><span>(</span>slice Slice<span>)</span> <span>{</span>
	<span>for</span> i <span>:=</span> <span>range</span> slice<span>.</span><span>All</span><span>(</span><span>)</span> <span>{</span>
		fmt<span>.</span><span>Println</span><span>(</span><span>&#34;all iter:&#34;</span><span>,</span> i<span>)</span>
		<span>if</span> i <span>&gt;</span> <span>10</span> <span>{</span>
			<span>break</span>
		<span>}</span>
	<span>}</span>
<span>}</span></code></pre></div>
<p>Yes, this is not strictly necessary in the case of our <code>Slice</code> since it&#39;s an alias for <code>[]int</code>. But
it demonstrates what&#39;s possible for all collection types.</p>
<h2 id="filtering-values"><a href="#filtering-values" aria-label="filtering values permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Filtering values</h2>
<p>I have a collection of elements, and I want to iterate over just the ones that match certain
criteria. Let&#39;s write a range iterator that iterates over only the prime numbers in a collection:</p>
<div data-language="go"><pre><code><span>func</span> <span>(</span>s Slice<span>)</span> <span>Primes</span><span>(</span><span>)</span> <span>func</span> <span>(</span>yield <span>func</span><span>(</span>i <span>int</span><span>)</span> <span>bool</span><span>)</span> <span>{</span>
	<span>return</span> <span>func</span> <span>(</span>yield <span>func</span><span>(</span>i <span>int</span><span>)</span> <span>bool</span><span>)</span> <span>{</span>
		<span>for</span> i <span>:=</span> <span>range</span> s <span>{</span>
			<span>if</span> big<span>.</span><span>NewInt</span><span>(</span><span>int64</span><span>(</span>s<span>[</span>i<span>]</span><span>)</span><span>)</span><span>.</span><span>ProbablyPrime</span><span>(</span><span>0</span><span>)</span> <span>{</span>
				<span>if</span> <span>!</span><span>yield</span><span>(</span>s<span>[</span>i<span>]</span><span>)</span> <span>{</span>
					<span>return</span>
				<span>}</span>
			<span>}</span>
		<span>}</span>
	<span>}</span>
<span>}</span></code></pre></div>
<p>I can call it like this:</p>
<div data-language="go"><pre><code><span>func</span> <span>iterPrimes</span><span>(</span>slice Slice<span>)</span> <span>{</span>
	<span>for</span> i <span>:=</span> <span>range</span> slice<span>.</span><span>Primes</span><span>(</span><span>)</span> <span>{</span>
		fmt<span>.</span><span>Println</span><span>(</span><span>&#34;prime number:&#34;</span><span>,</span> i<span>)</span>
		<span>if</span> i <span>&gt;</span> <span>10</span> <span>{</span>
			<span>break</span>
		<span>}</span>
	<span>}</span>
<span>}</span></code></pre></div>
<p>We can generalize this filtering approach by making a method that accepts a <em>predicate function</em>:</p>
<div data-language="go"><pre><code><span>func</span> <span>(</span>s Slice<span>)</span> <span>FilteredIter</span><span>(</span>predicate <span>func</span><span>(</span>i <span>int</span><span>)</span> <span>bool</span><span>)</span> <span>func</span> <span>(</span>yield <span>func</span><span>(</span>i <span>int</span><span>)</span> <span>bool</span><span>)</span> <span>{</span>
	<span>return</span> <span>func</span> <span>(</span>yield <span>func</span><span>(</span>i <span>int</span><span>)</span> <span>bool</span><span>)</span> <span>{</span>
		<span>for</span> i <span>:=</span> <span>range</span> s <span>{</span>
			<span>if</span> <span>predicate</span><span>(</span>s<span>[</span>i<span>]</span><span>)</span> <span>{</span>
				<span>if</span> <span>!</span><span>yield</span><span>(</span>s<span>[</span>i<span>]</span><span>)</span> <span>{</span>
					<span>return</span>
				<span>}</span>
			<span>}</span>
		<span>}</span>
	<span>}</span>
<span>}</span></code></pre></div>
<p>Now I can call this iterator with any predicate I want to select which elements in the collection to
iterate over. Here&#39;s one that iterates over only even numbers.</p>
<div data-language="go"><pre><code><span>func</span> <span>iterEvens</span><span>(</span>slice Slice<span>)</span> <span>{</span>
	<span>for</span> i <span>:=</span> <span>range</span> slice<span>.</span><span>FilteredIter</span><span>(</span><span>func</span><span>(</span>i <span>int</span><span>)</span> <span>bool</span> <span>{</span>
		<span>return</span> i<span>%</span><span>2</span> <span>==</span> <span>0</span>
	<span>}</span><span>)</span> <span>{</span>
		fmt<span>.</span><span>Println</span><span>(</span><span>&#34;even number:&#34;</span><span>,</span> i<span>)</span>
		<span>if</span> i <span>&gt;</span> <span>10</span> <span>{</span>
			<span>break</span>
		<span>}</span>
	<span>}</span>
<span>}</span></code></pre></div>
<h2 id="iterating-while-handling-errors"><a href="#iterating-while-handling-errors" aria-label="iterating while handling errors permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Iterating while handling errors</h2>
<p>For some collections, during iteration you might need to perform I/O or some other operation that
could fail in order to produce the next element. Range iterators give a very succinct way to express
this. Just define your iterator like this:</p>
<div data-language="go"><pre><code><span>func</span> <span>(</span>s Slice<span>)</span> <span>ErrorIter</span><span>(</span><span>)</span> <span>func</span><span>(</span>yield <span>func</span><span>(</span>i <span>int</span><span>,</span> e <span>error</span><span>)</span> <span>bool</span><span>)</span> <span>{</span>
	<span>return</span> <span>func</span><span>(</span>yield <span>func</span><span>(</span>i <span>int</span><span>,</span> e <span>error</span><span>)</span> <span>bool</span><span>)</span> <span>{</span>
		<span>for</span> <span>_</span><span>,</span> i <span>:=</span> <span>range</span> s <span>{</span>
            
            
			<span>if</span> <span>!</span><span>yield</span><span>(</span>i<span>,</span> <span>nil</span><span>)</span> <span>{</span>
				<span>return</span>
			<span>}</span>
		<span>}</span>
	<span>}</span>
<span>}</span></code></pre></div>
<p>This uses the 2-parameter variation of a <code>range</code> loop, which in the case of a slice or a map returns
the index and element or the key and value, respectively. We&#39;re slightly abusing that convention so
that our iterator returns either the element if it can be gotten, or an error.</p>
<div data-language="go"><pre><code><span>func</span> <span>iterWithErr</span><span>(</span>slice Slice<span>)</span> <span>error</span> <span>{</span>
	<span>for</span> i<span>,</span> err <span>:=</span> <span>range</span> slice<span>.</span><span>ErrorIter</span><span>(</span><span>)</span> <span>{</span>
		<span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
			<span>return</span> err
		<span>}</span>
		fmt<span>.</span><span>Printf</span><span>(</span><span>&#34;error iter got value: %d\n&#34;</span><span>,</span> i<span>)</span>
		<span>if</span> i <span>&gt;</span> <span>10</span> <span>{</span>
			<span>break</span>
		<span>}</span>
	<span>}</span>
	<span>return</span> <span>nil</span>
<span>}</span></code></pre></div>
<p>Maybe this makes you feel uncomfortable, which is understandable. It may not be what the Go authors
had in mind for these iterators, because it breaks the idiom of what the values in <code>range</code> mean. But
because it&#39;s both easy to do and useful, I predict this use case will emerge as a common pattern for
custom collection types.</p>
<p>If your iteration can return an error but you don&#39;t like the 2-parameter version, you can always
create a little wrapper struct for your results like so:</p>
<div data-language="go"><pre><code><span>type</span> IterResult <span>struct</span> <span>{</span>
    Result <span>int</span>
    Err <span>error</span>
<span>}</span></code></pre></div>
<h2 id="handling-sentinel-errors"><a href="#handling-sentinel-errors" aria-label="handling sentinel errors permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Handling sentinel errors</h2>
<p>One iteration pattern we&#39;ve seen a few places is for traditional iterators to use a sentinel error,
often <code>io.EOF</code>, to signal there are no more values. So you have an iteration loop that looks like
this:</p>
<div data-language="go"><pre><code><span>for</span> <span>{</span>
    val<span>,</span> err <span>:=</span> iter<span>.</span><span>Next</span><span>(</span><span>)</span>
    <span>if</span> err <span>==</span> io<span>.</span>EOF <span>{</span>
        <span>break</span>
    <span>}</span> <span>else</span> <span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
        <span>return</span> <span>nil</span><span>,</span> err
    <span>}</span>
    
    
<span>}</span></code></pre></div>
<p>Wouldn&#39;t it be nice if we didn&#39;t have to handle end-of-loop control flow by checking for a specific
sentinel error? Well, with range iters you can convert any iterator to do just that.</p>
<div data-language="go"><pre><code><span>type</span> iterEof <span>struct</span> <span>{</span>
	slice Slice
	i <span>int</span>
<span>}</span>

<span>func</span> <span>(</span>iter <span>*</span>iterEof<span>)</span> <span>Next</span><span>(</span><span>)</span> <span>(</span><span>int</span><span>,</span> <span>error</span><span>)</span> <span>{</span>
	<span>defer</span> <span>func</span><span>(</span><span>)</span> <span>{</span>
		iter<span>.</span>i<span>++</span>
	<span>}</span><span>(</span><span>)</span>
	
	<span>if</span> iter<span>.</span>i <span>&gt;=</span> <span>len</span><span>(</span>iter<span>.</span>slice<span>)</span> <span>{</span>
		<span>return</span> <span>0</span><span>,</span> io<span>.</span>EOF
	<span>}</span> <span>else</span> <span>if</span> rand<span>.</span><span>Float32</span><span>(</span><span>)</span> <span>&gt;</span> <span>.9</span> <span>{</span>
		<span>return</span> <span>0</span><span>,</span> fmt<span>.</span><span>Errorf</span><span>(</span><span>&#34;failed to fetch next element&#34;</span><span>)</span>
	<span>}</span>
	
	<span>return</span> iter<span>.</span>slice<span>[</span>iter<span>.</span>i<span>]</span><span>,</span> <span>nil</span>
<span>}</span>

<span>func</span><span>(</span>s Slice<span>)</span> <span>Iter</span><span>(</span><span>)</span> <span>*</span>iterEof <span>{</span>
	<span>return</span> <span>&amp;</span>iterEof<span>{</span>slice<span>:</span> s<span>}</span>
<span>}</span>

<span>func</span> <span>(</span>s Slice<span>)</span> <span>RangeCompatibleIter</span><span>(</span><span>)</span> <span>func</span> <span>(</span>yield <span>func</span><span>(</span><span>int</span><span>,</span> <span>error</span><span>)</span> <span>bool</span><span>)</span> <span>{</span>
	iter <span>:=</span> s<span>.</span><span>Iter</span><span>(</span><span>)</span>
	<span>return</span> <span>func</span> <span>(</span>yield <span>func</span><span>(</span>i <span>int</span><span>,</span> e <span>error</span><span>)</span> <span>bool</span><span>)</span> <span>{</span>
		<span>for</span> <span>{</span>
			next<span>,</span> err <span>:=</span> iter<span>.</span><span>Next</span><span>(</span><span>)</span>
			<span>if</span> err <span>==</span> io<span>.</span>EOF <span>{</span>
				<span>return</span>
			<span>}</span>

			<span>if</span> <span>!</span><span>yield</span><span>(</span>next<span>,</span> err<span>)</span> <span>{</span>
				<span>return</span> 
			<span>}</span>
		<span>}</span>
	<span>}</span>
<span>}</span></code></pre></div>
<p>This range iterator wraps the underlying, traditional iterator and handles the <code>io.EOF</code> control flow
for us. Now when we use it, any error we get is a real error, not a sentinel value.</p>
<div data-language="go"><pre><code><span>func</span> <span>iterTraditionalWithRange</span><span>(</span>slice Slice<span>)</span> <span>{</span>
	<span>for</span> i<span>,</span> err <span>:=</span> <span>range</span> slice<span>.</span><span>RangeCompatibleIter</span><span>(</span><span>)</span> <span>{</span>
		<span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
			fmt<span>.</span><span>Printf</span><span>(</span><span>&#34;error: %s\n&#34;</span><span>,</span> err<span>.</span><span>Error</span><span>(</span><span>)</span><span>)</span>
		<span>}</span>

		fmt<span>.</span><span>Println</span><span>(</span><span>&#34;iter got value: &#34;</span><span>,</span> i<span>)</span>
	<span>}</span>
<span>}</span></code></pre></div>
<p>A small quality of life improvement, but maybe one you care about. You also can use the same
strategy, minus the error handling, to convert any traditional iterator object to one compatible
with the <code>range</code> keyword using this technique.</p>

<p>The Go authors also included two convenience functions, <code>Pull</code> and <code>Pull2</code>, that transform range
iterator functions into traditional iterators. This is for people working with libraries that use
range iterators, but who <em>don&#39;t</em> want to use the range keyword, and would rather iterate with a
<code>Next()</code> method instead. Here&#39;s how they work.</p>
<div data-language="go"><pre><code><span>func</span> <span>iterTraditionalWithRangeRoundTrip</span><span>(</span>slice Slice<span>)</span> <span>{</span>
	next<span>,</span> stop <span>:=</span> iter<span>.</span><span>Pull2</span><span>(</span>slice<span>.</span><span>RangeCompatibleIter</span><span>(</span><span>)</span><span>)</span>
	<span>defer</span> <span>stop</span><span>(</span><span>)</span>
	i <span>:=</span> <span>0</span>
	<span>for</span> <span>{</span>
		result<span>,</span> err<span>,</span> valid <span>:=</span> <span>next</span><span>(</span><span>)</span>
		<span>if</span> <span>!</span>valid <span>{</span>
			<span>break</span>
		<span>}</span>
		
		<span>if</span> i <span>&gt;</span> <span>10</span> <span>{</span>
			<span>break</span>
		<span>}</span>
		i<span>++</span>

		<span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
			fmt<span>.</span><span>Printf</span><span>(</span><span>&#34;error: %s\n&#34;</span><span>,</span> err<span>.</span><span>Error</span><span>(</span><span>)</span><span>)</span>
		<span>}</span> <span>else</span> <span>{</span>
			fmt<span>.</span><span>Println</span><span>(</span><span>&#34;iter got value: &#34;</span><span>,</span> result<span>)</span>
		<span>}</span>
	<span>}</span>
<span>}</span></code></pre></div>
<p>So the <code>Pull2</code> function returns an iterator function, <code>next</code>. When you call it, you get back the 2
result params from the range iterator (only 1 result for the <code>Pull</code> function), as well as a boolean
telling you whether iteration is done. You must dispose of the iterator with the provided <code>stop</code>
function.</p>
<p>What we&#39;re doing above is deeply silly: we have a traditional iterator with a <code>Next()</code> method that
we&#39;re wrapping to turn into a range iterator, then using the <code>Pull2</code> function to turn it <em>back</em> into
a traditional iterator. But it all works, and demonstrates that these techniques can be composed in
arbitrary ways. Fun!</p>

<p>The Go convention for <code>range</code> is that the one-var version returns an index or a key, and the
two-var version returns those plus their values. If you want only the values, not the keys or
indexes, you do this:</p>
<div data-language="go"><pre><code><span>for</span> <span>_</span><span>,</span> val <span>:=</span> <span>range</span> slice <span>{</span> <span>...</span> <span>}</span></code></pre></div>
<p>With range iterators, we&#39;re free to write iterator functions that break this convention. So in some
of the above examples, we have a single var returned, and it&#39;s the value, not the index.</p>
<div data-language="go"><pre><code><span>func</span> <span>iterPrimes</span><span>(</span>slice Slice<span>)</span> <span>{</span>
	<span>for</span> i <span>:=</span> <span>range</span> slice<span>.</span><span>Primes</span><span>(</span><span>)</span> <span>{</span>
		fmt<span>.</span><span>Println</span><span>(</span><span>&#34;prime number:&#34;</span><span>,</span> i<span>)</span>
		<span>if</span> i <span>&gt;</span> <span>10</span> <span>{</span>
			<span>break</span>
		<span>}</span>
	<span>}</span>
<span>}</span></code></pre></div>
<p>Is this a good thing? Is it confusing that the single-var version of the <code>range</code> keyword might work
completely differently for range iterators than maps and slices? Well, this feature is still new,
and the conventions for its use don&#39;t really exist yet, so I&#39;ll leave it to the community to fight
over. However, I will point out that in a majority of the cases when I use the range keyword with a
slice, I&#39;m only interested in the value, not the index. And for some collection types, there isn&#39;t a
meaningful index or key to return anyway. I&#39;m sure we&#39;ll figure it out over time.</p>

<p>You can find all the examples above, plus some I cut for space,
<a href="https://gist.github.com/zachmu/350b47fbcbd0b0b08414ef4a58da8f80">here</a>.</p>
<p>Have questions about Go range iterators? Or maybe you are curious about the world&#39;s first
version-controlled SQL database? <a href="https://discord.gg/gqr7K4VNKe">Join us on Discord</a> to talk to our
engineering team and other Dolt users.</p></div></div>
  </body>
</html>
