<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.thezdi.com/blog/2022/7/13/cve-2022-30136-microsoft-windows-network-file-system-v4-remote-code-execution-vulnerability">Original</a>
    <h1>Microsoft Windows Network File System v4 Remote Code Execution</h1>
    
    <div id="readability-page-1" class="page"><div id="outerWrapper">

      

      <!--HEADER-->

      

      <!--SITE TITLE OR LOGO-->
      <div id="innerWrapper">

      <!--CONTENT INJECTION POINT-->
        <section id="content">
          <div data-content-field="main-content">
            <!-- CATEGORY NAV -->
            
            <div id="mainContent">
    

    <div>
        
        <div>
            <div>
                <div>
                    
                      <div>
                        <div data-layout-label="Post Body" data-type="item" data-updated-on="1657726576150" id="item-62cee63246879e6254003dc6"><div><div><div data-block-type="2" id="block-b305edb6cdc2c1243798"><p><em>In this excerpt of a Trend Micro Vulnerability Research Service vulnerability report, Guy Lederfein and Quintin Crist of the Trend Micro Research Team detail a recently patched remote code execution vulnerability in the Microsoft Windows operating system, originally discovered and reported by Yuki Chen. The bug is found in the implementation of Network File System (NFS)and is due to improper handling of NFSv4 requests. An unauthenticated attacker could exploit this bug to execute arbitrary code in the context of SYSTEM. The following is a portion of their write-up covering CVE-2022-30136, with a few minimal modifications.</em></p></div><div data-block-type="2" id="block-yui_3_17_2_1_1657117409650_123351"><div><p>A remote code execution vulnerability exists in Windows Network File System. The vulnerability is due to improper handling of NFSv4 requests.</p><p>A remote attacker can exploit this vulnerability by sending malicious RPC calls to a target server. Successful exploitation results in arbitrary code execution in the context of SYSTEM. Unsuccessful exploitation may result in a crash of the target system.</p><p><strong>The Vulnerability</strong></p><p>Microsoft Windows ships with several network features designed to communicate and interact with non-Windows file shares. One of these modules is called Network File System (NFS). </p><p>NFS is a network file system protocol originally developed by Sun Microsystems in 1984. Version 2 is documented in <a href="https://datatracker.ietf.org/doc/html/rfc1094" target="_blank">RFC 1094</a>. Version 3 is documented in <a href="https://datatracker.ietf.org/doc/html/rfc1813" target="_blank">RFC 1813</a>. Version 4 was developed by the IETF and is documented in <a href="https://datatracker.ietf.org/doc/html/rfc3010" target="_blank">RFC 3010</a> (released December 2000) and revised in <a href="https://datatracker.ietf.org/doc/html/rfc3530" target="_blank">RFC 3530</a> (released April 2003) and <a href="https://datatracker.ietf.org/doc/html/rfc7530" target="_blank">RFC 7530</a> (released March 2015). NFS allows users to access remote file shares in the same way that the local file system is accessed. Different access levels and permissions can be set on the share, such as read-write and read-only. Additionally, IP/UID/GID/Kerberos security can be used. NFS uses Open Network Computing (ONC) Remote Procedure Call (RPC) to exchange control messages. ONC RPC was originally developed by Sun Microsystems and can also be referred to as <a href="https://datatracker.ietf.org/doc/html/rfc5531" target="_blank">Sun RPC</a>.</p><p>When ONC RPC messages are transferred over TCP, they are prepended with a Fragment header structure (as illustrated in the following table) that specifies the length of the message. This allows the receiver to distinguish multiple messages sent over a single TCP session. Other protocols such as UDP do not use this field. Note that all multi-byte values are encoded in big-endian byte order.</p>


</div></div><div data-block-type="2" id="block-yui_3_17_2_1_1657117409650_126094"><p>The structure of ONC RPC request messages, in general, is as follows:</p></div><div data-block-type="2" id="block-yui_3_17_2_1_1657117409650_154459"><p>The <em>Credentials</em> structure in a Sun-RPC message has the following structure:</p></div><div data-block-type="2" id="block-yui_3_17_2_1_1657117409650_155299"><div><p>The <em>Flavor</em> field in the above structure serves as a type identifier of the <em>Contents</em> data. Security flavors have been called authentication flavors for historical reasons. There are multiple security flavors defined in the RPC specification, such as AUTH_NONE(0), AUTH_SYS(1), AUTH_SHORT(2), AUTH_DH(3), and RPCSEC_GSS(6).</p><p>The <em>Contents</em> field for the flavor RPCSEC_GSS has the following structure:</p>


</div></div><div data-block-type="2" id="block-yui_3_17_2_1_1657117409650_156287"><div><p>There are four types such as RPCSEC_GSS_DATA(0), RPCSEC_GSS_INIT(1), RPCSEC_GSS_CONTINUE_INIT(2), and RPCSEC_GSS_DESTROY(3) defined in the <em>GSS Procedure</em> field. Also, in the <em>GSS Service</em> field, there are three types: rpc_gss_svc_none(1), rpc_gss_svc_integrity(2), and rpc_gss_svc_privacy(3). When using RPCSEC_GSS to authenticate the RPC clients, a security context must be created by using RPCSEC_GSS_INIT and RPCSEC_GSS_CONTINUE_INIT RPC messages. First, the RPC client sends an RPCSEC_GSS_INIT message to start the creation of the context. Then, the RPC server decides whether it needs another token for the creation. If so, the server replies with a GSS_S_CONTINUE_NEEDED message, and the client needs to send an RPCSEC_GSS_CONTINUE_INIT message to continue.</p><p>If the <em>GSS Service</em> field is set to 2 (rpc_gss_svc_integrity), the <em>Program-specific data</em> field is prefixed with the following structure:</p>


</div></div><div data-block-type="2" id="block-yui_3_17_2_1_1657117409650_157303"><div><p>If the <em>GSS Service</em> field is set to 3 (rpc_gss_svc_privacy), the <em>Program-specific data</em> field is encrypted.</p><p>When the <em>Program</em> field is set to 100003 (NFS) and the <em>Procedure</em> field is set to 1 (Compound), the <em>Program-specific data</em> field has the following structure:</p>


</div></div><div data-block-type="2" id="block-yui_3_17_2_1_1657117409650_170299"><div><p>A buffer overflow vulnerability exists in the Windows implementation of NFS. The vulnerability is due to incorrect calculation of the size of response messages. The server calls the function <em>Nfs4SvrXdrpGetEncodeOperationResultByteCount()</em> to calculate the size of each opcode response, but it does not include the size of the opcode itself. This results in the size of the response buffer being too small by <em>OP Count</em> * 4 bytes. A corresponding buffer is allocated with <em>OncRpcBufMgrpAllocate</em>. When the response data is written to the buffer, the response data overflows. Due to the function only being used for NFS version 4, only NFS4 is vulnerable.</p><p><em>OncRpcBufMgrpAllocate()</em> will actually allocate the data with either <em>OncRpcBufMgrpAllocateDescriptorFromLLInlineBuffer()</em>, when the request is under 0x800 bytes in size, or <em>OncRpcBufMgrpAllocateDescriptorFromLLLargePoolAllocation()</em>, which is used otherwise. </p><p><em>OncRpcBufMgrpAllocateDescriptorFromLLInlineBuffer()</em> returns a buffer in a static 0x800 bytes inside the descriptor. The descriptor structure has 0x50 bytes of space that appears to be unused after the static buffer.</p><p><em>OncRpcBufMgrpAllocateDescriptorFromLLLargePoolAllocation()</em> returns a buffer allocated with <em>ExAllocatePoolWithTag()</em>. The number of bytes allocated is equal to the following:</p>


</div></div><div data-block-type="2" id="block-yui_3_17_2_1_1657117409650_172676"><div><p>This means that for either buffer type, more than 0x48 bytes must be overflowed to get past the padding in either buffer type. Since the number of overflowed bytes is OP Count * 4, a minimum of 19 operations must be performed in a compound message for the overflow to have any impact.</p><p>An attacker can use this vulnerability to send a crafted request with many operations, producing a large size miscalculation, resulting in a buffer overflow. Successful exploitation results in arbitrary code execution in the context of SYSTEM. Unsuccessful exploitation may result in a crash of the target system.</p><p><strong>Detecting Attacks</strong></p><p>Much of this information is largely seen earlier in this post. It is reposted here for your convenience. </p><p>When ONC RPC messages are transferred over TCP, they are prepended with a Fragment header structure (as illustrated in the following table) that specifies the length of the message. This allows the receiver to distinguish multiple messages sent over a single TCP session. Other protocols such as UDP do not use this field. Note that all multi-byte values are encoded in big-endian byte order.</p>


</div></div><div data-block-type="2" id="block-yui_3_17_2_1_1657117409650_175089"><div><p>The structure of ONC RPC request messages is shown above, as is the <em>Credentials</em> structure in a Sun-RPC message. As shown above, the <em>Flavor</em> field in the above structure serves as a type identifier of the Contents data. Security flavors have been called authentication flavors for historical reasons. There are multiple security flavors defined in the RPC specification, such as AUTH_NONE(0), AUTH_SYS(1), AUTH_SHORT(2), AUTH_DH(3), and RPCSEC_GSS(6).</p><p>As a reminder, the Contents field for the flavor RPCSEC_GSS has the following structure:</p>


</div></div><div data-block-type="2" id="block-yui_3_17_2_1_1657117409650_176121"><div><p>There are four types such as RPCSEC_GSS_DATA(0), RPCSEC_GSS_INIT(1), RPCSEC_GSS_CONTINUE_INIT(2), and RPCSEC_GSS_DESTROY(3) defined in the <em>GSS Procedure</em> field. Also, in the <em>GSS Service</em> field, there are three types: rpc_gss_svc_none(1), rpc_gss_svc_integrity(2), and rpc_gss_svc_privacy(3). When using RPCSEC_GSS to authenticate the RPC clients, a security context must be created by using RPCSEC_GSS_INIT and RPCSEC_GSS_CONTINUE_INIT RPC messages. Firstly, the RPC client sends an RPCSEC_GSS_INIT message to start the creation of the context. Then, the RPC server will decide whether it needs another token for the creation. If so, the server will reply with a GSS_S_CONTINUE_NEEDED message, and the client needs to send an RPCSEC_GSS_CONTINUE_INIT message to continue.</p><p>If the <em>GSS Service</em> field is set to 2 (rpc_gss_svc_integrity), the Program-specific data field is prefixed with the following structure:</p>


</div></div><div data-block-type="2" id="block-yui_3_17_2_1_1657117409650_191987"><div><p>If the <em>GSS Service</em> field is set to 3 (rpc_gss_svc_privacy), the <em>Program-specific data</em> field is encrypted and must be decrypted before continuing.</p><p>The detection device needs to check if the <em>Program</em> field in an RPC request message has the value 100003 (NFS), the <em>Procedure</em> field has the value 1 (COMPOUND), and the <em>Program Version</em> field has the value 4 (NFS4). If found, the device must inspect the <em>Program-specific data</em> in the ONC RPC messages.</p><p>The data format of NFS COMPOUND has the following structure:</p>


</div></div><div data-block-type="2" id="block-yui_3_17_2_1_1657117409650_193106"><div><p>The buffer overflow is only triggered if at least 19 operations are present in the NFS reply. Since the NFS reply has the response for each operation in the NFS request, request messages should be monitored for an OP Count field greater than 18.</p><p>If a packet with greater than 18 operations is detected, the traffic should be considered suspicious; an attack exploiting this vulnerability is likely underway.</p><p>Note that all multi-byte values are expressed in network (big-endian) byte order. Also, this detection method may generate false positives if normal traffic contains similar NFS COMPOUND requests.</p><p><strong>Conclusion</strong></p><p>This bug was patched by Microsoft in June 2022 and assigned CVE-2022-30136. In their write-up, they also list disabling NFSv4.1 as a method to mitigate attacks. However, this could lead to a loss of functionality. Also, Microsoft notes the update to address this bug should <em>not </em>be applied unless the fix for CVE-2022-26937 is installed. Applying both updates in the appropriate order is the best method to fully address these vulnerabilities.</p><p>Special thanks to Guy Lederfein and Quintin Crist of the Trend Micro Research Team for providing such a thorough analysis of this vulnerability. For an overview of Trend Micro Research services please visit <a href="http://go.trendmicro.com/tis/">http://go.trendmicro.com/tis/</a>.</p><p>The threat research team will be back with other great vulnerability analysis reports in the future. Until then, follow the ZDI <a href="https://twitter.com/thezdi" target="_blank">team</a> for the latest in exploit techniques and security patches.</p>


</div></div></div></div></div>
                      </div>

                       
                        <ul>
                          
                            <!--TAGS-->
                            
                              <li><a href="https://blog.jfo.click/blog?tag=NFS">NFS</a></li>
                            
                              <li><a href="https://blog.jfo.click/blog?tag=Microsoft">Microsoft</a></li>
                            
                              <li><a href="https://blog.jfo.click/blog?tag=Research">Research</a>
                          
                        </li></ul>
                      
                   
                    
                </div>
                
            </div><!-- /. contentBlock -->
        </div>

        
    </div><!-- /. blog-listing -->
</div>
          </div>
        </section>

        
        
        

        

        <!--FOOTER WITH OPEN BLOCK FIELD-->
        

        

    <!--INJECTION POINT FOR TRACKING SCRIPTS AND USER CONTENT FROM THE CODE INJECTION TAB-->

    
    </div> <!-- end #innerWrapper -->
    </div></div>
  </body>
</html>
