<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/kign/c4wa">Original</a>
    <h1>c4wa â€“ C compiler for Web Assembly</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text"><div dir="auto"><a id="user-content-c-compiler-for-web-assembly-c4wa" aria-label="Permalink: C compiler for Web Assembly (c4wa)" href="#c-compiler-for-web-assembly-c4wa"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This is a compiler from a <em>subset</em> of C language to Web Assembly.</p>
<p dir="auto">If you&#39;re not familiar with Web Assembly, check out <a href="https://en.wikipedia.org/wiki/WebAssembly" rel="nofollow">Wikipedia article</a>.
Web Assembly is a new universal executable format for the Web; it complements more traditional JavaScript
for computationally intensive tasks or if there is a need to port to Web existing code written in other languages.
Binary Web Assembly files have extension <code>.wasm</code>; throughout this document, <em>WASM</em> is used both as the name
for binary Web Assembly format and as a shortcut for <em>Web Assembly</em>.</p>
<p dir="auto">There are many compilers targeting Web Assembly; see for example a comprehensive list
<a href="https://github.com/appcypher/awesome-wasm-langs">here</a>. Why do we need another one?</p>
<p dir="auto">Here are some unique features of <code>c4wa</code> :</p>
<ul dir="auto">
<li>It creates minimalistic well-optimized Web Assembly output without any &#34;glue&#34; to make it
work with your application, without any embedded libraries, or any other overhead. This is simply
C code translated as efficiently as possible to WASM; nothing more</li>
<li>It is out of the box fully compatible with any WASM runtime; there are no dependencies on JavaScript or <code>node</code></li>
<li>It can efficiently utilize WASM linear memory model, making it possible to write applications
with full dynamic memory allocation support and still only minimal overhead</li>
<li>In addition to binary WASM format, it can output text-based
<a href="https://developer.mozilla.org/en-US/docs/WebAssembly/Understanding_the_text_format" rel="nofollow">WAT format</a>,
which is entirely readable, properly formatted and could be used for better understanding
inner workings of the compiler, edited manually, copied to separate WASM projects, or used for teaching/learning
Web Assembly and WAT format</li>
</ul>
<p dir="auto"><code>c4wa</code> is not a full C implementation and isn&#39;t trying to be one. Still, most of the typical day-to-day coding
targeting <code>c4wa</code> isn&#39;t much more complicated than coding in standard C.
It supports loops, conditionals, block scope of variables, intermingled declarations, all of C operators and primitive types, <code>struct</code>s,
arrays, pointers, variable arguments and dynamic memory
allocation. It can also apply external C preprocessor to your code before parsing.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Motivation</h2><a id="user-content-motivation" aria-label="Permalink: Motivation" href="#motivation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">There are <a href="https://github.com/appcypher/awesome-wasm-langs">many existing compilers</a>
from various programming languages to Web Assembly, including popular
<a href="https://github.com/emscripten-core/emscripten"><code>emscripten</code></a> for compiling C code. They typically treat
Web Assembly as a target not too different from a machine-level assembly; their main advantage is
full support of the underlying language (so you can compile your existing code base with few, if any, changes),
but in the process they often create bloated, unnecessary, and poorly fitting Web Assembly design code.</p>
<p dir="auto">You may, of course, not care, as long as at the end it&#39;s working as expected. Some people who do care
choose to write relatively simple fragments of Web Assembly in WAT (text-based) format. To make it clear,
WAT format is more than just Web Assembly instructions written as text; it supports S-expressions and
some other syntax sugar to make coding easier (See
excellent <a href="https://developer.mozilla.org/en-US/docs/WebAssembly/Understanding_the_text_format" rel="nofollow">introduction</a>
to WAT format at MDN.) Still, you are required to write each and every Web Assembly instructions manually,
so a simple assignment like this: <code>c = a*a + b*b + 1</code> might look like that:</p>
<div dir="auto" data-snippet-clipboard-copy-content="(set_local $c (i32.add (i32.add (i32.mul (get_local $a) (get_local $a)) 
                    (i32.mul (get_local $b) (get_local $b))) (i32.const 1)))"><pre>(<span>set_local</span> <span>$c</span> (<span>i32.add</span> (<span>i32.add</span> (<span>i32.mul</span> (<span>get_local</span> <span>$a</span>) (<span>get_local</span> <span>$a</span>)) 
                    (<span>i32.mul</span> (<span>get_local</span> <span>$b</span>) (<span>get_local</span> <span>$b</span>))) (<span>i32.const</span> <span>1</span>)))</pre></div>
<p dir="auto"><code>c4wa</code> purports to be a middle ground between these two extremes. It allows you to write your code in a
relatively higher-level language (a subset of <code>C</code>) while retaining a close relation to an underlying
Web Assembly. In addition to a binary WASM file, it can generate a well-formatted WAT output
which will be similar to what a human programmer would have written when solving the problem directly in WAT.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Dependencies</h2><a id="user-content-dependencies" aria-label="Permalink: Dependencies" href="#dependencies"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><code>c4wa</code> needs Java 11 or above. Using preprocessor requires external C compiler (<code>gcc</code> is recommended).</p>
<p dir="auto">While testing tools and examples described below assume POSIX-based environment, compiler itself
should work on any platform with Java installed. Generated WASM files are, of course, platform-independent.
(WAT files will be created in a default text format for your platform).</p>
<p dir="auto">In order to run Web Assembly, you need a <em>runtime</em>. Easiest runtime to use is <code>node</code>; there are also
universal runtimes such as <a href="https://wasmtime.dev/" rel="nofollow">wasmtime</a> and <a href="https://wasmer.io/" rel="nofollow">wasmer</a> with bindings
for many languages. Any modern browser will also have a Web Assembly runtime built-in, though it is
a bit more complicated since you&#39;d also need a local server to run your code.</p>
<p dir="auto"><code>cw4a</code> is entirely runtime-agnostic, though its testing framework is built on top of <code>node</code>.</p>
<p dir="auto">Finally, if you are working with Web Assembly, you probably should have
<a href="https://github.com/WebAssembly/wabt">WebAssembly Binary Toolkit</a> handy;
it allows you to compile WAT files, verify a WASM file, dump its content by sections, and a lot more.
However, <code>c4wa</code> doesn&#39;t have a dependency on any of the WABT tools.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Installation</h2><a id="user-content-installation" aria-label="Permalink: Installation" href="#installation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Download the latest release from <a href="https://github.com/kign/c4wa/releases/">here</a>; unzip to any directory
and use shell wrapper <code>c4wa-compile</code> (<code>c4wa-compile.bat</code> on Windows). For example,</p>
<div dir="auto" data-snippet-clipboard-copy-content="mkdir -p ~/Apps
cd ~/Apps
wget https://github.com/kign/c4wa/releases/download/v0.5/c4wa-compile-0.5.zip
unzip c4wa-compile-0.5.zip
cd
PATH=~/Apps/c4wa-compile-0.5/bin:$PATH
c4wa-compile --help"><pre>mkdir -p <span>~</span>/Apps
<span>cd</span> <span>~</span>/Apps
wget https://github.com/kign/c4wa/releases/download/v0.5/c4wa-compile-0.5.zip
unzip c4wa-compile-0.5.zip
<span>cd</span>
PATH=<span>~</span>/Apps/c4wa-compile-0.5/bin:<span>$PATH</span>
c4wa-compile --help</pre></div>
<div dir="auto"><h2 tabindex="-1" dir="auto">Usage</h2><a id="user-content-usage" aria-label="Permalink: Usage" href="#usage"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Let&#39;s say we want to check <a href="https://en.wikipedia.org/wiki/Collatz_conjecture" rel="nofollow">Collatz conjecture</a> for a
given integer number <em>N</em>.</p>
<p dir="auto">We start from this C code, which we save to file <code>collatz.c</code> :</p>
<div dir="auto" data-snippet-clipboard-copy-content="extern int collatz(int N) {
    int len = 0;
    unsigned long n = N;
    do {
        if (n == 1)
            break;
        if (n % 2 == 0)
            n /= 2;
        else
            n = 3 * n + 1;
        len ++;
    }
    while(1);
    return len;
}"><pre><span>extern</span> <span>int</span> <span>collatz</span>(<span>int</span> <span>N</span>) {
    <span>int</span> <span>len</span> <span>=</span> <span>0</span>;
    <span>unsigned long</span> <span>n</span> <span>=</span> <span>N</span>;
    <span>do</span> {
        <span>if</span> (<span>n</span> <span>==</span> <span>1</span>)
            <span>break</span>;
        <span>if</span> (<span>n</span> % <span>2</span> <span>==</span> <span>0</span>)
            <span>n</span> /= <span>2</span>;
        <span>else</span>
            <span>n</span> <span>=</span> <span>3</span> <span>*</span> <span>n</span> <span>+</span> <span>1</span>;
        <span>len</span> <span>++</span>;
    }
    <span>while</span>(<span>1</span>);
    <span>return</span> <span>len</span>;
}</pre></div>
<p dir="auto">Use <code>c4wa-compile</code> to compile:</p>
<div dir="auto" data-snippet-clipboard-copy-content="c4wa-compile -Xmodule.memoryStatus=none collatz.c"><pre>c4wa-compile -Xmodule.memoryStatus=none collatz.c</pre></div>
<p dir="auto">Write this simple <code>node</code>-based wrapper (save it as file <code>collatz.js</code>)</p>
<div dir="auto" data-snippet-clipboard-copy-content="const fs = require(&#39;fs&#39;);
const wasm_bytes = new Uint8Array(fs.readFileSync(&#39;collatz.wasm&#39;));
const n = parseInt(process.argv[2]);
WebAssembly.instantiate(wasm_bytes).then(wasm =&gt;
    console.log(&#34;Cycle length of&#34;, n, &#34;is&#34;, wasm.instance.exports.collatz (n)))"><pre><span>const</span> <span>fs</span> <span>=</span> <span>require</span><span>(</span><span>&#39;fs&#39;</span><span>)</span><span>;</span>
<span>const</span> <span>wasm_bytes</span> <span>=</span> <span>new</span> <span>Uint8Array</span><span>(</span><span>fs</span><span>.</span><span>readFileSync</span><span>(</span><span>&#39;collatz.wasm&#39;</span><span>)</span><span>)</span><span>;</span>
<span>const</span> <span>n</span> <span>=</span> <span>parseInt</span><span>(</span><span>process</span><span>.</span><span>argv</span><span>[</span><span>2</span><span>]</span><span>)</span><span>;</span>
<span>WebAssembly</span><span>.</span><span>instantiate</span><span>(</span><span>wasm_bytes</span><span>)</span><span>.</span><span>then</span><span>(</span><span>wasm</span> <span>=&gt;</span>
    <span>console</span><span>.</span><span>log</span><span>(</span><span>&#34;Cycle length of&#34;</span><span>,</span> <span>n</span><span>,</span> <span>&#34;is&#34;</span><span>,</span> <span>wasm</span><span>.</span><span>instance</span><span>.</span><span>exports</span><span>.</span><span>collatz</span> <span>(</span><span>n</span><span>)</span><span>)</span><span>)</span></pre></div>
<p dir="auto">Now you can run the code :</p>
<div dir="auto" data-snippet-clipboard-copy-content="node collatz.js 626331
# Output: Cycle length of 626331 is 508"><pre>node collatz.js 626331
<span><span>#</span> Output: Cycle length of 626331 is 508</span></pre></div>
<p dir="auto">Note that generated WASM file <code>collatz.wasm</code> <strong>is only 99 bytes in size</strong>.</p>
<p dir="auto">If you run compiler with option <code>-k</code>, it&#39;ll also save a WAT file, which looks like this:</p>
<div dir="auto" data-snippet-clipboard-copy-content="(module
  (func $collatz (export &#34;collatz&#34;) (param $N i32) (result i32)
    (local $len i32)
    (local $n i64)
    (set_local $n (i64.extend_i32_s (get_local $N)))
    (block $@block_1_break
      (loop $@block_1_continue
        (br_if $@block_1_break (i64.eq (get_local $n) (i64.const 1)))
        (if (i64.eqz (i64.rem_u (get_local $n) (i64.const 2)))
          (then
            (set_local $n (i64.div_u (get_local $n) (i64.const 2))))
          (else
            (set_local $n (i64.add (i64.mul (i64.const 3) (get_local $n)) (i64.const 1)))))
        (set_local $len (i32.add (get_local $len) (i32.const 1)))
        (br $@block_1_continue)))
    (get_local $len)))"><pre>(<span>module</span>
  (<span>func</span> <span>$collatz</span> (<span>export</span> <span><span>&#34;</span>collatz<span>&#34;</span></span>) (<span>param</span> <span>$N</span> <span>i32</span>) (<span>result</span> <span>i32</span>)
    (<span>local</span> <span>$len</span> <span>i32</span>)
    (<span>local</span> <span>$n</span> <span>i64</span>)
    (<span>set_local</span> <span>$n</span> (<span>i64.extend_i32_s</span> (<span>get_local</span> <span>$N</span>)))
    (<span>block</span> <span>$@block_1_break</span>
      (<span>loop</span> <span>$@block_1_continue</span>
        (<span>br_if</span> <span>$@block_1_break</span> (<span>i64.eq</span> (<span>get_local</span> <span>$n</span>) (<span>i64.const</span> <span>1</span>)))
        (<span>if</span> (<span>i64.eqz</span> (<span>i64.rem_u</span> (<span>get_local</span> <span>$n</span>) (<span>i64.const</span> <span>2</span>)))
          (<span>then</span>
            (<span>set_local</span> <span>$n</span> (<span>i64.div_u</span> (<span>get_local</span> <span>$n</span>) (<span>i64.const</span> <span>2</span>))))
          (<span>else</span>
            (<span>set_local</span> <span>$n</span> (<span>i64.add</span> (<span>i64.mul</span> (<span>i64.const</span> <span>3</span>) (<span>get_local</span> <span>$n</span>)) (<span>i64.const</span> <span>1</span>)))))
        (<span>set_local</span> <span>$len</span> (<span>i32.add</span> (<span>get_local</span> <span>$len</span>) (<span>i32.const</span> <span>1</span>)))
        (<span>br</span> <span>$@block_1_continue</span>)))
    (<span>get_local</span> <span>$len</span>)))</pre></div>
<p dir="auto">If you can read Web Assembly instructions, you can see how this corresponds to the
original C code, and it would seem reasonably close to how one might solve this problem directly in WAT.</p>
<p dir="auto">There is nothing whatsoever that forces you to use <code>node</code> or JavaScript to execute WASM files.
There are many universal runtimes with bindings available for many languages. For example,
using <a href="https://wasmer.io/" rel="nofollow">wasmer</a>, you can run <code>collatz.wasm</code> in python with this simple
script:</p>
<div dir="auto" data-snippet-clipboard-copy-content="import sys
from wasmer import engine, Store, Module, Instance
from wasmer_compiler_llvm import Compiler

store = Store(engine.Native(Compiler))
module = Module(store, open(&#39;collatz.wasm&#39;, &#39;rb&#39;).read())
instance = Instance(module)

n = int(sys.argv[1]);
print(&#34;Cycle length of&#34;, n, &#34;is&#34;, instance.exports.collatz(n))"><pre><span>import</span> <span>sys</span>
<span>from</span> <span>wasmer</span> <span>import</span> <span>engine</span>, <span>Store</span>, <span>Module</span>, <span>Instance</span>
<span>from</span> <span>wasmer_compiler_llvm</span> <span>import</span> <span>Compiler</span>

<span>store</span> <span>=</span> <span>Store</span>(<span>engine</span>.<span>Native</span>(<span>Compiler</span>))
<span>module</span> <span>=</span> <span>Module</span>(<span>store</span>, <span>open</span>(<span>&#39;collatz.wasm&#39;</span>, <span>&#39;rb&#39;</span>).<span>read</span>())
<span>instance</span> <span>=</span> <span>Instance</span>(<span>module</span>)

<span>n</span> <span>=</span> <span>int</span>(<span>sys</span>.<span>argv</span>[<span>1</span>]);
<span>print</span>(<span>&#34;Cycle length of&#34;</span>, <span>n</span>, <span>&#34;is&#34;</span>, <span>instance</span>.<span>exports</span>.<span>collatz</span>(<span>n</span>))</pre></div>
<p dir="auto">Save it as <code>collatz.py</code>, install <code>wasmer</code> bindings and execute:</p>
<div dir="auto" data-snippet-clipboard-copy-content="python3 -m pip install --upgrade wasmer wasmer_compiler_llvm
python3 collatz.py 626331
# Cycle length of 626331 is 508"><pre>python3 -m pip install --upgrade wasmer wasmer_compiler_llvm
python3 collatz.py 626331
<span><span>#</span> Cycle length of 626331 is 508</span></pre></div>
<p dir="auto">We also provide two slightly customized wrappers to run WASM files: <code>node</code>-based and <code>python-wasmer</code>-based.
Both will automatically call <code>main</code> function (must be exported) and both will support C-compatible <code>printf</code>.
You can use it with any of the tests in
<a href="https://github.com/kign/c4wa/tree/master/src/test/resources/c">this directory</a>.
For example</p>
<div dir="auto" data-snippet-clipboard-copy-content="c4wa-compile 170-life.c
# both wrappers should make same output 
etc/run-wasm 170-life.wasm
etc/run-wasm.py 170-life.wasm"><pre>c4wa-compile 170-life.c
<span><span>#</span> both wrappers should make same output </span>
etc/run-wasm 170-life.wasm
etc/run-wasm.py 170-life.wasm</pre></div>
<p dir="auto">See <a href="https://github.com/kign/c4wa/blob/master/etc/doc/language.md">Language Spec</a>
for in-depth discussion of implementing <code>printf</code> in WASM environment,
and also the <a href="https://github.com/kign/c4wa/blob/master/etc/wasm-printf.js">source code</a>.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">No standard library</h2><a id="user-content-no-standard-library" aria-label="Permalink: No standard library" href="#no-standard-library"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Web Assembly is an <em>embedded language</em>; it is intended to be executed from a <em>runtime</em> which interprets
Web Assembly instructions, perhaps compiles them into a native code (either ahead of time or JIT), and
handles all communications with OS, execution environment and the user. It could also optionally provide Web
Assembly with access to some library functions, via <em>import</em> functionality.</p>
<p dir="auto">From that standpoint, integrating any kind of standard library with <code>c4wa</code> compiler isn&#39;t practical. To the extent
Web Assembly code might need access to some library utilities (mathematical utilities such as <code>atan2</code>, for example),
it is almost always better to simply import them from the runtime, and most of the time, there isn&#39;t any other choice
anyway, since all communication with the environment is done through the runtime. For example, in order to
read from or write to files in Web Assembly, one needs to import from runtime something
resembling <code>fopen</code> function (and of course some runtimes, such as browser, won&#39;t support this).</p>
<p dir="auto">The only exceptions could be methods either already embedded into Web Assembly specification
(such as <code>sqrt</code> or <code>memcpy</code>) or dealing with dynamic memory allocations (<code>malloc</code> and <code>free</code>), and
perhaps also some common utilities to work with memory and with strings.</p>
<p dir="auto">Accordingly, <code>c4wa</code> compiler exposes all methods already available in Web Assembly as <em>built-in functions</em>
and gives a choice of memory managers with number of <em>built-in libraries</em>, and that&#39;s about it.
More details are in the <a href="https://github.com/kign/c4wa/blob/master/etc/doc/language.md">Language Spec</a>.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Examples</h2><a id="user-content-examples" aria-label="Permalink: Examples" href="#examples"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Test suite</h3><a id="user-content-test-suite" aria-label="Permalink: Test suite" href="#test-suite"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">There is large (and growing) set of tests, from trivial to rather complicated, in
<a href="https://github.com/kign/c4wa/tree/master/src/test/resources/c">this directory</a>.
For each of these files, you can find generated WAT code <a href="https://github.com/kign/c4wa/tree/master/tests/wat">here</a>.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Sample Web Application</h3><a id="user-content-sample-web-application" aria-label="Permalink: Sample Web Application" href="#sample-web-application"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Using compiled WASM file in a Web page is a bit more complicated than simply loading it into <code>node.js</code>.</p>
<ul dir="auto">
<li>For security reasons, browsers can&#39;t load WASM from local files (<code>file:///</code> protocol);
you need a local web server to run it.</li>
<li>You need <code>npm</code> module <a href="https://browserify.org/" rel="nofollow">browserify</a> to use any node-targeted code in Web
(e.g. <a href="https://github.com/kign/c4wa/blob/master/etc/wasm-printf.js">printf</a>).</li>
</ul>
<p dir="auto">There is a sample project in <a href="https://github.com/kign/c4wa/blob/master/etc/sample_web">this directory</a>
which illustrates how it could be done. Among other features, it also redirects <code>printf</code> calls made from C source
to HTML <code>&lt;textarea&gt;</code> element.</p>
<p dir="auto">To try it, simply run <code>./init.bash</code> from that directory (it&#39;ll check prerequisites,
install required npm modules, compile the source and load in browser);</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Game of life</h3><a id="user-content-game-of-life" aria-label="Permalink: Game of life" href="#game-of-life"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Previously, I had a native WAT implementation for Conway&#39;s game of life (on a final toroidal board);
later I used original implementation in C and compiled with <code>c4wa</code>.</p>
<ul dir="auto">
<li><a href="https://github.com/kign/life/blob/master/lib/lifestep.c">Original implementation in C</a></li>
<li><a href="https://github.com/kign/life/blob/master/wasm/life.wat">Original and independent implementation in WAT</a></li>
<li><a href="https://github.com/kign/life/blob/master/wasm/life-wasm.c">C source adapted for <code>c4wa</code></a> (note: this was based on release 0.1 of the compiler, stack variables were not yet available)</li>
<li><a href="https://github.com/kign/life/blob/master/wasm/life-wasm.wat">WAT compiled from the above C source</a></li>
</ul>
<p dir="auto"><strong>Conclusions</strong>:</p>
<ul dir="auto">
<li>Only minimal changes to the code were necessary for make it compatible with <code>c4wa</code> (and some of these changes wouldn&#39;t be necessary in version 0.2);</li>
<li><code>c4wa</code> compiler yields comparable though a bit larger WASM file (1415 bytes vs 1187);</li>
<li>Performance of <code>c4wa</code>-generated implementation is pretty much same as the original implementation directly in WAT,
except for <code>wasmer</code> runtime, where it is significantly better.</li>
</ul>
<div dir="auto"><h3 tabindex="-1" dir="auto">Game of Life: infinite board</h3><a id="user-content-game-of-life-infinite-board" aria-label="Permalink: Game of Life: infinite board" href="#game-of-life-infinite-board"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a href="https://github.com/kign/life-inf">https://github.com/kign/life-inf</a></p>
<p dir="auto">Unlike previous example, this Web Application was designed with <code>c4wa</code> in mind. It uses a scalable
implementation which can support a board of almost any dimensions. Board/Game algorithms are written in C,
and generated Web Assembly file (production version) is about 6Kb. You can also take a look at
<a href="https://github.com/kign/life-inf/blob/master/etc/bundle.wat">corresponding WAT file</a>.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Documentation</h2><a id="user-content-documentation" aria-label="Permalink: Documentation" href="#documentation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ul dir="auto">
<li><a href="https://github.com/kign/c4wa/blob/master/etc/doc/comparison.md">Comparison with <code>emscripten</code> and other compilers</a></li>
<li><a href="https://github.com/kign/c4wa/blob/master/etc/doc/language.md">Language Spec</a></li>
<li><a href="https://github.com/kign/c4wa/blob/master/etc/doc/properties.md">Compiler configuration options</a></li>
</ul>
<div dir="auto"><h2 tabindex="-1" dir="auto">Development and testing</h2><a id="user-content-development-and-testing" aria-label="Permalink: Development and testing" href="#development-and-testing"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">To run tests, execute</p>
<div dir="auto" data-snippet-clipboard-copy-content="./gradlew test
etc/run-tests all"><pre>./gradlew <span>test</span>
etc/run-tests all</pre></div>
<p dir="auto">First command will run all units tests; <strong>this only verifies successful compilation, not correctness of generated code</strong>.
node.js-based script <code>run-tests</code> will then run <code>wat2wasm</code> on every created WAT file and will verify that
generated WASM would run and print expected output (saved as commented out section in every source file).
It will also cross-compile with native C and check that output is exactly the same.
Finally, it will compare binary WASM file generated by <code>wat2wasm</code> and one made directly by <code>c4wa</code>.</p>
<p dir="auto">Due to this multistage process C Source =&gt; WAT =&gt; WASM =&gt; execute, there could be three types of changes you are
making:</p>
<ol dir="auto">
<li>Changes which are NOT expected to update any of the existing WAT files. For example, you could
be optimizing or cleaning the code, or implementing a new language feature;</li>
<li>Changes which are expected to propagate to (some) WAT files, but not actually change generated WASM.
This is relatively rare, but for example you may be changing variable naming or formatting;
You&#39;ll see updates in WAT, but none of that has any impact on the output of <code>wat2wasm</code>;</li>
<li>Finally, your changes could be expected to actually change (hopefully, improve or optimize) generated WASM code.</li>
</ol>
<p dir="auto">After running <code>./gradlew test</code> you should look at updated WAT files in
<code>tests/wat</code> <a href="https://github.com/kign/c4wa/tree/master/tests/wat">directory</a> whether anything changed unexpectedly.
If not (and wasn&#39;t expected to, case 1 above), there isn&#39;t anything else to test.</p>
<p dir="auto">If there <em>are</em> changes, you should first compare new versions of updated WAT files to approve the changes.
If changed are as expected, <em>then</em> you could run <code>etc/run-tests all</code>. It&#39;ll do two things for you:</p>
<ul dir="auto">
<li>Run all WAT files through <code>wat2wam</code> to create WASM files in
<code>tests/wasm</code> <a href="https://github.com/kign/c4wa/tree/master/tests/wasm">directory</a>;</li>
<li>Load these WASM files in <code>node.js</code> and execute function <code>main</code> in each one of them.</li>
</ul>
<p dir="auto">If you are making changes of type 2, at this point you need to make sure WASM files haven&#39;t changed and
if they indeed haven&#39;t, you are all set. If they did change, and were expected to, you need to pay attention
to the report generated by <code>run-tests</code> to make sure all tests actually passed runtime execution.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Error testing</h3><a id="user-content-error-testing" aria-label="Permalink: Error testing" href="#error-testing"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Since release 0.4 of the compiler, there are separate <em>error tests</em>
(see <a href="https://github.com/kign/c4wa/tree/master/src/test/resources/errors">here</a>)
consisting of parsable but invalid C code.
<code>./gradlew test</code> will verify that each of them will generate expected number of errors and warnings.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Built-in interpreter</h3><a id="user-content-built-in-interpreter" aria-label="Permalink: Built-in interpreter" href="#built-in-interpreter"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Since release 0.5, compiler includes a built-in Web Assembly interpreter (invoked with <code>-e</code>).
Similarly to <code>run-wasm</code> and <code>run-wasm.py</code> wrappers, it calls <code>main()</code> with no arguments and
supports <code>printf</code> import. Unlike these wrappers however, it&#39;s not a complete implementation,
and also very inefficient relative to any WASM runtime
(which makes it necessary to disable it for some tests in the test suite which would otherwise take too long).
It is however helpful for some run-time verification (such as alignment hints).</p>
</article></div></div>
  </body>
</html>
