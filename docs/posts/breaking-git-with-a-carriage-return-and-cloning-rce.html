<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dgl.cx/2025/07/git-clone-submodule-cve-2025-48384">Original</a>
    <h1>Breaking Git with a carriage return and cloning RCE</h1>
    
    <div id="readability-page-1" class="page"><div>
          
<p><em>tl;dr:</em> On Unix-like platforms, if you use <code>git clone --recursive</code> on an
untrusted repo, it could achieve remote code execution. Update to a <a href="https://github.blog/open-source/git/git-security-vulnerabilities-announced-6/">fixed
version</a>
of Git and other software that embeds Git (including GitHub Desktop).</p>
<p>If you&#39;ve ever used an old mechanical typewriter, you know that when you get to
the end of the line there&#39;s a physical action to to get back to the start of
the line. Sometimes this was done through an actual lever on the typewriter,
later models had a button. Because this action — the <a href="https://en.wikipedia.org/wiki/Carriage_return">carriage
return</a> — was distinct from the
line feed, it has its own character. In ASCII this is the character known as
&#34;Carriage Return&#34;, represented as &#34;␍&#34;, character number 13. The &#34;↵&#34; icon, as
often seen on the &#34;Enter&#34; or &#34;Return&#34; key on a modern keyboard encodes this
action, along with the action of moving to the next line, known as &#34;Line Feed&#34;
(␊).</p>
<div>
  <div>
    <p><img src="https://dgl.cx/2025/07/olympia-sm9.jpg"/></p></div>
</div>
<p>This legacy from the very early days of communications (carriage return was
introduced by the <a href="https://en.wikipedia.org/wiki/Baudot_code#Murray_code">Murray
code</a> in 1901!) is still
something we have to deal with. Unix attempted to simplify this by using just
LF (a &#34;\n&#34; in C-string terms) to separate lines, but Windows and various
Internet protocols use both CR+LF (a &#34;\r\n&#34; in C-string terms).</p>
<p>Why am I talking about <em>this</em>?</p>
<p>git has a simple .ini style configuration format, that looks like this:</p>
<pre><code>[section]
         key = value
</code></pre>
<p>If this was just used in the user’s configuration files there wouldn’t be a
concern about the formats that are accepted. However this configuration format
is also used in the <code>.gitmodules</code> file, which is a file that is checked into
the git repository that tracks submodules.</p>
<p>The format supports DOS line endings. It handles this in the fairly obvious way
of stripping them when it reads lines, below is the function get_next_char in
config.c:</p>
<pre><code>static int get_next_char(struct config_source *cs)
{
        int c = cs-&gt;do_fgetc(cs);

        if (c == &#39;\r&#39;) {
                /* DOS like systems */
                c = cs-&gt;do_fgetc(cs);
                if (c != &#39;\n&#39;) {
                        if (c != EOF)
                                cs-&gt;do_ungetc(c, cs);
                        c = &#39;\r&#39;;
                }
        }

</code></pre>
<p>The <code>cs-&gt;do_fgetc</code> call is nearly equivalent to the standard C function
<code>fgetc()</code>, so even without knowledge of git&#39;s particular functions this is
quite understandable.</p>
<p>It boils down to: If the character is a carriage return (<code>\r</code>), then look at
the next character, if it is a line feed (<code>\n</code>), just return a line feed (and
eat the carriage return). If however the next character isn’t a line feed,
return a carriage return (<code>\r</code>) and put the next character back (<code>ungetc</code>), so
it is returned next time.</p>
<p>The key thing to understand here is that this is done per line. So if for some
reason a line happens to end with a CR, it will be stripped, regardless of the
overall format of the file.</p>
<p>In addition to the code to read the configuration, git can also write
configuration files, for example when the user uses <code>git config</code> to set a
configuration value, it will use the code below to write <code>key = value</code> pairs
out to the file.</p>
<pre><code>static ssize_t write_pair(int fd, const char *key, const char *value, [...]
{
       [...]

       /*
         * Check to see if the value needs to be surrounded with a dq pair.
         * Note that problematic characters are always backslash-quoted; this
         * check is about not losing leading or trailing SP and strings that
         * follow beginning-of-comment characters (i.e. &#39;;&#39; and &#39;#&#39;) by the
         * configuration parser.
         */
        if (value[0] == &#39; &#39;)
                quote = &#34;\&#34;&#34;;
        for (i = 0; value[i]; i++)
                if (value[i] == &#39;;&#39; || value[i] == &#39;#&#39;)
                        quote = &#34;\&#34;&#34;;
        if (i &amp;&amp; value[i - 1] == &#39; &#39;)
                quote = &#34;\&#34;&#34;;

        strbuf_addf(&amp;sb, &#34;\t%s = %s&#34;, key + store-&gt;baselen + 1, quote);
</code></pre>
<p>The actual bug is in the interaction of the above get_next_char function with
this code. Elsewhere in the configuration reading code git supports quoted
strings, using double quotes. However, when it writes a value back out to the
configuration file, it will quote it only if it contains spaces in certain
positions, or a <code>;</code> or <code>#</code> anywhere. This means when it later reads the value
<code>write_pair</code> wrote to the configuration file back, it can be tricked to drop a
final <code>\r</code> off the value.</p>
<p>So, if we have a file with <code>key = &#34;foo^M&#34;</code>, when it&#39;s written out again it
becomes <code>key = foo^M</code> (where <code>^M</code> is the literal CR character).</p>
<p>As I alluded to already, <code>.gitmodules</code> is untrusted, so if we can confuse the
config parser, maybe that’s enough to confuse the code that handles submodules
within git?</p>
<p>On Unix based systems (not Windows), it is possible to have control characters
in filenames, so a path entry like the following in <code>.gitmodules</code> will attempt
to check out the module into a directory named with a control character in its
name.</p>
<pre><code>[submodule &#34;foo&#34;]
  path = &#34;foo^M&#34;
</code></pre>
<p>However when this is written out by git’s configuration code to
<code>.git/modules/foo/config</code>, it will look something like this:</p>
<pre><code>[core]
  workdir = ../../../foo^M
</code></pre>
<p>The validation has already happened against the untrusted path that was read
from <code>.gitmodules</code>. This means the path then essentially changes after
validation because when it is read, the config reading code strips off the
final <code>\r</code>.</p>
<p>The result of all this, is when a submodule clone is performed, it might read one
location from <code>path = ...</code>, but write out a different path that doesn’t end
with the <code>^M</code>.</p>
<p>This simple primitive is enough to confuse git, such that when it checks out a
submodule the contents of it will be written to a different path. This is very
similar to
<a href="https://github.com/git/git/security/advisories/GHSA-8h77-4q3w-gfgv">CVE-2024-32002</a>
where case-insensitivity (or lack of) in submodules could be used to confuse
git. Ironically, that bug required a case-insensitive file system, this one
requires a file system that allows control characters in filenames, therefore
Windows is not directly vulnerable to this particular bug (and macOS is
vulnerable to both CVE-2024-32002 and CVE-2025-48384).</p>
<p>When cloning on the command line, <code>git clone</code> on its own is not enough to clone
submodules, so a manual mitigation for this is to use <code>git clone</code> without
<code>--recursive</code> first, examine <code>.gitmodules</code> to check it is safe and then init
the submodules.</p>
<p>However GitHub Desktop automatically clones with the recursive option by
default, so if you use GitHub Desktop to clone, this can happen:</p>

<div data-file="github-desktop-cve.mp4" onclick="if (!this.querySelector(&#34;video&#34;)) this.innerHTML = `&lt;video controls autoplay&gt;&lt;source src=&#34;${this.dataset.file}&#34; type=&#34;video/mp4&#34;&gt;&lt;/video&gt;`;">
  <p><img src="https://dgl.cx/2025/07/vid-github-desktop-cve.jpg"/></p><p>GitHub Desktop Demo</p>
  <p>▶️
    
  </p>
</div>
<p>The
<a href="https://github.com/git/git/commit/05e9cd64ee23bbadcea6bcffd6660ed02b8eab89">patch</a>
for this is surprisingly simple, ensure that in <code>write_pair</code>, when writing a
string with a carriage return in it, it is quoted. (Technically only the last
character needs quoting, but it is safer to always quote.)</p>
<pre><code> 	for (i = 0; value[i]; i++)
-		if (value[i] == &#39;;&#39; || value[i] == &#39;#&#39;)
+		if (value[i] == &#39;;&#39; || value[i] == &#39;#&#39; || value[i] == &#39;\r&#39;)
 			quote = &#34;\&#34;&#34;;
</code></pre>
<p>The confused write primitive can be used to put malicious files from a
submodule in nearly any location on the filesystem and achieve arbitrary file
write (as it has bypassed validation it can follow symlinks outside the
repository). The most straightforward way to exploit this is to use it to write
inside the <code>.git</code> directory and create a <a href="https://git-scm.com/book/ms/v2/Customizing-Git-Git-Hooks">hook
script</a>, leading to
attacker controlled code execution when the hook is run by Git, however there
are other possibilities such as overwriting <code>.git/config</code>. I&#39;m not sharing a
PoC yet, but it is an almost trivial modification of an exploit for
CVE-2024-32002. There is also a <a href="https://github.com/git/git/commit/05e9cd64ee23bbadcea6bcffd6660ed02b8eab89#diff-8fbc2654131392c3018ecfc92462057b3bdc675cc674084c248bb0393a46b59f">test in the
commit</a>
fixing it that should give large hints.</p>
<p>This is not the first time the carriage return has caused issues for Git, in
January <a href="https://flatt.tech/research/posts/clone2leak-your-git-credentials-belong-to-us/">RyotaK found
issues</a>
with the credential helper protocol that could also be tricked with carriage
returns. It is also not the first time issues have been found with the
configuration parsing, in 2023 there was <a href="https://blog.ethiack.com/blog/git-arbitrary-configuration-injection-cve-2023-29007">a logic error found by André Baptista
and Vítor
Pinho</a>.</p>
<p>I find this particularly interesting because this isn&#39;t fundamentally a problem
of the software being written in C. These are logic errors that are possible in
nearly all languages, the common factor being this is a vulnerability in the
interprocess communication of the components (either between git and external
processes, or within the components of git itself). It is possible to draw a
parallel with CRLF injection as <a href="https://portswigger.net/web-security/request-smuggling">seen in
HTTP</a> (or even <a href="https://smtpsmuggling.com/">SMTP
smuggling</a>). For a long time the Internet worked on
Postel&#39;s <a href="https://en.wikipedia.org/wiki/Robustness_principle">robustness principle</a>:</p>
<pre><code>Be conservative in what you do, be liberal in what you accept from others
</code></pre>
<p>However that may not be the most sensible advice now. This is covered in more
detail than I can put here in <a href="https://www.rfc-editor.org/rfc/rfc9413.html">RFC
9413</a>.</p>
<p>This was found as part of an audit of Git and there are
<a href="https://github.com/git/git/compare/d61cfed2c23705fbeb9c0d08f59e75ee08738950...35cb1bb0b92c132249d932c05bbd860d410e12d4">several</a>
<a href="https://github.com/git/git/compare/2d22f0cd07c308d7ff25bbf4ec8f1bb53b4bcda7...9de345cb273cc7faaeda279c7e07149d8a15a319">other</a>
bugs I found of varying severity <a href="https://github.blog/open-source/git/git-security-vulnerabilities-announced-6/">fixed in the releases
today</a>.
Thanks to <a href="https://www.gresearch.com/teams/open-source-software/">G-Research Open Source</a> for enabling me to work on this.</p>

        </div></div>
  </body>
</html>
