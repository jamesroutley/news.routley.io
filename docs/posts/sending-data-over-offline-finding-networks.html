<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cc-sw.com/find-my-and-find-hub-network-research/">Original</a>
    <h1>Sending Data over Offline Finding Networks</h1>
    
    <div id="readability-page-1" class="page"><div>
				
<p>The following is a summary of an internal research project conducted by Hudson H. and Andrew G.</p>



<h2><strong>Goals</strong></h2>



<p>The Find My network consists of a billion Apple devices (AirTags, iPhones, AirPods, etc) that communicate using Bluetooth and ultra-wideband, helping each other geolocate lost devices and report them to Apple’s servers.</p>



<p>Google has created the similarly-named but separate Find Hub network. Find Hub also relies on crowd sourced data to determine the location of Android devices.</p>



<p>Given how ubiquitous Apple and Android devices are, it is possible to connect to either of these distributed networks from almost any populated location.</p>



<p>What we set out to learn:</p>



<ul>
<li>How is location reported when the lost device has no connection?</li>



<li>Can you send info back to that lost device?</li>



<li>How strictly do these corporations regulate their network (i.e. stalking alerts, snooping on users’ locations)?</li>
</ul>



<p>Our ultimate questions:</p>



<ul>
<li>Can arbitrary Bluetooth devices use these networks for free geolocation?</li>



<li>Can a secure communication channel for data transmission be established?</li>
</ul>



<hr/>



<h2><a href="#abstract"></a>Abstract</h2>



<p>This project demonstrates arbitrary data transmission using Offline Finding networks. Our custom protocol establishes a unidirectional communication channel that is robust, portable, and secure. It highlights critical differences between Apple’s Find My and Google’s Find Hub networks while exploring how unlicensed 3rd parties can piggyback off both of them. We propose deployment scenarios across a variety of architectures.</p>



<hr/>



<h2><a href="#find-my-protocol"></a>Find My Protocol</h2>



<p>There have been many research papers published since crowdsourced location reports were added to Find My in 2019, so we read them all to aggregate the following understanding of the Offline Finding protocol. This involved understanding what Apple has patched since its creation.</p>



<figure><a href="https://cc-sw.com/wp-content/uploads/2025/08/findmy_workflow.png"><img fetchpriority="high" decoding="async" width="1024" height="670" src="https://cc-sw.com/wp-content/uploads/2025/08/findmy_workflow-1024x670.png" alt="" srcset="https://cc-sw.com/wp-content/uploads/2025/08/findmy_workflow-1024x670.png 1024w, https://cc-sw.com/wp-content/uploads/2025/08/findmy_workflow-300x196.png 300w, https://cc-sw.com/wp-content/uploads/2025/08/findmy_workflow-768x503.png 768w, https://cc-sw.com/wp-content/uploads/2025/08/findmy_workflow.png 1089w" sizes="(max-width: 1024px) 100vw, 1024px"/></a></figure>



<p><a href="https://cc-sw.com/irad/findmy/-/wikis/uploads/737e6118a6b11b3430a48afaa1dcb396/findmy_workflow.png" target="_blank" rel="noreferrer noopener"></a><em> Image of Find My control flow [2]</em></p>



<hr/>







<p><strong>Pairing</strong></p>



<p>Public, Private, and Symmetric keys are generated using Elliptic Curve Cryptography (ECC). These are stored in iCloud keychain, while device stores only symmetric and public key.</p>



<hr/>







<p><strong>Lost</strong></p>



<p>Once an iPhone’s connection is lost or an AirTag moves away from its owner, the device generates a new rolling public key every 24 hours and continually broadcasts that key using Bluetooth Low Energy (BLE).</p>



<p>This is the custom BLE beacon format for a lost Apple device. The 28-byte public key + metadata does not fit within a normal 31-byte BLE payload, so part of the key is stored as the MAC address. The MAC technically must be a random static address, but some research suggests that any beacon type (random static, public, NRPA, or RPA) will be accepted.</p>



<figure><a href="https://cc-sw.com/wp-content/uploads/2025/08/ble_adv_format.png"><img decoding="async" width="1024" height="362" src="https://cc-sw.com/wp-content/uploads/2025/08/ble_adv_format-1024x362.png" alt="" srcset="https://cc-sw.com/wp-content/uploads/2025/08/ble_adv_format-1024x362.png 1024w, https://cc-sw.com/wp-content/uploads/2025/08/ble_adv_format-300x106.png 300w, https://cc-sw.com/wp-content/uploads/2025/08/ble_adv_format-768x272.png 768w, https://cc-sw.com/wp-content/uploads/2025/08/ble_adv_format.png 1371w" sizes="(max-width: 1024px) 100vw, 1024px"/></a></figure>



<p><a href="https://cc-sw.com/irad/findmy/-/wikis/uploads/d8dd99bb9b11cd139d312288005979ce/ble_adv_format.png" target="_blank" rel="noreferrer noopener"></a><em> Image of Find My BLE packet structure [6]</em></p>



<p>Note the status byte: it’s supposed to indicate the battery level and device type, but the user can actually set it to whatever they want.</p>



<hr/>







<p><strong>Finding</strong></p>



<p>When nearby Apple devices (“Finders”) see any BLE beacon in the correct format, they create a packet with their own location, encrypt it, and upload it and the seen key to Apple in the next batch. This is what crowdsourced refers to: you’re getting the location of nearby devices, not the GPS data from your own device. Apple then aggregates them in the Find My app.</p>



<p>This is the structure of the HTTPS body that finders send to Apple’s servers. Note that the relevant parts of the location report (lat, long, and status) are all encrypted. Also included is the SHA256 hash of the seen public key.</p>



<figure><a href="https://cc-sw.com/wp-content/uploads/2025/08/finder_upload_format.png"><img decoding="async" width="1024" height="444" src="https://cc-sw.com/wp-content/uploads/2025/08/finder_upload_format-1024x444.png" alt="" srcset="https://cc-sw.com/wp-content/uploads/2025/08/finder_upload_format-1024x444.png 1024w, https://cc-sw.com/wp-content/uploads/2025/08/finder_upload_format-300x130.png 300w, https://cc-sw.com/wp-content/uploads/2025/08/finder_upload_format-768x333.png 768w, https://cc-sw.com/wp-content/uploads/2025/08/finder_upload_format.png 1264w" sizes="(max-width: 1024px) 100vw, 1024px"/></a></figure>



<p><a href="https://cc-sw.com/irad/findmy/-/wikis/uploads/bdf24de9a0fa79490a9ccd1349416a6d/finder_upload_format.png" target="_blank" rel="noreferrer noopener"></a><em> Image of finder upload format [2]</em></p>



<hr/>







<p><strong>Fetching</strong></p>



<p>A user calculates the public keys that they’d expect the lost device to be transmitting for a given period, queries Apple’s servers for them, and decrypts the resulting location reports. Since the user and device both start from the same symmetric and public key, they can deterministically generate the same rolling keys for a given time period.</p>



<p>Apple’s servers act as a key-value store that allow us to probe for SHA256 hashes (keys) and returns location reports (values) if they exist. Up to 256 keys can be queried in a single HTTPS request, and each key can have up to 20 location reports associated with it. Location reports are stored for 7 days.</p>



<hr/>



<h2><a href="#conclusions"></a>Conclusions</h2>



<h3><a href="#two-way-communication"></a>Two-way Communication</h3>



<p>We were optimistic about sending data back to a lost device through the Find My network as we read about the ability to send commands to an AirTag (like playing sounds or wiping it). This would allow for possible Command and Control (C2) infrastructure.</p>



<p>Upon further reading and experimentation, however, we realized these actions are only sent through a local BLE or UWB connection. The Find My network <strong>does not support bidirectional communication</strong> between a user and their lost device unless the device is nearby. Our project is concerned with remote communication, so we contented ourselves with unidirectional data sending.</p>



<h3><a href="#user-privacy"></a>User Privacy</h3>



<p>We agree with the majority of security researchers: Apple’s network is surprisingly charitable for individual users’ privacy. Apple has very little avenue of selling location data or tracking users.</p>



<p>The location reports are E2E encrypted, and only the private key from the user’s iCloud keychain can decrypt them.</p>



<p>Finders are authenticated as a legit Apple device using a mixture of SEP, CA signatures, a unique identifier, and a Elliptic Curve Digital Signature Algorithm (ECDSA) signature; however, they do not send their Apple ID. Apple cannot extrapolate a user’s position by looking at which finders uploaded their reports.</p>



<h3><a href="#lack-of-authentication"></a>Lack of Authentication</h3>



<p>The most interesting aspect of the Find My network is the fact that lost devices are not authenticated as legitimate Apple devices. Finds will upload location reports for <strong>any BLE beacon that follows the Find My format.</strong></p>



<p>Additionally, any Apple ID can query for any public key hashes (but will only be able to decrypt those for which they have the key).</p>



<h3><a href="#stalking-alerts"></a>Stalking Alerts</h3>



<p>How they work:</p>



<p>Apple’s Unwanted Tracking (UT) alerts show a notification when a suspicious device is detected moving with the user for at least 840 meters and 10 mins. The alert is not triggered immediately: it takes 8 hours during the day, 30 mins at night, and only 10 mins if the user returns to a Significant Location (like home). This suspicious lost device must be an AirTag or AirPod that is separated from its owner and broadcasting rolling public keys.</p>



<p>These alerts rely on the fact that the public key only switches every 24 hours. By tracking duplicate keys seen over time, the user can tell if the same AirTag is following them.</p>



<p>Unfortunately, these alerts fail under several conditions, as discovered by previous work [5]:</p>



<ul>
<li>In the BLE advertisement, any beacon marked as either an Apple Device or Find My Device using the <strong>status byte</strong> will not generate stalking alerts.</li>



<li>A device that continuously cycles through new public keys will look like many new AirTags instead of the same one to nearby devices.</li>
</ul>



<p>We tested both methods by taking our tracker home; we received the following alert while using the basic implementation and never while using either method for avoidance.<br/></p>


<div>
<figure><a href="https://cc-sw.com/wp-content/uploads/2025/08/stalking_alert2.png"><img loading="lazy" decoding="async" width="473" height="1024" src="https://cc-sw.com/wp-content/uploads/2025/08/stalking_alert2-473x1024.png" alt="" srcset="https://cc-sw.com/wp-content/uploads/2025/08/stalking_alert2-473x1024.png 473w, https://cc-sw.com/wp-content/uploads/2025/08/stalking_alert2-139x300.png 139w, https://cc-sw.com/wp-content/uploads/2025/08/stalking_alert2-768x1662.png 768w, https://cc-sw.com/wp-content/uploads/2025/08/stalking_alert2-710x1536.png 710w, https://cc-sw.com/wp-content/uploads/2025/08/stalking_alert2.png 828w" sizes="auto, (max-width: 473px) 100vw, 473px"/></a></figure>
</div>


<h2><a href="#exfiltration"></a>Transmission</h2>



<p>Once we understood the Offline Finding network’s limitations and vulnerabilities, we set out to ensure that existing open-source tools still worked.</p>



<hr/>



<h3><a href="#openhaystack"></a>OpenHaystack</h3>



<p>OpenHaystack [1] is an AirTag spoofing tool made by security researchers who were the first to reverse engineer Apple’s Find My network protocol. Their paper (“Who Can Find My Device?” [2]) is fundamental to creating custom Find My devices.</p>



<p>Using an Ubertooth, we were able to confirm that the static public key was being broadcasted:</p>



<figure><a href="https://cc-sw.com/wp-content/uploads/2025/08/hardcoded_advertisement.png"><img loading="lazy" decoding="async" width="907" height="734" src="https://cc-sw.com/wp-content/uploads/2025/08/hardcoded_advertisement.png" alt="" srcset="https://cc-sw.com/wp-content/uploads/2025/08/hardcoded_advertisement.png 907w, https://cc-sw.com/wp-content/uploads/2025/08/hardcoded_advertisement-300x243.png 300w, https://cc-sw.com/wp-content/uploads/2025/08/hardcoded_advertisement-768x622.png 768w" sizes="auto, (max-width: 907px) 100vw, 907px"/></a></figure>



<p>To fetch the location reports, we upgraded OpenHayStack’s implementation to use the FindMy.py library [4]. It allows us to emulate a MacBook from any device and query for specific keys.</p>



<figure><a href="https://cc-sw.com/wp-content/uploads/2025/08/location_reports.png"><img loading="lazy" decoding="async" width="1024" height="772" src="https://cc-sw.com/wp-content/uploads/2025/08/location_reports-1024x772.png" alt="" srcset="https://cc-sw.com/wp-content/uploads/2025/08/location_reports-1024x772.png 1024w, https://cc-sw.com/wp-content/uploads/2025/08/location_reports-300x226.png 300w, https://cc-sw.com/wp-content/uploads/2025/08/location_reports-768x579.png 768w, https://cc-sw.com/wp-content/uploads/2025/08/location_reports.png 1229w" sizes="auto, (max-width: 1024px) 100vw, 1024px"/></a></figure>



<p>By taking our ESP32 for a walk around the business park, we demonstrated advanced location tracking.</p>



<figure><a href="https://cc-sw.com/wp-content/uploads/2025/08/walk_info.png"><img loading="lazy" decoding="async" width="1017" height="1024" src="https://cc-sw.com/wp-content/uploads/2025/08/walk_info-1017x1024.png" alt="" srcset="https://cc-sw.com/wp-content/uploads/2025/08/walk_info-1017x1024.png 1017w, https://cc-sw.com/wp-content/uploads/2025/08/walk_info-298x300.png 298w, https://cc-sw.com/wp-content/uploads/2025/08/walk_info-150x150.png 150w, https://cc-sw.com/wp-content/uploads/2025/08/walk_info-768x773.png 768w, https://cc-sw.com/wp-content/uploads/2025/08/walk_info-50x50.png 50w, https://cc-sw.com/wp-content/uploads/2025/08/walk_info.png 1088w" sizes="auto, (max-width: 1017px) 100vw, 1017px"/></a></figure>



<hr/>



<h3><a href="#sendmy"></a>SendMy</h3>



<p>Positive Security’s Send My [3] is a POC tool for rudimentary data transmission using the Find My network.</p>



<p>We successfully replicated their results:</p>


<div>
<figure><a href="https://cc-sw.com/wp-content/uploads/2025/08/sendmy.png"><img loading="lazy" decoding="async" width="512" height="401" src="https://cc-sw.com/wp-content/uploads/2025/08/sendmy.png" alt="" srcset="https://cc-sw.com/wp-content/uploads/2025/08/sendmy.png 512w, https://cc-sw.com/wp-content/uploads/2025/08/sendmy-300x235.png 300w" sizes="auto, (max-width: 512px) 100vw, 512px"/></a></figure>
</div>


<p>Limitations:</p>



<ul>
<li>Only 1 bit of data per advertisement.</li>



<li>Limited hardware support (only ESP32).</li>



<li>Requires macbook to fetch location reports.</li>



<li>Very limited data can be sent.</li>



<li>Payload is stored in public key, so protocol is totally unencrypted. Any nearby sniffers could decode message.</li>
</ul>



<hr/>



<h3><a href="#protocol-upgrades"></a>Protocol Upgrades</h3>



<p>With the knowledge that offline data transmission is possible, we began building a robust communication channel. The goal was to create frameworks for the device and client (which interacts with Apple’s servers to fetch location reports) that can <strong>send (and painlessly reconstruct) any data from any Bluetooth device</strong>.</p>



<figure><a href="https://cc-sw.com/wp-content/uploads/2025/08/protocol_flowchart.png"><img loading="lazy" decoding="async" width="1024" height="619" src="https://cc-sw.com/wp-content/uploads/2025/08/protocol_flowchart-1024x619.png" alt="" srcset="https://cc-sw.com/wp-content/uploads/2025/08/protocol_flowchart-1024x619.png 1024w, https://cc-sw.com/wp-content/uploads/2025/08/protocol_flowchart-300x181.png 300w, https://cc-sw.com/wp-content/uploads/2025/08/protocol_flowchart-768x464.png 768w, https://cc-sw.com/wp-content/uploads/2025/08/protocol_flowchart.png 1067w" sizes="auto, (max-width: 1024px) 100vw, 1024px"/></a></figure>



<p>The first step was to store our data payloads in private keys instead of public keys. By converting each payload to a its corresponding ECC public key before broadcasting over BLE, our data becomes cryptographically secure from sniffing. Each new chunk of data (of <em>n</em> bits, where <em>n</em> is the number of bits we encode in each advertisement) is a new private/public key pair. The following schema uses all 28 bytes of each private key while balancing messages per week, message length, future flexibility, and cryptographic security:</p>



<figure><table><thead><tr><th>4 bytes</th><th>2 bytes</th><th>20 bytes</th><th>2 bytes</th></tr></thead><tbody><tr><td>Chunk index</td><td>Message ID</td><td>Device ID</td><td>Data</td></tr><tr><td>Unsigned</td><td>Unsigned</td><td> </td><td> </td></tr><tr><td>Index of bit at which this data chunk starts</td><td>Think port number/ID for each datastream</td><td>Shared secret created while pairing</td><td>Supports variable bit encoding</td></tr></tbody></table></figure>



<p><strong>Tip</strong>: Translation: “At this offset within the stream, message <em>A</em> from device <em>B</em> has bytes <em>x</em>, <em>y</em>”</p>



<p>To fetch a data chunk, our client computes all 2^n possible private keys that could have been broadcasted. Since it knows the device ID, message ID, and current chunk index, only the <em>n</em> bits of data must be brute forced. It finds the corresponding ECC public key, SHA256 hashes them, then queries Apple for all 2^n. Apple tells the client which key it has received location reports for.</p>



<p><strong>Tip</strong>: Translation (assuming 2 bits/key): “At this offset for this message and device, are the bits 00, 01, 10, or 11?”</p>



<p>We quickly realized that how many bits we could send in each key was dependent upon how severely Apple throttles user key lookups. This project did not stress-test Apple’s hospitality, instead electing to typically use 8 bits/key. We faced no difficulty in querying 128,000+ keys (500 chunks * 256 keys/chunk) in the span of a couple minutes.</p>



<p>By using the status byte to store another byte of data, the system achieves <em>n</em> = <strong>16 bits/advertisement</strong> (8 in the private key payload that require brute forcing, and 8 in the status byte for free).</p>



<p>Chunk failures (when none of the 2^n keys return a valid location) are an interesting case. It can mean 3 things:</p>



<ol>
<li>The chunk has not arrived yet. It takes time for the advertisements to be uploaded, which we profile more later. Originally, we would pause and retry every failed chunk several times, hoping to fetch the entire message in one go. While optimizing throughput, we began emphasizing entire message retries over chunk retries. By <strong>caching</strong> found chunks, the client can rapidly update as lost chunks are delivered to Apple. This was a significant step in making our client smarter and more robust.</li>



<li>The chunk is missing. We discuss erasure correction shortly.</li>



<li>The chunk is past the bounds of the message. To detect the end of a message, our simplest idea was the most successful. Once <em>x</em> chunks in a row fail (and we have an unbroken chain of resolved chunks up to this point), we assume that the message has ended. We deliberated sending the message length as metadata so that the client definitively knows when to stop querying, but elected to save time this way.</li>
</ol>



<hr/>



<h3><a href="#synchronization"></a>Synchronization</h3>



<p>Everything we’ve outlined so far relies on the fact that the device and client can deterministically operate on the same message IDs and chunk numbers. Because this method is unidirectional, however, this assumption is problematic. How do we know if our device is sending a message? What if we miss messages because there’s no nearby finders? What if we don’t know when our device started transmitting?</p>



<p>It became apparent that an out-of-band synchronization channel was needed. This would be part of the key space that is set aside for denoting which messages have been sent.</p>



<p>We brainstormed many unsuccessful variations of how all possible 2^16 message IDs could be checked. Placing 1 byte in the key and the other in the status byte was promising, but different status bytes for duplicate keys overwrite each other. The sync packets are the most important chunks, because the client will not know to fetch the rest of the message if it doesn’t see them. For that reason, we wanted a protocol that could be expanded for arbitrary redundancy. We arrived at the following schema which spreads the message ID across 2 layers. The user can chose how many channels/dropboxes (with 2 layers each) they want.</p>



<figure><a href="https://cc-sw.com/wp-content/uploads/2025/08/synchronization_protocol.excalidraw.png"><img loading="lazy" decoding="async" width="970" height="544" src="https://cc-sw.com/wp-content/uploads/2025/08/synchronization_protocol.excalidraw.png" alt="" srcset="https://cc-sw.com/wp-content/uploads/2025/08/synchronization_protocol.excalidraw.png 970w, https://cc-sw.com/wp-content/uploads/2025/08/synchronization_protocol.excalidraw-300x168.png 300w, https://cc-sw.com/wp-content/uploads/2025/08/synchronization_protocol.excalidraw-768x431.png 768w" sizes="auto, (max-width: 970px) 100vw, 970px"/></a></figure>



<p><strong>Device:</strong> before the start of every message (and before successive repeats), transmit the 2 keys seen in the diagram (both with message ID = 0). One has the first byte of the message ID, the other has both.</p>



<ul>
<li>After informing the client about what message it’s about to send, switch to that message’s keyspace and begin transmitting chunks.</li>
</ul>



<p><strong>Tip</strong>: Translation: device is placing a note in a mailbox (or several mailboxes!) that says “I’m about to start sending message x”</p>



<p><strong>Client:</strong> whenever we don’t know what message to retrieve, check the layer 1 channel(s) for any new message indicators. It only has to brute-force 2^8 keys <strong>twice</strong> (1 for each layer) in order to search for possible message ID’s the device could be sending. When it sees a message ID that’s unaccounted for, it begins querying for that message’s contents.</p>



<p>Client periodically checks layer 1, and checks layer 2 when:</p>



<ol>
<li>A new key appears in layer 1.</li>



<li>A report for a key has a different status byte.
<ul>
<li>Example: we received message <code>0x0011</code> already and take a break.</li>



<li>Query layer 1: get location reports for <code>[ 0x0000 0x00 device_id 0x00 0x11 ]</code> as expected.</li>



<li>However, some of the reports now have status byte = <code>0x33</code>.</li>



<li>We know to check layer 2, and will see reports for both:
<ul>
<li><code>[ 0x0000 0x00 device_id 0x00 0x11 ]</code></li>



<li>and</li>



<li><code>[ 0x0000 0x00 device_id 0x33 0x11 ]</code></li>
</ul>
</li>



<li>Even if we missed far more since <code>0x0011</code> (say message <code>0x2211</code> was sent in the meantime too), then we’ll also see <code>[ 0x0000 0x00 device_id 0x22 0x11 ]</code> in layer 2.</li>
</ul>
</li>
</ol>



<p><strong>Tip</strong>: Translation: when the client doesn’t know what’s happening, it checks all the mailboxes for new notes (including looking underneath each paper to make sure it’s not covering up another one).</p>



<hr/>



<h3><a href="#erasure-correction"></a>Erasure Correction</h3>



<p>As we send increasing amounts of data over the Find My network, it became clear that packet loss was a minor issue. It’s rare for advertisements to not be picked up, but it becomes more likely if there’s not enough finders nearby or the message isn’t repeated enough times.</p>



<p>To combat this, we introduced Reed-Solomon erasure correction blocks to our messages. Using a predefined “code rate” (like 80%), the client can reconstruct the message if <em>any</em> 80% of the chunks are retrieved. The additional layer of handling on both sides of the transmission was a source of countless bugs, but once implemented Reed-Solomon was overall a large quality of life improvement. The slight overhead in message size is worth the breathing room.</p>



<hr/>



<h3><a href="#speed"></a>Speed</h3>



<p>The biggest point of latency in this protocol comes from waiting for nearby finders to pick up and report all of the advertisements.</p>



<p>Due to Apple finder characteristics, there is a hard limit on how much data each finder can report in a given time frame. Since each finder has 96 batches/day, we estimate a batch of 256 keys (512 data bytes) is uploaded every 15 mins. We estimate that <strong>for every +500 bytes of data you send with this method, you can expect to wait another +15 mins</strong> for your advertisements to be picked up. Of course, this estimate fluctuates with the number of finders nearby. In the best case where no other legit advertisements are reported, each finder device could upload 48 kB of our data per day.</p>



<p>Once all advertisements and corresponding location reports are stored in Apple’s servers, we can achieve download speeds of <strong>~60 bits/s</strong></p>


<div>
<figure><a href="https://cc-sw.com/wp-content/uploads/2025/08/speed1.png"><img loading="lazy" decoding="async" width="512" height="417" src="https://cc-sw.com/wp-content/uploads/2025/08/speed1.png" alt="" srcset="https://cc-sw.com/wp-content/uploads/2025/08/speed1.png 512w, https://cc-sw.com/wp-content/uploads/2025/08/speed1-300x244.png 300w" sizes="auto, (max-width: 512px) 100vw, 512px"/></a></figure>
</div>


<p>Example of Reed-Solomon decoding allowing us to decode message early (10 bytes were still missing, but text could be recovered):</p>


<div>
<figure><a href="https://cc-sw.com/wp-content/uploads/2025/08/rs.png"><img loading="lazy" decoding="async" width="1024" height="660" src="https://cc-sw.com/wp-content/uploads/2025/08/rs-1024x660.png" alt="" srcset="https://cc-sw.com/wp-content/uploads/2025/08/rs-1024x660.png 1024w, https://cc-sw.com/wp-content/uploads/2025/08/rs-300x193.png 300w, https://cc-sw.com/wp-content/uploads/2025/08/rs-768x495.png 768w, https://cc-sw.com/wp-content/uploads/2025/08/rs-1536x990.png 1536w, https://cc-sw.com/wp-content/uploads/2025/08/rs.png 1684w" sizes="auto, (max-width: 1024px) 100vw, 1024px"/></a></figure>
</div>


<hr/>



<h3><a href="#aside-deployment-scenarios"></a>Aside: Deployment Scenarios</h3>



<p>Once we achieved arbitrary data transmission, we began thinking of deployment scenarios for a unidirectional, low bitrate communication channel. Some ideas included:</p>



<ul>
<li>Keylogger</li>



<li>Speech-to-text recording device</li>



<li>Passive BLE/WiFi sniffer</li>



<li>Images</li>



<li>Other embedded devices from previous research projects</li>
</ul>



<p>It quickly became clear that use cases stretched across many different architectures and device types. This brought us back to a major goal for this project: portability.</p>



<hr/>



<h2><a href="#portability"></a>Portability</h2>



<p>As the project developed, it became clear that a unidirectional, low bitrate communication channel had a range of uses across the embedded software world. To support the wide variety of use cases, we made portability across several architectures and operating systems a priority.</p>



<p>Our Find My spoofing requires fine-tune control over Bluetooth Low Energy advertisement packets. To achieve this across different hardware, we could find the BT API provided by the OS/manufacturer. For example, we used the high-level ESP BT API up to this point. However, this becomes messy quickly. All of the APIs expect different formats, exert different levels of customization, and are not guaranteed to provide the commands we need.</p>



<p>Instead, we transitioned to HCI. Host Controller Interface is a protocol used to communicate between a host and its Bluetooth adapter/controller. Besides vendor-specific commands, HCI packet structure is consistent across different hardware. Therefore, constructing HCI commands that represent the BT services that we need (setting MAC address, modifying body, etc) is a one-time effort that makes all future portability much easier.</p>



<p>This formed the basis of our Hardware Abstraction Layer (HAL): a new device simply must find out <strong>how to send HCI packets to its BT radio and read responses</strong> (commonly through UART, USB, or SPI). We refactored our device-side codebase twice as we minimized the amount of platform-specific code. The resulting API layers allow for seamless transition from raw data, to Reed-Solomon encoded messages, to BT advertisements, to HCI packets, to transmission.</p>



<figure><a href="https://cc-sw.com/wp-content/uploads/2025/08/device_control_flow.png"><img loading="lazy" decoding="async" width="1024" height="209" src="https://cc-sw.com/wp-content/uploads/2025/08/device_control_flow-1024x209.png" alt="" srcset="https://cc-sw.com/wp-content/uploads/2025/08/device_control_flow-1024x209.png 1024w, https://cc-sw.com/wp-content/uploads/2025/08/device_control_flow-300x61.png 300w, https://cc-sw.com/wp-content/uploads/2025/08/device_control_flow-768x157.png 768w, https://cc-sw.com/wp-content/uploads/2025/08/device_control_flow-1536x314.png 1536w, https://cc-sw.com/wp-content/uploads/2025/08/device_control_flow-2048x418.png 2048w" sizes="auto, (max-width: 1024px) 100vw, 1024px"/></a></figure>



<hr/>



<h3><a href="#esp32"></a>ESP32</h3>



<p>After combing through documentation, we discovered a lower-level API (VHCI) for sending HCI commands.</p>



<figure><a href="https://cc-sw.com/wp-content/uploads/2025/08/esp32_bluetooth_vhci.webp"><img loading="lazy" decoding="async" width="1024" height="695" src="https://cc-sw.com/wp-content/uploads/2025/08/esp32_bluetooth_vhci-1024x695.webp" alt="" srcset="https://cc-sw.com/wp-content/uploads/2025/08/esp32_bluetooth_vhci-1024x695.webp 1024w, https://cc-sw.com/wp-content/uploads/2025/08/esp32_bluetooth_vhci-300x204.webp 300w, https://cc-sw.com/wp-content/uploads/2025/08/esp32_bluetooth_vhci-768x521.webp 768w, https://cc-sw.com/wp-content/uploads/2025/08/esp32_bluetooth_vhci.webp 1512w" sizes="auto, (max-width: 1024px) 100vw, 1024px"/></a></figure>



<p><a href="https://cc-sw.com/irad/findmy/-/wikis/uploads/5457b280c99e42a8e9bf2f489a4e7473/esp32_bluetooth_vhci.webp" target="_blank" rel="noreferrer noopener"></a><em> Image of ESP32 HCI structure [7]</em></p>



<hr/>



<h3><a href="#linux"></a>Linux</h3>



<p>Besides waiting for a BT dongle to arrive and fixing some memory unsafe BlueZ code, Linux integration was a relatively painless process. Creating a raw socket for the correct interface allows for easy HCI communication. The program must be run as root, which is inevitable for the level of BT control we require. <strong>Our desktops were now AirTags!</strong></p>



<hr/>



<h3><a href="#nrf52-dk"></a>nRF52 DK</h3>



<p>The nRF52 DK is natively supported by platformIO, which we already had infrastructure for. We decided to use the Zephyr RTOS with it, since Zephyr was one of the RTOS’s that platformIO offered with it’s native support for the nRF52. From there, we looked at the Zephyr source code for its Bluetooth API to identify the lower layer HCI API.</p>



<hr/>



<h3><a href="#ti-devices"></a>TI Devices</h3>



<p>Integrating TI microcontrollers is a work in progress. We wanted to use platformIO to keep a mostly unified build tooling for our firmware, but we learned that it doesn’t natively support most TI devices. We moved on to using TI’s own IDE called CCS. The first TI device we used was the TI LaunchXL 2640R2, the subject of a previous research project. After much troubleshooting, we concluded that the board was dead. We ended up going through every TI device in the building and found that every board either did not have Bluetooth (like a TI CC1310) or was dead. Regardless, we implemented the infrastructure for supporting TI devices through a <code>Cmakelists.txt</code>. TI strongly encourages (read: enforces) the use of their own proprietary software, including their own IDE, compiler, RTOS, and flashing software. It was a challenge to integrate the TI build tooling with our main codebase. Our solution:</p>



<ul>
<li>Download the CCS IDE and create a sample project with the desired board. This downloads the correct SDK and compiler to build it.</li>



<li>Look at the output of the compiler and find the paths of the necessary dependencies (outlined in the CmakeLists.txt) that were just downloaded.</li>



<li>Use the TI Uniflash tool to flash the built firmware.</li>
</ul>



<hr/>



<h2><a href="#scanning"></a>Scanning</h2>



<p>Each of these supported platforms has their own potential uses for offline data transmission. As a test case, we wanted to scan nearby BLE devices on all of them. As the first real use case besides simple text, it shed light on several key areas:</p>



<ul>
<li>Demonstrated consistent data transfer over time using the Find My network.</li>



<li>Standardized HCI response parsing as taking place in a second thread of execution instead of a callback. We were able to abstract data transfer between layers even further.</li>



<li>Prompted us to create an abstract class on the client side to support reconstruction of different types of data.</li>
</ul>


<div>
<figure><a href="https://cc-sw.com/wp-content/uploads/2025/08/scanning_results.png"><img loading="lazy" decoding="async" width="603" height="365" src="https://cc-sw.com/wp-content/uploads/2025/08/scanning_results.png" alt="" srcset="https://cc-sw.com/wp-content/uploads/2025/08/scanning_results.png 603w, https://cc-sw.com/wp-content/uploads/2025/08/scanning_results-300x182.png 300w" sizes="auto, (max-width: 603px) 100vw, 603px"/></a></figure>
</div>






<p>The actual scanning data was less illustrative than we hoped, but it still has some reconnaissance/intel value. We got creative with the graphs, sending abridged “update” packets for seen devices that allow us to track their proximity over time. This info also tells us if there’s Apple devices nearby, which could help the transmission device determine whether its advertisements will get picked up or not. Future improvements include adding WiFi scanning for richer profiling data.</p>


<div>
<figure><a href="https://cc-sw.com/wp-content/uploads/2025/08/scanning_example3.png"><img loading="lazy" decoding="async" width="1024" height="596" src="https://cc-sw.com/wp-content/uploads/2025/08/scanning_example3-1024x596.png" alt="" srcset="https://cc-sw.com/wp-content/uploads/2025/08/scanning_example3-1024x596.png 1024w, https://cc-sw.com/wp-content/uploads/2025/08/scanning_example3-300x175.png 300w, https://cc-sw.com/wp-content/uploads/2025/08/scanning_example3-768x447.png 768w, https://cc-sw.com/wp-content/uploads/2025/08/scanning_example3-1536x894.png 1536w, https://cc-sw.com/wp-content/uploads/2025/08/scanning_example3.png 1600w" sizes="auto, (max-width: 1024px) 100vw, 1024px"/></a></figure>
</div>


<hr/>



<h2><a href="#more-networks"></a>More Networks?</h2>



<p>There are many areas with few Apple finders where our protocol would struggle. Why limit ourselves to one Offline Finding network? With Android’s massive market share, Google Find Hub provided an enticing supplement to the project. The first step was to figure out the similarities and differences between how Apple and Google run their networks.</p>


<div>
<figure><a href="https://cc-sw.com/wp-content/uploads/2025/08/iphone-vs-android-us.webp"><img loading="lazy" decoding="async" width="1024" height="778" src="https://cc-sw.com/wp-content/uploads/2025/08/iphone-vs-android-us-1024x778.webp" alt="" srcset="https://cc-sw.com/wp-content/uploads/2025/08/iphone-vs-android-us-1024x778.webp 1024w, https://cc-sw.com/wp-content/uploads/2025/08/iphone-vs-android-us-300x228.webp 300w, https://cc-sw.com/wp-content/uploads/2025/08/iphone-vs-android-us-768x584.webp 768w, https://cc-sw.com/wp-content/uploads/2025/08/iphone-vs-android-us.webp 1200w" sizes="auto, (max-width: 1024px) 100vw, 1024px"/></a></figure>
</div>


<p><a href="https://cc-sw.com/irad/findmy/-/wikis/uploads/de1549578b786dcd2a37c1c40d43260d/iphone-vs-android-global.webp" target="_blank" rel="noreferrer noopener"></a><em> <a href="https://cc-sw.com/irad/findmy/-/wikis/uploads/11fff59ed2a7671895fb7995fb64bf2c/iphone-vs-android-us.webp" target="_blank" rel="noreferrer noopener"></a> Images of Apple vs Android market shares [8]</em></p>



<hr/>



<h2><a href="#google-find-hub"></a>Google Find Hub</h2>



<p>Unlike Find My, there are very few research papers about Google Find Hub. Much of our info comes from a singular paper [9]. Although Find Hub (2013) was only released four years after Find My (2009), offline finding (crowdsourced location reports) was added much later–Apple in June 2019, Google in April 2024. Since Apple’s crowdsourcing has been released for much longer, it has already been thoroughly reverse engineered. We suspect that Google witnessed the abuse of the Find My network and <strong>designed Find Hub with heavy restrictions</strong> to prevent the same fate.</p>



<h3><a href="#find-hub-protocol"></a>Find Hub Protocol</h3>



<p>The basic workflow of Offline Finding networks holds true for Google’s Find Hub. These are some key differences:</p>



<ul>
<li>Google knows which public keys (EIDs) belong to which devices and will not store location reports for those that are not associated with a registered device.</li>



<li>Users can only query location reports for trackers registered to their account.</li>



<li>Much harsher rate limiting and throttling is enforced. Users can only get location updates for a specific tracker once every few hours.</li>



<li>No status byte transmitted over the network.</li>
</ul>



<h3><a href="#googlefindmytools"></a>GoogleFindMyTools</h3>



<p>GoogleFindMyTools (made by the authors of the above paper) is the prominent open source Find Hub authority, akin to OpenHaystack. GoogleFindMyTools made key contributions in identifying the contents of protobufs for important GRPC services on Google’s Spot API. The author also discovered how to use Google’s Firebase project with the Spot API to query for location reports.</p>



<p>Our first step was to ensure that their spoofing method still worked. The company firewall prevented us from talking out on <code>mtalk.google.com 5228</code>, so we used Oniux to route our network traffic through Tor exit nodes. To look like a valid user, we made a burner Google account and signed into a Google Pixel created by Google’s own android emulator. Using GoogleFindMyTools, we were able to view location reports from our ESP32 in the emulator’s Find Hub app.</p>



<p>Limitations: the ESP32 could only broadcast a static key, and there was no way to delete devices registered to your account using GoogleFindMyTools.</p>



<h3><a href="#google-data-exfiltration"></a>Google Data Transmission</h3>



<h4><a href="#basic-data-exfiltration"></a>Basic Data Transmission</h4>



<p>To our knowledge, <strong>Find Hub transmission had never been done before</strong>. We investigated Google’s heavily regulated system for weeks before coming up with a POC. The fundamentals of our protocol (device sends specific keys, client guesses the data bits while querying) remain the same, but Google did their best to make it difficult. Location reports will only be stored if the device with the associated EID has been registered by the time that report is uploaded. Therefore, <strong>each of the 2^n guesses for a data chunk is its own registered device</strong>. Typically for Google, n = 2 bits/key. Querying a single one of those guesses takes ~2.25 HTTP requests, not including the device registration or deletion.</p>



<p>To confirm that basic data transmission was possible, we performed a simple test with 2 registered devices. After querying them and finding the correct bit, we had to log into the Find Hub app on the Android emulator and delete the device from there. Although the method was functional, we realized that automation was needed for it be viable.</p>



<h4><a href="#finding-unknown-grpc-services"></a>Finding Unknown GRPC services</h4>



<p>We went on a quest for uncovered capabilities of the Find Hub network that could aid our transmission. We found a Github issue listing several of the GRPC services with the Spot API, seemingly found by decompiling a Find Hub apk. There were many interesting GRPC services listed, most prominently being <code>DeleteBleDevice</code> and <code>ListEidsForBleDevices</code>. Our first attempt in uncovering these services’ protobufs was to intercept calls from the browser version of Find Hub. As it turns out, the web version of Find Hub has limited capabilities compared to the Find Hub Android app, and we were unable to trigger any interesting GRPC services. The next best option was to reverse engineer the Android Find Hub app. We used the Android emulator with Magisk to root the emulator device and began testing. In the midst of that work, we discovered an overlooked source that revealed the contents of the protobufs. Our client was now able to employ the <code>DeleteBleDevice</code> and <code>ListEidsForBleDevices</code> services.</p>



<h4><a href="#client-upgrades"></a>Client Upgrades</h4>



<p>With the power to automatically delete devices, our device registration transmission method is viable. Because of the overhead involved with each chunk, we spent lots of time looking for optimizations on the client side.</p>



<p>It became apparent that we needed to register as many devices as we could. Upon startup, our client spawns 8 threads to create ~100 devices on our burner Google account. Their info is also prefetched for later interactions.</p>



<figure><a href="https://cc-sw.com/wp-content/uploads/2025/08/google_init_flowchart.png"><img loading="lazy" decoding="async" width="1024" height="332" src="https://cc-sw.com/wp-content/uploads/2025/08/google_init_flowchart-1024x332.png" alt="" srcset="https://cc-sw.com/wp-content/uploads/2025/08/google_init_flowchart-1024x332.png 1024w, https://cc-sw.com/wp-content/uploads/2025/08/google_init_flowchart-300x97.png 300w, https://cc-sw.com/wp-content/uploads/2025/08/google_init_flowchart-768x249.png 768w, https://cc-sw.com/wp-content/uploads/2025/08/google_init_flowchart-1536x499.png 1536w, https://cc-sw.com/wp-content/uploads/2025/08/google_init_flowchart.png 2015w" sizes="auto, (max-width: 1024px) 100vw, 1024px"/></a></figure>



<hr/>



<p>Another improvement came from examining <code>ListEidsForBleDevices</code>. We realized that <code>UploadPrecomputedKeyIds</code>, an existing GRPC service, could allow us to overwrite the key associated with each device. Instead of deleting and recreating all 100 devices once their keys have been guessed, this strategy repurposes them to brute force the next chunks. Creation and deletion only need to be done when a message is first seen and completely fetched.</p>



<figure><a href="https://cc-sw.com/wp-content/uploads/2025/08/google_query_flowchart.png"><img loading="lazy" decoding="async" width="1024" height="840" src="https://cc-sw.com/wp-content/uploads/2025/08/google_query_flowchart-1024x840.png" alt="" srcset="https://cc-sw.com/wp-content/uploads/2025/08/google_query_flowchart-1024x840.png 1024w, https://cc-sw.com/wp-content/uploads/2025/08/google_query_flowchart-300x246.png 300w, https://cc-sw.com/wp-content/uploads/2025/08/google_query_flowchart-768x630.png 768w, https://cc-sw.com/wp-content/uploads/2025/08/google_query_flowchart-1536x1260.png 1536w, https://cc-sw.com/wp-content/uploads/2025/08/google_query_flowchart.png 1560w" sizes="auto, (max-width: 1024px) 100vw, 1024px"/></a></figure>



<hr/>



<p>By parallelizing and retrying failed HTTP requests, we were able to substantially increase download speeds for Apple and Google messages.</p>



<hr/>



<h3><a href="#google-blocking-tor"></a>Google Blocking Tor</h3>



<p>Two days before our presentation, critical requests to Google’s servers stopped working. We ran unit tests performing GRPC services that we knew were not blocked by the CCSW firewall, and they were successful. Upon running the same unit tests under Oniux, every single one failed. After combing through git logs and confirming that nothing on our end changed, we find it likely that Google has blocked the Tor exit nodes. Thankfully, we could obtain a firewall exception and stop using Oniux entirely.</p>



<hr/>



<h2><a href="#find-myhub-integration"></a>Find My/Hub Integration</h2>



<p>Now that we can send arbitrary data over an <em>additional</em> Offline Finding network, how does that help us?</p>



<p>This is mostly up to the user and is based on what they value. Transmission over Google’s network is very slow, so it is best used as backup/auxiliary source compared to Apple (although if needed, it can certainly stand alone). Our client supports any use cases that integrate both networks, including:</p>



<ul>
<li>Improve throughput by sending data proportionally across the networks based on their speeds (if Apple is 10x faster, send 1 Google chunk every 10 Apple ones).</li>



<li>Use as redundancy for important chunks.</li>



<li>Send every chunk over both networks and consult Google iff Apple lost a packet.</li>



<li>Use as a side channel to communicate metadata.</li>
</ul>



<hr/>



<h2><a href="#sending-images"></a>Sending Images</h2>



<p>A popular suggested deployment scenario was sending images from a connectionless state. The big question was whether we could compress the images small enough to where our communication channel could handle them. Based on our theories about payload size and wait time, we wanted to get squash images into the 500-1000 byte range so that they could send in ~30 minutes. We experimented with many different combinations of compression algorithms before finding a process that balanced image recognizability and size. We downscale by 75%, compress heavily with JPEG, and losslessly zip.</p>



<p>The following images were sent using the Find My network in around 30 minutes.</p>



<figure><a href="https://cc-sw.com/wp-content/uploads/2025/08/demo_sent.png"><img loading="lazy" decoding="async" width="320" height="240" src="https://cc-sw.com/wp-content/uploads/2025/08/demo_sent.png" alt="" srcset="https://cc-sw.com/wp-content/uploads/2025/08/demo_sent.png 320w, https://cc-sw.com/wp-content/uploads/2025/08/demo_sent-300x225.png 300w" sizes="auto, (max-width: 320px) 100vw, 320px"/></a></figure>



<figure><a href="https://cc-sw.com/wp-content/uploads/2025/08/stickman1_sent.jpg"><img loading="lazy" decoding="async" width="320" height="240" src="https://cc-sw.com/wp-content/uploads/2025/08/stickman1_sent.jpg" alt="" srcset="https://cc-sw.com/wp-content/uploads/2025/08/stickman1_sent.jpg 320w, https://cc-sw.com/wp-content/uploads/2025/08/stickman1_sent-300x225.jpg 300w" sizes="auto, (max-width: 320px) 100vw, 320px"/></a></figure>



<figure><a href="https://cc-sw.com/wp-content/uploads/2025/08/HELLO_680.jpg"><img loading="lazy" decoding="async" width="320" height="240" src="https://cc-sw.com/wp-content/uploads/2025/08/HELLO_680.jpg" alt="" srcset="https://cc-sw.com/wp-content/uploads/2025/08/HELLO_680.jpg 320w, https://cc-sw.com/wp-content/uploads/2025/08/HELLO_680-300x225.jpg 300w" sizes="auto, (max-width: 320px) 100vw, 320px"/></a></figure>



<p>The compression levels can easily be tweaked according to user specifications: for example, this high quality (2.7 kB, wow!) image was sent in 1.5 hours.</p>



<figure><a href="https://cc-sw.com/wp-content/uploads/2025/08/flag_92.jpg"><img loading="lazy" decoding="async" width="448" height="336" src="https://cc-sw.com/wp-content/uploads/2025/08/flag_92.jpg" alt="" srcset="https://cc-sw.com/wp-content/uploads/2025/08/flag_92.jpg 448w, https://cc-sw.com/wp-content/uploads/2025/08/flag_92-300x225.jpg 300w" sizes="auto, (max-width: 448px) 100vw, 448px"/></a></figure>



<hr/>



<h2><a href="#conclusion"></a>Conclusion</h2>



<ul>
<li>Offline, unidirectional data transmission and location tracking.</li>



<li>Download speeds of <strong>60 bits/s</strong>.</li>



<li>Custom protocol design that maximizes cryptographic security and throughput.</li>



<li>Supports Apple’s Find My and Google’s Find Hub networks in tandem.</li>



<li>Low risk of detection (and difficult to track back to the user, even for Apple/Google).</li>



<li>Easily cross-platform (only requiring a hardware abstraction layer for HCI sending). Currently supports ESP32, Linux, nRF42_DK, and TI microcontrollers (WIP).</li>



<li>Supports different data types (nearby BLE device scanning, text, images).</li>



<li>Low energy and cost (free communication using network we don’t control).</li>



<li>Out-of-band synchronization between device and client.</li>



<li>Erasure correction (Reed-Solomon encoding) for message reconstruction.</li>



<li>Avoids the industry standard for anti-stalking mechanisms.</li>
</ul>



<hr/>



<h2><a href="#security-faq"></a>Security FAQ</h2>



<p>Can 3rd parties (finders, Apple, or nearby sniffers) spy on the data payload?</p>



<ul>
<li>The data payload is an ECC <em>private</em> key. The corresponding <em>public</em> key is embedded in the public Bluetooth Low Energy advertisements, but the conversion is not reversible. Each beacon looks like a totally random AirTag.
<ul>
<li>Note: the status byte is encrypted by the finders by the time Apple sees it, but it is <strong>not encrypted during advertisements</strong>. That is 8 bits of data from our datastream that could be intercepted by nearby sniffers (including the finders themselves). If this is unacceptable, then status byte data can be disabled.</li>
</ul>
</li>
</ul>



<p>Are we vulnerable to replay attacks?</p>



<ul>
<li>Slightly. An attacker doesn’t need to understand the public key in order to repeat it. Similarly to above, this poses an issue with the status byte. They could poison half of a chunk by repeating with a bogus status byte. The solution to this is to disable the status byte and accept lower data rates.</li>
</ul>



<p>Will these devices trigger Apple’s stalking alerts?</p>



<ul>
<li>No. They check for AirTags that repeat the same public key for 24 hours. Our protocol’s keys change rapidly. If we repeated the same message for several hours, then an alert could trigger. It would look like hundreds of AirTags were following.</li>
</ul>



<p>Can an attacker query our data in our stead if they know our protocol? Can they send false info?</p>



<ul>
<li>Yes, but only if they know the 20-byte device ID that we’ve chosen. This cryptographically-secure shared secret that is set while pairing ensures that our device and client have a protected channel of communication.</li>
</ul>



<p>Do we have to worry about conflicts with real AirTag keys?</p>



<ul>
<li>Not that we’ve witnessed. The 28-byte keyspace seems sufficiently large, and reports are only stored for a week.</li>
</ul>



<p>Can this method be correlated to our device or identity?</p>



<ul>
<li>Apple could identify your burner account querying for thousands of location reports, but we haven’t gotten banned yet. Apple also cannot see where those E2E-encrypted location reports are coming from. Google certainly cares about the spam, but they’d have to work very hard to get around burner accounts. To nearby devices, it simply looks as though hundreds of AirTags are surrounding them. They cannot easily trace the source of the advertisement spam.</li>
</ul>



<hr/>



<h2><a href="#resources"></a>Resources</h2>



<p>[1]: <a href="https://github.com/seemoo-lab/openhaystack/tree/main" rel="noreferrer noopener" target="_blank">Openhaystack</a> tool</p>



<p>[2]: <a href="https://arxiv.org/abs/2103.02282" rel="noreferrer noopener" target="_blank">Who Can Find My Device?</a></p>



<p>[3]: <a href="https://positive.security/blog/send-my" rel="noreferrer noopener" target="_blank">Positive Security’s Send My</a></p>



<p>[4]: <a href="https://github.com/malmeloo/FindMy.py" rel="noreferrer noopener" target="_blank">FindMy.py Library</a></p>



<p>[5]: <a href="https://samteplov.com/uploads/who-tracks-the-trackers/trackers.pdf" rel="noreferrer noopener" target="_blank">Who Tracks the Trackers? Circumventing Apple’s Anti-Tracking Alerts in the Find My Network</a></p>



<p>[6]: <a href="https://petsymposium.org/popets/2023/popets-2023-0102.pdf" rel="noreferrer noopener" target="_blank">Track You: A Deep Dive into Safety Alerts for Apple Airtags</a></p>



<p>[7]: <a href="https://developer.espressif.com/blog/2025/03/esp32-bluetooth-clearing-the-air/" rel="noreferrer noopener" target="_blank">ESP32 Undocumented Bluetooth Commands: Clearing the Air</a></p>



<p>[8]: <a href="https://explodingtopics.com/blog/iphone-android-users" rel="noreferrer noopener" target="_blank">iPhone vs Android User Stats (2025 Data)</a></p>



<p>[9]: <a href="https://petsymposium.org/popets/2025/popets-2025-0147.pdf" rel="noreferrer noopener" target="_blank">Okay Google, Where’s My Tracker? Security, Privacy, and Performance Evaluation of Google’s Find My Device Network</a></p>



<p>[11]: <a href="https://dl.acm.org/doi/pdf/10.1145/3572864.3580342" rel="noreferrer noopener" target="_blank">TagAlong: Free, Wide-Area Data-Muling and Services</a></p>



<blockquote>
<p>“Uncontrolled mules move in unknown ways.”</p>
</blockquote>



<p>[12]: <a href="https://mediatum.ub.tum.de/doc/1660335/u3ar0phky7osx7cgokyz7xcgf.2022_Andrea_Tag.pdf" rel="noreferrer noopener" target="_blank">Where Is My Tag? Unveiling Alternative Uses of the Apple FindMy Service</a></p>



<p>[13]: <a href="https://adamcatley.com/AirTag.html" rel="noreferrer noopener" target="_blank">Apple AirTag Reverse Engineering</a></p>



<p>[14]: <a href="https://cs.gmu.edu/~zeng/papers/2025-security-nrootgag.pdf" rel="noreferrer noopener" target="_blank">Tracking You from a Thousand Miles Away! Turning a Bluetooth Device into an Apple AirTag Without Root Privileges</a></p>



<p>[15]: <a href="https://arxiv.org/pdf/2202.11813" rel="noreferrer noopener" target="_blank">AirGuard – Protecting Android Users From Stalking Attacks By Apple Find My Devices</a></p>



<p>[16]: <a href="https://security.googleblog.com/2024/04/find-my-device-network-security-privacy-protections.html" rel="noreferrer noopener" target="_blank">How we built the new Find Hub network with user security and privacy in mind</a></p>



<p>[17]: <a href="https://blog.google/products/android/android-find-my-device/" rel="noreferrer noopener" target="_blank">5 ways to use the new Find My Device on Android</a></p>



<p>[18]: <a href="https://developers.google.com/nearby/fast-pair/specifications/extensions/fmdn" rel="noreferrer noopener" target="_blank">Find Hub Network Accessory Specification</a></p>




 
	</div></div>
  </body>
</html>
