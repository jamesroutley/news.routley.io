<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://openjdk.org/projects/amber/design-notes/on-ramp">Original</a>
    <h1>Paving the on-ramp to Java</h1>
    
    <div id="readability-page-1" class="page"><article>
<header>
</header>
<section id="brian-goetz-september-2022">
<p><b><a href="#brian-goetz-september-2022">Brian Goetz, September 2022</a></b>  Java is one of the most widely taught programming languages in the world. Tens of thousands of educators find that the imperative core of the language combined with a straightforward standard library is a foundation that students can comfortably learn on. Choosing Java gives educators many degrees of freedom: they can situate students in <code>jshell</code> or Notepad or a full-fledged IDE; they can teach imperative, object-oriented, functional, or hybrid programming styles; and they can easily find libraries to interact with external data and services.</p>

<p>No language is perfect, and one of the most common complaints about Java is that it is “too verbose” or has “too much ceremony.” And unfortunately, Java imposes its heaviest ceremony on those first learning the language, who need and appreciate it the least. The declaration of a class and the incantation of <code>public static void main</code> is pure mystery to a beginning programmer. While these incantations have principled origins and serve a useful organizing purpose in larger programs, they have the effect of placing obstacles in the path of <em>becoming</em> Java programmers. Educators constantly remind us of the litany of complexity that students have to confront on Day 1 of class — when they really just want to write their first program.</p>
<p>As an amusing demonstration of this, in her JavaOne keynote appearance in 2019, <a href="https://www.youtube.com/watch?v=BkPPFiXUwYk">Aimee Lucido</a> talked about when she learned to program in Java, and how her teacher performed a rap song to help students memorize <code>&#34;public static void main&#34;</code>. Our hats are off to creative educators everywhere for this kind of dedication, but teachers shouldn’t have to do this.</p>
<p>Of course, advanced programmers complain about ceremony too. We will never be able to satisfy programmers’ insatiable appetite for typing fewer keystrokes, and we shouldn’t try, because the goal of programming is to write programs that are easy to read and are clearly correct, not programs that were easy to type. But we can try to better align the ceremony commensurate with the value it brings to a program — and let simple programs be expressed more simply.</p>
</section><section id="concept-overload">
<h2><a href="#concept-overload">Concept overload</a></h2>
<p>The classic “Hello World” program looks like this in Java:</p>
<pre><code>public class HelloWorld { 
    public static void main(String[] args) { 
        System.out.println(&#34;Hello World&#34;);
    }
}</code></pre>
<p>It may only be five lines, but those lines are packed with concepts that are challenging to absorb without already having some programming experience and familiarity with object orientation. Let’s break down the concepts a student confronts when writing their first Java program:</p>
<ul>
<li>
<p><strong>public</strong> (on the class). The <code>public</code> accessibility level is relevant only when there is going to be cross-package access; in a simple “Hello World” program, there is only one class, which lives in the unnamed package. They haven’t even written a one-line program yet; the notion of access control — keeping parts of a program from accessing other parts of it — is still way in their future.</p>
</li>
<li>
<p><strong>class</strong>. Our student hasn’t set out to write a <em>class</em>, or model a complex system with objects; they want to write a <em>program</em>. In Java, a program is just a <code>main</code> method in some class, but at this point our student still has no idea what a class is or why they want one.</p>
</li>
<li>
<p><strong>Methods</strong>. Methods are of course a key concept in Java, but the mechanics of methods — parameters, return types, and invocation — are still unfamiliar, and the <code>main</code> method is invoked magically from the <code>java</code> launcher rather than from explicit code.</p>
</li>
<li>
<p><strong>public</strong> (again). Like the class, the <code>main</code> method has to be public, but again this is only relevant when programs are large enough to require packages to organize them.</p>
</li>
<li>
<p><strong>static</strong>. The <code>main</code> method has to be static, and at this point, students have no context for understanding what a static method is or why they want one. Worse, the early exposure to <code>static</code> methods will turn out to be a bad habit that must be later unlearned. Worse still, the fact that the <code>main</code> method is <code>static</code> creates a seam between <code>main</code> and other methods; either they must become <code>static</code> too, or the <code>main</code> method must trampoline to some sort of “instance main” (more ceremony!) And if we get this wrong, we get the dreaded and mystifying <code>&#34;cannot be referenced from a static context&#34;</code> error.</p>
</li>
<li>
<p><strong>main</strong>. The name <code>main</code> has special meaning in a Java program, indicating the starting point of a program, but this specialness hides behind being an ordinary method name. This may contribute to the sense of “so many magic incantations.”</p>
</li>
<li>
<p><strong>String[]</strong>. The parameter to <code>main</code> is an array of strings, which are the arguments that the <code>java</code> launcher collected from the command line. But our first program — likely our first dozen — will not use command-line parameters. Requiring the <code>String[]</code> parameter is, at this point, a mistake waiting to happen, and it will be a long time until this parameter makes sense. Worse, educators may be tempted to explain arrays at this point, which further increases the time-to-first-program.</p>
</li>
<li>
<p><strong>System.out.println</strong>. If you look closely at this incantation, each element in the chain is a different thing — <code>System</code> is a class (what’s a class again?), <code>out</code> is a static field (what’s a field?), and <code>println</code> is an instance method. The only part the student cares about right now is <code>println</code>; the rest of it is an incantation that they do not yet understand in order to get at the behavior they want.</p>
</li>
</ul>
<p>That’s a lot to explain to a student on the first day of class. There’s a good chance that by now, class is over and we haven’t written any programs yet, or the teacher has said “don’t worry what this means, you’ll understand it later” six or eight times. Not only is this a lot of <em>syntactic</em> things to absorb, but each of those things appeals to a different concept (class, method, package, return value, parameter, array, static, public, etc) that the student doesn’t have a framework for understanding yet. Each of these will have an important role to play in larger programs, but so far, they only contribute to “wow, programming is complicated.”</p>
<p>It won’t be practical (or even desirable) to get <em>all</em> of these concepts out of the student’s face on day 1, but we can do a lot — and focus on the ones that do the most to help beginners understand how programs are constructed.</p>
</section><section id="goal-a-smooth-on-ramp">
<h2><a href="#goal-a-smooth-on-ramp">Goal: a smooth on-ramp</a></h2>
<p>As much as programmers like to rant about ceremony, the real goal here is not mere ceremony reduction, but providing a graceful <em>on ramp</em> to Java programming. This on-ramp should be helpful to beginning programmers by requiring only those concepts that a simple program needs.</p>
<p>Not only should an on-ramp have a gradual slope and offer enough acceleration distance to get onto the highway at the right speed, but its direction must align with that of the highway. When a programmer is ready to learn about more advanced concepts, they should not have to discard what they’ve already learned, but instead easily see how the simple programs they’ve already written generalize to more complicated ones, and both the syntatic and conceptual transformation from “simple” to “full blown” program should be straightforward and unintrusive. It is a definite non-goal to create a “simplified dialect of Java for students”.</p>
<p>We identify three simplifications that should aid both educators and students in navigating the on-ramp to Java, as well as being generally useful to simple programs beyond the classroom as well:</p>
<ul>
<li>A more tolerant launch protocol</li>
<li>Unnamed classes</li>
<li>Predefined static imports for the most critical methods and fields</li>
</ul>
</section><section id="a-more-tolerant-launch-protocol">
<h2><a href="#a-more-tolerant-launch-protocol">A more tolerant launch protocol</a></h2>
<p>The Java Language Specification has relatively little to say about how Java “programs” get launched, other than saying that there is some way to indicate which class is the initial class of a program (JLS 12.1.1) and that a public static method called <code>main</code> whose sole argument is of type <code>String[]</code> and whose return is <code>void</code> constitutes the entry point of the indicated class.</p>
<p>We can eliminate much of the concept overload simply by relaxing the interactions between a Java program and the <code>java</code> launcher:</p>
<ul>
<li>
<p>Relax the requirement that the class, and <code>main</code> method, be public. Public accessibility is only relevant when access crosses packages; simple programs live in the unnamed package, so cannot be accessed from any other package anyway. For a program whose main class is in the unnamed package, we can drop the requirement that the class or its <code>main</code> method be public, effectively treating the <code>java</code> launcher as if it too resided in the unnamed package.</p>
</li>
<li>
<p>Make the “args” parameter to <code>main</code> optional, by allowing the <code>java</code> launcher to first look for a main method with the traditional <code>main(String[])</code> signature, and then (if not found) for a main method with no arguments.</p>
</li>
<li>
<p>Make the <code>static</code> modifier on <code>main</code> optional, by allowing the <code>java</code> launcher to invoke an instance <code>main</code> method (of either signature) by instantiating an instance using an accessible no-arg constructor and then invoking the <code>main</code> method on it.</p>
</li>
</ul>
<p>This small set of changes to the launch protocol strikes out five of the bullet points in the above list of concepts: public (twice), static, method parameters, and <code>String[]</code>.</p>
<p>At this point, our Hello World program is now:</p>
<pre><code>class HelloWorld { 
    void main() { 
        System.out.println(&#34;Hello World&#34;);
    }
}</code></pre>
<p>It’s not any shorter by line count, but we’ve removed a lot of “horizontal noise” along with a number of concepts. Students and educators will appreciate it, but advanced programmers are unlikely to be in any hurry to make these implicit elements explicit either.</p>
<p>Additionally, the notion of an “instance main” has value well beyond the first day. Because excessive use of <code>static</code> is considered a code smell, many educators encourage the pattern of “all the static <code>main</code> method does is instantiate an instance and call an instance <code>main</code> method” anyway. Formalizing the “instance main” protocol reduces a layer of boilerplate in these cases, and defers the point at which we have to explain what instance creation is — and what <code>static</code> is. (Further, allowing the <code>main</code> method to be an instance method means that it could be inherited from a superclass, which is useful for simple frameworks such as test runners or service frameworks.)</p>
</section><section id="unnamed-classes">
<h2><a href="#unnamed-classes">Unnamed classes</a></h2>
<p>In a simple program, the <code>class</code> declaration often doesn’t help either, because other classes (if there are any) are not going to reference it by name, and we don’t extend a superclass or implement any interfaces. If we say an “unnamed class” consists of member declarations without a class header, then our Hello World program becomes:</p>
<pre><code>void main() { 
    System.out.println(&#34;Hello World&#34;);
}</code></pre>
<p>Such source files can still have fields, methods, and even nested classes, so that as a program evolves from a few statements to needing some ancillary state or helper methods, these can be factored out of the <code>main</code> method while still not yet requiring a full class declaration:</p>
<pre><code>String greeting() { return &#34;Hello World&#34;; }

void main() {
    System.out.println(greeting());
}</code></pre>
<p>This is where treating <code>main</code> as an instance method really shines; the user has just declared two methods, and they can freely call each other. Students need not confront the confusing distinction between instance and static methods yet; indeed, if not forced to confront static members on day 1, it might be a while before they do have to learn this distinction. The fact that there is a receiver lurking in the background will come in handy later, but right now is not bothering anybody.</p>
<p><a href="https://openjdk.org/jeps/330">JEP 330</a> allows single-file programs to be launched directly without compilation; this streamlined launcher pairs well with unnamed classes.</p>
</section><section id="predefined-static-imports">
<h2><a href="#predefined-static-imports">Predefined static imports</a></h2>
<p>The most important classes, such as <code>String</code> and <code>Integer</code>, live in the <code>java.lang</code> package, which is automatically on-demand imported into all compilation units; this is why we do not have to <code>import java.lang.String</code> in every class. Static imports were not added until Java 5, but no corresponding facility for automatic on-demand import of common behavior was added at that time. Most programs, however, will want to do console IO, and Java forces us to do this in a roundabout way — through the static <code>System.out</code> and <code>System.in</code> fields. Basic console input and output is a reasonable candidate for auto-static import, as one or both are needed by most simple programs. While these are currently instance methods accessed through static fields, we can easily create static methods for <code>println</code> and <code>readln</code> which are suitable for static import, and automatically import them. At which point our first program is now down to:</p>
<pre><code>void main() {
    println(&#34;Hello World&#34;);
}</code></pre></section><section id="putting-this-all-together">
<h2><a href="#putting-this-all-together">Putting this all together</a></h2>
<p>We’ve discussed several simplifications:</p>
<ul>
<li>Update the launcher protocol to make public, static, and arguments optional for main methods, and for main methods to be instance methods (when a no-argument constructor is available);</li>
<li>Make the class wrapper for “main classes” optional (unnamed classes);</li>
<li>Automatically static import methods like <code>println</code></li>
</ul>
<p>which together whittle our long list of day-1 concepts down considerably. While this is still not as minimal as the minimal Python or Ruby program — statements must still live in a method — the goal here is not to win at “code golf”. The goal is to ensure that concepts not needed by simple programs need not appear in those programs, while at the same time not encouraging habits that have to be unlearned as programs scale up.</p>
<p>Each of these simplifications is individually small and unintrusive, and each is independent of the others. And each embodies a simple transformation that the author can easily manually reverse when it makes sense to do so: elided modifiers and <code>main</code> arguments can be added back, the class wrapper can be added back when the affordances of classes are needed (supertypes, constructors), and the full qualifier of static-import can be added back. And these reversals are independent of one another; they can done in any combination or any order.</p>
<p>This seems to meet the requirements of our on-ramp; we’ve eliminated most of the day-1 ceremony elements without introducing new concepts that need to be unlearned. The remaining concepts — a method is a container for statements, and a program is a Java source file with a <code>main</code> method — are easily understood in relation to their fully specified counterparts.</p>
</section><section id="alternatives">
<h2><a href="#alternatives">Alternatives</a></h2>
<p>Obviously, we’ve lived with the status quo for 25+ years, so we could continue to do so. There were other alternatives explored as well; ultimately, each of these fell afoul of one of our goals.</p>
<section id="cant-we-go-further">
<h3><a href="#cant-we-go-further">Can’t we go further?</a></h3>
<p>Fans of “code golf” — of which there are many — are surely right now trying to figure out how to eliminate the last little bit, the <code>main</code> method, and allow statements to exist at the top-level of a program. We deliberately stopped short of this because it offers little value beyond the first few minutes, and even that small value quickly becomes something that needs to be unlearned.</p>
<p>The fundamental problem behind allowing such “loose” statements is that variables can be declared inside both classes (fields) and methods (local variables), and they share the same syntactic production but not the same semantics. So it is unclear (to both compilers and humans) whether a “loose” variable would be a local or a field. If we tried to adopt some sort of simple heuristic to collapse this ambiguity (e.g., whether it precedes or follows the first statement), that may satisfy the compiler, but now simple refactorings might subtly change the meaning of the program, and we’d be replacing the explicit syntactic overhead of <code>void main()</code> with an invisible “line” in the program that subtly affects semantics, and a new subtle rule about the meaning of variable declarations that applies only to unnamed classes. This doesn’t help students, nor is this particularly helpful for all but the most trivial programs. It quickly becomes a crutch to be discarded and unlearned, which falls afoul of our “on ramp” goals. Of all the concepts on our list, “methods” and “a program is specified by a main method” seem the ones that are most worth asking students to learn early.</p>
</section>
<section id="why-not-just-use-jshell">
<h3><a href="#why-not-just-use-jshell">Why not “just” use <code>jshell</code>?</a></h3>
<p>While JShell is a great interactive tool, leaning too heavily on it as an onramp would fall afoul of our goals. A JShell session is not a program, but a sequence of code snippets. When we type declarations into <code>jshell</code>, they are viewed as implicitly static members of some unspecified class, with accessibility is ignored completely, and statements execute in a context where all previous declarations are in scope. This is convenient for experimentation — the primary goal of <code>jshell</code> — but not such a great mental model for learning to write Java programs. Transforming a batch of working declarations in <code>jshell</code> to a real Java program would not be sufficiently simple or unintrusive, and would lead to a non-idiomatic style of code, because the straightforward translation would have us redeclaring each method, class, and variable declaration as <code>static</code>. Further, this is probably not the direction we want to go when we scale up from a handful of statements and declarations to a simple class — we probably want to start using classes as classes, not just as containers for static members. JShell is a great tool for exploration and debugging, and we expect many educators will continue to incorporate it into their curriculum, but is not the on-ramp programming model we are looking for.</p>
</section>
<section id="what-about-always-local">
<h3><a href="#what-about-always-local">What about “always local”?</a></h3>
<p>One of the main tensions that <code>main</code> introduces is that most class members are not <code>static</code>, but the <code>main</code> method is — and that forces programmers to confront the seam between static and non-static members. JShell answers this with “make everything static”.</p>
<p>Another approach would be to “make everything local” — treat a simple program as being the “unwrapped” body of an implicit main method. We already allow variables and classes to be declared local to a method. We could add local methods (a useful feature in its own right) and relax some of the asymmetries around nesting (again, an attractive cleanup), and then treat a mix of declarations and statements without a class wrapper as the body of an invisible <code>main</code> method. This seems an attractive model as well — at first.</p>
<p>While the syntactic overhead of converting back to full-blown classes — wrap the whole thing in a <code>main</code> method and a <code>class</code> declaration — is far less intrusive than the transformation inherent in <code>jshell</code>, this is still not an ideal on-ramp. Local variables interact with local classes (and methods, when we have them) in a very different way than instance fields do with instance methods and inner classes: their scopes are different (no forward references), their initialization rules are different, and captured local variables must be effectively final. This is a subtly different programming model that would then have to be unlearned when scaling up to full classes. Further, the result of this wrapping — where everything is local to the main method — is also not “idiomatic Java”. So while local methods may be an attractive feature, they are similarly not the on-ramp we are looking for.</p>
</section>
</section>

</article></div>
  </body>
</html>
