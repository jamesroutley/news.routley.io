<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/AncientJames/multivox">Original</a>
    <h1>Multivox: Volumetric Display</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">This is the code I currently use to drive my <a href="https://www.youtube.com/watch?v=pcAEqbYwixU" rel="nofollow">volumetric displays</a>.</p>
<p dir="auto">It supports two closely related devices which are configured in the <code>src/driver/gadgets</code> directory:</p>
<ul dir="auto">
<li><a href="https://youtu.be/97cLIO7FNtw" rel="nofollow">Rotovox</a> is a 400mm Orb featuring two 128x64 panels arranged vertically side by side.</li>
<li><a href="https://youtu.be/Ozzpirkhi5c" rel="nofollow">Vortex</a> is a 300mm Orb featuring two 128x64 panels arranged horizontally, back to back.</li>
</ul>
<p dir="auto">Rotovox has a higher vertical resolution and better horizontal density; Vortex is brighter and has a higher refresh rate.</p>
<p dir="auto">The 3D printable parts for Vortex are available <a href="https://github.com/AncientJames/VortexParts">here</a>.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/AncientJames/multivox/blob/main/images/multivox.jpg"><img src="https://github.com/AncientJames/multivox/raw/main/images/multivox.jpg" alt="A photograph of two orbs, one running Doom, the other GTA"/></a></p>

<p dir="auto">This code was originally written for a single display, and the device specific code was later somewhat abstracted
out to support a second similar gadget. There are assumptions about the hardware that are pretty well baked in:</p>
<ul dir="auto">
<li>It consists of two HUB75 LED panels spinning around a vertical axis.</li>
<li>The panels use either ABCDE addressing or ABC shift register addressing.</li>
<li>It uses a single GPIO (a photodiode or similar) to sync to rotation - high for 180°, low for 180°.</li>
<li>It&#39;s running on a Raspberry Pi 4.</li>
</ul>
<p dir="auto">The GPIO mappings and panel layout are defined in <code>src/driver/gadgets/gadget_&lt;name&gt;.h</code>. GPIO is via memory mapped
access - if you&#39;re using a different model of Pi you&#39;ll need to change <code>BCM_BASE</code> in the GPIO code. I haven&#39;t tested
this, and you should probably assume it doesn&#39;t work.</p>
<p dir="auto">Input is via a bluetooth gamepad - I&#39;ve been using an Xbox controller, and the input system is based on the default
mapping for that.</p>
<p dir="auto">Audio out is also via bluetooth. I haven&#39;t had success with the higher quality codecs, but the headset protocol works.</p>

<p dir="auto">There are two parts to this code - the driver, which creates a voxel buffer in shared memory and scans its contents out
in sync with rotation, and the client code which generates content and writes it into the voxel buffer. Both driver
and client code are designed to run on the same device, a Raspberry Pi embedded in the hardware and spinning at several
hundred RPM. There is a demo included in the Python directory which streams point clouds from a PC over wifi to the
device, but fundamentally it&#39;s designed as a self contained gadget, like an alternate timeline Vectrex. A bluetooth
gamepad is used to control the demos.</p>
<div data-snippet-clipboard-copy-content="├── src
│   ├── driver
│   │   ├── gadgets         -- the different volumetric display configurations
│   │   │   └──             
│   │   └── vortex.c        -- driver code - creates a voxel buffer in shared memory,
│   │                          and handles scanning it out to the led panels in sync with
│   │                          the rotation
│   ├── simulator
│   │   └── virtex.c        -- software simulator - presents the same voxel buffer as
│   │                          the driver would, but renders the contents into an X11 window
│   │
│   ├── multivox            -- front end / launcher for the various volumetric toys
│   │   └──
│   ├── platform            -- common client code
│   │   └──
│   └── toys                -- a collection of volumetric demos using the shared voxel buffer
│       ├── eighty          -- multiplayer light cycles
│       ├── fireworks.c     -- cheesy first demo
│       ├── flight.c        -- some kind of 70s scifi thing
│       ├── tesseract.c     -- a 4D cubube
│       ├── viewer.c        -- viewer for .obj and .png files
│       └── zander          -- lander/zarch/virus-esque
├── python  
│   ├── calibration.py      -
│   ├── grid.py             -- some pattern generators, useful when calibrating the device
│   ├── colourwheel.py      -
│   ├── obj2c.py            -- tool for embedding .obj models in a header file
│   ├── pointvision.py      -- receive point clouds streamed from vortexstream.py
│   └── vortexstream.py     -- stream point clouds to pointvision.py
└── README.md               -- you are here"><pre><code>├── src
│   ├── driver
│   │   ├── gadgets         -- the different volumetric display configurations
│   │   │   └──             
│   │   └── vortex.c        -- driver code - creates a voxel buffer in shared memory,
│   │                          and handles scanning it out to the led panels in sync with
│   │                          the rotation
│   ├── simulator
│   │   └── virtex.c        -- software simulator - presents the same voxel buffer as
│   │                          the driver would, but renders the contents into an X11 window
│   │
│   ├── multivox            -- front end / launcher for the various volumetric toys
│   │   └──
│   ├── platform            -- common client code
│   │   └──
│   └── toys                -- a collection of volumetric demos using the shared voxel buffer
│       ├── eighty          -- multiplayer light cycles
│       ├── fireworks.c     -- cheesy first demo
│       ├── flight.c        -- some kind of 70s scifi thing
│       ├── tesseract.c     -- a 4D cubube
│       ├── viewer.c        -- viewer for .obj and .png files
│       └── zander          -- lander/zarch/virus-esque
├── python  
│   ├── calibration.py      -
│   ├── grid.py             -- some pattern generators, useful when calibrating the device
│   ├── colourwheel.py      -
│   ├── obj2c.py            -- tool for embedding .obj models in a header file
│   ├── pointvision.py      -- receive point clouds streamed from vortexstream.py
│   └── vortexstream.py     -- stream point clouds to pointvision.py
└── README.md               -- you are here
</code></pre></div>

<p dir="auto">On the Raspberry Pi, clone the repository:</p>
<div data-snippet-clipboard-copy-content="git clone https://github.com/AncientJames/multivox.git"><pre><code>git clone https://github.com/AncientJames/multivox.git
</code></pre></div>
<p dir="auto">Configure the project for your hardware:</p>
<div data-snippet-clipboard-copy-content="cd multivox
mkdir build
cd build
cmake -DMULTIVOX_GADGET=vortex ..
cmake --build ."><pre><code>cd multivox
mkdir build
cd build
cmake -DMULTIVOX_GADGET=vortex ..
cmake --build .
</code></pre></div>

<p dir="auto">First, the driver has to be running:</p>

<p dir="auto">When invoked from the command line it periodically outputs profiling information (frame rate, rotation rate), and accepts keyboard input for various diagnostics:</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Key</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td>esc</td>
<td>Exit</td>
</tr>
<tr>
<td>b</td>
<td>Bit depth - cycles through 1, 2 or 3 bits per channel. Higher bit depths result in lower refresh rates</td>
</tr>
<tr>
<td>u</td>
<td>Uniformity - cycles through different strategies for trading off brightness against uniformity</td>
</tr>
<tr>
<td>t</td>
<td>Trails - adjusts how far back to accumulate skipped voxels when the rotation rate is too high for the refresh rate</td>
</tr>
<tr>
<td>l</td>
<td>Lock - whether to adjust the rotation sync to keep it facing one way</td>
</tr>
<tr>
<td>d D</td>
<td>Drift - rotisserie mode. Introduces some explicit drift to the rotation sync</td>
</tr>
<tr>
<td>p</td>
<td>Panel - selectively disable the panels</td>
</tr>
<tr>
<td>xyz</td>
<td>Axis - When the display isn&#39;t spinning, it shows an othographic view. This lets you choose the axis</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto">While that&#39;s running, try one of the toys:</p>

<p dir="auto">The <code>viewer</code> takes a list of <em>.obj</em> and <em>.png</em> files as arguments. You can scale, rotate and so on using the gamepad, and it
also accepts keyboard input when run remotely from the command line.</p>
<div data-snippet-clipboard-copy-content="./viewer ~/Multivox/models/*.obj"><pre><code>./viewer ~/Multivox/models/*.obj
</code></pre></div>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Control</th>
<th>Key</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>esc</td>
<td>Exit</td>
</tr>
<tr>
<td>LB/RB</td>
<td>[ / ]</td>
<td>Cycle through models</td>
</tr>
<tr>
<td>A</td>
<td></td>
<td>Walkthrough / Orbit</td>
</tr>
<tr>
<td>X</td>
<td></td>
<td>Zoom to fit</td>
</tr>
<tr>
<td>Y</td>
<td></td>
<td>Toggle wireframe</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>

<p dir="auto">If you don&#39;t have a physical volumetric display, there&#39;s a simulator, <code>virtex</code>, which you can run in place of <code>vortex</code>. It exposes the same voxel buffer in shared memory, but renders the contents using OpenGL in an X11 window.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/AncientJames/multivox/blob/main/images/virtex.jpg"><img src="https://github.com/AncientJames/multivox/raw/main/images/virtex.jpg" alt="Screenshot of a tesseract rendered in Virtex"/></a></p>
<p dir="auto">Run without command line arguments it creates a display compatible with the currently configured gadget, but there are some options to let you experiment with different geometries:</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Option</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td>-s X</td>
<td>slice count - the number of vertical slices per revolution</td>
</tr>
<tr>
<td>-o X X</td>
<td>offsets - distance the front and back screens are offset from the axis, as a fraction of screen radius</td>
</tr>
<tr>
<td>-b X</td>
<td>bits per channel (1 - 3)</td>
</tr>
<tr>
<td>-w X Y</td>
<td>panel resolution</td>
</tr>
<tr>
<td>-g X</td>
<td>scan geometry - radial or linear. Linear looks better, but it&#39;s a lot harder to build.</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto">An idealised device with linear scanning and 3 bits per channel can be invoked like this:</p>
<div data-snippet-clipboard-copy-content="./virtex -g l -s 128 -w 1280 1280 -b 3"><pre><code>./virtex -g l -s 128 -w 1280 1280 -b 3
</code></pre></div>
<p dir="auto">The simulator is fill rate intensive; if you&#39;re running it on a Raspberry Pi you&#39;ll probably want to reduce the slice count.</p>

<p dir="auto">If you want it to start up automatically on boot, you can install <code>vortex</code> as a service, and set <code>multivox</code> to run on startup.</p>
<p dir="auto">First install everything to its default location <code>~/Multivox</code>:</p>
<blockquote>
<p dir="auto">make install</p>
</blockquote>
<p dir="auto">This will build the executable files and copy them into the destination directory, as well as creating <code>.mct</code> files in <code>~/Multivox/carts</code> for the built in toys.</p>
<p dir="auto">Create the driver service:</p>
<div data-snippet-clipboard-copy-content="sudo nano /usr/lib/systemd/system/vortex.service"><pre><code>sudo nano /usr/lib/systemd/system/vortex.service
</code></pre></div>
<p dir="auto">and fill in the following information:</p>
<div data-snippet-clipboard-copy-content="[Unit]
Description=Vortex Display Driver
After=multi-user.target

[Service]
ExecStart=/home/pi/Multivox/bin/vortex

[Install]
WantedBy=multi-user.target"><pre><code>[Unit]
Description=Vortex Display Driver
After=multi-user.target

[Service]
ExecStart=/home/pi/Multivox/bin/vortex

[Install]
WantedBy=multi-user.target
</code></pre></div>
<p dir="auto">Then start it up:</p>
<div data-snippet-clipboard-copy-content="sudo systemctl daemon-reload
sudo systemctl enable vortex.service"><pre><code>sudo systemctl daemon-reload
sudo systemctl enable vortex.service
</code></pre></div>
<p dir="auto">The driver assigns itself to core 3 - you can add <code>isolcpus=3</code> to the end of <code>/boot/cmdline.txt</code> to ensure it&#39;s the only thing running on that core.</p>
<p dir="auto">You&#39;ll also want the launcher to start up on boot:</p>

<p dir="auto">And add the line:</p>
<div data-snippet-clipboard-copy-content="@reboot /home/pi/Multivox/bin/multivox"><pre><code>@reboot /home/pi/Multivox/bin/multivox
</code></pre></div>

<p dir="auto">If everything goes smoothly, when you turn on the device it will boot up into <code>Multivox</code>. This is a fantasy console which
acts as a launcher for all the games and demos you run on the hardware. The bundled toys are automatically installed in
the <code>~/Multivox/carts/</code> directory as <code>.mct</code> files, and external apps can be launched by adding a <code>.mct</code> file containing
its command, path and arguments.</p>
<p dir="auto">Each <code>.mct</code> file appears as a cartridge in the Multivox front end. They should each have a label on the side; at the moment
all you can do to distinguish between them is change their colour in the <code>.mct</code>.</p>
<p dir="auto">When you exit an app back to the launcher, it saves a snapshot of the voxel volume, and this gives a preview of what you&#39;ll
see when you launch a cart. This means there are two competing representations of the same information, and any future work
on the front end will probably start with overhauling the entire approach.</p>
<p dir="auto">Some basic UI for controls such as changing bit depth, rebooting and so on would also be a boon.</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Control</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td>LB/RB</td>
<td>Cycle through carts</td>
</tr>
<tr>
<td>A</td>
<td>Launch cart</td>
</tr>
<tr>
<td>⧉</td>
<td>Exit / resume running cart</td>
</tr>
<tr>
<td>△ ▽</td>
<td>Change bit depth</td>
</tr>
<tr>
<td>☰ x5</td>
<td>Power off</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<hr/>
</article></div></div>
  </body>
</html>
