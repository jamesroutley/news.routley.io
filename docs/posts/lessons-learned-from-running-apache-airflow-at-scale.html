<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://shopify.engineering/lessons-learned-apache-airflow-scale">Original</a>
    <h1>Lessons learned from running Apache Airflow at scale</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
  <p><em><strong>By Megan Parker and Sam Wheating</strong></em></p>
<p><a href="https://airflow.apache.org/" target="_blank" title="Apache Airflow" rel="nofollow noopener noreferrer">Apache Airflow</a> is an orchestration platform that enables development, scheduling and monitoring of workflows. At Shopify, we’ve been running Airflow in production for over two years for a variety of workflows, including data extractions, <a href="https://shopify.engineering/merlin-shopify-machine-learning-platform" target="_blank" title="The Magic of Merlin: Shopify&#39;s New Machine Learning Platform" rel="nofollow noopener noreferrer">machine learning model training</a>, Apache Iceberg table maintenance, and <a href="https://shopify.engineering/build-production-grade-workflow-sql-modelling" target="_blank" title="How to Build a Production Grade Workflow with SQL Modelling" rel="nofollow noopener noreferrer">DBT-powered data modeling</a>. At the time of writing, we are currently running Airflow 2.2 on Kubernetes, using the Celery executor and MySQL 8.</p>
<figure><img alt="System diagram showing Shopify&#39;s Airflow Architecture" data-src="https://cdn.shopify.com/s/files/1/0779/4361/files/ShopifyAirflowArchitecture.png?format=jpg&amp;quality=90&amp;v=1653312100"/>
<figcaption>Shopify’s Airflow Architecture</figcaption>
</figure>
<p>Shopify’s usage of Airflow has scaled dramatically over the past two years. In our largest environment, we run over 10,000 DAGs representing a large variety of workloads. This environment averages over 400 tasks running at a given moment and over 150,000 runs executed per day. As adoption increases within Shopify, the load incurred on our Airflow deployments will only increase. As a result of this rapid growth, we have encountered a few challenges, including slow file access, insufficient control over DAG (directed acyclic graph) capabilities, irregular levels of traffic, and resource contention between workloads, to name a few.</p>
<p>Below we’ll share some of the lessons we learned and solutions we built in order to run Airflow at scale.</p>

<p>Fast file access is critical to the performance and integrity of an Airflow environment. A well defined strategy for file access ensures that the scheduler can process DAG files quickly and keep your jobs up-to-date.</p>
<p>Airflow keeps its internal representation of its workflows up-to-date by repeatedly scanning and reparsing all the files in the configured DAG directory. These files must be scanned often in order to maintain consistency between the on-disk source of truth for each workload and its in-database representation. This means the contents of the DAG directory must be consistent across all schedulers and workers in a single environment (<a href="https://airflow.apache.org/docs/helm-chart/stable/manage-dags-files.html" target="_blank" title="Airflow Apache - Manage DAGs files" rel="nofollow noopener noreferrer">Airflow suggests a few ways of achieving this</a>).</p>
<p>At Shopify, we use Google Cloud Storage (GCS) for the storage of DAGs. Our initial deployment of Airflow utilized <a href="https://github.com/GoogleCloudPlatform/gcsfuse" target="_blank" title="gcsfuse is a user-space file system for interacting with Google Cloud Storage." rel="nofollow noopener noreferrer">GCSFuse</a> to maintain a consistent set of files across all workers and schedulers in a single Airflow environment. However, at scale this proved to be a bottleneck on performance as every file read incurred a request to GCS. The volume of reads was especially high because every pod in the environment had to mount the bucket separately.</p>
<p>After some experimentation we found that we could vastly improve performance across our Airflow environments by running an NFS (network file system) server within the Kubernetes cluster. We then mounted this NFS server as a read-write-many volume into the worker and scheduler pods. We wrote a custom script which synchronizes the state of this volume with  GCS, so that users only have to interact with GCS for uploading or managing DAGs. This script runs in a separate pod within the same cluster. This also allows us to conditionally sync only a subset of the DAGs from a given bucket, or even sync DAGs from multiple buckets into a single file system based on the environment’s configuration (more on this later).</p>
<p>Altogether this provides us with fast file access as a stable, external source of truth, while maintaining our ability to quickly add or modify DAG files within Airflow. Additionally, we can use Google Cloud Platform’s IAM (identify and access management) capabilities to control which users are able to upload files to a given environment. For example, we allow users to upload DAGs directly to the staging environment but limit production environment uploads to our continuous deployment processes.</p>
<p>Another factor to consider when ensuring fast file access when running Airflow at scale is your file processing performance. Airflow is highly configurable and offers several ways to tune the background file processing (such as <a href="https://airflow.apache.org/docs/apache-airflow/stable/configurations-ref.html#file-parsing-sort-mode" target="_blank" title="Apache Airflow - file_parsing_sort_mode" rel="nofollow noopener noreferrer">the sort mode</a>, <a href="https://airflow.apache.org/docs/apache-airflow/stable/configurations-ref.html#parsing-processes" target="_blank" title="Apache Airflow - parsing_processes" rel="nofollow noopener noreferrer">the parallelism</a>, and <a href="https://airflow.apache.org/docs/apache-airflow/stable/configurations-ref.html#dag-file-processor-timeout" target="_blank" title="Airflow Apache - dag_file_processor_timeout" rel="nofollow noopener noreferrer">the timeout</a>). This allows you to optimize your environments for interactive DAG development or scheduler performance depending on the requirements.</p>

<p>In a normal-sized Airflow deployment, performance degradation due to metadata volume wouldn’t be an issue, at least within the first years of continuous operation.</p>
<p>However, at scale the metadata starts to accumulate pretty fast. After a while this can start to incur additional load on the database. This is noticeable in the loading times of the Web UI and even more so during Airflow upgrades, during which migrations can take <em>hours</em>.</p>
<p>After some trial and error, we settled on a metadata retention policy of 28 days, and implemented a simple DAG which uses ORM (object–relational mapping) queries within a PythonOperator to delete rows from any tables containing historical data (DagRuns, TaskInstances, Logs, TaskRetries, etc). We settled on 28 days as this gives us sufficient history for managing incidents and tracking historical job performance, while keeping the volume of data in the database at a reasonable level.</p>

<p>Unfortunately, this means that features of Airflow which rely on durable job history (for example, long-running backfills) aren’t supported in our environment. This wasn’t a problem for us, but it may cause issues depending on your retention period and usage of Airflow.</p>
<p>As an alternative approach to a custom DAG, Airflow has <a href="https://github.com/apache/airflow/pull/20838" target="_blank" title="Add db clean CLI command for purging old data #20838" rel="nofollow noopener noreferrer">recently added support</a> for a <code>db clean</code> command which can be used to remove old metadata. This command is available in Airflow version 2.3.</p>

<p>When running Airflow in a multi-tenant setting (and especially at a large organization), it’s important to be able to trace a DAG back to an individual or team. Why? Because if a job is failing, throwing errors or interfering with other workloads, us administrators can quickly reach out to the appropriate users.</p>
<p>If all of the DAGs were deployed directly from one repository, we could simply use <code>git blame</code> to track down the job owner. However, since we allow users to deploy workloads from their own projects (and even dynamically generate jobs at deploy-time), this becomes more difficult.</p>
<p>In order to easily trace the origin of DAGs, we introduced a registry of Airflow <em>namespaces</em>, which we refer to as an Airflow environment’s <em>manifest file</em>.</p>

<p>The<em> manifest file</em> is a YAML file where users must register a namespace for their DAGs. In this file they will include information about the jobs’ owners and source github repository (or even source GCS bucket), as well as define some basic restrictions for their DAGs. We maintain a separate manifest per-environment and upload it to GCS alongside with the DAGs.</p>

<p>By allowing users to directly write and upload DAGs to a shared environment, we’ve granted them a lot of power. Since Airflow is a central component of our data platform, it ties into a lot of different systems and thus jobs have wide-ranging access. While we trust our users, we still want to maintain some level of control over what they can and cannot do within a given Airflow Environment. This is especially important at scale as it becomes unfeasible for the Airflow administrators to review all jobs before they make it to production.</p>
<p>In order to create some basic guardrails, we’ve implemented a <a href="https://airflow.apache.org/docs/apache-airflow/stable/concepts/cluster-policies.html" target="_blank" title="Apache Airflow Cluster Policies" rel="nofollow noopener noreferrer">DAG policy</a> which reads configuration from the previously mentioned Airflow manifest, and rejects DAGs which don’t conform to their namespace’s constraints by raising an <code>AirflowClusterPolicyViolation</code>.</p>
<p>Based on the contents of the <em>manifest file</em>, this policy will apply a few basic restrictions to DAG files, such as:</p>
<ul>
<li>
<strong><em>A DAG ID must be prefixed with the name of an existing namespace</em></strong>, for ownership.</li>
<li>
<strong><em>Tasks in a DAG must only enqueue tasks to the specified celery queue</em></strong>—more on this later.</li>
<li>
<strong><em>Tasks in a DAG can only be run in specified pools</em></strong>, to prevent one workload from taking over another’s capacity.</li>
<li>
<strong><em>Any KubernetesPodOperators in this DAG must only launch pods in the specified</em></strong> <strong><em>namespaces</em></strong>, to prevent access to other namespace’s secrets.</li>
<li><strong>Tasks in a DAG can only launch pods into specified sets of external kubernetes clusters</strong></li>
</ul>
<p>This policy can be extended to enforce other rules (for example, only allowing a limited set of operators), or even mutate tasks to conform to a certain specification (for exampke, adding a namespace-specific execution timeout to all tasks in a DAG).</p>
<p>Here’s a simplified example demonstrating how to create a DAG policy which reads the previously shared <em>manifest file,</em> and implements the first three of the controls mentioned above:</p>

<p>These validations provide us with sufficient traceability while also creating some basic controls which reduce DAGs abilities to interfere with each other.</p>

<p>It’s very tempting to use an absolute interval for your DAGs schedule interval—simply set the DAG to run every <code>timedelta(hours=1)</code> and you can walk away, safely knowing that your DAG will run approximately every hour. However, this can lead to issues at scale.</p>
<p>When a user merges a large number of automatically-generated DAGs, or writes a python file which generates many DAGs at parse-time, all the DAGRuns will be created at the same time. This creates a large surge of traffic which can overload the Airflow scheduler, as well as any external services or infrastructure which the job is utilizing (for example, a Trino cluster).</p>
<p>After a single <code>schedule_interval</code> has passed, all these jobs will run again at the same time, thus leading to another surge of traffic. Ultimately, this can lead to suboptimal resource utilization and increased execution times.</p>
<p>While crontab-based schedules won’t cause these kinds of surges, they come with their own issues. Humans are biased towards human-readable schedules, and thus tend to create jobs which run at the top of every hour, every hour, every night at midnight, etc. Sometimes there’s a valid application-specific reason for this (for example, every night at midnight we want to extract the previous day’s data), but often we have found users just want to run their job on a regular interval. Allowing users to directly specify their own crontabs can lead to bursts of traffic which can impact SLOs and put uneven load on external systems.</p>
<p>As a solution to both these issues, we use a deterministically randomized schedule interval for all automatically generated DAGs (which represent the vast majority of our workflows). This is typically based on a hash of a constant seed such as the <code>dag_id</code>.</p>
<p>The below snippet provides a simple example of a function which generates deterministic, random crontabs which yield constant schedule intervals. Unfortunately, this limits the range of possible intervals since not all intervals can be expressed as a single crontab. We have not found this limited choice of schedule intervals to be limiting, and in cases when we <em>really</em> need to run a job every five hours, we just accept that there will be a single four hours interval each day.</p>

<p>Thanks to our randomized schedule implementation, we were able to smooth the load out significantly. The below image shows the number of tasks completed every 10 minutes over a twelve hour period in our single largest Airflow environment.</p>
<figure><img alt="Bar graph showing the Tasks Executed versus time. Shows a per 10–minute Interval in our Production Airflow Environment" data-src="https://cdn.shopify.com/s/files/1/0779/4361/files/TaskInstancesSuccessFailures.png?format=jpg&amp;quality=90&amp;v=1653313762"/><figcaption>Tasks Executed per 10–minute Interval in our Production Airflow Environment</figcaption></figure>

<p>There’s a lot of possible points of resource contention within Airflow, and it’s really easy to end up chasing bottlenecks through a series of experimental configuration changes. Some of these resource conflicts can be handled within Airflow, while others may require some infrastructure changes. Here’s a couple of ways which we handle resource contention within Airflow at Shopify:</p>
<h2>Pools</h2>
<p>One way to reduce resource contention is to use Airflow <a href="https://airflow.apache.org/docs/apache-airflow/stable/concepts/pools.html" target="_blank" title="Apache Airflow Pools" rel="nofollow noopener noreferrer">pools</a>. Pools are used to limit the concurrency of a given set of tasks. These can be really useful for reducing disruptions caused by bursts in traffic. While pools are a useful tool to enforce task isolation, they can be a challenge to manage because only administrators have access to edit them via the Web UI.</p>
<p>We wrote a custom DAG which synchronizes the pools in our environment with the state specified in a Kubernetes Configmap via some simple ORM queries. This lets us manage pools alongside the rest of our Airflow deployment configuration and allows users to update pools via a reviewed Pull Request without needing elevated access. </p>
<h2>Priority Weight</h2>
<p><a href="https://airflow.apache.org/docs/apache-airflow/stable/concepts/priority-weight.html#priority-weights" target="_blank" title="Apache Airflow Priority Weights" rel="nofollow noopener noreferrer"><code>Priority_weight</code></a> allows you to assign a higher priority to a given task. Tasks with a higher priority will float to the top of the pile to be scheduled first. Although not a direct solution to resource contention, <code>priority_weight</code> can be useful to ensure that latency-sensitive critical tasks are run prior to lower priority tasks. However, given that the <code>priority_weight</code> is an arbitrary scale, it can be hard to determine the actual priority of a task without comparing it to all other tasks. We use this to ensure that our basic Airflow monitoring DAG (which emits simple metrics and powers some alerts) always runs as promptly as possible.</p>
<p>It’s also worthwhile to note that by default, the effective <code>priority_weight</code> of a task used when making scheduling decisions is the <a href="https://airflow.apache.org/docs/apache-airflow/stable/configurations-ref.html#default-task-weight-rule" target="_blank" title="Apache Airflow default_task_weight_rule" rel="nofollow noopener noreferrer">sum of its own weight and that of all its downstream tasks</a>. What this means is that upstream tasks in large DAGs are often favored over tasks in smaller DAGs. Therefore, using <code>priority_weight</code> requires some knowledge of the other DAGs running in the environment.</p>
<h2>Celery Queues and Isolated Workers</h2>
<p>If you need your tasks to execute in separate environments (for example, dependencies on different python libraries, higher resource allowances for intensive tasks, or differing level of access), you can create additional queues which a subset of jobs submit tasks to. Separate sets of workers can then be configured to pull from separate queues. A task can be assigned to a separate queue using the <code>queue</code> argument in operators. To start a worker which runs tasks from a different queue, you can use the following command:</p>
<p><code>bashAirflow celery worker –queues &lt;list of queues&gt;</code></p>
<p>This can help ensure that sensitive or high-priority workloads have sufficient resources, as they won’t be competing with other workloads for worker capacity.</p>
<p>Any combination of pools, priority weights and queues can be useful in reducing resource contention. While pools allow for limiting concurrency within a single workload, a <code>priority_weight</code> can be used to make individual tasks run at a lower latency than others. If you need even more flexibility, worker isolation provides fine-grained control over the environment in which your tasks are executed.</p>
<p>It’s important to remember that not all resources can be carefully allocated in Airflow—scheduler throughput, database capacity and Kubernetes IP space are all finite resources which can’t be restricted on a workload-by-workload basis without the creation of isolated environments.</p>

<p>There are many considerations that go into running Airflow with such high throughput, and any combination of solutions can be useful. We’ve learned a ton and we hope you’ll remember these lessons and apply some of our solutions in your own Airflow infrastructure and tooling.</p>
<p>To sum up our key takeaways:</p>
<ul>
<li><span>A combination of GCS and NFS allows for both performant and easy to use file management.</span></li>
<li><span>Metadata retention policies can reduce degradation of Airflow performance.</span></li>
<li><span>A centralized metadata repository can be used to track DAG origins and ownership.</span></li>
<li><span>DAG Policies are great for enforcing standards and limitations on jobs.</span></li>
<li><span>Standardized schedule generation can reduce or eliminate bursts in traffic.</span></li>
<li><span>Airflow provides multiple mechanisms for managing resource contention.</span></li>
</ul>
<p>What’s next for us? We’re currently working on applying the principles of scaling Airflow in a single environment as we explore splitting our workloads across multiple environments. This will make our platform more resilient, allow us to fine-tune each individual Airflow instance based on its workloads’ specific requirements, and reduce the reach of any one Airflow deployment.</p>
<p>Got questions about implementing Airflow at scale? You can reach out to either of the authors on the Apache Airflow slack community.</p>
<p><strong>Megan</strong> has worked on the data platform team at Shopify for the past 9 months where she has been working on enhancing the user experience for Airflow and Trino. Megan is located in Toronto, Canada where she enjoys any outdoor activity, especially biking and hiking.</p>
<p><strong>Sam</strong> is a Senior developer from Vancouver, BC who has been working on the Data Infrastructure and Engine Foundations teams at Shopify for the last 2.5 years. He is an internal advocate for open source software and a recurring contributor to the Apache Airflow project.</p>
<hr/>
<p>Interested in tackling challenging problems that make a difference? Visit our Data Science &amp; Engineering <a href="https://www.shopify.ca/careers/teams/data?shpxid=418c474d-224A-428F-942E-A33D556FD22B" target="_blank">career page</a> to browse our open positions. You can also contribute to <a href="https://github.com/apache/airflow" target="_blank" rel="nofollow noopener noreferrer">Apache Airflow</a> to improve Airflow for everyone.</p>
</div></div>
  </body>
</html>
