<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/Articles/990177/">Original</a>
    <h1>Debian’s “secret” sauce</h1>
    
    <div id="readability-page-1" class="page"><div>

<p>
While Debian&#39;s &#34;sauce&#34; is not actually all that secret, it is not particularly
well-known either, Samuel Henrique said at the start of his <a href="https://debconf24.debconf.org/">DebConf24</a> talk.  There is a lot
of software-engineering effort that has been put in place by the
distribution in order to create and maintain its releases, but &#34;<q>loads of
people are not aware</q>&#34; of it.  That may be due to the fact that all of
that is
not really documented anywhere in a central location that he can just point
someone to.  Recognizing that is what led him to give the talk;
hopefully it will be a &#34;<q>first step toward</q>&#34; helping solve the problem.
</p>

<p>
Henrique said that he is a Brazilian and has been a Debian Developer since 2018.
He mostly 
works in the <a href="https://wiki.debian.org/Teams/pkg-security">security
tools packaging team</a>, but also maintains some packages outside of that
team, including curl and rsync.  In addition, he mentors Debian newcomers, mostly
on packaging tasks. He works on the Amazon Linux security team.  He
noted that his <a href="https://samueloph.dev/">web site</a> contains links
to the <a href="https://raw.githubusercontent.com/samueloph/personal_website_files/main/slides/samueloph_slides_2024_08_the_secret_sauce_of_debian.pdf">slides</a>
from the talk; a <a href="https://saimei.ftp.acc.umu.se/pub/debian-meetings/2024/DebConf24/debconf24-151-the-secret-sauce-of-debian.av1.webm">WebM
video</a> is also available.  [<b>Update</b>: A <a href="https://www.youtube.com/watch?v=x_X2IBnpjic">YouTube video</a> with subtitles in English and Portuguese is also available.]
</p>

<h4>Underpinnings</h4>

<p><a href="https://lwn.net/Articles/992707/">
<img src="https://static.lwn.net/images/2024/debconf-henrique-sm.png" alt="[Samuel Henrique]" title="Samuel Henrique" width="218" height="280"/>
</a></p><p>
A distribution is a project set up to distribute software; it can choose
defaults or tweak how a software package behaves to make it easier to use, for
example, as part of that work.  But it is important not to ship bugs or
other issues, including 
security problems, in those packages.  Some distributions try to stay as
close as possible to the upstream code, but &#34;<q>in Debian, we like to
improve things</q>&#34; by &#34;<q>applying our own judgment</q>&#34; to the code.
</p>

<p>
Beyond that, the project needs to support whatever it is that gets shipped.
That means there is a need to put procedures in place to &#34;<q>make sure we
are following up with reported issues</q>&#34; and fixing them.  At all times,
the project needs to be supporting the current Debian stable release, while
developing the next stable release. &#34;<q>We have to do both things at the
same time, and so that is a constant process.</q>&#34;
</p>

<p>
The <a href="https://www.debian.org/social_contract">Debian social
contract</a> aligns the project in an &#34;<q>ideological manner</q>&#34;; it
provides a definition for &#34;free software&#34;, for example.  The <a href="https://www.debian.org/devel/constitution">Debian constitution</a>
provides a framework for how the project operates, how it apportions power,
how it makes its decisions, and so on.  On a technical level, the <a href="https://www.debian.org/doc/debian-policy/">policy manual</a>
describes how packages should (and should not) operate, as well as how they
should be put together.  And, finally, the <a href="https://www.debian.org/doc/manuals/developers-reference/index.en.html">developer&#39;s
reference</a> is meant to give recommendations to packagers on how to
follow the policies and to describe tools that can help.  Those documents
help create a &#34;<q>tight organization where we are all sharing the same
goals, following the same rules, roughly speaking</q>&#34;, which serves as a
basis for the work that the project does.
</p>

<h4>Forms of Debian</h4>

<p>
There are multiple releases and repositories that the project works with,
Henrique said.  For example, a Debian developer who wants to try something
out might push it to the <a href="https://wiki.debian.org/DebianExperimental">Debian experimental</a> repository, which typically
only has a few packages.  Experimental is not a full release, so it
requires being enabled on a system running <a href="https://wiki.debian.org/DebianUnstable">Debian unstable</a>, then packages
from experimental can be installed.
</p>

<!-- middle-ad -->

<p>
Unstable, also known as &#34;sid&#34;, is a
full release, so it can be installed on a system.  Unstable is a rolling
release that is &#34;<q>constantly being updated</q>&#34; and is not officially supported, so &#34;<q>you should not be installing
this on your production servers</q>&#34;.  <a href="https://wiki.debian.org/DebianTesting">Debian testing</a> is also a rolling
release, but it is &#34;<q>more stable than Debian unstable</q>&#34;
</p>

<p>
Finally, there is <a href="https://wiki.debian.org/DebianStable">Debian
stable</a>, &#34;<q>which is what you should be running on production
servers</q>&#34;.  There is also <a href="https://wiki.debian.org/DebianOldStable">oldstable</a>, which is the
previous stable release that is still being supported.  The <a href="https://wiki.debian.org/Backports">backports</a> repository provides
&#34;<q>newer packages for users of Debian stable</q>&#34;; it is meant to give
users flexibility, but it is &#34;<q>not officially supported</q>&#34; as a
release.
</p>

<h4>Architectures</h4>

<p>
Debian supports 20 architectures, &#34;<q>nine of them are official, 11 of them
are not official</q>&#34;.  Being official means that all of the packages in
stable and oldstable are 
built for them, as are the packages in unstable, testing, and experimental.
The non-official architectures only get packages built for <strike>stable</strike> unstable, testing, and
experimental.  The list of architectures is &#34;<q>constantly changing</q>&#34;;
the Debian <a href="https://wiki.debian.org/Teams/ReleaseTeam">release
team</a> determines which architectures are official or not before each new
stable release.  That decision
generally comes down to a question of long-term support for an
architecture, he said: will there be sufficient infrastructure to build the
packages and enough people to help support them?
</p>

<p>
Henrique put up a screen shot from the <a href="https://buildd.debian.org/">buildd.debian.org web site</a>, which
showed the <a href="https://buildd.debian.org/status/package.php?p=coreutils&amp;suite=sid">build
status of the coreutils package</a> on sid for all of the architectures.
It shows green for a successful build and red for a failure (only hurd-i386
currently and in his screen shot). The page shows the logs of the build
failure; the results of earlier builds and other releases can also be seen
at the site.
</p>

<p>
Supporting multiple architectures matters, he said, because it finds bugs.
Currently, Debian supports two architectures for non-Linux kernels, both for <a href="https://www.gnu.org/software/hurd/">GNU Hurd</a> on x86 systems,
though it used 
to also support <a href="https://wiki.debian.org/Debian_GNU/kFreeBSD">kFreeBSD</a>. It
supports both big- and little-endian systems, as well as 32- and 64-bit
architectures; there is also diversity in the size of C data types.  All of
that is <a href="https://wiki.debian.org/ArchitectureSpecificsMemo">summarized on the
Debian wiki</a>.  That diversity makes it easier to find problems in
upstream software, even when the developer does not have access to, say, a
big-endian system to test with. &#34;<q>So if your software is packaged for
Debian, you&#39;re at least going to know if it runs or not</q>&#34;; maintainers may
care about that or might not, but they will at least know.
</p>

<p>
Henrique pointed to a <a href="https://github.com/benhoyt/goawk/commit/63ba6482a374376f49378b47a4296065fa4348bd">fix
to the tests</a>
for <a href="https://github.com/benhoyt/goawk?tab=readme-ov-file#goawk-an-awk-interpreter-with-csv-support">GoAWK</a>, which is an
AWK implementation in Go, when it is built on 32-bit systems.  It had been packaged
for Debian and entered the distribution as part of the unstable release
when the problem was discovered; the Debian maintainer <a href="https://github.com/benhoyt/goawk/issues/234">reported it
upstream</a> and developed a fix.  Debian was apparently the first to build
and test GoAWK on 32-bit systems.
</p>

<p>
Another example is a bug he <a href="https://github.com/aircrack-ng/aircrack-ng/issues/2324">reported</a>
in the <a href="https://aircrack-ng.org/">Aircrack-ng</a> WiFi-security
tool.  It turned out to be a problem building and running the tests on
big-endian systems. This kind of thing has
happened before, he said,  and is fairly easy to spot because all five
big-endian architectures suddenly start reporting build/test problems.
</p>

<h4>Repositories</h4>

<p>
Henrique created the following diagram to help attendees understand how
packages flow into the development repositories: experimental, unstable,
and testing.  The Debian developer in the upper left has four different
places where they can send a new or updated package.  They can directly put
the package into the experimental or unstable repositories, or they can
send updates that are bound for testing to either the release team, for regular
updates, or the security team, for security fixes.
</p>

<blockquote>
<a href="https://lwn.net/Articles/992708/">
<img src="https://static.lwn.net/images/2024/debconf-henrique-slide-sm.png" alt="[Diagram slide]" title="Diagram slide"/>
</a>
</blockquote>

<p>
He noted that the experimental repository was not further connected in the
diagram, &#34;<q>it goes nowhere</q>&#34;, which makes sense because of how it is
used.  The repository makes it &#34;<q>very easy to test things</q>&#34;.  For
example, if 
he wanted to enable a new architecture for a package and make it available
to others for testing, he could upload it to experimental; that will also
cause some of the automated testing to happen, which will generate useful
reports. &#34;<q>I get a preview of what would have happened if I sent this package
to unstable.</q>&#34;
</p>

<p>
It is easy to revert changes in experimental, as the package can simply be
removed.  In addition, successful changes can be pushed to unstable, which
allows having two variants of the same package available at the same time.
The curl packagers recently used that ability when the TLS backend was being
changed from OpenSSL to GnuTLS; the GnuTLS version stayed on experimental
for a month or so, while the OpenSSL version was updated several times on
unstable. 
</p>

<p>
The unstable repository does not provide a supported release, but it does
have all of the packages available, unlike experimental.  It is &#34;<q>installed
and used by expert users</q>&#34;, however; since it is the first place that new
packages show up, a lot of developers make use of it, he said.  Packages in
unstable get full coverage from the testing and QA infrastructure. It is
&#34;<q>important not to break things too badly</q>&#34; because it risks breaking
other packages; for risky changes, experimental should be used instead.
</p>

<p>
Packages in unstable automatically migrate to testing &#34;<q>after some rules
are followed</q>&#34;; the package needs to be passing its tests and spend some
time in unstable before it gets promoted.  While testing is not supported
either, it is generally much more stable than unstable since the packages
there are bound for the next Debian stable release.  There were some recent
problems with the <a href="https://lwn.net/Articles/938149/">64-bit <tt>time_t</tt> transition</a> that affected testing,
however, which is the kind of thing &#34;<q>that happens every 20 years,
maybe</q>&#34;; that shows that testing can still break, but it is &#34;<q>quite
stable</q>&#34; overall.
</p>

<p>
Unlike experimental or unstable, testing has an installer available, so
that the installer team can test it before releasing. That means testing
can be installed from scratch.  He recommends testing for non-server use
cases, desktops for example.  &#34;<q>I believe it is as stable as any other
rolling release</q>&#34; due to all of the checks and procedures that the
distribution has put in place.
</p>

<h4>Stable</h4>

<p>
When thinking about Debian stable, there are two parts to consider,
Henrique said: its creation and its maintenance.  The creation happens
every two years, by using a snapshot of testing; once it is created,
packages are not updated as they are for unstable or testing.  Users
running stable are looking for something that is predictable, not something
that is bug-free; &#34;<q>the point is there won&#39;t be ten new bugs showing [up]
each
day</q>&#34;.
</p>

<p>
But there needs to be a time when packages cannot freely flow from unstable
to testing in order to stabilize something that will become stable.  The
release team has a <a href="https://release.debian.org/testing/freeze_policy.html">freeze
process</a> that changes the ability of packages to migrate to testing.
The requirements for package migration change and get stricter as the
various phases of the freeze process progress; in the final phase, any
changes need to be manually reviewed and approved by the release team.
</p>

<p>
The last freeze, for the <a href="https://www.debian.org/releases/bookworm/">Debian 12 (&#34;bookworm&#34;)</a>
release, lasted around six months.  During the freeze, there is less
activity in the unstable and testing repositories, because the focus is on
fixing what is in testing; but updates that are bound for testing are still
being pushed to unstable.
</p>

<p>
Some of the packages pushed to unstable during a freeze may not be bound
for stable, however; if there is a need for a fix to the version of that
package in testing, a different path must be taken.  That is where the
testing-proposed-updates and testing-security repositories (from the
diagram) come into play; with manual review from the release or security
team, patches can go into those repositories and then to testing from there.
</p>

<p>
Once there has been a stable release, though, the path for package updates
also requires manual review by one of the teams depending &#34;<q>on the nature
of the fix</q>&#34;, Henrique said.  Critical security fixes, such as for a CVE, might go
directly into 
stable, but others will  &#34;<q>spend baking time in the proposed-updates</q>&#34;
repository; the normal requirement is that packages spend a week in
proposed-updates before moving to stable.  Periodically, the release team
will pause migrations from proposed-updates to stable in order to create a
point release.
</p>

<h4>Tools</h4>

<p>
There are &#34;<q>a million tools in Debian</q>&#34; that can be used for doing
various kinds of testing, such as for continuous integration (CI) or
general QA.  He chose to focus on a few of those in his talk, but all of
them are freely available; &#34;<q>anybody can just query all of the build logs
of Debian packages, identify a pattern of something that&#39;s wrong, and
provide patches</q>&#34; to fix the problems found.  For those who are curious,
the <a href="https://wiki.debian.org/qa.debian.org">Debian QA group wiki page</a>
covers the full set of tools and the processes the group uses.
</p>

<p>
The <a href="https://manpages.debian.org/bookworm/debhelper/dh_auto_test.1.en.html">dh_auto_test
tool</a> is hooked into the package-building system and tries to run the
upstream tests once the package is built.  It can detect things like
testing targets in makefiles and run them automatically, but if it cannot
determine how to run the tests, it can be configured to run any tests of
interest.  It is meant to confirm that the package works in the Debian
environment, for all of its architectures, and with the build flags
(including hardening options) that the distribution uses.  Even though the
upstream project is also running its tests, the dependencies that Debian
uses may be different; &#34;<q>sometimes we spot issues</q>&#34; because of
all of those differences.
</p>

<p>
<a href="https://wiki.debian.org/Lintian">Lintian</a> does lots of
different tests on packages to find &#34;<q>silly things, like spelling
mistakes</q>&#34; or more serious problems like the presence of binary blobs
without source files.  It is hooked into the build process and if it
detects problems that are serious enough, the package will be rejected.
His first contribution to the curl package was for a problem detected
by lintian: curl 
was still using Python 2 in its tests after the distribution had switched to Python 3,
which was <a href="https://github.com/curl/curl/pull/7899/commits/ce432e0fe642c003a76db32a8aab3706c4decbd2">easy to fix</a>.
</p>

<p>
<a href="https://wiki.debian.org/ContinuousIntegration/autopkgtest">Autopkgtest</a>
standardizes the test definitions for packages so that they can be run as
part of the CI system.  These tests are not build-time tests, but are used
to run end-to-end tests of the packaged software.  The autopkgtest scripts
often include running the upstream tests, but additional tests are
generally added; &#34;<q>you have a lot of freedom here</q>&#34; to add
dependencies needed to test the software in various ways.
</p>

<p>
While autopkgtest is the mechanism used, <a href="https://wiki.debian.org/debci">debci</a> is the service that runs the
tests continuously, the results of which can be seen at <a href="https://ci.debian.net/">ci.debian.net</a>.  It runs these tests
&#34;<q>on a long list of architectures</q>&#34; for each change, though not all of
the architectures that the
distribution supports.  The main artifact that it produces is reports of
the tests, which can be used to determine whether the package should
migrate from unstable to testing.
</p>

<p>
A given package will be tested, but there is more to it than that; its
dependencies are also being tested, as are the packages which either depend
on it or have tests
that do.  The intent is to find regressions where the previous version of
the package was passing, but it no longer does; so, when tests fail, the
previous version is tested to see if it also fails.  So if package A gets
uploaded to unstable, debci will look at which packages depend on it and
find package B, for example; it will then run the tests for B using both
the old and new versions of A and compare the results.  That can all be
seen on <a href="https://tracker.debian.org/">tracker.debian.org</a> on a
per-package basis, such as for the <a href="https://tracker.debian.org/pkg/glibc">glibc package</a>.
</p>

<p>
He gave two examples of where this process finds bugs that may have gone
unnoticed otherwise.  A <a href="https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=989179">2021 test
failure</a> for the aeskeyfind utility, which is a forensic tool to find
AES keys in memory, silently failed because it was relying on undefined behavior
that changed due to a different GCC version.  Since aeskeyfind is
unmaintained, other distributions may also have the problem, though
Henrique has tried to get the word out on it.
</p>

<p>
The other was a <a href="https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=1039613">failure</a>
of <a href="https://packages.debian.org/unstable/udptunnel">UDPTunnel</a> test due to
a change in the <a href="https://nmap.org/">Nmap</a> port scanner.  The
problem was a hidden regression in Nmap that was detected by autopkgtest
and debci,  which 
resulted in <a href="https://github.com/nmap/nmap/issues/2685">an Nmap bug
report</a> and subsequent fix.
</p>

<p>
<a href="https://salsa.debian.org/salsa-ci-team/pipeline/-/blob/master/README.md?ref_type=heads">Salsa
CI</a> is one of his favorite tools; it is based on the Debian GitLab
instance, <a href="https://salsa.debian.org/public">Salsa</a>, and helps
&#34;<q>make sure our packages are all nice and stable</q>&#34;.  The <a href="https://wiki.debian.org/Teams/SalsaCI">Salsa CI team</a> provides
recipes for tests that run on individual commits for packages.  He showed a
<a href="https://salsa.debian.org/debian/curl/-/pipelines/700118">Salsa CI
page for curl</a>, which lists a bunch of different tests that were run,
including build tests, autopkgtest, a test for possibly missing build flags,
such as for hardening, a build reproducibility test, and more.  There were
a few other tools he briefly mentioned, including one to <a href="https://wiki.debian.org/MultiArch/Hints">ensure there are
no multi-arch problems</a> and <a href="https://wiki.debian.org/Janitor">Janitor</a>, which will proactively
scan source repositories and send merge requests with suggested
improvements. 
</p>

<p>
An audience member asked about what other distributions do with regard to
QA.  Henrique said that he knew a bit about others, including Fedora, which
has some equivalent systems and processes, but thought that Debian is
&#34;<q>the best one doing this today</q>&#34;.  With that, the session ran out of
time.  Overall, he provided a nice whirlwind tour of Debian development and
maintenance in his presentation—and helped show the recipe for the sauce.
</p>

<p>
[I would like to thank the Linux Foundation, LWN&#39;s travel sponsor, for
its assistance in visiting Busan for DebConf24.]
</p></div></div>
  </body>
</html>
