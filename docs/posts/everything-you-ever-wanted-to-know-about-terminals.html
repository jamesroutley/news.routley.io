<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://xn--rpa.cc/irl/term.html">Original</a>
    <h1>Everything you ever wanted to know about terminals</h1>
    
    <div id="readability-page-1" class="page">
<h3><a href="http://xn--rpa.cc/index.html">ʞ</a> / <a href="http://xn--rpa.cc/irl/index.html">essays</a> /</h3>



<p>so here&#39;s a short tutorial on ansi escape codes and terminal control, because you philistines won&#39;t stop using ncurses and oh my god <em>WHY ARE WE STILL USING NCURSES IT IS THE TWENTY FIRST FUCKING CENTURY</em></p>

<p>the way terminal emulators handle fancy things like color and cursor shape aren&#39;t some mysterious opaque black box you can only access through a library. accessing most of these capabilities is actually extremely simple; they can even be hardcoded into a text file and displayed by <code>cat</code> or <code>less</code>. or even <a href="http://ʞ.cc/ansiglot">curl</a>! the way you do this is with something called <em>ANSI escape sequences.</em></p>

<p>almost all UI changes in a terminal are accomplished through in-band signalling. these signals are triggered with the ASCII/UTF-8 character <strong>‹ESC›</strong> (<code>0x1B</code> or <code>27</code>). it&#39;s the same <strong>‹ESC›</strong> character that you send to the terminal when you press the <code>Escape</code> key on your keyboard or a key sequence involving the <code>Alt</code> key. (typing <strong>‹A-c›</strong> for instance sends the characters <strong>‹ESC›</strong> and <strong>‹c›</strong> in very rapid succession; this is why you&#39;ll notice a delay in some terminal programs after you press the escape key — it&#39;s waiting to try and determine whether the user hit <code>Escape</code> or an alt-key chord.)</p>

<p>the simplest thing we can do with these escapes is to make the text <strong>bold</strong> (or &#34;bright&#34;). we accomplish this by sending the terminal the <strong>‹ESC›</strong> character followed by <code>[1m</code>. <code>[</code> is a character indicating to the terminal what kind of escape we&#39;re sending, <code>1</code> indicates bold/bright mode, and <code>m</code> is the control character for formatting escapes.</p>

<p>all text sent after this escape sequence will be bold until we explicitly turn it off again (even if your program terminates). there are two ways we can turn off bright mode: by clearing formatting entirely, using the <code>m</code> formatting command with no arguments or the argument <code>0</code>, or more specifically clearing the bold bit with the <code>21m</code> command. (you&#39;ll notice that you can usually turn off modes by prefixing the same number with <code>2</code>.)</p>

<p>in a C program, this might look like the following:</p>

<code><b>#include</b> <cite>&lt;unistd.h&gt;</cite>
<span>#define</span> szstr(str) str,sizeof(str)
<strong>int</strong> main() {
	write(1, szstr(<em>&#34;plain text - \x1b[1mbold text\x1b[0m - plain text&#34;</em>));
}
</code>

<p>the <code>\x1b</code> escape here is a C string escape that inserts hex character <code>0x1B</code> (<strong>‹ESC›</strong>) into the string. it&#39;s kind of ugly and unreadable if you&#39;re not used to reading source with explicit escapes in it. you can make it a lot less horrible with a handful of defines, tho:</p>

<code><span>#include</span> <em>&lt;unistd.h&gt;</em>
<span>#define</span> szstr(str) str,sizeof(str)

<span>#define</span>     plain &#34;0&#34; /* or &#34;&#34; */
<span>#define</span>        no &#34;2&#34;
<span>#define</span>    bright &#34;1&#34;
<span>#define</span>       dim &#34;2&#34;
<span>#define</span>    italic &#34;3&#34;
<span>#define</span> underline &#34;4&#34;
<span>#define</span>   reverse &#34;7&#34;
<span>#define</span>      with &#34;;&#34;
<span>#define</span>  ansi_esc &#34;\x1b&#34;
<span>#define</span> fmt(style) ansi_esc &#34;[&#34; style &#34;m&#34;

<span>int</span> main() {
	write(1, szstr(    <em>&#34;plain text - &#34;</em>
		fmt(bright)     <em>&#34;bright text&#34;</em>     fmt(no bright) <em>&#34; - &#34;</em>
		fmt(dim)       <em>&#34;dim text&#34;</em>        fmt(no dim)    <em>&#34; - &#34;</em> 
		fmt(italic)    <em>&#34;italic text&#34;</em>     fmt(no italic) <em>&#34; - &#34;</em>
		fmt(reverse)   <em>&#34;reverse video&#34;</em>   fmt(plain)     <em>&#34; - &#34;</em>
		fmt(underline) <em>&#34;underlined text&#34;</em> fmt(no underline) )
	);
}
</code>

<p>the beauty of this approach is that all the proper sequences are generated at <em>compile time</em>, meaning the compiler turns all that into a single string interpolated with the raw escapes. it offers much more readability for the coder at zero cost to the end user.</p>

<p>but hang on, where&#39;s that semicolon coming from? it turns out, ansi escape codes let you specify multiple formats per sequence. you can separate each command with a <code>;</code>. this would allow us to write formatting commands like <code>fmt(underline with bright with no italic)</code>, which translates into <code>\x1b[4;1;23m</code> at compile time.</p>

<p>of course, being able to style text isn&#39;t nearly good enough. we also need to be able to color it. there are two components to a color command: what we&#39;re trying to change the color of, and what color we want to change it to. both the foreground and background can be given colors separately - despite what ncurses wants you to believe, you do not have to define &#34;&#34;&#34;color pairs&#34;&#34;&#34; with each foreground-background pair you&#39;re going to use. this is a ridiculous archaism that nobody in the 21st fucking century should be limited by.</p>

<p>to target the foreground, we send the character <code>3</code> for normal colors or <code>9</code> for bright colors; to target the background, we send <code>4</code> for normal or <code>10</code> for bright. this is then followed by a color code selecting one of the traditional 8 terminal colors.</p>

<p>note that the &#34;bright&#34; here is both the same thing and something different from the &#34;bright&#34; mode we mentioned earlier. while turning on the &#34;bright&#34; mode will automatically shift text it applies to the bright variant of its color <em>if</em> it is set to one of the traditional 8 colors, setting a &#34;bright color&#34; with <code>9</code> or <code>10</code> will not automatically make the text bold.</p>

<code><span>#include</span> <em>&lt;unistd.h&gt;</em>
<span>#define</span> szstr(str) str,sizeof(str)

<span>#define</span> fg &#34;3&#34;
<span>#define</span> br_fg &#34;9&#34;
<span>#define</span> bg &#34;4&#34;
<span>#define</span> br_bg &#34;10&#34;
<span>#define</span> with &#34;;&#34;
<span>#define</span>      plain &#34;&#34;
<span>#define</span>      black &#34;0&#34;
<span>#define</span>        red &#34;1&#34;
<span>#define</span>      green &#34;2&#34;
<span>#define</span>     yellow &#34;3&#34;
<span>#define</span>       blue &#34;4&#34;
<span>#define</span>    magenta &#34;5&#34;
<span>#define</span>       cyan &#34;6&#34;
<span>#define</span>      white &#34;7&#34;
<span>#define</span>   ansi_esc &#34;\x1b&#34;
<span>#define</span> fmt(style) ansi_esc &#34;[&#34; style &#34;m&#34;

<span>int</span> main() {
	write(1, szstr(
		<em>&#34;plain text - &#34;</em>
		fmt(fg blue) <em>&#34;blue text&#34;</em> fmt(plain)               <em>&#34; - &#34;</em>
		fmt(br_fg blue) <em>&#34;bright blue text&#34;</em> fmt(plain)     <em>&#34; - &#34;</em>
		fmt(br_bg red) <em>&#34;bright red background&#34;</em> fmt(plain) <em>&#34; - &#34;</em>
		fmt(fg red with br_bg magenta) <em>&#34;hideous red text&#34;</em> fmt(plain))
	);
}
</code>

<p>when we invoke <code>fmt(fg red with br_bg magenta)</code>, this is translated by the compiler into the command string <code>\x1b[31;105m</code>. note that we&#39;re using <code>fmt(plain)</code> (<code>\x1b[m</code>) to clear the coloring here; this is because if you try to reset colors with, for instance, <code>fmt(fg black with bg white)</code>, you&#39;ll be overriding the preferences of users who have their terminal color schemes set to anything but that exact pair. additionally, if the user happens to have a terminal with a transparent background, a set background color will create ugly colored blocks around text instead of letting whatever&#39;s behind the window display correctly.</p>

<p>now, while it is more polite to use the &#34;8+8&#34; colors because they&#39;re a color palette the end-user can easily configure (she might prefer more pastel colors than the default harsh pure-color versions, or change the saturation and lightness to better fit with her terminal background), if you&#39;re doing anything remotely interesting UI-wise you&#39;re going to run up against that limit very quickly. while you can get a bit more mileage by mixing colors with styling commands, if you want to give <em>any</em> configurability to the user in terms of color schemes (as you rightly should), you&#39;ll want access to a much broader palette of colors.</p>

<p>to pick from a 256-color palette, we use a slightly different sort of escape: <code>\x1b[38;5;<em>(color)</em>m</code> to set the foreground and <code>\x1b[48;5;<em>(color)</em>m</code> to set the background, where <em>(color)</em> is the palette index we want to address. these escapes are even more unwieldy than the 8+8 color selectors, so it&#39;s even more important to have good abstraction.</p>

<code><span>#include</span> <em>&lt;unistd.h&gt;</em>
<span>#define</span> szstr(str) str,sizeof(str)

<span>#define</span>       with &#34;;&#34;
<span>#define</span>      plain &#34;;&#34;
<span>#define</span> wfg(color) &#34;38;5;&#34; #color
<span>#define</span> wbg(color) &#34;48;5;&#34; #color
<span>#define</span>   ansi_esc &#34;\x1b&#34;
<span>#define</span> fmt(style) ansi_esc &#34;[&#34; style &#34;m&#34;

<span>int</span> main() {
	write(1, szstr(<em>&#34;plain text - &#34;</em>
		fmt(wfg(198) with wbg(232))
			<em>&#34;rose text on dark grey&#34;</em>
		fmt(plain) <em>&#34; - &#34;</em>
		
		fmt(wfg(232) with wbg(248))
			<em>&#34;dark grey on light grey&#34;</em>
		fmt(plain) <em>&#34; - &#34;</em>
		
		fmt(wfg(248) with wbg(232))
			<em>&#34;light grey on dark grey&#34;</em>
		fmt(plain))
	);
}
</code>
<p>here, the stanza <code>fmt(wfg(248) with wbg(232))</code> translates into <code>\x1b[38;5;248;48;5;232m</code>. we&#39;re hard-coding the numbers here for simplicity but as a rule of thumb, any time you&#39;re using 8-bit colors in a terminal, you should <em>always</em> make them configurable by the user.</p>

<p>the opaque-seeming indexes are actually very systematic, and you can calculate which index to use for a particular color with the formula <code>16 + 36r + 6g + b</code>, where <code>r</code>, <code>g</code>, and <code>b</code> are integers ranging between 0 and 5. indices 232 through 255 are a grayscale ramp from dark (232) to light (255).</p>

<p>of course, this is still pretty restrictive. 8-bit color may have been enough for &#39;90s CD-ROM games on Windows, but it&#39;s long past it&#39;s expiration date. using true color is much more flexible. we can do this through the escape sequence <code>\x1b[38;2;<em>(r)</em>;<em>(g)</em>;<em>(b)</em>m</code> where each component is an integer between 0 and 255.</p>

<p>sadly, true color isn&#39;t supported on many terminals, urxvt tragically included. for this reason, your program should never rely on it, and abstract these settings away to be configured by the user. defaulting to 8-bit color is a good choice, as every reasonable modern terminal has supported it for a long time now.</p>

<p>but, for users of XTerm, kitty, Konsole, and libVTE-based terminal emulators (such as gnome-terminal, mate-terminal, and termite), it&#39;s polite to have a 24-bit color mode in place. for example:</p>

<code><span>#include</span> <em>&lt;stdio.h&gt;</em>
<span>#include</span> <em>&lt;stdint.h&gt;</em>
<span>#include</span> <em>&lt;stdbool.h&gt;</em>

<span>struct</span> color {
	<span>enum</span> color_mode { trad, trad_bright, b8, b24 } mode;
	<span>union</span> {
		<span>uint8_t</span> color;
		<span>struct</span> { <span>uint8_t</span> r, g, b; };
	}
};
<span>struct</span> style {
	unsigned <span>char</span> bold      : 1;
	unsigned <span>char</span> underline : 1;
	unsigned <span>char</span> italic    : 1;
	unsigned <span>char</span> dim       : 1;
	unsigned <span>char</span> reverse   : 1;
};
<span>struct</span> format {
	<span>struct</span> style style;
	<span>struct</span> color fg, bg;
};

<span>struct</span> format
	fmt_menu = {
		{0, 0, 0, 0, 0},
		{trad, 7},
		{trad, 4}
	},
	fmt_menu_hl = {
		{1, 0, 0, 0, 0},
		{trad_bright, 7},
		{trad_bright, 4},
	};

<span>void</span> apply_color(<span>bool</span> bg, <span>struct</span> color c) {
	switch(c.mode) {
		case trad: printf(<em>&#34;%c%u&#34;</em>, bg ? <em>&#39;4&#39;</em> : <em>&#39;3&#39;</em>, c.color ); break;
		case trad_bright: printf(<em>&#34;%s%u&#34;</em>, bg ? <em>&#34;9&#34;</em> : <em>&#34;10&#34;</em>, c.color ); break;
		case b8: printf(<em>&#34;%c8;5;%u&#34;</em>, bg ? <em>&#39;4&#39;</em> : <em>&#39;3&#39;</em>, c.color); break;
		case b24: printf(<em>&#34;%c8;2;%u;%u;%u&#34;</em>, bg ? <em>&#39;4&#39;</em> : <em>&#39;3&#39;</em>, c.r, c.b, c.g);
	}
}

<span>void</span> fmt(struct format f) {
	printf(<em>&#34;\x1b[&#34;</em>);
	f.bold      &amp;&amp; printf(<em>&#34;;1&#34;</em>);
	f.underline &amp;&amp; printf(<em>&#34;;4&#34;</em>);
	f.italic    &amp;&amp; printf(<em>&#34;;3&#34;</em>);
	f.reverse   &amp;&amp; printf(<em>&#34;;7&#34;</em>);
	f.dim       &amp;&amp; printf(<em>&#34;;2&#34;</em>);
	
	apply_color(false, f.fg);
	apply_color(true, f.bg);

	printf(<em>&#34;m&#34;</em>);
}

<span>int</span> main() {
	…
	if (is_conf(<em>&#34;style/menu/color&#34;</em>)) {
		if (strcmp(conf(<em>&#34;style/menu/color&#34;</em>, 0), <em>&#34;rgb&#34;</em>) == 0) {
			fmt_menu.mode = b24;
			fmt_menu.r = atoi(conf(<em>&#34;style/menu/color&#34;</em>, 1));
			fmt_menu.g = atoi(conf(<em>&#34;style/menu/color&#34;</em>, 2));
			fmt_menu.b = atoi(conf(<em>&#34;style/menu/color&#34;</em>, 3));
		} else if (atoi(conf(<em>&#34;style/menu/color&#34;</em>, 0)) &gt; 8) {
			fmt_menu.mode = b8;
			fmt_menu.color = atoi(conf(<em>&#34;style/menu/color&#34;</em>, 1));
		} else {
			fmt_menu.color = atoi(conf(<em>&#34;style/menu/color&#34;</em>, 1));
		}
	}
	…
}
</code>

<p>this sort of infrastructure gives you an enormously flexible formatting system that degrades gracefully without tying you to massive, archaic libraries or contaminating the global namespace with hundreds of idiot functions and macros (which is which of course being entirely indistinguishable). </p>

<p>but what if you want more than formatting? what if you want an actual TUI?</p>

<p>depending on the sort of TUI you want, you could actually get away with plain old ASCII. if you&#39;re just trying to draw a progress bar, for instance, you can (and should) use the ASCII control character <strong>‹CR›</strong>, &#34;carriage return&#34; (in C, <code>\r</code>):</p>

<code><span>#include</span> <em>&lt;unistd.h&gt;</em>
<span>#include</span> <em>&lt;stdlib.h&gt;</em>
<span>#include</span> <em>&lt;stdint.h&gt;</em>
<span>#include</span> <em>&lt;time.h&gt;</em>

<span>#define</span> barwidth 25
<span>#define</span> szstr(str) str,sizeof(str)

typedef <span>uint8_t</span> bar_t;
<span>int</span> main() {
	srand(time(NULL));
	bar_t prmax = -1;
	<span>size_t</span> ratio = prmax / barwidth;
	for(bar_t progress = 0; progress &lt; prmax;) {
		write(1,<em>&#34;\r&#34;</em>, 1);

		<span>size_t</span> barlen = progress / ratio;
		for (<span>size_t</span> i = 0; i &lt; barwidth; ++i) {
			<span>size_t</span> barlen = progress / ratio;
			if (i &lt;= barlen) write(1,szstr(<em>&#34;█&#34;</em>));
						else write(1,szstr(<em>&#34;░&#34;</em>));
		}

		fsync(1); 

		<span>size_t</span> incr = rand() % (prmax / 10);
		if (prmax - progress &lt; incr) break; 
		progress += incr;
		sleep(1);
	}
}
</code>

<p>of course, if we want to be <em>really</em> fancy, we can adorn the progress bar with ANSI colors using the escape sequences described above. this will be left as an exercise to the reader.</p>

<p>this is sufficient for basic applications, but eventually, we&#39;ll get to the point where we actually need to address and paint individual cells of the terminal. or, what if we wanted to size the progress bar dynamically with the size of the terminal window? it&#39;s time to break out ANSI escape sequences again.</p>

<p>the first thing you should always do when writing a TUI application is to send the <strong>TI</strong> or <strong>smcup</strong> escape. this notifies the terminal to switch to TUI mode (the &#34;alternate buffer&#34;), protecting the existing buffer so that it won&#39;t be overwritten and users can return to it when your application closes.</p>

<p>in ANSI, we achieve this with the sequence <code><strong>‹ESC›</strong>[?1049h</code> (or, as a C string, <code>&#34;\x1b[?1049h&#34;</code>).</p>

<p><em>(n.b. there&#39;s another escape, <code>&#34;\x1b47h&#34;</code>, with deceptively similar effects as <code>1049</code>, but it&#39;s behavior is subtly broken on some terminals (such as xterm) and it outright doesn&#39;t work on others (such as kitty). <code>&#34;\x1b[?1049h&#34;</code> has the correct effects everywhere that the alternate buffer is supported tho.)</em></p>

<p>once you&#39;ve switched to the alternate buffer, the first thing you&#39;ll want to do is clear the screen and home the cursor, to clean up any debris previous applications might have left behind. for this, we use the sequence <code><strong>‹ESC›</strong>[2J</code>, which clears the screen and nukes scrollback. (we <em>can&#39;t</em> use the terminal reset sequence, <strong>‹ESC›</strong><code>c</code>, because it affects not just the active buffer, but the entire terminal session, and will wreck everything that&#39;s currently displayed!)</p>

<p>likewise, just before exit, you need to send the <strong>TE</strong> or <strong>rmcup</strong> escape. this notifies the terminal to switch back to the previous mode. this sequence, as a C string, is <code>&#34;\x1b[?1049l&#34;</code>. to be polite, before you send this escape, you should clean up after yourself, clearing scrollback as before.</p>

<p>(<code>h</code> and <code>l</code> in these escapes seem to stand for &#34;high&#34; and &#34;low,&#34; meaning essentially &#34;on&#34; and &#34;off&#34; by reference to hardware IO lines, where high current usually corresponds to a 1 bit and low to a 0 bit. in the hardware terminals of the past eon, it&#39;s possible program-configurable modes such as this were implemented with discrete IO lines set to a particular level; it&#39;s also possible the ANSI escape code designers just reached for a handy metaphor in an age where booleans weren&#39;t yet in vogue. if anyone happens to find out the actual story behind this, please do let me know)</p>

<p>once we&#39;re in the alternate buffer, we can safely start throwing around escape sequences to move the cursor to arbitrary positions. however, before we do this, we need to know how big the terminal actually is so we can lay out the UI appropriately.</p>

<p>it&#39;s good form to have a function called <code>resize()</code> or similar that you run on program start and later when the terminal window is resized. while there is a horrible way to do this with ANSI escapes, it&#39;s better to just bite the bullet and learn how to use ioctls and termios.</p>

<p>termios is a POSIX interface that lets you discover and set properties of the current terminal. it&#39;s kind of an unholy mess, but fortunately, we only need to use a very small corner of it to get the information we need.</p>

<p>we start off by importing the <code>&lt;sys/ioctl.h&gt;</code> header. this gives us the functions and structures we need to set ioctls. termios returns the size of the window in a structure called <code>struct winsize</code>. (far more rational than anything you&#39;d find in ncurses, no?) this struct is populated using the function call <code>ioctl(1, TIOCGWINSZ, &amp;ws)</code> where <code>ws</code> is the name of our struct (and <code>1</code> is the file descriptor for standard output). terminal width and height can then be accessed in the fields <code>ws_col</code> (for width) and <code>ws_row</code> (for height).</p>

<p>of course, we need to keep these values up to date when the terminal size changes. this is why <code>resize()</code> needs to be its own function - it needs to be called whenever our program is sent the <code>SIGWINCH</code> signal. <code>SIGWINCH</code> is automatically sent to child processes by the controlling terminal emulator whenever its window is reshaped.</p>

<p>a full example of these concepts in action:</p>

<code><span>#include</span> <em>&lt;sys/ioctl.h&gt;</em>;
<span>#include</span> <em>&lt;signal.h&gt;</em>;

<span>uint16_t</span> width;
<span>uint16_t</span> height;

<span>void</span> resize(int i) {
	
	

	<span>struct winsize</span> ws;
	ioctl(1, TIOCGWINSZ, &amp;ws);
	width = ws.ws_col;
	height = ws.ws_row;

	
	
}

<span>int</span> main(<span>void</span>) {
	signal(SIGWINCH, resize);
	resize(0);

	
}
</code>

<p>throughout all of this, you may have noticed one thing: despite our attempts to create a clean, slick TUI, the cursor itself remains stubbornly onscreen. don&#39;t worry, tho; we can fix this.</p>

<p>the escape sequence to show and hide the cursor works much like the one to switch to and from the alternate buffer, except it has the number <code>25</code> instead of <code>1049</code>. we can therefore hide the cursor by printing the string <code>&#34;\x1b[?25l&#34;</code> and show it again with the string <code>&#34;\x1b[?25h&#34;</code>.</p>

<p>it&#39;s important to track how you&#39;re changing the behavior of the terminal, though, and restore it on program exit. otherwise, the user will have to reset the terminal herself, which many don&#39;t even know how to do (for the record, it&#39;s <code>$ reset</code> or <code>$ echo -ne &#34;\ec&#34;</code>). since you won&#39;t necessarily have control over how your program exits, it&#39;s important to set an exit handler using the <code>atexit(3)</code> and <code>signal(3)</code> functions. this way, even if the process is terminated with <code>SIGTERM</code> or <code>SIGINT</code>, it will still restore the terminal to its original state.</p>

<p>(it won&#39;t do jack shit in case of a <code>SIGKILL</code>, of course, but at that point it&#39;s the user&#39;s responsibility anyway.)</p>

<p>here&#39;s an example of appropriate terminal cleanup:</p>

<code><span>#include</span> <em>&lt;stdlib.h&gt;</em>
<span>#include</span> <em>&lt;unistd.h&gt;</em>
<span>#include</span> <em>&lt;signal.h&gt;</em>;
<span>#define</span> say(str) write(1,str,sizeof(str))

<span>void</span> cleanup(<span>void</span>) {
	
	say(<em>&#34;\x1b[2J&#34;</em>);

	
	say(<em>&#34;\x1b[?1049l&#34;</em>);

	
	say(<em>&#34;\x1b[?25h&#34;</em>);
}

<span>void</span> cleanup_die(<span>int</span> i) {
	exit(1);
}

<span>int</span> main(<span>void</span>) {
	
	say(<em>&#34;\x1b[?1049h&#34;</em>);

	
	atexit(cleanup);
	signal(SIGTERM, cleanup_die);
	signal(SIGINT,  cleanup_die);

	
	say(<em>&#34;\x1b[2J&#34;</em>);

	
	say(<em>&#34;\x1b[?25l&#34;</em>);
	
	sleep(10);

	return 0;
}
</code>

<p>note the strategic placement of the atexit and signal functions. depending on where the program is in its execution when it receives SIGTERM, the cleanup function may be called before anything following it. if these traps were placed at the top of the program, they might be called before the alternate buffer was even opened, wiping out the ordinary buffer and anything the user had there. this is very impolite: we want to make sure that havoc is minimized.</p>

<p>of course, there is still a very small problem: if by some miracle the program is killed after entering the alternate buffer but before the cleanup function is registered, the user could be left stuck in the alternate buffer. to fix this, we would have to register the cleanup function before anything else, and start off the cleanup function by giving the instruction to enter the alternate buffer. this is a NOP is we&#39;re already there; if we&#39;re not, it protects the user&#39;s terminal from the deleterious effects of the following code.</p>

<p>now we&#39;ve set the stage for our slick ncurses-free TUI, we just need to figure out how to put things on it.</p>

<p>we can move the cursor to an arbitrary position with <code><strong>‹ESC›</strong>[<em>(r)</em>;<em>(c)</em>H</code>. <em>(r)</em> here is the row we want to move to (the first row being 1), and <em>(c)</em> is the target column (also 1-indexed).</p>

<p>there&#39;s a number of other control sequences that move the cursor by relative steps, but as a rule, you should always use absolute addressing, as using relative addressing can lead to cumulative errors - and if your program <em>doesn&#39;t</em> know the location of the cursor at all times, something is very wrong.</p>

<p>if you actually try this, though, you&#39;ll quickly notice a new problem. anything the user types will still appear onscreen, all over your beautiful TUI,  whether or not you want it to. this also moves the cursor as a side effect. this is chaos you don&#39;t want in a program, so we need to put an end to it. however, there&#39;s no standardized escape code to accomplish this.</p>

<p>in other words, we need to use termios. the <em>ugly</em> side of termios.</p>

<p>termios, unlike libraries you might be used to, doesn&#39;t just have functions you can call to set properties. instead, we need to download the entire termios struct for the current terminal into a variable of type <code>struct termios</code>, make our modifications, and then upload it back to the terminal.</p>

<p>to do this, we need to define two of those structs: one to hold our modifications, and one to hold the original state of the program so it can be restored by our cleanup function at exit. to download the struct, we use the function <code>tcgetattr(3)</code>. this function takes two arguments: a file descriptor representing the current terminal (always <code>1</code>, for stdout), and a pointer to a <code>struct termios</code> to write into. as soon as we&#39;ve populated our struct, before we&#39;ve made any modifications, we need to copy the unmodified struct into our global-scope &#34;backup&#34; struct.</p>

<p>after that, we can turn off echo. local echo is one of a number of flags encoded in the bitfield <code>c_lflag</code>, identified by the constant ECHO. to disable it, we first invert <code>ECHO</code> with the <code>~</code> bitwise NOT operator, and then bitwise-AND the field by the resulting value.</p>

<p>once we&#39;ve made our modifications, we can send them back up with the function <code>tcsetattr(3)</code>. this one takes <em>three</em> arguments. the first is the file descriptor to modify, as usual. the second is a constant controlling when these modifications actually take place - for our purposes, this is always <code>TCSANOW</code>. finally, we give it a pointer to the struct we&#39;ve modified.</p>

<p>having turned off local echo, we now need to handle it (and line-editing) by hand, printing and deleting characters as the user types them. the problem is, the terminal won&#39;t actually <em>tell</em> us the user has typed anything until she hits <strong>‹ENTER›</strong>, making line-editing (or even just seeing what she&#39;s typing) impossible. </p>

<p>the reason this happens is something called <em>canonical mode.</em> canonical mode is the normal mode of operation for dumb terminals and terminal emulators. while in canonical mode, terminals will exhibit traditional Unix-y behaviors, like allowing you to type anything at any time, even if nothing is reading from stdin, and only sending text line-by-line as <strong>‹ENTER›</strong> is keyed. remember, unlike DOS, UNIX uses a file/stream metaphor to interact with the terminal: it&#39;s just another file, so you can type things in at any time (and they&#39;ll be there as soon as a program decides to read from it again).</p>

<p>this doesn&#39;t suit our purposes at all, tho. we need DOS-like control over the UI. to achieve this, we need to turn off canonical mode. this is controlled by the <code>ICANON</code> flag, and with it off, we&#39;ll be able to read characters keystroke by keystoke.</p>

<code><span>#include</span> <em>&lt;unistd.h&gt;</em>
<span>#include</span> <em>&lt;termios.h&gt;</em>
<span>#include</span> <em>&lt;stdlib.h&gt;</em>
<span>#include</span> <em>&lt;signal.h&gt;</em>;
<span>#define</span> say(str) write(1, str, sizeof(str))

<span>struct termios</span> initial;

<span>void</span> restore(<span>void</span>) {
	tcsetattr(1, TCSANOW, &amp;initial);
}
<span>void</span> die(<span>int</span> i) {
	exit(1);
}

<span>void</span> terminit(<span>void</span>) {
	<span>struct termios</span> t;
	tcgetattr(1, &amp;t);
	initial = t;
	atexit(restore);
	signal(SIGTERM, die);
	signal(SIGINT, die);
	t.c_lflag &amp;= (~ECHO &amp; ~ICANON);
	tcsetattr(1, TCSANOW, &amp;t);
}

<span>int</span> main(<span>void</span>) {
	terminit();
	for(<span>char</span> buf; buf != <em>&#39;\n&#39;</em> &amp;&amp; buf != <em>&#39;\x1b&#39;</em>;) {
		read(1, &amp;buf, 1);
		say(<em>&#34;\ryou pressed &#34;</em>);
		write(1, &amp;buf, 1);
	}
	return 1;
}
</code>

<p>this is the final piece we strictly <em>need</em> to write a TUI. however, for extra credit:</p>

<p>if you&#39;re a <code>vim</code> user, you may have noticed that the cursor changes shape depending on what mode you&#39;re in (i-beam for insert, block for normal, or underline for replace). we can do this as well, with the DECSCUSR escape sequences.</p>

<p>these sequences start off as usual, with <code><strong>‹ESC›</strong>[</code>. a numeric character then follows, indicating which cursor we want to employ. we then finish the sequence with the command <code> q</code>, a literal space followed by the letter <code>q</code>.</p>

<p>the values we can use are <code>0</code> or <code>1</code> for a blinking block cursor, <code>2</code> for a steady block cursor, <code>3</code> for a blinking underline cursor, <code>4</code> for a steady underline cursor, <code>5</code> for a blinking i-beam cursor, and <code>6</code> for a steady i-beam. </p>

<p>now let&#39;s put it all together:</p>

<code><span>#include</span> <em>&lt;unistd.h&gt;</em>
<span>#include</span> <em>&lt;stdint.h&gt;</em>
<span>#include</span> <em>&lt;stddef.h&gt;</em>
<span>#include</span> <em>&lt;sys/ioctl.h&gt;</em>
<span>#include</span> <em>&lt;termios.h&gt;</em>
<span>#include</span> <em>&lt;stdlib.h&gt;</em>
<span>#include</span> <em>&lt;stdio.h&gt;</em>
<span>#include</span> <em>&lt;signal.h&gt;</em>
<span>#include</span> <em>&lt;stdbool.h&gt;</em>

<span>#define</span>      with &#34;;&#34;
<span>#define</span>     plain &#34;0&#34; /* or &#34;&#34; */
<span>#define</span>        no &#34;2&#34;
<span>#define</span>    bright &#34;1&#34;
<span>#define</span>       dim &#34;2&#34;
<span>#define</span>    italic &#34;3&#34;
<span>#define</span> underline &#34;4&#34;
<span>#define</span>   reverse &#34;7&#34;

<span>#define</span>        fg &#34;3&#34;
<span>#define</span>        bg &#34;4&#34;
<span>#define</span>     br_fg &#34;9&#34;
<span>#define</span>     br_bg &#34;10&#34;
<span>#define</span>     black &#34;0&#34;
<span>#define</span>       red &#34;1&#34;
<span>#define</span>     green &#34;2&#34;
<span>#define</span>    yellow &#34;3&#34;
<span>#define</span>      blue &#34;4&#34;
<span>#define</span>   magenta &#34;5&#34;
<span>#define</span>      cyan &#34;6&#34;
<span>#define</span>     white &#34;7&#34;

<span>#define</span>    alt_buf &#34;?1049&#34;
<span>#define</span>       curs &#34;?25&#34;
<span>#define</span> term_clear &#34;2J&#34;
<span>#define</span> clear_line &#34;2K&#34;
<span>#define</span>       high &#34;h&#34;
<span>#define</span>        low &#34;l&#34;
<span>#define</span>       jump &#34;H&#34;

<span>#define</span> esc &#34;\x1b&#34;
<span>#define</span> esca esc &#34;[&#34;
<span>#define</span> wfg &#34;38;5;&#34;
<span>#define</span> wbg &#34;48;5;&#34;
<span>#define</span> color &#34;m&#34;
<span>#define</span> fmt(f) esca f &#34;m&#34;

<span>#define</span> say(s) write(1,s,sizeof(s))
<span>#define</span> sz(s) (sizeof(s)/sizeof(*s))

<span>struct termios</span> initial;
<span>uint16_t</span> width, height;

<span>uint8_t</span> meter_value = 0;
<span>uint8_t</span> meter_size = 25;
<span>uint8_t</span> meter_color_on = 219;
<span>uint8_t</span> meter_color_off = 162;
<span>bool</span> help_visible = true;

<span>const <span>char</span></span>* instructions[] = {
	<em>&#34;press &#34;</em> fmt(reverse with bright) <em>&#34; i &#34;</em> fmt(plain)
		<em>&#34; to &#34;</em> fmt(underline with fg cyan) <em>&#34;increase the meter value&#34;</em> fmt(plain),
	<em>&#34;press &#34;</em> fmt(reverse with bright) <em>&#34; b &#34;</em> fmt(plain)
		<em>&#34; to &#34;</em> fmt(underline with fg red) <em>&#34;increase the length of the meter&#34;</em> fmt(plain),
	<em>&#34;press &#34;</em> fmt(reverse with bright) <em>&#34; d &#34;</em> fmt(plain)
		<em>&#34; to &#34;</em> fmt(underline with fg yellow) <em>&#34;decrease the meter value&#34;</em> fmt(plain),
	<em>&#34;press &#34;</em> fmt(reverse with bright) <em>&#34; s &#34;</em> fmt(plain)
		<em>&#34; to &#34;</em> fmt(underline with fg green) <em>&#34;decrease the length of the meter&#34;</em> fmt(plain),
	<em>&#34;press &#34;</em> fmt(reverse with bright) <em>&#34; c &#34;</em> fmt(plain)
		<em>&#34; to &#34;</em> fmt(underline with fg blue) <em>&#34;change the filled color&#34;</em> fmt(plain),
	<em>&#34;press &#34;</em> fmt(reverse with bright) <em>&#34; r &#34;</em> fmt(plain)
		<em>&#34; to &#34;</em> fmt(underline with br_fg red) <em>&#34;change the unfilled color&#34;</em> fmt(plain),
	<em>&#34;&#34;</em>,
	<em>&#34;press &#34;</em> fmt(reverse with bright) <em>&#34; h &#34;</em> fmt(plain)
		<em>&#34; to &#34;</em> fmt(underline with fg magenta) <em>&#34;toggle this text&#34;</em> fmt(plain),
	<em>&#34;press &#34;</em> fmt(reverse with bright) <em>&#34;ESC&#34;</em> fmt(plain)
		<em>&#34; to &#34;</em> fmt(underline with br_fg cyan) <em>&#34;quit&#34;</em> fmt(plain)
};

<span>size_t</span> textsz(<span>const <span>char</span></span>* str) {
	
	<span>size_t</span> sz = 0, i = 0;

	<span>count:</span> if (str[i] == 0) return sz;
		else if (str[i] == <em>&#39;\x1b&#39;</em>) goto skip;
		else { ++i; ++sz; goto count; }

	<span>skip:</span> if (str[i] != <em>&#39;m&#39;</em>) {
		++i; goto skip;
	} else goto count;
};

<span>void</span> restore(<span>void</span>) {
	say(
		
			esca alt_buf high
		
		
			esca term_clear

		
			esca curs high

		
			esca alt_buf low
	);

	
	tcsetattr(1, TCSANOW, &amp;initial);
	
}
<span>void</span> restore_die(int i) {
	exit(1);
	
}

<span>void</span> repaint(<span>void</span>);

<span>void</span> resize(int i) {
	<span>struct winsize</span> ws;
	ioctl(1, TIOCGWINSZ, &amp;ws);
	width = ws.ws_col;
	height = ws.ws_row;
	say(esca term_clear); 
	repaint();
}

<span>void</span> initterm(<span>void</span>) {
	
	
	setvbuf(stdout, NULL, _IONBF, 0);

	<span>termios:</span> {
		<span>struct termios</span> t;
		tcgetattr(1, &amp;t);
		initial = t;
		t.c_lflag &amp;= (~ECHO &amp; ~ICANON);
		tcsetattr(1, TCSANOW, &amp;t);
	};
	
	atexit(restore);
	signal(SIGTERM, restore_die);
	signal(SIGINT, restore_die);
	
	say (
		esca alt_buf high
		esca term_clear
		esca curs low
	);
}

<span>void</span> repaint(<span>void</span>) {
	<span>const uint16_t</span>
		mx = (width / 2) - (meter_size / 2),
		my = (height / 2) + 1;
	
	if (help_visible) for (<span>size_t</span> i = 0; i &lt; sz(instructions); ++i)
		printf(esca <em>&#34;%u&#34;</em> with <em>&#34;%u&#34;</em> jump fmt(plain) <em>&#34;%s&#34;</em>,
			
				my - (1 + (sz(instructions) - i)),
			
				(width/2) - (textsz(instructions[i])/2),
			
				instructions[i]);

	printf(esca <em>&#34;%u&#34;</em> with <em>&#34;%u&#34;</em> jump, my, mx);
	say(esca clear_line);

	for (<span>size_t</span> i = 0; i &lt; meter_size; ++i)
		printf(esca wfg <em>&#34;%u&#34;</em> color <em>&#34;%s&#34;</em>,
			i &lt; meter_value ? meter_color_on : meter_color_off,
			i &lt; meter_value ? <em>&#34;█&#34;</em> : <em>&#34;░&#34;</em>);
}

<span>int</span> main() {
	initterm();
	signal(SIGWINCH, resize);
	resize(0);
	<span>bool</span> dirty = true;
	for (<span>char</span> inkey; inkey != <em>&#39;\x1b&#39;</em>;) {
		if (dirty) { repaint(); dirty = false; }
		read(1,&amp;inkey,1);
		switch(inkey) {
			case <em>&#39;i&#39;</em>: 
				++meter_value; break;
			case <em>&#39;d&#39;</em>: 
				--meter_value; break;
			case <em>&#39;b&#39;</em>: 
				++meter_size; break;
			case <em>&#39;s&#39;</em>: 
				--meter_size; break;
			case <em>&#39;c&#39;</em>: 
				meter_color_on = rand(); break;
			case <em>&#39;r&#39;</em>: 
				meter_color_off = rand(); break;
			case <em>&#39;h&#39;</em>: 
				help_visible =! help_visible;
				say(esca term_clear); break;
			default: goto end;
		}
		dirty = true;
		end:;
	}
}
</code>

<p>that&#39;s it for the tutorial. i hope you learned something and will <em>reconsider using fucking ncurses next time</em> because <em>jesus fucking christ</em>.</p>

<p>yes, ncurses supplies features like window-drawing and region invalidation (<del>to avoid terminal flicker</del> actually <a href="https://justine.lol">justine tunney</a> has pointed out that this isn’t an issue with modern terminal emulators; you can generally just redraw the whole ui every frame so region invalidation is no longer quite as useful) that are much harder to implement yourself. no, you shouldn&#39;t <em>have</em> to implement it yourself. there <em>should</em> be a modern library to <em>replace</em> curses using the capabilities outlined here. but i swear to god developers have so completely forgotten <em>how terminals work</em> that i might be one of a handful of people left on earth who actually has the knowledge to, so they all just layer their bullshit on top of ncurses (which should never have survived the &#39;90s) instead and it&#39;s ｍａｄｄｅｎｉｎｇ．</p>

<p>my hope is that this tutorial will curtail some of the more egregiously trivial uses of ncurses and provide others with the knowledge needed to implement a 21st-century terminal UI library. because i sure as fuck don&#39;t have the energy to.</p>

<p>also, i have effectively zero pull in the tech community and am also kind of a controversial character who is liable to give projects a bad reputation, which i don&#39;t normally care about but this one is <strong>important</strong>. point is, nothing i wrote would ever gain any traction; any project designed to supplant ncurses needs to come from someone who&#39;s actually known to and respected by the FOSS community. and a maintainer who isn&#39;t a cripple.</p>

<p>you can find <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">a fuller list of ANSI escapes at wikipedia</a>.</p>

<p>oh, and before anyone starts up:</p>

<p>being compatible only with ANSI-capable terminals <em>is a feature, not a bug,</em> go the fuck away. terminfo is a fucking joke. nobody needs to target obscure dumb terminals (or smart terminals, for that matter) from 1983 anymore.</p>

<p><em>all sample code in this document is the sole property of the author and is released exclusively under the <a href="https://gnu.org/licenses/agpl.html">GNU AGPLv3</a>.</em></p>


</div>
  </body>
</html>
