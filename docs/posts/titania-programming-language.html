<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/gingerBill/titania">Original</a>
    <h1>Titania Programming Language</h1>
    
    <div id="readability-page-1" class="page"><p dir="auto">This is designed to be a language to teach compiler development with.</p><div data-snippet-clipboard-copy-content="module = &#34;module&#34; ident &#34;;&#34; [import_list] decl_sequence
         [&#34;begin&#34; stmt_sequence] &#34;end&#34; [&#34;;&#34;].

import_list = &#34;import&#34; import_decl {&#34;,&#34; import_decl} &#34;;&#34;.
decl_sequence = [&#34;const&#34; {const_decl &#34;;&#34;}]
                [&#34;type&#34;  {type_decl  &#34;;&#34;}]
                [&#34;var&#34;   {var_decl   &#34;;&#34;}]
                [{proc_decl          &#34;;&#34;}].

const_decl = ident &#34;=&#34; const_expr.
type_decl = ident &#34;=&#34;&#34; struct_type.
var_decl = ident_list &#34;:&#34; type.

proc_decl = &#34;proc&#34; ident [formal_parameters] &#34;;&#34; proc_body.
proc_body = decl_sequence [&#34;begin&#34; stmt_sequence] [&#34;return&#34; expr] &#34;end&#34;.


const_expr = expr.
expr = simple_expr {relation simple_expr}.

simple_expr = [&#34;+&#34; | &#34;-&#34;] unary_expr {add_operator unary_expr}.
unary_expr = [&#34;+&#34; | &#34;-&#34;] term.
term = factor {mul_operator factor}.

factor = integer | real | string | nil | true | false | set |
         &#34;(&#34; expr &#34;)&#34; | &#34;not&#34; expr | designator.

element = expr [&#34;..&#34; expr].

ident_list = ident {&#34;,&#34; ident}.
qual_ident = [ident &#34;.&#34;] ident.

struct_type = array_type | record_type | pointer_type | proc_type.
array_type = &#34;[&#34;&#34; const_expr {&#34;,&#34; const_expr} &#34;]&#34; type.
record_type = &#34;record&#34; [&#34;(&#34; qual_ident &#34;)&#34;] [field_list_sequence] &#34;end&#34;.
pointer_type = &#34;^&#34; type.
proc_type = &#34;proc&#34; formal_parameters.
field_list = ident_list &#34;:&#34; type.
formal_parmeters = &#34;(&#34; [fp_section {&#34;;&#34; fp_section}] [&#34;;&#34;] &#34;)&#34;.
formal_type = &#34;[&#34; &#34;]&#34; qual_ident.

stmt_sequence = stmt {&#34;;&#34; stmt} [&#34;;&#34;].
stmt = [assignment | proc_call | if_stmt | case_stmt | while_stmt | repeat_stmt | for_stmt ].

assignment = designator &#34;:=&#34; expr

if_stmt = &#34;if&#34; expr &#34;then&#34; stmt_sequence
          {&#34;elseif&#34; expr &#34;then&#34; stmt_sequence}
          [&#34;else&#34; stmt_sequence]
          &#34;end&#34;.

case_stmt = &#34;case&#34; expr &#34;of&#34; case {&#34;|&#34; case} &#34;end&#34;.
case = [case_label_list &#34;:&#34; stmt_sequence].
case_list = label_range {&#34;,&#34; label_range}.
label_range = label [&#34;..&#34; label].
label = integer | string | qual_ident.

while_stmt = &#34;while&#34; expr &#34;do&#34; stmt_sequence
             {&#34;elseif&#34; expr &#34;then&#34; stmt_sequence}
             &#34;end&#34;.
repeat_stmt = &#34;repeat&#34; stmt_sequence &#34;until&#34; expr.
for_stmt = &#34;for&#34; ident &#34;:=&#34; expr &#34;to&#34; expr [&#34;by&#34; const_expr] &#34;do&#34; stmt_sequence &#34;end&#34;.


designator = qual_ident {selector}.
selector = &#34;.&#34; ident | &#34;[&#34; expr_list &#34;]&#34; | &#34;^&#34; | &#34;(&#34; qual_ident &#34;)&#34;.
expr_list = expr {&#34;,&#34; expr}.


add_operator = &#34;+&#34; | &#34;-&#34; | &#34;xor&#34; | &#34;or&#34;.
mul_operator = &#34;*&#34; | &#34;/&#34; | &#34;%&#34;   | &#34;and&#34;.
relation     = &#34;=&#34; | &#34;&lt;&gt;&#34; | &#34;&lt;&#34; | &#34;&lt;=&#34; | &#34;&gt;&#34; | &#34;&gt;=&#34; | &#34;in&#34; | &#34;is&#34;."><pre><code>module = &#34;module&#34; ident &#34;;&#34; [import_list] decl_sequence
         [&#34;begin&#34; stmt_sequence] &#34;end&#34; [&#34;;&#34;].

import_list = &#34;import&#34; import_decl {&#34;,&#34; import_decl} &#34;;&#34;.
decl_sequence = [&#34;const&#34; {const_decl &#34;;&#34;}]
                [&#34;type&#34;  {type_decl  &#34;;&#34;}]
                [&#34;var&#34;   {var_decl   &#34;;&#34;}]
                [{proc_decl          &#34;;&#34;}].

const_decl = ident &#34;=&#34; const_expr.
type_decl = ident &#34;=&#34;&#34; struct_type.
var_decl = ident_list &#34;:&#34; type.

proc_decl = &#34;proc&#34; ident [formal_parameters] &#34;;&#34; proc_body.
proc_body = decl_sequence [&#34;begin&#34; stmt_sequence] [&#34;return&#34; expr] &#34;end&#34;.


const_expr = expr.
expr = simple_expr {relation simple_expr}.

simple_expr = [&#34;+&#34; | &#34;-&#34;] unary_expr {add_operator unary_expr}.
unary_expr = [&#34;+&#34; | &#34;-&#34;] term.
term = factor {mul_operator factor}.

factor = integer | real | string | nil | true | false | set |
         &#34;(&#34; expr &#34;)&#34; | &#34;not&#34; expr | designator.

element = expr [&#34;..&#34; expr].

ident_list = ident {&#34;,&#34; ident}.
qual_ident = [ident &#34;.&#34;] ident.

struct_type = array_type | record_type | pointer_type | proc_type.
array_type = &#34;[&#34;&#34; const_expr {&#34;,&#34; const_expr} &#34;]&#34; type.
record_type = &#34;record&#34; [&#34;(&#34; qual_ident &#34;)&#34;] [field_list_sequence] &#34;end&#34;.
pointer_type = &#34;^&#34; type.
proc_type = &#34;proc&#34; formal_parameters.
field_list = ident_list &#34;:&#34; type.
formal_parmeters = &#34;(&#34; [fp_section {&#34;;&#34; fp_section}] [&#34;;&#34;] &#34;)&#34;.
formal_type = &#34;[&#34; &#34;]&#34; qual_ident.

stmt_sequence = stmt {&#34;;&#34; stmt} [&#34;;&#34;].
stmt = [assignment | proc_call | if_stmt | case_stmt | while_stmt | repeat_stmt | for_stmt ].

assignment = designator &#34;:=&#34; expr

if_stmt = &#34;if&#34; expr &#34;then&#34; stmt_sequence
          {&#34;elseif&#34; expr &#34;then&#34; stmt_sequence}
          [&#34;else&#34; stmt_sequence]
          &#34;end&#34;.

case_stmt = &#34;case&#34; expr &#34;of&#34; case {&#34;|&#34; case} &#34;end&#34;.
case = [case_label_list &#34;:&#34; stmt_sequence].
case_list = label_range {&#34;,&#34; label_range}.
label_range = label [&#34;..&#34; label].
label = integer | string | qual_ident.

while_stmt = &#34;while&#34; expr &#34;do&#34; stmt_sequence
             {&#34;elseif&#34; expr &#34;then&#34; stmt_sequence}
             &#34;end&#34;.
repeat_stmt = &#34;repeat&#34; stmt_sequence &#34;until&#34; expr.
for_stmt = &#34;for&#34; ident &#34;:=&#34; expr &#34;to&#34; expr [&#34;by&#34; const_expr] &#34;do&#34; stmt_sequence &#34;end&#34;.


designator = qual_ident {selector}.
selector = &#34;.&#34; ident | &#34;[&#34; expr_list &#34;]&#34; | &#34;^&#34; | &#34;(&#34; qual_ident &#34;)&#34;.
expr_list = expr {&#34;,&#34; expr}.


add_operator = &#34;+&#34; | &#34;-&#34; | &#34;xor&#34; | &#34;or&#34;.
mul_operator = &#34;*&#34; | &#34;/&#34; | &#34;%&#34;   | &#34;and&#34;.
relation     = &#34;=&#34; | &#34;&lt;&gt;&#34; | &#34;&lt;&#34; | &#34;&lt;=&#34; | &#34;&gt;&#34; | &#34;&gt;=&#34; | &#34;in&#34; | &#34;is&#34;.
</code></pre></div><div data-snippet-clipboard-copy-content="and    else    import  of      then   while
begin  elseif  in      or      to     xor
by     end     is      proc    true
case   false   module  record  type
const  for     nil     repeat  until
do     if      not     return  var"><pre><code>and    else    import  of      then   while
begin  elseif  in      or      to     xor
by     end     is      proc    true
case   false   module  record  type
const  for     nil     repeat  until
do     if      not     return  var
</code></pre></div><div data-snippet-clipboard-copy-content="+    .   (   )   =  &lt;&gt;
-    ,   [   ]   &lt;  &lt;=
*    ;   {   }   &gt;  &gt;=
/    |   :=  :   ..
%    ^"><pre><code>+    .   (   )   =  &lt;&gt;
-    ,   [   ]   &lt;  &lt;=
*    ;   {   }   &gt;  &gt;=
/    |   :=  :   ..
%    ^
</code></pre></div><div data-snippet-clipboard-copy-content="abs(x)            - absolute value of
lsh(x, y)         - logical shift left
ash(x, y)         - arithmetic shift right
ror(x, y)         - rotate right
chr(i)            - convert int to char
ord(c)            - convert char to int
inc(x)            - x := x + 1
inc(x, y)         - x := x + y
dec(x)            - x := x - 1
dec(x, y)         - x := x - y
incl(x, y)        - include y in set x
excl(x, y)        - exclude y in set x
odd(x)            - x % 2 = 0
floor(x)          - round-down for real
ceil(x)           - round-up   for real
assert(cond)      - assert when cond is false
new(ptr)          - allocate memory
delete(ptr)       - free memory
addr(x)           - address of addressable memory
size_of(x)        - size of the type of &#39;x&#39;
align_of(x)       - alignment of the type of &#39;x&#39;
copy(dst, src, n) - non-overlapping memory copying from `src` to `dst` of `n` bytes
print(...)        - variadic print without newline
println(...)      - variadic print with newline
len(x)            - length of an array &#39;x&#39;"><pre><code>abs(x)            - absolute value of
lsh(x, y)         - logical shift left
ash(x, y)         - arithmetic shift right
ror(x, y)         - rotate right
chr(i)            - convert int to char
ord(c)            - convert char to int
inc(x)            - x := x + 1
inc(x, y)         - x := x + y
dec(x)            - x := x - 1
dec(x, y)         - x := x - y
incl(x, y)        - include y in set x
excl(x, y)        - exclude y in set x
odd(x)            - x % 2 = 0
floor(x)          - round-down for real
ceil(x)           - round-up   for real
assert(cond)      - assert when cond is false
new(ptr)          - allocate memory
delete(ptr)       - free memory
addr(x)           - address of addressable memory
size_of(x)        - size of the type of &#39;x&#39;
align_of(x)       - alignment of the type of &#39;x&#39;
copy(dst, src, n) - non-overlapping memory copying from `src` to `dst` of `n` bytes
print(...)        - variadic print without newline
println(...)      - variadic print with newline
len(x)            - length of an array &#39;x&#39;
</code></pre></div></div>
  </body>
</html>
