<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/gingerBill/titania">Original</a>
    <h1>Titania Programming Language</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">Based on the <a href="https://people.inf.ethz.ch/wirth/Oberon/Oberon07.Report.pdf" rel="nofollow">Oberon-07</a> programming language designed by the late <a href="https://en.wikipedia.org/wiki/Niklaus_Wirth" rel="nofollow">Niklaus Wirth</a>.</p>
<p dir="auto">This is designed to be a language to teach compiler development with.</p>
<p dir="auto">Meaning behind the name:</p>
<ul dir="auto">
<li>Titania is the wife of Oberon (Fairy King) in Shakespeare&#39;s <em>A Midsummer Night&#39;s Dream</em></li>
<li><a href="https://en.wikipedia.org/wiki/Titania_(A_Midsummer_Night%27s_Dream)" rel="nofollow">https://en.wikipedia.org/wiki/Titania_(A_Midsummer_Night%27s_Dream)</a></li>
<li>This is just a codename, and probably not final for this teaching language</li>
</ul>

<div data-snippet-clipboard-copy-content="module = &#34;module&#34; ident &#34;;&#34; [import_list] decl_sequence
         [&#34;begin&#34; stmt_sequence] &#34;end&#34; [&#34;;&#34;].

import_list = &#34;import&#34; import_decl {&#34;,&#34; import_decl} &#34;;&#34;.
decl_sequence = [&#34;const&#34; {const_decl &#34;;&#34;}]
                [&#34;type&#34;  {type_decl  &#34;;&#34;}]
                [&#34;var&#34;   {var_decl   &#34;;&#34;}]
                [{proc_decl          &#34;;&#34;}].

const_decl = ident &#34;=&#34; const_expr.
type_decl = ident &#34;=&#34;&#34; struct_type.
var_decl = ident_list &#34;:&#34; type.

proc_decl = &#34;proc&#34; ident [formal_parameters] &#34;;&#34; proc_body.
proc_body = decl_sequence [&#34;begin&#34; stmt_sequence] [&#34;return&#34; expr] &#34;end&#34;.


const_expr = expr.
expr = simple_expr {relation simple_expr}.

simple_expr = [&#34;+&#34; | &#34;-&#34;] unary_expr {add_operator unary_expr}.
unary_expr = [&#34;+&#34; | &#34;-&#34;] term.
term = factor {mul_operator factor}.

factor = integer | real | string | nil | true | false | set |
         &#34;(&#34; expr &#34;)&#34; | &#34;not&#34; expr | designator.

element = expr [&#34;..&#34; expr].

ident_list = ident {&#34;,&#34; ident}.
qual_ident = [ident &#34;.&#34;] ident.

struct_type = array_type | record_type | pointer_type | proc_type.
array_type = &#34;[&#34;&#34; const_expr {&#34;,&#34; const_expr} &#34;]&#34; type.
record_type = &#34;record&#34; [&#34;(&#34; qual_ident &#34;)&#34;] [field_list_sequence] &#34;end&#34;.
pointer_type = &#34;^&#34; type.
proc_type = &#34;proc&#34; formal_parameters.
field_list = [&#34;using&#34;] ident_list &#34;:&#34; type.
formal_parmeters = &#34;(&#34; [fp_section {&#34;;&#34; fp_section}] [&#34;;&#34;] &#34;)&#34;.
formal_type = &#34;[&#34; &#34;]&#34; qual_ident.

stmt_sequence = stmt {&#34;;&#34; stmt} [&#34;;&#34;].
stmt = [assignment | proc_call | if_stmt | case_stmt | while_stmt | repeat_stmt | for_stmt ].

assignment = designator &#34;:=&#34; expr

if_stmt = &#34;if&#34; expr &#34;then&#34; stmt_sequence
          {&#34;elseif&#34; expr &#34;then&#34; stmt_sequence}
          [&#34;else&#34; stmt_sequence]
          &#34;end&#34;.

case_stmt = &#34;case&#34; expr &#34;of&#34; case {&#34;|&#34; case} &#34;end&#34;.
case = [case_label_list &#34;:&#34; stmt_sequence].
case_list = label_range {&#34;,&#34; label_range}.
label_range = label [&#34;..&#34; label].
label = integer | string | qual_ident.

while_stmt = &#34;while&#34; expr &#34;then&#34; stmt_sequence
             {&#34;elseif&#34; expr &#34;then&#34; stmt_sequence}
             &#34;end&#34;.
repeat_stmt = &#34;repeat&#34; stmt_sequence &#34;until&#34; expr.
for_stmt = &#34;for&#34; ident &#34;:=&#34; expr &#34;to&#34; expr [&#34;by&#34; const_expr] &#34;then&#34; stmt_sequence &#34;end&#34;.


designator = qual_ident {selector}.
selector = &#34;.&#34; ident |
           &#34;[&#34; expr_list &#34;]&#34; |
           &#34;^&#34; |
           &#34;(&#34; [expr_list] &#34;)&#34;.
expr_list = expr {&#34;,&#34; expr}.


add_operator = &#34;+&#34; | &#34;-&#34; | &#34;xor&#34; | &#34;or&#34;.
mul_operator = &#34;*&#34; | &#34;/&#34; | &#34;%&#34;   | &#34;and&#34;.
relation     = &#34;=&#34; | &#34;&lt;&gt;&#34; | &#34;&lt;&#34; | &#34;&lt;=&#34; | &#34;&gt;&#34; | &#34;&gt;=&#34; | &#34;in&#34; | &#34;is&#34;."><pre><code>module = &#34;module&#34; ident &#34;;&#34; [import_list] decl_sequence
         [&#34;begin&#34; stmt_sequence] &#34;end&#34; [&#34;;&#34;].

import_list = &#34;import&#34; import_decl {&#34;,&#34; import_decl} &#34;;&#34;.
decl_sequence = [&#34;const&#34; {const_decl &#34;;&#34;}]
                [&#34;type&#34;  {type_decl  &#34;;&#34;}]
                [&#34;var&#34;   {var_decl   &#34;;&#34;}]
                [{proc_decl          &#34;;&#34;}].

const_decl = ident &#34;=&#34; const_expr.
type_decl = ident &#34;=&#34;&#34; struct_type.
var_decl = ident_list &#34;:&#34; type.

proc_decl = &#34;proc&#34; ident [formal_parameters] &#34;;&#34; proc_body.
proc_body = decl_sequence [&#34;begin&#34; stmt_sequence] [&#34;return&#34; expr] &#34;end&#34;.


const_expr = expr.
expr = simple_expr {relation simple_expr}.

simple_expr = [&#34;+&#34; | &#34;-&#34;] unary_expr {add_operator unary_expr}.
unary_expr = [&#34;+&#34; | &#34;-&#34;] term.
term = factor {mul_operator factor}.

factor = integer | real | string | nil | true | false | set |
         &#34;(&#34; expr &#34;)&#34; | &#34;not&#34; expr | designator.

element = expr [&#34;..&#34; expr].

ident_list = ident {&#34;,&#34; ident}.
qual_ident = [ident &#34;.&#34;] ident.

struct_type = array_type | record_type | pointer_type | proc_type.
array_type = &#34;[&#34;&#34; const_expr {&#34;,&#34; const_expr} &#34;]&#34; type.
record_type = &#34;record&#34; [&#34;(&#34; qual_ident &#34;)&#34;] [field_list_sequence] &#34;end&#34;.
pointer_type = &#34;^&#34; type.
proc_type = &#34;proc&#34; formal_parameters.
field_list = [&#34;using&#34;] ident_list &#34;:&#34; type.
formal_parmeters = &#34;(&#34; [fp_section {&#34;;&#34; fp_section}] [&#34;;&#34;] &#34;)&#34;.
formal_type = &#34;[&#34; &#34;]&#34; qual_ident.

stmt_sequence = stmt {&#34;;&#34; stmt} [&#34;;&#34;].
stmt = [assignment | proc_call | if_stmt | case_stmt | while_stmt | repeat_stmt | for_stmt ].

assignment = designator &#34;:=&#34; expr

if_stmt = &#34;if&#34; expr &#34;then&#34; stmt_sequence
          {&#34;elseif&#34; expr &#34;then&#34; stmt_sequence}
          [&#34;else&#34; stmt_sequence]
          &#34;end&#34;.

case_stmt = &#34;case&#34; expr &#34;of&#34; case {&#34;|&#34; case} &#34;end&#34;.
case = [case_label_list &#34;:&#34; stmt_sequence].
case_list = label_range {&#34;,&#34; label_range}.
label_range = label [&#34;..&#34; label].
label = integer | string | qual_ident.

while_stmt = &#34;while&#34; expr &#34;then&#34; stmt_sequence
             {&#34;elseif&#34; expr &#34;then&#34; stmt_sequence}
             &#34;end&#34;.
repeat_stmt = &#34;repeat&#34; stmt_sequence &#34;until&#34; expr.
for_stmt = &#34;for&#34; ident &#34;:=&#34; expr &#34;to&#34; expr [&#34;by&#34; const_expr] &#34;then&#34; stmt_sequence &#34;end&#34;.


designator = qual_ident {selector}.
selector = &#34;.&#34; ident |
           &#34;[&#34; expr_list &#34;]&#34; |
           &#34;^&#34; |
           &#34;(&#34; [expr_list] &#34;)&#34;.
expr_list = expr {&#34;,&#34; expr}.


add_operator = &#34;+&#34; | &#34;-&#34; | &#34;xor&#34; | &#34;or&#34;.
mul_operator = &#34;*&#34; | &#34;/&#34; | &#34;%&#34;   | &#34;and&#34;.
relation     = &#34;=&#34; | &#34;&lt;&gt;&#34; | &#34;&lt;&#34; | &#34;&lt;=&#34; | &#34;&gt;&#34; | &#34;&gt;=&#34; | &#34;in&#34; | &#34;is&#34;.
</code></pre></div>

<div data-snippet-clipboard-copy-content="and    else    if      nil   record  true   while
begin  elseif  import  not   repeat  type   xor
by     end     in      of    return  until
case   false   is      or    then    using
const  for     module  proc  to      var"><pre><code>and    else    if      nil   record  true   while
begin  elseif  import  not   repeat  type   xor
by     end     in      of    return  until
case   false   is      or    then    using
const  for     module  proc  to      var
</code></pre></div>

<div data-snippet-clipboard-copy-content="+    .   (   )   =  &lt;&gt;
-    ,   [   ]   &lt;  &lt;=
*    ;   {   }   &gt;  &gt;=
/    |   :=  :   ..
%    ^"><pre><code>+    .   (   )   =  &lt;&gt;
-    ,   [   ]   &lt;  &lt;=
*    ;   {   }   &gt;  &gt;=
/    |   :=  :   ..
%    ^
</code></pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Tokenizer Semicolon Insertion Rules</h3><a id="user-content-tokenizer-semicolon-insertion-rules" aria-label="Permalink: Tokenizer Semicolon Insertion Rules" href="#tokenizer-semicolon-insertion-rules"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">When a newline is seen after the following token kind, a semicolon is inserted, otherwise no semicolon is inserted:</p>
<ul dir="auto">
<li>Identifiers</li>
<li>Integer, Real, String, Boolean literals</li>
<li><code>nil</code></li>
<li><code>^</code></li>
<li><code>)</code>, <code>]</code>, <code>}</code></li>
<li><code>end</code></li>
</ul>

<p dir="auto">Note: These will be added to as the compiler develops</p>
<div data-snippet-clipboard-copy-content="abs(x)            - absolute value of
lsh(x, y)         - logical shift left
ash(x, y)         - arithmetic shift right
ror(x, y)         - rotate right
chr(i)            - convert int to char
ord(c)            - convert char to int
inc(x)            - x := x + 1
inc(x, y)         - x := x + y
dec(x)            - x := x - 1
dec(x, y)         - x := x - y
incl(x, y)        - include y in set x
excl(x, y)        - exclude y in set x
odd(x)            - x % 2 = 0
floor(x)          - round-down for real
ceil(x)           - round-up   for real
assert(cond)      - assert when cond is false
new(ptr)          - allocate memory
delete(ptr)       - free memory
addr(x)           - address of addressable memory
size_of(x)        - size of the type of &#39;x&#39;
align_of(x)       - alignment of the type of &#39;x&#39;
copy(dst, src, n) - non-overlapping memory copying from `src` to `dst` of `n` bytes
print(...)        - variadic print without newline
println(...)      - variadic print with newline
len(x)            - length of an array &#39;x&#39;"><pre><code>abs(x)            - absolute value of
lsh(x, y)         - logical shift left
ash(x, y)         - arithmetic shift right
ror(x, y)         - rotate right
chr(i)            - convert int to char
ord(c)            - convert char to int
inc(x)            - x := x + 1
inc(x, y)         - x := x + y
dec(x)            - x := x - 1
dec(x, y)         - x := x - y
incl(x, y)        - include y in set x
excl(x, y)        - exclude y in set x
odd(x)            - x % 2 = 0
floor(x)          - round-down for real
ceil(x)           - round-up   for real
assert(cond)      - assert when cond is false
new(ptr)          - allocate memory
delete(ptr)       - free memory
addr(x)           - address of addressable memory
size_of(x)        - size of the type of &#39;x&#39;
align_of(x)       - alignment of the type of &#39;x&#39;
copy(dst, src, n) - non-overlapping memory copying from `src` to `dst` of `n` bytes
print(...)        - variadic print without newline
println(...)      - variadic print with newline
len(x)            - length of an array &#39;x&#39;
</code></pre></div>
</article></div></div>
  </body>
</html>
