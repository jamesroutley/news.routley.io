<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://frankforce.com/city-in-a-bottle-a-256-byte-raycasting-system/">Original</a>
    <h1>City in a Bottle – A 256 Byte Raycasting System</h1>
    
    <div id="readability-page-1" class="page"><div>
						
<p>Hello size coding fans. Today, I have something amazing to share: A tiny raycasting engine and city generator that fits in a standalone 256 byte html file.</p>



<p>In this post I will share all the secrets about how this magical program works. Here’s my tweet that contains the code and a video of the output…</p>



<figure><div>
<blockquote data-width="550" data-dnt="true"><p lang="en" dir="ltr">A City in a Bottle 🌆</p>— Frank Force 🌻 (@KilledByAPixel) <a href="https://twitter.com/KilledByAPixel/status/1517294627996545024?ref_src=twsrc%5Etfw">April 22, 2022</a></blockquote>
</div></figure>



<p>You may have already seen this post on my twitter timeline. After I originally released it about 2 years ago it ended up being one of my most popular tweets ever. Thank you for supporting this strange obsession of mine. Keep reading and I will try my best to explain how and why it works the way it does…</p>



<p>This amazing program uses many different concepts in a very small space, understanding it is kind of like solving a puzzle. There are several main pieces including the html code, frame update loop, rendering system, raycasting engine, and the city itself.</p>



<center><canvas id="c"><svg onload="t=9;c.height=60;setInterval(&#39;for(c.width=w=99,++t,i=6e3;i--;c.getContext`2d`.fillRect(i%w,i/w|0,1-d*Z/w+s,1))for(a=i%w/50-1,s=b=1-i/4e3,X=t,Y=Z=d=1;++Z&lt;w&amp;(Y&lt;6-(32&lt;Z&amp;27&lt;X%w&amp;&amp;X/9^Z/8)*8%46||d|(s=(X&amp;Y&amp;Z)%3/Z,a=b=1,d=Z/w));Y-=b)X+=a&#39;,t=16)">
</svg></canvas></center>



<p>You might think that it would require some advanced math to unravel this mystery, but actually no, the code is fairly simple and only uses basic algebra, not even any trig functions are used. Though there are a few tricks that allow everything to come together with an impressive result.</p>



<h2>All Of The Code</h2>



<p>First we can take a quick look at all the code before we dive in. This is not just a JavaScript snippet but an entire valid HTML program.</p>



<pre><code>&lt;canvas style=width:99% id=c onclick=setInterval(&#39;for(c.width=w=99,++t,i=6e3;i--;c.getContext`2d`.fillRect(i%w,i/w|0,1-d*Z/w+s,1))for(a=i%w/50-1,s=b=1-i/4e3,X=t,Y=Z=d=1;++Z&lt;w&amp;(Y&lt;6-(32&lt;Z&amp;27&lt;X%w&amp;&amp;X/9^Z/8)*8%46||d|(s=(X&amp;Y&amp;Z)%3/Z,a=b=1,d=Z/w));Y-=b)X+=a&#39;,t=9)&gt;</code></pre>



<p>This is a crazy tight 256 byte block of minified code so it will take some work to make it readable.</p>



<h2>The HTML Code</h2>



<p>Let’s look at the HTML part of the code before we move onto the JavaScript. Here is just the HTML by itself…</p>



<pre><code>&lt;canvas style=width:99% id=c onclick=setInterval(&#39;&#39;,t=9)&gt;</code></pre>



<p>It is just a canvas element with an onclick event. I splurged by setting the CSS width to 99%, though it still works fine without so there is some extra space to play around with for future remixes. The canvas id is set to c which gives us a way to access it from JavaScript.</p>



<p>The onclick event is what starts the program. The setInterval call is a bit of JavaScript that creates the update loop. The interval time is 9 milliseconds which is a little faster than 60 but close enough that it doesn’t matter. The time variable t is also initialized to 9 here to save space.</p>



<p>There is a slight bug that will occur if the canvas is clicked multiple times, the interval will also run multiple times causing it to slow down. It’s not much of an issue here but something to be aware of. There are several other ways to craft the HTML part of this code, each with their own tradeoffs. A normal script block works fine too, that would just require a little more space.</p>



<h2>The JavaScript Code</h2>



<p>Next up we have the 199 byte payload of JavaScript that runs when the canvas is clicked…</p>



<pre><code>for(c.width=w=99,++t,i=6e3;i--;c.getContext`2d`.fillRect(i%w,i/w|0,1-d*Z/w+s,1))for(a=i%w/50-1,s=b=1-i/4e3,X=t,Y=Z=d=1;++Z&lt;w&amp;(Y&lt;6-(32&lt;Z&amp;27&lt;X%w&amp;&amp;X/9^Z/8)*8%46||d|(s=(X&amp;Y&amp;Z)%3/Z,a=b=1,d=Z/w));Y-=b)X+=a</code></pre>



<h2>Breaking up the JavaScript</h2>



<p><a href="https://capjs.3d2k.com/?filename=City256&amp;crushed=t*%3D60%0Afor%7Bc.width%3Dw%3D99%2C%2B%2Bt%2Ci%3D6e3%3Bi--%3Bc.getContext%602d%60.fillRect%7Bi%27%2Ci%28%7C0%2C1-d*Z%28%2Bs%2C1%7D%7Dfor%7Ba%3Di%27%2F50-1%2Cs%21-i%2F4e3%2CX%3Dt%2CY%3DZ%3DdA%3B%2B%2BZ%3Cw%26%7BY%3C6-%7B32%3CZ%2627%3CX%27%26%26X%2F9%5EZ%2F8%7D*8%2546%7C%7Cd%7C%7Bs%3D%7BX%26Y%26Z%7D%253%2FZ%2Ca%21%2Cd%3DZ%28%7D%7D%3BY-%29%7DX%2B%3Da%21%29A%27%25w%28%2Fw%29%3DbA%3D1%01A%29%28%27%21_" target="_blank" rel="noreferrer noopener">This code is fully compatible with dwitter, so you can paste it in there or into CapJS to play around with it, just add t=60 to correct the speed.</a></p>


<div>
<figure><a href="https://frankforce.com/wp-content/uploads/2024/05/city4-10.png"><img decoding="async" width="480" height="270" src="https://frankforce.com/wp-content/uploads/2024/05/city4-10.png" alt="" srcset="https://frankforce.com/wp-content/uploads/2024/05/city4-10.png 480w, https://frankforce.com/wp-content/uploads/2024/05/city4-10-300x169.png 300w" sizes="(max-width: 480px) 100vw, 480px"/></a><figcaption>Final image with city, textures, and shadows</figcaption></figure></div>


<p>The first thing we’ll do is break up this code to make it easier to read. Whitespace is mostly ignored by JavaScript so we can rearrange things and add some extra space. Semicolons are usually not required to end a statement, so they are only used inside the for loop structure.</p>



<pre><code>c.width = w = 99
++t
for (i = 6e3; i--;)
{
  a = i%w/50 - 1
  s = b = 1 - i/4e3
  X = t
  Y = Z = d = 1
  for(; ++Z&lt;w &amp;
    (Y &lt; 6 - (32&lt;Z &amp; 27&lt;X%w &amp;&amp; X/9^Z/8)*8%46 ||
    d | (s = (X&amp;Y&amp;Z)%3/Z, a = b = 1, d = Z/w));)
  {
    X += a
    Y -= b
  }
  c.getContext`2d`.fillRect(i%w, i/w|0, 1 - d*Z/w + s, 1)
}</code></pre>



<h2>Stepping Through the Code</h2>



<p>Ok, let’s walk through the code one line at a time…</p>



<pre><code>c.width = w = 99 </code></pre>



<p>First we clear the canvas, set it’s width to 99 pixels and store 99 in w. This number will be reused many times. The default canvas height is 150 which works fine here, anything below what we draw just be left blank.</p>



<pre><code>++t</code></pre>



<p>We must increment the time variable once each frame to animate the scene.</p>



<pre><code>for (i = 6e3; i--;)</code></pre>



<p>This loop will iterate using the loop variable i and ultimately determine the brightness of each individual pixel.</p>



<p>To do that we will fire a ray from the camera using the position of this pixel to control the angle of the ray. Then if something is hit, it will send the ray towards the sun to check if it is in shadow. It sounds more complicated then it actually is!</p>



<h2>Getting the Camera Vector</h2>



<p>First we need to get a representation of the camera ray that is fired from the origin.</p>



<pre><code>a = i % w / 50 - 1</code></pre>



<p>The horizontal component of the camera vector is stored in a. We can calculate it from i by first moding i by the width which is 99. Then we divide by 50 to get a value between 0 and 2, and subtract 1 to normalize it between -1 and 1. Thankfully no parenthesis were needed which helps to save space.</p>



<pre><code>b = s = 1 - i / 4e3 </code></pre>



<p>The vertical component of the camera vector is stored in b. So it is a similar calculation to a. The correct way to calculate the vertical percentage is to first divide i by the width, then take the floor of that, then divide that by the height.</p>



<p>However by accepting a nearly imperceptible slant, we can simplify and just divide i by half the number of pixels and subtracting 1 to normalize between -1 and 1. The value 4e3 was chosen to move the horizon below center. You can play around with these values to see how it effects the result.</p>



<p>Also, notice that s is being set to the same value as b to create a vertical linear fade in the background if nothing in the scene is hit. The value of s will eventually be used to control the shading of the scene.</p>


<div>
<figure><a href="https://frankforce.com/wp-content/uploads/2024/05/city4-9.png"><img decoding="async" width="480" height="270" src="https://frankforce.com/wp-content/uploads/2024/05/city4-9.png" alt="" srcset="https://frankforce.com/wp-content/uploads/2024/05/city4-9.png 480w, https://frankforce.com/wp-content/uploads/2024/05/city4-9-300x169.png 300w" sizes="(max-width: 480px) 100vw, 480px"/></a><figcaption>Background fade stored in s</figcaption></figure></div>


<h2>Getting the Camera Position</h2>



<p>To make the scene appear animated moving to the right, the time value t is used as the starting X position.</p>



<pre><code>X = t</code></pre>



<p>We must also initialize the Y and Z component as well as d which is used to blend in the distance fog. A value of 1 works fine for all of these.</p>



<pre><code>Y = Z = d = 1</code></pre>



<h2>Raycasting System</h2>



<p>This inner loop is the most complicated part of the entire program, where the raycasting system steps until something is hit, then bounces the ray to check for shadows.</p>



<pre><code>for(; ++Z&lt;w &amp;</code></pre>



<p>The condition part of the for loop does a lot of heavy lifting here so we will split it up into several lines for clarity. The first part just moves Z forwards one step until it goes too far, which for us will be reusing the variable w that is equal to 99. The X and Y variables will be updated inside the loop.</p>



<h2>Checking The Building Height</h2>



<p>This code represents the shape of the city. It is here that we create the buildings, alleyways, and beautiful beach side real estate. It is a <em>very dense</em> bit of code!</p>



<pre><code>    (Y &lt; 6 - (32&lt;Z &amp; 27&lt;X%w &amp;&amp; X/9^Z/8)*8%46 ||</code></pre>



<p>To test if the ray is inside collision we check if the Y value is less than whatever the height is at that position. The city is formed by controlling the height for each XZ location</p>



<p>The 6 – part just moves the height result down below center and flips everything so the ground is on the bottom as it should be.</p>



<p>Inside the parentheses is where the real magic happens…</p>



<ul>
<li>Leave some space between the camera and the first row of buildings by making sure Z has moved at least 32 units.</li>



<li>Create the side streets and seaside by checking that X mod w (constant 99) is more than 27. This periodically leaves empty gaps like roads that divide the city up into blocks. As an added bonus this always returns false for negative values, creating a serendipitous ocean.</li>



<li>Generate a noise function for the heights of the buildings using X/9^Z/8. The bitwise exclusive or function is used here to produce an interesting spread of values, giving a random feel the height of the buildings.</li>



<li>The division is to scale it so the buildings will be 9 units wide and 8 units deep. Using larger units would increase the size of the buildings.</li>



<li>The value of X/9 here is also related the the side street width being between 27 and 99, all of those numbers are divisible by 9. This prevents very thin buildings being created on the sides.</li>
</ul>


<div>
<figure><a href="https://frankforce.com/wp-content/uploads/2024/03/Dweet_28705-5.png"><img loading="lazy" decoding="async" width="480" height="270" src="https://frankforce.com/wp-content/uploads/2024/03/Dweet_28705-5.png" alt="" srcset="https://frankforce.com/wp-content/uploads/2024/03/Dweet_28705-5.png 480w, https://frankforce.com/wp-content/uploads/2024/03/Dweet_28705-5-300x169.png 300w" sizes="(max-width: 480px) 100vw, 480px"/></a><figcaption>Top down view of building heights expressed in grayscale</figcaption></figure></div>


<p>The result of everything in the parentheses ends up getting multiplied by 8 and moded by 46 which is the maximum height. These values were chosen after experimentation to produce an interesting variety of building heights.</p>



<p>We could just stop here without looping a second time and draw what we have using the Z value to fade off buildings in the distance.</p>


<div>
<figure><a href="https://frankforce.com/wp-content/uploads/2024/05/city4-8.png"><img loading="lazy" decoding="async" width="480" height="270" src="https://frankforce.com/wp-content/uploads/2024/05/city4-8.png" alt="" srcset="https://frankforce.com/wp-content/uploads/2024/05/city4-8.png 480w, https://frankforce.com/wp-content/uploads/2024/05/city4-8-300x169.png 300w" sizes="(max-width: 480px) 100vw, 480px"/></a><figcaption>Distance values used to apply fog</figcaption></figure></div>


<h2>Creating Shadow and Texture</h2>



<p>If this code is hit, then the first test has passed so the ray must have collided with something. This is where we will get the texture of what is hit, bounce the light towards the sun to produce a shadow. It’s a little bit tricky because it’s actually two loops in one.</p>



<pre><code>    d | (s = (X&amp;Y&amp;Z)%3/Z, a = b = 1, d = Z/w));)</code></pre>



<p>The first part d | is to check if we are firing the ray from the camera or casting the ray towards the light to check for a shadow. We had already set d to 1 before the loop began, and end of this line it will be set to a value less that 1 which combined with the bitwise or will evaluate to false. This allows the loop to run a second time, moving towards the light to check for shadow. So if it is in shadow the next time this code is hit, it will exit the for loop and draw the pixel.</p>



<p>The grayscale texture value is stored in s and generated by using the &amp; operator with X, Y, and Z and modding that by 3. This creates and effect that looks something like different types of windows. The result is also divided by Z to fade off the texturing in the distance.</p>


<div>
<figure><a href="https://frankforce.com/wp-content/uploads/2024/03/Dweet_28705-4.png"><img loading="lazy" decoding="async" width="480" height="270" src="https://frankforce.com/wp-content/uploads/2024/03/Dweet_28705-4.png" alt="" srcset="https://frankforce.com/wp-content/uploads/2024/03/Dweet_28705-4.png 480w, https://frankforce.com/wp-content/uploads/2024/03/Dweet_28705-4-300x169.png 300w" sizes="(max-width: 480px) 100vw, 480px"/></a><figcaption>Side view of building textures</figcaption></figure></div>


<p>To point the ray towards the light source both a and b are set to 1. This works great for a directional light source light the sun.</p>



<p>A fog value is stored in d by dividing the current Z value by w (99) which will is used to brighten the buildings in the distance. This same value of d is now guaranteed to be less than 1 signifying that we are testing for shadow as mentioned earlier.</p>



<pre><code>X += a
Y -= b</code></pre>



<p>Each component is updated to move the ray end point. The X and Y part is controlled by a and b respectively. The Z part always moves forward by 1, since the directional light is also in the direction of the camera it never needs to change.</p>



<h2>Drawing Each Pixel</h2>



<p>Each pixel is finally drawn using a simple calculation of i to get the X and Y coordinates. The brightness is controlled by reducing the size of the pixel which is a very small way to create grayscale images one pixel at a time.</p>



<pre><code>c.getContext`2d`.fillRect(i%w, i/w|0, 1 - d*Z/w + s, 1)</code></pre>



<p>There are several values that are combined to control the final grayscale value. A value of 1 here would be a black pixel and so we will be subtracting from 1 to create the image.</p>


<div>
<figure><a href="https://frankforce.com/wp-content/uploads/2024/05/city4-3.png"><img loading="lazy" decoding="async" width="480" height="270" src="https://frankforce.com/wp-content/uploads/2024/05/city4-3.png" alt="" srcset="https://frankforce.com/wp-content/uploads/2024/05/city4-3.png 480w, https://frankforce.com/wp-content/uploads/2024/05/city4-3-300x169.png 300w" sizes="(max-width: 480px) 100vw, 480px"/></a><figcaption>Without the texture component</figcaption></figure></div>


<p>The fog value d gets multiplied by the current distance Z/w, which is how the shadows are created. If the ray is not in shadow, than it must have traveled the maximum distance of w so Z/w will be 1. Conversely if it is in shadow, than Z will be less that w causing that area to be darker. This actually creates a type of ambient occlusion because the closer the light blocking object, the darker the shadow.</p>


<div>
<figure><a href="https://frankforce.com/wp-content/uploads/2024/05/city3-1-1-6-3-1-2.png"><img loading="lazy" decoding="async" width="480" height="270" src="https://frankforce.com/wp-content/uploads/2024/05/city3-1-1-6-3-1-2.png" alt="" srcset="https://frankforce.com/wp-content/uploads/2024/05/city3-1-1-6-3-1-2.png 480w, https://frankforce.com/wp-content/uploads/2024/05/city3-1-1-6-3-1-2-300x169.png 300w" sizes="(max-width: 480px) 100vw, 480px"/></a><figcaption>Just the texture component</figcaption></figure></div>


<p>Finally we add s to the result which is the texture of the buildings we calculated earlier. You an see how both of those important components combine to create a realistic looking scene.</p>


<div>
<figure><a href="https://frankforce.com/wp-content/uploads/2024/05/city4-10.png"><img decoding="async" width="480" height="270" src="https://frankforce.com/wp-content/uploads/2024/05/city4-10.png" alt="" srcset="https://frankforce.com/wp-content/uploads/2024/05/city4-10.png 480w, https://frankforce.com/wp-content/uploads/2024/05/city4-10-300x169.png 300w" sizes="(max-width: 480px) 100vw, 480px"/></a><figcaption>Final result with everything combined</figcaption></figure></div>


<p>Believe it or not, that’s the entire program! This tiny 256-byte raycasting engine and city generator demonstrates how much can be achieved with minimal code. I hope you enjoyed this deep dive into the inner workings of “City In A Bottle.”</p>



<h2>Continued Learning</h2>



<p><a href="https://www.pouet.net/prod.php?which=91532">This demo was entered into the Revision 2022 demo party and is available on Pouet.</a> It did not rank highly at the time because it was entered in the wrong category (oops) but I believe it stands as one of the most impressive 256 byte JavaScript demos out there.</p>



<p>Also, we have continued expanding this concept on Shadertoy where I worked with <a href="https://x.com/XorDev">Xor </a>and a few other coders to create a 256 byte shader that perfectly recreates the JavaScript version. <a href="https://www.shadertoy.com/view/7dccRj">It’s kind of amazing to see it run in HD at 60fps, check it out!</a></p>



<figure><a href="https://frankforce.com/wp-content/uploads/2024/05/city4-2.png"><img loading="lazy" decoding="async" width="1024" height="576" src="https://frankforce.com/wp-content/uploads/2024/05/city4-2-1024x576.png" alt="" srcset="https://frankforce.com/wp-content/uploads/2024/05/city4-2-1024x576.png 1024w, https://frankforce.com/wp-content/uploads/2024/05/city4-2-300x169.png 300w, https://frankforce.com/wp-content/uploads/2024/05/city4-2-768x432.png 768w, https://frankforce.com/wp-content/uploads/2024/05/city4-2-1536x864.png 1536w, https://frankforce.com/wp-content/uploads/2024/05/city4-2.png 1920w" sizes="(max-width: 1024px) 100vw, 1024px"/></a><figcaption>HD Version on Shadertoy</figcaption></figure>



<p>Lastly, <a href="https://x.com/DanielDarabos">Daniel Darabos</a> made an interactive tool on observable that allows you to play with different aspects of the program in real time! – <a href="https://observablehq.com/@darabos/decoding-a-city-in-a-bottle">Decoding A City In A Bottle</a></p>



<h2>Wrap Up</h2>



<p>Thank you for following along this epic writeup. If you want to explore more, <a href="https://www.dwitter.net/d/25311">feel free to remix the code on Dwitter</a> or just play around with it on CapJS. I’m always excited to see the creative variations and improvements that the community comes up with.</p>



<p>Stay tuned for more tiny cities and other projects! I’ll leave you with this cool little isometric rendering system I’ve been working on and shared recently. It works in a similar way to get the building heights and textures but without using raycasting.</p>


<div>
<figure><a href="https://frankforce.com/wp-content/uploads/2024/05/chaosbuble-3-1-1-2-2-1-4-2-2.png"><img loading="lazy" decoding="async" width="1024" height="576" src="https://frankforce.com/wp-content/uploads/2024/05/chaosbuble-3-1-1-2-2-1-4-2-2-1024x576.png" alt="" srcset="https://frankforce.com/wp-content/uploads/2024/05/chaosbuble-3-1-1-2-2-1-4-2-2-1024x576.png 1024w, https://frankforce.com/wp-content/uploads/2024/05/chaosbuble-3-1-1-2-2-1-4-2-2-300x169.png 300w, https://frankforce.com/wp-content/uploads/2024/05/chaosbuble-3-1-1-2-2-1-4-2-2-768x432.png 768w, https://frankforce.com/wp-content/uploads/2024/05/chaosbuble-3-1-1-2-2-1-4-2-2-1536x864.png 1536w, https://frankforce.com/wp-content/uploads/2024/05/chaosbuble-3-1-1-2-2-1-4-2-2.png 1920w" sizes="(max-width: 1024px) 100vw, 1024px"/></a><figcaption>Blocked Up 🏨 <a href="https://www.dwitter.net/d/31724">https://www.dwitter.net/d/31724</a></figcaption></figure></div>


<p>Keep coding, keep experimenting, and let’s continue to push the boundaries of what we can do with tiny code! <a href="https://x.com/KilledByAPixel">Follow me on twitter more coding magic and other crazy experiments.</a></p>
											</div></div>
  </body>
</html>
