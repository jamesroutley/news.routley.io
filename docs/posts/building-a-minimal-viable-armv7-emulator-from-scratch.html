<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://xnacly.me/posts/2025/building-a-minimal-viable-armv7-emulator/">Original</a>
    <h1>Building a Minimal Viable Armv7 Emulator from Scratch</h1>
    
    <div id="readability-page-1" class="page"><div><div id="callout"><h3>Tip or TLDR - I built a tiny, zero dependency armv7 userspace emulator in Rust</h3><p>I wrote a minimal viable armv7 emulator in 1.3k lines of Rust without any
dependencies. It parses and validates a 32-bit arm binary, maps its segments,
decodes a subset of arm instructions, translates guest and host memory
interactions and forwards arm Linux syscalls into x86-64 System V syscalls.</p><p>It can run a armv7 hello world binary and does so in 1.9ms (0.015ms for raw
emulation without setup), while qemu takes 12.3ms (stinkarm is thus ~100-1000x
slower than native armv7 execution).</p></div><p>After reading about the process the Linux kernel performs to execute binaries,
I thought: I want to write an armv7 emulator - <a href="https://github.com/xnacly/stinkarm"><code>stinkarm</code></a>. Mostly to understand the ELF
format, the encoding of arm 32bit instructions, the execution of arm assembly
and how it all fits together (this will help me with the JIT for my programming
language I am currently designing). To fully understand everything: no
dependencies. And of course Rust, since I already have enough C projects going
on.</p><p>So I wrote the smallest binary I could think of:</p><p><span>ARMASM</span></p><div><pre tabindex="0"><code data-lang="armasm"><span><span>1</span><span>    <span>.global</span> _start  <span>@ declare _start as a global
</span></span></span><span><span>2</span><span><span></span>_start:             <span>@ start is the defacto entry point
</span></span></span><span><span>3</span><span><span></span>    mov <span>r0</span>, #<span>161</span>    <span>@ first and only argument to the exit syscall
</span></span></span><span><span>4</span><span><span></span>    mov <span>r7</span>, #<span>1</span>      <span>@ syscall number 1 (exit)
</span></span></span><span><span>5</span><span><span></span>    svc #<span>0</span>          <span>@ trapping into the kernel (thats US, since we are translating)
</span></span></span></code></pre></div><p>To execute this arm assembly on my x86 system, I need to:</p><ol><li>Parse the ELF, validate it is armv7 and statically executable (I don’t want
to write a dynamic dependency resolver and loader)</li><li>Map the segments defined in ELF into the host memory, forward memory access</li><li>Decode armv7 instructions and convert them into a nice Rust enum</li><li>Emulate the CPU, its state and registers</li><li>Execute the instructions and apply their effects to the CPU state</li><li>Translate and forward syscalls</li></ol><p>Sounds easy? It is!</p><p><em>Open below if you want to see me write a build script and a nix flake:</em></p><details><summary><h3>Minimalist arm setup and smallest possible arm binary</h3></summary><p>Before I start parsing ELF I’ll need a binary to emulate, so lets create a
build script called <code>bld_exmpl</code> (so I can write a lot less) and nix flake, so
the asm is converted into armv7 machine code in a armv7 binary on my non armv7
system :^)</p><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span> 1</span><span><span>// tools/bld_exmpl
</span></span></span><span><span> 2</span><span><span></span><span>use</span> clap::Parser;
</span></span><span><span> 3</span><span><span>use</span> std::fs;
</span></span><span><span> 4</span><span><span>use</span> std::path::Path;
</span></span><span><span> 5</span><span><span>use</span> std::process::Command;
</span></span><span><span> 6</span><span>
</span></span><span><span> 7</span><span><span>/// Build all ARM assembly examples into .elf binaries
</span></span></span><span><span> 8</span><span><span></span><span>#[derive(Parser)]</span>
</span></span><span><span> 9</span><span><span>struct</span> <span>Args</span> {
</span></span><span><span>10</span><span>    <span>/// Directory containing .S examples
</span></span></span><span><span>11</span><span><span></span>    <span>#[arg(long, default_value = </span><span>&#34;examples&#34;</span><span>)]</span>
</span></span><span><span>12</span><span>    examples_dir: <span>String</span>,
</span></span><span><span>13</span><span>}
</span></span><span><span>14</span><span>
</span></span><span><span>15</span><span><span>fn</span> <span>main</span>() -&gt; <span>Result</span>&lt;(), <span>Box</span>&lt;<span>dyn</span> std::error::Error&gt;&gt; {
</span></span><span><span>16</span><span>    <span>let</span> args = Args::parse();
</span></span><span><span>17</span><span>    <span>let</span> dir = Path::new(&amp;args.examples_dir);
</span></span><span><span>18</span><span>
</span></span><span><span>19</span><span>    <span>for</span> entry <span>in</span> fs::read_dir(dir)? {
</span></span><span><span>20</span><span>        <span>let</span> entry = entry?;
</span></span><span><span>21</span><span>        <span>let</span> path = entry.path();
</span></span><span><span>22</span><span>        <span>if</span> path.extension().and_then(|s| s.to_str()) == <span>Some</span>(<span>&#34;S&#34;</span>) {
</span></span><span><span>23</span><span>            <span>let</span> name = path.file_stem().unwrap().to_str().unwrap();
</span></span><span><span>24</span><span>            <span>let</span> output = dir.join(<span>format!</span>(<span>&#34;</span><span>{}</span><span>.elf&#34;</span>, name));
</span></span><span><span>25</span><span>            build_asm(&amp;path, &amp;output)?;
</span></span><span><span>26</span><span>        }
</span></span><span><span>27</span><span>    }
</span></span><span><span>28</span><span>
</span></span><span><span>29</span><span>    <span>Ok</span>(())
</span></span><span><span>30</span><span>}
</span></span><span><span>31</span><span>
</span></span><span><span>32</span><span><span>fn</span> <span>build_asm</span>(input: <span>&amp;</span><span>Path</span>, output: <span>&amp;</span><span>Path</span>) -&gt; <span>Result</span>&lt;(), <span>Box</span>&lt;<span>dyn</span> std::error::Error&gt;&gt; {
</span></span><span><span>33</span><span>    <span>println!</span>(<span>&#34;Building </span><span>{}</span><span> -&gt; </span><span>{}</span><span>&#34;</span>, input.display(), output.display());
</span></span><span><span>34</span><span>
</span></span><span><span>35</span><span>    <span>let</span> obj_file = input.with_extension(<span>&#34;o&#34;</span>);
</span></span><span><span>36</span><span>
</span></span><span><span>37</span><span>    <span>let</span> status = Command::new(<span>&#34;arm-none-eabi-as&#34;</span>)
</span></span><span><span>38</span><span>        .arg(<span>&#34;-march=armv7-a&#34;</span>)
</span></span><span><span>39</span><span>        .arg(input)
</span></span><span><span>40</span><span>        .arg(<span>&#34;-o&#34;</span>)
</span></span><span><span>41</span><span>        .arg(&amp;obj_file)
</span></span><span><span>42</span><span>        .status()?;
</span></span><span><span>43</span><span>
</span></span><span><span>44</span><span>    <span>if</span> !status.success() {
</span></span><span><span>45</span><span>        <span>return</span> <span>Err</span>(<span>format!</span>(<span>&#34;Assembler failed for </span><span>{}</span><span>&#34;</span>, input.display()).into());
</span></span><span><span>46</span><span>    }
</span></span><span><span>47</span><span>
</span></span><span><span>48</span><span>    <span>let</span> status = Command::new(<span>&#34;arm-none-eabi-ld&#34;</span>)
</span></span><span><span>49</span><span>        .arg(<span>&#34;-Ttext=0x8000&#34;</span>)
</span></span><span><span>50</span><span>        .arg(&amp;obj_file)
</span></span><span><span>51</span><span>        .arg(<span>&#34;-o&#34;</span>)
</span></span><span><span>52</span><span>        .arg(output)
</span></span><span><span>53</span><span>        .status()?;
</span></span><span><span>54</span><span>
</span></span><span><span>55</span><span>    <span>if</span> !status.success() {
</span></span><span><span>56</span><span>        <span>return</span> <span>Err</span>(<span>format!</span>(<span>&#34;Linker failed for </span><span>{}</span><span>&#34;</span>, output.display()).into());
</span></span><span><span>57</span><span>    }
</span></span><span><span>58</span><span>
</span></span><span><span>59</span><span>    <span>Ok</span>(fs::remove_file(obj_file)?)
</span></span><span><span>60</span><span>}</span></span></code></pre></div><p><span>TOML</span></p><div><pre tabindex="0"><code data-lang="toml"><span><span> 1</span><span><span># Cargo.toml</span>
</span></span><span><span> 2</span><span>[package]
</span></span><span><span> 3</span><span>name = <span>&#34;stinkarm&#34;</span>
</span></span><span><span> 4</span><span>version = <span>&#34;0.1.0&#34;</span>
</span></span><span><span> 5</span><span>edition = <span>&#34;2024&#34;</span>
</span></span><span><span> 6</span><span>default-run = <span>&#34;stinkarm&#34;</span>
</span></span><span><span> 7</span><span>
</span></span><span><span> 8</span><span>[dependencies]
</span></span><span><span> 9</span><span>clap = { version = <span>&#34;4.5.51&#34;</span>, features = [<span>&#34;derive&#34;</span>] }
</span></span><span><span>10</span><span>
</span></span><span><span>11</span><span>[[bin]]
</span></span><span><span>12</span><span>name = <span>&#34;stinkarm&#34;</span>
</span></span><span><span>13</span><span>path = <span>&#34;src/main.rs&#34;</span>
</span></span><span><span>14</span><span>
</span></span><span><span>15</span><span>[[bin]]
</span></span><span><span>16</span><span>name = <span>&#34;bld_exmpl&#34;</span>
</span></span><span><span>17</span><span>path = <span>&#34;tools/bld_exmpl.rs&#34;</span></span></span></code></pre></div><p><span>NIX</span></p><div><pre tabindex="0"><code data-lang="nix"><span><span> 1</span><span>{
</span></span><span><span> 2</span><span>  description = <span>&#34;stinkarm — ARMv7 userspace binary emulator for x86 linux systems&#34;</span>;
</span></span><span><span> 3</span><span>  inputs = {
</span></span><span><span> 4</span><span>    nixpkgs.url = <span>&#34;github:NixOS/nixpkgs/nixos-unstable&#34;</span>;
</span></span><span><span> 5</span><span>    flake-utils.url = <span>&#34;github:numtide/flake-utils&#34;</span>;
</span></span><span><span> 6</span><span>  };
</span></span><span><span> 7</span><span>  outputs = { self, nixpkgs, flake-utils, ... }:
</span></span><span><span> 8</span><span>    flake-utils.lib.eachDefaultSystem (system:
</span></span><span><span> 9</span><span>      <span>let</span>
</span></span><span><span>10</span><span>        pkgs = <span>import</span> nixpkgs { <span>inherit</span> system; };
</span></span><span><span>11</span><span>      <span>in</span> {
</span></span><span><span>12</span><span>        devShells.default = pkgs.mkShell {
</span></span><span><span>13</span><span>          buildInputs = <span>with</span> pkgs; [
</span></span><span><span>14</span><span>            gcc-arm-embedded
</span></span><span><span>15</span><span>            binutils
</span></span><span><span>16</span><span>            qemu
</span></span><span><span>17</span><span>          ];
</span></span><span><span>18</span><span>        };
</span></span><span><span>19</span><span>      }
</span></span><span><span>20</span><span>  );
</span></span><span><span>21</span><span>}</span></span></code></pre></div></details><p>So there are some resources for parsing ELF, two of them I used a whole lot:</p><ol><li><a href="https://linux.die.net/man/5/elf"><code>man elf</code></a> <em>(remember to <code>export MANPAGER=&#39;nvim +Man!&#39;</code>)</em></li><li><a href="https://gabi.xinuos.com/index.html">gabi.xinuos.com</a></li></ol><p>At a high level, ELF (32bit, for armv7) consists of headers and segments, it
holds an Elf header, multiple program headers and the rest I don’t care about,
since this emulator is only for static binaries, no dynamically linked support.</p><h2 id="elf32_ehdr">Elf32_Ehdr</h2><p>The ELF header is exactly 52 bytes long and holds all data I need to find the
program headers and whether I even want to emulate the binary I’m currently
parsing. These criteria are defined as members of the <code>Identifier</code> at the beg
of the header.</p><p>In terms of byte layout:</p><p><span>TEXT</span></p><div><pre tabindex="0"><code data-lang="text"><span><span> 1</span><span>+------------------------+--------+--------+----------------+----------------+----------------+----------------+----------------+--------+---------+--------+---------+--------+--------+
</span></span><span><span> 2</span><span>|       identifier       |  type  |machine |    version     |     entry      |     phoff      |     shoff      |     flags      | ehsize |phentsize| phnum  |shentsize| shnum  |shstrndx|
</span></span><span><span> 3</span><span>|          16B           |   2B   |   2B   |       4B       |       4B       |       4B       |       4B       |       4B       |   2B   |   2B    |   2B   |   2B    |   2B   |   2B   |
</span></span><span><span> 4</span><span>+------------------------+--------+--------+----------------+----------------+----------------+----------------+----------------+--------+---------+--------+---------+--------+--------+
</span></span><span><span> 5</span><span>           \|/
</span></span><span><span> 6</span><span>            |
</span></span><span><span> 7</span><span>            |
</span></span><span><span> 8</span><span>            v
</span></span><span><span> 9</span><span>+----------------+------+------+-------+------+-----------+------------------------+
</span></span><span><span>10</span><span>|     magic      |class | data |version|os_abi|abi_version|          pad           |
</span></span><span><span>11</span><span>|       4B       |  1B  |  1B  |  1B   |  1B  |    1B     |           7B           |
</span></span><span><span>12</span><span>+----------------+------+------+-------+------+-----------+------------------------+</span></span></code></pre></div><p>Most resources show C based examples, the rust ports are
below:</p><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span> 1</span><span><span>/// Representing the ELF Object File Format header in memory, equivalent to Elf32_Ehdr in 2. ELF
</span></span></span><span><span> 2</span><span><span>/// header in https://gabi.xinuos.com/elf/02-eheader.html
</span></span></span><span><span> 3</span><span><span>///
</span></span></span><span><span> 4</span><span><span>/// Types are taken from https://gabi.xinuos.com/elf/01-intro.html#data-representation Table 1.1
</span></span></span><span><span> 5</span><span><span>/// 32-Bit Data Types:
</span></span></span><span><span> 6</span><span><span>///
</span></span></span><span><span> 7</span><span><span>/// | Elf32_ | Rust |
</span></span></span><span><span> 8</span><span><span>/// | ------ | ---- |
</span></span></span><span><span> 9</span><span><span>/// | Addr   | u32  |
</span></span></span><span><span>10</span><span><span>/// | Off    | u32  |
</span></span></span><span><span>11</span><span><span>/// | Half   | u16  |
</span></span></span><span><span>12</span><span><span>/// | Word   | u32  |
</span></span></span><span><span>13</span><span><span>/// | Sword  | i32  |
</span></span></span><span><span>14</span><span><span></span><span>#[derive(Debug, Clone, Copy, PartialEq, Eq)]</span>
</span></span><span><span>15</span><span><span>pub</span> <span>struct</span> <span>Header</span> {
</span></span><span><span>16</span><span>    <span>/// initial bytes mark the file as an object file and provide machine-independent data with
</span></span></span><span><span>17</span><span><span></span>    <span>/// which to decode and interpret the file’s contents
</span></span></span><span><span>18</span><span><span></span>    <span>pub</span> ident: <span>Identifier</span>,
</span></span><span><span>19</span><span>    <span>pub</span> r#type: <span>Type</span>,
</span></span><span><span>20</span><span>    <span>pub</span> machine: <span>Machine</span>,
</span></span><span><span>21</span><span>    <span>/// identifies the object file version, always EV_CURRENT (1)
</span></span></span><span><span>22</span><span><span></span>    <span>pub</span> version: <span>u32</span>,
</span></span><span><span>23</span><span>    <span>/// the virtual address to which the system first transfers control, thus starting
</span></span></span><span><span>24</span><span><span></span>    <span>/// the process. If the file has no associated entry point, this member holds zero
</span></span></span><span><span>25</span><span><span></span>    <span>pub</span> entry: <span>u32</span>,
</span></span><span><span>26</span><span>    <span>/// the program header table’s file offset in bytes. If the file has no program header table,
</span></span></span><span><span>27</span><span><span></span>    <span>/// this member holds zero
</span></span></span><span><span>28</span><span><span></span>    <span>pub</span> phoff: <span>u32</span>,
</span></span><span><span>29</span><span>    <span>/// the section header table’s file offset in bytes. If the file has no section header table, this
</span></span></span><span><span>30</span><span><span></span>    <span>/// member holds zero
</span></span></span><span><span>31</span><span><span></span>    <span>pub</span> shoff: <span>u32</span>,
</span></span><span><span>32</span><span>    <span>/// processor-specific flags associated with the file
</span></span></span><span><span>33</span><span><span></span>    <span>pub</span> flags: <span>u32</span>,
</span></span><span><span>34</span><span>    <span>/// the ELF header’s size in bytes
</span></span></span><span><span>35</span><span><span></span>    <span>pub</span> ehsize: <span>u16</span>,
</span></span><span><span>36</span><span>    <span>/// the size in bytes of one entry in the file’s program header table; all entries are the same
</span></span></span><span><span>37</span><span><span></span>    <span>/// size
</span></span></span><span><span>38</span><span><span></span>    <span>pub</span> phentsize: <span>u16</span>,
</span></span><span><span>39</span><span>    <span>/// the number of entries in the program header table. Thus the product of e_phentsize and e_phnum
</span></span></span><span><span>40</span><span><span></span>    <span>/// gives the table’s size in bytes. If a file has no program header table, e_phnum holds the value
</span></span></span><span><span>41</span><span><span></span>    <span>/// zero
</span></span></span><span><span>42</span><span><span></span>    <span>pub</span> phnum: <span>u16</span>,
</span></span><span><span>43</span><span>    <span>/// section header’s size in bytes. A section header is one entry in the section header table; all
</span></span></span><span><span>44</span><span><span></span>    <span>/// entries are the same size
</span></span></span><span><span>45</span><span><span></span>    <span>pub</span> shentsize: <span>u16</span>,
</span></span><span><span>46</span><span>    <span>/// number of entries in the section header table. Thus the product of e_shentsize and e_shnum
</span></span></span><span><span>47</span><span><span></span>    <span>/// gives the section header table’s size in bytes. If a file has no section header table,
</span></span></span><span><span>48</span><span><span></span>    <span>/// e_shnum holds the value zero.
</span></span></span><span><span>49</span><span><span></span>    <span>pub</span> shnum: <span>u16</span>,
</span></span><span><span>50</span><span>    <span>/// the section header table index of the entry associated with the section name string table.
</span></span></span><span><span>51</span><span><span></span>    <span>/// If the file has no section name string table, this member holds the value SHN_UNDEF
</span></span></span><span><span>52</span><span><span></span>    <span>pub</span> shstrndx: <span>u16</span>,
</span></span><span><span>53</span><span>}</span></span></code></pre></div><p>The identifier is 16 bytes long and holds the previously mentioned info so I
can check if I want to emulate the binary, for instance the endianness and the
bit class, in the <code>TryFrom</code> implementation I strictly check what is parsed:</p><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span> 1</span><span><span>/// 2.2 ELF Identification: https://gabi.xinuos.com/elf/02-eheader.html#elf-identification
</span></span></span><span><span> 2</span><span><span></span><span>#[repr(C)]</span>
</span></span><span><span> 3</span><span><span>#[derive(Debug, Clone, Copy, PartialEq, Eq)]</span>
</span></span><span><span> 4</span><span><span>pub</span> <span>struct</span> <span>Identifier</span> {
</span></span><span><span> 5</span><span>    <span>/// 0x7F, &#39;E&#39;, &#39;L&#39;, &#39;F&#39;
</span></span></span><span><span> 6</span><span><span></span>    <span>pub</span> magic: [<span>u8</span>; <span>4</span>],
</span></span><span><span> 7</span><span>    <span>/// file class or capacity
</span></span></span><span><span> 8</span><span><span></span>    <span>///
</span></span></span><span><span> 9</span><span><span></span>    <span>/// | Name          | Value | Meaning       |
</span></span></span><span><span>10</span><span><span></span>    <span>/// | ------------- | ----- | ------------- |
</span></span></span><span><span>11</span><span><span></span>    <span>/// | ELFCLASSNONE  | 0     | Invalid class |
</span></span></span><span><span>12</span><span><span></span>    <span>/// | ELFCLASS32    | 1     | 32-bit        |
</span></span></span><span><span>13</span><span><span></span>    <span>/// | ELFCLASS64    | 2     | 64-bit        |
</span></span></span><span><span>14</span><span><span></span>    <span>pub</span> class: <span>u8</span>,
</span></span><span><span>15</span><span>    <span>/// data encoding, endian
</span></span></span><span><span>16</span><span><span></span>    <span>///
</span></span></span><span><span>17</span><span><span></span>    <span>/// | Name         | Value |
</span></span></span><span><span>18</span><span><span></span>    <span>/// | ------------ | ----- |
</span></span></span><span><span>19</span><span><span></span>    <span>/// | ELFDATANONE  | 0     |
</span></span></span><span><span>20</span><span><span></span>    <span>/// | ELFDATA2LSB  | 1     |
</span></span></span><span><span>21</span><span><span></span>    <span>/// | ELFDATA2MSB  | 2     |
</span></span></span><span><span>22</span><span><span></span>    <span>pub</span> data: <span>u8</span>,
</span></span><span><span>23</span><span>    <span>/// file version, always EV_CURRENT (1)
</span></span></span><span><span>24</span><span><span></span>    <span>pub</span> version: <span>u8</span>,
</span></span><span><span>25</span><span>    <span>/// operating system identification
</span></span></span><span><span>26</span><span><span></span>    <span>///
</span></span></span><span><span>27</span><span><span></span>    <span>/// - if no extensions are used: 0
</span></span></span><span><span>28</span><span><span></span>    <span>/// - meaning depends on e_machine
</span></span></span><span><span>29</span><span><span></span>    <span>pub</span> os_abi: <span>u8</span>,
</span></span><span><span>30</span><span>    <span>/// value depends on os_abi
</span></span></span><span><span>31</span><span><span></span>    <span>pub</span> abi_version: <span>u8</span>,
</span></span><span><span>32</span><span>    <span>// padding bytes (9-15)
</span></span></span><span><span>33</span><span><span></span>    _pad: [<span>u8</span>; <span>7</span>],
</span></span><span><span>34</span><span>}
</span></span><span><span>35</span><span>
</span></span><span><span>36</span><span><span>impl</span> TryFrom&lt;&amp;[<span>u8</span>]&gt; <span>for</span> Identifier {
</span></span><span><span>37</span><span>    <span>type</span> <span>Error</span> = &amp;<span>&#39;static</span> <span>str</span>;
</span></span><span><span>38</span><span>
</span></span><span><span>39</span><span>    <span>fn</span> <span>try_from</span>(bytes: <span>&amp;</span>[<span>u8</span>]) -&gt; <span>Result</span>&lt;<span>Self</span>, <span>Self</span>::Error&gt; {
</span></span><span><span>40</span><span>        <span>if</span> bytes.len() &lt; <span>16</span> {
</span></span><span><span>41</span><span>            <span>return</span> <span>Err</span>(<span>&#34;e_ident too short for ELF&#34;</span>);
</span></span><span><span>42</span><span>        }
</span></span><span><span>43</span><span>
</span></span><span><span>44</span><span>        <span>// I don&#39;t want to cast via unsafe as_ptr and as Header because the header could outlive the
</span></span></span><span><span>45</span><span><span></span>        <span>// source slice, thus we just do it the old plain indexing way
</span></span></span><span><span>46</span><span><span></span>        <span>let</span> ident = <span>Self</span> {
</span></span><span><span>47</span><span>            magic: <span>bytes</span>[<span>0</span>..<span>4</span>].try_into().unwrap(),
</span></span><span><span>48</span><span>            class: <span>bytes</span>[<span>4</span>],
</span></span><span><span>49</span><span>            data: <span>bytes</span>[<span>5</span>],
</span></span><span><span>50</span><span>            version: <span>bytes</span>[<span>6</span>],
</span></span><span><span>51</span><span>            os_abi: <span>bytes</span>[<span>7</span>],
</span></span><span><span>52</span><span>            abi_version: <span>bytes</span>[<span>8</span>],
</span></span><span><span>53</span><span>            _pad: <span>bytes</span>[<span>9</span>..<span>16</span>].try_into().unwrap(),
</span></span><span><span>54</span><span>        };
</span></span><span><span>55</span><span>
</span></span><span><span>56</span><span>        <span>if</span> ident.magic != [<span>0x7f</span>, <span>b</span><span>&#39;E&#39;</span>, <span>b</span><span>&#39;L&#39;</span>, <span>b</span><span>&#39;F&#39;</span>] {
</span></span><span><span>57</span><span>            <span>return</span> <span>Err</span>(<span>&#34;Unexpected EI_MAG0 to EI_MAG3, wanted 0x7f E L F&#34;</span>);
</span></span><span><span>58</span><span>        }
</span></span><span><span>59</span><span>
</span></span><span><span>60</span><span>        <span>const</span> ELFCLASS32: <span>u8</span> = <span>1</span>;
</span></span><span><span>61</span><span>        <span>const</span> ELFDATA2LSB: <span>u8</span> = <span>1</span>;
</span></span><span><span>62</span><span>        <span>const</span> EV_CURRENT: <span>u8</span> = <span>1</span>;
</span></span><span><span>63</span><span>
</span></span><span><span>64</span><span>        <span>if</span> ident.version != EV_CURRENT {
</span></span><span><span>65</span><span>            <span>return</span> <span>Err</span>(<span>&#34;Unsupported EI_VERSION value&#34;</span>);
</span></span><span><span>66</span><span>        }
</span></span><span><span>67</span><span>
</span></span><span><span>68</span><span>        <span>if</span> ident.class != ELFCLASS32 {
</span></span><span><span>69</span><span>            <span>return</span> <span>Err</span>(<span>&#34;Unexpected EI_CLASS: ELFCLASS64, wanted ELFCLASS32 (ARMv7)&#34;</span>);
</span></span><span><span>70</span><span>        }
</span></span><span><span>71</span><span>
</span></span><span><span>72</span><span>        <span>if</span> ident.data != ELFDATA2LSB {
</span></span><span><span>73</span><span>            <span>return</span> <span>Err</span>(<span>&#34;Unexpected EI_DATA: big-endian, wanted little&#34;</span>);
</span></span><span><span>74</span><span>        }
</span></span><span><span>75</span><span>
</span></span><span><span>76</span><span>        <span>Ok</span>(ident)
</span></span><span><span>77</span><span>    }</span></span></code></pre></div><p><code>Type</code> and <code>Machine</code> are just enums encoding meaning in the Rust type system:</p><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span> 1</span><span><span>#[repr(u16)]</span>
</span></span><span><span> 2</span><span><span>#[derive(Debug, Clone, Copy, PartialEq, Eq)]</span>
</span></span><span><span> 3</span><span><span>pub</span> <span>enum</span> <span>Type</span> {
</span></span><span><span> 4</span><span>    <span>None</span> = <span>0</span>,
</span></span><span><span> 5</span><span>    Relocatable = <span>1</span>,
</span></span><span><span> 6</span><span>    Executable = <span>2</span>,
</span></span><span><span> 7</span><span>    SharedObject = <span>3</span>,
</span></span><span><span> 8</span><span>    Core = <span>4</span>,
</span></span><span><span> 9</span><span>    LoOs = <span>0xfe00</span>,
</span></span><span><span>10</span><span>    HiOs = <span>0xfeff</span>,
</span></span><span><span>11</span><span>    LoProc = <span>0xff00</span>,
</span></span><span><span>12</span><span>    HiProc = <span>0xffff</span>,
</span></span><span><span>13</span><span>}
</span></span><span><span>14</span><span>
</span></span><span><span>15</span><span><span>impl</span> TryFrom&lt;<span>u16</span>&gt; <span>for</span> Type {
</span></span><span><span>16</span><span>    <span>type</span> <span>Error</span> = &amp;<span>&#39;static</span> <span>str</span>;
</span></span><span><span>17</span><span>
</span></span><span><span>18</span><span>    <span>fn</span> <span>try_from</span>(value: <span>u16</span>) -&gt; <span>Result</span>&lt;<span>Self</span>, <span>Self</span>::Error&gt; {
</span></span><span><span>19</span><span>        <span>match</span> value {
</span></span><span><span>20</span><span>            <span>0</span> =&gt; <span>Ok</span>(Type::<span>None</span>),
</span></span><span><span>21</span><span>            <span>1</span> =&gt; <span>Ok</span>(Type::Relocatable),
</span></span><span><span>22</span><span>            <span>2</span> =&gt; <span>Ok</span>(Type::Executable),
</span></span><span><span>23</span><span>            <span>3</span> =&gt; <span>Ok</span>(Type::SharedObject),
</span></span><span><span>24</span><span>            <span>4</span> =&gt; <span>Ok</span>(Type::Core),
</span></span><span><span>25</span><span>            <span>0xfe00</span> =&gt; <span>Ok</span>(Type::LoOs),
</span></span><span><span>26</span><span>            <span>0xfeff</span> =&gt; <span>Ok</span>(Type::HiOs),
</span></span><span><span>27</span><span>            <span>0xff00</span> =&gt; <span>Ok</span>(Type::LoProc),
</span></span><span><span>28</span><span>            <span>0xffff</span> =&gt; <span>Ok</span>(Type::HiProc),
</span></span><span><span>29</span><span>            _ =&gt; <span>Err</span>(<span>&#34;Invalid u16 value for e_type&#34;</span>),
</span></span><span><span>30</span><span>        }
</span></span><span><span>31</span><span>    }
</span></span><span><span>32</span><span>}
</span></span><span><span>33</span><span>
</span></span><span><span>34</span><span>
</span></span><span><span>35</span><span><span>#[repr(u16)]</span>
</span></span><span><span>36</span><span><span>#[allow(non_camel_case_types)]</span>
</span></span><span><span>37</span><span><span>#[derive(Debug, Clone, Copy, PartialEq, Eq)]</span>
</span></span><span><span>38</span><span><span>pub</span> <span>enum</span> <span>Machine</span> {
</span></span><span><span>39</span><span>    EM_ARM = <span>40</span>,
</span></span><span><span>40</span><span>}
</span></span><span><span>41</span><span>
</span></span><span><span>42</span><span><span>impl</span> TryFrom&lt;<span>u16</span>&gt; <span>for</span> Machine {
</span></span><span><span>43</span><span>    <span>type</span> <span>Error</span> = &amp;<span>&#39;static</span> <span>str</span>;
</span></span><span><span>44</span><span>
</span></span><span><span>45</span><span>    <span>fn</span> <span>try_from</span>(value: <span>u16</span>) -&gt; <span>Result</span>&lt;<span>Self</span>, <span>Self</span>::Error&gt; {
</span></span><span><span>46</span><span>        <span>match</span> value {
</span></span><span><span>47</span><span>            <span>40</span> =&gt; <span>Ok</span>(Machine::EM_ARM),
</span></span><span><span>48</span><span>            _ =&gt; <span>Err</span>(<span>&#34;Unsupported machine&#34;</span>),
</span></span><span><span>49</span><span>        }
</span></span><span><span>50</span><span>    }
</span></span><span><span>51</span><span>}</span></span></code></pre></div><p>Since all of <code>Header</code>’s members implement <code>TryFrom</code> we can implement
<code>TryFrom&lt;&amp;[u8]&gt; for Header</code> and propagate all occurring errors in member parsing
cleanly via <code>?</code>:</p><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span> 1</span><span><span>impl</span> TryFrom&lt;&amp;[<span>u8</span>]&gt; <span>for</span> Header {
</span></span><span><span> 2</span><span>    <span>type</span> <span>Error</span> = &amp;<span>&#39;static</span> <span>str</span>;
</span></span><span><span> 3</span><span>
</span></span><span><span> 4</span><span>    <span>fn</span> <span>try_from</span>(b: <span>&amp;</span>[<span>u8</span>]) -&gt; <span>Result</span>&lt;<span>Self</span>, <span>Self</span>::Error&gt; {
</span></span><span><span> 5</span><span>        <span>if</span> b.len() &lt; <span>52</span> {
</span></span><span><span> 6</span><span>            <span>return</span> <span>Err</span>(<span>&#34;not enough bytes for Elf32_Ehdr (ELF header)&#34;</span>);
</span></span><span><span> 7</span><span>        }
</span></span><span><span> 8</span><span>
</span></span><span><span> 9</span><span>        <span>let</span> header = <span>Self</span> {
</span></span><span><span>10</span><span>            ident: <span>b</span>[<span>0</span>..<span>16</span>].try_into()?,
</span></span><span><span>11</span><span>            r#type: <span>le16</span>!(b[<span>16</span>..<span>18</span>]).try_into()?,
</span></span><span><span>12</span><span>            machine: <span>le16</span>!(b[<span>18</span>..<span>20</span>]).try_into()?,
</span></span><span><span>13</span><span>            version: <span>le32</span>!(b[<span>20</span>..<span>24</span>]),
</span></span><span><span>14</span><span>            entry: <span>le32</span>!(b[<span>24</span>..<span>28</span>]),
</span></span><span><span>15</span><span>            phoff: <span>le32</span>!(b[<span>28</span>..<span>32</span>]),
</span></span><span><span>16</span><span>            shoff: <span>le32</span>!(b[<span>32</span>..<span>36</span>]),
</span></span><span><span>17</span><span>            flags: <span>le32</span>!(b[<span>36</span>..<span>40</span>]),
</span></span><span><span>18</span><span>            ehsize: <span>le16</span>!(b[<span>40</span>..<span>42</span>]),
</span></span><span><span>19</span><span>            phentsize: <span>le16</span>!(b[<span>42</span>..<span>44</span>]),
</span></span><span><span>20</span><span>            phnum: <span>le16</span>!(b[<span>44</span>..<span>46</span>]),
</span></span><span><span>21</span><span>            shentsize: <span>le16</span>!(b[<span>46</span>..<span>48</span>]),
</span></span><span><span>22</span><span>            shnum: <span>le16</span>!(b[<span>48</span>..<span>50</span>]),
</span></span><span><span>23</span><span>            shstrndx: <span>le16</span>!(b[<span>50</span>..<span>52</span>]),
</span></span><span><span>24</span><span>        };
</span></span><span><span>25</span><span>
</span></span><span><span>26</span><span>        <span>match</span> header.r#type {
</span></span><span><span>27</span><span>            Type::Executable =&gt; (),
</span></span><span><span>28</span><span>            _ =&gt; {
</span></span><span><span>29</span><span>                <span>return</span> <span>Err</span>(<span>&#34;Unsupported ELF type, only ET_EXEC (static executables) is supported&#34;</span>);
</span></span><span><span>30</span><span>            }
</span></span><span><span>31</span><span>        }
</span></span><span><span>32</span><span>
</span></span><span><span>33</span><span>        <span>Ok</span>(header)
</span></span><span><span>34</span><span>    }
</span></span><span><span>35</span><span>}</span></span></code></pre></div><p>The attentive reader will see me using <code>le16!</code> and <code>le32!</code> for parsing bytes
into unsigned integers of different classes (<code>le</code> is short for little endian):</p><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span> 1</span><span><span>#[macro_export]</span>
</span></span><span><span> 2</span><span>macro_rules! le16 {
</span></span><span><span> 3</span><span>    (<span>$bytes</span>:<span>expr</span>) =&gt; {{
</span></span><span><span> 4</span><span>        <span>let</span> b: [<span>u8</span>; <span>2</span>] = <span>$bytes</span>
</span></span><span><span> 5</span><span>            .try_into()
</span></span><span><span> 6</span><span>            .map_err(|_| <span>&#34;Failed to create u16 from 2*u8&#34;</span>)?;
</span></span><span><span> 7</span><span>        <span>u16</span>::from_le_bytes(b)
</span></span><span><span> 8</span><span>    }};
</span></span><span><span> 9</span><span>}
</span></span><span><span>10</span><span>
</span></span><span><span>11</span><span><span>#[macro_export]</span>
</span></span><span><span>12</span><span>macro_rules! le32 {
</span></span><span><span>13</span><span>    (<span>$bytes</span>:<span>expr</span>) =&gt; {{
</span></span><span><span>14</span><span>        <span>let</span> b: [<span>u8</span>; <span>4</span>] = <span>$bytes</span>
</span></span><span><span>15</span><span>            .try_into()
</span></span><span><span>16</span><span>            .map_err(|_| <span>&#34;Failed to create u32 from 4*u8&#34;</span>)?;
</span></span><span><span>17</span><span>        <span>u32</span>::from_le_bytes(b)
</span></span><span><span>18</span><span>    }};
</span></span><span><span>19</span><span>}</span></span></code></pre></div><h2 id="elf32_phdr">Elf32_Phdr</h2><p><span>TEXT</span></p><div><pre tabindex="0"><code data-lang="text"><span><span>1</span><span>+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+
</span></span><span><span>2</span><span>|      type      |     offset     |     vaddr      |     paddr      |     filesz     |     memsz      |     flags      |     align      |
</span></span><span><span>3</span><span>|       4B       |       4B       |       4B       |       4B       |       4B       |       4B       |       4B       |       4B       |
</span></span><span><span>4</span><span>+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+</span></span></code></pre></div><p>For me, the most important fields in <code>Header</code> are <code>phoff</code> and <code>phentsize</code>,
since we can use these to index into the binary to locate the program headers (<code>Phdr</code>).</p><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span> 1</span><span><span>/// Phdr, equivalent to Elf32_Phdr, see: https://gabi.xinuos.com/elf/07-pheader.html
</span></span></span><span><span> 2</span><span><span>///
</span></span></span><span><span> 3</span><span><span>/// All of its member are u32, be it Elf32_Word, Elf32_Off or Elf32_Addr
</span></span></span><span><span> 4</span><span><span></span><span>#[derive(Debug)]</span>
</span></span><span><span> 5</span><span><span>pub</span> <span>struct</span> <span>Pheader</span> {
</span></span><span><span> 6</span><span>    <span>pub</span> r#type: <span>Type</span>,
</span></span><span><span> 7</span><span>    <span>pub</span> offset: <span>u32</span>,
</span></span><span><span> 8</span><span>    <span>pub</span> vaddr: <span>u32</span>,
</span></span><span><span> 9</span><span>    <span>pub</span> paddr: <span>u32</span>,
</span></span><span><span>10</span><span>    <span>pub</span> filesz: <span>u32</span>,
</span></span><span><span>11</span><span>    <span>pub</span> memsz: <span>u32</span>,
</span></span><span><span>12</span><span>    <span>pub</span> flags: <span>Flags</span>,
</span></span><span><span>13</span><span>    <span>pub</span> align: <span>u32</span>,
</span></span><span><span>14</span><span>}
</span></span><span><span>15</span><span>
</span></span><span><span>16</span><span><span>impl</span> Pheader {
</span></span><span><span>17</span><span>    <span>/// extracts Pheader from raw, starting from offset
</span></span></span><span><span>18</span><span><span></span>    <span>pub</span> <span>fn</span> <span>from</span>(raw: <span>&amp;</span>[<span>u8</span>], offset: <span>usize</span>) -&gt; <span>Result</span>&lt;<span>Self</span>, <span>String</span>&gt; {
</span></span><span><span>19</span><span>        <span>let</span> end = offset.checked_add(<span>32</span>).ok_or(<span>&#34;Offset overflow&#34;</span>)?;
</span></span><span><span>20</span><span>        <span>if</span> raw.len() &lt; end {
</span></span><span><span>21</span><span>            <span>return</span> <span>Err</span>(<span>&#34;Not enough bytes to parse Elf32_Phdr, need at least 32&#34;</span>.into());
</span></span><span><span>22</span><span>        }
</span></span><span><span>23</span><span>
</span></span><span><span>24</span><span>        <span>let</span> p_raw = &amp;raw[offset..end];
</span></span><span><span>25</span><span>        <span>let</span> r#type = p_raw[<span>0</span>..<span>4</span>].try_into()?;
</span></span><span><span>26</span><span>        <span>let</span> flags = p_raw[<span>24</span>..<span>28</span>].try_into()?;
</span></span><span><span>27</span><span>        <span>let</span> align = <span>le32!</span>(p_raw[<span>28</span>..<span>32</span>]);
</span></span><span><span>28</span><span>
</span></span><span><span>29</span><span>        <span>if</span> align &gt; <span>1</span> &amp;&amp; !align.is_power_of_two() {
</span></span><span><span>30</span><span>            <span>return</span> <span>Err</span>(<span>format!</span>(<span>&#34;Invalid p_align: </span><span>{}</span><span>&#34;</span>, align));
</span></span><span><span>31</span><span>        }
</span></span><span><span>32</span><span>
</span></span><span><span>33</span><span>        <span>Ok</span>(<span>Self</span> {
</span></span><span><span>34</span><span>            r#type,
</span></span><span><span>35</span><span>            offset: <span>le32</span>!(p_raw[<span>4</span>..<span>8</span>]),
</span></span><span><span>36</span><span>            vaddr: <span>le32</span>!(p_raw[<span>8</span>..<span>12</span>]),
</span></span><span><span>37</span><span>            paddr: <span>le32</span>!(p_raw[<span>12</span>..<span>16</span>]),
</span></span><span><span>38</span><span>            filesz: <span>le32</span>!(p_raw[<span>16</span>..<span>20</span>]),
</span></span><span><span>39</span><span>            memsz: <span>le32</span>!(p_raw[<span>20</span>..<span>24</span>]),
</span></span><span><span>40</span><span>            flags,
</span></span><span><span>41</span><span>            align,
</span></span><span><span>42</span><span>        })
</span></span><span><span>43</span><span>    }
</span></span><span><span>44</span><span>}</span></span></code></pre></div><p><code>Type</code> holds info about what type of segment the header defines:</p><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span> 1</span><span><span>#[derive(Debug, Clone, Copy, PartialEq, Eq)]</span>
</span></span><span><span> 2</span><span><span>#[repr(C)]</span>
</span></span><span><span> 3</span><span><span>pub</span> <span>enum</span> <span>Type</span> {
</span></span><span><span> 4</span><span>    NULL = <span>0</span>,
</span></span><span><span> 5</span><span>    LOAD = <span>1</span>,
</span></span><span><span> 6</span><span>    DYNAMIC = <span>2</span>,
</span></span><span><span> 7</span><span>    INTERP = <span>3</span>,
</span></span><span><span> 8</span><span>    NOTE = <span>4</span>,
</span></span><span><span> 9</span><span>    SHLIB = <span>5</span>,
</span></span><span><span>10</span><span>    PHDR = <span>6</span>,
</span></span><span><span>11</span><span>    TLS = <span>7</span>,
</span></span><span><span>12</span><span>    LOOS = <span>0x60000000</span>,
</span></span><span><span>13</span><span>    HIOS = <span>0x6fffffff</span>,
</span></span><span><span>14</span><span>    LOPROC = <span>0x70000000</span>,
</span></span><span><span>15</span><span>    HIPROC = <span>0x7fffffff</span>,
</span></span><span><span>16</span><span>}</span></span></code></pre></div><p><code>Flag</code> defines the
permission flags the segment should have once it is dumped into memory:</p><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span> 1</span><span><span>#[derive(Debug, Clone, Copy, PartialEq, Eq)]</span>
</span></span><span><span> 2</span><span><span>#[repr(transparent)]</span>
</span></span><span><span> 3</span><span><span>pub</span> <span>struct</span> <span>Flags</span>(<span>u32</span>);
</span></span><span><span> 4</span><span>
</span></span><span><span> 5</span><span><span>impl</span> Flags {
</span></span><span><span> 6</span><span>    <span>pub</span> <span>const</span> NONE: <span>Self</span> = Flags(<span>0x0</span>);
</span></span><span><span> 7</span><span>    <span>pub</span> <span>const</span> X: <span>Self</span> = Flags(<span>0x1</span>);
</span></span><span><span> 8</span><span>    <span>pub</span> <span>const</span> W: <span>Self</span> = Flags(<span>0x2</span>);
</span></span><span><span> 9</span><span>    <span>pub</span> <span>const</span> R: <span>Self</span> = Flags(<span>0x4</span>);
</span></span><span><span>10</span><span>}</span></span></code></pre></div><h2 id="full-elf-parsing">Full ELF parsing</h2><p>Putting <code>Elf32_Ehdr</code> and <code>Elf32_Phdr</code> parsing together:</p><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span> 1</span><span><span>/// Representing an ELF32 binary in memory
</span></span></span><span><span> 2</span><span><span>///
</span></span></span><span><span> 3</span><span><span>/// This does not include section headers (Elf32_Shdr), but only program headers (Elf32_Phdr), see either `man elf` and/or https://gabi.xinuos.com/elf/03-sheader.html
</span></span></span><span><span> 4</span><span><span></span><span>#[derive(Debug)]</span>
</span></span><span><span> 5</span><span><span>pub</span> <span>struct</span> <span>Elf</span> {
</span></span><span><span> 6</span><span>    <span>pub</span> header: <span>header</span>::Header,
</span></span><span><span> 7</span><span>    <span>pub</span> pheaders: <span>Vec</span>&lt;pheader::Pheader&gt;,
</span></span><span><span> 8</span><span>}
</span></span><span><span> 9</span><span>
</span></span><span><span>10</span><span><span>impl</span> TryFrom&lt;&amp;[<span>u8</span>]&gt; <span>for</span> Elf {
</span></span><span><span>11</span><span>    <span>type</span> <span>Error</span> = <span>String</span>;
</span></span><span><span>12</span><span>
</span></span><span><span>13</span><span>    <span>fn</span> <span>try_from</span>(b: <span>&amp;</span>[<span>u8</span>]) -&gt; <span>Result</span>&lt;<span>Self</span>, <span>String</span>&gt; {
</span></span><span><span>14</span><span>        <span>let</span> header = header::Header::try_from(b).map_err(|e| e.to_string())?;
</span></span><span><span>15</span><span>
</span></span><span><span>16</span><span>        <span>let</span> <span>mut</span> pheaders = <span>Vec</span>::with_capacity(header.phnum <span>as</span> <span>usize</span>);
</span></span><span><span>17</span><span>        <span>for</span> i <span>in</span> <span>0</span>..header.phnum {
</span></span><span><span>18</span><span>            <span>let</span> offset = header.phoff <span>as</span> <span>usize</span> + i <span>as</span> <span>usize</span> * header.phentsize <span>as</span> <span>usize</span>;
</span></span><span><span>19</span><span>            <span>let</span> ph = pheader::Pheader::from(b, offset)?;
</span></span><span><span>20</span><span>            pheaders.push(ph);
</span></span><span><span>21</span><span>        }
</span></span><span><span>22</span><span>
</span></span><span><span>23</span><span>        <span>Ok</span>(Elf { header, pheaders })
</span></span><span><span>24</span><span>    }
</span></span><span><span>25</span><span>}</span></span></code></pre></div><p>The equivalent to <code>readelf -l</code>:</p><p><span>TEXT</span></p><div><pre tabindex="0"><code data-lang="text"><span><span> 1</span><span>Elf {
</span></span><span><span> 2</span><span>    header: Header {
</span></span><span><span> 3</span><span>        ident: Identifier {
</span></span><span><span> 4</span><span>            magic: [127, 69, 76, 70],
</span></span><span><span> 5</span><span>            class: 1,
</span></span><span><span> 6</span><span>            data: 1,
</span></span><span><span> 7</span><span>            version: 1,
</span></span><span><span> 8</span><span>            os_abi: 0,
</span></span><span><span> 9</span><span>            abi_version: 0,
</span></span><span><span>10</span><span>            _pad: [0, 0, 0, 0, 0, 0, 0]
</span></span><span><span>11</span><span>        },
</span></span><span><span>12</span><span>        type: Executable,
</span></span><span><span>13</span><span>        machine: EM_ARM,
</span></span><span><span>14</span><span>        version: 1,
</span></span><span><span>15</span><span>        entry: 32768,
</span></span><span><span>16</span><span>        phoff: 52,
</span></span><span><span>17</span><span>        shoff: 4572,
</span></span><span><span>18</span><span>        flags: 83886592,
</span></span><span><span>19</span><span>        ehsize: 52,
</span></span><span><span>20</span><span>        phentsize: 32,
</span></span><span><span>21</span><span>        phnum: 1,
</span></span><span><span>22</span><span>        shentsize: 40,
</span></span><span><span>23</span><span>        shnum: 8,
</span></span><span><span>24</span><span>        shstrndx: 7
</span></span><span><span>25</span><span>    },
</span></span><span><span>26</span><span>    pheaders: [
</span></span><span><span>27</span><span>        Pheader {
</span></span><span><span>28</span><span>            type: LOAD,
</span></span><span><span>29</span><span>            offset: 4096,
</span></span><span><span>30</span><span>            vaddr: 32768,
</span></span><span><span>31</span><span>            paddr: 32768,
</span></span><span><span>32</span><span>            filesz: 12,
</span></span><span><span>33</span><span>            memsz: 12,
</span></span><span><span>34</span><span>            flags: Flags(5),
</span></span><span><span>35</span><span>            align: 4096
</span></span><span><span>36</span><span>        }
</span></span><span><span>37</span><span>    ]
</span></span><span><span>38</span><span>}</span></span></code></pre></div><p>Or in the debug output of stinkarm:</p><p><span>TEXT</span></p><div><pre tabindex="0"><code data-lang="text"><span><span> 1</span><span>[     0.613ms] opening binary &#34;examples/asm.elf&#34;
</span></span><span><span> 2</span><span>[     0.721ms] parsing ELF...
</span></span><span><span> 3</span><span>[     0.744ms] \
</span></span><span><span> 4</span><span>ELF Header:
</span></span><span><span> 5</span><span>  Magic:              [7f, 45, 4c, 46]
</span></span><span><span> 6</span><span>  Class:              ELF32
</span></span><span><span> 7</span><span>  Data:               Little endian
</span></span><span><span> 8</span><span>  Type:               Executable
</span></span><span><span> 9</span><span>  Machine:            EM_ARM
</span></span><span><span>10</span><span>  Version:            1
</span></span><span><span>11</span><span>  Entry point:        0x8000
</span></span><span><span>12</span><span>  Program hdr offset: 52 (32 bytes each)
</span></span><span><span>13</span><span>  Section hdr offset: 4572
</span></span><span><span>14</span><span>  Flags:              0x05000200
</span></span><span><span>15</span><span>  EH size:            52
</span></span><span><span>16</span><span>  # Program headers:  1
</span></span><span><span>17</span><span>  # Section headers:  8
</span></span><span><span>18</span><span>  Str tbl index:      7
</span></span><span><span>19</span><span>
</span></span><span><span>20</span><span>Program Headers:
</span></span><span><span>21</span><span>  Type       Offset   VirtAddr   PhysAddr   FileSz    MemSz  Flags  Align
</span></span><span><span>22</span><span>  LOAD     0x001000 0x00008000 0x00008000 0x00000c 0x00000c    R|X 0x1000</span></span></code></pre></div><p>Since the only reason for parsing the elf headers is to know where to put what
segment with which permissions, I want to quickly interject on why we have to
put said segments at these specific addresses. The main reason is that all
pointers, all offsets and pc related decoding has to be done relative to
<code>Elf32_Ehdr.entry</code>, here <code>0x8000</code>. The linker also generated all instruction
arguments according to this value.</p><p>Before mapping each segment at its <code>Pheader::vaddr</code>, we have to understand:
One doesn’t simply <code>mmap</code> with <code>MAP_FIXED</code> or <code>MAP_NOREPLACE</code> into the virtual
address <code>0x8000</code>. The Linux kernel won’t let us, and rightfully so, <code>man mmap</code>
says:</p><blockquote><p>If addr is not NULL, then the kernel takes it as a hint about where to place
the mapping; on Linux, the kernel will pick a nearby page boundary (but
always above or equal to the value specified by /proc/sys/vm/mmap_min_addr) and
attempt to create the mapping there.</p></blockquote><p>And <code>/proc/sys/vm/mmap_min_addr</code> on my system is <code>u16::MAX</code> (2^16)-1=65535. So
mapping our segment to <code>0x8000</code> (32768) is not allowed:</p><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span> 1</span><span><span>let</span> segment = sys::mmap::mmap(
</span></span><span><span> 2</span><span>    <span>// this is only UB if dereferenced, its just a hint, so its safe here
</span></span></span><span><span> 3</span><span><span></span>    <span>Some</span>(<span>unsafe</span> { std::ptr::NonNull::new_unchecked(<span>0x8000</span> <span>as</span> *<span>mut</span> <span>u8</span>) }),
</span></span><span><span> 4</span><span>    <span>4096</span>,
</span></span><span><span> 5</span><span>    sys::mmap::MmapProt::WRITE,
</span></span><span><span> 6</span><span>    sys::mmap::MmapFlags::ANONYMOUS
</span></span><span><span> 7</span><span>        | sys::mmap::MmapFlags::PRIVATE
</span></span><span><span> 8</span><span>        | sys::mmap::MmapFlags::NOREPLACE,
</span></span><span><span> 9</span><span>    -<span>1</span>,
</span></span><span><span>10</span><span>    <span>0</span>,
</span></span><span><span>11</span><span>)
</span></span><span><span>12</span><span>.unwrap();</span></span></code></pre></div><p>Running the above with our <code>vaddr</code> of <code>0x8000</code> results in:</p><p><span>TEXT</span></p><div><pre tabindex="0"><code data-lang="text"><span><span>1</span><span>thread &#39;main&#39; panicked at src/main.rs:33:6:
</span></span><span><span>2</span><span>called `Result::unwrap()` on an `Err` value: &#34;mmap failed (errno 1): Operation not permitted
</span></span><span><span>3</span><span>(os error 1)&#34;</span></span></code></pre></div><p>It only works in elevated permission mode, which is something I dont want to
run my emulator in.</p><h2 id="translating-guest-memory-access-to-host-memory-access">Translating guest memory access to host memory access</h2><p>The obvious fix is to not mmap below <code>u16::MAX</code> and let the kernel choose where
we dump our segment:</p><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span>1</span><span><span>let</span> segment = sys::mmap::mmap(
</span></span><span><span>2</span><span>    <span>None</span>,
</span></span><span><span>3</span><span>    <span>4096</span>,
</span></span><span><span>4</span><span>    MmapProt::WRITE,
</span></span><span><span>5</span><span>    MmapFlags::ANONYMOUS | MmapFlags::PRIVATE,
</span></span><span><span>6</span><span>    -<span>1</span>,
</span></span><span><span>7</span><span>    <span>0</span>,
</span></span><span><span>8</span><span>).unwrap();</span></span></code></pre></div><p>But this means the segment of the process to emulate is not at <code>0x8000</code>, but
anywhere the kernel allows. So we need to add a translation layer between guest
and host memory: (If you’re familiar with how virtual memory works, its similar
but one more indirection)</p><p><span>TEXT</span></p><div><pre tabindex="0"><code data-lang="text"><span><span>1</span><span>+--guest--+
</span></span><span><span>2</span><span>| 0x80000 | ------------+
</span></span><span><span>3</span><span>+---------+             |
</span></span><span><span>4</span><span>                        |
</span></span><span><span>5</span><span>                    Mem::translate
</span></span><span><span>6</span><span>                        |
</span></span><span><span>7</span><span>+------host------+      |
</span></span><span><span>8</span><span>| 0x7f5b4b8f8000 | &lt;----+
</span></span><span><span>9</span><span>+----------------+</span></span></code></pre></div><p>Putting this into rust:</p><ul><li><code>map_region</code> registers a region of memory and allows <code>Mem</code>
to take ownership for calling munmap on these segments
once it goes out of scope</li><li><code>translate</code> takes a guest addr and translates it to a host addr</li></ul><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span> 1</span><span><span>struct</span> <span>MappedSegment</span> {
</span></span><span><span> 2</span><span>    host_ptr: *<span>mut</span> <span>u8</span>,
</span></span><span><span> 3</span><span>    len: <span>u32</span>,
</span></span><span><span> 4</span><span>}
</span></span><span><span> 5</span><span>
</span></span><span><span> 6</span><span><span>pub</span> <span>struct</span> <span>Mem</span> {
</span></span><span><span> 7</span><span>    maps: <span>BTreeMap</span>&lt;<span>u32</span>, MappedSegment&gt;,
</span></span><span><span> 8</span><span>}
</span></span><span><span> 9</span><span>
</span></span><span><span>10</span><span><span>impl</span> Mem {
</span></span><span><span>11</span><span>    <span>pub</span> <span>fn</span> <span>map_region</span>(&amp;<span>mut</span> <span>self</span>, guest_addr: <span>u32</span>, len: <span>u32</span>, host_ptr: *<span>mut</span> <span>u8</span>) {
</span></span><span><span>12</span><span>        <span>self</span>.maps
</span></span><span><span>13</span><span>            .insert(guest_addr, MappedSegment { host_ptr, len });
</span></span><span><span>14</span><span>    }
</span></span><span><span>15</span><span>
</span></span><span><span>16</span><span>    <span>/// translate a guest addr to a host addr we can write and read from
</span></span></span><span><span>17</span><span><span></span>    <span>pub</span> <span>fn</span> <span>translate</span>(&amp;<span>self</span>, guest_addr: <span>u32</span>) -&gt; <span>Option</span>&lt;*<span>mut</span> <span>u8</span>&gt; {
</span></span><span><span>18</span><span>        <span>// Find the greatest key &lt;= guest_addr.
</span></span></span><span><span>19</span><span><span></span>        <span>let</span> (&amp;base, seg) = <span>self</span>.maps.range(..=guest_addr).next_back()?;
</span></span><span><span>20</span><span>        <span>if</span> guest_addr &lt; base.wrapping_add(seg.len) {
</span></span><span><span>21</span><span>            <span>let</span> offset = guest_addr.wrapping_sub(base);
</span></span><span><span>22</span><span>            <span>Some</span>(<span>unsafe</span> { seg.host_ptr.add(offset <span>as</span> <span>usize</span>) })
</span></span><span><span>23</span><span>        } <span>else</span> {
</span></span><span><span>24</span><span>            <span>None</span>
</span></span><span><span>25</span><span>        }
</span></span><span><span>26</span><span>    }
</span></span><span><span>27</span><span>
</span></span><span><span>28</span><span>    <span>pub</span> <span>fn</span> <span>read_u32</span>(&amp;<span>self</span>, guest_addr: <span>u32</span>) -&gt; <span>Option</span>&lt;<span>u32</span>&gt; {
</span></span><span><span>29</span><span>        <span>let</span> ptr = <span>self</span>.translate(guest_addr)?;
</span></span><span><span>30</span><span>        <span>unsafe</span> { <span>Some</span>(<span>u32</span>::from_le(*(ptr <span>as</span> *<span>const</span> <span>u32</span>))) }
</span></span><span><span>31</span><span>    }
</span></span><span><span>32</span><span>}</span></span></code></pre></div><p>This fix has the added benfit of allowing us to sandbox guest memory fully, so
we can validate each memory access before we allow a guest to host memory
interaction.</p><h2 id="mapping-segments-with-their-permissions">Mapping segments with their permissions</h2><p>The basic idea is similar to the way a JIT compiler works:</p><ol><li>create a <code>mmap</code> section with <code>W</code> permissions</li><li>write bytes from elf into section</li><li>zero rest of defined size</li><li>change permission of section with <code>mprotect</code> to the
permissions defined in the <code>Pheader</code></li></ol><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span> 1</span><span><span>/// mapping applies the configuration of self to the current memory context by creating the
</span></span></span><span><span> 2</span><span><span>/// segments with the corresponding permission bits, vaddr, etc
</span></span></span><span><span> 3</span><span><span></span><span>pub</span> <span>fn</span> <span>map</span>(&amp;<span>self</span>, raw: <span>&amp;</span>[<span>u8</span>], guest_mem: <span>&amp;</span><span>mut</span> mem::Mem) -&gt; <span>Result</span>&lt;(), <span>String</span>&gt; {
</span></span><span><span> 4</span><span>    <span>// zero memory needed case, no clue if this actually ever happens, but we support it
</span></span></span><span><span> 5</span><span><span></span>    <span>if</span> <span>self</span>.memsz == <span>0</span> {
</span></span><span><span> 6</span><span>        <span>return</span> <span>Ok</span>(());
</span></span><span><span> 7</span><span>    }
</span></span><span><span> 8</span><span>
</span></span><span><span> 9</span><span>    <span>if</span> <span>self</span>.vaddr == <span>0</span> {
</span></span><span><span>10</span><span>        <span>return</span> <span>Err</span>(<span>&#34;program header has a zero virtual address&#34;</span>.into());
</span></span><span><span>11</span><span>    }
</span></span><span><span>12</span><span>
</span></span><span><span>13</span><span>    <span>// we need page alignement, so either Elf32_Phdr.p_align or 4096
</span></span></span><span><span>14</span><span><span></span>    <span>let</span> (start, _end, len) = <span>self</span>.alignments();
</span></span><span><span>15</span><span>
</span></span><span><span>16</span><span>    <span>// Instead of mapping at the guest vaddr (Linux doesnt&#39;t allow for low addresses),
</span></span></span><span><span>17</span><span><span></span>    <span>// we allocate memory wherever the host kernel gives us.
</span></span></span><span><span>18</span><span><span></span>    <span>// This keeps guest memory sandboxed: guest addr != host addr.
</span></span></span><span><span>19</span><span><span></span>    <span>let</span> segment = mem::mmap::mmap(
</span></span><span><span>20</span><span>        <span>None</span>,
</span></span><span><span>21</span><span>        len <span>as</span> <span>usize</span>,
</span></span><span><span>22</span><span>        MmapProt::WRITE,
</span></span><span><span>23</span><span>        MmapFlags::ANONYMOUS | MmapFlags::PRIVATE,
</span></span><span><span>24</span><span>        -<span>1</span>,
</span></span><span><span>25</span><span>        <span>0</span>,
</span></span><span><span>26</span><span>    )?;
</span></span><span><span>27</span><span>
</span></span><span><span>28</span><span>    <span>let</span> segment_ptr = segment.as_ptr();
</span></span><span><span>29</span><span>    <span>let</span> segment_slice = <span>unsafe</span> { std::slice::from_raw_parts_mut(segment_ptr, len <span>as</span> <span>usize</span>) };
</span></span><span><span>30</span><span>
</span></span><span><span>31</span><span>    <span>let</span> file_slice: <span>&amp;</span>[<span>u8</span>] =
</span></span><span><span>32</span><span>        &amp;raw[<span>self</span>.offset <span>as</span> <span>usize</span>..(<span>self</span>.offset.wrapping_add(<span>self</span>.filesz)) <span>as</span> <span>usize</span>];
</span></span><span><span>33</span><span>
</span></span><span><span>34</span><span>    <span>// compute offset inside the mmapped slice where the segment should start
</span></span></span><span><span>35</span><span><span></span>    <span>let</span> offset = (<span>self</span>.vaddr - start) <span>as</span> <span>usize</span>;
</span></span><span><span>36</span><span>
</span></span><span><span>37</span><span>    <span>// copy the segment contents to the mmaped segment
</span></span></span><span><span>38</span><span><span></span>    segment_slice[offset..offset + file_slice.len()].copy_from_slice(file_slice);
</span></span><span><span>39</span><span>
</span></span><span><span>40</span><span>    <span>// we need to zero the remaining bytes
</span></span></span><span><span>41</span><span><span></span>    <span>if</span> <span>self</span>.memsz &gt; <span>self</span>.filesz {
</span></span><span><span>42</span><span>        segment_slice
</span></span><span><span>43</span><span>            [offset.wrapping_add(file_slice.len())..offset.wrapping_add(<span>self</span>.memsz <span>as</span> <span>usize</span>)]
</span></span><span><span>44</span><span>            .fill(<span>0</span>);
</span></span><span><span>45</span><span>    }
</span></span><span><span>46</span><span>
</span></span><span><span>47</span><span>    <span>// record mapping in guest memory table, so CPU can translate guest vaddr to host pointer
</span></span></span><span><span>48</span><span><span></span>    guest_mem.map_region(<span>self</span>.vaddr, len, segment_ptr);
</span></span><span><span>49</span><span>
</span></span><span><span>50</span><span>    <span>// we change the permissions for our segment from W to the segments requested bits
</span></span></span><span><span>51</span><span><span></span>    mem::mmap::mprotect(segment, len <span>as</span> <span>usize</span>, <span>self</span>.flags.into())
</span></span><span><span>52</span><span>}
</span></span><span><span>53</span><span>
</span></span><span><span>54</span><span><span>/// returns (start, end, len)
</span></span></span><span><span>55</span><span><span></span><span>fn</span> <span>alignments</span>(&amp;<span>self</span>) -&gt; (<span>u32</span>, <span>u32</span>, <span>u32</span>) {
</span></span><span><span>56</span><span>    <span>// we need page alignement, so either Elf32_Phdr.p_align or 4096
</span></span></span><span><span>57</span><span><span></span>    <span>let</span> align = <span>match</span> <span>self</span>.align {
</span></span><span><span>58</span><span>        <span>0</span> =&gt; <span>0x1000</span>,
</span></span><span><span>59</span><span>        _ =&gt; <span>self</span>.align,
</span></span><span><span>60</span><span>    };
</span></span><span><span>61</span><span>    <span>let</span> start = <span>self</span>.vaddr &amp; !(align - <span>1</span>);
</span></span><span><span>62</span><span>    <span>let</span> end = (<span>self</span>.vaddr.wrapping_add(<span>self</span>.memsz).wrapping_add(align) - <span>1</span>) &amp; !(align - <span>1</span>);
</span></span><span><span>63</span><span>    <span>let</span> len = end - start;
</span></span><span><span>64</span><span>    (start, end, len)
</span></span><span><span>65</span><span>}</span></span></code></pre></div><p>Map is called in the emulators entry point:</p><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span>1</span><span><span>let</span> elf: <span>elf</span>::Elf = (&amp;buf <span>as</span> &amp;[<span>u8</span>]).try_into().expect(<span>&#34;Failed to parse binary&#34;</span>);
</span></span><span><span>2</span><span><span>let</span> <span>mut</span> mem = mem::Mem::new();
</span></span><span><span>3</span><span><span>for</span> phdr <span>in</span> elf.pheaders {
</span></span><span><span>4</span><span>    <span>if</span> phdr.r#type == elf::pheader::Type::LOAD {
</span></span><span><span>5</span><span>        phdr.map(&amp;buf, &amp;<span>mut</span> mem)
</span></span><span><span>6</span><span>            .expect(<span>&#34;Mapping program header failed&#34;</span>);
</span></span><span><span>7</span><span>    }
</span></span><span><span>8</span><span>}</span></span></code></pre></div><p>We can now request a word (32bit) from our <code>LOAD</code> segment which contains
the <code>.text</code> section bytes one can inspect via <code>objdump</code>:</p><p><span>TEXT</span></p><div><pre tabindex="0"><code data-lang="text"><span><span> 1</span><span>$ arm-none-eabi-objdump -d examples/exit.elf
</span></span><span><span> 2</span><span>
</span></span><span><span> 3</span><span>examples/exit.elf:     file format elf32-littlearm
</span></span><span><span> 4</span><span>
</span></span><span><span> 5</span><span>
</span></span><span><span> 6</span><span>Disassembly of section .text:
</span></span><span><span> 7</span><span>
</span></span><span><span> 8</span><span>00008000 &lt;_start&gt;:
</span></span><span><span> 9</span><span>    8000:       e3a000a1        mov     r0, #161        @ 0xa1
</span></span><span><span>10</span><span>    8004:       e3a07001        mov     r7, #1
</span></span><span><span>11</span><span>    8008:       ef000000        svc     0x00000000</span></span></code></pre></div><p>So we use <code>Mem::read_u32(0x8000)</code> and get <code>0xe3a000a1</code>.</p><p>Decoding armv7 instructions seems doable at a glance, but
it is a deeper rabbit-hole than I expected, prepare for a bit
shifting, implicit behaviour and intertwined meaning heavy
section:</p><p>Instructions are more or less grouped into four groups:</p><ol><li>Branch and control</li><li>Data processing</li><li>Load and store</li><li>Other (syscalls &amp; stuff)</li></ol><p>Each armv7 instruction is 32 bit in size, (in general) its layout is as
follows:</p><p><span>TEXT</span></p><div><pre tabindex="0"><code data-lang="text"><span><span>1</span><span>+--------+------+------+------+------------+---------+
</span></span><span><span>2</span><span>|  cond  |  op  |  Rn  |  Rd  |  Operand2  |  shamt  |
</span></span><span><span>3</span><span>|   4b   |  4b  |  4b  |  4b  |     12b    |   4b    |
</span></span><span><span>4</span><span>+--------+------+------+------+------------+---------+</span></span></code></pre></div><table><thead><tr><th>bit range</th><th>name</th><th>description</th></tr></thead><tbody><tr><td>0..4</td><td>cond</td><td>contains <code>EQ</code>, <code>NE</code>, etc</td></tr><tr><td>4..8</td><td>op</td><td>for instance <code>0b1101</code> for <code>mov</code></td></tr><tr><td>8..12</td><td>rn</td><td>source register</td></tr><tr><td>12..16</td><td>rd</td><td>destination register</td></tr><tr><td>16..28</td><td>operand2</td><td>immediate value or shifted register</td></tr><tr><td>28..32</td><td>shamt</td><td>shift amount</td></tr></tbody></table><h2 id="rust-representation">Rust representation</h2><p>Since <code>cond</code> decides whether or not the instruction is
executed, I decided on the following struct to be the decoded
instruction:</p><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span> 1</span><span><span>#[derive(Debug, Copy, Clone)]</span>
</span></span><span><span> 2</span><span><span>pub</span> <span>struct</span> <span>InstructionContainer</span> {
</span></span><span><span> 3</span><span>    <span>pub</span> cond: <span>u8</span>,
</span></span><span><span> 4</span><span>    <span>pub</span> instruction: <span>Instruction</span>,
</span></span><span><span> 5</span><span>}
</span></span><span><span> 6</span><span>
</span></span><span><span> 7</span><span><span>#[derive(Debug, Copy, Clone)]</span>
</span></span><span><span> 8</span><span><span>pub</span> <span>enum</span> <span>Instruction</span> {
</span></span><span><span> 9</span><span>    MovImm { rd: <span>u8</span>, rhs: <span>u32</span> },
</span></span><span><span>10</span><span>    Svc,
</span></span><span><span>11</span><span>    LdrLiteral { rd: <span>u8</span>, addr: <span>u32</span> },
</span></span><span><span>12</span><span>    Unknown(<span>u32</span>),
</span></span><span><span>13</span><span>}</span></span></code></pre></div><p>These 4 instructions are enough to support both the minimal
binary at the intro and the asm hello world:</p><p><span>ARMASM</span></p><div><pre tabindex="0"><code data-lang="armasm"><span><span>1</span><span>    <span>.global</span> _start
</span></span><span><span>2</span><span>_start:
</span></span><span><span>3</span><span>    mov <span>r0</span>, #<span>161</span>
</span></span><span><span>4</span><span>    mov <span>r7</span>, #<span>1</span>
</span></span><span><span>5</span><span>    svc #<span>0</span></span></span></code></pre></div><p><span>ARMASM</span></p><div><pre tabindex="0"><code data-lang="armasm"><span><span> 1</span><span>    <span>.section</span> <span>.rodata</span>
</span></span><span><span> 2</span><span>msg:<span>
</span></span></span><span><span> 3</span><span><span>    .asciz </span>&#34;<span>Hello, world!\n</span>&#34;
</span></span><span><span> 4</span><span>
</span></span><span><span> 5</span><span>    <span>.section</span> <span>.text</span>
</span></span><span><span> 6</span><span>    <span>.global</span> _start
</span></span><span><span> 7</span><span>_start:
</span></span><span><span> 8</span><span>    ldr <span>r0</span>, =1
</span></span><span><span> 9</span><span>    ldr <span>r1</span>, =msg
</span></span><span><span>10</span><span>    mov <span>r2</span>, #<span>14</span>
</span></span><span><span>11</span><span>    mov <span>r7</span>, #<span>4</span>
</span></span><span><span>12</span><span>    svc #<span>0</span>
</span></span><span><span>13</span><span>
</span></span><span><span>14</span><span>    mov <span>r0</span>, #<span>0</span>
</span></span><span><span>15</span><span>    mov <span>r7</span>, #<span>1</span>
</span></span><span><span>16</span><span>    svc #<span>0</span></span></span></code></pre></div><h2 id="general-instruction-detection">General instruction detection</h2><p>Our decoder is a function accepting a word, the program counter (we need
this later for decoding the offset for <code>ldr</code>) and returning the
aforementioned instruction container:</p><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span>1</span><span><span>pub</span> <span>fn</span> <span>decode_word</span>(word: <span>u32</span>, caddr: <span>u32</span>) -&gt; <span>InstructionContainer</span></span></span></code></pre></div><p>Referring to the diagram shown before, I know the first 4 bit are the
condition, so I can extract these first. I also take the top 3 bits to
identify the instruction class (load and store, branch or data
processing immediate):</p><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span>1</span><span><span>// ...
</span></span></span><span><span>2</span><span><span></span><span>let</span> cond = ((word &gt;&gt; <span>28</span>) &amp; <span>0xF</span>) <span>as</span> <span>u8</span>;
</span></span><span><span>3</span><span><span>let</span> top = ((word &gt;&gt; <span>25</span>) &amp; <span>0x7</span>) <span>as</span> <span>u8</span>;</span></span></code></pre></div><p>Since there are immediate moves and non immediate moves, both <code>0b000</code> and
<code>0b001</code> are valid top values we want to support.</p><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span>1</span><span><span>// ...
</span></span></span><span><span>2</span><span><span></span><span>if</span> top == <span>0b000</span> || top == <span>0b001</span> {
</span></span><span><span>3</span><span>    <span>let</span> i_bit = ((word &gt;&gt; <span>25</span>) &amp; <span>0x1</span>) != <span>0</span>;
</span></span><span><span>4</span><span>    <span>let</span> opcode = ((word &gt;&gt; <span>21</span>) &amp; <span>0xF</span>) <span>as</span> <span>u8</span>;
</span></span><span><span>5</span><span>    <span>if</span> i_bit {
</span></span><span><span>6</span><span>        <span>// ...
</span></span></span><span><span>7</span><span><span></span>    }
</span></span><span><span>8</span><span>}</span></span></code></pre></div><p>If the i bit is set, we can extract convert the opcode from its bits into
something I can read a lot better:</p><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span> 1</span><span><span>#[derive(Debug, Clone, Copy, PartialEq, Eq)]</span>
</span></span><span><span> 2</span><span><span>#[repr(u8)]</span>
</span></span><span><span> 3</span><span><span>enum</span> <span>Op</span> {
</span></span><span><span> 4</span><span>    <span>// ...
</span></span></span><span><span> 5</span><span><span></span>    Mov = <span>0b1101</span>,
</span></span><span><span> 6</span><span>}
</span></span><span><span> 7</span><span>
</span></span><span><span> 8</span><span><span>static</span> OP_TABLE: [Op; <span>16</span>] = [
</span></span><span><span> 9</span><span>    <span>// ...
</span></span></span><span><span>10</span><span><span></span>    Op::Mov,
</span></span><span><span>11</span><span>];
</span></span><span><span>12</span><span>
</span></span><span><span>13</span><span><span>#[inline(always)]</span>
</span></span><span><span>14</span><span><span>fn</span> <span>op_from_bits</span>(bits: <span>u8</span>) -&gt; <span>Op</span> {
</span></span><span><span>15</span><span>    <span>debug_assert!</span>(bits &lt;= <span>0b1111</span>);
</span></span><span><span>16</span><span>    <span>unsafe</span> { *OP_TABLE.get_unchecked(bits <span>as</span> <span>usize</span>) }
</span></span><span><span>17</span><span>}</span></span></code></pre></div><p>We can now plug this in, match on the only ddi (data processing immediate)
we know and extract both the destination register (rd) and the raw
immediate value:</p><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span> 1</span><span><span>if</span> top == <span>0b000</span> || top == <span>0b001</span> {
</span></span><span><span> 2</span><span>    <span>// Data-processing immediate (ddi) (top 0b000 or 0b001 when I==1)
</span></span></span><span><span> 3</span><span><span></span>    <span>let</span> i_bit = ((word &gt;&gt; <span>25</span>) &amp; <span>0x1</span>) != <span>0</span>;
</span></span><span><span> 4</span><span>    <span>let</span> opcode = ((word &gt;&gt; <span>21</span>) &amp; <span>0xF</span>) <span>as</span> <span>u8</span>;
</span></span><span><span> 5</span><span>    <span>if</span> i_bit {
</span></span><span><span> 6</span><span>        <span>match</span> op_from_bits(opcode) {
</span></span><span><span> 7</span><span>            Op::Mov =&gt; {
</span></span><span><span> 8</span><span>                <span>let</span> rd = ((word &gt;&gt; <span>12</span>) &amp; <span>0xF</span>) <span>as</span> <span>u8</span>;
</span></span><span><span> 9</span><span>                <span>let</span> imm12 = word &amp; <span>0xFFF</span>;
</span></span><span><span>10</span><span>                <span>// ...
</span></span></span><span><span>11</span><span><span></span>            }
</span></span><span><span>12</span><span>            _ =&gt; <span>todo!</span>(),
</span></span><span><span>13</span><span>        }
</span></span><span><span>14</span><span>    }
</span></span><span><span>15</span><span>}</span></span></code></pre></div><p>From the examples before one can see the immediate value is prefixed with
<code>#</code>. To move the value <code>161</code> into <code>r0</code> we do:</p><p><span>ASM</span></p><p>Since we know there are only 12 bits available for the immediate the arm
engineers came up with rotation of the resulting integer by the remaining 4
bits:</p><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span>1</span><span><span>#[inline(always)]</span>
</span></span><span><span>2</span><span><span>fn</span> <span>decode_rotated_imm</span>(imm12: <span>u32</span>) -&gt; <span>u32</span> {
</span></span><span><span>3</span><span>    <span>let</span> rotate = ((imm12 &gt;&gt; <span>8</span>) &amp; <span>0b1111</span>) * <span>2</span>;
</span></span><span><span>4</span><span>    (imm12 &amp; <span>0xff</span>).rotate_right(rotate)
</span></span><span><span>5</span><span>}</span></span></code></pre></div><p>Plugging this back in results in us being able to fully decode <code>mov r0,#161</code>:</p><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span> 1</span><span><span>if</span> top == <span>0b000</span> || top == <span>0b001</span> {
</span></span><span><span> 2</span><span>    <span>let</span> i_bit = ((word &gt;&gt; <span>25</span>) &amp; <span>0x1</span>) != <span>0</span>;
</span></span><span><span> 3</span><span>    <span>let</span> opcode = ((word &gt;&gt; <span>21</span>) &amp; <span>0xF</span>) <span>as</span> <span>u8</span>;
</span></span><span><span> 4</span><span>    <span>if</span> i_bit {
</span></span><span><span> 5</span><span>        <span>match</span> op_from_bits(opcode) {
</span></span><span><span> 6</span><span>            Op::Mov =&gt; {
</span></span><span><span> 7</span><span>                <span>let</span> rd = ((word &gt;&gt; <span>12</span>) &amp; <span>0xF</span>) <span>as</span> <span>u8</span>;
</span></span><span><span> 8</span><span>                <span>let</span> imm12 = word &amp; <span>0xFFF</span>;
</span></span><span><span> 9</span><span>                <span>let</span> rhs = decode_rotated_imm(imm12);
</span></span><span><span>10</span><span>                <span>return</span> InstructionContainer {
</span></span><span><span>11</span><span>                    cond,
</span></span><span><span>12</span><span>                    instruction: <span>Instruction</span>::MovImm { rd, rhs },
</span></span><span><span>13</span><span>                };
</span></span><span><span>14</span><span>            }
</span></span><span><span>15</span><span>            _ =&gt; <span>todo!</span>(),
</span></span><span><span>16</span><span>        }
</span></span><span><span>17</span><span>    }
</span></span><span><span>18</span><span>}</span></span></code></pre></div><p>As seen when <code>dbg!</code>-ing the cpu steps:</p><p><span>TEXT</span></p><div><pre tabindex="0"><code data-lang="text"><span><span>1</span><span>[src/cpu/mod.rs:114:13] decoder::decode_word(word, self.pc()) =
</span></span><span><span>2</span><span>InstructionContainer {
</span></span><span><span>3</span><span>    cond: 14,
</span></span><span><span>4</span><span>    instruction: MovImm {
</span></span><span><span>5</span><span>        rd: 0,
</span></span><span><span>6</span><span>        rhs: 161,
</span></span><span><span>7</span><span>    },
</span></span><span><span>8</span><span>}</span></span></code></pre></div><h2 id="load-and-store">Load and Store</h2><p><code>ldr</code> is part of the load and store instruction group and is needed for
the accessing of <code>Hello World!</code> in <code>.rodata</code> and putting a ptr to it
into a register.</p><p>In comparison to immediate mov we have to do a little trick, since we
only want to match for load and store that matches:</p><ul><li>single register modification</li><li>load and store with immediate</li></ul><p>So we only decode:</p><p><span>ARMASM</span></p><div><pre tabindex="0"><code data-lang="armasm"><span><span>1</span><span>LDR <span>Rd</span>, <span>[Rn</span>, #<span>imm]</span>
</span></span><span><span>2</span><span>LDR <span>Rd</span>, <span>[Rn]</span>, #<span>imm</span>
</span></span><span><span>3</span><span><span>@ etc
</span></span></span></code></pre></div><p>Thus we match with <code>(top &gt;&gt; 1) &amp; 0b11 == 0b01</code> and start extracting a
whole bucket load of bit flags:</p><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span> 1</span><span><span>if</span> (top &gt;&gt; <span>1</span>) &amp; <span>0b11</span> == <span>0b01</span> {
</span></span><span><span> 2</span><span>    <span>let</span> p = ((word &gt;&gt; <span>24</span>) &amp; <span>1</span>) != <span>0</span>;
</span></span><span><span> 3</span><span>    <span>let</span> u = ((word &gt;&gt; <span>23</span>) &amp; <span>1</span>) != <span>0</span>;
</span></span><span><span> 4</span><span>    <span>let</span> b = ((word &gt;&gt; <span>22</span>) &amp; <span>1</span>) != <span>0</span>;
</span></span><span><span> 5</span><span>    <span>let</span> w = ((word &gt;&gt; <span>21</span>) &amp; <span>1</span>) != <span>0</span>;
</span></span><span><span> 6</span><span>    <span>let</span> l = ((word &gt;&gt; <span>20</span>) &amp; <span>1</span>) != <span>0</span>;
</span></span><span><span> 7</span><span>    <span>let</span> rn = ((word &gt;&gt; <span>16</span>) &amp; <span>0xF</span>) <span>as</span> <span>u8</span>;
</span></span><span><span> 8</span><span>    <span>let</span> rd = ((word &gt;&gt; <span>12</span>) &amp; <span>0xF</span>) <span>as</span> <span>u8</span>;
</span></span><span><span> 9</span><span>    <span>let</span> imm12 = (word &amp; <span>0xFFF</span>) <span>as</span> <span>u32</span>;
</span></span><span><span>10</span><span>
</span></span><span><span>11</span><span>    <span>// Literal‑pool version
</span></span></span><span><span>12</span><span><span></span>    <span>if</span> l &amp;&amp; rn == <span>0b1111</span> &amp;&amp; p &amp;&amp; u &amp;&amp; !w &amp;&amp; !b {
</span></span><span><span>13</span><span>        <span>let</span> pc_seen = caddr.wrapping_add(<span>8</span>);
</span></span><span><span>14</span><span>        <span>let</span> literal_addr = pc_seen.wrapping_add(imm12);
</span></span><span><span>15</span><span>
</span></span><span><span>16</span><span>        <span>return</span> InstructionContainer {
</span></span><span><span>17</span><span>            cond,
</span></span><span><span>18</span><span>            instruction: <span>Instruction</span>::LdrLiteral {
</span></span><span><span>19</span><span>                rd,
</span></span><span><span>20</span><span>                addr: <span>literal_addr</span>,
</span></span><span><span>21</span><span>            },
</span></span><span><span>22</span><span>        };
</span></span><span><span>23</span><span>    }
</span></span><span><span>24</span><span>
</span></span><span><span>25</span><span>    <span>todo!</span>(<span>&#34;only LDR with p&amp;u&amp;!w&amp;!b is implemented&#34;</span>)
</span></span><span><span>26</span><span>}</span></span></code></pre></div><table><thead><tr><th>bit</th><th>description</th></tr></thead><tbody><tr><td>p</td><td>pre-indexed addressing, offset added before load</td></tr><tr><td>u</td><td>add (1) vs subtract (0) offset</td></tr><tr><td>b</td><td>word (0) or byte (1) sized access</td></tr><tr><td>w</td><td>(no=0) write back to base</td></tr><tr><td>l</td><td>load (1), or store (0)</td></tr></tbody></table><p><code>ldr Rn, &lt;addr&gt;</code> matches exactly <code>load</code>, base register is PC (<code>rn==0b1111</code>), pre-indexed
addressing, added offset, no write back and no byte sized access (<code>l &amp;&amp; rn == 0b1111 &amp;&amp; p &amp;&amp; u &amp;&amp; !w &amp;&amp; !b</code>).</p><h2 id="syscalls">Syscalls</h2><p>Syscalls are the only way to interact with the Linux kernel (as far as I
know), so we definitely need to implement both decoding and forwarding.
Bits 27-24 are <code>1111</code> for system calls. The immediate value is
irrelevant for us, since the Linux syscall handler either way discards
the value:</p><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span>1</span><span><span>if</span> ((word &gt;&gt; <span>24</span>) &amp; <span>0xF</span>) <span>as</span> <span>u8</span> == <span>0b1111</span> {
</span></span><span><span>2</span><span>    <span>return</span> InstructionContainer {
</span></span><span><span>3</span><span>        cond,
</span></span><span><span>4</span><span>        <span>// technically arm says svc has a 24bit immediate but we don&#39;t care about it, since the
</span></span></span><span><span>5</span><span><span></span>        <span>// Linux kernel also doesn&#39;t
</span></span></span><span><span>6</span><span><span></span>        instruction: <span>Instruction</span>::Svc,
</span></span><span><span>7</span><span>    };
</span></span><span><span>8</span><span>}</span></span></code></pre></div><p>We can now fully decode all instructions for both the simple exit and
the more advanced hello world binary:</p><p><span>TEXT</span></p><div><pre tabindex="0"><code data-lang="text"><span><span>1</span><span>[src/cpu/mod.rs:121:15] instruction = MovImm { rd: 0, rhs: 161, }
</span></span><span><span>2</span><span>[src/cpu/mod.rs:121:15] instruction = MovImm { rd: 7, rhs: 1, }
</span></span><span><span>3</span><span>[src/cpu/mod.rs:121:15] instruction = Svc</span></span></code></pre></div><p><span>TEXT</span></p><div><pre tabindex="0"><code data-lang="text"><span><span>1</span><span>[src/cpu/mod.rs:121:15] instruction = MovImm { rd: 0, rhs: 1, }
</span></span><span><span>2</span><span>[src/cpu/mod.rs:121:15] instruction = LdrLiteral { rd: 1, addr: 32800, }
</span></span><span><span>3</span><span>[src/cpu/mod.rs:121:15] instruction = MovImm { rd: 2, rhs: 14, }
</span></span><span><span>4</span><span>[src/cpu/mod.rs:121:15] instruction = MovImm { rd: 7, rhs: 4, }
</span></span><span><span>5</span><span>[src/cpu/mod.rs:121:15] instruction = Svc
</span></span><span><span>6</span><span>[src/cpu/mod.rs:121:15] instruction = MovImm { rd: 0, rhs: 0, }
</span></span><span><span>7</span><span>[src/cpu/mod.rs:121:15] instruction = MovImm { rd: 7, rhs: 1, }
</span></span><span><span>8</span><span>[src/cpu/mod.rs:121:15] instruction = Svc</span></span></code></pre></div><p>This is by FAR the easiest part, I only struggled with the double
indirection for <code>ldr</code> (I simply didn’t know about it), but each problem
at its time :^).</p><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span> 1</span><span><span>pub</span> <span>struct</span> <span>Cpu</span>&lt;&#39;cpu&gt; {
</span></span><span><span> 2</span><span>    <span>/// r0-r15 (r13=SP, r14=LR, r15=PC)
</span></span></span><span><span> 3</span><span><span></span>    <span>pub</span> r: [<span>u32</span>; <span>16</span>],
</span></span><span><span> 4</span><span>    <span>pub</span> cpsr: <span>u32</span>,
</span></span><span><span> 5</span><span>    <span>pub</span> mem: <span>&amp;</span>&#39;cpu <span>mut</span> mem::Mem,
</span></span><span><span> 6</span><span>    <span>/// only set by ArmSyscall::Exit to propagate exit code to the host
</span></span></span><span><span> 7</span><span><span></span>    <span>pub</span> status: <span>Option</span>&lt;<span>i32</span>&gt;,
</span></span><span><span> 8</span><span>}
</span></span><span><span> 9</span><span>
</span></span><span><span>10</span><span><span>impl</span>&lt;&#39;cpu&gt; Cpu&lt;&#39;cpu&gt; {
</span></span><span><span>11</span><span>    <span>pub</span> <span>fn</span> <span>new</span>(mem: <span>&amp;</span>&#39;cpu <span>mut</span> mem::Mem, pc: <span>u32</span>) -&gt; <span>Self</span> {
</span></span><span><span>12</span><span>        <span>let</span> <span>mut</span> s = <span>Self</span> {
</span></span><span><span>13</span><span>            r: [<span>0</span>; <span>16</span>],
</span></span><span><span>14</span><span>            cpsr: <span>0x60000010</span>,
</span></span><span><span>15</span><span>            mem,
</span></span><span><span>16</span><span>            status: <span>None</span>,
</span></span><span><span>17</span><span>        };
</span></span><span><span>18</span><span>        s.r[<span>15</span>] = pc;
</span></span><span><span>19</span><span>        s
</span></span><span><span>20</span><span>    }</span></span></code></pre></div><p>Instantiating the cpu:</p><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span>1</span><span><span>let</span> <span>mut</span> cpu = cpu::Cpu::new(&amp;<span>mut</span> mem, elf.header.entry);</span></span></code></pre></div><h2 id="conditional-instructions">Conditional Instructions?</h2><p>When writing the decoder I was confused by the 4 conditional bits. I always
though one does conditional execution by using a branch to jump over
instructions that shouldnt be executed. That was before I learned for arm,
both ways are supported (the armv7 reference says this feature should only
be used if there arent multiple instructions depending on the same
condition, otherwise one should use branches) - so I need to support this
too:</p><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span> 1</span><span><span>impl</span>&lt;&#39;cpu&gt; Cpu&lt;&#39;cpu&gt; {
</span></span><span><span> 2</span><span>    <span>#[inline(always)]</span>
</span></span><span><span> 3</span><span>    <span>fn</span> <span>cond_passes</span>(&amp;<span>self</span>, cond: <span>u8</span>) -&gt; <span>bool</span> {
</span></span><span><span> 4</span><span>        <span>match</span> cond {
</span></span><span><span> 5</span><span>            <span>0x0</span> =&gt; (<span>self</span>.cpsr &gt;&gt; <span>30</span>) &amp; <span>1</span> == <span>1</span>, <span>// EQ: Z == 1
</span></span></span><span><span> 6</span><span><span></span>            <span>0x1</span> =&gt; (<span>self</span>.cpsr &gt;&gt; <span>30</span>) &amp; <span>1</span> == <span>0</span>, <span>// NE
</span></span></span><span><span> 7</span><span><span></span>            <span>0xE</span> =&gt; <span>true</span>,                       <span>// AL (always)
</span></span></span><span><span> 8</span><span><span></span>            <span>0xF</span> =&gt; <span>false</span>,                      <span>// NV (never)
</span></span></span><span><span> 9</span><span><span></span>            _ =&gt; <span>false</span>,                        <span>// strict false
</span></span></span><span><span>10</span><span><span></span>        }
</span></span><span><span>11</span><span>    }
</span></span><span><span>12</span><span>}</span></span></code></pre></div><h2 id="instruction-dispatch">Instruction dispatch</h2><p>After implementing the necessary checks and setup for emulating the cpu, the
CPU can now check if an instruction is to be executed, match on the decoded
instruction and run the associated logic:</p><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span> 1</span><span><span>impl</span>&lt;&#39;cpu&gt; Cpu&lt;&#39;cpu&gt; {
</span></span><span><span> 2</span><span>    <span>#[inline(always)]</span>
</span></span><span><span> 3</span><span>    <span>fn</span> <span>pc</span>(&amp;<span>self</span>) -&gt; <span>u32</span> {
</span></span><span><span> 4</span><span>        <span>self</span>.r[<span>15</span>] &amp; !<span>0b11</span>
</span></span><span><span> 5</span><span>    }
</span></span><span><span> 6</span><span>
</span></span><span><span> 7</span><span>    <span>/// moves pc forward a word
</span></span></span><span><span> 8</span><span><span></span>    <span>#[inline(always)]</span>
</span></span><span><span> 9</span><span>    <span>fn</span> <span>advance</span>(&amp;<span>mut</span> <span>self</span>) {
</span></span><span><span>10</span><span>        <span>self</span>.r[<span>15</span>] = <span>self</span>.r[<span>15</span>].wrapping_add(<span>4</span>);
</span></span><span><span>11</span><span>    }
</span></span><span><span>12</span><span>
</span></span><span><span>13</span><span>    <span>pub</span> <span>fn</span> <span>step</span>(&amp;<span>mut</span> <span>self</span>) -&gt; <span>Result</span>&lt;<span>bool</span>, err::<span>Err</span>&gt; {
</span></span><span><span>14</span><span>        <span>let</span> <span>Some</span>(word) = <span>self</span>.mem.read_u32(<span>self</span>.pc()) <span>else</span> {
</span></span><span><span>15</span><span>            <span>return</span> <span>Ok</span>(<span>false</span>);
</span></span><span><span>16</span><span>        };
</span></span><span><span>17</span><span>
</span></span><span><span>18</span><span>        <span>if</span> word == <span>0</span> {
</span></span><span><span>19</span><span>            <span>// zero instruction means we hit zeroed out rest of the page
</span></span></span><span><span>20</span><span><span></span>            <span>return</span> <span>Ok</span>(<span>false</span>);
</span></span><span><span>21</span><span>        }
</span></span><span><span>22</span><span>
</span></span><span><span>23</span><span>        <span>let</span> InstructionContainer { instruction, cond } = decoder::decode_word(word, <span>self</span>.pc());
</span></span><span><span>24</span><span>
</span></span><span><span>25</span><span>        <span>if</span> !<span>self</span>.cond_passes(cond) {
</span></span><span><span>26</span><span>            <span>self</span>.advance();
</span></span><span><span>27</span><span>            <span>return</span> <span>Ok</span>(<span>true</span>);
</span></span><span><span>28</span><span>        }
</span></span><span><span>29</span><span>
</span></span><span><span>30</span><span>        <span>match</span> instruction {
</span></span><span><span>31</span><span>            decoder::Instruction::MovImm { rd, rhs } =&gt; {
</span></span><span><span>32</span><span>                <span>self</span>.r[rd <span>as</span> <span>usize</span>] = rhs;
</span></span><span><span>33</span><span>            }
</span></span><span><span>34</span><span>            decoder::Instruction::Unknown(w) =&gt; {
</span></span><span><span>35</span><span>                <span>return</span> <span>Err</span>(err::<span>Err</span>::UnknownOrUnsupportedInstruction(w));
</span></span><span><span>36</span><span>            }
</span></span><span><span>37</span><span>            i =&gt; {
</span></span><span><span>38</span><span>                <span>stinkln!</span>(
</span></span><span><span>39</span><span>                    <span>&#34;found unimplemented instruction, exiting: {:#x}:={:?}&#34;</span>,
</span></span><span><span>40</span><span>                    word,
</span></span><span><span>41</span><span>                    i
</span></span><span><span>42</span><span>                );
</span></span><span><span>43</span><span>                <span>self</span>.status = <span>Some</span>(<span>1</span>);
</span></span><span><span>44</span><span>            }
</span></span><span><span>45</span><span>        }
</span></span><span><span>46</span><span>
</span></span><span><span>47</span><span>        <span>self</span>.advance();
</span></span><span><span>48</span><span>
</span></span><span><span>49</span><span>        <span>Ok</span>(<span>true</span>)
</span></span><span><span>50</span><span>    }
</span></span><span><span>51</span><span>}</span></span></code></pre></div><h2 id="ldr-and-addresses-in-literal-pools">LDR and addresses in literal pools</h2><p>While <a href="#translating-guest-memory-access-to-host-memory-access">Translating guest memory access to host memory
access</a> goes into depth
on translating / forwarding guest memory access to host memory adresses, this
chapter will focus on the layout of literals in armv7 and how <code>ldr</code> indirects
memory access.</p><p>Lets first take a look at the ldr instruction of our hello world example:</p><p><span>ARMASM</span></p><div><pre tabindex="0"><code data-lang="armasm"><span><span> 1</span><span>    <span>.section</span> <span>.rodata</span>
</span></span><span><span> 2</span><span>    <span>@ define a string with the `msg` label
</span></span></span><span><span> 3</span><span><span></span>msg:
</span></span><span><span> 4</span><span>    <span>@ asciz is like asciii but zero terminated
</span></span></span><span><span> 5</span><span><span></span>    <span>.asciz</span> <span>&#34;</span>Hello <span>world!\n&#34;</span>
</span></span><span><span> 6</span><span>
</span></span><span><span> 7</span><span>    <span>.section</span> <span>.text</span>
</span></span><span><span> 8</span><span>    <span>.global</span> _start
</span></span><span><span> 9</span><span>_start:
</span></span><span><span>10</span><span>    <span>@ load the literal pool addr of msg into r1
</span></span></span><span><span>11</span><span><span></span>    ldr <span>r1</span>, =msg</span></span></code></pre></div><p>The <code>as</code>
<a href="https://sourceware.org/binutils/docs/as.html#index-LDR-reg_002c_003d_003clabel_003e-pseudo-op_002c-ARM">documentation</a>
says:</p><blockquote><p><code>LDR</code></p><p><span>ARMASM</span></p><div><pre tabindex="0"><code data-lang="armasm"><span><span>1</span><span>ldr <span>&lt;register&gt;</span>, <span>=</span> <span>&lt;expression&gt;</span></span></span></code></pre></div><p>If expression evaluates to a numeric constant then a MOV or MVN instruction
will be used in place of the LDR instruction, if the constant can be generated
by either of these instructions. Otherwise the constant will be placed into the
nearest literal pool (if it not already there) and a PC relative LDR
instruction will be generated.</p></blockquote><p>Now this may not make sense at a first glance, why would <code>=msg</code> be assembled
into an address to the address of the literal. But an <code>armv7</code> instruction can
not encode a full address, it is impossible due to the instruction being
restricted to an 8-bit value rotated right by an even number of bits. The ldr
instructions argument points to a literal pool entry, this entry is a 32-bit
value and reading it produces the actual address of <code>msg</code>.</p><p>When decoding we can see ldr points to a memory address (32800 or <code>0x8020</code>) in
the section we mmaped earlier:</p><p><span>TEXT</span></p><div><pre tabindex="0"><code data-lang="text"><span><span>1</span><span>[src/cpu/mod.rs:121:15] instruction = LdrLiteral { rd: 1, addr: 32800 }</span></span></code></pre></div><p>Before accessing guest memory, we must translate said addr to a host addr:</p><p><span>TEXT</span></p><div><pre tabindex="0"><code data-lang="text"><span><span> 1</span><span>+--ldr.addr--+
</span></span><span><span> 2</span><span>|   0x8020   |
</span></span><span><span> 3</span><span>+------------+
</span></span><span><span> 4</span><span>      |
</span></span><span><span> 5</span><span>      |             +-------------Mem::read_u32(addr)-------------+
</span></span><span><span> 6</span><span>      |             |                                             |
</span></span><span><span> 7</span><span>      |             |   +--guest--+                               |
</span></span><span><span> 8</span><span>      |             |   |  0x8020 | ------------+                 |
</span></span><span><span> 9</span><span>      |             |   +---------+             |                 |
</span></span><span><span>10</span><span>      |             |                           |                 |
</span></span><span><span>11</span><span>      +-----------&gt; |                       Mem::translate        |
</span></span><span><span>12</span><span>                    |                           |                 |
</span></span><span><span>13</span><span>                    |   +------host------+      |                 |
</span></span><span><span>14</span><span>                    |   | 0x7ffff7f87020 | &lt;----+                 |
</span></span><span><span>15</span><span>                    |   +----------------+                        |
</span></span><span><span>16</span><span>                    |                                             |
</span></span><span><span>17</span><span>                    +---------------------------------------------+
</span></span><span><span>18</span><span>                                           |
</span></span><span><span>19</span><span>+--literal-ptr--+                          |
</span></span><span><span>20</span><span>|     0x8024    | &lt;------------------------+
</span></span><span><span>21</span><span>+---------------+</span></span></code></pre></div><p>Or in code:</p><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span> 1</span><span><span>impl</span>&lt;&#39;cpu&gt; Cpu&lt;&#39;cpu&gt; {
</span></span><span><span> 2</span><span>    <span>pub</span> <span>fn</span> <span>step</span>(&amp;<span>mut</span> <span>self</span>) -&gt; <span>Result</span>&lt;<span>bool</span>, err::<span>Err</span>&gt; {
</span></span><span><span> 3</span><span>        <span>// ...
</span></span></span><span><span> 4</span><span><span></span>        <span>match</span> instruction {
</span></span><span><span> 5</span><span>            decoder::Instruction::LdrLiteral { rd, addr } =&gt; {
</span></span><span><span> 6</span><span>                <span>self</span>.r[rd <span>as</span> <span>usize</span>] = <span>self</span>.mem.read_u32(addr).expect(<span>&#34;Segfault&#34;</span>);
</span></span><span><span> 7</span><span>            }
</span></span><span><span> 8</span><span>        }
</span></span><span><span> 9</span><span>        <span>// ...
</span></span></span><span><span>10</span><span><span></span>    }
</span></span><span><span>11</span><span>}</span></span></code></pre></div><p>Any other instruction using a addr will have to also go through the
<code>Mem::translate</code> indirection.</p><h2 id="forwarding-syscalls-and-other-feature-flag-based-logic">Forwarding Syscalls and other feature flag based logic</h2><p>Since stinkarm has three ways of dealing with syscalls (<code>deny</code>, <code>sandbox</code>,
<code>forward</code>). I decided on handling the selection of the appropriate logic at cpu
creation time via a function pointer attached to the CPU as the
<code>syscall_handler</code> field:</p><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span> 1</span><span><span>type</span> <span>SyscallHandlerFn</span> = <span>fn</span>(&amp;<span>mut</span> Cpu, ArmSyscall) -&gt; <span>i32</span>;
</span></span><span><span> 2</span><span>
</span></span><span><span> 3</span><span><span>pub</span> <span>struct</span> <span>Cpu</span>&lt;&#39;cpu&gt; {
</span></span><span><span> 4</span><span>    <span>/// r0-r15 (r13=SP, r14=LR, r15=PC)
</span></span></span><span><span> 5</span><span><span></span>    <span>pub</span> r: [<span>u32</span>; <span>16</span>],
</span></span><span><span> 6</span><span>    <span>pub</span> cpsr: <span>u32</span>,
</span></span><span><span> 7</span><span>    <span>pub</span> mem: <span>&amp;</span>&#39;cpu <span>mut</span> mem::Mem,
</span></span><span><span> 8</span><span>    syscall_handler: <span>SyscallHandlerFn</span>,
</span></span><span><span> 9</span><span>    <span>pub</span> status: <span>Option</span>&lt;<span>i32</span>&gt;,
</span></span><span><span>10</span><span>}
</span></span><span><span>11</span><span>
</span></span><span><span>12</span><span><span>impl</span>&lt;&#39;cpu&gt; Cpu&lt;&#39;cpu&gt; {
</span></span><span><span>13</span><span>    <span>pub</span> <span>fn</span> <span>new</span>(conf: <span>&amp;</span>&#39;cpu <span>config</span>::Config, mem: <span>&amp;</span>&#39;cpu <span>mut</span> mem::Mem, pc: <span>u32</span>) -&gt; <span>Self</span> {
</span></span><span><span>14</span><span>        <span>// ... 
</span></span></span><span><span>15</span><span><span></span>
</span></span><span><span>16</span><span>        <span>// simplified, in stinkarm this gets wrapped if the user specifies
</span></span></span><span><span>17</span><span><span></span>        <span>// syscall traces via -lsyscalls or -v
</span></span></span><span><span>18</span><span><span></span>        s.syscall_handler = <span>match</span> conf.syscalls {
</span></span><span><span>19</span><span>            SyscallMode::Forward =&gt; translation::syscall_forward,
</span></span><span><span>20</span><span>            SyscallMode::Sandbox =&gt; sandbox::syscall_sandbox,
</span></span><span><span>21</span><span>            SyscallMode::Deny =&gt; sandbox::syscall_stub,
</span></span><span><span>22</span><span>        };
</span></span><span><span>23</span><span>        <span>// ...
</span></span></span><span><span>24</span><span><span></span>    }
</span></span><span><span>25</span><span>}</span></span></code></pre></div><h3 id="calling-conventions-armv7-vs-x86">Calling conventions, armv7 vs x86</h3><p>In our examples I obviously used the armv7 syscall calling convention. But this
convention differs from the calling convention of our x86 (technically its
x86-64 System V AMD64 ABI) host by a lot.</p><p>While armv7 uses <code>r7</code> for the syscall number and <code>r0-r5</code> for the syscall
arguments, x86 uses <code>rax</code> for the syscall id and <code>rdi</code>, <code>rsi</code>, <code>rdx</code>, <code>r10</code>,
<code>r8</code> and <code>r9</code> for the syscall arguments (<code>rcx</code> can’t be used since <code>syscall</code>
clobbers it, thus Linux goes with <code>r10</code>).</p><p>Also the syscall numbers differ between armv7 and x86, <code>sys_write</code> is <code>1</code> on
x86 and <code>4</code> on armv7. If you are interested in either calling conventions,
syscall ids and documentation, do visit <a href="https://www.chromium.org/chromium-os/developer-library/reference/linux-constants/syscalls/">The Chromium Projects- Linux System
Call
Table</a>,
it is generated from Linux headers and fairly readable.</p><p>Table version:</p><table><thead><tr><th>usage</th><th>armv7</th><th>x86-64</th></tr></thead><tbody><tr><td>syscall id</td><td>r7</td><td>rax</td></tr><tr><td>return</td><td>r0</td><td>rax</td></tr><tr><td>arg0</td><td>r0</td><td>rdi</td></tr><tr><td>arg1</td><td>r1</td><td>rsi</td></tr><tr><td>arg2</td><td>r2</td><td>rdx</td></tr><tr><td>arg3</td><td>r3</td><td>r10</td></tr><tr><td>arg4</td><td>r4</td><td>r8</td></tr><tr><td>arg5</td><td>r5</td><td>r9</td></tr></tbody></table><p>So something like writing <code>TEXT123</code> to stdout looks like this on arm:</p><p><span>ARMASM</span></p><div><pre tabindex="0"><code data-lang="armasm"><span><span> 1</span><span>    <span>.section</span> <span>.rodata</span>
</span></span><span><span> 2</span><span>txt:<span>
</span></span></span><span><span> 3</span><span><span>    .asciz </span>&#34;<span>TEXT123\n</span>&#34;
</span></span><span><span> 4</span><span>
</span></span><span><span> 5</span><span>    <span>.section</span> <span>.text</span>
</span></span><span><span> 6</span><span>    <span>.global</span> _start
</span></span><span><span> 7</span><span>_start:
</span></span><span><span> 8</span><span>    ldr <span>r0</span>, =1
</span></span><span><span> 9</span><span>    ldr <span>r1</span>, =txt
</span></span><span><span>10</span><span>    mov <span>r2</span>, #<span>8</span>
</span></span><span><span>11</span><span>    mov <span>r7</span>, #<span>4</span>
</span></span><span><span>12</span><span>    svc #<span>0</span></span></span></code></pre></div><p>While it looks like the following on x86:</p><p><span>ASM</span></p><div><pre tabindex="0"><code data-lang="asm"><span><span> 1</span><span>    .section .rodata
</span></span><span><span> 2</span><span>txt:
</span></span><span><span> 3</span><span>    .string <span>&#34;TEXT123\n&#34;</span>
</span></span><span><span> 4</span><span>
</span></span><span><span> 5</span><span>    .section .text
</span></span><span><span> 6</span><span>    .global _start
</span></span><span><span> 7</span><span>_start:
</span></span><span><span> 8</span><span>    <span>movq</span> $1, <span>%rax</span>
</span></span><span><span> 9</span><span>    <span>movq</span> $1, <span>%rdi</span>
</span></span><span><span>10</span><span>    <span>leaq</span> txt(<span>%rip</span>), <span>%rsi</span>
</span></span><span><span>11</span><span>    <span>movq</span> $8, <span>%rdx</span>
</span></span><span><span>12</span><span>    <span>syscall</span></span></span></code></pre></div><h3 id="hooking-the-syscall-handler-up">Hooking the syscall handler up</h3><p>After made the calling convention differences clear, the handling of a syscall
is simply to execute this handler and use <code>r7</code> to convert the armv7 syscall
number to the x86 syscall number:</p><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span> 1</span><span><span>impl</span>&lt;&#39;cpu&gt; Cpu&lt;&#39;cpu&gt; {
</span></span><span><span> 2</span><span>    <span>pub</span> <span>fn</span> <span>step</span>(&amp;<span>mut</span> <span>self</span>) -&gt; <span>Result</span>&lt;<span>bool</span>, err::<span>Err</span>&gt; {
</span></span><span><span> 3</span><span>        <span>// ...
</span></span></span><span><span> 4</span><span><span></span>
</span></span><span><span> 5</span><span>        <span>match</span> instruction {
</span></span><span><span> 6</span><span>            <span>// ...
</span></span></span><span><span> 7</span><span><span></span>            decoder::Instruction::Svc =&gt; {
</span></span><span><span> 8</span><span>                <span>self</span>.r[<span>0</span>] = (<span>self</span>.syscall_handler)(<span>self</span>, ArmSyscall::try_from(<span>self</span>.r[<span>7</span>])?) <span>as</span> <span>u32</span>;
</span></span><span><span> 9</span><span>            }
</span></span><span><span>10</span><span>            <span>// ...
</span></span></span><span><span>11</span><span><span></span>        }
</span></span><span><span>12</span><span>        <span>// ...
</span></span></span><span><span>13</span><span><span></span>    }
</span></span><span><span>14</span><span>}</span></span></code></pre></div><p>Of course for this to work the syscall has to be implemented and even
decodable. At least for the decoding, there is the <code>ArmSyscall</code> enum:</p><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span> 1</span><span><span>#[derive(Debug)]</span>
</span></span><span><span> 2</span><span><span>#[allow(non_camel_case_types)]</span>
</span></span><span><span> 3</span><span><span>pub</span> <span>enum</span> <span>ArmSyscall</span> {
</span></span><span><span> 4</span><span>    restart = <span>0x00</span>,
</span></span><span><span> 5</span><span>    exit = <span>0x01</span>,
</span></span><span><span> 6</span><span>    fork = <span>0x02</span>,
</span></span><span><span> 7</span><span>    read = <span>0x03</span>,
</span></span><span><span> 8</span><span>    write = <span>0x04</span>,
</span></span><span><span> 9</span><span>    open = <span>0x05</span>,
</span></span><span><span>10</span><span>    close = <span>0x06</span>,
</span></span><span><span>11</span><span>}
</span></span><span><span>12</span><span>
</span></span><span><span>13</span><span><span>impl</span> TryFrom&lt;<span>u32</span>&gt; <span>for</span> ArmSyscall {
</span></span><span><span>14</span><span>    <span>type</span> <span>Error</span> = err::<span>Err</span>;
</span></span><span><span>15</span><span>
</span></span><span><span>16</span><span>    <span>fn</span> <span>try_from</span>(value: <span>u32</span>) -&gt; <span>Result</span>&lt;<span>Self</span>, <span>Self</span>::Error&gt; {
</span></span><span><span>17</span><span>        <span>Ok</span>(<span>match</span> value {
</span></span><span><span>18</span><span>            <span>0x00</span> =&gt; <span>Self</span>::restart,
</span></span><span><span>19</span><span>            <span>0x01</span> =&gt; <span>Self</span>::exit,
</span></span><span><span>20</span><span>            <span>0x02</span> =&gt; <span>Self</span>::fork,
</span></span><span><span>21</span><span>            <span>0x03</span> =&gt; <span>Self</span>::read,
</span></span><span><span>22</span><span>            <span>0x04</span> =&gt; <span>Self</span>::write,
</span></span><span><span>23</span><span>            <span>0x05</span> =&gt; <span>Self</span>::open,
</span></span><span><span>24</span><span>            <span>0x06</span> =&gt; <span>Self</span>::close,
</span></span><span><span>25</span><span>            _ =&gt; <span>return</span> <span>Err</span>(err::<span>Err</span>::UnknownSyscall(value)),
</span></span><span><span>26</span><span>        })
</span></span><span><span>27</span><span>    }
</span></span><span><span>28</span><span>}</span></span></code></pre></div><p>By default the sandboxing mode is selected, but I will go into detail on both
sandboxing and denying syscalls later, first I want to focus on the
implementation of the translation layer from armv7 to x86 syscalls:</p><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span>1</span><span><span>pub</span> <span>fn</span> <span>syscall_forward</span>(cpu: <span>&amp;</span><span>mut</span> <span>super</span>::Cpu, syscall: <span>ArmSyscall</span>) -&gt; <span>i32</span> {
</span></span><span><span>2</span><span>    <span>match</span> syscall {
</span></span><span><span>3</span><span>        <span>// none are implemented, dump debug print
</span></span></span><span><span>4</span><span><span></span>        c =&gt; <span>todo!</span>(<span>&#34;</span><span>{:?}</span><span>&#34;</span>, c),
</span></span><span><span>5</span><span>    }
</span></span><span><span>6</span><span>}</span></span></code></pre></div><h3 id="handling-the-only-exception-exit">Handling the only exception: <code>exit</code></h3><p>Since exit means the guest wants to exit, we can’t just forward this to the
host system, simply because this would exit the emulator before it would be
able to do cleanup and unmap memory regions allocated.</p><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span>1</span><span><span>pub</span> <span>fn</span> <span>syscall_forward</span>(cpu: <span>&amp;</span><span>mut</span> <span>super</span>::Cpu, syscall: <span>ArmSyscall</span>) -&gt; <span>i32</span> {
</span></span><span><span>2</span><span>    <span>match</span> syscall {
</span></span><span><span>3</span><span>        ArmSyscall::exit =&gt; {
</span></span><span><span>4</span><span>            cpu.status = <span>Some</span>(cpu.r[<span>0</span>] <span>as</span> <span>i32</span>);
</span></span><span><span>5</span><span>            <span>0</span>
</span></span><span><span>6</span><span>        }
</span></span><span><span>7</span><span>        <span>// ...
</span></span></span><span><span>8</span><span><span></span>    }
</span></span><span><span>9</span><span>}</span></span></code></pre></div><p>To both know we hit the exit syscall (we need to, otherwise the emulator
executes further) and propagate the exit code to the host system, we set the
<code>Cpu::status</code> field to <code>Some(r0)</code>, which is the argument to the syscall.</p><p>This field is then used in the emulator entry point / main loop:</p><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span> 1</span><span><span>fn</span> <span>main</span>() {
</span></span><span><span> 2</span><span>    <span>let</span> <span>mut</span> cpu = cpu::Cpu::new(&amp;conf, &amp;<span>mut</span> mem, elf.header.entry);
</span></span><span><span> 3</span><span>
</span></span><span><span> 4</span><span>    <span>loop</span> {
</span></span><span><span> 5</span><span>        <span>match</span> cpu.step() { <span>/**/</span> }
</span></span><span><span> 6</span><span>
</span></span><span><span> 7</span><span>        <span>// Cpu::status is only some if sys_exit was called, we exit the
</span></span></span><span><span> 8</span><span><span></span>        <span>// emulation loop
</span></span></span><span><span> 9</span><span><span></span>        <span>if</span> cpu.status.is_some() {
</span></span><span><span>10</span><span>            <span>break</span>;
</span></span><span><span>11</span><span>        }
</span></span><span><span>12</span><span>    }
</span></span><span><span>13</span><span>
</span></span><span><span>14</span><span>    <span>let</span> status = cpu.status.unwrap_or(<span>0</span>);
</span></span><span><span>15</span><span>    <span>// cleaning up used memory via munmap
</span></span></span><span><span>16</span><span><span></span>    mem.destroy();
</span></span><span><span>17</span><span>    <span>// propagating the status code to the host system
</span></span></span><span><span>18</span><span><span></span>    exit(status);
</span></span><span><span>19</span><span>}</span></span></code></pre></div><h3 id="implementing-sys_write">Implementing: <code>sys_write</code></h3><p>The write syscall is not as spectacular as <code>sys_exit</code>: writing a <code>buf</code> of <code>len</code>
to a file descriptor.</p><table><thead><tr><th>register</th><th>description</th></tr></thead><tbody><tr><td>rax</td><td>syscall number (1 for write)</td></tr><tr><td>rdi</td><td>file descriptor (0 for stdin, 1 for stdout, 2 for stderr)</td></tr><tr><td>rsi</td><td>a pointer to the buffer</td></tr><tr><td>rdx</td><td>the length of the buffer <code>rsi</code> is pointing to</td></tr></tbody></table><p>It is necessary for doing the O of I/O tho, otherwise there won’t be any
<code>Hello, World!</code>s on the screen.</p><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span> 1</span><span><span>use</span> <span>crate</span>::{cpu, sys};
</span></span><span><span> 2</span><span>
</span></span><span><span> 3</span><span><span>pub</span> <span>fn</span> <span>write</span>(cpu: <span>&amp;</span><span>mut</span> cpu::Cpu, fd: <span>u32</span>, buf: <span>u32</span>, len: <span>u32</span>) -&gt; <span>i32</span> {
</span></span><span><span> 4</span><span>    <span>// fast path for zero length buffer
</span></span></span><span><span> 5</span><span><span></span>    <span>if</span> len == <span>0</span> {
</span></span><span><span> 6</span><span>        <span>return</span> <span>0</span>;
</span></span><span><span> 7</span><span>    }
</span></span><span><span> 8</span><span>
</span></span><span><span> 9</span><span>    <span>// Option::None returned from translate indicates invalid memory access
</span></span></span><span><span>10</span><span><span></span>    <span>let</span> <span>Some</span>(buf_ptr) = cpu.mem.translate(buf) <span>else</span> {
</span></span><span><span>11</span><span>        <span>// so we return &#39;Bad Address&#39;
</span></span></span><span><span>12</span><span><span></span>        <span>return</span> -(sys::Errno::EFAULT <span>as</span> <span>i32</span>);
</span></span><span><span>13</span><span>    };
</span></span><span><span>14</span><span>
</span></span><span><span>15</span><span>    <span>let</span> ret: <span>i64</span>;
</span></span><span><span>16</span><span>    <span>unsafe</span> {
</span></span><span><span>17</span><span>        core::arch::<span>asm!</span>(
</span></span><span><span>18</span><span>            <span>&#34;syscall&#34;</span>,
</span></span><span><span>19</span><span>            <span>// syscall number
</span></span></span><span><span>20</span><span><span></span>            <span>in</span>(<span>&#34;rax&#34;</span>) <span>1_</span><span>u64</span>,
</span></span><span><span>21</span><span>            <span>in</span>(<span>&#34;rdi&#34;</span>) fd <span>as</span> <span>u64</span>,
</span></span><span><span>22</span><span>            <span>in</span>(<span>&#34;rsi&#34;</span>) buf_ptr <span>as</span> <span>u64</span>,
</span></span><span><span>23</span><span>            <span>in</span>(<span>&#34;rdx&#34;</span>) len <span>as</span> <span>u64</span>,
</span></span><span><span>24</span><span>            lateout(<span>&#34;rax&#34;</span>) ret,
</span></span><span><span>25</span><span>            <span>// we clobber rcx
</span></span></span><span><span>26</span><span><span></span>            out(<span>&#34;rcx&#34;</span>) _,
</span></span><span><span>27</span><span>            <span>// and r11
</span></span></span><span><span>28</span><span><span></span>            out(<span>&#34;r11&#34;</span>) _,
</span></span><span><span>29</span><span>            <span>// we don&#39;t modify the stack
</span></span></span><span><span>30</span><span><span></span>            options(nostack),
</span></span><span><span>31</span><span>        );
</span></span><span><span>32</span><span>    }
</span></span><span><span>33</span><span>
</span></span><span><span>34</span><span>    ret.try_into().unwrap_or(<span>i32</span>::MAX)
</span></span><span><span>35</span><span>}</span></span></code></pre></div><p>Adding it to <code>translation::syscall_forward</code> with it’s arguments according to the
calling convention we established before:</p><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span>1</span><span><span>pub</span> <span>fn</span> <span>syscall_forward</span>(cpu: <span>&amp;</span><span>mut</span> <span>super</span>::Cpu, syscall: <span>ArmSyscall</span>) -&gt; <span>i32</span> {
</span></span><span><span>2</span><span>    <span>match</span> syscall {
</span></span><span><span>3</span><span>        <span>// ...
</span></span></span><span><span>4</span><span><span></span>        ArmSyscall::write =&gt; sys::write(cpu, cpu.r[<span>0</span>], cpu.r[<span>1</span>], cpu.r[<span>2</span>]),
</span></span><span><span>5</span><span>        <span>// ...
</span></span></span><span><span>6</span><span><span></span>    }
</span></span><span><span>7</span><span>}</span></span></code></pre></div><p>Executing <code>helloWorld.elf</code> now results in:</p><p><span>SHELL</span></p><div><pre tabindex="0"><code data-lang="shell"><span><span>1</span><span>$ stinkarm -Cforward example/helloWorld.elf
</span></span><span><span>2</span><span>Hello, world!
</span></span><span><span>3</span><span>$ <span>echo</span> <span>$status</span>
</span></span><span><span>4</span><span><span>0</span></span></span></code></pre></div><h3 id="deny-and-sandbox---restricting-syscalls">Deny and Sandbox - restricting syscalls</h3><p>The simplest sandboxing mode is to deny, the more complex is to allow
some syscall interactions while others are denied. The latter requires
checking arguments to syscalls, not just the syscall kind.</p><p>Lets start with the easier syscall handler: <code>deny</code>. Deny simply returns
<code>ENOSYS</code> to all invoked syscalls:</p><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span>1</span><span><span>pub</span> <span>fn</span> <span>syscall_deny</span>(cpu: <span>&amp;</span><span>mut</span> <span>super</span>::Cpu, syscall: <span>ArmSyscall</span>) -&gt; <span>i32</span> {
</span></span><span><span>2</span><span>    <span>if</span> <span>let</span> ArmSyscall::exit = syscall {
</span></span><span><span>3</span><span>        cpu.status = <span>Some</span>(cpu.r[<span>0</span>] <span>as</span> <span>i32</span>)
</span></span><span><span>4</span><span>    };
</span></span><span><span>5</span><span>
</span></span><span><span>6</span><span>    -(sys::Errno::ENOSYS <span>as</span> <span>i32</span>)
</span></span><span><span>7</span><span>}</span></span></code></pre></div><p>Thus executing the hello world and enabling syscall logs results in neither
<code>sys_write</code> nor <code>sys_exit</code> going through and <code>ENOSYS</code> being returned for both
in <code>r0</code>:</p><p><span>TEXT</span></p><div><pre tabindex="0"><code data-lang="text"><span><span>1</span><span>$ stinkarm -Cdeny -lsyscalls examples/helloWorld.elf
</span></span><span><span>2</span><span>148738 write(fd=1, buf=0x8024, len=14) [deny]
</span></span><span><span>3</span><span>=ENOSYS
</span></span><span><span>4</span><span>148738 exit(code=0) [deny]
</span></span><span><span>5</span><span>=ENOSYS</span></span></code></pre></div><p><code>sandbox</code> at a high level is the same as deny, check for conditions before
executing a syscall, if they don’t match, disallow the syscall:</p><p><span>RUST</span></p><div><pre tabindex="0"><code data-lang="rust"><span><span> 1</span><span><span>pub</span> <span>fn</span> <span>syscall_sandbox</span>(cpu: <span>&amp;</span><span>mut</span> <span>super</span>::Cpu, syscall: <span>ArmSyscall</span>) -&gt; <span>i32</span> {
</span></span><span><span> 2</span><span>    <span>match</span> syscall {
</span></span><span><span> 3</span><span>        ArmSyscall::exit =&gt; {
</span></span><span><span> 4</span><span>            cpu.status = <span>Some</span>(cpu.r[<span>0</span>] <span>as</span> <span>i32</span>);
</span></span><span><span> 5</span><span>            <span>0</span>
</span></span><span><span> 6</span><span>        }
</span></span><span><span> 7</span><span>        ArmSyscall::write =&gt; {
</span></span><span><span> 8</span><span>            <span>let</span> (r0, r1, r2) = (cpu.r[<span>0</span>], cpu.r[<span>1</span>], cpu.r[<span>2</span>]);
</span></span><span><span> 9</span><span>            <span>// only allow writing to stdout, stderr and stdin
</span></span></span><span><span>10</span><span><span></span>            <span>if</span> r0 &gt; <span>2</span> {
</span></span><span><span>11</span><span>                <span>return</span> -(sys::Errno::ENOSYS <span>as</span> <span>i32</span>);
</span></span><span><span>12</span><span>            }
</span></span><span><span>13</span><span>
</span></span><span><span>14</span><span>            sys::write(cpu, r0, r1, r2)
</span></span><span><span>15</span><span>        }
</span></span><span><span>16</span><span>        _ =&gt; <span>todo!</span>(<span>&#34;</span><span>{:?}</span><span>&#34;</span>, syscall),
</span></span><span><span>17</span><span>    }
</span></span><span><span>18</span><span>}</span></span></code></pre></div><p>For instance we only allow writing to stdin, stdout and stderr, no other file
descriptors. One could also add pointer range checks, buffer length checks and
other hardening measures here. Emulating the hello world example with this mode
(which is the default mode):</p><p><span>TEXT</span></p><div><pre tabindex="0"><code data-lang="text"><span><span>1</span><span>$ stinkarm -Csandbox -lsyscalls examples/helloWorld.elf
</span></span><span><span>2</span><span>150147 write(fd=1, buf=0x8024, len=14) [sandbox]
</span></span><span><span>3</span><span>Hello, world!
</span></span><span><span>4</span><span>=14
</span></span><span><span>5</span><span>150147 exit(code=0) [sandbox]
</span></span><span><span>6</span><span>=0</span></span></code></pre></div><p>So there you have it, emulating armv7 in six steps:</p><ol><li>parsing and validating a 32-bit armv7 Elf binary</li><li>mapping segments into host address space</li><li>decoding a non-trivial subset of armv7 instructions</li><li>handling program counter relative literal loads</li><li>translating memory interactions from guest to host</li><li>forwarding armv7 Linux syscalls into their x86-64 System V counterparts</li></ol><p>Diving into the Elf and armv7 spec without any previous relevant experience,
except the asm module I had in uni, was a bit overwhelming at first. Armv7
decoding was by far the most annoying part of the project and I still don’t
like the bizarre argument ordering for x86-64 syscalls.</p><p>The whole project is about 1284 lines of Rust, has zero dependencies<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> and is
as far as I know working correctly<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>.</p><p>It executes a real armv7 hello world binary in ~0.015ms of guest execution-only
time, excluding process startup and parsing. The e2e execution with all stages
I outlined before, it takes about 2ms.</p><p><span>TEXT</span></p><div><pre tabindex="0"><code data-lang="text"><span><span> 1</span><span>$ stinkarm -v examples/helloWorld.elf
</span></span><span><span> 2</span><span>[     0.070ms] opening binary &#34;examples/helloWorld.elf&#34;
</span></span><span><span> 3</span><span>[     0.097ms] parsing ELF...
</span></span><span><span> 4</span><span>[     0.101ms] \
</span></span><span><span> 5</span><span>ELF Header:
</span></span><span><span> 6</span><span>  Magic:              [7f, 45, 4c, 46]
</span></span><span><span> 7</span><span>  Class:              ELF32
</span></span><span><span> 8</span><span>  Data:               Little endian
</span></span><span><span> 9</span><span>  Type:               Executable
</span></span><span><span>10</span><span>  Machine:            EM_ARM
</span></span><span><span>11</span><span>  Version:            1
</span></span><span><span>12</span><span>  Entry point:        0x8000
</span></span><span><span>13</span><span>  Program hdr offset: 52 (32 bytes each)
</span></span><span><span>14</span><span>  Section hdr offset: 4696
</span></span><span><span>15</span><span>  Flags:              0x05000200
</span></span><span><span>16</span><span>  EH size:            52
</span></span><span><span>17</span><span>  # Program headers:  1
</span></span><span><span>18</span><span>  # Section headers:  9
</span></span><span><span>19</span><span>  Str tbl index:      8
</span></span><span><span>20</span><span>
</span></span><span><span>21</span><span>Program Headers:
</span></span><span><span>22</span><span>  Type       Offset   VirtAddr   PhysAddr   FileSz    MemSz  Flags  Align
</span></span><span><span>23</span><span>  LOAD     0x001000 0x00008000 0x00008000 0x000033 0x000033    R|X 0x1000
</span></span><span><span>24</span><span>
</span></span><span><span>25</span><span>[     0.126ms] mapped program header `LOAD` of 51B (G=0x8000 -&gt; H=0x7ffff7f87000)
</span></span><span><span>26</span><span>[     0.129ms] jumping to entry G=0x8000 at H=0x7ffff7f87000
</span></span><span><span>27</span><span>[     0.131ms] starting the emulator
</span></span><span><span>28</span><span>153719 write(fd=1, buf=0x8024, len=14) [sandbox]
</span></span><span><span>29</span><span>Hello, world!
</span></span><span><span>30</span><span>=14
</span></span><span><span>31</span><span>153719 exit(code=0) [sandbox]
</span></span><span><span>32</span><span>=0
</span></span><span><span>33</span><span>[     0.149ms] exiting with `0`</span></span></code></pre></div><p>Comparing the whole pipeline (parsing elf, segment mapping, cpu setup, etc) to
<code>qemu</code> we arrive at the following micro benchmark results. To be fair, qemu
does a whole lot more than stinkarm, it has a jit, a full linux-user runtime, a
dynamic loader, etc.</p><p><span>TEXT</span></p><div><pre tabindex="0"><code data-lang="text"><span><span>1</span><span>$ hyperfine &#34;./target/release/stinkarm examples/helloWorld.elf&#34; -N --warmup 10
</span></span><span><span>2</span><span>Benchmark 1: ./target/release/stinkarm examples/helloWorld.elf
</span></span><span><span>3</span><span>  Time (mean ± σ):       1.9 ms ±   0.3 ms    [User: 0.2 ms, System: 1.4 ms]
</span></span><span><span>4</span><span>  Range (min … max):     1.6 ms …   3.4 ms    1641 runs
</span></span><span><span>5</span><span>
</span></span><span><span>6</span><span>$ hyperfine &#34;qemu-arm ./examples/helloWorld.elf&#34; -N --warmup 10
</span></span><span><span>7</span><span>Benchmark 1: qemu-arm ./examples/helloWorld.elf
</span></span><span><span>8</span><span>  Time (mean ± σ):      12.3 ms ±   1.5 ms    [User: 3.8 ms, System: 8.0 ms]
</span></span><span><span>9</span><span>  Range (min … max):     8.8 ms …  19.8 ms    226 runs</span></span></code></pre></div></div></div>
  </body>
</html>
