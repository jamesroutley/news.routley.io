<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.ctrl-alt-test.fr/2023/procedural-3d-mesh-generation-in-a-64kb-intro/">Original</a>
    <h1>Procedural 3D mesh generation in a 64kB intro</h1>
    
    <div id="readability-page-1" class="page"><div>
			
<p><em>This article is the sequel to our series on the making of H – Immersion (see <a href="https://www.youtube.com/watch?v=27PN1SsXbjM">the demo on YouTube</a>). You can read the first and the second parts here: </em><a href="http://www.ctrl-alt-test.fr/?p=463"><em>A dive into the making of Immersion</em></a><em> ; </em><a href="http://www.ctrl-alt-test.fr/2018/texturing-in-a-64kb-intro/"><em>Texturing a 64kB intro</em></a><em>.</em></p>



<p>In the previous part, we saw how textures are generated in <a href="http://www.pouet.net/prod.php?which=69654"><em>H – Immersion</em></a>. This time, we’ll have a look at another important tool for size coding: procedural geometry.</p>



<p>More specifically, since our rendering uses traditional polygons, we wrote a procedural mesh generator. We’ll see how with a few well chosen techniques, it is possible to create a variety of shapes, or make a viewer believe we did.</p>



<h2>First, Cubes</h2>



<p>When we started making demos, the 64kB limit felt intimidating. We didn’t know anything about procedural mesh generation, and we already had a lot to do with the rendering, the camera, the textures, the story… well, with everything. So in our first demo, <a href="https://www.ctrl-alt-test.fr/productions/b-incubation/"><em>B – Incubation</em></a>, we took the early decision to skip 3D modeling altogether. Instead, we chose to use only cubes and designed the demo around this concept.</p>



<p>This is an example of how a technical constraint can become a creative challenge, and force us to look for new ideas and do something unexpected. In all of our 64kB intros, the size limitation affects the design, sometimes in small and unexpected ways: we are constantly looking for tricks, code reuse, and workarounds to evade this barrier.</p>



<figure><a href="https://www.ctrl-alt-test.fr/?attachment_id=1071"><img decoding="async" loading="lazy" width="1024" height="576" src="https://www.ctrl-alt-test.fr/wp-content/uploads/2023/03/B.jpg" alt="" srcset="https://www.ctrl-alt-test.fr/wp-content/uploads/2023/03/B.jpg 1024w, https://www.ctrl-alt-test.fr/wp-content/uploads/2023/03/B-300x169.jpg 300w, https://www.ctrl-alt-test.fr/wp-content/uploads/2023/03/B-768x432.jpg 768w, https://www.ctrl-alt-test.fr/wp-content/uploads/2023/03/B-624x351.jpg 624w" sizes="(max-width: 1024px) 100vw, 1024px"/></a><figcaption><a href="https://www.ctrl-alt-test.fr/productions/b-incubation/">B – Incubation</a>, 2010.</figcaption></figure>



<h2>Revolution!</h2>



<p>After this first 64kB, it was time to introduce procedural meshes at last! For <a href="https://www.ctrl-alt-test.fr/productions/f-felixs-workshop/"><em>F – Felix’s Workshop</em></a>, we implemented some rudimentary mesh generation. The demo received good feedback, but the code is probably simpler than what many people expect.</p>



<p>If you pay close attention to the image below, you might notice that there are only two kinds of shapes used by all geometry. Some elements, like the table, the shelf and the wall, are made by assembling deformed cubes. The rest have varied shapes, but are all sort of cylindrical. Indeed we built them using <a href="https://en.wikipedia.org/wiki/Surface_of_revolution">surfaces of revolution</a>.</p>



<figure><a href="https://www.ctrl-alt-test.fr/wp-content/uploads/2023/03/image-1.png"><img decoding="async" loading="lazy" width="919" height="473" src="https://www.ctrl-alt-test.fr/wp-content/uploads/2023/03/image-1.png" alt="" srcset="https://www.ctrl-alt-test.fr/wp-content/uploads/2023/03/image-1.png 919w, https://www.ctrl-alt-test.fr/wp-content/uploads/2023/03/image-1-300x154.png 300w, https://www.ctrl-alt-test.fr/wp-content/uploads/2023/03/image-1-768x395.png 768w, https://www.ctrl-alt-test.fr/wp-content/uploads/2023/03/image-1-624x321.png 624w" sizes="(max-width: 919px) 100vw, 919px"/></a><figcaption><a href="https://www.ctrl-alt-test.fr/productions/f-felixs-workshop/">F – Felix’s Workshop</a>, 2012</figcaption></figure>



<p>The idea is to draw <a href="http://iquilezles.org/www/articles/minispline/minispline.htm">simple splines</a>, then rotate them around an axis to create 3D models. Here is the spline we used to create pawns on a chessboard.</p>



<p><img decoding="async" loading="lazy" width="459" height="308" src="https://lh6.googleusercontent.com/onVFXgfC86NkYfgx8OTkJ7SHA7WK8wDtCB--jQq5CiV3dmbSJZ6LS2h63r01Smx5vVvnRdLt9f0xo0OYnwz-e5ld6tgZwGZtrbtC3jhT7Y-GYl2TlqnusStLEK5tbIupPgXR8qJXfFgk26eyenmjVBg"/></p>



<p>The numbers on the left are 2D coordinates of a list of control points. We interpolate between the points using <a href="https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Catmull%E2%80%93Rom_spline">Catmull-Rom splines</a>. Catmull-Rom is a nice algorithm first published in 1974, which <a href="https://iquilezles.org/articles/minispline/">Iñigo Quilez details and recommends</a>. The shape on the right is the result (after symmetry) of applying the technique on the list of points.</p>



<p>Once done, we can convert the data to 3D by creating faces along the spline. With little variation we can also create other chess pieces. Here’s the final result.</p>



<figure><img decoding="async" src="https://lh4.googleusercontent.com/i-jYpkGUa4ziue7xzxMH7ulgME9dbETcKiFplI0DidH-GpXgGP8BXLBGCi_Dff6b9pmJTpJFj6qTndMGXnVNQjRq6O3reYobIwLkjq2Ss6cxdTpRJweTV7If4xAQ7NJ7B9OLocrZ4NYPiKrD0gxV8zQ" alt=""/><figcaption><a href="https://www.ctrl-alt-test.fr/productions/f-felixs-workshop/">F – Felix’s Workshop</a>, 2012</figcaption></figure>



<p>How many bytes do we need for this? Not too many, especially when you reuse the technique in lots of ways throughout the demo. If we stored each number on one byte, we would need less than 40 bytes of data to represent the pawn… and this doesn’t take into account the compression step.</p>



<p>If you look at the <a href="https://github.com/laurentlb/Ctrl-Alt-Test/blob/master/F/src/chess.cc">source code for the chessboard</a>, you’ll notice that we actually use a floating-point type to store these integers between 0 and 255. These 32-bit floats use 4 bytes each. Is it a waste of bytes? Not quite: as said in the previous paragraph, the program is compressed. If you check the <a href="https://www.h-schmidt.net/FloatConverter/IEEE754.html">binary representation</a> of those floats, you’ll see they are very similar and end with a bunch of 0s. The compression tool (<a href="http://www.farbrausch.de/~fg/kkrunchy/">kkrunchy</a>) will pack this efficiently, and it can be smaller than if we tried to be smart.</p>



<h2>Extending and combining</h2>



<figure><a href="https://www.ctrl-alt-test.fr/wp-content/uploads/2023/03/image.png"><img decoding="async" loading="lazy" src="https://www.ctrl-alt-test.fr/wp-content/uploads/2023/03/image.png" alt="" width="655" height="351" srcset="https://www.ctrl-alt-test.fr/wp-content/uploads/2023/03/image.png 884w, https://www.ctrl-alt-test.fr/wp-content/uploads/2023/03/image-300x161.png 300w, https://www.ctrl-alt-test.fr/wp-content/uploads/2023/03/image-768x412.png 768w, https://www.ctrl-alt-test.fr/wp-content/uploads/2023/03/image-624x335.png 624w" sizes="(max-width: 655px) 100vw, 655px"/></a><figcaption><a href="https://www.ctrl-alt-test.fr/productions/f-felixs-workshop/">F – Felix’s Workshop</a>, 2012</figcaption></figure>



<p>In the scene above, notice how the drum has distinct faces. Our function lets us control the number of faces to generate, so not everything has to be perfectly circular. For example, the pencil on the desk is hexagonal.</p>



<p>In the background of the chess scene, even the white ornament at the top of the hearth is made with this technique: it is built as a pointy octogonal shape. Then the central part is elongated along one axis, resulting in a large shape with beveled corners. We can not only elongate the shape along an axis, but also generate it along a curve. This is how the train ramp is made, with its path described by another spline.</p>



<h2>Growing Cubes</h2>



<p>Combining and deforming simple cubes also has a lot of potential. For the vegetation in <a href="https://www.ctrl-alt-test.fr/productions/h-immersion/"><em>H – Immersion</em></a>, we started from a cuboid, and deformed it a bit. Then we made many copies of the mesh placed vertically around an imaginary axis, with random size and orientation. This creates something that vaguely looks like a plant. We repeat, again with random parameters, to create more of them:</p>


<div>
<figure><img decoding="async" loading="lazy" src="https://lh4.googleusercontent.com/7_52XY9m9iOx1OnfpHP27HMekWKRTPkvQF9310HPbMnyzTFmvSDeob7mTZV8qUhxjiYrURgNZxt9hNnC8e7_tQWttXZL6pLjz9OoFvTvxQD1fANEbMV6pEYEQvrTjKCWzWBAPw5KnRJZazBsdqJr9VU" alt="" width="389" height="289"/></figure></div>


<p>This looks very rough and you’re probably expecting to read what the next steps are to refine the shape. There aren’t any: this is the final mesh. We didn’t even create a  custom texture for it. Instead, we just applied the ground texture on that mesh!</p>



<p>But during the demo, the effect works well enough thanks to the rendering, the lights and shadows, and a simple but convincing animation. The editing also helps a lot: the shapes and movements set the mood, but the viewer doesn’t have time to notice the details before the camera moves on. Sometimes evoking a shape with a proper mood is more effective than painstakingly modeling it.</p>



<figure><img decoding="async" src="https://lh3.googleusercontent.com/cOQdPOCsI0zk3UzRiOvAyFOQM_r83o9tJAf4a_VTXGdWoucoidbG3mR6PTuEgl-XG6wVSmeR574DwkKNgxWQ3gsido1tdjvb9odQyTcLf-ZFj0lHo0sJeeM3WPpcrgN0LI2IbA-ixwYMN41BiMyClq4" alt=""/><figcaption><a href="https://www.ctrl-alt-test.fr/productions/h-immersion/">H – Immersion</a>, 2017</figcaption></figure>



<h2>Extruding Cubes</h2>



<p>At some point, we wanted to have more complex meshes. As usual, we started from our beloved cube and decided to modify it. Merely deforming a cube will still result in.. well, a cuboid. So we needed something more. Enters extrusion: we pick a face, and <a href="https://docs.blender.org/manual/en/latest/modeling/meshes/editing/face/extrude_faces.html">extrude it</a>. This operation will create a new face, which we can pull from the object, resize, or transform in any way we like.</p>



<p>We iterate multiple times, to create the shape we want. Each extrusion will add more details. The result is often low poly, but we use the <a href="https://en.wikipedia.org/wiki/Catmull%E2%80%93Clark_subdivision_surface">Catmull-Clark subdivision algorithm</a> to smooth the result out. This approach was inspired by the <a href="https://qoob.weebly.com/index.html">Qoob modeling tool</a>.</p>



<p>What we’ve described is exactly what we did to generate the small statues used as decorating props in several places during the demo:</p>



<figure><img decoding="async" src="https://lh3.googleusercontent.com/AjEaH_xH19dYAsH5sJXdrX5hJ7s0XJ7QYCHoevm-MbyGp7nsaVRczboXU11A8Y4_1GOb8w9CJswnqMCBfVjNy4-TJUKY4jTD8fYRY-hZsu6fH9BY9fVqwg66oZdFfPeQbuD5lUkJZ8vfM_PJHcR6KQQ" alt=""/></figure>



<p>Since it’s all procedural generation, we can pass arguments to the function. These arguments can control some angles for the legs, arms, etc. Write a loop generating lots of statues with random parameters, et voilà! You have enough variation, so that it doesn’t get visually boring.</p>



<p>We also created two statues with hard-coded parameters, for better results. Here is how it looks after applying textures and lighting.</p>



<figure><img decoding="async" loading="lazy" src="https://lh3.googleusercontent.com/cHWn2YmmnkQ06Qo1GgO0xZFphagI7vks38V4oExSOOZOSjLjDTByI2vv_mlkIjOzMMIysoF_jy3mnQ7rPASnKNs-gyhrXZEm5cb-qj8z94_NRJ2UJXXKtbppHZhe-a1Q_yPgH9nQstTFHkf4BeEmfYY" alt="" width="655" height="391"/><figcaption><a href="https://www.ctrl-alt-test.fr/productions/h-immersion/">H – Immersion</a>, 2017</figcaption></figure>



<p>And of course, statues are reused: we’ve also put variations of those on top of a fountain created with a revolution surface.</p>



<figure><img decoding="async" loading="lazy" src="https://lh5.googleusercontent.com/UujWAKfSEqj29eREO3vqE0mjwspBgfFoGvncT9NYZKOwlmFA0vXHlxqyubZVUX2eIhzHkIz-X0l8X0sZFo6NtGbPMtAi8aH9NMMytSlT5VhzTQDD1YbjHfFvFBSgM2LTaeHaDtKIChux9Zq55b9S_Zs" alt="" width="655" height="369"/><figcaption><a href="https://www.ctrl-alt-test.fr/productions/h-immersion/">H – Immersion</a>, 2017</figcaption></figure>



<h2>Marching Cubes</h2>



<p>In the temple, we wanted to show a colossal statue of Poseidon seating on its throne. The technique used for the small statues was too rough for a model that would have more focus. Poseidon is huge and we wanted more details. The demo has a lot of content and fitting everything was a challenge. After a lot of size optimization work, we managed to get around one spare kilobyte. We decided to use it to get a better model for Poseidon.</p>



<p>To do so, we used a completely different technique than what we’ve seen so far: implicit surface expressed with <a href="https://www.alanzucconi.com/2016/07/01/signed-distance-functions/">signed-distance fields</a> (SDF). This is a technique very popular in 4kB intros, usually used with the ray marching algorithm to generate the result, and implemented as a screenspace shader. But since our rendering is based on meshes, we generated a polygon mesh by evaluating the SDF function with a <a href="https://en.wikipedia.org/wiki/Marching_cubes">marching cube</a> algorithm instead of ray marching. We built the humanoid shape as a series of segments, with a little bit of tweaking to give it an organic look.</p>







<figure><img decoding="async" src="https://lh5.googleusercontent.com/sq9dKfCRuQwF5VZoMtJbGYxLAxrwj3NPSmLRE6HrcYk60kCWZIR804it0mzM-2ZF-knDnrmfmqRphBSvvz3Ifz5luKNcYLwaX1H7j761c96NV2xBtQJtZt1yiIoajFu_isAGuHBT1wcexyrrkRJbR_w" alt=""/><figcaption>On the left, the normals deduced from the SDF reveal the underlying simple shapes.</figcaption></figure>



<p>There was only so much detail we could afford, not to mention that modeling humans is difficult and people are very good at spotting issues in human-like models. We used to our advantage the low resolution of the generated mesh. It turns out that evaluating the normals on the final mesh (as opposed to deducing them from the SDF function) creates visible artifacts: the surface is full of smooth creases and edges. This very rough appearance can give sort of a sculpture look. We used lighting and cinematographic techniques on top of that to trick the viewer into filling the details. In the final shot, the statue seems more detailed than it actually is.</p>



<figure><img decoding="async" src="https://lh4.googleusercontent.com/wr-9Z0zcJE1kopOXlGT9gEiJYvj8oJCs54ddpNJ-mbef36M4HW2vdfX-VtrXSDgho8oaxFHV6GISiQhueg8G4AYUSzsjleOCAqPuXPjSfxZhxbf-mVsKSF8j2nXjA2_yAi0smuSIGMSUVgP4ryYZc4M" alt=""/><figcaption><a href="https://www.ctrl-alt-test.fr/productions/h-immersion/">H – Immersion</a>, 2017</figcaption></figure>



<h2>Online Cubes</h2>



<p>In creative activities, it is often crucial to iterate quickly on a design. You cannot do everything right from the first try, so you need to easily make changes, iterate, explore, see what works.</p>



<p>At some point, we put our mesh generator on a web server, just <a href="http://www.ctrl-alt-test.fr/2018/texturing-in-a-64kb-intro/">like we did with the textures</a>. The webpage had a textarea where we could write C++ code. When we clicked on a button, it compiled the code on the server and returned the mesh in a JSON format. The webpage displayed the result with <a href="https://threejs.org/">three.js</a>, so that we could view and rotate the model with the mouse. Just like in <a href="https://www.shadertoy.com/">Shadertoy</a>, this allowed us to quickly try ideas, share them with the team, fork and tweak other models.</p>



<p>We later moved to a different solution, C++ recompilation, which we mentioned <a href="https://www.ctrl-alt-test.fr/2018/a-dive-into-the-making-of-immersion/">in the first part</a>.</p>



<h2>Conclusion</h2>



<p>Mesh generation is arguably more difficult to design and more involved to implement than texture generation. When textures are just flat surfaces, meshes have different topologies, which adds a new layer of complexity.</p>



<p>But like with textures, the simplest building blocks can offer a wide range of possibilities to explore, as long as it’s possible to combine them in various ways. A few simple elements used creatively can give a wide range of shapes.</p>



<p>Moreover, as we’ve seen with at least two examples, the power of suggestion can play an important part and replace modeling work that would be tedious or even impossible to do with the available building blocks.</p>



<p>Using both of these observations can go a long way, as we hope to have demonstrated. The trick is to find the right balance between modeling work and expressiveness.</p>
					</div></div>
  </body>
</html>
