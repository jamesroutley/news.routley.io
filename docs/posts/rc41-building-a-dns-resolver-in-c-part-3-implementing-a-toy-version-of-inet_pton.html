<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.datadoodad.com/recurse%20center/RC41/">Original</a>
    <h1>RC41. Building a DNS Resolver in C, Part 3: Implementing a toy version of inet_pton()</h1>
    
    <div id="readability-page-1" class="page"><div>
      
        <header>
          
          

  <p>
    
      
      <span>
        <i aria-hidden="true"></i>
        
        <time datetime="2023-07-11T00:00:00-07:00">July 11, 2023</time>
      </span>
    

    <span></span>

    
      
      

      <span>
        <i aria-hidden="true"></i>
        
          3 minute read
        
      </span>
    
  </p>


        </header>
      

      <section itemprop="text">
        

        
        <p><i>Daily dispatches from my 12 weeks at the Recurse Center in Summer 2023
</i></p>
        
        <p>Last time on <a href="https://www.datadoodad.com/recurse%20center/RC39-5/">stumbling through building a DNS resolver in C</a>, I messed around with the nifty function <code>inet_pton()</code>, which takes IPv4 and IPv6 addresses and converts them from <strong>P</strong>resentation to <strong>N</strong>etwork format, which is to say from a human-friendly format like <code>31.13.70.36</code> to a machine-friendly 32-bit integer like <code>520963620</code>. Along the way we discovered the hazards of endian-ness and learned our lesson: never, ever don’t convert numbers from host-to-network byte order and back!</p>

<p>That goes for port numbers, too, by the way. Want to make a DNS query on port 53? Don’t forget to first convert it with <code>htons(53)</code>! Otherwise, if you’re on an Intel machine, you’ll end up querying port 13563. Why? 53 in hex is 0x35, so you’d think a two-byte integer would render that value as 0x0035. And you’d be right if you’re thinking the way networks think! But Intel machines are eccentric and little-endian, and they would store that integer as 0x3500 (least significant byte first), which would be interpreted as 13563 by big-endian machines and networks. So, do your conversions, folks!</p>

<p>One of the things I did since then, in any case, is flesh out a toy version of <code>inet_pton()</code>, which does the full conversion from an IPv4 address to a 32-bit integer in a REPL-style interface.</p>

<p><img src="https://www.datadoodad.com/assets/images/RC41_ipv4_to_i.gif" alt="IPv4 to int"/></p>

<p>The little program isn’t that complicated, but, well, it’s in C, so the whole thing felt like a bunch of LeetCode problems. (That’s a compliment.)</p>

<p>Here’s the full code:</p>

<div><div><pre><code><span>#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;
</span>
<span>int</span> <span>main</span><span>()</span>
<span>{</span>
    <span>char</span> <span>c</span><span>,</span> <span>chunk</span><span>[</span><span>4</span><span>];</span>
    <span>int</span> <span>i</span><span>,</span> <span>chunk_as_i</span><span>,</span> <span>chunks_count</span><span>;</span>
    <span>uint32_t</span> <span>addr</span><span>;</span>

    <span>i</span> <span>=</span> <span>0</span><span>;</span>
    <span>addr</span> <span>=</span> <span>0</span><span>;</span>
    <span>chunks_count</span> <span>=</span> <span>0</span><span>;</span>

    <span>while</span> <span>((</span><span>c</span> <span>=</span> <span>getchar</span><span>())</span> <span>!=</span> <span>EOF</span><span>)</span>
    <span>{</span>

        <span>/* convert chunk to int if we reach a `.` or `\n` */</span>
        <span>if</span> <span>(</span><span>c</span> <span>==</span> <span>&#39;.&#39;</span> <span>||</span> <span>c</span> <span>==</span> <span>&#39;\n&#39;</span><span>)</span> <span>{</span>
            <span>chunk</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>&#39;\0&#39;</span><span>;</span>            <span>// append null to chunk</span>
            <span>addr</span> <span>&lt;&lt;=</span> <span>8</span><span>;</span>                 <span>// shift addr 8 bits left</span>
            <span>chunk_as_i</span> <span>=</span> <span>atoi</span><span>(</span><span>chunk</span><span>);</span>   <span>// convert current chunk to int</span>
            <span>if</span> <span>(</span><span>chunk_as_i</span> <span>&gt;</span> <span>255</span><span>)</span> <span>{</span>     <span>// exit on invalid chunk</span>
                <span>printf</span><span>(</span><span>&#34;Invalid IPv4 address component: %s</span><span>\n</span><span>&#34;</span><span>,</span> <span>chunk</span><span>);</span>
                <span>return</span> <span>1</span><span>;</span>
            <span>}</span>
            <span>addr</span> <span>|=</span> <span>atoi</span><span>(</span><span>chunk</span><span>);</span>        <span>// add chunk to addr</span>

            <span>// reset chunk</span>
            <span>for</span> <span>(;</span> <span>i</span><span>&gt;</span><span>0</span><span>;</span> <span>--</span><span>i</span><span>)</span> <span>{</span> <span>chunk</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>&#39;\0&#39;</span><span>;</span> <span>}</span>

            <span>// inc chunks_count</span>
            <span>chunks_count</span><span>++</span><span>;</span>

            <span>// output addr and reset on newline</span>
            <span>if</span> <span>(</span><span>c</span> <span>==</span> <span>&#39;\n&#39;</span><span>)</span> <span>{</span>
                <span>if</span> <span>(</span><span>chunks_count</span> <span>==</span> <span>4</span><span>)</span> <span>{</span>
                    <span>printf</span><span>(</span><span>&#34;%u</span><span>\n</span><span>&#34;</span><span>,</span> <span>addr</span><span>);</span>
                <span>}</span> <span>else</span> <span>{</span>
                    <span>printf</span><span>(</span><span>&#34;Unexpected IPv4 address format &#34;</span><span>);</span>
                    <span>for</span> <span>(</span><span>int</span> <span>j</span><span>=</span><span>1</span><span>;</span> <span>j</span><span>&lt;</span><span>chunks_count</span><span>;</span> <span>++</span><span>j</span><span>)</span>
                        <span>printf</span><span>(</span><span>&#34;x.&#34;</span><span>);</span>
                    <span>printf</span><span>(</span><span>&#34;x</span><span>\n</span><span>&#34;</span><span>);</span>
                    <span>return</span> <span>1</span><span>;</span>
                <span>}</span>
                <span>chunks_count</span> <span>=</span> <span>0</span><span>;</span>
                <span>addr</span> <span>=</span> <span>0</span><span>;</span>
            <span>}</span>

        <span>/* else append char to chunk if numeric */</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>i</span> <span>&lt;</span> <span>3</span> <span>&amp;&amp;</span> <span>c</span> <span>&gt;=</span> <span>&#39;0&#39;</span> <span>&amp;&amp;</span> <span>c</span> <span>&lt;=</span> <span>&#39;9&#39;</span><span>){</span>
            <span>chunk</span><span>[</span><span>i</span><span>++</span><span>]</span> <span>=</span> <span>c</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>There’s plenty of room for refactoring here, and probably error-detection and handling could be better, and, well, probably a lot could be better. But there are a few things that I think are especially neat that I’m psyched about.</p>

<p>The first is the decision not to read in an entire line at a time (i.e., up until a newline is detected), but to read in what I’m calling here a chunk at a time, meaning the parts of the IPv4 address between dots. So I’ve got <code>chunk</code>, a little array of chars of length 4 (the extra space being for a newline character so that I can easily treat the variable like a string), and as I traverse the input stream, I add the numeric characters I encounter to consecutive indexes. When I encounter a dot or a newline character, though, it’s time to rock and roll.</p>

<p>If it’s a dot, then that means we have a chunk to deal with, which leads us to my second innovation (which actaully I borrowed from a helpful recurser who was perplexed by my previous decision to work with bitstrings representing this 32-bit integer): the bitwise approach, of course! We shift <code>addr</code>, our output variable, 8 bits left and <code>OR</code> it with the integer value of the current chunk (once we ensure that it’s a valid one-byte value, that is). Then we reset <code>chunk</code> and our incrementer in one fell swoop, and continue along our input stream.</p>

<p>That just leaves the output. If we encounter a newline character, that means (in theory) that we’re finished and it’s time to print out <code>addr</code>. Once we make sure that there are, indeed, 4 chunks as expected, then, yeah, let ‘er rip! Otherwise, something ain’t right. ABORT PROGRAM.</p>

<p><img src="https://www.datadoodad.com/assets/images/RC41_hal.gif" alt="Bye HAL" width="100%"/></p>

<p>And that, ladies and gentlemen, is what reinventing the wheel, in a much worse and more brittle way, looks like.</p>


          

        

        
      </section>

      

      

      
  

    </div></div>
  </body>
</html>
