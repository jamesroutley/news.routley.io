<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://superfastpython.com/python-concurrency-choose-api/">Original</a>
    <h1>How to Choose the Right Python Concurrency API</h1>
    
    <div id="readability-page-1" class="page"><div><div><main id="genesis-content"><article class="page" aria-label="Choose the Right Python Concurrency API" itemscope="" itemtype="https://schema.org/CreativeWork"><div itemprop="text">




<p>Python standard library offers 3 concurrency APIs.</p>



<p><strong>How do you know which API to use in your project?</strong></p>



<p>In this tutorial you will discover helpful step-by-step procedure and helpful questions to guide you to the most appropriate concurrency API.</p>



<p>After reading this guide, you will also know how to choose the right Python concurrency API for current and future projects.</p>



<p>Let’s get started.</p>




<h2><span id="Problem_of_Pythons_Concurrency_APIs"></span>Problem of Python’s Concurrency APIs<span></span></h2>



<p>The Python standard library (stdlib) offers three ways to execute tasks conucrrently in your programs.</p>



<p>They are the <strong>multiprocessing</strong> module for process-based concurrency, <strong>threading</strong> module for thread-based concurrency, and the <strong>asyncio</strong> module for coroutine-based concurrency.</p>



<p>The abundance of choice makes it confusing.</p>



<p><strong>It’s worse than you think</strong>:</p>



<ul><li>For example, after choosing a module, should you use a pool of workers or should you code up the concurrent task yourself? </li><li>If you choose a pool of workers, you should use the Pools API or the Executors API.</li></ul>



<p>Even experienced Python developers are baffled by the options.</p>



<p><strong>Which Python concurrency API should you use for your project?</strong></p>



<p>You need rules of thumb to guide you to the most appropriate concurrency API.</p>



<p>Before we look at a handy procedure for choosing, let’s take a closer look at the problem and structure it carefully.</p>



<h2><span id="Which_Python_Concurrency_API_Should_You_Use"></span>Which Python Concurrency API Should You Use?<span></span></h2>



<p>You want to use concurrency in your Python program.</p>



<p><strong>There’s just one problem. Which API should you use?</strong></p>



<p>You’re not alone. This is perhaps one of the most common questions I receive.</p>



<p>Firstly, there are three main Python concurrency APIs, they are:</p>



<ul><li><strong>Coroutine-based</strong>, provided by the “<em>asyncio</em>” module.</li><li><strong>Thread-based</strong>, provided by the “<em>threading</em>” module.</li><li><strong>Process-based</strong>, provided by the “<em>multiprocessing</em>” module.</li></ul>



<p>Choosing among these three is relatively straightforward. I’ll show you how in the next section.</p>



<p>The problem is, there are further decisions to make.</p>



<p>You will need to consider whether you should use a pool of reusable workers or not.</p>



<p>For example:</p>



<ul><li>If you decide you need thread-based concurrency, should you use a thread pool or use the <strong>Thread</strong> class in some way?</li><li>If you decide you need process-based concurrency, should you use a process pool or use the <strong>Process</strong> class in some way.</li></ul>



<p>Then, if you decide to use reusable workers for concurrency, you have multiple options to choose from.</p>



<p>For example:</p>



<ul><li>If you decide you need a thread pool, should you use the <strong>ThreadPool</strong> class or the <strong>ThreadPoolExecutor</strong>?</li><li>If you decide you need a process pool, should you use the <strong>Pool</strong> class or the <strong>ProcessPoolExecutor</strong>?</li></ul>



<p>The below figure summarizes these decision points.</p>



<figure><a href="https://i0.wp.com/superfastpython.com/wp-content/uploads/2022/07/Python-Concurrency-API-Choice.jpg?ssl=1"><img width="888" height="579" src="https://i0.wp.com/superfastpython.com/wp-content/uploads/2022/07/Python-Concurrency-API-Choice.jpg?resize=888%2C579&amp;ssl=1" alt="Python Concurrency API Choice" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/superfastpython.com/wp-content/uploads/2022/07/Python-Concurrency-API-Choice.jpg?w=888&amp;ssl=1 888w, https://i0.wp.com/superfastpython.com/wp-content/uploads/2022/07/Python-Concurrency-API-Choice.jpg?resize=300%2C196&amp;ssl=1 300w, https://i0.wp.com/superfastpython.com/wp-content/uploads/2022/07/Python-Concurrency-API-Choice.jpg?resize=768%2C501&amp;ssl=1 768w" data-lazy-sizes="(max-width: 888px) 100vw, 888px" data-lazy-src="https://i0.wp.com/superfastpython.com/wp-content/uploads/2022/07/Python-Concurrency-API-Choice.jpg?resize=888%2C579&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a><figcaption>Python Concurrency API Choice (click to enlarge)</figcaption></figure>



<p>How do you figure all of this out?</p>



<p><strong>How do you choose a Python concurrency API for your project?</strong></p>



<h2><span id="Process_to_Choose_a_Python_Concurrency_API"></span>Process to Choose a Python Concurrency API<span></span></h2>



<p>One approach you can use, that is perhaps the most common, is to choose one API in an ad hoc manner.</p>



<p>Many development decisions are made this way and your program will probably work fine.</p>



<p>But maybe it won’t.</p>



<p>I recommend a 3 step process when choosing the right Python concurrency API for your project.</p>



<p>The steps are as follows:</p>



<ol><li><strong>Step 1</strong>: CPU-Bound vs IO-Bound (Multiprocessing vs Threading)<ol><li><strong>Step 1.1</strong> Choosing Between AsyncIO and Threading</li></ol></li><li><strong>Step 2</strong>: Many Ad Hoc Tasks vs One Complex Task?</li><li><strong>Step 3</strong>: Pools vs Executors?</li></ol>



<p>I have also distilled the decisions into a handy picture, as follows:</p>



<figure><a href="https://i0.wp.com/superfastpython.com/wp-content/uploads/2022/07/Python-Concurrency-API-Decision-Tree.jpg?ssl=1"><img width="960" height="720" src="https://i0.wp.com/superfastpython.com/wp-content/uploads/2022/07/Python-Concurrency-API-Decision-Tree.jpg?resize=960%2C720&amp;ssl=1" alt="Python Concurrency API Decision Tree" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/superfastpython.com/wp-content/uploads/2022/07/Python-Concurrency-API-Decision-Tree.jpg?w=960&amp;ssl=1 960w, https://i0.wp.com/superfastpython.com/wp-content/uploads/2022/07/Python-Concurrency-API-Decision-Tree.jpg?resize=300%2C225&amp;ssl=1 300w, https://i0.wp.com/superfastpython.com/wp-content/uploads/2022/07/Python-Concurrency-API-Decision-Tree.jpg?resize=768%2C576&amp;ssl=1 768w" data-lazy-sizes="(max-width: 960px) 100vw, 960px" data-lazy-src="https://i0.wp.com/superfastpython.com/wp-content/uploads/2022/07/Python-Concurrency-API-Decision-Tree.jpg?resize=960%2C720&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a><figcaption>Python Concurrency API Decision Tree (click to enlarge)</figcaption></figure>



<p>Next, let’s take a closer look at each step and add some nuance.</p>



<h2><span id="Step_1_CPU-Bound_vs_IO-Bound_Tasks"></span>Step 1: CPU-Bound vs IO-Bound Tasks?<span></span></h2>



<p>The first step in choosing the Python concurrency API to use is to think about the limiting factor of the task or tasks you want to execute.</p>



<p>Are the tasks mostly CPU-bound or IO-bound?</p>



<p>If you get this part right, the other decisions you need to make are less important.</p>



<p>Let’s take a closer look at each in turn.</p>



<h3>CPU-Bound Tasks</h3>



<p>A CPU-bound task is a type of task that involves performing a computation and does not involve IO.</p>



<p>The operations only involve data in main memory and performing computations on or with that data.</p>



<p>As such, the limit on these operations is the speed of the CPU. This is why we call them CPU-bound tasks.</p>



<p>Examples include:</p>



<ul><li>Calculating points in a fractal.</li><li>Estimating Pi</li><li>Factoring primes.</li><li>Parsing HTML, JSON, etc. documents.</li><li>Processing text.</li><li>Running simulations.</li></ul>



<p>CPUs are very fast and we often have more than one CPU. We would like to perform our tasks and make full use of multiple CPU cores in modern hardware.</p>



<p>Now that we are familiar with CPU-bound tasks, let’s take a closer look at IO-bound tasks.</p>



<h3>IO-Bound Tasks</h3>



<p>An IO-bound task is a type of task that involves reading from or writing to a device, file, or socket connection.</p>



<p>The operations involve input and output (IO), and the speed of these operations is bound by the device, hard drive, or network connection. This is why these tasks are referred to as IO-bound.</p>



<p>CPUs are really fast. Modern CPUs, like a 4GHz, can execute 4 billion instructions per second, and you likely have more than one CPU in your system.</p>



<p>Doing IO is very slow compared to the speed of CPUs.</p>



<p>Interacting with devices, reading and writing files, and socket connections involve calling instructions in your operating system (the kernel), which will wait for the operation to complete. If this operation is the main focus for your CPU, such as executing in the main thread of your Python program, then your CPU is going to wait many milliseconds, or even many seconds, doing nothing.</p>



<p>That is potentially billions of operations that it is prevented from executing.</p>



<p>Examples of IO-bound tasks include:</p>



<ul><li>Reading or writing a file from the hard drive.</li><li>Reading or writing to standard output, input, or error (stdin, stdout, stderr).</li><li>Printing a document.</li><li>Downloading or uploading a file.</li><li>Querying a server.</li><li>Querying a database.</li><li>Taking a photo or recording a video.</li><li>And so much more.</li></ul>



<p>Now that we are familiar with both CPU-bound and IO-bound tasks, let’s consider the types of Python concurrency APIs we should use.</p>



<h3>Choose Python Concurrency API</h3>



<p>Recall that the multiprocessing module provides process-based concurrency and the threading module provides thread-based concurrency within a process.</p>



<p>Generally, you should use process-based concurrency if you have a CPU-bound task and thread-based concurrency if you have an IO-bound task.</p>



<ul><li><strong>CPU-Bound Tasks</strong>: Use the “<strong>multiprocessing</strong>” module for process-based concurrency.</li><li><strong>IO-Bound Tasks</strong>: Use the “<strong>threading</strong>” module for thread-based concurrency.</li></ul>



<p>The multiprocessing module is suitable for tasks that focus on computing or calculating something with relatively little data shared between tasks. Multiprocessing is not suitable for tasks that send or receive a lot of data with other processes because of the computational overhead added because all data shared between processes must be serialized.</p>



<p>You would execute one task per logical CPU core or one per physical CPU core and maximize the capabilities of the underlying hardware.</p>



<p>The threading module is suitable for tasks that focus on reading or writing from an IO device with relatively little calculation. Threading is not suitable for tasks that perform a lot of CPU computation as the Global Interpreter Lock (GIL) prevents more than one Python thread from executing at a time. The GIL is generally only released when performing blocking operations, like IO, or specifically in some third-party C libraries, such as NumPy.</p>



<p>You can execute tens, hundreds, or thousands of thread-based tasks to maximize the capabilities of the underlying hardware as IO spends most of the time waiting.</p>



<p>The following figure summarizes the decision point in choosing between the threading module for thread-based concurrency or the multiprocessing module for process-based concurrency.</p>



<figure><a href="https://i0.wp.com/superfastpython.com/wp-content/uploads/2022/07/Python-Concurrency-API-threading-vs-multiprocessing.jpg?ssl=1"><img width="960" height="720" src="https://i0.wp.com/superfastpython.com/wp-content/uploads/2022/07/Python-Concurrency-API-threading-vs-multiprocessing.jpg?resize=960%2C720&amp;ssl=1" alt="Python Concurrency API threading vs multiprocessing" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/superfastpython.com/wp-content/uploads/2022/07/Python-Concurrency-API-threading-vs-multiprocessing.jpg?w=960&amp;ssl=1 960w, https://i0.wp.com/superfastpython.com/wp-content/uploads/2022/07/Python-Concurrency-API-threading-vs-multiprocessing.jpg?resize=300%2C225&amp;ssl=1 300w, https://i0.wp.com/superfastpython.com/wp-content/uploads/2022/07/Python-Concurrency-API-threading-vs-multiprocessing.jpg?resize=768%2C576&amp;ssl=1 768w" data-lazy-sizes="(max-width: 960px) 100vw, 960px" data-lazy-src="https://i0.wp.com/superfastpython.com/wp-content/uploads/2022/07/Python-Concurrency-API-threading-vs-multiprocessing.jpg?resize=960%2C720&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a><figcaption>Python Concurrency API threading vs multiprocessing (click to enlarge)</figcaption></figure>



<p>You can learn more about choosing between using a <strong>Thread</strong> and using a <strong>Process</strong> in the tutorials:</p>



<ul><li><a href="https://superfastpython.com/thread-vs-process/">Thread vs Process in Python</a></li><li><a href="https://superfastpython.com/why-not-always-use-processes-in-python/" data-type="post" data-id="1677">Why Not Always Use Processes in Python</a></li><li><a href="https://superfastpython.com/multiprocessing-in-python/">Python Multiprocessing Complete Guide</a></li><li><a href="https://superfastpython.com/threading-in-python/">Python Threading Complete Guide</a></li></ul>



<p>Next, let’s consider if AsyncIO is appropriate.</p>



<h3>Step 1.1 Choosing Between Threading and AsyncIO</h3>



<p>If your tasks are mostly IO-bound, you have another decision point.</p>



<p>You must choose between using the “<strong>threading</strong>” module and using the “<strong>asyncio</strong>” module.</p>



<p>Recall that the threading module provides thread-based concurrency and the asyncio module provides coroutine-based concurrency within a thread.</p>



<p>Generally, you should use coroutine-based concurrency if you have many socket connections (or prefer asynchronous programming), and thread-based concurrency otherwise.</p>



<ul><li><strong>Many Socket-Connections</strong>: Use the “<strong>asyncio</strong>” module for coroutine-based concurrency.</li><li><strong>Otherwise</strong>: Use the “<strong>threading</strong>” module for thread-based concurrency.</li></ul>



<p>The asyncio module focuses on concurrent non-blocking IO for socket connections. For example, if your IO tasks are file-based, then asyncio would not be an appropriate choice, at least for this reason alone.</p>



<p>The rationale is that coroutines are more lightweight than threads, therefore a single thread may host many more coroutines than a process may manage threads. For example, asyncio may allow thousands, tens of thousands or more coroutines for socket-based IO as opposed to hundreds to low thousands of threads in the threading API.</p>



<p>Another consideration is that you may want or need to use an asynchronous programming paradigm in developing your program, e.g. async/wait. Therefore this requirement would override any requirements imposed by the tasks.</p>



<p>Similarly, you may have an aversion to the asynchronous programming paradigm and therefore this preference would override any requirements imposed by the tasks.</p>



<p>For more on the differences between asyncio and thread-based concurrency, see the tutorial:</p>



<ul><li><a href="https://superfastpython.com/threadpoolexecutor-vs-asyncio/">ThreadPoolExecutor vs. AsyncIO in Python</a></li></ul>



<h2><span id="Step_2_Many_Ad_Hoc_Tasks_vs_One_Complex_Task"></span>Step 2: Many Ad Hoc Tasks vs One Complex Task?<span></span></h2>



<p>The second step is to consider if you need to execute independent ad hoc tasks or a large complex task.</p>



<p>What we are thinking about at this decision point is whether you need to issue one or many ad hoc tasks that may benefit from a pool of reusable workers. Otherwise, whether you need a single task where a pool of reusable workers would be overkill.</p>



<p>Another way to think about it is whether you have one or a few different but complex tasks like monitors, schedulers or similar that might live for a long time, such as the duration of the program. These would not be ad hoc tasks, and may not benefit from a reusable pool of workers.</p>



<ul><li><strong>Shorter-lived and/or many ad hoc</strong> : Use a thread or process pool.</li><li><strong>Longer-lived and/or complex tasks</strong>: Use the <strong>Thread</strong> or <strong>Process</strong> class.</li></ul>



<p>In the case where you have chosen thread-based concurrency the choice is between a thread pool or using the Thread class.</p>



<p>In the case where you have chosen process-based concurrency, the choice is between a process pool or using the Process class.</p>



<p>Some additional considerations include:</p>



<ul><li><strong>Heterogeneous vs. Homogeneous Tasks</strong>: A pool is perhaps more appropriate for a diverse set of tasks (heterogeneous) whereas a Process/Thread class is appropriate for one type of task (homogeneous).</li><li><strong>Reuse vs. Single Use</strong>: A pool is appropriate for reusing the basis of concurrency, e.g. reusing a thread or a process for many tasks, whereas a Process/Thread class is appropriate for a single use task, perhaps a long lived one.</li><li><strong>Multiple Tasks vs. Single Task</strong>: A pool naturally supports many tasks, perhaps issued in many ways, whereas a Process/Thread class only supports one type of task, once configured or overridden.</li></ul>



<p>To make this more concrete, let’s consider some examples:</p>



<ul><li>A for-loop that calls a function many times with different arguments each iteration may be appropriate for a thread pool as workers can be reused for each task automatically as needed.</li><li>A background task that monitors a resource may be appropriate for a Thread/Process class as it is a long-running single task and may have a lot of complex and specialized functionality perhaps spread across many function calls.</li><li>A script that downloads many files would be appropriate for a pool of workers as each task is short in duration and there may be many more files than there are workers, allowing reuse of workers and queuing of tasks to complete.</li><li>A one-off task that maintains internal state and interacts with the main program may be appropriate for Thread/Process class as the class can be overridden to use instance variables for state and methods for modular functionality.</li></ul>



<p>The figure below may help choose between using a pool of workers vs a <strong>Thread</strong> or <strong>Process</strong> class.</p>



<figure><a href="https://i0.wp.com/superfastpython.com/wp-content/uploads/2022/07/Python-Concurrency-API-Worker-Pool-vs-Class.png?ssl=1"><img width="960" height="720" src="https://i0.wp.com/superfastpython.com/wp-content/uploads/2022/07/Python-Concurrency-API-Worker-Pool-vs-Class.png?resize=960%2C720&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/superfastpython.com/wp-content/uploads/2022/07/Python-Concurrency-API-Worker-Pool-vs-Class.png?w=960&amp;ssl=1 960w, https://i0.wp.com/superfastpython.com/wp-content/uploads/2022/07/Python-Concurrency-API-Worker-Pool-vs-Class.png?resize=300%2C225&amp;ssl=1 300w, https://i0.wp.com/superfastpython.com/wp-content/uploads/2022/07/Python-Concurrency-API-Worker-Pool-vs-Class.png?resize=768%2C576&amp;ssl=1 768w" data-lazy-sizes="(max-width: 960px) 100vw, 960px" data-lazy-src="https://i0.wp.com/superfastpython.com/wp-content/uploads/2022/07/Python-Concurrency-API-Worker-Pool-vs-Class.png?resize=960%2C720&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a><figcaption>Python Concurrency API Worker Pool vs Class (click to enlarge)</figcaption></figure>



<p>For more on pools of workers vs one complex task, see:</p>



<ul><li><a href="https://superfastpython.com/threadpoolexecutor-vs-threads/">ThreadPoolExecutor vs. Thread in Python</a></li><li><a href="https://superfastpython.com/multiprocessing-pool-vs-process/">Multiprocessing Pool vs Process in Python</a></li></ul>



<p>Next, let’s consider the type of pool that might be considered.</p>



<h2><span id="Step_3_Pools_vs_Executors"></span>Step 3: Pools vs Executors?<span></span></h2>



<p>The third step is to consider the type of worker pool to use.</p>



<p>There are two main types, they are:</p>



<ul><li><strong>Pool</strong>: <strong>multiprocessing.pool.Pool</strong> and the port of the class to support threads in <strong>multiprocessing.pool.ThreadPool</strong>.</li><li><strong>Executors</strong>: The <strong>concurrent.futures.Executor</strong> class and two sub-classes <strong>ThreadPoolExecutor</strong> and <strong>ProcessPoolExecutor</strong>.</li></ul>



<p>Both provide pools of workers. The similarities are many and the differences are few and subtle.</p>



<p>For example, the similarities are:</p>



<ul><li>Both have thread- and Process-based versions.</li><li>Both can execute ad hoc tasks.</li><li>Both support synchronous and asynchronous task execution.</li><li>Both provide support for checking the status and waiting for asynchronous tasks.</li><li>Both support callback functions for asynchronous tasks.</li></ul>



<p>Choosing one over the other will not make a big impact on your program.</p>



<p>The main difference is in the API offered by each, specifically minor differences in focus or in how tasks are handled.</p>



<p>For example:</p>



<ul><li>Executors provide the ability to cancel issued tasks, whereas the Pool does not.</li><li>Executors provide the ability to work with collections of heterogeneous tasks, whereas the Pool does not.</li><li>Executors do not provide the ability to forcefully terminate all tasks, whereas the Pool does.</li><li>Executors do not provide multiple parallel versions of the <strong>map()</strong> function, whereas the Pool does.</li><li>Executors provide the ability to access an exception raised in a task, whereas the Pool does not.</li></ul>



<p>The difference between these pools that I think matter is that the Pool is focused on concurrent for-loops with many different versions of the <strong>map()</strong> function, e.g. apply a function each argument in an iterable.</p>



<p>The Executors have this capability but the focus is more on issuing ad hoc tasks asynchronously and managing the collection of tasks.</p>



<p>The figure below helps to summarize the differences between pools and executors</p>



<figure><a href="https://i0.wp.com/superfastpython.com/wp-content/uploads/2022/07/Python-Concurrency-API-Pools-vs-Executors.png?ssl=1"><img width="613" height="722" src="https://i0.wp.com/superfastpython.com/wp-content/uploads/2022/07/Python-Concurrency-API-Pools-vs-Executors.png?resize=613%2C722&amp;ssl=1" alt="Python Concurrency API Pools vs Executors" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/superfastpython.com/wp-content/uploads/2022/07/Python-Concurrency-API-Pools-vs-Executors.png?w=613&amp;ssl=1 613w, https://i0.wp.com/superfastpython.com/wp-content/uploads/2022/07/Python-Concurrency-API-Pools-vs-Executors.png?resize=255%2C300&amp;ssl=1 255w" data-lazy-sizes="(max-width: 613px) 100vw, 613px" data-lazy-src="https://i0.wp.com/superfastpython.com/wp-content/uploads/2022/07/Python-Concurrency-API-Pools-vs-Executors.png?resize=613%2C722&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a><figcaption>Python Concurrency API Pools vs Executors (click to enlarge)</figcaption></figure>



<p>For more on Pools vs Executors see:</p>



<ul><li><a href="https://superfastpython.com/multiprocessing-pool-vs-processpoolexecutor/">Multiprocessing Pool vs ProcessPoolExecutor in Python</a></li></ul>



<h2><span id="Takeaways"></span>Takeaways<span></span></h2>



<p>You now know how to choose between the different Python concurrency APIs</p>



<p><strong>Did this guide help?</strong></p>



<p><strong>Do you have any questions?</strong></p>
</div></article></main></div></div></div>
  </body>
</html>
