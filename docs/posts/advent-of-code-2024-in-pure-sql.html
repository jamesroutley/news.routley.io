<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://databasearchitects.blogspot.com/2024/12/advent-of-code-2024-in-pure-sql.html">Original</a>
    <h1>Advent of Code 2024 in pure SQL</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-7330506685859612652" itemprop="description articleBody">
<p> On a whim I decided to do this years <a href="https://adventofcode.com/2024">advent of code</a> in pure SQL. That was an interesting experience that I can recommend to everybody because it forces you to think differently about the problems. And I can report that <a href="https://github.com/neumannt/aoc24">it was possible to solve every problem in pure SQL</a>.</p><p>In many cases SQL was actually surprisingly pleasant to use. The full solution for day 11 (including the puzzle input) is shown below:</p>
<!--HTML generated using hilite.me--><div><table><tbody><tr><td><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre></td><td><pre><span>with</span> <span>recursive</span> aoc10_input(i) <span>as</span> (<span>select</span> <span>&#39;</span>
<span>89010123</span>
<span>78121874</span>
<span>87430965</span>
<span>96549874</span>
<span>45678903</span>
<span>32019012</span>
<span>01329801</span>
<span>10456732</span>
<span>&#39;</span>),
lines(y,line) <span>as</span> (
   <span>select</span> <span>0</span>, substr(i,<span>1</span>,<span>position</span>(E<span>&#39;\n&#39;</span> <span>in</span> i)<span>-</span><span>1</span>), substr(i,<span>position</span>(E<span>&#39;\n&#39;</span> <span>in</span> i)<span>+</span><span>1</span>)
   <span>from</span> aoc10_input
   <span>union</span> <span>all</span>
   <span>select</span> y<span>+</span><span>1</span>,substr(r,<span>1</span>,<span>position</span>(E<span>&#39;\n&#39;</span> <span>in</span> r)<span>-</span><span>1</span>), substr(r,<span>position</span>(E<span>&#39;\n&#39;</span> <span>in</span> r)<span>+</span><span>1</span>)
   <span>from</span> lines l(y,l,r) <span>where</span> <span>position</span>(E<span>&#39;\n&#39;</span> <span>in</span> r)<span>&gt;</span><span>0</span>
),
field(x,y,v) <span>as</span> (
   <span>select</span> x,y,ascii(substr(line,x::<span>integer</span>,<span>1</span>))<span>-</span><span>48</span>
   <span>from</span> (<span>select</span> <span>*</span> <span>from</span> lines l <span>where</span> line<span>&lt;&gt;</span><span>&#39;&#39;</span>) s, <span>lateral</span> generate_series(<span>1</span>,<span>length</span>(line)) <span>g</span>(x)
),
paths(x,y,v,sx,sy) <span>as</span> (
   <span>select</span> x,y,<span>9</span>,x,y <span>from</span> field <span>where</span> v <span>=</span> <span>9</span>
   <span>union</span> <span>all</span>
   <span>select</span> f.x,f.y,f.v,p.sx,p.sy
   <span>from</span> field f, paths p
   <span>where</span> f.v<span>=</span>p.v<span>-</span><span>1</span> <span>and</span> ((f.x<span>=</span>p.x <span>and</span> <span>abs</span>(f.y<span>-</span>p.y)<span>=</span><span>1</span>) <span>or</span> (f.y<span>=</span>p.y <span>and</span> <span>abs</span>(f.x<span>-</span>p.x)<span>=</span><span>1</span>)) <span>and</span> p.v<span>&gt;</span><span>0</span>),
results <span>as</span> (<span>select</span> <span>*</span> <span>from</span> paths <span>where</span> v<span>=</span><span>0</span>),
part1 <span>as</span> (<span>select</span> <span>distinct</span> <span>*</span> <span>from</span> results)
<span>select</span> (<span>select</span> <span>count</span>(<span>*</span>) <span>from</span> part1)  <span>as</span> part1, (<span>select</span> <span>count</span>(<span>*</span>) <span>from</span> results) <span>as</span> part2
</pre></td></tr></tbody></table></div>


<p>Parsing the input is a bit painful in SQL, but it is not too bad. Lines 1-10 are simply the puzzle input, lines 11-17 split the input into individual lines, and lines 18-21 construct a 2D array from the input. The algorithm itself is pretty short, lines 22-27 perform a recursive traversal of the field, and lines 28-39 extract the puzzle answer from the traversal results. For this kind of small scale traversals SQL works just fine.</p><p>Other days were more painful. <a href="https://github.com/neumannt/aoc24/blob/master/day16.sql">Day 16</a> for example does conceptually a very similar traversal of a field, and it computes the minimal traversal distance for each visited. Expressing that in SQL in easy, but evaluation is wasteful. When replacing the reference input with a real puzzle input the field is quite large, and the recursive query generates and preserves a lot of state, even though we only care about the last iteration of the recursive query. As a consequence you need a machine with over 200GB memory to execute that query, even though most of the computed tuples are irrelevant. We could fix that excessive memory consumption by using <a href="https://www.cidrdb.org/cidr2023/papers/p14-hirn.pdf">iteration semantic</a> during recursion, but that is not widely supported by DBMSes. Umbra could do it, but Postgres and DuckDB cannot, thus I have not used it in my solutions.</p><p>And sometimes the programming model of recursive SQL clashes with what we want to do. On <a href="https://github.com/neumannt/aoc24/blob/master/day23.sql">day 23</a> we had to find the maximum clique in sparse graph. This can be computed reasonably well with the <a href="https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm">Bron-Kerbosch algorithm</a>, but expressing that in recursive SQL is quite convoluted because the algorithm wants to maintain multiple sets, but recursive SQL only passes a single set along. It can be done, but the result <a href="https://github.com/neumannt/aoc24/blob/218e93d12b477e694ab88e2c25c6070c28a6fbf4/day23.sql#L52">does not look pretty</a>.</p><p>This experiment has shown two things to me 1) it is possible to code quite complex algorithms in SQL, and often the SQL code is surprisingly pleasant, and 2) recursive SQL would be much more efficient and more pleasant to use if we had mechanisms to update state. There is <a href="https://www.cidrdb.org/cidr2025/papers.html">ongoing work</a> on supporting more complex control flow in recursion via a trampoline mechanisms, which is very useful, too, but we should definitively look into more complex state manipulation mechanisms. With just a bit extra functionality SQL would be quite a solid choice for running complex algorithms directly inside a database.<br/></p>

</div></div>
  </body>
</html>
