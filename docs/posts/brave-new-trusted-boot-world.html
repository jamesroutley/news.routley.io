<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://0pointer.net/blog/brave-new-trusted-boot-world.html">Original</a>
    <h1>Brave New Trusted Boot World</h1>
    
    <div id="readability-page-1" class="page"><div>
    
<p><em>This document looks at the boot process of general purpose Linux
distributions. It covers the status quo and how we envision Linux boot
to work in the future with a focus on robustness and simplicity.</em></p>
<p>This document will assume that the reader has comprehensive
familiarity with TPM 2.0 security chips and their capabilities (e.g.,
PCRs, measurements, SRK), boot loaders, the <code>shim</code> binary, Linux,
initrds, UEFI Firmware, PE binaries, and SecureBoot.</p>
<h2>Problem Description</h2>
<p>Status quo ante of the boot logic on typical Linux distributions:</p>
<ul>
<li>
<p>Most popular Linux distributions generate <code>initrds</code> locally, and
  they are unsigned, thus not protected through SecureBoot (since that
  would require local SecureBoot key enrollment, which is generally
  not done), nor TPM PCRs.</p>
</li>
<li>
<p>Boot chain is typically Firmware →
  <a href="https://github.com/rhboot/shim"><code>shim</code></a> → <code>grub</code> → Linux kernel →
  <code>initrd</code> (<code>dracut</code> or similar) → root file system</p>
</li>
<li>
<p>Firmware’s UEFI SecureBoot protects shim, shim’s key management
  protects grub and kernel. No code signing protects initrd. initrd
  acquires the key for encrypted root fs from the user (or
  TPM/FIDO2/PKCS11).</p>
</li>
<li>
<p><code>shim</code>/<code>grub</code>/kernel is measured into TPM PCR 4, among other stuff</p>
</li>
<li>
<p>EFI TPM event log reports measured data into TPM PCRs, and can be
  used to reconstruct and validate state of TPM PCRs from the used
  resources.</p>
</li>
<li>
<p>No userspace components are typically measured, except for what IMA
  measures</p>
</li>
<li>
<p>New kernels require locally generating new boot loader scripts and
  generating a new initrd each time. OS updates thus mean fragile
  generation of multiple resources and copying multiple files into the
  boot partition.</p>
</li>
</ul>
<p>Problems with the status quo ante:</p>
<ul>
<li>
<p>initrd typically unlocks root file system encryption, but is not
  protected <em>whatsoever</em>, and trivial to attack and modify offline</p>
</li>
<li>
<p>OS updates are brittle: PCR values of grub are very hard to
  pre-calculate, as grub measures chosen control flow path, not just
  code images. PCR values vary wildly, and OS provided resources are
  not measured into separate PCRs. Grub’s PCR measurements might be
  useful up to a point to reason about the boot after the fact, for
  the most basic remote attestation purposes, but useless for
  calculating them ahead of time during the OS build process (which
  would be desirable to be able to bind secrets to future expected PCR
  state, for example to bind secrets to an OS in a way that it remain
  accessible even after that OS is updated).</p>
</li>
<li>
<p>Updates of a boot loader are not robust, require multi-file updates
  of ESP and boot partition, and regeneration of boot scripts</p>
</li>
<li>
<p>No rollback protection (no way to cryptographically invalidate
  access to TPM-bound secrets on OS updates)</p>
</li>
<li>
<p>Remote attestation of running software is needlessly complex since
  initrds are generated locally and thus basically are guaranteed to
  vary on each system.</p>
</li>
<li>
<p>Locking resources maintained by arbitrary user apps to TPM state
  (PCRs) is not realistic for general purpose systems, since PCRs will
  change on every OS update, and there’s no mechanism to re-enroll
  each such resource before every OS update, and remove the old
  enrollment after the update.</p>
</li>
<li>
<p>There is no concept to cryptographically invalidate/revoke secrets
  for an older OS version once updated to a new OS version. An
  attacker thus can always access the secrets generated on old OSes if
  they manage to exploit an old version of the OS — even if a newer
  version already has been deployed.</p>
</li>
</ul>
<p>Goals of the new design:</p>
<ul>
<li>
<p>Provide a <strong>fully signed execution path</strong> from firmware to
  userspace, no exceptions</p>
</li>
<li>
<p>Provide a <strong>fully measured execution path</strong> from firmware to
  userspace, no exceptions</p>
</li>
<li>
<p><strong>Separate out TPM PCRs assignments</strong>, by “owner” of measured
  resources, so that resources can be bound to them in a fine-grained
  fashion.</p>
</li>
<li>
<p>Allow <strong>easy pre-calculation of expected PCR values</strong> based on
  booted kernel/initrd, configuration, local identity of the system</p>
</li>
<li>
<p><strong>Rollback protection</strong></p>
</li>
<li>
<p>Simple &amp; robust updates: <strong>one updated file per concept</strong></p>
</li>
<li>
<p><strong>Updates without requiring re-enrollment/local preparation</strong> of the
  TPM-protected resources (no more “brittle” PCR hashes that must be
  propagated into every TPM-protected resource on each OS update)</p>
</li>
<li>
<p>System ready for easy <strong>remote attestation</strong>, to prove validity of
  booted OS, configuration and local identity</p>
</li>
<li>
<p>Ability to <strong>bind secrets to specific phases of the boot</strong>, e.g. the
  root fs encryption key should be retrievable from the TPM only in
  the initrd, but not after the host transitioned into the root fs.</p>
</li>
<li>
<p>Reasonably <strong>secure, automatic, unattended unlocking</strong> of disk
  encryption secrets should be possible.</p>
</li>
<li>
<p>“Democratize” use of PCR policies by defining PCR register meanings,
  and making binding to them robust against updates, so that
  <strong>external projects</strong> can safely and securely bind their own data to
  them (or use them for remote attestation) without risking breakage
  whenever the OS is updated.</p>
</li>
<li>
<p>Build around <strong>TPM 2.0</strong> (with graceful fallback for TPM-less
  systems if desired, but TPM 1.2 support is out of scope)</p>
</li>
</ul>
<p>Considered attack scenarios and considerations:</p>
<ul>
<li>
<p>Evil Maid: neither online nor offline (i.e. “at rest”), physical
  access to a storage device should enable an attacker to read the
  user’s plaintext data on disk (confidentiality); neither online nor
  offline, physical access to a storage device should allow undetected
  modification/backdooring of user data or OS (integrity), or
  exfiltration of secrets.</p>
</li>
<li>
<p>TPMs are assumed to be reasonably “secure”, i.e. can securely
  store/encrypt secrets. Communication to TPM is not “secure” though
  and must be protected on the wire.</p>
</li>
<li>
<p>Similar, the CPU is assumed to be reasonably “secure”</p>
</li>
<li>
<p>SecureBoot is assumed to be reasonably “secure” to permit validated
  boot up to and including shim+boot loader+kernel (but see discussion
  below)</p>
</li>
<li>
<p>All user data must be encrypted <em>and</em> authenticated. All vendor and
  administrator data must be authenticated.</p>
</li>
<li>
<p>It is assumed all software involved regularly contains
  vulnerabilities and requires frequent updates to address them, plus
  regular revocation of old versions.</p>
</li>
<li>
<p>It is further assumed that key material used for signing code by the
  OS vendor can reasonably be kept secure (via use of HSM, and
  similar, where secret key information never leaves the signing
  hardware) and does <em>not</em> require frequent roll-over.</p>
</li>
</ul>
<h2>Proposed Construction</h2>
<p>Central to the proposed design is the concept of a <strong>Unified Kernel
Image (UKI)</strong>. These UKIs are the combination of a Linux kernel image,
and initrd, a UEFI boot stub program (and further resources, see
below) into one single UEFI PE file that can either be directly
invoked by the UEFI firmware (which is useful in particular in some
cloud/Confidential Computing environments) or through a boot loader
(which is generally useful to implement support for multiple kernel
versions, with interactive or automatic selection of image to boot
into, potentially with automatic fallback management to increase
robustness).</p>
<h2>UKI Components</h2>
<p>Specifically, UKIs typically consist of the following resources:</p>
<ol>
<li>
<p>An UEFI boot stub that is a small piece of code still running in
   UEFI mode and that transitions into the Linux kernel included in
   the UKI (e.g., as implemented in
   <a href="https://www.freedesktop.org/software/systemd/man/systemd-stub.html"><code>sd-stub</code></a>,
   see below)</p>
</li>
<li>
<p>The Linux kernel to boot in the <code>.linux</code> PE section</p>
</li>
<li>
<p>The initrd that the kernel shall unpack and invoke in the
   <code>.initrd</code> PE section</p>
</li>
<li>
<p>A kernel command line string, in the <code>.cmdline</code> PE
   section</p>
</li>
<li>
<p>Optionally, information describing the OS this kernel is intended
   for, in the <code>.osrel</code> PE section (derived from
   <code>/etc/os-release</code> of the booted OS). This is useful for
   presentation of the UKI in the boot loader menu, and ordering it
   against other entries, using the included version information.</p>
</li>
<li>
<p>Optionally, information describing kernel release information
   (i.e. <code>uname -r</code> output) in the <code>.uname</code> PE
   section. This is also useful for presentation of the UKI in the
   boot loader menu, and ordering it against other entries.</p>
</li>
<li>
<p>Optionally, a boot splash to bring to screen before transitioning
   into the Linux kernel in the <code>.splash</code> PE section</p>
</li>
<li>
<p>Optionally, a compiled Devicetree database file, for systems which
   need it, in the <code>.dtb</code> PE section</p>
</li>
<li>
<p>Optionally, the public key in PEM format that matches the
   signatures of the <code>.pcrsig</code> PE section (see below), in a
   <code>.pcrpkey</code> PE section.</p>
</li>
<li>
<p>Optionally, a JSON file encoding expected PCR 11 hash values seen
    from userspace once the UKI has booted up, along with signatures
    of these expected PCR 11 hash values, matching a specific public
    key in the <code>.pcrsig</code> PE section. (Note: we use plural
    for “values” and “signatures” here, as this JSON file will
    typically carry a separate value and signature for each PCR bank
    for PCR 11, i.e. one pair of value and signature for the SHA1
    bank, and another pair for the SHA256 bank, and so on. This
    ensures when enrolling or unlocking a TPM-bound secret we’ll
    always have a signature around matching the banks available
    locally (after all, which banks the local hardware supports is up
    to the hardware). For the sake of simplifying this already overly
    complex topic, we’ll pretend in the rest of the text there was
    only one PCR signature per UKI we have to care about, even if this
    is not actually the case.)</p>
</li>
</ol>
<p>Given UKIs are regular UEFI PE files, they can thus be signed as one
for SecureBoot, protecting all of the individual resources listed
above at once, and their combination. Standard Linux tools such as
<code>sbsigntool</code> and <code>pesign</code> can be used to sign
UKI files.</p>
<p>UKIs wrap all of the above data in a single file, hence all of the
above components can be updated in one go through single file atomic
updates, which is useful given that the primary expected storage place
for these UKIs is the UEFI System Partition (ESP), which is a vFAT
file system, with its limited data safety guarantees.</p>
<p>UKIs can be generated via a single, relatively simple objcopy
invocation, that glues the listed components together, generating one
PE binary that then can be signed for SecureBoot. (For details on
building these, see below.)</p>
<p>Note that the primary location to place UKIs in is the EFI System
Partition (or an otherwise firmware accessible file system). This
typically means a VFAT file system of some form. Hence an effective
UKI size limit of 4GiB is in place, as that’s the largest file size a
FAT32 file system supports.</p>
<h2>Basic UEFI Stub Execution Flow</h2>
<p>The mentioned UEFI stub program will execute the following operations
in UEFI mode before transitioning into the Linux kernel that is
included in its <code>.linux</code> PE section:</p>
<ol>
<li>
<p>The PE sections listed are searched for in the invoked UKI the stub
   is part of, and superficially validated (i.e. general file format is
   in order).</p>
</li>
<li>
<p>All PE sections listed above of the invoked UKI are measured into
   TPM PCR 11. This TPM PCR is expected to be all zeroes before the UKI
   initializes. Pre-calculation is thus very straight-forward if the
   resources included in the PE image are known. (Note: as a single
   exception the <code>.pcrsig</code> PE section is excluded from this measurement,
   as it is supposed to carry the expected result of the measurement, and
   thus cannot also be input to it, see below for further details about
   this section.)</p>
</li>
<li>
<p>If the <code>.splash</code> PE section is included in the UKI it is brought onto the screen</p>
</li>
<li>
<p>If the <code>.dtb</code> PE section is included in the UKI it is activated
   using the Devicetree UEFI “fix-up” protocol</p>
</li>
<li>
<p>If a command line was passed from the boot loader to the UKI
   executable it is discarded if SecureBoot is enabled and the command
   line from the <code>.cmdline</code> used. If SecureBoot is disabled and a
   command line was passed it is used in place of the one from
   <code>.cmdline</code>. Either way the used command line is measured into TPM
   PCR 12. (This of course removes any flexibility of control of the
   kernel command line of the local user. In many scenarios this is
   probably considered beneficial, but in others it is not, and some
   flexibility might be desired. Thus, this concept probably needs to
   be extended sooner or later, to allow more flexible kernel command
   line policies to be enforced via definitions embedded into the
   UKI. For example: allowing definition of multiple kernel command
   lines the user/boot menu can select one from; allowing additional
   allowlisted parameters to be specified; or even optionally allowing
   any verification of the kernel command line to be turned off even
   in SecureBoot mode. It would then be up to the builder of the UKI
   to decide on the policy of the kernel command line.)</p>
</li>
<li>
<p>It will set a couple of volatile EFI variables to inform userspace
   about executed TPM PCR measurements (and which PCR registers were
   used), and other execution properties. (For example: the EFI
   variable <code>StubPcrKernelImage</code> in the
   <code>4a67b082-0a4c-41cf-b6c7-440b29bb8c4f</code> vendor namespace indicates
   the PCR register used for the UKI measurement, i.e. the value
   “11”).</p>
</li>
<li>
<p>An initrd cpio archive is dynamically synthesized from the
   <code>.pcrsig</code> and <code>.pcrpkey</code> PE section data (this is later passed to
   the invoked Linux kernel as additional initrd, to be overlaid with
   the main initrd from the .initrd section). These files are later
   available in the <code>/.extra/</code> directory in the initrd context.</p>
</li>
<li>
<p>The Linux kernel from the <code>.linux</code> PE section is invoked with with
   a combined initrd that is composed from the blob from the <code>.initrd</code>
   PE section, the dynamically generated initrd containing the
   <code>.pcrsig</code> and <code>.pcrpkey</code> PE sections, and possibly some additional
   components like sysexts or syscfgs.</p>
</li>
</ol>
<h2>TPM PCR Assignments</h2>
<p>In the construction above we take possession of two PCR registers
previously unused on generic Linux distributions:</p>
<ul>
<li>
<p>TPM <strong>PCR 11</strong> shall contain measurements of all components of the
  UKI (with exception of the <code>.pcrsig</code> PE section, see above). This
  PCR will also contain measurements of the boot phase once userspace
  takes over (see below).</p>
</li>
<li>
<p>TPM <strong>PCR 12</strong> shall contain measurements of the used kernel command
  line. (Plus potentially other forms of
  parameterization/configuration passed into the UKI, not discussed in
  this document)</p>
</li>
</ul>
<p>On top of that we intend to define two more PCR registers like this:</p>
<ul>
<li>
<p>TPM <strong>PCR 15</strong> shall contain measurements of the volume encryption
  key of the root file system of the OS.</p>
</li>
<li>
<p>[TPM <strong>PCR 13</strong> shall contain measurements of additional extension
  images for the initrd, to enable a modularized initrd – not covered
  by this document]</p>
</li>
</ul>
<p>(See the <a href="https://uapi-group.org/specifications/docs/linux_tpm_pcr_registry/">Linux TPM PCR
Registry</a>
for an overview how these four PCRs fit into the list of Linux PCR
assignments.)</p>
<p>For all four PCRs the assumption is that they are zero before the UKI
initializes, and only the data that the UKI and the OS measure into
them is included. This makes pre-calculating them straightforward:
given a specific set of UKI components, it is immediately clear what
PCR values can be expected in PCR 11 once the UKI booted up. Given a
kernel command line (and other parameterization/configuration) it is
clear what PCR values are expected in PCR 12.</p>
<p>Note that these four PCRs are defined by the conceptual “owner” of the
resources measured into them. PCR 11 only contains resources the <strong>OS
vendor</strong> controls. Thus it is straight-forward for the OS vendor to
pre-calculate and then cryptographically sign the expected values for
PCR 11. The PCR 11 values will be identical on all systems that run
the same version of the UKI. PCR 12 only contains resources the
<strong>administrator</strong> controls, thus the administrator can pre-calculate
PCR values, and they will be correct on all instances of the OS that
use the same parameters/configuration. PCR 15 only contains resources
inherently local to the <strong>local system</strong>, i.e. the cryptographic key
material that encrypts the root file system of the OS.</p>
<p>Separating out these three roles does not imply these actually need to
be separate when used. However the assumption is that in many popular
environments these three roles should be separate.</p>
<p>By separating out these PCRs by the owner’s role, it becomes
straightforward to remotely attest, individually, on the software that
runs on a node (PCR 11), the configuration it uses (PCR 12) or the
identity of the system (PCR 15). Moreover, it becomes straightforward
to robustly and securely encrypt data so that it can only be unlocked
on a specific set of systems that share the same OS, or the same
configuration, or have a specific identity – or a combination thereof.</p>
<p>Note that the mentioned PCRs are so far not typically used on generic
Linux-based operating systems, to our knowledge. Windows uses them,
but given that Windows and Linux should typically not be included in
the same boot process this should be unproblematic, as Windows’ use of
these PCRs should thus not conflict with ours.</p>
<p>To summarize:</p>
<table>
  <tbody><tr>
   <th>PCR</th>
   <th>Purpose</th>
   <th>Owner</th>
   <th>Expected Value before UKI boot</th>
   <th>Pre-Calculable</th>
  </tr>
  <tr>
   <td><strong>11</strong></td>
   <td>Measurement of <strong>UKI components</strong> and <strong>boot phases</strong></td>
   <td>OS Vendor</td>
   <td>Zero</td>
   <td>Yes</td>
  </tr>
  <tr>
   <td><strong>12</strong></td>
   <td>Measurement of <strong>kernel command line,</strong> additional <strong>kernel runtime configuration</strong> such as systemd credentials, systemd syscfg images</td>
   <td>Administrator</td>
   <td>Zero</td>
   <td>Yes</td>
  </tr>
  <tr>
   <td><strong>13</strong>
   </td>
   <td><strong>System Extension Images</strong> of initrd</td>
   <td>(Administrator)</td>
   <td>Zero</td>
   <td>Yes<br (when="" set="" of="" extensions="" is="" assembled)<="" td=""/>
  </td></tr>
  <tr>
   <td><strong>15</strong>
   </td>
   <td>Measurement of<strong> root file system volume key</strong></td>
   <td>Local System</td>
   <td>Zero</td>
   <td>Yes</td>
  </tr>
</tbody></table>

<h2>Signature Keys</h2>
<p>In the model above in particular two sets of private/public key pairs
are relevant:</p>
<ul>
<li>
<p>The SecureBoot key to sign the UKI PE executable with. This controls
  permissible choices of OS/kernel</p>
</li>
<li>
<p>The key to sign the expected PCR 11 values with. Signatures made
  with this key will end up in the <code>.pcrsig</code> PE section. The public
  key part will end up in the <code>.pcrpkey</code> PE section.</p>
</li>
</ul>
<p>Typically the key pair for the PCR 11 signatures should be chosen with
a narrow focus, reused for exactly one specific OS (e.g. “Fedora
Desktop Edition”) and the series of UKIs that belong to it (all the
way through all the versions of the OS). The SecureBoot signature key
can be used with a broader focus, if desired. By keeping the PCR 11
signature key narrow in focus one can ensure that secrets bound to the
signature key can only be unlocked on the narrow set of UKIs desired.</p>
<h2>TPM Policy Use</h2>
<p>Depending on the intended access policy to a resource protected by the
TPM, one or more of the PCRs described above should be selected to
bind TPM policy to.</p>
<p>For example, the root file system encryption key should likely be
bound to TPM PCR 11, so that it can only be unlocked if a specific set
of UKIs is booted (it should then, once acquired, be measured into PCR
15, as discussed above, so that later TPM objects can be bound to it,
further down the chain). With the model described above this is
reasonably straight-forward to do:</p>
<ul>
<li>
<p>When userspace wants to bind disk encryption to a specific series of
  UKIs (“<strong>enrollment</strong>”), it looks for the public key passed to the
  <code>initrd</code> in the <code>/.extra/</code> directory (which as discussed above
  originates in the <code>.pcrpkey</code> PE section of the UKI). The relevant
  userspace component (e.g. <code>systemd</code>) is then responsible for
  generating a random key to be used as symmetric encryption key for
  the storage volume (let’s call it <em>disk encryption key _here</em>,
  DEK_). The TPM is then used to encrypt (“seal”) the DEK with its
  internal Storage Root Key (TPM SRK). A TPM2 policy is bound to the
  encrypted DEK. The policy enforces that the DEK may only be
  decrypted if a valid signature is provided that matches the state of
  PCR 11 and the public key provided in the <code>/.extra/</code> directory of
  the <code>initrd</code>. The plaintext DEK key is passed to the kernel to
  implement disk encryption (e.g. LUKS/dm-crypt). (Alternatively,
  hardware disk encryption can be used too, i.e. Intel MKTME, AMD SME
  or even OPAL, all of which are outside of the scope of this
  document.) The TPM-encrypted version of the DEK which the TPM
  returned is written to the encrypted volume’s superblock.</p>
</li>
<li>
<p>When userspace wants to <strong>unlock</strong> disk encryption on a specific
  UKI, it looks for the signature data passed to the initrd in the
  <code>/.extra/</code> directory (which as discussed above originates in the
  <code>.pcrsig</code> PE section of the UKI). It then reads the encrypted
  version of the DEK from the superblock of the encrypted volume. The
  signature and the encrypted DEK are then passed to the TPM. The TPM
  then checks if the current PCR 11 state matches the supplied
  signature from the <code>.pcrsig</code> section and the public key used during
  enrollment. If all checks out it decrypts (“unseals”) the DEK and
  passes it back to the OS, where it is then passed to the kernel
  which implements the symmetric part of disk encryption.</p>
</li>
</ul>
<p>Note that in this scheme the encrypted volume’s DEK is <strong>not</strong> bound
to specific literal PCR hash values, but to a public key which is
expected to sign PCR hash values.</p>
<p>Also note that the state of PCR 11 only matters during unlocking. It
is not used or checked when enrolling.</p>
<p>In this scenario:</p>
<ul>
<li>
<p>Input to the TPM part of the <strong>enrollment</strong> process are the TPM’s
  internal SRK, the plaintext DEK provided by the OS, and the public
  key later used for signing expected PCR values, also provided by the
  OS. – Output is the encrypted (“sealed”) DEK.</p>
</li>
<li>
<p>Input to the TPM part of the <strong>unlocking</strong> process are the TPM’s
  internal SRK, the current TPM PCR 11 values, the public key used
  during enrollment, a signature that matches both these PCR values
  and the public key, and the encrypted DEK. – Output is the plaintext
  (“unsealed”) DEK.</p>
</li>
</ul>
<p>Note that sealing/unsealing is done entirely on the TPM chip, the host
OS just provides the inputs (well, only the inputs that the TPM chip
doesn’t know already on its own), and receives the outputs. With the
exception of the plaintext DEK, none of the inputs/outputs are
sensitive, and can safely be stored in the open. On the wire the
plaintext DEK is protected via TPM parameter encryption (not discussed
in detail here because though important not in scope for this
document).</p>
<p>TPM PCR 11 is the most important of the mentioned PCRs, and its use is
thus explained in detail here. The other mentioned PCRs can be used in
similar ways, but signatures/public keys must be provided via other
means.</p>
<p>This scheme builds on the functionality Linux’ LUKS2 functionality
provides, i.e. key management supporting multiple slots, and the
ability to embed arbitrary metadata in the encrypted volume’s
superblock. Note that this means the TPM2-based logic explained here
doesn’t have to be the only way to unlock an encrypted volume. For
example, in many setups it is wise to enroll both this TPM-based
mechanism and an additional “<em>recovery key</em>” (i.e. a high-entropy
computer generated passphrase the user can provide manually in case
they lose access to the TPM and need to access their data), of which
either can be used to unlock the volume.</p>
<h2>Boot Phases</h2>
<p>Secrets needed during boot-up (such as the root file system encryption
key) should typically not be accessible anymore afterwards, to protect
them from access if a system is attacked during runtime. To implement
this the scheme above is extended in one way: at certain milestones of
the boot process additional fixed “words” should be measured into PCR
11. These milestones are placed at conceptual security boundaries,
i.e. whenever code transitions from a higher privileged context to a
less privileged context.</p>
<p>Specifically:</p>
<ul>
<li>
<p>When the initrd initializes (“<code>initrd-enter</code>”)</p>
</li>
<li>
<p>When the initrd transitions into the root file system (“<code>initrd-leave</code>”)</p>
</li>
<li>
<p>When the early boot phase of the OS on the root file system has
  completed, i.e. all storage and file systems have been set up and
  mounted, immediately before regular services are started
  (“<code>sysinit</code>”)</p>
</li>
<li>
<p>When the OS on the root file system completed the boot process far
  enough to allow unprivileged users to log in (“<code>complete</code>”)</p>
</li>
<li>
<p>When the OS begins shut down (“<code>shutdown</code>”)</p>
</li>
<li>
<p>When the service manager is mostly finished with shutting down and
  is about to pass control to the final phase of the shutdown logic
  (“<code>final</code>”)</p>
</li>
</ul>
<p>By measuring these additional words into PCR 11 the distinct phases of
the boot process can be distinguished in a relatively straight-forward
fashion and the expected PCR values in each phase can be determined.</p>
<p>The phases are measured into PCR 11 (as opposed to some other PCR)
mostly because available PCRs are scarce, and the boot phases defined
are typically specific to a chosen OS, and hence fit well with the
other data measured into PCR 11: the UKI which is also specific to the
OS. The OS vendor generates both the UKI and defines the boot phases,
and thus can safely and reliably pre-calculate/sign the expected PCR
values for each phase of the boot.</p>
<h2>Revocation/Rollback Protection</h2>
<p>In order to secure secrets stored at rest, in particular in
environments where unattended decryption shall be possible, it is
essential that an attacker cannot use old, known-buggy – but properly
signed – versions of software to access them.</p>
<p>Specifically, if disk encryption is bound to an OS vendor (via UKIs
that include expected PCR values, signed by the vendor’s public key)
there must be a mechanism to lock out old versions of the OS or UKI
from accessing TPM based secrets once it is determined that the old
version is vulnerable.</p>
<p>To implement this we propose making use of one of the “counters” TPM
2.0 devices provide: integer registers that are persistent in the TPM
and can only be increased on request of the OS, but never be
decreased. When sealing resources to the TPM, a policy may be declared
to the TPM that restricts how the resources can later be unlocked:
here we use one that requires that along with the expected PCR values
(as discussed above) a counter integer range is provided to the TPM
chip, along with a suitable signature covering both, matching the
public key provided during sealing. The sealing/unsealing mechanism
described above is thus extended: the signature passed to the TPM
during unsealing now covers both the expected PCR values and the
expected counter range. To be able to use a signature associated with
an UKI provided by the vendor to unseal a resource, the counter thus
must be at least increased to the lower end of the range the signature
is for. By doing so the ability is lost to unseal the resource for
signatures associated with older versions of the UKI, because their
upper end of the range disables access once the counter has been
increased far enough. By carefully choosing the upper and lower end of
the counter range whenever the PCR values for an UKI shall be signed
it is thus possible to ensure that updates can invalidate prior
versions’ access to resources. By placing some space between the upper
and lower end of the range it is possible to allow a controlled level
of fallback UKI support, with clearly defined milestones where
fallback to older versions of an UKI is not permitted anymore.</p>
<p>Example: a hypothetical distribution FooOS releases a regular stream
of UKI kernels 5.1, 5.2, 5.3, … It signs the expected PCR values for
these kernels with a key pair it maintains in a HSM. When signing UKI
5.1 it includes information directed at the TPM in the signed data
declaring that the TPM counter must be above 100, and below 120, in
order for the signature to be used. Thus, when the UKI is booted up
and used for unlocking an encrypted volume the unlocking code must
first increase the counter to 100 if needed, as the TPM will otherwise
refuse unlocking the volume. The next release of the UKI, i.e. UKI 5.2
is a feature release, i.e. reverting back to the old kernel locally is
acceptable. It thus does not increase the lower bound, but it
increases the upper bound for the counter in the signature payload,
thus encoding a valid range 100…121 in the signed payload. Now a major
security vulnerability is discovered in UKI 5.1. A new UKI 5.3 is
prepared that fixes this issue. It is now essential that UKI 5.1 can
no longer be used to unlock the TPM secrets. Thus UKI 5.3 will bump
the lower bound to 121, and increase the upper bound by one, thus
allowing a range 121…122. Or in other words: for each new UKI release
the signed data shall include a counter range declaration where the
upper bound is increased by one. The lower range is left as-is between
releases, except when an old version shall be cut off, in which case
it is bumped to one above the upper bound used in that release.</p>
<h2>UKI Generation</h2>
<p>As mentioned earlier, UKIs are the combination of various resources
into one PE file. For most of these individual components there are
pre-existing tools to generate the components. For example the
included kernel image can be generated with the usual Linux kernel
build system. The initrd included in the UKI can be generated with
existing tools such as <code>dracut</code> and similar. Once the basic components
(<code>.linux</code>, <code>.initrd</code>, <code>.cmdline</code>, <code>.splash</code>, <code>.dtb</code>, <code>.osrel</code>,
<code>.uname</code>) have been acquired the combination process works roughly
like this:</p>
<ol>
<li>
<p>The expected PCR 11 hashes (and signatures for them) for the UKI
   are calculated. The tool for that takes all basic UKI components
   and a signing key as input, and generates a JSON object as output
   that includes both the literal expected PCR hash values and a
   signature for them. (For all selected TPM2 banks)</p>
</li>
<li>
<p>The EFI stub binary is now combined with the basic components, the
   generated JSON PCR signature object from the first step (in the
   <code>.pcrsig</code> section) and the public key for it (in the <code>.pcrpkey</code>
   section). This is done via a simple “<code>objcopy</code>” invocation
   resulting in a single UKI PE binary.</p>
</li>
<li>
<p>The resulting EFI PE binary is then signed for SecureBoot (via a
   tool such as
   <a href="https://git.kernel.org/pub/scm/linux/kernel/git/jejb/sbsigntools.git/"><code>sbsign</code></a>
   or similar).</p>
</li>
</ol>
<p>Note that the UKI model implies pre-built initrds. How to generate
these (and securely extend and parameterize them) is outside of the
scope of this document, but a related document will be provided
highlighting these concepts.</p>
<h2>Protection Coverage of SecureBoot Signing and PCRs</h2>
<p>The scheme discussed here touches both SecureBoot code signing and TPM
PCR measurements. These two distinct mechanisms cover separate parts
of the boot process.</p>
<p>Specifically:</p>
<ul>
<li>
<p>Firmware/Shim SecureBoot signing covers bootloader and UKI</p>
</li>
<li>
<p>TPM PCR 11 covers the UKI components and boot phase</p>
</li>
<li>
<p>TPM PCR 12 covers admin configuration</p>
</li>
<li>
<p>TPM PCR 15 covers the local identity of the host</p>
</li>
</ul>
<p>Note that this means SecureBoot coverage ends once the system
transitions from the initrd into the root file system. It is assumed
that trust and integrity have been established before this transition
by some means, for example LUKS/dm-crypt/dm-integrity, ideally bound
to PCR 11 (i.e. UKI and boot phase).</p>
<p>A robust and secure update scheme for PCR 11 (i.e. UKI) has been
described above, which allows binding TPM-locked resources to a
UKI. For PCR 12 no such scheme is currently designed, but might be
added later (use case: permit access to certain secrets only if the
system runs with configuration signed by a specific set of
keys). Given that resources measured into PCR 15 typically aren’t
updated (or if they are updated loss of access to other resources
linked to them is desired) no update scheme should be necessary for
it.</p>
<p>This document focuses on the three PCRs discussed above. Disk
encryption and other userspace may choose to also bind to other
PCRs. However, doing so means the PCR brittleness issue returns that
this design is supposed to remove. PCRs defined by the various
firmware UEFI/TPM specifications generally do not know any concept for
signatures of expected PCR values.</p>
<p>It is known that the industry-adopted SecureBoot signing keys are too
broad to act as more than a denylist for known bad code. It is thus
probably a good idea to enroll vendor SecureBoot keys wherever
possible (e.g. in environments where the hardware is very well known,
and VM environments), to raise the bar on preparing rogue UKI-like PE
binaries that will result in PCR values that match expectations but
actually contain bad code. Discussion about that is however outside of
the scope of this document.</p>
<h2>Whole OS embedded in the UKI</h2>
<p>The above is written under the assumption that the UKI embeds an
initrd whose job it is to set up the root file system: find it,
validate it, cryptographically unlock it and similar. Once the root
file system is found, the system transitions into it.</p>
<p>While this is the traditional design and likely what most systems will
use, it is also possible to embed a regular root file system into the
UKI and avoid any transition to an on-disk root file system. In this
mode the whole OS would be encapsulated in the UKI, and
signed/measured as one. In such a scenario the whole of the OS must be
loaded into RAM and remain there, which typically restricts the
general usability of such an approach. However, for specific purposes
this might be the design of choice, for example to implement
self-sufficient recovery or provisioning systems.</p>

<p>The toolset for most of the above is already implemented in systemd and related projects in one way or another. Specifically:</p>
<ol>
<li>
<p>The
   <a href="https://www.freedesktop.org/software/systemd/man/systemd-stub.html"><code>systemd-stub</code></a>
   (or short: <code>sd-stub</code>) component implements the discussed UEFI stub
   program</p>
</li>
<li>
<p>The
   <a href="https://www.freedesktop.org/software/systemd/man/systemd-measure.html"><code>systemd-measure</code></a>
   tool can be used to pre-calculate expected PCR 11 values given the
   UKI components and can sign the result, as discussed in the UKI
   Image Generation section above.</p>
</li>
<li>
<p>The
   <a href="https://www.freedesktop.org/software/systemd/man/systemd-cryptenroll.html"><code>systemd-cryptenroll</code></a>
   and
   <a href="https://www.freedesktop.org/software/systemd/man/systemd-cryptsetup@.service.html"><code>systemd-cryptsetup</code></a>
   tools can be used to bind a LUKS2 encrypted file system volume to a
   TPM and PCR 11 public key/signatures, according to the scheme
   described above. (The two components also implement a “<em>recovery
   key</em>” concept, as discussed above)</p>
</li>
<li>
<p>The
   <a href="https://www.freedesktop.org/software/systemd/man/systemd-pcrphase.service.html"><code>systemd-pcrphase</code></a>
   component measures specific words into PCR 11 at the discussed
   phases of the boot process.</p>
</li>
<li>
<p>The
   <a href="https://www.freedesktop.org/software/systemd/man/systemd-creds.html"><code>systemd-creds</code></a>
   tool may be used to encrypt/decrypt data objects called
   “credentials” that can be passed into services and booted systems,
   and are automatically decrypted (if needed) immediately before
   service invocation. Encryption is typically bound to the local TPM,
   to ensure the data cannot be recovered elsewhere.</p>
</li>
</ol>
<p>Note that
<a href="https://www.freedesktop.org/software/systemd/man/systemd-stub.html"><code>systemd-stub</code></a>
(i.e. the UEFI code glued into the UKI) is distinct from
<a href="https://www.freedesktop.org/software/systemd/man/systemd-boot.html"><code>systemd-boot</code></a>
(i.e. the UEFI boot loader than can manage multiple UKIs and other
boot menu items and implements automatic fallback, an interactive menu
and a programmatic interface for the OS among other things). One can
be used without the other – both <code>sd-stub</code> without <code>sd-boot</code> and vice
versa – though they integrate nicely if used in combination.</p>
<p>Note that the mechanisms described are relatively generic, and can be
implemented and be consumed in other software too, systemd should be
considered a reference implementation, though one that found
comprehensive adoption across Linux distributions.</p>
<p>Some concepts discussed above are currently not
implemented. Specifically:</p>
<ol>
<li>
<p>The rollback protection logic is currently not implemented.</p>
</li>
<li>
<p>The mentioned measurement of the root file system volume key to PCR
   15 is implemented, but not merged into the systemd main branch yet.</p>
</li>
</ol>

<p>We recently started a new group for discussing concepts and
specifications of basic OS components, including UKIs as described
above. It&#39;s called <a href="https://uapi-group.org/">the UAPI Group</a>. Please
have a look at the various documents and specifications already
available there, and expect more to come. Contributions welcome!</p>
<h2>Glossary</h2>
<blockquote>
<p><strong>TPM</strong></p>
</blockquote>
<p><em>Trusted Platform Module</em>; a security chip found in many modern
systems, both physical systems and increasingly also in virtualized
environments. Traditionally a discrete chip on the mainboard but today
often implemented in firmware, and lately directly in the CPU SoC.</p>
<blockquote>
<p><strong>PCR</strong></p>
</blockquote>
<p><em>Platform Configuration Register</em>; a set of registers on a TPM that
are initialized to zero at boot. The firmware and OS can “<em>extend</em>”
these registers with hashes of data used during the boot process and
afterwards. “Extension” means the supplied data is first
cryptographically hashed. The resulting hash value is then combined
with the previous value of the PCR and the combination hashed
again. The result will become the new value of the PCR. By doing this
iteratively for all parts of the boot process (always with the data
that will be used next during the boot process) a concept of
“<em>Measured Boot</em>” can be implemented: as long as every element in the
boot chain measures (i.e. extends into the PCR) the next part of the
boot like this, the resulting PCR values will prove cryptographically
that only a certain set of boot components can have been used to boot
up. A standards compliant TPM usually has 24 PCRs, but more than half
of those are already assigned specific meanings by the firmware. Some
of the others may be used by the OS, of which we use four in the
concepts discussed in this document.</p>
<blockquote>
<p><strong>Measurement</strong></p>
</blockquote>
<p>The act of “<em>extending</em>” a PCR with some data object.</p>
<blockquote>
<p><strong>SRK</strong></p>
</blockquote>
<p><em>Storage Root Key</em>; a special cryptographic key generated by a TPM
that never leaves the TPM, and can be used to encrypt/decrypt data
passed to the TPM.</p>
<blockquote>
<p><strong>UKI</strong></p>
</blockquote>
<p><em>Unified Kernel Image</em>; the concept this document is about. A
combination of kernel, <code>initrd</code> and other resources. See above.</p>
<blockquote>
<p><strong>SecureBoot</strong></p>
</blockquote>
<p>A mechanism where every software component involved in the boot
process is cryptographically signed and checked against a set of
public keys stored in the mainboard hardware, implemented in firmware,
before it is used.</p>
<blockquote>
<p><strong>Measured Boot</strong></p>
</blockquote>
<p>A boot process where each component measures (i.e., hashes and extends
into a TPM PCR, see above) the next component it will pass control to
before doing so. This serves two purposes: it can be used to bind
security policy for encrypted secrets to the resulting PCR values (or
signatures thereof, see above), and it can be used to reason about
used software after the fact, for example for the purpose of remote
attestation.</p>
<blockquote>
<p><strong>initrd</strong></p>
</blockquote>
<p>Short for “<em>initial RAM disk</em>”, which – strictly speaking – is a
misnomer today, because no RAM disk is anymore involved, but a <code>tmpfs</code>
file system instance. Also known as “<code>initramfs</code>”, which is also
misleading, given the file system is not <code>ramfs</code> anymore, but <code>tmpfs</code>
(both of which are in-memory file systems on Linux, with different
semantics). The <code>initrd</code> is passed to the Linux kernel and is
basically a file system tree in <code>cpio</code> archive. The kernel unpacks the
image into a <code>tmpfs</code> (i.e., into an in-memory file system), and then
executes a binary from it. It thus contains the binaries for the first
userspace code the kernel invokes. Typically, the <code>initrd</code>’s job is to
find the actual root file system, unlock it (if encrypted), and
transition into it.</p>
<blockquote>
<p><strong>UEFI</strong></p>
</blockquote>
<p>Short for “<em>Unified Extensible Firmware Interface</em>”, it is a widely
adopted standard for PC firmware, with native support for <em>SecureBoot</em>
and Measured Boot.</p>
<blockquote>
<p><strong>EFI</strong></p>
</blockquote>
<p>More or less synonymous to UEFI, IRL.</p>
<blockquote>
<p><strong>Shim</strong></p>
</blockquote>
<p>A boot component originating in the Linux world, which in a way
extends the public key database SecureBoot maintains (which is under
control from Microsoft) with a second layer (which is under control of
the Linux distributions and of the owner of the physical device).</p>
<blockquote>
<p><strong>PE</strong></p>
</blockquote>
<p><em>Portable Executable</em>; a file format for executable binaries,
originally from the Windows world, but also used by UEFI firmware. PE
files may contain code and data, categorized in labeled “sections”</p>
<blockquote>
<p><strong>ESP</strong></p>
</blockquote>
<p><em>EFI System Partition</em>; a special partition on a storage
medium that the firmware is able to look for UEFI PE binaries
in to execute at boot.</p>
<blockquote>
<p><strong>HSM</strong></p>
</blockquote>
<p><em>Hardware Security Module</em>; a piece of hardware that can generate and
store secret cryptographic keys, and execute operations with them,
without the keys leaving the hardware (though this is
configurable). TPMs can act as HSMs.</p>
<blockquote>
<p><strong>DEK</strong></p>
</blockquote>
<p><em>Disk Encryption Key</em>; an asymmetric cryptographic key used for
unlocking disk encryption, i.e. passed to LUKS/dm-crypt for activating
an encrypted storage volume.</p>
<blockquote>
<p><strong>LUKS2</strong></p>
</blockquote>
<p><em>Linux Unified Key Setup Version 2</em>; a specification for a superblock
for encrypted volumes widely used on Linux. LUKS2 is the default
on-disk format for the <code>cryptsetup</code> suite of tools. It provides
flexible key management with multiple independent key slots and allows
embedding arbitrary metadata in a JSON format in the superblock.</p>
<h2>Thanks</h2>
<p><em>I’d like to thank Alain Gefflaut, Anna Trikalinou, Christian Brauner,
Daan de Meyer, Luca Boccassi, Zbigniew Jędrzejewski-Szmek for
reviewing this text.</em></p>
  </div></div>
  </body>
</html>
