<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://openjdk.org/jeps/431">Original</a>
    <h1>JEP 431: Sequenced Collections</h1>
    
    <div id="readability-page-1" class="page"><div><h2 id="Summary">Summary</h2>
<p>Introduce new interfaces to represent collections with a defined
encounter order. Each such collection has a well-defined first element,
second element, and so forth, up to the last element. It also provides
uniform APIs for accessing its first and last elements, and for
processing its elements in reverse order.</p>
<blockquote>
<p>&#34;Life can only be understood backwards; but it must be lived forwards.&#34;</p>
</blockquote>
<h2 id="Motivation">Motivation</h2>
<p>Javaâ€™s <a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/doc-files/coll-index.html">collections framework</a> lacks a collection type that represents
a sequence of elements with a defined encounter order. It also lacks a
uniform set of operations that apply across such collections. These
gaps have been a repeated source of problems and complaints.</p>
<p>For example, <code>List</code> and <code>Deque</code> both define an encounter order but
their common supertype is <code>Collection</code>, which does not. Similarly,
<code>Set</code> does not define an encounter order, and subtypes such as
<code>HashSet</code> do not define one, but subtypes such as <code>SortedSet</code> and
<code>LinkedHashSet</code> do. Support for encounter order is thus spread across
the type hierarchy, making it difficult to express certain useful
concepts in APIs. Neither <code>Collection</code> nor <code>List</code> can describe a
parameter or return value that has an encounter order. <code>Collection</code> is
too general, relegating such constraints to the prose specification,
possibly leading to hard-to-debug errors.  <code>List</code> is too specific,
excluding <code>SortedSet</code> and <code>LinkedHashSet</code>.</p>
<p>A related problem is that view collections are often forced to
downgrade to weaker semantics. Wrapping a <code>LinkedHashSet</code> with
<code>Collections::unmodifiableSet</code> yields a <code>Set</code>, discarding the
information about encounter order.</p>
<p>Without interfaces to define them, operations related to encounter
order are either inconsistent or missing.  While many implementations
support getting the first or last element, each collection defines its
own way, and some are not obvious or are missing entirely:</p>
<blockquote><table>
  <tbody>
    <tr><th></th><th>First element</th><th>Last element</th></tr>
    <tr>
      <td><code><strong>List</strong></code></td>
      <td><code>list.get(0)</code></td>
      <td><code>list.get(list.size() - 1)</code></td>
    </tr>
    <tr>
      <td><code><strong>Deque</strong></code></td>
      <td><code>deque.getFirst()</code></td>
      <td><code>deque.getLast()</code></td>
    </tr>
    <tr>
      <td><code><strong>SortedSet</strong></code></td>
      <td><code>sortedSet.first()</code></td>
      <td><code>sortedSet.last()</code></td>
    </tr>
    <tr>
      <td><code><strong>LinkedHashSet</strong></code></td>
      <td><code>linkedHashSet.iterator().next()</code></td>
      <td><code>// missing</code></td>
    </tr>
  </tbody>
</table></blockquote>
<p>Some of these are unnecessarily cumbersome, such as getting the last
element of a <code>List</code>. Some are not even possible without heroics: The
only way to get the last element of a <code>LinkedHashSet</code> is to iterate
the entire set.</p>
<p>Similarly, iterating the elements of a collection from first to last
is straightforward and consistent, but iterating in reverse order is
neither. All of these collections can be iterated forward with an
<code>Iterator</code>, the enhanced <code>for</code> loop, a <code>stream()</code>, or <code>toArray()</code>.
Iterating in reverse is different in every case. <code>NavigableSet</code>
provides the <code>descendingSet()</code> view for reverse iteration:</p>
<pre><code>for (var e : navSet.descendingSet())
    process(e);</code></pre>
<p><code>Deque</code> does so with a reverse <code>Iterator</code>:</p>
<pre><code>for (var it = deque.descendingIterator(); it.hasNext();) {
    var e = it.next();
    process(e);
}</code></pre>
<p><code>List</code> does so but with <code>ListIterator</code>:</p>
<pre><code>for (var it = list.listIterator(list.size()); it.hasPrevious();) {
    var e = it.previous();
    process(e);
}</code></pre>
<p><code>LinkedHashSet</code>, finally, provides no support for reverse iteration.
The only practical way to process the elements of a <code>LinkedHashSet</code> in
reverse order is to copy its elements into another collection.</p>
<p>Similarly, processing a collection&#39;s elements using streams is a
powerful and effective alternative to processing elements using loops,
but obtaining a stream in reverse order can be difficult.  Of the
various collections that define encounter order, the only one that
supports this conveniently is <code>NavigableSet</code>:</p>
<pre><code>navSet.descendingSet().stream()</code></pre>
<p>The others require either copying the elements to another collection
or creating a stream from a customized <code>Spliterator</code> that reverses
iteration.</p>
<p>This is an unfortunate state of affairs. The concept of a collection
with defined encounter order exists in multiple places in the
collections framework, but there is no single type that represents
it. As a result, some operations on such collections are inconsistent
or missing, and processing elements in reverse order ranges from
inconvenient to impossible. We should fill these gaps.</p>
<h2 id="Description">Description</h2>
<p>We define new interfaces for sequenced collections, sequenced sets,
and sequenced maps, and then retrofit them into the existing
collections type hierarchy.  All of the new methods declared in these
interfaces have default implementations.</p>
<h3 id="Sequenced-collections">Sequenced collections</h3>
<p>A <em>sequenced collection</em> is a <code>Collection</code> whose elements have a
defined encounter order. (The word &#34;sequenced&#34; as used here is the
past participle of the verb <em>to sequence</em>, meaning &#34;to arrange
elements in a particular order.&#34;) A sequenced collection has first and
last elements, and the elements between them have successors and
predecessors. A sequenced collection supports common operations at
either end, and it supports processing the elements from first to last
and from last to first (i.e., forward and reverse).</p>
<pre><code>interface SequencedCollection&lt;E&gt; extends Collection&lt;E&gt; {
    // new method
    SequencedCollection&lt;E&gt; reversed();
    // methods promoted from Deque
    void addFirst(E);
    void addLast(E);
    E getFirst();
    E getLast();
    E removeFirst();
    E removeLast();
}</code></pre>
<p>The new <code>reversed()</code> method provides a reverse-ordered view of the
original collection. Any modifications to the original collection are
visible in the view. If permitted, modifications to the view write
through to the original collection.</p>
<p>The reverse-ordered view enables all the different sequenced types to
process elements in both directions, using all the usual iteration
mechanisms: Enhanced <code>for</code> loops, explicit <code>iterator()</code> loops,
<code>forEach()</code>, <code>stream()</code>, <code>parallelStream()</code>, and <code>toArray()</code>.</p>
<p>For example, obtaining a reverse-ordered stream from a <code>LinkedHashSet</code>
was previously quite difficult; now it is simply</p>
<pre><code>linkedHashSet.reversed().stream()</code></pre>
<p>(The <code>reversed()</code> method is essentially a renamed
<code>NavigableSet::descendingSet</code>, promoted to <code>SequencedCollection</code>.)</p>
<p>The following methods of <code>SequencedCollection</code> are promoted from
<code>Deque</code>.  They support adding, getting, and removing elements at both
ends:</p>
<ul>
<li><code>void addFirst(E)</code></li>
<li><code>void addLast(E)</code></li>
<li><code>E getFirst()</code></li>
<li><code>E getLast()</code></li>
<li><code>E removeFirst()</code></li>
<li><code>E removeLast()</code></li>
</ul>
<p>The <code>add*(E)</code> and <code>remove*()</code> methods are optional, primarily to
support the case of unmodifiable collections. The <code>get*()</code> and
<code>remove*()</code> methods throw <code>NoSuchElementException</code> if the collection
is empty.</p>
<p>There are no definitions of <code>equals()</code> and <code>hashCode()</code> in
<code>SequencedCollection</code> because its sub-interfaces have conflicting
definitions.</p>
<h3 id="Sequenced-sets">Sequenced sets</h3>
<p>A <em>sequenced set</em> is a <code>Set</code> that is a <code>SequencedCollection</code> that
contains no duplicate elements.</p>
<pre><code>interface SequencedSet&lt;E&gt; extends Set&lt;E&gt;, SequencedCollection&lt;E&gt; {
    SequencedSet&lt;E&gt; reversed();    // covariant override
}</code></pre>
<p>Collections such as <code>SortedSet</code>, which position elements by relative
comparison, cannot support explicit-positioning operations such as the
<code>addFirst(E)</code> and <code>addLast(E)</code> methods declared in the
<code>SequencedCollection</code> superinterface.  Thus, these methods can throw
<code>UnsupportedOperationException</code>.</p>
<p>The <code>addFirst(E)</code> and <code>addLast(E)</code> methods of <code>SequencedSet</code> have
special-case semantics for collections such as <code>LinkedHashSet</code>: If the
element is already present in the set then it is moved to the
appropriate position. This remedies a long-standing deficiency in
<code>LinkedHashSet</code>, namely the inability to reposition elements.</p>
<h3 id="Sequenced-maps">Sequenced maps</h3>
<p>A <em>sequenced map</em> is a <code>Map</code> whose entries have a defined encounter
order.</p>
<pre><code>interface SequencedMap&lt;K,V&gt; extends Map&lt;K,V&gt; {
    // new methods
    SequencedMap&lt;K,V&gt; reversed();
    SequencedSet&lt;K&gt; sequencedKeySet();
    SequencedCollection&lt;V&gt; sequencedValues();
    SequencedSet&lt;Entry&lt;K,V&gt;&gt; sequencedEntrySet();
    V putFirst(K, V);
    V putLast(K, V);
    // methods promoted from SortedMap and NavigableMap
    Entry&lt;K, V&gt; firstEntry();
    Entry&lt;K, V&gt; lastEntry();
    K firstKey();
    K lastKey();
    Entry&lt;K, V&gt; pollFirstEntry();
    Entry&lt;K, V&gt; pollLastEntry();
}</code></pre>
<p>The new <code>put*(K, V)</code> methods have special-case semantics, similar to
the corresponding <code>add*(E)</code> methods of <code>SequencedSet</code>: For maps such
as <code>LinkedHashMap</code>, they have the additional effect of repositioning
the entry if it is already present in the map. For maps such as
<code>SortedMap</code>, these methods throw <code>UnsupportedOperationException</code>.</p>
<p>The following methods of <code>SequencedMap</code> are promoted from <code>SortedMap</code>
and <code>NavigableMap</code>. They support getting and removing entries at both
ends:</p>
<ul>
<li><code>Entry&lt;K, V&gt; firstEntry()</code></li>
<li><code>Entry&lt;K, V&gt; lastEntry()</code></li>
<li><code>K firstKey()</code></li>
<li><code>K lastKey()</code></li>
<li><code>Entry&lt;K, V&gt; pollFirstEntry()</code></li>
<li><code>Entry&lt;K, V&gt; pollLastEntry()</code></li>
</ul>
<h3 id="Retrofitting">Retrofitting</h3>
<p>The three new interfaces defined above fit neatly into the existing
collections type hierarchy (click to enlarge):</p>
<p><a href="https://cr.openjdk.java.net/~smarks/collections/SequencedCollectionDiagram20220216.png">
<img src="https://cr.openjdk.java.net/~smarks/collections/SequencedCollectionDiagram20220216.png"/></a></p><p>In detail, we make the following adjustments to retrofit existing
classes and interfaces:</p>
<ul>
<li><code>List</code> has <code>SequencedCollection</code> as its immediate superinterface,</li>
<li><code>Deque</code> has <code>SequencedCollection</code> as its immediate superinterface,</li>
<li><code>LinkedHashSet</code> implements <code>SequencedSet</code>,</li>
<li><code>SortedSet</code> has <code>SequencedSet</code> as its immediate superinterface,</li>
<li><code>LinkedHashMap</code> implements <code>SequencedMap</code>, and</li>
<li><code>SortedMap</code> has <code>SequencedMap</code> as its immediate superinterface.</li>
</ul>
<p>We define covariant overrides for the <code>reversed()</code> method in the
appropriate places. For example, <code>List::reversed</code> is overridden to
return a value of type <code>List</code> rather than a value of type
<code>SequencedCollection</code>.</p>
<p>We also add new methods to the <code>Collections</code> utility class to create
unmodifiable wrappers for the three new types:</p>
<ul>
<li><code>Collections.unmodifiableSequencedCollection(collection)</code></li>
<li><code>Collections.unmodifiableSequencedSet(sequencedSet)</code></li>
<li><code>Collections.unmodifiableSequencedMap(sequencedMap)</code></li>
</ul>
<h2 id="Alternatives">Alternatives</h2>
<h3 id="Types">Types</h3>
<p>An alternative to adding new types would be to repurpose the <code>List</code>
interface as a general sequenced collection type.  Indeed <code>List</code> is
sequenced, but it also supports element access by integer index. Many
sequenced data structures do not naturally support indexing and would
thus be required to support it iteratively. This would result in indexed
access having O(n) performance instead of the expected O(1), perpetuating
the mistake of <code>LinkedList</code>.</p>
<p><code>Deque</code> seems promising as a general sequence type, since it already
supports the right set of operations. However, it is cluttered with other
operations, including a family of null-returning operations (offer, peek,
and poll), stack operations (push and pop), and operations inherited from
<code>Queue</code>. These operations are sensible for a queue but less so for other
collections.  If <code>Deque</code> were repurposed as a general sequence type then
<code>List</code> would also be a <code>Queue</code> and would support stack operations,
resulting in a cluttered and confusing API.</p>
<h3 id="Naming">Naming</h3>
<p>The term <em>sequence</em>, which we have chosen here, implies elements that
are arranged in order. It is commonly used across various platforms to
represent collections with semantics similar to those described above.</p>
<p>The term <em>ordered</em> is not quite specific enough. We require iteration
in both directions, and operations at both ends. An ordered collection
such as a <code>Queue</code> is a notable outlier: It is ordered, but it is also
decidedly asymmetric.</p>
<p>The term <em>reversible</em>, used in an earlier version of this proposal,
does not immediately evoke the concept of having two ends. Perhaps a
bigger issue is that the <code>Map</code> variant would be named <code>ReversibleMap</code>,
which misleadingly implies that it supports lookup by key and by value
(sometimes called a <code>BiMap</code> or <code>BidiMap</code>).</p>
<h3 id="Add-put-and-UnsupportedOperationException">Add, put, and <code>UnsupportedOperationException</code></h3>
<p>As described above, explicit-positioning APIs such as
<code>SortedSet::addFirst</code> and <code>SortedMap::putLast</code> throw
<code>UnsupportedOperationException</code> because the sequence of their elements
is determined by relative comparison. The asymmetry of having some
collections not implement all of the <code>SequencedCollection</code> operations
may seem unpleasant. It is nonetheless valuable because it brings
<code>SortedSet</code> and <code>SortedMap</code> into the sequenced collection family,
allowing them to be used more broadly than otherwise. This asymmetry
is, also, consistent with prior design decisions in the collections
framework. For example, the <code>Map::keySet</code> method returns a <code>Set</code>, even
though the implementation returned does not support addition.</p>
<p>Alternatively, the addition operations could be kept separate by
rearranging the interfaces along structural lines. That would result
in new interface types with very thin semantics (e.g.,
<code>AddableCollection</code>) that are not useful in practice and that clutter
up the type hierarchy.</p>
<h2 id="History">History</h2>
<p>This proposal is an incremental evolution of our 2021
<a href="http://mail.openjdk.org/pipermail/core-libs-dev/2021-April/076461.html"><code>ReversibleCollections</code> proposal</a>.
The major changes from that proposal are renaming, the addition of the
<code>SequencedMap</code> interface, and the addition of unmodifiable wrapper
methods.</p>
<p>The <code>ReversibleCollection</code> proposal was in turn based on Tagir Valeev&#39;s
2020 <a href="http://mail.openjdk.org/pipermail/core-libs-dev/2020-April/066028.html"><code>OrderedMap/OrderedSet</code> proposal</a>.
Several fundamental concepts from that proposal are still present,
although there are many differences in detail.</p>
<p>Over the years we have received many requests and proposals in the
vein of combining a <code>List</code> with a <code>Set</code> or <code>Map</code>. The recurring themes
are a <code>List</code> that contains unique elements, or a <code>Set</code> or <code>Map</code> that
maintains ordering. These requests include
<a href="https://bugs.openjdk.org/browse/JDK-4152834">4152834</a>,
<a href="https://bugs.openjdk.org/browse/JDK-4245809">4245809</a>,
<a href="https://bugs.openjdk.org/browse/JDK-4264420">4264420</a>,
<a href="https://bugs.openjdk.org/browse/JDK-4268146">4268146</a>,
<a href="https://bugs.openjdk.org/browse/JDK-6447049">6447049</a>, and
<a href="https://bugs.openjdk.org/browse/JDK-8037382">8037382</a>.</p>
<p>Some of these requests were partially addressed with the introduction
of <code>LinkedHashSet</code> and <code>LinkedHashMap</code> in Java 1.4. While those
classes do satisfy some use cases, their introduction left gaps in the
abstractions and operations provided by the collections framework, as
described above.</p>
<h2 id="Testing">Testing</h2>
<p>We will add a comprehensive set of tests to the JDK&#39;s regression test
suite.</p>
<h2 id="Risks-and-Assumptions">Risks and Assumptions</h2>
<p>Introducing new methods high in the inheritance hierarchy runs the risk
of clashes over obvious method names such as <code>reversed</code> and <code>getFirst</code>.</p>
<p>Of particular concern are the covariant overrides of the <code>reversed()</code>
method on <code>List</code> and <code>Deque</code>. These are source and binary incompatible
with existing collections that implement both <code>List</code> and
<code>Deque</code>. There are two examples of such collections in the JDK:
<code>LinkedList</code> and an internal class <code>sun.awt.util.IdentityLinkedList</code>.
This incompatibility can only be handled by adding an overriding
<code>reversed</code> method.</p>
<p>The introduction of covariant overrides on the <code>keySet()</code> and
<code>entrySet()</code> methods of the <code>SequencedMap</code> interface could also result in
incompatibilities with subclasses that override these methods.</p>
<p>If necessary, we could mitigate these incompatibilities by choosing
different method names, for example <code>reversedList()</code> or
<code>sequencedKeySet()</code>, thereby avoiding the covariant overrides. That
approach was taken with the introduction of the
<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/NavigableMap.html#navigableKeySet()"><code>navigableKeySet()</code></a>
method in Java 6, which alternatively could have been a covariant
override of <code>keySet()</code>.</p>
<p>We will analyze a large corpus of Java code in order to assess these
risks.</p>
</div></div>
  </body>
</html>
