<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jason.today/falling-improved">Original</a>
    <h1>Improving the foundation of our falling sand simulator</h1>
    
    <div id="readability-page-1" class="page"><div>
    <h2>Formalize our concept of a particle</h2>
    <p>
      In the previous post, our <code>Grid</code> held hex strings, or a <code>0</code>.
      If we want to be able to add new particles with different rules, we need to lay a strong foundation
      to build upon - that is, storing objects, not colors.
    </p>
    <p>Let&#39;s introduce the <code>Particle</code>.</p>
    <pre><code>class Particle {
  constructor({color, empty} = {}) {
    this.color = color;
    this.empty = empty ?? false;
  }
  // We&#39;ll use this later!
  update() {}
}</code></pre>
    <p>It has a color, and an indication of whether or not it is empty.</p>
    <p>Let&#39;s extend it to create <code>Sand</code>...</p>
    <pre><code>class Sand extends Particle {
  static baseColor = &#34;#dcb159&#34;;
  constructor(p) {
    super({color: p.varyColor(Sand.baseColor)});
  }
}</code></pre>
    <p>And add an empty particle, which every single pixel other than sand, will be. That&#39;s right, lots
    of instances of <code>Empty</code>.</p>
    <pre><code>class Empty extends Particle {
  static baseColor = window.background;
  constructor() {
    super({empty: true});
  }
}</code></pre>
    <p>
      Now we can just keep track of our &#34;current particle type&#34; and then add a little palette to choose between them!
    </p>
    <p>
      Just hit &#34;Start Rendering&#34;, and when you&#39;re ready for the next step, &#34;Pause Rendering&#34;.
      The current approach is very inefficient, and we&#39;re going to improve it starting in the next step,
      so let&#39;s not waste computation by keeping this running.
    </p>
    
    
  </div><div>
    <h2>Performance and Bug Fixes</h2>
    <p><i>
      If you want to skip all this performance stuff, <a onclick="document.getElementById(&#39;skip-performance&#39;).scrollIntoView({block: &#39;start&#39;})">
      click here to go straight to the new functionality!
    </a></i></p><h3>A larger canvas</h3>
    <p>
      If we try to make our canvas larger, we notice we get a pretty harsh slow down.
    </p>
    <p>Just hit &#34;Start Rendering&#34; and make some sand to see how slow the canvas (and whole post) gets!</p>
    
    <p>
      Let&#39;s do some profiling to see why that is.
    </p>
    <p>
      (Make sure to hit &#34;Pause Rendering&#34;, or the whole post is going to continue to be slow)
    </p>
    
    <h3>Unnecessary color parsing</h3>
    <p>So I jumped in Chrome DevTools and hit the performance tab, record and played around in our canvas.</p>
    <p><img src="https://jason.today/img/parsing_colors.png" alt="Parsing colors every pixel was killing performance" title="Parsing colors every pixel was killing performance"/></p><p>Wow! The vast majority of the processing is going to <code>Color._parseInputs</code></p>
    <p>This is the current implementation - where <code>color</code> is a hex string, like <code>#fff123</code>.</p>
    <pre><code>function setPixel(p, i, color) {  // color is a string
  const index = 4 * i;
  p.pixels[index] = p.red(color);  // Parse string
  p.pixels[index + 1] = p.green(color);  // Parse string
  p.pixels[index + 2] = p.blue(color);  // Parse string
  p.pixels[index + 3] = p.alpha(color);  // Parse string
}</code></pre>
    <p>
      Parsing the color from a string for every channel of every pixel on every frame is expensive! Fortunately now
      that we know what the problem is, it&#39;s a pretty simple fix. We just need to calculate the channels at particle
      creation time, which we can do in our approach with <code>p.color</code>, then we don&#39;t need to do any parsing
      at draw time, because we&#39;re passing around an object with the channels pre-calculated.
    </p>

    <pre><code>p.backgroundColor = p.color(window.background);
p.varyColor = (color) =&gt; {
  // Skipping the color varying logic for brevity
  // See the previous post for how we did it!
  return p.color(`hsl(${hue}, ${saturation}%, ${lightness}%)`);
};</code></pre>
    <p>
      What a dramatic improvement. The key takeaway here isn&#39;t that string parsing is slow. It&#39;s that profiling
      is an incredibly powerful tool for understanding the performance of an application. We shouldn&#39;t blindly optimize
      according to what we think might work. We should profile and tackle the bottlenecks it identifies!
    </p>
    
    

    <h3>Only update the pixels that changed (and stop rendering when we can!)</h3>
    <p>
      So, we removed our string parsing- what&#39;s the next step?
    </p>
    <p>
      Instead of updating our buffer for every cell in our simulation, let&#39;s keep a <code>Set</code> of indices of the
      pixels we modified, and only update them!
    </p>
    <p>
      Additionally, now that we&#39;re tracking updates, we can automatically
      pause the simulation when it&#39;s not updating, and resume when the user interacts with it.
    </p>
    <p>
      So, let&#39;s introduce the <code>Set</code>, and keep track of whether we cleared all pixels last render.
    </p>
    <pre><code>initialize(width, height) {
  super.initialize(width, height);
  this.modifiedIndices = new Set();
  this.cleared = false;
}</code></pre>
    <p>
      Now we need to create an entry point to set values in the grid that we&#39;ll always use now.
      It will take note of the index that was modified.
    </p>
    <pre><code>setIndex(i, particle) {
  super.setIndex(i, particle);
  this.modifiedIndices.add(i);
}</code></pre>
    <p>
      This one&#39;s easy - if we cleared this frame, take note!
    </p>
    <pre><code>clear() {
    super.clear();
    this.cleared = true;
}</code></pre>
    <p>
      <code>update</code> runs at the beginning of every frame, so let&#39;s make sure to reset our modified
      indices and whether we&#39;ve cleared.
    </p>
    <pre><code>update() {
  this.cleared = false;
  this.modifiedIndices = new Set();
  super.update();
}</code></pre>
    <p>If we&#39;re trying to update an empty space, just return.</p>
    <pre><code>updatePixel(i) {
  if (this.isEmpty(i)) { return; }
  super.updatePixel(i);
}</code></pre>
    <p>And if we&#39;re trying to swap empty space, just return.</p>
    <pre><code>swap(a, b) {
  if (this.grid[a].empty &amp;&amp; this.grid[b].empty) {
    return;
  }
  super.swap(a, b);
}</code></pre>
    <p>
      Finally, our draw. If we cleared, clear all the pixels. If we modified any pixels,
      then just set those!
    </p>
    <pre><code>draw(p) {
  if (this.cleared) {
    p.clearPixels();
  } else if (this.modifiedIndices.size) {
    this.modifiedIndices.forEach((index) =&gt; {
      p.setPixel(index, this.grid[index].color || p.backgroundColor);
    });
  }
  p.updatePixels();
}</code></pre>
    <p>
      Wait a sec - we&#39;re still calling <code>p.updatePixels</code> every frame!
    </p>
    <p>Yeah- so we actually clear the
      screen at the beginning of every loop, so if we don&#39;t call it, it&#39;ll be a blank canvas
      <i>unless we&#39;re updating</i> which isn&#39;t what we want. So let&#39;s tackle this a different way.
    </p>
    <p>
      Unless we tell it not to, our simulation will tell the renderer to keep updating at 60 fps, using a fair amount
      of processing power. If the particles aren&#39;t moving and you&#39;ve stopped interacting with it, it doesn&#39;t need to
      keep draining your battery or spinning up your fans.

      So the rule we need to implement is, if we didn&#39;t clear our canvas, update pixels, click on, or touch the screen,
      stop running our draw loop.
    </p>
    <p>First, the check for whether it needs updating...</p>
    <pre><code>needsUpdate() {
  return this.cleared || this.modifiedIndices.size;
}</code></pre>
    <p>And that&#39;s it!</p>
    <p>
      And now our pausing and resuming logic!
      </p>
    <p><i>
      In p5.js, you can do this with <code>p.loop()</code> and <code>p.noLoop()</code>, I just renamed them for clarity.
    </i></p><p>
      In essence, we&#39;re pausing any time the grid doesn&#39;t need an update, and resuming if we detect any user events.
      We <i>could</i> take this further by checking if the event is executing within the bounds of the canvas.
    </p>
    <pre><code>class EfficientLogic extends SlowLogic {
  logic(p, grid) {
    super.logic(p, grid);
    p.mouseDragged = () =&gt; {p.resume();}
    p.mouseMoved = () =&gt; {p.resume();}
    p.mousePressed = () =&gt; {p.resume();}
    p.touched = () =&gt; {p.resume();}
    p.after = () =&gt; {
      // If there&#39;s no reason to update, pause drawing to save cpu / battery!
      if (!grid.needsUpdate()) {
        p.pause();
      }
    }
  }
}</code></pre>
    <p>
      We&#39;re incrementing a counter any time there&#39;s an update to verify our logic is working as expected- that is
      the frame should stop incrementing when we aren&#39;t sending events and sand isn&#39;t falling.
    </p><p>
    Frame: <span id="skip-performance">0</span></p>

    

    <p>So - we have a relatively efficient renderer now! (and no more manual toggling of rendering) Pretty cool.
      But, there&#39;s more to do.
    </p>
    <h2>Fix the left bias</h2>
    <p>If you&#39;ve been playing around with these, you may have noticed a frustrating left-bias.</p>
    <p>(Try just holding / drawing in a single place for a little while)</p>
    <p><i>Shout out to <b>@jakear</b> from HN for the suggested fix.</i></p><p>
      So, what&#39;s going on here? Well, when we update our pixels, we&#39;re going from the end to the beginning. This
      means that we&#39;re running the rules for each particle from right to left for each row, so the right particles
      will always execute their rules before the left ones, causing a bias.
    </p>
    <p>What can we do?</p>
    <p>Fortunately we can just randomly decide whether we should perform a left-pass or a right-pass for each row.</p>
    <p>Save the row count so we can refer to it during <code>update</code>.</p>
    <pre><code>initialize(width, height) {
  super.initialize(width, height);
  this.rowCount = Math.floor(this.grid.length / this.width);
}</code></pre>
    <p>
      The core logic change: instead of iterating from end to beginning, we give ourselves an opportunity to change
      the direction we iterate for each row. We still iterate last row to first, but we randomly swap the direction
      we iterate.
    </p>
    <pre><code>update() {
  this.cleared = false;
  this.modifiedIndices = new Set();

  for (let row = this.rowCount - 1; row &gt;= 0; row--) {
    const rowOffset = row * this.width;
    const leftToRight = Math.random() &gt; 0.5;
    for (let i = 0; i &lt; this.width; i++) {
      // Go from right to left or left to right depending on our random value
      const columnOffset = leftToRight ? i : -i - 1 + this.width;
      this.updatePixel(rowOffset + columnOffset);
    }
  }
}</code></pre>
    <p>While we&#39;re here... it&#39;s currently possible to overflow to the other side of the screen. Due to not properly
    checking bounds in our <code>updatePixel</code> function. Let&#39;s fix that!</p>
    <pre><code>updatePixel(i) {
  const below = i + this.width;
  const belowLeft = below - 1;
  const belowRight = below + 1;
  const column = i % this.width;

  if (this.isEmpty(below)) {
    this.swap(i, below);
  // Check to make sure belowLeft didn&#39;t wrap to the next line
  } else if (this.isEmpty(belowLeft) &amp;&amp; belowLeft % this.width &lt; column) {
    this.swap(i, belowLeft);
  // Check to make sure belowRight didn&#39;t wrap to the next line
  } else if (this.isEmpty(belowRight) &amp;&amp; belowRight % this.width &gt; column) {
    this.swap(i, belowRight);
  }
}</code></pre>
    <p>
      So, because <code>belowLeft</code> and <code>belowRight</code> are calculated by adding or removing 1, if
      our particle was on the left or right edge of the screen, these variables could have represented a pixel on
      the next line! Fortunately we can check to make sure that they are actually in the right direction (less
      than our current column for left, and more than our current column for right).
    </p>

    
    
  </div><div>
    <h2>Introduce velocity and acceleration</h2>
    <p>
      So here we are, spending all this time improving performance, surely there&#39;s a reason other than disciplined
      engineering practices! Right?
    </p>
    <p>
      Right! Now that we&#39;ve dramatically improved performance, we can update particles more than once per frame!
      Why is this a big deal? Because it means we can add acceleration and velocity and make the simulation
      feel much more fluid.
    </p>
    <p>
      We need to wrap up this post as it&#39;s getting very long, so we&#39;re only going to tackle 1D velocity for now.
    </p>

    <p>
      There are two key methods we&#39;ll need to make: <code>updateVelocity</code> and <code>getUpdateCount</code>.
      These methods will maintain the velocity of a particle, and communicate to our update function, how to
      update the particle based on its velocity. There are a few other changes we&#39;ll too.
    </p>
    <p>Let&#39;s introduce our particle with velocity.</p>
    <p>Adding the parameters we&#39;ll need...</p>
    <pre><code>// Our sand particle
constructor(p) {
  super(p);
  this.maxSpeed = 8;
  this.acceleration = 0.4;
  this.velocity = 0;
  this.modified = false;
}</code></pre>
    <p>Next, we need to keep track of our velocity, updating it according to
      <code>acceleration</code> and not allowing it to exceed <code>maxSpeed</code>.
    </p>
    <pre><code>updateVelocity() {
  let newVelocity = this.velocity + this.acceleration;

  if (Math.abs(newVelocity) &gt; this.maxSpeed) {
    newVelocity = Math.sign(newVelocity) * this.maxSpeed;
  }

  this.velocity = newVelocity;
}</code></pre>
    <p>
      We then want to ensure we can reset the velocity (when it collides with something).
    </p>
    <pre><code>resetVelocity() {
  this.velocity = 0;
}</code></pre>
    <p>
      Now to the key logic for making use of velocity in our simulation... To make use of
      velocity, we&#39;re going to run the <code>updatePixel</code> function some number of
      times according to the velocity. Now if the velocity is 1, 2, or 3 (i.e. discrete)
      this isn&#39;t so hard! <code>getUpdateCount</code> would just return <code>velocity</code>.
    </p>
    <p>
      But how do we deal with a <code>velocity</code> of 1.5 or 0.5?
    </p>
    <p>
      The approach we&#39;re going to use is that any remainder of a whole number will be the
      probability that the update will occur this frame. Not perfect, but simple to implement.
    </p>
    <pre><code>getUpdateCount() {
  const abs = Math.abs(this.velocity);
  const floored = Math.floor(abs);
  const mod = abs - floored;
  // Treat a remainder (e.g. 0.5) as a random chance to update
  return floored + (Math.random() &lt; mod ? 1 : 0);
}</code></pre>
    <p>
      Finally we want to have a generic <code>update</code> method that tells us if our particle
    was modified, i.e. &#34;is in motion&#34;. To tell our modification tracking system that it shouldn&#39;t
    stop rendering.
    </p>
    <pre><code>update() {
  if ((this.maxSpeed ?? 0) === 0) {
    this.modified = false;
    return;
  }
  this.updateVelocity();
  this.modified = this.velocity !== 0;
}</code></pre>
    <p>And that&#39;s our particle!</p>

    <p>
      Now we need to update our <code>Grid</code> update logic, and we&#39;ll be done.
      We&#39;re replacing the current code which just calls <code>this.updatePixel(index)</code>.
    </p>
    <pre><code>const particle = this.grid[index];

// Update our velocity and save whether we modified the particle
particle.update();

if (!particle.modified) {
  continue;
}

// Make sure we note it was modified, as movement
// is probabilistic now.
this.modifiedIndices.add(index);

// Update the number of times the particle instructs us to
for (let v = 0; v &lt; particle.getUpdateCount(); v++) {
  const newIndex = this.updatePixel(index);

  // If we swapped the particle to a new location,
  // we need to update our index to be that new one.
  // As we are repeatedly updating the same particle.
  if (newIndex !== index) {
    index = newIndex;
  } else {
    particle.resetVelocity();
    break;
  }
}</code></pre>
    <p>
      The very last step is that we update our <code>updatePixel</code> method to return the index
      of the index it was swapped with, or itself if it was not swapped.
    </p>
    <p>
      So, we&#39;ve made it to the end and I didn&#39;t even mention how to implement <code>Wood</code>.
      How might it be implemented, now that we have a concept of particles we can extend, and velocity?
    </p>
    
    
  </div></div>
  </body>
</html>
