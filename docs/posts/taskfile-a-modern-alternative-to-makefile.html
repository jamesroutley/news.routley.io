<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cloudnativeengineer.substack.com/p/ep-5-taskfile-a-modern-alternative">Original</a>
    <h1>Taskfile: A Modern Alternative to Makefile</h1>
    
    <div id="readability-page-1" class="page"><div><div><article><div class=""><div><div dir="auto"><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F5b3d6874-886e-43d3-865f-cb74b7c827f2_2030x1522.png" data-component-name="Image2ToDOM" rel="nofollow ugc noopener"><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F5b3d6874-886e-43d3-865f-cb74b7c827f2_2030x1522.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F5b3d6874-886e-43d3-865f-cb74b7c827f2_2030x1522.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F5b3d6874-886e-43d3-865f-cb74b7c827f2_2030x1522.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F5b3d6874-886e-43d3-865f-cb74b7c827f2_2030x1522.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F5b3d6874-886e-43d3-865f-cb74b7c827f2_2030x1522.png" width="1456" height="1092" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/5b3d6874-886e-43d3-865f-cb74b7c827f2_2030x1522.png&#34;,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:1092,&#34;width&#34;:1456,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:566255,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:&#34;image/png&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:false,&#34;topImage&#34;:true,&#34;internalRedirect&#34;:null}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F5b3d6874-886e-43d3-865f-cb74b7c827f2_2030x1522.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F5b3d6874-886e-43d3-865f-cb74b7c827f2_2030x1522.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F5b3d6874-886e-43d3-865f-cb74b7c827f2_2030x1522.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F5b3d6874-886e-43d3-865f-cb74b7c827f2_2030x1522.png 1456w" sizes="100vw" fetchpriority="high"/></picture></div></a></figure></div><p>I meant to write this post for a while now, but I never thought many people would read it. I&#39;m writing it now for those few people brave enough to try something new around automation tools.</p><p><span>After being unhappy with Makefile for years now, last year I decided that I had enough and I started looking around for alternatives. None of the projects I found seemed to fit my needs until I discovered </span><a href="https://taskfile.dev/" rel="nofollow ugc noopener">Taskfile</a><span>. After using it successfully for the past year, I&#39;m happy to say that I found a better way to write automation scripts than Makefile and I&#39;m not going back.</span></p><p>In this post, I would like to introduce Taskfile and a few other tools that combined make a nice automation framework. My intention is not for this post to be an exhaustive guide to those tools. People can read the official documentation if they are interested.</p><p><span>I just want to introduce some basic features that I use every day and maybe spark the reader&#39;s curiosity. Just use 20% of those tools&#39; features to reap 80% of the benefits. Thanks, Pareto for your </span><a href="https://en.wikipedia.org/wiki/Pareto_principle" rel="nofollow ugc noopener">principle</a><span>.</span></p><p>This is just my first post on this topic. I&#39;m planning to write soon a more in-depth one where I describe my current use cases.</p><div data-attrs="{&#34;url&#34;:&#34;https://cloudnativeengineer.substack.com/p/ep-5-taskfile-a-modern-alternative?utm_source=substack&amp;utm_medium=email&amp;utm_content=share&amp;action=share&#34;,&#34;text&#34;:&#34;Share&#34;}" data-component-name="CaptionedButtonToDOM"><p>Thank you for reading Cloud Native Engineer. This post is public so feel free to share it.</p><p data-attrs="{&#34;url&#34;:&#34;https://cloudnativeengineer.substack.com/p/ep-5-taskfile-a-modern-alternative?utm_source=substack&amp;utm_medium=email&amp;utm_content=share&amp;action=share&#34;,&#34;text&#34;:&#34;Share&#34;}" data-component-name="ButtonCreateButton"><a href="https://cloudnativeengineer.substack.com/p/ep-5-taskfile-a-modern-alternative?utm_source=substack&amp;utm_medium=email&amp;utm_content=share&amp;action=share" rel="nofollow ugc noopener"><span>Share</span></a></p></div><p>What I don&#39;t get is how we make so much progress in AI, data science, and machine learning, but we are still stuck in the past whenever it comes to automation and developer tools. How can we innovate fast enough in AI (or any other fields) if technology hasn&#39;t caught up with our modern needs for developer tools?</p><p><span>As anyone that writes or interacts with software these days, I need to run automation scripts every day but I am still stuck with a tool that (according to </span><a href="https://en.wikipedia.org/wiki/Make_(software)" rel="nofollow ugc noopener">Wikipedia</a><span>) has been written 47 years ago. Don&#39;t get me wrong, Makefile was really useful 20 years ago but I think we can do better than that in 2023.</span></p><p>My take on why people are still using Makefile?</p><p>Everyone got used to the fact that Makefile is the only alternative available for a standard (not language-specific like Grunt or Gulp) task runner and there is nothing they can do about it.</p><p>Well, not everyone. Someone decided that they had enough of Makefile and wrote an alternative in Golang called Taskfile.</p><p><span>Like everyone here, I used to just write makefiles or simple bash scripts and then lengthy </span><code>Readme</code><span> in Markdown to explain how to run those scripts or how to install all the required tools necessary.</span></p><p>It was a long and excruciating, but necessary, process not just for other people but mostly for myself. I have a very bad memory, and I tend to forget what was that command argument or the script that I run last week. Things don&#39;t get better with age, I had to find a better alternative.</p><p>Also, as an engineer, I hate writing documentation:</p><ul><li><p>It is a tedious process.</p></li><li><p>It gets out of date the minute that you finish writing it.</p></li><li><p>There are no refactoring tools for a Readme in Markdown that keep your documentation up to date with your code.</p></li><li><p>Documentation is not executable. I mean there are tools now that allow you to run code from Markdown documentation but they are not a widespread practice.</p></li></ul><p>So What do I do now instead?</p><p>Instead of writing documentation as an after-math, if I run a shell command that I think I might use in the future, I add it to my now big list of tasks, make it reusable, and attach a one-line comment to the code, if I need it. My automation framework makes it very easy to pick it up next time when I need to run that command again.</p><p><span>In order to make those automation scripts reusable, I separate the </span><code>state</code><span> (the part that might change at each use case) from the reusable </span><code>code</code><span> (the part that is fixed every time).</span></p><p>How do I do that? I use a combination of three different tools: Taskfile, Direnv, Devenv.</p><p>My documentation is much shorter now, I still embed notes on how to use those scripts but I tend to write them next to the code as comments. The proximity of documentation and code makes the shelf life of my docs a lot longer.</p><p>I just want to point out, that this is not a simple setup. In order to make this happen, I am using three different tools and I had to do quite some experimentation. During this time, I bumped into many bugs (some of which are now fixed) and feature missing due to the new nature of those tools and the fact they are not widely used.</p><p>Having said that, I see the development of those tools going in the right direction and the number of Github stars rising exponentially. I know, GitHub stars as a metric for adoption is not everything, but that&#39;s what we are stuck with.</p><p>Also, you don&#39;t have to go through the same pain. You can just reap the benefit of my experience.</p><p>Furthermore, the learning curve of those tools is quite gentle and you can just start with the basics and add more stuff over time. I&#39;m not even saying that you should adopt my full framework. If you don&#39;t feel comfortable you can just start playing with each single tool in isolation.</p><p><span>I like to think that by combining these three somehow </span><code>small</code><span> tools I am following the teaching of the </span><a href="https://en.wikipedia.org/wiki/Unix_philosophy" rel="nofollow ugc noopener">Unix Philosophy</a><span>, which I like to paraphrase to </span></p><p>Combine simple and small tools to create something powerful</p><p>And this described here is exactly it, a very powerful framework, that once correctly setup, can allow you to build a complex pipeline of tasks</p><p><span>Until now, I&#39;ve been calling it Taskfile, but in reality, that&#39;s the name of the config file used by the tool </span><code>Task</code><span>. Given how generic is the word task, I believe that&#39;s a better way to identify the tool. I mean, it is kind of the same story with </span><code>Make</code><span> the tool and its format </span><code>Makefile</code><span>.</span></p><p><span>The official definition of Task from </span><a href="https://taskfile.dev/" rel="nofollow ugc noopener">taskfile.dev</a><span> is the following:</span></p><blockquote><p><span>Task is a task runner / build tool that aims to be simpler and easier to use than, for example, </span><a href="https://www.gnu.org/software/make/" rel="nofollow ugc noopener">GNU Make</a><span>.</span></p></blockquote><p>Some interesting facts about Task:</p><ul><li><p>Written in Go</p></li><li><p>Single binary with no other dependencies</p></li><li><p>Taskfile is just a dialect of YAML format with a specific syntax</p></li><li><p><span>8k stars on </span><a href="https://github.com/go-task/task" rel="nofollow ugc noopener">GitHub</a><span> at the time of writing</span></p></li></ul><p>Between the features of this tool we can find:</p><ul><li><p>You can build a pipeline of tasks in parallel or in sequence, call other tasks from other Taskfiles, and have tasks that run as dependencies.</p></li><li><p><span>Tasks can be exposed (aka public) or </span><code>internal</code><span> (aka private)</span></p></li><li><p><span>You can run a task&#39;s cleanup using Go&#39;s </span><code>defer</code><span> command</span></p></li><li><p>Prevent unnecessary work (similar to how Makefile works)</p></li><li><p>Reference environment variables already defined in the shell environment</p></li><li><p>Tasks can be templated using Go&#39;s template engine</p></li><li><p>Dry run mode</p></li></ul><p>The list of features goes on and on. More on the official docs.</p><p><span>Here it is a simple Taskfile taken from </span><code>taskfile.dev</code></p><pre><code><code>version: &#39;3&#39;

tasks:
  build:
    cmds:
      - go build -v -i main.go

  assets:
    cmds:
      - esbuild --bundle --minify css/index.css &gt; public/bundle.css
</code></code></pre><p>Please refer to the official documentation for how to install the tool and to see sample use of those features.</p><p><span>The perfect one-liner to describe Direnv can be found in their official documentation </span><a href="https://direnv.net/" rel="nofollow ugc noopener">direnv.net</a></p><blockquote><p>direnv – unclutter your .profile</p></blockquote><p>and then:</p><blockquote><p><code>direnv</code><span> is an extension for your shell. It augments existing shells with a new feature that can load and unload environment variables depending on the current directory</span></p></blockquote><p>Some noticeable facts about Direnv:</p><ul><li><p>Single binary</p></li><li><p>Written in Golang</p></li><li><p>Integrates with your shell (eg. bash, zsh, fish, and more)</p></li><li><p><span>It supports </span><a href="https://12factor.net/config" rel="nofollow ugc noopener">12 factor apps</a><span> where you store your configs in environment variables or config files</span></p></li><li><p><span>10k starts on </span><a href="https://github.com/direnv/direnv/tree/master" rel="nofollow ugc noopener">GitHub</a><span> at the time of writing</span></p></li></ul><p><span>I mostly use it to define environment variables on </span><code>.env</code><span> files and then load them into my shell automatically when I </span><code>cd</code><span> into a directory with a </span><code>.envrc</code><span> file.</span></p><p><span>For example, if I have a </span><code>.envrc</code><span> with the following content</span></p><pre><code><code>dotenv

dotenv ../golang/.env
</code></code></pre><p><span>I will be able to load environment variables both from a </span><code>.env</code><span> in the current directory and also from a file at </span><code>../golang/.env</code><span>.</span></p><p><span>This way of splitting environment variables into different files allows for better reusability over the long term. If you only need Golang in your next project, you can just bring with you </span><code>golang/.env</code><span> file.</span></p><p><span>Devenv is probably the most complicated of these three tools but also the most powerful. With &#34;only&#34; 2.2k stars on </span><a href="https://github.com/cachix/devenv" rel="nofollow ugc noopener">GitHub</a><span> it is still in the early stages of its life but it is already very powerful.</span></p><p><span>The one-liner from the official </span><a href="https://devenv.sh/" rel="nofollow ugc noopener">documentation</a><span> states</span></p><blockquote><p>Use a simple unified configuration to configure packages, processes, services, scripts, git hooks, integrations.</p></blockquote><p><span>Devenv is based on </span><a href="https://nixos.org/" rel="nofollow ugc noopener">Nix</a><span> a powerful package manager and system configuration tool, that comes with its own language. I&#39;m not qualified to explain what Nix is, and this is not even the right place for it. Suffice it to say, I don&#39;t know how to write Nix code and I didn&#39;t need to learn it so far. I&#39;m only using it here via a higher-level abstraction.</span></p><p>Devenv deserves an entire post to describe all its features and use cases. Here I&#39;m only using it to describe dependencies (in the shape of command line tools) that I would like to have installed on my laptop.</p><pre><code><code>{ pkgs, ... }:

{
	packages = [ 
	    pkgs.git 
	    pkgs.govulncheck
	    pkgs.gofumpt 
	    pkgs.go-swag
	    pkgs.gocyclo
	];
}
</code></code></pre><p>In this example, I use to install a few command line tools that I use to write Golang applications.</p><p>This file is enough to tell what dependencies I have in my project, Devenv will make sure those are installed in an isolated and reproducible environment.</p><div data-attrs="{&#34;url&#34;:&#34;https://cloudnativeengineer.substack.com/p/ep-5-taskfile-a-modern-alternative?utm_source=substack&amp;utm_medium=email&amp;utm_content=share&amp;action=share&#34;,&#34;text&#34;:&#34;Share&#34;}" data-component-name="CaptionedButtonToDOM"><p>Thank you for reading Cloud Native Engineer. This post is public so feel free to share it.</p><p data-attrs="{&#34;url&#34;:&#34;https://cloudnativeengineer.substack.com/p/ep-5-taskfile-a-modern-alternative?utm_source=substack&amp;utm_medium=email&amp;utm_content=share&amp;action=share&#34;,&#34;text&#34;:&#34;Share&#34;}" data-component-name="ButtonCreateButton"><a href="https://cloudnativeengineer.substack.com/p/ep-5-taskfile-a-modern-alternative?utm_source=substack&amp;utm_medium=email&amp;utm_content=share&amp;action=share" rel="nofollow ugc noopener"><span>Share</span></a></p></div><p>It is finally time to put those three projects together and explain how I use them in my framework.</p><p>Structure of the project</p><ul><li><p>Taskfile.yml</p></li><li><p>taskfiles/</p><ul><li><p>golang.taskfile.yml</p></li><li><p>docker.taskfile.yml</p></li></ul></li><li><p>envs/</p><ul><li><p>golang/</p><ul><li><p>.env</p></li></ul></li><li><p>docker/</p><ul><li><p>.env</p></li><li><p>.envrc</p></li></ul></li></ul></li><li><p>devenv.nix</p></li><li><p>... (other files omitted for brevity) ...</p></li></ul><p><span>Here </span><code>Taskfile.yml</code><span> is just the entry point to all other taskfiles. Tasks are split into multiple files to achieve a nice separation of concerns:</span></p><pre><code><code>version: &#39;3&#39;

includes:
  docker: taskfiles/docker.taskfile.yml
  go: taskfiles/go.taskfile.yml
</code></code></pre><p><span>Here we have a </span><code>golang.taskfile.yml</code><span> used to build a Golang application</span></p><pre><code><code>version: &#39;3&#39;

tasks:  
  build:
    cmds:
      - GOOS={{.CMD_GOOS}} GOARCH={{.CMD_GOARCH}} go build -o build/hello cmd/hello.go
</code></code></pre><p><span>and a </span><code>docker.taskfile.yml</code><span> used to build a Docker image from the Golang binary and a Dockerfile</span></p><pre><code><code>version: &#39;3&#39;

includes:
  go: taskfiles/go.taskfile.yml

tasks:  
  build:
    deps:
      - go:build
    cmds:
      - docker build -t {{.DOCKER_IMAGE}}:{{.DOCKER_TAG}} -f Dockerfile .
</code></code></pre><p><span>Here we have a file </span><code>envs/golang/.env</code><span> used to define the environment variable for the Golang application</span></p><pre><code><code>CMD_GOOS=linux
CMD_GOARCH=arm64
</code></code></pre><p><span>and another file </span><code>envs/docker/.env</code><span> used instead for Docker environment variables</span></p><pre><code><code>DOCKER_IMAGE=hello
DOCKER_TAG=v1.0
</code></code></pre><p><span>Furthermore we have a file </span><code>envs/docker/.envrc</code><span> that tides together the two .env files and load environment variables from both</span></p><pre><code><code>dotenv

dotenv ../golang/.env
</code></code></pre><p><span>Finally a file </span><code>devenv.nix</code><span> used to install Taskfile and Golang</span></p><pre><code><code>{ pkgs, ... }:

{
	packages = [ 
	    pkgs.go-task
	];

	languages.go.enable = true;
}
</code></code></pre><p><span>Devenv comes with more files than just </span><code>devenv.nix</code><span>. Here we haven&#39;t discussed about them since they don&#39;t really need human intervention.</span></p><p>In order for this framework to work, there are a couple of assumptions:</p><ul><li><p>Devenv and Direnv needs to be installed</p></li><li><p>Taskfile will be installed via devenv but alternatively you can install it via brew</p></li><li><p>We assume that you have already installed Docker on your laptop.</p></li><li><p>No need to install Golang</p></li></ul><p>If you want to build the docker image you only need to run the following commands</p><pre><code><code>cd envs/docker
task docker:build
</code></code></pre><p><span>Changing the directory will instruct Direnv to load the environment variables from the relative </span><code>.env</code><span> file, while the second command will build the docker image after having built the binary from the source code.</span></p><p>It is that simple!</p><p><span>Now you have a reusable framework to build container images for your Golang applications. You can copy the content of these files to your Golang application and just change the content of the </span><code>.env</code><span> files without touching anything else.</span></p><p>I know this is a small artificial project, but I hope you can see the power of this framework and expand it for your use case.</p><p>Once you spend enough time with this framework, you are going to be able to run automation scripts that can save you hours of manual toil.</p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F3303a55d-0982-4d34-8e1d-1b0f5e748e94_535x466.jpeg" data-component-name="Image2ToDOM" rel="nofollow ugc noopener"><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F3303a55d-0982-4d34-8e1d-1b0f5e748e94_535x466.jpeg 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F3303a55d-0982-4d34-8e1d-1b0f5e748e94_535x466.jpeg 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F3303a55d-0982-4d34-8e1d-1b0f5e748e94_535x466.jpeg 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F3303a55d-0982-4d34-8e1d-1b0f5e748e94_535x466.jpeg 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F3303a55d-0982-4d34-8e1d-1b0f5e748e94_535x466.jpeg" width="535" height="466" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/3303a55d-0982-4d34-8e1d-1b0f5e748e94_535x466.jpeg&#34;,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:466,&#34;width&#34;:535,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:53599,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:&#34;image/jpeg&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;topImage&#34;:false,&#34;internalRedirect&#34;:null}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F3303a55d-0982-4d34-8e1d-1b0f5e748e94_535x466.jpeg 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F3303a55d-0982-4d34-8e1d-1b0f5e748e94_535x466.jpeg 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F3303a55d-0982-4d34-8e1d-1b0f5e748e94_535x466.jpeg 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F3303a55d-0982-4d34-8e1d-1b0f5e748e94_535x466.jpeg 1456w" sizes="100vw" loading="lazy"/></picture></div></a></figure></div><p>I&#39;m sorry for the very long post but I couldn&#39;t make it shorter. There was a lot to unpack and I couldn&#39;t miss the opportunity to add those memes.</p><p>I&#39;ll probably write a more elaborate post where I provide some samples of how I am using this automation framework for real use cases.</p><p>I hope that you will adopt one of those tools or all of them. If you find any of those useful, please star them on GitHub to drive adoption.</p></div></div></div></article></div></div></div>
  </body>
</html>
