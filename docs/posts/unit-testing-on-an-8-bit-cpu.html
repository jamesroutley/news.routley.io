<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://boston.conman.org/2023/11/27.1">Original</a>
    <h1>Unit testing on an 8-bit CPU</h1>
    
    <div id="readability-page-1" class="page"><div id="content">

<!-- google_ad_section_start --> <!-- Hey, it can't hurt! -->
<h2><a name="2023-11-27" href="https://boston.conman.org/2023/11/27">Monday, November 27, 2023</a></h2>

<h3><a rel="bookmark" name="2023-11-27.1" href="https://boston.conman.org/2023/11/27.1">Unit testing on an 8-bit CPU</a></h3>

<!-- programming, testing, unit testing, 8-bit CPU programming, retro programming, 6809 -->

<p>I&#39;ve been using my <a href="https://boston.conman.org/2023/11/24.1">assembler</a> to write silly little programs for the <a href="https://en.wikipedia.org/wiki/TRS-80_Color_Computer">Color Computer</a>
(<a href="http://www.6809.org.uk/xroar/">simulated</a>—easier than setting up my Color Computer, the first computer I owned as a kid).
It took me entirely too long to locate a bug in a maze-drawing program I&#39;ve been writing,
and I want to do a deep dive on this.</p>

<p>The program is simple,
it just draws a maze,
following a few simple rules:</p>

<ol>
<li>pick a random direction (up, right, left or down);</li>
<li>attempt to draw a maze segment (using color 1) in the given direction;</li>
<li>if we&#39;re boxed in (no direction to go in)—<ol>
	<li>if we&#39;re at the starting location, we&#39;re done;</li>
	<li>backtrack along a segment of the path we&#39;ve drawn (using color 2);</li>
	<li>if we are no longer boxed in, go back to step 1;</li>
	<li>otherwise, go back to step 3.</li></ol></li>
</ol>

<p>Nothing hard about it,
yet the program kept getting stuck.</p>

<p><img src="https://boston.conman.org/2023/11/27/stuck-maze.png" width="320" height="240" alt="[Image of a partially drawn maze]" title="It&#39;s hardly a maze, thus, it&#39;s hardly amazing"/>
</p>

<p>It starts in the upper left,
meanders a bit
(in blue),
backtracks a bit
(in red)
until it gets stuck.
I would then stare at the code until blood formed on my brow,
simplify the code if I could,
and try again only to watch it get stuck,
again.</p>

<p>The issue is that I have no debugger on this system.
I don&#39;t have two screens upon which to show debugging output.
I have no way of single-stepping though the code.
I don&#39;t even have a log to go through.
Debugging consists of running the code,
then thinking real hard.
And yes,
it was a stupid mistake that took all of two lines of code to fix.</p>

<p><img src="https://boston.conman.org/2023/11/27/maze.png" width="320" height="240" alt="[Image of a fully drawn maze]" title="Woot!  A maze!  That&#39;s inging!  Amazing!"/>
</p>

<p>Now,
the question I want to ask is—would I have saved time if I did “unit testing?”
Not just testing,
which I was doing all along,
but the typical style of “unit testing” where you test a “unit” of code
(<a href="https://boston.conman.org/2023/11/19.1">getting back to <em>that</em> question again</a>).
Looking over <a href="https://boston.conman.org/2023/11/27/maze-bug.asm">the code</a>
(and that version <em>has</em> the bug—see if you can find it;
you&#39;ll also need these
<a href="https://boston.conman.org/2023/11/27/Coco-DP.i">two</a> <a href="https://boston.conman.org/2023/11/27/Coco-video.i">files</a>),
the most isolated “unit” is <code>random</code>
(the last subroutine in the code).</p>

<pre title="Assembly">;***********************************************************************
;	RANDOM		Generate a random number
;Entry:	none
;Exit:	B - random number (1 - 255)
;***********************************************************************

random		ldb	lfsr
		andb	#1
		negb
		andb	#$B4
		stb	,-s		; lsb = -(lfsr &amp; 1) &amp; taps
		ldb	lfsr
		lsrb			; lfsr &gt;&gt;= 1
		eorb	,s+		; lfsr ^=  lsb
		stb	lfsr
		rts
</pre>


<p>It implements <a href="https://en.wikipedia.org/wiki/Linear-feedback_shift_register">a linear-feedback shift register</a>
with a period of 255
(in that it will return each value in the range of 1‥255 once in some randomesque order before repeating,
which is Good Enough™ for this code).
So what if we want to test that the code is correct?</p>

<p>And it&#39;s here I came to a realization—“unit testing” really depends upon the language and tooling around it.
Modern orthodoxy holds “unit testing über alles” and therefore,
modern languages and tooling is created to support “unit testing über alles”
(and woe betide those who question it).
I think my struggle with “unit testing” is that the environments I find myself in don&#39;t lend themselves very well to “unit testing.”
Even when I worked at The Enterprise,
we were using C (C99 at best) and C++ (C++98, <em>maybe</em> C++03?) which take a lot of work upfront to support “unit testing” well,
and there wasn&#39;t a lot of work upfront to support “unit testing” well,
and there was a decidely lack of a “unit testing” framework.
And here,
there&#39;s definitely not a “unit testing” framework.
Any “unit testing” I have to do involves writing <em>yet more code</em>.
So let&#39;s write <em>yet more code</em> and test this sucker.</p>

<pre title="Assembly">CHROUT		equ	$A002		; BASIC character output routine
lfsr		equ	$F6		; unused location in direct page

		org	$4000

start		ldx	#result_array	; point to memory
		clra			; storing 0 to memory
		clrb			; 256 bytes to clear

.clrarray	sta	,x+		; clear memory
		decb			; decrement count
		bne	.clrarray	; keep going until count = 0

		ldx	#result_array	; point to array
		lda	#255		; cycle length

checkrnd	bsr	random		; get random number in B
		tst	b,x		; have we seen this number?
		bne	.failed		; if so, we have failed
		inc	b,x		; set flag for this number
		deca			; are we done with the cycle
		bne	checkrnd	; if not, keep going

		ldx	#msg.success	; SUCCESS!
		bsr	puts
		rts

	;---------------------------------------------------
	; Store count (register A) and random # (register B) 
	; so we can use PEEK in BASIC to see where we failed
	;---------------------------------------------------

.failed		std	lfsr+1
		ldx	#msg.failed	; failed message
		bsr	puts		; display it
		rts			; return to BASIC

puts.10		jsr	[CHROUT]	; print character
puts		lda	,x+		; get character
		bne	puts.10		; if not NUL, print it
		rts			; return to BASIC

;******************************************************************

random		ldb	lfsr
		andb	#1
		negb
		andb	#$B4
		stb	,-s		; lsb = -(lfsr &amp; 1) &amp; taps
		ldb	lfsr
		lsrb			; lfsr &gt;&gt;= 1
		eorb	,s+		; lfsr ^=  lsb
		stb	lfsr
		rts

;*******************************************************************

msg.success	asciiz	&#39;SUCCESS!\r&#39;
msg.failed	asciiz	&#39;FAILED!\r&#39;
result_array	equ	*
		end	start
</pre>


<p>The tooling here doesn&#39;t support linking 6809 code,
and I&#39;d rather not have to keep each routine in its own file since the program is so simple and makes editing it easier if everything is in one file
(no <abbr title="Integrated Development Environment">IDE</abbr> here—and yes,
I have thoughts about testing and <abbr title="Integrated Development Environment">IDE</abbr>s but that&#39;s beyond the scope for this post).
So I have to copy the routine to the test program.</p>

<p>This was something I kept trying to tell my manager at The Enterprise—the test program itself might be buggy
(he personally treated the output as gospel—sigh).
And the “unit testing” proponents seem to hem and haw about testing the testing code,
implying that one does not simply test the testing code.
But if programmers aren&#39;t trusted to write code and must test,
then why are they trusted to write testing code without testing?</p>

<p>It might seem I digress,
but I&#39;m not.
There are <em>four</em> bugs in the above test.
The code I&#39;m testing, <code>random</code>?
It was fine.
And I wasn&#39;t intending to write a buggy test harness,
it just happened as I was writing it.
Bug one—I forgot to test that <code>random</code> didn&#39;t return 0
(that&#39;s a degenerate case with <abbr title="Linear-Feedback Shift Register">LFSR</abbr>s).
Second bug—I forgot to ininitialize the <abbr title="Linear-Feedback Shift Register">LFSR</abbr> state with a non-zero value,
so <code>random</code> would return nothing <em>but</em> zero.
The third bug was thinking I had used the wrong condition when branching to the failure case,
but no,
I had it right the first time
(the fact that I changed it, and then changed it back, is the bug).
The actual bug that caused this was the fourth bug,
but I have to digress a bit to explain it.</p>

<p>The 6809 has an extensive indexing addressing mode for an 8-bit <abbr title="Central Processing Unit">CPU</abbr>.
One of the modes allow one to use an accumulator register (<code>A</code>, <code>B</code> or <code>D</code>)
as an offset to the index register.
I used the <code>B</code> register,
which contains the random number,
as an offset into a 256-element array to track the return values,
thus the use of <code>b,x</code> in the code above.
What I forgot about in the moment of writing the code is that the “accumulator,index-register” indexing mode <em>sign extends</em> the accumulator.
And the first value from <code>random</code> is,
due to the <abbr title="Linear-Feedback Shift Register">LFSR</abbr> I&#39;m using,
if treated as signed,
a negative value—it would fail on the very first attempt.</p>

<p>Sigh.</p>

<p>This is why I panicked and thought I botched the conditional branch.</p>

<p>Now,
all of that just to test the most isolated of subroutines in the program.</p>

<p>But had I continued,
would any form of “unit testing” been beneficial?
There&#39;s the subroutine <code>point_addr</code>—which converts an X,Y position into a byte address in the frame buffer,
and the pixel in said byte.
I could have done an exhaustive test of all 4,096 points,
again,
that&#39;s code I would have write
(in 6809 Assembly code)
and unfortunately, test,
to have any confidence in it.
And working up the chain,
there&#39;s <code>getpixel</code> and <code>setpixel</code>.
Testing those would require a bit of thought—let&#39;s see … <code>getpixel</code> returns the color of the pixel at the given X,Y location on the screen.
and assuming <code>point_addr</code> is working,
it would only take four tests
(one per pixel in the byte)
but at this point,
would I even trust myself to write the test code?</p>

<p>In fact,
would “unit testing” have saved me <em>any</em> time?</p>

<p>Given that I would have to write the testing framework,
no,
I don&#39;t think I would have saved time.
Perhaps if I thought the issue through before diving into changing the code,
I would have solved this earlier.</p>

<p>And the clues were there.
I did discover pretty early on that the bug was in the backtracking code.
The top level code is pretty easy to visually inspect:</p>

<pre title="Assembly">backtrack	lda	#BACKTRACK
		sta	color

.loop		ldd	xpos		; check to see if we&#39;re back
		cmpd	xstart		; at the starting point,
		beq	done		; and if so, we&#39;re done

		ldd	xpos		; can we backtrack NORTH?
		decb
		lbsr	getpixel
		cmpb	#EXPLORE
		bne	.check_east
		lbsr	move_north.now	; if so, move NORTH and see if
		bra	.probe		; we have to keep backtracking

.check_east	ldd	xpos		; east ...
		inca
		lbsr	getpixel
		cmpb	#EXPLORE
		bne	.check_west
		lbsr	move_east.now
		bra	.probe

.check_west	ldd	xpos		; yada yada ...
		deca
		lbsr	getpixel
		cmpb	#EXPLORE
		bne	.check_south
		lbsr	move_west.now
		bra	.probe

.check_south	ldd	xpos
		incb
		lbsr	getpixel
		cmpb	#EXPLORE
		bne	.probe
		lbsr	move_south.now

.probe		bsr	boxed_in	; can we stop backtracking?
		bne	explore		; if so, go back to exploring
		bra	.loop		; else backtrack some more
</pre>


<p>The thing to keep in mind here is that the <code>D</code> register is a 16-bit register where the upper 8-bits is the <code>A</code> register,
and the lower 8-bits are the <code>B</code> register,
and that the 6809 is big-endian.
So when we do <code>ldd xpos</code> we are loading the <code>A</code> register with the X coordinate,
and <code>B</code> with the Y coordinate.
And the <code>move_*.now</code> subroutines work,
or else we wouldn&#39;t get the starting maze segments at all.
So it&#39;s clear that <code>setpixel</code> works fine.</p>

<p>The code is getting stuck trying to backtrack along already drawn segments,
and it does that by calling <code>getpixel</code>,
therefore,
it seems prudent to check <code>getpixel</code>.
And sure enough,
that is where the bug resides.</p>

<pre title="Assembly">;*************************************************************************
;	GETPIXEL	Get the color of a given pixel
;Entry:	A - x pos
;	B - y pos
;Exit:	X - video address
;	A - 0
;	B - color
;*************************************************************************

getpixel	bsr	point_addr	; get video address
		comb			; reverse mask (since we&#39;re reading
		stb	,-s		; the screen, not writing it)
		ldb	,x		; get video data
		andb	,s+		; mask off the pixel
.rotate		lsrb			; shift color bits
		deca
		bne	.rotate
.done		rts			; return color in B

;*************************************************************************
;	POINT_ADDR		calculate the address of a pixel
;Entry:	A - xpos
;	B - ypos
;Exit:	X - video address
;	A - shift value
;	B - mask
;*************************************************************************


point_addr.bits	fcb	%00111111,%11001111,%11110011,%11111100 ; masks
		fcb	6,4,2,0	; bit shift counts
</pre>


<p>I&#39;ve included a bit of <code>point_addr</code> to give some context.
<code>point_addr</code> returns the number of shifts required to move the color value into place,
and one of those shift values is 0.
But <code>getpixel</code> doesn&#39;t check to see it&#39;s 0 before decrementing it.
And thus,
<code>getpixel</code> will return the wrong value for the last pixel in any byte.
The fix is simple:</p>

<pre title="Assembly">		tsta
		beq	.done
</pre>


<p>just before the <code>.rotate</code> label fixes the bug
(two instructions, three bytes and here&#39;s a link to the <a href="https://boston.conman.org/2023/11/27/maze.asm">fixed code</a>).</p>

<p>Yes,
I freely admit that a “unit test“ of this subroutine would have shown the bug.
But how much time would I have spent writing the test code to begin with?
The only reason it took me as long as it did to find was because the reference code I was using was quite convoluted,
and I spent time simplifying the code as I went along
(which is worthy of doing anyway).</p>

<p>What I wish the “unit testing” proponents would realize is that easy testing depends upon the language and tooling involved in the project,
and what a “unit” is truly depends upon the language.
I suspect that “unit test” proponents also find “unit testing” easier to deal with than “integration testing” or even “end-to-end testing,”
thus why we get “unit tests über alles” shouted from the roof tops.</p>

<hr/>

<h4>Discussions about this entry</h4>

<ul>
<li><a href="https://zerobytes.monster/post/3904613">Unit testing on an 8-bit CPU - ZeroBytes</a></li>
<li><a href="https://derp.foo/post/444794">Unit testing on an 8-bit CPU - derp.foo</a></li>
<li><a href="https://news.ycombinator.com/item?id=38443368">Unit testing on an 8-bit CPU | Hacker News</a></li>
<li><a href="https://twostopbits.com/item?id=1143">Two Stop Bits | Unit testing on an 8-bit CPU</a></li>

</ul>


<!-- google_ad_section_end -->
</div></div>
  </body>
</html>
