<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://timbaumann.info/svd-image-compression-demo/">Original</a>
    <h1>Image Compression with Singular Value Decomposition</h1>
    
    <div id="readability-page-1" class="page"><div>
        <h2>About Singular Value Decomposition</h2>
        <p>
          A matrix of size <span>m × n</span> is a grid of real numbers consisting of <span>m</span> rows and <span>n</span> columns.
          In linear algebra, a branch of mathematics, matrices of size <span>m × n</span> describe linear mappings from <span>n</span>-dimensional to <span>m</span>-dimensional space.
          The word linear roughly means that straight lines map to straight lines and the origin in <span>n</span>‑dimensional space maps to the origin in <span>m</span>‑dimensional space.
          When we have an <span>(m × n)</span>‑matrix <span>A</span> and a <span>(n × k)</span>‑matrix <span>B</span>, we can compute the product <span>AB</span> which is an <span>(m × k)</span>‑matrix.
          The mapping corresponding to <span>AB</span> is exactly the composition of the mappings corresponding to <span>A</span> and <span>B</span> respectively.
        </p>
        <p>
          <a href="https://en.wikipedia.org/wiki/Singular_value_decomposition">Singular Value Decomposition</a> (SVD) states that every <span>(m × n)</span>‑matrix <span>A</span> can be written as a product
        </p>
        
        <p>
          where <span>U</span> and <span>V</span> are orthogonal matrices and the the matrix <span>Σ</span> consists of descending non-negative values on its diagonal and zeros elsewhere.
          The entries <span>σ<sub>1</sub> ≥ σ<sub>2</sub> ≥ σ<sub>3</sub> ≥ … ≥ 0</span> on the diagonal of <span>Σ</span> are called the <em>singular values</em> (SVs) of <span>A</span>.
          Geometrically, <span>Σ</span> maps the <span>j</span>‑th unit coordinate vector of <span>n</span>‑dimensional space to the <span>j</span>‑th coordinate vector of <span>m</span>‑dimensional space, scaled by the factor <span>σ<sub>j</sub></span>.
          Orthogonality of <span>U</span> and <span>V</span> means that they correspond to rotations (possibly followed by a reflection) of <span>m</span>‑dimensional and <span>n</span>‑dimensional space respectively.
          Therefore only <span>Σ</span> changes the length of vectors.
        </p>
        <h2>Using SVD for image compression</h2>
        <p>
          We can decompose a given image into the three color channels red, green and blue.
          Each channel can be represented as a <span>(m × n)</span>‑matrix with values ranging from 0 to 255.
          We will now compress the matrix <span>A</span> representing one of the channels.
        </p>
        <p>
          To do this, we compute an approximation to the matrix <span>A</span> that takes only a fraction of the space to store.
          Now here&#39;s the great thing about SVD: the data in the matrices <span>U</span>, <span>Σ</span> and <span>V</span> is sorted by how much it contributes to the matrix <span>A</span> in the product.
          That enables us to get quite a good approximation by simply using only the most important parts of the matrices.
        </p>
      </div><div>
        <p>
          We now choose a number <span>k</span> of singular values that we are going to use for the approximation.
          The higher this number, the better the quality of the approximation gets but also the more data is needed to encode it.
          We now take only the first <span>k</span> columns of <span>U</span> and <span>V</span> and the upper left <span>(k × k)</span>-square of <span>Σ</span>, containing the <span>k</span> largest (and therefore most important) singular values.
          We then have
        </p>
        
        <p>
          The amount of data needed to store this approximation is proportional to the colored area:
        </p>
        <p>
          compressed size = <span>m × k</span> + <span>k</span> + <span>k × n</span> = k × (<span>1</span> + <span>m</span> + <span>n</span>)
        </p>
        <p>
          (Actually, slightly less space is needed due to the orthogonality of <span>U</span> and <span>V</span>.)
          One can prove that this approximation is <a href="https://en.wikipedia.org/wiki/Low-rank_approximation#Basic_low-rank_approximation_problem" title="Eckart–Young–Mirsky theorem">optimal in a certain sense</a>.
        </p>
        <p>
          This demo lets you choose the number of singular values <span>k</span> and see how this choice affects the quality of the approximation and the compression rate.
          Notice how for all photographs, the graph showing the singular values looks like a hyperbola: there are only a few really large SVs and a long tail of relatively smaller SVs.
          In contrast, for the random noise image the graph of SVs looks roughly linear.
        </p>
        <p>
          SVD is routinely used in statistics for <a href="https://en.wikipedia.org/wiki/Principal_component_analysis">principal component analysis</a> and in numerical simulations for <a href="https://en.wikipedia.org/wiki/Model_order_reduction">reducing the order of models</a>.
          For image compression, more sophisticated methods like <a href="https://www.youtube.com/watch?v=n_uNPbdenRs">JPG</a> that take human perception into account generally outperform compression using SVD.
        </p>
        <h2>About this demo</h2>
        <p>
          The computation of the SVD is performed on the client-side using <a href="https://webassembly.org/">WebAssembly</a>.
          We use the algorithm implemented by the Rust library <a href="https://nalgebra.org/">nalgebra</a>.
          The SVDs of all three color channels are computed in parallel using one <a href="https://en.wikipedia.org/wiki/Web_worker">web worker</a> for every channel.
          To provide the quick preview, we use <a href="https://research.facebook.com/blog/294071574113354/fast-randomized-svd/">a randomized algorithm</a> to compute an approximate truncated SVD with 50 singular values.

          The user interface uses <a href="http://facebook.github.io/react/">React</a>, <a href="https://github.com/akiran/react-slick">react-slick</a> and <a href="http://refreshless.com/nouislider/">noUiSlider</a>.
          Thanks to the creators of all these great projects!
        </p>
      </div></div>
  </body>
</html>
