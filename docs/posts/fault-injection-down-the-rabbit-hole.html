<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://security.humanativaspa.it/fault-injection-down-the-rabbit-hole/">Original</a>
    <h1>Fault Injection – Down the Rabbit Hole</h1>
    
    <div id="readability-page-1" class="page"><div>
	<div>

		<!-- Article -->
		<div>

		
		<article id="post-4682">
			<!-- .entry-header -->

			<!---->

					<div>
						<h3>Intro</h3>
<p>This <a href="https://security.humanativaspa.it/tag/fault-injection">series</a> of articles describes <strong>fault injection attack techniques</strong> in order to understand their real potential by testing their limits and applicability with limited hardware (available on the market at an acceptable cost). It explores possible ways of using an attack that, in my opinion, is <strong>greatly underestimated</strong>.</p>
<p>First of all, I want to thank <a href="https://twitter.com/pulsoid">@pulsoid</a> and <a href="https://twitter.com/tieknimmers">@tieknimmers</a> for their excellent <em>Fault inject advanced</em> course (<a href="https://raelize.com/taofi/">TAoFI – The Art of Fault Injection</a>) that I attended. In their training, they provide great insights and ideas, thanks to their pioneering work and passionate pursuit of these topics. One of the mantras of the course was “<strong>Don’t glitch and pray</strong>” (© <a href="https://raelize.com/">Raelize</a>), and I tried to internalize this concept as much as possible. These articles were born precisely from that.</p>
<p>The term <em>glitching</em> refers to an <strong>external behavior that causes a chip to enter an anomalous state</strong>, allowing for the <strong>creation of a fault</strong>, which is an internal error that enables the execution of something different from what was expected. Let’s start with the basics. There are four main techniques for performing fault injection on a chip:</p>
<ul>
<li><strong>Voltage glitching</strong></li>
<li><strong>Clock glitching</strong></li>
<li><strong>Electromagnetic glitching</strong></li>
<li><strong>Optical glitching (laser)</strong></li>
</ul>
<p>I will focus on the voltage glitching part, as it is one of the most approachable techniques with limited hardware. The basic concept is that we “deprive” the chip of power, making it “unstable”.</p>
<p>There are several ways to perform voltage glitching, primarily:</p>
<ul>
<li>Crowbar to ground (used by ChipWhisperer)</li>
<li>Crowbar to high voltage (which risks burning the chip)</li>
<li>Controlled VCC (by providing a controlled different voltage)</li>
</ul>
<p>For now, we will use the <strong>crowbar to ground</strong> technique, which is used by <a href="https://www.newae.com/chipwhisperer">ChipWhisperer</a> devices. During the tests, I mainly used <a href="https://rtfm.newae.com/Capture/ChipWhisperer-Husky/">ChipWhisperer-Husky</a>. A detailed description of the technique can be found at: <a href="https://eprint.iacr.org/2016/810.pdf">https://eprint.iacr.org/2016/810.pdf</a></p>
<p>As for the target of these attacks, I have chosen to work on <strong>ESP32</strong> for various reasons, primarily:</p>
<ul>
<li>There is already a lot of available material on attacks.</li>
<li>There is a “patched” v3 chip that should solve multiple issues on which it will be possible to test the resistance of the countermeasures implemented.</li>
<li>It was the chip used in the TaoFI course, so I already have a working board ready.</li>
</ul>
<p>The main <strong>past works</strong> on these chips are the following (hoping to mention them all):</p>
<ul>
<li>Pwn the ESP32 Secure Boot <a href="https://limitedresults.com/2019/09/pwn-the-esp32-secure-boot/">https://limitedresults.com/2019/09/pwn-the-esp32-secure-boot/</a></li>
<li>Pwn the ESP32 Forever: Flash Encryption and Sec. Boot Keys Extraction <a href="https://limitedresults.com/2019/11/pwn-the-esp32-forever-flash-encryption-and-sec-boot-keys-extraction/">https://limitedresults.com/2019/11/pwn-the-esp32-forever-flash-encryption-and-sec-boot-keys-extraction/</a> + <a href="https://www.youtube.com/watch?v=vwwTC_ivG00">https://www.youtube.com/watch?v=vwwTC_ivG00</a></li>
<li>Espressif ESP32: Bypassing Secure Boot using EMFI <a href="https://raelize.com/blog/espressif-systems-esp32-bypassing-sb-using-emfi/">https://raelize.com/blog/espressif-systems-esp32-bypassing-sb-using-emfi/</a></li>
<li>Espressif ESP32: Controlling PC during Secure Boot <a href="https://raelize.com/blog/espressif-systems-esp32-controlling-pc-during-sb/">https://raelize.com/blog/espressif-systems-esp32-controlling-pc-during-sb/</a></li>
<li>Espressif ESP32: Bypassing Flash Encryption (CVE-2020-15048) <a href="https://raelize.com/blog/espressif-systems-esp32-bypassing-flash-encryption/">https://raelize.com/blog/espressif-systems-esp32-bypassing-flash-encryption/</a></li>
<li>Espressif ESP32: Bypassing Encrypted Secure Boot (CVE-2020-13629) <a href="https://raelize.com/blog/espressif-esp32-bypassing-encrypted-secure-boot-cve-2020-13629/">https://raelize.com/blog/espressif-esp32-bypassing-encrypted-secure-boot-cve-2020-13629/</a></li>
<li>Unlimited Results: Breaking Firmware Encryption of ESP32-V3 <a href="https://eprint.iacr.org/2023/090.pdf">https://eprint.iacr.org/2023/090.pdf</a> + <a href="https://www.youtube.com/watch?v=wfZHQocTsZo">https://www.youtube.com/watch?v=wfZHQocTsZo</a></li>
<li>Breaking the Flash Encryption Feature of Espressif’s Parts <a href="https://courk.cc/breaking-flash-encryption-of-espressif-parts">https://courk.cc/breaking-flash-encryption-of-espressif-parts</a></li>
<li>Fault Injection Attacks against the ESP32-C3 and ESP32-C6 <a href="https://courk.cc/esp32-c3-c6-fault-injection">https://courk.cc/esp32-c3-c6-fault-injection</a></li>
<li>Breaking Espressif’s ESP32 V3: Program Counter Control with Computed Values using Fault Injection <a href="https://www.usenix.org/conference/woot24/presentation/delvaux">https://www.usenix.org/conference/woot24/presentation/delvaux</a></li>
</ul>
<p>I encourage you to read them to get familiar with the topic, otherwise you will likely struggle to understand the rest of this article.</p>
<h3>Let’s start</h3>
<p>Let’s now try to create a “clean” situation that allows us to better explore what happens with glitching.</p>
<p><strong>Unlike many examples found online, our goal is not to skip an instruction but to understand what else can happen and why. Thus, trying to make a “world” considered non-deterministic a little more deterministic.</strong></p>
<p>To do this, we need to:</p>
<ul>
<li>understand exactly which instruction(s) we are going to influence</li>
<li>know the context (including other registers, memory areas, etc.)</li>
</ul>
<p>So:</p>
<ul>
<li>we need to use as much <strong>ASM code as possible instead of C code in order to exclude unnecessary instructions</strong> (e.g., calls) that partially modify the context</li>
<li>find a method to have a <strong>clear view of the context without influencing it</strong></li>
<li>use a limited number of instructions, especially ones that allow us to understand which one we are influencing</li>
</ul>
<h3>Preparation of the test environment</h3>
<h4>Using as few instructions as possible</h4>
<p>Now let’s try to create an environment that is as clean as possible, and see how to improve the code that is normally used as a starting point.</p>
<p>Generally, when working on glitching examples, a <strong>trigger signal</strong> is used, which is when the code of our interest is executed. This helps us explore the data more precisely by narrowing down the scope.</p>
<p>This method is often used to change a trigger PIN:</p>
<pre data-enlighter-language="generic">GPIO_OUTPUT_SET(26,1);
</pre>
<p>However, if we look at how this is translated at the assembler level, it generates:</p>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20231122184428-2.png" alt="Pasted image 20231122184428.png"/></p>
<p>Essentially, the function “0x40009B24” (gpio_output_set) is called, which is present in the ROM. By disassembling the ROM, we can see what happens:</p>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20231121225520-2.png" alt="Pasted image 20231121225520.png"/></p>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20231121225803-2.png" alt="Pasted image 20231121225803.png"/></p>
<p>In the documentation, you can find details about the addresses used:</p>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20231121225741-2.png" alt="Pasted image 20231121225741.png"/></p>
<p>And, more specifically:</p>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20231121225917-2.png" alt="Pasted image 20231121225917.png"/></p>
<p>According to the reference manual, we can use GPIO_OUT_W1TS_REG to activate the pin and GPIO_OUT_W1TC_REG to deactivate it, thus eliminating a call and a series of unnecessary instructions that could cause problems during glitching.</p>
<p>The final assembler code will be:</p>
<pre data-enlighter-language="asm">// GPIO 26 PING HIGH using GPIO_OUT_W1TS
&#34;movi a11, 0x4000000;&#34;
&#34;movi a12, 0x3ff44008;&#34;
&#34;s32i.n  a11, a12, 0;&#34;

// GPIO 26 PIN LOW using GPIO_OUT_W1TC
&#34;movi a12, 0x3ff4400C;&#34;
&#34;movi a11, 0x4000000;&#34;
&#34;s32i.n  a11, a12, 0;&#34;
</pre>
<p>This way, we save instructions and tamper only with a very limited number of registers.</p>
<h4>Having a clear understanding of the context</h4>
<p>Once we have solved the initial problem, we need to find a simple way to maintain the context while <strong>losing as little information as possible</strong>.</p>
<p>My idea is to <strong>use CPU exceptions that allow to get a complete context</strong> (https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-guides/fatal-errors.html#illegal-instr-msg). The initial idea was to execute the code at the bootloader level to “speed up” the boot phase. However, the exceptions are directly handled by the ROM, and the classic “Guru meditation” has not been implemented yet:</p>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20240819215208-2.png" alt="Pasted image 20240819215208.png"/></p>
<p>The advantage is having a complete context, but the downside is that each attempt would require resetting the CPU, resulting in fewer tests. However, at this moment, I prefer to have a clearer understanding of what is happening rather than being fast.</p>
<p>After conducting a search, I found out that the ROM uses the following code:</p>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20231122105303-2.png" alt="Pasted image 20231122105303.png"/></p>
<p>During boot, it sets up a series of exception handlers that point to a function that prints some information. However, these exceptions only provide partial information and are only available for certain types.</p>
<p>I have made various attempts to correctly implement the complete <strong>exception handlers</strong>, and it is possible, but not straightforward. The code that should be implemented is the same as the one already present in <strong>FreeRTOS</strong>:</p>
<ul>
<li><a href="https://github.com/espressif/esp-idf/blob/ab03c2ea13ecaac1510b75e93b32cf0c472640fb/components/esp_system/port/panic_handler.c#L208">https://github.com/espressif/esp-idf/blob/ab03c2ea13ecaac1510b75e93b32cf0c472640fb/components/esp_system/port/panic_handler.c#L208</a></li>
<li><a href="https://github.com/espressif/esp-idf/blob/ab03c2ea13ecaac1510b75e93b32cf0c472640fb/components/esp_system/port/arch/xtensa/panic_handler_asm.S#L18">https://github.com/espressif/esp-idf/blob/ab03c2ea13ecaac1510b75e93b32cf0c472640fb/components/esp_system/port/arch/xtensa/panic_handler_asm.S#L18</a></li>
<li><a href="https://github.com/espressif/esp-idf/blob/ab03c2ea13ecaac1510b75e93b32cf0c472640fb/components/xtensa/xtensa_context.S#L71">https://github.com/espressif/esp-idf/blob/ab03c2ea13ecaac1510b75e93b32cf0c472640fb/components/xtensa/xtensa_context.S#L71</a></li>
</ul>
<p>For this reason, I preferred to have the original bootloader that implements FreeRTOS and already has all the exception handlers implemented.</p>
<p>To generate the exception, we have different methods, the simplest one being to perform a write to a non writable area:</p>
<pre data-enlighter-language="asm">&#34;movi a13, 0x93939393;&#34;
&#34;s32i.n  a2, a13, 0;&#34;
</pre>
<p>This way, when necessary, with just one instruction, we will be able to see the complete context. <strong>Furthermore, using a unique method for all types of faults will allow us to perform a unified parsing in all situations and quickly identify if the injected glitch has allowed the instructions to continue until the end of the code.</strong></p>
<h4>Instructions to attack</h4>
<p>The standard fault injection example uses <strong>loops or similar methods that do not allow us to understand in detail what is happening, thus it’s not an optimal approach</strong>. Instead, repeated instructions are arguably the best choice. However, in this case, we also want to <strong>understand precisely which ones we are affecting</strong>. By using a different increment value each time, we can understand which instruction we are influencing and what happens.</p>
<p>To determine which instruction we are affecting, we add a number that is equivalent to a single bit representation. This will speed up certain types of analysis:</p>
<pre data-enlighter-language="asm">&#34;addi a6, a6, 0x1;&#34;
&#34;addi a6, a6, 0x2;&#34;
&#34;addi a6, a6, 0x4;&#34;
&#34;addi a6, a6, 0x8;&#34;
&#34;addi a6, a6, 0x10&#34;
&#34;addi a6, a6, 0x20&#34;
&#34;addi a6, a6, 0x40;&#34;
</pre>
<p>The result of the operations will be as follows:</p>
<pre data-enlighter-language="generic">&#34;addi a6, a6, 0x1;&#34;  -&gt; a6 = 0x01 (0b00000001)
&#34;addi a6, a6, 0x2;&#34;  -&gt; a6 = 0x03 (0b00000011)
&#34;addi a6, a6, 0x4;&#34;  -&gt; a6 = 0x07 (0b00000111)
&#34;addi a6, a6, 0x8;&#34;  -&gt; a6 = 0x0F (0b00001111)
&#34;addi a6, a6, 0x10&#34;  -&gt; a6 = 0x1F (0b00011111)
&#34;addi a6, a6, 0x20&#34;  -&gt; a6 = 0x3F (0b00111111)
&#34;addi a6, a6, 0x40;&#34; -&gt; a6 = 0x7F (0b01111111)
</pre>
<p>As a safety measure, we also check with IDA Pro that the code generated by the compiler is what we intended it to be:</p>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20231201124427-2.png" alt="Pasted image 20231201124427.png"/></p>
<p>As we can see, probably <strong>due to some assembler optimizations, the code has been partially changed</strong>. In fact, the first instructions have been translated as “addi.n,” which are 16-bit instructions, instead of “addi,” which are 24-bit instructions. In terms of code functionality, the result remains unchanged, as the two instructions are equivalent.</p>
<p>By researching details in the “Xtensa Instruction Set Architecture (ISA) – Reference Manual,” we can find the following:</p>
<pre data-enlighter-language="generic">Assembler Note
The assembler may convert ADDI instructions to ADDI.N when the Code Density
Option is enabled and the immediate operand falls within the available range. If the immediate
is too large the assembler may substitute an equivalent sequence. Prefixing the
ADDI instruction with an underscore (_ADDI) disables these optimizations and forces
the assembler to generate the wide form of the instruction or an error instead.
</pre>
<p>By modifying the assembly code as described at this point (replacing ADDI with _ADDI), we would get the “clean” code, which is also confirmed by the disassembling:</p>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20231215224519-2.png" alt="Pasted image 20231215224519.png"/></p>
<p>By conducting some tests, we found that approximately 12 instructions are executed in about 162ns. Considering that the compilation options set the frequency to 80Mhz and assuming that each instruction requires approximately 2 clock cycles, the timing looks reasonable:</p>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20240809153534-2.png" alt="Pasted image 20240809153534.png"/></p>
<p>Using a frequency of 160Mhz, we have approximately 62 nanoseconds for the execution of 12 instructions:</p>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20231201130259-2.png" alt="Pasted image 20231201130259.png"/></p>
<p>For convenience, let’s start working at 80Mhz to be more precise.</p>
<h4>Putting everything together</h4>
<p>To have a completely controlled environment, we need to perform the following steps:</p>
<ul>
<li>Set all registers to known values. This will help us understand what is happening.:</li>
</ul>
<pre data-enlighter-language="asm">// a0 is return address, but not used anymore
&#34;movi a0, 0x40404040;&#34;

// a1 is the stack pointer (it&#39;s not a typo, I decided to exclude the a1 to have clean info into the stacktraces)
// &#34;movi a0, 0x41414141;&#34;

&#34;movi a2, 0x42424242;&#34;
&#34;movi a3, 0x43434343;&#34;
&#34;movi a4, 0x44444444;&#34;
&#34;movi a5, 0x45454545;&#34;
&#34;movi a6, 0x46464646;&#34;
&#34;movi a7, 0x47474747;&#34;
&#34;movi a8, 0x48484848;&#34;
&#34;movi a9, 0x49494949;&#34;
&#34;movi a10, 0x50505050;&#34;
&#34;movi a11, 0x51515151;&#34;
&#34;movi a12, 0x52525252;&#34;
&#34;movi a13, 0x93939393;&#34;
&#34;movi a14, 0x54545454;&#34;
&#34;movi a15, 0x55555555;&#34;
</pre>
<ul>
<li>Set the trigger:</li>
</ul>
<pre data-enlighter-language="asm">// GPIO 26 PING HIGH using GPIO_OUT_W1TS
&#34;movi a11, 0x4000000;&#34;

&#34;movi a12, 0x3ff44024;&#34;
&#34;s32i.n  a11, a12, 0;&#34;

&#34;movi a12, 0x3ff44008;&#34;
&#34;s32i.n  a11, a12, 0;&#34;
</pre>
<ul>
<li>Modify the registers used during the trigger setup:</li>
</ul>
<pre data-enlighter-language="asm">// Set correctly used registers
&#34;movi a11, 0x51515151;&#34;
&#34;movi a12, 0x52525252;&#34;
</pre>
<ul>
<li>Execute a series of NOPs to allow time for glitching and propagation:</li>
</ul>
<pre data-enlighter-language="asm">// Execute NOP instructions
&#34;nop;&#34;
</pre>
<ul>
<li>Execute the code we want to attack:</li>
</ul>
<pre data-enlighter-language="asm">&#34;addi a6, a6, 0x1;&#34;
&#34;addi a6, a6, 0x2;&#34;
&#34;addi a6, a6, 0x4;&#34;
&#34;addi a6, a6, 0x8;&#34;
&#34;addi a6, a6, 0x10;&#34;
&#34;addi a6, a6, 0x20;&#34;
&#34;addi a6, a6, 0x40;&#34;
</pre>
<ul>
<li>Execute a second series of NOPs to avoid glitching the final exception creation:</li>
</ul>
<pre data-enlighter-language="asm">// Execute NOP instructions
&#34;nop;&#34;
</pre>
<ul>
<li>Set the trigger again to deactivate it:</li>
</ul>
<pre data-enlighter-language="asm">// GPIO 26 PIN LOW using GPIO_OUT_W1TC
&#34;movi a12, 0x3ff4400C;&#34;
&#34;movi a11, 0x4000000;&#34;
&#34;s32i.n  a11, a12, 0;&#34;
</pre>
<ul>
<li>Generate a CPU exception:</li>
</ul>
<pre data-enlighter-language="asm">// GENERATE CPU EXCEPTION
&#34;s32i.n  a2, a13, 0;&#34;
</pre>
<p>By running the entire code, we can observe that execution takes around a total of 25,200 nanoseconds:</p>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20240809153608-2.png" alt="Pasted image 20240809153608.png"/></p>
<h3>Glitching</h3>
<h4>Hardware setup</h4>
<p>On the datasheet of the ESP32 processor, further details can be found on how the different VDD pins that provide power to the chip are used:</p>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20240809150151-2.png" alt="Pasted image 20240809150151.png"/></p>
<p>For this initial analysis, I decided to keep <strong>all VDD pins connected together</strong>, removing the capacitors connected to the VDD3P3_RTC and VDD3P3_CPU power lines.</p>
<p>The hardware on which the tests were performed has the following configuration, and the circled capacitors have been removed:</p>
<p><img fetchpriority="high" decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20240819213918-2.png" alt="Pasted image 20240819213918.png" width="645" height="333"/></p>
<p>Source: <a href="https://github.com/raelize/TAoFI-Target/blob/main/files/schematic.png">https://github.com/raelize/TAoFI-Target/blob/main/files/schematic.png</a></p>
<h4>Glitching preparation</h4>
<p>Now that we have a “clean” environment just the way I like it, let’s look at the main features of the <strong>glitching script</strong>.</p>
<p>For convenience, we use the setup provided during the course, which includes:</p>
<ul>
<li>an ESP-PROG programmer with which we communicate via serial to the ESP32</li>
<li>a Chipwhisperer Husky connected to the trigger PIN and responsible for performing crowbar glitching</li>
<li>an RK6006 power supply to provide the ESP32 with a controlled voltage below the standard, making it more comfortable to execute faults; throughout all the tests, the power supply provides 2.13v to the ESP32 chip, which is below the threshold recommended by the manufacturer</li>
</ul>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20240129230604-2.png" alt="Pasted image 20240129230604.png"/></p>
<p>After some initial tests, I have determined that the probable values for obtaining a good sample are as follows:</p>
<pre data-enlighter-language="python">min_length = 400    
max_length = 3000
min_delay = 4000
max_delay = 22000
</pre>
<p>To begin, we will use a “standard” configuration of the Husky:</p>
<pre data-enlighter-language="python">cw_scope.clock.clkgen_src          = &#39;system&#39;
cw_scope.clock.adc_mul             = 1
cw_scope.clock.clkgen_freq         = 200e6

# Glitching parameters
cw_scope.io.glitch_hp              = True
cw_scope.io.glitch_lp              = False    
</pre>
<p>In the following articles of this <a href="https://security.humanativaspa.it/tag/fault-injection">series</a>, we will also explore how we can make the most of the Husky.</p>
<p>However, the most important part is the <strong>initial classification</strong> that is performed before saving the result.</p>
<p>As we described earlier, we know that all the results should be “identical” because we use CPU exceptions that are all handled in the same way, whether our glitch is too long, causing an illegal instruction, or our glitch is too short and therefore does not affect code execution.</p>
<p>A specific routine is responsible for analyzing the result, comparing it with the expected result, and <strong>saving only the values that are “different” from the standard ones, in order to have a cleaner output during subsequent analysis.</strong></p>
<h3>A first interpretation of the results</h3>
<p>With the “Glitch and pray” approach, we can start to see the first results and try to understand how to interpret them better. We have two varying values: the distance of the glitch from the trigger (delay) and the length of the performed glitch (length).</p>
<p>Some <strong>important assumptions</strong>:</p>
<ul>
<li>If PC is different from 0x400d713b (the address of the last instruction before the forged exception), we have not experienced a “clean” fault, so something broke beforehand. In the case of “illegal instruction” exceptions, it could help us understand which instruction caused the fault.</li>
<li>If PC is equal to 0x400d713b (the address of the last instruction before the forged exception), we can interpret the results and understand which instructions we have influenced.</li>
<li>All our target code works on the A6 registry; if A6 has not changed it is very likely that we have influenced instructions that are not of our interest.</li>
</ul>
<p>All the <strong>results have been classified</strong> in this way:</p>
<ul>
<li>the green color represents “normal” results, the PC is correct and no modification of others registers has been detected</li>
<li>the magenta color represents CPU restarts that usually happen if the glitch is too long</li>
<li>the yellow color represents a fault with wrong PC, which means that we didn’t reach our final code</li>
<li>the cyan color represents a fault where PC is correct (we reached our last instruction) and also A6 is correct, which means we didn’t fault our target instruction, but some other instruction</li>
<li>the red color represents a fault where PC is correct (we reached our last instruction) and A6 doesn’t have the proper value, which means we faulted our target instruction</li>
</ul>
<p>After 36K attempts, here are the first results:</p>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20240128233433-2.png" alt="Pasted image 20240128233433.png"/></p>
<p>The ones of interest to us are the red dots, where we have the correct PC but A6 doesn’t have the value we expected.</p>
<p>By cleaning up the results a little bit, we can see how the areas are quite concentrated:</p>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20240128233745-2.png" alt="Pasted image 20240128233745.png"/></p>
<p>We can find in blue some points of particular interest to us. For example, the “illegal instruction” in the first add operation. We can associate this behavior with “we have zeroed too many bits” of a specific instruction.</p>
<p>Searching for results <code>Illegal.*PC: 0x400d70e4</code> we can identify parameters which lead us to corrupt our first target instruction which is at 0x400d70e4:</p>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20240128234155-2.png" alt="Pasted image 20240128234155.png"/></p>
<p>Looking for <code>Illegal.*PC: 0x400d70e7</code> we can identify parameters which lead to corrupt the second instruction:</p>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20240128234241-2.png" alt="Pasted image 20240128234241.png"/></p>
<p>Looking for <code>Illegal.*PC: 0x400d70ea</code> we can identify parameters which lead to corrupt the third instruction:</p>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20240128234302-2.png" alt="Pasted image 20240128234302.png"/></p>
<p>Looking for <code>Illegal.*PC: 0x400d70ed</code> we can identify parameters which lead to corrupt the fourth instruction:</p>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20240128234322-2.png" alt="Pasted image 20240128234322.png"/></p>
<p>Looking for <code>Illegal.*PC: 0x400d70f0</code> we can identify parameters which lead to corrupt the fourth instruction:</p>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20240128234353-2.png" alt="Pasted image 20240128234353.png"/></p>
<p>Looking for <code>Illegal.*PC: 0x400d70f3</code> we can identify parameters which lead to corrupt the fifth instruction:</p>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20240128234407-2.png" alt="Pasted image 20240128234407.png"/></p>
<p>Looking for <code>Illegal.*PC: 0x400d70f6</code> we can identify parameters which lead to corrupt the sixth instruction:</p>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20240128234434-2.png" alt="Pasted image 20240128234434.png"/></p>
<p>Executing some custom query on the data we can also find where we “skipped the instruction” (we will see later that this is not actually the case) by looking for the expected value in A6.</p>
<p>Looking for <code>Store.* PC: 0x400d713b.*A6 : 0x0000007e</code> we can identify parameters which lead to corrupt the first instruction in a way that the additional operation has not been executed:</p>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20240128234752-2.png" alt="Pasted image 20240128234752.png"/></p>
<p>Looking for <code>Store.* PC: 0x400d713b.*A6 : 0x0000007d</code> we can identify parameters which lead to corrupt the second instruction in a way that the additional operation has not been executed. In our initial test, no cases have been identified:</p>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20240128234818-2.png" alt="Pasted image 20240128234818.png"/></p>
<p>Looking for <code>Store.* PC: 0x400d713b.*A6 : 0x0000007b</code> we can identify parameters which lead to corrupt the third instruction in a way that the additional operation has not been executed:</p>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20240128234841-2.png" alt="Pasted image 20240128234841.png"/></p>
<p>Looking for <code>Store.* PC: 0x400d713b.*A6 : 0x00000077</code> we can identify parameters which lead to corrupt the forth instruction in a way that the additional operation has not been executed:</p>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20240128234858-2.png" alt="Pasted image 20240128234858.png"/></p>
<p>Looking for <code>Store.* PC: 0x400d713b.*A6 : 0x0000006f</code> we can identify parameters which lead to corrupt the fifth instruction in a way that the additional operation has not been executed:</p>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20240128234918-2.png" alt="Pasted image 20240128234918.png"/></p>
<p>Looking for <code>Store.* PC: 0x400d713b.*A6 : 0x0000005f</code> we can identify parameters which lead to corrupt the sixth instruction in a way that the additional operation has not been executed:</p>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20240128234941-2.png" alt="Pasted image 20240128234941.png"/></p>
<p>Looking for <code>Store.* PC: 0x400d713b.*A6 : 0x0000003f</code> we can identify parameters which lead to corrupt the seventh instruction in a way that the additional operation has not been executed:</p>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20240128235000-2.png" alt="Pasted image 20240128235000.png"/></p>
<p><strong>As we could see from the initial results, we can consider performing a very precise targeting of an instruction based on the time from the trigger.</strong></p>
<p><strong>However, the same results tell us that some instructions are more “simple” to target than others. I hypothesize that this is also due to the pipeline and internal caches of the processor.</strong></p>
<h3>A script to better understand the cause</h3>
<p>One of the fundamental things taught in the course by <a href="https://twitter.com/pulsoid">@pulsoid</a> and <a href="https://twitter.com/tieknimmers">@tieknimmers</a> is to debunk the myth of “an instruction was skipped”. Many who talk about glitching and fault injection wrongly use this term just to say “I didn’t understand what happened”.</p>
<p>To understand the results we are going to analyze, we need to hypothesize what will happen at the processor level. Since we are using the “crowbar to ground” technique, it is <strong>plausible to assume that during certain CPU operations</strong> (such as loading instructions, execution, memory copies, etc.), <strong>some bits which are 1 may turn into 0</strong>. Other techniques could yield different results, but this is the most likely effect in our situation.</p>
<p>To do this, I have developed a small script that, given a specific opcode, sets N bits to 0 and observes what the “corrupted” instruction would be. In an ideal world, fault injection could change a single bit, but currently we do not know if we can be that precise. Therefore, we must assume that we will change N different bits.</p>
<p>The script generates N different possibilities by assuming influence on N different bits. The bits that have changed from 1 to 0 are marked in red, while the bits that are among the selected N bits but have not changed because they were already set to 0 are marked in green. All possible variations that do not alter the instruction are ignored.</p>
<p>Let’s see, for example, what can happen to the instruction <code>addi a6, a6, 0x1;</code> in different scenarios assuming a variation from 1 to 4 bits.</p>
<p><strong>Red bits are the ones changed</strong>, <strong>green bits are the ones that should been changed but already were set to 0</strong>.</p>
<p>The bit representation is consistent with that shown in the datasheet:</p>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20240121152043-1-2.png" alt="Pasted image 20240121152043 1.png"/></p>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20240819215945-2.png" alt="Pasted image 20240819215945.png"/></p>
<p>Alternatively, a “reduced” version that does not include duplicate cases:</p>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20240819222851-2.png" alt="Pasted image 20240819222851.png"/></p>
<p>The code can be viewed at <a href="https://github.com/inode-/fault_injection/blob/main/OpcodeCalculator/opcode_calculator.py">https://github.com/inode-/fault_injection/blob/main/OpcodeCalculator/opcode_calculator.py</a></p>
<h3>A better interpretation of the results</h3>
<p>Now let’s try to understand what actually happens at the processor level, <strong>assuming that “the instruction was skipped” is not a valid answer</strong>.</p>
<p>We start with the simplest cases and move towards the more complex and less “explainable” ones.</p>
<p>The results from a normal execution are as follows:</p>
<pre data-enlighter-language="generic">&#34;addi a6, a6, 0x1;&#34;  -&gt; a6 = 0x01 
&#34;addi a6, a6, 0x2;&#34;  -&gt; a6 = 0x03 
&#34;addi a6, a6, 0x4;&#34;  -&gt; a6 = 0x07 
&#34;addi a6, a6, 0x8;&#34;  -&gt; a6 = 0x0F 
&#34;addi a6, a6, 0x10&#34;  -&gt; a6 = 0x1F 
&#34;addi a4, a6, 0x20&#34;  -&gt; a6 = 0x3F
&#34;addi a6, a6, 0x40;&#34; -&gt; a6 = 0x7F
</pre>
<p>During the next steps, it is necessary to remember what the states of the registers are in a “normal” situation.</p>
<pre data-enlighter-language="generic">Core  0 register dump:
PC      : 0x400d713b  PS      : 0x00060430  A0      : 0x40404040  A1      : 0x3ffb4810  
A2      : 0x42424242  A3      : 0x43434343  A4      : 0x44444444  A5      : 0x45454545  
A6      : 0x0000007f  A7      : 0x47474747  A8      : 0x48484848  A9      : 0x49494949  
A10     : 0x50505050  A11     : 0x04000000  A12     : 0x3ff4400c  A13     : 0x93939393  
A14     : 0x54545454  A15     : 0x55555555  SAR     : 0x00000004  EXCCAUSE: 0x0000001d  
EXCVADDR: 0x93939393  LBEG    : 0x400014fd  LEND    : 0x4000150d  LCOUNT  : 0xffffffff  
</pre>
<p>Some typical examples are analyzed below. <em>We have arbitrarily decided to consider that the maximum number of bits changed is 6, but the value could also be higher.</em></p>
<h4>Level 1 (simple)</h4>
<p>Difference between the normal registers:</p>
<pre data-enlighter-language="generic">StoreProhibited - PC: 0x400d713b - A6 : 0x00000077(0x0000007f)  - 
</pre>
<p>Which means:</p>
<ul>
<li>Expected value on A6 is 0x7F, we got 0x77 which means we have a difference of 0x8.</li>
<li>Having a difference of 0x8 means that we faulted the 4th target instruction.</li>
<li>No other registers have been affected.</li>
<li>Calculating possible fault generated instructions, we can identify only one instruction which doesn’t generate a different CPU exception and causes the result to “add nothing”.</li>
</ul>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20240819223606-2.png" alt="Pasted image 20240819223606.png"/></p>
<p>That will produce:</p>
<pre data-enlighter-language="generic">&#34;addi a6, a6, 0x1;&#34;  -&gt; a6 = 0x01 
&#34;addi a6, a6, 0x2;&#34;  -&gt; a6 = 0x03 
&#34;addi a6, a6, 0x4;&#34;  -&gt; a6 = 0x07 
&#34;addi a6, a6, 0x0;&#34;  -&gt; a6 = 0x07 | GLITCHED
&#34;addi a6, a6, 0x10&#34;  -&gt; a6 = 0x17 
&#34;addi a6, a6, 0x20&#34;  -&gt; a6 = 0x37
&#34;addi a6, a6, 0x40;&#34; -&gt; a6 = 0x77
</pre>
<h4>Level 2 (simple)</h4>
<p>Difference between the normal registers:</p>
<pre data-enlighter-language="generic">StoreProhibited - PC: 0x400d713b - A4 : 0x0000003f(0x44444444)  - A6 : 0x0000005f(0x0000007f)  - 
</pre>
<p>Which meanss:</p>
<ul>
<li>Expected value on A6 is 0x7F, we got 0x5f which means we have a difference of 0x20.</li>
<li>Having a difference of 0x20 means that we faulted the 6th target instruction.</li>
<li>Only register A4 has been changed, which means that in some way we have overwritten it.</li>
<li>Calculating possible fault generated instructions, we can identify only one instruction which doesn’t generate a different CPU exception and causes the override of A4.</li>
</ul>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20240819223825-2.png" alt="Pasted image 20240819223825.png"/></p>
<p>That will produce:</p>
<pre data-enlighter-language="generic">&#34;addi a6, a6, 0x1;&#34;  -&gt; a6 = 0x01 
&#34;addi a6, a6, 0x2;&#34;  -&gt; a6 = 0x03 
&#34;addi a6, a6, 0x4;&#34;  -&gt; a6 = 0x07 
&#34;addi a6, a6, 0x8;&#34;  -&gt; a6 = 0x0F 
&#34;addi a6, a6, 0x10&#34;  -&gt; a6 = 0x1F 
&#34;addi a4, a6, 0x20&#34;  -&gt; a6 = 0x1F, a4 = 0x3F | GLITCHED
&#34;addi a6, a6, 0x40;&#34; -&gt; a6 = 0x5F, a4 = 0x3F
</pre>
<h4>Level 3 (simple)</h4>
<pre data-enlighter-language="generic">StoreProhibited - PC: 0x400d713b - A2 : 0x40404041(0x42424242)  - A6 : 0x0000007e(0x0000007f)  - 
</pre>
<p>Which means:</p>
<ul>
<li>Expected value on A6 is 0x7F, we got 0x7e which means we have a difference of 0x1.</li>
<li>Having a difference of 0x1 means that we faulted the 1st target instruction.</li>
<li>Register A2 contains the value of A0 plus one, which means that we changed both source and destination register in a single fault.</li>
<li>Calculating possible fault generated instructions, we can identify only one instruction which doesn’t generate a different CPU exception and causes the override of A2 using A0 as source.</li>
</ul>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20240819223946-2.png" alt="Pasted image 20240819223946.png"/></p>
<p>That will produce:</p>
<pre data-enlighter-language="generic">&#34;addi a6, a6, 0x1;&#34;  -&gt; a6 = 0x00, a2 = 0x40404041 | GLITCHED
&#34;addi a6, a6, 0x2;&#34;  -&gt; a6 = 0x02, a2 = 0x40404041
&#34;addi a4, a6, 0x4;&#34;  -&gt; a6 = 0x06, a2 = 0x40404041
&#34;addi a6, a6, 0x8;&#34;  -&gt; a6 = 0x0E, a2 = 0x40404041
&#34;addi a6, a6, 0x10&#34;  -&gt; a6 = 0x1E, a2 = 0x40404041
&#34;addi a6, a6, 0x20&#34;  -&gt; a6 = 0x3E, a2 = 0x40404041
&#34;addi a6, a6, 0x40;&#34; -&gt; a6 = 0x7E, a2 = 0x40404041
</pre>
<h4>Level 4 (simple)</h4>
<pre data-enlighter-language="generic">StoreProhibited - PC: 0x400d713b - A4 : 0x00000007(0x44444444)  - A6 : 0x0000007b(0x0000007f)  - 
</pre>
<p>Which means:</p>
<ul>
<li>Expected value on A6 is 0x7F, we got 0x7b which means we have a difference of 0x4.</li>
<li>Having a difference of 0x4 means that we faulted the 3rd target instruction.</li>
<li>Only register A4 has been changed, which means that in some way we have overwritten it.</li>
<li>Calculating possible fault generated instructions, we can identify only one instruction which doesn’t generate a different CPU exception and causes the override of A4.</li>
</ul>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20240819224040-2.png" alt="Pasted image 20240819224040.png"/></p>
<p>That will produce:</p>
<pre data-enlighter-language="generic">&#34;addi a6, a6, 0x1;&#34;  -&gt; a6 = 0x01 
&#34;addi a6, a6, 0x2;&#34;  -&gt; a6 = 0x03 
&#34;addi a4, a6, 0x4;&#34;  -&gt; a6 = 0x03, a4 = 0x7 | GLITCHED
&#34;addi a6, a6, 0x8;&#34;  -&gt; a6 = 0x0B, a4 = 0x7 
&#34;addi a6, a6, 0x10&#34;  -&gt; a6 = 0x1B, a4 = 0x7  
&#34;addi a6, a6, 0x20&#34;  -&gt; a6 = 0x3B, a4 = 0x7  
&#34;addi a6, a6, 0x40;&#34; -&gt; a6 = 0x7B, a4 = 0x7  
</pre>
<h4>Level 5 (medium)</h4>
<pre data-enlighter-language="generic">StoreProhibited - PC: 0x400d713b - A0 : 0x0000001f(0x40404040)  - A4 : 0x0000002f(0x44444444)  - A6 : 0x0000004f(0x0000007f)  - 
</pre>
<p>Which means:</p>
<ul>
<li>Expected value on A6 is 0x7F, we got 0x4f which means we have a difference of 0x30.</li>
<li>Having a difference of 0x30 means that we faulted 2 target instructions, the 6th and the 7th.</li>
<li>The A0 register contains the exact result of the standard 6th instruction.</li>
<li>The A4 register contains a fault compatible with “the skip” of the 6th instruction and the sum generated from the 7th instruction.</li>
<li>Calculating possible fault generated instructions, we can identify only one instruction which doesn’t generate a different CPU exception and causes the override of A0 and A4 in the correct way.</li>
</ul>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20240819224413-2.png" alt="Pasted image 20240819224413.png"/></p>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20240819224620-2.png" alt="Pasted image 20240819224620.png"/></p>
<p>That will produce:</p>
<pre data-enlighter-language="generic">&#34;addi a6, a6, 0x1;&#34;  -&gt; a6 = 0x01 
&#34;addi a6, a6, 0x2;&#34;  -&gt; a6 = 0x03 
&#34;addi a6, a6, 0x4;&#34;  -&gt; a6 = 0x07 
&#34;addi a6, a6, 0x8;&#34;  -&gt; a6 = 0x0F 
&#34;addi a0, a6, 0x10&#34;  -&gt; a6 = 0x0F, a0 = 0x1F             | GLITCHED
&#34;addi a4, a6, 0x20&#34;  -&gt; a6 = 0x0F, a0 = 0x1F, a4 = 0x2F  | GLITCHED
&#34;addi a6, a6, 0x40;&#34; -&gt; a6 = 0x7F
</pre>
<h4>Level 6 (medium)</h4>
<pre data-enlighter-language="generic">StoreProhibited - PC: 0x400d713b - A4 : 0x00000005(0x44444444)  - A6 : 0x00000079(0x0000007f)  - 
</pre>
<p>Which means:</p>
<ul>
<li>Expected value on A6 is 0x7F, we got 0x79 which means we have a difference of 0x6.</li>
<li>Having a difference of 0x6 means that we faulted 2 target instructions, the 2nd and the 3rd.</li>
<li>The A4 register contains a value that is compatible if the second instruction has not modified A6.</li>
<li>Calculating possible fault generated instructions, we can identify only two instructions which don’t generate a different CPU exception and cause the override of A4 in the correct way.</li>
</ul>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20240819224835-2.png" alt="Pasted image 20240819224835.png"/></p>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20240819224922-2.png" alt="Pasted image 20240819224922.png"/></p>
<p>That will produce:</p>
<pre data-enlighter-language="generic">&#34;addi a6, a6, 0x1;&#34;  -&gt; a6 = 0x01 
&#34;addi a6, a6, 0x0;&#34;  -&gt; a6 = 0x01              | GLITCHED
&#34;addi a4, a6, 0x4;&#34;  -&gt; a6 = 0x01, a4 =  0x5   | GLITCHED
&#34;addi a6, a6, 0x8;&#34;  -&gt; a6 = 0x09, a4 =  0x5 
&#34;addi a6, a6, 0x10&#34;  -&gt; a6 = 0x19, a4 =  0x5 
&#34;addi a4, a6, 0x20&#34;  -&gt; a6 = 0x39, a4 =  0x5
&#34;addi a6, a6, 0x40;&#34; -&gt; a6 = 0x79, a4 =  0x5
</pre>
<h4>Level 7 (medium)</h4>
<pre data-enlighter-language="generic">StoreProhibited - PC: 0x400d713b - A6 : 0x42424262(0x0000007f)  - 
</pre>
<p>Which means:</p>
<ul>
<li>The A6 register has been modified with the content of A2 (0x42424242).</li>
<li>Difference between A2 and final A6 is 0x42424262 – 0x42424242 which is 0x20 meaning that we faulted the 6th target instruction.</li>
<li>Register A6 is missing 0x40 which is the add of the last target instruction, so we corrupted 2 instructions.</li>
<li>Calculating possible fault generated instructions, we can identify only one instruction which doesn’t generate a different CPU exception and causes the override of A6 with A2 value (6th instruction).</li>
<li>Calculating possible fault generated instructions, we can identify one instruction which potentially doesn’t generate a different CPU exception and does nothing on A6.</li>
</ul>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20240819225348-2.png" alt="Pasted image 20240819225348.png"/></p>
<p><img decoding="async" src="https://security.humanativaspa.it/sec/wp-content/uploads/2024/11/Pasted-image-20240819225320-2.png" alt="Pasted image 20240819225320.png"/></p>
<p>That will produce:</p>
<pre data-enlighter-language="generic">&#34;addi a6, a6, 0x1;&#34;  -&gt; a6 = 0x01 
&#34;addi a6, a6, 0x2;&#34;  -&gt; a6 = 0x03 
&#34;addi a6, a6, 0x4;&#34;  -&gt; a6 = 0x07 
&#34;addi a6, a6, 0x8;&#34;  -&gt; a6 = 0x0F 
&#34;addi a6, a6, 0x10&#34;  -&gt; a6 = 0x1F 
&#34;addi a6, a2, 0x20&#34;  -&gt; a6 = 0x42424262 | GLITCHED
&#34;addi a6, a6, 0x00&#34;  -&gt; a6 = 0x42424262 | GLITCHED
</pre>
<h3>Interpretation of the results – another approach</h3>
<p>Comparing the possible instructions on which we have made a fault is possible in simple cases. However, in more complex scenarios it becomes difficult to manually explain the cases. For this reason, I have decided to also take another path, to emulate the execution of the fault in a virtual environment and subsequently compare the result. My first choice would have been to use <a href="https://www.unicorn-engine.org/">Unicorn Engine</a>, but unfortunately it does not currently support the XTENSA CPU.</p>
<p>Another feasible approach could have been to use the JTAG port combined with GDB to modify the instructions and the context, to execute the instructions step by step and see what had changed. Technically feasible but probably too slow to perform as many emulations as we need.</p>
<p>We then decided to try the emulation feature of Ghidra, which is poorly documented but should be supported for all CPUs. In fact, unlike for example IDA Pro, practically all processors come with what is defined as “P-Code”, that is, what a certain assembler operation performs. The P-Code abstraction is also what allows Ghidra to perform decompilation on almost all supported processors.</p>
<h4>Ghidra CPU emulation</h4>
<p>Some examples of using Ghidra for instruction emulation that I’ve used as a starting point:</p>
<ul>
<li><a href="https://gist.github.com/cetfor/18cae544249e4cf78f66930175072876">https://gist.github.com/cetfor/18cae544249e4cf78f66930175072876</a></li>
<li><a href="https://medium.com/@cetfor/emulating-ghidras-pcode-why-how-dd736d22dfb">https://medium.com/@cetfor/emulating-ghidras-pcode-why-how-dd736d22dfb</a></li>
</ul>
<p>Reusing part of the Python code presented earlier, I decided to export the possible instructions that could be executed and import them directly into the code of our plugin.</p>
<p>At this point, as a first step, we must modify the binary to reflect the instructions we want to emulate:</p>
<pre data-enlighter-language="java">void patch_code(long newcode[]) throws CancelledException, MemoryAccessException
{
	Address current_instruction = currentProgram.getAddressFactory().getDefaultAddressSpace().getAddress(init_addr);

	for(int i = 0; i &lt; newcode.length; i++) 
	{
		clearListing(current_instruction);

		this.setBytes(current_instruction, longToBytes_24bits(newcode[i]));		
		current_instruction = current_instruction.add(3);		
	}
	
	disassemble(currentProgram.getAddressFactory().getDefaultAddressSpace().getAddress(init_addr));		
	return;

}
</pre>
<p>Then we set the context exactly as what is expected by the CPU:</p>
<pre data-enlighter-language="java">emuHelper.writeRegister(&#34;a0&#34;, 0x40404040);
emuHelper.writeRegister(&#34;a1&#34;, 0x41414141);
emuHelper.writeRegister(&#34;a2&#34;, 0x42424242);
emuHelper.writeRegister(&#34;a3&#34;, 0x43434343);
emuHelper.writeRegister(&#34;a4&#34;, 0x44444444);
emuHelper.writeRegister(&#34;a5&#34;, 0x45454545);
emuHelper.writeRegister(&#34;a6&#34;, 0x46464646);
emuHelper.writeRegister(&#34;a7&#34;, 0x47474747);
emuHelper.writeRegister(&#34;a8&#34;, 0x48484848);
emuHelper.writeRegister(&#34;a9&#34;, 0x49494949);
emuHelper.writeRegister(&#34;a10&#34;, 0x50505050);
emuHelper.writeRegister(&#34;a11&#34;, 0x51515151);
emuHelper.writeRegister(&#34;a12&#34;, 0x52525252);
emuHelper.writeRegister(&#34;a13&#34;, 0x93939393);
emuHelper.writeRegister(&#34;a14&#34;, 0x54545454);
emuHelper.writeRegister(&#34;a15&#34;, 0x55555555);

emuHelper.writeRegister(&#34;a6&#34;, 0x0);
</pre>
<p>Afterwards, we execute the instructions of interest:</p>
<pre data-enlighter-language="java">	emuHelper.writeRegister(emuHelper.getPCRegister(), initial_instruction);
	
	int j = 0;
	
	for(int i = 0; i&lt;=array_size; i++)
	{
		Address executionAddress = emuHelper.getExecutionAddress();
		
		outfile.write(executionAddress.toString() + &#39; &#39; + getInstructionAt(executionAddress) + &#34;\n&#34;);
		
		try {
			boolean success = emuHelper.step(monitor);
			
			j++;
			if( success == false) {
				String lastError = emuHelper.getLastError();
				outfile.write(lastError  + &#34; - &#34; +  getInstructionAt(executionAddress) + &#34;\n&#34;);
				outfile.write(HexFormat.of().formatHex(getBytes(executionAddress, 3)));
				return -1;
			}
		} catch (Exception e) {
			println(e.toString());
			return -1;
			
		}
		
	}
</pre>
<p>At this point, we compare the results and save only those that are different from what we expect:</p>
<pre data-enlighter-language="java">		if(emuHelper.readRegister(&#34;a0&#34;).longValue() != 0x40404040 )
			outfile.write(&#34;A0 : 0x&#34; + String.format(&#34;%08x&#34;, emuHelper.readRegister(&#34;a0&#34;).longValue()) + &#34; &#34;);
		if(emuHelper.readRegister(&#34;a1&#34;).longValue() != 0x41414141 )
			outfile.write(&#34;A1 : 0x&#34; + String.format(&#34;%08x&#34;,emuHelper.readRegister(&#34;a1&#34;).longValue()) + &#34; &#34;);
		if(emuHelper.readRegister(&#34;a2&#34;).longValue() != 0x42424242 )
			outfile.write(&#34;A2 : 0x&#34; + String.format(&#34;%08x&#34;,emuHelper.readRegister(&#34;a2&#34;).longValue()) + &#34; &#34;);
		if(emuHelper.readRegister(&#34;a3&#34;).longValue() != 0x43434343 )
			outfile.write(&#34;A3 : 0x&#34; + String.format(&#34;%08x&#34;,emuHelper.readRegister(&#34;a3&#34;).longValue()) + &#34; &#34;);
		if(emuHelper.readRegister(&#34;a4&#34;).longValue() != 0x44444444 )
			outfile.write(&#34;A4 : 0x&#34; + String.format(&#34;%08x&#34;,emuHelper.readRegister(&#34;a4&#34;).longValue()) + &#34; &#34;);
		if(emuHelper.readRegister(&#34;a5&#34;).longValue() != 0x45454545 )
			outfile.write(&#34;A5 : 0x&#34; + String.format(&#34;%08x&#34;,emuHelper.readRegister(&#34;a5&#34;).longValue()) + &#34; &#34;);
		if(emuHelper.readRegister(&#34;a6&#34;).longValue() != 0x7f )
			outfile.write(&#34;A6 : 0x&#34; + String.format(&#34;%08x&#34;,emuHelper.readRegister(&#34;a6&#34;).longValue()) + &#34; &#34;);
		if(emuHelper.readRegister(&#34;a7&#34;).longValue() != 0x47474747 )
			outfile.write(&#34;A7 : 0x&#34; + String.format(&#34;%08x&#34;,emuHelper.readRegister(&#34;a7&#34;).longValue()) + &#34; &#34;);
		if(emuHelper.readRegister(&#34;a8&#34;).longValue() != 0x48484848 )
			outfile.write(&#34;A8 : 0x&#34; + String.format(&#34;%08x&#34;,emuHelper.readRegister(&#34;a8&#34;).longValue()) + &#34; &#34;);
		if(emuHelper.readRegister(&#34;a9&#34;).longValue() != 0x49494949 )
			outfile.write(&#34;A9 : 0x&#34; + String.format(&#34;%08x&#34;,emuHelper.readRegister(&#34;a9&#34;).longValue()) + &#34; &#34;);
		if(emuHelper.readRegister(&#34;a10&#34;).longValue() != 0x50505050 )
			outfile.write(&#34;A10 : 0x&#34; + String.format(&#34;%08x&#34;,emuHelper.readRegister(&#34;a10&#34;).longValue()) + &#34; &#34;);
		if(emuHelper.readRegister(&#34;a11&#34;).longValue() != 0x51515151 )
			outfile.write(&#34;A11 : 0x&#34; + String.format(&#34;%08x&#34;,emuHelper.readRegister(&#34;a11&#34;).longValue()) + &#34; &#34;);
		if(emuHelper.readRegister(&#34;a12&#34;).longValue() != 0x52525252 )
			outfile.write(&#34;A12 : 0x&#34; + String.format(&#34;%08x&#34;,emuHelper.readRegister(&#34;a12&#34;).longValue()) + &#34; &#34;);
		if(emuHelper.readRegister(&#34;a13&#34;).longValue() != 0x93939393L )
			outfile.write(&#34;A13 : 0x&#34; + String.format(&#34;%08x&#34;,emuHelper.readRegister(&#34;a13&#34;).longValue()) + &#34; &#34;);
		if(emuHelper.readRegister(&#34;a14&#34;).longValue() != 0x54545454 )
			outfile.write(&#34;A14 : 0x&#34; + String.format(&#34;%08x&#34;,emuHelper.readRegister(&#34;a14&#34;).longValue()) + &#34; &#34;);
		if(emuHelper.readRegister(&#34;a15&#34;).longValue() != 0x55555555 )
			outfile.write(&#34;A15 : 0x&#34; + String.format(&#34;%08x&#34;,emuHelper.readRegister(&#34;a15&#34;).longValue()) + &#34; &#34;);
		outfile.write(HexFormat.of().formatHex(getBytes(currentProgram.getAddressFactory().getDefaultAddressSpace().getAddress(init_addr), 3*7)));
		outfile.write(&#34;\n&#34;);
		
</pre>
<p>Full code available at<a href="https://github.com/inode-/fault_injection/blob/main/GhidraEmulation/xtensa_emulator.java"> https://github.com/inode-/fault_injection/blob/main/GhidraEmulation/xtensa_emulator.java</a></p>
<h4>Pros and cons</h4>
<p>One of the main pros of this approach is the possibility of having an emulator up and running in a very short time, even though Ghidra’s APIs are poorly documented. However, there are also a number of cons:</p>
<ul>
<li>the procedure to emulate everything is slow</li>
<li>we cannot be certain that some exceptions are handled in the same way by the emulation layer as by the original hardware</li>
</ul>
<h3>Conclusions</h3>
<p>One thing <strong>we can state with certainty is that instructions are not “skipped”…</strong></p>
<p>Sometimes it is not easy to explain what happens in the context of fault injection, but it is possible to try to <strong>understand what happened if there is a clear context</strong>. Of course, <strong>we cannot be certain, but we can come to have a good degree of confidence</strong> in understanding what happened in some cases. In the next articles in this <a href="https://security.humanativaspa.it/tag/fault-injection">series</a>, I will try to find other ways to interpret the results.</p>
<p>Another important finding is that somehow <strong>it is possible to affect multiple instructions</strong>, and the modified bits don’t have to be contiguous.</p>
<p>Certainly, this article does not intend to be exhaustive, and I know there are many opportunities for improvement. For example, in the context we are working on, the floating-point registers are not printed, but as a start, I would dare to say that it is more than enough.</p>
<p><em>Once again, I’d like to thank <a href="https://twitter.com/tieknimmers">@tieknimmers</a> and <a href="https://twitter.com/pulsoid">@pulsoid</a> for their invaluable support during the writing of this article and for putting up with my endless questions and queries.</em></p>
					</div><!-- .entry-content -->
			
					</article><!-- #post-4682 -->

					

		</div>


		<!-- Sidenav -->
		

	</div>
</div></div>
  </body>
</html>
