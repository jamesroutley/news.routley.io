<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://holmeinbuch.de/repo/txmppc/file?name=txmppc.c&amp;ci=tip">Original</a>
    <h1>Simple XMPP command line client</h1>
    
    <div id="readability-page-1" class="page"><div>
<pre>/*
-- Tiny XMPP Client --
txmppc reads commands from stdin and prints to stdout.
It is a KISS client for command line or automation.

Out of scope:
roster -&gt; there is a presence list -&gt; no name (alias), group or subscription state
MUC management -&gt; basic works: join (with password), write and leave -&gt; no administration, invitation, register, disco, ...
no disco, bookmark, pubsub, vcard, files, voice, ...
OMEMO - encryption is good, but too complicated for a tiny client:
  There is one lib ( https://github.com/gkdr/libomemo ) and profanity has a good implementation, but the code of omemo is 5x larger than txmppc.
  -&gt; profanity (tui - OMEMO, OTR and PGP and plugins) -&gt; https://profanity-im.github.io/ (c uses libstrophe)
  -&gt; poezio (tui - OMEMO and OTR) -&gt; https://poez.io/ (python uses slixmpp lib)
  -&gt; mcabber (tui - No OMEMO, but OTR and PGP, external scripts + fifo) -&gt; https://mcabber.com/ (c uses lib loudmouth -&gt; https://github.com/mcabber/loudmouth )
  -&gt; xmppc (cli, which can send messages (chat + PGP), monitor and query some data) -&gt; https://codeberg.org/Anoxinon_e.V./xmppc (c uses libstrophe)
  -&gt; smplxmpp -&gt; https://codeberg.org/tropf/smplxmpp (c++ uses gloox lib)
  -&gt; freetalk -&gt; https://www.gnu.org/software/freetalk/ (c uses loudmouth)
  -&gt; jj (creates filesystem (fifo) structure) -&gt; https://23.fi/jj/ (c uses loudmouth)

Build:
Depends only on libstophe
&gt; gcc txmppc.c -lstrophe -o txmppc
Static compile (musl)
&gt; gcc txmppc.c -lstrophe -lc -lssl -lcrypto -lexpat -static -o txmppc_static
  (depending on libstrophe, it can be xml2 instead of expat and/or gnutls instead of openssl)
optional: &gt; strip txmppc_static

Use:
[echo &#34;command jid message&#34; |] txmppc[_static] &lt;jid&gt; &lt;pass&gt; [&lt;server&gt;[(:|=)&lt;port&gt;]]
- jid and password are mandatory
- optional is a third parameter with server (and :port or =port -&gt; ignores if tls startup (self-signed cert) fails)

txmppc logs incomming messages to stdout and reads commands from stdin
- just start as a slim client:
  &gt; txmppc
- Sending single message:
  &gt; echo &#34;[mM] jid message&#34; | txmppc
    -&gt; txmppc executes the command and exits (on close of stdin)
- Using fifo for commands:
  &gt; tail -f fifo | txmppc
    -&gt; executes the commands from fifo and prints to stdout
  &gt; echo &#34;q&#34; &gt;&gt; fifo # ! tail will still wait - so it doesn&#39;t exit -&gt; send another line
- tmux horizontal split + rlwrap client example:
  (mkfifo fifo; echo &#34;contact@example.com&#34; &gt;&gt; jid_file)
  90% pane&gt; while read line; do printf &#39;%s: &gt; %s\n&#39; &#34;$(date &#34;+%Y-%m-%d %H:%M&#34;)&#34; &#34;${line}&#34; &gt;&amp;2; printf &#39;%s\n&#39; &#34;${line}&#34;; test &#34;q&#34; = &#34;${line}&#34; &amp;&amp; break; done &lt; fifo | txmppc JID PASS | while read line; do printf &#39;%s: %s\n&#39; &#34;$(date &#34;+%Y-%m-%d %H:%M&#34;)&#34; &#34;${line}&#34;; done
  10% pane&gt; rlwrap -s -10 -H /dev/null -b &#34; &#34; -f jid_file awk &#39;{print} /^q$/ {exit}&#39; &gt;&gt; fifo
  -&gt; readline editing with 10 lines history (not saved) and jid completion from fid_file, output will have a date prepended
  -&gt; Hint: In that case the fifo can&#39;t be used for other processes, because sending an EOF will end the client.

Commands:
j[ muc [password]] -&gt; join multi user conference (without muc &#34;join&#34; presence status changes - default on)
J muc [password] -&gt; join multi user conference - no history
l[ muc] -&gt; leave multi user conference (without muc &#34;leave&#34; presence status changes)
[m ]jid[ message] -&gt; send (chat) message to jid (without message enter multi line mode)
h jid message -&gt; send headline message to jid
n jid message -&gt; send normal message to jid
M muc_jid message -&gt; send (groupchat) message to multi user conference (if not in the muc, it will be joined and left)
.[ message] -&gt; send (chat|headline|normal|groupchat) message to last jid (without message enter multi line mode)
p[ [priority] presence [status]] -&gt; priority: -128 / 127, presence: on[line]|of[fline]|aw[ay]|ch[at]|dn[d]|xa
  -&gt; without arg: show presence list; without priority: change presence only
P[ jid [priority] presence [status]] -&gt; send presence to jid, extra presence: subscribe|subscribed|unsubscribe|unsubscribed
  -&gt; without arg show presence list including unavailable/offline
q -&gt; end/exit

Output:
i -&gt; info
I -&gt; Info offline, lost connection
p -&gt; presence (join/leave status changes with j/l command)
P -&gt; presence list
m -&gt; message chat (&#34;m from: message&#34;, if carbon from self &#34;m -&gt; to: message&#34;)
n -&gt; message normal
h -&gt; message headline
M -&gt; message muc
H -&gt; message muc history
e -&gt; error
W -&gt; Warn - command error
E -&gt; (stderr) startup error -&gt; will exit

License:
https://holmeinbuch.de/repo/txmppc/ - matthias@

Copyright (c) ISC License

Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED &#34;AS IS&#34; AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;signal.h&gt;
#include &lt;sys/select.h&gt;
#include &lt;time.h&gt;
#include &lt;unistd.h&gt;
// https://www.rfc-editor.org/rfc/rfc6120 - core
// https://www.rfc-editor.org/rfc/rfc6121 - IM + presence
#include &lt;strophe.h&gt;

static unsigned short ignore_cert_fail = 0;
static short reconnect = 1;
// https://www.rfc-editor.org/rfc/rfc6120 -&gt; 4.6.4 Use of Checking Methods: RECOMMENDED not more than once every 5 minutes
#define PING_INTERVAL 60
static char ping_id[32];
#define BUFIN_MAX 4096
// https://www.rfc-editor.org/rfc/rfc6121 -&gt; don&#39;t mess with priority, negative might get no messages
static short conn_priority = 0;
static unsigned short show_presence_status_change = 1;
#define PRESENCE_MAX 5
#define PRESENCE_JID_MAX 9
static char presence_type[10][13] = {&#34;offline&#34;, &#34;online&#34;, &#34;away&#34;, &#34;chat&#34;, &#34;dnd&#34;, &#34;xa&#34;, &#34;subscribe&#34;, &#34;subscribed&#34;, &#34;unsubscribe&#34;, &#34;unsubscribed&#34;};
#define PRESENCE_OFFLINE 0
#define PRESENCE_ONLINE 1
#define PRESENCE_ONLINE_MUC -1
#define PRESENCE_ONLINE_MUC_NO_HISTORY -101
#define PRESENCE_OFFLINE_MUC -100
// https://www.rfc-editor.org/rfc/rfc7622 - address (jid)
#define JID_MAX 3071 + 1
static char last_sent_type_jid[1 + JID_MAX];
struct list_node {
  char jid[JID_MAX];
  short presence;
  short priority;
  struct list_node *next;
};
static struct list_node *jid_list = NULL;
// https://xmpp.org/extensions/xep-0172.html - nick -&gt; nickname length not defined
// https://xmpp.org/extensions/xep-0045.html - muc -&gt; nickname is resource part of jid
#define NICK_MAX 1023 + 1
static char nick[NICK_MAX];
static short multi_line = 0;

unsigned short get_start_pos(char *buf, unsigned short start_pos) {
  unsigned short buf_len = (unsigned short)strlen(&amp;buf[start_pos]) + start_pos;

  for (unsigned short i = start_pos; i &lt; buf_len; i++) {
    if (!isspace(buf[i])) {
      return i;
    }
  }
  return buf_len;
}

void update_jid_list(const char *jid, short presence, short priority) {
  struct list_node *list_before = NULL;
  struct list_node *list_current = jid_list;
  struct list_node *list_new = NULL;
  size_t jid_len = strlen(jid);

  while (list_current) {
    int jid_match = strncmp(jid, list_current-&gt;jid, jid_len);

    if (jid_match == 0) {
      if (presence == PRESENCE_OFFLINE_MUC) {
        // remove jid, who leave the muc from list
        // if self leaves muc, called with bare jid -&gt; remove every muc entry
        while (list_current &amp;&amp; strncmp(jid, list_current-&gt;jid, jid_len) == 0) {
          if (list_before) {
            list_before-&gt;next = list_current-&gt;next;
            free(list_current);
            list_current = list_before-&gt;next;
          } else {
            jid_list = list_current-&gt;next;
            free(list_current);
            list_current = jid_list-&gt;next;
          }
        }
        return;
      }
      // update jid state for self and subscription (offline too)
      list_current-&gt;presence = presence;
      list_current-&gt;priority = priority;
      return;
    }
    if (jid_match &lt; 0) {
      // insert new jid here
      break;
    }
    list_before = list_current;
    list_current = list_current-&gt;next;
  }
  list_new = (struct list_node*) malloc(sizeof(struct list_node));
  strncpy(list_new-&gt;jid, jid, JID_MAX - 1);
  list_new-&gt;presence = presence;
  list_new-&gt;priority = priority;
  if (list_before) {
    list_before-&gt;next = list_new;
  } else {
    jid_list = list_new;
  }
  list_new-&gt;next = list_current;
}

void send_presence(xmpp_conn_t *conn, short presence_index, const char *status_text, const char *jid, const char *priority_text) {
  xmpp_ctx_t *ctx = xmpp_conn_get_context(conn);
  xmpp_stanza_t *presence_stanza = xmpp_presence_new(ctx);

  if (jid) {
    xmpp_stanza_set_to(presence_stanza, jid);
  }
  if (presence_index == PRESENCE_OFFLINE) {
    xmpp_stanza_set_type(presence_stanza, &#34;unavailable&#34;);
  } else if (PRESENCE_MAX &lt; presence_index) {
    xmpp_stanza_set_type(presence_stanza, presence_type[presence_index]);
  // inverse presence for muc
  } else if (presence_index &lt; 0) {
    // MUC special
    xmpp_stanza_t *extension_stanza;
    unsigned short jid_len = (unsigned short)strlen(jid);
    unsigned short i = 0;

    for (;;) {
      // muc_jid is only muc, no nick
      if (i == jid_len) {
        char muc_jid_nick[JID_MAX];

        if (JID_MAX - 1 - NICK_MAX &lt; strlen(jid)) {
          fprintf(stdout, &#34;W invalid muc jid\n&#34;);
          fflush(stdout);
          xmpp_stanza_release(presence_stanza);
          return;
        }
        sprintf(muc_jid_nick, &#34;%s/%s&#34;, jid, nick);
        xmpp_stanza_set_to(presence_stanza, muc_jid_nick);
        break;
      }
      // muc_jid contains nick
      if (jid[i++] == &#39;/&#39;) {
        break;
      }
    }
    extension_stanza = xmpp_stanza_new(ctx);
    xmpp_stanza_set_name(extension_stanza, &#34;x&#34;);
    xmpp_stanza_set_ns(extension_stanza, &#34;http://jabber.org/protocol/muc&#34;);
    if (presence_index == PRESENCE_ONLINE_MUC_NO_HISTORY) {
      xmpp_stanza_t *history_stanza;

      history_stanza = xmpp_stanza_new(ctx);
      xmpp_stanza_set_name(history_stanza, &#34;history&#34;);
      xmpp_stanza_set_attribute(history_stanza, &#34;maxstanzas&#34;, &#34;0&#34;);
      xmpp_stanza_add_child_ex(extension_stanza, history_stanza, 0);
    }
    if (status_text) {
      xmpp_stanza_t *password_stanza, *value_stanza;

      password_stanza = xmpp_stanza_new(ctx);
      xmpp_stanza_set_name(password_stanza, &#34;password&#34;);
      value_stanza = xmpp_stanza_new(ctx);
      xmpp_stanza_set_text(value_stanza, status_text);
      xmpp_stanza_add_child_ex(password_stanza, value_stanza, 0);
      xmpp_stanza_add_child_ex(extension_stanza, password_stanza, 0);
    }
    xmpp_stanza_add_child_ex(presence_stanza, extension_stanza, 0);
  } else {
    if (1 &lt; presence_index) {
      xmpp_stanza_t *show_stanza, *value_stanza;

      show_stanza = xmpp_stanza_new(ctx);
      xmpp_stanza_set_name(show_stanza, &#34;show&#34;);
      value_stanza = xmpp_stanza_new(ctx);
      xmpp_stanza_set_text(value_stanza, presence_type[presence_index]);
      xmpp_stanza_add_child_ex(show_stanza, value_stanza, 0);
      xmpp_stanza_add_child_ex(presence_stanza, show_stanza, 0);
    }
    if (priority_text || (conn_priority &amp;&amp; -128 &lt; conn_priority &amp;&amp; conn_priority &lt; 127)) {
      xmpp_stanza_t *priority_stanza, *value_stanza;

      priority_stanza = xmpp_stanza_new(ctx);
      xmpp_stanza_set_name(priority_stanza, &#34;priority&#34;);
      value_stanza = xmpp_stanza_new(ctx);
      if (!priority_text) {
        char conn_priority_text[5];
        sprintf(conn_priority_text, &#34;%d&#34;, conn_priority);
        xmpp_stanza_set_text(value_stanza, conn_priority_text);
      } else {
        xmpp_stanza_set_text(value_stanza, priority_text);
      }
      xmpp_stanza_add_child_ex(priority_stanza, value_stanza, 0);
      xmpp_stanza_add_child_ex(presence_stanza, priority_stanza, 0);
    }
    if (status_text) {
      xmpp_stanza_t *status_stanza, *value_stanza;

      status_stanza = xmpp_stanza_new(ctx);
      xmpp_stanza_set_name(status_stanza, &#34;status&#34;);
      value_stanza = xmpp_stanza_new(ctx);
      xmpp_stanza_set_text(value_stanza, status_text);
      xmpp_stanza_add_child_ex(status_stanza, value_stanza, 0);
      xmpp_stanza_add_child_ex(presence_stanza, status_stanza, 0);
    }
  }
  xmpp_send(conn, presence_stanza);
  xmpp_stanza_release(presence_stanza);
}

void disconnect(xmpp_conn_t *conn) {
  if (reconnect == 1) {
    reconnect = 0;
  }
  send_presence(conn, PRESENCE_OFFLINE, NULL, NULL, NULL);
  xmpp_disconnect(conn);
}

void send_message(xmpp_conn_t *conn, const char *jid, const char command, const char *text) {
  xmpp_ctx_t *ctx = xmpp_conn_get_context(conn);
  xmpp_stanza_t *message_stanza;
  xmpp_stanza_t *extension_stanza = NULL;
  const char *type = &#34;chat&#34;;

  switch (command) {
    case &#39;x&#39;:
      // x: m -&gt; jid in muc
      extension_stanza = xmpp_stanza_new(ctx);
      break;
    case &#39;M&#39;:
      type = &#34;groupchat&#34;;
      break;
    case &#39;h&#39;:
      type = &#34;headline&#34;;
      break;
    case &#39;N&#39;:
      // N: n -&gt; jid in muc
      extension_stanza = xmpp_stanza_new(ctx);
      // fall through
    case &#39;n&#39;:
      type = &#34;normal&#34;;
      break;
  }
  message_stanza = xmpp_message_new(ctx, type, jid, NULL);
  xmpp_message_set_body(message_stanza, text);
  if (extension_stanza) {
    xmpp_stanza_set_name(extension_stanza, &#34;x&#34;);
    xmpp_stanza_set_ns(extension_stanza, &#34;http://jabber.org/protocol/muc#user&#34;);
    xmpp_stanza_add_child_ex(message_stanza, extension_stanza, 0);
  }
  xmpp_send(conn, message_stanza);
  xmpp_stanza_release(message_stanza);
}

short muc_in_jid_list(const char *jid) {
  struct list_node *list_current = jid_list;
  unsigned short jid_len = (unsigned short)strlen(jid);

  while (list_current) {
    // inverse presence for muc jid
    if (list_current-&gt;presence &lt; 0 &amp;&amp; strncmp(jid, list_current-&gt;jid, jid_len) == 0) {
      return 1;
    }
    list_current = list_current-&gt;next;
  }
  return 0;
}

int input_handler(xmpp_conn_t *conn, void *userdata) {
  struct timeval tv;
  fd_set rd;
  int cin;
  char bufin[BUFIN_MAX];
  unsigned short bufin_len = 0;
  unsigned short index;
  // starting with a jid -&gt; default (chat) [m]essage to jid
  char command = &#39;m&#39;;
  char *jid = NULL;

  if (reconnect &lt; 0) {
    // signal received
    disconnect(conn);
    return 1;
  }
  FD_ZERO(&amp;rd);
  FD_SET(0, &amp;rd);
  tv.tv_sec = 0;
  tv.tv_usec = 250;
  cin = select(1, &amp;rd, 0, 0, &amp;tv);
  if (cin == 0) {
    // timeout - no input
    return 1;
  }
  if (cin == -1) {
    // stdin broken
    disconnect(conn);
    return 1;
  }
  while (cin != &#39;\n&#39;) {
    cin = fgetc(stdin);
    if (cin == EOF) {
      disconnect(conn);
      return 1;
    }
    // if space left, else still read/remove everything from input
    if (bufin_len &lt; BUFIN_MAX - 1) {
      bufin[bufin_len++] = (char)cin;
    }
  }
  if (bufin_len == BUFIN_MAX - 1) {
    fprintf(stdout, &#34;W too much input\n&#34;);
    fflush(stdout);
    return 1;
  }
  while (0 &lt; bufin_len &amp;&amp; isspace(bufin[bufin_len - 1])) {
    // trim end of input
    bufin_len--;
  }
  bufin[bufin_len] = 0;
  if (multi_line) {
    if (bufin[0] == &#39;.&#39; &amp;&amp; bufin[1] == 0) {
      if (multi_line == -1) {
        send_presence(conn, PRESENCE_OFFLINE, NULL, &amp;last_sent_type_jid[1], NULL);
      }
      multi_line = 0;
      fprintf(stdout, &#34;i end multi line\n&#34;);
      fflush(stdout);
      return 1;
    }
    send_message(conn, &amp;last_sent_type_jid[1], last_sent_type_jid[0], bufin);
    return 1;
  }
  if (bufin[0] == 0) {
    // ignore empty lines
    return 1;
  }
  // trim start
  index = get_start_pos(bufin, 0);

  if (bufin[index + 1] == &#39; &#39;) {
    // get command (if second char is empty it is no jid)
    command = bufin[index];
    index = get_start_pos(bufin, index + 2);
  } else if (bufin[index + 1] == 0) {
    // just single char command
    struct list_node *list_current;
    char priority_text[8];
    unsigned short show_offline = 0;

    command = bufin[index];
    switch (command) {
      case &#39;q&#39;:
        disconnect(conn);
        return 1;
      case &#39;P&#39;:
        show_offline = 1;
        // fall through
      case &#39;p&#39;:
        list_current = jid_list;
        while (list_current) {
          if (list_current-&gt;priority) {
            sprintf(priority_text, &#34; (%d)&#34;, list_current-&gt;priority);
          } else {
            priority_text[0] = 0;
          }
          if (list_current-&gt;presence &lt; 0) {
            // use inverse presence for muc
            fprintf(stdout, &#34;P %s (M) - %s%s\n&#34;, list_current-&gt;jid, presence_type[-list_current-&gt;presence], priority_text);
          } else if (show_offline || list_current-&gt;presence != PRESENCE_OFFLINE) {
            fprintf(stdout, &#34;P %s - %s%s\n&#34;, list_current-&gt;jid, presence_type[list_current-&gt;presence], priority_text);
          }
          list_current = list_current-&gt;next;
        }
        fflush(stdout);
        return 1;
      case &#39;l&#39;:
        show_presence_status_change = 0;
        return 1;
      case &#39;j&#39;:
        show_presence_status_change = 1;
        return 1;
      case &#39;.&#39;:
        if (last_sent_type_jid[0] == 0) {
          fprintf(stdout, &#34;W no last jid\n&#34;);
          fflush(stdout);
          return 1;
        }
        multi_line = 1;
        if (last_sent_type_jid[0] == &#39;M&#39;) {
          if (!muc_in_jid_list(&amp;last_sent_type_jid[1])) {
            multi_line = -1;
          }
        }
        fprintf(stdout, &#34;i multi line - end with \&#34;.\&#34;\n&#34;);
        fflush(stdout);
        return 1;
    }
  }
  if (command != &#39;.&#39; &amp;&amp; command != &#39;m&#39; &amp;&amp; command != &#39;M&#39; &amp;&amp; command != &#39;j&#39; &amp;&amp; command != &#39;J&#39; &amp;&amp; command != &#39;l&#39; &amp;&amp; command != &#39;p&#39; &amp;&amp; command != &#39;P&#39; &amp;&amp; command != &#39;n&#39; &amp;&amp; command != &#39;h&#39;) {
    fprintf(stdout, &#34;W invalid command\n&#34;);
    fflush(stdout);
    return 1;
  }

  if (command != &#39;.&#39; &amp;&amp; command != &#39;p&#39;) {
    // get jid (if not message to last jid or global presence)
    unsigned short jid_local_and_domain = 0;

    for (unsigned short i = index; i &lt; bufin_len; i++) {
      if (bufin[i] == &#39;@&#39;) {
        // simple identification of jid (no real validation)
        jid_local_and_domain++;
      } else if (jid_local_and_domain == 1 &amp;&amp; bufin[i] == &#39; &#39;) {
        bufin[i] = 0;
        jid = &amp;bufin[index];
        index = i + 1;
        break;
      } else if (jid_local_and_domain == 1 &amp;&amp; bufin[i + 1] == 0) {
        jid = &amp;bufin[index];
        index = i + 1;
        break;
      }
    }
    if (!jid || JID_MAX &lt; strlen(jid)) {
      fprintf(stdout, &#34;W invalid jid\n&#34;);
      fflush(stdout);
      return 1;
    }
  }

  if (command == &#39;j&#39; || command == &#39;J&#39;) {
    // join room
    const char *password = &amp;bufin[get_start_pos(bufin, index)];

    send_presence(conn, command == &#39;j&#39; ? PRESENCE_ONLINE_MUC : PRESENCE_ONLINE_MUC_NO_HISTORY, password[0] == 0 ? NULL : password, jid, NULL);
    return 1;
  }
  if (command == &#39;l&#39;) {
    // leave room
    send_presence(conn, PRESENCE_OFFLINE, NULL, jid, NULL);
    return 1;
  }
  if (command == &#39;p&#39; || command == &#39;P&#39;) {
    // sending presence
    char *presence_text = &amp;bufin[index];
    char *status_text = NULL;
    char *priority_text = NULL;
    short priority = 0;

    index = get_start_pos(bufin, index);
    while (index &lt; bufin_len) {
      if (bufin[index] != &#39; &#39;) {
        index++;
        continue;
      }
      bufin[index] = 0;
      index = get_start_pos(bufin, index + 1);
      priority = (short)atoi(presence_text);
      if (priority == 0 &amp;&amp; (presence_text[0] != &#39;0&#39; || presence_text[1] != 0)) {
        status_text = &amp;bufin[index];
        break;
      } else {
        priority_text = presence_text;
        if (command == &#39;p&#39;) {
          // keep priority (if global presence)
          conn_priority = priority;
        }
        presence_text = &amp;bufin[index];
      }
    }
    if (presence_text[0] == 0) {
      fprintf(stdout, &#34;W no presence\n&#34;);
      fflush(stdout);
      return 1;
    }
    if (strcmp(presence_text, &#34;unavailable&#34;) == 0) {
      // special check for word unavailable instead of offline
      send_presence(conn, PRESENCE_OFFLINE, status_text, jid, NULL);
      return 1;
    }
    for (short i = 0; i &lt;= PRESENCE_JID_MAX; i++) {
      if (!jid &amp;&amp; PRESENCE_MAX &lt; i) {
        fprintf(stdout, &#34;W subscription with invalid jid\n&#34;);
        fflush(stdout);
        return 1;
      }
      if ((i &lt;= PRESENCE_MAX &amp;&amp; strncmp(presence_text, presence_type[i], 2) == 0) || strcmp(presence_text, presence_type[i]) == 0) {
        send_presence(conn, i, status_text, jid, priority_text);
        return 1;
      }
    }
    fprintf(stdout, &#34;W invalid presence\n&#34;);
    fflush(stdout);
    return 1;
  }

  if (command == &#39;m&#39; || command == &#39;M&#39; || command == &#39;h&#39; || command == &#39;n&#39; || command == &#39;.&#39;) {
    // sending message
    unsigned short muc_leave = 0;

    if (command == &#39;.&#39;) {
      // sending with last command to last jid -&gt; restore values
      if (last_sent_type_jid[0] == 0) {
        fprintf(stdout, &#34;W no last jid\n&#34;);
        fflush(stdout);
        return 1;
      }
      command = last_sent_type_jid[0];
      jid = &amp;last_sent_type_jid[1];
    } else {
      // save values for &#39;.&#39; command next time
      last_sent_type_jid[0] = command;
      strncpy(&amp;last_sent_type_jid[1], jid, JID_MAX - 1);
    }
    if (command == &#39;m&#39; || command == &#39;n&#39;) {
      if (muc_in_jid_list(jid)) {
        // marker for sending to jid in muc
        command = command == &#39;m&#39; ? &#39;x&#39; : &#39;N&#39;;
        last_sent_type_jid[0] = command;
      }
    } else if (command == &#39;M&#39;) {
      if (!muc_in_jid_list(jid)) {
        send_presence(conn, PRESENCE_ONLINE_MUC_NO_HISTORY, NULL, jid, NULL);
        muc_leave = 1;
      }
    }
    if (bufin[index] == 0) {
      // no message text -&gt; use multi line mode
      multi_line = muc_leave ? -1 : 1;
      fprintf(stdout, &#34;i multi line - end with \&#34;.\&#34;\n&#34;);
      fflush(stdout);
      return 1;
    }
    send_message(conn, jid, command, &amp;bufin[index]);
    if (muc_leave) {
      send_presence(conn, PRESENCE_OFFLINE, NULL, jid, NULL);
    }
    return 1;
  }
  // should not get here...
  fprintf(stdout, &#34;W invalid input\n&#34;);
  fflush(stdout);
  return 1;
}

void print_stanza_error(xmpp_ctx_t *ctx, xmpp_stanza_t *stanza, const char* error_from) {
  xmpp_stanza_t *error_stanza, *defined_condition_stanza, *text_stanza;
  const char *error_name, *error_ns;

  error_stanza = xmpp_stanza_get_child_by_name(stanza, &#34;error&#34;);
  if (!error_stanza) {
    return;
  }
  defined_condition_stanza = xmpp_stanza_get_child_by_ns(error_stanza, &#34;urn:ietf:params:xml:ns:xmpp-stanzas&#34;);
  while (defined_condition_stanza) {
    // the name is one out of 22 defined conditions, but stanzas in that namespace are only 1 or 2
    error_ns = xmpp_stanza_get_ns(defined_condition_stanza);
    if (error_ns &amp;&amp; strcmp(error_ns, &#34;urn:ietf:params:xml:ns:xmpp-stanzas&#34;) == 0) {
      error_name = xmpp_stanza_get_name(defined_condition_stanza);
      if (error_name &amp;&amp; strcmp(error_name, &#34;text&#34;) != 0) {
        break;
      }
    }
    defined_condition_stanza = xmpp_stanza_get_next(defined_condition_stanza);
  }
  text_stanza = xmpp_stanza_get_child_by_name(error_stanza, &#34;text&#34;);
  if (text_stanza) {
    char *error_text = xmpp_stanza_get_text(text_stanza);

    fprintf(stdout, &#34;e %s -&gt; %s - %s: %s\n&#34;, error_from, xmpp_stanza_get_type(error_stanza), error_name, error_text);
    xmpp_free(ctx, error_text);
  } else {
    fprintf(stdout, &#34;e %s -&gt; %s - %s\n&#34;, error_from, xmpp_stanza_get_type(error_stanza), error_name);
  }
  fflush(stdout);
}

int presence_handler(xmpp_conn_t *conn, xmpp_stanza_t *presence_stanza, void *userdata) {
  xmpp_ctx_t *ctx = xmpp_conn_get_context(conn);
  const char *presence_from = xmpp_stanza_get_from(presence_stanza);
  xmpp_stanza_t *status_stanza = xmpp_stanza_get_child_by_name(presence_stanza, &#34;status&#34;);
  short presence = PRESENCE_ONLINE;
  const char *type;
  char *status_text = NULL;

  if (!presence_from) {
    presence_from = &#34;&#34;;
  }
  if (status_stanza) {
    status_text = xmpp_stanza_get_text(status_stanza);
  }
  type = xmpp_stanza_get_type(presence_stanza);
  if (type) {
    if (strcmp(type, &#34;error&#34;) == 0) {
      print_stanza_error(ctx, presence_stanza, presence_from);
    } else if (strcmp(type, &#34;unavailable&#34;) == 0) {
      xmpp_stanza_t *extension_stanza = xmpp_stanza_get_child_by_name_and_ns(presence_stanza, &#34;x&#34;, &#34;http://jabber.org/protocol/muc#user&#34;);

      if (extension_stanza) {
        // presence from a muc jid
        xmpp_stanza_t *x_status_stanza = xmpp_stanza_get_child_by_name(extension_stanza, &#34;status&#34;);
        unsigned short is_self_jid = 0;

        while (x_status_stanza) {
          const char *code_text = xmpp_stanza_get_attribute(x_status_stanza, &#34;code&#34;);

          if (code_text) {
            unsigned short code = (unsigned short)atoi(code_text);
            switch (code) {
              case 110:
                // self presence
                is_self_jid++;
                break;
              case 210:
                // nick assigned or modified
                // fall through
              case 303:
                // new nick
                is_self_jid--;
                break;
            }
          }
          x_status_stanza = xmpp_stanza_get_next(x_status_stanza);
        }
        if (is_self_jid == 1) {
          // bare muc jid will remove every room occupant
          char *jid_bare = xmpp_jid_bare(ctx, presence_from);
          update_jid_list(jid_bare, PRESENCE_OFFLINE_MUC, 0);
          xmpp_free(ctx, jid_bare);
        } else {
          // other muc jid - only remove that
          update_jid_list(presence_from, PRESENCE_OFFLINE_MUC, 0);
        }
      } else {
        // no muc jid - change of presence status
        update_jid_list(presence_from, PRESENCE_OFFLINE, 0);
      }
      if (show_presence_status_change) {
        if (status_text) {
          fprintf(stdout, &#34;p %s -&gt; offline: %s\n&#34;, presence_from, status_text);
        } else {
          fprintf(stdout, &#34;p %s -&gt; offline\n&#34;, presence_from);
        }
      }
    } else {
      // &#34;subscribe&#34;, &#34;subscribed&#34;, &#34;unsubscribe&#34;, &#34;unsubscribed&#34;(, &#34;probe&#34; - server only)
      fprintf(stdout, &#34;p %s -&gt; %s\n&#34;, presence_from, type);
    }
  } else {
    char *show_text = NULL;
    short priority = 0;
    xmpp_stanza_t *priority_stanza, *show_stanza;

    priority_stanza = xmpp_stanza_get_child_by_name(presence_stanza, &#34;priority&#34;);
    if (priority_stanza) {
      char *priority_text = xmpp_stanza_get_text(priority_stanza);

      if (priority_text) {
        priority = (short)atoi(priority_text);
      }
      xmpp_free(ctx, priority_text);
    }
    show_stanza = xmpp_stanza_get_child_by_name(presence_stanza, &#34;show&#34;);
    if (show_stanza) {
      show_text = xmpp_stanza_get_text(show_stanza);
      if (show_text) {
        // skip 0 offline and 1 online
        for (short i = 2; i &lt;= PRESENCE_MAX; i++) {
          if (strncmp(show_text, presence_type[i], 2) == 0) {
            presence = i;
            break;
          }
        }
      }
    }
    if (xmpp_stanza_get_child_by_name_and_ns(presence_stanza, &#34;x&#34;, &#34;http://jabber.org/protocol/muc#user&#34;)) {
      // use inverse presence for muc
      update_jid_list(presence_from, -presence, priority);
    } else {
      update_jid_list(presence_from, presence, priority);
    }
    if (show_presence_status_change) {
      char priority_text[8];

      priority_text[0] = 0;
      if (priority) {
        sprintf(priority_text, &#34; (%d)&#34;, priority);
      }
      fprintf(stdout, &#34;p %s -&gt; %s%s&#34;, presence_from, show_text ? show_text : &#34;online&#34;, priority_text);
      if (status_text) {
        fprintf(stdout, &#34;: %s\n&#34;, status_text);
      } else {
        fprintf(stdout, &#34;\n&#34;);
      }
    }
    if (show_text) {
      xmpp_free(ctx, show_text);
    }
  }
  if (status_text) {
    xmpp_free(ctx, status_text);
  }
  fflush(stdout);
  return 1;
}

int message_handler(xmpp_conn_t *conn, xmpp_stanza_t *message_stanza, void *userdata) {
  xmpp_ctx_t *ctx = xmpp_conn_get_context(conn);
  const char *type = xmpp_stanza_get_type(message_stanza);
  xmpp_stanza_t *carbons_stanza, *body_stanza, *subject_stanza;
  const char *message_from = NULL;
  const char *carbons_sent = &#34;&#34;;
  char indicator = &#39;m&#39;;
  char *message_text;

  if (!type) {
    return 1;
  }
  // https://xmpp.org/extensions/xep-0280.html
  carbons_stanza = xmpp_stanza_get_child_by_ns(message_stanza, &#34;urn:xmpp:carbons:2&#34;);
  if (carbons_stanza) {
    xmpp_stanza_t *forward_stanza, *forward_message_stanza;
    const char *carbons_name, *conn_jid, *sender_jid;

    conn_jid = xmpp_conn_get_jid(conn);
    sender_jid = xmpp_stanza_get_from(message_stanza);
    if (!conn_jid || !sender_jid || strcmp(conn_jid, sender_jid) != 0) {
      // fake sender
      return 1;
    }
    carbons_name = xmpp_stanza_get_name(carbons_stanza);
    if (carbons_name &amp;&amp; strcmp(carbons_name, &#34;sent&#34;) == 0) {
      carbons_sent = &#34;-&gt; &#34;;
    } else if (!carbons_name || strcmp(carbons_name, &#34;received&#34;) != 0) {
      // invalid carbon type
      return 1;
    }
    forward_stanza = xmpp_stanza_get_child_by_ns(carbons_stanza, &#34;urn:xmpp:forward:0&#34;);
    if (!forward_stanza) {
      return 1;
    }
    forward_message_stanza = xmpp_stanza_get_child_by_name(forward_stanza, &#34;message&#34;);
    if (!forward_message_stanza) {
      return 1;
    }
    if (xmpp_stanza_get_child_by_name_and_ns(forward_message_stanza, &#34;private&#34;, &#34;urn:xmpp:carbons:2&#34;)) {
      // invalid private -&gt; no carbons
      return 1;
    }
    if (xmpp_stanza_get_child_by_name_and_ns(forward_message_stanza, &#34;x&#34;, &#34;http://jabber.org/protocol/muc#user&#34;)) {
      const char *message_to = xmpp_stanza_get_to(forward_message_stanza);
      if (message_to) {
        if (!muc_in_jid_list(message_to)) {
          // invalid message not in muc with this client
          return 1;
        }
      }
    }
    message_stanza = forward_message_stanza;
  }
  if (carbons_sent[0] == 0) {
    message_from = xmpp_stanza_get_from(message_stanza);
  } else {
    // message_from is conn_jid
    message_from = xmpp_stanza_get_to(message_stanza);
  }
  if (!message_from) {
    message_from = &#34;&#34;;
  }
  if (strcmp(type, &#34;error&#34;) == 0) {
    print_stanza_error(ctx, message_stanza, message_from);
    return 1;
  }
  if (strcmp(type, &#34;groupchat&#34;) == 0) {
    if (xmpp_stanza_get_child_by_ns(message_stanza, &#34;urn:xmpp:delay&#34;)) {
      indicator = &#39;H&#39;;
    } else {
      indicator = &#39;M&#39;;
    }
  } else if (strcmp(type, &#34;headline&#34;) == 0) {
      indicator = &#39;h&#39;;
  } else if (strcmp(type, &#34;normal&#34;) == 0) {
      indicator = &#39;n&#39;;
  }
  subject_stanza = xmpp_stanza_get_child_by_name(message_stanza, &#34;subject&#34;);
  if (subject_stanza) {
    message_text = xmpp_stanza_get_text(subject_stanza);
    if (message_text) {
      fprintf(stdout, &#34;%c %s%s -&gt; subject: %s\n&#34;, indicator, carbons_sent, message_from, message_text);
      fflush(stdout);
    }
    xmpp_free(ctx, message_text);
  }
  body_stanza = xmpp_stanza_get_child_by_name(message_stanza, &#34;body&#34;);
  if (!body_stanza) {
    return 1;
  }
  message_text = xmpp_stanza_get_text(body_stanza);
  fprintf(stdout, &#34;%c %s%s: %s\n&#34;, indicator, carbons_sent, message_from, message_text ? message_text : &#34;&#34;);
  fflush(stdout);
  xmpp_free(ctx, message_text);
  return 1;
}

// https://xmpp.org/extensions/xep-0199.html - ping
int ping_send_handler(xmpp_conn_t *conn, void *userdata) {
  xmpp_ctx_t *ctx = xmpp_conn_get_context(conn);
  xmpp_stanza_t *iq_stanza, *ping_stanza;

  if (ping_id[0]) {
    // already sent -&gt; lost
    xmpp_disconnect(conn);
    return 1;
  }
  sprintf(ping_id, &#34;ping_server_%lu&#34;, time(NULL));
  iq_stanza = xmpp_iq_new(ctx, &#34;get&#34;, ping_id);
  ping_stanza = xmpp_stanza_new(ctx);
  xmpp_stanza_set_name(ping_stanza, &#34;ping&#34;);
  xmpp_stanza_set_ns(ping_stanza, &#34;urn:xmpp:ping&#34;);
  xmpp_stanza_add_child_ex(iq_stanza, ping_stanza, 0);
  xmpp_send(conn, iq_stanza);
  xmpp_stanza_release(iq_stanza);
  return 1;
}

int iq_handler(xmpp_conn_t *conn, xmpp_stanza_t *iq_stanza, void *userdata) {
  const char *type = xmpp_stanza_get_type(iq_stanza);
  const char *id = xmpp_stanza_get_id(iq_stanza);

  if (!type || !id) {
    return 1;
  }
  if (strcmp(type, &#34;result&#34;) == 0) {
    if (strcmp(ping_id, id) == 0) {
      ping_id[0] = 0;
    }
  } else if (strcmp(type, &#34;get&#34;) == 0) {
    xmpp_ctx_t *ctx = xmpp_conn_get_context(conn);
    const char* iq_from = xmpp_stanza_get_from(iq_stanza);
    xmpp_stanza_t *result_stanza;

    if (xmpp_stanza_get_child_by_ns(iq_stanza, &#34;urn:xmpp:ping&#34;)) {
      result_stanza = xmpp_iq_new(ctx, &#34;result&#34;, id);
    } else {
      xmpp_stanza_t *error_stanza, *defined_condition_stanza;

      result_stanza = xmpp_iq_new(ctx, &#34;error&#34;, id);
      error_stanza = xmpp_stanza_new(ctx);
      xmpp_stanza_set_name(iq_stanza, &#34;error&#34;);
      xmpp_stanza_set_type(error_stanza, &#34;cancel&#34;);
      defined_condition_stanza = xmpp_stanza_new(ctx);
      xmpp_stanza_set_name(defined_condition_stanza, &#34;service-unavailable&#34;);
      xmpp_stanza_set_ns(defined_condition_stanza, &#34;urn:ietf:params:xml:ns:xmpp-stanzas&#34;);
      xmpp_stanza_add_child_ex(error_stanza, defined_condition_stanza, 0);
      xmpp_stanza_add_child_ex(result_stanza, error_stanza, 0);
    }
    xmpp_stanza_set_to(result_stanza, iq_from ? iq_from : &#34;&#34;);
    xmpp_send(conn, result_stanza);
    xmpp_stanza_release(result_stanza);
  } else if (strcmp(type, &#34;error&#34;) == 0) {
    if (strcmp(ping_id, id) == 0) {
      if (xmpp_stanza_get_child_by_ns(iq_stanza, &#34;urn:xmpp:ping&#34;)) {
        xmpp_timed_handler_delete(conn, ping_send_handler);
        ping_id[0] = 0;
        xmpp_conn_set_keepalive(conn, PING_INTERVAL, PING_INTERVAL);
      }
    }
  }
  return 1;
}

int certfail_handler(const xmpp_tlscert_t *cert, const char *const error_message) {
  if (ignore_cert_fail) {
    return 1;
  }
  fprintf(stderr, &#34;E %s\n&#34;, error_message);
  fflush(stderr);
  reconnect = -1;
  return 0;
}

void conn_handler(xmpp_conn_t *conn, xmpp_conn_event_t status, int error, xmpp_stream_error_t *stream_error, void *userdata) {
  xmpp_ctx_t *ctx = xmpp_conn_get_context(conn);

  if (status == XMPP_CONN_CONNECT) {
    xmpp_stanza_t *carbons_stanza, *enable_stanza;

    xmpp_handler_add(conn, iq_handler, NULL, &#34;iq&#34;, NULL, NULL);
    xmpp_handler_add(conn, presence_handler, NULL, &#34;presence&#34;, NULL, NULL);
    xmpp_handler_add(conn, message_handler, NULL, &#34;message&#34;, NULL, NULL);
    xmpp_timed_handler_add(conn, input_handler, 750, NULL);
    xmpp_timed_handler_add(conn, ping_send_handler, PING_INTERVAL * 1000, NULL);
    send_presence(conn, PRESENCE_ONLINE, NULL, NULL, NULL);
    carbons_stanza = xmpp_iq_new(ctx, &#34;set&#34;, &#34;carbons_enable1&#34;);
    enable_stanza = xmpp_stanza_new(ctx);
    xmpp_stanza_set_name(enable_stanza, &#34;enable&#34;);
    xmpp_stanza_set_ns(enable_stanza, &#34;urn:xmpp:carbons:2&#34;);
    xmpp_stanza_add_child_ex(carbons_stanza, enable_stanza, 0);
    xmpp_send(conn, carbons_stanza);
    xmpp_stanza_release(carbons_stanza);
    fprintf(stdout, &#34;i online: %s\n&#34;, xmpp_conn_get_bound_jid(conn));
    fflush(stdout);
  } else {
    xmpp_timed_handler_delete(conn, ping_send_handler);
    xmpp_timed_handler_delete(conn, input_handler);
    xmpp_handler_delete(conn, message_handler);
    xmpp_handler_delete(conn, presence_handler);
    xmpp_handler_delete(conn, iq_handler);
    xmpp_stop(ctx);
  }
}

void signal_handler(int signum) {
  // inverse signum -&gt; negative reconnect means exit
  reconnect = (short)-signum;
}

int main(int argc, char **argv) {
  xmpp_ctx_t *ctx;
  xmpp_conn_t *conn;
  int connected;
  char *jid, *pass;
  char *server = NULL;
  unsigned short port = 0;

  if (argc &lt; 3) {
    fprintf(stderr, &#34;E Usage: %s &lt;jid&gt; &lt;pass&gt; [&lt;server&gt;[(:|=)&lt;port&gt;]]\n&#34;, argv[0]);
    fflush(stderr);
    return 1;
  }
  jid = argv[1];
  last_sent_type_jid[0] = 0;
  strncpy(nick, jid, NICK_MAX - 1);
  for (unsigned short i = 0; i &lt; NICK_MAX; i++) {
    // default nick from jid (if muc is not joined with muc_jid/nick)
    if (nick[i] == &#39;@&#39;) {
      nick[i] = 0;
      break;
    }
  }
  pass = argv[2];
  if (4 == argc) {
    // custom server and port
    for (unsigned short i = 0; i &lt; strlen(argv[3]); i++) {
      if (argv[3][i] == &#39;:&#39; || argv[3][i] == &#39;=&#39;) {
        if (argv[3][i] == &#39;=&#39;) {
          ignore_cert_fail = 1;
        }
        port = (unsigned short)atoi(&amp;argv[3][i + 1]);
        argv[3][i] = 0;
        break;
      }
    }
    server = argv[3];
  }
  srand((unsigned int)time(NULL));
  xmpp_initialize();
  //ctx = xmpp_ctx_new(NULL, xmpp_get_default_logger(XMPP_LEVEL_DEBUG));
  ctx = xmpp_ctx_new(NULL, NULL);
  if (!ctx) {
    fprintf(stderr, &#34;E cannot initialize ctx\n&#34;);
    fflush(stderr);
    return 1;
  }
  conn = xmpp_conn_new(ctx);
  if (!conn) {
    fprintf(stderr, &#34;E cannot initialize conn\n&#34;);
    fflush(stderr);
    return 1;
  }
  xmpp_conn_set_jid(conn, jid);
  xmpp_conn_set_pass(conn, pass);
  xmpp_conn_set_certfail_handler(conn, certfail_handler);
  signal(SIGINT, signal_handler);
  signal(SIGTERM, signal_handler);
  for (;;) {
    struct list_node *list_current;
    unsigned short unpredictable;

    ping_id[0] = 0;
    connected = xmpp_connect_client(conn, server, port, conn_handler, NULL);
    if (connected != XMPP_EOK) {
      fprintf(stderr, &#34;E connection failed\n&#34;);
      fflush(stderr);
      reconnect = -1;
      break;
    }
    xmpp_run(ctx);
    // clean jid presence list
    while (jid_list) {
      list_current = jid_list-&gt;next;
      free(jid_list);
      jid_list = list_current;
    }
    if (reconnect &lt;= 0) {
      fprintf(stdout, &#34;i offline\n&#34;);
      fflush(stdout);
      break;
    }
    // https://www.rfc-editor.org/rfc/rfc6120 -&gt; 3.3. Reconnection: SHOULD be set to an unpredictable number between 0 and 60 (seconds)
    unpredictable = (unsigned short)rand() % 61;
    fprintf(stdout, &#34;I offline - lost connection - try reconnect in %ds ...\n&#34;, unpredictable);
    fflush(stdout);
    sleep(unpredictable);
  }
  xmpp_conn_release(conn);
  xmpp_ctx_free(ctx);
  xmpp_shutdown();
  // reconnect is 0, -1 on ssl fail or -signum
  return -reconnect;
}


</pre>
</div></div>
  </body>
</html>
