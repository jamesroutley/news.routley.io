<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.tjll.net/a-beginners-guide-to-extending-emacs/">Original</a>
    <h1>A beginner&#39;s guide to extending Emacs</h1>
    
    <div id="readability-page-1" class="page"><div>
      
<hgroup>
  <h3>
    
    <a href="https://blog.tjll.net/blog-architecture-redux/">«</a>
    
    A Beginner&#39;s Guide to Extending Emacs
    
    <a href="https://blog.tjll.net/human-resources-misalignment/">»</a>
    
  </h3>
  <div>
    <ul id="post-details">
      <li> 4 February, 2025</li>
      <li>3,983 words</li>
      <li>17 minute read time</li>
    </ul>
  </div>
</hgroup>


        <section id="content">
	  
<p>
This post isn’t about the virtues of some editors versus others: <a href="https://www.murilopereira.com/the-values-of-emacs-the-neovim-revolution-and-the-vscode-gorilla/">that&#39;s already been written by somebody else</a> (and it’s really good) – if you want to know <i>why</i> I use emacs, I suggest reading that instead.
</p>

<p>
<i>This</i> post will help you understand why &#34;extensibility&#34; and &#34;introspectability&#34; are such prominent emacs features even without an emacs lisp background.
Bridging the gap from <a href="https://www.spacemacs.org/">spacemacs</a> or <a href="https://github.com/doomemacs/doomemacs">doom emacs</a> to a bespoke configuration wasn&#39;t easy for me because I didn’t know <i>how</i> to learn emacs, so I&#39;m going to stumble through one of my own use cases to demonstrate how this process goes if you&#39;re peeking in from outside the emacs ecosystem, <del>horrified</del> curious about how this all works.
</p>

<p>
Let&#39;s talk about reStructuredText.
</p>


<div id="outline-container-restructuredtext">
<h4 id="restructuredtext">reStructuredText</h4>
<div id="text-restructuredtext">
<p>
At my day job I write <a href="https://docs.bowtie.works/">our user documentation</a> using <a href="https://www.sphinx-doc.org/en/master/">Sphinx</a>.
It expects my stilted prose in <code>.rst</code> format, which is kind of like Markdown if you squint.
</p>

<p>
I do an awful lot of cross-referencing between <i>references</i> (or <code>refs</code>) to link concepts across the documentation.
You define a reference like this:
</p>

<p><span><span>ReST</span></span></p><div><ul><li><span>Font used for directives and roles.</span></li>
<li><span>Font used for all other defining constructs.</span></li></ul></div><div>
<pre><code><span>.. _code_example:</span></code>
<code></code>
<code><span>.. code::</span></code>
<code>   echo &#34;HELP I&#39;M TRAPPED IN A CODE EXAMPLE&#34;</code>
</pre>
</div>

<p>
…and then link to it later like this:
</p>

<p><span><span>ReST</span></span></p><div><ul><li><span>Font used for field names and interpreted text.</span></li>
<li><span>Font used for directives and roles.</span></li></ul></div><div>
<pre><code>This <span>:ref:</span><span>`doesn&#39;t look like anything to me &lt;code_example&gt;`</span>.</code>
</pre>
</div>

<p>
…or like this (if the <code>ref</code> is associated with a title of some sort):
</p>

<p><span><span>ReST</span></span></p><div><ul><li><span>Font used for field names and interpreted text.</span></li>
<li><span>Font used for directives and roles.</span></li></ul></div><div>
<pre><code>Don&#39;t say <span>:ref:</span><span>`code_example`</span>.</code>
</pre>
</div>

<p>
My problem is that I have an <i>assload</i> of references across the all of the documentation and my brain cannot recall them on the spot.
What I really need is the ability to call up the list of references to easily discover and select from that list – this is basically auto-completion but for documentation headers (or titles).
</p>

<p>
I am ready to write some shitty elisp <a href="http://landoflisp.com/">with the help of aliens</a>.
</p>
</div>
<div id="outline-container-a-parentheses-prelude">
<h5 id="a-parentheses-prelude">A Parentheses Prelude</h5>
<p>
Before we dig into emacs&#39; guts, here are some principles that I learned after my first elisp experiments that might help somebody digging into this ecosystem for the first time:
</p>
<div id="outline-container-1-emacs-wants-you-to-extend-it">
<h6 id="1-emacs-wants-you-to-extend-it">1. Emacs <i>Wants</i> You to Extend It</h6>
<div>
<p>
I haven&#39;t written plugins for other editors extensively, but I <i>can</i> tell you this: emacs doesn&#39;t just make deep customization available, but it actively <i>encourages</i> you to make an absolute customization <del>messes</del> masterpieces.
Core editor functions aren&#39;t just documented, but often include tidbits about &#34;you probably want to see this other variable&#34; or &#34;here&#39;s how you should use this&#34;.
</p>

<p>
Not only that, but emacs happily hands you functions shaped like nuclear warheads like <code><span>advice-add</span></code> (that let you override any function) that can absolutely obliterate your editor if you hold it the wrong way.
Of course, this also grants you <b>unlimited power</b>.
</p>

<p>
Remember that emacs is designed to be torn apart and rearranged.
</p>
</div>
</div>
<div id="outline-container-2-geriatric-software">
<h6 id="2-geriatric-software">2. Geriatric Software</h6>
<div>
<p>
The first public release of GNU emacs happened in 1985.
Literally <i>40 years</i> of development sits inside of emacs and its developers are <b>still</b> adding non-trivial features (native language server support landed in version 29 in 2023).
</p>

<p>
The ecosystem is vast and the language has evolved for a long time.
There&#39;s nearly always something useful if you need a particular piece of functionality, so even moreso than with other ecosystems: remember to do your homework first.
</p>
</div>
</div>
<div id="outline-container-3-lisp-for-for-the-un-lisped">
<h6 id="3-lisp-for-for-the-un-lisped">3. Lisp for for the un-Lisped</h6>
<div>
<p>
The syntax is polarizing, I know.
Gurus will wince when I get this wrong, but:
</p>

<ul>
<li>Writing lisp is like writing any other code, just with the parentheses wrapping <i>everything</i> instead of just <i>arguments</i>. <code><span>print</span><span>(</span><span>&#34;Macrodata Refinement&#34;</span><span>)</span></code> becomes <code><span>(</span><span>print</span> <span>&#34;Macrodata Refinement&#34;</span><span>)</span></code></li>
<li>Sometimes you don&#39;t get functions, you get macros that behave special ways.
For example, <code><span>let</span></code> sets variables for an inner block of code.
Like this: <code><span>(</span><span>let</span> <span>(</span>name <span>&#34;Mark S.&#34;</span><span>)</span> <span>(</span><span>print</span> name<span>)</span><span>)</span></code></li>
<li>Lispers say &#34;this is actually data and not calling code&#34; by doing this with single quotes: <code><span>&#39;</span><span>(</span><span>&#34;list&#34;</span> <span>&#34;of&#34;</span> <span>&#34;strings&#34;</span><span>)</span></code></li>
</ul>

<p>
I&#39;m out of my depth in lisp, but if you&#39;re a novice, those notes might help.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-extensible-macros">
<h4 id="extensible-macros">Extensible MACroS</h4>
<div id="text-extensible-macros">
<p>
With that prelude out of the way, let&#39;s begin.
</p>

<p>
Inside of emacs you can call up a list of potential <i>completions</i> by using the keyboard shortcut <kbd>M-.</kbd> (that’s &#34;hit the meta key along with period&#34;, where &#34;meta&#34; is the <kbd>Alt</kbd> key for me).
This applies in a wide variety of scenarios, like when completing class names or variables.
If we want to ask emacs to hand us a list of potential references, then the system we want to hook into is this <i>completions</i> system.
</p>

<p>
(This is the only time I&#39;ll assume we know where to go without crawling through documentation. You could discover it yourself looking for &#34;<code>completion</code>&#34; or similar string in emacs docs).
</p>

<p>
To start our hero’s journey, we figure out what the hell <kbd>M-.</kbd> actually <i>does</i>.
We can ask emacs this by calling the function <code><span>describe-key</span></code>, which is bound to <kbd>C-h k</kbd>.
Hitting <kbd>Ctrl-h</kbd>, then <kbd>k</kbd>, then <kbd>M-.</kbd> drops us into a help buffer that looks like this:
</p>

<pre id="org6bbb9dc"><code>M-. runs the command completion-at-point (found in</code>
<code>evil-insert-state-map), which is an interactive native-compiled Lisp</code>
<code>function in ‘minibuffer.el’.</code>
<code></code>
<code>It is bound to M-..</code>
<code></code>
<code>(completion-at-point)</code>
<code></code>
<code>Perform completion on the text around point.</code>
<code>The completion method is determined by ‘completion-at-point-functions’.</code>
<code></code>
<code>  Probably introduced at or before Emacs version 23.2.</code>
</pre>

<p>
We have the next breadcrumb to follow, which is the variable <code><span>completion-at-point-functions</span></code>.
Running <code><span>completion-at-point</span></code> by hitting <kbd>M-.</kbd> consults that variable to hand us completion candidates, so we <code><span>describe-variable</span></code> it with <kbd>C-h v</kbd> and then choose <code><span>completion-at-point-functions</span></code> from the list of variables:
</p>

<pre id="org56c73d2"><code>completion-at-point-functions is a variable defined in ‘minibuffer.el’.</code>
<code></code>
<code>Its value is (cape-dict cape-file tags-completion-at-point-function)</code>
<code></code>
<code>Special hook to find the completion table for the entity at point.</code>
<code>Each function on this hook is called in turn without any argument and</code>
<code>should return either nil, meaning it is not applicable at point,</code>
<code>or a function of no arguments to perform completion (discouraged),</code>
<code>or a list of the form (START END COLLECTION . PROPS)</code>
</pre>

<p>
…and it goes on from there.
You can see some existing completion functions in there: I use a package called <a href="https://github.com/minad/cape">cape</a> to offer helpful suggestions like file paths if I start typing in something like <code>./filename</code>.
</p>

<p>
The description for this variable instructs us about how to add our own functions (scary!)
You’ll note that emacs calls this a &#34;hook&#34;, which is most often just a term used to describe a variable that is a list of functions that get called at a specific time (hooks show up everywhere).
</p>

<p>
I elided the full description for <code><span>completion-at-point-functions</span></code> – which is lengthy! – but if you parse it all out, you learn the following:
</p>

<ul>
<li>Your completion at point function should return either <code>nil</code> (the elisp &#34;null&#34;) – which means your completion function doesn’t apply right now – or another function (which emacs discourages), or a list, which is what we’ll do because it sounds like the most-correct thing to do.</li>
<li>The list we return is <code><span>(</span>START END COLLECTION . PROPS<span>)</span></code>:
<ul>
<li><code>START</code> and <code>END</code> should be positions in the buffer between which emacs will replace the completed symbol with our candidate.
That is, if your cursor is calling a method on a Python object like <code>file.ope|</code> (where the bar is your cursor), emacs will replace just <code>ope</code> when you select <code>open</code> from a list of completions and not the entire <code>file.ope</code> string.</li>
<li><code>COLLECTION</code> is the juicy bit. The documentation calls it a completion &#34;table&#34;, and there’s probably hidden meaning there, but you can just return a list of candidates and move on with your day, which is what I&#39;ll do.</li>
</ul></li>
</ul>

<p>
Okay, so we need to write something to find the bounds of a string to replace and a function that returns that list.
</p>
</div>
<div id="outline-container-completions-abound">
<h5 id="completions-abound">Completions Abound</h5>
<div id="text-completions-abound">
<p>
I fooled around with some regular expressions for a while until I did the <i>right</i> thing and examined how other completion backends do it.
If you have the package installed, the aforementioned <code><span>cape-file</span></code> function gives us a hint: hit <kbd>M-x</kbd>, then choose <code><span>find-function</span></code>, select <code><span>cape-file</span></code>, and poke around. You’ll find the use of a function called <code><span>bounds-of-thing-at-point</span></code>.
Describing it with <kbd>C-h f</kbd> <code><span>bounds-of-thing-at-point</span></code> gives us:
</p>

<pre id="orgdb3711b"><code>Determine the start and end buffer locations for the THING at point.</code>
<code>THING should be a symbol specifying a type of syntactic entity.</code>
<code>Possibilities include ‘symbol’, ‘list’, ‘sexp’, ‘defun’, ‘number’,</code>
<code>‘filename’, ‘url’, ‘email’, ‘uuid’, ‘word’, ‘sentence’, ‘whitespace’,</code>
<code>‘line’, and ‘page’.</code>
</pre>

<p>
And <i>that</i> is useful for our <code>START</code> and <code>END</code> needs.
You can take it for a test drive at any time with <kbd>M-:</kbd> <code><span>(</span><span>bounds-of-thing-at-point</span> <span>&#39;</span><span>word</span><span>)</span></code> to see where emacs thinks the <i>word</i> at your cursor starts and ends.
This is a common theme when developing elisp: try out functions all the time within the editor since they’re near at hand.
</p>

<p>
The argument to <code><span>bounds-of-thing-at-point</span></code> is a symbol for a literal <i>thing</i> that is predefined by the function <code><span>define-thing-chars</span></code>.
We pass <code><span>define-thing-chars</span></code> a name for our &#34;thing&#34; and a regex, and we can call <code><span>bounds-of-thing-at-point</span></code> with it from that point on.
The function documentation in <code>thingatpt.el</code> that emacs refers you to explains more if you’re interested.
</p>

<p>
<code><span>define-thing-chars</span></code> expects a string with characters to put into a regex character class (like <code>[...]</code>) - just any valid character.
This is a pretty standard character class and we can start with something super simple.
I can’t be bothered to look up whatever the reStructedText spec is for references, but let’s start with &#34;word characters, dashes, and underscores&#34;.
That expressed as a &#34;thing&#34; looks like this:
</p>

<p><span><span>ELisp</span></span></p><div><ul><li><span>Font used to highlight strings.</span></li>
<li><span>Font used to highlight keywords.</span></li></ul></div><div>
<pre><code><span>(</span><span>define-thing-chars</span> rst-ref <span>&#34;[:alpha:]_-&#34;</span><span>)</span></code>
</pre>
</div>

<p>
Now we have a <i>thing</i> called <code>rst-ref</code> we can use with <code><span>bounds-of-thing-at-point</span></code>.
In typical emacs fashion, we can run elisp ad-hoc in our editor just to tinker, so let’s do that now.
</p>

<p>
Remember: we’re trying to write a function to give us the <code>start</code> and <code>end</code> of whatever piece of text we intend for a completion to replace.
Let’s try it out: in any sort of buffer, put a piece of fake <code>.rst</code> text with a reference, like this:
</p>

<p><span><span>ReST</span></span></p><div><ul><li><span>Font used for field names and interpreted text.</span></li>
<li><span>Font used for directives and roles.</span></li></ul></div><div>
<pre><code>This is a <span>:ref:</span><span>`other-reference`</span>.</code>
</pre>
</div>

<p>
Place your point somewhere within &#34;<code>other-reference</code>&#34; and try out your <code>thing</code>:
</p>

<p>
<kbd>M-:</kbd> <code><span>(</span><span>bounds-of-thing-at-point</span> <span>&#39;</span><span>rst-ref</span><span>)</span></code>
</p>

<p>
You’ll see something like <code><span>(</span>number . number<span>)</span></code> in the echo area (the little minibuffer at the bottom of the emacs window frame).
Congratulations!
We’ve got the first part of the problem solved.
</p>
</div>
</div>
</div>
<div id="outline-container-gathering-completions">
<h4 id="gathering-completions">Gathering Completions</h4>
<div id="text-gathering-completions">
<p>
Recall the structure of what our &#34;completion backend&#34; needs to return to emacs:
</p>

<p><span><span>ELisp</span></span></p><div>
<pre><code><span>(</span>START END COLLECTION . PROPS<span>)</span></code>
</pre>
</div>

<p>
We can construct <code>START</code> and <code>END</code> with <code><span>bounds-of-thing-at-point</span></code>, now we just need <code>COLLECTION</code>, which is a list of potential candidates.
</p>

<p>
Conceptually the task isn’t hard: we should find all instances of strings of the form:
</p>

<p><span><span>ReST</span></span></p><div><ul><li><span>Font used for all other defining constructs.</span></li></ul></div>

<p>
in our document and capture <code>my-reference</code>.
Where do we start?
</p>

<p>
Once again you can rely on discovery mechanisms like searching for functions that <i>sound</i> related (by browsing <code><span>describe-function</span></code>) or look at existing code.
Personally, I found this:
</p>

<pre id="orge9859ee"><code>(re-search-forward REGEXP &amp;optional BOUND NOERROR COUNT)</code>
<code></code>
<code>Search forward from point for regular expression REGEXP.</code>
</pre>

<p>
The documentation refers you to some other related functions, like this one:
</p>

<pre id="org335f041"><code>(match-beginning SUBEXP)</code>
<code></code>
<code>Return position of start of text matched by last search.</code>
<code>SUBEXP, a number, specifies which parenthesized expression in the last</code>
<code>regexp.</code>
</pre>

<p>
So we can <code><span>(</span><span>re-search-forward</span><span>)</span></code> for something then invoke <code><span>(</span><span>match-beginning</span> 1<span>)</span></code>, for example, if we used a regex capture group to grab the reference’s label.
Cool: we can start there.
</p>

<p>
As you get deeper into elisp you’ll find that regular expressions are <i>everywhere</i>, and this case is no different.
We need a solid regex to search through a reStructuredText buffer (and honor any quirks in emacs’ regular expression engine), so we’ll use this opportunity to kick the tires on <i>interactively</i> developing regular expressions in emacs.
</p>
</div>
<div id="outline-container-regexes">
<h5 id="regexes">Regexes</h5>
<div id="text-regexes">
<p>
Geriatric millennial software engineers like myself grew up on <a href="https://regexr.com/">https://regexr.com/</a> when it was still a Flash application.
Unless you’re a masochist that lives and breathes regular expressions, it’s kind of hard to develop a good regex without live feedback, which sites like <a href="https://regexr.com/">https://regexr.com/</a> provide.
</p>

<p>
Little did I know that emacs comes with its own live regular expression builder and it&#39;s goooood.
</p>

<p>
Within any emacs buffer, run <kbd>M-x</kbd> <code><span>re-builder</span></code> to open the regex builder window split alongside the current buffer.
If I then enter the string <code><span>&#34;re-</span><span><span>\\</span></span><span><span>(</span></span><span>builder</span><span><span>\\</span></span><span><span>)</span></span><span>&#34;</span></code> into that buffer, that string a) gets highlighted in my original buffer and b) the capture group gets highlighted in its own unique group color.
</p>

<p>
You can do this all day long to fine-tune a regular expression, but there’s yet <i>another</i> trick when writing regular expressions, which is to use the <code><span>rx</span></code> macro.
</p>

<p>
My previous example regular expression <code><span>&#34;re-</span><span><span>\\</span></span><span><span>(</span></span><span>builder</span><span><span>\\</span></span><span><span>)</span></span><span>&#34;</span></code> works, but the quirks when writing emacs regular expressions pile up quickly: escaping characters is one example but there are more, too.
</p>

<p>
Instead, the <code><span>rx</span></code> macro will let you define a regular expression in lisp-y form and evaluate it into a typical string-based regular expression you can use normally, so it works any place emacs expects a string-based regular expression.
For example, if you evaluate this with <kbd>M-:</kbd>:
</p>

<p><span><span>ELisp</span></span></p><div><ul><li><span>Font used to highlight strings.</span></li>
<li><span>Font used to highlight keywords.</span></li></ul></div><div>
<pre><code><span>(</span><span>rx</span> <span>&#34;re-&#34;</span> <span>(</span>group <span>&#34;builder&#34;</span><span>)</span><span>)</span></code>
</pre>
</div>

<p>
This is what emacs returns:
</p>

<p><span><span>ELisp</span></span></p><div><ul><li><span>Font for backslashes in Lisp regexp grouping constructs.</span></li>
<li><span>Font used to highlight strings.</span></li></ul></div>

<p>
Identical!
The <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Rx-Constructs.html"><code>rx</code> documentation</a> explains all the constructs available to you.
</p>

<p>
Jumping back to <code><span>re-builder</span></code>, with the <code><span>re-builder</span></code> window active, invoke <kbd>M-x</kbd> <code>reb-change-syntax</code> and choose <code><span>rx</span></code>.
Now you can interactively build regular expressions with the <code><span>rx</span></code> macro!
In the <code><span>re-builder</span></code> window, you’ve got to enter a weird syntax to get it to take <code><span>rx</span></code> constructs (I’m… not sure why this is), but you end up with the same outcome:
</p>

<p><span><span>ELisp</span></span></p><div><ul><li><span>Font used to highlight strings.</span></li></ul></div><div>
<pre><code><span>&#39;</span><span>(</span><span>:</span> <span>&#34;re-&#34;</span> <span>(</span>group <span>&#34;builder&#34;</span><span>)</span><span>)</span></code>
</pre>
</div>

<p>
Watch the regex get highlighted live just as it was in the string-based regex mode.
</p>

<p>
To bring this full circle, hop into a buffer with an example <code>.rst</code> document like this one:
</p>

<p><span><span>ReST</span></span></p><div><ul><li><span>Font used for all other defining constructs.</span></li>
<li><span>Font used for the adornment of a section header.</span></li>
<li><span>Default font for section title text at level 1.</span></li></ul></div><div>
<pre><code><span>A Heading</span></code>
<code><span>=========</span></code>
<code></code>
<code><span>.. _my-reference:</span></code>
<code></code>
<code>Link to me!</code>
</pre>
</div>

<p>
Using our newfound <code><span>re-builder</span></code> knowledge, let’s build a regex interactively to make short work of it:
</p>

<ul>
<li>Invoke <kbd>M-x</kbd> <code><span>re-builder</span></code></li>
<li>Change the engine to something easier with <kbd>M-x</kbd> <code>reb-change-syntax</code> and choose <code><span>rx</span></code></li>
<li>Start trying out solutions</li>
</ul>

<p>
I’ll refer here to the <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Rx-Constructs.html">rx constructs documentation</a> which lists out all the possibilities that you can plug into the <code><span>rx</span></code> macro.
Here’s a recorded example of what developing it looks like from start to finish, ending up with a functional <code><span>rx</span></code> construct:
</p>



<p>
Live-highlighting regex development.
Nice.
If you add more groups, more colors show up.
In this example the <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Rx-Constructs.html">rx constructs</a> I’m using are:
</p>

<ul>
<li>Any strings end up as literal matches</li>
<li>Special symbols <code>bol</code> and <code>eol</code> for &#34;beginning of line&#34; and &#34;end of line&#34;, respectively</li>
<li>Symbols like <code>+</code> behave like their regex counterparts (&#34;at least one&#34;)</li>
<li>Some symbols like <code>not</code> are nice little shortcuts (in this case, to negate the next form)</li>
</ul>

<p>
Because <code><span>rx</span></code> is a macro, we don’t ever actually <i>need</i> to compile its regular expressions to use elsewhere - we can always just use <code><span>rx</span></code> when we need a regex.
</p>
</div>
</div>
</div>
<div id="outline-container-gathering-completions-continued">
<h4 id="gathering-completions-continued">Gathering Completions: Continued</h4>
<div id="text-gathering-completions-continued">
<p>
Okay, we&#39;ve cut our teeth on emacs regular expressions.
Let&#39;s use &#39;em.
(Not our teeth. Regexes.)
</p>

<p>
To start, let&#39;s save our reStructuredText regular expression to find a <code>ref</code> so we can easily grab it later.
I&#39;ll save the one I came up with to the name <code>tmp/re</code> (this name is arbitrary, I drop temporary variables into <code>tmp/&lt;name&gt;</code> out of habit)
</p>

<p><span><span>ELisp</span></span></p><div><ul><li><span>Font used to highlight built-in function names.</span></li>
<li><span>Font used to highlight strings.</span></li>
<li><span>Font used to highlight keywords.</span></li></ul></div><div>
<pre><code><span>(</span><span>setq</span> tmp/re <span>(</span><span>rx</span> bol <span>&#34;..&#34;</span> <span>(</span><span>+</span> blank<span>)</span> <span>&#34;_&#34;</span> <span>(</span>group <span>(</span><span>+</span> <span>(</span><span>not</span> <span>&#34;:&#34;</span><span>)</span><span>)</span><span>)</span> <span>&#34;:&#34;</span> eol<span>)</span><span>)</span></code>
</pre>
</div>

<p>
Now we can reference it easily.
I mentioned before that <code><span>re-search-forward</span></code> accepts a regex, so let&#39;s hop into a reStructuredText rev up the regex.
</p>

<p>
Here&#39;s my sample text that I&#39;ll work with:
</p>

<p><span><span>ReST</span></span></p><div><ul><li><span>Font used for directives and roles.</span></li>
<li><span>Font used for all other defining constructs.</span></li>
<li><span>Font used for the adornment of a section header.</span></li>
<li><span>Default font for section title text at level 1.</span></li></ul></div><div>
<pre><code><span>A Title</span></code>
<code><span>=======</span></code>
<code></code>
<code>Beware the Jabberwock, my son.</code>
<code></code>
<code><span>.. _my-reference:</span></code>
<code></code>
<code>You are like a little baby. Watch this.</code>
<code></code>
<code><span>.. _code-sample:</span></code>
<code></code>
<code><span>.. code::</span> python</code>
<code></code>
<code>   print(&#34;emacs needs telemetry&#34;)</code>
<code></code>
<code>The end?</code>
</pre>
</div>

<p>
The <code><span>re-search-forward</span></code> documentation indicates that it starts at the <code>point</code>&#39;s current position, so head to the start of the buffer, hit <kbd>M-:</kbd> to enter the elisp <code>Eval</code> prompt, and try:
</p>

<p><span><span>ELisp</span></span></p><div><ul><li><span>Font used to highlight built-in function names.</span></li></ul></div><div>
<pre><code><span>(</span><span>re-search-forward</span> tmp/re<span>)</span></code>
</pre>
</div>

<p>
This is anticlimactic because you&#39;ll just see the point move to the end of one of the references.
BUT.
This means that the search succeeded.
So… what now?
</p>

<p>
More reading in the <code><span>re-search-forward</span></code> documentation will educate you about emacs <i>global match data</i>.
In non-functional-programming style, functions like <code><span>match-beginning</span></code> and <code><span>match-end</span></code> serve to interrogate a global state that functions like <code><span>re-search-forward</span></code> will modify.
In concise terms, our regular expression defines one match group and we can grab it with <code><span>(</span><span>match-string-no-properties</span> 1<span>)</span></code> to get the first group match (<code><span>match-string</span></code> will return a string with &#34;properties&#34;, which is a bunch of data like font styling that we don&#39;t want).
</p>

<p>
Within our example buffer, executing this after the regex search should return our match:
</p>

<p><span><span>ELisp</span></span></p><div><ul><li><span>Font used to highlight function names.</span></li></ul></div><div>
<pre><code><span>(</span><span>match-string-no-properties</span> 1<span>)</span></code>
</pre>
</div>

<p>
I see <code>&#34;my-reference&#34;</code> from this command.
Now we&#39;re cooking like it&#39;s 1985, baby.
You can enter the minibuffer again with <kbd>M-:</kbd>, press <kbd>↑</kbd> to find the <code><span>re-search-forward</span></code> command again, and repeat this process again to watch the point move to the next match, after which you can see the matched string with <code><span>match-string-no-properties</span></code>.
</p>

<p>
Note that running this a few times will eventually error out after no matches exist past your point.
We&#39;ll address this.
</p>

<p>
If you&#39;re a human (or Claude) at this point, you can see the path ahead – we need to write some elisp that will:
</p>

<ul>
<li>Move the point to the beginning of the buffer (important, remember that <code><span>re-search-forward</span></code> relies upon the current position of your point)</li>
<li>Iteratively execute an <code><span>re-search-forward</span></code> command to aggregate reference targets</li>
<li>Conclude when there aren&#39;t any more matches</li>
</ul>

<p>
I&#39;ll start with the code and then explain which demons the parentheses are summoning afterward:
</p>

<p><span><span>ELisp</span></span></p><div><ul><li><span>Font used to highlight function names.</span></li>
<li><span>Font used to highlight strings.</span></li>
<li><span>Font used to highlight special form names.</span></li>
<li><span>Font used to highlight built-in function names.</span></li>
<li><span>Font used to highlight keywords.</span></li>
<li></li>
<li></li></ul></div><div>
<pre><code></code>
<code></code>
<code></code>
<code></code>
<code></code>
<code><span>(</span><span>save-excursion</span></code>
<code>  </code>
<code>  </code>
<code>  <span>(</span><span>progn</span></code>
<code>    </code>
<code>    <span>(</span><span>goto-char</span> <span>(</span><span>point-min</span><span>)</span><span>)</span></code>
<code>    </code>
<code>    </code>
<code>    </code>
<code>    </code>
<code>    </code>
<code>    </code>
<code>    </code>
<code>    </code>
<code>    </code>
<code>    </code>
<code>    </code>
<code>    </code>
<code>    </code>
<code>    <span>(</span><span>cl-loop</span> <span>while</span> <span>(</span><span>re-search-forward</span></code>
<code>                    <span>(</span><span>rx</span> bol <span>&#34;..&#34;</span> <span>(</span><span>+</span> blank<span>)</span> <span>&#34;_&#34;</span> <span>(</span>group <span>(</span><span>+</span> <span>(</span><span>not</span> <span>&#34;:&#34;</span><span>)</span><span>)</span><span>)</span> <span>&#34;:&#34;</span> eol<span>)</span></code>
<code>                    </code>
<code>                    </code>
<code>                    </code>
<code>                    </code>
<code>                    </code>
<code>                    nil <span>t</span><span>)</span></code>
<code>             </code>
<code>             </code>
<code>             </code>
<code>             collect <span>(</span><span>match-string-no-properties</span> 1<span>)</span><span>)</span><span>)</span><span>)</span></code>
</pre>
</div>

<p>
The code is less intimidating without comments:
</p>

<p><span><span>ELisp</span></span></p><div><ul><li><span>Font used to highlight function names.</span></li>
<li><span>Font used to highlight strings.</span></li>
<li><span>Font used to highlight special form names.</span></li>
<li><span>Font used to highlight built-in function names.</span></li>
<li><span>Font used to highlight keywords.</span></li></ul></div><div>
<pre><code><span>(</span><span>save-excursion</span></code>
<code>  <span>(</span><span>progn</span></code>
<code>    <span>(</span><span>goto-char</span> <span>(</span><span>point-min</span><span>)</span><span>)</span></code>
<code>    <span>(</span><span>cl-loop</span> <span>while</span> <span>(</span><span>re-search-forward</span></code>
<code>                    <span>(</span><span>rx</span> bol <span>&#34;..&#34;</span> <span>(</span><span>+</span> blank<span>)</span> <span>&#34;_&#34;</span> <span>(</span>group <span>(</span><span>+</span> <span>(</span><span>not</span> <span>&#34;:&#34;</span><span>)</span><span>)</span><span>)</span> <span>&#34;:&#34;</span> eol<span>)</span></code>
<code>                    nil <span>t</span><span>)</span></code>
<code>             collect <span>(</span><span>match-string-no-properties</span> 1<span>)</span><span>)</span><span>)</span><span>)</span></code>
</pre>
</div>

<p>
Without belaboring the point, you can – like I did – discover most of these functions by skimming existing elisp code and using it as a launch pad.
Many of these functions are bog standard and show up all over the place in emacs packages (<code><span>save-excursion</span></code>, <code><span>progn</span></code>, <code><span>goto-char</span></code>…)
</p>

<p>
Here&#39;s the result when I run this code against our example <code>.rst</code> file:
</p>

<p><span><span>ELisp</span></span></p><div><ul><li><span>Font used to highlight strings.</span></li></ul></div><div>
<pre><code><span>(</span><span>&#34;my-reference&#34;</span> <span>&#34;code-sample&#34;</span><span>)</span></code>
</pre>
</div>

<p>
Looks good!
</p>
</div>
</div>
<div id="outline-container-completing-the-completion-backend">
<h4 id="completing-the-completion-backend">Completing the Completion Backend</h4>
<div id="text-completing-the-completion-backend">
<p>
We&#39;re now armed with the ability to:
</p>

<ul>
<li>Identify the bounds of the string we want to replace, and</li>
<li>Collect a list of targets for completion candidates</li>
</ul>

<p>
We are <i>so close</i>.
Recall the description of the variable we need to modify:
</p>

<pre id="orgb0e2210"><code>completion-at-point-functions is a variable defined in ‘minibuffer.el’.</code>
<code></code>
<code>Its value is (cape-dict cape-file tags-completion-at-point-function)</code>
<code></code>
<code>Special hook to find the completion table for the entity at point.</code>
<code>Each function on this hook is called in turn without any argument and</code>
<code>should return either nil, meaning it is not applicable at point,</code>
<code>or a function of no arguments to perform completion (discouraged),</code>
<code>or a list of the form (START END COLLECTION . PROPS)</code>
</pre>

<p>
To return the list that <code><span>completion-at-point-functions</span></code> expects, we already have the ability to identify the bounds of a <code>thing</code> and sweep up a list of candidates in our buffer.
Note the comment about returning <code>nil</code>: we probably don&#39;t <i>always</i> want to run our backend, so we should short-circuit our function to eagerly return nil to avoid tying up emacs with a regex loop we don&#39;t need.
</p>

<p>
With all that said, <a href="https://en.wikipedia.org/wiki/Bill_Nye">consider the following</a>:
</p>

<p><span><span>ELisp</span></span></p><div><ul><li><span>Font used to highlight special form names.</span></li>
<li><span>Font to highlight quoted Lisp symbols.</span></li>
<li><span>Font used to highlight built-in function names.</span></li>
<li><span>Font used to highlight function names.</span></li>
<li><span>Font used to highlight documentation embedded in program code.
It is typically used for special documentation comments or strings.</span></li>
<li><span>Font used to highlight function names.</span></li>
<li><span>Font used to highlight strings.</span></li>
<li><span>Font used to highlight keywords.</span></li>
<li></li>
<li></li></ul></div><div>
<pre><code></code>
<code><span>(</span><span>define-thing-chars</span> rst-ref <span>&#34;[:alpha:]_-&#34;</span><span>)</span></code>
<code></code>
<code><span>(</span><span>defun</span> <span>my/rst-internal-reference-capf</span> <span>()</span></code>
<code>  <span>&#34;Completion backend for buffer reStructuredText references&#34;</span></code>
<code>  </code>
<code>  </code>
<code>  <span>(</span><span>when</span> <span>(</span><span>looking-back</span> <span>(</span><span>rx</span> <span>&#34;:ref:`&#34;</span> <span>(</span><span>*</span> <span>(</span><span>not</span> <span>&#34;`&#34;</span><span>)</span><span>)</span><span>)</span> <span>(</span><span>point-at-bol</span><span>)</span><span>)</span></code>
<code>    </code>
<code>    <span>(</span><span>let*</span> <span>(</span><span>(</span>bounds <span>(</span><span>or</span> <span>(</span><span>bounds-of-thing-at-point</span> <span>&#39;</span><span>rst-ref</span><span>)</span></code>
<code>                       </code>
<code>                       <span>(</span><span>cons</span> <span>(</span><span>point</span><span>)</span> <span>(</span><span>point</span><span>)</span><span>)</span><span>)</span><span>)</span></code>
<code>           <span>(</span>start <span>(</span><span>car</span> bounds<span>)</span><span>)</span></code>
<code>           <span>(</span>end <span>(</span><span>cdr</span> bounds<span>)</span><span>)</span></code>
<code>           </code>
<code>           <span>(</span>candidates</code>
<code>            </code>
<code>            <span>(</span><span>save-excursion</span></code>
<code>              <span>(</span><span>progn</span></code>
<code>                <span>(</span><span>goto-char</span> <span>(</span><span>point-min</span><span>)</span><span>)</span></code>
<code>                <span>(</span><span>cl-loop</span> <span>while</span> <span>(</span><span>re-search-forward</span></code>
<code>                                <span>(</span><span>rx</span> bol <span>&#34;..&#34;</span> <span>(</span><span>+</span> blank<span>)</span> <span>&#34;_&#34;</span> <span>(</span>group <span>(</span><span>+</span> <span>(</span><span>not</span> <span>&#34;:&#34;</span><span>)</span><span>)</span><span>)</span> <span>&#34;:&#34;</span> eol<span>)</span></code>
<code>                                nil <span>t</span><span>)</span></code>
<code>                         collect <span>(</span><span>match-string-no-properties</span> 1<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span></code>
<code>      </code>
<code>      <span>(</span><span>list</span> start end candidates<span>)</span><span>)</span><span>)</span><span>)</span></code>
</pre>
</div>

<ul>
<li>We&#39;re following some naming conventions by calling this a &#34;<code>capf</code>&#34; (a &#34;completion-at-point function) and prefixing with <code>my/</code> (a habit to namespace your own functions)</li>
<li>Our short-circuit takes the form of using <code><span>looking-back</span></code> to ask, &#34;are we inside of a reStructuredText reference&#34;?
Note the use of <code><span>rx</span></code> here again to clean up our lisp.</li>
<li>We use our <code>rst-ref</code> <code>thing</code> to easily snag the <code>start</code> and <code>end</code> of the string to replace – note our fallback to <i>just</i> the immediate point if we can&#39;t find the bounds of our <code>thing</code>.</li>
</ul>

<p>
We wrap it all up with <code>list</code>.
Personally, even as somebody relatively new to writing Lisps, I find the code pleasant to read and self-evident.
We did a lot in 17 lines of code!
</p>

<p>
Inside of our test <code>.rst</code> buffer, we can test drive this function.
First, invoke <kbd>M-x</kbd> <code><span>eval-defun</span></code> with your cursor somewhere in the function to evaluate it, which makes <code>my/rst-internal-reference-capf</code> available.
Then run:
</p>

<p><span><span>ELisp</span></span></p><div><ul><li><span>Font to highlight quoted Lisp symbols.</span></li>
<li><span>Font used to highlight variable names.</span></li>
<li><span>Font used to highlight function names.</span></li></ul></div><div>
<pre><code><span>(</span><span>add-hook</span> <span>&#39;</span><span>completion-at-point-functions</span> <span>&#39;</span><span>my/rst-internal-reference-capf</span><span>)</span></code>
</pre>
</div>

<p>
Huzzah!
Our function is now live in emacs&#39; completion framework.
You can trigger the completion by calling <code>completion-at-point</code> at a relevant spot in a buffer.
Many batteries-included emacs distributions like spacemacs or doom emacs slap nice-looking porcelain on top of the completion framework; here&#39;s an example that uses the <a href="https://github.com/minad/corfu">corfu</a> package:
</p>



<p>
Congratulations, you&#39;ve extended emacs for the first time!
</p>
</div>
</div>
<div id="outline-container-dressing-up-the-bones">
<h4 id="dressing-up-the-bones">Dressing Up the Bones</h4>
<p>
Okay, this is a pretty basic setup.
You could improve it in <i>many</i> ways, but here are a few ideas about potential directions:
</p>
<div id="outline-container-mode-hooks">
<h5 id="mode-hooks">Mode Hooks</h5>
<div id="text-mode-hooks">
<p>
Manually adding your custom completion function to the <code><span>completion-at-point-functions</span></code> hook is tedious, but there&#39;s a way to automate it.
Recall that in emacs parlance, a &#34;hook&#34; is usually a <i>variable</i> that holds a <i>list of functions</i> that get called at a <i>specific time</i>.
</p>

<p>
If you use <a href="https://docutils.sourceforge.io/docs/user/emacs.html">rst-mode</a>, then opening an <code>.rst</code> file will drop you into <code><span>rst-mode</span></code> and implicitly call the <code><span>rst-mode-hook</span></code> functions.
That means that this line is sufficient to integrate our completion function:
</p>

<p><span><span>ELisp</span></span></p><div><ul><li><span>Font to highlight quoted Lisp symbols.</span></li>
<li><span>Font to highlight Lisp quotes.</span></li>
<li><span>Font used to highlight keywords.</span></li>
<li><span>Font used to highlight variable names.</span></li>
<li><span>Font used to highlight function names.</span></li></ul></div><div>
<pre><code><span>(</span><span>add-hook</span> <span>&#39;</span><span>rst-mode-hook</span> <span>(</span><span>lambda</span> <span>()</span> </code>
<code>    <span>(</span><span>add-hook</span> <span>&#39;</span><span>completion-at-point-functions</span>  <span>#&#39;</span><span>my/rst-internal-reference-capf</span> 0 <span>t</span><span>)</span><span>)</span><span>)</span></code>
</pre>
</div>

<p>
This says: &#34;when I open an <code>.rst</code> file, run this lambda that modifies <code><span>completion-at-point-functions</span></code> <i>only</i> for this buffer by adding my internal reference completion function&#34;.
It&#39;s a little nested which makes it less obvious with the two <code>add-hook</code> calls.
</p>
</div>
</div>
<div id="outline-container-other-files">
<h5 id="other-files">Other Files</h5>
<div id="text-other-files">
<p>
Okay, our example works for references in the <i>same buffer</i> but this is sort of pointless for uses <i>across</i> files.
</p>

<p>
You can solve this too, although my post is already too long so we won&#39;t solve this step-by-step.
However, here&#39;s how <i>I</i> solved it:
</p>

<ul>
<li>Turn my <code>capf</code> into a minor mode that manages the completion variables</li>
<li>Doesn&#39;t search the buffer every time but instead does so once and then rebuilds it with a hook in <code><span>after-change-functions</span></code>, saving it to a hash cache</li>
<li>Walk all <code>.rst</code> files in the current project and run the reference collection function for each, storing the results into a hash cache for all files that don&#39;t have live buffers</li>
<li>When it comes time to call the completion function, combine the hash for completions for files without buffers along with each <code>.rst</code> buffer&#39;s cached list of references</li>
</ul>

<p>
It sounds complicated, but it works!
Functions like <code><span>with-temp-buffer</span></code> make this pretty easy by aggregating reference targets for files using the exact same function we do for live buffers.
</p>

<p><span><span>ELisp</span></span></p><div><ul><li><span>Font used to highlight built-in function names.</span></li>
<li><span>Font used to highlight keywords.</span></li></ul></div><div>
<pre><code><span>(</span><span>with-temp-buffer</span></code>
<code>  <span>(</span><span>insert-file-contents</span> file<span>)</span></code>
<code>  <span>(</span>my/rst-internal-references<span>)</span><span>)</span></code>
</pre>
</div>
</div>
</div>
<div id="outline-container-fancy-completion">
<h5 id="fancy-completion">Fancy Completion</h5>
<div id="text-fancy-completion">
<p>
Emacs&#39; long history includes <a href="https://company-mode.github.io/">company-mode</a>, which is a third-party completion framework that integrates with the <code><span>completion-at-point</span></code> set of functions.
Some <code><span>company-mode</span></code> features include additional metadata about completion candidates, and I found two that were useful: <code>company-kind</code> and <code>company-doc-buffer</code>.
</p>

<ul>
<li><code>company-kind</code> is a simple key that just tells the completion caller what the completion cadidate <i>is</i>.
In our case we can add some eye candy by indicating it&#39;s <code><span>&#39;</span><span>text</span></code>.</li>
<li><code>company-doc-buffer</code> lets us add additional context to a completion candidate.
I leveraged this to include a couple of lines following the reference line to help me figure out what exactly the link refers to.
It&#39;s easier to show what this looks like rather than tell:</li>
</ul>



<p>
Notes:
</p>

<ul>
<li>I&#39;m using GUI emacs here for the nicer completion popup with <a href="https://github.com/minad/corfu">corfu</a> which displays a transparent, floating frame</li>
<li>My completion candidate &#34;context&#34; is a real excerpt from the text around the reference, complete with styling, etc.</li>
<li>The small icon to the left of each candidate comes from the <code>company-kind</code> attribute.</li>
<li>The <code>~</code> syntax is part of <a href="https://github.com/oantolin/orderless">orderless</a></li>
</ul>

<p>
Completion candidate context is an extra frill but very helpful.
</p>
</div>
</div>
</div>
<div id="outline-container-summary">
<h4 id="summary">Summary</h4>
<p>
My experience extending a core emacs function was an instructive and interesting exercise.
I don&#39;t know what the future of emacs looks like in an increasingly LLM-crazed world, but I hope that future includes an open and powerful way to extend and customize the tools we use to write software.
</p>
</div>


<hr/>



<hr/>







        </section>
    </div></div>
  </body>
</html>
