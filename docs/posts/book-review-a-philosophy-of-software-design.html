<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://theleo.zone/books/a-philosophy-of-software-design/">Original</a>
    <h1>Book Review: A Philosophy of Software Design</h1>
    
    <div id="readability-page-1" class="page"><div><p>Rating:üíØ</p><p><a href="https://web.stanford.edu/~ouster/cgi-bin/book.php">A Philosophy of Software Design</a> is a book by <a href="https://web.stanford.edu/~ouster/cgi-bin/home.php">John Ousterhout</a>. I found it extremely worthwhile to read.
It distilled certain vague intuitions that I‚Äôd built up over time into clear ideas. Reading it immediately impacted my
programming style across different dimensions.</p><p>Ousterhout admits:</p><blockquote><p>Unfortunately, there isn‚Äôt a simple recipe that will guarantee great software designs. Instead, I will present a
collection of higher-level concepts that border on the philosophical‚Ä¶</p></blockquote><p>Here are the main philosophical ideas ‚Äì the ‚Äúsummary of design principles‚Äù ‚Äì enumerated at the end of the book:</p><ol><li>Complexity is incremental: you have to sweat the small stuff</li><li>Working code isn‚Äôt enough</li><li>Make continual small investments to improve system design</li><li>Modules should be deep</li><li>Interfaces should be designed to make the most common usage as simple as possible</li><li>It‚Äôs more important for a module to have a simple interface than a simple implementation</li><li>General-purpose modules are deeper</li><li>Separate general-purpose and special-purpose code</li><li>Different layers should have different abstractions</li><li>Pull complexity downward</li><li>Define errors</li><li>Design it twice</li><li>Comments should describe things that are not obvious from the code</li><li>Software should be designed for ease of reading, not ease of writing</li><li>The increments of software development should be abstractions, not features</li></ol><p>What follows is some paraphrased and summarized notes I took throughout the book. They resonate with me unless specified
otherwise.</p><p>Ousterhout defines software complexity as ‚Äúanything related to the structure of a software system that makes it hard to
understand and modify the system‚Äù. I think this rings true. He also emphasizes that system complexity is the sum of the
complexity of each system part weighted by the fraction of time developers spend engaged with that part.</p><p>Complexity is caused by dependencies and obscurity, and its symptoms manifest as simple changes requiring many code
modifications in different places, high cognitive load, and non-obviousness of what needs modifying to complete a task.</p><p>Dependencies exist when code can‚Äôt be understood and modified in isolation ‚Äì you need to read higher-level caller or
lower-level implementation code to understand the current code‚Äôs workings or implications.</p><p>Modules should be deep, with the simplest and clearest possible interface and the bulk of the complexity of
implementation hidden away from the user of the interface. Configuration, if necessary, should have reasonable defaults,
and potential for errors eliminated when possible.</p><p>A garbage collector is a deep module with ‚Äúno interface‚Äù - it just runs and does what is required mostly invisibly. The
Unix I/O interface is extremely deep, with a few simple methods: <code>open</code>, <code>read</code>, <code>write</code>, <code>seek</code>, <code>close</code>. Hidden away
in the implementation is everything from how files are represented on disk, how permissions work, how concurrent file
access is implemented, caching, and device driver interoperability. It is more important to have a simple interface than
a simple implementation.</p><p>The length of functions doesn‚Äôt really matter, as long as the code in them needs to be executed sequentially and serve
the function‚Äôs goal of doing one thing, completely. Comments and spacing can help differentiate sequential blocks of
code within a single function rather than breaking code out into a short function call with a descriptive name,
particularly if these ‚Äúinternal‚Äù functions need to access and return many variables and so have a complex interface.
This is in direct contrast to ‚ÄúClean Code‚Äù‚Äôs guidance that ‚ÄúThe first rule of functions is that they should be small‚Äù,
which never seemed comprehensive to me.</p><p>‚ÄúDesigning it twice‚Äù has directly influenced how I‚Äôm building my current project. It‚Äôs now small enough to iterate on
but big enough to have some tricky complexity to manage, so I‚Äôve been building and rebuilding it and examining the
tradeoffs of each set of abstractions. I‚Äôve learned a TON doing this, and am going to end up with a much better code
base as a result.</p><p>Comments should describe things that aren‚Äôt already obvious from the code. They can fill in missing details, like units,
inclusivity/exclusivity of boundaries, responsibility for resource management, and invariants. Interface comments that
talk about implementation details probably indicate a shallow interface. Comments can be a valuable design tool,
especially when written before the code.</p><p>Consistency and convention is more important than being brilliant and new. Event-driven programming can make it hard to
follow control flow. Test Driven Development pulls focus towards getting specific features working rather than finding
the best design.</p><p>The increments of development should be abstractions, not features. If you have the right abstraction, the
implementation should be trivial. If the implementation isn‚Äôt trivial, it‚Äôs probably time to rethink some abstractions.</p><p>Like I‚Äôve said, I loved this book, and would like to read it again as I progress as a software designer and engineer.</p></div></div>
  </body>
</html>
