<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jrsinclair.com/articles/2022/whats-so-great-about-functional-programming-anyway/">Original</a>
    <h1>What’s so great about functional programming anyway?</h1>
    
    <div id="readability-page-1" class="page"><div>
            <hr/>

<p><em>This is a sample chapter from my upcoming book: “A skeptic’s guide to functional programming with JavaScript.” Be sure to <a href="https://jrsinclair.com/subscribe">subscribe</a> if you’d like to know when it’s available. It’s due for release soon. And there will be a discount for people who buy early.</em></p>

<figure><img src="https://jrsinclair.com/assets/cover.jpg" alt="Cover artwork for ‘A skeptic’s guide to functional programming with JavaScript.’ The subtitle reads ‘How to level up your code without alienating your team.’ The author is James Sinclair."/></figure>

<hr/>

<p>To hear some people talk about functional programming, you’d think they’d joined some kind of cult. They prattle on about how it’s changed the way they think about code. They’ll extol the benefits of <a href="https://jrsinclair.com/articles/2018/how-to-deal-with-dirty-side-effects-in-your-pure-functional-javascript/">purity</a>, at length. And proclaim that they are now able to “reason about their code”—as if all other code is irrational and incomprehensible. It’s enough to make anyone skeptical.</p>

<p>Still, one has to wonder. There must be a reason these zealots are so excited. In my personal experience, it wasn’t the lazy, incompetent programmers who developed an interest functional programming.<a href="#fn:1" id="fnref:1" title="see footnote"><sup>1</sup></a> Instead, the most intelligent coders I knew tended to take it up; the people most passionate about writing good code. (Though, they did tend towards the boffin end of the spectrum.) And this raises the question: What are they so excited about?</p>

<p>Faced with this question, most educators will start with the basics. They’ll take you to the metaphorical baby pool. And they’ll try to explain to you what functional programming <em>is</em>. They’ll talk about “coding with expressions” and side-effects, and purity, and … they mean well. But telling people what functional programming <em>is</em> doesn’t explain what functional programming is <em>good for.</em></p>

<p>Lets&#39; be honest. Nobody cares what functional programming <em>is</em>, at least, not at first. What we care about is “can we deliver better code, faster?” And our project managers care about those in reverse order. Instead, let’s try something different and skip the baby pool. Rather than talking about the definition of functional programming, we’ll go straight to the good parts. Let’s talk about Algebraic Structures.</p>

<h3 id="algebraicstructures">Algebraic structures</h3>

<p>Algebraic structures allow us to write expressive code, with more confidence. They’re expressive because they convey a wealth of information. They tell us how code can be re-used, optimised, and rearranged. And all these with complete confidence we won’t break anything. In some cases, they even enable automatic code generation.</p>

<p>These are bold claims. But by the end of this chapter, we will have demonstrated both:</p>

<ul>
<li>Reusable code; and</li>
<li>Performance optimisation with guaranteed safety.</li>
</ul>

<p>Furthermore, in later chapters, we’ll show how algebraic structures allow our code to convey more information.</p>

<h4 id="whatarealgebraicstructures">What are algebraic structures?</h4>

<p>If they’re so good, what are algebraic structures? In short, they’re what lots of people consider the scary bits of functional programming. They include concepts like ‘monoids’, ‘semigroups’, ‘functors’, and the dreaded ‘monad.’ They’re also super abstract—in the literal sense. Algebraic structures are abstractions of abstractions. In this way, they’re are a little bit like <em>design patterns</em>, such as those described in the ‘gang of four’ book <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>.<a href="#fn:2" id="fnref:2" title="see footnote"><sup>2</sup></a> But they have some significant differences too.</p>

<p>Once again though, instead of focussing on what they <em>are</em>, let’s start with what they can do.</p>

<h4 id="arealworldproblem">A real world problem</h4>

<p>If we want to see what functional programming (and algebraic structures) are good for, there’s no point solving toy problems. We can do better than adding two numbers together. Instead, let’s look at something JavaScript developers deal with often.</p>

<p>Let’s imagine we’re working on a web application. We have a list of notifications to display to the user. And we have them in an array of <abbr title="Plain ol’ JavaScript Object">POJO</abbr>s. But, we need to transform them into a format that the front-end UI code can handle. Suppose the data looks something like this:</p>

<pre><code>const notificationData = [
  {
    username: &#39;sherlock&#39;,
    message: &#39;Watson. Come at once if convenient.&#39;,
    date: -1461735479,
    displayName: &#39;Sherlock Holmes&#39;,
    id: 221,
    read: false,
    sourceId: &#39;note-to-watson-1895&#39;,
    sourceType: &#39;note&#39;,
  },
  {
    username: &#39;sherlock&#39;,
    message: &#39;If not convenient, come all the same.&#39;,
    date: -1461735359,
    displayName: &#39;Sherlock Holmes&#39;,
    id: 221,
    read: false,
    sourceId: &#39;note-to-watson-1895&#39;,
    sourceType: &#39;note&#39;,
  },
  // … and so on. Imagine we had lots more entries here.
];
</code></pre>

<p>Now, to convert this data so our templating system can handle it, we need to do the following:</p>

<ol>
<li>Generate a readable date;</li>
<li>Sanitise the message to prevent <abbr>XSS</abbr> attacks;</li>
<li>Build a link to the sender’s profile page;</li>
<li>Build a link to the source of the notification; and</li>
<li>Tell the template what icon to display, based on the source type.</li>
</ol>

<p>To get started, we write a function for each:<a href="#fn:3" id="fnref:3" title="see footnote"><sup>3</sup></a></p>

<pre><code>const getSet = (getKey, setKey, transform) =&gt; (obj) =&gt;
({
  ...obj,
  [setKey]: transform(obj[getKey]),
});
const addReadableDate = getSet(
  &#39;date&#39;,
  &#39;readableDate&#39;,
  t =&gt; new Date(t * 1000).toGMTString()
);
const sanitizeMessage = getSet(
  &#39;message&#39;,
  &#39;message&#39;,
  msg =&gt; msg.replace(/&lt;/g, &#39;&amp;lt;&#39;)
);
const buildLinkToSender = getSet(
  &#39;username&#39;,
  &#39;sender&#39;,
  u =&gt; `https://example.com/users/${u}`
);

const buildLinkToSource = (notification) =&gt; ({
  ...notification,
  source: `https://example.com/${
    notification.sourceType
  }/${notification.sourceId}`
});
const iconPrefix = &#39;https://example.com/assets/icons/&#39;;
const iconSuffix = &#39;-small.svg&#39;;
const addIcon = getSet(
  &#39;sourceType&#39;,
  &#39;icon&#39;,
  sourceType =&gt; `${urlPrefix}${sourceType}${iconSuffix}`
);
</code></pre>

<p>One way to wire all these together is to run them one-by-one, and store the results in named variables. For example:</p>

<pre><code>const withDates = notificationData.map(addReadableDate);
const sanitized = withDates.map(sanitizeMessage);
const withSenders = sanitized.map(buildLinkToSender);
const withSources = withSenders.map(buildLinkToSource);
const dataForTemplate = withSources.map(addIcon);
</code></pre>

<p>Those interstitial variables don’t add any new information, though. We can see what’s going on from the name of the function we’re mapping. Another way to wire it up would be to use some boring old JavaScript array method chaining. And as we do that, the code starts to look a little bit ‘functional:’</p>

<pre><code>const dataForTemplate = notificationData
  .map(addReadableDate)
  .map(sanitizeMessage)
  .map(buildLinkToSender)
  .map(buildLinkToSource)
  .map(addIcon);
</code></pre>

<p>Now, while this is truly ‘functional’ code, it’s not overly special. Weren’t we supposed to be talking about the wondrous benefits of algebraic structures?</p>

<p>Bear with me. We’re going to rewrite this code using a couple of helper functions. The first is not complicated. We’ll write a <code>map()</code> function that, well, calls <code>.map()</code>.<a href="#fn:4" id="fnref:4" title="see footnote"><sup>4</sup></a></p>

<pre><code>const map = f =&gt; functor =&gt; functor.map(f);
</code></pre>

<p>Next, we write a <code>pipe()</code> function that lets us ‘pipe’ a value through a series of functions. It’s a variation on function composition.<a href="#fn:5" id="fnref:5" title="see footnote"><sup>5</sup></a></p>

<pre><code>const pipe = (x0, ...funcs) =&gt; funcs.reduce(
  (x, f) =&gt; f(x),
  x0
);
</code></pre>

<p>The pipe function uses the spread operator to turn all but the first argument into an array. Then it passes that first argument to the first function. And the result of that to the next function. And so on.</p>

<p>Now we can rewrite our transform code like so:</p>

<pre><code>const dataForTemplate = pipe(
  notificationData,
  map(addReadableDate),
  map(sanitizeMessage),
  map(buildLinkToSender),
  map(buildLinkToSource),
  map(addIcon)
);
</code></pre>

<p>The first thing to notice here, is that it looks a lot like the previous version using chained methods. But aside from that, it’s still rather banal code. We can map over an array, so what? And worse still, it’s inefficient.<a href="#fn:6" id="fnref:6" title="see footnote"><sup>6</sup></a></p>

<p>Hang in there. It’s about to get more interesting.</p>

<h3 id="maybe">Maybe</h3>

<p>For the sake of argument, let’s change the scenario a little. Instead of a list of notifications, suppose we’ve received the most recent one. But, we don’t have complete confidence in our server. On occasion, something goes wrong, and it sends us an <abbr title="HyperText markup language">HTML</abbr> page instead of <abbr title="JavaScript Object Notation">JSON</abbr> data. And we end up with <code>undefined</code> rather than a notification.</p>

<p>Now, one way to handle this would be to litter our code with if-statements. First, we catch the error, and return <code>undefined</code> if the response doesn’t parse.</p>

<pre><code>const parseJSON = (dataFromServer) =&gt; {
  try {
    const parsed = JSON.parse(dataFromServer);
    return parsed;
  } catch (_) {
    return undefined;
  }
};
</code></pre>

<p>Then we add if-statements to each of our utility functions.</p>

<pre><code>const addReadableDate = (notification) =&gt; {
  if (notification !== undefined) {
    return getSet(
      &#39;date&#39;,
      &#39;readableDate&#39;,
      t =&gt; new Date(t * 1000).toGMTString()
    )(notification);
  } else {
    return undefined;
  }
}
const sanitizeMessage = (notification) =&gt; {
  if (notification !== undefined) {
    return getSet(
      &#39;message&#39;,
      &#39;message&#39;,
      msg =&gt; msg.replace(/&lt;/g, &#39;&amp;lt;&#39;)
    )(notification)
  } else {
    return undefined;
  }
};
const buildLinkToSender = (notification) =&gt; {
  if (notification !== undefined) {
    return getSet(
      &#39;username&#39;,
      &#39;sender&#39;,
      u =&gt; `https://example.com/users/${u}`
    );
  } else {
    return undefined;
  }
};
const buildLinkToSource = (notification) =&gt; {
  if (notification !== undefined) {
    return ({
      ...notification,
      source: `https://example.com/${
        notification.sourceType
      }/${notification.sourceId}`
    });
  } else {
    return undefined;
  }
};
const iconPrefix = &#39;https://example.com/assets/icons/&#39;;
const iconSuffix = &#39;-small.svg&#39;;
const addIcon = (notification) =&gt; {
  if (notification !== undefined) {
    getSet(
      &#39;sourceType&#39;,
      &#39;icon&#39;,
      sourceType =&gt;
        `${urlPrefix}${sourceType}${iconSuffix}`
    );
  } else {
    return undefined;
  }
};
</code></pre>

<p>After all that, our main <code>pipe()</code> call still looks the same.</p>

<pre><code>const dataForTemplate = pipe(
  notificationData,
  map(addReadableDate),
  map(sanitizeMessage),
  map(buildLinkToSender),
  map(buildLinkToSource),
  map(addIcon)
);
</code></pre>

<p>But, as you can see, it makes our individual functions verbose and repetitive. Surely there must be an alternative? And indeed, there is. We’ll write a pair of functions like so:</p>

<pre><code>const Just = (val) =&gt; ({
  map: f =&gt; Just(f(val)),
});

const Nothing = () =&gt; {
  const nothing = { map: () =&gt; nothing };
  return nothing;
};
</code></pre>

<p>Both <code>Just</code> and <code>Nothing</code> return an object with a <code>.map()</code> method. When used together, we call this pair a Maybe. And we use it like so:</p>

<pre><code>const parseJSON = (data) =&gt; {
  try {
    return Just(JSON.parse(data));
  } catch () {
    return Nothing();
  }
}
const notificationData = parseJSON(dataFromServer);
</code></pre>

<p>With that in place, let’s look at our mapping code. In this new scenario, we’re no longer working with arrays. Instead, we have a single value that may be <code>Nothing</code>. Or, it may be <code>Just</code> a notification. But, as a reminder, here’s the code we had for arrays again:</p>

<pre><code>const dataForTemplate = pipe(
  notificationData,
  map(addReadableDate),
  map(sanitizeMessage),
  map(buildLinkToSender),
  map(buildLinkToSource),
  map(addIcon)
);
</code></pre>

<p>What do we need to make this work with Maybe a single value? Almost nothing. All we need is a way to get our value out of the <code>Just</code> wrapper at the end. To do that, we’ll add another method to <code>Just</code> and <code>Nothing</code>.</p>

<pre><code>const Just = (val) =&gt; ({
  map: f =&gt; Just(f(val)),
  reduce: (f, x0) =&gt; f(x0, val),
});

const Nothing = () =&gt; {
  const nothing = {
    map: () =&gt; nothing,
    reduce: (_, x0) =&gt; x0,
  };
  return nothing;
};
</code></pre>

<p>Notice how we’ve added <code>reduce()</code> to both <code>Just</code> and <code>Nothing</code>. That allows us write a stand-alone <code>reduce()</code> function, much like we did for <code>map()</code>:</p>

<pre><code>const reduce = (f, x0) =&gt; foldable =&gt;
    foldable.reduce(f, x0);
</code></pre>

<p>If we want to get our value out of a <code>Just</code>, we can call <code>reduce()</code> like so:</p>

<pre><code>reduce((_, val) =&gt; val, fallbackValue);
</code></pre>

<p>If <code>reduce()</code> encounters <code>Nothing</code>, it will return the fallback value. Otherwise, it will ignore fallback value and returns the data.</p>

<p>So the pipeline would look like so:</p>

<pre><code>const dataForTemplate = pipe(
  notificationData,
  map(addReadableDate),
  map(sanitizeMessage),
  map(buildLinkToSender),
  map(buildLinkToSource),
  map(addIcon),
  reduce((_, val) =&gt; val, fallbackValue),
);
</code></pre>

<p>Now, you may be wondering, why all this rigmarole with <code>.reduce()</code>? Why not add a method that provides the fallback value straight away? For example:</p>

<pre><code>const Just = (val) =&gt; ({
  map: f =&gt; Just(f(val)),
  fallbackTo: (_) =&gt; val,
});

const Nothing = () =&gt; {
  const nothing = {
    map: () =&gt; nothing,
    fallBackTo: (x0) =&gt; x0,
  };
  return nothing;
};
</code></pre>

<p>Once again, because we’ve added <code>.fallBackTo()</code> to both, we can write another utility function. This will work regardless of whether we get <code>Just</code> or <code>Nothing</code>. It will do what we expect either way.</p>

<pre><code>const fallBackTo = (x0) =&gt; (m) =&gt; m.fallBackTo(x0);
</code></pre>

<p>This utility function, <code>fallBackTo()</code> is concise and effective. Why bother with <code>reduce()</code>?</p>

<p>It’s a good question. At first glance, it appears to be the kind of needlessly complicated code that makes functional programmers so annoying. Always adding in layers of abstraction that make code harder to read, and confusing for juniors. Right?</p>

<p>There’s a good reason for using <code>reduce()</code> instead of <code>fallBackTo()</code>, though. Because <code>reduce()</code> can work with other data structures besides <code>Just</code> and <code>Nothing</code>. It’s portable code. The truth is, for this code, we can replace <code>Just</code> and <code>Nothing</code> with something else. What would happen if we rewrote the parsing code like this:</p>

<pre><code>const parseJSON = strData =&gt; {
  try { return [JSON.parse(strData)]; }
  catch () { return []; }
};

const notificationData = parseJSON(dataFromServer);
</code></pre>

<p>Instead of using <code>Just</code> and <code>Nothing</code>, we’re now returning plain ol’ JavaScript arrays. If we look at our pipeline again:</p>

<pre><code>const dataForTemplate = pipe(
  notificationData,
  map(addReadableDate),
  map(sanitizeMessage),
  map(buildLinkToSender),
  map(buildLinkToSource),
  map(addIcon),
  reduce((_, val) =&gt; val, fallbackValue),
);
</code></pre>

<p>We don’t change a single line. But it still produces the same result.</p>

<h3 id="result">Result</h3>

<p>Let’s stick with this scenario a moment longer. In our <abbr>JSON</abbr> parsing code, we ignore the error in the <code>catch</code> clause. But, what if that error has useful information inside? We may want to log the error somewhere so we can debug issues.</p>

<p>Let’s go back to our old <code>Just</code>/<code>Nothing</code> code. We’ll switch out <code>Nothing</code> for a slightly different function, <code>Err</code>. And while we’re at it, we’ll also rename <code>Just</code> to <code>OK</code>.</p>

<pre><code>const OK = (val) =&gt; ({
  map:  (f) =&gt; OK(f(fal)),
  reduce: (f, x0) =&gt; f(x0, val),
});

const Err = (e) =&gt; ({
  const err = {
    map: (_) =&gt; err,
    reduce: (_, x0) =&gt; x0,
  };
  return err;
});
</code></pre>

<p>We’ll call this new pair of functions, Result.<a href="#fn:7" id="fnref:7" title="see footnote"><sup>7</sup></a> With that in place, we can change our <code>parseJSON()</code> code so that it uses Result.</p>

<pre><code>const parseJSON = strData =&gt; {
  try { return OK(JSON.parse(strData)); }
  catch (e) { return Err(e); }
}

const notificationData = parseJSON(dataFromServer);
</code></pre>

<p>Now, instead of ignoring the error, we capture it in an <code>Err</code> object. If we go back to the pipeline, we don’t have to change anything. Since <code>Err</code> has compatible <code>.map()</code> and <code>.reduce()</code> methods, it still works.</p>

<pre><code>const dataForTemplate = pipe(
  notificationData,
  map(addReadableDate),
  map(sanitizeMessage),
  map(buildLinkToSender),
  map(buildLinkToSource),
  map(addIcon),
  reduce((_, val) =&gt; val, fallbackValue),
);
</code></pre>

<p>Of course, we’re still ignoring the error when we get to that final <code>reduce()</code>. To fix that, we need to make a firm decision about what we want to do with that error. Do we want to log it to the console, introducing a side-effect? Do we want to send it over the network to a logging platform? Or do we want to extract something from it and display it to the user?</p>

<p>For now, let’s assume we’re OK with a small side effect, and we’ll log it to the console. We add a <code>.peekErr()</code> method to both <code>OK</code> and <code>Err</code> like so:</p>

<pre><code>const OK = (val) =&gt; ({
  map: (f) =&gt; OK(f(fal)),
  reduce: (f, x0) =&gt; f(x0, val),
  peekErr: () =&gt; OK(val),
});

const Err = (e) =&gt; ({
  const err = {
    map: (_) =&gt; err,
    reduce: (_, x0) =&gt; x0,
    peekErr: (f) =&gt; { f(e); return err; }
  }
});
</code></pre>

<p>The version we add to <code>OK</code> does nothing, because there’s no error to peek at. But having it there allows us to write a utility function that works with both <code>OK</code> and <code>Err</code>.</p>

<pre><code>const peekErr = (f) =&gt; (result) =&gt; result.peekErr(f);
</code></pre>

<p>Then we can add <code>peekErr()</code> to our pipeline:</p>

<pre><code>const dataForTemplate = pipe(
  notificationData,
  map(addReadableDate),
  map(sanitizeMessage),
  map(buildLinkToSender),
  map(buildLinkToSource),
  map(addIcon),
  peekErr(console.warn),
  reduce((_, val) =&gt; val, fallbackValue),
);
</code></pre>

<p>If there happens to be an error, we log it and move on. If we needed more complex error handling, we might use other structures.</p>

<p>Of course, adding <code>peekErr()</code> breaks compatibility with Arrays and the Maybe structure. And that’s fine. Arrays and Maybe don’t have this extra error data to deal with.</p>

<h3 id="task">Task</h3>

<p>Now, this is all well and good, but we’ve been ignoring something important. All along we’ve been saying that this data comes from a server. But retrieving data from a server implies that there’s some sort of network call involved. And in JavaScript, that most often means asynchronous code.</p>

<p>For example, suppose we have some code that fetches our notification data using standard JavaScript promises:</p>

<pre><code>const notificationDataPromise = fetch(urlForData)
  .then(response =&gt; response.json());
</code></pre>

<p>Let’s see if we can build a structure that works for asynchronous code too. To do this, we’re going to create a structure with a constructor function much like a Promise. It expects a function that takes two arguments:</p>

<ol>
<li>One to call on successful resolution; and</li>
<li>Another to call if something goes wrong.</li>
</ol>

<p>We can call it like so:</p>

<pre><code>const notificationData = Task((resolve, reject) =&gt; {
  fetch(urlForData)
    .then(response =&gt; response.json())
    .then(resolve)
    .catch(reject);
});
</code></pre>

<p>In this example, we call fetch and pass it the <abbr>URL</abbr> for our notification. Then we call <code>.json()</code> on the response to parse the data. And with that done, we <code>resolve()</code> if the call was successful, or <code>reject()</code> if it wasn’t. It looks a little awkward compared to the Promise-only <code>fetch()</code> code. But that’s so we can wire up the resolve and reject. We’ll add a helper for wiring up asynchronous functions like <code>fetch()</code> in a moment.</p>

<p>The implementation for our <code>Task</code> structure is not too complex:</p>

<pre><code>const Task = (run) =&gt; {
  map: (f) =&gt; Task((resolve, reject) =&gt; {
    run(
      (x) =&gt; (resolve(f(x))),
      reject
    );
  }),
  peekErr: (f) =&gt; Task((resolve, reject) =&gt; {
    run(
      resolve,
      (err) =&gt; { f(err); reject(err); }
    )
  }),
  run: (onResolve, onReject) =&gt; run(
    onResolve,
    onReject
  );
}
</code></pre>

<p>We have <code>.map()</code> and <code>.peekErr()</code>, as we did for Result. But a <code>.reduce()</code> method doesn’t make sense for asynchronous code. Once you go asynchronous, you can never go back. We’ve also added a <code>.run()</code> method to kick off our Task.</p>

<p>To make working with Promises a little easier, we can add a static helper to <code>Task</code>. And another helper for fetching <abbr>JSON</abbr> data:</p>

<pre><code>Task.fromAsync = (asyncFunc) =&gt; (...args) =&gt;
  Task((resolve, reject) =&gt; {
    asyncFunc(...args).then(resolve).catch(reject);
  });

const taskFetchJSON = Task.fromAsync(
  (url) =&gt; fetch(url).then(data =&gt; data.json())
);
</code></pre>

<p>With those helpers, we can define <code>notificationData</code> like so:</p>

<pre><code>const notificatonData = taskFetchJSON(urlForData);
</code></pre>

<p>To work with Task, we need to change our pipeline a little. But it’s a small change:</p>

<pre><code>const dataForTemplate = pipe(
  notificationData,
  map(addReadableDate),
  map(sanitizeMessage),
  map(buildLinkToSender),
  map(buildLinkToSource),
  map(addIcon),
  peekErr(console.warn),
);
</code></pre>

<p>Most of it still works, except for the <code>reduce()</code> function. But we still want some way to introduce a fallback value if the network request or parsing fails. To make that happen, we’ll add a method called <code>.scan()</code>. It will be like <code>.reduce()</code>, but we give it a different name to acknowledge that the result will still be ‘inside’ a <code>Task</code>.</p>

<pre><code>const Task = (run) =&gt; {
  map: (f) =&gt; Task((resolve, reject) =&gt; {
    run(
      (x) =&gt; (resolve(f(x))),
      reject
    );
  }),
  peekErr: (f) =&gt; Task((resolve, reject) =&gt; {
    run(
      resolve,
      (err) =&gt; { f(err); reject(err); }
    )
  }),
  run: (onResolve, onReject) =&gt; run(
      onResolve,
      onReject
    );
  scan: (f, x0) =&gt; Task((resolve, reject) =&gt; run(
    x =&gt; resolve(f(x0, x)),
    e =&gt; resolve(x0),
  )),
}
</code></pre>

<p>And, as usual, we’ll create a matching utility function:</p>

<pre><code>const scan = (f, x0) =&gt; (scannable) =&gt;
  scannable.scan(f, x0);
</code></pre>

<p>With that in place, we can adjust our pipeline like so:</p>

<pre><code>const taskForTemplateData = pipe(
  notificationData,
  map(addReadableDate),
  map(sanitizeMessage),
  map(buildLinkToSender),
  map(buildLinkToSource),
  map(addIcon),
  peekErr(console.warn),
  scan((_, val) =&gt; val, fallback)
);
</code></pre>

<p>And to run it, we do something like this:</p>

<pre><code>taskForTemplateData.run(
  renderNotifications,
  handleError
);
</code></pre>

<h4 id="whynotusepromises">Why not use Promises?</h4>

<p>Someone might be wondering, JavaScript already has a built-in data structure for asynchronous code. Why not use Promises? Why bother with this Task business? What’s the point, if it’s going to confuse everyone?</p>

<p>There’s at least three reasons. The first is that Promises don’t have a <code>.run()</code> method. This means they kick off as soon as you create them. Using <code>Task</code> gives us precise control over when everything starts.</p>

<p>Now, we don’t <em>need</em> Task to get this control. If we want to, we can delay our Promises by putting them inside a function. Then, the Promise won’t ‘kick off’ until we call the function. Along the way though, we’ve as-good-as reinvented Task. But with a different syntax and less flexibility.</p>

<p>The second reason for preferring Task is it has abilities Promises don’t. The main one is being able to nest Tasks. We can run a Task, and get back another Task. We can then wait and decide when to run that next Task. This isn’t possible with Promises.<a href="#fn:8" id="fnref:8" title="see footnote"><sup>8</sup></a> Promises smoosh <code>.map()</code> and <code>.flatMap()</code> together into a single <code>.then()</code> method. And as a consequence, we lose flexibility (again).</p>

<p>The final reason for preferring Task is that it’s consistent with other algebraic structures. If we keep using these structures often enough, they become familiar. And in turn, it becomes easier to make inferences about what the code is doing. Or (more importantly) <em>not</em> doing. We’ll discuss this further in a moment.</p>

<p>In summary, Task gives us more power, flexibility, and consistency. This isn’t to say that there’s no tradeoffs using tasks. With the <code>async … await</code> keywords, JavaScript supports Promises ‘out of the box’. We may not want to give up that convenience to use Tasks. And that’s okay.</p>

<h3 id="soyouusedpolymorphism.bigdeal.">So you used polymorphism. Big deal.</h3>

<p>We started this chapter asking the question “What’s so great about functional programming?” But all we’ve done so far is talk about a handful of objects that share some method names. That’s plain old polymorphism. <abbr title="Object Oriented Programming">OOP</abbr> gurus have been banging on about polymorphism for decades. We can’t claim that functional programming is awesome because it uses polymorphism.</p>

<p>Or can we?</p>

<p>It’s not polymorphism itself that makes algebraic structures (and functional programming) so awesome. But polymorphism makes algebraic structures possible in JavaScript. In our notifications example, we defined some methods with matching names and signatures. For example, <code>.map()</code> and <code>.reduce()</code>. Then we wrote utility functions that work with methods matching those signatures, for example, <code>map()</code> and <code>reduce()</code>. Polymorphism makes those utility functions work.</p>

<p>Those method definitions (and utility functions) aren’t arbitrary. They’re not design patterns that someone made up by observing common architectural patterns. No, algebraic structures come from mathematics; from fields like set theory and category theory. This means that, as well as specific method signatures, these structures come with <em>laws</em>.</p>

<p>At first, this doesn’t sound wonderful. We associate mathematics with confusion and boredom. And we associate laws with restriction. Laws get in our way. They stop us doing what we want. They’re inconvenient. But if you take a moment to read these laws, they may surprise you. Because they’re <em>boring</em>. Incredibly boring.</p>

<p>Now, you may be thinking “I’m not sure why you thought that would be surprising. That’s the least surprising thing ever.” But these laws are a particular kind of boring. They’re boring in the sense that they state the obvious. The kind of thing where you wonder why anyone bothered to write it down. We read them and tend to think “Of course it works like that. In what scenario would it ever be different?” And that, there, is the beauty of algebraic structures.</p>

<p>To illustrate, let’s look back at our notifications example. We’ve made use of at least two algebraic structures. One of them, we call Functor. All that means is that in Maybe, Result, and Task, we wrote a <code>.map()</code> method. And the way we’ve written those <code>.map()</code> methods, each one follows some laws. We also used another algebraic structure called Foldable. We call a data structure Foldable if it has a <code>.reduce()</code> method, and that method obeys some laws.</p>

<p>One of the laws for Functor says that the following two pieces of code must always produce the same result. No matter what. Assuming we have two pure functions, <code>f</code>, and <code>g</code>, our first piece of code is:</p>

<pre><code>const resultA = a.map(f).map(g);
</code></pre>

<p>And the second piece of code is:</p>

<pre><code>const resultB = a.map(x =&gt; g(f(x)));
</code></pre>

<p>These two pieces of code must produce the same result when given the same input. That is, <code>resultA ≣ resultB</code>. We call this the composition rule. And we can apply it to our pipeline code. Because <code>x =&gt; g(f(x))</code> is the same as writing <code>x =&gt; pipe(x, f, g)</code>. That is, our <code>pipe()</code> function is a form of composition. Thus, if we go all the way back to the array-based version of our pipeline, we have:</p>

<pre><code>const dataForTemplate = pipe(
  notificationData,
  map(addReadableDate),
  map(sanitizeMessage),
  map(buildLinkToSender),
  map(buildLinkToSource),
  map(addIcon),
);
</code></pre>

<p>We can rewrite it as:</p>

<pre><code>const dataForTemplate = map(x =&gt; pipe(x,
  addReadableDate,
  sanitizeMessage,
  buildLinkToSender,
  buildLinkToSource,
  addIcon,
))(notificationData);
</code></pre>

<p>Because of the composition law, we know these two pieces of code are equivalent. It doesn’t matter if we’re working with a Maybe, Result, Task, or an Array. These two pieces of code will always produce the same result.</p>

<p>Now, it’s possible, that doesn’t look like a big deal to you. And you may even think the second version is uglier, and overly complex. But for arrays, that second version will be more efficient. The first version will produce at least five intermediate arrays as it passes data through the pipe. The second version does it all in one pass. We get a performance improvement that’s guaranteed to produce the same result as the code we started with. Well, guaranteed, so long as we’re using pure functions.</p>

<h3 id="sowhat">So what?</h3>

<p>It’s all about confidence. Those laws tell me that if I use an algebraic structure, it will behave as I expect. And I have a mathematical guarantee that it will continue to do so. 100%. All the time.</p>

<p>As promised, we’ve demonstrated code that we can re-use. Our utility functions like <code>map()</code>, <code>reduce()</code> and <code>pipe()</code> work with a bunch of different structures. Structures like Array, Maybe, Either, and Task. And we showed how the laws of algebraic structures helped us rearrange the code with complete safety. And showed how that rearrangement provided a performance improvement. Again, with complete confidence.</p>

<p>This, in turn, gets to the heart of what’s great about functional programming. It’s not mainly about algebraic structures. They’re but one set of tools in a gigantic tool chest. Functional programming is all about having confidence in our code. It’s about knowing that our code is doing what we expect, and <em>nothing but</em> what we expect.</p>

<p>Once we understand this, the eccentricities of functional programming start to make a little more sense. This is why, for example, functional programmers are so careful about side-effects. The more we work with pure functions, the more certainty we gain. It also explains the love affair some programmers have with fancy type systems like the one in Haskell.<a href="#fn:9" id="fnref:9" title="see footnote"><sup>9</sup></a> They’re addicted to the drug of certainty.</p>

<p>This knowledge—that functional programming is about confidence in your code—is like having a secret key. It explains why functional programmers get all worked up about ostensibly trivial matters. It’s not that they enjoy pedantry. (Well, okay, <em>some</em> of them appear to enjoy pedantry a lot). Most of the time, they’re fighting to preserve confidence. And they’re willing to do whatever it takes. Even if it involves delving into the dark arts of mathematics.</p>

<hr/>

<p><em>Once again, this is a sample chapter from my upcoming book: “A skeptic’s guide to functional programming with JavaScript.” If you want to know when it’s available, please <a href="https://jrsinclair.com/subscribe">subscribe</a>. It’s due for release soon. And there will be a discount for people who buy early.</em></p>


          </div></div>
  </body>
</html>
