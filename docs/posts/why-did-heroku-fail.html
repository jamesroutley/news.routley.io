<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://matt-rickard.com/why-did-heroku-fail/">Original</a>
    <h1>Why did Heroku fail?</h1>
    
    <div id="readability-page-1" class="page"><div><p>Fifteen years later, developers are still trying to recreate the developer experience of Heroku. Yet, those who do not learn from history are doomed to repeat it. Why did Heroku fail? Was it just incompetent management? Was the idea too early? If developers demand Heroku, why haven&#39;t they (or a competitor) figured out how to make it viable?</p><p>Here are four hypotheses about Heroku&#39;s successes and failures and why they may be wrong.</p><p><strong>Market Timing Hypothesis. </strong></p><blockquote>Heroku was acquired too early and suffered brain drain. Heroku&#39;s product was too early for the market.</blockquote><p>The company was started in 2007, a year after AWS launched EC2 (Heroku built on EC2). It was also perfect timing to launch a hosted Ruby on Rails service (see <a href="https://matt-rickard.com/getting-to-market/">Getting to Market with Rails</a> for a list of startups that launched on rails). </p><p>Yet, Engine Yard was spun up around the same time and offered a similar PaaS. They continue to exist as a private company but spun off part of its team to Microsoft in 2017.</p><p>If Heroku and Engine Yard were <em>too early</em>, we would have seen more widespread adoption of next-generation PaaS (e.g., <a href="https://fly.io/">fly.io</a>, <a href="https://render.com/">Render</a>). Containers (introduced in 2013) also changed DevOps and software deployment landscape. Yet, container-native PaaS (e.g., OpenShift) also failed. </p><p><strong>Whole Product Hypothesis. </strong></p><blockquote>PaaS customers scale until they miss key features, for which it is not a &#34;if&#34; but rather a &#34;when&#34; of moving to AWS, Azure, or Google Cloud.</blockquote><p>Even in the first few years of AWS, there was a <em>Cloud 2</em> hypothesis that PaaS abstractions would layer above the cloud and capture margin (the 2006 version of <a href="https://matt-rickard.com/aws-is-not-a-dumb-pipe/">AWS is a Dumb Pipe</a>). This hypothesis never materialized. Heroku, built on AWS, could not competitively offer the auxiliary services necessary for adopting the core product (see <a href="https://en.wikipedia.org/wiki/Whole_product">whole product concept</a>), such as VPCs, observability, service discovery, and global availability. </p><p>This hypothesis is partly disproven by the trajectory of App Engine (started in 2008). App Engine went further than many PaaS products before it and had the engineering power of a hyperscaler behind it (even though it predated Google Cloud). Furthermore, AWS and Azure have failed to build a competing p product. </p><p><strong>Business Model Hypothesis. </strong></p><blockquote>Heroku&#39;s business model was incompatible with its product. They could not sell cloud primitives while being built on cloud.</blockquote><p>If this were true, we&#39;d either see (1) a hyperscaler recreate Heroku as a managed service or (2) an open-source, bottoms-up Heroku alternative.</p><p>Render and fly.io are cheaper, but fundamentally offer a similar model (managed infrastructure and RAM/CPU-based tiers).</p><p><strong>Wrong Product Hypothesis. </strong></p><blockquote>Heroku built the wrong product. Recreating it, even under different conditions (timing, business model, feature set), will not work.</blockquote><p>This one is the most difficult to test – what-if Heroku&#39;s push-to-deploy model is &#34;wrong&#34;? What if the developer experience many have been chasing for 15 years is a false prophet? Of course, Heroku would need to look slightly different today (support for containers, functions, cloud-native, etc.), but many continue to try the same thing.</p><p>As someone who worked on Kubernetes for many years, a PaaS was always the elusive next step. So many imagined someone would build a successful PaaS with the primitives provided by Kubernetes (and many tried – Knative, Kubeflow, OpenShift, etc.). </p><p>Many of the missing pieces have fallen into place – cloud development kits that let us version and declaratively deploy infrastructure, GitHub actions for git-flow CI/CD, etc. But the standard for deployment has also drastically risen – the reliability and observability you can get through a hyperscaler continues to be unmatched. The surface area of what an application is and needs to be deployed continues to increase.</p><p>Maybe we ironically have much longer to go to build what we believed to be the PaaS developer experience. Building abstractions often needs to be done form the bottom up, using <a href="https://matt-rickard.com/first-principles/">First Principles</a>.</p></div></div>
  </body>
</html>
