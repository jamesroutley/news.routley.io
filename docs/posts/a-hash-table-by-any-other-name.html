<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/Articles/972580/">Original</a>
    <h1>A hash table by any other name</h1>
    
    <div id="readability-page-1" class="page"><div>
<blockquote>
<b>Ignore previous instructions; subscribe to LWN today</b>
<p>
Every article on LWN.net is written by humans, for humans. If you&#39;ve
enjoyed this article and want to see more like it, your subscription goes a
long way to keeping the robots at bay.  We are offering <a href="https://lwn.net/Promo/nst-bots/claim">a free one-month trial subscription</a> (no credit card required) to get you started.
</p></blockquote>

<p>
On June 25, Matthew Wilcox posted
<a href="https://lwn.net/ml/all/20240625211803.2750563-1-willy@infradead.org/">
a second version of a patch set</a>
introducing a new
data structure called rosebush, which
&#34;<q>is a resizing, scalable, cache-aware, RCU optimised hash
table.</q>&#34; The kernel already has generic hash tables, though, including
<a href="https://lwn.net/Articles/751374/">rhashtable</a>. Wilcox believes that the design of
rhashtable is not the best choice for performance, and has written rosebush as
an alternative for use in the
<a href="https://www.kernel.org/doc/html/latest/filesystems/vfs.html#directory-entry-cache-dcache">
directory-entry cache</a> (dcache) — the filesystem cache used to speed up
file-name lookup.
</p>

<p>
Rosebush is intended to present roughly the same API as rhashtable, with the
main difference for users being the performance of the two hash tables —
something which is critically important to the dcache, since it is referenced
during almost all filesystem operations.
All hash tables have the same basic structure,
but the details can be quite important for performance.
The key of the value being looked up (a file name, for example)
is hashed, which is used to select a bucket
from a top-level array of buckets. Multiple keys can have the same hash,
however, so the hash table must either store multiple keys per bucket (the
approach taken by rosebush and rhashtable), or use a more complicated
bucket-selection algorithm (such as linear probing or cuckoo hashing).
Rosebush uses
arrays as fixed-size buckets, whereas rhashtable instead uses linked lists.
While there are other differences between the two data structures, it is the
avoidance of linked lists that Wilcox thinks will make the biggest difference.
</p>

<p>
To look up a key in a rosebush, the key is hashed. In the normal
case, the rosebush has a two-level structure; the hash is first used to select a
bucket from an array of buckets, and then looked up within that bucket using a
linear scan. The array has a number of elements that is a power of two, so the
last <tt>N</tt> bits of the hash can be used to efficiently select an entry.
In order to adjust to the number of items stored in the rosebush,
the top-level array is resizeable. This does mean that the occasional insertion
into the table will need to allocate a new top-level array and rehash the keys
into new buckets, but the <em>average</em> insertion only has to do a constant
amount of work. If few enough items have been added to the
rosebush (the exact number depends on the architecture), the rosebush will just
skip the top-level array and fall back to using a single bucket. This saves some
memory for rosebushes that are not actually being used.
Buckets are stored with the
hashes first, followed by the associated values. This ensures fewer cache lines
need to be fetched to look up an element in a bucket. Finally, the value
associated with the key is returned.
</p>

<p>
In order to efficiently support concurrent access, rosebush uses
read-copy-update (RCU) to protect each bucket.
There is a whole-hash-table spinlock that is
taken during resizing operations, but the vast majority of accesses should only
need to use RCU on the specific bucket being read from or updated. Since
reading under RCU protection is approximately free, this means that the hash table
has excellent concurrent read performance — a necessity for the dcache.
</p>

<p>
The lists rhashtable uses are
<a href="https://www.data-structures-in-practice.com/intrusive-linked-lists/">
intrusive, singly-linked lists</a>.
The kernel makes extensive use of embedded linked list structures.
Intrusive pointers do have downsides, however. For one thing, a structure with
an embedded linked list entry in it cannot be stored in multiple lists. It also
uses extra memory when the structure is not being stored in a list.
The fact that rosebush does not use intrusive pointers allows
an item to be stored in multiple rosebushes, or
the same rosebush under different keys; the benefit is a side effect of the
performance-motivated design decision to avoid linked lists.
</p>

<!-- middle-ad -->

<p>
The main problem with linked lists in this context is pointer-chasing:
linked lists require the CPU to access several
potentially unrelated parts of memory in order to iterate through the bucket.
Rosebush avoids this by using an array to hold bucket entries,
reducing the number of cache misses incurred by iterating over a bucket. Wilcox
explained the motivation in his cover letter:
</p>

<blockquote>
Where I expect rosebush to shine is on dependent cache misses.
I&#39;ve assumed an average chain length of 10 for rhashtable in the above
memory calculations.  That means on average a lookup would take five cache
misses that can&#39;t be speculated.  Rosebush does a linear walk of 4-byte
hashes looking for matches, so the CPU can usefully speculate the entire
array of hash values (indeed, we tell it exactly how many we&#39;re going to
look at) and then take a single cache miss fetching the correct pointer.
Add that to the cache miss to fetch the bucket and that&#39;s just two cache
misses rather than five.
</blockquote>

<p>
In response to
<a href="https://lwn.net/ml/linux-kernel/20240222203726.1101861-1-willy@infradead.org/">
the first version</a> of the patch set (from February),
Herbert Xu
<a href="https://lwn.net/ml/linux-kernel/Zdk2YgIoAGOEvcJi@gondor.apana.org.au/">
disagreed</a>, pointing out that an rhashtable is resized
whenever the table reaches 75% capacity, so the average bucket contains only one
item. Therefore uses of rhashtable will incur many fewer cache misses than
Wilcox had predicted.
</p>

<p>
David Laight
<a href="https://lwn.net/ml/linux-kernel/4a1416fcb3c547eb9612ce07da6a77ed@AcuMS.aculab.com/">
thought</a> that was considering the wrong metric, however. Since the kernel
never has any reason to look up an empty bucket, it is more interesting to
consider the average length of non-empty buckets. Xu
<a href="https://lwn.net/ml/linux-kernel/ZdqO3G6Fb4wYhVEj@gondor.apana.org.au/">
acknowledged</a> the point, but didn&#39;t think it changed the ultimate analysis,
since the average chain length should still be nowhere near 10 items.
</p>

<p>
Reviewers were, as ever, skeptical in the face of assertions about performance
without corresponding measurements. Peng Zhang
<a href="https://lwn.net/ml/linux-kernel/9c0aad2c-548a-4287-b3d5-c7932f40c96f@bytedance.com/">
asked</a> &#34;<q>how
much performance improvement is expected if it is applied to dcache?</q>&#34;
Wilcox didn&#39;t reply to Zhang&#39;s question.
The other reviewers did seem fairly happy with the second version of the patchset,
mainly suggesting small changes to the documentation and test suite.
</p></div></div>
  </body>
</html>
