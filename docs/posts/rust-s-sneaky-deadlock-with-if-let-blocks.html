<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://brooksblog.bearblog.dev/rusts-sneaky-deadlock-with-if-let-blocks/">Original</a>
    <h1>Rust&#39;s Sneaky Deadlock With `if let` Blocks</h1>
    
    <div id="readability-page-1" class="page"><div>
    

    
        
    

    
        

        <p>
            <i>
                <time datetime="2024-11-01T18:18Z">
                    01 Nov, 2024
                </time>
            </i>
        </p>
    

    <p>Rust is my favorite programming language. I&#39;ve been writing Rust for about 6 years, from college to professionally, and I&#39;m vocal about how helpful the compiler is in catching particularly nasty multithreaded issues and memory bugs. What the compiler doesn&#39;t always catch though is deadlocks, which can occur using several well known types like <code>Mutex</code> and <code>RwLock</code>.</p>
<p>Generally, this is fine, and you can sus out if a program is going to cause a deadlock by just making sure you aren&#39;t acquiring multiple simultaneous locks. This post is going to focus specifically on the former situation, which is acquiring multiple simultaneous competing read/write locks on the same resource. Take this snippet for example:</p>
<div><pre><span></span><span>use</span><span> </span><span>std</span><span>::</span><span>sync</span><span>::</span><span>RwLock</span><span>;</span>

<span>fn</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span>
<span>    </span><span>let</span><span> </span><span>optional</span><span> </span><span>=</span><span> </span><span>RwLock</span><span>::</span><span>new</span><span>(</span><span>Some</span><span>(</span><span>123</span><span>));</span>
<span>    </span><span>let</span><span> </span><span>lock</span><span> </span><span>=</span><span> </span><span>optional</span><span>.</span><span>read</span><span>().</span><span>unwrap</span><span>();</span>
<span>    </span><span>let</span><span> </span><span>lock2</span><span> </span><span>=</span><span> </span><span>optional</span><span>.</span><span>write</span><span>().</span><span>unwrap</span><span>();</span>
<span>    </span><span>eprintln!</span><span>(</span><span>&#34;Finished!&#34;</span><span>);</span>
<span>}</span>
</pre></div>
<p>This program will deadlock during the statement that attempts to acquire a write lock on the map. Preventing this can take many forms, the simplest being to <code>drop</code> the read lock before acquiring the write lock:</p>
<div><pre><span></span><span>use</span><span> </span><span>std</span><span>::</span><span>sync</span><span>::</span><span>RwLock</span><span>;</span>

<span>fn</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span>
<span>    </span><span>let</span><span> </span><span>optional</span><span> </span><span>=</span><span> </span><span>RwLock</span><span>::</span><span>new</span><span>(</span><span>Some</span><span>(</span><span>123</span><span>));</span>
<span>    </span><span>let</span><span> </span><span>lock</span><span> </span><span>=</span><span> </span><span>optional</span><span>.</span><span>read</span><span>().</span><span>unwrap</span><span>();</span>
<span>    </span><span>drop</span><span>(</span><span>lock</span><span>);</span>
<span>    </span><span>let</span><span> </span><span>lock2</span><span> </span><span>=</span><span> </span><span>optional</span><span>.</span><span>write</span><span>().</span><span>unwrap</span><span>();</span>
<span>    </span><span>eprintln!</span><span>(</span><span>&#34;Finished!&#34;</span><span>);</span>
<span>}</span>
</pre></div>
<p>You can also force dropping the lock by using an explicit block statement:</p>
<div><pre><span></span><span>use</span><span> </span><span>std</span><span>::</span><span>sync</span><span>::</span><span>RwLock</span><span>;</span>

<span>fn</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span>
<span>    </span><span>let</span><span> </span><span>optional</span><span> </span><span>=</span><span> </span><span>RwLock</span><span>::</span><span>new</span><span>(</span><span>Some</span><span>(</span><span>123</span><span>));</span>
<span>    </span><span>{</span>
<span>        </span><span>let</span><span> </span><span>lock</span><span> </span><span>=</span><span> </span><span>optional</span><span>.</span><span>read</span><span>().</span><span>unwrap</span><span>();</span>
<span>    </span><span>}</span>
<span>    </span><span>let</span><span> </span><span>lock2</span><span> </span><span>=</span><span> </span><span>optional</span><span>.</span><span>write</span><span>().</span><span>unwrap</span><span>();</span>
<span>    </span><span>eprintln!</span><span>(</span><span>&#34;Finished!&#34;</span><span>);</span>
<span>}</span>
</pre></div>
<p>So in a single-threaded case with competing locks, there are fairly simple ways to prevent this from happening. Now for the trouble.</p>
<h2 id="sneaky-deadlock">Sneaky Deadlock</h2><p>Knowing what you know now, let&#39;s take a look at another snippet of code:</p>
<div><pre><span></span><span>use</span><span> </span><span>std</span><span>::</span><span>sync</span><span>::</span><span>RwLock</span><span>;</span>

<span>fn</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span>
<span>    </span><span>let</span><span> </span><span>map</span><span>:</span><span> </span><span>RwLock</span><span>&lt;</span><span>Option</span><span>&lt;</span><span>u32</span><span>&gt;&gt;</span><span> </span><span>=</span><span> </span><span>RwLock</span><span>::</span><span>new</span><span>(</span><span>Some</span><span>(</span><span>2</span><span>));</span>
<span>    </span><span>if</span><span> </span><span>map</span><span>.</span><span>read</span><span>().</span><span>unwrap</span><span>().</span><span>is_some</span><span>()</span><span> </span><span>{</span>
<span>        </span><span>eprintln!</span><span>(</span><span>&#34;There&#39;s a number in there&#34;</span><span>);</span>
<span>    </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span>
<span>        </span><span>let</span><span> </span><span>mut</span><span> </span><span>lock2</span><span> </span><span>=</span><span> </span><span>map</span><span>.</span><span>write</span><span>().</span><span>unwrap</span><span>();</span>
<span>        </span><span>*</span><span>lock2</span><span> </span><span>=</span><span> </span><span>Some</span><span>(</span><span>5</span><span>);</span>
<span>        </span><span>eprintln!</span><span>(</span><span>&#34;There will now be a number {lock2:?}&#34;</span><span>);</span>
<span>    </span><span>}</span>
<span>    </span><span>eprintln!</span><span>(</span><span>&#34;Finished!&#34;</span><span>);</span>
<span>}</span>
</pre></div>
<p>Here, we&#39;re locking an optional number in a <code>RwLock</code> In the case where that variable is <code>Some</code>, we know that it&#39;s been initialized and don&#39;t need to take any action. Otherwise, we acquire a write lock and then can write a number to the lock. This runs just fine.</p>
<p>Let&#39;s use the <code>if let</code> statement to clean up our code a little bit and print out the number that&#39;s contained in the <code>RwLock</code>:</p>
<div><pre><span></span><span>use</span><span> </span><span>std</span><span>::</span><span>sync</span><span>::</span><span>RwLock</span><span>;</span>
<span>use</span><span> </span><span>std</span><span>::</span><span>collections</span><span>::</span><span>HashMap</span><span>;</span>

<span>fn</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span>
<span>    </span><span>let</span><span> </span><span>map</span><span>:</span><span> </span><span>RwLock</span><span>&lt;</span><span>Option</span><span>&lt;</span><span>u32</span><span>&gt;&gt;</span><span> </span><span>=</span><span> </span><span>RwLock</span><span>::</span><span>new</span><span>(</span><span>Some</span><span>(</span><span>2</span><span>));</span>
<span>    </span><span>if</span><span> </span><span>let</span><span> </span><span>Some</span><span>(</span><span>num</span><span>)</span><span> </span><span>=</span><span> </span><span>*</span><span>map</span><span>.</span><span>read</span><span>().</span><span>unwrap</span><span>()</span><span> </span><span>{</span>
<span>        </span><span>eprintln!</span><span>(</span><span>&#34;There&#39;s a number in there: {num}&#34;</span><span>);</span>
<span>    </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span>
<span>        </span><span>let</span><span> </span><span>mut</span><span> </span><span>lock2</span><span> </span><span>=</span><span> </span><span>map</span><span>.</span><span>write</span><span>().</span><span>unwrap</span><span>();</span>
<span>        </span><span>*</span><span>lock2</span><span> </span><span>=</span><span> </span><span>Some</span><span>(</span><span>5</span><span>);</span>
<span>        </span><span>eprintln!</span><span>(</span><span>&#34;There will now be a number {lock2:?}&#34;</span><span>);</span>
<span>    </span><span>}</span>
<span>    </span><span>eprintln!</span><span>(</span><span>&#34;Finished!&#34;</span><span>);</span>
<span>}</span>
</pre></div>
<p>This is the same logic, other than using the value obtained from the read lock changing the contents of the print statement. If we run this program, we get the output:</p>
<div><pre><span></span>There&#39;s a number in there: 2
Finished!
</pre></div>
<p>Now, what happens if we change the map to <code>RwLock::new(None)</code>, and try to initialize it?</p>
<p><img src="https://t4.ftcdn.net/jpg/01/27/37/95/360_F_127379587_IIGf7GeF0TqoLnyFPPR8scdsdNCN6JyF.jpg" alt="Waiting looking at watch"/></p>
<p>It deadlocks.</p>
<h2 id="but-why">But why?</h2><p>In short, when declaring a variable as a part of an <code>if let</code> statement that variable is held for the entire statement, including the <code>else</code> block. You can think of the program we wrote as syntactic sugar for:</p>
<div><pre><span></span><span>use</span><span> </span><span>std</span><span>::</span><span>sync</span><span>::</span><span>RwLock</span><span>;</span>
<span>use</span><span> </span><span>std</span><span>::</span><span>collections</span><span>::</span><span>HashMap</span><span>;</span>

<span>fn</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span>
<span>    </span><span>let</span><span> </span><span>map</span><span>:</span><span> </span><span>RwLock</span><span>&lt;</span><span>Option</span><span>&lt;</span><span>u32</span><span>&gt;&gt;</span><span> </span><span>=</span><span> </span><span>RwLock</span><span>::</span><span>new</span><span>(</span><span>Some</span><span>(</span><span>2</span><span>));</span>
<span>    </span><span>{</span>
<span>        </span><span>let</span><span> </span><span>num</span><span> </span><span>=</span><span> </span><span>map</span><span>.</span><span>read</span><span>().</span><span>unwrap</span><span>();</span>
<span>        </span><span>if</span><span> </span><span>num</span><span>.</span><span>is_some</span><span>()</span><span> </span><span>{</span>
<span>            </span><span>eprintln!</span><span>(</span><span>&#34;There&#39;s a number in there: {}&#34;</span><span>,</span><span> </span><span>num</span><span>.</span><span>unwrap</span><span>());</span>
<span>        </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span>
<span>            </span><span>let</span><span> </span><span>mut</span><span> </span><span>lock2</span><span> </span><span>=</span><span> </span><span>map</span><span>.</span><span>write</span><span>().</span><span>unwrap</span><span>();</span>
<span>            </span><span>*</span><span>lock2</span><span> </span><span>=</span><span> </span><span>Some</span><span>(</span><span>5</span><span>);</span>
<span>            </span><span>eprintln!</span><span>(</span><span>&#34;There will now be a number {lock2:?}&#34;</span><span>);</span>
<span>        </span><span>}</span>
<span>    </span><span>}</span>
<span>    </span><span>eprintln!</span><span>(</span><span>&#34;Finished!&#34;</span><span>);</span>
<span>}</span>
</pre></div>
<p>From this perspective, it&#39;s obvious that the read lock will be held for the entire block, and we could employ one of our previous fixes (adding explicit <code>drop</code> calls, or multiple blocks) to fix the issue. In the above cherry-picked example, this would work fine, albeit making the code a bit more complicated.</p>
<p>I wrote this block because this has specifically bitten different Rust crates in the <a href="https://wasmcloud.com/">wasmCloud</a> project multiple times (most recently <a href="https://github.com/wasmCloud/wasmCloud/pull/3523/commits/03564e40864c586db612a87c71d3177ca8cccbff?w=1#diff-3aa690812c8db9bda41ef8803d2e99d00ac9eb849354fb8c8f3daef68ccc5470">here</a> and I hoped to prevent the same mistake for others. If you&#39;re dealing with locks in Rust it can be a good idea to write out some unit tests for the different control paths you could take to make sure they all complete, and if in doubt, wrap your locks in explicit blocks to make sure they&#39;re dropped when you&#39;re finished with them.</p>


    

    
        

        
            


        
    


  </div></div>
  </body>
</html>
