<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.trailofbits.com/2023/09/18/security-flaws-in-an-sso-plugin-for-caddy/">Original</a>
    <h1>Security flaws in an SSO plugin for Caddy</h1>
    
    <div id="readability-page-1" class="page"><article id="post-105094">
	<!-- .entry-header -->

	<div>
		<p><em>By Maciej Domanski, Travis Peters, and David Pokora</em></p>
<p>We identified 10 security vulnerabilities within the <a href="https://github.com/greenpau/caddy-security" target="_blank" rel="noopener">caddy-security plugin</a> for the <a href="https://github.com/caddyserver/caddy" target="_blank" rel="noopener">Caddy</a> web server that could enable a variety of high-severity attacks in web applications, including client-side code execution, OAuth replay attacks, and unauthorized access to resources.</p>
<p>During our evaluation, Caddy was deployed as a reverse proxy to provide access to several of our internal services. We explored a plugin configuration that would allow us to handle authentication and authorization with our Google SSO so that we didn’t have to implement this on a per-app basis.</p>
<p>In this blog post, we will briefly explore the security vulnerabilities we identified in the caddy-security plugin and discuss their potential impact. As with our typical security assessments, for each issue we identified, we present a recommendation for immediately fixing the issue, as well as long-term, more strategic advice for preventing similar issues and improving the overall security posture.</p>
<p>As security experts, our goal is not only to identify vulnerabilities in specific software but also to contribute to the larger community by sharing our recommendations for fixing these problems. We believe that these recommendations can help developers overcome similar challenges in other SSO systems and improve their security.</p>
<h2>Caddy Background</h2>
<p><a href="https://caddyserver.com/" target="_blank" rel="noopener">Caddy</a> (a.k.a. Caddy Server or Caddy 2) is a modern, open-source web server written in Golang that is designed to be easy to use and highly configurable. Caddy is built to streamline the process of hosting web applications while prioritizing security and performance. It aims to reduce the complexity associated with configuring and deploying web servers.</p>
<p>The caddy-security plugin is a middleware plugin for the Caddy web server. It provides various security-related functionalities to enhance the overall security posture of web applications. Some of the key features offered by the caddy-security plugin include an authentication plugin for implementing Form-Based, Basic, Local, LDAP, OpenID Connect, OAuth 2.0, SAML Authentication, and an authorization plugin for HTTP request authorization based on JWT/PASETO tokens.</p>
<h2>Findings</h2>
<h3>Issue #1: Reflected Cross-Site Scripting (XSS)</h3>
<p><em>Severity: High</em></p>
<p>Reflected XSS occurs when an application includes untrusted data in the HTML response sent to the user’s browser. In this case, the provided <code>/admin%22%3E%3Cscript%3Ealert(document.domain)%3C/script%3E/admin/login</code> or <code>/settings/mfa/delete/&lt;img%20src=x%20onerror=alert(document.domain)&gt;</code> API calls trigger an alert. An attacker can exploit this vulnerability to execute arbitrary JavaScript code within the target user’s browser, potentially leading to further attacks such as session hijacking.</p>
<p>To immediately address this issue, strategically treat all string values as potentially untrustworthy, regardless of their source, and escape them properly (using the <code>safehtml/template</code> package that generates output-safe HTML).</p>
<p>In addition to that remediation, we also suggest a few different ways to improve defense in depth:</p>
<ul>
<li>Extend unit tests with potentially malicious XSS payloads. Refer to the <a href="https://portswigger.net/web-security/cross-site-scripting/cheat-sheet" target="_blank" rel="noopener">Cross-site scripting (XSS) cheat sheet</a> for various attack vectors.</li>
<li>Consider using the Active Scanner from Burp Suite Professional in a testing environment for all API calls. Additionally, use the <a href="https://portswigger.net/burp/documentation/desktop/automated-scanning/live-tasks" target="_blank" rel="noopener">scanning with a live task</a> strategy to have underlying requests scanned automatically when interacting with the web interface.</li>
<li>Expand the caddy-security documentation to promote security headers—especially the Content Security Policy (CSP) header that controls which resources can be loaded by the browser, limiting the impact of potential XSS attacks.</li>
</ul>
<h3>Issue #2: Insecure Randomness</h3>
<p><em>Severity: High</em></p>
<p>The caddy-security plugin uses the <code>math/rand</code> Golang library with a seed based on the Unix timestamp to generate strings for three security-critical contexts in the application, which could possibly be predicted via a brute-force search. Attackers could use the potentially predictable nonce value used for authentication purposes in the OAuth flow to conduct OAuth replay attacks. In addition, insecure randomness is used while generating multifactor authentication (MFA) secrets and creating API keys in the database package.</p>
<p>To immediately mitigate this vulnerability, use a cryptographically secure random number generator for generating the random strings. Golang’s library <code>crypto/rand</code> is designed for secure random number generation.</p>
<p>In addition to that fix, we recommend considering the following long-term recommendations:</p>
<ul>
<li>Review the application for other instances where the <code>math/rand</code> package is used for secure context. Create secure wrapping functions and use them throughout the code to serve a cryptographically secure string with the requested length.</li>
<li>Avoid duplicating code. Having a single function, such as <code>secureRandomString</code>, rather than multiple duplicate functions makes it easier to audit and verify the system’s security. It also prevents future changes to the codebase from reintroducing issues.</li>
<li>Implement Semgrep in the CI/CD. The <code>math-random-used</code> Semgrep rule will catch instances where <code>math/rand</code> is used. Refer to our <a href="https://appsec.guide/docs/static-analysis/semgrep/" target="_blank" rel="noopener">Testing Handbook on Semgrep</a> for more information.</li>
<li>Read textbooks such as <em>Real World Cryptography</em>, as it is a great resource for practical cryptographic considerations.</li>
</ul>
<h3>Issue #3: IP Spoofing via X-Forwarded-For Header</h3>
<p><em>Severity: Medium</em></p>
<p>By manipulating the <code>X-Forwarded-For</code> header, an attacker can spoof an IP address used in the user <code>identity</code> module (<code>/whoami</code> API endpoint). This could lead to unauthorized access if the system trusts this spoofed IP address.</p>
<p>To resolve this vulnerability, reimplement the application to not rely on user-provided headers when obtaining a user’s IP address. If user-provided headers are required (e.g., <code>X-Forwarded-For</code> for logging purposes), ensure the header is properly validated (i.e., the value is consistent with IP address format through regular expression) or sanitized (to avoid <a href="https://owasp.org/www-community/vulnerabilities/CRLF_Injection" target="_blank" rel="noopener">CRLF log injection attacks</a>, for example).</p>
<p>In addition to this immediate fix, we recommend considering these long-term recommendations:</p>
<ul>
<li>Implement appropriate checks for potential IP spoofing and <code>X-</code> headers on the unit testing level. Consider <a href="https://book.hacktricks.xyz/network-services-pentesting/pentesting-web/special-http-headers#headers-to-change-location" target="_blank" rel="noopener">other headers that can rewrite IP sources</a>.</li>
<li>Cover the IP spoofing scenarios and user-provided header processing in Golang’s native fuzz tests.</li>
<li>Use the dynamic testing approach with Burp Suite Professional and the <a href="https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943" target="_blank" rel="noopener">Param Miner</a> extension to identify the processing of hidden headers.</li>
<li>Expand the caddy-security documentation to increase user awareness of this type of threat; show an example of misconfiguration, how to resolve, and how to test it.</li>
</ul>
<h3>Issue #4: Referer-Based Header XSS</h3>
<p><em>Severity: Medium</em></p>
<p>An XSS vulnerability can be triggered by rewriting the <code>Referer</code> header. Although the <code>Referer</code> header is sanitized by escaping some characters that can allow XSS (e.g., [<code>&amp;</code>], [<code>&lt;</code>], [<code>&gt;</code>], [<code>&#34;</code>], [<code>&#39;</code>]), it does not account for the attack based on the JavaScript URL scheme (e.g., <code>javascript:alert(document.domain)//</code> payload). Exploiting this vulnerability may not be trivial, but it could lead to the execution of malicious scripts in the context of the target user’s browser, compromising user sessions.</p>
<p>The mitigation for this issue is identical to issue #1.</p>
<h3>Issue #5: Open Redirection Vulnerability</h3>
<p><em>Severity: Medium</em></p>
<p>When a logged-in user clicks on a specially crafted link with a <code>redirect_url</code> parameter, the user can be redirected to an external website. The user must take an action, such as clicking on a portal button or using the browser’s back button, to trigger the redirection. This could lead to phishing attacks, where an attacker tricks users into visiting a malicious website by crafting a convincing URL.</p>
<p>To mitigate this vulnerability, perform proper <code>redirect_url</code> parameter validation to ensure that the redirection URLs are allowed only within the same domain or from trusted sources.</p>
<p>In addition, we also recommend the following long-term fixes:</p>
<ul>
<li>Implement robust unit tests with different bypassing scenarios of <code>redirect_url</code> parameter validation. Refer to the potential <a href="https://book.hacktricks.xyz/pentesting-web/ssrf-server-side-request-forgery/url-format-bypass" target="_blank" rel="noopener">URL Format Bypasses</a>. Keep in mind that different components can use different URI parsers, which can lead to <a href="https://snyk.io/blog/url-confusion-vulnerabilities/" target="_blank" rel="noopener">parsing confusion</a>.</li>
<li>Use Burp Suite Professional with a scanner with both these settings enabled:
<ul>
<li>Audit coverage – maximum: to use the most extensive set of payload variations and insertion point options</li>
<li>Audit coverage – thorough: to try more payload variations</li>
</ul>
</li>
</ul>
<h3>Issue #6: X-Forwarded-Host Header Manipulation</h3>
<p><em>Severity: Medium</em></p>
<p>The caddy-security plugin processes the <code>X-Forwarded-Host</code> header, which could lead to various security vulnerabilities (web cache poisoning, business logic flaws, routing-based server-side request forgery [SSRF], and classic server-side vulnerabilities). Additionally, the caddy-security plugin generates QR codes based on this header, which extends the attack surface.</p>
<p>To mitigate this issue, do not rely on the <code>Host</code> and <code>X-Forwarded-Host</code> headers in the caddy-security plugin logic. Instead, use the current domain manually specified in the configuration file to generate a QR code.</p>
<p>In addition, we recommend the following:</p>
<ul>
<li>Use Burp Suite Professional with the Param Miner extension to identify the processing of hidden headers.</li>
<li>Extend the caddy-security documentation to increase user awareness of the <a href="https://portswigger.net/web-security/host-header/exploiting" target="_blank" rel="noopener">HTTP <code>Host</code> header attacks</a>.</li>
</ul>
<h3>Issue #7: X-Forwarded-Proto Header Manipulation</h3>
<p><em>Severity: Low</em></p>
<p>The processing of the <code>X-Forwarded-Proto</code> header results in redirection to the injected protocol. While this scenario may have limited impact, improper handling of such headers could result in unpredictable security risks, such as bypass of security mechanisms or confusion in handling TLS.</p>
<p>To address this issue, do not rely on the <code>X-Forwarded-Proto</code> header. If it is required, validate the value of the <code>X-Forwarded-Proto</code> header against an allowlist of accepted protocols (e.g., HTTP/HTTPS) and reject unexpected values.</p>
<p>In addition, consider the long-term recommendations from issue #3.</p>
<h3>Issue #8: 2FA Bypass by Brute-Forcing Verification Codes</h3>
<p><em>Severity: Low</em></p>
<p>The current implementation of the application’s two-factor authentication (2FA) lacks sufficient protection against brute-force attacks. Although the application blocks the user after several failed attempts to provide 2FA codes, attackers can bypass this blocking mechanism by automating the application’s full multistep 2FA process.</p>
<p>To address this issue effectively, enforce a minimum six-digit code length in the MFA configuration. Additionally, to reduce the risk of automated brute-forcing, implement an account locking mechanism that triggers after a specified number of invalid 2FA code attempts. Finally, enforce reauthentication for critical actions involving sensitive account information or security settings. For actions such as changing passwords or disabling 2FA, users should be required to reauthenticate, either with their password or a 2FA token. An exception can be made for reauthentication if the user has logged in within the last 10 minutes. Check out <a href="https://blog.trailofbits.com/2019/06/20/getting-2fa-right-in-2019/" target="_blank" rel="noopener">Getting 2FA Right in 2019</a> at the Trail of Bits Blog for more information.</p>
<h3>Issue #9: Lack of User Session Invalidation on Logout</h3>
<p><em>Severity: Low</em></p>
<p>The caddy-security plugin lacks proper user session invalidation upon clicking the “Sign Out” button; user sessions remain valid even after requests are sent to <code>/logout</code> and <code>/oauth2/google/logout</code>. Attackers who gain access to an active but supposedly logged-out session can perform unauthorized actions on behalf of the user.</p>
<p>To address this issue, review the sign-out process to identify the cause of the unexpected behavior. Ensure that the <code>/oauth2/google/logout</code> endpoint correctly terminates the user session and invalidates the associated tokens.</p>
<p>For more defense in depth, use the <a href="https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v3-session-management" target="_blank" rel="noopener">OWASP Application Security Verification Standard (V3 Session Management)</a> to check whether the implementation handles sessions securely.</p>
<h3>Issue #10: Multiple Panics when Parsing Caddyfile</h3>
<p><em>Severity: Low</em></p>
<p>Multiple parsing functions do not validate whether their input values are <code>nil</code> before attempting to access elements, which can lead to a panic (<code>index</code> <code>out</code> <code>of</code> <code>range</code>). Panics during the parsing of a Caddyfile may not be perceived as immediate vulnerabilities, but they could indicate improperly enforced security controls (e.g., insufficient data validation), which could lead to issues in other code paths.</p>
<p>To address these issues, integrate <code>nil</code> checks for input values before element access across all relevant functions.</p>
<p>To prevent similar issues of this type, add Golang’s native fuzz tests for Caddyfile parsing functions.</p>
<h2>Golang Security for the Community</h2>
<p>We <em>love</em> writing and reviewing Golang codebases at Trail of Bits. Indeed, we are constantly working on Golang-related <a href="https://appsec.guide/docs/static-analysis/semgrep/" target="_blank" rel="noopener">(Semgrep) resources</a>, <a href="https://github.com/trailofbits/semgrep-rules/tree/main/go" target="_blank" rel="noopener">rules</a>, and <a href="https://blog.trailofbits.com/?s=go&amp;submit=Search" target="_blank" rel="noopener">blog posts</a> and look forward to any opportunity to take on pet audits (like this) and <a href="https://github.com/trailofbits/publications#security-reviews">client projects</a> where we examine Golang codebases.</p>
<p>Our aim in publishing our findings is to help protect others who may consider implementing a solution similar to the one we explored and to help them make informed decisions about their security infrastructure.</p>
<p>If you’re actively implementing a codebase in Golang or have questions, concerns, or other recommendations on open-source software you think we should look at, please <a href="https://www.trailofbits.com/contact/" target="_blank" rel="noopener">contact us</a>.</p>
<h2>Coordinated Disclosure Timeline</h2>
<p>As part of the disclosure process, we reported the vulnerabilities to the caddy-security plugin maintainers first. The timeline of disclosure is provided below:</p>
<ul>
<li>
<ul>
<li>August 7, 2023: We reported our findings to the caddy-security plugin maintainers.</li>
<li>August 23, 2023: The caddy-security plugin maintainers confirmed that there were no near-term plans to act on the reported vulnerabilities.</li>
<li>September 18, 2023: The disclosure blog post was released and issues were filed with the original project repository.</li>
</ul>
</li>
</ul>

			</div><!-- .entry-content -->

	
</article></div>
  </body>
</html>
