<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://qdiv.dev/posts/eth2/">Original</a>
    <h1>Show HN: I made a discrete logic network card</h1>
    
    <div id="readability-page-1" class="page"><article><h5>April 9, 2024</h5><p>This post is a continuation of my journey to build a complete computer system using discrete logic components. At this point I have made a computer capable of running network applications like an HTTP server or a LAN game.</p><p>Last year I built <a href="https://qdiv.dev/posts/eth-to-spi">a physical level adapter</a> which converts a 10BASE-T Ethernet signal to SPI and back. Back then I used an STM32 microcontroller to test its operation, now I’m implementing a MAC layer module to connect it to my <a href="https://qdiv.dev/posts/ccpu">homebrew computer</a>.</p><p>Both adapters are full-duplex and have independent transmitter and receiver parts.</p><p><img src="https://qdiv.dev/eth2/overview-eth.jpg" alt="Discrete logic computer"/>
<em>Complete computer. The new module is bottom-right.</em></p><p><img src="https://qdiv.dev/eth2/eth.jpg" alt="ETH MAC adapter"/>
<em>The new module with PHY shield removed. Bodge wires fix swapped SCK and MOSI.</em></p><h2 id="receiver">Receiver
<a href="#receiver">#</a></h2><p>Summary of receiver operation:</p><ul><li>SPI serial data is converted to bytewise parallel data, byte clock is extracted;</li><li>First 6 bytes are checked against destination MAC address criteria, unmatched frames are rejected;</li><li>Bytes are written into a static RAM buffer;</li><li>When a frame ends, receiver is disabled and further frames are rejected until user re-arms the receiver. Byte counter is stopped, its value is made accessible to the user.</li></ul><p><a href="https://en.wikipedia.org/wiki/Frame_check_sequence">FCS</a> is not checked in hardware.</p><h3 id="data-collection">Data collection
<a href="#data-collection">#</a></h3><p>Firstly, serial SPI data needs to be converted into a stream of bytes.</p><p><img src="https://qdiv.dev/eth2/receiver.png" alt="Receiver"/></p><p>Serial data is shifted into a shift register (<code>U32</code>). <code>U30</code> and <code>U31</code> count bits and bytes respectively. Static RAM write signal <code>recv_buf_we</code> is formed using a D flip-flop <code>U29B</code>. This signal briefly becomes low after each 8 bits of input data:</p><p><img src="https://qdiv.dev/eth2/recv_buf_we.svg" alt="recv_buf_we"/></p><p>Received bytes are written into a 2 kB static RAM buffer 6116 (<code>U20</code>).</p><p><img src="https://qdiv.dev/eth2/recv-buffer.png" alt="receiver buffer"/></p><p><code>U13</code>, <code>U16</code> and <code>U18</code> form an address multiplexer: it chooses either byte counter or system address bus as an address input for the SRAM (<code>U20</code>). A tri-state buffer <code>U21</code> forwards the received byte into the RAM.</p><p>To access the received data and its length, RAM and byte counter are connected to the system data bus with tri-state buffers:</p><p><img src="https://qdiv.dev/eth2/recv-output.png" alt="receiver output"/></p><p><code>U25</code> connects the receiver RAM with the system data bus. After a frame is complete, the byte counter is not reset and its value is kept on the <code>recv_byte_cnt</code> bus. This bus is connected with the system data bus using <code>U26</code> and <code>U27</code>. They are activated when CPU makes a read request to specific addresses. The other half of <code>U27</code> makes a two-bit read-only status register which is used to query receiver and transmitter status.</p><h3 id="mac-address-filtering">MAC address filtering
<a href="#mac-address-filtering">#</a></h3><p>When analyzing the Ethernet traffic I noticed that frames usually come in small groups (3-4 frames together separated by a short delay). Frames in one group usually have different destination MAC addresses. This made me think that my computer won’t be able to filter received frames by MAC and re-arm the receiver fast enough to catch the frames meant for itself. I needed a hardware MAC address filtering.</p><p>Storing a custom MAC address somewhere and then comparing first 6 received bytes against it is a no-go: too complex. I could also make it a repetition of a single byte (e.g. FE:FE:FE:FE:FE:FE), but that’s boring. To bring some variation to my MAC, I made it a function of the byte index:</p><ul><li>Bit 0 is fixed to 0;</li><li>Bit 1 is fixed to 1;</li><li>Bits 2-4 are an inversion of the byte index;</li><li>Bits 5-7 are fixed to 1.</li></ul><p>Using this rule, the MAC address comes out to be <code>FE:FA:F6:F2:EE:EA</code>. We also need to accept the broadcast MAC <code>FF:FF:FF:FF:FF:FF</code> to work with ARP.</p><p><img src="https://qdiv.dev/eth2/mac-filter.png" alt="MAC filter"/></p><p>On this schematics, bus <code>a[0..3]</code> is the lower 4 bits of the byte counter. Bus <code>d[0..7]</code> is the received byte. <code>U33</code> compares data bits 0 and 2-4 with their desired values, the output of <code>U34A</code> will be high when those bits match. <code>U35A</code> implements the broadcast MAC check: its output will be high when bits 0 and 2-4 are all ones. Those two signals are combined with a logical OR (implemented with diodes <code>D7</code> and resistor <code>R6</code>). The remaining bits are checked for being all ones with <code>U35B</code>.</p><p>This block only checks the validity of a single byte. To check all six of them, the result is accumulated in <code>U10A</code>. When no frame is being received, <code>ss</code> (the incoming SPI slave select signal) is low and <code>U10A</code> is set to 1. During frame reception this value is updated for each received byte. If destination MAC address matches the criteria, the value of <code>U10A</code> stays high. When byte address reaches 5, the final value is latched into <code>U36B</code>. Its output is used to inhibit frame reception if destination address is unmatched.</p><h2 id="transmitter">Transmitter
<a href="#transmitter">#</a></h2><p>Similarly to the receiver, the transmitter doesn’t implement FCS generation, it is done in software. To simplify the transmitter even further, I decided to only support frames of a fixed length. This way no complex digital comparator is necessary, the frame transmission logic only depends on a single bit of the byte counter. I selected the frame length to be 1024 bytes, this is close to the usual MTU of 1500 bytes. The frame preamble (the sequence of several 0x55 ending with a 0xD5 required by 10BASE-T) is also included in those 1024 bytes and needs to be loaded there in software.</p><p>Fixing the frame length doesn’t have any effect on higher-level protocols because they encode the packet size in their headers and do not rely on the actual Ethernet frame length.</p><p>Summary of transmitter operation:</p><ul><li>Data is stored in a static RAM;</li><li>20 MHz clock is fed to a 4-bit counter, its overflow output is used as a byte clock;</li><li>To transmit a frame, user writes to a specific write-only memory location which enables the counter;</li><li>Parallel byte data is serialized using a shift register.</li></ul><h3 id="counters">Counters
<a href="#counters">#</a></h3><p><img src="https://qdiv.dev/eth2/tx-counters.png" alt="tx counters"/></p><p>Same as in the receiver, two counters are used to count bits (<code>U12</code>) and bytes (<code>U14</code>). First counter is fed by a 20 MHz clock from an integrated oscillator. 20 MHz is not used directly, but only divided at least by 2. This way the duty cycle of the oscillator doesn’t affect the output signal.</p><h3 id="data-flow">Data flow
<a href="#data-flow">#</a></h3><p><img src="https://qdiv.dev/eth2/tx-dataflow.png" alt="tx data flow"/></p><p>Same as in the receiver three 74HC157 multiplexors (not shown here) are used to select address input for the RAM (<code>U22</code>). <code>U23</code> is used to load data into the RAM. <code>U24</code> acts as an intermediate storage for the byte currently being transmitted. The idea here is similar to my <a href="https://qdiv.dev/posts/vga/#image-generation">VGA pipeline</a>: byte counter 74HC4040 is a ripple counter and is slow to stabilize, <code>U24</code> provides a stable output while RAM output is still invalid. This data is fed to the shift register <code>U28</code> and shifted bit-by-bit.</p><p><em>After I’d built the thing I noticed that I’d messed up the order of bits coming from the RAM to the shift register. I had to shuffle bits in software to workaround this hardware bug. This was something I couldn’t test in Verilog beforehand.</em></p><p>To form a nice 10BASE-T signal (see <a href="https://qdiv.dev/posts/eth-to-spi/#transmitter">my previous post</a>) <code>MOSI</code> and <code>SCK</code> should be precisely synchronized. <code>U11A</code> and <code>U8B</code> achieve that. <code>tx_cnt0</code> (bit 0 of the bit counter, 20 MHz divided by 2) is used as a clock. <code>U11A</code> changes its output in sync with this signal. <code>U8B</code> delays the clock to match the delay introduced by <code>U11A</code>. Because a D-latch is more complex than a simple AND gate and has a slightly larger (by 5 ns) delay, a faster 74LV74A is used here. Its propagation delay is the same as of 74HC08. This is the only chip of a “fast” family on this board.</p><h2 id="cpu-interface">CPU interface
<a href="#cpu-interface">#</a></h2><p>From the programmer’s point of view, my Ethernet adapter has following interface:</p><ul><li>Both frame buffers are mapped at <code>0xF000</code>.</li><li>There are two read-only registers:<ul><li>8-bit status register at <code>0xFB00</code> has two flags:<ul><li><code>RX_FULL</code> - a frame is received,</li><li><code>TX_BUSY</code> - a frame is being transmitted;</li></ul></li><li>16-bit received data length register at <code>0xFB02</code>.</li></ul></li><li>Writing any value at <code>0xFB00</code> re-arms the receiver.</li><li>Writing any value at <code>0xFB01</code> starts a transmission.</li></ul><p>There are no interrupts since my CPU doesn’t support them.</p><p><img src="https://qdiv.dev/eth2/addr-select.png" alt="address selector"/></p><p>Any relevant address starts with an <code>F</code> (upper 4 bits are all ones). This condition is checked by <code>U2A</code>.</p><p>Bit 11 should be 0 for a buffer address. <code>U1D</code>, <code>D2</code>, <code>R2</code> and <code>U1E</code> check that. Then the buffer select signal is combined with either write- or output-enable signals to select writing to the TX buffer or reading from the RX buffer.</p><p>Second hex digit being <code>B</code> (1011) for registers is checked by <code>U1B</code> and <code>U2B</code>. Then another diode logic block (<code>D1</code>, <code>R1</code>, <code>U1C</code>) combines it with the first digit check. Decoders <code>U4A</code> and <code>U4B</code> are used to select the individual function.</p><p>Two LEDs indicate buffer or register access.</p><h2 id="programming">Programming
<a href="#programming">#</a></h2><p>I wanted a network support for my computer, but didn’t want to implement a TCP/IP stack myself. Also I wanted a decent C compiler because my first compiler sucked and programming in assembly is annoying. So I made a <a href="https://github.com/imihajlow/ccpu-cc">C compiler</a>. It is mature enough to compile uIP 1.0 (a tiny TCP/IP library). Despite my CPU having awfully low code density, uIP is small enough to fit into RAM and have some place left for an actual application.</p><p>Network performance is very low, but I’m still very happy with it considering that no commercial CPUs or special chips are involved here:</p><ul><li>Ping round trip average 85 ms;</li><li>HTTP server download speed 2.6 kB/s (serving static files from the SD card).</li></ul><h2 id="project-repository">Project repository
<a href="#project-repository">#</a></h2><p>Models, schematic files and PCB drawings are located <a href="https://github.com/imihajlow/ccpu">on github</a>.</p></article></div>
  </body>
</html>
