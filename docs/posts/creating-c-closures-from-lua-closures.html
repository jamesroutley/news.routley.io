<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lowkpro.com/blog/creating-c-closures-from-lua-closures.html">Original</a>
    <h1>Creating C closures from Lua closures</h1>
    
    <div id="readability-page-1" class="page"><div>
        <main>
           <p>When I set out to bridge the entire Windows C API to Lua,
one of the most interesting and fun challenges I had
was to create C callbacks from Lua functions.
Without this, a significant portion of the API would be
useless, such as <a href="https://lowkpro.com/docs/winapi.WNDPROC.html">WNDPROC</a>.</p>
<h3>Brief primer on Lua closures</h3>
<p>For those unfamiliar with Lua 5.4,
it has semantics perhaps 90% similar to JavaScript.
In this case, that includes closures and lexical scoping.
That is, outer variables are &#34;enclosed around&#34;
when a new function is created that makes use of them.
In Lua, these are called &#34;up values&#34;, because they come
from &#34;up&#34; in a higher lexical scope.</p>
<pre><code>local a = 1
local f = function(b) return a + b end
print(f(2)) -- prints 3
</code></pre>
<h3>Brief primer on C &#34;closures&#34;</h3>
<p>The brutally but beautifully minimalistic language of C
has no concept of closures at all. But it does have functions
and pointers to raw memory, which are enough to work with.
Therefore it&#39;s conventional to manually pass data through
to callback functions via pointer to appropriate memory.</p>
<p>The following trivial example shows the basic concept at work.
The outer caller and inner callback pass around a pointer
and are aware of its true type, but the middle function
is unaware, and simply passes it through as a <code>void *ctx</code>.</p>
<pre><code>int cb(void *ctx, int b) {
  int a = *(int*)ctx;
  return a + b;
}

int add(void *a, int b, int (*f)(void *ctx)) {
  return f(a, b);
}

int main() {
  int a = 1;
  add(&amp;a, 2, &amp;cb);
}
</code></pre>
<p><em>Note:</em> the C expressions <code>cb</code> and <code>&amp;cb</code> both produce an address (in fact, the <em>same</em> address),
but I explicitly used <code>&amp;cb</code> here to make it more clear that it&#39;s a normal C address,
in order to tie better into what we&#39;re going to do later.</p>
<h3>The ideal bridging API</h3>
<p>This is the Lua API that I settled on:</p>
<pre><code>local a = 1
local lpfnWndProc = WNDPROC(function(hwnd, umsg, wparam, lparam)
  if umsg == WM_KEYDOWN then
    print(a)
  end
  return DefWindowProc(hwnd, umsg, wparam, lparam)
end)
</code></pre>
<p>That is, you pass a Lua function to another Lua function
that represents the C callback type, and it returns a <code>void*</code>
pointing to a dynamically created C function.</p>
<h3>The naive implementation</h3>
<p>Let&#39;s make our first example work, with a minor tweak:</p>
<pre><code>local a = 1
local f = CALLBACK(function(b) return a + b end)
print(Add(f, 2)) -- prints 3
</code></pre>
<p>We introduced two new functions:</p>
<ul>
<li><code>CALLBACK</code> which takes a Lua function and returns a C function</li>
<li><code>Add</code> which takes the C callback and an int, and runs it from within C</li>
</ul>
<p>This is enough to be a simplified variant of the pattern used by
<a href="https://lowkpro.com/docs/winapi.WNDPROC.html">WNDPROC</a>,
<a href="https://lowkpro.com/docs/winapi.WNDCLASS.html">WNDCLASS</a>,
and <a href="https://lowkpro.com/docs/winapi.CreateWindow.html">CreateWindow</a>.</p>
<p>We can trivially implement this:</p>
<pre><code>static int findex;

static int REAL_CALLBACK(lua_State *L, int b) {
  // push the function and arg onto the stack
  lua_rawgeti(L, LUA_REGISTRYINDEX, findex);
  lua_pushinteger(L, b);
  // call the Lua function with 1 arg, 1 result
  lua_call(L, 1, 1);
  // return its result interpreted as a C int
  return lua_tointeger(L, -1);
}

static int CALLBACK(lua_State *L) {
  // store Lua function in Lua registry,
  // save its index as C global findex
  findex = luaL_ref(L, LUA_REGISTRYINDEX);
  // push the heavy lifting C function
  // as a light userdata (plain C pointer)
  lua_pushlightuserdata(L, &amp;REAL_CALLBACK);
  return 1;
}

static int Add(lua_State *L) {
  int (*f)(lua_State *L, int b) = lua_touserdata(L, 1);
  int b = lua_tointeger(L, 2);

  // shim real work to the C function
  int c = f(L, b);

  lua_pushinteger(L, c);
  return 1;
}

int main() {
  lua_State *L = luaL_newstate();

  lua_pushcfunction(L, CALLBACK);
  lua_setglobal(L, &#34;CALLBACK&#34;);

  lua_pushcfunction(L, Add);
  lua_setglobal(L, &#34;Add&#34;);

  luaL_dostring(L, the_above_code);
}
</code></pre>
<p>This should be mostly self-explanatory,
even if you&#39;re not familiar with <a href="https://www.lua.org/manual/5.4/contents.html#index">Lua&#39;s C API</a>,
because it is is fairly self-documenting.
But in short, Lua&#39;s C API uses an implicit stack of objects,
and all the functions operate on this stack,
with index 1 pointing to the lowest object,
and index -1 pointing to the top-most object.
We convert C types to Lua types via functions
that operate on this stack and push/pop/interpret from it.
(We&#39;re only pushing/interpreting from it,
since our usage has no need to pop anything.)
Userdata is how Lua stores and gives out C pointers.</p>
<p>The other thing worth explaining briefly here is <code>LUA_REGISTRYINDEX</code>,
which is an index to a global table that&#39;s only accessible from C.
The <code>luaL_ref</code> function pops the last stack object and stores it
in this table at a unique index. This is perfect for our case,
because then we can retrieve it from this table later in our callback.
All we need to do is store the function&#39;s index in the <code>findex</code> global.</p>
<p>The most obvious problem with this solution is that it&#39;s
limited to having a single function remembered by the callback.
In other words, the following code would <em>not</em> work,
because <code>findex</code> is overwritten on each call to <code>CALLBACK</code>,
causing it to &#34;lose&#34; the first function, and only remember the second.</p>
<pre><code>local a1, a2 = 1, 2
local f1 = CALLBACK(function(b) return a1 + b end)
local f2 = CALLBACK(function(b) return a2 + b end)
print(Add(f1, 2)) -- prints 4 -- wrong!
print(Add(f2, 2)) -- prints 4, right
</code></pre>
<p>The question is, how do you create a <em>new</em> and <em>unique</em>
C pointer for <em>each</em> Lua function passed in,
one that uses the correct Lua function?
The answer, of course, is dynamically generated assembly!</p>
<h3>Creating C closures dynamically at runtime</h3>
<p>Now we&#39;re finally getting to the fun stuff!
We&#39;re going to change <code>CALLBACK</code> to dynamically generate
a &#34;C&#34; function at runtime, one that correctly sets our
C global <code>findex</code> just before calling <code>REAL_CALLBACK</code>.</p>
<p>Naturally, this will need to have different implementations
for different platforms, which is easy enough using <code>#if</code> guards.
But for now we&#39;re only concerned with 64-bit Windows.
The <a href="https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170">x64 calling convention</a> document will be a helpful reference,
and perhaps <a href="https://learn.microsoft.com/en-us/cpp/build/x64-software-conventions?view=msvc-170">Overview of x64 ABI conventions</a> too,
but I&#39;ll explain the basics that we need to know.</p>
<p>The equivalent C code that we&#39;ll be generating is essentially this:</p>
<pre><code>/* unspecified */ generated_function(/* unspecified */) {
  findex = _closed_over_findex;
  goto REAL_CALLBACK(/* pass args as-is */);
  /* return value is whatever REAL_CALLBACK returns */
}
</code></pre>
<p>In other words:</p>
<ol>
<li>Create a temporary <code>_closed_over_findex</code> value</li>
<li>Set the C global <code>findex</code> to our new <code>_closed_over_findex</code> value</li>
<li>Jump to first instruction at <code>&amp;REAL_CALLBACK</code></li>
</ol>
<h3>Learning assembly via Visual Studio&#39;s debugger</h3>
<p>As a starting point, we can look at what assembly MSVC generates
for code very similar to what we need to do.
Let&#39;s create a minimalistic <code>main</code> that just
sets a few globals and then jumps to an address.
Then set a debug point on the first line of <code>main</code> (<code>foo1 = 111</code>),
run it, and hit <code>Ctrl-Alt-D</code> to show the assembly.</p>
<pre><code>static int foo1;
static int foo2;
static int foo3;

int main() {
  foo1 = 111;
  goto later;
  foo2 = 222;
  foo3 = 333;
later:
  return 0;
}
</code></pre>
<p>When you compile in <strong>Release</strong> mode, you get this:</p>
<pre><code>nop          ;; 
xor eax, eax ;; set ret to 0
ret          ;; exit main
</code></pre>
<p>It happens because the values are optimized away.
That&#39;s not particularly useful in this instance.
But we can fix it by adding <code>volatile</code> to the variables.
This tells the compiler that our variables are off-limits
for optimizations, possibly for the sake of side-effects,
or in our case, so we can inspect the actual output.</p>
<pre><code>- static int foo1;
- static int foo2;
- static int foo3;
+ static volatile int foo1;
+ static volatile int foo2;
+ static volatile int foo3;
</code></pre>
<p>Now we get this:</p>
<pre><code>nop          ;; 
mov dword ptr [foo1 (07FF7838E0670h)], 6Fh
xor eax, eax ;; set ret to 0
ret          ;; exit main
</code></pre>
<p>You&#39;ll get a different value than <code>07FF7838E0670h</code>,
but it will always be the same value as <code>&amp;foo1</code>.
You can test this with <code>printf(&#34;%lld\n&#34;, &amp;foo1);</code>
We have to use <code>lld</code> because in Windows 64-bit,
pointers are 64-bits aka <code>long long int</code>.</p>
<p>Still, the compiler is just too smart for us here,
and we have to compile in <strong>Debug</strong> configuration,
so that we can see the <code>jmp</code> at all. Now we get this:</p>
<pre><code>;int main() {
push  rbp  
push  rdi  
sub   rsp,0E8h  
lea   rbp,[rsp+20h]  
lea   rcx,[__29E14FF1_ConsoleApplication1@c (07FF717A41008h)]  
call  __CheckForDebuggerJustMyCode (07FF717A31352h)  
nop  
;  foo1 = 111;
mov   dword ptr [foo1 (07FF717A3C200h)],6Fh  
;  goto later;
jmp   $later (07FF717A317ACh)  
;  foo2 = 222;
mov   dword ptr [foo2 (07FF717A3C204h)],0DEh  
;  foo3 = 333;
mov   dword ptr [foo3 (07FF717A3C208h)],14Dh  
;later:
;  return 0;
xor   eax,eax  
;}
lea   rsp,[rbp+0C8h]  
pop   rdi  
pop   rbp  
ret  
</code></pre>
<p>Now we start seeing stack setup, and debug shims, but we can ignore all that.
The only interesting part here is this:</p>
<pre><code>mov   dword ptr [foo1 (07FF717A3C200h)],6Fh  
jmp   $later (07FF717A317ACh)  
</code></pre>
<p>Now, tying this to our original code, we&#39;ll want to generate this assembly:</p>
<pre><code>mov   dword ptr [findex], _closed_over_findex
jmp   REAL_CALLBACK
</code></pre>
<h3>Learning how to generate assembly</h3>
<p>There&#39;s two websites that will help us here:</p>
<ul>
<li><a href="https://defuse.ca/online-x86-assembler.htm">https://defuse.ca/online-x86-assembler.htm</a> which uses GCC (make sure to click x64)</li>
<li><a href="https://asmjit.com/parser.html">https://asmjit.com/parser.html</a> which uses AsmJit</li>
</ul>
<p>If we use both and compare outputs,
we can double-check our solution.</p>
<p>We&#39;ll start by inputting the assembly as-is,
but we&#39;ll notice errors and try to fix them.
For starters, it&#39;s not helpful to have variables,
so we can change them out with placeholder numbers,
which we can later replace with our own values.
In this case, let&#39;s stick with the first example:</p>
<pre><code>mov   dword ptr [07FF717A3C200h],6Fh
jmp   07FF717A317ACh
</code></pre>
<p>The first issue we run into is that
the first website (which uses GCC)
hates the <code>h</code> syntax for hex values.
So let&#39;s use the <code>0x</code> syntax:</p>
<pre><code>mov   dword ptr [0x07FF717A3C200],0x6F
jmp   0x07FF717A317AC
</code></pre>
<p>Now we see some &#34;Unsupported instructions&#34; in the GCC site,
and we continue to see &#34;Relocations&#34; in the asmjit site.
Let&#39;s simplify this by breaking down each instruction.</p>
<h3>Learning the jmp instruction</h3>
<p>First, let&#39;s look at <code>jmp</code> by itself.
Here&#39;s a table of the values I tried to encode,
with the results from the GCC site and asmjit site:</p>
<pre><code>;; input               ;; gcc        ;; asmjit
jmp   0x07FF717A317AC  ;; error      ;; 40E900000000
jmp   0xffffffff       ;; error      ;; 40E900000000
jmp   0xfffffff        ;; e900000000 ;; 40E900000000
</code></pre>
<p>Interesting, we finally get assembly from GCC,
and the 0xE9 matches what asmjit has been giving us,
except that it&#39;s missing the 0x40 from asmjit.</p>
<p>The <a href="https://www.felixcloutier.com/x86/jmp">jmp manual page</a>
indicates that E9 refers to a <em>relative</em> address.
That explains why it only allows values <em>just under</em> 32-bits.
If we want an absolute address, particularly a 64-bit one,
we can use FF and refer to memory via a register.
This is confirmed in <a href="https://stackoverflow.com/a/79741806/30953273">this SO answer</a>.</p>
<p>Now we need to find an unused register.
Consulting the <a href="https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170">x64-conventions</a> page,
we need to find a scratch register,
particularly one that isn&#39;t used for params,
since we&#39;re creating a shim at the beginning of a function.
That page suggests that <code>rax</code> is fine, since it&#39;s both
&#34;volatile&#34; (scratch register) and not used by params.</p>
<p>So let&#39;s change our assembly to use that:</p>
<pre><code>;; input   ;; gcc    ;; asmjit
jmp   rax  ;; FFE0   ;; FFE0
</code></pre>
<p>Voila! We have a perfect match.
<em>And</em>, since <code>rax</code> is the 64-bit version of <code>eax</code>,
we have automatic support for 64-bit values. Nice.</p>
<p>So our jump is just two bytes: <code>0xFF</code> and <code>0xE0</code>.
Let&#39;s note this for later and move on to <code>mov</code>.</p>
<h3>Learning the mov instruction</h3>
<p>Going back to our example:</p>
<pre><code>mov   dword ptr [0x07FF717A3C200],0x6F
</code></pre>
<p>This works in asmjit, but not the GCC site.
And the asmjit version has relocations again.</p>
<p>Let&#39;s see what happens if we reuse the <code>rax</code> trick.
We&#39;ll store a literal value into <code>rax</code>, which
we&#39;ll need to do anyway for the <code>jmp</code> instruction,
so it knows where to goto.</p>
<pre><code>mov   dword ptr [rax], 0x6F
;; gcc:    C7006F000000
;; asmjit: C7006F000000
</code></pre>
<p>Another perfect match! And no relocations!
The immediate value (0x6F) is generated with the instruction.</p>
<p>There&#39;s only one problem: the d-word.
Double words are only 32 bytes.
What if our value is 64 bytes?
We&#39;ll need a qword:</p>
<pre><code>mov   qword ptr [rax], 0x6F
;; gcc:    48C7006F000000
;; asmjit: 48C7006F000000
</code></pre>
<p>It works, but it generates different instructions.
But once we try a 64-bit <em>value</em>, such as <code>0xffffffffff</code>
we see this fail in <em>both</em> sites.
That&#39;s because this is actually <em>incorrect asm</em>.</p>
<p>The syntax <code>qword ptr [rax]</code> made sense
when the &#34;dest&#34; operand was a memory address
and the &#34;src&#34; operand was an immediate (literal value).
But now that we&#39;re dealing with a <em>register</em>,
this is <em>not</em> the correct syntax.
If we retry it with just plain <code>rax</code> we get this:</p>
<pre><code>mov   rax, 0x6F               ;; 48C7C06F000000
mov   rax, 0xfffffff          ;; 48C7C0FFFFFF0F
mov   rax, 0xffffffff         ;; 48B8FFFFFFFF00000000
mov   rax, 0xfffffffff        ;; 48B8FFFFFFFF0F000000
mov   rax, 0x7f7f7f7f7f7f7f7f ;; 48B87F7F7F7F7F7F7F7F
</code></pre>
<p>Which means, our function <code>movToRax</code> looks like this:</p>
<ul>
<li>For 32-bit values, write <code>48,C7,C0,(4 byte val)</code></li>
<li>For 64-bit values, write <code>48,B8,(8 byte val)</code></li>
</ul>
<pre><code>static BYTE* movToRax(BYTE* exe, UINT64 val) {
  if (val &gt; 0xffffffff) {
    *exe++ = 0x48;
    *exe++ = 0xb8;
    *((UINT64*)exe) = val;
    exe += sizeof(UINT64);
  }
  else {
    *exe++ = 0x48;
    *exe++ = 0xc7;
    *exe++ = 0xc0;
    *((UINT32*)exe) = val;
    exe += sizeof(UINT32);
  }
  return exe;
}
</code></pre>
<p>There&#39;s probably a more concise way to do this,
but this gets the job done, and returns a pointer
to the next byte after the memory is written,
which we will use when we tie it all together.</p>
<p>We will need the inverse, a <code>movRaxTo</code> function,
because our overall assembly generator will need to:</p>
<ol>
<li>Move <code>_closed_over_findex</code> to <code>RAX</code></li>
<li>Move <code>RAX</code> to <code>&amp;findex</code></li>
<li>Move <code>&amp;REAL_CALLBACK</code> to <code>RAX</code></li>
<li>Jump to <code>RAX</code></li>
</ol>
<p>We can use <code>movToRax</code> for 1 and 3,
and 4 is the exact same logic as <code>movToRax</code>
except that it just emits <code>0xFF</code> and <code>0xE0</code>
and doesn&#39;t need to check the size.</p>
<p>Implementing <code>movRaxTo</code> is an exercise for the reader.
Which means now we&#39;re at the super fun part!</p>
<h3>Generating assembly at runtime</h3>
<p>We&#39;re almost ready to generate assembly!
First, let&#39;s change <code>CALLBACK</code> to use
the function we need but don&#39;t have yet:</p>
<pre><code>static int CALLBACK(lua_State *L) {
- findex = luaL_ref(L, LUA_REGISTRYINDEX);
- lua_pushlightuserdata(L, &amp;REAL_CALLBACK);
+ int index = luaL_ref(L, LUA_REGISTRYINDEX);
+ void *_generated_function = generate_function(index);
+ lua_pushlightuserdata(L, _generated_function);
  return 1;
}
</code></pre>
<p>A few changes:</p>
<ol>
<li>
<p>Instead of storing the index in <code>findex</code> directly,
we&#39;re passing the int to <code>generate_function</code>,
which will deal with <code>findex</code> in a new way.</p>
</li>
<li>
<p>We have a new function <code>generate_function</code>
which returns a <code>void*</code> pointing to a new function
which we&#39;re going to create dynamically at runtime,
which we named <code>_generated_function</code> here.</p>
</li>
<li>
<p>Instead of returning <code>&amp;REAL_CALLBACK</code>,
we&#39;re returning the pointer <code>_generated_function</code>.</p>
</li>
</ol>
<p>Now we have to implement the new <code>generate_function</code>,
which produces assembly corresponding to <code>generated_function</code>
as outlined above.</p>
<pre><code>static void *generate_function(int _closed_over_findex) {
  BYTE *exe = VirtualAlloc(
    NULL,
    0x10000,
    MEM_RESERVE | MEM_COMMIT,
    PAGE_READWRITE | PAGE_EXECUTE
  );

  BYTE *fn = exe;

  exe = movToRax(exe, _closed_over_findex);
  exe = movRaxTo(exe, &amp;findex);
  exe = movToRax(exe, &amp;REAL_CALLBACK);
  exe = jmpToRax(exe);

  return fn;
}
</code></pre>
<p>That&#39;s it! We now have executable memory,
which we wrote assembly to at runtime.
It creates functions which set <code>findex</code>
and then jumps to <code>&amp;REAL_CALLBACK</code>.
We return the memory, and it&#39;s <em>indistinguishable</em>
at runtime from a function we&#39;d have written in C,
except mainly that it&#39;s missing debug information.</p>
<h3>Caveats on incorrect things here</h3>
<p>Notice that we didn&#39;t do <em>any</em> error handling.
In practice, lowkPRO does a <em>lot</em> more,
but it&#39;s rather boring and distracting.</p>
<p>Also notice that we have a <em>hugely</em> inefficient use of <code>VirtualAlloc</code>.
That function allocates <em>in 64kb chunks</em>. You do <em>not</em> want to use it this way.
In practice, lowkPRO allocates each chunk as needed, and splits it up
into nodes in a large linked list, to be used at each callback creation.
Nodes are freed by a <code>winapi.freecallback</code> function that lowkPRO provides.</p>
<p>And finally, it&#39;s not good practice to have executable memory
that&#39;s both writable and executable. In practice, lowkPRO
uses <code>AllocProtect</code> to set it as writable only when creating a callback,
and executable at all other times.</p>
<p>It does a little more work, too, using <code>thread_local</code>
and a critical section to make sure that creating,
freeing, and calling callbacks are thread safe operations.</p>
<p>The techniques I describe in this article were used to bridge
<em>all</em> Windows API callbacks to Lua,
from <a href="https://lowkpro.com/docs/winapi.WNDPROC.html">WNDPROC</a>
to <a href="https://lowkpro.com/docs/winapi.pD3DCompile.html">pD3DCompile</a>,
using a script written in C# that generates C++ code
which itself takes about 30 minutes to recompile,
porting about half a million Windows API entries.</p>

        
      
        </main>
        
      </div></div>
  </body>
</html>
