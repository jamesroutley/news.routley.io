<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/e3ntity/nanograd">Original</a>
    <h1>Minimal auto-differentiation engine in Rust</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">Minimal automatic-differentiation engine written in Rust.</p>


<p dir="auto">Running the demo trains a tiny Multi-Layer Perceptron to learn the XOR function and writes a rendered computation graph of a single Perceptron to <code>graph.html</code>.</p>

<div dir="auto" data-snippet-clipboard-copy-content="use nanograd::scalar::{Scalar, func};

let x = Scalar::new_grad(2.0);
let y = Scalar::new_grad(-1.0);

// z = relu(x * y + 3)
let z = func::relu(x.clone() * y.clone() + 3.0);
z.backward();

println!(&#34;z = {}&#34;, z.get_value());
println!(&#34;dz/dx = {:?}&#34;, x.get_grad());
println!(&#34;dz/dy = {:?}&#34;, y.get_grad());"><pre><span>use</span> nanograd<span>::</span>scalar<span>::</span><span>{</span><span>Scalar</span><span>,</span> func<span>}</span><span>;</span>

<span>let</span> x = <span>Scalar</span><span>::</span><span>new_grad</span><span>(</span><span>2.0</span><span>)</span><span>;</span>
<span>let</span> y = <span>Scalar</span><span>::</span><span>new_grad</span><span>(</span>-<span>1.0</span><span>)</span><span>;</span>

<span>// z = relu(x * y + 3)</span>
<span>let</span> z = func<span>::</span><span>relu</span><span>(</span>x<span>.</span><span>clone</span><span>(</span><span>)</span> <span>*</span> y<span>.</span><span>clone</span><span>(</span><span>)</span> + <span>3.0</span><span>)</span><span>;</span>
z<span>.</span><span>backward</span><span>(</span><span>)</span><span>;</span>

<span>println</span><span>!</span><span>(</span><span>&#34;z = {}&#34;</span><span>,</span> z<span>.</span>get_value<span>(</span><span>)</span><span>)</span><span>;</span>
<span>println</span><span>!</span><span>(</span><span>&#34;dz/dx = {:?}&#34;</span><span>,</span> x<span>.</span>get_grad<span>(</span><span>)</span><span>)</span><span>;</span>
<span>println</span><span>!</span><span>(</span><span>&#34;dz/dy = {:?}&#34;</span><span>,</span> y<span>.</span>get_grad<span>(</span><span>)</span><span>)</span><span>;</span></pre></div>

<ul dir="auto">
<li>Each <code>Scalar</code> stores <strong>value</strong>, optional <strong>gradient</strong>, and an <code>Edge</code> describing the operation that produced it.</li>
<li>Operator overloads (<code>+</code>, <code>*</code>, <code>-</code>, ...) and helpers in <code>scalar::func</code> build a directed acyclic graph of <code>Scalar</code>s while caching the <strong>local derivative</strong> for every edge.</li>
<li><code>backward()</code> starts at an output node and <strong>recursively propagates gradients</strong> along the graph, accumulating them into the leaf nodes created with <code>Scalar::new_grad</code>.</li>
<li>The graph can be visualised with <code>plot::dump_graph</code>, which emits a self-contained D3.js HTML file.</li>
</ul>
</article></div></div>
  </body>
</html>
