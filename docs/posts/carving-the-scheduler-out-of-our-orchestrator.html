<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fly.io/blog/carving-the-scheduler-out-of-our-orchestrator/">Original</a>
    <h1>Carving the scheduler out of our orchestrator</h1>
    
    <div id="readability-page-1" class="page"><article> <dl> <dt>Author</dt> <dd> <img src="https://fly.io/static/images/thomas.jpg" alt="Thomas Ptacek" srcset=""/> <dl> <dt>Name</dt> <dd> Thomas Ptacek </dd> <dt>Twitter</dt> <dd> <a href="https://twitter.com/tqbf" target="_blank"> @tqbf </a> </dd> </dl> </dd> </dl> <section> <figure> <img src="https://fly.io/blog/2023-02-01/starry-containers.jpg" alt=""/> <figcaption> <span>Image by</span> <svg role="img" style="pointer-events: none; width: 17px; height: 17px;" viewBox="0 0 20 20" fill="currentColor" fill-rule="evenodd"> <g buffered-rendering="static"> <path fill-rule="evenodd" d="M1 8a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 018.07 3h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0016.07 6H17a2 2 0 012 2v7a2 2 0 01-2 2H3a2 2 0 01-2-2V8zm13.5 3a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0zM10 14a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd"></path> </g> </svg> <a href="https://annieruygtillustration.com/" target="_blank"> Annie Ruygt </a> </figcaption> </figure> <p> We’re Fly.io, a global sandwich-rating company with a hosting problem. Even if you don&#39;t have a sandwich to rate, you might benefit from the hosting platform we built. Check it out: with a working Docker image, <a href="https://fly.io/docs/speedrun/">you can be up and running on Fly.io in just minutes.</a></p><p>So, you want to build an app to rate sandwiches. Well, the world has a lot of different sandwiches. <a href="https://en.wikipedia.org/wiki/Pit_beef">Pit beefs</a> in Baltimore, <a href="https://www.bonappetit.com/recipe/pork-katsu-sandwich">Tonkatsu sandos</a> in Shinjuku, and <a href="https://en.wikipedia.org/wiki/Cemita">Cemitas</a> in Puebla. You want real-time sandwich telemetry, no matter the longitude of the sandwich. So you need to run it all over the world, without a lot of ceremony.</p> <p>We built one of those at Fly.io. We’ve written a bunch <a href="https://fly.io/blog/docker-without-docker/">about one important piece of the puzzle</a>: how we take Docker images from our users and efficiently run them as virtual machines. You can run a Docker image as VM. You’re almost done! Time to draw the rest of the owl.</p> <p>To turn our Docker transmogrification into a platform, we need to go from running a single job to running hundreds of thousands. That’s an engineering problem with a name:</p> <h2 id="orchestration"><a href="#orchestration" aria-label="Anchor"></a>Orchestration</h2><p>Orchestrators link clusters of worker servers together and offer up an API to run jobs on them. <a href="https://kubernetes.io/">Kubernetes</a> is an orchestrator; the Kleenex of orchestrators. Then, HashiCorp has <a href="https://www.nomadproject.io/">Nomad</a>, which we use, and about which more in a bit.</p> <p>Find a serverside developer complaining about how much harder it is to deliver an app in 2023 than it was in 2005, and odds are, <a href="https://news.ycombinator.com/item?id=20774712">they’re complaining about orchestration.</a> They&#39;re not wrong: Kubernetes is fractally complicated. But the idea isn’t.</p> <p>Let’s write an orchestrator. Start by writing a supervisor.</p> <div><pre><code>    <span>for</span> <span>_</span><span>,</span> <span>task</span> <span>:=</span> <span>range</span> <span>tasks</span> <span>{</span>
        <span>wg</span><span>.</span><span>Add</span><span>(</span><span>1</span><span>)</span>

        <span>go</span> <span>func</span><span>(</span><span>t</span> <span>Task</span><span>)</span> <span>{</span>
            <span>defer</span> <span>wg</span><span>.</span><span>Done</span><span>()</span>

            <span>argv</span> <span>:=</span> <span>strings</span><span>.</span><span>Split</span><span>(</span><span>t</span><span>.</span><span>Command</span><span>,</span> <span>&#34; &#34;</span><span>)</span>

            <span>for</span> <span>{</span>
                <span>cmd</span> <span>:=</span> <span>exec</span><span>.</span><span>Command</span><span>(</span><span>argv</span><span>[</span><span>0</span><span>],</span> <span>argv</span><span>[</span><span>1</span><span>:</span><span>]</span><span>...</span><span>)</span>

                <span>cmd</span><span>.</span><span>Start</span><span>()</span>
                <span>cmd</span><span>.</span><span>Wait</span><span>()</span>

                <span>if</span> <span>!</span><span>t</span><span>.</span><span>Restart</span> <span>{</span>
                    <span>break</span>
                <span>}</span>
            <span>}</span>
        <span>}(</span><span>task</span><span>)</span>
    <span>}</span>

    <span>wg</span><span>.</span><span>Wait</span><span>()</span>

</code></pre></div><p>I believe this design is so powerful it does not need to be discussed.</p> <p>There are, like, <a href="http://supervisord.org/">100</a> <a href="https://github.com/DarthSim/overmind">different</a> <a href="https://mmonit.com/monit/">supervisors</a>. You can write a program to run a shell command, you can write a supervisor. Come on. You&#39;ve already written a supervisor. Let&#39;s stop kidding each other.</p> <p>Let’s turn ours into an orchestrator.</p> <p>For illustrative purposes, our supervisor takes a JSON configuration:</p> <div><pre><code>[
  {
    &#34;Name&#34;: &#34;frick&#34;,
    &#34;Command&#34;: &#34;sleep 1&#34;,
    &#34;Restart&#34;: true
  },
  {
    &#34;Name&#34;: &#34;frack&#34;,
    &#34;Command&#34;: &#34;sleep 5&#34;
  }
]

</code></pre></div><p>Instead of reading this configuration from a file, like a dumb old supervisor, read it from an HTTP API, like a majestic orchestrator. &#34;Workers&#34; run our simple supervisor code, and a <code>server</code> doles out tasks. Here’s an API:</p> <div><pre><code>GET /sched/jobs # polled
POST /sched/claim/{name}
POST /sched/release/{name}
GET /sched/cancellations # polled

POST /sched/submit
GET /sched/status/{name}
POST /sched/cancel/{name}

</code></pre></div><p>The server implementing this is an exercise for the reader. Don’t overthink it .</p> <p>Workers poll <code>/jobs</code>. They <code>/claim</code> them by name. The <code>server</code> decides which claim wins, awarding it a <code>200</code> HTTP response. The worker runs the job, until it stops, and posts <code>/release</code>.</p> <p>End-users drive the orchestrator with the same API; they post JSON tasks to <code>/submit</code>, check to see where they’re running, kill them by name with <code>/cancel</code>. Workers poll <code>/cancellations</code> to see what to stop running.</p> <p>There. That&#39;s an orchestrator. It&#39;s just a client-server process supervisor.</p> <p>I see a lot of hands raised in the audience. I’ll take questions at the end. But let’s see if I can head some of them off:</p> <ul> <li>Sure, it’s unusual for an orchestrator to run shell commands.  A serious orchestrator would run Docker containers (or some agglomeration of multiple Dockerfiles called a Pod or a Brood or a Murder). But that’s just a detail; a constant factor of new lines calling the containerd SDK. <a href="https://pkg.go.dev/github.com/containerd/containerd">Knock yourself out!</a> </li><li>Yeah, if you were running this in some big enterprise, you’d need some kind of <a href="https://awspolicygen.s3.amazonaws.com/policygen.html">security and access control</a>; this thing is just <code>rsh</code>. These are just details. </li><li>“That’s a stupid API” isn’t a question. </li><li>No, I don’t know what should happen if the server goes down. Something sane. Cancel and restart all the tasks. </li><li>OK, having all the workers stampeding to grab conflicting jobs is inefficient. But at most cluster sizes, who cares? Have the workers wait a random interval before claiming. Have them randomize the job they try to claim. It&#39;ll probably scale fine. </li><li>Yes, you could just do this with Redis and <code>BLPOP</code>. </li></ul> <p>You there in the back hollering… this isn’t a real orchestrator, why? Oh, because we’re not</p> <h2 id="scheduling"><a href="#scheduling" aria-label="Anchor"></a>Scheduling</h2><p>Scheduling means deciding which worker to run each task on.</p> <p>Scheduling is to an orchestrator what a routing protocol is to a router: the dilithium crystal, the contents of Marcellus Wallace’s briefcase, the thing that, ostensibly, makes the system Difficult.</p> <p>It doesn&#39;t have to be hard. Assume our cluster is an undifferentiated mass of identical workers on the same network. Decide how many jobs a worker can run. Then: just tell a worker not to bid on jobs when it’s at its limit.</p> <p>But no mainstream orchestrator works this way. All of them share some notion of centralized scheduling: an all-seeing eye that allocates space on workers the way a memory allocator doles out memory.</p> <p>Even centralized scheduling doesn&#39;t complicate our API that much.</p> <div><pre><code>POST /sched/register # {&#39;cpu&#39;:64,&#39;mem&#39;:256,&#39;diskfree&#39;:&#39;4t&#39;}
GET /sched/assigned
POST /sched/started/{name}
POST /sched/stopped/{name}
GET /sched/cancellations

</code></pre></div><p>Instead of rattling off all the available jobs and having workers stampede to claim them, our new API assigns them directly. Easier for the workers, harder for the server, which is now obligated to make decisions.</p> <p>Here&#39;s the rough outline of a centralized scheduler:</p> <ol> <li>Filter out workers that fail to match constraints, like sufficient disk space or CPUs or microlattice shapecasters. </li><li>Rank the surviving workers. </li></ol> <p>The textbook way to rank viable workers is &#34;<a href="https://www.ics.uci.edu/~goodrich/teach/cs165/notes/BinPacking.pdf">bin packing</a>&#34;. Bin packing is a classic computer science problem: given a series of variably-sized objects and fixed-size containers, fit all the objects in the smallest number of containers. The conventional wisdom about allocating jobs in a cluster is indeed that of the clown car: try to make servers as utilized as possible, so you can minimize the number of servers you need to buy.</p> <p>So far, the mechanics of what I&#39;m describing are barely an afternoon coding project. But real clusters tend to run Kubernetes. Even small clusters: people run K8s for apps like <code>ratemysandwich.com</code> all the time. But K8s was designed to host things like <code>all of Google</code>. So K8s has fussy scheduling system.</p> <p>To qualify as “fussy”, a scheduler needs at least 2 of the following 3 properties:</p> <ol> <li>Place jobs on workers according to some optimum that is theoretically NP-hard to obtain (but is in practice like 2 nested <code>for</code> loops). </li><li>Accounting for varying resource requirements for jobs using a live inventory of all the workers and something approximating a constraint solver. </li><li>Scaling to huge clusters, without a single point of failure, so that the scheduler itself becomes a large distributed system. </li></ol> <p>These tenets of fussiness hold true not just for K8s, but for all mainstream orchestrators, including the one we use.</p> <p><img src="https://fly.io/blog/2023-02-01/mickens.png?3/4&amp;border" alt=""/></p> <h2 id="nomad"><a href="#nomad" aria-label="Anchor"></a>Nomad</h2><p>Let&#39;s start by reckoning with what&#39;s going on with Kubernetes.</p> <p>The legends speak of a mighty orchestrator lurking within the halls of Google called &#34;<a href="https://research.google/pubs/pub43438/">Borg</a>&#34;. Those of us who&#39;ve never worked at Google have to take the word of those who have that Borg actually exists, and the word of other people that <a href="https://kubernetes.io/blog/2015/04/borg-predecessor-to-kubernetes/">K8s is based on the design of Borg.</a></p> <p>The thing about Borg is that, if it exists, it exists within an ecosystem of other internal Google services. This makes sense for Google the same way having <a href="https://aws.amazon.com/s3/">S3</a>, <a href="https://aws.amazon.com/sqs/">SQS</a>, <a href="https://aws.amazon.com/ecs/">ECS</a>, <a href="https://aws.amazon.com/lambda/">Lambda</a>, <a href="https://aws.amazon.com/ebs/">EBS</a>, <a href="https://aws.amazon.com/elasticloadbalancing/">ALBs</a>, <a href="https://aws.amazon.com/cloudwatch/">CloudWatch</a>, <a href="https://aws.amazon.com/cognito/">Cognito</a>, <a href="https://aws.amazon.com/efs/">EFS</a>, <a href="https://aws.amazon.com/redshift/">RedShift</a>, <a href="https://aws.amazon.com/route53">Route53</a>, <a href="https://aws.amazon.com/glacier/">Glacier</a>, <a href="https://aws.amazon.com/sns/">SNS</a>, <a href="https://aws.amazon.com/vpc/">VPC</a>, <a href="https://aws.amazon.com/certificate-manager/">Certificate Manager</a>, <a href="https://universalpaperclips.fandom.com/wiki/Quantum_Foam_Annealment">QFA</a>, <a href="https://aws.amazon.com/iam/">IAM</a>, <a href="https://aws.amazon.com/kms/">KMS</a>, <a href="https://aws.amazon.com/codecommit/">CodeCommit</a>, <a href="https://aws.amazon.com/opsworks/">OpsWorks</a>, <a href="https://aws.amazon.com/cloudformation/">Cloudformation</a>, <a href="https://aws.amazon.com/snowball/">Snowball</a>, <a href="https://aws.amazon.com/xray/">X-Ray</a>, <a href="https://www.youtube.com/watch?v=KWotO76SuXE">Price List Marketplace Metering Service Entitlement Modernization</a>, and <a href="https://aws.amazon.com/ec2/">EC2</a> does for AWS. Like, somewhere within Google there&#39;s a team that&#39;s using each of these kinds of service.</p> <p>It makes less sense for a single piece of software to try to wrap up all those services. But <a href="https://landscape.cncf.io/">Kubernetes seems to be trying</a>. Here&#39;s some perspective: K8s is, some people say, essentially Borg but with Docker Containers instead of <a href="https://www.usenix.org/sites/default/files/conference/protected-files/lisa_2014_talk.pdf">Midas packages</a>. Midas is neat, but it in turn relies on <a href="https://static.googleusercontent.com/media/research.google.com/en//archive/bigtable-osdi06.pdf">BigTable</a> and <a href="https://cloud.google.com/blog/products/storage-data-transfer/a-peek-behind-colossus-googles-file-system">Colossus</a>, two huge Google services. And that&#39;s just packages, the lowest level primitive in the system. It&#39;s an, uh, ambitious starting point for a global open source standard.</p> <p>At any rate, our customers want to run Linux apps, not Kubernetes apps. So Kubernetes is out.</p> <p>Sometime later, a team inside Google took it upon themselves to redesign Borg. Their system was called <a href="https://research.google/pubs/pub41684/">Omega</a>. I don&#39;t know if it was ever widely used, but it&#39;s influential. Omega has these properties:</p> <ul> <li>Distributed scheduling, so that scheduling decisions could be made on servers across the cluster instead of a monolithic single central scheduler. </li><li>A complete, up-to-date picture of available resources on the cluster (via a Paxos-replicated database) provided to all schedulers. </li><li>Optimistic transactions: if a proposed decision fails, because it conflicts with some other claim on the same resources, your scheduler just tries again. </li></ul> <p>Hashicorp <a href="https://developer.hashicorp.com/nomad/docs/concepts/scheduling/scheduling">took Google&#39;s Omega paper and turned it into an open source project</a>, called Nomad.</p> <p>Omega&#39;s architecture is nice. But the real win is that Nomad is lightweight. It&#39;s conceptually not all that far from the API we designed earlier, <a href="https://github.com/hashicorp/raft">plus Raft</a>.</p> <p>Nomad can run Unix programs directly, or in Docker containers. We do neither. Not a problem: Nomad will orchestrate jobs for anything that conforms to <a href="https://pkg.go.dev/github.com/hashicorp/nomad/plugins/drivers">this interface</a>:</p> <div><pre><code>    <span>RecoverTask</span><span>(</span><span>*</span><span>TaskHandle</span><span>)</span> <span>error</span>
    <span>StartTask</span><span>(</span><span>*</span><span>TaskConfig</span><span>)</span> <span>(</span><span>*</span><span>TaskHandle</span><span>,</span> <span>*</span><span>DriverNetwork</span><span>,</span> <span>error</span><span>)</span>
    <span>WaitTask</span><span>(</span><span>ctx</span> <span>context</span><span>.</span><span>Context</span><span>,</span> <span>taskID</span> <span>string</span><span>)</span> <span>(</span><span>&lt;-</span><span>chan</span> <span>*</span><span>ExitResult</span><span>,</span> <span>error</span><span>)</span>
    <span>StopTask</span><span>(</span><span>taskID</span> <span>string</span><span>,</span> <span>timeout</span> <span>time</span><span>.</span><span>Duration</span><span>,</span> <span>signal</span> <span>string</span><span>)</span> <span>error</span>
    <span>DestroyTask</span><span>(</span><span>taskID</span> <span>string</span><span>,</span> <span>force</span> <span>bool</span><span>)</span> <span>error</span>
    <span>InspectTask</span><span>(</span><span>taskID</span> <span>string</span><span>)</span> <span>(</span><span>*</span><span>TaskStatus</span><span>,</span> <span>error</span><span>)</span>
    <span>// plus some other goo</span>

</code></pre></div><p>For the year following <a href="https://news.ycombinator.com/item?id=22616857">our launch</a>, Fly.io&#39;s platform was a Rust proxy and a Golang Nomad driver. The driver could check out a Docker image, convert it to a block device, and start Firecracker on it. In return for coding to the driver interface, we got:</p> <ul> <li>Constraint-based deployments that let us tell a specific Fly app to run in Singapore (har cheong gai burger), Sydney (hamdog), and Frankfurt (doner kebab), on dedicated CPU instances with 2 cores and at least 4 gigs of memory, say. </li><li>The ability to move Fly Apps around our fleet, draining them off specific machines for maintenance. </li><li>Opt-in integration <a href="https://fly.io/blog/a-foolish-consistency/">with Consul</a>, which we used for request routing and to glue our API to our platform backend. </li></ul> <p>About Nomad itself, we have nothing but nice things to say. Nomad is like Flask to K8s&#39;s Django, Sinatra to K8s&#39;s Rails. It&#39;s unopinionated, easy to set up, and straightforward to extend. Use Nomad.</p> <p> Another very cool system to look at in this space is <a href="https://github.com/flynn/flynn">Flynn</a>. Flynn was an open source project that started before Docker was stable and grew up alongside it. They set out to build a platform-as-a-service in a box, one that bootstraps itself from a single-binary install. It does so much stuff! If you&#39;ve ever wondered what all the backend code for something like Fly.io must be like (multiple generations of schedulers and all), check out what they did.</p><p>But we&#39;ve outgrown it, because:</p> <p><strong>Bin packing is wrong for platforms like Fly.io</strong>. Fussy schedulers are premised on minimizing deployed servers by making every server do more. That makes a lot of sense if you&#39;re Pixar. We rent out server space. So we buy enough of them to have headroom in every region. As long as they&#39;re running, we&#39;d want to use them.</p> <p><a href="http://www.columbia.edu/~cs2035/courses/ieor4405.S13/datacenter_scheduling.ppt">Here&#39;s a Google presentation</a> on the logic behind Nomad&#39;s first-fit bin packing scheduler. It was designed for a cluster where 0% utilization was better, for power consumption reasons, than &lt; 40% utilization. Makes sense for Google. Not so much for us.</p> <p>With strict bin packing, we end up with Katamari Damacy scheduling, where a couple overworked servers in our fleet suck up all the random jobs they come into contact with. Resource tracking is imperfect and neighbors are noisy, so this is a pretty bad customer experience.</p> <p>Nomad added a &#34;<a href="https://developer.hashicorp.com/nomad/tutorials/advanced-scheduling/spread">spread scheduling</a>&#34; option, which just inverts the bin pack scoring they use by default. But that&#39;s not necessarily what we want. What we want is complicated! We&#39;re high-maintenance! In a geographically diverse fleet with predictable usage patterns, the best scheduling plans are intricate, and we don&#39;t want to fight with a scheduler to implement them.</p> <p><strong>We Run One Global Cluster.</strong> This isn&#39;t what Nomad expects. Nomad wants us to run <a href="https://developer.hashicorp.com/nomad/tutorials/manage-clusters/federation">a bunch of federated clusters</a> (one in Dallas, one in Newark, and so on).</p> <p>There are two big reasons we don&#39;t federate Nomad:</p> <ul> <li>It changes the semantics of how apps are orchestrated, which would require fiddly engineering for us to wire back into our UX. For instance: there isn&#39;t an obvious, clean way to roll back a failing app deploy across a dozen regions all at once. We have lots of regions, but offer one platform to our users, so we run into lots of stuff like this. </li><li>Even if we did that work, Nomad pricing looks at us and sees Apple, Inc. More power to them! But, like, no. </li></ul> <p><strong>We Outgrew The Orchestration Model.</strong> Nomad scheduling is asynchronous. You submit a job to a server. All the servers convene a trustees meeting, solicit public comment, agree on the previous meeting&#39;s minutes, and reach consensus about the nature of the job requested. A plan is put into motion, and the implicated workers are informed. Probably, everything works fine; if not, the process starts over again, and again, until seconds, minutes, hours, or days later, it does work.</p> <p>This is not a bad way to handle a <code>flyctl deploy</code> request. But it&#39;s no way to handle an HTTP request, and that&#39;s what we want: for a request to land at our network edge in São Paulo, and then we <strong>scale from zero</strong> to handle it in our <code>GRU</code> region, starting a Fly Machine on a particular server, synchronously.</p> <div><p> The Fly.io step in there that costs the most is pulling containers from registries. People&#39;s containers are huge! That makes the win from caching large – and just not captured by the Nomad scheduler. </p></div><p>At this point, what we&#39;re asking our scheduler to do is to consider Docker images themselves to be a resource, like disk space and memory. The set of images cached and ready to deploy on any given server is changing every second, and so are the scheduling demands being submitted to the orchestrator. Crazy producers. Crazy consumers. It&#39;s a lot to ask from a centralized scheduler.</p> <p>So we built our own, called</p> <h2 id="numad"><a href="#numad" aria-label="Anchor"></a>Nümad</h2><p>Just kidding, we call it <code>flyd</code>.</p> <p>There is a <a href="https://queue.acm.org/detail.cfm?id=3173558">long and distinguished literature</a> of <a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/44843.pdf">cluster scheduling</a>, <a href="https://ieeexplore.ieee.org/document/4634">going back into the 1980s</a>. We decided not to consult it, and just built something instead.</p> <p><code>flyd</code> has a radically different model from Kubernetes and Nomad. Mainstream orchestrators are like sophisticated memory allocators, operating from a reliable global picture of all capacity everywhere in the cluster. Not <code>flyd</code>.</p> <p>Instead, <code>flyd</code> operates like a market. Requests to schedule jobs are bids for resources; workers are suppliers. Our orchestrator sits in the middle like an exchange. <code>ratemysandwich.com</code> asks for a Fly Machine with 4 dedicated CPU cores in Chennai (sandwich: bun kebab?). Some worker in <code>MAA</code> offers room; a match is made, the order is filled.</p> <p>Or, critically: the order is not filled. That&#39;s fine too! What&#39;s important is that the decision be made quickly, so that it can be done synchronously. What we don&#39;t want is a <code>pending</code> state waiting for the weather to clear up.</p> <p><img src="https://fly.io/blog/2023-02-01/flaps.png?3/4" alt=""/></p> <p>Our system has a cast of three characters:</p> <ul> <li><code>flyd</code> is the source of truth for all the VMs running on a particular worker. </li><li><code>flaps</code> is a stateful proxy for all the <code>flyd</code> instances. </li><li><code>flyctl</code> is our CLI. You know it, you love it. </li></ul> <p>The engine of this system is <code>flyd</code>.</p> <p>In Nomad-land, our Firecracker driver doesn&#39;t keep much state. That&#39;s the job of huge scheduling servers, operating in unlighted chambers beyond time amidst the maddening beating and monotonous whine of the <a href="https://www.imdb.com/title/tt5073642/">Raft consensus protocol</a>.</p> <p>In <code>flyd</code>-land, state-keeping is very much the worker&#39;s problem. Every worker is its own source of truth. Every <code>flyd</code> keeps a <code>boltdb</code> database of its current state, which is an append-only log of all the operations applied to the worker.</p> <p><code>flyd</code> is rigidly structured as a collection of state machines, like &#34;create a machine&#34; or &#34;delete a volume&#34;. Each has a concrete representation both in the code (using Go generics) and in <code>boltdb</code>. Everything happening in <code>flyd</code> (in logs, traces, metrics or whatever) happens at a particular state for a particular resource ID. Easy to reason about. And, of course, if we bounce <code>flyd</code>, it picks up right where it left off.</p> <div> <p><code>flyd</code> operates off of a local <code>boltdb</code> database, but our platform also has an SQLite view of all the resources allocated systemwide. We built it by caching Consul, but, in keeping with our ethos of &#34;if you see Raft anywhere, something went wrong&#34;, we&#39;ve replaced it with something simpler. We call it Corrosion. </p></div><p>All the <code>flyd</code> instances in (say) Madrid form a <code>MAD</code> cluster. But it&#39;s not a cluster in the same sense Nomad or K8s uses: no state is shared between the <code>flyd</code> instances, and no consensus protocol runs.</p> <p>To get jobs running on a <code>flyd</code> in <code>MAD</code>, you talk to <code>flaps</code>. <code>flaps</code> is running wherever you are (in my case, <code>ORD</code>).</p> <p><code>flaps</code> uses Corrosion to find all the workers in a particular region. It has direct connectivity to every <code>flyd</code>, because our network is meshed up with WireGuard. <code>flyd</code> exposes an internal HTTP API to <code>flaps</code>, and <code>flaps</code> in turn exposes this API:</p> <div><pre><code>GET /v1/apps/my-app/machines  # list
POST /v1/apps/my-app/machines # create
GET /v1/apps/{machineid}      # show
DELETE /v1/apps/{machineid} 
POST /v1/apps/{machineid}/start
POST /v1/apps/{machineid}/stop

</code></pre></div><p>&#34;Creating&#34; a Fly Machine reserves space on a worker in some region.</p> <p><img src="https://fly.io/blog/2023-02-01/curve.png?1/4&amp;wrap-right" alt="A utility function for, say, CPU capacity"/> To reserve space in Sydney, <code>flaps</code> collects capacity information from all the <code>flyds</code> in <code>SYD</code>, and then runs a quick best-fit ranking over the workers with space, which is just a simple linear interpolation rankings workers as more or less desirable at different utilizations of different resources.</p>  <p>Rather than forming distributed consensus clusters, Fly.io regions like <code>MAD</code> and <code>SYD</code>† are like products listed on an exchange. There are multiple suppliers of <code>MAD</code> VMs (each of our workers in Madrid) and you don&#39;t care which one you get. <code>flaps</code> act like a broker. Orders come in, and we attempt to match them. <code>flaps</code> does some lookups in the process, but it doesn&#39;t hold on to any state; the different <code>flaps</code> instances around the world don&#39;t agree on a picture of the world. The whole process can fail, the same way an immediate-or-cancel order does with a financial market order. That&#39;s OK!</p> <p>Here&#39;s what doesn&#39;t happen in this design: jobs don&#39;t arrive and then sit on the book in a &#34;pending&#34; state while the orchestrator does its best to find some place, any place to run it. If you ask for VMs in <code>MAD</code>, you&#39;re going to get VMs in <code>MAD</code>, or you&#39;re going to get nothing. You won&#39;t get VMs in <code>FRA</code> because the orchestrator has decided &#34;that&#39;s close enough&#34;. That kind of thing happened to us all the time with Nomad.</p> <h2 id="scheduling-reconsidered"><a href="#scheduling-reconsidered" aria-label="Anchor"></a>Scheduling, Reconsidered</h2><p>If you&#39;re a certain kind of reader, you&#39;ve noticed that this design doesn&#39;t do everything Fly Apps do. What happens when an app crashes? How do we deploy across a bunch of regions? How does a rollback work? These are problems Nomad solved. It doesn&#39;t look like <code>flaps</code> and <code>flyd</code> solve them.</p> <p>That&#39;s because they don&#39;t! Other parts of the platform — most notably, <code>flyctl</code>, our beloved CLI — take over those responsibilities.</p> <p>For example: how do we handle a crashed worker? Now, <code>flyd</code> will restart a crashed VM, of course; that&#39;s an easy decision to make locally. But some problems can&#39;t be fixed by a single worker. Well, one thing we do is: when you do a deploy, <code>flyctl</code> creates multiple machines for each instance. Only one is started, but others are prepped on different workers. If a worker goes down, <code>fly-proxy</code> notices, and sends a signal to start a spare.</p> <p>What we&#39;re doing more generally is carving complex, policy-heavy functionality out of our platform, and moving it out to the client. <a href="https://web.mit.edu/Saltzer/www/publications/endtoend/endtoend.pdf">Aficionados of classic papers</a> will recognize this as an old strategy.</p> <p>What we had with Nomad was a system that would make a lot of sense if we were scheduling a relatively small number of huge apps. But we schedule a huge number of relatively small apps, and the intelligent decisions our platform made in response to stimuli were often a Mad Hatter&#39;s tea party. For instance: many times when Europe lost connectivity to <code>us-east-1</code> S3, apps would flake, and Nomad would in response cry &#34;change places!&#34; and reschedule them onto different machines.</p> <p>What we&#39;ve concluded is that these kinds of scheduling decisions are actually the nuts and bolts of how our platform works. They&#39;re things we should have very strong opinions about, and we shouldn&#39;t be debating a bin packer or a constraint system to implement them. In the new design, the basic primitives are directly exposed, and we just write code to configure them the way we want.</p> <p>Internally, we call this new system &#34;AppsV2&#34;, because we&#39;re good at naming things. If you&#39;re deploying an app in January of 2023, you&#39;re still using Nomad; if you&#39;re deploying one in December of 2023, you&#39;ll probably be interacting with <code>flyd</code>. If we do it right, you mostly won&#39;t have to care.</p> <figure> <figcaption> <p> The Fly Machines API runs on flyd and reserves, starts, and stops individual VMs.</p><p><a href="https://fly.io/docs/speedrun/"> Try Fly for free  <span>→</span> </a></p> </figcaption><p><img src="https://fly.io/static/images/cta-dog.jpg" srcset="/static/images/cta-dog@2x.jpg 2x" alt=""/></p></figure><h2 id="drawing-most-of-the-owl"><a href="#drawing-most-of-the-owl" aria-label="Anchor"></a>Drawing Most of the Owl</h2><p>Over the last couple years, we&#39;ve written about most of the guts of Fly.io:</p> <ul> <li><a href="https://fly.io/blog/docker-without-docker/">How we run containers as VMs</a> in the first place, </li><li>how our <a href="https://fly.io/blog/ipv6-wireguard-peering/">WireGuard-backed private networking layer</a> works, </li><li>how we <a href="https://fly.io/blog/32-bit-real-estate/">provision Internet Anycasting</a>, and </li><li>how our <a href="https://fly.io/blog/a-foolish-consistency/">control plane works</a> (gonna have to rewrite that one soon!). </li></ul> <p>It took us awhile, but we&#39;re glad to have finally written down our thoughts about one of the last remaining big pieces. With an execution engine, a control plane, and an orchestrator, you&#39;ve got most of our platform! The only huge piece left is <code>fly-proxy</code>, which we have not yet done justice.</p> <p>We hope this is interesting stuff even if you never plan on running an app here (or building a platform of your own on top of ours). We&#39;re not the first team to come up with a bidding-style orchestrator — they&#39;re documented <a href="https://ieeexplore.ieee.org/document/4634">in that 1988 paper above</a>! But given an entire industry of orchestrators that look like Borg, it&#39;s good to get a reminder of how many degrees of freedom we really have.</p>  </section> <dl> <dt> Previous post  ↓ </dt> <dd> <a href="https://fly.io/blog/fly-in-johannesburg/"> Fly.io is in Johannesburg </a> </dd> </dl> </article></div>
  </body>
</html>
