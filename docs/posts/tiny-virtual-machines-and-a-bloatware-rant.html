<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rfong.github.io/rflog/2024/07/09/vms/">Original</a>
    <h1>Tiny virtual machines and a bloatware rant</h1>
    
    <div id="readability-page-1" class="page"><div>
      





<div>
  
  
  

	
  
    <p>I just spent yesterday afternoon and this morning “implementing” an <a href="https://en.wikipedia.org/wiki/Little_Computer_3">LC-3 (Little Computer 3)</a> VM in C. (By the facetious quotes I mean that I was following a tutorial with a lot of training wheels.)</p>



<h3 id="whats-a-virtual-machine">What’s a virtual machine?</h3>

<p>A VM is a program that simulates some CPU architecture with I/O interaction, and can understand programs written in some machine language. A VM could simulate a certain video game platform, or a modern OS. A VM could also be some made-up architecture; it doesn’t need to correspond to an existing machine.</p>

<p>Reasons you might use a VM:</p>
<ul>
  <li>Running the same program on different pieces of hardware (for example, emulating a Nintendo game on a laptop)</li>
  <li>Executing code in architecture-level isolation from your actual system (for example, testing your weird custom hardware’s 24-bit 3-register architecture (yes, this is a thing lol) on your 64-bit laptop)</li>
</ul>

<p><a href="https://www.atlassian.com/microservices/cloud-computing/containers-vs-vms">How does a container differ from a VM?</a>: Containers (think of Docker or Kubernetes) also provide a certain level of virtual separation, but less than VMs. Containers run on top of the existing operating system, while virtual machines run on top of an entirely simulated architecture.</p>

<h3 id="whats-lc-3">What’s <a href="https://en.wikipedia.org/wiki/Little_Computer_3">LC-3</a>?</h3>

<p>LC-3 is a spec for a small educational toy computer architecture that you can build quickly in simulation. It has a 16-bit architecture that understands assembly programs, but it is much smaller and simpler than classic x86 Assembly.</p>

<p>LC-3 has 2^16 = 65,536 memory locations, each of which stores a 16-bit value, for a total of 128KB of memory.</p>

<p>There are 2 special registers (one for the program counter, one for condition flags), and technically 8 general-purpose registers. However, <code>R7</code> is typically reserved for storing jump locations.</p>

<p>There are 16 <strong>opcodes</strong>. An opcode is a hardcoded number corresponding to some fundamental basic assembly instruction the CPU can execute using registers and memory, for example jumping somewhere in memory or loading some value into a register. Some have multiple modes. For example, <code>ADD</code> can either add together the values at two pointers, or add the value at a pointer with a small binary value provided directly in the assembly instruction.</p>

<h3 id="whats-an-assembler">What’s an assembler?</h3>

<p>Assembly language is kind of the bare minimum veneer of human readable syntax. You are describing operations as close to bare metal as software goes, but you get to use niceties such as commas, whitespace, comments, and ASCII characters.</p>

<p>An assembler is a program that converts assembly into machine code binary.</p>

<h3 id="isnt-it-weird-to-write-an-assembly-consuming-vm-in-something-as-high-level-as-c-which-then-runs-on-top-of-a-whole-os">Isn’t it weird to write an Assembly-consuming VM in something as high level as C, which then runs on top of a whole OS?</h3>

<p>Not really; the point of VMs is portability.</p>

<p>Most programs are shackled to their computer architecture. If you want to port a program directly to another architecture, you probably need to rewrite the entire thing. This is why it almost never happens for consumer programs with big user interfaces.</p>

<p>Thankfully it is not too rare to see ports of low-level terminal utilities.</p>



<p>The instruction set implementation took me maybe an hour, it was mostly pushing bits around in <code>uint16</code>s. A lot of functionality was duplicated between instructions and could stand to get streamlined down. Most of my time was spent reading the documentation and understanding the scaffolding that was necessary before you could start using the instruction set.</p>

<p>The tutorial step order made sense from an abstract perspective, but it felt out of order codewise. In order to do intermediate checks to see if I had implemented the instruction sets correctly, I had to skip around a lot in the tutorial. So I did the scaffolding first.</p>

<p>I uploaded <a href="https://github.com/rfong/lc3-vm-c">my implementation here</a>. If you also want to try writing the LC-3 instruction set but you don’t want to understand all the rest of the setup code, 
I uploaded <a href="https://github.com/rfong/lc3-vm-tutorial-c">my scaffolding and toolchain setup instructions</a> here as a jumping-off point.</p>

<p>However, I would really recommend typing everything out manually like I did and taking the time to understand each line, instead of copypasting. I made a typo in one bitwise operator along the way and OH BOY was it an educational experience.</p>



<h3 id="hundred-rabbits-uxn-platform">Hundred Rabbits <code>uxn</code> platform</h3>

<p>I recently read a computery writeup I quite enjoyed, but without VM/OS experience, I had trouble understanding the design considerations. So I went off on the LC-3 tangent in order to better understand this talk.</p>

<p><a href="https://100r.co/site/weathering_software_winter.html">“Weathering software winter”</a> is a Hundred Rabbits talk about the design considerations that went into the base of their current personal off-grid tech stack, <code>uxn</code>, a super tiny custom VM. It runs programs written in a small assembly instruction set called <a href="https://wiki.xxiivv.com/site/uxntal.html"><code>uxntal</code></a>, which has 32 opcodes. The smallness makes it easy to port across lots of hardware.</p>

<blockquote>
  <p>No one can take a paper computer away from you. […] this is a form of computing that can be easily ported.</p>
</blockquote>

<p>This is cool because it lets you write utilities that perform well on old, cheap hardware, such as a Nintendo DS that has never touched the internet, or a Raspberry Pi, or a $100 Chromebook. As opposed to the modern method of buying a new thousand dollar device that will last 2 years and break if you don’t feed it 11 gigabyte software updates all the time.</p>

<p>They use <code>uxn</code> to run various custom utility tools they have written to replace their industry bloatware tools. It is obviously not a consumer general-purpose computer, but it works for their purposes – graphics editing, an office toolsuite, livecoding, etc.</p>

<p>For context, Hundred Rabbits is a studio of two creatives (focusing somewhat in video games) who work on computers and live full-time internationally on a sailboat with only 180W of solar power. Open sea crossings mean that they sometimes go months without internet. They have thoroughly clashed with the off-grid limitations and planned obsolescence of modern software and hardware.</p>

<p>A lot of modern Western software &amp; hardware assumes nearly-unlimited internet bandwidth, and crashes in unexpected ways if you remove it from its expected parameters. So you basically cannot develop for MacOS if you live in certain parts of the world, can’t use modern Adobe software at all while offgrid, etc.</p>

<p>Further 100r reading:</p>
<ul>
  <li><a href="https://youtu.be/BW32yUEymvU">30-minute video talk on their off-grid infrastructure</a></li>
  <li><a href="https://100r.co/site/tools_ecosystem.html">their software tools ecosystem</a> - the shorter layperson version of “weathering software winter”, minus the computer architecture details</li>
</ul>

<h3 id="modern-bloatware-rant">modern bloatware rant</h3>

<p>I live squarely in a U.S. city with high-speed internet and even so – simply as a person who does not want to throw away a perfectly good computer and buy a new one every few years – I often clash with bloatware and hardware obsolescence. I upgraded from my 2013 computer last year not because anything was inherently wrong with it, but because it could no longer run a modern web browser, videochat, and a team messaging tool simultaneously without seizing up.</p>

<p>Computers get exponentially more powerful and yet the software that runs on them gets slower, buggier, less introspectable, and shorter-lived all the time.</p>

<p>Modern software is simultaneously more and less accessible.</p>
<ul>
  <li>More accessible in the sense that anyone with a super fast Western internet connection can play in someone else’s sandbox by using a few magic aliases to connect together big and complex chonks of code that someone else has written, and <em>(via a monstrosity of multi-region multi-replica distributed systems so Eldritch that understanding even the abstractions in a modern distsys paper requires you to understand 30 other modern distsys papers, then recurse, ad infinitum)</em> run it in a container instance somewhere on the “cloud”, e.g. probably an Amazon datacenter.</li>
  <li>Less accessible in the sense that you must constantly upgrade to the latest hardware, you must be perpetually online, your software is dependent on chains of hundreds of providers that have bugs and downtime and can yank support at any time, and hundreds/thousands of dependencies that are vulnerable to attack or deprecation. Expect obsolescence within 2-3 years.</li>
</ul>

<p>Systems level stuff does not get terribad as quickly – probably because people who directly push bits around understand that magic’s only guarantee is your swift and wretched ruination – but web toolchains get exponentially worse with each passing year. It is pretty standard these days to be forced to setup hundreds of packages and several complicated interlocking layers of frameworks, toolchains, and watchers just to laboriously compile and render the most basic static site functionality you can imagine. <a href="https://rfong.github.io/rflog/2021/06/15/ultralight-web/">As previously described</a>, I avoid modern heavyweight stacks like the plague while in the realm of personal projects.</p>

<p>Last year while contracting for <a href="https://dataplusfeminism.mit.edu/">MIT Data+Feminism Lab</a>, I got to overhaul a tool where I was explicitly being hired to make it work better for international users with low network bandwidth, which was really refreshing and restored my faith in humanity a little bit. Most of our non-U.S.-based users were on 2.4GHz networks, and some had &lt;1Mbps download speed. I throttled my browser to 500Kbps for testing, and it was both an upsetting and enlightening experience.</p>

<p>I miss the 00s internet.</p>


  
</div>




    </div></div>
  </body>
</html>
