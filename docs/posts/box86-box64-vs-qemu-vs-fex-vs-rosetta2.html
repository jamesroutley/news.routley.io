<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://box86.org/2022/03/box86-box64-vs-qemu-vs-fex-vs-rosetta2/">Original</a>
    <h1>Box86/Box64 vs. QEMU vs. FEX (Vs Rosetta2)</h1>
    
    <div id="readability-page-1" class="page"><div>

		<div>

			
<h2>Comparing performances</h2>



<p>I decided to compare the performances of the OpenSource Linux Userspace Emulator that allows you to run x86/x86_64 apps on ARM linux. There are <a href="https://www.qemu.org/">QEMU-user</a>, <a href="https://fex-emu.org/">FEX-emu</a> and <a href="https://github.com/ptitSeb/box86">Box86</a>/<a href="https://github.com/ptitSeb/box64">Box64</a>.</p>



<h2>How to bench Linux userspace emulator</h2>



<p>Test will consist of the bench I already used a couple of time, and that can be run as native or emulated:</p>



<ul><li>7-zip integrated benchmark, that contains mostly integer code (no x87 or SSE), and can be used as a baseline to see the pure x86 code translation efficiency. The version 16 present in Ubuntu was used for those tests.</li><li>dav1d, an opensource video transcoding tool, that includes hand-optimized SSE assembly code (SSE3 or more).</li><li>glmark2 that is GL limited and should run at mostly native speed (as long as GL is hardware accelerated). I couldn’t install the armhf version of glmark2 on Ubuntu, so only the native 64bits version was benchmarked.</li><li>openarena, that contains x87 code, and a JIT, and, in that config, is very much GPU limited, and so should be running very close to the native speed (again, as long as GL is still hardware accelerated).</li></ul>



<p>The 7z, dav1d and glmark2 bench are described <a href="https://stands.fosdem.org/stands/box86/performances/">here</a>, and the openarena one <a href="https://box86.org/2021/06/game-performances/">there</a>.</p>



<p>I’ll also do some quick bench not available natively. The fps will simply be measured with `HUD_GALLIUM=fps` on a stable and reproducible moment in the game:</p>



<ul><li>WorldOfGoo: The game has simple graphics, it should run fine. Measures will be done on the Title screen.</li><li>FTL: that I added to the bench after doing the QEMU measures. Measures will be done on the 1st Tutorial screen, while the game is paused.</li><li>CINEBENCH r15: A benchmark based on a raytracing engine. Lots of SSE (SSE2 and more) code here. Use multi-core also. Does include a CPU bench and OpenGL bench, but only the CPU one is used here. It provides a simple number indicating the performance (the higher, the better).</li></ul>



<p>To install WorldOfGoo, the “uname” trick will be used, as this allows to choose x86 or x86_64 installation (without the trick, the installer doesn’t recognise “aarch64” platform and fallback to x86). WorldOfGoo will run at 1920×1080 fullscreen.</p>



<p>CINEBENCH r15. This one needs Wine, and a 64bits version of it. It’s a benchmark with the CINEMA 4D Engine.</p>



<p>After some some testing, I realized that both openarena and WorldOfGoo mainly use x87 code, at least for the 32bits version of WorldOfGoo. Both QEMU and FEX seem to use use Softfloat for it, to keep the 80bits precision, while box uses hardware float (with some tricks to keep 80bits when needed, like on some data copy used by old games), so I decided to also check the menu page of FTL, that I know use SSE code. But I didn’t test on QEMU (it’s not hardware accelerated anyway, so it would be too slow). FTL will run at default resolution of 1280×720 windowed. I’ll launch the tutorial, answer to the 1st dialog box and mesure the fps at this point.</p>



<h2>Machine used</h2>



<p>Test machine is an RPI400 (so, 4 big cores @1.8GHz and 4GB of RAM), and I will be using Ubuntu 21.10 64bits OS. Here are the common steps to prepare the OS (after turning off the “Blank screen” option in the “Power” settings), as I’ll be reinstalling the OS between each emu:</p>



<pre><code>sudo apt update &amp;&amp; sudo apt upgrade -y</code></pre>



<p>reboot, then install the ssh server</p>



<pre><code>sudo apt install openssh-server -y</code></pre>



<p>And then install some libs, for games</p>



<pre><code>sudo apt install libsdl1.2debian libopenal1 -y</code></pre>



<figure><img loading="lazy" width="1024" height="576" src="https://box86.org/wp-content/uploads/2022/03/Pi400_Ubuntu-1024x576.jpg" alt="" srcset="https://box86.org/wp-content/uploads/2022/03/Pi400_Ubuntu-1024x576.jpg 1024w, https://box86.org/wp-content/uploads/2022/03/Pi400_Ubuntu-300x169.jpg 300w, https://box86.org/wp-content/uploads/2022/03/Pi400_Ubuntu-768x432.jpg 768w, https://box86.org/wp-content/uploads/2022/03/Pi400_Ubuntu-1536x864.jpg 1536w, https://box86.org/wp-content/uploads/2022/03/Pi400_Ubuntu-1200x675.jpg 1200w, https://box86.org/wp-content/uploads/2022/03/Pi400_Ubuntu.jpg 1723w" sizes="(max-width: 1024px) 100vw, 1024px"/><figcaption>The PI/400 used for this benchmark, running Ubuntu impish.</figcaption></figure>



<h2>QEMU-user</h2>



<p>Installation is very simple on Ubuntu, as it’s part of the repo:</p>



<pre><code>sudo dpkg --add-architecture i386
sudo dpkg --add-architecture amd64</code></pre>



<p>Then add the correct repo, create <code><kbd>/etc/apt/sources.list.d/i386.list</kbd></code> with this:</p>



<pre><code>deb [arch=i386] http://security.ubuntu.com/ubuntu/ impish-security  main restricted universe multiverse
deb [arch=i386]  http://archive.ubuntu.com/ubuntu/ impish           main restricted universe multiverse
deb [arch=i386]  http://archive.ubuntu.com/ubuntu/ impish-updates   main restricted universe multiverse
deb [arch=i386]  http://archive.ubuntu.com/ubuntu/ impish-backports main restricted universe multiverse</code></pre>



<p>And <kbd>/etc/apt/sources.list.d/amd64.list</kbd> with this</p>



<pre><code>deb [arch=amd64] http://security.ubuntu.com/ubuntu/ impish-security  main restricted universe multiverse
deb [arch=amd64]  http://archive.ubuntu.com/ubuntu/ impish           main restricted universe multiverse
deb [arch=amd64]  http://archive.ubuntu.com/ubuntu/ impish-updates   main restricted universe multiverse
deb [arch=amd64]  http://archive.ubuntu.com/ubuntu/ impish-backports main restricted universe multiverse</code></pre>



<p>Then update with</p>



<pre><code>sudo apt update</code></pre>



<p>Install qemu-usr and binfmt integration with</p>



<pre><code>sudo apt install qemu-user-binfmt</code></pre>



<p>And now some libs with</p>



<pre><code>sudo apt install libgtk2.0-0:i386 libgtk2.0-0:amd64 libsdl2-image-2.0-0:i386 libsdl2-image-2.0-0:amd64 libgl1:i386 libgl1:amd64 libsdl1.2debian:i386 libopenal1:i386 libsdl1.2debian:amd64 libopenal1:amd64 libvorbisfile3:i386 libvorbisfile3:amd64 -y</code></pre>



<p>QEMU doesn’t integrate a pass-thru mecanism for GL by default. So the rendering is done in software. Even worse, it’s done in emulated software, so the graphics performances are really not good with that config.</p>



<h2>FEX-emu</h2>



<p>Installation: I simply followed the instructions on the github README, as Ubuntu 21.10 is a supported OS. But first, <code>curl</code> needed to be installed with</p>



<pre><code>sudo apt install curl</code></pre>



<p>And then, from the readme:</p>



<pre><code>curl --silent https://raw.githubusercontent.com/FEX-Emu/FEX/main/Scripts/InstallFEX.py --output /tmp/InstallFEX.py &amp;&amp; python3 /tmp/InstallFEX.py &amp;&amp; rm /tmp/InstallFEX.py</code></pre>



<p>I had some binfmt service error message at the beginning of the install, but the installation continued, and, after a few questions, downloaded 930M for the rootfs. The version installed was the 2203. Despite the error messages (in red), everything installed smoothly and worked fine.</p>



<p>I didn’t need the “uname” trick to install WorldOfGoo, using `FEXBash` was enough. Also, the FEX Rootfs has most of the needed libs to run things, so while the initial download is big, there isn’t much to install after that.</p>



<h2>Box86/Box64</h2>



<p>I will follow the COMPILE.md from the github of each project to install. But I need some build tools first:</p>



<pre><code>sudo apt install git cmake -y</code></pre>



<p>Then, fetch and build box64:</p>



<pre><code>cd ~
git clone https://github.com/ptitSeb/box64
cd box64
mkdir build; cd build; cmake .. -DRPI4ARM64=1 -DCMAKE_BUILD_TYPE=RelWithDebInfo
make -j4
sudo make install</code></pre>



<p>For box86, we need some more build-tools:</p>



<pre><code>sudo apt install gcc-arm-linux-gnueabihf -y</code></pre>



<p>And fetch and build box86 with</p>



<pre><code>cd ~
git clone https://github.com/ptitSeb/box86
cd box86
mkdir build; cd build; cmake .. -DRPI4ARM64=1 -DCMAKE_BUILD_TYPE=RelWithDebInfo
make -j2
sudo make install</code></pre>



<p>Build time is a bit long on the Pi400 (I should provide precompile binary to ease the install process). Restart binfmt integration so box86 &amp; box64 will be called automatically</p>



<pre><code>sudo systemctl restart systemd-binfmt</code></pre>



<p>Now, we need to add armhf architecture and grab some libraries, for box86:</p>



<pre><code>sudo dpkg --add-architecture armhf
sudo apt update
sudo apt install libgtk2.0-0:armhf libsdl2-image-2.0-0:armhf libsdl1.2debian:armhf libopenal1:armhf libvorbisfile3:armhf libgl1:armhf libjpeg62:armhf libcurl4:armhf libasound2-plugins:armhf -y</code></pre>



<p>The setup of WorldOfGoo worked fine with the “uname” trick (although, some error message popped up on the console) and I could install both x86 and x86_64 version easily with box64. But the setup of FTL didn’t work with box64 (I guess some more work on GTK wrapping has to be done there). It did worked with box86 (so without using the uname trick).</p>



<p>To install wine, I used a 64bits version 6.0.1 from PlayOnLinux build bot. But there are many other versions of wine available now. You can also use stagging and tkg versions now with box86+box64. The installation I do lives in the “home”, with just a few shortcut in <kbd>/usr/local/bin</kbd>, but it can be done in different ways (and the shortcut are just for conveniances)</p>



<pre><code>cd ~
wget https://www.playonlinux.com/wine/binaries/phoenicis/upstream-linux-amd64/PlayOnLinux-wine-6.0.1-upstream-linux-amd64.tar.gz
mkdir wine
cd wine
tar xf ../PlayOnLinux-wine-6.0.1-upstream-linux-amd64.tar.gz
sudo ln -s $(pwd)/bin/wine /usr/local/bin/wine
sudo ln -s $(pwd)/bin/wine64 /usr/local/bin/wine64
sudo ln -s $(pwd)/bin/wineserver /usr/local/bin/wineserver
sudo ln -s $(pwd)/bin/winecfg /usr/local/bin/winecfg
sudo ln -s $(pwd)/bin/wineboot /usr/local/bin/wineboot</code></pre>



<p>After this (long) setup done, everything was working, sound included.</p>



<h2>Benchmarks</h2>



<p>Here are the results I collected.</p>



<p>Emus vs Native:</p>



<figure><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>Bench</td><td>QEMU x86</td><td>QEMU x86_64</td><td>FEX x86</td><td>FEX x86_64</td><td>Box86</td><td>Box64</td><td>Armhf</td><td>Aarch64</td></tr><tr><td>7z</td><td>691</td><td>931</td><td>1197</td><td>1486</td><td>3117</td><td>3084</td><td>6157</td><td>5787</td></tr><tr><td>dav1d 1t</td><td>10.57</td><td>11.24</td><td>21.75</td><td>27.28</td><td>49.94</td><td>49.72</td><td>170.07</td><td>185.57</td></tr><tr><td>dav1d 4t</td><td>11.47</td><td>15.65</td><td>45.31</td><td>52.67</td><td>118.97</td><td>116.64</td><td>290.99</td><td>312.23</td></tr><tr><td>glmark2</td><td>2</td><td>4</td><td>139</td><td>164</td><td>179</td><td>178</td><td>N/A</td><td>181</td></tr><tr><td>openarena</td><td>error</td><td>0.083</td><td>0.9</td><td>1.8</td><td>4.2</td><td>8.4</td><td>5.2</td><td>8.4</td></tr></tbody></table><figcaption>The bigger, the better</figcaption></figure>


		

		


<p>Here the first 3 benchs are CPU only, and show the effeciency of the translated code. The last two benchs  on the other hand are GPU limited, were in those case an emulated speed of 100% of the native speed can be achieved.</p>



<p>For the other benchs, the data are sparcer:</p>



<figure><table><thead><tr><th>Soft</th><th>QEMU</th><th>FEX</th><th>Box</th></tr></thead><tbody><tr><td>WorldOfGoo x86 (fps)</td><td>wont start</td><td>2.2</td><td>37</td></tr><tr><td>WorldOfGoo x86_64 (fps)</td><td>wont start</td><td>37</td><td>37</td></tr><tr><td>FTL x86 (fps)</td><td>N/A</td><td>32</td><td>52</td></tr><tr><td>FTL x86_64 (fps)</td><td>N/A</td><td>42</td><td>52</td></tr><tr><td>CINEBENCH r15</td><td>10</td><td>can’t run wine</td><td>54</td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><figcaption>The bigger, the better</figcaption></figure>



<p>WorldOfGoo is interesting: we can see, for the 64bits version, that it seems GPU limited, and no matter the emulator used (Box64 or FEX), you get the same speed.</p>



<h2>Box64 vs Rosetta2</h2>



<p>As a bonus, I did a small quick comparaison of Rosetta2 and Box64. For this, I will use 7zip on macOS and compare with 7zip on Asahi and Box64. The machine used for this is a MacBookPro with a M1 soc. On macOS I used a 7z version downloaded from the 7-zip.org (latest version: 21), and used <kbd>lipo</kbd> to split the arm64 and x86_64 version of 7z. On Linux, the version was only the 17 and seem to have less arm64 optimisation, so I also downloaded the 21 from the official website there too. As a consequence, the test results cannot be compared to the other tests (but I did a run on the old 7z version to see how a regular M1 compares to a Pi400)… Aso, keep in mind that there is no Hardware acceleration on Asahi for now, so the refresh of the screen and the terminal window (I wasn’t using ssh here) might use some cycles (probably explaining why the macOS bench of 7z native has a 10% higher score than the linux one). I couldn’t include FEX in the bench as it’s not compatible with the 16k page actualy used on Asahi/M1.</p>



<figure><table><tbody><tr><td></td><td>macOS Natif</td><td>macOS Rosetta2</td><td>linux Natif</td><td>linux Box64</td></tr><tr><td>7z</td><td>47239</td><td>33746</td><td>43271</td><td>24746</td></tr></tbody></table><figcaption>The bigger, the better</figcaption></figure>



<p>For reference, the older 16.02 7z binary (the same as with FEX and QEMU comparison) on the mac M1 with box64 gives me: 17942 (yeah, almost 6x faster than the Pi400), a dav1d with 1 thread 354.86 (7x faster) and with 4 threads 636.42 (5.5x faster), all this still with box64. Yeah, the M1 is quite a beast!</p>


		

		


<p>So, Rosetta2 is 71% of native speed on 7zip, while Box64 is at 57% of native speed. Taking into account that some optimisations are still to be done in the dynarec, and that none of the advanced Arm64 opcode are used on Box64, it’s not too bad.</p>





		</div><!-- .entry-content -->

	</div></div>
  </body>
</html>
