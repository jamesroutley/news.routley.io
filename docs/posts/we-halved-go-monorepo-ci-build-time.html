<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eng.uber.com/how-we-halved-go-monorepo-ci-build-time/">Original</a>
    <h1>We Halved Go Monorepo CI Build Time</h1>
    
    <div id="readability-page-1" class="page"><div>
            <!-- image -->
                                <p><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/CI-bog-post-cover-1-e1655863516128-768x195.jpg" alt="How We Halved Go Monorepo CI Build Time" title="How We Halved Go Monorepo CI Build Time"/>
                                            </p>
            
            
<p><span>Before 2021, Uber engineers would have to take quite a taxing journey to make a code change to the </span><a href="https://eng.uber.com/go-monorepo-bazel"><span>Go Monorepo</span></a><span>. First, the engineer would make their changes on a local branch and put up a code revision to our internal code review system, </span><a href="https://www.phacility.com/phabricator"><span>Phabricator</span></a><span>. Next, our infrastructure would see the request and initiate a number of validation jobs on our CI. Those jobs would run build and test validation using the Bazel<sup>™</sup></span><span> build system, check the coverage, do some other work, and report back to the user a red light (i.e., tests failed or some other issues) or green light. Next, the user, after seeing the “green light,” would get their code reviewed and then initiate a “land” request to the </span><a href="https://eng.uber.com/research/keeping-master-green-at-scale"><span>Submit Queue</span></a><span>. The queue, after receiving their request, would patch their changes on the latest HEAD of the main branch and re-run these associated builds and tests to make sure their change would be valid at the current state of the repository. If everything looked good, the changes would be pushed and the revision would be closed.</span></p>
<p><span>This sounds pretty easy, right? Make sure everything is green, reviewed, and then let the queue do the work to push your change!</span></p>
<p><span>Well… what if the change is to a fundamental and widely used library? All packages depending on the library will need to be validated, even though the change itself is only a few lines of code. This might slow down the “build and test” part. Validating this change could sometimes take several hours. Internally, we call such changes </span><i><span>big changes</span></i><span>. </span></p>


<p><span>Our CI uses </span><a href="https://github.com/bazelbuild/bazel/issues/7962#issuecomment-553042506"><span>an algorithm</span></a><span> we call Changed Targets Calculation (CTC). CTC creates a </span><a href="https://en.wikipedia.org/wiki/Merkle_tree"><span>Merkle-style tree</span></a><span>, where each node (representing each Go package) is computed from all of its source files and inputs. Using this, we can compute this tree before and after a change, and see which Go packages (Bazel targets) have been altered by the change. These targets represent both “directly” and “indirectly” changed targets, which will all need to be retested and rebuilt to validate whether the change is in fact green. Changed targets calculation at the time took about 5 minutes to run and had to be run for every single change. If a change has more than a certain number (say 10,000) of affected targets, then it is labeled a big change.</span></p>
<figure id="attachment_9593" aria-describedby="caption-attachment-9593"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-1-300x284.png" alt="" width="419" height="397" srcset="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-1-300x284.png 300w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-1-768x728.png 768w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-1-696x659.png 696w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-1-443x420.png 443w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-1.png 1025w" sizes="(max-width: 419px) 100vw, 419px"/><figcaption id="caption-attachment-9593">Figure 1: Example Changed Targets Calculation for a change to “c.go” file.</figcaption></figure>


<p><span>But one big change here and there—what’s the big deal? SubmitQueue can still validate and land other changes concurrently, right?</span></p>
<p><span>Not really… SubmitQueue has a Conflict Analyzer to decide whether a change is in conflict with other changes earlier in the queue. If there is no conflict, SubmitQueue can validate and land the change concurrently. However, when there is a change in the SubmitQueue that affects a very large portion of the repository, it will be in conflict with most other changes. Consequently, most changes that SubmitQueue receives after the big change will have to wait. SubmitQueue also speculates on the most likely outcomes of preceding changes, so the validation of a change can start (and possibly finish) before all proceeding changes in the queue have been validated. However, a change still has to wait for the validation outcome of all preceding conflicting changes in order to decide which speculation path to take. As a result, we often saw a big change blocking many changes behind it, and all those changes had finished their validation on several speculation paths.</span></p>
<figure id="attachment_9594" aria-describedby="caption-attachment-9594"><img loading="lazy" src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-2.png" alt="" width="1972" height="986" srcset="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-2.png 1972w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-2-300x150.png 300w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-2-1024x512.png 1024w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-2-768x384.png 768w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-2-1536x768.png 1536w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-2-696x348.png 696w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-2-1068x534.png 1068w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-2-1920x960.png 1920w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-2-840x420.png 840w" sizes="(max-width: 1972px) 100vw, 1972px"/><figcaption id="caption-attachment-9594">Figure 2: SubmitQueue hourly volume per hour over a 30-day span.</figcaption></figure>

<p><span>Currently, Uber engineers introduce around 50 code changes per hour to the Go Monorepo during working hours. This means if the change at the head of the queue is large enough to affect other changes and takes an hour to test, none of the other 49 changes can proceed until this change lands. Now each of these 50 engineers will wait for over an hour for their code to land.</span></p>
<p><span>So, what can we do here to fix this problem? Well, we came up with these three options:</span></p>
<ol>
<li aria-level="1"><span>Optimizing SubmitQueue</span></li>
<li aria-level="1"><span>Make sure there aren’t any “big” (slow) changes waiting in line</span></li>
<li aria-level="1"><span>Make the build and test faster</span></li>
</ol>

<h2><span>Optimizing SubmitQueue</span></h2>
<p><span>First, we optimized the Conflict Analyzer algorithm to simplify the conflicts graph, which reduced cost and latency due to a decrease of job load. Next, we worked on speeding up pushing the change to the main branch. Before CI, diffs will enter a validation stage, where the system tries to cherry-pick the change onto the current HEAD of the repository and rejects the change if there’s a conflict. Meanwhile, it would also push the cherry-picked branch to the remote to share with other actions. Finally, if everything looks good, the cherry-picked commit is pushed. This way, we minimize the effort of having to perform expensive fetch and patch.</span></p>
<p><span>These optimizations reduced our push time by around 65% and even more for overall in-queue time. This effort required a lot of research and experimentation, which we will cover more in future posts. </span></p>

<h2><span>Blocking Large Changes During Working Hours</span></h2>
<p><span>Despite all possible solutions, the lack of infrastructure features and the urgency of this issue required an easy, short-term fix. Thus, we chose the easiest to implement and fastest to deliver (delivered in days) feature option: </span><i><span>blocking large changes during working hours</span></i><span>.</span></p>
<p><span>We did this by engineering a “guard,” which would stop any change from entering the landing queue during work hours if it was considered “large”.</span></p>
<p><span>Implementation of the guard was easy, and showed immediate success in queue times; however, we received some complaints:</span></p>
<ol>
<li aria-level="1"><i><span>Wait</span></i><span>: Engineers with large and important changes do not want to have to wait until after the work day to land their changes. </span></li>
<li aria-level="1"><i><span>Time</span></i><span>: Finding a proper blackout landing window is tricky. Uber Engineering offices are distributed across the globe, meaning any hour of the day is during someone’s “working hours”. However, the load distribution is not even. So we switched to the term “peak hours” instead (i.e., block large diffs during peak hours, which are mostly US time zones).</span></li>
<li aria-level="1"><i><span>Special attention needed</span></i><span>: Large changes are also more prone to outages. If we land them outside the working hours, there would be limited resources to mitigate potential outages. To prevent this, we ended up asking engineers to get up early to deploy these changes (e.g., a Go compiler upgrade).</span></li>
</ol>
<p><span>We have added a “delayed lands” feature to support this solution, which automatically would land the diff after the peak hours. However, that wasn’t good enough.</span></p>
<p><span>We need to validate the changes faster. </span></p>


<p><span>Existing CI builds contained these main steps:</span></p>
<ul>
<li aria-level="1"><i><span>Build environment preparation</span></i></li>
<li aria-level="1"><i><span>Various build pre-checks</span></i><span>: to fail faster (e.g., dependency checks or linting checks)</span></li>
<li aria-level="1"><i><span>CTC</span></i><span>: to detect what to validate</span></li>
<li aria-level="1"><i><span>Bazel build and test</span></i><span>: the most time-consuming part of validation</span></li>
<li aria-level="1"><i><span>Results analyzer and publisher</span></i><span><span>: to report to an Engineer and related systems</span></span></li>
</ul>
<figure id="attachment_9595" aria-describedby="caption-attachment-9595"><img loading="lazy" src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-3.png" alt="" width="1999" height="613" srcset="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-3.png 1999w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-3-300x92.png 300w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-3-1024x314.png 1024w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-3-768x236.png 768w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-3-1536x471.png 1536w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-3-696x213.png 696w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-3-1068x328.png 1068w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-3-1920x589.png 1920w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-3-1370x420.png 1370w" sizes="(max-width: 1999px) 100vw, 1999px"/><figcaption id="caption-attachment-9595">Figure 3: Landing Validation time percentage breakdown P95 and P99</figcaption></figure>

<p><span>All these steps were executed in sequence. The main question was which parts we could parallelize and how.</span></p>
<p><span>As seen in the chart above, the main consumers are Bazel build/test, CTC, and resolve dependencies check. It turns out that the Resolve dependencies check is independent of CTC and Bazel builds and could be executed in parallel, which was a free win. Bazel build is dependent on CTC results so it can’t be parallelized. The main part that could be parallelized and provide the wanted results was Bazel build.</span></p>
<p><span>Because our CTC yielded a list of changed targets, why not just split these up and run them on separate machines or hosts? Well, that’s exactly what we did.</span></p>

<h2><span>Optimizing Legacy Jenkins</span></h2>
<p><span>Uber’s CI used to run on Jenkins using a </span><a href="https://plugins.jenkins.io/jenkins-multijob-plugin"><span>MultiJob</span></a><span> plugin to define a graph of Jenkins jobs that will be executed in sequence or in parallel. Even though that plugin requires a static hierarchy, with some tricks we managed to get it to act dynamically. We statically defined 50 shards and each shard was launched depending on the metadata. In the end, it looked like dynamic sharding.</span></p>
<figure id="attachment_9596" aria-describedby="caption-attachment-9596"><img loading="lazy" src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-4-scaled-e1655939104955.jpeg" alt="" width="2560" height="1337" srcset="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-4-scaled-e1655939104955.jpeg 2560w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-4-scaled-e1655939104955-300x157.jpeg 300w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-4-scaled-e1655939104955-1024x535.jpeg 1024w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-4-scaled-e1655939104955-768x401.jpeg 768w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-4-scaled-e1655939104955-1536x802.jpeg 1536w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-4-scaled-e1655939104955-2048x1070.jpeg 2048w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-4-scaled-e1655939104955-696x363.jpeg 696w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-4-scaled-e1655939104955-1068x558.jpeg 1068w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-4-scaled-e1655939104955-1920x1003.jpeg 1920w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-4-scaled-e1655939104955-804x420.jpeg 804w" sizes="(max-width: 2560px) 100vw, 2560px"/><figcaption id="caption-attachment-9596">Figure 4: Parallelized build on Jenkins.</figcaption></figure>

<p><span>Now, rather than running 10,000 targets in an hour, we could run them in ~10 minutes.</span></p>
<p><span>Unfortunately, we could not cut the time by 1/50 with 50 shards. Although we tried to distribute the same amount of changed targets to every shard, targets built on different shards may depend on the same targets. Such targets may need to be built more than once, on every shard that needs them. Imagine there is a build graph, where target </span><i><span>//a</span></i><span> depends on target </span><i><span>//b</span></i><span>, and target </span><i><span>//c</span></i><span> depends on target </span><i><span>//d</span></i><span>. If a developer changed both </span><i><span>//b</span></i><span> and </span><i><span>//d</span></i><span>, then CTC would return </span><i><span>//a</span></i><span>, </span><i><span>//b</span></i><span>, </span><i><span>//c</span></i><span>, </span><i><span>//d</span></i><span> for building and testing. In a naive sharding strategy, </span><i><span>//a</span></i><span> and </span><i><span>//c</span></i><span> may be assigned to one shard, and </span><i><span>//b</span></i><span> and </span><i><span>//d</span></i><span> to another. Because of the dependency, the sharding building</span><i><span> //a</span></i><span> and</span><i><span> //c</span></i><span> will have to build </span><i><span>//b</span></i><span> and </span><i><span>//d </span></i><span>too, causing</span><i><span> //b</span></i><span> and </span><i><span>//d</span></i><span> to be built on both shards, which is inefficient.</span></p>
<p><span>To reduce the overlap, we changed CTC to compute the </span><i><span>root targets</span></i><span>, which means no other targets in the build graph depend on them. In the above example, </span><i><span>//a</span></i><span> and </span><i><span>//c</span></i><span> are root targets. Because of the dependencies, building //a implicitly requires building </span><i><span>//b</span></i><span>, building </span><i><span>//c</span></i><span> implicitly requires building </span><i><span>//d</span></i><span>, we don’t need to explicitly build </span><i><span>//b</span></i><span> and </span><i><span>//d</span></i><span>. If we assign shards according to root targets, </span><i><span>//a</span></i><span> and </span><i><span>//b</span></i><span>, </span><i><span>//c</span></i><span> and </span><i><span>//d</span></i><span> each will be built on the same shard, reducing the duplication. </span></p>
<p><span>This change was great and allowed us to remove our guard for large changes, which made everyone happy. </span></p>
<p><span>The end result was:</span></p>
<figure id="attachment_9597" aria-describedby="caption-attachment-9597"><img loading="lazy" src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-5.png" alt="" width="1999" height="505" srcset="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-5.png 1999w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-5-300x76.png 300w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-5-1024x259.png 1024w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-5-768x194.png 768w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-5-1536x388.png 1536w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-5-696x176.png 696w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-5-1068x270.png 1068w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-5-1920x485.png 1920w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-5-1663x420.png 1663w" sizes="(max-width: 1999px) 100vw, 1999px"/><figcaption id="caption-attachment-9597">Figure 5: Improvements from enabling sharding.</figcaption></figure>

<p><span>However, to improve further we required an actual dynamic CI system, so we started looking into </span><a href="https://buildkite.com/home"><span>Buildkite</span></a><span>.</span></p>

<h2><span>Building a True Dynamic CI in Buildkite</span></h2>
<p><span>By “dynamic,” the root meaning of this improvement was that we could configure each build and its configuration at runtime. For example: If CTC didn’t yield any target changes, we could immediately skip the build/test step. If a change touched only a single target, we could run it in one “shard,” but if this number grew, we could dynamically and intelligently split the number of targets into a changing set of shards.</span></p>
<p><span>Buildkite runs each shard of each step in a separate container (i.e., separate checkout of the repo). While this reduces side effects from potential cross-contamination (environment variables, etc.), this introduces some other problems.</span></p>
<p><span>Checking out a repo with 500,000 files and a really complex history is… you guessed it… slow. The bottleneck became more about job “setup” than the actual validation of the change. Due to containerization, builds were not aware of each other and thus were doing repetitive work, without sharing a common cache. Initially, containerized Buildkite builds showed much lower P99 and P95 than non-containerized Jenkins jobs, but an increased P50 and mean, simply because of an important fact: </span><i><span>In a repo with over 10,000,000 targets, most changes are small changes.</span></i></p>
<p><span>We addressed this problem in a couple of directions:</span></p>

<h3><span>Improving Our Git to be Faster</span></h3>
<p><span>Because we run thousands of parallel builds, each of which clones the Monorepo, it quickly became a necessity for our repository-hosting backend to catch up with our usage. We then implemented our own internal plugin to replace the out-of-the-box Buildkite checkout strategy. In a nutshell, we maintain a periodically refreshed Git snapshot that can be fast downloaded atomically to the machine before the checkout happens. Each build can then refresh the index with that snapshot, rather than needing to manually checkout the repository. Eventually, only the commits after the latest cached state need to be fetched during checkout.</span></p>

<h3><span>“Stateful” CI</span></h3>
<h4><span>Persistent Container Environment</span></h4>
<p><span>Initially, we started a brand new docker container for each test shard, then tore it down when the shard finished. This means each time when a shard runs, there’s a fixed overhead, such as starting a new container, starting the Bazel server etc., and its memory state is reset. But what if we reuse the same container and keep the memory footprint? We then implemented a mechanism that starts a persistent container and only sends commands to it. The container is ID-ed by multiple variables such as Bazel version, image hash, job name, etc., to ensure that commands run on the correct container and new containers are created at the right time, such as Bazel upgrades and image updates. We noticed nearly 60% improvement in CTC run time with this approach.</span></p>

<h3><span>Host Cache</span></h3>
<p><span>To ensure the integrity of our dependency graph, we run</span> <a href="https://go.dev/ref/mod#go-mod-tidy"><i><span>go mod tidy</span></i></a><span> in each of our CI jobs. This operation downloads all the dependency module cache for our entire repo, which can be both heavy for our internal module proxy and slow for CI machines, especially for the first job that runs on the host. To address this latency, we periodically prepare a snapshot of the cache. The first job on the machine will download it and mount it to the container to share with subsequent jobs. We also enable a similar sharing mechanism for the Bazel output base and prewarm the Bazel build graph prior to running CTC.</span></p>
<p><span>Another issue we discovered was that some targets couldn’t be separated, and were extremely slow to build and test every time. No matter how many shards we initiated, these would always become a bottleneck. This was optimized primarily through the implementation of a shared remote Bazel cache.</span></p>

<h2><span>Remote Cache</span></h2>
<p><span>We talked about sharding and root target calculation to avoid building the same target on more than one shard. Unfortunately, this may not work in all cases. Imagine there is a package depended on by many root targets; these root targets may still be assigned to different shards, causing the package to be built on multiple shards. Can we do better?</span></p>
<p><span>Exploiting the fact that Bazel is an </span><a href="https://bazel.build/basics/artifact-based-builds"><span>artifact-based build system</span></a><span>, and assuming that every build is deterministic, we can simply save these build artifacts in a shared place and reuse them if the build/test has already been done before. This shared place is called the </span><i><span>remote cache</span></i><span>. Once a package is built on a shard, the resulting artifacts are uploaded to the remote cache. Before a second shard builds the package, it can check the remote cache. If the artifacts produced by that package are already available, the second shard can download and reuse them.</span></p>
<p><span>We started with an internal implementation of the remote cache based on HTTP, and then migrated to an gRPC-based remote cache hosted by Google Cloud Services (GCS). This migration stabilized the P95, from fluctuating between 40 and over 100 minutes to being consistently below 40 minutes. In 2021, we further migrated the remote cache from GCS to </span><a href="https://github.com/bazelbuild/bazel-buildfarm"><span>Buildfarm</span></a><span>, which cut down the build time by about half.</span></p>
<p><span>One thing you may have asked yourself along the way: if you’re running tests both as a CI validation step and again as a landing validation step, isn’t this redundant?</span></p>
<p><span>Yes and No.</span></p>
<figure id="attachment_9598" aria-describedby="caption-attachment-9598"><img loading="lazy" src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-6.png" alt="" width="438" height="413" srcset="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-6.png 965w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-6-300x283.png 300w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-6-768x724.png 768w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-6-696x656.png 696w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure-6-445x420.png 445w" sizes="(max-width: 438px) 100vw, 438px"/><figcaption id="caption-attachment-9598">Figure 6: Example invalidated target graph.</figcaption></figure>

<p><span>Let’s say there are two targets, </span><i><span>//A:bin</span></i><span> and </span><i><span>//B:bin</span></i><span>, which depend on a common library </span><i><span>//C:lib</span></i><span>. Imagine two separate changes, </span><i><span>diff1</span></i><span> change to A and C, and </span><i><span>diff2</span></i><span> change to B. When the changes are first authored, jobs will need to run to validate A, B, and C in </span><i><span>diff1,</span></i><span> and separately but similarly </span><i><span>diff2</span></i><span> will test B.</span></p>
<p><span>Now, consider when a user pushes </span><i><span>diff1</span></i><span> into the landing queue. Since A, B, C have already been done, rerunning this test would actually be redundant work, since we know that nothing here has changed since it was tested. Then imagine </span><i><span>diff2</span></i><span> is later pushed into the queue after </span><i><span>diff1</span></i><span> landed. Because B depends on C, but C was just updated in </span><i><span>diff1</span></i><span>, B needs to be retested with the new C to ensure this change is still valid at the HEAD of main.</span></p>
<p><span>How do we optimize this without having some shared “higher power” that knows everything that’s already been tested? We can’t, so that’s exactly what we’ll do, using a shared remote cache. Bazel caches both build artifacts and test results in the remote cache. Although a test was run a few days ago when </span><i><span>diff1</span></i><span> was created on a different machine and a different Buildkite pipeline, Bazel can check the remote cache and check whether any of the test’s dependencies have changed since then. If not, it will fetch the test result from the remote cache when we are landing </span><i><span>diff1</span></i><span>, thus avoiding running tests for </span><i><span>//A:bin</span></i><span>, </span><i><span>//B:bin</span></i><span>, and </span><i><span>//C:lib</span></i><span> again.</span></p>


<p><span>Even with a rate of 50 changes per hour, an engineer can land a change that affects the entire repository in under 15 minutes. This efficiency helps keep engineering productivity high, reduces merge conflicts from staleness, and increases morale. </span></p>
<p><span>Additionally, it helped our team focus on increasing the complexity and features of our change validation process.</span></p>
        </div></div>
  </body>
</html>
