<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pqsrc.cr.yp.to/libsecded-20220828/README.html">Original</a>
    <h1>Libsecded</h1>
    
    <div id="readability-page-1" class="page">
<pre>-rw-r--r-- 3964 <b><a href="https://pqsrc.cr.yp.to/libsecded-20220828.html">libsecded-20220828</a>/README</b> <a href="https://pqsrc.cr.yp.to/libsecded-20220828/README">raw</a><hr/>Data stored in DRAM sometimes flips bits. A study of Google servers
found that each gigabyte of DRAM flips a bit every few hours on average:
https://www.cs.toronto.edu/~bianca/papers/sigmetrics09.pdf

Servers typically protect against DRAM errors using &#34;SECDED ECC DRAM&#34;,
which is slightly more expensive than conventional DRAM. &#34;SECDED&#34; means
&#34;single error correction, double error detection&#34;. Each 64-bit chunk of
data is stored in 72 physical bits; the extra 8 bits are used for
checksums that allow any single bit flip to be automatically corrected
and any double bit flip to be detected. Operating systems report
&#34;correctable errors&#34; (&#34;CE&#34;) and &#34;uncorrectable errors&#34; (&#34;UE&#34;) to warn
system administrators to replace failing DRAM.

However, typical desktops, laptops, and smartphones use conventional
DRAM, with no protection against bit flips. Usually a bit flip doesn&#39;t
matter (would you notice a pixel occasionally changing in a movie?), but
sometimes it does matter.

libsecded is a software library aimed at programmers who would like to
reduce the risk of data corruption. The library stores an array as a
slightly longer array, using extra bits to automatically correct single
errors and detect double errors. The API is straightforward (with
lengths represented as long long, not size_t):

   secded_encode(x,&amp;xlen): encode bytes x[0...xlen-1] as bytes
   x[0...newxlen-1], changing xlen to newxlen, which is at most xlen+64

   secded_decode(x,&amp;xlen): change x[...] and xlen back to what they
   were, while correcting any single error

Notes follow on optional aspects of the API.

There&#39;s a secded_clean(x,xlen) that you can use to correct errors in
encoded data while leaving the data in encoded form. This is essentially
the same as secded_decode(x,&amp;xlen) followed by secded_encode(x,&amp;xlen),
but simpler and faster. (Periodically sweeping through encoded data to
correct errors is typically called &#34;scrubbing&#34; for SECDED ECC DRAM.)

Both secded_decode() and secded_clean() return an unsigned int, namely 0
for no errors, 1 through 255 for correctable errors, 256 through 65535
for uncorrectable errors. This lets you measure how often problems occur
and decide what action to take.

Some values of xlen are never produced by secded_encode(). For example,
xlen=120 turns into newxlen=128, xlen=121 turns into newxlen=130, and
nothing turns into newxlen=129. In case you&#39;re worried about what
happens with invalid lengths such as 129:

   * Invalid lengths are accepted by decode(), essentially as if they
     were truncated down to the next valid length, so they won&#39;t crash
     your program.

   * If you&#39;re worried about data from an untrustworthy source, you
     shouldn&#39;t think that rejecting invalid lengths is a solution. The
     source will still be able to produce arbitrary results from decode().

   * If you&#39;re trying to recognize repeated events, you shouldn&#39;t be
     merely checking for repeated _encodings_ of those events. Even
     outside the error-correction context, it&#39;s usually wrong to assume
     that only one string can decode to a particular piece of data.

   * If for some reason you want to recognize invalid lengths, one way is
     to see that decode() followed by encode() _doesn&#39;t_ produce the
     original length. You can pass a 0 pointer to decode() and encode()
     to just do length computations without touching the array. You can
     also more directly recognize the invalid lengths (1, 2, 3, 5, 9,
     17, 33, etc.) as nonzero xlen such that (xlen-1)&amp;(xlen-2) == 0.

The software is designed to work for array lengths as large as an
exabyte (2^60 bytes). However, obviously bugs for large array sizes
could have slipped past tests for smaller array sizes, and being able to
correct just one error is insufficient for large arrays. Large arrays
should be split into smaller arrays with separate error correction. For
even higher reliability, SECDED should be replaced with multiple-error
correction.
</pre>


</div>
  </body>
</html>
