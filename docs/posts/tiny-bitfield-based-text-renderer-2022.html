<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.onirom.fr/wiki/blog/25-09-2022_tiny_bitfield_based_text_renderer/">Original</a>
    <h1>Tiny bitfield based text renderer (2022)</h1>
    
    <div id="readability-page-1" class="page"><div>


<p>I have been busy doing tiny text rasterizer for a <a href="http://www.sizecoding.org/wiki/Main_Page">256 bytes Linux
intro</a> which use the Linux <a href="https://en.wikipedia.org/wiki/Linux_framebuffer">framebuffer</a>,
the idea is to draw some 1-bit letters (three big ones in my case;
a logo) with the smallest amount of <a href="https://en.wikipedia.org/wiki/X86">x86</a> code
possible.<br/></p>

<p>An easy way would be to use the <a href="https://docs.kernel.org/fb/fbcon.html">framebuffer console</a>
(fbcon) but i also needed to apply some post-process to the letters
once they are drawn thus the <a href="https://docs.kernel.org/fb/framebuffer.html">frame buffer
device</a> (/dev/fb*) was more adequate (fbcon draw on top of
/dev/fb*), the frame buffer device is quite low-level, just giving
you the minimum to manipulate graphics (no direct way to draw
rectangles etc.) so a standalone text renderer had to be
done.</p>

<p>I first wrote specific x86 code which resulted in about 69
bytes to draw a big three letters string &#34;ORZ&#34; with a custom tiny
typeface (just lines and no anti aliasing), this does not use bit
field but some fun x86 instructions gymnastics (basically
exploiting symmetry because O and R use the same parts), this first
implementation was basically a reference by which i evaluated
generic algorithms later on.</p>

<p>I then wrote many prototyping sketches with <a href="https://p5js.org/">p5js</a> which i converted to C and then
checked the compiler output with <a href="https://godbolt.org/">Godbolt</a> to get an idea of how small the
binary can get.</p>

<p>Compilers can optimize reasonably well but may have troubles
beating handwritten assembly because some space saving instructions
are never generated by <a href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection">GCC</a>,
you can also do <a href="http://www.sizecoding.org/wiki/General_Coding_Tricks">clever
instruction tricks</a> with handwritten assembly although the code
become even more tied to the platform.</p>
<p>
<h4>Result<br/></h4>
</p>
<p>The best C implementation for my use case generate about ~77
bytes of x86 code so far (a bit less if not centered and much less
~55 bytes if not scaled), i think it is quite okay, there is
perhaps still some stuff to optimize.</p>

<p>I later did a x86 handwritten conversion of my best C
algorithm, the result is <b>52 bytes of x86 code</b> so far which
is smaller than my first non generic one! I guess it was worth it.
:)<br/></p>

<p><img src="https://www.onirom.fr/wiki/blog/25-09-2022_tiny_bitfield_based_text_renderer/images/0.png"/></p>
<p>The boring result, this image can be rendered
with <b>52 bytes</b> of raw x86 code (no API uses), doing a longer
string wouldn&#39;t add much</p>


<div>
<h3>Font / Typeface</h3>

<p>Due to size constraint i stayed with a simple 3x3 <a href="https://en.wikipedia.org/wiki/Monospaced_font">monospaced font</a>
which seemed readable enough for the three letters i am focusing
with.</p>
</div>

<p>A 3x3 font also has advantages when it come to packing the
font into a 32-bit value (as a <a href="https://en.wikipedia.org/wiki/Bit_field">Bit Field</a>) since you
can pack as much as 3 letters into one value, it only use 9-bit for
a single <a href="https://en.wikipedia.org/wiki/Glyph">glyph</a>.</p>

<p>3x3 is at the edge of being readable but it is still okay for
most letters.<br/></p>

<p>The <a href="https://en.wikipedia.org/wiki/Typeface">typeface</a> is thus quite
simple and looks like this one:</p>

<p><img src="https://www.onirom.fr/wiki/blog/25-09-2022_tiny_bitfield_based_text_renderer/images/1.png"/></p>
<p>3x3 Typeface by Anders de Flon<br/></p>

<p>Anyway this later got me into looking at the tiniest typeface
to exist, it is a fun topic with some peoples doing <a href="https://github.com/Michaelangel007/nanofont3x4">readable tiny
typefaces</a> (nanofont3x4) and there is even some with <a href="https://zserge.com/posts/tiny-font/">2x3</a> although they are
barely readable at this point.</p>

<p><img src="https://www.onirom.fr/wiki/blog/25-09-2022_tiny_bitfield_based_text_renderer/images/2.png"/></p>
<p>nanofont3x4, one of the smallest readable
typeface</p>

<p>There is also some <a href="https://www.flickr.com/photos/dafalcon/5204413187">1x5?
typeface</a> which use LCD <a href="https://en.wikipedia.org/wiki/Subpixel_rendering">sub pixels</a>
which means that glyph are made of one pixel wide colored strips
which form letters and numbers on LCD monitors. (<a href="https://github.com/tangmi/really-small-font">github</a>) Also
<a href="https://advent.blinry.org/2018/17">Millitext</a>.<br/></p>

<p>Some project like <a href="https://dotsies.org/">Dotsies</a>
also replace letters by dots so the font become literally 1x5, goal
of the project is to optimize for reading, it is unreadable unless
trained for it. (here is a <a href="https://news.ycombinator.com/item?id=3602163">v2</a> tentative)
Around 6 characters could fit into a 32 bits value, this can be
quite cool to convey textual information in size limited contexts.
Dotsies can be seen as the font version of <a href="https://en.wikipedia.org/wiki/Baudot_code">Baudot code</a>.</p>
<div>
<h4>The case of stylized fonts</h4>
<p>This article focus heavily on rendering the pretty boring
typeface above but i also explored some way to render stylized
fonts without much size impact by using the wire-frame renderer
(see below) and adding a notion of line weight to do the fill
style.</p>

<p>An easy way to stylize the font would be to alter the way it
is rendered, doing it in perspective (bit like Star Wars scroll
text) or skipping some pixels for example, many <a href="https://www.pouet.net/prod.php?which=74171">bbstro in the early
90s did that</a>.</p>

<p><a href="http://marquee.revival-studios.com/blog/blog_haiku.html">Another
approach</a> is to render the text somewhere and to render it again
by reading it back but with modulation or compositing (fastest way
to <a href="https://www.pouet.net/prod.php?which=86929">render text
on DOS</a>, also because of <a href="https://en.wikipedia.org/wiki/VGA_text_mode">VGA text mode</a> and
<a href="https://wiki.osdev.org/VGA_Fonts#How_to_get_fonts.3F">VGA
fonts</a>), most obvious would be to render it again but with an
offset and dimmed, it could perhaps be applied on a per glyph
basis, the renderer could perhaps be altered as well but this may
be difficult for scalability.</p>

<p>Another approach would be to use feedback or perhaps drive it
through diffusion (Laplace or Poisson equation; basis of the
old-school fire effect as seen below), a cellular automaton or a
chaos process or a free running <a href="https://en.wikipedia.org/wiki/L-system">Lindenmayer
system</a>.</p>

<p>See also the <a href="https://twitter.com/PETSCIIWORLD">PETSCII art scene</a> for huge
amount of creative logos, found out that many of them are
stylistically impressive due to <a href="https://en.wikipedia.org/wiki/PETSCII">PETSCII</a>
constraints.<br/></p>

<p><img src="https://www.onirom.fr/wiki/blog/25-09-2022_tiny_bitfield_based_text_renderer/images/3.png"/></p>


<p><img src="https://www.onirom.fr/wiki/blog/25-09-2022_tiny_bitfield_based_text_renderer/images/4.png"/></p>


<p><img src="https://www.onirom.fr/wiki/blog/25-09-2022_tiny_bitfield_based_text_renderer/images/5.png"/></p>


<p>Many cheap decoration could also be added to beautify the logo
such as a mirror effect + watery effect through distortion of the
reflected image.</p>

<p>Doing curve rendering may be interesting although the bytes
cost might be high.<br/></p>

<p>Here is some stylized rendering example which can be done in
~256 bytes :<br/></p>

<p><img src="https://www.onirom.fr/wiki/blog/25-09-2022_tiny_bitfield_based_text_renderer/images/6.png"/><img src="https://www.onirom.fr/wiki/blog/25-09-2022_tiny_bitfield_based_text_renderer/images/7.png"/></p>
<p>rendered as pseudo 3d (cube renderer is very
small !) with diffusion process on the right (also small)<br/></p>

<p><img src="https://www.onirom.fr/wiki/blog/25-09-2022_tiny_bitfield_based_text_renderer/images/8.png"/></p>
<p>different kind of diffusion for a neon style
(also very small !)<br/></p>

<p><img src="https://www.onirom.fr/wiki/blog/25-09-2022_tiny_bitfield_based_text_renderer/images/9.png"/></p>


<p><img src="https://www.onirom.fr/wiki/blog/25-09-2022_tiny_bitfield_based_text_renderer/images/10.png"/></p>


<p><img src="https://www.onirom.fr/wiki/blog/25-09-2022_tiny_bitfield_based_text_renderer/images/11.png"/></p>
<p>easy one<br/></p>
</div>
<div>
<h3>Bit field</h3>

<p>Packing data into a <a href="https://en.wikipedia.org/wiki/Bit_field">bit field</a> (e.g. using
bits as an array where a bit represent a glyph pixel) was quite
mandatory to save space, 9-bit is required to encode a glyph since
it is a 3x3 font so ones can just use a single 32-bit value to
represent 3 glyph at a time (or a 64-bit value to represent 7 glyph
etc.), saving space.</p>

<p>Another advantage is that the data fit into a <a href="https://en.wikipedia.org/wiki/Processor_register">CPU register</a>
so there is no needs to access memory which may be quite heavy
performances wise and also space wise.</p>

<p>A string could fit into a register or a set of registers,
longer strings could be done with or without memory access, a stack
could also be used.</p>

<p>Anyway, what does a string such as &#34;ORZ&#34; packed naively into a
bit field looks like ?</p>
<p>
<h4>11-bit rows packing<br/></h4>
</p>
<p><code>11101110110 -&gt; 1910<br/></code></p>
<p><code>10101000010 -&gt; 1346<br/></code></p>
<p><code>11101000011 -&gt; 1859<br/></code></p>
</div>


<div>
<p>All of this is not limited to text rendering of course, bit
fields can be used to encode all sort of things, boolean values
(known as <a href="https://en.wikipedia.org/wiki/FLAGS_register">flags</a>),
volumetric data, tiny pixels art that you upscale on render just
like a glyph so ones can make some tiny sprites or background. I&#39;d
bet that many intros are doing this for the geometry of some
shapes, then they change colors (or even the representation so that
it is less blocky, see the fancy fonts below) with some algorithm
at runtime.</p>

<p>Another useful use case is also doing tiny textures by
sampling the bitfield instead of using the common XOR patterns you
see in small intros.</p>

<p><img src="https://www.onirom.fr/wiki/blog/25-09-2022_tiny_bitfield_based_text_renderer/images/13.png"/><img src="https://www.onirom.fr/wiki/blog/25-09-2022_tiny_bitfield_based_text_renderer/images/14.png"/></p>



<p><span id="title"><span id="prod-title"><a href="https://www.pouet.net/prod.php?which=68704">neon</a> by
Sensenstahl; not really bitfield again but could be stored into a
bitfield<br/></span></span></p>

<p>Another idea would be to render tiles and modifying the tiles
content by just modulating the bit fields or map a set of tiles
differently or do simple transforms using <a href="https://en.wikipedia.org/wiki/Bitwise_operation">bitwise
operations</a> such as mirroring, once you have a complete set of
tile operations you can combine them to compose detailed patterns /
images, ones could also animate tiles individually by switching
values in a cyclic fashion (or just modifying a palette if using
<a href="https://en.wikipedia.org/wiki/Indexed_color">indexed
color</a>), this might give all sorts of cool patterns ? This is
perhaps the way the impressive 256 bytes intro <a href="https://www.pouet.net/prod.php?which=89830">MEMS by Digimind</a>
works although just pure speculation. (didn&#39;t look at the
code)</p>

<p><img src="https://www.onirom.fr/wiki/blog/25-09-2022_tiny_bitfield_based_text_renderer/images/16.png"/></p>

<div>
<h3>Renderer : Introduction</h3>

<div>
<p>The sections below show the working <a href="https://editor.p5js.org/">p5js</a> code of &#34;generic&#34; bit field
text rasterizer, there is also some C code and x86 code. They all
basically draw the first image of this article. (&#34;ORZ&#34;)</p>

<p>Most of the code below focus on drawing 3 glyph made of 64x64
blocks, it is trivial to extend them to render more. (if you just
add a loop + put the string bit field data into an array / stack
and iterate)</p>

<p>The output code generated by GCC vary with GCC version,
compiler options (<i>-m32 -Os -fomit-frame-pointer</i>) and code so
the binary size don&#39;t tell much (approximation) except seeing there
is a potential to bring it down even more with handwritten
assembly.<br/></p>

<p>C code use a 32-bit pixels buffer.</p>

<p>The code is focused on 32-bit bit field but any size works, it
will just affect some instructions and the amount of glyph that can
be packed.<br/></p>

</div>
<p>I also avoid floating-point arithmetic (generally not
recommended for size coding) and division / multiplication
instructions as much as possible, i wanted the code to be
compatible with low complexity CPU, this include old CPU without
div / mul instructions, i also try to fit all ideas from this
context.</p>

<p>The text can be scaled easily.</p>
<h3>Renderer #1</h3>

<p>This algorithm iterate over a whole row area and rasterize the
associated bit field content.</p>

<p>There is 3 variations :</p>
<div>
<ol>
<li>with rows as three separate values (with spaces between
glyph)<br/></li>
<li>non generic variant with single 32-bit value (a row is encoded
as 11-bit values which include spaces; the last glyph block will be
missed which is okay for some set of glyph)<br/></li>
<li>with single 32-bit value (a row is encoded as 9-bit values
which does not include spaces)</li>
</ol>
<p>Modifying text height is easy but width is not so flexible
as-is unless the bit index is computed differently.</p>

<p>The second variant avoid handling the spacing with a
conditional so it is probably the smallest for this renderer
although not adapted to all strings.<br/></p>

<p>8 characters can be drawn as-is with the first method and 10
if you don&#39;t pack spaces.</p>
</div>

<p><code>function setup() {</code></p></div>
</div>

<p>They are all about 90 bytes in C with GCC 12.2, quite small
and simple:</p>

<p><img src="https://www.onirom.fr/wiki/blog/25-09-2022_tiny_bitfield_based_text_renderer/images/17.png"/></p>

<p>The code above draw each row separately, an additional loop
can be added to avoid it, example with optimization on the third
variant :</p>

<p><code>const logo = 104667903</code></p>

<p>Note how the rows spacing / glyph height is handled by
re-using the row iteration value. It handle spacing between glyph
although it is less flexible. (1px space)<br/></p>

<p>In C it compile down to ~90 bytes of x86 code (not counting
the stack push / pop for the function); ~81 bytes without space
between glyph (by removing the costly conditional).<br/></p>
<h3>Renderer #2</h3>

<p>This algorithm iterate per glyph, the text is encoded per
glyph row in the bit field, it can be quite efficient space wise
with more optimization.<br/></p>

<p><code>function setup() {</code></p>
<div>

<p>The conditional and x / y computation can be avoided by
introducing an additional loop. ~94 bytes of x86 code generated by
GCC.<br/></p>

<p>A variation of this algorithm might render the
glyph per column so the logo is encoded per column instead of per
row, this help for optimization and avoid some computation and
shrink the x86 code to ~86 bytes :<br/></p>

<p><img src="https://www.onirom.fr/wiki/blog/25-09-2022_tiny_bitfield_based_text_renderer/images/18.png"/></p>

<p>The glyph loop can be split in two loop to avoid
computation and the first loop can be a for loop which help to
shrink it to ~83 bytes of x86 code :<br/></p>

<p><img src="https://www.onirom.fr/wiki/blog/25-09-2022_tiny_bitfield_based_text_renderer/images/19.png"/></p>

<p>This can be optimized furthermore by encoding the
logo backward and using negative number as a way to avoid masking
(~77 bytes) :</p>

<p><code>int width = 960;</code></p>
<h3>x86 implementation<br/></h3>

<p>Here is a size optimized version of the C code above (adapted
for 1920xN resolution), this beat GCC output:</p>

<p><code>mov esi,4159852416 ; bit field
logo</code></p>

<p>63 bytes, this was my first try.</p>

<p>Note : <i>esp</i> point to the target buffer
in this case.</p>
<p>
<h4>Using extensions<br/></h4>
</p>
<p>Here is a 62 bytes version which use <a href="https://en.wikipedia.org/wiki/X86_Bit_manipulation_instruction_set">
BMI2 (Bit Manipulation Instruction)</a> set (<i>shlx</i>) to free
<a href="https://en.wikibooks.org/wiki/X86_Assembly/X86_Architecture#General-Purpose_Registers_(GPR)_-_16-bit_naming_conventions">
CL register</a> so it can be used to replace a loop with <a href="https://www.felixcloutier.com/x86/loop:loopcc">loop</a>
instruction, advantage is that it is also fast since it doesn&#39;t
output black values (<i>loopne</i>):</p>

<p><code>mov esi,4159852416 ; bit
field logo</code></p>
</div>
<p>Glyphs could also be rendered by taking parts of simple
operations / formulas such as bitwise operators that could be
assembled, would require a different renderer, i don&#39;t know how
tiny it could end up but might be fun to do!</p>

<p>Here is a small blocky example (consider <i>w</i> and <i>h</i>
are set to 64) :</p>

<div><p><code>  for (let y = 0; y &lt; h; y +=
1) {</code></p>
<p>Perhaps blocks could also be taken by taking
parts of an offseted sierpinsky or <a href="https://en.wikipedia.org/wiki/Munching_square">munching
square</a>.<br/></p>

<p><img src="https://www.onirom.fr/wiki/blog/25-09-2022_tiny_bitfield_based_text_renderer/images/46.png"/><img src="https://www.onirom.fr/wiki/blog/25-09-2022_tiny_bitfield_based_text_renderer/images/47.png"/><img src="https://www.onirom.fr/wiki/blog/25-09-2022_tiny_bitfield_based_text_renderer/images/48.png"/></p>
<p>result with operators : <i>+ | -</i><br/></p>

<p>Also, an interesting approach would be to use an
algorithm to generate all possible combinations of pixels (guess it
work best for <a href="https://zserge.com/posts/tiny-font/">2x3
font</a> since there is 64 possibilities only), perhaps the index
can be encoded efficiently with some scheme since you only want a
tiny subset of characters.</p>

<p>Here is some LUA code (TIC-80) which render a
scaled &#34;ORZ&#34; using the combinations / index method, the function
can be used to render all combinations for the given grid setup
(3x3 here) by calling it for all index values (c), render code is
not that different than the code shown in this article
actually...<br/></p>

<p><code>w=3 -- grid width</code></p>

<p>The interesting property is that each letters can be encoded
into 8 bits by using a tiny subset of all the combination (offset +
modulo) :</p>

<p><code>function cb(i,x,y,d,s)</code></p>
<h3>Sources<br/></h3>

<div><p>The code above are from the smallest / aggressively optimized
ones but there is other type of renderer i didn&#39;t mention which may
be all found <a href="https://editor.p5js.org/fsynthesizer/collections/w5I2ghzfw">here</a>
(warning: code might be a mess!), they tend to produce a bit
heavier x86 code.</p></div>
</div>

</div></div>
  </body>
</html>
