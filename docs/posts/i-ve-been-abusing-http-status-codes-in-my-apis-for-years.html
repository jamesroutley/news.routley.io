<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.slimjim.xyz/posts/stop-using-http-codes/">Original</a>
    <h1>I&#39;ve been abusing HTTP Status Codes in my APIs for years</h1>
    
    <div id="readability-page-1" class="page"><div>
            
    <article>
        

        <section>
            



    


<p><em>update</em>: Hacker News raises some good points. I’d like to clarify I’m not talking about a RESTful service, but rather HTTP RPC. That said, I’m basically implying a RESTful endpoint, so perhaps this is the source of my confusion. The important question then is this: Is there a distinction between a bad URL and a missing record, and if so, should you try represent it differently?</p>

<p>Got your attention? Good. That’s what got my attention too during my colleagues&#39; discussion this morning.</p>
<p>In this post I want to put forth the argument that as an <em>application</em> programmer building HTTP APIs, you should <em>never</em> touch HTTP status codes. Ever. For any reason.</p>
<p>Naturally, this argument does not apply to anyone working on actual web servers, such as nginx.</p>

<p>You have some GET HTTP resource defined, say <code>/api/v1/employees/&lt;employee_id&gt;</code>. It’s pretty simple: If you pass a valid employee ID to this service, it will return all the details the service has stored for the employee, as well as some kind of error if you don’t pass a number for the ID or if you pass an ID that doesn’t exist.</p>
<p>If your mind went straight to <code>404</code> and <code>400</code>, then this post is for you.</p>

<p>You try employee 1, fantastic, it works!</p>
<p>You try employee 100, not fantastic, it 404’d.</p>
<p><strong>Huh?</strong></p>
<p>Why do I get a 404 here? The path is clearly correct, otherwise employee 1 wouldn’t have worked either.</p>
<p>“Ah”, you may be thinking “but it <em>clearly</em> means that the employee wasn’t found!”</p>
<p>No, there’s nothing clear about that. If I were to call <code>/api/v11/employees/1</code> I would get the <strong>exact same</strong> error. As an API consumer, all I want to do here is raise my middle finger.</p>
<p>But as an API producer, this results in a conundrum: What am I supposed to do then?</p>

<p>Maybe part of my confusion is that <a href="https://www.rfc-editor.org/rfc/rfc7230">RFC 7230</a> defines HTTP as an Application Layer protocol, which means it should represent application logic, right?</p>
<p>Right?</p>
<p>Wrong.</p>
<p>HTTP is just a protocol defining behavior that belongs in layer 7. It’s not a transport layer in a technical sense, but from the perspective of an API it’s mostly just TCP with extra steps. The problem comes in when we start to use <strong>protocol</strong> errors to denote <strong>application</strong> problems.</p>
<p>HTTP status codes are used to denote the state of the <strong>HTTP</strong> transaction, and using them to denote the result of the <strong>application</strong> logic is abusing the specification.</p>
<p>You wouldn’t return a TCP error to denote you couldn’t find an employee, so why are you using HTTP errors?</p>

<p>In any API call, there are 2 problems to solve as a client when you are processing the response:</p>
<p>1: Did the technical request succeed?</p>
<p>2: Did the business/domain request succeed?</p>

<p>Networks are flakey, everyone knows that. Sometimes you lose packets, sometimes you fat finger URLs. In any scenario, application logic cannot be processed until you satisfy the technical constraints in front of it. In this instance, we’re talking about HTTP.</p>
<p>For HTTP 1/1 requests, <strong>Host</strong> is a mandatory header. Failure to provide this results in an immediate 400 from a compliant web server.</p>
<p>Further headers are required to locate a resource, such as <code>path</code> and possibly <code>method</code>.</p>
<p>If I’ve provided all of these constraints to the target service, then the HTTP transaction has succeeded (provided the server doesn’t blow up processing it, looking at you <code>NullPointerException</code>).</p>

<p>Now that the web server is happy with the incoming payload, it can correctly identify which resource to call. We’re discussing APIs, so the resource in this instance is some business/domain logic. In our example, that would be the service responsible for retrieving the employee record.</p>
<p><strong>Any</strong> business error that comes out of this layer (such as providing a letter instead of a number or an ID that doesn’t exist) is <strong>not</strong> something the web server cares about in any shape or form. <strong>Importantly</strong>, neither does the client. The HTTP client only cares about whether or not it successfully created a valid HTTP request for the server to parse.</p>
<p>You might not like where this is going, but your consumers will thank you: regardless of the business/domain outcome, return a 2xx status code.</p>

<p>Returning a 2xx code immediately tells the client that the HTTP response contains a payload that they can parse to determine the outcome of the business/domain request. That is to say</p>
<ul>
<li>client checks HTTP response is valid (2xx status)</li>
<li>client can confidently parse the response and make a <em>domain</em> oriented decision, as opposed to a techinical one</li>
</ul>
<p>This makes your client happy. Very, very happy. Using our above examples, here is what we would see:</p>
<div><h2 id="success-scenario-apiv1employees1">Success scenario: <code>/api/v1/employees/1</code><a data-clipboard-text="https://blog.slimjim.xyz/posts/stop-using-http-codes/#success-scenario-apiv1employees1" aria-label="Anchor Success scenario: &lt;code&gt;/api/v1/employees/1&lt;/code&gt;" href="#success-scenario-apiv1employees1"><svg><use xlink:href="#link"></use></svg></a></h2></div>
<p>StatusCode: 200</p>
<p>Body:</p>
<div><pre tabindex="0"><code data-lang="json"><span>{</span>
    <span>&#34;result&#34;</span><span>:</span> <span>true</span><span>,</span>
    <span>&#34;payload&#34;</span><span>:</span> <span>{</span>
        <span>&#34;id&#34;</span><span>:</span> <span>1</span><span>,</span>
        <span>&#34;name&#34;</span><span>:</span> <span>&#34;slim&#34;</span><span>,</span>
        <span>&#34;surname&#34;</span><span>:</span> <span>&#34;jim&#34;</span><span>,</span>
        <span>&#34;email:&#34;</span> <span>&#34;james@slimjim.xyz&#34;</span><span>,</span>
        <span>&#34;role&#34;</span><span>:</span> <span>&#34;chief doughnut&#34;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><div><h2 id="failed-scenario-no-such-employee-apiv1employees100">Failed scenario: No such employee <code>/api/v1/employees/100</code><a data-clipboard-text="https://blog.slimjim.xyz/posts/stop-using-http-codes/#failed-scenario-no-such-employee-apiv1employees100" aria-label="Anchor Failed scenario: No such employee &lt;code&gt;/api/v1/employees/100&lt;/code&gt;" href="#failed-scenario-no-such-employee-apiv1employees100"><svg><use xlink:href="#link"></use></svg></a></h2></div>
<p>StatusCode: 200</p>
<p>Body:</p>
<div><pre tabindex="0"><code data-lang="json"><span>{</span>
    <span>&#34;result&#34;</span><span>:</span> <span>false</span><span>,</span>
    <span>&#34;errorMessage&#34;</span><span>:</span> <span>&#34;No employee found for ID 100&#34;</span>
<span>}</span>
</code></pre></div><div><h2 id="failed-scenario-bad-path-apiv11employees1">Failed scenario: Bad path <code>/api/v11/employees/1</code><a data-clipboard-text="https://blog.slimjim.xyz/posts/stop-using-http-codes/#failed-scenario-bad-path-apiv11employees1" aria-label="Anchor Failed scenario: Bad path &lt;code&gt;/api/v11/employees/1&lt;/code&gt;" href="#failed-scenario-bad-path-apiv11employees1"><svg><use xlink:href="#link"></use></svg></a></h2></div>
<p>StatusCode: 404</p>

<p>This approach throws ambiguity straight out of the window. I can now immediately differentiate between a failure in the technical layer and a failure in the business domain.</p>
<p>My API is clean, easy to understand and easy to debug. A client no longer needs to send me a request to ask for clarity on an endpoint that sometimes returns a 200 and other times returns a 404.</p>


        </section>
    </article>

        </div></div>
  </body>
</html>
