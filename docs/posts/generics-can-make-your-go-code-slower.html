<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://planetscale.com/blog/generics-can-make-your-go-code-slower">Original</a>
    <h1>Generics can make your Go code slower</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><p><a href="https://go.dev/blog/go1.18">Go 1.18</a> is here, and with it, the first release of the long-awaited implementation of Generics is finally ready for production usage. Generics are a frequently requested feature that has been highly contentious throughout the Go community. On the one side, vocal detractors worry about the added complexity. They fear the inescapable evolution of Go towards either a verbose and Enterprisey Java-lite with Generic Factories or, most terrifyingly, a degenerate HaskellScript that replaces <code>if</code>s with Monads. In all fairness, both these fears may be overblown. On the other side, proponents of generics believe that they are a critical feature to implement clean and reusable code at scale.</p>
<p>This blog post does not take sides in that debate, or advise where and when to use Generics in Go. Instead, this blog post is about the <em>third</em> side of the generics conundrum: It’s about systems engineers who are not excited about generics <em>per se</em>, but about <em><a href="https://en.wikipedia.org/wiki/Monomorphization">monomorphization</a></em> and its performance implications. There are dozens of us! Dozens! And we’re all due for some serious disappointment.</p>
<h4>The generics implementation in 1.18</h4>
<p>There are many different ways to implement parametric polymorphism (what we usually call “generics”) in a programming language. Let us briefly discuss this problem space to understand the solution that has been implemented in Go 1.18. Since this is a blog post about Systems Engineering, we’ll make this type-theory discussion light and painless. And instead of technical terms, we’ll use the word <em>“things”</em> often.</p>
<p>Say you want to create a polymorphic function, i.e. a function that operates on different <em>things</em> indistinctly. There are, broadly speaking, two ways to go about this.</p>
<p>The first way is making all the <em>things</em> that the function will operate on look and act the same way. This approach is called “boxing”, and it usually involves allocating the <em>things</em> on the heap and just passing pointers to them to our function. Since all the <em>things</em> have the same shape (they’re pointers!), all we need to operate on them is knowing where the <em>methods</em> for those <em>things</em> live. Hence, the pointers to the <em>things</em> that are passed to our function are usually accompanied by a table of function pointers, often called a “virtual method table” or vtable for short. Does this ring a bell? This is how Go interfaces are implemented, but also <code>dyn Trait</code>s in Rust, and virtual classes in C++. These are all forms of polymorphism that are easy to use in practice but are limited by their expressiveness and by their runtime overhead.</p>
<p>The second way to make a function operate on many different <em>things</em> is called “monomorphization.” The name may sound scary, but its implementation is relatively straightforward. It boils down to creating a different copy of the function for every unique <em>thing</em> it must operate on. That’s it, really. If you have a function that adds two numbers, and you call it to add two <code>float64</code>s, the compiler creates a copy of the function and replaces the generic type placeholder with <code>float64</code>, then compiles that function. It is by far the easiest way to <em>implement</em> polymorphism (even if sometimes it becomes quite hard to use in practice) and it is also the most expensive – for the compiler.</p>
<p>Historically, monomorphization has been the design of choice for implementing Generics in systems languages such as C++, D, or Rust. There are many reasons for this, but it all boils down to trading longer compile times for <em>significant</em> performance gains in the resulting code. When you replace the type placeholders in generic code with their final types before the compiler has performed any optimization passes, you create an exciting universe of optimizations that are essentially impossible when using boxed types. At the very least, you get to de-virtualize function calls and get rid of virtual tables; in the best case scenario, you get to <em>inline</em> code, which in turn enables further optimizations. Inlining code is <em>great</em>. Monomorphization is a total win for systems programming languages: it is, essentially, the only form of polymorphism that has <em>zero</em> runtime overhead, and often it has <em>negative</em> performance overhead. It makes generic code <em>faster</em>.</p>
<p>So, as somebody who works on performance for large Go applications, I admit I was <em>not</em> particularly excited about Generics in Go, really. I was excited about monomorphization, and about the potential for the Go compiler to perform optimizations that it simply can’t do when it’s dealing with interfaces. Cue my disappointment: The Generics implementation in Go 1.18 does not use monomorphization… at least, not quite.</p>
<p>It is actually based on a partial monomorphization technique called “GCShape stenciling with Dictionaries.” The full details behind this technical choice can be found <a href="https://github.com/golang/proposal/blob/master/design/generics-implementation-dictionaries-go1.18.md">in this design document available in the upstream repository</a>. For the sake of completeness, and to guide this post’s performance analysis, I am going to give a quick summary of it:</p>
<p>The core idea is that, since fully monomorphizing every function call based on its input arguments would result in a very significant amount of code being generated, we can reduce the amount of unique function shapes by monomorphizing at a broader level than the type of the arguments. Hence, in this implementation of Generics, the Go compiler performs monomorphization (what they call “stenciling”) based on the <em>GCShape</em> of the arguments, not their type. The <em>GCShape</em> of a type is an abstract concept specific to Go and this implementation of Generics. As the design document states, <em>two concrete types are in the same gcshape grouping if and only if they have the same underlying type or they are both pointer types.</em> The first part of this definition is straightforward: if you have a method that performs, for example, arithmetic on its arguments, the Go compiler will effectively monomorphize it based on their types. The generated code for <code>uint32</code>, using integral arithmetic instructions, will be different to the code for <code>float64</code>, which will use floating point instructions. The generated code for a type-alias to <code>uint32</code>, on the other hand, will be the same as for the underlying <code>uint32</code>.</p>
<p>So far, so good. However, the second part of the <em>GCShape</em> definition has huge performance implications. Let me emphasize this: <strong>All pointers to objects belong to the same <em>GCShape</em>, regardless of the object being pointed at</strong>. This means that a <code>*time.Time</code> pointer has the same <em>GCShape</em> as an <code>*uint64</code>, a <code>*bytes.Buffer</code> and a <code>*strings.Builder</code>. This might make you wonder: <em>“Huh, so, what happens when we want to call a method on these objects? The location of such method cannot possibly be part of the GCShape!”</em>. Well, the name of the design spoils this for us: The <em>GCShapes</em> do not know about methods, so we need to talk about the <em>dictionaries</em> that accompany them.</p>
<p>In the current implementation of Generics in 1.18, every runtime invocation of a generic function will transparently receive as its first argument a static dictionary with metadata about the arguments being passed to the function. The dictionary will be placed in register <code>AX</code> for AMD64, and in the stack in platforms where the Go compiler doesn’t support register-based calling conventions yet. The full implementation details for these dictionaries are explained in depth in the aforementioned design document, but as a summary, they include all the required type metadata to pass the arguments to further generic functions, to convert them from/to interfaces, and most relevantly to us, to call methods on them. That’s right, <em>after</em> the monomorphization step, the generated function shape needs to take as a runtime input the virtual method tables for all its generic arguments. Intuitively, we can venture that while this greatly reduces that amount of unique code being generated, this kind of broad monomorphization does not lend itself to de-virtualization, to inlining, or really to any kind of performance optimization.</p>
<p>In fact, it might seem that for the vast majority of Go code, making it generic will imply making it slower. But before we start sinking into a deep pit of despair, let us run some benchmarks, look at some assembly and verify some behaviors.</p>
<h4>Interface inlining</h4>
<p><a href="https://github.com/vitessio/vitess/">Vitess</a>, the Open-Source distributed database that powers PlanetScale, is a large and complex real world Go application that serves as a great test-bed for new Go language features, particularly performance-related ones. I happen to have a long list of functions and implementations in Vitess that are currently manually monomorphized (this is a fancy way of saying <em>“copy and pasted, but with different types”</em>). Some of these functions are duplicated because their polymorphism cannot be modeled with interfaces; some others are duplicated because they are performance-critical and having them compile without interfaces provides a measurable performance gain.</p>
<p>Let’s look at a good candidate from this list: the <code>BufEncodeSQL</code> functions in the <code>sqltypes</code> package. These functions have been duplicated to take either a <code>*strings.Builder</code> or a <code>*bytes.Buffer</code> because they perform many calls to the provided buffer, and these calls <em>can</em> be inlined by the compiler if the buffer is passed as an unboxed type, as opposed to an interface. This results in meaningful performance wins in a function that is used <em>extensively</em> throughout the codebase.</p>
<p>Making this code generic is trivial, so let’s do so and compare the generic version of the function against the simple version that takes an <code>io.ByteWriter</code> as an interface.</p>

<p>There is nothing surprising <span onmouseover="asmref2(this, 0, 0, true)" onmouseout="asmref2(this, 0, 0, false)">in the assembly for the <code>io.ByteWriter</code> version</span>: <span onmouseover="asmref2(this, 0, 1, true)" onmouseout="asmref2(this, 0, 1, false)">all the calls to <code>WriteByte</code> happen through the <code>itab</code></span>. We’ll review exactly what this means in just a moment. The generic version gets much more interesting, though. The first thing we see is that the compiler has generated <span onmouseover="asmref2(this, 1, 0, true)" onmouseout="asmref2(this, 1, 0, false)">a single shape instantiation for the function (<code>BufEncodeStringSQL[go.shape.*uint8_0]</code>)</span>. Although we don’t show it on the inline view, we have to call the generic function with a <code>*strings.Builder</code> from reachable code; otherwise the compiler won’t generate any instantiations for the function at all:</p>
<pre><code><span>var</span><span> </span><span>sb</span><span> strings.Builder</span>
<span>BufEncodeStringSQL</span><span>(</span><span>&amp;</span><span>sb, []</span><span>byte</span><span>(</span><span>nil</span><span>))</span></code></pre>
<p>Since we called the function with a <code>*strings.Builder</code> as its argument, we see in the generated assembly the shape for <code>*uint8</code>. As explained earlier, all the generic calls that take a pointer-to as a generic argument are stenciled into <code>*uint8</code>, regardless of the object being pointed at. The actual properties of the object --and most importantly, its <code>itab</code>– are stored in the dictionary that is passed to the generic function.</p>
<p>This all matches what we read in the design document: the stenciling process for passing a pointer-to-struct monomorphizes the pointer into a void-like pointer. No other attributes from the pointed-at object are taken into account during monomorphization, and hence, <strong>no inlining is possible</strong>. The information on the methods for the struct that <em>could</em> be inlined is only available in the dictionary at runtime. This is already a bummer: we’ve seen that the design behind this stenciling doesn’t allow for de-virtualization of function calls, and consequently, it does not provide any inlining opportunities to the compiler. But wait, it gets worse!</p>
<p>There’s an insightful performance analysis that we can make in this chunk of code by comparing the assembly generated to call the <code>WriteByte</code> method in the interface code against the generic code.</p>
<h5>Intermission: Calling an interface method in Go</h5>
<p>Before we can compare the calls between the two versions of the code, we need a quick refresher on how interfaces are implemented in Go. We’ve briefly touched on the fact that interfaces are a form of polymorphism that involves boxing, i.e. ensuring that all objects we’re operating on have the same shape. This shape, for a Go interface, is a fat 16 byte pointer (<code>iface</code>) where the first half points to the metadata about the boxed value (what we call the <code>itab</code>), and the second half points to the value itself.</p>
<pre><code><span>type</span><span> </span><span>iface</span><span> </span><span>struct</span><span> {</span>
<span>	tab </span><span>*</span><span>itab</span>
<span>	data unsafe.Pointer</span>
<span>}</span>

<span>type</span><span> </span><span>itab</span><span> </span><span>struct</span><span> {</span>
<span>	inter </span><span>*</span><span>interfacetype </span><span>// offset 0</span>
<span>	_type </span><span>*</span><span>_type </span><span>// offset 8</span>
<span>	hash  </span><span>uint32</span><span> </span><span>// offset 16</span>
<span>	_     [</span><span>4</span><span>]</span><span>byte</span>
<span>	fun   [</span><span>1</span><span>]</span><span>uintptr</span><span> </span><span>// offset 24...</span>
<span>}</span></code></pre>
<p>The <code>itab</code> contains a lot of information about the type inside an interface. The <code>inter</code>, <code>_type</code> and <code>hash</code> fields contain all the required metadata to allow conversion between interfaces, reflection and to switch on the type of the interface. But what we care about here is the <code>fun</code> array at the end of the <code>itab</code>: although displayed as a <code>[1]uintptr</code> in the type description, this is actually a variable-length allocation. The size of the <code>itab</code> struct changes between specific interfaces, with enough space at the end of the struct to store a function pointer for every method in the interface. These function pointers are what we need to access every time we want to call a method on the interface; they are the Go equivalent to a C++ virtual table.</p>
<p>With this in mind, we can now understand the call assembly for an interface method in the non-generic implementation of our function. This is what line 8, <code>buf.WriteByte(&#39;\\&#39;)</code>, compiles into:</p>
<pre><code id="asm-iface"><p><span>0089  </span><span>MOVQ</span><span> &#34;&#34;.buf+</span><span>48</span><span>(</span><span>SP</span><span>), </span><span>CX</span>
</p><p><span>008e  </span><span>MOVQ</span><span> </span><span>24</span><span>(</span><span>CX</span><span>), </span><span>DX</span>
</p><p><span>0092  </span><span>MOVQ</span><span> &#34;&#34;.buf+</span><span>56</span><span>(</span><span>SP</span><span>), </span><span>AX</span>
</p><p><span>0097  </span><span>MOVL</span><span> $</span><span>92</span><span>, </span><span>BX</span>
</p><p><span>009c  </span><span>CALL </span><span>DX</span>
</p></code></pre>
<p>To call the <code>WriteByte</code> method on <code>buf</code>, the first thing we need is a pointer to the <code>itab</code> for <code>buf</code>. Although <code>buf</code> was originally passed into our function in a pair of registers, the compiler spilled it into the stack at the start of the function body so it can use the registers for other things. To call a method on <code>buf</code>, we first must <span onmouseover="asmref(this, 0, true)" onmouseout="asmref(this, 0, false)">load the <code>*itab</code> from the stack back into a register (<code>CX</code>)</span>. Now, we can dereference the <code>itab</code> pointer in <code>CX</code> to access its fields: <span onmouseover="asmref(this, 1, true)" onmouseout="asmref(this, 1, false)">we move the double word at offset <code>24</code> into <code>DX</code></span>, and a quick peek at the original definition of <code>itab</code> above shows that, indeed, the first function pointer in the <code>itab</code> resides at offset <code>24</code> – this all makes sense so far.</p>
<p>With <code>DX</code> containing the address of the function we want to call, we’re just missing its arguments. What Go calls a “struct-attached method” is <a href="https://en.wikipedia.org/wiki/Syntactic_sugar">sugaring</a> for a freestanding function that takes its receiver as its first argument, e.g. <code>func (b *Builder) WriteByte(x byte)</code> desugars to <code>func &#34;&#34;.(*Builder).WriteByte(b *Builder, x byte)</code>. Hence, the first argument to our function call must be <code>buf.(*iface).data</code>, the actual pointer to a <code>strings.Builder</code> that lives inside our interface. <span onmouseover="asmref(this, 2, true)" onmouseout="asmref(this, 2, false)">That pointer is available in the stack, 8 bytes after the <code>tab</code> pointer we’ve just loaded</span>. Finally, <span onmouseover="asmref(this, 3, true)" onmouseout="asmref(this, 3, false)">the second argument to our function is the literal <code>\\</code>, (ASCII 92)</span>, and we can <span onmouseover="asmref(this, 4, true)" onmouseout="asmref(this, 4, false)"><code>CALL DX</code> to execute our method</span>.</p>
<p>Phew! That’s some effort to call a simple method. Although in practical performance terms, it’s not <em>so</em> bad. Besides the fact that a call through an interface always prevents inlining, the actual overhead of a call is a single pointer dereference to load the function address from inside the <code>itab</code>. In a moment we’re going to benchmark this to see how expensive that dereference is, but first, let us look at the codegen for the generic code.</p>
<h5>Back to generics: Pointer calls</h5>
<p>We’re back to the assembly for our generic function. As a reminder, we’re analyzing the generated instantiation shape for <code>*uint8</code>, because all pointer instantiation shapes use the same void-like pointer type. Let’s see what calling the <code>WriteByte</code> method on <code>buf</code> looks like here:</p>
<pre><code id="asm-generic-ptr"><p><span>008f  </span><span>MOVQ</span><span> &#34;&#34;..dict+</span><span>48</span><span>(</span><span>SP</span><span>), </span><span>CX</span>
</p><p><span>0094  </span><span>MOVQ</span><span> </span><span>64</span><span>(</span><span>CX</span><span>), </span><span>CX</span>
</p><p><span>0098  </span><span>MOVQ</span><span> </span><span>24</span><span>(</span><span>CX</span><span>), </span><span>CX</span>
</p><p><span>009c  </span><span>MOVQ</span><span> &#34;&#34;.buf+</span><span>56</span><span>(</span><span>SP</span><span>), </span><span>AX</span>
</p><p><span>00a1  </span><span>MOVL</span><span> $</span><span>92</span><span>, </span><span>BX</span>
</p><p><span>00a6  </span><span>CALL </span><span>CX</span>
</p></code></pre>
<p>It looks quite familiar, but there’s a stark difference. Offset <code>0x0094</code> contains what we don’t want a function call-site to contain: <span onmouseover="asmref(this, 1, true)" onmouseout="asmref(this, 1, false)"><em>another</em> pointer dereference</span>. The technical term for this is, again, a total bummer. Here’s what’s going on: since we’re monomorphizing all pointer shapes into a single shape instantiation for <code>*uint8</code>, the shape doesn’t contain any information about the methods that can be called on those pointers. Where would that information live? Ideally, it would live in the <code>itab</code> associated to our pointer, but there’s no <code>itab</code> directly associated to our pointer because the shape of our function takes a single 8-byte pointer as its <code>buf</code> argument, as opposed to a 16-byte fat pointer with an <code>*itab</code> and <code>data</code> fields, like an interface would. If you recall, this is the whole reason why the stenciling implementation passes a dictionary to every generic function call: this dictionary contains pointers to the <code>itab</code>s of all the generic arguments to the function.</p>
<p>Alright, so that assembly, with the extra load, makes perfect sense now. The method call begins, instead of by loading the <code>itab</code> for our <code>buf</code>, by <span onmouseover="asmref(this, 0, true)" onmouseout="asmref(this, 0, false)">loading the dictionary that has been passed to our generic function</span> (and which has also been spilled into the stack). <span onmouseover="asmref(this, 1, true)" onmouseout="asmref(this, 1, false)">With the dictionary in <code>CX</code>, we can dereference it, and at offset 64 we find the <code>*itab</code> we were looking for</span>. Sadly, we now need <span onmouseover="asmref(this, 2, true)" onmouseout="asmref(this, 2, false)">yet another dereference (<code>24(CX)</code>)</span>, to load the function pointer from inside the <code>itab</code>. <span onmouseover="asmref(this, 3, true)" onmouseout="asmref(this, 3, false)">The rest of the method call</span> is identical to the previous codegen.</p>
<p>How bad is this extra dereference in practice? Intuitively, <strong>we can assume that calling methods on an object in a generic function will always be slower than in a non-generic function that simply takes an interface as an argument</strong>, because Generics will devolve what previously were pointer calls into a twice-indirect interface call, ostensibily slower than a plain interface call.</p>
<pre><code>name                      time/op      alloc/op     allocs/op
Monomorphized-16          5.06µs ± 1%  2.56kB ± 0%  2.00 ± 0%
Iface-16                  6.85µs ± 1%  2.59kB ± 0%  3.00 ± 0%
GenericWithPtr-16         7.18µs ± 2%  2.59kB ± 0%  3.00 ± 0%</code></pre>
<p>This simple benchmark tests the same function body with 3 slightly different implementations. <code>GenericWithPointer</code> passes a <code>*strings.Builder</code> to our <code>func Escape[W io.ByteWriter](W, []byte)</code> generic function. The <code>Iface</code> benchmark is for a <code>func Escape(io.ByteWriter, []byte)</code> that takes an interface directly. <code>Monomorphized</code> is for a manually monomorphized <code>func Escape(*strings.Builder, []byte)</code>.</p>
<p>The results are not surprising. The function that has been specialized to take a <code>*strings.Builder</code> directly is the fastest, because it allowed the compiler to inline the <code>WriteByte</code> calls inside of it. The generic function is measurably slower than the simplest possible implementation taking an <code>io.ByteWriter</code> interface as an argument. We can see that the impact of the extra load from the generic dictionary is not significant, because both the <code>itab</code> and the Generics dictionary will be very warm in cache in this micro-benchmark (however, do keep reading for an analysis of how cache contention affects Generic code).</p>
<p>This is the first insight we can gather from this analysis: <strong>there’s no incentive to convert a <em>pure</em> function that takes an interface to use Generics in 1.18</strong>. It’ll only make it slower, as the Go compiler cannot currently generate a function shape where methods are called through a pointer. Instead, it will introduce an interface call with two layers of indirection. This is going in the exact opposite direction of what we’d like, which is de-virtualization and, where possible, inlining.</p>
<p>Before we wrap up this section, let’s point out a detail in the Go compiler’s escape analysis: we can see that our monomorphized function has <code>2 allocs/op</code> in our benchmark. This is because we’re passing a pointer to a <code>strings.Builder</code> that lives in the stack, and the compiler can prove that it doesn’t escape and hence it doesn’t need to be heap allocated. The <code>Iface</code> benchmark shows <code>3 allocs/op</code> even though we’re also passing a pointer from the stack. This is because we’re moving the pointer to an interface, and that always allocates. Surprisingly, the <code>GenericWithPointer</code> implementation also shows <code>3 allocs/op</code>. Even though the generated instantiation for the function takes the pointer directly, the escape analysis can no longer prove it as non-escaping, so we get an extra heap allocation. Oh well. That is a small disappointment, but it is now time to move to bigger, better disappointments.</p>
<h5>Generic interface calls</h5>
<p>These past few sections we’ve been analyzing the codegen for our generic <code>Escape</code> function by looking at the shape generated when calling the function with a <code>*strings.Builder</code>. If you recall, the generic signature for our method was <code>func Escape[W io.ByteWriter](W, []byte)</code>, and <code>*strings.Builder</code> definitely fulfills that constraint, resulting in an instantiation shape for <code>*uint8</code>.</p>
<p>But what would happen if instead we were to hide our <code>*strings.Builder</code> behind an interface?</p>
<pre><code><span>var</span><span> </span><span>buf</span><span> strings.Builder</span>
<span>var</span><span> </span><span>i</span><span> io.ByteWriter </span><span>=</span><span> </span><span>&amp;</span><span>buf</span>
<span>BufEncodeStringSQL</span><span>(i, []</span><span>byte</span><span>(</span><span>nil</span><span>))</span></code></pre>
<p>The argument to our generic function is now an interface, instead of a pointer. And the call is clearly valid, as the interface we’re passing is identical to the constraint on our method. But what does the instantiation shape we’re generating look like? We’re not embedding the full disassembly because it gets <em>real noisy</em>, but just like we did before, let us analyze the call sites for the <code>WriteByte</code> methods in the function:</p>
<pre><code id="asm-generic-iface"><p><span>00b6  </span><span>LEAQ</span><span> type.io.ByteWriter(</span><span>SB</span><span>), </span><span>AX</span>
</p><p><span>00bd  </span><span>MOVQ</span><span> &#34;&#34;..autotmp_8+</span><span>40</span><span>(</span><span>SP</span><span>), </span><span>BX</span>
</p><p><span>00c2  </span><span>CALL runtime.assertI2I(</span><span>SB</span><span>)</span>
</p><p><span>00c7  </span><span>MOVQ</span><span> </span><span>24</span><span>(</span><span>AX</span><span>), </span><span>CX</span>
</p><p><span>00cb  </span><span>MOVQ</span><span> &#34;&#34;.buf+</span><span>80</span><span>(</span><span>SP</span><span>), </span><span>AX</span>
</p><p><span>00d0  </span><span>MOVL</span><span> $</span><span>92</span><span>, </span><span>BX</span>
</p><p><span>00d5  </span><span>CALL </span><span>CX</span>
</p></code></pre>
<p>Big yikes! Compared to our previous codegen, this does look much less familiar. We agreed (and measured) that an extra dereference on each call site was a not a good thing, so imagine how we should feel about <span onmouseover="asmref(this, 2, true)" onmouseout="asmref(this, 2, false)">a whole extra function call</span>.</p>
<p>What’s going on here? We can find the <a href="https://github.com/golang/go/blob/c6d9b38dd82fea8775f1dff9a4a70a017463035d/src/runtime/iface.go#L421-L430"><code>runtime.assertI2I</code> method</a> inside the Go runtime: it’s the helper that asserts a conversion between interfaces. It takes an <code>*interfacetype</code> and an <code>*itab</code> as its two arguments, and returns an <code>itab</code> for the given <code>interfacetype</code> <em>only if the interface in the given <code>itab</code> also implements our target interface</em>. Huh, what?</p>
<p>Say you have an interface like this:</p>
<pre><code><span>type</span><span> </span><span>IBuffer</span><span> </span><span>interface</span><span> {</span>
<span>	</span><span>Write</span><span>([]</span><span>byte</span><span>) (</span><span>int</span><span>, </span><span>error</span><span>)</span>
<span>	</span><span>WriteByte</span><span>(c </span><span>byte</span><span>) </span><span>error</span>
<span>	</span><span>Len</span><span>() </span><span>int</span>
<span>	</span><span>Cap</span><span>() </span><span>int</span>
<span>}</span></code></pre>
<p>This interface makes no mention of <code>io.ByteWriter</code> or <code>io.Writer</code>, and yet, any type that implements <code>IBuffer</code> also implements these two interfaces implicitly. This has a meaningful impact in the codegen of our generic function: since the generic constraint to our function is <code>[W io.ByteWriter]</code>, we can pass as an argument any interface that implements <code>io.ByteWriter</code> – this includes something like <code>IBuffer</code>. But when we need to call the <code>WriteByte</code> method on our argument, where in the <code>itab.fun</code> array for the interface we’ve received does this method live? We don’t know! If we pass our <code>*strings.Builder</code> as an <code>io.ByteWriter</code> interface, the <code>itab</code> in that interface will have our method at <code>fun[0]</code>. If we pass it as an <code>IBuffer</code>, it’ll be at <code>fun[1]</code>. What we need is a helper that can take the <code>itab</code> for an <code>IBuffer</code> and return an <code>itab</code> for an <code>io.ByteWriter</code>, where our <code>WriteByte</code> function pointer is always stable at <code>fun[0]</code>.</p>
<p>That’s the job of <code>assertI2I</code>, and that’s what every call site in the function is doing. Let’s break it down step by step.</p>
<pre><code id="asm-generic-iface-2"><p><span>00b6  </span><span>LEAQ</span><span> type.io.ByteWriter(</span><span>SB</span><span>), </span><span>AX</span>
</p><p><span>00bd  </span><span>MOVQ</span><span> &#34;&#34;..autotmp_8+</span><span>40</span><span>(</span><span>SP</span><span>), </span><span>BX</span>
</p><p><span>00c2  </span><span>CALL runtime.assertI2I(</span><span>SB</span><span>)</span>
</p><p><span>00c7  </span><span>MOVQ</span><span> </span><span>24</span><span>(</span><span>AX</span><span>), </span><span>CX</span>
</p><p><span>00cb  </span><span>MOVQ</span><span> &#34;&#34;.buf+</span><span>80</span><span>(</span><span>SP</span><span>), </span><span>AX</span>
</p><p><span>00d0  </span><span>MOVL</span><span> $</span><span>92</span><span>, </span><span>BX</span>
</p><p><span>00d5  </span><span>CALL </span><span>CX</span>
</p></code></pre>
<p>First, <span onmouseover="asmref(this, 0, true)" onmouseout="asmref(this, 0, false)">it loads the <code>interfacetype</code> for <code>io.ByteWriter</code> (which is a hard-coded global, since this is the interface type defined in our constraint) into <code>AX</code></span>. Then, <span onmouseover="asmref(this, 1, true)" onmouseout="asmref(this, 1, false)">it loads the actual <code>itab</code> for the interface we passed to our function into <code>BX</code></span>. These are the two arguments that <code>assertI2I</code> needs, and after <span onmouseover="asmref(this, 2, true)" onmouseout="asmref(this, 2, false)">calling it</span>, we’re left with the <code>itab</code> for <code>io.ByteWriter</code> in <code>AX</code>, and we can <span onmouseover="asmref(this, 6, true)" onmouseout="asmref(this, 6, false)">continue with our interface function call like we did in the previous codegen</span>, knowing that our function pointer is now always <span onmouseover="asmref(this, 3, true)" onmouseout="asmref(this, 3, false)">at offset <code>24</code> inside our <code>itab</code></span>. Essentially, what this shape instantiation is doing is converting every method call from <code>buf.WriteByte(ch)</code> to <code>buf.(io.ByteWriter).WriteByte(ch)</code>.</p>
<p>And yes, that looks expensive as hell. And yes, it also looks very redundant. Wouldn’t it be possible to acquire the <code>io.ByteWriter</code> <code>itab</code> just once at the start of the function and re-use it in all function calls? Ehh, not in the general case, but there are function shapes where this would be safe to do (like, for instance, the function we’re currently analyzing), since the value inside the <code>buf</code> interface never changes and we don’t need to type-switch or pass down the <code>buf</code> interface to any further functions down the stack. There’s definitely some room for optimization here in the Go compiler. Let’s look at the benchmark numbers to see how much impact would such an optimization have:</p>
<pre><code>name                      time/op      alloc/op     allocs/op
Monomorphized-16          5.06µs ± 1%  2.56kB ± 0%  2.00 ± 0%
Iface-16                  6.85µs ± 1%  2.59kB ± 0%  3.00 ± 0%
GenericWithPtr-16         7.18µs ± 2%  2.59kB ± 0%  3.00 ± 0%
GenericWithExactIface-16  9.68µs ± 2%  2.59kB ± 0%  3.00 ± 0%</code></pre>
<p>That’s not great. The overhead of the <code>assertI2I</code> call is noticeable, even in a function that does more than simply calling other functions. We’re almost twice as slow as the manually monomorphized function that calls <code>WriteByte</code> directly, and 30% slower than simply using an <code>io.ByteWriter</code> interface without generics. This is, by any definition, a performance footgun to be aware of: the same generic function, with the same argument, will be significantly slower if you pass the argument inside an interface as opposed to directly as a pointer.</p>
<p>…But wait! We’re not done here! There’s still more fascinating performance details to share, as you may have guessed from the careful naming of our benchmark cases. It turns out that our <code>GenericWithExactIface</code> benchmark is actually <em>the best possible scenario</em>, because the constraint in our function is <code>[W io.ByteWriter]</code> and we’re passing our argument as an <code>io.ByteWriter</code> interface. This means that the <code>runtime.assertI2I</code> call will return immediately with the <code>itab</code> we passed to it – because it matches the <code>itab</code> that our shape instantiation is looking for. But what if we passed our argument as the previously defined <code>IBuffer</code> interface? This should work just fine, because <code>*strings.Builder</code> implements both <code>IBuffer</code> and <code>io.ByteWriter</code>, but at runtime, every single method call inside our function will result in a <em>global hash table lookup</em> when <code>assertI2I</code> tries to acquire an <code>io.ByteWriter</code> <code>itab</code> from our <code>IBuffer</code> argument.</p>
<pre><code>name                      time/op      alloc/op     allocs/op
Monomorphized-16          5.06µs ± 1%  2.56kB ± 0%  2.00 ± 0%
Iface-16                  6.85µs ± 1%  2.59kB ± 0%  3.00 ± 0%
GenericWithPtr-16         7.18µs ± 2%  2.59kB ± 0%  3.00 ± 0%
GenericWithExactIface-16  9.68µs ± 2%  2.59kB ± 0%  3.00 ± 0%
GenericWithSuperIface-16  17.6µs ± 3%  2.59kB ± 0%  3.00 ± 0%</code></pre>
<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="100%" viewBox="0 0 654.429219 274.079688" xmlns="http://www.w3.org/2000/svg" version="1.1">
 <metadata>
  <rdf:rdf xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
   <cc:work>
    <dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage"></dc:type>
    <dc:date>2022-03-25T15:46:37.899867</dc:date>
    <dc:format>image/svg+xml</dc:format>
    <dc:creator>
     <cc:agent>
      <dc:title>Matplotlib v3.5.1, https://matplotlib.org/</dc:title>
     </cc:agent>
    </dc:creator>
   </cc:work>
  </rdf:rdf>
 </metadata>
 <defs>
  
 </defs>
 <g id="figure_1">
  <g id="patch_1">
   <path d="M 0 274.079688 
L 654.429219 274.079688 
L 654.429219 0 
L 0 0 
L 0 274.079688 
z
" style="fill: none"></path>
  </g>
  <g id="axes_1">
   <g id="patch_2">
    <path d="M 172.029219 202.32 
L 618.429219 202.32 
L 618.429219 36 
L 172.029219 36 
L 172.029219 202.32 
z
" style="fill: none"></path>
   </g>
   <g id="matplotlib.axis_1">
    <g id="xtick_1">
     <g id="line2d_1">
      <defs>
       <path id="ma757de52bf" d="M 0 0 
L 0 6 
" style="stroke: #ffffff; stroke-width: 1.25"></path>
      </defs>
      <g>
       <use xlink:href="#ma757de52bf" x="172.029219" y="202.32" style="fill: #ffffff; stroke: #ffffff; stroke-width: 1.25"></use>
      </g>
     </g>
     <g id="text_1">
      <!-- 0 -->
      <g style="fill: #ffffff" transform="translate(168.529844 220.178281)scale(0.11 -0.11)">
       <defs>
        <path id="DejaVuSans-30" d="M 2034 4250 
Q 1547 4250 1301 3770 
Q 1056 3291 1056 2328 
Q 1056 1369 1301 889 
Q 1547 409 2034 409 
Q 2525 409 2770 889 
Q 3016 1369 3016 2328 
Q 3016 3291 2770 3770 
Q 2525 4250 2034 4250 
z
M 2034 4750 
Q 2819 4750 3233 4129 
Q 3647 3509 3647 2328 
Q 3647 1150 3233 529 
Q 2819 -91 2034 -91 
Q 1250 -91 836 529 
Q 422 1150 422 2328 
Q 422 3509 836 4129 
Q 1250 4750 2034 4750 
z
" transform="scale(0.015625)"></path>
       </defs>
       <use xlink:href="#DejaVuSans-30"></use>
      </g>
     </g>
    </g>
    <g id="xtick_2">
     <g id="line2d_2">
      <g>
       <use xlink:href="#ma757de52bf" x="232.401678" y="202.32" style="fill: #ffffff; stroke: #ffffff; stroke-width: 1.25"></use>
      </g>
     </g>
     <g id="text_2">
      <!-- 2500 -->
      <g style="fill: #ffffff" transform="translate(218.404178 220.178281)scale(0.11 -0.11)">
       <defs>
        <path id="DejaVuSans-32" d="M 1228 531 
L 3431 531 
L 3431 0 
L 469 0 
L 469 531 
Q 828 903 1448 1529 
Q 2069 2156 2228 2338 
Q 2531 2678 2651 2914 
Q 2772 3150 2772 3378 
Q 2772 3750 2511 3984 
Q 2250 4219 1831 4219 
Q 1534 4219 1204 4116 
Q 875 4013 500 3803 
L 500 4441 
Q 881 4594 1212 4672 
Q 1544 4750 1819 4750 
Q 2544 4750 2975 4387 
Q 3406 4025 3406 3419 
Q 3406 3131 3298 2873 
Q 3191 2616 2906 2266 
Q 2828 2175 2409 1742 
Q 1991 1309 1228 531 
z
" transform="scale(0.015625)"></path>
        <path id="DejaVuSans-35" d="M 691 4666 
L 3169 4666 
L 3169 4134 
L 1269 4134 
L 1269 2991 
Q 1406 3038 1543 3061 
Q 1681 3084 1819 3084 
Q 2600 3084 3056 2656 
Q 3513 2228 3513 1497 
Q 3513 744 3044 326 
Q 2575 -91 1722 -91 
Q 1428 -91 1123 -41 
Q 819 9 494 109 
L 494 744 
Q 775 591 1075 516 
Q 1375 441 1709 441 
Q 2250 441 2565 725 
Q 2881 1009 2881 1497 
Q 2881 1984 2565 2268 
Q 2250 2553 1709 2553 
Q 1456 2553 1204 2497 
Q 953 2441 691 2322 
L 691 4666 
z
" transform="scale(0.015625)"></path>
       </defs>
       <use xlink:href="#DejaVuSans-32"></use>
       <use xlink:href="#DejaVuSans-35" x="63.623047"></use>
       <use xlink:href="#DejaVuSans-30" x="127.246094"></use>
       <use xlink:href="#DejaVuSans-30" x="190.869141"></use>
      </g>
     </g>
    </g>
    <g id="xtick_3">
     <g id="line2d_3">
      <g>
       <use xlink:href="#ma757de52bf" x="292.774137" y="202.32" style="fill: #ffffff; stroke: #ffffff; stroke-width: 1.25"></use>
      </g>
     </g>
     <g id="text_3">
      <!-- 5000 -->
      <g style="fill: #ffffff" transform="translate(278.776637 220.178281)scale(0.11 -0.11)">
       <use xlink:href="#DejaVuSans-35"></use>
       <use xlink:href="#DejaVuSans-30" x="63.623047"></use>
       <use xlink:href="#DejaVuSans-30" x="127.246094"></use>
       <use xlink:href="#DejaVuSans-30" x="190.869141"></use>
      </g>
     </g>
    </g>
    <g id="xtick_4">
     <g id="line2d_4">
      <g>
       <use xlink:href="#ma757de52bf" x="353.146596" y="202.32" style="fill: #ffffff; stroke: #ffffff; stroke-width: 1.25"></use>
      </g>
     </g>
     <g id="text_4">
      <!-- 7500 -->
      <g style="fill: #ffffff" transform="translate(339.149096 220.178281)scale(0.11 -0.11)">
       <defs>
        <path id="DejaVuSans-37" d="M 525 4666 
L 3525 4666 
L 3525 4397 
L 1831 0 
L 1172 0 
L 2766 4134 
L 525 4134 
L 525 4666 
z
" transform="scale(0.015625)"></path>
       </defs>
       <use xlink:href="#DejaVuSans-37"></use>
       <use xlink:href="#DejaVuSans-35" x="63.623047"></use>
       <use xlink:href="#DejaVuSans-30" x="127.246094"></use>
       <use xlink:href="#DejaVuSans-30" x="190.869141"></use>
      </g>
     </g>
    </g>
    <g id="xtick_5">
     <g id="line2d_5">
      <g>
       <use xlink:href="#ma757de52bf" x="413.519055" y="202.32" style="fill: #ffffff; stroke: #ffffff; stroke-width: 1.25"></use>
      </g>
     </g>
     <g id="text_5">
      <!-- 10000 -->
      <g style="fill: #ffffff" transform="translate(396.02218 220.178281)scale(0.11 -0.11)">
       <defs>
        <path id="DejaVuSans-31" d="M 794 531 
L 1825 531 
L 1825 4091 
L 703 3866 
L 703 4441 
L 1819 4666 
L 2450 4666 
L 2450 531 
L 3481 531 
L 3481 0 
L 794 0 
L 794 531 
z
" transform="scale(0.015625)"></path>
       </defs>
       <use xlink:href="#DejaVuSans-31"></use>
       <use xlink:href="#DejaVuSans-30" x="63.623047"></use>
       <use xlink:href="#DejaVuSans-30" x="127.246094"></use>
       <use xlink:href="#DejaVuSans-30" x="190.869141"></use>
       <use xlink:href="#DejaVuSans-30" x="254.492188"></use>
      </g>
     </g>
    </g>
    <g id="xtick_6">
     <g id="line2d_6">
      <g>
       <use xlink:href="#ma757de52bf" x="473.891514" y="202.32" style="fill: #ffffff; stroke: #ffffff; stroke-width: 1.25"></use>
      </g>
     </g>
     <g id="text_6">
      <!-- 12500 -->
      <g style="fill: #ffffff" transform="translate(456.394639 220.178281)scale(0.11 -0.11)">
       <use xlink:href="#DejaVuSans-31"></use>
       <use xlink:href="#DejaVuSans-32" x="63.623047"></use>
       <use xlink:href="#DejaVuSans-35" x="127.246094"></use>
       <use xlink:href="#DejaVuSans-30" x="190.869141"></use>
       <use xlink:href="#DejaVuSans-30" x="254.492188"></use>
      </g>
     </g>
    </g>
    <g id="xtick_7">
     <g id="line2d_7">
      <g>
       <use xlink:href="#ma757de52bf" x="534.263973" y="202.32" style="fill: #ffffff; stroke: #ffffff; stroke-width: 1.25"></use>
      </g>
     </g>
     <g id="text_7">
      <!-- 15000 -->
      <g style="fill: #ffffff" transform="translate(516.767098 220.178281)scale(0.11 -0.11)">
       <use xlink:href="#DejaVuSans-31"></use>
       <use xlink:href="#DejaVuSans-35" x="63.623047"></use>
       <use xlink:href="#DejaVuSans-30" x="127.246094"></use>
       <use xlink:href="#DejaVuSans-30" x="190.869141"></use>
       <use xlink:href="#DejaVuSans-30" x="254.492188"></use>
      </g>
     </g>
    </g>
    <g id="xtick_8">
     <g id="line2d_8">
      <g>
       <use xlink:href="#ma757de52bf" x="594.636433" y="202.32" style="fill: #ffffff; stroke: #ffffff; stroke-width: 1.25"></use>
      </g>
     </g>
     <g id="text_8">
      <!-- 17500 -->
      <g style="fill: #ffffff" transform="translate(577.139558 220.178281)scale(0.11 -0.11)">
       <use xlink:href="#DejaVuSans-31"></use>
       <use xlink:href="#DejaVuSans-37" x="63.623047"></use>
       <use xlink:href="#DejaVuSans-35" x="127.246094"></use>
       <use xlink:href="#DejaVuSans-30" x="190.869141"></use>
       <use xlink:href="#DejaVuSans-30" x="254.492188"></use>
      </g>
     </g>
    </g>
    <g id="text_9">
     <!-- ns/op -->
     <g style="fill: #ffffff" transform="translate(378.799531 235.584063)scale(0.12 -0.12)">
      <defs>
       <path id="DejaVuSans-6e" d="M 3513 2113 
L 3513 0 
L 2938 0 
L 2938 2094 
Q 2938 2591 2744 2837 
Q 2550 3084 2163 3084 
Q 1697 3084 1428 2787 
Q 1159 2491 1159 1978 
L 1159 0 
L 581 0 
L 581 3500 
L 1159 3500 
L 1159 2956 
Q 1366 3272 1645 3428 
Q 1925 3584 2291 3584 
Q 2894 3584 3203 3211 
Q 3513 2838 3513 2113 
z
" transform="scale(0.015625)"></path>
       <path id="DejaVuSans-73" d="M 2834 3397 
L 2834 2853 
Q 2591 2978 2328 3040 
Q 2066 3103 1784 3103 
Q 1356 3103 1142 2972 
Q 928 2841 928 2578 
Q 928 2378 1081 2264 
Q 1234 2150 1697 2047 
L 1894 2003 
Q 2506 1872 2764 1633 
Q 3022 1394 3022 966 
Q 3022 478 2636 193 
Q 2250 -91 1575 -91 
Q 1294 -91 989 -36 
Q 684 19 347 128 
L 347 722 
Q 666 556 975 473 
Q 1284 391 1588 391 
Q 1994 391 2212 530 
Q 2431 669 2431 922 
Q 2431 1156 2273 1281 
Q 2116 1406 1581 1522 
L 1381 1569 
Q 847 1681 609 1914 
Q 372 2147 372 2553 
Q 372 3047 722 3315 
Q 1072 3584 1716 3584 
Q 2034 3584 2315 3537 
Q 2597 3491 2834 3397 
z
" transform="scale(0.015625)"></path>
       <path id="DejaVuSans-2f" d="M 1625 4666 
L 2156 4666 
L 531 -594 
L 0 -594 
L 1625 4666 
z
" transform="scale(0.015625)"></path>
       <path id="DejaVuSans-6f" d="M 1959 3097 
Q 1497 3097 1228 2736 
Q 959 2375 959 1747 
Q 959 1119 1226 758 
Q 1494 397 1959 397 
Q 2419 397 2687 759 
Q 2956 1122 2956 1747 
Q 2956 2369 2687 2733 
Q 2419 3097 1959 3097 
z
M 1959 3584 
Q 2709 3584 3137 3096 
Q 3566 2609 3566 1747 
Q 3566 888 3137 398 
Q 2709 -91 1959 -91 
Q 1206 -91 779 398 
Q 353 888 353 1747 
Q 353 2609 779 3096 
Q 1206 3584 1959 3584 
z
" transform="scale(0.015625)"></path>
       <path id="DejaVuSans-70" d="M 1159 525 
L 1159 -1331 
L 581 -1331 
L 581 3500 
L 1159 3500 
L 1159 2969 
Q 1341 3281 1617 3432 
Q 1894 3584 2278 3584 
Q 2916 3584 3314 3078 
Q 3713 2572 3713 1747 
Q 3713 922 3314 415 
Q 2916 -91 2278 -91 
Q 1894 -91 1617 61 
Q 1341 213 1159 525 
z
M 3116 1747 
Q 3116 2381 2855 2742 
Q 2594 3103 2138 3103 
Q 1681 3103 1420 2742 
Q 1159 2381 1159 1747 
Q 1159 1113 1420 752 
Q 1681 391 2138 391 
Q 2594 391 2855 752 
Q 3116 1113 3116 1747 
z
" transform="scale(0.015625)"></path>
      </defs>
      <use xlink:href="#DejaVuSans-6e"></use>
      <use xlink:href="#DejaVuSans-73" x="63.378906"></use>
      <use xlink:href="#DejaVuSans-2f" x="115.478516"></use>
      <use xlink:href="#DejaVuSans-6f" x="149.169922"></use>
      <use xlink:href="#DejaVuSans-70" x="210.351562"></use>
     </g>
    </g>
   </g>
   <g id="matplotlib.axis_2">
    <g id="ytick_1">
     <g id="line2d_9">
      <defs>
       <path id="mf17ef798b8" d="M 0 0 
L -6 0 
" style="stroke: #ffffff; stroke-width: 1.25"></path>
      </defs>
      <g>
       <use xlink:href="#mf17ef798b8" x="172.029219" y="52.632" style="fill: #ffffff; stroke: #ffffff; stroke-width: 1.25"></use>
      </g>
     </g>
     <g id="text_10">
      <!-- Monomorphized -->
      <g style="fill: #ffffff" transform="translate(74.102969 56.811141)scale(0.11 -0.11)">
       <defs>
        <path id="DejaVuSans-4d" d="M 628 4666 
L 1569 4666 
L 2759 1491 
L 3956 4666 
L 4897 4666 
L 4897 0 
L 4281 0 
L 4281 4097 
L 3078 897 
L 2444 897 
L 1241 4097 
L 1241 0 
L 628 0 
L 628 4666 
z
" transform="scale(0.015625)"></path>
        <path id="DejaVuSans-6d" d="M 3328 2828 
Q 3544 3216 3844 3400 
Q 4144 3584 4550 3584 
Q 5097 3584 5394 3201 
Q 5691 2819 5691 2113 
L 5691 0 
L 5113 0 
L 5113 2094 
Q 5113 2597 4934 2840 
Q 4756 3084 4391 3084 
Q 3944 3084 3684 2787 
Q 3425 2491 3425 1978 
L 3425 0 
L 2847 0 
L 2847 2094 
Q 2847 2600 2669 2842 
Q 2491 3084 2119 3084 
Q 1678 3084 1418 2786 
Q 1159 2488 1159 1978 
L 1159 0 
L 581 0 
L 581 3500 
L 1159 3500 
L 1159 2956 
Q 1356 3278 1631 3431 
Q 1906 3584 2284 3584 
Q 2666 3584 2933 3390 
Q 3200 3197 3328 2828 
z
" transform="scale(0.015625)"></path>
        <path id="DejaVuSans-72" d="M 2631 2963 
Q 2534 3019 2420 3045 
Q 2306 3072 2169 3072 
Q 1681 3072 1420 2755 
Q 1159 2438 1159 1844 
L 1159 0 
L 581 0 
L 581 3500 
L 1159 3500 
L 1159 2956 
Q 1341 3275 1631 3429 
Q 1922 3584 2338 3584 
Q 2397 3584 2469 3576 
Q 2541 3569 2628 3553 
L 2631 2963 
z
" transform="scale(0.015625)"></path>
        <path id="DejaVuSans-68" d="M 3513 2113 
L 3513 0 
L 2938 0 
L 2938 2094 
Q 2938 2591 2744 2837 
Q 2550 3084 2163 3084 
Q 1697 3084 1428 2787 
Q 1159 2491 1159 1978 
L 1159 0 
L 581 0 
L 581 4863 
L 1159 4863 
L 1159 2956 
Q 1366 3272 1645 3428 
Q 1925 3584 2291 3584 
Q 2894 3584 3203 3211 
Q 3513 2838 3513 2113 
z
" transform="scale(0.015625)"></path>
        <path id="DejaVuSans-69" d="M 603 3500 
L 1178 3500 
L 1178 0 
L 603 0 
L 603 3500 
z
M 603 4863 
L 1178 4863 
L 1178 4134 
L 603 4134 
L 603 4863 
z
" transform="scale(0.015625)"></path>
        <path id="DejaVuSans-7a" d="M 353 3500 
L 3084 3500 
L 3084 2975 
L 922 459 
L 3084 459 
L 3084 0 
L 275 0 
L 275 525 
L 2438 3041 
L 353 3041 
L 353 3500 
z
" transform="scale(0.015625)"></path>
        <path id="DejaVuSans-65" d="M 3597 1894 
L 3597 1613 
L 953 1613 
Q 991 1019 1311 708 
Q 1631 397 2203 397 
Q 2534 397 2845 478 
Q 3156 559 3463 722 
L 3463 178 
Q 3153 47 2828 -22 
Q 2503 -91 2169 -91 
Q 1331 -91 842 396 
Q 353 884 353 1716 
Q 353 2575 817 3079 
Q 1281 3584 2069 3584 
Q 2775 3584 3186 3129 
Q 3597 2675 3597 1894 
z
M 3022 2063 
Q 3016 2534 2758 2815 
Q 2500 3097 2075 3097 
Q 1594 3097 1305 2825 
Q 1016 2553 972 2059 
L 3022 2063 
z
" transform="scale(0.015625)"></path>
        <path id="DejaVuSans-64" d="M 2906 2969 
L 2906 4863 
L 3481 4863 
L 3481 0 
L 2906 0 
L 2906 525 
Q 2725 213 2448 61 
Q 2172 -91 1784 -91 
Q 1150 -91 751 415 
Q 353 922 353 1747 
Q 353 2572 751 3078 
Q 1150 3584 1784 3584 
Q 2172 3584 2448 3432 
Q 2725 3281 2906 2969 
z
M 947 1747 
Q 947 1113 1208 752 
Q 1469 391 1925 391 
Q 2381 391 2643 752 
Q 2906 1113 2906 1747 
Q 2906 2381 2643 2742 
Q 2381 3103 1925 3103 
Q 1469 3103 1208 2742 
Q 947 2381 947 1747 
z
" transform="scale(0.015625)"></path>
       </defs>
       <use xlink:href="#DejaVuSans-4d"></use>
       <use xlink:href="#DejaVuSans-6f" x="86.279297"></use>
       <use xlink:href="#DejaVuSans-6e" x="147.460938"></use>
       <use xlink:href="#DejaVuSans-6f" x="210.839844"></use>
       <use xlink:href="#DejaVuSans-6d" x="272.021484"></use>
       <use xlink:href="#DejaVuSans-6f" x="369.433594"></use>
       <use xlink:href="#DejaVuSans-72" x="430.615234"></use>
       <use xlink:href="#DejaVuSans-70" x="471.728516"></use>
       <use xlink:href="#DejaVuSans-68" x="535.205078"></use>
       <use xlink:href="#DejaVuSans-69" x="598.583984"></use>
       <use xlink:href="#DejaVuSans-7a" x="626.367188"></use>
       <use xlink:href="#DejaVuSans-65" x="678.857422"></use>
       <use xlink:href="#DejaVuSans-64" x="740.380859"></use>
      </g>
     </g>
    </g>
    <g id="ytick_2">
     <g id="line2d_10">
      <g>
       <use xlink:href="#mf17ef798b8" x="172.029219" y="85.896" style="fill: #ffffff; stroke: #ffffff; stroke-width: 1.25"></use>
      </g>
     </g>
     <g id="text_11">
      <!-- Iface -->
      <g style="fill: #ffffff" transform="translate(135.854219 90.075141)scale(0.11 -0.11)">
       <defs>
        <path id="DejaVuSans-49" d="M 628 4666 
L 1259 4666 
L 1259 0 
L 628 0 
L 628 4666 
z
" transform="scale(0.015625)"></path>
        <path id="DejaVuSans-66" d="M 2375 4863 
L 2375 4384 
L 1825 4384 
Q 1516 4384 1395 4259 
Q 1275 4134 1275 3809 
L 1275 3500 
L 2222 3500 
L 2222 3053 
L 1275 3053 
L 1275 0 
L 697 0 
L 697 3053 
L 147 3053 
L 147 3500 
L 697 3500 
L 697 3744 
Q 697 4328 969 4595 
Q 1241 4863 1831 4863 
L 2375 4863 
z
" transform="scale(0.015625)"></path>
        <path id="DejaVuSans-61" d="M 2194 1759 
Q 1497 1759 1228 1600 
Q 959 1441 959 1056 
Q 959 750 1161 570 
Q 1363 391 1709 391 
Q 2188 391 2477 730 
Q 2766 1069 2766 1631 
L 2766 1759 
L 2194 1759 
z
M 3341 1997 
L 3341 0 
L 2766 0 
L 2766 531 
Q 2569 213 2275 61 
Q 1981 -91 1556 -91 
Q 1019 -91 701 211 
Q 384 513 384 1019 
Q 384 1609 779 1909 
Q 1175 2209 1959 2209 
L 2766 2209 
L 2766 2266 
Q 2766 2663 2505 2880 
Q 2244 3097 1772 3097 
Q 1472 3097 1187 3025 
Q 903 2953 641 2809 
L 641 3341 
Q 956 3463 1253 3523 
Q 1550 3584 1831 3584 
Q 2591 3584 2966 3190 
Q 3341 2797 3341 1997 
z
" transform="scale(0.015625)"></path>
        <path id="DejaVuSans-63" d="M 3122 3366 
L 3122 2828 
Q 2878 2963 2633 3030 
Q 2388 3097 2138 3097 
Q 1578 3097 1268 2742 
Q 959 2388 959 1747 
Q 959 1106 1268 751 
Q 1578 397 2138 397 
Q 2388 397 2633 464 
Q 2878 531 3122 666 
L 3122 134 
Q 2881 22 2623 -34 
Q 2366 -91 2075 -91 
Q 1284 -91 818 406 
Q 353 903 353 1747 
Q 353 2603 823 3093 
Q 1294 3584 2113 3584 
Q 2378 3584 2631 3529 
Q 2884 3475 3122 3366 
z
" transform="scale(0.015625)"></path>
       </defs>
       <use xlink:href="#DejaVuSans-49"></use>
       <use xlink:href="#DejaVuSans-66" x="29.492188"></use>
       <use xlink:href="#DejaVuSans-61" x="64.697266"></use>
       <use xlink:href="#DejaVuSans-63" x="125.976562"></use>
       <use xlink:href="#DejaVuSans-65" x="180.957031"></use>
      </g>
     </g>
    </g>
    <g id="ytick_3">
     <g id="line2d_11">
      <g>
       <use xlink:href="#mf17ef798b8" x="172.029219" y="119.16" style="fill: #ffffff; stroke: #ffffff; stroke-width: 1.25"></use>
      </g>
     </g>
     <g id="text_12">
      <!-- GenericWithPtr -->
      <g style="fill: #ffffff" transform="translate(79.43625 123.339141)scale(0.11 -0.11)">
       <defs>
        <path id="DejaVuSans-47" d="M 3809 666 
L 3809 1919 
L 2778 1919 
L 2778 2438 
L 4434 2438 
L 4434 434 
Q 4069 175 3628 42 
Q 3188 -91 2688 -91 
Q 1594 -91 976 548 
Q 359 1188 359 2328 
Q 359 3472 976 4111 
Q 1594 4750 2688 4750 
Q 3144 4750 3555 4637 
Q 3966 4525 4313 4306 
L 4313 3634 
Q 3963 3931 3569 4081 
Q 3175 4231 2741 4231 
Q 1884 4231 1454 3753 
Q 1025 3275 1025 2328 
Q 1025 1384 1454 906 
Q 1884 428 2741 428 
Q 3075 428 3337 486 
Q 3600 544 3809 666 
z
" transform="scale(0.015625)"></path>
        <path id="DejaVuSans-57" d="M 213 4666 
L 850 4666 
L 1831 722 
L 2809 4666 
L 3519 4666 
L 4500 722 
L 5478 4666 
L 6119 4666 
L 4947 0 
L 4153 0 
L 3169 4050 
L 2175 0 
L 1381 0 
L 213 4666 
z
" transform="scale(0.015625)"></path>
        <path id="DejaVuSans-74" d="M 1172 4494 
L 1172 3500 
L 2356 3500 
L 2356 3053 
L 1172 3053 
L 1172 1153 
Q 1172 725 1289 603 
Q 1406 481 1766 481 
L 2356 481 
L 2356 0 
L 1766 0 
Q 1100 0 847 248 
Q 594 497 594 1153 
L 594 3053 
L 172 3053 
L 172 3500 
L 594 3500 
L 594 4494 
L 1172 4494 
z
" transform="scale(0.015625)"></path>
        <path id="DejaVuSans-50" d="M 1259 4147 
L 1259 2394 
L 2053 2394 
Q 2494 2394 2734 2622 
Q 2975 2850 2975 3272 
Q 2975 3691 2734 3919 
Q 2494 4147 2053 4147 
L 1259 4147 
z
M 628 4666 
L 2053 4666 
Q 2838 4666 3239 4311 
Q 3641 3956 3641 3272 
Q 3641 2581 3239 2228 
Q 2838 1875 2053 1875 
L 1259 1875 
L 1259 0 
L 628 0 
L 628 4666 
z
" transform="scale(0.015625)"></path>
       </defs>
       <use xlink:href="#DejaVuSans-47"></use>
       <use xlink:href="#DejaVuSans-65" x="77.490234"></use>
       <use xlink:href="#DejaVuSans-6e" x="139.013672"></use>
       <use xlink:href="#DejaVuSans-65" x="202.392578"></use>
       <use xlink:href="#DejaVuSans-72" x="263.916016"></use>
       <use xlink:href="#DejaVuSans-69" x="305.029297"></use>
       <use xlink:href="#DejaVuSans-63" x="332.8125"></use>
       <use xlink:href="#DejaVuSans-57" x="387.792969"></use>
       <use xlink:href="#DejaVuSans-69" x="484.419922"></use>
       <use xlink:href="#DejaVuSans-74" x="512.203125"></use>
       <use xlink:href="#DejaVuSans-68" x="551.412109"></use>
       <use xlink:href="#DejaVuSans-50" x="614.791016"></use>
       <use xlink:href="#DejaVuSans-74" x="675.09375"></use>
       <use xlink:href="#DejaVuSans-72" x="714.302734"></use>
      </g>
     </g>
    </g>
    <g id="ytick_4">
     <g id="line2d_12">
      <g>
       <use xlink:href="#mf17ef798b8" x="172.029219" y="152.424" style="fill: #ffffff; stroke: #ffffff; stroke-width: 1.25"></use>
      </g>
     </g>
     <g id="text_13">
      <!-- GenericWithExactIface -->
      <g style="fill: #ffffff" transform="translate(37.665469 156.603141)scale(0.11 -0.11)">
       <defs>
        <path id="DejaVuSans-45" d="M 628 4666 
L 3578 4666 
L 3578 4134 
L 1259 4134 
L 1259 2753 
L 3481 2753 
L 3481 2222 
L 1259 2222 
L 1259 531 
L 3634 531 
L 3634 0 
L 628 0 
L 628 4666 
z
" transform="scale(0.015625)"></path>
        <path id="DejaVuSans-78" d="M 3513 3500 
L 2247 1797 
L 3578 0 
L 2900 0 
L 1881 1375 
L 863 0 
L 184 0 
L 1544 1831 
L 300 3500 
L 978 3500 
L 1906 2253 
L 2834 3500 
L 3513 3500 
z
" transform="scale(0.015625)"></path>
       </defs>
       <use xlink:href="#DejaVuSans-47"></use>
       <use xlink:href="#DejaVuSans-65" x="77.490234"></use>
       <use xlink:href="#DejaVuSans-6e" x="139.013672"></use>
       <use xlink:href="#DejaVuSans-65" x="202.392578"></use>
       <use xlink:href="#DejaVuSans-72" x="263.916016"></use>
       <use xlink:href="#DejaVuSans-69" x="305.029297"></use>
       <use xlink:href="#DejaVuSans-63" x="332.8125"></use>
       <use xlink:href="#DejaVuSans-57" x="387.792969"></use>
       <use xlink:href="#DejaVuSans-69" x="484.419922"></use>
       <use xlink:href="#DejaVuSans-74" x="512.203125"></use>
       <use xlink:href="#DejaVuSans-68" x="551.412109"></use>
       <use xlink:href="#DejaVuSans-45" x="614.791016"></use>
       <use xlink:href="#DejaVuSans-78" x="677.974609"></use>
       <use xlink:href="#DejaVuSans-61" x="737.154297"></use>
       <use xlink:href="#DejaVuSans-63" x="798.433594"></use>
       <use xlink:href="#DejaVuSans-74" x="853.414062"></use>
       <use xlink:href="#DejaVuSans-49" x="892.623047"></use>
       <use xlink:href="#DejaVuSans-66" x="922.115234"></use>
       <use xlink:href="#DejaVuSans-61" x="957.320312"></use>
       <use xlink:href="#DejaVuSans-63" x="1018.599609"></use>
       <use xlink:href="#DejaVuSans-65" x="1073.580078"></use>
      </g>
     </g>
    </g>
    <g id="ytick_5">
     <g id="line2d_13">
      <g>
       <use xlink:href="#mf17ef798b8" x="172.029219" y="185.688" style="fill: #ffffff; stroke: #ffffff; stroke-width: 1.25"></use>
      </g>
     </g>
     <g id="text_14">
      <!-- GenericWithSuperIface -->
      <g style="fill: #ffffff" transform="translate(36 189.867141)scale(0.11 -0.11)">
       <defs>
        <path id="DejaVuSans-53" d="M 3425 4513 
L 3425 3897 
Q 3066 4069 2747 4153 
Q 2428 4238 2131 4238 
Q 1616 4238 1336 4038 
Q 1056 3838 1056 3469 
Q 1056 3159 1242 3001 
Q 1428 2844 1947 2747 
L 2328 2669 
Q 3034 2534 3370 2195 
Q 3706 1856 3706 1288 
Q 3706 609 3251 259 
Q 2797 -91 1919 -91 
Q 1588 -91 1214 -16 
Q 841 59 441 206 
L 441 856 
Q 825 641 1194 531 
Q 1563 422 1919 422 
Q 2459 422 2753 634 
Q 3047 847 3047 1241 
Q 3047 1584 2836 1778 
Q 2625 1972 2144 2069 
L 1759 2144 
Q 1053 2284 737 2584 
Q 422 2884 422 3419 
Q 422 4038 858 4394 
Q 1294 4750 2059 4750 
Q 2388 4750 2728 4690 
Q 3069 4631 3425 4513 
z
" transform="scale(0.015625)"></path>
        <path id="DejaVuSans-75" d="M 544 1381 
L 544 3500 
L 1119 3500 
L 1119 1403 
Q 1119 906 1312 657 
Q 1506 409 1894 409 
Q 2359 409 2629 706 
Q 2900 1003 2900 1516 
L 2900 3500 
L 3475 3500 
L 3475 0 
L 2900 0 
L 2900 538 
Q 2691 219 2414 64 
Q 2138 -91 1772 -91 
Q 1169 -91 856 284 
Q 544 659 544 1381 
z
M 1991 3584 
L 1991 3584 
z
" transform="scale(0.015625)"></path>
       </defs>
       <use xlink:href="#DejaVuSans-47"></use>
       <use xlink:href="#DejaVuSans-65" x="77.490234"></use>
       <use xlink:href="#DejaVuSans-6e" x="139.013672"></use>
       <use xlink:href="#DejaVuSans-65" x="202.392578"></use>
       <use xlink:href="#DejaVuSans-72" x="263.916016"></use>
       <use xlink:href="#DejaVuSans-69" x="305.029297"></use>
       <use xlink:href="#DejaVuSans-63" x="332.8125"></use>
       <use xlink:href="#DejaVuSans-57" x="387.792969"></use>
       <use xlink:href="#DejaVuSans-69" x="484.419922"></use>
       <use xlink:href="#DejaVuSans-74" x="512.203125"></use>
       <use xlink:href="#DejaVuSans-68" x="551.412109"></use>
       <use xlink:href="#DejaVuSans-53" x="614.791016"></use>
       <use xlink:href="#DejaVuSans-75" x="678.267578"></use>
       <use xlink:href="#DejaVuSans-70" x="741.646484"></use>
       <use xlink:href="#DejaVuSans-65" x="805.123047"></use>
       <use xlink:href="#DejaVuSans-72" x="866.646484"></use>
       <use xlink:href="#DejaVuSans-49" x="907.759766"></use>
       <use xlink:href="#DejaVuSans-66" x="937.251953"></use>
       <use xlink:href="#DejaVuSans-61" x="972.457031"></use>
       <use xlink:href="#DejaVuSans-63" x="1033.736328"></use>
       <use xlink:href="#DejaVuSans-65" x="1088.716797"></use>
      </g>
     </g>
    </g>
   </g>
   <g id="patch_3">
    <path d="M 172.029219 39.3264 
L 294.247225 39.3264 
L 294.247225 65.9376 
L 172.029219 65.9376 
z
" clip-path="url(#pd8b32db46a)" style="fill: #5875a4; stroke: #ffffff; stroke-linejoin: miter"></path>
   </g>
   <g id="patch_4">
    <path d="M 172.029219 72.5904 
L 337.522204 72.5904 
L 337.522204 99.2016 
L 172.029219 99.2016 
z
" clip-path="url(#pd8b32db46a)" style="fill: #cc8963; stroke: #ffffff; stroke-linejoin: miter"></path>
   </g>
   <g id="patch_5">
    <path d="M 172.029219 105.8544 
L 345.394772 105.8544 
L 345.394772 132.4656 
L 172.029219 132.4656 
z
" clip-path="url(#pd8b32db46a)" style="fill: #5f9e6e; stroke: #ffffff; stroke-linejoin: miter"></path>
   </g>
   <g id="patch_6">
    <path d="M 172.029219 139.1184 
L 405.718934 139.1184 
L 405.718934 165.7296 
L 172.029219 165.7296 
z
" clip-path="url(#pd8b32db46a)" style="fill: #b55d60; stroke: #ffffff; stroke-linejoin: miter"></path>
   </g>
   <g id="patch_7">
    <path d="M 172.029219 172.3824 
L 597.172076 172.3824 
L 597.172076 198.9936 
L 172.029219 198.9936 
z
" clip-path="url(#pd8b32db46a)" style="fill: #857aab; stroke: #ffffff; stroke-linejoin: miter"></path>
   </g>
   <g id="line2d_14">
    <path clip-path="url(#pd8b32db46a)" style="fill: none; stroke: #424242; stroke-width: 2.7; stroke-linecap: round"></path>
   </g>
   <g id="line2d_15">
    <path clip-path="url(#pd8b32db46a)" style="fill: none; stroke: #424242; stroke-width: 2.7; stroke-linecap: round"></path>
   </g>
   <g id="line2d_16">
    <path clip-path="url(#pd8b32db46a)" style="fill: none; stroke: #424242; stroke-width: 2.7; stroke-linecap: round"></path>
   </g>
   <g id="line2d_17">
    <path clip-path="url(#pd8b32db46a)" style="fill: none; stroke: #424242; stroke-width: 2.7; stroke-linecap: round"></path>
   </g>
   <g id="line2d_18">
    <path clip-path="url(#pd8b32db46a)" style="fill: none; stroke: #424242; stroke-width: 2.7; stroke-linecap: round"></path>
   </g>
   <g id="patch_8">
    <path d="M 172.029219 202.32 
L 172.029219 36 
" style="fill: none; stroke: #ffffff; stroke-width: 1.25; stroke-linejoin: miter; stroke-linecap: square"></path>
   </g>
   <g id="patch_9">
    <path d="M 618.429219 202.32 
L 618.429219 36 
" style="fill: none; stroke: #ffffff; stroke-width: 1.25; stroke-linejoin: miter; stroke-linecap: square"></path>
   </g>
   <g id="patch_10">
    <path d="M 172.029219 202.32 
L 618.429219 202.32 
" style="fill: none; stroke: #ffffff; stroke-width: 1.25; stroke-linejoin: miter; stroke-linecap: square"></path>
   </g>
   <g id="patch_11">
    <path d="M 172.029219 36 
L 618.429219 36 
" style="fill: none; stroke: #ffffff; stroke-width: 1.25; stroke-linejoin: miter; stroke-linecap: square"></path>
   </g>
  </g>
 </g>
 <defs>
  <clipPath id="pd8b32db46a">
   <rect x="172.029219" y="36" width="446.4" height="166.32"></rect>
  </clipPath>
 </defs>
</svg>
<p>Haha, awesome. This is a very cool insight. We’ve upgraded from a performance footgun to a footcannon, and this all depends on whether the interface you’re passing to a generic function matches exactly its constraint or is a super-set of the constraint. This is possibly the most salient point of this analysis: <strong>passing interfaces to a generic function in Go is never a good idea</strong>. In the best case scenario, if your interface matches exactly the constraint, you’re going to see significant overhead from every method call on your types. In the likely case where your interface is a superset of the constraint, every single method call will have to be resolved dynamically from a hash table, and no caching has been implemented for this functionality.</p>
<p>Before we wrap up this section, here’s something extremely important to take into account when figuring out whether the overhead of Go Generics is suitable for your use case: <strong>the numbers shown in this benchmark are best-case values, particularly for interface calls</strong>, and not representative of the overhead a function call would have in a real world application. These micro-benchmarks are being ran on a vacuum, where the <code>itab</code> and dictionaries for the generic function are always warm in cache, and the global <code>itabTable</code> that enables <code>assertI2I</code> is <em>empty and uncontended</em>. In an actual production service there is cache contention, and the global <code>itabTable</code> can contain from hundreds to <em>millions</em> of entries, depending on how long your service has been running and the amount of unique type/interface pairs in your compiled code. <strong>This means that Generic method call overhead in your Go programs will degrade with the complexity of your codebase</strong>. This is nothing new, as the degradation actually affects all interface checks in a Go program, but these interface checks are usually not performed in tight loops like function calls can be.</p>
<p>Is there any way to benchmark this degradation in a synthetic environment? There is, but it’s not very scientific. You can pollute the global <code>itabTable</code> with entries and continuously trash the L2 CPU cache from a separate Goroutine. This approach can arbitrarily increase the method call overhead on any generic code being benchmarked, but it’s really hard to create a contention pattern in the <code>itabTable</code> that accurately matches what we’d see in a live production service, so the measured overheads are hard to translate into more realistic environments.</p>
<p>Nonetheless, the behavior observed in these benchmarks is still quite interesting. This is the result of a micro-benchmark measuring the method call overhead (in nanoseconds per call) for the different possible method call codegens in Go 1.18. The method being tested has a non-inlined empty body, so this is strictly measuring the call overhead. The benchmark is run three times: in a vacuum, with continuous thrashing of the L2 cache, and with thrashing and a greatly enlarged global <code>itabTable</code> that contains collisions for the <code>itab</code> we’re looking for.</p>
<p><img src="https://cdn.sanity.io/images/f1avhira/production/f3132352619c9385114207578eed2a853c2b168e-624x274.svg?w=450" alt="image"/></p>
<p>We can see that the method call overhead in a vacuum scales similarly to what we saw in our Escape benchmarks. The interesting behavior happens when we add contention: as we’d expect, the performance of non-generic method calls is not affected by contending for the L2 cache, while there is a small increase in the overhead of <em>all</em> generic code (even the one that doesn’t access the global <code>itabTable</code> – most likely because of the larger runtime dictionaries that must be accessed for <em>all</em> Generic method calls). The truly disastrous combination happens when we increase the size of of the <code>itabTable</code> together with the L2 cache trashing: it introduces a massive amount of overhead behind every method call, because the global <code>itabTable</code> is too large to fit in cache, and the relevant entries are no longer warm. Again, the exact amount of overhead cannot be meaningfully discerned from this micro-benchmark. It depends on the complexity and load of your Go application in production. The important take-away from this experiment is that this spooky action-at-a-distance exists in Generic Go code, so be careful about it, and measure for your use case.</p>
<h4>Byte sequences</h4>
<p>There’s a very common and recurring pattern in Go codebases, which can even be seen throughout the standard library, where a function that takes a <code>[]byte</code> slice as its argument will also have an identical equivalent that takes an <code>string</code> instead.</p>
<p>We can find this pattern all over the place (e.g. <code>(*Buffer).Write</code> vs <code>(*Buffer).WriteString</code>), but the <code>encoding/utf8</code> package really is a shining example of where this starts becoming an issue: roughly 50% of its API surface are duplicated methods that have been manually monomorphized to support both <code>[]byte</code> and <code>string</code>.</p>
<table>
<thead>
<tr>
<th>Bytes</th>
<th>String</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>DecodeLastRune</code></td>
<td><code>DecodeLastRuneInString</code></td>
</tr>
<tr>
<td><code>DecodeRune</code></td>
<td><code>DecodeRuneInString</code></td>
</tr>
<tr>
<td><code>FullRune</code></td>
<td><code>FullRuneInString</code></td>
</tr>
<tr>
<td><code>RuneCount</code></td>
<td><code>RuneCountInString</code></td>
</tr>
<tr>
<td><code>Valid</code></td>
<td><code>ValidString</code></td>
</tr>
</tbody>
</table>
<p>It’s worth pointing out that this duplication is, in fact, a performance optimization: the API could very well provide only <code>[]byte</code> functions to operate on UTF8 data, forcing the users to convert their <code>string</code> inputs to <code>[]byte</code> before calling into the package. This would not be particularly un-ergonomic, but it would be <em>very expensive</em>. Since byte slices in Go are mutable and <code>string</code>s are not, converting between them in either direction always forces an allocation.</p>
<p>This significant amount of code duplication sure looks like a juicy target for Generics, but since the code was duplicated in the first place to prevent extra allocations, before we attempt to unify the implementations we must ensure that the generated shape instantiations behave as we’d expect them to do.</p>
<p>Let’s compare two different versions of the <code>Valid</code> function: the original one in <code>encoding/utf8</code> that takes a <code>[]byte</code> as its input, and a new, generic one which is constrained with a <code>byteseq</code>, a very simple constraint of <code>string | []byte</code> which should allow us to use the two argument types interchangeably.</p>

<p>Before we look at the shape for our new generic function, there’s a few optimization details in the non-Generic codegen which we ought to review, so we can verify they survive the generic instantiation process. We can see two nice optimizations and another not-so-good one: First, the <a href="https://go.googlesource.com/proposal/+/refs/changes/78/248178/1/design/40724-register-calling.md">register-based Go calling convention</a> introduced in 1.16 behaves nicely here with our <code>[]byte</code> argument. Instead of being pushed to the stack, the 24 bytes of the slice header that this function receives are passed individually as 3 pointers in 3 registers: the <code>*byte</code> pointer for the slice resides in <code>AX</code> throughout the function body and its length resides in <code>BX</code>, and they never spill. We can see <span onmouseover="asmref2(this, 0, 0, true)" onmouseout="asmref2(this, 0, 0, false)">relatively complex expressions such as <code>len(p) &gt;= 8</code> compile into <code>CMPQ BX, $8</code></span> because of this efficient register usage. Likewise, <span onmouseover="asmref2(this, 0, 1, true)" onmouseout="asmref2(this, 0, 1, false)">the 32/64 bit load from <code>p</code> is properly optimized into a <code>MOVL</code> + <code>ORL</code> from <code>AX</code></span>.</p>
<p>The only irksome detail in this compiled function happens in the main <code>for</code> loop: <span onmouseover="asmref2(this, 0, 4, true)" onmouseout="asmref2(this, 0, 4, false)">the <code>pi := p[i]</code> load in line <code>19</code></span> has a bounds check that should have been made superfluous by <span onmouseover="asmref2(this, 0, 3, true)" onmouseout="asmref2(this, 0, 3, false)">the <code>i &lt; n</code> check in the loop header just above</span>. We can see in the generated assembly that we’re actually chaining two jumps one after the other: a <code>JGE</code> (which is a <em>signed</em> comparison instruction) and a <code>JAE</code> (which is an <em>unsigned</em> comparison instruction). This is an insidious problem, arising from the fact that the return value of <code>len</code> in Go is signed, and probably worth its own blog post.</p>
<p>Either way, the non-Generic codegen for this <code>Valid</code> function is looking quite good overall. Let’s compare it with the generic instantiation! We’re only looking at the shape for a <code>[]byte</code> argument here; calling the generic function with a <code>string</code> argument will generate a different shape, as the memory layout of these two is different (16 byte for <code>string</code>, 24 for <code>[]byte</code>) even through its usage in the two instantiated shapes would be identical, as we’re accessing the byte sequence in a read-only way.</p>
<p>…And the result is… It’s good! It’s very good actually. We’ve found a use case where Generics can help with code de-duplication without showing a performance regression. This is exciting! Going from top to bottom, we see that all the optimizations hold (and this is also the case for the <code>string</code> shape, not shown here). The register-based calling convention survives the generic instantiation, although do note that the length of our <code>[]byte</code> argument now resides in <code>CX</code> instead of <code>BX</code>: all registers have shifted right one slot, because <code>AX</code> is now occupied by the runtime dictionary of the Generics implementation.</p>
<p>Everything else is neat as a pin: the 32/64 bit load is still two instructions, the few bound checks that were elided in the non-Generic version are still elided here, and no additional overhead has been introduced anywhere.</p>
<p>A quick benchmark of the two implementations verifies our reading:</p>
<pre><code>name                             time/op
Valid/Japanese/Bytes-16          2.63µs ± 2%
Valid/Japanese/GenericBytes-16   2.67µs ± 1%
Valid/Japanese/String-16         2.48µs ± 2%
Valid/Japanese/GenericString-16  2.53µs ± 0%
Valid/ASCII/Bytes-16              937ns ± 1%
Valid/ASCII/GenericBytes-16       943ns ± 1%
Valid/ASCII/String-16             930ns ± 3%
Valid/ASCII/GenericString-16      811ns ± 2%</code></pre>
<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="100%" viewBox="0 0 657.04 274.079688" xmlns="http://www.w3.org/2000/svg" version="1.1">
 <metadata>
  <rdf:rdf xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
   <cc:work>
    <dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage"></dc:type>
    <dc:date>2022-03-25T15:46:39.484064</dc:date>
    <dc:format>image/svg+xml</dc:format>
    <dc:creator>
     <cc:agent>
      <dc:title>Matplotlib v3.5.1, https://matplotlib.org/</dc:title>
     </cc:agent>
    </dc:creator>
   </cc:work>
  </rdf:rdf>
 </metadata>
 <defs>
  
 </defs>
 <g id="figure_1">
  <g id="patch_1">
   <path d="M 0 274.079688 
L 657.04 274.079688 
L 657.04 0 
L 0 0 
L 0 274.079688 
z
" style="fill: none"></path>
  </g>
  <g id="axes_1">
   <g id="patch_2">
    <path d="M 174.64 202.32 
L 621.04 202.32 
L 621.04 36 
L 174.64 36 
L 174.64 202.32 
z
" style="fill: none"></path>
   </g>
   <g id="matplotlib.axis_1">
    <g id="xtick_1">
     <g id="line2d_1">
      <defs>
       <path id="m216c498d18" d="M 0 0 
L 0 6 
" style="stroke: #ffffff; stroke-width: 1.25"></path>
      </defs>
      <g>
       <use xlink:href="#m216c498d18" x="174.64" y="202.32" style="fill: #ffffff; stroke: #ffffff; stroke-width: 1.25"></use>
      </g>
     </g>
     <g id="text_1">
      <!-- 0 -->
      <g style="fill: #ffffff" transform="translate(171.140625 220.178281)scale(0.11 -0.11)">
       <defs>
        <path id="DejaVuSans-30" d="M 2034 4250 
Q 1547 4250 1301 3770 
Q 1056 3291 1056 2328 
Q 1056 1369 1301 889 
Q 1547 409 2034 409 
Q 2525 409 2770 889 
Q 3016 1369 3016 2328 
Q 3016 3291 2770 3770 
Q 2525 4250 2034 4250 
z
M 2034 4750 
Q 2819 4750 3233 4129 
Q 3647 3509 3647 2328 
Q 3647 1150 3233 529 
Q 2819 -91 2034 -91 
Q 1250 -91 836 529 
Q 422 1150 422 2328 
Q 422 3509 836 4129 
Q 1250 4750 2034 4750 
z
" transform="scale(0.015625)"></path>
       </defs>
       <use xlink:href="#DejaVuSans-30"></use>
      </g>
     </g>
    </g>
    <g id="xtick_2">
     <g id="line2d_2">
      <g>
       <use xlink:href="#m216c498d18" x="253.78641" y="202.32" style="fill: #ffffff; stroke: #ffffff; stroke-width: 1.25"></use>
      </g>
     </g>
     <g id="text_2">
      <!-- 500 -->
      <g style="fill: #ffffff" transform="translate(243.288285 220.178281)scale(0.11 -0.11)">
       <defs>
        <path id="DejaVuSans-35" d="M 691 4666 
L 3169 4666 
L 3169 4134 
L 1269 4134 
L 1269 2991 
Q 1406 3038 1543 3061 
Q 1681 3084 1819 3084 
Q 2600 3084 3056 2656 
Q 3513 2228 3513 1497 
Q 3513 744 3044 326 
Q 2575 -91 1722 -91 
Q 1428 -91 1123 -41 
Q 819 9 494 109 
L 494 744 
Q 775 591 1075 516 
Q 1375 441 1709 441 
Q 2250 441 2565 725 
Q 2881 1009 2881 1497 
Q 2881 1984 2565 2268 
Q 2250 2553 1709 2553 
Q 1456 2553 1204 2497 
Q 953 2441 691 2322 
L 691 4666 
z
" transform="scale(0.015625)"></path>
       </defs>
       <use xlink:href="#DejaVuSans-35"></use>
       <use xlink:href="#DejaVuSans-30" x="63.623047"></use>
       <use xlink:href="#DejaVuSans-30" x="127.246094"></use>
      </g>
     </g>
    </g>
    <g id="xtick_3">
     <g id="line2d_3">
      <g>
       <use xlink:href="#m216c498d18" x="332.93282" y="202.32" style="fill: #ffffff; stroke: #ffffff; stroke-width: 1.25"></use>
      </g>
     </g>
     <g id="text_3">
      <!-- 1000 -->
      <g style="fill: #ffffff" transform="translate(318.93532 220.178281)scale(0.11 -0.11)">
       <defs>
        <path id="DejaVuSans-31" d="M 794 531 
L 1825 531 
L 1825 4091 
L 703 3866 
L 703 4441 
L 1819 4666 
L 2450 4666 
L 2450 531 
L 3481 531 
L 3481 0 
L 794 0 
L 794 531 
z
" transform="scale(0.015625)"></path>
       </defs>
       <use xlink:href="#DejaVuSans-31"></use>
       <use xlink:href="#DejaVuSans-30" x="63.623047"></use>
       <use xlink:href="#DejaVuSans-30" x="127.246094"></use>
       <use xlink:href="#DejaVuSans-30" x="190.869141"></use>
      </g>
     </g>
    </g>
    <g id="xtick_4">
     <g id="line2d_4">
      <g>
       <use xlink:href="#m216c498d18" x="412.079231" y="202.32" style="fill: #ffffff; stroke: #ffffff; stroke-width: 1.25"></use>
      </g>
     </g>
     <g id="text_4">
      <!-- 1500 -->
      <g style="fill: #ffffff" transform="translate(398.081731 220.178281)scale(0.11 -0.11)">
       <use xlink:href="#DejaVuSans-31"></use>
       <use xlink:href="#DejaVuSans-35" x="63.623047"></use>
       <use xlink:href="#DejaVuSans-30" x="127.246094"></use>
       <use xlink:href="#DejaVuSans-30" x="190.869141"></use>
      </g>
     </g>
    </g>
    <g id="xtick_5">
     <g id="line2d_5">
      <g>
       <use xlink:href="#m216c498d18" x="491.225641" y="202.32" style="fill: #ffffff; stroke: #ffffff; stroke-width: 1.25"></use>
      </g>
     </g>
     <g id="text_5">
      <!-- 2000 -->
      <g style="fill: #ffffff" transform="translate(477.228141 220.178281)scale(0.11 -0.11)">
       <defs>
        <path id="DejaVuSans-32" d="M 1228 531 
L 3431 531 
L 3431 0 
L 469 0 
L 469 531 
Q 828 903 1448 1529 
Q 2069 2156 2228 2338 
Q 2531 2678 2651 2914 
Q 2772 3150 2772 3378 
Q 2772 3750 2511 3984 
Q 2250 4219 1831 4219 
Q 1534 4219 1204 4116 
Q 875 4013 500 3803 
L 500 4441 
Q 881 4594 1212 4672 
Q 1544 4750 1819 4750 
Q 2544 4750 2975 4387 
Q 3406 4025 3406 3419 
Q 3406 3131 3298 2873 
Q 3191 2616 2906 2266 
Q 2828 2175 2409 1742 
Q 1991 1309 1228 531 
z
" transform="scale(0.015625)"></path>
       </defs>
       <use xlink:href="#DejaVuSans-32"></use>
       <use xlink:href="#DejaVuSans-30" x="63.623047"></use>
       <use xlink:href="#DejaVuSans-30" x="127.246094"></use>
       <use xlink:href="#DejaVuSans-30" x="190.869141"></use>
      </g>
     </g>
    </g>
    <g id="xtick_6">
     <g id="line2d_6">
      <g>
       <use xlink:href="#m216c498d18" x="570.372051" y="202.32" style="fill: #ffffff; stroke: #ffffff; stroke-width: 1.25"></use>
      </g>
     </g>
     <g id="text_6">
      <!-- 2500 -->
      <g style="fill: #ffffff" transform="translate(556.374551 220.178281)scale(0.11 -0.11)">
       <use xlink:href="#DejaVuSans-32"></use>
       <use xlink:href="#DejaVuSans-35" x="63.623047"></use>
       <use xlink:href="#DejaVuSans-30" x="127.246094"></use>
       <use xlink:href="#DejaVuSans-30" x="190.869141"></use>
      </g>
     </g>
    </g>
    <g id="text_7">
     <!-- ns/op -->
     <g style="fill: #ffffff" transform="translate(381.410313 235.584063)scale(0.12 -0.12)">
      <defs>
       <path id="DejaVuSans-6e" d="M 3513 2113 
L 3513 0 
L 2938 0 
L 2938 2094 
Q 2938 2591 2744 2837 
Q 2550 3084 2163 3084 
Q 1697 3084 1428 2787 
Q 1159 2491 1159 1978 
L 1159 0 
L 581 0 
L 581 3500 
L 1159 3500 
L 1159 2956 
Q 1366 3272 1645 3428 
Q 1925 3584 2291 3584 
Q 2894 3584 3203 3211 
Q 3513 2838 3513 2113 
z
" transform="scale(0.015625)"></path>
       <path id="DejaVuSans-73" d="M 2834 3397 
L 2834 2853 
Q 2591 2978 2328 3040 
Q 2066 3103 1784 3103 
Q 1356 3103 1142 2972 
Q 928 2841 928 2578 
Q 928 2378 1081 2264 
Q 1234 2150 1697 2047 
L 1894 2003 
Q 2506 1872 2764 1633 
Q 3022 1394 3022 966 
Q 3022 478 2636 193 
Q 2250 -91 1575 -91 
Q 1294 -91 989 -36 
Q 684 19 347 128 
L 347 722 
Q 666 556 975 473 
Q 1284 391 1588 391 
Q 1994 391 2212 530 
Q 2431 669 2431 922 
Q 2431 1156 2273 1281 
Q 2116 1406 1581 1522 
L 1381 1569 
Q 847 1681 609 1914 
Q 372 2147 372 2553 
Q 372 3047 722 3315 
Q 1072 3584 1716 3584 
Q 2034 3584 2315 3537 
Q 2597 3491 2834 3397 
z
" transform="scale(0.015625)"></path>
       <path id="DejaVuSans-2f" d="M 1625 4666 
L 2156 4666 
L 531 -594 
L 0 -594 
L 1625 4666 
z
" transform="scale(0.015625)"></path>
       <path id="DejaVuSans-6f" d="M 1959 3097 
Q 1497 3097 1228 2736 
Q 959 2375 959 1747 
Q 959 1119 1226 758 
Q 1494 397 1959 397 
Q 2419 397 2687 759 
Q 2956 1122 2956 1747 
Q 2956 2369 2687 2733 
Q 2419 3097 1959 3097 
z
M 1959 3584 
Q 2709 3584 3137 3096 
Q 3566 2609 3566 1747 
Q 3566 888 3137 398 
Q 2709 -91 1959 -91 
Q 1206 -91 779 398 
Q 353 888 353 1747 
Q 353 2609 779 3096 
Q 1206 3584 1959 3584 
z
" transform="scale(0.015625)"></path>
       <path id="DejaVuSans-70" d="M 1159 525 
L 1159 -1331 
L 581 -1331 
L 581 3500 
L 1159 3500 
L 1159 2969 
Q 1341 3281 1617 3432 
Q 1894 3584 2278 3584 
Q 2916 3584 3314 3078 
Q 3713 2572 3713 1747 
Q 3713 922 3314 415 
Q 2916 -91 2278 -91 
Q 1894 -91 1617 61 
Q 1341 213 1159 525 
z
M 3116 1747 
Q 3116 2381 2855 2742 
Q 2594 3103 2138 3103 
Q 1681 3103 1420 2742 
Q 1159 2381 1159 1747 
Q 1159 1113 1420 752 
Q 1681 391 2138 391 
Q 2594 391 2855 752 
Q 3116 1113 3116 1747 
z
" transform="scale(0.015625)"></path>
      </defs>
      <use xlink:href="#DejaVuSans-6e"></use>
      <use xlink:href="#DejaVuSans-73" x="63.378906"></use>
      <use xlink:href="#DejaVuSans-2f" x="115.478516"></use>
      <use xlink:href="#DejaVuSans-6f" x="149.169922"></use>
      <use xlink:href="#DejaVuSans-70" x="210.351562"></use>
     </g>
    </g>
   </g>
   <g id="matplotlib.axis_2">
    <g id="ytick_1">
     <g id="line2d_7">
      <defs>
       <path id="mccb27da594" d="M 0 0 
L -6 0 
" style="stroke: #ffffff; stroke-width: 1.25"></path>
      </defs>
      <g>
       <use xlink:href="#mccb27da594" x="174.64" y="46.395" style="fill: #ffffff; stroke: #ffffff; stroke-width: 1.25"></use>
      </g>
     </g>
     <g id="text_8">
      <!-- Japanese/Bytes -->
      <g style="fill: #ffffff" transform="translate(80.617031 50.574141)scale(0.11 -0.11)">
       <defs>
        <path id="DejaVuSans-4a" d="M 628 4666 
L 1259 4666 
L 1259 325 
Q 1259 -519 939 -900 
Q 619 -1281 -91 -1281 
L -331 -1281 
L -331 -750 
L -134 -750 
Q 284 -750 456 -515 
Q 628 -281 628 325 
L 628 4666 
z
" transform="scale(0.015625)"></path>
        <path id="DejaVuSans-61" d="M 2194 1759 
Q 1497 1759 1228 1600 
Q 959 1441 959 1056 
Q 959 750 1161 570 
Q 1363 391 1709 391 
Q 2188 391 2477 730 
Q 2766 1069 2766 1631 
L 2766 1759 
L 2194 1759 
z
M 3341 1997 
L 3341 0 
L 2766 0 
L 2766 531 
Q 2569 213 2275 61 
Q 1981 -91 1556 -91 
Q 1019 -91 701 211 
Q 384 513 384 1019 
Q 384 1609 779 1909 
Q 1175 2209 1959 2209 
L 2766 2209 
L 2766 2266 
Q 2766 2663 2505 2880 
Q 2244 3097 1772 3097 
Q 1472 3097 1187 3025 
Q 903 2953 641 2809 
L 641 3341 
Q 956 3463 1253 3523 
Q 1550 3584 1831 3584 
Q 2591 3584 2966 3190 
Q 3341 2797 3341 1997 
z
" transform="scale(0.015625)"></path>
        <path id="DejaVuSans-65" d="M 3597 1894 
L 3597 1613 
L 953 1613 
Q 991 1019 1311 708 
Q 1631 397 2203 397 
Q 2534 397 2845 478 
Q 3156 559 3463 722 
L 3463 178 
Q 3153 47 2828 -22 
Q 2503 -91 2169 -91 
Q 1331 -91 842 396 
Q 353 884 353 1716 
Q 353 2575 817 3079 
Q 1281 3584 2069 3584 
Q 2775 3584 3186 3129 
Q 3597 2675 3597 1894 
z
M 3022 2063 
Q 3016 2534 2758 2815 
Q 2500 3097 2075 3097 
Q 1594 3097 1305 2825 
Q 1016 2553 972 2059 
L 3022 2063 
z
" transform="scale(0.015625)"></path>
        <path id="DejaVuSans-42" d="M 1259 2228 
L 1259 519 
L 2272 519 
Q 2781 519 3026 730 
Q 3272 941 3272 1375 
Q 3272 1813 3026 2020 
Q 2781 2228 2272 2228 
L 1259 2228 
z
M 1259 4147 
L 1259 2741 
L 2194 2741 
Q 2656 2741 2882 2914 
Q 3109 3088 3109 3444 
Q 3109 3797 2882 3972 
Q 2656 4147 2194 4147 
L 1259 4147 
z
M 628 4666 
L 2241 4666 
Q 2963 4666 3353 4366 
Q 3744 4066 3744 3513 
Q 3744 3084 3544 2831 
Q 3344 2578 2956 2516 
Q 3422 2416 3680 2098 
Q 3938 1781 3938 1306 
Q 3938 681 3513 340 
Q 3088 0 2303 0 
L 628 0 
L 628 4666 
z
" transform="scale(0.015625)"></path>
        <path id="DejaVuSans-79" d="M 2059 -325 
Q 1816 -950 1584 -1140 
Q 1353 -1331 966 -1331 
L 506 -1331 
L 506 -850 
L 844 -850 
Q 1081 -850 1212 -737 
Q 1344 -625 1503 -206 
L 1606 56 
L 191 3500 
L 800 3500 
L 1894 763 
L 2988 3500 
L 3597 3500 
L 2059 -325 
z
" transform="scale(0.015625)"></path>
        <path id="DejaVuSans-74" d="M 1172 4494 
L 1172 3500 
L 2356 3500 
L 2356 3053 
L 1172 3053 
L 1172 1153 
Q 1172 725 1289 603 
Q 1406 481 1766 481 
L 2356 481 
L 2356 0 
L 1766 0 
Q 1100 0 847 248 
Q 594 497 594 1153 
L 594 3053 
L 172 3053 
L 172 3500 
L 594 3500 
L 594 4494 
L 1172 4494 
z
" transform="scale(0.015625)"></path>
       </defs>
       <use xlink:href="#DejaVuSans-4a"></use>
       <use xlink:href="#DejaVuSans-61" x="29.492188"></use>
       <use xlink:href="#DejaVuSans-70" x="90.771484"></use>
       <use xlink:href="#DejaVuSans-61" x="154.248047"></use>
       <use xlink:href="#DejaVuSans-6e" x="215.527344"></use>
       <use xlink:href="#DejaVuSans-65" x="278.90625"></use>
       <use xlink:href="#DejaVuSans-73" x="340.429688"></use>
       <use xlink:href="#DejaVuSans-65" x="392.529297"></use>
       <use xlink:href="#DejaVuSans-2f" x="454.052734"></use>
       <use xlink:href="#DejaVuSans-42" x="487.744141"></use>
       <use xlink:href="#DejaVuSans-79" x="556.347656"></use>
       <use xlink:href="#DejaVuSans-74" x="615.527344"></use>
       <use xlink:href="#DejaVuSans-65" x="654.736328"></use>
       <use xlink:href="#DejaVuSans-73" x="716.259766"></use>
      </g>
     </g>
    </g>
    <g id="ytick_2">
     <g id="line2d_8">
      <g>
       <use xlink:href="#mccb27da594" x="174.64" y="67.185" style="fill: #ffffff; stroke: #ffffff; stroke-width: 1.25"></use>
      </g>
     </g>
     <g id="text_9">
      <!-- Japanese/GenericBytes -->
      <g style="fill: #ffffff" transform="translate(37.959375 71.364141)scale(0.11 -0.11)">
       <defs>
        <path id="DejaVuSans-47" d="M 3809 666 
L 3809 1919 
L 2778 1919 
L 2778 2438 
L 4434 2438 
L 4434 434 
Q 4069 175 3628 42 
Q 3188 -91 2688 -91 
Q 1594 -91 976 548 
Q 359 1188 359 2328 
Q 359 3472 976 4111 
Q 1594 4750 2688 4750 
Q 3144 4750 3555 4637 
Q 3966 4525 4313 4306 
L 4313 3634 
Q 3963 3931 3569 4081 
Q 3175 4231 2741 4231 
Q 1884 4231 1454 3753 
Q 1025 3275 1025 2328 
Q 1025 1384 1454 906 
Q 1884 428 2741 428 
Q 3075 428 3337 486 
Q 3600 544 3809 666 
z
" transform="scale(0.015625)"></path>
        <path id="DejaVuSans-72" d="M 2631 2963 
Q 2534 3019 2420 3045 
Q 2306 3072 2169 3072 
Q 1681 3072 1420 2755 
Q 1159 2438 1159 1844 
L 1159 0 
L 581 0 
L 581 3500 
L 1159 3500 
L 1159 2956 
Q 1341 3275 1631 3429 
Q 1922 3584 2338 3584 
Q 2397 3584 2469 3576 
Q 2541 3569 2628 3553 
L 2631 2963 
z
" transform="scale(0.015625)"></path>
        <path id="DejaVuSans-69" d="M 603 3500 
L 1178 3500 
L 1178 0 
L 603 0 
L 603 3500 
z
M 603 4863 
L 1178 4863 
L 1178 4134 
L 603 4134 
L 603 4863 
z
" transform="scale(0.015625)"></path>
        <path id="DejaVuSans-63" d="M 3122 3366 
L 3122 2828 
Q 2878 2963 2633 3030 
Q 2388 3097 2138 3097 
Q 1578 3097 1268 2742 
Q 959 2388 959 1747 
Q 959 1106 1268 751 
Q 1578 397 2138 397 
Q 2388 397 2633 464 
Q 2878 531 3122 666 
L 3122 134 
Q 2881 22 2623 -34 
Q 2366 -91 2075 -91 
Q 1284 -91 818 406 
Q 353 903 353 1747 
Q 353 2603 823 3093 
Q 1294 3584 2113 3584 
Q 2378 3584 2631 3529 
Q 2884 3475 3122 3366 
z
" transform="scale(0.015625)"></path>
       </defs>
       <use xlink:href="#DejaVuSans-4a"></use>
       <use xlink:href="#DejaVuSans-61" x="29.492188"></use>
       <use xlink:href="#DejaVuSans-70" x="90.771484"></use>
       <use xlink:href="#DejaVuSans-61" x="154.248047"></use>
       <use xlink:href="#DejaVuSans-6e" x="215.527344"></use>
       <use xlink:href="#DejaVuSans-65" x="278.90625"></use>
       <use xlink:href="#DejaVuSans-73" x="340.429688"></use>
       <use xlink:href="#DejaVuSans-65" x="392.529297"></use>
       <use xlink:href="#DejaVuSans-2f" x="454.052734"></use>
       <use xlink:href="#DejaVuSans-47" x="487.744141"></use>
       <use xlink:href="#DejaVuSans-65" x="565.234375"></use>
       <use xlink:href="#DejaVuSans-6e" x="626.757812"></use>
       <use xlink:href="#DejaVuSans-65" x="690.136719"></use>
       <use xlink:href="#DejaVuSans-72" x="751.660156"></use>
       <use xlink:href="#DejaVuSans-69" x="792.773438"></use>
       <use xlink:href="#DejaVuSans-63" x="820.556641"></use>
       <use xlink:href="#DejaVuSans-42" x="875.537109"></use>
       <use xlink:href="#DejaVuSans-79" x="944.140625"></use>
       <use xlink:href="#DejaVuSans-74" x="1003.320312"></use>
       <use xlink:href="#DejaVuSans-65" x="1042.529297"></use>
       <use xlink:href="#DejaVuSans-73" x="1104.052734"></use>
      </g>
     </g>
    </g>
    <g id="ytick_3">
     <g id="line2d_9">
      <g>
       <use xlink:href="#mccb27da594" x="174.64" y="87.975" style="fill: #ffffff; stroke: #ffffff; stroke-width: 1.25"></use>
      </g>
     </g>
     <g id="text_10">
      <!-- Japanese/String -->
      <g style="fill: #ffffff" transform="translate(78.657656 92.154141)scale(0.11 -0.11)">
       <defs>
        <path id="DejaVuSans-53" d="M 3425 4513 
L 3425 3897 
Q 3066 4069 2747 4153 
Q 2428 4238 2131 4238 
Q 1616 4238 1336 4038 
Q 1056 3838 1056 3469 
Q 1056 3159 1242 3001 
Q 1428 2844 1947 2747 
L 2328 2669 
Q 3034 2534 3370 2195 
Q 3706 1856 3706 1288 
Q 3706 609 3251 259 
Q 2797 -91 1919 -91 
Q 1588 -91 1214 -16 
Q 841 59 441 206 
L 441 856 
Q 825 641 1194 531 
Q 1563 422 1919 422 
Q 2459 422 2753 634 
Q 3047 847 3047 1241 
Q 3047 1584 2836 1778 
Q 2625 1972 2144 2069 
L 1759 2144 
Q 1053 2284 737 2584 
Q 422 2884 422 3419 
Q 422 4038 858 4394 
Q 1294 4750 2059 4750 
Q 2388 4750 2728 4690 
Q 3069 4631 3425 4513 
z
" transform="scale(0.015625)"></path>
        <path id="DejaVuSans-67" d="M 2906 1791 
Q 2906 2416 2648 2759 
Q 2391 3103 1925 3103 
Q 1463 3103 1205 2759 
Q 947 2416 947 1791 
Q 947 1169 1205 825 
Q 1463 481 1925 481 
Q 2391 481 2648 825 
Q 2906 1169 2906 1791 
z
M 3481 434 
Q 3481 -459 3084 -895 
Q 2688 -1331 1869 -1331 
Q 1566 -1331 1297 -1286 
Q 1028 -1241 775 -1147 
L 775 -588 
Q 1028 -725 1275 -790 
Q 1522 -856 1778 -856 
Q 2344 -856 2625 -561 
Q 2906 -266 2906 331 
L 2906 616 
Q 2728 306 2450 153 
Q 2172 0 1784 0 
Q 1141 0 747 490 
Q 353 981 353 1791 
Q 353 2603 747 3093 
Q 1141 3584 1784 3584 
Q 2172 3584 2450 3431 
Q 2728 3278 2906 2969 
L 2906 3500 
L 3481 3500 
L 3481 434 
z
" transform="scale(0.015625)"></path>
       </defs>
       <use xlink:href="#DejaVuSans-4a"></use>
       <use xlink:href="#DejaVuSans-61" x="29.492188"></use>
       <use xlink:href="#DejaVuSans-70" x="90.771484"></use>
       <use xlink:href="#DejaVuSans-61" x="154.248047"></use>
       <use xlink:href="#DejaVuSans-6e" x="215.527344"></use>
       <use xlink:href="#DejaVuSans-65" x="278.90625"></use>
       <use xlink:href="#DejaVuSans-73" x="340.429688"></use>
       <use xlink:href="#DejaVuSans-65" x="392.529297"></use>
       <use xlink:href="#DejaVuSans-2f" x="454.052734"></use>
       <use xlink:href="#DejaVuSans-53" x="487.744141"></use>
       <use xlink:href="#DejaVuSans-74" x="551.220703"></use>
       <use xlink:href="#DejaVuSans-72" x="590.429688"></use>
       <use xlink:href="#DejaVuSans-69" x="631.542969"></use>
       <use xlink:href="#DejaVuSans-6e" x="659.326172"></use>
       <use xlink:href="#DejaVuSans-67" x="722.705078"></use>
      </g>
     </g>
    </g>
    <g id="ytick_4">
     <g id="line2d_10">
      <g>
       <use xlink:href="#mccb27da594" x="174.64" y="108.765" style="fill: #ffffff; stroke: #ffffff; stroke-width: 1.25"></use>
      </g>
     </g>
     <g id="text_11">
      <!-- Japanese/GenericString -->
      <g style="fill: #ffffff" transform="translate(36 112.944141)scale(0.11 -0.11)">
       <use xlink:href="#DejaVuSans-4a"></use>
       <use xlink:href="#DejaVuSans-61" x="29.492188"></use>
       <use xlink:href="#DejaVuSans-70" x="90.771484"></use>
       <use xlink:href="#DejaVuSans-61" x="154.248047"></use>
       <use xlink:href="#DejaVuSans-6e" x="215.527344"></use>
       <use xlink:href="#DejaVuSans-65" x="278.90625"></use>
       <use xlink:href="#DejaVuSans-73" x="340.429688"></use>
       <use xlink:href="#DejaVuSans-65" x="392.529297"></use>
       <use xlink:href="#DejaVuSans-2f" x="454.052734"></use>
       <use xlink:href="#DejaVuSans-47" x="487.744141"></use>
       <use xlink:href="#DejaVuSans-65" x="565.234375"></use>
       <use xlink:href="#DejaVuSans-6e" x="626.757812"></use>
       <use xlink:href="#DejaVuSans-65" x="690.136719"></use>
       <use xlink:href="#DejaVuSans-72" x="751.660156"></use>
       <use xlink:href="#DejaVuSans-69" x="792.773438"></use>
       <use xlink:href="#DejaVuSans-63" x="820.556641"></use>
       <use xlink:href="#DejaVuSans-53" x="875.537109"></use>
       <use xlink:href="#DejaVuSans-74" x="939.013672"></use>
       <use xlink:href="#DejaVuSans-72" x="978.222656"></use>
       <use xlink:href="#DejaVuSans-69" x="1019.335938"></use>
       <use xlink:href="#DejaVuSans-6e" x="1047.119141"></use>
       <use xlink:href="#DejaVuSans-67" x="1110.498047"></use>
      </g>
     </g>
    </g>
    <g id="ytick_5">
     <g id="line2d_11">
      <g>
       <use xlink:href="#mccb27da594" x="174.64" y="129.555" style="fill: #ffffff; stroke: #ffffff; stroke-width: 1.25"></use>
      </g>
     </g>
     <g id="text_12">
      <!-- ASCII/Bytes -->
      <g style="fill: #ffffff" transform="translate(101.886563 133.734141)scale(0.11 -0.11)">
       <defs>
        <path id="DejaVuSans-41" d="M 2188 4044 
L 1331 1722 
L 3047 1722 
L 2188 4044 
z
M 1831 4666 
L 2547 4666 
L 4325 0 
L 3669 0 
L 3244 1197 
L 1141 1197 
L 716 0 
L 50 0 
L 1831 4666 
z
" transform="scale(0.015625)"></path>
        <path id="DejaVuSans-43" d="M 4122 4306 
L 4122 3641 
Q 3803 3938 3442 4084 
Q 3081 4231 2675 4231 
Q 1875 4231 1450 3742 
Q 1025 3253 1025 2328 
Q 1025 1406 1450 917 
Q 1875 428 2675 428 
Q 3081 428 3442 575 
Q 3803 722 4122 1019 
L 4122 359 
Q 3791 134 3420 21 
Q 3050 -91 2638 -91 
Q 1578 -91 968 557 
Q 359 1206 359 2328 
Q 359 3453 968 4101 
Q 1578 4750 2638 4750 
Q 3056 4750 3426 4639 
Q 3797 4528 4122 4306 
z
" transform="scale(0.015625)"></path>
        <path id="DejaVuSans-49" d="M 628 4666 
L 1259 4666 
L 1259 0 
L 628 0 
L 628 4666 
z
" transform="scale(0.015625)"></path>
       </defs>
       <use xlink:href="#DejaVuSans-41"></use>
       <use xlink:href="#DejaVuSans-53" x="68.408203"></use>
       <use xlink:href="#DejaVuSans-43" x="131.884766"></use>
       <use xlink:href="#DejaVuSans-49" x="201.708984"></use>
       <use xlink:href="#DejaVuSans-49" x="231.201172"></use>
       <use xlink:href="#DejaVuSans-2f" x="260.693359"></use>
       <use xlink:href="#DejaVuSans-42" x="294.384766"></use>
       <use xlink:href="#DejaVuSans-79" x="362.988281"></use>
       <use xlink:href="#DejaVuSans-74" x="422.167969"></use>
       <use xlink:href="#DejaVuSans-65" x="461.376953"></use>
       <use xlink:href="#DejaVuSans-73" x="522.900391"></use>
      </g>
     </g>
    </g>
    <g id="ytick_6">
     <g id="line2d_12">
      <g>
       <use xlink:href="#mccb27da594" x="174.64" y="150.345" style="fill: #ffffff; stroke: #ffffff; stroke-width: 1.25"></use>
      </g>
     </g>
     <g id="text_13">
      <!-- ASCII/GenericBytes -->
      <g style="fill: #ffffff" transform="translate(59.228906 154.524141)scale(0.11 -0.11)">
       <use xlink:href="#DejaVuSans-41"></use>
       <use xlink:href="#DejaVuSans-53" x="68.408203"></use>
       <use xlink:href="#DejaVuSans-43" x="131.884766"></use>
       <use xlink:href="#DejaVuSans-49" x="201.708984"></use>
       <use xlink:href="#DejaVuSans-49" x="231.201172"></use>
       <use xlink:href="#DejaVuSans-2f" x="260.693359"></use>
       <use xlink:href="#DejaVuSans-47" x="294.384766"></use>
       <use xlink:href="#DejaVuSans-65" x="371.875"></use>
       <use xlink:href="#DejaVuSans-6e" x="433.398438"></use>
       <use xlink:href="#DejaVuSans-65" x="496.777344"></use>
       <use xlink:href="#DejaVuSans-72" x="558.300781"></use>
       <use xlink:href="#DejaVuSans-69" x="599.414062"></use>
       <use xlink:href="#DejaVuSans-63" x="627.197266"></use>
       <use xlink:href="#DejaVuSans-42" x="682.177734"></use>
       <use xlink:href="#DejaVuSans-79" x="750.78125"></use>
       <use xlink:href="#DejaVuSans-74" x="809.960938"></use>
       <use xlink:href="#DejaVuSans-65" x="849.169922"></use>
       <use xlink:href="#DejaVuSans-73" x="910.693359"></use>
      </g>
     </g>
    </g>
    <g id="ytick_7">
     <g id="line2d_13">
      <g>
       <use xlink:href="#mccb27da594" x="174.64" y="171.135" style="fill: #ffffff; stroke: #ffffff; stroke-width: 1.25"></use>
      </g>
     </g>
     <g id="text_14">
      <!-- ASCII/String -->
      <g style="fill: #ffffff" transform="translate(99.927188 175.314141)scale(0.11 -0.11)">
       <use xlink:href="#DejaVuSans-41"></use>
       <use xlink:href="#DejaVuSans-53" x="68.408203"></use>
       <use xlink:href="#DejaVuSans-43" x="131.884766"></use>
       <use xlink:href="#DejaVuSans-49" x="201.708984"></use>
       <use xlink:href="#DejaVuSans-49" x="231.201172"></use>
       <use xlink:href="#DejaVuSans-2f" x="260.693359"></use>
       <use xlink:href="#DejaVuSans-53" x="294.384766"></use>
       <use xlink:href="#DejaVuSans-74" x="357.861328"></use>
       <use xlink:href="#DejaVuSans-72" x="397.070312"></use>
       <use xlink:href="#DejaVuSans-69" x="438.183594"></use>
       <use xlink:href="#DejaVuSans-6e" x="465.966797"></use>
       <use xlink:href="#DejaVuSans-67" x="529.345703"></use>
      </g>
     </g>
    </g>
    <g id="ytick_8">
     <g id="line2d_14">
      <g>
       <use xlink:href="#mccb27da594" x="174.64" y="191.925" style="fill: #ffffff; stroke: #ffffff; stroke-width: 1.25"></use>
      </g>
     </g>
     <g id="text_15">
      <!-- ASCII/GenericString -->
      <g style="fill: #ffffff" transform="translate(57.269531 196.104141)scale(0.11 -0.11)">
       <use xlink:href="#DejaVuSans-41"></use>
       <use xlink:href="#DejaVuSans-53" x="68.408203"></use>
       <use xlink:href="#DejaVuSans-43" x="131.884766"></use>
       <use xlink:href="#DejaVuSans-49" x="201.708984"></use>
       <use xlink:href="#DejaVuSans-49" x="231.201172"></use>
       <use xlink:href="#DejaVuSans-2f" x="260.693359"></use>
       <use xlink:href="#DejaVuSans-47" x="294.384766"></use>
       <use xlink:href="#DejaVuSans-65" x="371.875"></use>
       <use xlink:href="#DejaVuSans-6e" x="433.398438"></use>
       <use xlink:href="#DejaVuSans-65" x="496.777344"></use>
       <use xlink:href="#DejaVuSans-72" x="558.300781"></use>
       <use xlink:href="#DejaVuSans-69" x="599.414062"></use>
       <use xlink:href="#DejaVuSans-63" x="627.197266"></use>
       <use xlink:href="#DejaVuSans-53" x="682.177734"></use>
       <use xlink:href="#DejaVuSans-74" x="745.654297"></use>
       <use xlink:href="#DejaVuSans-72" x="784.863281"></use>
       <use xlink:href="#DejaVuSans-69" x="825.976562"></use>
       <use xlink:href="#DejaVuSans-6e" x="853.759766"></use>
       <use xlink:href="#DejaVuSans-67" x="917.138672"></use>
      </g>
     </g>
    </g>
   </g>
   <g id="patch_3">
    <path d="M 174.64 38.079 
L 591.330021 38.079 
L 591.330021 54.711 
L 174.64 54.711 
z
" clip-path="url(#pd535ddf6c3)" style="fill: #5875a4; stroke: #ffffff; stroke-linejoin: miter"></path>
   </g>
   <g id="patch_4">
    <path d="M 174.64 58.869 
L 596.870269 58.869 
L 596.870269 75.501 
L 174.64 75.501 
z
" clip-path="url(#pd535ddf6c3)" style="fill: #cc8963; stroke: #ffffff; stroke-linejoin: miter"></path>
   </g>
   <g id="patch_5">
    <path d="M 174.64 79.659 
L 567.491122 79.659 
L 567.491122 96.291 
L 174.64 96.291 
z
" clip-path="url(#pd535ddf6c3)" style="fill: #5f9e6e; stroke: #ffffff; stroke-linejoin: miter"></path>
   </g>
   <g id="patch_6">
    <path d="M 174.64 100.449 
L 574.677616 100.449 
L 574.677616 117.081 
L 174.64 117.081 
z
" clip-path="url(#pd535ddf6c3)" style="fill: #b55d60; stroke: #ffffff; stroke-linejoin: miter"></path>
   </g>
   <g id="patch_7">
    <path d="M 174.64 121.239 
L 322.954041 121.239 
L 322.954041 137.871 
L 174.64 137.871 
z
" clip-path="url(#pd535ddf6c3)" style="fill: #857aab; stroke: #ffffff; stroke-linejoin: miter"></path>
   </g>
   <g id="patch_8">
    <path d="M 174.64 142.029 
L 323.954452 142.029 
L 323.954452 158.661 
L 174.64 158.661 
z
" clip-path="url(#pd535ddf6c3)" style="fill: #8d7866; stroke: #ffffff; stroke-linejoin: miter"></path>
   </g>
   <g id="patch_9">
    <path d="M 174.64 162.819 
L 321.890313 162.819 
L 321.890313 179.451 
L 174.64 179.451 
z
" clip-path="url(#pd535ddf6c3)" style="fill: #d095bf; stroke: #ffffff; stroke-linejoin: miter"></path>
   </g>
   <g id="patch_10">
    <path d="M 174.64 183.609 
L 303.040804 183.609 
L 303.040804 200.241 
L 174.64 200.241 
z
" clip-path="url(#pd535ddf6c3)" style="fill: #8c8c8c; stroke: #ffffff; stroke-linejoin: miter"></path>
   </g>
   <g id="line2d_15">
    <path d="M 585.37821 46.395 
L 597.060221 46.395 
" clip-path="url(#pd535ddf6c3)" style="fill: none; stroke: #424242; stroke-width: 2.7; stroke-linecap: round"></path>
   </g>
   <g id="line2d_16">
    <path d="M 594.305134 67.185 
L 599.782857 67.185 
" clip-path="url(#pd535ddf6c3)" style="fill: none; stroke: #424242; stroke-width: 2.7; stroke-linecap: round"></path>
   </g>
   <g id="line2d_17">
    <path d="M 562.45741 87.975 
L 572.629307 87.975 
" clip-path="url(#pd535ddf6c3)" style="fill: none; stroke: #424242; stroke-width: 2.7; stroke-linecap: round"></path>
   </g>
   <g id="line2d_18">
    <path d="M 573.981127 108.765 
L 575.342446 108.765 
" clip-path="url(#pd535ddf6c3)" style="fill: none; stroke: #424242; stroke-width: 2.7; stroke-linecap: round"></path>
   </g>
   <g id="line2d_19">
    <path d="M 322.482328 129.555 
L 323.425754 129.555 
" clip-path="url(#pd535ddf6c3)" style="fill: none; stroke: #424242; stroke-width: 2.7; stroke-linecap: round"></path>
   </g>
   <g id="line2d_20">
    <path d="M 322.979368 150.345 
L 324.929535 150.345 
" clip-path="url(#pd535ddf6c3)" style="fill: none; stroke: #424242; stroke-width: 2.7; stroke-linecap: round"></path>
   </g>
   <g id="line2d_21">
    <path d="M 320.121233 171.135 
L 323.41309 171.135 
" clip-path="url(#pd535ddf6c3)" style="fill: none; stroke: #424242; stroke-width: 2.7; stroke-linecap: round"></path>
   </g>
   <g id="line2d_22">
    <path d="M 301.934496 191.925 
L 303.962227 191.925 
" clip-path="url(#pd535ddf6c3)" style="fill: none; stroke: #424242; stroke-width: 2.7; stroke-linecap: round"></path>
   </g>
   <g id="patch_11">
    <path d="M 174.64 202.32 
L 174.64 36 
" style="fill: none; stroke: #ffffff; stroke-width: 1.25; stroke-linejoin: miter; stroke-linecap: square"></path>
   </g>
   <g id="patch_12">
    <path d="M 621.04 202.32 
L 621.04 36 
" style="fill: none; stroke: #ffffff; stroke-width: 1.25; stroke-linejoin: miter; stroke-linecap: square"></path>
   </g>
   <g id="patch_13">
    <path d="M 174.64 202.32 
L 621.04 202.32 
" style="fill: none; stroke: #ffffff; stroke-width: 1.25; stroke-linejoin: miter; stroke-linecap: square"></path>
   </g>
   <g id="patch_14">
    <path d="M 174.64 36 
L 621.04 36 
" style="fill: none; stroke: #ffffff; stroke-width: 1.25; stroke-linejoin: miter; stroke-linecap: square"></path>
   </g>
  </g>
 </g>
 <defs>
  <clipPath id="pd535ddf6c3">
   <rect x="174.64" y="36" width="446.4" height="166.32"></rect>
  </clipPath>
 </defs>
</svg>
<p>The performance difference between the two implementations is within the margin of error, so this is indeed a best case scenario: <strong>the <code>[]byte | string</code> constraint can be used in Go generics to reduce code duplication in functions that process byte sequences without introducing any extra overhead</strong>. There is one interesting exception here: the Generic shape for <code>string</code> is measurably faster (~4%) than the non-Generic implementation when running the ASCII benchmark, even though their assemblies are functionally identical. However, the shape for <code>[]byte</code> has the same performance as the non-Generic code for all benchmarks, again having identical assemblies. This is a puzzling artifact that can be reproduced reliably, only when benchmarking ASCII input.</p>
<h4>Function Callbacks</h4>
<p>Since its very first release, Go has had very good support for anonymous functions. They are a core part of the language, and they increase its expressiveness by allowing many patterns that would become very verbose without changing the language’s syntax. For instance, user code cannot be extended to allow the <code>range</code> operator being called on a custom struct or interface. This means that to support iteration, our data strutures need to implement custom Iterator structs (with significant overhead), or have an iteration API based on function callbacks, which are often faster. Here’s a small example that uses a function callback to iterate through all the valid runes (i.e. Unicode codepoints) in an UTF-8 encoded byte slice:</p>
<pre><code id="for-each-rune-go"><span>func</span><span> </span><span>ForEachRune</span><span>(p []</span><span>byte</span><span>, each </span><span>func</span><span>(</span><span>rune</span><span>)) {</span>
<span>	</span><span>np</span><span> </span><span>:=</span><span> </span><span>len</span><span>(p)</span>
<span>	</span><span>for</span><span> </span><span>i</span><span> </span><span>:=</span><span> </span><span>0</span><span>; i </span><span>&lt;</span><span> np; {</span>
<span>		</span><span>c0</span><span> </span><span>:=</span><span> p[i]</span>
<span>		</span><span>if</span><span> c0 </span><span>&lt;</span><span> RuneSelf {</span>
<span>			</span><span>each</span><span>(</span><span>rune</span><span>(c0))</span>
<span>			i</span><span>++</span>
<span>			</span><span>continue</span>
<span>		}</span>
<span>		</span><span>x</span><span> </span><span>:=</span><span> first[c0]</span>
<span>		</span><span>if</span><span> x </span><span>==</span><span> xx {</span>
<span>			i</span><span>++</span><span> </span><span>// invalid.</span>
<span>			</span><span>continue</span>
<span>		}</span>
<span>		</span><span>size</span><span> </span><span>:=</span><span> </span><span>int</span><span>(x </span><span>&amp;</span><span> </span><span>7</span><span>)</span>
<span>		</span><span>if</span><span> i</span><span>+</span><span>size </span><span>&gt;</span><span> np {</span>
<span>			i</span><span>++</span><span> </span><span>// Short or invalid.</span>
<span>			</span><span>continue</span>
<span>		}</span>
<span>		</span><span>accept</span><span> </span><span>:=</span><span> acceptRanges[x</span><span>&gt;&gt;</span><span>4</span><span>]</span>
<span>		</span><span>if</span><span> </span><span>c1</span><span> </span><span>:=</span><span> p[i</span><span>+</span><span>1</span><span>]; c1 </span><span>&lt;</span><span> accept.lo </span><span>||</span><span> accept.hi </span><span>&lt;</span><span> c1 {</span>
<span>			</span><span>size</span><span> </span><span>=</span><span> </span><span>1</span>
<span>		} </span><span>else</span><span> </span><span>if</span><span> size </span><span>==</span><span> </span><span>2</span><span> {</span>
<span>			</span><span>each</span><span>(</span><span>rune</span><span>(c0</span><span>&amp;</span><span>mask2)</span><span>&lt;&lt;</span><span>6</span><span> </span><span>|</span><span> </span><span>rune</span><span>(c1</span><span>&amp;</span><span>maskx))</span>
<span>		} </span><span>else</span><span> </span><span>if</span><span> </span><span>c2</span><span> </span><span>:=</span><span> p[i</span><span>+</span><span>2</span><span>]; c2 </span><span>&lt;</span><span> locb </span><span>||</span><span> hicb </span><span>&lt;</span><span> c2 {</span>
<span>			</span><span>size</span><span> </span><span>=</span><span> </span><span>1</span>
<span>		} </span><span>else</span><span> </span><span>if</span><span> size </span><span>==</span><span> </span><span>3</span><span> {</span>
<span>			</span><span>each</span><span>(</span><span>rune</span><span>(c0</span><span>&amp;</span><span>mask3)</span><span>&lt;&lt;</span><span>12</span><span> </span><span>|</span><span> </span><span>rune</span><span>(c1</span><span>&amp;</span><span>maskx)</span><span>&lt;&lt;</span><span>6</span><span> </span><span>|</span><span> </span><span>rune</span><span>(c2</span><span>&amp;</span><span>maskx))</span>
<span>		} </span><span>else</span><span> </span><span>if</span><span> </span><span>c3</span><span> </span><span>:=</span><span> p[i</span><span>+</span><span>3</span><span>]; c3 </span><span>&lt;</span><span> locb </span><span>||</span><span> hicb </span><span>&lt;</span><span> c3 {</span>
<span>			</span><span>size</span><span> </span><span>=</span><span> </span><span>1</span>
<span>		} </span><span>else</span><span> {</span>
<span>			</span><span>each</span><span>(</span><span>rune</span><span>(c0</span><span>&amp;</span><span>mask4)</span><span>&lt;&lt;</span><span>18</span><span> </span><span>|</span><span> </span><span>rune</span><span>(c1</span><span>&amp;</span><span>maskx)</span><span>&lt;&lt;</span><span>12</span><span> </span><span>|</span><span> </span><span>rune</span><span>(c2</span><span>&amp;</span><span>maskx)</span><span>&lt;&lt;</span><span>6</span><span> </span><span>|</span><span> </span><span>rune</span><span>(c3</span><span>&amp;</span><span>maskx))</span>
<span>		}</span>
<span>		i </span><span>+=</span><span> size</span>
<span>	}</span>
<span>}</span></code></pre>
<p>Without looking at any benchmarks: how well do you think this function fares compared to a more idiomatic iteration using <code>for _, cp := range string(p)</code>? Right, it doesn’t quite keep up. And the reason for that is because the <code>range</code> loop over a string has the body of its iteration inline, so the best case scenario (a pure ASCII string) can be handled without any function calls. On the other hand, our custom function must issue a callback for every single rune.</p>
<p>If we could somehow <em>inline</em> our <code>each</code> callback for our function, we’d be competitive with a <code>range</code> loop for ASCII strings, and probably even <em>faster</em> for Unicode strings! Alas, what would it take for the Go compiler to inline our callback? It’s a very hard problem to solve in the general case. Think about it. The callback we’re passing is not executed in our local function. It is executed inside of <code>ForEachRune</code>, as part of the iteration. In order for the callback to be inlined <em>inside of the iterator</em>, we’d have to instantiate a copy of <code>ForEachRune</code> with our specific callback. But the Go compiler won’t do that. No sensible compiler is going to generate more than one instance of a pure function. Unless…</p>
<p>Unless we trick the compiler into doing it! Because this sure sounds a lot like monomorphization. There’s a pattern as old as time (or at least as old as C++), which is parametrizing a function over the type of the callback it receives. If you’ve ever worked on a C++ codebase, you’ve probably noticed how functions that take callbacks are often generic, with the type of the function callback as a parameter. When the enclosing function is monomorphized, the specific callback for that function invocation is replaced into the IR, and it often becomes <em>trivial</em> to inline – particularly if it’s a pure function (i.e. a callback that does not capture any arguments). Because of this reliable optimization, the combination of lambdas and templates has become a cornerstone zero-cost abstraction in modern C++. It adds a lot of expressiveness to a language just as orthopedic as Go, enabling iteration and other functional constructs without introducing new language syntax nor runtime overhead.</p>
<p>The question is: can we do the same in Go? Can we parametrize a function based on its callback? It turns out we can, although interestingly this is not explained in any of the Generics documentation I’ve found. We can rewrite the signature of our iterator function like this, and it actually <em>compiles and runs</em>:</p>
<pre><code><span>func</span><span> ForEachRune[F </span><span>func</span><span>(</span><span>rune</span><span>)](p []</span><span>byte</span><span>, each F) {</span>
<span>	</span><span>// ...</span>
<span>}</span></code></pre>
<p>Yes, you can use a <code>func</code> signature as a Generic constraint. Constraints do not necessarily need to be an <code>interface</code>. That is something worth keeping in mind.</p>
<p>As for the result of this optimization attempt, I’m not going to include the diassembly here, but if you’ve been following along so far, you’ve probably already guessed that this serves no purpose whatsoever. The shape of the generic function that is instantiated is not specific to our callback. It is a generic shape for a <code>func(rune)</code> callback, that doesn’t allow any kind of inlining. This is another example where more aggressive monomorphization would open up a very interesting optimization opportunity.</p>
<p>So, is that it? Nothing interesting to do with function callbacks? Well, not quite. It turns out that the Go compiler has gotten pretty good with inlining since its 1.0 release. It can do some very powerful stuff these days – when generics don’t get in the way.</p>
<p>Let me show you an example: imagine we’re working on a library to add functional constructs to Go. Why would we do that? I don’t know. Lots of people seem to be doing it. Maybe because it’s trendy. So let’s start with a simple case, a ‘Map’ function that calls a callback on each element of a slice and stores its result in place.</p>

<p>Before we jump into the Generic map (which is the interesting case), let’s look at a <code>MapInt</code> hardcoded to <code>int</code> slices, to see what the Go compiler can do with this code. It turns out it can do a lot: the assembly for <code>MapInt</code> is looking very good. We can see that there are no <code>CALL</code>s in the main <code>IntMapTest</code> from our example: we go <span onmouseover="asmref2(this, 0, 1, true)" onmouseout="asmref2(this, 0, 1, false)">straight from loading the global <code>input1</code> slice</span> to <span onmouseover="asmref2(this, 0, 0, true)" onmouseout="asmref2(this, 0, 0, false)">iterating on it</span>, and the mapping operation (a simple multiplication in this case) <span onmouseover="asmref2(this, 0, 2, true)" onmouseout="asmref2(this, 0, 2, false)">is performed inline with a single instruction</span>. The function has been <em>fully flattened</em>, and both <code>MapInt</code> and the anonymous callback inside of <code>IntMapTest</code> are gone from the codegen.</p>
<p>Should we be impressed about this code generation? It’s a very trivial case after all. Maybe “impressed” is not the right word, but if you’ve been paying attention to the evolution of Go performance over the last decade, you should <em>at least</em> be quite excited!</p>
<p>You see, the simple <code>MapInt</code> function from this example is actually a stress test for the inline heuristics in the Go compiler: it is <em>not</em> a leaf function (because it calls another function inside of it) and it contains a <code>for</code> loop with a <code>range</code>. These two details would have made the function impossible to optimize for every single Go release there’s been until now. <a href="https://docs.google.com/presentation/d/1Wcblp3jpfeKwA0Y4FOmj63PW52M_qmNqlQkNaLj0P5o/edit#slide=id.g1d00ad65a7_2_0">Mid-stack inlining</a> wasn’t stabilized until Go 1.10, and inlining functions that contain <code>for</code> loops <a href="https://github.com/golang/go/issues/14768">has been an issue for more than 6 years</a>. In fact, Go 1.18 is the very first release where a <code>range</code> loop can be inlined, so <code>MapInt</code> would look wildly different if it were compiled just a couple months ago.</p>
<p>This is some very exciting progress when it comes to code generation in the Go compiler, so let’s keep celebrating by looking at the Generic implementation of this very same function and… Oh. Oh no. It’s gone now. Well that’s a bummer. The body of <code>MapAny</code>, thanks to mid-stack inlining, has been <span onmouseover="asmref2(this, 1, 2, true)" onmouseout="asmref2(this, 1, 2, false)">inlined in its parent function</span>. However, the actual callback, which is now behind a generic shape, <span onmouseover="asmref2(this, 1, 3, true)" onmouseout="asmref2(this, 1, 3, false)">has been generated as a free-standing function</span> and <span onmouseover="asmref2(this, 1, 1, true)" onmouseout="asmref2(this, 1, 1, false)">must be called explicitly on each iteration of the loop</span>.</p>
<p>Let’s not despair: what if we attempt the same pattern we’ve just discussed, parametrizing over the type of the callback? That actually does the trick! We’re back to a fully flattened function, but do note that this ain’t magic. Inlining is after all an heuristic, and in this particular example, we’ve tickled the heuristic the right way. Since our <code>MapAny</code> function is simple enough that its whole body can be inlined, all we needed is to add more specificity to the shape of our Generic function. If the callback to our function is not a callback to a generic shape, but a monomorphized instance of a <code>func(rune)</code> callback, that will allow the Go compiler to flatten the whole call. Do you see where I’m going? In this example, inlining the function body is a very special kind of monomorphization. A very aggressive one, because the shape it instantiates is actually a <em>full monomorphization</em>: it can’t be anything else, because the enclosing function is not generic! And when you fully monomorphize code, the Go compiler is capable of performing <em>very</em> interesting optimizations.</p>
<p>To summarize: if you’re writing functional helpers that use callbacks, such as Iterators or Monads, you want to parametrize them on the type of their callbacks. If <em>and only if</em> the helper itself is simple enough be fully inlined, the extra parametrization will tickle the inliner into fully flattening the call, which is <em>exactly what you want</em> for a functional helper. However, if your helper is not simple enough to be inlined, the parametrization will be pointless. The instantiated generic shape will be too coarse to perform any optimization.</p>
<p>Lastly, let me point out that even though this full monomorphization example is probably not reliable in all cases, it does hint at something very hopeful: that the Go compiler has gotten <em>very good</em> at inlining, and that if it gets to deal with very specific code instantiations, it is capable of generating very good assembly. There’s an ocean of optimization opportunities already implemented in the Go compiler that are just waiting for a little push from the Generics implementation to start shining.</p>
<h4>Conclusions</h4>
<p>This was a lot of fun! I hope you had a lot of fun too looking at these assemblies with me. Let’s finish this post with a short list of <strong>DOs</strong> and <strong>DON’Ts</strong> when it comes to performance and Generics in Go 1.18:</p>
<ul>
<li><strong>DO</strong> try to de-duplicate identical methods that take a <code>string</code> and a <code>[]byte</code> using a <code>ByteSeq</code> constraint. The generated shape instantiation is very close to manually writing two almost-identical functions.</li>
<li><strong>DO</strong> use generics in data structures. This is by far their best use case: Generic data structures that were previously implemented using <code>interface{}</code> are complex and un-ergonomic. Removing the type assertions and storing types <em>unboxed</em> in a type-safe way makes these data structures both easier to use and more performant.</li>
<li><strong>DO</strong> attempt to parametrize functional helpers by their callback types. In some cases, it may allow the Go compiler to flatten them.</li>
<li><strong>DO NOT</strong> attempt to use Generics to de-virtualize or inline method calls. It doesn’t work because there’s a single shape for all pointer types that can be passed to the generic function; the associated method information lives in a runtime dictionary.</li>
<li><strong>DO NOT</strong> pass an interface to a generic function, under any circumstances. Because of the way shape instantiation works for interfaces, instead of de-virtualizing, you’re adding another virtualization layer that involves a global hash table lookup for every method call. When dealing with Generics in a performance-sensitive context, use only pointers instead of interfaces.</li>
<li><strong>DO NOT</strong> rewrite interface-based APIs to use Generics. Given the current constraints of the implementation, any code that currently uses non-empty interfaces will behave more predictably, and will be simpler, if it continues using interfaces. When it comes to method calls, Generics devolve pointers into twice-indirect interfaces, and interfaces into… well, something quite horrifying, if I’m being honest.</li>
<li><strong>DO NOT</strong> despair and/or weep profusely, as there is no technical limitation in the language design for Go Generics that prevents an (eventual) implementation that uses monomorphization more aggressively to inline or de-virtualize method calls.</li>
</ul>
<p>Ah well. Overall, this may have been a bit of a disappointment to those who expected to use Generics as a powerful option to optimize Go code, as it is done in other systems languages. We have learned (I hope!) a lot of interesting details about the way the Go compiler deals with Generics. Unfortunately, we have also learned that the implementation shipped in 1.18, more often than not, makes Generic code slower than whatever it was replacing. But as we’ve seen in several examples, it needn’t be this way. Regardless of whether we consider Go as a “systems-oriented” language, it feels like runtime dictionaries was <em>not</em> the right technical implementation choice for a <em>compiled</em> language at all. Despite the low complexity of the Go compiler, it’s clear and measurable that its generated code has been steadily getting better on every release since 1.0, with very few regressions, up until now.</p>
<p>From reading the <a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/generics-implementation-stenciling.md">Risks section in the original proposal for full monomorphization in Go 1.18</a>, it appears the choice of implementing Generics with dictionaries was made because <em>monomorphizing code is slow</em>. But this raises the question: is it, though? How could anybody possibly know that monomorphizing Go code is slow? It has never been done before! In fact, there’s never been any Generic Go code to monomorphize. It feels like a strong guiding factor behind this complex techincal choice were potentially misleading assumptions, which we all hold, such as <em>“monomorphizing C++ code is slow”</em>. This, again, raises the question: is it, though? How much of the C++ compilation overhead comes from monomorphization, as opposed to the performance nightmare that is C++ <code>include</code> processing, or the many optimization passes that are applied on top of the monomorphized code? Would the terrible performance characteristics of C++ template instantiation also apply to the Go compiler, with many fewer optimization passes and a clean module system that could prevent a lot of redundant code generation? And what would the <em>actual</em> performance impact be when compiling large Go projects such as Kubernetes or Vitess? Surely the answer will depend on how often and where are Generics used in these codebases. These are all things that we can start measuring now, but that couldn’t be measured earlier. Likewise, we can now measure the performance impact of stenciling + dictionaries in real world code, like we’re doing in this analysis, and see that we’re paying a hefty performance tax in our programs to speed up the Go compiler.</p>
<p>Considering what we now know, and the limitations that this Generics implementation imposes on its adoption in performance-sensitive code, I can only hope that the choice of using runtime dictionaries to cut on compilation times will be re-evaluated, and that more aggressive monomorphization will come in future Go releases. Introducing Generics into Go has been a titanic task, and while the design of this ambitious feature has been succesful by any measure, the complexity it introduces into the language warrants an equally amibitious implementation. One that can be used in as many contexts as possible, without runtime overhead, and that enables not only <em>parametric polymorphism</em> but deeper optimizations from which a lot of real-world Go applications would benefit.</p>




</div></div></div></div>
  </body>
</html>
