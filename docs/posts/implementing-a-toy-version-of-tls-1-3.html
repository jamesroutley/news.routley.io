<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jvns.ca/blog/2022/03/23/a-toy-version-of-tls/">Original</a>
    <h1>Implementing a toy version of TLS 1.3</h1>
    
    

<p>Hello! Recently I&rsquo;ve been thinking about how I find it fun to learn computer
networking by implementing working versions of real network protocols.</p>

<p>And it made me wonder &ndash; I&rsquo;ve implemented toy versions of
<a href="https://jvns.ca/blog/2013/10/31/day-20-scapy-and-traceroute/">traceroute</a>, <a href="https://jvns.ca/blog/2014/08/12/what-happens-if-you-write-a-tcp-stack-in-python/">TCP</a> and <a href="https://jvns.ca/blog/2022/02/01/a-dns-resolver-in-80-lines-of-go/">DNS</a>.
What about TLS? Could I implement a toy version of that to learn more about how it works?</p>

<p>I asked on Twitter if this would be hard, got <a href="https://twitter.com/Lukasaoz/status/1505593360521777157">some encouragement and pointers for where to start</a>, so I decided to go for it.</p>

<p>This was really fun and I learned a little more about how involved real
cryptography is &ndash; I already 100% believed that I should not invent my own
crypto implementations, and seeing how the crypto in TLS 1.3 works gave me even more of
an appreciation for why I shouldn&rsquo;t :)</p>

<p>As a warning: I am really not a cryptography person, I will probably say some
incorrect things about cryptography in this post and I absolutely do not know
the history of past TLS vulnerabilities that informed TLS 1.3&rsquo;s design.</p>

<p>All of that said, let&rsquo;s go implement some cryptography! All of my hacky code is <a href="https://github.com/jvns/tiny-tls/">on github</a>.</p>

<h3 id="the-simplifications">the simplifications</h3>

<p>I only wanted to work on this for a few days at most, so I needed to make some
pretty dramatic simplifications to make it possible to get it done quickly.</p>

<p>I decided my goal was going to be to download this blog&rsquo;s homepage with TLS. So I
don&rsquo;t need to implement a fully general TLS implementation, I just need to
successfully connect to one website.</p>

<p>Specifically, this means that:</p>

<ul>
<li>I only support one cipher suite</li>
<li>I don&rsquo;t verify the server&rsquo;s certificate at all, I just ignore it</li>
<li>my parsing and message formatting can be extremely janky and fragile because I only need to be able to talk to one specific TLS implementation (and believe me, they are)</li>
</ul>

<h3 id="an-amazing-tls-resource-tls13-ulfheim-net">an amazing TLS resource: tls13.ulfheim.net</h3>

<p>Luckily, before starting this I remembered vaguely that I&rsquo;d seen a website that
explained every single byte in a TLS 1.3 connection, with detailed code examples to
reproduce every part. Some googling revealed that it was <a href="https://tls13.ulfheim.net">The New Illustrated TLS Connection</a>.</p>

<p>I can&rsquo;t stress enough how helpful this was, I looked at probably more than a
hundred times and I only looked at the TLS 1.3 RFC for a few small things.</p>

<h3 id="some-cryptography-basics">some cryptography basics</h3>

<p>Before I started working on this, my understanding of TLS was:</p>

<ol>
<li>at the beginning there&rsquo;s some sort of Diffie-Hellman key exchange</li>
<li>you use the key exchange to somehow (how???) get an AES symmetric key and encrypt the rest of the connection with AES</li>
</ol>

<p>This was sort of right, but it turns out it&rsquo;s more complicated than that.</p>

<p>Okay, let&rsquo;s get into my hacky toy TLS implementation. It hopefully goes without saying that you should absolutely not use this code for anything.</p>

<h3 id="step-1-say-hello">step 1: say hello</h3>

<p>First we need to send a &ldquo;Client Hello&rdquo; message. For my purposes this has just 4 pieces of information in it:</p>

<ol>
<li>A randomly generated public key</li>
<li>32 bytes of random data (the &ldquo;Client Random&rdquo;)</li>
<li>The domain name I want to connect to (<code>jvns.ca</code>)</li>
<li>The cipher suites/signature algorithms we want to use (which I just copied
from tls.ulfheim.net). This negotiation process is pretty important in
general but I&rsquo;m ignoring it because I only support one signature algorithm /
cipher suite.</li>
</ol>

<p>The most interesting part of this to me was part 1 &ndash; how do I generate the public key?</p>

<p>I was confused about this for a while but it ended up being just 2 lines of code.</p>

<pre><code>privateKey := random(32)
publicKey, err := curve25519.X25519(privateKey, curve25519.Basepoint)
</code></pre>

<p>You can see the rest of the code to generate the <a href="https://github.com/jvns/tiny-tls/blob/cb5a3665c3487ad1f1d5f917ad069c93dd44967e/format.go#L41">client hello message here</a>
but it&rsquo;s very boring, it&rsquo;s just a lot of bit fiddling.</p>

<h3 id="elliptic-curve-cryptography-is-cool">elliptic curve cryptography is cool</h3>

<p>I am not going to give an explanation of elliptic curve cryptography here,  but I just want to say how point out how cool it is that you can:</p>

<ul>
<li>generate a random 32-byte string as a private key</li>
<li>&ldquo;multiply&rdquo; the private key by the curve&rsquo;s base point to get the public key (this is elliptic curve &ldquo;multiplication&rdquo;, where <code>n * P</code> means &ldquo;add P to itself n times&rdquo;)</li>
<li>that&rsquo;s it!!</li>
</ul>

<p>I am not going to say more about elliptic curve cryptography here but I love how
simple this is to use &ndash; it seems a lot straightforward than RSA where your
private keys have to be prime numbers.</p>

<p>I don&rsquo;t know if &ldquo;you can generate any 32-byte string as a private key&rdquo; is true
for all elliptic curves or just for this specific elliptic curve (<a href="https://en.wikipedia.org/wiki/Curve25519">Curve25519</a>).</p>

<h3 id="step-2-parse-the-server-hello">step 2: parse the server hello</h3>

<p>Next the server says hello. This is very boring, basically we just need to
parse it to get the server&rsquo;s public key which is 32 bytes. <a href="https://github.com/jvns/tiny-tls/blob/cb5a3665c3487ad1f1d5f917ad069c93dd44967e/format.go#L98-L131">Here&rsquo;s the code though</a>.</p>

<h3 id="step-3-calculate-the-keys-to-encrypt-the-handshake">step 3: calculate the keys to encrypt the handshake</h3>

<p>Now that we have the server&rsquo;s public key and we&rsquo;ve sent the server our public
key, we can start to calculate the keys we&rsquo;re going to use to actually encrypt
data.</p>

<p>I was surprised to learn that there are at least 4 different symmetric keys involved in TLS:</p>

<ul>
<li>client handshake key/iv (for the data the client sends in the handshake)</li>
<li>server handshake key/iv (for the data the server sends in the handshaek)</li>
<li>client application key/iv (for the rest of the data the client sends)</li>
<li>server application key/iv (for the rest of the data the server sends)</li>
<li>I think also another key for session resumption, but I didn&rsquo;t implement that</li>
</ul>

<p>We start out by combining the server&rsquo;s private key and our public key to get a
shared secret. This is called &ldquo;elliptic curve diffie hellman&rdquo; or ECDH and it&rsquo;s
pretty simple: &ldquo;multiply&rdquo; the server&rsquo;s private key by our public key:</p>

<pre><code>sharedSecret, err := curve25519.X25519(session.Keys.Private, session.ServerHello.PublicKey)
</code></pre>

<p>This gives us a 32-byte secret key that both the client and the server has. Yay!</p>

<p>But we need 96 bytes (16 + 12) * 4 of keys in total. That&rsquo;s more than 32 bytes!</p>

<h3 id="time-for-key-derivation">time for key derivation</h3>

<p>Apparently the way you turn a small key into more keys is called &ldquo;key
derivation&rdquo;, and TLS 1.3 uses an algorithm called &ldquo;HKDF&rdquo; to do this. I honestly do not
understand this but here is what my code to do it looks like.</p>

<p>It seems to involve alternately calling <code>hkdf.Expand</code> and <code>hkdf.Extract</code> over and
over again a bunch of times.</p>

<pre><code>func (session *Session) MakeHandshakeKeys() {
	zeros := make([]byte, 32)
	psk := make([]byte, 32)
	// ok so far
	if err != nil {
		panic(err)
	}
	earlySecret := hkdf.Extract(sha256.New, psk, zeros) // TODO: psk might be wrong
	derivedSecret := deriveSecret(earlySecret, &quot;derived&quot;, []byte{})
	session.Keys.HandshakeSecret = hkdf.Extract(sha256.New, sharedSecret, derivedSecret)
	handshakeMessages := concatenate(session.Messages.ClientHello.Contents(), session.Messages.ServerHello.Contents())

	cHsSecret := deriveSecret(session.Keys.HandshakeSecret, &quot;c hs traffic&quot;, handshakeMessages)
	session.Keys.ClientHandshakeSecret = cHsSecret
	session.Keys.ClientHandshakeKey = hkdfExpandLabel(cHsSecret, &quot;key&quot;, []byte{}, 16)
	session.Keys.ClientHandshakeIV = hkdfExpandLabel(cHsSecret, &quot;iv&quot;, []byte{}, 12)

	sHsSecret := deriveSecret(session.Keys.HandshakeSecret, &quot;s hs traffic&quot;, handshakeMessages)
	session.Keys.ServerHandshakeKey = hkdfExpandLabel(sHsSecret, &quot;key&quot;, []byte{}, 16)
	session.Keys.ServerHandshakeIV = hkdfExpandLabel(sHsSecret, &quot;iv&quot;, []byte{}, 12)
}
</code></pre>

<p>This was pretty annoying to get working because I kept passing the wrong
arguments to things. The only reason I managed it was because
<a href="https://tls13.ulfheim.net">https://tls13.ulfheim.net</a> provided a bunch of example inputs and outputs and
example code so I was able to write some unit tests and check my code against
the site&rsquo;s example implementation.</p>

<p>Anyway, eventually I got all my keys calculated and it was time to start decrypting!</p>

<h3 id="an-aside-on-ivs">an aside on IVs</h3>

<p>For each key there&rsquo;s also an &ldquo;IV&rdquo; which stands for &ldquo;initialization vector&rdquo;. The
idea seems to be to use a different initialization vector for every message we
encrypt/decrypt, for More Security &trade;.</p>

<p>In this implementation the way we get a different IV for each message is by
xoring the IV with the number of messages sent/received so far.</p>

<h3 id="step-4-write-some-decryption-code">step 4: write some decryption code</h3>

<p>Now that we have all these keys and IVs, we can write a <code>decrypt</code> function.</p>

<p>I thought that TLS just used AES, but apparently it uses something called
&ldquo;authentication encryption&rdquo; on top of AES that I hadn&rsquo;t heard of before.</p>

<p>The wikipedia article explanation of authenticated encryption is actually pretty clear:</p>

<blockquote>
<p>&hellip; authenticated encryption can provide security against <strong>chosen ciphertext</strong> attack. In these attacks, an adversary attempts to gain an advantage against a cryptosystem (e.g., information about the secret decryption key) by submitting carefully chosen ciphertexts to some &ldquo;decryption oracle&rdquo; and analyzing the decrypted results. Authenticated encryption schemes can recognize improperly-constructed ciphertexts and refuse to decrypt them. This, in turn, prevents the attacker from requesting the decryption of any ciphertext unless it was generated correctly using the encryption algorithm</p>
</blockquote>

<p>This makes sense to me because I did some of the cryptopals challenges and there&rsquo;s an attack a bit like this in <a href="https://cryptopals.com/sets/2/challenges/14">cryptopals set 2</a> (I don&rsquo;t know if it&rsquo;s the exact same thing).</p>

<p>Anyway, here&rsquo;s some code that uses authenticated encryption the way the TLS 1.3
spec says it should. I think GCM is an authenticated encryption algorithm.</p>

<pre><code>func decrypt(key, iv, wrapper []byte) []byte {

	block, err := aes.NewCipher(key)
	if err != nil {
		panic(err.Error())
	}

	aesgcm, err := cipher.NewGCM(block)
	if err != nil {
		panic(err.Error())
	}

	additional := wrapper[:5]
	ciphertext := wrapper[5:]

	plaintext, err := aesgcm.Open(nil, iv, ciphertext, additional)
	if err != nil {
		panic(err.Error())
	}
	return plaintext
}
</code></pre>

<h3 id="step-5-decrypt-the-server-handshake">step 5: decrypt the server handshake</h3>

<p>Next the server sends some more handshake data. This contains the certificate
and some other stuff.</p>

<p>Here&rsquo;s my code for decrypting the handshake. Basically it just reads the
encrypted data from the network, decrypts it, and saves it.</p>

<pre><code>record := readRecord(session.Conn)
if record.Type() != 0x17 {
    panic(&quot;expected wrapper&quot;)
}
session.Messages.ServerHandshake = decrypt(session.Keys.ServerHandshakeKey, session.Keys.ServerHandshakeIV, record)
</code></pre>

<p>You might notice that we don&rsquo;t actually <em>parse</em> this data at all &ndash; that&rsquo;s
because we don&rsquo;t need the contents, since we&rsquo;re not verifying the server&rsquo;s
certificate.</p>

<p>We do need it for the next step though.</p>

<h3 id="step-6-derive-more-keys">step 6: derive more keys</h3>

<p>We use a hash of the SHA256 handshake data we just got from the server to
generate even more symmetric keys. This is almost the last step!</p>

<p>This is almost exactly the same as the key derivation code from before, but I&rsquo;m
including it because I was surprised by how much work needed to be done to generate all these keys.</p>

<pre><code>func (session *Session) MakeApplicationKeys() {
    handshakeMessages := concatenate(
        session.Messages.ClientHello.Contents(),
        session.Messages.ServerHello.Contents(),
        session.Messages.ServerHandshake.Contents())

    zeros := make([]byte, 32)
    derivedSecret := deriveSecret(session.Keys.HandshakeSecret, &quot;derived&quot;, []byte{})
    masterSecret := hkdf.Extract(sha256.New, zeros, derivedSecret)

    cApSecret := deriveSecret(masterSecret, &quot;c ap traffic&quot;, handshakeMessages)
    session.Keys.ClientApplicationKey = hkdfExpandLabel(cApSecret, &quot;key&quot;, []byte{}, 16)
    session.Keys.ClientApplicationIV = hkdfExpandLabel(cApSecret, &quot;iv&quot;, []byte{}, 12)

    sApSecret := deriveSecret(masterSecret, &quot;s ap traffic&quot;, handshakeMessages)
    session.Keys.ServerApplicationKey = hkdfExpandLabel(sApSecret, &quot;key&quot;, []byte{}, 16)
    session.Keys.ServerApplicationIV = hkdfExpandLabel(sApSecret, &quot;iv&quot;, []byte{}, 12)
}
</code></pre>

<h3 id="step-7-finish-the-handshake">step 7: finish the handshake</h3>

<p>Next we need to send a &ldquo;handshake finished&rdquo; message to the server to verify that everything is done. That code is <a href="https://github.com/jvns/tiny-tls/blob/cb5a3665c3487ad1f1d5f917ad069c93dd44967e/crypto.go#L177-L183">here</a>.</p>

<p>And now we&rsquo;re done the handshake! That was the hard part, sending and receiving
the data is relatively easy.</p>

<h3 id="step-8-make-a-http-request">step 8: make a HTTP request</h3>

<p>I wrote a <code>SendData</code> function that encrypts and sends data using our keys. This time we&rsquo;re using the &ldquo;application&rdquo; keys and not the handshake keys. This made making a HTTP request pretty simple:</p>

<pre><code>req := fmt.Sprintf(&quot;GET / HTTP/1.1\r\nHost: %s\r\n\r\n&quot;, domain)
session.SendData([]byte(req))
</code></pre>

<h3 id="step-9-we-can-actually-decrypt-the-response">step 9: we can actually decrypt the response!!!</h3>

<p>Now comes the moment I&rsquo;d been waiting for &mdash; actually decrypting the response
from the server!!! But here I needed to learn something else about TLS.</p>

<h3 id="tls-data-comes-in-blocks">TLS data comes in blocks</h3>

<p>I previously thought that once you established the connection, encrypted TLS
data was just a stream. But that&rsquo;s not how it works &ndash; instead, it&rsquo;s
transmitted in blocks. Like, you&rsquo;ll get a chunk of ~1400 bytes to decrypt, and
then another chunk, and then another chunk.</p>

<p>I&rsquo;m not sure why the blocks have the size they do (maybe it&rsquo;s so that each one will fit inside a TCP
packet ???), but in theory I think they could be up to 65535 bytes, since their
size field is 2 bytes. The blocks I got were all 1386 bytes each.</p>

<p>Every time we get a block, we have to:</p>

<ul>
<li>calculate a new IV as <code>old_iv xor num_records_received</code></li>
<li>decrypt it using the key and the new IV</li>
<li>increment the count of records received</li>
</ul>

<p>Here&rsquo;s what the <code>ReceiveData()</code> function I wrote looks like.</p>

<p>The most interesting part of this is the <code>iv[11] ^= session.RecordsReceived</code> &ndash;
that&rsquo;s the part that adjusts the IV for each block.</p>

<pre><code>func (session *Session) ReceiveData() []byte {
	record := readRecord(session.Conn)
	iv := make([]byte, 12)
	copy(iv, session.Keys.ServerApplicationIV)
	iv[11] ^= session.RecordsReceived
	plaintext := decrypt(session.Keys.ServerApplicationKey, iv, record)
	session.RecordsReceived += 1
	return plaintext
}
</code></pre>

<p>This <code>iv[11]</code> thing assumes that there are less than 255 blocks which obviously
is not true in general in TLS, but I was lazy and to download my blog&rsquo;s
homepage I only needed 82 blocks.</p>

<p>We actually have to do this when we send data too, but I didn&rsquo;t implement it
because we only sent 1 packet.</p>

<h3 id="problem-getting-the-whole-block-of-tls-data">problem: getting the whole block of tLS data</h3>

<p>I ran into one problem with TCP where sometimes I&rsquo;d try to read a block of TLS
data (~1386 bytes), but I wouldn&rsquo;t get the whole thing. I guess the TLS blocks
can be split up across multiple TCP packets.</p>

<p>I fixed this in a really dumb way, by just polling the TCP connection in a loop
until it gave me the data I wanted. Here&rsquo;s my code to do that:</p>

<pre><code>func read(length int, reader io.Reader) []byte {
	var buf []byte
	for len(buf) != length {
		buf = append(buf, readUpto(length-len(buf), reader)...)
	}
	return buf
}
</code></pre>

<p>I assume a real TLS implementation would use a thread pool or coroutines or
something to manage this.</p>

<h3 id="step-10-knowing-when-we-re-done">step 10: knowing when we&rsquo;re done</h3>

<p>When the HTTP response is done, we get these bytes: <code>[]byte{48, 13, 10, 13, 10, 23}</code>.
I don&rsquo;t know what this is supposed to mean exactly but it seems to signal
the end of the connection.</p>

<p>So here&rsquo;s the code to receive the HTTP response. Basically we just loop until
we see those bytes, then we stop.</p>

<pre><code>func (session *Session) ReceiveHTTPResponse() []byte {
	var response []byte
	for {
		pt := session.ReceiveData()
		if string(pt) == string([]byte{48, 13, 10, 13, 10, 23}) {
			break
		}
		response = append(response, pt...)
	}
	return response
}
</code></pre>

<h3 id="that-s-it">that&rsquo;s it!</h3>

<p>Finally, I ran the program and I downloaded my blog&rsquo;s homepage! It worked! Here&rsquo;s what the results look like:</p>

<pre><code>$ go build; ./tiny-tls
HTTP/1.1 200 OK
Date: Wed, 23 Mar 2022 19:37:47 GMT
Content-Type: text/html
Transfer-Encoding: chunked
Connection: keep-alive
... lots more headers and HTML follow...
</code></pre>

<p>Okay, the results are kind of anticlimactic, it&rsquo;s just the same as what you&rsquo;d
see if you ran <code>curl -i https://jvns.ca</code> except with no formatting. But I was
extremely excited when I saw it.</p>

<h3 id="the-block-thing-is-kind-of-weird">the block thing is kind of weird</h3>

<p>I find it a bit weird that TLS data is sent/received in blocks. I assume it
makes sense from a cryptography perspective (because you want to change your
IVs frequently or something?).</p>

<p>But from a networking perspective it feels a bit strange. Like, TCP is built on
top of a packet system, and then with TLS you sort of have another packet
system on top of TCP.</p>

<p>Maybe one of the motivations for QUIC is to design a network protocol which has
TLS as more of a first-class citizen, so you don&rsquo;t have this weird
packet/stream/packet thing?</p>

<h3 id="some-things-i-learned">some things I learned</h3>

<p>This was really fun! I learned that</p>

<ul>
<li>elliptic curve diffie-hellman is very cool, and at least with Curve25519 you can use literally any 32-byte string as a private key</li>
<li>there are a LOT of different symmetric keys involved in TLS and the key derivation process is pretty complicated</li>
<li>TLS uses AES with some extra &ldquo;authenticated encryption&rdquo; algorithms on top</li>
<li>TLS data is sent/received as a bunch of blocks, not as a stream</li>
</ul>

<p>I won&rsquo;t pretend to understand all the reasons TLS is designed this way, but it
was a fun way to spend a couple of days, I feel a little more informed, and I
think it&rsquo;ll be easier for me to understand things I read about TLS in the
future.</p>

  </body>
</html>
