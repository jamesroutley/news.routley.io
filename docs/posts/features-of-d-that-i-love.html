<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bradley.chatha.dev/blog/dlang-propaganda/features-of-d-that-i-love/">Original</a>
    <h1>Features of D That I Love</h1>
    
    <div id="readability-page-1" class="page"><div> <section>  <section> <a href="https://bradley.chatha.dev/blog/dlang-propaganda">  </a> </section>  <p>This is a beginner-friendly post exploring some of my favourite parts of the <a href="https://dlang.org/">D programming language</a>, ranging from smaller quality of life stuff, to more major features.</p>
<p>I <em>won’t</em> talk much about D’s metaprogramming in this post as that topic basically requires its own dedicated feature list, but I still want to mention that D’s metaprogramming is world class - allowing a level of flexibility &amp; modelling power that few statically compiled languages are able to rival.</p>
<p>I’ll be providing some minimal code snippets to demonstrate each feature, but this is by no means an in depth technical post, but more of an easy to read “huh, that’s neat/absolutely abhorrent!” sort of deal.</p>
<h2 id="summary">Summary</h2>
<ul>
<li><a href="#feature---automatic-constructors">Feature - Automatic constructors</a></li>
<li><a href="#feature---design-by-contract">Feature - Design by contract</a></li>
<li><a href="#syntax---the-dollar-operator">Syntax - The dollar operator</a></li>
<li><a href="#feature---ctfe-compile-time-function-execution">Feature - CTFE (Compile Time Function Execution)</a></li>
<li><a href="#feature---built-in-unittests">Feature - Built-in unittests</a></li>
<li><a href="#feature---exhaustive-switch-statements">Feature - Exhaustive switch statements</a></li>
<li><a href="#syntax---parenthesis-omission">Syntax - Parenthesis omission</a></li>
<li><a href="#syntax---ufcs-uniform-function-call-syntax">Syntax - UFCS (Uniform Function Call Syntax)</a></li>
<li><a href="#feature---scoped--selective-imports">Feature - Scoped &amp; Selective Imports</a></li>
<li><a href="#feature---built-in-documentation-generator">Feature - Built-in documentation generator</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<h2 id="feature---automatic-constructors">Feature - Automatic constructors</h2>
<p>If you define a struct (by-value object) without an explicit constructor, the compiler will automatically generate one for you based on the lexical order of the struct’s fields.</p>
<div><figure><pre data-language="d"><code><div><p><span>struct</span><span> </span><span>Vector2</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>int</span><span> </span><span>a</span><span>;</span></p></div><div><p><span>    </span><span>int</span><span> </span><span>b</span><span>;</span></p></div><div></div><div><p><span>    </span><span>/++ Automatically generates this constructor:</span></p></div><div></div><div><p><span><span>    </span></span><span>this(int a = int.init, int b = int.init)</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span><span>        </span></span><span>this.a = a;</span></p></div><div><p><span><span>        </span></span><span>this.b = b;</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span><span>    </span></span><span>++/</span></p></div><div><p><span>}</span></p></div><div></div><div><p><span>void</span><span> </span><span>main</span><span>()</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>const</span><span> </span><span>noParams</span><span> </span><span>=</span><span> </span><span>Vector2</span><span>();</span></p></div><div><p><span>    </span><span>const</span><span> </span><span>oneParam</span><span> </span><span>=</span><span> </span><span>Vector2</span><span>(</span><span>20</span><span>); </span><span>// Sets .a to `20`</span></p></div><div><p><span>    </span><span>const</span><span> </span><span>twoParams</span><span> </span><span>=</span><span> </span><span>Vector2</span><span>(</span><span>20</span><span>,</span><span> </span><span>40</span><span>); </span><span>// Sets .a to `20` and .b to `40`</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>Very handy for Plain Old Data types, especially with the semi-recent support for <a href="https://dlang.org/spec/expression.html#argument-parameter-matching">named parameters</a>.</p>
<h2 id="feature---design-by-contract">Feature - Design by contract</h2>
<p>D supports <a href="https://en.wikipedia.org/wiki/Design_by_contract">contract programming</a> which allows functions to define:</p>
<ul>
<li>“in” assertions to confirm that the function’s parameters are valid.</li>
<li>“out” assertions to confirm that the function’s return value is in a valid state.</li>
</ul>
<p>Additionally you can attach “invariants” onto structs and classes. Invariants are functions that run at the start and end of every <strong>public</strong> member function, and can be used to ensure that the type is always in a valid state.</p>
<p>Let’s start off with a contrived example of invariants:</p>
<div><figure><pre data-language="d"><code><div><p><span>// Example of invariants</span></p></div><div><p><span>struct</span><span> </span><span>PositiveBound</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>private</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>int</span><span> </span><span>_lower</span><span>;</span></p></div><div><p><span>        </span><span>int</span><span> </span><span>_upper</span><span>;</span></p></div><div></div><div><p><span>        </span><span>// Arbitrary function syntax</span></p></div><div><p><span>        </span><span>invariant</span></p></div><div><p><span><span>        </span></span><span>{</span></p></div><div><p><span>            </span><span>assert(</span><span>_lower</span><span> </span><span>&gt;=</span><span> </span><span>0</span><span>,</span><span> </span><span>&#34;_lower must not be negative&#34;</span><span>)</span><span>;</span></p></div><div><p><span>            </span><span>assert(</span><span>_upper</span><span> </span><span>&gt;=</span><span> </span><span>0</span><span>,</span><span> </span><span>&#34;_upper must not be negative&#34;</span><span>)</span><span>;</span></p></div><div><p><span><span>        </span></span><span>}</span></p></div><div></div><div><p><span>        </span><span>// Short hand syntax, translates to a single `assert()`.</span></p></div><div><p><span>        </span><span>invariant</span><span>(</span><span>_upper</span><span> </span><span>&gt;=</span><span> </span><span>_lower</span><span>,</span><span> </span><span>&#34;_upper must not be less than _lower&#34;</span><span>);</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span>    </span><span>this</span><span>(</span><span>int</span><span> </span><span>lower</span><span>,</span><span> </span><span>int</span><span> </span><span>upper</span><span>)</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>// invariants don&#39;t run at the start of constructors.</span></p></div><div></div><div><p><span>        </span><span>this</span><span>._lower</span><span> </span><span>=</span><span> </span><span>lower</span><span>;</span></p></div><div><p><span>        </span><span>this</span><span>._upper</span><span> </span><span>=</span><span> </span><span>upper</span><span>;</span></p></div><div></div><div><p><span>        </span><span>// invariants are called.</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span>    </span><span>void</span><span> </span><span>upper</span><span>(</span><span>int</span><span> </span><span>upper</span><span>)</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>// invariants are called.</span></p></div><div></div><div><p><span>        </span><span>this</span><span>._upper</span><span> </span><span>=</span><span> </span><span>upper</span><span>;</span></p></div><div></div><div><p><span>        </span><span>// invariants are called again.</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span>    </span><span>private</span><span> </span><span>void</span><span> </span><span>setLower</span><span>(</span><span>int</span><span> </span><span>lower</span><span>)</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>// Function is non-public, invariants aren&#39;t called.</span></p></div><div><p><span>        </span><span>this</span><span>._lower</span><span> </span><span>=</span><span> </span><span>lower</span><span>;</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>Now let’s rewrite the above type to use “in” contracts instead, with an extra function to show off “out” contracts:</p>
<div><figure><pre data-language="d"><code><div><p><span>// Example of in/out contracts</span></p></div><div><p><span>struct</span><span> </span><span>PositiveBound</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>private</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>int</span><span> </span><span>_lower</span><span>;</span></p></div><div><p><span>        </span><span>int</span><span> </span><span>_upper</span><span>;</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span>    </span><span>this</span><span>(</span><span>int</span><span> </span><span>lower</span><span>,</span><span> </span><span>int</span><span> </span><span>upper</span><span>)</span></p></div><div><p><span>    </span><span>in</span><span>(</span><span>lower</span><span> </span><span>&gt;=</span><span> </span><span>0</span><span>,</span><span> </span><span>&#34;lower must not be negative&#34;</span><span>)</span></p></div><div><p><span>    </span><span>in</span><span>(</span><span>upper</span><span> </span><span>&gt;=</span><span> </span><span>lower</span><span>,</span><span> </span><span>&#34;upper must not be less than lower&#34;</span><span>)</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>// `in` functions are called.</span></p></div><div><p><span>        </span><span>this</span><span>._lower</span><span> </span><span>=</span><span> </span><span>lower</span><span>;</span></p></div><div><p><span>        </span><span>this</span><span>._upper</span><span> </span><span>=</span><span> </span><span>upper</span><span>;</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span>    </span><span>void</span><span> </span><span>upper</span><span>(</span><span>int</span><span> </span><span>upper</span><span>)</span></p></div><div><p><span>    </span><span>in</span><span>(</span><span>upper</span><span> </span><span>&gt;=</span><span> </span><span>this</span><span>._lower</span><span>,</span><span> </span><span>&#34;upper must not be less than lower&#34;</span><span>)</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>this</span><span>._upper</span><span> </span><span>=</span><span> </span><span>upper</span><span>;</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span>    </span><span>private</span><span> </span><span>void</span><span> </span><span>setLower</span><span>(</span><span>int</span><span> </span><span>lower</span><span>)</span></p></div><div><p><span>    </span><span>in</span><span>(</span><span>lower</span><span> </span><span>&gt;=</span><span> </span><span>0</span><span>,</span><span> </span><span>&#34;lower must not be negative&#34;</span><span>)</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>this</span><span>._lower</span><span> </span><span>=</span><span> </span><span>lower</span><span>;</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span>    </span><span>int</span><span> </span><span>numbersInRange</span><span>()</span></p></div><div><p><span>    </span><span>out(</span><span>result</span><span>; </span><span>result</span><span> &gt;= </span><span>0</span><span>, &#34;</span><span>result</span><span> </span><span>is</span><span> </span><span>somehow</span><span> </span><span>negative</span><span>?&#34;</span><span>)</span></p></div><div><p><span>    </span><span>out(</span><span>result</span><span>; </span><span>this._upper</span><span> == </span><span>this._lower</span><span> || </span><span>result</span><span> != </span><span>0</span><span>, &#34;</span><span>upper</span><span> </span><span>and</span><span> </span><span>lower</span><span> </span><span>are</span><span> </span><span>different</span><span> </span><span>numbers</span><span>, </span><span>but</span><span> </span><span>result</span><span> </span><span>is</span><span> </span><span>somehow</span><span> </span><span>0</span><span>?&#34;</span><span>)</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>return</span><span> </span><span>this</span><span>._upper</span><span> </span><span>-</span><span> </span><span>this</span><span>._lower</span><span>; </span><span>// `out` functions are called, with (this._upper - this._lower) as their parameter.</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>This can allow for an easy self-descriptive validation pattern for consumers/readers of your code, as well as an easy to implement self-checking mechanism for types that have complex internals.</p>
<p>Anecdotally I find this to be an underutilised feature of D, and it’s one I like to make use of a lot in my own code.</p>
<h2 id="syntax---the-dollar-operator">Syntax - The dollar operator</h2>
<p>A lot of languages do not provide a shorthand syntax for referencing the length of an array, which can sometimes lead to awkward looking code when e.g. slicing arrays (any Go enjoyers here?).</p>
<p>D provides the dollar operator, which is a shorthand syntax for referencing the length of something.</p>
<div><figure><pre data-language="d"><code><div><p><span>auto</span><span> </span><span>foo</span><span> </span><span>=</span><span> [</span><span>0</span><span>,</span><span> </span><span>1</span><span>,</span><span> </span><span>2</span><span>,</span><span> </span><span>3</span><span>,</span><span> </span><span>4</span><span>,</span><span> </span><span>5</span><span>,</span><span> </span><span>6</span><span>,</span><span> </span><span>7</span><span>,</span><span> </span><span>8</span><span>,</span><span> </span><span>9</span><span>,</span><span> </span><span>10</span><span>];</span></p></div><div><p><span>auto</span><span> </span><span>bar</span><span> </span><span>=</span><span> </span><span>foo</span><span>[</span><span>5</span><span>..$-</span><span>2</span><span>]; </span><span>// Same as: foo[5..foo.length-2]</span></p></div></code></pre></figure></div>
<p>Structs and classes can even <a href="https://dlang.org/spec/operatoroverloading.html#dollar">overload</a> this operator.</p>
<h2 id="feature---ctfe-compile-time-function-execution">Feature - CTFE (Compile Time Function Execution)</h2>
<p>D compilers provide an interpreter for the language which allows a very large amount of D code to be ran at compile time, as-is, without any special marking or other weirdness to go with it.</p>
<p>Generally, anywhere where the language requires a compile-time constant is a place where CTFE will transparently come into play.</p>
<div><figure><pre data-language="d"><code><div><p><span>import</span><span> </span><span>std.algorithm</span><span> : </span><span>filter</span><span>;</span></p></div><div><p><span>import</span><span> </span><span>std.array</span><span>     : </span><span>array</span><span>;</span></p></div><div><p><span>import</span><span> </span><span>std.range</span><span>     : </span><span>iota</span><span>;</span></p></div><div></div><div><p><span>// As we&#39;re setting a global variable, the value must be a compile-time constant.</span></p></div><div><p><span>//</span></p></div><div><p><span>// Due to CTFE, we can just use normal D functions to compute a value for us.</span></p></div><div><p><span>immutable</span><span> </span><span>ALL_EVEN_NUMBERS_UNDER_1000</span><span> </span><span>=</span><span> </span><span>iota</span><span>(</span><span>0</span><span>,</span><span> </span><span>1000</span><span>).</span><span>filter</span><span>!(</span><span>n</span><span> =&gt; </span><span>n</span><span> </span><span>%</span><span> </span><span>2</span><span> </span><span>==</span><span> </span><span>0</span><span>).</span><span>array</span><span>;</span></p></div><div></div><div><p><span>// pragma(msg) can write to stdout during compile time, thus requiring a compile-time constant.</span></p></div><div><p><span>// We can use this to confirm that everything is only happening during compilation.</span></p></div><div><p><span>pragma(msg, </span><span>ALL_EVEN_NUMBERS_UNDER_1000</span><span>)</span><span>; </span><span>// [0, 2, 4, 8, ...</span></p></div></code></pre></figure></div>
<p>This feature has a lot of different practical applications, and can allow for much cleaner, robust code than hardcoding precomputed values.</p>
<p>Since a lot of use cases relate to metaprogramming I’ll leave the topic here, but CTFE is an extremely instant example of D’s unusual feature set.</p>
<h2 id="feature---built-in-unittests">Feature - Built-in unittests</h2>
<p>D has direct support for defining unittests, and even allows you to override the built-in test runner for something more robust (such as with the <a href="https://code.dlang.org/packages/unit-threaded">unit-threaded</a> library).</p>
<p>D code usually bundles unittests and normal code within the same file, rather than splitting them out into separate files as with most other languages:</p>
<div><figure><pre data-language="d"><code><div><p><span>int</span><span> </span><span>add</span><span>(</span><span>int</span><span> </span><span>a</span><span>,</span><span> </span><span>int</span><span> </span><span>b</span><span>) </span><span>=&gt;</span><span> </span><span>a</span><span> </span><span>+</span><span> </span><span>b</span><span>;</span></p></div><div><p><span>unittest</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>assert(</span><span>add</span><span>(</span><span>60</span><span> </span><span>+</span><span> </span><span>8</span><span>) </span><span>==</span><span> </span><span>68</span><span>,</span><span> </span><span>&#34;60 + 8 is somehow not equal to 68&#34;</span><span>)</span><span>;</span></p></div><div><p><span>}</span></p></div><div></div><div><p><span>// If you give a unittest an empty documentation comment (`///`), then D&#39;s built in documentation</span></p></div><div><p><span>// generator will generate an &#34;example&#34; block using the test code!</span></p></div><div></div><div><p><span>int</span><span> </span><span>sub</span><span>(</span><span>int</span><span> </span><span>a</span><span>,</span><span> </span><span>int</span><span> </span><span>b</span><span>) </span><span>=&gt;</span><span> </span><span>a</span><span> </span><span>-</span><span> </span><span>b</span><span>;</span></p></div><div><p><span>///</span></p></div><div><p><span>unittest</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>assert(</span><span>sub</span><span>(</span><span>70</span><span>,</span><span> </span><span>2</span><span>) </span><span>==</span><span> </span><span>68</span><span>)</span><span>;</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>This extremely low-friction barrier for writing tests is a godsend for motivating people to write even the most minimal of tests.</p>
<p>Of course if you have more complex needs then the option to have a proper testing framework + structure is still available to you, but the vast majority of D code I’ve seen simply uses <code>unittest</code> blocks, optionally with a library that provides a better test runner.</p>
<h2 id="feature---exhaustive-switch-statements">Feature - Exhaustive switch statements</h2>
<p>D provides a <code>final switch</code> statement which has an autogenerated <code>default:</code> case that will immediately crash the program if its taken.</p>
<p>This allows you to define a switch that will always alert you if a new value needs to be added, or if an invalid value was somehow passed into it.</p>
<p>Additionally, if you use a <code>final switch</code> with an <code>enum</code> value, then a compile-time check is triggered to ensure that every value within the <code>enum</code> type has been declared, making it impossible to forget to add a new case when the enum is modified.</p>
<div><figure><pre data-language="d"><code><div><p><span>enum</span><span> </span><span>OutputType</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>file</span><span>,</span></p></div><div><p><span>    </span><span>stdout</span></p></div><div><p><span>}</span></p></div><div></div><div><p><span>void</span><span> </span><span>main</span><span>()</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>auto</span><span> </span><span>output</span><span> </span><span>=</span><span> </span><span>OutputType.stdout</span><span>;</span></p></div><div></div><div><p><span>    </span><span>// Exhaustive switching with a compile time check.</span></p></div><div><p><span>    </span><span>final switch</span><span>(</span><span>output</span><span>)</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>case</span><span> </span><span>OutputType.file</span><span>:</span></p></div><div><p><span>            </span><span>// ...</span></p></div><div><p><span>            </span><span>break</span><span>;</span></p></div><div></div><div><p><span>        </span><span>case</span><span> </span><span>OutputType.stdout</span><span>:</span></p></div><div><p><span>            </span><span>// ...</span></p></div><div><p><span>            </span><span>break</span><span>;</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span>    </span><span>// Exhausitve switching with no compile time check, may trigger a `SwitchError` at runtime.</span></p></div><div><p><span>    </span><span>auto</span><span> </span><span>str</span><span> </span><span>=</span><span> </span><span>&#34;not my string&#34;</span><span>;</span></p></div><div><p><span>    </span><span>final switch</span><span>(</span><span>str</span><span>)</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>case</span><span> </span><span>&#34;my string&#34;</span><span>:</span></p></div><div><p><span>            </span><span>// ...</span></p></div><div><p><span>            </span><span>break</span><span>;</span></p></div><div></div><div><p><span>        </span><span>// Any other value will crash the program (unless the SwitchError is caught, which you shouldn&#39;t do outside of tests).</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<h2 id="syntax---parenthesis-omission">Syntax - Parenthesis omission</h2>
<p>D allows you to omit parentheses when calling functions in multiple contexts.</p>
<p>When calling a function with no parameters, you can omit them:</p>
<div><figure><pre data-language="d"><code><div><p><span>struct</span><span> </span><span>Person</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>private</span><span> </span><span>string</span><span> </span><span>_name</span><span>;</span></p></div><div></div><div><p><span>    </span><span>string</span><span> </span><span>name</span><span>() </span><span>=&gt;</span><span> </span><span>this</span><span>._name</span><span>;</span></p></div><div><p><span>}</span></p></div><div></div><div><p><span>void</span><span> </span><span>main</span><span>()</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>import</span><span> </span><span>std.stdio</span><span> : </span><span>writeln</span><span>;</span></p></div><div></div><div><p><span>    </span><span>auto</span><span> </span><span>person</span><span> </span><span>=</span><span> </span><span>Person</span><span>(</span><span>&#34;Brad&#34;</span><span>);</span></p></div><div><p><span>    </span><span>writeln</span><span>(</span><span>person.name</span><span>); </span><span>// Instead of: writeln(person.name())</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>(Marginally related) When calling a function with 1 parameter, you may use assignment syntax instead:</p>
<div><figure><pre data-language="d"><code><div><p><span>struct</span><span> </span><span>Person</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>private</span><span> </span><span>string</span><span> </span><span>_name</span><span>;</span></p></div><div></div><div><p><span>    </span><span>void</span><span> </span><span>name</span><span>(</span><span>string</span><span> </span><span>name</span><span>)</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>this</span><span>._name</span><span> </span><span>=</span><span> </span><span>name</span><span>;</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div><p><span>}</span></p></div><div></div><div><p><span>void</span><span> </span><span>main</span><span>()</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>Person</span><span> </span><span>person</span><span>;</span></p></div><div><p><span>    </span><span>person.name</span><span> </span><span>=</span><span> </span><span>&#34;Brad&#34;</span><span>; </span><span>// Instead of: person.name(&#34;Brad&#34;)</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>When passing a single template parameter which consists of only 1 lexical token, you may omit the parenthesis:</p>
<div><figure><pre data-language="d"><code><div><p><span>import</span><span> </span><span>std.conv</span><span> : </span><span>to</span><span>;</span></p></div><div></div><div><p><span>void</span><span> </span><span>main</span><span>()</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>auto</span><span> </span><span>number</span><span> </span><span>=</span><span> </span><span>&#34;20&#34;</span><span>.</span><span>to</span><span>!int</span><span>; </span><span>// Instead of &#34;20.to!(int)&#34; or &#34;20.to!(int)()&#34;</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>This can do wonders for readability.</p>
<h2 id="syntax---ufcs-uniform-function-call-syntax">Syntax - UFCS (Uniform Function Call Syntax)</h2>
<p>UFCS allows call chains to be “inverted” by allowing freestanding functions to be used as if they were a member of their first parameter.</p>
<p>In other words: <code>baz(bar(foo))</code> can be rewritten as <code>foo.bar().baz()</code>.</p>
<p>The two following snippets are completely equivalent in function, except the second snippet uses UFCS to provide a more clean look.</p>
<div><figure><pre data-language="d"><code><div><p><span>import</span><span> </span><span>std.algorithm</span><span> : </span><span>filter</span><span>,</span><span> </span><span>map</span><span>;</span></p></div><div><p><span>import</span><span> </span><span>std.range</span><span>     : </span><span>iota</span><span>;</span></p></div><div><p><span>import</span><span> </span><span>std.stdio</span><span>     : </span><span>writeln</span><span>;</span></p></div><div></div><div><p><span>// Without UFCS</span></p></div><div><p><span>void</span><span> </span><span>main</span><span>()</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>writeln</span><span>(</span><span>map</span><span>!</span><span>(</span><span>num</span><span> =&gt; </span><span>num</span><span> </span><span>*</span><span> </span><span>2</span><span>)(</span></p></div><div><p><span>        </span><span>filter</span><span>!</span><span>(</span><span>num</span><span> =&gt; </span><span>num</span><span> </span><span>%</span><span> </span><span>2</span><span> </span><span>==</span><span> </span><span>0</span><span>)(</span></p></div><div><p><span>            </span><span>iota</span><span>(</span><span>0</span><span>,</span><span> </span><span>10_000</span><span>)</span></p></div><div><p><span><span>        </span></span><span>)</span></p></div><div><p><span><span>    </span></span><span>));</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<div><figure><pre data-language="d"><code><div><p><span>import</span><span> </span><span>std.algorithm</span><span> : </span><span>filter</span><span>,</span><span> </span><span>map</span><span>;</span></p></div><div><p><span>import</span><span> </span><span>std.range</span><span>     : </span><span>iota</span><span>;</span></p></div><div><p><span>import</span><span> </span><span>std.stdio</span><span>     : </span><span>writeln</span><span>;</span></p></div><div></div><div><p><span>// With UFCS</span></p></div><div><p><span>void</span><span> </span><span>main</span><span>()</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>iota</span><span>(</span><span>0</span><span>,</span><span> </span><span>10_000</span><span>)</span></p></div><div><p><span><span>        </span></span><span>.</span><span>filter</span><span>!(</span><span>num</span><span> =&gt; </span><span>num</span><span> </span><span>%</span><span> </span><span>2</span><span> </span><span>==</span><span> </span><span>0</span><span>)</span></p></div><div><p><span><span>        </span></span><span>.</span><span>map</span><span>!(</span><span>num</span><span> =&gt; </span><span>num</span><span> </span><span>*</span><span> </span><span>2</span><span>)</span></p></div><div><p><span>        </span><span>.writeln</span><span>();</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<h2 id="feature---scoped--selective-imports">Feature - Scoped &amp; Selective Imports</h2>
<p>D supports limiting imports to a specific scope, whether that be a singular if-statement, an entire function, an entire struct/class, etc.</p>
<p>D will also allow you to selectively import symbols from other modules, instead of polluting your lookup scope with a ton of unrelated stuff - also helps increase comprehension of the codebase.</p>
<div><figure><pre data-language="d"><code><div><p><span>// (slightly contrived example)</span></p></div><div></div><div><p><span>import</span><span> </span><span>std.algorithm</span><span> : </span><span>joiner</span><span>; </span><span>// Scoped to the entire module.</span></p></div><div></div><div><p><span>struct</span><span> </span><span>Person</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>import</span><span> </span><span>std.algorithm</span><span> : </span><span>filter</span><span>; </span><span>// Scoped to everything in this struct.</span></p></div><div></div><div><p><span>    </span><span>string</span><span>[] </span><span>names</span><span>;</span></p></div><div></div><div><p><span>    </span><span>void</span><span> </span><span>printNames</span><span>()</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>import</span><span> </span><span>std.stdio</span><span> : </span><span>write</span><span>,</span><span> </span><span>writeln</span><span>; </span><span>// Scoped only to this function.</span></p></div><div></div><div><p><span>        </span><span>if</span><span>(</span><span>this</span><span>.names.length</span><span> </span><span>&gt;</span><span> </span><span>1</span><span>)</span></p></div><div><p><span><span>        </span></span><span>{</span></p></div><div><p><span>            </span><span>import</span><span> </span><span>std.algorithm</span><span> : </span><span>each</span><span>; </span><span>// Scoped only to this branch.</span></p></div><div><p><span>            </span><span>this</span><span>.names.filter</span><span>!(</span><span>name</span><span> =&gt; </span><span>name.length</span><span> </span><span>&gt;</span><span> </span><span>0</span><span>)</span></p></div><div><p><span>                      </span><span>.joiner</span><span>(</span><span>&#34; &#34;</span><span>)</span></p></div><div><p><span><span>                      </span></span><span>.</span><span>each</span><span>!</span><span>write</span><span>;</span></p></div><div><p><span>            </span><span>writeln</span><span>();</span></p></div><div><p><span><span>        </span></span><span>}</span></p></div><div><p><span>        </span><span>else</span></p></div><div><p><span>            </span><span>writeln</span><span>(</span><span>this</span><span>.names</span><span>[</span><span>0</span><span>]);</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div><p><span>}</span></p></div><div></div><div><p><span>void</span><span> </span><span>main</span><span>()</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>Person</span><span>([</span><span>&#34;Bradley&#34;</span><span>,</span><span> </span><span>&#34;Chatha&#34;</span><span>])</span><span>.printNames</span><span>();</span></p></div><div><p><span>    </span><span>Person</span><span>([</span><span>&#34;Shmradley&#34;</span><span>])</span><span>.printNames</span><span>();</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>While it may seem like clutter and extra effort, in the long run this allows for:</p>
<ol>
<li>Making it easy for newcomers to understand where certain functions are coming from.</li>
<li>Allows for code to become “portable” between files since the code can carry most of its external dependencies inside of itself, making refactoring a bit easier.</li>
</ol>
<h2 id="feature---built-in-documentation-generator">Feature - Built-in documentation generator</h2>
<p>Finally, D has a built-in documentation generator with a relative standard, easy to read format.</p>
<p>There’s also a handful of documentation tools that are detached from the built-in one since the default generated output is a bit lacklustre (<em>cough</em> I’m plugging my <a href="https://github.com/Juptune/marmos">custom tool</a> here).</p>
<p>Here’s a relatively extreme example from one of my personal projects, to get an idea of the basic format:</p>
<div><figure><pre data-language="d"><code><div><p><span>/++</span></p></div><div><p><span><span> </span></span><span>+ Parses a URI from a string into a `ScopeUri`, which specifically does not contain any copy of the input</span></p></div><div><p><span><span> </span></span><span>+ data, but instead slices from the original `input` slice.</span></p></div><div><p><span><span> </span></span><span>+</span></p></div><div><p><span><span> </span></span><span>+ This means the returned `ScopeUri` is only valid for as long as the `input` slice is valid and unmodified.</span></p></div><div><p><span><span> </span></span><span>+</span></p></div><div><p><span><span> </span></span><span>+ This function is intended to be used when the caller wants to avoid copying the input data, and is willing</span></p></div><div><p><span><span> </span></span><span>+ to accept the limitations and risks of a `ScopeUri`.</span></p></div><div><p><span><span> </span></span><span>+</span></p></div><div><p><span><span> </span></span><span>+ Please report any non-compliance with RFC 3986 as a bug.</span></p></div><div><p><span><span> </span></span><span>+</span></p></div><div><p><span><span> </span></span><span>+ Valid Formats:</span></p></div><div><p><span><span> </span></span><span>+  isAbsolute</span></p></div><div><p><span><span> </span></span><span>+      -&gt; scheme://user:info@host:port/path?query#fragment, e.g. &#34;http://user:info@localhost:8080/some/path?some=query#some-fragment&#34;</span></p></div><div><p><span><span> </span></span><span>+</span></p></div><div><p><span><span> </span></span><span>+  isNetworkReference</span></p></div><div><p><span><span> </span></span><span>+      -&gt; //user:info@host:port/path?query#fragment, e.g. &#34;//user:info@localhost:8080/some/path?some=query#some-fragment&#34;</span></p></div><div><p><span><span> </span></span><span>+</span></p></div><div><p><span><span> </span></span><span>+  !isAbsolute &amp;&amp; !isNetworkReference &amp;&amp; pathIsAbsolute</span></p></div><div><p><span><span> </span></span><span>+      -&gt; /path?query#fragment, e.g. &#34;/some/path?some=query#some-fragment&#34;</span></p></div><div><p><span><span> </span></span><span>+</span></p></div><div><p><span><span> </span></span><span>+  pathIsRootless</span></p></div><div><p><span><span> </span></span><span>+   only if `UriParseRules.allowUriSuffix` IS NOT set.</span></p></div><div><p><span><span> </span></span><span>+      -&gt; path?query#fragment, e.g. &#34;some/path?some=query#some-fragment&#34;</span></p></div><div><p><span><span> </span></span><span>+</span></p></div><div><p><span><span> </span></span><span>+  isUriSuffix</span></p></div><div><p><span><span> </span></span><span>+    only the host component is supported within the authority - port and user info are not supported</span></p></div><div><p><span><span> </span></span><span>+       due to their colons causing the URI to be seen as an absolute URI, which will likely generate an error.</span></p></div><div><p><span><span> </span></span><span>+    only if `UriParseRules.allowUriSuffix` IS set.</span></p></div><div><p><span><span> </span></span><span>+       -&gt; host/path?query#fragment, e.g. &#34;localhost/some/path?some=query#some-fragment&#34;</span></p></div><div><p><span><span> </span></span><span>+</span></p></div><div><p><span><span> </span></span><span>+ Please see the individual, lower level parsing functions for the exact details of each component.</span></p></div><div><p><span><span> </span></span><span>+</span></p></div><div><p><span><span> </span></span><span>+ Notes:</span></p></div><div><p><span><span> </span></span><span>+  The output of all `out` parameters is undefined if the function returns an error.</span></p></div><div><p><span><span> </span></span><span>+</span></p></div><div><p><span><span> </span></span><span>+  This parser will attempt to heuristically determine whether the start of the URI</span></p></div><div><p><span><span> </span></span><span>+  is a scheme or an authority. Please note that errors in a scheme may manifest as an error in the</span></p></div><div><p><span><span> </span></span><span>+  authority component.</span></p></div><div><p><span><span> </span></span><span>+</span></p></div><div><p><span><span> </span></span><span>+  If it&#39;s not clear, you can use `uri.hints` to determine the exact structure of the URI.</span></p></div><div><p><span><span> </span></span><span>+</span></p></div><div><p><span><span> </span></span><span>+ Params:</span></p></div><div><p><span><span> </span></span><span>+  input = The input string to parse</span></p></div><div><p><span><span> </span></span><span>+  uri   = The `ScopeUri` to write the parsed URI to</span></p></div><div><p><span><span> </span></span><span>+  rules = A set of rules that can be used to control the behaviour of the URI parser</span></p></div><div><p><span><span> </span></span><span>+</span></p></div><div><p><span><span> </span></span><span>+ Throws:</span></p></div><div><p><span><span> </span></span><span>+  Anything that `uriParseScheme`, `uriParseAuthority`, `uriParsePath`, `uriParseQuery`, or `uriParseFragment` can throw.</span></p></div><div><p><span><span> </span></span><span>+</span></p></div><div><p><span><span> </span></span><span>+ Returns:</span></p></div><div><p><span><span> </span></span><span>+  A `Result` indicating whether the parsing was successful or not.</span></p></div><div><p><span><span> </span></span><span>+ ++/</span></p></div><div><p><span>Result</span><span> </span><span>uriParseNoCopy</span><span>(</span></p></div><div><p><span>    </span><span>const</span><span>(</span><span>char</span><span>)[] </span><span>input</span><span>,</span></p></div><div><p><span>    </span><span>out</span><span> </span><span>scope</span><span> </span><span>ScopeUri</span><span> </span><span>uri</span><span>,</span></p></div><div><p><span>    </span><span>UriParseRules</span><span> </span><span>rules</span><span> </span><span>=</span><span> </span><span>UriParseRules.strict</span></p></div><div><p><span>) </span><span>@nogc</span><span> </span><span>@trusted</span><span> </span><span>nothrow</span><span> </span><span>// Note: It is actually @safe however compiler-generated temporaries trigger @safe deprecation warnings</span></p></div><div><p><span>in</span><span>(</span><span>input.length</span><span> </span><span>&gt;</span><span> </span><span>0</span><span>,</span><span> </span><span>&#34;Attempting to parse an empty string is likely incorrect logic. Null checks, people!&#34;</span><span>)</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>// ...</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>Here’s an example from the standard library, which has minor usage of documentation macros:</p>
<div><figure><pre data-language="d"><code><div><p><span>/**</span></p></div><div><p><span>Converts a hex literal to a string at compile time.</span></p></div><div></div><div><p><span>Takes a string made of hexadecimal digits and returns</span></p></div><div><p><span>the matching string by converting each pair of digits to a character.</span></p></div><div><p><span>The input string can also include white characters, which can be used</span></p></div><div><p><span>to keep the literal string readable in the source code.</span></p></div><div></div><div><p><span>The function is intended to replace the hexadecimal literal strings</span></p></div><div><p><span>starting with `&#39;x&#39;`, which could be removed to simplify the core language.</span></p></div><div></div><div><p><span>Params:</span></p></div><div><p><span><span>    </span></span><span>hexData = string to be converted.</span></p></div><div></div><div><p><span>Returns:</span></p></div><div><p><span><span>    </span></span><span>a `string`, a `wstring` or a `dstring`, according to the type of hexData.</span></p></div><div></div><div><p><span>See_Also:</span></p></div><div><p><span><span>    </span></span><span>Use $(REF fromHexString, std, digest) for run time conversions.</span></p></div><div><p><span><span>    </span></span><span>Note, these functions are not drop-in replacements and have different</span></p></div><div><p><span><span>    </span></span><span>input requirements.</span></p></div><div><p><span><span>    </span></span><span>This template inherits its data syntax from builtin</span></p></div><div><p><span><span>    </span></span><span>$(LINK2 $(ROOT_DIR)spec/lex.html#hex_string, hex strings).</span></p></div><div><p><span><span>    </span></span><span>See $(REF fromHexString, std, digest) for its own respective requirements.</span></p></div><div><p><span><span> </span></span><span>*/</span></p></div><div><p><span>template</span><span> </span><span>hexString</span><span>(</span><span>string</span><span> </span><span>hexData</span><span>)</span></p></div><div><p><span>if</span><span> (</span><span>hexData.isHexLiteral</span><span>)</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>// ...</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<h2 id="conclusion">Conclusion</h2>
<p>I tried to focus more on the more simpler day-to-day features, with only a splattering of the bigger more complicated stuff.</p>
<p>Hopefully this provides some insight on the wacky-yet-wonderful feature set that D provides.</p> <section> <a href="https://bradley.chatha.dev/blog/dlang-propaganda">  </a> </section>  </section>  </div></div>
  </body>
</html>
