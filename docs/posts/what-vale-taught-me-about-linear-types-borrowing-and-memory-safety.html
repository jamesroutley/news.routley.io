<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://verdagon.dev/blog/linear-types-borrowing">Original</a>
    <h1>What Vale taught me about linear types, borrowing, and memory safety</h1>
    
    <div id="readability-page-1" class="page"><div class="page">
    <div>
  

        <div>
          <div>
  

            
    
<section>
<p>
I&#39;ve had some pretty surreal experiences while making Vale. <a href="#note0" data-noteid="0">0</a> The weirdest was when I realized the hidden fundamental truth beneath a lot of the programming languages we use today.
</p>

</section>
<section>
<h2 id="the-ancient-writings-that-lit-up-a-new-field">
 The ancient writings that lit up a new field</h2>

</section>
<section>
<p>
In July of 1799, a soldier was digging some foundations to expand a fortress in the Egyptian town of Rashid, when he stumbled upon an ancient-looking slate. He took it to his commanding officer, who realised that it could be important, or at the very least, valuable.
</p>

</section>
<section>
<div><center><img src="https://verdagon.dev/images/rosetta.jpg"/><span></span></center></div>


</section>
<section>
<p>
The slate had writings in three languages, including ancient Egyptian hieroglyphs. Nobody knew how to read hieroglyphs yet, except for some oval shapes which are known to contain the names of kings and queens.
</p>
<p>
The other two languages say the same thing as each other, and also mention those same kings and queens.
</p>

</section>
<section>
<p>
The scholar Jean-Francois Champollion used these clues to eventually decipher the entire stone, and enabled us to finally understand ancient Egyptian hieroglyphs.
</p>

</section>
<section>
<p>
I wonder what Champollion felt in that moment, when he had that entire slate translated for the first time. Probably overwhelmed and excited at the potential!
</p>

</section>
<section>
<p>
I&#39;m no scholar, and I certainly didn&#39;t discover anything new. But I think I felt that same overwhelm and excitement when Vale showed me the hidden truths that led to the creation of our <b>linear-aliasing model</b>, which lets us use linear types to completely eliminate Vale&#39;s memory safety costs.
</p>

</section>

      </div>
  
<div>

      <nav>
      <p>What Vale Taught Me About Linear Types, Borrowing, and Memory Safety</p>
    


      </nav>
      
    

      <div>
        <div>
    
<div id="note0" data-noteid="0">
<p><span>0</span></p><section>
<p>
And a lot of unexpected experiences! There was one time where I dove down an ancient history rabbit hole, just so I could add some flavor to an article about memory safety.
</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h2 id="a-different-way-to-get-memory-safety">
 A different way to get memory safety</h2>
<p>
Recently, I was making a sample program to show how Vale&#39;s <a href="https://verdagon.dev/blog/zero-cost-borrowing-regions-overview">regions</a> can blend borrowing <a href="#note1" data-noteid="1">1</a> with shared mutability.
</p>

</section>
<section>
<p>
I was surprised to find that the sample program had almost <i>zero</i> memory-safety overhead, except for a tiny bit in this (<a href="https://github.com/Verdagon/RegionsBenchmarks/blob/main/cellular-automata/CellularAutomata.vale">paraphrased</a>) code:
</p>

    <div>
      
      <pre><code><span><span>func <span>RandInt</span><span>(<span>rand <span><span></span><span><span>&amp;</span><span>Random</span></span></span></span>)</span> <span><span>i64</span> </span><span>{</span></span></span></code></pre>
    </div>
  

</section>
<section>
<p>
Specifically, when <span>RandInt</span>&#39;s <span>rand.num</span> dereferences the <span>rand</span> object, it does an implicit <a href="https://verdagon.dev/blog/generational-references">generation check</a> assertion to ensure the object is still alive.
</p>

</section>
<section>
<p>
Normally, I don&#39;t believe in chasing zero-cost memory safety. Playing overhead golf can often lead to chasing diminishing returns or prematurely optimizing. Besides, a generation check is usually only as expensive as a bounds check (in other words, usually negligible).
</p>

</section>
<section>
<p>
But still, I wondered if it <i>could</i> be done. Could we get rid of that last little bit of overhead?
</p>

</section>
<section>
<p>
A few weeks later, I discovered the solution.
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note1" data-noteid="1">
<p><span>1</span></p><section>
<p>
&#34;Borrowing&#34; is how we can temporarily freeze data to make accessing it much more efficient. If the compiler knows some data won&#39;t change, then it doesn&#39;t have to incur any memory safety overhead. This was popularized by Rust, and we found a way to compose it with shared mutability via regions.
</p>

</section>
</div>
<div id="note2" data-noteid="2">
<p><span>2</span></p><section>
<p>
 The <span>set</span> statement, like <span>set x = 10;</span>, reassigns an existing variable, equivalent to C&#39;s <span>x = 10;</span>. Vale has a <span>set</span> keyword so that its declarations can be simpler, like <span>x = 4;</span>.
</p>

</section>
</div>
<div id="note3" data-noteid="3">
<p><span>3</span></p><section>
<p>
 The optimizer is actually smart enough to optimize this second generation check out on its own.

</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h2 id="moving-into-and-out-of-functions">
 Moving into and out of functions</h2>
<div>
<div>
<section>
<p>
Instead of taking a <span>&amp;Random</span> reference parameter like this:
</p>

    <div>
      
      <pre><code><span><span>func <span>RandInt</span><span>(<span>rand <span><span></span><span><span>&amp;</span><span>Random</span></span></span></span>)</span> <span><span>i64</span> </span><span>{</span></span></span></code></pre>
    </div>
  


</section>
</div>
<div>
<section>
<p>
...<span>RandInt</span> could take (and return) an owned <span>Random</span>, like this:
</p>

    <div>
      
      <pre><code><span><span>func <span>RandInt</span><span>(<span>rand <span><span></span><span>Random</span></span></span>)</span> <span><span>(<span>i64</span>, <span>Random</span>)</span> </span><span>{</span></span></span></code></pre>
    </div>
  


</section>
</div>
</div>

</section>
<section>
<p>
Here&#39;s what we changed:
</p>
<ul>
<li>
<span>rand &amp;Random</span> became <span>rand Random</span>. Instead of taking a reference, the caller moves the actual Random instance itself.
</li>
<li>
<span>return x</span> became <span>return (x, rand);</span> which returns a two-element tuple, which also has the Random instance.
</li>
<li>
The return type <span>i64</span> became <span>(i64, Random)</span> accordingly.
</li>
</ul>

</section>
<section>
<p>
Now, <span>rand.num</span> isn&#39;t dereferencing a reference, it&#39;s accessing a field of an owned value.
</p>
<p>
Vale&#39;s compiler sees this, and doesn&#39;t insert a generation check, because any object that we own is still alive.
</p>

</section>
<section>
<p>
Of course, that requires we change how <span>MakeBoard</span> calls <span>RandInt</span>.
</p>

</section>
<section>
<div>
<div>
<section>
<p>
It goes from this:
</p>

    
  
<p>
where <span>rand</span> is a <span>&amp;Random</span> reference...

</p>

</section>
</div>
<div>
<section>
<p>
...to this:
</p>

    <div>
      
      <pre><code>[r, set rand] = RandInt(rand);</code></pre>
    </div>
  
<p>
where <span>rand</span> is an actual <span>Random</span>, not just a reference.

</p>

</section>
</div>
</div>

</section>
<section>
<p>
This new line will:
</p>
<ul>
<li>
Moves the <span>rand</span> instance into the <span>RandInt</span> call.
</li>
<li>
Uses the square braces to break apart the returned tuple into its two elements:
</li>
<ul>
<li>
The <span>i64</span> part assigned to the local variable <span>r</span>.
</li>
<li>
The <span>Random</span> part is put into the <span>rand</span> variable via <span>set rand</span>.
</li>
</ul>
</ul>

</section>
<section>
<p>
Here&#39;s the rest of <span>MakeBoard</span>, for context.
</p>

</section>
<section>
<div>
<div>
<section>
<p>
It went from this:
</p>

    <div>
      
      <pre><code>// Returns a 2D array of random bools.
func MakeBoard(
    rand &amp;Random,
    num_rows int,
    num_cols int)
[][]bool {
  rows = [][]bool(num_rows);
  foreach row_i in 0..num_rows {
    row = []bool(num_cols);
    foreach col_i in 0..num_cols {
      r = RandInt(rand);
      row.push((r mod 2) == 0);
    }
    rows.push(row);
  }
  return rows;
}</code></pre>
    </div>
  


</section>
</div>
<div>
<section>
<p>
...to this:
</p>

    <div>
      
      <pre><code>// Returns a 2D array of random bools.
func MakeBoard(
   rand Random,
   num_rows int,
   num_cols int)
([][]bool, Random) {
  rows = [][]bool(num_rows);
  foreach row_i in 0..num_rows {
    row = []bool(num_cols);
    foreach col_i in 0..num_cols {
      [r, set rand] = RandInt(rand);
      row.push((r mod 2) == 0);
    }
    rows.push(row);
  }
  return (rows, rand);
}</code></pre>
    </div>
  


</section>
</div>
</div>

</section>
<section>
<p>
Let&#39;s break that down:
</p>
<ul>
<li>
The <span>rand &amp;Random</span> parameter became <span>rand Random</span>, to take an actual <span>Random</span> instance instead of a reference.
</li>
<li>
The return type <span>[][]bool</span> became <span>([][]bool, Random)</span>, so we can later return the <span>Random</span> instance.
</li>
<li>
The <span>[r, set rand] = RandInt(rand);</span> line changed, as explained above.
</li>
<li>
<span>return (rows, rand)</span> returns the new board and the <span>Random</span> instance to the caller.
</li>
</ul>

</section>
<section>
<p>
Instead of passing a reference, it&#39;s like we&#39;re &#34;lending&#34; an owned value to a function, which then returns it to us. For now, let&#39;s call this maneuver <b>own-lending</b>.
</p>

</section>
<section>
<p>
If you&#39;ve used a language like <a href="https://www.rust-lang.org/">Rust</a> before, this might feel familiar: own-lending is semantically equivalent to borrowing a <span>&amp;mut Random</span> and passing it around.
</p>

</section>
<section>
<p>
Just for fun, I tried applying own-lending to the entire program. Sure enough, the <span>--print_mem_overhead true</span> flag reported that I reduced generation checks down to <b>zero.</b>
</p>

</section>

      </div>
  


    </div>
    <div>
      <div>
  
<section>
<h2 id="wait-zero">
 Wait, zero?!</h2>
<p>
This <i>blew</i> my <i>mind</i>. That shouldn&#39;t be possible. I&#39;ve never seen <span>--print_mem_overhead</span> print zero before!
</p>

</section>
<section>
<p>
Yet there it was.
</p>

</section>
<section>
<p>
I sat back from my desk, and got up for a walk. After ten minutes, I realized I&#39;d just been staring at a wall, and hadn&#39;t actually walked anywhere. <a href="#note4" data-noteid="4">4</a>
</p>

</section>
<section>
<p>
It slowly sank in over the next few days.
</p>

</section>
<section>
<p>
<b>Using own-lending, we can completely eliminate every single generation check in a program, to get memory safety without borrow checking, reference counting, or tracing garbage collection.</b> <a href="#note5" data-noteid="5">5</a>
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note4" data-noteid="4">
<p><span>4</span></p><section>
<p>
This wall-staring happens more often than you might think. The same thing happened when I first realized that regions <a href="https://verdagon.dev/blog/making-regions-part-1-human-factor">could also eliminate memory safety costs</a>.
</p>

</section>
</div>
<div id="note5" data-noteid="5">
<p><span>5</span></p><section>
<p>
This was particularly surprising to me, since it meant that immutable borrowing wasn&#39;t strictly necessary for languages like <a href="https://www.rust-lang.org/">Rust</a> and <a href="https://austral-lang.org/">Austral</a>. They&#39;re definitely nice usability improvements though, so it&#39;s good they added them.
</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h2 id="discovering-linear-types">
 Discovering Linear Types</h2>
<p>
I imagine that Jean-Francois Champollion felt overwhelmed, discovering how to read ancient Egyptian hieroglyphs. He had found the secret to exploring an ancient culture in a way nobody ever has before.
</p>

</section>
<section>
<p>
I didn&#39;t discover anything like what Champollion did, but I certainly felt overwhelmed when I saw that zero.
</p>

</section>
<section>
<p>
And I hadn&#39;t found anything new, of course. I was just learning the natural consequence of Vale&#39;s owned values being <a href="https://en.wikipedia.org/wiki/Substructural_type_system#Linear_type_systems">linear types</a>, which is a distant cousin of Rust&#39;s affine types. Both are a kind of &#34;<a href="https://en.wikipedia.org/wiki/Substructural_type_system">substructural type system</a>&#34;. Apparently, people have been writing about substructural type systems&#39; abilities for decades! <a href="#note6" data-noteid="6">6</a>
</p>

</section>
<section>
<p>
With this new understanding, I also considered Rust from a different perspective. It led me to the eventual truth: their memory safety doesn&#39;t come from borrow checking, not exactly. It comes from their types being affine. In a way, <span>&amp;mut</span> references are just syntactic sugar, <a href="#note7" data-noteid="7">7</a> and <a href="https://doc.rust-lang.org/stable/book/ch04-01-what-is-ownership.html#return-values-and-scope">you can take `&amp;mut` out of Rust and not much would change semantically</a>.
</p>

</section>
<section>
<p>
The same is true of Vale, apparently. If you program without making any references, your program becomes memory safe, and has no memory-safety related overhead!
</p>

</section>
<section>
<p>
I&#39;m no type theorist. I vaguely knew that Vale&#39;s owned values were linear, but I had no idea they could do so much. This came as a huge surprise to me.
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note6" data-noteid="6">
<p><span>6</span></p><section>
<p>
There&#39;s also a very interesting language named <a href="https://austral-lang.org/">Austral</a>, based on linear types!
</p>

</section>
</div>
<div id="note7" data-noteid="7">
<p><span>7</span></p><section>
<p>
&#34;Syntactic sugar&#34; is what we call features that just make the code a bit cleaner, but aren&#39;t really required to express a certain computation.
</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h2 id="necessary-techniques">
 Necessary techniques</h2>
<p>
In the two functions I showed above, it was pretty simple to do own-lending.
</p>

</section>
<section>
<p>
Soon, I discovered that we need some other features to support own-lending fully. In particular, a language needs:
</p>
<ul>
<li>
Struct &#34;destructuring&#34;
</li>
<li>
Array insert and extract
</li>
</ul>

</section>

      </div>
  


    </div>
    <div>
      <div>
  
<section>
<h3 id="destructuring">
 Destructuring</h3>
<p>
We destructured a tuple in the above example, and we&#39;d need to do it again if we want to take ownership of something from a containing struct.
</p>

</section>
<section>
<p>
Let&#39;s say that <span>Random</span> instance was already owned by a <span>GameState</span> struct like this:
</p>

    <div>
      
      <pre><code>struct GameState {
  player_name str;
  rand Random;
}
exported func main() {
  game = GameState(&#34;Vast&#34;, Random(42));
  // Error!
  MakeBoard(game.rand);
  ...
}</code></pre>
    </div>
  

</section>
<section>
<p>
The compiler would give us an error, because taking that <span>Random</span> out of the <span>GameState</span> would leave the <span>GameState</span> struct in an invalid state.
</p>
<p>
Instead, we&#39;ll need to temporarily destroy the GameState and then recreate it.
</p>

</section>
<section>
<p>
Instead of writing <span>MakeBoard(game.rand);</span>, we would write:
</p>

    <div>
      
      <pre><code>[player_name, rand] = game;
set rand = MakeBoard(rand);
set game = GameState(player_name, rand);</code></pre>
    </div>
  

</section>
<section>
<p>
It&#39;s verbose, but it works!
</p>

</section>
<section>
<p>
A language could make this less verbose with a few different approaches, which I&#39;ll talk about further below. First, let&#39;s make this work with arrays!
</p>

</section>

      </div>
  


    </div>
    <div>
      <div>
  
<section>

<p>
If the <span>Random</span> was in an array, we can take it out using an <span>extract</span> method, and put it back in using an <span>insert</span> method.
</p>

</section>
<section>

    <div>
      
      <pre><code>arr []Random = …;
...
rand = arr.extract(3);
set rand = MakeBoard(rand);
arr.insert(3, rand);</code></pre>
    </div>
  

</section>
<section>
<p>
Depending on the implementation of <span>extract</span> and <span>insert</span>, this could be costly, up to O(n) time as it shifts all the subsequent elements by one.
</p>
<p>
There are more efficient ways to implement it. Some options:
</p>
<ul>
<li>
<span>extract</span> might swap the last element to this position, and <span>insert</span> might put it back at the end.
</li>
<li>
We could temporarily destroy the containing array to give us ownership, similar to what we did with structs above.
</li>
<li>
If we&#39;re using generational references like Vale is, we could temporarily change the object&#39;s generation number.
</li>
</ul>
<p>
We&#39;ll talk about that last one further below.
</p>

</section>

      </div>
  


    </div>
    <div>
      <div>
  
<section>
<h3 id="some-sugar">
 Some Sugar <a href="#note8" data-noteid="8">8</a></h3>
<p>
We could add some syntactic sugar <a href="#note9" data-noteid="9">9</a> to temporarily destroy an array or a struct, so we can take ownership of the contained data.
</p>
<div>
<div>
<section>
<p>
Recall this code from above:
</p>

    <div>
      
      <pre><code>// Create a GameState struct
game = GameState(&#34;Vast&#34;, Random(42));
...
[name, rand] = game;
set rand = MakeBoard(rand);
set game = GameState(name, rand);</code></pre>
    </div>
  


</section>
</div>
<div>
<section>
<p>
Those last three lines could conceptually become this:
</p>

    <div>
      
      <pre><code>borrow game.rand as rand;
set rand = MakeBoard(rand);</code></pre>
    </div>
  
<p>
or this alternative syntax:
</p>

    <div>
      
      <pre><code>rand = borrow game.rand;
set rand = MakeBoard(rand);</code></pre>
    </div>
  


</section>
</div>
</div>

</section>
<section>
<p>
At the end of the scope, the language would use <span>rand</span> to reconstruct a <span>GameState</span> to put in <span>game</span>.
</p>

</section>
<section>
<div>
<div>
<section>
<p>
Recall the code with the array:
</p>

    <div>
      
      <pre><code>arr []Random = …;
...
rand = arr.extract(3);
set rand = MakeBoard(rand);
arr.insert(3, rand);</code></pre>
    </div>
  


</section>
</div>
<div>
<section>
<p>
Those last three lines could conceptually become this:
</p>

    <div>
      
      <pre><code>borrow arr[3] as rand;
set rand = MakeBoard(rand);</code></pre>
    </div>
  
<p>
or this alternative syntax:
</p>

    <div>
      
      <pre><code>rand = borrow arr[3];
set rand = MakeBoard(rand);</code></pre>
    </div>
  


</section>
</div>
</div>

</section>
<section>
<p>
And instead of a function taking and returning an owned value, we can add some syntactic sugar to do that for us.
</p>

</section>
<section>
<div>
<div>
<section>
<p>
Instead of:
</p>

    <div>
      
      <pre><code>func RandInt(rand Random) (i64, Random) {
  x = rand.num;
  set x = x + (x / 200096i64);
  set x = x - (x * 33554432i64);
  set x = x + (x / 134217728i64);
  set rand.num = x;
  return (x, rand);
}</code></pre>
    </div>
  


</section>
</div>
<div>
<section>
<p>
...we could add an <span>inout</span> keyword:
</p>

    <div>
      
      <pre><code>func RandInt(rand inout Random) i64 {
  x = rand.num;
  set x = x + (x / 200096i64);
  set x = x - (x * 33554432i64);
  set x = x + (x / 134217728i64);
  set rand.num = x;
  return x;
}</code></pre>
    </div>
  
<p>
...so that it could be called like <span>r = RandInt(borrow rand);</span>.

</p>

</section>
</div>
</div>

</section>
<section>
<p>
This <span>inout</span> keyword would work exactly like Swift&#39;s or C#&#39;s <span>inout</span> keyword, and like references in <a href="https://www.val-lang.dev/">Val</a>&#39;s <a href="https://www.jot.fm/issues/issue_2022_02/article2.pdf">mutable value semantics</a>. <a href="#note10" data-noteid="10">10</a> It&#39;s also <a href="https://doc.rust-lang.org/stable/book/ch04-01-what-is-ownership.html#return-values-and-scope">similar</a> to Rust&#39;s <span>&amp;mut</span>, but this is part of the variable/parameter, not part of its type.
</p>

</section>
<section>
<p>
As a bonus, this makes it easier for the compiler to optimize out any destroying/recreating structs, or shifting around array elements. In Vale, we would just temporarily change the containing struct&#39;s/array&#39;s generation.
</p>

</section>
<section>
<p>
It&#39;s unclear whether we&#39;ll add this sugar in Vale. If you have any opinions on the matter, make an <a href="https://github.com/ValeLang/Vale/issues">issue</a> or join the <a href="https://discord.gg/SNB8yGH">discord server</a>!
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note8" data-noteid="8">
<p><span>8</span></p><section>
<p>
Everything in this section is theoretical, we haven&#39;t decided on any particular sugar to add to Vale for this.
</p>

</section>
</div>
<div id="note9" data-noteid="9">
<p><span>9</span></p><section>
<p>
&#34;Syntactic sugar&#34; is what we call features that just make the code a bit cleaner, but aren&#39;t really required to express a certain computation.
</p>

</section>
</div>
<div id="note10" data-noteid="10">
<p><span>10</span></p><section>
<p>
Val is a different language from Vale and Vala (we all have similarly great taste in naming!)
</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h2 id="benefits-and-drawbacks">
 Benefits and Drawbacks</h2>

</section>
<section>
<p>
To get a sense of this &#34;linear style&#34;, I like to compare it to Rust&#39;s borrow checking, because they&#39;re surprisingly similar.
</p>

</section>
<section>
<p>
They both have some benefits:
</p>
<ul>
<li>
Memory safety with no direct extra costs. <a href="#note11" data-noteid="11">11</a>
</li>
<li>
Safety from data races; data races happen when two threads use references to access the same object, but we only ever allow one reference.
</li>
</ul>

</section>
<section>
<p>
And they both have some drawbacks:
</p>
<ol>
<li>
We often can&#39;t have multiple references to some data (except temporarily with borrow checking <a href="#note12" data-noteid="12">12</a> <a href="#note13" data-noteid="13">13</a>).
</li>
<li>
When we would otherwise have multiple references, we instead sometimes need to &#34;slice&#34; our data in unintuitive ways, which can cause some extra refactoring.
</li>
<li>
We can&#39;t use optimal patterns like <a href="https://lwn.net/Articles/907876/">intrusive data structures</a> and <a href="https://news.ycombinator.com/item?id=24996001">graphs</a> which are sometimes faster in certain situations.
</li>
<li>
We can&#39;t use certain patterns that decouple our code and make it more flexible, like <a href="https://www.reddit.com/r/rust/comments/pwqju6/is_there_an_underlying_reason_that_idiomatic_rust/">observers</a>, <a href="https://users.rust-lang.org/t/back-reference-to-the-parent-struct/7413/2">back-references</a>, <a href="https://en.wikipedia.org/wiki/Dependency_injection">dependency references</a>, <a href="https://news.ycombinator.com/item?id=12029238">callbacks</a>, and <a href="https://medium.com/@nimjea/delegation-pattern-in-swift-4-2-f6aca61f4bf5">delegates</a>.
</li>
</ol>

</section>
<section>
<p>
All of the above drawbacks exist because neither linear typing nor borrow checking can have <b>shared mutability</b>. In other words, multiple mutable references to the same data.
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note11" data-noteid="11">
<p><span>11</span></p><section>
<p>
I say &#34;direct&#34; because it does have some indirect overhead; guideline #2 leads us to put more objects into arrays and hash maps, which leads to more bounds checking and hashing. Sometimes we also get more cache misses, though sometimes we get less.
</p>

</section>
</div>
<div id="note12" data-noteid="12">
<p><span>12</span></p><section>
<p>
&#34;Shared&#34; references in Rust parlance, and they&#39;re read-only unless we use them to get to a <span>Cell</span>, <span>RefCell</span>, <span>Mutex</span>, etc.
</p>

</section>
</div>
<div id="note13" data-noteid="13">
<p><span>13</span></p><section>
<p>
Though, in both linear typing and borrow checking, long-lived references to the same data will still need to be made into indices or IDs into a central collection which holds the data.
</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h2 id="addressing-the-drawbacks">
 Addressing the Drawbacks</h2>
<p>
Are there any ways we can address those downsides without sacrificing the benefits?
</p>

</section>
<section>
<p>
In other words, is there a way we can have linear types <i>and</i> shared mutability?
</p>

</section>
<section>
<p>
Adding borrow checking partially helps with drawback #1 <a href="#note14" data-noteid="14">14</a> but it still has drawbacks #2, #3, and #4. Rust&#39;s <span>Rc</span> and <span>RefCell</span> helps with those, but they&#39;re incompatible with linear types&#39; benefits <a href="#note15" data-noteid="15">15</a>, and have their own drawbacks (like forcing heap allocation and not having <a href="https://verdagon.dev/blog/higher-raii-7drl">higher RAII</a>).
</p>

</section>
<section>
<p>
The other solution, surprisingly, is to blend generational references back in.
</p>
<p>
Each object is still owned linearly; only one place can own an object at a time. But we&#39;ll also allow a generational reference to point at the object.
</p>
<p>
With this, we can address a lot of the drawbacks:
</p>
<ol>
<li>
We can have as many references to data as we want, though there is still only one owner.
</li>
<li>
We don&#39;t need to restructure our program to accommodate them.
</li>
<li>
We can use patterns like intrusive data structures and graphs. <a href="#note16" data-noteid="16">16</a>
</li>
<li>
We can use observers, back-references, dependency references, callbacks, delegates, whatever we want.
</li>
<li>
We still don&#39;t have data races, because Vale changes the generations of any objects that cross region boundaries (unless we safely avoid that with <a href="https://verdagon.dev/blog/zero-cost-borrowing-regions-part-2-isolates">isolates</a>).
</li>
</ol>

</section>
<section>
<p>
Generational references seem to occupy a sweet spot because they allow objects to be linear (they&#39;re owned by only one place), yet allow shared mutability in a way that doesn&#39;t artificially extend the lifetime of the object.
</p>

</section>
<section>
<p>
Since we&#39;re combining linear types with aliasing, we&#39;ll call this the <b>linear-aliasing model</b>.
</p>

</section>
<section>
<p>
The mark of a good language is when its features compose well and don&#39;t conflict with each other. It seems we&#39;re on the right track with this model, as it composes linear types with shared mutability pretty well.
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note14" data-noteid="14">
<p><span>14</span></p><section>
<p>
Partially because borrow checking lets us have temporary references, not persistent ones. The borrow checker has a hard time putting references into data structures.
</p>

</section>
</div>
<div id="note15" data-noteid="15">
<p><span>15</span></p><section>
<p>
We can&#39;t put a linear type into an <span>Rc</span> because <span>Rc</span> throws away its contents when the last alias disappears.
</p>

</section>
</div>
<div id="note16" data-noteid="16">
<p><span>16</span></p><section>
<p>
In Vale, we would still have all nodes owned by a central collection, but we could still have references between nodes just fine.
</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h2 id="matches-made-in-heaven">
 Matches Made in Heaven</h2>
<p>
A pleasant surprise, we&#39;re back to where we started!
</p>

</section>
<section>
<p>
But we arrive with a new understanding:
</p>
<ul>
<li>
We can code in a &#34;linear-first&#34; fashion, and then only add references if we want some extra flexibility.
</li>
<li>
Alternatively, we can code with a lot of references, and then bring them down to <b>zero</b> where we want some more speed.
</li>
</ul>
<p>
In other words, we now have complete control over the flexibility vs. performance tradeoff, something I&#39;ve never seen a language do well.
</p>

</section>
<section>
<p>
It was quite a shock, realizing that Vale could do this the entire time.
</p>

</section>
<section>
<p>
And it made me wonder, what does this mean for <a href="https://verdagon.dev/blog/zero-cost-borrowing-regions-overview">regions</a>, Vale&#39;s other mechanism for eliminating generation checks?
</p>

</section>
<section>
<p>
Then I realized, they fit <i>perfectly</i> together. We can use regions to look at a function&#39;s inputs in a zero-cost way, and use this &#34;linear style&#34; for any new data the function creates.
</p>
<p>
I tried this out in a little <a href="https://github.com/Verdagon/RegionsBenchmarks/blob/main/tiny-roguelike/roguelike.vale">roguelike game</a>. The vast majority of generation checks were eliminated by regions, and the rest were eliminated by this new linear style.
</p>

</section>
<section>
<p>
You can try this too! Just invoke the Vale compiler with the <span>--print_mem_overhead true</span> flag to make the program print out how many generation checks you can still eliminate (and if you want to use regions too, check out the experimental branch <a href="https://verdagon.dev/blog/first-regions-prototype">described here</a>).
</p>

</section>

      </div>
  


    </div>
    <div>
      <div>
  
<section>
<h2 id="conclusion-and-next-steps">
 Conclusion and Next Steps</h2>
<p>
For those of us that like to squeeze every little last drop of performance out of our programs, this is a pretty exciting realization.
</p>

</section>
<section>
<p>
But ironically, that&#39;s a small minority. For the vast majority of Vale programs, generational references aren&#39;t a noticeable source of overhead, and none of this will matter. And that&#39;s a good thing; one of Vale&#39;s main strengths is that you can just make your program, and things will just work and will be fast.
</p>

</section>
<section>
<p>
However, this does open up Vale to some new domains. Since we can program in a way that doesnt require generation checks, that means that Vale could be used in new niches, like embedded systems, operating system kernels, and safety-critical software. That&#39;s pretty exciting, I think!
</p>

</section>
<section>
<p>
Thanks for reading, and I hope you enjoyed this article. If you have any questions, feel free to join the <a href="https://discord.gg/SNB8yGH">discord</a> or <a href="https://reddit.com/r/vale">subreddit</a> or reach out via <a href="https://twitter.com/verdagon">twitter</a>!
</p>

</section>
<section>
<p>
Cheers,
</p>
<p>
- Evan Ovadia
</p>

</section>

      </div>
  


    </div>
    <div>
      <div>
  
<section>
<h2 id="vale-needs-your-help">
 Vale needs your help!</h2>

</section>
<section>
<p>
With your help, we can bring a new language into the world that focuses on <b>speed</b>, <b>safety</b>, <b>flexibility</b>, and <b>ease of use.</b>
</p>

</section>
<section>
<p>
We’re a very small team of passionate individuals, working on this on our own and not backed by any corporation.
</p>

</section>
<section>
<p>
If you want to support our work, please consider <a href="https://github.com/sponsors/ValeLang">sponsoring us on GitHub</a>!
</p>

</section>
<section>
<center>
  <a href="https://github.com/sponsors/ValeLang">
     
     Sponsor us on GitHub
  </a>
</center>


</section>
<section>
<p>
Those who sponsor us also get extra benefits, including:
</p>
<ul>
<li>
Early access to all of our articles!
</li>
<li>
A sneak peek at some of our more ambitious designs, such as memory-safe allocators based on algebraic effects, an async/await/goroutine hybrid that works without data coloring or function coloring, and more.
</li>
<li>
Your name on the <a href="https://vale.dev/">vale.dev</a> home page!
</li>
</ul>

</section>
<section>
<p>
With enough sponsorship, we can:
</p>
<ul>
<li>
Start a a 501(c)(3) non-profit organization to hold ownership of Vale. <a href="#note17" data-noteid="17">17</a>
</li>
<li>
Buy the necessary computers to support more architectures.
</li>
<li>
Work on this full-time.
</li>
<li>
Make Vale into a production-ready language, and push it into the mainstream!
</li>
</ul>

</section>
<section>
<p>
We have a strong <a href="https://vale.dev/roadmap">track record</a>, and during this quest we&#39;ve discovered and implemented a lot of completely new techniques:
</p>
<ul>
<li>
The <a href="https://verdagon.dev/blog/linear-types-borrowing">Linear-Aliasing Model</a> that lets us use linear types where we need speed, and <a href="https://verdagon.dev/blog/generational-references">generational references</a> where we need the flexibility of shared mutability.
</li>
<li>
<a href="https://verdagon.dev/blog/first-regions-prototype">Region Borrowing</a>, which makes it easier to write efficient code by composing shared mutability with the ability to temporarily freeze data.
</li>
<li>
<a href="https://verdagon.dev/blog/single-ownership-without-borrow-checking-rc-gc">Higher RAII</a>, where the language adds logic safety by enforcing that we eventually perform a specific future operation.
</li>
<li>
<a href="https://verdagon.dev/blog/perfect-replayability-prototyped">Perfect Replayability</a> makes debugging race conditions obsolete  by recording all inputs and replaying execution exactly.
</li>
</ul>

</section>
<section>
<p>
These have been successfully prototyped. With your sponsorship we can polish them, integrate them, and bring these techniques into the mainstream. <a href="#note18" data-noteid="18">18</a>
</p>

</section>
<section>
<p>
Our next steps are focused on making Vale more user-friendly by:
</p>
<ol>
<li>
Finalizing the compiler&#39;s error messages and improving compile speeds.
</li>
<li>
Polishing interop with other languages.
</li>
<li>
Growing the standard library and ecosystem!
</li>
</ol>

</section>
<section>
<p>
We aim to combine and add to the benefits of our favorite languages:
</p>
<ul>
<li>
The scalability of <a href="https://go.dev/">Go</a> and ergonomics of <a href="https://scala-lang.org/">Scala</a>, but using Vale&#39;s <a href="https://verdagon.dev/blog/linear-types-borrowing">linear-aliasing model</a> instead of garbage collection.
</li>
<li>
C++&#39;s single-ownership shared-mutability abilities with more <a href="https://verdagon.dev/blog/single-ownership-without-borrow-checking-rc-gc">memory safety</a>, without sacrificing its flexibility.
</li>
<li>
The speed and safety of <a href="https://www.rust-lang.org/">Rust</a>, but with <a href="https://verdagon.dev/blog/zero-cost-borrowing-regions-overview">easier borrowing rules</a>, more <a href="https://verdagon.dev/blog/higher-raii-7drl">compile time guarantees</a>, and better compatibility with <a href="https://verdagon.dev/blog/linear-types-borrowing">shared mutability</a>.
</li>
</ul>

</section>
<section>
<p>
<b>We need your help to make this happen!</b>
</p>

</section>
<section>
<p>
If you&#39;re impressed by our <a href="https://vale.dev/roadmap">track record</a> and believe in the direction we&#39;re heading, please consider sponsoring us:
</p>
<center>
  <a href="https://github.com/sponsors/ValeLang">
     
     Sponsor us on GitHub
  </a>
</center>


</section>
<section>
<p>
If you have any questions, always feel free to reach out via <a href="mailto:verdagon_epsa@verdagon.dev">email</a>, <a href="https://twitter.com/vale_pl">twitter</a>, <a href="https://discord.gg/SNB8yGH">discord</a>, or the <a href="https://reddit.com/r/vale">subreddit</a>. Cheers!
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note17" data-noteid="17">
<p><span>17</span></p><section>
<p>
Tentatively name the Vale Software Foundation.
</p>

</section>
</div>
<div id="note18" data-noteid="18">
<p><span>18</span></p><section>
<p>
 <a href="https://verdagon.dev/blog/generational-references">Generational references</a>, the <a href="https://verdagon.dev/blog/linear-types-borrowing">linear-aliasing model</a>, and <a href="https://verdagon.dev/blog/single-ownership-without-borrow-checking-rc-gc">higher RAII</a> are all complete, and <a href="https://verdagon.dev/blog/first-regions-prototype">Region borrowing</a>, <a href="https://verdagon.dev/blog/fearless-ffi">fearless FFI</a>, and <a href="https://verdagon.dev/blog/perfect-replayability-prototyped">perfect replayability</a> have been successfully prototyped. Be sure to check out the experimental version of the compiler!

</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    
    
  

    </div>
  </div></div>
  </body>
</html>
