<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/VKCOM/nocc">Original</a>
    <h1>Nocc – A Distributed C&#43;&#43; Compiler</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto"><code>nocc</code> propagates a compiler invocation to a remote machine: <code>nocc g++ 1.cpp</code> calls <code>g++</code> remotely, not locally.</p>
<p dir="auto"><code>nocc</code> speeds up compilation of large C++ projects: when you have multiple remotes, tons of local jobs are parallelized between them.</p>
<p dir="auto">But its most significant effort is greatly speeding up re-compilation across build agents in CI/CD and across developers working on the same project:
they use shared remote caches.
Once a cpp file has been compiled, the resulting obj is used by other agents without launching compilation, actually.</p>
<p dir="auto"><code>nocc</code> easily integrates into any build system, since a build system should only prefix executing commands.</p>

<div dir="auto"><h2 tabindex="-1" dir="auto">The reason why nocc was created</h2><a id="user-content-the-reason-why-nocc-was-created" aria-label="Permalink: The reason why nocc was created" href="#the-reason-why-nocc-was-created"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><code>nocc</code> was created at VK.com to speed up KPHP compilation.
<a href="https://github.com/VKCOM/kphp">KPHP</a> is a PHP compiler: it converts PHP sources to C++.
VK.com codebase is huge, for how we have about <strong>150 000</strong> autogenerated cpp files.</p>
<p dir="auto">Our goal was to greatly improve the performance of the <em>&#34;C++ → binary&#34;</em> step.</p>
<p dir="auto">Since 2014, we used <a href="https://github.com/distcc/distcc">distcc</a>.</p>

<div dir="auto"><h2 tabindex="-1" dir="auto">Installation and configuration</h2><a id="user-content-installation-and-configuration" aria-label="Permalink: Installation and configuration" href="#installation-and-configuration"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The easiest way is just to download ready binaries — proceed to the <a href="https://github.com/VKCOM/nocc/releases">releases page</a>
and download the latest <code>.tar.gz</code> for your system: you&#39;ll have 3 binaries after extracting.</p>
<p dir="auto">You can also compile <code>nocc</code> from sources, see the <a href="https://github.com/VKCOM/nocc/blob/master/docs/installation.md">installation page</a>.</p>
<p dir="auto">For a test launch (to make sure that everything works), proceed to <a href="https://github.com/VKCOM/nocc/blob/master/docs/installation.md#run-a-simple-example-locally">this section</a>.</p>
<p dir="auto">For a list of command-line arguments and environment variables, visit the <a href="https://github.com/VKCOM/nocc/blob/master/docs/configuration.md">configuration page</a>.</p>


<p dir="auto">Consider the following file named <code>1.cpp</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="#include &#34;1.h&#34;

int square(int a) { 
  return a * a; 
}"><pre>#<span>include</span> <span><span>&#34;</span>1.h<span>&#34;</span></span>

<span>int</span> <span>square</span>(<span>int</span> a) { 
  <span>return</span> a * a; 
}</pre></div>
<p dir="auto">Having <code>1.h</code> be just like</p>

<p dir="auto">When you run <code>nocc g++ 1.cpp -o 1.o -c</code>, the compilation is done remotely:</p>
<p dir="auto">
    <a target="_blank" rel="noopener noreferrer" href="https://github.com/VKCOM/nocc/blob/master/docs/img/nocc-one-file.drawio.png"><img src="https://github.com/VKCOM/nocc/raw/master/docs/img/nocc-one-file.drawio.png" alt="one file" height="201"/></a>
</p>
<p dir="auto">What&#39;s actually happening here:</p>
<ul dir="auto">
<li><code>nocc</code> parses the command-line invocation: input files, include dirs, cxx flags, etc.</li>
<li>for an input file (<code>1.cpp</code>), <code>nocc</code> finds all dependencies: it traverses all <code>#include</code> recursively (which results in just one file <code>1.h</code> here)</li>
<li><code>nocc</code> uploads files to a server and waits</li>
<li><code>nocc-server</code> executes the same command-line (same cxx flags, but modified paths)</li>
<li><code>nocc-server</code> pushes a compiled object file back</li>
<li><code>nocc</code> saves <code>1.o</code> — the same as if compiled locally</li>
</ul>
<p dir="auto">Besides an object file, <code>nocc-server</code> pushes <em>exitCode/stdout/stderr</em> of the C++ compiler: <code>nocc</code> process uses them as a self output.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">In production, you have multiple compilation servers</h3><a id="user-content-in-production-you-have-multiple-compilation-servers" aria-label="Permalink: In production, you have multiple compilation servers" href="#in-production-you-have-multiple-compilation-servers"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Conceptually, you can think of a working scheme like this:</p>
<p dir="auto">
    <a target="_blank" rel="noopener noreferrer" href="https://github.com/VKCOM/nocc/blob/master/docs/img/nocc-many-files.drawio.png"><img src="https://github.com/VKCOM/nocc/raw/master/docs/img/nocc-many-files.drawio.png" alt="many files" height="356"/></a>
</p>
<p dir="auto">Lots of <code>nocc</code> processes are launched simultaneously — much more than you could launch if you use g++ locally.</p>
<p dir="auto">Every <code>nocc</code> invocation handles exactly one <code>.cpp -&gt; .o</code> compilation, it&#39;s by design.
It does remote compilation and dies — <code>nocc</code> is just a front-end layer between any build system and a real C++ compiler.</p>
<p dir="auto">For every invocation, a remote server is chosen, all dependencies are detected, missing dependencies are uploaded,
and the server streams back a ready obj file.
This happens in parallel for all command lines.</p>
<p dir="auto">Actually, to be more efficient, all connections are served via one background <strong>nocc-daemon</strong>:</p>
<p dir="auto">
    <a target="_blank" rel="noopener noreferrer" href="https://github.com/VKCOM/nocc/blob/master/docs/img/nocc-daemon.drawio.png"><img src="https://github.com/VKCOM/nocc/raw/master/docs/img/nocc-daemon.drawio.png" alt="daemon" height="356"/></a>
</p>
<p dir="auto"><code>nocc-daemon</code> is written in Go, whereas <code>nocc</code> is a very lightweight C++ wrapper,
the only aim of which is to pipe command-line to a daemon, wait for the response, and die.</p>
<p dir="auto">So, a final working scheme is the following:</p>
<ol dir="auto">
<li>The very first <code>nocc</code> invocation starts <code>nocc-daemon</code>:
a daemon serves grpc connections and actually does all stuff for remote compilation.</li>
<li>Every <code>nocc</code> invocation pipes a command-line (<code>g++ ...</code>) to a daemon via Unix socket, a daemon compiles it remotely and
writes the resulting .o file, then <code>nocc</code> process dies.</li>
<li><code>nocc</code> jobs start and die: a build system executes and balances them.</li>
<li><code>nocc-daemon</code> dies in 15 seconds after <code>nocc</code> stops connecting (after the compilation process finishes).</li>
</ol>
<p dir="auto">For more info, consider the <a href="https://github.com/VKCOM/nocc/blob/master/docs/architecture.md">nocc architecture page</a>.</p>

<div dir="auto"><h2 tabindex="-1" dir="auto">nocc is also a remote src/obj cache</h2><a id="user-content-nocc-is-also-a-remote-srcobj-cache" aria-label="Permalink: nocc is also a remote src/obj cache" href="#nocc-is-also-a-remote-srcobj-cache"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The main idea behind <code>nocc</code> is that <strong>the 2nd, the 3rd, the Nth runs are faster than the first</strong>.
Even if you clean a build directory, even on another machine, even in a renamed folder.</p>
<p dir="auto">That&#39;s because of remote caches.</p>
<p dir="auto">
    <a target="_blank" rel="noopener noreferrer" href="https://github.com/VKCOM/nocc/blob/master/docs/img/nocc-second-run.drawio.png"><img src="https://github.com/VKCOM/nocc/raw/master/docs/img/nocc-second-run.drawio.png" alt="second run" height="255"/></a>
</p>
<p dir="auto">Such an approach dramatically decreases compilation times if your CI has different build machines or your builds start from a fresh copy.
Moreover, git branch switching and merging is also a great target for remote caching.</p>


<p dir="auto">When CMake generates a buildfile for your C++ project, you typically launch the build process with <code>make</code> or <code>ninja</code>.
These build systems launch and balance processes and keep doing it until all C++ files are compiled.</p>
<p dir="auto">Our goal is to tell CMake to launch <code>nocc g++</code> instead of <code>g++</code> (or any other C++ compiler). This can be done
with <code>-DCMAKE_CXX_COMPILER_LAUNCHER</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="cmake -DCMAKE_CXX_COMPILER_LAUNCHER=/path/to/nocc .."><pre>cmake -DCMAKE_CXX_COMPILER_LAUNCHER=/path/to/nocc ..</pre></div>
<p dir="auto">Then <code>make</code> building would look like this:</p>
<p dir="auto">
    <a target="_blank" rel="noopener noreferrer" href="https://github.com/VKCOM/nocc/blob/master/docs/img/nocc-make%20-j.drawio.png"><img src="https://github.com/VKCOM/nocc/raw/master/docs/img/nocc-make%20-j.drawio.png" alt="make" height="301"/></a>
</p>
<p dir="auto">CMake sometimes invokes the C++ compiler with <code>-MD/-MT</code> flags to generate a dependency list.
<code>nocc</code> supports them out of the box, depfiles are generated on a client-side.</p>


<p dir="auto"><a href="https://ninja-build.org/" rel="nofollow">Ninja</a> is a build system, easily integrated to CMake instead of <code>make</code>.</p>
<p dir="auto"><code>nocc</code> works with <code>ninja</code>, but there are 2 points to care about:</p>
<ol dir="auto">
<li>Explicitly set <code>-j {jobs}</code> (typically, you don&#39;t do this with <code>ninja</code>, then it automatically spreads jobs across machine CPUs, but we need <em>{jobs}</em> to be a huge number).</li>
<li>There is an upsetting defect that (whyever) <code>ninja</code> incrementally waits for a daemon to die. A workaround is to launch a daemon manually in advance. <a href="https://github.com/VKCOM/nocc/blob/master/docs/ninja-problem.md">Read more</a> about this problem.</li>
</ol>


<p dir="auto">Originally, <code>nocc</code> was created to speed up compiling large KPHP projects, with lots of autogenerated C++ files.
KPHP does not call <code>make</code>: it has a build system right inside itself.</p>
<p dir="auto">To use <code>nocc</code> with KPHP, just set the <code>KPHP_CXX=nocc g++</code> environment variable.
Then <code>nocc</code> will be used for both C++ compilation and precompiled headers generation.</p>

<div dir="auto"><h2 tabindex="-1" dir="auto">Precompiled headers support</h2><a id="user-content-precompiled-headers-support" aria-label="Permalink: Precompiled headers support" href="#precompiled-headers-support"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><code>nocc</code> treats precompiled headers in a special way. When a client command to generate pch is executed,</p>
<div dir="auto" data-snippet-clipboard-copy-content="nocc g++ -x c++-header -o all-headers.h.gch all-headers.h"><pre>nocc g++ -x c++-header -o all-headers.h.gch all-headers.h</pre></div>
<p dir="auto">then <code>nocc</code> emits <code>all-headers.h.nocc-pch</code>, whereas <code>all-headers.h.gch</code> is <strong>not produced</strong> at all.
This is a text file containing all dependencies — compiled on a server-side into a real <code>.gch/.pch</code>.</p>
<p dir="auto">Generating a <code>.nocc-pch</code> file is much faster than generating a real precompiled header, so it&#39;s acceptable to call it for every build — anyway, it will be compiled remotely only once.</p>
<p dir="auto">Here you can <a href="https://github.com/VKCOM/nocc/blob/master/docs/architecture.md#own-precompiled-headers">read more</a> about own precompiled headers.</p>


<p dir="auto">It&#39;s quite incorrect to compare <code>nocc</code> with <code>ccache</code>, as <code>ccache</code> is not intended to parallelize compilation on remotes.
<code>ccache</code> can speed up compilation performed locally (especially useful when you switch git branches),
but when it comes to compiling a huge number of C++ files from scratch, everything is still done locally.</p>
<p dir="auto"><code>nocc</code> also greatly speeds up re-compilation when switching branches. But <code>nocc</code> does it in a completely different
ideological way: using remote caches.</p>


<p dir="auto">Because <code>nocc</code> was targeted as a distcc replacement, a detailed analysis of their differences is written on
the <a href="https://github.com/VKCOM/nocc/blob/master/docs/compare-with-distcc.md">compare with distcc page</a>.</p>
<p dir="auto">That page includes an architecture overview, some info about patching distcc with pch support,
and real build times from VK.com production.</p>


<p dir="auto"><code>nocc</code> architecture is specially tuned to be as fast as possible for typical usage scenarios.</p>
<ul dir="auto">
<li><code>nocc-daemon</code> keeps all connections alive, while <code>nocc</code> processes start and die during a build</li>
<li>to resolve all recursive <code>#include</code>, <code>nocc</code> does not invoke preprocessor: it uses its own parser instead</li>
<li><code>nocc-server</code> has the src cache: once <code>1.h</code> is uploaded by any client, no other clients need to upload this file again (unless changed)</li>
<li><code>nocc-server</code> has the obj cache: once <code>1.cpp</code> is compiled by any client, all other clients receive <code>1.o</code> without compilation (if all dependencies and flags match)</li>
<li>for a <code>file.cpp</code>, one and the same server is chosen every time to make remote caches reusable</li>
<li>shared precompiled headers: once <code>1.gch</code> compiled, no other build agents have to do it locally</li>
</ul>
<p dir="auto"><a href="https://github.com/VKCOM/nocc/blob/master/docs/architecture.md"><strong>Dig deeper into nocc architecture</strong></a></p>


<p dir="auto"><strong>What are the conditions to make sure that a remote .o file would equal a local .o?</strong></p>
<p dir="auto"><code>nocc</code> assumes that all remotes have the C++ compiler of exactly the same version as local.
That would ensure no difference, where exactly the compilation was launched if we have equal source files.
Since linking is done locally, remotes are not required to have all libs needed for linking.</p>
<p dir="auto"><strong>What if I #include &lt;re2.h&gt; but it doesn&#39;t exist on remote?</strong></p>
<p dir="auto">Everything would still work.
When <code>nocc</code> traverses dependencies, it also finds all system headers recursively, their hash sums are sent to the remote along with the cpp file info.
If some system includes are missing (or if they differ from local ones), they are also sent like regular files,
saved to the <code>/tmp</code> folder representing client file structure, and discovered via special <code>-isystem</code> arguments added to the command-line.</p>
<p dir="auto"><strong>How does nocc handle linking commands?</strong></p>
<p dir="auto">Linking is done locally. All commands that are unsupported or non-well-formed are done locally.</p>
<p dir="auto"><strong>What happens if some servers are unavailable?</strong></p>
<p dir="auto">When <code>nocc</code> tries to compile <code>1.cpp</code> remotely, but the server is unavailable, <code>nocc</code> falls back to local compilation.
It does not try another server, it&#39;s <a href="https://github.com/VKCOM/nocc/blob/master/docs/architecture.md#local-fallback-queue">intentionally</a>.</p>
<p dir="auto"><strong>Does nocc support clang?</strong></p>
<p dir="auto">Theoretically, there should be no difference, what compiler is being used: <code>g++</code>, or <code>clang++</code>, or <code>/usr/bin/c++</code>, etc.
Even <code>.pch</code> files are supposed to work, as pch compilation is done remotely.
Small tests for clang work well, but it hasn&#39;t been tested well in production, as we use only <code>g++</code> in KPHP and VK.com for now.</p>
<p dir="auto"><strong>What is the optimal job/server count?</strong></p>
<p dir="auto">The final number that we fixated at VK.com is <em>&#34;launch ~20 jobs for one server&#34;</em>.
For example, we have 32 compilation servers, and we launch ~600 jobs for C++ compilation.
This works well both when files are compiled and when they are just taken from obj cache.
Note, that if you use a large number of parallel jobs, you&#39;d probably have to increase <code>ulimit -n</code>,
as <code>nocc-daemon</code> reads lots of files and keeps all connections to <code>nocc</code> C++ wrappers simultaneously.</p>
<p dir="auto"><strong>I get an error &#34;compiling locally: rpc error: code = Unknown desc = file xxx.cpp was already uploaded, but now got another sha256 from client&#34;</strong></p>
<p dir="auto">This error occurs in such a scenario: you compile a file, they quickly modify it, and launch compilation again — a previous <code>nocc-daemon</code> is still running, previous file structure is still mapped to servers. Then the compilation for such file is done locally. In reality, such an error never occurs, as big projects take some time for linking/finalization after compilation (a daemon dies in 15 seconds).</p>
<p dir="auto"><strong>Why did you name this tool &#34;nocc&#34;?</strong></p>
<p dir="auto">We already have a PHP linter named <a href="https://github.com/VKCOM/noverify">noverify</a>
and an architecture validation tool <a href="https://github.com/VKCOM/nocolor">nocolor</a>.
That&#39;s why &#34;nocc&#34; — just because I like such naming :)</p>
</article></div></div>
  </body>
</html>
