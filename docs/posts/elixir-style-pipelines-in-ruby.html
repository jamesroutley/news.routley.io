<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.gregnavis.com/articles/elixir-style-pipelines-in-9-lines-of-ruby.html">Original</a>
    <h1>Elixir-style pipelines in Ruby</h1>
    
    <div id="readability-page-1" class="page"><div>
  <div>
    <h4 id="background--and-">Background: <code>&lt;&lt;</code> and <code>&gt;&gt;</code></h4>

<p>Ruby offers some pipelining primitives. <code>Proc</code> and <code>Method</code> respond to <code>#&lt;&lt;</code> and <code>#&gt;&gt;</code>, which can be used in pipelines:</p>

<div><div><pre><code><span>FindByLogin</span> <span>=</span> <span>proc</span> <span>{</span> <span>|</span><span>login</span><span>|</span> <span>...</span> <span>}</span>
<span>ConfirmUserAccount</span> <span>=</span> <span>proc</span> <span>{</span> <span>|</span><span>user</span><span>|</span> <span>...</span> <span>}</span>
<span>SendConfirmationNotification</span> <span>=</span> <span>proc</span> <span>{</span> <span>|</span><span>user</span><span>|</span> <span>...</span> <span>}</span>

<span>(</span><span>FindByLogin</span> <span>&gt;&gt;</span>
  <span>ConfirmUserAccount</span> <span>&gt;&gt;</span>
  <span>SendConfirmationNotification</span><span>).</span><span>call</span><span>(</span><span>&#34;gregnavis&#34;</span><span>)</span>
</code></pre></div></div>

<p>This approach has several drawbacks:</p>

<ol>
  <li>The <code>Proc</code> returned by <code>#&gt;&gt;</code> cannot be called using <code>result(...)</code>, but only via <code>proc.call(...)</code> or <code>proc.(...)</code> or <code>proc[...]</code>, which is inconsistent with regular method calls. Admittedly, this is unavoidable, but can be made to matter less.</li>
  <li>The pipeline argument comes at the end, but having it at the front would be more readable and more consistent with the pipeline structure.</li>
  <li>Operations taking more than one parameter must be implemented as higher-order procs or use currying. Introducing or eliminating additional parameters entails switching between regular procs and higher-order or curried procs.</li>
</ol>

<p>To illustrate the last problem, let’s make <code>SendConfirmationNotification</code> take an argument determining the type of notification: e-mail or SMS. It has to be rewritten as:</p>

<div><div><pre><code><span># Using a higher-order proc.</span>
<span>SendConfirmationNotification</span> <span>=</span> <span>proc</span> <span>do</span> <span>|</span><span>method</span><span>|</span>
  <span>proc</span> <span>{</span> <span>|</span><span>user</span><span>|</span> <span>...</span> <span>}</span>
<span>end</span>

<span># Using currying; notice .curry after the block</span>
<span>SendConfirmationNotification</span> <span>=</span> <span>proc</span> <span>do</span> <span>|</span><span>method</span><span>,</span> <span>user</span><span>|</span>
  <span>...</span>
<span>end</span><span>.</span><span>curry</span>
</code></pre></div></div>

<p>Unfortunately, the pipeline still suffers from the problem of argument coming at the end:</p>

<div><div><pre><code>(FindByLogin &gt;&gt;
  ConfirmUserAccount &gt;&gt;
  SendConfirmationNotification[:sms])[&#34;gregnavis&#34;]
</code></pre></div></div>

<p>The rest of the article shows how to use Ruby refinements, a built-in but relatively obscure facility, to make the code below work:</p>

<div><div><pre><code>&#34;gregnavis&#34; &gt;&gt;
  FindByLogin &gt;&gt;
  ConfirmUserAccount &gt;&gt;
  SendConfirmationNotification[:sms]
</code></pre></div></div>

<p>Let’s start with operator definitions. Monkey-patching will be used initially, but will be replaced with refinements by the end of the article.</p>

<h4 id="step-1-defining-parameterized-operations">Step 1: Defining Parameterized Operations</h4>

<p>Parameterized and parameterless operations should be defined the same way. A new <code>Kernel</code> method will help here:</p>

<div><div><pre><code>module Kernel
  def operation(...) = proc(...).curry
end
</code></pre></div></div>

<p>Basically, <code>operation</code> is an automatically curried <code>proc</code>. The pipeline can now be defined as:</p>

<div><div><pre><code>FindByLogin = operation { |login| ... }
ConfirmUserAccount = operation { |user| ... }

# Notice user comes last.
SendConfirmationNotification = operation { |method, user| ... }
</code></pre></div></div>

<p>Due to currying, the first argument to <code>SendConfirmationNotification</code> can be provided in the pipeline, while the execution is “paused” until <code>user</code> is provided, too. The code below now works as expected:</p>

<div><div><pre><code>(FindByLogin &gt;&gt;
  ConfirmUserAccount &gt;&gt;
  SendConfirmationNotification[:sms])[&#34;gregnavis&#34;]
</code></pre></div></div>

<p>The next goal is moving the pipeline to the front.</p>

<h4 id="step-2-piping-arguments-into-callables">Step 2: Piping Arguments into Callables</h4>

<p>The following two expressions should be equivalent:</p>

<div><div><pre><code><span># When we write this:</span>
<span>argument</span> <span>&gt;&gt;</span> <span>callable</span>

<span># we actually mean this:</span>
<span>callable</span><span>.</span><span>call</span><span>(</span><span>argument</span><span>)</span>
</code></pre></div></div>

<p>The snippet hints at what needs to be done: <em>all</em> objects must respond to <code>&gt;&gt;</code> and that method must call <code>call</code>. A top-level class (<code>Object</code> or <code>BasicObject</code>) must be modified to make <code>#&gt;&gt;</code> available on all objects, resulting in the following patch:</p>

<div><div><pre><code><span>class</span> <span>Object</span>
  <span>def</span> <span>&gt;&gt;</span><span>(</span><span>callable</span><span>)</span> <span>=</span> <span>callable</span><span>.</span><span>call</span><span>(</span><span>self</span><span>)</span>
<span>end</span>
</code></pre></div></div>

<p>Finally, we’re able to write:</p>

<div><div><pre><code><span>&#34;gregnavis&#34;</span> <span>&gt;&gt;</span>
  <span>FindUserByLogin</span> <span>&gt;&gt;</span>
  <span>ConfirmUserAccount</span> <span>&gt;&gt;</span>
  <span>SendConfirmationNotification</span><span>[</span><span>:sms</span><span>]</span>
</code></pre></div></div>

<p>The patches on <code>Kernel</code> and <code>Object</code> must be turned into a refinement to avoid global monkey patching.</p>

<h4 id="step-3-introducing-refinements">Step 3: Introducing Refinements</h4>

<p>Refinements are a topic for a separate article, but in short they are monkey-patches that can enabled inside a specific module or class by calling <code>Module#using</code>. Let’s approach the problem outside in by starting with how we want the code to be used.</p>

<p>Suppose we’re working inside a Rails controller. We’d like to be able to write code like this:</p>

<div><div><pre><code><span>class</span> <span>UsersController</span> <span>&lt;</span> <span>ApplicationController</span>
  <span>using</span> <span>Pipelines</span>

  <span>def</span> <span>confirm</span>
    <span>params</span><span>[</span><span>:login</span><span>]</span> <span>&gt;&gt;</span>
      <span>FindUserByLogin</span> <span>&gt;&gt;</span>
      <span>ConfirmUserAccount</span> <span>&gt;&gt;</span>
      <span>SendConfirmationNotification</span><span>[</span><span>:sms</span><span>]</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<p><code>using</code> is built into Ruby, and <code>Pipelines</code> is the refinement to be defined. It’s an ordinary Ruby module that refines (i.e. patches) <code>Kernel</code> and <code>Object</code>:</p>

<div><div><pre><code><span>module</span> <span>Pipelines</span>
  <span>refine</span> <span>Kernel</span> <span>do</span>
    <span>def</span> <span>operation</span><span>(</span><span>...</span><span>)</span> <span>=</span> <span>proc</span><span>(</span><span>...</span><span>).</span><span>curry</span>
  <span>end</span>

  <span>refine</span> <span>Object</span> <span>do</span>
    <span>def</span> <span>&gt;&gt;</span><span>(</span><span>callable</span><span>)</span> <span>=</span> <span>callable</span><span>.</span><span>call</span><span>(</span><span>self</span><span>)</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<p>That’s it! Pipelines are now enabled only in <code>UsersController</code>, and no other code will be affected. Keep in mind you need to be <code>using</code> the refinement when defining operations too (so that <code>operation</code> is available).</p>

<h4 id="summary">Summary</h4>

<p>That pipeline implementation would fit on a napkin. Let’s have a critical look at this approach.</p>

<p>First, calling a curried proc with no arguments keeps the execution “paused”, so missing an argument can make the pipeline return a curried proc, instead of the expected return value. This will likely lead to difficult to understand errors later in the program.</p>

<p>Second, procs are difficult to inspect. Seeing <code>#&lt;Proc:0x...&gt;</code> in the terminal is unhelpful when debugging. It <em>is</em> possible to inspect parameters passed to an operation via <code>operation_object.binding.local_variables</code> and <code>operation_object.binding.local_variable_get(name)</code> for parameters of interest. It’d be more helpful if inspecting an operation produced something along the lines of <code>SendConfirmationNotification[method: :sms]</code>.</p>

<h4 id="next-steps">Next Steps</h4>

<p>The above was my <em>second</em> approach to implementing pipelines. The first approach was object-oriented and didn’t have the drawbacks mentioned above at the expense of <em>slightly</em> more complex implementation. I’ll cover it an an upcoming article.</p>

    
      <div>
        <p>If you&#39;d like to see the next pipeline implementation or read about other advanced Ruby and Rails topics then leave me your email below.</p>

          </div>

      </div>
    
</div></div>
  </body>
</html>
