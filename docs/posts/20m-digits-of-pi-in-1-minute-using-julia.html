<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gist.github.com/juliusgeo/41811563811a6e523086e514ef2bec4a">Original</a>
    <h1>20M digits of pi in 1 minute using Julia</h1>
    
    <div id="readability-page-1" class="page"><div>
  <div id="file-gauss-legendre-md">
      
      <div id="file-gauss-legendre-md-readme">
    <article itemprop="text">
<p dir="auto">I recently discovered a relatively obscure algorithm for calculating the digits of pi: <a href="https://en.wikipedia.org/wiki/Gauss%E2%80%93Legendre_algorithm" rel="nofollow">https://en.wikipedia.org/wiki/Gauss–Legendre_algorithm</a>.
Well, at least obscure compared to Chudnovsky&#39;s. Wikipedia notes that it is &#34;memory-intensive&#34; but is it really?
Let&#39;s compare to the MPFR <code>pi</code> function:</p>
<div dir="auto"><pre><span>function</span> <span>gauss_legendre</span>(prec)
    <span>setprecision</span>(BigFloat, prec, base<span>=</span><span>10</span>)
    GC<span>.</span><span>enable</span>(<span>false</span>)
    <span>println</span>(<span>precision</span>(BigFloat, base<span>=</span><span>2</span>))
    x<span>::</span><span>BigFloat</span> <span>=</span> a<span>::</span><span>BigFloat</span> <span>=</span> <span>BigFloat</span>(<span>1</span>, precision<span>=</span><span>precision</span>(BigFloat, base<span>=</span><span>2</span>))
    b<span>::</span><span>BigFloat</span> <span>=</span> <span>BigFloat</span>(a <span>/</span> <span>sqrt</span>(<span>BigFloat</span>(<span>2</span>, precision<span>=</span><span>precision</span>(BigFloat, base<span>=</span><span>2</span>))))
    t<span>::</span><span>BigFloat</span> <span>=</span> <span>BigFloat</span>(a <span>/</span> <span>4</span>, precision<span>=</span><span>precision</span>(BigFloat, base<span>=</span><span>2</span>))
    y<span>::</span><span>BigFloat</span> <span>=</span> a
    <span>for</span> _<span>=</span><span>0</span><span>:</span><span>ceil</span>(BigInt, <span>log2</span>(prec))
        y, a <span>=</span> a<span>::</span><span>BigFloat</span>, (a<span>::</span><span>BigFloat</span> <span>+</span> b<span>::</span><span>BigFloat</span>) <span>/</span> <span>2</span>
        b <span>=</span> <span>sqrt</span>(b<span>::</span><span>BigFloat</span><span>*</span>y<span>::</span><span>BigFloat</span>)
        t <span>=</span> t<span>::</span><span>BigFloat</span><span>-</span>(x<span>::</span><span>BigFloat</span> <span>*</span> (y<span>::</span><span>BigFloat</span><span>-</span>a<span>::</span><span>BigFloat</span>)<span>^</span><span>2</span>)
        x <span>=</span> x<span>::</span><span>BigFloat</span><span>*</span><span>2</span>
    <span>end</span>
    (a <span>+</span> b)<span>^</span><span>2</span> <span>/</span> (<span>4</span> <span>*</span> t)
<span>end</span>
<span>function</span> <span>mpfr_pi</span>(ndigits<span>::</span><span>Int64</span>)
    <span>setprecision</span>(ndigits, base<span>=</span><span>10</span>)
    <span>BigFloat</span>(π)
<span>end</span>
<span>gauss_legendre</span>(<span>1</span>)
<span>@time</span> <span>begin</span>
    my_pi <span>=</span> <span>gauss_legendre</span>(<span>20000000</span>)
<span>end</span>
<span>mpfr_pi</span>(<span>1</span>)
<span>@time</span> <span>begin</span>
    mpfrs_pi <span>=</span> <span>mpfr_pi</span>(<span>20000000</span>)
<span>end</span>
<span>println</span>(<span>Float64</span>((my_pi<span>::</span><span>BigFloat</span><span>-</span>mpfrs_pi<span>::</span><span>BigFloat</span>)<span>::</span><span>BigFloat</span><span>*</span><span>20000000</span>))</pre></div>
<p dir="auto">20 million digits is a fair amount! Let&#39;s see how they run:</p>
<pre><code> 59.159281 seconds (477.69 k allocations: 18.049 GiB)
 42.238366 seconds (390.11 k allocations: 12.369 GiB)
-0.0
</code></pre>
<p dir="auto">All benchmarks shown are run on my 2020 MBP 13&#39; M1.
That last number is the &#34;error&#34; (comparing our implementation to MPFR).
Only ~17 seconds slower, and with about 6 more gigs of memory allocated. However--my algorithm is written in pure Julia, whereas MPFR is in C.
Perhaps this is the new holy grail of pi-computation algorithms?</p>
<p dir="auto">Oh, and I mentioned Chudnovsky&#39;s algorithm:</p>
<pre><code> 32.878370 seconds (1.48 M allocations: 25.777 GiB, 0.01% compilation time)
</code></pre>
<p dir="auto">That was for only 100k digits. Perhaps I&#39;m missing something but why has no one set a world record with Gauss-Legendre?
If anyone has a super powerful computer and wants to try this out, please post the results below. I wanna see how far you can push this.</p>
</article>
  </div>

  </div>
</div></div>
  </body>
</html>
