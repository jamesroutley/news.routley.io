<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://matklad.github.io/2023/04/09/can-you-trust-a-compiler-to-optimize-your-code.html">Original</a>
    <h1>Can you trust a compiler to optimize your code?</h1>
    
    <div id="readability-page-1" class="page"><div>
  <article>

    
<p><span>More or less the title this time, but first, a story about SIMD. There are three</span>
<span>levels of understanding how SIMD works (well, at least I am level 3 at the moment):</span></p>
<ol>
<li>
<p><span>Compilers are smart! They will auto-vectorize all the code!</span></p>
</li>
<li>
<p><span>Compilers are dumb, auto-vectorization is fragile, it</span>’<span>s very easy to break it</span>
<span>by unrelated changes to the code. It</span>’<span>s always better to manually write</span>
<span>explicit SIMD instructions.</span></p>
</li>
<li>
<p><span>Writing SIMD by hand is really hard </span>—<span> you</span>’<span>ll need to re-do the work for</span>
<span>every different CPU architecture. Also, you probably think that, for scalar</span>
<span>code, a compiler writes better assembly than you. What makes you think that</span>
<span>you</span>’<span>d beat the compiler at SIMD, where there are more funky instructions and</span>
<span>constraints? Compilers are tools. They can reliably vectorize code if it is</span>
<span>written in an amenable-to-vectorization form.</span></p>
</li>
</ol>
<p><span>I</span>’<span>ve recently moved from the second level to the third one, and that made me aware of the moment when the model used by a compiler for optimization clicked in my head.</span>
<span>In this post, I want to explain the general framework for reasoning about compiler optimizations for static languages such as Rust or C++.</span>
<span>After that, I</span>’<span>ll apply that framework to auto-vectorization.</span></p>
<p><span>I haven</span>’<span>t worked on backends of production optimizing compilers, so the following will not be academically correct, but these models are definitely helpful at least to me!</span></p>
<section id="Seeing-Like-a-Compiler">

    <h2>
    <a href="#Seeing-Like-a-Compiler"><span>Seeing Like a Compiler</span> </a>
    </h2>
<p><span>The first bit of a puzzle is understanding how a compiler views code. Some useful references here include</span>
<a href="https://link.springer.com/book/10.1007/978-3-030-80515-9"><em><span>The SSA Book</span></em></a><span> or LLVM</span>’<span>s</span>
<a href="https://llvm.org/docs/LangRef.html"><em><span>Language Reference</span></em></a><span>.</span></p>
<p><span>Another interesting choice would be </span><a href="https://webassembly.github.io/spec/core/"><em><span>WebAssembly Specification</span></em></a><span>.</span>
<span>While WASM would be a poor IR for an optimizing compiler, it has a lot of structural similarities, and the core spec is exceptionally readable.</span></p>
<p><span>A unit of optimization is a function.</span>
<span>Let</span>’<span>s take a simple function like the following:</span></p>

<figure>


<pre><code><span>fn</span> <span>sum</span>(xs: &amp;[<span>i32</span>]) <span>-&gt;</span> <span>i32</span> {</code>
<code>  <span>let</span> <span>mut </span><span>total</span> = <span>0</span>;</code>
<code>  <span>for</span> <span>i</span> <span>in</span> <span>0</span>..xs.<span>len</span>() {</code>
<code>    total = total.<span>wrapping_add</span>(xs[i]);</code>
<code>  }</code>
<code>  total</code>
<code>}</code></pre>

</figure>
<p><span>In some pseudo-IR, it would look like this:</span></p>

<figure>


<pre><code>fn sum return i32 {</code>
<code>  param xs_ptr: ptr</code>
<code>  param xs_len: size</code>
<code></code>
<code>  local total: i32 = 0</code>
<code>  local i: size = 0</code>
<code>  local x: i32</code>
<code></code>
<code>loop:</code>
<code>  branch_if i &gt;= xs_len :ret</code>
<code>  load x base=xs_ptr offset=i</code>
<code>  add total x</code>
<code>  add i 1</code>
<code>  goto :loop</code>
<code></code>
<code>ret:</code>
<code>  return total</code>
<code>}</code></pre>

</figure>
<p><span>The most important characteristic here is that there are two kinds of entities:</span></p>
<p><em><span>First</span></em><span>, there is program memory, very roughly an array of bytes.</span>
<span>Compilers generally can not reason about the contents of the memory very well, because it is shared by all the functions, and different functions might interpret the contents of the memory differently.</span></p>
<p><em><span>Second</span></em><span>, there are local variables.</span>
<span>Local variables are not bytes </span>—<span> they are integers, they obey mathematical properties which a compiler can reason about.</span></p>
<p><span>For example, if a compiler sees a loop like</span></p>

<figure>


<pre><code>param n: u32</code>
<code>local i: u32 = 0</code>
<code>local total: u32</code>
<code>local tmp</code>
<code></code>
<code>loop:</code>
<code>  branch_if i &gt;= n :ret</code>
<code>  set tmp i</code>
<code>  mul tmp 4</code>
<code>  add t tmp</code>
<code>  goto :loop</code>
<code></code>
<code>ret:</code>
<code>  return total</code></pre>

</figure>
<p><span>It can </span><em><span>reason</span></em><span> that on each iteration </span><code>tmp</code><span> holds </span><code>i * 4</code><span> and optimize the code to</span></p>

<figure>


<pre><code>param n: u32</code>
<code>local i: u32 = 0</code>
<code>local total: u32</code>
<code>local tmp = 0</code>
<code></code>
<code>loop:</code>
<code>  branch_if i &gt;= n :ret</code>
<code>  add t tmp</code>
<code>  add tmp 4  # replace multiplication with addition</code>
<code>  goto :loop</code>
<code></code>
<code>ret:</code>
<code>  return total</code></pre>

</figure>
<p><span>This works, because all locals are just numbers.</span>
<span>If we did the same computation, but all numbers were located in memory, it would be significantly harder for a compiler to reason that the transformation is actually correct.</span>
<span>What if the storage for </span><code>n</code><span> and </span><code>total</code><span> actually overlaps?</span>
<span>What if </span><code>tmp</code><span> overlaps with something which isn</span>’<span>t even in the current function?</span></p>
<p><span>However, there</span>’<span>s a bridge between the worlds of mathematical local variables and the world of memory bytes </span>—<span> </span><code>load</code><span> and </span><code>store</code><span> instructions.</span>
<span>The </span><code>load</code><span> instruction takes a range of bytes in memory, interprets the bytes as an integer, and stores that integer into a local variable.</span>
<span>The </span><code>store</code><span> instruction does the opposite.</span>
<span>By loading something from memory into a local, a compiler gains the ability to reason about it precisely.</span>
<span>Thus, the compiler doesn</span>’<span>t need to track the general contents of memory.</span>
<span>It only needs to check that it would be correct to load from memory at a specific point in time.</span></p>
<p><span>So, a compiler really doesn</span>’<span>t see all that well </span>—<span> it can only really reason about a single function at a time, and only about the local variables in that function.</span></p>
</section>
<section id="Bringing-Code-Closer-to-Compiler-s-Nose">

    <h2>
    <a href="#Bringing-Code-Closer-to-Compiler-s-Nose"><span>Bringing Code Closer to Compiler</span>’<span>s Nose</span> </a>
    </h2>
<p><span>Compilers are myopic.</span>
<span>This can be fixed by giving more context to the compiler, which is the task of two core optimizations.</span></p>
<p><em><span>The first</span></em><span> core optimization is </span><dfn><span>inlining</span></dfn><span>.</span>
<span>It substitutes callee</span>’<span>s body for a specific call.</span>
<span>The benefit here is not that we eliminate function call overhead, that</span>’<span>s relatively minor.</span>
<span>The big thing is that locals of both the caller and the callee are now in the same frame, and a compiler can optimize them together.</span></p>
<p><span>Let</span>’<span>s look again at that Rust code:</span></p>

<figure>


<pre><code><span>fn</span> <span>sum</span>(xs: &amp;[<span>i32</span>]) <span>-&gt;</span> <span>i32</span> {</code>
<code>  <span>let</span> <span>mut </span><span>total</span> = <span>0</span>;</code>
<code>  <span>for</span> <span>i</span> <span>in</span> <span>0</span>..xs.<span>len</span>() {</code>
<code>    total = total.<span>wrapping_add</span>(xs[i]);</code>
<code>  }</code>
<code>  total</code>
<code>}</code></pre>

</figure>
<p><span>The </span><code>xs[i]</code><span> expression there is actually a function call.</span>
<span>The indexing function does a bounds check before accessing the element of an array.</span>
<span>After inlining it into the </span><code>sum</code><span>, compiler can see that it is dead code and eliminate it.</span></p>
<p><span>If you look at various standard optimizations, they often look like getting rid of dumb things, which no one would actually write in the first place, so its not clear immediately if it is worth it to implement such optimizations.</span>
<span>But the thing is, after inlining a lot of dumb things appear, because functions tend to handle the general case, and, at a specific call-site, there are usually enough constraints to dismiss many edge cases.</span></p>
<p><em><span>The second</span></em><span> core optimization is </span><dfn><span>scalar replacement of aggregates</span></dfn><span>.</span>
<span>It is a generalization of the </span>“<span>let</span>’<span>s use </span><code>load</code><span> to avoid reasoning about memory and reason about a local instead</span>”<span> idea we</span>’<span>ve already seen.</span></p>
<p><span>If you have a function like</span></p>

<figure>


<pre><code><span>fn</span> <span>permute</span>(xs: &amp;<span>mut</span> <span>Vec</span>&lt;<span>i32</span>&gt;) {</code>
<code>  ...</code>
<code>}</code></pre>

</figure>
<p><span>it</span>’<span>s pretty difficult for the compiler to reason about it.</span>
<span>It receives a pointer to some memory which holds a complex struct (ptr, len, capacity triple), so reasoning about evolution of this struct is hard.</span>
<span>What the compiler can do is to load this struct from memory, replacing the aggregate with a bunch of scalar local variables:</span></p>

<figure>


<pre><code>fn permute(xs: &amp;mut Vec&lt;i32&gt;) {</code>
<code>  local ptr: ptr</code>
<code>  local len: usize</code>
<code>  local cap: usize</code>
<code></code>
<code>  load ptr xs.ptr</code>
<code>  load len xs.len</code>
<code>  load cap xs.cap</code>
<code></code>
<code>  ...</code>
<code></code>
<code>  store xs.ptr ptr</code>
<code>  store xs.len len</code>
<code>  store xs.cap cap</code>
<code>}</code></pre>

</figure>
<p><span>This way, a compiler again gains reasoning power.</span>
<span>SROA is like inlining, but for memory rather than code.</span></p>
</section>
<section id="Impossible-and-Possible">

    <h2>
    <a href="#Impossible-and-Possible"><span>Impossible and Possible</span> </a>
    </h2>
<p><span>Using this mental model of a compiler which:</span></p>
<ul>
<li>
<span>optimizes on a per-function basis,</span>
</li>
<li>
<span>can inline function calls,</span>
</li>
<li>
<span>is great at noticing relations between local variables and rearranging the code based on that,</span>
</li>
<li>
<span>is capable of </span><em><span>limited</span></em><span> reasoning about the memory (namely, deciding when it</span>’<span>s safe to </span><code>load</code><span> or </span><code>store</code><span>)</span>
</li>
</ul>
<p><span>we can describe which code is reliably optimizable, and which code prevents optimizations, explaining zero cost abstractions.</span></p>
<p><span>To enable inlining, a compiler needs to know which function is actually called.</span>
<span>If a function is called directly, it</span>’<span>s pretty much guaranteed that a compiler would try to inline it.</span>
<span>If the call is indirect (via function pointer, or via a table of virtual functions), in the general case a compiler won</span>’<span>t be able to inline that.</span>
<span>Even for indirect calls, sometimes the compiler can reason about the value of the pointer and de-virtualize the call, but that relies on successful optimization elsewhere.</span></p>
<p><span>This is the reason why, in Rust, every function has a unique, zero-sized type with no runtime representation.</span>
<span>It statically guarantees that the compiler could always inline the code, and makes this abstraction zero cost, because any decent optimizing compiler will melt it to nothing.</span></p>
<p><span>A higher level language might choose to </span><em><span>always</span></em><span> represent functions with function pointers.</span>
<span>In practice, in many cases the resulting code would be equivalently optimizable.</span>
<span>But there won</span>’<span>t be any indication in the source whether this is an optimizable case (the actual pointer is knowable at compile time) or a genuinely dynamic call.</span>
<span>With Rust, the difference between guaranteed to be optimizable and potentially optimizable is reflected in the source language:</span></p>

<figure>


<pre><code></code>
<code><span>fn</span> <span>call1</span>&lt;F: <span>Fn</span>()&gt;(f: F) {</code>
<code>  <span>f</span>()</code>
<code>}</code>
<code></code>
<code></code>
<code><span>fn</span> <span>call2</span>(f: <span>fn</span>()) {</code>
<code>  <span>f</span>()</code>
<code>}</code></pre>

</figure>
<p><span>So, the first rule is to make most of the calls statically resolvable, to allow inlining.</span>
<span>Function pointers and dynamic dispatch prevent inlining.</span>
<span>Separate compilation might also get in a way of inlining, see this </span><a href="https://matklad.github.io/2021/07/09/inline-in-rust.html"><span>separate essay</span></a><span> on the topic.</span></p>
<p><span>Similarly, indirection in </span><em><span>memory</span></em><span> can cause troubles for the compiler.</span></p>
<p><span>For something like this</span></p>

<figure>


<pre><code><span>struct</span> <span>Foo</span> {</code>
<code>  bar: Bar,</code>
<code>  baz: Baz,</code>
<code>}</code></pre>

</figure>
<p><span>the </span><code>Foo</code><span> struct is completely transparent for the compiler.</span></p>
<p><span>While here:</span></p>

<figure>


<pre><code><span>struct</span> <span>Foo</span> {</code>
<code>  bar: <span>Box</span>&lt;Bar&gt;,</code>
<code>  baz: Baz,</code>
<code>}</code></pre>

</figure>
<p><span>it is not clear cut.</span>
<span>Proving something about the memory occupied by </span><code>Foo</code><span> does not in general transfer to the memory occupied by </span><code>Bar</code><span>.</span>
<span>Again, in many cases a compiler </span><em><span>can</span></em><span> reason through boxes thanks to uniqueness, but this is not guaranteed.</span></p>
<p><span>A good homework at this point is to look at Rust</span>’<span>s iterators and understand why they look the way they do.</span></p>
<p><span>Why the signature and definition of </span><a href="https://doc.rust-lang.org/stable/core/iter/trait.Iterator.html#method.map"><code>map</code></a><span> is</span></p>

<figure>


<pre><code><span>#[inline]</span></code>
<code><span>fn</span> <span>map</span>&lt;B, F&gt;(<span>self</span>, f: F) <span>-&gt;</span> Map&lt;<span>Self</span>, F&gt;</code>
<code><span>where</span></code>
<code>  <span>Self</span>: <span>Sized</span>,</code>
<code>  F: <span>FnMut</span>(<span>Self</span>::Item) <span>-&gt;</span> B,</code>
<code>{</code>
<code>  Map::<span>new</span>(<span>self</span>, f)</code>
<code>}</code></pre>

</figure>
<p><span>Another important point about memory is that, in general, a compiler can</span>’<span>t change the overall layout of stuff.</span>
<span>SROA can load some data structure into a bunch of local variables, which then can, eg, replace </span>“<span>a pointer and an index</span>”<span> representation with </span>“<span>a pair of pointers</span>”<span>.</span>
<span>But at the end of the day SROA would have to materialize </span>“<span>a pointer and an index</span>”<span> back and store that representation back into the memory.</span>
<span>This is because memory layout is shared across all functions, so a function can not unilaterally dictate a more optimal representation.</span></p>
<p><span>Together, these observations give a basic rule for the baseline of performant code.</span></p>

</section>
<section id="SIMD">

    <h2>
    <a href="#SIMD"><span>SIMD</span> </a>
    </h2>
<p><span>Let</span>’<span>s apply this general framework of giving a compiler optimizable code to work with to auto-vectorization.</span>
<span>We will be optimizing the function which computes the longest common prefix between two slices of bytes (thanks </span><a href="https://github.com/nkkarpov"><span>@nkkarpov</span></a><span> for the example).</span></p>
<p><span>A  direct implementation would look like this:</span></p>

<figure>


<pre><code><span>use</span> std::iter::zip;</code>
<code></code>
<code></code>
<code><span>fn</span> <span>common_prefix</span>(xs: &amp;[<span>u8</span>], ys: &amp;[<span>u8</span>]) <span>-&gt;</span> <span>usize</span> {</code>
<code>  <span>let</span> <span>mut </span><span>result</span> = <span>0</span>;</code>
<code>  <span>for</span> (x, y) <span>in</span> <span>zip</span>(xs, ys) {</code>
<code>    <span>if</span> x != y { <span>break</span>; }</code>
<code>    result += <span>1</span></code>
<code>  }</code>
<code>  result</code>
<code>}</code></pre>

</figure>
<p><span>If you already have a mental model for auto-vectorization, or if you look at the assembly output, you can realize that the function as written works one byte at a time, which is much slower than it needs to be.</span>
<span>Let</span>’<span>s fix that!</span></p>
<p><span>SIMD works on many values simultaneously.</span>
<span>Intuitively, we want the compiler to compare a bunch of bytes at the same time, but our current code does not express that.</span>
<span>Let</span>’<span>s make the structure explicit, by processing 16 bytes at a time, and then handling remainder separately:</span></p>

<figure>


<pre><code></code>
<code><span>fn</span> <span>common_prefix</span>(xs: &amp;[<span>u8</span>], ys: &amp;[<span>u8</span>]) <span>-&gt;</span> <span>usize</span> {</code>
<code>  <span>let</span> <span>chunk_size</span> = <span>16</span>;</code>
<code></code>
<code>  <span>let</span> <span>mut </span><span>result</span> = <span>0</span>;</code>
<code></code>
<code>  <span>&#39;outer</span>: <span>for</span> (xs_chunk, ys_chunk) <span>in</span></code>
<code>    <span>zip</span>(xs.<span>chunks_exact</span>(chunk_size), ys.<span>chunks_exact</span>(chunk_size))</code>
<code>  {</code>
<code>    <span>for</span> (x, y) <span>in</span> <span>zip</span>(xs_chunk, ys_chunk) {</code>
<code>      <span>if</span> x != y { <span>break</span> <span>&#39;outer</span>; }</code>
<code>      result += <span>1</span></code>
<code>    }</code>
<code>  }</code>
<code></code>
<code>  <span>for</span> (x, y) <span>in</span> <span>zip</span>(&amp;xs[result..], &amp;ys[result..]) {</code>
<code>    <span>if</span> x != y { <span>break</span>; }</code>
<code>    result += <span>1</span></code>
<code>  }</code>
<code></code>
<code>  result</code>
<code>}</code></pre>

</figure>
<p><span>Amusingly, this is already a bit faster, but not quite there yet.</span>
<span>Specifically, SIMD needs to process all values in the chunk in parallel in the same way.</span>
<span>In our code above, we have a </span><code>break</code><span>, which means that processing of the nth pair of bytes depends on the n-1st pair.</span>
<span>Let</span>’<span>s fix </span><em><span>that</span></em><span> by disabling short-circuiting.</span>
<span>We will check if the whole chunk of bytes matches or not, but we won</span>’<span>t care which specific byte is a mismatch:</span></p>

<figure>


<pre><code></code>
<code><span>fn</span> <span>common_prefix3</span>(xs: &amp;[<span>u8</span>], ys: &amp;[<span>u8</span>]) <span>-&gt;</span> <span>usize</span> {</code>
<code>  <span>let</span> <span>chunk_size</span> = <span>16</span>;</code>
<code></code>
<code>  <span>let</span> <span>mut </span><span>result</span> = <span>0</span>;</code>
<code>  <span>for</span> (xs_chunk, ys_chunk) <span>in</span></code>
<code>    <span>zip</span>(xs.<span>chunks_exact</span>(chunk_size), ys.<span>chunks_exact</span>(chunk_size))</code>
<code>  {</code>
<code>    <span>let</span> <span>mut </span><span>chunk_equal</span>: <span>bool</span> = <span>true</span>;</code>
<code>    <span>for</span> (x, y) <span>in</span> <span>zip</span>(xs_chunk, ys_chunk) {</code>
<code>      </code>
<code>      chunk_equal = chunk_equal &amp; (x == y);</code>
<code>    }</code>
<code></code>
<code>    <span>if</span> !chunk_equal { <span>break</span>; }</code>
<code>    result += chunk_size;</code>
<code>  }</code>
<code></code>
<code>  <span>for</span> (x, y) <span>in</span> <span>zip</span>(&amp;xs[result..], &amp;ys[result..]) {</code>
<code>    <span>if</span> x != y { <span>break</span>; }</code>
<code>    result += <span>1</span></code>
<code>  }</code>
<code></code>
<code>  result</code>
<code>}</code></pre>

</figure>
<p><span>And this version finally lets vectorization kick in, reducing the runtime almost by an order of magnitude.</span>
<span>We can now compress this version using iterators.</span></p>

<figure>


<pre><code></code>
<code><span>fn</span> <span>common_prefix5</span>(xs: &amp;[<span>u8</span>], ys: &amp;[<span>u8</span>]) <span>-&gt;</span> <span>usize</span> {</code>
<code>  <span>let</span> <span>chunk_size</span> = <span>16</span>;</code>
<code></code>
<code>  <span>let</span> <span>off</span> =</code>
<code>    <span>zip</span>(xs.<span>chunks_exact</span>(chunk_size), ys.<span>chunks_exact</span>(chunk_size))</code>
<code>      .<span>take_while</span>(|(xs_chunk, ys_chunk)| xs_chunk == ys_chunk)</code>
<code>      .<span>count</span>() * chunk_size;</code>
<code></code>
<code>  off + <span>zip</span>(&amp;xs[off..], &amp;ys[off..])</code>
<code>    .<span>take_while</span>(|(x, y)| x == y)</code>
<code>    .<span>count</span>()</code>
<code>}</code></pre>

</figure>
<p><span>Note how the code is meaningfully different from our starting point.</span>
<span>We do not blindly rely on the compiler</span>’<span>s optimization.</span>
<span>Rather, we are aware about specific optimizations we need in this case, and write the code in a way that triggers them.</span></p>
<p><span>Specifically, for SIMD:</span></p>
<ul>
<li>
<span>we express the algorithm in terms of processing </span><em><span>chunks</span></em><span> of elements,</span>
</li>
<li>
<span>within each chunk, we make sure that there</span>’<span>s no branching and all elements are processed in the same way.</span>
</li>
</ul>
</section>
<section id="Conclusion">

    <h2>
    <a href="#Conclusion"><span>Conclusion</span> </a>
    </h2>
<p><span>Compilers are tools.</span>
<span>While there</span>’<span>s a fair share of </span>“<span>optimistic</span>”<span> transformations which sometimes kick in, the bulk of the impact of an optimizing compiler comes from guaranteed optimizations with specific preconditions.</span>
<span>Compilers are myopic </span>—<span> they have a hard time reasoning about code outside of the current function and values not held in the local variables.</span>
<span>Inlining and scalar replacement of aggregates are two optimizations to remedy the situation.</span>
<span>Zero cost abstractions work by expressing opportunities for guaranteed optimizations in the language</span>’<span>s type system.</span></p>
<p><span>If you like this post, I highly recommend </span><a href="https://www.clear.rice.edu/comp512/Lectures/Papers/1971-allen-catalog.pdf"><em><span>A Catalogue of Optimizing Transformations</span></em></a><span> by Frances Allen.</span></p>
</section>
</article>
  </div></div>
  </body>
</html>
