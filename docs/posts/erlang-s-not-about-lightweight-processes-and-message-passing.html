<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/stevana/armstrong-distributed-systems/blob/main/docs/erlang-is-not-about.md">Original</a>
    <h1>Erlang&#39;s not about lightweight processes and message passing</h1>
    
    <div id="readability-page-1" class="page"><div>

    <div data-target="readme-toc.content">
      
  


        <div id="readme">
    <article itemprop="text"><table>
  <thead>
  <tr>
  <th>date</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td><p>2023-01-18</p></td>
  </tr>
  </tbody>
</table>


<p dir="auto">I used to think that the big idea of Erlang is its lightweight processes and
message passing. Over the last couple of years I&#39;ve realised that there&#39;s a
bigger insight to be had, and in this post I&#39;d like to share it with you.</p>
<h2 dir="auto"><a id="user-content-background" aria-hidden="true" href="#background"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Background</h2>
<p dir="auto">Erlang has an interesting history. If I understand things correctly, it started
of as a Prolog library for building reliable distributed systems, morphed into a
Prolog dialect, before finally becoming a language in its own right.</p>
<p dir="auto">The goal seemed to have always been to solve the problem of building reliable
distributed systems. It was developed at Ericsson and used to program their
telephone switches. This was sometime in the 80s and 90s, before internet use
become widespread. I suppose they were already dealing with &#34;internet scale&#34;
traffic, i.e. hundreds of millions of users, with stricter SLAs than most
internet services provide today. So in a sense they were ahead of their time.</p>
<p dir="auto">In 1998 Ericsson decided to ban all use of Erlang. The people responsible for
developing it argued that if they were going to ban it, then they might as well
open source it. Which Ericsson did and shortly after the whole team working on
Erlang quit and started their own company.</p>
<p dir="auto">One of these people was Joe Armstrong, which also was one of the main people
behind the design and implementation of Erlang. The company was called Bluetail
and they got bought up a couple of times but in the end Joe got fired in 2002.</p>
<p dir="auto">Shortly after, still in 2002, Joe starts writing his PhD thesis at the Swedish
Institute of Computer Science (SICS). Joe was born 1950, so he was probably 52
years old at this point. The topic of the thesis is <em>Making reliable distributed
systems in the presence of software errors</em> and it was finished the year after
in 2003.</p>
<p dir="auto">It&#39;s quite an unusual thesis in many ways. For starters, most theses are written
by people in their twenties with zero experience of practical applications.
Whereas in Joe&#39;s case he has been working professionally on this topic since the
80s, i.e. about twenty years. The thesis contains no math nor theory, it&#39;s
merely a presentation of the ideas that underpin Erlang and how they used Erlang
to achieve the original goal of building reliable distributed systems.</p>
<p dir="auto">I highly commend reading his
<a href="http://kth.diva-portal.org/smash/record.jsf?pid=diva2%3A9492&amp;dswid=-1166" rel="nofollow">thesis</a>
and forming your own opinion, but to me it&#39;s clear that the big idea there isn&#39;t
lightweight processes<sup><a href="#user-content-fn-1-36a93bf173b7880cb5fb71f8a9ffcae4" id="user-content-fnref-1-36a93bf173b7880cb5fb71f8a9ffcae4" data-footnote-ref="" aria-describedby="footnote-label">1</a></sup> and message passing, but rather the generic components
which in Erlang are called <em>behaviours</em>.</p>
<h2 dir="auto"><a id="user-content-behaviours" aria-hidden="true" href="#behaviours"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Behaviours</h2>
<p dir="auto">I&#39;ll first explain in more detail what behaviours are, and then I&#39;ll come back
to the point that they are more important than the idea of lightweight processes.</p>
<p dir="auto">Erlang behaviours are like interfaces in, say, Java or Go. It&#39;s a collection of
type signatures which can have multiple implementations, and once the programmer
provides such an implementation they get access to functions written against
that interface. To make it more concrete here&#39;s a contrived example in Go:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// The interface.
type HasName interface {
        Name() string
}

// A generic function written against the interface.
func Greet(n HasName) {
    fmt.Printf(&#34;Hello %s!\n&#34;, n.Name())
}

// First implementation of the interface.
type Joe struct {}

func (_ *Joe) Name() string {
        return &#34;Joe&#34;
}

// Second implementation of the interface.
type Mike struct {}

func (_ *Mike) Name() string {
        return &#34;Mike&#34;
}

func main() {
        joe := &amp;Joe{}
        mike := &amp;Mike{}
        Greet(mike)
        Greet(joe)
}"><pre><span>// The interface.</span>
<span>type</span> <span>HasName</span> <span>interface</span> {
        <span>Name</span>() <span>string</span>
}

<span>// A generic function written against the interface.</span>
<span>func</span> <span>Greet</span>(<span>n</span> <span>HasName</span>) {
    <span>fmt</span>.<span>Printf</span>(<span>&#34;Hello %s!<span>\n</span>&#34;</span>, <span>n</span>.<span>Name</span>())
}

<span>// First implementation of the interface.</span>
<span>type</span> <span>Joe</span> <span>struct</span> {}

<span>func</span> (<span>_</span> <span>*</span><span>Joe</span>) <span>Name</span>() <span>string</span> {
        <span>return</span> <span>&#34;Joe&#34;</span>
}

<span>// Second implementation of the interface.</span>
<span>type</span> <span>Mike</span> <span>struct</span> {}

<span>func</span> (<span>_</span> <span>*</span><span>Mike</span>) <span>Name</span>() <span>string</span> {
        <span>return</span> <span>&#34;Mike&#34;</span>
}

<span>func</span> <span>main</span>() {
        <span>joe</span> <span>:=</span> <span>&amp;</span><span>Joe</span>{}
        <span>mike</span> <span>:=</span> <span>&amp;</span><span>Mike</span>{}
        <span>Greet</span>(<span>mike</span>)
        <span>Greet</span>(<span>joe</span>)
}</pre></div>
<p dir="auto">Running the above program will display:</p>

<p dir="auto">This hopefully illustrates how <code>Greet</code> is generic in, or parametrised by, the
interface <code>HasName</code>.</p>
<h3 dir="auto"><a id="user-content-generic-server-behaviour" aria-hidden="true" href="#generic-server-behaviour"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Generic server behaviour</h3>
<p dir="auto">Next lets have look at a more complicated example in Erlang taken from Joe&#39;s
thesis (p. 136). It&#39;s a key-value store where we can <code>store</code> a key value pair or
<code>lookup</code> the value of a key, the <code>handle_call</code> part is the most interesting:</p>
<div dir="auto" data-snippet-clipboard-copy-content="-module(kv).
-behaviour(gen_server).

-export([start/0, stop/0, lookup/1, store/2]).

-export([init/1, handle_call/3, handle_cast/2, terminate/2]).

start() -&gt;
  gen_server:start_link({local,kv},kv,arg1,[]).

stop() -&gt; gen_server:cast(kv, stop).

init(arg1) -&gt;
  io:format(&#34;Key-Value server starting~n&#34;),
  {ok, dict:new()}.

store(Key, Val) -&gt;
  gen_server:call(kv, {store, Key, Val}).

lookup(Key) -&gt; gen_server:call(kv, {lookup, Key}).

handle_call({store, Key, Val}, From, Dict) -&gt;
  Dict1 = dict:store(Key, Val, Dict),
  {reply, ack, Dict1};
handle_call({lookup, crash}, From, Dict) -&gt;
  1/0; %% &lt;- deliberate error :-)
handle_call({lookup, Key}, From, Dict) -&gt;
  {reply, dict:find(Key, Dict), Dict}.

handle_cast(stop, Dict) -&gt; {stop, normal, Dict}.

terminate(Reason, Dict) -&gt;
  io:format(&#34;K-V server terminating~n&#34;)."><pre>-<span>module</span>(<span>kv</span>).
-<span>behaviour</span>(<span>gen_server</span>).

-<span>export</span>([<span>start</span>/<span>0</span>, <span>stop</span>/<span>0</span>, <span>lookup</span>/<span>1</span>, <span>store</span>/<span>2</span>]).

-<span>export</span>([<span>init</span>/<span>1</span>, <span>handle_call</span>/<span>3</span>, <span>handle_cast</span>/<span>2</span>, <span>terminate</span>/<span>2</span>]).

<span>start</span>() <span>-&gt;</span>
  <span>gen_server</span>:<span>start_link</span>({<span>local</span>,<span>kv</span>},<span>kv</span>,<span>arg1</span>,[]).

<span>stop</span>() <span>-&gt;</span> <span>gen_server</span>:<span>cast</span>(<span>kv</span>, <span>stop</span>).

<span>init</span>(<span>arg1</span>) <span>-&gt;</span>
  <span>io</span>:<span>format</span>(<span><span>&#34;</span>Key-Value server starting<span>~n</span><span>&#34;</span></span>),
  {<span>ok</span>, <span>dict</span>:<span>new</span>()}.

<span>store</span>(<span>Key</span>, <span>Val</span>) <span>-&gt;</span>
  <span>gen_server</span>:<span>call</span>(<span>kv</span>, {<span>store</span>, <span>Key</span>, <span>Val</span>}).

<span>lookup</span>(<span>Key</span>) <span>-&gt;</span> <span>gen_server</span>:<span>call</span>(<span>kv</span>, {<span>lookup</span>, <span>Key</span>}).

<span>handle_call</span>({<span>store</span>, <span>Key</span>, <span>Val</span>}, <span>From</span>, <span>Dict</span>) <span>-&gt;</span>
  <span>Dict1</span> <span>=</span> <span>dict</span>:<span>store</span>(<span>Key</span>, <span>Val</span>, <span>Dict</span>),
  {<span>reply</span>, <span>ack</span>, <span>Dict1</span>};
<span>handle_call</span>({<span>lookup</span>, <span>crash</span>}, <span>From</span>, <span>Dict</span>) <span>-&gt;</span>
  <span>1</span><span>/</span><span>0</span>; <span><span>%</span>% &lt;- deliberate error :-)</span>
<span>handle_call</span>({<span>lookup</span>, <span>Key</span>}, <span>From</span>, <span>Dict</span>) <span>-&gt;</span>
  {<span>reply</span>, <span>dict</span>:<span>find</span>(<span>Key</span>, <span>Dict</span>), <span>Dict</span>}.

<span>handle_cast</span>(<span>stop</span>, <span>Dict</span>) <span>-&gt;</span> {<span>stop</span>, <span>normal</span>, <span>Dict</span>}.

<span>terminate</span>(<span>Reason</span>, <span>Dict</span>) <span>-&gt;</span>
  <span>io</span>:<span>format</span>(<span><span>&#34;</span>K-V server terminating<span>~n</span><span>&#34;</span></span>).</pre></div>
<p dir="auto">This is an implementation of the <code>gen_server</code> behaviour/interface. Notice how
<code>handle_call</code> updates the state (<code>Dict</code>) in case of a <code>store</code> and <code>lookup</code>s the
key in the state. Once <code>gen_server</code> is given this implementation it will provide
a server which can handle concurrent <code>store</code> and <code>lookup</code> requests, similarly to
how <code>Greet</code> provided the displaying functionality.</p>
<p dir="auto">At this point you might be thinking &#34;OK, so what? Lots of programming languages
have interfaces...&#34;. That&#39;s true, but notice how <code>handle_call</code> is completely
sequential, i.e. all concurrency is hidden away in the generic <code>gen_server</code>
component. &#34;Yeah, but that&#39;s just good engineering practice which can be done in
any language&#34; you say. That&#39;s true as well, but the thesis pushes this idea
quite far. It identifies six behaviours: <code>gen_server</code>, <code>gen_event</code>, <code>gen_fsm</code>,
<code>supervisor</code>, <code>application</code>, and <code>release</code> and then says these are enough to
build reliable distributed systems. As a case study Joe uses one of Ericsson&#39;s
telephone switches (p. 157):</p>
<blockquote>
<p dir="auto">When we look at the AXD301 project in chapter 8, we will see that there were
122 instances of gen_server, 36 instances of gen_event and 10 instances of
gen_fsm. There were 20 supervisors and 6 applications. All this is packaged
into one release.</p>
</blockquote>
<p dir="auto">Joe gives several arguments for why behaviour should be used (p. 157-158):</p>
<ol dir="auto">
<li>
<p dir="auto">The application programmer only has to provide the part of the code which
defines the <em>semantics</em> (or &#34;business logic&#34;) of their problem, while the
<em>infrastructure</em> code is provided automatically by the behaviour;</p>
</li>
<li>
<p dir="auto">The application programmer writes sequential code, all concurrency is hidden
away in the behaviour;</p>
</li>
<li>
<p dir="auto">Behaviours are written by experts, and based on years of experience and
represent &#34;best practices&#34;;</p>
</li>
<li>
<p dir="auto">Easier for new team members to get started: business logic is sequential,
similar structure that they might have seen before elsewhere;</p>
</li>
<li>
<p dir="auto">If whole systems are implemented reusing a small set of behaviours: as
behaviour implementations improve the whole systems will improve without
requiring any code changes;</p>
</li>
<li>
<p dir="auto">Sticking to only using behaviours enforces structure, which in turn makes
testing and formal verification much easier.</p>
</li>
</ol>
<p dir="auto">We&#39;ll come back to this last point about testing later.</p>
<h3 dir="auto"><a id="user-content-event-manager-behaviour" aria-hidden="true" href="#event-manager-behaviour"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Event manager behaviour</h3>
<p dir="auto">Lets come back to the behaviours we listed above first. We looked at
<code>gen_server</code>, but what are the others for? There&#39;s <code>gen_event</code> which is a
generic event manager, which lets you register event handlers that are then run
when the event manager gets messages associated with the handlers. Joe says this
is useful for, e.g., error logging and gives the following example of an simple
logger (p. 142):</p>
<div dir="auto" data-snippet-clipboard-copy-content="-module(simple_logger).
-behaviour(gen_event).

-export([start/0, stop/0, log/1, report/0]).

-export([init/1, terminate/2,
         handle_event/2, handle_call/2]).

-define(NAME, my_simple_event_logger).

start() -&gt;
  case gen_event:start_link({local, ?NAME}) of
    Ret = {ok, Pid} -&gt;
      gen_event:add_handler(?NAME,?MODULE,arg1),
      Ret;
  Other -&gt;
    Other
  end.

stop() -&gt; gen_event:stop(?NAME).

log(E) -&gt; gen_event:notify(?NAME, {log, E}).

report() -&gt;
  gen_event:call(?NAME, ?MODULE, report).

init(arg1) -&gt;
  io:format(&#34;Logger starting~n&#34;),
  {ok, []}.

handle_event({log, E}, S) -&gt; {ok, trim([E|S])}.

handle_call(report, S) -&gt; {ok, S, S}.

terminate(stop, _) -&gt; true.

trim([X1,X2,X3,X4,X5|_]) -&gt; [X1,X2,X3,X4,X5];
trim(L) -&gt; L."><pre>-<span>module</span>(<span>simple_logger</span>).
-<span>behaviour</span>(<span>gen_event</span>).

-<span>export</span>([<span>start</span>/<span>0</span>, <span>stop</span>/<span>0</span>, <span>log</span>/<span>1</span>, <span>report</span>/<span>0</span>]).

-<span>export</span>([<span>init</span>/<span>1</span>, <span>terminate</span>/<span>2</span>,
         <span>handle_event</span>/<span>2</span>, <span>handle_call</span>/<span>2</span>]).

-<span>define</span>(<span>NAME</span>, <span>my_simple_event_logger</span>).

<span>start</span>() <span>-&gt;</span>
  <span>case</span> <span>gen_event</span>:<span>start_link</span>({<span>local</span>, <span>?</span><span>NAME</span>}) <span>of</span>
    <span>Ret</span> <span>=</span> {<span>ok</span>, <span>Pid</span>} -&gt;
      <span>gen_event</span>:<span>add_handler</span>(<span>?</span><span>NAME</span>,<span>?</span><span>MODULE</span>,<span>arg1</span>),
      <span>Ret</span>;
  <span>Other</span> -&gt;
    <span>Other</span>
  <span>end</span>.

<span>stop</span>() <span>-&gt;</span> <span>gen_event</span>:<span>stop</span>(<span>?</span><span>NAME</span>).

<span>log</span>(<span>E</span>) <span>-&gt;</span> <span>gen_event</span>:<span>notify</span>(<span>?</span><span>NAME</span>, {<span>log</span>, <span>E</span>}).

<span>report</span>() <span>-&gt;</span>
  <span>gen_event</span>:<span>call</span>(<span>?</span><span>NAME</span>, <span>?</span><span>MODULE</span>, <span>report</span>).

<span>init</span>(<span>arg1</span>) <span>-&gt;</span>
  <span>io</span>:<span>format</span>(<span><span>&#34;</span>Logger starting<span>~n</span><span>&#34;</span></span>),
  {<span>ok</span>, []}.

<span>handle_event</span>({<span>log</span>, <span>E</span>}, <span>S</span>) <span>-&gt;</span> {<span>ok</span>, <span>trim</span>([<span>E</span>|<span>S</span>])}.

<span>handle_call</span>(<span>report</span>, <span>S</span>) <span>-&gt;</span> {<span>ok</span>, <span>S</span>, <span>S</span>}.

<span>terminate</span>(<span>stop</span>, <span>_</span>) <span>-&gt;</span> <span>true</span>.

<span>trim</span>([<span>X1</span>,<span>X2</span>,<span>X3</span>,<span>X4</span>,<span>X5</span>|<span>_</span>]) <span>-&gt;</span> [<span>X1</span>,<span>X2</span>,<span>X3</span>,<span>X4</span>,<span>X5</span>];
<span>trim</span>(<span>L</span>) <span>-&gt;</span> <span>L</span>.</pre></div>
<p dir="auto">The interesting part is <code>handle_event</code>, <code>trim</code> and <code>report</code>. Together they let
the user log, keep track and display the last five error messages.</p>
<h3 dir="auto"><a id="user-content-state-machine-behaviour" aria-hidden="true" href="#state-machine-behaviour"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>State machine behaviour</h3>
<p dir="auto">The <code>gen_fsm</code> behavior has been renamed to <code>gen_statem</code> (for state machine)
since thesis was written. It&#39;s very similar to <code>gen_server</code>, but more geared
towards implementing protocols, which often are specified as state machines. I
believe any <code>gen_server</code> can be implemented as a <code>gen_statem</code> and vice versa so
we won&#39;t go into the details of <code>gen_statem</code>.</p>
<h3 dir="auto"><a id="user-content-supervisor-behaviour" aria-hidden="true" href="#supervisor-behaviour"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Supervisor behaviour</h3>
<p dir="auto">The next interesting behavior is <code>supervisor</code>. Supervisors are processes which
sole job is to make sure that other processes are healthy and doing their job.
If a supervised process fails then the supervisor can restart it according
to some predefined strategy. Here&#39;s an example due to Joe (p. 148):</p>
<div dir="auto" data-snippet-clipboard-copy-content="-module(simple_sup).
-behaviour(supervisor).

-export([start/0, init/1]).

start() -&gt;
  supervisor:start_link({local, simple_supervisor},
  ?MODULE, nil).

init(_) -&gt;
  {ok,
  {{one_for_one, 5, 1000},
  [
   {packet,
     {packet_assembler, start, []},
     permanent, 500, worker, [packet_assembler]},
   {server,
     {kv, start, []},
     permanent, 500, worker, [kv]},
   {logger,
     {simple_logger, start, []},
     permanent, 500, worker, [simple_logger]}]}}."><pre>-<span>module</span>(<span>simple_sup</span>).
-<span>behaviour</span>(<span>supervisor</span>).

-<span>export</span>([<span>start</span>/<span>0</span>, <span>init</span>/<span>1</span>]).

<span>start</span>() <span>-&gt;</span>
  <span>supervisor</span>:<span>start_link</span>({<span>local</span>, <span>simple_supervisor</span>},
  <span>?</span><span>MODULE</span>, <span>nil</span>).

<span>init</span>(<span>_</span>) <span>-&gt;</span>
  {<span>ok</span>,
  {{<span>one_for_one</span>, <span>5</span>, <span>1000</span>},
  [
   {<span>packet</span>,
     {<span>packet_assembler</span>, <span>start</span>, []},
     <span>permanent</span>, <span>500</span>, <span>worker</span>, [<span>packet_assembler</span>]},
   {<span>server</span>,
     {<span>kv</span>, <span>start</span>, []},
     <span>permanent</span>, <span>500</span>, <span>worker</span>, [<span>kv</span>]},
   {<span>logger</span>,
     {<span>simple_logger</span>, <span>start</span>, []},
     <span>permanent</span>, <span>500</span>, <span>worker</span>, [<span>simple_logger</span>]}]}}.</pre></div>
<p dir="auto">The <code>{one_for_one, 5, 1000}</code> is the restart strategy. It says that if one of the
supervised processes (<code>packet_assembler</code>, <code>kv</code>, and <code>simple_logger</code>) fail then
only restart the failing process (<code>one_for_one</code>). If the supervisor needs to
restart more than <code>5</code> times in <code>1000</code> seconds then the supervisor itself should
fail.</p>
<p dir="auto">The <code>permanent, 500, worker</code> part means that this is a worker process which
should be permanently kept alive and its given 500 milliseconds to gracefully
stop what it&#39;s doing in case the supervisor wants to restart it.</p>
<p dir="auto">&#34;Why would the supervisor want to restart it if it&#39;s not dead already?&#34;, one
might wonder. Well, there are other restart strategies than <code>one_for_one</code>. For
example, <code>one_for_all</code> where if one process fails then the supervisor restarts
all of its children.</p>
<p dir="auto">If we also consider that supervisors can supervise supervisors, which are not
necessarily running on the same computer, then I hope that you get an idea of
powerful this behaviour can be. And, no, this isn&#39;t &#34;just Kubernetes&#34;, because
it&#39;s at the thread/lightweight process level rather than docker container level.</p>
<p dir="auto">The idea for supervisors and their restart strategies comes from the observation
that often a restart appears to fix the problem, as captured in the <em>Have You
Tried Turning It Off And On Again?</em> sketches from IT Crowd.</p>
<p dir="auto">Knowing that failing processes will get restarted coupled with Jim Gray&#39;s idea
of failing fast, that&#39;s either produce the output according to the specification
or signal failure and stop operating, leads to Joe&#39;s slogan: &#34;Let it crash!&#34; (p.
107). Another way to think of it is that a program should only express its
&#34;happy path&#34;, should anything go wrong on its happy way it should crash, rather
than trying to be clever about it and try to fix the problem (potentially making
it worse), and another program higher up the supervisor tree will handle it.</p>
<p dir="auto">Supervisors and the &#34;let it crash&#34; philosophy, appear to produce reliable
systems. Joe uses the Ericsson AXD301 telephone switch example again (p. 191):</p>
<blockquote>
<p dir="auto">Evidence for the long-term operational stability of the system had also not
been collected in any systematic way. For the Ericsson AXD301 the only
information on the long-term stability of the system came from a power-point
presentation showing some figures claiming that a major customer had run an 11
node system with a 99.9999999% reliability, though how these figure had been
obtained was not documented.</p>
</blockquote>
<p dir="auto">To put this in perspective, five nines (99.999%) reliability is considered good
(5.26 minutes of downtime per year). &#34;59% of Fortune 500 companies experience a
minimum of 1.6 hours of downtime per week&#34;, according to some
<a href="https://courseware.cutm.ac.in/wp-content/uploads/2020/06/Assessing-the-Financial-Impact-of-Downtime-UK.pdf" rel="nofollow">report</a>
from a biased company. Notice per <em>year</em> vs per <em>week</em>, but as we don&#39;t know how
either reliability numbers are obtained its probably safe to assume that the
truth is somewhere in the middle -- still a big difference, but not 31.56
milliseconds (nine nines) of downtime per year vs 1.6 hours of downtime per
week.</p>
<h3 dir="auto"><a id="user-content-application-and-release-behaviours" aria-hidden="true" href="#application-and-release-behaviours"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Application and release behaviours</h3>
<p dir="auto">I&#39;m not sure if <code>application</code> and <code>release</code> technically are behaviours, i.e.
interfaces. They are part of the same chapter as the other behaviours in the
thesis and they do provide a clear structure which is a trait of the other
behaviours though, so we&#39;ll include them in the discussion.</p>
<p dir="auto">So far we&#39;ve presented behaviours from the bottom up. We started with &#34;worker&#34;
behaviours <code>gen_server</code>, <code>gen_statem</code> and <code>gen_event</code> which together capture the
semantics of our problem. We then saw how we can define <code>supervisor</code> trees whose
children are other supervisor trees or workers, to deal with failures and
restarts.</p>
<p dir="auto">Next level up is an <code>application</code> which consists of a supervisor tree together
with everything else we need to deliver a particular application.</p>
<p dir="auto">A system can consist of several <code>application</code> and that&#39;s where the final
&#34;behaviour&#34; comes in. A <code>release</code> packages up one or more applications. They
also contain code to handle upgrades. If the upgrade fails, it must be able to
rollback to the previous stable state.</p>
<h2 dir="auto"><a id="user-content-how-behaviours-can-be-implemented" aria-hidden="true" href="#how-behaviours-can-be-implemented"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>How behaviours can be implemented</h2>
<p dir="auto">I hope that by now I&#39;m managed to convince you that it&#39;s not actually the
lightweight processes and message passing by themselves that make Erlang great
for building reliable systems.</p>
<p dir="auto">At best one might be able to claim that lightweight processes and supervisors
are the key mechanisms at play<sup><a href="#user-content-fn-2-36a93bf173b7880cb5fb71f8a9ffcae4" id="user-content-fnref-2-36a93bf173b7880cb5fb71f8a9ffcae4" data-footnote-ref="" aria-describedby="footnote-label">2</a></sup>, but I think it would be more honest to recognise
the structure that behaviours provide and how that ultimately leads to reliable
software.</p>
<p dir="auto">I&#39;ve not come across any other language, library, or framework which provides
such relatively simple building blocks that compose into big systems like the
AXD301 (&#34;over a million lines of Erlang code&#34;, p. 167).</p>
<p dir="auto">This begs the question: why aren&#39;t language and library designers stealing the
structure behind Erlang&#39;s behaviours, rather than copying the ideas of
lightweight processes and message passing?</p>
<p dir="auto">Let&#39;s take a step back. We said earlier that behaviours are interfaces and many
programming languages have interfaces. How would we go about starting to
implement behaviours in other languages?</p>
<p dir="auto">Lets start with <code>gen_server</code>. I like to think its interface signature as being:</p>
<div dir="auto" data-snippet-clipboard-copy-content="Input -&gt; State -&gt; (State, Output)"><pre><span>Input</span> <span>-&gt;</span> <span>State</span> <span>-&gt;</span> (<span>State</span>, <span>Output</span>)</pre></div>
<p dir="auto">That&#39;s it takes some input, its current state and produces a pair of the new
updated state and an output.</p>
<p dir="auto">How do we turn this sequential signature into something that can handle
concurrent requests? One way would be to fire up a HTTP server which transforms
requests into <code>Input</code>s and puts them on a queue, have an event loop which pops
inputs from the queue and feeds it to the sequential implementation, then
writing the output back to the client response. It wouldn&#39;t be difficult to
generalise this to be able to handle multiple <code>gen_server</code>s at the same time, by
giving each a name and let the request include the name in addition to the
input.</p>
<p dir="auto"><code>gen_event</code> could be implemented by allowing registration of callbacks to
certain types of event on the queue.</p>
<p dir="auto"><code>supervisor</code>s is more interesting, one simple way to think of it is: when we
feed the <code>gen_server</code> function the next input from the queue, we wrap that call
in an exception handler, and should it throw we notify its supervisor. It gets a
bit more complicated if the supervisor is not running on the same computer as
the <code>gen_server</code>.</p>
<p dir="auto">I haven&#39;t thought about <code>application</code> and <code>release</code>s much yet, but given that
configuration, deployment and upgrades are difficult problems they seem
important.</p>
<h2 dir="auto"><a id="user-content-correctness-of-behaviours" aria-hidden="true" href="#correctness-of-behaviours"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Correctness of behaviours</h2>
<p dir="auto">Writing a post solely about stealing from Erlang doesn&#39;t seem fair, even though
it&#39;s the right thing to do, so I&#39;d like to finish off with how we can build upon
the insights of Joe and the Erlang community.</p>
<p dir="auto">I&#39;ve been interesting in testing for a while now. Most recently I&#39;ve been
looking into <a href="https://github.com/stevana/property-based-testing-stateful-systems-tutorial">simulation
testing</a>
distributed systems à la
<a href="https://www.youtube.com/watch?v=4fFDFbi3toc" rel="nofollow">FoundationDB</a>.</p>
<p dir="auto">Simulation testing in a nutshell is running your system in a simulated world,
where the simulation has full control over which messages get sent when over the
network.</p>
<p dir="auto">FoundationDB built their own programming language, or dialect of C++ with
actors, in order do the simulation testing. Our team seemed to be able to get
quite far with merely using state machines of type:</p>
<div dir="auto" data-snippet-clipboard-copy-content="Input -&gt; State -&gt; (State, [Output])"><pre><span>Input</span> <span>-&gt;</span> <span>State</span> <span>-&gt;</span> (<span>State</span>, [<span>Output</span>])</pre></div>
<p dir="auto">where <code>[Output]</code> is a sequence of outputs.</p>
<p dir="auto">The idea being that the simulator keeps track of a priority queue of messages
sorted by their arrival time, it pops a message, advances the clock to the
arrival time of that message, feeds the message to the receiving state machine,
generates new arrival times for all output messages and puts them back into the
priority queue, rinse and repeat. As long as everything is deterministic and the
arrival times are generated using a seed we can explore many different
interleavings and get reproducible failures. It&#39;s also much faster than Jepsen,
because messaging is done in-memory and we advance the clock to the arrival
time, thereby triggering any timeouts without having to wait for them.</p>
<p dir="auto">We used to say that programs of this state machine type where written in
&#34;network normal form&#34;, and conjectured that every program which can receive and
send stuff over the network can be refactored into this shape<sup><a href="#user-content-fn-3-36a93bf173b7880cb5fb71f8a9ffcae4" id="user-content-fnref-3-36a93bf173b7880cb5fb71f8a9ffcae4" data-footnote-ref="" aria-describedby="footnote-label">3</a></sup>. Even if we
had a proof, &#34;network normal form&#34; always felt a bit arbitrary. But then I read
Joe&#39;s thesis and realised that <code>gen_server</code> and <code>gen_statem</code> basically have the
same type, so I stopped being concerned about it. As I think that if a structure
is found to be useful by different people, then it&#39;s usually a sign that it
isn&#39;t arbitrary.</p>
<p dir="auto">Anyway, in, at least, one of Joe&#39;s <a href="https://youtu.be/cNICGEwmXLU?t=1439" rel="nofollow">talks</a>
he mentions how difficult it&#39;s to correctly implement distributed leader
election.</p>
<p dir="auto">I believe this is a problem that would be greatly simplified by having access to
a simulator. A bit like I&#39;d imagine having access to a wind tunnel would make
building an airplane easier. Both lets you test your system under extreme
conditions, such as unreliable networking or power loss, before they happen in
&#34;production&#34;. Furthermore, this simulator can be generic in, or parametrised by,
behaviours. Which means that the developer gets it for free while the complexity
of the simulator is hidden away, just like the concurrent code of <code>gen_server</code>!</p>
<p dir="auto">FoundationDB is a good example of simulation testing working, as witnessed by
this <a href="https://twitter.com/aphyr/status/405017101804396546" rel="nofollow">tweet</a> where somebody
asked Kyle &#34;aphyr&#34; Kingsbury to Jepsen test FoundationDB:</p>
<blockquote>
<p dir="auto">“haven’t tested foundation[db] in part because their testing appears to be
waaaay more rigorous than mine.”</p>
</blockquote>
<p dir="auto">Formal verification is also made easier if the program is written a state
machine. Basically all of Lamport&#39;s model checking
<a href="https://www.microsoft.com/en-us/research/publication/computation-state-machines/" rel="nofollow">work</a>
with TLA+ assumes that the specification is a state machine. Also more recently
Kleppmann has
<a href="https://lawrencecpaulson.github.io/2022/10/12/verifying-distributed-systems-isabelle.html" rel="nofollow">shown</a>
how to exploit the state machine structure to do proof by (structural) induction
to solve the state explosion problem.</p>
<p dir="auto">So there you have it, we&#39;ve gone full circle. We started by taking inspiration
from Joe and Erlang&#39;s behaviours, and ended up using the structure of the
<code>gen_server</code> behaviour to make it easier to solve a problem that Joe used to
have.</p>
<h2 dir="auto"><a id="user-content-contributing" aria-hidden="true" href="#contributing"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Contributing</h2>
<p dir="auto">There are a bunch of related ideas that I have started working on:</p>
<ul dir="auto">
<li>Stealing ideas from Martin Thompson&#39;s work on the LMAX Disruptor and
<a href="https://github.com/real-logic/aeron">aeron</a> to make a fast event loop, on
top of which the behaviours run;</li>
<li>Enriching the state machine type with <a href="https://github.com/stevana/coroutine-state-machines">async
I/O</a>;</li>
<li>How to implement supervisors in more detail;</li>
<li>Hot code swapping of state machines.</li>
</ul>
<p dir="auto">I hope to write about these things separately at some later point.</p>
<p dir="auto">Meanwhile feel free to get in touch, if you find any of this interesting and
would like to get involved, or if you have have comments, suggestions or
questions.</p>
<h2 dir="auto"><a id="user-content-see-also" aria-hidden="true" href="#see-also"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>See also</h2>
<ul dir="auto">
<li>Chapter 6.1 on behaviours in Joe Armstrong&#39;s
<a href="http://kth.diva-portal.org/smash/record.jsf?pid=diva2%3A9492&amp;dswid=-1166" rel="nofollow">thesis</a>,
p. 129;</li>
<li><a href="https://www.erlang.org/doc/design_principles/des_princ.html" rel="nofollow">OTP design principles</a>;</li>
<li>The documentation for behaviours:
<ul dir="auto">
<li><a href="https://www.erlang.org/doc/man/gen_server.html" rel="nofollow"><code>gen_server</code></a>;</li>
<li><a href="https://www.erlang.org/doc/man/gen_event.html" rel="nofollow"><code>gen_event</code></a>;</li>
<li><a href="https://www.erlang.org/doc/man/gen_statem.html" rel="nofollow"><code>gen_statem</code></a>;</li>
<li><a href="https://www.erlang.org/doc/man/supervisor.html" rel="nofollow"><code>supervisor</code></a>;</li>
<li><a href="https://www.erlang.org/doc/man/application.html" rel="nofollow"><code>application</code></a>;</li>
<li><a href="https://www.erlang.org/doc/design_principles/release_structure.html" rel="nofollow">release</a>.</li>
</ul>
</li>
<li><a href="https://youtube.com/watch?v=7erJ1DV_Tlo" rel="nofollow">Hewitt, Meijer and Szyperski: The Actor Model (everything you wanted to know,
but were afraid to ask)</a> (2012);</li>
<li>Erlang the <a href="https://www.youtube.com/watch?v=xrIjfIjssLE" rel="nofollow">movie</a> (1990);</li>
<li><a href="https://www.youtube.com/watch?v=cNICGEwmXLU" rel="nofollow">Systems that run forever self-heal and
scale</a> by Joe Armstrong (Strange
Loop, 2013);</li>
<li><a href="https://www.youtube.com/watch?v=TTM_b7EJg5E" rel="nofollow">The Do&#39;s and Don&#39;ts of Error
Handling</a> by Joe Armstrong (GOTO,
2018);</li>
<li><a href="https://ferd.ca/the-zen-of-erlang.html" rel="nofollow">The Zen of Erlang</a> by Fred Hebert
(2016);</li>
<li><a href="https://ferd.ca/the-hitchhiker-s-guide-to-the-unexpected.html" rel="nofollow">The Hitchhiker&#39;s Guide to the
Unexpected</a> by
Fred Hebert (2018);</li>
<li><a href="https://www.hpl.hp.com/techreports/tandem/TR-85.7.pdf" rel="nofollow">Why Do Computers Stop and What Can Be Done About
It?</a> by Jim Gray
(1985);</li>
<li>The supervision trees chapter of <a href="https://adoptingerlang.org/docs/development/supervision_trees/" rel="nofollow"><em>Adopting
Erlang</em></a>
(2019);</li>
<li>&#34;If there&#39;s one thing I&#39;d say to the Erlang folks, it&#39;s you got the stuff
right from a high-level, but you need to invest in your messaging
infrastructure so it&#39;s super fast, super efficient and obeys all the right
properties to let this stuff work really well.&#34;
<a href="https://youtu.be/OqsAGFExFgQ?t=2532" rel="nofollow">quote</a> by Martin Thompson (Functional
Conf, 2017).</li>
</ul>

</article>
  </div>

    </div>

  </div></div>
  </body>
</html>
