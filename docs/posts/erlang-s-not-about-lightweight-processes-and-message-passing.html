<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://stevana.github.io/erlangs_not_about_lightweight_processes_and_message_passing.html">Original</a>
    <h1>Erlang&#39;s not about lightweight processes and message passing</h1>
    
    <div id="readability-page-1" class="page"><div>

<nav id="TOC" role="doc-toc">
<h2 id="toc-title">Table of contents</h2>
<ul>
<li><a href="#background" id="toc-background">Background</a></li>
<li><a href="#behaviours" id="toc-behaviours">Behaviours</a>
<ul>
<li><a href="#generic-server-behaviour" id="toc-generic-server-behaviour">Generic server behaviour</a></li>
<li><a href="#event-manager-behaviour" id="toc-event-manager-behaviour">Event manager behaviour</a></li>
<li><a href="#state-machine-behaviour" id="toc-state-machine-behaviour">State machine behaviour</a></li>
<li><a href="#supervisor-behaviour" id="toc-supervisor-behaviour">Supervisor behaviour</a></li>
<li><a href="#application-and-release-behaviours" id="toc-application-and-release-behaviours">Application and release
behaviours</a></li>
</ul></li>
<li><a href="#how-behaviours-can-be-implemented" id="toc-how-behaviours-can-be-implemented">How behaviours can be
implemented</a></li>
<li><a href="#correctness-of-behaviours" id="toc-correctness-of-behaviours">Correctness of behaviours</a></li>
<li><a href="#contributing" id="toc-contributing">Contributing</a></li>
<li><a href="#see-also" id="toc-see-also">See also</a></li>
<li><a href="#discussion" id="toc-discussion">Discussion</a></li>
</ul>
</nav>
<p>Posted on Jan 18, 2023</p>
<p>I used to think that the big idea of Erlang is its lightweight
processes and message passing. Over the last couple of years I’ve
realised that there’s a bigger insight to be had, and in this post I’d
like to share it with you.</p>
<section id="background">
<h2><a href="#background" title="Background">Background</a></h2>
<p>Erlang has an interesting history. If I understand things correctly,
it started off as a Prolog library for building reliable distributed
systems, morphed into a Prolog dialect, before finally becoming a
language in its own right.</p>
<p>The goal seemed to have always been to solve the problem of building
reliable distributed systems. It was developed at Ericsson and used to
program their telephone switches. This was sometime in the 80s and 90s,
before internet use become widespread. I suppose they were already
dealing with “internet scale” traffic, i.e. hundreds of millions of
users, with stricter SLAs than most internet services provide today. So
in a sense they were ahead of their time.</p>
<p>In 1998 Ericsson decided to ban all use of Erlang<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a>.
The people responsible for developing it argued that if they were going
to ban it, then they might as well open source it. Which Ericsson did
and shortly after most of the team that created Erlang quit and started
their own company.</p>
<p>One of these people was Joe Armstrong, which also was one of the main
people behind the design and implementation of Erlang. The company was
called Bluetail and they got bought up a couple of times but in the end
Joe got fired in 2002.</p>
<p>Shortly after, still in 2002, Joe starts writing his PhD thesis at
the Swedish Institute of Computer Science (SICS). Joe was born 1950, so
he was probably 52 years old at this point. The topic of the thesis is
<em>Making reliable distributed systems in the presence of software
errors</em> and it was finished the year after in 2003.</p>
<p>It’s quite an unusual thesis in many ways. For starters, most theses
are written by people in their twenties with zero experience of
practical applications. Whereas in Joe’s case he has been working
professionally on this topic since the 80s, i.e. about twenty years. The
thesis contains no math nor theory, it’s merely a presentation of the
ideas that underpin Erlang and how they used Erlang to achieve the
original goal of building reliable distributed systems.</p>
<p>I highly commend reading his <a href="http://kth.diva-portal.org/smash/record.jsf?pid=diva2%3A9492&amp;dswid=-1166">thesis</a>
and forming your own opinion, but to me it’s clear that the big idea
there isn’t lightweight processes<a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a> and message passing, but
rather the generic components which in Erlang are called
<em>behaviours</em>.</p>
</section>
<section id="behaviours">
<h2><a href="#behaviours" title="Behaviours">Behaviours</a></h2>
<p>I’ll first explain in more detail what behaviours are, and then I’ll
come back to the point that they are more important than the idea of
lightweight processes.</p>
<p>Erlang behaviours are like interfaces in, say, Java or Go. It’s a
collection of type signatures which can have multiple implementations,
and once the programmer provides such an implementation they get access
to functions written against that interface. To make it more concrete
here’s a contrived example in Go:</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span>// The interface.</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span>type</span> HasName <span>interface</span> <span>{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        Name<span>()</span> <span>string</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span>// A generic function written against the interface.</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span>func</span> Greet<span>(</span>n HasName<span>)</span> <span>{</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    fmt<span>.</span>Printf<span>(</span><span>&#34;Hello %s!</span><span>\n</span><span>&#34;</span><span>,</span> n<span>.</span>Name<span>())</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span>// First implementation of the interface.</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span>type</span> Joe <span>struct</span> <span>{}</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span>func</span> <span>(</span>_ <span>*</span>Joe<span>)</span> Name<span>()</span> <span>string</span> <span>{</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        <span>return</span> <span>&#34;Joe&#34;</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span>// Second implementation of the interface.</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span>type</span> Mike <span>struct</span> <span>{}</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span>func</span> <span>(</span>_ <span>*</span>Mike<span>)</span> Name<span>()</span> <span>string</span> <span>{</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>        <span>return</span> <span>&#34;Mike&#34;</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span>func</span> main<span>()</span> <span>{</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>        joe <span>:=</span> <span>&amp;</span>Joe<span>{}</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>        mike <span>:=</span> <span>&amp;</span>Mike<span>{}</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>        Greet<span>(</span>mike<span>)</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>        Greet<span>(</span>joe<span>)</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Running the above program will display:</p>
<pre><code>Hello Mike!
Hello Joe!</code></pre>
<p>This hopefully illustrates how <code>Greet</code> is generic in, or
parametrised by, the interface <code>HasName</code>.</p>
<section id="generic-server-behaviour">
<h3><a href="#generic-server-behaviour" title="Generic server behaviour">Generic server behaviour</a></h3>
<p>Next lets have a look at a more complicated example in Erlang taken
from Joe’s thesis (p. 136). It’s a key-value store where we can
<code>store</code> a key value pair or <code>lookup</code> the value of
a key, the <code>handle_call</code> part is the most interesting:</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span>-module</span><span>(</span><span>kv</span><span>).</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span>-</span><span>behaviour(</span><span>gen_server</span><span>).</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span>-export</span><span>([</span><span>start</span><span>/</span><span>0</span><span>,</span> <span>stop</span><span>/</span><span>0</span><span>,</span> <span>lookup</span><span>/</span><span>1</span><span>,</span> <span>store</span><span>/</span><span>2</span><span>]).</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span>-export</span><span>([</span><span>init</span><span>/</span><span>1</span><span>,</span> <span>handle_call</span><span>/</span><span>3</span><span>,</span> <span>handle_cast</span><span>/</span><span>2</span><span>,</span> <span>terminate</span><span>/</span><span>2</span><span>]).</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span>start()</span> <span>-&gt;</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>  <span>gen_server:start_link({</span><span>local</span><span>,</span><span>kv</span><span>},</span><span>kv</span><span>,</span><span>arg1</span><span>,[]).</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span>stop()</span> <span>-&gt;</span> <span>gen_server:cast(</span><span>kv</span><span>,</span> <span>stop</span><span>).</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span>init(</span><span>arg1</span><span>)</span> <span>-&gt;</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>  <span>io:format(</span><span>&#34;Key-Value server starting~n&#34;</span><span>),</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>  <span>{</span><span>ok</span><span>,</span> <span>dict:new()}.</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span>store(</span><span>Key</span><span>,</span> <span>Val</span><span>)</span> <span>-&gt;</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>  <span>gen_server:call(</span><span>kv</span><span>,</span> <span>{</span><span>store</span><span>,</span> <span>Key</span><span>,</span> <span>Val</span><span>}).</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span>lookup(</span><span>Key</span><span>)</span> <span>-&gt;</span> <span>gen_server:call(</span><span>kv</span><span>,</span> <span>{</span><span>lookup</span><span>,</span> <span>Key</span><span>}).</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a><span>handle_call({</span><span>store</span><span>,</span> <span>Key</span><span>,</span> <span>Val</span><span>},</span> <span>From</span><span>,</span> <span>Dict</span><span>)</span> <span>-&gt;</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>  <span>Dict1</span> <span>=</span> <span>dict:store(</span><span>Key</span><span>,</span> <span>Val</span><span>,</span> <span>Dict</span><span>),</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>  <span>{</span><span>reply</span><span>,</span> <span>ack</span><span>,</span> <span>Dict1</span><span>};</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a><span>handle_call({</span><span>lookup</span><span>,</span> <span>crash</span><span>},</span> <span>From</span><span>,</span> <span>Dict</span><span>)</span> <span>-&gt;</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>  <span>1</span><span>/</span><span>0</span><span>;</span> <span>%% &lt;- deliberate error :-)</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a><span>handle_call({</span><span>lookup</span><span>,</span> <span>Key</span><span>},</span> <span>From</span><span>,</span> <span>Dict</span><span>)</span> <span>-&gt;</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>  <span>{</span><span>reply</span><span>,</span> <span>dict:find(</span><span>Key</span><span>,</span> <span>Dict</span><span>),</span> <span>Dict</span><span>}.</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a><span>handle_cast(</span><span>stop</span><span>,</span> <span>Dict</span><span>)</span> <span>-&gt;</span> <span>{</span><span>stop</span><span>,</span> <span>normal</span><span>,</span> <span>Dict</span><span>}.</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a><span>terminate(</span><span>Reason</span><span>,</span> <span>Dict</span><span>)</span> <span>-&gt;</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>  <span>io:format(</span><span>&#34;K-V server terminating~n&#34;</span><span>).</span></span></code></pre></div>
<p>This is an implementation of the <code>gen_server</code>
behaviour/interface. Notice how <code>handle_call</code> updates the
state (<code>Dict</code>) in case of a <code>store</code> and
<code>lookup</code>s the key in the state. Once <code>gen_server</code>
is given this implementation it will provide a server which can handle
concurrent <code>store</code> and <code>lookup</code> requests,
similarly to how <code>Greet</code> provided the displaying
functionality.</p>
<p>At this point you might be thinking “OK, so what? Lots of programming
languages have interfaces…”. That’s true, but notice how
<code>handle_call</code> is completely sequential, i.e. all concurrency
is hidden away in the generic <code>gen_server</code> component. “Yeah,
but that’s just good engineering practice which can be done in any
language” you say. That’s true as well, but the thesis pushes this idea
quite far. It identifies six behaviours: <code>gen_server</code>,
<code>gen_event</code>, <code>gen_fsm</code>, <code>supervisor</code>,
<code>application</code>, and <code>release</code> and then says these
are enough to build reliable distributed systems. As a case study Joe
uses one of Ericsson’s telephone switches (p. 157):</p>
<blockquote>
<p>When we look at the AXD301 project in chapter 8, we will see that
there were 122 instances of gen_server, 36 instances of gen_event and 10
instances of gen_fsm. There were 20 supervisors and 6 applications. All
this is packaged into one release.</p>
</blockquote>
<p>Joe gives several arguments for why behaviour should be used
(pp. 157-158):</p>
<ol type="1">
<li><p>The application programmer only has to provide the part of the
code which defines the <em>semantics</em> (or “business logic”) of their
problem, while the <em>infrastructure</em> code is provided
automatically by the behaviour;</p></li>
<li><p>The application programmer writes sequential code, all
concurrency is hidden away in the behaviour;</p></li>
<li><p>Behaviours are written by experts, and based on years of
experience and represent “best practices”;</p></li>
<li><p>Easier for new team members to get started: business logic is
sequential, similar structure that they might have seen before
elsewhere;</p></li>
<li><p>If whole systems are implemented reusing a small set of
behaviours: as behaviour implementations improve the whole systems will
improve without requiring any code changes;</p></li>
<li><p>Sticking to only using behaviours enforces structure, which in
turn makes testing and formal verification much easier.</p></li>
</ol>
<p>We’ll come back to this last point about testing later.</p>
</section>
<section id="event-manager-behaviour">
<h3><a href="#event-manager-behaviour" title="Event manager behaviour">Event manager behaviour</a></h3>
<p>Lets come back to the behaviours we listed above first. We looked at
<code>gen_server</code>, but what are the others for? There’s
<code>gen_event</code> which is a generic event manager, which lets you
register event handlers that are then run when the event manager gets
messages associated with the handlers. Joe says this is useful for,
e.g., error logging and gives the following example of an simple logger
(p. 142):</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span>-module</span><span>(</span><span>simple_logger</span><span>).</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span>-</span><span>behaviour(</span><span>gen_event</span><span>).</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span>-export</span><span>([</span><span>start</span><span>/</span><span>0</span><span>,</span> <span>stop</span><span>/</span><span>0</span><span>,</span> <span>log</span><span>/</span><span>1</span><span>,</span> <span>report</span><span>/</span><span>0</span><span>]).</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span>-export</span><span>([</span><span>init</span><span>/</span><span>1</span><span>,</span> <span>terminate</span><span>/</span><span>2</span><span>,</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>         <span>handle_event</span><span>/</span><span>2</span><span>,</span> <span>handle_call</span><span>/</span><span>2</span><span>]).</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span>-define</span><span>(</span><span>NAME</span><span>,</span> <span>my_simple_event_logger</span><span>).</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span>start()</span> <span>-&gt;</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>  <span>case</span> <span>gen_event:start_link({</span><span>local</span><span>,</span> <span>?</span><span>NAME</span><span>})</span> <span>of</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span>Ret</span> <span>=</span> <span>{</span><span>ok</span><span>,</span> <span>Pid</span><span>}</span> <span>-&gt;</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>      <span>gen_event:add_handler(?</span><span>NAME</span><span>,?</span><span>MODULE</span><span>,</span><span>arg1</span><span>),</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>      <span>Ret</span><span>;</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>  <span>Other</span> <span>-&gt;</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    <span>Other</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>  <span>end</span><span>.</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a><span>stop()</span> <span>-&gt;</span> <span>gen_event:stop(?</span><span>NAME</span><span>).</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a><span>log(</span><span>E</span><span>)</span> <span>-&gt;</span> <span>gen_event:notify(?</span><span>NAME</span><span>,</span> <span>{</span><span>log</span><span>,</span> <span>E</span><span>}).</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a><span>report()</span> <span>-&gt;</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>  <span>gen_event:call(?</span><span>NAME</span><span>,</span> <span>?</span><span>MODULE</span><span>,</span> <span>report</span><span>).</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a><span>init(</span><span>arg1</span><span>)</span> <span>-&gt;</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>  <span>io:format(</span><span>&#34;Logger starting~n&#34;</span><span>),</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>  <span>{</span><span>ok</span><span>,</span> <span>[]}.</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a><span>handle_event({</span><span>log</span><span>,</span> <span>E</span><span>},</span> <span>S</span><span>)</span> <span>-&gt;</span> <span>{</span><span>ok</span><span>,</span> <span>trim([</span><span>E</span><span>|</span><span>S</span><span>])}.</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a><span>handle_call(</span><span>report</span><span>,</span> <span>S</span><span>)</span> <span>-&gt;</span> <span>{</span><span>ok</span><span>,</span> <span>S</span><span>,</span> <span>S</span><span>}.</span></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a><span>terminate(</span><span>stop</span><span>,</span> <span>_</span><span>)</span> <span>-&gt;</span> <span>true</span><span>.</span></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a><span>trim([</span><span>X1</span><span>,</span><span>X2</span><span>,</span><span>X3</span><span>,</span><span>X4</span><span>,</span><span>X5</span><span>|</span><span>_</span><span>])</span> <span>-&gt;</span> <span>[</span><span>X1</span><span>,</span><span>X2</span><span>,</span><span>X3</span><span>,</span><span>X4</span><span>,</span><span>X5</span><span>];</span></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a><span>trim(</span><span>L</span><span>)</span> <span>-&gt;</span> <span>L</span><span>.</span></span></code></pre></div>
<p>The interesting part is <code>handle_event</code>, <code>trim</code>
and <code>report</code>. Together they let the user log, keep track and
display the last five error messages.</p>
</section>
<section id="state-machine-behaviour">
<h3><a href="#state-machine-behaviour" title="State machine behaviour">State machine behaviour</a></h3>
<p>The <code>gen_fsm</code> behavior has been renamed to
<code>gen_statem</code> (for state machine) since thesis was written.
It’s very similar to <code>gen_server</code>, but more geared towards
implementing protocols, which often are specified as state machines. I
believe any <code>gen_server</code> can be implemented as a
<code>gen_statem</code> and vice versa so we won’t go into the details
of <code>gen_statem</code>.</p>
</section>
<section id="supervisor-behaviour">
<h3><a href="#supervisor-behaviour" title="Supervisor behaviour">Supervisor behaviour</a></h3>
<p>The next interesting behavior is <code>supervisor</code>. Supervisors
are processes which sole job is to make sure that other processes are
healthy and doing their job. If a supervised process fails then the
supervisor can restart it according to some predefined strategy. Here’s
an example due to Joe (p. 148):</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span>-module</span><span>(</span><span>simple_sup</span><span>).</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span>-</span><span>behaviour(</span><span>supervisor</span><span>).</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span>-export</span><span>([</span><span>start</span><span>/</span><span>0</span><span>,</span> <span>init</span><span>/</span><span>1</span><span>]).</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span>start()</span> <span>-&gt;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  <span>supervisor:start_link({</span><span>local</span><span>,</span> <span>simple_supervisor</span><span>},</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>  <span>?</span><span>MODULE</span><span>,</span> <span>nil</span><span>).</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span>init(</span><span>_</span><span>)</span> <span>-&gt;</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>  <span>{</span><span>ok</span><span>,</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>  <span>{{</span><span>one_for_one</span><span>,</span> <span>5</span><span>,</span> <span>1000</span><span>},</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>  <span>[</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>   <span>{</span><span>packet</span><span>,</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>     <span>{</span><span>packet_assembler</span><span>,</span> <span>start</span><span>,</span> <span>[]},</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>     <span>permanent</span><span>,</span> <span>500</span><span>,</span> <span>worker</span><span>,</span> <span>[</span><span>packet_assembler</span><span>]},</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>   <span>{</span><span>server</span><span>,</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>     <span>{</span><span>kv</span><span>,</span> <span>start</span><span>,</span> <span>[]},</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>     <span>permanent</span><span>,</span> <span>500</span><span>,</span> <span>worker</span><span>,</span> <span>[</span><span>kv</span><span>]},</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>   <span>{</span><span>logger</span><span>,</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>     <span>{</span><span>simple_logger</span><span>,</span> <span>start</span><span>,</span> <span>[]},</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>     <span>permanent</span><span>,</span> <span>500</span><span>,</span> <span>worker</span><span>,</span> <span>[</span><span>simple_logger</span><span>]}]}}.</span></span></code></pre></div>
<p>The <code>{one_for_one, 5, 1000}</code> is the restart strategy. It
says that if one of the supervised processes
(<code>packet_assembler</code>, <code>kv</code>, and
<code>simple_logger</code>) fail then only restart the failing process
(<code>one_for_one</code>). If the supervisor needs to restart more than
<code>5</code> times in <code>1000</code> seconds then the supervisor
itself should fail.</p>
<p>The <code>permanent, 500, worker</code> part means that this is a
worker process which should be permanently kept alive and its given 500
milliseconds to gracefully stop what it’s doing in case the supervisor
wants to restart it.</p>
<p>“Why would the supervisor want to restart it if it’s not dead
already?”, one might wonder. Well, there are other restart strategies
than <code>one_for_one</code>. For example, <code>one_for_all</code>
where if one process fails then the supervisor restarts all of its
children.</p>
<p>If we also consider that supervisors can supervise supervisors, which
are not necessarily running on the same computer, then I hope that you
get an idea of how powerful this behaviour can be. And, no, this isn’t
“just Kubernetes”, because it’s at the thread/lightweight process level
rather than docker container level.</p>
<p>The idea for supervisors and their restart strategies comes from the
observation that often a restart appears to fix the problem, as captured
in the <em>Have You Tried Turning It Off And On Again?</em> sketches
from IT Crowd.</p>
<p>Knowing that failing processes will get restarted coupled with Jim
Gray’s idea of failing fast, that’s either produce the output according
to the specification or signal failure and stop operating, leads to
Joe’s slogan: “Let it crash!” (p. 107). Another way to think of it is
that a program should only express its “happy path”, should anything go
wrong on its happy way it should crash, rather than trying to be clever
about it and try to fix the problem (potentially making it worse), and
another program higher up the supervisor tree will handle it.</p>
<p>Supervisors and the “let it crash” philosophy, appear to produce
reliable systems. Joe uses the Ericsson AXD301 telephone switch example
again (p. 191):</p>
<blockquote>
<p>Evidence for the long-term operational stability of the system had
also not been collected in any systematic way. For the Ericsson AXD301
the only information on the long-term stability of the system came from
a power-point presentation showing some figures claiming that a major
customer had run an 11 node system with a 99.9999999% reliability,
though how these figure had been obtained was not documented.</p>
</blockquote>
<p>To put this in perspective, five nines (99.999%) reliability is
considered good (5.26 minutes of downtime per year). “59% of Fortune 500
companies experience a minimum of 1.6 hours of downtime per week”,
according to some <a href="https://courseware.cutm.ac.in/wp-content/uploads/2020/06/Assessing-the-Financial-Impact-of-Downtime-UK.pdf">report</a>
from a biased company. Notice per <em>year</em> vs per <em>week</em>,
but as we don’t know how either reliability numbers are obtained its
probably safe to assume that the truth is somewhere in the middle –
still a big difference, but not 31.56 milliseconds (nine nines) of
downtime per year vs 1.6 hours of downtime per week.</p>
</section>
<section id="application-and-release-behaviours">
<h3><a href="#application-and-release-behaviours" title="Application and release behaviours">Application and release
behaviours</a></h3>
<p>I’m not sure if <code>application</code> and <code>release</code>
technically are behaviours, i.e. interfaces. They are part of the same
chapter as the other behaviours in the thesis and they do provide a
clear structure which is a trait of the other behaviours though, so
we’ll include them in the discussion.</p>
<p>So far we’ve presented behaviours from the bottom up. We started with
“worker” behaviours <code>gen_server</code>, <code>gen_statem</code> and
<code>gen_event</code> which together capture the semantics of our
problem. We then saw how we can define <code>supervisor</code> trees
whose children are other supervisor trees or workers, to deal with
failures and restarts.</p>
<p>Next level up is an <code>application</code> which consists of a
supervisor tree together with everything else we need to deliver a
particular application.</p>
<p>A system can consist of several <code>application</code> and that’s
where the final “behaviour” comes in. A <code>release</code> packages up
one or more applications. They also contain code to handle upgrades. If
the upgrade fails, it must be able to rollback to the previous stable
state.</p>
</section>
</section>
<section id="how-behaviours-can-be-implemented">
<h2><a href="#how-behaviours-can-be-implemented" title="How behaviours can be implemented">How behaviours can be
implemented</a></h2>
<p>I hope that by now I’m managed to convince you that it’s not actually
the lightweight processes and message passing by themselves that make
Erlang great for building reliable systems.</p>
<p>At best one might be able to claim that lightweight processes and
supervisors are the key mechanisms at play<a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a>,
but I think it would be more honest to recognise the structure that
behaviours provide and how that ultimately leads to reliable
software.</p>
<p>I’ve not come across any other language, library, or framework which
provides such relatively simple building blocks that compose into big
systems like the AXD301 (“over a million lines of Erlang code”,
p. 167).</p>
<p>This begs the question: why aren’t language and library designers
stealing the structure behind Erlang’s behaviours, rather than copying
the ideas of lightweight processes and message passing?</p>
<p>Let’s take a step back. We said earlier that behaviours are
interfaces and many programming languages have interfaces. How would we
go about starting to implement behaviours in other languages?</p>
<p>Lets start with <code>gen_server</code>. I like to think its
interface signature as being:</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span>Input</span> <span>-&gt;</span> <span>State</span> <span>-&gt;</span> (<span>State</span>, <span>Output</span>)</span></code></pre></div>
<p>That’s it takes some input, its current state and produces a pair of
the new updated state and an output.</p>
<p>How do we turn this sequential signature into something that can
handle concurrent requests? One way would be to fire up a HTTP server
which transforms requests into <code>Input</code>s and puts them on a
queue, have an event loop which pops inputs from the queue and feeds it
to the sequential implementation, then writing the output back to the
client response. It wouldn’t be difficult to generalise this to be able
to handle multiple <code>gen_server</code>s at the same time, by giving
each a name and let the request include the name in addition to the
input.</p>
<p><code>gen_event</code> could be implemented by allowing registration
of callbacks to certain types of event on the queue.</p>
<p><code>supervisor</code>s is more interesting, one simple way to think
of it is: when we feed the <code>gen_server</code> function the next
input from the queue, we wrap that call in an exception handler, and
should it throw we notify its supervisor. It gets a bit more complicated
if the supervisor is not running on the same computer as the
<code>gen_server</code>.</p>
<p>I haven’t thought about <code>application</code> and
<code>release</code>s much yet, but given that configuration, deployment
and upgrades are difficult problems they seem important.</p>
</section>
<section id="correctness-of-behaviours">
<h2><a href="#correctness-of-behaviours" title="Correctness of behaviours">Correctness of behaviours</a></h2>
<p>Writing a post solely about stealing from Erlang doesn’t seem fair,
even though it’s the right thing to do, so I’d like to finish off with
how we can build upon the insights of Joe and the Erlang community.</p>
<p>I’ve been interesting in testing for a while now. Most recently I’ve
been looking into <a href="https://github.com/stevana/property-based-testing-stateful-systems-tutorial">simulation
testing</a> distributed systems à la <a href="https://www.youtube.com/watch?v=4fFDFbi3toc">FoundationDB</a>.</p>
<p>Simulation testing in a nutshell is running your system in a
simulated world, where the simulation has full control over which
messages get sent when over the network.</p>
<p>FoundationDB built their own programming language, or dialect of C++
with actors, in order do the simulation testing. Our team seemed to be
able to get quite far with merely using state machines of type:</p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span>Input</span> <span>-&gt;</span> <span>State</span> <span>-&gt;</span> (<span>State</span>, [<span>Output</span>])</span></code></pre></div>
<p>where <code>[Output]</code> is a sequence of outputs.</p>
<p>The idea being that the simulator keeps track of a priority queue of
messages sorted by their arrival time, it pops a message, advances the
clock to the arrival time of that message, feeds the message to the
receiving state machine, generates new arrival times for all output
messages and puts them back into the priority queue, rinse and repeat.
As long as everything is deterministic and the arrival times are
generated using a seed we can explore many different interleavings and
get reproducible failures. It’s also much faster than Jepsen, because
messaging is done in-memory and we advance the clock to the arrival
time, thereby triggering any timeouts without having to wait for
them.</p>
<p>We used to say that programs of this state machine type where written
in “network normal form”, and conjectured that every program which can
receive and send stuff over the network can be refactored into this
shape<a href="#fn4" id="fnref4" role="doc-noteref"><sup>4</sup></a>. Even if we had a proof, “network
normal form” always felt a bit arbitrary. But then I read Joe’s thesis
and realised that <code>gen_server</code> and <code>gen_statem</code>
basically have the same type, so I stopped being concerned about it. As
I think that if a structure is found to be useful by different people,
then it’s usually a sign that it isn’t arbitrary.</p>
<p>Anyway, in, at least, one of Joe’s <a href="https://youtu.be/cNICGEwmXLU?t=1439">talks</a> he mentions how
difficult it’s to correctly implement distributed leader election.</p>
<p>I believe this is a problem that would be greatly simplified by
having access to a simulator. A bit like I’d imagine having access to a
wind tunnel would make building an airplane easier. Both lets you test
your system under extreme conditions, such as unreliable networking or
power loss, before they happen in “production”. Furthermore, this
simulator can be generic in, or parametrised by, behaviours. Which means
that the developer gets it for free while the complexity of the
simulator is hidden away, just like the concurrent code of
<code>gen_server</code>!</p>
<p>FoundationDB is a good example of simulation testing working, as
witnessed by this <a href="https://twitter.com/aphyr/status/405017101804396546">tweet</a>
where somebody asked Kyle “aphyr” Kingsbury to Jepsen test
FoundationDB:</p>
<blockquote>
<p>“haven’t tested foundation[db] in part because their testing appears
to be waaaay more rigorous than mine.”</p>
</blockquote>
<p>Formal verification is also made easier if the program is written a
state machine. Basically all of Lamport’s model checking <a href="https://www.microsoft.com/en-us/research/publication/computation-state-machines/">work</a>
with TLA+ assumes that the specification is a state machine. Also more
recently Kleppmann has <a href="https://lawrencecpaulson.github.io/2022/10/12/verifying-distributed-systems-isabelle.html">shown</a>
how to exploit the state machine structure to do proof by (structural)
induction to solve the state explosion problem.</p>
<p>So there you have it, we’ve gone full circle. We started by taking
inspiration from Joe and Erlang’s behaviours, and ended up using the
structure of the <code>gen_server</code> behaviour to make it easier to
solve a problem that Joe used to have.</p>
</section>
<section id="contributing">
<h2><a href="#contributing" title="Contributing">Contributing</a></h2>
<p>There are a bunch of related ideas that I have started working
on:</p>
<ul>
<li>Stealing ideas from Martin Thompson’s work on the LMAX Disruptor and
<a href="https://github.com/real-logic/aeron">aeron</a> to <a href="https://github.com/stevana/pipelined-state-machines">make</a> a
fast event loop, on top of which the behaviours run;</li>
<li>Enriching the state machine type with <a href="https://github.com/stevana/coroutine-state-machines">async
I/O</a>;</li>
<li>How to implement <a href="https://github.com/stevana/supervised-state-machines">supervisors</a>
in more detail;</li>
<li>Hot code <a href="https://github.com/stevana/hot-swapping-state-machines">swapping</a>
of state machines.</li>
</ul>
<p>Feel free to get in touch, if you find any of this interesting and
would like to get involved, or if you have have comments, suggestions or
questions.</p>
</section>
<section id="see-also">
<h2><a href="#see-also" title="See also">See also</a></h2>
<ul>
<li>Chapter 6.1 on behaviours in Joe Armstrong’s <a href="http://kth.diva-portal.org/smash/record.jsf?pid=diva2%3A9492&amp;dswid=-1166">thesis</a>,
p. 129;</li>
<li><a href="https://www.erlang.org/doc/design_principles/des_princ.html">OTP
design principles</a>;</li>
<li>The documentation for behaviours:
<ul>
<li><a href="https://www.erlang.org/doc/man/gen_server.html"><code>gen_server</code></a>;</li>
<li><a href="https://www.erlang.org/doc/man/gen_event.html"><code>gen_event</code></a>;</li>
<li><a href="https://www.erlang.org/doc/man/gen_statem.html"><code>gen_statem</code></a>;</li>
<li><a href="https://www.erlang.org/doc/man/supervisor.html"><code>supervisor</code></a>;</li>
<li><a href="https://www.erlang.org/doc/man/application.html"><code>application</code></a>;</li>
<li><a href="https://www.erlang.org/doc/design_principles/release_structure.html">release</a>.</li>
</ul></li>
<li><a href="https://youtube.com/watch?v=7erJ1DV_Tlo">Hewitt, Meijer and
Szyperski: The Actor Model (everything you wanted to know, but were
afraid to ask)</a> (2012);</li>
<li>Erlang the <a href="https://www.youtube.com/watch?v=xrIjfIjssLE">movie</a>
(1990);</li>
<li><a href="https://www.youtube.com/watch?v=cNICGEwmXLU">Systems that
run forever self-heal and scale</a> by Joe Armstrong (Strange Loop,
2013);</li>
<li><a href="https://www.youtube.com/watch?v=TTM_b7EJg5E">The Do’s and
Don’ts of Error Handling</a> by Joe Armstrong (GOTO, 2018);</li>
<li><a href="https://ferd.ca/the-zen-of-erlang.html">The Zen of
Erlang</a> by Fred Hebert (2016);</li>
<li><a href="https://ferd.ca/the-hitchhiker-s-guide-to-the-unexpected.html">The
Hitchhiker’s Guide to the Unexpected</a> by Fred Hebert (2018);</li>
<li><a href="https://www.hpl.hp.com/techreports/tandem/TR-85.7.pdf">Why
Do Computers Stop and What Can Be Done About It?</a> by Jim Gray
(1985);</li>
<li>The supervision trees chapter of <a href="https://adoptingerlang.org/docs/development/supervision_trees/"><em>Adopting
Erlang</em></a> (2019);</li>
<li>“If there’s one thing I’d say to the Erlang folks, it’s you got the
stuff right from a high-level, but you need to invest in your messaging
infrastructure so it’s super fast, super efficient and obeys all the
right properties to let this stuff work really well.” <a href="https://youtu.be/OqsAGFExFgQ?t=2532">quote</a> by Martin Thompson
(Functional Conf, 2017).</li>
</ul>
</section>
<section id="discussion">
<h2><a href="#discussion" title="Discussion">Discussion</a></h2>
<ul>
<li><a href="https://news.ycombinator.com/item?id=34545061">Hacker
News</a></li>
<li><a href="https://lobste.rs/s/7dguth/erlang_s_not_about_lightweight_processes">lobste.rs</a></li>
<li><a href="https://old.reddit.com/r/programming/comments/10mt6hz/erlangs_not_about_lightweight_processes_and/">r/programming</a></li>
<li><a href="https://old.reddit.com/r/haskell/comments/10mgd0a/erlangs_not_about_lightweight_processes_and/">r/haskell</a></li>
<li><a href="https://old.reddit.com/r/erlang/comments/10g0zbg/erlangs_not_about_lightweight_processes_and/">r/erlang</a></li>
<li><a href="https://elixirforum.com/t/erlangs-not-about-lightweight-processes-and-message-passing/53484/7">Elixir
Forum</a></li>
</ul>
</section>

</div></div>
  </body>
</html>
