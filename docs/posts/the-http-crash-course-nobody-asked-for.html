<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fasterthanli.me/articles/the-http-crash-course-nobody-asked-for">Original</a>
    <h1>The HTTP crash course nobody asked for</h1>
    
    <div id="readability-page-1" class="page"><div>
  

  
    
      
    
  

  <p>HTTP does a pretty good job staying out of everyone&#39;s way.</p>
<p>If you&#39;re reading this article, there&#39;s a solid chance it was delivered to you
over HTTP. Even if you&#39;re reading this from an RSS reader or something. And
you didn&#39;t even have to think about it!</p>
<p>&#34;Not having to think about it&#34; is certainly a measure of success for a given
technology. By contrast, <a href="https://twitter.com/fasterthanlime/status/1568236103966007296">I think about Bluetooth a
lot</a>. I wish I
didn&#39;t.</p>
<p>If my personal life is relatively devoid of thinking about HTTP, the same cannot
be said of my professional life, wherein I maintain an HTTP/S/2 proxy.</p>

                        <h2>
                            <a id="mise-en-bouche" href="#mise-en-bouche">
                                Mise en bouche
                            </a>
                        </h2>
                        
<p>Usually with HTTP, you control at least the client or the server. So you can
trust those to some extent. Or, should trust not suffice, you can always get in
there and add instrumentation until either you, or the problem, meets their
maker.</p>
<p>But when you write a proxy, you can trust <em>no one</em>.</p>
<p>Not even yourself.</p>
<p>Bug reports usually come in the form of &#34;So... stuff appears to be going wrong.
We&#39;re not sure why. We suspect the proxy.&#34;</p>
<p>And who wouldn&#39;t!</p>
<p>It&#39;s just <em>sitting there</em>, in the middle of everything, taunting you.</p>
<p>It&#39;s consuming CPU cycles for reasons that seem dubious at best – why is it
spending so much on syscalls? Does it <em>really</em> cost that much to do TLS? I
thought <a href="https://istlsfastyet.com/">TLS was fast now</a>.</p>
<p>So of course, when something is misbehaving, and you don&#39;t have client logs,
(because you almost never have client logging), and the server logs don&#39;t have
anything, because they hate you, yes, you personally, what else are you supposed
to blame?</p>
<p>As is often the case, this article is motivated by a particularly gnarly bug
I&#39;ve found at work - but it involves HTTP/2, and so, we must start at the
beginning.</p>

                        <h2>
                            <a id="let-s-start-with-http-1-1" href="#let-s-start-with-http-1-1">
                                Let&#39;s start with HTTP/1.1
                            </a>
                        </h2>
                        
<p>I briefly considered taking you on a tour of Ethernet and IP, but it turns out
<a href="https://fasterthanli.me/series/making-our-own-ping">I&#39;ve already done that</a>. So
let&#39;s skip over that part.</p>
<p>For our purposes, the internet really <em>is</em> <a href="https://en.wikipedia.org/wiki/Series_of_tubes">a series of
tubes</a>.</p>
<p>Every &#34;peer&#34; gets an IP address (no, we&#39;re not talking about NAT), and you can
establish an outbound TCP connections to another peer (which is what a client
usually does) or listen for and accept incoming TCP connections (which is what a
server usually does).</p>
<p>Once that&#39;s done, you get a bidirectional socket, from which you can read bytes
from and write bytes to. You get in-order, reliable delivery - by which I mean
there&#39;s checksums and retransmission involved.</p>
<p>Because there&#39;s a lot of peers and, thus, a lot of packets, there&#39;s mechanisms
to make sure someone doesn&#39;t ruin it for everyone: these include congestion
control (to protect the network) and flow control (to protect the server), and
they&#39;re both out of scope, but it&#39;s nice to know they&#39;ve thought about it.</p>
<p>HTTP/1.1 is a delightfully simple protocol, if you ignore most of it.</p>
<p>It merely involves opening a TCP connection to some server, and writing some
text to it - and then we get some text back!</p>
<p>Using <code>nc</code>, here <a href="https://askubuntu.com/a/426320">netcat-openbsd</a>, we can open a
TCP connection to <code>neverssl.com</code>, on port 80 (oh yeah, there&#39;s ports - 65536 of
them, a whole u16&#39;s worth), and just speak handwritten HTTP:</p>
<div><p>Shell session</p><pre data-lang="shell">$ printf &#39;HEAD / HTTP/1.1\r\nHost: neverssl.com\r\nConnection: close\r\n\r\n&#39; | nc neverssl.com 80
HTTP/1.1 200 OK
Date: Tue, 13 Sep 2022 19:10:46 GMT
Server: Apache/2.4.53 ()
Upgrade: h2,h2c
Connection: Upgrade, close
Last-Modified: Wed, 29 Jun 2022 00:23:33 GMT
ETag: &#34;f79-5e28b29d38e93&#34;
Accept-Ranges: bytes
Content-Length: 3961
Vary: Accept-Encoding
Content-Type: text/html; charset=UTF-8
</pre></div>
<p>Here&#39;s a more readable version of the payload we sent:</p>
<div><p>Shell session</p><pre data-lang="shell">HEAD / HTTP/1.1
Host: neverssl.com
Connection: close

</pre></div><div>

<p>Where every line ends with <code>\r\n</code>, also known as CRLF, for Carriage Return +
Line Feed, that&#39;s right, HTTP is based on
<a href="https://en.wikipedia.org/wiki/Teleprinter">teletypes</a>, which are just remote
<a href="https://www.youtube.com/watch?v=YE0U018Copw">typewriters</a></p>
</div>
<p><code>nc</code> did a DNS lookup as a favor, which means it turned <code>neverssl.com</code> into an
IP address, but we could&#39;ve just as well done it ourselves, using something like
<code>dig</code>:</p>
<div><p>Shell session</p><pre data-lang="shell">$ dig +short A neverssl.com
34.223.124.45
</pre></div>
<p>Or, for IPv6:</p>
<div><p>Shell session</p><pre data-lang="shell">$ dig +short AAAA neverssl.com
2600:1f13:37c:1400:ba21:7165:5fc7:736e
</pre></div>
<p>And we could&#39;ve used either of these in place of <code>neverssl.com</code> in our <code>nc</code>
invocation, and things would&#39;ve worked just as well. I&#39;m just not printing it
here in case the IP address does change later and everyone is confused because
the one-liner no longer works.</p>
<p>All of what we sent is called the &#34;HTTP header&#34;, which contains the request line:</p>

<p>...itself made up of the &#34;method&#34; (sometimes called &#34;verb&#34;), here <code>HEAD</code>, then
the path, here <code>/</code>, and the HTTP protocol version, which is a fixed string which
is always set to <code>HTTP/1.1</code> and nothing else.</p>

<p>IT&#39;S SET TO <code>HTTP/1.1</code> AND NOTHING ELSE.</p>

<p>The path determines the resource we want to operate on: if we specify a resource
that doesn&#39;t exist, we might get a response with a status of &#34;404&#34;, which means
&#34;not found&#34;, or &#34;does exist but if we returned a 403 you&#39;d know something of
that name exists and our customers might dislike that so all you get is a 404&#34;:</p>
<div><p>Shell session</p><pre data-lang="shell">$ printf &#39;HEAD /etc/passwd HTTP/1.1\r\nHost: neverssl.com\r\nConnection: close\r\n\r\n&#39; | nc neverssl.com 80
HTTP/1.1 404 Not Found
Date: Tue, 13 Sep 2022 20:15:42 GMT
Server: Apache/2.4.53 ()
Connection: close
Content-Type: text/html; charset=iso-8859-1
</pre></div>
<p>We&#39;re not done with our request payload yet! We sent:</p>

<p>This is actually <a href="https://www.rfc-editor.org/rfc/rfc7230.html#section-5.4">a requirement for
HTTP/1.1</a>, and was one
of its big selling points compared to, uh...</p>
<div>

<p>AhAH! Drew yourself into a corner didn&#39;t you.</p>
</div>
<p>...Gopher? <a href="https://github.com/gophernicus/gophernicus#virtual-hosting">I guess</a>?</p>
<p>Anyway this lets you host different websites at the same IP address, which is
fortunate because, in a world of proxies and CDNs and stuff, this is pretty much
the default scenario.</p>
<p>Of course, not all servers check it:</p>
<div><p>Shell session</p><pre data-lang="shell">$ printf &#39;HEAD / HTTP/1.1\r\nHost: fasterthanli.me\r\nConnection: close\r\n\r\n&#39; | nc neverssl.com 80 | head -1
HTTP/1.1 200 OK
</pre></div>
<p>But some do!</p>
<div><p>Shell session</p><pre data-lang="shell">$ printf &#39;HEAD / HTTP/1.1\r\nHost: fasterthanli.me\r\nConnection: close\r\n\r\n&#39; | nc example.org 80 | head -1 
HTTP/1.1 404 Not Found
</pre></div>
<p>If we wanted, we could send a body with our request: it&#39;s simply an arbitrary
payload made of.. bytes. We&#39;d put it <em>after</em> the empty line. After the
<code>\r\n\r\n</code>.</p>
<p>We just have to specify how long it is – at least, that&#39;s the simple way to do
it.</p>
<p>Something like that:</p>
<div><pre data-lang="">POST / HTTP/1.1
Host: example.org
Content-Length: 27

Take, eat; this is my body.
</pre></div>
<p>That allows the server to know the difference between &#34;a client sent the whole
request body then went away&#34; and &#34;a client yeeted its connection to us
mid-request body&#34;.</p>
<p><code>example.org</code>, one of the few domains I&#39;m allowed to use for illustrative
purposes, doesn&#39;t actually do anything interesting with our request body:</p>
<div><p>Shell session</p><pre data-lang="shell">$ printf &#39;POST / HTTP/1.1\r\nHost: example.org\r\nConnection: close\r\nContent-Length: 27\r\n\r\nTake, eat; this is my body.&#39; | nc example.org 80 | head -15
HTTP/1.1 200 OK
Accept-Ranges: bytes
Cache-Control: max-age=604800
Content-Type: text/html; charset=UTF-8
Date: Tue, 13 Sep 2022 20:28:11 GMT
Etag: &#34;3147526947&#34;
Expires: Tue, 20 Sep 2022 20:28:11 GMT
Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT
Server: EOS (vny/0452)
Content-Length: 1256
Connection: close

&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
</pre></div>
<p>..but it&#39;s nice to see a response from another HTTP server.</p>
<p>You can see that responses look fairly similar to requests: they have headers
too. Some let us know what&#39;s the encoding of the response body for example:</p>
<div><pre data-lang="">Content-Type: text/html; charset=UTF-8
</pre></div>
<p>This is a remnant from the before times, when not everything was UTF-8.</p>
<div>

<p>But Amos, even today, not everyth-</p>
</div>
<p>LALALA can&#39;t hear you. Anyway.</p>
<p>This server also lets us know what time it is, in case we&#39;re lost:</p>
<div><pre data-lang="">Date: Tue, 13 Sep 2022 20:28:11 GMT
</pre></div>
<p>There&#39;s a bunch of caching stuff too, but, to the relief of everyone, myself
included, we&#39;re not talking about caching today.</p>
<p>Just like request bodies, content bodies have a corresponding <code>content-length</code>
header, and the idea is exactly the same: you want to be sure you&#39;ve read the
whole thing by the time the server closes the connection on you.</p>
<p>Which, speaking of, the server only closes the connection because we asked it
to, with a <code>Connection: close</code> request header.</p>
<p>If we don&#39;t, it keeps the connection open, ready for another request:</p>
<div><pre data-lang="">$ printf &#39;HEAD / HTTP/1.1\r\nHost: example.org\r\n\r\nHEAD / HTTP/1.1\r\nHost: example.org\r\nConnection: close\r\n\r\n&#39; | nc example.org 80
HTTP/1.1 200 OK
Content-Encoding: gzip
Accept-Ranges: bytes
Age: 475287
Cache-Control: max-age=604800
Content-Type: text/html; charset=UTF-8
Date: Tue, 13 Sep 2022 20:33:50 GMT
Etag: &#34;3147526947+gzip&#34;
Expires: Tue, 20 Sep 2022 20:33:50 GMT
Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT
Server: ECS (dcb/7F39)
X-Cache: HIT
Content-Length: 648

HTTP/1.1 200 OK
Content-Encoding: gzip
Accept-Ranges: bytes
Age: 475287
Cache-Control: max-age=604800
Content-Type: text/html; charset=UTF-8
Date: Tue, 13 Sep 2022 20:33:50 GMT
Etag: &#34;3147526947+gzip&#34;
Expires: Tue, 20 Sep 2022 20:33:50 GMT
Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT
Server: ECS (dcb/7F39)
X-Cache: HIT
Content-Length: 648
Connection: close
</pre></div>
<p>Here&#39;s our request payload, for readability:</p>
<div><pre data-lang="">HEAD / HTTP/1.1
Host: neverssl.com

HEAD / HTTP/1.1
Host: neverssl.com
Connection: close

</pre></div>
<p>The most-used HTTP method is no doubt <code>GET</code>, which just means &#34;gimme that&#34;.
<code>HEAD</code> is just like <code>GET</code>, except you&#39;re telling the server <em>not</em> to send a
response body - you&#39;re only interested in the response headers.</p>
<p><code>POST</code> lets us submit forms, or upload stuff. <code>DELETE</code> lets us delete stuff.
<code>OPTIONS</code> is used for <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">Cross-Origin Resource
Sharing</a>.</p>
<p>There&#39;s other methods, which aren&#39;t as interesting, so let&#39;s not.</p>
<p>I wanted to talk about chunked transfer encoding, but it&#39;s a bit hard to give
you a one-liner that works, so instead you&#39;re gonna have to trust me: imagine
you&#39;re uploading a file <em>as it&#39;s being generated</em>.</p>
<p>You don&#39;t yet know how large it&#39;s going to be. So you can&#39;t send a
<code>Content-Length</code> header. What do?</p>
<p>You send chunks! Like so:</p>
<div><pre data-lang="">POST / HTTP/1.1
Host: example.org
Connection: close
Transfer-Encoding: chunked

4
Help
C
I am chunked
0


</pre></div>
<p>Every chunk is prefixed by <code>L\r\n</code>, where <code>L</code> is the length of the next chunk,
formatted as hexadecimal (&#34;I am chunked&#34; is 12 bytes long, hence, <code>0xC</code>).</p>
<p>To signal that you&#39;re done, you send a chunk of length 0. Here too, the server
can tell whether the client went away in the middle of sending the body, or
after it was done. Some clients don&#39;t stick around to find out how you felt
about their payload, you know how it is.</p>
<div>

<p>HTTP/1.1 is a text-based, human readable format. The request and response header
are separated by CRLF (<code>\r\n</code>), and contain various bits of metadata about a
request.</p>
<p>Requests are made over TCP connections. In HTTP/1.1, multiple requests can be
made over the same connection, one after the other. After the header, the body
begins (if there is one), and can either be written &#34;all at once&#34;, or in chunks,
prefixed with their hexadecimal length.</p>
</div>

                        <h2>
                            <a id="the-practicalities-of-proxying-http-1-1" href="#the-practicalities-of-proxying-http-1-1">
                                The practicalities of proxying HTTP/1.1
                            </a>
                        </h2>
                        
<p>We&#39;re far from done, but let&#39;s take a moment to consider how we would go about
proxying HTTP/1.1.</p>
<p>Let&#39;s assume we&#39;re a CDN (Content Delivery Network) or an ADN (Application
Delivery Network): we operate &#34;edge nodes&#34; at various locations around the world
and proxy the requests back to some &#34;worker nodes&#34;.</p>
<p>First, we need to accept TCP connections. As the first line of defense against
attacks, this already raises questions: do we rate-limit? If so, how? Limiting
the overall number of connections we&#39;re willing to service concurrently is
fairly easy, but it gets harder if you want to limit &#34;per IP address&#34; or &#34;per
AS&#34;.</p>
<p>Not impossible, just
<a href="https://making.pusher.com/per-ip-rate-limiting-with-iptables/">harder</a>.</p>
<p>But let&#39;s ignore that part - for each connection we accept on port 80, we must
be ready to speak HTTP/1.1. That means reading the HTTP request header (that
contains both the &#34;request line&#34; and &#34;request headers&#34;).</p>
<p>And then, we have to make our first choice. Let&#39;s say we receive this:</p>
<div><pre data-lang="">GET / HTTP/1.1
Host: fantastic-app.example.org
</pre></div>
<p>We already know which &#34;app&#34; this request is meant for – we could start
establishing a connection to the app right now, and start writing a similar
request header to it!</p>
<p>But the internet is a cold and scary place. As far as network protocols are
concerned, anyway.</p>
<p>A well-behaved, innocent client would send a few more headers and then an empty
line, indicating the end of the HTTP header.</p>
<p>But a malicious client could do a number of things!</p>
<p>It could, for example, send a header of infinite length:</p>
<div><pre data-lang="">GET / HTTP/1.1
Host: fantastic-app.example.org
Mwahahah: You will never stop parsing this header because I am never going to stop sending it. Your buffer will grow and grow, until your HTTP server consumes all available resources and dies in the fiery flames of an OOM. Unless you&#39;re specifically looking out for that, of course. Point is, this header will never end. In a real-life attack, this header would probably be generated, but in this case, it&#39;s hand-written. Because isn&#39;t it much more fun that way? Anyway I&#39;ll continue until I get a TCP connection reset, indicating your server&#39;s untimely death - until it restarts, and I do the same. We are not so different, you and I. Both shovelling bytes, day in, day out. What does it matter what our purpose is, as long as we can send and receive bytes? After all, isn&#39;t it what life is _truly_ about? Who can tell. Have you crashed yet? No. Very well, let&#39;s read from Webster&#39;s dictionary: aba, abacate, abacisci, aback, abactinal, abaculi, abacus (haha, classic), abaft, abaiss.. ooh, almost sent a non-ASCII character there, can&#39;t have that in a header value. Abalone, abandon, abandoner, abarthroses, abase... you&#39;re still here? Damn, this is more work than I thought. Fine. I give up. You stay online. You stay online and you be the bravest little server you can. Don&#39;t let others tell you what you can and can&#39;t do, you hear? You&#39;re going to be just fine, little server. Just fine. Me? Don&#39;t worry about me. Where I&#39;m going, we don&#39;t need servers.
</pre></div>
<p>Which is why most servers protect against that - they&#39;ll just send back an HTTP
431 or something. 414 if it&#39;s the URI that&#39;s too long. Or just a generic 400 if
they don&#39;t feel like being specific.</p>
<p>That&#39;s just one thing attackers can do!</p>
<p>They can also send reasonably-sized headers, but lots and lots and lots and lots
and lots of them.</p>
<p>Actually, why complicate things? They could simply open a TCP connection and
just... sit there. Doing nothing. And if they open lots and lots and lots of
connections, you&#39;ll run into some arbitrary limit, maybe it&#39;s the maximum number
of open file descriptors, maybe it&#39;s the amount of memory you have.</p>
<p>But maybe you set a timeout on how long you&#39;re willing to sit there with the
connection all idle: after all, if someone&#39;s connecting, it must already know
what it want, correct?</p>
<p>In which case the attacker can fall back to sending a reasonable amount of HTTP
request headers, of reasonable size, but it sends them one... byte... at...
a... time... slowly....... very slowly.</p>
<p>And that&#39;s a <a href="https://en.wikipedia.org/wiki/Slowloris_(computer_security)">Slowloris
attack</a>.  They can
also do that with the request body to great effect! (If they can find an
endpoint that accepts POST requests, for example).</p>
<p>So, for all these reasons and more, we probably want to wait until we&#39;ve
received the <em>full</em> HTTP request header before establishing a connection to the
&#34;backend&#34; or &#34;app&#34; or &#34;upstream&#34; or whatever you want to call it.</p>
<p>But then, more decisions await.</p>
<p>What balance do you want to strike between &#34;fidelity&#34; (how accurately you
reproduce the client&#39;s request) and &#34;safety&#34; (enforcing rules)?</p>
<p>For example, <a href="https://httpwg.org/specs/rfc9110.html#fields.values">RFC 9110</a>
doesn&#39;t allow the use of NUL characters in header values. But legacy
applications might rely on that! They might treat header values as an opaque
byte string, using the full 0-255 range.</p>
<p>What should your proxy do? Return HTTP 400 on ASCII values &gt; 127, or pass them
through as-is?</p>
<p>What if the client sends a <code>Content-Length: 0</code> header, or no <code>Content-Length</code>
header at all, but then follows up with a request body? Do you send it to the
backend? Ignore it? Reject the request altogether?</p>
<p>What if the backend returns an <code>HTTP 204</code> status, which means &#34;no content&#34;, but
it also sends a <code>Content-Length</code> header with a body. Do you strip the response
body when replying to the client, or do you proxy it as-is?</p>
<p>Speaking of bodies – what kind of buffering do you do? Do you wait until you&#39;ve
received the whole request body to relay it to the server? What if it&#39;s really
large? That might not make sense.</p>
<p>What about the response body though? Especially if you&#39;re intent on caching it?</p>
<p>What about transfer encoding? If the backend answers in chunked transfer
encoding, do you always reply to the client in kind? Is it okay to turn a
non-chunked body into a chunked one? What if the client has specific
requirements?</p>
<p>What about content encoding? Bodies can be compressed with gzip or brotli, for
example. Do you decompress request bodies? Do you pass them as-is? What about
response bodies? What <code>accept-encoding</code> do <em>you</em> send to the backend? Do you
want <em>them</em> to try and compress the response body, or is that your job, as a
CDN/ADN/edge?</p>
<p>If you&#39;re caching, do you cache bodies uncompressed? Compressed? With which
algorithm? Is it a good idea to decompress from brotli on-the-fly for clients
that don&#39;t support its encoding? Is is better to recompress to gzip on-the-fly
or pay the cost of storing another copy as gzip?</p>
<p>Getting someone to write an HTTP proxy is not covered by the Geneva convention,
but, as you can see, maybe it should be.</p>
<div>

<p>HTTP/1.1 proxies need to be opinionated, because there is a LOT of ways in which
the specifications (plural) can be interpreted. A variety of attacks can be
performed against HTTP endpoints.</p>
<p>We haven&#39;t touched on the security implications, mostly on resource exhaustion,
but as with any protocol, user input cannot be trusted, and we must validate
everything, set timeouts, and enforce limits aggressively.</p>
</div>

                        <h2>
                            <a id="also-tls" href="#also-tls">
                                Also, TLS
                            </a>
                        </h2>
                        
<p>But, we suffer HTTP for good reason: it&#39;s ubiquitous.</p>
<p>Let&#39;s get meta! I said you&#39;re probably reading this article over HTTP, and so we
can read that article from the command line, just as we did before with
<code>neverssl.com</code> and <code>example.org</code>:</p>
<div><p>Shell session</p><pre data-lang="shell">$ printf &#39;GET /articles/the-http-crash-course-nobody-asked-for HTTP/1.1\r\nHost: fasterthanli.me\r\nConnection: close\r\n\r\n&#39; | nc fasterthanli.me 80
HTTP/1.1 301 Moved Permanently
location: https://fasterthanli.me/articles/the-http-crash-course-nobody-asked-for
server: Fly/54d1d920f (2022-09-30)
via: 1.1 fly.io
fly-request-id: 01GES4PVF73NH3QDMM6HHHQBTJ-cdg
content-length: 0
date: Fri, 07 Oct 2022 11:53:50 GMT

</pre></div><div>

<p>That&#39;s... that&#39;s not the article.</p>
</div>
<p>Ah right, it redirects to the HTTPS version. Well that&#39;s a bummer. I mean, no!
It&#39;s good! Pretty much any exchange over the internet should be secured in some
way, and TLS (<a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">Transport Layer
Security</a>, not
<a href="https://hdoro.dev/series/making-our-own-executable-packer/part-13">thread-local storage</a>) is a decent
way to do that.</p>
<div>

<p>Wait, why do we want to secure this particular exchange? Does reading this
article put someone at legal risk somehow? Should they be worried?</p>
</div>
<p>Oh, no no. Cryptography <a href="https://en.wikipedia.org/wiki/Export_of_cryptography_from_the_United_States">isn&#39;t illegal
anymore</a>.
Well, <a href="https://en.wikipedia.org/wiki/Encryption_ban_proposal_in_the_United_Kingdom">for now</a>.</p>
<p><em>At the time of this writing</em> it&#39;s fine to read this article. Check with your
local legislator. It&#39;s easier to see the point of encryption if you think about
accessing your bank&#39;s online interface to, uhh pay your bills, or count your
money Scrooge McDuck style.</p>
<p>But if you care about privacy at all (and you should), encryption should be the
default. If all you use <a href="https://signal.org/">Signal</a> for is &#34;sensitive
communications&#34;, and everything else is plaintext, that&#39;s pretty much a big
HEY HERE&#39;S WHAT I HAVE TO HIDE sign to any potential attacker.</p>
<p>Also, cryptography isn&#39;t foolproof, and there&#39;s always the <a href="https://en.wikipedia.org/wiki/Dual_EC_DRBG">occasional
backdoor</a> introduced on purpose
because some intelligence agency thought nobody should be able to snoop but
them! And then said backdoors end up being used by other actors who aren&#39;t &#34;the
good guys&#34;, and also it turns the good guys maybe weren&#39;t good in the first place
and...</p>
<div>

<p>Alright, okay, point taken, so — do we write a TLS implementation now or...?</p>
</div>
<p>Oh no, absolutely not. Normally I&#39;d use <a href="https://lib.rs/crates/rustls">rustls</a>
but here in the command line I&#39;ll just take what we probably already have
installed, which is <a href="https://www.openssl.org/">OpenSSL</a>, which, you can tell
is old because it still has &#34;SSL&#34; in the name.</p>
<div>

<p>SSL 2.0 was deprecated in 2011, and SSL 3.0 in 2015 because,
<a href="https://en.wikipedia.org/wiki/POODLE">woof</a> — for those keeping score.</p>
</div>
<p>The <code>openssl</code> command-line utility comes with an <code>s_client</code> subcommand (see <a href="https://www.openssl.org/docs/manmaster/man1/openssl-s_client.html">its
manpage</a> for
more info) that lets us establish a TLS connection with a server, and encrypts
from stdin / decrypts to stdout transparently.</p>
<p>So we can just swap <code>nc</code> (which does raw TCP) with <code>openssl s_client</code> and <em>now</em>
we can read this article from the command line:</p>
<div><p>Shell session</p><pre data-lang="shell">$ printf &#39;GET /articles/the-http-crash-course-nobody-asked-for HTTP/1.1\r\nHost: fasterthanli.me\r\nConnection: close\r\n\r\n&#39; | openssl s_client -verify_quiet -quiet -connect fasterthanli.me:443 | grep Bluetooth -A 2 -B 2
you didn&#39;t even have to think about it!&lt;/p&gt;
&lt;p&gt;&amp;quot;Not having to think about it&amp;quot; is certainly a measure of success for a given
technology. By contrast, &lt;a href=&#34;https://twitter.com/fasterthanlime/status/1568236103966007296&#34;&gt;I think about Bluetooth a
lot&lt;/a&gt;. I wish I
didn&#39;t.&lt;/p&gt;
</pre></div>
<p>This right here is HTML, a markup language that briefly cosplayed as XML but
is now <a href="https://html.spec.whatwg.org/">its own thing again</a>, that you should definitely
<a href="https://stackoverflow.com/a/1732454">not parse with regular expressions</a>.</p>
<p>Luckily, this is out of scope for this article.</p>
<p>You know what isn&#39;t, though? <a href="https://www.rust-lang.org/">Rust</a>. Because if we
want to go past HTTP/1.1, we&#39;re going to need more than just the command line.</p>
<div>

<p>Wait, doesn&#39;t curl have an <code>--http2</code> option?</p>
</div>
<p>curl? What&#39;s a curl? Can you eat it? Do you wear it as a hat? Does it run on my
smart watch?</p>
<div>

<p>Actually chances are, it d-</p>
</div>

                        <h2>
                            <a id="making-http-1-1-requests-with-reqwest" href="#making-http-1-1-requests-with-reqwest">
                                Making HTTP/1.1 requests with <code>reqwest</code>
                            </a>
                        </h2>
                        
<p>Let&#39;s start the easy way! The <a href="https://lib.rs/crates/reqwest">reqwest</a> crate lets us
do that at a relatively high level, so, let&#39;s.</p>
<div><p>Shell session</p><pre data-lang="shell">$ cargo new --bin crash
     Created binary (application) `crash` package
</pre></div>
<p>We&#39;ll want an async runtime:</p>
<div><p>Shell session</p><pre data-lang="shell">$ cargo add tokio -F full
    Updating crates.io index
      Adding tokio v1.21.2 to dependencies.
             Features:
(cut)
</pre></div>
<p>And of course, <code>reqwest</code>:</p>
<div><p>Shell session</p><pre data-lang="shell">$ cargo add reqwest
(cut)
</pre></div>
<p>And then, this code:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>// in `src/main.rs`</i>

<i>#<i>[</i>tokio<i>::</i>main<i>]</i></i>
async <i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> response = reqwest<i>::</i><i>get</i><i>(</i><i>&#34;http://example.org&#34;</i><i>)</i><i>.</i>await<i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
    <i>println</i><i>!</i><i>(</i>
        <i>&#34;Got HTTP {}, with headers: {:#?}&#34;</i>,
        response.status<i>(</i><i>)</i>,
        response.headers<i>(</i><i>)</i>
    <i>)</i><i>;</i>

    <i>let</i> body = response<i>.</i><i>text</i><i>(</i><i>)</i><i>.</i>await<i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>

    <i>let</i> num_lines = <i>10</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;First {num_lines} lines of body:&#34;</i><i>)</i><i>;</i>
    <i>for</i> line <i>in</i> body<i>.</i><i>lines</i><i>(</i><i>)</i><i>.</i><i>take</i><i>(</i>num_lines<i>)</i> {
        <i>println</i><i>!</i><i>(</i><i>&#34;{line}&#34;</i><i>)</i><i>;</i>
    }
}
</pre></div><div><p>Shell session</p><pre data-lang="shell">$ cargo run
(cut)
     Running `target/debug/crash`
Got HTTP 200 OK, with headers: {
    &#34;age&#34;: &#34;471421&#34;,
    &#34;cache-control&#34;: &#34;max-age=604800&#34;,
    &#34;content-type&#34;: &#34;text/html; charset=UTF-8&#34;,
    &#34;date&#34;: &#34;Fri, 07 Oct 2022 13:50:20 GMT&#34;,
    &#34;etag&#34;: &#34;\&#34;3147526947+ident\&#34;&#34;,
    &#34;expires&#34;: &#34;Fri, 14 Oct 2022 13:50:20 GMT&#34;,
    &#34;last-modified&#34;: &#34;Thu, 17 Oct 2019 07:18:26 GMT&#34;,
    &#34;server&#34;: &#34;ECS (dcb/7F39)&#34;,
    &#34;vary&#34;: &#34;Accept-Encoding&#34;,
    &#34;x-cache&#34;: &#34;HIT&#34;,
    &#34;content-length&#34;: &#34;1256&#34;,
}
First 10 lines of body:
&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Example Domain&lt;/title&gt;

    &lt;meta charset=&#34;utf-8&#34; /&gt;
    &lt;meta http-equiv=&#34;Content-type&#34; content=&#34;text/html; charset=utf-8&#34; /&gt;
    &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1&#34; /&gt;
    &lt;style type=&#34;text/css&#34;&gt;
    body {
</pre></div>
<p>Not much to say here! We did a plaintext HTTP/1.1 request, and we got a
UTF-8-encoded HTML response. So far so good.</p>
<p>Now let&#39;s do the same, but with HTTPS (which, right now, is just HTTP/1.1 over
TLS). All we have to do is change our URL to start with <code>https://</code>:</p>
<div><p>Rust code</p><pre data-lang="rust">    <i>let</i> response = reqwest<i>::</i><i>get</i><i>(</i><i>&#34;https://example.org&#34;</i><i>)</i><i>.</i>await<i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
</pre></div>
<p>The output is exactly the same: we might hit a different server, the date would
be different, but the payload is the exact same, and looking at request headers,
there&#39;s really no way to tell we even used HTTPS.</p>
<p>How is <code>reqwest</code> able to speak TLS? Let&#39;s find out:</p>
<div><p>Shell session</p><pre data-lang="shell">$ cargo tree -i openssl
openssl v0.10.42
└── native-tls v0.2.10
    ├── hyper-tls v0.5.0
    │   └── reqwest v0.11.12
    │       └── crash v0.1.0 (/home/amos/bearcove/crash)
    ├── reqwest v0.11.12 (*)
    └── tokio-native-tls v0.3.0
        ├── hyper-tls v0.5.0 (*)
        └── reqwest v0.11.12 (*)
</pre></div>
<p>Oh! It just uses openssl (by default).</p>
<p>It feels weird that it just.. worked. Just like that. I don&#39;t trust it.</p>
<p>Let&#39;s do a little packet capture with tcpdump so we can see what&#39;s going down in
Wireshark. The network interface I use for the internet on this VM is called
<code>enp0s3</code>, so, in one terminal:</p>
<div><p>Shell session</p><pre data-lang="shell">$ sudo tcpdump -i enp0s3 -s 65536 -w /shared/crash.cap
tcpdump: listening on enp0s3, link-type EN10MB (Ethernet), snapshot length 65536 bytes
(at this point it just waits)
</pre></div>
<p>And in another:</p>
<div><p>Shell session</p><pre data-lang="shell">$ cd crash/
$ cargo run --quiet
(cut)
</pre></div>
<p>Then, <code>Ctrl-C</code> in the tcpdump terminal:</p>
<div><p>Shell session</p><pre data-lang="shell">^C215 packets captured
229 packets received by filter
0 packets dropped by kernel
</pre></div>
<p>And then we can open it in Wireshark! It was a bit noisy so I had to find the
right TCP stream (and filter with right click -&gt; &#34;Follow&#34; -&gt; &#34;TCP Stream&#34;), and
then we get this:</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/the-http-crash-course-nobody-asked-for/assets/wireshark-reqwest-tls.4c6435affb314cfc.avif"/>
                <source type="image/webp" srcset="/content/articles/the-http-crash-course-nobody-asked-for/assets/wireshark-reqwest-tls.16c6a010ea03d4a7.webp"/>
                <img loading="lazy" src="https://hdoro.dev/content/articles/the-http-crash-course-nobody-asked-for/assets/wireshark-reqwest-tls.1b7183504ba1672a.jpg" title="A TCP stream viewed in wireshark. The contents are explained in the next paragraph." alt="A TCP stream viewed in wireshark. The contents are explained in the next paragraph."/>
            </picture>
            
<p>First we have the TCP handshake: SYN, SYN-ACK, and ACK. Then my computer (in
this case, <code>10.0.2.15</code>, oh no you have my IP, don&#39;t hack me!) sends a TLS
<code>ClientHello</code>, and that&#39;s what&#39;s focused just so you can see what&#39;s in there:
one noteworthy part is the &#34;server name&#34; extension, which is set to <code>example.org</code>,
and that&#39;s how I know it&#39;s actually the right TCP stream!</p>
<p>Next up we can see the server replies with a <code>ServerHello</code>, and then... there&#39;s
a bunch of <code>Application Data</code>, which are opaque. If we click on them, we just
see the encrypted version:</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/the-http-crash-course-nobody-asked-for/assets/wireshark-reqwest-tls-appdata.6ef6512def1af9d8.avif"/>
                <source type="image/webp" srcset="/content/articles/the-http-crash-course-nobody-asked-for/assets/wireshark-reqwest-tls-appdata.0b591b9245374c51.webp"/>
                <img loading="lazy" src="https://hdoro.dev/content/articles/the-http-crash-course-nobody-asked-for/assets/wireshark-reqwest-tls-appdata.1987358339c7107b.jpg" title="The same wireshark window, except one of the Application Data lines is focused. The structured pane shows a TLSv1.3 record layer with encrypted application data. No attempt is made at decrypting it." alt="The same wireshark window, except one of the Application Data lines is focused. The structured pane shows a TLSv1.3 record layer with encrypted application data. No attempt is made at decrypting it."/>
            </picture>
            
<p>So, well, uhh... we don&#39;t know what&#39;s in there, but we can tell it&#39;s using TLS
at least, which is what we wanted to verify.</p>
<p>If we go back to the insecure <code>http://</code> URL real quick, we see a different picture:</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/the-http-crash-course-nobody-asked-for/assets/wireshark-reqwest-plaintext.3f6299880e9bf15c.avif"/>
                <source type="image/webp" srcset="/content/articles/the-http-crash-course-nobody-asked-for/assets/wireshark-reqwest-plaintext.1b21078a0f4f52c4.webp"/>
                <img loading="lazy" src="https://hdoro.dev/content/articles/the-http-crash-course-nobody-asked-for/assets/wireshark-reqwest-plaintext.eaa4f487bdb97836.jpg" title="Wireshark capture showing a plaintext HTTP request" alt="Wireshark capture showing a plaintext HTTP request"/>
            </picture>
            
<p>This time, we still see the TCP handshake, but then Wireshark is able to decode
the following packets as plaintext HTTP. It even parses the headers, the body,
everything!</p>
<p>It&#39;s time to move down one level of abstraction.</p>

                        <h2>
                            <a id="making-http-1-1-requests-with-hyper" href="#making-http-1-1-requests-with-hyper">
                                Making HTTP/1.1 requests with <code>hyper</code>
                            </a>
                        </h2>
                        
<p><code>reqwest</code> uses <a href="https://lib.rs/crates/hyper">hyper</a>, and so, that seems like the
next logical place to go to.</p>
<div><p>Shell session</p><pre data-lang="shell">$ cargo rm reqwest
(cut)
$ cargo add hyper -F client,tcp,http1
(cut)
</pre></div><div><p>Rust code</p><pre data-lang="rust"><i>// in `src/main.rs`</i>

<i>#<i>[</i>tokio<i>::</i>main<i>]</i></i>
async <i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> response = hyper<i>::</i><i>Client</i><i>::</i><i>new</i><i>(</i><i>)</i>
        <i>.</i><i>get</i><i>(</i><i>&#34;http://example.org&#34;</i><i>.</i><i>parse</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>)</i>
        <i>.</i>await
        <i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
    <i>println</i><i>!</i><i>(</i>
        <i>&#34;Got HTTP {}, with headers: {:#?}&#34;</i>,
        response.status<i>(</i><i>)</i>,
        response.headers<i>(</i><i>)</i>
    <i>)</i><i>;</i>

    <i>let</i> body = response<i>.</i><i>body</i><i>(</i><i>)</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;Body: {:?}&#34;</i>, body<i>)</i><i>;</i>
}
</pre></div><div><p>Shell session</p><pre data-lang="shell">$ cargo run --quiet
Got HTTP 200 OK, with headers: {
    &#34;age&#34;: &#34;479710&#34;,
    &#34;cache-control&#34;: &#34;max-age=604800&#34;,
    &#34;content-type&#34;: &#34;text/html; charset=UTF-8&#34;,
    &#34;date&#34;: &#34;Fri, 07 Oct 2022 16:14:16 GMT&#34;,
    &#34;etag&#34;: &#34;\&#34;3147526947+ident\&#34;&#34;,
    &#34;expires&#34;: &#34;Fri, 14 Oct 2022 16:14:16 GMT&#34;,
    &#34;last-modified&#34;: &#34;Thu, 17 Oct 2019 07:18:26 GMT&#34;,
    &#34;server&#34;: &#34;ECS (dcb/7F5E)&#34;,
    &#34;vary&#34;: &#34;Accept-Encoding&#34;,
    &#34;x-cache&#34;: &#34;HIT&#34;,
    &#34;content-length&#34;: &#34;1256&#34;,
}
Body: Body(Streaming)
</pre></div>
<p>Hey, that&#39;s eerily similar! And it wasn&#39;t even that bad!</p>
<div>

<p>Say, that&#39;s uhh.. that&#39;s not the body at all.</p>
</div>
<p>Oh right, the body. Well, in reqwest&#39;s API, you could already see the separation
between &#34;header&#34; and &#34;body&#34;, because we had to <code>.await</code> twice: once to get the
header, and another time to get the whole body as text.</p>
<div>

<p>The HTTP <em>header</em> is not to be confused with HTTP <em>headers</em>.</p>
<p>An HTTP <em>header</em> begins with a <code>start-line</code> (a <code>request-line</code> for requests, or a
<code>status-line</code> for responses) and is followed by one or more header fields. See
<a href="https://httpwg.org/specs/rfc9112.html#message.format">RFC 9112, Section 2.1</a> for
details.</p>
</div>
<p>Hyper does give us a handle to the body immediately, and then we can choose what
to do with it. Using the lowest-level interface available, we can poll it for
data, getting one buffer at a time:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>// in `src/main.rs`</i>

<i>use</i> hyper<i>::</i>body<i>::</i>HttpBody<i>;</i>
<i>use</i> std<i>::</i>pin<i>::</i>Pin<i>;</i>

<i>#<i>[</i>tokio<i>::</i>main<i>]</i></i>
async <i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> response = hyper<i>::</i><i>Client</i><i>::</i><i>new</i><i>(</i><i>)</i>
        <i>.</i><i>get</i><i>(</i><i>&#34;http://example.org&#34;</i><i>.</i><i>parse</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>)</i>
        <i>.</i>await
        <i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>

    <i>let</i> <i>mut</i> body = response<i>.</i><i>into_body</i><i>(</i><i>)</i><i>;</i>

    <i>while</i> <i>let</i> Some<i>(</i>buffer<i>)</i> = std<i>::</i>future<i>::</i><i>poll_fn</i><i>(</i>|cx| <i>Pin</i><i>::</i><i>new</i><i>(</i><i>&amp;</i><i>mut</i> body<i>)</i><i>.</i><i>poll_data</i><i>(</i>cx<i>)</i><i>)</i><i>.</i>await {
        <i>let</i> buffer = buffer<i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
        <i>println</i><i>!</i><i>(</i><i>&#34;Read {} bytes&#34;</i>, buffer.len<i>(</i><i>)</i><i>)</i><i>;</i>
    }
}
</pre></div>
<p>With this code, sometimes we get this:</p>
<div><p>Shell session</p><pre data-lang="shell">$ cargo run --quiet
Read 1256 byte
</pre></div>
<p>And sometimes:</p>
<div><p>Shell session</p><pre data-lang="shell">$ cargo run --quiet
Read 1125 bytes
Read 131 bytes
</pre></div>
<p>Which is interesting! We can see how it corresponds to the size of the reads
performed against the TCP socket with <a href="https://man7.org/linux/man-pages/man1/strace.1.html">strace</a>:</p>
<div><p>Shell session</p><pre data-lang="shell">$ strace -ff ./target/debug/crash 2&gt;&amp;1 | grep -E &#39;recvfrom|Read [0-9]+ bytes&#39;
[pid 174829] recvfrom(9, &#34;$\241\201\200\0\1\0\1\0\0\0\0\7example\3org\0\0\34\0\1\300\f\0&#34;..., 2048, 0, {sa_family=AF_INET6, sin6_port=htons(53), sin6_flowinfo=htonl(0), inet_pton(AF_INET6, &#34;fdaa:0:a0c3::3&#34;, &amp;sin6_addr), sin6_scope_id=0}, [28]) = 57
[pid 174829] recvfrom(9, &#34;G\276\201\200\0\1\0\1\0\0\0\0\7example\3org\0\0\1\0\1\300\f\0&#34;..., 65536, 0, {sa_family=AF_INET6, sin6_port=htons(53), sin6_flowinfo=htonl(0), inet_pton(AF_INET6, &#34;fdaa:0:a0c3::3&#34;, &amp;sin6_addr), sin6_scope_id=0}, [28]) = 45
[pid 174813] recvfrom(9, &#34;HTTP/1.1 200 OK\r\nAge: 135402\r\nCa&#34;..., 8192, 0, NULL, NULL) = 1591
[pid 174812] write(1, &#34;Read 1256 bytes\n&#34;, 16 &lt;unfinished ...&gt;
[pid 174827] write(4, &#34;\1\0\0\0\0\0\0\0&#34;, 8Read 1256 bytes
</pre></div>
<p>And here&#39;s the version in two reads:</p>
<div><p>Shell session</p><pre data-lang="shell">$ strace -ff ./target/debug/crash 2&gt;&amp;1 | grep -E &#39;recvfrom|Read [0-9]+ bytes&#39;
[pid 175754] recvfrom(9, &#34;2\375\201\200\0\1\0\1\0\0\0\0\7example\3org\0\0\1\0\1\300\f\0&#34;..., 2048, 0, {sa_family=AF_INET6, sin6_port=htons(53), sin6_flowinfo=htonl(0), inet_pton(AF_INET6, &#34;fdaa:0:a0c3::3&#34;, &amp;sin6_addr), sin6_scope_id=0}, [28]) = 45
[pid 175754] recvfrom(9, &#34;\v\376\201\200\0\1\0\1\0\0\0\0\7example\3org\0\0\34\0\1\300\f\0&#34;..., 65536, 0, {sa_family=AF_INET6, sin6_port=htons(53), sin6_flowinfo=htonl(0), inet_pton(AF_INET6, &#34;fdaa:0:a0c3::3&#34;, &amp;sin6_addr), sin6_scope_id=0}, [28]) = 57
[pid 175740] recvfrom(9, &#34;HTTP/1.1 200 OK\r\nAge: 481205\r\nCa&#34;..., 8192, 0, NULL, NULL) = 1460
[pid 175737] write(1, &#34;Read 1125 bytes\n&#34;, 16 &lt;unfinished ...&gt;
Read 1125 bytes
[pid 175740] recvfrom(9, &#34;sking for permission.&lt;/p&gt;\n    &lt;p&#34;..., 8192, 0, NULL, NULL) = 131
[pid 175737] write(1, &#34;Read 131 bytes\n&#34;, 15 &lt;unfinished ...&gt;
[pid 175740] shutdown(9, SHUT_WRRead 131 bytes
</pre></div>
<p>Notice how the first read is 1460 bytes? I guess that&#39;s the
<a href="https://superuser.com/a/1652039">MSS</a> for the path from my VM to <code>example.org</code>!
How fun!</p>
<div>

<p>But how come sometimes we get it all in one read?</p>
</div>
<p>Ah, because the kernel does its own buffering.</p>
<p>Anyway, the <code>poll_data</code> code is kinda scary, using the recently-stabilized
<code>std::future::poll_fn</code> construct, which you really shouldn&#39;t have to know about
unless <a href="https://hdoro.dev/articles/understanding-rust-futures-by-going-way-too-deep">you really want
to</a>.</p>
<p>Instead, we can use a standard interface: streams! Which are like iterators, but
asynchronous.</p>
<p>We just need to add a feature to hyper:</p>
<div><p>Shell session</p><pre data-lang="shell">$ cargo add hyper -F stream                                                  
    Updating crates.io index
      Adding hyper v0.14.20 to dependencies.
(cut)
</pre></div>
<p>(Doing <code>cargo add</code> for an existing dependency adds to the already-present
features so we don&#39;t need to list <code>tcp</code>, <code>client</code>, <code>http1</code>, etc. again)</p>
<p>And also add a convenience crate to use streams, since very little of async is
actually in the standard library:</p>
<div><p>Shell session</p><pre data-lang="shell">$ cargo add futures
(cut)
</pre></div>
<p>And now our code can look like this:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>use</i> futures<i>::</i>TryStreamExt<i>;</i>

<i>#<i>[</i>tokio<i>::</i>main<i>]</i></i>
async <i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> response = hyper<i>::</i><i>Client</i><i>::</i><i>new</i><i>(</i><i>)</i>
        <i>.</i><i>get</i><i>(</i><i>&#34;http://example.org&#34;</i><i>.</i><i>parse</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>)</i>
        <i>.</i>await
        <i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>

    <i>let</i> <i>mut</i> body = response<i>.</i><i>into_body</i><i>(</i><i>)</i><i>;</i>

    <i>while</i> <i>let</i> Some<i>(</i>buffer<i>)</i> = body<i>.</i><i>try_next</i><i>(</i><i>)</i><i>.</i>await<i>.</i><i>unwrap</i><i>(</i><i>)</i> {
        <i>println</i><i>!</i><i>(</i><i>&#34;Read {} bytes&#34;</i>, buffer.len<i>(</i><i>)</i><i>)</i><i>;</i>
    }
}
</pre></div>
<p>And does the exact same thing, except, we could now use combinators on the body
if we wanted, and we didn&#39;t have to know much about how futures work in Rust.</p>
<p>In our case though, we don&#39;t really <em>need</em> to read the body in a streaming
fashion, we&#39;re fine collecting it all and handling it as a single buffer, so
we can do this:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>#<i>[</i>tokio<i>::</i>main<i>]</i></i>
async <i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> response = hyper<i>::</i><i>Client</i><i>::</i><i>new</i><i>(</i><i>)</i>
        <i>.</i><i>get</i><i>(</i><i>&#34;http://example.org&#34;</i><i>.</i><i>parse</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>)</i>
        <i>.</i>await
        <i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>

    <i>let</i> body = hyper<i>::</i>body<i>::</i><i>to_bytes</i><i>(</i>response<i>.</i><i>into_body</i><i>(</i><i>)</i><i>)</i><i>.</i>await<i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;body is {} bytes&#34;</i>, body.len<i>(</i><i>)</i><i>)</i><i>;</i>
}
</pre></div>
<p>And now it looks somewhat closer to the <code>reqwest</code> version. It&#39;s not doing the
same thing yet though — we&#39;re getting a slice of bytes, not a UTF-8 encoded
string. If we want a true equivalent, we&#39;ll do this:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>#<i>[</i>tokio<i>::</i>main<i>]</i></i>
async <i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> response = hyper<i>::</i><i>Client</i><i>::</i><i>new</i><i>(</i><i>)</i>
        <i>.</i><i>get</i><i>(</i><i>&#34;http://example.org&#34;</i><i>.</i><i>parse</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>)</i>
        <i>.</i>await
        <i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>

    <i>let</i> body = <i>String</i><i>::</i><i>from_utf8</i><i>(</i>
        hyper<i>::</i>body<i>::</i><i>to_bytes</i><i>(</i>response<i>.</i><i>into_body</i><i>(</i><i>)</i><i>)</i>
            <i>.</i>await
            <i>.</i><i>unwrap</i><i>(</i><i>)</i>
            <i>.</i><i>to_vec</i><i>(</i><i>)</i>,
    <i>)</i>
    <i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;response body: {body}&#34;</i><i>)</i><i>;</i>
}
</pre></div>
<p>And you can kinda see all the failure points at the <code>.unwrap()</code> callsites. Which,
by the way, means &#34;turn this <code>Result&lt;T, E&gt;</code> into a <code>T</code> or die trying&#34;, and by die
I mean &#34;print a backtrace/stacktrace and quit the program&#34;.</p>
<p><code>Client::get()</code> can fail because we might not be able to establish a TCP
connection, we might not be able to write our HTTP/1.1 request, the server might
not respond with HTTP/1.1 at all, or close the connection early.</p>
<p><code>body::to_bytes()</code> can fail because, again, the server could close the
connection early. Or it could be using chunked transfer encoding and send
invalid chunk prefixes.</p>
<p><code>String::from_utf8</code> can fail because the body might not actually be valid UTF-8,
it could just be arbitrary binary spaghetti.</p>
<div>

<p>Still, that code isn&#39;t too bad. Why do we need to bother with <code>reqwest</code> again?</p>
</div>
<p>I&#39;m not sure! Let&#39;s try doing HTTPS now:</p>
<div><p>Rust code</p><pre data-lang="rust">    <i>let</i> response = hyper<i>::</i><i>Client</i><i>::</i><i>new</i><i>(</i><i>)</i>
        <i>//     👇 was http</i>
        <i>.</i><i>get</i><i>(</i><i>&#34;https://example.org&#34;</i><i>.</i><i>parse</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>)</i>
        <i>.</i>await
        <i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
</pre></div><div><p>Shell session</p><pre data-lang="shell">$ cargo run --quiet
thread &#39;main&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: hyper::Error(Connect, &#34;invalid URL, scheme is not http&#34;)&#39;, src/main.rs:6:10
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</pre></div>
<p>Oh! There&#39;s a panic from one of those famous <code>unwrap</code>.</p>
<div><p>Shell session</p><pre data-lang="shell">$ RUST_BACKTRACE=1 cargo run --quiet
thread &#39;main&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: hyper::Error(Connect, &#34;invalid URL, scheme is not http&#34;)&#39;, src/main.rs:6:10
stack backtrace:
   0: rust_begin_unwind
             at /rustc/a55dd71d5fb0ec5a6a3a9e8c27b2127ba491ce52/library/std/src/panicking.rs:584:5
   1: core::panicking::panic_fmt
             at /rustc/a55dd71d5fb0ec5a6a3a9e8c27b2127ba491ce52/library/core/src/panicking.rs:142:14
   2: core::result::unwrap_failed
             at /rustc/a55dd71d5fb0ec5a6a3a9e8c27b2127ba491ce52/library/core/src/result.rs:1814:5
   3: core::result::Result&lt;T,E&gt;::unwrap
             at /rustc/a55dd71d5fb0ec5a6a3a9e8c27b2127ba491ce52/library/core/src/result.rs:1107:23
   4: crash::main::{{closure}}
             at ./src/main.rs:3:20
   5: &lt;core::future::from_generator::GenFuture&lt;T&gt; as core::future::future::Future&gt;::poll
             at /rustc/a55dd71d5fb0ec5a6a3a9e8c27b2127ba491ce52/library/core/src/future/mod.rs:91:19
   6: tokio::park::thread::CachedParkThread::block_on::{{closure}}
             at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.21.2/src/park/thread.rs:267:54
   7: tokio::coop::with_budget::{{closure}}
             at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.21.2/src/coop.rs:102:9
   8: std::thread::local::LocalKey&lt;T&gt;::try_with
             at /rustc/a55dd71d5fb0ec5a6a3a9e8c27b2127ba491ce52/library/std/src/thread/local.rs:445:16
   9: std::thread::local::LocalKey&lt;T&gt;::with
             at /rustc/a55dd71d5fb0ec5a6a3a9e8c27b2127ba491ce52/library/std/src/thread/local.rs:421:9
  10: tokio::coop::with_budget
             at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.21.2/src/coop.rs:95:5
  11: tokio::coop::budget
             at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.21.2/src/coop.rs:72:5
  12: tokio::park::thread::CachedParkThread::block_on
             at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.21.2/src/park/thread.rs:267:31
  13: tokio::runtime::enter::Enter::block_on
             at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.21.2/src/runtime/enter.rs:152:13
  14: tokio::runtime::scheduler::multi_thread::MultiThread::block_on
             at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.21.2/src/runtime/scheduler/multi_thread/mod.rs:79:9
  15: tokio::runtime::Runtime::block_on
             at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.21.2/src/runtime/mod.rs:492:44
  16: crash::main
             at ./src/main.rs:15:5
  17: core::ops::function::FnOnce::call_once
             at /rustc/a55dd71d5fb0ec5a6a3a9e8c27b2127ba491ce52/library/core/src/ops/function.rs:248:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</pre></div>
<p>And there&#39;s a backtrace.</p>
<div>

<div>
<p>So, wait, hyper can&#39;t do HTTPS?</p>
<p>I mean.. it must be able to, right? Since reqwest can, and reqwest uses hyper?</p>
</div>
</div>
<p>That&#39;s correct! We just have to explicitly enable it. And this time, we&#39;ll
use <code>rustls</code>, not <code>OpenSSL</code>:</p>
<div><p>Shell session</p><pre data-lang="shell">$ cargo add hyper-rustls
(cut)
</pre></div><div><p>Rust code</p><pre data-lang="rust"><i>#<i>[</i>tokio<i>::</i>main<i>]</i></i>
async <i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> conn = hyper_rustls<i>::</i><i>HttpsConnectorBuilder</i><i>::</i><i>new</i><i>(</i><i>)</i>
        <i>.</i><i>with_native_roots</i><i>(</i><i>)</i>
        <i>.</i><i>https_or_http</i><i>(</i><i>)</i>
        <i>.</i><i>enable_http1</i><i>(</i><i>)</i>
        <i>.</i><i>build</i><i>(</i><i>)</i><i>;</i>

    <i>let</i> client = hyper<i>::</i><i>Client</i><i>::</i><i>builder</i><i>(</i><i>)</i><i>.</i><i>build</i><i>::</i><i>&lt;</i><i>_</i>, hyper<i>::</i><i>Body</i><i>&gt;</i><i>(</i>conn<i>)</i><i>;</i>

    <i>let</i> response = client
        <i>.</i><i>get</i><i>(</i><i>&#34;https://example.org&#34;</i><i>.</i><i>parse</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>)</i>
        <i>.</i>await
        <i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>

    <i>let</i> body = <i>String</i><i>::</i><i>from_utf8</i><i>(</i>
        hyper<i>::</i>body<i>::</i><i>to_bytes</i><i>(</i>response<i>.</i><i>into_body</i><i>(</i><i>)</i><i>)</i>
            <i>.</i>await
            <i>.</i><i>unwrap</i><i>(</i><i>)</i>
            <i>.</i><i>to_vec</i><i>(</i><i>)</i>,
    <i>)</i>
    <i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;response body: {body}&#34;</i><i>)</i><i>;</i>
}
</pre></div><div>

<p>The output is exactly the same, so I&#39;m not going to show it here.</p>
</div>
<div>

<p>Okay yeah now it is a little long-winded.</p>
</div>
<p>Yes, hence the use for something higher-level like <code>reqwest</code>. But you know
what&#39;s cool about going lower-level?</p>

<p>No, control! Now, for example, we can enable a very fun rustls option.</p>
<div><p>Shell session</p><pre data-lang="shell">$ cargo add rustls
</pre></div><div><p>Rust code</p><pre data-lang="rust"><i>use</i> std<i>::</i>sync<i>::</i>Arc<i>;</i>

<i>use</i> hyper_rustls<i>::</i>ConfigBuilderExt<i>;</i>
<i>use</i> rustls<i>::</i>{ClientConfig, KeyLogFile}<i>;</i>

<i>#<i>[</i>tokio<i>::</i>main<i>]</i></i>
async <i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> <i>mut</i> client_config = <i>ClientConfig</i><i>::</i><i>builder</i><i>(</i><i>)</i>
        <i>.</i><i>with_safe_defaults</i><i>(</i><i>)</i>
        <i>.</i><i>with_native_roots</i><i>(</i><i>)</i>
        <i>.</i><i>with_no_client_auth</i><i>(</i><i>)</i><i>;</i>
    <i>// this is the fun option</i>
    client_config<i>.</i><i>key_log</i> = <i>Arc</i><i>::</i><i>new</i><i>(</i><i>KeyLogFile</i><i>::</i><i>new</i><i>(</i><i>)</i><i>)</i><i>;</i>

    <i>let</i> conn = hyper_rustls<i>::</i><i>HttpsConnectorBuilder</i><i>::</i><i>new</i><i>(</i><i>)</i>
        <i>.</i><i>with_tls_config</i><i>(</i>client_config<i>)</i>
        <i>.</i><i>https_or_http</i><i>(</i><i>)</i>
        <i>.</i><i>enable_http1</i><i>(</i><i>)</i>
        <i>.</i><i>build</i><i>(</i><i>)</i><i>;</i>

    <i>let</i> client = hyper<i>::</i><i>Client</i><i>::</i><i>builder</i><i>(</i><i>)</i><i>.</i><i>build</i><i>::</i><i>&lt;</i><i>_</i>, hyper<i>::</i><i>Body</i><i>&gt;</i><i>(</i>conn<i>)</i><i>;</i>

    <i>let</i> response = client
        <i>.</i><i>get</i><i>(</i><i>&#34;https://example.org&#34;</i><i>.</i><i>parse</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>)</i>
        <i>.</i>await
        <i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>

    <i>let</i> body = <i>String</i><i>::</i><i>from_utf8</i><i>(</i>
        hyper<i>::</i>body<i>::</i><i>to_bytes</i><i>(</i>response<i>.</i><i>into_body</i><i>(</i><i>)</i><i>)</i>
            <i>.</i>await
            <i>.</i><i>unwrap</i><i>(</i><i>)</i>
            <i>.</i><i>to_vec</i><i>(</i><i>)</i>,
    <i>)</i>
    <i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;response body: {body}&#34;</i><i>)</i><i>;</i>
}
</pre></div>
<p>And now for the grand reveal... again we&#39;ll run tcpdump in a terminal, and in
the other:</p>
<div><p>Shell session</p><pre data-lang="shell">$ SSLKEYLOGFILE=/shared/sslkeylogfile cargo run
(cut)
</pre></div>
<p>Tada!</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/the-http-crash-course-nobody-asked-for/assets/wireshark-hyper-tls-keylog.74ddce6dd76b59b5.avif"/>
                <source type="image/webp" srcset="/content/articles/the-http-crash-course-nobody-asked-for/assets/wireshark-hyper-tls-keylog.ddfbff18384717a3.webp"/>
                <img loading="lazy" src="https://hdoro.dev/content/articles/the-http-crash-course-nobody-asked-for/assets/wireshark-hyper-tls-keylog.bcd91e3265c63676.jpg" title="Wireshark view of our TLS session, now decrypted." alt="Wireshark view of our TLS session, now decrypted."/>
            </picture>
            
<p>All I needed was to give Wireshark the path to our <code>sslkeylogfile</code> written by
hyper, which looks like this btw:</p>
<div><pre data-lang="">CLIENT_HANDSHAKE_TRAFFIC_SECRET 7c0414ee6d236f73fd5f382bd35608a5e3c8d513c5b86574eb4a4f02209f1726 d477d1ae27cbb94ff7068f187540f9534dc8407e4e1ce4e5d76504799d094ffb2ee4038889d2b8fb870f236db46e6c6b
SERVER_HANDSHAKE_TRAFFIC_SECRET 7c0414ee6d236f73fd5f382bd35608a5e3c8d513c5b86574eb4a4f02209f1726 3d5102a8a2f61187df77b5acd18f255fc62f29750d6ee9d0204ccdb088d814a5823b4f091d762c490bb3cd2f802cc4b4
CLIENT_TRAFFIC_SECRET_0 7c0414ee6d236f73fd5f382bd35608a5e3c8d513c5b86574eb4a4f02209f1726 bfe83697e414f522fbefb2a7685133bc4a6680277f84e43b9d18c5cbebff3401641d8b6b09a4c2e21c704868dd67c358
SERVER_TRAFFIC_SECRET_0 7c0414ee6d236f73fd5f382bd35608a5e3c8d513c5b86574eb4a4f02209f1726 92aadcdc3987693e5d6650cae166dccee5b305fc52e70901d093d3fa2f8f274d7b773b762e8888a4b23f6831a4c4d30e
EXPORTER_SECRET 7c0414ee6d236f73fd5f382bd35608a5e3c8d513c5b86574eb4a4f02209f1726 0be36d7656f908a04847f3d09de9429d611ab539f761a1a96f70674c7efe588ac0829fd11b980490f7816cb5e5f2b61c
</pre></div>
<p>You can set that up for yourself in Edit -&gt; Preferences -&gt; Protocols -&gt; TLS (you
can type to jump to it), and from there, set the &#34;(Pre)-Master-Secret log
filename&#34;.</p>
<p>Here&#39;s what the client sent:</p>
<div><pre data-lang="">0000   47 45 54 20 2f 20 48 54 54 50 2f 31 2e 31 0d 0a   GET / HTTP/1.1..
0010   68 6f 73 74 3a 20 65 78 61 6d 70 6c 65 2e 6f 72   host: example.or
0020   67 0d 0a 0d 0a                                    g....
</pre></div>
<p>And here&#39;s what the server replied with:</p>
<div><pre data-lang="">0000   48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d   HTTP/1.1 200 OK.
0010   0a 41 67 65 3a 20 34 38 34 38 39 34 0d 0a 43 61   .Age: 484894..Ca
0020   63 68 65 2d 43 6f 6e 74 72 6f 6c 3a 20 6d 61 78   che-Control: max
0030   2d 61 67 65 3d 36 30 34 38 30 30 0d 0a 43 6f 6e   -age=604800..Con
0040   74 65 6e 74 2d 54 79 70 65 3a 20 74 65 78 74 2f   tent-Type: text/
0050   68 74 6d 6c 3b 20 63 68 61 72 73 65 74 3d 55 54   html; charset=UT
0060   46 2d 38 0d 0a 44 61 74 65 3a 20 46 72 69 2c 20   F-8..Date: Fri, 
0070   30 37 20 4f 63 74 20 32 30 32 32 20 31 37 3a 30   07 Oct 2022 17:0
0080   35 3a 30 30 20 47 4d 54 0d 0a 45 74 61 67 3a 20   5:00 GMT..Etag: 
0090   22 33 31 34 37 35 32 36 39 34 37 2b 69 64 65 6e   &#34;3147526947+iden
00a0   74 22 0d 0a 45 78 70 69 72 65 73 3a 20 46 72 69   t&#34;..Expires: Fri
00b0   2c 20 31 34 20 4f 63 74 20 32 30 32 32 20 31 37   , 14 Oct 2022 17
00c0   3a 30 35 3a 30 30 20 47 4d 54 0d 0a 4c 61 73 74   :05:00 GMT..Last
00d0   2d 4d 6f 64 69 66 69 65 64 3a 20 54 68 75 2c 20   -Modified: Thu, 
00e0   31 37 20 4f 63 74 20 32 30 31 39 20 30 37 3a 31   17 Oct 2019 07:1
00f0   38 3a 32 36 20 47 4d 54 0d 0a 53 65 72 76 65 72   8:26 GMT..Server
0100   3a 20 45 43 53 20 28 64 63 62 2f 37 46 36 30 29   : ECS (dcb/7F60)
0110   0d 0a 56 61 72 79 3a 20 41 63 63 65 70 74 2d 45   ..Vary: Accept-E
0120   6e 63 6f 64 69 6e 67 0d 0a 58 2d 43 61 63 68 65   ncoding..X-Cache
0130   3a 20 48 49 54 0d 0a 43 6f 6e 74 65 6e 74 2d 4c   : HIT..Content-L
0140   65 6e 67 74 68 3a 20 31 32 35 36 0d 0a 0d 0a      ength: 1256....
</pre></div>
<p>This is all pretty familiar. I feel like we have a fairly good handle on
what HTTP/1.1 looks like right now.</p>
<p>Which means we can probably do it ourselves.</p>

                        <h2>
                            <a id="making-http-1-1-requests-ourselves" href="#making-http-1-1-requests-ourselves">
                                Making HTTP/1.1 requests ourselves
                            </a>
                        </h2>
                        
<p>First let&#39;s get rid of hyper:</p>
<div><p>Shell session</p><pre data-lang="shell">$ cargo rm hyper
    Removing hyper from dependencies
$ cargo rm hyper-rustls
    Removing hyper-rustls from dependencies
</pre></div>
<p>We&#39;ll skip the plaintext part, since we&#39;re already at the &#34;setting up rustls
ourselves&#34; stage. Because we&#39;ll want to be able to use the <code>AsyncRead</code> /
<code>AsyncWrite</code> traits, we&#39;ll want to pull in
<a href="https://lib.rs/crates/tokio-rustls">tokio-rustls</a> as well.</p>
<div><p>Shell session</p><pre data-lang="shell">$ cargo add tokio-rustls
    Updating crates.io index
      Adding tokio-rustls v0.23.4 to dependencies.
</pre></div>
<p>Because we need to tell rustls which certificates to trust, we need to point it
to a set of &#34;certificate roots&#34;. We could use the <a href="https://lib.rs/crates/webpki-roots">Mozilla
set</a> or just rely on whatever the OS has
installed. Let&#39;s go with the latter:</p>
<div><p>Shell session</p><pre data-lang="shell">$ cargo add rustls-native-certs
    Updating crates.io index
      Adding rustls-native-certs v0.6.2 to dependencies.
</pre></div>
<p>I also would like some nice error types by default, so, let&#39;s grab
<a href="https://lib.rs/crates/color-eyre">color-eyre</a>:</p>
<div><p>Shell session</p><pre data-lang="shell">$ cargo add color-eyre
    Updating crates.io index
      Adding color-eyre v0.6.2 to dependencies
</pre></div>
<p>And because we&#39;re getting into serious business, let&#39;s also pull in <code>tracing</code>
and <code>tracing-subscriber</code>:</p>
<div><p>Shell session</p><pre data-lang="shell">$ cargo add tracing tracing-subscriber
(cut)
</pre></div>
<p>Finally, because writing a parser by hand is no fun, let&#39;s pull in
<a href="https://lib.rs/crates/nom">nom</a>:</p>
<div><p>Shell session</p><pre data-lang="shell">$ cargo add nom
    Updating crates.io index
      Adding nom v7.1.1 to dependencies.
</pre></div>
<p>Here&#39;s the main structure of our program:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>// in `src/main.rs`</i>

<i>use</i> std<i>::</i>{str<i>::</i>FromStr, sync<i>::</i>Arc}<i>;</i>

<i>use</i> color_eyre<i>::</i>eyre<i>::</i>eyre<i>;</i>
<i>use</i> nom<i>::</i>Offset<i>;</i>
<i>use</i> rustls<i>::</i>{Certificate, ClientConfig, KeyLogFile, RootCertStore}<i>;</i>
<i>use</i> tokio<i>::</i>{
    io<i>::</i>{AsyncReadExt, AsyncWriteExt},
    net<i>::</i>TcpStream,
}<i>;</i>
<i>use</i> tracing<i>::</i>info<i>;</i>
<i>use</i> tracing_subscriber<i>::</i>{filter<i>::</i>targets<i>::</i>Targets, layer<i>::</i>SubscriberExt, util<i>::</i>SubscriberInitExt}<i>;</i>

<i>mod</i> http11<i>;</i>

<i>#<i>[</i>tokio<i>::</i>main<i>]</i></i>
async <i>fn</i> <i>main</i><i>(</i><i>)</i> -&gt; color_eyre<i>::</i><i>Result</i><i>&lt;</i><i>(</i><i>)</i><i>&gt;</i> {
    color_eyre<i>::</i><i>install</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>

    <i>let</i> filter_layer =
        <i>Targets</i><i>::</i><i>from_str</i><i>(</i>std<i>::</i>env<i>::</i><i>var</i><i>(</i><i>&#34;RUST_LOG&#34;</i><i>)</i><i>.</i><i>as_deref</i><i>(</i><i>)</i><i>.</i><i>unwrap_or</i><i>(</i><i>&#34;info&#34;</i><i>)</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
    <i>let</i> format_layer = tracing_subscriber<i>::</i>fmt<i>::</i><i>layer</i><i>(</i><i>)</i><i>;</i>
    tracing_subscriber<i>::</i><i>registry</i><i>(</i><i>)</i>
        <i>.</i><i>with</i><i>(</i>filter_layer<i>)</i>
        <i>.</i><i>with</i><i>(</i>format_layer<i>)</i>
        <i>.</i><i>init</i><i>(</i><i>)</i><i>;</i>

    <i>info</i><i>!</i><i>(</i><i>&#34;Establishing a TCP connection...&#34;</i><i>)</i><i>;</i>
    <i>let</i> stream = <i>TcpStream</i><i>::</i><i>connect</i><i>(</i><i>&#34;example.org:443&#34;</i><i>)</i><i>.</i>await?<i>;</i>

    <i>info</i><i>!</i><i>(</i><i>&#34;Setting up TLS root certificate store&#34;</i><i>)</i><i>;</i>
    <i>let</i> <i>mut</i> root_store = <i>RootCertStore</i><i>::</i><i>empty</i><i>(</i><i>)</i><i>;</i>
    <i>for</i> cert <i>in</i> rustls_native_certs<i>::</i><i>load_native_certs</i><i>(</i><i>)</i>? {
        root_store<i>.</i><i>add</i><i>(</i><i>&amp;</i>Certificate<i>(</i>cert<i>.</i><i>0</i><i>)</i><i>)</i>?<i>;</i>
    }
    <i>let</i> <i>mut</i> client_config = <i>ClientConfig</i><i>::</i><i>builder</i><i>(</i><i>)</i>
        <i>.</i><i>with_safe_defaults</i><i>(</i><i>)</i>
        <i>.</i><i>with_root_certificates</i><i>(</i>root_store<i>)</i>
        <i>.</i><i>with_no_client_auth</i><i>(</i><i>)</i><i>;</i>
    client_config<i>.</i><i>key_log</i> = <i>Arc</i><i>::</i><i>new</i><i>(</i><i>KeyLogFile</i><i>::</i><i>new</i><i>(</i><i>)</i><i>)</i><i>;</i>
    <i>let</i> connector = tokio_rustls<i>::</i><i>TlsConnector</i><i>::</i><i>from</i><i>(</i><i>Arc</i><i>::</i><i>new</i><i>(</i>client_config<i>)</i><i>)</i><i>;</i>

    <i>info</i><i>!</i><i>(</i><i>&#34;Performing TLS handshake&#34;</i><i>)</i><i>;</i>
    <i>let</i> <i>mut</i> stream = connector<i>.</i><i>connect</i><i>(</i><i>&#34;example.org&#34;</i><i>.</i><i>try_into</i><i>(</i><i>)</i>?, stream<i>)</i><i>.</i>await?<i>;</i>

    <i>info</i><i>!</i><i>(</i><i>&#34;Sending HTTP/1.1 request&#34;</i><i>)</i><i>;</i>
    <i>let</i> req = <i>[</i>
        <i>&#34;GET / HTTP/1.1&#34;</i>,
        <i>&#34;host: example.org&#34;</i>,
        <i>&#34;user-agent: cool-bear/1.0&#34;</i>,
        <i>&#34;connection: close&#34;</i>,
        <i>&#34;&#34;</i>,
        <i>&#34;&#34;</i>,
    <i>]</i>
    <i>.</i><i>join</i><i>(</i><i>&#34;\r\n&#34;</i><i>)</i><i>;</i> <i>// allocates gratuitously which is fine for a sample</i>
    stream<i>.</i><i>write_all</i><i>(</i>req<i>.</i><i>as_bytes</i><i>(</i><i>)</i><i>)</i><i>.</i>await?<i>;</i>

    <i>info</i><i>!</i><i>(</i><i>&#34;Reading HTTP/1.1 response&#34;</i><i>)</i><i>;</i>

    <i>let</i> <i>mut</i> accum: <i>Vec</i><i>&lt;</i><i>u8</i><i>&gt;</i> = <i>Default</i><i>::</i><i>default</i><i>(</i><i>)</i><i>;</i>
    <i>let</i> <i>mut</i> rd_buf = <i>[</i><i>0u8</i><i>;</i> <i>1024</i><i>]</i><i>;</i>

    <i>let</i> <i>(</i>body_offset, res<i>)</i> = <i>loop</i> {
        <i>let</i> n = stream<i>.</i><i>read</i><i>(</i><i>&amp;</i><i>mut</i> rd_buf<i>[</i>..<i>]</i><i>)</i><i>.</i>await?<i>;</i>
        <i>info</i><i>!</i><i>(</i><i>&#34;Read {n} bytes&#34;</i><i>)</i><i>;</i>
        <i>if</i> n == <i>0</i> {
            <i>return</i> Err<i>(</i><i>eyre</i><i>!</i><i>(</i>
                <i>&#34;unexpected EOF (server closed connection during headers)&#34;</i>
            <i>)</i><i>)</i><i>;</i>
        }

        accum<i>.</i><i>extend_from_slice</i><i>(</i><i>&amp;</i>rd_buf<i>[</i>..n<i>]</i><i>)</i><i>;</i>

        <i>match</i> http11<i>::</i><i>response</i><i>(</i><i>&amp;</i>accum<i>)</i> {
            Err<i>(</i>e<i>)</i> =&gt; {
                <i>if</i> e<i>.</i><i>is_incomplete</i><i>(</i><i>)</i> {
                    <i>info</i><i>!</i><i>(</i><i>&#34;Need to read more, continuing&#34;</i><i>)</i><i>;</i>
                    <i>continue</i><i>;</i>
                } <i>else</i> {
                    <i>return</i> Err<i>(</i><i>eyre</i><i>!</i><i>(</i><i>&#34;parse error: {e}&#34;</i><i>)</i><i>)</i><i>;</i>
                }
            }
            Ok<i>(</i><i>(</i>remain, res<i>)</i><i>)</i> =&gt; {
                <i>let</i> body_offset = accum<i>.</i><i>offset</i><i>(</i>remain<i>)</i><i>;</i>
                <i>break</i> <i>(</i>body_offset, res<i>)</i><i>;</i>
            }
        }<i>;</i>
    }<i>;</i>

    <i>info</i><i>!</i><i>(</i><i>&#34;Got HTTP/1.1 response: {:#?}&#34;</i>, res<i>)</i><i>;</i>
    <i>let</i> <i>mut</i> body_accum = accum<i>[</i>body_offset..<i>]</i><i>.</i><i>to_vec</i><i>(</i><i>)</i><i>;</i>
    <i>// header names are case-insensitive, let&#39;s get it right. we&#39;re assuming</i>
    <i>// that the absence of content-length means there&#39;s no body, and also we</i>
    <i>// don&#39;t support chunked transfer encoding.</i>
    <i>let</i> content_length = res
        <i>.</i><i>headers</i>
        <i>.</i><i>iter</i><i>(</i><i>)</i>
        <i>.</i><i>find</i><i>(</i>|<i>(</i>k, _<i>)</i>| k<i>.</i><i>eq_ignore_ascii_case</i><i>(</i><i>&#34;content-length&#34;</i><i>)</i><i>)</i>
        <i>.</i><i>map</i><i>(</i>|<i>(</i>_, v<i>)</i>| v<i>.</i><i>parse</i><i>::</i><i>&lt;</i><i>usize</i><i>&gt;</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>)</i>
        <i>.</i><i>unwrap_or_default</i><i>(</i><i>)</i><i>;</i>

    <i>while</i> body_accum<i>.</i><i>len</i><i>(</i><i>)</i> &lt; content_length {
        <i>let</i> n = stream<i>.</i><i>read</i><i>(</i><i>&amp;</i><i>mut</i> rd_buf<i>[</i>..<i>]</i><i>)</i><i>.</i>await?<i>;</i>
        <i>info</i><i>!</i><i>(</i><i>&#34;Read {n} bytes&#34;</i><i>)</i><i>;</i>
        <i>if</i> n == <i>0</i> {
            <i>return</i> Err<i>(</i><i>eyre</i><i>!</i><i>(</i><i>&#34;unexpected EOF (peer closed connection during body)&#34;</i><i>)</i><i>)</i><i>;</i>
        }

        body_accum<i>.</i><i>extend_from_slice</i><i>(</i><i>&amp;</i>rd_buf<i>[</i>..n<i>]</i><i>)</i><i>;</i>
    }

    <i>info</i><i>!</i><i>(</i><i>&#34;===== Response body =====&#34;</i><i>)</i><i>;</i>
    <i>info</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, String::from_utf8_lossy<i>(</i>&amp;body_accum<i>)</i><i>)</i><i>;</i>

    Ok<i>(</i><i>(</i><i>)</i><i>)</i>
}
</pre></div><div>

<p>If you&#39;re following along at home and <code>root_store.add(&amp;Certificate(cert.0))?;</code>
returns an error, you might want to ignore that error instead.</p>
<p>Depending on your operating system, some certificate roots may be invalid and
can be safely ignored. That&#39;s what <a href="https://github.com/rustls/hyper-rustls/blob/634f0af61058c01e5f0478754fe6a855365b79d1/src/config.rs">hyper-rustls does</a>.</p>
</div>
<p>At this point, since we&#39;re pretty familiar with the protocol itself, I want to
take some time to talk about the buffering strategy.</p>
<p>We have <code>rd_buf</code>, 1KiB on the stack, that&#39;s used for making reads, which are
then copied into <code>accum</code>. That essentially adds a <code>memcpy</code> per read — we could
easily do better by growing <code>accum</code> and reading directly into it.</p>
<p>We could do even <em>better</em> if we were dealing with the headache that is
uninitialized data (it&#39;s left as an exercise to you, the reader). I took a quick
look and apparently by using <code>bytes::BytesMut</code> it&#39;s not as much of a headache
as I thought? Still, that&#39;s not what I&#39;m focused on in this article. You do it.</p>
<p>I don&#39;t think I&#39;ve said it explicitly, so here goes: we don&#39;t control the amount
of data we read off of a socket. We can limit it (here we read at most 1024
bytes), but we could be getting data one byte at a time. There is something
cleverer to be done parsing-wise, probably, but the solution here is to just 
accumulate the whole header (and some of the body, accidentally) into a single
buffer, and have a &#34;streaming parser&#34;.</p>
<p>The parser isn&#39;t as streaming as I&#39;d like it to, but it does the job: it
gracefully indicates whether the HTTP header is complete or not. And it gets
that property simply by using nom&#39;s <code>streaming</code> built-in parsers:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>// in `src/http11.rs`</i>

<i>use</i> nom<i>::</i>{
    bytes<i>::</i>streaming<i>::</i>{tag, take_until, take_while1},
    character<i>::</i>is_digit,
    combinator<i>::</i>{map_res, opt},
    sequence<i>::</i>{preceded, terminated},
    IResult,
}<i>;</i>

<i>#<i>[</i>derive<i>(</i>Debug<i>)</i><i>]</i></i>
<i>pub</i> <i>struct</i> <i>Response</i><i>&lt;</i><i>&#39;</i><i>a</i><i>&gt;</i> {
    <i>pub</i> <i>status</i>: <i>u16</i>,
    <i>pub</i> <i>status_text</i>: <i>&amp;</i><i>&#39;</i><i>a</i> <i>str</i>,

    <i>// header names/values could be non-UTF-8, but let&#39;s not care for this sample.</i>
    <i>// we are however careful not to use a HashMap, since headers can repeat.</i>
    <i>pub</i> <i>headers</i>: <i>Vec</i><i>&lt;</i><i>(</i><i>&amp;</i><i>&#39;</i><i>a</i> <i>str</i>, <i>&amp;</i><i>&#39;</i><i>a</i> <i>str</i><i>)</i><i>&gt;</i>,
}

<i>const</i> CRLF: <i>&amp;</i><i>str</i> = <i>&#34;\r\n&#34;</i><i>;</i>

<i>// Looks like `HTTP/1.1 200 OK\r\n` or `HTTP/1.1 404 Not Found\r\n`</i>
<i>pub</i> <i>fn</i> <i>response</i><i>(</i><i>i</i>: <i>&amp;</i><i>[</i><i>u8</i><i>]</i><i>)</i> -&gt; <i>IResult</i><i>&lt;</i><i>&amp;</i><i>[</i><i>u8</i><i>]</i>, <i>Response</i><i>&lt;</i><i>&#39;</i><i>_</i><i>&gt;</i><i>&gt;</i> {
    <i>let</i> <i>(</i>i, _<i>)</i> = <i>tag</i><i>(</i><i>&#34;HTTP/1.1 &#34;</i><i>)</i><i>(</i>i<i>)</i>?<i>;</i>

    <i>let</i> <i>(</i>i, status<i>)</i> = <i>terminated</i><i>(</i>u16_text, ws<i>)</i><i>(</i>i<i>)</i>?<i>;</i>
    <i>let</i> <i>(</i>i, status_text<i>)</i> =
        <i>map_res</i><i>(</i><i>terminated</i><i>(</i><i>take_until</i><i>(</i>CRLF<i>)</i>, <i>tag</i><i>(</i>CRLF<i>)</i><i>)</i>, std<i>::</i>str<i>::</i>from_utf8<i>)</i><i>(</i>i<i>)</i>?<i>;</i>

    <i>let</i> <i>mut</i> res = <i>Response</i> {
        status,
        status_text,
        <i>headers</i>: <i>Default</i><i>::</i><i>default</i><i>(</i><i>)</i>,
    }<i>;</i>

    <i>let</i> <i>mut</i> i = i<i>;</i>
    <i>loop</i> {
        <i>if</i> <i>let</i> <i>(</i>i, Some<i>(</i>_<i>)</i><i>)</i> = <i>opt</i><i>(</i><i>tag</i><i>(</i>CRLF<i>)</i><i>)</i><i>(</i>i<i>)</i>? {
            <i>// end of headers</i>
            <i>return</i> Ok<i>(</i><i>(</i>i, res<i>)</i><i>)</i><i>;</i>
        }

        <i>let</i> <i>(</i>i2, <i>(</i>name, value<i>)</i><i>)</i> = <i>header</i><i>(</i>i<i>)</i>?<i>;</i>
        res<i>.</i><i>headers</i><i>.</i><i>push</i><i>(</i><i>(</i>name, value<i>)</i><i>)</i><i>;</i>
        i = i2<i>;</i>
    }
}

<i>/// Parses a single header line</i>
<i>fn</i> <i>header</i><i>(</i><i>i</i>: <i>&amp;</i><i>[</i><i>u8</i><i>]</i><i>)</i> -&gt; <i>IResult</i><i>&lt;</i><i>&amp;</i><i>[</i><i>u8</i><i>]</i>, <i>(</i><i>&amp;</i><i>str</i>, <i>&amp;</i><i>str</i><i>)</i><i>&gt;</i> {
    <i>let</i> <i>(</i>i, name<i>)</i> = <i>map_res</i><i>(</i><i>terminated</i><i>(</i><i>take_until</i><i>(</i><i>&#34;:&#34;</i><i>)</i>, <i>tag</i><i>(</i><i>&#34;:&#34;</i><i>)</i><i>)</i>, std<i>::</i>str<i>::</i>from_utf8<i>)</i><i>(</i>i<i>)</i>?<i>;</i>
    <i>let</i> <i>(</i>i, value<i>)</i> = <i>map_res</i><i>(</i>
        <i>preceded</i><i>(</i>ws, <i>terminated</i><i>(</i><i>take_until</i><i>(</i>CRLF<i>)</i>, <i>tag</i><i>(</i>CRLF<i>)</i><i>)</i><i>)</i>,
        std<i>::</i>str<i>::</i>from_utf8,
    <i>)</i><i>(</i>i<i>)</i>?<i>;</i>

    Ok<i>(</i><i>(</i>i, <i>(</i>name, value<i>)</i><i>)</i><i>)</i>
}

<i>/// Parses whitespace (not including newlines)</i>
<i>fn</i> <i>ws</i><i>(</i><i>i</i>: <i>&amp;</i><i>[</i><i>u8</i><i>]</i><i>)</i> -&gt; <i>IResult</i><i>&lt;</i><i>&amp;</i><i>[</i><i>u8</i><i>]</i>, <i>(</i><i>)</i><i>&gt;</i> {
    <i>let</i> <i>(</i>i, _<i>)</i> = <i>take_while1</i><i>(</i>|c| c == <i>b&#39; &#39;</i><i>)</i><i>(</i>i<i>)</i>?<i>;</i>
    Ok<i>(</i><i>(</i>i, <i>(</i><i>)</i><i>)</i><i>)</i>
}

<i>/// Parses text as a u16</i>
<i>fn</i> <i>u16_text</i><i>(</i><i>i</i>: <i>&amp;</i><i>[</i><i>u8</i><i>]</i><i>)</i> -&gt; <i>IResult</i><i>&lt;</i><i>&amp;</i><i>[</i><i>u8</i><i>]</i>, <i>u16</i><i>&gt;</i> {
    <i>let</i> f = <i>take_while1</i><i>(</i>is_digit<i>)</i><i>;</i>
    <i>let</i> f = <i>map_res</i><i>(</i>f, std<i>::</i>str<i>::</i>from_utf8<i>)</i><i>;</i>
    <i>let</i> <i>mut</i> f = <i>map_res</i><i>(</i>f, |s| s<i>.</i><i>parse</i><i>(</i><i>)</i><i>)</i><i>;</i>
    <i>f</i><i>(</i>i<i>)</i>
}
</pre></div>
<p>Well, let&#39;s check that it actually works</p>
<div><p>Shell session</p><pre data-lang="shell">$ cargo run
   Compiling crash v0.1.0 (/home/amos/bearcove/crash)
    Finished dev [unoptimized + debuginfo] target(s) in 1.89s
     Running `target/debug/crash`
2022-10-09T16:56:38.643152Z  INFO crash: Establishing a TCP connection...
2022-10-09T16:56:38.789985Z  INFO crash: Setting up TLS root certificate store
2022-10-09T16:56:38.810252Z  INFO crash: Performing TLS handshake
2022-10-09T16:56:39.035877Z  INFO crash: Sending HTTP/1.1 request
2022-10-09T16:56:39.035973Z  INFO crash: Reading HTTP/1.1 response
2022-10-09T16:56:39.142733Z  INFO crash: Read 1024 bytes
2022-10-09T16:56:39.142865Z  INFO crash: Got HTTP/1.1 response: Response {
    status: 200,
    status_text: &#34;OK&#34;,
    headers: [
        (
            &#34;Age&#34;,
            &#34;515711&#34;,
        ),
        (
            &#34;Cache-Control&#34;,
            &#34;max-age=604800&#34;,
        ),
        (
            &#34;Content-Type&#34;,
            &#34;text/html; charset=UTF-8&#34;,
        ),
        (
            &#34;Date&#34;,
            &#34;Sun, 09 Oct 2022 16:56:39 GMT&#34;,
        ),
        (
            &#34;Etag&#34;,
            &#34;\&#34;3147526947+ident\&#34;&#34;,
        ),
        (
            &#34;Expires&#34;,
            &#34;Sun, 16 Oct 2022 16:56:39 GMT&#34;,
        ),
        (
            &#34;Last-Modified&#34;,
            &#34;Thu, 17 Oct 2019 07:18:26 GMT&#34;,
        ),
        (
            &#34;Server&#34;,
            &#34;ECS (dcb/7F83)&#34;,
        ),
        (
            &#34;Vary&#34;,
            &#34;Accept-Encoding&#34;,
        ),
        (
            &#34;X-Cache&#34;,
            &#34;HIT&#34;,
        ),
        (
            &#34;Content-Length&#34;,
            &#34;1256&#34;,
        ),
        (
            &#34;Connection&#34;,
            &#34;close&#34;,
        ),
    ],
}
2022-10-09T16:56:39.142994Z  INFO crash: Read 586 bytes
2022-10-09T16:56:39.143027Z  INFO crash: ===== Response body =====
2022-10-09T16:56:39.143053Z  INFO crash: &lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Example Domain&lt;/title&gt;
(cut)
</pre></div>
<p>And it does! How cool is that? We&#39;ve actually got a pretty decent start for a
real HTTP/1.1 implementation here. It supports a subset of the spec, needs
timeouts, and is a bit particular about what it&#39;ll accept, but I&#39;ve seen worse.</p>
<p>Before we move on, let&#39;s take a quick look at some numbers: I&#39;ve moved TLS
configuration out of the way (we&#39;re not measuring that), and added code like
this in various places, just to measure how long things take:</p>
<div><p>Rust code</p><pre data-lang="rust">    <i>info</i><i>!</i><i>(</i><i>&#34;Performing a DNS lookup...&#34;</i><i>)</i><i>;</i>
    <i>let</i> before = <i>Instant</i><i>::</i><i>now</i><i>(</i><i>)</i><i>;</i>
    <i>let</i> addr = <i>&#34;example.org:443&#34;</i>
        <i>.</i><i>to_socket_addrs</i><i>(</i><i>)</i>?
        <i>.</i><i>next</i><i>(</i><i>)</i>
        <i>.</i><i>ok_or_else</i><i>(</i>|| <i>eyre</i><i>!</i><i>(</i><i>&#34;Failed to resolve address for example.org:443&#34;</i><i>)</i><i>)</i>?<i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;{:?} DNS lookup&#34;</i>, before.elapsed<i>(</i><i>)</i><i>)</i><i>;</i>

    <i>info</i><i>!</i><i>(</i><i>&#34;Establishing a TCP connection...&#34;</i><i>)</i><i>;</i>
    <i>let</i> before = <i>Instant</i><i>::</i><i>now</i><i>(</i><i>)</i><i>;</i>
    <i>let</i> stream = <i>TcpStream</i><i>::</i><i>connect</i><i>(</i>addr<i>)</i><i>.</i>await?<i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;{:?} TCP connect&#34;</i>, before.elapsed<i>(</i><i>)</i><i>)</i><i>;</i>
</pre></div><div>

<p>Oh also, yeah, for measuring purposes, I&#39;ve separated DNS lookup from the
actual TCP handshake. You can do better than that with a crate like
<a href="https://lib.rs/crates/trust-dns-resolver">trust-dns-resolver</a>, but that&#39;s out
of scope for this article.</p>
</div>
<p>Let&#39;s see what we got!</p>
<div><p>Shell session</p><pre data-lang="shell">$ for i in $(seq 1 3); do echo &#34;-----------------------&#34;; RUST_LOG=warn cargo run --quiet; done
-----------------------
12.70664ms DNS lookup
88.916729ms TCP connect
242.988959ms TLS handshake
49.64µs Request send
212.122418ms Response header read
15.93µs Response body read
-----------------------
47.281324ms DNS lookup
125.635306ms TCP connect
199.093467ms TLS handshake
27.21µs Request send
289.471602ms Response header read
20.93µs Response body read
-----------------------
50.376377ms DNS lookup
92.435129ms TCP connect
288.879476ms TLS handshake
52.74µs Request send
200.708618ms Response header read
18.4µs Response body read
</pre></div>
<p>What conclusions can we draw from these numbers?</p>
<div>

<p>None. All benchmarks are lies. There&#39;s only sadness ahead.</p>
</div>
<p>Conclusion number 1: something&#39;s up with my DNS setup. I would expect this lookup
to be cached. This is thankfully out of scope.</p>
<p>Conclusion number 2: request send is in the microseconds <em>because the kernel
does its own buffering</em>. This is how long it takes to make a syscall, not how
long it takes to actually reach the example.org server.</p>
<p>Conclusion number 3: the response body read is in the microseconds because the
body is small, and it fits in the read we already did for the request header.
If we did a request with a larger body (try it!), the numbers would look quite
different.</p>
<p>But also... those numbers are pretty bad, right? </p>
<p>There&#39;s a couple things we can do here: we can fix my DNS setup (for the time
being), we can switch to a release build (<code>cargo run --release</code>), we can use a
site other than <code>example.org</code> which <em>should</em> be closer / more reliably
low-latency, but even then:</p>
<div><p>Shell session</p><pre data-lang="shell">$ for i in $(seq 1 3); do echo &#34;-----------------------&#34;; RUST_LOG=warn cargo run --release --quiet; done
-----------------------
390.53µs DNS lookup
12.203892ms TCP connect
14.378385ms TLS handshake
2.93µs Request send
116.984718ms Response header read
510ns Response body read
-----------------------
375.14µs DNS lookup
18.963162ms TCP connect
13.734487ms TLS handshake
3.79µs Request send
123.921931ms Response header read
400ns Response body read
-----------------------
382.33µs DNS lookup
10.026293ms TCP connect
15.45463ms TLS handshake
3.47µs Request send
169.120957ms Response header read
460ns Response body read
</pre></div>
<p>There&#39;s one last thing we forgot to do: <a href="https://docs.rs/tokio/latest/tokio/net/struct.TcpStream.html#method.set_nodelay">set
<code>TCP_NODELAY</code></a>,
which disables <a href="https://en.wikipedia.org/wiki/Nagle%27s_algorithm">Nagle&#39;s algorithm</a>.</p>
<p>Previously, the TCP stack would wait until we have &#34;enough data&#34;, or &#34;some
amount of time has passed&#34;, before actually sending the data to the server. With
<code>TCP_NODELAY</code> set, our numbers are looking better:</p>
<div><p>Shell session</p><pre data-lang="shell">$ for i in $(seq 1 3); do echo &#34;-----------------------&#34;; RUST_LOG=warn cargo run --release --quiet; done
-----------------------
371.14µs DNS lookup
21.606747ms TCP connect
14.028551ms TLS handshake
22.77µs Request send
18.990437ms Response header read
370ns Response body read
-----------------------
396.29µs DNS lookup
33.659129ms TCP connect
14.904545ms TLS handshake
17.32µs Request send
19.642322ms Response header read
360ns Response body read
-----------------------
384.77µs DNS lookup
23.117568ms TCP connect
19.567509ms TLS handshake
29.81µs Request send
19.120578ms Response header read
320ns Response body read
</pre></div>
<p>These look a lot better!</p>
<p>But you can still see how one would want to <em>not</em> use <code>connection: close</code>, and
instead use persistent HTTP connections instead.</p>
<div>

<p>This is not the same as <a href="https://en.wikipedia.org/wiki/HTTP_pipelining">HTTP
pipelining</a>, which I will not
discuss, out of spite.</p>
</div>
<p>And just like that, we&#39;re done with HTTP/1.1. There&#39;s a lot more to it, but I
feel like we have enough baggage to move on to the next major version of the
protocol: HTTP/2.</p>

                        <h2>
                            <a id="making-http-2-requests-with-hyper" href="#making-http-2-requests-with-hyper">
                                Making HTTP/2 requests with <code>hyper</code>
                            </a>
                        </h2>
                        
<p>There&#39;s two ways I write articles: either I write about something I already know
and I have to feign ignorance, and make up mistakes for didactic purposes. Or
I write about something I&#39;ve actually never done before, and the article acts as
structured notes on what I learn.</p>
<p>We&#39;ve just moved decisively from the former into the latter.</p>
<p>I have been doing HTTP/2, a lot, but I was shielded from the truth by
<a href="https://lib.rs/crates/hyper">hyper</a>.</p>
<p>So, let&#39;s do that first. We&#39;re not going to go through <code>reqwest</code> first - as
we&#39;ve seen, its higher-level niceties don&#39;t buy us much <em>in this particular
scenario</em>.</p>
<div><p>Shell session</p><pre data-lang="shell">$ cargo rm tokio-rustls nom
$ cargo add hyper -F client,http1,http2,tcp
$ cargo add hyper-rustls -F http2
</pre></div>
<p>And, well, let&#39;s get started!</p>
<p>Things look much like our HTTP/1.1 hyper example, with all the nice things we&#39;ve
added on top:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>use</i> std<i>::</i>{str<i>::</i>FromStr, sync<i>::</i>Arc}<i>;</i>

<i>use</i> hyper<i>::</i>{Client, Request}<i>;</i>
<i>use</i> rustls<i>::</i>{Certificate, ClientConfig, KeyLogFile, RootCertStore}<i>;</i>
<i>use</i> tracing<i>::</i>info<i>;</i>
<i>use</i> tracing_subscriber<i>::</i>{filter<i>::</i>targets<i>::</i>Targets, layer<i>::</i>SubscriberExt, util<i>::</i>SubscriberInitExt}<i>;</i>

<i>#<i>[</i>tokio<i>::</i>main<i>]</i></i>
async <i>fn</i> <i>main</i><i>(</i><i>)</i> -&gt; color_eyre<i>::</i><i>Result</i><i>&lt;</i><i>(</i><i>)</i><i>&gt;</i> {
    color_eyre<i>::</i><i>install</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>

    <i>let</i> filter_layer =
        <i>Targets</i><i>::</i><i>from_str</i><i>(</i>std<i>::</i>env<i>::</i><i>var</i><i>(</i><i>&#34;RUST_LOG&#34;</i><i>)</i><i>.</i><i>as_deref</i><i>(</i><i>)</i><i>.</i><i>unwrap_or</i><i>(</i><i>&#34;info&#34;</i><i>)</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
    <i>let</i> format_layer = tracing_subscriber<i>::</i>fmt<i>::</i><i>layer</i><i>(</i><i>)</i><i>;</i>
    tracing_subscriber<i>::</i><i>registry</i><i>(</i><i>)</i>
        <i>.</i><i>with</i><i>(</i>filter_layer<i>)</i>
        <i>.</i><i>with</i><i>(</i>format_layer<i>)</i>
        <i>.</i><i>init</i><i>(</i><i>)</i><i>;</i>

    <i>info</i><i>!</i><i>(</i><i>&#34;Setting up TLS root certificate store&#34;</i><i>)</i><i>;</i>
    <i>let</i> <i>mut</i> root_store = <i>RootCertStore</i><i>::</i><i>empty</i><i>(</i><i>)</i><i>;</i>
    <i>for</i> cert <i>in</i> rustls_native_certs<i>::</i><i>load_native_certs</i><i>(</i><i>)</i>? {
        root_store<i>.</i><i>add</i><i>(</i><i>&amp;</i>Certificate<i>(</i>cert<i>.</i><i>0</i><i>)</i><i>)</i>?<i>;</i>
    }

    <i>let</i> <i>mut</i> client_config = <i>ClientConfig</i><i>::</i><i>builder</i><i>(</i><i>)</i>
        <i>.</i><i>with_safe_defaults</i><i>(</i><i>)</i>
        <i>.</i><i>with_root_certificates</i><i>(</i>root_store<i>)</i>
        <i>.</i><i>with_no_client_auth</i><i>(</i><i>)</i><i>;</i>
    client_config<i>.</i><i>key_log</i> = <i>Arc</i><i>::</i><i>new</i><i>(</i><i>KeyLogFile</i><i>::</i><i>new</i><i>(</i><i>)</i><i>)</i><i>;</i>

    <i>let</i> connector = hyper_rustls<i>::</i><i>HttpsConnectorBuilder</i><i>::</i><i>new</i><i>(</i><i>)</i>
        <i>.</i><i>with_tls_config</i><i>(</i>client_config<i>)</i>
        <i>.</i><i>https_only</i><i>(</i><i>)</i>
        <i>.</i><i>enable_http2</i><i>(</i><i>)</i>
        <i>.</i><i>build</i><i>(</i><i>)</i><i>;</i>

    <i>let</i> client = <i>Client</i><i>::</i><i>builder</i><i>(</i><i>)</i>
        <i>.</i><i>http2_only</i><i>(</i><i>true</i><i>)</i>
        <i>.</i><i>build</i><i>::</i><i>&lt;</i><i>_</i>, hyper<i>::</i><i>Body</i><i>&gt;</i><i>(</i>connector<i>)</i><i>;</i>

    <i>let</i> req = <i>Request</i><i>::</i><i>get</i><i>(</i><i>&#34;https://example.org&#34;</i><i>)</i><i>.</i><i>body</i><i>(</i>hyper<i>::</i><i>Body</i><i>::</i><i>empty</i><i>(</i><i>)</i><i>)</i>?<i>;</i>
    <i>info</i><i>!</i><i>(</i><i>&#34;Performing HTTP/2 request...&#34;</i><i>)</i><i>;</i>
    <i>let</i> res = client<i>.</i><i>request</i><i>(</i>req<i>)</i><i>.</i>await?<i>;</i>
    <i>info</i><i>!</i><i>(</i><i>&#34;Response header: {:?}&#34;</i>, res<i>)</i><i>;</i>

    <i>info</i><i>!</i><i>(</i><i>&#34;Reading response body...&#34;</i><i>)</i><i>;</i>
    <i>let</i> body = hyper<i>::</i>body<i>::</i><i>to_bytes</i><i>(</i>res<i>.</i><i>into_body</i><i>(</i><i>)</i><i>)</i><i>.</i>await?<i>;</i>
    <i>info</i><i>!</i><i>(</i><i>&#34;Response body is {} bytes&#34;</i>, body.len<i>(</i><i>)</i><i>)</i><i>;</i>

    Ok<i>(</i><i>(</i><i>)</i><i>)</i>
}
</pre></div><div>

<p>Phew, some bit of luck that <code>example.org</code> supports HTTP/2, eh? Did you plan
that one out?</p>
</div>
<p>Well.. does it? Let&#39;s do some packet capture to find out...</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/the-http-crash-course-nobody-asked-for/assets/wireshark-hyper-http2.672a415c5ce795f5.avif"/>
                <source type="image/webp" srcset="/content/articles/the-http-crash-course-nobody-asked-for/assets/wireshark-hyper-http2.e7261a8425c8cead.webp"/>
                <img loading="lazy" src="https://hdoro.dev/content/articles/the-http-crash-course-nobody-asked-for/assets/wireshark-hyper-http2.227ac16fb3a79ba0.jpg" title="A wireshark capture of an HTTP2 exchange with example.org" alt="A wireshark capture of an HTTP2 exchange with example.org"/>
            </picture>
            
<p>Ah, it sure does! I can see HTTP2 as the decoded protocol, so it must be HTTP2.</p>
<p>We can see that TLS is still used, and it&#39;s still done over TCP. That&#39;s good!
That&#39;s familiar.</p>
<div>

<p>Good thing we have a nice higher-level abstraction to protect us from the
implementation details!</p>
</div>
<p>Not for long, cool bear... not for long.</p>

                        <h2>
                            <a id="making-http-2-requests-with-h2" href="#making-http-2-requests-with-h2">
                                Making HTTP/2 requests with <code>h2</code>
                            </a>
                        </h2>
                        
<p>See, the thing is, <em>most</em> of the things that are interesting about HTTP/2 are
not implemented in the <code>hyper</code> crate, they&#39;re implemented in the
<a href="https://lib.rs/crates/h2">h2</a> crate.</p>
<p>And moving just one level of abstraction lower lets us peer into some of the
details of HTTP/2, as a softer introduction of what&#39;s to come.</p>
<div><p>Shell session</p><pre data-lang="shell">$ cargo rm hyper-rustls hyper
(cut)
$ cargo add h2 tokio-rustls
(cut)
</pre></div>
<p>Everything up until the TLS connection stage is the same. We can pass our &#34;TLS
socket&#34; to the <code>h2</code> crate directly.</p>
<div><p>Rust code</p><pre data-lang="rust"><i>use</i> std<i>::</i>{net<i>::</i>ToSocketAddrs, str<i>::</i>FromStr, sync<i>::</i>Arc}<i>;</i>

<i>use</i> color_eyre<i>::</i>eyre<i>::</i>eyre<i>;</i>
<i>use</i> rustls<i>::</i>{Certificate, ClientConfig, KeyLogFile, RootCertStore}<i>;</i>
<i>use</i> tokio<i>::</i>net<i>::</i>TcpStream<i>;</i>
<i>use</i> tracing<i>::</i>info<i>;</i>
<i>use</i> tracing_subscriber<i>::</i>{filter<i>::</i>targets<i>::</i>Targets, layer<i>::</i>SubscriberExt, util<i>::</i>SubscriberInitExt}<i>;</i>

<i>#<i>[</i>tokio<i>::</i>main<i>]</i></i>
async <i>fn</i> <i>main</i><i>(</i><i>)</i> -&gt; color_eyre<i>::</i><i>Result</i><i>&lt;</i><i>(</i><i>)</i><i>&gt;</i> {
    color_eyre<i>::</i><i>install</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>

    <i>let</i> filter_layer =
        <i>Targets</i><i>::</i><i>from_str</i><i>(</i>std<i>::</i>env<i>::</i><i>var</i><i>(</i><i>&#34;RUST_LOG&#34;</i><i>)</i><i>.</i><i>as_deref</i><i>(</i><i>)</i><i>.</i><i>unwrap_or</i><i>(</i><i>&#34;info&#34;</i><i>)</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
    <i>let</i> format_layer = tracing_subscriber<i>::</i>fmt<i>::</i><i>layer</i><i>(</i><i>)</i><i>;</i>
    tracing_subscriber<i>::</i><i>registry</i><i>(</i><i>)</i>
        <i>.</i><i>with</i><i>(</i>filter_layer<i>)</i>
        <i>.</i><i>with</i><i>(</i>format_layer<i>)</i>
        <i>.</i><i>init</i><i>(</i><i>)</i><i>;</i>

    <i>info</i><i>!</i><i>(</i><i>&#34;Setting up TLS&#34;</i><i>)</i><i>;</i>
    <i>let</i> <i>mut</i> root_store = <i>RootCertStore</i><i>::</i><i>empty</i><i>(</i><i>)</i><i>;</i>
    <i>for</i> cert <i>in</i> rustls_native_certs<i>::</i><i>load_native_certs</i><i>(</i><i>)</i>? {
        root_store<i>.</i><i>add</i><i>(</i><i>&amp;</i>Certificate<i>(</i>cert<i>.</i><i>0</i><i>)</i><i>)</i>?<i>;</i>
    }

    <i>let</i> <i>mut</i> client_config = <i>ClientConfig</i><i>::</i><i>builder</i><i>(</i><i>)</i>
        <i>.</i><i>with_safe_defaults</i><i>(</i><i>)</i>
        <i>.</i><i>with_root_certificates</i><i>(</i>root_store<i>)</i>
        <i>.</i><i>with_no_client_auth</i><i>(</i><i>)</i><i>;</i>
    client_config<i>.</i><i>key_log</i> = <i>Arc</i><i>::</i><i>new</i><i>(</i><i>KeyLogFile</i><i>::</i><i>new</i><i>(</i><i>)</i><i>)</i><i>;</i>

    <i>let</i> connector = tokio_rustls<i>::</i><i>TlsConnector</i><i>::</i><i>from</i><i>(</i><i>Arc</i><i>::</i><i>new</i><i>(</i>client_config<i>)</i><i>)</i><i>;</i>

    <i>let</i> addr = <i>&#34;example.org:443&#34;</i>
        <i>.</i><i>to_socket_addrs</i><i>(</i><i>)</i>?
        <i>.</i><i>next</i><i>(</i><i>)</i>
        <i>.</i><i>ok_or_else</i><i>(</i>|| <i>eyre</i><i>!</i><i>(</i><i>&#34;Failed to resolve address for example.org:443&#34;</i><i>)</i><i>)</i>?<i>;</i>

    <i>info</i><i>!</i><i>(</i><i>&#34;Establishing TCP connection...&#34;</i><i>)</i><i>;</i>
    <i>let</i> stream = <i>TcpStream</i><i>::</i><i>connect</i><i>(</i>addr<i>)</i><i>.</i>await?<i>;</i>

    <i>info</i><i>!</i><i>(</i><i>&#34;Establishing TLS session...&#34;</i><i>)</i><i>;</i>
    <i>let</i> stream = connector<i>.</i><i>connect</i><i>(</i><i>&#34;example.org&#34;</i><i>.</i><i>try_into</i><i>(</i><i>)</i>?, stream<i>)</i><i>.</i>await?<i>;</i>

    <i>info</i><i>!</i><i>(</i><i>&#34;Establishing HTTP/2 connection...&#34;</i><i>)</i><i>;</i>
    <i>let</i> <i>(</i>_send_req, conn<i>)</i> = h2<i>::</i>client<i>::</i><i>handshake</i><i>(</i>stream<i>)</i><i>.</i>await?<i>;</i>
    tokio<i>::</i><i>spawn</i><i>(</i>conn<i>)</i><i>;</i>

    <i>info</i><i>!</i><i>(</i><i>&#34;Now what?&#34;</i><i>)</i><i>;</i>

    Ok<i>(</i><i>(</i><i>)</i><i>)</i>
}
</pre></div>
<p>The API here is interesting - we get a <code>SendRequest</code> handle, and a <code>Connection</code>.
The <code>Connection</code> bit implements <code>Future</code> and we have to poll it for the other
handles to make any progress — we achieve that here by simply spawning it onto
the tokio runtime (&#34;starting a background task&#34;).</p>
<p>And now, we can use the <code>SendRequest</code> bit to... send a request! That&#39;s where we
find out about a common crate between <code>hyper</code> and <code>h2</code>, the
<a href="https://lib.rs/crates/http">http</a> crate.</p>
<div><p>Shell session</p><pre data-lang="shell">$ cargo add http
    Updating crates.io index
      Adding http v0.2.8 to dependencies
</pre></div>
<p>And that&#39;s very interesting from a design standpoint. For example, there&#39;s
nothing preventing us from shoving a <code>transfer-encoding</code> header, or a
<code>connection</code> header in there, even though that makes no sense in http/2.</p>
<p>But, <a href="https://docs.rs/http/latest/http/header/struct.HeaderMap.html">HeaderMap</a>
vaguely behaves like a hash map, and so there&#39;s only <em>so much</em> correctness
that is being enforced, regardless of <a href="https://hdoro.dev/articles/aiming-for-correctness-with-types">what I think</a>.</p>
<p>Anyway, let&#39;s send a request!</p>
<div><p>Rust code</p><pre data-lang="rust">    <i>// (rest of `main` omitted)</i>

    <i>info</i><i>!</i><i>(</i><i>&#34;Establishing TLS session...&#34;</i><i>)</i><i>;</i>
    <i>let</i> stream = connector<i>.</i><i>connect</i><i>(</i><i>&#34;example.org&#34;</i><i>.</i><i>try_into</i><i>(</i><i>)</i>?, stream<i>)</i><i>.</i>await?<i>;</i>

    <i>info</i><i>!</i><i>(</i><i>&#34;Establishing HTTP/2 connection...&#34;</i><i>)</i><i>;</i>
    <i>let</i> <i>(</i><i>mut</i> send_req, conn<i>)</i> = h2<i>::</i>client<i>::</i><i>handshake</i><i>(</i>stream<i>)</i><i>.</i>await?<i>;</i>
    tokio<i>::</i><i>spawn</i><i>(</i>conn<i>)</i><i>;</i>

    <i>info</i><i>!</i><i>(</i><i>&#34;Sending HTTP/2 request...&#34;</i><i>)</i><i>;</i>
    <i>let</i> req = http<i>::</i><i>Request</i><i>::</i><i>builder</i><i>(</i><i>)</i>
        <i>.</i><i>uri</i><i>(</i><i>&#34;https://example.org/&#34;</i><i>)</i>
        <i>.</i><i>body</i><i>(</i><i>(</i><i>)</i><i>)</i>?<i>;</i>
    <i>let</i> <i>(</i>res, _req_body<i>)</i> = send_req<i>.</i><i>send_request</i><i>(</i>req, <i>true</i><i>)</i>?<i>;</i>
    <i>let</i> res = res<i>.</i>await?<i>;</i>
    <i>info</i><i>!</i><i>(</i><i>&#34;Got HTTP/2 response {res:?}&#34;</i><i>)</i><i>;</i>

    <i>let</i> <i>mut</i> body = res<i>.</i><i>into_body</i><i>(</i><i>)</i><i>;</i>
    <i>let</i> <i>mut</i> body_len = <i>0</i><i>;</i>
    <i>while</i> <i>let</i> Some<i>(</i>chunk<i>)</i> = body<i>.</i><i>data</i><i>(</i><i>)</i><i>.</i>await<i>.</i><i>transpose</i><i>(</i><i>)</i>? {
        body_len += chunk<i>.</i><i>len</i><i>(</i><i>)</i><i>;</i>
    }
    <i>info</i><i>!</i><i>(</i><i>&#34;Got HTTP/2 response body of {body_len} bytes&#34;</i><i>)</i><i>;</i>
</pre></div>
<p>Just as before, this should pretty much work out of the box:</p>
<div><p>Shell session</p><pre data-lang="shell">$ cargo run
   Compiling crash v0.1.0 (/home/amos/bearcove/crash)
    Finished dev [unoptimized + debuginfo] target(s) in 3.01s
     Running `target/debug/crash`
2022-10-09T18:48:20.367727Z  INFO crash: Setting up TLS
2022-10-09T18:48:20.417851Z  INFO crash: Establishing TCP connection...
2022-10-09T18:48:20.549700Z  INFO crash: Establishing TLS session...
2022-10-09T18:48:20.730001Z  INFO crash: Establishing HTTP/2 connection...
2022-10-09T18:48:20.730173Z  INFO crash: Sending HTTP/2 request...
Error: 
   0: connection error detected: frame with invalid size

Location:
   src/main.rs:55

Backtrace omitted. Run with RUST_BACKTRACE=1 environment variable to display it.
Run with RUST_BACKTRACE=full to include source snippets.
</pre></div>
<p>Oh.</p>

<p>Mhh.</p>
<div>

<p>Say amos, you&#39;re still connecting to port 443, right?</p>
</div>
<p>Well yeah! It&#39;s &#34;just https&#34;.</p>
<div>

<p>And how does the server know you want to speak HTTP2, exactly?</p>
</div>
<p>Ohhhh right. So there&#39;s essentially two ways. One is the <code>Upgrade</code> header,
that goes like so:</p>
<div><pre data-lang="">&gt; OPTIONS / HTTP/1.1
&gt; Host: server.example.org
&gt; Connection: Upgrade, HTTP2-Settings
&gt; Upgrade: h2c
&gt; HTTP2-Settings: &lt;base64url encoding of HTTP/2 SETTINGS payload&gt;

&lt; HTTP/1.1 101 Switching Protocols
&lt; Connection: Upgrade
&lt; Upgrade: h2c

(HTTP/2 traffic ensues)
</pre></div>
<p>This exchange is adapted from <a href="https://www.rfc-editor.org/rfc/rfc7540">RFC
7540</a>.  You can also user other verbs,
making <em>one</em> HTTP/1.1 request, and using HTTP/2 for subsequence requests, but as
the RFC notes, a large initial request can block the use of the connection for
further requests.</p>
<p>But that&#39;s for plaintext http2, known affectionately as <code>h2c</code> (&#34;c&#34; for
&#34;cleartext&#34;, same meaning as &#34;plaintext&#34;).</p>
<p>We&#39;re already doing TLS, and TLS lets us do ALPN, which stands for
<a href="https://www.rfc-editor.org/rfc/rfc7301">Application-Layer Protocol Negotiation</a>:
we can tell the server we&#39;re willing to speak h2 if they are, just like we use
a TLS 1.2 extension to say we <a href="https://www.youtube.com/watch?v=YHIiVsFybLA">can do TLS 1.3 if they&#39;re game</a>.</p>
<p>All we&#39;re really missing is this line:</p>
<div><p>Rust code</p><pre data-lang="rust">    client_config<i>.</i><i>alpn_protocols</i> = <i>vec</i><i>!</i><i>[</i><i>b&#34;h2&#34;</i>.to_vec<i>(</i><i>)</i><i>]</i><i>;</i>
</pre></div><div>

<p>In the real world, we&#39;d probably want to pass <em>both</em> <code>h2</code> and <code>http1.1</code>, so we
could fall back to HTTP 1.1 if we wanted, but here we&#39;re only about HTTP/2.</p>
</div>
<p>And it works:</p>
<div><p>Shell session</p><pre data-lang="shell">$ cargo run --quiet
2022-10-17T19:43:43.684054Z  INFO crash: Setting up TLS
2022-10-17T19:43:43.697403Z  INFO crash: Establishing TCP connection...
2022-10-17T19:43:43.780303Z  INFO crash: Establishing TLS session...
2022-10-17T19:43:43.949577Z  INFO crash: Establishing HTTP/2 connection...
2022-10-17T19:43:43.949817Z  INFO crash: Sending HTTP/2 request...
2022-10-17T19:43:44.116467Z  INFO crash: Got HTTP/2 response Response { status: 200, version: HTTP/2.0, headers: {&#34;age&#34;: &#34;560541&#34;, &#34;cache-control&#34;: &#34;max-age=604800&#34;, &#34;content-type&#34;: &#34;text/html; charset=UTF-8&#34;, &#34;date&#34;: &#34;Mon, 17 Oct 2022 19:43:44 GMT&#34;, &#34;etag&#34;: &#34;\&#34;3147526947+ident\&#34;&#34;, &#34;expires&#34;: &#34;Mon, 24 Oct 2022 19:43:44 GMT&#34;, &#34;last-modified&#34;: &#34;Thu, 17 Oct 2019 07:18:26 GMT&#34;, &#34;server&#34;: &#34;ECS (dcb/7EA3)&#34;, &#34;vary&#34;: &#34;Accept-Encoding&#34;, &#34;x-cache&#34;: &#34;HIT&#34;, &#34;content-length&#34;: &#34;1256&#34;}, body: RecvStream { inner: FlowControl { inner: OpaqueStreamRef { stream_id: StreamId(1), ref_count: 2 } } } }
2022-10-17T19:43:44.116612Z  INFO crash: Got HTTP/2 response body of 1256 bytes
</pre></div>
<p>The <code>Debug</code> implementation of the body here is interesting: it shows a
<code>FlowControl</code> struct, which has an <code>OpaqueStreamRef</code>. This is <em>one</em> of the big
differences between HTTP/1.1 and HTTP/2. Although they both build upon TCP,
HTTP/2 brings stream multiplexing.</p>
<p>We can treat our program like a black box and poke at it with strace to verify
that this is the case:</p>
<div><p>Rust code</p><pre data-lang="rust">    <i>// omitted: TLS setup, etc.</i>
    <i>info</i><i>!</i><i>(</i><i>&#34;Establishing HTTP/2 connection...&#34;</i><i>)</i><i>;</i>
    <i>let</i> <i>(</i><i>mut</i> send_req, conn<i>)</i> = h2<i>::</i>client<i>::</i><i>handshake</i><i>(</i>stream<i>)</i><i>.</i>await?<i>;</i>
    tokio<i>::</i><i>spawn</i><i>(</i>conn<i>)</i><i>;</i>

    <i>let</i> <i>(</i>tx, <i>mut</i> rx<i>)</i> = tokio<i>::</i>sync<i>::</i>mpsc<i>::</i><i>channel</i><i>::</i><i>&lt;</i>color_eyre<i>::</i><i>Result</i><i>&lt;</i><i>(</i><i>)</i><i>&gt;</i><i>&gt;</i><i>(</i><i>1</i><i>)</i><i>;</i>
    <i>for</i> i <i>in</i> <i>0</i>..<i>5</i> {
        <i>let</i> req = http<i>::</i><i>Request</i><i>::</i><i>builder</i><i>(</i><i>)</i>
            <i>.</i><i>uri</i><i>(</i><i>&#34;https://example.org/&#34;</i><i>)</i>
            <i>.</i><i>body</i><i>(</i><i>(</i><i>)</i><i>)</i>?<i>;</i>
        <i>let</i> <i>(</i>res, _req_body<i>)</i> = send_req<i>.</i><i>send_request</i><i>(</i>req, <i>true</i><i>)</i>?<i>;</i>

        <i>let</i> fut = async <i>move</i> {
            <i>let</i> <i>mut</i> body = res<i>.</i>await?<i>.</i><i>into_body</i><i>(</i><i>)</i><i>;</i>
            <i>info</i><i>!</i><i>(</i><i>&#34;{i}: received headers&#34;</i><i>)</i><i>;</i>
            <i>let</i> <i>mut</i> body_len = <i>0</i><i>;</i>
            <i>while</i> <i>let</i> Some<i>(</i>chunk<i>)</i> = body<i>.</i><i>data</i><i>(</i><i>)</i><i>.</i>await<i>.</i><i>transpose</i><i>(</i><i>)</i>? {
                body_len += chunk<i>.</i><i>len</i><i>(</i><i>)</i><i>;</i>
            }
            <i>info</i><i>!</i><i>(</i><i>&#34;{i}: received body ({body_len} bytes)&#34;</i><i>)</i><i>;</i>
            Ok<i>::</i><i>&lt;</i><i>_</i>, color_eyre<i>::</i><i>Report</i><i>&gt;</i><i>(</i><i>(</i><i>)</i><i>)</i>
        }<i>;</i>

        <i>let</i> tx = tx<i>.</i><i>clone</i><i>(</i><i>)</i><i>;</i>
        tokio<i>::</i><i>spawn</i><i>(</i>async <i>move</i> { _ = tx<i>.</i><i>send</i><i>(</i>fut<i>.</i>await<i>)</i><i>.</i>await }<i>)</i><i>;</i>
    }

    <i>drop</i><i>(</i>tx<i>)</i><i>;</i>
    <i>while</i> <i>let</i> Some<i>(</i>res<i>)</i> = rx<i>.</i><i>recv</i><i>(</i><i>)</i><i>.</i>await {
        res?<i>;</i>
    }
</pre></div><div><p>Shell session</p><pre data-lang="shell">$ cargo build --quiet &amp;&amp; strace -e connect ./target/debug/crash
2022-10-17T19:57:33.515259Z  INFO crash: Setting up TLS
2022-10-17T19:57:33.528504Z  INFO crash: Performing DNS lookup
connect(9, {sa_family=AF_UNIX, sun_path=&#34;/var/run/nscd/socket&#34;}, 110) = -1 ENOENT (No such file or directory)
connect(9, {sa_family=AF_UNIX, sun_path=&#34;/var/run/nscd/socket&#34;}, 110) = -1 ENOENT (No such file or directory)
connect(9, {sa_family=AF_INET6, sin6_port=htons(53), sin6_flowinfo=htonl(0), inet_pton(AF_INET6, &#34;fdaa::3&#34;, &amp;sin6_addr), sin6_scope_id=0}, 28) = 0
connect(9, {sa_family=AF_INET6, sin6_port=htons(0), sin6_flowinfo=htonl(0), inet_pton(AF_INET6, &#34;2606:2800:220:1:248:1893:25c8:1946&#34;, &amp;sin6_addr), sin6_scope_id=0}, 28) = 0
connect(9, {sa_family=AF_UNSPEC, sa_data=&#34;\0\0\0\0\0\0\0\0\0\0\0\0\0\0&#34;}, 16) = 0
connect(9, {sa_family=AF_INET, sin_port=htons(0), sin_addr=inet_addr(&#34;93.184.216.34&#34;)}, 16) = 0
amos@e7840d9c290d83 ~/bearcove/crash main*
❯ cargo build --quiet &amp;&amp; strace -e connect ./target/debug/crash
2022-10-17T19:58:14.593076Z  INFO crash: Setting up TLS
2022-10-17T19:58:14.610245Z  INFO crash: Performing DNS lookup
connect(9, {sa_family=AF_UNIX, sun_path=&#34;/var/run/nscd/socket&#34;}, 110) = -1 ENOENT (No such file or directory)
connect(9, {sa_family=AF_UNIX, sun_path=&#34;/var/run/nscd/socket&#34;}, 110) = -1 ENOENT (No such file or directory)
connect(9, {sa_family=AF_INET6, sin6_port=htons(53), sin6_flowinfo=htonl(0), inet_pton(AF_INET6, &#34;fdaa::3&#34;, &amp;sin6_addr), sin6_scope_id=0}, 28) = 0
connect(9, {sa_family=AF_INET6, sin6_port=htons(0), sin6_flowinfo=htonl(0), inet_pton(AF_INET6, &#34;2606:2800:220:1:248:1893:25c8:1946&#34;, &amp;sin6_addr), sin6_scope_id=0}, 28) = 0
connect(9, {sa_family=AF_UNSPEC, sa_data=&#34;\0\0\0\0\0\0\0\0\0\0\0\0\0\0&#34;}, 16) = 0
connect(9, {sa_family=AF_INET, sin_port=htons(0), sin_addr=inet_addr(&#34;93.184.216.34&#34;)}, 16) = 0
2022-10-17T19:58:14.612669Z  INFO crash: Establishing TCP connection...
connect(9, {sa_family=AF_INET6, sin6_port=htons(443), sin6_flowinfo=htonl(0), inet_pton(AF_INET6, &#34;2606:2800:220:1:248:1893:25c8:1946&#34;, &amp;sin6_addr), sin6_scope_id=0}, 28) = -1 EINPROGRESS (Operation now in progress)
2022-10-17T19:58:14.695729Z  INFO crash: Establishing TLS session...
2022-10-17T19:58:14.865204Z  INFO crash: Establishing HTTP/2 connection...
2022-10-17T19:58:15.032358Z  INFO crash: 0: received headers
2022-10-17T19:58:15.032444Z  INFO crash: 0: received body (1256 bytes)
2022-10-17T19:58:15.033636Z  INFO crash: 2: received headers
2022-10-17T19:58:15.033714Z  INFO crash: 2: received body (1256 bytes)
2022-10-17T19:58:15.033830Z  INFO crash: 3: received headers
2022-10-17T19:58:15.033873Z  INFO crash: 3: received body (1256 bytes)
2022-10-17T19:58:15.033924Z  INFO crash: 4: received headers
2022-10-17T19:58:15.033857Z  INFO crash: 1: received headers
2022-10-17T19:58:15.033988Z  INFO crash: 1: received body (1256 bytes)
2022-10-17T19:58:15.033998Z  INFO crash: 4: received body (1256 bytes)
+++ exited with 0 +++
</pre></div>
<p>We can see in those logs there&#39;s a single <code>connect</code> call to port 443 (it also
happens to use IPv6, good job <code>example.org</code>!).</p>
<p>And we can see that the headers and bodies are received out of order, through
that single TCP connection!</p>
<p>What we don&#39;t see, are the HTTP/2 messages being exchanged. Luckily, this
article isn&#39;t over yet.</p>

                        <h2>
                            <a id="making-http-2-requests-ourselves" href="#making-http-2-requests-ourselves">
                                Making HTTP/2 requests ourselves
                            </a>
                        </h2>
                        
<p>First off, let&#39;s get rid of the <code>h2</code> crate:</p>
<div><p>Shell session</p><pre data-lang="shell">$ cargo rm h2
</pre></div>
<p>And reach out for a couple crates again, for encoding and decoding:</p>
<div><p>Shell session</p><pre data-lang="shell">$ cargo add byteorder
    Updating crates.io index
      Adding byteorder v1.4.3 to dependencies.
$ cargo add nom
    Updating crates.io index
      Adding nom v7.1.1 to dependencies.
$ cargo add enum-repr
    Updating crates.io index
      Adding enum-repr v0.2.6 to dependencies.
$ cargo add bytes
    Updating crates.io index
      Adding bytes v1.2.1 to dependencies.
</pre></div>
<p>We&#39;ll start by writing decoding and encoding code for HTTP/2 frames, in a
separate module:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>// in `src/h2.rs`</i>

<i>use</i> std<i>::</i>{
    fmt,
    ops<i>::</i>{Deref, DerefMut},
}<i>;</i>

<i>use</i> enum_repr<i>::</i>EnumRepr<i>;</i>
<i>use</i> nom<i>::</i>{
    combinator<i>::</i>map_res,
    number<i>::</i>streaming<i>::</i>{be_u24, be_u8},
    sequence<i>::</i>tuple,
    IResult,
}<i>;</i>
<i>use</i> tokio<i>::</i>io<i>::</i>{AsyncWrite, AsyncWriteExt}<i>;</i>

<i>/// This is sent by h2 clients after negotiating over ALPN, or when doing h2c.</i>
<i>pub</i> <i>const</i> PREFACE: <i>&amp;</i><i>[</i><i>u8</i><i>]</i> = <i>b&#34;PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n&#34;</i><i>;</i>

<i>/// See https://httpwg.org/specs/rfc9113.html#FrameTypes</i>
<i>#<i>[</i>EnumRepr<i>(</i>type = <i>&#34;u8&#34;</i><i>)</i><i>]</i></i>
<i>#<i>[</i>derive<i>(</i>Debug<i>)</i><i>]</i></i>
<i>pub</i> <i>enum</i> <i>FrameType</i> {
    Data = <i>0</i>,
    Headers = <i>1</i>,
    Priority = <i>2</i>,
    RstStream = <i>3</i>,
    Settings = <i>4</i>,
    PushPromise = <i>5</i>,
    Ping = <i>6</i>,
    GoAway = <i>7</i>,
    WindowUpdate = <i>8</i>,
    Continuation = <i>9</i>,
}

<i>/// See https://httpwg.org/specs/rfc9113.html#FrameHeader</i>
<i>#<i>[</i>derive<i>(</i>Debug<i>)</i><i>]</i></i>
<i>pub</i> <i>struct</i> <i>Frame</i> {
    <i>pub</i> <i>frame_type</i>: <i>FrameType</i>,
    <i>pub</i> <i>flags</i>: <i>u8</i>,
    <i>pub</i> <i>reserved</i>: <i>u8</i>,
    <i>pub</i> <i>stream_id</i>: <i>u32</i>,
    <i>pub</i> <i>payload</i>: <i>OpaquePayload</i>,
}

<i>/// This is just used to avoid dumping the entire payload in the [fmt::Debug]</i>
<i>/// implementation of [Frame].</i>
<i>#<i>[</i>derive<i>(</i>Default<i>)</i><i>]</i></i>
<i>pub</i> <i>struct</i> <i>OpaquePayload</i><i>(</i><i>pub</i> <i>Vec</i><i>&lt;</i><i>u8</i><i>&gt;</i><i>)</i><i>;</i>

<i>impl</i> <i>Deref</i> <i>for</i> <i>OpaquePayload</i> {
    <i>type</i> <i>Target</i> = <i>Vec</i><i>&lt;</i><i>u8</i><i>&gt;</i><i>;</i>

    <i>fn</i> <i>deref</i><i>(</i><i>&amp;</i><i>self</i><i>)</i> -&gt; <i>&amp;</i>Self<i>::</i><i>Target</i> {
        <i>&amp;</i><i>self</i><i>.</i><i>0</i>
    }
}

<i>impl</i> <i>DerefMut</i> <i>for</i> <i>OpaquePayload</i> {
    <i>fn</i> <i>deref_mut</i><i>(</i><i>&amp;</i><i>mut</i> <i>self</i><i>)</i> -&gt; <i>&amp;</i><i>mut</i> Self<i>::</i><i>Target</i> {
        <i>&amp;</i><i>mut</i> <i>self</i><i>.</i><i>0</i>
    }
}

<i>impl</i> fmt<i>::</i><i>Debug</i> <i>for</i> <i>OpaquePayload</i> {
    <i>fn</i> <i>fmt</i><i>(</i><i>&amp;</i><i>self</i>, <i>f</i>: <i>&amp;</i><i>mut</i> fmt<i>::</i><i>Formatter</i><i>&lt;</i><i>&#39;</i><i>_</i><i>&gt;</i><i>)</i> -&gt; fmt<i>::</i><i>Result</i> {
        f<i>.</i><i>debug_struct</i><i>(</i><i>&#34;OpaquePayload&#34;</i><i>)</i>
            <i>.</i><i>field</i><i>(</i><i>&#34;len&#34;</i>, <i>&amp;</i><i>self</i><i>.</i><i>0</i><i>.</i><i>len</i><i>(</i><i>)</i><i>)</i>
            <i>.</i><i>finish</i><i>(</i><i>)</i>
    }
}

<i>impl</i> <i>Frame</i> {
    <i>/// Create a new frame with the given type and stream ID.</i>
    <i>pub</i> <i>fn</i> <i>new</i><i>(</i><i>frame_type</i>: <i>FrameType</i>, <i>stream_id</i>: <i>u32</i><i>)</i> -&gt; <i>Self</i> {
        <i>Self</i> {
            frame_type,
            <i>flags</i>: <i>0</i>,
            <i>reserved</i>: <i>0</i>,
            stream_id,
            <i>payload</i>: <i>Default</i><i>::</i><i>default</i><i>(</i><i>)</i>,
        }
    }

    <i>/// Parse a frame from the given slice. This also takes the payload from the</i>
    <i>/// slice, and copies it to the heap, which may not be ideal for a production</i>
    <i>/// implementation.</i>
    <i>pub</i> <i>fn</i> <i>parse</i><i>(</i><i>i</i>: <i>&amp;</i><i>[</i><i>u8</i><i>]</i><i>)</i> -&gt; <i>IResult</i><i>&lt;</i><i>&amp;</i><i>[</i><i>u8</i><i>]</i>, <i>Self</i><i>&gt;</i> {
        <i>let</i> <i>(</i>i, <i>(</i>length, frame_type, flags, <i>(</i>reserved, stream_id<i>)</i><i>)</i><i>)</i> = <i>tuple</i><i>(</i><i>(</i>
            be_u24,
            <i>map_res</i><i>(</i>be_u8, |u| {
                <i>FrameType</i><i>::</i><i>from_repr</i><i>(</i>u<i>)</i><i>.</i><i>ok_or</i><i>(</i>nom<i>::</i>error<i>::</i><i>ErrorKind</i><i>::</i>OneOf<i>)</i>
            }<i>)</i>,
            be_u8,
            parse_reserved_and_stream_id,
        <i>)</i><i>)</i><i>(</i>i<i>)</i>?<i>;</i>
        <i>let</i> <i>(</i>i, payload<i>)</i> = nom<i>::</i>bytes<i>::</i>streaming<i>::</i><i>take</i><i>(</i>length<i>)</i><i>(</i>i<i>)</i>?<i>;</i>

        <i>let</i> frame = <i>Frame</i> {
            frame_type,
            flags,
            reserved,
            stream_id,
            <i>payload</i>: OpaquePayload<i>(</i>payload<i>.</i><i>to_vec</i><i>(</i><i>)</i><i>)</i>,
        }<i>;</i>
        Ok<i>(</i><i>(</i>i, frame<i>)</i><i>)</i>
    }

    <i>/// Writes a frame to an [AsyncWrite].</i>
    <i>pub</i> async <i>fn</i> <i>write</i><i>(</i><i>&amp;</i><i>self</i>, <i>w</i>: <i>&amp;</i><i>mut</i> <i>(</i><i>dyn</i> <i>AsyncWrite</i> + <i>Unpin</i><i>)</i><i>)</i> -&gt; color_eyre<i>::</i><i>Result</i><i>&lt;</i><i>(</i><i>)</i><i>&gt;</i> {
        <i>let</i> <i>mut</i> header = <i>[</i><i>0u8</i><i>;</i> <i>9</i><i>]</i><i>;</i>
        {
            <i>use</i> byteorder<i>::</i>{BigEndian, WriteBytesExt}<i>;</i>
            <i>let</i> <i>mut</i> header = <i>&amp;</i><i>mut</i> header<i>[</i>..<i>]</i><i>;</i>
            header<i>.</i><i>write_u24</i><i>::</i><i>&lt;</i><i>BigEndian</i><i>&gt;</i><i>(</i><i>self</i><i>.</i><i>payload</i><i>.</i><i>len</i><i>(</i><i>)</i> <i>as</i> <i>_</i><i>)</i>?<i>;</i>
            header<i>.</i><i>write_u8</i><i>(</i><i>self</i><i>.</i><i>frame_type</i><i>.</i><i>repr</i><i>(</i><i>)</i><i>)</i>?<i>;</i>
            header<i>.</i><i>write_u8</i><i>(</i><i>self</i><i>.</i><i>flags</i><i>)</i>?<i>;</i>
            header<i>.</i><i>write_u32</i><i>::</i><i>&lt;</i><i>BigEndian</i><i>&gt;</i><i>(</i><i>self</i><i>.</i><i>stream_id</i><i>)</i>?<i>;</i>
        }

        <i>// We could be doing vectored I/O here, but there&#39;s no</i>
        <i>// `write_all_vectored` method in [AsyncWriteExt]</i>
        w<i>.</i><i>write_all</i><i>(</i><i>&amp;</i>header<i>)</i><i>.</i>await?<i>;</i>
        w<i>.</i><i>write_all</i><i>(</i><i>&amp;</i><i>self</i><i>.</i><i>payload</i><i>)</i><i>.</i>await?<i>;</i>

        Ok<i>(</i><i>(</i><i>)</i><i>)</i>
    }
}

<i>/// See https://httpwg.org/specs/rfc9113.html#FrameHeader - the first bit</i>
<i>/// is reserved, and the rest is a 32-bit stream id</i>
<i>fn</i> <i>parse_reserved_and_stream_id</i><i>(</i><i>i</i>: <i>&amp;</i><i>[</i><i>u8</i><i>]</i><i>)</i> -&gt; <i>IResult</i><i>&lt;</i><i>&amp;</i><i>[</i><i>u8</i><i>]</i>, <i>(</i><i>u8</i>, <i>u32</i><i>)</i><i>&gt;</i> {
    <i>fn</i> <i>reserved</i><i>(</i><i>i</i>: <i>(</i><i>&amp;</i><i>[</i><i>u8</i><i>]</i>, <i>usize</i><i>)</i><i>)</i> -&gt; <i>IResult</i><i>&lt;</i><i>(</i><i>&amp;</i><i>[</i><i>u8</i><i>]</i>, <i>usize</i><i>)</i>, <i>u8</i><i>&gt;</i> {
        nom<i>::</i>bits<i>::</i>streaming<i>::</i><i>take</i><i>(</i><i>1_usize</i><i>)</i><i>(</i>i<i>)</i>
    }

    <i>fn</i> <i>stream_id</i><i>(</i><i>i</i>: <i>(</i><i>&amp;</i><i>[</i><i>u8</i><i>]</i>, <i>usize</i><i>)</i><i>)</i> -&gt; <i>IResult</i><i>&lt;</i><i>(</i><i>&amp;</i><i>[</i><i>u8</i><i>]</i>, <i>usize</i><i>)</i>, <i>u32</i><i>&gt;</i> {
        nom<i>::</i>bits<i>::</i>streaming<i>::</i><i>take</i><i>(</i><i>31_usize</i><i>)</i><i>(</i>i<i>)</i>
    }

    nom<i>::</i>bits<i>::</i><i>bits</i><i>(</i><i>tuple</i><i>(</i><i>(</i>reserved, stream_id<i>)</i><i>)</i><i>)</i><i>(</i>i<i>)</i>
}
</pre></div>
<p>This is not a <em>complete</em> parser by any stretch of the imagination, but it should
be enough to get the h2 server to send us some frames back!</p>
<div><p>Rust code</p><pre data-lang="rust"><i>// in `src/main.rs`</i>

<i>use</i> std<i>::</i>{net<i>::</i>ToSocketAddrs, str<i>::</i>FromStr, sync<i>::</i>Arc}<i>;</i>

<i>use</i> bytes<i>::</i>BytesMut<i>;</i>
<i>use</i> color_eyre<i>::</i>eyre<i>::</i>eyre<i>;</i>
<i>use</i> nom<i>::</i>Offset<i>;</i>
<i>use</i> rustls<i>::</i>{Certificate, ClientConfig, KeyLogFile, RootCertStore}<i>;</i>
<i>use</i> tokio<i>::</i>{
    io<i>::</i>{AsyncReadExt, AsyncWriteExt},
    net<i>::</i>TcpStream,
}<i>;</i>
<i>use</i> tracing<i>::</i>info<i>;</i>
<i>use</i> tracing_subscriber<i>::</i>{filter<i>::</i>targets<i>::</i>Targets, layer<i>::</i>SubscriberExt, util<i>::</i>SubscriberInitExt}<i>;</i>

<i>use</i> crate<i>::</i>h2<i>::</i>{Frame, FrameType}<i>;</i>

<i>mod</i> h2<i>;</i>

<i>#<i>[</i>tokio<i>::</i>main<i>]</i></i>
async <i>fn</i> <i>main</i><i>(</i><i>)</i> -&gt; color_eyre<i>::</i><i>Result</i><i>&lt;</i><i>(</i><i>)</i><i>&gt;</i> {
    <i>// this is just a trick to get rust-analyzer to complete the body of the</i>
    <i>// function better. there&#39;s still issues with auto-completion within</i>
    <i>// functions, see https://github.com/rust-lang/rust-analyzer/issues/13355</i>
    <i>real_main</i><i>(</i><i>)</i><i>.</i>await
}

async <i>fn</i> <i>real_main</i><i>(</i><i>)</i> -&gt; color_eyre<i>::</i><i>Result</i><i>&lt;</i><i>(</i><i>)</i><i>&gt;</i> {
    color_eyre<i>::</i><i>install</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>

    <i>let</i> filter_layer =
        <i>Targets</i><i>::</i><i>from_str</i><i>(</i>std<i>::</i>env<i>::</i><i>var</i><i>(</i><i>&#34;RUST_LOG&#34;</i><i>)</i><i>.</i><i>as_deref</i><i>(</i><i>)</i><i>.</i><i>unwrap_or</i><i>(</i><i>&#34;info&#34;</i><i>)</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
    <i>let</i> format_layer = tracing_subscriber<i>::</i>fmt<i>::</i><i>layer</i><i>(</i><i>)</i><i>;</i>
    tracing_subscriber<i>::</i><i>registry</i><i>(</i><i>)</i>
        <i>.</i><i>with</i><i>(</i>filter_layer<i>)</i>
        <i>.</i><i>with</i><i>(</i>format_layer<i>)</i>
        <i>.</i><i>init</i><i>(</i><i>)</i><i>;</i>

    <i>info</i><i>!</i><i>(</i><i>&#34;Setting up TLS&#34;</i><i>)</i><i>;</i>
    <i>let</i> <i>mut</i> root_store = <i>RootCertStore</i><i>::</i><i>empty</i><i>(</i><i>)</i><i>;</i>
    <i>for</i> cert <i>in</i> rustls_native_certs<i>::</i><i>load_native_certs</i><i>(</i><i>)</i>? {
        root_store<i>.</i><i>add</i><i>(</i><i>&amp;</i>Certificate<i>(</i>cert<i>.</i><i>0</i><i>)</i><i>)</i>?<i>;</i>
    }

    <i>let</i> <i>mut</i> client_config = <i>ClientConfig</i><i>::</i><i>builder</i><i>(</i><i>)</i>
        <i>.</i><i>with_safe_defaults</i><i>(</i><i>)</i>
        <i>.</i><i>with_root_certificates</i><i>(</i>root_store<i>)</i>
        <i>.</i><i>with_no_client_auth</i><i>(</i><i>)</i><i>;</i>
    client_config<i>.</i><i>key_log</i> = <i>Arc</i><i>::</i><i>new</i><i>(</i><i>KeyLogFile</i><i>::</i><i>new</i><i>(</i><i>)</i><i>)</i><i>;</i>
    client_config<i>.</i><i>alpn_protocols</i> = <i>vec</i><i>!</i><i>[</i><i>b&#34;h2&#34;</i>.to_vec<i>(</i><i>)</i><i>]</i><i>;</i>

    <i>let</i> connector = tokio_rustls<i>::</i><i>TlsConnector</i><i>::</i><i>from</i><i>(</i><i>Arc</i><i>::</i><i>new</i><i>(</i>client_config<i>)</i><i>)</i><i>;</i>

    <i>info</i><i>!</i><i>(</i><i>&#34;Performing DNS lookup&#34;</i><i>)</i><i>;</i>
    <i>let</i> addr = <i>&#34;example.org:443&#34;</i>
        <i>.</i><i>to_socket_addrs</i><i>(</i><i>)</i>?
        <i>.</i><i>next</i><i>(</i><i>)</i>
        <i>.</i><i>ok_or_else</i><i>(</i>|| <i>eyre</i><i>!</i><i>(</i><i>&#34;Failed to resolve address for example.org:443&#34;</i><i>)</i><i>)</i>?<i>;</i>

    <i>info</i><i>!</i><i>(</i><i>&#34;Establishing TCP connection...&#34;</i><i>)</i><i>;</i>
    <i>let</i> stream = <i>TcpStream</i><i>::</i><i>connect</i><i>(</i>addr<i>)</i><i>.</i>await?<i>;</i>

    <i>info</i><i>!</i><i>(</i><i>&#34;Establishing TLS session...&#34;</i><i>)</i><i>;</i>
    <i>let</i> <i>mut</i> stream = connector<i>.</i><i>connect</i><i>(</i><i>&#34;example.org&#34;</i><i>.</i><i>try_into</i><i>(</i><i>)</i>?, stream<i>)</i><i>.</i>await?<i>;</i>

    <i>info</i><i>!</i><i>(</i><i>&#34;Establishing HTTP/2 connection...&#34;</i><i>)</i><i>;</i>

    <i>info</i><i>!</i><i>(</i><i>&#34;Writing preface&#34;</i><i>)</i><i>;</i>
    stream<i>.</i><i>write_all</i><i>(</i>h2<i>::</i>PREFACE<i>)</i><i>.</i>await?<i>;</i>

    <i>let</i> settings = <i>Frame</i><i>::</i><i>new</i><i>(</i><i>FrameType</i><i>::</i>Settings, <i>0</i><i>)</i><i>;</i>
    <i>info</i><i>!</i><i>(</i><i>&#34;&gt; {settings:?}&#34;</i><i>)</i><i>;</i>
    settings<i>.</i><i>write</i><i>(</i><i>&amp;</i><i>mut</i> stream<i>)</i><i>.</i>await?<i>;</i>

    <i>let</i> <i>mut</i> buf: <i>BytesMut</i> = <i>Default</i><i>::</i><i>default</i><i>(</i><i>)</i><i>;</i>
    <i>loop</i> {
        <i>info</i><i>!</i><i>(</i><i>&#34;Reading frame ({} bytes so far)&#34;</i>, buf.len<i>(</i><i>)</i><i>)</i><i>;</i>
        <i>if</i> stream<i>.</i><i>read_buf</i><i>(</i><i>&amp;</i><i>mut</i> buf<i>)</i><i>.</i>await? == <i>0</i> {
            <i>info</i><i>!</i><i>(</i><i>&#34;connection closed!&#34;</i><i>)</i><i>;</i>
            <i>return</i> Ok<i>(</i><i>(</i><i>)</i><i>)</i><i>;</i>
        }

        <i>let</i> slice = <i>&amp;</i>buf<i>[</i>..<i>]</i><i>;</i>
        <i>let</i> frame = <i>match</i> <i>Frame</i><i>::</i><i>parse</i><i>(</i>slice<i>)</i> {
            Ok<i>(</i><i>(</i>rest, frame<i>)</i><i>)</i> =&gt; {
                buf = buf<i>.</i><i>split_off</i><i>(</i>slice<i>.</i><i>offset</i><i>(</i>rest<i>)</i><i>)</i><i>;</i>
                frame
            }
            Err<i>(</i>e<i>)</i> =&gt; {
                <i>if</i> e<i>.</i><i>is_incomplete</i><i>(</i><i>)</i> {
                    <i>// keep reading!</i>
                    <i>continue</i><i>;</i>
                }
                <i>panic</i><i>!</i><i>(</i><i>&#34;parse error: {e}&#34;</i><i>)</i><i>;</i>
            }
        }<i>;</i>

        <i>info</i><i>!</i><i>(</i><i>&#34;&lt; {frame:?}&#34;</i><i>)</i><i>;</i>
    }
}
</pre></div>
<p>And indeed it does!</p>
<div><p>Shell session</p><pre data-lang="shell">$ cargo run
   Compiling crash v0.1.0 (/home/amos/bearcove/crash)
    Finished dev [unoptimized + debuginfo] target(s) in 2.09s
     Running `target/debug/crash`
2022-10-20T09:29:21.260528Z  INFO crash: Setting up TLS
2022-10-20T09:29:21.282568Z  INFO crash: Performing DNS lookup
2022-10-20T09:29:21.295450Z  INFO crash: Establishing TCP connection...
2022-10-20T09:29:21.390187Z  INFO crash: Establishing TLS session...
2022-10-20T09:29:21.591178Z  INFO crash: Establishing HTTP/2 connection...
2022-10-20T09:29:21.591227Z  INFO crash: Writing preface
2022-10-20T09:29:21.591293Z  INFO crash: &gt; Frame { frame_type: Settings, flags: 0, reserved: 0, stream_id: 0, payload: OpaquePayload { len: 0 } }
2022-10-20T09:29:21.591362Z  INFO crash: Reading frame (0 bytes so far)
2022-10-20T09:29:21.705711Z  INFO crash: &lt; Frame { frame_type: Settings, flags: 0, reserved: 0, stream_id: 0, payload: OpaquePayload { len: 30 } }
2022-10-20T09:29:21.705789Z  INFO crash: Reading frame (13 bytes so far)
2022-10-20T09:29:21.798666Z  INFO crash: &lt; Frame { frame_type: WindowUpdate, flags: 0, reserved: 0, stream_id: 0, payload: OpaquePayload { len: 4 } }
2022-10-20T09:29:21.798737Z  INFO crash: Reading frame (9 bytes so far)
^C
</pre></div>
<p>The SETTINGS frame we send is empty, but the server&#39;s SETTINGS frame isn&#39;t:</p>
<div><pre data-lang="">HyperText Transfer Protocol 2
    Stream: SETTINGS, Stream ID: 0, Length 30
        Length: 30
        Type: SETTINGS (4)
        Flags: 0x00
        0... .... .... .... .... .... .... .... = Reserved: 0x0
        .000 0000 0000 0000 0000 0000 0000 0000 = Stream Identifier: 0
        Settings - Header table size : 4096
        Settings - Max concurrent streams : 100
        Settings - Initial Windows size : 1048576
        Settings - Max frame size : 16384
        Settings - Max header list size : 16384
</pre></div>
<p>We could pretty easily parse those, but let&#39;s ignore them for now — we&#39;re only
planning on making a simple GET method, we should be way below those limits.</p>
<p>The server also sends us a WINDOW_UPDATE frame:</p>
<div><pre data-lang="">HyperText Transfer Protocol 2
    Stream: WINDOW_UPDATE, Stream ID: 0, Length 4
        Length: 4
        Type: WINDOW_UPDATE (8)
        Flags: 0x00
        0... .... .... .... .... .... .... .... = Reserved: 0x0
        .000 0000 0000 0000 0000 0000 0000 0000 = Stream Identifier: 0
        0... .... .... .... .... .... .... .... = Reserved: 0x0
        .000 0000 0000 1111 0000 0000 0000 0001 = Window Size Increment: 983041
</pre></div>
<p>...giving us a generous 983041-byte (~960 KiB) increment to the flow control
window, that applies to the whole connection (the stream identifier is 0). Since
it <a href="https://httpwg.org/specs/rfc9113.html#InitialWindowSize">starts at 65535
bytes</a>, we can send
exactly one megabyte before the server needs to raise our allowance.</p>
<p>Even though we&#39;re not really planning on processing these settings, it&#39;s a good
idea to acknowledge them, by sending another SETTINGS frame with the <code>ack</code> flag
set (0x01).</p>
<p>To make sure we&#39;re not acknowledging the server&#39;s own acknowledgement frame, we
have to start thinking about flags.</p>
<p>We&#39;ll reach out for <a href="https://lib.rs/crates/enumflags2">enumflags2</a>, which
conveniently comes with conversions between the underlying representation (here
<code>u8</code>), and a <code>BitFlags&lt;T&gt;</code> type, letting us test for flag presence, set flags,
and show both the numeric value and actual flags in its debug implementation.</p>
<div><p>Shell session</p><pre data-lang="shell">$ cargo add enumflags2
    Updating crates.io index
      Adding enumflags2 v0.7.5 to dependencies.
</pre></div>
<p>To avoid matching on frame type several times, we&#39;ll rename our existing
<code>FrameType</code> enum to <code>RawFrameType</code></p>
<div><p>Rust code</p><pre data-lang="rust"><i>// in `src/h2.rs`</i>

<i>/// See https://httpwg.org/specs/rfc9113.html#FrameTypes</i>
<i>#<i>[</i>EnumRepr<i>(</i>type = <i>&#34;u8&#34;</i><i>)</i><i>]</i></i>
<i>#<i>[</i>derive<i>(</i>Debug<i>)</i><i>]</i></i>
<i>pub</i> <i>enum</i> <i>RawFrameType</i> {
    Data = <i>0</i>,
    Headers = <i>1</i>,
    <i>// (cut)</i>
    Continuation = <i>9</i>,
}
</pre></div>
<p>And introduce a <em>new</em> <code>FrameType</code> enum, that contains the flags we know about:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>// in `src/h2.rs`</i>

<i>/// Typed flags for various frame types</i>
<i>#<i>[</i>derive<i>(</i>Debug<i>)</i><i>]</i></i>
<i>pub</i> <i>enum</i> <i>FrameType</i> {
    Data,
    Headers,
    Priority,
    RstStream,
    Settings<i>(</i><i>BitFlags</i><i>&lt;</i><i>SettingsFlags</i><i>&gt;</i><i>)</i>,
    PushPromise,
    Ping,
    GoAway,
    WindowUpdate,
    Continuation,
}
</pre></div>
<p>And then we&#39;ll define our <code>SettingsFlags</code>:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>// in `src/h2.rs`</i>

<i>use</i> enumflags2<i>::</i>{bitflags, BitFlags}<i>;</i>

<i>/// See https://httpwg.org/specs/rfc9113.html#SETTINGS</i>
<i>#<i>[</i>bitflags<i>]</i></i>
<i>#<i>[</i>repr<i>(</i>u8<i>)</i><i>]</i></i>
<i>#<i>[</i>derive<i>(</i>Copy, Clone, Debug, PartialEq, Eq<i>)</i><i>]</i></i>
<i>pub</i> <i>enum</i> <i>SettingsFlags</i> {
    Ack = <i>0x01</i>,
}
</pre></div>
<p>We can now trivially add helpers to convert from <code>(RawFrameType, u8)</code> to
<code>FrameType</code> and back:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>// in `src/h2.rs`</i>

<i>impl</i> <i>FrameType</i> {
    <i>fn</i> <i>encode</i><i>(</i><i>&amp;</i><i>self</i><i>)</i> -&gt; <i>(</i><i>RawFrameType</i>, <i>u8</i><i>)</i> {
        <i>match</i> <i>self</i> {
            <i>FrameType</i><i>::</i>Data =&gt; <i>(</i><i>RawFrameType</i><i>::</i>Data, <i>0</i><i>)</i>,
            <i>FrameType</i><i>::</i>Headers =&gt; <i>(</i><i>RawFrameType</i><i>::</i>Headers, <i>0</i><i>)</i>,
            <i>FrameType</i><i>::</i>Priority =&gt; <i>(</i><i>RawFrameType</i><i>::</i>Priority, <i>0</i><i>)</i>,
            <i>FrameType</i><i>::</i>RstStream =&gt; <i>(</i><i>RawFrameType</i><i>::</i>RstStream, <i>0</i><i>)</i>,
            <i>FrameType</i><i>::</i>Settings<i>(</i>f<i>)</i> =&gt; <i>(</i><i>RawFrameType</i><i>::</i>Settings, f<i>.</i><i>bits</i><i>(</i><i>)</i><i>)</i>,
            <i>FrameType</i><i>::</i>PushPromise =&gt; <i>(</i><i>RawFrameType</i><i>::</i>PushPromise, <i>0</i><i>)</i>,
            <i>FrameType</i><i>::</i>Ping =&gt; <i>(</i><i>RawFrameType</i><i>::</i>Ping, <i>0</i><i>)</i>,
            <i>FrameType</i><i>::</i>GoAway =&gt; <i>(</i><i>RawFrameType</i><i>::</i>GoAway, <i>0</i><i>)</i>,
            <i>FrameType</i><i>::</i>WindowUpdate =&gt; <i>(</i><i>RawFrameType</i><i>::</i>WindowUpdate, <i>0</i><i>)</i>,
            <i>FrameType</i><i>::</i>Continuation =&gt; <i>(</i><i>RawFrameType</i><i>::</i>Continuation, <i>0</i><i>)</i>,
        }
    }

    <i>fn</i> <i>decode</i><i>(</i><i>ty</i>: <i>RawFrameType</i>, <i>flags</i>: <i>u8</i><i>)</i> -&gt; <i>Self</i> {
        <i>match</i> ty {
            <i>RawFrameType</i><i>::</i>Data =&gt; <i>FrameType</i><i>::</i>Data,
            <i>RawFrameType</i><i>::</i>Headers =&gt; <i>FrameType</i><i>::</i>Headers,
            <i>RawFrameType</i><i>::</i>Priority =&gt; <i>FrameType</i><i>::</i>Priority,
            <i>RawFrameType</i><i>::</i>RstStream =&gt; <i>FrameType</i><i>::</i>RstStream,
            <i>RawFrameType</i><i>::</i>Settings =&gt; {
                <i>FrameType</i><i>::</i>Settings<i>(</i><i>BitFlags</i><i>::</i><i>&lt;</i><i>SettingsFlags</i><i>&gt;</i><i>::</i><i>from_bits_truncate</i><i>(</i>flags<i>)</i><i>)</i>
            }
            <i>RawFrameType</i><i>::</i>PushPromise =&gt; <i>FrameType</i><i>::</i>PushPromise,
            <i>RawFrameType</i><i>::</i>Ping =&gt; <i>FrameType</i><i>::</i>Ping,
            <i>RawFrameType</i><i>::</i>GoAway =&gt; <i>FrameType</i><i>::</i>GoAway,
            <i>RawFrameType</i><i>::</i>WindowUpdate =&gt; <i>FrameType</i><i>::</i>WindowUpdate,
            <i>RawFrameType</i><i>::</i>Continuation =&gt; <i>FrameType</i><i>::</i>Continuation,
        }
    }
}
</pre></div>
<p>Note that these aren&#39;t fallible — unknown frame types are handled when parsing
<code>RawFrameType</code>, and unknown flags are simply ignored.</p>
<p>The <code>Frame</code> struct should refer to the strongly-typed <code>FrameType</code> now, and
should no longer have a <code>flags</code> field:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>/// See https://httpwg.org/specs/rfc9113.html#FrameHeader</i>
<i>#<i>[</i>derive<i>(</i>Debug<i>)</i><i>]</i></i>
<i>pub</i> <i>struct</i> <i>Frame</i> {
    <i>// was `RawFrameType` 👇 (after rename)</i>
    <i>pub</i> <i>frame_type</i>: <i>FrameType</i>,
    <i>// removed: `flags: u8`</i>
    <i>pub</i> <i>reserved</i>: <i>u8</i>,
    <i>pub</i> <i>stream_id</i>: <i>u32</i>,
    <i>pub</i> <i>payload</i>: <i>OpaquePayload</i>,
}
</pre></div>
<p>The <code>Frame::new</code> method should be updated too, but that&#39;s left as an exercise to
the reader. <code>Frame::parse</code> should also now decode:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>impl</i> <i>Frame</i> {
    <i>/// Parse a frame from the given slice. This also takes the payload from the</i>
    <i>/// slice, and copies it to the heap, which may not be ideal for a production</i>
    <i>/// implementation.</i>
    <i>pub</i> <i>fn</i> <i>parse</i><i>(</i><i>i</i>: <i>&amp;</i><i>[</i><i>u8</i><i>]</i><i>)</i> -&gt; <i>IResult</i><i>&lt;</i><i>&amp;</i><i>[</i><i>u8</i><i>]</i>, <i>Self</i><i>&gt;</i> {
        <i>let</i> <i>(</i>i, <i>(</i>length, frame_type, flags, <i>(</i>reserved, stream_id<i>)</i><i>)</i><i>)</i> = <i>tuple</i><i>(</i><i>(</i>
            be_u24,
            <i>map_res</i><i>(</i>be_u8, |u| {
                <i>RawFrameType</i><i>::</i><i>from_repr</i><i>(</i>u<i>)</i><i>.</i><i>ok_or</i><i>(</i>nom<i>::</i>error<i>::</i><i>ErrorKind</i><i>::</i>OneOf<i>)</i>
            }<i>)</i>,
            be_u8,
            parse_reserved_and_stream_id,
        <i>)</i><i>)</i><i>(</i>i<i>)</i>?<i>;</i>
        <i>let</i> <i>(</i>i, payload<i>)</i> = nom<i>::</i>bytes<i>::</i>streaming<i>::</i><i>take</i><i>(</i>length<i>)</i><i>(</i>i<i>)</i>?<i>;</i>

        <i>//                  👇 new!</i>
        <i>let</i> frame_type = <i>FrameType</i><i>::</i><i>decode</i><i>(</i>frame_type, flags<i>)</i><i>;</i>

        <i>let</i> frame = <i>Frame</i> {
            frame_type,
            reserved,
            stream_id,
            <i>payload</i>: OpaquePayload<i>(</i>payload<i>.</i><i>to_vec</i><i>(</i><i>)</i><i>)</i>,
        }<i>;</i>
        Ok<i>(</i><i>(</i>i, frame<i>)</i><i>)</i>
    }
}
</pre></div>
<p>And <code>Frame::write</code> should encode:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>impl</i> <i>Frame</i> {
    <i>/// Writes a frame to an [AsyncWrite].</i>
    <i>pub</i> async <i>fn</i> <i>write</i><i>(</i><i>&amp;</i><i>self</i>, <i>w</i>: <i>&amp;</i><i>mut</i> <i>(</i><i>dyn</i> <i>AsyncWrite</i> + <i>Unpin</i><i>)</i><i>)</i> -&gt; color_eyre<i>::</i><i>Result</i><i>&lt;</i><i>(</i><i>)</i><i>&gt;</i> {
        <i>let</i> <i>mut</i> header = <i>[</i><i>0u8</i><i>;</i> <i>9</i><i>]</i><i>;</i>
        {
            <i>use</i> byteorder<i>::</i>{BigEndian, WriteBytesExt}<i>;</i>
            <i>let</i> <i>mut</i> header = <i>&amp;</i><i>mut</i> header<i>[</i>..<i>]</i><i>;</i>
            header<i>.</i><i>write_u24</i><i>::</i><i>&lt;</i><i>BigEndian</i><i>&gt;</i><i>(</i><i>self</i><i>.</i><i>payload</i><i>.</i><i>len</i><i>(</i><i>)</i> <i>as</i> <i>_</i><i>)</i>?<i>;</i>
            <i>let</i> <i>(</i>ty, flags<i>)</i> = <i>self</i><i>.</i><i>frame_type</i><i>.</i><i>encode</i><i>(</i><i>)</i><i>;</i>
            header<i>.</i><i>write_u8</i><i>(</i>ty<i>.</i><i>repr</i><i>(</i><i>)</i><i>)</i>?<i>;</i>
            header<i>.</i><i>write_u8</i><i>(</i>flags<i>)</i>?<i>;</i>
            header<i>.</i><i>write_u32</i><i>::</i><i>&lt;</i><i>BigEndian</i><i>&gt;</i><i>(</i><i>self</i><i>.</i><i>stream_id</i><i>)</i>?<i>;</i>
        }

        <i>// etc.</i>
    }
}
</pre></div><div>

<p>Say, Amos, aren&#39;t we getting carried away? Isn&#39;t this all throwaway code?</p>
</div>
<p>Oh sure, we could just as well have had a <code>frame.flags &amp; 0x01 != 0</code> or something
in <code>main.rs</code>, but it&#39;s actually less mental overhead for me to set up those nice
abstractions, even for throwaway code.</p>
<p>It makes everything more readable, and it makes harder to &#34;hold incorrectly&#34;,
which is an important upside of Rust.</p>
<p>Each frame type has its own set of flags, and with that setup, we cannot
accidentally mix them up. We also get a nice <code>Debug</code> implementation.</p>
<p>Let me update <code>main.rs</code> real quick, and you&#39;ll see:</p>
<div><p>Rust code</p><pre data-lang="rust">    <i>//                            don&#39;t pass any flags 👇</i>
    <i>let</i> settings = <i>Frame</i><i>::</i><i>new</i><i>(</i><i>FrameType</i><i>::</i>Settings<i>(</i><i>Default</i><i>::</i><i>default</i><i>(</i><i>)</i><i>)</i>, <i>0</i><i>)</i><i>;</i>
    <i>info</i><i>!</i><i>(</i><i>&#34;&gt; {settings:?}&#34;</i><i>)</i><i>;</i>
    settings<i>.</i><i>write</i><i>(</i><i>&amp;</i><i>mut</i> stream<i>)</i><i>.</i>await?<i>;</i>
</pre></div><div><p>Shell session</p><pre data-lang="shell">$ cargo run
(cut)
2022-10-20T10:17:14.722354Z  INFO crash: Writing preface
2022-10-20T10:17:14.722400Z  INFO crash: &gt; Frame { frame_type: Settings(BitFlags&lt;SettingsFlags&gt;(0b0)), reserved: 0, stream_id: 0, payload: OpaquePayload { len: 0 } }
2022-10-20T10:17:14.722466Z  INFO crash: Reading frame (0 bytes so far)
2022-10-20T10:17:14.833748Z  INFO crash: &lt; Frame { frame_type: Settings(BitFlags&lt;SettingsFlags&gt;(0b0)), reserved: 0, stream_id: 0, payload: OpaquePayload { len: 30 } }
2022-10-20T10:17:14.833821Z  INFO crash: Reading frame (13 bytes so far)
2022-10-20T10:17:14.964432Z  INFO crash: &lt; Frame { frame_type: WindowUpdate, reserved: 0, stream_id: 0, payload: OpaquePayload { len: 4 } }
2022-10-20T10:17:14.964502Z  INFO crash: Reading frame (9 bytes so far)
</pre></div>
<p>Okay, well... there&#39;s no flags so far, but, just you wait. In our read loop,
if we get a settings frame that <em>doesn&#39;t</em> have the ACK flag, we send an ACK
ourselves:</p>
<div><p>Rust code</p><pre data-lang="rust">        <i>info</i><i>!</i><i>(</i><i>&#34;&lt; {frame:?}&#34;</i><i>)</i><i>;</i>
        <i>if</i> <i>let</i> <i>FrameType</i><i>::</i>Settings<i>(</i>flags<i>)</i> = <i>&amp;</i>frame<i>.</i><i>frame_type</i> {
            <i>if</i> !flags<i>.</i><i>contains</i><i>(</i><i>SettingsFlags</i><i>::</i>Ack<i>)</i> {
                <i>info</i><i>!</i><i>(</i><i>&#34;Acknowledging server settings&#34;</i><i>)</i><i>;</i>
                <i>let</i> settings = <i>Frame</i><i>::</i><i>new</i><i>(</i><i>FrameType</i><i>::</i>Settings<i>(</i><i>SettingsFlags</i><i>::</i>Ack<i>.</i><i>into</i><i>(</i><i>)</i><i>)</i>, <i>0</i><i>)</i><i>;</i>
                <i>info</i><i>!</i><i>(</i><i>&#34;&gt; {settings:?}&#34;</i><i>)</i><i>;</i>
                settings<i>.</i><i>write</i><i>(</i><i>&amp;</i><i>mut</i> stream<i>)</i><i>.</i>await?<i>;</i>
            }
        }
</pre></div>
<p>And with that, it&#39;s time to send a request! The way we do that is with a HEADERS
frame, which has a bunch of interesting flags:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>/// See https://httpwg.org/specs/rfc9113.html#rfc.section.6.2</i>
<i>#<i>[</i>bitflags<i>]</i></i>
<i>#<i>[</i>repr<i>(</i>u8<i>)</i><i>]</i></i>
<i>#<i>[</i>derive<i>(</i>Copy, Clone, Debug, PartialEq, Eq<i>)</i><i>]</i></i>
<i>pub</i> <i>enum</i> <i>HeadersFlags</i> {
    Priority = <i>0x20</i>,
    Padded = <i>0x08</i>,
    EndHeaders = <i>0x04</i>,
    EndStream = <i>0x01</i>,
}
</pre></div>
<p>(The <code>FrameType</code> enum, along with <code>FrameType::encode</code> and <code>FrameType::decode</code>,
must be adjusted as well.)</p>
<p>The payload of the <code>HEADERS</code> frame is a Header Block Fragment, which is encoded
with HPACK, that has its own RFC, <a href="https://httpwg.org/specs/rfc7541.html">RFC
7541</a>.</p>
<p>Luckily, there&#39;s also existing Rust implementations, which we&#39;ll just go ahead
and use. The <a href="https://lib.rs/crates/hpack">hpack</a> crate hasn&#39;t been touched in a
few years, let&#39;s hope it works just as well.</p>
<div><p>Shell session</p><pre data-lang="shell">$ cargo add hpack
    Updating crates.io index
      Adding hpack v0.3.0 to dependencies.
</pre></div><div>

<p>Mhh do we need to acknowledge the server SETTINGS frame before sending our
HEADERS frame?</p>
</div>
<p>I don&#39;t think so. Here&#39;s what <a href="https://httpwg.org/specs/rfc9113.html#preface">the RFC says</a>:</p>
<blockquote>
<p>To avoid unnecessary latency, clients are permitted to send additional frames to
the server immediately after sending the client connection preface, without
waiting to receive the server connection preface.</p>
</blockquote>
<p>But then:</p>
<blockquote>
<p>It is important to note, however, that the server connection preface SETTINGS
frame might include settings that necessarily alter how a client is expected to
communicate with the server. Upon receiving the SETTINGS frame, the client is
expected to honor any settings established. In some configurations, it is
possible for the server to transmit SETTINGS before the client sends additional
frames, providing an opportunity to avoid this issue.</p>
</blockquote>
<p>And by &#34;some configurations&#34;, I&#39;m assuming they mean the <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-7.8">Upgrade
mechanism</a>, which is
not the way we&#39;re doing HTTP/2 anyway, so... I guess let&#39;s see what happens.</p>
<p>Our request must happen over a new stream. Client-initiated streams must be
odd-numbered, and there are no streams so far, so let&#39;s pick 1. We don&#39;t have a
request body, so we can set <code>END_DATA</code> (which will half-close the stream), and
we only have a few headers, that will definitely fit in the initial <code>HEADERS</code>
frame, so we can set <code>END_HEADERS</code>.</p>
<p>Our complete request sending code now looks like:</p>
<div><p>Rust code</p><pre data-lang="rust">    <i>info</i><i>!</i><i>(</i><i>&#34;Writing preface&#34;</i><i>)</i><i>;</i>
    stream<i>.</i><i>write_all</i><i>(</i>h2<i>::</i>PREFACE<i>)</i><i>.</i>await?<i>;</i>

    <i>let</i> settings = <i>Frame</i><i>::</i><i>new</i><i>(</i><i>FrameType</i><i>::</i>Settings<i>(</i><i>Default</i><i>::</i><i>default</i><i>(</i><i>)</i><i>)</i>, <i>0</i><i>)</i><i>;</i>
    <i>info</i><i>!</i><i>(</i><i>&#34;&gt; {settings:?}&#34;</i><i>)</i><i>;</i>
    settings<i>.</i><i>write</i><i>(</i><i>&amp;</i><i>mut</i> stream<i>)</i><i>.</i>await?<i>;</i>

    <i>let</i> <i>mut</i> encoder = hpack<i>::</i><i>Encoder</i><i>::</i><i>new</i><i>(</i><i>)</i><i>;</i>
    <i>let</i> headers: <i>&amp;</i><i>[</i><i>(</i><i>&amp;</i><i>[</i><i>u8</i><i>]</i>, <i>&amp;</i><i>[</i><i>u8</i><i>]</i><i>)</i><i>]</i> = <i>&amp;</i><i>[</i>
        <i>(</i><i>b&#34;:method&#34;</i>, <i>b&#34;GET&#34;</i><i>)</i>,
        <i>(</i><i>b&#34;:path&#34;</i>, <i>b&#34;/&#34;</i><i>)</i>,
        <i>(</i><i>b&#34;:scheme&#34;</i>, <i>b&#34;https&#34;</i><i>)</i>,
        <i>(</i><i>b&#34;:authority&#34;</i>, <i>b&#34;example.org&#34;</i><i>)</i>,
        <i>(</i><i>b&#34;user-agent&#34;</i>, <i>b&#34;fasterthanlime/http-crash-course&#34;</i><i>)</i>,
        <i>// http://www.gnuterrypratchett.com/</i>
        <i>(</i><i>b&#34;x-clacks-overhead&#34;</i>, <i>b&#34;GNU Terry Pratchett&#34;</i><i>)</i>,
    <i>]</i><i>;</i>
    <i>let</i> <i>mut</i> headers_frame = <i>Frame</i><i>::</i><i>new</i><i>(</i>
        <i>FrameType</i><i>::</i>Headers<i>(</i><i>HeadersFlags</i><i>::</i>EndHeaders | <i>HeadersFlags</i><i>::</i>EndStream<i>)</i>,
        <i>1</i>,
    <i>)</i><i>;</i>
    headers_frame<i>.</i><i>payload</i><i>.</i><i>0</i> = encoder<i>.</i><i>encode</i><i>(</i>headers<i>.</i><i>iter</i><i>(</i><i>)</i><i>.</i><i>copied</i><i>(</i><i>)</i><i>)</i><i>;</i>
    <i>info</i><i>!</i><i>(</i><i>&#34;&gt; {headers_frame:?}&#34;</i><i>)</i><i>;</i>
    headers_frame<i>.</i><i>write</i><i>(</i><i>&amp;</i><i>mut</i> stream<i>)</i><i>.</i>await?<i>;</i>
</pre></div>
<p>Before we try it out, let&#39;s also add flags for the <code>DATA</code> frame, which <em>should</em> be
used by the server to send us the response body:</p>
<div><p>Rust code</p><pre data-lang="rust"><i>/// See https://httpwg.org/specs/rfc9113.html#DATA</i>
<i>#<i>[</i>bitflags<i>]</i></i>
<i>#<i>[</i>repr<i>(</i>u8<i>)</i><i>]</i></i>
<i>#<i>[</i>derive<i>(</i>Copy, Clone, Debug, PartialEq, Eq<i>)</i><i>]</i></i>
<i>pub</i> <i>enum</i> <i>DataFlags</i> {
    Padded = <i>0x08</i>,
    EndStream = <i>0x01</i>,
}
</pre></div>
<p>As before, the <code>FrameType</code> enum, and its <code>encode</code> and <code>decode</code> methods should
be adjusted.</p>
<p>And now, for the moment of truth:</p>
<div><p>Shell session</p><pre data-lang="shell">$ cargo run
   Compiling crash v0.1.0 (/home/amos/bearcove/crash)
    Finished dev [unoptimized + debuginfo] target(s) in 2.32s
     Running `target/debug/crash`
2022-10-20T12:39:16.427502Z  INFO crash: Setting up TLS
2022-10-20T12:39:16.447999Z  INFO crash: Performing DNS lookup
2022-10-20T12:39:16.460366Z  INFO crash: Establishing TCP connection...
2022-10-20T12:39:16.547827Z  INFO crash: Establishing TLS session...
2022-10-20T12:39:16.771621Z  INFO crash: Establishing HTTP/2 connection...
2022-10-20T12:39:16.771665Z  INFO crash: Writing preface
2022-10-20T12:39:16.771710Z  INFO crash: &gt; Frame { frame_type: Settings(BitFlags&lt;SettingsFlags&gt;(0b0)), reserved: 0, stream_id: 0, payload: OpaquePayload { len: 0 } }
2022-10-20T12:39:16.771909Z  INFO crash: &gt; Frame { frame_type: Headers(BitFlags&lt;HeadersFlags&gt;(0b101, EndStream | EndHeaders)), reserved: 0, stream_id: 1, payload: OpaquePayload { len: 90 } }
2022-10-20T12:39:16.772016Z  INFO crash: Reading frame (0 bytes so far)
2022-10-20T12:39:16.893181Z  INFO crash: &lt; Frame { frame_type: Settings(BitFlags&lt;SettingsFlags&gt;(0b0)), reserved: 0, stream_id: 0, payload: OpaquePayload { len: 30 } }
2022-10-20T12:39:16.893253Z  INFO crash: Acknowledging server settings
2022-10-20T12:39:16.893294Z  INFO crash: &gt; Frame { frame_type: Settings(BitFlags&lt;SettingsFlags&gt;(0b1, Ack)), reserved: 0, stream_id: 0, payload: OpaquePayload { len: 0 } }
2022-10-20T12:39:16.893408Z  INFO crash: Reading frame (13 bytes so far)
2022-10-20T12:39:16.979533Z  INFO crash: &lt; Frame { frame_type: WindowUpdate, reserved: 0, stream_id: 0, payload: OpaquePayload { len: 4 } }
2022-10-20T12:39:16.979605Z  INFO crash: Reading frame (12 bytes so far)
2022-10-20T12:39:16.979897Z  INFO crash: &lt; Frame { frame_type: Settings(BitFlags&lt;SettingsFlags&gt;(0b1, Ack)), reserved: 0, stream_id: 0, payload: OpaquePayload { len: 0 } }
2022-10-20T12:39:16.979966Z  INFO crash: Reading frame (67 bytes so far)
2022-10-20T12:39:16.980128Z  INFO crash: &lt; Frame { frame_type: Headers(BitFlags&lt;HeadersFlags&gt;(0b100, EndHeaders)), reserved: 0, stream_id: 1, payload: OpaquePayload { len: 175 } }
2022-10-20T12:39:16.980189Z  INFO crash: Reading frame (9 bytes so far)
2022-10-20T12:39:17.021026Z  INFO crash: Reading frame (11 bytes so far)
2022-10-20T12:39:17.021079Z  INFO crash: Reading frame (256 bytes so far)
2022-10-20T12:39:17.021119Z  INFO crash: Reading frame (512 bytes so far)
2022-10-20T12:39:17.021152Z  INFO crash: Reading frame (1024 bytes so far)
2022-10-20T12:39:17.021188Z  INFO crash: &lt; Frame { frame_type: Data(BitFlags&lt;DataFlags&gt;(0b1, EndStream)), reserved: 0, stream_id: 1, payload: OpaquePayload { len: 1256 } }
2022-10-20T12:39:17.021225Z  INFO crash: Reading frame (0 bytes so far)
^C
</pre></div>
<p>That looks <em>very</em> promising. Because the <code>HEADERS</code> frame we get back has the
<code>END_HEADERS</code> flag set, I&#39;m guessing all the response headers fit in there - we
can simply decode them.</p>
<p>And then, it also seems like the whole response fits in the following <code>DATA</code>
frame, because it has the <code>END_STREAM</code> flag set.</p>
<p>So, let&#39;s read those responses!</p>
<p>Outside our read loop, we can make an hpack decoder, and inside the loop,
we&#39;ll handle <code>HEADERS</code> and <code>DATA</code> frames:</p>
<div><p>Rust code</p><pre data-lang="rust">    <i>let</i> <i>mut</i> decoder = hpack<i>::</i><i>Decoder</i><i>::</i><i>new</i><i>(</i><i>)</i><i>;</i>
    <i>let</i> <i>mut</i> decoder = hpack<i>::</i><i>Decoder</i><i>::</i><i>new</i><i>(</i><i>)</i><i>;</i>

    <i>let</i> <i>mut</i> buf: <i>BytesMut</i> = <i>Default</i><i>::</i><i>default</i><i>(</i><i>)</i><i>;</i>
    <i>loop</i> {
        <i>info</i><i>!</i><i>(</i><i>&#34;Reading frame ({} bytes so far)&#34;</i>, buf.len<i>(</i><i>)</i><i>)</i><i>;</i>
        <i>if</i> stream<i>.</i><i>read_buf</i><i>(</i><i>&amp;</i><i>mut</i> buf<i>)</i><i>.</i>await? == <i>0</i> {
            <i>info</i><i>!</i><i>(</i><i>&#34;connection closed!&#34;</i><i>)</i><i>;</i>
            <i>return</i> Ok<i>(</i><i>(</i><i>)</i><i>)</i><i>;</i>
        }

        <i>let</i> slice = <i>&amp;</i>buf<i>[</i>..<i>]</i><i>;</i>
        <i>let</i> frame = <i>match</i> <i>Frame</i><i>::</i><i>parse</i><i>(</i>slice<i>)</i> {
            Ok<i>(</i><i>(</i>rest, frame<i>)</i><i>)</i> =&gt; {
                buf = buf<i>.</i><i>split_off</i><i>(</i>slice<i>.</i><i>offset</i><i>(</i>rest<i>)</i><i>)</i><i>;</i>
                frame
            }
            Err<i>(</i>e<i>)</i> =&gt; {
                <i>if</i> e<i>.</i><i>is_incomplete</i><i>(</i><i>)</i> {
                    <i>// keep reading!</i>
                    <i>continue</i><i>;</i>
                }
                <i>panic</i><i>!</i><i>(</i><i>&#34;parse error: {e}&#34;</i><i>)</i><i>;</i>
            }
        }<i>;</i>

        <i>info</i><i>!</i><i>(</i><i>&#34;&lt; {frame:?}&#34;</i><i>)</i><i>;</i>
        <i>match</i> <i>&amp;</i>frame<i>.</i><i>frame_type</i> {
            <i>FrameType</i><i>::</i>Settings<i>(</i>flags<i>)</i> =&gt; {
                <i>if</i> !flags<i>.</i><i>contains</i><i>(</i><i>SettingsFlags</i><i>::</i>Ack<i>)</i> {
                    <i>info</i><i>!</i><i>(</i><i>&#34;Acknowledging server settings&#34;</i><i>)</i><i>;</i>
                    <i>let</i> settings = <i>Frame</i><i>::</i><i>new</i><i>(</i><i>FrameType</i><i>::</i>Settings<i>(</i><i>SettingsFlags</i><i>::</i>Ack<i>.</i><i>into</i><i>(</i><i>)</i><i>)</i>, <i>0</i><i>)</i><i>;</i>
                    <i>info</i><i>!</i><i>(</i><i>&#34;&gt; {settings:?}&#34;</i><i>)</i><i>;</i>
                    settings<i>.</i><i>write</i><i>(</i><i>&amp;</i><i>mut</i> stream<i>)</i><i>.</i>await?<i>;</i>
                }
            }
            <i>FrameType</i><i>::</i>Headers<i>(</i>flags<i>)</i> =&gt; {
                <i>assert</i><i>!</i><i>(</i>
                    !flags.contains<i>(</i>HeadersFlags::Padded<i>)</i>,
                    <i>&#34;padding not supported&#34;</i>
                <i>)</i><i>;</i>
                <i>assert</i><i>!</i><i>(</i>
                    !flags.contains<i>(</i>HeadersFlags::Priority<i>)</i>,
                    <i>&#34;priority not supported&#34;</i>
                <i>)</i><i>;</i>
                <i>assert</i><i>!</i><i>(</i>
                    flags.contains<i>(</i>HeadersFlags::EndHeaders<i>)</i>,
                    <i>&#34;continuation frames not supported&#34;</i>
                <i>)</i><i>;</i>

                <i>let</i> headers = decoder<i>.</i><i>decode</i><i>(</i><i>&amp;</i>frame<i>.</i><i>payload</i><i>.</i><i>0</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
                <i>for</i> <i>(</i>name, value<i>)</i> <i>in</i> headers {
                    <i>info</i><i>!</i><i>(</i>
                        <i>&#34;response header: {}: {}&#34;</i>,
                        String::from_utf8_lossy<i>(</i>&amp;name<i>)</i>,
                        String::from_utf8_lossy<i>(</i>&amp;value<i>)</i>
                    <i>)</i><i>;</i>
                }
            }
            <i>FrameType</i><i>::</i>Data<i>(</i>flags<i>)</i> =&gt; {
                <i>assert</i><i>!</i><i>(</i>!flags.contains<i>(</i>DataFlags::Padded<i>)</i>, <i>&#34;padding not supported&#34;</i><i>)</i><i>;</i>
                <i>assert</i><i>!</i><i>(</i>
                    flags.contains<i>(</i>DataFlags::EndStream<i>)</i>,
                    <i>&#34;streaming response bodies not supported&#34;</i>
                <i>)</i><i>;</i>

                <i>let</i> response_body = <i>String</i><i>::</i><i>from_utf8_lossy</i><i>(</i><i>&amp;</i>frame<i>.</i><i>payload</i><i>.</i><i>0</i><i>)</i><i>;</i>
                <i>info</i><i>!</i><i>(</i>
                    <i>&#34;response body: {}&#34;</i>,
                    &amp;response_body<i>[</i>..std::cmp::min<i>(</i><i>100</i>, response_body.len<i>(</i><i>)</i><i>)</i><i>]</i>
                <i>)</i><i>;</i>

                <i>info</i><i>!</i><i>(</i><i>&#34;All done!&#34;</i><i>)</i><i>;</i>
                <i>return</i> Ok<i>(</i><i>(</i><i>)</i><i>)</i><i>;</i>
            }
            _ =&gt; {
                <i>// ignore other types of frames</i>
            }
        }
    }
</pre></div>
<p>And.. let&#39;s try it out!</p>
<div><p>Shell session</p><pre data-lang="shell">$ cargo run
   Compiling crash v0.1.0 (/home/amos/bearcove/crash)
    Finished dev [unoptimized + debuginfo] target(s) in 2.01s
     Running `target/debug/crash`
2022-10-20T12:51:17.223557Z  INFO crash: Setting up TLS
2022-10-20T12:51:17.244862Z  INFO crash: Performing DNS lookup
2022-10-20T12:51:17.261562Z  INFO crash: Establishing TCP connection...
2022-10-20T12:51:17.353975Z  INFO crash: Establishing TLS session...
2022-10-20T12:51:17.557466Z  INFO crash: Establishing HTTP/2 connection...
2022-10-20T12:51:17.557511Z  INFO crash: Writing preface
2022-10-20T12:51:17.557594Z  INFO crash: &gt; Frame { frame_type: Settings(BitFlags&lt;SettingsFlags&gt;(0b0)), reserved: 0, stream_id: 0, payload: OpaquePayload { len: 0 } }
2022-10-20T12:51:17.557714Z  INFO crash: &gt; Frame { frame_type: Headers(BitFlags&lt;HeadersFlags&gt;(0b101, EndStream | EndHeaders)), reserved: 0, stream_id: 1, payload: OpaquePayload { len: 90 } }
2022-10-20T12:51:17.557798Z  INFO crash: Reading frame (0 bytes so far)
2022-10-20T12:51:17.649268Z  INFO crash: &lt; Frame { frame_type: Settings(BitFlags&lt;SettingsFlags&gt;(0b0)), reserved: 0, stream_id: 0, payload: OpaquePayload { len: 30 } }
2022-10-20T12:51:17.649344Z  INFO crash: Acknowledging server settings
2022-10-20T12:51:17.649371Z  INFO crash: &gt; Frame { frame_type: Settings(BitFlags&lt;SettingsFlags&gt;(0b1, Ack)), reserved: 0, stream_id: 0, payload: OpaquePayload { len: 0 } }
2022-10-20T12:51:17.649512Z  INFO crash: Reading frame (13 bytes so far)
2022-10-20T12:51:17.732283Z  INFO crash: &lt; Frame { frame_type: WindowUpdate, reserved: 0, stream_id: 0, payload: OpaquePayload { len: 4 } }
2022-10-20T12:51:17.732356Z  INFO crash: Reading frame (12 bytes so far)
2022-10-20T12:51:17.732416Z  INFO crash: &lt; Frame { frame_type: Settings(BitFlags&lt;SettingsFlags&gt;(0b1, Ack)), reserved: 0, stream_id: 0, payload: OpaquePayload { len: 0 } }
2022-10-20T12:51:17.732465Z  INFO crash: Reading frame (67 bytes so far)
2022-10-20T12:51:17.732529Z  INFO crash: &lt; Frame { frame_type: Headers(BitFlags&lt;HeadersFlags&gt;(0b100, EndHeaders)), reserved: 0, stream_id: 1, payload: OpaquePayload { len: 176 } }
2022-10-20T12:51:17.742680Z  INFO crash: response header: :status: 200
amos@sonic ~/bearcove/crash main*
❯ cargo run
   Compiling crash v0.1.0 (/home/amos/bearcove/crash)
    Finished dev [unoptimized + debuginfo] target(s) in 2.15s
     Running `target/debug/crash`
2022-10-20T12:55:38.526593Z  INFO crash: Setting up TLS
2022-10-20T12:55:38.547786Z  INFO crash: Performing DNS lookup
2022-10-20T12:55:38.597677Z  INFO crash: Establishing TCP connection...
2022-10-20T12:55:38.706586Z  INFO crash: Establishing TLS session...
2022-10-20T12:55:38.897806Z  INFO crash: Establishing HTTP/2 connection...
2022-10-20T12:55:38.897853Z  INFO crash: Writing preface
2022-10-20T12:55:38.897915Z  INFO crash: &gt; Frame { frame_type: Settings(BitFlags&lt;SettingsFlags&gt;(0b0)), reserved: 0, stream_id: 0, payload: OpaquePayload { len: 0 } }
2022-10-20T12:55:38.898052Z  INFO crash: &gt; Frame { frame_type: Headers(BitFlags&lt;HeadersFlags&gt;(0b101, EndStream | EndHeaders)), reserved: 0, stream_id: 1, payload: OpaquePayload { len: 90 } }
2022-10-20T12:55:38.898135Z  INFO crash: Reading frame (0 bytes so far)
2022-10-20T12:55:38.986090Z  INFO crash: &lt; Frame { frame_type: Settings(BitFlags&lt;SettingsFlags&gt;(0b0)), reserved: 0, stream_id: 0, payload: OpaquePayload { len: 30 } }
2022-10-20T12:55:38.987852Z  INFO crash: Acknowledging server settings
2022-10-20T12:55:38.987898Z  INFO crash: &gt; Frame { frame_type: Settings(BitFlags&lt;SettingsFlags&gt;(0b1, Ack)), reserved: 0, stream_id: 0, payload: OpaquePayload { len: 0 } }
2022-10-20T12:55:38.987999Z  INFO crash: Reading frame (13 bytes so far)
2022-10-20T12:55:39.079214Z  INFO crash: &lt; Frame { frame_type: WindowUpdate, reserved: 0, stream_id: 0, payload: OpaquePayload { len: 4 } }
2022-10-20T12:55:39.079273Z  INFO crash: Reading frame (12 bytes so far)
2022-10-20T12:55:39.079338Z  INFO crash: &lt; Frame { frame_type: Settings(BitFlags&lt;SettingsFlags&gt;(0b1, Ack)), reserved: 0, stream_id: 0, payload: OpaquePayload { len: 0 } }
2022-10-20T12:55:39.079377Z  INFO crash: Reading frame (67 bytes so far)
2022-10-20T12:55:39.079403Z  INFO crash: &lt; Frame { frame_type: Headers(BitFlags&lt;HeadersFlags&gt;(0b100, EndHeaders)), reserved: 0, stream_id: 1, payload: OpaquePayload { len: 175 } }
2022-10-20T12:55:39.088713Z  INFO crash: response header: :status: 200
2022-10-20T12:55:39.088747Z  INFO crash: response header: age: 524935
2022-10-20T12:55:39.088793Z  INFO crash: response header: cache-control: max-age=604800
2022-10-20T12:55:39.088819Z  INFO crash: response header: content-type: text/html; charset=UTF-8
2022-10-20T12:55:39.088834Z  INFO crash: response header: date: Thu, 20 Oct 2022 12:55:39 GMT
2022-10-20T12:55:39.088850Z  INFO crash: response header: etag: &#34;3147526947+ident&#34;
2022-10-20T12:55:39.088865Z  INFO crash: response header: expires: Thu, 27 Oct 2022 12:55:39 GMT
2022-10-20T12:55:39.088881Z  INFO crash: response header: last-modified: Thu, 17 Oct 2019 07:18:26 GMT
2022-10-20T12:55:39.088908Z  INFO crash: response header: server: ECS (dcb/7F84)
2022-10-20T12:55:39.088923Z  INFO crash: response header: vary: Accept-Encoding
2022-10-20T12:55:39.088939Z  INFO crash: response header: x-cache: HIT
2022-10-20T12:55:39.088968Z  INFO crash: response header: content-length: 1256
2022-10-20T12:55:39.088985Z  INFO crash: Reading frame (9 bytes so far)
2022-10-20T12:55:39.126261Z  INFO crash: Reading frame (11 bytes so far)
2022-10-20T12:55:39.126332Z  INFO crash: Reading frame (256 bytes so far)
2022-10-20T12:55:39.126367Z  INFO crash: Reading frame (512 bytes so far)
2022-10-20T12:55:39.126411Z  INFO crash: Reading frame (1024 bytes so far)
2022-10-20T12:55:39.126460Z  INFO crash: &lt; Frame { frame_type: Data(BitFlags&lt;DataFlags&gt;(0b1, EndStream)), reserved: 0, stream_id: 1, payload: OpaquePayload { len: 1256 } }
2022-10-20T12:55:39.126519Z  INFO crash: response body: &lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Example Domain&lt;/title&gt;

    &lt;meta charset=&#34;utf-8&#34; /&gt;
    &lt;m
2022-10-20T12:55:39.126552Z  INFO crash: All done!
</pre></div>
<p>And that&#39;s it!</p>
<p>We&#39;ve made an http/2 request all by ourselves, re-using &#34;only&#34; DNS, TCP, TLS,
and HPACK.</p>
<div>

<p>You want to throw Ethernet in there for good measure or?</p>
</div>
<p>Nah, I&#39;m good. Now that we&#39;ve implemented HTTP/1.1 and HTTP/2 (minimally), we
can properly compare them.</p>

                        <h2>
                            <a id="http-semantics-over-http-2" href="#http-semantics-over-http-2">
                                HTTP semantics over HTTP/2
                            </a>
                        </h2>
                        
<p>In HTTP/1.1, the &#34;Host&#34; header is used to pick &#34;which of the virtual servers
behind this IP address we&#39;re trying to reach&#34;. And we mentioned that it can be
an issue if it doesn&#39;t match the hostname passed in the SNI extension during the
TLS handshake.</p>
<p>HTTP/2 has that same issue (except the <code>:authority</code> pseudo-header is used
instead), and more! Because HTTP/2 allows <em>pushing responses</em>, before the client
even knows it wants them.</p>
<p>Here&#39;s what <a href="https://httpwg.org/specs/rfc9113.html#PushResources">RFC 9113 says</a> about it:</p>
<blockquote>
<p>Server push was designed to allow a server to improve client-perceived performance by <strong>predicting what requests will follow those that it receives</strong>, thereby removing a round trip for them.</p>
<p>For example, a request for HTML is often followed by requests for stylesheets and scripts referenced by that page. When these requests are pushed, the client does not need to wait to receive the references to them in the HTML and issue separate requests.</p>
</blockquote>
<p>But also:</p>
<blockquote>
<p>In practice, server push is difficult to use effectively, because it requires the server to correctly anticipate the additional requests the client will make, taking into account factors such as caching, content negotiation, and user behavior.</p>
<p>Errors in prediction can lead to <strong>performance degradation</strong>, due to the opportunity cost that the additional data on the wire represents. In particular, pushing any significant amount of data can cause contention issues with responses that are more important.</p>
</blockquote>
<p>In practice, the world is moving towards <a href="https://html.spec.whatwg.org/multipage/semantics.html#early-hints">early
hints</a>
instead, which works over HTTP/1.1, 2, and 3, although <a href="https://httpwg.org/specs/rfc8297.html#security-considerations">RFC 8297
warns about compatibility</a>:</p>
<blockquote>
<p>Some clients might have issues handling a 103 (Early Hints) response, because informational responses are rarely used in reply to requests not including an Expect header field.</p>
<p>In particular, an HTTP/1.1 client that mishandles an informational response as a final response <strong>is likely to consider all responses to the succeeding requests sent over the same connection to be part of the final response</strong>. Such behavior might constitute a cross-origin information disclosure vulnerability in case the client multiplexes requests to different origins onto a single persistent connection.</p>
<p>Therefore, a server might refrain from sending 103 (Early Hints) responses over HTTP/1.1 unless the client is known to handle informational responses correctly.</p>
</blockquote>
<p>Isn&#39;t that fun? I haven&#39;t even talked about informational responses in this
article yet, and it&#39;s already long enough that I&#39;ll get e-mails about how it
should&#39;ve been a series instead (the chunked transfer-encoding of fasterthanlime
writing).</p>
<p>Besides being hard to use <em>properly</em>, HTTP/2 push can only be used for evil.
Servers can push responses for <em>any</em> <code>:authority</code>, and it&#39;s up to the client to
check that the server is, in fact, authoritative.</p>
<p>So just making your server well-behaved doesn&#39;t protect your web application.
Every <em>client</em> implementation must be secure against that (or disable HTTP/2
push altogether, which I&#39;d probably advise doing, at this point).</p>
<p>The <em>happy path</em> of HTTP/2 is pretty clear: a single HTTP/2 connection is
&#34;simply&#34; a bundle of (bidirectional) streams, which feel a lot like TCP
connections, except the concept of headers (and trailers) is baked into the
framing format, so there&#39;s a lot less opportunity for accidentally interpreting
part of the headers as the body, or vice versa.</p>
<p>Chunked transfer encoding doesn&#39;t really exist in HTTP/2 anymore, or rather,
it&#39;s the default: each &#34;chunk&#34; is a <code>DATA</code> frame, and the last one has the
<code>END_DATA</code> flag set, whether it&#39;s empty or not.</p>
<p>HTTP/2 doesn&#39;t use hexadecimal encoding for numbers anymore (which HTTP/1.1 used
for chunk lengths), and... one would hope it doesn&#39;t use decimal encoding
anymore, but...</p>
<div>

<p>Actually yeah, what happens to the <code>content-length</code> header?</p>
</div>
<p>...that&#39;s an excellent question! Which reminds me, as of HTTP/2, all header
names are lowercased, which is the Correct Decision (don&#39;t @ me):</p>
<blockquote>
<p>Field names MUST be converted to lowercase when constructing an HTTP/2 message.</p>
<p><a href="https://httpwg.org/specs/rfc9113.html#HttpHeaders">https://httpwg.org/specs/rfc9113.html#HttpHeaders</a></p>
</blockquote>
<p>The <code>content-length</code> header is <em>still</em> a thing, if you want to, but it <em>must</em>
be correct, or else the message is malformed:</p>
<blockquote>
<p>A request or response that includes message content can include a content-length header field. A request or response is also malformed if the value of a content-length header field does not equal the sum of the DATA frame payload lengths that form the content...</p>
</blockquote>
<p>Of course there&#39;s a catch:</p>
<blockquote>
<p>...unless the message is defined as having no content. For example, 204 or 304 responses contain no content, as does the response to a HEAD request. A response that is defined to have no content, as described in Section 6.4.1 of HTTP, MAY have a non-zero content-length header field, even though no content is included in DATA frames.</p>
</blockquote>
<p>204 here being &#34;No Content&#34; (the response to a HEAD request), and 304 being &#34;Not
Modified&#34; (the response to a conditional request, that tells the server &#34;what
version of the cacheable resource we have&#34;).</p>
<p>For request bodies, the same applies: you can set a <code>content-length</code> header, but
you better make sure it matches the data you send. Chunked transfer encoding is
also deprecated / the default here, they&#39;re just DATA frames on the same stream,
in the client-&gt;server direction.</p>
<p>Things get more interesting when you start thinking about what happens when a
LOT of concurrent requests are done over the same HTTP/2 connection.</p>
<p>Before we even have to think about flow control, there&#39;s the question of stream
IDs. We have <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">{2^{31}}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>2</span><span><span><span><span><span><span></span><span><span><span>31</span></span></span></span></span></span></span></span></span></span></span></span></span> stream IDs available (that&#39;s 2 million). Can we run out
of them?</p>
<p>Yes we can. Without even sending 2 million requests. The only requirement when
generating a new stream ID is that it must be &#34;numerically greater than all the
streams that the initiating endpoint has opened or reserved&#34;.</p>
<p>What happens when we run out of stream identifiers? It&#39;s easy for a client: they
just open another HTTP/2 connection and go on about their business. For a
server, it&#39;s a bit more awkward — they have to politely ask the client to
go away. With a <code>GOAWAY</code> frame.</p>
<p>This is interesting, because it means HTTP/2 can send errors out-of-band. In
HTTP/1.1 land, if there&#39;s an error <em>while generating the body</em>, you&#39;re out of
luck. Well, you can send some
<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Trailer">trailers</a>
maybe.</p>
<p>But just because an HTTP/2 server sends a <code>GOAWAY</code>, doesn&#39;t mean the whole
connection can be thrown away! There might still be several requests or
responses in-flight, which must be allowed to gracefully complete.</p>
<p>And there&#39;s a smörgåsbord of potential race conditions here: if the client
receives a <code>GOAWAY</code>, how does it know which of the requests it has sent have
been accepted by the server? Well, it knows because in the <code>GOAWAY</code> payload,
a &#34;last stream ID&#34; is specified (along with an error code and some optional,
additional debug data).</p>
<p>So, from the perspective of the server, we might have:</p>
<ul>
<li>Receive <code>HEADERS</code> for stream 1</li>
<li>Receive <code>HEADERS</code> for stream 3</li>
<li>Receive <code>HEADERS</code> for stream 5</li>
<li>Decide to do graceful shutdown, send <code>GOAWAY</code> with last stream id 5</li>
</ul>
<p>And from the perspective of the client, we might have:</p>
<ul>
<li>Send <code>HEADERS</code> for stream 1</li>
<li>Send <code>HEADERS</code> for stream 3</li>
<li>Send <code>HEADERS</code> for stream 5</li>
<li>Send <code>HEADERS</code> for stream 7</li>
<li>Send <code>HEADERS</code> for stream 9</li>
<li>Send <code>HEADERS</code> for stream 11</li>
<li>Receive <code>GOAWAY</code> with last stream id of 5</li>
</ul>
<p>And the client should know that requests 7, 9, and 11 will <em>not</em> be processed by
the server and should be retried elsewhere.</p>
<p>This isn&#39;t something that can be really achieved with HTTP/1.1. If the TCP
connection is closed without returning a response header, there&#39;s <em>no telling</em>
what the server actually did. Returning a 429 (<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429">Too Many
Requests</a>) or a
503 (<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/503">Service
Unavailable</a>) may
indicate that a request is safe to retry, but that&#39;s backend-dependent. If you&#39;re
writing a proxy, well... you need special response headers to indicate whether
those came from the app you&#39;re proxying to, or the proxy itself.</p>
<p>I love how optimistic some web documentation is, by the way: did you know the
<code>Retry-After</code> header for 503 indicates &#34;how long the service is expected to be
unavailable&#34; (according to MDN)? Does anyone use this for schedule maintenance,
and return a value other than &#34;idk try again in a couple seconds I guess&#34;?</p>
<p>If you do, please send me a message. I always love to be proven wrong.</p>
<p>Flow control is a rich bug area with HTTP/2. We&#39;ve already seen that either
peer can send <code>WINDOW_UPDATE</code> frames whenever they feel like it. But they
can also send a <code>SETTINGS_INITIAL_WINDOW_SIZE</code> as part of the <code>SETTINGS</code> frame,
which, as you may or may not remember, the client doesn&#39;t need to wait for,
before sending requests.</p>
<p>That means the initial window size can be retroactively changed, and the
relevant passage from the RFC is just delicious:</p>
<blockquote>
<p>A change to SETTINGS_INITIAL_WINDOW_SIZE can cause the available space in a flow-control window to <strong>become negative</strong>. A sender MUST track the negative flow-control window and MUST NOT send new flow-controlled frames until it receives WINDOW_UPDATE frames that cause the flow-control window to become positive.</p>
<p>For example, if the client sends 60 KB immediately on connection establishment and the server sets the initial window size to be 16 KB, the client will recalculate the available flow-control window to be -44 KB on receipt of the SETTINGS frame. The client retains a negative flow-control window until WINDOW_UPDATE frames restore the window to being positive, after which the client can resume sending.</p>
</blockquote>
<p>Furthermore, the size of the flow-control window for a stream can be changed by
sending a <code>SETTINGS</code> frame, but again, since everything is asynchronous, the
peer that sent that frame must be prepared to receive <em>more</em> data than allowed
by the new window size, until the <code>SETTINGS</code> frame is acknowledged.</p>
<div>

<p>But what if the <code>SETTINGS</code> frame is never acknowledged?</p>
</div>
<p>Ah, well <a href="https://httpwg.org/specs/rfc9113.html#SettingsSync">the RFC covers that</a>:</p>
<blockquote>
<p>If the sender of a SETTINGS frame does not receive an acknowledgment within a reasonable amount of time, it MAY issue a connection error (Section 5.4.1) of type SETTINGS_TIMEOUT. In setting a timeout, some allowance needs to be made for processing delays at the peer; a timeout that is solely based on the round-trip time between endpoints might result in spurious errors.</p>
</blockquote>
<p>A less nuclear option is to yeet a single stream (the one that&#39;s going over its
flow-control window):</p>
<blockquote>
<p>The receiver MAY instead send a RST_STREAM with an error code of FLOW_CONTROL_ERROR for the affected streams.</p>
</blockquote>
<p>This is important because, again: in HTTP/1.1, you can simply close the TCP
connection, but in HTTP/2, you must act on the <em>stream</em> level, where all streams
share the same TCP connection.</p>
<p>And that&#39;s neat if you&#39;re monitoring your HTTP endpoints because, in HTTP/1.1,
if you change your mind about making a specific HTTP request for example, all
you can do is close the TCP connection in the middle of the server streaming
the response back to you.</p>
<p>The server will never know if you went away by choice, or through an unfortunate
sequence of events (loss of connectivity, OOM-kill, etc.). But with HTTP/2,
you <em>can</em> send a <code>RST_STREAM</code> with the <code>CANCEL</code> error message.</p>
<p>(Chances are your HTTP/2 client won&#39;t do that, but it <em>could</em>. I like having
at least the <em>option</em> of doing things properly).</p>
<p>That&#39;s not the end of flow control &#34;fun&#34;. In section 10.5 (Denial-of-Service
Considerations) of RFC 9113, we learn about whole new categories of things to
fear.</p>
<p>Some are pretty basic: spamming <code>SETTINGS</code> frames (each of them requiring a
separate acknowledgement), or <code>PING</code> frames, or sending <code>WINDOW_UPDATE</code> frames
with a tiny increment, forcing the other peer to generate a <em>lot</em> of tiny <code>DATA</code>
frames.</p>
<p>But some of the most &#34;entertaining&#34; ones have to do with the interaction of TCP
and HTTP/2 flow control:</p>
<blockquote>
<p>An attacker can provide large amounts of flow-control credit at the HTTP/2 layer but withhold credit at the TCP layer, preventing frames from being sent. An endpoint that constructs and remembers frames for sending without considering TCP limits might be subject to resource exhaustion.</p>
</blockquote>
<p>And of course, because compression is involved in headers now, a whole other
series of attacks becomes relevant, like
<a href="https://en.wikipedia.org/wiki/CRIME">CRIME</a>, which stands for &#34;Compression
Ratio Info-leak Made Easy&#34;, and involves guessing a header value by chosen
plaintext:</p>
<blockquote>
<p>(..) the attacker being able to observe the size of the ciphertext sent by the browser while at the same time inducing the browser to make multiple carefully crafted web connections to the target site.</p>
<p>The attacker then <strong>observes the change in size of the compressed request payload</strong>, which contains both the secret cookie that is sent by the browser only to the target site, and variable content created by the attacker, as the variable content is altered.</p>
<p><strong>When the size of the compressed content is reduced</strong>, it can be inferred that it is probable that some part of the injected content matches some part of the source, which includes the secret content that the attacker desires to discover.</p>
</blockquote>
<p>As I said. Very entertaining.</p>

                        <h2>
                            <a id="bugs-bugs-bugs" href="#bugs-bugs-bugs">
                                Bugs, bugs, bugs!
                            </a>
                        </h2>
                        
<p>Originally I started writing this article to tell y&#39;all about a funny bug we had
at work, but it&#39;s been a month, and two things happened:</p>
<ul>
<li>I decided it would be a swell idea to let this article turn into &#34;let&#39;s
implement H1+H2 from semi-scratch&#34;</li>
<li>We&#39;ve had other, gnarlier H2 bugs that I don&#39;t have explanations for, yet.</li>
</ul>
<p>Looking back at the original (internal) write-up I did for the bug, I&#39;m not sure
I even understand it anymore. I&#39;ve tried coming up with a small reproduction for
this article, but I failed at both the &#34;small&#34; and &#34;reproduction&#34; aspects of
that endeavor.</p>
<p>So instead, we shall be looking at another fun bug!</p>
<p>Here&#39;s my test code:</p>
<div><p>TOML markup</p><pre data-lang="toml"><i># in `h2-repro/Cargo.toml`</i>

<i>[</i><i>package</i><i>]</i>
<i>name</i> <i>=</i> <i>&#34;h2-repro&#34;</i>
<i>version</i> <i>=</i> <i>&#34;0.1.0&#34;</i>
<i>edition</i> <i>=</i> <i>&#34;2021&#34;</i>

<i>[</i><i>dependencies</i><i>]</i>
<i>color-eyre</i> <i>=</i> <i>&#34;0.6.2&#34;</i>
<i>hyper</i> <i>=</i> <i>{</i> <i>version</i> <i>=</i> <i>&#34;0.14.20&#34;</i><i>,</i> <i>features</i> <i>=</i> <i>[</i><i>&#34;client&#34;</i><i>,</i> <i>&#34;server&#34;</i><i>,</i> <i>&#34;http2&#34;</i><i>,</i> <i>&#34;tcp&#34;</i><i>]</i> <i>}</i>
<i>tokio</i> <i>=</i> <i>{</i> <i>version</i> <i>=</i> <i>&#34;1.21.2&#34;</i><i>,</i> <i>features</i> <i>=</i> <i>[</i><i>&#34;full&#34;</i><i>]</i> <i>}</i>
<i>tracing</i> <i>=</i> <i>&#34;0.1.37&#34;</i>
<i>tracing-subscriber</i> <i>=</i> <i>{</i> <i>version</i> <i>=</i> <i>&#34;0.3.16&#34;</i> <i>}</i>
</pre></div><div><p>Rust code</p><pre data-lang="rust"><i>// in `in h2-repro/src/main.rs`</i>

<i>use</i> std<i>::</i>{convert<i>::</i>Infallible, net<i>::</i>TcpListener, str<i>::</i>FromStr, time<i>::</i>Duration}<i>;</i>

<i>use</i> color_eyre<i>::</i>eyre<i>;</i>
<i>use</i> hyper<i>::</i>{
    body<i>::</i>Bytes,
    client<i>::</i>HttpConnector,
    service<i>::</i>{make_service_fn, service_fn},
    Body, Client, Method, Request, Response,
}<i>;</i>
<i>use</i> tokio<i>::</i>sync<i>::</i>mpsc<i>;</i>
<i>use</i> tracing<i>::</i>{error, info}<i>;</i>
<i>use</i> tracing_subscriber<i>::</i>{filter<i>::</i>Targets, layer<i>::</i>SubscriberExt, util<i>::</i>SubscriberInitExt}<i>;</i>

<i>#<i>[</i>tokio<i>::</i>main<i>]</i></i>
async <i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>real_main</i><i>(</i><i>)</i><i>.</i>await<i>.</i><i>unwrap</i><i>(</i><i>)</i>
}

async <i>fn</i> <i>real_main</i><i>(</i><i>)</i> -&gt; eyre<i>::</i><i>Result</i><i>&lt;</i><i>(</i><i>)</i><i>&gt;</i> {
    color_eyre<i>::</i><i>install</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>

    <i>let</i> filter_layer =
        <i>Targets</i><i>::</i><i>from_str</i><i>(</i>std<i>::</i>env<i>::</i><i>var</i><i>(</i><i>&#34;RUST_LOG&#34;</i><i>)</i><i>.</i><i>as_deref</i><i>(</i><i>)</i><i>.</i><i>unwrap_or</i><i>(</i><i>&#34;info&#34;</i><i>)</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
    <i>let</i> format_layer = tracing_subscriber<i>::</i>fmt<i>::</i><i>layer</i><i>(</i><i>)</i><i>;</i>
    tracing_subscriber<i>::</i><i>registry</i><i>(</i><i>)</i>
        <i>.</i><i>with</i><i>(</i>filter_layer<i>)</i>
        <i>.</i><i>with</i><i>(</i>format_layer<i>)</i>
        <i>.</i><i>init</i><i>(</i><i>)</i><i>;</i>

    <i>let</i> h2_max_streams: <i>u32</i> = std<i>::</i>env<i>::</i><i>var</i><i>(</i><i>&#34;H2_MAX_STREAMS&#34;</i><i>)</i>
        <i>.</i><i>map</i><i>(</i>|s| s<i>.</i><i>parse</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>)</i>
        <i>.</i><i>unwrap_or</i><i>(</i><i>50</i><i>)</i><i>;</i>
    <i>let</i> h2_requests = std<i>::</i>env<i>::</i><i>var</i><i>(</i><i>&#34;H2_REQUESTS&#34;</i><i>)</i>
        <i>.</i><i>map</i><i>(</i>|s| s<i>.</i><i>parse</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>)</i>
        <i>.</i><i>unwrap_or</i><i>(</i><i>100</i><i>)</i><i>;</i>

    <i>info</i><i>!</i><i>(</i><i>&#34;{h2_requests} requests on {h2_max_streams} streams&#34;</i><i>)</i><i>;</i>
    <i>info</i><i>!</i><i>(</i><i>&#34;(Set $H2_REQUESTS and $H2_MAX_STREAMS environment variables to adjust)&#34;</i><i>)</i><i>;</i>

    <i>run_test</i><i>(</i><i>false</i>, h2_max_streams, h2_requests<i>)</i><i>.</i>await?<i>;</i>
    <i>run_test</i><i>(</i><i>true</i>, h2_max_streams, h2_requests<i>)</i><i>.</i>await?<i>;</i>

    Ok<i>(</i><i>(</i><i>)</i><i>)</i>
}

async <i>fn</i> <i>run_test</i><i>(</i><i>h2_only</i>: <i>bool</i>, <i>h2_max_streams</i>: <i>u32</i>, <i>h2_requests</i>: <i>u32</i><i>)</i> -&gt; eyre<i>::</i><i>Result</i><i>&lt;</i><i>(</i><i>)</i><i>&gt;</i> {
    <i>let</i> prefix = <i>if</i> h2_only { <i>&#34;H2&#34;</i> } <i>else</i> { <i>&#34;H1&#34;</i> }<i>;</i>

    <i>let</i> ln = <i>TcpListener</i><i>::</i><i>bind</i><i>(</i><i>&#34;[::]:0&#34;</i><i>)</i>?<i>;</i>
    <i>let</i> addr = ln<i>.</i><i>local_addr</i><i>(</i><i>)</i>?<i>;</i>
    <i>let</i> server = hyper<i>::</i>server<i>::</i><i>Server</i><i>::</i><i>from_tcp</i><i>(</i>ln<i>)</i>?
        <i>.</i><i>http2_max_concurrent_streams</i><i>(</i>h2_max_streams<i>)</i>
        <i>.</i><i>http2_only</i><i>(</i>h2_only<i>)</i>
        <i>.</i><i>serve</i><i>(</i><i>make_service_fn</i><i>(</i>|_conn| async {
            Ok<i>::</i><i>&lt;</i><i>_</i>, <i>Infallible</i><i>&gt;</i><i>(</i><i>service_fn</i><i>(</i>sample_endpoint<i>)</i><i>)</i>
        }<i>)</i><i>)</i><i>;</i>

    <i>let</i> _server_jh = tokio<i>::</i><i>spawn</i><i>(</i>async <i>move</i> {
        server<i>.</i>await<i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
    }<i>)</i><i>;</i>

    <i>let</i> client = <i>Client</i><i>::</i><i>builder</i><i>(</i><i>)</i><i>.</i><i>http2_only</i><i>(</i>h2_only<i>)</i><i>.</i><i>build_http</i><i>::</i><i>&lt;</i><i>Body</i><i>&gt;</i><i>(</i><i>)</i><i>;</i>

    <i>let</i> <i>(</i>tx, <i>mut</i> rx<i>)</i> = mpsc<i>::</i><i>channel</i><i>::</i><i>&lt;</i>eyre<i>::</i><i>Result</i><i>&lt;</i><i>(</i><i>)</i><i>&gt;</i><i>&gt;</i><i>(</i><i>4096</i><i>)</i><i>;</i>

    <i>let</i> body = <i>Bytes</i><i>::</i><i>from</i><i>(</i><i>vec</i><i>!</i><i>[</i><i>0u8</i>; <i>65535</i> + <i>1</i><i>]</i><i>)</i><i>;</i>

    async <i>fn</i> <i>do_one_request</i><i>(</i><i>req</i>: <i>Request</i><i>&lt;</i><i>Body</i><i>&gt;</i>, <i>client</i>: <i>Client</i><i>&lt;</i><i>HttpConnector</i><i>&gt;</i><i>)</i> -&gt; eyre<i>::</i><i>Result</i><i>&lt;</i><i>(</i><i>)</i><i>&gt;</i> {
        <i>let</i> res = client<i>.</i><i>request</i><i>(</i>req<i>)</i><i>.</i>await?<i>;</i>
        _ = hyper<i>::</i>body<i>::</i><i>to_bytes</i><i>(</i>res<i>.</i><i>into_body</i><i>(</i><i>)</i><i>)</i><i>.</i>await?<i>;</i>
        Ok<i>(</i><i>(</i><i>)</i><i>)</i>
    }

    <i>for</i> _ <i>in</i> <i>0</i>..h2_requests {
        <i>let</i> req = <i>Request</i><i>::</i><i>builder</i><i>(</i><i>)</i>
            <i>.</i><i>uri</i><i>(</i><i>format</i><i>!</i><i>(</i><i>&#34;http://{addr}&#34;</i><i>)</i><i>)</i>
            <i>.</i><i>method</i><i>(</i><i>Method</i><i>::</i>POST<i>)</i>
            <i>.</i><i>body</i><i>(</i><i>Body</i><i>::</i><i>from</i><i>(</i>body<i>.</i><i>clone</i><i>(</i><i>)</i><i>)</i><i>)</i>?<i>;</i>
        <i>let</i> fut = <i>do_one_request</i><i>(</i>req, client<i>.</i><i>clone</i><i>(</i><i>)</i><i>)</i><i>;</i>
        <i>let</i> tx = tx<i>.</i><i>clone</i><i>(</i><i>)</i><i>;</i>
        tokio<i>::</i><i>spawn</i><i>(</i>async <i>move</i> { _ = tx<i>.</i><i>send</i><i>(</i>fut<i>.</i>await<i>)</i><i>.</i>await }<i>)</i><i>;</i>
    }
    <i>drop</i><i>(</i>tx<i>)</i><i>;</i>

    <i>let</i> <i>mut</i> complete_reqs = <i>0</i><i>;</i>

    <i>while</i> <i>let</i> Ok<i>(</i>Some<i>(</i>res<i>)</i><i>)</i> = tokio<i>::</i>time<i>::</i><i>timeout</i><i>(</i><i>Duration</i><i>::</i><i>from_millis</i><i>(</i><i>500</i><i>)</i>, rx<i>.</i><i>recv</i><i>(</i><i>)</i><i>)</i><i>.</i>await {
        res?<i>;</i>
        complete_reqs += <i>1</i><i>;</i>
    }

    <i>if</i> complete_reqs != h2_requests {
        <i>error</i><i>!</i><i>(</i><i>&#34;{prefix}: Stuck at {complete_reqs} / {h2_requests}&#34;</i><i>)</i><i>;</i>
    } <i>else</i> {
        <i>info</i><i>!</i><i>(</i><i>&#34;{prefix}: Completed {complete_reqs} / {h2_requests}&#34;</i><i>)</i><i>;</i>
    }

    Ok<i>(</i><i>(</i><i>)</i><i>)</i>
}

async <i>fn</i> <i>sample_endpoint</i><i>(</i><i>req</i>: <i>Request</i><i>&lt;</i><i>Body</i><i>&gt;</i><i>)</i> -&gt; <i>Result</i><i>&lt;</i><i>Response</i><i>&lt;</i><i>Body</i><i>&gt;</i>, <i>Infallible</i><i>&gt;</i> {
    <i>let</i> <i>(</i>_parts, req_body<i>)</i> = req<i>.</i><i>into_parts</i><i>(</i><i>)</i><i>;</i>
    hyper<i>::</i>body<i>::</i><i>to_bytes</i><i>(</i>req_body<i>)</i><i>.</i>await<i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>

    <i>let</i> res = <i>Response</i><i>::</i><i>new</i><i>(</i><i>&#34;hi there&#34;</i><i>.</i><i>into</i><i>(</i><i>)</i><i>)</i><i>;</i>
    Ok<i>(</i>res<i>)</i>
}
</pre></div>
<p>This &#34;simply&#34; makes many concurrent requests with the same <code>hyper::Client</code> to a
hyper server, over HTTP/1.1, and then HTTP/2. (Separate clients, separate servers).</p>
<p>We can get it to work reliably:</p>
<div><p>Shell session</p><pre data-lang="shell">$ RUST_BACKTRACE=1 H2_MAX_STREAMS=100 H2_REQUESTS=100 cargo run --release --quiet
2022-10-20T18:35:28.635803Z  INFO h2_repro: 100 requests on 100 streams
2022-10-20T18:35:28.635826Z  INFO h2_repro: (Set $H2_REQUESTS and $H2_MAX_STREAMS environment variables to adjust)
2022-10-20T18:35:28.717719Z  INFO h2_repro: H1: Completed 100 / 100
2022-10-20T18:35:28.814155Z  INFO h2_repro: H2: Completed 100 / 100
$ RUST_BACKTRACE=1 H2_MAX_STREAMS=100 H2_REQUESTS=100 cargo run --release --quiet
2022-10-20T18:35:30.478822Z  INFO h2_repro: 100 requests on 100 streams
2022-10-20T18:35:30.478842Z  INFO h2_repro: (Set $H2_REQUESTS and $H2_MAX_STREAMS environment variables to adjust)
2022-10-20T18:35:30.589255Z  INFO h2_repro: H1: Completed 100 / 100
2022-10-20T18:35:30.692042Z  INFO h2_repro: H2: Completed 100 / 100
$ RUST_BACKTRACE=1 H2_MAX_STREAMS=100 H2_REQUESTS=100 cargo run --release --quiet
2022-10-20T18:35:31.202745Z  INFO h2_repro: 100 requests on 100 streams
2022-10-20T18:35:31.202769Z  INFO h2_repro: (Set $H2_REQUESTS and $H2_MAX_STREAMS environment variables to adjust)
2022-10-20T18:35:31.287174Z  INFO h2_repro: H1: Completed 100 / 100
2022-10-20T18:35:31.430318Z  INFO h2_repro: H2: Completed 100 / 100
</pre></div>
<p>What&#39;s interesting is what happens if the maximum number of streams is set
<em>lower</em> than the maximum amount of requests we make.</p>
<p>Sometimes, the server actually gets to send a <code>RST_STREAM</code> with error code
<a href="https://httpwg.org/specs/rfc9113.html#REFUSED_STREAM">REFUSED_STREAM</a></p>
<div><p>Shell session</p><pre data-lang="shell">$ RUST_BACKTRACE=1 H2_MAX_STREAMS=50 H2_REQUESTS=100 cargo run --release --quiet
2022-10-20T18:35:46.732954Z  INFO h2_repro: 100 requests on 50 streams
2022-10-20T18:35:46.732986Z  INFO h2_repro: (Set $H2_REQUESTS and $H2_MAX_STREAMS environment variables to adjust)
2022-10-20T18:35:46.782711Z  INFO h2_repro: H1: Completed 100 / 100
The application panicked (crashed).
Message:  called `Result::unwrap()` on an `Err` value: 
   0: http2 error: stream error received: refused stream before processing any application logic
   1: stream error received: refused stream before processing any application logic

Location:
   src/main.rs:69

(cut)
</pre></div>
<p>In my view, this is a bug: I think <code>hyper::Client</code> should retry the request. But
I&#39;m sympathetic to the argument that hyper has already encoded headers, and
probably started sending the request body, and there&#39;s no trait bound for
&#34;replaying bodies&#34;, and it doesn&#39;t want to do its own buffering there, so, sure.</p>
<p>Some other times, though, something much more fun happens:</p>
<div><p>Shell session</p><pre data-lang="shell">$ RUST_BACKTRACE=1 H2_MAX_STREAMS=50 H2_REQUESTS=100 cargo run --release --quiet
2022-10-20T18:40:30.826371Z  INFO h2_repro: 100 requests on 50 streams
2022-10-20T18:40:30.826391Z  INFO h2_repro: (Set $H2_REQUESTS and $H2_MAX_STREAMS environment variables to adjust)
2022-10-20T18:40:30.909172Z  INFO h2_repro: H1: Completed 100 / 100
2022-10-20T18:40:31.491769Z ERROR h2_repro: H2: Stuck at 51 / 100
</pre></div>
<p>It gets stuck!</p>
<div><p>Shell session</p><pre data-lang="shell">$ RUST_BACKTRACE=1 H2_MAX_STREAMS=200 H2_REQUESTS=240 cargo run --release --quiet
2022-10-20T18:41:28.854054Z  INFO h2_repro: 240 requests on 200 streams
2022-10-20T18:41:28.854078Z  INFO h2_repro: (Set $H2_REQUESTS and $H2_MAX_STREAMS environment variables to adjust)
2022-10-20T18:41:28.981241Z  INFO h2_repro: H1: Completed 240 / 240
2022-10-20T18:41:29.571869Z ERROR h2_repro: H2: Stuck at 222 / 240
</pre></div>
<p>The test loses patience after 500 milliseconds, but believe me, it never gets
unstuck.</p>
<div><p>Shell session</p><pre data-lang="shell">$ RUST_BACKTRACE=1 H2_MAX_STREAMS=100 H2_REQUESTS=150 cargo run --release --quiet
2022-10-20T18:41:52.152636Z  INFO h2_repro: 150 requests on 100 streams
2022-10-20T18:41:52.152658Z  INFO h2_repro: (Set $H2_REQUESTS and $H2_MAX_STREAMS environment variables to adjust)
2022-10-20T18:41:52.206723Z  INFO h2_repro: H1: Completed 150 / 150
2022-10-20T18:41:52.775941Z ERROR h2_repro: H2: Stuck at 143 / 150
</pre></div><div>

<p>And now you&#39;re going to explain why that happens, right?</p>
</div>
<p>Oh no. I&#39;ve done quite enough for now. That issue has been open for <a href="https://github.com/hyperium/hyper/issues/2419">quite a while
now</a>. Maybe someone else will
crack it!</p>
<p>Unlike HTTP/1.1, HTTP/2 has a conformance testing tool,
<a href="https://github.com/summerwind/h2spec">h2spec</a>. But it should be considered more
of a starting point: there&#39;s plenty of opportunity for unfortunate interactions
after that.</p>

                        <h2>
                            <a id="afterword" href="#afterword">
                                Afterword
                            </a>
                        </h2>
                        
<p>Thanks for following me into the depths of HTTP 1.1 and 2. Apologies for not
covering HTTP/3, although, in fairness, it&#39;s probably as involved as both its
predecessors added together.</p>
<p>Researching this article, as always, gave me simultaneously much-needed
humility, and a renewed motivation to experiment further with implementing
protocols from scratch (or nearly scratch).</p>
<p>I&#39;ve been working on <a href="https://github.com/hapsoc/hring">a new H1/H2 implementation in
Rust</a>, with very specific design objectives:</p>
<ul>
<li>Only target Linux</li>
<li>Use <code>io_uring</code> for asynchronous I/O (through <a href="https://lib.rs/crates/tokio-uring">tokio-uring</a> right now)</li>
<li>Use <a href="https://lib.rs/crates/rustls">rustls</a> for TLS handshakes, then <a href="https://docs.kernel.org/networking/tls-offload.html">kTLS</a> (see <a href="https://github.com/rustls/rustls/pull/1112">this PR</a>)</li>
<li>Control memory usage carefully, using a fixed-size buffer pool</li>
<li>Provide visibility into the exact state of H1/H2 connections</li>
</ul>
<p>The requirements are so different from hyper/h2, that they&#39;re not at all
competitors. It&#39;s also still very early stages: HTTP/1.1 barely works, and I
just got a (pretty poor implementation of) chunked transfer-encoding last week.</p>
<p>What&#39;s interesting about building on top of <code>io_uring</code> is that a lot of the
async interface I was used to don&#39;t work or make sense anymore. A lot has been
written about what the &#34;proper&#34; Rust interface for <code>io_uring</code> should be: the
short answer is that as soon as you submit an operation, the buffer is no longer
owned by the application: it&#39;s owned by the kernel.</p>
<p>So if you look at tokio-uring&#39;s <a href="https://docs.rs/tokio-uring/0.3.0/tokio_uring/net/struct.TcpStream.html#method.write"><code>TcpStream::write</code>
method</a>
for example, you&#39;ll see it takes a <code>T: IoBuf</code>, owned, and returns a <code>BufResult&lt;usize, T&gt;</code>,
which is just a <code>(Result&lt;T&gt;, B)</code>.</p>
<p>Which means, in practice, you find yourself writing yourself a lot of code like:</p>
<div><p>Rust code</p><pre data-lang="rust">        <i>let</i> <i>mut</i> buf = <i>get_a_buf</i><i>(</i><i>)</i><i>;</i>
        <i>let</i> res<i>;</i>
        <i>(</i>res, buf<i>)</i> = src<i>.</i><i>read</i><i>(</i>buf<i>)</i><i>.</i>await<i>;</i>
        res?<i>;</i>
</pre></div>
<p>The naive solution is to use <code>Vec&lt;u8&gt;</code> as a buffer type. A slightly less naive
solution is to use something like <code>Bytes</code> from the
<a href="https://lib.rs/crates/bytes">bytes</a> crate (which is actually what hyper uses
throughout).</p>
<p>But even then, <code>Bytes</code> does more work than we need, because it&#39;s <code>Send</code>, so it
uses atomic reference-counting under the hood. <code>tokio-uring</code> has its own <code>start</code>
method to start a runtime, and it&#39;s effectively a <code>current_thread</code> tokio
runtime: things don&#39;t need to be <code>Send</code> because there&#39;s only ever one userland
thread.</p>
<p>If you to utilize multiple cores, you can &#34;simply&#34; start one <code>tokio-uring</code>
runtime per core. Using socket options like <code>SO_REUSEADDR</code> and <code>SO_REUSEPORT</code>,
accepted connections can be spread across workers. This isn&#39;t the only solution,
or necessarily <a href="https://blog.cloudflare.com/the-sad-state-of-linux-socket-balancing/">the right
one</a>, but
it&#39;s an easy one.</p>
<p>And now, if you&#39;re able to do <em>most</em> of the processing for a connection in its
own thread, limiting interactions with process-wide state as much as possible,
you don&#39;t need atomic reference counting — regular reference counting works.</p>
<p>I&#39;ve always wondered what the true cost of the <code>Arc&lt;GlobalState&gt;</code> model is for
high-traffic hyper applications. I was surprised to find out that Arc is <a href="https://pkolaczk.github.io/server-slower-than-a-laptop/">not so
free, under certain
circumstances</a>.</p>
<p>Similarly, most mutexes can now transform into
<a href="https://doc.rust-lang.org/stable/std/cell/struct.RefCell.html">RefCells</a>, which
<em>still</em> enforce &#34;only one single mutable reference to something at any given
time&#34;, but never spin, never block, never yield to another thread.</p>
<p>Inevitably, there&#39;ll still be some global state to interact with — I&#39;m hoping
communicating over channels with some &#34;controller&#34; runtime won&#39;t end up being
prohibitively expensive.</p>
<p>Another thing I&#39;ve found frustrating while working with <code>hyper</code> is how little
internal state it exposes. The complex lifecycle of some HTTP connections is
somewhat lost behind abstractions like <code>tower::Service</code>, and most of it is
&#34;tasks spawned on the runtime&#34;. Even with custom acceptors, custom body types,
etc., I&#39;ve been stumped multiple times.</p>
<p>This of course, makes sense for the de-facto standard HTTP implementation for
Rust: hyper&#39;s public API has been remarkably stable, and changing it now would
be an enormous undertaking, that would no doubt make a lot of noise (not
necessarily in a good way).</p>
<p>I&#39;m a big fan of the &#34;let users as much of the internal state as possible&#34;
school of thought. It makes unknown unknowns a lot easier to chase down. That&#39;s
what I&#39;m going for with this specific exploration.</p>
<p>Anyway! I&#39;m really excited about this work, and I do think more folks should
play around with their own implementation of HTTP and adjacent protocols: Rust
is truly an excellent language for it.</p>
<p>The inner workings of HTTP/2 were intimidating and mysterious before I wrote
this article, and now they feel somewhat approachable.</p>
<p>I hope this article did the same for you — that&#39;s the whole reason I started
writing &#34;seriously&#34; in the first place :)</p>
<p>Thanks for reading, and as always: take excellent care of yourself.</p>

</div><div>
  
    
    
      

  


  







<div>
    <h2>Latest video</h2>









<div>
    
        
        
        
            
        

        

        
        

        
        
        
        
        
            
        
        
         
        
            
        
        
            
        
        <div>
            <a href="https://hdoro.dev/videos/how-does-the-detour-crate-work">
                
                    
                    <div>
                        <picture>
                            <source type="image/avif" srcset="https://tube.fasterthanli.me/covers/how-the-detour-crate-works/cover.avif"/>
                            <source type="image/webp" srcset="https://tube.fasterthanli.me/covers/how-the-detour-crate-works/cover.webp"/>
                            <img alt="video cover image" src="https://tube.fasterthanli.me/covers/how-the-detour-crate-works/cover.jpg"/>
                        </picture>
                    </div>
                

                <span>
                    
                        
                        How does the detour crate work?
                    
                </span>
            </a>
            <div>
                <div>
                    <div>
                        <p>Oct 19, 2022</p>
                        
                            
                                
                                    <p>
                                        20 minute watch
                                    </p>
                                
                            
                        

                        
                            
                            
                        

                        
                        
                        
                            
                        
                        

                        
                        
                    </div>
                </div>

                <div>
                    
                        
                            
                            <p>We want to hook a function, so that our code gets called... but we also want the original code to execute. How the heck does that work?</p>
                        
                    
                </div>

                
                    <p><a href="https://hdoro.dev/videos/how-does-the-detour-crate-work">
                        <span>
                            
                                Watch now
                            
                        </span>
                    </a>
                
            </p></div>
        </div>
    
</div>


    <p>You can watch more videos <a href="https://hdoro.dev/videos">over there</a></p>
</div> <!-- Latest video -->

  
</div></div>
  </body>
</html>
