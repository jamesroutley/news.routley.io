<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.smashingmagazine.com/2022/09/javascript-api-guide/">Original</a>
    <h1>Lesser-known JavaScript APIs</h1>
    
    <div id="readability-page-1" class="page"><div><div id="article__content"><div><ul><li>16 min read</li><li><a href="https://www.smashingmagazine.com/category/api">API</a>,
<a href="https://www.smashingmagazine.com/category/apps">Apps</a>,
<a href="https://www.smashingmagazine.com/category/tools">Tools</a>,
<a href="https://www.smashingmagazine.com/category/guides">Guides</a>,
<a href="https://www.smashingmagazine.com/category/javascript">JavaScript</a></li></ul><p><section aria-label="Quick summary"><span id="article__start" aria-hidden="true"></span>In this article, Juan Diego covers the least known yet extremely useful APIs, such as the Page Visibility API, Web Sharing API, Broadcast Channel API and Internationalization API. Together we will see what they are, where we should use them, and how to use them.</section></p><p>A couple of days ago, I revisited the awesome <a href="https://2021.stateofjs.com/en-US/">2021 State of JS Survey</a>. The state of JS is an online survey that collects data from developers around the world to see the most recent and upcoming trends in the JavaScript community. Among the data it collects, a section is dedicated to the native features JavaScript provides, listed by their usage and awareness. As you can imagine, among the most used features are popular ones like <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining">Optional chaining</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator">Nullish coalescing</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API">Websockets</a>, and so on.</p><p>However, I wasn’t interested in the most used or known APIs. Instead, I was looking for the least known ones. I wanted to know which APIs we aren’t talking about enough, and among them, I found four pretty different APIs that are extremely useful:</p><ul><li><a href="#page-visibility-api">Page Visibility API</a></li><li><a href="#web-share-api">Web Share API</a></li><li><a href="#broadcast-channel-api">Broadcast Channel API</a></li><li><a href="#internationalization-api">Internationalization API</a></li></ul><p>In this article, we will see what they are, where we should use them, and how to use them.</p><p><strong>Note</strong>: <em><a href="https://monknow.github.io/apis-you-didnt-know-about/">These APIs are all available in this demo</a>.</em></p><h2 id="page-visibility-api">Page Visibility API</h2><p>This is a little-known web API that rates last fourth in awareness in the <a href="https://2021.stateofjs.com/en-US/features">State of JS Survey</a>. It lets you know when a user has left the page. To be precise, the API triggers an event whenever the page visibility status changes, either when the user minimizes or maximizes the window or switches the tab.</p><p>In the past, you had to use gimmicks to know if a user had switched tabs or minimized the window. The most popular was using the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/blur_event"><code>blur</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/focus_event"><code>focus</code></a> browser events. Using these events would result in something like the following:</p><pre><code>window.addEventListener(&#34;focus&#34;, function () {
    // User is back on the page
    // Do Something
});

window.addEventListener(&#34;blur&#34;, function () {
    // User left the page
    // Do Something
});
</code></pre><p>The previous code works but not as intended. Since the <code>blur</code> event is triggered when the page loses focus, it can be triggered when the user clicks the search bar, an alert dialog, the console, or the window border. So, <code>blur</code> and <code>focus</code> only tell us if the page is active but not if the content of the page is hidden or visible.</p><h3 id="use-cases">Use Cases</h3><p>In general, we want to use the Page Visibility API to stop unnecessary processes when the user doesn’t see the page or, on the other hand, to perform background actions. Some specific cases can be:</p><ul><li>to pause videos, image carousels, or animations when the user leaves the page;</li><li>if the page displays live data from an API, stop this behavior temporarily while the user is away;</li><li>to send user analytics.</li></ul><h3 id="how-to-use-it">How To Use It?</h3><p>The Page Visibility API brings two properties and an event to access the page visibility status:</p><ul><li><code>document.hidden</code></li><li><code>document.visibilityState</code></li><li><code>visibilitychange</code></li></ul><pre><code>document.addEventListener(&#34;visibilitychange&#34;, () =&gt; {
    if (document.visibilityState === &#34;visible&#34;) {
        // page is visible
    } else {
        // page is hidden
    }
});
</code></pre><p>To see how to use the Page Visibility API, let’s use it to pause a video and stop fetching resources from an API when the user leaves the page. To start, I will be using <a href="https://vitejs.dev/guide/#scaffolding-your-first-vite-project">vite.js</a>, which is an amazing tool to start a new project quickly:</p><pre><code>npm create vite@latest unknown-web-apis</code></pre><p>When asked to select a framework, select vanilla to create a vanilla javascript project. And once finished, go to the new folder, install the necessary <code>npm</code> packages and start the developer server:</p><pre><code>  cd unknown-web-apis
  npm install
  npm run dev</code></pre><p>Go to <a href="http://localhost:3000/">localhost:3000/</a>, and you will see your Vite project up and running!</p><figure><a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/af373d72-bc9b-49c5-994d-a92fb1e781f1/vite-new-project.png"><img loading="lazy" decoding="async" fetchpriority="low" width="800" height="362" srcset="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/af373d72-bc9b-49c5-994d-a92fb1e781f1/vite-new-project.png 400w,
https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_800/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/af373d72-bc9b-49c5-994d-a92fb1e781f1/vite-new-project.png 800w,
https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/af373d72-bc9b-49c5-994d-a92fb1e781f1/vite-new-project.png 1200w,
https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/af373d72-bc9b-49c5-994d-a92fb1e781f1/vite-new-project.png 1600w,
https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/af373d72-bc9b-49c5-994d-a92fb1e781f1/vite-new-project.png 2000w" src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/af373d72-bc9b-49c5-994d-a92fb1e781f1/vite-new-project.png" sizes="100vw" alt="Vite New Project"/></a><figcaption>Vite New Project. (<a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/af373d72-bc9b-49c5-994d-a92fb1e781f1/vite-new-project.png">Large preview</a>)</figcaption></figure><p>Firstly, we will direct to the <code>/main.js</code> file and delete all the boilerplate. Secondly, we will open <code>/index.html</code>, and inside the <code>#app</code> div tag, we will add a video element with any video file you want. I used a dancing Yoshi one. :)</p><pre><code>&lt;div id=&#34;app&#34;&gt;
    &lt;video controls id=&#34;video&#34;&gt;
        &lt;source src=&#34;./yoshi.mp4&#34; /&gt;
    &lt;/video&gt;
&lt;/div&gt;</code></pre><figure><a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/526008ab-f9d4-4deb-b384-2a5d74709b96/yoshi-screenshot.png"><img loading="lazy" decoding="async" fetchpriority="low" width="800" height="447" srcset="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/526008ab-f9d4-4deb-b384-2a5d74709b96/yoshi-screenshot.png 400w,
https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_800/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/526008ab-f9d4-4deb-b384-2a5d74709b96/yoshi-screenshot.png 800w,
https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/526008ab-f9d4-4deb-b384-2a5d74709b96/yoshi-screenshot.png 1200w,
https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/526008ab-f9d4-4deb-b384-2a5d74709b96/yoshi-screenshot.png 1600w,
https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/526008ab-f9d4-4deb-b384-2a5d74709b96/yoshi-screenshot.png 2000w" src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/526008ab-f9d4-4deb-b384-2a5d74709b96/yoshi-screenshot.png" sizes="100vw" alt="Video with controls showing a Yoshi image"/></a><figcaption>Video with controls showing a Yoshi image. (<a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/526008ab-f9d4-4deb-b384-2a5d74709b96/yoshi-screenshot.png">Large preview</a>)</figcaption></figure><p>Back to <code>/main.js</code>, we will add an event listener to the <code>document</code> object listening to the <code>visibilitychange</code> event. We then can access the <code>document.visibilityState</code> property to see when the page is visible or hidden.</p><pre><code>document.addEventListener(&#34;visibilitychange&#34;, () =&gt; {
    console.log(document.visibilityState);
});</code></pre><p>You can go to the page’s console and see the page visibility status change when you minimize the window or switch to another tab. Now, inside the event listener, we can check the <code>document.visibilityState</code> property, pause the video when it is <code>hidden</code>, and play it when <code>visible</code>. (Of course, we first select the <code>video</code> element using <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector"><code>document.querySelector()</code></a>.)</p><pre><code>const video = document.querySelector(&#34;#video&#34;);

document.addEventListener(&#34;visibilitychange&#34;, () =&gt; {
    if (document.visibilityState === &#34;visible&#34;) {
        video.play();
    } else {
        video.pause();
    }
});</code></pre><p>Now the video stops whenever the user leaves the page. Another use of the Page Visibility API is to stop fetching unnecessary resources when the user doesn’t see the page. To see this, we will write a function to constantly fetch a random quote from the <a href="https://github.com/lukePeavey/quotable">quotable.io</a> API and pause this behavior when the page is hidden. Firstly, we will create a new div tag to store the quote in <code>/index.html</code>.</p><pre><code>&lt;div id=&#34;app&#34;&gt;
    &lt;video controls id=&#34;video&#34;&gt;
        &lt;source src=&#34;./yoshi.mp4&#34; /&gt;
    &lt;/video&gt;
    &lt;div id=&#34;quote&#34;&gt;&lt;/div&gt;
&lt;/div&gt;</code></pre><p>Back in <code>/main.js</code>, we will use the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"><strong>Fetch API</strong></a> to make a call to the <code>quotable.io</code> endpoint <a href="https://api.quotable.io/random">https://api.quotable.io/random</a> and then insert it into the <code>quote</code> div.</p><div><pre><code>const quote = document.querySelector(&#34;#quote&#34;);

const getQuote = async () =&gt; {
try {
const response = await fetch(&#34;https://api.quotable.io/random&#34;);
const {content, author, dateAdded} = await response.json();
const parsedQuote = ` &lt;q&gt;${content}&lt;/q&gt; &lt;br&gt; &lt;p&gt;- ${author}&lt;/p&gt;&lt;br&gt; &lt;p&gt;Added on ${dateAdded}&lt;/p&gt;`;
quote.innerHTML = parsedQuote;
} catch (error) {
console.error(error);
}
};

getQuote();</code></pre></div><p>Let’s shortly explain what is happening right here. We first select the <code>quote</code> element from the DOM. We then declare the <code>getQuote</code> function, which is an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function"><code>async</code> function</a> that allows us to use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await"><code>await</code></a> keyword to wait until we fetch the data from the API. The data fetched is in JSON format, so we use the <code>await</code> keyword one more time to wait until the data is parsed into a JavaScript object. The <code>quotable.io</code> API gives us—among other things—the <code>content</code>, <code>author</code>, and <code>dateAdded</code> properties that we will inject and display into the <code>quote</code> div. This works, but the quote is only fetched once, so we can use <a href="https://developer.mozilla.org/en-US/docs/Web/API/setInterval"><code>setInterval()</code></a> to call the function every 10 seconds.</p><div><pre><code>const quote = document.querySelector(&#34;#quote&#34;);

const getQuote = async () =&gt; {
try {
const response = await fetch(&#34;https://api.quotable.io/random&#34;);
const {content, author, dateAdded} = await response.json();
const parsedQuote = ` &lt;q&gt;${content}&lt;/q&gt; &lt;br&gt; &lt;p&gt;- ${author}&lt;/p&gt;&lt;br&gt; &lt;p&gt;Added on ${dateAdded}&lt;/p&gt;`;
quote.innerHTML = parsedQuote;
} catch (error) {
console.error(error);
}
};

getQuote();

setInterval(getQuote, 10000);</code></pre></div><p>If the user minimizes the window or switches the tab, the page would still fetch the quotes, creating an unnecessary network load. To solve this, we can check if the page is visible before fetching a quote.</p><div><pre><code>const getQuote = async () =&gt; {
    if (document.visibilityState === &#34;visible&#34;) {
        try {
            const response = await fetch(&#34;https://api.quotable.io/random&#34;);
            const {content, author, dateAdded} = await response.json();
            const parsedQuote = `
            &lt;q&gt;${content}&lt;/q&gt; &lt;br&gt; 
            &lt;p&gt;- ${author}&lt;/p&gt;&lt;br&gt; 
            &lt;p&gt;Added on ${dateAdded}&lt;/p&gt;`;
            quote.innerHTML = parsedQuote;
        } catch (error) {
            console.error(error);
        }
    }
};

getQuote();

setInterval(getQuote, 10000);</code></pre></div><p>Now, we will only fetch the quote if the page is visible to the user.</p><h3 id="support">Support</h3><p><a href="https://caniuse.com/pagevisibility">Widely supported</a></p><div data-audience="non-subscriber" data-remove="true"><p><span>More after jump! Continue reading below ↓</span></p></div><h3 id="what-is-it">What Is It?</h3><p>The <strong>Web Share API</strong> is also among the least-known APIs but is extremely useful. It lets you access the operative system’s native sharing mechanism, which is especially useful to mobile users. With this API, you can share text, links, and files without the need to create your own sharing mechanisms or use third-party ones.</p><h3 id="use-cases-1">Use Cases</h3><p>They are pretty self-explanatory. You can use it to share content from your page to social media or copy it to the user’s clipboard.</p><h3 id="how-to-use-it-1">How To Use It?</h3><p>The Web Share API gives us two interfaces to access the user’s sharing system:</p><ol><li><code>navigator.canShare()</code></li><li><p><code>navigator.share()</code></p><ul><li><code>url</code>: URL to be shared,</li><li><code>text</code>: text to be shared,</li><li><code>title</code>: title to be shared,</li><li><code>files</code>: array of <code>File</code> objects representing files to be shared.</li></ul></li></ol><p>To see how to use this API, we will recycle our prior example and make an option to share our quotes using the Web Sharing API. To start, we first have to make a share button in <code>/index.html</code>:</p><pre><code>&lt;div id=&#34;app&#34;&gt;
    &lt;video controls id=&#34;video&#34;&gt;
        &lt;source src=&#34;./yoshi.mp4&#34; /&gt;
    &lt;/video&gt;
    &lt;div id=&#34;quote&#34;&gt;&lt;/div&gt;
    &lt;button type=&#34;button&#34; id=&#34;share-button&#34;&gt;Share Quote&lt;/button&gt;
&lt;/div&gt;</code></pre><p>We direct to <code>/main.js</code> and select the share button from the DOM. Then, we create an <code>async</code> function to share the data we want.</p><pre><code>const shareButton = document.querySelector(&#34;#share-button&#34;);

const shareQuote = async (shareData) =&gt; {
    try {
        await navigator.share(shareData);
    } catch (error) {
        console.error(error);
    }
};</code></pre><p>Now, we can add a click event listener to the <code>shareButton</code> element to callback the <code>shareQuote</code> function. Our <code>shareData.text</code> value will be the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent"><code>quote.textContent</code></a> property and the <code>shareData.url</code> will be the page URL i.e the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Location/href"><code>location.href</code></a> property.</p><pre><code>const shareButton = document.querySelector(&#34;#share-button&#34;);

const shareQuote = async (shareData) =&gt; {
    try {
        await navigator.share(shareData);
    } catch (error) {
        console.error(error);
    }
};

shareButton.addEventListener(&#34;click&#34;, () =&gt; {
    let shareData = {
        title: &#34;A Beautiful Quote&#34;,
        text: quote.textContent,
        url: location.href,
    };

    shareQuote(shareData);
});</code></pre><p>Now you can share your quotes with anyone through your native operative system. However, it is important to note that the Web Share API will only work if the context is secure, i.e., if the page is served over <code>https://</code> or <code>wss://</code> URLs.</p><h3 id="support-1">Support</h3><p><a href="https://caniuse.com/web-share">Poorly supported</a></p><h2 id="broadcast-channel-api">Broadcast Channel API</h2><h3 id="what-is-it-1">What Is It?</h3><p>Another API I want to talk about is the <strong>Broadcast Channel API</strong>. It allows browsing contexts to send and receive basic data from each other. Browsing contexts are elements like a tab, window, iframe, or anywhere a page can be displayed. Due to security reasons, communication between browsing contexts isn’t allowed unless they are of the same origin and use the Broadcast Channel API. For two browsing contexts to be of the same origin, they must share in their URL the same protocol (e.g. <code>http/https</code>), domain (e.g. <code>example.com</code>), and port (e.g. <code>:8080</code>).</p><h3 id="use-cases-2">Use Cases</h3><p>The Broadcast Channel API is generally used to keep a page’s state synced across different tabs and windows to enhance user experience or for security reasons. It can also be used to know when a service is finished in another tab or window. Some examples are:</p><ul><li>Log a user in or out across all tabs.</li><li>Detect when an asset is uploaded and show it across all pages.</li><li>Instruct a service worker to do some background work.</li></ul><h3 id="how-to-use-it-2">How To Use It?</h3><p>The Broadcast Channel API involves a <code>BroadcastChannel</code> object that can be used to send messages to other contexts. Its constructor has only one argument: a string that will work as an identifier to connect to the channel from other contexts.</p><pre><code>const broadcast = new BroadcastChannel(&#34;new_channel&#34;);</code></pre><p>Once we have created a <code>BroadcastChannel</code> object with the same identifier across two contexts, the new <code>BroadcastChannel</code> object will have two available methods to start communicating:</p><ul><li><code>BroadcastChannel.postMessage()</code> to send a message across all connected contexts. It takes any kind of object as its only argument so that you can send a wide variety of data.</li></ul><pre><code>broadcast.postMessage(&#34;Example message&#34;);</code></pre><ul><li><code>BroadcastChannel.close()</code> to close the channel and indicate to the browser that it won’t receive any more messages so it can collect them into the garbage.</li></ul><p>To receive a message, the <code>BroadcastChannel</code> has a <code>message</code> event that we can listen to using an <code>addEventListener</code> or its <code>onmessage</code> property. The <code>message</code> event has a <code>data</code> property with the data sent and other properties to identify the context that sent the message, such as <code>origin</code>, <code>lastEventId</code>, <code>source</code>, and <code>ports</code>.</p><pre><code>broadcast.onmessage = ({data, origin}) =&gt; {
    console.log(`${origin} says ${data}`);
};</code></pre><p>Let’s see how to use the Broadcast Channel API by using our prior example. Our goal would be to make another browsing context with the same origin and display the same quote in both contexts. To do this, we will create a new folder named <code>new-origin</code> with a new <code>/index.html</code> and <code>/main.js</code> files inside.</p><p>The <code>/new-origin/index.html</code> will be a new HTML boilerplate with a <code>#quote</code> div inside:</p><div><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&#34;en&#34;&gt;
    &lt;head&gt;
        &lt;meta charset=&#34;UTF-8&#34; /&gt;
        &lt;link rel=&#34;icon&#34; type=&#34;image/svg+xml&#34; href=&#34;../favicon.svg&#34; /&gt;
        &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1.0&#34; /&gt;
        &lt;title&gt;Vite App&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id=&#34;quote&#34;&gt;&lt;/div&gt;
        &lt;script type=&#34;module&#34; src=&#34;./main.js&#34;&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre></div><p>In the <code>/new-origin/main.js</code> file, we will create a new broadcast channel and select the <code>#quote</code> element from the DOM:</p><pre><code>const broadcast = new BroadcastChannel(&#34;quote_channel&#34;);
const quote = document.querySelector(&#34;#quote&#34;);</code></pre><p>And in our prior <code>/main.js</code> file, we will create a new <code>BroadcastChannel</code> object and connect it to the <code>&#34;quote_channel&#34;</code>. We will also modify the <code>getQuote</code> function to send the quote as a message to other contexts.</p><div><pre><code>const broadcast = new BroadcastChannel(&#34;quote_channel&#34;);

//...

const getQuote = async () =&gt; {
try {
const response = await fetch(&#34;https://api.quotable.io/random&#34;);
const {content, author, dateAdded} = await response.json();
const parsedQuote = ` &lt;q&gt;${content}&lt;/q&gt; &lt;br&gt; &lt;p&gt;- ${author}&lt;/p&gt;&lt;br&gt; &lt;p&gt;Added on ${dateAdded}&lt;/p&gt;`;
quote.innerHTML = parsedQuote;
broadcast.postMessage(parsedQuote);
} catch (error) {
console.error(error);
}
};</code></pre></div><p>Back in the <code>/new-origin/main.js</code> file, we will listen to the <code>message</code> event and change the <code>quote.innerHTML</code> each time a new quote is sent.</p><pre><code>const broadcast = new BroadcastChannel(&#34;quote_channel&#34;);
const quote = document.querySelector(&#34;#quote&#34;);

broadcast.onmessage = ({data}) =&gt; {
    quote.innerHTML = data;
};</code></pre><p>Now you can see how the quote in <a href="http://localhost:3000/origin/">http://localhost:3000/new-origin/</a> changes to the quote in <a href="http://localhost:3000">http://localhost:3000</a>. You can also notice how the quote doesn’t change when the <a href="http://localhost:3000">http://localhost:3000</a> tab is hidden since it only fetches a quote when its page visibility status is visible.</p><h3 id="support-2">Support</h3><p><a href="https://caniuse.com/mdn-api_broadcastchannel_name">Widely supported</a></p><h2 id="internationalization-api">Internationalization API</h2><h3 id="what-it-ss">What It Ss?</h3><p>When developing a web page or app, it’s extremely common to need to translate its content across other languages to reach a wider audience. However, just translating your page’s text to whichever language you need isn’t enough to make your content available to speakers of that language since things like dates, numbers, units, and so on are different across countries and may cause confusion to your users.</p><p>Let’s say you want to display the date “November 8, 2022” on your webpage like “11/8/22”. This data can be read in three distinct ways depending on the reader’s country:</p><ul><li>“November 8, 2022” or MM/DD/YY by people from the US.</li><li>“August 11, 2022” or DD/MM/YY by people from Europe and Latam.</li><li>“August 22, 2011” or YY/MM/DD by people from Japan, China, and Canada.</li></ul><p>This is where the <strong>Internationalization API</strong> (Or <strong>I18n API</strong>) comes to solve formatting issues across different languages and regions. The I18n API is an amazing tool that has several uses, but we won’t delve into them to not overcomplicate this article.</p><h3 id="how-to-use-it-3">How To Use It?</h3><p>The I18n API uses locale identifiers to work. A locale identifier is a string that expresses the user’s language, country, region, dialect, and other preferences. To be precise, a locale identifier is a string that consists of subtags separated by hyphens. Subtags represent user preferences like language, country, region, or script and are formatted in the following way:</p><ol><li>“zh”: Chinese (language);</li><li>“zh-Hant”: Chinese (language) written in traditional characters (script);</li><li>“zh-Hant-TW”: Chinese (language) written in traditional characters (script) as used in Taiwan (region).</li></ol><p>There are more subtags to address more users’ preferences (if you want to learn more, you can check the <a href="https://datatracker.ietf.org/doc/html/rfc5646">RFC definition</a> of language tags), but to keep it short, the I18n API uses these locale identifiers to know how to format all the language-sensitive data.</p><p>To be more precise, the I18n API provides an <code>Intl</code> object that brings a bunch of specialized constructors to work with language-sensitive data. In my opinion, some of the most useful <code>Intl</code> constructors for internationalization are:</p><ul><li><code>Intl.DateTimeFormat()</code></li><li><code>Intl.DisplayNames()</code></li><li><code>Intl.Locale()</code></li><li><code>Intl.NumberFormat()</code></li><li><code>Intl.RelativeTimeFormat()</code></li></ul><p>For our example, we will focus on the <code>Intl.DateTimeFormat()</code> constructor to format the quote’s <code>dateAdded</code> property depending on the user locale. The <code>Intl.DateTimeFormat()</code> constructor takes two arguments: the <code>locale</code> string that defines the date formatting convention and the <code>options</code> objects to customize how to format the dates.</p><p>The <code>Intl.DateTimeFormat()</code> created object has a <code>format()</code> method that takes two arguments: the <code>Date</code> object we want to format and the <code>options</code> object to customize how to display the formatted date.</p><pre><code>const logDate = (locale) =&gt; {
    const newDate = new Date(&#34;2022-10-24&#34;); // YY/MM/DD
    const dateTime = new Intl.DateTimeFormat(locale, {timeZone: &#34;UTC&#34;});
    const formatedDate = dateTime.format(newDate);
    console.log(formatedDate);
};

logDate(&#34;en-US&#34;); // 10/24/2022
logDate(&#34;de-DE&#34;); // 24.10.2022
logDate(&#34;zh-TW&#34;); // 2022/10/24</code></pre><p><strong>Note:</strong> <em>On the <code>Intl.DateTimeFormat</code> constructor’s <code>options</code> argument, we set the <code>timeZone</code> property to <code>&#34;UTC&#34;</code> so the date isn’t formatted to the user’s local time. In my case, the date is parsed to “10/23/2022” without the <code>timeZone</code> option.</em></p><p>As you can see, the <code>dateTime.format()</code> changes the date depending on the locale’s date formatting convention. We can implement this behavior on the quotes’ date using the <code>navigator.language</code> global property, which holds the user’s preferred locale. To do this, we will create a new function that takes a date string (in YYYY-MM-DD format) and returns the date formatted depending on the user’s locale.</p><div><pre><code>const formatDate = (dateString) =&gt; {
    const date = new Date(dateString);
    const locale = navigator.language;
    const dateTimeFormat = new Intl.DateTimeFormat(locale, {timeZone: &#34;UTC&#34;});

    return dateTimeFormat.format(date);

};</code></pre></div><p>We can add this function inside the <code>getQuote()</code> function to parse the <code>dateAdded</code> date.</p><div><pre><code>const getQuote = async () =&gt; {
    if (document.visibilityState === &#34;visible&#34;) {
        try {
            const response = await fetch(&#34;https://api.quotable.io/random&#34;);
            const {content, author, dateAdded} = await response.json();
            const parsedQuote = `
            &lt;q&gt;${content}&lt;/q&gt; &lt;br&gt; 
            &lt;p&gt;- ${author}&lt;/p&gt;&lt;br&gt; 
            &lt;p&gt;Added on ${formatDate(dateAdded)}&lt;/p&gt;`;
            quote.innerHTML = parsedQuote;
            broadcast.postMessage(parsedQuote);
        } catch (error) {
            console.error(error);
        }
    }
};</code></pre></div><p>With this, our quotes are localized to the user’s preferred language! In my case, my <code>navigator.language</code> value is <code>&#34;en&#34;</code>, so my dates are formatted to MM/DD/YY.</p><h3 id="support-3">Support</h3><p><a href="https://caniuse.com/internationalization">Widely supported</a></p><h2 id="conclusion">Conclusion</h2><p>After reading this article, you can now flex about knowing the existence of these APIs and how to use them. Even though they were ranked last in awareness in the <a href="https://2021.stateofjs.com/en-US/features">State of JS Survey</a>, they are extremely useful, and knowing how to use them will definitely enhance your developing experience. The fact that these powerful APIs aren’t very known means that there are still useful APIs you and I still don’t know about, so it’s the perfect time to explore and find that API that will simplify your code and save you a ton of time developing.</p><p>I hope you liked this article and until the next time!</p><p><img src="https://www.smashingmagazine.com/images/logo/logo--red.png" alt="Smashing Editorial" width="35" height="46" loading="lazy" decoding="async"/>
<span>(vf, yk, il)</span></p></div></div></div></div>
  </body>
</html>
