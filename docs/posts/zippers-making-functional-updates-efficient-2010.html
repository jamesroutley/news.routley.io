<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://www.goodmath.org/blog/2010/01/13/zippers-making-functional-updates-efficient/">Original</a>
    <h1>Zippers: Making Functional &#34;Updates&#34; Efficient (2010)</h1>
    
    <div id="readability-page-1" class="page"><div>
			<p><img decoding="async" src="http://upload.wikimedia.org/wikipedia/commons/f/f0/Zipper_animated.gif"/></p>
<p> In the Haskell stuff, I was planning on moving on to some monad-related</p>
<p> A zipper is a remarkably clever idea. It’s not really a single data</p>
<p> It also happens that zippers are one of the rare cases of data structures</p>

<p> The basic idea of a zipper is to give you a way of efficiently working with data</p>
<p> For example, consider the list <code>[a b c d e f g]</code>. Implemented</p>
<p> That makes the functional program much slower than the imperative one.</p>
<p> In general, it’s very hard to get around that. You can’t update in place</p>
<p> For example, if you’re building a text editor, you’ve got the point</p>
<p> What a zipper does is take a data structure, and unfold it around a focal</p>
<p> The idea of it is a lot like a gap-buffer. Right now, I’m actually working</p>
<p> A zipper is a tree or graph-based version of a similar idea. For this</p>
<p> It’s called a zipper because what you do to create this pre-focus, path,</p>
<p><img data-recalc-dims="1" fetchpriority="high" decoding="async" src="https://i0.wp.com/scientopia.org/img-archive/goodmath/img_413.png?resize=389%2C202" width="389" height="202" alt="string-tree.png"/></p>
<p> Now, suppose I want to put the focus on “mno”. To do that, I climb down</p>
<p><img data-recalc-dims="1" decoding="async" src="https://i0.wp.com/scientopia.org/img-archive/goodmath/img_414.png?resize=447%2C231" width="447" height="231" alt="string-tree-zippered.png"/></p>
<p> With the zipper, you can make all sorts of changes very easily at the</p>
<p> I could also add new children nodes. Suppose that instead of adding</p>
<p><img data-recalc-dims="1" decoding="async" src="https://i0.wp.com/scientopia.org/img-archive/goodmath/img_415.png?resize=497%2C231" width="497" height="231" alt="string-tree-zippered-and-edited.png"/></p>
<p> That’s the beauty of the zipper: most operations can be in terms of local</p>
<p> Doing other things isn’t that difficult either. Suppose we wanted to move</p>
<p> So why is it harder to code? Because when we’re dealing with trees, we’re pretty much always dealing with balance. And balance <em>isn’t</em> a local property. No matter which kind of tree you use – red/black, 2/3, AVL –  you might need to climb up the tree to do the balance maintenance. That mangles the simple zipper.</p>
<p> You’ve got two choices. One is to re-balance</p>
<p> The alternative is something called <em>scarring</em>. You put marks in the tree called scars that identify places where you made changes that could trigger a rebalance. (Or more generally,</p>
<p> Either way, it gets a bit more complicated – and when you look at the code</p>
					</div></div>
  </body>
</html>
