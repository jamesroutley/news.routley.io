<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/ashton314/muKanren_reading">Original</a>
    <h1>Annotated implementation of microKanren: an embeddable logic language</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">

<p dir="auto">I wanted to understand how <a href="http://webyrd.net/scheme-2013/papers/HemannMuKanren2013.pdf" rel="nofollow">μKanren</a> works. This is an annotated journey through implementing the code from that paper.</p>

<p dir="auto">μKanren is a very small implementation in the Kanren family: essentially these are little embedded Prolog implementations. μKanren is particularly interesting because its implementation is less than 40 lines of Scheme code, and makes no use of exotic language features. Indeed, if your language has closures, you can make yourself a μKanren.</p>

<h2 dir="auto"><a id="user-content-basic-types" aria-hidden="true" href="#basic-types"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Basic types</h2>
<pre>state :: subst × fresh_var_counter

subst :: assoc list mapping variable → variable | value

goal :: state → state*
</pre>
<p dir="auto">Goals take a state and return a stream (lazy) of zero or more new states.</p>
<p dir="auto">A state tells us a variable substitution that satisfies the constrains the goals created.</p>
<h2 dir="auto"><a id="user-content-the-walk-function" aria-hidden="true" href="#the-walk-function"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>The <code>walk</code> function</h2>
<p dir="auto">This takes a variable and a substitution list, and it will walk through the substitution list until it finds the ultimate reference of the variable given. Since variables can map to other variables in the substitution list (see the <a href="https://github.com/ashton314/muKanren_reading/blob/master/Basic%20types">Basic types</a> section) then <code>walk</code> traverses those transitive dependencies until it can’t any more.</p>
<p dir="auto">It <i>can</i> return another variable; if the last thing that one variable points to is another variable that is <i>not</i> present at the beginning of the list, then returning that variable is valid. This is important for the <a href="https://github.com/ashton314/muKanren_reading/blob/master/Implementing%20~unify~">unify</a> function.</p>
<h2 dir="auto"><a id="user-content-implementing-unify" aria-hidden="true" href="#implementing-unify"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Implementing <code>unify</code></h2>
<p dir="auto">The unify function take two <i>things</i>, <code>u</code> and <code>v</code>, and tries to make them line up according to the substitution that you give as well.</p>
<div data-snippet-clipboard-copy-content="(unify &#39;(1 2 3) &#39;(2 3 4) &#39;())
#f

(unify &#39;(1 2 3) &#39;(1 2 3) &#39;())
&#39;()

(unify &#39;(1 2 3) &#39;(1 2 3) &#39;(yay))
&#39;(yay)

(unify (list 1 2 3) (list 1 (var 0) 3) &#39;())
(list (cons (var 0) 2))

(unify (list 1 2 3) (list 1 (var 0) 3) `((,(var 0) 4)))
#f"><pre>(unify &#39;(<span>1</span> <span>2</span> <span>3</span>) &#39;(<span>2</span> <span>3</span> <span>4</span>) <span>&#39;()</span>)
<span>#f</span>

(unify &#39;(<span>1</span> <span>2</span> <span>3</span>) &#39;(<span>1</span> <span>2</span> <span>3</span>) <span>&#39;()</span>)
<span>&#39;()</span>

(unify &#39;(<span>1</span> <span>2</span> <span>3</span>) &#39;(<span>1</span> <span>2</span> <span>3</span>) &#39;(yay))
&#39;(yay)

(unify (list <span>1</span> <span>2</span> <span>3</span>) (list <span>1</span> (var <span>0</span>) <span>3</span>) <span>&#39;()</span>)
(list (cons (var <span>0</span>) <span>2</span>))

(unify (list <span>1</span> <span>2</span> <span>3</span>) (list <span>1</span> (var <span>0</span>) <span>3</span>) `((,(var <span>0</span>) <span>4</span>)))
<span>#f</span></pre></div>
<p dir="auto">This example illustrates how the <code>walk</code> function drills down:</p>
<div data-snippet-clipboard-copy-content="(walk (var 0) `((,(var 0) . ,(var 1)) (,(var 1) . ,(var 2))))
(var 2)

(unify (list 1 2 3) (list 1 (var 0) 3) `((,(var 0) . ,(var 1)) (,(var 1) . 2)))
(list (cons (var 0) (var 1)) (cons (var 1) 2))"><pre>(walk (var <span>0</span>) `((,(var <span>0</span>) . ,(var <span>1</span>)) (,(var <span>1</span>) . ,(var <span>2</span>))))
(var <span>2</span>)

(unify (list <span>1</span> <span>2</span> <span>3</span>) (list <span>1</span> (var <span>0</span>) <span>3</span>) `((,(var <span>0</span>) . ,(var <span>1</span>)) (,(var <span>1</span>) . <span>2</span>)))
(list (cons (var <span>0</span>) (var <span>1</span>)) (cons (var <span>1</span>) <span>2</span>))</pre></div>
<p dir="auto">If we wanted to be able to unify more than just lists (e.g. rich structures) we would teach μKanren here in the <code>cond</code> how to walk those richer structures.</p>
<p dir="auto">Successful unification returns the substitution list that made the two things unify. This is different from the passed-in substitution list when a variable is found to point to another variable.</p>
<h2 dir="auto"><a id="user-content-implementing-callfresh" aria-hidden="true" href="#implementing-callfresh"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Implementing <code>call/fresh</code></h2>
<p dir="auto">The implementation of call/fresh depends on the structure of the state: in a pure language, we stick a fresh variable counter on the state so we can thread that fresh effect through the computation. I would like to try just using something like <code>gensym</code> for variable creation.</p>
<h2 dir="auto"><a id="user-content-and-and-or-goal-constructors" aria-hidden="true" href="#and-and-or-goal-constructors"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>AND</code> and <code>OR</code> goal constructors</h2>
<p dir="auto">The magic of the <a href="https://github.com/ashton314/muKanren_reading/blob/master/kanren.rkt::define%20%28disj%20goal1%20goal2">disj</a> and <a href="https://github.com/ashton314/muKanren_reading/blob/master/kanren.rkt::define%20%28conj%20goal1%20goal2">conj</a> functions is encapsulated in the <code>mplus</code> and <code>bind</code> functions.</p>
<p dir="auto">With the <code>disj</code> function, we want to <code>OR</code> two goals, and the <code>conj</code> is to <code>AND</code> two goals. For <code>disj</code>, we run both goals and <i>add</i> them together. For <code>conj</code>, we run the first goal (seen by applying the first goal to the <code>subst/counter</code> variable) and then we thread the result of that to the second goal.</p>
<p dir="auto">Exactly <i>how</i> we add the goal results together bzw. thread the state from one goal to another determines the properties of the search. I’ll skip the detailed evolution of this (see the paper for a nice walk-through) but in the end we get lazily-evaluated interleaving stream handling so we can exhaust every finite stream.</p>
<h3 dir="auto"><a id="user-content-what-are-streams" aria-hidden="true" href="#what-are-streams"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>What are streams?</h3>
<p dir="auto">Streams are lists of states with lazily-evaluated members.</p>
<p dir="auto">Here’s an example from the paper showing how streams need to be interleaved and be lazy:</p>
<div data-snippet-clipboard-copy-content="(define (fives x)
  (disj (== x 5)
        (λ (s/c) (λ () ((fives x) s/c)))))

(define (sixes x)
  (disj (== x 6)
        (λ (s/c) (λ () ((sixes x) s/c)))))

(define fives-and-sixes (call/fresh (λ (x) (disj (fives x) (sixes x)))))"><pre>(<span>define</span> (fives x)
  (disj (<span>==</span> x <span>5</span>)
        (<span>λ</span> (s/c) (<span>λ</span> () ((fives x) s/c)))))

(<span>define</span> (sixes x)
  (disj (<span>==</span> x <span>6</span>)
        (<span>λ</span> (s/c) (<span>λ</span> () ((sixes x) s/c)))))

(<span>define</span> fives-and-sixes (call/fresh (<span>λ</span> (x) (disj (fives x) (sixes x)))))</pre></div>

<p dir="auto">These are some syntactic sugar that make working with μKanren nicer. Most of them are macros, which would make porting these to other languages less straight-forward. But they do make working in Scheme/Racket a lot nicer. Some new non-Lisp languages like Elixir[fn:1] feature hygienic macro systems, so these features would be portable.</p>

<h2 dir="auto"><a id="user-content-variable-representation" aria-hidden="true" href="#variable-representation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Variable representation</h2>
<p dir="auto">I deviated from the paper’s implementation of variables and wrote them as structs instead of vectors. I think further changes could be made (e.g. not having to keep around a number in the state to generate fresh variable names but these might rely on some more language-specific features. (E.g. generating fresh strings/symbols.)</p>
<h2 dir="auto"><a id="user-content-predicates-in-unify" aria-hidden="true" href="#predicates-in-unify"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Predicates in <code>unify</code></h2>
<p dir="auto">I’ve added some rudimentary predicate checking to the <code>unify</code> function:</p>
<div data-snippet-clipboard-copy-content="(define (fav-num n)
  (disj (== n 42)
        (== (cons &#39;? even?) n)))"><pre>(<span>define</span> (fav-num n)
  (disj (<span>==</span> n <span>42</span>)
        (<span>==</span> (cons <span>&#39;?</span> even?) n)))</pre></div>
<div data-snippet-clipboard-copy-content="&gt; (run* (n) (== n 12) (fav-num n))
&#39;(12)

&gt; (run* (n) (== n 13) (fav-num n))
&#39;()

&gt; (run* (n) (fav-num n))
&#39;(42 (? . #&lt;procedure:even?&gt;))"><pre>&gt; (run* (n) (<span>==</span> n <span>12</span>) (fav-num n))
&#39;(<span>12</span>)

&gt; (run* (n) (<span>==</span> n <span>13</span>) (fav-num n))
<span>&#39;()</span>

&gt; (run* (n) (fav-num n))
&#39;(<span>42</span> (? . #&lt;procedure:even?&gt;))</pre></div>

<h2 dir="auto"><a id="user-content-family-tree-relationships" aria-hidden="true" href="#family-tree-relationships"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Family tree relationships</h2>
<p dir="auto">The classic example. See <a href="https://github.com/ashton314/muKanren_reading/blob/master/relations_playground.rkt">./relations_playground.rkt</a>. Because of how the relations are defined, this will print out an infinite list of relations if you try to run certain queries, so best use the <code>run</code> function with some finite (and preferably small number; it doesn’t take much to cover the whole space at least once) bound, as opposed to just running <code>run*</code>.</p>
<h2 dir="auto"><a id="user-content-type-checking" aria-hidden="true" href="#type-checking"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Type checking</h2>
<p dir="auto">See <a href="https://github.com/ashton314/muKanren_reading/blob/master/type_checking.rkt">./type_checking.rkt</a> for an implementation of a simple type checker/inference algorithm. Here is how you check the type of a program:</p>
<div data-snippet-clipboard-copy-content="&gt; (run* (type) (type-for &#39;((lambda x x) 2) &#39;() type))
&#39;(number)

&gt; (run* (type) (type-for &#39;((lambda x (zero? x)) 2) &#39;() type))
&#39;(boolean)

&gt; (run* (type) (type-for &#39;((lambda x (zero? x)) #f) &#39;() type))
&#39;()  ;; type error

&gt; (run* (type) (type-for &#39;(lambda x x) &#39;() type))
&#39;((_.5 . _.5)) ;; generic type: a -&gt; a"><pre>&gt; (run* (type) (type-for &#39;((<span>lambda</span> x x) <span>2</span>) <span>&#39;()</span> type))
&#39;(number)

&gt; (run* (type) (type-for &#39;((<span>lambda</span> x (zero? x)) <span>2</span>) <span>&#39;()</span> type))
&#39;(boolean)

&gt; (run* (type) (type-for &#39;((<span>lambda</span> x (zero? x)) <span>#f</span>) <span>&#39;()</span> type))
<span>&#39;()</span>  <span>;; type error</span>

&gt; (run* (type) (type-for &#39;(<span>lambda</span> x x) <span>&#39;()</span> type))
&#39;((_.5 . _.5)) <span>;; generic type: a -&gt; a</span></pre></div>
<p dir="auto">Here’s the crazy thing: you can actually ask for programs that match a given type, since relations work both ways. Here’s an example of generating five programs that are of type <code>number → boolean</code>:</p>
<div data-snippet-clipboard-copy-content="&gt; (run 5 (prog) (type-for prog &#39;() (cons &#39;number &#39;boolean)))
&#39;((lambda _.1 (? . #&lt;procedure:boolean?&gt;))
  (lambda _.1 (zero? (? . #&lt;procedure:number?&gt;)))
  (lambda (? . #&lt;procedure:symbol?&gt;) (zero? (? . #&lt;procedure:symbol?&gt;)))
  (lambda _.1 (zero? (+ (? . #&lt;procedure:number?&gt;) (? . #&lt;procedure:number?&gt;))))
  (lambda _.1 (if (? . #&lt;procedure:boolean?&gt;) (? . #&lt;procedure:boolean?&gt;) (? . #&lt;procedure:boolean?&gt;))))"><pre>&gt; (run <span>5</span> (prog) (type-for prog <span>&#39;()</span> (cons <span>&#39;number</span> <span>&#39;boolean</span>)))
&#39;((<span>lambda</span> _.1 (? . #&lt;procedure:boolean?&gt;))
  (<span>lambda</span> _.1 (zero? (? . #&lt;procedure:number?&gt;)))
  (<span>lambda</span> (? . #&lt;procedure:symbol?&gt;) (zero? (? . #&lt;procedure:symbol?&gt;)))
  (<span>lambda</span> _.1 (zero? (+ (? . #&lt;procedure:number?&gt;) (? . #&lt;procedure:number?&gt;))))
  (<span>lambda</span> _.1 (<span>if</span> (? . #&lt;procedure:boolean?&gt;) (? . #&lt;procedure:boolean?&gt;) (? . #&lt;procedure:boolean?&gt;))))</pre></div>

<p dir="auto">I hope is <i>very clear</i> that <i>I</i> did <i>not</i> write the μKanren paper. That would be Daniel P. Friedman and Jason Hemann. I merely wrote up this annotation.</p>
<p dir="auto">Ashton Wiersdorf &lt;ashton.wiersdorf@pobox.com&gt;</p>

<p dir="auto">Be sure to read <a href="http://webyrd.net/scheme-2013/papers/HemannMuKanren2013.pdf" rel="nofollow">the actual paper</a> which is freely available.</p>
<p dir="auto">Other fun links:</p>
<ul dir="auto">
  <li><a href="https://aphyr.com/posts/354-unifying-the-technical-interview" rel="nofollow">Unifying the Technical Interview</a></li>
</ul>

<p dir="auto">[fn:1] Personally, I think of Elixir as a Lisp in Ruby’s clothing running on the BEAM. But don’t tell anyone that Lisp is quietly becoming the new hot thing in web development and some machine learning. <g-emoji alias="shushing_face" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f92b.png">🤫</g-emoji></p>
</article>
          </div></div>
  </body>
</html>
