<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://forums.swift.org/t/template-for-a-possible-future-object-model/59823">Original</a>
    <h1>The Val Object Model: Template for a possible future Swift object model</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
          
<p><a href="https://www.val-lang.dev/" rel="noopener nofollow ugc">Val</a> is a Swift-inspired language being developed by <a href="https://forums.swift.org/u/dabrahams">@dabrahams</a>, <a href="https://forums.swift.org/u/alvae">@Alvae</a>, and a handful of others.</p>
<p>Beyond trivial syntactic similarity, Val draws on Swift for its object model, re-imagining how we think it would look if Swift:</p>
<ul>
<li>Started with support for non-copyable types.</li>
<li>Had the benefit of insights gained during its development, especially the law of exclusivity and <code>_modify</code>/<code>_read</code> accessors.</li>
<li>Did not start with support for (single-thread safe) reference semantics at its core.</li>
</ul>
<p>This post is not an attempt to sell Val to anyone, and we certainly don&#39;t believe Swift can adopt Val&#39;s object model wholesale, immediately, or without modification. That said, we think Swift might be evolved in the direction of Val&#39;s model, and that doing so could result in a simpler, better Swift. Because Val was designed with noncopyable types in mind, the model is cleaner than what&#39;s currently being contemplated for the future of Swift, which understandably shows signs of a retrofit. At <a href="https://forums.swift.org/u/joe_groff">@Joe_Groff</a>&#39;s <a href="https://forums.swift.org/t/borrow-and-take-parameter-ownership-modifiers/59581/62">suggestion</a> we are starting this thread to introduce the big picture in one place, tuned to be appropriate for the Swift evolution audience.</p>
<p>Significant portions of this post synthesize parts of <a href="https://www.val-lang.dev/pages/language-tour.html" rel="noopener nofollow ugc">Val&#39;s language tour</a>, with additional comments describing how Val relates to Swift. We have omitted detailed explanations of things we think this audience can easily intuit on their own, but please feel free to ask questions about anything.</p>
<h2>
<a name="pure-value-semantics-2" href="#pure-value-semantics-2"></a>Pure Value Semantics</h2>
<p>Val&#39;s originating question was: <em>What does programming look like when there is only <a href="https://www.jot.fm/issues/issue_2022_02/article2.pdf" rel="noopener nofollow ugc">mutable value semantics</a>?</em></p>
<p>Therefore we started with Swift, omitting the three sources of reference semantics in Swift&#39;s (single-thread) safe subset:</p>
<ul>
<li>classes</li>
<li>mutable global variables</li>
<li>closure captures with reference semantics</li>
</ul>
<p>The approach is a major departure from that of Swift, but we believe the design is relevant nonetheless, and that reference semantics in the style of Swift can be reconstructed on top of Val&#39;s core object model. [Note that shared mutable state is accessible in the Val model&#39;s unsafe subset via pointer dereferences].</p>
<h2>
<a name="explicit-necessary-copies-3" href="#explicit-necessary-copies-3"></a>Explicit, necessary copies</h2>
<p>The way Swift passes arguments to functions showed us that arguments passed by value don&#39;t need to be copied or moved, which led us to realize that the semantics of a <code>let</code> binding (which can be viewed as passing by-value to a continuation function) doesn&#39;t necessarily imply a copy or move either.</p>
<p>When these copies are eliminated, the need for copying becomes rare enough that:</p>
<ul>
<li>It becomes reasonable to make all copies, even those of trivial types like <code>Int</code>, explicit via <code>x.copy()</code>, thus simplifying the story for generic code that must operate on both kinds of type.</li>
<li>Many generic algorithms written straightforwardly to operate on copyable types “just work” on non-copyable types without modification, so the need to add a generic <code>Copyable</code> requirement becomes rare.</li>
<li>Since a copy is only needed when the source of a <code>let</code> binding is modified during the <code>let</code> binding&#39;s lifetime, it turns out that the compiler can issue a “fix-it” suggesting exactly the necessary copies, and can warn about those that are unnecessary. The user experience is analogous to the one Swift provides around <code>let</code> and <code>var</code>.</li>
<li>Finally, since the compiler can identify necessary and unnecessary copies, we can add a way to turn on implicit copies.</li>
</ul>
<p>In the latter mode <strong>the programming model for copyable types is practically identical to the one that Swift offers today</strong>, but with only the necessary copies actually being made. It is this overlap that makes us think it may be possible to evolve Swift toward Val&#39;s model. We also think this model provides a suitable platform for interoperating with C++. Swift may need to use the opposite default for backward compatibility reasons of course.</p>
<h3>
<a name="examples-4" href="#examples-4"></a>Examples</h3>
<h4>
<a name="missing-copy-detection-5" href="#missing-copy-detection-5"></a>Missing copy detection:</h4>
<p>The ability to create a let binding without an implicit copy means that immutability must be conferred upon the source of the binding during the binding&#39;s lifetime.</p>
<pre><code>fun f(x: inout Int) {
  let y = x // &lt;-------------------------------------------+
  x += 1    // error: x is let-bound.  Insert a copy here -+
  print(x, y)
}
</code></pre>
<p>If Swift ever gets local <code>inout</code> bindings, an analogous coupling will confer inaccessiblity on source values during the lifetime of the binding.</p>
<p>Because by-value parameters are borrowed, they can&#39;t be stored or returned without a copy:</p>
<pre><code>type Vector2 {
  var x: Double
  var y: Double

  /// Creates an instance whose `x` and `y` values are `buffer[0]` and 
  /// `buffer[1]` respectively.
  init(_ buffer: Double[2]) {
    x = buffer[0].copy()
    y = buffer[1] // error: `buffer[1]` cannot escape; insert a copy here.
  }
}
</code></pre>
<p>An alternative would be to pass <code>buffer</code> as a <code>sink</code> parameter, which would allow it to be consumed to create the new <code>Vector2</code> instance. More on passing conventions later.</p>
<h4>
<a name="opt-in-implicit-copying-6" href="#opt-in-implicit-copying-6"></a>Opt-in implicit copying</h4>
<p>Because the compiler can know where copies would have been made in a language with implicit copying, we can allow the user to enable implicit copies, resulting in a model that mimics Swift.</p>
<pre><code>@implicitcopy

type Vector2 {
  var x: Double
  var y: Double

  init(_ buffer: Double[2]) {
    x = buffer[0] // implicit copy here
    y = buffer[1] // and here
  }
}
</code></pre>
<p><em>Note: you can use <code>@implicitcopy</code> at any scope, or can parameterize it with specific types or traits (e.g. <code>CheaplyCopyable</code>), allowing the effect to be controlled when it matters.</em></p>
<h4>
<a name="copyability-7" href="#copyability-7"></a>Copyability</h4>
<p>Copyability is enable by making types conform to the <code>Copyable</code> trait. A trait is like Swift protocol.</p>
<pre><code>type Vector2: Copyable {
  var x: Double
  var y: Double
}
</code></pre>
<p>Just as in Swift, conformance to traits like <code>Copyable</code>, <code>Equatable</code> and <code>Hashable</code> can be synthesized when stored properties have those conformances.</p>
<h2>
<a name="parameter-passing-conventions-8" href="#parameter-passing-conventions-8"></a>Parameter passing conventions</h2>
<p>A parameter passing convention describes how an argument is passed from caller to callee. In Val, there are four: <code>let</code>, <code>inout</code>, <code>sink</code> and <code>set</code>. The next series of examples define four corresponding functions to offset this 2-dimensional vector type:</p>
<pre><code>type Vector2: Copyable {
  var x: Double
  var y: Double
}
</code></pre>
<h3>
<a name="let-parameters-9" href="#let-parameters-9"></a><code>let</code> parameters</h3>
<p><code>let</code> is the default convention and does not need to be spelled explicitly. At the user level, <code>let</code> parameters can be understood just like reglar parameters in Swift. They are (notionally) passed by value, and are truly immutable.</p>
<pre><code>fun offset_let(_ v: Vector2, by delta: Vector2) -&gt; Vector2 {
  Vector2(x: v.x + delta.x, y: v.y + delta.y)
}
</code></pre>
<p>The <code>let</code> convention does not transfer ownership of the argument to the callee, meaning, for example, that without first copying it, a <code>let</code> parameter can&#39;t be returned, or stored anywhere that outlives the call.</p>
<pre><code>fun duplicate(_ v: Vector2) -&gt; Vector2 {
  v // error: `v` cannot escape; return `v.copy()` instead.
}
</code></pre>
<h3>
<a name="inout-parameters-10" href="#inout-parameters-10"></a><code>inout</code> parameters</h3>
<p><code>inout</code> behaves almost exactly like in Swift. Arguments to <code>inout</code> parameters must be unique, mutable, and marked with an ampersand (<code>&amp;</code>) at the call site.</p>
<pre><code>fun offset_inout(_ target: inout Vector2, by delta: Vector2) {
  &amp;target.x += delta.x
  &amp;target.y += delta.y
}
</code></pre>
<p>One syntactic difference from Swift you&#39;ll notice is that in Val there are no exceptions to the rule that mutated objects are marked with <code>&amp;</code>, so you&#39;ll see it in uses of operators and mutating methods.</p>
<p>Another difference from Swift is that, although <code>inout</code> parameters are required to be valid at function entry and exit, a callee is entitled to do anything with the value of such parameters, including destroying them, as long as it puts a value back before returning. That makes it convenient to temporarily move an argument into an object that encapsulates some computation.</p>
<pre><code>type Processor {
  var ast: AST
  fun process() inout { ... }
  fun process_expr() inout { ... }
  fun process_decl() inout { ... }
  fun finalize() sink -&gt; {AST, Result} { ... }
}

fun process(_ ast: inout AST) -&gt; Result {
  // Move `ast` into `p`, without copying it
  var p = Processor(ast)
  
  // Execute the computation encapsulated by `Processor`
  &amp;p.process()

  // Move `p` back into `ast`.
  let result: Result
  (ast, result) = p.finalize()
  return result
}
</code></pre>
<p><em>Note: In Val, the passing convention for the <code>self</code> parameter to a method is written after the parameter list, so mutating methods are marked with a postfix <code>inout</code></em>.</p>
<h3>
<a name="sink-parameters-11" href="#sink-parameters-11"></a><code>sink</code> parameters</h3>
<p>The <code>sink</code> convention indicates a transfer of ownership, so unlike previous examples the parameter can escape the lifetime of the callee.</p>
<pre><code>fun offset_sink(_ base: sink Vector2, by delta: Vector2) -&gt; Vector2 {
  &amp;base.x += delta.x
  &amp;base.y += delta.y
  return base        // OK; base escapes here!
}
</code></pre>
<p>Just as with <code>inout</code> parameters, the compiler enforces that arguments to <code>sink</code> parameters are unique. Because of the transfer of ownership, though, the argument becomes inaccessible in the caller after the callee is invoked.</p>
<pre><code>fun main()
  let v = Vector2(x: 1, y: 2)
  
  print(offset_sink(v, (x: 3, y: 5)))  // prints (x: 4, y: 7)
  
  print(v) // &lt;== error: v was consumed above.
}          // to use v here, pass v.copy() to offset_sink.
</code></pre>
<p>The conventions we&#39;ve seen so far are closely related; so much so that <code>offset_sink</code> can be written in terms of <code>offset_inout</code>, and vice versa:</p>
<pre><code>fun offset_sink2(_ v: sink Vector2, by delta: Vector2) -&gt; Vector2 {
  offset_inout(&amp;v, by: delta)
  return v
}

fun offset_inout2(_ v: inout Vector2, by delta: Vector2) {
  v = offset_sink(v, by: delta)
}
</code></pre>
<p>Furthermore, either one can be written in terms of <code>offset_let</code>:</p>
<pre><code>fun offset_sink3(_ v: sink Vector2, by delta: Vector2) -&gt; Vector2 {
  offset_let(v, by: delta)
}

fun offset_inout3(_ v: inout Vector2, by delta: Vector2) {
  v = offset_let(v, by: delta)
}
</code></pre>
<h3>
<a name="set-parameters-12" href="#set-parameters-12"></a><code>set</code> parameters</h3>
<p>The <code>set</code> convention lets a callee initialize an uninitialized value. An argument to a <code>set</code> parameter is unique, mutable and guaranteed uninitialized at the function&#39;s entry.</p>
<pre><code>fun init_vector(_ target: set Vector2, x: sink Double, y: sink Double) {
  target = Vector2(x: x, y: y)
}

public fun main() {
  var v: Vector2
  init_vector(&amp;v, x: 1.5, y: 2.5)
  print(v)                         // (x: 1.5, y: 2.5)
}
</code></pre>
<h2>
<a name="method-bundles-13" href="#method-bundles-13"></a>Method bundles</h2>
<p>When multiple methods have the same functionality but differ only in the passing convention of their receiver, they can be grouped into a single <em>bundle</em>.</p>
<pre><code>extension Vector2 {
  fun offset(by delta: Vector2) -&gt; Vector2 {
    let {
      Vector2(x: x + delta.x, y: y + delta.y)
    }
    inout {
      &amp;x += delta.x
      &amp;y += delta.y
    }
    sink {
      &amp;x += delta.x
      &amp;y += delta.y
      return self
    }
  }
}

public fun main() {
  let unit_x = Vector2(x: 1.0, y: 0.0)
  var v1 = Vector2(x: 1.5, y: 2.5)
  
  &amp;v1.offset(by: unit_x)          // inout
  let v2 = v1.offset(by: unit_x)  // let
  print(v1.offset(by: unit_x))    // sink
  print(v2)
}
</code></pre>
<p>At the call site, the compiler determines the variant to apply depending on the context of the call. In this example, the first call applies the <code>inout</code> variant as the receiver has been marked for mutation. The second call applies the <code>let</code> variant as the receiver is used in the next line The third call applies the <code>sink</code> variant as it is receiver&#39;s last use.</p>
<p>Thanks to the <a href="https://github.com/val-lang/Documentation/blob/main/object-model-for-swift-designers.md#let_inout_sink" rel="noopener nofollow ugc">link</a> between conventions, the compiler is able to synthesize one implementation from the other as long as the type is <code>Sinkable</code>. This feature can be used to avoid code duplication in cases where custom implementations of the different variants do not offer any performance benefit, or where performance is not a concern. For example, in the case of <code>Vector2.offset(by:)</code>, it is sufficient to write the following declaration and let the compiler synthesize the missing variants.</p>
<pre><code>extension Vector2 {
  fun offset(by delta: Vector2) -&gt; Vector2 {
    let { Vector2(x: x + delta.x, y: y + delta.y) }
  }
}
</code></pre>
<h3>
<a name="the-copyable-and-sinkable-traits-14" href="#the-copyable-and-sinkable-traits-14"></a>The <code>Copyable</code> and <code>Sinkable</code> traits.</h3>
<p>The <code>Copyable</code> trait is a refinement of <code>Sinkable</code>, the trait for types that can be moved. They are defined as follows in the standard library, using method bundles:</p>
<pre><code>trait Sinkable {

  // Gives `self` the value of a consumed `source`.
  fun take_value(from source: sink Self) {
    // The pattern `let x: T = f()` is compiled as `let x: T; x.take_value(from: f())`.
    set { /* synthesized memberwise */ }   // move-initialization

    // The pattern `x = f()` is compiled as `x.take_value(from: f())`.
    inout { /* synthesized memberwise */ } // move-assignment
  }

}

trait Copyable: Sinkable {

  // Gives `self` the copied value of `source`.
  fun copy_value(from source: sink Self) {
    // The pattern `let x: T = expr.copy()` is compiled as `let x: T; x.copy_value(from: expr)`.
    set { take_value(from: source.copy()) }   // copy-initialization

    // The pattern `x = y.copy()` is compiled as `x.copy_value(from: y)`.
    inout { take_value(from: source.copy()) } // copy-assignment
  }

}
</code></pre>
<p>The compiler chooses an implementation based on the whether the left-hand-side is initialized and whether the RHS is consumed.</p>
<h2>
<a name="projections-15" href="#projections-15"></a>Projections</h2>
<p>A subscript or computed property <em>projects</em> a value rather than returning one. Unlike in Swift, a subscript in Val can be named and can be freestanding, like a function (as opposed to a method). Otherwise, it operates similarly to a Swift subscript.</p>
<pre><code>// A freestanding named subscript.
subscript min&lt;T: Comparable&gt;(_ x: T, _ y: T): T {
  if y &lt; x { yield y } else { yield x }
}

fun main() {
  let one = 1
  let two = 2
  print(min[one, two]) // 1
}
</code></pre>
<p>Note that, because <code>min(_:_:)</code> <code>yield</code>s rather than <code>return</code>ing a value, its parameters do not escape from the subscript.</p>
<p>A projection can be assigned to a local binding and used over multiple statements. For example:</p>
<pre><code>fun main() {
  var numbers = Array([3, 1, 6, 5, 4, 6, 2, 0])
  inout slice = numbers[in: 1 ..&lt; 5] // slice is projected out of `numbers`
  &amp;slice.sort()
  print(numbers) // [3, 1, 4, 5, 6, 2, 0]
}
</code></pre>
<p>Just like methods, subscripts and properties can bundle multiple implementations to represent different variants of the same functionality.</p>
<pre><code>type Angle {
  var radians: Double
  
  property degrees: Double {
    let {
      radians * 180.0 / Double.pi
    }
    inout {
      var d = radians * 180.0 / Double.pi
      yield &amp;d
      radians = d * Double.pi / 180.0
    }
    set(new_value) {
      radians = new_value * Double.pi / 180.0
    }
    sink {
      radians * 180.0 / Double.pi
    }
  }
}
</code></pre>
<p>Most of Val&#39;s accessors correspond to Swift&#39;s:</p>
<ul>
<li>A <code>let</code> subscript is like Swift&#39;s <code>_read</code> accessor. It is the default in Val, as it allows to project values without transferring their ownership.</li>
<li>An <code>inout</code> subscript is like Swift&#39;s <code>_modify</code> accessor.</li>
<li>A <code>set</code> subscript is like Swift&#39;s <code>set</code> accessor.</li>
</ul>
<p>However, <code>sink</code> subscripts are a bit different. They can be used to &#34;destructure&#34; a value and extract some of its parts. Although they overlap with <code>sink</code> methods, they serve to optimize cases where the value from which a projection is created is no longer used, and, crucially, their results can escape.</p>
<pre><code>fun main() {
  var numbers = Array([3, 1, 6, 5, 4, 6, 2, 0])
  var slice = numbers[in: 1 ..&lt; 5] // last use of &#39;numbers&#39;
  _ = slice.pop_first()
  print(slice)
}
</code></pre>
        </div></div>
  </body>
</html>
