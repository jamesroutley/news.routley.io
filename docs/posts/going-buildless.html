<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mxb.dev/blog/buildless/">Original</a>
    <h1>Going Buildless</h1>
    
    <div id="readability-page-1" class="page"><article aria-labelledby="going-buildless-title" id="going-buildless" itemscope="" itemtype="http://schema.org/BlogPosting" role="article"><div itemprop="articleBody"><p>The year is 2005. You&#39;re blasting a pirated mp3 of &#34;Feel Good Inc&#34; and chugging vanilla coke while updating your website.</p><p>It‚Äôs just a simple change, so you log on via FTP, edit your <code>style.css</code> file, hit save - and reload the page to see your changes live.</p><p>Did that story resonate with you? Well then congrats A) you‚Äôre a nerd and B) you‚Äôre old enough to remember a time before bundlers, pipelines and build processes.</p><p>Now listen, I really don‚Äôt want to go back to doing live updates in production. That can get painful real fast. But I think it‚Äôs amazing when the files you see in your code editor are exactly the same files that are delivered to the browser. No compilation, no node process, no build step. Just edit, save, boom.</p><p>There‚Äôs something really satisfying about a buildless workflow. Brad Frost recently wrote about it in <a href="https://bradfrost.com/blog/post/raw-dogging-websites/">‚Äúraw-dogging websites‚Äù</a>, while developing the (very groovy) site for <a href="https://frostapalooza.bradfrost.com/">Frostapalooza</a>.</p><p>So, how far are we away from actually working without builds in <a href="#html">HTML</a>, <a href="#css">CSS</a> and <a href="#javascript">Javascript</a>? The idea of ‚Äúbuildless‚Äù development isn‚Äôt new - but there have been some recent improvements that might get us closer. Let‚Äôs jump in.</p><div><p>The obvious tradeoff for a buildless workflow is performance. We use bundlers mostly to concatenate files for fewer network requests, and to avoid long dependency chains that cause &#34;loading waterfalls&#34;. I think it&#39;s still worth considering, but take everything here with a grain of performance salt.</p></div><h2 id="html" tabindex="-1">HTML</h2><p><a href="https://mxb.dev/blog/buildless/h-html"><span>Permalink to ‚ÄúHTML‚Äù</span> <span aria-hidden="true">#</span></a></p><p>The main reason for a build process in HTML is composition. We don‚Äôt want to repeat the markup for things like headers, footers, etc for every single page - so we need to keep these in separate files and stitch them together later.</p><p>Oddly enough, HTML is the one where native imports are still an unsolved problem. If you want to include a chunk of HTML in another template, your options are limited:</p><ul><li>PHP or some other preprocessor language</li><li>server-side includes</li><li>frames?</li></ul><p>There is no real standardized way to do this in just HTML, but Scott Jehl came up <a href="https://www.filamentgroup.com/lab/html-includes/">with this idea</a> of using iframes and the <code>onload</code> event to essentially achieve html imports:</p><pre><code><span><span><span>&lt;</span>iframe</span>
    <span>src</span><span><span>=</span><span>&#34;</span>/includes/something.html<span>&#34;</span></span>
    <span><span>onload</span><span><span>=</span><span>&#34;</span><span><span>this</span><span>.</span><span>before</span><span>(</span><span>(</span><span>this</span><span>.</span>contentDocument<span>.</span>body<span>||</span><span>this</span><span>.</span>contentDocument<span>)</span><span>.</span>children<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span><span>this</span><span>.</span><span>remove</span><span>(</span><span>)</span></span><span>&#34;</span></span></span>
<span>&gt;</span></span><span><span><span>&lt;/</span>iframe</span><span>&gt;</span></span></code></pre><p>Andy Bell then repackaged that technique as a neat <a href="https://codepen.io/andybelldesign/project/full/DyVyPG">web component</a>. Finally Justin Fagnani took it even further with <a href="https://github.com/justinfagnani/html-include-element">html-include-element</a>, a web component that uses native <code>fetch</code> and can also render content into the shadow DOM.</p><p>For my own buildless experiment, I built a <a href="https://github.com/maxboeck/zerobuild/blob/main/assets/js/html-include.js">simplified version</a> that replaces itself with the fetched content. It can be used like this:</p><pre><code><span><span><span>&lt;</span>html-include</span> <span>src</span><span><span>=</span><span>&#34;</span>./my-local-file.html<span>&#34;</span></span><span>&gt;</span></span><span><span><span>&lt;/</span>html-include</span><span>&gt;</span></span></code></pre><p>That comes pretty close to actual native HTML imports, even though it now has a Javascript dependency üò¢.</p><h3 id="server-side-enhancement" tabindex="-1">Server-Side Enhancement</h3><p><a href="https://mxb.dev/blog/buildless/h-server-side-enhancement"><span>Permalink to ‚ÄúServer-Side Enhancement‚Äù</span> <span aria-hidden="true">#</span></a></p><p>Right, so using web components works, but if you want to nest elements (fetch a piece of content that itself contains a <code>html-include</code>), you can run into waterfall situations again, and you might see things like layout shifts when it loads. Maybe progressive enhancement can help?</p><p>I‚Äôm hosting my experiment on Cloudflare Pages, and they offer the ability to write a ‚Äúworker‚Äù script (very similar to a service worker) to interact with the platform.</p><p>It‚Äôs possible to use a <a href="https://blog.cloudflare.com/introducing-htmlrewriter/">HTML Rewriter</a> in such a worker to intercept requests to the CDN and rewrite the response. So I can check if the request is for a piece of HTML and if so, look for the <code>html-include</code> element in there:</p><pre><code>
<span>export</span> <span>default</span> <span>{</span>
    <span>async</span> <span>fetch</span><span>(</span><span>request<span>,</span> env</span><span>)</span> <span>{</span>
        <span>const</span> response <span>=</span> <span>await</span> env<span>.</span><span>ASSETS</span><span>.</span><span>fetch</span><span>(</span>request<span>)</span>
        <span>const</span> contentType <span>=</span> response<span>.</span>headers<span>.</span><span>get</span><span>(</span><span>&#39;Content-Type&#39;</span><span>)</span>

        <span>if</span> <span>(</span><span>!</span>contentType <span>||</span> <span>!</span>contentType<span>.</span><span>startsWith</span><span>(</span><span>&#39;text/html&#39;</span><span>)</span><span>)</span> <span>{</span>
            <span>return</span> response
        <span>}</span>

        <span>const</span> origin <span>=</span> <span>new</span> <span>URL</span><span>(</span>request<span>.</span>url<span>)</span><span>.</span>origin
        <span>const</span> rewriter <span>=</span> <span>new</span> <span>HTMLRewriter</span><span>(</span><span>)</span><span>.</span><span>on</span><span>(</span>
            <span>&#39;html-include&#39;</span><span>,</span>
            <span>new</span> <span>IncludeElementHandler</span><span>(</span>origin<span>)</span>
        <span>)</span>

        <span>return</span> rewriter<span>.</span><span>transform</span><span>(</span>response<span>)</span>
    <span>}</span>
<span>}</span></code></pre><p>You can then define a custom handler for each <code>html-include</code> element it encounters. I made one that pretty much does the same thing as the web component, but server-side: it fetches the content defined in the <code>src</code> attribute and replaces the element with it.</p><pre><code>
<span>class</span> <span>IncludeElementHandler</span> <span>{</span>
    <span>constructor</span><span>(</span><span>origin</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>origin <span>=</span> origin
    <span>}</span>

    <span>async</span> <span>element</span><span>(</span><span>element</span><span>)</span> <span>{</span>
        <span>const</span> src <span>=</span> element<span>.</span><span>getAttribute</span><span>(</span><span>&#39;src&#39;</span><span>)</span>
        <span>if</span> <span>(</span>src<span>)</span> <span>{</span>
            <span>try</span> <span>{</span>
                <span>const</span> content <span>=</span> <span>await</span> <span>this</span><span>.</span><span>fetchContents</span><span>(</span>src<span>)</span>
                <span>if</span> <span>(</span>content<span>)</span> <span>{</span>
                    element<span>.</span><span>before</span><span>(</span>content<span>,</span> <span>{</span> <span>html</span><span>:</span> <span>true</span> <span>}</span><span>)</span>
                    element<span>.</span><span>remove</span><span>(</span><span>)</span>
                <span>}</span>
            <span>}</span> <span>catch</span> <span>(</span>err<span>)</span> <span>{</span>
                console<span>.</span><span>error</span><span>(</span><span>&#39;could not replace element&#39;</span><span>,</span> err<span>)</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    <span>async</span> <span>fetchContents</span><span>(</span><span>src</span><span>)</span> <span>{</span>
        <span>const</span> url <span>=</span> <span>new</span> <span>URL</span><span>(</span>src<span>,</span> <span>this</span><span>.</span>origin<span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span>
        <span>const</span> response <span>=</span> <span>await</span> <span>fetch</span><span>(</span>url<span>,</span> <span>{</span>
            <span>method</span><span>:</span> <span>&#39;GET&#39;</span><span>,</span>
            <span>headers</span><span>:</span> <span>{</span>
                <span>&#39;user-agent&#39;</span><span>:</span> <span>&#39;cloudflare&#39;</span>
            <span>}</span>
        <span>}</span><span>)</span>
        <span>const</span> content <span>=</span> <span>await</span> response<span>.</span><span>text</span><span>(</span><span>)</span>
        <span>return</span> content
    <span>}</span>
<span>}</span></code></pre><p>This is a common concept known as <a href="https://en.wikipedia.org/wiki/Edge_Side_Includes">Edge Side Includes</a> (ESI), used to inject pieces of dynamic content into an otherwise static or cached response. By using it here, I can get the best of both worlds: a buildless setup in development with no layout shift in production.</p><div><div><p>Cloudflare Workers run at the edge, not the client. But if your site isn&#39;t hosted there - It should also be possible to use this approach in a regular service worker. When installed, the service worker could <a href="https://github.com/worker-tools/html-rewriter">rewrite responses</a> to stitch HTML imports into the content.</p><p>Maybe you could even cache pieces of HTML locally once they&#39;ve been fetched? I don&#39;t know enough about service worker architecture to do this, but maybe someone else wants to give it a shot?</p></div></div><h2 id="css" tabindex="-1">CSS</h2><p><a href="https://mxb.dev/blog/buildless/h-css"><span>Permalink to ‚ÄúCSS‚Äù</span> <span aria-hidden="true">#</span></a></p><p>Historically, we‚Äôve used CSS preprocessors or build pipelines to do a few things the language couldn‚Äôt do:</p><ol><li>variables</li><li>selector nesting</li><li>vendor prefixing</li><li>bundling (combining partial files)</li></ol><p>Well good news: we now have native support for variables and nesting, and prefixing is not really necessary anymore in evergreen browsers. That leaves us with bundling again.</p><p>CSS has had <code>@import</code> support for a long time - it‚Äôs trivial to include stylesheets in other stylesheets. It‚Äôs just ‚Ä¶ really frowned upon. üòÖ</p><p>Why? Damn performance waterfalls again. Nested levels of <code>@import</code> statements in a render-blocking stylesheet give web developers the creeps, and for <a href="https://csswizardry.com/2023/10/the-three-c-concatenate-compress-cache/">good reason</a>.</p><p>But what if we had a flat structure? If you had just <em>one</em> level of imports, wouldn‚Äôt HTTP/2 multiplexing take care of that, loading all these files in parallel?</p><p>Chris Ferdinandi <a href="https://gomakethings.com/modular-css-and-different-ways-to-structure-your-stylesheets/#the-test-results">ran some benchmark tests</a> on precisely that and the numbers don‚Äôt look so bad.</p><p>So maybe we could link up a main stylesheet that contains the top-level imports of smaller files, split by concern? We could even use that approach to automatically assign cascade layers to them, like so:</p><pre><code>
<span><span>@layer</span> default<span>,</span> layout<span>,</span> components<span>,</span> utils<span>,</span> theme<span>;</span></span>

<span><span>@import</span> <span>&#39;reset.css&#39;</span> <span>layer</span><span>(</span>default<span>)</span><span>;</span></span>
<span><span>@import</span> <span>&#39;base.css&#39;</span> <span>layer</span><span>(</span>default<span>)</span><span>;</span></span>
<span><span>@import</span> <span>&#39;layout.css&#39;</span> <span>layer</span><span>(</span>layout<span>)</span><span>;</span></span>
<span><span>@import</span> <span>&#39;components.css&#39;</span> <span>layer</span><span>(</span>components<span>)</span><span>;</span></span>
<span><span>@import</span> <span>&#39;utils.css&#39;</span> <span>layer</span><span>(</span>utils<span>)</span><span>;</span></span>
<span><span>@import</span> <span>&#39;theme.css&#39;</span> <span>layer</span><span>(</span>theme<span>)</span><span>;</span></span></code></pre><h3 id="design-tokens" tabindex="-1">Design Tokens</h3><p><a href="https://mxb.dev/blog/buildless/h-design-tokens"><span>Permalink to ‚ÄúDesign Tokens‚Äù</span> <span aria-hidden="true">#</span></a></p><p>Love your atomic styles? Instead of Tailwind, you can use something like <a href="https://open-props.style/">Open Props</a> to include a set of ready-made design tokens without a build step. They‚Äôll be available in all other files as CSS variables.</p><p>You can pick-and-choose what you need (just get color tokens or easing curves) or use all of them at once. Open props is available on a CDN, so you can just do this in your main stylesheet:</p><pre><code>
<span><span>@import</span> <span>&#39;https://unpkg.com/open-props&#39;</span><span>;</span></span></code></pre><h2 id="javascript" tabindex="-1">Javascript</h2><p><a href="https://mxb.dev/blog/buildless/h-javascript"><span>Permalink to ‚ÄúJavascript‚Äù</span> <span aria-hidden="true">#</span></a></p><p>Javascript is the one where a build step usually does the most work. Stuff like:</p><ul><li>transpiling (converting modern ES6 to cross-browser supported ES5)</li><li>typechecking (if you‚Äôre using TypeScript)</li><li>compiling JSX (or other non-standard syntactic sugars)</li><li>minification</li><li>bundling (again)</li></ul><p>A buildless worflow can never replace <strong>all</strong> of that. But it may not have to! Transpiling for example is not necessary anymore in modern browsers. As for bundling: ES Modules come with a built-in composition system, so any browser that understands module syntax‚Ä¶</p><pre><code><span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>&#34;</span>/assets/js/main.js<span>&#34;</span></span> <span>type</span><span><span>=</span><span>&#34;</span>module<span>&#34;</span></span><span>&gt;</span></span><span></span><span><span><span>&lt;/</span>script</span><span>&gt;</span></span></code></pre><p>‚Ä¶allows you to import other modules, and even lazy-load them dynamically:</p><pre><code>
<span>import</span> <span>&#39;./some/module.js&#39;</span>

<span>if</span> <span>(</span>document<span>.</span><span>querySelector</span><span>(</span><span>&#39;#app&#39;</span><span>)</span><span>)</span> <span>{</span>
    <span>import</span><span>(</span><span>&#39;./app.js&#39;</span><span>)</span>
<span>}</span></code></pre><p>The newest addition to the module system are <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/importmap">Import Maps</a>, which essentially allow you to define a JSON object that maps dependency names to a source location. That location can be an internal path or an external CDN like <a href="https://unpkg.com/">unpkg</a>.</p><pre><code><span><span><span>&lt;</span>head</span><span>&gt;</span></span>
    <span><span><span>&lt;</span>script</span> <span>type</span><span><span>=</span><span>&#34;</span>importmap<span>&#34;</span></span><span>&gt;</span></span><span><span>
        <span>{</span>
            <span>&#34;imports&#34;</span><span>:</span> <span>{</span>
                <span>&#34;preact&#34;</span><span>:</span> <span>&#34;https://unpkg.com/htm/preact/standalone.module.js&#34;</span>
            <span>}</span>
        <span>}</span>
    </span></span><span><span><span>&lt;/</span>script</span><span>&gt;</span></span>
<span><span><span>&lt;/</span>head</span><span>&gt;</span></span></code></pre><p>Any Javascript on that page can then access these dependencies as if they were bundled with it, using the standard syntax: <code>import { render } from &#39;preact&#39;</code>.</p><h2 id="conclusion" tabindex="-1">Conclusion</h2><p><a href="https://mxb.dev/blog/buildless/h-conclusion"><span>Permalink to ‚ÄúConclusion‚Äù</span> <span aria-hidden="true">#</span></a></p><p>So, can we all ditch our build tools soon?</p><p>Probably not. I‚Äôd say for production-grade development, we‚Äôre not quite there yet. Performance tradeoffs are a big part of it, but there are lots of other small problems that you‚Äôd likely run into pretty soon once you hit a certain level of complexity.</p><p>For smaller sites or side projects though, I can imagine going the buildless route - just to see how far I can take it.</p><p>Funnily enough, many build tools advertise their superior ‚ÄúDeveloper Experience‚Äù (DX). For my money, there‚Äôs no better DX than shipping code straight to the browser and not having to worry about some cryptic <code>node_modules</code> error in between.</p><p>I‚Äôd love to see a future where we get that simplicity back.</p><h2 id="links" tabindex="-1">Links</h2><p><a href="https://mxb.dev/blog/buildless/h-links"><span>Permalink to ‚ÄúLinks‚Äù</span> <span aria-hidden="true">#</span></a></p><ul><li><a href="https://github.com/maxboeck/zerobuild">Repo for my demo code</a></li><li><a href="https://modern-web.dev/guides/going-buildless/getting-started/">Getting started with buildess</a></li><li><a href="https://modern-web.dev/docs/dev-server/overview/">A simple dev server for a buildless workflow</a></li><li><a href="https://www.spicyweb.dev/buildless-modern-development-workflows-are-this-close-to-a-reality/">‚ÄúA Real ‚ÄúBuildless‚Äù Modern Web Development Workflow? Oh Yes!‚Äù</a> by Jared White</li><li><a href="https://jvns.ca/blog/2023/02/16/writing-javascript-without-a-build-system/">‚ÄúWriting Javascript without a build system‚Äù</a> by Julia Evans</li></ul></div></article></div>
  </body>
</html>
