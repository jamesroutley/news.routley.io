<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://chriskiehl.com/article/event-sourcing-is-hard">Original</a>
    <h1>Event Sourcing Is Hard (2019)</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><article><p><img alt="" src="https://d39wtn5cxihhz5.cloudfront.net/content/800Pasted image 20210923205452.jpeg" srcset="https://d39wtn5cxihhz5.cloudfront.net/content/800Pasted image 20210923205452.jpeg 800w, https://d39wtn5cxihhz5.cloudfront.net/content/667Pasted image 20210923205452.jpeg 667w, https://d39wtn5cxihhz5.cloudfront.net/content/534Pasted image 20210923205452.jpeg 534w, https://d39wtn5cxihhz5.cloudfront.net/content/401Pasted image 20210923205452.jpeg 401w, https://d39wtn5cxihhz5.cloudfront.net/content/268Pasted image 20210923205452.jpeg 268w, https://d39wtn5cxihhz5.cloudfront.net/content/135Pasted image 20210923205452.jpeg 135w"/></p><p><sup>published 2019-02-03</sup></p><p>I&#39;m going to give it to you straight: event sourcing actually comes with drawbacks. If you&#39;ve read anything about the topic on the internet this will surely shock you. After all, it&#39;s commonly sold as one big fat bag of sunshine and rainbows. You got some kind of a problem? Turns out its actually solved by event sourcing. In fact, most of your life troubles up till now were probably directly caused by your <i>lack</i> of event sourcing.</p><p>You, having been seduced by the internet, are probably off to start your event sourcing journey and begin living the good life. Well, before you do that, I&#39;m here to ruin it for you and tell you that event sourcing is not actually a bag filled with pure joy, but instead a bag filled with mines designed to blow your legs off and leave you to a crippled life filled with pain.</p><p>Why would I say such things? Because I&#39;m a guy who previously drank the juice, had the power to make design calls, and took a team down the path of building an event sourced system from scratch. After an aggressive year of deploying a complex application, I&#39;ve collected a lot of scars, bruises, and lessons learned. Below are my opinions, unexpected hurdles, bad assumptions, bad understandings, after growing an Event Sourced application.</p><h3>Preface</h3><p>To be clear, this is not a &#34;you should never event source&#34;, or an &#34;event sourcing is the worst thing ever&#34;, this is just a collection of the unexpected costs and problems that popped up while putting an event sourcing powered system into production. The bulk of these probably fall under &#34;he obviously didn&#39;t understand X,&#34; or &#34;you should <i>never</i> do Y!&#34; in which case you would be absolutely right. The point of this is that I didn&#39;t understand the drawbacks or pain points until I&#39;d gotten past the &#34;toy&#34; stage.</p><p>Without further ado...</p><h3>The core selling point of Event Sourcing is largely an anti-pattern</h3><blockquote><p> In my humble, opinion, of course </p></blockquote><p>The big Event Sourcing &#34;sell&#34; is the idea that any interested sub-systems can just subscribe to an event stream and happily listen away and do its work. Y&#39;know, <i>this</i> picture, that you&#39;ll find in pretty much any Event Sourcing Intro:</p><p><img alt="" src="https://d39wtn5cxihhz5.cloudfront.net/content/800Pasted image 20210923205609.jpeg" srcset="https://d39wtn5cxihhz5.cloudfront.net/content/800Pasted image 20210923205609.jpeg 800w, https://d39wtn5cxihhz5.cloudfront.net/content/667Pasted image 20210923205609.jpeg 667w, https://d39wtn5cxihhz5.cloudfront.net/content/534Pasted image 20210923205609.jpeg 534w, https://d39wtn5cxihhz5.cloudfront.net/content/401Pasted image 20210923205609.jpeg 401w, https://d39wtn5cxihhz5.cloudfront.net/content/268Pasted image 20210923205609.jpeg 268w, https://d39wtn5cxihhz5.cloudfront.net/content/135Pasted image 20210923205609.jpeg 135w"/></p><blockquote><p> Image via: <a href="https://www.amazon.com/Microservices-Clojure-event-driven-microservices-monitoring-ebook/dp/B076VKG1Y1/ref=sr_1_fkmr0_1?ie=UTF8&amp;qid=1547352676&amp;sr=8-1-fkmr0&amp;keywords=microservices+in+clojure">Microservices with Clojure</a> </p></blockquote><p>In practice, this manages to somehow simultaneously be both extremely coupled and yet excruciatingly opaque. The idea of a keeping a central log against which multiple services can subscribe and publish is insane. You wouldn&#39;t let two separate services reach directly into each other&#39;s data storage when <i>not</i> event sourcing – you&#39;d pump them through a layer of abstraction to avoid breaking every consumer of your service when it needs to change its data – However, with the event log, we pretend this isn&#39;t the case. &#34;Reach right on in there and grab those raw data events&#34;, we say. They&#39;re immutable &#34;facts&#34; after all. And Immutable things don&#39;t change, right? (<i>*cough* no *cough*</i>)</p><p>In effect, the raw event stream subscription setup kills the ability to locally reason about the boundaries of a service. Under &#34;normal&#34; development flows, you operate within the safe, cozy little walls which make up your service. You&#39;re free to make choices about implementation and storage and then, when you&#39;re ready, deal with how those things get exposed to the outside world. It&#39;s one of the core benefits of &#34;services&#34;. However, when people are reaching into your data store and reading your events directly, that &#39;black box&#39; property goes out the window. Coordination can&#39;t be bolted on later, you have to talk to the people who will be consuming the events you produce to ensure that the events include enough data for the consuming system to make a decision.</p><p>If you fight through the above obstacle and manage to successfully wire a fleet of services together via an event stream, you&#39;ll be rewarded with a new problem: opacity. With multiple systems just reading an event stream sans any coordination layer, <i>how</i> these system actually work and connect together will eventually be completely baffling. You&#39;ve basically got <a href="https://infoscience.epfl.ch/record/176887/files/DeprecatingObservers2012.pdf">all the problems that come with Observer heavy code</a>, but now on the system level. Control becomes inverted in a way that makes it difficult to reason about how data actually flows through the systems, or which systems consume / produce events, or care if they&#39;re added / removed / modified, etc.. etc..</p><p>Now, to be fair, <a href="https://youtu.be/LDW0QWie21s?t=2391">Greg Young has a talk</a> where he mentions these problems and advocates for solving them via Process Managers or simple Actor based setups i.e. introducing something which can serve as central coordination point which can route events. However, I didn&#39;t see that talk until much later. I went in thinking that ledgers would rule the world, and had to slowly discover the need for this meta management layer by painfully bumping into all the bits that <i>don&#39;t</i> work with the Event Sourcing setup <i>as commonly sold</i>.</p><h3>The upstart costs are large</h3><p>Event Sourcing is not a &#34;<i>Move Fast and Break Things</i>&#34; kind of setup when you&#39;re a green field application. It&#39;s a more of a &#34;<i>Let&#39;s all Move Slow and Try Not to Die</i>&#34; sort of setup. For one, you&#39;re <i>probably</i> going to be building the core components from scratch. Frameworks in this area tend to be heavy weight, overly prescriptive, and inflexible in terms of tech stacks. If you want to get something up in running in your corporate environment with the tech available to you <i>today</i>, rolling your own is the way to go (<a href="https://youtu.be/LDW0QWie21s?t=1926">and a suggested approach!</a>).</p><p>While this path is honestly a <em>ton</em> of fun, it&#39;s also super time consuming. It will all be time which is not being spent making actual forward progress on your application. Entire sprints will be lost to planning out how you deploy things on the infrastructure available, how to ensure streams behave, messages get processed, how failures will be retried, and <i>then</i> you&#39;ve got to actually go about implementing it, learning what sucks about your choices, implementing it again with your newly gained knowledge, until you end up with a solid enough foundation upon which you can actually begin to build the application in question.</p><p>And once you&#39;re into the implementation stage, you&#39;ll realize something else: the shear volume of plumbing code involved is staggering. Instead of your friendly N-tier setup, you&#39;ve now got classes for commands, command handlers, command validators, events, aggregates, <i>AND THEN</i> your projections, those model classes, their access classes, custom materialization code, and so on. Getting from zero to working baseline requires significant scaffolding. Now, admittedly, how much this hurts is somewhat language dependent, but if you&#39;re is an already verbose language like Java (like I was), your fingers will be tired at the end of each day.</p><p>As a final point on the Getting Started side of things, there&#39;s a certain human / political cost involved. Getting an entire development team onboard philosophically is non-trivial. There will be those excited by the idea who read up on it outside work and are down for riding out the growing pains involved in trying alternative development methodologies, and then there will be those who aren&#39;t into it <i>at all</i>. However, regardless of which &#34;camp&#34; a person is in, disagreements will still mount as everyone tries to figure out how best to build a maintainable a system under a foreign methodology with unclear best practices.</p><p>These team problems can additionally creep outside of your immediate development group. Getting tertiary members like UX involved presents its own challenges. Which leads to the unexpected point of...</p><h3>Event sourcing needs the UI side to play along</h3><p>This one, while obvious in retrospect, caught me by surprise. If you have a UI, it generally needs to play along with the event driven aspect of the back end. Meaning, it should be <a href="https://www.uxmatters.com/mt/archives/2014/12/task-driven-user-interfaces.php">task based</a>. However, the bulk of common UI iterations <i>aren&#39;t</i> designed that way. They&#39;re static and form based. Which means you end up with a massive impedance mismatch between the back-end, which wants small semantic events, and the front-end, which is giving you fat blobs of form data.</p><p>A common response to would be the argument that maybe those heavy form driven parts of the application shouldn&#39;t be written to a ledger at all – let CRUD be CRUD, and that&#39;s an interesting argument, which brings me to..</p><h3>You&#39;ll potentially be building two entirely different systems along side each other</h3><p>A super common piece of advice in the ES world is that <a href="https://www.infoq.com/news/2016/04/event-sourcing-anti-pattern">you don&#39;t event source everywhere</a> <small>*</small>. This is all well and good at the conceptual level, but actually figuring out where and when to draw those architectural boundaries through your system is quite tough in practice.</p><p>The core reason is that the requirements that likely led you to Event Sourcing in the first place generally don&#39;t go away just because some parts of your application are more &#34;CRUD-y&#34;. If you still need to audit your data, do you build out a totally different audit strategy for those non-event driven parts, or just reuse the ledger setups you&#39;ve already deployed and tested? What about communication with other systems? Do you build out new communication channels, or reuse the streaming architecture already in place?</p><p>There&#39;s no clear answer because no path is ideal. Each one comes with its own pain points and draw backs.</p><p>* ...although this flies in the face of <i>other</i> advice like <a href="https://webcache.googleusercontent.com/search?q=cache:7LlBzKXMJhUJ:https://blog.csdn.net/waterboy/article/details/143597+&amp;cd=4&amp;hl=en&amp;ct=clnk&amp;gl=us">&#34;only CRUD when you can afford it&#34;</a></p><h3>Past system states from the audit Log will often have fidelity problems</h3><blockquote><p> Unless you&#39;re willing to go into crazy person territory. </p></blockquote><p>Software changes, requirements change, focuses shift. Those immutable &#34;facts,&#34; along with your ability to process them, won&#39;t last as long as you expect.</p><p>We made it about a month before a shift in focus caused us to hit our first &#34;oh, so these events are no longer relevant, <i>at all</i>?&#34; situation. Once you hit this point, you&#39;ve got a decision to make: what to do with the irrelevant / wrong / outdated events.</p><p>Do you keep the now deprecated events in the ledger, but &#34;cast&#34; them up to new events (or <code>no-op</code>s) during materialization, or do you rewrite the ledger itself to remove/cast the old events? The best practices in this area are often debated.</p><p>Regardless of which path you take, as soon as you take it, you&#39;ve lost the ability to accurately produce the state of your system <i>at the point in time of the rewrite</i>. (unless you have the deep character flaws required to do something <a href="https://martinfowler.com/eaaDev/TemporalProperty.html">completely psychotic</a>, of course).</p><p>So, the often sold idea of a <a href="http://eventuate.io/whyeventsourcing.html">&#34;100% accurate audit log&#34;</a> and <a href="http://eventuate.io/whyeventsourcing.html">&#34;easy temporal queries!&#34;</a> ends up suffering from a case of &#34;nope&#34; once you get past the conceptual / toy stage and bump into the real world. If you&#39;ve sold your magical log idea to stake holders, this fidelity loss over time could pose issues depending on your domain.</p><h3>The audit log is often <i>too</i> chatty for direct use</h3><p>This one is obviously <i>very</i> business / use case dependent, but having a full low-level audit log of every action in the application was often more of a hindrance than a help. Meaning, most of it ends up being pure noise that actually needs filtered out, both by end users, and by consuming sub-systems. All of those transient &#34;Bob renamed field x to y&#34; are seldom of interest. If you&#39;re showing the audit log to an end user, more often than not, discrete logical states are of far more value than transient intermediates. So, the &#34;free audit log&#34; actually turns into &#34;tedious projection writing.&#34; For downstream systems, this chattiness causes similar coordination woes. &#34;When should I actually run?&#34; and &#34;should I care about event X?&#34; was a common question during design meetings. It&#39;s all in the class of problems that require either Process Managers or the introduction of queues to solve.</p><h3>The audit log as a debugging tool considered: over hyped</h3><p>Minor, but worth pointing out: another touted benefit to being ledger based is that it helps with debugging. &#34;If you find a bug in your application, you can replay the log to see how you got into that state!&#34; I&#39;m yet to see this play out. 99% of the time &#34;bad states&#34; were <i>bad events</i> caused by your standard run-of-the-mill human error. No different than any other &#34;how did that get in the database?&#34; style problem. Having a ledger provided little value over your normal debugging intuition when using a standard db set. Meaning, if an <code>age</code> field was corrupt, you&#39;d probably know which code to start investigating.</p><h3>Projections are not actually free</h3><p>&#34;You&#39;re no longer bound to a single table structure&#34;, says Event Sourcing. If you need a different view of your data, just materialize the event log in a new way. &#34;It&#39;s so easy!&#34;</p><p>In practice, this is expensive both in terms of initial development cost and ongoing maintenance. That first extra projection you add doubles the amount of code that touches your event stream. And odds are, you&#39;ll be writing more than one projection. So now you have N things processing this event stream instead of 1 thing. There&#39;s no more <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY</a> from this point forward. If you add, modify, or remove an event type, you&#39;re on the hook for spreading knowledge of that change to N different places.</p><h3>You&#39;ll deal with materialization lag:</h3><p>Once your data grows to the point where you can no longer materialize from the ledger in a reasonable amount of time, you&#39;ll be forced to offload the reads to your materialized projections. And with this step comes materialization lag and the loss of read-after-write consistency.</p><p><img alt="" src="https://d39wtn5cxihhz5.cloudfront.net/content/800Pasted image 20210923205644.jpeg" srcset="https://d39wtn5cxihhz5.cloudfront.net/content/800Pasted image 20210923205644.jpeg 800w, https://d39wtn5cxihhz5.cloudfront.net/content/667Pasted image 20210923205644.jpeg 667w, https://d39wtn5cxihhz5.cloudfront.net/content/534Pasted image 20210923205644.jpeg 534w, https://d39wtn5cxihhz5.cloudfront.net/content/401Pasted image 20210923205644.jpeg 401w, https://d39wtn5cxihhz5.cloudfront.net/content/268Pasted image 20210923205644.jpeg 268w, https://d39wtn5cxihhz5.cloudfront.net/content/135Pasted image 20210923205644.jpeg 135w"/></p><p>Information is now either outdated, missing, or just wrong. Newly created data will 404, deleted items will awkwardly stick around, duplicate items will be returned, you get the gist. Basically all the joys of the <i>eventual</i> part of consistency.</p><p>Individually, they&#39;re not a huge deal, but these are still things you have to spend time solving. Do you bake in a fall-back strategy for reads? Do you spend time adding smarts to the materialization itself in order to make it faster? Do you write logic to allow the caller to request the type of read they want (i.e. ledger, at the cost of latency, or projected, at the cost of consistency)?</p><p>There are a ton of ways to solve it. But <i>you</i> having to solve it is the key thing I&#39;m getting at here. This is time that needs to be accounted for, planned, implemented, and deployed (all at the expense the thing you&#39;re <i>supposed</i> to be solving!).</p><h3>Finally: You won&#39;t really know the pain points until you&#39;re past the toy level.</h3><p>This is just the reality of maintaining any long-lived software. Regardless of how much you try to prepare, how much background reading you do, or how many prototypes you build, you&#39;re doing something totally <i>new</i>. The problems that cause the most pain won&#39;t manifest themselves in small test programs. It&#39;s only once you have a living, breathing machine, users which depend on you, consumers which you can&#39;t break, and all the other real-world complexities that plague software projects that the hard problems in event sourcing will rear their heads. And once you hit them, you&#39;re on your own. </p><h3>So what now?</h3><p>Event Sourcing isn&#39;t <i>all</i> bad, my complaint with it is just that it is wildly over sold as a cure all and rarely are any negative side-effects talked about. I still really like the <i>ideas</i> from event sourcing, it&#39;s just that putting it into practice caused more pain than I would have otherwise liked.<br/></p><h3>What&#39;s the take away here? Should I event source or not!?</h3><p>I think you can generally answer it with some alone time, deep introspection, and two questions:</p><ol><li>For which <i>core problem</i> is event sourcing the solution?</li><li>Is what you actually want just a plain old queue?</li></ol><p>If you can&#39;t answer the first question concretely, or the justification involves vague hand-wavy ideas like &#34;auditablity&#34;, &#34;flexibility,&#34; or something about &#34;read separation&#34;: <strong>Don&#39;t</strong>. Those are not problems exclusively solved by event sourcing. A good ol&#39; fashion history table gets you 80% of the value of a ledger with essentially none of the cost. It won&#39;t have first class change semantics baked in, but those low-level details are mostly worthless anyway and can ultimately be derived at a later date if so required. Similarly CQRS doesn&#39;t require event sourcing. You can have all the power of different projections <i>without</i> putting the ledger at the heart of your system.</p><p>The latter question is to weed out confused people like myself who thought the Ledgers would rule the world. Look at the interaction points of your systems. If you&#39;re going full event sourcing, what events are actually going to be produced? Do those downstream systems care about those intermediate states, or will it just be noise that needs to be filtered out? If the end goal is just decoupled processes which communicate via <i>something</i>, event sourcing is not required. Put a queue between those two bad boys and start enjoying the good life.</p><p>Edit: 2018-02-05:</p><p>This spawned lots of interesting discussion  on <a href="https://news.ycombinator.com/item?id=19072850">Hacker News</a> and <a href="https://old.reddit.com/r/programming/comments/amvde6/dont_let_the_internet_dupe_you_event_sourcing_is/">Reddit</a>. Am I a dumbass? Am I a genius?! Am I just a regular dude that makes mistakes?! Find out inside!</p></article></div></div></div></div>
  </body>
</html>
