<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.ashbyhq.com/blog/company/tiptap-part-1">Original</a>
    <h1>Switching Rich Text Editors, Part 1: Picking Tiptap</h1>
    
    <div id="readability-page-1" class="page"><div><div id="blog-content"><div><p>Once you&#39;ve picked a rich text library for your application, switching to a new one isn&#39;t easy and carries many risks. We recently changed the rich text library we use at Ashby, and, with research and planning, we were able to do it with minimal issues in production. We wanted to share that research and process with the hope that it helps you make a similar switch. </p><p>This post is part one of a two-part series about how we switched from Slate to <a href="https://tiptap.dev/" rel="noopener" target="_blank">tiptap</a>. Today, we&#39;ll explain the process we used to decide on tiptap, and our follow-up post will describe how we made the switch.</p><h2>Time to Switch</h2><p>We added rich text editing to Ashby in 2019. We evaluated multiple solutions to make our decision (including <a href="https://quilljs.com/" rel="noopener" target="_blank">Quill</a> and <a href="https://draftjs.org/" rel="noopener" target="_blank">Draft.js</a>), and eventually went with <a href="https://www.slatejs.org/examples/richtext" rel="noopener" target="_blank">Slate</a>.</p><p>Like many libraries back then, Slate was in beta but quickly improving and expanding. We took a chance that Slate would support more browsers and its API would remain stable (despite the maintainers strongly suggesting that both might not happen!). Unfortunately, our gamble didn&#39;t pay off, and the maintainers introduced significant breaking changes to the API and document model in <code>0.50.x</code>. These changes were the right direction for the future of Slate but would require a lot of work for us to migrate to —work we couldn&#39;t do as a small engineering team (even with the <a href="https://github.com/ianstormtaylor/slate/issues/3215" rel="noopener" target="_blank">great support the community was providing</a>).</p><p>We stayed on <code>0.47.x</code> as long as we could, but our users were growing, and we needed to upgrade Slate to fix issues and support more browsers. There were more rich text editor libraries to choose from since 2019, so we decided to evaluate switching to a new library in addition to upgrading Slate.</p><h2>Find All Possible Candidates</h2><p>We created a comprehensive list of rich text editor libraries to evaluate. While Google is useful, ranking in Google Search is a popularity contest, not a quality test. To be exhaustive, we started with the initial list of libraries we found back in 2019 and used the references to other libraries in their documentation to find more. For instance, Slate lists Draft.js, Prosemirror, and Quill as inspirations <a href="https://docs.slatejs.org/" rel="noopener" target="_blank">in their introduction document</a>. Quill <a href="https://quilljs.com/guides/comparison-with-other-rich-text-editors/" rel="noopener" target="_blank">lists</a> CKEditor, TinyMCE, Draft.js, Prosemirror, and Trix. Using this method, we gathered a list of more than ten candidates.</p><h2>Find Showstoppers</h2><p>We went through the candidates and made a list of key library attributes using available documentation, blog posts, and other information we could find. Some key attributes that we collected across the board were:</p><ul><li><strong>Beta or stable</strong>: It&#39;s not a showstopper if a library is in beta, but it&#39;s essential to know if using it introduces the risk of breaking changes.</li><li><strong>Stars on GitHub</strong>: This is not a quality measure by any means, but it gives you a feeling of the library&#39;s community and how active it is.</li><li><strong>React support</strong>: We built our app with React, so the ease of using the library in React is essential.</li><li><strong>Browser support</strong>: This was one of our main pain points with Slate <code>0.47.x</code>, so we wanted to ensure that all major browsers on desktop and mobile had good support.</li><li><strong>Age of last release</strong>: This shows how actively maintained the library is. Stable or not, the landscape around javascript libraries is constantly evolving, so there&#39;s always something to be done. No app is ever &#34;finished.&#34;</li><li><strong>Age of last commit</strong>: Like the age of the last release, this gives you a feeling of how active the community is, even if the latest release has aged, and a proxy for how quickly issues are fixed.</li><li><strong>Current version</strong>: If we ever looked back at our notes, we knew what version we had evaluated and see if things changed since then.</li></ul><p>Typical showstoppers we identified:</p><ul><li>Missing or outdated support for React</li><li>Missing mobile support (or no clear stance in that area)</li><li>Hard to visually customize</li><li>Missing extensibility or unclear documentation around extensions or plugins</li><li>Small community or no recent updates</li></ul><p>In addition to the key attributes, there were common features that we paid attention to across all libraries. The number grew as we looked at each library—we&#39;d often find something that stood out in one library and see if other libraries supported it. For instance, the available extensions in tiptap satisfied most of our needs (including @-mentions) and began to compare that across libraries. </p><p>We exited this phase with a shortlist of five libraries: Slate, Quill, Prosemirror, ReMirror, and tiptap.</p><h2>Prototyping</h2><p>We didn&#39;t write a single line of code until this point, but it was time to start building quick prototypes to get a better feel for each library.</p><p>The goal of each prototype was to come as close as possible to the current state of the editor (visually and functionally). To keep each prototype around half a workday and come to an airtight statement:</p><ul><li>We used our existing frontend components (e.g., buttons, icons, CSS).</li><li>We didn&#39;t implement custom extensions —if it wasn&#39;t a ready-to-use feature, we left it out (e.g., @mentions). </li><li>We didn&#39;t implement interoperability with the current editor and its document model. Each prototype would only work standalone, with a new document from the library&#39;s documentation.</li></ul><p>Eventually, we were able to compare a couple more things about our shortlist candidates:</p><ul><li>Developer experience</li><li>Documentation quality</li><li>Customizability</li><li>User experience</li></ul><h2>Gather Data</h2><p>With this experience, we listed the advantages and disadvantages of each of the libraries based on our needs. These might not be valid at the time you read this, or you might consider something that we identified as an advantage as a disadvantage (and vice versa).</p><p>We collected the data (including version numbers and GitHub stars) in May 2021. All conclusions have been drawn based on the library version listed next to the names. The libraries might have evolved significantly since then.</p><h3>Slate <code>0.63.0</code> (20.6k ⭐)</h3><p>We felt sure that migrating to the latest version was similar to starting from scratch. A significant disadvantage was that we couldn&#39;t have both <code>0.47.x</code> and <code>0.63.0</code> in our application simultaneously. Not using both simultaneously prevented us from gradually migrating features, and we&#39;d need to do a complete rip and replace.</p><p>We liked that Slate was built for React (and didn&#39;t need a wrapper), had a large user base, was actively maintained, and had prior experience with it. However, it&#39;s still in beta, android support is experimental, and the maintainers still warn users about breaking API changes.</p><h3>Quill <code>1.3.7</code> (29.9k ⭐️)</h3><p>Quill is popular with well-known brands and officially maintained by Slab, a wiki we use for our internal documentation (and love!). Quill&#39;s main advantages were its popularity, its recommendations within our network, and that it had a stable release.</p><p>Quill itself doesn&#39;t offer any React support, and for our prototype, we used react-quill, a third-party dependency in beta. Although it&#39;s actively maintained, the current stable release is from 2019 (there&#39;s an ongoing effort for a new major version).</p><h3>ProseMirror (5.7k ⭐️)<a href="#footnote-1">1</a></h3><p>We considered going directly with ProseMirror (a &#34;toolkit for building rich-text editors on the web&#34;) and not a ready-to-use rich-text editor. ProseMirror would&#39;ve given us the most control over the editing experience, but we decided the overhead of implementing our editor with the ProseMirror toolkit was too much work.</p><p>To us, Prosemirror stood out as the most powerful solution. We wouldn&#39;t have needed any third-party dependencies (except for a React integration) and would have been able to define our document schema from the ground up. We didn&#39;t go with it because it took a lot of code to get started (even the official ProseMirror guides <a href="https://prosemirror.net/examples/basic/" rel="noopener" target="_blank">state this</a>) and defining our custom schema, while powerful, was not worth the effort since we didn&#39;t have many custom requirements.</p><p>We still liked ProseMirror, which led us to two available React integrations: ReMirror and tiptap.</p><h3>ReMirror<code>1.0.0-next.60</code> (1.1k ⭐️)</h3><p>We liked many things about ReMirror. It&#39;s a ProseMirror editor built on React and comes with extensions that covered most of our requirements.</p><p>It was hard not to go with ReMirror since we liked it as much as tiptap, but when evaluating both frameworks in May 2021, tiptap felt a little more mature.</p><p>Since we evaluated the rich text editor libraries, ReMirror made impressive progress. The library became stable, added many extensions, and the community grew. There&#39;s no longer much difference between ReMirror and tiptap, and it&#39;s a great example of how quickly a library can change. While we&#39;re still delighted with tiptap, today&#39;s ReMirror would have met our needs!</p><h3>tiptap <code>2.0.0-beta60</code> (10.8k ⭐️)</h3><p>Tiptap ticked a lot of boxes for us. The library (like ReMirror) builds on top of ProseMirror. While it was created initially for Vue and relied on a third-party wrapper for React, it gained official react support in <code>2.0.0</code>. Tiptap is in beta, so breaking changes are still possible, and the maintainers almost change things daily. Its API was the simplest of all libraries that we used in the prototyping phase, and we also liked that we could fall back to native ProseMirror code if necessary.</p><p>As with ProseMirror and ReMirror, tiptap met most of our requirements with its available extensions, so we only needed to implement a hand full of them. A drawback with all of the ProseMirror-based editors (and ProseMirror itself) is that ProseMirror is not a React library, so some bridging between vanilla javascript and React is necessary.</p><h2>Showdown</h2><p>A library can work great in a sandbox environment, but integrating it with an existing codebase can surface issues. We wanted to find these issues as early as possible, so we implemented the first draft of Ashby&#39;s rich text editor with our favorite library, tiptap.</p><p>We paired the first draft with our usual writing process and technical specification to tease out more issues and tasks. The specifications covered motivations, goals, research, and a detailed roadmap of how we&#39;d implement the new editor and make the switch in production.</p><p>I shared the specification and first draft implementation (via a pull request) with the team to get feedback.</p><h2>Decision</h2><p>Once we answered all questions and responded to all comments, it was clear tiptap would be the best solution for our needs and we were ready to use it as Ashby&#39;s new rich text library.</p><p>In part two, we&#39;ll share our migration plan from one library to the other and the challenges we faced executing that plan and releasing to production.</p></div></div></div></div>
  </body>
</html>
