<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rabbitcavern.substack.com/p/should-we-drain-the-everglades">Original</a>
    <h1>Should we drain the Everglades?</h1>
    
    <div id="readability-page-1" class="page"><article><header><time datetime="2025-09-13 19:49:24 +0530">13 Sep 2025</time></header><p>Setsum is an order agnostic, commutative checksum. It was developed by <a href="https://rescrv.net">Robert Escriva</a> at Dropbox’s metadata team. In this short post, I’ll explain why they’re used and the math behind them. Jump to the end if you’d like to see the code.</p><h2 id="introduction">Introduction</h2><p>Say you’re building a database replication system. The primary sends logical operations to replicas, which apply them in order:</p><div><pre tabindex="0"><code data-lang="json"><span><span>{<span>&#34;op&#34;</span>: <span>&#34;add&#34;</span>, <span>&#34;id&#34;</span>: <span>&#34;apple&#34;</span>}
</span></span><span><span>{<span>&#34;op&#34;</span>: <span>&#34;add&#34;</span>, <span>&#34;id&#34;</span>: <span>&#34;apple&#34;</span>}
</span></span><span><span>{<span>&#34;op&#34;</span>: <span>&#34;remove&#34;</span>, <span>&#34;id&#34;</span>: <span>&#34;orange&#34;</span>}
</span></span></code></pre></div><p>After the replica processes these changes (add two apples, remove an orange), how do you verify both nodes ended up in the same state?</p><p>One naive (rather horrible) approach is to dump both states and compare them directly. It’s expensive, impractical, and doesn’t scale. Instead, you can maintain checksums that update with each operation. When you’re done, just compare the checksums; if they match, you’re in sync. That’s why distributed databases like Cassandra use Merkle trees for the same purpose.</p><p>Setsum is similar but has some nice properties that make it attractive over Merkle trees. They can be computed incrementally; the cost only depends on the change being applied, not the whole dataset. I also find them attractive because they let you remove items as well.</p><h2 id="properties">Properties</h2><p>Setsum has some interesting properties:</p><p><strong>1. Order doesn’t matter.</strong> Both of these yield the same result:</p><div><pre tabindex="0"><code data-lang="rust"><span><span>s1 <span>=</span> New()
</span></span><span><span>s1.add(<span>&#34;apple&#34;</span>)
</span></span><span><span>s1.add(<span>&#34;banana&#34;</span>)
</span></span><span><span>
</span></span><span><span>s2 <span>=</span> New()
</span></span><span><span>s2.add(<span>&#34;banana&#34;</span>)
</span></span><span><span>s2.add(<span>&#34;apple&#34;</span>)
</span></span><span><span>
</span></span><span><span>assert_eq(s1, s2)
</span></span></code></pre></div><p><strong>2. You can remove items.</strong> These are equivalent:</p><div><pre tabindex="0"><code data-lang="rust"><span><span>s1.add(<span>&#34;apple&#34;</span>)
</span></span><span><span>s1.add(<span>&#34;banana&#34;</span>)
</span></span><span><span>s1.remove(<span>&#34;apple&#34;</span>)
</span></span><span><span>
</span></span><span><span>s2.add(<span>&#34;banana&#34;</span>)
</span></span><span><span>s2.add(<span>&#34;banana&#34;</span>)
</span></span><span><span>s2.remove(<span>&#34;banana&#34;</span>)
</span></span><span><span>
</span></span><span><span>assert_eq(s1, s2)
</span></span></code></pre></div><p><strong>3. You can combine setsums.</strong> As you guessed already, these are equal:</p><div><pre tabindex="0"><code data-lang="rust"><span><span>s1.add(<span>&#34;apple&#34;</span>)
</span></span><span><span>s1.add(<span>&#34;banana&#34;</span>)
</span></span><span><span>s2.add(<span>&#34;chikoo&#34;</span>)
</span></span><span><span>
</span></span><span><span>s3.add(<span>&#34;banana&#34;</span>)
</span></span><span><span>s3.add(<span>&#34;chikoo&#34;</span>)
</span></span><span><span>s3.add(<span>&#34;apple&#34;</span>)
</span></span><span><span>
</span></span><span><span>assert_eq(s1<span>+</span>s2, s3)
</span></span></code></pre></div><p>The only state you need to maintain is 256 bits, and all operations are <code>O(len(msg))</code> instead of depending on your entire dataset.</p><h2 id="the-internals">The internals</h2><p>Each Setsum is an array of 8 unsigned 32-bit integers (u32), called “columns”. Each column starts at 0 when you create a new Setsum. Each column has an associated large prime number (close to <code>u32::MAX</code>).</p><p>When you add an item:</p><ul><li>Compute the SHA3-256 hash of the item (produces 32 bytes)</li><li>Split the hash into 8 chunks of 4 bytes each</li><li>Interpret each chunk as a little-endian u32</li><li>Add each number to its corresponding column</li><li>If the sum exceeds the column’s prime, store the remainder (mod prime)</li></ul><p>You can also remove an item that was previously added. The magic is in computing the inverse: first, derive the inverse of the item’s hashed value, then add that inverse to the setsum. This effectively cancels out the original, removing the item from the set!</p><p>To compute the inverse, we use modular arithmetic: it’s simply the prime minus the value.</p><h2 id="the-math-behind-setsum">The math behind setsum</h2><p>Disclaimer: If we’re friends, you already know I’m no math person. If not, hey there, new friend! You can probably skip this if you understand modulo arithmetic, the Chinese remainder theorem, and a bit of probability.</p><p>Let’s simplify: instead of 8 columns, let’s use just one. The prime number for this column is 29. Consider adding these items with their hash and inverse values:</p><table><thead><tr><th>Item</th><th>Hash</th><th>Inverse</th></tr></thead><tbody><tr><td>apple</td><td>15</td><td>14</td></tr><tr><td>banana</td><td>23</td><td>6</td></tr><tr><td>chikoo</td><td>7</td><td>22</td></tr><tr><td>pomegranate</td><td>18</td><td>11</td></tr><tr><td>watermelon</td><td>26</td><td>3</td></tr></tbody></table></article></div>
  </body>
</html>
