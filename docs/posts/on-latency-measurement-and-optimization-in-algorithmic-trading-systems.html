<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.architect.co/posts/how-fast-is-it-really">Original</a>
    <h1>On latency, measurement, and optimization in algorithmic trading systems</h1>
    
    <div id="readability-page-1" class="page"><div><p><span><em> &#34;The speed of light sucks.&#34; - John Carmack</em></span></p><p><span><em>‍</em></span></p><pre contenteditable="false"><code><span>def</span><span> </span><span>on_market_trade</span><span>(</span><span>self, instrument, market_trade</span><span>):</span><span>
</span>  model_value = self.compute_model_value(instrument, market_trade)
<!-- -->  order = self.compute_order_decision(instrument, model_value)
<span>  </span><span>if</span><span> order </span><span>is</span><span> </span><span>not</span><span> </span><span>None</span><span>:
</span>    self.send_order(order)</code></pre><p>A reasonable place to start in understanding the latency of your critical codepath is to wrap timers around the functions doing the heavy lifting:</p><pre contenteditable="false"><code><span>def</span><span> </span><span>on_market_trade</span><span>(</span><span>self, instrument, market_trade</span><span>):</span><span>
</span>  start_time = datetime.now()
<!-- -->  model_value = self.compute_model_value(instrument, market_trade)
<!-- -->  order = self.compute_order_decision(instrument, model_value)
<!-- -->  end_time = datetime.now()
<!-- -->  self.add_time_sample(end_time - start_time)
<span>  </span><span>if</span><span> order </span><span>is</span><span> </span><span>not</span><span> </span><span>None</span><span>:
</span>    self.send_order(order)</code></pre><p>The function <strong><em>self.add_time_sample</em></strong> would add the elapsed time to a histogram that you could print statistics for at the end of your program’s lifecycle, or on some regular basis based on time or number of samples observed.</p><p>There are many issues with the above approach:</p><ol role="list"><li>It measures the time required to compute the order decision, but does not include the time it takes to send the actual order.</li><li>It observes computation time on every market trade, rather than just the trades that result in orders — this can bias results because the most interesting times to send orders may be the ones where your program is running the slowest due to volume of market events or other factors.</li><li><strong><em>datetime.now()</em></strong> itself is a slow, expensive function that can impact the runtime speed and memory profile of the code above, which adds up if your program is already operating on a microsecond-timescale. The typical way to fix this last issue is to use native performance counters that most programming language have primitives to access.</li></ol><p>Here’s a new code sample that attempts to fix the above:</p><pre contenteditable="false"><code><span>def</span><span> </span><span>on_market_trade</span><span>(</span><span>self, instrument, market_trade</span><span>):</span><span>
</span>  start_time = time.perf_counter_ns()
<!-- -->  model_value = self.compute_model_value(instrument, market_trade)
<!-- -->  order = self.compute_order_decision(instrument, model_value)
<span>  </span><span>if</span><span> order </span><span>is</span><span> </span><span>not</span><span> </span><span>None</span><span>:
</span>    self.send_order(order)
<!-- -->    end_time = time.perf_counter_ns()
<!-- -->    self.add_time_sample(end_time - start_time)</code></pre><p>This is an improvement, but are we really getting at the full latency of the trading system? The above doesn’t include significant elements of the critical path, including the time to parse the market trade update, or anything involving network I/O. Let’s take a step back and trace a market data update through the complete critical path of the <strong>automated trading system (ATS)</strong>:</p><ol role="list"><li>Network packet containing the market trade hits the network card of the box where the ATS is running (sent from the exchange)</li><li>The packet is passed to the runtime of the ATS</li><li>The ATS parses the bytes of the packet to pull out necessary fields (such as trade price or trade size)</li><li>The ATS computes a model value and makes a decision to send an order</li><li>The internal memory representation of the order is converted to the protocol of the exchange that the order is being sent to</li><li>The ATS makes function calls to pass the order bytes to the network card of the box for sending</li><li>The network card of the box sends the order bytes to the exchange</li></ol><p>(There are many details missing from the above, such as the multiple methods of going from steps 1 to 2 and 6 to 7, but we are omitting those for simplicity for now.)</p><p>The code sample above is only measuring steps 4, 5, and 6. I have seen many real-world instances where 90% or more of the full latency profile was present in 1, 2, 6, and 7. A large chunk of latency could be incurred in step 3 if performed uncarefully, or if there is any order-book-building necessary in steps 3 and 4.</p><p>If we solely wanted to <em>measure</em> the latency of the system, we could tag each outbound message with the market data event sequence number, then, for each order, you can grab the NIC hardware timestamp tagged for the inbound market data event, and subtract it from the NIC hardware timestamp for the outbound order.</p><p>To truly capture all seven steps in a reproducible way (so that we can do A/B testing on your code improvements), you can set up this alternative method for measuring latency:</p><ul role="list"><li>Write a program that simulates the exchange marketdata, by sending random market trade events on a timer</li><li>Have that same program simulate the exchange itself by receiving orders in the exchange’s native protocol</li><li>Have the simulator timestamp the market trades with the current time right before sending</li><li>Configure the ATS to receive data from the simulator and send orders to the simulator. Have the ATS attach the exchange trade timestamp on the order it sends to the exchange, or if that’s not possible in the protocol have it record a mapping from order id to exchange trade timestamp</li><li>Have the simulator write down the timestamp when it receives orders from the ATS. From either the data on the order itself or from the ATS’s mapping of order id to exchange trade timestamp, compute the difference between market trade send time and order receive time.</li></ul><p>While the above does completely capture the full critical path, it provides too conservative an estimate of latency: it also captures a similar codepath for the simulator itself! To get closer to the right answer, you can write <em>another</em> simulation Exchange and also a simulation ATS that just ping/pongs a single timestamp back and forth without any protocol translation, model building, order sending, etc. This provides a baseline for inter-program latency that could be subtracted from the above experiment.</p><p>The as-close-as-possible-to-perfect solution involves a much more advanced setup, where modern switching hardware is used to replicate packet traffic in and out of the box and the raw network packets are parsed and correlated for timestamping. But I’ll leave those details for a future post.</p><p>‍</p><p><strong>Writing fast algorithmic trading system code is hard.</strong> Measuring it properly is even harder. At Architect we have created institutional-grade low-latency trading software for both regulated derivatives and digital assets, so that you can let us do the work for you. For more information, contact us at <em>hello </em>at<em> architect.co</em>.</p><p>‍</p></div></div>
  </body>
</html>
