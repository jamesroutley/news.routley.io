<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://marvinh.dev/blog/speeding-up-javascript-ecosystem/">Original</a>
    <h1>Speeding up the JavaScript ecosystem, one library at a time</h1>
    
    <div id="readability-page-1" class="page"><p>ðŸ“– tl;dr: Most popular libraries can be sped up by avoiding unnecessary type conversions or by avoiding creating functions inside functions.</p><div>
						<p>Whilst the trend is seemingly to rewrite every JavaScript build tool in other languages such as Rust or Go, the current JavaScript-based tools could be a lot faster. The build pipeline in a typical frontend project is usually composed of many different tools working together. But the diversification of tools makes it a little harder to spot performance problems for tooling maintainers as they need to know which tools their own ones are frequently used with.</p>
						<p>Although JavaScript is certainly slower than Rust or Go from a pure language point of view, the current JavaScript tools could be improved considerably. Sure JavaScript is slower, but it shouldn&#39;t be <em>that</em> slow in comparison as it is today. JIT engines are crazy fast these days!</p>
						<p>Curiosity lead me down the path of spending some time profiling common JavaScript-based tools to kinda see where all that time was spent. Let&#39;s start with PostCSS, a very popular parser and transpiler for anything CSS.</p>
						<h2>Saving 4.6s in PostCSS</h2>
						<p>There is a very useful plugin called <a href="https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-custom-properties">postcss-custom-properties</a> that adds basic support for CSS Custom Properties in older browsers. Somehow it showed up very prominently in traces with a costly 4.6s being attributed to a single regex that it uses internally. That looked odd.</p>
						<p><img src="https://marvinh.dev/media/js-tools-postcss-custom-properties.png" alt="Picture of a flamegraph showing that the regex alone takes 4.6s"/></p>
						<p>The regex looks suspiciously like something that searches for a particular comment value to change the plugin&#39;s behaviour, similar to the ones from <a href="https://eslint.org/">eslint</a> used to disable specific linting rules. It&#39;s not mentioned in their README, but a peek into the source code confirmed that assumption.</p>
						<p>The place where the regex is created is part of a <a href="https://github.com/csstools/postcss-plugins/blob/main/plugins/postcss-custom-properties/src/lib/is-ignored.ts#L1-L6">function that checks</a> if a CSS rule or declaration is preceeded by said comment.</p>
						<pre><code><span>function</span> <span>isBlockIgnored</span><span>(</span><span>ruleOrDeclaration</span><span>)</span> <span>{</span></code></pre>
						<p>The <code>rule.toString()</code> call caught my eye pretty quickly. Places where one type is cast to another are usually worth another look if you&#39;re tackling performance as not having to do the conversion always saves time. What was interesting in this scenario is that the <code>rule</code> variable always holds an <code>object</code> with a custom <code>toString</code> method. It was never a string to begin with, so we know that we&#39;re always paying a bit of serialization cost here to be able to test the regex against. From experience I knew that matching a regex against many short strings is a lot slower than matching it against few long ones. This is a prime candidate waiting to be optimized!</p>
						<p>The rather troubling aspect of this code is that every input file has to pay this cost, regardless of whether it has a postcss comment or not. Knowing that running one regex over a long string is cheaper than the repeated regex over short strings and the serialization cost, we can guard this function to avoid even having to call <code>isBlockIgnored</code> if we know that the file doesn&#39;t contain any postcss comments.</p>
						<p>With <a href="https://github.com/csstools/postcss-plugins/pull/730#issuecomment-1328120939">the fix</a> applied, the build time went down by a whopping <strong>4.6s</strong>!</p>
						<h2>Optimizing SVG compression speed</h2>
						<p>Next up is <a href="https://github.com/svg/svgo">SVGO</a>, a library for compressing SVG files. It&#39;s pretty awesome and a staple for projects with lots of SVG icons. The CPU profile reveiled that <strong>3.1s</strong> was spent in compressing SVGs though. Can we speed that up?</p>
						<p>Searching a bit through the profiling data there was one function that stood out: <code>strongRound</code>. What&#39;s more is that function was always followed by a little bit of GC cleanup shortly after (see the small red boxes).</p>
						<p><img src="https://marvinh.dev/media/js-tools-strongRound.png" alt="Flamegraph showing lot of overhead caused by a strongRound function"/></p>
						<p>Consider my curiosity piqued! Let&#39;s pull up the <a href="https://github.com/svg/svgo/blob/ae32acf5144be318872a45f49b3ece50c0a4cb18/plugins/convertPathData.js#L962">source on GitHub</a>:</p>
						<pre><code></code></pre>
						<p>Aha, so it&#39;s a function that is used to compress numbers, which there are a lot of in any typical SVG file. The function receives an array of <code>numbers</code> and is expected to mutate its entries. Let&#39;s take a look at the type of variables that are used in its implementation. With a bit of closer inspection we notice that there is a lot of back and forth casting between string and numbers.</p>
						<pre><code><span>function</span> <span>strongRound</span><span>(</span><span><span>data</span><span>:</span> number<span>[</span><span>]</span></span><span>)</span> <span>{</span></code></pre>
						<p>The act of rounding numbers seems like something that can be done with a little bit of math alone, without having to convert numbers to strings. As a general rule of thumb a good chunk of optimizations are about expressing things in numbers, the main reason being that CPUs are crazy good at working with numbers. With a few changes here and there we can ensure that we always stay in number-land and thus avoid the string casting entirely.</p>
						<pre><code></code></pre>
						<p>Running the profiling again confirmed that we were able to speed up build times by about <strong>1.4s</strong>! I&#39;ve filed a <a href="https://github.com/svg/svgo/pull/1716">PR upstream</a> for that too.</p>
						<h3>Regexes on short strings (part 2)</h3>
						<p>In close vicinity to <code>strongRound</code> another function looked suspicious as it takes up nearly a whole second (0.9s) to complete.</p>
						<p><img src="https://marvinh.dev/media/js-tools-stringifyNumber.png" alt="Flamegraph highlight usages of stringifyNumbers in the profile"/></p>
						<p>Similar to <code>stringRound</code> this function compresses numbers too, but with the added trick that we can drop the leading zero if the number has decimals and is smaller than 1 and bigger than -1. So <code>0.5</code> can be compressed to <code>.5</code> and <code>-0.2</code> to <code>-.2</code> respectively. In particular the <a href="https://github.com/svg/svgo/blob/ae32acf5144be318872a45f49b3ece50c0a4cb18/lib/path.js#L246">last line</a> looks of interest.</p>
						<pre><code><span>const</span> <span>stringifyNumber</span> <span>=</span> <span>(</span><span><span>number</span><span>:</span> number<span>,</span> <span>precision</span><span>:</span> number</span><span>)</span> <span>=&gt;</span> <span>{</span></code></pre>
						<p>Here we are converting a number to a string and calling a regex on it. It&#39;s extremely likely that the string version of the number will be a short string. And we know that a number can not be both <code>n &gt; 0 &amp;&amp; n &lt; 1</code> and <code>n &gt; -1 &amp;&amp; &lt; 0</code> at the same time. Not even <code>NaN</code> has that power! From that we can deduce that either only one of the regexes matches or none of them, but never both. At least one of the <code>.replace</code> calls is always wasted.</p>
						<p>We can optimize that by differentiating between those cases by hand. Only if we know that we&#39;re dealing with a number that has a leading <code>0</code> should we apply our replacement logic. Those number checks are quicker than doing a regex search.</p>
						<pre><code><span>const</span> <span>stringifyNumber</span> <span>=</span> <span>(</span><span><span>number</span><span>:</span> number<span>,</span> <span>precision</span><span>:</span> number</span><span>)</span> <span>=&gt;</span> <span>{</span></code></pre>
						<p>We can go one step further and get rid of the regex searches entirely as we know with 100% certainty where the leading <code>0</code> is in the string and thus can manipulate the string directly.</p>
						<pre><code><span>const</span> <span>stringifyNumber</span> <span>=</span> <span>(</span><span><span>number</span><span>:</span> number<span>,</span> <span>precision</span><span>:</span> number</span><span>)</span> <span>=&gt;</span> <span>{</span></code></pre>
						<p>Since there is a separate function to trim the leading <code>0</code> in svgo&#39;s codebase already, we can leverage that instead. Another 0.9s saved! <a href="https://github.com/svg/svgo/pull/1717">Upstream PR</a>.</p>
						<h3>Inline functions, inline caches and recursion</h3>
						<p>One function called <code>monkeys</code> intrigued me due to its name alone. In traces I could see that it was called multiple times inside itself, which is a strong indicator that some sort of recursion is happening here. It&#39;s often used to traverse a tree-like structure. Whenever some sort of traversal is used, there is a likelihood that it&#39;s somewhat in the &#34;hot&#34; path of the code. That&#39;s not true for every scenario but in my experience it has been a good rule of thumb.</p>
						<pre><code><span>function</span> <span>perItem</span><span>(</span><span>data<span>,</span> info<span>,</span> plugin<span>,</span> params<span>,</span> reverse</span><span>)</span> <span>{</span></code></pre>
						<p>Here we have a function that creates another function inside its body which recalls the inner function again. If I had to guess, I&#39;d assume that this was done here to save some keystrokes by not having to pass around all arguments again. Thing is that functions that are created inside other functions are pretty difficult to optimize when the outer function is called frequently.</p>
						<pre><code><span>function</span> <span>perItem</span><span>(</span><span>items<span>,</span> info<span>,</span> plugin<span>,</span> params<span>,</span> reverse</span><span>)</span> <span>{</span></code></pre>
						<p>We can get rid of the inner function by always passing all arguments explicitly vs capturing them by closure like before. The impact of this change is rather minor, but in total it saved another <strong>0.8s</strong>.</p>
						<p>Luckily this is already addressed in the new major <code>3.0.0</code> release, but it will take a bit until the ecosystem switches to the new version.</p>
						<h2>Beware of for...of transpilation</h2>
						<p>A nearly identical problem occurs in <code>@vanilla-extract/css</code>. The published package ships with the following piece of code:</p>
						<pre><code><span>class</span> <span>ConditionalRuleset</span> <span>{</span></code></pre>
						<p>What&#39;s interesting about this function is that it&#39;s not present in the original source code. In the original source it&#39;s a standard <code>for...of</code> loop.</p>
						<pre><code><span>class</span> <span>ConditionalRuleset</span> <span>{</span></code></pre>
						<p>I couldn&#39;t replicate this issue in babel or typescript&#39;s repl, but I can confirm that it&#39;s introduced by their build pipeline. Given that it seems to be a shared abstraction over their build tool I&#39;d assume that a few more projects are affected by this. So for now I just patched the package locally inside <code>node_modules</code> and was happy to see that this improved the build times by another <code>0.9s</code>.</p>
						<h2>The curious case of semver</h2>
						<p>With this one I&#39;m not sure if I&#39;ve configured something wrong. Essentially, the profile showed that the whole babel configuration was always read anew whenever it transpiled a file.</p>
						<p><img src="https://marvinh.dev/media/js-tools-babel-semver.png" alt="Flamegraph showing a long time being spent in parsing browser targets"/></p>
						<p>It&#39;s a bit hard to see in the screenshot, but one of the functions taking up much time was code from the <code>semver</code> package, the same package that&#39;s used in npm&#39;s cli. Huh? What has semver to do with babel? It took a while until it dawned on me: It&#39;s for parsing the browserlist target for <code>@babel/preset-env</code>. Although the browserlist settings might look pretty short, ultimately they were expanded to about 290 individual targets.</p>
						<p>That alone isn&#39;t enough for concern, but it&#39;s easy to miss the allocation cost when using validation functions. It&#39;s a bit spread out in babel&#39;s code base, but essentially the versions of the browser targets are converted to semver strings <code>&#34;10&#34; -&gt; &#34;10.0.0&#34;</code> and then validated. Some of those version numbers already match the semver format. These versions and sometimes version ranges are compared against each other until we find the lowest common feature set we need to transpile for. There is nothing wrong with this approach.</p>
						<p>Performance problems arise here, because the semver versions are stored as a <code>string</code> instead of the parsed semver data type. This means that every call to <code>semver.valid(&#39;1.2.3&#39;)</code> will create a new semver instance and immediately destroy it. Same is true when comparing semver versions when using strings: <code>semver.lt(&#39;1.2.3&#39;, &#39;9.8.7&#39;)</code>. And <em>that</em> is why we&#39;re seeing semver so prominently in the traces.</p>
						<p>By patching that locally in <code>node_modules</code> again, I was able to reduce the build time by another <code>4.7s</code>.</p>
						<h2>Conclusion</h2>
						<p>At this point I stopped looking, but I&#39;d assume that you&#39;ll find more of these minor performance issues in popular libraries. Today we mainly looked at some build tools, but UI components or other libraries usually have the same low hanging performance issues.</p>
						<p>Will this be enough to match Go&#39;s or Rust&#39;s performance? Unlikely, but the thing is that the current JavaScript tools could be faster than they are today. And the things we looked at in this post are more or less just the tip of the iceberg.</p>
					</div></div>
  </body>
</html>
