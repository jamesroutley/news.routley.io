<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.computationalcomplexity.org/2025/02/you-need-much-less-memory-than-time.html">Original</a>
    <h1>You need much less memory than time</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-3222385872113044921" itemprop="description articleBody">
<p>Just as I was <a href="https://blog.computationalcomplexity.org/2025/02/research-then-and-now.html">complaining</a> that we haven&#39;t seen many surprising breakthroughs in complexity recently, we get an earthquake of a result to start the year, showing that all algorithms can be simulated using considerable less memory than the time of the original algorithm. You can reuse space (memory) but you can&#39;t reuse time, and this new result from Ryan Williams in an upcoming <a href="https://eccc.weizmann.ac.il/report/2025/017/">STOC paper</a> provides the first stark difference.</p><p>DTIME(\(t(n)\)) \(\subseteq\) DSPACE(\(\sqrt{t(n)\log t(n)}\))</p><p>This is a vast improvement on the previous best known simulation, the classic 1977 <a href="https://doi.org/10.1145/322003.322015">Hopcroft-Paul-Valiant paper</a> showing</p><p>DTIME(\(t(n)\)) \(\subseteq\) DSPACE(\(t(n)/\log t(n)\))</p><p>only slightly lower than the trivial \(t(n)\) bound. Williams gets a huge near quadratic improvement that will go down as a true classic complexity theorem. Note that the space simulation does not maintain the time bound.</p><p>Williams&#39; proof relies on a <a href="https://doi.org/10.1145/3618260.3649664">space-efficient tree evaluation algorithm</a> by James Cook and Ian Mertz from last year&#39;s STOC conference. Cook and Mertz&#39;s algorithm builds on earlier work on catalytic computing, highlighted in a <a href="https://www.quantamagazine.org/catalytic-computing-taps-the-full-power-of-a-full-hard-drive-20250218/">recent Quanta article</a>. </p><p>Let me give an highly overly simplified view of the combined proof.</p><p>A \(t(n)\) time Turing machine uses at most that much space on its tapes. Split the tapes into \(\sqrt{t(n)}\) segments of size \(\sqrt{t(n)}\). Using the fact that it takes \(\sqrt{t(n)}\) time to cross an entire segment, Williams with some clever tricks models acceptance of the Turing machines as a circuit of bounded degree and depth<b> </b>\(\sqrt{t(n)}\), where the wires carry the contents of the size \(\sqrt{t(n)}\) segments at various times in the computation. </p><p>Williams then applies the tree evaluation algorithm of Cook and Mertz. Cook and Mertz use finite fields to encode these segments as a combination of registers of size \(\log t(n)\) and show how to compute the value of each node of the tree using only \(\sqrt{t(n)}\) space for the local computation plus needing to only remember a constant number of registers while reusing the rest of the space when recursively computing the tree. It&#39;s pretty magical how they manage to make it all work. </p><p>It&#39;s worth going through the proof yourself. I recommend Sections 3.1 and Footnote 6 in Williams&#39; paper (a slightly weaker space bound but much simpler) and Sections 2-4 of the Cook-Mertz paper. Oded Goldreich has an <a href="https://www.wisdom.weizmann.ac.il/~oded/VO/tree-eval.pdf">alternative exposition</a> of the Cook-Mertz algorithm and proof.</p><p>Williams&#39; theorem works for multitape Turing machines and oblivious random-access machines, where the queries to the memory are fixed in advance. He shows how to use this result to compute the output a circuit of size \(s\) using nearly \(\sqrt{s}\) space. Fully general random access machines remains open, as does nondeterministic and other models of computation (random, quantum, etc).</p><p>In 1986 my advisor Mike Sipser gave the <a href="https://doi.org/10.1016/0022-0000(88)90035-9">first hardness vs randomness result</a>, showing roughly that if there were problems that took time \(2^n\) but could not be solved in space \(2^{.99n}\) on multi-tape Turing machines then RP = P. Williams&#39; theorem kills this assumption though we&#39;ve developed <a href="https://blog.computationalcomplexity.org/2006/03/uniform-derandomization-assumptions.html">weaker assumptions</a> since. </p><p>Moving forward, can we push Williams&#39; result to get a simulation in space \(n^\epsilon\) for \(\epsilon&lt;1/2\). A simulation for all \(\epsilon&gt;0\) would separate P from PSPACE. Even a slight improvement would have applications for alternating time. Maybe try to use the Cook-Mertz techniques directly in the Turing machine simulation instead of going through computation trees.</p><p>Read sections 4 and 5 of Williams&#39; paper for some further consequences and challenges for further improvements. </p>

</div></div>
  </body>
</html>
