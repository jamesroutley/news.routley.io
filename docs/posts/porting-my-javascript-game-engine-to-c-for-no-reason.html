<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://phoboslab.org/log/2024/08/high_impact">Original</a>
    <h1>Porting my JavaScript game engine to C for no reason</h1>
    
    <div id="readability-page-1" class="page"><div>	
	<div>
		
		<p>— Sunday, August 4th 2024</p>
	</div>
	

	<h2>high_impact</h2>
<p>tl;dr: <a href="https://github.com/phoboslab/high_impact">high_impact</a> is small game engine for 2D action games. It&#39;s written in C, compiles to Windows, Mac and Linux as well as to WASM for the Web. It&#39;s “inspired by” my original <a href="https://impactjs.com">Impact</a> JavaScript game engine from 2010. The name high_impact is a nod to a time when C was considered a high level language.</p>
<p>MIT licensed, source on github: <a href="https://github.com/phoboslab/high_impact">github.com/phoboslab/high_impact</a></p>


<h2>Ancient History</h2>
<p>In April 2010 Steve Jobs published an open letter titled <a href="https://en.wikipedia.org/wiki/Thoughts_on_Flash">“Thoughts on Flash”</a>, in which he outlined the decision to not ever support Flash on iOS.</p>
<p>Flash was a browser plugin that — until then — was so vital for the web that it was bundled with browsers and included in Windows updates. Websites like Newgrounds and Kongregate, devoted entirely to Flash Games and Animations, marked the epicenter of Internet Culture. The importance of Flash cannot be overstated: A web without Flash was a boring web.</p>
<p>While Android supported Flash, it was a total shit show and everybody knew it. Adobe, ever reluctant to do the right thing, made no effort to improve on its shortcomings on mobile. With Apple refusing to let this rotting, closed source code base run on iOS, it marked the beginning of the end.</p>
<p>No Flash meant no games in the browser. Or so was the thought.</p>
<p>At the time I was looking for a project for my bachelor thesis and stumbled upon the little used JavaScript Canvas2D API. Canvas2D allowed you to draw images and shapes into a <code>&lt;canvas&gt;</code> element on your website. It was invented and implemented by Apple/Safari (with no standards procedure) for the purpose of rendering desktop widgets: Weather forecasts, calendars, stock tickers and other mildly useful fluff.</p>
<p>Google and Mozilla soon followed with support for Canvas2D while Microsoft forgot that the Web existed – but that was ok, nobody cared about Internet Explorer anymore. Canvas2D was supported by all <em>serious</em> browsers.</p>
<p>So I set out to proof that you don&#39;t need Flash to make games for the Web. The result was <a href="https://playbiolab.com">Biolab Disaster</a>.</p>
<p><img src="https://phoboslab.org/content/assets/biolab-title.png" alt="Biolab Disaster Title Screen"/>
<em>The Biolab Disaster Title Screen, with the the key art borrowed from the amazingly talented <a href="http://androidarts.com/">Arne Niklas Jansson</a>.</em></p>
<p>I felt I had succeeded when famous Apple aficionado John Gruber published a <a href="https://daringfireball.net/linked/2010/09/13/biolab-disaster">two-sentence piece</a> about the game with the purpose (as I perceived it) to redeem Steve Job&#39;s decision.</p>
<p>To make Biolab Disaster I had to create a game engine and level editor all while <a href="https://phoboslab.org/log/2011/03/the-state-of-html5-audio">jumping</a> <a href="https://phoboslab.org/log/2011/03/multiple-channels-for-html5-audio">through</a> <a href="https://phoboslab.org/log/2012/09/drawing-pixels-is-hard">countless</a> <a href="https://phoboslab.org/log/2012/06/measuring-input-lag-in-browsers">hoops</a> that the early Canvas and Audio APIs demanded. Only with all the attention that the 2010 Web had to offer, I realized what I had.</p>
<p>I decided to polish my code, write extensive documentation for it and then released Impact. Not for free, but for a rather steep $99. My decision to sell it was met with a lot of backlash but <a href="https://phoboslab.org/log/2011/01/impact-sales-report">was successful enough</a> to launch me into a self-sustained career. I ended up selling more than 3000 licenses.</p>
<p>Many Web games were created with Impact and it even served as the basis for some commercial cross-platform titles like <a href="https://store.steampowered.com/app/368340/CrossCode/">Cross Code</a>, <a href="https://store.steampowered.com/app/293440/Elliot_Quest/">Eliot Quest</a> and my own Nintendo Wii-U game <a href="https://xtype-plus.com/">XType Plus</a>.</p>
<p>At the end of its life, I released Impact <a href="https://phoboslab.org/log/2018/05/impact-is-now-free-open-source">for free</a>.</p>
<p>A few weeks ago I started to build Impact <em>again</em> from the ground up, but this time in C, instead of JavaScript.</p>
<h2>Why C?</h2>
<p>C is a fun little language. It&#39;s miles apart from all the things I write for money. It&#39;s very simple, yet extremely deep. It paralells everything I love in games: easy to learn, hard to master.</p>
<p>I slowly re-discovered my love for C – first when I ported my <a href="https://phoboslab.org/log/2017/02/decode-it-like-its-1999">JavaScript MPEG1 decoder</a> to the <a href="https://phoboslab.org/log/2019/06/pl-mpeg-single-file-library">single header pl_mpeg library</a>, then implementing VR in <a href="https://phoboslab.org/log/2016/05/quake-for-oculus-rift">Quake for Oculus Rift</a>, created the <a href="https://phoboslab.org/log/2021/11/qoi-fast-lossless-image-compression">QOI image format</a> &amp; <a href="https://phoboslab.org/log/2023/02/qoa-time-domain-audio-compression">QOA audio format</a> and lastly <a href="https://phoboslab.org/log/2023/08/rewriting-wipeout">re-wrote wipEout</a>.</p>
<p>Impact was quite simple; by no means comparable to Godot, Unreal or Unity. Still it proved to be a solid basis for a lot of different games. </p>
<p>Rewriting Impact in C should be a fun exercise.</p>
<h2>Concept</h2>
<p>As with most things I write for fun, I try to condense it down to its simplest form. Everything in high_impact is implemented as straight forward as possible, with the absolute minimum amount of code I could come up with. Achieving this with C is not always easy, but for me that&#39;s the most enjoyable part of this whole project.</p>
<p>The basic idea for high_impact is the same as for the original JavaScript game engine: you get the facilities for loading tile-maps and creating, updating and drawing game objects (“entities”). The game engine handles the physics and collision detection between entities and with the collision map. high_impact also provides the functionality for simple sprite-sheet animations, drawing text and playing sound effects and music.</p>
<p>high_impact is not a “library”, but rather a framework. It&#39;s an empty scaffold, that you can fill. You write your business logic <em>inside</em> the framework.</p>
<p>At the very bottom of this framework sits the <code>platform</code> backend. high_impact currently compiles with either of two platforms: <a href="http://www.libsdl.org/">SDL</a> or <a href="https://github.com/floooh/sokol">Sokol</a>.</p>
<p>Your game code sits in one or more “scenes” (think: “title_screen”, “menu”, “game”, ...), where a scene is just a struct with some function pointers. You initially call <code>engine_set_scene(&amp;scene_game)</code> and the engine will set up the new scene, call <code>scene_game.init()</code> once and then <code>scene_game.update()</code> &amp; <code>scene_game.draw()</code> for every frame.</p>
<p>Tile-maps and the initial entities can be loaded from a .json file (utilizing my <a href="https://github.com/phoboslab/pl_json">pl_json</a> library) or created on the fly. The reason I chose JSON for the level format was simply backwards compatibility with the original Impact.</p>
<p>To do some dogfooding, high_impact loads images in <a href="https://qoiformat.org">QOI</a> and sounds/music in <a href="https://qoaformat.org">QOA</a> format. The Makefile for the demo games is set up to automatically convert all assets to these formats (i.e. PNG to QOI and WAV to QOA). This means there&#39;s no need to include any other image/sound decoding libraries.</p>
<p>Future versions of high_impact may support different asset formats, but I quite like how the simplicity of these formats continue the whole theme of this project.</p>
<h2>Entities</h2>
<p>All entities (the dynamic objects in the game world) share the same <code>entity_t struct</code> that contains all properties that high_impact needs: position, velocity, size, etc. Each entity being the same byte size makes storage and management trivial.</p>
<p>To move your entities you set the velocity or acceleration and high_impact handles all the rest.</p>
<p>Through a macro, high_impact allows you to extend the basic entity struct with some custom per-entity properties. How you extend this struct is up to you. Biolab Disaster uses a <code>union</code>, with one struct per entity type, but there are good arguments to just have a “fat struct” instead. For what it&#39;s worth, Drop doesn&#39;t need to define any additional properties.</p>
<pre><code><span>ENTITY_DEFINE</span><span>(</span>
    <span>union</span> <span>{</span>
        <span>struct</span> <span>{</span>
            <span>float</span> high_jump_time<span>;</span>
            <span>float</span> idle_time<span>;</span>
            <span>bool</span> flip<span>;</span>
            <span>bool</span> can_jump<span>;</span>
            <span>bool</span> is_idle<span>;</span>
        <span>}</span> player<span>;</span>

        <span>struct</span> <span>{</span>
            entity_list_t targets<span>;</span>
            <span>float</span> delay<span>;</span>
            <span>float</span> delay_time<span>;</span>
            <span>bool</span> can_fire<span>;</span>
        <span>}</span> trigger<span>;</span>

            <span>}</span>
<span>);</span></code></pre>
<p>In your game, you can access a struct in this union like so:</p>
<pre><code><span>static</span> <span>void</span> update<span>(</span>entity_t <span>*</span><span>self</span><span>)</span> <span>{</span>
    <span>self</span><span>-&gt;</span>player<span>.</span>idle_time <span>+=</span> engine<span>.</span>tick<span>;</span>
<span>}</span></code></pre>
<p>Each of your entity types also needs to supply a <code>entity_vtab_t</code> that provides the function pointers used by this entity:</p>
<pre><code><span>static</span> <span>void</span> update<span>(</span>entity_t <span>*</span><span>self</span><span>)</span> <span>{</span>
        
        entity_base_update<span>(</span><span>self</span><span>);</span>
<span>}</span>

<span>static</span> <span>void</span> touch<span>(</span>entity_t <span>*</span><span>self</span><span>,</span> entity_t <span>*</span>other<span>)</span> <span>{</span>
    entity_damage<span>(</span>other<span>,</span> <span>self</span><span>,</span> <span>10</span><span>);</span>
<span>}</span>

entity_vtab_t entity_vtab_blob <span>=</span> <span>{</span>
    <span>.</span>update <span>=</span> update<span>,</span>
    <span>.</span>touch <span>=</span> touch<span>,</span>
    <span>};</span></code></pre>
<p>All entries in this <code>entity_vtab_t</code> are optional. See <a href="https://github.com/phoboslab/high_impact/blob/master/src/entity.h#L58">entity.h</a> for a list of all available functions.</p>
<p>Like for most other things in high_impact, there&#39;s a fixed size storage for all entities. By default you can have 1024 active entities, but this can be configured by defining <code>ENTITIES_MAX</code>. The engine easily handles up to 64k entities.</p>


<p>Whenever you want to hold a reference to an entity for more than one frame, you can get a <code>entity_ref_t</code>, which is just a <code>struct { uint16_t id, index; };</code> – a unique id for that entity and the index into the entity storage array. This can be resolved (very cheaply) to a pointer again using <code>entity_by_ref()</code>. This ensures that the entity at the particular index still has the id that we expect and is not a different entity that happens to occupy the same storage address after the original died. Using an <code>uint16_t</code> for the index here is also the reason for the hard 64k maximum active entities. If you need more, change the source!</p>
<p>The entity system is the one part where working with C gets a bit awkward. What I wanted is simple OOP with classes and single inheritance, but that takes some fiddling with C. Still, high_impact tries to make this as ergonomic as possible.</p>
<p>A lot of people (<a href="https://www.youtube.com/watch?v=dS6rCaDSwW8">not</a> <a href="https://www.youtube.com/watch?v=w7W3xM2tzRA">Jonathan</a> <a href="https://www.youtube.com/watch?v=4t1K66dMhWk">Blow</a>) believe that OOP (I use the term loosely here) is the wrong approach for entities and you should rather do some kind of composition (e.g. going full “Entity Component System” with <a href="https://www.flecs.dev">FLECS</a> or others). However, with all the games that I wrote, I found this “naive” OOP approach to <em>just work</em>. All logic for a particular entity type sits in a single place it&#39;s extremely easy to reason about.</p>
<h2>Collision Detection/Response</h2>
<p>The easy way to handle game world collisions is to check if an entity can move to a new position and if not: just stop it. This is usually good enough (it worked well for <a href="https://phoboslab.org/log/2024/08/log/2021/09/q1k3-making-of">Q1k3</a> and <a href="https://phoboslab.org/log/2018/09/underrun-making-of">Underrun</a>), but can produce some weird behavior for fast moving objects: imagine in a 2D platformer the player is falling towards the ground. 16px above the ground, the next movement step will put the player inside the ground – so the player is stopped mid air. In the next frame, gravity is applied again and the player moves further to the ground. This looks like a &#34;soft landing&#34;.</p>
<p>high_impact instead traces the entity&#39;s box against the tile-map and calculates the exact point of impact. This is a bit more involved than a simple yes/no check but produces far better results. high_impact can also handle sloped tiles, which complicates this tracing a fair bit. See <a href="https://github.com/phoboslab/high_impact/blob/master/src/trace.c">trace.c</a> for the details.</p>
<p>When an entity hits a tile, we may also have to do a second trace with the remaining velocity. E.g. if you hit the ground at an angle the entity&#39;s <code>vel.y</code> is set to <code>0</code>, but we don&#39;t want to stop the entity at the exact hit point. So we do the second trace with the remaining <code>vel.x</code> to slide along the ground.</p>
<p>Collisions between entities is handled separately. Each entity defines how it wants to collide with other entities. E.g. particles may want to collide with the tile map, but not collide with other entities at all. Moving platforms collide with other entities, but should not move in a collision response.</p>


<p>The broad phase collision detection sorts all entities by their <code>pos.x</code>, which is cheap with an insertion sort, as the entities are already mostly sorted from the last frame. With the sorted entities, we only have to go from left to right, checking each entity against all entities that lie between <code>pos.x</code> and <code>pos.x + size.x</code>.</p>
<p>This &#34;sweep and prune&#34; is fast as long as we don&#39;t have too many entities overlapping at similar x positions. I.e. a big tower of stacked boxes is this worst case for this approach. Some games (e.g. vertical shooters) may also want to change the sweep axis. This can be done with <code>#define ENTITY_SWEEP_AXIS y</code>.</p>
<h2>Rendering</h2>
<p>high_impact currently comes with two renderers: OpenGL and an (incomplete) software renderer. Since all rendering goes through a very slim API and the actual draw calls are using a single function, implementing different backends is quite straight forward. The functions an additional rendering backend needs to support are:</p>
<pre><code><span>void</span> render_backend_init<span>(</span><span>void</span><span>);</span>
<span>void</span> render_backend_cleanup<span>(</span><span>void</span><span>);</span>

<span>void</span> render_set_screen<span>(</span>vec2i_t size<span>);</span>

<span>void</span> render_frame_prepare<span>(</span><span>void</span><span>);</span>
<span>void</span> render_frame_end<span>(</span><span>void</span><span>);</span>

<span>void</span> render_draw_quad<span>(</span>quadverts_t <span>*</span>quad<span>,</span> texture_t texture_handle<span>);</span></code></pre>
<p>Plus three more to handle textures:</p>
<pre><code>texture_mark_t textures_mark<span>(</span><span>void</span><span>);</span>
<span>void</span> textures_reset<span>(</span>texture_mark_t mark<span>);</span>

texture_t texture_create<span>(</span>vec2i_t size<span>,</span> rgba_t <span>*</span>pixels<span>);</span></code></pre>
<p>Of course this is fairly simplistic: you can only draw quads and can&#39;t use any shader effects, but for the purpose of this game engine it&#39;s enough.</p>
<p>The software renderer is just 140 lines of code (see <a href="https://github.com/phoboslab/high_impact/blob/master/src/render_software.h">render_software.c</a>) though I cheated a bit by only supporting axis aligned quads.</p>
<p>The OpenGL renderer (see <a href="https://github.com/phoboslab/high_impact/blob/master/src/render_gl.h">render_gl.c</a>) is a bit more involved, as it tries to fit the rendering for a whole frame into a single OpenGL draw call. This is achieved in two ways: </p>
<ol>
<li>all quads to be drawn are collected into a big buffer and handed over to OpenGL with <code>glDrawElements()</code> at once</li>
<li>all textures are combined into a single texture atlas. We never have to rebind any textures.</li>
</ol>
<p>Texture atlases are quite oldschool and have their own drawbacks. Strictly speaking, they are not needed anymore with bindless textures, but these are not supported everywhere. </p>
<p>While high_impact only supports a single texture atlas, the atlas size is configurable through a <code>#define</code>. Mobile GPUs typically support 8k×8k textures while modern Desktop GPUs seem to max out at 32k×32k. Good enough for the purpose of this engine. For what it&#39;s worth, Biolab Disaster and Drop use a 512×512 atlas.</p>
<h2>Sound</h2>
<p>Sound output is handled by SDL2 or Sokol, so we only need to handle loading, decoding and mixing of multiple sounds. The sound system is split into a <code>sound_source_t</code> holding the underlying samples, and a <code>sound_t</code> that represents a currently playing sound using one of the sources.</p>
<p>The system is an adaptation of the one I wrote for <a href="https://phoboslab.org/log/2023/08/rewriting-wipeout">wipEout</a> and can decompress QOA on demand.</p>
<p>Again, everything is statically allocated. There&#39;s a fixed number of sources you can load and a fixed number of sounds you can play at a time. Sounds are automatically disposed when they finished playing, so that they can be reused. The whole system is set up in way that you don&#39;t have to think about it much.</p>
<p>As an example from Drop, here&#39;s how the bounce sound of the player entity is loaded/played:</p>
<pre><code><span>static</span> sound_source_t <span>*</span>sound_bounce<span>;</span>

<span>static</span> <span>void</span> load<span>(</span><span>void</span><span>)</span> <span>{</span>
    sound_bounce <span>=</span> sound_source<span>(</span><span>&#34;assets/bounce.qoa&#34;</span><span>);</span>
<span>}</span>

<span>static</span> <span>void</span> collide<span>(</span>entity_t <span>*</span><span>self</span><span>,</span> vec2_t normal<span>,</span> trace_t <span>*</span>trace<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>normal<span>.</span>y <span>==</span> <span>-</span><span>1</span> <span>&amp;&amp;</span> <span>self</span><span>-&gt;</span>vel<span>.</span>y <span>&gt;</span> <span>32</span><span>)</span> <span>{</span>
        sound_play<span>(</span>sound_bounce<span>);</span>
    <span>}</span>
<span>}</span></code></pre>
<p>Sounds can change volume, be panned (shifted left or right) and change pitch (the playback speed). Setting pitch to a negative value plays it backwards. The “resampling” needed for the variable pitch is pretty low quality: just a nearest neighbor interpolation.</p>
<p>See <a href="https://github.com/phoboslab/high_impact/blob/master/src/sound.h">sound.h</a> for the documentation and <a href="https://github.com/phoboslab/high_impact/blob/master/src/sound.c">sound.c</a> for the implementation details.</p>
<h2>Memory Management</h2>
<p>This is the fun part. Memory management in C is often regarded as some sort of black magic and many tutorials and libraries over-complicate things a lot. For games in particular, we can make it much simpler. In fact, in high_impact you don&#39;t have to think about memory much at all.</p>
<p>For games that don&#39;t have any user created assets, you know exactly how much memory you need. Either the largest scene fits or it doesn&#39;t. So high_impact statically allocates a single array of bytes, called the “hunk”. This is the only memory high_impact uses. The size of the hunk is configurable through <code>#define ALLOC_SIZE</code>. From that hunk, you can allocate memory using two ways:</p>
<ol>
<li>At the beginning of the hunk, growing upwards, is a bump allocator (also known as an “arena”) that holds all assets and other data needed for the game, entities and the current scene.</li>
<li>At the end of the hunk, growing downwards, is a temp allocator that behaves like <code>malloc()</code> and <code>free()</code>. This is meant as temporary storage when loading assets e.g. to decompress an image before handing the pixels over to the GPU.</li>
</ol>
<p>The bump allocator has multiple “high water marks” and resets automatically to these at certain times. This means you never have to explicitly <code>free()</code> some bump allocated memory. It behaves a bit like autorelease pools in the Apple ecosystem. Conceptually it looks like this:</p>
<pre><code>game {
    scene {
        frame {}
    }
}</code></pre>
<ol>
<li>Everything you allocate <em>before</em> setting the first scene will only be freed when the program ends</li>
<li>Everything you allocate during <code>scene.load()</code> will be freed when the scene ends</li>
<li>Everything you allocate while a scene is running will be freed at the end of the frame</li>
</ol>
<p>One simplification here is that we call <code>load()</code> for each entity type at stage 1, since we don&#39;t know ahead of time which entities might be used in a scene. Level data and everything else that is only needed for the current scene is at stage 2, and things you only need for the logic of a current frame at stage 3.</p>
<p>You can also specifically wrap your code in an additional allocation context:</p>
<pre><code>alloc_pool<span>()</span> <span>{</span>
    <span>void</span> <span>*</span>result <span>=</span> memory_intensive_computation<span>();</span>
    do_something<span>(</span>result<span>);</span>
<span>}</span></code></pre>
<p>Which is just a shorthand for:</p>
<pre><code>bump_mark_t mark <span>=</span> bump_mark<span>();</span>
<span>void</span> <span>*</span>result <span>=</span> memory_intensive_computation<span>();</span>
do_something<span>(</span>result<span>);</span>
bump_reset<span>(</span>mark<span>);</span></code></pre>
<p>There&#39;s some more documentation of the system in <a href="https://github.com/phoboslab/high_impact/blob/master/src/alloc.h">alloc.h</a>.</p>
<h2>The Level Editor</h2>
<p>The original Impact came with a level editor called “Weltmeister”. I decided to make this part of high_impact as well. It&#39;s still written in JavaScript and uses much of the original source, but was updated for some modern browser features.</p>


<p>Weltmeister is completely self-contained. You can just double-click the <code>weltmeister.html</code> and start building levels. In the old days Weltmeister needed a backend API (written in PHP or NodeJS) to load and save files. Now with the <a href="https://developer.mozilla.org/en-US/docs/Web/API/File_System_API">FileSystemAPI</a> we can just ask for access to a certain folder. Sadly, this is not yet fully supported by Safari or Firefox (particularly the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/showDirectoryPicker">showDirectoryPicker()</a> function), so you need a Chrome-ish browser.</p>
<p>I hope Mozilla will get their shit together at some point (or <a href="https://ladybird.org/">Ladybird</a> can fill the gap). This is such a cool way to deliver cross platform apps that can read/write the filesystem.</p>
<p>Weltmeister reads your C source files and collects all entity types from it. high_impact comes with some macros that do <em>nothing</em>, but are understood by Weltmeister to change the appearance and behavior of the entities in the editor.</p>
<pre><code></code></pre>
<p>E.g. the <a href="https://github.com/phoboslab/high_biolab/blob/master/src/entities/trigger.c">trigger entity</a> in Biolab Disaster is configured with this</p>
<pre><code><span>EDITOR_SIZE</span><span>(</span><span>8</span><span>,</span> <span>8</span><span>);</span>
<span>EDITOR_RESIZE</span><span>(</span><span>true</span><span>);</span>
<span>EDITOR_COLOR</span><span>(</span><span>255</span><span>,</span> <span>229</span><span>,</span> <span>14</span><span>);</span></code></pre>
<h2>Demo Games</h2>
<p>To make sure high_impact actually works as a game engine I ported two of my original Impact games to C.</p>
<p>This was honestly quite a mundane task. It&#39;s just a “transliteration” of the original JS source and re-uses all existing assets. I&#39;ll view the lack of challenges here as a testament to high_impact working as intended.</p>
<h3>Biolab Disaster</h3>
<p>The original launch title for Impact. A side scrolling Jump&#39;n&#39;Gun.</p>
<ul>
<li>Source: <a href="https://github.com/phoboslab/high_biolab">github.com/phoboslab/high_biolab</a></li>
<li>high_impact WASM version: <a href="https://phoboslab.org/high_impact/biolab">/high_impact/biolab</a></li>
<li>Original JS version: <a href="https://playbiolab.com">playbiolab.com</a></li>
</ul>
<h3>Drop</h3>
<p>A super simple arcade game.</p>
<ul>
<li>Source: <a href="https://github.com/phoboslab/high_drop">github.com/phoboslab/high_drop</a></li>
<li>high_impact WASM version: <a href="https://phoboslab.org/high_impact/drop">/high_impact/drop</a></li>
<li>Original JS version: <a href="https://impactjs.com/drop/">impactjs.com/drop/</a></li>
<li>My current high score: <a href="https://x.com/phoboslab/status/1815441819540373600">26789 Points</a></li>
</ul>
<h2>Extensibility</h2>
<p>high_impact works as a traditional game engine, where all game specific code is <em>additive</em>. I.e. you don&#39;t need to change the source code of the engine itself, but I hope it is simple enough that you <em>can</em> change the engine source as needed. This is not an ivory tower. Go wild!</p>
<p>The platform and renderer of high_impact are meant to be extensible without necessitating changes to the rest of the code. If anyone cares about high_impact at all, I&#39;d hope to see support for lots of different systems and I welcome pull requests for Vulkan, DirectX &amp; Metal and maybe even platform backends for PSX, N64, Dreamcast and whatever else you can think of.</p>
<p>It&#39;s C. It should run everywhere.</p></div></div>
  </body>
</html>
