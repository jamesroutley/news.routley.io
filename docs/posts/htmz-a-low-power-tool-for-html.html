<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://leanrada.com/htmz/">Original</a>
    <h1>Show HN: htmz ‚Äì a low power tool for HTML</h1>
    
    <div id="readability-page-1" class="page">
    
    <i> a low power tool for html </i>

    <section>
      <p>
        <b>htmz</b> is a minimalist HTML microframework that gives you the power
        to create modular web user interfaces with the familiar simplicity of
        <strong>plain HTML</strong>.
        <a href="https://github.com/Kalabasa/htmz" target="_blank">[GitHub]</a>
      </p>
    </section>

    <section>
      <div>
        <h2>plain<span>üç¶</span></h2>
        <p>
          Use straight up HTML. No supersets. No hz- ng- hx- v- w- x-; no
          special attributes. No DSLs. No &lt;custom-elements&gt;.
          <em>Just vanilla HTML.</em>
        </p>
      </div>
      <div>
        <h2>lightweight<span>ü™∂</span></h2>
        <p>
          <strong>166 bytes in total.</strong> Zero dependencies. Zero JS
          bundles to load. Not even a backend is required.
          <em>Just an inline HTML snippet</em>.
        </p>
      </div>
      <div>
        <h2>nofilter<span>‚ö°</span></h2>
        <p>
          No preventDefaults. No hidden layers. Real DOM, real interactions. No
          VDOM, no click listeners. No AJAX, no fetch.
          <em>No reinventing browsers</em>.
        </p>
      </div>
    </section>

    <section>
      <p>
        <b>In a nutshell, htmz</b> lets you swap page fragments using vanilla
        HTML code.
      </p>
      <p>
        Imagine clicking a link, but instead of reloading the whole page, it
        <em>only updates the relevant portion of the page</em>.
      </p>
      <p>
        htmz is an <em>experiment</em> inspired by
        <a target="_blank" href="https://htmx.org/">htmx</a>,
        <a target="_blank" href="https://en.wikipedia.org/wiki/Comet_(programming)">Comet</a>, ‚ÄòHTML As The Engine Of Application State‚Äô<a target="_blank" href="https://en.wikipedia.org/wiki/HATEOAS">[1]</a><a target="_blank" href="https://htmx.org/essays/hateoas/">[2]</a>, and
        other similar web application architectures.
      </p>
    </section>

    <section>
      <h2>Demos</h2>
      <p>Check out these demos to get an idea of what htmz can do!</p>
      
      <div id="demos-tab-panel" role="tabpanel">
        <p>üêô Select an example above!</p>
      </div>
    </section>

    <section>
      <h2>Installing</h2>
      <p>Simply copy the following snippet into your page:</p>
      <pre><code>&lt;iframe hidden name=htmz onload=&#34;setTimeout(()=&gt;document.querySelector(contentWindow.location.hash||null)?.replaceWith(...contentDocument.body.childNodes))&#34;&gt;&lt;/iframe&gt;</code></pre>
      <p>
        For <strong>npm enjoyers</strong>, the following npm commands automate
        the process of copying the snippet into your page:
      </p>
      <pre><code><!--
--><span>npm install --save-dev</span> htmz
<span>npx</span> htmzify ./path/to/my/index.html<!--
      --></code></pre>
      <p>
        For <strong>hackers</strong>, you may start with the development version
        (deminified):
        <a href="https://github.com/Kalabasa/htmz/blob/master/htmz.dev.html" target="_blank">htmz.dev.html</a>
      </p>
    </section>

    <section>
      <h2>Basic usage</h2>
      <p>
        To invoke htmz, you need a hyperlink (or form) having these attributes:
      </p>
      <ol>
        <li>
          href (or action) pointing to the
          <strong>resource URL</strong>
          <code><span>href</span>=&#34;<span>/flower.html</span>‚ãØ</code>
        </li>
        <li>
          Continuing within the href:
          <strong>destination ID selector</strong>
          <code>‚ãØ<span>#my-element</span>&#34;</code>
        </li>
        <li>
          And a <strong>target</strong> attribute with this value
          <code><span>target=<strong>htmz</strong></span></code>
        </li>
      </ol>
      <pre><code><!--
-->
&lt;<span>a href</span>=&#34;<i>/flower.html</i><b>#my-element</b>&#34; <span>target=<strong>htmz</strong></span>&gt;Flower&lt;/<span>a</span>&gt;<!--
--></code></pre>
      <p>
        While this looks like an abuse of the URL fragment (it is), there is no
        other use for the URL fragment in this context, so it was repurposed as
        the destination ID selector. And it already looks like a CSS ID
        selector.
      </p>
      <p>
        <b>‚ö† Important note:</b> The loaded content
        <strong>replaces</strong> the selected destination. It may not be
        intuitive at first, but htmz does <em>not</em> insert the content into
        the destination. The rationale is that replacement is a more powerful
        operation. With replacement, you can <i>replace</i>,
        <i>delete</i> (replace with nothing), and <i>insert-into</i> (replace
        with the same container as original).
      </p>
    </section>

    <section>
      <h2>What does it do exactly?</h2>
      <p>htmz does one thing and one thing only.</p>
      <p>
        <strong>
          Enable you to load HTML resources within <em>any element</em> in the
          page.
        </strong>
      </p>
      <p>
        Think tabbed UIs, dual-pane list-detail layouts, dialogs, in-place
        editors, and the like.
      </p>
      <p>
        <em>This idea is not new.</em> Dividing web pages into independently
        reloading parts has been a thing since mid-1990s. They were called
        <a target="_blank" href="https://www.w3.org/TR/html401/present/frames.html"><b>frames</b></a>, namely, &lt;iframe&gt;s, &lt;frame&gt;s, and &lt;frameset&gt;s.
      </p>
      <p>
        <strong>htmz is a generalisation of HTML frames.</strong> ‚Äî Load
        HTML resources within <del>any frame</del> <ins>any element</ins> in the
        page.
      </p>
      <p>
        Read more on <a href="#how" target="_self">how it works</a> in a section
        below.
      </p>
    </section>

    <section>
      <h2 id="examples">Examples</h2>
      <p><img alt="todo app" src="https://leanrada.com/htmz/todo.png"/>
        <img alt="chat app" src="https://leanrada.com/htmz/chat.png"/>
        <img alt="calendar app" src="https://leanrada.com/htmz/cal.png"/>
      </p>
      <p>
        More example applications, componentization approaches, and code in
        different languages can be found in the
        <code>/examples</code> directory. To start the example server:
      </p>
      <pre><code><!--
--><span>cd</span> examples
./run_servers.sh<!--
--></code></pre>
      <p>Then load <code>http://localhost:3000/</code>.</p>
    </section>

    <section>
      <h2>Advanced usage</h2>
      <p>
        Naturally, only <code>&lt;a&gt;</code> and <code>&lt;form&gt;</code> elements
        can target and invoke htmz (as of current HTML5). This is fine; it‚Äôs
        semantic, after all. However, HTML offers a couple more features that
        work well with htmz.
      </p>

      <section>
        <h3>Per-button action &amp; target</h3>
        <p>
          If you want to override the form‚Äôs action on a per-button basis, use
          the
          <code>&lt;button&gt;</code>‚Äôs
          <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#formaction" target="_blank"><code>formaction</code></a>
          attribute.
        </p>
        <pre><code><!--
-->&lt;<span>form action</span>=&#34;<i>/default</i><b>#my-target</b>&#34; <span>target</span><b>=<span>htmz</span>&gt;</b>
  &lt;<span>button</span>&gt;Default form action&lt;/<span>button</span>&gt;
  &lt;<span>button formaction</span>=&#34;<i>/button</i><b>#my-target</b>&#34;&gt;
    Different button action
  &lt;/<span>button</span>&gt;
  &lt;<span>button formaction</span>=&#34;<i>/another-action</i><b>#another-target</b>&#34;&gt;
    Another action
  &lt;/<span>button</span>&gt;
&lt;/<span>form</span>&gt;<!--
--></code></pre>
      </section>

      <section>
        <h3>Base target value</h3>
        <p>Tired of adding <code>target=htmz</code> to every link and form?</p>
        <p>
          Using the
          <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base" target="_blank">base</a>
          element, set htmz as the default target for all relative links. Add
          this at the top of your page.
        </p>
        <pre><code><!--
-->&lt;<span>base target</span><b>=<span>htmz</span>&gt;</b><!--
--></code></pre>
      </section>

      <section>
        <h3>Clean target values</h3>
        <p>
          Don‚Äôt like the look of <code>target=htmz</code> at all? Prefer using
          the real target as the value?
        </p>
        <p>
          We can do a hack that enables you to write the target ID selector in
          the target attribute itself! Like this:
        </p>
        <pre><code><!--
-->
&lt;<span>a href</span>=&#34;<i>/flower.html</i>&#34; <span>target</span>=&#34;<b>#my-element</b>&#34;&gt;Flower&lt;/<span>a</span>&gt;<!--
--></code></pre>
        <p>
          The key is to add an iframe with a <em>matching name</em>, and modify
          the htmz snippet accordingly.
        </p>
        <pre><code><!--
-->&lt;<span>iframe hidden name</span>=&#34;<b>#my-element</b>&#34; <span>onload</span>=&#34;htmz(<span>this</span>)&#34;&gt;&lt;/<span>iframe</span>&gt;
&lt;<span>script</span>&gt;
  <span>function</span> htmz(frame) {
    document.<span>querySelector</span>(frame.name) 
      ?.<span>replaceWith</span>(...frame.contentDocument.body.children);
  }
&lt;/<span>script</span>&gt;
<!--
--></code></pre>
        <p>
          You can even
          <a href="https://github.com/Kalabasa/htmz/blob/master/examples/cf_clean_target_tabs/worker.js" target="_blank">automate the generation of matching target iframes</a>.
        </p>
      </section>

      <section>
        <h3>Scripting / interactivity</h3>
        <p>
          If you need something more interactive than the request-response
          model, you may try the htmz companion scripting language:
          <b>javazcript</b>. Sorry, I meant JavaScript, a scripting language
          designed to make HTML interactive.
        </p>
        <p>
          htmz does not preclude you writing JS or using UI libraries to enhance
          interaction. You could, say, enhance a single form control with
          <a href="http://vanilla-js.com/" target="_blank">vanillaJS</a>, but
          the form
          <em>values</em>
          could still be submitted as a regular HTTP form with htmz.
        </p>
        <p>That said, htmz is extensible!</p>
      </section>
    </section>

    <section>
      <h2>Extensibility</h2>
      <p>
        Need advanced selectors? Need error handling? Multiple targets? Fear
        not; the hero is here to save the day. The hero is you.
      </p>
      <p>
        Here‚Äôs
        <a href="https://github.com/Kalabasa/htmz/blob/master/htmz.dev.html" target="_blank">the development version of the snippet</a>. Feel free to hack and extend according to your needs. You‚Äôre a
        programmer, right?
      </p>
      <pre><code><!--
-->&lt;<span>script</span>&gt;
  <span>function</span> htmz(frame) {
    <b>// Write your extensions here</b>

    
    <span>setTimeout</span>(() =&gt;
      document
        .<span>querySelector</span>(frame.contentWindow.location.hash || <span>null</span>)
        ?.<span>replaceWith</span>(...frame.contentDocument.body.children)
    );
  }
&lt;/<span>script</span>&gt;
&lt;<span>iframe hidden name</span>=<span>htmz</span> <span>onload</span>=&#34;htmz(<strong>this</strong>)&#34;&gt;&lt;/<span>iframe</span>&gt;<!--
--></code></pre>
    </section>

    <section>
      <h2><abbr title="Freemptively answered questions">FAQ</abbr></h2>

      <section>
        <h3 id="how">How does it work?</h3>
        <p>
          htmz is an iframe named &#34;htmz&#34;. You invoke htmz by loading a
          URL into the iframe via target=htmz. By using an iframe, we lean on
          the browser‚Äôs native capability to fetch the URL and parse the HTML.
          After loading the HTML resource, we take the resulting DOM via an
          onload handler.
        </p>
        <p>htmz is essentially a <strong>proxy target</strong>.</p>
        <p>
          Like how a proxy server forwards requests to some specified server,
          proxy target htmz forwards responses into some specified target.
        </p>
        <pre><code><!--
-->
&lt;<span>a href</span>=&#34;<i>/flower.html</i>&#34; <span>target</span>=&#34;<b>#my-element</b>&#34;&gt;Flower&lt;/<span>a</span>&gt;


&lt;<span>a href</span>=&#34;<i>/flower.html</i><b>#my-element</b>&#34; <span>target</span>=<strong>htmz</strong>&gt;Flower&lt;/<span>a</span>&gt;<!--
--></code></pre>
        <p>
          When you load a URL into the htmz iframe, the onload handler kicks in.
          It extracts your destination ID selector from the URL hash fragment
          and transplants the iframe‚Äôs contents (now containing the loaded HTML
          resource) into your specified destination.
        </p>
        <p>
          htmz only runs when you invoke it. It does not continually parse your
          DOM and scan it for special attributes or syntax, nor does it attach
          listeners in your DOM. It‚Äôs a proxy not a VPN.
        </p>
      </section>

      <section>
        <h3>So it‚Äôs just another JavaScript framework?</h3>
        <p>Oh my! Not the f-word!!!</p>
        <p>
          On a more serious note, I would say that rather than a JS one, it‚Äôs
          more of an HTML micro-f*******k. It does use JS, but only the minimum
          necessary.
        </p>
      </section>

      <section>
        <h3>Is htmz a library or a framework?</h3>
        <p>htmz is a snippet. ‚úÇÔ∏è</p>
      </section>

      <section>
        <h3>What does htmz mean?</h3>
        <p>
          HTMZ stands for
          <i>
            <b>H</b>tml with <b>T</b>argeted <b>M</b>anipulation <b>Z</b>ones.
          </i>
        </p>
      </section>

      <section>
        <h3>Is this a joke?</h3>
        <p>
          This started as a
          <i>
            ‚ÄúDo I really need htmx? Can‚Äôt I do the load-link-into-target thing
            with current web? Sounds a lot like frames.‚Äù
          </i>
          and ended up with this.
        </p>
        <p>
          So, it isn‚Äôt quite a joke, but a response to htmx. I wanted to try
          htmx. The premise sounded great (<i>Why should you only be able to replace the entire screen?</i>), then I saw that it was 16kB of JavaScript. Huh. Then there‚Äôs
          special syntax everywhere. Huh. I don‚Äôt want to learn a whole new set
          of instructions and Turing-complete DSLs specific to those
          instructions.
        </p>
        <p>
          Regardless of joke status, htmz seems fine as a library. It feels
          kinda powerful for its tiny size. (But really it‚Äôs the browser that‚Äôs
          doing the heavy lifting!) Nonetheless, there are limitations.
        </p>
      </section>

      <section>
        <h3>What are the limitations?</h3>
        <p>
          The main direct limitation is having only one destination per
          response. However, this can be fixed by writing an extension. ;)
        </p>
        <p>
          A more general but classic limitation is the request-response model.
          The Web 1.0 model, and the baggage that comes with it. Like a
          roundtrip delay on every interaction, a browser history entry on every
          click, etc.
        </p>
        <p>
          The Web 1.0 model might also mean putting more UI logic in the web
          server. This can be a good thing or a bad thing, as it could lead to
          either consolidation or fragmentation of UI logic, which respectively
          decreases or increases complexity. It really depends on your goal and
          style.
        </p>
      </section>
    </section>

    

    <!-- prettier-ignore -->
    

    
  

</div>
  </body>
</html>
