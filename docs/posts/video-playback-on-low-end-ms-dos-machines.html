<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://scalibq.wordpress.com/2024/01/01/video-playback-on-low-end-ms-dos-machines/">Original</a>
    <h1>Video playback on low-end MS-DOS machines</h1>
    
    <div id="readability-page-1" class="page"><div>
						
<p>Playing video on MS-DOS… it kinda was a thing with things such as the <a href="https://en.wikipedia.org/wiki/Graphics_Animation_System_for_Professionals">GRASP/GLPro</a> and <a href="https://en.wikipedia.org/wiki/FLIC_(file_format)">FLIC</a> formats back in the day. But not on REALLY low-end machines, such as 8088s and CGA. Until the demo 8088 Corruption was released in 2004. And then its successor 8088 Domination in 2014, <a href="https://scalibq.wordpress.com/2014/08/13/8088-domination-by-trixterhornet/">which I already discussed earlier</a>.</p>



<p>It can play videos at very acceptable quality on an 8088 at 4.77 MHz with (composite) CGA and a Sound Blaster 2.0.</p>



<p>Wait, a Sound Blaster 2.0? That is a bit of an anachronism, is it not? Yes, but for two good reasons:</p>



<ol>
<li>The Sound Blaster was the first commonly available sound solution for the IBM PC that could take advantage of the DMA controller for sample playback, thereby reducing CPU load to near-zero.</li>



<li><a href="https://scalibq.wordpress.com/2017/03/12/dma-activation/">As discussed here earlier</a>, the early Sound Blasters had some shortcomings that meant they weren’t capable of seamless playback. The 2.0 version was the first to solve this.</li>
</ol>



<p>Okay, so the Sound Blaster 2.0 was the first *good* solution for digital audio playback. But, one may argue… An IBM PC with a 4.77 MHz 8088 and CGA is not in the ‘good’ category either, is it? The point is “let’s see what we can do anyway”. What if we also apply this to audio?</p>



<p>I’ve had this idea for a while. Since I had done a <a href="https://scalibq.wordpress.com/2016/12/11/any-real-keeping-lately/">streaming audio solution on PC speaker on my IBM 5160 PC/XT</a>, I wanted to add video as well. It would make sense to combine the two, as I already wrote at the time. And the past few days I had a bit of spare time, so I decided give it a quick-and-dirty try.</p>



<p>The code for the <a href="https://x86dc.wordpress.com/">XDC encoder and decoder</a> are <a href="https://github.com/MobyGamer/XDC">available on Github</a>, so I just made my own fork:</p>



<p><a href="https://github.com/Scalibq/XDC">https://github.com/Scalibq/XDC</a></p>



<h2>PC Speaker first</h2>



<p>As you can see from the commits, I added my code for <a href="https://scalibq.wordpress.com/2015/12/15/pc-compatibility-its-all-relative/">auto-EOI</a> to shave off a few cycles with each interrupt. For the Sound Blaster and ‘quiet’ options, this is not required, because there is only one interrupt per frame. But for the PC speaker and various other sound sources that don’t support DMA, you need an interrupt for every individual sample, so I enable auto-EOI in those cases.</p>



<p>I then added some PC speaker routines to enable PWM playback. I use a simple translation table that translates the unsigned 8-bit PCM samples in the XDV file to the correct PWM values. Note that the PWM values are dependent on the sample rate, so the table is initialized at runtime, when the sample rate of the file is known.</p>



<p>And that pretty much took care of things already. PC speaker sound is now working. There is extra CPU overhead of course, so you’ll either need a faster machine to play the same content, or you need to encode your content with a lower sample rate, and perhaps also reduce the frame rate and/or the <strong>MAXDISKRATE</strong> value when encoding. I would not recommend PC speaker on a 4.77 MHz machine at all, but on a turbo XT at 8 or 10 MHz, you should be able to get away with it reasonably well, as long as you keep the sample rate low enough, say between 8 and 11 kHz. It will be a bit of trial-and-error to find what works best for your specific machine.</p>



<h2>Then Covox…</h2>



<p>Now that I had a solution that could bit-bang samples, I figured I might as well add some other common devices. One is the Covox, which was trivial, as the 8-bit unsigned PCM samples could be sent to the Covox as-is. This makes it slightly faster than the PC speaker solution. It also sounds better. The quality is almost as good as the Sound Blaster. The main issue is that the interrupt-driven sample playback is more susceptible to jitter than DMA transfers are. On a fast enough machine that won’t be an issue, but on 8088s you may hear some minor jitter.</p>



<h2>And Tandy…</h2>



<p>Tandy is another interesting target. XDC already supports Tandy video modes, so adding Tandy audio would make sense. It can do PC speaker playback of course, but PWM also gives an annoying carrier wave. Sample playback on the SN76496 chip does not have that issue. You can get 4-bit PCM from the sound chip’s volume register. The volume is non-linear however, so you can’t just take the high nibble from the 8-bit source samples (it works, but it’s suboptimal). Instead you should use a translation table from the linear 8-bit samples to the correct non-linear 4-bit volume settings. That’s simple enough. I could just use the same approach as for the PC speaker, but with a different table.</p>



<p>The Tandy threw me a bit of a curveball though. I had done PCjr sample playback before, so I thought I could just take that code as a starting point. But it gave me a weird low base note, and very loud at that. Strange, that wasn’t there before?</p>



<p>Where the PCjr uses an actual <a href="https://en.wikipedia.org/wiki/Texas_Instruments_SN76489">Texas Instruments SN76496</a> chip, Tandy opted for a clone instead: an <a href="https://www.vgmpf.com/Wiki/index.php/NCR_8496">NCR 8496</a>. No big deal, you may think. But there’s a catch: for sample playback you set the SN76496 to a period value of 0. This is an undocumented feature that results in an output of 0 Hz, so effectively the output is constantly high. You can modulate it with the volume register, and presto: we have a 4-bit DAC.</p>



<p>The NCR 8496 however, didn’t get that memo. When you write a period of 0 to it, it interprets it as a value of 400h instead, which is one higher than the maximum period value of 3FFh you can normally set (<a href="https://scalibq.wordpress.com/2015/08/02/8088-mph-the-final-version/">which is very similar to the various 6845-implementations that interpret a hsync width of 0 differently</a>). So this results in a tone of (base frequency)/1024, instead of 0 Hz. That explains the loud base note I was hearing.</p>



<p>But wait, sample playback works on Tandy, doesn’t it? Didn’t Rob Hubbard use a sample channel in some of that excellent music he made for Tandy games? Well yes:</p>



<figure><p><span><iframe width="640" height="360" src="https://www.youtube.com/embed/I8_z_CI37JE?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation allow-popups-to-escape-sandbox"></iframe></span>
</p></figure>



<p>So how does that work then? I decided to study the code and see what it did exactly. And indeed, I found that it set a period of 1 instead of a period of 0. On the NCR 8496 this results in the highest possible frequency it can play, rather than the lowest possible frequency that you got with a period of 0. Since this frequency is well beyond the audible spectrum (over 100 kHz), you won’t actually hear it. But you can hear the modulation with the volume register, giving you the same DAC-like effect (this same trick is also used on the <a href="https://en.wikipedia.org/wiki/Philips_SAA1099">SAA1099</a> sound chip by the way, found on the <a href="https://en.wikipedia.org/wiki/Sound_Blaster#Creative_Music_System_and_Game_Blaster">CMS/GameBlaster</a>, for example in the game <a href="https://www.mobygames.com/game/233/battletech-the-crescent-hawks-revenge/">BattleTech: The Crescent Hawk’s Revenge</a>).</p>



<p>So once I figured out how the NCR 8496 and SN76496 are different, it was an easy enough fix. Apparently all my code was correct after all, I should just have set a period of 1 instead of a period of 0.</p>



<h2>Sound Blaster..</h2>



<p>Sound Baster? That was already supported, wasn’t it? Well yes, the 2.0 version. But as I <a href="https://scalibq.wordpress.com/2017/03/12/dma-activation/">discussed earlier</a>, you can implement streaming playback on earlier Sound Blasters as well. It will not be entirely glitch-free, but you can get acceptable results.</p>



<p>In this case I just went for a quick-and-dirty approach. The thing is that the audio buffer size is directly related to the frame rate. That is, an audio buffer has the exact length of one frame. That is what makes the magic work in the original XDC player: the SB will generate an interrupt when the audio buffer has completed. The interrupt handler will then display a new frame. This means that the audio buffers are extremely short.</p>



<p>As I said earlier, that is suboptimal, because you get a glitch everytime you start a new buffer. So ideally you want the largest possible buffers, to reduce glitching to a minimum. However, for now I just went for a quick-and-dirty solution that just restarts the audio buffer at every interrupt. It was trivial to add this to the existing code. It will result in a glitch at every frame. However, this glitching is because of the time it takes to start a new buffer on the DSP. When I wrote the article, the assumption was that you use high sample rates. As I wrote in the article, sending a new command to the DSP took about 316 CPU cycles on an 8088 at 4.77 MHz, while a single sample at 22 kHz took 216 CPU cycles. Clearly, at lower sample rates, each sample takes longer, while the DSP time should remain constant. So that means the glitches become less obvious at lower rates, and perhaps won’t be noticeable at all, given a low enough rate.</p>



<p>I may revisit this code at some point, and modify the buffering of audio in a way that I can apply some of the ideas in my earlier article, by using a large DMA buffer. But for now at least SB 1.x works. And the code checks the DSP version, so it only uses this fallback when a 1.x SB is detected. SB 2.0 and higher should still work as they always did, so they are not compromised in any way by this addition.</p>



<h2>So now what?</h2>



<p>Well, one way to use this is to create new content, targeted specifically at lower sample rates that work better on these newly supported sound devices.</p>



<p>Another way is to run existing content on faster machines. 8088 Domination uses 22 kHz audio, which is a pretty bad case for bit-banged devices. But a reasonably fast 286 will have no problem with that. So you should be able to play back the 8088 Domination content as-is on a fast enough machine.</p>



<p>A third method is to downgrade the existing content. The audio buffers are stored at the end of each frame. It is trivial to downsample the buffers in-place. A turbo XT should be able to play the video content on PC speaker/Covox when the audio is downsampled from 22 kHz to something in the range of 8-11 kHz I would think.</p>



<p>And when you modify the audio anyway, you could also pre-apply the translation table, so it won’t have to be done at runtime, shaving off some precious CPU-cycles per sample, which will definitely improve performance. Some extra feature flags could be introduced to the feature-byte of the XDV-format to mark PWM-encoded or Tandy-encoded audio.</p>



<p>Anyway, feel free to experiment and have fun. <a href="https://scalibq.wordpress.com/2024/01/02/some-results-from-the-modified-xdc-movie-player-for-8088-cga/">See the next post</a> for some of my results, and a modified version of 8088 Domination to toy around with.</p>



<figure><p><span><iframe width="640" height="360" src="https://www.youtube.com/embed/HAmL9UXRWNM?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation allow-popups-to-escape-sandbox"></iframe></span>
</p></figure>

			
														</div></div>
  </body>
</html>
