<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gilslotd.com/blog/features_id_postgresql">Original</a>
    <h1>Features I&#39;d Like in PostgreSQL</h1>
    
    <div id="readability-page-1" class="page"><div><p>I’ve put in my fair share of time with PostgreSQL. It has no shortage of functionality and I believe its expansive feature set drove a lot of its growing popularity in the 2010s. As my time with the database has worn on I’ve come up with a handful of features that I wish the database had. Some of these are ideas borrowed from other systems, some are inventions of my own. The real tragedy is that I simply don’t have the time to implement the patches myself.</p>
<h3>–i-am-a-dummy mode</h3>
<p>This idea comes from MySQL whose stock CLI client supports an <a href="https://dev.mysql.com/doc/refman/8.0/en/mysql-tips.html#safe-updates">–i-am-a-dummy flag</a>. When enabled, MySQL identifies any UPDATE or DELETE that lacks a WHERE clause and fails them with an error. In other words, if you intended to <code>DELETE FROM table1 WHERE pk = 10</code>, started typing it into your prompt, and only got as far as <code>DELETE FROM table1</code> before accidentally executing the query, the query errors out instead of having every row deleted. More modern versions of MySQL also use the flag to block queries that return excessively large result sizes, require the WHERE to reference a key column, or allow a LIMIT in place of a WHERE.</p>
<h3>Unit test mode (random result sorting)</h3>
<p>The order of a query’s results is famously unspecified unless you nail it down with an ORDER BY. The flexibility is useful: sometimes you need a stable order for whatever code consumes the query results and sometimes you just don’t. But there is a secret, third thing: some code comes to accidentally depend on a coincidental ordering of the results. To help flush these out it would be neat if PostgreSQL could intentionally shuffle the order of query results if a given query did not specify an ORDER BY. I imagine this as a run-time configuration field for the database that you’d turn on when running automated tests or in a testing environment. The alternative, folding every query in your application into a subquery that randomly sorts the results, is ugly and invasive, although perhaps some ORMs could implement the feature at their level.</p>
<p>Update: <a href="https://news.ycombinator.com/item?id=34563051">User avianlyric</a> on Hacker News pointed out that CLUSTER can can be used to reorder results in a pinch.</p>
<h3>Query progress in psql</h3>
<p><a href="https://mariadb.com/kb/en/progress-reporting/">This is another feature from MariaDB</a>. It’s possible in both databases to query the database to get progress information on several types of queries, but the ALTER TABLE, CREATE INDEX, DROP INDEX and LOAD DATA INFILE queries also automatically inform the CLI client on their progress. The CLI uses this to draw a nice animated status bar with some informational messages. PostgreSQL lets you <a href="https://www.postgresql.org/docs/15/progress-reporting.html">query the system catalog for the progress of several query types</a> but has no live update functionality in the psql client.</p>
<h3>Pandas-like join validation</h3>
<p>I am a true database expert who has never screwed up a join before. But there are many beginners out there and it would be neat to extend the SQL language to support <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.merge.html">validation features</a> like Pandas has for its join function. When doing a join you’d specify what relation you expect to have unique keys and which one has potential duplicates and PostgreSQL could warn or panic when this assertion is triggered. Some hypothetical syntax:</p>
<pre>SELECT x, y
FROM t1
JOIN t2 USING (key) VALIDATE 1:m
</pre><p>Which would have PostgreSQL check that t1.key has no duplicate rows and errors if it comes across any. This is another place where it would be useful to have a runtime option to disable the expensive uniqueness checks.</p>
<p>Pandas’ “suffixes” argument, which automatically renames overlapping columns in the output, and “indicator”, which emits a new column identifying the left or right table or both as the source of an output row, are also neat ideas that seem really helpful for relational newbies trying to troubleshoot their joins. Pandas is insanely popular, it’s taught to a lot of very inexperienced developers, and I think features like these were earned with newbie blood. I suspect PostgreSQL’s users and developers don’t get that sort of exposure to newbies and their typical problems but there’s no reason why they can’t learn from the hard-earned experience of Pandas and incorporate some good ideas.</p>
<p>Update: <a href="https://news.ycombinator.com/item?id=34561436">User richbell</a> on Hacker News brought up DuckDB&#39;s <a href="https://duckdb.org/2022/05/04/friendlier-sql.html">Friendlier SQL</a> which is a superset of sensible extensions to SQL. I endorse all of these ideas except for the trailing comma fix - join the dark side and use leading commas!</p>
<h3>JIT support for CREATE INDEX</h3>
<p>Today, the JIT support in PostgreSQL is closely tied to query planning and execution. It rests upon the object-oriented nature of the execution plan and emits LLVM IR for each plan node as it traverses the plan tree. It’s an elegant technical approach, and for its sweet spot of long-running analytical queries it can cut down on query time and free up CPU time.</p>
<p>DDL statements are not JITed, and for good reason - the vast majority of them are going to be I/O bound and not particularly interesting or useful to JIT. However, this is one exception: CREATE INDEX. Even though it does a lot of I/O (typically scanning the entire table) in my experience it is CPU-bound. Even moderately sized tables of tens or hundreds of gigabytes can take 10-30 minutes to index. And sometimes you just have to reindex everything, at once, like when you restore a backup with pg_restore. JIT compilation of the index creation code would be a huge and immediate benefit to just about every PostgreSQL user. And it would be a benefit: the PGCon 2017 presentation “<a href="https://www.pgcon.org/2017/schedule/attachments/467_PGCon%202017-05-26%2015-00%20ISPRAS%20Dynamic%20Compilation%20of%20SQL%20Queries%20in%20PostgreSQL%20Using%20LLVM%20JIT.pdf">JIT-Compiling SQL Queries in PostgreSQL Using LLVM</a>“ which first explored JIT compilation found up to a 19% improvement in index creation time.</p>
<h3>Reduce the memory usage of prepared queries
<!--3--></h3>
<p>Like many databases, PostgreSQL has a <a href="https://www.postgresql.org/docs/15/sql-prepare.html">PREPARE statement</a> that takes an entire query with placeholder values and stores its query plan for future re-use. You can later invoke the stored query with EXECUTE, passing values in for the placeholders, and take advantage of all the precomputed query planning work. If your query is executed more than once, even if only a few times, this winds up being a measurable win. The database feature has been around for years and years and years, but over on the Python driver side, we’re finally starting to see database drivers automatically preparing and managing prepared queries for you (see <a href="https://www.psycopg.org/psycopg3/docs/advanced/prepare.html">psycopg3</a> and <a href="https://magicstack.github.io/asyncpg/current/api/index.html#prepared-statements">asyncpg</a>). The rollout of these drivers is slow, even if they are production-ready, but over time we are only going to see more and more inadvertent users of prepared statements.</p>
<p>On the server side, prepared statements are per connection. They don’t take up a ton of memory, especially on the sort of beefy machine you’d use as a database host, but they take up more than you might expect them to do, to the point where it made sense for me to deallocate prepared plans when I knew they wouldn’t be used anymore. The per connection scope means that there’s no way to share query plans across connections. My first feature I’d like to see around PREPARE is a way to share prepared statements in some sort of global cache. A typical OLTP database is going to have a handful of long-lived connections, behind some sort of bouncer, and some number of hot queries, whether they are determined automatically by a driver or explicitly by the application developer. A global cache could easily be hydrated when a long-lived connection starts up or as queries are issued and easily gets some performance wins.</p>
<p>This issue was <a href="https://www.postgresql.org/message-id/15923-4b35496c683c52d2%40postgresql.org">reported in 2019 by Daniel Migowski</a> who provides some statistics. He happens to be working with some decently large queries which turn out to have 30-45 MB stored query plans, totalling 7 GB of RAM over his dataset of around 250 queries. It can get ugly! Under the hood, the PREPARE statement stores everything in <a href="https://github.com/postgres/postgres/blob/8d2c1913ed3df9384973399deeb75fc1e55943fe/src/include/utils/plancache.h#L44">struct CachedPlanSource</a>, which includes the original query’s text, the parse tree for the query, the query tree for the query, and possibly the plan tree if the database decides to re-use a generic plan for each execution. All of this is potentially needed to execute a prepared statement in the future.</p>
<p>But I’d also like to draw your attention to an <a href="https://www.postgresql.org/message-id/7995.1564092813%40sss.pgh.pa.us">email by Tom Lane</a> later in the thread where he suggests some techniques to reduce the memory usage of the individual query plan. In particular, one of the suggestions is:</p>
<blockquote><p>A totally different idea is to make a variant version of copyObject that is intended to produce a compact form of a node tree, and does not create a separate palloc allocation for each node but just packs them as tightly as it can in larger palloc chunks.  [...] The stumbling block here is that nobody is gonna tolerate maintaining two versions of copyfuncs.c, so you&#39;d have to find a way [...] to autogenerate the copy functions from annotated struct definitions; people have muttered about that for years but not done anything.</p>
</blockquote>
<p>Some background on PostgreSQL’s memory management circus: there are a lot of tree data structures in the backend of the database. Originally, <a href="https://github.com/postgres/postgres/blob/d31084e9d1118b25fd16580d9d8c2924b5740dff/src/backend/nodes/README#L54">when the database was written in Lisp</a>, the trees and their nodes were what I’d broadly call object-oriented giving them standard interfaces, constructors and destructors. When porting to C they created this copyObject function that can traverse trees, inspect each node and do the appropriate work to copy it. I’d still call it object-oriented but it is definitely C-flavored OO. This high-level interface over trees is the first of three legs of memory management in PostgreSQL.</p>
<p>The second leg is memory contexts. Each context has a malloc-like interface (palloc, as mentioned by Tom before) that allocates within a memory context. All memory contexts are organized into a hierarchy of contexts, and there is always a current context used by palloc() that gets set by the backend as it moves through the different stages of query execution. By scoping allocations with the same lifetime you reduce memory fragmentation but also make cleanup easier - when the user is finished with a query or it aborts for whatever error, you can tear down the relevant parent memory context and have all of its children recursively cleaned up.</p>
<p>The memory context API is also object-oriented in that it is a standard interface implemented by several sub-allocators. They make up third leg of memory management in the database. The most frequently used one is AllocSet, an arena allocator. This is the actual code that calls malloc() and free() to get whole free pages from the system. AllocSet maintains its own freelist to avoid too much round-tripping between PostgreSQL and the system allocator and groups smaller allocations of the same size onto the same page to reduce fragmentation.</p>
<p>There’s a lot of flexibility in this system but there’s also a decent amount of overhead as each step is allocating one or more structs for its own bookkeeping data. Avoiding this overhead is what Tom is proposing: there could be a special copyObject that figures out the full size of the tree it has to copy, makes a single allocation, and packs everything into it, avoiding most of the overhead from all the small data structures needed for the prepared query. This is the second feature I’d like to see attempted to save PREPARE memory usage.</p>
<h3>An entirely new allocator?</h3>
<p>AllocSet is a mature battle-tested, and pretty simple piece of code which has sat at the heart of PostgreSQL since 1999 with little change to its design since then. There is something to be said for the longevity of such a fundamental piece of code and I would not be surprised if any alternate implementations can’t beat its performance just because of its simplicity. I’d like to see someone try to slot one of the modern malloc implementations (e.g. jemalloc, mimalloc, tcmalloc) into PostgreSQL. Even if it isn’t a win I’d like to see the results. Modern implementations take advantage of everything we’ve learned about writing fast memory allocation on modern hardware and operating systems and have seen lots of real-world testing. I also don’t think the palloc()/memory context API needs to change at all, modern allocators typically have an arena allocator interface and could be slotted in to replace the memory context API without API breakage. Some concerns would be legal licensing or performance losses from synchronization (the PostgreSQL backend is single-threaded and thus any effort spent on locking or synchronization is wasted) but I am hopeful that there is a malloc that can fit the bill.</p>
</div></div>
  </body>
</html>
