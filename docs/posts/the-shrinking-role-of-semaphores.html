<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/Articles/928026/">Original</a>
    <h1>The shrinking role of semaphores</h1>
    
    <div id="readability-page-1" class="page"><div>
<center>
           <div><b>This article brought to you by LWN subscribers</b><p>Subscribers to LWN.net made this article — and everything that
       surrounds it — possible.  If you appreciate our content, please
       <a href="https://lwn.net/subscribe/">buy a subscription</a> and make the next
       set of articles possible.</p></div>
           </center>
           <p>
The kernel&#39;s handling of concurrency has changed a lot over the years.  In
2023, a kernel developer&#39;s toolkit includes tools like completions, highly
optimized mutexes, and a variety of <a href="https://lwn.net/Articles/844224/">lockless
algorithms</a>.  But, once upon a time, concurrency control came down to
the use of simple semaphores; a discussion on a small change to the
semaphore API shows just how much the role of semaphores has changed over
the course of the kernel&#39;s history.
</p><p>
At its core, a semaphore is an integer counter used to control access to a
resource.  Code needing access must first decrement the counter — but only
if the counter&#39;s value is greater than zero; otherwise it must wait for the
value to increase.  Releasing the semaphore is a matter of incrementing the
counter.  In the Linux kernel implementation, acquisition of a semaphore
happens with a call to <a href="https://elixir.bootlin.com/linux/v6.2.9/source/kernel/locking/semaphore.c#L43"><tt>down()</tt></a>
(or one of a few variants); if the semaphore is unavailable,
<tt>down()</tt> will wait until some other thread releases it.  The release
operation, unsurprisingly, is called <a href="https://elixir.bootlin.com/linux/v6.2.9/source/kernel/locking/semaphore.c#L176"><tt>up()</tt></a>.
In the classic literature, as defined by Edsger Dijkstra, those operations
are called <tt>P()</tt> and <tt>V()</tt> instead.
</p><p>
The 0.01 kernel release in 1991 did not have semaphores — or much of any
other concurrency-control mechanism, in truth.  In the beginning, the
kernel only ran on uniprocessor systems and, like most Unix systems at that
time, the kernel had exclusive access to the CPU for as long as it chose to
run.  A process running in the kernel would not be preempted and would
continue to execute until it explicitly blocked on an event or returned to
user space, so data races were rarely a problem. The one exception was
hardware interrupts; to prevent unwanted concurrency from interrupts, the
code was liberally sprinkled with <tt>cli()</tt> and <tt>sti()</tt> calls
to block (and unblock) interrupts where needed.
</p><p>
In May 1992, the 0.96 release brought a number of significant changes,
including some initial &#34;networking&#34; support; it enabled Unix-domain sockets
using a Linux-specific <tt>socketcall()</tt> system call.  Perhaps most
significant in this release, though, was the addition of support for SCSI
devices; good SCSI support would be a key factor during the early adoption
phase of Linux.  The SCSI subsystem brought with it the first mention of
semaphores in the kernel, buried deep down within the driver layer.  Like
many that would follow, SCSI semaphores were <i>binary</i> semaphores,
meaning that their initial value was set to one, allowing only a single
thread to have access to the resource (a SCSI host controller) that it
managed.  The 0.99.10 release in June 1993 brought a reimplemented network
layer and support for System V semaphores in user space, but still no
general support for semaphores in the kernel.
</p><h4>The addition of semaphores</h4>
<p>
The first implementation of general-purpose semaphores for the kernel
itself showed up in the 0.99.15c release in February 1994.  The initial user
was the virtual filesystem layer, which added a semaphore to <a href="https://elixir.bootlin.com/linux/0.99.15c/source/include/linux/fs.h#L160">the
<tt>inode</tt> structure</a>; no other users had been added by the 1.0
release one month later.  The 2.0 release (June 1996) saw a slow growth in
the number of semaphores, as well as the addition of the infamous big
kernel lock (BKL), which was not a semaphore.
</p><p>
That was the beginning of SMP support and, even then,
kernel code ran under the BKL by default, so most kernel code was limited
in the amount of concurrency it had to deal with.  In essence, the BKL
existed so that kernel code could run under the same assumption of
exclusive access to the CPU that had been wired deeply into the code
since the beginning; it only allowed one CPU to be running in the kernel at
any given time.  So disabling interrupts was still by far the most common
concurrency-control mechanism in use in the kernel.
</p><p>
By the 2.2 release (January 1999), there were 71 <tt>struct semaphore</tt>
declarations in the kernel; by 2.4.0 (January 2001) that number had grown
to 138, and by 2.6.0 (December 2003) it was 332.  The 2.6.14 release, in
October 2005, had 483 semaphore declarations.  By this time, disabling
interrupts was falling out of favor as a way to control concurrency — the
cost on system performance as a whole was simply too high — and the big
kernel lock had become a scalability problem in its own right.
</p><p>
Meanwhile, the first spinlock infrastructure was added in the 2.1.23
development kernel, though it was not really used until a spinlock was
added to the scheduler in 2.1.30.  Unlike a semaphore, a spinlock is a pure
mutual-exclusion primitive, without a semaphore&#39;s count.  It also is a
non-sleeping lock; code waiting for a spinlock would simply &#34;spin&#34; in a
tight loop until the lock became available.  Until this addition,
semaphores had been the only generalized mutual-exclusion mechanism
supported by the kernel.
</p><p>
Spinlocks were better than semaphores for many situations, but they came
with the restriction that code holding a spinlock is not allowed to sleep;
that meant that there was still a need for a semaphore-like structure.
Around the end of 2005, though, developers <a href="https://lwn.net/Articles/163842/">started thinking</a> that a better solution might
exist for the binary-semaphore case — which was how most semaphores were
used.  An initial &#34;mutex&#34; implementation turned out to perform worse than
semaphores did but, as happened frequently in that era, Ingo Molnar <a href="https://lwn.net/Articles/165039/">showed up</a> with a faster alternative within
days.  Mutexes were soon added to the kernel as an alternative to semaphores,
and the process of converting semaphores to mutexes began.
</p><h4>A slow transition</h4>
<p>
When mutexes were introduced, developers worried that they would force a
flag-day change where all binary semaphores would be changed over to the
new type.  But mutexes were added alongside the old type, allowing the two
to coexist and code to be converted at leisure.  As a result,
unsurprisingly, there are still over 100 semaphores declared in the kernel,
the bulk of which appear to be binary semaphores.  It is hard to find
patches that add new semaphores, though; the most recent would appear to be
<a href="https://git.kernel.org/linus/63fbae0a74c3">this driver patch</a>
in August 2022.  Most kernel developers, it seems, have no reason to think
about semaphores much of the time.
</p><p>
Modules maintainer Luis Chamberlain has recently been working on a problem
where the arrival of a large number of requests to load modules in a short
time can create difficulties for the memory-management subsystem.  After
some discussion, he posted <a href="https://lwn.net/ml/linux-kernel/ZB4BP0ZgxNirBNOJ@bombadil.infradead.org/">a
proposal</a> for a mechanism that would simply limit the number of
module-load operations that can be underway at any given time.  Linus
Torvalds quickly <a href="https://lwn.net/ml/linux-kernel/CAHk-=whkj6=wyi201JXkw9iT_eTUTsSx+Yb9d4OgmZFjDJA18g@mail.gmail.com/">answered</a>,
reminding Chamberlain that semaphores (&#34;<q>a *classic* concurrency
limiter</q>&#34;) could be used for that purpose.  The patch has since <a href="https://lwn.net/ml/linux-kernel/20230329053149.3976378-5-mcgrof@kernel.org/">been
reworked</a> along those lines.
</p><p>
As part of the associated discussion, though, Peter Zijlstra <a href="https://lwn.net/ml/linux-kernel/20230329091935.GP4253@hirez.programming.kicks-ass.net/">noted</a>
that <a href="https://elixir.bootlin.com/linux/v6.3-rc5/source/include/linux/semaphore.h#L21">the
<tt>DEFINE_SEMAPHORE()</tt> macro</a>, which declares and initializes a
static semaphore, sets the initial value to one, creating a binary
semaphore by default.  Since, as he said, &#34;<q>binary semaphores are a
special case</q>&#34;, it would have been better to have
<tt>DEFINE_SEMAPHORE()</tt> take an additional argument to specify what the
initial value should be.  Torvalds <a href="https://lwn.net/ml/linux-kernel/CAHk-=whF6Ta_KcJP2eC78+Mstv+vAku8ATRMbv98sf9VhdvySQ@mail.gmail.com/">agreed</a>
that this change would make sense: &#34;<q>So let&#39;s just make it clear that the
only reason to use semaphores these days is for counting semaphores, and
just make DEFINE_SEMAPHORE() take the number.</q>&#34; Semaphores, he said, are
now &#34;<q>almost entirely a legacy thing</q>&#34;.  Zijlstra has since <a href="https://lwn.net/ml/linux-kernel/20230330115626.GA124812@hirez.programming.kicks-ass.net/">posted
a patch</a> to that effect.
</p><p>
This minor change to the semaphore API is not likely to affect too many
developers.  There is still, though, the open question of the dozens of
binary semaphores still in use.  There would be value in converting them
over to mutexes; the performance would be better, and the resulting code
would look more familiar to current developers.  As Sergey Senozhatsky <a href="https://lwn.net/ml/linux-kernel/20230331034209.GA12892@google.com/">pointed out</a>,
though, it is not possible to mechanically convert those users without
taking a close look.  There is, for example, a binary semaphore that
persists in the <tt>printk()</tt> code because <tt>mutex_unlock()</tt>
cannot be called from interrupt context, while <tt>up()</tt> can.
</p><p>
It just goes to show that in the kernel, as elsewhere, old code can persist
for a long time.  The use of binary semaphores was arguably outmoded in
2006, but many uses remain and it took until 2023 to change the initializer
to not create a binary semaphore by default.  Kernel developers may come
and go, but kernel code, at least sometimes, can stay around for a lot
longer.<br clear="all"/></p><table>
           <tbody><tr><th colspan="2">Index entries for this article</th></tr>
           <tr><td><a href="https://lwn.net/Kernel/Index">Kernel</a></td><td><a href="https://lwn.net/Kernel/Index#Locking_mechanisms-Semaphores">Locking mechanisms/Semaphores</a></td></tr>
            <tr><td><a href="https://lwn.net/Kernel/Index">Kernel</a></td><td><a href="https://lwn.net/Kernel/Index#Semaphores">Semaphores</a></td></tr>
            </tbody></table></div></div>
  </body>
</html>
