<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.hillelwayne.com/post/decision-table-patterns/">Original</a>
    <h1>Decision Table Patterns (2020)</h1>
    
    <div id="readability-page-1" class="page"><article lang="en">
    

    
    

    <div>
  

<p>Decision tables are easy, simple, and powerful. You can teach them in five minutes and write one in half that time. You can look at a table and understand what it’s saying, see if it matches your problem, and check for design flaws. So it’s kinda weird that there’s basically nothing about them online. I wrote an <a href="https://www.hillelwayne.com/post/decision-tables/">introduction</a> a while back, but I want something a little more formal. So this post will reintroduce the core ideas in a more formal way and then talk about some of the techniques you can apply to make better tables.</p>

<p>Note that this is a theorycrafting post. I haven’t tested all of the content in production and can’t guarantee that they work well in practice. Caveat emptor.</p>

<h2 id="basics">Basics</h2>

<p>A decision table maps finite enumerated inputs to outputs. The outputs can be anything: returned values, side effects, whatever, but all possible inputs must map to an output. By looking at the table, you know what’s supposed to happen. This makes them good for case analysis and examining requirements.</p>

<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>O</th>
</tr>
</thead>

<tbody>
<tr>
<td>T</td>
<td>T</td>
<td>T</td>
<td><strong>1</strong></td>
</tr>

<tr>
<td>T</td>
<td>T</td>
<td>F</td>
<td><strong>3</strong></td>
</tr>

<tr>
<td>T</td>
<td>F</td>
<td>T</td>
<td><strong>7</strong></td>
</tr>

<tr>
<td>T</td>
<td>F</td>
<td>F</td>
<td><strong>0</strong></td>
</tr>

<tr>
<td>F</td>
<td>-</td>
<td>-</td>
<td><strong>2</strong></td>
</tr>
</tbody>
</table>

<p>For all of these examples we’ll assume one output, O, unless otherwise specified. There is more technique involved in encoding inputs than outputs.</p>

<p>A decision table is <strong>complete</strong> if every possible combination of inputs is represented by a row. It is <strong>sound</strong> if a row of inputs doesn’t appear twice with two different outputs. It is <strong>valid</strong> if it is both complete and sound. A valid table, then, will have exactly one row for each possible combination of inputs. If we have two boolean inputs and one 3-value enumeration, then the table will have 12 rows.</p>

<p>Because decision tables must satisfy rules to be considered valid, they are considered a form of <strong>formal specification</strong>. By being formalized, 1) we can analyze correctness of a table with automated tooling, and 2) errors in the construction of the table often map to errors in our design itself.</p>

<p>Decision tables are also called Parnas tables, especially when they’re used as part of formal verification.</p>

<h3 id="vs-pattern-matching">vs. Pattern Matching</h3>

<p>A common question asked about decision tables is “why not pattern match?” In many languages we can do something like this:</p>
<div><pre><code data-lang="fsharp"><span></span><span>let</span><span> patternMatch a b c </span><span>=</span>
<span>    </span><span>match</span><span> </span><span>(</span><span>a</span><span>,</span><span> b</span><span>,</span><span> c</span><span>)</span><span> </span><span>with</span>
<span>    </span><span>|</span><span> </span><span>(</span><span>true</span><span>,</span><span> </span><span>true</span><span>,</span><span> </span><span>true</span><span>)</span><span>   </span><span>-&gt;</span><span> </span><span>1</span>
<span>    </span><span>|</span><span> </span><span>(</span><span>true</span><span>,</span><span> </span><span>true</span><span>,</span><span> </span><span>false</span><span>)</span><span>  </span><span>-&gt;</span><span> </span><span>3</span>
<span>    </span><span>|</span><span> </span><span>(</span><span>true</span><span>,</span><span> </span><span>false</span><span>,</span><span> </span><span>true</span><span>)</span><span>  </span><span>-&gt;</span><span> </span><span>7</span>
<span>    </span><span>|</span><span> </span><span>(</span><span>true</span><span>,</span><span> </span><span>false</span><span>,</span><span> </span><span>false</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>0</span>
<span>    </span><span>|</span><span> </span><span>(</span><span>false</span><span>,</span><span> </span><span>_,</span><span> </span><span>_)</span><span>        </span><span>-&gt;</span><span> </span><span>2</span>
</code></pre></div>

<p>In which case we already have an execution. So why use decision tables if they don’t map to execution?</p>

<p>This is because decision tables are <em>specification</em>, not code.  Pattern matching is good for representing a single decision in the code. Decision tables represent a decision at any abstraction level, whether for the code or the entire system. They can even represent high-level non-code decisions:</p>

<table>
<thead>
<tr>
<th>PR passed review?</th>
<th>PR passed tests?</th>
<th>O</th>
</tr>
</thead>

<tbody>
<tr>
<td>T</td>
<td>T</td>
<td>Merge</td>
</tr>

<tr>
<td>T</td>
<td>F</td>
<td>Fix tests</td>
</tr>

<tr>
<td>F</td>
<td>T</td>
<td>Fix review comments</td>
</tr>

<tr>
<td>F</td>
<td>F</td>
<td>Fix tests first</td>
</tr>
</tbody>
</table>

<p>Pattern matching is part of the language implementation. Decision tables are more to help you with the design.</p>

<p>That said you also see decision tables as a control-flow  construct. Decision tables are pretty popular in both rules engines and automated QA tools that large enterprises use. SAP advertises their automated decision tables. I am much more interested in their use as specification tools and will not discuss their use as an implementation construct further.</p>

<h3 id="representing-infinite-states">Representing Infinite States</h3>

<p>The system can have an infinite number of states as long as they map to a finite number of values. We can do this by grouping the states into “effectively similar inputs”, or <strong>equivalence classes</strong>. Then we replace the raw input with the class. As an instructive example, we <em>cannot</em> make a “naïve” odd-or-even table, as there are infinite positive numbers:</p>

<table>
<thead>
<tr>
<th>N</th>
<th>O</th>
</tr>
</thead>

<tbody>
<tr>
<td>1</td>
<td>odd</td>
</tr>

<tr>
<td>2</td>
<td>even</td>
</tr>

<tr>
<td>3</td>
<td>odd</td>
</tr>

<tr>
<td>4</td>
<td>even</td>
</tr>

<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>

<p>Since not every possible input can be represented, this table is not complete and so not valid. What we can do is replace the number N with the equation <code>N % 2</code>. That has only a finite number of inputs and leads to a valid table.</p>

<table>
<thead>
<tr>
<th><code>N % 2</code></th>
<th>O</th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>even</td>
</tr>

<tr>
<td>1</td>
<td>odd</td>
</tr>
</tbody>
</table>

<p>Another thing we can do is partition inputs into <strong>intervals</strong>: giving lower and upper bounds for the numbers in each class. Another trite example, “can this person drink in the US?”</p>

<table>
<thead>
<tr>
<th>Age</th>
<th>O</th>
</tr>
</thead>

<tbody>
<tr>
<td>0-21</td>
<td>F</td>
</tr>

<tr>
<td>21-</td>
<td>T</td>
</tr>
</tbody>
</table>

<p>Intervals can be ambiguous: does <code>0-21</code> include 0, 21, or both? If both, how do you express the real numbers between 0 and 21, exclusive? We can adapt some math notation here: <code>(0, 21)</code> excludes both while <code>[0, 21]</code> includes both.</p>

<table>
<thead>
<tr>
<th>Age</th>
<th>O</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>[0, 21)</code></td>
<td>F</td>
</tr>

<tr>
<td><code>[21, ∞)</code></td>
<td>T</td>
</tr>
</tbody>
</table>

<p>Conventionally a missing bound is implied to extend to infinity, so we write <code>[21, ∞)</code> as <code>[21, )</code>.</p>

<h2 id="aesthetics">Aesthetics</h2>

<p>These are habits that make decision tables more visually pleasing. I have no idea if they actually make them better or are just decoration.</p>

<h3 id="row-ordering">Row ordering</h3>

<p>Rows should be ordered by column value. The leftmost column is the most significant key, then the second leftmost, all the way forward. In other words:</p>



<div>
  <p><strong>BAD</strong></p>

<p><strong>GOOD</strong></p>

<table>
<thead>
<tr>
<th>P</th>
<th>Q</th>
</tr>
</thead>

<tbody>
<tr>
<td>F</td>
<td>T</td>
</tr>

<tr>
<td>T</td>
<td>F</td>
</tr>

<tr>
<td>T</td>
<td>T</td>
</tr>

<tr>
<td>F</td>
<td>F</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th>P</th>
<th>Q</th>
</tr>
</thead>

<tbody>
<tr>
<td>T</td>
<td>T</td>
</tr>

<tr>
<td>T</td>
<td>F</td>
</tr>

<tr>
<td>F</td>
<td>T</td>
</tr>

<tr>
<td>F</td>
<td>F</td>
</tr>
</tbody>
</table>



</div>



<p>This makes it easier to read the table. If you know your inputs and are looking for the output, you can binary search the values.</p>

<p>Values should all be sorted the same way. If one column places T before F, other columns shouldn’t place F before T. I strongly prefer to sort with T first.</p>

<h3 id="column-ordering">Column Ordering</h3>

<p>The order of the columns should match the order someone would naturally reason through the decision. If you’re making the table for a login flow, you might have conditions for <code>valid_user?</code> and <code>correct_password?</code>. Since it doesn’t make sense to talk about the password before you have the user, most people would think about finding the user first. The column for that condition should appear before the password column.</p>

<p>A lesser consideration is handling <code>Any</code> fields (see below). Columns with <code>-</code> values matter less in the table and should be placed later.</p>

<div>
  <p><strong>BAD</strong></p>

<p><strong>GOOD</strong></p>

<table>
<thead>
<tr>
<th>P</th>
<th>Q</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>-</code></td>
<td>T</td>
</tr>

<tr>
<td>T</td>
<td>F</td>
</tr>

<tr>
<td>F</td>
<td>F</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th>Q</th>
<th>P</th>
</tr>
</thead>

<tbody>
<tr>
<td>T</td>
<td>-</td>
</tr>

<tr>
<td>F</td>
<td>T</td>
</tr>

<tr>
<td>F</td>
<td>F</td>
</tr>
</tbody>
</table>



</div>



<p>I don’t think the <code>-</code> rule is as aesthetically valuable as the “most important columns first” rule, and neither rule is as important as the row rule.</p>



<p>If one of your fields isn’t a boolean, explicitly enumerate the possibilities. It might be implicitly defined in the table, but that’s too easy to confuse.</p>

<table>
<thead>
<tr>
<th>P</th>
<th>Q</th>
</tr>
</thead>

<tbody>
<tr>
<td>T</td>
<td>-</td>
</tr>

<tr>
<td>F</td>
<td>red</td>
</tr>

<tr>
<td>F</td>
<td>blue</td>
</tr>
</tbody>
</table>

<p>Is this table complete? We don’t know. It could be missing the row <code>|F, Yellow|</code>! The legend doesn’t have to be part of the table itself, as long as the reader can infer it from the surrounding context.  Let the reader know that Q can have values <code>{red, blue}</code>.</p>

<h2 id="techniques">Techniques</h2>

<p>The most common problem with decision tables is bloat: if you have five boolean columns, your table will have 32 rows. Add a sixth and then you’re at 64. Most techniques are about reducing bloat, such as by compressing rows or decomposing tables.</p>

<h3 id="any">Any/-</h3>

<p>Pretty much everybody does this. <code>-</code> means “for any value”. These two tables are equivalent:</p>

<div>
  <table>
<thead>
<tr>
<th>P</th>
<th>Q</th>
<th>O</th>
</tr>
</thead>

<tbody>
<tr>
<td>T</td>
<td>T</td>
<td>1</td>
</tr>

<tr>
<td>T</td>
<td>F</td>
<td>1</td>
</tr>

<tr>
<td>F</td>
<td>T</td>
<td>2</td>
</tr>

<tr>
<td>F</td>
<td>F</td>
<td>3</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th>P</th>
<th>Q</th>
<th>O</th>
</tr>
</thead>

<tbody>
<tr>
<td>T</td>
<td>-</td>
<td>1</td>
</tr>

<tr>
<td>F</td>
<td>T</td>
<td>2</td>
</tr>

<tr>
<td>F</td>
<td>F</td>
<td>3</td>
</tr>
</tbody>
</table>



</div>



<p><code>-</code> is great for simplifying tables. It’s easy to check for completeness, as you can map the compact version to the full version. If a table consists of four booleans, then <code>|T - - -|</code> maps to 8 rows. </p>

<p>Aesthetically it looks more pleasant when values don’t follow <code>-</code>. <code>|T - - F|</code> just looks funny. Sometimes I shuffle around the columns to make the dashes line up. This isn’t always possible, though, and it might obscure the natural flow of the rules.</p>

<p>There’s a couple pitfalls to <code>-</code>. First, you can accidentally be unsound, as each <code>-</code> expands to several rows. For example:</p>

<table>
<thead>
<tr>
<th>P</th>
<th>Q</th>
<th>O</th>
</tr>
</thead>

<tbody>
<tr>
<td>T</td>
<td><code>-</code></td>
<td>1</td>
</tr>

<tr>
<td><code>-</code></td>
<td>T</td>
<td>2</td>
</tr>

<tr>
<td>F</td>
<td>F</td>
<td>3</td>
</tr>
</tbody>
</table>

<p>This is complete but unsound, as <code>|T T|</code> maps to both 1 and 2. The other pitfall is implicit ordering. We might have</p>

<table>
<thead>
<tr>
<th>P</th>
<th>O</th>
</tr>
</thead>

<tbody>
<tr>
<td>A</td>
<td>T</td>
</tr>

<tr>
<td>B</td>
<td>F</td>
</tr>

<tr>
<td>C</td>
<td>F</td>
</tr>
</tbody>
</table>

<p>It’s tempting to write this as</p>

<table>
<thead>
<tr>
<th>P</th>
<th>O</th>
</tr>
</thead>

<tbody>
<tr>
<td>A</td>
<td>T</td>
</tr>

<tr>
<td><code>-</code></td>
<td>F</td>
</tr>
</tbody>
</table>

<p>Now the order of the rows matters! Someone can figure out what you mean here, but now it’s no longer explicit. Prefer to list things out here.</p>

<p>Notation note: <code>-</code> usually means “any”, but that’s not always clear. It’s easy to think the symbol means “unknown” or “n/a”. If you have concerns then prefer to be explicit. You should probably use a different symbol if you’re using <code>+</code> as a value.</p>

<h4 id="input-elimination">Input Elimination</h4>

<p>Often by using <code>-</code> we find that a column is unnecessary. Given the table</p>

<table>
<thead>
<tr>
<th>P</th>
<th>Q</th>
<th>O</th>
</tr>
</thead>

<tbody>
<tr>
<td>T</td>
<td>T</td>
<td>1</td>
</tr>

<tr>
<td>T</td>
<td>F</td>
<td>1</td>
</tr>

<tr>
<td>F</td>
<td>T</td>
<td>2</td>
</tr>

<tr>
<td>F</td>
<td>F</td>
<td>2</td>
</tr>
</tbody>
</table>

<p>We can simplify this as</p>

<div>
  <p><code>Simplify</code></p>

<p><code>Drop Q</code></p>

<table>
<thead>
<tr>
<th>P</th>
<th>Q</th>
<th>O</th>
</tr>
</thead>

<tbody>
<tr>
<td>T</td>
<td>-</td>
<td>1</td>
</tr>

<tr>
<td>F</td>
<td>-</td>
<td>2</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th>P</th>
<th>O</th>
</tr>
</thead>

<tbody>
<tr>
<td>T</td>
<td>1</td>
</tr>

<tr>
<td>F</td>
<td>2</td>
</tr>
</tbody>
</table>



</div>



<p>In this way decision tables can help us determine if some inputs are unnecessary for our logic.</p>

<h3 id="table-decomposition">Table Decomposition</h3>

<p>An output is <strong>dependent</strong> on an input if that input plays “some role” on that output. Not all outputs may be dependent on all inputs.</p>

<table>
<thead>
<tr>
<th>P</th>
<th>Q</th>
<th>O1</th>
<th>O2</th>
</tr>
</thead>

<tbody>
<tr>
<td>T</td>
<td>T</td>
<td>F</td>
<td>T</td>
</tr>

<tr>
<td>T</td>
<td>F</td>
<td>F</td>
<td>F</td>
</tr>

<tr>
<td>F</td>
<td>T</td>
<td>T</td>
<td>T</td>
</tr>

<tr>
<td>F</td>
<td>F</td>
<td>T</td>
<td>F</td>
</tr>
</tbody>
</table>

<p>O1 only depends on P and O2 only depends on Q. We can decompose this table into two smaller ones:</p>

<div>
  <table>
<thead>
<tr>
<th>P</th>
<th>O1</th>
</tr>
</thead>

<tbody>
<tr>
<td>T</td>
<td>F</td>
</tr>

<tr>
<td>F</td>
<td>T</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th>Q</th>
<th>O2</th>
</tr>
</thead>

<tbody>
<tr>
<td>T</td>
<td>T</td>
</tr>

<tr>
<td>F</td>
<td>F</td>
</tr>
</tbody>
</table>

</div>



<p>Decomposing tables makes them simpler but isn’t always the right choice. If O1 and O2 are conceptually related, this might things less clear to the reader. Nor does decomposing always reduce the size of your table. An outcome might be dependent on one value while the other might be dependent on both.</p>

<table>
<thead>
<tr>
<th>P</th>
<th>Q</th>
<th>O1</th>
<th>O2</th>
</tr>
</thead>

<tbody>
<tr>
<td>T</td>
<td>T</td>
<td>T</td>
<td>T</td>
</tr>

<tr>
<td>T</td>
<td>F</td>
<td>T</td>
<td>F</td>
</tr>

<tr>
<td>F</td>
<td>T</td>
<td>T</td>
<td>T</td>
</tr>

<tr>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
</tr>
</tbody>
</table>

<p>Decomposing this table would give you two tables with a total of six rows. On the other hand, if O1 and O2 are totally conceptually distinct it might be clearer to break them into separate tables. As always, what’s best is highly context-dependent.</p>

<h3 id="input-dependence">Input Dependence</h3>

<p>Inputs are dependent if one can restrict the values of another. Take the following three business rules:</p>

<ol>
<li>If a form doesn’t exist, redirect them to the “start” page.</li>
<li>If the form exists and hasn’t been submitted, redirect to “continue”.</li>
<li>If the form exists and has been submitted, redirect to “review”.</li>
</ol>

<p>We could write this as two booleans: <code>form_exists?</code> and <code>submitted?</code>. Submitted is only a meaningful boolean if the form already exists. We can instead fold these two booleans into a single column, such as <code>form_status</code>:</p>

<table>
<thead>
<tr>
<th><code>form_status</code></th>
<th>O</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>not_started</code></td>
<td>“start”</td>
</tr>

<tr>
<td><code>incomplete</code></td>
<td>“continue”</td>
</tr>

<tr>
<td><code>submitted</code></td>
<td>“review”</td>
</tr>
</tbody>
</table>

<p>This breaks down for larger tables. Consider a login table with three values: <code>password_correct?</code>, <code>2auth_enabled?</code>, and <code>2auth_correct?</code>. Whether or not you have 2auth is irrelevant if you don’t know the password, and asking if you passed the 2auth is nonsensical if you have it disabled. There’s a few different ways to model this, all awkward. The simplest is probably to use another symbol, like <code>/</code>, to tell the reader that it’s impossible:</p>

<table>
<thead>
<tr>
<th><code>password-correct?</code></th>
<th><code>2auth-enabled?</code></th>
<th><code>2auth-correct?</code></th>
<th>O</th>
</tr>
</thead>

<tbody>
<tr>
<td>T</td>
<td>T</td>
<td>T</td>
<td>4</td>
</tr>

<tr>
<td>T</td>
<td>T</td>
<td>F</td>
<td>3</td>
</tr>

<tr>
<td>T</td>
<td>F</td>
<td>/</td>
<td>2</td>
</tr>

<tr>
<td>F</td>
<td>-</td>
<td>/</td>
<td>1</td>
</tr>
</tbody>
</table>

<p>If you’d prefer to not introduce a new symbol and turn your booleans into trileans then another alternative is to use <code>any</code>. This is a little deceptive, as it implies the column <em>has</em> a value, we just don’t care what it is. It works but make logicians very sad.</p>

<h4 id="pitfalls">Pitfalls</h4>

<p>When handling dependent inputs, it matters whether the dependence is a <strong>fact</strong> or if it’s an <strong>assertion</strong>. A fact is something that <em>cannot possibly</em> be false. If we run into a case where it is false, then a software bug is the least of our worries. This most often happens when the conditions are incompatible and only one of them can be true. In this case, we can fold the columns into an enumeration.</p>

<table>
<thead>
<tr>
<th><code>thread1_lock?</code></th>
<th><code>thread2_lock?</code></th>
<th>O</th>
</tr>
</thead>

<tbody>
<tr>
<td>T</td>
<td>F</td>
<td>1</td>
</tr>

<tr>
<td>F</td>
<td>T</td>
<td>2</td>
</tr>

<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th><code>lock_held_by</code></th>
<th>O</th>
</tr>
</thead>

<tbody>
<tr>
<td>None</td>
<td>1</td>
</tr>

<tr>
<td>Thread 1</td>
<td>2</td>
</tr>

<tr>
<td>Thread 2</td>
<td>3</td>
</tr>
</tbody>
</table>

<p>An assertion, by contrast, is something we build the system to guarantee. It can, in reality, be false, but ideally it’s never false in our system.</p>

<p>Ideally is a dangerous word. In this case I’d want to be clear that the odd combination is not something that <em>can’t possibly</em> happen, it’s something that <em>shouldn’t</em> happen. That means if it <em>does</em> happen, there’s something wrong and we should stop and figure that out. Perhaps we wrote our own locking mechanism and aren’t completely sure it’s correct, maybe we’re worried about cosmic rays, whatever. These possibilities should be explicitly enumerated, and the output should be clearly marked as unspecified or an error.</p>

<table>
<thead>
<tr>
<th><code>thread1_lock?</code></th>
<th><code>thread2_lock?</code></th>
<th>O</th>
</tr>
</thead>

<tbody>
<tr>
<td>T</td>
<td>T</td>
<td><strong>???</strong></td>
</tr>

<tr>
<td>F</td>
<td>F</td>
<td><strong>error</strong></td>
</tr>

<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>

<p>The simplest answer here is to redesign your system to handle it, but that might not be feasible.</p>

<h3 id="subtables">Subtables</h3>

<p>If many inputs or outputs are dependent on a single input, it makes sense to break this into a separate table. The two tables should refer to each other. See for example <a href="https://help.sap.com/viewer/2754875d2d2a403f95e58a41a9c7d6de/1911/en-US/2bccc3ed722d1014a688d77c71096543.html">here</a>. I’ve struggled to find a good teaching example so am only mentioning this for completeness.</p>

<h2 id="more-difficult-situations">More difficult situations</h2>

<h3 id="independent-intervals">Independent Intervals</h3>

<p>When working with intervals we run into a problem where different conditions may depend on distinct partitions of the interval into ranges.</p>

<table>
<thead>
<tr>
<th>P</th>
<th>Q</th>
<th>O</th>
</tr>
</thead>

<tbody>
<tr>
<td>T</td>
<td><code>[0, 2]</code></td>
<td>1</td>
</tr>

<tr>
<td>T</td>
<td><code>(2, 10]</code></td>
<td>2</td>
</tr>

<tr>
<td>F</td>
<td><code>[0, 4)</code></td>
<td>3</td>
</tr>

<tr>
<td>F</td>
<td><code>[4, 10]</code></td>
<td>4</td>
</tr>
</tbody>
</table>

<p>This is especially common when working with date intervals, as we saw with the <a href="https://www.hillelwayne.com/requirements/">Rose Kata</a>. The problem is ensuring completeness. If we have two separate sets of interval covers, we lose our direct mapping between the possible values and the total number of rows. It’s also easy to accidentally miss something.</p>

<p>A thorough-but-bloaty solution is to combine all of the intervals into one superset with no overlaps.</p>

<table>
<thead>
<tr>
<th>P</th>
<th>Q</th>
<th>O</th>
</tr>
</thead>

<tbody>
<tr>
<td>T</td>
<td><code>[0, 2]</code></td>
<td>1</td>
</tr>

<tr>
<td>T</td>
<td><code>(2, 4)</code></td>
<td>2</td>
</tr>

<tr>
<td>T</td>
<td><code>[4, 10]</code></td>
<td>2</td>
</tr>

<tr>
<td>F</td>
<td><code>[0, 2]</code></td>
<td>3</td>
</tr>

<tr>
<td>F</td>
<td><code>(2, 4)</code></td>
<td>3</td>
</tr>

<tr>
<td>F</td>
<td><code>[4, 10]</code></td>
<td>4</td>
</tr>
</tbody>
</table>

<p>This makes the table more formalized at the cost of bloat and concealing the underlying logic. You also need to watch for mistakes in translating to the new partitions, especially at the boundaries of intervals.</p>

<h3 id="state">State</h3>

<p>Really you should be using transition tables or state machines to formalize state, but we can handle small problems with decision tables. If we want a decision table to represent a mutation, we need to make explicit the difference between the old and new values on the table. The convention is write the variable with a prime. If the table mutates <code>x</code>, we write the original value as <code>x</code> and the new value as <code>x&#39;</code>.</p>

<table>
<thead>
<tr>
<th><code>x % 2 == 0</code></th>
<th><code>x&#39;</code></th>
</tr>
</thead>

<tbody>
<tr>
<td>T</td>
<td><code>x/2</code></td>
</tr>

<tr>
<td>F</td>
<td><code>3x+1</code></td>
</tr>
</tbody>
</table>

<p>Each table should only model one step. In the body of the table, <code>x</code> always refers to the old value and <code>x&#39;</code> should not appear at all. Multiple outputs can depend on <code>x</code>, though, making this useful for representing simultaneous mutations:</p>

<table>
<thead>
<tr>
<th>P</th>
<th><code>x&#39;</code></th>
<th><code>y&#39;</code></th>
</tr>
</thead>

<tbody>
<tr>
<td>T</td>
<td><code>x+y</code></td>
<td><code>x</code></td>
</tr>

<tr>
<td>F</td>
<td><code>x</code></td>
<td><code>x-y</code></td>
</tr>
</tbody>
</table>

<p>If we need to represent a more complex update, we can break it down into one table that defines <code>x&#39;</code> and one that defines <code>x&#39;&#39;</code>:</p>

<table>
<thead>
<tr>
<th><code>x&#39;</code></th>
<th><code>x&#39;&#39;</code></th>
</tr>
</thead>

<tbody>
<tr>
<td><code>(, 0]</code></td>
<td>0</td>
</tr>

<tr>
<td><code>[1, 50]</code></td>
<td><code>x&#39;</code></td>
</tr>

<tr>
<td><code>[51, )</code></td>
<td>50</td>
</tr>
</tbody>
</table>

<p>Representing state in decision tables gets awkward quickly and it doesn’t quite scale to complex state.</p>

<h4 id="more-complex-state">More Complex State</h4>

<p>Make a damn state machine</p>

<h3 id="when-you-re-going-too-far">When you’re going too far</h3>

<p>Decision tables have minimal syntax and semantics. They are easy to use. They also quickly hit limits.</p>

<p>I don’t like saying “don’t use them when they’re inappropriate”, because that sounds like smug avoidance to me. That answer doesn’t give you any insight into when they are inappropriate. We want to be specific about when they become inappropriate.</p>

<p>Decision tables work best when the entire problem can be modeled as discrete, independent inputs. Break that and everything falls apart. Sometimes you can refine the problem space like we did with intervals, but that only gets you so far. Other signs that decision tables are inappropriate include:</p>

<ul>
<li>When you have complex data structures. If one of the inputs is a list of integers, your table is going to be huge.</li>
<li>When the decision is made “over time”, where you have to perform some effects in order to complete the decision. DTs model instantaneous decisions. Consider a flowchart instead.</li>
<li>When there’s no easy way to encode your data in a way that the table is “obviously” complete. If your input is “three events with a ranking”, a complete table will still look like it is missing rows.</li>
<li>When the table gets extremely large.</li>
<li>When a table layout doesn’t make anything clearer.</li>
</ul>

<h2 id="shortcuts">Shortcuts</h2>

<p>How strict you need to be about your decision tables depends on what you’re using them for. If your goal is to have a specification artifact then you want to be as rigorous as possible. You want to be strict if you’re trying to explicitly shakeout design issues or plan to high-level project-level decisions based on the table. If you’re using the decision table as a mental augmentation tool, then taking shortcuts is fine. The goal is to help you think better and excessive formalism doesn’t always lead to insight.</p>

<h2 id="final-thoughts">Final Thoughts</h2>

<p>Decision tables are easy, simple, and powerful. You can teach them in five minutes and write one in half that time. And while they have a low expressiveness ceiling, there’s no opportunity cost to trying them first. Worst case is you lose a few minutes before realizing they’re inappropriate for your problem.</p>

<p>If you want to see decision tables used in the wild, two good examples are <a href="https://github.com/rails/rails/pull/36795#issuecomment-515914165">here</a> and <a href="https://twitter.com/jesterxl/status/1222728288117972992">here</a>.</p>

<p>I hope this made decision tables more accessible to you. If you’re interested in my other writing, in addition to this site I have a twice-weekly <a href="https://buttondown.email/hillelwayne/">newsletter</a> on software and a <a href="https://twitter.com/hillelogram">Twitter</a> that’s a mix of tech, math, confectioning, and general Twitter inanery.</p>

<p><em>Thanks to <a href="https://nrinaudo.github.io/">Nicolas Rinaudo</a> for feedback.</em></p>


</div>

    



  </article></div>
  </body>
</html>
