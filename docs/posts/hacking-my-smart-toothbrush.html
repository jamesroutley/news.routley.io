<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kuenzi.dev/toothbrush/">Original</a>
    <h1>Hacking my “smart” toothbrush</h1>
    
    <div id="readability-page-1" class="page"><div>
      
        <header>
          
          

  <p>
    

    

    
      
      

      <span>
        <i aria-hidden="true"></i>
        
          6 minute read
        
      </span>
    
  </p>


        </header>
      

      <section itemprop="text">
        
        <p>After buying a new <a href="https://www.philips.ch/c-p/HX6851_53/sonicare-protectiveclean-5100-elektrische-schallzahnbuerste">Philips Sonicare</a> toothbrush I was surprised to see that it reacts to the insertion of a brush head by blinking an LED. 
A quick online search reveals that the head communicates with the toothbrush handle to remind you when it’s time to buy a new one.</p>
<p><img src="https://kuenzi.dev/assets/images/toothbrush/smart.png" alt="0"/></p>

<h2 id="reverse-engineering">Reverse Engineering</h2>

<p>Looking at the base of the head shows that it contains an antenna and a tiny black box that is presumably an IC.
The next hint can be found in the manual where it says that: “Radio Equipment in this product operates at 13.56 MHz”, which would indicate that it is an <a href="https://en.wikipedia.org/wiki/Near-field_communication">NFC tag</a>. 
And indeed when holding the brush head to my phone it opens a link to a product page: <a href="https://www.usa.philips.com/c-m-pe/toothbrush-heads">https://www.usa.philips.com/c-m-pe/toothbrush-heads</a>.</p>

<figure>
  
    
      <a href="https://kuenzi.dev/assets/images/toothbrush/brush_head.jpg" title="Brush head">
          <img src="https://kuenzi.dev/assets/images/toothbrush/brush_head.jpg" alt="Brush head"/>
      </a>
    
  
    
      <a href="https://kuenzi.dev/assets/images/toothbrush/nfc_chip.jpg" title="Antenna">
          <img src="https://kuenzi.dev/assets/images/toothbrush/nfc_chip.jpg" alt="Antenna"/>
      </a>
    
  
  
    <figcaption>
</figcaption>
  
</figure>

<p>Using the <a href="https://play.google.com/store/apps/details?id=com.wakdev.nfctools.pro">NFC Tools</a> app we can learn a lot about this tag:</p>

<p><img src="https://kuenzi.dev/assets/images/toothbrush/nfc_info.png" alt="" width="50%"/></p>

<ul>
  <li>It is an <a href="https://www.nxp.com/products/rfid-nfc/nfc-hf/ntag-for-tags-labels/ntag-213-215-216-nfc-forum-type-2-tag-compliant-ic-with-144-504-888-bytes-user-memory:NTAG213_215_216">NTAG213</a></li>
  <li>It uses NfcA</li>
  <li>It is password protected</li>
  <li>We can see the link to the Philips webpage</li>
</ul>

<p>Also using NFC Tools, the memory and memory access conditions can be read:</p>

<table>
  <thead>
    <tr>
      <th>Address</th>
      <th>Data</th>
      <th>Type</th>
      <th>Access</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0x00</td>
      <td>04:EC:FC:9C</td>
      <td>UID0-UID2/BCC0</td>
      <td>Read-Only</td>
    </tr>
    <tr>
      <td>0x01</td>
      <td>A2:94:10:90</td>
      <td>UID3-UDI6</td>
      <td>Read-Only</td>
    </tr>
    <tr>
      <td>0x02</td>
      <td>B6:48:FF:FF</td>
      <td>BCC1/INT./LOCK0-LOCK1</td>
      <td>Read-Only</td>
    </tr>
    <tr>
      <td>0x03</td>
      <td>E1:10:12:00</td>
      <td>OTP0-OTP3</td>
      <td>Read-Only</td>
    </tr>
    <tr>
      <td>0x04</td>
      <td>03:20:D1:01</td>
      <td>DATA</td>
      <td>Read-Only</td>
    </tr>
    <tr>
      <td>0x05</td>
      <td>1C:55:02:70</td>
      <td>DATA</td>
      <td>Read-Only</td>
    </tr>
    <tr>
      <td>0x06</td>
      <td>68:69:6C:69</td>
      <td>DATA</td>
      <td>Read-Only</td>
    </tr>
    <tr>
      <td>0x07</td>
      <td>70:73:2E:63</td>
      <td>DATA</td>
      <td>Read-Only</td>
    </tr>
    <tr>
      <td>0x08</td>
      <td>6F:6D:2F:6E</td>
      <td>DATA</td>
      <td>Read-Only</td>
    </tr>
    <tr>
      <td>0x09</td>
      <td>66:63:62:72</td>
      <td>DATA</td>
      <td>Read-Only</td>
    </tr>
    <tr>
      <td>0x0A</td>
      <td>75:73:68:68</td>
      <td>DATA</td>
      <td>Read-Only</td>
    </tr>
    <tr>
      <td>0x0B</td>
      <td>65:61:64:74</td>
      <td>DATA</td>
      <td>Read-Only</td>
    </tr>
    <tr>
      <td>0x0C</td>
      <td>61:70:FE:00</td>
      <td>DATA</td>
      <td>Read-Only</td>
    </tr>
    <tr>
      <td>0x0D…</td>
      <td>00:00:00:00</td>
      <td>DATA</td>
      <td>Read-Only</td>
    </tr>
    <tr>
      <td>0x1F</td>
      <td>00:01:07:00</td>
      <td>DATA</td>
      <td>Readable, write protected by PW</td>
    </tr>
    <tr>
      <td>0x20</td>
      <td>00:00:00:02</td>
      <td>DATA</td>
      <td>Read-Only</td>
    </tr>
    <tr>
      <td>0x21</td>
      <td>60:54:32:32</td>
      <td>DATA</td>
      <td>Read-Only</td>
    </tr>
    <tr>
      <td>0x22</td>
      <td>31:32:31:34</td>
      <td>DATA</td>
      <td>Read-Only</td>
    </tr>
    <tr>
      <td>0x23</td>
      <td>20:31:32:4B</td>
      <td>DATA</td>
      <td>Read-Only</td>
    </tr>
    <tr>
      <td>0x24</td>
      <td>B3:02:02:00</td>
      <td>DATA</td>
      <td>Readable,write protected by PW</td>
    </tr>
    <tr>
      <td>0x25</td>
      <td>00:00:00:00</td>
      <td>DATA</td>
      <td>Readable,write protected by PW</td>
    </tr>
    <tr>
      <td>0x26</td>
      <td>00:00:00:00</td>
      <td>DATA</td>
      <td>Readable,write protected by PW</td>
    </tr>
    <tr>
      <td>0x27</td>
      <td>00:00:00:01</td>
      <td>DATA</td>
      <td>Readable,write protected by PW</td>
    </tr>
    <tr>
      <td>0x28</td>
      <td>00:03:30:BD</td>
      <td>LOCK2 - LOCK4</td>
      <td>Readable,write protected by PW</td>
    </tr>
    <tr>
      <td>0x29</td>
      <td>04:00:00:10</td>
      <td>CFG 0</td>
      <td>Read-Only</td>
    </tr>
    <tr>
      <td>0x2A</td>
      <td>43:00:00:00</td>
      <td>CFG 1</td>
      <td>Read-Only</td>
    </tr>
    <tr>
      <td>0x2B</td>
      <td>00:00:00:00</td>
      <td>PWD0-PWD3</td>
      <td>Write-Only</td>
    </tr>
    <tr>
      <td>0x2C</td>
      <td>00:00:00:00</td>
      <td>PACK0-PACK1</td>
      <td>Write-Only</td>
    </tr>
  </tbody>
</table>

<p>I repeated this process for one black and two white <a href="https://www.usa.philips.com/c-p/HX6062_65/sonicare-w-diamondclean-standard-sonic-toothbrush-heads">W DiamondClean</a> brush heads and learned the following:</p>
<ul>
  <li>Address 0x00-0x02 contains a unique ID and its checksum</li>
  <li>Address 0x04-0x0C contains the link to the Philips store</li>
  <li>Address 0x22 is 31:32:31:34 for black and 31:31:31:31 for white heads respectively</li>
  <li>Address 0x24 contains the <strong>total brush time</strong></li>
  <li>All other readable data is identical between all heads</li>
</ul>

<h3 id="decoding-the-stored-time">Decoding the stored time</h3>
<p>Let’s do an experiment to see what changes happen to the tag when using the toothbrush:</p>
<ol>
  <li>Read the tag
    <ul>
      <li>When reading a new brush head that has never been in contact with the data at addr. 0x24 is 00:00:02:00.</li>
      <li>Simply attaching it to the handle (without brushing) changes nothing</li>
    </ul>
  </li>
  <li>Brush for some time
    <ul>
      <li>In this case, I let the toothbrush run for 5s</li>
    </ul>
  </li>
  <li>Read the tag again
    <ul>
      <li>The data at addr. 0x24 is now 05:00:02:00</li>
    </ul>
  </li>
  <li>Observe the difference
    <ul>
      <li>Looks like addr. 0x24 saves the number of seconds that the brush head was in use</li>
    </ul>
  </li>
</ol>

<p>When the brush is used for more than 255s, this timer rolls over to the second bit (02:01:02:00 -&gt; 258s).</p>

<p>Trying to overwrite the stored time is unfortunately unsuccessful, as this memory address is password protected.</p>

<h2 id="sniffing-the-password">Sniffing the password</h2>
<p>Luckily it turns out that the required password is sent over plain text! So all I need to do is to sniff the communication between the toothbrush and the head.
After digging out my <a href="https://greatscottgadgets.com/hackrf/">HackRF</a> <a href="https://en.wikipedia.org/wiki/Software-defined_radio">software defined radio</a> and some trial and error, I came up with the following workflow.</p>

<h3 id="record-rf-signal">Record RF signal</h3>
<p><img src="https://kuenzi.dev/assets/images/toothbrush/sniffing_in_progress.jpg" alt="" width="100%"/></p>

<p>When opening <a href="https://gqrx.dk/">gqrx</a> and tuning it to 13.736 MHz while holding the toothbrush close to the antenna, it is visible that the head gets polled multiple times a second. It is a welcome surprise that my simple monopole antenna gets a signal that is strong enough for this purpose. You can download the relevant gqrx configuration file <a href="https://kuenzi.dev/assets/files/gqrx.conf">here</a>.</p>

<p><img src="https://kuenzi.dev/assets/images/toothbrush/gqrx.png" alt="" width="100%"/></p>

<p>While brushing, the NFC polling takes a brief pause and the first burst of packets that follows updates the time counter. 
With the ability of gqrx to make I/Q recordings, we can capture the password RF signals like this:</p>
<ol>
  <li>Turn on the toothbrush</li>
  <li>Start recording</li>
  <li>Turn off the toothbrush</li>
  <li>Stop the recording</li>
</ol>

<p>The first packets in the file should now contain the password in plain text.</p>

<h3 id="convert-recording">Convert recording</h3>
<p><img src="https://kuenzi.dev/assets/images/toothbrush/gnuradio.png" alt="" width="100%"/></p>

<p>Before this raw I/Q file can be decoded it needs to be converted into a slightly different format to be read by the decoding program.</p>

<h3 id="decode-recording">Decode recording</h3>

<figure>
  
    
      <a href="https://kuenzi.dev/assets/images/toothbrush/nfc_lab.png" title="Decoded traffic">
          <img src="https://kuenzi.dev/assets/images/toothbrush/nfc_lab.png" alt="Decoded traffic"/>
      </a>
    
  
  
</figure>

<p>I found the perfect tool for this task called <a href="https://github.com/josevcm/nfc-laboratory">NFC-laboratory</a>. 
After opening the newly created WAV file, it should look something like the picture above. In this case, the recording is only good enough to see the communication that goes from host to tag (green arrow). But to sniff the password this is perfect.</p>
<ul>
  <li>Line #0-#6: communication is established with the tags’ unique ID</li>
  <li>Line #7: The toothbrush sends the <strong>password</strong> (command 0x1B = PWD_AUTH)</li>
  <li>Line #9: The time counter is updated to the new value (command 0xA2 = WRITE)</li>
  <li>All lines below are repeated polling without password authentication or writing anything</li>
</ul>

<p>So the password for this brush head is <strong>67:B3:8B:98</strong> (underlined in the picture).</p>

<h2 id="writing-to-the-brush">Writing to the brush</h2>
<p>With the password successfully acquired, it’s now possible to set the counter on the brush head to anything we want by sending the relevant bytes over NFC.</p>
<ol>
  <li>Go to Other -&gt; Advanced NFC commands</li>
  <li>Set the I/O Class to NfcA</li>
  <li>Set the data to 1B:67:B3:8B:98,A2:24:00:00:02:00</li>
  <li>Enjoy a factory-new brush head (at least as far as the time counter is concerned)</li>
</ol>

<p>Here is the breakdown of the command in step 3:</p>

<table>
  <thead>
    <tr>
      <th>Command</th>
      <th>Explanation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1B</td>
      <td>PWD_AUTH</td>
    </tr>
    <tr>
      <td>67:B3:8B:98</td>
      <td>The password</td>
    </tr>
    <tr>
      <td>,</td>
      <td>Package delimiter</td>
    </tr>
    <tr>
      <td>A2</td>
      <td>WRITE</td>
    </tr>
    <tr>
      <td>24</td>
      <td>To address 0x24</td>
    </tr>
    <tr>
      <td>00:00:02:00</td>
      <td>Timer set to 0s</td>
    </tr>
  </tbody>
</table>

<p>Below you can see the memory of the brush head before and after the custom NFC commands:</p>

<figure>
  
    
      <a href="https://kuenzi.dev/assets/images/toothbrush/nfc_before.png" title="Before: 10s on timer">
          <img src="https://kuenzi.dev/assets/images/toothbrush/nfc_before.png" alt=""/>
      </a>
    
  
    
      <a href="https://kuenzi.dev/assets/images/toothbrush/nfc_during.png" title="Applying the update">
          <img src="https://kuenzi.dev/assets/images/toothbrush/nfc_during.png" alt=""/>
      </a>
    
  
    
      <a href="https://kuenzi.dev/assets/images/toothbrush/nfc_after.png" title="After: 0s on timer">
          <img src="https://kuenzi.dev/assets/images/toothbrush/nfc_after.png" alt=""/>
      </a>
    
  
  
    <figcaption>Observe how the timer at address 0x24 changes
</figcaption>
  
</figure>

<p>With this, the toothbrush is now <strong>successfully hacked</strong> and we can play around with the timer as we wish.</p>

<p>Here are some interesting observations:</p>
<ul>
  <li>Only the first two bytes at address 0x24 are used for timekeeping.  Once the counter reaches FF:FF:02:00 it stops going up (18 hours of continuous brushing).</li>
  <li>When the stored time is greater than 0x5460 the toothbrush blinks the LED to notify you to change heads. This corresponds to 21’600s -&gt; 180 x 2min -&gt; 3 months of brushing twice a day, which is exactly in line with Philips recommendation to change heads every 3 months.</li>
</ul>



<h3 id="password-verification-protection">Password verification protection</h3>
<p>You might have noticed the color of the brush head changing throughout of this post. This is because I had to run out and buy a new one after getting locked out of the first one.</p>

<h3 id="password-generation">Password generation</h3>
<p>Unfortunately, the password of every brush head is unique and this process of extracting it with an SDR is quite involved and requires special hardware. 
At the bottom of page 30 in the datasheet, NXP recommends generating the password from the 7-byte UID. Below are all the UID - password pairs I obtained from my 3 heads:</p>

<table>
  <thead>
    <tr>
      <th>UID</th>
      <th>Password</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>04:79:CF:7A:89:10:90</td>
      <td>FF:34:CE:4C</td>
    </tr>
    <tr>
      <td>04:EC:FC:A2:94:10:90</td>
      <td>61:F0:A5:0F</td>
    </tr>
    <tr>
      <td>04:D7:29:0A:94:10:90</td>
      <td>67:B3:8B:98</td>
    </tr>
  </tbody>
</table>

<p>All my tries to guess to one-way function for generating the passwords failed. Depending on the care that the Philips engineers took, guessing this function could be almost impossible. 
But if you manage to solve this puzzle, feel free to hit me up with an E-mail.</p>

<!-- Google tag (gtag.js) -->





        
      </section>

      

      

      
  

    </div></div>
  </body>
</html>
