<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kevingal.com/blog/rc4.html">Original</a>
    <h1>Recurse Center, week 4</h1>
    
    <div id="readability-page-1" class="page">
    <header>
        
    </header>


<h3>2024-01-26</h3>
<h3>A weekly log of my activity at the Recurse Center, a 12-week programming retreat.</h3>
<p>Tags: <a href="https://kevingal.com/blog/tag/rc.html">rc</a> </p>
<hr/>
<h3 id="monday-january-22nd">Monday, January 22nd</h3>
<p>Did more work on my pull request for ~sketch~, feels like a disproportionate amount of effort to fix this bug.</p>
<p>Read some <a href="https://github.com/nornagon/jonesforth/blob/master/jonesforth.S">jonesforth</a> and <a href="https://www.forth.com/starting-forth/11-forth-compiler-defining-words/">Starting Forth</a>, trying to understand Forth execution.</p>
<p>My original plan was to write most of my Forth code in a Lisp DSL, like this. </p>


<p>Forth code is then just a list of Lisp symbols!</p>
<p>However, this has various hairy edge cases. Consider the Forth words <code>(</code> or <code>:</code>, neither of which are valid names for Lisp symbols. A possible solution is to expand these into Latin characters with some type of escape character in front of them: <code>^lparen</code> and <code>^colon</code>, for example. The escape character itself would have to be escaped, too, in case the user ever tries to define a word called <code>^lparen</code> -- with escaping, this would become the Lisp symbol <code>^^lparen</code>. And the Forth word <code>^(</code> would become the symbol <code>^^^lparen</code>.</p>
<p>Another edge case to avoid: imagine I gave the symbol <code>|</code> the expanded name <code>^lpar</code>. Then the Forth word <code>|en</code> would expand to <code>^lparen</code>, clashing with the Lisp symbol for <code>(</code>. So the expansions of banned symbols cannot be prefixes of each other. This probably comes up a lot when designing programming languages (string escaping!), so that could be interesting to look into.</p>
<p>I think that solves the problem of weird Forth characters. However, there&#39;s also the problem that Forth words are able to hook into the parsing of the program they&#39;re part of. Famously, comments in Forth are implemented as the words <code>(</code> and <code>)</code>. Here&#39;s how they&#39;re used:</p>
<div><pre><span></span><code><span>:</span><span> </span><span>someword</span><span> </span><span>( this is a Forth comment )</span><span> </span><span>1</span><span> </span><span>1</span><span> </span><span>+</span><span> </span><span>;</span><span></span>
</code></pre></div>

<p>The definition of <code>(</code> is basically: skip text until the next right parenthesis shows up. That wouldn&#39;t work with my &#34;list of symbols&#34; DSL because the symbols will be parsed by the Lisp reader and there will be no input stream of text to speak of.</p>
<p>Another Problem Word is <code>&#34;.</code>, which prints a string to the screen...</p>
<div><pre><span></span><code><span>:</span><span> </span><span>firstprogram</span><span> </span><span>&#34;.</span><span> </span><span>Hello</span><span> </span><span>World</span><span> </span><span>&#34;</span><span> </span><span>;</span><span></span>
</code></pre></div>

<p>...which might be defined in the DSL (with escaping for the <code>&#34;</code> special character) as follows...</p>
<div><pre><span></span><code><span>(</span><span>defword</span><span> </span><span>firstprogram</span><span> </span><span>(</span><span>^quote.</span><span> </span><span>Hello</span><span> </span><span>World</span><span> </span><span>^quote</span><span>))</span><span></span>
</code></pre></div>

<p>But, again, <code>&#34;.</code> needs access to the input stream of text. So, I think the DSL should allow Forth words to be defined as strings...</p>
<div><pre><span></span><code><span>(</span><span>defword</span><span> </span><span>firstprogram</span><span> </span><span>&#34;\&#34;. Hello World \&#34;&#34;</span><span>)</span><span></span>
</code></pre></div>

<p>Anyway, this is all a distraction from the task of actually implementing a Forth. What&#39;s confusing me more is how to map the Forth <a href="https://www.forth.com/starting-forth/9-forth-execution/#Forth_Geography">memory model</a> onto a running Lisp process. Forth seems to assume that it&#39;s operating on a giant contiguous block of memory, and it compiles itself by writing stuff into that memory. That&#39;s fine for assembly language, but I really don&#39;t get how to deal with that in Common Lisp or JavaScript or whatever. The Forth word <code>HERE</code>, for example, points to the address space where the next dictionary entry should be written. What does that mean when the dictionary is a list data structure in JavaScript or Common Lisp or whatever? I think it would be straightforward in C: the dictionary is a big <code>malloc</code>&#39;d block of memory, and we can push onto the stack the actual memory address where the next DictionaryEntry struct should be written.</p>
<p>After some thought (and reading stuff, and pestering Reed), I think I should treat Forth memory as a giant array and write the dictionary (as well as text input and everything else) directly into it as bytes!</p>
<p>My brain was mush from all the reading and thinking, so I finished the day by doing &#34;mindless&#34; coding: turning my <code>vec2</code> implementation into <code>vec</code>, for whenever I need to do physics or graphics stuff in more than 2 dimensions.</p>
<h3 id="tuesday-january-23rd">Tuesday, January 23rd</h3>
<p>I spent a lot of time working on ~sketch~ today (now using &#34;~&#34; to demarcate when I&#39;m talking about the Common Lisp graphics library called &#34;sketch&#34;). First, refactoring my pull request according to Gleefre&#39;s (one of my co-developers) feedback. Then testing a fix that Gleefre finished for drawing polygons. Then brainstorming various possible features and documenting them as issues in the repository. My testing did result in a kinda cool animation (<strong>EPILEPSY ALERT!</strong>):</p>
<figure>
<video width="100" height="100" controls="">
    <source src="/static/video/recurse/polygons.mp4" type="video/mp4"/>
</video>
<figcaption>Drawing a random polygon with 10 vertices, many many times per second.</figcaption>
</figure>

<p>Since then I&#39;ve been catching up on my blogging and thinking a lot about how to implement a Forth interpreter (most of the brainstorming got dumped into DMs with Reed and into Monday&#39;s entry).</p>
<p>I haven&#39;t been participating so much in social activities at RC! Partly because my projects don&#39;t currently overlap with most of the groups, and partly because I&#39;m feeling a little low on social energy to be pairing / chatting with people. Trying not to be too hard on myself over this.</p>
<h3 id="wednesday-january-24th">Wednesday, January 24th</h3>
<p>Had a nice call with David about programming and BitTorrent stuff.</p>
<p>The rest of the day was consumed by Creative Coding, where the prompt was &#34;Impossible objects (undecided geometry)&#34;. I took the opportunity to draw some trees based on Coding Train videos: recursion trees, object trees (with leaves! üçÉ), and L-system trees.</p>
<figure>
<img src="https://kevingal.com/static/img/recurse/recursive-tree.png" alt="A recursive tree."/>
<img src="https://kevingal.com/static/img/recurse/leaves-again.png" alt="An object-oriented tree."/>
<img src="https://kevingal.com/static/img/recurse/lsystem-tree.png" alt="An L-system tree."/>
<figcaption>Trees!</figcaption>
</figure>

<p>The code is <a href="https://github.com/Kevinpgalligan/sketches/blob/master/src/thesketches/trees.lisp">here</a>. There&#39;s a memory fault after more than 6 iterations of the L-system, with no backtrace. I think it allocates too much memory because the strings grow surprisingly quickly -- if my napkin calculations are correct, ~1GB after 7 iterations. The solution may be to do depth-first expansion of the rules, rather than breadth-first, so that no string allocation is necessary. (Although, it sounds like it would take forever to iterate through 1 billion symbols, so it may be impractical to go beyond a depth of 6 for this L-system, anyway).</p>
<p>When I get that working, I may as well test out all the L-systems on the <a href="https://en.wikipedia.org/wiki/L-system">Wiki page</a>, since the rules can be copy/pasted once you have an L-system implementation.</p>
<div><pre><span></span><code><span>(</span><span>def-lsystem</span><span> </span><span>tree</span><span></span>
<span>    </span><span>((</span><span>#\F</span><span> </span><span>&#34;FF+[+F-F-F]-[-F+F+F]&#34;</span><span>)))</span><span></span>
<span>(</span><span>evaluate-lsystem</span><span> </span><span>&#39;tree</span><span> </span><span>:axiom</span><span> </span><span>&#34;F&#34;</span><span>)</span><span></span>
</code></pre></div>

<h3 id="thursday-january-25th">Thursday, January 25th</h3>
<p>Read through a paper on the <a href="https://en.wikipedia.org/wiki/Paxos_(computer_science)">Paxos algorithm</a>  with Chris, courtesy of the Pairing Bot. The paper was surprisingly entertaining! It&#39;s an algorithm for reaching consensus among distributed processes, but the author framed it as &#34;priests&#34; voting in a &#34;legislature&#34; on the island of Paxos.</p>
<p>Spent some time on my generative trees (see above).</p>
<p>Returned to the BitTorrent client! It feels less intimidating now that I&#39;ve broken the project into smaller pieces. After skimming <a href="https://blog.jse.li/posts/torrent/">this article</a> shared with me by David, I&#39;ve kinda changed my mind about how to handle multi-threading in the client. I&#39;m leaning towards doing all thread-to-thread communication using queues, because it seems easier to reason about than sharing a big data structure with a lock on it.</p>
<p>Today&#39;s main coding task was to write a buffer / parser for peer-to-peer messages (network bytes in, messages out). Almost at the point of writing unit tests for it. Other small tasks I&#39;ve identified:</p>
<ul>
<li>A data structure to accumulate the blocks that form pieces, before they&#39;re stitched together.</li>
<li>Validating the SHA1 hash of completed pieces.</li>
<li>Writing pieces to the appropriate file on disk.</li>
<li>Implement the bitmask for tracking which pieces have been downloaded.</li>
<li>Make a flowchart for the lifecycle of the threads that talk to peers.</li>
</ul>
<p>I ended the day by attending the weekly presentations. They were all amazing, but particular highlights were: Tristan&#39;s singing computer (using a one-tone beeper to play music by beeping it at different frequencies), Jacob&#39;s custom MIDI device, and Julie&#39;s AI fishtank TV show (object and collision detection + a fish tank + games for the fish to unknowingly play = an automated version of an Adult Swim comedy show). I find myself getting very excited about music-related projects, so I should probably launch into music programming when my current projects are wrapped up.</p>
<h3 id="friday-january-26th">Friday, January 26th</h3>
<p>Inspired by Isaac, I went for a walk before doing any programming today. Also kicked off MemTest86 tests on my desktop, since it has suffered from intermittent freezes ever since I built it. If that doesn&#39;t turn up anything, I guess I&#39;ll open it up and make sure all the components are properly secured. Couldn&#39;t hurt to update Linux Mint, either.</p>
<p>I finished my goal of implementing a message buffer interface for the BitTorrent client! It accumulates bytes from network packets, parses any peer-to-peer messages in that stream of bytes, and spits those messages back out! Also wrote a bunch of unit tests, which reminded me of my old job -- we had to write a lot of unit tests! In the process, I discovered that Common Lisp has built-in support for bitmasks, so I won&#39;t need to implement them myself.</p>
<div><pre><span></span><code><span>;; A bit vector of 7 bits!</span><span></span>
<span>(</span><span>defparameter</span><span> </span><span>*bs*</span><span> </span><span>(</span><span>make-array</span><span> </span><span>7</span><span> </span><span>:element-type</span><span> </span><span>&#39;bit</span><span>))</span><span></span>
<span>(</span><span>bit-and</span><span> </span><span>*bs*</span><span> </span><span>#*1111000</span><span> </span><span>t</span><span>)</span><span> </span><span>; make the last 3 bits 0!</span><span></span>
</code></pre></div>

<p>I did remember another task I&#39;ll have to take on: serialising peer-to-peer messages for network transmission. I&#39;m sure there&#39;s a library I could&#39;ve used for defining the serialisation format rather than manually writing code to do the serialising AND deserialising. Oh well, it was nice to make some progress today.</p>
<p>Besides that, I did a Forth deep dive with Reed, trying to figure out the execution model of Forth and how to model it in a higher-level language. He also shared some neat Emacs tips with me (&#34;use Doom&#34;).</p>
<p>Plan for next week:</p>
<ul>
<li>More gradual progress on BitTorrent.</li>
<li>Get to a point where I can actually start writing code for the Forth interpreter.</li>
<li>Some generative art / ~sketch~ stuff.</li>
</ul>
<hr/>
<ul>
<li><a href="https://kevingal.com/blog.html">Back to blog</a></li>
<li><a href="https://kevingal.com/feed.xml">RSS feed</a></li>
</ul>
<p>I&#39;d be happy to hear from you at <i>galligankevinp@gmail.com</i>.</p>


</div>
  </body>
</html>
