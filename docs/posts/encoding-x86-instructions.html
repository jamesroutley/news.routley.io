<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www-user.tu-chemnitz.de/~heha/hs/chm/x86.chm/x86.htm">Original</a>
    <h1>Encoding x86 Instructions</h1>
    
    <div id="readability-page-1" class="page">﻿

<title>Encoding Real x86 Instructions</title>


Source: CIS-77 Home
<a href="http://www.c-jump.com/CIS77/CIS77syllabus.htm">
<tt>http://www.c-jump.com/CIS77/CIS77syllabus.htm</tt></a> 



<ul>
  <li>It is time to take a look that the actual machine instruction format of the 
  x86 CPU family.
  </li><li>They don&#39;t call the x86 CPU a Complex Instruction Set Computer (CISC) for 
  nothing!
  </li><li>Although more complex instruction encodings exist, no one is going to 
  challenge that the x86 has a complex instruction encoding!
</li></ul>

<h2 id="1">1. x86 Instructions Overview</h2>

<div><p>
 x86 Instruction Encoding:
 </p><p><img alt="x86 Instruction Encoding" src="https://www.bryanbraun.com/2025/10/28/SolidGoldMagikarp/x86_instruction_encoding.png"/> 
</p></div>

Although the diagram seems to imply that instructions can be up to 16 
bytes long, in actuality the x86 will not allow instructions greater 
than 15 bytes in length.<p>

The prefix bytes <strong>are not</strong> the <em>opcode expansion 
prefix</em> discussed earlier - they are special bytes to modify the 
behavior of existing instructions.

</p><h2 id="2">2. x86 Instruction Format Reference</h2>

<div><p>
 Another view of the x86 instruction format:
 </p><p><img alt="The x86 instruction format" src="https://www.bryanbraun.com/2025/10/28/SolidGoldMagikarp/x86_instruction_format.png"/>
</p></div>

Additional reference:
<ul>
  <li>Intel x86 <a href="http://www.c-jump.com/CIS77/reference/Instructions_by_Opcode.html">instructions by opcode</a>
  </li><li>Intel x86 <a href="http://www.c-jump.com/CIS77/reference/Instructions_by_Mnemonic.html">instructions by mnemonic</a>
  </li><li>Brief Intel x86 instruction <a href="http://www.c-jump.com/CIS77/reference/ISA/index.html">reference.</a>
</li></ul>

<h2 id="3">3. x86 Opcode Sizes</h2>

The x86 CPU supports two basic opcode sizes:
<ol>
  <li>standard <strong>one</strong>-byte opcode
  </li><li><strong>two</strong>-byte opcode consisting of a 
  <strong>0Fh</strong> <em>opcode expansion prefix byte</em>.
  </li></ol>

<ul>
  <li>The x86 opcode bytes are 8-bit equivalents of <strong>iii</strong> field 
  that we discussed in simplified encoding.
  </li><li>This provides for up to 512 different instruction classes, although the x86 
  does not yet use them all.
</li></ul>

<h3 id="3.1">3.1. x86 ADD Instruction Opcode</h3>

<div><p>
  x86 ADD <a href="https://www.bryanbraun.com/2025/10/28/SolidGoldMagikarp/x86_instruction_format.png">instruction opcode</a>:</p><p>
  <img alt="x86 ADD Opcode" src="https://www.bryanbraun.com/2025/10/28/SolidGoldMagikarp/x86_add_opcode.png"/>
  </p><p>Bit number <strong>one</strong>, marked <strong>d</strong>, specifies 
  the <strong>direction</strong> of the data transfer:
  </p><ul>
    <li>If <strong>d = 0</strong> then the destination operand is a memory 
          location, e.g. <pre>        add [ebx], al</pre>
    </li><li>If <strong>d = 1</strong> then the destination operand is a 
          register, e.g. <pre>        add al, [ebx]</pre>
  </li></ul>
</div>

Bit number <strong>zero</strong> marked <strong>s</strong> specifies 
the <strong>size</strong> of the operands the <span>ADD</span> instruction operates upon:
<ul>
  <li>If <strong>s = 0</strong> then the operands are 8-bit registers and 
  memory locations.
  </li><li>If <strong>s = 1</strong> then the operands are either 16-bits or 
  32-bits:
  <ul>
    <li>Under 32-bit operating systems the default is 32-bit operands if 
    <strong>s = 1</strong>.
    </li><li>To specify a 16-bit operand (under Windows or Linux) you must 
    insert a special <em>operand-size prefix byte</em> in front of the 
    instruction (example of this later.)
  </li></ul>
</li></ul>
<hr/>
You&#39;ll soon see that this direction bit <strong>d</strong> creates a 
problem that results in one instruction have two different possible 
opcodes.

<h2 id="4">4. Encoding x86 Instruction Operands, MOD-REG-R/M Byte</h2>

The <span>MOD-REG-R/M</span> byte specifies <a href="https://www.bryanbraun.com/2025/10/28/SolidGoldMagikarp/x86_instruction_format.png">instruction</a> 
operands and their addressing mode<strong><sup>(*)</sup></strong>: 

<div>
  <p><img alt="MOD-REG-R/M Byte" src="https://www.bryanbraun.com/2025/10/28/SolidGoldMagikarp/mod_reg_r_m_byte.png"/></p><p>
  The <strong>MOD</strong> field specifies x86 addressing mode:</p><p>
  <table>
  <tbody><tr><th>MOD</th><th>Meaning
  </th></tr><tr><td>00</td><td>Register indirect addressing mode or SIB with no displacement
	(when R/M = 100) or Displacement only addressing mode (when R/M = 101).
  </td></tr><tr><td>01</td><td>One-byte signed displacement follows addressing mode byte(s).
  </td></tr><tr><td>10</td><td>Four-byte signed displacement follows addressing mode byte(s).
  </td></tr><tr><td>11</td><td>Register addressing mode.
  </td></tr></tbody></table></p><p>
  The <strong>REG</strong> field specifies source or destination 
  <strong>register</strong>:</p><p>
  <table>
  <tbody><tr><th>REG Value
    </th><th>Register if data size is eight bits
    </th><th>Register if data size is 16-bits
    </th><th>Register if data size is 32 bits
  </th></tr><tr><td>000</td><td>al</td><td>ax</td><td>eax
  </td></tr><tr><td>001</td><td>cl</td><td>cx</td><td>ecx
  </td></tr><tr><td>010</td><td>dl</td><td>dx</td><td>edx
  </td></tr><tr><td>011</td><td>bl</td><td>bx</td><td>ebx
  </td></tr><tr><td>100</td><td>ah</td><td>sp</td><td>esp
  </td></tr><tr><td>101</td><td>ch</td><td>bp</td><td>ebp
  </td></tr><tr><td>110</td><td>dh</td><td>si</td><td>esi
  </td></tr><tr><td>111</td><td>bh</td><td>di</td><td>edi
  </td></tr></tbody></table>
</p></div>
<p>
The <strong>R/M</strong> field, combined with <strong>MOD</strong>, 
specifies either
</p><ol>
  <li>the second operand in a <strong>two</strong>-operand instruction, or
  </li><li>the only operand in a <strong>single</strong>-operand instruction 
      like <span>NOT</span> or <span>NEG</span>.
</li></ol>
The <strong>d</strong> bit in the opcode determines which operand is 
the source, and which is the destination:
<ul>
  <li><strong>d=0: MOD R/M <tt>&lt;-</tt> REG</strong>, REG is the source 
  </li><li><strong>d=1: REG <tt>&lt;-</tt> MOD R/M</strong>, REG is the destination
</li></ul>
<hr/>
<strong><sup>(*)</sup></strong> Technically, registers do not have an 
address, but we apply the term <em>addressing mode</em> to registers 
nonetheless.

<h2 id="5">5. General-Purpose Registers</h2>

<div>
  <p><img alt="16-bit general-purpose registers" src="https://www.bryanbraun.com/2025/10/28/SolidGoldMagikarp/gp_registers.jpg"/></p><p>
  Since the processor accesses registers more quickly than it accesses 
  memory, you can make your programs run faster by keeping the 
  most-frequently used data in registers.
</p></div>

<ul>
  <li>The <span>EAX</span>, <span>EDX</span>, <span>ECX</span>, 
    <span>EBX</span>, <span>EBP</span>, <span>EDI</span>, 
    and <span>ESI</span> registers are 32-bit 
    general-purpose registers, used for temporary data storage and memory 
    access.
  </li><li>The <span>AX</span>, <span>DX</span>, <span>CX</span>, 
    <span>BX</span>, <span>BP</span>, <span>DI</span>, and 
    <span>SI</span> registers are 16-bit equivalents of 
    the above, they represent the low-order 16 bits of 32-bit registers.
  </li><li>The <span>AH</span>, <span>DH</span>, <span>CH</span>, and 
    <span>BH</span> registers represent the high-order 8 
    bits of the corresponding registers.
  </li><li>Similarly, <span>AL</span>, <span>DL</span>, <span>CL</span>, and <span>BL</span> represent the low-order 8 bits of the registers. 
</li></ul>

<h2 id="6">6. REG Field of the MOD-REG-R/M Byte</h2>

See <a href="#4">MOD-REG-R/M Byte</a>.<p>

Depending on the <a href="https://www.bryanbraun.com/2025/10/28/SolidGoldMagikarp/x86_instruction_format.png">instruction</a>,
this can be either the <em>source</em> or the destination operand.</p><p>

Many instructions have the <strong>d</strong> (direction) field in 
their opcode to choose <strong>REG</strong> operand role:
</p><ol>
  <li>If <strong>d=0</strong>, <strong>REG</strong> is the source, 
  </li><li>If <strong>d=1</strong>, <strong>REG</strong> is the destination,
  </li></ol>
<hr/>
<strong><sup>(*)</sup></strong> For certain (often single-operand or 
  immediate-operand) instructions, the <strong>REG</strong> field may contain an 
  <em>opcode extension</em> rather than the register bits. The 
  <strong>R/M</strong> field will specify the operand in such case.

<h3 id="9">9. MOD R/M Byte and Addressing Modes </h3>

<table>
<tbody><tr><td><pre>MOD R/M Addressing Mode
=== === ================================
 00 000 [ <span>eax</span> ]
 01 000 [ <span>eax</span> + <strong>disp8</strong> ]               (1)
 10 000 [ <span>eax</span> + <strong>disp32</strong> ]
 11 000 <span>register</span>  ( <span>al</span> / <span>ax</span> / <span>eax</span> )   (2)
 00 001 [ <span>ecx</span> ]
 01 001 [ <span>ecx</span> + <strong>disp8</strong> ]
 10 001 [ <span>ecx</span> + <strong>disp32</strong> ]
 11 001 <span>register</span>  ( <span>cl</span> / <span>cx</span> / <span>ecx</span> )
 00 010 [ <span>edx</span> ]
 01 010 [ <span>edx</span> + <strong>disp8</strong> ]
 10 010 [ <span>edx</span> + <strong>disp32</strong> ]
 11 010 <span>register</span>  ( <span>dl</span> / <span>dx</span> / <span>edx</span> )
 00 011 [ <span>ebx</span> ]
 01 011 [ <span>ebx</span> + <strong>disp8</strong> ]
 10 011 [ <span>ebx</span> + <strong>disp32</strong> ]
 11 011 <span>register</span>  ( <span>bl</span> / <span>bx</span> / <span>ebx</span> )
 00 100 <strong>SIB</strong>  Mode                     (3)
 01 100 <strong>SIB</strong>  +  <strong>disp8</strong>  Mode
 10 100 <strong>SIB</strong>  +  <strong>disp32</strong>  Mode
 11 100 <span>register</span>  ( <span>ah</span> / <span>sp</span> / <span>esp</span> )
 00 101 32-bit Displacement-Only Mode (4)
 01 101 [ <span>ebp</span> + <strong>disp8</strong> ]
 10 101 [ <span>ebp</span> + <strong>disp32</strong> ]
 11 101 <span>register</span>  ( <span>ch</span> / <span>bp</span> / <span>ebp</span> )
 00 110 [ <span>esi</span> ]
 01 110 [ <span>esi</span> + <strong>disp8</strong> ]
 10 110 [ <span>esi</span> + <strong>disp32</strong> ]
 11 110 <span>register</span>  ( <span>dh</span> / <span>si</span> / <span>esi</span> )
 00 111 [ <span>edi</span> ]
 01 111 [ <span>edi</span> + <strong>disp8</strong> ]
 10 111 [ <span>edi</span> + <strong>disp32</strong> ]
 11 111 <span>register</span>  ( <span>bh</span> / <span>di</span> / <span>edi</span> )
</pre></td><td>
<ol>
  <li>Addressing modes with 8-bit displacement fall in the range -128..+127 
    and require only a single byte displacement after the <a href="https://www.bryanbraun.com/2025/10/28/SolidGoldMagikarp/x86_instruction_format.png">opcode</a> (Faster!)
  </li><li>The size bit in the opcode specifies 8 or 32-bit register size.
    To select a 16-bit register requires a prefix byte.
  </li><li>The so-called scaled indexed addressing modes, <strong>SIB</strong> = 
    scaled index byte mode.
  </li><li>Note that there is no [ <span>ebp</span> ] addressing.
    It&#39;s slot is occupied by the 32-bit <em>displacement only</em> addressing mode.
    Intel decided that programmers can use [ <span>ebp</span>+ <strong>disp8</strong> ] 
    addressing mode instead, with its 8-bit displacement set equal to zero 
    (instruction is a little longer, though.) 
</li></ol>
</td></tr></tbody></table>

<h2 id="8">8. SIB (Scaled Index Byte) Layout</h2>

<div><p>
  Scaled index byte layout:</p><p>
  <img alt="SIB, Scaled index byte layout" src="https://www.bryanbraun.com/2025/10/28/SolidGoldMagikarp/sib_layout.png"/></p><p>
  <table>
  <tbody><tr>
    <td><table>
    <tbody><tr><th>Scale Value</th><th>Index*Scale Value
    </th></tr><tr><td>00</td><td>Index*1
    </td></tr><tr><td>01</td><td>Index*2
    </td></tr><tr><td>10</td><td>Index*4
    </td></tr><tr><td>11</td><td>Index*8
    </td></tr></tbody></table>
    </td><td><table>
    <tbody><tr><th>Index</th><th>Register
    </th></tr><tr><td>000</td><td>EAX
    </td></tr><tr><td>001</td><td>ECX
    </td></tr><tr><td>010</td><td>EDX
    </td></tr><tr><td>011</td><td>EBX
    </td></tr><tr><td>100</td><td>Illegal
    </td></tr><tr><td>101</td><td>EBP
    </td></tr><tr><td>110</td><td>ESI
    </td></tr><tr><td>111</td><td>EDI
    </td></tr></tbody></table>
    </td><td><table>
    <tbody><tr><th>Base</th><th>MOD</th><th>Register
    </th></tr><tr><td>000</td><td><i>xx</i></td><td>EAX
    </td></tr><tr><td>001</td><td><i>xx</i></td><td>ECX
    </td></tr><tr><td>010</td><td><i>xx</i></td><td>EDX
    </td></tr><tr><td>011</td><td><i>xx</i></td><td>EBX
    </td></tr><tr><td>100</td><td><i>xx</i></td><td>ESP
    </td></tr><tr><td rowspan="2">101</td><td>00</td><td>Displacement-only
    </td></tr><tr><td>01, 10</td><td>EBP
    </td></tr><tr><td>110</td><td><i>xx</i></td><td>ESI
    </td></tr><tr><td>111</td><td><i>xx</i></td><td>EDI
    </td></tr></tbody></table>
  </td></tr></tbody></table>
</p></div>

<ul>
  <li><em>Scaled indexed addressing mode</em> uses the second byte (namely, 
    <strong>SIB</strong> byte) that follows the <strong>MOD-REG-R/M</strong> 
    byte in the <a href="https://www.bryanbraun.com/2025/10/28/SolidGoldMagikarp/x86_instruction_format.png">instruction</a> format.
  </li><li>The <strong>MOD</strong> field still specifies the displacement size 
    of <strong>zero</strong>, <strong>one</strong>, or <strong>four</strong> 
    bytes.
  <ul>
    <li>The <strong>MOD-REG-R/M</strong> and SIB bytes are complex, because 
      Intel reused 16-bit addressing circuitry in the 32-bit mode, rather 
      than simply abandoning the 16-bit format in the 32-bit mode.
    </li><li>There are good hardware reasons for this, but the end result is a 
      complex scheme for specifying addressing modes in the opcodes. 
  </li></ul>
</li></ul>

<h3 id="8.1">8.1. Scaled Indexed Addressing Mode</h3>

<table><tbody><tr>
<td><pre>[ <span>reg32</span> + <span>eax</span>*<strong>n</strong> ] MOD = 00
[ <span>reg32</span> + <span>ebx</span>*<strong>n</strong> ] 
[ <span>reg32</span> + <span>ecx</span>*<strong>n</strong> ]
[ <span>reg32</span> + <span>edx</span>*<strong>n</strong> ]
[ <span>reg32</span> + <span>ebp</span>*<strong>n</strong> ]
[ <span>reg32</span> + <span>esi</span>*<strong>n</strong> ]
[ <span>reg32</span> + <span>edi</span>*<strong>n</strong> ]

[ <strong>disp</strong> + <span>reg8</span> + <span>eax</span>*<strong>n</strong> ] MOD = 01
[ <strong>disp</strong> + <span>reg8</span> + <span>ebx</span>*<strong>n</strong> ]
[ <strong>disp</strong> + <span>reg8</span> + <span>ecx</span>*<strong>n</strong> ]
[ <strong>disp</strong> + <span>reg8</span> + <span>edx</span>*<strong>n</strong> ]
[ <strong>disp</strong> + <span>reg8</span> + <span>ebp</span>*<strong>n</strong> ]
[ <strong>disp</strong> + <span>reg8</span> + <span>esi</span>*<strong>n</strong> ]
[ <strong>disp</strong> + <span>reg8</span> + <span>edi</span>*<strong>n</strong> ]

[ <strong>disp</strong> + <span>reg32</span> + <span>eax</span>*<strong>n</strong> ] MOD = 10
[ <strong>disp</strong> + <span>reg32</span> + <span>ebx</span>*<strong>n</strong> ]
[ <strong>disp</strong> + <span>reg32</span> + <span>ecx</span>*<strong>n</strong> ]
[ <strong>disp</strong> + <span>reg32</span> + <span>edx</span>*<strong>n</strong> ]
[ <strong>disp</strong> + <span>reg32</span> + <span>ebp</span>*<strong>n</strong> ]
[ <strong>disp</strong> + <span>reg32</span> + <span>esi</span>*<strong>n</strong> ]
[ <strong>disp</strong> + <span>reg32</span> + <span>edi</span>*<strong>n</strong> ]

[ <strong>disp</strong> + <span>eax</span>*<strong>n</strong> ] MOD = 00, and
[ <strong>disp</strong> + <span>ebx</span>*<strong>n</strong> ] BASE field = 101
[ <strong>disp</strong> + <span>ecx</span>*<strong>n</strong> ]
[ <strong>disp</strong> + <span>edx</span>*<strong>n</strong> ]
[ <strong>disp</strong> + <span>ebp</span>*<strong>n</strong> ]
[ <strong>disp</strong> + <span>esi</span>*<strong>n</strong> ]
[ <strong>disp</strong> + <span>edi</span>*<strong>n</strong> ]

</pre></td><td>
Note: <strong>n</strong> = <strong>1</strong>, <strong>2</strong>, 
<strong>4</strong>, or <strong>8</strong>.<p>

In each <strong>scaled indexed addressing mode</strong> the 
<strong>MOD</strong> field in <strong>MOD-REG-R/M</strong> byte 
specifies the <em>size of the displacement</em>. It can be zero, one, or 
four bytes:</p><pre>    MOD R/M  Addressing Mode
    --- ---  --------------------------- 
     00 100  <strong>SIB</strong>
     01 100  <strong>SIB</strong> + <strong>disp8</strong>
     10 100  <strong>SIB</strong> + <strong>disp32</strong>
</pre>
The <strong>Base</strong> and <strong>Index</strong> fields of the <a href="https://www.bryanbraun.com/2025/10/28/SolidGoldMagikarp/x86_instruction_format.png">SIB 
byte</a> select the base and index registers, respectively.<p>

Note that this addressing mode does not allow the use of the 
<strong>ESP</strong> register as an index register. Presumably, Intel 
left this particular mode undefined to provide the ability to extend the 
addressing modes in a future version of the CPU.
</p></td></tr></tbody></table>

<h2 id="9">9. Examples</h2>

<h3 id="9.1">9.1. Encoding ADD Instruction Example</h3>

<ul>
  <li>
  <p>The <span>ADD</span> <a href="https://www.bryanbraun.com/2025/10/28/SolidGoldMagikarp/x86_instruction_format.png">opcode</a> can 
  be decimal 0, 1, 2, or 3, depending on the direction and size bits in the 
  opcode: </p>
  <ul>
    <li>
    <p>  <img alt="ADD opcode" src="https://www.bryanbraun.com/2025/10/28/SolidGoldMagikarp/x86_add_opcode.png"/> 
    </p></li></ul>
  </li><li>
  <p>How could we encode various forms of the <span>ADD</span> instruction using different addressing modes? 
  </p>
  
  </li></ul>

<h3 id="9.2">9.2 Encoding ADD CL, AL Instruction</h3>

<ul>
  <li>
  <p>  <img alt="Encoding ADD AL, CL Instruction" src="https://www.bryanbraun.com/2025/10/28/SolidGoldMagikarp/encoding_add_cl_al.png"/> </p></li></ul>
<ul>
  <li>
  <p>Interesting side effect of the direction bit and the <strong>MOD-REG-R/M 
  byte</strong> organization: some instructions can have two different opcodes, 
  and both are legal! </p>
  </li><li>
  <p>For example, encoding of </p><pre>    add cl, al
</pre>
  <p>could be <strong>00 C1</strong> (if <strong>d=0</strong>), or <strong>02 
  C8</strong>, if <strong>d</strong> bit is set to <strong>1</strong>. </p>
  </li><li>
  <p>The possibility of opcode duality issue here applies to all instructions 
  with two register operands. </p>
  </li></ul>

<h3 id="9.3">9.3. Encoding ADD ECX, EAX Instruction</h3>

<ul>
  <li><pre>    add ecx, eax
</pre></li></ul>
<ul>
  <li>
  <p>  <img alt="Encoding ADD ECX, EAX Instruction" src="https://www.bryanbraun.com/2025/10/28/SolidGoldMagikarp/encoding_add_ecx_eax.png"/> </p>
  </li><li>
  <p>Note that we could also encode <span>ADD</span> 
  <strong>ECX</strong>, <strong>EAX</strong> using the bytes <strong>03 
  C8</strong>. </p>
  
  </li></ul>

<h3 id="9.4">9.4. Encoding ADD EDX, DISPLACEMENT Instruction</h3>

<ul>
  <li>
  <p>Encoding the <span>ADD</span> <strong>EDX</strong>, 
  DISP Instruction: </p><pre>    add edx, disp
    <img alt="Encoding the ADD EDX, DISP Instruction" src="https://www.bryanbraun.com/2025/10/28/SolidGoldMagikarp/encoding_add_edx_disp.png"/>
</pre>
  
  </li></ul>

<h3 id="9.5">9.5. Encoding ADD EDI, [EBX] Instruction</h3>

<ul>
  <li>
  <p>Encoding the <span>ADD</span> <strong>EDI</strong>, [ 
  <strong>EBX</strong> ] instruction: </p><pre>    add edi, [ebx]
    <img alt="Encoding the ADD EDI, [EBX] Instruction" src="https://www.bryanbraun.com/2025/10/28/SolidGoldMagikarp/encoding_add_edi_ebx.png"/>
</pre>
  
  </li></ul>

<h3 id="9.6">9.6. Encoding ADD EAX, [ ESI + disp8 ] Instruction</h3>

<ul>
  <li>
  <p>Encoding the <span>ADD</span> <strong>EAX</strong>, [ 
  <strong>ESI</strong> + <strong>disp8</strong> ] instruction: </p><pre>    add eax, [ esi + disp8 ]
    <img alt="Encoding the ADD EAX, [ ESI + disp8 ] Instruction" src="https://www.bryanbraun.com/2025/10/28/SolidGoldMagikarp/encoding_add_eax_esi_disp8.png"/>
</pre>
  
  </li></ul>

<h3 id="9.7">9.7. Encoding ADD EBX, [ EBP + disp32 ] Instruction</h3>

<ul>
  <li>
  <p>Encoding the <span>ADD</span> <strong>EBX</strong>, [ 
  <strong>EBP</strong> + <strong>disp32</strong> ] instruction: </p><pre>    add ebx, [ ebp + disp32 ]
    <img alt="Encoding the ADD EBX, [ EBP + disp32 ] Instruction" src="https://www.bryanbraun.com/2025/10/28/SolidGoldMagikarp/encoding_add_ebx_ebp_disp32.png"/>
</pre>
  
  </li></ul>

<h3 id="9.8">9.8. Encoding ADD EBP, [ disp32 + EAX*1 ] Instruction</h3>

<ul>
  <li>
  <p>Encoding the <span>ADD</span> <strong>EBP</strong>, [ 
  <strong>disp32</strong> + <strong>EAX</strong>*1 ] Instruction </p><pre>    add ebp, [ disp32 + eax*1 ]
    <img alt="Encoding the ADD EBP, [ disp32 + EAX*1 ] Instruction" src="https://www.bryanbraun.com/2025/10/28/SolidGoldMagikarp/encoding_add_ebp_disp32_eax_1.png"/>
</pre>
  
  </li></ul>

<h3 id="9.9">9.9. Encoding ADD ECX, [ EBX + EDI*4 ] Instruction</h3>

<ul>
  <li>
  <p>Encoding the <span>ADD</span> <strong>ECX</strong>, [ 
  <strong>EBX</strong> + <strong>EDI</strong>*4 ] Instruction </p><pre>    add ecx, [ ebx + edi*4 ]
    <img alt="Encoding ADD ECX, [ EBX + EDI*4 ] Instruction" src="https://www.bryanbraun.com/2025/10/28/SolidGoldMagikarp/encoding_add_ecx_ebx_edi_4.png"/>
</pre>
  
  </li></ul>

<h2 id="10">10. Encoding ADD Immediate Instruction</h2>

<div><p>
 Encoding x86 immediate operands:
 </p><p><img alt="Encoding Immediate Operands" src="https://www.bryanbraun.com/2025/10/28/SolidGoldMagikarp/encoding_immediate_operands.png"/> 
</p></div>

<strong>MOD-REG-R/M</strong> and <strong>SIB</strong> bytes have no 
bit combinations to specify an immediate operand.<p>

Instead, x86 uses a entirely different <a href="https://www.bryanbraun.com/2025/10/28/SolidGoldMagikarp/x86_instruction_format.png">instruction format</a> to specify instruction with an immediate operand.</p><p>

There are three rules that apply:
</p><ol>
  <li>If opcode high-order bit set to <strong>1</strong>, then <em>instruction 
  has an immediate constant</em>.
  </li><li>There is no direction bit in the opcode:
  <ul>
    <li>: indeed, you cannot specify a constant as a destination operand!
    </li><li>Therefore, destination operand is always the location encoded in the 
    <strong>MOD-R/M</strong> bits of the the <strong>MOD-REG-R/M</strong> byte. 
    </li><li>In place of the direction bit <strong>d</strong>, the opcode has a sign 
    extension <strong>x</strong> bit instead:
    <ul>
      <li>For 8-bit operands, the CPU ignores <strong>x</strong> bit.
      </li><li>For 16-bit and 32-bit operands, <strong>x</strong> bit specifies the 
      size of the <span>Constant</span> following at 
      the end of the instruction:
      <ul>
        <li>If <strong>x</strong> bit contains <strong>zero</strong>, the <span>Constant</span> is the same 
        size as the operand (i.e., 16 or 32 bits).
        </li><li>If <strong>x</strong> bit contains <strong>one</strong>, the <span>Constant</span> is a <span>signed</span> 8-bit value, and the CPU sign-extends 
        this value to the appropriate size before adding it to the operand. 
      </li></ul>
      </li><li>This little <strong>x</strong> trick often makes programs shorter, 
      because adding small-value constants to 16 or 32 bit operands is very 
      common.
    </li></ul>
  </li></ul>
  </li><li>The third difference between the <span>ADD</span>-immediate and the standard <span>ADD</span> instruction is the meaning of the 
  <strong>REG</strong> field in the <strong>MOD-REG-R/M</strong> byte:
  <ul>
    <li>Since the instruction implies that
    <ul>
      <li>the source operand is a constant, and
      </li><li><strong>MOD-R/M</strong> fields specify the destination operand, 
    </li></ul>
    the instruction does not need to use the <strong>REG</strong> field to 
    specify an operand.
    </li><li>Instead, the x86 CPU uses these three bits as an <strong>opcode 
    extension</strong>.
    </li><li>For the <span>ADD</span>-immediate instruction the 
    <strong>REG</strong> bits must contain zero.
    </li><li>Other bit patterns would correspond to a different instruction. 
  </li></ul>
</li></ol>
<blockquote>
  Note that when adding a constant to a memory location, the displacement (if 
  any) immediately precedes the immediate (constant) value in the opcode 
  sequence.
</blockquote>

<h2 id="11">11. Encoding Eight, Sixteen, and Thirty-Two Bit Operands</h2>

<div><p>
 x86 ADD Opcode:
 </p><p><img alt="x86 ADD Opcode" src="https://www.bryanbraun.com/2025/10/28/SolidGoldMagikarp/x86_add_opcode.png"/>
</p></div>

<ul>
  <li>When Intel designed the 8086, one bit in the opcode, 
        <strong>s</strong>, selected between 8 and 16 bit integer operand sizes. 
  </li><li>Later, when CPU added 32-bit integers to its architecture on 80386 
        chip, there was a problem:
  <ul>
    <li>three encodings were needed to support 8, 16, and 32 bit sizes. 
  </li></ul>
  </li><li>Solution was an <em>operand size prefix byte</em>.
  </li><li>Intel studied x86 instruction set and came to the conclusion:
  <ul>
    <li>in a 32-bit environment, programs were more likely to use 8-bit and 
    32-bit operands far more often than 16-bit operands.
  </li></ul>
  </li><li>So Intel decided to let the size bit <strong>s</strong> in the opcode 
  select between 8- and 32-bit operands.
</li></ul>

<h3 id="11.1">11.1. Encoding Sixteen Bit Operands</h3>

<div><p>
 x86 instruction format:
 </p><p><img alt="instruction format" src="https://www.bryanbraun.com/2025/10/28/SolidGoldMagikarp/x86_instruction_format.png"/> 
</p></div>

32-bit programs don&#39;t use 16-bit operands that often, but they do 
need them now and then.<p>

To allow for 16-bit operands, Intel added prefix a 32-bit mode 
instruction with the <em>operand size prefix byte</em> with value 
<strong>66h</strong>.</p><p>

This prefix byte tells the CPU to operand on 16-bit data rather than 
32-bit data.

</p><ul>
  <li>There is nothing programmer has to do explicitly to put an operand size 
  prefix byte in front of a 16-bit instruction:
  <ul>
    <li>the assembler does this automatically as soon as 16-bit operand is found 
    in the instruction.
  </li></ul>
  </li><li>However, keep in mind that whenever you use a 16-bit operand in a 32-bit 
  program, the instruction is longer by one byte:<pre>    Opcode     Instruction
    --------   ------------
    41h        <span>INC</span> ECX
    66h 41h    <span>INC</span> CX</pre>
  </li><li>Be careful about using 16-bit instructions if size (and to a lesser extent, 
  speed) are important, because
  <ol>
    <li>instructions are longer, and
    </li><li>slower because of their effect on the instruction cache.
  </li></ol>
</li></ul>

<h2 id="12">12. x86 Instruction Prefix Bytes</h2>

<ul>
  <li>x86 <a href="https://www.bryanbraun.com/2025/10/28/SolidGoldMagikarp/x86_instruction_format.png">instruction</a> can have up to 4 prefixes.
  </li><li>Each prefix adjusts interpretation of the opcode:
  <ol>
    <li><strong>Repeat/lock</strong> prefix byte guarantees that instruction will 
    have exclusive use of all shared memory, until the instruction completes 
    execution:<pre>        F0h = <span>LOCK</span></pre>
    </li><li><strong>String manipulation</strong> instruction prefixes<pre>        F3h = <span>REP</span>, <span>REPE</span>
        F2h = <span>REPNE</span></pre>
    where
    <ul>
      <li><span>REP</span> repeats instruction the number of 
      times specified by <em>iteration count</em> <span>ECX</span>.
      </li><li><span>REPE</span> and <span>REPNE</span> prefixes allow to terminate loop on the 
      value of <strong>ZF</strong> CPU flag.
    </li></ul>
    Related string manipulation instructions are:
    <ul>
      <li><span>MOVS</span>, move string
      </li><li><span>STOS</span>, store string
      </li><li><span>SCAS</span>, scan string
      </li><li><span>CMPS</span>, compare string, etc. 
    </li></ul>
    See also string manipulation sample program: <a href="http://www.c-jump.com/CIS77/samples/rep_movsb.htm"><tt>rep_movsb.asm</tt></a> 

    </li><li><strong>Segment override</strong> prefix causes memory access to use 
    <em>specified segment</em> instead of <em>default segment</em> designated 
    for instruction operand.<pre>        2Eh = <span>CS</span>
        36h = <span>SS</span>
        3Eh = <span>DS</span>
        26h = <span>ES</span>
        64h = <span>FS</span>
        65h = <span>GS</span></pre>
    </li><li><strong>Operand override</strong>, <strong>66h</strong>. Changes size of 
    data expected by default mode of the instruction e.g. 16-bit to 32-bit and 
    vice versa. 
    </li><li><strong>Address override</strong>, <strong>67h</strong>. Changes size of 
    address expected by the instruction. 32-bit address could switch to 16-bit 
    and vice versa.
  </li></ol>
</li></ul>

<h2 id="13">13. Alternate Encodings for Instructions</h2>

<ul>
  <li>To shorten program code, Intel created alternate (shorter) encodings of 
  some very commonly used instructions.
  </li><li>For example, x86 provides a single byte opcode for<pre>    add al, constant    ; one-byte opcode and no MOD-REG-R/M byte
    add eax, constant   ; one-byte opcode and no MOD-REG-R/M byte</pre>
  the opcodes are <strong>04h</strong> and <strong>05h</strong>, 
  respectively. Also,
  </li><li>These instructions are one byte shorter than their standard
  <span>ADD</span> immediate counterparts.
  </li><li>Note that<pre>    add ax, constant   ; operand size prefix byte + one-byte opcode, no MOD-REG-R/M byte</pre>
  requires an operand size prefix just as a standard <span>ADD</span> <strong>AX</strong>, <strong>constant</strong> 
  instruction, yet is still one byte shorter than the corresponding standard 
  version of <span>ADD</span> immediate.
  </li><li>Any decent assembler will <em>automatically</em> choose the shortest 
  possible instruction when translating program into machine code.
  </li><li>Intel only provides alternate encodings only for the accumulator registers 
  <strong>AL</strong>, <strong>AX</strong>, <strong>EAX</strong>.
  </li><li>This is a good reason to use accumulator registers if you have a choice 
  <blockquote>
    (also a good reason to take some time and study encodings of the x86 
    instructions.) </blockquote>
</li></ul>

<h2 id="14">14. x86 Opcode Summary</h2>

<ul>
  <li>x86 opcodes are represented by one or two bytes.
  </li><li>Opcode could extend into unused bits of <strong>MOD-REG-R/M</strong> byte. 
  </li><li>Opcode encodes information about
  <ul>
    <li>operation type,
    </li><li>operands,
    </li><li>size of each operand, including the size of an immediate operand. 
  </li></ul>
</li></ul>

<h3 id="14.1">14.1. MOD-REG-R/M Byte Summary</h3>

<div><p>
 MOD-REG-R/M Byte:
 </p><p><img alt="MOD-REG-R/M Byte" src="https://www.bryanbraun.com/2025/10/28/SolidGoldMagikarp/mod_reg_r_m_byte.png"/> 
</p></div>

<ul>
  <li><strong>MOD-REG-R/M</strong> byte follows one or two opcode bytes of 
        the <a href="https://www.bryanbraun.com/2025/10/28/SolidGoldMagikarp/x86_instruction_format.png">instruction</a>
  </li><li>It provides <em>addressing mode</em> information for one or two 
        operands.
  </li><li>If operand is in <span>memory</span>, or operand is a 
  <span>register</span>:
  <ul>
    <li><strong>MOD</strong> field (bits [7:6]), combined with the 
    <strong>R/M</strong> field (bits [2:0]), specify <span>memory</span>/<span>register</span> 
    operand, as well as its <em>addressing mode</em>.
    </li><li><strong>REG</strong> field (bits [5:3]) specifies another <span>register</span> operand in of the two-operand 
    instruction.
  </li></ul>
</li></ul>

<h2 id="15">15. ISA Design Considerations</h2>

<ul>
  <li>Instruction set architecture design that can stand the test of time is a 
  true intellectual challenge.
  </li><li>It takes several compromises between space and efficiency to assign opcodes 
  and encode instruction formats.
  </li><li>Today people are using Intel x86 instruction set for purposes never 
  intended by original designers.
  </li><li>Extending the CPU is a very difficult task.
  </li><li>The instruction set can become <em>extremely complex</em>.
  </li><li>If x86 CPU was designed <em>from scratch</em> today, it would have a 
  totally different ISA!
  </li><li>Software developers usually don&#39;t have a problem adapting to a new 
  architecture when writing new software...
  <blockquote>
    ...but they are very resistant to moving existing software from one 
    platform to another. </blockquote>
  </li><li>This is the primary reason the Intel x86 platform remains so popular to 
  this day.
</li></ul>

<h3 id="15.1">15.1. ISA Design Challenges </h3>

<ul>
  <li>Allowing for future expansion of the chip requires some <em>undefined 
  opcodes</em>.
  </li><li>From the beginning there should be a balance between the number of 
  undefined opcodes and
  <ol>
    <li>the number of initial instructions, and
    </li><li>the size of your opcodes (including special assignments.)
  </li></ol>
  </li><li>Hard decisions:
  <ul>
    <li>Reduce the number of instructions in the initial instruction set?
    </li><li>Increase the size of the opcode?
    </li><li>Rely on an opcode prefix byte(s), which makes later added instructions 
    longer?
  </li></ul>
  </li><li>There are no easy answers to these challenges for CPU designers!
</li></ul>

<h2 id="16">16. Intel Architecture Software Developer&#39;s Manual</h2>

Classic Intel Pentium II Architecture Software Developer&#39;s Manual contains 
three parts:
<ol>
  <li><a href="http://developer.intel.com/design/pentiumii/manuals/243190.htm">Volume 1</a> , <em>Intel Basic Architecture</em>: 
  <a href="http://download.intel.com/design/PentiumII/manuals/24319002.PDF">Order Number 243190</a> , PDF, 2.6 MB.
  </li><li><a href="http://developer.intel.com/design/pentiumii/manuals/243191.htm">Volume 2</a> , <em>Instruction Set Reference</em>: 
  <a href="http://download.intel.com/design/PentiumII/manuals/24319102.PDF">Order Number 243191</a> , PDF, 6.6 MB.
  </li><li><a href="http://developer.intel.com/design/pentiumii/manuals/243192.htm">Volume 3</a> , <em>System Programing Guide</em>: 
  <a href="http://download.intel.com/design/PentiumII/manuals/24319202.pdf">Order Number 243192</a> , PDF, 5.1 MB.
</li></ol>
It is highly recommended that you download the above manuals and use them 
as a reference.

<h3 id="16.1">16.1. Intel Instruction Set Reference (Volume2)</h3>

<ul>
  <li><strong>Chapter 3</strong> of the
  <a href="http://developer.intel.com/design/pentiumii/manuals/243191.htm">Instruction Set Reference</a> describes
  <ul>
    <li>each Intel instruction in detail
    </li><li>algorithmic description of each operation
    </li><li>effect on flags
    </li><li>operand(s), their sizes and attributes
    </li><li>CPU exceptions that may be generated.
  </li></ul>
  </li><li>The instructions are arranged in alphabetical order.
  </li><li><strong>Appendix A</strong> provides <em>opcode map</em> for the entire 
  Intel Architecture instruction set.
</li></ul>

<h3 id="16.2">16.2. Chapter 3 of Intel Instruction Set Reference</h3>

<ul>
  <li><strong>Chapter 3</strong> begins with instruction format example and 
  explains the <strong>Opcode</strong> column encoding.
  </li><li>The <strong>Opcode</strong> column gives the <em>complete machine 
  codes</em> as it is understood by the CPU.
  </li><li>When possible, the actual <em>machine code bytes</em> are given as exact 
  hexadecimal bytes, in the same order in which they appear in memory.
  </li><li>However, there are opcode definitions other than hexadecimal bytes...
</li></ul>

<h3 id="16.3">16.3. Intel Reference Opcode Bytes</h3>

<ul>
  <li>Fow example,
  <p><img alt="INC instruction reference page" src="https://www.bryanbraun.com/2025/10/28/SolidGoldMagikarp/intel_inc.png"/>
</p></li></ul>

<h3 id="16.4">16.4. Intel Reference Opcode Bytes, Cont.</h3>

<ul>
  <li><tt>/digit</tt> - A digit between 0 and 7 indicates that
  <ul>
    <li>The <strong>reg</strong> field of <strong>Mod R/M</strong> byte contains 
    the instruction opcode extension.
    </li><li>The <strong>r/m</strong> (register or memory) operand of <strong>Mod 
    R/M</strong> byte indicates
<pre>    R/M Addressing Mode
    === ===========================
    000 register ( al / ax / eax )
    001 register ( cl / cx / ecx )
    010 register ( dl / dx / edx )
    011 register ( bl / bx / ebx )
    100 register ( ah / sp / esp )
    101 register ( ch / bp / ebp )
    110 register ( dh / si / esi )
    111 register ( bh / di / edi )</pre>
  </li></ul>
  </li><li>The size bit in the opcode specifies 8 or 32-bit register size.
  </li><li>A 16-bit register requires a prefix byte:<pre>    Opcode     Instruction
    --------   ------------
    41h        <span>INC</span> ECX
    66h 41h    <span>INC</span> CX</pre>
</li></ul>

<h3 id="16.5">16.5. Intel Reference Opcode Bytes, Cont.</h3>

<ul>
  <li><tt>/r</tt> - Indicates that the instruction uses the <strong>Mod 
  R/M</strong> byte of the instruction.
  </li><li><strong>Mod R/M</strong> byte contains both
  <ul>
    <li>a register operand <strong>reg</strong> and
    </li><li>an <strong>r/m</strong> (register or memory) operand.
  </li></ul>
</li></ul>

<h3 id="16.6">16.6. Intel Reference Opcode Bytes, Cont. </h3>

<ul>
  <li><tt>cb, cw, cd, cp</tt> - A 1-byte (cb), 2-byte (cw), 4-byte (cd), or 
  6-byte (cp) value, </li></ul>

<h3 id="16.7">16.7. Intel Reference Opcode Bytes, Cont.</h3>

<ul>
  <li><tt>ib, iw, id</tt> - A 1-byte (ib), 2-byte (iw), or 4-byte (id) indicates 
  presence of the <strong>immediate operand</strong> in the instruction.
  </li><li>Typical order of opcode bytes is
  <ul>
    <li><strong>opcode</strong>
    </li><li><strong>Mod R/M</strong> byte (optional)
    </li><li><strong>SIB</strong> scale-indexing byte (optional)
    </li><li><strong>immediate operand</strong>.
  </li></ul>
  </li><li>The opcode determines if the operand is a signed value.
  </li><li>All words and doublewords are given with the low-order byte first (little endian).
</li></ul>

<h3 id="16.8">16.8. Intel Reference Opcode Bytes, Cont.</h3>

<ul>
  <li><tt>+rb, +rw, +rd</tt> - A register code, from 0 through 7, added to the 
  hexadecimal byte given at the left of the plus sign to form a single opcode 
  byte.
  </li><li>Register Encodings Associated with the <strong>+rb</strong>, 
  <strong>+rw</strong>, and <strong>+rd</strong>:
  <p><img alt="Register Encodings Associated with the +rb, +rw, and +rd" src="https://www.bryanbraun.com/2025/10/28/SolidGoldMagikarp/intel_rb_rw_rd.png"/>
  </p><p>For example,
  </p><p><img alt="INC instruction reference page" src="https://www.bryanbraun.com/2025/10/28/SolidGoldMagikarp/intel_inc.png"/>
</p></li></ul>

<h3 id="16.9">16.9. Intel Reference Instruction Column</h3>

<ul>
  <li>The <strong>Instruction</strong> column gives the syntax of the instruction 
  statement as it would appear in a 386 Assembly program.
  </li><li>For example,
  <p><img alt="INC instruction reference page" src="https://www.bryanbraun.com/2025/10/28/SolidGoldMagikarp/intel_inc.png"/>
</p></li></ul>


</div>
  </body>
</html>
