<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fasterthanli.me/articles/lies-we-tell-ourselves-to-keep-using-golang">Original</a>
    <h1>Lies we tell ourselves to keep using Golang</h1>
    
    <div id="readability-page-1" class="page"><div>
  

  <p>
    Apr 29, 2022
    
      · 21 minute read
    
    
    
      
        
          ·
          <a href="https://scattered-thoughts.net/tags/golang">golang</a>
        
      
        
          ·
          <a href="https://scattered-thoughts.net/tags/rant">rant</a>
        
      
      
      
      
          
      
      
    
  </p>

  
</div><div>
  

  <p>In the two years since I&#39;ve posted <a href="https://scattered-thoughts.net/articles/i-want-off-mr-golangs-wild-ride">I want off Mr Golang&#39;s Wild
Ride</a>, it&#39;s made the rounds time and
time again, on Reddit, on Lobste.rs, on HackerNews, and elsewhere.</p>
<p>And every time, it elicits the same responses:</p>
<ul>
<li>You talk about Windows: that&#39;s not what Go is good at! (Also, who cares?)</li>
<li>This is very one-sided: you&#39;re not talking about the <em>good</em> sides of Go!</li>
<li>You don&#39;t understand the compromises Go makes.</li>
<li>Large companies use Go, so it can&#39;t be <em>that</em> bad!</li>
<li>Modelling problems &#34;correctly&#34; is too costly, so caring about correctness is moot.</li>
<li>Correctness is a spectrum, Go lets you trade some for development speed.</li>
<li>Your go-to is Rust, which also has shortcomings, so your argument is invalid.</li>
<li>etc.</li>
</ul>
<p>There&#39;s also a vocal portion of commenters who wholeheartedly agree with the
rant, but let&#39;s focus on unpacking the apparent conflict here.</p>
<p>I&#39;ll first spend a short amount of time pointing out clearly disingenuous
arguments, to get them out of the way, and then I&#39;ll move on to the fairer
comments, addressing them as best I can.</p>
<h2>The author is a platypus</h2>
<p>When you don&#39;t want to hear something, one easy way to <em>not have to think about
it at all</em> is to convince yourself that whoever is saying it is incompetent, or
that they have ulterior motives.</p>
<p>For example, the top comment on HackerNews right now starts like this:</p>
<blockquote>
<p>The author fundamentally misunderstands language design.</p>
</blockquote>
<p>As an impostor syndrome enthusiast, I would normally be sympathetic to such
comments. However, it is a lazy and dismissive way to consider any sort of
feedback.</p>
<p>It doesn&#39;t take much skill to notice a problem.</p>
<p>In fact, as developers get more and more senior, they tend to ignore more and
more problems, because they&#39;ve gotten so used to it. That&#39;s the way it&#39;s always
been done, and they&#39;ve learned to live with them, so they&#39;ve stopped questioning
it any more.</p>
<p>Junior developers however, get to look at everything again with a fresh pair of
eyes: they haven&#39;t learned to ignore all the quirks yet, so it feels
<em>uncomfortable</em> to them, and they tend to question it (if they&#39;re made to feel
safe enough to voice their concerns).</p>
<p>This alone is an extremely compelling reason to hire junior developers, which I
wish more companies would do, instead of banking on the fact that &#34;seniors can
get up-to-speed with our current mess faster&#34;.</p>
<p>As it happens, I am <em>not</em> a junior developer, far from it. Some way or another,
over the past 12 years, seven different companies have found an excuse to pay me
enough money to cover rent and then some.</p>
<p>I did, in fact, <a href="https://ooc-lang.org/">design a language</a> all the way back in
2009 (when I <em>was</em> a wee programmer baby), focused mainly on syntactic sugar
over C. At the time it was deemed interesting enough to warrant an invitation to
OSCON (my first time in Portland Oregon, the capital of grunge, coffee, poor
weather and whiteness), where I got to meet other young and not-so-young
whippersnappers (working on Io, Ioke, Wren, JRuby, Clojure, D, Go, etc.)</p>
<p>It was a very interesting conference: I&#39;m still deeply ashamed by the
presentation I gave, but I remember fondly the time an audience member asked the
Go team <strong>&#34;why did you choose to ignore any research about type systems since the
1970s&#34;</strong>? I didn&#39;t fully understand the implications at the time, but I sure do
now.</p>
<p>I have since thoroughly lost interest in my language, because I&#39;ve started
caring about semantics a lot more than syntax, which is why I also haven&#39;t
looked at Zig, Nim, Odin, etc: I am no longer interested in &#34;a better C&#34;.</p>
<p>But <em>all of that is completely irrelevant</em>. It doesn&#39;t matter who points out that
&#34;maybe we shouldn&#39;t hit ourselves in the head with a rake repeatedly&#34;: that
feedback ought to be taken under advisement no matter who it comes from.</p>
<h2>Mom smokes, so it&#39;s probably okay</h2>
<p>One of the least effective way to shop for technologies (which CTOs, VPs of
engineering, principals, senior staff and staff engineers need to do regularly)
is to look at what other companies are using.</p>
<p>It is a great way to <em>discover</em> technologies to evaluate (that or checking
ThoughtWorks&#39; <a href="https://www.thoughtworks.com/radar">Tech Radar</a>), but it&#39;s far
from enough.</p>
<p>A piece from company X on &#34;how they used technology Y&#34;, will <em>very rarely</em>
reflect the true cost of adopting that technology. By the point the engineers
behind the post have been bullied into filling out the company&#39;s tech blog after
months of an uphill battle, the decision has been made, and there&#39;s no going
back.</p>
<p>This kind of blog doesn&#39;t lend itself to coming out and admitting that mistakes
were made. It&#39;s supposed to make the company look good. It&#39;s supposed to attract
new hires. It&#39;s supposed to help us stay <em>relevant</em>.</p>
<p>Typically, scathing indictments of technologies come from <em>individuals</em>, who
have simply decided that they, as a person, can afford making a lot of people
angry. Companies typically cannot.</p>
<p>There are some exceptions: <a href="https://tailscale.com/">Tailscale</a>&#39;s blog is
refreshingly candid, for example. But when reading articles like <a href="https://tailscale.com/blog/netaddr-new-ip-type-for-go/">netaddr.IP: a
new IP address type for
Go</a>, or <a href="https://tailscale.com/blog/go-linker/">Hey linker, can
you spare a meg?</a> you can react in
different ways.</p>
<p>You can be impressed, that <em>very smart folks</em> are using Go, right now, and that
they have gone all the way to Davy Jones&#39; Locker and back to solve complex
problems that ultimately helps deliver value to customers.</p>
<p>Or you can be <em>horrified</em>, as you realize that those complex problems only exist
<em>because Go is being used</em>. Those complex problems would not exist in other
languages, not even in C, which I can definitely not be accused of shilling for
(and would not recommend as a Go replacement).</p>
<p>A lot of the pain in the <code>netaddr.IP</code> article is caused by:</p>
<ul>
<li>Go not having sum types — making it really awkward to have a type that is
&#34;either an IPv4 address or an IPv6 address&#34;</li>
<li>Go choosing which data structures you need — in this case, it&#39;s the
one-size-fits-all slice, for which you pay 24 bytes on 64-bit machines.</li>
<li>Go not letting you do operator overloading, harking back to the Java days
where <code>a == b</code> isn&#39;t the same as <code>a.equals(b)</code></li>
<li>Go&#39;s lack of support for immutable data — the only way to prevent something
from being mutated is to only hand out copies of it, and to <em>be very careful</em>
to not mutate it in the code that actually has access to the inner bits.</li>
<li>Go&#39;s unwillingness to let you make an opaque &#34;newtype&#34;. The only way to do
it is to make a separate package and use interfaces for indirection, which is
costly <em>and</em> awkward.</li>
</ul>
<p>Unless you&#39;re out for confirmation bias, that whole article is a very compelling
argument against using Go for that specific problem.</p>
<p>And yet Tailscale is using it. Are they wrong? Not necessarily! Because their
team is made up of a bunch of <em>Go experts</em>. As evidenced by the <em>other</em> article,
about the Go linker.</p>
<p>Because they&#39;re Go experts, they know the cost of using Go upfront, and they&#39;re
equipped to make the decision whether or not it&#39;s worth it. They know how Go
works deep down (something Go marketing pinky-swears you <em>never need to worry
about, why do you ask?</em>), so if they hit edge cases, they can dive into it, fix
it, and wait for their fix to be upstreamed (if ever).</p>
<p>But chances are, <em>this is not you</em>. This is not your org. You are not Google
either, and you cannot afford to build a whole new type system on top of Go just
to make your project (Kubernetes) work at all.</p>
<h2>The good parts</h2>
<p>But okay - Tailscale&#39;s usage of Go is pretty <em>out there</em> still. Just like my
2020 piece about Windows raised an army of &#34;but that&#39;s not what Go is good for&#34;
objections, you could dismiss Tailscale&#39;s posts as &#34;well that&#39;s on you for
wanting to ship stuff on iOS / doing low-level network stuff&#34;.</p>
<p>Fair enough! Okay. Let&#39;s talk about what makes Go compelling.</p>
<p>Go is a pretty good async runtime, with opinionated defaults, a
<a href="https://go.dev/blog/ismmkeynote">state-of-the-art garbage collector</a> with two
knobs, and tooling that would make C developers jealous, if they bothered
looking outside their bubble.</p>
<p>This also describes <a href="https://nodejs.org/en/">Node.js</a> from the very start (which
is essentially libuv + V8), and I believe it also describes &#34;modern Java&#34;, with
APIs like NIO. Although I haven&#39;t checked what&#39;s happening in Java land too
closely, so if you&#39;re looking for an easy inaccuracy to ignore this whole
article, there you go: that&#39;s a freebie.</p>
<p>Because the async runtime is core to the language, it comes with tooling that
<em>does</em> make Rust developers jealous! I talk about it in <a href="https://scattered-thoughts.net/articles/request-coalescing-in-async-rust">Request coalescing in
async Rust</a>, for example.</p>
<p>Go makes it easy to dump backtraces (stack traces) for all running goroutines in
a way <a href="https://tokio.rs/">tokio</a> doesn&#39;t, at this time. It is also able to
detect deadlocks, it comes with its own profiler, it seemingly lets you not
worry about <a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">the color of
functions</a>, etc.</p>
<p>Go&#39;s tooling around package management, refactoring, cross-compiling, etc., is
easy to pick up and easy to love — and certainly feels at first like a definite
improvement over the many person-hours lost to the whims of pkg-config,
autotools, CMake, etc. Until you reach some of the arbitrary limitations that
simply do not matter to the Go team, and then you&#39;re on your own.</p>
<p>All those and more explains why many, including me, were originally enticed by
it: enough to write piles and piles of it, until its shortcomings have finally
become impossible to ignore, by which point it&#39;s too late. You&#39;ve made your bed,
and now you&#39;ve got to make yourself feel okay about lying in it.</p>
<p>But one <em>really good bit</em> does not a platform make.</p>
<p>The really convenient async runtime is not the only thing you adopted. You also
adopted a <em>very custom</em> toolchain, a build system, a calling convention, a
single GC (whether it works for you or not), the set of included batteries, some
of which you CAN swap out, but the rest of the ecosystem won&#39;t, and most
importantly, you adopted a language that happened by accident.</p>
<p>I will grant you that caring <em>too much</em> about something is grounds for
suspicion. It is no secret that a large part of what comes out of academia is
woefully inapplicable in the industry at this time: it is easy to lose oneself
in the abstract, and come up with convoluted schemes to solve problems that do
not really exist for anyone else.</p>
<p>I imagine this is the way some folks feel about Rust.</p>
<p>But caring <em>too little</em> about something is dangerous too.</p>
<p>Evidently, the Go team didn&#39;t <em>want</em> to design a language. What they really
liked was their async runtime. And they wanted to be able to implement TCP, and
HTTP, and TLS, and HTTP/2, and DNS, etc., on top of it. And then web services on
top of all of that.</p>
<p>And so they didn&#39;t. They didn&#39;t design a language. It sorta just &#34;happened&#34;. </p>
<p>Because it needed to be familiar to &#34;Googlers, fresh out of school, who probably
learned some Java/C/C++/Python&#34; (Rob Pike, Lang NEXT 2014), it borrowed from all
of these.</p>
<p>Just like C, it doesn&#39;t concern itself with error handling <em>at all</em>. Everything
is a big furry ball of mutable state, and it&#39;s on you to add ifs and elses to
VERY CAREFULLY (and very manually) ensure that you do not propagate invalid
data.</p>
<p>Just like Java, it tries to erase the distinction between &#34;value&#34; and
&#34;reference&#34;, and so it&#39;s impossible to tell from the callsite if something is
getting mutated or not:</p>
<div><p>Go code</p><pre data-lang="go"><i>import</i> <i>&#34;fmt&#34;</i>

<i>type</i> <i>A</i> <i>struct</i> {
	<i>Value</i> <i>int</i>
}

<i>func</i> <i>main</i>() {
	<i>a</i> <i>:=</i> <i>A</i>{<i>Value</i>: 1}
	<i>a</i>.<i>Change</i>()
	<i>fmt</i>.<i>Printf</i>(<i>&#34;a.Value = %d\n&#34;</i>, <i>a</i>.<i>Value</i>)
}
</pre></div>
<p>Depending on whether the signature for change is this:</p>
<div><p>Go code</p><pre data-lang="go"><i>func</i> (<i>a</i> <i>A</i>) <i>Change</i>() {
	<i>a</i>.<i>Value</i> <i>=</i> 2
}
</pre></div>
<p>Or this:</p>
<div><p>Go code</p><pre data-lang="go"><i>func</i> (<i>a</i> <i>*</i><i>A</i>) <i>Change</i>() {
	<i>a</i>.<i>Value</i> <i>=</i> 2
}
</pre></div>
<p>...the local <code>a</code> in <code>main</code> will either get mutated or not.</p>
<p>And since, just like C <em>and</em> Java, you do not get to decide what is mutable and
what is immutable (the <code>const</code> keyword in C is essentially advisory), passing a
reference to something (to avoid a costly copy, for example) is fraught with
risk, like it getting mutated from under you, or it being held somewhere
forever, preventing it from being freed (a lesser, but very real, problem).</p>
<p>Go fails to prevent many other classes of errors: it makes it easy to
accidentally <a href="https://scattered-thoughts.net/articles/a-rust-match-made-in-hell">copy a mutex</a>, rendering it
completely ineffective, or leaving struct fields uninitialized (or rather,
initialized to their zero value), resulting in countless logic errors.</p>
<p>Taken in isolation, each of these and more can be dismissed as &#34;just a thing to
be careful about&#34;. And breaking down an argument to its smallest pieces,
rebutting them one by one, is a self-defense tactic used by those who cannot
afford to adjust their position in the slightest.</p>
<p>Which makes perfect sense, because Go is really hard to move away from.</p>
<h2>Go is an island</h2>
<p>Unless you use cgo, (but <a href="https://dave.cheney.net/2016/01/18/cgo-is-not-go">cgo is not
Go</a>), you are living in the
Plan 9 cinematic universe.</p>
<p>The Go toolchain does not use the assembly language everyone else knows about.
It does not use the linkers everyone else knows about. It does not let you use
the debuggers everyone knows about, the <a href="https://valgrind.org/">memory checkers</a>
everyone knows about, or the calling conventions everyone else has agreed to
suffer, in the interest of interoperability.</p>
<p>Go is closer to
<a href="https://en.wikipedia.org/wiki/Open-world_assumption">closed-world</a> languages
than it is to C or C++. Even Node.js, Python and Ruby are not as hostile to
<a href="https://en.wikipedia.org/wiki/Foreign_function_interface">FFI</a>.</p>
<p>To a large extent, this is a feature: being different is <em>the point</em>. And it
comes with its benefits. Being able to profile the internals of the TLS and HTTP
stacks the same way you do your business logic is fantastic. (Whereas in dynamic
languages, the stack trace stops at OpenSSL). And that code takes full advantage
of the lack of function coloring: it can let the <em>runtime</em> worried about
non-blocking I/O and scheduling.</p>
<p>But it comes at a terrible cost, too. There is excellent tooling out there for
many things, which you cannot use with Go (you can use it for the cgo parts,
but again, you should not use cgo if you want the Real Go Experience). All the
&#34;institutional knowledge&#34; there is lost, and must be relearned from scratch.</p>
<p>It also makes it extremely hard to integrate Go with anything else, whether it&#39;s
upstream (calling C from Go) or downstream (calling Go from Ruby). Both these
scenarios involve cgo, or, if you&#39;re unreasonably brave, <a href="https://words.filippo.io/rustgo/">a terrifying
hack</a>.</p>
<p><em>Note: as of Go 1.13, <a href="https://go.dev/doc/go1.13">binary-only packages are no longer supported</a></em></p>
<p>Making Go play nice with another language (any other language) is really hard.
Calling C from Go, nevermind the cost of crossing the FFI boundary, involves
<a href="https://pkg.go.dev/cmd/cgo#hdr-Passing_pointers">manual descriptor tracking</a>,
so as to not break the GC. (WebAssembly had the same problem before <a href="https://github.com/WebAssembly/reference-types/blob/master/proposals/reference-types/Overview.md">reference
types</a>!)</p>
<p>Calling Go from <em>anything</em> involves shoving the whole Go runtime (GC included)
into whatever you&#39;re running: expect a very large static library and all the
operational burden of running Go code as a regular executable.</p>
<p>After spending years doing those FFI dances in both directions, I&#39;ve reached the
conclusion that <strong>the only good boundary with Go is a network boundary</strong>. </p>
<p>Integrating with Go is <em>relatively painless</em> if you can afford to pay the
latency cost of doing RPC over TCP (whether it&#39;s a REST-ish HTTP/1 API,
something like JSON-RPC, a more complicated scheme like GRPC, etc.). It&#39;s also
the only way to make sure it doesn&#39;t &#34;infect&#34; your whole codebase.</p>
<p>But even that is costly: you need to maintain invariants on both sides of the
boundary. In Rust, one would typically reach for something like
<a href="https://serde.rs/">serde</a> for that, which, combined with sum types and the lack
of zero values, lets you make <em>reasonably sure</em> that what you&#39;re holding is what
you think you&#39;re holding: if a number is zero, it was meant to be zero, it
wasn&#39;t just missing.</p>
<p>(All this goes out the window if you use a serialization format like
<a href="https://developers.google.com/protocol-buffers">protobuf</a>, which has all the
drawbacks of Go&#39;s type system and none of the advantages).</p>
<p>That still leaves you with the Go side of things, where unless you use some sort
of <a href="https://go-ozzo.github.io/ozzo-validation/">validation package</a> religiously,
you need to be ever vigilant not to let bad data slip in, because the compiler
does <em>nothing</em> to help you maintain those invariants.</p>
<p>And that brings us to the larger overall problem of the Go <em>culture</em>.</p>
<h2>All or nothing (so let&#39;s do nothing)</h2>
<p>I&#39;ve mentioned &#34;leaving struct fields uninitialized&#34;. This happens easily when
you make a code change from something like this:</p>
<div><p>Go code</p><pre data-lang="go"><i>package</i> main

<i>import</i> <i>&#34;log&#34;</i>

<i>type</i> <i>Params</i> <i>struct</i> {
	<i>a</i> <i>int32</i>
}

<i>func</i> <i>work</i>(<i>p</i> <i>Params</i>) {
	<i>log</i>.<i>Printf</i>(<i>&#34;Working with a=%v&#34;</i>, <i>p</i>.<i>a</i>)
}

<i>func</i> <i>main</i>() {
	<i>work</i>(<i>Params</i>{
		<i>a</i>: 47,
	})
}
</pre></div>
<p>To something like this:</p>
<div><p>Go code</p><pre data-lang="go"><i>package</i> main

<i>import</i> <i>&#34;log&#34;</i>

<i>type</i> <i>Params</i> <i>struct</i> {
	<i>a</i> <i>int32</i>
	<i>b</i> <i>int32</i>
}

<i>func</i> <i>work</i>(<i>p</i> <i>Params</i>) {
	<i>log</i>.<i>Printf</i>(<i>&#34;Working with a=%v, b=%v&#34;</i>, <i>p</i>.<i>a</i>, <i>p</i>.<i>b</i>)
}

<i>func</i> <i>main</i>() {
	<i>work</i>(<i>Params</i>{
		<i>a</i>: 47,
	})
}
</pre></div>
<p>That second program prints this:</p>
<div><pre data-lang="">2009/11/10 23:00:00 Working with a=47, b=0
</pre></div>
<p>We&#39;ve essentially changed the function signature, but forgot to update a
callsite. This doesn&#39;t bother the compiler at all.</p>
<p>Oddly enough, if our function was structured like this:</p>
<div><p>Go code</p><pre data-lang="go"><i>package</i> main

<i>import</i> <i>&#34;log&#34;</i>

<i>func</i> <i>work</i>(<i>a</i> <i>int32</i>, <i>b</i> <i>int32</i>) {
	<i>log</i>.<i>Printf</i>(<i>&#34;Working with a=%v, b=%v&#34;</i>, <i>p</i>.<i>a</i>, <i>p</i>.<i>b</i>)
}

<i>func</i> <i>main</i>() {
	<i>work</i>(47)
}
</pre></div>
<p>Then we&#39;d get a compile error:</p>
<div><pre data-lang="">./prog.go:6:40: undefined: p
./prog.go:10:7: not enough arguments in call to work
	have (number)
	want (int32, int32)

Go build failed.
</pre></div>
<p>Why does the Go compiler suddenly care if we provide explicit values now? If the
language was self-consistent, it would let me omit both parameters, and just
default to zero.</p>
<p>Because one of the tenets of Go is that zero values are good, actually.</p>
<p>See, they let you go fast. If you <em>did</em> mean for <code>b</code> to be zero, you can just
not specify it.</p>
<p>And sometimes it works fine, because zero values <em>do</em> mean something:</p>
<div><p>Go code</p><pre data-lang="go"><i>package</i> main

<i>import</i> <i>&#34;log&#34;</i>

<i>type</i> <i>Container</i> <i>struct</i> {
	<i>Items</i> []<i>int32</i>
}

<i>func</i> (<i>c</i> <i>*</i><i>Container</i>) <i>Inspect</i>() {
	<i>log</i>.<i>Printf</i>(<i>&#34;We have %v items&#34;</i>, <i>len</i>(<i>c</i>.<i>Items</i>))
}

<i>func</i> <i>main</i>() {
	<i>var</i> <i>c</i> <i>Container</i>
	<i>c</i>.<i>Inspect</i>()
}
</pre></div><div><pre data-lang="">2009/11/10 23:00:00 We have 0 items

Program exited.
</pre></div>
<p>This is fine! Because the <code>[]int32</code> slice is actually a reference type, and its
zero value is <code>nil</code>, and <code>len(nil)</code> just returns zero, because &#34;obviously&#34;, a
nil slice is empty.</p>
<p>And sometimes it&#39;s <em>not</em> fine, because zero values don&#39;t mean what you think
they mean:</p>
<div><p>Go code</p><pre data-lang="go"><i>package</i> main

<i>type</i> <i>Container</i> <i>struct</i> {
	<i>Items</i> <i>map</i>[<i>string</i>]<i>int32</i>
}

<i>func</i> (<i>c</i> <i>*</i><i>Container</i>) <i>Insert</i>(<i>key</i> <i>string</i>, <i>value</i> <i>int32</i>) {
	<i>c</i>.<i>Items</i>[<i>key</i>] <i>=</i> <i>value</i>
}

<i>func</i> <i>main</i>() {
	<i>var</i> <i>c</i> <i>Container</i>
	<i>c</i>.<i>Insert</i>(<i>&#34;number&#34;</i>, 32)
}
</pre></div><div><pre data-lang="">panic: assignment to entry in nil map

goroutine 1 [running]:
main.(*Container).Insert(...)
	/tmp/sandbox115204525/prog.go:8
main.main()
	/tmp/sandbox115204525/prog.go:13 +0x2e

Program exited.
</pre></div>
<p>In that case, you should&#39;ve initialized the map first (which is also <em>actually</em>
a reference type), with <code>make</code>, or with a map literal.</p>
<p>That alone is enough to cause incidents and outages that wake people up at
night, but everything gets worse real fast when you consider the <a href="https://dave.cheney.net/2014/03/19/channel-axioms">Channel
Axioms</a>:</p>
<ul>
<li>A send to a <code>nil</code> channel blocks forever</li>
<li>A receive from a <code>nil</code> channel blocks forever</li>
<li>A send to a closed channel panics</li>
<li>A receive from a closed channel returns the zero value immediately</li>
</ul>
<p>Because <em>there had to be a meaning</em> for nil channels, this is what was picked.
Good thing there&#39;s pprof to find those deadlocks!</p>
<p>And because there&#39;s no way to &#34;move&#34; out of values, there has to be meaning for
receiving and sending to closed channels, too, because even after you close them
<em>you can still interact with them</em>.</p>
<p>(Whereas in a language like Rust, a channel closes when its
<a href="https://doc.rust-lang.org/stable/std/sync/mpsc/struct.Sender.html">Sender</a> is
dropped, which only happens when <em>nobody can touch it again, ever</em>. The same probably
applies to C++ and a bunch of other languages, this is not new stuff).</p>
<p>&#34;Zero values have meaning&#34; is naive, and clearly untrue when you consider the
inputs of, like... almost everything. There&#39;s so many situations when values
need to be &#34;one of these known options, and nothing else&#34;, and that&#39;s where
sum types come in (in Rust, that&#39;s <a href="https://scattered-thoughts.net/articles/peeking-inside-a-rust-enum">enums</a>).</p>
<p>And Go&#39;s response to that is: just be careful. Just like C&#39;s response before it.</p>
<p>Just don&#39;t access the return value if you haven&#39;t checked the error value. Just
have a half-dozen people carefully review each trivial code change to make sure
you&#39;re not accidentally propagating a nil, zero, or empty string way too deep
into your system.</p>
<p>It&#39;s just another thing watch out for.</p>
<p>It&#39;s not like you can prevent <em>all</em> problems anyway.</p>
<p>That is true! There&#39;s a ton of things to watch out for, always. Something as
simple as <a href="https://scattered-thoughts.net/articles/downloads-gone-wrong">downloading a file to disk</a>... isn&#39;t!
At all!</p>
<p>And you can write logic errors in just about every language! And if you try hard
enough I&#39;m sure you can drive a train straight into a tree! It&#39;s just much
easier with a car.</p>
<p>The fallacy here is that because it is impossible to solve <em>everything</em>, we
shouldn&#39;t even attempt to solve <em>some of it</em>. By that same logic, it&#39;s always
worthless to support any individual financially, because it does nothing to help
every <em>other</em> individual who&#39;s struggling.</p>
<p>And this is another self-defense tactic: to refuse to consider anything but the
most extreme version of a position, and point out how ridiculous it is (ignoring
the fact that nobody is actually defending that ridiculous, extreme position).</p>
<p>So let&#39;s talk about that position.</p>
<h2>&#34;Rust is perfect and you&#39;re all idiots&#34;</h2>
<p>I <em>so wish</em> that was how I felt, because it would be so much simpler to explain.</p>
<p>That fantasy version of my argument is so easy to defeat, too. &#34;How come you use
Linux then? That&#39;s written in C&#34;. &#34;Unsafe Rust is incredibly hard to write
correctly, how do you feel about that?&#34;</p>
<p>The success of Go is due in large part to it having batteries included and
opinionated defaults.</p>
<p>The success of Rust is due in large part to it being easy to adopt piecemeal
and <em>playing nice with others</em>.</p>
<p>They are both success stories, just very different ones.</p>
<p>If the boogeymen (it&#39;s always men) are to be believed, &#34;Rust shills&#34; would have
everyone immediately throw away everything, and replace it with The Only Good
Language Out there.</p>
<p>This is <em>so very far</em> from what&#39;s happening in the real world, it&#39;s tragic.</p>
<p>Firefox is largely a C++ codebase, but ships <a href="https://wiki.mozilla.org/Oxidation#Shipped">several crucial
components</a> in Rust.  The Android
project recently <a href="https://www.reddit.com/r/rust/comments/mgz7y5/androids_new_bluetooth_stack_rewrite_gabeldorsh/">reimplemented its entire Bluetooth stack in
Rust</a>.
Rust cryptography code has found its way into Python, Rust HTTP code has found its way
into curl (as one of many available backends), and the Linux kernel <a href="https://www.phoronix.com/scan.php?page=news_item&amp;px=Rust-For-Linux-Kernel-v4">Rust patches</a> are looking better every round.</p>
<p>None of these are without challenges, and none of the people involved are
denying said challenges. But all of these are incremental and pragmatic, very
progressively porting parts to a safer language <em>where it makes sense</em>.</p>
<p>We are very far from a &#34;throwing the baby out with the bathwater&#34; approach. The
Rust codegen backend <em>literally everyone uses</em> is a mountain of C++ code (LLVM).
The alternatives are not competitors by any stretch of the imagination, except
maybe for <a href="https://github.com/rust-lang/rustc_codegen_gcc">another mountain of C++
code</a>.</p>
<p>The most hardcore Rust users are the most vocal about issues like build times,
the lack of certain language features (I just want
<a href="https://blog.rust-lang.org/2021/08/03/GATs-stabilization-push.html">GATs</a>!),
and all the other shortcomings everyone else is also talking about.</p>
<p>And they&#39;re also the first to be on the lookout for other, newer languages, that
tackle the same kind of problems, but do it <em>even better</em>.</p>
<p>But as with the &#34;questioning your credentials&#34; angle, <em>this is all irrelevant</em>.
The current trends could be dangerous snake oil and we could have literally no
decent alternative, and <em>it would still be worth talking about</em>. No matter who
raises the point!</p>
<p>Creating false dichotomies isn&#39;t going to help resolve any of this.</p>
<p>Folks who develop an allergic reaction to &#34;big balls of mutable state without
sum types&#34; tend to gravitate towards languages that gives them control over
mutability, lifetimes, and lets them build abstractions. That those languages
happen to often be Go and Rust is immaterial. Sometimes it&#39;s C and Haskell.
Sometimes it&#39;s ECMAScript and Elixir. I can&#39;t speak to those, but they do
happen.</p>
<p>You don&#39;t have to choose between &#34;going fast&#34; and &#34;modelling literally every
last detail of the problem space&#34;. And you&#39;re not stuck doing one or the other
if you choose Go or Rust.</p>
<p>You can, at great cost, write extremely careful Go code that stays far away from
stringly-typed values and constantly checks invariants — you just get no help
from the compiler whatsoever.</p>
<p>And you can, fairly easily, decide not to care about a whole bunch of cases when
writing Rust code. For example, if you&#39;re not writing a low-level command-line
utility like <code>ls</code>, you can decide to only care about paths that are valid UTF-8
strings by using <a href="https://lib.rs/crates/camino">camino</a>.</p>
<p>When handling errors, it is extremely common to list a few options we <em>do</em> care
about and want to do special handling for, and shove everything else into an
&#34;Other&#34; or &#34;Internal&#34; or &#34;Unknown&#34; variant, which we can flesh out later as
needed, when reviewing logs. </p>
<p>The &#34;correct&#34; way to assume an optional value is set is to <em>assert that it is</em>,
not to use it regardless. That&#39;s the difference between calling <code>json.Unmarshal</code>
and crossing your fingers, and calling
<a href="https://doc.rust-lang.org/stable/std/option/enum.Option.html#method.unwrap">unwrap()</a>
on an <code>Option&lt;T&gt;</code>.</p>
<p>And it&#39;s so much easier to do it correctly when the type system lets you spell
out what the options are — even when it&#39;s as simple as &#34;ok&#34; or &#34;not ok&#34;.</p>
<p>Which brings me to the next argument, by far the most reasonable of the bunch.</p>
<h2>Go as a prototyping/starter language</h2>
<p>We&#39;ve reached the fifth stage of grief: acceptance.</p>
<p><em>Fine</em>. It may well be that Go is not adequate for production services unless
your shop is literally made up of Go experts (Tailscale) or you have infinite
money to spend on engineering costs (Google).</p>
<p>But surely there&#39;s still a place for it.</p>
<p>After all, Go is an easy language to pick up (because it&#39;s so small, right?),
and a lot of folks have learned it by now, so it&#39;s easy to recruit Go
developers, so we can get lots of them on the cheap and just uhhh prototype a
few systems?</p>
<p>And then later when things get hard (as they always do at scale) we&#39;ll either
rewrite it to something else, or we&#39;ll bring in experts, we&#39;ll figure something
out.</p>
<p>Except there is no such thing as throwaway code.</p>
<p>All engineering organizations I&#39;ve ever seen are EXTREMELY rewrite-averse, and
for good reason! They take time, orchestrating a seamless transition is hard,
details get lost in the shuffle, you&#39;re not shipping new features while you&#39;re
doing that, you have to retrain your staff to be effective at the new thing,
etc.</p>
<p>Tons of good, compelling reasons.</p>
<p>So very few things eventually end up being rewritten. And as more and more
components get written in Go, there&#39;s more and more reason to <em>keep</em> doing that:
not because it&#39;s working particularly well for you, but because interacting with
the existing codebases from <em>literally anything else</em> is so painful (except over
the network, and even then.. see &#34;Go is an island&#34; above).</p>
<p>So things essentially never improve. All the Go pitfalls, all the things the
language and compiler <em>doesn&#39;t help you prevent</em>, are an issue for everyone,
fresh or experienced. Linters help some, but can never do quite as much as
compiler for languages that took these problems seriously to begin with. <em>And</em>
they slow down development, cutting into the &#34;fast development&#34; promise. </p>
<p>All the complexity that doesn&#39;t live in the language now lives in your codebase.
All the invariants you don&#39;t have to spell out using types, you now have to
spell out using code: the signal-to-noise ratio of your (very large) codebases
is extremely poor.</p>
<p>Because it has been decided that abstractions are for academics and fools, and
all you <em>really</em> need is slices and maps and channels and funcs and structs, it
becomes extremely hard to follow what any program is doing at a high level,
because everywhere you look, you get bogged down in imperative code doing
trivial data manipulation or error propagation.</p>
<p>Because function signatures don&#39;t tell you much of anything (does this mutate
data? does it hold onto it? is a zero value there okay? does it start a
goroutine? can that channel be nil? what types can I really pass for this
<code>interface{}</code> param?), you rely on documentation, which is costly to update, and
costlier still <em>not</em> to update, resulting in more and more bugs.</p>
<p>The very reason I don&#39;t consider Go a language &#34;suitable for beginners&#34; is
precisely that its compiler accepts so much code that is very clearly wrong.</p>
<p>It takes a lot of experience about everything <em>around</em> the language, everything
Go willfully leaves as an exercise to the writer, to write semi-decent Go code,
and even then, I consider it more effort than it&#39;s worth.</p>
<p>The &#34;worse is better&#34; debate was never about some people wanting to feel
superior by adding needless complexity, then mastering it.</p>
<p>Quite the contrary, it&#39;s an admission that humans suck at maintaining
invariants. All of us. But we are capable of building tools that can help us
doing that. And focusing our efforts on that has an upfront cost, but that cost
is well worth it.</p>
<p>I thought we&#39;d moved past the notion that &#34;programming is typing on a keyboard&#34;
long ago, but when I keep reading &#34;but it&#39;s fast to write lots of Go!&#34;, I&#39;m not
so sure.</p>
<p>Inherent complexity does not go away if you close your eyes.</p>
<p>When you choose not to care about complexity, you&#39;re merely pushing it onto
other developers in your org, ops people, your customers, <em>someone</em>. Now
<em>they</em> have to work around your assumptions to make sure everything keeps
running smoothly.</p>
<p>And nowadays, I&#39;m often that <em>someone</em>, and I&#39;m tired of it.</p>
<p>Because there is a lot to like in Go at first, because it&#39;s so easy to pick up,
but so hard to move away from, and because the cost of choosing it in the first
place reveals itself slowly over time, and compounds, only becoming unbearable
when it&#39;s much too late, this is not a discussion we can afford to ignore as an
industry.</p>
<p>Until we demand better of our tools, we are doomed to be woken up in the middle
of the night, over and over again, because some <code>nil</code> value slipped in where it
never should have.</p>
<p>It&#39;s the <a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/">Billion Dollar
Mistake</a>
all over again.</p>
<div>

<p>Here&#39;s a list of lies we tell ourselves to keep using Golang:</p>
<ul>
<li>Others use it, so it must be good for us too</li>
<li>Everyone who has concerns about it is an elitist jerk</li>
<li>Its attractive async runtime and GC make up for everything else</li>
<li>Every language design flaw is ok in isolation, and ok in aggregate too</li>
<li>We can overcome these by &#34;just being careful&#34; or adding more linters/eyeballs</li>
<li>Because it&#39;s easy to write, it&#39;s easy to develop production software with</li>
<li>Because the language is simple, everything else is, too</li>
<li>We can do just a little of it, or just at first, or we can move away from it easily</li>
<li>We can always rewrite it later</li>
</ul>
</div>

</div><div>
  
    
    
  

  

  

  


  







<div>
    <h2>Latest video</h2>









<div>
    
        
        
        
            
        

        

        

        
        
        
        
        
            
        
        
         
        
            
        
        
            
        
        <div>
            <a href="https://scattered-thoughts.net/videos/getting-good-at-snes">
                
                    
                    <div>
                        <picture>
                            <source type="image/avif" srcset="https://tube.fasterthanli.me/covers/joy/cover.avif"/>
                            <source type="image/webp" srcset="https://tube.fasterthanli.me/covers/joy/cover.webp"/>
                            <img alt="video cover image" src="https://tube.fasterthanli.me/covers/joy/cover.jpg"/>
                        </picture>
                    </div>
                

                <span>
                    
                        
                        Getting good at SNES games through DLL injection
                    
                </span>
            </a>
            <div>
                <div>
                    <div>
                        <p>Apr 25, 2022</p>
                        
                            
                                
                                    <p>
                                        19 minute watch
                                    </p>
                                
                            
                        

                        
                            
                            
                        

                        
                        
                        
                            
                        
                        

                        
                        
                    </div>
                </div>

                <div>
                    
                        
                            
                            <p>Are you ever confronted with a problem and then think to yourself &#34;wait a minute,
I know how to code?&#34; — that&#39;s exactly what happened there.</p>
                        
                    
                </div>

                
                    <p><a href="https://scattered-thoughts.net/videos/getting-good-at-snes">
                        <span>
                            
                                Watch now
                            
                        </span>
                    </a>
                
            </p></div>
        </div>
    
</div>


    <p>You can watch more videos <a href="https://scattered-thoughts.net/videos">over there</a></p>
</div> <!-- Latest video -->

  
</div></div>
  </body>
</html>
