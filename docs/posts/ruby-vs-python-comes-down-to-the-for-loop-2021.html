<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://softwaredoug.com/blog/2021/11/12/ruby-vs-python-for-loop.html">Original</a>
    <h1>Ruby vs. Python comes down to the for loop (2021)</h1>
    
    <div id="readability-page-1" class="page"><div>
	  <p>So much of how Ruby and Python differ comes down to the <code>for</code> loop.</p>

<p>Python embraces <code>for</code>. Objects tell <code>for</code> how to  work with them, and the for loop’s body processes what’s given back by the object. Ruby does the opposite. In Ruby, <code>for</code> itself (via <code>each</code>) is a method of the Object. The caller passes the body of the for loop to this method.</p>

<p>With idiomatic Python, the object-model submits to the for loop. In Ruby’s case, the for loop submits to the object-model.</p>

<p>That is to say, in Python, if you wish to customize iteration, an object tells the language how it should be iterated:</p>

<div><div><pre><code><span>class</span> <span>Stuff</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>):</span>
        <span>self</span><span>.</span><span>a_list</span> <span>=</span> <span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>]</span>
        <span>self</span><span>.</span><span>position</span> <span>=</span> <span>0</span>
    <span>def</span> <span>__next__</span><span>(</span><span>self</span><span>):</span>
        <span>try</span><span>:</span>
            <span>value</span> <span>=</span> <span>self</span><span>.</span><span>a_list</span><span>[</span><span>self</span><span>.</span><span>position</span><span>]</span>
            <span>self</span><span>.</span><span>position</span> <span>+=</span> <span>1</span>
            <span>return</span> <span>value</span>
        <span>except</span> <span>IndexError</span><span>:</span>
            <span>self</span><span>.</span><span>position</span> <span>=</span> <span>0</span>
            <span>raise</span> <span>StopIteration</span>
    <span>def</span> <span>__iter__</span><span>(</span><span>self</span><span>):</span>
        <span>return</span> <span>self</span>
</code></pre></div></div>

<p>Here <code>Stuff</code> uses methods <code>__next__</code> and <code>__iter__</code> to make itself iterable.</p>

<div><div><pre><code><span>for</span> <span>data</span> <span>in</span> <span>Stuff</span><span>():</span>
    <span>print</span><span>(</span><span>data</span><span>)</span>
</code></pre></div></div>

<p>In idiomatic Ruby, however, you do something quite the opposite. You create <code>for</code> itself as a method, and it accepts code (the body) to run. Ruby puts procedural code in blocks so they can be passed around. Then in your <code>each</code> method you interact with the block using <code>yield</code>, passing the value into the block to do what you need (the block is kind of an implicit argument on any method).</p>

<p>If we rewrote the code above, it would be</p>

<div><div><pre><code><span>class</span> <span>Stuff</span>
  <span>def</span> <span>initialize</span>
    <span>@a_list</span> <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>]</span>
  <span>end</span>

  <span>def</span> <span>each</span>
    <span>for</span> <span>item</span> <span>in</span> <span>@a_list</span>
      <span>yield</span> <span>item</span>
    <span>end</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<p>Using <code>each</code> to iterate:</p>

<div><div><pre><code><span>Stuff</span><span>.</span><span>new</span><span>().</span><span>each</span> <span>do</span> <span>|</span><span>item</span><span>|</span>
  <span>puts</span> <span>item</span>
<span>end</span>
</code></pre></div></div>

<p>Instead of passing data back to the for loop (Python) you pass the code to the data (Ruby).</p>

<p>But it goes deeper than this:</p>

<p>Python builds on <code>for</code>-like constructs for all kinds of processing; Ruby pushes other kinds of data processing work to methods.</p>

<p>Pythonic code uses list and dictionary comprehensions to implement  map and filter, with the same for/iteration semantics at the core of those expressions.</p>

<div><div><pre><code><span>In</span> <span>[</span><span>2</span><span>]:</span> <span>[</span><span>item</span> <span>for</span> <span>item</span> <span>in</span> <span>Stuff</span><span>()]</span>
<span>Out</span><span>[</span><span>2</span><span>]:</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>]</span>

<span>In</span> <span>[</span><span>3</span><span>]:</span> <span>[</span><span>item</span> <span>for</span> <span>item</span> <span>in</span> <span>Stuff</span><span>()</span> <span>if</span> <span>item</span> <span>%</span> <span>2</span> <span>==</span> <span>0</span><span>]</span>
<span>Out</span><span>[</span><span>3</span><span>]:</span> <span>[</span><span>2</span><span>,</span> <span>4</span><span>]</span>
</code></pre></div></div>

<p>Ruby keeps going with its methods-first approach, except instead of <code>each</code> we have  a new set of methods commonly implemented on collections, as below:</p>

<div><div><pre><code><span>class</span> <span>Stuff</span>
  <span>...</span>

  <span>def</span> <span>select</span>
    <span>out</span> <span>=</span> <span>[]</span>
    <span>each</span> <span>do</span> <span>|</span><span>e</span><span>|</span>
      <span># If block returns truthy on e, append to out</span>
      <span>if</span> <span>yield</span><span>(</span><span>e</span><span>)</span>
        <span>out</span> <span>&lt;&lt;</span> <span>e</span>
      <span>end</span>
    <span>end</span>
    <span>out</span>
  <span>end</span>

  <span>def</span> <span>map</span>
    <span>out</span> <span>=</span> <span>[]</span>
    <span># One line block syntax, append output of block processed on e to out</span>
    <span>each</span> <span>{</span><span>|</span><span>e</span><span>|</span> <span>out</span> <span>&lt;&lt;</span> <span>yield</span><span>(</span><span>e</span><span>)</span> <span>}</span> 
    <span>out</span>
<span>end</span>
</code></pre></div></div>

<div><div><pre><code><span>puts</span> <span>Stuff</span><span>.</span><span>new</span><span>().</span><span>map</span> <span>{</span><span>|</span><span>item</span><span>|</span> <span>item</span><span>}</span>
<span>puts</span> <span>Stuff</span><span>.</span><span>new</span><span>().</span><span>select</span><span>{</span><span>|</span><span>item</span><span>|</span> <span>item</span><span>.</span><span>even?</span><span>}</span>
</code></pre></div></div>

<p>Python says “you tell us how to iterate your instances, we’ll decide what we do with your data.” Python has a few language based primitives for iteration and processing, and to customize that iteration we simply add the right code to the for loop’s (or expressions) body.</p>

<p>Ruby flips the script, giving the objects deeper customizability. Yes in some cases we could simply add more control flow inside blocks. Yes, we could bend our usage of <code>each</code> to basically do <code>map</code>. But Ruby lets objects give different <code>map</code> and <code>each</code> implementations (perhaps “each”’s implementation would be very suboptimal, or even unsafe, if used for “map”). Ruby objects can be much more forward about the best ways to process its data.</p>

<p>In Ruby, the objects control the affordances. In Python, the language does.</p>

<p>Idiomatic Python has strong opinions about data processing. Python says “look, 90% of your code will fit neatly into these ideas, just conform to it and get your work done.” Just make your objects for-loopable and get out of my hair. However Ruby says “there will be important cases where we don’t want to give the caller that much power”. So Ruby encourages objects to control how they’re processed and developers are encouraged to fall in line to how the objects want to be interacted with. Ruby chooses expressiveness with fewer opinions about data.</p>

<p>Python feels more like an extension of C-based “object oriented” programming. In C-based OO, like with  <a href="https://en.wikipedia.org/wiki/File_descriptor">posix file descriptors</a> or <a href="https://stackoverflow.com/questions/2334966/win32-application-arent-so-object-oriented-and-why-there-are-so-many-pointers">Win32 window handles</a> the language doesn’t enforce bundling ‘methods’ with the object itself. Rather the object-to-method bundling happens out of convention. Python thinks this procedural world can be evolved - it upgrades this mindset to make it safer. Free functions exist, and indeed, are often encouraged over methods. Objects exist, but in a more hesitant way. Methods accept “self” as their first parameter, almost in the same way C functions in Win32 or Posix API accept a handle. When functions get passed around, they are treated almost like C function pointers. The procedural paradigm comes first and serves as the crucial foundation for everything, with object oriented semantics layered on top.</p>

<p>Ruby, however, inverts this. Ruby puts object-orientation as the foundation of the pyramid. Ruby contains the messy procedural world in blocks, letting objects work with those procedural blocks. Instead of breaking objects to conform to the language’s procedural foundation, Ruby makes procedural code fit into the object’s view of the world. Ruby has real privates, unlike Python which has private methods / parameters only out of convention.</p>

<p>It’s no wonder that Python felt natural to my brain when I came to it from a system-programming perspective. It evolved and made that world safer, with an ability to write C when needed. Perhaps that’s why it’s found its home in a system resource intensive numerical computing space.</p>

<p>It’s also no wonder that Ruby feels like a natural fit for developers building more fluent, perhaps safer, APIs and DSLs. Ruby wants programmers to model the domain, not the programming environment, and for many jobs this feels like the right approach.</p>

<p>A search developer like me, working at a <a href="http://engineering.shopify.com">Ruby shop</a> needs to navigate these differences. Maybe you’ll want to join me on this Ruby-Python-Search Adventure? Well then maybe <a href="https://jobs.smartrecruiters.com/ni/Shopify/bedf9119-9a23-4fd3-8d8a-7fcbf168eca9-senior-relevance-engineer-search-discovery">apply to this job</a> :-p</p>

      
      <p><small>

      Special Thanks to
       
      <a href="https://felipebesson.com/">Felipe Besson</a>, 

       
      <a href="https://sirupsen.com/">Simon Eskildsen</a> and

       
      <a href="http://blog.jnbrymn.com/">John Berryman</a>

      
      for reviewing this post and giving substantive edits and feedback!
      </small>
      


	  </p></div></div>
  </body>
</html>
