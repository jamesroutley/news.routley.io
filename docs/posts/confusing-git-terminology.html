<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jvns.ca/blog/2023/11/01/confusing-git-terminology/">Original</a>
    <h1>Confusing git terminology</h1>
    
    

<p>Hello! I&rsquo;m slowly working on explaining git. One of my biggest problems is that
after almost 15 years of using git, I&rsquo;ve become very used to git&rsquo;s
idiosyncracies and it&rsquo;s easy for me to forget what&rsquo;s confusing about it.</p>

<p>So I asked people <a href="https://social.jvns.ca/@b0rk/111330564535454510">on Mastodon</a>:</p>

<blockquote>
<p>what git jargon do you find confusing? thinking of writing a blog post that explains some of git&rsquo;s weirder terminology: &ldquo;detached HEAD state”, &ldquo;fast-forward&rdquo;, &ldquo;index/staging area/staged&rdquo;, “ahead of &lsquo;origin/main&rsquo; by 1 commit”, etc</p>
</blockquote>

<p>I got a lot of GREAT answers and I&rsquo;ll try to summarize some of them here.  Here&rsquo;s a list of the terms:</p>

<ul>
<li><a href="#head-and-heads">HEAD and &ldquo;heads&rdquo;</a></li>
<li><a href="#detached-head-state">&ldquo;detached HEAD state&rdquo;</a></li>
<li><a href="#ours-and-theirs-while-merging-or-rebasing">&ldquo;ours&rdquo; and &ldquo;theirs&rdquo; while merging or rebasing</a></li>
<li><a href="#your-branch-is-up-to-date-with-origin-main">&ldquo;Your branch is up to date with &lsquo;origin/main&rsquo;&rdquo;</a></li>
<li><a href="#head-head-head-head-head-2-head-2">HEAD^, HEAD~ HEAD^^, HEAD~~, HEAD^2, HEAD~2</a></li>
<li><a href="#and">.. and &hellip;</a></li>
<li><a href="#can-be-fast-forwarded">&ldquo;can be fast-forwarded&rdquo;</a></li>
<li><a href="#reference-symbolic-reference">&ldquo;reference&rdquo;, &ldquo;symbolic reference&rdquo;</a></li>
<li><a href="#refspecs">refspecs</a></li>
<li><a href="#tree-ish">&ldquo;tree-ish&rdquo;</a></li>
<li><a href="#index-staged-cached">&ldquo;index&rdquo;, &ldquo;staged&rdquo;, &ldquo;cached&rdquo;</a></li>
<li><a href="#reset-revert-restore">&ldquo;reset&rdquo;, &ldquo;revert&rdquo;, &ldquo;restore&rdquo;</a></li>
<li><a href="#untracked-files-remote-tracking-branch-track-remote-branch">&ldquo;untracked files&rdquo;, &ldquo;remote-tracking branch&rdquo;, &ldquo;track remote branch&rdquo;</a></li>
<li><a href="#checkout">checkout</a></li>
<li><a href="#reflog">reflog</a></li>
<li><a href="#merge-vs-rebase-vs-cherry-pick">merge vs rebase vs cherry-pick</a></li>
<li><a href="#rebase-onto">rebase &ndash;onto</a></li>
<li><a href="#commit">commit</a></li>
<li><a href="#more-confusing-terms">more confusing terms</a></li>
</ul>

<p>I&rsquo;ve done my best to explain what&rsquo;s going on with these terms, but they
cover basically every single major feature of git which is definitely too much
for a single blog post so it&rsquo;s pretty patchy in some places.</p>

<h3 id="head-and-heads"><code>HEAD</code> and &ldquo;heads&rdquo;</h3>

<p>A few people said they were confused by the terms <code>HEAD</code> and <code>refs/heads/main</code>,
because it sounds like it&rsquo;s some complicated technical internal thing.</p>

<p>Here&rsquo;s a quick summary:</p>

<ul>
<li>&ldquo;heads&rdquo; are &ldquo;branches&rdquo;. Internally in git, branches are stored in a directory called <code>.git/refs/heads</code>. (technically the <a href="https://git-scm.com/docs/gitglossary">official git glossary</a> says that the branch is all the commits on it and the head is just the most recent commit, but they&rsquo;re 2 different ways to think about the same thing)</li>
<li><code>HEAD</code> is the current branch. It&rsquo;s stored in <code>.git/HEAD</code>.</li>
</ul>

<p>I think that &ldquo;a <code>head</code> is a branch, <code>HEAD</code> is the current branch&rdquo; is a good
candidate for the weirdest terminology choice in git, but it&rsquo;s definitely too
late for a clearer naming scheme so let&rsquo;s move on.</p>

<p>There are some important exceptions to &ldquo;HEAD is the current branch&rdquo;, which we&rsquo;ll talk about next.</p>

<h3 id="detached-head-state">&ldquo;detached HEAD state&rdquo;</h3>

<p>You&rsquo;ve probably seen this message:</p>

<pre><code>$ git checkout v0.1
You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by switching back to a branch.

[...]
</code></pre>

<p>Here&rsquo;s the deal with this message:</p>

<ul>
<li>In Git, usually you have a &ldquo;current branch&rdquo; checked out, for example <code>main</code>.</li>
<li>The place the current branch is stored is called <code>HEAD</code>.</li>
<li>Any new commits you make will get added to your current branch, and if you run <code>git merge other_branch</code>, that will also affect your current branch</li>
<li>But <code>HEAD</code> doesn&rsquo;t <strong>have</strong> to be a branch! Instead it can be a commit ID.</li>
<li>Git calls this state (where HEAD is a commit ID instead of a branch) &ldquo;detached HEAD state&rdquo;</li>
<li>For example, you can get into detached HEAD state by checking out a tag, because a tag isn&rsquo;t a branch</li>
<li>if you don&rsquo;t have a current branch, a bunch of things break:

<ul>
<li><code>git pull</code> doesn&rsquo;t work at all (since the whole point of it is to update your current branch)</li>
<li>neither does <code>git push</code> unless you use it in a special way</li>
<li><code>git commit</code>, <code>git merge</code>, <code>git rebase</code>, and <code>git cherry-pick</code> <strong>do</strong> still
work, but they&rsquo;ll leave you with &ldquo;orphaned&rdquo; commits that aren&rsquo;t connected
to any branch, so those commits will be hard to find</li>
</ul></li>
<li>You can get out of detached HEAD state by either creating a new branch or switching to an existing branch</li>
</ul>

<h3 id="ours-and-theirs-while-merging-or-rebasing">&ldquo;ours&rdquo; and &ldquo;theirs&rdquo; while merging or rebasing</h3>

<p>If you have a merge conflict, you can run <code>git checkout --ours file.txt</code> to pick the version of <code>file.txt</code> from the &ldquo;ours&rdquo; side. But which side is &ldquo;ours&rdquo; and which side is &ldquo;theirs&rdquo;?</p>

<p>I always find this confusing and I never use <code>git checkout --ours</code> because of
that, but I looked it up to see which is which.</p>

<p>For merges, here&rsquo;s how it works: the current branch is &ldquo;ours&rdquo; and the branch
you&rsquo;re merging in is &ldquo;theirs&rdquo;, like this. Seems reasonable.</p>

<pre><code>$ git checkout merge-into-ours # current branch is &quot;ours&quot;
$ git merge from-theirs # branch we're merging in is &quot;theirs&quot;
</code></pre>

<p>For rebases it&rsquo;s the opposite &ndash; the current branch is &ldquo;theirs&rdquo; and the target branch we&rsquo;re rebasing onto is &ldquo;ours&rdquo;, like this:</p>

<pre><code>$ git checkout theirs # current branch is &quot;theirs&quot;
$ git rebase ours # branch we're rebasing onto is &quot;ours&quot;
</code></pre>

<p>I think the reason for this is that under the hood <code>git rebase main</code> is merging
the current branch into main (it&rsquo;s like <code>git checkout main; git merge current_branch</code>), but I still find it confusing.</p>

<p><a href="https://nitaym.github.io/ourstheirs/">This nice tiny site</a> explains the &ldquo;ours&rdquo; and &ldquo;theirs&rdquo; terms.</p>

<p>A couple of people also mentioned that VSCode calls &ldquo;ours&rdquo;/&ldquo;theirs&rdquo; &ldquo;current
change&rdquo;/&ldquo;incoming change&rdquo;, and that it&rsquo;s confusing in the exact same way.</p>

<h3 id="your-branch-is-up-to-date-with-origin-main">&ldquo;Your branch is up to date with &lsquo;origin/main&rsquo;&rdquo;</h3>

<p>This message seems straightforward &ndash; it&rsquo;s saying that your <code>main</code> branch is up
to date with the origin!</p>

<p>But it&rsquo;s actually a little misleading. You might think that this means that
your <code>main</code> branch is up to date. It doesn&rsquo;t. What it <strong>actually</strong> means is &ndash;
if you last ran <code>git fetch</code> or <code>git pull</code> 5 days ago, then your <code>main</code> branch
is up to date with all the changes <strong>as of 5 days ago</strong>.</p>

<p>So if you don&rsquo;t realize that, it can give you a false sense of security.</p>

<p>I think git could theoretically give you a more useful message like &ldquo;is up to
date with the origin&rsquo;s <code>main</code> <strong>as of your last fetch 5 days ago</strong>&rdquo; because the time
that the most recent fetch happened is stored in the reflog, but it doesn&rsquo;t.</p>

<h3 id="head-head-head-head-head-2-head-2"><code>HEAD^</code>, <code>HEAD~</code> <code>HEAD^^</code>, <code>HEAD~~</code>, <code>HEAD^2</code>, <code>HEAD~2</code></h3>

<p>I&rsquo;ve known for a long time that <code>HEAD^</code> refers to the previous commit, but I&rsquo;ve
been confused for a long time about the difference between <code>HEAD~</code> and <code>HEAD^</code>.</p>

<p>I looked it up, and here&rsquo;s how these relate to each other:</p>

<ul>
<li><code>HEAD^</code> and <code>HEAD~</code> are the same thing (1 commit ago)</li>
<li><code>HEAD^^^</code> and <code>HEAD~~~</code> and <code>HEAD~3</code> are the same thing (3 commits ago)</li>
<li><code>HEAD^3</code> refers the the third parent of a commit, and is different from <code>HEAD~3</code></li>
</ul>

<p>This seems weird &ndash; why are <code>HEAD~</code> and <code>HEAD^</code> the same thing? And what&rsquo;s the
&ldquo;third parent&rdquo;? Is that the same thing as the parent&rsquo;s parent&rsquo;s parent? (spoiler: it
isn&rsquo;t) Let&rsquo;s talk about it!</p>

<p>Most commits have only one parent. But merge commits have multiple parents  &ndash;
they&rsquo;re merging together 2 or more commits. In Git <code>HEAD^</code> means &ldquo;the parent of
the HEAD commit&rdquo;. But what if HEAD is a merge commit? What does <code>HEAD^</code> refer
to?</p>

<p>The answer is that <code>HEAD^</code> refers to the the <strong>first</strong> parent of the merge,
<code>HEAD^2</code> is the second parent, <code>HEAD^3</code> is the third parent, etc.</p>

<p>But I guess they also wanted a way to refer to &ldquo;3 commits ago&rdquo;, so <code>HEAD^3</code> is
the third parent of the current commit (which may have many parents if it&rsquo;s a merge commit), and <code>HEAD~3</code> is the parent&rsquo;s parent&rsquo;s
parent.</p>

<p>I think in the context of the merge commit ours/theirs discussion earlier, <code>HEAD^</code> is &ldquo;ours&rdquo; and <code>HEAD^2</code> is &ldquo;theirs&rdquo;.</p>

<h3 id="and"><code>..</code> and <code>...</code></h3>

<p>Here are two commands:</p>

<ul>
<li><code>git log main..test</code></li>
<li><code>git log main...test</code></li>
</ul>

<p>What&rsquo;s the difference between <code>..</code> and <code>...</code>? I never use these so I had to look it up in <a href="https://git-scm.com/docs/git-range-diff">man git-range-diff</a>. It seems like the answer is that in this case:</p>

<pre><code>A - B main
  \ 
    C - D test
</code></pre>

<ul>
<li><code>main..test</code> is commits C and D</li>
<li><code>test..main</code> is commit B</li>
<li><code>main...test</code> is commits B, C, and D</li>
</ul>

<p>But it gets worse: apparently <code>git diff</code> also supports <code>..</code> and <code>...</code>, but
they do something completely different than they do with <code>git log</code>? I think the summary is:</p>

<ul>
<li><code>git log test..main</code> shows changes on <code>main</code> that aren&rsquo;t on <code>test</code>, whereas <code>git log test...main</code> shows changes on <em>both</em> sides.</li>
<li><code>git diff test..main</code> shows <code>test</code> changes <em>and</em> <code>main</code> changes (it diffs <code>B</code> and <code>D</code>) whereas <code>git diff test...main</code> diffs <code>A</code> and <code>D</code> (it only shows you the diff on one side).</li>
</ul>

<p><a href="https://matthew-brett.github.io/pydagogue/pain_in_dots.html">this blog post</a> talks about it a bit more.</p>

<h3 id="can-be-fast-forwarded">&ldquo;can be fast-forwarded&rdquo;</h3>

<p>Here&rsquo;s a very common message you&rsquo;ll see in <code>git status</code>:</p>

<pre><code>$ git status
On branch main
Your branch is behind 'origin/main' by 2 commits, and can be fast-forwarded.
  (use &quot;git pull&quot; to update your local branch)
</code></pre>

<p>What does &ldquo;fast-forwarded&rdquo; mean? Basically it&rsquo;s trying to say that the two branches look something like this: (newest commits are on the right)</p>

<pre><code>main:        A - B - C
origin/main: A - B - C - D - E
</code></pre>

<p>or visualized another way:</p>

<pre><code>A - B - C - D - E (origin/main)
        |
       main
</code></pre>

<p>Here <code>origin/main</code> just has 2 extra commits that <code>main</code> doesn&rsquo;t have, so it&rsquo;s
easy to bring <code>main</code> up to date &ndash; we just need to add those 2 commits.
Literally nothing can possibly go wrong &ndash; there&rsquo;s no possibility of merge
conflicts. A fast forward merge is a very good thing! It&rsquo;s the easiest way to combine 2 branches.</p>

<p>After running <code>git pull</code>, you&rsquo;ll end up this state:</p>

<pre><code>main:        A - B - C - D - E
origin/main: A - B - C - D - E
</code></pre>

<p>Here&rsquo;s an example of a state which <strong>can&rsquo;t</strong> be fast-forwarded.</p>

<pre><code>             A - B - C - X  (main)
                     |
                     - - D - E  (origin/main)
</code></pre>

<p>Here <code>main</code> has a commit that <code>origin/main</code> doesn&rsquo;t have (<code>X</code>). So
you can&rsquo;t do a fast forward. In that case, <code>git status</code> would say:</p>

<pre><code>$ git status
Your branch and 'origin/main' have diverged,
and have 1 and 2 different commits each, respectively.
</code></pre>

<h3 id="reference-symbolic-reference">&ldquo;reference&rdquo;, &ldquo;symbolic reference&rdquo;</h3>

<p>I&rsquo;ve always found the term &ldquo;reference&rdquo; kind of confusing. There are at least 3 things that get called &ldquo;references&rdquo; in git</p>

<ul>
<li>branches and tags like <code>main</code> and <code>v0.2</code></li>
<li><code>HEAD</code>, which is the current branch</li>
<li>things like <code>HEAD^^^</code> which git will resolve to a commit ID. Technically these are probably not &ldquo;references&rdquo;, I guess git <a href="https://git-scm.com/docs/revisions">calls them</a> &ldquo;revision parameters&rdquo; but I&rsquo;ve never used that term.</li>
</ul>

<p>&ldquo;symbolic reference&rdquo; is a very weird term to me because personally I think the only
symbolic reference I&rsquo;ve ever used is <code>HEAD</code> (the current branch), and <code>HEAD</code>
has a very central place in git (most of git&rsquo;s core commands&rsquo; behaviour depends
on the value of <code>HEAD</code>), so I&rsquo;m not sure what the point of having it as a
generic concept is.</p>

<h3 id="refspecs">refspecs</h3>

<p>When you configure a git remote in <code>.git/config</code>, there&rsquo;s this <code>+refs/heads/main:refs/remotes/origin/main</code> thing.</p>

<pre><code>[remote &quot;origin&quot;]
	url = git@github.com:jvns/pandas-cookbook
	fetch = +refs/heads/main:refs/remotes/origin/main
</code></pre>

<p>I don&rsquo;t really know what this means, I&rsquo;ve always just used whatever the default
is when you do a <code>git clone</code> or <code>git remote add</code>, and I&rsquo;ve never felt any
motivation to learn about it or change it from the default.</p>

<h3 id="tree-ish">&ldquo;tree-ish&rdquo;</h3>

<p>The man page for <code>git checkout</code> says:</p>

<pre><code> git checkout [-f|--ours|--theirs|-m|--conflict=&lt;style&gt;] [&lt;tree-ish&gt;] [--] &lt;pathspec&gt;...
</code></pre>

<p>What&rsquo;s <code>tree-ish</code>??? What git is trying to say here is when you run <code>git checkout THING .</code>, <code>THING</code> can be either:</p>

<ul>
<li>a commit ID (like <code>182cd3f</code>)</li>
<li>a reference to a commit ID (like <code>main</code> or <code>HEAD^^</code> or <code>v0.3.2</code>)</li>
<li>a subdirectory <strong>inside</strong> a commit (like <code>main:./docs</code>)</li>
<li>I think that&rsquo;s it????</li>
</ul>

<p>Personally I&rsquo;ve never used the &ldquo;directory inside a commit&rdquo; thing and from my perspective &ldquo;tree-ish&rdquo; might as well just mean &ldquo;commit or reference to commit&rdquo;.</p>

<h3 id="index-staged-cached">&ldquo;index&rdquo;, &ldquo;staged&rdquo;, &ldquo;cached&rdquo;</h3>

<p>All of these refer to the exact same thing (the file <code>.git/index</code>, which is where your changes are staged when you run <code>git add</code>):</p>

<ul>
<li><code>git diff --cached</code></li>
<li><code>git rm --cached</code></li>
<li><code>git diff --staged</code></li>
<li>the file <code>.git/index</code></li>
</ul>

<p>Even though they all ultimately refer to the same file, there&rsquo;s some variation in how those terms are used in practice:</p>

<ul>
<li>Apparently the flags <code>--index</code> and <code>--cached</code> do not generally mean the same
thing. I have personally never used the <code>--index</code> flag so I&rsquo;m not
going to get into it, but <a href="https://gitster.livejournal.com/39629.html">this blog post by Junio
Hamano</a> (git&rsquo;s lead maintainer)
explains all the gnarly details</li>
<li>the &ldquo;index&rdquo; lists untracked files (I guess for performance reasons) but you don&rsquo;t usually think of the &ldquo;staging area&rdquo; as including untracked files&rdquo;</li>
</ul>

<h3 id="reset-revert-restore">&ldquo;reset&rdquo;, &ldquo;revert&rdquo;, &ldquo;restore&rdquo;</h3>

<p>A bunch of people mentioned that &ldquo;reset&rdquo;, &ldquo;revert&rdquo; and &ldquo;restore&rdquo; are very
similar words and it&rsquo;s hard to differentiate them.</p>

<p>I think it&rsquo;s made worse because</p>

<ul>
<li><code>git reset --hard</code> and <code>git restore .</code> on their own do basically the same thing. (though <code>git reset --hard COMMIT</code> and <code>git restore --source COMMIT .</code> are completely different from each other)</li>
<li>the respective man pages don&rsquo;t give very helpful descriptions:

<ul>
<li><code>git reset</code>: &ldquo;Reset current HEAD to the specified state&rdquo;</li>
<li><code>git revert</code>: &ldquo;Revert some existing commits&rdquo;</li>
<li><code>git restore</code>: &ldquo;Restore working tree files&rdquo;</li>
</ul></li>
</ul>

<p>Those short descriptions do give you a better sense for which noun is being
affected (&ldquo;current HEAD&rdquo;, &ldquo;some commits&rdquo;, &ldquo;working tree files&rdquo;) but they assume
you know what &ldquo;reset&rdquo;, &ldquo;revert&rdquo; and &ldquo;restore&rdquo; mean in this context.</p>

<p>Here are some short descriptions of what they each do:</p>

<ul>
<li><code>git revert COMMIT</code>: Create a new commit that&rsquo;s the &ldquo;opposite&rdquo; of COMMIT on your current branch (if COMMIT added 3 lines, the new commit will delete those 3 lines)</li>
<li><code>git reset --hard COMMIT</code>: Force your current branch back to the state it was at <code>COMMIT</code>, erasing any new changes since <code>COMMIT</code>. Very dangerous operation.</li>
<li><code>git restore --source=COMMIT PATH</code>: Take all the files in <code>PATH</code> back to how they were at <code>COMMIT</code>, without changing any other files or commit history.</li>
</ul>

<h3 id="untracked-files-remote-tracking-branch-track-remote-branch">&ldquo;untracked files&rdquo;, &ldquo;remote-tracking branch&rdquo;, &ldquo;track remote branch&rdquo;</h3>

<p>Git uses the word &ldquo;track&rdquo; in 3 different related ways:</p>

<ul>
<li><code>Untracked files:</code> in the output of <code>git status</code>. This means those files aren&rsquo;t managed by Git and won&rsquo;t be included in commits.</li>
<li>a &ldquo;remote tracking branch&rdquo; like <code>origin/main</code>. This is a local reference, and it&rsquo;s the commit ID that <code>main</code> pointed to on the remote <code>origin</code> the last time you ran <code>git pull</code> or <code>git fetch</code>.</li>
<li>“branch foo set up to <strong>track</strong> remote branch bar from origin”</li>
</ul>

<p>The &ldquo;untracked files&rdquo; and &ldquo;remote tracking branch&rdquo; thing is not too bad &ndash; they
both use &ldquo;track&rdquo;, but the context is very different. No big deal. But I think
the other two uses of &ldquo;track&rdquo; are actually quite confusing:</p>

<ul>
<li><code>main</code> is a branch that tracks a remote</li>
<li><code>origin/main</code> is a remote-tracking branch</li>
</ul>

<p>But a &ldquo;branch that tracks a remote&rdquo; and a &ldquo;remote-tracking branch&rdquo; are
different things in Git and the distinction is pretty important! Here&rsquo;s a quick
summary of the differences:</p>

<ul>
<li><code>main</code> is a branch. You can make commits to it, merge into it, etc. It&rsquo;s often configured to &ldquo;track&rdquo; the remote <code>main</code> in <code>.git/config</code>, which means that you can use <code>git pull</code> and <code>git push</code> to push/pull changes.</li>
<li><code>origin/main</code> is not a branch. It&rsquo;s a &ldquo;remote-tracking branch&rdquo;, which is not
a kind of branch (I&rsquo;m sorry). You <strong>can&rsquo;t</strong> make commits to it. The only way
you can update it is by running <code>git pull</code> or <code>git fetch</code> to get the latest
state of <code>main</code> from the remote.</li>
</ul>

<p>I&rsquo;d never really thought about this ambiguity before but I think it&rsquo;s pretty
easy to see why folks are confused by it.</p>

<h3 id="checkout">checkout</h3>

<p>Checkout does two totally unrelated things:</p>

<ul>
<li><code>git checkout BRANCH</code> switches branches</li>
<li><code>git checkout file.txt</code> discards your unstaged changes to <code>file.txt</code></li>
</ul>

<p>This is well known to be confusing and git has actually split those two
functions into <code>git switch</code> and <code>git restore</code> (though you can still use
checkout if, like me, you have 15 years of muscle memory around <code>git checkout</code>
that you don&rsquo;t feel like unlearning)</p>

<p>Also personally after 15 years I still can&rsquo;t remember the order of the
arguments to <code>git checkout main file.txt</code> for restoring the version of
<code>file.txt</code> from the <code>main</code> branch.</p>

<p>I think sometimes you need to pass <code>--</code> to <code>checkout</code> as an argument somewhere
to help it figure out which argument is a branch and which ones are paths but I
never do that and I&rsquo;m not sure when it&rsquo;s needed.</p>

<h3 id="reflog">reflog</h3>

<p>Lots of people mentioning reading reflog as <code>re-flog</code> and not <code>ref-log</code>. I
won&rsquo;t get deep into the reflog here because this post is REALLY long but:</p>

<ul>
<li>&ldquo;reference&rdquo; is an umbrella term git uses for branches, tags, and HEAD</li>
<li>the reference log (&ldquo;reflog&rdquo;) gives you the history of everything a reference has ever pointed to</li>
<li>It can help get you out of some VERY bad git situations, like if you accidentally delete an important branch</li>
<li>I find it one of the most confusing parts of git&rsquo;s UI and I try to avoid
needing to use it.</li>
</ul>

<h3 id="merge-vs-rebase-vs-cherry-pick">merge vs rebase vs cherry-pick</h3>

<p>A bunch of people mentioned being confused about the difference between merge
and rebase and not understanding what the &ldquo;base&rdquo; in rebase was supposed to be.</p>

<p>I&rsquo;ll try to summarize them very briefly here, but I don&rsquo;t think these 1-line
explanations are that useful because people structure their workflows around
merge / rebase in pretty different ways and to really understand merge/rebase
you need to understand the workflows. Also pictures really help. That could
really be its whole own blog post though so I&rsquo;m not going to get into it.</p>

<ul>
<li>merge creates a single new commit that merges the 2 branches</li>
<li>rebase copies commits on the current branch to the target branch, one at a time.</li>
<li>cherry-pick is similar to rebase, but with a totally different syntax (one
big difference is that rebase copies commits FROM the current branch,
cherry-pick copies commits TO the current branch)</li>
</ul>

<h3 id="rebase-onto"><code>rebase --onto</code></h3>

<p><code>git rebase</code> has an flag called <code>onto</code>. This has always seemed confusing to me
because the whole point of <code>git rebase main</code> is to rebase the current branch
<strong>onto</strong> main. So what&rsquo;s the extra <code>onto</code> argument about?</p>

<p>I looked it up, and <code>--onto</code> definitely solves a problem that I&rsquo;ve rarely/never
actually had, but I guess I&rsquo;ll write down my understanding of it anyway.</p>

<pre><code>A - B - C (main)
     \
      D - E - F - G (mybranch)
          | 
          otherbranch
</code></pre>

<p>Imagine that for some reason I just want to move commits <code>F</code> and <code>G</code> to be
rebased on top of <code>main</code>. I think there&rsquo;s probably some git workflow where this
comes up a lot.</p>

<p>Apparently you can run <code>git rebase --onto main otherbranch mybranch</code> to do
that. It seems impossible to me to remember the syntax for this (there are 3
different branch names involved, which for me is too many), but I heard about it from a
bunch of people so I guess it must be useful.</p>

<h3 id="commit">commit</h3>

<p>Someone mentioned that they found it confusing that commit is used both as a
verb and a noun in git.</p>

<p>for example:</p>

<ul>
<li>verb: &ldquo;Remember to commit often&rdquo;</li>
<li>noun: &ldquo;the most recent commit on <code>main</code>&ldquo;</li>
</ul>

<p>My guess is that most folks get used to this relatively quickly, but this use
of &ldquo;commit&rdquo; is different from how it&rsquo;s used in SQL databases, where I think
&ldquo;commit&rdquo; is just a verb (you &ldquo;COMMIT&rdquo; to end a transaction) and not a noun.</p>

<p>Also in git you can think of a Git commit in 3 different ways:</p>

<ol>
<li>a <strong>snapshot</strong> of the current state of every file</li>
<li>a <strong>diff</strong> from the parent commit</li>
<li>a <strong>history</strong> of every previous commit</li>
</ol>

<p>None of those are wrong: different commands use commits in all of these ways.
For example <code>git show</code> treats a commit as a diff, <code>git log</code> treats it as a
history, and <code>git restore</code> treats it as a snapshot.</p>

<p>But git&rsquo;s terminology doesn&rsquo;t do much to help you understand in which sense a
commit is being used by a given command.</p>

<h3 id="more-confusing-terms">more confusing terms</h3>

<p>Here are a bunch more confusing terms. I don&rsquo;t know what a lot of these mean.</p>

<p>things I don&rsquo;t really understand myself:</p>

<ul>
<li>&ldquo;the git pickaxe&rdquo; (maybe this is <code>git log -S</code> and <code>git log -G</code>, for searching the diffs of previous commits?)</li>
<li>submodules (all I know is that they don&rsquo;t work the way I want them to work)</li>
<li>&ldquo;cone mode&rdquo; in git sparse checkout (no idea what this is but someone mentioned it)</li>
</ul>

<p>things that people mentioned finding confusing but that I left out of this post
because it was already 3000 words:</p>

<ul>
<li>blob, tree</li>
<li>the direction of &ldquo;merge&rdquo;</li>
<li>&ldquo;origin&rdquo;, &ldquo;upstream&rdquo;, &ldquo;downstream&rdquo;</li>
<li>that <code>push</code> and <code>pull</code> aren&rsquo;t opposites</li>
<li>the relationship between <code>fetch</code> and <code>pull</code> (pull = fetch + merge)</li>
<li>git porcelain</li>
<li>subtrees</li>
<li>worktrees</li>
<li>the stash</li>
<li>&ldquo;master&rdquo; or &ldquo;main&rdquo; (it sounds like it has a special meaning inside git but it doesn&rsquo;t)</li>
<li>when you need to use <code>origin main</code> (like <code>git push origin main</code>) vs <code>origin/main</code></li>
</ul>

<p>github terms people mentioned being confused by:</p>

<ul>
<li>&ldquo;pull request&rdquo; (vs &ldquo;merge request&rdquo; in gitlab which folks seemed to think was clearer)</li>
<li>what &ldquo;squash and merge&rdquo; and &ldquo;rebase and merge&rdquo; do (I&rsquo;d never actually heard of <code>git merge --squash</code> until yesterday, I thought &ldquo;squash and merge&rdquo; was a special github feature)</li>
</ul>

<h3 id="it-s-genuinely-every-git-term">it&rsquo;s genuinely &ldquo;every git term&rdquo;</h3>

<p>I was surprised that basically every other core feature of git was mentioned by
at least one person as being confusing in some way. I&rsquo;d be interested in
hearing more examples of confusing git terms that I missed too.</p>

<p>There&rsquo;s another great post about this from 2012 called <a href="https://longair.net/blog/2012/05/07/the-most-confusing-git-terminology/">the most confusing git terminology</a>.
It talks more about how git&rsquo;s terminology relates to CVS and Subversion&rsquo;s terminology.</p>

<p>If I had to pick the 3 most confusing git terms, I think right now I&rsquo;d pick:</p>

<ul>
<li>a <code>head</code> is a branch, <code>HEAD</code> is the current branch</li>
<li>&ldquo;remote tracking branch&rdquo; and &ldquo;branch that tracks a remote&rdquo; being different things</li>
<li>how &ldquo;index&rdquo;, &ldquo;staged&rdquo;, &ldquo;cached&rdquo; all refer to the same thing</li>
</ul>

<h3 id="that-s-all">that&rsquo;s all!</h3>

<p>I learned a lot from writing this &ndash; I learned a few new facts about git, but
more importantly I feel like I have a slightly better sense now for what
someone might mean when they say that everything in git is confusing.</p>

<p>I really hadn&rsquo;t thought about a lot of these issues before &ndash; like I&rsquo;d never
realized how &ldquo;tracking&rdquo; is used in such a weird way when discussing branches.</p>

<p>Also as usual I might have made some mistakes, especially since I ended up in a
bunch of corners of git that I hadn&rsquo;t visited before.</p>

  </body>
</html>
