<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fly.io/blog/rethinking-serverless-with-flame/">Original</a>
    <h1>Rethinking Serverless with Flame</h1>
    
    <div id="readability-page-1" class="page"><article>
         <dl>
             <dt>Author</dt>
             <dd>
                 <img alt="Chris McCord" src="https://fly.io/static/images/chris-m.webp"/>
               <dl>
                 <dt>Name</dt>
                 <dd>
                   Chris McCord
                 </dd>
                   <dt>Twitter</dt>
                   <dd>
                     <a href="https://twitter.com/chris_mccord" target="_blank">
                       @chris_mccord
                     </a>
                   </dd>
               </dl>
             </dd>
         </dl>

        <section>
            <figure>
                <img src="https://fly.io/blog/rethinking-serverless-with-flame/assets/flame-cover.webp" alt="FLAME logo"/>
            </figure>
          <blockquote>Imagine if you could auto scale simply by wrapping any existing app code in a function and have that block of code run in a temporary copy of your app.</blockquote>


<p>The pursuit of elastic, auto-scaling applications has taken us to silly places.</p>

<p>Serverless/FaaS had a couple things going for it. Elastic Scale™ is hard. It’s even harder when you need to manage those pesky servers. It also promised pay-what-you-use costs to avoid idle usage. Good stuff, right?</p>

<p>Well the charade is over. You offload scaling concerns and the complexities of scaling, just to end up needing <em>more complexity</em>. Additional queues, storage, and glue code to communicate back to our app is just the starting point. Dev, test, and CI complexity balloons as fast as your costs. Oh, and you often have to rewrite your app in proprietary JavaScript – even if it’s already written in JavaScript!</p>

<p>At the same time, the rest of us have elastically scaled by starting more webservers. Or we’ve dumped on complexity with microservices. This doesn’t make sense. Piling on more webservers to transcode more videos or serve up more ML tasks isn’t what we want. And granular scale shouldn’t require slicing our apps into bespoke operational units with their own APIs and deployments to manage.</p>

<p>Enough is enough. There’s a better way to elastically scale applications.</p>
<h2 id="the-flame-pattern"><a href="#the-flame-pattern" aria-label="Anchor"></a>The FLAME pattern</h2>
<p>Here’s what we really want:</p>

<ul>
<li>We don’t want to manage those pesky servers. We already have this for our app deployments via <code>fly deploy</code>, <code>git push heroku</code>, <code>kubectl</code>, etc
</li><li>We want on-demand, <em>granular</em> elastic scale of specific parts of our app code
</li><li>We don’t want to rewrite our application or write parts of it in proprietary runtimes
</li></ul>

<p>Imagine if we could auto scale simply by wrapping any existing app code in a function and have that block of code run in a temporary copy of the app.</p>

<p>Enter the FLAME pattern.</p>
<blockquote>FLAME - Fleeting Lambda Application for Modular Execution</blockquote>


<p>With FLAME, you treat your <em>entire application</em> as a lambda, where modular parts can be executed on short-lived infrastructure.</p>

<p>No rewrites. No bespoke runtimes. No outrageous layers of complexity. Need to insert the results of an expensive operation to the database? PubSub broadcast the result of some expensive work? No problem! It’s your whole app so of course you can do it.</p>

<p>The Elixir <a href="https://github.com/phoenixframework/flame">flame library</a> implements the FLAME pattern. It has a backend adapter for Fly.io, but you can use it on any cloud that gives you an API to spin up an instance with your app code running on it. We’ll talk more about backends in a bit, as well as implementing FLAME in other languages.</p>

<p>First, lets watch a realtime thumbnail generation example to see FLAME + Elixir in action:</p>
<div><p>
          <iframe width="100%" height="100%" src="https://www.youtube.com/embed/l1xt_rkWdic" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="">
          </iframe>
        </p>
</div>


<p>Now let’s walk thru something a little more basic. Imagine we have a function to transcode video to thumbnails in our Elixir application after they are uploaded:</p>
<div>
  <pre><code><span>def</span> <span>generate_thumbnails</span><span>(%</span><span>Video</span><span>{}</span> <span>=</span> <span>vid</span><span>,</span> <span>interval</span><span>)</span> <span>do</span>
  <span>tmp</span> <span>=</span> <span>Path</span><span>.</span><span>join</span><span>(</span><span>System</span><span>.</span><span>tmp_dir!</span><span>(),</span> <span>Ecto</span><span>.</span><span>UUID</span><span>.</span><span>generate</span><span>())</span>
  <span>File</span><span>.</span><span>mkdir!</span><span>(</span><span>tmp</span><span>)</span>
  <span>args</span> <span>=</span> <span>[</span><span>&#34;-i&#34;</span><span>,</span> <span>vid</span><span>.</span><span>url</span><span>,</span> <span>&#34;-vf&#34;</span><span>,</span> <span>&#34;fps=1/</span><span>#{</span><span>interval</span><span>}</span><span>&#34;</span><span>,</span> <span>&#34;</span><span>#{</span><span>tmp</span><span>}</span><span>/%02d.png&#34;</span><span>]</span>
  <span>System</span><span>.</span><span>cmd</span><span>(</span><span>&#34;ffmpeg&#34;</span><span>,</span> <span>args</span><span>)</span>
  <span>urls</span> <span>=</span> <span>VidStore</span><span>.</span><span>put_thumbnails</span><span>(</span><span>vid</span><span>,</span> <span>Path</span><span>.</span><span>wildcard</span><span>(</span><span>tmp</span> <span>&lt;&gt;</span> <span>&#34;/*.png&#34;</span><span>))</span>
  <span>Repo</span><span>.</span><span>insert_all</span><span>(</span><span>Thumb</span><span>,</span> <span>Enum</span><span>.</span><span>map</span><span>(</span><span>urls</span><span>,</span> <span>&amp;</span><span>%{</span><span>vid_id:</span> <span>vid</span><span>.</span><span>id</span><span>,</span> <span>url:</span> <span>&amp;1</span><span>}))</span>
<span>end</span>
</code></pre>
</div>

<p>Our <code>generate_thumbnails</code> function accepts a video struct. We shell out to <code>ffmpeg</code> to take the video URL and generate thumbnails at a given interval. We then write the temporary thumbnail paths to durable storage. Finally, we insert the generated thumbnail URLs into the database.</p>

<p>This works great locally, but CPU bound work like video transcoding can quickly bring our entire service to a halt in production. Instead of rewriting large swaths of our app to move this into microservices or some FaaS, we can simply wrap it in a FLAME call:</p>
<div>
  <pre><code><span>def</span> <span>generate_thumbnails</span><span>(%</span><span>Video</span><span>{}</span> <span>=</span> <span>vid</span><span>,</span> <span>interval</span><span>)</span> <span>do</span>
  <span>FLAME</span><span>.</span><span>call</span><span>(</span><span>MyApp</span><span>.</span><span>FFMpegRunner</span><span>,</span> <span>fn</span> <span>-&gt;</span>
    <span>tmp</span> <span>=</span> <span>Path</span><span>.</span><span>join</span><span>(</span><span>System</span><span>.</span><span>tmp_dir!</span><span>(),</span> <span>Ecto</span><span>.</span><span>UUID</span><span>.</span><span>generate</span><span>())</span>
    <span>File</span><span>.</span><span>mkdir!</span><span>(</span><span>tmp</span><span>)</span>
    <span>args</span> <span>=</span>
      <span>[</span><span>&#34;-i&#34;</span><span>,</span> <span>vid</span><span>.</span><span>url</span><span>,</span> <span>&#34;-vf&#34;</span><span>,</span> <span>&#34;fps=1/</span><span>#{</span><span>interval</span><span>}</span><span>&#34;</span><span>,</span> <span>&#34;</span><span>#{</span><span>tmp</span><span>}</span><span>/%02d.png&#34;</span><span>]</span>
    <span>System</span><span>.</span><span>cmd</span><span>(</span><span>&#34;ffmpeg&#34;</span><span>,</span> <span>args</span><span>)</span>
    <span>urls</span> <span>=</span> <span>VidStore</span><span>.</span><span>put_thumbnails</span><span>(</span><span>vid</span><span>,</span> <span>Path</span><span>.</span><span>wildcard</span><span>(</span><span>tmp</span> <span>&lt;&gt;</span> <span>&#34;/*.png&#34;</span><span>))</span>
    <span>Repo</span><span>.</span><span>insert_all</span><span>(</span><span>Thumb</span><span>,</span> <span>Enum</span><span>.</span><span>map</span><span>(</span><span>urls</span><span>,</span> <span>&amp;</span><span>%{</span><span>vid_id:</span> <span>vid</span><span>.</span><span>id</span><span>,</span> <span>url:</span> <span>&amp;1</span><span>}))</span>
  <span>end</span><span>)</span>
<span>end</span>
</code></pre>
</div>

<p>That’s it! <code>FLAME.call</code> accepts the name of a runner pool, and a function. It then finds or boots a new copy of our entire application and runs the function there. Any variables the function closes over (like our <code>%Video{}</code> struct and <code>interval</code>) are passed along automatically.</p>

<p>When the FLAME runner boots up, it connects back to the parent node, receives the function to run, executes it, and returns the result to the caller. Based on configuration, the booted runner either waits happily for more work before idling down, or extinguishes itself immediately.</p>

<p>Let’s visualize the flow:</p>

<p><img alt="visualizing the flow" src="https://fly.io/blog/rethinking-serverless-with-flame/assets/visual.webp?centered"/></p>

<p>We changed no other code and issued our DB write with <code>Repo.insert_all</code> just like before, because we are running our <em>entire</em> <em>application</em>. Database connection(s) and all. Except this fleeting application only runs that little function after startup and nothing else.</p>

<p>In practice, a FLAME implementation will support a pool of runners for hot startup, scale-to-zero, and elastic growth. More on that later.</p>
<h2 id="solving-a-problem-vs-removing-the-problem"><a href="#solving-a-problem-vs-removing-the-problem" aria-label="Anchor"></a>Solving a problem vs removing the problem</h2><blockquote>FaaS solutions help you solve a problem. FLAME removes the problem.</blockquote>


<p>The FaaS labyrinth of complexity defies reason. And it’s unavoidable. Let’s walkthrough the thumbnail use-case to see how.</p>

<p>We try to start with the simplest building block like request/response AWS Lambda Function URL’s.</p>

<p>The complexity hits immediately.</p>

<p>We start writing custom encoders/decoders on both sides to handle streaming the thumbnails back to the app over HTTP. Phew that’s done. Wait, is our video transcoding or user uploads going to take longer than 15 minutes? Sorry, hard timeout limit – time to split our videos into chunks to stay within the timeout, which means more lambdas to do that. Now we’re orchestrating lambda workflows and relying on additional services, such as SQS and S3, to enable this.</p>

<p>All the FaaS is doing is adding layers of communication between your code and the parts you want to run elastically. Each layer has its own glue integration price to pay.</p>

<p>Ultimately handling this kind of use-case looks something like this:</p>

<ul>
<li>Trigger the lambda via HTTP endpoint, S3, or API gateway ($)
</li><li>Write the bespoke lambda to transcode the video ($)
</li><li>Place the thumbnail results into SQS ($)
</li><li>Write the SQS consumer in our app (dev $)
</li><li>Persist to DB and figure out how to get events back to active subscribers that may well be connected to other instances than the SQS consumer (dev $)
</li></ul>

<p>This is nuts. We pay the FaaS toll at every step. We shouldn’t have to do any of this!</p>

<p>FaaS provides a bunch of offerings to build a solution on top of. FLAME removes the problem entirely.</p>
<h2 id="flame-backends"><a href="#flame-backends" aria-label="Anchor"></a>FLAME Backends</h2><blockquote>On Fly.io infrastructure the <code>FLAME.FlyBackend</code> can boot a copy of your application on a new <a href="https://fly.io/docs/machines/">Machine</a> and have it connect back to the parent for work within ~3s.</blockquote>


<p>By default, FLAME ships with a <code>LocalBackend</code> and <code>FlyBackend</code>, but any host that provides an API to provision a server and run your app code can work as a FLAME backend. Erlang and Elixir primitives are doing all the heavy lifting here. The entire <code>FLAME.FlyBackend</code> is <a href="https://github.com/phoenixframework/flame/blob/main/lib/flame/fly_backend.ex">&lt; 200 LOC with docs</a>. The library has a single dependency, <code>req</code>, which is an HTTP client.</p>

<p>Because Fly.io runs our applications as a packaged up docker image, we simply ask the Fly API to boot a new Machine for us with the same image that our app is currently running. Also thanks to Fly infrastructure, we can guarantee the FLAME runners are started in the same region as the parent. This optimizes latency and lets you ship whatever data back and forth between parent and runner without having to think about it.</p>
<h2 id="look-at-everything-were-not-doing"><a href="#look-at-everything-were-not-doing" aria-label="Anchor"></a>Look at everything we’re not doing</h2>
<p>With FaaS, just imagine how quickly the dev and testing story becomes a fate worse than death.</p>

<p>To run the app locally, we either need to add some huge dev dependencies to simulate the entire FaaS pipeline, or worse, connect up our dev and test environments directly to the FaaS provider.</p>

<p>With FLAME, your dev and test runners simply run on the local backend.</p>

<p>Remember, this is your app. FLAME just controls where modular parts of it run. In dev or test, those parts simply run on the existing runtime on your laptop or CI server.</p>

<p>Using Elixir, we can even send a file across to the remote FLAME application thanks to the distributed features of the Erlang VM:</p>
<div>
  <pre><code><span>def</span> <span>generate_thumbnails</span><span>(%</span><span>Video</span><span>{}</span> <span>=</span> <span>vid</span><span>,</span> <span>interval</span><span>)</span> <span>do</span>
  <span>parent_stream</span> <span>=</span> <span>File</span><span>.</span><span>stream!</span><span>(</span><span>vid</span><span>.</span><span>filepath</span><span>,</span> <span>[],</span> <span>2048</span><span>)</span>
  <span>FLAME</span><span>.</span><span>call</span><span>(</span><span>MyApp</span><span>.</span><span>FFMpegRunner</span><span>,</span> <span>fn</span> <span>-&gt;</span>
    <span>tmp_file</span> <span>=</span> <span>Path</span><span>.</span><span>join</span><span>(</span><span>System</span><span>.</span><span>tmp_dir!</span><span>(),</span> <span>Ecto</span><span>.</span><span>UUID</span><span>.</span><span>generate</span><span>())</span>
    <span>flame_stream</span> <span>=</span> <span>File</span><span>.</span><span>stream!</span><span>(</span><span>tmp_file</span><span>)</span>
    <span>Enum</span><span>.</span><span>into</span><span>(</span><span>parent_stream</span><span>,</span> <span>flame_stream</span><span>)</span>

    <span>tmp</span> <span>=</span> <span>Path</span><span>.</span><span>join</span><span>(</span><span>System</span><span>.</span><span>tmp_dir!</span><span>(),</span> <span>Ecto</span><span>.</span><span>UUID</span><span>.</span><span>generate</span><span>())</span>
    <span>File</span><span>.</span><span>mkdir!</span><span>(</span><span>tmp</span><span>)</span>
    <span>args</span> <span>=</span>
      <span>[</span><span>&#34;-i&#34;</span><span>,</span> <span>vid</span><span>.</span><span>url</span><span>,</span> <span>&#34;-vf&#34;</span><span>,</span> <span>&#34;fps=1/</span><span>#{</span><span>interval</span><span>}</span><span>&#34;</span><span>,</span> <span>&#34;</span><span>#{</span><span>tmp</span><span>}</span><span>/%02d.png&#34;</span><span>]</span>
    <span>System</span><span>.</span><span>cmd</span><span>(</span><span>&#34;ffmpeg&#34;</span><span>,</span> <span>args</span><span>)</span>
    <span>urls</span> <span>=</span> <span>VidStore</span><span>.</span><span>put_thumbnails</span><span>(</span><span>vid</span><span>,</span> <span>Path</span><span>.</span><span>wildcard</span><span>(</span><span>tmp</span> <span>&lt;&gt;</span> <span>&#34;/*.png&#34;</span><span>))</span>
    <span>Repo</span><span>.</span><span>insert_all</span><span>(</span><span>Thumb</span><span>,</span> <span>Enum</span><span>.</span><span>map</span><span>(</span><span>urls</span><span>,</span> <span>&amp;</span><span>%{</span><span>vid_id:</span> <span>vid</span><span>.</span><span>id</span><span>,</span> <span>url:</span> <span>&amp;1</span><span>}))</span>
  <span>end</span><span>)</span>
<span>end</span>
</code></pre>
</div>

<p>On line 2 we open a file on the parent node to the video path. Then in the FLAME child, we stream the file from the parent node to the FLAME server in only a couple lines of code. That’s it! No setup of S3 or HTTP interfaces required.</p>

<p>With FLAME it’s easy to miss everything we’re not doing:</p>

<ul>
<li>We don’t need to write code outside of our application. We can reuse business logic, database setup, PubSub, and all the features of our respective platforms
</li><li>We don’t need to manage deploys of separate services or endpoints
</li><li>We don’t need to write results to S3 or SQS just to pick up values back in our app
</li><li>We skip the dev, test, and CI dependency dance
</li></ul>
<h2 id="flame-outside-elixir"><a href="#flame-outside-elixir" aria-label="Anchor"></a>FLAME outside Elixir</h2>
<p>Elixir is fantastically well suited for the FLAME model because we get so much <a href="https://fly.io/phoenix-files/elixir-and-phoenix-can-do-it-all/">for free</a> like process supervision and distributed messaging. That said, any language with reasonable concurrency primitives can take advantage of this pattern. For example, my teammate, Lubien, created a proof of concept example for breaking out functions in your JavaScript application and running them inside a new Fly Machine: <a href="https://github.com/lubien/fly-run-this-function-on-another-machine">https://github.com/lubien/fly-run-this-function-on-another-machine</a></p>

<p>So the general flow for a JavaScript-based FLAME call would be to move the modular executions to a new file, which is executed on a runner pool. Provided the arguments are JSON serializable, the general FLAME flow is similar to what we’ve outlined here. Your application, your code, running on fleeting instances.</p>

<p>A complete FLAME library will need to handle the following concerns:</p>

<ul>
<li>Elastic pool scale-up and scale-down logic
</li><li>Hot vs cold startup with pools
</li><li>Remote runner monitoring to avoid orphaned resources
</li><li>How to monitor and keep deployments fresh
</li></ul>

<p>For the rest of this post we’ll see how the Elixir FLAME library handles these concerns as well as features uniquely suited to Elixir applications. But first, you might be wondering about your background job queues.</p>
<h2 id="what-about-my-background-job-processor"><a href="#what-about-my-background-job-processor" aria-label="Anchor"></a>What about my background job processor?</h2>
<p>FLAME works great inside your background job processor, but you may have noticed some overlap. If your job library handles scaling the worker pool, what is FLAME doing for you? There’s a couple important distinctions here.</p>

<p>First, we reach for these queues when we need <em>durability guarantees</em>. We often can turn knobs to have the queues scale to handle more jobs as load changes. But durable operations are separate from elastic execution. Conflating these concerns can send you down a similar path to lambda complexity. Leaning on your worker queue purely for offloaded execution means writing all the glue code to get the data into and out of the job, and back to the caller or end-user’s device somehow.</p>

<p>For example, if we want to guarantee we successfully generated thumbnails for a video after the user upload, then a job queue makes sense as the <em>dispatch, commit, and retry</em> <em>mechanism</em> for this operation. The actual transcoding could be a FLAME call inside the job itself, so we decouple the ideas of durability and scaled execution.</p>

<p>On the other side, we have operations we don’t need durability for. Take the screencast above where the user hasn’t yet saved their video. Or an ML model execution where there’s no need to waste resources churning a prompt if the user has already left the app. In those cases, it doesn’t make sense to write to a durable store to pick up a job for work that will go right into the ether.</p>
<h2 id="pooling-for-elastic-scale"><a href="#pooling-for-elastic-scale" aria-label="Anchor"></a>Pooling for Elastic Scale</h2>
<p>With the Elixir implementation of FLAME, you define elastic pools of runners. This allows scale-to-zero behavior while also elastically scaling up FLAME servers with max concurrency limits.</p>

<p>For example, lets take a look at the <code>start/2</code> callback, which is the entry point of all Elixir applications. We can drop in a <code>FLAME.Pool</code> for video transcriptions and say we want it to scale to zero, boot a max of 10, and support 5 concurrent <code>ffmpeg</code> operations per runner:</p>
<div>
  <pre><code><span>def</span> <span>start</span><span>(</span><span>_type</span><span>,</span> <span>_args</span><span>)</span> <span>do</span>
  <span>flame_parent</span> <span>=</span> <span>FLAME</span><span>.</span><span>Parent</span><span>.</span><span>get</span><span>()</span>

  <span>children</span> <span>=</span> <span>[</span>
    <span>...</span><span>,</span>
    <span>MyApp</span><span>.</span><span>Repo</span><span>,</span>
    <span>{</span><span>FLAME</span><span>.</span><span>Pool</span><span>,</span>
      <span>name:</span> <span>Thumbs</span><span>.</span><span>FFMpegRunner</span><span>,</span>
      <span>min:</span> <span>0</span><span>,</span>
      <span>max:</span> <span>10</span><span>,</span>
      <span>max_concurrency:</span> <span>5</span><span>,</span>
      <span>idle_shutdown_after:</span> <span>30_000</span><span>},</span>
    <span>!flame_parent</span> <span>&amp;&amp;</span> <span>MyAppWeb</span><span>.</span><span>Endpoint</span>
  <span>]</span>
  <span>|&gt;</span> <span>Enum</span><span>.</span><span>filter</span><span>(</span><span>&amp;</span> <span>&amp;1</span><span>)</span>

  <span>opts</span> <span>=</span> <span>[</span><span>strategy:</span> <span>:one_for_one</span><span>,</span> <span>name:</span> <span>MyApp</span><span>.</span><span>Supervisor</span><span>]</span>
  <span>Supervisor</span><span>.</span><span>start_link</span><span>(</span><span>children</span><span>,</span> <span>opts</span><span>)</span>
<span>end</span>
</code></pre>
</div>

<p>We use the presence of a FLAME parent to conditionally start our Phoenix webserver when booting the app. There’s no reason to start a webserver if we aren’t serving web traffic. Note we leave other services like the database <code>MyApp.Repo</code> alone because we want to make use of those services inside FLAME runners.</p>

<p>Elixir’s supervised process approach to applications is uniquely great for turning these kinds of knobs.</p>

<p>We also set our pool to idle down after 30 seconds of no caller operations. This keeps our runners hot for a short while before discarding them. We could also pass a <code>min: 1</code> to always ensure at least one <code>ffmpeg</code> runner is hot and ready for work by the time our application is started.</p>
<h2 id="process-placement"><a href="#process-placement" aria-label="Anchor"></a>Process Placement</h2>
<p>In Elixir, stateful bits of our applications are built around the <em>process</em> primitive – lightweight greenthreads with message mailboxes. Wrapping our otherwise stateless app code in a synchronous <code>FLAME.call</code>‘s or async <code>FLAME.cast</code>’s works great, but what about the stateful parts of our app?</p>

<p><code>FLAME.place_child</code> exists to take an existing process specification in your Elixir app and start it on a FLAME runner instead of locally. You can use it anywhere you’d use <code>Task.Supervisor.start_child</code> , <code>DynamicSupervisor.start_child</code>, or similar interfaces. Just like <code>FLAME.call</code>, the process is run on an elastic pool and runners handle idle down when the process completes its work.</p>

<p>And like <code>FLAME.call</code>, it lets us take existing app code, change a single LOC, and continue shipping features.</p>

<p>Let’s walk thru the example from the screencast above. Imagine we want to generate video thumbnails for a video <em>as it is being uploaded</em>. Elixir and LiveView make this easy. We won’t cover all the code here, but you can view the <a href="https://github.com/fly-apps/thumbnail_generator/blob/main/lib/thumbs/thumbnail_generator.ex">full app implementation</a>.</p>

<p>Our first pass would be to write a LiveView upload writer that calls into a <code>ThumbnailGenerator</code>:</p>
<div>
  <pre><code><span>defmodule</span> <span>ThumbsWeb</span><span>.</span><span>ThumbnailUploadWriter</span> <span>do</span>
  <span>@behaviour</span> <span>Phoenix</span><span>.</span><span>LiveView</span><span>.</span><span>UploadWriter</span>

  <span>alias</span> <span>Thumbs</span><span>.</span><span>ThumbnailGenerator</span>

  <span>def</span> <span>init</span><span>(</span><span>opts</span><span>)</span> <span>do</span>
    <span>generator</span> <span>=</span> <span>ThumbnailGenerator</span><span>.</span><span>open</span><span>(</span><span>opts</span><span>)</span>
    <span>{</span><span>:ok</span><span>,</span> <span>%{</span><span>gen:</span> <span>generator</span><span>}}</span>
  <span>end</span>

  <span>def</span> <span>write_chunk</span><span>(</span><span>data</span><span>,</span> <span>state</span><span>)</span> <span>do</span>
    <span>ThumbnailGenerator</span><span>.</span><span>stream_chunk!</span><span>(</span><span>state</span><span>.</span><span>gen</span><span>,</span> <span>data</span><span>)</span>
    <span>{</span><span>:ok</span><span>,</span> <span>state</span><span>}</span>
  <span>end</span>

  <span>def</span> <span>meta</span><span>(</span><span>state</span><span>),</span> <span>do</span><span>:</span> <span>%{</span><span>gen:</span> <span>state</span><span>.</span><span>gen</span><span>}</span>

  <span>def</span> <span>close</span><span>(</span><span>state</span><span>,</span> <span>_reason</span><span>)</span> <span>do</span>
    <span>ThumbnailGenerator</span><span>.</span><span>close</span><span>(</span><span>state</span><span>.</span><span>gen</span><span>)</span>
    <span>{</span><span>:ok</span><span>,</span> <span>state</span><span>}</span>
  <span>end</span>
<span>end</span>
</code></pre>
</div>

<p>An upload writer is a behavior that simply ferries the uploaded chunks from the client into whatever we’d like to do with them. Here we have a <code>ThumbnailGenerator.open/1</code> which starts a process that communicates with an <code>ffmpeg</code> shell. Inside <code>ThumbnailGenerator.open/1</code>, we use regular elixir process primitives:</p>
<div>
  <pre><code>  <span># thumbnail_generator.ex</span>
  <span>def</span> <span>open</span><span>(</span><span>opts</span> <span>\\</span> <span>[])</span> <span>do</span>
    <span>Keyword</span><span>.</span><span>validate!</span><span>(</span><span>opts</span><span>,</span> <span>[</span><span>:timeout</span><span>,</span> <span>:caller</span><span>,</span> <span>:fps</span><span>])</span>
    <span>timeout</span> <span>=</span> <span>Keyword</span><span>.</span><span>get</span><span>(</span><span>opts</span><span>,</span> <span>:timeout</span><span>,</span> <span>5_000</span><span>)</span>
    <span>caller</span> <span>=</span> <span>Keyword</span><span>.</span><span>get</span><span>(</span><span>opts</span><span>,</span> <span>:caller</span><span>,</span> <span>self</span><span>())</span>
    <span>ref</span> <span>=</span> <span>make_ref</span><span>()</span>
    <span>parent</span> <span>=</span> <span>self</span><span>()</span>

    <span>spec</span> <span>=</span> <span>{</span><span>__MODULE__</span><span>,</span> <span>{</span><span>caller</span><span>,</span> <span>ref</span><span>,</span> <span>parent</span><span>,</span> <span>opts</span><span>}}</span>
    <span>{</span><span>:ok</span><span>,</span> <span>pid</span><span>}</span> <span>=</span> <span>DynamicSupervisor</span><span>.</span><span>start_child</span><span>(</span><span>@sup</span><span>,</span> <span>spec</span><span>)</span>

    <span>receive</span> <span>do</span>
      <span>{</span><span>^</span><span>ref</span><span>,</span> <span>%</span><span>ThumbnailGenerator</span><span>{}</span> <span>=</span> <span>gen</span><span>}</span> <span>-&gt;</span>
        <span>%</span><span>ThumbnailGenerator</span><span>{</span><span>gen</span> <span>|</span> <span>pid:</span> <span>pid</span><span>}</span>
    <span>after</span>
      <span>timeout</span> <span>-&gt;</span> <span>exit</span><span>(</span><span>:timeout</span><span>)</span>
    <span>end</span>
  <span>end</span>
</code></pre>
</div>

<p>The details aren’t super important here, except line 10 where we call <code>{:ok, pid} = DynamicSupervisor.start_child(@sup, spec)</code>, which starts a supervised<code>ThumbnailGenerator</code> process. The rest of the implementation simply ferries chunks as stdin into <code>ffmpeg</code> and parses png’s from stdout. Once a PNG delimiter is found in stdout, we send the <code>caller</code> process (our LiveView process) a message saying “hey, here’s an image”:</p>
<div>
  <pre><code><span># thumbnail_generator.ex</span>
<span>@png_begin</span> <span>&lt;&lt;</span><span>137</span><span>,</span> <span>80</span><span>,</span> <span>78</span><span>,</span> <span>71</span><span>,</span> <span>13</span><span>,</span> <span>10</span><span>,</span> <span>26</span><span>,</span> <span>10</span><span>&gt;&gt;</span>
<span>defp</span> <span>handle_stdout</span><span>(</span><span>state</span><span>,</span> <span>ref</span><span>,</span> <span>bin</span><span>)</span> <span>do</span>
  <span>%</span><span>ThumbnailGenerator</span><span>{</span><span>ref:</span> <span>^</span><span>ref</span><span>,</span> <span>caller:</span> <span>caller</span><span>}</span> <span>=</span> <span>state</span><span>.</span><span>gen</span>

  <span>case</span> <span>bin</span> <span>do</span>
    <span>&lt;&lt;</span><span>@png_begin</span><span>,</span> <span>_rest</span><span>::</span><span>binary</span><span>&gt;&gt;</span> <span>-&gt;</span>
      <span>if</span> <span>state</span><span>.</span><span>current</span> <span>do</span>
        <span>send</span><span>(</span><span>caller</span><span>,</span> <span>{</span><span>ref</span><span>,</span> <span>:image</span><span>,</span> <span>state</span><span>.</span><span>count</span><span>,</span> <span>encode</span><span>(</span><span>state</span><span>)})</span>
      <span>end</span>

      <span>%{</span><span>state</span> <span>|</span> <span>count:</span> <span>state</span><span>.</span><span>count</span> <span>+</span> <span>1</span><span>,</span> <span>current:</span> <span>[</span><span>bin</span><span>]}</span>

    <span>_</span> <span>-&gt;</span>
      <span>%{</span><span>state</span> <span>|</span> <span>current:</span> <span>[</span><span>bin</span> <span>|</span> <span>state</span><span>.</span><span>current</span><span>]}</span>
  <span>end</span>
<span>end</span>
</code></pre>
</div>

<p>The <code>caller</code> LiveView process then picks up the message in a <code>handle_info</code> callback and updates the UI:</p>
<div>
  <pre><code><span># thumb_live.ex</span>
<span>def</span> <span>handle_info</span><span>({</span><span>_ref</span><span>,</span> <span>:image</span><span>,</span> <span>_count</span><span>,</span> <span>encoded</span><span>},</span> <span>socket</span><span>)</span> <span>do</span>
  <span>%{</span><span>count:</span> <span>count</span><span>}</span> <span>=</span> <span>socket</span><span>.</span><span>assigns</span>

  <span>{</span><span>:noreply</span><span>,</span>
   <span>socket</span>
   <span>|&gt;</span> <span>assign</span><span>(</span><span>count:</span> <span>count</span> <span>+</span> <span>1</span><span>,</span> <span>message:</span> <span>&#34;Generating (</span><span>#{</span><span>count</span> <span>+</span> <span>1</span><span>}</span><span>)&#34;</span><span>)</span>
   <span>|&gt;</span> <span>stream_insert</span><span>(</span><span>:thumbs</span><span>,</span> <span>%{</span><span>id:</span> <span>count</span><span>,</span> <span>encoded:</span> <span>encoded</span><span>})}</span>
<span>end</span>
</code></pre>
</div>

<p>The <code>send(caller, {ref, :image, state.count, encode(state)}</code> is one magic part about Elixir. Everything is a process, and we can message those processes, regardless of their location in the cluster.</p>

<p>It’s like if every instantiation of an object in your favorite OO lang included a cluster-global unique identifier to work with methods on that object. The LiveView (a process) simply receives the image message and updates the UI with new images.</p>

<p>Now let’s head back over to our <code>ThumbnailGenerator.open/1</code> function and make this elastically scalable.</p>
<div>
  <pre><code><span>-    {:ok, pid} = DynamicSupervisor.start_child(@sup, spec)
</span><span>+    {:ok, pid} = FLAME.place_child(Thumbs.FFMpegRunner, spec)
</span></code></pre>
</div>

<p>That’s it! Because everything is a process and processes can live anywhere, it doesn’t matter what server our <code>ThumbnailGenerator</code> process lives on. It simply messages the caller with <code>send(caller, …)</code> and the messages are sent across the cluster if needed.</p>

<p>Once the process exits, either from an explicit close, after the upload is done, or from the end-user closing their browser tab, the FLAME server will note the exit and idle down if no other work is being done.</p>

<p>Check out the <a href="https://github.com/fly-apps/thumbnail_generator/blob/main/lib/thumbs/thumbnail_generator.ex">full implementation</a> if you’re interested.</p>
<h2 id="remote-monitoring"><a href="#remote-monitoring" aria-label="Anchor"></a>Remote Monitoring</h2>
<p>All this transient infrastructure needs failsafe mechanisms to avoid orphaning resources. If a parent spins up a runner, that runner must take care of idling itself down when no work is present and handle failsafe shutdowns if it can no longer contact the parent node.</p>

<p>Likewise, we need to shutdown runners when parents are rolled for new deploys as we must guarantee we’re running the same code across the cluster.</p>

<p>We also have active callers in many cases that are awaiting the result of work on runners that could go down for any reason.</p>

<p>There’s a lot to monitor here.</p>

<p>There’s also a number of failure modes that make this sound like a harrowing experience to implement. Fortunately Elixir has all the primitives to make this an easy task thanks to the Erlang VM. Namely, we get the following for free:</p>

<ul>
<li>Process monitoring and supervision – we know when things go bad. Whether on a node-local process, or one across the cluster
</li><li>Node monitoring – we know when nodes come up, and when nodes go away
</li><li>Declarative and controlled app startup and shutdown - we carefully control the startup and shutdown sequence of applications as a matter of course. This allows us to gracefully shutdown active runners when a fresh deploy is triggered, while giving them time to finish their work
</li></ul>

<p>We’ll cover the internal implementation details in a future deep-dive post. For now, feel free to poke around <a href="https://github.com/phoenixframework/flame">the flame source</a>.</p>
<h2 id="whats-next"><a href="#whats-next" aria-label="Anchor"></a>What’s Next</h2>
<p>We’re just getting started with the Elixir FLAME library, but it’s ready to try out now. In the future  look for more advance pool growth techniques, and deep dives into how the Elixir implementation works. You can also find me <a href="https://twitter.com/chris_mccord">@chris_mccord</a> to chat about implementing the FLAME pattern in your language of choice.</p>

<p>Happy coding!</p>

<p>–Chris</p>

          
        </section>
        <dl>
            <dt>
              Next post  ↑
            </dt>
            <dd>
              <a href="https://fly.io/blog/scaling-llm-ollama/">
                Scaling Large Language Models to zero with Ollama
              </a>
            </dd>
            <dt>
              Previous post  ↓
            </dt>
            <dd>
              <a href="https://fly.io/blog/the-risks-of-building-apps-on-chatgpt/">
                The risks of building apps on ChatGPT
              </a>
            </dd>
        </dl>
      </article></div>
  </body>
</html>
