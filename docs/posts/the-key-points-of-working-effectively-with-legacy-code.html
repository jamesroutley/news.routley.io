<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://understandlegacycode.com/blog/key-points-of-working-effectively-with-legacy-code/">Original</a>
    <h1>The key points of &#34;Working Effectively with Legacy Code&#34;</h1>
    
    <div id="readability-page-1" class="page"><div> <blockquote>
<p>‚ÄúLegacy Code is code without tests‚Äù</p>
</blockquote>
<p>If you‚Äôve come across that definition, it‚Äôs from Michael Feathers‚Äô book: <a href="https://www.google.com/search?q=working+effectively+with+legacy+code">Working Effectively with Legacy Code</a>.</p>
<p>While I have <a href="https://understandlegacycode.com/blog/what-is-legacy-code-is-it-code-without-tests/">a slightly extended definition</a>, this is a very valid and useful one!</p>
<p>Feathers‚Äô book is from 2004. Yet, its content doesn‚Äôt get outdated. There is a reason for that and <a href="http://www.commitstrip.com/en/2019/03/13/like-a-good-wine">this CommitStrip</a> puts it best:</p>
<p><img src="https://understandlegacycode.com/assets/legacy-code-commitstrip.png" alt="Working Effectively with Legacy Code is like a good wine: it gets better with age"/></p>
<p>This book is a reference. Probably THE reference.</p>
<p>When there‚Äôs a thread about Legacy Code, it doesn‚Äôt take long for someone to drop a comment suggesting you read it.</p>
<blockquote>
<p>I didn‚Äôt read it. I‚Äôve seen it‚Äôs recommended. But what are the key points of that book?</p>
</blockquote>
<p>If that‚Äôs you, I got your back!</p>
<p>Here‚Äôs my summary of the salient points of the book and how they can help you deal with your existing codebase.</p>
<h2 id="first-add-tests-then-do-your-changes"><a href="#first-add-tests-then-do-your-changes"><svg aria-hidden="true" version="1.1" viewBox="0 0 511.997 511.997" width="22" height="22"><path d="M212.26,390.24l-60.331,60.331c-25.012,25.012-65.517,25.012-90.508,0.005c-24.996-24.996-24.996-65.505-0.005-90.496 l120.683-120.683c24.991-24.992,65.5-24.992,90.491,0c8.331,8.331,21.839,8.331,30.17,0c8.331-8.331,8.331-21.839,0-30.17 c-41.654-41.654-109.177-41.654-150.831,0L31.247,329.909c-41.654,41.654-41.654,109.177,0,150.831 c41.649,41.676,109.177,41.676,150.853,0l60.331-60.331c8.331-8.331,8.331-21.839,0-30.17S220.591,381.909,212.26,390.24z"></path><path d="M480.751,31.24c-41.654-41.654-109.199-41.654-150.853,0l-72.384,72.384c-8.331,8.331-8.331,21.839,0,30.17 c8.331,8.331,21.839,8.331,30.17,0l72.384-72.384c24.991-24.992,65.521-24.992,90.513,0c24.991,24.991,24.991,65.5,0,90.491 L317.845,284.638c-24.992,24.992-65.5,24.992-90.491,0c-8.331-8.331-21.839-8.331-30.17,0s-8.331,21.839,0,30.17 c41.654,41.654,109.177,41.654,150.831,0l132.736-132.736C522.405,140.418,522.405,72.894,480.751,31.24z"></path></svg></a>First, add tests, then do your changes</h2>
<p>The challenge with changing existing code is to preserve the existing behavior.</p>
<p>When code is not tested, how do you know you didn‚Äôt break anything?</p>
<p>You need <strong>feedback</strong>. Automated feedback is the best. Thus, this is the first thing you need to do: write the tests.</p>
<p>Only then you‚Äôll be safe to change the code and refactor.</p>
<p>Your goal is to get there. The point of the book is to show you <em>how</em> you can get there when you have to deal with an impossibly convoluted codebase. Which leads us to the next point‚Ä¶</p>
<h2 id="adding-tests-the-legacy-code-dilemma"><a href="#adding-tests-the-legacy-code-dilemma"><svg aria-hidden="true" version="1.1" viewBox="0 0 511.997 511.997" width="22" height="22"><path d="M212.26,390.24l-60.331,60.331c-25.012,25.012-65.517,25.012-90.508,0.005c-24.996-24.996-24.996-65.505-0.005-90.496 l120.683-120.683c24.991-24.992,65.5-24.992,90.491,0c8.331,8.331,21.839,8.331,30.17,0c8.331-8.331,8.331-21.839,0-30.17 c-41.654-41.654-109.177-41.654-150.831,0L31.247,329.909c-41.654,41.654-41.654,109.177,0,150.831 c41.649,41.676,109.177,41.676,150.853,0l60.331-60.331c8.331-8.331,8.331-21.839,0-30.17S220.591,381.909,212.26,390.24z"></path><path d="M480.751,31.24c-41.654-41.654-109.199-41.654-150.853,0l-72.384,72.384c-8.331,8.331-8.331,21.839,0,30.17 c8.331,8.331,21.839,8.331,30.17,0l72.384-72.384c24.991-24.992,65.521-24.992,90.513,0c24.991,24.991,24.991,65.5,0,90.491 L317.845,284.638c-24.992,24.992-65.5,24.992-90.491,0c-8.331-8.331-21.839-8.331-30.17,0s-8.331,21.839,0,30.17 c41.654,41.654,109.177,41.654,150.831,0l132.736-132.736C522.405,140.418,522.405,72.894,480.751,31.24z"></path></svg></a>Adding tests: the Legacy Code dilemma</h2>
<p>Before you change code, you should have tests in place. But to put tests in place, you have to change code.</p>
<p>This is the paradox of Legacy Code!</p>
<p>So, how do you go about it? Are you doomed?</p>
<p>You‚Äôre not. But you should be extra careful until you got tests in place. You should perform minimal, safe refactorings.</p>
<p><strong>Change as little code as possible to get tests in place.</strong></p>
<p>The recipe is:</p>
<ol>
<li>Identify change points (Seams)</li>
<li>Break dependencies</li>
<li>Write the tests</li>
<li>Make your changes</li>
<li>Refactor</li>
</ol>
<p>Once you get to the tests, you know how to proceed. The first two points are the difficult ones.</p>
<h2 id="identify-seams-to-break-your-code-dependencies"><a href="#identify-seams-to-break-your-code-dependencies"><svg aria-hidden="true" version="1.1" viewBox="0 0 511.997 511.997" width="22" height="22"><path d="M212.26,390.24l-60.331,60.331c-25.012,25.012-65.517,25.012-90.508,0.005c-24.996-24.996-24.996-65.505-0.005-90.496 l120.683-120.683c24.991-24.992,65.5-24.992,90.491,0c8.331,8.331,21.839,8.331,30.17,0c8.331-8.331,8.331-21.839,0-30.17 c-41.654-41.654-109.177-41.654-150.831,0L31.247,329.909c-41.654,41.654-41.654,109.177,0,150.831 c41.649,41.676,109.177,41.676,150.853,0l60.331-60.331c8.331-8.331,8.331-21.839,0-30.17S220.591,381.909,212.26,390.24z"></path><path d="M480.751,31.24c-41.654-41.654-109.199-41.654-150.853,0l-72.384,72.384c-8.331,8.331-8.331,21.839,0,30.17 c8.331,8.331,21.839,8.331,30.17,0l72.384-72.384c24.991-24.992,65.521-24.992,90.513,0c24.991,24.991,24.991,65.5,0,90.491 L317.845,284.638c-24.992,24.992-65.5,24.992-90.491,0c-8.331-8.331-21.839-8.331-30.17,0s-8.331,21.839,0,30.17 c41.654,41.654,109.177,41.654,150.831,0l132.736-132.736C522.405,140.418,522.405,72.894,480.751,31.24z"></path></svg></a>Identify Seams to break your code dependencies</h2>
<p>Adding tests on the existing code can be challenging.</p>
<p>Hell, it‚Äôs usually a nightmare!</p>
<p>That‚Äôs because the code was not written to be <em>testable</em> in the first place. 99% of the time, this is a dependency problem: the code you want to test can‚Äôt run because it needs <em>something</em> hard to put in the test.</p>
<p>Sometimes it‚Äôs a database connection. Sometimes it‚Äôs a call to a third-party server. Sometimes it‚Äôs a parameter that‚Äôs complex to instantiate. Usually, it‚Äôs a complex mix of all that.</p>
<p>To test your code, you need to <strong>break these dependencies</strong> in the tests.</p>
<p>Therefore, you need to identify <strong>Seams</strong>.</p>
<blockquote>
<p>‚ÄúA Seam is a place to alter program behavior, without changing the code.‚Äù</p>
</blockquote>
<p>There are different types of Seams. The gist of it is to identify how you can change the code behavior without touching the source code.</p>
<p>If your language is Object-Oriented, the most common and convenient Seam is an object.</p>
<p>Consider this piece of JavaScript code:</p>
<div><p>js</p><pre tabindex="0" data-language="js"><code><span><span>export</span><span> class</span><span> DatabaseConnector</span><span> {</span></span>
<span><span>  // A lot of code‚Ä¶</span></span>
<span></span>
<span><span>  connect</span><span>() {</span></span>
<span><span>    // Perform some calls to connect to the DB.</span></span>
<span><span>  }</span></span>
<span><span>}</span></span></code></pre></div>
<p>Say the <code>connect()</code> method is causing you problems when you try to put code into tests. Well, the whole class is a Seam you can alter.</p>
<p>You can extend this class in tests to prevent it from connecting to an actual DB:</p>
<div><p>js</p><pre tabindex="0" data-language="js"><code><span><span>class</span><span> FakeDatabaseConnector</span><span> extends</span><span> DatabaseConnector</span><span> {</span></span>
<span><span>  connect</span><span>() {</span></span>
<span><span>    // Override the problematic calls to the DB</span></span>
<span><span>    console.</span><span>log</span><span>(</span><span>&#34;Connect to the DB&#34;</span><span>)</span></span>
<span><span>  }</span></span>
<span><span>}</span></span></code></pre></div>
<p>There are other kinds of Seams.</p>
<p>If your language allows you to change code behavior without altering the source code, you have an entry point to writing the tests.</p>
<p>Speaking about tests‚Ä¶</p>
<h2 id="unit-tests-are-fast-and-reliable"><a href="#unit-tests-are-fast-and-reliable"><svg aria-hidden="true" version="1.1" viewBox="0 0 511.997 511.997" width="22" height="22"><path d="M212.26,390.24l-60.331,60.331c-25.012,25.012-65.517,25.012-90.508,0.005c-24.996-24.996-24.996-65.505-0.005-90.496 l120.683-120.683c24.991-24.992,65.5-24.992,90.491,0c8.331,8.331,21.839,8.331,30.17,0c8.331-8.331,8.331-21.839,0-30.17 c-41.654-41.654-109.177-41.654-150.831,0L31.247,329.909c-41.654,41.654-41.654,109.177,0,150.831 c41.649,41.676,109.177,41.676,150.853,0l60.331-60.331c8.331-8.331,8.331-21.839,0-30.17S220.591,381.909,212.26,390.24z"></path><path d="M480.751,31.24c-41.654-41.654-109.199-41.654-150.853,0l-72.384,72.384c-8.331,8.331-8.331,21.839,0,30.17 c8.331,8.331,21.839,8.331,30.17,0l72.384-72.384c24.991-24.992,65.521-24.992,90.513,0c24.991,24.991,24.991,65.5,0,90.491 L317.845,284.638c-24.992,24.992-65.5,24.992-90.491,0c-8.331-8.331-21.839-8.331-30.17,0s-8.331,21.839,0,30.17 c41.654,41.654,109.177,41.654,150.831,0l132.736-132.736C522.405,140.418,522.405,72.894,480.751,31.24z"></path></svg></a>Unit tests are fast and reliable</h2>
<p>Discussions about testing best practices usually turn into heated debates. Should you apply the <a href="https://martinfowler.com/articles/practical-test-pyramid.html">Pyramid of Tests</a> principle and write a maximum of unit tests? Or should you embrace <a href="https://kentcdodds.com/blog/write-tests/">the Testing Trophy</a> instead and write mostly integration tests?</p>
<blockquote>
<p>Why are people giving contradictory advice?</p>
</blockquote>
<p>Because <strong>they don‚Äôt have the same definition of what a ‚Äúunit‚Äù is</strong>. Thus, some people talk about ‚Äúintegration tests‚Äù when others talk about ‚Äúunit tests‚Äù.</p>
<p>To avoid any confusion, Michael Feathers gives a clear definition of <strong>what is NOT</strong> a unit test.</p>
<p>In short, your test is not unit if:</p>
<ol>
<li>it doesn‚Äôt run fast (&lt; 100ms / test)</li>
<li>it talks to the Infrastructure (e.g. a database, the network, the file system, environment variables‚Ä¶)</li>
</ol>
<p>Write a maximum of tests that have these 2 qualities. How you call them doesn‚Äôt matter.</p>
<p>Now, sometimes it‚Äôs really hard to write such tests because you don‚Äôt even <em>understand</em> what the code is supposed to do. There‚Äôs a technique for that‚Ä¶</p>
<h2 id="characterization-tests"><a href="#characterization-tests"><svg aria-hidden="true" version="1.1" viewBox="0 0 511.997 511.997" width="22" height="22"><path d="M212.26,390.24l-60.331,60.331c-25.012,25.012-65.517,25.012-90.508,0.005c-24.996-24.996-24.996-65.505-0.005-90.496 l120.683-120.683c24.991-24.992,65.5-24.992,90.491,0c8.331,8.331,21.839,8.331,30.17,0c8.331-8.331,8.331-21.839,0-30.17 c-41.654-41.654-109.177-41.654-150.831,0L31.247,329.909c-41.654,41.654-41.654,109.177,0,150.831 c41.649,41.676,109.177,41.676,150.853,0l60.331-60.331c8.331-8.331,8.331-21.839,0-30.17S220.591,381.909,212.26,390.24z"></path><path d="M480.751,31.24c-41.654-41.654-109.199-41.654-150.853,0l-72.384,72.384c-8.331,8.331-8.331,21.839,0,30.17 c8.331,8.331,21.839,8.331,30.17,0l72.384-72.384c24.991-24.992,65.521-24.992,90.513,0c24.991,24.991,24.991,65.5,0,90.491 L317.845,284.638c-24.992,24.992-65.5,24.992-90.491,0c-8.331-8.331-21.839-8.331-30.17,0s-8.331,21.839,0,30.17 c41.654,41.654,109.177,41.654,150.831,0l132.736-132.736C522.405,140.418,522.405,72.894,480.751,31.24z"></path></svg></a>Characterization tests</h2>
<p>Before you can refactor the code, you need tests. But writing these tests can be challenging. Especially when code is hard to understand.</p>
<blockquote>
<p>‚ÄúA characterization test is a test that characterizes the actual behavior of a piece of code.‚Äù</p>
</blockquote>
<p>Instead of writing comprehensive unit tests, you capture the current behavior of the code. You take a snapshot of what it does.</p>
<p>The test ensures that this behavior doesn‚Äôt change!</p>
<p>This is very powerful because:</p>
<ol>
<li>With most systems, what the code <em>actually</em> does is more important than what it <em>should</em> do.</li>
<li>You can quickly cover Legacy Code with these tests, giving you a safety net to refactor.</li>
</ol>
<p>This technique is also called ‚Äú<em>Approval Testing</em>‚Äù, ‚Äú<em>Snapshot Testing</em>‚Äù or ‚Äú<em>Golden Master</em>‚Äù in the wild. Same stuff.</p>
<p>And I also blogged about it: <a href="https://understandlegacycode.com/blog/3-steps-to-add-tests-on-existing-code-when-you-have-short-deadlines">the 3 steps to add tests on Legacy Code when you have short deadlines</a>.</p>
<p>Having short deadlines is a very common situation. When you are in a hurry, it‚Äôs hard to take the time not to make things worse. Hopefully, there‚Äôs something you can do‚Ä¶</p>
<h2 id="use-sprout--wrap-techniques-to-add-code-when-you-dont-have-time-to-refactor"><a href="#use-sprout--wrap-techniques-to-add-code-when-you-dont-have-time-to-refactor"><svg aria-hidden="true" version="1.1" viewBox="0 0 511.997 511.997" width="22" height="22"><path d="M212.26,390.24l-60.331,60.331c-25.012,25.012-65.517,25.012-90.508,0.005c-24.996-24.996-24.996-65.505-0.005-90.496 l120.683-120.683c24.991-24.992,65.5-24.992,90.491,0c8.331,8.331,21.839,8.331,30.17,0c8.331-8.331,8.331-21.839,0-30.17 c-41.654-41.654-109.177-41.654-150.831,0L31.247,329.909c-41.654,41.654-41.654,109.177,0,150.831 c41.649,41.676,109.177,41.676,150.853,0l60.331-60.331c8.331-8.331,8.331-21.839,0-30.17S220.591,381.909,212.26,390.24z"></path><path d="M480.751,31.24c-41.654-41.654-109.199-41.654-150.853,0l-72.384,72.384c-8.331,8.331-8.331,21.839,0,30.17 c8.331,8.331,21.839,8.331,30.17,0l72.384-72.384c24.991-24.992,65.521-24.992,90.513,0c24.991,24.991,24.991,65.5,0,90.491 L317.845,284.638c-24.992,24.992-65.5,24.992-90.491,0c-8.331-8.331-21.839-8.331-30.17,0s-8.331,21.839,0,30.17 c41.654,41.654,109.177,41.654,150.831,0l132.736-132.736C522.405,140.418,522.405,72.894,480.751,31.24z"></path></svg></a>Use Sprout &amp; Wrap techniques to add code when you don‚Äôt have time to refactor</h2>
<p>Big lumps of code have a gravitational force. They <em>attract</em> more code. If the class is already 2,000 lines-long, who cares that you add 3 more <code>if</code> statements?</p>
<p>Well, you should. Now you have to maintain a 2,0<strong>10</strong> lines-long class!</p>
<p>But what if you really, <em>really</em> don‚Äôt have time to write tests for that class? That‚Äôs just 3 <code>if</code> statements and you might not feel like you can justify taking 2 days for that ‚Äî although you should.</p>
<p><img src="https://understandlegacycode.com/assets/time-for-dat.jpg" alt=""/></p>
<p>In such a tricky position, you can still make the right call with these 2 techniques.</p>
<h3 id="1-the-sprout-technique"><a href="#1-the-sprout-technique"><svg aria-hidden="true" version="1.1" viewBox="0 0 511.997 511.997" width="22" height="22"><path d="M212.26,390.24l-60.331,60.331c-25.012,25.012-65.517,25.012-90.508,0.005c-24.996-24.996-24.996-65.505-0.005-90.496 l120.683-120.683c24.991-24.992,65.5-24.992,90.491,0c8.331,8.331,21.839,8.331,30.17,0c8.331-8.331,8.331-21.839,0-30.17 c-41.654-41.654-109.177-41.654-150.831,0L31.247,329.909c-41.654,41.654-41.654,109.177,0,150.831 c41.649,41.676,109.177,41.676,150.853,0l60.331-60.331c8.331-8.331,8.331-21.839,0-30.17S220.591,381.909,212.26,390.24z"></path><path d="M480.751,31.24c-41.654-41.654-109.199-41.654-150.853,0l-72.384,72.384c-8.331,8.331-8.331,21.839,0,30.17 c8.331,8.331,21.839,8.331,30.17,0l72.384-72.384c24.991-24.992,65.521-24.992,90.513,0c24.991,24.991,24.991,65.5,0,90.491 L317.845,284.638c-24.992,24.992-65.5,24.992-90.491,0c-8.331-8.331-21.839-8.331-30.17,0s-8.331,21.839,0,30.17 c41.654,41.654,109.177,41.654,150.831,0l132.736-132.736C522.405,140.418,522.405,72.894,480.751,31.24z"></path></svg></a>1. The Sprout technique</h3>
<ol>
<li>Create your code somewhere else.</li>
<li>Unit test it.</li>
<li>Identify where you should call that code from the existing code: the <em>insertion point</em>.</li>
<li>Call your code from the Legacy Code.</li>
</ol>
<p>Consider the following example:</p>
<div><p>js</p><pre tabindex="0" data-language="js"><code><span><span>class</span><span> TransactionGate</span><span> {</span></span>
<span><span>  // ‚Ä¶ a lot of code</span></span>
<span></span>
<span><span>  postEntries</span><span>(</span><span>entries</span><span>) {</span></span>
<span><span>    for</span><span> (</span><span>let</span><span> entry </span><span>of</span><span> entries) {</span></span>
<span><span>      entry.</span><span>postDate</span><span>()</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    // ‚Ä¶ a lot of code</span></span>
<span></span>
<span><span>    transactionBundle.</span><span>getListManager</span><span>().</span><span>add</span><span>(entries)</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  // ‚Ä¶ a lot of code</span></span>
<span><span>}</span></span></code></pre></div>
<p>Say you need to deduplicate the <code>entries</code>, but <code>postEntries()</code> is hard to test and you really don‚Äôt have time for that.</p>
<p>You can <em>sprout</em> the code somewhere else, like in a new method <code>uniqueEntries()</code>.</p>
<p>This new method, you can test easily, because it‚Äôs isolated.</p>
<p>Then, insert a call to that method in the existing, non-tested code. Minimal change, minimal risk.</p>
<div><p>js</p><pre tabindex="0" data-language="js"><code><span><span>class</span><span> TransactionGate</span><span> {</span></span>
<span><span>  // ‚Ä¶ a lot of code</span></span>
<span></span>
<span><span>  uniqueEntries</span><span>(</span><span>entries</span><span>) {</span></span>
<span><span>    // Some clever logic to dedupe entries, fully tested!</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  postEntries</span><span>(</span><span>entries</span><span>) {</span></span>
<span><span>    const</span><span> uniqueEntries</span><span> =</span><span> this</span><span>.</span><span>uniqueEntries</span><span>(entries)</span></span>
<span></span>
<span><span>    for</span><span> (</span><span>let</span><span> entry </span><span>of</span><span> uniqueEntries) {</span></span>
<span><span>      entry.</span><span>postDate</span><span>()</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    // ‚Ä¶ a lot of code</span></span>
<span></span>
<span><span>    transactionBundle.</span><span>getListManager</span><span>().</span><span>add</span><span>(uniqueEntries)</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  // ‚Ä¶ a lot of code</span></span>
<span><span>}</span></span></code></pre></div>
<p>The diff might be clearer:</p>
<div><p>diff</p><pre tabindex="0" data-language="diff"><code><span><span>class TransactionGate {</span></span>
<span><span>  // ‚Ä¶ a lot of code</span></span>
<span></span>
<span><span><span>+</span>  uniqueEntries(entries) {</span></span>
<span><span><span>+</span>    // Some clever logic to dedupe entries, fully tested!</span></span>
<span><span><span>+</span>  }</span></span>
<span></span>
<span><span>  postEntries(entries) {</span></span>
<span><span><span>+</span>    const uniqueEntries = this.uniqueEntries(entries)</span></span>
<span><span><span>+</span></span></span>
<span><span><span>+</span>    for (let entry of uniqueEntries) {</span></span>
<span><span><span>-</span>    for (let entry of entries) {</span></span>
<span><span>      entry.postDate()</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    // ‚Ä¶ a lot of code</span></span>
<span></span>
<span><span><span>+</span>    transactionBundle.getListManager().add(uniqueEntries)</span></span>
<span><span><span>-</span>    transactionBundle.getListManager().add(entries)</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  // ‚Ä¶ a lot of code</span></span>
<span><span>}</span></span></code></pre></div>
<p>You can Sprout a single method, a whole class or anything that will isolate your new code.</p>
<h3 id="2-the-wrap-technique"><a href="#2-the-wrap-technique"><svg aria-hidden="true" version="1.1" viewBox="0 0 511.997 511.997" width="22" height="22"><path d="M212.26,390.24l-60.331,60.331c-25.012,25.012-65.517,25.012-90.508,0.005c-24.996-24.996-24.996-65.505-0.005-90.496 l120.683-120.683c24.991-24.992,65.5-24.992,90.491,0c8.331,8.331,21.839,8.331,30.17,0c8.331-8.331,8.331-21.839,0-30.17 c-41.654-41.654-109.177-41.654-150.831,0L31.247,329.909c-41.654,41.654-41.654,109.177,0,150.831 c41.649,41.676,109.177,41.676,150.853,0l60.331-60.331c8.331-8.331,8.331-21.839,0-30.17S220.591,381.909,212.26,390.24z"></path><path d="M480.751,31.24c-41.654-41.654-109.199-41.654-150.853,0l-72.384,72.384c-8.331,8.331-8.331,21.839,0,30.17 c8.331,8.331,21.839,8.331,30.17,0l72.384-72.384c24.991-24.992,65.521-24.992,90.513,0c24.991,24.991,24.991,65.5,0,90.491 L317.845,284.638c-24.992,24.992-65.5,24.992-90.491,0c-8.331-8.331-21.839-8.331-30.17,0s-8.331,21.839,0,30.17 c41.654,41.654,109.177,41.654,150.831,0l132.736-132.736C522.405,140.418,522.405,72.894,480.751,31.24z"></path></svg></a>2. The Wrap technique</h3>
<p>When the change you need to do should happen before or after the existing code, you can also <em>wrap</em> it.</p>
<ol>
<li>Rename the old method you want to wrap.</li>
<li>Create a new method with the same name and signature as the old method.</li>
<li>Call the old method from the new method.</li>
<li>Put the new logic before/after the other method call.</li>
</ol>
<p>That new logic, you can test.</p>
<p>Why? Because the old method is a Seam you can alter in the tests.</p>
<p>Remember the previous code?</p>
<div><p>js</p><pre tabindex="0" data-language="js"><code><span><span>class</span><span> TransactionGate</span><span> {</span></span>
<span><span>  // ‚Ä¶ a lot of code</span></span>
<span></span>
<span><span>  postEntries</span><span>(</span><span>entries</span><span>) {</span></span>
<span><span>    for</span><span> (</span><span>let</span><span> entry </span><span>of</span><span> entries) {</span></span>
<span><span>      entry.</span><span>postDate</span><span>()</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    // ‚Ä¶ a lot of code</span></span>
<span></span>
<span><span>    transactionBundle.</span><span>getListManager</span><span>().</span><span>add</span><span>(entries)</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  // ‚Ä¶ a lot of code</span></span>
<span><span>}</span></span></code></pre></div>
<p>Another way to tackle the problem would be to wrap it, so we pass to <code>postEntries()</code> the list of deduped entries:</p>
<div><p>js</p><pre tabindex="0" data-language="js"><code><span><span>class</span><span> TransactionGate</span><span> {</span></span>
<span><span>  // ‚Ä¶ a lot of code</span></span>
<span></span>
<span><span>  postEntries</span><span>(</span><span>entries</span><span>) {</span></span>
<span><span>    // Some clever logic to retrieve unique entries</span></span>
<span><span>    this</span><span>.</span><span>postEntriesThatAreUnique</span><span>(uniqueEntries)</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  postEntriesThatAreUnique</span><span>(</span><span>entries</span><span>) {</span></span>
<span><span>    for</span><span> (</span><span>let</span><span> entry </span><span>of</span><span> entries) {</span></span>
<span><span>      entry.</span><span>postDate</span><span>()</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    // ‚Ä¶ a lot of code</span></span>
<span></span>
<span><span>    transactionBundle.</span><span>getListManager</span><span>().</span><span>add</span><span>(entries)</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  // ‚Ä¶ a lot of code</span></span>
<span><span>}</span></span></code></pre></div>
<p>In tests, you‚Äôd alter the problematic <code>postEntriesThatAreUnique()</code>, so you can test the dedupe logic works.</p>
<p>The diff might be clearer:</p>
<div><p>diff</p><pre tabindex="0" data-language="diff"><code><span><span>class TransactionGate {</span></span>
<span><span>  // ‚Ä¶ a lot of code</span></span>
<span></span>
<span><span><span>+</span>  postEntries(entries) {</span></span>
<span><span><span>+</span>    // Some clever logic to retrieve unique entries</span></span>
<span><span><span>+</span>    this.postEntriesThatAreUnique(uniqueEntries)</span></span>
<span><span><span>+</span>  }</span></span>
<span></span>
<span><span><span>+</span>  postEntriesThatAreUnique(entries) {</span></span>
<span><span><span>-</span>  postEntries(entries) {</span></span>
<span><span>    for (let entry of entries) {</span></span>
<span><span>      entry.postDate()</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    // ‚Ä¶ a lot of code</span></span>
<span></span>
<span><span>    transactionBundle.getListManager().add(entries)</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  // ‚Ä¶ a lot of code</span></span>
<span><span>}</span></span></code></pre></div>
<p>These techniques are not ideal and they have pitfalls. But they are useful tools to have when addressing Legacy Code.</p>
<p>And when necessary, you can even bend the rules a bit‚Ä¶</p>
<h2 id="use-scratch-refactoring-to-get-familiar-with-the-code"><a href="#use-scratch-refactoring-to-get-familiar-with-the-code"><svg aria-hidden="true" version="1.1" viewBox="0 0 511.997 511.997" width="22" height="22"><path d="M212.26,390.24l-60.331,60.331c-25.012,25.012-65.517,25.012-90.508,0.005c-24.996-24.996-24.996-65.505-0.005-90.496 l120.683-120.683c24.991-24.992,65.5-24.992,90.491,0c8.331,8.331,21.839,8.331,30.17,0c8.331-8.331,8.331-21.839,0-30.17 c-41.654-41.654-109.177-41.654-150.831,0L31.247,329.909c-41.654,41.654-41.654,109.177,0,150.831 c41.649,41.676,109.177,41.676,150.853,0l60.331-60.331c8.331-8.331,8.331-21.839,0-30.17S220.591,381.909,212.26,390.24z"></path><path d="M480.751,31.24c-41.654-41.654-109.199-41.654-150.853,0l-72.384,72.384c-8.331,8.331-8.331,21.839,0,30.17 c8.331,8.331,21.839,8.331,30.17,0l72.384-72.384c24.991-24.992,65.521-24.992,90.513,0c24.991,24.991,24.991,65.5,0,90.491 L317.845,284.638c-24.992,24.992-65.5,24.992-90.491,0c-8.331-8.331-21.839-8.331-30.17,0s-8.331,21.839,0,30.17 c41.654,41.654,109.177,41.654,150.831,0l132.736-132.736C522.405,140.418,522.405,72.894,480.751,31.24z"></path></svg></a>Use scratch refactoring to get familiar with the code</h2>
<p>When you‚Äôve to work with a code that you didn‚Äôt write, that is not tested and that is poorly documented, it‚Äôs overwhelming!</p>
<p>Let me remind you of the ‚Äúhow to tackle Legacy Code‚Äù recipe:</p>
<ol>
<li>Identify change points (Seams)</li>
<li>Break dependencies</li>
<li>Write the tests</li>
<li>Make your changes</li>
<li>Refactor</li>
</ol>
<p>So first, you need to break dependencies and write the tests. But where do you even start when code is really opaque?</p>
<p>A good technique is <em>scratch refactoring</em>!</p>
<p>The goal is to get familiar with the code, not to actually clean it.</p>
<p>The only rule is: <strong>revert your changes when you‚Äôre done</strong>.</p>
<p>If you do that, then you can do unsafe changes!</p>
<p>Play with the code as much as you want. Extract functions, simplify code, rename variables‚Ä¶ Get to know the code. Once you do, revert your changes and start over with proper tests.</p>
<p>Let‚Äôs conclude our review on a cautionary tale‚Ä¶</p>
<h2 id="dont-make-your-code-depend-on-libraries-implementation"><a href="#dont-make-your-code-depend-on-libraries-implementation"><svg aria-hidden="true" version="1.1" viewBox="0 0 511.997 511.997" width="22" height="22"><path d="M212.26,390.24l-60.331,60.331c-25.012,25.012-65.517,25.012-90.508,0.005c-24.996-24.996-24.996-65.505-0.005-90.496 l120.683-120.683c24.991-24.992,65.5-24.992,90.491,0c8.331,8.331,21.839,8.331,30.17,0c8.331-8.331,8.331-21.839,0-30.17 c-41.654-41.654-109.177-41.654-150.831,0L31.247,329.909c-41.654,41.654-41.654,109.177,0,150.831 c41.649,41.676,109.177,41.676,150.853,0l60.331-60.331c8.331-8.331,8.331-21.839,0-30.17S220.591,381.909,212.26,390.24z"></path><path d="M480.751,31.24c-41.654-41.654-109.199-41.654-150.853,0l-72.384,72.384c-8.331,8.331-8.331,21.839,0,30.17 c8.331,8.331,21.839,8.331,30.17,0l72.384-72.384c24.991-24.992,65.521-24.992,90.513,0c24.991,24.991,24.991,65.5,0,90.491 L317.845,284.638c-24.992,24.992-65.5,24.992-90.491,0c-8.331-8.331-21.839-8.331-30.17,0s-8.331,21.839,0,30.17 c41.654,41.654,109.177,41.654,150.831,0l132.736-132.736C522.405,140.418,522.405,72.894,480.751,31.24z"></path></svg></a>Don‚Äôt make your code depend on libraries‚Äô implementation</h2>
<blockquote>
<p>‚ÄúAvoid littering direct calls to library classes in your code. You might think that you‚Äôll never change them, but that can become a self-fulfilling prophecy.‚Äù</p>
</blockquote>
<p>I wanted to highlight this advice because it‚Äôs a very common mistake. I‚Äôve seen that a lot!</p>
<p>We use libraries to do the job and save us time. So far so good.</p>
<p>But rarely we take the extra time to wrap these tools behind custom abstractions that <strong>we</strong> own.</p>
<p>Therefore, their implementation leaks across our codebase! All of our code quickly depends on a specific API. It spreads like a parasite. Until someday we easily get rid of it or do a major upgrade of that library.</p>
<p>Think about all the ORM code, monitoring libs, utility packages that you use. Do you control them? Or do you depend on them?</p>
<h2 id="should-you-read-that-book-it-still-looks-old"><a href="#should-you-read-that-book-it-still-looks-old"><svg aria-hidden="true" version="1.1" viewBox="0 0 511.997 511.997" width="22" height="22"><path d="M212.26,390.24l-60.331,60.331c-25.012,25.012-65.517,25.012-90.508,0.005c-24.996-24.996-24.996-65.505-0.005-90.496 l120.683-120.683c24.991-24.992,65.5-24.992,90.491,0c8.331,8.331,21.839,8.331,30.17,0c8.331-8.331,8.331-21.839,0-30.17 c-41.654-41.654-109.177-41.654-150.831,0L31.247,329.909c-41.654,41.654-41.654,109.177,0,150.831 c41.649,41.676,109.177,41.676,150.853,0l60.331-60.331c8.331-8.331,8.331-21.839,0-30.17S220.591,381.909,212.26,390.24z"></path><path d="M480.751,31.24c-41.654-41.654-109.199-41.654-150.853,0l-72.384,72.384c-8.331,8.331-8.331,21.839,0,30.17 c8.331,8.331,21.839,8.331,30.17,0l72.384-72.384c24.991-24.992,65.521-24.992,90.513,0c24.991,24.991,24.991,65.5,0,90.491 L317.845,284.638c-24.992,24.992-65.5,24.992-90.491,0c-8.331-8.331-21.839-8.331-30.17,0s-8.331,21.839,0,30.17 c41.654,41.654,109.177,41.654,150.831,0l132.736-132.736C522.405,140.418,522.405,72.894,480.751,31.24z"></path></svg></a>Should you read that book, it still looks old?</h2>
<p><strong>Of course, you should.</strong></p>
<p>While I have given you an overview of the advice in the book, there is many more examples and approaches in the book itself!</p>
<p>You have to deal with Legacy Code every day. This is one of the most actionable resources you can find on the topic.</p>
<p>You might have read (or listed) other books such as Clean Code and Refactoring. These are must-reads too. But I‚Äôd recommend starting with Working Effectively with Legacy Code.</p>
<p>If you want to refactor your code, you first need to put tests on it. And putting tests on an existing, tangled mess is the point of Michael Feathers‚Äô book.</p>
<blockquote>
<p>But the code examples are in Java and C++ and I do python/JavaScript/ruby/‚Ä¶</p>
</blockquote>
<p>Granted, you might not feel comfortable with the code examples from the book being written in a language you don‚Äôt know.</p>
<p>But that‚Äôs OK for 2 reasons:</p>
<ol>
<li>Legacy Code is not always easy to read, so that‚Äôs actually relevant. It‚Äôs a skill you need to practice.</li>
<li>Java code is object-oriented code that you should be able to understand, even if you don‚Äôt know the language.</li>
</ol>
<p>So, again: this summary gives you a good overview of what kind of advice are in the book. <strong>But there are more!</strong></p>
<p>The book goes in detail into <em>how</em> you can apply these advice through different use-cases. If you liked this summary, you‚Äôll enjoy <a href="https://www.google.com/search?q=working+effectively+with+legacy+code">the book</a>.</p>
<p>Aaaaand you‚Äôll <em>love</em> the content I publish every week! ü§†</p>
<p>Subscribe to my newsletter to receive my Legacy Code tips &amp; tricks, directly in your inbox, every Wednesday.</p>
<p>Take care out there!</p> </div></div>
  </body>
</html>
