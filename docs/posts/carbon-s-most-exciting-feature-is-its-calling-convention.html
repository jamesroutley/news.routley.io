<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.foonathan.net/2022/07/carbon-calling-convention/">Original</a>
    <h1>Carbon’s most exciting feature is its calling convention</h1>
    
    <div id="readability-page-1" class="page"><div id="content">





<article>
    <header>
        
        <section>
            
            
        </section>
    </header>
<a id="content"></a>
    <p>Last week, <a href="https://github.com/carbon-language/carbon-lang">Chandler Carruth announced Carbon</a>, a potential C++ replacement they’ve been working on for the past two years.
It has the usual cool features you expect from a modern language: useful generics, compile-time interfaces/traits/concepts, modules, etc.
– but the thing I’m most excited about is a tiny detail about the way parameters are passed there.</p>
<p>It’s something I’ve been thinking about in the past myself, and to my knowledge it hasn’t been done in any low-level language before, but the concept has a lot of potential.
Let me explain what I’m talking about.</p>
    <a id="more"></a>
    
    
<h2 id="carbons-parameter-passing">Carbon’s parameter passing</h2>
<p>By default, i.e. if you don’t write anything else, Carbon parameters are passed by the equivalent of a <code>const T&amp;</code> in C++.</p>
<pre tabindex="0"><code data-lang="carbon">class Point
{
  var x: i64;
  var y: i64;
  var z: i64;
}

fn Print(p : Point);
</code></pre><div><pre tabindex="0"><code data-lang="cpp"><span><span><span>struct</span> <span>Point</span>
</span></span><span><span><span>{</span>
</span></span><span><span>    <span>std</span><span>::</span><span>uint64_t</span> <span>x</span><span>,</span> <span>y</span><span>,</span> <span>z</span><span>;</span>
</span></span><span><span><span>};</span>
</span></span><span><span>
</span></span><span><span><span>void</span> <span>Print</span><span>(</span><span>const</span> <span>Point</span><span>&amp;</span> <span>p</span><span>);</span>
</span></span></code></pre></div><p>However – and this is the import part – the compiler is allowed to convert that to a <code>T</code> under the <a href="https://en.cppreference.com/w/cpp/language/as_if">as-if rule</a>.</p>
<pre tabindex="0"><code data-lang="carbon">fn Print(x : i32);
</code></pre><div><pre tabindex="0"><code data-lang="cpp"><span><span><span>void</span> <span>Print</span><span>(</span><span>std</span><span>::</span><span>int32_t</span> <span>x</span><span>);</span>
</span></span></code></pre></div><p>… and so what? Why am I so excited about that?</p>
<h2 id="advantage-1-performance">Advantage #1: Performance</h2>
<p>Passing things by <code>const T&amp;</code> is always good, right? After all, you’re avoiding a copy!</p>
<p>While true, references are essentially pointers on the assembly level.
This means that passing an argument by <code>const T&amp;</code> sets a register to its address, which means</p>
<ol>
<li>in the caller, the argument needs an address and must be stored in memory somewhere, and</li>
<li>in the callee, the parameter needs to load the value from memory when its read.</li>
</ol>
<p>This is the only options for types that don’t fit in a register, or small types with non-trivial copy constructors,
but it’s less ideal for trivially copyable types that do fit.</p>
<p><a href="https://godbolt.org/z/qTrP3oMT3">Compare the assembly</a> between the <code>add</code> function that takes its arguments by <code>const T&amp;</code></p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>[[gnu::noinline]]</span> <span>int</span> <span>add</span><span>(</span><span>const</span> <span>int</span><span>&amp;</span> <span>a</span><span>,</span> <span>const</span> <span>int</span><span>&amp;</span> <span>b</span><span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>    <span>return</span> <span>a</span> <span>+</span> <span>b</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>int</span> <span>foo</span><span>()</span>
</span></span><span><span><span>{</span>
</span></span><span><span>    <span>return</span> <span>add</span><span>(</span><span>11</span><span>,</span> <span>42</span><span>);</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>and the one that doesn’t</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>[[gnu::noinline]]</span> <span>int</span> <span>add</span><span>(</span><span>int</span> <span>a</span><span>,</span> <span>int</span> <span>b</span><span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>    <span>return</span> <span>a</span> <span>+</span> <span>b</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>int</span> <span>foo</span><span>()</span>
</span></span><span><span><span>{</span>
</span></span><span><span>    <span>return</span> <span>add</span><span>(</span><span>11</span><span>,</span> <span>42</span><span>);</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>All the memory stores and loads just disappear;
you don’t want to be passing <code>int</code>’s by reference!</p>
<p>So it’s really nice that in Carbon you don’t need to think about it – the compiler will just do the correct thing for you.
Furthermore, you can’t always do it manually.</p>
<h2 id="advantage-2-optimal-calling-convention-in-generic-code">Advantage #2: Optimal calling convention in generic code</h2>
<p>Suppose we want to write a generic function print function in C++.
The type can be arbitrarily large with an arbitrarily expensive copy constructor, so the you should use <code>const T&amp;</code> in generic code.</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>template</span> <span>&lt;</span><span>typename</span> <span>T</span><span>&gt;</span>
</span></span><span><span><span>void</span> <span>Print</span><span>(</span><span>const</span> <span>T</span><span>&amp;</span> <span>obj</span><span>);</span>
</span></span></code></pre></div><p>However, this pessimizes the situation for small and cheap types, which is unfortunate.
It’s also not something the compiler can fix with optimizations, because the function signature and calling convention is part of the – here comes our favorite three-letter acronym – ABI.
At best, the compiler can inline it and elide the entire call.</p>
<p>There are <a href="https://www.boost.org/doc/libs/1_79_0/libs/utility/doc/html/utility/utilities/call_traits.html">ways to work around that problem</a>, because of course there are, but it just works™ in Carbon, which is nice.</p>
<p>But the real reason I’m excited about the feature has nothing to do with eliding memory load/stores.</p>
<h2 id="advantage-3-copies-that-arent-copies">Advantage #3: Copies that aren’t copies</h2>
<p>Note that the transformation the compiler can do isn’t quite the same as <code>const T&amp;</code> -&gt; <code>T</code> in C++ would do.
The latter creates a copy of the argument: if needed, it will invoke the copy constructor and destructor.</p>
<p>In Carbon, this isn’t the case: the value is simply set to a register.
As the called function does not call the destructor of the parameter, the caller does not need to call the copy constructor.
This means that the optimization would even be valid for Carbon’s equivalent of <code>std::unique_ptr</code>.
The caller simply sets a register to the underlying pointer value, and the callee can access it.
No transfer of ownership happens here.</p>
<p>This isn’t something you can do in (standard) C++.</p>
<h2 id="advantage-4-parameters-without-address">Advantage #4: Parameters without address</h2>
<p>If you’ve been thinking about the consequences of that language feature, you might wonder about Carbon code like the following:</p>
<pre tabindex="0"><code data-lang="carbon">fn Print(p : Point)
{
    var ptr : Point* = &amp;p;
    …
}
</code></pre><p>If the compiler decides to pass <code>p</code> in a register, you can’t create a pointer to it.
So the code doesn’t compile - you must not take the address of a parameter (unless its declared using the <code>var</code> keyword).</p>
<p>Without additional annotation, parameters of a Carbon function do not expose their address to the compiler, as they might not have any.
<em>This</em> is the real reason I’m so excited about that feature.</p>
<h3 id="more-precise-escape-analysis">More precise escape analysis</h3>
<p>Since a programmer can’t take the address of a parameter, <a href="https://en.wikipedia.org/wiki/Escape_analysis">escape analysis</a> does not need to consider them.
For example, in the following C++ code, what is returned by the function?</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>void</span> <span>take_by_ref</span><span>(</span><span>const</span> <span>int</span><span>&amp;</span> <span>i</span><span>);</span>
</span></span><span><span>
</span></span><span><span><span>void</span> <span>do_sth</span><span>();</span>
</span></span><span><span>
</span></span><span><span><span>int</span> <span>foo</span><span>()</span>
</span></span><span><span><span>{</span>
</span></span><span><span>    <span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>    <span>take_by_ref</span><span>(</span><span>i</span><span>);</span>
</span></span><span><span>    <span>i</span> <span>=</span> <span>11</span><span>;</span>
</span></span><span><span>    <span>do_sth</span><span>();</span>
</span></span><span><span>    <span>return</span> <span>i</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Well, <code>11</code> right?</p>
<p>However, the following is a valid implementation of <code>take_by_ref()</code> and <code>do_sth()</code>:</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>int</span><span>*</span> <span>ptr</span><span>;</span> <span>// global variable
</span></span></span><span><span><span></span>
</span></span><span><span><span>void</span> <span>take_by_ref</span><span>(</span><span>const</span> <span>int</span><span>&amp;</span> <span>i</span><span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>    <span>// i wasn&#39;t const to begin with, so it&#39;s fine
</span></span></span><span><span><span></span>    <span>ptr</span> <span>=</span> <span>&amp;</span><span>const_cast</span><span>&lt;</span><span>int</span><span>&amp;&gt;</span><span>(</span><span>i</span><span>);</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>void</span> <span>do_sth</span><span>()</span>
</span></span><span><span><span>{</span>
</span></span><span><span>    <span>*</span><span>ptr</span> <span>=</span> <span>42</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Suddenly, <code>foo()</code> returns <code>42</code> – and this was 100% valid.
As such, the compiler has to separately reload the value stored in <code>i</code> before returning, it <em>escapes</em>.</p>
<p>In Carbon, this is impossible, <code>take_by_ref()</code> can’t sneakily store the address somewhere where it can come back to haunt you.
As such, <code>i</code> will not escape and the compiler can optimize the function to return <code>11</code>.</p>
<h3 id="explicit-address-syntax">Explicit address syntax</h3>
<p>Is the following C++ code okay?</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>class</span> <span>Widget</span>
</span></span><span><span><span>{</span>
</span></span><span><span><span>public</span><span>:</span>
</span></span><span><span>    <span>void</span> <span>DoSth</span><span>(</span><span>const</span> <span>std</span><span>::</span><span>string</span><span>&amp;</span> <span>str</span><span>);</span>
</span></span><span><span><span>};</span>
</span></span><span><span>
</span></span><span><span><span>Widget</span> <span>Foo</span><span>()</span>
</span></span><span><span><span>{</span>
</span></span><span><span>    <span>Widget</span> <span>result</span><span>;</span>
</span></span><span><span>
</span></span><span><span>    <span>std</span><span>::</span><span>string</span> <span>str</span> <span>=</span> <span>&#34;Hello!&#34;</span><span>;</span>
</span></span><span><span>    <span>result</span><span>.</span><span>DoSth</span><span>(</span><span>str</span><span>);</span>
</span></span><span><span>
</span></span><span><span>    <span>return</span> <span>result</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>It depends.</p>
<p><code>Widget::DoSth()</code> can get the address of the function-local string and store it somewhere.
Then when its returned from the function, it contains a dangling pointer.</p>
<p>In Carbon, this is impossible – if widget wants to store a pointer, it needs to accept a pointer:</p>
<pre tabindex="0"><code data-lang="carbon">class Widget
{
    fn DoSth[addr me : Self*](str : String*);
}
</code></pre><p>Crucially, calling code then also needs to take the address:</p>
<pre tabindex="0"><code data-lang="carbon">fn Foo() -&gt; Widget
{
    var result : Widget;

    var str : String = &#34;Hello&#34;;
    result.DoSth(&amp;str);

    return result;
}
</code></pre><p>The extra syntax in the call makes it really obvious that something problematic might be going on here.</p>
<p>For the same reason, <a href="https://stackoverflow.com/questions/26441220/googles-style-guide-about-input-output-parameters-as-pointers">the Google C++ style guide used to require pointers</a> in C++ code in such situations.
This has the unfortunate side-effect that you can pass <code>nullptr</code> to the parameter, so I’ve suggested in the past to <a href="https://github.com/foonathan/type_safe">use my <code>type_safe::object_ref</code> instead</a>.</p>
<blockquote>
<p>This situation also makes it clear that references aren’t simply non-null pointers, which is a common misconception.
<a href="https://www.jonathanmueller.dev/talk/cppnow2018/">References and pointers have crucial differences</a>.</p>
</blockquote>
<h2 id="future-language-extensions">Future language extensions</h2>
<blockquote>
<p>Disclaimer: I’m not a Carbon developer, I’m just someone with opinions.</p>
</blockquote>
<p>In parameters, <code>foo : T</code> is a parameter whose address can’t be taken, and <code>var foo : T</code> is a parameter with an address.
The same principle can also be applied to more situations.
For example, consider the following classes:</p>
<pre tabindex="0"><code data-lang="carbon">class Birthday
{
    var year : i32;
    var month : i8;
    var day : i8;
}

class Person
{
    var birthday : Birthday;
    var number_of_children : i8;
}
</code></pre><blockquote>
<p>I know, it’s silly. Bear with me.</p>
</blockquote>
<p>Assuming Carbon follows the same rules for data layout, as C++ the size of <code>Birthday</code> is 8 bytes (4 bytes for <code>year</code>, 1 for <code>month</code>, 1 for <code>day</code> and 2 padding bytes at the end), and the size of <code>Person</code> is 12 bytes (8 bytes for <code>Birthday</code>, 1 byte for <code>number_of_children</code>, and 3 for padding).</p>
<p>A more optimal layout would eliminate <code>Birthday</code> and inline the members into <code>Person</code>:</p>
<pre tabindex="0"><code data-lang="carbon">class Person
{
    var birthday_year : i32;
    var birthday_month : i8;
    var birthday_day : i8;
    var number_of_children : i8;
}
</code></pre><p>Now, the size of <code>Person</code> is only 8 bytes because <code>number_of_children</code> can be stored in what were padding bytes before.</p>
<p>Is this an optimization the compiler could do?</p>
<p>Not really, because it needs to preserve a separate <code>Birthday</code> subobject: someone could take the address of the <code>birthday</code> member and pass it around.</p>
<blockquote>
<p>While it could work here, because we’re just stuffing things into padding bytes; in general optimal layout might require splitting an existing subobject into two different parts or shuffling the members around differently.
Then there simply exists no contiguous sequence of bytes that make up the member, so there no pointer to it can exist.</p>
</blockquote>
<p>However, we could imagine member variables where you can’t take the address, signified by a lack of <code>var</code>:</p>
<pre tabindex="0"><code data-lang="carbon">class Person
{
    birthday : Birthday;
    number_of_children : i8;
}
</code></pre><p>Now the compiler is free to change the layout, inline struct members and shuffle them around.
Note that taking the address of <code>birthday.month</code> (and the other members) is still fine: it’s been declared with <code>var</code> and its stored contiguously in memory – just not necessarily next to <code>year</code> and <code>day</code>.
<code>var</code> and non-<code>var</code> members can be freely mixed.</p>
<p>Similarly, an optimization that transforms <a href="https://en.wikipedia.org/wiki/AoS_and_SoA">Array of Structs to Struct of Arrays</a> is also invalid, as in the first layout you have each individual struct in one contiguous chunk of memory that have an address, but in the second the struct members have been split.
If you have an array where you can’t take the address of elements however, this isn’t something you can observe.</p>
<p>Finally, extending it to local variables essentially enables the <a href="https://en.wikipedia.org/wiki/Register_(keyword)">register keyword</a> from C: local variables without an address that can safely live in registers.
While it isn’t necessary for modern optimizers, it’s still less work if the compiler doesn’t need to consider them during escape analysis at all.
More importantly, it documents intent to the reader.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Creating entities whose address can’t be taken is a simple feature with lots of potential.
It enables many optimizations to change layout, as layout can’t be observed,
it simplifies escape analysis and optimizes parameter passing.</p>
<p>It’s also not really a limitation in many cases: how often do you actually need to take the address of something?
Marking those few situations with an extra keyword doesn’t cost you anything.</p>
<p>I really wish C++ had it as well, but it wouldn’t work with functions that take references, which makes them useless unless the language was designed around it from the start.</p>
<p>This is exactly where Carbon comes in.</p>

    <blockquote>
        <p>If you&#39;ve liked this blog post, consider <a href="https://paypal.me/foonathan">donating</a> or otherwise <a href="https://jonathanmueller.dev/support-me/" target="_blank">supporting me</a>.</p>
    </blockquote>
    

</article>


    </div></div>
  </body>
</html>
