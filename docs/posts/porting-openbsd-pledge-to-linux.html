<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://justine.lol/pledge/">Original</a>
    <h1>Show HN: Porting OpenBSD Pledge() to Linux</h1>
    
    <div id="readability-page-1" class="page">

<p>
July 13<sup>th</sup>, 2022 @ <a href="http://thewebivore.com/index.html">justine&#39;s web page</a>
</p>

<a href="http://thewebivore.com/on-doing-nothing/openbsd.png"><img width="330" height="290" alt="[OpenBSD Blowfish Logo]" src="http://storage.googleapis.com/justine/pledge/openbsd.png"/></a>

<p>
OpenBSD is an operating system that&#39;s famous for its focus on security.
Unfortunately, OpenBSD leader Theo states that there
are <a href="https://everything2.com/title/BSD+is+dying">only 7000
users</a> of OpenBSD. So it&#39;s a very small but elite group, that yields
a disproportionate influence; since we hear all the time about the
awesome security features these guys get to use, even though we usually
can&#39;t use them ourselves.

</p><p>
Pledge is like the forbidden fruit we all covet when the boss says we
must use things like Linux. Why does it matter? It&#39;s because pledge()
actually makes security comprehensible. Linux has never really had a
security layer that mere mortals can understand. For example, let&#39;s say
you want to do something on Linux like control whether or not some
program you downloaded from the web is allowed to have telemetry. You&#39;d
need to write stuff like this:

</p><pre><span>static const struct</span> <span>sock_filter</span> <span>kFilter</span>[] = {
    <span>/* L0*/</span> BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, syscall, 0, 14 - 1),
    <span>/* L1*/</span> BPF_STMT(BPF_LD | BPF_W | BPF_ABS, OFF(args[0])),
    <span>/* L2*/</span> BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, 2, 4 - 3, 0),
    <span>/* L3*/</span> BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, 10, 0, 13 - 4),
    <span>/* L4*/</span> BPF_STMT(BPF_LD | BPF_W | BPF_ABS, OFF(args[1])),
    <span>/* L5*/</span> BPF_STMT(BPF_ALU | BPF_AND | BPF_K, ~0x80800),
    <span>/* L6*/</span> BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, 1, 8 - 7, 0),
    <span>/* L7*/</span> BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, 2, 0, 13 - 8),
    <span>/* L8*/</span> BPF_STMT(BPF_LD | BPF_W | BPF_ABS, OFF(args[2])),
    <span>/* L9*/</span> BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, 0, 12 - 10, 0),
    <span>/*L10*/</span> BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, 6, 12 - 11, 0),
    <span>/*L11*/</span> BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, 17, 0, 13 - 11),
    <span>/*L12*/</span> BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),
    <span>/*L13*/</span> BPF_STMT(BPF_LD | BPF_W | BPF_ABS, OFF(nr)),
    <span>/*L14*/ /* next filter */</span>
};
</pre>

<p>
Oh my gosh. It&#39;s like we traded one form of security privilege for
another. OpenBSD limits security to a small pond, but makes it easy.
Linux is a big tent, but makes it impossibly hard. SECCOMP BPF might as
well be the Traditional Chinese of programming languages, since only a
small number of people who&#39;ve devoted the oodles of time it takes to
understand code like what you see above have actually been able to
benefit from it. But if you&#39;ve got OpenBSD privilege, then doing the
same thing becomes easy:

</p><pre>pledge(<span>&#34;stdio rpath&#34;</span>, 0);
</pre>

<p>
That&#39;s really all OpenBSD users have to do to prevent things like leaks
of confidential information. So how do we get it that simple on Linux? I
believe the answer is to find someone with enough free time to figure
out how to use SECCOMP BPF to implement pledge. The latest volunteer is
me, so look upon my code ye mighty and despair.

</p><ul>
  <li><a href="https://github.com/jart/cosmopolitan/blob/0a589add4167c1b5873eddd2904569e90bf4f27c/libc/mem/pledge.c#L1089">cosmopolitan/libc/mem/pledge.c</a></li><li><a href="https://github.com/jart/cosmopolitan/blob/0a589add4167c1b5873eddd2904569e90bf4f27c/tool/build/pledge.c">cosmopolitan/tool/build/pledge.c</a></li><li><a href="https://github.com/jart/cosmopolitan/blob/0a589add4167c1b5873eddd2904569e90bf4f27c/test/libc/mem/pledge_test.c">cosmopolitan/test/libc/mem/pledge_test.c</a></li></ul>

<p>
There&#39;s been a few devs in the past who&#39;ve tried this. I&#39;m not going to
name names, because most of these projects were never completed. When it
comes to SECCOMP, the online tutorials only explain how to whitelist the
system calls themselves, so most people lose interest before figuring
out how to filter arguments. The projects that got further along also
had oversights like allowing the changing of setuid/setgid/sticky bits.
So none of the current alternatives should be used. I believe this
effort gets us much closer to having pledge() than ever before.

</p><h2 class="page" id="download">
  <a href="#download">
    Command Line Utility
     
    <img src="http://storage.googleapis.com/justine/redbean/linux.png" title="Linux" alt="[Linux]" width="28" height="32"/>
  </a>
</h2>

<p>
I originally wrote my pledge() polyfill for
the <a href="https://redbean.dev/">redbean</a> web server as a
sandboxing solution. However it turns out pledge() is robust enough as
an abstraction that I thought it&#39;d be useful to create a small command
line utility which launches processes under pledge(), so that anyone can
use it, without having to configure it in C code.

</p><p>
  <a href="http://thewebivore.com/on-doing-nothing/pledge.com">pledge.com</a></p><p>
That binary will work on all Linux distros since RHEL6. Root privileges
are not required. You just use it to wrap your command invocations. It&#39;s
so tiny and lightweight that it only adds a few microseconds of startup
latency to your program. It&#39;s great for shell scripts and automated
tools. For example, if you want to run the list directory command, and
only permit that command to do basic stdio and filesystem path reading,
you&#39;d say:

</p><pre>$ wget https://justine.lol/pledge/pledge.com
$ chmod +x pledge.com
$ ./pledge.com -p <span>&#39;stdio rpath&#39;</span> ls
<em>file listing output...</em>
</pre>

<p>
You can now be certain your ls command isn&#39;t doing things like spying on
you, or uploading your bitcoin wallet to the cloud. However let&#39;s say
authorizing network access is what you want. One command that has a real
legitimate need for that is curl, which can be configured as follows:

</p><pre>$ ./pledge.com -p <span>&#39;stdio rpath inet thread&#39;</span> curl http://justine.lol/hello.txt
hello world
</pre>

<p>
Here&#39;s another example. Let&#39;s say you have a public ssh server and you
want to let people read and take notes of your book collection, but you
don&#39;t want anyone rewriting your books. In that case, you can repupose
something like the nano command as a strictly read-only editor. Since
nano has a TUI interface, you&#39;d need to grant it TTY privileges.

</p><pre>./pledge.com -np <span>&#39;stdio rpath tty&#39;</span> nano ~/books/bofh.txt
</pre>

<h3 class="page">
  Troubleshooting
</h3>

<p>
If your program crashes, then you can figure out why by tracing the
binary and seeing which system call is EPERM&#39;ing. Since the invocation
above used the default set of promises (thereby making <code>-p &#39;stdio
rpath&#39;</code> redundant) then let&#39;s see what happens if we reduce the
privileges to just stdio.

</p><pre>$ strace -ff ./pledge.com -p stdio ls
open(<span>&#34;/etc/ld-musl-x86_64.path&#34;</span>, O_RDONLY|O_CLOEXEC) = -1 EPERM (Operation not permitted)
</pre>

<p>
Well that didn&#39;t take long. Now that you know what&#39;s wrong, you would
then consult the <a href="#Promises">Promises</a> section to see which
promise you need. For example, you&#39;d know <code>open(O_RDONLY)</code> is
provided by <code>rpath</code> and that in order to <code>fork()</code>
you need <code>-p proc</code>.

</p><h3 class="page">
  Resource Limits
</h3>

<p>
In addition to polyfilling pledge, your pledge command is also able to
apply some other very important safety hacks that aren&#39;t obvious to the
uninitiated. For example, we&#39;ve all run a program before that hammers
the system. Linux is very generous in how much memory programs can
allocate. An accidental loop in just one program, by default on Linux,
will absolutely take the whole machine out of commission for a few
minutes before the &#34;OOM Killer&#34; kicks in. In other cases, like a fork()
bomb, the default Linux environment provides no such protection, so it&#39;s
essentially equivalent to a blue screen of death.

</p><p>
Your pledge command imposes some perfectly reasonable resource quotas on
programs by default, to prevent that from happening. By default, unless
you tune the flags, a program is allowed to use only 4gb of memory and,
if you&#39;ve permitted it to fork off new processes, then it won&#39;t be able
to spawn more of them at the same time than twice your number of CPUs.
That way your sandbox won&#39;t compromise the stability of your machine.

</p><p>
We also have a niceness feature. Have you ever had a program use so much
disk i/o that everything crawls to a halt? You run some program, and
then suddenly every small file takes seconds to load in Emacs? Your
pledge command can fix that. If you&#39;re got a compute heavy long running
program, then pass the <code>-n</code> flag for a <code>nice</code>
that&#39;s actually nice. The naive nice command doesn&#39;t really do much,
since it doesn&#39;t change the scheduler and it doesn&#39;t change the i/o
priority. This command actually does. Using the <code>-n</code> flag
will guarantee the sandbox program will stay out of the way, since the
kernel will only let it use spare capacity.

</p><h3 class="page">
  Pledge Command Flags
</h3>

<dl>
<dt>-n
</dt><dd>Apply maximum niceness to program. This means (1) nice is set to 19,
    (2) i/o priority is set to idle, and (3) scheduler is set to idle.
</dd><dt>-N
</dt><dd>Don&#39;t normalize file descriptors. by default, pledge.com guarantees
    (1) the stdio file descriptors exist, and (2) file descriptors that
    the parent process or shell forgot to close will be closed. In the
    latter case, we only poll up to fd=256 which is fast, but the number
    may be lower depending on system limits.
</dd><dt>-g GID
</dt><dd>Call setgid() before executing program (not allowed if setuid binary)
</dd><dt>-u UID
</dt><dd>Call setuid() before executing program (not allowed if setuid binary)
</dd><dt>-c PATH
</dt><dd>Call chroot() before executing program (needs root privileges)
</dd><dt>-C SECS
</dt><dd>set cpu limit in seconds [default: inherited]
</dd><dt>-M BYTES
</dt><dd>set virtual memory limit in bytes [default: 4gb]
</dd><dt>-P PROCS
</dt><dd>set process limit [default: GetCpuCount()*2]
</dd><dt>-F BYTES
</dt><dd>set individual file size limit [default: 4gb]
</dd><dt>-p PLEDGE
  </dt><dd>Defaults to <code>-p &#39;stdio rpath&#39;</code>. It&#39;s repeatable. May
  contain any of following separated by spaces:</dd></dl>

<h3 class="page">
  Securing APE Binaries
</h3>

<p>
Actually Portable Executables should be written to call pledge()
internally. But if you want to secure an APE binary that doesn&#39;t, using
the pledge.com command, then you need to convert (or &#34;assimilate&#34;) it
into the ELF format beforehand. You can usually do this by saying:

</p><pre>$ file redbean.com
redbean.com: DOS/MBR boot sector
$ ./redbean.com --assimilate
$ file redbean.com
redbean.com: ELF 64-bit LSB executable
</pre>

<p>
Please note that won&#39;t work if you&#39;re using the binfmt_misc with the new
<a href="https://justine.lol/apeloader/">APE Loader</a> then you can&#39;t
run the APE shell script to assimilate your binary. We instead provide a
new assimilate.com program which can be used to convert APE programs to
ELF or Mach-O.

</p><p>
  <a href="http://thewebivore.com/on-doing-nothing/assimilate.com">assimilate.com</a></p><h2 class="page" id="c">
  <a href="#c">
    C API
  </a>
</h2>

<p>
Pledge works best when developing software using
<a href="https://github.com/jart/cosmopolitan">Cosmpolitan Libc</a>. You
can get started relatively easily writing pledge() programs using the
cosmopolitan monorepo. The zero config solution is to just plop this
program file into the examples folder. Start by cloning the repo:

</p><pre>$ git clone https://github.com/jart/cosmopolitan
$ cd cosmopolitan
$ nano examples/mypledge.c
</pre>

<p>
You can then copy and paste this code:

</p><pre><span>#include</span> <span>&#34;libc/calls/calls.h&#34;</span>
<span>#include</span> <span>&#34;libc/stdio/stdio.h&#34;</span>

<span>int</span> main() {
  pledge(<span>&#34;stdio&#34;</span>, 0);
  printf(<span>&#34;hello world\n&#34;</span>);
}
</pre>

<p>
You can then build and run your program as follows:

</p><pre>$ make -j8 o//examples/mypledge.com
$ o//examples/mypledge.com
hello world
</pre>

<p>
One of the things you may have noticed about the pledge.com command, is
its most restrictive mode (<code>pledge.com -p &#34;&#34; cmd...</code>) can&#39;t
actually be used. Your program will just crash. That&#39;s because it&#39;s
intended for the C API. What it means is that your process or thread
won&#39;t be able to call any system call except exit. Such a program might
sound impossible, but you can actually communicate between processes
using shared memory. For example, here&#39;s how you&#39;d do it with threads.

</p><pre><span>int</span> enclave(<span>void</span> *arg, <span>int</span> tid) {
  if (pledge(&#34;&#34;, 0)) <span>return</span> 1;
  <span>int</span> *job = arg;            <span>// get job</span>
  job[0] = job[0] + job[1];  <span>// do work</span>
  <span>return</span> 0;                  <span>// exit</span>
}
<span>int</span> main() {
  <span>struct</span> <span>spawn</span> worker;
  <span>int</span> job[2] = {2, 2};            <span>// create workload</span>
  _spawn(enclave, job, &amp;worker);  <span>// create worker</span>
  _join(&amp;worker);                 <span>// wait for exit</span>
  assert(job[0] == 4);            <span>// check result</span>
}
</pre>

<p>
The above example shows an enclaved worker doing some kind of
computational task, possibly executing untrusted code, and then storing
the result to some memory location that the parent thread can see when
the worker has finished executing. It works great and is fast.

</p><p>
One of the disadvantages of the above example, is that the enclaved
worker has unfettered access to your stack memory and might make a mess
of things. That&#39;s potentially creepy and not very enclaved. One way to
fix that is to use fork() instead of threads. In that case, you can
explicitly whitelist which memory is shared.

</p><pre><span>int</span> ws;
<span>// create small shared memory region</span>
<span>int</span> *job = mmap(0, FRAMESIZE, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
job[0] = 2;  <span>// create workload</span>
job[1] = 2;
<span>if</span> (!fork()) {  <span>// create enclaved worker</span>
  <span>if</span> (pledge(&#34;&#34;, 0)) _Exit(1);
  job[0] = job[0] + job[1];  <span>// do work</span>
  _Exit(0);
}
wait(&amp;ws);  <span>// wait for worker</span>
assert(WIFEXITED(ws));
assert(WEXITSTATUS(ws) == 0);
assert(job[0] == 4);  <span>// check result</span>
munmap(job, FRAMESIZE);
</pre>

<p>
Most of our the Cosmopolitan Libc unit tests have been set up to use
pledge() these days. Not necessarily because we&#39;re concerned about them
being compromised, but because the pledge function has outstanding
documentation value in helping people understand our tests, since it
readily communicates what system functionality they need. For example,
our tests for the access() filesystem function says:

</p><pre><span>__attribute__</span>((<span>__constructor__</span>)) <span>static</span> <span>void</span> init(<span>void</span>) {
  pledge(<span>&#34;stdio rpath wpath cpath fattr&#34;</span>, 0);
  errno = 0;
}
</pre>

<h3 class="page" id="msyscall">
  <a href="#msyscall">
    System Call Origin Verification
  </a>
</h3>

<p>
When you write your own Actually Portable Executables, you also get some
added security benefits compared to pledge.com. For example, another
famous OpenBSD system call is msyscall() which causes the kernel to
validate the RIP register of anything that issues a system call. In
Cosmopolitan, calling pledge() will polyfill that feature too
automatically, to only allow functions which are annotated with
the <code>priviliged</code> keyword to use <code>SYSCALL</code>. What
that means is if someone manages to compromise your server to inject
executable code into your program&#39;s memory, then that code effectively
will have <code>pledge(&#34;&#34;, 0)</code> privileges, even if when your app
called pledge(), it specified something much broader. The redbean web
server&#39;s <a href="https://redbean.dev/#unix.pledge">unix.pledge</a>()
function is also able to take advantage of this.

</p><h2 class="page" id="caveats">
  <a href="#caveats">
    Caveats
  </a>
</h2>

<p>
File system access is a blind spot. OpenBSD solves this with another
famous system call called unveil(), which lets users control file system
paths too. Right now there&#39;s no clear way to implement that for Linux.
However our pledge() polyfill does do a reasonable job in restricting
which file system operations are possible. But once you permit the file
system ops, the ops are allowed to happen on pretty much any file the
user has access to.

</p><p>
I personally don&#39;t view this as a problem. What I love about pledge.com
is it tells me if the programs I run that I downloaded from random
strangers on the Internet, are actually the good little command line
citizens that they claim to be. For example, if I download a tool for
computing some math, or compressing a file, then it really shouldn&#39;t
need any access except <code>-p &#34;stdio rpath&#34;</code> especially if I&#39;m
able to use pipes. So I can use pledge.com to make sure the command
keeps its promise and lets me know if there&#39;s any surprising behaviors.
So this is great security if you&#39;re dealing with command line programs
that are written in a conscientious manner. If it&#39;s only able to read
files and can&#39;t talk to the Internet, then seriously, what could it
possible do? It&#39;s such a simple pareto-optimized niche that I can&#39;t
believe no one&#39;s made it easily addressable until now.

</p><p>
However, there&#39;s always going to be that one program you want that&#39;s
power hungry, possibly due to bloated frameworks and dependencies. In
that case, we may want access to <em>some</em> (but not all) of the file
system. pledge.com is able to address the need somewhat using chroot().
It&#39;s worth noting though that chroot() has weaknesses that kernel devs
have refused to fix for decades. Most of the docs on this subject are
unprofessional and crazy. For example, the chroot(2) man page is
probably the only category 2 man page I&#39;ve ever seen that uses shell
script code to describe its functionality. As far as I can tell, the
only convincing weakness with chroot() is that the jail is only locked
from the inside. If you take away the freedom of a process by putting it
in a chroot jail, then another process that&#39;s free can use its freedom
to bust its friend out of jail. For example, here&#39;s how root can leave a
backdoor that lets the process escape:

</p><pre>mkdir(<span>&#34;/tmp/mydir&#34;</span>, 0755);
<span>// privileged user opens a backdoor</span>
<span>int</span> dirfd = open(<span>&#34;/tmp&#34;</span>, O_RDONLY | O_DIRECTORY);
<span>// process enters chroot jail</span>
chdir(<span>&#34;/tmp/mydir&#34;</span>);
chroot(<span>&#34;/tmp/mydir&#34;</span>);
<span>// process escapes jail</span>
fchdir(dirfd);
chdir(<span>&#34;..&#34;</span>);
<span>// list root directory</span>
<span>struct</span> <span>dirent</span> *e;
<span>DIR</span> *d = opendir(&#34;.&#34;);
<span>while</span> ((e = readdir(d))) {
  printf(&#34;%s\n&#34;, e-&gt;d_name);
}
closedir(d);
</pre>

<p>
The Linux devs could fix that if they wanted to. However I personally
don&#39;t see why it&#39;s a total dealbreaker, pledge.com helps avoid it by
closing rogue file descriptors at startup using poll(). What even more
surprising is that this weakness is also exploitable on OpenBSD, since
they too seem to have given up on securing the traditional chroot()
call. But at least OpenBSD provides an alternative that&#39;s easy to use,
called unveil(). It&#39;d be great to see that leadership from the Linux
kernel, but instead we just see blog posts from companies like RedHat
saying that having chroot() will make us more insecure than having no
security at all. It&#39;s like banning locks because lockpick kits exist.
RedHat must be experts at mental gymnastics to publish such communiqués.
It&#39;s also comical that Linux addresses the problem by restricting
chroot() to the root user account, since clearly something which is so
&#34;insecure&#34; will become more secure if you only do it from the most
privileged user. What an unfortunate state of affairs, since many of us
have needed to look elsewhere for answers, and the only folks offering
those right now is bloatware like Docker that locks-in your filesystem
with a bunch of cryptically named tar files. And they say that Docker
isn&#39;t a security layer too! Even though it&#39;s based things like cgroups
which are even more elite and difficult to understand than SECCOMP BPF.
We can only guess why the kernel devs do it. Maybe they&#39;re afraid of
issue workload burnout and figure people won&#39;t complain about security
if no one understands it! That&#39;s something we&#39;re working to change.

</p><p>
It should also be noted that there&#39;s some features OpenBSD bakes into
pledge() that we&#39;re not able to polyfill with Linux SECCOMP BPF. One of
the things OpenBSD does is it can check file system paths, in order to
loosen up restrictions around things like accessing the time zone
database. This isn&#39;t a problem if you&#39;re a Cosmopolitan Libc user.
Because APE binaries don&#39;t read tzdata from the filesystem and instead
embed time zone data inside the ZIP structure of the binary. However it
could potentially be problematic if you&#39;re using pledge.com to launch
binaries that are provided by your distro. Ask your friendly distro
maintainers to improve their security solutions. If they can&#39;t, then you
can always switch to Cosmopolitan Libc.

</p><p>
Another caveat is that, so far, I&#39;ve only implemented the things
described in the OpenBSD pledge(2) manual page. We still need to
reconcile this properly with the primary materials which would be the
OpenBSD pledge() kernel source code. We also need more community
feedback to make sure there aren&#39;t things we haven&#39;t considered. For
example, Linux has a lot of sneaky capabilities in a shifting landscape
that aren&#39;t always widely understood, which can potentially bite the
authors of security tools, even when they&#39;ve done due diligence.

</p><p>
I&#39;ve also only really tested this on console applications. If you want a
pledge() that&#39;s likely to work with GUIs, then, knowing the way the
Linux desktop goes, you really should consider
<a href="https://awesomekling.github.io/pledge-and-unveil-in-SerenityOS/">SerenityOS</a>
since Andreas added pledge() support a couple years ago.

</p><h2 class="page" id="docs">
  <a href="#docs">
    Pledge Documentation
  </a>
</h2>

<p>
Pledging causes most system calls to become unavailable. Your system
call policy is enforced by the kernel, which means it can propagate
across execve() if permitted. This system call is supported on
OpenBSD and Linux where it&#39;s polyfilled using SECCOMP BPF. The way it
works on Linux is verboten system calls will raise EPERM whereas
OpenBSD just kills the process while logging a helpful message to
/var/log/messages explaining which promise category you needed.

</p><p>
By default exit and exit_group are always allowed. This is useful
for processes that perform pure computation and interface with the
parent via shared memory.

</p><p>
Once pledge is in effect, the chmod functions (if allowed) will not
permit the sticky/setuid/setgid bits to change. Linux will EPERM here
and OpenBSD should ignore those three bits rather than crashing.

</p><p>
User and group IDs can&#39;t be changed once pledge is in effect. OpenBSD
should ignore chown without crashing; whereas Linux will just EPERM.

</p><p>
Memory functions won&#39;t permit creating executable code after pledge.
Restrictions on origin of SYSCALL instructions will become enforced
on Linux (cf. msyscall) after pledge too, which means the process
gets killed if SYSCALL is used outside the .privileged section. One
exception is if the &#34;exec&#34; group is specified, in which case these
restrictions need to be loosened.

</p><p>
Using pledge is irreversible. On Linux it causes PR_SET_NO_NEW_PRIVS
to be set on your process; however, if &#34;id&#34; or &#34;recvfd&#34; are allowed
then then they theoretically could permit the gaining of some new
privileges. You may call pledge() multiple times if &#34;stdio&#34; is
allowed. In that case, the process can only move towards a more
restrictive state.

</p><p>
pledge() can&#39;t filter file system paths or internet addresses. For
example, if you enable a category like &#34;inet&#34; then your process will
be able to talk to any internet address. The same applies to
categories like &#34;wpath&#34; and &#34;cpath&#34;; if enabled, any path the
effective user id is permitted to change will be changeable.

</p><p>
The Linux pledge() polyfill isn&#39;t able to support the OpenBSD
`execpromises` parameter.

</p><h3 class="page" id="promises">
  <a href="#promises">
    Promises
  </a>
</h3>

<p>
  Your promises is a string that may include any of the following groups
  delimited by spaces.

</p><dl>
<dt>stdio
</dt><dd>allows close, dup, dup2, dup3, fchdir, fstat, fsync,
fdatasync, ftruncate, getdents, getegid, getrandom, geteuid,
getgid, getgroups, getitimer, getpgid, getpgrp, getpid, getppid,
getresgid, getresuid, getrlimit, getsid, wait4, gettimeofday,
getuid, lseek, madvise, brk, arch_prctl, uname, set_tid_address,
clock_getres, clock_gettime, clock_nanosleep, mmap (PROT_EXEC and
weird flags aren&#39;t allowed), mprotect (PROT_EXEC isn&#39;t allowed),
msync, munmap, nanosleep, pipe, pipe2, read, readv, pread, recv,
poll, recvfrom, preadv, write, writev, pwrite, pwritev, select,
send, sendto (only if addr is null), setitimer, shutdown, sigaction
(but SIGSYS is forbidden), sigaltstack, sigprocmask, sigreturn,
sigsuspend, umask, socketpair, ioctl(FIONREAD), ioctl(FIONBIO),
ioctl(FIOCLEX), ioctl(FIONCLEX), fcntl(F_GETFD), fcntl(F_SETFD),
fcntl(F_GETFL), fcntl(F_SETFL).

</dd><dt>rpath
</dt><dd>(read-only path ops) allows chdir, getcwd, open(O_RDONLY),
openat(O_RDONLY), stat, fstat, lstat, fstatat, access, faccessat,
readlink, readlinkat, statfs, fstatfs.

</dd><dt>wpath
</dt><dd>(write path ops) allows getcwd, open(O_WRONLY),
openat(O_WRONLY), stat, fstat, lstat, fstatat, access, faccessat,
readlink, readlinkat, chmod, fchmod, fchmodat.

</dd><dt>cpath
</dt><dd>(create path ops) allows open(O_CREAT), openat(O_CREAT),
rename, renameat, renameat2, link, linkat, symlink, symlinkat,
unlink, rmdir, unlinkat, mkdir, mkdirat.

</dd><dt>dpath
</dt><dd>(create special path ops) allows mknod, mknodat, mkfifo.

</dd><dt>flock
</dt><dd>allows flock, fcntl(F_GETLK), fcntl(F_SETLK),
fcntl(F_SETLKW).

</dd><dt>tty
</dt><dd>allows ioctl(TIOCGWINSZ), ioctl(TCGETS), ioctl(TCSETS),
ioctl(TCSETSW), ioctl(TCSETSF).

</dd><dt>recvfd
</dt><dd>allows recvmsg(SCM_RIGHTS).

</dd><dt>fattr
</dt><dd>allows chmod, fchmod, fchmodat, utime, utimes, futimens,
utimensat.

</dd><dt>inet
</dt><dd>allows socket(AF_INET), listen, bind, connect, accept,
accept4, getpeername, getsockname, setsockopt, getsockopt, sendto.

</dd><dt>unix
</dt><dd>allows socket(AF_UNIX), listen, bind, connect, accept,
accept4, getpeername, getsockname, setsockopt, getsockopt.

</dd><dt>dns
</dt><dd>allows socket(AF_INET), sendto, recvfrom, connect.

</dd><dt>proc
</dt><dd>allows fork, vfork, kill, getpriority, setpriority, prlimit,
setrlimit, setpgid, setsid.

</dd><dt>thread
</dt><dd>allows clone, futex, and permits PROT_EXEC in mprotect.

</dd><dt>id
</dt><dd>allows setuid, setreuid, setresuid, setgid, setregid,
setresgid, setgroups, prlimit, setrlimit, getpriority, setpriority,
setfsuid, setfsgid.

</dd><dt>exec
</dt><dd>allows execve, execveat, access, faccessat. On Linux this
also weakens some security to permit running APE binaries. However
on OpenBSD they must be assimilate beforehand. On Linux, mmap()
will be loosened up to allow creating PROT_EXEC memory (for APE
loader) and system call origin verification won&#39;t be activated.

</dd><dt>execnative
</dt><dd>allows execve, execveat. Can only be used to run
native executables; you won&#39;t be able to run APE binaries. mmap()
and mprotect() are still prevented from creating executable memory.
System call origin verification can&#39;t be enabled. If you always
assimilate your APE binaries, then this should be preferred.
</dd></dl>


<h2 class="page" id="funding">
  <a href="#funding">
    Funding
  </a>
</h2>

<p>
  <a href="http://justine.lol/lemuria.png">
    <picture>
      <source srcset="//storage.googleapis.com/justine/sectorlisp2/lemuria.webp" type="image/webp"/>
      <img src="http://storage.googleapis.com/justine/sectorlisp2/lemuria.png" width="850" height="360" alt="[United States of Lemuria - two dollar bill - all debts public and primate]"/>
    </picture>
  </a>

</p><p>
Funding for the development of pledge() on Linux was crowdsourced from
Justine Tunney&#39;s <a href="https://github.com/sponsors/jart">GitHub
sponsors</a> and <a href="https://www.patreon.com/jart">Patreon
subscribers</a>. Your support is what makes projects like Cosmopolitan
Libc possible. Thank you.

</p>
</div>
  </body>
</html>
