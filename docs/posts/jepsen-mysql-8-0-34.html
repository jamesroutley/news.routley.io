<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jepsen.io/analyses/mysql-8.0.34">Original</a>
    <h1>Jepsen: MySQL 8.0.34</h1>
    
    <div id="readability-page-1" class="page"><p><a href="https://www.mysql.com/">MySQL</a> is a popular relational database. We revisit Kleppmann’s 2014 <a href="https://github.com/ept/hermitage/blob/master/mysql.md">Hermitage</a> and confirm that MySQL’s Repeatable Read still allows G2-item, G-single, and lost update. Using our transaction consistency checker <a href="https://github.com/jepsen-io/elle">Elle</a>, we show that MySQL Repeatable Read also violates internal consistency. Furthermore, it violates Monotonic Atomic View: transactions can observe some of another transaction’s effects, then later fail to observe other effects of that same transaction. We demonstrate violations of ANSI SQL’s requirements for Repeatable Read. We believe MySQL Repeatable Read is somewhat stronger than Read Committed. As a lagniappe, we show that AWS RDS MySQL clusters routinely violate Serializability. This work was performed independently without compensation, and conducted in accordance with the <a href="https://jepsen.io/ethics">Jepsen ethics policy</a>.</p><article>
  <div>

<p><a href="https://www.mysql.com/">MySQL</a> needs little introduction. Over the last 28 years it has become one of the most widely deployed SQL databases. MySQL is primarily used for online transaction processing (OLTP) workloads, but is also deployed as a part of OLAP and queuing systems.</p>
<p>MySQL was designed as a single-server database, but has been extended with various multi-node replication schemes, including <a href="https://www.percona.com/blog/overview-of-different-mysql-replication-solutions/">several flavors</a> of <a href="https://dev.mysql.com/doc/refman/8.0/en/binlog-replication-configuration-overview.html">binlog replication</a>, <a href="https://dev.mysql.com/blog-archive/mysql-group-replication-a-quick-start-guide/">group replication</a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/mysql-cluster.html">NDB cluster</a>, and third-party plugins like <a href="https://galeracluster.com/">Galera Cluster</a> &amp; <a href="https://www.percona.com/software/mysql-database/percona-xtradb-cluster">Percona XtraDB Cluster</a>. Previous Jepsen work discussed <a href="https://aphyr.com/posts/328-call-me-maybe-percona-xtradb-cluster">Percona XtraDB Cluster</a> and <a href="https://aphyr.com/posts/327-jepsen-mariadb-galera-cluster">Galera Cluster</a>. In this analysis we focus on single-server MySQL, but we also evaluated clusters with a single writeable primary and read-only secondaries using <a href="https://dev.mysql.com/doc/refman/8.0/en/replication-howto.html">binlog replication</a>.</p>
<p>MySQL also supports multiple storage engines which have different safety properties. We focus on the default: <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-introduction.html">InnoDB</a>. Throughout this text, we use “MySQL” to mean “MySQL using the InnoDB storage engine.”</p>
<h2 data-number="1.1" id="ansi-sql-isolation-is-bad-actually"> ANSI SQL Isolation is Bad, Actually</h2>
<p>In order to discuss the nuances of SQL isolation levels, we must first explain some history. In 1977 Gray, Lorie, Putzolu, and Traiger published <a href="https://www.cs.cmu.edu/~natassa/courses/15-721/papers/GrayLocks.pdf">Granularity of Locks and Degrees of Consistency in a Shared Data Base</a>, which introduced four increasingly safe degrees of transaction consistency. In 1973 IBM developed System R, one of the first relational databases, and shortly thereafter <a href="https://learnsql.com/blog/history-of-sql/">introduced SQL</a> as a query language for it. System R’s success spawned a slew of relational databases using SQL, many with distinct flavors of concurrency control. Starting in <a href="https://archive.org/details/federalinformati127nati">1986</a> ANSI <a href="https://blog.ansi.org/sql-standard-iso-iec-9075-2023-ansi-x3-135/">released</a><a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a> a <a href="https://learnsql.com/blog/history-of-sql-standards/">series of standards</a> codifying SQL behavior. The third revision of the standard, SQL-92, defined the semantics of concurrent transactions through four transaction isolation levels, again with increasing degrees of safety. As with Gray et al., these isolation levels were related to the behavior of increasingly conservative locking regimes. However, to allow databases which used non-locking concurrency control, ANSI phrased their levels in terms of three possible phenomena which should not occur. As the standard puts it, “the following phenomena are possible:”<a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<dl>
<dt>P1 (“Dirty Read”)</dt>
<dd>SQL-transaction T1 modifies a row. SQL-transaction T2 then reads that row before T1 performs a COMMIT. If T1 then performs a ROLLBACK, T2 will have read a row that was never committed and that may thus be considered to have never existed.
</dd>
<dt>P2 (“Non-Repeatable Read”)</dt>
<dd>SQL-transaction T1 reads a row. SQL-transaction T2 then modifies or deletes that row and performs a COMMIT. If T1 then attempts to reread the row, it may receive the modified value or discover that the row has been deleted.
</dd>
<dt>P3 (“Phantom”)</dt>
<dd>SQL-transaction T1 reads the set of rows N that satisfy some &lt;search condition&gt;. SQL-transaction T2 then executes SQL-statements that generate one or more rows that satisfy the &lt;search condition&gt; used by SQL-transaction T1. If SQL-transaction T1 then repeats the initial read with the same &lt;search condition&gt;, it obtains a different collection of rows.
</dd>
</dl>
<p>ANSI SQL defines four isolation levels in terms of these anomalies. It begins by stating that transactions which execute at the Serializable isolation level must be equivalent to some serial execution, i.e., one in which that set of transactions executed one after the other. Then it says “the isolation levels are different with respect to phenomena P1, P2, and P3.” The standard provides the following table which “specifies the phenomena that are possible and not possible for a given isolation level”:</p>
<table>
<thead>
<tr>
<th>Level</th>
<th>P1</th>
<th>P2</th>
<th>P3</th>
</tr>
</thead>
<tbody>
<tr>
<td>Read Uncommitted</td>
<td>Possible</td>
<td>Possible</td>
<td>Possible</td>
</tr>
<tr>
<td>Read Committed</td>
<td>Not Possible</td>
<td>Possible</td>
<td>Possible</td>
</tr>
<tr>
<td>Repeatable Read</td>
<td>Not Possible</td>
<td>Not Possible</td>
<td>Possible</td>
</tr>
<tr>
<td>Serializable</td>
<td>Not Possible</td>
<td>Not Possible</td>
<td>Not Possible</td>
</tr>
</tbody>
</table>
<p>In 1995 Berenson, Bernstein, Gray,<a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a> Melton, and the O’Neils published <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf">A Critique of ANSI SQL Isolation Levels</a>, which laid out critical flaws in these definitions. “The three ANSI phenomena are ambiguous. Even their broadest interpretations do not exclude anomalous behavior.”</p>
<p>For example, P1 says something bad might happen if <span><em>T</em><sub>1</sub></span> were to abort, but doesn’t actually say whether it aborts or not. Some people interpreted the standard to require <span><em>T</em><sub>1</sub></span> aborts. This would make it legal under read committed for transactions to read as-yet-uncommitted state from other transactions (so long as they went on to commit). <span><em>T</em><sub>1</sub></span> could write <span><em>x</em> = 1</span>, <span><em>T</em><sub>2</sub></span> could write <span><em>y</em> = 2</span>, and <span><em>T</em><sub>1</sub></span> and <span><em>T</em><sub>2</sub></span> could both see each other’s effects. This kind of circular information flow seems bad, but whether the standard allows it is a matter of interpretation. Similar ambiguities exist for P2 and P3.</p>
<p>Even interpreted broadly, preventing P1, P2, and P3 does not ensure Serializability. The standard omits a critical phenomenon P0 (“dirty write”), in which transaction <span><em>T</em><sub>1</sub></span> writes some row, transaction <span><em>T</em><sub>2</sub></span> overwrites <span><em>T</em><sub>1</sub></span>’s write, and <span><em>T</em><sub>1</sub></span> commits. This is clearly undesirable, but legal under ANSI Read Uncommitted, Read Committed, and Repeatable Read. Furthermore, ANSI SQL P3 only prohibits inserts affecting a predicate, but not updates or deletes.</p>
<p>In 1999, <a href="https://pmg.csail.mit.edu/papers/adya-phd.pdf">Atul Adya built on Berenson et al.’s critique</a> and developed formal and implementation-independent definitions of various transaction isolation levels, including those in ANSI SQL.<a href="#fn4" id="fnref4" role="doc-noteref"><sup>4</sup></a> As he notes:</p>
<blockquote>
<p>The ANSI definitions are imprecise because they allow at least two interpretations; furthermore, the anomaly interpretation is definitely incorrect. The preventative interpretation [meaning Berenson et al.’s interpretation which added P0, expanded P3, and so on] is correct in the sense that it rules out undesirable (i.e., non-serializable) histories. However, this interpretation is overly restrictive since it also rules out correct behavior that does not lead to inconsistencies and can occur in a real system. Thus, any system that allows such histories is disallowed by this interpretation, e.g., databases based on optimistic mechanisms.</p>
</blockquote>
<p>Adya first defines a dependency graph between transactions. There are three main types of dependencies, which we summarize informally:</p>
<dl>
<dt>Write-Write</dt>
<dd>Transaction <span><em>T</em><sub>1</sub></span> writes some version <span><em>x</em><sub>1</sub></span> of object <span><em>x</em></span>, which transaction <span><em>T</em><sub>2</sub></span> overwrites by installing the next version of <span><em>x</em></span>: <span><em>x</em><sub>2</sub></span>.
</dd>
<dt>Write-Read</dt>
<dd>Transaction <span><em>T</em><sub>1</sub></span> writes version <span><em>x</em><sub>1</sub></span>, which transaction <span><em>T</em><sub>2</sub></span> reads.
</dd>
<dt>Read-Write</dt>
<dd>Transaction <span><em>T</em><sub>1</sub></span> reads version <span><em>x</em><sub>1</sub></span>, which transaction <span><em>T</em><sub>2</sub></span> overwrites by installing the next version of <span><em>x</em></span>: <span><em>x</em><sub>2</sub></span>.
</dd>
</dl>
<p>Adya then defines portable isolation levels PL-1, PL-2, PL-2.99, and PL-3, which capture what the ANSI SQL standard (arguably) intended. Each level rules out progressively broader kinds of cycles in the transaction dependency graph:</p>
<dl>
<dt>PL-1 (“Read Uncommitted”)</dt>
<dd>Prohibits G0 (“write cycle”): a cycle of write-write dependencies. This is analogous to Berenson’s P0 (“dirty write”).
</dd>
<dt>PL-2 (“Read Committed”)</dt>
<dd>Prohibits G0 and G1. G1 consists of three anomalies: G1a (“aborted read”), G1b (“intermediate read”)<a href="#fn5" id="fnref5" role="doc-noteref"><sup>5</sup></a>, and G1c (“cyclic information flow”): a cycle of write-write or write-read dependencies. This captures the essence of the preventative interpretation of P1.
</dd>
<dt>PL-2.99 (“Repeatable Read”)</dt>
<dd>Prohibits G0, G1, and G2-item: a cycle involving write-write, write-read, or read-write edges <em>without predicates</em>. This captures the essence of ANSI SQL Repeatable Read, which is distinguished from Serializable only by predicate safety.
</dd>
<dt>PL-3 (“Serializable”)</dt>
<dd>Prohibits G0, G1, and G2: a cycle involving write-write, write-read, or read-write edges (with or without predicates). This guarantees equivalence to a serial execution.
</dd>
</dl>
<p>Adya’s dependency graph-based isolation levels resolved the ambiguities of the ANSI definitions, and remains the most widely-used formalism for characterizing transaction histories and anomalies. Jepsen generally uses Adya’s formalism.</p>
<p>Although the database community has known for decades that ANSI SQL’s isolation level definitions are broken, the standard’s language remained unchanged. The same ambiguous, incomplete definitions are still present in the <a href="https://webstore.ansi.org/standards/iso/isoiec90752023-2502169">2023 revision of the standard</a>.</p>
<h2 data-number="1.2" id="repeatable-read"> Repeatable Read</h2>
<p>ANSI SQL’s isolation levels are bad, but some levels have caused more problems than others.  The fact that different database vendors provide isolation levels with the same names is useful only if the semantics of a particular level are consistent across vendors. And for three of the isolation levels, this is usually true. Most databases we’ve evaluated do ensure at least PL-1 for read uncommitted, PL-2 for Read Committed, and PL-3 for Serializable.<a href="#fn6" id="fnref6" role="doc-noteref"><sup>6</sup></a> However, there is less agreement on the semantics of Repeatable Read.</p>
<p>Adya’s PL-2.99 definition of Repeatable Read is quite strict, ruling out all dependency cycles except those involving predicate edges. The ANSI definition, while ambiguous, appears similarly strict: it prohibits all listed anomalies except “phantoms,” which depend on predicate reads. This is not surprising when we consider the roots of the isolation levels in locking regimes: the original Repeatable Read was the isolation level you got when you followed strict two-phase locking (holding read and write locks until the end of the transaction) but did not enforce predicate locking.</p>
<p>For some reason DB vendors have chosen different definitions of Repeatable Read than Adya and the ANSI standard, and almost no vendors provide the same guarantees at Repeatable Read. In fact, Microsoft SQL Server is the only database that we have tested for which Repeatable Read appears to correspond to PL-2.99 and the ANSI definition. In Postgres, <a href="https://jepsen.io/analyses/postgresql-12.3">Repeatable Read means Snapshot Isolation</a>, a level that is neither stronger nor weaker than PL-2.99.<a href="#fn7" id="fnref7" role="doc-noteref"><sup>7</sup></a></p>
<p>With this diversity of implementations in mind, we turn to the question at hand: what does MySQL do?</p>
<h2 data-number="1.3" id="mysql-isolation"> MySQL Isolation</h2>
<p>The <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html">transaction isolation levels</a> documentation for MySQL indicates that MySQL with InnoDB “offers all four transaction isolation levels described by the SQL:1992 standard”: <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_read-uncommitted">Read Uncommitted</a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_read-committed">Read Committed</a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_repeatable-read">Repeatable Read</a>, and <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_serializable">Serializable</a>. The documentation goes on to explain how MySQL achieves these isolation levels.</p>
<p>At MySQL Read Uncommitted, transactions should behave “like <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_read-uncommitted">Read Committed</a>,” except for allowing <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_dirty_read">dirty read</a>: an anomaly where a read observes “data that was updated by another transaction but not yet committed.”</p>
<p>At MySQL <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_read-committed">Read Committed</a>, every individual <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-consistent-read.html">consistent read</a> reads from a fresh snapshot of committed state. A “consistent read” is the default behavior for reads (e.g. <code>SELECT * FROM problems</code>) and is the focus of this report. <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking-reads.html">There are also</a> stronger reads (e.g. <code>SELECT ... FOR UPDATE</code>) which explicitly request locks, and weaker reads (e.g. <code>SELECT ... SKIP LOCKED</code>) which skip some of the default locks.</p>
<p>MySQL <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_repeatable-read">Repeatable Read</a>, the default isolation level, ensures safety through a snapshot mechanism:</p>
<blockquote>
<p>Consistent reads within the same transaction read the snapshot established by the first read. This means that if you issue several plain (nonlocking) <code>SELECT</code> statements within the same transaction, these <code>SELECT</code> statements are consistent also with respect to each other.</p>
</blockquote>
<p>MySQL’s <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-consistent-read.html">consistent read documentation</a> further emphasizes that reads should operate on a snapshot of the database taken by the first read in a transaction.</p>
<blockquote>
<p>If the transaction isolation level is <code>REPEATABLE READ</code> (the default level), all consistent reads within the same transaction read the snapshot established by the first such read in that transaction….</p>
<p>Suppose that you are running in the default <code>REPEATABLE READ</code> isolation level. When you issue a consistent read (that is, an ordinary <code>SELECT</code> statement), InnoDB gives your transaction a timepoint according to which your query sees the database. If another transaction deletes a row and commits after your timepoint was assigned, you do not see the row as having been deleted. Inserts and updates are treated similarly.</p>
</blockquote>
<p>The documentation for <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_serializable">Serializable</a> isolation says Serializable is “like <code>REPEATABLE READ</code>, but <code>InnoDB</code> implicitly converts all plain <code>SELECT</code> statements to <code>SELECT ... FOR SHARE</code> if <code>autocommit</code> is disabled.”</p>
<p>There ends the isolation level documentation. However, if one digs deeper into the <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-consistent-read.html">consistent read documentation</a>, there is a curious note on the semantics of Repeatable Read:</p>
<blockquote>
<p>The snapshot of the database state applies to <code>SELECT</code> statements within a transaction, not necessarily to DML statements. If you insert or modify some rows and then commit that transaction, a <code>DELETE</code> or <code>UPDATE</code> statement issued from another concurrent <code>REPEATABLE READ</code> transaction could affect those just-committed rows, even though the session could not query them. If a transaction does update or delete rows committed by a different transaction, those changes do become visible to the current transaction.</p>
</blockquote>
<p>This is confusing: the ANSI SQL standard and MySQL’s <a href="https://dev.mysql.com/doc/refman/8.0/en/sql-data-manipulation-statements.html">own reference manual</a> both consider <code>SELECT</code> to be a DML statement, but this note seems to think they’re different. It appears that writes made by a Repeatable Read transaction can affect rows that the transaction could not read. But what does it mean for a different transaction’s updates to become visible to the current transaction? How does that align with MySQL’s claim that multiple reads in a Repeatable Read transaction “read the snapshot established by the first read”? What happened to the timepoint assigned by the first read?</p>
<p>This calls for a test.</p>

<p>We designed a <a href="https://github.com/jepsen-io/mysql">small test suite for MySQL</a> using the <a href="https://github.com/jepsen-io/jepsen">Jepsen testing library</a> at version 0.3.4. We used the <code>mysql-connector-j</code> JDBC adapter as our client. We tested MySQL 8.0.34, and <a href="https://mariadb.org/">MariaDB</a> 10.11.3 on Debian Bookworm. Our tests ran against a single MySQL node as well as binlog-replicated clusters with one or two read-only followers, without failover. We also ran our test suite against a hosted MySQL service: AWS’s <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/multi-az-db-clusters-concepts.html">RDS Cluster</a>, using the “Multi-AZ DB Cluster” profile. This is the recommended default for production workloads, and offers a binlog-replicated deployment of MySQL 8.0.34 where secondary nodes support read queries.</p>
<p>Our tests included basic fault injection for process pauses, crashes, and network partitions, as well as the loss of un-fsynced writes to disk. However, almost every finding we discuss in this work occurred in healthy, single-node MySQL instances.</p>
<h2 data-number="2.1" id="list-append"> List Append</h2>
<p>Our main workload used <a href="https://github.com/jepsen-io/elle">Elle</a>’s list-append checker for transactional isolation. In a nutshell, Elle infers Adya’s write-write, write-read, and read-write dependencies between transactions, then looks for cycles in the resulting dependency graph. Each cycle it finds demonstrates that a particular set of isolation levels do not hold.</p>
<p>At a high level the <a href="https://github.com/jepsen-io/mysql/blob/4c239cb5c66a7f1a55fa02ce4c9f43b7a70e9d0b/src/jepsen/mysql/append.clj">append workload</a> performs randomly generated transactions comprising reads and appends of unique integer elements to a collection of lists identified by primary key. As in <a href="https://jepsen.io/analyses/postgresql-12.3">our previous tests of SQL databases</a>, we encoded these lists as a <code>text</code> field of comma-separated values, one per row, and used SQL <code>CONCAT</code> to append elements.<a href="#fn8" id="fnref8" role="doc-noteref"><sup>8</sup></a> We split these rows across multiple tables with a structure like</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span>create</span> <span>table</span> <span>&#34;txn0&#34;</span> (</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>  <span>id</span> <span>int</span> <span>not</span> <span>null</span> <span>primary</span> <span>key</span>,</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  val text</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>);</span></code></pre></div>
<p>Over the last few years we’ve made several improvements to Elle which allow it to detect more anomalies.<a href="#fn9" id="fnref9" role="doc-noteref"><sup>9</sup></a> When some appended elements are never read in a list-append test, Elle now <a href="https://github.com/jepsen-io/elle/commit/bccbc1ed6bc175453b40d514bdf873e554494633">infers ww and rw dependencies</a>, placing them after the last value seen in the longest successful read. <a href="https://github.com/jepsen-io/elle/commit/9da9f48d4bf1ab998533d9d6f5c0de4b732365ce">We now detect P4 (lost update)</a> anomalies explicitly, even when version orders are uninferable. Elle also searches for <a href="https://github.com/jepsen-io/elle/commit/3abdb6a56b6c816199796d8c635125f7ecd197cd">cycles involving multiple nonadjacent read-write anti-dependencies which also include real-time and process edges</a>. This lets us detect more subtle violations of both strong and strong session Snapshot Isolation.</p>
<h2 data-number="2.2" id="non-repeatable-read"> Non-Repeatable Read</h2>
<p>When Elle identified internal consistency violations at Repeatable Read, we designed a <a href="https://github.com/jepsen-io/mysql/blob/4c239cb5c66a7f1a55fa02ce4c9f43b7a70e9d0b/src/jepsen/mysql/nonrepeatable_read.clj">workload specifically to stress</a> MySQL’s Repeatable Read semantics, which works as follows. We create a simple table of people identified by primary key, and populate it with a single row:</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span>create</span> <span>table</span> people (</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  <span>id</span>     <span>int</span> <span>not</span> <span>null</span>,</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>  name   text <span>not</span> <span>null</span>,</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>  gender text <span>not</span> <span>null</span>,</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>  <span>primary</span> <span>key</span> (<span>id</span>))</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>);</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a><span>insert</span> <span>into</span> people (<span>id</span>, name, gender)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>  <span>values</span> (<span>0</span>, <span>&#34;moss&#34;</span>, <span>&#34;enby&#34;</span>);</span></code></pre></div>
<p>We then perform a series of write transactions which update only the row’s name. Concurrently, a second series of transactions each read the row’s name, update its gender field, and read the name again. Violations of Repeatable Read manifest as the row’s name changing between the two reads. We also perform deletions and re-insertions of row 0, in case they behave differently than plain updates.</p>
<h2 data-number="2.3" id="monotonic-atomic-view"> Monotonic Atomic View</h2>
<p>We also designed a <a href="https://github.com/jepsen-io/mysql/blob/4c239cb5c66a7f1a55fa02ce4c9f43b7a70e9d0b/src/jepsen/mysql/mav.clj">second targeted workload</a> to illustrate violations of <a href="https://jepsen.io/consistency/models/monotonic-atomic-view">Monotonic Atomic View</a>. This workload creates a single table with two rows:</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span>create</span> <span>table</span> mav (</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>  <span>id</span>      <span>int</span> <span>not</span> <span>null</span>,</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>  `value` <span>int</span> <span>not</span> <span>null</span>,</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>  noop    <span>int</span> <span>not</span> <span>null</span>,</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>  <span>primary</span> <span>key</span> (<span>id</span>)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>);</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a><span>insert</span> <span>into</span> mav (<span>id</span>, `value`, noop)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>  <span>values</span> (<span>0</span>, <span>0</span>, <span>0</span>);</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a><span>insert</span> <span>into</span> mav (<span>id</span>, `value`, noop)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a>  <span>values</span> (<span>1</span>, <span>0</span>, <span>0</span>);</span></code></pre></div>
<p>We perform a mix of write and read transactions. Each write increments the <code>value</code> of row 0, then increments row 1. Reads select the value of row 0, set the <code>noop</code> field of row 1 to a random value, then read the values of 1 and 0. Under Monotonic Atomic View, these reads should be monotonically increasing. For example, once a reader observes value <code>2</code>, it should thereafter see every row’s value as <code>2</code> or higher.</p>
<h2 data-number="2.4" id="lazyfs"> LazyFS</h2>
<p>In 2022 Jepsen commissioned the University of Porto’s <a href="https://www.inesctec.pt/en">INESC TEC</a> to develop <a href="https://github.com/dsrhaslab/lazyfs">LazyFS</a>: a FUSE filesystem for simulating the loss of un-fsynced writes. LazyFS maintains an in-memory page cache of data which has been written but not fsynced, flushing it to underlying storage only as the cache fills or <code>fsync</code> calls are made. A test harness can ask LazyFS to discard its cache at any time, simulating what might happen during a power failure. João Pedro Rodrigues Azevedo’s <a href="https://repositorium.sdum.uminho.pt/bitstream/1822/84475/1/Joao%20Pedro%20Rodrigues%20Azevedo.pdf">dissertation</a> discusses this work in detail, including several database bugs.</p>
<p><a href="https://github.com/dsrhaslab/lazyfs">LazyFS</a> has been <a href="https://github.com/jepsen-io/jepsen/blob/f69fe9929af8528d289b9ba4f72bdc18bad35157/jepsen/src/jepsen/lazyfs.clj">integrated with Jepsen</a> for a little over a year, but this is the first public Jepsen report including it. We tested MySQL by killing the MySQL process, <a href="https://github.com/jepsen-io/mysql/blob/4c239cb5c66a7f1a55fa02ce4c9f43b7a70e9d0b/src/jepsen/mysql/db/mysql.clj#L200-L203">asking LazyFS to drop uncommitted writes</a>, then restarting the process.</p>

<h2 data-number="3.1" id="g2-item-at-repeatable-read"> G2-item at Repeatable Read</h2>
<p>Adya’s Repeatable Read (PL-2.99) prohibits G2-item: a cycle of write-write, write-read, and read-write dependency edges, where those edges do not involve predicates. However, MySQL’s Repeatable Read routinely allows G2-item, even on a single healthy node. Kleppmann <a href="https://github.com/ept/hermitage/blob/master/mysql.md#write-skew-g2-item">reported this behavior</a> in 2014 and it still occurs today. Take for example <a href="https://s3.amazonaws.com/jepsen.io/analyses/mysql-8.0.34/rr-g2-item-20230929T000636.621.zip">this list-append test</a>, which exhibited 214 cycles in just 40 seconds. Here is one of those cycles comprising two transactions, neither of which saw each other’s effects.</p>

<p>In this diagram the top transaction read key 141 and saw the value <code>[1 2]</code>, then appended <code>1</code> to key 140. The bottom transaction appended <code>3</code> to key 141, read key 141 and observed the value <code>[1 2 3]</code>, then read key 140 and found it did not exist. The top transaction must have executed before the bottom transaction, since it failed to observe the bottom transaction’s append of <code>3</code>. But the bottom transaction must have executed before the top transaction, since it read key 140 before any append! This cycle involves purely reads and updates by primary key, and is therefore G2-item.<a href="#fn10" id="fnref10" role="doc-noteref"><sup>10</sup></a></p>
<p>Transactions which fail to see each other’s effects could violate important invariants. Consider two independent electricians, each adding a new 20 amp circuit to a breaker panel. Each might visit the site to check<a href="#fn11" id="fnref11" role="doc-noteref"><sup>11</sup></a> that the total load on each circuit (including the one they intend to add) would not exceed the 100 amp capacity of the panel, then return a few days later to add the circuit. Under MySQL’s Repeatable Read, both could see a load of 70 amps, add a 20 amp circuit, and create a total load of 110 amps—exceeding the safe load of the panel.<a href="#fn12" id="fnref12" role="doc-noteref"><sup>12</sup></a></p>
<p>While this behavior is prohibited by PL-2.99 Repeatable Read, it could be interpreted as legal under ANSI SQL Repeatable Read. The standard’s definition of P2 (non-Repeatable Read) only discusses a transaction which reads the same row twice and observes some other transaction’s effects. Since these transactions never read a row twice, they do not exhibit P2! This is one of many ways in which the standard fails to capture anomalous behavior.</p>
<h2 data-number="3.2" id="g-single-at-repeatable-read"> G-single at Repeatable Read</h2>
<p>The example of G2-item we presented above involved a pair of transactions linked by adjacent read-write edges: in short, neither observed the other’s effects. However, MySQL Repeatable Read also exhibits G-single (a.k.a. read skew): cycles composed of write-write, write-read, and read-write edges, but where read-write edges are never adjacent to one another. <a href="https://github.com/ept/hermitage/blob/master/mysql.md#read-skew-g-single">Kleppmann reported this behavior in 2014</a>, and we can confirm it still occurs in MySQL 8.0.34. Like G2-item, G-single cycles involving only item dependencies are prohibited under PL-2.99 Repeatable Read.</p>
<p>Take, for example, this <a href="https://s3.amazonaws.com/jepsen.io/analyses/mysql-8.0.34/rr-everything-20231003T100453.595-0500.zip">sixty-second append test</a> of a single MySQL node without any faults. At roughly 140 transactions per second it exhibited 244 instances of G-single (plus 305 more instances of G2-item). Since the append test uses no predicate operations, all of these are violations of Repeatable Read. Here is one of those cycles:</p>

<p>The top transaction here appended <code>9</code> to key 363, then <code>5</code> to key 377. The bottom transaction failed to observe the append to 377, but also managed to append <code>10</code> to key 363 after the top transaction. We know this because a later read observed key 363’s value as <code>[5 6 4 7 8 9 10]</code>. This violates both Repeatable Read (which rules out any cycle of item edges) and Snapshot Isolation (which rules out G-single in general).</p>
<p>In short: one transaction can both fail to observe but also overwrite another. More complex cycles involving write-read edges also occur. In this case the dependency edges involved different keys, which suggests an interesting question: what would happen if two transactions conflicted on a <em>single</em> key?</p>
<h2 data-number="3.3" id="lost-update-at-repeatable-read"> Lost Update at Repeatable Read</h2>
<p>Phenomenon P4 (lost update) is a special case of G-single in which exactly two transactions are linked by a write-write and read-write cycle on a single key. In other words: two transactions read the same version of some key, and both go on to update it. This is expressly prohibited by <a href="https://jepsen.io/consistency/models/snapshot-isolation">Snapshot Isolation</a> and <a href="https://jepsen.io/consistency/models/repeatable-read">PL-2.99 Repeatable Read</a>. However, <a href="https://github.com/ept/hermitage/blob/master/mysql.md#lost-update-p4">Kleppmann showed</a> in 2014 that MySQL Repeatable Read allowed lost update, and we can confirm that it still occurs routinely, even on a single node without faults. Here is a second cycle from the <a href="https://s3.amazonaws.com/jepsen.io/analyses/mysql-8.0.34/rr-everything-20231003T100453.595-0500.zip">same test run</a>:</p>

<p>Both of these transactions read key 636, found it missing, and went on to write what they thought would be the first element. This is an obvious instance of lost update: at most one of these transactions should have been able to commit.<a href="#fn13" id="fnref13" role="doc-noteref"><sup>13</sup></a> We also have less obvious examples:</p>

<p>This cluster involves two G-single cycles. The smaller, comprising just the bottom two transactions, has no read of key 1167 before the middle transaction’s write: it is not a classic instance of lost update. However, its read of key 1167 = [1] implies that the state of that key <em>prior</em> to its append of 1 must have been empty, which looks “lost-update-esque.” Moreover, the top transaction <em>also</em> read the unborn version of key 1167 before appending 4 to it. That, together with the bottom transaction, must be lost update.</p>
<p>A later read <code>[:r 1167 [1 3 4]]</code> suggests the following sequence of events. All three transactions must have started before 1167 existed. The middle transaction appended <code>1</code> and read <code>[1]</code> back. Then the bottom transaction appended <code>3</code>, and finally the top transaction appended <code>4</code>. All three transactions eventually committed.</p>
<p>These instances of lost update were caught by Elle’s cycle detection system, since they were involved in G-single. However, Elle’s cycle detection relies on inferring the order of writes to a given key, which we can (mostly) do only if some read observes them. We have recently extended Elle to detect instances of lost update which are invisible to the cycle detector. In these tests, we search for two or more committed transactions which read the same version of some key <span><em>k</em></span>, then all write <span><em>k</em></span>. Regardless of whether we see their effects or not, the mere fact that both committed implies lost update. For example:</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>{<span>:key</span> <span>892</span>,</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a> <span>:value</span> <span>nil</span>,</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a> <span>:txns</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a> [{<span>:process</span> <span>6</span>,</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>   <span>:type</span> <span>:ok</span>,</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>   <span>:f</span> <span>:txn</span>,</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>   <span>:value</span> [[<span>:r</span> <span>892</span> <span>nil</span>]</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>           [<span>:r</span> <span>891</span> <span>nil</span>]</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>           [<span>:append</span> <span>892</span> <span>1</span>]</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>           [<span>:r</span> <span>892</span> [<span>2</span> <span>5</span> <span>4</span> <span>1</span>]]],</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>   <span>:index</span> <span>14806</span>,</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a>   <span>:time</span> <span>49518094450</span>}</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a>  {<span>:process</span> <span>18</span>,</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a>   <span>:type</span> <span>:ok</span>,</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a>   <span>:f</span> <span>:txn</span>,</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a>   <span>:value</span> [[<span>:r</span> <span>892</span> <span>nil</span>]</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a>           [<span>:append</span> <span>892</span> <span>8</span>]</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a>           [<span>:r</span> <span>891</span> [<span>2</span> <span>3</span>]]</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a>           [<span>:append</span> <span>891</span> <span>9</span>]],</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true"></a>   <span>:index</span> <span>14842</span>,</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true"></a>   <span>:time</span> <span>49636093552</span>}]}</span></code></pre></div>
<p>Both of these committed transactions read the unborn (<code>nil</code>) version of key 892 and wrote to it. Out of 9,048 successful transactions in this test, our new checker found 446 distinct transactions involved in 198 instances of lost update. Only 47 of those instances appeared in some cycle.</p>
<p>In short: MySQL Repeatable Read transactions cannot safely read a value and then write it. The standard ORM pattern where a program starts a transaction, loads an object into memory, manipulates it, saves it back to the database, then commits, may find that MySQL silently discards those committed changes. Although PL-2.99 Repeatable Read is supposed to make this pattern safe, MySQL Repeatable Read does not. MySQL users must instead perform their own explicit locking.</p>
<p>An attentive reader may have noticed the above example is more alarming than first meets the eye. The first transaction read the empty state of key 892, appended a single value, then read a version of key 892 including <em>three additional values</em>. Where did those come from?</p>
<h2 data-number="3.4" id="non-repeatable-read-at-repeatable-read"> Non-Repeatable Read at Repeatable Read</h2>
<p>MySQL Repeatable Read exhibits <em>internal consistency anomalies</em>: consistency violations whose effects are visible within a single transaction. These occur even on a single healthy MySQL node. In that <a href="https://s3.amazonaws.com/jepsen.io/analyses/mysql-8.0.34/rr-everything-20231003T100453.595-0500.zip">same test run</a>, 126 of 9,048 committed transactions exhibited internal consistency errors. For example:</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>{<span>:op</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a> {<span>:process</span> <span>12</span>,</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>  <span>:type</span> <span>:ok</span>,</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>  <span>:f</span> <span>:txn</span>,</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>  <span>:value</span> [[<span>:r</span> <span>1185</span> <span>nil</span>]</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>          [<span>:append</span> <span>1185</span> <span>6</span>]</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>          [<span>:append</span> <span>1182</span> <span>8</span>]</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>          [<span>:r</span> <span>1185</span> [<span>3</span> <span>4</span> <span>2</span> <span>6</span>]]],</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>  <span>:index</span> <span>19874</span>,</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a>  <span>:time</span> <span>65980191472</span>},</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a> <span>:mop</span> [<span>:r</span> <span>1185</span> [<span>3</span> <span>4</span> <span>2</span> <span>6</span>]],</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a> <span>:expected</span> [<span>6</span>]}</span></code></pre></div>
<p>This transaction read the unborn (<code>nil</code>) state of key 1185, and decided to append <code>6</code> to it. It then read key 1185 and observed <code>[3 4 2 6]</code>. Three elements appeared out of thin air. Or consider:</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>{<span>:op</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a> {<span>:process</span> <span>19</span>,</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>  <span>:type</span> <span>:ok</span>,</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>  <span>:f</span> <span>:txn</span>,</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>  <span>:value</span> [[<span>:append</span> <span>1099</span> <span>10</span>]</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>          [<span>:r</span> <span>1096</span> [<span>1</span> <span>2</span> <span>3</span>]]</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>          [<span>:append</span> <span>1096</span> <span>7</span>]</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>          [<span>:r</span> <span>1096</span> [<span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span> <span>6</span> <span>7</span>]]],</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>  <span>:index</span> <span>18404</span>,</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>  <span>:time</span> <span>61061580955</span>},</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a> <span>:mop</span> [<span>:r</span> <span>1096</span> [<span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span> <span>6</span> <span>7</span>]],</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a> <span>:expected</span> [<span>1</span> <span>2</span> <span>3</span> <span>7</span>]}</span></code></pre></div>
<p>This transaction read key 1096 and obtained the list <code>[1 2 3]</code>. It appended <code>7</code>, then read the key again, and found three additional values (<code>4</code>, <code>5</code>, and <code>6</code>) inserted in its place. This is forbidden under PL-2.99 Repeatable Read: there must be a read-write dependency from this transaction to some other, and a write-read (or similar) dependency chain leading back. It is forbidden under ANSI Repeatable Read: the transaction performed two reads of the same object and saw different states resulting from a different transaction! The point of Repeatable Read—both for ANSI and Adya—is that once a transaction observes some value, it can count on that value being stable for the remainder of the transaction. MySQL does the opposite: a write is an invitation for another transaction to sneak in and clobber the state you just read.</p>
<p>This behavior allows <a href="https://s3.amazonaws.com/jepsen.io/analyses/mysql-8.0.34/gender-20231003T193907.588.zip">incredible transactions</a> like the following, recorded during a repeatable-read workload:</p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span>set</span> <span>transaction</span> <span>isolation</span> <span>level</span> Repeatable <span>Read</span>;</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a><span>start</span> <span>transaction</span>;</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a><span>select</span> name <span>from</span> people <span>where</span> <span>id</span> <span>=</span> <span>0</span>;</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>  <span>--&gt; &#34;pebble&#34;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a><span>update</span> people <span>set</span> gender <span>=</span> <span>&#34;femme&#34;</span> <span>where</span> <span>id</span> <span>=</span> <span>0</span>;</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a><span>select</span> name <span>from</span> people <span>where</span> <span>id</span> <span>=</span> <span>0</span>;</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>  <span>--&gt; &#34;moss&#34;</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a><span>commit</span>;</span></code></pre></div>
<p>This transaction read a person’s name, set their gender, and read their name again. Despite executing at Repeatable Read, their name spontaneously changed from “pebble” to “moss”.</p>
<p>Violations of internal consistency <a href="https://software.imdea.org/~andrea.cerone/works/Framework.pdf">are forbidden under</a> Read Atomic, Causal Consistency, Parallel Snapshot Isolation, Prefix Consistency, Snapshot Isolation, and Serializability. It also seems clear that this transaction satisfies ANSI SQL’s informal definition of a “non-repeatable read.” It violates MySQL’s <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_repeatable-read">isolation levels documentation</a>, which claims that “consistent reads within the same transaction read the snapshot established by the first read.” It contradicts MySQL’s <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-consistent-read.html">consistent read documentation</a>, which specifically states that InnoDB assigns a timepoint on a transaction’s first read, and the effects of concurrent transactions should not appear in subsequent reads.</p>
<p>If we add other transactions which insert or delete the row, we can observe rows <a href="https://s3.amazonaws.com/jepsen.io/analyses/mysql-8.0.34/rr-nonrepeatable-insert-delete-20231003T231826.zip">popping into existence</a> in the middle of a Repeatable Read transaction:</p>
<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span>start</span> <span>transaction</span>;</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span>select</span> name <span>from</span> people <span>where</span> <span>id</span> <span>=</span> <span>0</span> <span>--&gt; nil</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a><span>update</span> people <span>set</span> gender <span>=</span> <span>&#34;butch&#34;</span> <span>where</span> <span>id</span> <span>=</span> <span>0</span>;</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a><span>select</span> name <span>from</span> people <span>where</span> <span>id</span> <span>=</span> <span>0</span>; <span>--&gt; &#34;moss&#34;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a><span>commit</span>;</span></code></pre></div>
<p>However, we have not yet observed a row vanishing due to a concurrent delete. Perhaps this is because the update statement updates <em>no</em> rows, leaving the snapshot intact. Whatever the reason, the consistent read documentation’s claim that deletes, inserts, and updates “are treated similarly” appears incorrect: deletes seem to work differently from inserts and updates.</p>
<h2 data-number="3.5" id="non-monotonic-view"> Non-Monotonic View</h2>
<p><a href="https://github.com/ept/hermitage">Kleppmann’s Hermitage</a> lists MySQL Repeatable Read as <a href="https://jepsen.io/consistency/models/monotonic-atomic-view">monotonic atomic view</a>. Per <a href="https://amplab.cs.berkeley.edu/wp-content/uploads/2013/10/hat-vldb2014.pdf">Bailis et al</a>, Monotonic Atomic View ensures that once a transaction <span><em>T</em><sub>2</sub></span> observes an effect of transaction <span><em>T</em><sub>1</sub></span>, <span><em>T</em><sub>2</sub></span> observes <em>all</em> effects of <span><em>T</em><sub>1</sub></span>. Even if MySQL Repeatable Read fetches a fresh snapshot on each write, it might still provide Monotonic Atomic View if the snapshots are monotone. This is how <a href="https://github.com/ept/hermitage/blob/master/postgres.md">Postgres read committed</a> works.</p>
<p>This is not the case in MySQL. In healthy single-node deployments, MySQL routinely violates Monotonic Atomic View at Repeatable Read. Recall that our Monotonic Atomic View workload has two rows whose <code>value</code>s are initially <code>0</code>. Writer transactions increment the value of row 0, then row 1: both rows’ values should appear to advance in lockstep. However, the first read transaction from <a href="https://s3.amazonaws.com/jepsen.io/analyses/mysql-8.0.34/rr-mav-20231005T140119.171-0500.zip">this monotonic-atomic-view test</a> observed:</p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span>start</span> <span>transaction</span>;</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a><span>select</span> <span>value</span> <span>from</span> mav <span>where</span> <span>id</span> <span>=</span> <span>0</span>;    <span>--&gt; 0</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a><span>update</span> mav <span>set</span> noop <span>=</span> <span>73</span> <span>where</span> <span>id</span> <span>=</span> <span>1</span>;</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a><span>select</span> <span>value</span> <span>from</span> mav <span>where</span> <span>id</span> <span>=</span> <span>1</span>;    <span>--&gt; 1</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a><span>select</span> <span>value</span> <span>from</span> mav <span>where</span> <span>id</span> <span>=</span> <span>0</span>;    <span>--&gt; 0</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a><span>commit</span>;</span></code></pre></div>
<p>This read transaction saw the state of row 0 prior to the first write transaction. Then it saw the writer’s increment of row 1. Under monotonic atomic view, it should have gone on to observe all of the writer’s effects—including the increment of row 0. However, when it selected row 0 it saw the old value, not the new one. This is a non-monotonic read!</p>
<p>MySQL’s <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-consistent-read.html">consistent read documentation</a> talks about snapshots extensively, but this behavior doesn’t look like a snapshot at all. Snapshot systems usually provide a consistent, point-in-time view of the database state. They are usually atomic: either all of a transaction’s effects are included, or none are. Even if MySQL had somehow obtained a non-atomic snapshot from the <em>middle</em> of the write transaction, it must have seen the increment of row 0 before the increment of row 1. This is not the case: this read transaction observed the increment of row 1 but <em>not</em> row 0. In what sense can this possibly be considered a snapshot?</p>
<h2 data-number="3.6" id="fractured-read-like-anomalies-with-rds-serializable"> Fractured Read-Like Anomalies with RDS Serializable</h2>
<p>A common strategy for improving both the availability and throughput of a production MySQL database is to deploy one or more <em>read replicas</em>. These replicas continually apply binlogs that are shipped to them by the read/write primary instance, accept connections, and permit read-only transactions to run. Some cloud vendors (e.g. Amazon RDS) configure one or two read replicas as a part of their default production deployment profile.</p>
<p>We found that AWS RDS MySQL routinely violated Serializability at Serializable isolation, even in healthy clusters. Consider <a href="http://jepsen.io.s3.amazonaws.com/analyses/mysql-8.0.34/20230829T165306.964Z.zip">this append test</a> which ran on an RDS MySQL cluster with the default recommended production profile. It exhibited several G2-item and G-single anomalies, like the following:</p>

<p>The top transaction appended <code>3</code> to key 2215, and that write was visible to the middle transaction. The middle transaction appended <code>8</code> to key 2219, which was visible to the bottom transaction. However, the bottom transaction missed the top transaction’s write! All G-single anomalies we found involved at least three transactions linked by at least two write-read edges.</p>
<p>Exactly what kind of anomaly is this, and how severe is it? It is clearly an instance of G-single, since it has exactly one read-write edge. It is also G2-item, since it does not involve predicates. This implies RDS MySQL’s “Serializable” isolation violates Snapshot Isolation, Repeatable Read, and Serializability.</p>
<p>However, G-single is a broad class of anomalies, and this appears unlike the other instances of G-single we’ve discussed so far. It is not lost update: no transaction reads then writes the same key. Unlike our previous example of G-single which involved a write-write edge, this anomaly has only write-read and read-write edges. It somewhat resembles <a href="https://people.eecs.berkeley.edu/~alig/papers/ramp.pdf">fractured read</a>, in which a transaction reads only a subset of another transaction’s writes. However, this anomaly involves a reader <span><em>T</em><sub>3</sub></span> which observes a writer <span><em>T</em><sub>2</sub></span>’s effects, but does not observe an earlier <span><em>T</em><sub>1</sub></span> which was visible to <span><em>T</em><sub>2</sub></span>. It is in some sense a “transitive” fractured read.</p>
<p>Regarding severity, we observe first that <em>any</em> instance of G-single, when running all transactions at the Serializable isolation level, is significant. The received wisdom in the MySQL community is to avoid using Serializable unless absolutely necessary. The MySQL manual discourages users from using Serializable at all, stating:</p>
<blockquote>
<p><code>SERIALIZABLE</code> enforces even stricter rules than <code>REPEATABLE READ</code>, and is used mainly in specialized situations, such as with XA transactions and for troubleshooting issues with concurrency and deadlocks.</p>
</blockquote>
<p>Given this guidance, we would expect users to run transactions at this strongest isolation level only when they know they need a high degree of safety, and are willing to pay the performance cost of extra synchronization in order to rule out anomalies. Graver still, fractured read-like anomalies (as instances of G2-item) are forbidden by Repeatable Read. They should occur only at Read Committed and below. That they arise at “Serializable” is troubling.</p>
<p>We suspect this behavior is due in part to RDS’s choice of default parameters for production clusters. Among the large variety of configuration parameters that govern the behavior of read replicas is one whose very name should make us uneasy: <a href="https://dev.mysql.com/doc/refman/8.0/en/replication-options-replica.html#sysvar_replica_preserve_commit_order"><code>replica_preserve_commit_order</code></a>.<a href="#fn14" id="fnref14" role="doc-noteref"><sup>14</sup></a></p>
<blockquote>
<p>For multithreaded replicas (replicas on which <code>replica_parallel_workers</code> is set to a value greater than 0), setting <code>replica_preserve_commit_order=ON</code> ensures that transactions are executed and committed on the replica in the same order as they appear in the replica’s relay log. This prevents gaps in the sequence of transactions that have been executed from the replica’s relay log, and preserves the same transaction history on the replica as on the source (with the limitations listed below).</p>
</blockquote>
<p>Serializable systems are supposed to guarantee transactions execute in (what appears to be) a total order. Failing to preserve that order on a replica seems like it would be a bad thing, even if it permitted more parallelism in applying the log entries. The documentation goes on to say that while this parameter used to be disabled by default, MySQL version 8.0.27 and higher default to <code>replica_preserve_commit_order=ON</code>. However, RDS’s default parameters still choose <code>replica_preserve_commit_order=OFF</code>. If we apply this setting to our local test clusters, we observe similar instances of G-single and G2-item.</p>
<table>
<thead>
<tr>
<th>№</th>
<th>Summary</th>
<th>Event Required</th>
<th>Fixed in</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>G2-item at Repeatable Read</td>
<td>None</td>
<td>Unresolved</td>
</tr>
<tr>
<td>2</td>
<td>G-single at Repeatable Read</td>
<td>None</td>
<td>Unresolved</td>
</tr>
<tr>
<td>3</td>
<td>Lost update at Repeatable Read</td>
<td>None</td>
<td>Unresolved</td>
</tr>
<tr>
<td>4</td>
<td>Non-Repeatable read at Repeatable Read</td>
<td>None</td>
<td>Unresolved</td>
</tr>
<tr>
<td>5</td>
<td>Non-monotonic view at Repeatable Read</td>
<td>None</td>
<td>Unresolved</td>
</tr>
<tr>
<td>6</td>
<td>Fractured read-like anomalies at Serializable (in RDS)</td>
<td>None</td>
<td>Unresolved</td>
</tr>
</tbody>
</table>

<p>First, the good news. In our testing, MySQL 8.0.34’s Read Uncommitted, read committed, and Serializable isolation levels appeared to satisfy PL-1 read uncommitted, PL-2 Read Committed, and PL-3 Serializable, respectively. This held both for single nodes and small clusters with read-only replicas using binlog replication, and through process pauses, crashes, and network partitions.</p>
<p>Our LazyFS fault injection scheme did not discover problems with MySQL’s default settings. With <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_flush_log_at_trx_commit"><code>innodb_flush_log_at_trx_commit</code></a> at the default setting of <code>1</code>, process crashes followed by the loss of un-fsynced data did not result in the loss of committed transactions. When we adjusted that setting to <code>0</code>, MySQL fsynced only once every <span><em>n</em></span> seconds and we observe data loss.</p>
<p>The bad news: MySQL’s “Repeatable Read” does not satisfy PL-2.99 Repeatable Read: it exhibits G2-item anomalies including write skew. It does not satisfy Snapshot Isolation: it exhibits G-single, including read skew and lost update. Lost update rules out cursor stability. Reads in MySQL “Repeatable Read” are not repeatable, even under the ambiguous definitions of the ANSI SQL standard. Its transactions violate internal consistency, which rules out Read Atomic, Causal, Consistent View, Prefix, and Parallel snapshot isolation. <a href="https://github.com/ept/hermitage#summary-of-test-results">Kleppmann’s 2014 Hermitage</a> suggested MySQL Repeatable Read might be Monotonic Atomic View, but this cannot be true: we found monotonicity violations.</p>
<p>Some authors <a href="https://fileadmin.cs.lth.se/cs/Education/EDAF20/lectures/transactions.pdf">characterize</a> MySQL Repeatable Read as <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf">Snapshot Isolation</a>. For example, Kleppmann’s <a href="https://www.oreilly.com/library/view/designing-data-intensive-applications/9781491903063/"><em>Designing Data-Intensive Applications</em></a> says “PostgreSQL and MySQL call their Snapshot Isolation level Repeatable Read”.<a href="#fn15" id="fnref15" role="doc-noteref"><sup>15</sup></a> Formalizations of Snapshot Isolation <a href="https://jepsen.io/consistency/models/snapshot-isolation">vary</a>, but most make it appear as if all of a transaction’s reads occurred at the transaction start time (plus local changes). This is not true in MySQL: when a write occurs, multiple reads of a key may reveal <em>newer</em> versions of that key resulting from other transactions’ writes. Moreover, Snapshot Isolated systems generally appear as if all of a transaction’s writes occur atomically. MySQL allows a transaction to read some, but not all, of another transaction’s writes. This is inconsistent with every version of Snapshot Isolation we are familiar with.</p>
<p>It isn’t clear what MySQL Repeatable Read actually <em>is</em>. It allows histories which violate Monotonic Atomic View and cursor stability; we know it cannot be equal to or stronger than those models. We have not observed G0 (dirty writes), G1a (aborted reads), G1b (intermediate reads), or G1c (cyclic infomation flow); it appears at least as strong as Read Committed. The repeatability of <em>some</em> reads means it is actually stronger than Read Committed.</p>

<p>In this <a href="https://jepsen.io/consistency">graph of consistency models</a> an arrow from A to B means that B is strictly stronger than A. By this we mean the histories permitted by B are a strict subset of those permitted by A: a system which provides B provides A as well. It seems likely that MySQL Repeatable Read is incomparable to Monotonic Atomic View: it allows violations of Monotonic Atomic View, but also rules out some non-repeatable reads that Monotonic Atomic View allows. Likewise, it is incomparable to Repeatable Read: MySQL Repeatable Read <a href="https://www.pythian.com/blog/understanding-mysql-isolation-levels-repeatable-read">appears to prohibit certain phantoms</a> which are legal under both ANSI and PL-2.99 Repeatable Read. However, we are unsure exactly which other models are strictly stronger than MySQL Repeatable Read. Is every prefix-consistent history legal under MySQL Repeatable Read? Or are they too incomparable? Because MySQL Repeatable Read’s behavior is so unusual, and because we lack a formal definition of its properties, we are unsure where to draw additional arrows in the diagram above.</p>
<p>As always, we caution that Jepsen takes an experimental approach to safety verification: we can prove the presence of bugs, but not their absence. While we make extensive efforts to find problems, we cannot prove correctness.</p>

<p>The behavior of MySQL Repeatable Read appears poorly understood in the MySQL community. <a href="https://priyankvex.com/2018/10/20/tackling-lost-updates-problem-in-database-using-better-isolation-level/">Several</a> <a href="https://levelup.gitconnected.com/preventing-data-inconsistencies-in-mysql-strategies-for-avoiding-lost-updates-cfdb04107f7c">authors</a> <a href="https://www.zghurskyi.com/lost-update/">believe</a> <a href="https://forums.mysql.com/read.php?22,56420,56420#msg-56420">Repeatable</a> <a href="https://vladmihalcea.com/a-beginners-guide-to-database-locking-and-the-lost-update-phenomena/">Read</a> <a href="https://amirsoleimani.medium.com/understanding-database-isolation-level-via-examples-mysql-and-postgres-a86b5502d404">should</a> <a href="https://flylib.com/books/en/1.63.1.107/1/">prevent</a> lost update. However, <a href="https://stackoverflow.com/questions/46315232/how-to-use-transactions-in-mysql-to-avoid-lost-updates">several</a> <a href="https://forums.mysql.com/read.php?22,56420,57733">others</a> <a href="https://stackoverflow.com/questions/9060400/repeatable-read-and-second-lost-updates-issue">acknowledge</a> <a href="https://www.up-2date.com/post/lost-update">it</a> <a href="https://blog.jcoglan.com/2020/10/12/reading-and-writing-part-3/">actually</a> <a href="https://forum.hibernate.org/viewtopic.php?p=2489608">does</a> <a href="https://stackoverflow.com/questions/10040785/mysql-repeatable-read-and-lost-update-phantom-reads?rq=3">not</a>, and advise (for example) explicit locking tactics. Similarly, <a href="https://www.prisma.io/dataguide/mysql/inserting-and-modifying-data/using-transactions">many</a> <a href="https://mydbops.wordpress.com/2018/06/22/back-to-basics-isolation-levels-in-mysql/">internet</a> <a href="https://buildatscale.tech/transaction-isolation-level-in-innodb/">sources</a> <a href="https://stackoverflow.com/questions/42668158/mysql-repeatable-read-transaction-unexpected-behavior">state</a> (<a href="https://decentro.tech/blog/decoding-isolation-levels-in-mysql/">incorrectly</a>) that MySQL repeatable reads <a href="https://www.prisma.io/dataguide/mysql/inserting-and-modifying-data/using-transactions">are</a> <a href="https://www.tutorialspoint.com/mysql/mysql_set_transaction.htm">repeatable</a>. This is understandable: <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_repeatable-read">MySQL</a> and <a href="https://mariadb.com/kb/en/set-transaction/#repeatable-read">MariaDB</a>’s own documentation makes this claim. Those claims are contradicted by a single sentence in a note buried in the <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-consistent-read.html">MySQL consistent reads documentation</a>. Other blog posts and articles <a href="https://yizhang82.dev/innodb-repeatable-read">acknowledge</a> (<a href="https://dev.to/techschoolguru/understand-isolation-levels-read-phenomena-in-mysql-postgres-c2e">some indirectly</a>) that MySQL Repeatable Read <a href="https://www.pythian.com/blog/understanding-mysql-isolation-levels-repeatable-read">actually</a> <a href="https://www.percona.com/blog/what-if-mysqls-repeatable-reads-cause-you-to-lose-money/">allows</a> non-repeatable reads.</p>
<p>Cabral and Murphy’s 2009 <a href="https://www.oreilly.com/library/view/mysql-administrators-bible/9780470416914/"><em>MySQL Administrator’s Bible</em></a> states that MySQL “supports the four standard isolation levels,” and emphasizes at length that Repeatable Read prevents a transaction from observing another transaction’s concurrent writes:</p>
<blockquote>
<p>Using the <code>REPEATABLE READ</code> isolation level, all reads within a transaction show the same data values, even if a second transaction has committed a data change while the first transaction was still running. If a transaction starts, reads a row, waits 60 seconds, and reads the same row again, both data reads will be the same—even if in those 60 seconds another transaction has changed and committed data. The first transaction has the same data when it repeats the read….</p>
<p><code>REPEATABLE READ</code> may not seem like a good idea—after all, if the data changes, shouldn’t a transaction be aware of that? The problem is that a transaction may take different actions based on the values of the data. Data values changing within a transaction may lead to unexpected consequences.</p>
</blockquote>
<p>Cabral and Murphy repeat that Repeatable Read “allows a transaction to see the same data for values it has already read regardless of whether or not the data has been changed.” In their section on multi-version concurrency control, they emphasize the independence of transaction snapshots:</p>
<blockquote>
<p>If a second transaction starts, it “checks out” its own copy of the data. If the first transaction makes changes and commits, the second transaction will not see the data. The second transaction can only work with the data it has. There is no way to update the data that the second transaction sees, though the second transaction could issue a ROLLBACK and start the transaction again to see the new data.</p>
</blockquote>
<p>This is also wrong: writing a row modifies the transaction’s local copy of the data.</p>
<p>Grippa &amp; Kuzmichev’s 2021 <a href="https://www.oreilly.com/library/view/learning-mysql-2nd/9781492085911/"><em>Learning MySQL</em></a> states that MySQL supports all of the SQL:1992 standard isolation levels. They too claim:</p>
<blockquote>
<p>With the <code>REPEATABLE READ</code> isolation level, there are thus no dirty reads and or non-repeatable reads. Each transaction reads the snapshot established by the first read.</p>
</blockquote>
<p>However, the section on Serializable isolation actually demonstrates (perhaps inadvertently) that MySQL’s Repeatable Read allows both lost update, a change in read snapshot, and a resulting internal consistency violation! It then shows that <code>Serializable</code> prevents those anomalies. It doesn’t name the anomalies, instead opting to say that “this doesn’t make sense”, but the behavior is visible to a careful reader. It’s not clear if the authors realize the example contradicts their earlier claims about non-repeatable reads and snapshot integrity.</p>
<h2 data-number="4.2" id="recommendations"> Recommendations</h2>
<p>The core problem is that MySQL claims to implement Repeatable Read but actually provides something much weaker. We see two avenues to resolve this problem.</p>
<p>The first is to keep MySQL’s behavior as it is, and to clearly document the consistency model “Repeatable Read” actually provides. There is precedent in other databases: PostgreSQL’s Repeatable Read <a href="https://jepsen.io/analyses/postgresql-12.3">is actually Snapshot Isolation</a>, and exhibits behaviors which violate PL-2.99 Repeatable Read. However, PostgreSQL’s documentation eventually <a href="https://www.postgresql.org/docs/current/transaction-iso.html#XACT-REPEATABLE-READ">mentions</a> that their Repeatable Read implementation is actually Snapshot Isolation. MySQL could similarly document that their “Repeatable Read” means “Read Committed, plus some sort of guarantees that hold until the transaction writes something, at which point mysteries occur.” A precise characterization of those mysteries would be most welcome.</p>
<p>The second option is to treat these behaviors as bugs and fix them. Jepsen would be delighted if MySQL and other vendors were to commit to providing PL-2.99 Repeatable Read. However, even satisfying the incomplete, ambiguous ANSI definition of Repeatable Read would be an improvement over current affairs.</p>
<p>In the meantime, MySQL users who require PL-2.99 or ANSI Repeatable Read should be cautious of MySQL Repeatable Read. Reads may not be repeatable, or even reflect a snapshot of committed state. The common ORM pattern in which a transaction reads an object into memory, modifies it, then writes it back within a transaction, may cause committed updates to be silently lost. Users requiring Repeatable Read semantics should use MySQL’s Serializable isolation instead. Alternatively, they can selectively strengthen reads performed at <code>READ COMMITTED</code> using locking techniques like <code>SELECT ... FOR UPDATE</code>.</p>
<h2 data-number="4.3" id="rds"> RDS</h2>
<p>AWS RDS MySQL cluster exhibits read skew and G2-item at its “Serializable” isolation level. Users who rely on Serializability should set <code>slave_preserve_commit_order</code> to <code>ON</code> in their RDS parameter groups. Jepsen suggests that AWS either change the default, or clearly explain the allowed violations of Serializability in the <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/MySQL.KnownIssuesAndLimitations.html">known limitations</a> documentation for RDS MySQL.</p>
<h2 data-number="4.4" id="future-work"> Future Work</h2>
<p>MySQL’s binlog replication appears fragile. We observed a number of mysterious scenarios in which replication halted in our local Jepsen tests. We also found that a few minutes of testing could <a href="https://mastodon.jepsen.io/@jepsen/111231274947177218">completely break</a> AWS RDS’s MySQL replication: even a simple <code>CREATE DATABASE</code> would succeed on the primary and fail to appear on the secondaries. We waited an hour without observing recovery. MySQL’s <a href="https://dev.mysql.com/doc/refman/8.0/en/replication-solutions-unexpected-replica-halt.html">default settings are known to be unsafe</a> in replicated systems. We made no attempt to promote nodes from secondaries to primaries, or to explore <a href="https://mariadb.com/kb/en/replication-overview/#common-replication-setups">exciting topologies</a> like ring or star replication. Future work might explore these behaviors.</p>
<p>We have begun research into more general-purpose predicate tests, but this work is still early. Once ready, we’d like to evaluate MySQL predicate safety and see if it differs from primary-key operations.</p>
<h2 data-number="4.5" id="a-plea-to-standards-bodies"> A Plea to Standards Bodies</h2>
<p>Twenty-eight years after Berenson et al. demonstrated that ANSI SQL’s isolation levels are ambiguous and incomplete, seven revisions of the ANSI &amp; ISO standards have left its definitions unchanged.<a href="#fn16" id="fnref16" role="doc-noteref"><sup>16</sup></a> P0 is still legal at every level up to Repeatable Read. We still don’t know whether circular information flow is legal at Read Committed. P3 still doesn’t mention deletes. Internal behavior remains unspecified. <a href="https://www.vldb.org/pvldb/vol7/p181-bailis.pdf">The</a> <a href="https://www.cs.cornell.edu/lorenzo/papers/Crooks17Seeing.pdf">research</a> <a href="https://arxiv.org/abs/1903.00731">community</a> <a href="https://software.imdea.org/~andrea.cerone/works/Framework.pdf">has</a> <a href="https://software.imdea.org/~gotsman/papers/si-podc16.pdf">moved</a> <a href="http://www.cs.ox.ac.uk/people/hongseok.yang/paper/popl14-final.pdf">on</a> <a href="https://asc.di.fct.unl.pt/~nmp/pubs/europar-2-2013.pdf">to</a> <a href="https://dsf.berkeley.edu/cs286/papers/ssi-tods2005.pdf">new</a> <a href="https://www.inf.usi.ch/faculty/pedone/Paper/2004/IC_TECH_REPORT_200421.pdf">formalisms</a>. Many are based on <a href="https://pmg.csail.mit.edu/papers/adya-phd.pdf">Adya’s 1999 thesis</a>, which struggled to capture “what the SQL standard actually meant.”</p>
<p>If you happen to sit on the ISO/IEC JTC1/SC 32 Data Management and Interchange committee, please imagine the soft chords of a heart-tugging piano lament have begun to play. A montage of transactional anomalies appears on your screen. Internal anomalies. Lost updates. Dirty writes. Jepsen is looking into the camera, holding a database.</p>
<blockquote>
<p>Hi. This is Jepsen. Will you be an angel for a helpless database? Every day major databases exhibit anomalous behavior which ISO/IEC 9075-2 fails to characterize. For just <a href="https://pmg.csail.mit.edu/papers/icde00.pdf">a few pages of formalism</a>, you can give vendors and users a clear, meaningful, and portable definition of isolation levels.</p>
<p>It’s been almost three decades. Act now.</p>
</blockquote>
<p><em>Jepsen wishes to thank <a href="https://www.inesctec.pt/en">INESC TEC</a> and in particular João Azevedo, Ricardo Macedo, João Tiago Paulo, José Pereira, and Maria Ramos, for building LazyFS. Our thanks also to <a href="https://github.com/jgpc42">Justin Conklin</a>, who contributed ASM advice and code for a significant performance improvement in Jepsen’s underlying analysis library. <a href="https://www.irenekannyo.com/">Irene Kannyo</a> provided invaluable editorial support. This work was performed independently by Jepsen without compensation, in accordance with the <a href="https://jepsen.io/ethics">Jepsen ethics policy</a>.</em></p>

  </div>
</article></div>
  </body>
</html>
