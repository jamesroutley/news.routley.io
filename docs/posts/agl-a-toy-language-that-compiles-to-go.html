<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/alaingilbert/agl">Original</a>
    <h1>Show HN: AGL a toy language that compiles to Go</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text"><p dir="auto">
  <a target="_blank" rel="noopener noreferrer" href="https://parkerhiggins.net/alaingilbert/agl/blob/master/agl.png"><img src="https://parkerhiggins.net/alaingilbert/agl/raw/master/agl.png" alt="AGL" width="250"/></a>
</p>


<p dir="auto">AGL is a language that compiles to Go.</p>
<ul dir="auto">
<li>Functions return only a single value. This makes it possible to use types like <code>Option[T]</code> and <code>Result[T]</code>, and to support automatic error propagation via an operator.</li>
<li>To make returning multiple values easy, a Tuple type has been introduced. For example: <code>Result[(u8, string, bool)]</code></li>
<li>AGL can be used as a scripting language</li>
</ul>
<p dir="auto">Notable change: number types are <code>int i8 i16 i32 i64 uint u8 u16 u32 u64 f32 f64</code></p>

<ul dir="auto">
<li>Tuple</li>
<li>Enum</li>
<li>Error propagation operators (<code>?</code> for Option[T] / <code>!</code> for Result[T])</li>
<li>Concise anonymous function with type inferred arguments (<code>other := someArr.Filter({ $0 % 2 == 0 })</code>)</li>
<li>Array built-in Map/Reduce/Filter/Find/Sum methods</li>
<li>Operator overloading</li>
<li>Compile down to Go code</li>
<li>VSCode extension &amp; LSP (language server protocol)</li>
<li>Shell &#34;shebang&#34; support</li>
</ul>

<div dir="auto" data-snippet-clipboard-copy-content="go build               // Build the &#34;agl&#34; executable
./agl main.agl         // Output Go code in stdout
./agl run main.agl     // Run the code directly and output the result in stdout
./agl build main.agl   // Create a main.go file"><pre><span>go</span> <span>build</span>               <span>// Build the &#34;agl&#34; executable</span>
.<span>/</span><span>agl</span> <span>main</span>.<span>agl</span>         <span>// Output Go code in stdout</span>
.<span>/</span><span>agl</span> <span>run</span> <span>main</span>.<span>agl</span>     <span>// Run the code directly and output the result in stdout</span>
.<span>/</span><span>agl</span> <span>build</span> <span>main</span>.<span>agl</span>   <span>// Create a main.go file</span></pre></div>


<div dir="auto" data-snippet-clipboard-copy-content="package main

import &#34;fmt&#34;

func getInt() int! { // `int!` means the function return a `Result[int]`
    return Ok(42)
}

func intermediate() int! {
    num := getInt()! // Propagate &#39;Err&#39; value to the caller
    return Ok(num + 1)
}

func main() {
    num := intermediate()! // crash on &#39;Err&#39; value
    fmt.Println(num)
}"><pre><span>package</span> main

<span>import</span> <span>&#34;fmt&#34;</span>

<span>func</span> <span>getInt</span>() <span>int</span><span>!</span> { <span>// `int!` means the function return a `Result[int]`</span>
    <span>return</span> <span>Ok</span>(<span>42</span>)
}

<span>func</span> <span>intermediate</span>() <span>int</span><span>!</span> {
    <span>num</span> <span>:=</span> <span>getInt</span>()<span>!</span> <span>// Propagate &#39;Err&#39; value to the caller</span>
    <span>return</span> <span>Ok</span>(<span>num</span> <span>+</span> <span>1</span>)
}

<span>func</span> <span>main</span>() {
    <span>num</span> <span>:=</span> <span>intermediate</span>()<span>!</span> <span>// crash on &#39;Err&#39; value</span>
    <span>fmt</span>.<span>Println</span>(<span>num</span>)
}</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="package main

import &#34;fmt&#34;

func maybeInt() int? { // `int?` means the the function return an `Option[int]`
    return Some(42)
}

func intermediate() int? {
    num := maybeInt()? // Propagate &#39;None&#39; value to the caller
    return Some(num + 1)
}

func main() {
    num := intermediate()? // crash on &#39;None&#39; value
    fmt.Println(num)
}"><pre><span>package</span> main

<span>import</span> <span>&#34;fmt&#34;</span>

<span>func</span> <span>maybeInt</span>() <span>int</span>? { <span>// `int?` means the the function return an `Option[int]`</span>
    <span>return</span> <span>Some</span>(<span>42</span>)
}

<span>func</span> <span>intermediate</span>() <span>int</span>? {
    <span>num</span> <span>:=</span> <span>maybeInt</span>()? <span>// Propagate &#39;None&#39; value to the caller</span>
    <span>return</span> <span>Some</span>(<span>num</span> <span>+</span> <span>1</span>)
}

<span>func</span> <span>main</span>() {
    <span>num</span> <span>:=</span> <span>intermediate</span>()? <span>// crash on &#39;None&#39; value</span>
    <span>fmt</span>.<span>Println</span>(<span>num</span>)
}</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="package main

type Person struct { Name string }

func (p Person) MaybeSelf() Person? {
    return Some(p)
}

func main() {
    bob := Person{Name: &#34;bob&#34;}
    bob.MaybeSelf()?.MaybeSelf()?.MaybeSelf()?
}"><pre><span>package</span> main

<span>type</span> <span>Person</span> <span>struct</span> { <span>Name</span> <span>string</span> }

<span>func</span> (<span>p</span> <span>Person</span>) <span>MaybeSelf</span>() <span>Person</span>? {
    <span>return</span> <span>Some</span>(<span>p</span>)
}

<span>func</span> <span>main</span>() {
    <span>bob</span> <span>:=</span> <span>Person</span>{<span>Name</span>: <span>&#34;bob&#34;</span>}
    <span>bob</span>.<span>MaybeSelf</span>()?.<span>MaybeSelf</span>()?.<span>MaybeSelf</span>()?
}</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto"><code>If Some(val) := ... {</code> to use a Option[T]/Result[T] value safely</h3><a id="user-content-if-someval----to-use-a-optiontresultt-value-safely" aria-label="Permalink: If Some(val) := ... { to use a Option[T]/Result[T] value safely" href="#if-someval----to-use-a-optiontresultt-value-safely"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This pattern works with any of <code>Ok</code>|<code>Err</code>|<code>Some</code></p>
<div dir="auto" data-snippet-clipboard-copy-content="func maybeInt() int? { Some(42) } // Implicit return when a single expression is present

func main() {
    if Some(num) := maybeInt() {
        fmt.Println(num)
    }
}"><pre><span>func</span> <span>maybeInt</span>() <span>int</span>? { <span>Some</span>(<span>42</span>) } <span>// Implicit return when a single expression is present</span>

<span>func</span> <span>main</span>() {
    <span>if</span> <span>Some</span>(<span>num</span>) <span>:=</span> <span>maybeInt</span>() {
        <span>fmt</span>.<span>Println</span>(<span>num</span>)
    }
}</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="package main

import &#34;fmt&#34;

func getInt() int! { Ok(42) }

func maybeInt() int? { Some(42) }

func main() {
    match getInt() {
    case Ok(num):
        fmt.Println(&#34;Num:&#34;, num)
    case Err(err):
        fmt.Println(&#34;Error:&#34;, err)
    }

    match maybeInt() {
    case Some(num):
        fmt.Println(&#34;Num:&#34;, num)
    case None:
        fmt.Println(&#34;No value&#34;)
    }
}"><pre><span>package</span> main

<span>import</span> <span>&#34;fmt&#34;</span>

<span>func</span> <span>getInt</span>() <span>int</span><span>!</span> { <span>Ok</span>(<span>42</span>) }

<span>func</span> <span>maybeInt</span>() <span>int</span>? { <span>Some</span>(<span>42</span>) }

<span>func</span> <span>main</span>() {
    <span>match</span> <span>getInt</span>() {
    <span>case</span> <span>Ok</span>(<span>num</span>):
        <span>fmt</span>.<span>Println</span>(<span>&#34;Num:&#34;</span>, <span>num</span>)
    <span>case</span> <span>Err</span>(<span>err</span>):
        <span>fmt</span>.<span>Println</span>(<span>&#34;Error:&#34;</span>, <span>err</span>)
    }

    <span>match</span> <span>maybeInt</span>() {
    <span>case</span> <span>Some</span>(<span>num</span>):
        <span>fmt</span>.<span>Println</span>(<span>&#34;Num:&#34;</span>, <span>num</span>)
    <span>case</span> None:
        <span>fmt</span>.<span>Println</span>(<span>&#34;No value&#34;</span>)
    }
}</pre></div>

<p dir="auto"><code>or_break</code>/<code>or_continue</code> will <code>break</code>/<code>continue</code> on a <code>None</code>/<code>Err</code> value</p>
<div dir="auto" data-snippet-clipboard-copy-content="package main

import &#34;fmt&#34;
import &#34;time&#34;

func test(i int) int? {
    if i &gt;= 2 {
        return None
    }
    return Some(i)
}

func main() {
    for i := 0; i &lt; 10; i++ {
        res := test(i) or_break // `res` has type `int`
        fmt.Println(res)        // will print the value `0` and `1`
        time.Sleep(time.Second)
    }
}"><pre><span>package</span> main

<span>import</span> <span>&#34;fmt&#34;</span>
<span>import</span> <span>&#34;time&#34;</span>

<span>func</span> <span>test</span>(<span>i</span> <span>int</span>) <span>int</span>? {
    <span>if</span> <span>i</span> <span>&gt;=</span> <span>2</span> {
        <span>return</span> <span>None</span>
    }
    <span>return</span> <span>Some</span>(<span>i</span>)
}

<span>func</span> <span>main</span>() {
    <span>for</span> <span>i</span> <span>:=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>10</span>; <span>i</span><span>++</span> {
        <span>res</span> <span>:=</span> <span>test</span>(<span>i</span>) <span>or_break</span> <span>// `res` has type `int`</span>
        <span>fmt</span>.<span>Println</span>(<span>res</span>)        <span>// will print the value `0` and `1`</span>
        <span>time</span>.<span>Sleep</span>(<span>time</span>.<span>Second</span>)
    }
}</pre></div>
<div dir="auto"><h2 tabindex="-1" dir="auto">Short anonymous function (type inferred)</h2><a id="user-content-short-anonymous-function-type-inferred" aria-label="Permalink: Short anonymous function (type inferred)" href="#short-anonymous-function-type-inferred"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Arguments are mapped into <code>$0</code>|<code>$1</code>...</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Lang</th>
<th>Expression</th>
</tr>
</thead>
<tbody>
<tr>
<td>Go</td>
<td><code>utils.Filter(arr, func(x int) bool { return x % 2 == 0 })</code></td>
</tr>
<tr>
<td>AGL</td>
<td><code>arr.Filter({ $0 % 2 == 0 })</code></td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto">Since the function is expected to return something and there is only one expression, it will be returned automatically.</p>
<div dir="auto" data-snippet-clipboard-copy-content="package main

type Person struct {
    Name string
    Age int
}

func main() {
    arr := []int{1, 2, 3, 4, 5}
    sum := arr.Filter({ $0 % 2 == 0 }).Map({ $0 + 1 }).Sum()
    assert(sum == 8)

    p1 := Person{Name: &#34;foo&#34;, Age: 18}
    p2 := Person{Name: &#34;bar&#34;, Age: 19}
    people := []Person{p1, p2}
    names := people.Map({ $0.Name }).Joined(&#34;, &#34;)
    sumAge := people.Map({ $0.Age }).Sum()
    assert(names == &#34;foo, bar&#34;)
    assert(sumAge == 37)
}"><pre><span>package</span> main

<span>type</span> <span>Person</span> <span>struct</span> {
    <span>Name</span> <span>string</span>
    <span>Age</span> <span>int</span>
}

<span>func</span> <span>main</span>() {
    <span>arr</span> <span>:=</span> []<span>int</span>{<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>}
    <span>sum</span> <span>:=</span> arr.<span>Filter</span>({ $<span>0</span> <span>%</span> <span>2</span> <span>==</span> <span>0</span> }).<span>Map</span>({ $<span>0</span> <span>+</span> <span>1</span> }).<span>Sum</span>()
    <span>assert</span>(<span>sum</span> <span>==</span> <span>8</span>)

    <span>p1</span> <span>:=</span> <span>Person</span>{<span>Name</span>: <span>&#34;foo&#34;</span>, <span>Age</span>: <span>18</span>}
    <span>p2</span> <span>:=</span> <span>Person</span>{<span>Name</span>: <span>&#34;bar&#34;</span>, <span>Age</span>: <span>19</span>}
    <span>people</span> <span>:=</span> []<span>Person</span>{<span>p1</span>, <span>p2</span>}
    <span>names</span> <span>:=</span> people.<span>Map</span>({ $<span>0.</span><span>Name</span> }).<span>Joined</span>(<span>&#34;, &#34;</span>)
    <span>sumAge</span> <span>:=</span> people.<span>Map</span>({ $<span>0.</span><span>Age</span> }).<span>Sum</span>()
    <span>assert</span>(<span>names</span> <span>==</span> <span>&#34;foo, bar&#34;</span>)
    <span>assert</span>(<span>sumAge</span> <span>==</span> <span>37</span>)
}</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="package main

import &#34;fmt&#34;

type IpAddr enum {
    v4(u8, u8, u8, u8)
    v6(string)
}

func main() {
    // enum values can be destructured
    addr1 := IpAddr.v4(127, 0, 0, 1)
    a, b, c, d := addr1

    // tuple can be destructured
    tuple := (1, &#34;hello&#34;, true)
    e, f, g := tuple

    fmt.Println(a, b, c, d, e, f, g)
}"><pre><span>package</span> main

<span>import</span> <span>&#34;fmt&#34;</span>

<span>type</span> <span>IpAddr</span> <span>enum</span> {
    <span>v4</span>(<span>u8</span>, <span>u8</span>, <span>u8</span>, <span>u8</span>)
    <span>v6</span>(<span>string</span>)
}

<span>func</span> <span>main</span>() {
    <span>// enum values can be destructured</span>
    <span>addr1</span> <span>:=</span> <span>IpAddr</span>.<span>v4</span>(<span>127</span>, <span>0</span>, <span>0</span>, <span>1</span>)
    <span>a</span>, <span>b</span>, <span>c</span>, <span>d</span> <span>:=</span> <span>addr1</span>

    <span>// tuple can be destructured</span>
    <span>tuple</span> <span>:=</span> (<span>1</span>, <span>&#34;hello&#34;</span>, <span>true</span>)
    <span>e</span>, <span>f</span>, <span>g</span> <span>:=</span> <span>tuple</span>

    <span>fmt</span>.<span>Println</span>(<span>a</span>, <span>b</span>, <span>c</span>, <span>d</span>, <span>e</span>, <span>f</span>, <span>g</span>)
}</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="package main

type Person struct {
    Name string
    Age int
}

func (p Person) == (other Person) bool {
    return p.Age == other.Age
}

func main() {
    p1 := Person{Name: &#34;foo&#34;, Age: 42}
    p2 := Person{Name: &#34;bar&#34;, Age: 42}
    assert(p1 == p2) // People of the same age are obviously equal!
}"><pre><span>package</span> main

<span>type</span> <span>Person</span> <span>struct</span> {
    <span>Name</span> <span>string</span>
    <span>Age</span> <span>int</span>
}

<span>func</span> (<span>p</span> <span>Person</span>) <span>==</span> (<span>other</span> <span>Person</span>) <span>bool</span> {
    <span>return</span> <span>p</span>.<span>Age</span> <span>==</span> <span>other</span>.<span>Age</span>
}

<span>func</span> <span>main</span>() {
    <span>p1</span> <span>:=</span> <span>Person</span>{<span>Name</span>: <span>&#34;foo&#34;</span>, <span>Age</span>: <span>42</span>}
    <span>p2</span> <span>:=</span> <span>Person</span>{<span>Name</span>: <span>&#34;bar&#34;</span>, <span>Age</span>: <span>42</span>}
    <span>assert</span>(<span>p1</span> <span>==</span> <span>p2</span>) <span>// People of the same age are obviously equal!</span>
}</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="package main

import &#34;fmt&#34;

func (v agl.Vec[T]) Even() []T {
    out := make([]T, 0)
    for _, el := range v {
        if el % 2 == 0 {
            out = append(out, el)
        }
    }
    return out
}

func main() {
    arr := []int{1, 2, 3, 4, 5, 6, 7, 8}
    res := arr.Even().Filter({ $0 &lt;= 6 }).Map({ $0 + 1 }) 
    //         ^^^^^^ new method available
    fmt.Println(res) // [3 5 7]
}"><pre><span>package</span> main

<span>import</span> <span>&#34;fmt&#34;</span>

<span>func</span> (<span>v</span> agl.<span>Vec</span>[<span>T</span>]) <span>Even</span>() []<span>T</span> {
    <span>out</span> <span>:=</span> <span>make</span>([]<span>T</span>, <span>0</span>)
    <span>for</span> <span>_</span>, <span>el</span> <span>:=</span> <span>range</span> <span>v</span> {
        <span>if</span> <span>el</span> <span>%</span> <span>2</span> <span>==</span> <span>0</span> {
            <span>out</span> <span>=</span> <span>append</span>(<span>out</span>, <span>el</span>)
        }
    }
    <span>return</span> <span>out</span>
}

<span>func</span> <span>main</span>() {
    <span>arr</span> <span>:=</span> []<span>int</span>{<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>, <span>6</span>, <span>7</span>, <span>8</span>}
    <span>res</span> <span>:=</span> <span>arr</span>.<span>Even</span>().<span>Filter</span>({ $<span>0</span> <span>&lt;=</span> <span>6</span> }).<span>Map</span>({ $<span>0</span> <span>+</span> <span>1</span> }) 
    <span>//         ^^^^^^ new method available</span>
    <span>fmt</span>.<span>Println</span>(<span>res</span>) <span>// [3 5 7]</span>
}</pre></div>
<p dir="auto">Methods can have generic type parameters</p>
<div dir="auto" data-snippet-clipboard-copy-content="func (v agl.Vec[T]) MyMap[R any](clb func(T) R) []R {
    out := make([]R, 0)
    for _, el := range v {
        out = append(out, clb(el))
    }
    return out
}"><pre><span>func</span> (<span>v</span> agl.<span>Vec</span>[<span>T</span>]) <span>MyMap</span>[<span>R</span> <span>any</span>](<span>clb</span> <span>func</span>(<span>T</span>) <span>R</span>) []<span>R</span> {
    <span>out</span> <span>:=</span> <span>make</span>([]<span>R</span>, <span>0</span>)
    <span>for</span> _, <span>el</span> <span>:=</span> <span>range</span> <span>v</span> {
        <span>out</span> <span>=</span> <span>append</span>(<span>out</span>, <span>clb</span>(<span>el</span>))
    }
    <span>return</span> <span>out</span>
}</pre></div>
<p dir="auto">You can also extend for a specific type of vector</p>
<div dir="auto" data-snippet-clipboard-copy-content="func (v agl.Vec[string]) MyJoined(sep string) string {
    return strings.Join(v, sep)
}"><pre><span>func</span> (<span>v</span> agl.<span>Vec</span>[<span>string</span>]) <span>MyJoined</span>(<span>sep</span> <span>string</span>) <span>string</span> {
    <span>return</span> <span>strings</span>.<span>Join</span>(<span>v</span>, <span>sep</span>)
}</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="package main

import (
    &#34;fmt&#34;
    &#34;os&#34;
)

func main() {
    os.WriteFile(&#34;test.txt&#34;, []byte(&#34;test&#34;), 0755)!
    by := os.ReadFile(&#34;test.txt&#34;)!
    fmt.Println(string(by))
}"><pre><span>package</span> main

<span>import</span> (
    <span>&#34;fmt&#34;</span>
    <span>&#34;os&#34;</span>
)

<span>func</span> <span>main</span>() {
    <span>os</span>.<span>WriteFile</span>(<span>&#34;test.txt&#34;</span>, []<span>byte</span>(<span>&#34;test&#34;</span>), <span>0755</span>)<span>!</span>
    <span>by</span> <span>:=</span> os.<span>ReadFile</span>(<span>&#34;test.txt&#34;</span>)<span>!</span>
    <span>fmt</span>.<span>Println</span>(<span>string</span>(<span>by</span>))
}</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="package main

import (
    &#34;fmt&#34;
    &#34;net/http&#34;
    &#34;io&#34;
)

func main() {
    req := http.NewRequest(http.MethodGet, &#34;https://google.com&#34;, None)!
    c := http.Client{}
    resp := c.Do(req)!
    defer resp.Body.Close()
    by := io.ReadAll(resp.Body)!
    fmt.Println(string(by))
}"><pre><span>package</span> main

<span>import</span> (
    <span>&#34;fmt&#34;</span>
    <span>&#34;net/http&#34;</span>
    <span>&#34;io&#34;</span>
)

<span>func</span> <span>main</span>() {
    <span>req</span> <span>:=</span> <span>http</span>.<span>NewRequest</span>(<span>http</span>.<span>MethodGet</span>, <span>&#34;https://google.com&#34;</span>, <span>None</span>)<span>!</span>
    <span>c</span> <span>:=</span> http.<span>Client</span>{}
    <span>resp</span> <span>:=</span> c.<span>Do</span>(<span>req</span>)<span>!</span>
    <span>defer</span> <span>resp</span>.<span>Body</span>.<span>Close</span>()
    <span>by</span> <span>:=</span> io.<span>ReadAll</span>(<span>resp</span>.<span>Body</span>)<span>!</span>
    <span>fmt</span>.<span>Println</span>(<span>string</span>(<span>by</span>))
}</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="#!/usr/bin/env agl run
package main

import &#34;fmt&#34;

func main() {
    fmt.Println(&#34;Hello AGL!&#34;)
}"><pre>#<span>!</span><span>/</span><span>usr</span><span>/</span><span>bin</span><span>/</span><span>env</span> <span>agl</span> <span>run</span>
<span>package</span> main

<span>import</span> <span>&#34;fmt&#34;</span>

<span>func</span> <span>main</span>() {
    <span>fmt</span>.<span>Println</span>(<span>&#34;Hello AGL!&#34;</span>)
}</pre></div>
<div dir="auto" data-snippet-clipboard-copy-content="$ chmod +x hello.agl
$ ./hello.agl
Hello AGL!"><pre>$ chmod +x hello.agl
$ ./hello.agl
Hello AGL<span>!</span></pre></div>
</article></div></div>
  </body>
</html>
