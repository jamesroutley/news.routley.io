<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://williamw520.github.io/2025/07/13/zig-interface-revisited.html">Original</a>
    <h1>Zig Interface Revisited</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
    <p><strong><em>Achieving polymorphism via dynamic dispatch in Zig</em></strong></p>

<p>Unlike many languages that offer <code>interface</code> or <code>virtual</code> constructs, 
Zig has no built-in notion of interfaces. This reflects Zig’s commitment 
to simplicity and performance. That doesn’t mean polymorphism is off the table.
In fact Zig has the tools to build interface-like behavior, making dynamic dispatch possible.</p>

<h2 id="polymorphism-in-zig-the-options">Polymorphism in Zig: The Options</h2>

<p>Let’s backtrack a bit. There are ways to achieve polymorphism in Zig, depending on the use case:</p>

<ul>
  <li><strong>Generics and comptime dispatch</strong> - for static polymorphism based on types and functions.</li>
  <li><strong>Tagged unions</strong> - for closed sets of known types, enabling sum-type polymorphism.</li>
  <li><strong>VTable interfaces</strong> - for dynamic dispatch across heterogeneous implementations.</li>
</ul>

<p>A common motivation for interfaces is to allow uniform typing, e.g. storing multiple 
implementations in an array or map. Both tagged unions and vtable-based interfaces support this.</p>

<h2 id="on-vtable-interfaces">On VTable Interfaces</h2>

<p>In this post we’ll focus on vtable interfaces.</p>

<p>While I was doing the <a href="https://github.com/williamw520/zigjr">ZigJR</a> project, I had the need
for using interfaces to plug in different implementations.
There had been a number of approaches developed over time to make vtable interface possible in Zig. 
After a deep dive into the language, I have settled on one pattern. With some finetuning, 
this pattern provides a clean, flexible, and reusable approach, with little to no impact on implementation types.</p>

<h2 id="goals-of-this-interface-pattern">Goals of This Interface Pattern</h2>

<p>This approach achieves:</p>

<ul>
  <li>Clear separation between interface and implementation.</li>
  <li>No changes required in implementation types.</li>
  <li>Full dynamic dispatch via function pointers.</li>
  <li>Uniform type for all interface instances (enabling storage in arrays, maps, etc.).</li>
</ul>

<p>Let’s explore how it works step-by-step.</p>

<hr/>

<h2 id="example-use-case-loggers">Example Use Case: Loggers</h2>

<p>Let’s say we’re building a logging system that supports multiple backends:</p>

<ul>
  <li>A debug logger that prints to the console.</li>
  <li>A file logger that writes to disk.</li>
  <li>And others.</li>
</ul>

<p>Each logger supports a common interface: <code>log()</code> and <code>setLevel()</code>.</p>

<blockquote>
  <p><small>Note: The code below is simplified for illustrative purposes. 
It omits many practical considerations in favor of brevity.</small></p>
</blockquote>

<h3 id="debug-logger">Debug Logger</h3>

<p>Below is the implementation of a logger logging to the <code>std.debug</code> output. 
It has its own idiosyncrasy like keeping track of the message count.</p>

<pre><code>pub const DbgLogger = struct {
    level:  usize = 0,
    count:  usize = 0;

    pub fn log(self: *DbgLogger, msg: []const u8) void {
        self.count += 1;
        std.debug.print(&#34;{}: [level {}] {s}\n&#34;, .{self.count, self.level, msg});
    }

    pub fn setLevel(self: *DbgLogger, level: usize) void {
        self.level = level;
    }
};
</code></pre>

<h3 id="file-logger">File Logger</h3>

<p>Here is another logging implementation that logs to a file. It has its own <code>init()</code> and <code>deinit()</code> methods
dealing with the log file.</p>

<pre><code>pub const FileLogger = struct {
    file:   std.fs.File,

    pub fn init(path: []const u8) !FileLogger {
        return .{ 
            .file = try std.fs.cwd().createFile(path, .{ .read = false }) 
        };
    }

    pub fn deinit(self: *FileLogger) void {
        self.file.close();
    }

    pub fn log(self: *FileLogger, msg: []const u8) void {
        self.file.writer().print(&#34;{s}\n&#34;, .{msg})
            catch |err| std.debug.print(&#34;Err: {any}\n&#34;, .{err});
    }

    pub fn setLevel(self: *FileLogger, level: usize) void {
        self.file.writer().print(&#34;== New Level {} =={s}\n&#34;, .{level})
            catch |err| std.debug.print(&#34;Err: {any}\n&#34;, .{err});
    }
};
</code></pre>

<p>Note: The two implementations are totally independent. They don’t know about any “interface” 
but they share the same “interface” method signatures.</p>

<h2 id="building-the-vtable-interface">Building the VTable Interface</h2>

<p>Below is the core <code>Logger</code> interface type, with labeled sections for explanation.</p>

<pre><code>/// Logger interface
pub const Logger = struct {
    impl:       *anyopaque,     // (1) pointer to the implementation
    v_log:      *const fn(*anyopaque, []const u8) void, // (2) vtable
    v_setLevel: *const fn(*anyopaque, usize) void,      // (2) vtable

    // (3) Link up the implementation pointer and vtable functions
    pub fn implBy(impl_obj: anytype) Logger {
        const delegate = LoggerDelegate(impl_obj);
        return .{
            .impl = impl_obj,
            .v_log = delegate.log,
            .v_setLevel = delegate.setLevel,
        };
    }

    // (4) Public methods of the interface

    pub fn log(self: Logger, msg: []const u8) void {
        self.v_log(self.impl, msg);
    }

    pub fn setLevel(self: Logger, level: usize) void {
        self.v_setLevel(self.impl, level);
    }
};

// (5) Delegate to turn the opaque pointer back to the implementation.
inline fn LoggerDelegate(impl_obj: anytype) type {
    const ImplType = @TypeOf(impl_obj);
    return struct {
        fn log(impl: *anyopaque, msg: []const u8) void {
            TPtr(ImplType, impl).log(msg);
        }

        fn setLevel(impl: *anyopaque, level: usize) void {
            TPtr(ImplType, impl).setLevel(level);
        }
    };
}

fn TPtr(T: type, opaque_ptr: *anyopaque) T {
    return @as(T, @ptrCast(@alignCast(opaque_ptr)));
}
</code></pre>

<h3 id="using-the-interface">Using the Interface</h3>

<pre><code>    var dbg_logger = DbgLogger {};
    const logger1 = Logger.implBy(&amp;dbg_logger);
    logger1.log(&#34;Hello1&#34;);
    logger1.log(&#34;Hello2&#34;);
    logger1.setLevel(2);
    logger1.log(&#34;Hello3&#34;);

    var file_logger = try FileLogger.init(&#34;log.txt&#34;);
    defer file_logger.deinit();
    const logger2 = Logger.implBy(&amp;file_logger);
    logger2.log(&#34;Hello1&#34;);
    logger2.setLevel(3);
    logger2.log(&#34;Hello2&#34;);
    logger2.log(&#34;Hello3&#34;);
    
    const loggers = [_] Logger {logger1, logger2};
    for (loggers) |l|
        l.log(&#34;Hello to all loggers&#34;);
    
</code></pre>

<p>Both <code>logger1</code> and <code>logger2</code> are of type <code>Logger</code>, so they can be stored in arrays, 
passed to functions, or placed in maps, just like in strictly typed languages with first-class interfaces.</p>

<h2 id="how-it-works">How It Works</h2>

<p>Let’s review the key parts of this interface pattern:</p>

<table>
  <thead>
    <tr>
      <th>Part</th>
      <th>Role</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>(1) <code>impl: *anyopaque</code></td>
      <td>Stores the implementation as an untyped pointer.</td>
    </tr>
    <tr>
      <td>(2) function pointers</td>
      <td>The “vtable” pointers to method shims that downcast and call the real methods.</td>
    </tr>
    <tr>
      <td>(3) <code>implBy()</code></td>
      <td>Connects an implementation to the interface’s untyped pointer and vtable.</td>
    </tr>
    <tr>
      <td>(4) Interface methods</td>
      <td>Public API of the interface. Call into the vtable with the opaque pointer.</td>
    </tr>
    <tr>
      <td>(5) Delegate struct</td>
      <td>Reconstructs the original type and calls its methods. This also enforces parameter checking at compile time to ensure the implementation’s functions match up to the interface’s ones.</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<hr/>

<h2 id="advantages">Advantages</h2>

<ul>
  <li><strong>Clean separation</strong>: Implementations don’t know about the interface.</li>
  <li><strong>Extensible</strong>: Adding a new implementation requires no changes to the interface.</li>
  <li><strong>Uniform type</strong>: You can store different implementations together.</li>
</ul>

<h2 id="trade-offs">Trade-offs</h2>

<ul>
  <li>Boilerplate: must manually define each vtable method and delegate.</li>
  <li>Some indirection: Dynamic dispatch requires extra function pointer calls (minimal, but real).</li>
</ul>

<blockquote>
  <p>The upside is that all boilerplate and complexity is confined to the interface layer; 
 implementations remain simple and pure.</p>
</blockquote>

<h2 id="closing-thoughts">Closing Thoughts</h2>

<p>Though Zig doesn’t have interfaces as a language feature, you can still build your own. 
You get full control over abstraction, and zero runtime overhead if you want it.
With vtable interfaces, you can achieve dynamic dispatch, support uniform types, 
and write expressive, decoupled APIs.</p>

<p>With better tooling or codegen in the future, some of the boilerplate may even be eliminated.</p>

<p>Until then, this approach gives you the flexibility of interfaces, in the Zig way.</p>

    <hr/>

  </div></div>
  </body>
</html>
