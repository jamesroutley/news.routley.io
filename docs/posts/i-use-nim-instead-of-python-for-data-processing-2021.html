<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://benjamindlee.com/posts/2021/why-i-use-nim-instead-of-python-for-data-processing/">Original</a>
    <h1>I use Nim instead of Python for data processing (2021)</h1>
    
    <div id="readability-page-1" class="page"><article><header><div><p><time datetime="2021-09-23 05:08:20 -0400 -0400">September 23, 2021</time><span>·</span><span title="Reading time">5 mins</span></p></div></header><section><div><p>Lazy programmers often prefer to substitute computing effort for programming effort. I am just such a programmer. For my research, I often need to design and run algorithms over large datasets ranging into the scale of terabytes. As a fellow at the NIH, I have access to Biowulf, a 100,000+ processor cluster, so it’s usually not worth spending a ton of time optimizing single-threaded performance for a single experiment when I can just perform a big <a href="https://en.wikipedia.org/wiki/MapReduce" target="_blank" rel="noreferrer">MapReduce</a>.</p><p>Despite having access to these resources, I increasingly use the <a href="https://nim-lang.org" target="_blank" rel="noreferrer">Nim programming language</a> for data processing tasks. Nim is under-appreciated in computational science but it is a very capable Python replacement for non-numerical data processing. At a high level, Nim is as easy to write as Python and as fast as C. It’s part of a newer generation of languages that have the performance of compiled languages with the expressiveness of dynamic languages. If you know Python, you’re 90% of the way to knowing Nim and reaping all of the benefits.</p><p>Consider the following simple problem: you have a bunch of DNA sequences (strings which are comprised of four letters, A, T, G, and C), stored in a text file with <code>&gt;</code> delimited comment lines (<em>i.e.</em> <a href="https://en.wikipedia.org/wiki/FASTA_format" target="_blank" rel="noreferrer">FASTA format</a>). A standard task is computing the percentage of Gs and Cs in the sequence, a metric known as the <a href="https://en.wikipedia.org/wiki/GC-content" target="_blank" rel="noreferrer">GC content</a>. In Python, a simple implementation would look like this:</p><div><div><pre tabindex="0"><code data-lang="python"><span><span>gc <span>=</span> <span>0</span>
</span></span><span><span>total <span>=</span> <span>0</span>
</span></span><span><span>
</span></span><span><span><span>for</span> line <span>in</span> <span>open</span>(<span>&#34;orthocoronavirinae.fasta&#34;</span>):
</span></span><span><span>    <span>if</span> line[<span>0</span>] <span>==</span> <span>&#39;&gt;&#39;</span>: <span># ignore comment lines</span>
</span></span><span><span>        <span>continue</span>
</span></span><span><span>    <span>for</span> letter <span>in</span> line<span>.</span>rstrip():
</span></span><span><span>        <span>if</span> letter <span>==</span> <span>&#39;C&#39;</span> <span>or</span> letter <span>==</span> <span>&#39;G&#39;</span>:
</span></span><span><span>            gc <span>+=</span> <span>1</span>
</span></span><span><span>        total <span>+=</span> <span>1</span>
</span></span><span><span>
</span></span><span><span><span>print</span>(gc <span>/</span> total)
</span></span></code></pre></div></div><p>This code takes 23.43 seconds to run on a 150 MB coronavirus genome dataset using my laptop. As an alternative, I can just use Nim and get a huge speed up essentially for free. Indeed, the Nim implementation is more-or-less identical:</p><div><div><pre tabindex="0"><code data-lang="nim"><span><span><span>var</span> gc <span>=</span> <span>0</span>
</span></span><span><span><span>var</span> total <span>=</span> <span>0</span>
</span></span><span><span>
</span></span><span><span><span>for</span> line <span>in</span> lines(<span>&#34;orthocoronavirinae.fasta&#34;</span>):
</span></span><span><span>    <span>if</span> line<span>[</span><span>0</span><span>]</span> <span>==</span> <span>&#39;&gt;&#39;</span>: <span># ignore comment lines</span>
</span></span><span><span>        <span>continue</span>
</span></span><span><span>    <span>for</span> letter <span>in</span> line:
</span></span><span><span>        <span>if</span> letter <span>==</span> <span>&#39;C&#39;</span> <span>or</span> letter <span>==</span> <span>&#39;G&#39;</span>:
</span></span><span><span>            gc <span>+=</span> <span>1</span>
</span></span><span><span>        total <span>+=</span> <span>1</span>
</span></span><span><span>
</span></span><span><span>echo(gc <span>/</span> total)
</span></span></code></pre></div></div><p>These changes, though small in terms of code, are quite large in terms of performance:</p><table><thead><tr><th>Program</th><th>Time</th><th>Relative to Nim</th></tr></thead><tbody><tr><td>Python 3.9</td><td>23.43 s</td><td>30.6x</td></tr><tr><td>PyPy 7.3</td><td>2.54 s</td><td>3.3x</td></tr><tr><td>Nim 1.4 (with<code>-d:danger --gc:orc</code> flags)</td><td>0.765 s</td><td>1.0x</td></tr></tbody></table><p>For complete fairness in the comparisons, the Nim compilation process took an additional 702 ms, meaning that it is <em>still</em> faster to do a complete optimized compile and run cycle than even using PyPy. Nim makes this easy since there is an <code>r</code> command that automatically runs your program after it compiles. Even though Nim is a compiled language, the compilation process is fast enough that it can be used in place of an interpreted one.</p><p>Though nearly the same, there are a few differences between the Nim code and the Python code:</p><ol><li>Variables are declared using <code>var</code>. Nim allows run-time constants to be defined using <code>let</code> and checked at compile time for any possibility of mutation. It also supports compile-time constants using <code>const</code>.</li><li>The <code>lines</code> function is used rather than <code>open</code> to iterate over the contents of the file line-by-line. A nice feature of the <code>lines</code> function is that it automatically strips newline characters such as <code>LF</code> and <code>CRLF</code> so we no longer need to do<code>line.rstrip()</code>.</li><li>Nim uses <code>echo</code>, not <code>print</code>. There are a few minor differences but one plus for <code>echo</code> is that the Python 2.x era <code>print</code>-as-a-statement style expression is back (<em>e.g</em> <code>echo &#34;Hello world!&#34;</code>).</li></ol><p>To illustrate just how useful Nim is, consider this real-life example I encountered in my research. I had a lot of palindromic artifacts within my data, which was messing up my hunt for new <a href="https://en.wikipedia.org/wiki/Viroid" target="_blank" rel="noreferrer">viroids</a>. A hallmark of these artifacts was the presence of long subsequences and their reverse complements (the subsequence backward and with each base replaced with the corresponding pair). To gauge the scope of the problem, I needed to go through each sequence in my dataset, see if it was a likely artifact, and remove it. Let’s first look at the standard Python way to do it:</p><div><div><pre tabindex="0"><code data-lang="python"><span><span><span>import</span> sys
</span></span><span><span><span>from</span> Bio <span>import</span> SeqIO
</span></span><span><span><span>from</span> Bio.Seq <span>import</span> Seq
</span></span><span><span>
</span></span><span><span><span># iterator for subsequences of length k</span>
</span></span><span><span><span>def</span> <span>kmers</span>(seq, k):
</span></span><span><span>    <span>for</span> i <span>in</span> <span>range</span>(<span>len</span>(seq) <span>-</span> k <span>+</span> <span>1</span>):
</span></span><span><span>        <span>yield</span> seq[i:i<span>+</span>k]
</span></span><span><span>
</span></span><span><span><span>for</span> record <span>in</span> SeqIO<span>.</span>parse(sys<span>.</span>argv[<span>1</span>], <span>&#34;fasta&#34;</span>):
</span></span><span><span>    unique_kmers <span>=</span> <span>set</span>()
</span></span><span><span>    palindrome <span>=</span> <span>False</span>
</span></span><span><span>    <span>for</span> kmer <span>in</span> kmers(record<span>.</span>seq, <span>25</span>):
</span></span><span><span>        <span>if</span> kmer<span>.</span>reverse_complement() <span>in</span> unique_kmers:
</span></span><span><span>            palindrome <span>=</span> <span>True</span>
</span></span><span><span>            <span>break</span>
</span></span><span><span>        unique_kmers<span>.</span>add(kmer)
</span></span><span><span>    <span>if</span> <span>not</span> palindrome:
</span></span><span><span>        <span>print</span>(record<span>.</span>format(<span>&#34;fasta&#34;</span>))
</span></span></code></pre></div></div><p>And in Nim:</p><div><div><pre tabindex="0"><code data-lang="nim"><span><span><span>import</span> os
</span></span><span><span><span>import</span> sets
</span></span><span><span><span>import</span> bioseq <span># my library, has k-mer iterator and FASTA parsing</span>
</span></span><span><span>
</span></span><span><span><span>for</span> record <span>in</span> readFasta<span>[</span>Dna<span>]</span>(paramStr(<span>1</span>)):
</span></span><span><span>  <span>var</span> uniqueKmers <span>=</span> initHashSet<span>[</span>Dna<span>]</span>()
</span></span><span><span>  <span>var</span> palindrome <span>=</span> <span>false</span>
</span></span><span><span>  <span>for</span> kmer <span>in</span> kmers(record, <span>25</span>):
</span></span><span><span>    <span>if</span> kmer.reverseComplement() <span>in</span> uniqueKmers:
</span></span><span><span>      palindrome <span>=</span> <span>true</span>
</span></span><span><span>      <span>break</span>
</span></span><span><span>    uniqueKmers.incl(kmer)
</span></span><span><span>  <span>if</span> <span>not</span> palindrome:
</span></span><span><span>    echo(record.asFasta)
</span></span></code></pre></div></div><p>Again, these programs are essentially identical. The salient differences here are:</p><ol><li>Nim uses <code>paramStr</code> to access <code>argv</code>.</li><li>The standard casing style is <a href="https://en.wikipedia.org/wiki/Camel_case" target="_blank" rel="noreferrer"><code>camelCase</code></a>, not <a href="https://en.wikipedia.org/wiki/Snake_case" target="_blank" rel="noreferrer"><code>snake_case</code></a>. Nim treats identifiers as equal if they are the same after removing capitalization (except for the first letter) and underscore, which means that you can use whichever style you want.</li></ol><p>Despite being equally easy to write, the Nim code is 20x faster. Assuming no significant algorithmic differences, it will be impossible for pure Python to beat pure Nim at raw performance since, under the hood, the Nim compilation process generates a C file which is in turn compiled by the C compiler of your choice. Because Nim generates standard C output, it is compatible with Python: you can <a href="https://github.com/yglukhov/nimpy" target="_blank" rel="noreferrer">call Python from Nim</a> and <a href="https://github.com/Pebaz/nimporter" target="_blank" rel="noreferrer">call Nim from Python</a>.</p><p>While Nim makes it easy for experienced Python users to translate their knowledge, where it begins to shine as its own language (rather than a faster Python) is when you write more idiomatic code. I find that Nim programs are usually shorter and easier to write than their Python counterparts as a result of Nim’s <a href="https://nim-lang.org/docs/backends.html#backends-the-javascript-target" target="_blank" rel="noreferrer">other</a> <a href="https://nim-lang.org/docs/manual.html#procedures-method-call-syntax" target="_blank" rel="noreferrer">great</a> <a href="https://nim-lang.org/docs/manual.html#pragmas-nosideeffect-pragma" target="_blank" rel="noreferrer">language</a> <a href="https://nim-lang.org/docs/tut1.html#procedures-result-variable" target="_blank" rel="noreferrer">features</a>, but these features are beyond the scope of a single article. I have used Nim regularly for the past year as a daily driver and continue to be impressed by its performance, simplicity, and elegance. Give Nim a try next time you want to process data: your CPU will thank you.</p></div></section></article></div>
  </body>
</html>
