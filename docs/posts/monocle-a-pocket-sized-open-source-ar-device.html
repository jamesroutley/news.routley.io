<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.brilliantmonocle.com/">Original</a>
    <h1>Monocle: A pocket sized open-source AR device</h1>
    
    <div id="readability-page-1" class="page"><div>
        <p><a href="https://datum-b.com/home">
        <img src="https://datum-b.com/static/dblogo.png" width="60%" max-width="50%" height="auto" alt="Made with PowerPoint"/>
        </a></p>
    <p>2 February, 2023</p>
    <p>My foray into programming has largely been sparked by the deep-seated desires of my own brain. Articulating tangible reasons for this pusuit has been difficult. As a result, there have been a few false starts and abandoned projects. In this post I look back at some of the artifacts I left behind, reflect on where I went wrong, and share some lessons learned for a beginning practitioner.</p>
<h2 id="the-start-to-a-checkered-history">The start to a checkered history</h2>
<p>In late 2017, a curiosity and desire to program was sparked. I don’t remember what sparked it, but I know I wanted to understand computer algorithms, and I wanted to make things run faster. I came across <a href="https://www.freecodecamp.org/">Free Code Camp</a> and started doing some of their JavaScript tutorials. I practiced doing short challenges on <a href="https://www.codewars.com">CodeWars</a>, as I figured this would be a good way to build some fundamentals. I soon dropped JavaScript, as everything I read pointed to Python as being the language to learn if I wanted to have a chance of using it as an engineer.</p>
<p>Around that time I heard about an ancient machine learning exercise, which was to program a game of checkers, and let the computer play against itself thousands of times, in order learn which board configurations led to a win or a loss, eventually training an AI that could beat human players. Inspired with a new problem to try, I learned Python, primarily picking up the language through the excellent and freely available online book <a href="https://greenteapress.com/thinkpython2/html/index.html">Think Python</a>.</p>
<p>The <a href="https://github.com/blairfrandeen/checkers">results of this experiment</a> are nothing to scoff at, if not slightly misguided. I wrote up a graphical interface so I could either play against the AI, or watch it play against itself.</p>
<figure>
<video src="/static/post_images/checkers_2.mp4" controls="" autoplay="" muted="" loop=""><a href="https://datum-b.com/static/post_images/checkers_2.mp4"></a></video><figcaption>My checkers program playing against itself. I never said it was any good, but it does play</figcaption>
</figure>
<p>My first attempt had the computer move purely randomly, and wrote the results of the game to a database. It would then count the percentage of times that a given scenario led to a win or a loss. Unfortunately I didn’t have any idea how to work efficiently with databases, and as the size of the database grew, it took longer and longer to open and write to. Additionally, there are about <span>10<sup>14</sup></span> potential board configurations, and I only recorded about a dozen that occurred more than a few times. These scenarios were generally not helpful, as they tended to only occur in the first few moves of the game.</p>
<p>I pivoted to a different approach to the checkers AI, where I tried to implement logic to determine what the next-best-move might be. This made the AI less bad, but it was still pretty bad. From here I tried to implement a system of scoring or weighting how good a move was, with the goal of using some kind of machine learning algorithms to adjust the weights.</p>
<p>I’d done a lot of rearchitecting, debugging, and even some serious profiling to get to this point. In retrospect, I didn’t have a good enough foundation for this project; neither in programming, computer fundamentals, or in machine learning. I think I over-used object-oriented features, and my attempts at implementing logical AI functions were mostly guesswork. I tried taking some free online courses to learn ML from the ground up, but I was tired of this project, and didn’t know what to work on next.</p>
<p>In hindsight, my failure here is that I was trying to prove to myself that I could solve the game of checkers from scratch, which is a fool’s errand. There is no shame in looking at other solutions. In fact, it would have made me a far better programmer if I had been willing to learn a simple adversarial search algorithm, or read other programmer’s source code to solve the same problem. I have learned more recently that this is the quickest way to pick up new skills and new methods of solving problems.</p>
<h2 id="constraint-dissatisfaction-problems">Constraint Dissatisfaction Problems</h2>
<p>My second false start came two years later, in the spring of 2020. I picked up Python again. I started working through the book <a href="https://www.manning.com/books/classic-computer-science-problems-in-python">Classic Computer Science Problems in Python</a>, still with the intuition that I wanted to understand algorithms at a deeper level. I satisfied this itch, learning basic search algorithms and constraint satisfaction problems. I also learned more about Python, type hinting, and had my first exposure to abstract base classes.</p>
<p>This time I was starting to build a better foundation. I follwed the example problems, and then implemented a new problem of my own choosing to that framework. This got me from the level of copying code out of a book to being forced to understand every bit of it. As an example, I made a <a href="https://github.com/blairfrandeen/knights">search algorithm visualization</a> based on a <a href="https://www.codewars.com/kata/58e6d83e19af2cb8840000b5">CodeWars kata that stumped me</a>. A classic maze problem, with the twist that you have to move like a knight on a chessboard.</p>
<figure>
<video src="/static/post_images/searches2.mp4" controls="" autoplay="" muted="" loop=""><a href="https://datum-b.com/static/post_images/searches2.mp4"></a></video><figcaption>Comparison of breadth-first search (BFS) and A* algorithms for classic maze and a concave obstacle</figcaption>
</figure>
<p>I also used the constraint satisfaction problem framework to build a <a href="https://github.com/blairfrandeen/sudoku">Sudoku solver</a> that could solve a Sudoku puzzle of an arbitrary size, with a built-in &amp; colorful visualization:</p>
<figure>
<video src="/static/post_images/sudoku-demo.mp4" controls="" autoplay="" muted="" loop=""><a href="https://datum-b.com/static/post_images/sudoku-demo.mp4"></a></video><figcaption>A sudoku solver using the constraint satisfaction framework</figcaption>
</figure>
<p>During this phase I started picking up more tools and meta-programming skills, which I still use today. Vim for text editing, and <a href="https://obsidian.md">Obsidian</a> for keeping my notes organized. I also picked up the basics of Jupyter Notebooks, Pandas, and Numpy.</p>
<p>I also started my first work-related coding project at this time, a <a href="https://www.selenium.dev/">Selenium</a> -based scraper and command line interface to augment an internal tool used for writing and executing procedures. I did it in my free time, and got both the joy of building an open-ended tool, and the despair of discovering the existence of <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/">Beautiful Soup</a>, which is when I realized that I had built my program on a shaky foundation, and a complete rewrite would be the best way to continue expanding it keeping it maintainable. When I saw how flawed my initial approach was, I dropped the project.</p>
<p>In better news, I had been promoted to a new position where I didn’t have to write procedures anymore, so I never restarted the tool. Nor did I do much coding at all for nearly 18 months.</p>
<h2 id="unstuckness">Unstuckness</h2>
<p>Both of these false starts have ended in what I hear referred to as “tutorial hell”: Reading more tutorials, trying to figure out what to learn next, and having no good outlet on which to apply it. Sometimes trying to step back from programming all together to get some more foundation in statistics, other times looking for open source projects that I might contribute to, spinning my wheels, and not getting anywhere.</p>
<p>I’m now into my third real push towards programming, and it’s been ongoing for more than a year, with no sign of slowing down. Looking back on these past projects, I see a few good takeaways:</p>
<h3 id="dont-be-ashamed-of-imitation">Don’t be ashamed of imitation</h3>
<p>They say that if you want to be a great original songwriter, you should learn a bunch of cover songs. In fact, learn the entire catalog of your favorite artists. Once mastered, you can find your own distinctive voice.</p>
<p>The same goes for programming: read a bunch of source code. Find puzzles to solve, try them, and if you get stuck, find solutions and pick them apart until you understand them. Get the code running on your machine, and try to break it. Then find a new puzzle, and you’ll eventually pick up on how to solve them.</p>
<p>In reading others source code, you’ll be exposed to tools, frameworks, and methods that wouldn’t otherwise be obvious to you. This leads to the next lesson:</p>
<h3 id="programming-is-not-just-languages">Programming is not just languages</h3>
<p>Text editors. Version control. APIs. Databases. Computer networking. The list goes on. Just knowing something like Python won’t get you very far. You have to understand the entire ecosystem. As a welding instructor once said to me, “a welder who only knows how to weld is like a carpenter who only knows how to use a hammer.”</p>
<h3 id="projects-are-the-gift-that-keeps-on-giving">Projects are the gift that keeps on giving</h3>
<p>If you’re learning to program, you need a good open-ended project. Something that you’ll actually use, even if it’s trivial. Using it means that you see ways to improve it. Improving it means you have more unique problems to solve, and if you wrote code that’s difficult to maintain, you’ll quickly find out. It also means you have to think not just as a programmer, but as an end-user.</p>
<p>One project that’s sustained me for most of the past year has been a <a href="https://github.com/blairfrandeen/titr">command-line application for tracking my time</a>. Another is this blog itself, which is a Flask application built from the ground-up. Both of these are likely built with deep flaws, and that’s okay, because I’m learning from them. And if I really hit a wall, I remember:</p>
<h3 id="its-okay-to-give-up">It’s okay to give up</h3>
<p>Starting new projects, or starting projects over, is often more valuable than finishing projects that are poorly architected.</p>
<p>Requirements for any system are often written and set in stone before that system is understood, and it’s no different with software. Add to this the dimension of a learning practitioner who does not yet know every technique &amp; tool available to them, and you have a recipe for doing it wrong several times.</p>
<p>Giving up or starting over feels like admitting defeat, and it isn’t always easy. Getting hopelessly stuck without a good next project in the pipeline has led me to give up on the adventure of programming for years at a time. There is a sense of disappointment for having done so, and also an appreciation of the perspective time away from my programming practice has given me.</p>


        <hr/>
        <h2>About</h2>
        <p>I am a new software engineer with nearly a decade of specialized experience in mechanical engineering. This blog chronicles my journey with coding, agile hardware development, and leadership principles.</p>

        <div>
            <p><a href="mailto:thoughts@datum-b.com">Email</a> ~ 
            <a href="https://github.com/blairfrandeen">Github</a> ~
            <a href="https://datum-b.com/feed/">Atom</a></p><p>© 2022 - 2023</p><p>The views expressed here are solely my own and do not reflect those of my employer.</p>
        </div>
    </div></div>
  </body>
</html>
