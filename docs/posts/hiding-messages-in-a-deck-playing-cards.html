<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://asherfalcon.com/blog/posts/3">Original</a>
    <h1>Hiding messages in a deck playing cards</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><div><p><span>hiding messages in playing cards</span></p></div><div><p>I was recently thinking about the huge number of ways you can shuffle a deck of 52 cards and wondered if it would be possible to store arbitrary data, which I explore in this blog post.</p></div><p>This blog post will go into the detail of how I found a way to store text inside the order of a deck of cards. If you want to play around with the tool, go <a target="_blank" href="https://deckcrypt.github.io/">here</a>. How many different ways can we shuffle a deck of 52 cards? We can think of it like picking one card from 52, then one from the remaining 51, and so on. We would get an expression that looks like <span data-testid="react-katex"><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>52</mn><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mn>52</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mn>52</mn><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>⋅</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>⋅</mo><mo stretchy="false">(</mo><mn>52</mn><mo>−</mo><mn>51</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(52)\cdot(52-1)\cdot(52-2)\cdot...\cdot(52-51)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>(</span><span>52</span><span>)</span><span></span><span>⋅</span><span></span></span><span><span></span><span>(</span><span>52</span><span></span><span>−</span><span></span></span><span><span></span><span>1</span><span>)</span><span></span><span>⋅</span><span></span></span><span><span></span><span>(</span><span>52</span><span></span><span>−</span><span></span></span><span><span></span><span>2</span><span>)</span><span></span><span>⋅</span><span></span></span><span><span></span><span>...</span><span></span><span>⋅</span><span></span></span><span><span></span><span>(</span><span>52</span><span></span><span>−</span><span></span></span><span><span></span><span>51</span><span>)</span></span></span></span></span>, which is the same as the factorial of 52, which is shown as <span data-testid="react-katex"><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>52</mn><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">52!</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>52</span><span>!</span></span></span></span></span>. If we evaluate <span data-testid="react-katex"><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>52</mn><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">52!</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>52</span><span>!</span></span></span></span></span> we get around <span data-testid="react-katex"><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn><mo>⋅</mo><msup><mn>10</mn><mn>67</mn></msup></mrow><annotation encoding="application/x-tex">8 \cdot 10^{67}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>8</span><span></span><span>⋅</span><span></span></span><span><span></span><span>1</span><span><span>0</span><span><span><span><span><span><span></span><span><span><span>67</span></span></span></span></span></span></span></span></span></span></span></span></span>. This tells us that the number of bits that can be represented by a deck of cards is <span data-testid="react-katex"><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">⌊</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mn>8</mn><mo>⋅</mo><msup><mn>10</mn><mn>67</mn></msup><mo stretchy="false">)</mo><mo fence="true">⌋</mo></mrow><annotation encoding="application/x-tex">\left\lfloor log_2(8 \cdot 10^{67}) \right\rfloor</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>⌊</span></span><span>l</span><span>o</span><span><span>g</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span>8</span><span></span><span>⋅</span><span></span><span>1</span><span><span>0</span><span><span><span><span><span><span></span><span><span><span>67</span></span></span></span></span></span></span></span></span><span>)</span><span><span>⌋</span></span></span></span></span></span></span>, or <span data-testid="react-katex"><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>225</mn></mrow><annotation encoding="application/x-tex">225</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>225</span></span></span></span></span> bits. But how do we actually store arbitrary bits? We need a one-to one mapping between the order of the cards and the theoretically usable bits. Initial thinking made me believe it could be done by using the color of the cards, because a deck of 52 cards will have 26 black cards and 26 red cards, however that would, in a worst-case scenario, only give you <span data-testid="react-katex"><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>26</mn></mrow><annotation encoding="application/x-tex">26</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>26</span></span></span></span></span> bits, only <span data-testid="react-katex"><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>11.</mn><mover accent="true"><mn>5</mn><mo>˙</mo></mover></mrow><annotation encoding="application/x-tex">11.\dot5</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>11.</span><span><span><span><span><span><span></span><span>5</span></span><span><span></span><span><span>˙</span></span></span></span></span></span></span></span></span></span></span>% of our theoretical limit. I later came across the concept of a <a target="_blank" href="https://en.wikipedia.org/wiki/Lehmer_code">Lehmer code</a>, which allows you to numerically represent each unique permutation of set of elements. The easiest way to compute a Lehmer code is to make each element have its own number or id, and then for each element we count the number of elements to the right of it that are less than it. An animation of this process is below.</p><p><img alt="output" about="Animation of the process of computing a Lehmer code." loading="lazy" width="600" height="400" decoding="async" data-nimg="1" src="https://asherfalcon.com/animation1.gif"/></p><p>Another way to generate a lehmer code is to make a list of all the numbers you have, and for each number, find the index of the number of your list and then remove it. This is not as fast as the first method but its a bit easier to implement. Now that we can turn our deck of 52 cards into a Lehmer code, how can we actually use that to store data? We have our code as a list of cards <span data-testid="react-katex"><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2...51</mn></mrow><annotation encoding="application/x-tex">i=0,1,2 ... 51</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>i</span><span></span><span>=</span><span></span></span><span><span></span><span>0</span><span>,</span><span></span><span>1</span><span>,</span><span></span><span>2...51</span></span></span></span></span> where each card&#39;s code <span data-testid="react-katex"><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">N_i</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>N</span><span><span><span><span><span><span></span><span><span>i</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span> can be in the range <span data-testid="react-katex"><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>51</mn><mo>−</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 51 -i]</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>[</span><span>0</span><span>,</span><span></span><span>51</span><span></span><span>−</span><span></span></span><span><span></span><span>i</span><span>]</span></span></span></span></span>. It is difficult to take that and just store arbitrary data using this array, so we can finally convert it a (very large) denary base10 number. We can do this because this Lehmer code is given to us as a <a target="_blank" href="https://en.wikipedia.org/wiki/Factorial_number_system">factorial number</a>. The factorial number system represents numbers using how many factorial numbers you need to make it. For example, let&#39;s try to turn the denary number 17 into a factorial number. We use the factorial numbers <span data-testid="react-katex"><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>24</mn><mo separator="true">,</mo><mn>120...</mn></mrow><annotation encoding="application/x-tex">1, 1, 2, 6, 24, 120 ...</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>1</span><span>,</span><span></span><span>1</span><span>,</span><span></span><span>2</span><span>,</span><span></span><span>6</span><span>,</span><span></span><span>24</span><span>,</span><span></span><span>120...</span></span></span></span></span> and so if we wanted to make 17 we would use two 6s, two 2s, and one 1, giving us a factoradic of <span data-testid="react-katex"><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>:</mo><mn>2</mn><mo>:</mo><mn>1</mn><mo>:</mo><msub><mn>0</mn><mo stretchy="false">!</mo></msub></mrow><annotation encoding="application/x-tex">2:2:1:0_!</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>2</span><span></span><span>:</span><span></span></span><span><span></span><span>2</span><span></span><span>:</span><span></span></span><span><span></span><span>1</span><span></span><span>:</span><span></span></span><span><span></span><span><span>0</span><span><span><span><span><span><span></span><span><span>!</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span> (Numbers in the factorial system are separated by colons and end with a !). We can convert from this back to decimal in a trivial way by just adding the factorial numbers for each factoradic digit. Some code for converting between decimal and factoradic is below.</p><div><div><center><pre><code><span>
</span><span></span><span>def</span><span> </span><span>convertToFactoradic</span><span>(</span><span>number: </span><span>int</span><span>) -&gt; [</span><span>int</span><span>]:</span><span>
</span>    result = []
<span>    divisor = </span><span>1</span><span>
</span><span>    </span><span>while</span><span>(number &gt; </span><span>0</span><span>):
</span><span>        result.insert(</span><span>0</span><span>, number % divisor)
</span>        number //= divisor
<span>        divisor+=</span><span>1</span><span>
</span><span>    </span><span>return</span><span> result
</span>
<span></span><span>def</span><span> </span><span>convertToDenary</span><span>(</span><span>number: [</span><span>int</span><span>]</span><span>) -&gt; </span><span>int</span><span>:</span><span>
</span><span>    </span><span>global</span><span> factorials
</span><span>    result = </span><span>0</span><span>
</span><span>    numlen = </span><span>len</span><span>(number)
</span><span>    </span><span>for</span><span> i </span><span>in</span><span> </span><span>range</span><span>(numlen):
</span><span>        result += number[i]*factorials[numlen-i-</span><span>1</span><span>]
</span><span>    </span><span>return</span><span> result
</span></code></pre></center></div></div><p>Now we can use this to store huge numbers inside our deck of cards. Shuffle a deck and run its permutation through the Lehmer code process, and then turn its factoradic number into a decimal number, and it will be <b>huge</b>. This is because its storing our 225 bits of data in a number. We have found a way to use <span data-testid="react-katex"><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn></mrow><annotation encoding="application/x-tex">100</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>100</span></span></span></span></span>% of bits we calculated previously. But how can we make this usable? We have 225 bits to play around with and so if we wanted to store alphabetical characters, we could use <span data-testid="react-katex"><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mn>26</mn><mo stretchy="false">)</mo><mo stretchy="false">⌉</mo><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">\lceil log_2(26) \rceil = 5</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>⌈</span><span>l</span><span>o</span><span><span>g</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span>26</span><span>)⌉</span><span></span><span>=</span><span></span></span><span><span></span><span>5</span></span></span></span></span> bits per character, which would leave us with some extra 6 characters. Most important is a space character, and after that I think a full stop is useful. If people want to put domains in there I thought a / slash might be useful. Finally a quotation mark, comma and dash are added to get our 5 bit, 32 symbol character set. With 5 bits per character, our 225 bits can store <span data-testid="react-katex"><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>225</mn><mn>5</mn></mfrac><mo>=</mo><mn>45</mn></mrow><annotation encoding="application/x-tex">\frac{225}{5} = 45</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span></span><span><span><span><span><span><span></span><span><span><span>5</span></span></span></span><span><span></span><span></span></span><span><span></span><span><span><span>225</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span></span></span><span></span><span>=</span><span></span></span><span><span></span><span>45</span></span></span></span></span> characters.</p><div><div><center><pre><code><span>alphabet = </span><span>&#34; .,-\&#34;/abcdefghijklmnopqrstuvwxyz&#34;</span></code></pre></center></div></div><p>In Python converting text to and from a 225 bit number is quite simple and just requires some bitwise operations. Additionally, the function to convert a number to a permutation just requires converting it to a factoradic and then using each digit to index into a list of available elements, removing each element after it is used.</p><div><div><center><pre><code><span>
</span><span></span><span>def</span><span> </span><span>convertToPermutation</span><span>(</span><span>number: </span><span>int</span><span>, permutationElements: </span><span>int</span><span>) -&gt; [</span><span>int</span><span>]:</span><span>
</span><span>    </span><span>global</span><span> factorials
</span><span>    </span><span>if</span><span>(number &gt;= factorials[permutationElements]):
</span><span>        </span><span>raise</span><span> ValueError(</span><span>&#34;Given number is outside of permutation range&#34;</span><span>)
</span>    factoradic = convertToFactoradic(number)
<span>    </span><span>while</span><span> </span><span>len</span><span>(factoradic) &lt; permutationElements:
</span><span>        factoradic.insert(</span><span>0</span><span>,</span><span>0</span><span>)
</span><span>    available = </span><span>list</span><span>(</span><span>range</span><span>(permutationElements))
</span>    permutation = []
<span>    </span><span>for</span><span> i </span><span>in</span><span> factoradic:
</span>        permutation.append(available[i])
<!-- -->        available.pop(i)
<span>    </span><span>return</span><span> permutation
</span>
<span></span><span>def</span><span> </span><span>textToPackOfCards</span><span>(</span><span>text: </span><span>str</span><span>) -&gt; [</span><span>int</span><span>]:</span><span>
</span><span>    </span><span>global</span><span> alphabet
</span><span>    </span><span>if</span><span>(</span><span>len</span><span>(text) &gt; </span><span>45</span><span>):
</span><span>        </span><span>raise</span><span> ValueError(</span><span>&#34;Text must be &lt;=45 characters to be represented in one deck of cards&#34;</span><span>)
</span><span>    </span><span>for</span><span> i </span><span>in</span><span> text.lower():
</span><span>        </span><span>if</span><span> </span><span>not</span><span> i </span><span>in</span><span> alphabet:
</span><span>            </span><span>raise</span><span> ValueError(</span><span>&#34;Text must only be characters A-Z or &#39;., -\&#34;/&#39; in order to use 5bit&#34;</span><span>)
</span><span>    data = </span><span>0</span><span>
</span><span>    </span><span>for</span><span> i </span><span>in</span><span> text.lower():
</span><span>        data&lt;&lt;=</span><span>5</span><span>
</span>        data|=alphabet.index(i)
<span>    data &lt;&lt;= (</span><span>5</span><span>*(</span><span>45</span><span>-</span><span>len</span><span>(text)))
</span><span>    </span><span>return</span><span> convertToPermutation(data, </span><span>52</span><span>)
</span></code></pre></center></div></div><p>The overall process of converting text to a deck of cards is shown below, and the main reason this works to both encode and decode is that each step shown is reversible.</p><p><img alt="output" about="Animation of the process of converting text to a deck of cards." loading="lazy" width="600" height="400" decoding="async" data-nimg="1" src="https://asherfalcon.com/img10.png"/></p><p>I tested it out, and it worked pretty well. One interesting side effect of using Lehmer codes is that if you change a card, all the characters after that card will be affected, and characters before will be fine. I hacked together a website where I ported the functions to c++ and used WebAssembly/Emscripten to make it run in the browser <i>Blazingly Fast 🔥</i>, I also added a simple XOR cipher with a second string of text if you want to &#39;encrypt&#39; your message before it hits the deck, but I think it&#39;s probably not neccesary as no one would suspect that you&#39;ve hidden a 46 character message in your deck of cards! Check it out <a target="_blank" href="https://deckcrypt.github.io/">here</a> and I hope you enjoyed this read. This whole process from thinking of the idea to implementing it was a lot of fun and I&#39;m glad I got to share it with you.If you have any questions or comments, please feel free to reach out to me <a href="https://asherfalcon.com/contact">here</a>.</p></div></div></div></div>
  </body>
</html>
