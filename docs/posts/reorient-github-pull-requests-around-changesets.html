<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mitchellh.com/writing/github-changesets">Original</a>
    <h1>Reorient GitHub pull requests around changesets</h1>
    
    <div id="readability-page-1" class="page"><div><p>I&#39;ve had the experience of
using GitHub as a maintainer for very large open source projects (1000+
contributors), as an engineer for very large closed source corporate projects,
and everything smaller. Through those experiences up to today, GitHub pull
requests is where I spend almost all of my time while on GitHub, and to me its
also unfortunately the most frustrating part of GitHub.</p>
<p>There are a lot of improvements I would love to see with pull requests,
but a massive chunk of my problems would be solved through
one major feature: <strong>changesets</strong>. This blog post describes this suggestion
and what I would love to see.</p>
<div><p><strong>Disclaimer:</strong> My ideas here are not original! I do not claim to have
come up with these ideas. My suggestions here are based on well-explored
Git workflows and also are partially or in full implemented by other
products such as Gerrit, Phabricator, or plain ol&#39; email-based patch
review.</p></div>
<hr/>

<p>The lifecycle of a GitHub pull request today is effectively one giant
mutable changeset. This is a mess!</p>
<p>Here is a typical PR today:
A contributor pushes a set of commits to a branch, opens a PR, and the PR now
represents that branch. People discuss the PR through comments. When the contributor
pushes new changes, they show up directly on the same PR, updating it immediately.
Reviewers can leave comments and the contributor can push changes at the same
time, and it all updates the same PR.</p>
<p>This has many problems:</p>
<ul>
<li>
<p>A reviewer can leave a review for a previous state the PR was in and
it can become immediately outdated because while the review was happening
the contributor pushed changes.</p>
</li>
<li>
<p>Worse, a review can become <em>partially</em> outdated and the
other feedback may not make sense in the context of the changes a
contributor pushed. For example, a line comment may say &#34;same feedback
as the previous comment&#34; but the <em>previous comment is now gone/hidden</em> because
the contributor pushed a change that moved those lines.<sup><a href="#user-content-fn-1" id="user-content-fnref-1" data-footnote-ref="true" aria-describedby="footnote-label">1</a></sup></p>
</li>
<li>
<p>Reviews don&#39;t contain any metadata about the commit they were attached to,
only a timestamp they were submitted. A user can roughly correlate timestamp
to commit but it isn&#39;t totally accurate because if a commit comes in during
a review, the timestamp will seem to imply it was after the most recent
commit but your review may have been against the prior commit. ðŸ˜•</p>
</li>
<li>
<p>Work-in-progress commits towards addressing review feedback become visible
as soon as the branch is pushed. This forces contributors to address all
feedback in a single commit, or for reviewers to deal with partially-addressed
feedback.</p>
</li>
<li>
<p>You can&#39;t easily scrub to prior states of the PR. If you want to review
a set of earlier commits while ignoring later commits, you either have
to manually build a &#34;compare&#34; view or use a local checkout (I do the
latter). But through either approach you only get the code changes,
you don&#39;t also get the point-in-time reviewer feedback!</p>
</li>
<li>
<p>Similar to the above, if a contributor pushes multiple new commits, you
can&#39;t easily compare <em>the new set of commits</em> to the old. You can only
really scrub one commit at a time. For this, you again have to fallback
to local <code>git</code> to build up a diff manually.</p>
</li>
<li>
<p>And more... I talk about some more later, but I think I&#39;ve made my point.</p>
</li>
</ul>
<div><p>I&#39;m sure I&#39;m wrong about some detail about some of the points above.
Someone is likely to say &#34;he could&#39;ve just done <em>this</em> to solve problem
5(a)&#34;. That&#39;s helpful! But, the point I&#39;m trying to make is that if you
step back the fundamentals <em>causing</em> these problems are the real issue.
Namely, a single mutable changeset tracking a branch on a per-commit basis.</p></div>
<hr/>

<p><strong>The solution is changesets:</strong> A pull request is <em>versionable</em>
through a monotonic number (v1, v2, ...).  These versions are often called &#34;changesets.&#34;</p>
<p>Each changeset points to the state of a branch <em>at a fixed time</em>. These
versions are <em>immutable</em>: when new commits are pushed, they become part
of a new changeset. If the contributor force pushes the branch, that also
becomes part of a new changeset. The previous changeset is saved forever.</p>
<p>A new changeset can be published immediately (per commit) or it can be deferred
until the contributor decides to propose a new version for review. The latter
allows a contributor to make multiple commits to address prior feedback and
only publish those changes when they feel ready.</p>
<p>In the world of changesets, feedback is attached to a changeset. If a reviewer
begins reviewing a changeset and a new changeset is published, that&#39;s okay
because the review as an atomic unit is attached to the prior changeset.</p>
<p>In future changesets, it is often useful to denote that a file or line has
unresolved comments in prior changesets. This ensures that feedback on
earlier changesets is not lost and must be addressed before any changeset
is accepted.</p>
<p>Typically, each changeset is represented by a different Git ref. For example,
GitHub pull requests today are usually <code>refs/pr/1234</code> and you can use <code>git</code>
locally to check out any pull request this way. A changeset would be something
like <code>refs/pr/1234/v2</code> (hypothetical) so you can also check out individual
changesets.</p>
<p>Instead of &#34;approving&#34; a PR and merging, reviewers approve a <em>changeset</em>. This
means that the contributor can also post multiple changesets with differing
approaches to a problem <em>in a single PR</em> and the maintainer can potentially
choose a non-latest changeset as the set of changes they want to merge.</p>
<hr/>

<p>Changesets are a well-established pattern across many open source projects
and companies. They&#39;re already a well-explored user experience problem
in existing products like Gerrit and Phabricator. I also believe changesets
can be introduced in a non-breaking way (since current PRs are like
single-mutable-changeset mode).</p>
<p>Changesets would make pull requests so much more scalable for larger
projects and organizations. Besides the scalability, they make the review
process cleaner and safer for both parties involved in pull requests.</p>
<p>Of course, I can only speak for myself and my experience, but this single
major feature would dramatically improve my quality of life and capabilities
while using GitHub<sup><a href="#user-content-fn-2" id="user-content-fnref-2" data-footnote-ref="true" aria-describedby="footnote-label">2</a></sup>.</p>
</div></div>
  </body>
</html>
