<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.kowalczyk.info/article/2f72237a4230410a888acbfce3dc0864/lessons-learned-from-15-years-of-sumatrapdf-an-open-source-windows-app.html">Original</a>
    <h1>Lessons learned from 15 years of SumatraPDF, an open source Windows app (2021)</h1>
    
    <div id="readability-page-1" class="page"><div id="2f72237a-4230-410a-888a-cbfce3dc0864">
  <p>I released first version of <a href="https://www.sumatrapdfreader.org/free-pdf-reader">SumatraPDF</a> in 2006. That&#39;s 15 years ago which seems like a good time for a retrospective.
  </p>
  <h2 id="f14f9454-6c60-44a1-91b6-ee1600f252c0">The app
  </h2>
  <p>SumatraPDF is a multi-format (PDF, ePub, Mobi, comic book, DjVu, XPS, CHM) viewer for Windows and currently looks like this:
  </p>
<p><img src="https://blog.kowalczyk.info/img/983eae4f6a4cbd89dd91ae7df84663081bbda06d.png"/></p><h2 id="72d4309c-2183-45d7-a698-43ad3d13aeac">The code
  </h2>
  <p>SumatraPDF is an open-source document reader for Windows. It started as a PDF reader, hence the name. Over time I&#39;ve added for e-book formats (epub, mobi), comic books (cbz, cbr), DjVu, XPS, image formats etc.
  </p>
  <p>It&#39;s about 127k lines of C++ (not counting libraries written by others).
  </p>
  <p>It&#39;s written against Win32 API, not using GUI abstraction libraries like Qt. This contributes to making it as small and fast as possible.
  </p>
  <p>Almost all of it was written by 2 people, with occasional contributions from others.
  </p>
  <p>The amount of code written is actually higher. It is the nature of long running code bases that the code gets written and re-written. We delete, add, change.
  </p>
  <p>It&#39;s a side project, done after hours, not a full time effort. How does a daily grind of working on an app looks like?
  </p>
  <p>It looks like this:
  </p>
<p><img src="https://blog.kowalczyk.info/img/251a5dbb72a41441d87187a4379b4b6532ff5506.png"/></p><p>You can also take a peek at <a href="https://github.com/sumatrapdfreader/sumatrapdf/blob/master/src/docs/log.txt">my dev log</a>. I&#39;ve only started it a year ago so only covers 1 year out of 15.
  </p>
  <h2 id="9a283ffc-9feb-47d9-9e98-494a7eb65a37">Why I created SumatraPDF
  </h2>
  <p>SumatraPDF is what I call an accidental success.
  </p>
  <p>I never wanted to write a PDF reader for Windows. 
  </p>
  <p>In 2006 I was working at Palm and one of my job duties was writing a PDF reader for <a href="https://en.wikipedia.org/wiki/Palm_Foleo">Foleo</a>, an ARM and Linux powered mini laptop. You never heard of Foleo because it was cancelled weeks before launch for reasons I&#39;m not privy to.
  </p>
  <p>At the time I didn&#39;t know that PDF is popular but Palm management did which is why they decided that PDF reader is a must have application. I ended up being the (sole) dev on the project.
  </p>
  <p>Writing a PDF rendering library is a multi-year effort. We didn&#39;t have years so I used <a href="https://poppler.freedesktop.org/">Poppler</a> open-source library.
  </p>
  <p>My job was to write a basic PDF viewer that used Poppler to render PDF pages into a bitmap in memory and blit those bitmap on screen.
  </p>
  <p>PDF is a complex format and rendering of some PDFs is slow. I wanted to improve the speed because Jeff Bezos told me that speed is something that customers will always care about.
  </p>
  <h2 id="062b2b16-3f7b-4166-9b4c-b751f066f544">Accidental app
  </h2>
  <p>The way to improve speed is to profile the code and look at the result. 
  </p>
  <p>Unfortunately, the toolchain for unreleased ARM hardware wasn&#39;t very good. Forget about a profiler, kid, be grateful you have a C++ compiler and don&#39;t have to enter assembly by typing hex, like Steve Wozniak.
  </p>
  <p>Windows had decent profilers, so I compiled Poppler for Windows.
  </p>
  <p>Once I had the library working on Windows, I wrote simplest GUI app that would show the pages and allow navigating between pages.
  </p>
  <p>What do you know: I had a simple PDF reader for Windows. 
  </p>
  <p>I released it on my website. It couldn&#39;t do much so I tagged it as version 0.1.
  </p>
<blockquote id="01543cae-8dec-4828-adac-cd2e8546a162">If you&#39;re not embarrassed by your app then you&#39;ve waited too long to release it
</blockquote>
  <p>I didn&#39;t come up with this nugget of wisdom but I agree with it. 
  </p>
  <p>Getting early users, learning what features they want the most beats toiling for months or years and implementing lots of features before you know anyone even cares.
  </p>
  <h2 id="13d06b9c-a635-4d02-a21f-7ff329b23139">Profiling, performance optimization and contributing to open source
  </h2>
  <p>Back to profiling: my plan worked.
  </p>
  <p>I profiled the documents that took the longest to render and made a few surprisingly simple and surprisingly effective optimizations.
  </p>
  <p>If memory servers, 2 optimizations had the biggest effect:
  </p>
  <ul id="c3160200-6701-4bc5-9b64-96c0f4ce4885">
    <li>optimizing string class to use what is know as &#34;small string optimization&#34; i.e. adding a small buffer inside string class to hold small strings inline (as opposed to always allocating memory for the string). Strings were used frequently and most of them were small
    </li>
    <li>fixing byte-at-a-time i/o by converting it to bulk reads. The way the code was structured in some code-paths it would do a virtual C++ call and a call to C read() function for each byte. Those are extremely cheap but not when you do it 5 million times
    </li>
  </ul>
  <p>As a good boy I did submit my changes to Poppler.
  </p>
  <p>As is my experience with contributing to open source projects, it was more of a miss than a hit.
  </p>
  <p>Yes, I got 13 commits in but the project wasn&#39;t very active and the maintainers weren&#39;t eager to accept anything beyond small changes. Forget any major refactors.
  </p>
  <p>I&#39;m not one to voluntarily bash my head against the wall so I stopped trying.
  </p>
  <p>(As you can see, I&#39;m a fantastic team player).
  </p>
  <h2 id="16cb5f36-b1c4-471c-8bb1-27029d8af9af">Code quality
  </h2>
  <p>I want it and you should want it to.
  </p>
  <p>How to maintain high code quality while working mostly solo, with no-one doing code reviews, no dedicated QA team?
  </p>
  <p>Here&#39;s how:
  </p>
  <ul id="d471f5af-aca0-4556-ac8d-35616d8a7472">
    <li>test the code yourself. Step through newly added code in the debugger, verify the newly added functionality works as expected and in general use the app a lot
    </li>
    <li>automated crash reporting. Unfortunately it&#39;s a pain to build but this is single most important thing you can do to improve quality of your software. Briefly: setup exception handlers to catch crashes in the app, in crash handler download symbols from the server to get readable callstack, create a crash report that includes callstacks of all thread, program and os information, log and submit that to a server. On the server, process those files and generate web pages for easy viewing of the crashes. Like I said: it&#39;s a pain to build. Once you have crashes, look at them occasionally and try to figure out what went wrong and fix it
    </li>
    <li><code>assert()</code>. asserts are well established practice in C++ code: an additional code only executed in debug builds that verifies some conditions are true. If they&#39;re not, something went wrong and you should investigate. I wrote wrote my own <code>assert</code>-like function which I enable in non-debug pre-release builds so that I automatically get bug reports from people hitting those conditions. Trust me: there&#39;s no amount of testing you can do yourself that would match all the different things that a thousand people will do just by using the app.
    </li>
    <li>logging. When investigating issues it helps to know what sequence of events led to a crash. My tiny logging module logs to a block of memory. That gets sent along with crash report. I also have an option to log to a file and I&#39;ve recently added logging to a separate logging app via named pipe. This is perfect because most of the time I don&#39;t care about the logs but when I do, I don&#39;t want to restart the app to enable logging. With separate logging app, SumatraPDF is logging all the time and when it detects that logging app is running, it&#39;ll also log to it. Implementation was trivial: logging app creates a named pipe, logger opens the pipe (like a file) and if open succeeds, it means the logger app is running and it reads the logs we write to the pipe
    </li>
    <li>static code analysis: max level of warnings in C++ compiler, make warnings into errors, Visual Studio&#39;s `/analyze&#39; option, cppcheck, clang-tidy, GitHub&#39;s CodeQL. Run those occasionally and fix the errors and warnings
    </li>
    <li>ASAN (<a href="https://clang.llvm.org/docs/AddressSanitizer.html">Address Sanitizer</a>), is fantastic. Was added in some point release of Visual Studio 2019. At a very small performance cost it can detect if you over-write memory or try to read uninitialized memory. I have a configuration with ASAN enabled. It&#39;s fast enough to be used as a regular build.
    </li>
    <li>stress testing. Sumatra&#39;s job is mostly to render complex document format. There often are crashes in specific files due to complexity of the formats. To ensure lack of crashes I wrote a stress test code that reads and renders all files in a directory. I typically run it before a release on a large collection of test files I amassed over the years
    </li>
    <li>unit testing. I don&#39;t have a lot of them, they&#39;re mostly for testing edge cases for low-level functionality like string formatting. They occasionally find bugs.
    </li>
    <li>memory leaks. It&#39;s surprisingly hard to find an easy to use memory leak detection tool. I&#39;m working on a very simple built-in leak detector. In the meantime I&#39;m using <a href="https://drmemory.org/">Dr. Memory</a>. It works but it&#39;s super slow.
    </li>
  </ul>
  <h2 id="4fe2c16b-c275-4a33-992e-a2d78d1f6ac6">Frequent releases
  </h2>
  <p>When you don&#39;t have many features, improving the app is fast and easy. It doesn&#39;t take much effort to implement &#34;Go to&#34; dialog (implemented in v 0.2).
  </p>
  <p>On one hand I don&#39;t want to release too often but I also do want the users to get new features as quickly as possible.
  </p>
  <p>My policy of new releases is: release when there&#39;s at least one notable, user-visible improvement.
  </p>
  <p>Web apps take it to the extreme (some companies deploy to production multiple times a day).
  </p>
  <p>In desktop software it&#39;s a bit more involved and I had to build functionality to make it easy i.e. add a check for new releases, write an installer that can update the program.
  </p>
  <p>BTW: I mean &#34;frequent in proportion to amount of new code written&#34;. SumatraPDF releases are not frequent in absolute terms but frequent if you consider that it&#39;s a part-time, after hours project.
  </p>
  <h2 id="4cb762ea-5006-4045-9523-17d65acfe328">Treat open source projects like commercial software
  </h2>
  <p>Majority of open source projects probably don&#39;t fall into this category, but if you want your open source to be as successful as possible, act as if it was a commercial product from a software company.
  </p>
  <p>What does it mean in practice?
  </p>
  <p>From day one I created a website for the app. It had screenshots, it had documentation, it was easy to download and install. Granted, a kind soul on Reddit called it &#34;a website made by a 6-year old&#34;. The lesson here is two-fold:
  </p>
  <ul id="c9cd8864-16ff-4ab3-9379-3e5296f6bbc7">
    <li>ignore haters and assholes
    </li>
    <li>a website built by a 6-year old is better than no website. It doesn&#39;t have to be pretty, it has to be functional
    </li>
  </ul>
  <p>I did basic SEO. Nothing beyond Google&#39;s &#34;SEO 101&#34; docs: just pay attention to URLs, put the right meta-data, use the right keywords.
  </p>
  <p>I had a forum for users to ask questions, submit feature requests and occasionally support each other.
  </p>
  <p>I made the installation process as easy as possible.
  </p>
  <p>Everything that is a good idea for promoting commercial software is also a good idea for open source project.
  </p>
  <h2 id="f4772aab-4102-468d-9091-6c1a29cc0115">Switching the engine while the car is running
  </h2>
  <p>At some point I decided to switch from Poppler to <a href="https://mupdf.com/">mupdf</a> because mupdf was better and actively maintained.
  </p>
  <p>Changing the app to use completely different library is not something you can do in an afternoon.
  </p>
  <p>It&#39;s demoralizing to work long time on code that doesn&#39;t even compile.
  </p>
  <p>To keep things compiling while also working towards supporting alternative rendering engine I developed an abstraction for the rendering engine.
  </p>
  <p>The engine would provide the functionality the UI needed: getting number of pages in the document, sizes of each page (to calculate layout), rendering a page as a bitmap etc.
  </p>
  <p>I&#39;m much less enthusiastic about abstractions than most programmers (at least those who like to opine on Hacker News) but in this case it served me well.
  </p>
  <p>I was able to incrementally convert program form using Poppler API to using Poppler via engine abstraction to using mupdf via Engine abstraction.
  </p>
  <p>For a while I supported both engines at the same time but eventually I switched to just mupdf, to keep the app small.
  </p>
  <p>This opened the door for supporting other formats via the same abstraction.
  </p>
  <h2 id="f2ca367f-280d-4855-88ab-06a5461e2cb8">Simplicity vs. customizability
  </h2>
  <p>Simplicity sells.
  </p>
  <p>I learned that from the history of Mozilla Firefox.
  </p>
  <p>Before Firefox there was Netscape Navigator. It was a beast of an app, combining web browser with e-mail client.
  </p>
  <p>Netscape couldn&#39;t help themselves and was adding features upon features, leading to very complex UI.
  </p>
  <p>A small group of renegades within Mozilla forked the code and focused on simple UI.
  </p>
  <p>Simple Firefox was much more popular than the complex Navigator and eventually ate it completely.
  </p>
  <p>From the beginning my goal was to keep the UI of SumatraPDF as simple as possible. An 80/20 app: 80% of functionality with 20% of the UI.
  </p>
  <p>This requires resolve. I constantly get requests to add more icons to the toolbar and I constantly have to say &#34;no&#34; because adding 2 more icons to the toolbar to satisfy 10% of users makes the app slightly worse for 100% of the users.
  </p>
  <p>Another trap is a siren song of additional settings. Sometimes people suggest that instead of doing X, the program should do Y. Not willing to remove X, they suggest adding a new UI setting &#34;[ ] Do Y instead of X&#34;.
  </p>
  <p>Having settings dialog with 100 settings is not a good solution. It makes the app worse for everyone due to overwhelming them with choices and hiding important options in a sea of non-important options.
  </p>
  <p>Not to mention that every conditional behavior requires more code, more potential bugs and more testing.
  </p>
  <p>That being said, I also believe customizability is important. I believe that a big reason for Winamp being such a dominant music player (at the time) was its ability to skin the whole UI.
  </p>
  <p>Some advanced features might only be used by 20% of users but those users are most likely power users that will evangelize the app more than the other 80% of the users.
  </p>
  <p>My solution to UI simplicity vs. customizability: advanced settings file.
  </p>
  <p>I designed a simple, human readable (and human writeable) textual format for <a href="https://www.sumatrapdfreader.org/settings/settings">advanced settings</a>. Think JSON, but better.
  </p>
  <p>I didn&#39;t bother to write UI for changing those advanced settings. I just launch notepad.exe with the file. When user changes the settings and saves the file, I reload it and apply the changes.
  </p>
  <h2 id="25a53576-5322-4848-b859-47ae59927c9d">Be water, my friend
  </h2>
  <p>Change is the only constant. We must adapt to the changes in the world.
  </p>
  <p>I can&#39;t believe how many popular projects still use craptastic Sourceforge for source repository or mailing list.
  </p>
  <p>Actually, I can believe: changing things takes effort and the path of least resistance is to do nothing.
  </p>
  <p>I started with Sourceforge, switched to code.google.com and then to github.com.
  </p>
  <p>I switched forum software three times.
  </p>
  <p>I&#39;ve added a browser plugin and then removed it when browsers stopped supporting such plugins.
  </p>
  <p>I changed the format for storing preferences from binary to human readable text.
  </p>
  <p>Windows XP went from being the OS used by majority of users to no longer being supported (long after Microsoft stopped supporting it).
  </p>
  <p>At first I only had 32-bit build and now I have both but emphasize 64-bit builds.
  </p>
  <h2 id="037fe291-5491-4e0c-94c7-3bf69db1b9aa">Think outside of the box
  </h2>
  <p>Thinking outside of the box is hard because the box is invisible.
  </p>
  <p>SumatraPDF wasn&#39;t the first PDF reader application ever written.
  </p>
  <p>But most PDF readers do not become multi-format readers.
  </p>
  <p>In hindsight it&#39;s an obvious idea to support as many document formats as possible but it took me 5 years to realize it.
  </p>
  <p>Most readers are still single format and I do believe being multi-format helped SumatraPDF become popular.
  </p>
  <p>I can&#39;t say it&#39;s totally unique idea. There were multi-format image viewers long before SumatraPDF and I probably was inspired by them.
  </p>
  <h2 id="78d5c807-4bb8-4601-98bf-5e635b5d1ce5">Small and fast - pick both
  </h2>
  <p>By today&#39;s standards SumatraPDF is tiny (installer smaller than 10 MB) and starts up instantly.
  </p>
  <p>I believe being small and seemingly fast was a big reason for adoption.
  </p>
  <p>This comes back to Jeff Bezos&#39; wisdom: there will never be a time when users want bloated and slow apps so being small and fast is a permanent advantage.
  </p>
  <p>How do I keep SumatraPDF small?
  </p>
  <p>I avoid unnecessary abstractions. Window&#39;s system of controls is a giant pain in the ass to program against. I could use wrappers like Qt, WxWindows or Gtk. They are easier to use but cause instant, giant bloat.
  </p>
  <p>I&#39;m not afraid to write my own implementation of things. I have my own JSON, HTML / XML parsers that are a fraction of size of the popular libraries for those tasks.
  </p>
  <p>I aggressively take advantage of rich functionality included in Windows.
  </p>
  <p>Let&#39;s say I need to do a network request. I could include a monster library like curl or I could write 300 lines of code using win32 APIs. I wrote 300 lines of code.
  </p>
  <p>An absence of bloat is hard to notice because it isn&#39;t there.
  </p>
  <p>My pet peeve is over-using XML for storing data.
  </p>
  <p>When I worked at Palm I was at a design meeting for auto-update system for a phone. Part of it was storing information about the current version in the image, downloading information about the latest version and comparing them.
  </p>
  <p>The developer decided to use XML for storing that information. That seemed like a lot of bloat for storing simple information like a version number. An compliant XML parser alone is a lot of code. Surely a simple binary format would be easier to implement, I suggested and was ignored.
  </p>
  <p>If you don&#39;t have the power to fire someone, your ideas will be ignored.
  </p>
  <p>(As you can see, I&#39;m a great team player.)
  </p>
  <p>For storing advanced settings I designed and implemented a file format that is smaller than XML, readable and writeable by humans and can be implemented in few hundred lines of code. It&#39;s as powerful as JSON and even more readable.
  </p>
  <p>It&#39;s so simple that after implementing it I had the time to implement a serialization system for C++ objects and a Go code generator. To add more settings I don&#39;t have to write more C++ code. I just add data definition to Go generator, re-run it and get data-driven C++ parsing auto-generated.
  </p>
  <h2 id="7eca9313-98ff-44cd-be4c-ee4250ffc76d">It&#39;s my project and I act like it
  </h2>
  <p>When someone pays you to write code you have to do it the way they like it.
  </p>
  <p>A big attraction of working on code you&#39;re not paid for is that there is no one who can tell you what to do or how to do it.
  </p>
  <p>My code would not pass a code review at Google and not because it&#39;s bad but because it&#39;s often unorthodox. Outside of accepted dogma.
  </p>
  <p>(As you can see, I&#39;m a great team player.)
  </p>
  <p>I always used SumatraPDF as my playground for testing crazy ideas.
  </p>
  <p>Minimize the code size by not using STL? That&#39;s crazy but I did it. Granted, in 2006 STL wasn&#39;t very good.
  </p>
  <p>I learned about how Plan 9 C code had non-traditional scheme of #include files where they don&#39;t put #ifdef wrappers in each .h file to allow multiple inclusion and .h files don&#39;t include other .h files. As a result .c files have to include every .h file they need and in the right order. It&#39;s a bit of a pain and no other modern C++ codebase I know of maintains such discipline.
  </p>
  <p>But it&#39;s my project so I did it and I keep doing it. It prevents circular dependencies between .h files and doesn&#39;t inflate C++ build times because of careless including the same files over and over again.
  </p>
  <p>I implemented a CSS inspired UI system. Not great, but mine. And I plan to replace with a different one. 
  </p>
  <p>Because I can. 
  </p>
  <p>Because no one can tell me not to.
  </p>
  <h2 id="7be74119-9e25-4e3b-b5e6-93aa45050560">Cross-platform is over-rated
  </h2>
  
  <p>Supporting other platforms (Linux, Mac, Android) is one of the most frequent requests. A request that I have to decline.
  </p>
  <p>First, there is a pragmatic reason: I just don&#39;t have the bandwidth to write code for 3 platforms.
  </p>
  <p>Second, I believe an excellent app for one platform can become more popular than a mediocre app for 3 platforms.
  </p>
  <p>Coming back to the first reason: I don&#39;t have the bandwidth to write 3 excellent apps. Part of the reason SumatraPDF is small is my use of win32 APIs for the UI.
  </p>
  <p>The only way for one person to even attempt cross-platform app is to use a UI abstraction layer like Qt, WxWidgets or Gtk.
  </p>
  <p>The problem is that Gtk is ugly, Qt is extremely bloated and WxWidgets barely works.
  </p>
  <h2 id="3282ad25-f57c-4e17-aec3-6db8ad7d6e49">Tests are not necessary, neither are code reviews
  </h2>
  <p>I&#39;m not saying tests are bad or that you shouldn&#39;t write test or do code reviews.
  </p>
  <p>I&#39;m saying that they are not necessary.
  </p>
  <p>Dogma is powerful. Sometimes in my corporate life I felt like writing tests was just going through motion. Maybe we should spend more time writing code instead, I though?
  </p>
  <p>But try to make a nuanced point about more tests vs. more code to your fellow developers and you&#39;ll be burned at stake and your smoldering carcass will be thrown to wild dogs. Village children will use your severed head to play soccer.
  </p>
  <p>(As you can see, I&#39;m a great team player.)
  </p>
  <p>And yet I do know that you can write complex, relatively bug free code without tests, because I did it.
  </p>
  <p>I do know that you can write complex, relatively bug free code without anyone looking over your code, because I did it.
  </p>
  <p>If no one uses your app then who cares if it crashes.
  </p>
  <p>If many people use your app and it crashes, they&#39;ll tell you and then you&#39;ll fix it.
  </p>
  <h2 id="888eaae0-0148-4dc5-b18c-cd78e89ac4bc">Overnight success takes a decade
  </h2>
  <p>SumatraPDF is relatively popular. Not Facebook popular or DOOM popular, but more popular than most apps. A respectable level of popular.
  </p>
  <p>It all started with v 0.1 and a trickle of downloads. It remained a trickle for many, many months.
  </p>
  <p>I&#39;m not sure there&#39;s a lesson here.
  </p>
  <p>Success often takes a long time. 
  </p>
  <p>Unfortunately, at that stage it&#39;s undistinguishable from (eventual) failure so this wisdom doesn&#39;t help you if you&#39;re working on a not-yet-successful project and debating if you should continue or abandon
  </p>
  <h2 id="d89f087c-968e-4b77-8342-e36cafab2c7e">The money
  </h2>
  <p>Open source is not a good business model.
  </p>
  <p>If you want to make money do literally anything else: try to sell software, do consulting, build a SAAS and charge monthly for it, rob a bank.
  </p>
  <p>I did experiment with making money and made some.
  </p>
  <p>There was a time AdSense would pay decent CPM so I put AdSense ads on the website and it made some money. I no longer do because the rates did plummet and it isn&#39;t worth annoying people. My soul has a price and AdSense can no longer afford it.
  </p>
  <p>Now I&#39;m experimenting with Patreon and Paypal donations. It makes more than $100 a month but not much more than that.
  </p>
  <p>Like I said: don&#39;t start open source project with intent to make money.
  </p>
  <p>Rarely you can have both: freedom to do whatever you want and a good pay so pick what is more important to you. Open source gives you freedom but not money.
  </p>
  <h2 id="3a635c7a-807d-4f2f-966b-f55efac43848">On to the future
  </h2>
  <p>I need to continue being like water.
  </p>
  <p>For years I resisted adding editing features. &#34;It&#39;s just a reader&#34; I said. But why not add editing? If people want it, give it to them.
  </p>
  <p>The future of all software is as a web app. Why not bring the spirit of SumatraPDF to the web?
  </p>
  <p>Those are just a few ideas I have today.
  </p>
  <p>Being like water means that in 5 years I&#39;ll have other ideas, informed by what&#39;s happening at that time.
  </p>
</div></div>
  </body>
</html>
