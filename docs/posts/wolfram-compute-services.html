<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://writings.stephenwolfram.com/2025/12/instant-supercompute-launching-wolfram-compute-services/">Original</a>
    <h1>Wolfram Compute Services</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p><img title="Instant Supercompute: Launching Wolfram Compute Services" src="https://content.wolfram.com/sites/43/2025/11/sw11252025heroimg1.png" alt="Instant Supercompute: Launching Wolfram Compute Services" width="620" height="540"/></p>
<div id="gpt-stripe">
<p>To immediately enable Wolfram Compute Services in Version 14.3 Wolfram Desktop systems, run</p>
<div data-c2c-file="https://content.wolfram.com/sites/43/2025/12/sw12022025banner-2img1_copy.txt" data-c2c-type="text/html" id="writtings-c2c_above"><tt>RemoteBatchSubmissionEnvironment[&#34;WolframBatch&#34;]</tt><p>.</p></div>
<p>(The functionality is automatically available in the <a href="https://www.wolfram.com/cloud/">Wolfram Cloud</a>.)</p>
</div>
<h2 id="scaling-up-your-computations">Scaling Up Your Computations</h2>
<p>Let’s say you’ve done a computation in <a href="https://www.wolfram.com/language/">Wolfram Language</a>. And now you want to scale it up. Maybe 1000x or more. Well, <a href="https://www.wolfram.com/compute-services/">today we’ve released</a> an extremely streamlined way to do that. Just wrap the scaled up computation in <tt><a href="http://reference.wolfram.com/language/ref/RemoteBatchSubmit.html">RemoteBatchSubmit</a></tt> and off it’ll go to our new <a href="https://www.wolfram.com/compute-services/">Wolfram Compute Services system</a>. Then—in a minute, an hour, a day, or whatever—it’ll let you know it’s finished, and you can get its results.</p>
<p>For decades I’ve often needed to do big, crunchy calculations (<a href="https://writings.stephenwolfram.com/all-by-date/">usually for science</a>). With large volumes of data, millions of cases, rampant <a href="https://www.wolframscience.com/nks/chap-12--the-principle-of-computational-equivalence#sect-12-6--computational-irreducibility">computational irreducibility</a>, etc. I probably have more compute lying around my house than most people—these days about 200 cores worth. But many nights I’ll leave all of that compute running, all night—and I still want much more. Well, as of today, there’s an easy solution—for everyone: just seamlessly send your computation off to Wolfram Compute Services to be done, at basically any scale.</p>
<p>For nearly 20 years we’ve had built-in functions like <tt><a href="http://reference.wolfram.com/language/ref/ParallelMap.html">ParallelMap</a></tt> and <tt><a href="http://reference.wolfram.com/language/ref/ParallelTable.html">ParallelTable</a></tt> in Wolfram Language that make it immediate to parallelize subcomputations. But for this to really let you scale up, you have to have the compute. Which now—thanks to our new Wolfram Compute Services—everyone can immediately get.<span id="more-71678"></span></p>
<p>The <a href="https://reference.wolfram.com/language/guide/RemoteBatchJobs.html">underlying tools</a> that make Wolfram Compute Services possible have existed in the Wolfram Language for several years. But what Wolfram Compute Services now does is to pull everything together to provide an extremely streamlined all-in-one experience. For example, let’s say you’re working in a notebook and building up a computation. And finally you give the input that you want to scale up. Typically that input will have lots of dependencies on earlier parts of your computation. But you don’t have to worry about any of that. Just take the input you want to scale up, and feed it to <tt>RemoteBatchSubmit</tt>. Wolfram Compute Services will automatically take care of all the dependencies, etc. </p>
<p>And another thing: <tt>RemoteBatchSubmit</tt>, like every function in Wolfram Language, is dealing with symbolic expressions, which can represent anything—from numerical tables to images to graphs to user interfaces to videos, etc. So that means that the results you get can immediately be used, say in your Wolfram Notebook, without any importing, etc.</p>
<p>OK, so what kinds of machines can you run on? Well, Wolfram Compute Services gives you a <a href="https://www.wolfram.com/compute-services/#machine-instance-categories">bunch of options</a>, suitable for different computations, and different budgets. There’s the most basic 1 core, 8 GB option—which you can use to just “get a computation off your own machine”. You can pick a machine with larger memory—currently up to about 1500 GB. Or you can pick a machine with more cores—currently up to 192. But if you’re looking for even larger scale parallelism Wolfram Compute Services can deal with that too. Because <tt><a href="http://reference.wolfram.com/language/ref/RemoteBatchMapSubmit.html">RemoteBatchMapSubmit</a></tt> can map a function across any number of elements, running on any number of cores, across multiple machines. </p>
<h2 id="a-simple-example">A Simple Example</h2>
<p>OK, so here’s a very simple example—that happens to come from <a href="https://writings.stephenwolfram.com/2023/11/aggregation-and-tiling-as-multicomputational-processes/#polygonal-shapes">some science I did a little while ago</a>. Define a function <tt>PentagonTiling</tt> that randomly adds nonoverlapping pentagons to a cluster:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2025/11/sw11252025simpleimg1.png" alt="" title="" width="407" height="74"/> </p>

<p>For 20 pentagons I can run this quickly on my machine:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2025/11/sw11252025simpleimg2.png" alt="" title="" width="205" height="153"/> </p>

<p>But what about for 500 pentagons? Well, the computational geometry gets difficult and it would take long enough that I wouldn’t want to tie up my own machine doing it. But now there’s another option: use Wolfram Compute Services!</p>
<p>And all I have to do is feed my computation to <tt>RemoteBatchSubmit</tt>:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2025/11/sw11252025simpleimg3.png" alt="" title="" width="600" height="108"/> </p>

<p>Immediately, a job is created (with all necessary dependencies automatically handled). And the job is queued for execution. And then, a couple of minutes later, I get an email: </p>
<p><img src="https://content.wolfram.com/sites/43/2025/11/sw11252025simpleimg4.png" alt="Email confirming batch job is starting" title="Email confirming batch job is starting" width="360" height="287"/></p>
<p>Not knowing how long it’s going to take, I go off and do something else. But a while later, I’m curious to check how my job is doing. So I click the link in the email and it takes me to a dashboard—and I can see that my job is successfully running:</p>
<p><img src="https://content.wolfram.com/sites/43/2025/11/sw11252025simpleimg5.png" alt="Wolfram Compute Services dashboard" title="Wolfram Compute Services dashboard" width="619" height="295"/></p>
<p>I go off and do other things. Then, suddenly, I get an email:</p>
<p><img src="https://content.wolfram.com/sites/43/2025/11/sw11252025simpleimg6.png" alt="Email confirming batch job success" title="Email confirming batch job success" width="611" height="657"/></p>
<p>It finished! And in the mail is a preview of the result. To get the result as an expression in a Wolfram Language session I just evaluate a line from the email: </p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2025/11/sw11252025simpleimg7.png" alt="" title="" width="673" height="380"/> </p>

<p>And this is now a computable object that I can work with, say computing areas</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2025/11/sw11252025simpleimg8.png" alt="" title="" width="322" height="43"/> </p>

<p>or counting holes:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2025/11/sw11252025simpleimg9.png" alt="" title="" width="293" height="93"/> </p>

<h2 id="large-scale-parallelism">Large-Scale Parallelism</h2>
<p>One of the great strengths of Wolfram Compute Services is that it makes it easy to use large-scale parallelism. You want to run your computation in parallel on hundreds of cores? Well, just use Wolfram Compute Services! </p>
<p>Here’s an example that came up in some recent work of mine. I’m searching for a cellular automaton rule that generates a pattern with a “lifetime” of exactly 100 steps. Here I’m testing 10,000 random rules—which takes a couple of seconds, and doesn’t find anything:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2025/11/sw11252025largeimg1.png" alt="" title="" width="516" height="91"/> </p>

<p>To test 100,000 rules I can use <tt><a href="http://reference.wolfram.com/language/ref/ParallelSelect.html">ParallelSelect</a></tt> and run in parallel, say across the 16 cores in my laptop:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2025/11/sw11252025largeimg2.png" alt="" title="" width="516" height="91"/> </p>

<p>Still nothing. OK, so what about testing 100 million rules? Well, then it’s time for Wolfram Compute Services. The simplest thing to do is just to submit a job requesting a machine with lots of cores (here 192, the maximum currently offered): </p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2025/11/sw11252025largeimg3.png" alt="" title="" width="660" height="179"/> </p>

<p>A few minutes later I get mail telling me the job is starting. After a while I check on my job and it’s still running:</p>
<p><img src="https://content.wolfram.com/sites/43/2025/11/sw11252025largeimg4.png" alt="Email confirming batch job is starting" title="Email confirming batch job is starting" width="360" height="287"/></p>
<p>I go off and do other things. Then, after a couple of hours I get mail telling me my job is finished. And there’s a preview in the email that shows, yes, it found some things:</p>
<p><img src="https://content.wolfram.com/sites/43/2025/11/sw11252025largeimg5.png" alt="Email confirming batch job success" title="Email confirming batch job success" width="360" height="461"/></p>
<p>I get the result:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2025/11/sw11252025largeimg6.png" alt="" title="" width="684" height="115"/> </p>

<p>And here they are—rules plucked from the hundred million tests we did in the computational universe:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2025/11/sw11252025largeimg7.png" alt="" title="" width="518" height="244"/> </p>

<p>But what if we wanted to get this result in less than a couple of hours? Well, then we’d need even more parallelism. And, actually, Wolfram Compute Services lets us get that too—using <tt>RemoteBatchMapSubmit</tt>. You can think of <tt>RemoteBatchMapSubmit</tt> as a souped up analog of <tt>ParallelMap</tt>—mapping a function across a list of any length, splitting up the necessary computations across cores that can be on different machines, and handling the data and communications involved in a scalable way. </p>
<p>Because <tt>RemoteBatchMapSubmit</tt> is a “pure <tt><a href="http://reference.wolfram.com/language/ref/Map.html">Map</a></tt>” we have to rearrange our computation a little—making it run 100,000 cases of selecting from 1000 random instances:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2025/11/sw11252025largeimg8.png" alt="" title="" width="630" height="219"/> </p>

<p>The system decided to distribute my 100,000 cases across 316 separate “child jobs”, here each running on its own core. How is the job doing? I can get a dynamic visualization of what’s happening:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2025/11/sw11252025largeimg9.png" alt="" title="" width="359" height="225"/> </p>

<p>And it doesn’t take many minutes before I’m getting mail that the job is finished:</p>
<p><img src="https://content.wolfram.com/sites/43/2025/11/sw11252025largeimg12.png" alt="Email providing job details" title="Email providing job details" width="454" height="430"/></p>
<p>And, yes, even though I only had to wait for 3 minutes to get this result, the total amount of computer time used—across all the cores—is about 8 hours. </p>
<p>Now I can retrieve all the results, using <tt><a href="http://reference.wolfram.com/language/ref/Catenate.html">Catenate</a></tt> to combine all the separate pieces I generated:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2025/11/sw11252025large-aimg1.png" alt="" title="" width="503" height="267"/> </p>

<p>And, yes, if I wanted to spend a little more, I could run a bigger search, increasing the 100,000 to a larger number; <tt>RemoteBatchMapSubmit</tt> and Wolfram Compute Services would seamlessly scale up.</p>
<h2 id="its-all-programmable">It’s All Programmable!</h2>
<p>Like everything around Wolfram Language, Wolfram Compute Services is fully programmable. When you submit a job, there are lots of options you can set. We already saw the option <tt><a href="https://reference.wolfram.com/language/ref/RemoteMachineClass.html">RemoteMachineClass</a></tt> which lets you choose the type of machine to use. Currently the choices range from <tt>&#34;</tt><span>Basic1x8</span><tt>&#34;</tt> (1 core, 8 GB) through <tt>&#34;</tt><span>Basic4x16</span><tt>&#34;</tt> (4 cores, 16 GB) to “parallel compute” <tt>&#34;</tt><span>Compute192x384</span><tt>&#34;</tt> (192 cores, 384 GB) and “large memory” <tt>&#34;</tt><span>Memory192x1536</span><tt>&#34;</tt> (192 cores, 1536 GB).</p>
<p>Different classes of machine cost different numbers of credits to run. And to make sure things don’t go out of control, you can set the options <tt><a href="http://reference.wolfram.com/language/ref/TimeConstraint.html">TimeConstraint</a></tt> (maximum time in seconds) and <tt><a href="https://reference.wolframcloud.com/language/ref/CreditConstraint.html">CreditConstraint</a></tt> (maximum number of credits to use). </p>
<p>Then there’s notification. The default is to send one email when the job is starting, and one when it’s finished. There’s an option <tt><a href="https://reference.wolfram.com/language/ref/RemoteJobName.html">RemoteJobName</a></tt> that lets you give a name to each job, so you can more easily tell which job a particular piece of email is about, or where the job is on the web dashboard. (If you don’t give a name to a job, it’ll be referred to by the UUID it’s been assigned.)</p>
<p>The option <tt><a href="https://reference.wolfram.com/language/ref/RemoteJobNotifications.html">RemoteJobNotifications</a></tt> lets you say what notifications you want, and how you want to receive them. There can be notifications whenever the status of a job changes, or at specific time intervals, or when specific numbers of credits have been used. You can get notifications either by email, or by text message. And, yes, if you get notified that your job is going to run out of credits, you can always go to the <a href="https://account.wolfram.com/login/oauth2/sign-in" target="_blank" rel="noopener">Wolfram Account portal</a> to top up your credits.</p>
<p>There are many properties of jobs that you can query. A central one is <tt>&#34;EvaluationResult&#34;</tt>. But, for example, <tt>&#34;<a href="http://reference.wolfram.com/language/ref/EvaluationData.html">EvaluationData</a>&#34;</tt> gives you a whole association of related information:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2025/11/sw11252025programmableimg1.png" alt="" title="" width="657" height="221"/> </p>

<p>If your job succeeds, it’s pretty likely <tt>&#34;EvaluationResult&#34;</tt> will be all you need. But if something goes wrong, you can easily drill down to study the details of what happened with the job, for example by looking at <tt>&#34;JobLogTabular&#34;</tt>.</p>
<p>If you want to know all the jobs you’ve initiated, you can always look at the web dashboard, but you can also get symbolic representations of the jobs from: </p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2025/11/sw11252025programmableimg3-a.png" alt="" title="" width="547" height="214"/> </p>

<p>For any of these job objects, you can ask for properties, and you can for example also apply <tt><a href="https://reference.wolfram.com/language/ref/RemoteBatchJobAbort.html">RemoteBatchJobAbort</a></tt> to abort them.</p>
<p>Once a job has completed, its result will be stored in Wolfram Compute Services—but only for a limited time (currently two weeks). Of course, once you’ve got the result, it’s very easy to store it permanently, for example, by putting it into the Wolfram Cloud using <tt><a href="https://reference.wolfram.com/language/ref/CloudPut.html">CloudPut</a></tt>[<i>expr</i>]. (If you know you’re going to want to store the result permanently, you can also do the <tt>CloudPut</tt> right inside your <tt>RemoteBatchSubmit</tt>.) </p>
<p>Talking about programmatic uses of Wolfram Compute Services, here’s another example: let’s say you want to generate a compute-intensive report once a week. Well, then you can put together several very high-level Wolfram Language functions to deploy a scheduled task that will run in the Wolfram Cloud to initiate jobs for Wolfram Compute Services:</p>
<p><img loading="lazy" src="https://content.wolfram.com/sites/43/2025/11/sw11252025programmableimg4.png" alt="" title="" width="485" height="14"/> </p>

<p>And, yes, you can initiate a Wolfram Compute Services job from any Wolfram Language system, whether on the desktop or in the cloud. </p>
<h2 id="and-theres-more-coming">And There’s More Coming…</h2>
<p>Wolfram Compute Services is going to be very useful to many people. But actually it’s just part of a much larger constellation of capabilities aimed at broadening the ways Wolfram Language can be used.</p>
<p>Mathematica and the Wolfram Language <a href="https://www.wolfram.com/mathematica/scrapbook/">started—back in 1988</a>—as desktop systems. But even at the very beginning, there was a capability to run the notebook front end on one machine, and then have a “<a href="https://reference.wolfram.com/language/howto/ConnectToARemoteKernel.html">remote kernel</a>” on another machine. (In those days we supported, among other things, communication via phone line!) In 2008 we introduced built-in parallel computation capabilities like <tt>ParallelMap</tt> and <tt>ParallelTable</tt>. Then in 2014 we introduced the <a href="https://www.wolframcloud.com">Wolfram Cloud</a>—both replicating the core functionality of <a href="https://www.wolfram.com/notebooks/">Wolfram Notebooks</a> on the web, and providing services such as <a href="https://reference.wolfram.com/language/guide/CreatingAnInstantAPI.html">instant APIs</a> and <a href="https://reference.wolfram.com/language/ref/ScheduledTask.html">scheduled tasks</a>. Soon thereafter, we introduced the <a href="https://www.wolfram.com/enterprise-private-cloud/">Enterprise Private Cloud</a>—a private version of Wolfram Cloud. In 2021 we introduced <a href="https://www.wolfram.com/application-server/">Wolfram Application Server</a> to deliver high-performance APIs (and it’s what we now use, for example, for <a href="https://www.wolframalpha.com">Wolfram|Alpha</a>). Along the way, in 2019, we introduced <a href="https://www.wolfram.com/engine/">Wolfram Engine</a> as a streamlined server and command-line deployment of Wolfram Language. Around Wolfram Engine we built <a href="https://www.wolfram.com/wstpserver/">WSTPServer</a> to serve Wolfram Engine capabilities on local networks, and we introduced <a href="https://www.wolfram.com/wolframscript/">WolframScript</a> to provide a deployment-agnostic way to run command-line-style Wolfram Language code. In <a href="https://writings.stephenwolfram.com/2020/12/launching-version-12-2-of-wolfram-language-mathematica-228-new-functions-and-much-more/#big-computations-send-them-to-a-cloud-provider">2020 we then introduced</a> the first version of <tt>RemoteBatchSubmit</tt>, to be used with cloud services such as <a href="https://reference.wolfram.com/language/ref/batchcomputationprovider/AWSBatch.html">AWS</a> and <a href="https://reference.wolfram.com/language/ref/batchcomputationprovider/AzureBatch.html">Azure</a>. But unlike with Wolfram Compute Services, this required <a href="https://reference.wolfram.com/language/workflow/SetUpTheAWSBatchComputationProvider.html">“do it yourself” provisioning</a> and licensing with the cloud services. And, finally, now, that’s what we’ve automated in Wolfram Compute Services.</p>
<p>OK, so what’s next? An important direction is the forthcoming Wolfram HPCKit—for organizations with their own large-scale compute facilities to set up their own back ends to <tt>RemoteBatchSubmit</tt>, etc. <tt>RemoteBatchSubmit</tt> is built in a very general way, that allows different “<a href="https://reference.wolfram.com/language/guide/RemoteBatchJobs.html#179238631">batch computation providers</a>” to be plugged in. Wolfram Compute Services is initially set up to support just one standard batch computation provider: <tt>&#34;WolframBatch&#34;</tt>. HPCKit will allow organizations to configure their own compute facilities (often with our help) to serve as batch computation providers, extending the streamlined experience of Wolfram Compute Services to on-premise or organizational compute facilities, and automating what is often a rather fiddly job process of submission (which, I must say, personally reminds me a lot of the mainframe job control systems I used in the 1970s). </p>
<p>Wolfram Compute Services is currently set up purely as a batch computation environment. But within the Wolfram System, we have the capability to support synchronous remote computation, and we’re planning to extend Wolfram Compute Services to offer this—allowing one, for example, to seamlessly run a remote kernel on a large or exotic remote machine. </p>
<p>But this is for the future. Today we’re launching the first version of Wolfram Compute Services. Which makes “supercomputer power” immediately available for any Wolfram Language computation. I think it’s going to be very useful to a broad range of users of Wolfram Language. I know I’m going to be using it a lot.</p>
        </div></div>
  </body>
</html>
