<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://revelry.co/insights/development/nix-time/">Original</a>
    <h1>Nix: An idea whose time has come</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div>
        <p>In which I shill you <a href="https://nixos.org/explore.html" target="_blank" rel="noopener">Nix</a>, a purely functional package manager.</p>
<h2>Why Nix?</h2>
<p>Joe Armstrong, one of the creators of Erlang, once described Erlang as the quest for programs that you “<a href="https://www.youtube.com/watch?v=u41GEwIq2mE&amp;t=3m59s" target="_blank" rel="noopener">write once, run forever</a>.” Nix, in comparison, might be the quest for programs that run wherever, whenever. Nix often scares newcomers and experienced devs alike, because it proposes a fairly radical overhaul to how we think about package management and how we run software in general. In this post, I’m going to illustrate which problems Nix solves and argue that this change in perspective has profound implications for software tooling.</p>
<p>Dealing with package managers is core to today’s developer experience, yet remains riddled with pitfalls. We tend to outsource our trust to a package cache, like NPM or Hex, and then incorporate whatever they return into our systems. Most of the time this works fine, as the package manager has incentives to act honestly. As an example of where this central point of failure becomes problematic, attackers can modify a package to include malware in what is known as a <a href="https://blog.aquasec.com/npm-library-supply-chain-attack" target="_blank" rel="noopener">digital supply chain attack</a>. What we really want, and what no package manager can give us today, is reproducibility.</p>
<p>By <a href="https://r13y.com/" target="_blank" rel="noopener">reproducibility</a>, we mean the ability to recreate, bit for bit, the build of a package on your own system. Whatever package is thrown your way, you can rebuild it locally and check whether you have the expected build output. This is analogous to verifying a binary downloaded from the Web by computing its sha256 hash, and comparing it to the one provided by the publisher of the binary. In Nix’s case, however, you’re building the package from source. Why is this important? Because it removes the need to trust the provider and makes the cost of detecting a failure or an attack much lower for the developer. Reproducibility means security for your systems and applications, and peace of mind for your developers.</p>
<p>The way in which one gets to this reproducible state is by assuming nothing about the local environment. Everything in Nix must be declared explicitly by the user. Most build tools or environments rely on assumptions about the local environment and try to deal with it as best they can, but if you want to provide a way to build anything, anywhere, you have to forgo any tether to the local environment. Nix does this by forcing you to declare the packages you want, and how to fit them together. Because every part of your environment or build is explicit, you can achieve isolation and reproducibility.</p>
<h2>Ok, but what is it?</h2>
<p>Nix is both a package manager–a source of prebuilt packages which one can download and run–and a functional language to help us to write “build expressions” in a reproducible way. A Nix expression is a function with one side-effect: creating the spec of the build itself.</p>
<p><em>“The main idea of the Nix approach is to store software components in isolation from each other in a central component store, under path names that contain cryptographic hashes of all inputs involved in building the component”</em></p>
<p>A simple idea, with some deep implications. Let’s unpack it.</p>
<p>First, everything built with Nix gets put in a central store, by default `/nix/store`, which is a departure from your Linux FHS (Filesystem Hierarchy Standard). You know very little about a package installed on your system the traditional way: how was it built? What does it depend on? Nix makes package definitions self-contained.</p>
<p>Second, every built artifact is identified with a hash, which is the summary identifier of the complete dependency graph of the package, the platform-specific build steps involved, and the Nix expression which defines how to build it.</p>
<p><a href="https://3ulsmb4eg8vz37c0vz2si64j-wpengine.netdna-ssl.com/wp-content/uploads/2022/02/Nix-chart.png"><img loading="lazy" src="https://3ulsmb4eg8vz37c0vz2si64j-wpengine.netdna-ssl.com/wp-content/uploads/2022/02/Nix-chart-300x181.png" alt="A red chart with black writing on a white background illustrating dependencies." width="300" height="181" srcset="https://3ulsmb4eg8vz37c0vz2si64j-wpengine.netdna-ssl.com/wp-content/uploads/2022/02/Nix-chart-300x181.png 300w, https://3ulsmb4eg8vz37c0vz2si64j-wpengine.netdna-ssl.com/wp-content/uploads/2022/02/Nix-chart.png 512w" sizes="(max-width: 300px) 100vw, 300px"/></a></p>
<p>This graph completely describes the flow of dependencies. Change the order, or change any dependency of bat, and the output hash changes, resulting in a new entry in the nix store. As far as Nix is concerned, it would be a totally new package. Since you know the hash of the output before you build it, you don’t need to backup packages themselves, just their build expressions. It means you can share the full spec of a local environment with a coworker, and know it will be executed exactly as it was run on your machine. It means you can have multiple environments, and multiple versions of a package, coexisting peacefully on your machine. And it gives you those assurances across languages and platforms: you gain a unified interface for packaging software, with everything you need to run it. Most of the time, it “just works”.</p>
<p>This alone is a welcome development, but another perhaps less appreciated benefit is that, while sharing software through space is easy today, sharing it through time is often much harder. For a made-up example, let’s imagine your company maintains a tool built 25 years ago with the C compiler from that time. It can’t be upgraded safely because the entire world’s banking system would fall apart if it did. Maybe you keep a dedicated laptop as a digital time capsule to maintain this tool. Instead, you can create a Nix shell with whatever version of the tools you need, pinned and never upgraded. This environment is isolated, and plays nice with all your other C versions on your system since it’s just another Nix package. You can share this environment with anybody and they’re one `nix-shell` command away from having the same environment as you.</p>
<p><em>“We build our computers the way we build our cities–over time, without a plan, on top of ruins.”</em></p>
<p>Nix undoubtedly has a steep learning curve, and there are two reasons for that. First, using Nix entails rethinking a lot of accepted wisdom and practices that have become second nature for a developer. Unlearning is hard. Second, Nix surfaces all the complexity involved in building software and forces you to deal with it. In order to make builds truly reproducible, this is largely inevitable. But once the “Nix way” is integrated, and the community tooling leveraged, your system becomes wonderfully transparent. No more chasing down configs and building tooling across your system and various languages. You gain a unified interface for dealing with building, composing, and sharing software artifacts across ecosystems. Nothing is hidden from you, and you can change whatever you like. In that sense, it belongs squarely in the Linux FOSS tradition.</p>
<p>Nix is out of the “science experiment phase”, but is still evolving. However, many companies used Nix in production today, for example, Target, <a href="https://blog.replit.com/betting-on-nix" target="_blank" rel="noopener">Replit</a>, and <a href="https://shopify.engineering/what-is-nix" target="_blank" rel="noopener">Shopify</a>. While the complexity of Nix can be daunting, I suspect we’ll look back in 20 years and wonder how we got along without it. In the meantime, enjoy being a few years ahead of the curve :).</p>
<section>
  
</section>
        <hr/>
              </div>
		</div></div>
  </body>
</html>
