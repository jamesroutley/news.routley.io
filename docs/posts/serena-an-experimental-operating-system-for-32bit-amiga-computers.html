<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/dplanitzer/Serena">Original</a>
    <h1>Serena: An experimental operating system for 32bit Amiga computers</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">Serena is an experimental operating system based on modern design principles with support for pervasive preemptive concurrency and multiple users. The kernel is object-oriented and designed to be cross-platform and future proof. It runs on Amiga systems with a 68030 or better CPU installed.</p>
<p dir="auto">One aspect that sets it aside from traditional threading-based OSs is that it is purely built around dispatch queues somewhat similar to Apple&#39;s Grand Central Dispatch. There is no support for creating threads in user space nor in kernel space. Instead the kernel implements a virtual processor concept where it dynamically manages a pool of virtual processors. The size of the pool is automatically adjusted based on the needs of the dispatch queues and virtual processors are assigned to processes as needed. All kernel and user space concurrency is achieved by creating dispatch queues and by submitting work items to dispatch queues. Work items are simply closures (a function with associated state) from the viewpoint of the user.</p>
<p dir="auto">Another interesting aspect is interrupt handling. Code which wants to react to an interrupt can register a counting semaphore with the interrupt controller for the interrupt it wants to handle. The interrupt controller will then signal the semaphore every time the interrupt occurs. Use of a counting semaphore ensures that the code which is interested in the interrupt does not miss the occurrence of an interrupt. The advantage of translating interrupts into signals on a semaphore is that the interrupt handling code executes in a well-defined context that is the same kind of context that any other kind of code runs in. It also gives the interrupt handling code more flexibility since it does not have to immediately react to an interrupt. The information that an interrupt has happened is never lost, whether the interrupt handler code happened to be busy with other things at the time of the interrupt or not.</p>
<p dir="auto">The kernel is generally reentrant. This means that virtual processors continue to be scheduled and context switched preemptively even while the CPU is executing inside the kernel. Additionally a full compliment of counting semaphores, condition variables and lock APIs are available inside the kernel. The API of those objects closely resembles what you would find in a user space implementation of a traditional OS.</p>
<p dir="auto">Serena implements a hierarchical process structure similar to POSIX. A process may spawn a number of child processes and it may pass a command line and environment variables to its children. A process accesses I/O resources via I/O channels which are similar to file descriptors in POSIX.</p>
<p dir="auto">There are two notable differences between the POSIX style process model and the Serena model though: first instead of using fork() followed by exec() to spawn a new process, you use a single function in Serena called Process_Spawn(). This makes spawning a process much faster and significantly less error prone.</p>
<p dir="auto">Secondly, a child process does not inherit the file descriptors of its parent by default. The only exception are the file descriptors 0, 1 and 2 which represent the terminal input and output streams. This model is much less error prone compared to the POSIX model where a process has to be careful to close file descriptors that it doesn&#39;t want to pass on to a child process before it spawns a child. Doing this was easy in the early days of Unix when applications were pretty much self contained and when there was no support for dynamic libraries. It&#39;s the opposite today because applications are far more complex and depend on many 3rd party libraries.</p>
<p dir="auto">The executable file format at this time is the Atari ST GemDos file format which is a close relative to the aout executable format. This file format will be eventually replaced with a file format that will be able to support dynamic libraries. However for now it is good enough to get the job done.</p>
<p dir="auto">The kernel implements SerenaFS which is a hierarchical file system with permissions and user and group information. A file system may be mounted on top of a directory located in another file system to expand the file namespace. All this works similar to how it works in POSIX systems. A process which wants to spawn a child process can specify that the child process should be confined to a sub-tree of the global file system namespace.</p>
<p dir="auto">The boot file system is currently RAM-based. The ROM contains a disk image which is created with the diskimage tool and which serves as a template for the RAM disk. This ROM disk image is copied to RAM at boot time.</p>
<p dir="auto">User space has support for libc, libsystem, libclap and the very beginnings of libm. Libsystem is a library that implements the user space side of the kernel interface. Libclap is a library that implements argument parsing for command line interface programs.</p>
<p dir="auto">Serena OS comes with a shell which implements a formally defined shell language. You can find the shell document <a href="https://github.com/dplanitzer/Serena/blob/main/Commands/shell/README.md">here</a>.</p>

<p dir="auto">The following kernel services are implemented at this time:</p>
<ul dir="auto">
<li>Kernel and user space separation in the sense of code privilege separation (not memory space separation)</li>
<li>Dispatch queues with execution priorities</li>
<li>Virtual processors with priorities and pervasive preemptive scheduling</li>
<li>Interrupt handling with support for direct and semaphore-based interrupt handling</li>
<li>Simple memory management (no virtual memory support yet)</li>
<li>In-kernel object runtime system (used for drivers and file systems)</li>
<li>Hierarchical processes with support for command line arguments, environment variables and I/O resource descriptor inheritance</li>
<li>Hierarchical file system structure with support for mounting/unmounting file systems</li>
<li>The SerenaFS file system</li>
<li>Support for ROM and RAM-based disks</li>
<li>Support for aout/GemDos executables</li>
<li>Support for pipes</li>
<li>Floppy disk driver</li>
<li>Monotonic clock</li>
<li>Repeating timers</li>
<li>Counting semaphores, condition variables and locks (mutexes)</li>
<li>Zorro II and III expansion board detection and enumeration</li>
<li>Event driver with support for keyboard, mouse, digital Joystick, analog joystick (paddles) and light pens</li>
<li>Simple graphics driver (not taking advantage of the Blitter yet)</li>
<li>VT52 and VT100 series compatible interactive console</li>
</ul>
<p dir="auto">The following user space services are available at this time:</p>
<ul dir="auto">
<li>A system library with support for processes, dispatch queues, time and file I/O</li>
<li>C99 compatible libc</li>
<li>Beginnings of a C99 compatible libm</li>
<li>libclap command line interface argument parsing library</li>
</ul>
<p dir="auto">The following user space programs are available at this time:</p>
<ul dir="auto">
<li>An <a href="https://github.com/dplanitzer/Serena/blob/main/Commands/shell/README.md">interactive shell</a> with command line editing and history support</li>
</ul>
<p dir="auto">The level of completeness and correctness of the various modules varies quite a bit at this time. Things are generically planned to improve over time :)</p>

<p dir="auto">The following hardware is supported at this time:</p>
<ul dir="auto">
<li>Amiga 2000, 3000 and 4000 motherboards</li>
<li>Newer than the original chipsets work, but their specific features are not used</li>
<li>Motorola 68030, 68040 and 68060 CPU. Note that the CPU has to be at least a 68030 class CPU</li>
<li>Motorola 68881 and 68882 FPU</li>
<li>Standard Commodore Amiga floppy drive</li>
<li>Zorro II and Zorro III memory expansion boards</li>
</ul>

<p dir="auto">Setting the project up for development and running the OS is a bit involved. The instructions below are for Windows but they should work pretty much the same on Linux and macOS.</p>

<p dir="auto">The first thing you will need is an Amiga computer emulator. I&#39;m using WinUAE which you can download from <a href="https://www.winuae.net/download" rel="nofollow">https://www.winuae.net/download</a></p>
<p dir="auto">Download the WinUAE installer and run it. This will place the emulator inside the &#39;Program Files&#39; directory on your boot drive.</p>
<p dir="auto">Next download and install the VBCC compiler and assembler needed to build the operating system. You can find the project homepage is at <a href="http://www.compilers.de/vbcc.html" rel="nofollow">http://www.compilers.de/vbcc.html</a> and the download page for the tools at <a href="http://sun.hasenbraten.de/vbcc" rel="nofollow">http://sun.hasenbraten.de/vbcc</a>.</p>
<p dir="auto">The version that I&#39;m using for my development and that I know works correctly on Windows 11 is 0.9h. Be sure to add an environment variable with the name <code>VBCC</code> which points to the VBCC folder on your disk and add the <code>vbcc\bin</code> folder to the <code>PATH</code> environment variable.</p>
<p dir="auto">Note that you need to have Microsoft Visual Studio and command line tools installed because the Microsoft C compiler is needed to build the build tools on Windows.</p>
<p dir="auto">Finally install GNU make for Windows and make sure that it is in the <code>PATH</code> environment variable. A straight-forward way to do this is by executing the following winget command in a shell window: <code>winget install GnuWin32.Make</code>.</p>

<p dir="auto">You only need to execute this step once and before you try to build the OS. The purpose of this step is to build a couple of tools that are needed to build the kernel and user space libraries. You can find documentation for these tools <a href="https://github.com/dplanitzer/Serena/blob/main/Tools/README.md">here</a>.</p>
<p dir="auto">First open a Developer Command Prompt in Windows Terminal and then cd into the <code>Serena/Tools</code> folder. Type <code>make</code> and hit return. This will build all required tools and place them inside a <code>Serena/build/tools</code> folder. The tools will be retained in this location even if you do a full clean of the OS project.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Building the Operating System</h3><a id="user-content-building-the-operating-system" aria-label="Permalink: Building the Operating System" href="#building-the-operating-system"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Open the Serena project folder in Visual Studio Code and select <code>Build All</code> from the <code>Run Build Task...</code> menu. This will build the kernel, libsystem, libc, libm and shell and generate a single <code>Serena.rom</code> file inside the <code>Serena/product/Kernel/</code> folder. This ROM file contains the kernel, user space libraries and the shell.</p>

<p dir="auto">First you&#39;ll need to create an Amiga configuration with at least a 68030 CPU (i.e. Amiga 3000 or 4000) in WinUAE if you haven&#39;t already. The easiest way to do this is by going to Quickstart and selecting A4000 as the model. Then go to the Hardware/ROM page and update the &#34;Main ROM file&#34; text field such that it points to the <code>Serena.rom</code> file inside the <code>Serena/build/product/</code> folder on your disk. Finally give your virtual Amiga at least 1MB of Fast RAM by going to the Hardware/RAM page and setting the &#34;Slow&#34; entry to 1MB. Save this configuration so that you don&#39;t have to recreate it next time you want to run the OS.</p>
<p dir="auto">Load the configuration and then hit the Start button or simply double-click the configuration in the Configurations page to run the OS. The emulator should open a screen that shows a boot message and then a shell prompt. See the <a href="https://github.com/dplanitzer/Serena/blob/main/Commands/shell/README.md">shell</a> page for a list of commands that are supported by the shell.</p>

<p dir="auto">Distributed under the MIT License. See <code>LICENSE.txt</code> for more information.</p>

<p dir="auto">Dietmar Planitzer - <a href="https://www.linkedin.com/in/dplanitzer" rel="nofollow">@linkedin</a></p>
<p dir="auto">Project link: <a href="https://github.com/dplanitzer/Serena">https://github.com/dplanitzer/Serena</a></p>
</article></div></div>
  </body>
</html>
