<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://meks.quest/blogs/the-theatre-of-pull-requests-and-code-review">Original</a>
    <h1>The Theatre of Pull Requests and Code Review</h1>
    
    <div id="readability-page-1" class="page"><div>
    
    <h3>Meks McClure · September 23, 2025</h3>

    <p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/z87j4h0uin8v9zgs26wo.png" alt="Goatmire"/>
    <a href="https://www.linkedin.com/in/petter-bostr%C3%B6m-a72ba788/">
      Photo Credit to Petter Boström
    </a></p>

    <p>
      I recently attended the
      <a href="https://goatmire.com/">Goatmire Elixir Conf</a>
      and one of the standout talks for me was
      <a href="https://www.linkedin.com/in/sasajuric/">Saša Jurić&#39;s</a>
      <a href="https://goatmire.com/talk/tell-me-a-story">&#34;Tell Me a Story&#34;</a>.
      It was an incredible presentation that combined theatrical storytelling with practical technical advice. Saša performed parts of his talk in character, turning technical topics into a compelling narrative that was part comedy, part tragedy, and fully packed with useful insights I&#39;ve started implementing myself. The recording will eventually be released online for viewing. I highly recommend that people watch it, and I&#39;ll endeavor to add a link to it here when it becomes available.
    </p>

    <p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/8xfruldbkakxrl1d1ib6.png" alt="Sasa Juric"/>
    <a href="https://www.linkedin.com/in/petter-bostr%C3%B6m-a72ba788/">
      Photo Credit to Petter Boström
    </a></p><h2>The Code Review Challenge</h2>

    <p>
      The talk focused on Code Review and Pull Requests (PRs). Saša laid out common problems most software engineers face. Too often, engineers dread code reviews even though they&#39;re a significant part of team collaboration. We avoid them because PRs tend to be too large, too complex, too difficult to comprehend, and too painful to test. So we end up commenting &#34;Looks Good To Me&#34; and suggesting a few minor styling improvements to give the appearance of a thorough review.
    </p>

    <p>
      This is how security leaks happen and codebases become progressively unmaintainable. Since git blame only points to the original author, it&#39;s easy to think &#34;if something goes wrong, it&#39;s not on me&#34;. But we&#39;re all responsible for the whole system, regardless of who wrote the individual lines of code.
    </p>

    <h2>What Makes a PR Reviewable?</h2>

    <p>
      So how do we review something that feels unreviewable? Saša advocates for normalizing the practice of returning difficult-to-understand PRs to the author. This makes logical sense, but it&#39;s challenging to implement because it can feel like admitting we&#39;re not smart enough to understand the code. However, saying &#34;I don&#39;t understand this enough to approve it&#34; is far more valuable than pretending with an empty &#34;LGTM&#34;.
    </p>

    <p>
      If we commit to only reviewing truly reviewable PRs, what does that look like? According to Saša, it should take the average reviewer 5-10 minutes. By &#39;average reviewer,&#39; he means mid-to-senior developers who understand the domain, business, and tech stack well—not newcomers still learning the system or mythical 10x engineers.
    </p>

    <p>
      How do you create a PR that can be reviewed in 5-10 minutes? By reducing the scope. A full feature should often be multiple PRs. A good rule of thumb is 300 lines of code changes - once you get above 500 lines, you&#39;re entering unreviewable territory.
    </p>

    <h2>Telling a Story with Commits</h2>

    <p>
      A key part of having a reviewable PR is writing commits that tell a story. Present your changes incrementally and logically so reviewers can follow your thought process. Generic commit messages such as &#34;add dependency,&#34; &#34;implement file upload feature,&#34; and &#34;address PR feedback&#34; don’t tell much of a story and leave reviewers guessing. Why was the dependency added? What were the specific steps in creating the file uploader feature? What feedback is being addressed?
    </p>

    <h3>Story-Telling Commit Messages</h3>

    <p>
      After a toast to the demo gods, Saša demonstrated writing story-telling commits with a live coding example, creating a PR that was part of a larger feature. His
      <a href="https://github.com/sasa1977/hamlet/pull/3">example PR</a>
      adds just 152 lines of code, removes 2 lines, but uses 13 thoughtful commits.
    </p>

    <p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/93ugurtvcfo9dp4njj8c.png" alt="image of commit messages"/></p><p>
      While some developers might understand those 152 lines from the final diff alone, I couldn&#39;t confidently approve it without the commit story.
    </p>

    <h3>Breaking Down the Example</h3>

    <p>
      For instance, looking at the overall diff, I didn&#39;t understand why he added
      <code>:runtime_tools</code>
      to <code>applications</code>
      in <code>mix.exs</code>. Following the <a href="https://github.com/sasa1977/hamlet/pull/3/commits/b94b851a4e8af5cd0905a70d6edc18a72d492df0">commit narrative</a>, it&#39;s clear this was needed for access to
      <code>:scheduler.get_sample()</code>
      to collect the samples. Now I can research that context or ask more pointed questions.
    </p>

    <h3>The Iterative Process</h3>

    <p>
      A huge benefit of seeing this live was witnessing the iterative process. In the <a href="https://github.com/sasa1977/hamlet/pull/3/commits/299d745cb8bbaf6731098b74f3643b9472ede4b8">compute average utilization commit</a>, we initially saw an incorrect implementation that computed averages of all schedulers, including offline ones. When testing revealed unexpected results, Saša went back and updated both the code and the commit that originally implemented that function so the story remained coherent.
    </p>

    <p>
      A flow that I find to work well for keeping commit history clean is with fixup commits. A fixup is a small commit that’s explicitly marked to be folded into an earlier commit during an interactive rebase. When you run rebase with autosquash, Git automatically pairs each fixup with its target and tucks the changes into the right place, keeping the story coherent without manual reordering.
    </p>

    <p>
      I sometimes experience creating merge conflicts for myself during this process. Both Saša and I agree that if it becomes too much effort to resolve the conflict, then creating a new commit is ok. Taking the time to put in extra effort to keep the commit history clean and the story coherent makes the PR easier for reviewers to understand.
    </p>

    <h3>The Value of Clean History</h3>

    <p>
      Keeping the commit history clean connects to advice I&#39;ve heard about ensuring every commit compiles and keeps the application runnable. I used to follow this loosely, but recent experiences with git bisect emphasized to me its importance. (If you are unfamiliar with
      <a href="https://git-scm.com/docs/git-bisect">git bisect</a>
      , it&#39;s worth checking out; it uses a binary search algorithm to find which commit in your project&#39;s history introduced a bug.)
    </p>

    <p>
      There are a few factors that make narrowing down when and how a regression was introduced more challenging. If a commit doesn&#39;t compile, I can&#39;t isolate whether the bug first appeared there. If the bug appeared in a commit that had hundreds of lines of code changed, determining which part of the commit is the issue requires significantly more reasoning. A clean commit history with messages that tell a story makes these kinds of investigations easier.
    </p>

    <h2>Making Review a Collaborative Success</h2>

    <p>
      When we present focused PRs with commits that tell clear stories, we get feedback sooner and our development cycles speed up. When reviewers understand our changes, we&#39;re more likely to receive valuable feedback instead of blanket approvals, and we&#39;re more likely to ship quality code. When our commits make sense, we can travel back in time as needed to understand how our codebase evolved.
    </p>

    <p>
      Thanks to Saša&#39;s theatrical lesson, I will be more intentional about crafting commit stories. The next time you&#39;re preparing a PR, consider:
      <strong>Are you telling a story your reviewers can follow?</strong>
      Start small - maybe focus on just one aspect, like keeping PRs under that 300-line guideline or writing more descriptive commit messages. Your future reviewers (and your future debugging self) will thank you.
    </p>

    <h3>Resources</h3>

    <ul>
      <li>
        <a href="https://git-scm.com/docs/git-blame">Git blame</a>
        for showing which revision and author last modified each line of a file
      </li>
      <li>
        <a href="https://git-scm.com/docs/git-rebase">Git rebase</a>
        for cleaning up commit history
      </li>
      <li>
        <a href="https://git-scm.com/docs/git-commit#Documentation/git-commit.txt---fixupltcommitgt">
          Git fixup
        </a>
        for amending earlier commits
      </li>
      <li>
        <a href="https://git-scm.com/docs/git-bisect">Git bisect</a>
        for finding when bugs were introduced
      </li>
    </ul>
  </div></div>
  </body>
</html>
