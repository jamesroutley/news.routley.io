<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rakhim.exotext.com/jupyter-notebooks-as-e2e-tests">Original</a>
    <h1>Jupyter Notebooks as E2E Tests</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p>Lots of scientific Python libraries are often used within Jupyter notebooks. At work, we develop and maintain plenty of such libraries for quantum computing, and some more higher-level ones include extensive user guides in form of Jupyter notebooks. </p>
<p>Recently, I&#39;ve been involved in building a new library, and it ended up containing a half dozen notebooks, covering everything from a quick start guide to niche applications and configuration examples. It being a completely new product, we wanted our users to have extensive interactive documentation from the start.</p>
<p>After the alpha stage was behind us, we needed to write e2e tests. I realized that user guide notebooks are essentially that! They already cover every major e2e use case, and we update them religiously. We also render them into HTML docs on release. Sure, they don&#39;t cover 100% of cases, and aren&#39;t generally parametrized. But if everything in them works, we have a very good indication that the overall release is healthy. (The library is used by another component of the system, and there are separate e2e tests for that component; and there are unit tests everywhere, too.)</p>
<p>To make Jupyter notebooks runnable as e2e tests (both locally and in CI pipelines) we needed to do 2 things:</p>
<ol>
<li>Make them parametrized so that both users following the guide and pipelines can run them.</li>
<li>Run them automatically.</li>
</ol>
<p>Point 1 is relevant because the library performs some actions on a remote server (a real quantum computer). So, we made the first cell in each user guide start with reading the URL of the server from the environment (<code>os.environ[&#39;SERVER_URL&#39;]</code>). The user can replace it with a literal string, or set the environment variable in their system. In CI, the environment variable is set by the Gitlab pipeline, and we can even dynamically rotate addresses.</p>
<p>Point 2 can be achieved in two ways. The easiest is to just install <a href="https://github.com/jupyter/nbclient">nbclient</a> run <code>jupyter execute &lt;NOTEBOOK.ipynb&gt;</code>. It can accept multiple files, and it produces no output. If notebooks were executed without errors, the process terminates without errors as well, and can be treated as a successful run by the CI. If there are errors, you&#39;ll see the output, which is good for debugging.</p>
<p>If you need to view the output of each executed cell, you can use a combination of <code>nbconvert</code> and <code>jq</code> (<a href="https://jqlang.github.io/jq/download/">homepage</a>). <code>nbconvert</code> to execute the notebook and convert the outputs into another notebook, then redirect them to stdout; and <code>jq</code> to extract particular parts of the output JSON.</p>
<pre><code>jupyter nbconvert --to notebook --execute  &lt;NOTEBOOK.ipynb&gt; --stdout | jq -r &#39;.cells[] | select(.outputs) | .outputs[] | select(.output_type == &#34;stream&#34;) | .text[]&#39;
</code></pre><p>This is a bit fragile as it relies on a particular structure of the output JSON, and it may change in future Jupyter versions. The example above is suitable for <code>notebook</code> version <code>6.4</code> and above. However, a failure of execution will not propogate up, the resulting notebook would just contain cells with error output, and <code>jq</code> would parse them successfully, rendering the whole run unsuited for continous integration. You&#39;d need to have some separate script to detect the presence/absence of &#34;error&#34; cells, and return the corresponding return code so that CI understands it.</p>
<p>For our purposes, the first way works ok. We only care about potential errors. Overall, by having this setup, we test both the integrity of documentation and of code on each merge request.</p>
<hr/>
<h3>Footnotes</h3>
<ol>
<li>Netflix uses notebooks for a variety of interesting purposes, including testing. See <a href="https://netflixtechblog.com/notebook-innovation-591ee3221233">Beyond Interactive: Notebook Innovation at Netflix</a>.</li>
</ol>

            </div></div>
  </body>
</html>
