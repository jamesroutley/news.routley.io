<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fasterthanli.me/articles/some-mistakes-rust-doesnt-catch">Original</a>
    <h1>Some mistakes Rust doesn&#39;t catch</h1>
    
    <div id="readability-page-1" class="page"><div>
  

  <div><p>
    Feb  7, 2022
    
      Â· 39 minute read
    
    
    
      
        
          Â·
          <a href="https://blog.plover.com/tags/rust">rust</a>
        
      
        
          Â·
          <a href="https://blog.plover.com/tags/golang">golang</a>
        
      
        
          Â·
          <a href="https://blog.plover.com/tags/concurrency">concurrency</a>
        
      
      
      
      
          
      
      
    
  </p></div>

  
</div><div>
  

  <p>I still get excited about programming languages. But these days, it&#39;s not so
much because of what they let me do, but rather what they <em>don&#39;t</em> let me do.</p>
<p>Ultimately, what you can with a programming language is seldom limited by the
language itself: there&#39;s nothing you can do in C++ that you can&#39;t do in C, given
infinite time.</p>
<p>As long as a language is turing-complete and compiles down to assembly, no
matter the interface, it&#39;s the same machine you&#39;re talking to. You&#39;re limited
by... what your hardware can do, how much memory it has (and how fast it is),
what kind of peripherals are plugged into it, and so on.</p>
<div>

<p>To be honest, the &#34;mov&#34; instruction is really <a href="https://github.com/xoreaxeaxeax/movfuscator">all you need</a>.</p>
</div>
<p>There&#39;s of course differences in expressiveness: some tasks might require more
or less code in different languages. The Java language is, or at least was,
infamous for being verbose: but other upsides made it an attractive choice for
many companies, today still.</p>
<p>And then there&#39;s performance, debuggability (which, if it isn&#39;t a word,
definitely should be one), and a dozen of other factors you might want to take
under advisement when &#34;picking a language&#34;.</p>
<h2>The size of the forest</h2>
<p>But consider this: of the complete set of combinations of all possible
instructions, only a tiny fraction are actually useful programs. A much tinier
fraction still, actually achieve the task you&#39;ve set out to do.</p>
<p>So one could view &#34;programming&#34; as searching for the right program within that
set. And one could view the virtue of &#34;stricter&#34; languages in reducing the size
of the set you&#39;re searching in, because there&#39;s fewer &#34;legal&#34; combinations.</p>
<p>With that in mind, one might be tempted to rank languages by &#34;how many programs
are legal&#34;. I don&#39;t expect everyone to achieve consensus on a single ranking,
but some divisions are well-accepted.</p>
<p>Consider the following JavaScript program:</p>
<pre><p>JavaScript code</p><p><code><i>function</i> <i>foo</i><i>(</i><i>i</i><i>)</i> <i>{</i>
  <i>console</i><i>.</i><i>log</i><i>(</i><i>&#34;foo&#34;</i><i>,</i> <i>i</i><i>)</i><i>;</i>
<i>}</i>

<i>function</i> <i>bar</i><i>(</i><i>)</i> <i>{</i>
  <i>console</i><i>.</i><i>log</i><i>(</i><i>&#34;bar!&#34;</i><i>)</i><i>;</i>
<i>}</i>

<i>function</i> <i>main</i><i>(</i><i>)</i> <i>{</i>
  <i>for</i> <i>(</i><i>i</i> <i>=</i> 0<i>;</i> <i>i</i> <i>&lt;</i> 3<i>;</i> <i>i</i><i>++</i><i>)</i> <i>{</i>
    <i>foo</i><i>(</i><i>i</i><i>)</i><i>;</i>
  <i>}</i>
  <i>return</i><i>;</i>
  <i>bar</i><i>(</i><i>)</i><i>;</i>
<i>}</i>

<i>main</i><i>(</i><i>)</i><i>;</i>
</code></p></pre>
<p>In this code, <code>bar()</code> is never actually invoked - <code>main</code> returns before it would
be.</p>
<p>Running it under node.js yields no warnings whatsoever:</p>
<pre><p>Shell session</p><p><code>$ node sample.js
foo 0
foo 1
foo 2
</code></p></pre>
<p>The same sample, as Go, also doesn&#39;t yield any warnings:</p>
<pre><p>Go code</p><p><code><i>package</i> main

<i>import</i> <i>&#34;log&#34;</i>

<i>func</i> <i>foo</i>(<i>i</i> <i>int</i>) {
  <i>log</i>.<i>Printf</i>(<i>&#34;foo %d&#34;</i>, <i>i</i>)
}

<i>func</i> <i>bar</i>() {
  <i>log</i>.<i>Printf</i>(<i>&#34;bar!&#34;</i>)
}

<i>func</i> <i>main</i>() {
  <i>for</i> <i>i</i> <i>:=</i> 0; <i>i</i> <i>&lt;</i> 3; <i>i</i><i>++</i> {
    <i>foo</i>(<i>i</i>)
  }
  <i>return</i>
  <i>bar</i>()
}
</code></p></pre><pre><p>Shell session</p><p><code>$ go build ./sample.main
$ ./sample
2022/02/06 17:35:55 foo 0
2022/02/06 17:35:55 foo 1
2022/02/06 17:35:55 foo 2
</code></p></pre>
<p>However, the <code>go vet</code> tool (which ships with the default Go distribution),
bats an eyelash:</p>
<pre><p>Shell session</p><p><code>$ go vet ./sample.go
# command-line-arguments
./sample.go:18:2: unreachable code
</code></p></pre>
<p>Because even though our code is not <em>technically</em> incorrect, it&#39;s... suspicious.
It looks a lot like incorrect code. So the linter gently asks &#34;hey, did you
really mean that? if you did, all good, just maybe comment it out. if you
didn&#39;t, now&#39;s your chance to fix it&#34;.</p>
<p>The same code, but in Rust, makes for a much noisier experience still:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>foo</i><i>(</i><i>i</i>: <i>usize</i><i>)</i> {
    <i>println</i><i>!</i><i>(</i><i>&#34;foo {}&#34;</i>, i<i>)</i><i>;</i>
}

<i>fn</i> <i>bar</i><i>(</i><i>)</i> {
    <i>println</i><i>!</i><i>(</i><i>&#34;bar!&#34;</i><i>)</i><i>;</i>
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>for</i> i <i>in</i> <i>0</i>..=<i>2</i> {
        <i>foo</i><i>(</i>i<i>)</i>
    }
    <i>return</i><i>;</i>
    <i>bar</i><i>(</i><i>)</i>
}
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo run
   Compiling lox v0.1.0 (/home/amos/bearcove/lox)
warning: unreachable expression
  --&gt; src/main.rs:14:5
   |
13 |     return;
   |     ------ any code following this expression is unreachable
14 |     bar()
   |     ^^^^^ unreachable expression
   |
   = note: `#[warn(unreachable_code)]` on by default

warning: `lox` (bin &#34;lox&#34;) generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.15s
     Running `target/debug/lox`
foo 0
foo 1
foo 2
</code></p></pre>
<p>I love that it doesn&#39;t just show what code is unreachable, but <em>why</em> that code
is unreachable.</p>
<p>Note that this is still a warning - just something we should look at when we get
a chance, but not a showstopper. (Unless we slap <code>#![deny(unreachable_code)]</code> at
the start of our <code>main.rs</code>, the equivalent of passing <code>-Werror=something</code> to
gcc/clang).</p>
<h2>Fuck around now, find out... when?</h2>
<p>Let&#39;s change our sample a little bit. Say we remove the definition of <code>bar</code>
entirely.</p>
<p>After all, it&#39;s never called - what harm could it do?</p>
<pre><p>JavaScript code</p><p><code><i>function</i> <i>foo</i><i>(</i><i>i</i><i>)</i> <i>{</i>
  <i>console</i><i>.</i><i>log</i><i>(</i><i>&#34;foo&#34;</i><i>,</i> <i>i</i><i>)</i><i>;</i>
<i>}</i>

<i>function</i> <i>main</i><i>(</i><i>)</i> <i>{</i>
  <i>for</i> <i>(</i><i>i</i> <i>=</i> 0<i>;</i> <i>i</i> <i>&lt;</i> 3<i>;</i> <i>i</i><i>++</i><i>)</i> <i>{</i>
    <i>foo</i><i>(</i><i>i</i><i>)</i><i>;</i>
  <i>}</i>
  <i>return</i><i>;</i>
  <i>bar</i><i>(</i><i>)</i><i>;</i>
<i>}</i>

<i>main</i><i>(</i><i>)</i><i>;</i>
</code></p></pre><pre><p>Shell session</p><p><code>$ node sample.js
foo 0
foo 1
foo 2
</code></p></pre>
<p>10/10 node.js implementations agree: nobody cares about <code>bar</code>, because it&#39;s
never <em>actually</em> called.</p>
<p>Go, however, is really cross about <code>bar</code>&#39;s departure:</p>
<pre><p>Go code</p><p><code><i>package</i> main

<i>import</i> <i>&#34;log&#34;</i>

<i>func</i> <i>foo</i>(<i>i</i> <i>int</i>) {
  <i>log</i>.<i>Printf</i>(<i>&#34;foo %d&#34;</i>, <i>i</i>)
}

<i>func</i> <i>main</i>() {
  <i>for</i> <i>i</i> <i>:=</i> 0; <i>i</i> <i>&lt;</i> 3; <i>i</i><i>++</i> {
    <i>foo</i>(<i>i</i>)
  }
  <i>return</i>
  <i>bar</i>()
}
</code></p></pre><pre><p>Shell session</p><p><code>$ go run ./sample.go 
# command-line-arguments
./sample.go:14:2: undefined: bar
</code></p></pre>
<p>...and terse as ever.</p>
<p>The Rust compiler is also heartbroken:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>foo</i><i>(</i><i>i</i>: <i>usize</i><i>)</i> {
    <i>println</i><i>!</i><i>(</i><i>&#34;foo {}&#34;</i>, i<i>)</i><i>;</i>
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>for</i> i <i>in</i> <i>0</i>..=<i>2</i> {
        <i>foo</i><i>(</i>i<i>)</i>
    }
    <i>return</i><i>;</i>
    <i>bar</i><i>(</i><i>)</i>
}
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo run
   Compiling lox v0.1.0 (/home/amos/bearcove/lox)
error[E0425]: cannot find function `bar` in this scope
  --&gt; src/main.rs:10:5
   |
10 |     bar()
   |     ^^^ not found in this scope

warning: unreachable expression
  --&gt; src/main.rs:10:5
   |
9  |     return;
   |     ------ any code following this expression is unreachable
10 |     bar()
   |     ^^^^^ unreachable expression
   |
   = note: `#[warn(unreachable_code)]` on by default

For more information about this error, try `rustc --explain E0425`.
warning: `lox` (bin &#34;lox&#34;) generated 1 warning
error: could not compile `lox` due to previous error; 1 warning emitted
</code></p></pre>
<p>...and still insistent that, were <code>bar</code> to exist (which it currently doesn&#39;t),
it would <em>still</em> never get called, and we still ought to... rethink our
position.</p>
<p>So, both Go and Rust reject these programs as illegal (they issue an error and
refuse to emit a compiled form of the program), even though, if I&#39;m to be
entirely fair, it&#39;s a perfectly fine program.</p>
<p>But there&#39;s a perfectly reasonable, practical explanation for this.</p>
<p>node.js, is in essence, an interpreter. It does ship with a just-in-time
compiler (several, in fact), but that is an implementation detail. We can
imagine that execution is performed &#34;on the fly&#34;, as new expressions and
statements are encountered, and be reasonably close to the truth.</p>
<p>So, node.js needn&#39;t concern itself with the existence of a <code>bar</code> symbol until
the very moment it&#39;s called (or accessed, or assigned to, etc.)</p>
<p>At which point, it <em>will</em> error out. At runtime, during the execution of our
program.</p>
<pre><p>JavaScript code</p><p><code><i>function</i> <i>foo</i><i>(</i><i>i</i><i>)</i> <i>{</i>
  <i>console</i><i>.</i><i>log</i><i>(</i><i>&#34;foo&#34;</i><i>,</i> <i>i</i><i>)</i><i>;</i>
<i>}</i>

<i>function</i> <i>main</i><i>(</i><i>)</i> <i>{</i>
  <i>for</i> <i>(</i><i>i</i> <i>=</i> 0<i>;</i> <i>i</i> <i>&lt;</i> 3<i>;</i> <i>i</i><i>++</i><i>)</i> <i>{</i>
    <i>foo</i><i>(</i><i>i</i><i>)</i><i>;</i>
  <i>}</i>
  <i>// ðŸ‘‡ (there used to be a &#39;return&#39; here)</i>
  <i>bar</i><i>(</i><i>)</i><i>;</i>
<i>}</i>

<i>main</i><i>(</i><i>)</i><i>;</i>
</code></p></pre><pre><p>Shell session</p><p><code>$ node sample.js
foo 0
foo 1
foo 2
/home/amos/bearcove/lox/sample.js:10
  bar();
  ^

ReferenceError: bar is not defined
    at main (/home/amos/bearcove/lox/sample.js:10:3)
    at Object.&lt;anonymous&gt; (/home/amos/bearcove/lox/sample.js:13:1)
    at Module._compile (node:internal/modules/cjs/loader:1101:14)
    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)
    at Module.load (node:internal/modules/cjs/loader:981:32)
    at Function.Module._load (node:internal/modules/cjs/loader:822:12)
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)
    at node:internal/main/run_main_module:17:47
</code></p></pre>
<p>However, both the Go and Rust compilers, through different machinery, eventually
generate some native executable that is full of machine code, and relatively
self-contained.</p>
<p>And thus, they must know what code to emit for the whole <code>main</code> function.
Including the address of <code>bar</code>, which, although it is in an unreachable portion
of the code, we still wrote a &#34;call&#34; instruction for in our source code.</p>
<p>If we wanted to reproduce roughly what&#39;s happening in node.js, we&#39;d need to use
a function pointer instead, which could be null, or point to a valid function:
and we&#39;d only find out when we actually call it.</p>
<p>This Go code compiles:</p>
<pre><p>Go code</p><p><code><i>package</i> main

<i>import</i> <i>&#34;log&#34;</i>

<i>func</i> <i>foo</i>(<i>i</i> <i>int</i>) {
  <i>log</i>.<i>Printf</i>(<i>&#34;foo %d&#34;</i>, <i>i</i>)
}

<i>type</i> <i>Bar</i> <i>func</i>()

<i>var</i> <i>bar</i> <i>Bar</i>

<i>func</i> <i>main</i>() {
  <i>for</i> <i>i</i> <i>:=</i> 0; <i>i</i> <i>&lt;</i> 3; <i>i</i><i>++</i> {
    <i>foo</i>(<i>i</i>)
  }
  <i>bar</i>()
}
</code></p></pre><pre><p>Shell session</p><p><code>$ go build ./sample.go

</code></p></pre>
<p>But panics during execution:</p>
<pre><p>Shell session</p><p><code>$ ./sample
2022/02/06 18:08:06 foo 0
2022/02/06 18:08:06 foo 1
2022/02/06 18:08:06 foo 2
panic: runtime error: invalid memory address or nil pointer dereference
[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x48756e]

goroutine 1 [running]:
main.main()
        /home/amos/bearcove/lox/sample.go:17 +0x6e
</code></p></pre>
<p>However, it stops panicking if we actually initialize <code>bar</code> to some valid
implementation:</p>
<pre><p>Go code</p><p><code><i>package</i> main

<i>import</i> <i>&#34;log&#34;</i>

<i>func</i> <i>foo</i>(<i>i</i> <i>int</i>) {
  <i>log</i>.<i>Printf</i>(<i>&#34;foo %d&#34;</i>, <i>i</i>)
}

<i>type</i> <i>Bar</i> <i>func</i>()

<i>var</i> <i>bar</i> <i>Bar</i>

<i>// ðŸ‘‡ we initialize bar in an `init` function, called implicitly at startup</i>
<i>func</i> <i>init</i>() {
  <i>bar</i> <i>=</i> <i>func</i>() {
    <i>log</i>.<i>Printf</i>(<i>&#34;bar!&#34;</i>)
  }
}

<i>func</i> <i>main</i>() {
  <i>for</i> <i>i</i> <i>:=</i> 0; <i>i</i> <i>&lt;</i> 3; <i>i</i><i>++</i> {
    <i>foo</i>(<i>i</i>)
  }

  <i>bar</i>()
}
</code></p></pre>
<p>We can do the same little charade in Rust:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>foo</i><i>(</i><i>i</i>: <i>usize</i><i>)</i> {
    <i>println</i><i>!</i><i>(</i><i>&#34;foo {}&#34;</i>, i<i>)</i><i>;</i>
}

<i>fn</i> <i>bar_impl</i><i>(</i><i>)</i> {
    <i>println</i><i>!</i><i>(</i><i>&#34;bar!&#34;</i><i>)</i><i>;</i>
}

<i>static</i> BAR: <i>fn</i><i>(</i><i>)</i> = bar_impl<i>;</i>

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>for</i> i <i>in</i> <i>0</i>..=<i>2</i> {
        <i>foo</i><i>(</i>i<i>)</i>
    }
    BAR<i>(</i><i>)</i>
}
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo run
   Compiling lox v0.1.0 (/home/amos/bearcove/lox)
    Finished dev [unoptimized + debuginfo] target(s) in 0.14s
     Running `target/debug/lox`
foo 0
foo 1
foo 2
bar!
</code></p></pre>
<p>Although, reproducing the crash is harder. Because we can&#39;t just declare a
function pointer that points to nothing.</p>
<pre><p>Rust code</p><p><code>$ <i>fn</i> <i>foo</i><i>(</i><i>i</i>: <i>usize</i><i>)</i> {
    <i>println</i><i>!</i><i>(</i><i>&#34;foo {}&#34;</i>, i<i>)</i><i>;</i>
}

<i>// ðŸ‘‡</i>
<i>static</i> BAR: <i>fn</i><i>(</i><i>)</i><i>;</i>

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>for</i> i <i>in</i> <i>0</i>..=<i>2</i> {
        <i>foo</i><i>(</i>i<i>)</i>
    }
    BAR<i>(</i><i>)</i>
}
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo run
   Compiling lox v0.1.0 (/home/amos/bearcove/lox)
error: free static item without body
 --&gt; src/main.rs:5:1
  |
5 | static BAR: fn();
  | ^^^^^^^^^^^^^^^^-
  |                 |
  |                 help: provide a definition for the static: `= &lt;expr&gt;;`

error: could not compile `lox` due to previous error
</code></p></pre>
<p>If we want to account for the possibility of bar being there or not there, we
must change its type to <code>Option&lt;fn()&gt;</code> instead:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>foo</i><i>(</i><i>i</i>: <i>usize</i><i>)</i> {
    <i>println</i><i>!</i><i>(</i><i>&#34;foo {}&#34;</i>, i<i>)</i><i>;</i>
}

<i>//            ðŸ‘‡</i>
<i>static</i> BAR: <i>Option</i><i>&lt;</i><i>fn</i><i>(</i><i>)</i><i>&gt;</i><i>;</i>

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>for</i> i <i>in</i> <i>0</i>..=<i>2</i> {
        <i>foo</i><i>(</i>i<i>)</i>
    }
    BAR<i>(</i><i>)</i>
}
</code></p></pre>
<p>And we still <em>must</em> assign it something.</p>
<pre><p>Shell session</p><p><code>$ cargo run
   Compiling lox v0.1.0 (/home/amos/bearcove/lox)
error: free static item without body
 --&gt; src/main.rs:5:1
  |
5 | static BAR: Option&lt;fn()&gt;;
  | ^^^^^^^^^^^^^^^^^^^^^^^^-
  |                         |
  |                         help: provide a definition for the static: `= &lt;expr&gt;;

(other errors omitted)
</code></p></pre>
<p>In this case, we&#39;ll assign <code>None</code> because I&#39;m trying to showcase what would
happen if <code>bar</code> did not exist:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>foo</i><i>(</i><i>i</i>: <i>usize</i><i>)</i> {
    <i>println</i><i>!</i><i>(</i><i>&#34;foo {}&#34;</i>, i<i>)</i><i>;</i>
}

<i>static</i> BAR: <i>Option</i><i>&lt;</i><i>fn</i><i>(</i><i>)</i><i>&gt;</i> = None<i>;</i>

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>for</i> i <i>in</i> <i>0</i>..=<i>2</i> {
        <i>foo</i><i>(</i>i<i>)</i>
    }
    BAR<i>(</i><i>)</i>
}
</code></p></pre>
<p>But now we have an error at the call site:</p>
<pre><p>Shell session</p><p><code>$ cargo run
   Compiling lox v0.1.0 (/home/amos/bearcove/lox)
error[E0618]: expected function, found enum variant `BAR`
  --&gt; src/main.rs:11:5
   |
5  | static BAR: Option&lt;fn()&gt; = None;
   | -------------------------------- `BAR` defined here
...
11 |     BAR()
   |     ^^^--
   |     |
   |     call expression requires function
   |
help: `BAR` is a unit variant, you need to write it without the parentheses
   |
11 -     BAR()
11 +     BAR
   | 

For more information about this error, try `rustc --explain E0618`.
error: could not compile `lox` due to previous error
</code></p></pre>
<p>Because now, <code>BAR</code> is not a function, that can be called, it&#39;s an <code>Option&lt;fn()&gt;</code>,
which could be one of either <code>Some(f)</code> (where <code>f</code> is a function we can call), 
or <code>None</code> (indicating the absence of a function we can call).</p>
<p>So, Rust forces us to account for both cases, which we can do with a <code>match</code> for
example:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>foo</i><i>(</i><i>i</i>: <i>usize</i><i>)</i> {
    <i>println</i><i>!</i><i>(</i><i>&#34;foo {}&#34;</i>, i<i>)</i><i>;</i>
}

<i>static</i> BAR: <i>Option</i><i>&lt;</i><i>fn</i><i>(</i><i>)</i><i>&gt;</i> = None<i>;</i>

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>for</i> i <i>in</i> <i>0</i>..=<i>2</i> {
        <i>foo</i><i>(</i>i<i>)</i>
    }
    <i>match</i> BAR {
        Some<i>(</i>f<i>)</i> =&gt; <i>f</i><i>(</i><i>)</i>,
        None =&gt; <i>println</i><i>!</i><i>(</i><i>&#34;(no bar implementation found)&#34;</i><i>)</i>,
    }
}
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo run
   Compiling lox v0.1.0 (/home/amos/bearcove/lox)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24s
     Running `target/debug/lox`
foo 0
foo 1
foo 2
(no bar implementation found)
</code></p></pre>
<p>And, with <code>BAR</code> set to the <code>Some</code> variant:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>foo</i><i>(</i><i>i</i>: <i>usize</i><i>)</i> {
    <i>println</i><i>!</i><i>(</i><i>&#34;foo {}&#34;</i>, i<i>)</i><i>;</i>
}

<i>static</i> BAR: <i>Option</i><i>&lt;</i><i>fn</i><i>(</i><i>)</i><i>&gt;</i> = Some<i>(</i>{
    <i>// we could define this outside the option, but we don&#39;t have to!</i>
    <i>// this is just showing off, but I couldn&#39;t resist, because it&#39;s fun.</i>
    <i>fn</i> <i>bar_impl</i><i>(</i><i>)</i> {
        <i>println</i><i>!</i><i>(</i><i>&#34;bar!&#34;</i><i>)</i><i>;</i>
    }
    <i>// the last expression of a block (`{}`) is what the block evaluates to</i>
    bar_impl
}<i>)</i><i>;</i>

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>for</i> i <i>in</i> <i>0</i>..=<i>2</i> {
        <i>foo</i><i>(</i>i<i>)</i>
    }
    <i>match</i> BAR {
        Some<i>(</i>f<i>)</i> =&gt; <i>f</i><i>(</i><i>)</i>,
        None =&gt; <i>println</i><i>!</i><i>(</i><i>&#34;(no bar implementation found)&#34;</i><i>)</i>,
    }
}
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
     Running `target/debug/lox`
foo 0
foo 1
foo 2
bar!
</code></p></pre>
<p>So, if we compare the stance of all three languages here:</p>
<ul>
<li>JavaScript (via node.js here) plain doesn&#39;t care if <code>bar()</code> exists until
you actually call it.</li>
<li>Go cares if it&#39;s a regular function call, but it will let you build a
function pointer that points to nowhere, and panic at runtime</li>
<li>Rust will not let you build a function pointer that
points to nowhere at all.</li>
</ul>
<p>JavaScript&#39;s looseness is not an oversight here: the mechanism which it uses to
look up symbols is completely different from Go and Rust. Even though there&#39;s
no mention of <code>bar</code> anywhere in our code, it might <em>still</em> exist, as evidenced
by this ~crime~ sample code:</p>
<pre><p>JavaScript code</p><p><code><i>function</i> <i>foo</i><i>(</i><i>i</i><i>)</i> <i>{</i>
  <i>console</i><i>.</i><i>log</i><i>(</i><i>&#34;foo&#34;</i><i>,</i> <i>i</i><i>)</i><i>;</i>
<i>}</i>

<i>eval</i><i>(</i>
  <i>`mruhgr4hgx&amp;C&amp;./&amp;CD&amp;iutyurk4rum.(hgx&#39;(/A`</i>
    <i>.</i><i>split</i><i>(</i><i>&#34;&#34;</i><i>)</i>
    <i>.</i><i>map</i><i>(</i><i>(</i><i>c</i><i>)</i> <i>=&gt;</i> String<i>.</i><i>fromCharCode</i><i>(</i><i>c</i><i>.</i><i>charCodeAt</i><i>(</i>0<i>)</i> <i>-</i> 6<i>)</i><i>)</i>
    <i>.</i><i>join</i><i>(</i><i>&#34;&#34;</i><i>)</i><i>,</i>
<i>)</i><i>;</i>

<i>function</i> <i>main</i><i>(</i><i>)</i> <i>{</i>
  <i>for</i> <i>(</i><i>i</i> <i>=</i> 0<i>;</i> <i>i</i> <i>&lt;</i> 3<i>;</i> <i>i</i><i>++</i><i>)</i> <i>{</i>
    <i>foo</i><i>(</i><i>i</i><i>)</i><i>;</i>
  <i>}</i>
  <i>bar</i><i>(</i><i>)</i><i>;</i>
<i>}</i>

<i>main</i><i>(</i><i>)</i><i>;</i>
</code></p></pre><pre><p>Shell session</p><p><code>$ node sample.js
foo 0
foo 1
foo 2
bar!
</code></p></pre>
<p>As for Rust, I should specify: <em>safe</em> Rust doesn&#39;t let you do that.</p>
<p>If we let ourself write <code>unsafe</code> code, an <em>essential</em> part of Rust, without
which one could not build safe abstractions atop the standard C library, or
system calls, for example, we can achieve crashdom:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>foo</i><i>(</i><i>i</i>: <i>usize</i><i>)</i> {
    <i>println</i><i>!</i><i>(</i><i>&#34;foo {}&#34;</i>, i<i>)</i><i>;</i>
}

<i>// initialize BAR with some garbage</i>
<i>static</i> BAR: <i>fn</i><i>(</i><i>)</i> = <i>unsafe</i> { std<i>::</i>mem<i>::</i><i>transmute</i><i>(</i><i>&amp;</i><i>(</i><i>)</i><i>)</i> }<i>;</i>

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>for</i> i <i>in</i> <i>0</i>..=<i>2</i> {
        <i>foo</i><i>(</i>i<i>)</i>
    }
    BAR<i>(</i><i>)</i><i>;</i>
}
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo run
   Compiling lox v0.1.0 (/home/amos/bearcove/lox)
error[E0080]: it is undefined behavior to use this value
 --&gt; src/main.rs:5:1
  |
5 | static BAR: fn() = unsafe { std::mem::transmute(&amp;()) };
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered pointer to alloc4, but expected a function pointer
  |
  = note: The rules on what exactly is undefined behavior aren&#39;t clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.
  = note: the raw bytes of the constant (size: 8, align: 8) {
              â•¾â”€â”€â”€â”€â”€â”€â”€alloc4â”€â”€â”€â”€â”€â”€â”€â”€â•¼                         â”‚ â•¾â”€â”€â”€â”€â”€â”€â•¼
          }

For more information about this error, try `rustc --explain E0080`.
error: could not compile `lox` due to previous error
</code></p></pre>
<p>Mh, nope, it caught that one. Huh.</p>
<p>Fine, let&#39;s do this then:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>foo</i><i>(</i><i>i</i>: <i>usize</i><i>)</i> {
    <i>println</i><i>!</i><i>(</i><i>&#34;foo {}&#34;</i>, i<i>)</i><i>;</i>
}

<i>const</i> BAR: <i>*</i><i>const</i> <i>(</i><i>)</i> = std<i>::</i>ptr<i>::</i><i>null</i><i>(</i><i>)</i><i>;</i>

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>for</i> i <i>in</i> <i>0</i>..=<i>2</i> {
        <i>foo</i><i>(</i>i<i>)</i>
    }

    <i>let</i> bar: <i>fn</i><i>(</i><i>)</i> = <i>unsafe</i> { std<i>::</i>mem<i>::</i><i>transmute</i><i>(</i>BAR<i>)</i> }<i>;</i>
    <i>bar</i><i>(</i><i>)</i><i>;</i>
}
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo run
   Compiling lox v0.1.0 (/home/amos/bearcove/lox)
    Finished dev [unoptimized + debuginfo] target(s) in 0.13s
     Running `target/debug/lox`
foo 0
foo 1
foo 2
zsh: segmentation fault (core dumped)  cargo run
</code></p></pre>
<p>There. We had to go out of our way to ask for it, but we got it.</p>
<p>So, of those three languages, it wouldn&#39;t be unreasonable to say that JavaScript
is the loosest one (letting us add things to the global scope at runtime, 
evaluate arbitrary strings, etc.), Rust is the strictest one (not letting us
create a dangling function pointer in safe Rust), and Go is somewhere in the
middle.</p>
<h2>Also, types</h2>
<p>Similarly, we can see a clear distinction in how those three languages treat
types.</p>
<p>It is extremely easy (too easy perhaps) to make a JavaScript function that can
&#34;add&#34; two arbitrary things. Because function parameters don&#39;t have types.</p>
<p>So, an <code>add</code> function will just as happily add together two numbers, as it will
concatenate two strings:</p>
<pre><p>JavaScript code</p><p><code><i>function</i> <i>add</i><i>(</i><i>a</i><i>,</i> <i>b</i><i>)</i> <i>{</i>
  <i>return</i> <i>a</i> <i>+</i> <i>b</i><i>;</i>
<i>}</i>

<i>function</i> <i>main</i><i>(</i><i>)</i> <i>{</i>
  <i>console</i><i>.</i><i>log</i><i>(</i><i>add</i><i>(</i>1<i>,</i> 2<i>)</i><i>)</i><i>;</i>
  <i>console</i><i>.</i><i>log</i><i>(</i><i>add</i><i>(</i><i>&#34;foo&#34;</i><i>,</i> <i>&#34;bar&#34;</i><i>)</i><i>)</i><i>;</i>
<i>}</i>

<i>main</i><i>(</i><i>)</i><i>;</i>
</code></p></pre><pre><p>Shell session</p><p><code>$ node sample.js
3
foobar
</code></p></pre>
<p>In Go, it&#39;s not that easy, because we have to pick a type.</p>
<p>We can do numbers:</p>
<pre><p>Go code</p><p><code><i>package</i> main

<i>import</i> <i>&#34;log&#34;</i>

<i>func</i> <i>add</i>(<i>a</i> <i>int</i>, <i>b</i> <i>int</i>) <i>int</i> {
  <i>return</i> <i>a</i> <i>+</i> <i>b</i>
}

<i>func</i> <i>main</i>() {
  <i>log</i>.<i>Printf</i>(<i>&#34;%v&#34;</i>, <i>add</i>(1, 2))
}
</code></p></pre><pre><p>Shell session</p><p><code>$ go run ./sample.go
2022/02/06 19:01:55 3
</code></p></pre>
<p>And we can do strings:</p>
<pre><p>Go code</p><p><code><i>package</i> main

<i>import</i> <i>&#34;log&#34;</i>

<i>func</i> <i>add</i>(<i>a</i> <i>string</i>, <i>b</i> <i>string</i>) <i>string</i> {
  <i>return</i> <i>a</i> <i>+</i> <i>b</i>
}

<i>func</i> <i>main</i>() {
  <i>log</i>.<i>Printf</i>(<i>&#34;%v&#34;</i>, <i>add</i>(<i>&#34;foo&#34;</i>, <i>&#34;bar&#34;</i>))
}
</code></p></pre><pre><p>Shell session</p><p><code>$ go run ./sample.go
2022/02/06 19:02:25 foobar
</code></p></pre>
<p>But we can&#39;t do both.</p>
<p>Or can we?</p>
<pre><p>Go code</p><p><code><i>package</i> main

<i>import</i> <i>&#34;log&#34;</i>

<i>func</i> <i>add</i>(<i>a</i> <i>interface</i>{}, <i>b</i> <i>interface</i>{}) <i>interface</i>{} {
  <i>if</i> <i>a</i>, <i>ok</i> <i>:=</i> <i>a</i>.(<i>int</i>); <i>ok</i> {
    <i>if</i> <i>b</i>, <i>ok</i> <i>:=</i> <i>b</i>.(<i>int</i>); <i>ok</i> {
      <i>return</i> <i>a</i> <i>+</i> <i>b</i>
    }
  }

  <i>if</i> <i>a</i>, <i>ok</i> <i>:=</i> <i>a</i>.(<i>string</i>); <i>ok</i> {
    <i>if</i> <i>b</i>, <i>ok</i> <i>:=</i> <i>b</i>.(<i>string</i>); <i>ok</i> {
      <i>return</i> <i>a</i> <i>+</i> <i>b</i>
    }
  }

  <i>panic</i>(<i>&#34;incompatible types&#34;</i>)
}

<i>func</i> <i>main</i>() {
  <i>log</i>.<i>Printf</i>(<i>&#34;%v&#34;</i>, <i>add</i>(1, 2))
  <i>log</i>.<i>Printf</i>(<i>&#34;%v&#34;</i>, <i>add</i>(<i>&#34;foo&#34;</i>, <i>&#34;bar&#34;</i>))
}
</code></p></pre><pre><p>Shell session</p><p><code>$ go run ./sample.go
2022/02/06 19:05:11 3
2022/02/06 19:05:11 foobar
</code></p></pre>
<p>It&#39;s... not very good, though. <code>add(1, &#34;foo&#34;)</code> will compile, but panic at
runtime, for example.</p>
<p>Luckily, Go 1.18 beta added generics, so maybe?</p>
<pre><p>Go code</p><p><code><i>package</i> main

<i>import</i> <i>&#34;log&#34;</i>

<i>func</i> <i>add</i>[<i>T</i> <i>int64</i> <i>|</i> <i>string</i>](<i>a</i> <i>T</i>, <i>b</i> <i>T</i>) <i>T</i> {
  <i>return</i> <i>a</i> <i>+</i> <i>b</i>
}

<i>func</i> <i>main</i>() {
  <i>log</i>.<i>Printf</i>(<i>&#34;%v&#34;</i>, <i>add</i>(1, 2))
  <i>log</i>.<i>Printf</i>(<i>&#34;%v&#34;</i>, <i>add</i>(<i>&#34;foo&#34;</i>, <i>&#34;bar&#34;</i>))
}
</code></p></pre><pre><p>Shell session</p><p><code>$ go run ./main.go
./main.go:10:22: int does not implement int64|string
</code></p></pre>
<p>Ah. Let&#39;s see what the <a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md#operators">type parameters
proposal</a>
suggests... oh. Okay.</p>
<pre><p>Go code</p><p><code><i>package</i> main

<i>import</i> <i>&#34;log&#34;</i>

<i>type</i> <i>Addable</i> <i>interface</i> {
  ~<i>int</i> <i>|</i> ~<i>int8</i> <i>|</i> ~<i>int16</i> <i>|</i> ~<i>int32</i> <i>|</i> ~<i>int64</i> <i>|</i>
    ~<i>uint</i> <i>|</i> ~<i>uint8</i> <i>|</i> ~<i>uint16</i> <i>|</i> ~<i>uint32</i> <i>|</i> ~<i>uint64</i> <i>|</i> ~<i>uintptr</i> <i>|</i>
    ~<i>float32</i> <i>|</i> ~<i>float64</i> <i>|</i> ~<i>complex64</i> <i>|</i> ~<i>complex128</i> <i>|</i>
    ~<i>string</i>
}

<i>func</i> <i>add</i>[<i>T</i> <i>Addable</i>](<i>a</i> <i>T</i>, <i>b</i> <i>T</i>) <i>T</i> {
  <i>return</i> <i>a</i> <i>+</i> <i>b</i>
}

<i>func</i> <i>main</i>() {
  <i>log</i>.<i>Printf</i>(<i>&#34;%v&#34;</i>, <i>add</i>(1, 2))
  <i>log</i>.<i>Printf</i>(<i>&#34;%v&#34;</i>, <i>add</i>(<i>&#34;foo&#34;</i>, <i>&#34;bar&#34;</i>))
}
</code></p></pre><pre><p>Shell session</p><p><code>$ go run ./main.go
2022/02/06 19:12:11 3
2022/02/06 19:12:11 foobar
</code></p></pre>
<p>Sure, that... that works. But I mean, we&#39;re not expressing a property of a type,
so much as listing all the types we can think of. I guess nobody will ever want
to implement the <code>+</code> operator for a user type. Or add <code>int128</code> / <code>uint128</code> to
the language.</p>
<p>Ah well.</p>
<p>As for contestant number 3, well... surely it&#39;s going to do great right? After
all, these articles are just thinly-veiled Rust propaganda, so surely it&#39;ll... </p>
<pre><p>Rust code</p><p><code><i>use</i> std<i>::</i>ops<i>::</i>Add<i>;</i>

<i>fn</i> <i>add</i><i>&lt;</i><i>T</i><i>&gt;</i><i>(</i><i>a</i>: <i>T</i>, <i>b</i>: <i>T</i><i>)</i> -&gt; T<i>::</i><i>Output</i>
<i>where</i>
    <i>T</i>: <i>Add</i><i>&lt;</i><i>T</i><i>&gt;</i>,
{
    a + b
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>dbg</i><i>!</i><i>(</i>add<i>(</i><i>1</i>, <i>2</i><i>)</i><i>)</i><i>;</i>
    <i>dbg</i><i>!</i><i>(</i>add<i>(</i><i>&#34;foo&#34;</i>, <i>&#34;bar&#34;</i><i>)</i><i>)</i><i>;</i>
}
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo run
   Compiling lox v0.1.0 (/home/amos/bearcove/lox)
error[E0277]: cannot add `&amp;str` to `&amp;str`
  --&gt; src/main.rs:12:10
   |
12 |     dbg!(add(&#34;foo&#34;, &#34;bar&#34;));
   |          ^^^ no implementation for `&amp;str + &amp;str`
   |
   = help: the trait `Add` is not implemented for `&amp;str`
note: required by a bound in `add`
  --&gt; src/main.rs:5:8
   |
3  | fn add&lt;T&gt;(a: T, b: T) -&gt; T::Output
   |    --- required by a bound in this
4  | where
5  |     T: Add&lt;T&gt;,
   |        ^^^^^^ required by this bound in `add`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `lox` due to previous error
</code></p></pre>
<p>Huh.</p>
<p>I mean, that&#39;s good if you&#39;re into that sort of thing.</p>
<p>I am, so I like it: first of all, we&#39;ve asked for &#34;any type that we can add&#34;,
not just listed a bunch of concrete types. We&#39;ve also allowed for <code>T + T</code> to
return a type that isn&#39;t <code>T</code>! The function&#39;s return type is <code>&lt;T as Add&lt;T&gt;&gt;::Output</code>, which could be anything.</p>
<p>Second of all, the diagnostic here is fantastic: it tells us what we asked,
why it couldn&#39;t be satisfied... I like it.</p>
<p>It doesn&#39;t really give the rationale behind <code>Add</code> not being implemented for
<code>&amp;str</code> and <code>&amp;str</code>, so I still serve a purpose. <code>&amp;str</code> is just a string slice:
it refers to some data that exists elsewhere, and doesn&#39;t carry ownership of
the data itself.</p>
<p>In our example, the data is in the executable itself:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>add</i><i>&lt;</i><i>T</i><i>&gt;</i><i>(</i>_: <i>T</i>, _: <i>T</i><i>)</i> -&gt; <i>T</i> {
    <i>todo</i><i>!</i><i>(</i><i>)</i><i>;</i>
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>dbg</i><i>!</i><i>(</i>add<i>(</i><i>1</i>, <i>2</i><i>)</i><i>)</i><i>;</i>
    <i>dbg</i><i>!</i><i>(</i>add<i>(</i><i>&#34;foo&#34;</i>, <i>&#34;bar&#34;</i><i>)</i><i>)</i><i>;</i>
}
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo build --quiet
$ objdump -s -j .rodata ./target/debug/lox | grep -B 3 -A 3 -E &#39;foo|bar&#39;
 3c0d0 03000000 00000000 02000000 00000000  ................
 3c0e0 00000000 00000000 02000000 00000000  ................
 3c0f0 00000000 00000000 20000000 04000000  ........ .......
                                                     ðŸ‘‡
 3c100 03000000 00000000 62617266 6f6f6164  ........barfooad
 3c110 64282266 6f6f222c 20226261 7222296e  d(&#34;foo&#34;, &#34;bar&#34;)n
 3c120 6f742079 65742069 6d706c65 6d656e74  ot yet implement
 3c130 65647372 632f6d61 696e2e72 73000000  edsrc/main.rs...
 3c140 01000000 00000000 00000000 00000000  ................
</code></p></pre>
<p>...so it&#39;s valid for the whole time the program is executed: the expression
<code>&#34;foo&#34;</code> is a <code>&amp;&#39;static str</code>.</p>
<p>But to join &#34;foo&#34; and &#34;bar&#34; together, we&#39;d have to allocate some memory. One
fairly natural way to do this would be to create a <code>String</code>, which would
allocate memory on the heap. And <code>String</code> implements <code>Deref&lt;Target=str&gt;</code>, so
anything we can do with a <code>&amp;str</code>, we can also do with a <code>String</code>.</p>
<p>So, long story short, you can&#39;t do <code>&amp;str + &amp;str</code>. You can, however, do <code>String + &amp;str</code>. If we look at <a href="https://doc.rust-lang.org/stable/std/string/struct.String.html#impl-Add%3C%26%27_%20str%3E">the docs</a>,
we find the rationale:</p>
<blockquote>
<p><code>impl&lt;&#39;_&gt; Add&lt;&amp;&#39;_ str&gt; for String</code></p>
<p>Implements theÂ <code>+</code>Â operator for concatenating two strings.</p>
<p>This consumes theÂ <code>String</code>Â on the left-hand side and re-uses its buffer (growing
it if necessary). This is done to avoid allocating a newÂ <code>String</code>Â and copying
the entire contents on every operation, which would lead toÂ <em>O</em>(<em>n</em>^2) running
time when building anÂ <em>n</em>-byte string by repeated concatenation.</p>
<p>The string on the right-hand side is only borrowed; its contents are copied into
the returnedÂ <code>String</code>.</p>
</blockquote>
<p>So, if we convert our parameters to <code>String</code> with <code>.to_string()</code>:</p>
<pre><p>Rust code</p><p><code><i>use</i> std<i>::</i>ops<i>::</i>Add<i>;</i>

<i>fn</i> <i>add</i><i>&lt;</i><i>T</i><i>&gt;</i><i>(</i><i>a</i>: <i>T</i>, <i>b</i>: <i>T</i><i>)</i> -&gt; T<i>::</i><i>Output</i>
<i>where</i>
    <i>T</i>: <i>Add</i><i>&lt;</i><i>T</i><i>&gt;</i>,
{
    a + b
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>dbg</i><i>!</i><i>(</i>add<i>(</i><i>1</i>, <i>2</i><i>)</i><i>)</i><i>;</i>
    <i>dbg</i><i>!</i><i>(</i>add<i>(</i><i>&#34;foo&#34;</i>.to_string<i>(</i><i>)</i>, <i>&#34;bar&#34;</i>.to_string<i>(</i><i>)</i><i>)</i><i>)</i><i>;</i>
}
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo run
   Compiling lox v0.1.0 (/home/amos/bearcove/lox)
error[E0277]: cannot add `String` to `String`
  --&gt; src/main.rs:12:10
   |
12 |     dbg!(add(&#34;foo&#34;.to_string(), &#34;bar&#34;.to_string()));
   |          ^^^ no implementation for `String + String`
   |
   = help: the trait `Add` is not implemented for `String`
note: required by a bound in `add`
  --&gt; src/main.rs:5:8
   |
3  | fn add&lt;T&gt;(a: T, b: T) -&gt; T::Output
   |    --- required by a bound in this
4  | where
5  |     T: Add&lt;T&gt;,
   |        ^^^^^^ required by this bound in `add`

error[E0277]: cannot add `String` to `String`
  --&gt; src/main.rs:12:10
   |
12 |     dbg!(add(&#34;foo&#34;.to_string(), &#34;bar&#34;.to_string()));
   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `String + String`
   |
   = help: the trait `Add` is not implemented for `String`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `lox` due to 2 previous errors
</code></p></pre>
<p>...it doesn&#39;t work either.</p>
<p>Because there&#39;s no <code>impl Add&lt;String, Output = String&gt; for String</code>.</p>
<p>Only <code>impl Add&lt;&amp;str, Output = String&gt; for String</code>. We don&#39;t <em>need</em> ownership of
the right-hand-side operand for <code>+</code>: we&#39;re merely reading it and copying it
immediately following the contents of the left-hand-side operand.</p>
<p>So, we can make our code work, if we accept arguments of two different types:</p>
<pre><p>Rust code</p><p><code><i>use</i> std<i>::</i>ops<i>::</i>Add<i>;</i>

<i>fn</i> <i>add</i><i>&lt;</i><i>A</i>, <i>B</i><i>&gt;</i><i>(</i><i>a</i>: <i>A</i>, <i>b</i>: <i>B</i><i>)</i> -&gt; A<i>::</i><i>Output</i>
<i>where</i>
    <i>A</i>: <i>Add</i><i>&lt;</i><i>B</i><i>&gt;</i>,
{
    a + b
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>dbg</i><i>!</i><i>(</i>add<i>(</i><i>1</i>, <i>2</i><i>)</i><i>)</i><i>;</i>
    <i>dbg</i><i>!</i><i>(</i>add<i>(</i><i>&#34;foo&#34;</i>.to_string<i>(</i><i>)</i>, <i>&#34;bar&#34;</i><i>)</i><i>)</i><i>;</i>
}
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo run
   Compiling lox v0.1.0 (/home/amos/bearcove/lox)
    Finished dev [unoptimized + debuginfo] target(s) in 0.21s
     Running `target/debug/lox`
[src/main.rs:11] add(1, 2) = 3
[src/main.rs:12] add(&#34;foo&#34;.to_string(), &#34;bar&#34;) = &#34;foobar&#34;
</code></p></pre>
<p>So, how did Rust fare here? Depends how you feel about things.</p>
<p>It&#39;s a pretty radical design choice, to force you to be aware that, yeah, since
you&#39;re creating a new value (out of the two parameters), you <em>will</em> have to
allocate. And so it forces you to allocate outside of the <code>Add</code> operation itself.</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>// I know `to_string` allocates, it&#39;s not hidden behind `+`.</i>
    <i>// the `+` may reallocate (to grow the `String`).</i>
    <i>let</i> foobar = <i>&#34;foo&#34;</i><i>.</i><i>to_string</i><i>(</i><i>)</i> + <i>&#34;bar&#34;</i><i>;</i>
    <i>dbg</i><i>!</i><i>(</i>&amp;foobar<i>)</i><i>;</i>
}
</code></p></pre><pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> foo: <i>String</i> = <i>&#34;foo&#34;</i><i>.</i><i>into</i><i>(</i><i>)</i><i>;</i>
    <i>let</i> bar: <i>String</i> = <i>&#34;bar&#34;</i><i>.</i><i>into</i><i>(</i><i>)</i><i>;</i>

    <i>// ðŸ›‘ this doesn&#39;t build:</i>
    <i>// the right-hand-side cannot be a `String`, it has to be a string slice,</i>
    <i>// e.g. `&amp;str`</i>
    <i>let</i> foobar = foo + bar<i>;</i>
    <i>dbg</i><i>!</i><i>(</i>&amp;foobar<i>)</i><i>;</i>
}
</code></p></pre><pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> foo: <i>String</i> = <i>&#34;foo&#34;</i><i>.</i><i>into</i><i>(</i><i>)</i><i>;</i>
    <i>let</i> bar: <i>String</i> = <i>&#34;bar&#34;</i><i>.</i><i>into</i><i>(</i><i>)</i><i>;</i>

    <i>// this builds fine!</i>
    <i>let</i> foobar = foo + <i>&amp;</i>bar<i>;</i>
    <i>dbg</i><i>!</i><i>(</i>&amp;foobar<i>)</i><i>;</i>
}
</code></p></pre><pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> foo: <i>String</i> = <i>&#34;foo&#34;</i><i>.</i><i>into</i><i>(</i><i>)</i><i>;</i>
    <i>let</i> bar: <i>String</i> = <i>&#34;bar&#34;</i><i>.</i><i>into</i><i>(</i><i>)</i><i>;</i>

    <i>let</i> foobar = foo + <i>&amp;</i>bar<i>;</i>
    <i>dbg</i><i>!</i><i>(</i>&amp;foobar<i>)</i><i>;</i>

    <i>// ðŸ›‘ this doesn&#39;t build!</i>
    <i>// `foo` was moved during the first addition (it was reused to store the</i>
    <i>// result of concatenating the two strings)</i>
    <i>let</i> foobar = foo + <i>&amp;</i>bar<i>;</i>
    <i>dbg</i><i>!</i><i>(</i>&amp;foobar<i>)</i><i>;</i>
}
</code></p></pre><pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> foo: <i>String</i> = <i>&#34;foo&#34;</i><i>.</i><i>into</i><i>(</i><i>)</i><i>;</i>
    <i>let</i> bar: <i>String</i> = <i>&#34;bar&#34;</i><i>.</i><i>into</i><i>(</i><i>)</i><i>;</i>

    <i>let</i> foobar = foo<i>.</i><i>clone</i><i>(</i><i>)</i> + <i>&amp;</i>bar<i>;</i>
    <i>dbg</i><i>!</i><i>(</i>&amp;foobar<i>)</i><i>;</i>

    <i>// this builds fine! we&#39;ve cloned foo in the previous addition, which</i>
    <i>// allocates. again, nothing is hidden in the implementation of `+`.</i>
    <i>let</i> foobar = foo + <i>&amp;</i>bar<i>;</i>
    <i>dbg</i><i>!</i><i>(</i>&amp;foobar<i>)</i><i>;</i>
}
</code></p></pre>
<p>That aspect of Rust is a turn-off to some folks. Even to folks who otherwise
love Rust for many other reasons. It&#39;s often been said that there&#39;s a
higher-level language (where you don&#39;t worry about allocating so much) inside of
Rust, waiting to be discovered.</p>
<p>Well, we&#39;re still waiting.</p>
<p>However, that very aspect is also what makes Rust so appealing for systems
programming. And its razor-sharp focus on ownership, lifetimes etc. is also the
underpinning of many of its safety guarantees.</p>
<h2>Losing the thread</h2>
<p>So, now that we&#39;ve looked at unreachable code / undefined symbols, and types,
let&#39;s talk about concurrency!</p>
<p>Code is said to be &#34;concurrent&#34; when several tasks can make progress at the same
time. And there&#39;s multiple mechanisms through which this can be achieved.</p>
<p>JavaScript definitely lets us write concurrent code:</p>
<pre><p>JavaScript code</p><p><code><i>function</i> <i>sleep</i><i>(</i><i>ms</i><i>)</i> <i>{</i>
  <i>return</i> <i>new</i> Promise<i>(</i><i>(</i><i>resolve</i><i>,</i> <i>_reject</i><i>)</i> <i>=&gt;</i> <i>setTimeout</i><i>(</i><i>resolve</i><i>,</i> <i>ms</i><i>)</i><i>)</i><i>;</i>
<i>}</i>

<i>async</i> <i>function</i> <i>doWork</i><i>(</i><i>name</i><i>)</i> <i>{</i>
  <i>for</i> <i>(</i><i>let</i> <i>i</i> <i>=</i> 0<i>;</i> <i>i</i> <i>&lt;</i> 30<i>;</i> <i>i</i><i>++</i><i>)</i> <i>{</i>
    <i>await</i> <i>sleep</i><i>(</i>Math<i>.</i><i>random</i><i>(</i><i>)</i> <i>*</i> 40<i>)</i><i>;</i>
    <i>process</i><i>.</i><i>stdout</i><i>.</i><i>write</i><i>(</i><i>name</i><i>)</i><i>;</i>
  <i>}</i>
<i>}</i>

Promise<i>.</i><i>all</i><i>(</i><i>[</i><i>&#34;a&#34;</i><i>,</i> <i>&#34;b&#34;</i><i>]</i><i>.</i><i>map</i><i>(</i><i>doWork</i><i>)</i><i>)</i><i>.</i><i>then</i><i>(</i><i>(</i><i>)</i> <i>=&gt;</i> <i>{</i>
  <i>process</i><i>.</i><i>stdout</i><i>.</i><i>write</i><i>(</i><i>&#34;\n&#34;</i><i>)</i><i>;</i>
<i>}</i><i>)</i><i>;</i>
</code></p></pre>
<p>And it runs fine in node.js:</p>
<pre><p>Shell session</p><p><code>$ node sample.js
abbaabbababaababbababbaabaabaababaabbabababaaababbbaababbabb
</code></p></pre>
<p>We can see here that both task &#34;a&#34; and task &#34;b&#34; are making progress,
concurrently. Not in parallel: they never actually make progress <em>at the same
time</em>, they just do little bits of progress one after the other, and, to the
outside observer, there&#39;s hardly a difference.</p>
<p>That means, for example, that you can definitely use node.js to write server
applications, that are serving a large number of concurrent requests.</p>
<p>Because you don&#39;t strictly need request handler to run in parallel, you just
need to them to process input as it comes in: oh, a client is trying to connect,
let&#39;s accept their connection! They sent a client hello, let&#39;s send a server
hello so we can complete a TLS handshake.</p>
<p>Now the request&#39;s coming in, there&#39;s one header, two, three, etc. - this can all
be done piecemeal. And then we can stream a body back to them, one spoonful at a
time, where spoons are actually buffers.</p>
<p>node.js actually does offer
<a href="https://nodejs.org/dist/latest/docs/api/worker_threads.html">threads</a>, but you
wouldn&#39;t use them to handle HTTP requests concurrently - rather, you&#39;d use them
to do cpu-intensive tasks in the background, not i/o-bound stuff.</p>
<p>If we turn our attention to Go, we can make a similar program fairly easily:</p>
<pre><p>Go code</p><p><code><i>package</i> main

<i>import</i> (
  <i>&#34;fmt&#34;</i>
  <i>&#34;math/rand&#34;</i>
  <i>&#34;sync&#34;</i>
  <i>&#34;time&#34;</i>
)

<i>func</i> <i>doWork</i>(<i>name</i> <i>string</i>) {
  <i>for</i> <i>i</i> <i>:=</i> 0; <i>i</i> <i>&lt;</i> 30; <i>i</i><i>++</i> {
    <i>time</i>.<i>Sleep</i>(<i>time</i>.<i>Duration</i>(<i>rand</i>.<i>Intn</i>(40)) <i>*</i> <i>time</i>.<i>Millisecond</i>)
    <i>fmt</i>.<i>Printf</i>(<i>&#34;%v&#34;</i>, <i>name</i>)
  }
}

<i>func</i> <i>main</i>() {
  <i>var</i> <i>wg</i> sync.<i>WaitGroup</i>

  <i>for</i> <i>name</i> <i>:=</i> <i>range</i> []<i>string</i>{<i>&#34;a&#34;</i>, <i>&#34;b&#34;</i>} {
    <i>wg</i>.<i>Add</i>(1)
    <i>go</i> <i>func</i>() {
      <i>defer</i> <i>wg</i>.<i>Done</i>()
      <i>doWork</i>(<i>name</i>)
    }()
  }

  <i>wg</i>.<i>Wait</i>()
  <i>fmt</i>.<i>Printf</i>(<i>&#34;\n&#34;</i>)
}
</code></p></pre><pre><p>Shell session</p><p><code>$ go run ./sample.go 
# command-line-arguments
./sample.go:24:10: cannot use name (type int) as type string in argument to doWork
</code></p></pre>
<p>Haha whoops, the &#34;for range&#34; syntax actually yields two values, and the first
one is the index, so we have to ignore it by binding it to <code>_</code>.</p>
<p>Let&#39;s try this again:</p>
<pre><p>Go code</p><p><code><i>// omitted: package, imports, func doWork</i>

<i>func</i> <i>main</i>() {
  <i>var</i> <i>wg</i> sync.<i>WaitGroup</i>

  <i>for</i> <i>_</i>, <i>name</i> <i>:=</i> <i>range</i> []<i>string</i>{<i>&#34;a&#34;</i>, <i>&#34;b&#34;</i>} {
    <i>wg</i>.<i>Add</i>(1)
    <i>go</i> <i>func</i>() {
      <i>defer</i> <i>wg</i>.<i>Done</i>()
      <i>doWork</i>(<i>name</i>)
    }()
  }

  <i>wg</i>.<i>Wait</i>()
  <i>fmt</i>.<i>Printf</i>(<i>&#34;\n&#34;</i>)
}
</code></p></pre><pre><p>Shell session</p><p><code>$ go run ./sample.go 
bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
</code></p></pre>
<p>Oh dear, there was another mix up. Yet there were no compiler warnings,
strange...</p>
<p>Let&#39;s try go vet?</p>
<pre><p>Shell session</p><p><code>$ go vet ./sample.go
# command-line-arguments
./sample.go:24:11: loop variable name captured by func literal
</code></p></pre>
<p>Haha right! Closures do work like that in Go.</p>
<pre><p>Go code</p><p><code><i>func</i> <i>main</i>() {
  <i>var</i> <i>wg</i> sync.<i>WaitGroup</i>

  <i>for</i> <i>_</i>, <i>name</i> <i>:=</i> <i>range</i> []<i>string</i>{<i>&#34;a&#34;</i>, <i>&#34;b&#34;</i>} {
    <i>wg</i>.<i>Add</i>(1)
    <i>name</i> <i>:=</i> <i>name</i>
    <i>go</i> <i>func</i>() {
      <i>defer</i> <i>wg</i>.<i>Done</i>()
      <i>doWork</i>(<i>name</i>)
    }()
  }

  <i>wg</i>.<i>Wait</i>()
  <i>fmt</i>.<i>Printf</i>(<i>&#34;\n&#34;</i>)
}
</code></p></pre>
<p>There!</p>
<div>

<p>I guess that&#39;s why the Go compiler is so fast - it barely checks for anything!</p>
</div>
<div>

<p>Now now, we&#39;re not here to disparage any specific language.</p>
</div>
<div>

<p>Yeah no okay but I mean... how often have you made those mistakes?</p>
</div>
<div>

<p>Ahh but maybe it&#39;s me who&#39;s stupid. Maybe I&#39;m a stupid stupid boy who just
will not learn - after all, only bad craftspeople blame their tools!</p>
</div>
<div>

<p>That is... that is so incredibly dense. Do you have any idea of the damage that
stupid, evil idiom has caused?</p>
</div>
<div>

<p>I don&#39;t know, sounds to me like maybe you&#39;re a bad craftsbear.</p>
</div>
<div>

<p>UGHHHHHHHHHHHHH</p>
</div>
<div>
<div>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><path d="M21.41 41.398c.148-1.787.337-3.572.574-5.351.369-2.772 4.393-11.308 5.624-12.882l.553-.706-1.344-.449a5.772 5.772 0 0 1-3.948-5.478 5.786 5.786 0 0 1 5.779-5.78 5.768 5.768 0 0 1 5.684 4.758l.249 1.396 1.231-.704a28.845 28.845 0 0 1 14.282-3.801c4.991 0 9.93 1.314 14.282 3.801l1.231.704.249-1.396a5.766 5.766 0 0 1 5.683-4.758 5.786 5.786 0 0 1 5.779 5.78 5.772 5.772 0 0 1-3.948 5.478l-1.344.449.552.705c1.911 2.44 2.55 2.541 3.563 5.599 1.422 4.293 2.923 7.964 2.923 12.61v49.875h2V41.373c0-6.519-2.008-12.717-5.819-18.005a7.768 7.768 0 0 0 4.072-6.836c0-4.29-3.49-7.78-7.779-7.78a7.766 7.766 0 0 0-7.3 5.1 30.834 30.834 0 0 0-14.146-3.45 30.834 30.834 0 0 0-14.146 3.45 7.766 7.766 0 0 0-7.301-5.1c-4.289 0-7.779 3.49-7.779 7.78a7.766 7.766 0 0 0 4.072 6.836c-6.681 9.271-5.976 21.037-5.992 32.034-.017 11.946.656 23.895.109 35.838l2.006-.001c.67 0-.17-33.831-.156-36.912.022-4.312.148-8.631.505-12.929z"></path><path d="M73.854 31.271v-4.494c0-.971-.79-1.76-1.761-1.76H55.235c-.604 0-1.3.869-1.778 1.905-.015 0-.027-.008-.042-.008H46.789c-.02 0-.037.011-.057.011-.478-1.037-1.175-1.908-1.779-1.908H28.094c-.971 0-1.761.79-1.761 1.76v4.494c0 4.477 3.643 8.119 8.119 8.119h5.12c4.265 0 7.734-3.47 7.734-7.734v-2.091H52.878v2.091c0 4.265 3.47 7.734 7.734 7.734h5.121c4.479-.001 8.121-3.643 8.121-8.119zm-41.713 3.192a1.387 1.387 0 0 1-1.917-.442 1.392 1.392 0 0 1 .442-1.917l8.403-5.255a1.392 1.392 0 0 1 1.475 2.359l-8.403 5.255zm11.163-2.18l-5.75 3.597a.95.95 0 0 1-1.313-.302.952.952 0 0 1 .303-1.312l5.75-3.597a.953.953 0 0 1 1.01 1.614zm15.168 1.935a1.387 1.387 0 0 1-1.917-.442 1.392 1.392 0 0 1 .442-1.917l8.403-5.255a1.392 1.392 0 0 1 1.475 2.359l-8.403 5.255zm4.909 1.561a.953.953 0 0 1-.506-1.759l5.75-3.597a.952.952 0 1 1 1.01 1.614l-5.75 3.597a.942.942 0 0 1-.504.145z"></path><path d="M59.705 45.232h-2c0 1.823-1.483 3.306-3.306 3.306s-3.306-1.483-3.306-3.306v-1.439h1.06a3.294 3.294 0 0 0 3.285-3.285v-.17c0-.259-.038-.508-.095-.749a3.291 3.291 0 0 0-2.665-2.482 3.243 3.243 0 0 0-.525-.053h-4.12c-.18 0-.353.025-.525.053a3.291 3.291 0 0 0-2.665 2.482 3.255 3.255 0 0 0-.095.749v.17a3.294 3.294 0 0 0 3.285 3.285h1.06v1.439a3.31 3.31 0 0 1-3.307 3.306 3.31 3.31 0 0 1-3.306-3.306h-2a5.312 5.312 0 0 0 5.306 5.306 5.293 5.293 0 0 0 4.306-2.229 5.294 5.294 0 0 0 4.306 2.229 5.313 5.313 0 0 0 5.307-5.306zM29.742 58.336a.703.703 0 0 0-1.406 0v5.368a.704.704 0 0 0 1.406 0v-5.368zM43.779 58.336a.703.703 0 0 0-1.406 0v5.368a.704.704 0 0 0 1.406 0v-5.368zM57.816 58.336a.703.703 0 0 0-1.407 0v5.368a.704.704 0 0 0 1.407 0v-5.368zM71.853 58.336a.704.704 0 0 0-1.407 0v5.368a.704.704 0 0 0 1.407 0v-5.368zM35.354 71.559v5.369a.703.703 0 0 0 1.406 0v-5.369a.703.703 0 0 0-1.406 0zM49.39 71.559v5.369a.704.704 0 0 0 1.407 0v-5.369a.703.703 0 0 0-1.407 0zM63.427 71.559v5.369a.704.704 0 0 0 1.407 0v-5.369a.703.703 0 0 0-1.407 0zM29.038 81.364a.703.703 0 0 0-.703.703v5.369a.703.703 0 0 0 1.406 0v-5.369a.703.703 0 0 0-.703-.703zM43.076 81.364a.703.703 0 0 0-.703.703v5.369a.703.703 0 0 0 1.406 0v-5.369a.705.705 0 0 0-.703-.703zM57.113 81.364a.704.704 0 0 0-.704.703v5.369a.704.704 0 0 0 1.407 0v-5.369a.705.705 0 0 0-.703-.703zM71.149 81.364a.703.703 0 0 0-.703.703v5.369a.703.703 0 0 0 1.407 0v-5.369a.705.705 0 0 0-.704-.703z"></path></svg><p>
Cool bear&#39;s hot tip
</p></div>
<p>AS IT TURNS OUT, good craftspeople don&#39;t shy away from questioning, criticizing,
and trying to improve their tools (or even switching to other tools entirely!)</p>
<p>It&#39;s... it&#39;s what they work with. What did you expect.</p>
<p>Anyone trying to tell you otherwise is probably romanticizing martyrdom and
fooling themselves into thinking that &#34;hard work&#34; must equate suffering, and
you deserve better companionship.</p>
</div>
<p>Anyway - the program finally does the thing:</p>
<pre><p>Shell session</p><p><code>$ go run ./sample.go
babbababaabbbabbbababbaabbbaabbabababbababbabaababbaaaaaaaaa
</code></p></pre>
<p>There&#39;s really no observable difference, running both program like that in a
shell. We just see a stream of &#34;a&#34; and &#34;b&#34; randomly coming in. Two instances of
&#34;doWork&#34; are also executing concurrently in Go.</p>
<p>But there is an actual difference: see, Go has threads.</p>
<p>If we run our node.js example again, but under <code>strace</code>, to look out for the
<code>write</code> syscall, and reduce the number of iterations to 5 for a more manageable
output, we can see that...</p>
<pre><p>Shell session</p><p><code>â¯ strace -f -e write node ./sample.js &gt; /dev/null
write(5, &#34;*&#34;, 1)                        = 1
strace: Process 1396685 attached
strace: Process 1396686 attached
strace: Process 1396687 attached
strace: Process 1396688 attached
strace: Process 1396689 attached
[pid 1396684] write(16, &#34;\1\0\0\0\0\0\0\0&#34;, 8) = 8
strace: Process 1396690 attached
[pid 1396684] write(1, &#34;b&#34;, 1)          = 1
[pid 1396684] write(1, &#34;b&#34;, 1)          = 1
[pid 1396684] write(1, &#34;a&#34;, 1)          = 1
[pid 1396684] write(1, &#34;a&#34;, 1)          = 1
[pid 1396684] write(1, &#34;b&#34;, 1)          = 1
[pid 1396684] write(1, &#34;a&#34;, 1)          = 1
[pid 1396684] write(1, &#34;b&#34;, 1)          = 1
[pid 1396684] write(1, &#34;a&#34;, 1)          = 1
[pid 1396684] write(1, &#34;a&#34;, 1)          = 1
[pid 1396684] write(1, &#34;b&#34;, 1)          = 1
[pid 1396684] write(1, &#34;\n&#34;, 1)         = 1
[pid 1396684] write(12, &#34;\1\0\0\0\0\0\0\0&#34;, 8) = 8
[pid 1396689] +++ exited with 0 +++
[pid 1396688] +++ exited with 0 +++
[pid 1396687] +++ exited with 0 +++
[pid 1396686] +++ exited with 0 +++
[pid 1396685] +++ exited with 0 +++
[pid 1396690] +++ exited with 0 +++
+++ exited with 0 +++
</code></p></pre><div>
<div>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><path d="M21.41 41.398c.148-1.787.337-3.572.574-5.351.369-2.772 4.393-11.308 5.624-12.882l.553-.706-1.344-.449a5.772 5.772 0 0 1-3.948-5.478 5.786 5.786 0 0 1 5.779-5.78 5.768 5.768 0 0 1 5.684 4.758l.249 1.396 1.231-.704a28.845 28.845 0 0 1 14.282-3.801c4.991 0 9.93 1.314 14.282 3.801l1.231.704.249-1.396a5.766 5.766 0 0 1 5.683-4.758 5.786 5.786 0 0 1 5.779 5.78 5.772 5.772 0 0 1-3.948 5.478l-1.344.449.552.705c1.911 2.44 2.55 2.541 3.563 5.599 1.422 4.293 2.923 7.964 2.923 12.61v49.875h2V41.373c0-6.519-2.008-12.717-5.819-18.005a7.768 7.768 0 0 0 4.072-6.836c0-4.29-3.49-7.78-7.779-7.78a7.766 7.766 0 0 0-7.3 5.1 30.834 30.834 0 0 0-14.146-3.45 30.834 30.834 0 0 0-14.146 3.45 7.766 7.766 0 0 0-7.301-5.1c-4.289 0-7.779 3.49-7.779 7.78a7.766 7.766 0 0 0 4.072 6.836c-6.681 9.271-5.976 21.037-5.992 32.034-.017 11.946.656 23.895.109 35.838l2.006-.001c.67 0-.17-33.831-.156-36.912.022-4.312.148-8.631.505-12.929z"></path><path d="M73.854 31.271v-4.494c0-.971-.79-1.76-1.761-1.76H55.235c-.604 0-1.3.869-1.778 1.905-.015 0-.027-.008-.042-.008H46.789c-.02 0-.037.011-.057.011-.478-1.037-1.175-1.908-1.779-1.908H28.094c-.971 0-1.761.79-1.761 1.76v4.494c0 4.477 3.643 8.119 8.119 8.119h5.12c4.265 0 7.734-3.47 7.734-7.734v-2.091H52.878v2.091c0 4.265 3.47 7.734 7.734 7.734h5.121c4.479-.001 8.121-3.643 8.121-8.119zm-41.713 3.192a1.387 1.387 0 0 1-1.917-.442 1.392 1.392 0 0 1 .442-1.917l8.403-5.255a1.392 1.392 0 0 1 1.475 2.359l-8.403 5.255zm11.163-2.18l-5.75 3.597a.95.95 0 0 1-1.313-.302.952.952 0 0 1 .303-1.312l5.75-3.597a.953.953 0 0 1 1.01 1.614zm15.168 1.935a1.387 1.387 0 0 1-1.917-.442 1.392 1.392 0 0 1 .442-1.917l8.403-5.255a1.392 1.392 0 0 1 1.475 2.359l-8.403 5.255zm4.909 1.561a.953.953 0 0 1-.506-1.759l5.75-3.597a.952.952 0 1 1 1.01 1.614l-5.75 3.597a.942.942 0 0 1-.504.145z"></path><path d="M59.705 45.232h-2c0 1.823-1.483 3.306-3.306 3.306s-3.306-1.483-3.306-3.306v-1.439h1.06a3.294 3.294 0 0 0 3.285-3.285v-.17c0-.259-.038-.508-.095-.749a3.291 3.291 0 0 0-2.665-2.482 3.243 3.243 0 0 0-.525-.053h-4.12c-.18 0-.353.025-.525.053a3.291 3.291 0 0 0-2.665 2.482 3.255 3.255 0 0 0-.095.749v.17a3.294 3.294 0 0 0 3.285 3.285h1.06v1.439a3.31 3.31 0 0 1-3.307 3.306 3.31 3.31 0 0 1-3.306-3.306h-2a5.312 5.312 0 0 0 5.306 5.306 5.293 5.293 0 0 0 4.306-2.229 5.294 5.294 0 0 0 4.306 2.229 5.313 5.313 0 0 0 5.307-5.306zM29.742 58.336a.703.703 0 0 0-1.406 0v5.368a.704.704 0 0 0 1.406 0v-5.368zM43.779 58.336a.703.703 0 0 0-1.406 0v5.368a.704.704 0 0 0 1.406 0v-5.368zM57.816 58.336a.703.703 0 0 0-1.407 0v5.368a.704.704 0 0 0 1.407 0v-5.368zM71.853 58.336a.704.704 0 0 0-1.407 0v5.368a.704.704 0 0 0 1.407 0v-5.368zM35.354 71.559v5.369a.703.703 0 0 0 1.406 0v-5.369a.703.703 0 0 0-1.406 0zM49.39 71.559v5.369a.704.704 0 0 0 1.407 0v-5.369a.703.703 0 0 0-1.407 0zM63.427 71.559v5.369a.704.704 0 0 0 1.407 0v-5.369a.703.703 0 0 0-1.407 0zM29.038 81.364a.703.703 0 0 0-.703.703v5.369a.703.703 0 0 0 1.406 0v-5.369a.703.703 0 0 0-.703-.703zM43.076 81.364a.703.703 0 0 0-.703.703v5.369a.703.703 0 0 0 1.406 0v-5.369a.705.705 0 0 0-.703-.703zM57.113 81.364a.704.704 0 0 0-.704.703v5.369a.704.704 0 0 0 1.407 0v-5.369a.705.705 0 0 0-.703-.703zM71.149 81.364a.703.703 0 0 0-.703.703v5.369a.703.703 0 0 0 1.407 0v-5.369a.705.705 0 0 0-.704-.703z"></path></svg><p>
Cool bear&#39;s hot tip
</p></div>
<p><code>strace</code> intercepts and prints information about system calls made by a process.</p>
<p>The <code>-f</code> option stands for &#34;follow forks&#34;, and it&#39;s especially useful because it
prefixes every line of output with a &#34;pid&#34;, which stands for &#34;process
identifier&#34;, but really, on Linux (where this experiment was done), processes
and threads are very much alike, and so we can actually pretend those pids are
tids (thread identifiers) instead.</p>
</div>
<p>...we can see that both &#34;a&#34; and &#34;b&#34; are written by the same thread (PID 1396684).</p>
<p>But if we run the Go program:</p>
<pre><p>Shell session</p><p><code>$ go build ./sample.go &amp;&amp; strace -f -e write ./sample &gt; /dev/null
strace: Process 1398810 attached
strace: Process 1398811 attached
strace: Process 1398812 attached
strace: Process 1398813 attached
[pid 1398813] write(1, &#34;b&#34;, 1)          = 1
[pid 1398809] write(1, &#34;a&#34;, 1)          = 1
[pid 1398813] write(1, &#34;b&#34;, 1)          = 1
[pid 1398813] write(5, &#34;\0&#34;, 1)         = 1
[pid 1398809] write(1, &#34;b&#34;, 1)          = 1
[pid 1398813] write(1, &#34;a&#34;, 1)          = 1
[pid 1398809] write(1, &#34;b&#34;, 1)          = 1
[pid 1398813] write(1, &#34;a&#34;, 1)          = 1
[pid 1398813] write(5, &#34;\0&#34;, 1)         = 1
[pid 1398809] write(1, &#34;a&#34;, 1)          = 1
[pid 1398813] write(1, &#34;b&#34;, 1)          = 1
[pid 1398809] write(1, &#34;a&#34;, 1)          = 1
[pid 1398809] write(1, &#34;\n&#34;, 1)         = 1
[pid 1398813] +++ exited with 0 +++
[pid 1398812] +++ exited with 0 +++
[pid 1398811] +++ exited with 0 +++
[pid 1398810] +++ exited with 0 +++
+++ exited with 0 +++
</code></p></pre>
<p>We can see that:</p>
<ul>
<li>&#34;a&#34; is written by PID 1398809</li>
<li>&#34;b&#34; is written by PID 1398813 </li>
</ul>
<p>...and we can see that occasionally, something writes the null byte (<code>\0</code>),
which I bet has everything to do with the scheduler.</p>
<p>We can actually tell Go to only use one thread.</p>
<pre><p>Shell session</p><p><code>$ go build ./sample.go &amp;&amp; GOMAXPROCS=1 strace -f -e write ./sample &gt; /dev/null
strace: Process 1401117 attached
strace: Process 1401118 attached
strace: Process 1401119 attached
[pid 1401116] write(1, &#34;b&#34;, 1)          = 1
[pid 1401116] write(1, &#34;a&#34;, 1)          = 1
[pid 1401116] write(1, &#34;b&#34;, 1)          = 1
[pid 1401116] write(1, &#34;b&#34;, 1)          = 1
[pid 1401116] write(1, &#34;a&#34;, 1)          = 1
[pid 1401119] write(1, &#34;b&#34;, 1)          = 1
[pid 1401119] write(1, &#34;a&#34;, 1)          = 1
[pid 1401119] write(1, &#34;b&#34;, 1)          = 1
[pid 1401116] write(1, &#34;a&#34;, 1)          = 1
[pid 1401116] write(1, &#34;a&#34;, 1)          = 1
[pid 1401116] write(1, &#34;\n&#34;, 1)         = 1
[pid 1401119] +++ exited with 0 +++
[pid 1401118] +++ exited with 0 +++
[pid 1401117] +++ exited with 0 +++
+++ exited with 0 +++
</code></p></pre>
<p>And now all the writes are issued from the same thread!</p>
<p>Wait! No they&#39;re not! What!</p>
<p>Let&#39;s check <a href="https://pkg.go.dev/runtime">the docs</a>:</p>
<blockquote>
<p>The GOMAXPROCS variable limits the number of operating system threads that can
execute user-level Go code simultaneously. There is no limit to the number of
threads that can be blocked in system calls on behalf of Go code; those do not
count against the GOMAXPROCS limit. This package&#39;s GOMAXPROCS function queries
and changes the limit.</p>
</blockquote>
<p>Ohohhh. I guess <code>nanosleep</code> is a blocking system call huh.</p>
<div>

<p>Huh.</p>
</div>
<p>As for Rust, well, we can have threads, for sure:</p>
<pre><p>Rust code</p><p><code><i>use</i> std<i>::</i>{
    io<i>::</i>{stdout, Write},
    time<i>::</i>Duration,
}<i>;</i>

<i>use</i> rand<i>::</i>Rng<i>;</i>

<i>fn</i> <i>do_work</i><i>(</i><i>name</i>: <i>String</i><i>)</i> {
    <i>let</i> <i>mut</i> rng = rand<i>::</i><i>thread_rng</i><i>(</i><i>)</i><i>;</i>
    <i>for</i> _ <i>in</i> <i>0</i>..<i>40</i> {
        std<i>::</i>thread<i>::</i><i>sleep</i><i>(</i><i>Duration</i><i>::</i><i>from_millis</i><i>(</i>rng<i>.</i><i>gen_range</i><i>(</i><i>0</i>..=<i>30</i><i>)</i><i>)</i><i>)</i><i>;</i>
        <i>print</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, name<i>)</i><i>;</i>
        <i>stdout</i><i>(</i><i>)</i><i>.</i><i>flush</i><i>(</i><i>)</i><i>.</i><i>ok</i><i>(</i><i>)</i><i>;</i>
    }
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> a = std<i>::</i>thread<i>::</i><i>spawn</i><i>(</i>|| <i>do_work</i><i>(</i><i>&#34;a&#34;</i><i>.</i><i>into</i><i>(</i><i>)</i><i>)</i><i>)</i><i>;</i>
    <i>let</i> b = std<i>::</i>thread<i>::</i><i>spawn</i><i>(</i>|| <i>do_work</i><i>(</i><i>&#34;b&#34;</i><i>.</i><i>into</i><i>(</i><i>)</i><i>)</i><i>)</i><i>;</i>
    a<i>.</i><i>join</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
    b<i>.</i><i>join</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>)</i><i>;</i>
}
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo run --quiet
babbabbabaabababbaaaabbabbabbababaaababbabababbbabbababbababababababaa
</code></p></pre>
<p>The output of <code>strace</code> for that program is exactly what we&#39;d expect (again,
reduced to only 5 iterations for readability):</p>
<pre><p>Shell session</p><p><code>$ cargo build --quiet &amp;&amp; strace -e write -f ./target/debug/lox &gt; /dev/null
strace: Process 1408066 attached
strace: Process 1408067 attached
[pid 1408066] write(1, &#34;a&#34;, 1)          = 1
[pid 1408067] write(1, &#34;b&#34;, 1)          = 1
[pid 1408066] write(1, &#34;a&#34;, 1)          = 1
[pid 1408067] write(1, &#34;b&#34;, 1)          = 1
[pid 1408067] write(1, &#34;b&#34;, 1)          = 1
[pid 1408067] write(1, &#34;b&#34;, 1)          = 1
[pid 1408066] write(1, &#34;a&#34;, 1)          = 1
[pid 1408067] write(1, &#34;b&#34;, 1)          = 1
[pid 1408067] +++ exited with 0 +++
[pid 1408066] write(1, &#34;a&#34;, 1)          = 1
[pid 1408066] write(1, &#34;a&#34;, 1)          = 1
[pid 1408066] +++ exited with 0 +++
write(1, &#34;\n&#34;, 1)                       = 1
+++ exited with 0 +++
</code></p></pre>
<p>&#34;a&#34; is written by PID 1408066, and &#34;b&#34; is written by PID 1408067.</p>
<p>We can also do that with async, say, with the <a href="https://lib.rs/crates/tokio">tokio</a> crate:</p>
<pre><p>Rust code</p><p><code><i>use</i> rand<i>::</i>Rng<i>;</i>
<i>use</i> std<i>::</i>{
    io<i>::</i>{stdout, Write},
    time<i>::</i>Duration,
}<i>;</i>
<i>use</i> tokio<i>::</i>{spawn, time<i>::</i>sleep}<i>;</i>

async <i>fn</i> <i>do_work</i><i>(</i><i>name</i>: <i>String</i><i>)</i> {
    <i>for</i> _ <i>in</i> <i>0</i>..<i>30</i> {
        <i>let</i> ms = rand<i>::</i><i>thread_rng</i><i>(</i><i>)</i><i>.</i><i>gen_range</i><i>(</i><i>0</i>..=<i>40</i><i>)</i><i>;</i>
        <i>sleep</i><i>(</i><i>Duration</i><i>::</i><i>from_millis</i><i>(</i>ms<i>)</i><i>)</i><i>.</i>await<i>;</i>
        <i>print</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, name<i>)</i><i>;</i>
        <i>stdout</i><i>(</i><i>)</i><i>.</i><i>flush</i><i>(</i><i>)</i><i>.</i><i>ok</i><i>(</i><i>)</i><i>;</i>
    }
}

<i>#<i>[</i>tokio<i>::</i>main<i>]</i></i>
async <i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> a = <i>spawn</i><i>(</i><i>do_work</i><i>(</i><i>&#34;a&#34;</i><i>.</i><i>into</i><i>(</i><i>)</i><i>)</i><i>)</i><i>;</i>
    <i>let</i> b = <i>spawn</i><i>(</i><i>do_work</i><i>(</i><i>&#34;b&#34;</i><i>.</i><i>into</i><i>(</i><i>)</i><i>)</i><i>)</i><i>;</i>
    a<i>.</i>await<i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
    b<i>.</i>await<i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>)</i><i>;</i>
}
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo run --quiet
abababbabababbabbabaabababbbaabaabaabbabaabbabbabababaababaa
</code></p></pre>
<p>The output of <code>strace</code> is actually interesting here:</p>
<pre><p>Shell session</p><p><code>$ cargo build --quiet &amp;&amp; strace -e write -f ./target/debug/lox &gt; /dev/null
strace: Process 1413863 attached
strace: Process 1413864 attached
strace: Process 1413865 attached
strace: Process 1413866 attached
strace: Process 1413867 attached
strace: Process 1413868 attached
strace: Process 1413869 attached
strace: Process 1413870 attached
strace: Process 1413871 attached
strace: Process 1413872 attached
strace: Process 1413873 attached
strace: Process 1413874 attached
strace: Process 1413875 attached
strace: Process 1413876 attached
strace: Process 1413877 attached
strace: Process 1413878 attached
strace: Process 1413879 attached
strace: Process 1413880 attached
strace: Process 1413881 attached
strace: Process 1413882 attached
strace: Process 1413883 attached
strace: Process 1413884 attached
strace: Process 1413885 attached
strace: Process 1413886 attached
strace: Process 1413887 attached
strace: Process 1413888 attached
strace: Process 1413889 attached
strace: Process 1413890 attached
strace: Process 1413891 attached
strace: Process 1413892 attached
strace: Process 1413893 attached
strace: Process 1413894 attached
[pid 1413893] write(4, &#34;\1\0\0\0\0\0\0\0&#34;, 8) = 8
[pid 1413863] write(1, &#34;a&#34;, 1)          = 1
[pid 1413863] write(4, &#34;\1\0\0\0\0\0\0\0&#34;, 8) = 8
[pid 1413863] write(1, &#34;a&#34;, 1)          = 1
[pid 1413863] write(1, &#34;a&#34;, 1)          = 1
[pid 1413893] write(1, &#34;b&#34;, 1 &lt;unfinished ...&gt;
[pid 1413863] write(4, &#34;\1\0\0\0\0\0\0\0&#34;, 8 &lt;unfinished ...&gt;
[pid 1413893] &lt;... write resumed&gt;)      = 1
[pid 1413863] &lt;... write resumed&gt;)      = 8
[pid 1413893] write(4, &#34;\1\0\0\0\0\0\0\0&#34;, 8) = 8
[pid 1413894] write(1, &#34;b&#34;, 1)          = 1
[pid 1413894] write(4, &#34;\1\0\0\0\0\0\0\0&#34;, 8) = 8
[pid 1413894] write(1, &#34;b&#34;, 1)          = 1
[pid 1413894] write(1, &#34;a&#34;, 1)          = 1
[pid 1413894] write(1, &#34;b&#34;, 1)          = 1
[pid 1413894] write(1, &#34;a&#34;, 1)          = 1
[pid 1413894] write(1, &#34;b&#34;, 1)          = 1
[pid 1413862] write(1, &#34;\n&#34;, 1)         = 1
[pid 1413862] write(4, &#34;\1\0\0\0\0\0\0\0&#34;, 8) = 8
[pid 1413867] +++ exited with 0 +++
[pid 1413863] +++ exited with 0 +++
[pid 1413864] +++ exited with 0 +++
[pid 1413868] +++ exited with 0 +++
[pid 1413865] +++ exited with 0 +++
[pid 1413866] +++ exited with 0 +++
[pid 1413869] +++ exited with 0 +++
[pid 1413870] +++ exited with 0 +++
[pid 1413873] +++ exited with 0 +++
[pid 1413871] +++ exited with 0 +++
[pid 1413872] +++ exited with 0 +++
[pid 1413874] +++ exited with 0 +++
[pid 1413875] +++ exited with 0 +++
[pid 1413876] +++ exited with 0 +++
[pid 1413878] +++ exited with 0 +++
[pid 1413877] +++ exited with 0 +++
[pid 1413879] +++ exited with 0 +++
[pid 1413880] +++ exited with 0 +++
[pid 1413881] +++ exited with 0 +++
[pid 1413882] +++ exited with 0 +++
[pid 1413883] +++ exited with 0 +++
[pid 1413884] +++ exited with 0 +++
[pid 1413885] +++ exited with 0 +++
[pid 1413886] +++ exited with 0 +++
[pid 1413887] +++ exited with 0 +++
[pid 1413888] +++ exited with 0 +++
[pid 1413891] +++ exited with 0 +++
[pid 1413890] +++ exited with 0 +++
[pid 1413889] +++ exited with 0 +++
[pid 1413893] +++ exited with 0 +++
[pid 1413892] +++ exited with 0 +++
[pid 1413894] +++ exited with 0 +++
+++ exited with 0 +++
</code></p></pre>
<p>The first thing that jumps out is that it&#39;s creating a lot of threads! 32, in
fact. Because that&#39;s how many hyperthreads are available on this computer.</p>
<p>The other thing that jumps out is that the writes seem to be issued by arbitrary
threads - tasks a and b don&#39;t seem to have any affinity for any particular
thread:</p>
<pre><p><code>========= 93
[pid 1413893] write(4, &#34;\1\0\0\0\0\0\0\0&#34;, 8) = 8
========= 63
[pid 1413863] write(1, &#34;a&#34;, 1)          = 1
[pid 1413863] write(4, &#34;\1\0\0\0\0\0\0\0&#34;, 8) = 8
[pid 1413863] write(1, &#34;a&#34;, 1)          = 1
[pid 1413863] write(1, &#34;a&#34;, 1)          = 1
========= 93
[pid 1413893] write(1, &#34;b&#34;, 1 &lt;unfinished ...&gt;
========= 63
[pid 1413863] write(4, &#34;\1\0\0\0\0\0\0\0&#34;, 8 &lt;unfinished ...&gt;
========= 93
[pid 1413893] &lt;... write resumed&gt;)      = 1
========= 63
[pid 1413863] &lt;... write resumed&gt;)      = 8
========= 93
[pid 1413893] write(4, &#34;\1\0\0\0\0\0\0\0&#34;, 8) = 8
========= 94
[pid 1413894] write(1, &#34;b&#34;, 1)          = 1
[pid 1413894] write(4, &#34;\1\0\0\0\0\0\0\0&#34;, 8) = 8
[pid 1413894] write(1, &#34;b&#34;, 1)          = 1
[pid 1413894] write(1, &#34;a&#34;, 1)          = 1
[pid 1413894] write(1, &#34;b&#34;, 1)          = 1
[pid 1413894] write(1, &#34;a&#34;, 1)          = 1
[pid 1413894] write(1, &#34;b&#34;, 1)          = 1
========= 62
[pid 1413862] write(1, &#34;\n&#34;, 1)         = 1
[pid 1413862] write(4, &#34;\1\0\0\0\0\0\0\0&#34;, 8) = 8
</code></p></pre>
<p>However, that version of the Rust code is fairly close to the Go code we had.</p>
<p>The implementation details vary significantly, but we have tasks/goroutines
being scheduled on OS threads, and we can ask the scheduler to only use a single
thread if we want to:</p>
<pre><p>Rust code</p><p><code><i>// omitted: everything else</i>

<i>#<i>[</i>tokio<i>::</i>main<i>(</i>flavor = <i>&#34;current_thread&#34;</i><i>)</i><i>]</i></i>
async <i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> a = <i>spawn</i><i>(</i><i>do_work</i><i>(</i><i>&#34;a&#34;</i><i>.</i><i>into</i><i>(</i><i>)</i><i>)</i><i>)</i><i>;</i>
    <i>let</i> b = <i>spawn</i><i>(</i><i>do_work</i><i>(</i><i>&#34;b&#34;</i><i>.</i><i>into</i><i>(</i><i>)</i><i>)</i><i>)</i><i>;</i>
    a<i>.</i>await<i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
    b<i>.</i>await<i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>)</i><i>;</i>
}
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo build --quiet &amp;&amp; strace -e write -f ./target/debug/lox &gt; /dev/null
write(4, &#34;\1\0\0\0\0\0\0\0&#34;, 8)         = 8
write(4, &#34;\1\0\0\0\0\0\0\0&#34;, 8)         = 8
write(1, &#34;a&#34;, 1)                        = 1
write(1, &#34;b&#34;, 1)                        = 1
write(1, &#34;a&#34;, 1)                        = 1
write(4, &#34;\1\0\0\0\0\0\0\0&#34;, 8)         = 8
write(1, &#34;a&#34;, 1)                        = 1
write(1, &#34;b&#34;, 1)                        = 1
write(4, &#34;\1\0\0\0\0\0\0\0&#34;, 8)         = 8
write(1, &#34;b&#34;, 1)                        = 1
write(4, &#34;\1\0\0\0\0\0\0\0&#34;, 8)         = 8
write(1, &#34;a&#34;, 1)                        = 1
write(4, &#34;\1\0\0\0\0\0\0\0&#34;, 8)         = 8
write(1, &#34;a&#34;, 1)                        = 1
write(4, &#34;\1\0\0\0\0\0\0\0&#34;, 8)         = 8
write(1, &#34;b&#34;, 1)                        = 1
write(4, &#34;\1\0\0\0\0\0\0\0&#34;, 8)         = 8
write(1, &#34;b&#34;, 1)                        = 1
write(4, &#34;\1\0\0\0\0\0\0\0&#34;, 8)         = 8
write(1, &#34;\n&#34;, 1)                       = 1
+++ exited with 0 +++
</code></p></pre>
<p>There! And that one&#39;s <em>actually</em> single-threaded: tokio&#39;s timer uses <a href="https://tokio.rs/blog/2018-03-timers">six hashed
timer wheels</a>. It&#39;s pretty neat.</p>
<h2>Off to the race conditions</h2>
<p>Both Go and Rust let us have not only concurrency, but also parallelism, via
threads. In Rust, we have the option of creating threads manually, or using
an async runtime - and we can tell the async runtime whether it&#39;s allowed
to use multiple threads or if it should just make everything happen on the
current thread.</p>
<p>As soon as multiple threads are allowed though, we&#39;re in dangerous lands.</p>
<p>Because now there can actually be multiple CPU cores manipulating the same area
in memory, something that... is a well-known source of problems.</p>
<p>Here&#39;s a simple example in go:</p>
<pre><p>Go code</p><p><code><i>package</i> main

<i>import</i> (
  <i>&#34;log&#34;</i>
  <i>&#34;sync&#34;</i>
)

<i>func</i> <i>doWork</i>(<i>counter</i> <i>*</i><i>int</i>) {
  <i>for</i> <i>i</i> <i>:=</i> 0; <i>i</i> <i>&lt;</i> 100000; <i>i</i><i>++</i> {
    <i>*</i><i>counter</i> <i>+=</i> 1
  }
}

<i>func</i> <i>main</i>() {
  <i>var</i> <i>wg</i> sync.<i>WaitGroup</i>
  <i>counter</i> <i>:=</i> 0

  <i>for</i> <i>i</i> <i>:=</i> 0; <i>i</i> <i>&lt;</i> 2; <i>i</i><i>++</i> {
    <i>wg</i>.<i>Add</i>(1)
    <i>go</i> <i>func</i>() {
      <i>defer</i> <i>wg</i>.<i>Done</i>()
      <i>doWork</i>(<i>&amp;</i><i>counter</i>)
    }()
  }

  <i>wg</i>.<i>Wait</i>()
  <i>log</i>.<i>Printf</i>(<i>&#34;counter = %v&#34;</i>, <i>counter</i>)
}
</code></p></pre>
<p>We&#39;ve got two tasks incrementing a counter a hundred thousand times - so we&#39;d
expect the final value to be two hundred thousands.</p>
<p>But instead:</p>
<pre><p>Shell session</p><p><code>$ go run ./sample.go
2022/02/07 15:02:18 counter = 158740

$ go run ./sample.go
2022/02/07 15:02:19 counter = 140789

$ go run ./sample.go
2022/02/07 15:02:19 counter = 200000

$ go run ./sample.go
2022/02/07 15:02:21 counter = 172553
</code></p></pre>
<p>Because incrementing a counter involves several steps: first we read its current
value, then we add one, then we store the new value in memory.</p>
<p>So it&#39;s entirely possible for this to happen:</p>
<ul>
<li>A reads a value of 10</li>
<li>B reads a value of 10</li>
<li>A computes the next value: it&#39;s 11</li>
<li>B computes the next value: it&#39;s 11</li>
<li>B stores the value 11 in the counter</li>
<li>A stores the value 11 in the counter</li>
</ul>
<p>And then we&#39;ve lost one value. And this happens quite a bit in our four sample
runs above. Only one of the runs successfully did all two hundred thousand
increments, and I bet it&#39;s because the first task was already done by the time
the second one started.</p>
<p>There&#39;s several ways to fix this: here we just have a dumb counter, so we can
simply use atomic operations:</p>
<pre><p>Go code</p><p><code><i>package</i> main

<i>import</i> (
  <i>&#34;log&#34;</i>
  <i>&#34;sync&#34;</i>
  <i>&#34;sync/atomic&#34;</i>
)

<i>func</i> <i>doWork</i>(<i>counter</i> <i>*</i><i>int64</i>) {
  <i>for</i> <i>i</i> <i>:=</i> 0; <i>i</i> <i>&lt;</i> 100000; <i>i</i><i>++</i> {
    <i>atomic</i>.<i>AddInt64</i>(<i>counter</i>, 1)
  }
}

<i>func</i> <i>main</i>() {
  <i>var</i> <i>wg</i> sync.<i>WaitGroup</i>
  <i>var</i> <i>counter</i> <i>int64</i> <i>=</i> 0

  <i>for</i> <i>i</i> <i>:=</i> 0; <i>i</i> <i>&lt;</i> 2; <i>i</i><i>++</i> {
    <i>wg</i>.<i>Add</i>(1)
    <i>go</i> <i>func</i>() {
      <i>defer</i> <i>wg</i>.<i>Done</i>()
      <i>doWork</i>(<i>&amp;</i><i>counter</i>)
    }()
  }

  <i>wg</i>.<i>Wait</i>()
  <i>log</i>.<i>Printf</i>(<i>&#34;counter = %v&#34;</i>, <i>counter</i>)
}
</code></p></pre><pre><p>Shell session</p><p><code>$ go run ./sample.go
2022/02/07 15:09:10 counter = 200000

$ go run ./sample.go
2022/02/07 15:09:11 counter = 200000

$ go run ./sample.go
2022/02/07 15:09:11 counter = 200000

$ go run ./sample.go
2022/02/07 15:09:11 counter = 200000 
</code></p></pre>
<p>Note that we can&#39;t use the <code>+</code> or <code>+=</code> operators here - we have to use specific
functions, because atomic operations have specific semantics.</p>
<p>Or we could use a <code>Mutex</code>, which is silly in this case, but will come into play
later, so we might as well see what it looks like:</p>
<pre><p>Go code</p><p><code><i>package</i> main

<i>import</i> (
  <i>&#34;log&#34;</i>
  <i>&#34;sync&#34;</i>
)

<i>func</i> <i>doWork</i>(<i>counter</i> <i>*</i><i>int64</i>, <i>mutex</i> sync.<i>Mutex</i>) {
  <i>for</i> <i>i</i> <i>:=</i> 0; <i>i</i> <i>&lt;</i> 100000; <i>i</i><i>++</i> {
    <i>mutex</i>.<i>Lock</i>()
    <i>*</i><i>counter</i> <i>+=</i> 1
    <i>mutex</i>.<i>Unlock</i>()
  }
}

<i>func</i> <i>main</i>() {
  <i>var</i> <i>wg</i> sync.<i>WaitGroup</i>
  <i>var</i> <i>counter</i> <i>int64</i> <i>=</i> 0
  <i>var</i> <i>mutex</i> sync.<i>Mutex</i>

  <i>for</i> <i>i</i> <i>:=</i> 0; <i>i</i> <i>&lt;</i> 2; <i>i</i><i>++</i> {
    <i>wg</i>.<i>Add</i>(1)
    <i>go</i> <i>func</i>() {
      <i>defer</i> <i>wg</i>.<i>Done</i>()
      <i>doWork</i>(<i>&amp;</i><i>counter</i>, <i>mutex</i>)
    }()
  }

  <i>wg</i>.<i>Wait</i>()
  <i>log</i>.<i>Printf</i>(<i>&#34;counter = %v&#34;</i>, <i>counter</i>)
}
</code></p></pre>
<p>And that works just as well:</p>
<pre><p>Shell session</p><p><code>$ go run ./sample.go
2022/02/07 15:14:47 counter = 190245

$ go run ./sample.go
2022/02/07 15:14:48 counter = 189107

$ go run ./sample.go
2022/02/07 15:14:48 counter = 164618

$ go run ./sample.go
2022/02/07 15:14:49 counter = 178458
</code></p></pre>
<p>Oh... oh no, it doesn&#39;t work at all.</p>
<div>

<p>And yet there were no compiler warnings!</p>
</div>
<p>Yeah I uh... I&#39;m not sure what happened, let&#39;s check &#34;go vet&#34;</p>
<pre><p>Shell session</p><p><code>$ go vet ./sample.go
# command-line-arguments
./sample.go:8:35: doWork passes lock by value: sync.Mutex
./sample.go:25:21: call of doWork copies lock value: sync.Mutex
</code></p></pre>
<p>Ohhhh haha it creates a copy of the lock, so each task has its own lock, which
results in no locking at all.</p>
<p>Silly me! No way I could&#39;ve seen that one coming.</p>
<pre><p>Go code</p><p><code><i>package</i> main

<i>import</i> (
  <i>&#34;log&#34;</i>
  <i>&#34;sync&#34;</i>
)

<i>func</i> <i>doWork</i>(<i>counter</i> <i>*</i><i>int64</i>, <i>mutex</i> <i>*</i>sync.<i>Mutex</i>) {
  <i>for</i> <i>i</i> <i>:=</i> 0; <i>i</i> <i>&lt;</i> 100000; <i>i</i><i>++</i> {
    <i>mutex</i>.<i>Lock</i>()
    <i>*</i><i>counter</i> <i>+=</i> 1
    <i>mutex</i>.<i>Unlock</i>()
  }
}

<i>func</i> <i>main</i>() {
  <i>var</i> <i>wg</i> sync.<i>WaitGroup</i>
  <i>var</i> <i>counter</i> <i>int64</i> <i>=</i> 0
  <i>var</i> <i>mutex</i> sync.<i>Mutex</i>

  <i>for</i> <i>i</i> <i>:=</i> 0; <i>i</i> <i>&lt;</i> 2; <i>i</i><i>++</i> {
    <i>wg</i>.<i>Add</i>(1)
    <i>go</i> <i>func</i>() {
      <i>defer</i> <i>wg</i>.<i>Done</i>()
      <i>doWork</i>(<i>&amp;</i><i>counter</i>, <i>&amp;</i><i>mutex</i>)
    }()
  }

  <i>wg</i>.<i>Wait</i>()
  <i>log</i>.<i>Printf</i>(<i>&#34;counter = %v&#34;</i>, <i>counter</i>)
}
</code></p></pre><pre><p>Shell session</p><p><code>$ go run ./sample.go
2022/02/07 15:16:59 counter = 200000

$ go run ./sample.go
2022/02/07 15:17:00 counter = 200000

$ go run ./sample.go
2022/02/07 15:17:00 counter = 200000

$ go run ./sample.go
2022/02/07 15:17:01 counter = 200000
</code></p></pre>
<p>Okay, now it works.</p>
<p>&#34;Mutex&#34; stands for &#34;mutual exclusion&#34;, and here it means that only <em>one</em> task
may hold a lock on the mutex at any given time. So, it goes something like this:</p>
<ul>
<li>A and B ask for the lock</li>
<li>B successfully acquires the lock</li>
<li>B reads the count: it&#39;s 10</li>
<li>B computes the next value: it&#39;s 11</li>
<li>B stores the value 11 in the counter</li>
<li>B releases the lock</li>
<li>B asks for the lock</li>
<li>A successfully acquires the lock</li>
<li>A reads the count: it&#39;s 11</li>
<li>A computes the next value: it&#39;s 12</li>
<li>A stores the value 12 in the counter</li>
</ul>
<p>...and so on.</p>
<p>There&#39;s several pitfalls associated with using a Mutex.</p>
<p>In Go specifically, since the counter and the mutex are separate, we must be
careful, and remember to always lock the mutex <em>before</em> touching the counter.</p>
<p>This can easily happen:</p>
<pre><p>Go code</p><p><code><i>func</i> <i>doWork</i>(<i>counter</i> <i>*</i><i>int64</i>, <i>mutex</i> <i>*</i>sync.<i>Mutex</i>) {
  <i>for</i> <i>i</i> <i>:=</i> 0; <i>i</i> <i>&lt;</i> 100000; <i>i</i><i>++</i> {
    <i>// woops forgot to use the mutex</i>
    <i>*</i><i>counter</i> <i>+=</i> 1
  }
}
</code></p></pre>
<p>And then we&#39;re back to square one.</p>
<p>Note that neither <code>go build</code> nor <code>go vet</code> see anything wrong with that code.</p>
<p>You can build an abstraction that holds <em>both</em> the counter and the mutex
together, somewhat awkwardly:</p>
<pre><p>Go code</p><p><code><i>package</i> main

<i>import</i> (
  <i>&#34;log&#34;</i>
  <i>&#34;sync&#34;</i>
)

<i>type</i> <i>ProtectedCounter</i> <i>struct</i> {
  <i>value</i> <i>int64</i>
  <i>mutex</i> sync.<i>Mutex</i>
}

<i>func</i> (<i>pc</i> <i>*</i><i>ProtectedCounter</i>) <i>inc</i>() {
  <i>pc</i>.<i>mutex</i>.<i>Lock</i>()
  <i>pc</i>.<i>value</i><i>++</i>
  <i>pc</i>.<i>mutex</i>.<i>Unlock</i>()
}

<i>func</i> (<i>pc</i> <i>*</i><i>ProtectedCounter</i>) <i>read</i>() <i>int64</i> {
  <i>return</i> <i>pc</i>.<i>value</i>
}

<i>func</i> <i>doWork</i>(<i>pc</i> <i>*</i><i>ProtectedCounter</i>) {
  <i>for</i> <i>i</i> <i>:=</i> 0; <i>i</i> <i>&lt;</i> 100000; <i>i</i><i>++</i> {
    <i>pc</i>.<i>inc</i>()
  }
}

<i>func</i> <i>main</i>() {
  <i>var</i> <i>wg</i> sync.<i>WaitGroup</i>
  <i>var</i> <i>pc</i> <i>ProtectedCounter</i>

  <i>for</i> <i>i</i> <i>:=</i> 0; <i>i</i> <i>&lt;</i> 2; <i>i</i><i>++</i> {
    <i>wg</i>.<i>Add</i>(1)
    <i>go</i> <i>func</i>() {
      <i>defer</i> <i>wg</i>.<i>Done</i>()
      <i>doWork</i>(<i>&amp;</i><i>pc</i>)
    }()
  }

  <i>wg</i>.<i>Wait</i>()
  <i>log</i>.<i>Printf</i>(<i>&#34;counter = %v&#34;</i>, <i>pc</i>.<i>read</i>())
}
</code></p></pre>
<p>And that code is correct.</p>
<p>But nothing&#39;s preventing us from accessing <code>ProtectedCounter.value</code> directly,
still:</p>
<pre><p>Go code</p><p><code><i>func</i> <i>doWork</i>(<i>pc</i> <i>*</i><i>ProtectedCounter</i>) {
  <i>for</i> <i>i</i> <i>:=</i> 0; <i>i</i> <i>&lt;</i> 100000; <i>i</i><i>++</i> {
    <i>pc</i>.<i>value</i> <i>+=</i> 1
  }
}
</code></p></pre>
<p>And then all hell breaks loose.</p>
<p>To really prevent that, we must move our protected counter to another package.</p>
<pre><p>Shell session</p><p><code>$ go mod init fasterthanli.me/sample
</code></p></pre><pre><p>Go code</p><p><code><i>// in `sample/protected/protected.go`</i>

<i>package</i> protected

<i>import</i> <i>&#34;sync&#34;</i>

<i>// Uppercase =&gt; exported</i>
<i>type</i> <i>Counter</i> <i>struct</i> {
  <i>// lowercase =&gt; unexported</i>
  <i>value</i> <i>int64</i>
  <i>mutex</i> sync.<i>Mutex</i>
}

<i>// Uppercase =&gt; exported</i>
<i>func</i> (<i>pc</i> <i>*</i><i>Counter</i>) <i>Inc</i>() {
  <i>pc</i>.<i>mutex</i>.<i>Lock</i>()
  <i>pc</i>.<i>value</i><i>++</i>
  <i>pc</i>.<i>mutex</i>.<i>Unlock</i>()
}

<i>// Uppercase =&gt; exported</i>
<i>func</i> (<i>pc</i> <i>*</i><i>Counter</i>) <i>Read</i>() <i>int64</i> {
  <i>return</i> <i>pc</i>.<i>value</i>
}
</code></p></pre>
<p>And then that code works:</p>
<pre><p>Go code</p><p><code><i>// in `sample/sample.go`</i>

<i>package</i> main

<i>import</i> (
  <i>&#34;log&#34;</i>
  <i>&#34;sync&#34;</i>

  <i>&#34;fasterthanli.me/sample/protected&#34;</i>
)

<i>func</i> <i>doWork</i>(<i>pc</i> <i>*</i>protected.<i>Counter</i>) {
  <i>for</i> <i>i</i> <i>:=</i> 0; <i>i</i> <i>&lt;</i> 100000; <i>i</i><i>++</i> {
    <i>pc</i>.<i>Inc</i>()
  }
}

<i>func</i> <i>main</i>() {
  <i>var</i> <i>wg</i> sync.<i>WaitGroup</i>
  <i>var</i> <i>pc</i> protected.<i>Counter</i>

  <i>for</i> <i>i</i> <i>:=</i> 0; <i>i</i> <i>&lt;</i> 2; <i>i</i><i>++</i> {
    <i>wg</i>.<i>Add</i>(1)
    <i>go</i> <i>func</i>() {
      <i>defer</i> <i>wg</i>.<i>Done</i>()
      <i>doWork</i>(<i>&amp;</i><i>pc</i>)
    }()
  }

  <i>wg</i>.<i>Wait</i>()
  <i>log</i>.<i>Printf</i>(<i>&#34;counter = %v&#34;</i>, <i>pc</i>.<i>Read</i>())
}
</code></p></pre>
<p>But that code fails with a compile error, as expected:</p>
<pre><p>Go code</p><p><code><i>func</i> <i>doWork</i>(<i>pc</i> <i>*</i>protected.<i>Counter</i>) {
  <i>for</i> <i>i</i> <i>:=</i> 0; <i>i</i> <i>&lt;</i> 100000; <i>i</i><i>++</i> {
    <i>pc</i>.<i>value</i> <i>+=</i> 1
  }
}
</code></p></pre><pre><p>Shell session</p><p><code>$ go build ./sample.go
# command-line-arguments
./sample.go:12:5: pc.value undefined (cannot refer to unexported field or method value)
</code></p></pre>
<p>Why we need to move it into a separate package to make that happen, or why the
visibility of symbols is tied to the casing of their identifiers... your guess
is as good as mine.</p>
<p>Let&#39;s turn our attention to Rust again.</p>
<p>Let&#39;s try to make the initial bug happen, where several threads are trying to
increment the same counter.</p>
<p>First let&#39;s try it with only one thread:</p>
<pre><p>Rust code</p><p><code><i>use</i> std<i>::</i>thread<i>::</i>spawn<i>;</i>

<i>fn</i> <i>do_work</i><i>(</i><i>counter</i>: <i>&amp;</i><i>mut</i> <i>u64</i><i>)</i> {
    <i>for</i> _ <i>in</i> <i>0</i>..<i>100_000</i> {
        <i>*</i>counter += <i>1</i>
    }
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> <i>mut</i> counter = <i>0</i><i>;</i>

    <i>let</i> a = <i>spawn</i><i>(</i>|| <i>do_work</i><i>(</i><i>&amp;</i><i>mut</i> counter<i>)</i><i>)</i><i>;</i>
    a<i>.</i><i>join</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>

    <i>println</i><i>!</i><i>(</i><i>&#34;counter = {counter}&#34;</i><i>)</i>
}
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo run
   Compiling lox v0.1.0 (/home/amos/bearcove/lox)
error[E0373]: closure may outlive the current function, but it borrows `counter`, which is owned by the current function
  --&gt; src/main.rs:12:19
   |
12 |     let a = spawn(|| do_work(&amp;mut counter));
   |                   ^^              ------- `counter` is borrowed here
   |                   |
   |                   may outlive borrowed value `counter`
   |
note: function requires argument type to outlive `&#39;static`
  --&gt; src/main.rs:12:13
   |
12 |     let a = spawn(|| do_work(&amp;mut counter));
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: to force the closure to take ownership of `counter` (and any other referenced variables), use the `move` keyword
   |
12 |     let a = spawn(move || do_work(&amp;mut counter));
   |                   ++++

error[E0502]: cannot borrow `counter` as immutable because it is also borrowed as mutable
  --&gt; src/main.rs:15:25
   |
12 |     let a = spawn(|| do_work(&amp;mut counter));
   |             -------------------------------
   |             |     |               |
   |             |     |               first borrow occurs due to use of `counter` in closure
   |             |     mutable borrow occurs here
   |             argument requires that `counter` is borrowed for `&#39;static`
...
15 |     println!(&#34;counter = {counter}&#34;)
   |                         ^^^^^^^^^ immutable borrow occurs here

Some errors have detailed explanations: E0373, E0502.
For more information about an error, try `rustc --explain E0373`.
error: could not compile `lox` due to 2 previous errors
</code></p></pre>
<p>Mh nope, it&#39;s already not happy. You can feel that the space of all legal
programs <em>really is</em> smaller.</p>
<p>So the issue here is that <code>do_work</code> is spawned in a thread, which might outlive
the parent thread. That&#39;s fair.</p>
<p>Let&#39;s try to make the counter a global instead.</p>
<pre><p>Rust code</p><p><code><i>use</i> std<i>::</i>thread<i>::</i>spawn<i>;</i>

<i>fn</i> <i>do_work</i><i>(</i><i>)</i> {
    <i>for</i> _ <i>in</i> <i>0</i>..<i>100_000</i> {
        COUNTER += <i>1</i>
    }
}

<i>static</i> <i>mut</i> COUNTER: <i>u64</i> = <i>0</i><i>;</i>

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> a = <i>spawn</i><i>(</i>|| <i>do_work</i><i>(</i><i>)</i><i>)</i><i>;</i>
    a<i>.</i><i>join</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>

    <i>println</i><i>!</i><i>(</i><i>&#34;counter = {COUNTER}&#34;</i><i>)</i>
}
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo run
   Compiling lox v0.1.0 (/home/amos/bearcove/lox)
error[E0133]: use of mutable static is unsafe and requires unsafe function or block
 --&gt; src/main.rs:5:9
  |
5 |         COUNTER += 1
  |         ^^^^^^^^^^^^ use of mutable static
  |
  = note: mutable statics can be mutated by multiple threads: aliasing violations or data races will cause undefined behavior

error[E0133]: use of mutable static is unsafe and requires unsafe function or block
  --&gt; src/main.rs:15:25
   |
15 |     println!(&#34;counter = {COUNTER}&#34;)
   |                         ^^^^^^^^^ use of mutable static
   |
   = note: mutable statics can be mutated by multiple threads: aliasing violations or data races will cause undefined behavior

For more information about this error, try `rustc --explain E0133`.
error: could not compile `lox` due to 2 previous errors
</code></p></pre>
<p>Huh. That&#39;s unsafe? <em>That</em> is unsafe?</p>
<p>Let&#39;s disregard that hint:</p>
<blockquote>
<p>note: mutable statics can be mutated by multiple threads: aliasing violations
or data races will cause undefined behavior </p>
</blockquote>
<p>...and step into unsafe territory.</p>
<pre><p>Rust code</p><p><code><i>use</i> std<i>::</i>thread<i>::</i>spawn<i>;</i>

<i>fn</i> <i>do_work</i><i>(</i><i>)</i> {
    <i>for</i> _ <i>in</i> <i>0</i>..<i>100_000</i> {
        <i>unsafe</i> { COUNTER += <i>1</i> }
    }
}

<i>static</i> <i>mut</i> COUNTER: <i>u64</i> = <i>0</i><i>;</i>

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> a = <i>spawn</i><i>(</i>|| <i>do_work</i><i>(</i><i>)</i><i>)</i><i>;</i>
    a<i>.</i><i>join</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>

    <i>println</i><i>!</i><i>(</i><i>&#34;counter = {}&#34;</i>, <i>unsafe</i> { COUNTER }<i>)</i>
}
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo run --quiet
counter = 100000
</code></p></pre>
<p>Well, that worked!</p>
<div>

<p>Yeah, but we only ever have one thread accessing <code>COUNTER</code>.</p>
</div>
<p>True, let&#39;s try two:</p>
<pre><p>Rust code</p><p><code><i>use</i> std<i>::</i>thread<i>::</i>spawn<i>;</i>

<i>fn</i> <i>do_work</i><i>(</i><i>)</i> {
    <i>for</i> _ <i>in</i> <i>0</i>..<i>100_000</i> {
        <i>unsafe</i> { COUNTER += <i>1</i> }
    }
}

<i>static</i> <i>mut</i> COUNTER: <i>u64</i> = <i>0</i><i>;</i>

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> a = <i>spawn</i><i>(</i>|| <i>do_work</i><i>(</i><i>)</i><i>)</i><i>;</i>
    <i>let</i> b = <i>spawn</i><i>(</i>|| <i>do_work</i><i>(</i><i>)</i><i>)</i><i>;</i>
    a<i>.</i><i>join</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
    b<i>.</i><i>join</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>

    <i>println</i><i>!</i><i>(</i><i>&#34;counter = {}&#34;</i>, <i>unsafe</i> { COUNTER }<i>)</i>
}
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo run --quiet
counter = 103946

$ cargo run --quiet
counter = 104384

$ cargo run --quiet
counter = 104845

$ cargo run --quiet
counter = 104596
</code></p></pre>
<p>Ahh there we have it! It feels like the threads are competing a lot more than
the tasks were in the Go version - we lost over 90 thousand increments there.</p>
<p>So, we reproduced the bug! But we had to use <code>unsafe</code> to do it.</p>
<p>It bothers me that we weren&#39;t able to make the one-worker version work though -
that one shouldn&#39;t have been an issue.</p>
<p>Until <a href="https://github.com/rust-lang/rfcs/pull/3151">this lands in the standard
library</a>, we can use
<a href="https://lib.rs/crates/crossbeam">crossbeam</a> to make it work:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>do_work</i><i>(</i><i>counter</i>: <i>&amp;</i><i>mut</i> <i>u64</i><i>)</i> {
    <i>for</i> _ <i>in</i> <i>0</i>..<i>100_000</i> {
        <i>*</i>counter += <i>1</i>
    }
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> <i>mut</i> counter = <i>0</i><i>;</i>

    crossbeam<i>::</i><i>scope</i><i>(</i>|s| {
        s<i>.</i><i>spawn</i><i>(</i>|_| <i>do_work</i><i>(</i><i>&amp;</i><i>mut</i> counter<i>)</i><i>)</i><i>;</i>
    }<i>)</i>
    <i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>

    <i>println</i><i>!</i><i>(</i><i>&#34;counter = {}&#34;</i>, counter<i>)</i>
}
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo run --quiet
counter = 100000
</code></p></pre>
<p>If we add a second task there, we can see one of the things Rust is <em>extremely</em>
concerned with:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>do_work</i><i>(</i><i>counter</i>: <i>&amp;</i><i>mut</i> <i>u64</i><i>)</i> {
    <i>for</i> _ <i>in</i> <i>0</i>..<i>100_000</i> {
        <i>*</i>counter += <i>1</i>
    }
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> <i>mut</i> counter = <i>0</i><i>;</i>

    crossbeam<i>::</i><i>scope</i><i>(</i>|s| {
        s<i>.</i><i>spawn</i><i>(</i>|_| <i>do_work</i><i>(</i><i>&amp;</i><i>mut</i> counter<i>)</i><i>)</i><i>;</i>
        s<i>.</i><i>spawn</i><i>(</i>|_| <i>do_work</i><i>(</i><i>&amp;</i><i>mut</i> counter<i>)</i><i>)</i><i>;</i>
    }<i>)</i>
    <i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>

    <i>println</i><i>!</i><i>(</i><i>&#34;counter = {}&#34;</i>, counter<i>)</i>
}
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo run --quiet
error[E0499]: cannot borrow `counter` as mutable more than once at a time
  --&gt; src/main.rs:12:17
   |
11 |         s.spawn(|_| do_work(&amp;mut counter));
   |                 ---              ------- first borrow occurs due to use of `counter` in closure
   |                 |
   |                 first mutable borrow occurs here
12 |         s.spawn(|_| do_work(&amp;mut counter));
   |           ----- ^^^              ------- second borrow occurs due to use of `counter` in closure
   |           |     |
   |           |     second mutable borrow occurs here
   |           first borrow later used by call

For more information about this error, try `rustc --explain E0499`.
error: could not compile `lox` due to previous error
</code></p></pre>
<p>It won&#39;t let us borrow something <em>mutably</em> more than once! Even if those two
tasks somehow never tried to mutate the counter in parallel, it would reject
that code. It won&#39;t let multiple mutable references to the same thing <em>exist</em>.</p>
<p>Instead, we can use an
<a href="https://doc.rust-lang.org/stable/std/sync/atomic/struct.AtomicU64.html">AtomicU64</a>,
just like we did in Go (although here it&#39;s straight up a different type):</p>
<pre><p>Rust code</p><p><code><i>use</i> std<i>::</i>sync<i>::</i>atomic<i>::</i>{AtomicU64, Ordering}<i>;</i>

<i>fn</i> <i>do_work</i><i>(</i><i>counter</i>: <i>&amp;</i><i>AtomicU64</i><i>)</i> {
    <i>for</i> _ <i>in</i> <i>0</i>..<i>100_000</i> {
        counter<i>.</i><i>fetch_add</i><i>(</i><i>1</i>, <i>Ordering</i><i>::</i>SeqCst<i>)</i><i>;</i>
    }
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> counter: <i>AtomicU64</i> = <i>Default</i><i>::</i><i>default</i><i>(</i><i>)</i><i>;</i>

    crossbeam<i>::</i><i>scope</i><i>(</i>|s| {
        s<i>.</i><i>spawn</i><i>(</i>|_| <i>do_work</i><i>(</i><i>&amp;</i>counter<i>)</i><i>)</i><i>;</i>
        s<i>.</i><i>spawn</i><i>(</i>|_| <i>do_work</i><i>(</i><i>&amp;</i>counter<i>)</i><i>)</i><i>;</i>
    }<i>)</i>
    <i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>

    <i>println</i><i>!</i><i>(</i><i>&#34;counter = {}&#34;</i>, counter.load<i>(</i>Ordering::SeqCst<i>)</i><i>)</i>
}
</code></p></pre>
<p>Note that we have to specify which ordering to use to perform a <code>fetch_add</code> or a
<code>load</code>: here I&#39;m using
<a href="https://doc.rust-lang.org/stable/std/sync/atomic/enum.Ordering.html#variant.SeqCst">SeqCst</a>,
which as far as I&#39;m aware is the strongest guarantee: all threads see all
sequentially consistent operations in the same order.</p>
<pre><p>Shell session</p><p><code>$ cargo run --quiet
counter = 200000

$ cargo run --quiet
counter = 200000

$ cargo run --quiet
counter = 200000

$ cargo run --quiet
counter = 200000
</code></p></pre>
<p>Alternatively, we can use some synchronization mechanism, like a
<a href="https://doc.rust-lang.org/stable/std/sync/struct.Mutex.html">Mutex</a>:</p>
<pre><p>Rust code</p><p><code><i>use</i> std<i>::</i>sync<i>::</i>Mutex<i>;</i>

<i>fn</i> <i>do_work</i><i>(</i><i>counter</i>: <i>&amp;</i><i>Mutex</i><i>&lt;</i><i>u64</i><i>&gt;</i><i>)</i> {
    <i>for</i> _ <i>in</i> <i>0</i>..<i>100_000</i> {
        <i>let</i> <i>mut</i> counter = counter<i>.</i><i>lock</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
        <i>*</i>counter += <i>1</i>
    }
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> counter: <i>Mutex</i><i>&lt;</i><i>u64</i><i>&gt;</i> = <i>Default</i><i>::</i><i>default</i><i>(</i><i>)</i><i>;</i>

    crossbeam<i>::</i><i>scope</i><i>(</i>|s| {
        s<i>.</i><i>spawn</i><i>(</i>|_| <i>do_work</i><i>(</i><i>&amp;</i>counter<i>)</i><i>)</i><i>;</i>
        s<i>.</i><i>spawn</i><i>(</i>|_| <i>do_work</i><i>(</i><i>&amp;</i>counter<i>)</i><i>)</i><i>;</i>
    }<i>)</i>
    <i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>

    <i>println</i><i>!</i><i>(</i><i>&#34;counter = {}&#34;</i>, counter.lock<i>(</i><i>)</i>.unwrap<i>(</i><i>)</i><i>)</i>
}
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo run --quiet
counter = 200000

$ cargo run --quiet
counter = 200000

$ cargo run --quiet
counter = 200000

$ cargo run --quiet
counter = 200000
</code></p></pre>
<p>And there&#39;s some very interesting things about that code, compared to the Go
version. First off, we&#39;re not handling a <code>(Mutex, u64)</code>, we&#39;re handling a
<code>Mutex&lt;u64&gt;</code>. There is no risk of accidentally manipulating the counter&#39;s value
without interacting with the lock.</p>
<p>Secondly, locking can <em>fail</em>. This is a feature: if a thread panics while
holding a lock to the mutex, the <code>std::sync::Mutex</code> type consider itself
&#34;poisoned&#34;. It takes the conservative point of view that the thread may have
panic in the middle of a multi-step update, and so some invariant may have been
broken.</p>
<p>It&#39;s still possible to recover from a <code>PoisonError</code> and get the inner data (at
which point you&#39;re supposed to check the invariants yourself, and if one of them
is not being upheld, you can panic). Most codebases I&#39;ve seen just propagate
poison errors, though.</p>
<p>But also, most codebases I&#39;ve seen prefer to use the <code>Mutex</code> from
<a href="https://lib.rs/crates/parking_lot">parking_lot</a>, which has several advantages
listed in its documentation, and also makes different design choices: should
a thread panic whilst holding a lock, the mutex is simply unlocked.</p>
<pre><p>Rust code</p><p><code><i>use</i> parking_lot<i>::</i>Mutex<i>;</i>

<i>fn</i> <i>do_work</i><i>(</i><i>counter</i>: <i>&amp;</i><i>Mutex</i><i>&lt;</i><i>u64</i><i>&gt;</i><i>)</i> {
    <i>for</i> _ <i>in</i> <i>0</i>..<i>100_000</i> {
        <i>// ðŸ‘‡ no more .unwrap()!</i>
        <i>let</i> <i>mut</i> counter = counter<i>.</i><i>lock</i><i>(</i><i>)</i><i>;</i>
        <i>*</i>counter += <i>1</i>
    }
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> counter: <i>Mutex</i><i>&lt;</i><i>u64</i><i>&gt;</i> = <i>Default</i><i>::</i><i>default</i><i>(</i><i>)</i><i>;</i>

    crossbeam<i>::</i><i>scope</i><i>(</i>|s| {
        s<i>.</i><i>spawn</i><i>(</i>|_| <i>do_work</i><i>(</i><i>&amp;</i>counter<i>)</i><i>)</i><i>;</i>
        s<i>.</i><i>spawn</i><i>(</i>|_| <i>do_work</i><i>(</i><i>&amp;</i>counter<i>)</i><i>)</i><i>;</i>
    }<i>)</i>
    <i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>

    <i>// ðŸ‘‡ no more .unwrap()!</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;counter = {}&#34;</i>, counter.lock<i>(</i><i>)</i><i>)</i>
}
</code></p></pre>
<p>The third noteworthy thing is that we... never unlock the mutex? Not explicitly
at least.</p>
<p>In the Go version, we had to explicity call <code>Lock()</code> and <code>Unlock()</code> - if we
forget to call <code>Unlock()</code>, things go south:</p>
<pre><p>Go code</p><p><code><i>package</i> main

<i>import</i> (
  <i>&#34;log&#34;</i>
  <i>&#34;sync&#34;</i>
)

<i>func</i> <i>doWork</i>(<i>counter</i> <i>*</i><i>int64</i>, <i>mutex</i> <i>*</i>sync.<i>Mutex</i>) {
  <i>for</i> <i>i</i> <i>:=</i> 0; <i>i</i> <i>&lt;</i> 100000; <i>i</i><i>++</i> {
    <i>mutex</i>.<i>Lock</i>()
    <i>*</i><i>counter</i> <i>+=</i> 1
    <i>// ðŸ‘‡ woops, no unlock!</i>
  }
}

<i>func</i> <i>main</i>() {
  <i>var</i> <i>wg</i> sync.<i>WaitGroup</i>
  <i>var</i> <i>counter</i> <i>int64</i> <i>=</i> 0
  <i>var</i> <i>mutex</i> sync.<i>Mutex</i>

  <i>for</i> <i>i</i> <i>:=</i> 0; <i>i</i> <i>&lt;</i> 2; <i>i</i><i>++</i> {
    <i>wg</i>.<i>Add</i>(1)
    <i>go</i> <i>func</i>() {
      <i>defer</i> <i>wg</i>.<i>Done</i>()
      <i>doWork</i>(<i>&amp;</i><i>counter</i>, <i>&amp;</i><i>mutex</i>)
    }()
  }

  <i>wg</i>.<i>Wait</i>()
  <i>log</i>.<i>Printf</i>(<i>&#34;counter = %v&#34;</i>, <i>counter</i>)
}
</code></p></pre>
<p>And we have... a deadlock. No progress will ever be made again, because every
goroutine is waiting to acquire the same lock, and the already-held lock will
never be released.</p>
<pre><p>Shell session</p><p><code>$ go run ./sample.go
fatal error: all goroutines are asleep - deadlock!

goroutine 1 [semacquire]:
sync.runtime_Semacquire(0x0)
        /usr/local/go/src/runtime/sema.go:56 +0x25
sync.(*WaitGroup).Wait(0xc000114000)
        /usr/local/go/src/sync/waitgroup.go:130 +0x71
main.main()
        /home/amos/bearcove/lox/sample.go:29 +0xfb

goroutine 18 [semacquire]:
sync.runtime_SemacquireMutex(0x0, 0x0, 0x0)
        /usr/local/go/src/runtime/sema.go:71 +0x25
sync.(*Mutex).lockSlow(0xc00013a018)
        /usr/local/go/src/sync/mutex.go:138 +0x165
sync.(*Mutex).Lock(...)
        /usr/local/go/src/sync/mutex.go:81
main.doWork(0xc00013a010, 0xc00013a018)
        /home/amos/bearcove/lox/sample.go:10 +0x58
main.main.func1()
        /home/amos/bearcove/lox/sample.go:25 +0x5c
created by main.main
        /home/amos/bearcove/lox/sample.go:23 +0x5a

goroutine 19 [semacquire]:
sync.runtime_SemacquireMutex(0x0, 0x0, 0x0)
        /usr/local/go/src/runtime/sema.go:71 +0x25
sync.(*Mutex).lockSlow(0xc00013a018)
        /usr/local/go/src/sync/mutex.go:138 +0x165
sync.(*Mutex).Lock(...)
        /usr/local/go/src/sync/mutex.go:81
main.doWork(0xc00013a010, 0xc00013a018)
        /home/amos/bearcove/lox/sample.go:10 +0x58
main.main.func1()
        /home/amos/bearcove/lox/sample.go:25 +0x5c
created by main.main
        /home/amos/bearcove/lox/sample.go:23 +0x5a
exit status 2
</code></p></pre>
<p>Thankfully, the Go runtime detects that simple case and lets us know exactly
what&#39;s going on in each goroutine.</p>
<p>However, if there&#39;s even one other goroutine still doing work, we&#39;re on our own:</p>
<pre><p>Go code</p><p><code><i>// omitted: everything except main</i>

<i>func</i> <i>main</i>() {
  <i>go</i> <i>func</i>() {
    <i>for</i> {
      <i>time</i>.<i>Sleep</i>(<i>time</i>.<i>Second</i>)
    }
  }()

  <i>var</i> <i>wg</i> sync.<i>WaitGroup</i>
  <i>var</i> <i>counter</i> <i>int64</i> <i>=</i> 0
  <i>var</i> <i>mutex</i> sync.<i>Mutex</i>

  <i>for</i> <i>i</i> <i>:=</i> 0; <i>i</i> <i>&lt;</i> 2; <i>i</i><i>++</i> {
    <i>wg</i>.<i>Add</i>(1)
    <i>go</i> <i>func</i>() {
      <i>defer</i> <i>wg</i>.<i>Done</i>()
      <i>doWork</i>(<i>&amp;</i><i>counter</i>, <i>&amp;</i><i>mutex</i>)
    }()
  }

  <i>wg</i>.<i>Wait</i>()
  <i>log</i>.<i>Printf</i>(<i>&#34;counter = %v&#34;</i>, <i>counter</i>)
}
</code></p></pre><pre><p>Shell session</p><p><code>$ go run ./sample.go

(no output, ever)
</code></p></pre>
<p>Out of fairness to Go, I must mention the built-in &#34;net/http/pprof&#34; package,
which lets you start an HTTP server you can use to troubleshoot situations like
that.</p>
<p>The <a href="https://pkg.go.dev/net/http/pprof">docs for <code>net/http/pprof</code></a> have the most
up-to-date guide on how to set it up. In my case I just added the following:</p>
<pre><p>Go code</p><p><code><i>import</i> _ <i>&#34;net/http/pprof&#34;</i>
<i>// omitted: other imports</i>

<i>func</i> <i>main</i>() {
  <i>log</i>.<i>Println</i>(<i>http</i>.<i>ListenAndServe</i>(<i>&#34;localhost:6060&#34;</i>, <i>nil</i>))
  
  <i>// omitted: rest of main</i>
}
</code></p></pre>
<p>And then we get this:</p>
<pre><p>Shell session</p><p><code>$ go run ./sample.go

</code></p></pre>
<p>And if we make a request to <code>localhost:6060</code>, we get:</p>
<pre><p>Shell session</p><p><code>$ curl &#39;http://localhost:6060/debug/pprof/goroutine?debug=1&#39;
goroutine profile: total 3
1 @ 0x439236 0x431bf3 0x4631e9 0x4a91d2 0x4aa86c 0x4aa859 0x5456f5 0x5569c8 0x555d1d 0x5f7334 0x5f6f5d 0x6464a5 0x646479 0x438e67 0x468641
#       0x4631e8        internal/poll.runtime_pollWait+0x88             /usr/local/go/src/runtime/netpoll.go:234
#       0x4a91d1        internal/poll.(*pollDesc).wait+0x31             /usr/local/go/src/internal/poll/fd_poll_runtime.go:84
#       0x4aa86b        internal/poll.(*pollDesc).waitRead+0x22b        /usr/local/go/src/internal/poll/fd_poll_runtime.go:89
#       0x4aa858        internal/poll.(*FD).Accept+0x218                /usr/local/go/src/internal/poll/fd_unix.go:402
#       0x5456f4        net.(*netFD).accept+0x34                        /usr/local/go/src/net/fd_unix.go:173
#       0x5569c7        net.(*TCPListener).accept+0x27                  /usr/local/go/src/net/tcpsock_posix.go:140
#       0x555d1c        net.(*TCPListener).Accept+0x3c                  /usr/local/go/src/net/tcpsock.go:262
#       0x5f7333        net/http.(*Server).Serve+0x393                  /usr/local/go/src/net/http/server.go:3002
#       0x5f6f5c        net/http.(*Server).ListenAndServe+0x7c          /usr/local/go/src/net/http/server.go:2931
#       0x6464a4        net/http.ListenAndServe+0x44                    /usr/local/go/src/net/http/server.go:3185
#       0x646478        main.main+0x18                                  /home/amos/bearcove/lox/sample.go:20
#       0x438e66        runtime.main+0x226                              /usr/local/go/src/runtime/proc.go:255

1 @ 0x462d85 0x638af5 0x63890d 0x635a8b 0x64469a 0x64524e 0x5f418f 0x5f5a89 0x5f6dbb 0x5f34e8 0x468641
#       0x462d84        runtime/pprof.runtime_goroutineProfileWithLabels+0x24   /usr/local/go/src/runtime/mprof.go:746
#       0x638af4        runtime/pprof.writeRuntimeProfile+0xb4                  /usr/local/go/src/runtime/pprof/pprof.go:724
#       0x63890c        runtime/pprof.writeGoroutine+0x4c                       /usr/local/go/src/runtime/pprof/pprof.go:684
#       0x635a8a        runtime/pprof.(*Profile).WriteTo+0x14a                  /usr/local/go/src/runtime/pprof/pprof.go:331
#       0x644699        net/http/pprof.handler.ServeHTTP+0x499                  /usr/local/go/src/net/http/pprof/pprof.go:253
#       0x64524d        net/http/pprof.Index+0x12d                              /usr/local/go/src/net/http/pprof/pprof.go:371
#       0x5f418e        net/http.HandlerFunc.ServeHTTP+0x2e                     /usr/local/go/src/net/http/server.go:2047
#       0x5f5a88        net/http.(*ServeMux).ServeHTTP+0x148                    /usr/local/go/src/net/http/server.go:2425
#       0x5f6dba        net/http.serverHandler.ServeHTTP+0x43a                  /usr/local/go/src/net/http/server.go:2879
#       0x5f34e7        net/http.(*conn).serve+0xb07                            /usr/local/go/src/net/http/server.go:1930

1 @ 0x468641
</code></p></pre>
<p>Wait... that&#39;s not right. I&#39;m only seeing the HTTP server&#39;s goroutines here...</p>
<p>Oh! OH! We&#39;re supposed to <em>spawn</em> the server in its own goroutine haha, what a
silly mistake. I hope no one else ever does that silly silly mistake. It&#39;s
probably just me.</p>
<pre><p>Go code</p><p><code><i>// omitted: everything else</i>

<i>func</i> <i>main</i>() {
  <i>go</i> <i>log</i>.<i>Println</i>(<i>http</i>.<i>ListenAndServe</i>(<i>&#34;localhost:6060&#34;</i>, <i>nil</i>))

  <i>// etc.</i>
}
</code></p></pre>
<p>Mhh, still only seeing the HTTP goroutines.</p>
<p>Jeeze, I keep making so many mistakes with such a simple language, I must really
be dense or something.</p>
<p>Let&#39;s see... ah! We have to wrap it all in a closure, otherwise it waits for
<code>http.ListenAndServe</code> to return, so it can <em>then</em> spawn <code>log.Println</code> on its
own goroutine.</p>
<p>Silly me.</p>
<pre><p>Go code</p><p><code><i>// omitted: everything else</i>

<i>func</i> <i>main</i>() {
  <i>go</i> <i>func</i>() {
    <i>log</i>.<i>Println</i>(<i>http</i>.<i>ListenAndServe</i>(<i>&#34;localhost:6060&#34;</i>, <i>nil</i>))
  }()

  <i>// etc.</i>
}
</code></p></pre><pre><p>Shell session</p><p><code>$ curl &#39;http://localhost:6060/debug/pprof/goroutine?debug=1&#39;
goroutine profile: total 7
2 @ 0x439236 0x449eac 0x449e86 0x464845 0x479f05 0x646418 0x64642d 0x64663c 0x468641
#       0x464844        sync.runtime_SemacquireMutex+0x24       /usr/local/go/src/runtime/sema.go:71
#       0x479f04        sync.(*Mutex).lockSlow+0x164            /usr/local/go/src/sync/mutex.go:138
#       0x646417        sync.(*Mutex).Lock+0x57                 /usr/local/go/src/sync/mutex.go:81
#       0x64642c        main.doWork+0x6c                        /home/amos/bearcove/lox/sample.go:13
#       0x64663b        main.main.func3+0x5b                    /home/amos/bearcove/lox/sample.go:38

1 @ 0x439236 0x431bf3 0x4631e9 0x4a91d2 0x4aa86c 0x4aa859 0x5456f5 0x5569c8 0x555d1d 0x5f7334 0x5f6f5d 0x646725 0x6466f5 0x468641
#       0x4631e8        internal/poll.runtime_pollWait+0x88             /usr/local/go/src/runtime/netpoll.go:234
#       0x4a91d1        internal/poll.(*pollDesc).wait+0x31             /usr/local/go/src/internal/poll/fd_poll_runtime.go:84
#       0x4aa86b        internal/poll.(*pollDesc).waitRead+0x22b        /usr/local/go/src/internal/poll/fd_poll_runtime.go:89
#       0x4aa858        internal/poll.(*FD).Accept+0x218                /usr/local/go/src/internal/poll/fd_unix.go:402
#       0x5456f4        net.(*netFD).accept+0x34                        /usr/local/go/src/net/fd_unix.go:173
#       0x5569c7        net.(*TCPListener).accept+0x27                  /usr/local/go/src/net/tcpsock_posix.go:140
#       0x555d1c        net.(*TCPListener).Accept+0x3c                  /usr/local/go/src/net/tcpsock.go:262
#       0x5f7333        net/http.(*Server).Serve+0x393                  /usr/local/go/src/net/http/server.go:3002
#       0x5f6f5c        net/http.(*Server).ListenAndServe+0x7c          /usr/local/go/src/net/http/server.go:2931
#       0x646724        net/http.ListenAndServe+0x44                    /usr/local/go/src/net/http/server.go:3185
#       0x6466f4        main.main.func1+0x14                            /home/amos/bearcove/lox/sample.go:21

1 @ 0x439236 0x449eac 0x449e86 0x464725 0x47b751 0x64657b 0x438e67 0x468641
#       0x464724        sync.runtime_Semacquire+0x24    /usr/local/go/src/runtime/sema.go:56
#       0x47b750        sync.(*WaitGroup).Wait+0x70     /usr/local/go/src/sync/waitgroup.go:130
#       0x64657a        main.main+0x11a                 /home/amos/bearcove/lox/sample.go:42
#       0x438e66        runtime.main+0x226              /usr/local/go/src/runtime/proc.go:255

1 @ 0x439236 0x4654ce 0x64679e 0x468641
#       0x4654cd        time.Sleep+0x12d        /usr/local/go/src/runtime/time.go:193
#       0x64679d        main.main.func2+0x1d    /home/amos/bearcove/lox/sample.go:26

1 @ 0x462d85 0x638af5 0x63890d 0x635a8b 0x64469a 0x64524e 0x5f418f 0x5f5a89 0x5f6dbb 0x5f34e8 0x468641
#       0x462d84        runtime/pprof.runtime_goroutineProfileWithLabels+0x24   /usr/local/go/src/runtime/mprof.go:746
#       0x638af4        runtime/pprof.writeRuntimeProfile+0xb4                  /usr/local/go/src/runtime/pprof/pprof.go:724
#       0x63890c        runtime/pprof.writeGoroutine+0x4c                       /usr/local/go/src/runtime/pprof/pprof.go:684
#       0x635a8a        runtime/pprof.(*Profile).WriteTo+0x14a                  /usr/local/go/src/runtime/pprof/pprof.go:331
#       0x644699        net/http/pprof.handler.ServeHTTP+0x499                  /usr/local/go/src/net/http/pprof/pprof.go:253
#       0x64524d        net/http/pprof.Index+0x12d                              /usr/local/go/src/net/http/pprof/pprof.go:371
#       0x5f418e        net/http.HandlerFunc.ServeHTTP+0x2e                     /usr/local/go/src/net/http/server.go:2047
#       0x5f5a88        net/http.(*ServeMux).ServeHTTP+0x148                    /usr/local/go/src/net/http/server.go:2425
#       0x5f6dba        net/http.serverHandler.ServeHTTP+0x43a                  /usr/local/go/src/net/http/server.go:2879
#       0x5f34e7        net/http.(*conn).serve+0xb07                            /usr/local/go/src/net/http/server.go:1930

1 @ 0x496ae5 0x494e2d 0x4a9da5 0x4a9d8d 0x4a9b45 0x544529 0x54ee45 0x5ed6bf 0x468641
#       0x496ae4        syscall.Syscall+0x4                             /usr/local/go/src/syscall/asm_linux_amd64.s:20
#       0x494e2c        syscall.read+0x4c                               /usr/local/go/src/syscall/zsyscall_linux_amd64.go:687
#       0x4a9da4        syscall.Read+0x284                              /usr/local/go/src/syscall/syscall_unix.go:189
#       0x4a9d8c        internal/poll.ignoringEINTRIO+0x26c             /usr/local/go/src/internal/poll/fd_unix.go:582
#       0x4a9b44        internal/poll.(*FD).Read+0x24                   /usr/local/go/src/internal/poll/fd_unix.go:163
#       0x544528        net.(*netFD).Read+0x28                          /usr/local/go/src/net/fd_posix.go:56
#       0x54ee44        net.(*conn).Read+0x44                           /usr/local/go/src/net/net.go:183
#       0x5ed6be        net/http.(*connReader).backgroundRead+0x3e      /usr/local/go/src/net/http/server.go:672
</code></p></pre>
<p>Ahh, now we see all our goroutines. So yeah, pprof is pretty neat! It has a lot
more features than what I&#39;ve shown here, you should go read up on it.</p>
<div>
<div>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><path d="M21.41 41.398c.148-1.787.337-3.572.574-5.351.369-2.772 4.393-11.308 5.624-12.882l.553-.706-1.344-.449a5.772 5.772 0 0 1-3.948-5.478 5.786 5.786 0 0 1 5.779-5.78 5.768 5.768 0 0 1 5.684 4.758l.249 1.396 1.231-.704a28.845 28.845 0 0 1 14.282-3.801c4.991 0 9.93 1.314 14.282 3.801l1.231.704.249-1.396a5.766 5.766 0 0 1 5.683-4.758 5.786 5.786 0 0 1 5.779 5.78 5.772 5.772 0 0 1-3.948 5.478l-1.344.449.552.705c1.911 2.44 2.55 2.541 3.563 5.599 1.422 4.293 2.923 7.964 2.923 12.61v49.875h2V41.373c0-6.519-2.008-12.717-5.819-18.005a7.768 7.768 0 0 0 4.072-6.836c0-4.29-3.49-7.78-7.779-7.78a7.766 7.766 0 0 0-7.3 5.1 30.834 30.834 0 0 0-14.146-3.45 30.834 30.834 0 0 0-14.146 3.45 7.766 7.766 0 0 0-7.301-5.1c-4.289 0-7.779 3.49-7.779 7.78a7.766 7.766 0 0 0 4.072 6.836c-6.681 9.271-5.976 21.037-5.992 32.034-.017 11.946.656 23.895.109 35.838l2.006-.001c.67 0-.17-33.831-.156-36.912.022-4.312.148-8.631.505-12.929z"></path><path d="M73.854 31.271v-4.494c0-.971-.79-1.76-1.761-1.76H55.235c-.604 0-1.3.869-1.778 1.905-.015 0-.027-.008-.042-.008H46.789c-.02 0-.037.011-.057.011-.478-1.037-1.175-1.908-1.779-1.908H28.094c-.971 0-1.761.79-1.761 1.76v4.494c0 4.477 3.643 8.119 8.119 8.119h5.12c4.265 0 7.734-3.47 7.734-7.734v-2.091H52.878v2.091c0 4.265 3.47 7.734 7.734 7.734h5.121c4.479-.001 8.121-3.643 8.121-8.119zm-41.713 3.192a1.387 1.387 0 0 1-1.917-.442 1.392 1.392 0 0 1 .442-1.917l8.403-5.255a1.392 1.392 0 0 1 1.475 2.359l-8.403 5.255zm11.163-2.18l-5.75 3.597a.95.95 0 0 1-1.313-.302.952.952 0 0 1 .303-1.312l5.75-3.597a.953.953 0 0 1 1.01 1.614zm15.168 1.935a1.387 1.387 0 0 1-1.917-.442 1.392 1.392 0 0 1 .442-1.917l8.403-5.255a1.392 1.392 0 0 1 1.475 2.359l-8.403 5.255zm4.909 1.561a.953.953 0 0 1-.506-1.759l5.75-3.597a.952.952 0 1 1 1.01 1.614l-5.75 3.597a.942.942 0 0 1-.504.145z"></path><path d="M59.705 45.232h-2c0 1.823-1.483 3.306-3.306 3.306s-3.306-1.483-3.306-3.306v-1.439h1.06a3.294 3.294 0 0 0 3.285-3.285v-.17c0-.259-.038-.508-.095-.749a3.291 3.291 0 0 0-2.665-2.482 3.243 3.243 0 0 0-.525-.053h-4.12c-.18 0-.353.025-.525.053a3.291 3.291 0 0 0-2.665 2.482 3.255 3.255 0 0 0-.095.749v.17a3.294 3.294 0 0 0 3.285 3.285h1.06v1.439a3.31 3.31 0 0 1-3.307 3.306 3.31 3.31 0 0 1-3.306-3.306h-2a5.312 5.312 0 0 0 5.306 5.306 5.293 5.293 0 0 0 4.306-2.229 5.294 5.294 0 0 0 4.306 2.229 5.313 5.313 0 0 0 5.307-5.306zM29.742 58.336a.703.703 0 0 0-1.406 0v5.368a.704.704 0 0 0 1.406 0v-5.368zM43.779 58.336a.703.703 0 0 0-1.406 0v5.368a.704.704 0 0 0 1.406 0v-5.368zM57.816 58.336a.703.703 0 0 0-1.407 0v5.368a.704.704 0 0 0 1.407 0v-5.368zM71.853 58.336a.704.704 0 0 0-1.407 0v5.368a.704.704 0 0 0 1.407 0v-5.368zM35.354 71.559v5.369a.703.703 0 0 0 1.406 0v-5.369a.703.703 0 0 0-1.406 0zM49.39 71.559v5.369a.704.704 0 0 0 1.407 0v-5.369a.703.703 0 0 0-1.407 0zM63.427 71.559v5.369a.704.704 0 0 0 1.407 0v-5.369a.703.703 0 0 0-1.407 0zM29.038 81.364a.703.703 0 0 0-.703.703v5.369a.703.703 0 0 0 1.406 0v-5.369a.703.703 0 0 0-.703-.703zM43.076 81.364a.703.703 0 0 0-.703.703v5.369a.703.703 0 0 0 1.406 0v-5.369a.705.705 0 0 0-.703-.703zM57.113 81.364a.704.704 0 0 0-.704.703v5.369a.704.704 0 0 0 1.407 0v-5.369a.705.705 0 0 0-.703-.703zM71.149 81.364a.703.703 0 0 0-.703.703v5.369a.703.703 0 0 0 1.407 0v-5.369a.705.705 0 0 0-.704-.703z"></path></svg><p>
Cool bear&#39;s hot tip
</p></div>
<p>A similar tool in Rust land would be
<a href="https://lib.rs/crates/tokio-console">tokio-console</a>, which I&#39;m <em>very</em> excited
about.</p>
</div>
<p>So, back to our Rust example!</p>
<p>So we had that:</p>
<pre><p>Rust code</p><p><code><i>use</i> parking_lot<i>::</i>Mutex<i>;</i>

<i>fn</i> <i>do_work</i><i>(</i><i>counter</i>: <i>&amp;</i><i>Mutex</i><i>&lt;</i><i>u64</i><i>&gt;</i><i>)</i> {
    <i>for</i> _ <i>in</i> <i>0</i>..<i>100_000</i> {
        <i>let</i> <i>mut</i> counter = counter<i>.</i><i>lock</i><i>(</i><i>)</i><i>;</i>
        <i>*</i>counter += <i>1</i>
    }
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> counter: <i>Mutex</i><i>&lt;</i><i>u64</i><i>&gt;</i> = <i>Default</i><i>::</i><i>default</i><i>(</i><i>)</i><i>;</i>

    crossbeam<i>::</i><i>scope</i><i>(</i>|s| {
        s<i>.</i><i>spawn</i><i>(</i>|_| <i>do_work</i><i>(</i><i>&amp;</i>counter<i>)</i><i>)</i><i>;</i>
        s<i>.</i><i>spawn</i><i>(</i>|_| <i>do_work</i><i>(</i><i>&amp;</i>counter<i>)</i><i>)</i><i>;</i>
    }<i>)</i>
    <i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>

    <i>println</i><i>!</i><i>(</i><i>&#34;counter = {}&#34;</i>, counter.lock<i>(</i><i>)</i><i>)</i>
}
</code></p></pre>
<p>And I said it&#39;s interesting how we don&#39;t have to unlock the mutex explicitly:
because the <code>counter</code> in <code>let mut counter</code>, in <code>fn do_work()</code>, is actually a
<code>MutexGuard&lt;u64&gt;</code>, and that type has a <code>Drop</code> implementation: so the <code>Mutex</code>
simply gets unlocked when the guard falls out of scope.</p>
<p>In Go, the <code>defer mutex.Unlock()</code> pattern can be used to get <em>part of the way
there</em>... but it&#39;s not quite the same.</p>
<p>See this example:</p>
<pre><p>Go code</p><p><code><i>package</i> main

<i>import</i> (
  <i>&#34;log&#34;</i>
  _ <i>&#34;net/http/pprof&#34;</i>
  <i>&#34;sync&#34;</i>
)

<i>func</i> <i>doWork</i>(<i>counter</i> <i>*</i><i>int64</i>, <i>mutex</i> <i>*</i>sync.<i>Mutex</i>) {
  <i>for</i> <i>i</i> <i>:=</i> 0; <i>i</i> <i>&lt;</i> 100000; <i>i</i><i>++</i> {
    <i>mutex</i>.<i>Lock</i>()
    <i>defer</i> <i>mutex</i>.<i>Unlock</i>()
    <i>*</i><i>counter</i> <i>+=</i> 1
  }
}

<i>func</i> <i>main</i>() {
  <i>var</i> <i>wg</i> sync.<i>WaitGroup</i>
  <i>var</i> <i>counter</i> <i>int64</i> <i>=</i> 0
  <i>var</i> <i>mutex</i> sync.<i>Mutex</i>

  <i>for</i> <i>i</i> <i>:=</i> 0; <i>i</i> <i>&lt;</i> 2; <i>i</i><i>++</i> {
    <i>wg</i>.<i>Add</i>(1)
    <i>go</i> <i>func</i>() {
      <i>defer</i> <i>wg</i>.<i>Done</i>()
      <i>doWork</i>(<i>&amp;</i><i>counter</i>, <i>&amp;</i><i>mutex</i>)
    }()
  }

  <i>wg</i>.<i>Wait</i>()
  <i>log</i>.<i>Printf</i>(<i>&#34;counter = %v&#34;</i>, <i>counter</i>)
}
</code></p></pre>
<p>This hangs forever.</p>
<p>We don&#39;t even get the nice &#34;automatic deadlock detection&#34;, which <em>I warned you</em>
only works for trivial cases - because we still have that import in there:</p>
<pre><p>Go code</p><p><code><i>import</i> 	_ <i>&#34;net/http/pprof&#34;</i>
</code></p></pre>
<p>Did you notice that? I sure hadn&#39;t.</p>
<p>And that import has an <code>init</code> function, which apparently ends up starting a
goroutine, so the deadlock detection mechanism is defeated (even though we
haven&#39;t actually started an HTTP server yet!)</p>
<p>But the meat of the problem is this: <code>defer</code> defers a function call <em>until the
ambient function exits</em>. Not until the end of the scope.</p>
<p>So this perfectly innocent snippet:</p>
<pre><p>Go code</p><p><code><i>func</i> <i>doWork</i>(<i>counter</i> <i>*</i><i>int64</i>, <i>mutex</i> <i>*</i>sync.<i>Mutex</i>) {
  <i>for</i> <i>i</i> <i>:=</i> 0; <i>i</i> <i>&lt;</i> 100000; <i>i</i><i>++</i> {
    <i>mutex</i>.<i>Lock</i>()
    <i>defer</i> <i>mutex</i>.<i>Unlock</i>()
    <i>*</i><i>counter</i> <i>+=</i> 1
  }
}
</code></p></pre>
<p>Is completely wrong.</p>
<p>So, another common pattern is to do this instead:</p>
<pre><p>Go code</p><p><code><i>func</i> <i>doWork</i>(<i>counter</i> <i>*</i><i>int64</i>, <i>mutex</i> <i>*</i>sync.<i>Mutex</i>) {
  <i>for</i> <i>i</i> <i>:=</i> 0; <i>i</i> <i>&lt;</i> 100000; <i>i</i><i>++</i> {
    <i>func</i>() {
      <i>mutex</i>.<i>Lock</i>()
      <i>defer</i> <i>mutex</i>.<i>Unlock</i>()
      <i>*</i><i>counter</i> <i>+=</i> 1
    }()
  }
}
</code></p></pre>
<p>And <em>that</em> does the right thing.</p>
<p>Do you see a pattern here? I pinky swear I&#39;m not even <em>trying</em> to find things
to complain about in Go: none of this was planned, it just... came up. While
I was writing to write <em>pretty simple</em> sample code.</p>
<p>And there&#39;s more. <a href="https://fasterthanli.me/articles/i-want-off-mr-golangs-wild-ride">Much more</a>.</p>
<p>Just as a comparison point, the following code works as expected:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>do_work</i><i>(</i><i>counter</i>: <i>&amp;</i><i>Mutex</i><i>&lt;</i><i>u64</i><i>&gt;</i><i>)</i> {
    <i>for</i> _ <i>in</i> <i>0</i>..<i>100_000</i> {
        {
            <i>let</i> <i>mut</i> counter = counter<i>.</i><i>lock</i><i>(</i><i>)</i><i>;</i>
            <i>*</i>counter += <i>1</i>
        }
        {
            <i>let</i> <i>mut</i> counter = counter<i>.</i><i>lock</i><i>(</i><i>)</i><i>;</i>
            <i>*</i>counter += <i>1</i>
        }
    }
}
</code></p></pre>
<p>Those are two distinct scopes, the first guard is dropped before the second
guard has a chance to exist, everything is fine.</p>
<h2>You can&#39;t use an old map to explore a new world</h2>
<p>Let&#39;s have another example:</p>
<pre><p>Go code</p><p><code><i>package</i> main

<i>import</i> (
  <i>&#34;log&#34;</i>
  <i>&#34;math/rand&#34;</i>
  <i>&#34;sync&#34;</i>
)

<i>func</i> <i>doWork</i>(<i>m</i> <i>map</i>[<i>uint64</i>]<i>uint64</i>) {
  <i>for</i> <i>i</i> <i>:=</i> 0; <i>i</i> <i>&lt;</i> 100; <i>i</i><i>++</i> {
    <i>key</i> <i>:=</i> <i>uint64</i>(<i>rand</i>.<i>Intn</i>(10))
    <i>m</i>[<i>key</i>] <i>+=</i> 1
  }
}

<i>func</i> <i>main</i>() {
  <i>var</i> <i>wg</i> sync.<i>WaitGroup</i>
  <i>var</i> <i>m</i> <i>map</i>[<i>uint64</i>]<i>uint64</i>

  <i>for</i> <i>i</i> <i>:=</i> 0; <i>i</i> <i>&lt;</i> 2; <i>i</i><i>++</i> {
    <i>wg</i>.<i>Add</i>(1)
    <i>go</i> <i>func</i>() {
      <i>defer</i> <i>wg</i>.<i>Done</i>()
      <i>doWork</i>(<i>m</i>)
    }()
  }

  <i>wg</i>.<i>Wait</i>()
  <i>log</i>.<i>Printf</i>(<i>&#34;map = %#v&#34;</i>, <i>m</i>)
}
</code></p></pre>
<p>What do you think happens here? We have two tasks mutating the same map
concurrently. Some concurrency-related shenanigans are bound to happen!</p>
<p>Surely!</p>
<pre><p>Shell session</p><p><code>$ go run ./sample.go
panic: assignment to entry in nil map

goroutine 7 [running]:
main.doWork(0x0)
        /home/amos/bearcove/lox/sample.go:12 +0x48
main.main.func1()
        /home/amos/bearcove/lox/sample.go:24 +0x58
created by main.main
        /home/amos/bearcove/lox/sample.go:22 +0x45
exit status 2
</code></p></pre>
<p>Oh! Nevermind! That&#39;s not concurrency-related at all.</p>
<p>That&#39;s just the zero value for a Go map (nil) being half-useful!</p>
<p>We can use <code>len()</code> to get its length, and we can read from it - we just can&#39;t
assign to it:</p>
<pre><p>Go code</p><p><code><i>package</i> main

<i>import</i> <i>&#34;log&#34;</i>

<i>func</i> <i>main</i>() {
  <i>var</i> <i>m</i> <i>map</i>[<i>uint64</i>]<i>uint64</i>
  <i>log</i>.<i>Printf</i>(<i>&#34;len(m) = %v&#34;</i>, <i>len</i>(<i>m</i>))
  <i>log</i>.<i>Printf</i>(<i>&#34;m[234] = %v&#34;</i>, <i>m</i>[234])
  <i>m</i>[234] <i>=</i> 432
}
</code></p></pre><pre><p>Shell session</p><p><code>$ go run ./scratch.go
2022/02/07 22:47:56 len(m) = 0
2022/02/07 22:47:56 m[234] = 0
panic: assignment to entry in nil map

goroutine 1 [running]:
main.main()
        /home/amos/bearcove/lox/scratch.go:9 +0xb8
exit status 2
</code></p></pre>
<p>So, let&#39;s fix that bug and look at our actual concurrency-related problem:</p>
<pre><p>Go code</p><p><code><i>// omitted: everything except main</i>

<i>func</i> <i>main</i>() {
  <i>var</i> <i>wg</i> sync.<i>WaitGroup</i>
  <i>m</i> <i>:=</i> <i>make</i>(<i>map</i>[<i>uint64</i>]<i>uint64</i>)

  <i>for</i> <i>i</i> <i>:=</i> 0; <i>i</i> <i>&lt;</i> 2; <i>i</i><i>++</i> {
    <i>wg</i>.<i>Add</i>(1)
    <i>go</i> <i>func</i>() {
      <i>defer</i> <i>wg</i>.<i>Done</i>()
      <i>doWork</i>(<i>m</i>)
    }()
  }

  <i>wg</i>.<i>Wait</i>()
  <i>log</i>.<i>Printf</i>(<i>&#34;map = %#v&#34;</i>, <i>m</i>)
}
</code></p></pre><pre><p>Shell session</p><p><code>$ go run ./sample.go
2022/02/07 22:49:17 map = map[uint64]uint64{0x0:0x19, 0x1:0x16, 0x2:0x10, 0x3:0x17, 0x4:0xe, 0x5:0x13, 0x6:0x16, 0x7:0x18, 0x8:0x15, 0x9:0xe}
</code></p></pre>
<p>Huh! No concurrency-related shenanigans.</p>
<p>But also, ugh, that formatting, - hang on a second.</p>
<pre><p>Shell session</p><p><code>$ go get github.com/davecgh/go-spew/spew
</code></p></pre><pre><p>Go code</p><p><code><i>// omitted: everything besides main</i>

<i>func</i> <i>main</i>() {
  <i>var</i> <i>wg</i> sync.<i>WaitGroup</i>
  <i>m</i> <i>:=</i> <i>make</i>(<i>map</i>[<i>uint64</i>]<i>uint64</i>)

  <i>for</i> <i>i</i> <i>:=</i> 0; <i>i</i> <i>&lt;</i> 2; <i>i</i><i>++</i> {
    <i>wg</i>.<i>Add</i>(1)
    <i>go</i> <i>func</i>() {
      <i>defer</i> <i>wg</i>.<i>Done</i>()
      <i>doWork</i>(<i>m</i>)
    }()
  }

  <i>wg</i>.<i>Wait</i>()
  <i>// ðŸ‘‡ instead of using the &#34;%#v&#34; specifier</i>
  <i>spew</i>.<i>Dump</i>(<i>m</i>)
}
</code></p></pre><pre><p>Shell session</p><p><code>$ go run ./sample.go
(map[uint64]uint64) (len=10) {
 (uint64) 8: (uint64) 21,
 (uint64) 5: (uint64) 19,
 (uint64) 6: (uint64) 22,
 (uint64) 4: (uint64) 14,
 (uint64) 2: (uint64) 16,
 (uint64) 7: (uint64) 24,
 (uint64) 9: (uint64) 14,
 (uint64) 3: (uint64) 23,
 (uint64) 1: (uint64) 22,
 (uint64) 0: (uint64) 25
}
</code></p></pre>
<p>Ah, better!</p>
<p>Well, no concurrency bugs here - that&#39;s about what I&#39;d expect. We distribute
200 increments in 10 buckets, so their value is roughly around 20.</p>
<p>We should probably sum them, just to make sure.</p>
<p>There&#39;s probably a function for that in the Go standard library!</p>
<div>

<p>...</p>
</div>
<p>Nevermind!</p>
<pre><p>Go code</p><p><code><i>func</i> <i>main</i>() {
  <i>// omitted: start of main</i>

  <i>sum</i> <i>:=</i> 0
  <i>for</i> <i>_</i>, <i>v</i> <i>:=</i> <i>range</i> <i>m</i> {
    <i>sum</i> <i>+=</i> <i>v</i>
  }
  <i>spew</i>.<i>Dump</i>(<i>sum</i>)
}
</code></p></pre><pre><p>Shell session</p><p><code>$  go run ./sample.go
# command-line-arguments
./sample.go:34:7: invalid operation: sum += v (mismatched types int and uint64)
</code></p></pre>
<p>Aaaaaaaaaaahhahahaah. Who needs type inference.</p>
<pre><p>Go code</p><p><code><i>func</i> <i>main</i>() {
  <i>// omitted: start of main</i>

  <i>sum</i> <i>:=</i> <i>uint64</i>(0) <i>// you can&#39;t make me use var!</i>
  <i>for</i> <i>_</i>, <i>v</i> <i>:=</i> <i>range</i> <i>m</i> {
    <i>sum</i> <i>+=</i> <i>v</i>
  }
  <i>spew</i>.<i>Dump</i>(<i>sum</i>)
}
</code></p></pre><pre><p>Shell session</p><p><code>$ go run ./sample.go
(map[uint64]uint64) (len=10) {
 (uint64) 5: (uint64) 19,
 (uint64) 0: (uint64) 25,
 (uint64) 2: (uint64) 16,
 (uint64) 7: (uint64) 24,
 (uint64) 8: (uint64) 21,
 (uint64) 6: (uint64) 22,
 (uint64) 4: (uint64) 14,
 (uint64) 3: (uint64) 23,
 (uint64) 1: (uint64) 22,
 (uint64) 9: (uint64) 14
}
(uint64) 200

$ go run ./sample.go
(map[uint64]uint64) (len=10) {
 (uint64) 7: (uint64) 24,
 (uint64) 9: (uint64) 14,
 (uint64) 8: (uint64) 21,
 (uint64) 4: (uint64) 14,
 (uint64) 2: (uint64) 16,
 (uint64) 1: (uint64) 22,
 (uint64) 5: (uint64) 19,
 (uint64) 0: (uint64) 25,
 (uint64) 6: (uint64) 22,
 (uint64) 3: (uint64) 23
}
(uint64) 200

$ go run ./sample.go
(map[uint64]uint64) (len=10) {
 (uint64) 9: (uint64) 14,
 (uint64) 0: (uint64) 25,
 (uint64) 3: (uint64) 23,
 (uint64) 1: (uint64) 22,
 (uint64) 7: (uint64) 24,
 (uint64) 8: (uint64) 21,
 (uint64) 5: (uint64) 19,
 (uint64) 6: (uint64) 22,
 (uint64) 4: (uint64) 14,
 (uint64) 2: (uint64) 16
}
(uint64) 200
</code></p></pre>
<p>Yeah no, no concurrency problems here! And the sum is 200 every time!</p>
<p>The distribution is different, but that&#39;s good, we <em>are</em> asking for
pseudo-random numbers.</p>
<p>And iteration order is random, but that&#39;s a feature:</p>
<pre><p>Go code</p><p><code><i>package</i> main

<i>import</i> <i>&#34;fmt&#34;</i>

<i>func</i> <i>main</i>() {
  <i>var</i> <i>m</i> <i>=</i> <i>make</i>(<i>map</i>[<i>string</i>]<i>struct</i>{})
  <i>for</i> <i>_</i>, <i>s</i> <i>:=</i> <i>range</i> []<i>string</i>{<i>&#34;a&#34;</i>, <i>&#34;b&#34;</i>, <i>&#34;c&#34;</i>, <i>&#34;A&#34;</i>} {
    <i>m</i>[<i>s</i>] <i>=</i> <i>struct</i>{}{}
  }

  <i>for</i> <i>i</i> <i>:=</i> 0; <i>i</i> <i>&lt;</i> 5; <i>i</i><i>++</i> {
    <i>for</i> <i>k</i> <i>:=</i> <i>range</i> <i>m</i> {
      <i>fmt</i>.<i>Printf</i>(<i>&#34;%v&#34;</i>, <i>k</i>)
    }
    <i>fmt</i>.<i>Println</i>()
  }
}
</code></p></pre><pre><p>Shell session</p><p><code>$ go run ./scratch.go
bcAa
cAab
bcAa
abcA
Acab
</code></p></pre>
<p>That&#39;s... an interesting idea. Map implementations are usually pretty explicit
about whether or not they maintain insertion order. Rust&#39;s <code>HashMap</code>, does not
preserve insertion order either.</p>
<pre><p>Rust code</p><p><code><i>use</i> std<i>::</i>collections<i>::</i>HashMap<i>;</i>

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> <i>mut</i> map = <i>HashMap</i><i>::</i><i>new</i><i>(</i><i>)</i><i>;</i>
    map<i>.</i><i>insert</i><i>(</i><i>&#34;a&#34;</i>, <i>1</i><i>)</i><i>;</i>
    map<i>.</i><i>insert</i><i>(</i><i>&#34;b&#34;</i>, <i>2</i><i>)</i><i>;</i>
    map<i>.</i><i>insert</i><i>(</i><i>&#34;c&#34;</i>, <i>3</i><i>)</i><i>;</i>

    <i>for</i> _ <i>in</i> <i>0</i>..<i>5</i> {
        <i>for</i> k <i>in</i> map<i>.</i><i>keys</i><i>(</i><i>)</i> {
            <i>print</i><i>!</i><i>(</i><i>&#34;{}&#34;</i>, k<i>)</i><i>;</i>
        }
        <i>println</i><i>!</i><i>(</i><i>)</i><i>;</i>
    }
}
</code></p></pre>
<p>But it also doesn&#39;t randomize the order at runtime:</p>
<pre><p>Shell session</p><p><code>$ cargo run --quiet 
bca
bca
bca
bca
bca

$ cargo run --quiet
abc
abc
abc
abc
abc

$ cargo run --quiet
acb
acb
acb
acb
acb
</code></p></pre>
<p>Whether or not spending resources on randomizing iteration order at runtime is
a good idea is up for debate - but ah well.</p>
<p>Back to our Go program: so, no concurrency-related problems. What if we kick
it up a notch?</p>
<p>Say, we have the loop in <code>doWork</code> do fifty thousand iterations instead?</p>
<pre><p>Go code</p><p><code><i>func</i> <i>doWork</i>(<i>m</i> <i>map</i>[<i>uint64</i>]<i>uint64</i>) {
  <i>//               ðŸ‘‡</i>
  <i>for</i> <i>i</i> <i>:=</i> 0; <i>i</i> <i>&lt;</i> 50000; <i>i</i><i>++</i> {
    <i>key</i> <i>:=</i> <i>uint64</i>(<i>rand</i>.<i>Intn</i>(10))
    <i>m</i>[<i>key</i>] <i>+=</i> 1
  }
}
</code></p></pre><pre><p>Shell session</p><p><code>$ go run ./sample.go
fatal error: concurrent map writes

goroutine 7 [running]:
runtime.throw({0x4cb240, 0xc000086f60})
        /usr/local/go/src/runtime/panic.go:1198 +0x71 fp=0xc000086f38 sp=0xc000086f08 pc=0x431311
runtime.mapassign_fast64(0x4b8080, 0xc0000ba390, 0x1)
        /usr/local/go/src/runtime/map_fast64.go:101 +0x2c5 fp=0xc000086f70 sp=0xc000086f38 pc=0x410425
main.doWork(0x0)
        /home/amos/bearcove/lox/sample.go:13 +0x48 fp=0xc000086fa8 sp=0xc000086f70 pc=0x4abac8
main.main.func1()
        /home/amos/bearcove/lox/sample.go:25 +0x58 fp=0xc000086fe0 sp=0xc000086fa8 pc=0x4abd78
runtime.goexit()
        /usr/local/go/src/runtime/asm_amd64.s:1581 +0x1 fp=0xc000086fe8 sp=0xc000086fe0 pc=0x45d421
created by main.main
        /home/amos/bearcove/lox/sample.go:23 +0x4f

goroutine 1 [semacquire]:
sync.runtime_Semacquire(0x0)
        /usr/local/go/src/runtime/sema.go:56 +0x25
sync.(*WaitGroup).Wait(0xc000084728)
        /usr/local/go/src/sync/waitgroup.go:130 +0x71
main.main()
        /home/amos/bearcove/lox/sample.go:29 +0xd8

goroutine 6 [runnable]:
math/rand.(*lockedSource).Int63(0xc000010030)
        /usr/local/go/src/math/rand/rand.go:387 +0xfe
math/rand.(*Rand).Int63(...)
        /usr/local/go/src/math/rand/rand.go:84
math/rand.(*Rand).Int31(...)
        /usr/local/go/src/math/rand/rand.go:98
math/rand.(*Rand).Int31n(0xc0000ba000, 0xa)
        /usr/local/go/src/math/rand/rand.go:133 +0x59
math/rand.(*Rand).Intn(0x4b8080, 0xc0000ba390)
        /usr/local/go/src/math/rand/rand.go:171 +0x2e
math/rand.Intn(...)
        /usr/local/go/src/math/rand/rand.go:337
main.doWork(0x0)
        /home/amos/bearcove/lox/sample.go:12 +0x34
main.main.func1()
        /home/amos/bearcove/lox/sample.go:25 +0x58
created by main.main
        /home/amos/bearcove/lox/sample.go:23 +0x4f
exit status 2
</code></p></pre>
<p>Ahah! Just as predicted! Concurrency-related shenanigans.</p>
<p>Those are no surprise, since Go maps are not thread-safe, as we can learn in the
<a href="https://go.dev/ref/spec">language specification</a>.</p>
<div>

<p>We can&#39;t. It&#39;s not in there.</p>
</div>
<div>

<p>It&#39;s not? But <code>map</code> is a built-in typ-</p>
</div>
<div>

<div>
<p>I know, and you&#39;d think so, but it&#39;s not in there - I checked several times.</p>
<p>It&#39;s documented in <a href="https://go.dev/blog/maps">a blog post</a>, though!</p>
</div>
</div>
<p>So, here too, if we want to access a map safely from multiple goroutines that
can run in parallel, you need a Mutex - or any other kind of lock, like an
RWLock.</p>
<p>Or you could use other concurrency primitives, like a channel that&#39;s in charge
of updating the map.</p>
<p>Because channels are a more recent idea, this is much less error-prone:</p>
<pre><p>Go code</p><p><code><i>package</i> main

<i>import</i> (
  <i>&#34;math/rand&#34;</i>
  <i>&#34;sync&#34;</i>

  <i>&#34;github.com/davecgh/go-spew/spew&#34;</i>
)

<i>func</i> <i>doWork</i>(<i>increments</i> <i>chan</i> <i>uint64</i>) {
  <i>for</i> <i>i</i> <i>:=</i> 0; <i>i</i> <i>&lt;</i> 50000; <i>i</i><i>++</i> {
    <i>key</i> <i>:=</i> <i>uint64</i>(<i>rand</i>.<i>Intn</i>(10))
    <i>// we&#39;re just sending a &#34;unit of work&#34; to the updater goroutine</i>
    <i>increments</i> <i>&lt;-</i> <i>key</i>
  }
}

<i>func</i> <i>main</i>() {
  <i>var</i> <i>wg</i> sync.<i>WaitGroup</i>

  <i>m</i> <i>:=</i> <i>make</i>(<i>map</i>[<i>uint64</i>]<i>uint64</i>)
  <i>var</i> <i>increments</i> <i>chan</i> <i>uint64</i>

  <i>// this goroutine will be in charge of updating the map</i>
  <i>go</i> <i>func</i>() {
    <i>for</i> <i>increment</i> <i>:=</i> <i>range</i> <i>increments</i> {
      <i>m</i>[<i>increment</i>] <i>+=</i> 1
    }
  }()

  <i>for</i> <i>i</i> <i>:=</i> 0; <i>i</i> <i>&lt;</i> 2; <i>i</i><i>++</i> {
    <i>wg</i>.<i>Add</i>(1)
    <i>go</i> <i>func</i>() {
      <i>defer</i> <i>wg</i>.<i>Done</i>()
      <i>doWork</i>(<i>increments</i>)
    }()
  }

  <i>wg</i>.<i>Wait</i>()
  <i>spew</i>.<i>Dump</i>(<i>m</i>)

  <i>sum</i> <i>:=</i> <i>uint64</i>(0)
  <i>for</i> <i>_</i>, <i>v</i> <i>:=</i> <i>range</i> <i>m</i> {
    <i>sum</i> <i>+=</i> <i>v</i>
  }
  <i>spew</i>.<i>Dump</i>(<i>sum</i>)
}
</code></p></pre><pre><p>Shell session</p><p><code>$ go run ./sample.go
fatal error: all goroutines are asleep - deadlock!

goroutine 1 [semacquire]:
sync.runtime_Semacquire(0x0)
        /usr/local/go/src/runtime/sema.go:56 +0x25
sync.(*WaitGroup).Wait(0xc000084728)
        /usr/local/go/src/sync/waitgroup.go:130 +0x71
main.main()
        /home/amos/bearcove/lox/sample.go:38 +0x111

goroutine 6 [chan receive (nil chan)]:
main.main.func1()
        /home/amos/bearcove/lox/sample.go:25 +0x59
created by main.main
        /home/amos/bearcove/lox/sample.go:24 +0x8f

goroutine 7 [chan send (nil chan)]:
main.doWork(0x0)
        /home/amos/bearcove/lox/sample.go:13 +0x48
main.main.func2()
        /home/amos/bearcove/lox/sample.go:34 +0x58
created by main.main
        /home/amos/bearcove/lox/sample.go:32 +0xa5

goroutine 8 [chan send (nil chan)]:
main.doWork(0x0)
        /home/amos/bearcove/lox/sample.go:13 +0x48
main.main.func2()
        /home/amos/bearcove/lox/sample.go:34 +0x58
created by main.main
        /home/amos/bearcove/lox/sample.go:32 +0xa5
exit status 2
</code></p></pre>
<p>Woops haha I&#39;m so clumsy. What happened?</p>
<p>Well the stack trace kinda gives it away: it&#39;s saying we&#39;re trying to send to a
nil chan, the zero value for a channel, and according to the four channel
axioms, which are... right, on <a href="https://dave.cheney.net/2014/03/19/channel-axioms">another
blog</a>, a send to a nil
channel just blocks forever.</p>
<p>The blog notes that this behavior is &#34;a little surprising to newcomers&#34;, but
doesn&#39;t go on to explain the rationale. I guess we&#39;ll never know.</p>
<p>So let&#39;s fix our bug:</p>
<pre><p>Go code</p><p><code><i>// (cut)</i>

<i>func</i> <i>main</i>() {
  <i>// (cut)</i>

  <i>m</i> <i>:=</i> <i>make</i>(<i>map</i>[<i>uint64</i>]<i>uint64</i>)
  <i>// ðŸ‘‡</i>
  <i>increments</i> <i>:=</i> <i>make</i>(<i>chan</i> <i>uint64</i>)

  <i>// (cut)</i>
}
</code></p></pre>
<p>And now everything works as expected!</p>
<pre><p>Shell session</p><p><code>$ go run ./sample.go
(map[uint64]uint64) (len=10) {
 (uint64) 9: (uint64) 9755,
 (uint64) 5: (uint64) 10032,
 (uint64) 0: (uint64) 10152,
 (uint64) 1: (uint64) 10115,
 (uint64) 7: (uint64) 10021,
 (uint64) 4: (uint64) 9884,
 (uint64) 2: (uint64) 9901,
 (uint64) 3: (uint64) 9913,
 (uint64) 8: (uint64) 9984,
 (uint64) 6: (uint64) 10242
}
(uint64) 99999
</code></p></pre><div>

<p>...no it doesn&#39;t.</p>
</div>
<p>Mh?</p>
<div>

<p>The sum. It&#39;s not one hundred thousand.</p>
</div>
<p>Oh right, uh I guess one must&#39;ve slipped by... but look, if I run it again, the
sum is right this time! This is fine right?</p>
<div>

<p>..................</p>
</div>
<p>Okay okay let&#39;s fix it.</p>
<p>There&#39;s a bunch of ways to fix that, none of which I really like.</p>
<p>Here&#39;s one:</p>
<pre><p>Go code</p><p><code><i>func</i> <i>main</i>() {
	<i>var</i> <i>wg</i> sync.<i>WaitGroup</i>

	<i>m</i> <i>:=</i> <i>make</i>(<i>map</i>[<i>uint64</i>]<i>uint64</i>)
	<i>increments</i> <i>:=</i> <i>make</i>(<i>chan</i> <i>uint64</i>)
	<i>signal</i> <i>:=</i> <i>make</i>(<i>chan</i> <i>struct</i>{})

	<i>go</i> <i>func</i>() {
		<i>for</i> <i>increment</i> <i>:=</i> <i>range</i> <i>increments</i> {
			<i>m</i>[<i>increment</i>] <i>+=</i> 1
		}
		<i>close</i>(<i>signal</i>)
	}()

	<i>for</i> <i>i</i> <i>:=</i> 0; <i>i</i> <i>&lt;</i> 2; <i>i</i><i>++</i> {
		<i>wg</i>.<i>Add</i>(1)
		<i>go</i> <i>func</i>() {
			<i>defer</i> <i>wg</i>.<i>Done</i>()
			<i>doWork</i>(<i>increments</i>)
		}()
	}

	<i>// wait for workers...</i>
	<i>wg</i>.<i>Wait</i>()

	<i>// signal end of &#34;units of work&#34;</i>
	<i>close</i>(<i>increments</i>)

	<i>// wait for updater goroutine to finish</i>
	<i>&lt;-</i><i>signal</i>

	<i>spew</i>.<i>Dump</i>(<i>m</i>)

	<i>sum</i> <i>:=</i> <i>uint64</i>(0)
	<i>for</i> <i>_</i>, <i>v</i> <i>:=</i> <i>range</i> <i>m</i> {
		<i>sum</i> <i>+=</i> <i>v</i>
	}
	<i>spew</i>.<i>Dump</i>(<i>sum</i>)
}
</code></p></pre>
<p>And with that, our code is correct. Probably. We even fixed a memory leak!
Previously, the updater goroutine would stick around forever, since it holds
a reference to the &#34;increments&#34; channel, which is never closed.</p>
<p>For a garbage-collected language, it&#39;s <em>extremely</em> easy to leak memory with.</p>
<p>But let&#39;s forget about personal feelings for a minute and go back to doing fair
comparisons. Nobody will argue that &#34;Go maps are not safe for concurrent access&#34;
isn&#39;t a footgun.</p>
<p>Does that same footgun exist in Rust?</p>
<p>Let&#39;s see:</p>
<pre><p>Rust code</p><p><code><i>use</i> rand<i>::</i>Rng<i>;</i>
<i>use</i> std<i>::</i>collections<i>::</i>HashMap<i>;</i>

<i>fn</i> <i>do_work</i><i>(</i><i>m</i>: <i>&amp;</i><i>mut</i> <i>HashMap</i><i>&lt;</i><i>u64</i>, <i>u64</i><i>&gt;</i><i>)</i> {
    <i>let</i> <i>mut</i> rng = rand<i>::</i><i>thread_rng</i><i>(</i><i>)</i><i>;</i>
    <i>for</i> _ <i>in</i> <i>0</i>..<i>100_000</i> {
        <i>let</i> key: <i>u64</i> = rng<i>.</i><i>gen_range</i><i>(</i><i>0</i>..<i>10</i><i>)</i><i>;</i>
        <i>*</i>m<i>.</i><i>entry</i><i>(</i>key<i>)</i><i>.</i><i>or_default</i><i>(</i><i>)</i> += <i>1</i>
    }
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> <i>mut</i> m: <i>HashMap</i><i>&lt;</i><i>u64</i>, <i>u64</i><i>&gt;</i> = <i>Default</i><i>::</i><i>default</i><i>(</i><i>)</i><i>;</i>

    crossbeam<i>::</i><i>scope</i><i>(</i>|s| {
        s<i>.</i><i>spawn</i><i>(</i>|_| <i>do_work</i><i>(</i><i>&amp;</i><i>mut</i> m<i>)</i><i>)</i><i>;</i>
        s<i>.</i><i>spawn</i><i>(</i>|_| <i>do_work</i><i>(</i><i>&amp;</i><i>mut</i> m<i>)</i><i>)</i><i>;</i>
    }<i>)</i>
    <i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>

    <i>// format strings can capture arguments, as of Rust 1.58:</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;map = {m:#?}&#34;</i><i>)</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;sum = {}&#34;</i>, m.values<i>(</i><i>)</i>.copied<i>(</i><i>)</i>.sum::&lt;<i>u64</i>&gt;<i>(</i><i>)</i><i>)</i><i>;</i>
}
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo run --quiet
error[E0499]: cannot borrow `m` as mutable more than once at a time
  --&gt; src/main.rs:17:17
   |
16 |         s.spawn(|_| do_work(&amp;mut m));
   |                 ---              - first borrow occurs due to use of `m` in closure
   |                 |
   |                 first mutable borrow occurs here
17 |         s.spawn(|_| do_work(&amp;mut m));
   |           ----- ^^^              - second borrow occurs due to use of `m` in closure
   |           |     |
   |           |     second mutable borrow occurs here
   |           first borrow later used by call

For more information about this error, try `rustc --explain E0499`.
error: could not compile `lox` due to previous error
</code></p></pre>
<p>No! It doesn&#39;t. Because you can read a map with a <code>&amp;HashMap</code> (an immutable
reference), but to mutate a map, you need a <code>&amp;mut HashMap</code> (a mutable
reference), and only one of these at most can exist at the same time.</p>
<p>The same techniques apply here, we can use a <code>Mutex</code>:</p>
<pre><p>Rust code</p><p><code><i>use</i> parking_lot<i>::</i>Mutex<i>;</i>
<i>use</i> rand<i>::</i>Rng<i>;</i>
<i>use</i> std<i>::</i>collections<i>::</i>HashMap<i>;</i>

<i>//               ðŸ‘‡</i>
<i>fn</i> <i>do_work</i><i>(</i><i>m</i>: <i>&amp;</i><i>Mutex</i><i>&lt;</i><i>HashMap</i><i>&lt;</i><i>u64</i>, <i>u64</i><i>&gt;</i><i>&gt;</i><i>)</i> {
    <i>let</i> <i>mut</i> rng = rand<i>::</i><i>thread_rng</i><i>(</i><i>)</i><i>;</i>
    <i>for</i> _ <i>in</i> <i>0</i>..<i>100_000</i> {
        <i>let</i> key: <i>u64</i> = rng<i>.</i><i>gen_range</i><i>(</i><i>0</i>..<i>10</i><i>)</i><i>;</i>
        <i>// ðŸ‘‡</i>
        <i>*</i>m<i>.</i><i>lock</i><i>(</i><i>)</i><i>.</i><i>entry</i><i>(</i>key<i>)</i><i>.</i><i>or_default</i><i>(</i><i>)</i> += <i>1</i>
    }
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>// note that `Default::default()` can still be used to build this type!</i>
    <i>let</i> m: <i>Mutex</i><i>&lt;</i><i>HashMap</i><i>&lt;</i><i>u64</i>, <i>u64</i><i>&gt;</i><i>&gt;</i> = <i>Default</i><i>::</i><i>default</i><i>(</i><i>)</i><i>;</i>

    crossbeam<i>::</i><i>scope</i><i>(</i>|s| {
        s<i>.</i><i>spawn</i><i>(</i>|_| <i>do_work</i><i>(</i><i>&amp;</i>m<i>)</i><i>)</i><i>;</i>
        s<i>.</i><i>spawn</i><i>(</i>|_| <i>do_work</i><i>(</i><i>&amp;</i>m<i>)</i><i>)</i><i>;</i>
    }<i>)</i>
    <i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>

    <i>// and that we can take the map out of the mutex afterwards!</i>
    <i>let</i> m = m<i>.</i><i>into_inner</i><i>(</i><i>)</i><i>;</i>

    <i>println</i><i>!</i><i>(</i><i>&#34;map = {m:#?}&#34;</i><i>)</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;sum = {}&#34;</i>, m.values<i>(</i><i>)</i>.copied<i>(</i><i>)</i>.sum::&lt;<i>u64</i>&gt;<i>(</i><i>)</i><i>)</i><i>;</i>
}
</code></p></pre>
<p>That works fine:</p>
<pre><p>Shell session</p><p><code>$ cargo run --quiet
map = {
    4: 19962,
    2: 19952,
    7: 20034,
    1: 20209,
    3: 20047,
    6: 19820,
    5: 20101,
    0: 20398,
    9: 19807,
    8: 19670,
}
sum = 200000
</code></p></pre>
<p>Or, we can have a thread dedicated to updating the map, just like we had with
goroutines:</p>
<pre><p>Rust code</p><p><code><i>use</i> rand<i>::</i>Rng<i>;</i>
<i>use</i> std<i>::</i>{collections<i>::</i>HashMap, sync<i>::</i>mpsc}<i>;</i>

<i>fn</i> <i>do_work</i><i>(</i><i>tx</i>: mpsc<i>::</i><i>Sender</i><i>&lt;</i><i>u64</i><i>&gt;</i><i>)</i> {
    <i>let</i> <i>mut</i> rng = rand<i>::</i><i>thread_rng</i><i>(</i><i>)</i><i>;</i>
    <i>for</i> _ <i>in</i> <i>0</i>..<i>100_000</i> {
        <i>let</i> key: <i>u64</i> = rng<i>.</i><i>gen_range</i><i>(</i><i>0</i>..<i>10</i><i>)</i><i>;</i>
        tx<i>.</i><i>send</i><i>(</i>key<i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
    }
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> <i>mut</i> m: <i>HashMap</i><i>&lt;</i><i>u64</i>, <i>u64</i><i>&gt;</i> = <i>Default</i><i>::</i><i>default</i><i>(</i><i>)</i><i>;</i>

    crossbeam<i>::</i><i>scope</i><i>(</i>|s| {
        <i>let</i> <i>(</i>tx1, rx<i>)</i> = mpsc<i>::</i><i>channel</i><i>(</i><i>)</i><i>;</i>
        <i>let</i> tx2 = tx1<i>.</i><i>clone</i><i>(</i><i>)</i><i>;</i>
        <i>let</i> m = <i>&amp;</i><i>mut</i> m<i>;</i>

        s<i>.</i><i>spawn</i><i>(</i><i>move</i> |_| {
            <i>while</i> <i>let</i> Ok<i>(</i>key<i>)</i> = rx<i>.</i><i>recv</i><i>(</i><i>)</i> {
                <i>*</i>m<i>.</i><i>entry</i><i>(</i>key<i>)</i><i>.</i><i>or_default</i><i>(</i><i>)</i> += <i>1</i>
            }
        }<i>)</i><i>;</i>
        s<i>.</i><i>spawn</i><i>(</i><i>move</i> |_| <i>do_work</i><i>(</i>tx1<i>)</i><i>)</i><i>;</i>
        s<i>.</i><i>spawn</i><i>(</i><i>move</i> |_| <i>do_work</i><i>(</i>tx2<i>)</i><i>)</i><i>;</i>
    }<i>)</i>
    <i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>

    <i>println</i><i>!</i><i>(</i><i>&#34;map = {m:#?}&#34;</i><i>)</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>&#34;sum = {}&#34;</i>, m.values<i>(</i><i>)</i>.copied<i>(</i><i>)</i>.sum::&lt;<i>u64</i>&gt;<i>(</i><i>)</i><i>)</i><i>;</i>
}
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo run --quiet
map = {
    2: 19931,
    5: 20027,
    3: 20023,
    7: 19937,
    8: 20007,
    4: 20003,
    6: 20122,
    9: 20030,
    1: 20013,
    0: 19907,
}
sum = 200000
</code></p></pre>
<p>Note that here, the &#34;sending&#34; and &#34;receiving&#34; ends of the channel are separate:
the updater gets the receiver, and each worker thread gets its own sender.</p>
<p>When a worker thread is done, it drops its sender, and when all senders are
dropped, the channel is closed, so the updater thread stops as well.</p>
<h2>But not all is preventable</h2>
<p>Before we move on, I&#39;d like to congratulate you on reading this far. Believe it
or not, you&#39;re in the minority!</p>
<p>If you check the comments section of whatever website you found this article on,
you will surely notice comments from folks who haven&#39;t read all the way to the
end (despite the title of the article being a giveaway).</p>
<p>We&#39;ve seen many situations where Rust helps avoid common problems. We&#39;ve also
seen situations where Rust&#39;s design makes it somewhat harder to do something we
want to do.</p>
<p>That&#39;s a natural consequence of the set of legal programs being smaller! A lot
of useful programs are excluded! So sometimes, we need to find alternative
formulations, for equivalent programs that are accepted by the Rust compiler.</p>
<p>That idea is what I was trying to articulate in <a href="https://fasterthanli.me/articles/frustrated-its-not-you-its-rust">Frustrated? It&#39;s not you, it&#39;s
Rust</a>.</p>
<p>But it is important to note that even the strictest of languages cannot catch every
kind of error.</p>
<div>
<div>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><path d="M21.41 41.398c.148-1.787.337-3.572.574-5.351.369-2.772 4.393-11.308 5.624-12.882l.553-.706-1.344-.449a5.772 5.772 0 0 1-3.948-5.478 5.786 5.786 0 0 1 5.779-5.78 5.768 5.768 0 0 1 5.684 4.758l.249 1.396 1.231-.704a28.845 28.845 0 0 1 14.282-3.801c4.991 0 9.93 1.314 14.282 3.801l1.231.704.249-1.396a5.766 5.766 0 0 1 5.683-4.758 5.786 5.786 0 0 1 5.779 5.78 5.772 5.772 0 0 1-3.948 5.478l-1.344.449.552.705c1.911 2.44 2.55 2.541 3.563 5.599 1.422 4.293 2.923 7.964 2.923 12.61v49.875h2V41.373c0-6.519-2.008-12.717-5.819-18.005a7.768 7.768 0 0 0 4.072-6.836c0-4.29-3.49-7.78-7.779-7.78a7.766 7.766 0 0 0-7.3 5.1 30.834 30.834 0 0 0-14.146-3.45 30.834 30.834 0 0 0-14.146 3.45 7.766 7.766 0 0 0-7.301-5.1c-4.289 0-7.779 3.49-7.779 7.78a7.766 7.766 0 0 0 4.072 6.836c-6.681 9.271-5.976 21.037-5.992 32.034-.017 11.946.656 23.895.109 35.838l2.006-.001c.67 0-.17-33.831-.156-36.912.022-4.312.148-8.631.505-12.929z"></path><path d="M73.854 31.271v-4.494c0-.971-.79-1.76-1.761-1.76H55.235c-.604 0-1.3.869-1.778 1.905-.015 0-.027-.008-.042-.008H46.789c-.02 0-.037.011-.057.011-.478-1.037-1.175-1.908-1.779-1.908H28.094c-.971 0-1.761.79-1.761 1.76v4.494c0 4.477 3.643 8.119 8.119 8.119h5.12c4.265 0 7.734-3.47 7.734-7.734v-2.091H52.878v2.091c0 4.265 3.47 7.734 7.734 7.734h5.121c4.479-.001 8.121-3.643 8.121-8.119zm-41.713 3.192a1.387 1.387 0 0 1-1.917-.442 1.392 1.392 0 0 1 .442-1.917l8.403-5.255a1.392 1.392 0 0 1 1.475 2.359l-8.403 5.255zm11.163-2.18l-5.75 3.597a.95.95 0 0 1-1.313-.302.952.952 0 0 1 .303-1.312l5.75-3.597a.953.953 0 0 1 1.01 1.614zm15.168 1.935a1.387 1.387 0 0 1-1.917-.442 1.392 1.392 0 0 1 .442-1.917l8.403-5.255a1.392 1.392 0 0 1 1.475 2.359l-8.403 5.255zm4.909 1.561a.953.953 0 0 1-.506-1.759l5.75-3.597a.952.952 0 1 1 1.01 1.614l-5.75 3.597a.942.942 0 0 1-.504.145z"></path><path d="M59.705 45.232h-2c0 1.823-1.483 3.306-3.306 3.306s-3.306-1.483-3.306-3.306v-1.439h1.06a3.294 3.294 0 0 0 3.285-3.285v-.17c0-.259-.038-.508-.095-.749a3.291 3.291 0 0 0-2.665-2.482 3.243 3.243 0 0 0-.525-.053h-4.12c-.18 0-.353.025-.525.053a3.291 3.291 0 0 0-2.665 2.482 3.255 3.255 0 0 0-.095.749v.17a3.294 3.294 0 0 0 3.285 3.285h1.06v1.439a3.31 3.31 0 0 1-3.307 3.306 3.31 3.31 0 0 1-3.306-3.306h-2a5.312 5.312 0 0 0 5.306 5.306 5.293 5.293 0 0 0 4.306-2.229 5.294 5.294 0 0 0 4.306 2.229 5.313 5.313 0 0 0 5.307-5.306zM29.742 58.336a.703.703 0 0 0-1.406 0v5.368a.704.704 0 0 0 1.406 0v-5.368zM43.779 58.336a.703.703 0 0 0-1.406 0v5.368a.704.704 0 0 0 1.406 0v-5.368zM57.816 58.336a.703.703 0 0 0-1.407 0v5.368a.704.704 0 0 0 1.407 0v-5.368zM71.853 58.336a.704.704 0 0 0-1.407 0v5.368a.704.704 0 0 0 1.407 0v-5.368zM35.354 71.559v5.369a.703.703 0 0 0 1.406 0v-5.369a.703.703 0 0 0-1.406 0zM49.39 71.559v5.369a.704.704 0 0 0 1.407 0v-5.369a.703.703 0 0 0-1.407 0zM63.427 71.559v5.369a.704.704 0 0 0 1.407 0v-5.369a.703.703 0 0 0-1.407 0zM29.038 81.364a.703.703 0 0 0-.703.703v5.369a.703.703 0 0 0 1.406 0v-5.369a.703.703 0 0 0-.703-.703zM43.076 81.364a.703.703 0 0 0-.703.703v5.369a.703.703 0 0 0 1.406 0v-5.369a.705.705 0 0 0-.703-.703zM57.113 81.364a.704.704 0 0 0-.704.703v5.369a.704.704 0 0 0 1.407 0v-5.369a.705.705 0 0 0-.703-.703zM71.149 81.364a.703.703 0 0 0-.703.703v5.369a.703.703 0 0 0 1.407 0v-5.369a.705.705 0 0 0-.704-.703z"></path></svg><p>
Cool bear&#39;s hot tip
</p></div>
<p>...which is not to say that there is no point in trying to catch errors.</p>
<p>Catching some is still /much better/ than catching none.</p>
<p>We find the same fallacy in physical-world problem solving. For example, it may
seem pointless to take care of oneself when so many things are going wrong
around us.</p>
<p>But we do have to start <em>somewhere</em>.</p>
</div>
<p>For example, this is a legal Rust program:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>add</i><i>(</i><i>a</i>: <i>u64</i>, <i>b</i>: <i>u64</i><i>)</i> -&gt; <i>u64</i> {
    a - b
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>dbg</i><i>!</i><i>(</i>add<i>(</i><i>1</i>, <i>3</i><i>)</i><i>)</i><i>;</i>
}
</code></p></pre>
<p><code>cargo check</code> has nothing to say about it. But a human would. That function is
clearly called <code>add</code>, yet it subtracts.</p>
<p>More to the point, this is also completely legal:</p>
<pre><p>Rust code</p><p><code><i>use</i> parking_lot<i>::</i>Mutex<i>;</i>

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> m: <i>Mutex</i><i>&lt;</i><i>u64</i><i>&gt;</i> = <i>Default</i><i>::</i><i>default</i><i>(</i><i>)</i><i>;</i>

    <i>let</i> <i>mut</i> guard = m<i>.</i><i>lock</i><i>(</i><i>)</i><i>;</i>
    <i>*</i>guard += <i>1</i><i>;</i>

    <i>println</i><i>!</i><i>(</i><i>&#34;m = {}&#34;</i>, m.lock<i>(</i><i>)</i><i>)</i><i>;</i>
}

</code></p></pre>
<p>And yet, it deadlocks:</p>
<pre><p>Shell session</p><p><code>$ cargo run --quiet
(nothing is printed)
</code></p></pre>
<p>Running that program under <a href="https://github.com/rust-lang/miri">miri</a> (with isolation disabled) does find the
deadlock:</p>
<pre><p>Shell session</p><p><code>$ cargo clean; MIRIFLAGS=&#34;-Zmiri-disable-isolation&#34; cargo +nightly miri run
   Compiling cfg-if v1.0.0
   (cut)
   Compiling lox v0.1.0 (/home/amos/bearcove/lox)
    Finished dev [unoptimized + debuginfo] target(s) in 5.73s
     Running `/home/amos/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/bin/cargo-miri target/miri/x86_64-unknown-linux-gnu/debug/lox`
error: deadlock: the evaluated program deadlocked
   --&gt; /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/parking_lot_core-0.9.1/src/thread_parker/linux.rs:118:13
    |
118 |             )
    |             ^ the evaluated program deadlocked
    |
    = note: inside `parking_lot_core::thread_parker::imp::ThreadParker::futex_wait` at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/parking_lot_core-0.9.1/src/thread_parker/linux.rs:118:13
    = note: inside `&lt;parking_lot_core::thread_parker::imp::ThreadParker as parking_lot_core::thread_parker::ThreadParkerT&gt;::park` at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/parking_lot_core-0.9.1/src/thread_parker/linux.rs:66:13
    = note: inside closure at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/parking_lot_core-0.9.1/src/parking_lot.rs:635:17
    = note: inside `parking_lot_core::parking_lot::with_thread_data::&lt;parking_lot_core::parking_lot::ParkResult, [closure@parking_lot_core::parking_lot::park&lt;[closure@parking_lot::RawMutex::lock_slow::{closure#0}], [closure@parking_lot::RawMutex::lock_slow::{closure#1}], [closure@parking_lot::RawMutex::lock_slow::{closure#2}]&gt;::{closure#0}]&gt;` at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/parking_lot_core-0.9.1/src/parking_lot.rs:207:5
    = note: inside `parking_lot_core::parking_lot::park::&lt;[closure@parking_lot::RawMutex::lock_slow::{closure#0}], [closure@parking_lot::RawMutex::lock_slow::{closure#1}], [closure@parking_lot::RawMutex::lock_slow::{closure#2}]&gt;` at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/parking_lot_core-0.9.1/src/parking_lot.rs:600:5
    = note: inside `parking_lot::RawMutex::lock_slow` at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/parking_lot-0.12.0/src/raw_mutex.rs:262:17
    = note: inside `&lt;parking_lot::RawMutex as parking_lot::lock_api::RawMutex&gt;::lock` at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/parking_lot-0.12.0/src/raw_mutex.rs:72:13
    = note: inside `parking_lot::lock_api::Mutex::&lt;parking_lot::RawMutex, u64&gt;::lock` at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/lock_api-0.4.6/src/mutex.rs:214:9
note: inside `main` at src/main.rs:9:24
   --&gt; src/main.rs:9:24
    |
9   |     println!(&#34;m = {}&#34;, m.lock());
    |                        ^^^^^^^^
    = note: inside `&lt;fn() as std::ops::FnOnce&lt;()&gt;&gt;::call_once - shim(fn())` at /home/amos/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/function.rs:227:5
    = note: inside `std::sys_common::backtrace::__rust_begin_short_backtrace::&lt;fn(), ()&gt;` at /home/amos/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys_common/backtrace.rs:123:18
    = note: inside closure at /home/amos/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/rt.rs:145:18
    = note: inside `std::ops::function::impls::&lt;impl std::ops::FnOnce&lt;()&gt; for &amp;dyn std::ops::Fn() -&gt; i32 + std::marker::Sync + std::panic::RefUnwindSafe&gt;::call_once` at /home/amos/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/function.rs:259:13
    = note: inside `std::panicking::r#try::do_call::&lt;&amp;dyn std::ops::Fn() -&gt; i32 + std::marker::Sync + std::panic::RefUnwindSafe, i32&gt;` at /home/amos/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panicking.rs:485:40
    = note: inside `std::panicking::r#try::&lt;i32, &amp;dyn std::ops::Fn() -&gt; i32 + std::marker::Sync + std::panic::RefUnwindSafe&gt;` at /home/amos/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panicking.rs:449:19
    = note: inside `std::panic::catch_unwind::&lt;&amp;dyn std::ops::Fn() -&gt; i32 + std::marker::Sync + std::panic::RefUnwindSafe, i32&gt;` at /home/amos/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panic.rs:136:14
    = note: inside closure at /home/amos/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/rt.rs:128:48
    = note: inside `std::panicking::r#try::do_call::&lt;[closure@std::rt::lang_start_internal::{closure#2}], isize&gt;` at /home/amos/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panicking.rs:485:40
    = note: inside `std::panicking::r#try::&lt;isize, [closure@std::rt::lang_start_internal::{closure#2}]&gt;` at /home/amos/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panicking.rs:449:19
    = note: inside `std::panic::catch_unwind::&lt;[closure@std::rt::lang_start_internal::{closure#2}], isize&gt;` at /home/amos/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panic.rs:136:14
    = note: inside `std::rt::lang_start_internal` at /home/amos/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/rt.rs:128:20
    = note: inside `std::rt::lang_start::&lt;()&gt;` at /home/amos/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/rt.rs:144:17

error: aborting due to previous error
</code></p></pre>
<p>This is actually quite a feat, given the machinery involved, and especially
since this is <code>parking_lot</code>&#39;s <code>Mutex</code> in use here, so I&#39;m impressed - but I
doubt it&#39;d be practical to run entire server applications under miri. It&#39;s more
suited to testing well-scoped library code.</p>
<p>The mistake I actually made, that Rust didn&#39;t catch, was a little more subtle:</p>
<pre><p>Rust code</p><p><code><i>use</i> parking_lot<i>::</i>RwLock<i>;</i>
<i>use</i> rand<i>::</i>Rng<i>;</i>
<i>use</i> std<i>::</i>{
    collections<i>::</i>HashMap,
    sync<i>::</i>Arc,
    time<i>::</i>{Duration, Instant},
}<i>;</i>

<i>#<i>[</i>derive<i>(</i>Default<i>)</i><i>]</i></i>
<i>struct</i> <i>State</i> {
    <i>entries</i>: <i>RwLock</i><i>&lt;</i><i>HashMap</i><i>&lt;</i><i>u64</i>, <i>u64</i><i>&gt;</i><i>&gt;</i>,
}

<i>impl</i> <i>State</i> {
    <i>fn</i> <i>update_state</i><i>(</i><i>&amp;</i><i>self</i><i>)</i> {
        <i>let</i> <i>mut</i> entries = <i>self</i><i>.</i><i>entries</i><i>.</i><i>write</i><i>(</i><i>)</i><i>;</i>
        <i>let</i> key = rand<i>::</i><i>thread_rng</i><i>(</i><i>)</i><i>.</i><i>gen_range</i><i>(</i><i>0</i>..<i>10</i><i>)</i><i>;</i>
        <i>*</i>entries<i>.</i><i>entry</i><i>(</i>key<i>)</i><i>.</i><i>or_default</i><i>(</i><i>)</i> += <i>1</i><i>;</i>
    }

    <i>fn</i> <i>foo</i><i>(</i><i>&amp;</i><i>self</i><i>)</i> {
        <i>let</i> entries = <i>self</i><i>.</i><i>entries</i><i>.</i><i>read</i><i>(</i><i>)</i><i>;</i>
        <i>if</i> entries<i>.</i><i>get</i><i>(</i><i>&amp;</i><i>4</i><i>)</i><i>.</i><i>copied</i><i>(</i><i>)</i><i>.</i><i>unwrap_or_default</i><i>(</i><i>)</i> % <i>2</i> == <i>0</i> {
            <i>// do something</i>
        } <i>else</i> {
            <i>self</i><i>.</i><i>bar</i><i>(</i><i>)</i><i>;</i>
        }
    }

    <i>fn</i> <i>bar</i><i>(</i><i>&amp;</i><i>self</i><i>)</i> {
        <i>let</i> entries = <i>self</i><i>.</i><i>entries</i><i>.</i><i>read</i><i>(</i><i>)</i><i>;</i>
        <i>if</i> entries<i>.</i><i>get</i><i>(</i><i>&amp;</i><i>2</i><i>)</i><i>.</i><i>is_some</i><i>(</i><i>)</i> {
            <i>// do something</i>
        } <i>else</i> {
            <i>// do something else</i>
        }
    }
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> s: <i>Arc</i><i>&lt;</i><i>State</i><i>&gt;</i> = <i>Default</i><i>::</i><i>default</i><i>(</i><i>)</i><i>;</i>

    std<i>::</i>thread<i>::</i><i>spawn</i><i>(</i>{
        <i>let</i> s = s<i>.</i><i>clone</i><i>(</i><i>)</i><i>;</i>
        <i>move</i> || <i>loop</i> {
            std<i>::</i>thread<i>::</i><i>sleep</i><i>(</i><i>Duration</i><i>::</i><i>from_millis</i><i>(</i><i>1</i><i>)</i><i>)</i><i>;</i>
            s<i>.</i><i>update_state</i><i>(</i><i>)</i><i>;</i>
        }
    }<i>)</i><i>;</i>

    <i>let</i> before = <i>Instant</i><i>::</i><i>now</i><i>(</i><i>)</i><i>;</i>
    <i>for</i> _ <i>in</i> <i>0</i>..<i>10_000</i> {
        s<i>.</i><i>foo</i><i>(</i><i>)</i><i>;</i>
    }
    <i>println</i><i>!</i><i>(</i><i>&#34;All done in {:?}&#34;</i>, before.elapsed<i>(</i><i>)</i><i>)</i><i>;</i>
}
</code></p></pre>
<p>Can you see the bug?</p>
<p>It seems to work fine...</p>
<pre><p>Shell session</p><p><code>$ cargo run --quiet
All done in 3.520651ms

</code></p></pre>
<p>But if we remove that sleep in the background thread...</p>
<pre><p>Rust code</p><p><code>
    <i>// in main:</i>
    std<i>::</i>thread<i>::</i><i>spawn</i><i>(</i>{
        <i>let</i> s = s<i>.</i><i>clone</i><i>(</i><i>)</i><i>;</i>
        <i>move</i> || <i>loop</i> {
            s<i>.</i><i>update_state</i><i>(</i><i>)</i><i>;</i>
        }
    }<i>)</i><i>;</i>
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo run --quiet
(nothing is ever printed)
</code></p></pre>
<p>It deadlocks.</p>
<p>If you haven&#39;t found the bug yet, try commenting out the call to <code>self.bar()</code>
in <code>State::foo</code>, and run it again. It&#39;ll work:</p>
<pre><p>Shell session</p><p><code>$ cargo run --quiet
warning: associated function is never used: `bar`
  --&gt; src/main.rs:26:8
   |
26 |     fn bar(&amp;self) {
   |        ^^^
   |
   = note: `#[warn(dead_code)]` on by default

All done in 1.891049988s
</code></p></pre>
<p>There&#39;s <em>heavy</em> contention for that lock (the updater thread is busy-looping!),
but somehow, we still manage to acquire a read lock to it ten thousand times in
under two seconds.</p>
<p>The problem here, is that to complete, <code>foo()</code> occasionally needs to acquire
<em>two</em> read locks for <code>entries</code>.</p>
<p>The following scenario is fine:</p>
<ul>
<li><code>update_state</code> acquires a write lock</li>
<li><code>foo</code> tries to acquire a read lock... (it blocks for a bit)</li>
<li><code>update_state</code> updates the state</li>
<li><code>update_state</code> releases the write lock</li>
<li><code>foo</code> successfully acquires a read lock</li>
<li><code>foo</code> calls <code>bar</code></li>
<li><code>bar</code> acquires a read lock</li>
<li><code>bar</code> releases its read lock</li>
<li><code>foo</code> releases its read lock</li>
</ul>
<p>But the following scenario isn&#39;t:</p>
<ul>
<li><code>foo</code> acquires a read lock</li>
<li><code>update_state</code> tries to acquire a write lock... (it blocks for now)</li>
<li><code>foo</code> calls <code>bar</code></li>
<li><code>bar</code> tries to acquire a read lock... (it blocks for now)</li>
</ul>
<p>And neither <code>bar</code> nor <code>update_state</code> can ever acquire their lock. Because a
write lock is &#34;pending&#34;, no additional read locks can be acquired. But because
<code>foo</code> called <code>bar</code>, we need <em>two</em> read locks to ever return from <code>foo</code> (and
release its read lock).</p>
<p>In other words, we have an &#34;RWR&#34; interleaving, and that&#39;s a deadlock. &#34;WRR&#34;
would be fine, so would &#34;RRW&#34;, but &#34;RWR&#34; is not.</p>
<p>So, that&#39;s a mistake Rust doesn&#39;t catch.</p>
<p>Of course, we can refactor our code so the mistake is less likely to occur!</p>
<p>We could, for example, move <code>entries</code> out of <code>State</code>, and have every function
that needs it take an immutable reference to it:</p>
<pre><p>Rust code</p><p><code><i>use</i> parking_lot<i>::</i>RwLock<i>;</i>
<i>use</i> rand<i>::</i>Rng<i>;</i>
<i>use</i> std<i>::</i>{collections<i>::</i>HashMap, sync<i>::</i>Arc, time<i>::</i>Instant}<i>;</i>

<i>#<i>[</i>derive<i>(</i>Default<i>)</i><i>]</i></i>
<i>struct</i> <i>State</i> {}

<i>impl</i> <i>State</i> {
    <i>fn</i> <i>update_state</i><i>(</i><i>&amp;</i><i>self</i>, <i>entries</i>: <i>&amp;</i><i>mut</i> <i>HashMap</i><i>&lt;</i><i>u64</i>, <i>u64</i><i>&gt;</i><i>)</i> {
        <i>let</i> key = rand<i>::</i><i>thread_rng</i><i>(</i><i>)</i><i>.</i><i>gen_range</i><i>(</i><i>0</i>..<i>10</i><i>)</i><i>;</i>
        <i>*</i>entries<i>.</i><i>entry</i><i>(</i>key<i>)</i><i>.</i><i>or_default</i><i>(</i><i>)</i> += <i>1</i><i>;</i>
    }

    <i>fn</i> <i>foo</i><i>(</i><i>&amp;</i><i>self</i>, <i>entries</i>: <i>&amp;</i><i>HashMap</i><i>&lt;</i><i>u64</i>, <i>u64</i><i>&gt;</i><i>)</i> {
        <i>if</i> entries<i>.</i><i>get</i><i>(</i><i>&amp;</i><i>4</i><i>)</i><i>.</i><i>copied</i><i>(</i><i>)</i><i>.</i><i>unwrap_or_default</i><i>(</i><i>)</i> % <i>2</i> == <i>0</i> {
            <i>// do something</i>
        } <i>else</i> {
            <i>self</i><i>.</i><i>bar</i><i>(</i>entries<i>)</i><i>;</i>
        }
    }

    <i>fn</i> <i>bar</i><i>(</i><i>&amp;</i><i>self</i>, <i>entries</i>: <i>&amp;</i><i>HashMap</i><i>&lt;</i><i>u64</i>, <i>u64</i><i>&gt;</i><i>)</i> {
        <i>if</i> entries<i>.</i><i>get</i><i>(</i><i>&amp;</i><i>2</i><i>)</i><i>.</i><i>is_some</i><i>(</i><i>)</i> {
            <i>// do something</i>
        } <i>else</i> {
            <i>// do something else</i>
        }
    }
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> entries: <i>Arc</i><i>&lt;</i><i>RwLock</i><i>&lt;</i><i>HashMap</i><i>&lt;</i><i>u64</i>, <i>u64</i><i>&gt;</i><i>&gt;</i><i>&gt;</i> = <i>Default</i><i>::</i><i>default</i><i>(</i><i>)</i><i>;</i>
    <i>let</i> s: <i>Arc</i><i>&lt;</i><i>State</i><i>&gt;</i> = <i>Default</i><i>::</i><i>default</i><i>(</i><i>)</i><i>;</i>

    std<i>::</i>thread<i>::</i><i>spawn</i><i>(</i>{
        <i>let</i> s = s<i>.</i><i>clone</i><i>(</i><i>)</i><i>;</i>
        <i>let</i> entries = entries<i>.</i><i>clone</i><i>(</i><i>)</i><i>;</i>
        <i>move</i> || <i>loop</i> {
            s<i>.</i><i>update_state</i><i>(</i><i>&amp;</i><i>mut</i> entries<i>.</i><i>write</i><i>(</i><i>)</i><i>)</i><i>;</i>
        }
    }<i>)</i><i>;</i>

    <i>let</i> before = <i>Instant</i><i>::</i><i>now</i><i>(</i><i>)</i><i>;</i>
    <i>for</i> _ <i>in</i> <i>0</i>..<i>10_000</i> {
        s<i>.</i><i>foo</i><i>(</i><i>&amp;</i>entries<i>.</i><i>read</i><i>(</i><i>)</i><i>)</i><i>;</i>
    }
    <i>println</i><i>!</i><i>(</i><i>&#34;All done in {:?}&#34;</i>, before.elapsed<i>(</i><i>)</i><i>)</i><i>;</i>
}
</code></p></pre>
<p>But now you have a whole lot of bookkeeping to take care of.</p>
<p>Another option is to make a second struct, <code>ReadLockedState</code>, that has its own
read guard:</p>
<pre><p>Rust code</p><p><code><i>use</i> parking_lot<i>::</i>{RwLock, RwLockReadGuard}<i>;</i>
<i>use</i> rand<i>::</i>Rng<i>;</i>
<i>use</i> std<i>::</i>{collections<i>::</i>HashMap, sync<i>::</i>Arc, time<i>::</i>Instant}<i>;</i>

<i>#<i>[</i>derive<i>(</i>Default<i>)</i><i>]</i></i>
<i>struct</i> <i>State</i> {
    <i>entries</i>: <i>Arc</i><i>&lt;</i><i>RwLock</i><i>&lt;</i><i>HashMap</i><i>&lt;</i><i>u64</i>, <i>u64</i><i>&gt;</i><i>&gt;</i><i>&gt;</i>,
}

<i>impl</i> <i>State</i> {
    <i>fn</i> <i>update_state</i><i>(</i><i>&amp;</i><i>self</i><i>)</i> {
        <i>let</i> <i>mut</i> entries = <i>self</i><i>.</i><i>entries</i><i>.</i><i>write</i><i>(</i><i>)</i><i>;</i>
        <i>let</i> key: <i>u64</i> = rand<i>::</i><i>thread_rng</i><i>(</i><i>)</i><i>.</i><i>gen_range</i><i>(</i><i>0</i>..<i>10</i><i>)</i><i>;</i>
        <i>*</i>entries<i>.</i><i>entry</i><i>(</i>key<i>)</i><i>.</i><i>or_default</i><i>(</i><i>)</i> += <i>1</i><i>;</i>
    }

    <i>fn</i> <i>read</i><i>(</i><i>&amp;</i><i>self</i><i>)</i> -&gt; <i>ReadLockedState</i><i>&lt;</i><i>&#39;</i><i>_</i><i>&gt;</i> {
        <i>ReadLockedState</i> {
            <i>entries</i>: <i>self</i><i>.</i><i>entries</i><i>.</i><i>read</i><i>(</i><i>)</i>,
        }
    }
}

<i>struct</i> <i>ReadLockedState</i><i>&lt;</i><i>&#39;</i><i>a</i><i>&gt;</i> {
    <i>entries</i>: <i>RwLockReadGuard</i><i>&lt;</i><i>&#39;</i><i>a</i>, <i>HashMap</i><i>&lt;</i><i>u64</i>, <i>u64</i><i>&gt;</i><i>&gt;</i>,
}

<i>impl</i> <i>ReadLockedState</i><i>&lt;</i><i>&#39;</i><i>_</i><i>&gt;</i> {
    <i>fn</i> <i>foo</i><i>(</i><i>&amp;</i><i>self</i><i>)</i> {
        <i>if</i> <i>self</i><i>.</i><i>entries</i><i>.</i><i>get</i><i>(</i><i>&amp;</i><i>4</i><i>)</i><i>.</i><i>copied</i><i>(</i><i>)</i><i>.</i><i>unwrap_or_default</i><i>(</i><i>)</i> % <i>2</i> == <i>0</i> {
            <i>// do something</i>
        } <i>else</i> {
            <i>self</i><i>.</i><i>bar</i><i>(</i><i>)</i><i>;</i>
        }
    }

    <i>fn</i> <i>bar</i><i>(</i><i>&amp;</i><i>self</i><i>)</i> {
        <i>if</i> <i>self</i><i>.</i><i>entries</i><i>.</i><i>get</i><i>(</i><i>&amp;</i><i>2</i><i>)</i><i>.</i><i>is_some</i><i>(</i><i>)</i> {
            <i>// do something</i>
        } <i>else</i> {
            <i>// do something else</i>
        }
    }
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> s: <i>Arc</i><i>&lt;</i><i>State</i><i>&gt;</i> = <i>Default</i><i>::</i><i>default</i><i>(</i><i>)</i><i>;</i>

    std<i>::</i>thread<i>::</i><i>spawn</i><i>(</i>{
        <i>let</i> s = s<i>.</i><i>clone</i><i>(</i><i>)</i><i>;</i>
        <i>move</i> || <i>loop</i> {
            s<i>.</i><i>update_state</i><i>(</i><i>)</i><i>;</i>
        }
    }<i>)</i><i>;</i>

    <i>let</i> before = <i>Instant</i><i>::</i><i>now</i><i>(</i><i>)</i><i>;</i>
    <i>for</i> _ <i>in</i> <i>0</i>..<i>10_000</i> {
        s<i>.</i><i>read</i><i>(</i><i>)</i><i>.</i><i>foo</i><i>(</i><i>)</i><i>;</i>
    }
    <i>println</i><i>!</i><i>(</i><i>&#34;All done in {:?}&#34;</i>, before.elapsed<i>(</i><i>)</i><i>)</i><i>;</i>
}
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo run --quiet
All done in 1.96135045s
</code></p></pre>
<p>I like that solution a lot more, but it&#39;s not ideal either. There&#39;s probably
other fields in <code>State</code>, and you might want to access those from
<code>ReadLockedState</code> as well, so you&#39;d either have to reference all of them, or
have a <code>&amp;&#39;a State</code> in there (re-opening the danger of calling
<code>self.state.entries.read()</code>), or you&#39;d have to split <code>State</code> into two sub-structs:
one that is <code>RwLock</code>-protected, and one that isn&#39;t (and the <code>ReadLockedState</code> struct
would have a <code>&amp;&#39;a ReadOnlyState</code>, and a <code>RwLockReadGuard&lt;&#39;a, ProtectedState&gt;</code>, or something).</p>
<p>But maybe there&#39;s some other <code>Arc&lt;RwLock&lt;T&gt;&gt;</code> fields in there too, complicating
the matter further. So there&#39;s no silver bullet.</p>
<p>And yet, one could imagine a language feature that would let you specify a
constraint like: I do not want it to be possible for several read locks for this
<code>RwLock</code> in the same call stack.</p>
<p>After all, this bit seems fairly easy to analyze statically:</p>
<pre><p>Rust code</p><p><code><i>impl</i> <i>State</i> {
    <i>fn</i> <i>foo</i><i>(</i><i>&amp;</i><i>self</i><i>)</i> {
        <i>let</i> entries = <i>self</i><i>.</i><i>entries</i><i>.</i><i>read</i><i>(</i><i>)</i><i>;</i>
        <i>if</i> entries<i>.</i><i>get</i><i>(</i><i>&amp;</i><i>4</i><i>)</i><i>.</i><i>copied</i><i>(</i><i>)</i><i>.</i><i>unwrap_or_default</i><i>(</i><i>)</i> % <i>2</i> == <i>0</i> {
            <i>// do something</i>
        } <i>else</i> {
            <i>self</i><i>.</i><i>bar</i><i>(</i><i>)</i><i>;</i>
        }
    }

    <i>fn</i> <i>bar</i><i>(</i><i>&amp;</i><i>self</i><i>)</i> {
        <i>// ðŸ›‘ error! cannot call `self.entries.read()` because `bar()` can be</i>
        <i>// called by `foo()`, which is already holding a read lock to</i>
        <i>// `self.entries`.</i>
        <i>let</i> entries = <i>self</i><i>.</i><i>entries</i><i>.</i><i>read</i><i>(</i><i>)</i><i>;</i>
        <i>if</i> entries<i>.</i><i>get</i><i>(</i><i>&amp;</i><i>2</i><i>)</i><i>.</i><i>is_some</i><i>(</i><i>)</i> {
            <i>// do something</i>
        } <i>else</i> {
            <i>// do something else</i>
        }
    }
}
</code></p></pre>
<p>It&#39;s just not something Rust is designed to protect against - at least, not
today. </p>

</div><div>
  
    
    
      <p>
    This article was made possible thanks to my patrons:
    asaaki, Yves, koivunej, Jonathan LEI, tonygo_, Raymond Hammarling, Scott Wilson,
Christopher Sidebottom, Xirvik Servers, Noodles, Ivo Murrell, Max Goisser, Mark
Hastings, compwhizii, Arun Kulshreshtha, Andy Yu, Vivek Ghaisas, Andronik,
Prince Wilson, Olivia Crain, Jonathan Strickland, s1ck, Alexander Payne, Fredrik
Ã˜strem, David Barsky, Yufan Lou, Stephen Molyneaux, Barret Rennie, Thomas
Corbin, MW, Jacob Cheriathundam, Michael Watzko, Embark Studios, Eugene Bulkin,
Marcus Griep, Tool Army, Tully, Santiago Lema, Spencer Gilbert, JÃ¶rn Huxhorn,
Garrett Ward, DEX, Christian Oudard, Ronen Cohen, Thor Kamphefner, Kamran Khan,
Cole Kurkowski, Arjen Laarhoven, Vicente Bosch, Chirag Jain, Ville Mattila,
Marie Janssen, Vladyslav Batyrenko, spike grobstein, Jon Gjengset, Paul Marques
Mota, Jakub FijaÅ‚kowski, Mitchell Hamilton, Brad Luyster, Max von Forell, Jake
S, Dimitri Merejkowsky, Chris Biscardi, Alex Doroshenko, Steven McGuire, Chad
Birch, Chris Emery, Bob Ippolito, John Van Enk, metabaron, Isak Sunde Singh,
Mads Johansen, lukvol, Ives van Hoorne, Jan De Landtsheer, Daniel Strittmatter,
Evgeniy Dubovskoy, Alex Rudy, Shane Lillie, Romet Tagobert, Douglas Creager,
Corey Alexander, Molly Howell, knutwalker, Zachary Dremann, Sebastian Ziebell,
Julien Roncaglia, Amber Kowalski, T, queenfartbutt, I Love Cake, Kristoffer
StrÃ¶m, Astrid Bek, Yoh Deadfall, Justin Ossevoort, TomÃ¡Å¡ Duda, Jeremy Banks,
Rasmus Larsen, Torben Clasen, C J Silverio, Walther, Pete Bevin, Shane Sveller,
Clara Schultz, jer, JoÃ£o Veiga, Richard Pringle, Adam Perry, Benjamin RÃ¶jder
Delnavaz, Matt Jadczak, tavr, Jonathan Knapp, Maximilian, Seth Stadick,
brianloveswords, Sean Bryant, Ember, Sebastian Zimmer, Luiz Irber, Makoto
Nakashima, Geoff Cant, Geoffroy Couprie, Michael Alyn Miller, o0Ignition0o,
Zaki, Raphael Gaschignard, Romain Ruetschi, Ignacio Vergara, Pascal, Jane Lusby,
Nicolas Goy, Ted Mielczarek, JesÃºs Higueras, Aurora.
</p>
    
  

  

  <div>
    
    
    <p><a target="_blank" href="https://blog.plover.com/comments?url=https%3A%2F%2Ffasterthanli.me%2Farticles%2Fsome-mistakes-rust-doesnt-catch&amp;title=Some mistakes Rust doesn&#39;t catch">
      <span>
        <svg enable-background="new 0 0 24 24" height="512" viewBox="0 0 24 24" width="512" xmlns="http://www.w3.org/2000/svg">
  <path d="m21.325 9.308c-.758 0-1.425.319-1.916.816-1.805-1.268-4.239-2.084-6.936-2.171l1.401-6.406 4.461 1.016c0 1.108.89 2.013 1.982 2.013 1.113 0 2.008-.929 2.008-2.038s-.889-2.038-2.007-2.038c-.779 0-1.451.477-1.786 1.129l-4.927-1.108c-.248-.067-.491.113-.557.365l-1.538 7.062c-2.676.113-5.084.928-6.895 2.197-.491-.518-1.184-.837-1.942-.837-2.812 0-3.733 3.829-1.158 5.138-.091.405-.132.837-.132 1.268 0 4.301 4.775 7.786 10.638 7.786 5.888 0 10.663-3.485 10.663-7.786 0-.431-.045-.883-.156-1.289 2.523-1.314 1.594-5.115-1.203-5.117zm-15.724 5.41c0-1.129.89-2.038 2.008-2.038 1.092 0 1.983.903 1.983 2.038 0 1.109-.89 2.013-1.983 2.013-1.113.005-2.008-.904-2.008-2.013zm10.839 4.798c-1.841 1.868-7.036 1.868-8.878 0-.203-.18-.203-.498 0-.703.177-.18.491-.18.668 0 1.406 1.463 6.07 1.488 7.537 0 .177-.18.491-.18.668 0 .207.206.207.524.005.703zm-.041-2.781c-1.092 0-1.982-.903-1.982-2.011 0-1.129.89-2.038 1.982-2.038 1.113 0 2.008.903 2.008 2.038-.005 1.103-.895 2.011-2.008 2.011z"></path>
  </svg>
      </span>
      Discuss this article on /r/fasterthanlime
    </a>
  </p></div>

  <div>
  
    <p>If you liked this article, please support my work on Patreon!</p>
    <p>
      <a href="https://www.patreon.com/bePatron?u=47556">
        <img src="https://blog.plover.com/img/patreon/mark-white.png"/>
        <span>Become a Patron</span>
      </a>
    </p>
  
</div>


  <div>
    
    
  </div>

  <div>
    <div><p>
      Looking for <a href="https://blog.plover.com/">the homepage</a>?
    </p></div>

    
    
    
      <div><p>
        Another article: <a href="https://blog.plover.com/articles/abstracting-away-correctness">Abstracting away correctness</a>
      </p></div>
    
  </div>
</div></div>
  </body>
</html>
