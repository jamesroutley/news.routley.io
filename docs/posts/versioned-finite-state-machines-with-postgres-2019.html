<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://raphael.medaer.me/2019/06/12/pgfsm.html">Original</a>
    <h1>Versioned finite-state machines with Postgres (2019)</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
    <p>Inspired by <a href="https://felixge.de/2017/07/27/implementing-state-machines-in-postgresql.html">Felix Geisendorfer blog post</a> I implemented a database FSM (Finite-State Machine) with Postgresql.
I brought some improvements to Felix’s implementation but before reading the following I recommend you to read carefully <a href="https://felixge.de/2017/07/27/implementing-state-machines-in-postgresql.html">the original post</a>.
<!--more--></p>

<p><strong>TL;DR</strong> Here are the changes I did:</p>

<ul>
  <li>Introduced a versioning control of the FSM.</li>
  <li>Optimized performances and data storage.</li>
  <li>Added some protection against user mistakes</li>
</ul>

<p>To keep it simple I’ll use exactly the same FSM graph than Felix: an ordering process with payment and shipment steps.</p>

<p><img src="https://raphael.medaer.me/assets/img/pgfsm-graph-v1.png" alt=""/></p>

<h3 id="types-optimization">Types optimization</h3>

<p>First I replaced the storage of states/events from <code>text</code> to <code>enum</code>. Because I have a finite number of states and transitions I can properly store them as custom <code>enum</code>. It reduces the storage of these to a lighter and constant 4 bytes.</p>

<div><div><pre><code><span>CREATE</span> <span>TYPE</span> <span>order_state</span> <span>AS</span> <span>ENUM</span> <span>(</span>
  <span>&#39;start&#39;</span><span>,</span>
  <span>&#39;awaiting_payment&#39;</span><span>,</span>
  <span>&#39;awaiting_shipment&#39;</span><span>,</span>
  <span>&#39;awaiting_refund&#39;</span><span>,</span>
  <span>&#39;shipped&#39;</span><span>,</span>
  <span>&#39;canceled&#39;</span><span>,</span>
  <span>&#39;error&#39;</span>
<span>);</span>
<span>CREATE</span> <span>TYPE</span> <span>order_event</span> <span>AS</span> <span>ENUM</span> <span>(</span>
  <span>&#39;create&#39;</span><span>,</span>
  <span>&#39;pay&#39;</span><span>,</span>
  <span>&#39;ship&#39;</span><span>,</span>
  <span>&#39;refund&#39;</span><span>,</span>
  <span>&#39;cancel&#39;</span>
<span>);</span>
</code></pre></div></div>

<p>If later I have to add new state or event I can easily do:</p>

<div><div><pre><code><span>ALTER</span> <span>TYPE</span> <span>order_event</span> <span>ADD</span> <span>VALUE</span> <span>&#39;my_new_event&#39;</span><span>;</span>
</code></pre></div></div>

<p>Obviously it impacts the <code>order_events</code> table:</p>

<div><div><pre><code><span>CREATE</span> <span>TABLE</span> <span>order_events</span> <span>(</span>
  <span>id</span> <span>bigint</span> <span>GENERATED</span> <span>ALWAYS</span> <span>AS</span> <span>IDENTITY</span> <span>PRIMARY</span> <span>KEY</span><span>,</span>
  <span>order_id</span> <span>uuid</span> <span>NOT</span> <span>NULL</span> <span>DEFAULT</span> <span>uuid_generate_v4</span><span>(),</span>
  <span>event</span> <span>order_event</span> <span>NOT</span> <span>NULL</span> <span>DEFAULT</span> <span>&#39;create&#39;</span><span>,</span>
  <span>time</span> <span>timestamp</span> <span>DEFAULT</span> <span>now</span><span>()</span> <span>NOT</span> <span>NULL</span>
<span>);</span>
</code></pre></div></div>

<p>As you noticed I replaced the <code>order_id</code> type from <code>INT</code> to <code>uuid</code>. In brief because it’s out of scope: <a href="https://www.clever-cloud.com/blog/engineering/2015/05/20/why-auto-increment-is-a-terrible-idea/">I never use serial for fields going out of database</a>.</p>

<h3 id="transition-mechanism-improvements">Transition mechanism improvements</h3>

<p>In his implementation, Felix Geisendorfer is using a <code>switch</code> statement to implement the state transition.
It’s a fine and straightforward solution. However, if you have more states/events it could become hard to maintain. Furthermore if you want to version your FSM, you’ll often have to <code>CREATE OR REPLACE FUNCTION</code>.
Instead I created a <em>mapping table</em> with 3 columns:</p>

<ul>
  <li><code>state</code>: the current state</li>
  <li><code>event</code>: the event which causes the transition</li>
  <li><code>next_state</code>: the resulting state</li>
</ul>

<div><div><pre><code><span>CREATE</span> <span>TABLE</span> <span>order_events_transitions</span> <span>(</span>
  <span>state</span>      <span>order_state</span> <span>NOT</span> <span>NULL</span><span>,</span>
  <span>event</span>      <span>order_event</span> <span>NOT</span> <span>NULL</span><span>,</span>
  <span>next_state</span> <span>order_state</span> <span>NOT</span> <span>NULL</span><span>,</span>
  <span>PRIMARY</span> <span>KEY</span> <span>(</span><span>state</span><span>,</span> <span>event</span><span>,</span> <span>next_state</span><span>)</span>
<span>);</span>
</code></pre></div></div>

<p><em>AN: I can limit transitions to only one path for two given states with <code>PRIMARY KEY (state, event)</code>.</em></p>

<p>Any transition which is not in this table will be resolved as <code>error</code> state in our new transition function:</p>

<div><div><pre><code><span>CREATE</span> <span>FUNCTION</span> <span>order_events_transition</span><span>(</span><span>_state</span> <span>order_state</span><span>,</span> <span>_event</span> <span>order_event</span><span>)</span>
<span>RETURNS</span> <span>order_state</span> <span>LANGUAGE</span> <span>sql</span> <span>AS</span> <span>$$</span>
<span>SELECT</span> <span>COALESCE</span><span>(</span>
  <span>(</span><span>SELECT</span> <span>next_state</span> <span>FROM</span> <span>order_events_transitions</span> <span>WHERE</span> <span>state</span><span>=</span><span>_state</span> <span>AND</span> <span>event</span><span>=</span><span>_event</span><span>),</span>
  <span>&#39;error&#39;</span><span>::</span><span>order_state</span>
<span>);</span>
<span>$$</span><span>;</span>
</code></pre></div></div>

<p><em>AN: There is maybe a better way then “COALESCE” to implement the “default”…</em></p>

<p>OK! It’s now time to write valid transitions:</p>

<div><div><pre><code><span>INSERT</span> <span>INTO</span> <span>order_events_transitions</span> <span>VALUES</span>
  <span>(</span><span>&#39;start&#39;</span><span>,</span>             <span>&#39;create&#39;</span><span>,</span> <span>&#39;awaiting_payment&#39;</span> <span>),</span>
  <span>(</span><span>&#39;awaiting_payment&#39;</span><span>,</span>  <span>&#39;pay&#39;</span><span>,</span>    <span>&#39;awaiting_shipment&#39;</span><span>),</span>
  <span>(</span><span>&#39;awaiting_payment&#39;</span><span>,</span>  <span>&#39;cancel&#39;</span><span>,</span> <span>&#39;canceled&#39;</span>         <span>),</span>
  <span>(</span><span>&#39;awaiting_shipment&#39;</span><span>,</span> <span>&#39;cancel&#39;</span><span>,</span> <span>&#39;awaiting_refund&#39;</span>  <span>),</span>
  <span>(</span><span>&#39;awaiting_shipment&#39;</span><span>,</span> <span>&#39;ship&#39;</span><span>,</span>   <span>&#39;shipped&#39;</span>          <span>),</span>
  <span>(</span><span>&#39;awaiting_refund&#39;</span><span>,</span>   <span>&#39;refund&#39;</span><span>,</span> <span>&#39;canceled&#39;</span>         <span>);</span>
</code></pre></div></div>

<h3 id="fsm-graph-versioning">FSM graph versioning</h3>

<p>In real life my use cases and business processes are moving (fast). Probably yours as well.
Since the FSM I build is the implementation of this processes, each change IRL impacts my database design.</p>

<p>For instance a state <code>awaiting_approval</code> could be added before allowing to pay.</p>

<p><img src="https://raphael.medaer.me/assets/img/pgfsm-graph-v2.png" alt=""/></p>

<p>If I change my transition function and table without taking care of past <code>order_events</code>, I will completly break my FSM. Indeed because I’m moving the <code>create</code> event, all the already recorded transitions will raise an <code>error</code> state. It’s not <a href="https://en.wikipedia.org/wiki/Maintainability">maintainable</a>!</p>

<blockquote>
  <p>How to handle multiple versions of my FSM graph ?</p>
</blockquote>

<p>Introducing version control in my design will solve this issue.</p>

<p>First I create a table to store the versions and their status:</p>

<div><div><pre><code><span>CREATE</span> <span>TYPE</span> <span>order_fsm_version_status</span> <span>AS</span> <span>ENUM</span> <span>(</span>
  <span>&#39;live&#39;</span><span>,</span>
  <span>&#39;deprecated&#39;</span><span>,</span>
  <span>&#39;obsolete&#39;</span>
<span>);</span>
<span>CREATE</span> <span>TABLE</span> <span>order_fsm_versions</span><span>(</span>
  <span>version</span> <span>integer</span> <span>GENERATED</span> <span>ALWAYS</span> <span>AS</span> <span>IDENTITY</span> <span>PRIMARY</span> <span>KEY</span><span>,</span>
  <span>status</span>  <span>order_fsm_version_status</span> <span>NOT</span> <span>NULL</span> <span>DEFAULT</span> <span>&#39;live&#39;</span>
<span>);</span>
</code></pre></div></div>

<p>In the meanwhile I create a function to get the last FSM up-and-running version:</p>

<div><div><pre><code><span>CREATE</span> <span>FUNCTION</span> <span>order_fsm_last_version</span><span>()</span>
<span>RETURNS</span> <span>integer</span> <span>LANGUAGE</span> <span>sql</span> <span>AS</span> <span>$$</span>
<span>SELECT</span> <span>version</span> <span>FROM</span> <span>order_fsm_versions</span> <span>WHERE</span> <span>status</span><span>=</span><span>&#39;live&#39;</span> <span>ORDER</span> <span>BY</span> <span>version</span> <span>DESC</span> <span>LIMIT</span> <span>1</span><span>;</span>
<span>$$</span><span>;</span>
</code></pre></div></div>
<p>Both <code>order_events</code> and <code>order_events_transitions</code> will need to reference this version:</p>

<div><div><pre><code><span>CREATE</span> <span>TABLE</span> <span>order_events</span> <span>(</span>
  <span>id</span>       <span>bigint</span>      <span>GENERATED</span> <span>ALWAYS</span> <span>AS</span> <span>IDENTITY</span> <span>PRIMARY</span> <span>KEY</span><span>,</span>
  <span>order_id</span> <span>uuid</span>        <span>NOT</span> <span>NULL</span> <span>DEFAULT</span> <span>uuid_generate_v4</span><span>(),</span>
  <span>event</span>    <span>order_event</span> <span>NOT</span> <span>NULL</span> <span>DEFAULT</span> <span>&#39;create&#39;</span><span>,</span>
  <span>version</span>  <span>integer</span>     <span>NOT</span> <span>NULL</span> <span>DEFAULT</span> <span>order_fsm_last_version</span><span>(),</span>
  <span>time</span>     <span>timestamp</span>   <span>NOT</span> <span>NULL</span> <span>DEFAULT</span> <span>now</span><span>(),</span>
  <span>FOREIGN</span> <span>KEY</span> <span>(</span><span>version</span><span>)</span> <span>REFERENCES</span> <span>order_fsm_versions</span><span>(</span><span>version</span><span>)</span>
<span>);</span>

<span>CREATE</span> <span>TABLE</span> <span>order_events_transitions</span> <span>(</span>
  <span>state</span>      <span>order_state</span> <span>NOT</span> <span>NULL</span><span>,</span>
  <span>event</span>      <span>order_event</span> <span>NOT</span> <span>NULL</span><span>,</span>
  <span>version</span>    <span>integer</span>     <span>NOT</span> <span>NULL</span> <span>DEFAULT</span> <span>order_fsm_last_version</span><span>(),</span>
  <span>next_state</span> <span>order_state</span> <span>NOT</span> <span>NULL</span><span>,</span>
  <span>PRIMARY</span> <span>KEY</span> <span>(</span><span>state</span><span>,</span> <span>event</span><span>,</span> <span>version</span><span>,</span> <span>next_state</span><span>),</span>
  <span>FOREIGN</span> <span>KEY</span> <span>(</span><span>version</span><span>)</span> <span>REFERENCES</span> <span>order_fsm_versions</span><span>(</span><span>version</span><span>)</span>
<span>);</span>
</code></pre></div></div>

<p>The transition function and its aggregate also have to take care of this version number:</p>

<div><div><pre><code><span>CREATE</span> <span>FUNCTION</span> <span>order_events_transition</span><span>(</span>
  <span>_state</span> <span>order_state</span><span>,</span>
  <span>_event</span> <span>order_event</span><span>,</span>
  <span>_version</span> <span>integer</span> <span>DEFAULT</span> <span>order_fsm_last_version</span><span>()</span>
<span>)</span> <span>RETURNS</span> <span>order_state</span> <span>LANGUAGE</span> <span>sql</span> <span>AS</span> <span>$$</span>
  <span>SELECT</span> <span>COALESCE</span><span>(</span>
    <span>(</span><span>SELECT</span> <span>next_state</span>
     <span>FROM</span> <span>order_events_transitions</span>
     <span>WHERE</span> <span>state</span><span>=</span><span>_state</span> <span>AND</span> <span>event</span><span>=</span><span>_event</span> <span>AND</span> <span>version</span><span>=</span><span>_version</span><span>),</span>
    <span>&#39;error&#39;</span><span>::</span><span>order_state</span><span>);</span>
<span>$$</span><span>;</span>
<span>CREATE</span> <span>AGGREGATE</span> <span>order_events_fsm</span><span>(</span><span>order_event</span><span>,</span> <span>integer</span><span>)</span> <span>(</span>
  <span>SFUNC</span> <span>=</span> <span>order_events_transition</span><span>,</span>
  <span>STYPE</span> <span>=</span> <span>order_state</span><span>,</span>
  <span>INITCOND</span> <span>=</span> <span>&#39;start&#39;</span>
<span>);</span>
</code></pre></div></div>

<p>And finally we have to restrict some transitions according to version status. It is done in the <code>order_events_trigger</code>:</p>

<div><div><pre><code><span>CREATE</span> <span>FUNCTION</span> <span>order_events_trigger_func</span><span>()</span> <span>RETURNS</span> <span>trigger</span>
<span>LANGUAGE</span> <span>plpgsql</span> <span>AS</span> <span>$$</span>
<span>DECLARE</span>
  <span>next_state</span> <span>order_state</span><span>;</span>
  <span>transition_status</span> <span>order_fsm_version_status</span><span>;</span>
<span>BEGIN</span>
  <span>SELECT</span> <span>status</span> <span>FROM</span> <span>order_fsm_versions</span> <span>WHERE</span> <span>version</span><span>=</span><span>new</span><span>.</span><span>version</span> <span>INTO</span> <span>transition_status</span><span>;</span>
  <span>IF</span> <span>transition_status</span> <span>=</span> <span>&#39;deprecated&#39;</span><span>::</span><span>order_fsm_version_status</span> <span>THEN</span>
    <span>RAISE</span> <span>NOTICE</span> <span>&#39;version % is deprecated&#39;</span><span>,</span> <span>new</span><span>.</span><span>version</span><span>;</span>
  <span>END</span> <span>IF</span><span>;</span>
  <span>IF</span> <span>transition_status</span> <span>=</span> <span>&#39;obsolete&#39;</span><span>::</span><span>order_fsm_version_status</span> <span>THEN</span>
    <span>RAISE</span> <span>EXCEPTION</span> <span>&#39;version % is obsolete&#39;</span><span>,</span> <span>new</span><span>.</span><span>version</span><span>;</span>
  <span>END</span> <span>IF</span><span>;</span>

  <span>SELECT</span> <span>order_events_fsm</span><span>(</span><span>event</span><span>,</span> <span>version</span> <span>ORDER</span> <span>BY</span> <span>id</span><span>)</span>
  <span>FROM</span> <span>(</span>
    <span>SELECT</span> <span>id</span><span>,</span> <span>event</span><span>,</span> <span>version</span> <span>FROM</span> <span>order_events</span> <span>WHERE</span> <span>order_id</span> <span>=</span> <span>new</span><span>.</span><span>order_id</span>
    <span>UNION</span>
    <span>SELECT</span> <span>new</span><span>.</span><span>id</span><span>,</span> <span>new</span><span>.</span><span>event</span><span>,</span> <span>new</span><span>.</span><span>version</span>
  <span>)</span> <span>s</span>
  <span>INTO</span> <span>next_state</span><span>;</span>

  <span>IF</span> <span>next_state</span> <span>=</span> <span>&#39;error&#39;</span><span>::</span><span>order_state</span> <span>THEN</span>
    <span>RAISE</span> <span>EXCEPTION</span> <span>&#39;invalid order event&#39;</span><span>;</span>
  <span>END</span> <span>IF</span><span>;</span>

  <span>RETURN</span> <span>new</span><span>;</span>
<span>END</span>
<span>$$</span><span>;</span>
</code></pre></div></div>

<p>I can now introduce new versions of my FSM graph and deprecate previous one. When I insert row in <code>order_events</code> it is using by default the last <code>live</code> version of the graph.</p>

<div><div><pre><code><span>INSERT</span> <span>INTO</span> <span>order_fsm_versions</span> <span>(</span><span>version</span><span>,</span> <span>status</span><span>)</span> <span>VALUES</span> <span>(</span><span>2</span><span>,</span> <span>&#39;live&#39;</span><span>)</span> <span>RETURNING</span> <span>*</span><span>;</span>
<span>UPDATE</span> <span>order_fsm_versions</span> <span>SET</span> <span>status</span><span>=</span><span>&#39;deprecated&#39;</span> <span>WHERE</span> <span>version</span> <span>=</span> <span>1</span><span>;</span>

<span>INSERT</span> <span>INTO</span> <span>order_events_transitions</span> <span>(</span><span>state</span><span>,</span> <span>event</span><span>,</span> <span>next_state</span><span>,</span> <span>version</span><span>)</span> <span>VALUES</span>
  <span>(</span><span>&#39;start&#39;</span><span>,</span>             <span>&#39;create&#39;</span><span>,</span>  <span>&#39;awaiting_approval&#39;</span><span>,</span> <span>2</span><span>),</span>
  <span>(</span><span>&#39;awaiting_approval&#39;</span><span>,</span> <span>&#39;approve&#39;</span><span>,</span> <span>&#39;awaiting_payment&#39;</span><span>,</span>  <span>2</span><span>),</span>
  <span>(</span><span>&#39;awaiting_payment&#39;</span><span>,</span>  <span>&#39;pay&#39;</span><span>,</span>     <span>&#39;awaiting_shipment&#39;</span><span>,</span> <span>2</span><span>),</span>
<span>(...)</span>

<span>INSERT</span> <span>INTO</span> <span>order_events</span> <span>(</span><span>order_id</span><span>,</span> <span>event</span><span>,</span> <span>time</span><span>)</span> <span>VALUES</span>
  <span>(</span><span>&#39;0d687d74-bab3-4c76-beed-0f55ec8a3af2&#39;</span><span>,</span> <span>&#39;create&#39;</span><span>,</span>  <span>&#39;2017-07-23 00:00:00&#39;</span><span>),</span>
  <span>(</span><span>&#39;0d687d74-bab3-4c76-beed-0f55ec8a3af2&#39;</span><span>,</span> <span>&#39;approve&#39;</span><span>,</span> <span>&#39;2017-07-23 00:00:00&#39;</span><span>),</span>
  <span>(</span><span>&#39;0d687d74-bab3-4c76-beed-0f55ec8a3af2&#39;</span><span>,</span> <span>&#39;pay&#39;</span><span>,</span>     <span>&#39;2017-07-23 12:00:00&#39;</span><span>);</span>
</code></pre></div></div>

<h3 id="conclusion">Conclusion</h3>

<p>I wrote <a href="https://raphael.medaer.me/resources/pgfsm.sql">a small SQL script which is testing all these features</a>. I hope it’s useful even if you can’t use it out of the box. Let me know if <a href="https://github.com/rmedaer/rmedaer.github.io/issues">you have feedback</a>.</p>

<p>Finally, keep in mind that it is still experimental. Consider it as a POC and not like something production-ready!</p>

<p>R.</p>

  </div></div>
  </body>
</html>
