<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://raku-advent.blog/2021/12/12/a-long-journey-to-ethereum-signatures/">Original</a>
    <h1>Dive into Ethereum signatures with Raku language</h1>
    
    <div id="readability-page-1" class="page"><article id="post-1413">

	

	
	<div>
		
<p>The Ethereum blockchain is essentially a transaction-based <a rel="noreferrer noopener" href="https://preethikasireddy.medium.com/how-does-ethereum-work-anyway-22d1df506369" target="_blank">state machine</a>. We begin with a blank state, before any transactions have happened on the network, and move into some final state when transactions are executed. The state of Ethereum relies on past transactions. These transactions are grouped into blocks and each block is chained together with its parent.</p>



<p>Transactions are processing by own Turing complete virtual machine – known as the <a rel="noreferrer noopener" href="https://ethereum.org/en/developers/docs/evm/" target="_blank">Ethereum Virtual Machine</a> (EVM). The EVM has its own language: <strong>EVM bytecode</strong>. Typically a programmer writes a program in a higher-level language such as <a rel="noreferrer noopener" href="https://docs.soliditylang.org/en/v0.8.10/" target="_blank">Solidity</a>. Then the program should be compiled down to EVM bytecode and commited to the Ethereum network as the new transaction. The EVM executes the transaction recursively, computing the system state and the machine state.</p>



<p>The EVM is included into the Ethereum node client software that verifies all transactions in each block, keeping the network secure and the data accurate. Many Ethereum clients exist, in a variety of programming languages such as Go, Rust, Java and others. They all follow a <a rel="noreferrer noopener" href="https://ethereum.github.io/yellowpaper/paper.pdf" target="_blank">formal specification</a>: it dictates how the Ethereum network and blockchain functions.</p>



<p>In this article we will consider <a rel="noreferrer noopener" href="https://geth.ethereum.org/docs/" target="_blank">Geth</a> as the basic Ethereum node software.</p>



<h2 id="transaction-signing-problem">Transaction signing problem</h2>



<p>Every transaction must be signed before sending to Ethereum network. This signature should be recoverable and actually is needed for a few reasons: the first one is to validate the origin, and the second one — to keep the basics of blockchain: transparency and traceability.  Traditionally on Ethereum networks transactions could be signed remotely on the nodes with enabled authentication and locally at the application level with some black-box magic.</p>



<p>The first problem for the beginners (and not only) is that most Ethereum gateways (such as <a rel="noreferrer noopener" href="https://infura.io/" target="_blank">Infura</a>, <a rel="noreferrer noopener" href="https://www.alchemy.com/" target="_blank">Alchemy</a>, <a rel="noreferrer noopener" href="https://zmok.io/" target="_blank">Zmok</a> and others) do not support authentication on their nodes due to security reasons. So, you have <a rel="noreferrer noopener" href="https://ethereum.org/en/developers/docs/nodes-and-clients/run-a-node/" target="_blank">to run your own node</a> or sign transactions locally.</p>



<p>The second problem: there’s no clear and efficient cross-language interface for Ethereum signatures management. Well, you have use some things in <a rel="noreferrer noopener" href="https://gitlab.com/pheix-io/service/-/blob/requirements/docs/auth.md#decrypt-private-key-with-python3" target="_blank">Python</a>, some in <a rel="noreferrer noopener" href="https://gitlab.com/pheix/net-ethereum-perl6/-/issues/24" target="_blank">JavaScript</a> and obviously low level implementations in <a rel="noreferrer noopener" href="https://github.com/bitcoin-core/secp256k1" target="_blank">C</a> or <a rel="noreferrer noopener" href="https://github.com/ethereum/go-ethereum/blob/d8ff53dfb8a516f47db37dbc7fd7ad18a1e8a125/crypto/crypto_test.go#L95" target="_blank">Go</a>.</p>



<p>In this article I would like to pass these tricky checkpoints with the explanations and examples and introduce fast Ethereum signing application in (almost pure) Raku.</p>



<h2 id="signing-node-the-prototype">Signing node: the prototype</h2>



<p>The remote signing node prototype was considered during <a rel="noreferrer noopener" href="https://pheix.org/embedded/page/multi-network-ethereum-dapp-in-raku" target="_blank">Multi-network Ethereum dApp in Raku</a> talk at <a rel="noreferrer noopener" href="https://conf.raku.org/" target="_blank">The 1st Raku Conference 2021</a>. The idea is to use the node pair per application: target node in private or public Ethereum network and local node running in docker just for transaction signing.</p>



<p>We should set up the mocked/shared account at local signing node: the account with the same private key and obviously address as we use for sending transactions to target node.</p>



<p>To set up the mocked/shared account we need to get the private key for origin account. A lot of account managers (like MetaMask) <a rel="noreferrer noopener" href="https://metamask.zendesk.com/hc/en-us/articles/360015289632-How-to-Export-an-Account-Private-Key" target="_blank">allow to export</a> private key. Since the private key is exported you should <a rel="noreferrer noopener" href="https://pheix.org/embedded/page/multi-network-ethereum-dapp-in-raku#21" target="_blank">generate</a> <code>keyfile</code> and copy it to your <code>keystore</code> folder. A new account will be imported on the fly.</p>



<p>On the other hand you can add new account with given private key via JSON RPC HTTP API — just post the next request to your Geth driven local signing node running at port <code>8541</code>:</p>



<pre id="advent-code-12eecd72-e417-429b-bf4d-98ac9b14208f"></pre>



<p>Since the local signing node is set up and running, we can try to sign a few transactions from a Raku application. The generic tool is <code>Net::Ethereum</code> module — Raku’s <a rel="noreferrer noopener" href="https://gitlab.com/pheix/net-ethereum-perl6" target="_blank">interface</a> for interacting with the Ethereum blockchain via JSON RPC API. This is the <a href="https://gitlab.com/pheix-research/talks/-/tree/main/advent/assets/2021" target="_blank">short code snippet</a> for Ethereum transaction signing in Raku:</p>



<pre id="advent-code-c8b045b1-0d20-47f1-8afe-d558c47fb2e6"></pre>



<p>You can dive deeply:</p>



<ol><li><code>Pheix::Controller::Blockchain::Signer</code> — <a rel="noreferrer noopener" href="https://gitlab.com/pheix-pool/core-perl6/-/blob/develop/lib/Pheix/Controller/Blockchain/Signer.rakumod" target="_blank">naive signer</a>;</li><li><code>Pheix::Model::Database::Blockchain::SendTx</code> — <a rel="noreferrer noopener" href="https://gitlab.com/pheix-pool/core-perl6/-/blob/develop/lib/Pheix/Model/Database/Blockchain/SendTx.rakumod" target="_blank">smart signer</a>;</li><li><code>Net::Ethereum</code> — signing <a rel="noreferrer noopener" href="https://gitlab.com/pheix/net-ethereum-perl6/-/blob/devel/t/05.t#L261" target="_blank">unit tests</a>.</li></ol>



<p><a href="https://pheix.org" target="_blank" rel="noreferrer noopener">Pheix CMS</a> uses <code>Pheix::Model::Database::Blockchain::SendTx</code> as the default signing module. The full integration test on <a rel="noreferrer noopener" href="https://www.rinkeby.io/" target="_blank">Rinkeby</a> test network with local signing node in docker container runs about <a rel="noreferrer noopener" href="https://gitlab.com/pheix-pool/core-perl6/-/jobs/1711114507" target="_blank">2½ hours</a>.</p>



<h2 id="make-it-possible-to-sign-transactions-locally">Make it possible to sign transactions locally</h2>



<p>Obviously Ethereum transaction could be signed manually. We need the next tools to make it possible: <a rel="noreferrer noopener" href="https://eth.wiki/fundamentals/rlp" target="_blank">rlp</a>, <a rel="noreferrer noopener" href="https://github.com/bitcoin-core/secp256k1" target="_blank">Secp256k1</a> and <a rel="noreferrer noopener" href="https://medium.com/@ConsenSys/are-you-really-using-sha-3-or-old-code-c5df31ad2b0" target="_blank">Keccak-256</a>. Finally, when transaction is successfully signed we have to send <code>sendRawTransaction</code> <a rel="noreferrer noopener" href="https://eth.wiki/json-rpc/API#eth_sendrawtransaction" target="_blank">request</a> to the target Ethereum node.</p>



<h3 id="recursive-length-prefix-rlp">Recursive Length Prefix (RLP)</h3>



<p>I have started with recursive Length Prefix (RLP). The purpose of RLP is to encode arbitrarily nested arrays of binary data, and RLP is the main encoding method used to serialize objects in Ethereum. It looks trivial and ready for direct porting to Raku.</p>



<p>Well, <code>Node::Ethereum::RLP</code> <a rel="noreferrer noopener" href="https://gitlab.com/pheix/raku-node-ethereum-rlp" target="_blank">module</a> was implemented: it delivers <code>rlp_encode</code> and <code>rlp_decode</code> methods in pure Raku. The usage is quite straight-forward:</p>



<pre id="advent-code-675fcff7-f962-4cd7-983f-0fde59efa09b"></pre>



<p>The direction of <code>Node::Ethereum::RLP</code> improving — to extend unit test suite. You can check <a rel="noreferrer noopener" href="https://arxiv.org/pdf/2009.13769.pdf" target="_blank">brilliant paper</a> <strong>«Ethereum’s Recursive Length Prefix in ACL2»</strong> by <a rel="noreferrer noopener" href="https://github.com/acoglio" target="_blank">Alessandro Coglio</a> about RLP, and see that there are a few non-trivial cases to be covered by module tests.</p>



<h3 id="ecdsa-secp256k1">ECDSA (Secp256k1)</h3>



<p>It was a little bit weird to figure out that Ethereum uses cryptography engine for signatures and keys management from Bitcoin. Not the own fork with any mods or any specific improvements, no — it’s totally borrowed “as is”. Anyway, it’s even better.</p>



<p>The path is clear: we need the Raku binding to Bitcoin’s Secp256k1 library: optimized C library for ECDSA signatures and secret/public key operations on <a rel="noreferrer noopener" href="https://en.bitcoin.it/wiki/Secp256k1" target="_blank">elliptic curve secp256k1</a>.</p>



<h4 id="usage">Usage</h4>



<p>So, the next stop is <code>Bitcoin::Core::Secp256k1</code> <a rel="noreferrer noopener" href="https://gitlab.com/pheix/raku-bitcoin-core-secp256k1" target="_blank">module</a>. It has bindings to <a rel="noreferrer noopener" href="https://github.com/bitcoin-core/secp256k1/blob/master/include/secp256k1.h" target="_blank">generic</a> and <a rel="noreferrer noopener" href="https://github.com/bitcoin-core/secp256k1/blob/master/include/secp256k1_recovery.h" target="_blank">recoverable</a> APIs. In context of Ethereum we have to use <strong>recoverable</strong> ones, cause of <a rel="noreferrer noopener" href="https://eips.ethereum.org/EIPS/eip-155" target="_blank">explicit</a> <code>recovery_param</code> (parity of <code>y</code> coordinate on ecliptic curve) and <code>ChainID</code> usage in signature. Synopsis:</p>



<pre id="advent-code-3075e893-8ecc-408c-a6e5-0f5e03d4afd6"></pre>



<h4 id="some-implementation-details">Some implementation details</h4>



<p>The implementation was much more complicated against <code>Node::Ethereum::RLP</code>. The most tricky things were (and are) the pointers to <code>CStructs</code>. If you will go through Secp256k1 C library <a rel="noreferrer noopener" href="https://github.com/bitcoin-core/secp256k1/blob/master/include/secp256k1.h" target="_blank">headers</a>, you will notice — just pointers to structs are moving between the functions. Since the Raku <a rel="noreferrer noopener" href="https://docs.raku.org/language/nativecall#Typed_pointers" target="_blank">does not allocate memory</a> for typed pointers, we need some manual magic.</p>



<p>Consider Secp256k1 ECDSA signature <a rel="noreferrer noopener" href="https://github.com/bitcoin-core/secp256k1/blob/master/include/secp256k1.h#L83" target="_blank">struct</a> in Raku:</p>



<pre id="advent-code-2971eccd-4502-4494-92ca-4c9ac448cc22"></pre>



<p>Implementation bellow was buggy and crashes from run to run with <a rel="noreferrer noopener" href="https://gitlab.com/pheix/raku-bitcoin-core-secp256k1/-/jobs/1788624414#L104" target="_blank">segfaults</a>:</p>



<pre id="advent-code-7f6b2180-acc6-4bdf-a7a0-f1c8b4b8308a"></pre>



<p>But this one works perfect (just allocated <a rel="noreferrer noopener" href="https://stackoverflow.com/a/20737216" target="_blank">64 bytes</a> for <code>data</code> member):</p>



<pre id="advent-code-6dd4cf1d-5de6-4411-b17f-9b83d570038f"></pre>



<p>So any details are very welcome and any explanations are highly appreciated, let’s discuss it in comments.</p>



<h3 id="keccak-256">Keccak-256</h3>



<p>Keccak is a family of sponge functions — the <a rel="noreferrer noopener" href="https://en.wikipedia.org/wiki/Sponge_function" target="_blank">sponge function</a> takes an input of any length and produces an output of any desired length — developed by the <a rel="noreferrer noopener" href="https://keccak.team/" target="_blank">Keccak team</a> and was selected as the winner of the the <a rel="noreferrer noopener" href="https://en.wikipedia.org/wiki/SHA-3" target="_blank">SHA-3</a> National Institute of Standards and Technology (<a rel="noreferrer noopener" href="https://www.nist.gov/" target="_blank">NIST</a>) competition. When published, NIST adopted the Keccak algorithm in its entirety, but modified the padding message by one byte. These two variants will have different values for their outputs, but both are equally secure. SHA-3 is often used interchangeably to refer to SHA-3 and Keccak. Ethereum was finalized with Keccak before SHA-3.</p>



<p>We are actually unable to use SHA-3 from <code>Gcrypt</code> <a rel="noreferrer noopener" href="https://github.com/CurtTilmes/raku-libgcrypt/tree/master/lib/Gcrypt" target="_blank">module</a>, because it gives an absolutely <a rel="noreferrer noopener" href="https://medium.com/@ConsenSys/are-you-really-using-sha-3-or-old-code-c5df31ad2b0" target="_blank">different</a> hash.</p>



<p>And finally we have the third <a rel="noreferrer noopener" href="https://gitlab.com/pheix/raku-node-ethereum-keccak256-native" target="_blank">module</a> <code>Node::Ethereum::Keccak256::Native</code>. This module is inspired <a rel="noreferrer noopener" href="https://github.com/bduggan/p6-digest-sha1-native" target="_blank">by</a> <code>Digest::SHA1::Native</code> and also has some magic in pointers as we discussed above. C implementation was taken from <a rel="noreferrer noopener" href="https://github.com/firefly/wallet" target="_blank">Firefly</a> DIY hardware wallet project, by the way, there is <a rel="noreferrer noopener" href="https://github.com/firefly/wallet/blob/master/source/libs/ethers/src/keccak256.c" target="_blank">original</a> Keccak-256 from SHA-3 submission.</p>



<pre id="advent-code-fbd5aaca-1a27-41d5-af5a-2fe405ebd4b7"></pre>



<p>To be honest we can fetch <code>keccak-256</code> hashes from Ethereum node. But you should convert your message to hex before the request:</p>



<pre id="advent-code-30bdd2ac-38e7-4993-b8d8-1f8f0cd05c90"></pre>



<p>As you see <code>keccak-256</code> via <code>NativeCall</code> is <strong>~25x</strong> faster against <code>keccak-256</code> via RPC to local Ethereum node. I guess it could be <strong>x100</strong> or even more speed up against public nodes.</p>



<h2 id="run-the-prototype">Run the prototype</h2>



<p>Let’s go back to <a href="#signing-node-the-prototype">Signing node: the prototype</a> section and figure out what’s happening under the hood of the <code>eth_signTransaction</code> <a rel="noreferrer noopener" href="https://gitlab.com/pheix/net-ethereum-perl6/-/blob/d56be357823fa677b389310d277cf207e28cdbfb/lib/Net/Ethereum.rakumod#L377" target="_blank">method</a> from <code>Net::Ethereum</code> module:</p>



<ol><li><code>Net::Ethereum</code> is <a href="https://gitlab.com/pheix/net-ethereum-perl6/-/blob/d56be357823fa677b389310d277cf207e28cdbfb/lib/Net/Ethereum.rakumod#L386" target="_blank" rel="noreferrer noopener">creating</a> the transaction object with all fields in hex;</li><li><code>Net::Ethereum</code> is <a href="https://gitlab.com/pheix/net-ethereum-perl6/-/blob/d56be357823fa677b389310d277cf207e28cdbfb/lib/Net/Ethereum.rakumod#L396" target="_blank" rel="noreferrer noopener">packing</a> and <a href="https://gitlab.com/pheix/net-ethereum-perl6/-/blob/d56be357823fa677b389310d277cf207e28cdbfb/lib/Net/Ethereum.rakumod#L402" target="_blank" rel="noreferrer noopener">sending</a> the request to the signing node;</li><li>Then magic on signing node happens.</li></ol>



<p>And let’s do this once again locally in Raku — with full explanation what kind of magic Geth node hides while signing.</p>



<h3 id="retrieve-signature-from-geth-endpoint">Retrieve signature from Geth endpoint</h3>



<p>First let’s run <code>local-signer.raku</code> <a rel="noreferrer noopener" href="https://gitlab.com/pheix-research/talks/-/blob/main/advent/assets/2021/local-signer.raku" target="_blank">script</a> and save the signature from Geth to <code>ETHEREUM_SIGNATURE</code> env variable:</p>



<pre id="advent-code-d670a8ad-076d-4abc-8901-46342981e8bd"></pre>



<h3 id="calculate-signature-locally">Calculate signature locally</h3>



<p>Consider <code>local-signer.raku</code> <a rel="noreferrer noopener" href="https://gitlab.com/pheix-research/talks/-/blob/main/advent/assets/2021/local-signer.raku" target="_blank">script</a>: there are a few constants on the top, then trivial fetching logic with <code>Net::Ethereum</code> comes.</p>



<p>First, let’s remove Geth endpoint from <code>Net::Ethereum</code> object initialization, to be sure — we are fully local, and create <code>Node::Ethereum::RLP</code> object:</p>



<pre id="advent-code-a2b550b1-3407-4f0e-8fa9-47495fb6d52d"></pre>



<p>Then let’s add a few constants more and create the transaction object to be signed:</p>



<pre id="advent-code-bcc7bc09-1593-4fa6-9dcb-c245d988dcec"></pre>



<p>Now let’s convert transaction object to array of buffers <code>@raw</code> with <code>chainid</code> and 2 blanks in the end: <code>(nonce, gasprice, startgas, to, value, data, chainid, 0, 0)</code>, as it’s required at <a rel="noreferrer noopener" href="https://eips.ethereum.org/EIPS/eip-155" target="_blank">EIP-155</a>:</p>



<pre id="advent-code-6600985a-59ab-4ff9-b5ba-e5f9fe0eb781"></pre>



<p>Well, let’s get RLP of <code>@raw</code> and then get Keccak-256 hash from it:</p>



<pre id="advent-code-d3bc943d-f32d-45a7-a526-96fa602f506e"></pre>



<p>It’s time to sign the <code>$hash</code>, here we go:</p>



<pre id="advent-code-e135f287-beb1-4f1c-aa04-201ab02bd4e3"></pre>



<p><code>$serialized</code> is the <a rel="noreferrer noopener" href="https://docs.raku.org/type/Hash" target="_blank">Hash</a>, where the member <code>signature</code> is 64 bytes long and first 32 bytes <a rel="noreferrer noopener" href="https://crypto.stackexchange.com/a/50718" target="_blank">are</a> <code>R</code> value and others are <code>S</code> value. In some cases we have leading zero bytes (<code>0x00</code>) there, so we should sanitize the nulls with <code>skip_lead_nulls()</code> helper subroutine:</p>



<pre id="advent-code-df285098-c51e-4a82-aceb-a3f0a650ed94"></pre>



<p>Almost done, now let’s calculate Ethereum recovery parameter according the recovery bit from the serialized signature, see <a rel="noreferrer noopener" href="https://eips.ethereum.org/EIPS/eip-155" target="_blank">EIP-155</a> reference again:</p>



<pre id="advent-code-49f5e7e4-04fc-44e6-8438-b2375bb9543e"></pre>



<p>Just patch the <code>@raw</code>: remove some data required for Keccak-256 hashing (did you remember <code>chainid</code> and 2 zeros in the end?) and add <code>R</code>, <code>S</code> and recover parameter values:</p>



<pre id="advent-code-d69ec6a2-53dc-4a1d-b3a0-c31f2590e5e8"></pre>



<p>Yep! Let’s do the final steps: get RLP from updated <code>@raw</code> and validate the signature:</p>



<pre id="advent-code-e9abc8b9-44fc-4e51-bb4c-1c8bb964956d"></pre>



<p>Full source code: <a rel="noreferrer noopener" href="https://gitlab.com/pheix-research/talks/-/blob/main/advent/assets/2021/raku-signer.raku" target="_blank">raku-signer.raku</a>, try it out:</p>



<pre id="advent-code-f14994e8-ac33-4dab-a605-105e671ec5a1"></pre>



<p>Also you can find more interesting examples at this repository: <a href="https://gitlab.com/pheix-research/manual-ethereum-transaction-signer">https://gitlab.com/pheix-research/manual-ethereum-transaction-signer</a>.</p>



<h2 id="conclusion">Conclusion</h2>



<p>One of the main advantages of local signer node — the ability to inherit authentication and signing features from node software. If your request could be authenticated on signer node, you can easily add mocked/share accounts, sign and commit transactions with no any headache.</p>



<p>Obvious disadvantage — maintenance, configuration, update and health monitoring. There also is the economic reason: standalone node requires sufficient resources like memory and disk space. So, you should check out advanced VPS plan for this task. If you try to use own physical server it will impose additional financial and organizational costs.<br/></p>



<p>From this perspective dApp with self-signing options is the best solution. By the way, I should mention a few more valuable features. I guest the important one is the <strong>quick on-boarding</strong> — just register your free endpoint at one the external Ethereum providers (<a rel="noreferrer noopener" href="https://infura.io/" target="_blank">Infura</a>, <a rel="noreferrer noopener" href="https://www.alchemy.com/" target="_blank">Alchemy</a>, <a rel="noreferrer noopener" href="https://zmok.io/" target="_blank">Zmok</a> and others) and start the development of your dApp in Raku.<br/></p>



<p>The next — <strong>flexibility</strong> while the external Ethereum providers usage: JSON RPC API stacks ary varying from one provider to another. For example, <a rel="noreferrer noopener" href="https://zmok.io/" target="_blank">zmok.io</a> is the fastest one, but does not provide <code>web3_sha3</code> <a rel="noreferrer noopener" href="https://eth.wiki/json-rpc/API#web3_sha3" target="_blank">API call</a>. Now it’s not the problem as we have <code>Node::Ethereum::Keccak256::Native</code> in place at <code>Net::Ethereum</code>.<br/></p>



<p>Finally, let’s discuss the <strong>performance</strong>. We create a lot of additional HTTP/HTTPS requests while we are using the standalone node for signing. As it was demonstrated at <a href="#keccak-256">Keccak-256</a> section — just the migration to <code>Node::Ethereum::Keccak256::Native</code> can bring <strong>x25</strong> boost.</p>



<p>All sources considered in this article are available <a rel="noreferrer noopener" href="https://gitlab.com/pheix-research/talks/-/tree/main/advent/assets/2021" target="_blank">here</a>, Merry Christmas!</p>
	</div><!-- .entry-content -->

	<!-- .entry-footer -->

				
</article></div>
  </body>
</html>
