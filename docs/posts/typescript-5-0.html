<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/">Original</a>
    <h1>TypeScript 5.0</h1>
    
    <div id="readability-page-1" class="page"><div id="featured">

	<div>
                         <p>
            March 16th, 2023</p><!-- .entry-meta -->
        
<p>Today we’re excited to announce the release of TypeScript 5.0!</p>
<p>This release brings many new features, while aiming to make TypeScript smaller, simpler, and faster.
We’ve implemented the new decorators standard, added functionality to better support ESM projects in Node and bundlers, provided new ways for library authors to control generic inference, expanded our JSDoc functionality, simplified configuration, and made many other improvements.</p>
<p>If you’re not familiar with TypeScript yet, it’s a language that builds on JavaScript by adding syntax for types which can be used for type-checking.
Type-checking can help catch lots of common mistakes, from typos to logic errors.
Bringing types to JavaScript also allows us to build great tooling, since types can power features like code completions, go-to-definition, and refactorings in your favorite editor.
In fact, if you’ve used editors like Visual Studio or VS Code, TypeScript already provides the JavaScript experience there!
You can read up about the language at <a href="https://typescriptlang.org">https://typescriptlang.org</a>.</p>
<p>But if you’re already familiar with TypeScript, have no fear!
5.0 is not a disruptive release, and everything you know is still applicable.
While TypeScript 5.0 includes correctness changes and some deprecations for infrequently-used options, we believe most developers will have an upgrade experience similar to previous releases.</p>
<p>To get started using TypeScript 5.0, you can get it <a href="https://www.nuget.org/packages/Microsoft.TypeScript.MSBuild">through NuGet</a>, or use npm with the following command:</p>
<pre><code><span>npm install -D typescript</span>
</code></pre>
<p>You can also follow directions for using a newer version of TypeScript in <a href="https://code.visualstudio.com/docs/typescript/typescript-compiling#_using-the-workspace-version-of-typescript">Visual Studio Code</a>.</p>
<p>Here’s a quick list of what’s new in TypeScript 5.0!</p>
<ul>
<li><a href="#decorators">Decorators</a></li>
<li><a href="#const-type-parameters"><code>const</code> Type Parameters</a></li>
<li><a href="#supporting-multiple-configuration-files-in-extends">Supporting Multiple Configuration Files in <code>extends</code></a></li>
<li><a href="#all-enums-are-union-enums">All <code>enum</code>s Are Union <code>enum</code>s</a></li>
<li><a href="#moduleresolution-bundler"><code>--moduleResolution bundler</code></a></li>
<li><a href="#resolution-customization-flags">Resolution Customization Flags</a></li>
<li><a href="#verbatimmodulesyntax"><code>--verbatimModuleSyntax</code></a></li>
<li><a href="#support-for-export-type">Support for <code>export type *</code></a></li>
<li><a href="#satisfies-support-in-jsdoc"><code>@satisfies</code> Support in JSDoc</a></li>
<li><a href="#overload-support-in-jsdoc"><code>@overload</code> Support in JSDoc</a></li>
<li><a href="#passing-emit-specific-flags-under-build">Passing Emit-Specific Flags Under <code>--build</code></a></li>
<li><a href="#case-insensitive-import-sorting-in-editors">Case-Insensitive Import Sorting in Editors</a></li>
<li><a href="#exhaustive-switch-case-completions">Exhaustive <code>switch</code>/<code>case</code> Completions</a></li>
<li><a href="#speed-memory-and-package-size-optimizations">Speed, Memory, and Package Size Optimizations</a></li>
<li><a href="#breaking-changes-and-deprecations">Breaking Changes and Deprecations</a></li>
<li><a href="#whats-next">What’s Next?</a></li>
</ul>
<h2 id="whats-new-since-the-beta-and-rc"><a name="beta-delta"></a> What’s New Since the Beta and RC?</h2>
<p>TypeScript 5.0 has several notable changes <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0-beta/">since our beta release</a>.</p>
<p>One new difference since TypeScript 5.0 Beta is that TypeScript permits <a href="#decorators">decorators</a> to be placed before or after <code>export</code> and <code>export default</code>.
This change reflects discussions and consensus within TC39, the standards body for ECMAScript/JavaScript.</p>
<p>Another is that <a href="#moduleresolution-bundler">the new <code>bundler</code> module resolution option</a> can now only be used when the <code>--module</code> option is set to <code>esnext</code>.
This was done to ensure that <code>import</code> statements written in input files won’t be transformed to <code>require</code> calls before the bundler resolves them, whether or not the bundler or loader respects TypeScript’s <code>module</code> option.
We’ve also provided some context in these release notes recommending most library authors stick to <code>node16</code> or <code>nodenext</code>.</p>
<p>While TypeScript 5.0 Beta shipped with this functionality, we did not document our work for supporting <a href="#case-insensitive-import-sorting-in-editors">case-insensitive import sorting in editor scenarios</a>.
This is in part because the UX for customization is still in discussion, but by default, TypeScript should now work better with the rest of your tooling.</p>
<p><a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0-rc/">Since our RC</a>, our most notable change is that TypeScript 5.0 now specifies a minimum Node.js version of <code>12.20</code> in our <code>package.json</code>.
We’ve also published <a href="https://devblogs.microsoft.com/typescript/typescripts-migration-to-modules/">a write-up about TypeScript 5.0’s migration to modules</a>, and linked to it.</p>
<p>Since TypeScript 5.0 Beta and RC were announced, the specific numbers for <a href="#speed-memory-and-package-size-optimizations">speed benchmarks and package size deltas</a> have also been adjusted, though noise has been a factor across runs.
The names of some benchmarks have also been adjusted for clarity, and package size improvements have been moved into a separate chart.</p>
<h2 id="decorators">Decorators</h2>
<p>Decorators are an upcoming ECMAScript feature that allow us to customize classes and their members in a reusable way.</p>
<p>Let’s consider the following code:</p>
<pre><code><span>class</span><span> </span><span>Person</span><span> {</span>
<span>    </span><span>name</span><span>: </span><span>string</span><span>;</span>
<span>    </span><span>constructor</span><span>(</span><span>name</span><span>: </span><span>string</span><span>) {</span>
<span>        </span><span>this</span><span>.</span><span>name</span><span> = </span><span>name</span><span>;</span>
<span>    }</span>

<span>    </span><span>greet</span><span>() {</span>
<span>        </span><span>console</span><span>.</span><span>log</span><span>(</span><span>`Hello, my name is </span><span>${</span><span>this</span><span>.</span><span>name</span><span>}</span><span>.`</span><span>);</span>
<span>    }</span>
<span>}</span>

<span>const</span><span> </span><span>p</span><span> = </span><span>new</span><span> </span><span>Person</span><span>(</span><span>&#34;Ron&#34;</span><span>);</span>
<span>p</span><span>.</span><span>greet</span><span>();</span>
</code></pre>
<p><code>greet</code> is pretty simple here, but let’s imagine it’s something way more complicated – maybe it does some async logic, it’s recursive, it has side effects, etc.
Regardless of what kind of ball-of-mud you’re imagining, let’s say you throw in some <code>console.log</code> calls to help debug <code>greet</code>.</p>
<pre><code><span>class</span><span> </span><span>Person</span><span> {</span>
<span>    </span><span>name</span><span>: </span><span>string</span><span>;</span>
<span>    </span><span>constructor</span><span>(</span><span>name</span><span>: </span><span>string</span><span>) {</span>
<span>        </span><span>this</span><span>.</span><span>name</span><span> = </span><span>name</span><span>;</span>
<span>    }</span>

<span>    </span><span>greet</span><span>() {</span>
<span>        </span><span>console</span><span>.</span><span>log</span><span>(</span><span>&#34;LOG: Entering method.&#34;</span><span>);</span>

<span>        </span><span>console</span><span>.</span><span>log</span><span>(</span><span>`Hello, my name is </span><span>${</span><span>this</span><span>.</span><span>name</span><span>}</span><span>.`</span><span>);</span>

<span>        </span><span>console</span><span>.</span><span>log</span><span>(</span><span>&#34;LOG: Exiting method.&#34;</span><span>)</span>
<span>    }</span>
<span>}</span>
</code></pre>
<p>This pattern is fairly common.
It sure would be nice if there was a way we could do this for every method!</p>
<p>This is where decorators come in.
We can write a function called <code>loggedMethod</code> that looks like the following:</p>
<pre><code><span>function</span><span> </span><span>loggedMethod</span><span>(</span><span>originalMethod</span><span>: </span><span>any</span><span>, </span><span>_context</span><span>: </span><span>any</span><span>) {</span>

<span>    </span><span>function</span><span> </span><span>replacementMethod</span><span>(</span><span>this</span><span>: </span><span>any</span><span>, ...</span><span>args</span><span>: </span><span>any</span><span>[]) {</span>
<span>        </span><span>console</span><span>.</span><span>log</span><span>(</span><span>&#34;LOG: Entering method.&#34;</span><span>)</span>
<span>        </span><span>const</span><span> </span><span>result</span><span> = </span><span>originalMethod</span><span>.</span><span>call</span><span>(</span><span>this</span><span>, ...</span><span>args</span><span>);</span>
<span>        </span><span>console</span><span>.</span><span>log</span><span>(</span><span>&#34;LOG: Exiting method.&#34;</span><span>)</span>
<span>        </span><span>return</span><span> </span><span>result</span><span>;</span>
<span>    }</span>

<span>    </span><span>return</span><span> </span><span>replacementMethod</span><span>;</span>
<span>}</span>
</code></pre>
<p>&#34;What’s the deal with all of these <code>any</code>s?
What is this, <code>any</code>Script!?&#34;</p>
<p>Just be patient – we’re keeping things simple for now so that we can focus on what this function is doing.
Notice that <code>loggedMethod</code> takes the original method (<code>originalMethod</code>) and returns a function that</p>
<ol>
<li>logs an &#34;Entering…&#34; message</li>
<li>passes along <code>this</code> and all of its arguments to the original method</li>
<li>logs an &#34;Exiting…&#34; message, and</li>
<li>returns whatever the original method returned.</li>
</ol>
<p>Now we can use <code>loggedMethod</code> to <em>decorate</em> the method <code>greet</code>:</p>
<pre><code><span>class</span><span> </span><span>Person</span><span> {</span>
<span>    </span><span>name</span><span>: </span><span>string</span><span>;</span>
<span>    </span><span>constructor</span><span>(</span><span>name</span><span>: </span><span>string</span><span>) {</span>
<span>        </span><span>this</span><span>.</span><span>name</span><span> = </span><span>name</span><span>;</span>
<span>    }</span>

<span>    @</span><span>loggedMethod</span>
<span>    </span><span>greet</span><span>() {</span>
<span>        </span><span>console</span><span>.</span><span>log</span><span>(</span><span>`Hello, my name is </span><span>${</span><span>this</span><span>.</span><span>name</span><span>}</span><span>.`</span><span>);</span>
<span>    }</span>
<span>}</span>

<span>const</span><span> </span><span>p</span><span> = </span><span>new</span><span> </span><span>Person</span><span>(</span><span>&#34;Ron&#34;</span><span>);</span>
<span>p</span><span>.</span><span>greet</span><span>();</span>

<span>// Output:</span>
<span>//</span>
<span>//   LOG: Entering method.</span>
<span>//   Hello, my name is Ron.</span>
<span>//   LOG: Exiting method.</span>
</code></pre>
<p>We just used <code>loggedMethod</code> as a decorator above <code>greet</code> – and notice that we wrote it as <code>@loggedMethod</code>.
When we did that, it got called with the method <em>target</em> and a <em>context object</em>.
Because <code>loggedMethod</code> returned a new function, that function replaced the original definition of <code>greet</code>.</p>
<p>We didn’t mention it yet, but <code>loggedMethod</code> was defined with a second parameter.
It’s called a &#34;context object&#34;, and it has some useful information about how the decorated method was declared – like whether it was a <code>#private</code> member, or <code>static</code>, or what the name of the method was.
Let’s rewrite <code>loggedMethod</code> to take advantage of that and print out the name of the method that was decorated.</p>
<pre><code><span>function</span><span> </span><span>loggedMethod</span><span>(</span><span>originalMethod</span><span>: </span><span>any</span><span>, </span><span>context</span><span>: </span><span>ClassMethodDecoratorContext</span><span>) {</span>
<span>    </span><span>const</span><span> </span><span>methodName</span><span> = </span><span>String</span><span>(</span><span>context</span><span>.</span><span>name</span><span>);</span>

<span>    </span><span>function</span><span> </span><span>replacementMethod</span><span>(</span><span>this</span><span>: </span><span>any</span><span>, ...</span><span>args</span><span>: </span><span>any</span><span>[]) {</span>
<span>        </span><span>console</span><span>.</span><span>log</span><span>(</span><span>`LOG: Entering method &#39;</span><span>${</span><span>methodName</span><span>}</span><span>&#39;.`</span><span>)</span>
<span>        </span><span>const</span><span> </span><span>result</span><span> = </span><span>originalMethod</span><span>.</span><span>call</span><span>(</span><span>this</span><span>, ...</span><span>args</span><span>);</span>
<span>        </span><span>console</span><span>.</span><span>log</span><span>(</span><span>`LOG: Exiting method &#39;</span><span>${</span><span>methodName</span><span>}</span><span>&#39;.`</span><span>)</span>
<span>        </span><span>return</span><span> </span><span>result</span><span>;</span>
<span>    }</span>

<span>    </span><span>return</span><span> </span><span>replacementMethod</span><span>;</span>
<span>}</span>
</code></pre>
<p>We’re now using the context parameter – and that it’s the first thing in <code>loggedMethod</code> that has a type stricter than <code>any</code> and <code>any[]</code>.
TypeScript provides a type called <code>ClassMethodDecoratorContext</code> that models the context object that method decorators take.</p>
<p>Apart from metadata, the context object for methods also has a useful function called <code>addInitializer</code>.
It’s a way to hook into the beginning of the constructor (or the initialization of the class itself if we’re working with <code>static</code>s).</p>
<p>As an example – in JavaScript, it’s common to write something like the following pattern:</p>
<pre><code><span>class</span><span> </span><span>Person</span><span> {</span>
<span>    </span><span>name</span><span>: </span><span>string</span><span>;</span>
<span>    </span><span>constructor</span><span>(</span><span>name</span><span>: </span><span>string</span><span>) {</span>
<span>        </span><span>this</span><span>.</span><span>name</span><span> = </span><span>name</span><span>;</span>

<span>        </span><span>this</span><span>.</span><span>greet</span><span> = </span><span>this</span><span>.</span><span>greet</span><span>.</span><span>bind</span><span>(</span><span>this</span><span>);</span>
<span>    }</span>

<span>    </span><span>greet</span><span>() {</span>
<span>        </span><span>console</span><span>.</span><span>log</span><span>(</span><span>`Hello, my name is </span><span>${</span><span>this</span><span>.</span><span>name</span><span>}</span><span>.`</span><span>);</span>
<span>    }</span>
<span>}</span>
</code></pre>
<p>Alternatively, <code>greet</code> might be declared as a property initialized to an arrow function.</p>
<pre><code><span>class</span><span> </span><span>Person</span><span> {</span>
<span>    </span><span>name</span><span>: </span><span>string</span><span>;</span>
<span>    </span><span>constructor</span><span>(</span><span>name</span><span>: </span><span>string</span><span>) {</span>
<span>        </span><span>this</span><span>.</span><span>name</span><span> = </span><span>name</span><span>;</span>
<span>    }</span>

<span>    </span><span>greet</span><span> = () </span><span>=&gt;</span><span> {</span>
<span>        </span><span>console</span><span>.</span><span>log</span><span>(</span><span>`Hello, my name is </span><span>${</span><span>this</span><span>.</span><span>name</span><span>}</span><span>.`</span><span>);</span>
<span>    };</span>
<span>}</span>
</code></pre>
<p>This code is written to ensure that <code>this</code> isn’t re-bound if <code>greet</code> is called as a stand-alone function or passed as a callback.</p>
<pre><code><span>const</span><span> </span><span>greet</span><span> = </span><span>new</span><span> </span><span>Person</span><span>(</span><span>&#34;Ron&#34;</span><span>).</span><span>greet</span><span>;</span>

<span>// We don&#39;t want this to fail!</span>
<span>greet</span><span>();</span>
</code></pre>
<p>We can write a decorator that uses <code>addInitializer</code> to call <code>bind</code> in the constructor for us.</p>
<pre><code><span>function</span><span> </span><span>bound</span><span>(</span><span>originalMethod</span><span>: </span><span>any</span><span>, </span><span>context</span><span>: </span><span>ClassMethodDecoratorContext</span><span>) {</span>
<span>    </span><span>const</span><span> </span><span>methodName</span><span> = </span><span>context</span><span>.</span><span>name</span><span>;</span>
<span>    </span><span>if</span><span> (</span><span>context</span><span>.</span><span>private</span><span>) {</span>
<span>        </span><span>throw</span><span> </span><span>new</span><span> </span><span>Error</span><span>(</span><span>`&#39;bound&#39; cannot decorate private properties like </span><span>${</span><span>methodName</span><span> </span><span>as</span><span> </span><span>string</span><span>}</span><span>.`</span><span>);</span>
<span>    }</span>
<span>    </span><span>context</span><span>.</span><span>addInitializer</span><span>(</span><span>function</span><span> () {</span>
<span>        </span><span>this</span><span>[</span><span>methodName</span><span>] = </span><span>this</span><span>[</span><span>methodName</span><span>].</span><span>bind</span><span>(</span><span>this</span><span>);</span>
<span>    });</span>
<span>}</span>
</code></pre>
<p><code>bound</code> isn’t returning anything – so when it decorates a method, it leaves the original alone.
Instead, it will add logic before any other fields are initialized.</p>
<pre><code><span>class</span><span> </span><span>Person</span><span> {</span>
<span>    </span><span>name</span><span>: </span><span>string</span><span>;</span>
<span>    </span><span>constructor</span><span>(</span><span>name</span><span>: </span><span>string</span><span>) {</span>
<span>        </span><span>this</span><span>.</span><span>name</span><span> = </span><span>name</span><span>;</span>
<span>    }</span>

<span>    @</span><span>bound</span>
<span>    @</span><span>loggedMethod</span>
<span>    </span><span>greet</span><span>() {</span>
<span>        </span><span>console</span><span>.</span><span>log</span><span>(</span><span>`Hello, my name is </span><span>${</span><span>this</span><span>.</span><span>name</span><span>}</span><span>.`</span><span>);</span>
<span>    }</span>
<span>}</span>

<span>const</span><span> </span><span>p</span><span> = </span><span>new</span><span> </span><span>Person</span><span>(</span><span>&#34;Ron&#34;</span><span>);</span>
<span>const</span><span> </span><span>greet</span><span> = </span><span>p</span><span>.</span><span>greet</span><span>;</span>

<span>// Works!</span>
<span>greet</span><span>();</span>
</code></pre>
<p>Notice that we stacked two decorators – <code>@bound</code> and <code>@loggedMethod</code>.
These decorations run in &#34;reverse order&#34;.
That is, <code>@loggedMethod</code> decorates the original method <code>greet</code>, and <code>@bound</code> decorates the result of <code>@loggedMethod</code>.
In this example, it doesn’t matter – but it could if your decorators have side effects or expect a certain order.</p>
<p>Also worth noting: if you’d prefer stylistically, you can put these decorators on the same line.</p>
<pre><code><span>    @</span><span>bound</span><span> @</span><span>loggedMethod</span><span> </span><span>greet</span><span>() {</span>
<span>        </span><span>console</span><span>.</span><span>log</span><span>(</span><span>`Hello, my name is </span><span>${</span><span>this</span><span>.</span><span>name</span><span>}</span><span>.`</span><span>);</span>
<span>    }</span>
</code></pre>
<p>Something that might not be obvious is that we can even make functions that <em>return</em> decorator functions.
That makes it possible to customize the final decorator just a little.
If we wanted, we could have made <code>loggedMethod</code> return a decorator and customize how it logs its messages.</p>
<pre><code><span>function</span><span> </span><span>loggedMethod</span><span>(</span><span>headMessage</span><span> = </span><span>&#34;LOG:&#34;</span><span>) {</span>
<span>    </span><span>return</span><span> </span><span>function</span><span> </span><span>actualDecorator</span><span>(</span><span>originalMethod</span><span>: </span><span>any</span><span>, </span><span>context</span><span>: </span><span>ClassMethodDecoratorContext</span><span>) {</span>
<span>        </span><span>const</span><span> </span><span>methodName</span><span> = </span><span>String</span><span>(</span><span>context</span><span>.</span><span>name</span><span>);</span>

<span>        </span><span>function</span><span> </span><span>replacementMethod</span><span>(</span><span>this</span><span>: </span><span>any</span><span>, ...</span><span>args</span><span>: </span><span>any</span><span>[]) {</span>
<span>            </span><span>console</span><span>.</span><span>log</span><span>(</span><span>`</span><span>${</span><span>headMessage</span><span>}</span><span> Entering method &#39;</span><span>${</span><span>methodName</span><span>}</span><span>&#39;.`</span><span>)</span>
<span>            </span><span>const</span><span> </span><span>result</span><span> = </span><span>originalMethod</span><span>.</span><span>call</span><span>(</span><span>this</span><span>, ...</span><span>args</span><span>);</span>
<span>            </span><span>console</span><span>.</span><span>log</span><span>(</span><span>`</span><span>${</span><span>headMessage</span><span>}</span><span> Exiting method &#39;</span><span>${</span><span>methodName</span><span>}</span><span>&#39;.`</span><span>)</span>
<span>            </span><span>return</span><span> </span><span>result</span><span>;</span>
<span>        }</span>

<span>        </span><span>return</span><span> </span><span>replacementMethod</span><span>;</span>
<span>    }</span>
<span>}</span>
</code></pre>
<p>If we did that, we’d have to call <code>loggedMethod</code> before using it as a decorator.
We could then pass in any string as the prefix for messages that get logged to the console.</p>
<pre><code><span>class</span><span> </span><span>Person</span><span> {</span>
<span>    </span><span>name</span><span>: </span><span>string</span><span>;</span>
<span>    </span><span>constructor</span><span>(</span><span>name</span><span>: </span><span>string</span><span>) {</span>
<span>        </span><span>this</span><span>.</span><span>name</span><span> = </span><span>name</span><span>;</span>
<span>    }</span>

<span>    @</span><span>loggedMethod</span><span>(</span><span>&#34;⚠️&#34;</span><span>)</span>
<span>    </span><span>greet</span><span>() {</span>
<span>        </span><span>console</span><span>.</span><span>log</span><span>(</span><span>`Hello, my name is </span><span>${</span><span>this</span><span>.</span><span>name</span><span>}</span><span>.`</span><span>);</span>
<span>    }</span>
<span>}</span>

<span>const</span><span> </span><span>p</span><span> = </span><span>new</span><span> </span><span>Person</span><span>(</span><span>&#34;Ron&#34;</span><span>);</span>
<span>p</span><span>.</span><span>greet</span><span>();</span>

<span>// Output:</span>
<span>//</span>
<span>//   ⚠️ Entering method &#39;greet&#39;.</span>
<span>//   Hello, my name is Ron.</span>
<span>//   ⚠️ Exiting method &#39;greet&#39;.</span>
</code></pre>
<p>Decorators can be used on more than just methods!
They can be used on properties/fields, getters, setters, and auto-accessors.
Even classes themselves can be decorated for things like subclassing and registration.</p>
<p>To learn more about decorators in-depth, you can read up on <a href="https://2ality.com/2022/10/javascript-decorators.html">Axel Rauschmayer’s extensive summary</a>.</p>
<p>For more information about the changes involved, you can <a href="https://github.com/microsoft/TypeScript/pull/50820">view the original pull request</a>.</p>
<h3 id="differences-with-experimental-legacy-decorators">Differences with Experimental Legacy Decorators</h3>
<p>If you’ve been using TypeScript for a while, you might be aware of the fact that it’s had support for &#34;experimental&#34; decorators for years.
While these experimental decorators have been incredibly useful, they modeled a much older version of the decorators proposal, and always required an opt-in compiler flag called <code>--experimentalDecorators</code>.
Any attempt to use decorators in TypeScript without this flag used to prompt an error message.</p>
<p><code>--experimentalDecorators</code> will continue to exist for the foreseeable future;
however, without the flag, decorators will now be valid syntax for all new code.
Outside of <code>--experimentalDecorators</code>, they will be type-checked and emitted differently.
The type-checking rules and emit are sufficiently different that while decorators <em>can</em> be written to support both the old and new decorators behavior, any existing decorator functions are not likely to do so.</p>
<p>This new decorators proposal is not compatible with <code>--emitDecoratorMetadata</code>, and it does not allow decorating parameters.
Future ECMAScript proposals may be able to help bridge that gap.</p>
<p>On a final note: in addition to allowing decorators to be placed before the <code>export</code> keyword, the proposal for decorators now provides the option of placing decorators after <code>export</code> or <code>export default</code>.
The only exception is that mixing the two styles is not allowed.</p>
<pre><code><span>// ✅ allowed</span>
<span>@</span><span>register</span><span> </span><span>export</span><span> </span><span>default</span><span> </span><span>class</span><span> </span><span>Foo</span><span> {</span>
<span>    </span><span>// ...</span>
<span>}</span>

<span>// ✅ also allowed</span>
<span>export</span><span> </span><span>default</span><span> @</span><span>register</span><span> </span><span>class</span><span> </span><span>Bar</span><span> {</span>
<span>    </span><span>// ...</span>
<span>}</span>

<span>// ❌ error - before *and* after is not allowed</span>
<span>@</span><span>before</span><span> </span><span>export</span><span> @</span><span>after</span><span> </span><span>class</span><span> </span><span>Bar</span><span> {</span>
<span>    </span><span>// ...</span>
<span>}</span>
</code></pre>
<h3 id="writing-well-typed-decorators">Writing Well-Typed Decorators</h3>
<p>The <code>loggedMethod</code> and <code>bound</code> decorator examples above are intentionally simple and omit lots of details about types.</p>
<p>Typing decorators can be fairly complex.
For example, a well-typed version of <code>loggedMethod</code> from above might look something like this:</p>
<pre><code><span>function</span><span> </span><span>loggedMethod</span><span>&lt;</span><span>This</span><span>, </span><span>Args</span><span> </span><span>extends</span><span> </span><span>any</span><span>[], </span><span>Return</span><span>&gt;(</span>
<span>    </span><span>target</span><span>: (</span><span>this</span><span>: </span><span>This</span><span>, ...</span><span>args</span><span>: </span><span>Args</span><span>) </span><span>=&gt;</span><span> </span><span>Return</span><span>,</span>
<span>    </span><span>context</span><span>: </span><span>ClassMethodDecoratorContext</span><span>&lt;</span><span>This</span><span>, (</span><span>this</span><span>: </span><span>This</span><span>, ...</span><span>args</span><span>: </span><span>Args</span><span>) </span><span>=&gt;</span><span> </span><span>Return</span><span>&gt;</span>
<span>) {</span>
<span>    </span><span>const</span><span> </span><span>methodName</span><span> = </span><span>String</span><span>(</span><span>context</span><span>.</span><span>name</span><span>);</span>

<span>    </span><span>function</span><span> </span><span>replacementMethod</span><span>(</span><span>this</span><span>: </span><span>This</span><span>, ...</span><span>args</span><span>: </span><span>Args</span><span>): </span><span>Return</span><span> {</span>
<span>        </span><span>console</span><span>.</span><span>log</span><span>(</span><span>`LOG: Entering method &#39;</span><span>${</span><span>methodName</span><span>}</span><span>&#39;.`</span><span>)</span>
<span>        </span><span>const</span><span> </span><span>result</span><span> = </span><span>target</span><span>.</span><span>call</span><span>(</span><span>this</span><span>, ...</span><span>args</span><span>);</span>
<span>        </span><span>console</span><span>.</span><span>log</span><span>(</span><span>`LOG: Exiting method &#39;</span><span>${</span><span>methodName</span><span>}</span><span>&#39;.`</span><span>)</span>
<span>        </span><span>return</span><span> </span><span>result</span><span>;</span>
<span>    }</span>

<span>    </span><span>return</span><span> </span><span>replacementMethod</span><span>;</span>
<span>}</span>
</code></pre>
<p>We had to separately model out the type of <code>this</code>, the parameters, and the return type of the original method, using the type parameters <code>This</code>, <code>Args</code>, and <code>Return</code>.</p>
<p>Exactly how complex your decorators functions are defined depends on what you want to guarantee.
Just keep in mind, your decorators will be used more than they’re written, so a well-typed version will usually be preferable – but there’s clearly a trade-off with readability, so try to keep things simple.</p>
<p>More documentation on writing decorators will be available in the future – but <a href="https://2ality.com/2022/10/javascript-decorators.html">this post</a> should have a good amount of detail for the mechanics of decorators.</p>
<h2 id="const-type-parameters"><code>const</code> Type Parameters</h2>
<p>When inferring the type of an object, TypeScript will usually choose a type that’s meant to be general.
For example, in this case, the inferred type of <code>names</code> is <code>string[]</code>:</p>
<pre><code><span>type</span><span> </span><span>HasNames</span><span> = { </span><span>readonly</span><span> </span><span>names</span><span>: </span><span>string</span><span>[] };</span>
<span>function</span><span> </span><span>getNamesExactly</span><span>&lt;</span><span>T</span><span> </span><span>extends</span><span> </span><span>HasNames</span><span>&gt;(</span><span>arg</span><span>: </span><span>T</span><span>): </span><span>T</span><span>[</span><span>&#34;names&#34;</span><span>] {</span>
<span>    </span><span>return</span><span> </span><span>arg</span><span>.</span><span>names</span><span>;</span>
<span>}</span>

<span>// Inferred type: string[]</span>
<span>const</span><span> </span><span>names</span><span> = </span><span>getNamesExactly</span><span>({ </span><span>names:</span><span> [</span><span>&#34;Alice&#34;</span><span>, </span><span>&#34;Bob&#34;</span><span>, </span><span>&#34;Eve&#34;</span><span>]});</span>
</code></pre>
<p>Usually the intent of this is to enable mutation down the line.</p>
<p>However, depending on what exactly <code>getNamesExactly</code> does and how it’s intended to be used, it can often be the case that a more-specific type is desired.</p>
<p>Up until now, API authors have typically had to recommend adding <code>as const</code> in certain places to achieve the desired inference:</p>
<pre><code><span>// The type we wanted:</span>
<span>//    readonly [&#34;Alice&#34;, &#34;Bob&#34;, &#34;Eve&#34;]</span>
<span>// The type we got:</span>
<span>//    string[]</span>
<span>const</span><span> </span><span>names1</span><span> = </span><span>getNamesExactly</span><span>({ </span><span>names:</span><span> [</span><span>&#34;Alice&#34;</span><span>, </span><span>&#34;Bob&#34;</span><span>, </span><span>&#34;Eve&#34;</span><span>]});</span>

<span>// Correctly gets what we wanted:</span>
<span>//    readonly [&#34;Alice&#34;, &#34;Bob&#34;, &#34;Eve&#34;]</span>
<span>const</span><span> </span><span>names2</span><span> = </span><span>getNamesExactly</span><span>({ </span><span>names:</span><span> [</span><span>&#34;Alice&#34;</span><span>, </span><span>&#34;Bob&#34;</span><span>, </span><span>&#34;Eve&#34;</span><span>]} </span><span>as</span><span> </span><span>const</span><span>);</span>
</code></pre>
<p>This can be cumbersome and easy to forget.
In TypeScript 5.0, you can now add a <code>const</code> modifier to a type parameter declaration to cause <code>const</code>-like inference to be the default:</p>
<pre><code><span>type</span><span> </span><span>HasNames</span><span> = { </span><span>names</span><span>: </span><span>readonly</span><span> </span><span>string</span><span>[] };</span>
<span>function</span><span> </span><span>getNamesExactly</span><span>&lt;</span><span>const</span><span> </span><span>T</span><span> </span><span>extends</span><span> </span><span>HasNames</span><span>&gt;(</span><span>arg</span><span>: </span><span>T</span><span>): </span><span>T</span><span>[</span><span>&#34;names&#34;</span><span>] {</span>
<span>//                       ^^^^^</span>
<span>    </span><span>return</span><span> </span><span>arg</span><span>.</span><span>names</span><span>;</span>
<span>}</span>

<span>// Inferred type: readonly [&#34;Alice&#34;, &#34;Bob&#34;, &#34;Eve&#34;]</span>
<span>// Note: Didn&#39;t need to write &#39;as const&#39; here</span>
<span>const</span><span> </span><span>names</span><span> = </span><span>getNamesExactly</span><span>({ </span><span>names:</span><span> [</span><span>&#34;Alice&#34;</span><span>, </span><span>&#34;Bob&#34;</span><span>, </span><span>&#34;Eve&#34;</span><span>] });</span>
</code></pre>
<p>Note that the <code>const</code> modifier doesn’t <em>reject</em> mutable values, and doesn’t require immutable constraints.
Using a mutable type constraint might give surprising results.
For example:</p>
<pre><code><span>declare</span><span> </span><span>function</span><span> </span><span>fnBad</span><span>&lt;</span><span>const</span><span> </span><span>T</span><span> </span><span>extends</span><span> </span><span>string</span><span>[]&gt;(</span><span>args</span><span>: </span><span>T</span><span>): </span><span>void</span><span>;</span>

<span>// &#39;T&#39; is still &#39;string[]&#39; since &#39;readonly [&#34;a&#34;, &#34;b&#34;, &#34;c&#34;]&#39; is not assignable to &#39;string[]&#39;</span>
<span>fnBad</span><span>([</span><span>&#34;a&#34;</span><span>, </span><span>&#34;b&#34;</span><span> ,</span><span>&#34;c&#34;</span><span>]);</span>
</code></pre>
<p>Here, the inferred candidate for <code>T</code> is <code>readonly [&#34;a&#34;, &#34;b&#34;, &#34;c&#34;]</code>, and a <code>readonly</code> array can’t be used where a mutable one is needed.
In this case, inference falls back to the constraint, the array is treated as <code>string[]</code>, and the call still proceeds successfully.</p>
<p>A better definition of this function should use <code>readonly string[]</code>:</p>
<pre><code><span>declare</span><span> </span><span>function</span><span> </span><span>fnGood</span><span>&lt;</span><span>const</span><span> </span><span>T</span><span> </span><span>extends</span><span> </span><span>readonly</span><span> </span><span>string</span><span>[]&gt;(</span><span>args</span><span>: </span><span>T</span><span>): </span><span>void</span><span>;</span>

<span>// T is readonly [&#34;a&#34;, &#34;b&#34;, &#34;c&#34;]</span>
<span>fnGood</span><span>([</span><span>&#34;a&#34;</span><span>, </span><span>&#34;b&#34;</span><span> ,</span><span>&#34;c&#34;</span><span>]);</span>
</code></pre>
<p>Similarly, remember to keep in mind that the <code>const</code> modifier only affects inference of object, array and primitive expressions that were written within the call, so arguments which wouldn’t (or couldn’t) be modified with <code>as const</code> won’t see any change in behavior:</p>
<pre><code><span>declare</span><span> </span><span>function</span><span> </span><span>fnGood</span><span>&lt;</span><span>const</span><span> </span><span>T</span><span> </span><span>extends</span><span> </span><span>readonly</span><span> </span><span>string</span><span>[]&gt;(</span><span>args</span><span>: </span><span>T</span><span>): </span><span>void</span><span>;</span>
<span>const</span><span> </span><span>arr</span><span> = [</span><span>&#34;a&#34;</span><span>, </span><span>&#34;b&#34;</span><span> ,</span><span>&#34;c&#34;</span><span>];</span>

<span>// &#39;T&#39; is still &#39;string[]&#39;-- the &#39;const&#39; modifier has no effect here</span>
<span>fnGood</span><span>(</span><span>arr</span><span>);</span>
</code></pre>
<p><a href="https://github.com/microsoft/TypeScript/pull/51865">See the pull request</a> and the (<a href="https://github.com/microsoft/TypeScript/issues/30680">first</a> and <a href="https://github.com/microsoft/TypeScript/issues/41114">second</a>) motivating issues for more details.</p>
<h2 id="supporting-multiple-configuration-files-in-extends">Supporting Multiple Configuration Files in <code>extends</code></h2>
<p>When managing multiple projects, it can be helpful to have a &#34;base&#34; configuration file that other <code>tsconfig.json</code> files can extend from.
That’s why TypeScript supports an <code>extends</code> field for copying over fields from <code>compilerOptions</code>.</p>
<pre><code><span>// packages/front-end/src/tsconfig.json</span>
<span>{</span>
<span>    </span><span>&#34;extends&#34;</span><span>: </span><span>&#34;../../../tsconfig.base.json&#34;</span><span>,</span>
<span>    </span><span>&#34;compilerOptions&#34;</span><span>: {</span>
<span>        </span><span>&#34;outDir&#34;</span><span>: </span><span>&#34;../lib&#34;</span><span>,</span>
<span>        </span><span>// ...</span>
<span>    }</span>
<span>}</span>
</code></pre>
<p>However, there are scenarios where you might want to extend from multiple configuration files.
For example, imagine using <a href="https://github.com/tsconfig/bases">a TypeScript base configuration file shipped to npm</a>.
If you want all your projects to also use the options from the <code>@tsconfig/strictest</code> package on npm, then there’s a simple solution: have <code>tsconfig.base.json</code> extend from <code>@tsconfig/strictest</code>:</p>
<pre><code><span>// tsconfig.base.json</span>
<span>{</span>
<span>    </span><span>&#34;extends&#34;</span><span>: </span><span>&#34;@tsconfig/strictest/tsconfig.json&#34;</span><span>,</span>
<span>    </span><span>&#34;compilerOptions&#34;</span><span>: {</span>
<span>        </span><span>// ...</span>
<span>    }</span>
<span>}</span>
</code></pre>
<p>This works to a point.
If you have any projects that <em>don’t</em> want to use <code>@tsconfig/strictest</code>, they have to either manually disable the options, or create a separate version of <code>tsconfig.base.json</code> that <em>doesn’t</em> extend from <code>@tsconfig/strictest</code>.</p>
<p>To give some more flexibility here, Typescript 5.0 now allows the <code>extends</code> field to take multiple entries.
For example, in this configuration file:</p>
<pre><code><span>{</span>
<span>    </span><span>&#34;extends&#34;</span><span>: [</span><span>&#34;a&#34;</span><span>, </span><span>&#34;b&#34;</span><span>, </span><span>&#34;c&#34;</span><span>],</span>
<span>    </span><span>&#34;compilerOptions&#34;</span><span>: {</span>
<span>        </span><span>// ...</span>
<span>    }</span>
<span>}</span>
</code></pre>
<p>Writing this is kind of like extending <code>c</code> directly, where <code>c</code> extends <code>b</code>, and <code>b</code> extends <code>a</code>.
If any fields &#34;conflict&#34;, the latter entry wins.</p>
<p>So in the following example, both <code>strictNullChecks</code> and <code>noImplicitAny</code> are enabled in the final <code>tsconfig.json</code>.</p>
<pre><code><span>// tsconfig1.json</span>
<span>{</span>
<span>    </span><span>&#34;compilerOptions&#34;</span><span>: {</span>
<span>        </span><span>&#34;strictNullChecks&#34;</span><span>: </span><span>true</span>
<span>    }</span>
<span>}</span>

<span>// tsconfig2.json</span>
<span>{</span>
<span>    </span><span>&#34;compilerOptions&#34;</span><span>: {</span>
<span>        </span><span>&#34;noImplicitAny&#34;</span><span>: </span><span>true</span>
<span>    }</span>
<span>}</span>

<span>// tsconfig.json</span>
<span>{</span>
<span>    </span><span>&#34;extends&#34;</span><span>: [</span><span>&#34;./tsconfig1.json&#34;</span><span>, </span><span>&#34;./tsconfig2.json&#34;</span><span>],</span>
<span>    </span><span>&#34;files&#34;</span><span>: [</span><span>&#34;./index.ts&#34;</span><span>]</span>
<span>}</span>
</code></pre>
<p>As another example, we can rewrite our original example in the following way.</p>
<pre><code><span>// packages/front-end/src/tsconfig.json</span>
<span>{</span>
<span>    </span><span>&#34;extends&#34;</span><span>: [</span><span>&#34;@tsconfig/strictest/tsconfig.json&#34;</span><span>, </span><span>&#34;../../../tsconfig.base.json&#34;</span><span>],</span>
<span>    </span><span>&#34;compilerOptions&#34;</span><span>: {</span>
<span>        </span><span>&#34;outDir&#34;</span><span>: </span><span>&#34;../lib&#34;</span><span>,</span>
<span>        </span><span>// ...</span>
<span>    }</span>
<span>}</span>
</code></pre>
<p>For more details, <a href="https://github.com/microsoft/TypeScript/pull/50403">read more on the original pull request</a>.</p>
<h2 id="all-enums-are-union-enums">All <code>enum</code>s Are Union <code>enum</code>s</h2>
<p>When TypeScript originally introduced enums, they were nothing more than a set of numeric constants with the same type.</p>
<pre><code><span>enum</span><span> </span><span>E</span><span> {</span>
<span>    </span><span>Foo</span><span> = </span><span>10</span><span>,</span>
<span>    </span><span>Bar</span><span> = </span><span>20</span><span>,</span>
<span>}</span>
</code></pre>
<p>The only thing special about <code>E.Foo</code> and <code>E.Bar</code> was that they were assignable to anything expecting the type <code>E</code>.
Other than that, they were pretty much just <code>number</code>s.</p>
<pre><code><span>function</span><span> </span><span>takeValue</span><span>(</span><span>e</span><span>: </span><span>E</span><span>) {}</span>

<span>takeValue</span><span>(</span><span>E</span><span>.</span><span>Foo</span><span>); </span><span>// works</span>
<span>takeValue</span><span>(</span><span>123</span><span>); </span><span>// error!</span>
</code></pre>
<p>It wasn’t until TypeScript 2.0 introduced enum literal types that enums got a bit more special.
Enum literal types gave each enum member its own type, and turned the enum itself into a <em>union</em> of each member type.
They also allowed us to refer to only a subset of the types of an enum, and to narrow away those types.</p>
<pre><code><span>// Color is like a union of Red | Orange | Yellow | Green | Blue | Violet</span>
<span>enum</span><span> </span><span>Color</span><span> {</span>
<span>    </span><span>Red</span><span>, </span><span>Orange</span><span>, </span><span>Yellow</span><span>, </span><span>Green</span><span>, </span><span>Blue</span><span>, </span><span>/* Indigo */</span><span>, </span><span>Violet</span>
<span>}</span>

<span>// Each enum member has its own type that we can refer to!</span>
<span>type</span><span> </span><span>PrimaryColor</span><span> = </span><span>Color</span><span>.</span><span>Red</span><span> | </span><span>Color</span><span>.</span><span>Green</span><span> | </span><span>Color</span><span>.</span><span>Blue</span><span>;</span>

<span>function</span><span> </span><span>isPrimaryColor</span><span>(</span><span>c</span><span>: </span><span>Color</span><span>): </span><span>c</span><span> </span><span>is</span><span> </span><span>PrimaryColor</span><span> {</span>
<span>    </span><span>// Narrowing literal types can catch bugs.</span>
<span>    </span><span>// TypeScript will error here because</span>
<span>    </span><span>// we&#39;ll end up comparing &#39;Color.Red&#39; to &#39;Color.Green&#39;.</span>
<span>    </span><span>// We meant to use ||, but accidentally wrote &amp;&amp;.</span>
<span>    </span><span>return</span><span> </span><span>c</span><span> === </span><span>Color</span><span>.</span><span>Red</span><span> &amp;&amp; </span><span>c</span><span> === </span><span>Color</span><span>.</span><span>Green</span><span> &amp;&amp; </span><span>c</span><span> === </span><span>Color</span><span>.</span><span>Blue</span><span>;</span>
<span>}</span>
</code></pre>
<p>One issue with giving each enum member its own type was that those types were in some part associated with the actual value of the member.
In some cases it’s not possible to compute that value – for instance, an enum member could be initialized by a function call.</p>
<pre><code><span>enum</span><span> </span><span>E</span><span> {</span>
<span>    </span><span>Blah</span><span> = </span><span>Math</span><span>.</span><span>random</span><span>()</span>
<span>}</span>
</code></pre>
<p>Whenever TypeScript ran into these issues, it would quietly back out and use the old enum strategy.
That meant giving up all the advantages of unions and literal types.</p>
<p>TypeScript 5.0 manages to make all enums into union enums by creating a unique type for each computed member.
That means that all enums can now be narrowed and have their members referenced as types as well.</p>
<p>For more details on this change, you can <a href="https://github.com/microsoft/TypeScript/pull/50528">read the specifics on GitHub</a>.</p>
<h2 id="moduleresolution-bundler"><code>--moduleResolution bundler</code></h2>
<p>TypeScript 4.7 introduced the <code>node16</code> and <code>nodenext</code> options for its <code>--module</code> and <code>--moduleResolution</code> settings.
The intent of these options was to better model the precise lookup rules for ECMAScript modules in Node.js;
however, this mode has many restrictions that other tools don’t really enforce.</p>
<p>For example, in an ECMAScript module in Node.js, any relative import needs to include a file extension.</p>
<pre><code><span>// entry.mjs</span>
<span>import</span><span> </span><span>*</span><span> </span><span>as</span><span> </span><span>utils</span><span> </span><span>from</span><span> </span><span>&#34;./utils&#34;</span><span>;     </span><span>// ❌ wrong - we need to include the file extension.</span>

<span>import</span><span> </span><span>*</span><span> </span><span>as</span><span> </span><span>utils</span><span> </span><span>from</span><span> </span><span>&#34;./utils.mjs&#34;</span><span>; </span><span>// ✅ works</span>
</code></pre>
<p>There are certain reasons for this in Node.js and the browser – it makes file lookups faster and works better for naive file servers.
But for many developers using tools like bundlers, the <code>node16</code>/<code>nodenext</code> settings were cumbersome because bundlers don’t have most of these restrictions.
In some ways, the <code>node</code> resolution mode was better for anyone using a bundler.</p>
<p>But in some ways, the original <code>node</code> resolution mode was already out of date.
Most modern bundlers use a fusion of the ECMAScript module and CommonJS lookup rules in Node.js.
For example, extensionless imports work just fine like in CommonJS, but when looking through the <a href="https://nodejs.org/api/packages.html#nested-conditions"><code>export</code> conditions</a> of a package, they’ll prefer an <code>import</code> condition just like in an ECMAScript file.</p>
<p>To model how bundlers work, TypeScript now introduces a new strategy: <code>--moduleResolution bundler</code>.</p>
<pre><code><span>{</span>
<span>    </span><span>&#34;compilerOptions&#34;</span><span>: {</span>
<span>        </span><span>&#34;target&#34;</span><span>: </span><span>&#34;esnext&#34;</span><span>,</span>
<span>        </span><span>&#34;moduleResolution&#34;</span><span>: </span><span>&#34;bundler&#34;</span>
<span>    }</span>
<span>}</span>
</code></pre>
<p>If you are using a modern bundler like Vite, esbuild, swc, Webpack, Parcel, and others that implement a hybrid lookup strategy, the new <code>bundler</code> option should be a good fit for you.</p>
<p>On the other hand, if you’re writing a library that’s meant to be published on npm, using the <code>bundler</code> option can hide compatibility issues that may arise for your users who <em>aren’t</em> using a bundler.
So in these cases, using the <code>node16</code> or <code>nodenext</code> resolution options is likely to be a better path.</p>
<p>To read more on <code>--moduleResolution bundler</code>, <a href="https://github.com/microsoft/TypeScript/pull/51669">take a look at the implementing pull request</a>.</p>
<h2 id="resolution-customization-flags">Resolution Customization Flags</h2>
<p>JavaScript tooling may now model &#34;hybrid&#34; resolution rules, like in the <code>bundler</code> mode we described above.
Because tools may differ in their support slightly, TypeScript 5.0 provides ways to enable or disable a few features that may or may not work with your configuration.</p>
<h3 id="allowimportingtsextensions"><code>allowImportingTsExtensions</code></h3>
<p><code>--allowImportingTsExtensions</code> allows TypeScript files to import each other with a TypeScript-specific extension like <code>.ts</code>, <code>.mts</code>, or <code>.tsx</code>.</p>
<p>This flag is only allowed when <code>--noEmit</code> or <code>--emitDeclarationOnly</code> is enabled, since these import paths would not be resolvable at runtime in JavaScript output files.
The expectation here is that your resolver (e.g. your bundler, a runtime, or some other tool) is going to make these imports between <code>.ts</code> files work.</p>
<h3 id="resolvepackagejsonexports"><code>resolvePackageJsonExports</code></h3>
<p><code>--resolvePackageJsonExports</code> forces TypeScript to consult <a href="https://nodejs.org/api/packages.html#exports">the <code>exports</code> field of <code>package.json</code> files</a> if it ever reads from a package in <code>node_modules</code>.</p>
<p>This option defaults to <code>true</code> under the <code>node16</code>, <code>nodenext</code>, and <code>bundler</code> options for <code>--moduleResolution</code>.</p>
<h3 id="resolvepackagejsonimports"><code>resolvePackageJsonImports</code></h3>
<p><code>--resolvePackageJsonImports</code> forces TypeScript to consult <a href="https://nodejs.org/api/packages.html#imports">the <code>imports</code> field of <code>package.json</code> files</a> when performing a lookup that starts with <code>#</code> from a file whose ancestor directory contains a <code>package.json</code>.</p>
<p>This option defaults to <code>true</code> under the <code>node16</code>, <code>nodenext</code>, and <code>bundler</code> options for <code>--moduleResolution</code>.</p>
<h3 id="allowarbitraryextensions"><code>allowArbitraryExtensions</code></h3>
<p>In TypeScript 5.0, when an import path ends in an extension that isn’t a known JavaScript or TypeScript file extension, the compiler will look for a declaration file for that path in the form of <code>{file basename}.d.{extension}.ts</code>.
For example, if you are using a CSS loader in a bundler project, you might want to write (or generate) declaration files for those stylesheets:</p>
<pre><code><span>/* app.css */</span>
<span>.cookie-banner</span><span> {</span>
<span>  </span><span>display</span><span>: </span><span>none</span><span>;</span>
<span>}</span>
</code></pre>
<pre><code><span>// app.d.css.ts</span>
<span>declare</span><span> </span><span>const</span><span> </span><span>css</span><span>: {</span>
<span>  </span><span>cookieBanner</span><span>: </span><span>string</span><span>;</span>
<span>};</span>
<span>export</span><span> </span><span>default</span><span> </span><span>css</span><span>;</span>
</code></pre>
<pre><code><span>// App.tsx</span>
<span>import</span><span> </span><span>styles</span><span> </span><span>from</span><span> </span><span>&#34;./app.css&#34;</span><span>;</span>

<span>styles</span><span>.</span><span>cookieBanner</span><span>; </span><span>// string</span>
</code></pre>
<p>By default, this import will raise an error to let you know that TypeScript doesn’t understand this file type and your runtime might not support importing it.
But if you’ve configured your runtime or bundler to handle it, you can suppress the error with the new <code>--allowArbitraryExtensions</code> compiler option.</p>
<p>Note that historically, a similar effect has often been achievable by adding a declaration file named <code>app.css.d.ts</code> instead of <code>app.d.css.ts</code> – however, this just worked through Node’s <code>require</code> resolution rules for CommonJS.
Strictly speaking, the former is interpreted as a declaration file for a JavaScript file named <code>app.css.js</code>.
Because relative files imports need to include extensions in Node’s ESM support, TypeScript would error on our example in an ESM file under <code>--moduleResolution node16</code> or <code>nodenext</code>.</p>
<p>For more information, read up <a href="https://github.com/microsoft/TypeScript/issues/50133">the proposal for this feature</a> and <a href="https://github.com/microsoft/TypeScript/pull/51435">its corresponding pull request</a>.</p>
<h3 id="customconditions"><code>customConditions</code></h3>
<p><code>--customConditions</code> takes a list of additional <a href="https://nodejs.org/api/packages.html#nested-conditions">conditions</a> that should succeed when TypeScript resolves from an [<code>exports</code>] or (<a href="https://nodejs.org/api/packages.html#exports">https://nodejs.org/api/packages.html#exports</a>) or <a href="https://nodejs.org/api/packages.html#imports"><code>imports</code></a> field of a <code>package.json</code>.
These conditions are added to whatever existing conditions a resolver will use by default.</p>
<p>For example, when this field is set in a <code>tsconfig.json</code> as so:</p>
<pre><code><span>{</span>
<span>    </span><span>&#34;compilerOptions&#34;</span><span>: {</span>
<span>        </span><span>&#34;target&#34;</span><span>: </span><span>&#34;es2022&#34;</span><span>,</span>
<span>        </span><span>&#34;moduleResolution&#34;</span><span>: </span><span>&#34;bundler&#34;</span><span>,</span>
<span>        </span><span>&#34;customConditions&#34;</span><span>: [</span><span>&#34;my-condition&#34;</span><span>]</span>
<span>    }</span>
<span>}</span>
</code></pre>
<p>Any time an <code>exports</code> or <code>imports</code> field is referenced in <code>package.json</code>, TypeScript will consider conditions called <code>my-condition</code>.</p>
<p>So when importing from a package with the following <code>package.json</code></p>
<pre><code><span>{</span>
<span>    </span><span>// ...</span>
<span>    </span><span>&#34;exports&#34;</span><span>: {</span>
<span>        </span><span>&#34;.&#34;</span><span>: {</span>
<span>            </span><span>&#34;my-condition&#34;</span><span>: </span><span>&#34;./foo.mjs&#34;</span><span>,</span>
<span>            </span><span>&#34;node&#34;</span><span>: </span><span>&#34;./bar.mjs&#34;</span><span>,</span>
<span>            </span><span>&#34;import&#34;</span><span>: </span><span>&#34;./baz.mjs&#34;</span><span>,</span>
<span>            </span><span>&#34;require&#34;</span><span>: </span><span>&#34;./biz.mjs&#34;</span>
<span>        }</span>
<span>    }</span>
<span>}</span>
</code></pre>
<p>TypeScript will try to look for files corresponding to <code>foo.mjs</code>.</p>
<p>This field is only valid under the <code>node16</code>, <code>nodenext</code>, and <code>bundler</code> options for <code>--moduleResolution</code></p>
<h2 id="verbatimmodulesyntax"><code>--verbatimModuleSyntax</code></h2>
<p>By default, TypeScript does something called <em>import elision</em>.
Basically, if you write something like</p>
<pre><code><span>import</span><span> { </span><span>Car</span><span> } </span><span>from</span><span> </span><span>&#34;./car&#34;</span><span>;</span>

<span>export</span><span> </span><span>function</span><span> </span><span>drive</span><span>(</span><span>car</span><span>: </span><span>Car</span><span>) {</span>
<span>    </span><span>// ...</span>
<span>}</span>
</code></pre>
<p>TypeScript detects that you’re only using an import for types and drops the import entirely.
Your output JavaScript might look something like this:</p>
<pre><code><span>export</span><span> </span><span>function</span><span> </span><span>drive</span><span>(</span><span>car</span><span>) {</span>
<span>    </span><span>// ...</span>
<span>}</span>
</code></pre>
<p>Most of the time this is good, because if <code>Car</code> isn’t a value that’s exported from <code>./car</code>, we’ll get a runtime error.</p>
<p>But it does add a layer of complexity for certain edge cases.
For example, notice there’s no statement like <code>import &#34;./car&#34;;</code> – the import was dropped entirely.
That actually makes a difference for modules that have side effects or not.</p>
<p>TypeScript’s emit strategy for JavaScript also has another few layers of complexity – import elision isn’t always just driven by how an import is used – it often consults how a value is declared as well.
So it’s not always clear whether code like the following</p>
<pre><code><span>export</span><span> { </span><span>Car</span><span> } </span><span>from</span><span> </span><span>&#34;./car&#34;</span><span>;</span>
</code></pre>
<p>should be preserved or dropped.
If <code>Car</code> is declared with something like a <code>class</code>, then it can be preserved in the resulting JavaScript file.
But if <code>Car</code> is only declared as a <code>type</code> alias or <code>interface</code>, then the JavaScript file shouldn’t export <code>Car</code> at all.</p>
<p>While TypeScript might be able to make these emit decisions based on information from across files, not every compiler can.</p>
<p>The <code>type</code> modifier on imports and exports helps with these situations a bit.
We can make it explicit whether an import or export is only being used for type analysis, and can be dropped entirely in JavaScript files by using the <code>type</code> modifier.</p>
<pre><code><span>// This statement can be dropped entirely in JS output</span>
<span>import</span><span> </span><span>type</span><span> </span><span>*</span><span> </span><span>as</span><span> </span><span>car</span><span> </span><span>from</span><span> </span><span>&#34;./car&#34;</span><span>;</span>

<span>// The named import/export &#39;Car&#39; can be dropped in JS output</span>
<span>import</span><span> { </span><span>type</span><span> </span><span>Car</span><span> } </span><span>from</span><span> </span><span>&#34;./car&#34;</span><span>;</span>
<span>export</span><span> { </span><span>type</span><span> </span><span>Car</span><span> } </span><span>from</span><span> </span><span>&#34;./car&#34;</span><span>;</span>
</code></pre>
<p><code>type</code> modifiers are not quite useful on their own – by default, module elision will still drop imports, and nothing forces you to make the distinction between <code>type</code> and plain imports and exports.
So TypeScript has the flag <code>--importsNotUsedAsValues</code> to make sure you use the <code>type</code> modifier, <code>--preserveValueImports</code> to prevent <em>some</em> module elision behavior, and <code>--isolatedModules</code> to make sure that your TypeScript code works across different compilers.
Unfortunately, understanding the fine details of those 3 flags is hard, and there are still some edge cases with unexpected behavior.</p>
<p>TypeScript 5.0 introduces a new option called <code>--verbatimModuleSyntax</code> to simplify the situation.
The rules are much simpler – any imports or exports without a <code>type</code> modifier are left around.
Anything that uses the <code>type</code> modifier is dropped entirely.</p>
<pre><code><span>// Erased away entirely.</span>
<span>import</span><span> </span><span>type</span><span> { </span><span>A</span><span> } </span><span>from</span><span> </span><span>&#34;a&#34;</span><span>;</span>

<span>// Rewritten to &#39;import { b } from &#34;bcd&#34;;&#39;</span>
<span>import</span><span> { </span><span>b</span><span>, </span><span>type</span><span> </span><span>c</span><span>, </span><span>type</span><span> </span><span>d</span><span> } </span><span>from</span><span> </span><span>&#34;bcd&#34;</span><span>;</span>

<span>// Rewritten to &#39;import {} from &#34;xyz&#34;;&#39;</span>
<span>import</span><span> { </span><span>type</span><span> </span><span>xyz</span><span> } </span><span>from</span><span> </span><span>&#34;xyz&#34;</span><span>;</span>
</code></pre>
<p>With this new option, what you see is what you get.</p>
<p>That does have some implications when it comes to module interop though.
Under this flag, ECMAScript <code>import</code>s and <code>export</code>s won’t be rewritten to <code>require</code> calls when your settings or file extension implied a different module system.
Instead, you’ll get an error.
If you need to emit code that uses <code>require</code> and <code>module.exports</code>, you’ll have to use TypeScript’s module syntax that predates ES2015:</p>
<table>
<thead>
<tr>
<th>Input TypeScript</th>
<th>Output JavaScript</th>
</tr>
</thead>
<tbody><tr>
<td>
<pre><code><span>import</span><span> </span><span>foo</span><span> = </span><span>require</span><span>(</span><span>&#34;foo&#34;</span><span>);</span>
</code></pre>
</td>
<td>
<pre><code><span>const</span><span> </span><span>foo</span><span> = </span><span>require</span><span>(</span><span>&#34;foo&#34;</span><span>);</span>
</code></pre>
</td>
</tr>
<tr>
<td>
<pre><code><span>function</span><span> </span><span>foo</span><span>() {}</span>
<span>function</span><span> </span><span>bar</span><span>() {}</span>
<span>function</span><span> </span><span>baz</span><span>() {}</span>

<span>export</span><span> = {</span>
<span>    </span><span>foo</span><span>,</span>
<span>    </span><span>bar</span><span>,</span>
<span>    </span><span>baz</span>
<span>};</span>
</code></pre>
</td>
<td>
<pre><code><span>function</span><span> </span><span>foo</span><span>() {}</span>
<span>function</span><span> </span><span>bar</span><span>() {}</span>
<span>function</span><span> </span><span>baz</span><span>() {}</span>

<span>module</span><span>.</span><span>exports</span><span> = {</span>
<span>    </span><span>foo</span><span>,</span>
<span>    </span><span>bar</span><span>,</span>
<span>    </span><span>baz</span>
<span>};</span>
</code></pre>
</td>
</tr>
</tbody></table>
<p>While this is a limitation, it does help make some issues more obvious.
For example, it’s very common to forget to set the <a href="https://nodejs.org/api/packages.html#type"><code>type</code> field in <code>package.json</code></a> under <code>--module node16</code>.
As a result, developers would start writing CommonJS modules instead of an ES modules without realizing it, giving surprising lookup rules and JavaScript output.
This new flag ensures that you’re intentional about the file type you’re using because the syntax is intentionally different.</p>
<p>Because <code>--verbatimModuleSyntax</code> provides a more consistent story than <code>--importsNotUsedAsValues</code> and <code>--preserveValueImports</code>, those two existing flags are being deprecated in its favor.</p>
<p>For more details, read up on <a href="https://github.com/microsoft/TypeScript/pull/52203">the original pull request</a> and <a href="https://github.com/microsoft/TypeScript/issues/51479">its proposal issue</a>.</p>
<h2 id="support-for-export-type">Support for <code>export type *</code></h2>
<p>When TypeScript 3.8 introduced type-only imports, the new syntax wasn’t allowed on <code>export * from &#34;module&#34;</code> or <code>export * as ns from &#34;module&#34;</code> re-exports. TypeScript 5.0 adds support for both of these forms:</p>
<pre><code><span>// models/vehicles.ts</span>
<span>export</span><span> </span><span>class</span><span> </span><span>Spaceship</span><span> {</span>
<span>  </span><span>// ...</span>
<span>}</span>

<span>// models/index.ts</span>
<span>export</span><span> </span><span>type</span><span> </span><span>*</span><span> </span><span>as</span><span> </span><span>vehicles</span><span> </span><span>from</span><span> </span><span>&#34;./vehicles&#34;</span><span>;</span>

<span>// main.ts</span>
<span>import</span><span> { </span><span>vehicles</span><span> } </span><span>from</span><span> </span><span>&#34;./models&#34;</span><span>;</span>

<span>function</span><span> </span><span>takeASpaceship</span><span>(</span><span>s</span><span>: </span><span>vehicles</span><span>.</span><span>Spaceship</span><span>) {</span>
<span>  </span><span>// ✅ ok - `vehicles` only used in a type position</span>
<span>}</span>

<span>function</span><span> </span><span>makeASpaceship</span><span>() {</span>
<span>  </span><span>return</span><span> </span><span>new</span><span> </span><span>vehicles</span><span>.</span><span>Spaceship</span><span>();</span>
<span>  </span><span>//         ^^^^^^^^</span>
<span>  </span><span>// &#39;vehicles&#39; cannot be used as a value because it was exported using &#39;export type&#39;.</span>
<span>}</span>
</code></pre>
<p>You can <a href="https://github.com/microsoft/TypeScript/pull/52217">read more about the implementation here</a>.</p>
<h2 id="satisfies-support-in-jsdoc"><code>@satisfies</code> Support in JSDoc</h2>
<p>TypeScript 4.9 introduced the <code>satisfies</code> operator.
It made sure that the type of an expression was compatible, without affecting the type itself.
For example, let’s take the following code:</p>
<pre><code><span>interface</span><span> </span><span>CompilerOptions</span><span> {</span>
<span>    </span><span>strict</span><span>?: </span><span>boolean</span><span>;</span>
<span>    </span><span>outDir</span><span>?: </span><span>string</span><span>;</span>
<span>    </span><span>// ...</span>
<span>}</span>

<span>interface</span><span> </span><span>ConfigSettings</span><span> {</span>
<span>    </span><span>compilerOptions</span><span>?: </span><span>CompilerOptions</span><span>;</span>
<span>    </span><span>extends</span><span>?: </span><span>string</span><span> | </span><span>string</span><span>[];</span>
<span>    </span><span>// ...</span>
<span>}</span>

<span>let</span><span> </span><span>myConfigSettings</span><span> = {</span>
<span>    </span><span>compilerOptions:</span><span> {</span>
<span>        </span><span>strict:</span><span> </span><span>true</span><span>,</span>
<span>        </span><span>outDir:</span><span> </span><span>&#34;../lib&#34;</span><span>,</span>
<span>        </span><span>// ...</span>
<span>    },</span>

<span>    </span><span>extends:</span><span> [</span>
<span>        </span><span>&#34;@tsconfig/strictest/tsconfig.json&#34;</span><span>,</span>
<span>        </span><span>&#34;../../../tsconfig.base.json&#34;</span>
<span>    ],</span>

<span>} </span><span>satisfies</span><span> </span><span>ConfigSettings</span><span>;</span>
</code></pre>
<p>Here, TypeScript knows that <code>myCompilerOptions.extends</code> was declared with an array – because while <code>satisfies</code> validated the type of our object, it didn’t bluntly change it to <code>CompilerOptions</code> and lose information.
So if we want to map over <code>extends</code>, that’s fine.</p>
<pre><code><span>declare</span><span> </span><span>function</span><span> </span><span>resolveConfig</span><span>(</span><span>configPath</span><span>: </span><span>string</span><span>): </span><span>CompilerOptions</span><span>;</span>

<span>let</span><span> </span><span>inheritedConfigs</span><span> = </span><span>myConfigSettings</span><span>.</span><span>extends</span><span>.</span><span>map</span><span>(</span><span>resolveConfig</span><span>);</span>
</code></pre>
<p>This was helpful for TypeScript users, but plenty of people use TypeScript to type-check their JavaScript code using JSDoc annotations.
That’s why TypeScript 5.0 is supporting a new JSDoc tag called <code>@satisfies</code> that does exactly the same thing.</p>
<p><code>/** @satisfies */</code> can catch type mismatches:</p>
<pre><code><span>// @ts-check</span>

<span>/**</span>
<span> * </span><span>@typedef</span><span> </span><span>CompilerOptions</span>
<span> * </span><span>@prop</span><span> </span><span>{boolean}</span><span> </span><span>[strict]</span>
<span> * </span><span>@prop</span><span> </span><span>{string}</span><span> </span><span>[outDir]</span>
<span> */</span>

<span>/**</span>
<span> * </span><span>@satisfies</span><span> {CompilerOptions}</span>
<span> */</span>
<span>let</span><span> </span><span>myCompilerOptions</span><span> = {</span>
<span>    </span><span>outdir:</span><span> </span><span>&#34;../lib&#34;</span><span>,</span>
<span>//  ~~~~~~ oops! we meant outDir</span>
<span>};</span>
</code></pre>
<p>But it will preserve the original type of our expressions, allowing us to use our values more precisely later on in our code.</p>
<pre><code><span>// @ts-check</span>

<span>/**</span>
<span> * </span><span>@typedef</span><span> </span><span>CompilerOptions</span>
<span> * </span><span>@prop</span><span> </span><span>{boolean}</span><span> </span><span>[strict]</span>
<span> * </span><span>@prop</span><span> </span><span>{string}</span><span> </span><span>[outDir]</span>
<span> */</span>

<span>/**</span>
<span> * </span><span>@typedef</span><span> </span><span>ConfigSettings</span>
<span> * </span><span>@prop</span><span> </span><span>{CompilerOptions}</span><span> </span><span>[compilerOptions]</span>
<span> * </span><span>@prop</span><span> </span><span>{string | string[]}</span><span> </span><span>[extends]</span>
<span> */</span>


<span>/**</span>
<span> * </span><span>@satisfies</span><span> {ConfigSettings}</span>
<span> */</span>
<span>let</span><span> </span><span>myConfigSettings</span><span> = {</span>
<span>    </span><span>compilerOptions:</span><span> {</span>
<span>        </span><span>strict:</span><span> </span><span>true</span><span>,</span>
<span>        </span><span>outDir:</span><span> </span><span>&#34;../lib&#34;</span><span>,</span>
<span>    },</span>
<span>    </span><span>extends:</span><span> [</span>
<span>        </span><span>&#34;@tsconfig/strictest/tsconfig.json&#34;</span><span>,</span>
<span>        </span><span>&#34;../../../tsconfig.base.json&#34;</span>
<span>    ],</span>
<span>};</span>

<span>let</span><span> </span><span>inheritedConfigs</span><span> = </span><span>myConfigSettings</span><span>.</span><span>extends</span><span>.</span><span>map</span><span>(</span><span>resolveConfig</span><span>);</span>
</code></pre>
<p><code>/** @satisfies */</code> can also be used inline on any parenthesized expression.
We could have written <code>myCompilerOptions</code> like this:</p>
<pre><code><span>let</span><span> </span><span>myConfigSettings</span><span> = </span><span>/** </span><span>@satisfies</span><span> {ConfigSettings} */</span><span> ({</span>
<span>    </span><span>compilerOptions:</span><span> {</span>
<span>        </span><span>strict:</span><span> </span><span>true</span><span>,</span>
<span>        </span><span>outDir:</span><span> </span><span>&#34;../lib&#34;</span><span>,</span>
<span>    },</span>
<span>    </span><span>extends:</span><span> [</span>
<span>        </span><span>&#34;@tsconfig/strictest/tsconfig.json&#34;</span><span>,</span>
<span>        </span><span>&#34;../../../tsconfig.base.json&#34;</span>
<span>    ],</span>
<span>});</span>
</code></pre>
<p>Why?
Well, it usually makes more sense when you’re deeper in some other code, like a function call.</p>
<pre><code><span>compileCode</span><span>(</span><span>/** </span><span>@satisfies</span><span> {CompilerOptions} */</span><span> ({</span>
<span>    </span><span>// ...</span>
<span>}));</span>
</code></pre>
<p><a href="https://github.com/microsoft/TypeScript/pull/51753">This feature</a> was provided thanks to <a href="https://github.com/a-tarasyuk">Oleksandr Tarasiuk</a>!</p>
<h2 id="overload-support-in-jsdoc"><code>@overload</code> Support in JSDoc</h2>
<p>In TypeScript, you can specify overloads for a function.
Overloads give us a way to say that a function can be called with different arguments, and possibly return different results.
They can restrict how callers can actually use our functions, and refine what results they’ll get back.</p>
<pre><code><span>// Our overloads:</span>
<span>function</span><span> </span><span>printValue</span><span>(</span><span>str</span><span>: </span><span>string</span><span>): </span><span>void</span><span>;</span>
<span>function</span><span> </span><span>printValue</span><span>(</span><span>num</span><span>: </span><span>number</span><span>, </span><span>maxFractionDigits</span><span>?: </span><span>number</span><span>): </span><span>void</span><span>;</span>

<span>// Our implementation:</span>
<span>function</span><span> </span><span>printValue</span><span>(</span><span>value</span><span>: </span><span>string</span><span> | </span><span>number</span><span>, </span><span>maximumFractionDigits</span><span>?: </span><span>number</span><span>) {</span>
<span>    </span><span>if</span><span> (</span><span>typeof</span><span> </span><span>value</span><span> === </span><span>&#34;number&#34;</span><span>) {</span>
<span>        </span><span>const</span><span> </span><span>formatter</span><span> = </span><span>Intl</span><span>.</span><span>NumberFormat</span><span>(</span><span>&#34;en-US&#34;</span><span>, {</span>
<span>            </span><span>maximumFractionDigits</span><span>,</span>
<span>        });</span>
<span>        </span><span>value</span><span> = </span><span>formatter</span><span>.</span><span>format</span><span>(</span><span>value</span><span>);</span>
<span>    }</span>

<span>    </span><span>console</span><span>.</span><span>log</span><span>(</span><span>value</span><span>);</span>
<span>}</span>
</code></pre>
<p>Here, we’ve said that <code>printValue</code> takes either a <code>string</code> or a <code>number</code> as its first argument.
If it takes a <code>number</code>, it can take a second argument to determine how many fractional digits we can print.</p>
<p>TypeScript 5.0 now allows JSDoc to declare overloads with a new <code>@overload</code> tag.
Each JSDoc comment with an <code>@overload</code> tag is treated as a distinct overload for the following function declaration.</p>
<pre><code><span>// @ts-check</span>

<span>/**</span>
<span> * </span><span>@overload</span>
<span> * </span><span>@param</span><span> </span><span>{string}</span><span> </span><span>value</span>
<span> * </span><span>@return</span><span> </span><span>{void}</span>
<span> */</span>

<span>/**</span>
<span> * </span><span>@overload</span>
<span> * </span><span>@param</span><span> </span><span>{number}</span><span> </span><span>value</span>
<span> * </span><span>@param</span><span> </span><span>{number}</span><span> </span><span>[maximumFractionDigits]</span>
<span> * </span><span>@return</span><span> </span><span>{void}</span>
<span> */</span>

<span>/**</span>
<span> * </span><span>@param</span><span> </span><span>{string | number}</span><span> </span><span>value</span>
<span> * </span><span>@param</span><span> </span><span>{number}</span><span> </span><span>[maximumFractionDigits]</span>
<span> */</span>
<span>function</span><span> </span><span>printValue</span><span>(</span><span>value</span><span>, </span><span>maximumFractionDigits</span><span>) {</span>
<span>    </span><span>if</span><span> (</span><span>typeof</span><span> </span><span>value</span><span> === </span><span>&#34;number&#34;</span><span>) {</span>
<span>        </span><span>const</span><span> </span><span>formatter</span><span> = </span><span>Intl</span><span>.</span><span>NumberFormat</span><span>(</span><span>&#34;en-US&#34;</span><span>, {</span>
<span>            </span><span>maximumFractionDigits</span><span>,</span>
<span>        });</span>
<span>        </span><span>value</span><span> = </span><span>formatter</span><span>.</span><span>format</span><span>(</span><span>value</span><span>);</span>
<span>    }</span>

<span>    </span><span>console</span><span>.</span><span>log</span><span>(</span><span>value</span><span>);</span>
<span>}</span>
</code></pre>
<p>Now regardless of whether we’re writing in a TypeScript or JavaScript file, TypeScript can let us know if we’ve called our functions incorrectly.</p>
<pre><code><span>// all allowed</span>
<span>printValue</span><span>(</span><span>&#34;hello!&#34;</span><span>);</span>
<span>printValue</span><span>(</span><span>123.45</span><span>);</span>
<span>printValue</span><span>(</span><span>123.45</span><span>, </span><span>2</span><span>);</span>

<span>printValue</span><span>(</span><span>&#34;hello!&#34;</span><span>, </span><span>123</span><span>); </span><span>// error!</span>
</code></pre>
<p>This new tag <a href="https://github.com/microsoft/TypeScript/pull/51234">was implemented</a> thanks to <a href="https://github.com/apendua">Tomasz Lenarcik</a>.</p>
<h2 id="passing-emit-specific-flags-under-build">Passing Emit-Specific Flags Under <code>--build</code></h2>
<p>TypeScript now allows the following flags to be passed under <code>--build</code> mode</p>
<ul>
<li><code>--declaration</code></li>
<li><code>--emitDeclarationOnly</code></li>
<li><code>--declarationMap</code></li>
<li><code>--sourceMap</code></li>
<li><code>--inlineSourceMap</code></li>
</ul>
<p>This makes it way easier to customize certain parts of a build where you might have different development and production builds.</p>
<p>For example, a development build of a library might not need to produce declaration files, but a production build would.
A project can configure declaration emit to be off by default and simply be built with</p>
<pre><code><span>tsc --build -p ./my-project-dir</span>
</code></pre>
<p>Once you’re done iterating in the inner loop, a &#34;production&#34; build can just pass the <code>--declaration</code> flag.</p>
<pre><code><span>tsc --build -p ./my-project-dir --declaration</span>
</code></pre>
<p><a href="https://github.com/microsoft/TypeScript/pull/51241">More information on this change is available here</a>.</p>
<h2 id="case-insensitive-import-sorting-in-editors">Case-Insensitive Import Sorting in Editors</h2>
<p>In editors like Visual Studio and VS Code, TypeScript powers the experience for organizing and sorting imports and exports.
Often though, there can be different interpretations of when a list is &#34;sorted&#34;.</p>
<p>For example, is the following import list sorted?</p>
<pre><code><span>import</span><span> {</span>
<span>    </span><span>Toggle</span><span>,</span>
<span>    </span><span>freeze</span><span>,</span>
<span>    </span><span>toBoolean</span><span>,</span>
<span>} </span><span>from</span><span> </span><span>&#34;./utils&#34;</span><span>;</span>
</code></pre>
<p>The answer might surprisingly be &#34;it depends&#34;.
If we <em>don’t</em> care about case-sensitivity, then this list is clearly not sorted.
The letter <code>f</code> comes before both <code>t</code> and <code>T</code>.</p>
<p>But in most programming languages, sorting defaults to comparing the byte values of strings.
The way JavaScript compares strings means that <code>&#34;Toggle&#34;</code> always comes before <code>&#34;freeze&#34;</code> because according to the <a href="https://en.wikipedia.org/wiki/ASCII">ASCII character encoding</a>, uppercase letters come before lowercase.
So from that perspective, the import list is sorted.</p>
<p>TypeScript previously considered the import list to be sorted because it was doing a basic case-sensitive sort.
This could be a point of frustration for developers who preferred a case-<em>insensitive</em> ordering, or who used tools like ESLint which require to case-insensitive ordering by default.</p>
<p>TypeScript now detects case sensitivity by default.
This means that TypeScript and tools like ESLint typically won’t &#34;fight&#34; each other over how to best sort imports.</p>
<p>Our team has also been experimenting <a href="https://github.com/microsoft/TypeScript/pull/52115">with further sorting strategies which you can read about here</a>.
These options may eventually be configurable by editors.
For now, they are still unstable and experimental, and you can opt into them in VS Code today by using the <code>typescript.unstable</code> entry in your JSON options.
Below are all of the options you can try out (set to their defaults):</p>
<pre><code><span>{</span>
<span>    </span><span>&#34;typescript.unstable&#34;</span><span>: {</span>
<span>        </span><span>// Should sorting be case-sensitive? Can be:</span>
<span>        </span><span>// - true</span>
<span>        </span><span>// - false</span>
<span>        </span><span>// - &#34;auto&#34; (auto-detect)</span>
<span>        </span><span>&#34;organizeImportsIgnoreCase&#34;</span><span>: </span><span>&#34;auto&#34;</span><span>,</span>

<span>        </span><span>// Should sorting be &#34;ordinal&#34; and use code points or consider Unicode rules? Can be:</span>
<span>        </span><span>// - &#34;ordinal&#34;</span>
<span>        </span><span>// - &#34;unicode&#34;</span>
<span>        </span><span>&#34;organizeImportsCollation&#34;</span><span>: </span><span>&#34;ordinal&#34;</span><span>,</span>

<span>        </span><span>// Under `&#34;organizeImportsCollation&#34;: &#34;unicode&#34;`,</span>
<span>        </span><span>// what is the current locale? Can be:</span>
<span>        </span><span>// - [any other locale code]</span>
<span>        </span><span>// - &#34;auto&#34; (use the editor&#39;s locale)</span>
<span>        </span><span>&#34;organizeImportsLocale&#34;</span><span>: </span><span>&#34;en&#34;</span><span>,</span>

<span>        </span><span>// Under `&#34;organizeImportsCollation&#34;: &#34;unicode&#34;`,</span>
<span>        </span><span>// should upper-case letters or lower-case letters come first? Can be:</span>
<span>        </span><span>// - false (locale-specific)</span>
<span>        </span><span>// - &#34;upper&#34;</span>
<span>        </span><span>// - &#34;lower&#34;</span>
<span>        </span><span>&#34;organizeImportsCaseFirst&#34;</span><span>: </span><span>false</span><span>,</span>

<span>        </span><span>// Under `&#34;organizeImportsCollation&#34;: &#34;unicode&#34;`,</span>
<span>        </span><span>// do runs of numbers get compared numerically (i.e. &#34;a1&#34; &lt; &#34;a2&#34; &lt; &#34;a100&#34;)? Can be:</span>
<span>        </span><span>// - true</span>
<span>        </span><span>// - false</span>
<span>        </span><span>&#34;organizeImportsNumericCollation&#34;</span><span>: </span><span>true</span><span>,</span>

<span>        </span><span>// Under `&#34;organizeImportsCollation&#34;: &#34;unicode&#34;`,</span>
<span>        </span><span>// do letters with accent marks/diacritics get sorted distinctly</span>
<span>        </span><span>// from their &#34;base&#34; letter (i.e. is é different from e)? Can be</span>
<span>        </span><span>// - true</span>
<span>        </span><span>// - false</span>
<span>        </span><span>&#34;organizeImportsAccentCollation&#34;</span><span>: </span><span>true</span>
<span>    },</span>
<span>    </span><span>&#34;javascript.unstable&#34;</span><span>: {</span>
<span>        </span><span>// same options valid here...</span>
<span>    },</span>
<span>}</span>
</code></pre>
<p>You can read more details on <a href="https://github.com/microsoft/TypeScript/pull/51733">the original work for auto-detecting and specifying case-insensitivity</a>, followed by <a href="https://github.com/microsoft/TypeScript/pull/52115">the broader set of options</a>.</p>
<h2 id="exhaustive-switch-case-completions">Exhaustive <code>switch</code>/<code>case</code> Completions</h2>
<p>When writing a <code>switch</code> statement, TypeScript now detects when the value being checked has a literal type.
If so, it will offer a completion that scaffolds out each uncovered <code>case</code>.</p>
<p><img decoding="async" src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2023/03/exhaustiveCaseCompletions-5.0-stable-1.gif" alt="A set of  statements generated through auto-completion based on literal types."/></p>
<p>You can <a href="https://github.com/microsoft/TypeScript/pull/50996">see specifics of the implementation on GitHub</a>.</p>
<h2 id="speed-memory-and-package-size-optimizations">Speed, Memory, and Package Size Optimizations</h2>
<p>TypeScript 5.0 contains lots of powerful changes across our code structure, our data structures, and algorithmic implementations.
What these all mean is that your entire experience should be faster – not just running TypeScript, but even installing it.</p>
<p>Here are a few interesting wins in speed and size that we’ve been able to capture relative to TypeScript 4.9.</p>
<table>
<thead>
<tr>
<th>Scenario</th>
<th>Time or Size Relative to TS 4.9</th>
</tr>
</thead>
<tbody>
<tr>
<td>material-ui build time</td>
<td>90%</td>
</tr>
<tr>
<td>TypeScript Compiler startup time</td>
<td>89%</td>
</tr>
<tr>
<td>Playwright build time</td>
<td>88%</td>
</tr>
<tr>
<td>TypeScript Compiler self-build time</td>
<td>87%</td>
</tr>
<tr>
<td>Outlook Web build time</td>
<td>82%</td>
</tr>
<tr>
<td>VS Code build time</td>
<td>80%</td>
</tr>
<tr>
<td>typescript npm Package Size</td>
<td>59%</td>
</tr>
</tbody>
</table>
<p><img decoding="async" src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2023/03/speed-5.0-stable-2.png" alt="Chart of build/run times TypeScript 5.0 relative to TypeScript 4.9: material-ui docs build time: 90%; Playwright build time: 88%; tsc startup time: 87%; tsc build time: 87%; Outlook Web build time: 82%; VS Code build time: 80%"/></p>
<p><img decoding="async" src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2023/03/size-5.0-stable-1.png" alt="Chart of package size on npm between TypeScript 4.9 and 5.0. 4.9 package size is 63.8 MB, 5.0 package size is 37.4 MB."/></p>
<p>How?
There are a few notable improvements we’d like to give more details on in the future.
But we won’t make you wait for that blog post.</p>
<p>First off, we recently migrated TypeScript from namespaces to modules, allowing us to leverage modern build tooling that can perform optimizations like scope hoisting.
Using this tooling, revisiting our packaging strategy, and removing some deprecated code has shaved off about 26.4 MB from TypeScript 4.9’s 63.8 MB package size.
It also brought us a notable speed-up through direct function calls.
We put together <a href="https://devblogs.microsoft.com/typescript/typescripts-migration-to-modules/">a detailed write-up about our migration to modules here</a>.</p>
<p>TypeScript also added more uniformity to internal object types within the compiler, and also slimmed the data stored on some of these object types as well.
This reduced polymorphic operations, while balancing out the increase in memory usage that came from making our object shapes more uniform.</p>
<p>We’ve also performed some caching when serializing information to strings.
Type display, which can happen as part of error reporting, declaration emit, code completions, and more, can end up being fairly expensive.
TypeScript now caches some commonly used machinery to reuse across these operations.</p>
<p>Another notable change we made that improved our parser was leveraging <code>var</code> to occasionally side-step the cost of using <code>let</code> and <code>const</code> across closures.
This improved some of our parsing performance.</p>
<p>Overall, we expect most codebases should see speed improvements from TypeScript 5.0, and have consistently been able to reproduce wins between 10% to 20%.
Of course this will depend on hardware and codebase characteristics, but we encourage you to try it out on your codebase today!</p>
<p>For more information, see some of our notable optimizations:</p>
<ul>
<li><a href="https://github.com/microsoft/TypeScript/pull/51387">Migrate to Modules</a></li>
<li><a href="https://github.com/microsoft/TypeScript/pull/51682"><code>Node</code> Monomorphization</a></li>
<li><a href="https://github.com/microsoft/TypeScript/pull/51880"><code>Symbol</code> Monomorphization</a></li>
<li><a href="https://github.com/microsoft/TypeScript/pull/52170"><code>Identifier</code> Size Reduction</a></li>
<li><a href="https://github.com/microsoft/TypeScript/pull/52382"><code>Printer</code> Caching</a></li>
<li><a href="https://github.com/microsoft/TypeScript/issues/52924">Limited Usage of <code>var</code></a></li>
</ul>
<h2 id="breaking-changes-and-deprecations">Breaking Changes and Deprecations</h2>
<h3 id="runtime-requirements">Runtime Requirements</h3>
<p>TypeScript now targets ECMAScript 2018.
The TypeScript package has also set a minimum expected engine of 12.20.
For Node users, that means TypeScript 5.0 has a minimum version requirement of at least Node.js 12.20 and later.</p>
<h3 id="lib-d-ts-changes"><code>lib.d.ts</code> Changes</h3>
<p>Changes to how types for the DOM are generated might have an impact on existing code.
Notably, certain properties have been converted from <code>number</code> to numeric literal types, and properties and methods for cut, copy, and paste event handling have been moved across interfaces.</p>
<h3 id="api-breaking-changes">API Breaking Changes</h3>
<p>In TypeScript 5.0, <a href="https://devblogs.microsoft.com/typescript/typescripts-migration-to-modules/">we moved to modules</a>, removed some unnecessary interfaces, and made some correctness improvements.
For more details on what’s changed, see our <a href="https://github.com/microsoft/TypeScript/wiki/API-Breaking-Changes">API Breaking Changes</a> page.</p>
<h3 id="forbidden-implicit-coercions-in-relational-operators">Forbidden Implicit Coercions in Relational Operators</h3>
<p>Certain operations in TypeScript will already warn you if you write code which may cause an implicit string-to-number coercion:</p>
<pre><code><span>function</span><span> </span><span>func</span><span>(</span><span>ns</span><span>: </span><span>number</span><span> | </span><span>string</span><span>) {</span>
<span>  </span><span>return</span><span> </span><span>ns</span><span> * </span><span>4</span><span>; </span><span>// Error, possible implicit coercion</span>
<span>}</span>
</code></pre>
<p>In 5.0, this will also be applied to the relational operators <code>&gt;</code>, <code>&lt;</code>, <code>&lt;=</code>, and <code>&gt;=</code>:</p>
<pre><code><span>function</span><span> </span><span>func</span><span>(</span><span>ns</span><span>: </span><span>number</span><span> | </span><span>string</span><span>) {</span>
<span>  </span><span>return</span><span> </span><span>ns</span><span> &gt; </span><span>4</span><span>; </span><span>// Now also an error</span>
<span>}</span>
</code></pre>
<p>To allow this if desired, you can explicitly coerce the operand to a <code>number</code> using <code>+</code>:</p>
<pre><code><span>function</span><span> </span><span>func</span><span>(</span><span>ns</span><span>: </span><span>number</span><span> | </span><span>string</span><span>) {</span>
<span>  </span><span>return</span><span> +</span><span>ns</span><span> &gt; </span><span>4</span><span>; </span><span>// OK</span>
<span>}</span>
</code></pre>
<p>This <a href="https://github.com/microsoft/TypeScript/pull/52048">correctness improvement</a> was contributed courtesy of <a href="https://github.com/Andarist">Mateusz Burzyński</a>.</p>
<h3 id="enum-overhaul">Enum Overhaul</h3>
<p>TypeScript has had some long-standing oddities around <code>enum</code>s ever since its first release.
In 5.0, we’re cleaning up some of these problems, as well as reducing the concept count needed to understand the various kinds of <code>enum</code>s you can declare.</p>
<p>There are two main new errors you might see as part of this.
The first is that assigning an out-of-domain literal to an <code>enum</code> type will now error as one might expect:</p>
<pre><code><span>enum</span><span> </span><span>SomeEvenDigit</span><span> {</span>
<span>    </span><span>Zero</span><span> = </span><span>0</span><span>,</span>
<span>    </span><span>Two</span><span> = </span><span>2</span><span>,</span>
<span>    </span><span>Four</span><span> = </span><span>4</span>
<span>}</span>

<span>// Now correctly an error</span>
<span>let</span><span> </span><span>m</span><span>: </span><span>SomeEvenDigit</span><span> = </span><span>1</span><span>;</span>
</code></pre>
<p>The other is that enums with values declared with a mix of numbers and indirect string enum references would incorrectly create an all-number <code>enum</code>:</p>
<pre><code><span>enum</span><span> </span><span>Letters</span><span> {</span>
<span>    </span><span>A</span><span> = </span><span>&#34;a&#34;</span>
<span>}</span>
<span>enum</span><span> </span><span>Numbers</span><span> {</span>
<span>    </span><span>one</span><span> = </span><span>1</span><span>,</span>
<span>    </span><span>two</span><span> = </span><span>Letters</span><span>.</span><span>A</span>
<span>}</span>

<span>// Now correctly an error</span>
<span>const</span><span> </span><span>t</span><span>: </span><span>number</span><span> = </span><span>Numbers</span><span>.</span><span>two</span><span>;</span>
</code></pre>
<p>You can <a href="https://github.com/microsoft/TypeScript/pull/50528">see more details in relevant change</a>.</p>
<h3 id="more-accurate-type-checking-for-parameter-decorators-in-constructors-under-experimentaldecorators">More Accurate Type-Checking for Parameter Decorators in Constructors Under <code>--experimentalDecorators</code></h3>
<p>TypeScript 5.0 makes type-checking more accurate for decorators under <code>--experimentalDecorators</code>.
One place where this becomes apparent is when using a decorator on a constructor parameter.</p>
<pre><code><span>export</span><span> </span><span>declare</span><span> </span><span>const</span><span> </span><span>inject</span><span>:</span>
<span>  (</span><span>entity</span><span>: </span><span>any</span><span>) </span><span>=&gt;</span>
<span>    (</span><span>target</span><span>: </span><span>object</span><span>, </span><span>key</span><span>: </span><span>string</span><span> | </span><span>symbol</span><span>, </span><span>index</span><span>?: </span><span>number</span><span>) </span><span>=&gt;</span><span> </span><span>void</span><span>;</span>

<span>export</span><span> </span><span>class</span><span> </span><span>Foo</span><span> {}</span>

<span>export</span><span> </span><span>class</span><span> </span><span>C</span><span> {</span>
<span>    </span><span>constructor</span><span>(@</span><span>inject</span><span>(</span><span>Foo</span><span>) </span><span>private</span><span> </span><span>x</span><span>: </span><span>any</span><span>) {</span>
<span>    }</span>
<span>}</span>
</code></pre>
<p>This call will fail because <code>key</code> expects a <code>string | symbol</code>, but constructor parameters receive a key of <code>undefined</code>.
The correct fix is to change the type of <code>key</code> within <code>inject</code>.
A reasonable workaround if you’re using a library that can’t be upgraded is to wrap <code>inject</code> in a more type-safe decorator function, and use a type-assertion on <code>key</code>.</p>
<p>For more details, <a href="https://github.com/microsoft/TypeScript/issues/52435">see this issue</a>.</p>
<h3 id="deprecations-and-default-changes">Deprecations and Default Changes</h3>
<p>In TypeScript 5.0, we’ve deprecated the following settings and setting values:</p>
<ul>
<li><code>--target: ES3</code></li>
<li><code>--out</code></li>
<li><code>--noImplicitUseStrict</code></li>
<li><code>--keyofStringsOnly</code></li>
<li><code>--suppressExcessPropertyErrors</code></li>
<li><code>--suppressImplicitAnyIndexErrors</code></li>
<li><code>--noStrictGenericChecks</code></li>
<li><code>--charset</code></li>
<li><code>--importsNotUsedAsValues</code></li>
<li><code>--preserveValueImports</code></li>
<li><code>prepend</code> in project references</li>
</ul>
<p>These configurations will continue to be allowed until TypeScript 5.5, at which point they will be removed entirely, however, you will receive a warning if you are using these settings.
In TypeScript 5.0, as well as future releases 5.1, 5.2, 5.3, and 5.4, you can specify <code>&#34;ignoreDeprecations&#34;: &#34;5.0&#34;</code> to silence those warnings.
We’ll also shortly be releasing a 4.9 patch to allow specifying <code>ignoreDeprecations</code> to allow for smoother upgrades.
Aside from deprecations, we’ve changed some settings to better improve cross-platform behavior in TypeScript.</p>
<p><code>--newLine</code>, which controls the line endings emitted in JavaScript files, used to be inferred based on the current operating system if not specified.
We think builds should be as deterministic as possible, and Windows Notepad supports line-feed line endings now, so the new default setting is <code>LF</code>.
The old OS-specific inference behavior is no longer available.</p>
<p><code>--forceConsistentCasingInFileNames</code>, which ensured that all references to the same file name in a project agreed in casing, now defaults to <code>true</code>.
This can help catch differences issues with code written on case-insensitive file systems.</p>
<p>You can leave feedback and view more information on the <a href="https://github.com/microsoft/TypeScript/issues/51909">tracking issue for 5.0 deprecations</a></p>
<h2 id="whats-next">What’s Next?</h2>
<p>Not to get ahead of ourselves, but TypeScript 5.1 is already in the works, and <a href="https://github.com/microsoft/TypeScript/issues/53031">all our plans are already on GitHub</a>.
If you’re eager, we encourage you to <a href="https://www.typescriptlang.org/docs/handbook/nightly-builds.html">try out our nightly builds of TypeScript</a> or the <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-typescript-next">JavaScript and TypeScript Nightly extension for VS Code</a>!</p>
<p>Of course, we won’t be hurt if you choose to just enjoy the new stable version of TypeScript.
We hope TypeScript 5.0 makes coding faster and more fun for everyone.</p>
<p>Happy Hacking!</p>
<p>– Daniel Rosenwasser and the TypeScript Team</p>

        

		
        
	</div><!-- .entry-content -->

</div></div>
  </body>
</html>
