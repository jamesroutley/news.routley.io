<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://katafrakt.me/2022/12/25/ruby-extension-zig/">Original</a>
    <h1>I wrote a Ruby extension in Zig</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>I always had mixed feelings about writing native Ruby extensions. They surely are the way to make critical parts of the code run faster, but the developer experience around that was not great for a Ruby programmer like me. Sure, I know C. This was the second language I learned (after Pascal). I can write C, I can read C, and I even <a href="https://github.com/Shopify/bootsnap/pull/278">wrote some larger extensions</a> in it, but I never felt comfortable with it.</p>

<p>Other options were not great as well. I can use Rust, but I have never been on good terms with Rust. I have a story of rewriting part of our production code as Rust extension, which turned out to be 3-4 times faster, but we ditched it anyway, because maintenance cost would be too high, I might tell it some other time. I have experimented a lot with writing extensions in D, and I actually have a working setup for that. But D has its own garbage collector and rumour has it it’s not a good mix. D also has a <code>@nogc</code> mode, but it feels like giving up on 60% of the language’s power.</p>

<p>When Zig entered the scene, my hopes of finding another language with which I could write Ruby extensions got up again. But soon I found out it was not possible. Ruby uses many arcane C parts and its extensive usage of varargs, which was not supported by Zig’s C export, was a deal-breaker. Fortunately, a few weeks ago an issue I’ve been tracking for about 3 years was resolved. Zig now can export functions with variable arguments. So writing Ruby extensions in it should be possible.</p>

<p>I gave it a try.</p>

<h2 id="the-extension-test">The extension test</h2>

<p>What I did is a really simple implementation of <a href="https://rosettacode.org/wiki/100_doors">100 doors</a> problem from Rosetta Code. I took a Zig implementation from there (I’m not very fluent in Zig myself), altered it to take one argument (number of passes) and rewrote it in Ruby:</p>

<figure><pre><code data-lang="ruby"><span>def</span> <span>hundred_doors</span><span>(</span><span>passes</span><span>)</span>
  <span>doors</span> <span>=</span> <span>Array</span><span>.</span><span>new</span><span>(</span><span>101</span><span>,</span> <span>false</span><span>)</span>
  <span>passes</span><span>.</span><span>times</span> <span>do</span> <span>|</span><span>i</span><span>|</span>
    <span>i</span> <span>+=</span> <span>1</span>
    <span>(</span><span>i</span><span>..</span><span>100</span><span>).</span><span>step</span><span>(</span><span>i</span><span>)</span> <span>do</span> <span>|</span><span>d</span><span>|</span>
      <span>doors</span><span>[</span><span>d</span><span>]</span> <span>=</span> <span>!</span><span>doors</span><span>[</span><span>d</span><span>]</span>
    <span>end</span>
  <span>end</span>
  <span># dropping first one as it does not count</span>
  <span>doors</span><span>.</span><span>drop</span><span>(</span><span>1</span><span>).</span><span>count</span> <span>{</span><span>|</span><span>d</span><span>|</span> <span>d</span><span>}</span>
<span>end</span></code></pre></figure>

<p>After that I wrapped it in the Ruby extension code in Zig:</p>

<figure><pre><code data-lang="zig"><span>const</span> <span>std</span> <span>=</span> <span>@import</span><span>(</span><span>&#34;std&#34;</span><span>);</span>
<span>const</span> <span>ruby</span> <span>=</span> <span>@cImport</span><span>(</span><span>@cInclude</span><span>(</span><span>&#34;ruby/ruby.h&#34;</span><span>));</span>
<span>const</span> <span>testing</span> <span>=</span> <span>std</span><span>.</span><span>testing</span><span>;</span>

<span>// Calculate number of open doors after N passes</span>
<span>// Code taken from Rosetta Code: https://rosettacode.org/wiki/100_doors#Zig</span>
<span>fn</span> <span>hundred_doors</span><span>(</span><span>passes</span><span>:</span> <span>c_int</span><span>)</span> <span>c_int</span> <span>{</span>
    <span>var</span> <span>doors</span> <span>=</span> <span>[</span><span>_</span><span>]</span><span>bool</span><span>{</span><span>false</span><span>}</span> <span>**</span> <span>101</span><span>;</span>
    <span>var</span> <span>pass</span><span>:</span> <span>u8</span> <span>=</span> <span>1</span><span>;</span>
    <span>var</span> <span>door</span><span>:</span> <span>u8</span> <span>=</span> <span>undefined</span><span>;</span>
    
    <span>while</span> <span>(</span><span>pass</span> <span>&lt;=</span> <span>passes</span><span>)</span> <span>:</span> <span>(</span><span>pass</span> <span>+=</span> <span>1</span><span>)</span> <span>{</span>
        <span>door</span> <span>=</span> <span>pass</span><span>;</span>
        <span>while</span> <span>(</span><span>door</span> <span>&lt;=</span> <span>100</span><span>)</span> <span>:</span> <span>(</span><span>door</span> <span>+=</span> <span>pass</span><span>)</span>
            <span>doors</span><span>[</span><span>door</span><span>]</span> <span>=</span> <span>!</span><span>doors</span><span>[</span><span>door</span><span>];</span>
    <span>}</span>
    
    <span>var</span> <span>num_open</span><span>:</span> <span>u8</span> <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>doors</span><span>)</span> <span>|</span><span>open</span><span>|</span> <span>{</span>
        <span>if</span> <span>(</span><span>open</span><span>)</span> 
            <span>num_open</span> <span>+=</span> <span>1</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>num_open</span><span>;</span>
<span>}</span>

<span>// This is a wrapper for hundred_doors function to make it work with Ruby.</span>
<span>fn</span> <span>rb_hundred_doors</span><span>(</span><span>...</span><span>)</span> <span>callconv</span><span>(.</span><span>C</span><span>)</span> <span>ruby</span><span>.</span><span>VALUE</span> <span>{</span>
    <span>var</span> <span>ap</span> <span>=</span> <span>@cVaStart</span><span>();</span>
    <span>defer</span> <span>@cVaEnd</span><span>(</span><span>&amp;</span><span>ap</span><span>);</span>

    <span>// first argument is `self`, but we don&#39;t use it so we need to discard it</span>
    <span>var</span> <span>self</span> <span>=</span> <span>@cVaArg</span><span>(</span><span>&amp;</span><span>ap</span><span>,</span> <span>ruby</span><span>.</span><span>VALUE</span><span>);</span>
    <span>_</span> <span>=</span> <span>self</span><span>;</span>

    <span>// back and forth conversion from Ruby types to internal types + delegation to</span>
    <span>// actual `hundred_doors` function</span>
    <span>var</span> <span>passes</span> <span>=</span> <span>ruby</span><span>.</span><span>NUM2INT</span><span>(</span><span>@cVaArg</span><span>(</span><span>&amp;</span><span>ap</span><span>,</span> <span>ruby</span><span>.</span><span>VALUE</span><span>));</span>
    <span>return</span> <span>ruby</span><span>.</span><span>INT2NUM</span><span>(</span><span>hundred_doors</span><span>(</span><span>passes</span><span>));</span>
<span>}</span>

<span>export</span> <span>fn</span> <span>Init_libzig_rb</span><span>()</span> <span>void</span> <span>{</span>
    <span>ruby</span><span>.</span><span>ruby_init</span><span>();</span>
    <span>var</span> <span>zig_rb_class</span><span>:</span> <span>ruby</span><span>.</span><span>VALUE</span> <span>=</span> <span>ruby</span><span>.</span><span>rb_define_class</span><span>(</span><span>&#34;ZigRb&#34;</span><span>,</span> <span>ruby</span><span>.</span><span>rb_cObject</span><span>);</span>
    <span>_</span> <span>=</span> <span>ruby</span><span>.</span><span>rb_define_method</span><span>(</span><span>zig_rb_class</span><span>,</span> <span>&#34;hundred_doors&#34;</span><span>,</span> <span>rb_hundred_doors</span><span>,</span> <span>1</span><span>);</span>
<span>}</span></code></pre></figure>

<p>Finally, I ran a benchmark against both versions:</p>

<figure><pre><code data-lang="sh">Warming up <span>--------------------------------------</span>
                Ruby   845.000  i/100ms
                 Zig    13.953k i/100ms
Calculating <span>-------------------------------------</span>
                Ruby     11.776k <span>(</span>±20.6%<span>)</span> i/s -     56.615k <span>in   </span>5.050436s
                 Zig    233.684k <span>(</span>± 0.5%<span>)</span> i/s -      1.172M <span>in   </span>5.015707s

Comparison:
                 Zig:   233683.7 i/s
                Ruby:    11775.9 i/s - 19.84x  <span>(</span>± 0.00<span>)</span> slower</code></pre></figure>

<p>As you can see, in my case the Zig version was almost 20 times faster. The standard deviation also seems to be much lower, so the execution speed is more predictable. I tried that on a much older machine and then the difference wasn’t as big as this, but also significant (almost 6 times faster). But that’s not all. This code is compiled by Zig in debug mode. What would happen if I compiled it with the fastest possible option (<code>-Drelease-fast</code>)? Let’s take a look:</p>

<figure><pre><code data-lang="sh">Warming up <span>--------------------------------------</span>
                Ruby   958.000  i/100ms
                 Zig   172.842k i/100ms
Calculating <span>-------------------------------------</span>
                Ruby      9.475k <span>(</span>± 1.3%<span>)</span> i/s -     47.900k <span>in   </span>5.056247s
                 Zig      2.726M <span>(</span>± 7.0%<span>)</span> i/s -     13.655M <span>in   </span>5.039594s

Comparison:
                 Zig:  2725947.9 i/s
                Ruby:     9474.9 i/s - 287.70x  <span>(</span>± 0.00<span>)</span> slower</code></pre></figure>

<p>The zig version is <strong>almost 300 times faster</strong>! Of course, I suspect that, due to the fact that it is basically a simple computation in the loop, compiler did some serious magic on optimizing it and there is no chance on getting this kind of speedup in a real-life situation. But anyway, I plan to dig a little deeper into it, perhaps try it with some more realisting examples and see what I can get.</p>

<p>For starters though, I am really happy to see that it is at least possible to use Zig for it. We will see how it goes.</p>

<p>If you want to try out the example yourself, here is the complete code: <a href="https://github.com/katafrakt/zig-ruby">https://github.com/katafrakt/zig-ruby</a>. It likely only works on Linux, but I’d be happy to accept the PR for MacOS (I don’t think Windows support is feasible for now).</p>

  </div></div>
  </body>
</html>
