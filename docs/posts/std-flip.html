<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://morwenn.github.io//c&#43;&#43;/2025/09/25/TSB004-std-flip.html">Original</a>
    <h1>`std::flip`</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p><code>std::flip</code> is a little-known utility from the C++ standard library header <code>&lt;functional&gt;</code>:
it is a higher-order function that accepts a <a href="https://en.cppreference.com/w/cpp/named_req/Callable"><em>Callable</em></a> and returns an equivalent <em>Callable</em> with the order of its parameters reversed (or “flipped”).</p>

<p>To understand how it can be useful, let’s start with a simple example. Consider the following tree node class:</p>

<div><div><pre><code><span>struct</span> <span>node</span> <span>{</span>
    <span>int</span> <span>value</span><span>;</span>
    <span>node</span><span>*</span> <span>parent</span> <span>=</span> <span>nullptr</span><span>;</span>
    <span>node</span><span>*</span> <span>left_child</span> <span>=</span> <span>nullptr</span><span>;</span>
    <span>node</span><span>*</span> <span>right_child</span> <span>=</span> <span>nullptr</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<p>Let’s write a function that takes two nodes, and returns whether the first node is a parent of the second one, at any level of ancestry:</p>

<div><div><pre><code><span>bool</span> <span>is_ancestor_of</span><span>(</span><span>node</span> <span>const</span><span>*</span> <span>maybe_parent</span><span>,</span> <span>node</span> <span>const</span><span>*</span> <span>maybe_child</span><span>)</span>
<span>{</span>
    <span>if</span> <span>(</span><span>maybe_child</span> <span>==</span> <span>nullptr</span> <span>||</span> <span>maybe_parent</span> <span>==</span> <span>nullptr</span><span>)</span> <span>{</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>

    <span>while</span> <span>(</span><span>maybe_child</span><span>-&gt;</span><span>parent</span> <span>!=</span> <span>nullptr</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>maybe_child</span><span>-&gt;</span><span>parent</span> <span>==</span> <span>maybe_parent</span><span>)</span> <span>{</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span>
        <span>maybe_child</span> <span>=</span> <span>maybe_child</span><span>-&gt;</span><span>parent</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>false</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>This is basically walking up the tree from the child node as if it were a linked list.
The reverse operation either implies walking through two children nodes, or simply flipping the order of parameters, which is where <code>std::flip</code> intervenes:</p>

<div><div><pre><code><span>auto</span> <span>is_descendant_of</span> <span>=</span> <span>std</span><span>::</span><span>flip</span><span>(</span><span>is_ancestor_of</span><span>);</span>

<span>// This property should always hold</span>
<span>assert</span><span>(</span><span>is_descendant_of</span><span>(</span><span>node1</span><span>,</span> <span>node2</span><span>)</span> <span>==</span> <span>is_ancestor_of</span><span>(</span><span>node2</span><span>,</span> <span>node1</span><span>));</span>
</code></pre></div></div>

<h2 id="origins">Origins</h2>

<p><code>std::flip</code> finds its roots in functional programming, a domain in which it is extremely prevalent:</p>
<ul>
  <li>Haskell has <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#v:flip"><code>flip</code></a> in its Prelude module.</li>
  <li>PureScript has <a href="https://pursuit.purescript.org/packages/purescript-prelude/4.0.0/docs/Data.Function#v:flip"><code>flip</code></a> in its Prelude module.</li>
  <li>OCaml has <a href="https://ocaml.org/manual/5.3/api/Fun.html#VALflip"><code>flip</code></a> in the <code>Fun</code> module of its standard library.</li>
  <li>Idris has <a href="https://www.idris-lang.org/Idris2/prelude/docs/Prelude.Basics.html#Prelude.Basics.flip"><code>flip</code></a> in its Prelude module.</li>
  <li>Elm used to have <a href="https://package.elm-lang.org/packages/elm-lang/core/2.0.1/Basics#flip"><code>flip</code></a> in its <code>Basics</code> module. It got removed, but lots of polyfills still provide it.</li>
</ul>

<p>The LISP family of languages generally does not provide such a function by default, but the need is common enough that I have seen programmers online wonder how often it gets reimplemented manually.</p>

<p>Functional programming libraries in lots of other programming languages also generally oblige:</p>
<ul>
  <li>Boost.Hana has <a href="https://boostorg.github.io/hana/group__group-functional.html#ga004f884cdbb85c2efe3383c1db450094"><code>boost::hana::flip</code></a>.</li>
  <li>The C++ library <a href="https://github.com/Dobiasd/FunctionalPlus">FunctionalPlus</a> provides a <code>fplus::fwd::flip</code> namespace.</li>
  <li>The Python library Toolz has <a href="https://toolz.readthedocs.io/en/latest/api.html#toolz.functoolz.flip"><code>toolz.functoolz.flip</code></a>.</li>
  <li>The JavaScript library Ramda has <a href="https://ramdajs.com/docs/#flip"><code>flip</code></a>.</li>
  <li>The TypeScript library fp-ts has <a href="https://gcanti.github.io/fp-ts/modules/function.ts.html#flip"><code>flip</code></a> in its <code>function.ts</code> module.</li>
  <li>The C# framework LanguageExt has <a href="https://louthy.github.io/language-ext/LanguageExt.Core/Prelude/Function%20argument%20flipping/index.html"><code>flip</code></a> in its <code>Prelude</code> class.</li>
</ul>

<p>Interestingly enough, most of these implementations only flip the first two parameters of whichever function they are passed,
though it seems to be because most of them are based on the Haskell prelude, and handling arbitrary arity can be tricky in that language.
The existence of a module such as <a href="https://hackage.haskell.org/package/flippers-1.0.1/docs/Data-Function-Flippers.html"><code>Data.Function.Flippers</code></a>, which provides <code>flip3</code>, <code>flip4</code>, etc. functions up to nine parameters,
without providing a generic “flip all” function only makes that argument stronger.</p>

<p>Closer to C++, D has <a href="https://dlang.org/library/std/functional/reverse_args.html"><code>std.functional.reverseArgs</code></a> which reverses all parameters of the passed function.</p>

<h2 id="predicates">Predicates</h2>

<p>The most common use case for <code>std::flip</code> is certainly to flip the two arguments passed to a predicate, similar to what we did in the introduction example.
As a matter of fact, it fits right with the standard library’s ordering predicates,
allowing higher-order function transforms which mirror the tricks that have been used for decades to implement all relational operators on top of <code>operator&lt;</code>:</p>

<table>
  <thead>
    <tr>
      <th>Comparison</th>
      <th>Generic implementation</th>
      <th>Function object</th>
      <th>Predicate</th>
      <th>Higher-order</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>a &lt; b</code></td>
      <td><code>a &lt; b</code></td>
      <td><code>std::less</code></td>
      <td><code>pred(a, b)</code></td>
      <td><code>pred</code></td>
    </tr>
    <tr>
      <td><code>a &lt; b</code></td>
      <td><code>b &lt; a</code></td>
      <td><code>std::greater</code></td>
      <td><code>pred(b, a)</code></td>
      <td><code>std::flip(pred)</code></td>
    </tr>
    <tr>
      <td><code>a &lt;= b</code></td>
      <td><code>not (b &lt; a)</code></td>
      <td><code>std::less_equal</code></td>
      <td><code>not pred(b, a)</code></td>
      <td><code>std::not_fn(std::flip(pred))</code></td>
    </tr>
    <tr>
      <td><code>a &gt;= b</code></td>
      <td><code>not (a &lt; b)</code></td>
      <td><code>std::greater_equal</code></td>
      <td><code>not pred(a, b)</code></td>
      <td><code>std::not_fn(pred)</code></td>
    </tr>
  </tbody>
</table>

<p><em>Note: <a href="https://en.cppreference.com/w/cpp/utility/functional/not_fn.html"><code>std::not_fn</code></a> is another higher-order function from the <code>&lt;functional&gt;</code> header with a very similar design philosophy.
It accepts a Callable and returns a new Callable that performs the negation of the wrapped one when called.</em></p>

<h2 id="use-case-simple-generic-algorithms">Use case: simple generic algorithms</h2>

<p>Perhaps the simplest example of what <code>std::flip</code> brings to the table is the classic problem of sorting a collection in descending order according to a predicate:</p>

<div><div><pre><code><span>template</span><span>&lt;</span><span>typename</span> <span>Iterator</span><span>,</span> <span>typename</span> <span>Compare</span><span>&gt;</span>
<span>bool</span> <span>is_reverse_sorted</span><span>(</span><span>Iterator</span> <span>begin</span><span>,</span> <span>Iterator</span> <span>end</span><span>,</span> <span>Compare</span> <span>compare</span><span>)</span>
<span>{</span>
    <span>return</span> <span>std</span><span>::</span><span>is_sorted</span><span>(</span><span>begin</span><span>,</span> <span>end</span><span>,</span> <span>std</span><span>::</span><span>flip</span><span>(</span><span>compare</span><span>));</span>
<span>}</span>
</code></pre></div></div>

<p>Another fairly straightforward example is using it to reimplement <a href="https://en.cppreference.com/w/cpp/algorithm/upper_bound.html"><code>std::upper_bound</code></a> on top of <a href="https://en.cppreference.com/w/cpp/algorithm/lower_bound.html"><code>std::lower_bound</code></a>:</p>

<div><div><pre><code><span>template</span><span>&lt;</span><span>typename</span> <span>Iterator</span><span>,</span> <span>typename</span> <span>T</span><span>,</span> <span>typename</span> <span>Compare</span><span>&gt;</span>
<span>auto</span> <span>upper_bound</span><span>(</span><span>Iterator</span> <span>begin</span><span>,</span> <span>Iterator</span> <span>end</span><span>,</span> <span>T</span> <span>const</span><span>&amp;</span> <span>value</span><span>,</span> <span>Compare</span> <span>compare</span><span>)</span>
    <span>-&gt;</span> <span>Iterator</span>
<span>{</span>
    <span>return</span> <span>std</span><span>::</span><span>lower_bound</span><span>(</span>
        <span>begin</span><span>,</span> <span>end</span><span>,</span> <span>value</span><span>,</span>
        <span>std</span><span>::</span><span>not_fn</span><span>(</span><span>std</span><span>::</span><span>flip</span><span>(</span><span>compare</span><span>))</span>
    <span>);</span>
<span>}</span>
</code></pre></div></div>

<p>Interestingly enough, this implementation was not allowed in the original version of C++98 because <code>Compare</code> was required to satisfy the named requirement <a href="https://en.cppreference.com/w/cpp/named_req/Compare.html"><em>Compare</em></a>,
and <code>T</code> was required to satisfy <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable.html"><em>LessThanComparable</em></a>.
Both of those require that the comparison models a <a href="https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings">strict weak ordering</a>,
which the piece of code above cannot satisfy because it breaks the asymmetry property:</p>
<ul>
  <li>Asymmetry states that if <code>compare(a, b)</code> is <code>true</code>, then <code>compare(b, a)</code> is <code>false</code>.</li>
  <li>Assuming that <code>compare</code> satisfies this axiom, we can still have <code>not compare(b, a)</code> is <code>true</code> and <code>not compare(a, b)</code> is <code>true</code> when <code>a == b</code>.</li>
</ul>

<p>The strict weak ordering requirement was lifted by <a href="https://cplusplus.github.io/LWG/issue270">LWG270</a>, a defect report retroactively applied to C++98,
making the implementation above legal now that the two algorithms only require that the collection be partitioned according to the predicate.
However <a href="https://en.cppreference.com/w/cpp/algorithm/ranges/lower_bound.html"><code>std::ranges::lower_bound</code></a> and <a href="https://en.cppreference.com/w/cpp/algorithm/ranges/upper_bound.html"><code>std::ranges::upper_bound</code></a> reintroduced a strict weak ordering requirement via the <a href="https://en.cppreference.com/w/cpp/iterator/indirect_strict_weak_order.html"><code>std::indirect_strict_weak_order</code> concept</a>,
rendering them unable to use the same implementation trick.</p>

<h2 id="use-case-longest-subsequences">Use case: longest subsequences</h2>

<p>A more involved example where <code>std::flip</code> and <code>std::not_fn</code> make code reuse and composition shine is that of the <a href="https://en.wikipedia.org/wiki/Longest_increasing_subsequence">longest increasing subsequence</a> problem.
Quoting Wikipedia:</p>

<blockquote>
  <p>In computer science, the longest increasing subsequence problem aims to find a subsequence of a given sequence in which the subsequence’s elements are sorted in an ascending order and in which the subsequence is as long as possible.
This subsequence is not necessarily contiguous or unique.</p>
</blockquote>

<p>The original problem statement is about finding a subsequence of strictly increasing values, though there are use cases for finding sequences of non-decreasing values instead, or of decreasing values.
Here are two examples I encountered while working on my <a href="https://github.com/Morwenn/cpp-sort">cpp-sort</a> library</p>
<ul>
  <li><a href="https://github.com/Morwenn/cpp-sort/wiki/Measures-of-disorder#rem"><em>Rem</em></a> is a measure of presortedness that corresponds to the minimum number of elements to remove from a sequence to make it sorted. It is equal to the size of the sequence minus the size of its longest non-decreasing subsequence.</li>
  <li><a href="https://github.com/Morwenn/cpp-sort/wiki/Measures-of-disorder#sus"><em>SUS</em></a> is another measure of presortedness corresponding to the minimum number of non-decreasing subsequences into which a sequence can be partitioned. It happens to match the size of the longest decreasing subsequence.</li>
</ul>

<p>The following snippet of code uses <code>boost::algorithm::longest_increasing_subsequence</code> to compute the longest increasing subsequence,
a feature of Boost.Algorithm that only exists <a href="https://github.com/boostorg/algorithm/pull/7/files">in a seemingly abandoned pull request</a>,
then builds other flavours of the algorithm on top of it:</p>

<div><div><pre><code><span>template</span><span>&lt;</span><span>typename</span> <span>Iterator</span><span>,</span> <span>typename</span> <span>Compare</span><span>&gt;</span>
<span>auto</span> <span>longest_increasing_subsequence</span><span>(</span><span>Iterator</span> <span>begin</span><span>,</span> <span>Iterator</span> <span>end</span><span>,</span> <span>Compare</span> <span>compare</span><span>)</span>
<span>{</span>
    <span>boost</span><span>::</span><span>algorithm</span><span>::</span><span>longest_increasing_subsequence</span><span>&lt;</span><span>Iterator</span><span>,</span> <span>Compare</span><span>&gt;</span> <span>lis</span><span>(</span><span>compare</span><span>);</span>
    <span>return</span> <span>lis</span><span>(</span><span>begin</span><span>,</span> <span>end</span><span>,</span> <span>boost</span><span>::</span><span>algorithm</span><span>::</span><span>value_output_tag</span><span>{});</span>
<span>}</span>

<span>template</span><span>&lt;</span><span>typename</span> <span>Iterator</span><span>,</span> <span>typename</span> <span>Compare</span><span>&gt;</span>
<span>auto</span> <span>longest_decreasing_subsequence</span><span>(</span><span>Iterator</span> <span>begin</span><span>,</span> <span>Iterator</span> <span>end</span><span>,</span> <span>Compare</span> <span>compare</span><span>)</span>
<span>{</span>
    <span>return</span> <span>longest_increasing_subsequence</span><span>(</span><span>begin</span><span>,</span> <span>end</span><span>,</span> <span>std</span><span>::</span><span>flip</span><span>(</span><span>compare</span><span>));</span>
<span>}</span>

<span>template</span><span>&lt;</span><span>typename</span> <span>Iterator</span><span>,</span> <span>typename</span> <span>Compare</span><span>&gt;</span>
<span>auto</span> <span>longest_non_decreasing_subsequence</span><span>(</span><span>Iterator</span> <span>begin</span><span>,</span> <span>Iterator</span> <span>end</span><span>,</span> <span>Compare</span> <span>compare</span><span>)</span>
<span>{</span>
    <span>return</span> <span>longest_increasing_subsequence</span><span>(</span><span>begin</span><span>,</span> <span>end</span><span>,</span> <span>std</span><span>::</span><span>not_fn</span><span>(</span><span>std</span><span>::</span><span>flip</span><span>(</span><span>compare</span><span>)));</span>
<span>}</span>

<span>template</span><span>&lt;</span><span>typename</span> <span>Iterator</span><span>,</span> <span>typename</span> <span>Compare</span><span>&gt;</span>
<span>auto</span> <span>longest_non_increasing_subsequence</span><span>(</span><span>Iterator</span> <span>begin</span><span>,</span> <span>Iterator</span> <span>end</span><span>,</span> <span>Compare</span> <span>compare</span><span>)</span>
<span>{</span>
    <span>return</span> <span>longest_increasing_subsequence</span><span>(</span><span>begin</span><span>,</span> <span>end</span><span>,</span> <span>std</span><span>::</span><span>not_fn</span><span>(</span><span>compare</span><span>));</span>
<span>}</span>
</code></pre></div></div>

<p>Let’s consider the following sequence:</p><p>

\[\langle 1, 10, 2, 9, 2, 8, 8, 3, 7, 4, 5, 6, 6, 7, 5, 5, 8, 4, 9, 3, 9, 2, 10, 1 \rangle\]

</p><p>Using the functions above gives the following results (double-checking their correctness is left as an exercise to whoever has doubts):</p>
<ul>
  <li>LIS: \(\langle 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 \rangle\)</li>
  <li>LDS: \(\langle 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 \rangle\)</li>
  <li>LNDS: \(\langle 1, 2, 2, 3, 4, 5, 6, 6, 7, 8, 9, 9, 10 \rangle\)</li>
  <li>LNIS: \(\langle 10, 9, 8, 8, 7, 6, 6, 5, 5, 4, 3, 2, 1 \rangle\)</li>
</ul>

<p>This demonstrates that a combination of <code>std::flip</code> and <code>std::not_fn</code> constitutes a simple yet powerful tool to solve common computer science problems.</p>

<h2 id="use-case-folds">Use case: folds</h2>

<p>Predicates might be the most obvious use case for <code>std::flip</code>, but its applicability goes well beyond those:
it notably integrates nicely with <a href="https://en.wikipedia.org/wiki/Fold_(higher-order_function)">folds</a>, another staple of functional programming.</p>

<p>Let’s create a small collection of strings, and concatenate it with <a href="https://en.cppreference.com/w/cpp/algorithm/ranges/fold_left"><code>std::ranges::fold_left</code></a> over <a href="https://en.cppreference.com/w/cpp/utility/functional/plus_void.html"><code>std::plus</code></a>:</p>

<div><div><pre><code><span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>std</span><span>::</span><span>string</span><span>&gt;</span> <span>vec</span> <span>=</span> <span>{</span> <span>&#34;iteration &#34;</span><span>,</span> <span>&#34;from &#34;</span><span>,</span> <span>&#34;left &#34;</span><span>,</span> <span>&#34;is &#34;</span><span>,</span> <span>&#34;what &#34;</span><span>,</span> <span>&#34;is &#34;</span><span>,</span> <span>&#34;right &#34;</span><span>,</span> <span>&#34;with &#34;</span><span>,</span> <span>&#34;ranges &#34;</span> <span>};</span>
<span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>std</span><span>::</span><span>ranges</span><span>::</span><span>fold_left</span><span>(</span><span>vec</span><span>,</span> <span>std</span><span>::</span><span>plus</span><span>{});</span>
</code></pre></div></div>

<p>We obtain the following sentence:</p>

<div><div><pre><code>iteration from left is what is right with ranges
</code></pre></div></div>

<p>Using <code>std::ranges::fold_left(vec, std::flip(std::plus{}))</code>, we can concatenate all elements in reverse order:</p>

<div><div><pre><code>ranges with right is what is left from iteration
</code></pre></div></div>

<p>We can technically obtain the same results by left-folding <code>std::plus</code> over <a href="https://en.cppreference.com/w/cpp/ranges/reverse_view.html"><code>vec | std::views::reverse</code></a> with no additional cost.
However this reverse-based alternative stops working with containers such as <a href="https://en.cppreference.com/w/cpp/container/forward_list.html"><code>std::forward_list</code></a>,
or with input ranges, the like of which are increasingly common with streaming interfaces.</p>

<p>Interestingly enough, <code>std::flip</code> and <code>std::views::reverse</code> also compose, and can even be used together to reimplement <a href="https://en.cppreference.com/w/cpp/algorithm/ranges/fold_right"><code>std::ranges::fold_right</code></a> on top of <code>std::ranges::fold_left</code>:</p>

<div><div><pre><code><span>template</span><span>&lt;</span><span>typename</span> <span>Range</span><span>,</span> <span>typename</span> <span>T</span><span>,</span> <span>typename</span> <span>Func</span><span>&gt;</span>
<span>auto</span> <span>fold_right</span><span>(</span><span>Range</span><span>&amp;&amp;</span> <span>range</span><span>,</span> <span>T</span> <span>init</span><span>,</span> <span>Func</span> <span>func</span><span>)</span>
<span>{</span>
    <span>return</span> <span>std</span><span>::</span><span>ranges</span><span>::</span><span>fold_left</span><span>(</span>
        <span>std</span><span>::</span><span>forward</span><span>&lt;</span><span>Range</span><span>&gt;</span><span>(</span><span>range</span><span>)</span> <span>|</span> <span>std</span><span>::</span><span>views</span><span>::</span><span>reverse</span><span>,</span>
        <span>std</span><span>::</span><span>move</span><span>(</span><span>init</span><span>),</span>
        <span>std</span><span>::</span><span>flip</span><span>(</span><span>func</span><span>)</span>
    <span>);</span>
<span>}</span>
</code></pre></div></div>

<h2 id="use-case-inconsistent-apis">Use case: inconsistent APIs</h2>

<p>A more down-to-earth use case of <code>std::flip</code> is using it to glue together APIs that expose the same information in different orders.
A classic example of such an inconsistency is geodetic systems:</p>
<ul>
  <li>Some standards such as <a href="https://en.wikipedia.org/wiki/ISO_6709">ISO 6709</a> (Standard representation of geographic point location by coordinates) describe points as <em>(latitude, longitude)</em>.</li>
  <li>Others such as <a href="https://www.rfc-editor.org/rfc/rfc7946">RFC 7946</a> (GeoJSON) describes points as <em>(longitude, latitude)</em>.</li>
</ul>

<p>Both are industry standards at this point, which means that any API that deals with coordinates follows either one or the other.
The result is an ecosystem split between both orders. Libraries often provide <code>Point</code> abstractions, but functions accepting raw coordinate pairs are still prevalent.</p>

<p>It wouldn’t be surprising to find a map widget signaling the coordinates of a click through one of those systems,
then having to bind that signal to a function from another library, expecting coordinates in the opposite order.
In such a case, <code>std::flip</code> acts as simple glue:</p>

<div><div><pre><code><span>map_widget</span><span>.</span><span>on_click</span><span>.</span><span>connect</span><span>(</span><span>std</span><span>::</span><span>flip</span><span>(</span><span>handle_coordinates</span><span>));</span>
</code></pre></div></div>

<h2 id="afterword">Afterword</h2>

<p>The more astute among you probably always went to cppreference to double-check what is, indeed, a lie: <code>std::flip</code> <strong>does not exist</strong>, making this whole article a mere piece of fiction.
I hope you enjoyed the ride either way, and learnt to appreciate the power of simple functional features if it wasn’t already the case.</p>

<p>Fortunately it is not just useless knowledge either: <code>flip</code> can be reified at will by copying the following C++17 implementation.</p>

<div><div><pre><code><span>// Make an std::index_sequence in reverse order</span>

<span>template</span><span>&lt;</span><span>std</span><span>::</span><span>size_t</span> <span>Index</span><span>,</span> <span>std</span><span>::</span><span>size_t</span><span>...</span> <span>Indices</span><span>&gt;</span>
<span>struct</span> <span>make_reversed_index_sequence</span><span>:</span>
    <span>make_reversed_index_sequence</span><span>&lt;</span><span>Index</span> <span>-</span> <span>1</span><span>,</span> <span>Indices</span><span>...,</span> <span>Index</span> <span>-</span> <span>1</span><span>&gt;</span>
<span>{};</span>

<span>template</span><span>&lt;</span><span>std</span><span>::</span><span>size_t</span><span>...</span> <span>Indices</span><span>&gt;</span>
<span>struct</span> <span>make_reversed_index_sequence</span><span>&lt;</span><span>0</span><span>,</span> <span>Indices</span><span>...</span><span>&gt;:</span>
    <span>std</span><span>::</span><span>index_sequence</span><span>&lt;</span><span>Indices</span><span>...</span><span>&gt;</span>
<span>{};</span>

<span>// Type returned by flip</span>

<span>template</span><span>&lt;</span><span>typename</span> <span>F</span><span>&gt;</span>
<span>struct</span> <span>flip_t</span>
<span>{</span>
    <span>private:</span>
        <span>F</span> <span>func</span><span>;</span>

        <span>// Forward *this cv-ref and invert order of parameters</span>

        <span>template</span><span>&lt;</span><span>typename</span> <span>Self</span><span>,</span> <span>typename</span> <span>Tuple</span><span>,</span> <span>std</span><span>::</span><span>size_t</span><span>...</span> <span>Indices</span><span>&gt;</span>
        <span>static</span> <span>auto</span> <span>_call</span><span>(</span><span>Self</span><span>&amp;&amp;</span> <span>self</span><span>,</span> <span>Tuple</span><span>&amp;&amp;</span> <span>args</span><span>,</span> <span>std</span><span>::</span><span>index_sequence</span><span>&lt;</span><span>Indices</span><span>...</span><span>&gt;</span><span>)</span>
            <span>-&gt;</span> <span>decltype</span><span>(</span><span>std</span><span>::</span><span>invoke</span><span>(</span>
                <span>std</span><span>::</span><span>forward</span><span>&lt;</span><span>Self</span><span>&gt;</span><span>(</span><span>self</span><span>).</span><span>func</span><span>,</span>
                <span>std</span><span>::</span><span>get</span><span>&lt;</span><span>Indices</span><span>&gt;</span><span>(</span><span>std</span><span>::</span><span>forward</span><span>&lt;</span><span>Tuple</span><span>&gt;</span><span>(</span><span>args</span><span>))...</span>
            <span>))</span>
        <span>{</span>
            <span>return</span> <span>std</span><span>::</span><span>invoke</span><span>(</span>
                <span>std</span><span>::</span><span>forward</span><span>&lt;</span><span>Self</span><span>&gt;</span><span>(</span><span>self</span><span>).</span><span>func</span><span>,</span>
                <span>std</span><span>::</span><span>get</span><span>&lt;</span><span>Indices</span><span>&gt;</span><span>(</span><span>std</span><span>::</span><span>forward</span><span>&lt;</span><span>Tuple</span><span>&gt;</span><span>(</span><span>args</span><span>))...</span>
            <span>);</span>
        <span>}</span>

        <span>template</span><span>&lt;</span><span>typename</span> <span>Self</span><span>,</span> <span>typename</span> <span>Tuple</span><span>&gt;</span>
        <span>static</span> <span>auto</span> <span>_call</span><span>(</span><span>Self</span><span>&amp;&amp;</span> <span>self</span><span>,</span> <span>Tuple</span><span>&amp;&amp;</span> <span>args</span><span>)</span>
            <span>-&gt;</span> <span>decltype</span><span>(</span><span>_call</span><span>(</span>
                <span>std</span><span>::</span><span>forward</span><span>&lt;</span><span>Self</span><span>&gt;</span><span>(</span><span>self</span><span>),</span>
                <span>std</span><span>::</span><span>forward</span><span>&lt;</span><span>Tuple</span><span>&gt;</span><span>(</span><span>args</span><span>),</span>
                <span>make_reversed_index_sequence</span><span>&lt;</span><span>std</span><span>::</span><span>tuple_size_v</span><span>&lt;</span><span>Tuple</span><span>&gt;&gt;</span><span>{}</span>
            <span>))</span>
        <span>{</span>
            <span>return</span> <span>_call</span><span>(</span>
                <span>std</span><span>::</span><span>forward</span><span>&lt;</span><span>Self</span><span>&gt;</span><span>(</span><span>self</span><span>),</span>
                <span>std</span><span>::</span><span>forward</span><span>&lt;</span><span>Tuple</span><span>&gt;</span><span>(</span><span>args</span><span>),</span>
                <span>make_reversed_index_sequence</span><span>&lt;</span><span>std</span><span>::</span><span>tuple_size_v</span><span>&lt;</span><span>Tuple</span><span>&gt;&gt;</span><span>{}</span>
            <span>);</span>
        <span>}</span>

    <span>public:</span>
        <span>// Construction</span>

        <span>flip_t</span><span>()</span> <span>=</span> <span>default</span><span>;</span>

        <span>explicit</span> <span>constexpr</span> <span>flip_t</span><span>(</span><span>F</span><span>&amp;&amp;</span> <span>func</span><span>)</span><span>:</span>
            <span>func</span><span>(</span><span>std</span><span>::</span><span>move</span><span>(</span><span>func</span><span>))</span>
        <span>{}</span>

        <span>// Call</span>

        <span>template</span><span>&lt;</span><span>typename</span><span>...</span> <span>Args</span><span>&gt;</span>
        <span>constexpr</span> <span>auto</span> <span>operator</span><span>()(</span><span>Args</span><span>&amp;&amp;</span><span>...</span> <span>args</span><span>)</span> <span>&amp;</span>
            <span>-&gt;</span> <span>decltype</span><span>(</span><span>_call</span><span>(</span><span>*</span><span>this</span><span>,</span> <span>std</span><span>::</span><span>forward_as_tuple</span><span>(</span><span>std</span><span>::</span><span>forward</span><span>&lt;</span><span>Args</span><span>&gt;</span><span>(</span><span>args</span><span>)...)))</span>
        <span>{</span>
            <span>return</span> <span>_call</span><span>(</span><span>*</span><span>this</span><span>,</span> <span>std</span><span>::</span><span>forward_as_tuple</span><span>(</span><span>std</span><span>::</span><span>forward</span><span>&lt;</span><span>Args</span><span>&gt;</span><span>(</span><span>args</span><span>)...));</span>
        <span>}</span>

        <span>template</span><span>&lt;</span><span>typename</span><span>...</span> <span>Args</span><span>&gt;</span>
        <span>constexpr</span> <span>auto</span> <span>operator</span><span>()(</span><span>Args</span><span>&amp;&amp;</span><span>...</span> <span>args</span><span>)</span> <span>const</span><span>&amp;</span>
            <span>-&gt;</span> <span>decltype</span><span>(</span><span>_call</span><span>(</span><span>*</span><span>this</span><span>,</span> <span>std</span><span>::</span><span>forward_as_tuple</span><span>(</span><span>std</span><span>::</span><span>forward</span><span>&lt;</span><span>Args</span><span>&gt;</span><span>(</span><span>args</span><span>)...)))</span>
        <span>{</span>
            <span>return</span> <span>_call</span><span>(</span><span>*</span><span>this</span><span>,</span> <span>std</span><span>::</span><span>forward_as_tuple</span><span>(</span><span>std</span><span>::</span><span>forward</span><span>&lt;</span><span>Args</span><span>&gt;</span><span>(</span><span>args</span><span>)...));</span>
        <span>}</span>

        <span>template</span><span>&lt;</span><span>typename</span><span>...</span> <span>Args</span><span>&gt;</span>
        <span>constexpr</span> <span>auto</span> <span>operator</span><span>()(</span><span>Args</span><span>&amp;&amp;</span><span>...</span> <span>args</span><span>)</span> <span>&amp;&amp;</span>
            <span>-&gt;</span> <span>decltype</span><span>(</span><span>_call</span><span>(</span><span>*</span><span>this</span><span>,</span> <span>std</span><span>::</span><span>forward_as_tuple</span><span>(</span><span>std</span><span>::</span><span>forward</span><span>&lt;</span><span>Args</span><span>&gt;</span><span>(</span><span>args</span><span>)...)))</span>
        <span>{</span>
            <span>return</span> <span>_call</span><span>(</span><span>*</span><span>this</span><span>,</span> <span>std</span><span>::</span><span>forward_as_tuple</span><span>(</span><span>std</span><span>::</span><span>forward</span><span>&lt;</span><span>Args</span><span>&gt;</span><span>(</span><span>args</span><span>)...));</span>
        <span>}</span>

        <span>template</span><span>&lt;</span><span>typename</span><span>...</span> <span>Args</span><span>&gt;</span>
        <span>constexpr</span> <span>auto</span> <span>operator</span><span>()(</span><span>Args</span><span>&amp;&amp;</span><span>...</span> <span>args</span><span>)</span> <span>const</span><span>&amp;&amp;</span>
            <span>-&gt;</span> <span>decltype</span><span>(</span><span>_call</span><span>(</span><span>*</span><span>this</span><span>,</span> <span>std</span><span>::</span><span>forward_as_tuple</span><span>(</span><span>std</span><span>::</span><span>forward</span><span>&lt;</span><span>Args</span><span>&gt;</span><span>(</span><span>args</span><span>)...)))</span>
        <span>{</span>
            <span>return</span> <span>_call</span><span>(</span><span>*</span><span>this</span><span>,</span> <span>std</span><span>::</span><span>forward_as_tuple</span><span>(</span><span>std</span><span>::</span><span>forward</span><span>&lt;</span><span>Args</span><span>&gt;</span><span>(</span><span>args</span><span>)...));</span>
        <span>}</span>

        <span>// Accessor</span>

        <span>[[</span><span>nodiscard</span><span>]]</span>
        <span>constexpr</span> <span>auto</span> <span>base</span><span>()</span> <span>const</span>
            <span>-&gt;</span> <span>F</span>
        <span>{</span>
            <span>return</span> <span>func</span><span>;</span>
        <span>}</span>
<span>};</span>

<span>// flip</span>

<span>template</span><span>&lt;</span><span>typename</span> <span>F</span><span>&gt;</span>
<span>constexpr</span> <span>auto</span> <span>flip</span><span>(</span><span>F</span> <span>func</span><span>)</span>
    <span>-&gt;</span> <span>flip_t</span><span>&lt;</span><span>F</span><span>&gt;</span>
<span>{</span>
    <span>return</span> <span>flip_t</span><span>&lt;</span><span>F</span><span>&gt;</span><span>(</span><span>std</span><span>::</span><span>move</span><span>(</span><span>func</span><span>));</span>
<span>}</span>

<span>template</span><span>&lt;</span><span>typename</span> <span>F</span><span>&gt;</span>
<span>constexpr</span> <span>auto</span> <span>flip</span><span>(</span><span>flip_t</span><span>&lt;</span><span>F</span><span>&gt;</span> <span>flipped_func</span><span>)</span>
    <span>-&gt;</span> <span>F</span>
<span>{</span>
    <span>return</span> <span>flipped_func</span><span>.</span><span>base</span><span>();</span>
<span>}</span>

</code></pre></div></div>

<p><em>Note: the <code>flip</code> implementation above is provided under Creative Commons <a href="https://creativecommons.org/public-domain/cc0/">CC0 license</a>.</em></p>


  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
