<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://corrode.dev/blog/rust-option-handling-best-practices/">Original</a>
    <h1>Don&#39;t unwrap options: There are better ways (2024)</h1>
    
    <div id="readability-page-1" class="page"><div>
    
    <div>
    

      <p>I noticed that handling the <code>None</code> variant of <code>Option</code> without falling back on <code>unwrap()</code> is a common papercut in Rust.
More specifically, the problem arises when you want to return early from a function that returns a <code>Result</code> if you encounter <code>None</code>.</p>
<p>It has been discussed a million times already, but, surprisingly, not even the Rust book mentions my favorite approach to handling that, and many forum posts are outdated.</p>
<p>With a bit of practice, robust handling of <code>None</code> can become as easy as <code>unwrap()</code>, but safer.</p>
<p>Jump to the end if you’re in a hurry and just need a quick recommendation.</p>
<h2 id="the-problem"><a href="#the-problem" aria-label="Anchor link for: the-problem">The Problem</a></h2>
<p>Very commonly, people write code like this:</p>
<pre data-lang="rust"><code data-lang="rust"><span></span><span><span><span><span>fn</span> </span><span>get_user</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span><span>Option</span><span>&lt;</span><span>String</span><span>&gt;</span></span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>None</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span><span>fn</span> </span><span>get_user_name</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span><span>Result</span><span>&lt;</span><span>String</span><span>&gt;</span></span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>let</span> user <span>=</span> <span>get_user</span><span><span>(</span></span><span><span>)</span></span><span>?</span><span>;</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>Ok</span><span><span>(</span>user</span><span><span>)</span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>The goal here is to return early if you encounter <code>None</code> in an <code>Option</code>, so
they use the <code>?</code> operator to propagate errors.</p>
<p>Alas, this code doesn’t compile. Instead, you get a dreaded error message:</p>
<pre data-lang="rust"><code data-lang="rust"><span>error<span><span>[</span><span>E0277</span><span>]</span></span><span>:</span> the `<span>?</span>` operator can only be used on `<span>Result</span>`s<span>,</span> not `<span>Option</span>`s<span>,</span> <span>in</span> a function that returns `<span>Result</span>`
</span><span>  <span>-</span><span><span>-&gt;</span> src</span><span>/</span>lib<span>.</span>rs<span>:</span><span>10</span><span>:</span><span>26</span>
</span><span>   <span>|</span>
</span><span><span>9</span>  <span>|</span> <span><span><span>fn</span> </span><span>get_user_name</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span><span>Result</span><span>&lt;</span><span>String</span><span>&gt;</span></span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>   <span>|</span> <span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span> this function returns a `<span>Result</span>`
</span></span></span><span><span><span><span>10</span> <span>|</span>     <span>let</span> user <span>=</span> <span>get_user</span><span><span>(</span></span><span><span>)</span></span><span>?</span><span>;</span>
</span></span></span><span><span><span>   <span><span><span>|</span></span></span><span><span>                          ^ use `.ok_or<span><span>(</span></span><span>...</span><span><span>)</span></span>?` to provide an error compatible with `std::result::Result&lt;<span>String</span><span>,</span> Box&lt;dyn std::error::Error&gt;&gt;`</span>
</span></span></span></span><span><span><span><span>   </span><span><span>|</span></span>
</span></span></span><span><span><span>   <span>=</span> help<span>:</span> the <span>trait</span> `<span>FromResidual<span>&lt;</span><span><span>Option</span><span>&lt;</span>Infallible<span>&gt;</span></span><span>&gt;</span></span>` is not implemented <span>for</span> `<span>std<span>::</span></span><span>result<span>::</span></span>Result<span><span>&lt;</span><span>String</span>, <span><span>Box</span><span>&lt;</span>dyn <span>std<span>::</span></span><span>error<span>::</span></span>Error<span>&gt;</span></span><span>&gt;</span></span>`
</span></span></span><span><span><span>   <span>=</span> help<span>:</span> the following other types implement <span>trait</span> `<span>FromResidual<span>&lt;</span>R<span>&gt;</span></span>`<span>:</span>
</span></span></span><span><span><span>             <span><span>&lt;</span><span>std<span>::</span></span><span>result<span>::</span></span><span><span>Result</span><span>&lt;</span>T, F<span>&gt;</span></span> <span>as</span> <span>FromResidual<span>&lt;</span><span>Yeet<span>&lt;</span>E<span>&gt;</span></span><span>&gt;</span></span><span>&gt;</span></span>
</span></span></span><span><span><span>             <span>&lt;</span><span>std<span>::</span></span><span>result<span>::</span></span>Result<span><span>&lt;</span>T, F<span>&gt;</span></span> <span>as</span> <span>FromResidual<span>&lt;</span><span>std<span>::</span></span><span>result<span>::</span></span><span><span>Result</span><span>&lt;</span>Infallible, E<span>&gt;</span></span><span>&gt;</span></span><span>&gt;</span>
</span></span></span></code></pre>
<p>(<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=7001ff6af6c0bcbf44249691d65b086f">Rust Playground</a>)</p>
<p>Ouch. This is scary-looking!</p>
<p>There’s a lot of visual noise in this error message. The <code>FromResidual</code> and <code>Yeet</code> are implementation details which could be confusing to a new user, and the relevant details are somewhat obscured.</p>
<p><strong>And all we did was try to use the <code>?</code> operator for our <code>Option</code>.</strong></p>
<p>My main gripe with this error message is that it doesn’t explain <em>why</em> the <code>?</code> operator doesn’t work with <code>Option</code> in that case… just that it doesn’t.</p>
<h2 id="what-people-end-up-doing"><a href="#what-people-end-up-doing" aria-label="Anchor link for: what-people-end-up-doing">What People End Up Doing</a></h2>
<p>The most common approach I see is this:</p>
<ul>
<li>People are confused for a bit.</li>
<li>They try to understand the error message.</li>
<li>Eventually, they give up and just add <code>unwrap()</code>.</li>
<li>They make a mental note to come back to it later.</li>
<li>‘Later’ never comes.</li>
</ul>
<p>Here’s what they end up with:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>get_user_name</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span><span>Result</span><span>&lt;</span><span>String</span>, <span>String</span><span>&gt;</span></span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>let</span> user <span>=</span> <span>get_user</span><span><span>(</span></span><span><span>)</span></span><span>.</span><span>unwrap</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>Ok</span><span><span>(</span>user</span><span><span>)</span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>In trainings, I noticed that people are often too embarrassed to ask for help.
They think people are supposed to <em>“get this”</em> and they are the only ones who don’t.</p>
<p>This just defers the problem.
The user of the function might hit a <code>panic</code> at runtime. That user might be their future self.</p>
<p><code>unwrap</code> is fine in many cases, but it shouldn’t be the first intuition for dealing with unexpected situations.
Especially when you’re writing a library or a function that is part of a larger codebase, you should strive to handle
such situations gracefully.
And in production code, it sets a bad example:
one <code>unwrap</code> attracts another and the codebase becomes more fragile as you continue down this path. </p>
<p>Okay, I’ve kept you waiting long enough. Let’s demystify this error message.</p>
<h2 id="the-actual-problem"><a href="#the-actual-problem" aria-label="Anchor link for: the-actual-problem">The Actual Problem</a></h2>
<p>What the compiler is trying to tell us is that <strong>you can’t propagate optionals within functions which return <code>Result</code></strong>.</p>
<p>Everything works just fine if you’re returning an <code>Option</code> instead:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>get_user_name</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span><span>Option</span><span>&lt;</span><span>String</span><span>&gt;</span></span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>let</span> user <span>=</span> <span>get_user</span><span><span>(</span></span><span><span>)</span></span><span>?</span><span>;</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>Some</span><span><span>(</span>user</span><span><span>)</span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>So if you can change the outer function to return an <code>Option</code> instead, you won’t run into the above error message.
There’s more info in the Rust documentation <a href="https://doc.rust-lang.org/std/option/index.html#the-question-mark-operator-">here</a>.</p>
<p>But what if the final return type of your function has to be a <code>Result</code>
or if you want to convey more information about the missing value to the caller?
After all, communicating the distinction between different <code>None</code> values can be helpful to the user of your function.</p>
<p>So, what if you <em>really</em> want your code to look like this?</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>get_user_name</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span><span>Result</span><span>&lt;</span><span>String</span>, <span>String</span><span>&gt;</span></span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>let</span> user <span>=</span> <span>get_user</span><span><span>(</span></span><span><span>)</span></span><span>?</span><span>;</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>Ok</span><span><span>(</span>user</span><span><span>)</span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>Well, that’s just a type error: <code>get_user()</code> returns an <code>Option</code>, but the outer function expects a <code>Result</code>.</p>
<p>Our problem statement becomes easier:</p>
<p>Turns out, there are multiple solutions!</p>
<h2 id="solution-1-change-the-return-type"><a href="#solution-1-change-the-return-type" aria-label="Anchor link for: solution-1-change-the-return-type">Solution 1: change the return type</a></h2>
<p>If “not having a value” is truly an error condition in your program’s logic, you should use <code>Result</code> instead of <code>Option</code>. <code>Option</code> is best used when the absence of a value is a normal, expected possibility, not an error state.</p>
<p>In our case, if you can change <code>get_user()</code> to return a <code>Result</code> instead of an <code>Option</code>, you can use the <code>?</code> operator as you intended:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>get_user</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span><span>Result</span><span>&lt;</span><span>String</span>, <span>String</span><span>&gt;</span></span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>Ok</span><span><span>(</span><span><span>&#34;</span>Alice<span>&#34;</span></span><span>.</span><span>to_string</span><span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span><span>fn</span> </span><span>get_user_name</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span><span>Result</span><span>&lt;</span><span>String</span>, <span>String</span><span>&gt;</span></span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>let</span> user <span>=</span> <span>get_user</span><span><span>(</span></span><span><span>)</span></span><span>?</span><span>;</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>Ok</span><span><span>(</span>user</span><span><span>)</span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>However, you might not be able to change <code>get_user()</code> to return a <code>Result</code> for various reasons,
for example, if it’s part of a library or if it’s used in many places
or if other callers don’t treat the absence of a user as an error.</p>
<p>In that case, read on!</p>
<h2 id="solution-2-ok-or"><a href="#solution-2-ok-or" aria-label="Anchor link for: solution-2-ok-or">Solution 2: <code>ok_or</code></a></h2>
<p>The initial error message, while cryptic, gave us a hint:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>use</span> `<span>.</span><span>ok_or</span><span><span>(</span><span>...</span></span><span><span>)</span></span><span>?</span>` to provide an error compatible with `<span><span>Result</span><span>&lt;</span><span>(</span><span>)</span>, <span><span>Box</span><span>&lt;</span>dyn <span>std<span>::</span></span><span>error<span>::</span></span>Error<span>&gt;</span></span><span>&gt;</span></span>`<span>.</span>
</span></code></pre>
<p>Apparently we can use the <code>ok_or</code> method, which converts the <code>Option</code> into a <code>Result</code>:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> user <span>=</span> <span>get_user</span><span><span>(</span></span><span><span>)</span></span><span>.</span><span>ok_or</span><span><span>(</span><span><span>&#34;</span>No user<span>&#34;</span></span></span><span><span>)</span></span><span>?</span><span>;</span>
</span></code></pre>
<p>That’s convenient! It also chains well when we use iterator patterns:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> user <span>=</span> <span>get_user</span><span><span>(</span></span><span><span>)</span></span>
</span><span>    <span>.</span><span>ok_or</span><span><span>(</span><span><span>&#34;</span>No user<span>&#34;</span></span></span><span><span>)</span></span><span>?</span>
</span><span>    <span>.</span><span>do_something</span><span><span>(</span></span><span><span>)</span></span>
</span><span>    <span>.</span><span>ok_or</span><span><span>(</span><span><span>&#34;</span>Something went wrong<span>&#34;</span></span></span><span><span>)</span></span><span>?</span><span>;</span>
</span></code></pre>
<p>(<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=c3053fe0b08b3157d377d3dce68d9e00">Playground</a></p>
<p><code>ok_or</code> is also great if you can recover from <code>None</code> and handle that case gracefully:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> user <span>=</span> <span>get_user</span><span><span>(</span></span><span><span>)</span></span><span>.</span><span>ok_or</span><span><span>(</span><span>get_logged_in_username</span><span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span><span>?</span><span>;</span>
</span></code></pre>
<p>These are good use cases for <code>ok_or</code>.</p>
<p>On the other side, it might not be immediately obvious to everyone what <code>ok_or</code> does.
I find the name <code>ok_or</code> unintuitive and needed to look it up many times.
That’s because <code>Ok</code> is commonly associated with the <code>Result</code> type, not <code>Option</code>.
There’s <code>Option::Some</code>, so it could have been called <code>some_or</code>, which was <a href="https://github.com/rust-lang/rust/pull/17469#issuecomment-56919911">actually suggested in 2014</a>, but the name <code>ok_or</code> won out,
because <code>ok_or(MyError)</code> reads nicely and I can see why. Guess we have to live with the minor inconsistency now.</p>
<p>I think <code>ok_or</code> is a quick solution to the problem, but there are alternatives that might be more readable.</p>
<h2 id="solution-3-match"><a href="#solution-3-match" aria-label="Anchor link for: solution-3-match">Solution 3: <code>match</code></a></h2>
<p>In the past, I used to recommend people to not be clever and just use a <code>match</code> statement.</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> user <span>=</span> <span>match</span> <span>get_user</span><span><span>(</span></span><span><span>)</span></span> <span><span>{</span>
</span></span><span><span>    <span>Some</span><span><span>(</span>user</span><span><span>)</span></span> <span>=&gt;</span> user<span>,</span>
</span></span><span><span>    <span>None</span> <span>=&gt;</span> <span>return</span> <span>Err</span><span><span>(</span><span><span>&#34;</span>No user<span>&#34;</span></span><span>.</span><span>into</span><span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span><span>,</span>
</span></span><span><span></span><span><span>}</span></span><span>;</span>
</span></code></pre>
<p><code>match</code> works in combination with <code>Option</code>, because it’s just an enum and we can pattern match on it.
As long as we cover all cases, the compiler is happy. In this situation, we only have two cases: <code>Some</code> and <code>None</code>.
In the <code>None</code> case, we return early with an error. In the <code>Some</code> case, we continue with the value.
(<code>match</code> is an expression and the value of the last expression in the block is returned. In our case it’s <code>user</code> and it
gets assigned to the <code>user</code> variable in the outer scope.)</p>
<p>This is already more explicit and easier to understand for beginners.
The one issue I had when teaching this was that it looked a bit more verbose for simple cases.</p>
<h2 id="solution-4-let-else"><a href="#solution-4-let-else" aria-label="Anchor link for: solution-4-let-else">Solution 4: <code>let-else</code></a></h2>
<p>With Rust 1.65, <a href="https://blog.rust-lang.org/2022/11/03/Rust-1.65.0.html#let-else-statements">the <code>let-else</code> expression was stabilized</a>, so now you can write this:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> <span>Some</span><span><span>(</span>user</span><span><span>)</span></span> <span>=</span> <span>get_user</span><span><span>(</span></span><span><span>)</span></span> <span>else</span> <span><span>{</span>
</span></span><span><span>    <span>return</span> <span>Err</span><span><span>(</span><span><span>&#34;</span>No user<span>&#34;</span></span><span>.</span><span>into</span><span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span><span>;</span>
</span></span><span><span></span><span><span>}</span></span><span>;</span>
</span><span>
</span><span></span></code></pre>
<p>In my opinion, that’s the best of both worlds: it’s compact while still being easy to understand.
It’s unanimously loved by beginners and experienced Rustaceans alike.</p>
<p>For some explanation: if <code>get_user()</code> returns <code>Some</code>, the <code>let</code> statement will destructure the <code>Some</code> variant and assign the value to the <code>user</code> variable. If <code>get_user()</code> returns <code>None</code>, the <code>else</code> block will be executed and we return early with an error.</p>
<p><strong>My favorite thing about <code>let-else</code> is that it clearly highlights the ‘happy path’ of your code.</strong></p>
<p>Unlike a <code>match</code> statement where you need to read both arms to understand the intended flow, <code>let-else</code> makes it immediately clear what the expected case is, with the <code>else</code> block handling the exceptional case.</p>
<p>This is a clear winner.
It is way more intuitive for beginners; once they understand the pattern, they use it all the time!</p>
<h2 id="bonus-anyhow"><a href="#bonus-anyhow" aria-label="Anchor link for: bonus-anyhow">Bonus: <code>anyhow</code></a></h2>
<p>I wanted to add one honorable mention here.</p>
<p>If you’re writing an application (not a library) and you’re using the
<a href="https://github.com/dtolnay/anyhow"><code>anyhow</code></a> crate already, you can also use their <code>context</code>
method to handle <code>None</code>:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>use</span> <span>anyhow<span>::</span></span><span><span>{</span>Context<span>,</span> <span>Result</span></span><span><span>}</span></span><span>;</span>
</span><span>
</span><span><span><span><span>fn</span> </span><span>get_user_name</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span><span>Result</span><span>&lt;</span><span>String</span><span>&gt;</span></span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>let</span> user <span>=</span> <span>get_user</span><span><span>(</span></span><span><span>)</span></span><span>.</span><span>context</span><span><span>(</span><span><span>&#34;</span>No user<span>&#34;</span></span></span><span><span>)</span></span><span>?</span><span>;</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>Ok</span><span><span>(</span>user</span><span><span>)</span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>It’s slightly less verbose than <code>let-else</code>, which makes it appealing.
Just remember that <code>anyhow</code> is an external dependency.
It’s probably fine for applications, but you might not want to use it in a library as users of
your library can no longer match on the concrete error variant then.</p>
<p>That’s why I believe that <code>let-else</code> is the best solution for handling <code>None</code> in most cases.</p>
<ul>
<li>It’s part of the standard library.</li>
<li>It’s easy to understand for beginners.</li>
<li>Learning the mechanics behind it is helpful in other places as well.</li>
<li>It’s reasonably compact.</li>
<li>It allows for more complex error handling logic in the <code>else</code> block if needed.</li>
</ul>
<h2 id="conclusion"><a href="#conclusion" aria-label="Anchor link for: conclusion">Conclusion</a></h2>
<p>For most cases, I prefer this syntax:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> <span>Some</span><span><span>(</span>value</span><span><span>)</span></span> <span>=</span> <span>some_function</span><span><span>(</span></span><span><span>)</span></span> <span>else</span> <span><span>{</span>
</span></span><span><span>    <span>return</span> <span>Err</span><span><span>(</span><span><span>&#34;</span>Descriptive error message<span>&#34;</span></span><span>.</span><span>into</span><span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span><span>;</span>
</span></span><span><span></span><span><span>}</span></span><span>;</span>
</span></code></pre>
<p>To me, <code>let-else</code> is the best solution for handling <code>None</code> because:</p>
<ul>
<li>It’s part of the standard library.</li>
<li>It works for both libraries and applications.</li>
<li>It’s easy to understand for beginners.</li>
<li>It’s reasonably compact.</li>
<li>It allows for more complex error handling logic in the <code>else</code> block if needed.</li>
<li>Learning the mechanics behind it is helpful in other places in Rust.</li>
</ul>
<p>I hope this helps more people handle <code>Option</code> in a more robust way.
If it helps a single person avoid one <code>unwrap</code>, it was already worth it.</p>


    </div>
  </div></div>
  </body>
</html>
