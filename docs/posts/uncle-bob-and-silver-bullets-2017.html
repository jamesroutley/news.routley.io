<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.hillelwayne.com/post/uncle-bob/">Original</a>
    <h1>Uncle Bob and Silver Bullets (2017)</h1>
    
    <div id="readability-page-1" class="page"><article lang="en">
    

    
    

    <div>
  <p>A while back I <a href="https://www.hillelwayne.com/post/10x">wrote</a> that Robert Martin was ruining software by being too good at programming. That was supposed to be a joke. Since then he’s done his damndest to actually ruin software by telling people they’re doing it wrong. His most recent response where he yells at <a href="http://blog.cleancoder.com/uncle-bob/2017/10/04/CodeIsNotTheAnswer.html">software correctness</a> was the breaking point for me, so I’m going to go ahead and say what many of us have been thinking:</p>

<p>Uncle Bob gives <em>terrible</em> advice. Following it will make your code worse.</p>

<p>He begins <a href="http://blog.cleancoder.com/uncle-bob/2017/10/04/CodeIsNotTheAnswer.html">Tools are not the Answer</a> by listing some of the “new” tools that are not “the answer”: Light Table, Model Driven Engineering, and TLA+. Now, I’m pretty biased here, what with writing a <a href="https://learntla.com">TLA+ manual</a> and all. But I agree with what (I thought) was the core critique: there is no silver bullet. TLA+ has shown some astounded successes at <a href="https://cacm.acm.org/magazines/2015/4/184701-how-amazon-web-services-uses-formal-methods/abstract">Amazon</a> and <a href="https://channel9.msdn.com/Events/Build/2014/3-642">Microsoft</a>, but it only verifies specs, not code. While it’s incredible for designing systems, you should combine it with other correctness techniques, like type systems and tests. A pretty good argument.</p>

<p>But it turns out that argument was only in my head, because he follows it with this:</p>

<blockquote>
<p>The solution to the software apocalypse is not more tools. The solution is better programming discipline.</p>
</blockquote>

<p>Just what is “discipline”, anyway? Uncle Bob says that means not “doing a half-assed job.” Uncle Bob is saying the solution for people writing bad code… is to not write bad code. Our programs would be perfect if it weren’t for the programmers!</p>

<p>One of the core assumptions of modern systems engineering is that there’s a constant flow of defects: <em>that people make mistakes</em>. You can’t rely on people to not fuck up on their own: after all, the US still has 30,000 auto deaths a year. Rather, the best way to reduce the volume and severity of mistakes is to adjust the system itself. Either make them harder to do, make them easier to catch, or make them cause less damage when they do happen. Don’t just blame the drivers, give them safe roads! Give them seatbelts!</p>

<p>One way of doing this is to add a bureaucratic <em>process</em>, such as code review. If your code doesn’t conform to requirements (it lacks tests, you named your variables <code>x</code> and <code>x2</code>, etc), the code will be rejected. That, on a systems level, reduces bugs. When we adopt mechanical tools, like tests and IDEs, all we are doing is automating those processes. We use the way we create code, and the kind of code we create, to check our work. This is the vast field of software correctness, and spans everything from type systems to language design.</p>

<p>Uncle Bob is okay with software correctness: after all, he uses the phrase “unit testing” like a smurf uses “smurf”. But what about every <em>other</em> correctness technique?</p>

<ul>
<li>End-to-End Tests: <a href="http://blog.cleancoder.com/uncle-bob/2017/03/06/TestingLikeTheTSA.html">‘Don’t test through UIs’</a>.</li>
<li>Safer Languages: <a href="http://blog.cleancoder.com/uncle-bob/2017/01/11/TheDarkPath.html">The ‘Dark Path’</a>.</li>
<li>Data Integrity: <a href="http://blog.cleancoder.com/uncle-bob/2012/05/15/NODB.html">Just ‘a detail’</a>.</li>
<li>Type Systems: <a href="http://blog.cleancoder.com/uncle-bob/2016/05/01/TypeWars.html">‘You don’t need static type checking if you have 100% unit test coverage’</a>.</li>
<li>Formal Methods: <a href="http://blog.cleancoder.com/uncle-bob/2017/10/04/CodeIsNotTheAnswer.html">Only a ‘shiny’</a>.</li>
<li>Property-Based Testing: Probably <a href="http://blog.cleancoder.com/uncle-bob/2016/10/26/DijkstrasAlg.html">hasn’t heard of it</a>.</li>
</ul>

<p>In other words, any correctness technique that isn’t unit tests can be dismissed. But unit tests don’t give you much confidence in your code. That’s because humans make mistakes, and we can’t always guarantee that the mistakes we make are the nicely unit testable ones. For example, here’s a ceiling function I wrote. Quick, what numbers would you test it with?</p>
<div><pre><code data-lang="js"><span></span><span>function</span><span> </span><span>ceiling</span><span>(</span><span>num</span><span>) {</span>
<span>    </span><span>if</span><span> (</span><span>num</span><span> </span><span>==</span><span> (</span><span>num</span><span> </span><span>|</span><span> </span><span>0</span><span>)) {</span>
<span>        </span><span>return</span><span> </span><span>num</span><span>;</span>
<span>    }</span>
<span>    </span><span>return</span><span> Math.</span><span>round</span><span>(</span><span>num</span><span> </span><span>+</span><span> </span><span>0.5</span><span>);</span>
<span>}</span>
</code></pre></div>

<p>Did you try <code>-1e-100</code>? You’d have seen that <code>ceiling(-1e-100) == 1</code> when it should be <code>0</code>. That’s because of how floating point works: <code>0.5 - 1e-100 == 0.5</code>. I’d be shocked if many people remembered to check that, if they even knew that floating point has quirks at all. But a property-based test catches it easily. Okay, function two:</p>
<div><pre><code data-lang="js"><span></span><span>function</span><span> </span><span>clamp</span><span>(</span><span>min</span><span>, </span><span>x</span><span>, </span><span>max</span><span>) {</span>
<span>    </span><span>return</span><span> Math.</span><span>max</span><span>(Math.</span><span>min</span><span>(</span><span>max</span><span>, </span><span>x</span><span>), </span><span>min</span><span>);</span>
<span>}</span>
</code></pre></div>

<p>The function is perfectly fine. The bug isn’t in the function at all! It’s that, in our 50 kLoC codebase, there is a single path that eventually ends with calling <code>clamp</code> with a null value. Are you going to test every possible path? Is that really superior to using a type system? Okay, last one:</p>
<div><pre><code data-lang="js"><span></span><span>function</span><span> </span><span>append_to_body</span><span>(</span><span>type</span><span>, </span><span>text</span><span>) {</span>
<span>    </span><span>var</span><span> </span><span>d</span><span> </span><span>=</span><span> document.</span><span>createElement</span><span>(</span><span>type</span><span>);</span>
<span>    </span><span>d</span><span>.</span><span>innerHTML</span><span> </span><span>=</span><span> </span><span>text</span><span>;</span>
<span>    document.</span><span>body</span><span>.</span><span>appendChild</span><span>(</span><span>d</span><span>);</span>
<span>}</span>
</code></pre></div>

<p>The function works fine, except you’ve now opened up an XSS vector. That’s why we have static analysis. These aren’t just toy examples. These are topics with plenty of research, plenty of development, and plenty of history. We’ve learned what they’re good for and what their limitations are. We use these tool because they work. Exactly the same reason we have unit tests and TDD.</p>

<p>But unit tests are not enough. Type systems are not enough. Contracts are not enough, formal specs are not enough, code review isn’t enough, <em>nothing</em> is enough. We have to use everything we have to even hope of writing correct code, because there’s only one way a program is right and infinite ways a program can be wrong, and we can’t assume that any tool we use will prevent more than a narrow slice of all those wrong ways.</p>

<p>That’s what makes Bob’s advice so toxic. By being so dismissive of everything but unit tests, he’s actively discouraging us from using our whole range of techniques. He demands we run blind and blames us for tripping.</p>

<p>Uncle Bob can say whatever he likes. We don’t have to listen to him. He’s welcome to keep shouting that tools won’t help, better languages won’t help, better process won’t help, the only thing that’ll help is lots and lots of unit tests. Meanwhile, we’ll continue to struggle with our bugs, curse our model checkers, and make software engineering just a little bit better. We don’t believe in silver bullets.</p>


</div>

    



  </article></div>
  </body>
</html>
