<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://planetscale.com/blog/btrees-and-database-indexes">Original</a>
    <h1>B-Trees and Database Indexes</h1>
    
    <div id="readability-page-1" class="page"><p><label for="toc">Table of contents</label></p><section><h2 id="what-is-a-b-tree-"><a href="#what-is-a-b-tree-">What is a B-tree?</a></h2><p>The B-tree plays a foundational role in many pieces of software, especially database management systems (DMBSs).<!-- --> <!-- -->MySQL, Postgres, MongoDB, Dynamo, and many others rely on B-trees to perform efficient data lookups via <strong>indexes</strong>.<!-- --> <!-- -->By the time you finish this article, you&#39;ll have learned how B-trees and B+trees work, why databases use them for indexes, and why using a UUID as your primary key <a href="https://planetscale.com/blog/the-problem-with-using-a-uuid-primary-key-in-mysql">might be a bad idea</a>.<!-- --> <!-- -->You&#39;ll also have the opportunity to play with <em>interactive</em> animations of the data structures we discuss.<!-- --> <!-- -->Get ready to click buttons.</p><p>Computer science has a plethora of data structures to choose from for storing, searching, and managing data on a computer.<!-- --> <!-- -->The B-tree is one such structure, and is commonly used in database applications.<!-- --> <!-- -->B-trees store pairs of data known as <em>keys</em> and <em>values</em> in what computer programmers call a tree-like structure.<!-- --> <!-- -->For those not acquainted with how computer scientists use the term &#34;tree&#34; it actually looks more like a root system.</p><p>Below you&#39;ll find the first <em>interactive</em> component of this blog.<!-- --> <!-- -->This allows you to visualize the structure of a B-tree and see what happens as you <span>add key/value pairs</span> and <span>change the number of key/value pairs per node</span>.<!-- --> <!-- -->Give it a try by clicking the <span>Add</span> or <span>Add random</span> button a few times and try to get an intuitive sense of how it works before we move on to the details.</p><p>If the animations above are too fast or slow, you can adjust the animation speed of everything that happens with the B-trees in this article.<!-- --> <!-- -->Adjust below:</p><p>Every B-tree is made up of <strong>nodes</strong> (the rectangles) and <strong>child pointers</strong> (the lines connecting the nodes).<!-- --> <!-- -->We call the top-most node the <strong>root node</strong>, the nodes on the bottom level <strong>leaf nodes</strong>, and everything else <strong>internal nodes</strong>.<!-- --> <!-- -->The formal definition of a B-tree can vary depending on who you ask, but the following is a pretty typical definition.</p><p><strong>A B-tree of order K is a tree structure with the following properties:</strong></p><ul><li><strong>Each node in the tree stores N key/value pairs, where N is greater than 1 and less than or equal to K.</strong></li><li><strong>Each internal node has at least N/2 key/value pairs (an internal node is one that is not a leaf or the root).</strong></li><li><strong>Each node has N+1 children.</strong></li><li><strong>The root node has at least one value and two children, unless it is the sole node.</strong></li><li><strong>All leaves are on the same level.</strong></li></ul><p>The other key characteristic of a B-tree is ordering.<!-- --> <!-- -->Within each node the elements are kept in order.<!-- --> <!-- -->Any child to the left of a key must only contain other keys that are less than it.<!-- --> <!-- -->Children to the right must have keys that are greater than it.</p><p>This enforced ordering means you can <strong>search for a key</strong> very efficiently.<!-- --> <!-- -->Starting at the <strong>root node</strong>, do the following:</p><ol><li>Check if the node contains the key you are looking for.</li><li>If not, find the location in the node where your key would get inserted into, if you were adding it.</li><li>Follow the <strong>child pointer</strong> at this spot down to the next level, and repeat the process.</li></ol><p>When searching in this way, you only need to visit <em>one</em> node at each level of the tree to search for one key.<!-- --> <!-- -->Therefore, the less levels it has (or the shallower it is), the faster searching can be performed.<!-- --> <!-- -->Try <span>searching</span> for some keys in the tree below:</p><p>B-trees are uniquely suited to work well when you have a <em>very large</em> quantity of data that also needs to be persisted to long-term storage (disk).<!-- --> <!-- -->This is because each node uses a fixed number of bytes.<!-- --> <!-- -->The number of bytes can be tailored to play nicely with <strong>disk blocks</strong>.</p><p>Reading and writing data on hard-drive disks (HDDs) and solid-state disks (SSDs) is done in units called <strong>blocks</strong>.<!-- --> <!-- -->These are typically byte sequences of length 4096, 8192, or 16384 (4k, 8k, 16k).<!-- --> <!-- -->A single disk will have a capacity of many millions or billions of blocks.<!-- --> <!-- -->RAM on the other hand is typically addressable on a per-byte level.</p><p>This is why B-trees work so well when we need to organize and store <em>persistent</em> data on disk.<!-- --> <!-- -->Each node of a B-tree can be sized to match to the size of a disk block (or a multiple of this size).</p><p>The number of values each node of the tree can store is based on the number of bytes each is allocated and the number of bytes consumed by each key / value pair.<!-- --> <!-- -->In the example above, you saw some pretty small nodes — ones storing 3 integer values and 4 pointers.<!-- --> <!-- -->If our disk block and B-tree node is 16k, and our keys, values, and child pointers are all 8 bits, this means we could store 682 key/values with 683 child pointers per node.<!-- --> <!-- -->A three level tree could store over 300 <em>million</em> key/value pairs (682 × 682 × 682 = 317,214,568).</p><h2 id="the-superior-b-tree-for-databases-"><a href="#the-superior-b-tree-for-databases-">The superior B+Tree (for databases)</a></h2><p>B-trees are great, but many database indexes use a &#34;fancier&#34; variant called the B+tree.<!-- --> <!-- -->It&#39;s similar to a B-tree, with the following changes to the rules:</p><ul><li><strong>Key/value pairs are stored only at the leaf nodes.</strong></li><li><strong>Non-leaf nodes store only keys and the associated child pointers.</strong></li></ul><p>There are two additional rules that are specific to how B+trees are implemented in MySQL indexes:</p><ul><li><strong>Non-leaf nodes store N child pointers instead of N+1.</strong></li><li><strong>All nodes also contain &#34;next&#34; and &#34;previous&#34; pointers, allowing each level of the tree to also act as a doubly-linked list.</strong></li></ul><p>Here&#39;s another visualization showing how the B+tree works with these modified characteristics.<!-- --> <!-- -->This time you can individually adjust the number of <span>keys in inner nodes</span> and <span>in the leaf nodes</span>, in addition to <span>adding key/value pairs</span>.</p><p>Why are B+ trees better for databases?<!-- --> <!-- -->There are two primary reasons.</p><ol><li>Since inner nodes do <em>not</em> have to store values, we can fit more keys per inner node! This can help keep the tree shallower.</li><li>All of the <em>values</em> can be stored at the same level, and traversed in-order via the bottom-level linked list.</li></ol><p>Go ahead and give <span>searching</span> on a B+tree a try as well:</p><h2 id="how-mysql-uses-b-trees"><a href="#how-mysql-uses-b-trees">How MySQL uses B+trees</a></h2><p>MySQL, arguably the world&#39;s most popular database management system, supports multiple storage engines.<!-- --> <!-- -->The most commonly used engine is InnoDB which relies <em>heavily</em> on B+Trees.<!-- --> <!-- -->In fact, it relies <em>so</em> heavily on them that it actually stores <em>all table data</em> in a B+tree, with the table&#39;s primary key used as the tree key.</p><p>Whenever you create a new InnoDB table you are required to specify a primary key.<!-- --> <!-- -->Database administrators and software engineers often use a simple auto-incrementing integer for this value.<!-- --> <!-- -->Behind the scenes, MySQL + InnoDB creates an B+tree for each new table created.<!-- --> <!-- -->The keys for this tree are whatever the primary key was set to.<!-- --> <!-- -->The values are the remaining column values for each row, and are stored only in the leaf nodes.</p><p>The size of each node in these B+trees is set to 16k by default.<!-- --> <!-- -->Whenever MySQL needs to access a piece of data (keys, values, whatever), it loads the entire associated page (B+tree node) from disk, even if that page contains other keys or values it does not need.</p><p>The number of rows stored in each node depends on how &#34;wide&#34; the table is.<!-- --> <!-- -->In a &#34;narrow&#34; table (a table with few columns), each leaf could store hundreds of rows.<!-- --> <!-- -->In a &#34;wide&#34; table (a table with many columns), each leaf may only store a single-digit number of rows.<!-- --> <!-- -->InnoDB also supports rows is being larger than a disk block, but we won&#39;t dig in to that in this post.</p><p>Use the visualization below to see how the number of <span>keys in each inner node</span> and <span>in each leaf node</span> affect the <span>depth of the tree</span>.<!-- --> <!-- -->The deeper the tree, the slower it is to look up elements.<!-- --> <!-- -->Thus, we want shallow trees for our databases!</p><p>It&#39;s also common to create secondary indexes on InnoDB tables — ones on columns other than the primary key.<!-- --> <!-- -->These may be needed to speed up WHERE clause filtering in SQL queries.<!-- --> <!-- -->An additional persistent B+tree is constructed for each secondary index.<!-- --> <!-- -->For these, the key is the column(s) that the user selected the index to be built for.<!-- --> <!-- -->The values are the <strong>primary key</strong> of the associated row.<!-- --> <!-- -->Whenever a secondary index is used for a query:</p><ol><li>A search is performed on the secondary index B+tree.</li><li>The primary keys for matching results are collected.</li><li>These are then used to do additional B+tree lookup(s) on the main table B+tree to then find the actual row data.</li></ol><p>Consider the following database schema:</p><div><pre><code><p><span>CREATE</span><span> </span><span>TABLE</span><span> </span><span>user</span><span> </span><span>(</span><span></span>
</p><p><span>  user_id </span><span>BIGINT</span><span> </span><span>UNSIGNED</span><span> </span><span>AUTO_INCREMENT</span><span> </span><span>NOT</span><span> </span><span>NULL</span><span>,</span><span></span>
</p><p><span>  username </span><span>VARCHAR</span><span>(</span><span>256</span><span>)</span><span> </span><span>NOT</span><span> </span><span>NULL</span><span>,</span><span></span>
</p><p><span>  email </span><span>VARCHAR</span><span>(</span><span>256</span><span>)</span><span> </span><span>NOT</span><span> </span><span>NULL</span><span>,</span><span></span>
</p><p><span>  </span><span>PRIMARY</span><span> </span><span>KEY</span><span> </span><span>(</span><span>user_id</span><span>)</span><span></span>
</p><p><span></span><span>)</span><span>;</span><span></span>
</p><p><span></span><span>CREATE</span><span> </span><span>INDEX</span><span> email_index </span><span>ON</span><span> </span><span>user</span><span>(</span><span>email</span><span>)</span><span>;</span>
</p></code></pre></div><p>This will cause two B+tree indexes to be created:</p><ul><li>One for the table&#39;s primary key, using <code>user_id</code> for the key and the other two columns stored in the values.</li><li>Another for the <code>email_index</code>, with <code>email</code> as the key and <code>user_id</code> as the value.</li></ul><p>When a query like this is executed:</p><div><pre><code><p><span>SELECT</span><span> username </span><span>FROM</span><span> </span><span>user</span><span> </span><span>WHERE</span><span> email </span><span>=</span><span> </span><span>&#39;x@planetscale.com&#39;</span><span>;</span>
</p></code></pre></div><p>This will first perform a lookup for <code>x@planetscale.com</code> on the <code>email_index</code> B+tree.<!-- --> <!-- -->After it has found the associated <code>user_id</code> value it will use that to perform another lookup into the primary key B+tree, and fetch the username from there.</p><p>Overall, we&#39;d like to always minimize the number of blocks / nodes that need to be visited to fulfill a query.<!-- --> <!-- -->The fewer nodes we have to visit, the faster our query can go.<!-- --> <!-- -->The <strong>primary key</strong> you choose for a table is pivotal in minimizing the number of nodes we need to visit.</p><h2 id="primary-key-choice-insertions"><a href="#primary-key-choice-insertions">Primary key choice: insertions</a></h2><p>The way your table&#39;s data is arranged in a B+tree depends on the key you choose.<!-- --> <!-- -->This means your choice of <code>PRIMARY KEY</code> will impact the layout on disk of all of the data in the table, and in turn performance.<!-- --> <!-- -->Choose your <code>PRIMARY KEY</code> wisely!</p><p>Two common choices for a primary key are:</p><ul><li>An integer sequence (such as <code>BIGINT UNSIGNED AUTO_INCREMENT</code>)</li><li>A <code>UUID</code>, of which there are <a href="https://planetscale.com/blog/the-problem-with-using-a-uuid-primary-key-in-mysql">many versions</a>.</li></ul><p>Let&#39;s first consider the consequences of using a <a href="https://planetscale.com/blog/the-problem-with-using-a-uuid-primary-key-in-mysql#uuidv4">UUIDv4</a> primary key.<!-- --> <!-- -->A UUIDv4 is a mostly-random 128 bit integer.</p><p>We can simulate this by <span>inserting a bunch of random integers</span> into our B+tree visualization.<!-- --> <!-- -->On each insertion, all of the visited nodes will be <span>highlighted green</span>.<!-- --> <!-- -->You can also control <span>the percentage of keys</span> to keep in the existing node when a split occurs.<!-- --> <!-- -->Give it a try by clicking the <span>Add random</span> button several times.<!-- --> <!-- -->What do you notice?</p><p>A few observations:</p><ol><li>The nodes visited for an insert are unpredictable ahead of time.</li><li>The destination leaf node for an insert is unpredictable.</li><li>The <strong>values</strong> in the leaves are not in order.</li></ol><p>Issues 1 and 2 are problematic because over the course of many insertions we&#39;ll have to visit many of the nodes (pages) in the tree.<!-- --> <!-- -->This excessive reading and writing leads to poor performance.<!-- --> <!-- -->Issue 3 is problematic if we intend to ever search for or view our data in the order it was inserted.</p><p>The same problem can arise (albeit in a less extreme way) with some other UUIDs as well.<!-- --> <!-- -->For example, UUID v3 and v5 are both generated from via hashing, and therefore will not be sequential and have similar behavior to inserting randomly.<!-- --> <!-- -->Alternatively, <a href="https://planetscale.com/blog/the-problem-with-using-a-uuid-primary-key-in-mysql#uuidv7">UUIDv7</a> actually does a good job of overcoming some of these challenges.</p><p>Let&#39;s consider using a sequential <code>BIGINT UNSIGNED AUTO_INCREMENT</code> as our primary key instead.<!-- --> <!-- -->Try <span>inserting sequential values</span> into the B+ tree instead:</p><p>This mitigates all of the aforementioned problems:</p><ol><li>We always follow the right-most path when inserting new values.</li><li>Leaves only get added on the right side of the tree.</li><li>At the leaf level, data is in sorted order based on when it was inserted.</li></ol><p>Because of 1 and 2, many insertions happening in sequence will revisit the same path of pages, leading to fewer I/O requests when inserting a lot of key/value pairs.</p><p>The bar chart below shows the number of unique nodes visited for the previous 5 inserts on the two B+trees above.<!-- --> <!-- -->Assuming trees of the same depth, you should see random one being slightly higher, meaning worse performance.</p><p>If you are curious about the effect of the <span>split percentage</span> on sequential vs random insert patterns, check out the interactive visualization below.<!-- --> <!-- -->Use the slider to set the <span>split percentage</span>.<!-- --> <!-- -->The line graph will update to show how many nodes needed to be visited for the prior 5 at various points in a 400-key insertion sequence.<!-- --> <!-- -->Notice that in most cases, the <span>sequential inserts</span> require much fewer node visits than <span>random inserts</span>, and are also more predictable.</p><h2 id="primary-key-choice-reading-data-in-order"><a href="#primary-key-choice-reading-data-in-order">Primary key choice: reading data in order</a></h2><p>It&#39;s common to search for data from a database in time-sequenced order.<!-- --> <!-- -->Consider viewing the timeline on X, or a chat history in Slack.<!-- --> <!-- -->We typically want to see the posts and chat messages in time (or reverse-time) sequences.<!-- --> <!-- -->This means we&#39;ll often read chunks of database that are &#34;near&#34; each-other in time.<!-- --> <!-- -->These queries take the form:</p><div><pre><code><p><span>SELECT</span><span> username</span><span>,</span><span> message_text</span><span>,</span><span> </span><span>.</span><span>.</span><span>.</span><span></span>
</p><p><span></span><span>FROM</span><span> post</span>
</p><p><span>  </span><span>WHERE</span><span> sent </span><span>&gt;</span><span> $START_DATETIME</span>
</p><p><span>  </span><span>AND</span><span> sent </span><span>&gt;</span><span> $END_DATETIME</span>
</p><p><span>  </span><span>ORDER</span><span> </span><span>BY</span><span> sent </span><span>DESC</span><span>;</span>
</p></code></pre></div><p>Consider what this would be like if we have UUIDv4s for our primary key<!-- --> <!-- -->In the B+tree below, a bunch of random keys and corresponding values have been inserted into the table.<!-- --> <!-- -->Try <span>finding ranges of values</span>.<!-- --> <!-- -->What do you see?</p><p>Notice that the value sequences are spread out across many non-sequential leaf nodes.<!-- --> <!-- -->On the other hand, consider <span>finding</span> sequentially inserted values instead.</p><p>In such cases, all pages with the search results will be next to each other.<!-- --> <!-- -->It&#39;s even possible to search for several rows, and all of them will be next to each other in a single page.<!-- --> <!-- -->For this variety of query pattern, we can mitigate the number of pages that need to be read using a sequential primary key.</p><h2 id="primary-key-choice-size"><a href="#primary-key-choice-size">Primary key choice: size</a></h2><p>Another important consideration is key size.<!-- --> <!-- -->We always want our primary keys to be:</p><ol><li>Big enough to never face exhaustion</li><li>Small enough to not use excessive storage</li></ol><p>For integer sequences, we can sometimes get away with a <code>MEDIUMINT</code> (16 million unique values) or <code>INT</code> (4 billion unique values) for smaller tables.<!-- --> <!-- -->For big tables, we often jump to <code>BIGINT</code> to be safe (18 sextillion possible values).<!-- --> <code>BIGINT</code>s are 64 bits (8 bytes).<!-- --> <!-- -->UUIDs are typically 128 bits (16 bytes), twice the size of even the largest integer type in MySQL.<!-- --> <!-- -->Since B+tree nodes are a fixed size, a <code>BIGINT</code> will allow us to fit more keys per-node than UUIDs.<!-- --> <!-- -->This results in shallower trees and faster lookups.</p><p>Consider a case where each tree node is only 100 bytes, child pointers are 8 bytes, and values are 8 bytes.<!-- --> <!-- -->We could fit 4 UUIDs (plus 4 child pointers) in each node.<!-- --> <!-- -->Hit the <span>play insertion sequence</span> button below to see the inserts.</p><p>If we had used a <code>BIGINT</code> instead, we could fit 6 keys (and corresponding child pointers) in each node instead.<!-- --> <!-- -->This would lead to a shallower tree, better for performance.</p><h2 id="b-trees-pages-and-innodb"><a href="#b-trees-pages-and-innodb">B+trees, Pages and InnoDB</a></h2><p>Recall that one of the big benefits of a B+tree is the fact that we can set the node size to whatever we want.<!-- --> <!-- -->In InnoDB, the B+tree nodes are typically set to 16k, the size of an <strong>InnoDB page</strong>.</p><p>When fulfilling a query (and therefore traversing B+trees), InnoDB does not read individual rows and columns from disk.<!-- --> <!-- -->Whenever it needs to access a piece of data, it loads the entire associated page from disk.</p><p>InnoDB has some tricks up its sleeve to mitigate this, the main one being the <strong>buffer pool</strong>.<!-- --> <!-- -->The buffer pool is an in-memory cache for InnoDB pages, sitting between the pages on-disk and MySQL query execution.<!-- --> <!-- -->When MySQL needs to read a page, it first checks if it&#39;s already in the buffer pool.<!-- --> <!-- -->If so, it reads it from there, skipping the disk I/O operation.<!-- --> <!-- -->If not, it finds the page on-disk, adds it to the buffer pool, and then continues query execution.</p><p>The buffer pool <em>drastically</em> helps query performance.<!-- --> <!-- -->Without it, we&#39;d end up doing significantly more disk I/O operations to handle a query workload.<!-- --> <!-- -->Even with the buffer pool, minimizing the number of pages that needs to be visited helps performance (1) because there&#39;s still a (small) cost to looking up a page in the buffer pool, and (2) it helps reduce the number of buffer pool loads and evictions that need to take place.</p><h2 id="other-situations"><a href="#other-situations">Other situations</a></h2><p>Here, we mostly focused on comparing a sequential key to a random / UUID key.<!-- --> <!-- -->However, the principles shown here are useful to keep in mind no matter what kind of primary or secondary key you are considering.</p><p>For example, you may also consider using a <code>user.created_at</code> timestamp as a key for an index.<!-- --> <!-- -->This will have similar properties to a sequential integer.<!-- --> <!-- -->Insertions will generally always go to the right-most path, unless legacy data is being inserted.</p><p>Conversely, something like a <code>user.email_address</code> string will have more similar characteristics to a random key.<!-- --> <!-- -->Users won&#39;t be creating accounts in email-alphabetical order, so insertions will happen all over the place in the B+tree.</p><h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2><p>This is already a long blog post, and yet, much more could be said about b+trees, indexes, and primary key choice in MySQL.<!-- --> <!-- -->On the surface it may seem simple, but there&#39;s an incredible amount of nuance to consider if you want to squeeze every ounce of performance out of your database.<!-- --> <!-- -->If you&#39;d like to experiment further, you can visit the dedicated <a href="https://bplustree.app">interactive B+tree website</a>.<!-- --> <!-- -->If you want a regular B-tree, <a href="https://btree.app">go here instead</a>.<!-- --> <!-- -->I hope you learned a thing or two about indexes!</p><p><em>Special thanks to <a href="https://samwho.dev">Sam Rose</a> for early review.</em></p></section></div>
  </body>
</html>
