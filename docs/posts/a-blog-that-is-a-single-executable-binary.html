<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.andreinc.net/2022/04/10/a-blog-that-is-a-single-executable-binary">Original</a>
    <h1>A blog that is a single executable binary</h1>
    
    <div id="readability-page-1" class="page"><div>
      
        <header>
          
          

  <p>
    
      
      <span>
        <i aria-hidden="true"></i>
        
        <time datetime="2022-04-10T00:00:00+00:00">April 10, 2022</time>
      </span>
    

    

    
  </p>


        </header>
      

      <section itemprop="text">
        
        <p>Recently, while browsing <a href="https://lobste.rs/">lobste.rs</a>, I had the chance to stumble upon this beautiful <a href="https://j3s.sh/thought/my-website-is-one-binary.html">article</a>, titled: <em>my website is one binary</em>.</p>

<p>It was an idea crazy enough (in a positive way) to try it myself in C.</p>

<p>So, what if I wrote my own blogging “platform” (in the lack of a more suitable term)? But, instead of outputting a static HTML site, my <em>platform</em> outputs a single <strong>executable binary file</strong> compatible with any *Nix platform. There would be no HTML files, no other assets, just a piece of source code that gets to be recompiled each time I plan to update my “content”. Everything stays in memory, and my <em>site</em> is an executable.</p>

<p>To go entirely minimalistic, I’ve decided to impose myself additional rules to follow:</p>
<ol>
  <li>The software is not going to use any external dependencies other than what the C standard library and whatever the operating system is offering me (POSIX, I am looking at you!);</li>
  <li>I won’t touch <a href="https://en.wikipedia.org/wiki/Common_Gateway_Interface">CGI</a>; that’s cheating;</li>
  <li>The program will be as concise as possible, and preferably it won’t get bigger than 200-300 lines of code. At the same time, it will be written following a “readable” coding style, without artificially squeezing things on a single line;</li>
  <li>No premature optimization. The software should withstand moderate traffic: a few requests per minute. No need to be extra clever; this is not <em>web-scale</em>;</li>
  <li>I will try to have fun while writing it, even if I have to deal with C strings;</li>
  <li>This prototype won’t replace my current blog, no matter how seductive it may be. I kind of like using ruby, Jekyll, and minimal mistakes;</li>
  <li>No dynamic memory allocation. I will refuse to use <code>calloc()</code>, <code>malloc()</code>, <code>free()</code> and the likes.</li>
</ol>

<p>That being (optimistically) settled down, I’ve realized I had to write my own primitive HTTP web server; nothing exceedingly fancy, but something that supports GET requests.</p>

<p>The last time I touched C sockets programming was more than 14 years ago, while I was in UNI. Reading an entire book about the topic was not an option, but I found something better called <a href="https://beej.us/guide/bgnet/html/">Beej’s Network Programming guide</a>. If you are already familiar with C, this tutorial has enough information to get you started, and it only takes a few hours to go through it. I’ve copy-pasted the examples, gone through them, modified a few things, and everything worked. End of story.</p>

<p>The next step was to read a bit of the HTTP Protocol. As a backend developer, I have a broad understanding of how it functions. But I was not (recently) put in the position to look closely at what the actual messages look like. I found out that Firefox, the <a href="https://www.rfc-editor.org/rfc/rfc2616">RFC</a>, and the <a href="https://duckduckgo.com/">duckduckgo</a> search engine were my friends.</p>

<p>That being said and done, I was good to go.</p>



<p>I’ve unimaginatively named my <em>blogging platform</em> <code>microblog-c</code>. The code and the the samples are available here:</p>

<div><div><pre><code>git clone git@github.com:nomemory/microblog-c.git
</code></pre></div></div>



<p>To build the sample blog we just compile <a href="https://github.com/nomemory/microblog-c/blob/main/microblog.c"><code>microblog.c</code></a> and we wun it:</p>
<div><div><pre><code><span>&gt;&gt;</span> gcc <span>-Wall</span> microblog.c <span>-o</span> microblog
<span>&gt;&gt;</span> ./microblog
</code></pre></div></div>

<p>The internal server will start serving HTTP requests on port <code>8080</code> if everything goes well.</p>

<p>If you are curious to see how everything looks like, just open a browser: <a href="http://localhost:8080">http://localhost:8080</a>, and enjoy:</p>

<p><img src="https://www.andreinc.net/assets/images/2022-04-10-a-blog-that-is-a-single-executable-binary/homepage.png" alt="png" height="40%" width="40%"/></p>

<p><img src="https://www.andreinc.net/assets/images/2022-04-10-a-blog-that-is-a-single-executable-binary/davidbowie.png" alt="png" height="25%" width="25%"/></p>

<p><img src="https://www.andreinc.net/assets/images/2022-04-10-a-blog-that-is-a-single-executable-binary/ozzy.png" alt="png" height="25%" width="25%"/></p>

<p>As you can see, CSS is not my strongest skill.</p>



<p>There’s no need to touch the <code>microblog.c</code> source-code for adding new content to the blog.</p>

<p>We start by creating a new file in the <code>./cnt</code> folder called <code>jimihendrix</code>:</p>

<div><div><pre><code><span>{</span>
    <span>.</span><span>content_type</span> <span>=</span> <span>&#34;text/html&#34;</span><span>,</span>
    <span>.</span><span>body</span> <span>=</span> <span>&#34;&lt;p&gt;Jimmy Hendridx&lt;/p&gt;&#34;</span>
            <span>&#34;&lt;p&gt;Jimmy Hendrix says hello&lt;/p&gt;&#34;</span>
<span>}</span>
</code></pre></div></div>

<blockquote>
  <p>Note to self: It’s JIMI, not JIMMY!</p>
</blockquote>

<p>Then, we reference the new file in the <code>posts</code> file:</p>

<div><div><pre><code><span>#include</span> <span>&#34;cnt/home&#34;</span><span> /* 0 */</span><span>
</span><span>,</span>
<span>#include</span> <span>&#34;cnt/davidbowie&#34;</span><span> /* 1 */</span><span>
</span><span>,</span>
<span>#include</span> <span>&#34;cnt/ozzyosbourne&#34;</span><span> /* 2 */</span><span>
</span><span>,</span> 
<span>#include</span> <span>&#34;cnt/jimmyhendrix&#34;</span><span> /* 3 &lt;---- ADD THIS LINE ---&gt; */</span><span>
</span></code></pre></div></div>

<p>Next, we will make the <em>article</em> visible on the homepage by editing <code>./cnt/home</code>:</p>

<div><div><pre><code><span>{</span>
    <span>.</span><span>content_type</span> <span>=</span> <span>&#34;text/html&#34;</span><span>,</span>
    <span>.</span><span>body</span> <span>=</span> <span>&#34;&lt;p&gt;My name is Andrei N. Ciobanu and this is a blog about my favourite musicians.&lt;p&gt;&#34;</span>
            <span>&#34;&lt;p&gt;To contact me, please write an email to gnomemory (and then append yahoo.com)&lt;p&gt;&#34;</span>
            <span>&#34;&lt;p&gt;List of favourite rock stars:&lt;p&gt;&#34;</span>
            <span>&#34;&lt;ol&gt;&#34;</span>
            <span>&#34;&lt;li&gt;&lt;a href=&#39;1&#39;&gt;David Bowie&lt;/a&gt;&lt;/li&gt;&#34;</span>
            <span>&#34;&lt;li&gt;&lt;a href=&#39;2&#39;&gt;Ozzy Osbourne&lt;/a&gt;&lt;/li&gt;&#34;</span>
            <span>&#34;&lt;li&gt;&lt;a href=&#39;3&#39;&gt;Jimmy Hendrix&lt;/a&gt;&lt;/li&gt;&#34;</span> <span>/* &lt;&lt;--- HERE*/</span>
            <span>&#34;&lt;/ol&gt;&#34;</span>
<span>}</span>
</code></pre></div></div>

<p>And the final step is to re-compile the blog and re-run the server:</p>

<div><div><pre><code><span>&gt;&gt;</span> gcc <span>-Wall</span> microblog.c <span>-o</span> microblog
<span>&gt;&gt;</span> ./microblog
</code></pre></div></div>

<p>If we open <a href="http://localhost:8080"><code>http://localhost:8080</code></a> again we will the changes:</p>

<p><img src="https://www.andreinc.net/assets/images/2022-04-10-a-blog-that-is-a-single-executable-binary/home_new.png" alt="png" height="25%" width="25%"/></p>

<p><img src="https://www.andreinc.net/assets/images/2022-04-10-a-blog-that-is-a-single-executable-binary/jimmyhendrix_new.png" alt="png" height="25%" width="25%"/></p>



<p>The following part of the article is not a step-by-step guide, so I suggest opening <a href="https://github.com/nomemory/microblog-c/blob/main/microblog.c"><code>microblog.c</code></a> to follow the code as you continue reading.</p>

<h2 id="the-model-and-a-neat-pre-processor-trick">The model and a neat pre-processor trick</h2>

<p>We start by defining our model, <code>struct post_s</code>:</p>

<div><div><pre><code><span>#define TEXT_PLAIN &#34;text/plain&#34;
#define TEXT_HTML &#34;text/html&#34;
</span><span>typedef</span> <span>struct</span> <span>post_s</span>
<span>{</span>
  <span>char</span> <span>*</span><span>content_type</span><span>;</span>
  <span>char</span> <span>*</span><span>body</span><span>;</span>
<span>}</span> <span>post</span><span>;</span>
</code></pre></div></div>

<p>We will keep things simple from the beginning: a blog post has a <code>content_type</code> and a <code>body</code>. The <code>content_type</code> can be either:</p>
<ul>
  <li><code>text/html</code> if we plan to server classical HTML content;</li>
  <li><code>text/plain</code> if we want to work with <code>.txt</code> files.</li>
</ul>

<p>Our main strategy is to keep all the blog posts inside a global array of <code>post posts[]</code> which is <em>known</em> at compile-time:</p>

<div><div><pre><code><span>#include</span> <span>&lt;stdio.h&gt;</span><span>
</span>
<span>#define TEXT_PLAIN &#34;text/plain&#34;
#define TEXT_HTML &#34;text/html&#34;
</span>
<span>typedef</span> <span>struct</span> <span>post_s</span>
<span>{</span>
  <span>char</span> <span>*</span><span>content_type</span><span>;</span>
  <span>char</span> <span>*</span><span>body</span><span>;</span>
<span>}</span> <span>post</span><span>;</span>

<span>post</span> <span>posts</span><span>[]</span> <span>=</span> <span>{</span>
    <span>{</span>
        <span>.</span><span>content_type</span> <span>=</span> <span>TEXT_PLAIN</span><span>,</span>
        <span>.</span><span>body</span> <span>=</span> <span>&#34;Article 0&#34;</span>
    <span>},</span>
    <span>{</span>
        <span>.</span><span>content_type</span> <span>=</span> <span>TEXT_HTML</span><span>,</span>
        <span>.</span><span>body</span> <span>=</span> <span>&#34;&lt;p&gt;Article 1&lt;/p&gt;&#34;</span>
    <span>}</span>
<span>};</span>
<span>const</span> <span>size_t</span> <span>posts_size</span> <span>=</span> <span>(</span><span>sizeof</span><span>(</span><span>posts</span><span>)</span> <span>/</span> <span>sizeof</span><span>(</span><span>post</span><span>));</span>

<span>int</span> <span>main</span><span>(</span><span>void</span><span>)</span> <span>{</span>
    <span>// Printing the posts to stdout</span>
    <span>for</span><span>(</span><span>size_t</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>posts_size</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
        <span>printf</span><span>(</span><span>&#34;post[%zu].content_type = %s</span><span>\n</span><span>&#34;</span><span>,</span> <span>i</span><span>,</span> <span>posts</span><span>[</span><span>i</span><span>].</span><span>content_type</span><span>);</span>
        <span>printf</span><span>(</span><span>&#34;post[%zu].body =</span><span>\n</span><span> %s</span><span>\n</span><span>&#34;</span><span>,</span> <span>i</span><span>,</span> <span>posts</span><span>[</span><span>i</span><span>].</span><span>body</span><span>);</span>
        <span>printf</span><span>(</span><span>&#34;</span><span>\n</span><span>&#34;</span><span>);</span>
    <span>}</span>
    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>The <code>posts</code> array contains all the content of our blog. Each article is accessible by its index in the global array.</p>

<p>To modify or add something, we would have to alter the source code and then re-compile. But what if there is a way to keep the content outside the source file?</p>

<p>Remember the <code>#include</code> pre-processor directive ? Well, contrary to popular belief, its usage it’s not limited to header files. We can actually use it to “externalize” our content, and <code>#include</code> it just before compilation:</p>

<div><div><pre><code><span>/* microblog.c */</span>
<span>post</span> <span>posts</span><span>[]</span> <span>=</span> <span>{</span>
    <span>#include</span> <span>&#34;posts&#34;</span><span>
</span><span>};</span>
</code></pre></div></div>

<p>Where <code>./posts</code> is a file on the disk with the following structure:</p>

<div><div><pre><code><span>/* posts file */</span>
<span>{</span>
    <span>.</span><span>content_type</span> <span>=</span> <span>TEXT_PLAIN</span><span>,</span>
    <span>.</span><span>body</span> <span>=</span> <span>&#34;Article 0&#34;</span>
<span>},</span>
<span>{</span>
    <span>.</span><span>content_type</span> <span>=</span> <span>TEXT_HTML</span><span>,</span>
    <span>.</span><span>body</span> <span>=</span> <span>&#34;&lt;p&gt;Article 1&lt;/p&gt;&#34;</span>
<span>}</span>
</code></pre></div></div>

<p>When we <code>#include</code> it, all of it gets inserted back into the source code.</p>

<p>At this point, we can go even further and separate the articles in their own files and further include them in <code>./posts</code>. To easily visualise what’s happening check out the following diagram:</p>

<p><img src="https://www.andreinc.net/assets/images/2022-04-10-a-blog-that-is-a-single-executable-binary/preproc.png" alt="png"/></p>

<h2 id="the-server">The server</h2>

<p>To serve our blog content to browsers, we will have to implement a straightforward HTTP Server that supports only the <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods">GET request</a>.</p>

<p>A typical GET request looks like this:</p>

<div><div><pre><code>GET /1 ........
...............
...............
...............
...........\r\n
</code></pre></div></div>

<p>The request is a <code>char*</code> (string) that ends with <code>\r\n</code> (<code>CRLF</code>), and starts with <code>GET /&lt;resource&gt;</code>.</p>

<p>Of course, the spec is infinitely more complex than this. But for the sake of simplicity, we will concentrate only on the first line, ignoring everything else. We will accept only numerical paths (<code>&lt;resources&gt;</code>). Internally those paths represent indices in our <code>post posts[]</code> array. By convention, our homepage will be <code>posts[0]</code>.</p>

<p>For example, to <code>GET</code> the homepage of our blog, the request should like:</p>

<div><div><pre><code>GET / .........
...............
...............
...............
...........\r\n
</code></pre></div></div>

<p>To <code>GET</code> another post, let’s say the article <code>posts[2]</code>, the request should look like this:</p>

<div><div><pre><code>GET /2 ........
...............
...............
...............
...........\r\n
</code></pre></div></div>

<p>The code for creating the actual server is quite straightforward if you are already familiar with C socket programming (I wasn’t, so the code is probably not the best):</p>

<div><div><pre><code><span>#define DEFAULT_BACKLOG 1000
#define DEFAULT_PORT 8080
#define DEFAULT_MAX_FORKS 5
#define DEFAULT_TIMEOUT 10000
</span>
<span>int</span> <span>max_forks</span> <span>=</span> <span>DEFAULT_MAX_FORKS</span><span>;</span>
<span>int</span> <span>cur_forks</span> <span>=</span> <span>0</span><span>;</span>

<span>void</span> <span>start_server</span><span>()</span> <span>{</span>
    <span>// Creates a Server Socket</span>
    <span>int</span> <span>server_sock_fd</span> <span>=</span> <span>socket</span><span>(</span>
        <span>AF_INET</span><span>,</span> <span>// Address Familiy specific to IPV4 addresses</span>
        <span>SOCK_STREAM</span><span>,</span> <span>// TCP </span>
        <span>0</span>
    <span>);</span>
    <span>if</span> <span>(</span><span>!</span><span>server_sock_fd</span><span>)</span> 
        <span>exit_with_error</span><span>(</span><span>ERR_SOC_CREATE</span><span>);</span>

    <span>struct</span> <span>sockaddr_in</span> <span>addr_in</span> <span>=</span> <span>{.</span><span>sin_family</span> <span>=</span> <span>AF_INET</span><span>,</span>
                                  <span>.</span><span>sin_addr</span><span>.</span><span>s_addr</span> <span>=</span> <span>INADDR_ANY</span><span>,</span>
                                  <span>.</span><span>sin_port</span> <span>=</span> <span>htons</span><span>(</span><span>DEFAULT_PORT</span><span>)};</span>
    <span>memset</span><span>(</span><span>addr_in</span><span>.</span><span>sin_zero</span><span>,</span> <span>&#39;\0&#39;</span><span>,</span> <span>sizeof</span><span>(</span><span>addr_in</span><span>.</span><span>sin_zero</span><span>));</span>

    <span>// Bind the socket to the address and port</span>
    <span>if</span> <span>(</span><span>bind</span><span>(</span><span>server_sock_fd</span><span>,</span> <span>(</span><span>struct</span> <span>sockaddr</span> <span>*</span><span>)</span><span>&amp;</span><span>addr_in</span><span>,</span>
             <span>sizeof</span><span>(</span><span>struct</span> <span>sockaddr</span><span>))</span> <span>==</span> <span>-</span><span>1</span><span>)</span>
        <span>exit_with_error</span><span>(</span><span>ERR_SOC_BIND</span><span>);</span>

    <span>// Start listening for incoming connections</span>
    <span>if</span> <span>(</span><span>listen</span><span>(</span><span>server_sock_fd</span><span>,</span> <span>DEFAULT_BACKLOG</span><span>)</span> <span>&lt;</span> <span>0</span><span>)</span>
        <span>exit_with_error</span><span>(</span><span>ERR_SOC_LISTEN</span><span>);</span>   

    <span>int</span> <span>client_sock_fd</span><span>;</span>
    <span>int</span> <span>addr_in_len</span> <span>=</span> <span>sizeof</span><span>(</span><span>addr_in</span><span>);</span>
    <span>for</span> <span>(;;)</span> <span>{</span>
        <span>// A cliet has made a request</span>
        <span>client_sock_fd</span> <span>=</span> <span>accept</span><span>(</span><span>server_sock_fd</span><span>,</span> <span>(</span><span>struct</span> <span>sockaddr</span> <span>*</span><span>)</span><span>&amp;</span><span>addr_in</span><span>,</span>
                                <span>(</span><span>socklen_t</span> <span>*</span><span>)</span><span>&amp;</span><span>addr_in_len</span><span>);</span>
        <span>if</span> <span>(</span><span>client_sock_fd</span> <span>==</span> <span>-</span><span>1</span><span>)</span> <span>{</span>
            <span>// TODO:	LOG ERROR BUT DON &#39;T EXIT</span>
            <span>exit_with_error</span><span>(</span><span>ERR_SOC_ACCEPT</span><span>);</span>
        <span>}</span>
        <span>pid_t</span> <span>proc</span> <span>=</span> <span>fork</span><span>();</span>
        <span>if</span> <span>(</span><span>proc</span> <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
            <span>// log error</span>
            <span>// Close client</span>
            <span>close</span><span>(</span><span>client_sock_fd</span><span>);</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>proc</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>// We serve the request on a different </span>
            <span>// subprocess</span>
            <span>server_proc_req</span><span>(</span><span>client_sock_fd</span><span>);</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>// We keep track of the number of forks </span>
            <span>// the parent is creating</span>
            <span>cur_forks</span><span>++</span><span>;</span>
            <span>// No reason to keep this open in the parent</span>
            <span>// We close it</span>
            <span>close</span><span>(</span><span>client_sock_fd</span><span>);</span>
        <span>}</span>
        <span>// Clean up some finished sub-processes</span>
        <span>if</span> <span>(</span><span>!</span><span>(</span><span>cur_forks</span><span>&lt;</span><span>max_forks</span><span>))</span> <span>{</span>
            <span>while</span> <span>(</span><span>waitpid</span><span>(</span><span>-</span><span>1</span><span>,</span> <span>NULL</span><span>,</span> <span>WNOHANG</span><span>)</span> <span>&gt;</span> <span>0</span><span>)</span> <span>{</span>
                <span>cur_forks</span><span>--</span><span>;</span>
            <span>}</span>
        <span>}</span>

    <span>}</span>
    <span>close</span><span>(</span><span>server_sock_fd</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>We start by creating <code>server_sock_fd</code>, which binds and listens to <code>DEFAULT_PORT=8080</code>. If those operations fail, the code exits and returns either <code>ERR_SOC_BIND</code> or <code>ERR_SOC_LISTEN</code>, depending on the error.</p>

<p>The <code>DEFAULT_BACKLOG</code> refers to the max length of the (internal) queue of pending socket connections <code>server_sock_fd</code> can grow to. If a connection request arrives when the (internal) queue has more elements than <code>DEFAULT_BACKLOG</code> , the client may receive an error indicating <code>ECONNREFUSED</code>.</p>

<p>If the first step is successful, we enter an infinite loop in which we accept new connections. Then, we process each incoming request in its subprocess (using fork()).</p>

<p>There’s a max limit on the number of parallel forks we can have (see <code>max_forks</code>). Our code keeps track of the running number of forks through <code>cur_forks</code>. Whenever <code>cur_forks</code> is close to the limit, we start reaping the zombie sub-processes using <code>waitpid(...)</code>.</p>

<p>The function responsible with processing the request (<code>server_proc_req</code>) looks like this:</p>

<div><div><pre><code><span>#define REQ_SIZE (1 &lt;&lt; 13)
#define REQ_RES_SIZE (1 &lt;&lt; 4)
#define REP_MAX_SIZE (REP_H_FMT_LEN + REP_MAX_CNT_SIZE)
</span>
<span>void</span> <span>server_proc_req</span><span>(</span><span>int</span> <span>client_sock_fd</span><span>)</span> <span>{</span>
    <span>char</span> <span>rep_buff</span><span>[</span><span>REP_MAX_SIZE</span><span>]</span> <span>=</span> <span>{</span><span>0</span><span>};</span>
    <span>char</span> <span>req_buff</span><span>[</span><span>REQ_SIZE</span><span>]</span> <span>=</span> <span>{</span><span>0</span><span>};</span>
    <span>char</span> <span>http_req_res_buff</span><span>[</span><span>REQ_RES_SIZE</span><span>]</span> <span>=</span> <span>{</span><span>0</span><span>};</span>
    <span>int</span> <span>rec_status</span> <span>=</span> <span>server_receive</span><span>(</span><span>client_sock_fd</span><span>,</span> <span>req_buff</span><span>);</span>
    <span>int</span> <span>rep_status</span><span>;</span>
    <span>if</span> <span>(</span><span>rec_status</span> <span>==</span> <span>SR_CON_CLOSE</span><span>)</span> <span>{</span>
        <span>// Connecon closed by peer</span>
        <span>// There &#39;s no reason to send anything further</span>
        <span>exit</span><span>(</span><span>EXIT_SUCCESS</span><span>);</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>rec_status</span> <span>==</span> <span>SR_READ_ERR</span> <span>||</span> <span>rec_status</span> <span>==</span> <span>SR_READ_OVERFLOW</span><span>)</span> <span>{</span>
        <span>// Cannot Read Request(SR_READ_ERR) OR</span>
        <span>// Request is bigger than(REQ_SIZE)</span>
        <span>// In this case we return 400(BAD REQUEST)</span>
        <span>rep_status</span> <span>=</span> <span>set_http_rep_400</span><span>(</span><span>rep_buff</span><span>);</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>http_req_is_get</span><span>(</span><span>req_buff</span><span>))</span> <span>{</span>
        <span>// Request is a valid GET</span>
        <span>if</span> <span>(</span><span>http_req_is_home</span><span>(</span><span>req_buff</span><span>))</span> <span>{</span>
            <span>// The resource is &#34;/&#34; we return posts[0]</span>
            <span>rep_status</span> <span>=</span> <span>set_http_rep_200</span><span>(</span><span>posts</span><span>[</span><span>0</span><span>].</span><span>content_type</span><span>,</span> <span>posts</span><span>[</span><span>0</span><span>].</span><span>body</span><span>,</span>
                                          <span>strlen</span><span>(</span><span>posts</span><span>[</span><span>0</span><span>].</span><span>body</span><span>)</span> <span>+</span> <span>1</span><span>,</span> <span>rep_buff</span><span>);</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>// The resource is different than &#34;/&#34;</span>
            <span>size_t</span> <span>p_idx</span><span>;</span>
            <span>set_http_req_res</span><span>(</span><span>req_buff</span><span>,</span> <span>5</span><span>,</span> <span>http_req_res_buff</span><span>);</span>
            <span>if</span> <span>(</span><span>set_post_idx</span><span>(</span><span>&amp;</span><span>p_idx</span><span>,</span> <span>http_req_res_buff</span><span>)</span> <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
                <span>// If the resource is not a number, or is a number</span>
                <span>// out of range we return 404 NOT FOUND</span>
                <span>rep_status</span> <span>=</span> <span>set_http_rep_404</span><span>(</span><span>rep_buff</span><span>);</span>
            <span>}</span> <span>else</span> <span>{</span>
                <span>// We return the corresponding post based on the index</span>
                <span>struct</span> <span>post_s</span> <span>post</span> <span>=</span> <span>posts</span><span>[</span><span>p_idx</span><span>];</span>
                <span>rep_status</span> <span>=</span> <span>set_http_rep_200</span><span>(</span><span>post</span><span>.</span><span>content_type</span><span>,</span> <span>post</span><span>.</span><span>body</span><span>,</span>
                                              <span>strlen</span><span>(</span><span>post</span><span>.</span><span>body</span><span>)</span> <span>+</span> <span>1</span><span>,</span> <span>rep_buff</span><span>);</span>
            <span>}</span>
        <span>}</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>// The request looks valid but it &#39;s not a get</span>
        <span>// We return 501</span>
        <span>rep_status</span> <span>=</span> <span>set_http_rep_501</span><span>(</span><span>rep_buff</span><span>);</span>
    <span>}</span>

    <span>if</span> <span>(</span><span>rep_status</span> <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
        <span>// There was an error constructing the response</span>
        <span>// TODO LOG</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>server_send</span><span>(</span><span>client_sock_fd</span><span>,</span> <span>rep_buff</span><span>);</span>
    <span>}</span>
    <span>close</span><span>(</span><span>client_sock_fd</span><span>);</span>
    <span>exit</span><span>(</span><span>EXIT_SUCCESS</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>We define three buffers:</p>
<ul>
  <li><code>rep_buff</code> - Here is where we keep the response we are sending back to the client;</li>
  <li><code>req_buff</code> - This contains the request coming from the client;</li>
  <li><code>http_req_res_buff</code> - Here we keep the resource (<code>posts</code> index) we want to access. This is something we extract from <code>req_buff</code>.</li>
</ul>

<p>The most important functions called from <code>server_proc_req</code> are <code>server_receive</code> and <code>server_send</code>. These two methods read and write data to/from the socket.</p>

<p>The code is quite straight-forward:</p>

<div><div><pre><code><span>enum</span> <span>server_receive_ret</span> <span>{</span>
    <span>SR_CON_CLOSE</span> <span>=</span> <span>-</span><span>1</span><span>,</span>
    <span>SR_READ_ERR</span> <span>=</span> <span>-</span><span>2</span><span>,</span>
    <span>SR_READ_OVERFLOW</span> <span>=</span> <span>-</span><span>3</span>
<span>};</span>
<span>static</span> <span>int</span> <span>server_receive</span><span>(</span><span>int</span> <span>client_sock_fd</span><span>,</span> <span>char</span> <span>*</span><span>req_buff</span><span>)</span> <span>{</span>
    <span>int</span> <span>b_req</span> <span>=</span> <span>0</span><span>;</span>
    <span>int</span> <span>tot_b_req</span> <span>=</span> <span>0</span><span>;</span>
    <span>while</span> <span>((</span><span>b_req</span> <span>=</span> <span>recv</span><span>(</span><span>client_sock_fd</span><span>,</span> <span>&amp;</span><span>req_buff</span><span>[</span><span>tot_b_req</span><span>],</span>
                         <span>REQ_SIZE</span> <span>-</span> <span>tot_b_req</span><span>,</span> <span>0</span><span>))</span> <span>&gt;</span> <span>0</span><span>)</span> <span>{</span>
        <span>/* Connection was closed by the peer */</span>
        <span>if</span> <span>(</span><span>b_req</span> <span>==</span> <span>0</span><span>)</span> <span>return</span> <span>SR_CON_CLOSE</span><span>;</span>
        <span>/* Reading Error */</span>
        <span>if</span> <span>(</span><span>b_req</span> <span>==</span> <span>-</span><span>1</span><span>)</span> <span>return</span> <span>SR_READ_ERR</span><span>;</span>
        <span>tot_b_req</span> <span>+=</span> <span>b_req</span><span>;</span>
        <span>/* HTTP Requst is sent */</span>
        <span>if</span> <span>(</span><span>http_req_is_final</span><span>(</span><span>req_buff</span><span>,</span> <span>tot_b_req</span><span>))</span> <span>break</span><span>;</span>
        <span>/* req_buff overflows */</span>
        <span>if</span> <span>(</span><span>tot_b_req</span> <span>&gt;=</span> <span>REQ_SIZE</span><span>)</span> <span>return</span> <span>SR_READ_OVERFLOW</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>tot_b_req</span><span>;</span>
<span>}</span>

<span>enum</span> <span>server_send_errno</span> <span>{</span> <span>SS_ERROR</span> <span>=</span> <span>-</span><span>1</span> <span>};</span>
<span>static</span> <span>int</span> <span>server_send</span><span>(</span><span>int</span> <span>client_sock_fd</span><span>,</span> <span>char</span> <span>*</span><span>rep_buff</span><span>)</span> <span>{</span>
    <span>int</span> <span>w_rep</span> <span>=</span> <span>0</span><span>;</span>
    <span>int</span> <span>tot_w_rep</span> <span>=</span> <span>0</span><span>;</span>
    <span>size_t</span> <span>total</span> <span>=</span> <span>strlen</span><span>(</span><span>rep_buff</span><span>)</span> <span>+</span> <span>1</span><span>;</span>
    <span>while</span> <span>((</span><span>w_rep</span> <span>=</span> <span>send</span><span>(</span><span>client_sock_fd</span><span>,</span> <span>rep_buff</span><span>,</span> <span>total</span> <span>-</span> <span>tot_w_rep</span><span>,</span> <span>0</span><span>))</span> <span>&gt;</span> <span>0</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>w_rep</span> <span>&lt;</span> <span>0</span><span>)</span> <span>return</span> <span>SS_ERROR</span><span>;</span>
        <span>tot_w_rep</span> <span>+=</span> <span>w_rep</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>tot_w_rep</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>The two methods (<code>server_receive</code> and <code>server_send</code>) are actual wrappers over <code>send()</code> and <code>recv()</code> that add additional checks on-top.</p>

<p>For example, in <code>server_receive</code> we make sure we read bytes (<code>b_req</code>) up until we encounter <code>CRLF</code> (<code>http_req_is_final</code>) or we overflow (we read more bytes than <code>req_buff</code> can hold).</p>

<p>In <code>server_send</code> we make sure that we send all the bytes from <code>rep_buff</code>. Calling <code>send</code> once doesn’t guarantee that; that’s why we do everything in a loop that checks how manys bytes we’ve sent (using <code>w_rep</code>).</p>

<p>Lastly, the methods: <code>set_http_rep_200</code>, <code>set_http_rep_404</code>, <code>set_http_rep_500</code> are all “overloaded” (if we can call them like this) for the <code>set_http_rep_ret</code> method:</p>

<div><div><pre><code><span>#define REP_FMT &#34;%s%s\n&#34;
#define REP_H_FMT &#34;HTTP/%s %d \nContent-Type: %s\nContent-Length: %zu\n\n&#34;
#define REP_H_FMT_LEN (strlen(REP_H_FMT) + 1 + (1 &lt;&lt; 6))
#define REP_MAX_CNT_SIZE (1 &lt;&lt; 19)
#define REP_MAX_SIZE (REP_H_FMT_LEN + REP_MAX_CNT_SIZE)
</span>
<span>enum</span> <span>set_http_rep_ret</span> <span>{</span>
    <span>SHR_ENC_ERROR</span> <span>=</span> <span>-</span><span>1</span><span>,</span>
    <span>SHR_HEAD_OVERFLOW</span> <span>=</span> <span>-</span><span>2</span><span>,</span>
    <span>SHR_CNT_ENC_EROR</span> <span>=</span> <span>-</span><span>3</span><span>,</span>
    <span>SHR_CNT_OVERFLOW</span> <span>=</span> <span>-</span><span>4</span>
<span>};</span>
<span>static</span> <span>int</span> <span>set_http_rep</span><span>(</span><span>const</span> <span>char</span> <span>*</span><span>http_ver</span><span>,</span> <span>const</span> <span>http_s_code</span> <span>s_code</span><span>,</span>
                        <span>const</span> <span>char</span> <span>*</span><span>cnt_type</span><span>,</span> <span>const</span> <span>char</span> <span>*</span><span>cnt</span><span>,</span>
                        <span>const</span> <span>size_t</span> <span>cnt_size</span><span>,</span> <span>char</span> <span>*</span><span>rep_buff</span><span>)</span> <span>{</span>
    <span>char</span> <span>h_buff</span><span>[</span><span>REP_H_FMT_LEN</span><span>]</span> <span>=</span> <span>{</span><span>0</span><span>};</span>
    <span>int</span> <span>bw_head</span> <span>=</span> <span>snprintf</span><span>(</span><span>h_buff</span><span>,</span> <span>REP_H_FMT_LEN</span><span>,</span> <span>REP_H_FMT</span><span>,</span> <span>http_ver</span><span>,</span> <span>s_code</span><span>,</span>
                           <span>cnt_type</span><span>,</span> <span>cnt_size</span><span>);</span>
    <span>if</span> <span>(</span><span>bw_head</span> <span>&lt;</span> <span>0</span><span>)</span>
        <span>return</span> <span>SHR_ENC_ERROR</span><span>;</span>
    <span>else</span> <span>if</span> <span>(</span><span>bw_head</span> <span>&gt;=</span> <span>REP_H_FMT_LEN</span><span>)</span>
        <span>return</span> <span>SHR_HEAD_OVERFLOW</span><span>;</span>
    <span>size_t</span> <span>buff_size</span> <span>=</span> <span>bw_head</span> <span>+</span> <span>cnt_size</span><span>;</span>
    <span>if</span> <span>(</span><span>buff_size</span> <span>&gt;</span> <span>REP_MAX_SIZE</span><span>)</span> <span>return</span> <span>SHR_CNT_OVERFLOW</span><span>;</span>
    <span>int</span> <span>bw_rep</span> <span>=</span> <span>snprintf</span><span>(</span><span>rep_buff</span><span>,</span> <span>buff_size</span><span>,</span> <span>REP_FMT</span><span>,</span> <span>h_buff</span><span>,</span> <span>cnt</span><span>);</span>
    <span>if</span> <span>(</span><span>bw_rep</span> <span>&lt;</span> <span>0</span><span>)</span> <span>return</span> <span>SHR_CNT_ENC_EROR</span><span>;</span>
    <span>return</span> <span>bw_rep</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>This method constructs the message we will send back to the browser and makes sure we don’t overflow. It starts by building the header response:</p>

<div><div><pre><code>&#34;HTTP/%s %d \nContent-Type: %s\nContent-Length: %zu\n\n&#34;
</code></pre></div></div>

<p>And then adding the actual content:</p>



<p>I’ve used <code>snprintf()</code> for both string concatenations to check for possible overflows or encoding errors.</p>

<p>That’s all.</p>



<p>All in all, <code>microblog.c</code> was an exciting experiment. The code is to be taken lightly: like a combination of software minimalism, poorly written C (waiting for feedback, actually), and a late April’s Fools Day joke.</p>



<p><a href="https://www.reddit.com/r/C_Programming/comments/u6eeno/a_blog_that_is_a_single_executable_binary/">reddit</a>, <a href="https://lobste.rs/s/oj0yi5/blog_is_single_executable_binary">lobste.rs</a>, <a href="https://news.ycombinator.com/item?id=31081049">hacker news</a>.</p>

        
      </section>

      

      

      
    </div></div>
  </body>
</html>
