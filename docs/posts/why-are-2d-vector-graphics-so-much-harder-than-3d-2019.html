<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.mecheye.net/2019/05/why-is-2d-graphics-is-harder-than-3d-graphics/">Original</a>
    <h1>Why are 2D vector graphics so much harder than 3D? (2019)</h1>
    
    <div id="readability-page-1" class="page"><div>
		
<p>
There’s a lot of fantastic research into 2D graphics rendering these days. Petr Kobalicek and Fabian Yzerman have been working on <a href="https://blend2d.com/">Blend2D</a>, one of the fastest and most accurate CPU rasterizers on the market, with a novel JIT approach. Patrick Walton of Mozilla has explored not just one, but <a href="https://github.com/pcwalton/pathfinder/wiki/Related-approaches">three separate approaches</a> in Pathfinder, culminating in now Pathfinder V3. Raph Levien has built a <a href="https://github.com/linebender/piet-metal">compute-based pipeline</a> based on Gan et al’s ahead-of-its-time <a href="http://w3.impa.br/~diego/projects/GanEtAl14/">2014 paper on vector textures</a>. Signed distance fields seem to be getting some further development from both <a href="https://twitter.com/adamjsimmons/status/730911372532322304">Adam Simmons</a> and <a href="https://www.merl.com/publications/docs/TR2000-15.pdf">Sarah Frisken</a> independently.
</p>

<p>
One might wonder: why is there so much commotion about 2D? It seriously can’t be that much harder than 3D, right? 3D is a whole other dimension! Real-time raytracing is around the corner, with accurate lighting and and yet we can’t manage dinky 2D graphics with solid colors?
</p>

<p>
To those not well-versed in the details of the modern GPU, it’s a very surprising conclusion! But 2D graphics has plenty of unique constraints that make it a difficult problem to solve, and one that doesn’t lend itself well to parallel approaches. Let’s take a stroll down history lane and trace the path that led us here in the first place, shall we?
</p>

<h2>The rise of PostScript</h2>

<p> In the beginning, there was the plotter. The first graphics devices to interact with computers were <a href="http://www.hpmuseum.net/display_item.php?hw=82">“plotters”</a>, which had one or multiple pens and an arm that could move over the paper. Things were drawn by <a href="https://www.youtube.com/watch?v=zyp68emXMZM">submitting a “pen-down” command, moving the arm in some unique way, possibly curved, and then submitting “pen-up”</a>. HP, manufacturer of some of the earliest plotter printers, used a variant of BASIC called “AGL” on the host computer, which then would send commands to the plotter peripheral itself in a another language like <a href="https://en.wikipedia.org/wiki/HP-GL">HP-GL</a>. During the 1970s, we saw the rise of affordable graphics terminals, starting with the <a href="https://en.wikipedia.org/wiki/Tektronix_4010">Tektronix 4010</a>. It has a CRT for its display, but don’t be fooled: it’s <em>not</em> a pixel display. Tektronix came from the analog oscilloscope industry, and these machines work by <a href="https://www.youtube.com/watch?v=tpD1QXvtlcg">driving the electron beam in a certain path</a>, not in a grid-like order. As such, the Tektronix 4010 didn’t have pixel output. Instead, you sent commands to it with <a href="http://vt100.net/docs/vt3xx-gp/chapter13.html#S13.14">a simple graphing mode</a> that could draw lines but, again, in a pen-up pen-down fashion.
</p>
<p>
Like a lot of other inventions, this all changed at Xerox PARC. Researchers there were starting to develop a new kind of printer, one that was more computationally expressive than what was seen in plotters. This new printer was based on a small, stack-based Turing-complete language similar to Forth, and they named it… the <a href="https://en.wikipedia.org/wiki/Interpress">Interpress</a>! Xerox, obviously, was unable to sell it, so the inventors jumped ship and founded a small, scrappy startup named “Adobe”. They took Interpress with them and tweaked it until was no longer recognizable as Interpress, and they renamed it PostScript. Besides the cute, Turing-complete stack-language language it comes with to calculate its shapes, the original <a href="http://www.adobe.com/content/dam/acom/en/devnet/actionscript/articles/PLRM.pdf">PostScript Language Reference</a> marks up an Imaging Model in Chapter 4, near-identical to the APIs we widely see today. Example 4.1 of the manual has a code example which can be translated to HTML5 &lt;canvas&gt; nearly line-by-line.
</p>
<pre title="">/box {                  function box() {
    newpath                 ctx.beginPath();
    0 0 moveto              ctx.moveTo(0, 0);
    0 1 lineto              ctx.lineTo(0, 1);
    1 1 lineto              ctx.lineTo(1, 1);
    1 0 lineto              ctx.lineTo(1, 0);
    closepath               ctx.closePath();
} def                   }
                        
gsave                   ctx.save();
72 72 scale             ctx.scale(72, 72);
box fill                box(); ctx.fill();
2 2 translate           ctx.translate(2, 2);
box fill                box(); ctx.fill();
grestore                ctx.restore();
</pre>

<p>
This is not a coincidence.
</p>
<p>
Apple’s Steve Jobs had met the Interpress engineers on his visit to PARC. Jobs thought that the printing business would be lucrative, and tried to simply buy Adobe at birth. Instead, Adobe countered and eventually sold a five-year license for PostScript to Apple. The third pillar in Jobs’s printing plan was funding a small startup, Aldus, which was making a WSYWIG app to create PostScript documents, “PageMaker”. In early 1985, Apple released the first PostScript-compliant printer, the Apple LaserWriter. The combination of the point-and-click Macintosh, PageMaker, and the LaserWriter singlehandedly turned the printing industry on its head, giving way to “desktop publishing” and solidifying PostScript its place in history. The main competition, Hewlett-Packward, would eventually license PostScript for its competing LaserJet series of printers in 1991, after consumer pressure.
</p>
<p>
PostScript slowly moved from being a printer control language to a file format in and of itself. Clever programmers noticed the underlying PostScript sent to the printers, and started writing PostScript documents by hand, introducing charts and graphs and art to their documents, with the PostScript evaluated for on-screen display. Demand sprung up for graphics outside of the printer! Adobe noticed, and quickly rushed out the <a href="https://en.wikipedia.org/wiki/Encapsulated_PostScript">Encapsulated PostScript</a> format, which was nothing more than a few specially-formatted PostScript comments to give metadata about the size of the image, and restrictions about using printer-centric commands like “page feed”. That same year, 1985, Adobe started development on “Illustrator”, an application for artists to draw Encapsulated PostScript files through a point-and-click interface. These files could then be placed into Word Processors, which then created… PostScript documents which were sent to PostScript printers. The whole world was PostScript, and Adobe couldn’t be happier. Microsoft, while working on Windows 1.0, wanted to create its own graphics API for developers, and a primary goal was making it compatible with existing printers so the graphics could be sent to printers as easily as a screen. This API was eventually released as <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd145203(v=vs.85).aspx">GDI</a>, a core component used by every engineer during Windows’s meteoric rise to popularity in the 90s. Generations of programmers developing for the Windows platform started to unknowingly equate “2D vector graphics” with the PostScript imaging model, cementing its status as <em>the</em> 2D imaging model.
</p>
<p>
The only major problem with PostScript was its Turing-completeness — viewing page 86 of a document means first running the script for pages 1-85. And that could be slow. Adobe caught wind of this user complaint, and decided to create a new document format that didn’t have these restrictions, called the “Portable Document Format”, or “PDF” for short. It threw out the programming language — but the graphics technology stayed the same. A quote from the <a href="http://www.adobe.com/content/dam/acom/en/devnet/acrobat/pdfs/pdf_reference_1-7.pdf#page=34">PDF specification, Chapter 2.1, “Imaging Model”</a>: </p><blockquote>At the heart of PDF is its ability to describe the appearance of sophisticated graphics and typography. This ability is achieved through the use of the <i>Adobe imaging model</i>, the same high-level, device-independent representation used in the PostScript page description language.</blockquote><p> By the time the W3C wanted to develop a 2D graphics markup language for the web, Adobe championed the XML-based <a href="https://www.w3.org/TR/1998/NOTE-PGML-19980410">PGML</a>, which had the PostScript graphics model front and center. </p><blockquote>PGML should encompass the PDF/PostScript imaging model to guarantee a 2D scalable graphics capability that satisfies the needs of both both casual users and graphics professionals.</blockquote><p> Microsoft’s competing format, <a href="https://www.w3.org/TR/NOTE-VML">VML</a>, was based on GDI, which as we know was based on PostScript. The two competing proposals, both still effectively PostScript, were combined to make up W3C’s “Scalable Vector Graphics” (“SVG”) technology we know and love today.
</p>
<p>
Even though it’s old, let’s not pretend that the innovations PostScript brought to the world are anything less than a technological marvel. Apple’s PostScript printer, the LaserWriter, had a CPU twice as powerful as the Macintosh that was controlling it, just to interpret the PostScript and rasterize the vector paths to points on paper. That might seem excessive, but if you were already buying a fancy printer with a <em>laser</em> in it, the expensive CPU on the side doesn’t seem so expensive in comparison. In its first incarnation, PostScript invented a fairly sophisticated imaging model, with all the features that we take for granted today. But the most powerful, wowing feature? Fonts. Fonts were, at the time, drawn by hand with ruler and protractor, and cast onto film, to be <a href="https://en.wikipedia.org/wiki/Phototypesetting">printed photochemically</a>. In 1977, Donald Knuth showed the world what could be with his <a href="https://en.wikipedia.org/wiki/Metafont">METAFONT</a> system, introduced together with his typesetting application TeX, but it didn’t catch on. It required the user to describe fonts mathematically, using brushes and curves, which wasn’t a skill that most fontgraphers really wanted to learn. And the fancy curves turned into mush at small sizes: the printers of the time did not have dots small enough, so they tended to bleed and blur into each other. Adobe’s PostScript proposed a novel solution to this: an algorithm to “snap” these paths to the coarser grids that printers had. This is known as “grid-fitting”. To prevent the geometry from getting too distorted, they allowed fonts to specify “hints” about what parts of the geometry were the most important, and how much should be preserved.
</p>
<p>
Adobe’s original business model was to sell this font technology to people that make printers, and sell special recreations of fonts, with added hints, to publishers, which is why Adobe, to this day, sells their versions of <a href="http://www.myfonts.com/fonts/adobe/times/">Times</a> and <a href="http://www.myfonts.com/fonts/adobe/futura/">Futura</a>. Adobe can do this, by the way, because fonts, or, more formally, “typefaces”, are one of <a href="https://www.ecfr.gov/cgi-bin/text-idx?node=se37.1.202_11">five things explicitly excluded by US Copyright Law</a>, since they were originally designated as “too plain or utilitarian to be creative works”. What <em>is</em> sold and copyrighted instead is the <em>digital program</em> that reproduces the font on the screen. So, to prevent people from copying Adobe’s fonts and adding their own, the <a href="https://www-cdf.fnal.gov/offline/PostScript/T1_SPEC.PDF">Type 1 Font</a> format was originally proprietary to Adobe and contained “font encryption” code. Only Adobe’s PostScript could interpret a Type 1 Font, and only Adobe’s Type 1 Fonts had the custom hinting technology allowing them to be visible at small sizes.
</p>
<p>
Grid fitting, by the way, was so universally popular that when Microsoft and Apple were tired of paying licensing fees to Adobe, they invented an alternate method for their font file competitor, <a href="https://developer.apple.com/fonts/TrueType-Reference-Manual/">TrueType</a>. Instead of specifying declarative “hints”, TrueType gives the font author a <a href="https://developer.apple.com/fonts/TrueType-Reference-Manual/RM03/Chap3.html">complete Turing-complete stack language</a> so that the author can control every part of grid-fitting (coincidentally avoiding Adobe’s patents on declarative “hints”). For years, the wars between the Adobe-backed Type 1 and the TrueType raged on, with font foundries being stuck in the middle, having to provide both formats to their users. Eventually, the industry reached a compromise: <a href="https://www.microsoft.com/en-us/Typography/OpenTypeSpecification.aspx">OpenType</a>. But rather than actually decide a winner, they simply plopped both specifications into one file format: Adobe, now in the business of selling Photoshop and Illustrator rather than Type 1 Fonts, removed the encryption bits, gave the format a small amount of spit polish, and released <a href="http://www.adobe.com/content/dam/Adobe/en/devnet/font/pdfs/5176.CFF.pdf">CFF</a> / <a href="http://www.adobe.com/content/dam/Adobe/en/devnet/font/pdfs/5177.Type2.pdf">Type 2</a> fonts, which were grafted into OpenType wholesale as the <a href="https://www.microsoft.com/typography/otspec/cff.htm">cff table</a>. TrueType, on the other hand, got shoved in as <a href="https://www.microsoft.com/typography/otspec/otff.htm#ttTables">glyf</a> and other tables. OpenType, while ugly, seemed to get the job done for users, mostly by war of endurance: just require that all software supports both kinds of fonts, because OpenType requires you to support both kinds of fonts.
</p>
<p>
Of course, we’re forced to ask: if PostScript didn’t become popular, what might have happened instead? It’s worth looking at some other alternatives. The previously mentioned METAFONT didn’t use filled paths. Instead, Knuth, in typical Knuth fashion, rigorously defines in his paper  <a href="http://www.math.lsa.umich.edu/~millerpd/docs/501_Winter13/Knuth79.pdf">Mathematical Typography</a> the concept of a curve that is “most pleasing”. You specify a number of points, and some algorithm finds the one correct “most pleasing” curve through them. You can stack these paths on top of each other: define such a path as a “pen”, and then “drag the pen” through some other path. Knuth, a computer scientist at heart, managed to introduce recursion to path stroking.  Knuth’s thesis student, John Hobby, designed and implemented algorithms for calculating <a href="http://i.stanford.edu/pub/cstr/reports/cs/tr/85/1047/CS-TR-85-1047.pdf">the “most pleasing curve”</a>, <a href="http://ect.bell-labs.com/who/hobby/thesis.pdf">the “flattening” of the nesting of paths</a>, <em>and</em> <a href="http://ect.bell-labs.com/who/hobby/87_2-04.pdf">rasterizing such curves</a>. For more on METAFONT, curves, and the history of font technology in general, I <em>highly</em> recommend the detailed reference of <a href="http://shop.oreilly.com/product/9780596102425.do">Fonts &amp; Encodings</a>, and the papers of <a href="http://ect.bell-labs.com/who/hobby/Publications.shtml">John D. Hobby</a>.
</p>
<p>
Thankfully, the renewed interest in 2D graphics research means that Knuth and Hobby’s splines are not entirely forgotten. While definitely arcane and non-traditional, they recently made their way into <a href="https://bosker.wordpress.com/2013/11/13/beyond-bezier-curves/">Apple’s iWork Suite</a> where they are now the default spline type.
</p>

<h2> The rise of triangles </h2>

<p>
Without getting too into the math weeds, at a high-level, we call approaches like Bezier curves and Hobby splines <a href="https://en.wikipedia.org/wiki/Implicit_curve">implicit curves</a>, because they are specified as a mathematical function which generates the curve. They are smooth functions which look good at any resolution and zoom level, which happen to be good traits for a 2D image designed to be scalable.
</p>
<p>
2D graphics started and maintained forward momentum around these implicit curves, by near necessity in their use in modelling human letterforms and glyphs. The hardware and software to compute these paths in real-time was expensive, but since the big industry push for vector graphics came from the printing industry, most of the rest of the existing industrial equipment was already plenty more expensive than the laser printer with the fancy CPU.
</p>
<p>
3D graphics, however, had a very different route. From the very beginning, the near-universal approach was to use straight-edged polygons, often times manually <a href="https://www.computerhistory.org/revolution/computer-graphics-music-and-art/15/206/560">marked up</a> and <a href="https://www.computerhistory.org/revolution/computer-graphics-music-and-art/15/206/556">entered into the computer by hand</a>. Not all approaches, though. The 3D equivalent of an implicit curve is an <a href="https://en.wikipedia.org/wiki/Implicit_surface">implicit surface</a>, made up of basic geometric primitives like spheres, cylinders and boxes. A perfect sphere with infinite resolution can be represented with a simple equation, so for organic geometry, it was a clear winner over <a href="https://www.youtube.com/watch?v=lAD6Obi7Cag">the polygon look of early 3D</a>. <a href="https://en.wikipedia.org/wiki/Mathematical_Applications_Group">MAGI</a> was one of a few companies pushing the limits of implicit surfaces, and combined with some clever artistic use of procedural textures, they won the contract with Disney to design the lightcycle sequences for the 1982 film Tron. Unfortunately, though, that approach quickly fell by the wayside. The number of triangles you could render in a scene was skyrocketing due to research into problems like “hidden surface removal” and faster CPUs, and for complex shapes, it was a lot easier for artists to think about polygons and vertices they could click and drag, rather than use combinations of boxes and cylinders to get the look they wanted.
</p>
<p>
This is not to say that implicit surfaces weren’t used in the modelling <em>process</em>. Tools like <a href="https://en.wikipedia.org/wiki/Catmull%E2%80%93Clark_subdivision_surface">Catmull-Clark subdivision</a> were a ubiquitous industry standard by the early 80s, allowing artists to put a smooth, organic look on otherwise simple geometry. Though Catmull-Clark wasn’t even framed as an “implicit surface” that can be computed with an equation until the early 2000s. Back then, it was seen as an iterative algorithm: a way to subdivide polygons into even more polygons.
</p>
<p>
Triangles reined supreme, and so followed the tools used to make 3D content. Up-and-coming artists for video games and CGI films were trained exclusively on polygon mesh modellers like Maya, 3DS Max and Softimage. As the “3D graphics accelerator” came onto the scene in late-80s, it was designed to accelerate the existing content out there: triangles. While some early GPU designs like the <a href="https://en.wikipedia.org/wiki/NV1">NVIDIA NV1</a> had some limited hardware-accelerated curve support, it was buggy and quickly dropped from the product line.
</p>
<p>
This culture mostly extends into what we see today. The dominant 2D imaging model, PostScript, started with a product that could render curves in “real-time”, while the 3D industry ignored curves as they were difficult to make work, relying on offline solutions to pre-transform curved surfaces into triangles.
</p>

<h2> Implicit surfaces rise from the dead </h2>

<p>
But why were implicit curves able to be done in real-time on 2D on a printer in the 80s, and yet 3D implicit curves are still too buggy near the early ’00s? Well, one answer is that Catmull-Clark is a lot more complicated than a Bezier curve. Bezier curves do exist in 3D, where they are known as B-splines, and they are computable, but they have the drawback that they limit the ways you can connect your mesh together. Surfaces like Catmull-Clark and NURBS allow for arbitrarily connected meshes to empower artists, but this can lead to polynomials greater than the fourth degree, which <a href="https://en.wikipedia.org/wiki/Abel%E2%80%93Ruffini_theorem">tend to have no closed-form solution</a>. Instead, what you get are approximations based on subdividing polygons, like what happens in Pixar’s <a href="http://graphics.pixar.com/opensubdiv/docs/intro.html">OpenSubdiv</a>. If someone ever finds an analytic closed-form solution to root-finding either Catmull-Clark or NURBS, Autodesk will pay a lot of money for it, for certain. Compared to these, triangles seem a lot nicer: simply compute <a href="https://fgiesen.wordpress.com/2013/02/06/the-barycentric-conspirac/">three linear plane equations</a> and you have yourself an easy test.
</p>
<p>
… but what if we don’t need an exact solution? That’s exactly what graphics developer of incredible renown
<a href="https://www.iquilezles.org/index.html">Íñigo Quílez</a> asked when doing research into implicit surfaces again. The solution? Signed distance fields. Instead of telling you the exact intersection point of the surface, it tells you how far away you are from a surface. Analoguous to an analytically computed integral vs. Euler integration, if you have the distance to the closest object, you can “march” through the scene, asking how far away you are at any given point and stepping that distance. Such surfaces have seen a brand new life through the demoscene and places like Shadertoy. A twist on the old MAGI approach to modelling brings us incredible gems like Quílez’s <a href="https://www.shadertoy.com/view/ldd3DX">Surfer Boy</a>, calculated in infinite precision like an implicit surface would. You don’t need to find the algebraic roots of Surfer Boy, you just feel it out as you march through.
</p>
<p>
The difficulty, of course, is that <em>only</em> a legitimate genius like Quílez can create Surfer Boy. There’s no existing tooling for signed-distance field geometry, it’s all code. That said, given the exciting resurgence of implicit surfaces for their organic, curved look, there’s now plenty of interest into the technique. MediaMolecule’s PS4 game <a href="https://www.playstation.com/en-us/games/dreams-ps4/">Dreams</a> is a content-creation kit built around combining implicit surfaces, <a href="http://advances.realtimerendering.com/s2015/AlexEvans_SIGGRAPH-2015-sml.pdf">requiring them to tear down and reinvent most of traditional graphics in the process</a>. It’s a promising approach, and the tools are <a href="https://www.twitch.tv/videos/411848857?t=6h55m34s">intuitive and fun</a>. <a href="https://www.oculus.com/medium">Oculus Medium</a> and <a href="http://on-demand.gputechconf.com/gtc/2017/presentation/s7777-florian-hoenig-a-road-to-3d-for-everyone.pdf">unbound.io</a> are also putting good research into the problem. It’s definitely a promising look into what the future of 3D graphics and next-generation tools might look like.
</p>
<p>But some of these approaches are less adaptable to 2D than you might think. Common 3D game scenes tend to have lush materials and textures but low geometry counts, as many critics and <a href="https://www.youtube.com/watch?v=00gAbgBu8R4">snake-oil salesman</a> are quick to point out. This means that we can rely on smaller amounts of anti-aliasing as silhouettes are not as majorly important. Approaches like 4x MSAA might cut the mustard for a lot of games, but for small fonts with solid colors, instead of <a href="https://magcius.github.io/xplain/article/rast1.html#antialiasing">16 fixed sample locations</a>, you would much rather compute <a href="http://nothings.org/gamedev/rasterize/">the exact area under the curve</a> for each pixel, giving you as much resolution as you want.
</p>
<p>
Rotating the viewport around in a 3D game has the effect of causing effects similar to <a href="https://en.wikipedia.org/wiki/Saccadic_masking">saccadic masking</a> as your brain re-adjusts to the new view. For a lot of games, this can help hide artifacts in post-processing effects like <a href="https://twitter.com/CypherSignal/status/793631118209781760">temporal antialiasing</a>, which Dreams and unbound.io heavily lean on to get good performance of their scene. Conversely, in a typical 2D scene, we don’t have this luxury of perspective, so attempting to use it will make our glyphs and shapes boil and jitter with those artifacts in full glory. 2D is viewed differently, and the expectations are higher. Stability is important as you zoom, pan, and scroll.
</p>
<p>
None of these effects are impossible to implement on a GPU, but they do show a radical departure from “3D” content, with different priorities. Ultimately, 2D graphics rendering is hard because it’s about shapes — accurate letterforms and glyphs — not materials and lighting, which is mostly a solid color. GPUs, through a consequence of history, chose not to focus on real-time implicit geometry like curves, but instead on everything that goes inside them. Maybe in a world where PostScript didn’t win, we would have a 2D imaging model that didn’t have Bezier as a core realtime requirement. And maybe in a world where triangles were replaced with better geometry representations sooner, we would see content creation tools focus on 3D splines, and GPUs that have realtime curves built right into the hardware. It’s always fun to imagine, after all.
</p>




			</div></div>
  </body>
</html>
