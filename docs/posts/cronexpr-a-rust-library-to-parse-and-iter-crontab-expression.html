<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://docs.rs/cronexpr/latest/cronexpr/">Original</a>
    <h1>Show HN: Cronexpr, a Rust library to parse and iter crontab expression</h1>
    
    <div id="readability-page-1" class="page"><div><p><code>cronexpr</code> is a library to parse and drive the crontab expression.</p>
<p>Here is a quick example that shows how to parse a cron expression and drive it with a timestamp:</p>

<div><pre><code> <span>use </span>std::str::FromStr;

 <span>use </span>cronexpr::MakeTimestamp;

 <span>let </span>crontab = cronexpr::parse_crontab(<span>&#34;2 4 * * * Asia/Shanghai&#34;</span>).unwrap();

 <span>assert!</span>(crontab.matches(<span>&#34;2024-09-24T04:02:00+08:00&#34;</span>).unwrap());
 <span>assert!</span>(!crontab.matches(<span>&#34;2024-09-24T04:01:00+08:00&#34;</span>).unwrap());

 <span>assert_eq!</span>(
     crontab
         .find_next(<span>&#34;2024-09-24T10:06:52+08:00&#34;</span>)
         .unwrap()
         .to_string(),
     <span>&#34;2024-09-25T04:02:00+08:00[Asia/Shanghai]&#34;
 </span>);

 <span>let </span>iter = crontab.iter_after(<span>&#34;2024-09-24T10:06:52+08:00&#34;</span>).unwrap();
 <span>assert_eq!</span>(
     iter.take(<span>5</span>)
         .map(|ts| ts.map(|ts| ts.to_string()))
         .collect::&lt;<span>Result</span>&lt;Vec&lt;<span>_</span>&gt;, cronexpr::Error&gt;&gt;()
         .unwrap(),
     <span>vec!</span>[
         <span>&#34;2024-09-25T04:02:00+08:00[Asia/Shanghai]&#34;</span>,
         <span>&#34;2024-09-26T04:02:00+08:00[Asia/Shanghai]&#34;</span>,
         <span>&#34;2024-09-27T04:02:00+08:00[Asia/Shanghai]&#34;</span>,
         <span>&#34;2024-09-28T04:02:00+08:00[Asia/Shanghai]&#34;</span>,
         <span>&#34;2024-09-29T04:02:00+08:00[Asia/Shanghai]&#34;</span>,
     ]
 );

 <span>let </span>iter = crontab.iter_after(<span>&#34;2024-09-24T10:06:52+08:00&#34;</span>).unwrap();
 <span>let </span>end = MakeTimestamp::from_str(<span>&#34;2024-10-01T00:00:00+08:00&#34;</span>).unwrap();
 <span>assert_eq!</span>(
     iter.take_while(|ts| ts.as_ref().map(|ts| ts.timestamp() &lt; end.<span>0</span>).unwrap_or(<span>true</span>))
         .map(|ts| ts.map(|ts| ts.to_string()))
         .collect::&lt;<span>Result</span>&lt;Vec&lt;<span>_</span>&gt;, cronexpr::Error&gt;&gt;()
         .unwrap(),
     <span>vec!</span>[
         <span>&#34;2024-09-25T04:02:00+08:00[Asia/Shanghai]&#34;</span>,
         <span>&#34;2024-09-26T04:02:00+08:00[Asia/Shanghai]&#34;</span>,
         <span>&#34;2024-09-27T04:02:00+08:00[Asia/Shanghai]&#34;</span>,
         <span>&#34;2024-09-28T04:02:00+08:00[Asia/Shanghai]&#34;</span>,
         <span>&#34;2024-09-29T04:02:00+08:00[Asia/Shanghai]&#34;</span>,
         <span>&#34;2024-09-30T04:02:00+08:00[Asia/Shanghai]&#34;</span>,
     ]
 );</code></pre></div>
<p>For more complex and edge cases, read the <a href="#edge-cases">Edge cases</a> section.</p>
<h2 id="syntax-overview"><a href="#syntax-overview">§</a>Syntax overview</h2>
<p>This crates supports all the syntax of <a href="https://en.wikipedia.org/wiki/Cron#Cron_expression">standard crontab</a> and most of the non-standard
extensions.</p>
<p>The mainly difference is that this crate always requires the timezone to be specified in the
crontab expression. This is because the timezone is necessary to determine the next timestamp.</p>
<div><pre><code>*    *    *    *    *    &lt;timezone&gt;
┬    ┬    ┬    ┬    ┬    ────┬────
│    │    │    │    │        |
│    │    │    │    │        └──── timezone     UTC, Asia/Shanghai, and so on
│    │    │    │    └───────────── day of week  0-7, SUN-SAT (0 or 7 is Sunday)
│    │    │    └────────────────── month        1-12, JAN-DEC
│    │    └─────────────────────── day of month 1-31
│    └──────────────────────────── hour         0-23
└───────────────────────────────── minute       0-59</code></pre></div>
<p>This crate also supports the following non-standard extensions:</p>
<ul>
<li><a href="#last-day-of-month-l">Last day of month (<code>L</code>)</a></li>
<li><a href="#nearest-weekday-1w-15w-etc">Nearest weekday (<code>1W</code>, <code>15W</code>, etc.)</a></li>
<li><a href="#last-day-of-week-5l">Last day of week (<code>5L</code>)</a></li>
<li><a href="#nth-day-of-week-53">Nth day of week (<code>5#3</code>)</a></li>
</ul>
<h2 id="timezone"><a href="#timezone">§</a>Timezone</h2>
<p>Timezone is parsed internally by <a href="https://docs.rs/jiff/0.1.13/x86_64-unknown-linux-gnu/jiff/tz/struct.TimeZone.html#method.get" title="associated function jiff::tz::TimeZone::get"><code>jiff::tz::TimeZone::get</code></a>. It supports all the
timezone names in the IANA Time Zone Database. See <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List">the list of time zones</a>.</p>
<h2 id="single-value"><a href="#single-value">§</a>Single value</h2>
<p>Every field (except timezone) can be a single value.</p>
<ul>
<li>For minutes, it can be from 0 to 59.</li>
<li>For hours, it can be from 0 to 23.</li>
<li>For days of month, it can be from 1 to 31.</li>
</ul>
<p>For months, it can be 1-12. Alternatively, it can be the first three letters of the English
name of the month (case-insensitive), such as <code>JAN</code>, <code>Feb</code>, etc. <code>JAN</code> will be mapped to 1,
<code>Feb</code> will be mapped to 2, and so on.</p>
<p>For days of week, it can be 0-7, where both 0 and 7 represent Sunday. Alternatively, it can be
the first three letters of the English name of the day (case-insensitive), such as <code>SUN</code>, <code>Mon</code>,
etc. <code>SUN</code> will be mapped to 0, <code>Mon</code> will be mapped to 1, and so on.</p>
<p>Days of week and days of month support extra syntax, read their dedicated sections below.</p>
<h2 id="asterisk"><a href="#asterisk">§</a>Asterisk</h2>
<p>Asterisks (also known as wildcard) represents “all”. For example, using <code>* * * * *</code> will run
every minute. Using <code>* * * * 1</code> will run every minute only on Monday.</p>
<h2 id="range"><a href="#range">§</a>Range</h2>
<p>Hyphen (<code>-</code>) defines ranges. For example, <code>JAN-JUN</code> indicates every month from January to June,
<em>inclusive</em>.</p>
<p>Range bound can be any valid <a href="#single-value">single value</a>, but the left bound must be less than
or equal to the right bound.</p>
<h2 id="step"><a href="#step">§</a>Step</h2>
<p>In Vixie’s cron, slash (<code>/</code>) can be combined with ranges to specify step values.</p>
<p>For example, <code>*/10</code> in the minutes field indicates every 10 minutes (see note below about
frequencies). It is shorthand for the more verbose POSIX form <code>00,10,20,30,40,50</code>.</p>
<p>Note that frequencies in general cannot be expressed; only step values which evenly divide their
range express accurate frequencies (for minutes and seconds, that’s <code>/2</code>, <code>/3</code>, <code>/4</code>, <code>/5</code>,
<code>/6</code>, <code>/10</code>, <code>/12</code>, <code>/15</code>, <code>/20</code> and <code>/30</code> because 60 is evenly divisible by those numbers; for
hours, that’s <code>/2</code>, <code>/3</code>, <code>/4</code>, <code>/6</code>, <code>/8</code> and <code>/12</code>); all other possible “steps” and all other
fields yield inconsistent “short” periods at the end of the time-unit before it “resets” to the
next minute, hour, or day; for example, entering <code>*/5</code> for the day field sometimes executes
after 1, 2, or 3 days, depending on the month and leap year; this is because cron is stateless
(it does not remember the time of the last execution nor count the difference between it and
now, required for accurate frequency counting—instead, cron is a mere pattern-matcher).</p>
<p>This crate requires the step value to be in the range of the field and not zero.</p>
<p>The range to be stepped can be any valid <a href="#single-value">single value</a>, <a href="#asterisk">asterisk</a>,
or <a href="#range">range</a>.</p>
<p>When it’s a single value <code>v</code>, it’s expanded to a range <code>v-&lt;field range end&gt;</code>. For example,
<code>15/XX</code> is the same as a Vixie’s cron schedule of <code>15-59/10</code> in the minutes section. Similarly,
you can remove the extra <code>-23</code> from <code>0-23/XX</code>, <code>-31</code> from <code>1-31/XX</code>, and <code>-12</code> from <code>1-12/XX</code>
for hours, days, and months; respectively.</p>
<p>Note that this is to support the existing widely adopted syntax, users are encouraged to use
the more explicit form.</p>
<h2 id="list"><a href="#list">§</a>List</h2>
<p>Commas (<code>,</code>) are used to separate items of a list. For example, using <code>MON,WED,FRI</code> in the 5th
field (day of week) means Mondays, Wednesdays and Fridays.</p>
<p>The list can contain any valid <a href="#single-value">single value</a>, <a href="#asterisk">asterisk</a>,
<a href="#range">range</a>, or <a href="#step">step</a>. For days of week and days of month, it can also contain
extra syntax, read their dedicated sections below.</p>
<p>List items are parsed delimited by commas. This takes the highest precedence in the parsing.
Thus, <code>1-10,40-50/2</code> is parsed as <code>1,2,3,4,5,6,7,8,9,10,40,42,44,46,48,50</code>.</p>
<h2 id="day-of-month-extension"><a href="#day-of-month-extension">§</a>Day of month extension</h2>
<p>All the extensions below can be specified only alone or as a single item of a list, not in a
range or a step.</p>
<h3 id="last-day-of-month-l"><a href="#last-day-of-month-l">§</a>Last day of month (<code>L</code>)</h3>
<p>The <code>L</code> character is allowed for the day-of-month field. This character specifies the last day
of the month.</p>
<h3 id="nearest-weekday-1w-15w-etc"><a href="#nearest-weekday-1w-15w-etc">§</a>Nearest weekday (<code>1W</code>, <code>15W</code>, etc.)</h3>
<p>The <code>W</code> character is allowed for the day-of-month field. This character is used to specify the
weekday (Monday-Friday) nearest the given day. As an example, if <code>15W</code> is specified as the value
for the day-of-month field, the meaning is: “the nearest weekday to the 15th of the month.” So,
if the 15th is a Saturday, the trigger fires on Friday the 14th. If the 15th is a Sunday, the
trigger fires on Monday the 16th. If the 15th is a Tuesday, then it fires on Tuesday the 15th.
However, if <code>1W</code> is specified as the value for day-of-month, and the 1st is a Saturday, the
trigger fires on Monday the 3rd, as it does not ‘jump’ over the boundary of a month’s days.</p>
<h2 id="day-of-week-extension"><a href="#day-of-week-extension">§</a>Day of week extension</h2>
<p>All the extensions below can be specified only alone or as a single item of a list, not in a
range or a step.</p>
<h3 id="last-day-of-week-5l"><a href="#last-day-of-week-5l">§</a>Last day of week (<code>5L</code>)</h3>
<p>The <code>L</code> character is allowed for the day-of-week field. This character specifies constructs such
as “the last Friday” (<code>5L</code>) of a given month.</p>
<h3 id="nth-day-of-week-53"><a href="#nth-day-of-week-53">§</a>Nth day of week (<code>5#3</code>)</h3>
<p>The <code>#</code> character is allowed for the day-of-week field, and must be followed by a number between
one and five. It allows specifying constructs such as “the second Friday” of a given month. For
example, entering <code>5#3</code> in the day-of-week field corresponds to the third Friday of every month.</p>
<h2 id="edge-cases"><a href="#edge-cases">§</a>Edge cases</h2><h3 id="the-vixies-cron-bug-became-the-de-facto-standard"><a href="#the-vixies-cron-bug-became-the-de-facto-standard">§</a>The Vixie’s cron bug became the de-facto standard</h3>
<p>Read <a href="https://crontab.guru/cron-bug.html">the article</a> for more details.</p>
<p>Typically, <code>0 12 *,10 * 2</code> is not equal to <code>0 12 10,* * 2</code>.</p>

<div><pre><code><span>let </span>crontab1 = cronexpr::parse_crontab(<span>&#34;0 12 *,10 * 2 UTC&#34;</span>).unwrap();
<span>let </span>crontab2 = cronexpr::parse_crontab(<span>&#34;0 12 10,* * 2 UTC&#34;</span>).unwrap();

<span>let </span>ts = <span>&#34;2024-09-24T13:06:52Z&#34;</span>;
<span>assert_ne!</span>(
    crontab1.find_next(ts).unwrap().to_string(),
    crontab2.find_next(ts).unwrap().to_string()
);</code></pre></div>
<p>This crate implements the Vixie’s cron behavior. That is,</p>
<ol>
<li>Check if either the day of month or the day of week starts with asterisk (<code>*</code>).</li>
<li>If so, match these two fields in interaction.</li>
<li>If not, match these two fields in union.</li>
</ol>
<p>So, explain the example above:</p>
<p>The first one’s (<code>0 12 *,10 * 2 UTC</code>) day-of-month starts with an asterisk so cron uses
intersect. The schedule fires only on Tuesdays because <code>all-days-of-month ∩ Tuesday = Tuesday</code>.
It is the same schedule as <code>0 12 * * 2 UTC</code>.</p>
<p>The second one’s (<code>0 12 10,* * 2 UTC</code>) day-of-month has an asterisk in the day-of-month field,
but not as the first character. So cron uses union. The schedule fires every day because
<code>all-days-of-month ∪ Tuesday = all-days-of-month</code>. It is therefore the same as <code>0 12 * * * UTC</code>.</p>
<p>Also, <code>0 12 1-31 * 2</code> is not equal to <code>0 12 * * 2</code>.</p>

<div><pre><code><span>let </span>crontab1 = cronexpr::parse_crontab(<span>&#34;0 12 1-31 * 2 UTC&#34;</span>).unwrap();
<span>let </span>crontab2 = cronexpr::parse_crontab(<span>&#34;0 12 * * 2 UTC&#34;</span>).unwrap();

<span>let </span>ts = <span>&#34;2024-09-24T13:06:52Z&#34;</span>;
<span>assert_ne!</span>(
    crontab1.find_next(ts).unwrap().to_string(),
    crontab2.find_next(ts).unwrap().to_string()
);</code></pre></div>
<p>The first one fires every day (same as <code>0 12 1-31 * * UTC</code> or as <code>0 12 * * * UTC</code>), and the
second schedule fires only on Tuesdays.</p>
<p>This bug is most likely to affect you when using step values. Quick reminder on step values:
<code>0-10/2</code> means every minute value from zero through ten (same as the list <code>0,2,4,6,8,10</code>), and
<code>*/3</code> means every third value. By using an asterisk with a step value for day-of-month or
day-of-week we put cron into the intersect mode producing unexpected results.</p>
<p>Most of the time, we choose to use the wildcard to make the cron more legible. However, by now
you understand why <code>0 12 */2 * 0,6</code> does not run on every uneven day of the month plus on
Saturday and Sundays. Instead, due to this bug, it only runs if today is uneven and is also on a
weekend. To accomplish the former behaviour, you have to rewrite the schedule as <code>0 12 1-31/2 *  0,6</code>.</p>

<div><pre><code> <span>fn </span>next(iter: <span>&amp;mut </span>cronexpr::CronTimesIter) -&gt; String {
     iter.next().unwrap().unwrap().to_string()
 }

 <span>let </span>crontab1 = cronexpr::parse_crontab(<span>&#34;0 12 */2 * 0,6 UTC&#34;</span>).unwrap();
 <span>let </span><span>mut </span>iter1 = crontab1.iter_after(<span>&#34;2024-09-24T13:06:52Z&#34;</span>).unwrap();

 <span>assert_eq!</span>(next(<span>&amp;mut </span>iter1), <span>&#34;2024-09-29T12:00:00+00:00[UTC]&#34;</span>);
 <span>assert_eq!</span>(next(<span>&amp;mut </span>iter1), <span>&#34;2024-10-05T12:00:00+00:00[UTC]&#34;</span>);
 <span>assert_eq!</span>(next(<span>&amp;mut </span>iter1), <span>&#34;2024-10-13T12:00:00+00:00[UTC]&#34;</span>);
 <span>assert_eq!</span>(next(<span>&amp;mut </span>iter1), <span>&#34;2024-10-19T12:00:00+00:00[UTC]&#34;</span>);
 <span>assert_eq!</span>(next(<span>&amp;mut </span>iter1), <span>&#34;2024-10-27T12:00:00+00:00[UTC]&#34;</span>);

 <span>let </span>crontab2 = cronexpr::parse_crontab(<span>&#34;0 12 1-31/2 * 0,6 UTC&#34;</span>).unwrap();
 <span>let </span><span>mut </span>iter2 = crontab2.iter_after(<span>&#34;2024-09-24T13:06:52Z&#34;</span>).unwrap();

 <span>assert_eq!</span>(next(<span>&amp;mut </span>iter2), <span>&#34;2024-09-25T12:00:00+00:00[UTC]&#34;</span>);
 <span>assert_eq!</span>(next(<span>&amp;mut </span>iter2), <span>&#34;2024-09-27T12:00:00+00:00[UTC]&#34;</span>);
 <span>assert_eq!</span>(next(<span>&amp;mut </span>iter2), <span>&#34;2024-09-28T12:00:00+00:00[UTC]&#34;</span>);
 <span>assert_eq!</span>(next(<span>&amp;mut </span>iter2), <span>&#34;2024-09-29T12:00:00+00:00[UTC]&#34;</span>);
 <span>assert_eq!</span>(next(<span>&amp;mut </span>iter2), <span>&#34;2024-10-01T12:00:00+00:00[UTC]&#34;</span>);</code></pre></div>
<h3 id="nearest-weekday-at-the-edge-of-the-month"><a href="#nearest-weekday-at-the-edge-of-the-month">§</a>Nearest weekday at the edge of the month</h3>
<p>Nearest weekday does not ‘jump’ over the boundary of a month’s days.</p>
<p>Thus, if <code>1W</code> is specified as the value for day-of-month, and the 1st is a Saturday, the trigger
fires on Monday the 3rd. (Although the nearest weekday to the 1st is the last day of the
previous month.)</p>
<p>If <code>31W</code> is specified as the value for day-of-month, and the 31st is a Sunday, the trigger fires
on Friday the 29th. (Although the nearest weekday to the 31st is the 1st of the next month.)
This is the same for <code>30W</code>, <code>29W</code>, <code>28W</code>, etc. if the day is the last day of the month.</p>
<p>If <code>31W</code> is specified as the value for day-of-month, the month does not have 31 days, the
trigger won’t fire in the month. This is the same for <code>30W</code>, <code>29W</code>, etc.</p>
<h3 id="nth-day-of-week-does-not-exist"><a href="#nth-day-of-week-does-not-exist">§</a>Nth day of week does not exist</h3>
<p>If the Nth day of week does not exist in the month, the trigger won’t fire in the month.
This happens only when the month has less than five of the weekday.</p>
<h2 id="faq"><a href="#faq">§</a>FAQ</h2><h3 id="why-do-you-create-this-crate"><a href="#why-do-you-create-this-crate">§</a>Why do you create this crate?</h3>
<p>The other way when I was implementing features like <a href="https://docs.snowflake.com/en/sql-reference/sql/create-task"><code>CREATE TASK</code> in Snowflake</a>,
it comes to a requirement to support parsing and driving a crontab expression.</p>
<p>Typically, the language interface looks like:</p>
<div><pre><code>CREATE TASK do_retention
SCHEDULE = &#39;* * * * * Asia/Shanghai&#39;
AS
    DELETE FROM t WHERE now() - ts &gt; &#39;PT10s&#39;::interval;</code></pre></div>
<p>The execution part of a traditional cron is the statement (<code>DELETE FROM ...</code>) here. Thus,
what I need is a library to parse the crontab expression and find the next timestamp to execute
the statement, without the need to execute the statement in the crontab library itself.</p>
<p>There are several good candidates like <a href="https://docs.rs/croner"><code>croner</code></a> and <a href="https://docs.rs/saffron"><code>saffron</code></a>, but they are not suitable for
my use case. Both of them do <em>not</em> support defining timezone in the expression which is
essential to my use case. Although <code>croner</code> support specific timezone later when matching, the
user experience is quite different. Also, the syntax that <code>croner</code> or <code>saffron</code> supports is
subtly different from my demand.</p>
<p>Other libraries are unmaintained or immature to use.</p>
<p>Last, most candidates using <a href="https://docs.rs/chrono"><code>chrono</code></a> to processing datetime, while I’d prefer to extend the
<a href="https://docs.rs/jiff/0.1.13/x86_64-unknown-linux-gnu/jiff/index.html" title="mod jiff"><code>jiff</code></a> ecosystem.</p>
<h3 id="why-does-the-crate-require-the-timezone-to-be-specified-in-the-crontab-expression"><a href="#why-does-the-crate-require-the-timezone-to-be-specified-in-the-crontab-expression">§</a>Why does the crate require the timezone to be specified in the crontab expression?</h3>
<p>Mainly two reasons:</p>
<ol>
<li>Without timezone information, you can <em>not</em> perform daylight saving time (DST) arithmetic,
and the result of the next timestamp may be incorrect.</li>
<li>When define the crontab expression, people usually have a specific timezone in mind. It’s
more natural to specify the timezone in the expression, instead of having UTC as an implicit
and forcing the user to convert the datetime to UTC.</li>
</ol>
<p>If there is a third reason, that is, it’s how Snowflake does.</p>
<h4 id="why-does-crontabfind_next-and-crontabiter_after-only-support-exclusive-bounds"><a href="#why-does-crontabfind_next-and-crontabiter_after-only-support-exclusive-bounds">§</a>Why does <a href="https://docs.rs/cronexpr/latest/cronexpr/struct.Crontab.html#method.find_next" title="method cronexpr::Crontab::find_next"><code>Crontab::find_next</code></a> and <a href="https://docs.rs/cronexpr/latest/cronexpr/struct.Crontab.html#method.iter_after" title="method cronexpr::Crontab::iter_after"><code>Crontab::iter_after</code></a> only support exclusive bounds?</h4>
<p>Crontab jobs are schedule at most every minute. Bike-shedding the inclusive bounds is not
practical.</p>
<p>If you’d like to try to match the boundary anyway, you can test it with <a href="https://docs.rs/cronexpr/latest/cronexpr/struct.Crontab.html#method.matches" title="method cronexpr::Crontab::matches"><code>Crontab::matches</code></a>
before calling <a href="https://docs.rs/cronexpr/latest/cronexpr/struct.Crontab.html#method.find_next" title="method cronexpr::Crontab::find_next"><code>Crontab::find_next</code></a> or <a href="https://docs.rs/cronexpr/latest/cronexpr/struct.Crontab.html#method.iter_after" title="method cronexpr::Crontab::iter_after"><code>Crontab::iter_after</code></a>.</p>
<h4 id="why-not-support-aliases-like-hourly-and-reboot"><a href="#why-not-support-aliases-like-hourly-and-reboot">§</a>Why not support aliases like <code>@hourly</code> and <code>@reboot</code>?</h4>
<p>They are too handy to support and are totally different syntax in parsing.</p>
<p><code>@reboot</code> is meaningless since this crate only parse and drive a crontab expression, rather
than execute the command. Other aliases should be easily converted to the syntax this crate
supports.</p>
<h3 id="why-not-support-seconds-andor-years"><a href="#why-not-support-seconds-andor-years">§</a>Why not support seconds and/or years?</h3>
<p>Crontab jobs are typically <em>not</em> frequent tasks that run in seconds. Especially for scheduling
tasks in a distributed database, trying to specify a task in seconds is impractical.</p>
<p>I don’t actually schedule the task exactly at the timestamp, but record the previous timestamp,
and then schedule the task when <code>now</code> is greater than or equal to the next timestamp.</p>
<p>For years, it’s not a common use case for crontab jobs. This crate can already specify “every
year”.</p>

<div><pre><code><span>fn </span>next(iter: <span>&amp;mut </span>cronexpr::CronTimesIter) -&gt; String {
    iter.next().unwrap().unwrap().to_string()
}

<span>let </span>crontab = cronexpr::parse_crontab(<span>&#34;0 0 1 JAN * UTC&#34;</span>).unwrap();
<span>let </span><span>mut </span>iter = crontab.iter_after(<span>&#34;2024-09-24T13:06:52Z&#34;</span>).unwrap();

<span>assert_eq!</span>(next(<span>&amp;mut </span>iter), <span>&#34;2025-01-01T00:00:00+00:00[UTC]&#34;</span>);
<span>assert_eq!</span>(next(<span>&amp;mut </span>iter), <span>&#34;2026-01-01T00:00:00+00:00[UTC]&#34;</span>);
<span>assert_eq!</span>(next(<span>&amp;mut </span>iter), <span>&#34;2027-01-01T00:00:00+00:00[UTC]&#34;</span>);
<span>assert_eq!</span>(next(<span>&amp;mut </span>iter), <span>&#34;2028-01-01T00:00:00+00:00[UTC]&#34;</span>);</code></pre></div>
<p>If you need to match certain years, please do it externally.</p>
<h3 id="why-not-support-passing-command-to-execute"><a href="#why-not-support-passing-command-to-execute">§</a>Why not support passing command to execute?</h3>
<p>The original purpose of this crate to provide a library to parse and drive the crontab
expression to find the next timestamp, while the execution part is scheduled outside.</p>
<p>Note that a crontab library scheduling command can be built upon this crate.</p>
<h3 id="why-not-support---and-many-other-non-standard-extensions"><a href="#why-not-support---and-many-other-non-standard-extensions">§</a>Why not support <code>?</code>, <code>%</code> and many other non-standard extensions?</h3>
<p>For <code>?</code>, it’s a workaround to <code>*</code> and the famous cron bug. This crate implements the Vixie’s
cron behavior, so <code>?</code> is not necessary.</p>
<p>For <code>%</code>, it’s coupled with command execution. This crate doesn’t support executing so <code>%</code> is
meaningless.</p>
<p>For <code>#</code> indicates comments, this crate doesn’t support comments. It’s too random for a library.</p>
</div></div>
  </body>
</html>
