<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://frontendmastery.com/posts/the-new-wave-of-react-state-management/">Original</a>
    <h1>The new wave of React state management</h1>
    
    <div id="readability-page-1" class="page"><div>
  <article>
          <h2 id="introduction">Introduction</h2><p>As React applications grow in size and complexity, managing shared global state is a challenge. The general advice is to only reach for global state management solutions when you need it.</p><p>This post will flesh out the core problems global state management libraries need to solve.</p><p>Understanding the underlying problems will help us assess the trade-offs made the “new wave” of state management approaches. For everything else, it’s often better to start local and scale up only as needed.</p><p>React itself does not provide any strong guidelines for how to solve this for shared global application state. As such the React ecosystem has collected numerous approaches and libraries to solve this problem over time.</p><p>This can make it confusing when assessing which library or pattern to adopt.</p><p>The common approach is to outsource this and use whatever is most popular. Which as we’ll see was the case with the widespread adoption of Redux early on, with many applications not needing it.</p><p>By understanding the problem space state management libraries operate in, it allows us to better understand why there are so many different libraries taking different approaches.</p><p>Each makes different tradeoffs against different problems, leading to numerous variations in API’s, patterns and conceptual models on how to think about state.</p><p>We’ll take a look at modern approaches and patterns that can be found in libraries like <a href="https://recoiljs.org/">Recoil</a>, <a href="https://jotai.org/">Jotai</a>, <a href="https://github.com/pmndrs/zustand">Zustand</a>, <a href="https://github.com/pmndrs/valtio">Valtio</a> and how others like <a href="https://github.com/dai-shi/react-tracked">React tracked</a> and <a href="https://react-query.tanstack.com/overview">React query</a> and how fit into the ever evolving landscape.</p><p>By the end we should be more equipped to accurately assess the trade-offs libraries make when we need to chose one that makes sense for our applications needs.</p><h2 id="the-problems-global-state-management-libraries-need-to-solve">The problems global state management libraries need to solve</h2><ol>
<li>
<p><strong>Ability to read stored state from anywhere in the component tree.</strong> This is the most basic function of a state management library.</p>
<p>It allows developers to persist their state in memory, and avoid the issues prop drilling has at scale. Early on in the React ecosystem we often reached for Redux unnecessarily to solve this pain point.</p>
<p>In practice there are two main approaches when it comes to actually storing the state.</p>
<p>The first is inside the React runtime. This often means leveraging API’s React provides like <code>useState</code>, <code>useRef</code> or <code>useReducer</code> combined with React context to propagate a shared value around. The main challenge here is optimizing re-renders correctly.</p>
<p>The second is outside of React’s knowledge, in module state. Module state allows for singleton-like state to be stored. It’s often easier to optimize re-renders through subscriptions that opt-in to re-rendering when the state changes. However because it’s a single value in memory, you can’t have different states for different subtrees.</p>
</li>
<li>
<p><strong>Ability to write to stored state.</strong> A library should to provide an intuitive API for both reading and writing data to the store.</p>
<p>An intuitive API is often one that fits ones existing mental models. So this can be somewhat subjective depending on who the consumer of the library is.</p>
<p>Often times clashes in mental models can cause friction in adoption or increase a learning curve.
A common clashing of mental models in React is mutable versus immutable state.</p>
<p>React’s model of UI as a function of state lends itself to concepts that rely on referential equality and immutable updates to detect when things changes so it can re-render correctly. But Javascript is a mutable language.</p>
<p>When using React we have to keep things like reference equality in mind. This can be a source of confusion for Javascript developers not used to functional concepts and forms part of the learning curve when using React.</p>
<p>Redux follows this model and requires all state updates be done that in an immutable way. There are trade-offs with choices like this, in this case a common gripe is the amount of boilerplate you have to write to make updates for those used to mutable style updates.</p>
<p>That’s is why libraries like <a href="https://github.com/immerjs/immer">Immer</a> are popular that allow developers to write mutable style code (even if under the hood updates are immutable).</p>
<p>There are other libraries in the new wave of “post-redux” global state management solutions such as <a href="https://valtio.pmnd.rs/">Valtio</a> that allow developers to use a mutable style API.</p>
</li>
<li>
<p><strong>Provide mechanisms to optimize rendering.</strong> The model of UI as a function of state is both incredibly simple and productive.</p>
<p>However the process of reconciliation when that state changes is expensive at scale. And often leads to poor runtime performance for large apps.</p>
<p>With this model, a global state management library needs to both detect when to re-render when it’s state gets updated, and only re-render what is necessary.</p>
<p>Optimizing this process is one of the biggest challenges a state management library needs to solve.</p>
<p>There are two main approaches often taken. The first is allowing consumers to manually optimize this process.</p>
<p>An example of a manual optimization would be subscribing to a piece of stored state through a selector function. Components that read state through a selector will only re-render when that specific piece of state updates.</p>
<p>The second is handling this automatically for consumers so they don’t have to think about manual optimizations.</p>
<p>Valtio is another example library that use <code>Proxy</code>’s under the hood to automatically track when things get updated and automatically manage when a component should re-render.</p>
</li>
<li>
<p><strong>Provide mechanisms to optimize memory usage.</strong> For very large frontend applications, not managing memory properly can silently lead to issues at scale.</p>
<p>Especially if you have customers that access these large applications from lower spec devices.</p>
<p>Hooking into the React lifecycle to store state means it’s easier to take advantage of automatic garbage collection when the component unmounts.</p>
<p>For libraries like Redux that promote the pattern of a single global store, you will need manage this yourself. As it’ll continue to hold a reference to your data so that it won’t automatically get garbage collected.</p>
<p>Similarly, using a state management library that stores state outside the React runtime in module state means it’s not tied to any specific components and may need to be managed manually.</p>
</li>
</ol><p><strong>More problems to solve:</strong>
In addition to the foundational problems above, there are some other common problems to consider when integrating with React:</p><ul>
<li>
<p><strong>Compatibility with concurrent mode.</strong> <a href="https://17.reactjs.org/docs/concurrent-mode-intro.html">Concurrent mode</a> allows React to “pause” and switch priorities within a render pass. Previously this process was completely synchronous.</p>
<p>Introducing concurrency to anything usually introduces edge cases. For state management libraries there is the potential for two components to read different values from an external store, if the value read is changed during that render pass.</p>
<p>This is known as “tearing”. This problem lead to the React team creating the <a href="https://reactjs.org/docs/hooks-reference.html#usesyncexternalstore">useSyncExternalStore</a> hook for library creators to solve this problem.</p>
</li>
<li>
<p><strong>Serialization of data.</strong> It can be useful to have fully serializable state so you can save and restore application state from storage somewhere. Some libraries handle this for you while others may require additional effort on the consumers side to enable this.</p>
</li>
<li>
<p><strong>The context loss problem.</strong> This is a problem for applications that <a href="https://github.com/facebook/react/issues/13332">mix multiple react-renderers together</a>. For example you may have an application that utilizes both <code>react-dom</code> and a library like <code>react-three-fiber</code>. Where React can’t reconcile the two separate contexts.</p>
</li>
<li>
<p><strong>The stale props problem.</strong> Hooks solved a lot of issues with traditional class components. The trade off for this was a new set of problems that come with embracing closures.</p>
<p>One common issue is data inside a closure no longer being “fresh” in the current render cycle. Leading to the data that is rendered out to the screen not being the latest value. This can be a problem when using selector functions that rely on props to calculate the state.</p>
</li>
<li>
<p><strong>The zombie child problem.</strong> This refers to an old issue with Redux where child components that mount themselves first and connect to the store before the parent can cause inconsistencies if that state is updated before the parent component mounts.</p>
</li>
</ul><h2 id="a-brief-history-of-the-state-management-ecosystem">A brief history of the state management ecosystem</h2><p>As we’ve seen there’s a lot of problems and edge cases global state management libraries need to take into account.</p><p>To better understand all the modern approaches to React state management. We can take a trip down memory lane to see the how the pain-points of the past have lead to lessons that we call “best practices” today.</p><p>Often times these best practices are discovered through trial and error and from find that certain solutions don’t end up scaling well.</p><p>From the beginning, React’s original tagline when it was first released was the “view” in Model View Controller.</p><p>It came without opinions on how to structure or manage state. This meant developers were sort of on their own when it came to dealing with the most complicated part of developing frontend applications.</p><p>Internally at Facebook a pattern was used called <a href="https://facebook.github.io/flux/">“Flux”</a>, that lent itself to uni-directional data flow and predictable updates that aligned with React’s model of “always re-render” the world.</p><p>This pattern fitted React’s mental model nicely, and caught on early in the React ecosystem.</p><h3 id="the-original-rise-of-redux">The original rise of Redux</h3><p>Redux was one of the first implementations of the Flux pattern that got widespread adoption.</p><p>It promoted the use of a single store, partly inspired by the Elm architecture, as opposed to many stores that was common with other Flux implementations.</p><p>You wouldn’t get fired for choosing Redux as your state management library of choice when spinning up a new project. It also had cool demoable features like ease of implementing undo / redo functionality and time travel debugging.</p><p>The overall model was, and still is, simple and elegant. Especially compared to the previous generation of MVC style frameworks like Backbone (at scale) that had preceded the React model.</p><p>While Redux is still a great state management library that has real use cases for specific apps. Over time there were a few common gripes with Redux that surfaced that lead it to fall out of favour as we learnt more as a community:</p><ul>
<li>
<p><strong>Issues in smaller apps</strong></p>
<p>For a lot of applications early on it solved the first problem. Accessing stored state from anywhere in the tree to avoid the pains of prop-drilling both data and functions to update that data down multiple levels.</p>
<p>It was often overkill for simple applications that fetched a few endpoints and had little interactivity.</p>
</li>
<li>
<p><strong>Issues in larger apps</strong></p>
<p>Over time our smaller applications grew into larger ones. And as we discovered that in practice there are many different types of state in a frontend application. Each with their own set of sub-problems.</p>
<p>We can count local UI state, remote server cache state, url state, and global shared state, and probably more distinct types of state.</p>
<p>For example with local UI state, prop drilling both data and methods to update that data often becomes a problem relatively quickly as things grow. To solve this, using <a href="https://frontendmastery.com/posts/building-future-facing-frontend-architectures">component composition patterns</a> in combination with <a href="https://reactjs.org/docs/lifting-state-up.html">lifting state up</a> can get you pretty far.</p>
<p>For remote server cache state there are common problems like request de-duplication, retries, polling, handling mutations and the list goes on.</p>
<p>As applications grow Redux tends to want to suck up all the state regardless of it’s type, as it promotes a single store.</p>
<p>This commonly lead to storing all the things in a big monolithic store. Which often times exacerbated the second problem of optimizing run-time performance.</p>
<p>Because Redux handles the global shared state generically, a lot of these sub problems needed to be repeatedly solved (or often times just left un-attended).</p>
<p>This lead to big monolithic stores holding everything between UI and remote entity state being managed in a single place.</p>
<p>This of course becomes very difficult to manage as things grow. Especially on teams where frontend developers need to ship fast. Where working on decoupled independent complex components becomes necessary.</p>
</li>
</ul><h3 id="the-de-emphasis-of-redux">The de-emphasis of Redux</h3><p>As we encountered more of these pain points, over time defaulting to Redux when spinning up a new project became discouraged.</p><p>In reality a lot of web applications are CRUD (create, read, update and delete) style applications that mainly need to synchronize the frontend with remote state data.</p><p>In other words, the main problems worth spending time on is the set of remote server cache problems. These problems include how to fetch, cache and synchronize with server state.</p><p>It also includes many other problems like handling race conditions, invalidating and refetching of stale data, de-duplicating requests, retries, refetching on component re-focus, and ease in mutating remote data compared to the boilerplate usually associated with Redux.</p><p>The boilerplate for this use-case was unnecessary and overly complex. Especially so when commonly combined with middleware libraries like <code>redux-saga</code> and <code>redux-observable</code>.</p><p>This toolchain was overkill for these types of applications. Both in terms of the overhead sent down to the client for fetching and mutations but in complexity of the model being used for relatively simple operations.</p><h3 id="the-pendulum-swing-to-simpler-approaches">The pendulum swing to simpler approaches</h3><p>Along came hooks and the new context API. For a time being the pendulum swang back from heavy abstractions like Redux to utilizing native context with the new hooks APIs. This often involved simple <code>useContext</code> combined with <code>useState</code> or <code>useReducer</code>.</p><p>This is a fine approach for simple applications. And a lot of smaller applications can get away with this. However as things grow, this lead to two problems:</p><ol>
<li>
<p><strong>Re-inventing Redux.</strong> And often times falling into the many problems we defined before. And either not solving them, or solving them poorly compared to a library dedicated to solving those specific edge cases. Leading many feeling the need to the promote the idea that <a href="https://blog.isquaredsoftware.com/2021/01/context-redux-differences/">React context has nothing to do with state management</a>.</p>
</li>
<li>
<p><strong>Optimizing runtime performance.</strong> The other core problem is optimizing re-renders. Which can be difficult to get right as things scale when using native context.</p>
<p>It’s worth noting modern user-land libraries such as <code>useContextSelector</code> designed to help with this problem. With the React team starting to look at <a href="https://github.com/reactjs/rfcs/pull/119#issuecomment-586390430">addressing this pain point automatically in the future as part of React</a>.</p>
</li>
</ol><h3 id="the-rise-of-purpose-built-libraries-to-solve-the-remote-state-management-problem">The rise of purpose built libraries to solve the remote state management problem</h3><p>For most web applications that are CRUD style applications, local state combined with a dedicated remote state management library can get you very far.</p><p>Some example libraries in this trend include <a href="https://react-query.tanstack.com/overview">React query</a>, <a href="https://github.com/vercel/swr">SWR</a>, <a href="https://www.apollographql.com/">Apollo</a> and <a href="https://relay.dev/">Relay</a>. Also in a “reformed” Redux with <a href="https://redux-toolkit.js.org/">Redux Toolkit</a> and <a href="https://redux-toolkit.js.org/introduction/getting-started#rtk-query">RTK Query</a>.</p><p>These are purpose built to solve the problems in the remote data problem space that often times were too cumbersome to implement solely using Redux.</p><p>While these libraries are great abstractions for single page apps. They still require a hefty overhead in terms of Javascript needed over the wire. Required for fetching and data mutation. And as a community of web builders the <a href="https://v8.dev/blog/cost-of-javascript-2019">real cost of Javascript</a> is becoming more fore-front of mind.</p><p>It’s worth noting newer meta-frameworks like <a href="https://remix.run/">Remix</a> address this, by providing abstractions for server-first data loading and declarative mutations that don’t require downloaded a dedicated library. Extending the “UI as a function of state” concept <a href="https://remix.run/blog/remix-data-flow">beyond the just the client</a> to include the backend remote state data.</p><h2 id="the-new-wave-of-global-state-management-libraries-and-patterns">The new wave of global state management libraries and patterns</h2><p>For large applications there is often no avoiding needing to have shared global state that is distinct from remote server state.</p><p><strong>The rise of bottom up patterns</strong></p><p>We can see previous state management solutions like Redux as somewhat “top down” in their approach. That over time tends to want to suck up all the state at the top of the component tree. State lives up high in the tree, and components below pull down the state they need through selectors.</p><p>In <a href="https://frontendmastery.com/posts/building-future-facing-frontend-architectures">Building future facing frontend architectures</a> we saw the usefulness of the bottom-up view to constructing components with composition patterns.</p><p>Hooks both afford and promote the same principle of composable pieces put together to form a larger whole.  With hooks we can mark a shift from monolithic state management approaches with a giant global store. Towards a bottom-up “micro” state management with an emphasis of smaller state slices consumed via hooks.</p><p>Popular libraries like <a href="https://recoiljs.org/">Recoil</a> and <a href="https://jotai.org/">Jotai</a> exemplify this bottom-up approach with their concepts of “atomic” state.</p><p>An atom is a minimal, but complete unit of state. They are small pieces of state that can connect together to form new derived states. That ends up forming a graph.</p><p>This model allows you to build up state incrementally bottom up. And optimizes re-renders by only invalidating atoms in the graph that have been updated.</p><p>This in contrast to having one large monolithic ball of state that you subscribe to and try to avoid unnecessary re-renders.</p><h3 id="how-modern-libraries-address-the-core-problems-of-state-management">How modern libraries address the core problems of state management</h3><p>Below is a simplified summary of the different approaches each “new wave” library takes to solve each of the core problems of state management. These are the same problems we defined at the start of the article.</p><h4 id="ability-to-read-stored-state-from-anywhere-within-a-subtree">Ability to read stored state from anywhere within a subtree</h4><table>
<thead>
<tr>
<th>Library</th>
<th>Description</th>
<th>Simplified API example</th>
</tr>
</thead>
<tbody>
<tr>
<td>React-Redux</td>
<td>React lifecycle</td>
<td><code>useSelector(state =&gt; state.foo)</code></td>
</tr>
<tr>
<td>Recoil</td>
<td>React lifecycle</td>
<td><code><code>const todos = atom({ key: &#39;todos&#39;, default: [] })</code></code></td>
</tr>
<tr>
<td>Jotai</td>
<td>React lifecycle</td>
<td><code><code>const countAtom = atom(0)</code></code></td>
</tr>
<tr>
<td>Valtio</td>
<td>Module state</td>
<td><code><code>const state = proxy({ count: 0 })</code></code></td>
</tr>
</tbody>
</table><h4 id="ability-to-write-and-update-stored-state">Ability to write and update stored state</h4><table>
<thead>
<tr>
<th>Library</th>
<th>Update API</th>
</tr>
</thead>
<tbody>
<tr>
<td>React-Redux</td>
<td>Immutable</td>
</tr>
<tr>
<td>Recoil</td>
<td>Immutable</td>
</tr>
<tr>
<td>Jotai</td>
<td>Immutable</td>
</tr>
<tr>
<td>Zustand</td>
<td>Immutable</td>
</tr>
<tr>
<td>Valtio</td>
<td>Mutable style</td>
</tr>
</tbody>
</table><h4 id="runtime-performance-re-render-optimizations">Runtime performance re-render optimizations</h4><p><strong>Manual optimizations</strong> often mean the creation of selector functions that subscribe to a specific piece of state. The advantage here is that consumers can have fine-grained control of how to subscribe and optimize how components that subscribe to that state will re-render. A disadvantage is that this is a manual process, that can be error prone, and one might argue requires an unnecessary overhead that shouldn’t be part of the API.</p><p><strong>Automatic optimizations</strong> is where the library optimizes this process of only re-rendering what is necessary, automatically, for you as a consumer. The advantage here of course is the ease of use, and the ability for consumers to focus on developing features without needing to worry about manual optimizations. A disadvantage of this is that as a consumer the optimization process is a black box, and without escape hatches to manually optimize some parts may feel a bit too magic.</p><table>
<thead>
<tr>
<th>Library</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>React-Redux</td>
<td>Manual via selectors</td>
</tr>
<tr>
<td>Recoil</td>
<td>Semi-manual through subscriptions to atoms</td>
</tr>
<tr>
<td>Jotai</td>
<td>Semi-manual through subscriptions to atoms</td>
</tr>
<tr>
<td>Zustand</td>
<td>Manual via selectors</td>
</tr>
<tr>
<td>Valtio</td>
<td>Automatic via <code>Proxy</code> snapshots</td>
</tr>
</tbody>
</table><h4 id="memory-optimizations">Memory optimizations</h4><p>Memory optimizations tend to only be issues on very large applications. A big part of this will depend on whether or not the library stores state at the module level or within the React runtime. It also depends how you structure the store.</p><p>The benefit of smaller independent stores compared to large monolithic ones is they can be garbage collected automatically when all subscribing components unmount. Whereas large monolithic stores are more prone to memory leaks without proper memory management.</p><table>
<thead>
<tr>
<th>Library</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Redux</td>
<td>Needs to be managed manually</td>
</tr>
<tr>
<td>Recoil</td>
<td>Automatic - as of v0.3.0</td>
</tr>
<tr>
<td>Jotai</td>
<td>Automatic - atoms are stored as keys in a <code>WeakMap</code> under the hood</td>
</tr>
<tr>
<td>Zustand</td>
<td>Semi-automatic - API’s are available to aid in manually unsubscribing components</td>
</tr>
<tr>
<td>Valtio</td>
<td>Semi-automatic - Garbage collected when subscribing components unmount</td>
</tr>
</tbody>
</table><h2 id="concluding-thoughts">Concluding thoughts</h2><p>There’s no right answer as to what is the best global state management library. A lot will depend on the needs of your specific application and who is building it.</p><p>Understanding the underlying unchanging problems state management libraries need to solve can help us assess both the libraries of today and the ones that will be developed in the future.</p><p>Going into depth on specific implementations is outside the scope of this article. If you’re interested to dig deeper I can recommend <a href="https://twitter.com/dai_shi">Daishi Kato’s</a> <a href="https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks">React state management book</a>, which is a good resource to go deeper into specific side-by-side comparisons of some of the newer libraries and approaches mentioned in this post.</p><h2 id="references">References</h2><ul>
<li><a href="https://developers.soundcloud.com/blog/garbage-collection-in-redux-applications">Garbage Collection in Redux Applications</a></li>
<li><a href="https://www.youtube.com/watch?v=lGEMwh32soc">React without memo</a></li>
<li><a href="https://react-redux.js.org/api/hooks#stale-props-and-zombie-children">The zombie child problem</a></li>
<li><a href="https://github.com/reactwg/react-18/discussions/86">useMutableSource -&gt; useSyncExternalStore discussion</a></li>
<li><a href="https://github.com/dai-shi/proxy-compare">Proxy compare</a></li>
<li><a href="https://github.com/dai-shi/use-context-selector">useContextSelector</a></li>
<li><a href="https://remix.run/blog/remix-data-flow">Data flow in Remix</a></li>
</ul>
        </article>
</div></div>
  </body>
</html>
