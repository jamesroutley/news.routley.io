<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://thingspool.net/morsels/page-10.html">Original</a>
    <h1>Game Programming in Prolog</h1>
    
    <div id="readability-page-1" class="page">

<a href="https://thingspool.net/morsels/list.html">Back to List</a>

<h3>Author: Youngjin Kang</h3>
<h3>Date: August 25, 2024</h3>

<hr/>

<h3><b>Introduction</b></h3>
<p>As a fan of unconventional programming paradigms, I enjoy learning new programming languages which are drastically different from the typical object-oriented ones such as C#, Java, and the like. The most iconic of them are LISP (which is a powerful language for both functional programming as well as metalinguistic patterns in software development) and Prolog (which is one of the most popular languages in logic programming). Learning these languages is quite hard, compared to being acquainted with usual C-style imperative languages such as Ruby and Python, yet it has turned out to be one of the most effective ways of exercising one&#39;s brain.</p>
<p>By the time I started learning LISP via MIT&#39;s 1986 lecture series called &#34;SICP (Structure and Interpretation of Computer Programs)&#34; back in 2018, I was already quite familiar with some of its core concepts (such as lambda expressions, higher-order functions, etc) because they were already integrated as some of the main features of C#, which was the language I was using all the time as a Unity game developer. Also, my academic background in electrical engineering (signal processing in particular) helped me easily grasp the idea of &#34;stream processing&#34; which appeared in the latter half of the lecture series. Thus, learning LISP and its functional design patterns was not as difficult as I imagined it to be.</p>
<p>A major intellectual challenge, however, struck me when I began to study Prolog - the famous logic programming language which is notorious for its esoteric syntax. The grammar itself did not appear to be complicated at all; it was just as minimal as that of LISP. The way in which programming had to be done in Prolog, though, was stressful enough to fry the engine of my brain. The way it approached data structures (such as lists) and algorithms based upon mathematical relations was something so revolutionarily novel to me, that it seriously opened up a new horizon in my faculty of computational reasoning.</p>
<p>While Prolog&#39;s approach in software development was quite alien to me, I managed to notice a number of familiar associations between Prolog and many useful topics in engineering. I discovered, for example, that the so-called &#34;relational databases&#34; (e.g. MySQL) are named so not because they comprise data tables which are related to each other via references, but because each row of a data table can be considered an n-ary predicate (where &#39;n&#39; is the number of columns in the table) in Prolog&#39;s syntax. Besides, I found out that the input/output behavior of each digital circuit component (e.g. logic gate) could be implemented as an n-ary relation (where &#39;n&#39; is the total number of the input/output ports combined), implying that an &#34;object&#34;, whether it be a piece of hardware or a piece of pure data in memory, may as well be defined as a relation in logic programming (just like an object may as well be defined as a function in functional programming). Furthermore, the declarative nature of Prolog strongly convinced me that it must be optimal for data-driven design.</p>
<p>These realizations soon led me to contemplate upon the notion that, maybe, logic programming has a great deal of potential in the design and implementation of highly complex systems, such as a video game&#39;s core gameplay mechanics. I began to ask myself, &#34;Will it be possible to develop an entire game using the grammar of logic programming?&#34;</p>
<p>Indeed, there are reasons why most game developers just stick to general-purpose programming languages (such as C#) for making games, aside from purely experimental purposes. Implementing an entire game based on Prolog, for instance, is perhaps too much of a challenge for those who are not hardcore mathematicians. Also, Prolog may not be the best language to use for parts of the project which are not necessarily made of a complex web of relations, such as simple I/O modules, graphics modules, audio modules, physics modules, and the like.</p>
<p>However, I believe that at least the core mechanics of a game can definitely be implemented using the language of Prolog, and that we will be able to solve a plethora of complex design problems by doing so. It is because a gameplay system which is structured in terms of a set of declarative statements will be far more robust, modular, and free of confusing edge cases (e.g. race conditions) than an imperative system.</p>
<p>For this alternative methodology to be successful, one must start by designing the system in terms of logical relations/predicates only, and nothing else (That is, no functions, no structs, no classes, no interfaces, no state variables, etc). This will allow us to construct a gameplay system which is purely driven by the soul of Prolog.</p>
<hr/>

<h3><b>World and Actors</b></h3>
<p>The core idea in Prolog-based game programming is to utilize relations as the most primitive building blocks of the system, just like basic circuit components (e.g. resistors, transistors, capacitors, inductors, etc) are the most primitive building blocks of an electric circuit. It is sensible, therefore, to start this journey by considering the most rudimentary relations (e.g. unary and binary) first, and see if these elements can serve as the most essential nuts and bolts of the game.</p>
<img src="https://thingspool.net/morsels/e01.jpg" alt="Game Programming in Prolog - Part 1 (Figure 1)"/>
<p>Suppose that we are designing a game, and that the game consists of two major parts - world and actors (see the image above). The world is a scene in which everything is supposed to happen, and actors are objects which belong to the world. Examples of actors include &#34;players&#34;, &#34;enemies&#34;, &#34;obstacles&#34;, &#34;items&#34;, and pretty much any discrete entities which have their own names and attributes. Actors are able to interact with each other (as well as with themselves), from which various events occur. What we refer to as &#34;gameplay&#34; is a chain of such events.</p>
<p>We will begin formulating a gameplay system based off of this conceptual backbone. All you need to remember is that there is a world, and that the world contains a number of actors, each of which possesses its own state and behavior.</p>
<hr/>

<h3><b>Tags</b></h3>
<p>First of all, let us identify each individual actor with a unique name. If there are two actors in the world, for instance, we will simply assume that the name &#34;actor1&#34; and &#34;actor2&#34; will be used to indicate the first and second actors, respectively.</p>
<img src="https://thingspool.net/morsels/e02.jpg" alt="Game Programming in Prolog - Part 1 (Figure 2)"/>
<p>The first piece of logic I will illustrate is the idea of tags. A tag is a keyword which, when attached to an actor, describes what the actor stands for. When an actor has the tag &#34;bread&#34; attached to it, for example, we should be able to tell that the actor is a piece of bread.</p>
<p>The Prolog code below assigns the tag &#34;bread&#34; to both actor1 and actor2, in the form of unary predicates (The tag &#34;bread&#34; itself is an unary relation, and &#34;bread(actor1)&#34; &amp; &#34;bread(actor2)&#34; are two separate instances of it). This implies that both actor1 and actor2 are pieces of bread.</p>
<div><pre><code>bread(actor1).
bread(actor2).</code></pre></div>
<img src="https://thingspool.net/morsels/e03.jpg" alt="Game Programming in Prolog - Part 1 (Figure 3)"/>
<p>An actor can have multiple tags as well. However, one may feel that it is a bit too tedious to manually assign a bunch of tags to each individual actor. For example, let us say that every piece of bread must also be labeled as flammable and decomposable. This means that, whenever an actor is associated with the tag &#34;bread&#34;, we are obliged to always ensure that it is also associated with the tag &#34;flammable&#34; and &#34;decomposable&#34;. Manually attaching these two additional tags to every &#34;bread&#34; actor is way too cumbersome and error-prone. Fortunately, the following pair of horn clauses neatly solve this problem. They enforce the following two rules:</p>
<p>(1) Whenever tag &#34;bread&#34; is assigned to actor X, tag &#34;flammable&#34; will automatically be assigned to actor X.</p>
<div><pre><code>flammable(X) :- bread(X).
decomposable(X) :- bread(X).</code></pre></div>
<img src="https://thingspool.net/morsels/e04.jpg" alt="Game Programming in Prolog - Part 1 (Figure 4)"/>
<p>These horn clauses, therefore, serve as part of the game&#39;s &#34;config data&#34; - a list of data entries in the game&#39;s technical design document (like the ones you would see on a spreadsheet) telling us the characteristics of each individual character type, skill type, mission type, and so forth. The tags called &#34;flammable&#34; and &#34;decomposable&#34; in our case, for instance, are characteristics which belong to the type-specifier called &#34;bread&#34;, meaning that any actor which can be identified as &#34;bread&#34; is a composition of two properties called &#34;flammable&#34; and &#34;decomposable&#34;.</p>
<p>A decent analogy can be found in Unity game engine, where we may create a prefab called &#34;Bread&#34; with two components in it - &#34;Flammable&#34; and &#34;Decomposable&#34;. Or, in a general object-oriented programming environment, &#34;Bread&#34; may stand for the name of a class which implements two interfaces called &#34;IFlammable&#34; and &#34;IDecomposable&#34;.</p>
<p>In a way, therefore, horn clauses in Prolog play the role of data type definitions.</p>
<img src="https://thingspool.net/morsels/e05.jpg" alt="Game Programming in Prolog - Part 1 (Figure 5)"/>
<p>Aside from these pre-configured tags (which all rely on the presence of the tag &#34;bread&#34;), one may as well attach a custom tag to an actor as needed. For example, imagine that a wizard happened to enchant actor2 (i.e. the second piece of bread). This means that, unlike actor1 which is an ordinary piece of bread, actor2 must be an &#34;enchanted&#34; piece of bread which is required to have the tag &#34;enchanted&#34; attached to it for the purpose of showing us that it has been enchanted. The code below ensures that this is the case.</p>

<img src="https://thingspool.net/morsels/e06.jpg" alt="Game Programming in Prolog - Part 1 (Figure 6)"/>
<p>The tags &#34;flammable&#34; and &#34;decomposable&#34; are characteristics of all pieces of bread, whereas the tag &#34;enchanted&#34; is a characteristic of only special pieces of bread which have been enchanted by a wizard.</p>
<hr/>

<h3><b>Relationships</b></h3>
<p>So far, we have been using tags for specifying the characteristics of each individual actor. In a gameplay system, however, we also need to specify relationships between actors, such as ways in which they interact, etc.</p>
<p>In an ecosystem, predators chase preys and preys run from predators. In a dating simulator, a guy tries to flirt with girls and girls reject him. In a social simulator (such as The Sims), people are either friends or enemies of each other, or somewhere in between. In the game of chess, a bishop devours a rook diagonally and a rook devours a bishop orthogonally. These are all relationships out of which the game&#39;s dynamics emerge.</p>
<p>Defining actor-to-actor relationships in Prolog is pretty straightforward. Just like an unary predicate can be used to characterize a single actor, a binary predicate can be used to characterize a relationship between a pair of actors. And by means of a horn clause, such a relationship can be dynamically deduced from a set of requisite conditions.</p>
<p>The following code is an example of a relationship. Suppose that there is a third actor called &#34;actor3&#34;, and that we have declared it as a human (by attaching the tag &#34;human&#34; to it). Since a human is able to eat a piece of bread, we can confidently assert that &#34;X can eat Y if X is a human and Y is a piece of bread&#34;. Here, &#34;X can eat Y&#34; is a relationship which holds whenever X is associated with tag &#34;human&#34; and Y is associated with tag &#34;bread&#34;.</p>
<div><pre><code>human(actor3).
canEat(X, Y) :- human(X), bread(Y).</code></pre></div>
<img src="https://thingspool.net/morsels/e07.jpg" alt="Game Programming in Prolog - Part 1 (Figure 7)"/>
<p>Here is another example. Since a piece of bread is decomposable (because anything which is identified as &#34;bread&#34; must also be identified as &#34;decomposable&#34;), we know that microbes such as fungi are capable of spoiling it. If there is an actor with the tag &#34;fungus&#34; attached to it, therefore, we will be able to tell that it must be able to spoil any other actor which is &#34;decomposable&#34;. This is yet another case of a relationship between two types of actors; it is a relationship which says, &#34;X can spoil Y if X is a fungus and Y is decomposable&#34;. The following code shows its definition.</p>
<div><pre><code>fungus(actor4).
canSpoil(X, Y) :- fungus(X), decomposable(Y).</code></pre></div>
<img src="https://thingspool.net/morsels/e08.jpg" alt="Game Programming in Prolog - Part 1 (Figure 8)"/>
<p>There is something still missing here, though. While I have demonstrated that it is possible to assign characteristics to individual actors as well as their mutual connections (i.e. relationships), I have not shown yet how to make these characteristics change over time. They all have been static so far, and the declarative nature of Prolog does not seem to offer an easy solution to make things dynamic.</p>
<p>If we want to create a game rather than a fixed landscape of how things are shaped permanently, we better let them move and interact as time goes by. In the next part of the series, I will explain how the game loop shall be conceptualized in Prolog.</p>
<p>(Will be continued in <a href="https://thingspool.net/morsels/page-11.html">Part 2</a>)</p>


</div>
  </body>
</html>
