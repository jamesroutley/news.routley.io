<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://educatedguesswork.org/posts/memory-management-1/">Original</a>
    <h1>Understanding Memory Management, Part 1: C</h1>
    
    <div id="readability-page-1" class="page"><div>
          <main>
            
<div>
  <div>
    <article>
        
        

        <p><img src="https://antiantihuman.com/img/userust.jpg" alt="Cover image"/></p>
<p>I&#39;ve been writing a lot of <a href="https://www.rust-lang.org/">Rust</a>
recently, and as anyone who has learned Rust can tell you, a huge part
of the process of learning Rust is learning to work within its
restrictive memory model, which forbids many operations that would be
perfectly legal in either a systems programming language like C/C++ or
a more dynamic language like Python or JavaScript. That got me thinking
about what was really happening and what invariants Rust was
trying to enforce.</p>
<p>In this series, I&#39;ll be walking through the logic of memory management
in software systems, starting with the simple memory management in C and then
working up to more complicated systems. This series isn&#39;t intended
to be a tutorial on how to write C, Rust, or any other language; rather
the idea is to look at how things actually work under the hood
at a level that we usually ignore when all we are doing is trying
to write code.</p>
<h2 id="how-programs-use-memory">How Programs Use Memory <a href="#how-programs-use-memory">#</a></h2>
<p>Consider the following program, written in Python</p>
<pre><code>all_lines <span>=</span> <span>[</span><span>]</span></code></pre>
<p>This program does something very simple, namely, it reads input
from the file one line at the time, then sorts the lines, and
prints out the lines in sorted order. So if <code>input.txt</code> has
the following contents:</p>
<pre><code>jim</code></pre>
<p>The output will be:</p>
<pre><code>bob</code></pre>
<p>However, there is something
complicated hiding under the hood: because we don&#39;t know the
sort order of the lines in advance, we have to store all of the
lines we&#39;ve read until we know that we&#39;ve seen all of them, and
only then can we write them in sorted order.
If we&#39;re going to store all the lines, they have to go somewhere,
which is in the computer&#39;s memory.</p>
<h3 id="storing-a-list">Storing a List <a href="#storing-a-list">#</a></h3>
<p>Conceptually, a computer&#39;s memory is just a giant table of values,
with each value having an address. For convenience, let&#39;s assume
that entries are numbered from 0 and each entry can hold a single
character. Thus, if we want to store the string &#34;computation&#34;, we end
up with something like:</p>
<div>
<table>
<thead>
<tr>
<th>Memory Address</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>c</td>
</tr>
<tr>
<td>1</td>
<td>o</td>
</tr>
<tr>
<td>2</td>
<td>m</td>
</tr>
<tr>
<td>3</td>
<td>p</td>
</tr>
<tr>
<td>4</td>
<td>u</td>
</tr>
<tr>
<td>5</td>
<td>t</td>
</tr>
<tr>
<td>6</td>
<td>a</td>
</tr>
<tr>
<td>7</td>
<td>t</td>
</tr>
<tr>
<td>8</td>
<td>i</td>
</tr>
<tr>
<td>9</td>
<td>o</td>
</tr>
<tr>
<td>10</td>
<td>n</td>
</tr>
</tbody>
</table>
</div>
<p>Or, in a more compact notation:</p>
<pre><code>Starting Address
0           | c | o | m | p | u | t | a | t | i | o |
10          | n |
</code></pre>
<p>The way to read this is that each cell is a memory location and on
the left we have the starting address for each row, so the <code>p</code> is at
address 3 (the fourth column in the first row).</p>
<p>With this in mind, how do we store the data from this file into
memory. The obvious way is something like this, which immediately
reveals that we have a problem:</p>
<pre><code>0           | j | i | m | b | o | b | d | e | b | c |
10          | a | r | o | l |
</code></pre>
<p>If we just concatenate the values in memory, how do we know where one
line ends and the next begins? For instance, maybe the first two
names are &#34;jim&#34; and &#34;bob&#34; or maybe it&#39;s one person named &#34;jimbob&#34;,
or even two people named &#34;jimbo&#34; and &#34;b&#34;. Obviously, we need some
way to keep track of the memory regions associated with individual values.</p>
<p>There are a number of alternatives here, but let&#39;s just do something
obvious, which is to prefix every value with its length, like so:</p>
<pre><code>0           | 3 | j | i | m | 3 | b | o | b | 3 | d |
10          | e | b | 5 | c | a | r | o | l |
</code></pre>
<p>If you know that an entry starts at address X, then you can print out
that entry in the obvious way:</p>
<pre><code>address = X
length = *X
address = address + 1
while length &gt; 0 {
    address = address + 1
    print *address
}
</code></pre>
<p>For non-C programmers, the notation <code>*X</code> means &#34;take the value at memory address X&#34; (technical
term: <em>dereferencing</em> <code>X</code>) so the second
line is setting <code>length</code> to be whatever is in X and the 5th line is
printing whatever is currently stored at <code>address</code>. So, what happens here
is that we first read the length of the current line out of <code>address</code>, then count
down one character at a time.</p>
<p>So far so good, but what if we want to print out the whole list? The obvious
thing to do is just to repeat the process above, but now we have a new
problem, which is knowing when to stop. Remember that the memory is a giant
table and we&#39;re just showing the relevant portion of it. In reality,
we have:</p>
<pre><code>0           | 3 | j | i | m | 3 | b | o | b | 3 | d |
10          | e | b | 5 | c | a | r | o | l | O | T |
20          | H | E | R |   |   | S | T | U | F | F |
30          | . | . | . |
</code></pre>
<p>This is just a new version of the same problem, which is we don&#39;t want
want to read off the end of the list. This requires knowing where does our list
end and the other stuff in memory begins. One obvious thing to do is to prefix
the list with the amount of memory that it consumes, like so:</p>
<pre><code>0           | 19| 3 | j | i | m | 3 | b | o | b | 3 |
10          | d | e | b | 5 | c | a | r | o | l |
</code></pre>
<p>Now we can write a program to go over the whole list, like so:</p>
<pre><code>total_length <span>=</span> <span>*</span>X</code></pre>
<p>Note that this is a <em>self-contained</em> object. As long as you know where it
starts and what type it is (i.e., a list of strings), then you can read
it out knowing just the starting address <code>X</code>. I.e., we can have a
subroutine/function, like so:</p>
<pre><code>function <span>print_list</span><span>(</span>X<span>)</span> <span>{</span></code></pre>
<p>However, we <em>do</em> have to remember where the object starts, as it&#39;s
not going to always start at <code>0</code> (what if we have two lists, or a
list and something else?). So how do we do that?</p>
<h3 id="the-stack">The Stack <a href="#the-stack">#</a></h3>
<p>Up till now I&#39;ve been acting like memory is just an undifferentiated
table, but the reality is much more complicated.
Although from a hardware perspective the memory is largely undifferentiated
there is a conventional way to lay things out, as shown in this
diagram I borrowed from Geeksforgeeks:</p>
<p><img src="https://cdncontribute.geeksforgeeks.org/wp-content/uploads/memoryLayoutC.jpg" alt="C memory architecture"/></p>
<p>To orient yourself, address zero is at the bottom of the diagram
and higher addresses are at the top. The program is actually
split up into two pieces: the program itself (&#34;the <em>text</em> segment&#34;)
There are also two different parts of memory where the program&#39;s
data is stored call the &#34;stack&#34; and the &#34;heap&#34;. Very roughly speaking,
they are used like this:</p>
<ul>
<li>
<p>The <strong>stack</strong> is used to store fixed-size data that is part of the
local context of the function.</p>
</li>
<li>
<p>The <strong>heap</strong> is used to store arbitrary-sized data or data that
survives past the lifetime of a function.</p>
</li>
</ul>
<p>For instance, in our <code>print_list()</code> function above, <code>total_length</code>, <code>address</code>,
and <code>length</code> are fixed size values (effectively integers big enough to hold
a memory address), so they can be allocated on the stack. By contrast,
the list of strings is arbitrary sized and in fact of a size that&#39;s
dependent on the file we are reading in, and so is allocated on the heap.</p>
<p>When we call a function in a compiled language like C (or Rust), the
compiler makes sure you have enough space on the stack to store all
the variables it needs and makes room for it in memory. This is called
a &#34;stack frame&#34;. So, <code>print_list()</code> would have a stack frame big
enough to store all three of these values just laid out end to end,
like so:</p>
<pre><code>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| total_length  |   address     |   length      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>
<p>Importantly, the layout here is fixed (and dictated by the compiler)
and so we don&#39;t need to have any metadata telling us how long things
are; the compiler just knows.</p>
<p>The stack is laid out <em>contiguously</em> in memory, with each function
call extending the stack by enough room for the stack frame associated
with that function, which depends on which function it is.
For technical reasons, the stack grows &#34;downward&#34; in memory towards
smaller addresses, so the callee has a lower address than the caller.
The following figure shows a simple example.</p>
<figure>
<p><img src="https://antiantihuman.com/img/function-call-stack.png" alt="The stack for a simple function call"/></p>
<figcaption>
The stack before, during, and after simple function call
</figcaption>
</figure>
<p>At the left of the figure, we see the situation where we are in
the function <code>f()</code>. The stack just consists of the stack from
for <code>f()</code>. If <code>f()</code> calls <code>g()</code> then we add a new stack frame
for <code>g()</code> (technical term: <em>pushing</em> onto the stack), shown in the middle of the figure. Then when <code>g()</code>
returns, the stack shrinks (technical term: <em>popping</em> the stack), leaving
us back where we were before. Note that if <code>f()</code> called a different
function <code>h()</code>, it would end up where the <code>g()</code> frame was before,
but might be of different size, depending on how many local
variables it had.</p>
<p>You should now be able to see why the stack isn&#39;t suitable for
variable-sized objects: we need to allocate the stack frame when
the function is called, and we can&#39;t do that if we don&#39;t know how
big the variables in the stack will be. It&#39;s possible to grow stack
frames but not convenient, so instead, we need to
allocate them somewhere else, which is what the heap is used for.</p>
<h3 id="the-heap">The Heap <a href="#the-heap">#</a></h3>
<p>Conceptually the heap is just a big pile of memory that we can allocate
space out of. In many languages (e.g., Python or JavaScript)
this is done automatically when you make an object, but in C,
you have to do memory management by hand. This is done with the <code>malloc()</code> API, which is
used like this:</p>
<pre><code>space <span>=</span> <span>malloc</span><span>(</span><span>100</span><span>)</span><span>;</span></code></pre>
<p>This works exactly like you would expect, namely reserving a block of
100 bytes on the heap that the caller can then use however they want.
The return value from <code>malloc()</code> is the memory address of the allocated
region. Internally, of course, <code>malloc()</code> has to do some bookkeeping
to know which memory is in use and which is not. There are a large number
of different data structures that can be used here, but essentially any
technique will involve using some of the heap for that bookkeeping,
leaving the rest available for allocation.</p>
<h2 id="memory-management-in-c">Memory Management in C <a href="#memory-management-in-c">#</a></h2>
<p>With that background, let&#39;s try rewriting our program in C, where
we have to do the memory management by hand. This gets a lot more
complicated, so let&#39;s take it in pieces.</p>
<h3 id="read-in-the-file.">Read in the file. <a href="#read-in-the-file.">#</a></h3>
<p>First, we have to read in the file.</p>
<pre><code>  FILE <span>*</span>fp <span>=</span> <span>fopen</span><span>(</span><span>&#34;input.txt&#34;</span><span>,</span> <span>&#34;r&#34;</span><span>)</span><span>;</span></code></pre>
<p>We start by opening the input file, in this case <code>input.txt</code>. Then,
as before, we&#39;re going to iterate over the lines in the file and
add them to our list of stored lines. This is accomplished by our
<code>while</code> loop.</p>
<p>We can read the line in using the <code>fgets()</code> function, which
reads a line (defined by ending in a <code>\n</code> newline character)
out of the file <code>fp</code> into the buffer (memory region) associated with <code>line</code>.</p>
<pre><code>  <span>char</span> line<span>[</span><span>1024</span><span>]</span><span>;</span></code></pre>
<div>
<h4 id="what&#39;s-a-buffer%3F">What&#39;s a buffer? <a href="#what&#39;s-a-buffer%3F">#</a></h4>
<p>For those of you who haven&#39;t heard the term before, a <em>buffer</em> is just
programmer jargon for some piece of storage used to hold data
temporarily, as in this case case where we&#39;re reading in a line
of data and then quickly doing something with it. It&#39;s also
the name for this doodad which is responsible for stopping trains
which don&#39;t stop on their own at the end of the track.</p>
<p><img src="https://antiantihuman.com/img/Airtrain_Domestic_stn_end_of_railway.jpg" alt="A buffer"/></p>
<p>From Wikipedia by <a href="https://commons.wikimedia.org/wiki/User:Orderinchaos" title="User:Orderinchaos">User:Orderinchaos</a> - <span lang="en">Own work</span>, <a href="https://creativecommons.org/licenses/by-sa/3.0" title="Creative Commons Attribution-Share Alike 3.0">CC BY-SA 3.0</a>, <a href="https://commons.wikimedia.org/w/index.php?curid=34243713">Link</a></p>
</div>
<p>There&#39;s already something sus here, though. Did you notice the line <code>char line[1024]</code>?
This is C notation for &#34;make a buffer called line which is long enough to hold 1024 characters&#34;.
As noted before, <code>line</code> has to be fixed size and 1024 is just an arbitrary
number that&#39;s hopefully large enough to hold any line in the file.
But what if
one of the lines is longer? In that case, <code>fgets()</code> will break up the line into
two pieces, causing the program to be incorrect. The right way to do this would
actually be to keep reading until we had a full line, but this would make
the program even more complicated, so we&#39;ll just live with the defect, seeing
as it&#39;s an example program.</p>
<p><code>fgets()</code> returns a pointer to the input buffer if successful and a zero value
(<code>NULL</code>) at the end of the file (or any error, actually), so when we test
for <code>l</code>, we are actually testing for the end of the file, at which point the
loop exits.</p>
<p>At this point, we have the next line of the file in <code>line</code>, but we overwrite
that buffer every time we read a new line from the file, so we need to store it
somewhere. We use the <code>lines</code> variable for this, which is defined as:</p>
<pre><code>  <span>char</span> <span>*</span><span>*</span>lines <span>=</span> <span>NULL</span><span>;</span></code></pre>
<p>This notation can be a bit hard to read for non C programmers, but briefly <code>*</code> means
that something is a <em>pointer</em>, which is to say that it&#39;s something that holds a
memory address. <code>**</code> means that it&#39;s a pointer to a pointer, which is to say that
<code>lines</code> holds the address of a block of memory that is itself full of values
that themselves are memory addresses, in this case the individual stored lines.
<code>num_lines</code> stores the number of lines that we have in memory.</p>
<p>We can see this in action by looking at the next block of code:</p>
<pre><code>    </code></pre>
<p>Storing a copy of <code>line</code> is a two-part process:</p>
<ol>
<li>Make a copy of the line itself.</li>
<li>Store the pointer to that line in <code>lines</code>.</li>
</ol>
<p>However, in order to store that pointer, we first need to make room in
<code>lines</code>, which means allocating some memory. This happens on the two lines
at the start of this snippet. There are actually two cases here:</p>
<ol>
<li>Lines is empty (nothing is stored), which happens at the start.</li>
<li>Lines is non-empty but doesn&#39;t have enough room.</li>
</ol>
<p>We distinguish these by looking at <code>num_lines</code> which starts at <code>0</code>.
In the former case, we allocate enough memory for a single line,
like so:</p>
<pre><code>      lines <span>=</span> <span>malloc</span><span>(</span><span>sizeof</span><span>(</span><span>char</span> <span>*</span><span>)</span><span>)</span><span>;</span></code></pre>
<p>This says &#34;make enough room to hold the address of a single string&#34;,
and is nothing we haven&#39;t seen before.</p>
<p>The latter case is more complicated, however, because we already
have something in <code>lines</code>, it&#39;s just that there&#39;s not (necessarily)
enough room in memory to add another value. This means we (may) need to</p>
<ol>
<li>Allocate enough memory to hold the new number of values.</li>
<li>Copy over the current contents of <code>lines</code> into the new
memory region.</li>
<li>De-allocate the original memory.</li>
</ol>
<p>What are all the parentheticals doing here? The answer is that
the block of memory pointed to by <code>lines</code> may already be big
enough. When you call <code>malloc(size)</code> the system guarantees that
the returned pointer is <em>at least</em> big enough to hold an object
of size <code>size</code>—assuming that the allocation succeeds—but it&#39;s
allowed to be larger. This could happen for a number of reasons
(see <a href="#how-malloc-works">How Malloc Works</a> below for some more
background), but one of which is to facilitate exactly this
case: if people want to resize an object frequently, as we are doing
here, then it&#39;s not efficient to have to copy the contents of
the object over and over again. Instead, you can allocate more
space than the programmer asked for and then when they ask for
more, just say &#34;ok&#34; without taking any other action.
All of this is handled automatically by the <code>realloc()</code> function call.
At the end of this process <code>lines</code> may or may not have the same
value from what you passed into <code>realloc</code>. What
matters, though, is that the memory that <code>lines</code> points to has
the same contents as before, and that&#39;s what <code>realloc()</code> guarantees.</p>
<p>It&#39;s also possible that the memory allocation will fail, for instance
if the computer is out of memory. In that case, <code>lines</code> will be set to
<code>NULL</code> and we need to abort:</p>
<pre><code>    if (!lines) {
      abort(); // We are out of memory so panic.
    }
</code></pre>
<p>Now that we have room in <code>lines</code> we can store a copy of the actual
line we&#39;ve read in, but first we have to make a new buffer to store
it in (remember that <code>line</code> will be overwritten). We can do that with
the <code>strdup()</code> function call, which makes a copy of a string,
allocating new memory as needed:</p>
<pre><code>    <span>char</span> <span>*</span>copy <span>=</span> <span>strdup</span><span>(</span>l<span>)</span><span>;</span></code></pre>
<p>Here too, we can run out of memory, so we need to check for <code>copy</code> being
<code>NULL</code>.</p>
<p>Finally, we can append the copied line to the end of <code>lines</code> and increment
the number of stored lines:</p>
<pre><code>    <span>char</span> <span>*</span>copy <span>=</span> <span>strdup</span><span>(</span>l<span>)</span><span>;</span></code></pre>
<p>The diagram below should help provide an understanding of the data structures
here:</p>
<figure>
<p><img src="https://antiantihuman.com/img/lines-buffer-unsorted.png" alt="Stored lines in C"/></p>
<figcaption>
Data structure for stored lines.
</figcaption>
</figure>
<p>On the left we have the <code>lines</code> variable itself, which is stored somewhere on the
stack. It contains the address of the memory we have allocated to store the
list of lines, namely address <code>1024</code>. That memory region is shown in the middle
of the diagram. Finally, on the right we have the individual regions for each
stored line. The memory region for <code>lines</code> stores their addresses, each laid
out one after the other. Note that there&#39;s no variable on the stack which
points to these regions, they&#39;re just pointed to by the addresses stored in
the region pointed to by <code>lines</code>.</p>
<h3 id="sorting-the-lines">Sorting the Lines <a href="#sorting-the-lines">#</a></h3>
<p>The next thing we do is to sort the lines. This is done by the <code>qsort()</code> library
function.</p>
<pre><code>  </code></pre>
<p><code>qsort()</code> is kind of hard to use because it&#39;s designed to sort a list of
any kind of object of any size. This means that you have to pass:</p>
<ul>
<li>The pointer (address) to the first object in the list (in this case <code>lines</code>)</li>
<li>The number of objects in the list (<code>num_lines</code>).</li>
<li>The <em>size</em> of the objects <code>sizeof(char *)</code>. In this case, that&#39;s the size
of a pointer to a string.</li>
<li>A comparison function which tells <code>qsort()</code> the sort order for two objects.
I&#39;m going to skip over the details here.</li>
</ul>
<p><code>qsort()</code> sorts its arguments in place, so this means that after it&#39;s
done, <code>lines</code> is sorted, like so:</p>
<figure>
<p><img src="https://antiantihuman.com/img/lines-buffer-sorted.png" alt="Stored lines in C (sorted)"/></p>
<figcaption>
Data structure for sorted stored lines.
</figcaption>
</figure>
<p>Importantly, the only thing that&#39;s changed here is the values in
the middle memory region, referenced by <code>lines</code>. The actual strings
are unchanged and are in the same memory regions; we&#39;ve just
rearranged the pointers in <code>lines</code> to point to the strings in
the right order. Note that that order is not given by the
numeric order but rather by the lexical order of the strings.
That&#39;s convenient, but actually required, because
<code>qsort()</code> doesn&#39;t know anything about the
objects it&#39;s sorting; it just knows how to pass them to the comparison
function, so all it can do is manipulate its own data as if the objects
were numbers, whatever their actual semantics.</p>
<h3 id="printing-the-results">Printing the Results <a href="#printing-the-results">#</a></h3>
<p>After all this, we&#39;re ready to print the results. This is comparatively
simple, just iterating over the entries in <code>lines</code> and printing the
corresponding strings:</p>
<pre><code>  </code></pre>
<p>One thing you may be wondering about here is how we know how long each
line is, as we haven&#39;t stored any length information. The convention in C is actually to have each string end with
a byte with the value of <code>0</code>, usually written as <code>\0</code>. This is
pretty universally agreed to have been a bad idea, but we&#39;re taking
advantage of it here because it means that the strings are self-contained.</p>
<h3 id="cleaning-up">Cleaning Up <a href="#cleaning-up">#</a></h3>
<p>Finally, we want to clean up. In this simple program, that&#39;s not really required
because when a program terminates the operating system automatically reclaims
its resources, including memory, but this function might be used by
some bigger program, in which case we&#39;d want to reclaim the memory
used by the list of strings, as well as close the open file (remember
<code>input.txt</code>?).</p>
<p>If this function were to return without cleaning up, it would create
what&#39;s called a &#34;memory leak&#34;. Remember that the only variable in
our program that knows about any of this memory is <code>lines</code>, which
points to the list of pointers for the individual stored lines. <code>lines</code>
is on the stack and will be lost when the function returns,
so if the function returns without cleaning up, then there is no
program variable pointing to any of this memory and it&#39;s just lost.
The result of a memory leak is that the leaked memory isn&#39;t available
for new allocations but also can&#39;t be used because there&#39;s nothing
pointing to it. If the program runs
long enough and has a big enough leak, you can eventually accumulate
enough leaked memory to affect the program function or even cause it
to run out of memory, so you want to clean up. This is one reason why
it often works to restart a program that seems stalled.</p>
<p>In C, memory is freed using the <code>free()</code> function, which takes the
pointer to be freed. Here&#39;s what the cleanup looks like:</p>
<pre><code>  </code></pre>
<p>Note that we need to free the stored lines before we free <code>lines</code>
because once we&#39;ve freed <code>lines</code> nothing points to the stored
lines and so there&#39;s no way to free them (remember, we need
their addresses). This means we need to iterate through <code>lines</code>
freeing each individual allocation and then only when we&#39;re
done freeing <code>lines</code> itself. Recall that all the local variables
will just be deallocated when the function returns. However,
this doesn&#39;t mean that the things they point to are deallocated,
just that the storage used by the variable itself is reclaimed.</p>
<h3 id="error-handling">Error Handling <a href="#error-handling">#</a></h3>
<p>Because this is demonstration code, I&#39;ve chosen to ignore the
case where a line is longer than 1024 characters, but what if
we wanted to handle that instead? You can detect this case with
<code>fgets()</code> by checking to see if you have a newline at the
end of the buffer</p>
<pre><code>    <span>char</span> <span>*</span>l <span>=</span> <span>fgets</span><span>(</span>line<span>,</span> <span>sizeof</span><span>(</span>line<span>)</span><span>,</span> fp<span>)</span><span>;</span></code></pre>
<p>The problem with this code is that it has a memory leak:
if we have already read in some of the lines, then we&#39;ll
leak <code>lines</code> and whatever lines we read in. In order to
avoid the leak, we need to run our cleanup routines.
Once common way to handle this is to have an <code>error</code> block
that we execute. For instance:</p>
<pre><code>  <span>int</span> status <span>=</span> OK<span>;</span></code></pre>
<p>The <code>goto</code> instruction here just says to go to the line labelled
<code>error</code>.</p>
<p>This works but is error prone: you need to note every
case where the function might return and jump to the right
error block. Moreover, the error block needs to be able to
clean up after any kind of error, so, for instance, it
needs to be able to handle when <code>lines = NULL</code> (fortunately,
<code>free()</code> handles this case automatically). Finally, if
you forget to set the <code>status</code> value, then you are incorrectly
returning an <code>OK</code> status even if there was an error.</p>
<h3 id="locally-scoped-allocations">Locally Scoped Allocations <a href="#locally-scoped-allocations">#</a></h3>
<p>You might ask why you can&#39;t just free <em>all</em> the memory that was
allocated by a function when the function returns rather than just
the memory on the stack? Then we wouldn&#39;t have to do all of
this stuff where we explicitly free everything.</p>
<p>There&#39;s an obvious answer to this question: some functions
<em>intentionally</em> allocate memory and don&#39;t clean it up. An obvious
example here is the <code>strdup()</code> function we used above. Internally,
strdup does something like this:</p>
<pre><code><span>char</span> <span>*</span><span>strdup</span><span>(</span><span>const</span> <span>char</span> <span>*</span>str<span>)</span> <span>{</span> </code></pre>
<p>If we automatically freed all memory that was allocated by the
function, then we would free <code>retval</code> before returning, at which point
the caller would be left with a pointer to memory that has been freed,
which is clearly a problem. In fact, it&#39;s the source of a common
security vulnerability called <a href="https://en.wikipedia.org/w/index.php?title=Dangling_pointer&amp;oldid=1248879275#use_after_free">use after
free</a>.
Clearly we would need something more sophisticated than just
freeing everything that was allocated in the function when
it exits.</p>
<p>What you actually want is the compiler to know when objects are
intended to outlive the function and when they are not, but actually
distinguishing these cases is very difficult in C, at least without
help from the programmer, as we will see in the rest of the series. In
fact, making this kind of analysis possible is one of the the main
motivating design choices for much of the Rust memory model.</p>
<h2 id="how-malloc()-works">How <code>malloc()</code> works <a href="#how-malloc()-works">#</a></h2>
<p>So far we&#39;ve just been treating <code>malloc()</code> as a kind of black box,
and that&#39;s generally fine for most programming tasks, but it&#39;s
helpful to have some sense of what&#39;s going on internally. The first
thing to realize is that <code>malloc()</code> isn&#39;t magic. In fact, you can
write your own memory allocator in C (Firefox, for instance, uses
a custom allocator).</p>
<p>At a very high level, you should think of <code>malloc()</code> as having
access to one or more large contiguous blocks of memory, which it
then dispenses on demand. On a very simple computer, <code>malloc()</code> would
just have access to the entire memory of the machine, but on a
modern multiprocess operating system, it gets chunks of memory
from the operating system. For our purposes, let&#39;s easiest to
think of it as having a big contiguous chunk of memory to work
with. As I said, we usually wouldn&#39;t start at memory location 0,
so we&#39;ll just assume the block starts at 1000.</p>
<p>The figure below shows the situation after a single allocation
of size 200, with the allocation being red and the unallocated
space being blue. What&#39;s happened here is just that <code>malloc(200)</code>
just picked the first available memory region, which is
at the start of the block because no memory has been allocated.</p>

<p><em>Note: If the following diagram doesn&#39;t render properly, it&#39;s
probably because your mail reader doesn&#39;t allow inline styles.
Try reading the <a href="https://educatedguesswork.org/posts/memory-management-1">Web version</a>.</em></p>
<figure>
<div>
   <div>
    <p>1: 1000-1199</p>
    <p>Unallocated</p>    
   </div>
  <div>
    <p>Unallocated</p>    
   </div>
</div>
</figure>
<p>The allocation starts at address 1000 and goes to address 1199,
so <code>malloc()</code> just returns the address <code>1000</code>, which points
to the start of the allocated region.</p>
<p>The next figure shows the situation with two more allocations, one of
size 400 and one of size 200. Again, this is what you&#39;d expect: the
allocator just picks the lowest available region.  As noted above, a
real allocator would probably leave some extra space to facilitate growing
the allocation but we&#39;re trying to keep things simple for the purpose
of examples. Designing fast memory allocators is a whole (complicated)
topic all on its own.</p>
<figure>
<div>
   <div>
    <p>1: 1000-1199</p>
    <p>2: 1200-1599</p>
    <p>3: 1600-1799</p>    
    <p>Unallocated</p>    
   </div>
  <div>
    <p>Unallocated</p>    
   </div>
</div>
</figure>
<p>So far so good, but now what happens when we free allocation #2?
The result is shown below.</p>
<figure>
<div>
   <div>
    <p>1: 1000-1199</p>
   <p>Unallocated</p>    
    <p>3: 1600-1799</p>    
    <p>Unallocated</p>    
   </div>
  <div>
    <p>Unallocated</p>    
   </div>
</div>
</figure>
<p>We have a 400 byte
sized hole of free memory. If we try to do another 200
byte allocation, it will work fine, like so:</p>
<figure>
<div>
   <div>
    <p>1: 1000-1199</p>
    <p>4: 1200-1399</p>    
   <p>Unallocated</p>    
    <p>3: 1600-1799</p>    
    <p>Unallocated</p>    
   </div>
  <div>
    <p>Unallocated</p>    
   </div>
</div>
</figure>
<p>But if we now try to allocate another 400 bytes, it obviously won&#39;t
fit, so we need to go into higher memory.</p>
<figure>
<div>
   <div>
    <p>1: 1000-1199</p>
    <p>4: 1200-1399</p>    
   <p>Unallocated</p>    
    <p>3: 1600-1799</p>    
    <p>Unallocated</p>    
   </div>
  <div>
    <p>4: 2000-2399</p>      
    <p>Unallocated</p>    
   </div>
</div>
</figure>
<p>As the program runs longer and memory is allocated and freed
you tend get lots of small holes that can&#39;t be filled with big
allocations, and so you have to allocate higher and higher
memory regions. This is called <em>fragmentation</em>.
In the extreme, you can get to the point where
you can&#39;t allocate new memory even though there&#39;s actually
plenty of free space; it&#39;s just not in a convenient form.
There are techniques for avoiding this kind of
fragmentation as well as for allocating memory more efficiently,
but they&#39;re too advanced to cover here.</p>
<div>
<h5 id="how-does-malloc()-get-its-memory%3F">How does <code>malloc()</code> get its memory? <a href="#how-does-malloc()-get-its-memory%3F">#</a></h5>
<p>As I said above, <code>malloc()</code> gets chunks of memory from the operating
system. Remember that your program has to share the computer, including
its memory, with other programs and the operating system is responsible
for arbitrating which program has which chunk of memory. Conceptually
this is actually somewhat like <code>malloc()</code> except that <code>malloc()</code>
calls some system API (for instance, <a href="https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man2/mmap.2.html"><code>mmap()</code></a> to request memory from the operating system.</p>
<p>Note that modern systems all have <a href="https://en.wikipedia.org/w/index.php?title=Virtual_memory&amp;oldid=1263034421">virtual
memory</a>,
systems in which the system automatically moves (&#34;swaps&#34;) data in and
out of the physical memory and onto disk so that programs can
allocate more space than is in the hardware of the system. In order
to this, the operating system may have to move stuff around
in physical memory, so it maintains a mapping from the address
the programs use to the actual physical location in memory.
In a future post, I may cover virtual memory in more detail, but
no promises.</p>
</div>
<p>A natural question to ask is why we can&#39;t just move things around
to accommodate the holes? The reason is that the pointers stored
in the program literally just point to the memory addresses
where the allocations are stored. So if (for instance) we were
to slide allocation #3 over to the right to make room for
allocation #4, then whatever pointer was returned from the initial
<code>malloc()</code> for #3 would now point somewhere in the middle of
allocation #4, which is obviously a problem. The compiler doesn&#39;t
keep track of the variables holding the pointers, so it has no
way to go back and readjust them.
The key thing to realize here is that all that <code>malloc()</code> and <code>free()</code>
are doing is <strong>bookkeeping</strong>: the allocator remembers which memory is
currently in use and then hands out pointers to regions that aren&#39;t
currently in use as needed. This naturally raises the
question of how the allocator does the bookkeeping. How does it
remember which regions are in use and which aren&#39;t? The obvious answer
is the right one: the allocator reserves some of the memory it
has to work with for this kind of bookkeeping metadata, at minimum:</p>
<ul>
<li>The size of each allocation (so it can be freed)</li>
<li>The regions that are currently free, for instance the
top of the highest allocation and the addresses of the
the freed holes.</li>
</ul>
<p>When you call <code>malloc()</code> the allocator finds a suitable region
and allocates it. When you call <code>free()</code> it adds it to the list
of holes (or adjusts the highest allocation value if it&#39;s the
highest allocation).</p>
<p>Interestingly, it&#39;s not always necessary to store a list
of every chunk of allocation memory. You can do this,
but that means you need some data structure that lets you
look up the allocations from their addresses. A common thing
people do instead is to store the per-allocation metadata
as a header right before the allocated region. The header
contains the size of the allocation and maybe some other stuff.
For instance, the first allocation above might look like this:</p>
<figure>
<div>
   <div>
    
    <p>1: 1100-1299</p>
    <p>Unallocated</p>    
   </div>
  <div>
    <p>Unallocated</p>    
   </div>
</div>
</figure>
<p>Instead of returning <code>1000</code>, in this case <code>malloc()</code> would return
<code>1100</code>. (I&#39;ve drawn it as 100 to make the figure more readable,
but hopefully you&#39;re not wasting 100 bytes of overhead on every allocation.)
Then when you call <code>free(1100)</code> the allocator would subtract
the size of the header and deallocate the whole region from
<code>1000-1299</code>. The reason this works is that <code>free()</code> requires
knowing the memory address anyway, so there&#39;s no need to
store it. If you call <code>free()</code> on some region of
memory that wasn&#39;t returned from <code>malloc()</code> the results are
likely to be disastrous, because <code>free()</code> has no way of knowing
that this is a mistake and will just treat whatever is right
before the pointer you passed in as the header. If that
data is attacker controlled, it can easily lead to a vulnerability.</p>
<h2 id="multiple-references-and-uaf">Multiple References and UAF <a href="#multiple-references-and-uaf">#</a></h2>
<p>Let&#39;s consider a slight modification of the function we&#39;ve been
looking at, in which along with printing out all the lines,
we instead return the last line in sort order.
With
a lot of trimming, the function might look like this:</p>
<pre><code><span>char</span> <span>*</span><span>find_smallest</span><span>(</span><span>const</span> <span>char</span> <span>*</span>filename<span>)</span></code></pre>
<p>This function gets called like this:</p>
<pre><code><span>char</span> <span>*</span>largest <span>=</span> <span>find_largest</span><span>(</span><span>&#34;input.txt&#34;</span><span>)</span><span>;</span></code></pre>
<p>The experienced C programmer will immediately note that this
code has a serious bug, because we are trying to use the
memory pointed to <code>largest</code> after we have <code>free()</code>d it.
When the calling function tries to use <code>largest</code>, there are
<a href="https://en.cppreference.com/w/c/language/behavior"><strong>no guarantees at all</strong> about what will happen.</a>
This is called a <em>use after free (UAF)</em>
bug. For example,
the allocator might have reallocated the memory in response
to some other call to <code>malloc()</code>, in which case it is now
full of some other data.  Of course, it&#39;s also quite likely
that the region is still unused and has the same contents
as before; it&#39;s just that the allocator added it to the list
of holes. In this case, the program may work fine under
test but then fail unpredictably later when some change
to your code causes allocations to happen differently and
suddenly <code>largest</code> points to some memory reason being used
for something else.</p>
<p>The reason this is all possible is that in C pointers are
just values that hold the memory address; effectively they&#39;re
just numbers and they behave like numbers. So if you assign
a pointer value to another variable, now you have two variables
that point to the same thing (i.e., they have the same value).
When we call free on the first copy of the variable, that
doesn&#39;t have any effect at all on the other copy (or on the
first one, for that matter). It just changes the state of
the memory region addressed by the variable. Once you&#39;ve
called <code>free(x)</code> you&#39;re still left with whatever is in <code>x</code>,
and nothing in C stops you from using it; it&#39;s just illegal
to do so, and it&#39;s your job not to, or else.</p>
<h2 id="next-up%3A-c%2B%2B">Next up: C++ <a href="#next-up%3A-c%2B%2B">#</a></h2>
<p>As you have probably gathered by now, managing memory yourself is
a huge amount of work, which is one reason why C programs
have so many memory issues. In the next post in this series,
we&#39;ll be taking a look at C++, which has some features that
make things a bit better, at least some of the time.</p>



    </article>

    
      
  </div>
  
</div>

<!-- Cloudflare Web Analytics --><!-- End Cloudflare Web Analytics -->


          </main>
        </div></div>
  </body>
</html>
