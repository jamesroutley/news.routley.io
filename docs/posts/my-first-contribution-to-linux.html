<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://vkoskiv.com/first-linux-patch/">Original</a>
    <h1>My first contribution to Linux</h1>
    
    <div id="readability-page-1" class="page"><article itemprop="articleBody">
        
            <p>I&#39;ve been spending more of my spare time in recent years studying the Linux source tree to try to build a deeper understanding of how computers work. As a result, I&#39;ve started accumulating patches that fix issues with hardware I own. I decided to try upstreaming one of these patches to familiarize myself with the kernel development process.</p>

            
              <details>
  <summary>Table of Contents</summary>
  <ul>
    
    <li>
      <a href="https://vkoskiv.com/first-linux-patch/#context">Context</a>
      
    </li>
    
    <li>
      <a href="https://vkoskiv.com/first-linux-patch/#how-do-the-keys-work">How do the keys work?</a>
      
    </li>
    
    <li>
      <a href="https://vkoskiv.com/first-linux-patch/#finding-the-correct-driver">Finding the correct driver</a>
      
    </li>
    
    <li>
      <a href="https://vkoskiv.com/first-linux-patch/#studying-fujitsu-laptop-driver">Studying fujitsu-laptop driver</a>
      
    </li>
    
    <li>
      <a href="https://vkoskiv.com/first-linux-patch/#modifying-the-driver">Modifying the driver</a>
      
    </li>
    
    <li>
      <a href="https://vkoskiv.com/first-linux-patch/#testing-my-changes">Testing my changes</a>
      
    </li>
    
    <li>
      <a href="https://vkoskiv.com/first-linux-patch/#upstreaming">Upstreaming</a>
      
    </li>
    
    <li>
      <a href="https://vkoskiv.com/first-linux-patch/#project-timeline">Project Timeline</a>
      
    </li>
    
    <li>
      <a href="https://vkoskiv.com/first-linux-patch/#conclusion">Conclusion</a>
      
    </li>
    
  </ul>
</details>

            

            <!-- Render the rest of the content after removing the summary portion -->
            
<span id="continue-reading"></span><h2 id="context"><a href="#context" aria-label="Anchor link for: context">Context</a></h2>
<p>I have an old laptop I&#39;m particularly fond of: a 2005 Fujitsu Lifebook S2110. It&#39;s probably the oldest computer I have that could still be considered &#34;modern&#34;, primarily because of its <a href="https://theretroweb.com/chips/2255">64-bit CPU</a>.</p>

    




<figure>
    <a href="https://vkoskiv.com/processed_images/2008_1.92b46b61b2dfd4bd.jpg"><img src="https://vkoskiv.com/processed_images/2008_1.1d256077bc2c6fbb.jpg" alt="A poorly framed picture of a black laptop computer on a wooden desk. The laptop is running Windows XP, with the Luna theme and a very cool dark lightning XP themed wallpaper. A pair of speakers sit beside the laptop, and some clutter can be seen on the desk."/></a>
    <figcaption><i>The laptop pictured in December 2008. I was 12 :]</i></figcaption>
</figure>
<p>Despite being 20 years old now, it still happily runs the latest <a href="https://archlinux.org/">Arch</a> rolling release with only 2GB of RAM and a spinning hard disk. Once the page cache warms up a bit, it&#39;s plenty fast enough for light C programming. The keyboard is <em>very</em> comfortable, and I really like how crisp bitmap fonts look on the glossy 1024x768 display.</p>
<p>Like many laptops from this era, it has a row of hotkeys above its keyboard that perform various functions:

    




</p><figure>
    <a href="https://vkoskiv.com/processed_images/mediakeys.bd6b5bba60467641.jpg"><img src="https://vkoskiv.com/processed_images/mediakeys.f9a476020ce576d2.jpg" alt="Close-up image of a row of 5 round buttons and the power button above the keyboard. The 5 keys all have labels above and below. The top labels from left to right are &#39;A&#39;, &#39;B&#39;, &#39;Internet&#39;, &#39;E-mail&#39; and &#39;Application&#39;. The bottom labels have icons for stop/eject, play/pause, rewind, fast-forward and &#39;Player&#39;. The rightmost key toggles between &#39;Application&#39; and &#39;Player&#39; modes, with a green LED to indicate which is selected. The power button has a bright blue LED behind it."/></a>
    <figcaption><i>The keys are very 2005 :]</i></figcaption>
</figure>

<p>That key on the right labelled <code>Application</code> and <code>Player</code> is a hardware toggle that selects between the two &#34;modes&#34;. Pushing it toggles which of the two labels is lit.</p>
<p>To be honest, I&#39;ve never really used these keys myself, but, continuing my kernel deep dive, I wanted to see how special keys like this are handled in Linux.</p>
<h2 id="how-do-the-keys-work"><a href="#how-do-the-keys-work" aria-label="Anchor link for: how-do-the-keys-work">How do the keys work?</a></h2>
<p>First of all, do these keys even work to begin with? Pressing them under <a href="https://i3wm.org/"><code>i3(1)</code></a> doesn&#39;t seem to do anything in either mode. Perhaps the events are being generated, but aren&#39;t bound to anything by default? I looked up how to show raw input events  on <a href="https://en.wikipedia.org/wiki/X_Window_System"><code>X11</code></a>, and it seems like <code>xev(1)</code> is the right tool for the job. With it running, a press of the leftmost <code>A</code> hotkey yields:</p>
<pre><code><span>KeyPress event, serial 47, synthetic NO, window 0xc00001,
</span><span>    root 0x18b, subw 0x0, time 5481538, (287,414), root:(803,434),
</span><span>    state 0x0, keycode 156 (keysym 0x1008ff41, XF86Launch1), same_screen YES,
</span><span>    XLookupString gives 0 bytes: 
</span><span>    XmbLookupString gives 0 bytes: 
</span><span>    XFilterEvent returns: False
</span><span>
</span><span>KeyRelease event, serial 47, synthetic NO, window 0xc00001,
</span><span>    root 0x18b, subw 0x0, time 5481642, (287,414), root:(803,434),
</span><span>    state 0x0, keycode 156 (keysym 0x1008ff41, XF86Launch1), same_screen YES,
</span><span>    XLookupString gives 0 bytes: 
</span><span>    XFilterEvent returns: False
</span></code></pre>
<p>Similar <code>KeyPress</code> and <code>KeyRelease</code> events are fired for all the keys in <code>Application</code> mode, mapped like this:</p>
<ul>
<li><code>A</code>: <code>XF86Launch1</code></li>
<li><code>B</code>: <code>XF86Launch2</code></li>
<li><code>Internet</code>: <code>XF86Launch3</code></li>
<li><code>E-mail</code>: <code>XF86Launch4</code></li>
</ul>
<p>I can then bind these key events to arbitrary commands in my <code>i3(1)</code> config:</p>
<pre><code><span>bindsym XF86Launch3 exec --no-startup-id firefox
</span><span>bindsym XF86Launch1 exec i3-sensible-terminal
</span></code></pre>
<p>After reloading the config, pushing <code>A</code> now fires up a terminal, and the <code>Internet</code> key now opens up Firefox. Neat.</p>
<p>However, if I switch to <code>Player</code> mode, no events are fired for any of the keys. That doesn&#39;t seem right. A further clue that something isn&#39;t working properly can be seen in the kernel log:</p>
<pre><code><span>Mar 25 19:59:02 s2110 kernel: ACPI: \_SB_.FEXT: Unknown GIRB result [40000414]
</span><span>Mar 25 19:59:04 s2110 kernel: ACPI: \_SB_.FEXT: Unknown GIRB result [40000415]
</span><span>Mar 25 19:59:06 s2110 kernel: ACPI: \_SB_.FEXT: Unknown GIRB result [40000416]
</span><span>Mar 25 19:59:07 s2110 kernel: ACPI: \_SB_.FEXT: Unknown GIRB result [40000417]
</span></code></pre>
<p>A line like this appears any time I push one of the keys while in <code>Player</code> mode, which suggests that this may be a driver problem.</p>
<h2 id="finding-the-correct-driver"><a href="#finding-the-correct-driver" aria-label="Anchor link for: finding-the-correct-driver">Finding the correct driver</a></h2>
<p>To figure out out what&#39;s going on here, I first need to find which driver is handling these key events, and get at least a rough idea of how it does that. This first step of finding the right spot in the <em>massive</em> kernel source tree can be a bit tricky. Luckily in this case, we have those messages in the kernel log. Grepping the source tree for error messages or other bits of text the kernel exposes is by far the <em>fastest</em> way to narrow down this search.</p>
<p>But first, let&#39;s check out a more broadly applicable method. Since <em>most</em> things in the kernel happen silently, there is a good chance we have no strings to go off of, and grepping educated guesses tends to yield a fairly poor signal/noise ratio in a massive codebase like this. Instead, we can instruct the running kernel to show us which drivers are currently in use, and we might be able to deduce which one we need to look at based on the name. Most driver code on Linux lives in <strong>kernel modules</strong> that are loaded on-demand from disk when a device is plugged in. We can list the modules that are currently loaded on a system with <code>lsmod(8)</code>:</p>
<pre data-lang="txt"><code data-lang="txt"><span>$ lsmod
</span><span>Module                  Size  Used by
</span><span>8021q                  53248  0
</span><span>... SNIP ...
</span><span>i2c_smbus              20480  1 i2c_piix4
</span><mark><span>fujitsu_laptop         32768  0
</span></mark><mark><span>sparse_keymap          12288  1 fujitsu_laptop
</span></mark><span>mac_hid                12288  0
</span><span>... SNIP ...
</span><span>mmc_core              290816  5 sdhci_uhs2,sdhci,ssb,cqhci,sdhci_pci
</span><mark><span>video                  81920  3 fujitsu_laptop,amdgpu,radeon
</span></mark></code></pre>
<p>Some of these module names are less obvious, but I&#39;d bet we&#39;ll find the code for these hotkeys in that <code>fujitsu_laptop</code> module. In this case, we can easily check if it&#39;s the right place by just grepping for that error message from before. Moving to a kernel source checkout I prepared earlier:</p>
<pre data-lang="txt"><code data-lang="txt"><span>$ cd linux
</span><span>$ rg &#39;Unknown GIRB result&#39;
</span><span>drivers/platform/x86/fujitsu-laptop.c
</span><span>1036:					 &#34;Unknown GIRB result [%x]\n&#34;, irb);
</span></code></pre>
<p>Okay, that&#39;s good confirmation that this is indeed the driver we need to look at.</p>
<h2 id="studying-fujitsu-laptop-driver"><a href="#studying-fujitsu-laptop-driver" aria-label="Anchor link for: studying-fujitsu-laptop-driver">Studying <code>fujitsu-laptop</code> driver</a></h2>
<p>This <code>fujitsu-laptop.c</code> file has ~1k lines of C, and it handles many other things in addition to these hotkeys, so it&#39;s important we stay on this &#39;golden path&#39; as we explore. I&#39;ll omit most unrelated code in this next part, but you can find the code I&#39;m referencing <a href="https://github.com/torvalds/linux/blob/eccf6f2f6ab9688b0fc113aeb8391998c11b5d49/drivers/platform/x86/fujitsu-laptop.c">here</a>, if you want to follow along.</p>
<p>I&#39;ve found that a good place to start studying driver code is often the module initialization boilerplate, which is usually at the very end of the file:</p>
<pre data-lang="C"><code data-lang="C"><span>static int</span><span> __init </span><span>fujitsu_init</span><span>(</span><span>void</span><span>)
</span><span>{
</span><span>	</span><span>int</span><span> ret;
</span><span>
</span><span>	ret </span><span>= </span><span>acpi_bus_register_driver</span><span>(</span><span>&amp;</span><span>acpi_fujitsu_bl_driver);
</span><span>	</span><span>if </span><span>(ret)
</span><span>		</span><span>return</span><span> ret;
</span><span>
</span><span>	</span><span>/* Register platform stuff */
</span><span>
</span><span>	ret </span><span>= </span><span>platform_driver_register</span><span>(</span><span>&amp;</span><span>fujitsu_pf_driver);
</span><span>	</span><span>if </span><span>(ret)
</span><span>		</span><span>goto</span><span> err_unregister_acpi;
</span><span>
</span><span>	</span><span>/* Register laptop driver */
</span><span>
</span><span>	ret </span><span>= </span><span>acpi_bus_register_driver</span><span>(</span><span>&amp;</span><span>acpi_fujitsu_laptop_driver);
</span><span>	</span><span>if </span><span>(ret)
</span><span>		</span><span>goto</span><span> err_unregister_platform_driver;
</span><span>
</span><span>	</span><span>pr_info</span><span>(</span><span>&#34;driver &#34;</span><span> FUJITSU_DRIVER_VERSION </span><span>&#34; successfully loaded</span><span>\n</span><span>&#34;</span><span>);
</span><span>
</span><span>	</span><span>return </span><span>0</span><span>;
</span><span>
</span><span>err_unregister_platform_driver:
</span><span>	</span><span>platform_driver_unregister</span><span>(</span><span>&amp;</span><span>fujitsu_pf_driver);
</span><span>err_unregister_acpi:
</span><span>	</span><span>acpi_bus_unregister_driver</span><span>(</span><span>&amp;</span><span>acpi_fujitsu_bl_driver);
</span><span>
</span><span>	</span><span>return</span><span> ret;
</span><span>}
</span><span>
</span><span>static void</span><span> __exit </span><span>fujitsu_cleanup</span><span>(</span><span>void</span><span>)
</span><span>{
</span><span>	</span><span>acpi_bus_unregister_driver</span><span>(</span><span>&amp;</span><span>acpi_fujitsu_laptop_driver);
</span><span>
</span><span>	</span><span>platform_driver_unregister</span><span>(</span><span>&amp;</span><span>fujitsu_pf_driver);
</span><span>
</span><span>	</span><span>acpi_bus_unregister_driver</span><span>(</span><span>&amp;</span><span>acpi_fujitsu_bl_driver);
</span><span>
</span><span>	</span><span>pr_info</span><span>(</span><span>&#34;driver unloaded</span><span>\n</span><span>&#34;</span><span>);
</span><span>}
</span><span>
</span><span>module_init</span><span>(fujitsu_init);
</span><span>module_exit</span><span>(fujitsu_cleanup);
</span></code></pre>
<p>That <code>module_init()</code> macro at the very end tells the kernel to call that <code>fujitsu_init()</code> function when this module is loaded. <code>fujitsu_init()</code> registers the different portions of this driver by calling the appropriate subsystem registration functions, and passing the address of a <code>static</code> struct, usually defined somewhere nearby. In this case, it registers:</p>
<ul>
<li><strong>acpi_fujitsu_bl_driver</strong>, which seems to handle backlight control</li>
<li><strong>fujitsu_pf_driver</strong>, which seems to be some kind of &#34;pseudo&#34;-driver that associates the different parts of this driver somehow, I&#39;m not entirely sure.</li>
<li><strong>acpi_fujitsu_laptop_driver</strong>, which seems like the part we&#39;re interested in today.</li>
</ul>
<p>I&#39;m not sure why the backlight driver is registered separately like this, but let&#39;s focus on <code>acpi_fujitsu_laptop_driver</code> for now. Here is the definition:</p>
<pre data-lang="C"><code data-lang="C"><span>static struct</span><span> acpi_driver acpi_fujitsu_laptop_driver </span><span>= </span><span>{
</span><span>	.</span><span>name </span><span>=</span><span> ACPI_FUJITSU_LAPTOP_DRIVER_NAME,
</span><span>	.</span><span>class </span><span>=</span><span> ACPI_FUJITSU_CLASS,
</span><span>	.</span><span>ids </span><span>=</span><span> fujitsu_laptop_device_ids,
</span><span>	.</span><span>ops </span><span>= </span><span>{
</span><span>		.</span><span>add </span><span>=</span><span> acpi_fujitsu_laptop_add,
</span><span>		.</span><span>remove </span><span>=</span><span> acpi_fujitsu_laptop_remove,
</span><span>		.</span><span>notify </span><span>=</span><span> acpi_fujitsu_laptop_notify,
</span><span>		},
</span><span>};
</span></code></pre>
<p>This uses the delightful <a href="https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html"><em>C99 designated initializers</em></a>. Struct fields are initialized with <code>.&lt;fieldname&gt; = &lt;value&gt;</code>, and any field we don&#39;t touch is zero-initialized for us. Here, it sets set some metadata, then provides a table <code>ids</code> of known device IDs this driver supports, and finally, specifies functions the kernel&#39;s <a href="https://en.wikipedia.org/wiki/ACPI">ACPI</a> subsystem will call for us when this device is added, removed, or receives some kind of notification.</p>
<p>Presumably the probing and setup for the hotkeys would happen when the device is added, so we&#39;ll take a look at <code>acpi_fujitsu_laptop_add</code> first:</p>
<pre data-lang="C"><code data-lang="C"><span>static int </span><span>acpi_fujitsu_laptop_add</span><span>(</span><span>struct</span><span> acpi_device </span><span>*</span><span>device</span><span>)
</span><span>{
</span><span>	</span><span>struct</span><span> fujitsu_laptop </span><span>*</span><span>priv;
</span><span>	</span><span>int</span><span> ret, i </span><span>= </span><span>0</span><span>;
</span><span>
</span><span>	priv </span><span>= </span><span>devm_kzalloc</span><span>(</span><span>&amp;</span><span>device-&gt;dev, </span><span>sizeof</span><span>(</span><span>*</span><span>priv), GFP_KERNEL);
</span><span>	</span><span>if </span><span>(</span><span>!</span><span>priv)
</span><span>		</span><span>return </span><span>-</span><span>ENOMEM;
</span><span>	</span><span>...</span><span> SNIP </span><span>...
</span><span>	device-&gt;driver_data </span><span>=</span><span> priv;
</span></code></pre>
<p>It first allocates a <code>struct fujitsu_laptop</code> that will contain our driver-specific state, and associates it with that generic <code>device</code> struct from the ACPI subsystem. Later calls to this driver from the ACPI subsystem will also provide that same struct, which lets this driver access its state via that <code>device-&gt;driver_data</code> pointer.</p>
<p>Then a bit further down, it starts to get interesting:</p>
<pre data-lang="C"><code data-lang="C"><span>while </span><span>(</span><span>call_fext_func</span><span>(device, FUNC_BUTTONS, </span><span>0x1</span><span>, </span><span>0x0</span><span>, </span><span>0x0</span><span>) </span><span>!= </span><span>0 </span><span>&amp;&amp;
</span><span>       i</span><span>++ &lt;</span><span> MAX_HOTKEY_RINGBUFFER_SIZE)
</span><span>	; </span><span>/* No action, result is discarded */
</span><span>acpi_handle_debug</span><span>(device-&gt;handle, </span><span>&#34;Discarded </span><span>%i</span><span> ringbuffer entries</span><span>\n</span><span>&#34;</span><span>,
</span><span>		  i);
</span></code></pre>
<p>This loop flushes the firmware key event ringbuffer until it&#39;s empty to ensure that the firmware internal state matches what this driver expects.
We also see the first call to <code>call_fext_func()</code>, which is a wrapper function around some kernel ACPI calls that interact with the system firmware.</p>
<blockquote>
<p>I won&#39;t explain ACPI in detail here, but I did end up falling down yet another rabbit hole learning about it while I was working on this. TL;DR: The hardware vendor provides <a href="https://en.wikipedia.org/wiki/ACPI">system firmware</a> that contains <a href="https://wiki.osdev.org/AML">architecture-agnostic bytecode</a> that knows how to talk to hardware. The kernel contains a <a href="https://github.com/acpica/acpica">virtual machine</a> that executes this bytecode. <code>call_fext_func()</code> lets this driver call different functions in this firmware code to interact with hardware.</p>
</blockquote>
<p>At the end of <code>acpi_fujitsu_laptop_add()</code>, we see calls to various setup functions to finish setting things up:</p>
<pre data-lang="C"><code data-lang="C"><mark><span>ret </span><span>= </span><span>acpi_fujitsu_laptop_input_setup</span><span>(device);
</span></mark><span>if </span><span>(ret)
</span><span>	</span><span>goto</span><span> err_free_fifo;
</span><span>
</span><span>ret </span><span>= </span><span>acpi_fujitsu_laptop_leds_register</span><span>(device);
</span><span>if </span><span>(ret)
</span><span>	</span><span>goto</span><span> err_free_fifo;
</span><span>
</span><span>ret </span><span>= </span><span>fujitsu_laptop_platform_add</span><span>(device);
</span><span>...</span><span> SNIP </span><span>...
</span></code></pre>
<p>That input setup function looks interesting:</p>
<pre data-lang="C"><code data-lang="C"><span>static int </span><span>acpi_fujitsu_laptop_input_setup</span><span>(</span><span>struct</span><span> acpi_device </span><span>*</span><span>device</span><span>)
</span><span>{
</span><span>	</span><span>struct</span><span> fujitsu_laptop </span><span>*</span><span>priv </span><span>= </span><span>acpi_driver_data</span><span>(device);
</span><span>	</span><span>int</span><span> ret;
</span><span>
</span><span>	priv-&gt;input </span><span>= </span><span>devm_input_allocate_device</span><span>(</span><span>&amp;</span><span>device-&gt;dev);
</span><span>	</span><span>if </span><span>(</span><span>!</span><span>priv-&gt;input)
</span><span>		</span><span>return </span><span>-</span><span>ENOMEM;
</span><span>
</span><span>	</span><span>snprintf</span><span>(priv-&gt;phys, </span><span>sizeof</span><span>(priv-&gt;phys), </span><span>&#34;</span><span>%s</span><span>/input0&#34;</span><span>,
</span><span>		 </span><span>acpi_device_hid</span><span>(device));
</span><span>
</span><span>	priv-&gt;input-&gt;name </span><span>= </span><span>acpi_device_name</span><span>(device);
</span><span>	priv-&gt;input-&gt;phys </span><span>=</span><span> priv-&gt;phys;
</span><span>	priv-&gt;input-&gt;id.</span><span>bustype </span><span>=</span><span> BUS_HOST;
</span></code></pre>
<p><code>acpi_driver_data()</code> gives us back that <code>device-&gt;driver_data</code> pointer that was set earlier, meaning <code>priv</code> now lets us access the driver state in the <code>fujitsu_laptop</code> struct. It then allocates an input device to <code>priv-&gt;input</code> and performs some initial setup on it.</p>
<p>Next, it checks this <code>fujitsu_laptop_dmi_table</code>, then passes a <code>keymap</code> to another setup function to associate it with <code>priv-&gt;input</code>, and finally registers this input device:</p>
<pre data-lang="C"><code data-lang="C"><span>dmi_check_system</span><span>(fujitsu_laptop_dmi_table);
</span><span>ret </span><span>= </span><span>sparse_keymap_setup</span><span>(priv-&gt;input, keymap, </span><span>NULL</span><span>);
</span><span>if </span><span>(ret)
</span><span>	</span><span>return</span><span> ret;
</span><span>
</span><span>return </span><span>input_register_device</span><span>(priv-&gt;input);
</span></code></pre>
<p>But what is <code>keymap</code> and where does it come from? It&#39;s defined like this a bit higher up in the file:</p>
<pre data-lang="C"><code data-lang="C"><span>static const struct</span><span> key_entry </span><span>*</span><span>keymap </span><span>=</span><span> keymap_default;
</span></code></pre>
<p>So <code>keymap</code> a global variable (marked <code>static</code>, so only global within this .c file), and it&#39;s initialized to point to <code>keymap_default</code>.
That call to <code>dmi_check_system()</code> iterates over this array:</p>
<pre data-lang="C"><code data-lang="C"><span>static const struct</span><span> dmi_system_id fujitsu_laptop_dmi_table[] </span><span>= </span><span>{
</span><span>	{
</span><span>		.</span><span>callback </span><span>=</span><span> fujitsu_laptop_dmi_keymap_override,
</span><span>		.</span><span>ident </span><span>= </span><span>&#34;Fujitsu Siemens S6410&#34;</span><span>,
</span><span>		.</span><span>matches </span><span>= </span><span>{
</span><span>			</span><span>DMI_MATCH</span><span>(DMI_SYS_VENDOR, </span><span>&#34;FUJITSU SIEMENS&#34;</span><span>),
</span><span>			</span><span>DMI_MATCH</span><span>(DMI_PRODUCT_NAME, </span><span>&#34;LIFEBOOK S6410&#34;</span><span>),
</span><span>		},
</span><span>		.</span><span>driver_data </span><span>= </span><span>(</span><span>void </span><span>*</span><span>)keymap_s64x0
</span><span>	},
</span><span>	{
</span><span>		.</span><span>callback </span><span>=</span><span> fujitsu_laptop_dmi_keymap_override,
</span><span>		.</span><span>ident </span><span>= </span><span>&#34;Fujitsu Siemens S6420&#34;</span><span>,
</span><span>		.</span><span>matches </span><span>= </span><span>{
</span><span>			</span><span>DMI_MATCH</span><span>(DMI_SYS_VENDOR, </span><span>&#34;FUJITSU SIEMENS&#34;</span><span>),
</span><span>			</span><span>DMI_MATCH</span><span>(DMI_PRODUCT_NAME, </span><span>&#34;LIFEBOOK S6420&#34;</span><span>),
</span><span>		},
</span><span>		.</span><span>driver_data </span><span>= </span><span>(</span><span>void </span><span>*</span><span>)keymap_s64x0
</span><span>	},
</span><span>	{
</span><span>		.</span><span>callback </span><span>=</span><span> fujitsu_laptop_dmi_keymap_override,
</span><span>		.</span><span>ident </span><span>= </span><span>&#34;Fujitsu LifeBook P8010&#34;</span><span>,
</span><span>		.</span><span>matches </span><span>= </span><span>{
</span><span>			</span><span>DMI_MATCH</span><span>(DMI_SYS_VENDOR, </span><span>&#34;FUJITSU&#34;</span><span>),
</span><span>			</span><span>DMI_MATCH</span><span>(DMI_PRODUCT_NAME, </span><span>&#34;LifeBook P8010&#34;</span><span>),
</span><span>		},
</span><span>		.</span><span>driver_data </span><span>= </span><span>(</span><span>void </span><span>*</span><span>)keymap_p8010
</span><span>	},
</span><span>	{}
</span><span>};
</span></code></pre>
<p>For each item in this array, it checks to see if the vendor and product names match what the firmware reports, and if so, calls the corresponding <code>callback</code> function. It passes that <code>driver_data</code> value to the callback via a <code>dmi_system_id</code> struct.</p>
<p>The callback in this driver is very simple:</p>
<pre data-lang="C"><code data-lang="C"><span>static int </span><span>fujitsu_laptop_dmi_keymap_override</span><span>(</span><span>const struct</span><span> dmi_system_id </span><span>*</span><span>id</span><span>)
</span><span>{
</span><span>	</span><span>pr_info</span><span>(</span><span>&#34;Identified laptop model &#39;</span><span>%s</span><span>&#39;</span><span>\n</span><span>&#34;</span><span>, id-&gt;ident);
</span><span>	keymap </span><span>=</span><span> id-&gt;driver_data;
</span><span>	</span><span>return </span><span>1</span><span>;
</span><span>}
</span></code></pre>
<p>It prints the laptop model to the kernel log, and updates that <code>keymap</code> global to point to a model-specific keymap specified in the dmi table.</p>
<p>In other words, it&#39;s looking for a hardware-specific keymap to use, and if one wasn&#39;t found, it falls back on <code>keymap_default</code>. Checking the kernel logs on my machine, I don&#39;t see that <code>Identified laptop model</code> message, which makes sense, since I don&#39;t see the Lifebook S2110 listed in this dmi table.</p>
<p>That covers the setup for the hotkey portion of this driver, but how are the actual key press events from the hardware handled? This is where that <code>notify</code> callback in the <code>acpi_driver</code> struct comes in. This driver sets it to <code>acpi_fujitsu_laptop_notify()</code>:</p>
<pre data-lang="C"><code data-lang="C"><span>static void </span><span>acpi_fujitsu_laptop_notify</span><span>(</span><span>struct</span><span> acpi_device </span><span>*</span><span>device</span><span>, u32 </span><span>event</span><span>)
</span><span>{
</span><span>	</span><span>struct</span><span> fujitsu_laptop </span><span>*</span><span>priv </span><span>= </span><span>acpi_driver_data</span><span>(device);
</span><span>	</span><span>unsigned long</span><span> flags;
</span><span>	</span><span>int</span><span> scancode, i </span><span>= </span><span>0</span><span>;
</span><span>	</span><span>unsigned int</span><span> irb;
</span><span>	</span><span>...</span><span> SNIP </span><span>...
</span><span>	</span><span>while </span><span>((irb </span><span>= </span><span>call_fext_func</span><span>(device,
</span><span>				     FUNC_BUTTONS, </span><span>0x1</span><span>, </span><span>0x0</span><span>, </span><span>0x0</span><span>)) </span><span>!= </span><span>0 </span><span>&amp;&amp;
</span><span>	       i</span><span>++ &lt;</span><span> MAX_HOTKEY_RINGBUFFER_SIZE) {
</span><span>		scancode </span><span>=</span><span> irb </span><span>&amp; </span><span>0x4ff</span><span>;
</span><span>		</span><span>if </span><span>(</span><span>sparse_keymap_entry_from_scancode</span><span>(priv-&gt;input, scancode))
</span><span>			</span><span>acpi_fujitsu_laptop_press</span><span>(device, scancode);
</span><span>		</span><span>else if </span><span>(scancode </span><span>== </span><span>0</span><span>)
</span><span>			</span><span>acpi_fujitsu_laptop_release</span><span>(device);
</span><span>		</span><span>else
</span><span>			</span><span>acpi_handle_info</span><span>(device-&gt;handle,
</span><span>					 </span><span>&#34;Unknown GIRB result [</span><span>%x</span><span>]</span><span>\n</span><span>&#34;</span><span>, irb);
</span><span>	}
</span><span>	</span><span>...</span><span> SNIP </span><span>...
</span><span>}
</span></code></pre>
<p>When the system firmware generates an event, such as a key press, it notifies the Linux ACPI subsystem, and that subsystem then calls this notify function for us. In here we see a loop similar to the one we saw earlier to flush the firmware ringbuffer, but rather than discarding the return value, it stores it in <code>irb</code>, and masks off some bits to get a <code>scancode</code>.</p>
<p>Next, it checks to see if <code>scancode</code> exists in the currently active keymap, and if it does, it sends a keypress event to the Linux input subsystem via <code>acpi_fujitsu_laptop_press()</code>. Same deal with key release, which the firmware seems to indicate with scancode 0.</p>
<p>There is a lot more to explore here, but I think I now have a rough idea of how this part of the driver works. To recap:</p>
<ol>
<li>The driver initializes itself in various subsystems</li>
<li>An input device is created</li>
<li>An appropriate keymap is selected based on a list of known hardware, with <code>keymap_default</code> as a fallback if a more specific keymap wasn&#39;t found.</li>
<li>That keymap is associated with the input device</li>
<li>The notify callback passes key events to the Linux input subsystem, and prints a message to the kernel log for unknown keycodes.</li>
</ol>
<h2 id="modifying-the-driver"><a href="#modifying-the-driver" aria-label="Anchor link for: modifying-the-driver">Modifying the driver</a></h2>
<p>So to add support for the media keys on my laptop, I probably need to define a new keymap. The keymaps are defined like this:</p>
<pre data-lang="C"><code data-lang="C"><span>static const struct</span><span> key_entry keymap_default[] </span><span>= </span><span>{
</span><span>	{ KE_KEY, KEY1_CODE,            { KEY_PROG1 } },
</span><span>	{ KE_KEY, KEY2_CODE,            { KEY_PROG2 } },
</span><span>	{ KE_KEY, KEY3_CODE,            { KEY_PROG3 } },
</span><span>	{ KE_KEY, KEY4_CODE,            { KEY_PROG4 } },
</span><span>	{ KE_KEY, KEY5_CODE,            { KEY_RFKILL } },
</span><span>	</span><span>/* Soft keys read from status flags */
</span><span>	{ KE_KEY, FLAG_RFKILL,          { KEY_RFKILL } },
</span><span>	{ KE_KEY, FLAG_TOUCHPAD_TOGGLE, { KEY_TOUCHPAD_TOGGLE } },
</span><span>	{ KE_KEY, FLAG_MICMUTE,         { KEY_MICMUTE } },
</span><span>	{ KE_END, </span><span>0 </span><span>}
</span><span>};
</span><span>
</span><span>static const struct</span><span> key_entry keymap_s64x0[] </span><span>= </span><span>{
</span><span>	{ KE_KEY, KEY1_CODE, { KEY_SCREENLOCK } },	</span><span>/* &#34;Lock&#34; */
</span><span>	{ KE_KEY, KEY2_CODE, { KEY_HELP } },		</span><span>/* &#34;Mobility Center */
</span><span>	{ KE_KEY, KEY3_CODE, { KEY_PROG3 } },
</span><span>	{ KE_KEY, KEY4_CODE, { KEY_PROG4 } },
</span><span>	{ KE_END, </span><span>0 </span><span>}
</span><span>};
</span></code></pre>
<p>Okay, the default keymap looks reasonable. It seems like other laptop models have keys for toggling radios, the touchpad and mic. I don&#39;t think my laptop has those, so I&#39;ll base my keymap on this <code>s64x0</code> table.
For each entry in these tables, the first value is the entry type, e.g. <code>KE_KEY</code> for a key, and <code>KE_END</code> to mark the end of an array. The next value is the raw scancode we receive from the firmware, and the last value is the corresponding keycode that gets passed to the Linux input subsystem.</p>
<p>These <code>KEY*_CODE</code> macros for the firmware scancodes are defined near the top of the file:</p>
<pre data-lang="C"><code data-lang="C"><span>/* Scancodes read from the GIRB register */
</span><span>#define </span><span>KEY1_CODE			</span><span>0x410
</span><span>#define </span><span>KEY2_CODE			</span><span>0x411
</span><span>#define </span><span>KEY3_CODE			</span><span>0x412
</span><span>#define </span><span>KEY4_CODE			</span><span>0x413
</span><span>#define </span><span>KEY5_CODE			</span><span>0x420
</span></code></pre>
<p>The macros for the linux keycodes such as <code>KEY_PROG1</code> and <code>KEY_RFKILL</code>, are defined in <a href="https://github.com/torvalds/linux/blob/eccf6f2f6ab9688b0fc113aeb8391998c11b5d49/include/uapi/linux/input-event-codes.h"><code>include/uapi/linux/input-event-codes.h</code></a></p>
<p>Looking at the values in those <code>Unknown GIRB result</code> messages in the kernel log when the keys are in <code>Player</code> mode, they correspond to codes <code>0x414</code>-<code>0x417</code>, which seems to check out. The codes just get shifted up by 4. I&#39;ll expand the set of defines to include these 4 new keys:</p>
<pre data-lang="diff"><code data-lang="diff"><span> #define KEY4_CODE          0x413
</span><span>-#define KEY5_CODE          0x420
</span><span>+#define KEY5_CODE          0x414
</span><span>+#define KEY6_CODE          0x415
</span><span>+#define KEY7_CODE          0x416
</span><span>+#define KEY8_CODE          0x417
</span><span>+#define KEY9_CODE          0x420
</span></code></pre>
<p>The existing value for <code>KEY5_CODE</code> is now <code>KEY9_CODE</code>, so I updated <code>keymap_default</code> to reflect that:</p>
<pre data-lang="diff"><code data-lang="diff"><span>@@ -560,7 +564,7 @@ </span><span>static const struct key_entry keymap_default[] = {
</span><span>    { KE_KEY, KEY2_CODE,            { KEY_PROG2 } },
</span><span>    { KE_KEY, KEY3_CODE,            { KEY_PROG3 } },
</span><span>    { KE_KEY, KEY4_CODE,            { KEY_PROG4 } },
</span><span>-   { KE_KEY, KEY5_CODE,            { KEY_RFKILL } },
</span><span>+   { KE_KEY, KEY9_CODE,            { KEY_RFKILL } },
</span><span>    /* Soft keys read from status flags */
</span></code></pre>
<p>With these updated defines, I put together this new keymap:</p>
<pre data-lang="C"><code data-lang="C"><span>static const struct</span><span> key_entry keymap_s2110[] </span><span>= </span><span>{
</span><span>	{ KE_KEY, KEY1_CODE, { KEY_PROG1 } }, </span><span>/* &#34;A&#34; */
</span><span>	{ KE_KEY, KEY2_CODE, { KEY_PROG2 } }, </span><span>/* &#34;B&#34; */
</span><span>	{ KE_KEY, KEY3_CODE, { KEY_WWW } },   </span><span>/* &#34;Internet&#34; */
</span><span>	{ KE_KEY, KEY4_CODE, { KEY_EMAIL } }, </span><span>/* &#34;E-mail&#34; */
</span><span>	{ KE_KEY, KEY5_CODE, { KEY_STOPCD } },
</span><span>	{ KE_KEY, KEY6_CODE, { KEY_PLAYPAUSE } },
</span><span>	{ KE_KEY, KEY7_CODE, { KEY_PREVIOUSSONG } },
</span><span>	{ KE_KEY, KEY8_CODE, { KEY_NEXTSONG } },
</span><span>	{ KE_END, </span><span>0 </span><span>}
</span><span>};
</span></code></pre>
<p>We already saw before that in <code>Application</code> mode, the key events showed up as <code>XF86Launch1</code>-<code>XF86Launch4</code> (corresponding to <code>KEY_PROG1</code>-<code>KEY_PROG4</code> in <code>keymap_default</code>), but since the last two keys on this laptop are labeled with their specific function, we can express that here with the more specific macros <code>KEY_WWW</code> and <code>KEY_EMAIL</code>.</p>
<p>The mapping between these Linux keycodes and the keycodes that show up in <code>xev(1)</code> output wasn&#39;t very obvious to me. There is some translation happening somewhere in userspace (libinput?), so I found it quicker to just experiment with different values to arrive at that final table.</p>
<p>Finally, I need to add a new entry to the DMI table so this new keymap is selected for this model of laptop:</p>
<pre data-lang="diff"><code data-lang="diff"><span>@@ -621,6 +637,15 @@ </span><span>static const struct dmi_system_id fujitsu_laptop_dmi_table[] = {
</span><span>        },
</span><span>        .driver_data = (void *)keymap_p8010
</span><span>    },
</span><span>+   {
</span><span>+       .callback = fujitsu_laptop_dmi_keymap_override,
</span><span>+       .ident = &#34;Fujitsu LifeBook S2110&#34;,
</span><span>+       .matches = {
</span><span>+           DMI_MATCH(DMI_SYS_VENDOR, &#34;FUJITSU SIEMENS&#34;),
</span><span>+           DMI_MATCH(DMI_PRODUCT_NAME, &#34;LIFEBOOK S2110&#34;),
</span><span>+       },
</span><span>+       .driver_data = (void *)keymap_s2110
</span><span>+   },
</span><span>    {}
</span><span> };
</span></code></pre>
<h2 id="testing-my-changes"><a href="#testing-my-changes" aria-label="Anchor link for: testing-my-changes">Testing my changes</a></h2>
<p>To test my changes, I ended up using the <a href="https://wiki.archlinux.org/title/Kernel/Arch_build_system">Arch build system</a>. So I&#39;d run <code>makepkg -e</code> to build a new kernel package with my modifications, which I could then install alongside the upstream Arch kernel. I didn&#39;t spend too much time refining this setup, so I ended up just manually patching the <code>src</code> directory that <code>makepkg</code> sets up. I&#39;m sure there is some way to point <code>PKGBUILD</code> at an existing local git repository to make this process a bit smoother.</p>
<p>With my patched kernel installed and running, I can now see the message from the keymap override callback appear on boot:</p>
<pre><code><span>[   68.921998] fujitsu_laptop: ACPI: Fujitsu FUJ02E3 [FEXT]
</span><span>[   68.923714] ACPI: \_SB_.FEXT: BTNI: [0xff0101]
</span><mark><span>[   68.923741] fujitsu_laptop: Identified laptop model &#39;Fujitsu LifeBook S2110&#39;
</span></mark></code></pre>
<p>And the keys now all work as expected! Check this out:</p>
<pre><code><span>&gt; xev -event keyboard | grep keysym
</span><span>    state 0x0, keycode 156 (keysym 0x1008ff41, XF86Launch1), same_screen YES,
</span><span>    state 0x0, keycode 157 (keysym 0x1008ff42, XF86Launch2), same_screen YES,
</span><span>    state 0x0, keycode 158 (keysym 0x1008ff2e, XF86WWW), same_screen YES,
</span><span>    state 0x0, keycode 223 (keysym 0x1008ff19, XF86Mail), same_screen YES,
</span><span>	(Switch to Player mode)
</span><span>    state 0x0, keycode 174 (keysym 0x1008ff15, XF86AudioStop), same_screen YES,
</span><span>    state 0x0, keycode 172 (keysym 0x1008ff14, XF86AudioPlay), same_screen YES,
</span><span>    state 0x0, keycode 173 (keysym 0x1008ff16, XF86AudioPrev), same_screen YES,
</span><span>    state 0x0, keycode 171 (keysym 0x1008ff17, XF86AudioNext), same_screen YES,
</span></code></pre>
<p>With the new key events working, I can expand my <code>i3(1)</code> config to match:</p>
<pre><code><span>bindsym XF86AudioStop exec --no-startup-id playerctl stop
</span><span>bindsym XF86AudioPlay exec --no-startup-id playerctl play-pause
</span><span>bindsym XF86AudioPrev exec --no-startup-id playerctl previous
</span><span>bindsym XF86AudioNext exec --no-startup-id playerctl next
</span><span>bindsym XF86WWW exec --no-startup-id firefox
</span><span>bindsym XF86Launch1 exec i3-sensible-terminal
</span></code></pre>
<p>I found that <code>playerctl(1)</code> utility while I was working on this. It uses <a href="https://wiki.archlinux.org/title/MPRIS">MPRIS</a> to control media players over <a href="https://wiki.archlinux.org/title/D-Bus">D-Bus</a>.</p>
<p>I even found a physical music CD to test with in VLC to get that fully authentic 2005 experience! 8]</p>
<h2 id="upstreaming"><a href="#upstreaming" aria-label="Anchor link for: upstreaming">Upstreaming</a></h2>
<p>So I&#39;ve now fixed the media keys on my laptop, so it&#39;s time to think about sending my improvements to kernel maintainers for inclusion in upstream Linux, so everyone else running the latest kernel on their S2110 can benefit.</p>
<p>I&#39;ll start by committing my changes locally:</p>
<pre><code><span>$ git checkout -b s2110-mediakeys
</span><span>$ git add drivers/platform/x86/fujitsu-laptop.c
</span><span>$ git commit
</span><span>$ git show --stat HEAD
</span><span>commit d0e1e0b3e2e6674cce73909d4092874c6c8c2d11 (HEAD -&gt; s2110-mediakeys)
</span><span>Author: Valtteri Koskivuori &lt;vkoskiv@gmail.com&gt;
</span><span>Date:   Fri May 9 17:54:50 2025 +0300
</span><span>
</span><span>    platform/x86: fujitsu-laptop: Support Lifebook S2110 hotkeys
</span><span>    
</span><span>    The S2110 has an additional set of media playback control keys enabled
</span><span>    by a hardware toggle button that switches the keys between &#34;Application&#34;
</span><span>    and &#34;Player&#34; modes. Toggling &#34;Player&#34; mode just shifts the scancode of
</span><span>    each hotkey up by 4.
</span><span>    
</span><span>    Add defines for new scancodes, and a keymap and dmi id for the S2110.
</span><span>    
</span><span>    Tested on a Fujitsu Lifebook S2110.
</span><span>    
</span><span>    Signed-off-by: Valtteri Koskivuori &lt;vkoskiv@gmail.com&gt;
</span><span>
</span><span> drivers/platform/x86/fujitsu-laptop.c | 33 +++++++++++++++++++++++++++++----
</span><span> 1 file changed, 29 insertions(+), 4 deletions(-)
</span></code></pre>
<p>Then I can run <a href="https://docs.kernel.org/dev-tools/checkpatch.html"><code>checkpatch.pl</code></a> against this commit. It should point out any obvious issues with my code or the commit message.</p>
<pre><code><span>$ scripts/checkpatch.pl -g HEAD
</span><span>total: 0 errors, 0 warnings, 68 lines checked
</span><span>
</span><span>Commit d0e1e0b3e2e6 (&#34;platform/x86: fujitsu-laptop: Support Lifebook S2110 hotkeys&#34;) has no obvious style problems and is ready for submission.
</span></code></pre>
<p>Looks good. Next, to get the list of recipients for my submission email, I can use <code>scripts/get_maintainer.pl</code>:</p>
<pre><code><span>$ scripts/get_maintainer.pl -f drivers/platform/x86/fujitsu-laptop.c 
</span><span>Jonathan Woithe &lt;*******@just42.net&gt; (maintainer:FUJITSU LAPTOP EXTRAS)
</span><span>Hans de Goede &lt;********@redhat.com&gt; (maintainer:X86 PLATFORM DRIVERS)
</span><span>&#34;Ilpo JÃ¤rvinen&#34; &lt;****.********@linux.intel.com&gt; (maintainer:X86 PLATFORM DRIVERS)
</span><span>platform-driver-x86@vger.kernel.org (open list:FUJITSU LAPTOP EXTRAS)
</span><span>linux-kernel@vger.kernel.org (open list)
</span></code></pre>
<p>I&#39;ve already configured my git email integration following <a href="https://git-send-email.io/">this guide</a> and tested that it works, so I can just use <code>git-send-email(1)</code> to fire off my patch.</p>
<p>To be extra sure that everything is working correctly, I&#39;ll first send the patch to myself:</p>
<pre><code><span>$ git send-email --to=&#34;vkoskiv@gmail.com&#34; HEAD^
</span></code></pre>
<p>Looks good on the receiving end, so I type the following:</p>
<pre><code><span>$ git send-email --to *******@just42.net --to ********@redhat.com --to ****.********@linux.intel.com --cc platform-driver-x86@vger.kernel.org --cc linux-kernel@vger.kernel.org HEAD^
</span></code></pre>
<p>I don&#39;t usually get nervous when sending email, but I was still worried I had missed some detail, and I <em>really</em> don&#39;t want to waste a kernel maintainer&#39;s time. I could soon refresh the mailing list archives and find <a href="https://lore.kernel.org/lkml/20250509184251.713003-1-vkoskiv@gmail.com/">my message</a>.</p>
<p>The maintainers didn&#39;t request any changes for this minor patch, so a bit over a month after sending this email, I ran <code>pacman -Syu</code> on the S2110, and I could see my changes had landed in the upstream Arch Linux kernel. That was a pretty cool moment! :]</p>
<h2 id="project-timeline"><a href="#project-timeline" aria-label="Anchor link for: project-timeline">Project Timeline</a></h2>
<ul>
<li><strong>2025-05-09</strong>: I send my patch: <a href="https://lore.kernel.org/lkml/20250509184251.713003-1-vkoskiv@gmail.com/">lore.kernel.org</a></li>
<li><strong>2025-05-11</strong>: The <code>fujitsu-laptop</code> driver maintainer <a href="https://docs.kernel.org/process/submitting-patches.html#when-to-use-acked-by-cc-and-co-developed-by">ACKs</a> my patch: <a href="https://lore.kernel.org/lkml/aCCTRWvlYKX%2FfObR@marvin.atrad.com.au/">lore.kernel.org</a></li>
<li><strong>2025-05-15</strong>: <code>platform-drivers-x86</code> maintainer applies my patch to their review branch: <a href="https://lore.kernel.org/lkml/174730959183.1777.1876414558560379948.b4-ty@linux.intel.com/">lore.kernel.org</a></li>
<li><strong>2025-05-23</strong>: <code>platform-drivers-x86</code> maintainer sends a PR to Linus for v6.15, <strong>my patch is included!</strong> <a href="https://lore.kernel.org/platform-driver-x86/174801369026.3634038.4067925322010414165.pr-tracker-bot@kernel.org/T/#t">lore.kernel.org</a></li>
<li><strong>2025-05-23</strong>: Linus merges that PR later that same day: <a href="https://lore.kernel.org/platform-driver-x86/174801369026.3634038.4067925322010414165.pr-tracker-bot@kernel.org/T/#madca0be47ba6b64d167b3ce54aa79c1eba733db9">lore.kernel.org</a></li>
<li><strong>2025-05-25</strong>: Linux 6.15 is announced by Linus. My name appears in the changelog! <a href="https://lore.kernel.org/all/CAHk-=wiLRW8DN8-4jmeCZH0OpO8skXOC5e6FwMfsPwGMpQYmVQ@mail.gmail.com/">lore.kernel.org</a></li>
<li><strong>2025-05-27</strong>: Sasha Levin <a href="https://lwn.net/Articles/1020203/">selects</a> my patch (and a few others) for backporting to all the currently maintained upstream LTS kernels 6.14, 6.12, 6.6, 6.1, 5.15, 5.10 and 5.4.</li>
<li><strong>2025-06-14</strong>: I upgrade Arch on my S2110, the keys now work with the upstream kernel! :]</li>
</ul>
<h2 id="conclusion"><a href="#conclusion" aria-label="Anchor link for: conclusion">Conclusion</a></h2>
<p>It was <em>really</em> cool to watch my patch make its way up the chain and have it end up in mainline! It was also nice to experience the traditional patch &amp; email workflow for the first time. The <a href="https://kernelnewbies.org/FirstKernelPatch#SubmitPatch">kernel newbies guide</a> was a good resource to ensure everything was in order before sending my first patch. The whole process was actually much easier than I had imagined it to be.</p>
<p>That being said, this was a very small change in a minor driver, so it went in without any rounds of feedback. I actually already have another set of patches I made earlier this year that resolve a minor issue with the network card in this laptop, but that set involves a minor change to core kernel code under <code>kernel/dma/</code>, so I want to be 100% certain my changes are justified before I seek feedback from kernel maintainers.</p>
<p>It was actually this process of finding existing precedent for justifying my choices that made me really appreciate the traditional mailing list based process. The kernel git log and mailing lists are full of really valuable context for changes dating back decades, so all my questions during this process were answered by either searching these archives or by browsing git logs.</p>
<p>Thank you for reading! I&#39;d really appreciate any feedback on my writing, so if you have any questions, corrections, suggestions or other thoughts, do <a href="mailto:vkoskiv@gmail.com">get in touch</a>! :]</p>
<p>My next post, <strong>&#34;Tracking down a regression in Mesa 3D&#34;</strong>, is due to be published within the next week (by <strong>October 12th, 2025</strong>).</p>
<hr/>
<p><em>This post was discussed on <a href="https://news.ycombinator.com/item?id=45490652">Hacker News</a> and <a href="https://lobste.rs/s/xlqurj/my_first_contribution_linux">lobste.rs</a>.</em></p>
<hr/>



        
    </article></div>
  </body>
</html>
