<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://two-wrongs.com/software-design-tree-and-program-families.html">Original</a>
    <h1>Common Mistakes in Modularisation</h1>
    
    <div id="readability-page-1" class="page"><div>
                <p>
This article<span><sup>1</sup> Alternate title: <i>The Software Design Tree and Program
Families</i>.</span> leads to two rather simple ideas.
</p>

<ul>
<li>Design decisions have consequences on other design decisions. This is an
important aspect of how and when to decide things.</li>
<li>Modules can be used to hide design decisions so they no longer affect
subsequent decisions.</li>
</ul>

<p>
I will try to explain how this comes about, some consequences, and some mistakes
to watch out for. But first, we need to visualise the effects design decisions
have on other decisions.
</p>
<section id="outline-container-org8cfa422">

<div id="text-org8cfa422">
<p>
We can think of the design space as a tree.
</p>

<ul>
<li>The decisions near the leaves of the tree are about concrete things that don’t
affect much of the rest of the design.
<ul>
<li>What input encoding do we use?</li>
<li>What is the colour of the button?</li>
<li>How long is the timeout?</li>
</ul></li>
<li>On the other hand, high-level branch decisions near the trunk of the tree
severely constrict the solutions that are possible. These are the significant
decisions that are incompatible with a large number of potential solutions.
<ul>
<li>How much memory can we use?</li>
<li>Which problems will we avoid solving?</li>
<li>How much control will we give the user?</li>
</ul></li>
</ul>

<p>
The path we take through the tree – i.e. the design decisions we make – result
in a specific product being designed.
</p>


<p><img src="https://two-wrongs.com/image/designtree-01.png" alt="designtree-01.png"/>
</p>

<p>
In this example, we have created the product implied by our decisions in
questions <i>a-c-h-m-t</i>. Notably, the decision we made in question <i>a</i> took us
down the path to <i>c</i>, which means it also eliminated the potential solutions
that involve decisions in question <i>b</i>.
</p>

<p>
This is why it’s useful to start with the high-level questions: it eliminates
the parts of the design tree we think are irrelevant, and lets us focus on the
relevant questions. It gets us to market faster, and we can learn quicker which
decisions we got wrong.
</p>
</div>
<div id="outline-container-org0ae6121">
<h2 id="org0ae6121">Configuration options create multiple products</h2>
<div id="text-org0ae6121">
<p>
In the software world, we don’t generally end up with just one product. We end
up with a configurable product, which is the same as a large number of products
that behave slightly differently; with the specific product desired at any given
moment selected by configuration options.
</p>

<p>
This is true, but immaterial to the following analysis. We can pretend that the
final leaf node represents not just one product, but all products that can be
generated by making configuration adjustments.
</p>
</div>
</div>
</section>
<section id="outline-container-org06b6080">

<div id="text-org06b6080">
<p>
When we are new to product development, we often dig into the concrete details
right away. This means we make decisions near the leaves before we tackle higher
level decisions. Halfway through the development work (i.e. when significant
amounts of code has been written already), we may have a design tree that looks
like this:
</p>


<p><img src="https://two-wrongs.com/image/designtree-02.png" alt="designtree-02.png"/>
</p>

<p>
What product does that correspond to? None at all. These decisions are on
completely different branches, meaning they are mutually exclusive, and there is
no way to construct a product that satisfies them all. We generally don’t notice
this until someone forces us to make a decision on e.g. question <i>b</i>, and then
we realise that whatever we choose, we are locking ourselves out of either <i>k</i>
or <i>g</i>.
</p>

<p>
The silver lining on the dark clouds is that this is usually discovered rather
late in the development process, so at this point the stakeholders may actually
be receptive to throwing out most of the decisions we had agreed to in order to
make the project finish sooner. It is a little embarrassing none the less.
</p>

<p>
Sometimes we are lucky and by accident make coherent leaf-level choices, e.g.
like this:
</p>


<p><img src="https://two-wrongs.com/image/designtree-03.png" alt="designtree-03.png"/>
</p>

<p>
But then when we get around to discussing question <i>a</i>, we realise we would much
rather make the choice that unlocks <i>c</i> as an alternative. Unfortunately, that’s
incompatible with all decisions we’ve made so far.
</p>

<p>
This is a devious situation that occurs surprisingly often: our early leaf-near
decisions imply a set of higher level decisions that we disagree with. Again, we
usually don’t discover this until we are trying to integrate everything and get
it out the door. Result: lots of expensive rework, or settling for a suboptimal
solution.
</p>


<p>
This is another reason to focus on high-level decisions first: we lower the risk
of spending time on decisions that we’ll have to tear up later because they are
incompatible with the overall shape we want the product to have.
</p>
</div>
<div id="outline-container-orgae455d7">
<h2 id="orgae455d7">We focus on leaf decisions because it feels good</h2>
<div id="text-orgae455d7">
<p>
The reason we tend to focus on leaf-near decisions, I speculate, is that
concrete details
</p>

<ul>
<li>engage a lot of people because they are easy to understand; and</li>
<li>quickly give us a sense of progress.</li>
</ul>

<p>
When we focus on concrete details while ignoring the big picture, we can work
off ticket after ticket and show great velocity when the project starts. This is
good for getting promoted.
</p>

<p>
But this also means we make these mistakes more often under time pressure,
and/or when many people are involved. These are the situations in which we most
would like to avoid rework! We can do better.
</p>

<p>
The very early parts of the project is not the time to make decisions on
details. Leave the details open.
</p>
</div>
</div>
</section>
<section id="outline-container-orgb46646f">

<div id="text-orgb46646f">
<p>
Let’s imagine we overcome these difficulties<span><sup>2</sup> Either by designing a coherent
product from the start, or by regretting some of our early decisions and
unwinding them.</span> and we have a working product. Guess what happens next?
</p>

<p>
The requirements change!
</p>

<p>
It turns out what users really wanted was the product that comes out of the
decisions in <i>a-c-h-n-q</i> instead. We backtrack, tear out some code, write new
code, refactor, and we end up with a new set of design decisions.
</p>


<p><img src="https://two-wrongs.com/image/designtree-04.png" alt="designtree-04.png"/>
</p>

<p>
Only then we discover the users may actually want <i>a-c-h-m-p</i> instead!
</p>



<p><img src="https://two-wrongs.com/image/designtree-05.png" alt="designtree-05.png"/>
</p>

<p>
In some businesses, we are lucky and can at this point say, “There. This is your
finished product. Go off and have fun with it.” In other businesses, this
process never ends; we keep discovering new requirements and – hypothetically –
walk around the design tree forever.
</p>

<p>
In practise we never end up walking the design tree forever. Residue from our
past mistakes (the dotted nodes) lingers in the codebase and makes it ever
harder for us to walk around the design tree. Eventually, fresh competitors will
be able to do it quicker and take our users.
</p>
</div>
<div id="outline-container-orgca16f18">
<h2 id="orgca16f18">Some decisions are practically unchangeable</h2>
<div id="text-orgca16f18">
<p>
At some point, we may also discover a requirement that implies a different
decision for a high-level design question, such as wanting to take the other
branch in question <i>c</i>. These changes are extremely expensive because all of the
subsequent decisions have depended on them. If we tear up <i>c</i>, we also have to
tear up <i>h-m-p</i>. We may start <a href="https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/">a big rewrite project and then regret it, one way
or another</a>.
</p>

<p>
Again, rework ensues and we accrete more residue. Although we <i>should</i> change
our decision in question <i>c</i>, there is no practical way to do it at this point.
It’s really important to get high-level decisions right.
</p>
</div>
</div>
</section>
<section id="outline-container-orgd3a7d7a">

<div id="text-orgd3a7d7a">
<p>
This, ultimately, leads us to what may seem like a paradox of product design.
</p>

<ul>
<li>We need to focus on the high-level design questions <i>first</i>, because otherwise
we will make incoherent detailed design decisions.</li>
<li>It is important that we get the high-level design questions right, which we
can only do if we postpone them for as long as possible.</li>
</ul>

<p>
There is a nuance here that is worth mentioning: not all high-level design
decisions will change. It’s easy to find constants in any domain, or at least
reliable relationships. These are sometimes called the <i>fundamental laws of the
domain</i> and a big part of innovative product development is to discover them.
Here are some dumb examples.
</p>

<ul>
<li>Passwords are shared secrets. If we use password-based authentication, we
need to be equipped to store valuable secrets.</li>
<li>There will be bugs in our software, so there needs to be a way to patch them.</li>
<li>Automation is capable of producing errors at a high rate.</li>
<li>Network <abbr>i/o</abbr> is slower than local <abbr>ram</abbr> access – although the next fastest
thing after “my <abbr>ram</abbr>” may well be “someone else’s <abbr>ram</abbr> on the same local
network.”</li>
<li>Humans don’t make sense of tables of many numbers. They need visual displays
of quantitative data.</li>
<li>Meteorologists need to be able to represent <i>fronts</i> in their weather
visualisation software.</li>
</ul>

<p>
It’s fine to make decisions and write code that assumes these fundamental laws
because they are unlikely to change. But there are also high-level decisions
that <i>are</i> prone to be invalidated by changing requirements. How do we deal with
that?
</p>
</div>
</section>
<section id="outline-container-orgc971090">

<div id="text-orgc971090">
<p>
We have to take a step back. The key realisation is that we are <i>not</i> designing
one program … and then we get unlucky and have to evolve it through time.
</p>

<p>
Instead, we start from the assumption that we <i>will</i> create several very similar
programs. We will create a <i>program family</i>, in the terminology of
Parnas<span><sup>3</sup> <i>On the Design and Development of Program Families</i>; Parnas; <abbr>ieee</abbr>
Transactions in Software Engineering; 1976.</span>. We bake this fact into our design
from the start. We account for not having the correct requirements (we never do)
and we plan to create multiple versions of the product. This changes how we
approach the design.
</p>

<p>
We still only create one product at a time, of course: the one that fulfills our
best current guess of the requirements. But we build it in such a way that the
other products we think we’ll need to build in the future are easy to build.
</p>

<p>
With this realisation, we start to think in modules.
</p>
</div>
</section>
<section id="outline-container-orgf9c8962">

<div id="text-orgf9c8962">
<p>
Any design questions where we anticipate the answer may change in the future, we
don’t write code mirroring our decision right away. Instead, we figure out the
interface that matches all possible decisions on that question, and write the
code against that interface. The effect is that we are <i>hiding</i> our decision
inside a module, and the rest of the code works against the interface of that
module, completely oblivious to what the actual decision was.
</p>

<p>
If we hide the decision made on question <i>h</i> in our original <i>a-c-(h)-m-t</i>
product, we still get the same product at first.
</p>


<p><img src="https://two-wrongs.com/image/designtree-06.png" alt="designtree-06.png"/>
</p>

<p>
But then, when we realise we might want the <i>a-c-(h)-n-q</i> product instead, we
don’t have to backtrack and rip up old decisions and rework the code. That
branch will still work against the general interface we made to hide the
decision <i>h</i>. We can build the missing pieces without having to change what
already exists.
</p>


<p><img src="https://two-wrongs.com/image/designtree-07.png" alt="designtree-07.png"/>
</p>

<p>
This is even more important for those high-level decisions. If we had
encapsulated the decision at <i>c</i> in a module, we could create the program
<i>a-(c)-g-o</i> without ripping up anything along the other branch, because none of
<i>g</i>, <i>h</i> or any descendent decisions would be able to make any assumptions about
the decision we made in <i>c</i> – that decision is hidden inside a module.
</p>


<p><img src="https://two-wrongs.com/image/designtree-08.png" alt="designtree-08.png"/>
</p>
</div>
</section>
<section id="outline-container-orga4d77a7">

<div id="text-orga4d77a7">
<p>
There’s an obvious reason we don’t just hide every decision in their own
modules: modules are more expensive than assumptions. Compared to
straightforward assumptions, modules
</p>

<ul>
<li>Take longer to create, because they need a general interface<span><sup>4</sup> And if their
interface is not quite general enough, they start to leak which is even
worse.</span>;</li>
<li>Introduce abstract concepts the reader may not be familiar with; and</li>
<li>Increase indirection in the code, making it harder to know what goes on.</li>
</ul>

<p>
We need to hide only some decisions – the ones that may change, and would be
expensive to change if they were coded as assumptions rather than hidden in
modules. So far, we have completely brushed over this difficult judgment, which
is a broad enough topic to be an article of its own. We will look at that some
other time.
</p>

<p>
Now that we know what modules are intended for, we also know what modules are
<i>not</i> for.
</p>

<ul>
<li>We don’t create a module just because we found a noun in the specification.</li>

<li>We don’t split our software into two modules because two teams will be working
on it.</li>

<li>We don’t create 100 modules because we recently read about how great
microservices are.</li>

<li>We don’t create a new module because the source code in the current one is
getting large.</li>
</ul>

<p>
We <i>do</i> create a module <b>to hide a design decision</b> we are forced to make
<b>before we are certain</b> it’s not going to change, so <b>subsequent decision
decisions cannot make assumptions</b> about this one.
</p>
</div>
</section>

            </div></div>
  </body>
</html>
