<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://scharenbroch.dev/projects/apl-interpreter/">Original</a>
    <h1>APL Interpreter – An implementation of APL, written in Haskell (2024)</h1>
    
    <div id="readability-page-1" class="page"><div><h4>January 11, 2024</h4><h3 id="github-linkhttpsgithubcomlucasscharenbrochapl-interpreter">(<a href="https://github.com/lucasscharenbroch/apl-interpreter" target="_blank">Github Link</a>)</h3><h2 id="why-apl">Why APL?</h2><p><a href="https://en.wikipedia.org/wiki/APL_%28programming_language%29" target="_blank">APL</a> is an <em>array</em> programming language<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>.
Its <strong>only data type</strong> is the (multidimensional) <em>array</em>.
While this might seem like a huge limitation, the generality it provides leads to a syntax that is incredibly compact and expressive, which forces the programmer to approach problems at a higher level.</p><p>I was first drawn to APL by the nature of its syntax: with the exception of user-defined variables, all built-in functions and operators are single<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup> unicode symbols.
As a result, code looks like this.</p><div><pre tabindex="0"><code data-lang="apl"><span><span><span>⍝ My solution to day 7 of Advent of Code &#39;23</span>
</span></span><span><span>
</span></span><span><span>c2n <span>←</span> <span>&#39;23456789TJQKA&#39;</span><span>∘</span><span>⍳</span>
</span></span><span><span>classify <span>←</span> (<span>5</span><span>-≢</span><span>⍤</span><span>∪</span>)<span>,</span>(<span>⌈</span><span>/</span>(<span>+</span><span>/∘.</span><span>=</span><span>⍨</span>))<span>,</span>((<span>5</span><span>≡∪</span>)<span>×</span>(<span>⌈</span><span>/</span>c2n))
</span></span><span><span>h2n <span>←</span> <span>13</span><span>⊥</span>classify<span>,</span>(<span>¯1</span><span>∘</span><span>+</span>c2n)
</span></span><span><span>
</span></span><span><span>hands bids <span>←</span> <span>↓⍉↑</span>((<span>&#39; &#39;</span><span>∘</span><span>≠</span>)<span>⊆⊢</span>)<span>¨</span> input
</span></span><span><span>bids <span>←</span> <span>⍎</span><span>¨</span> bids
</span></span><span><span>
</span></span><span><span>⎕ <span>←</span> <span>+</span><span>/</span> (<span>⍳≢</span>bids) <span>×</span> bids<span>[</span><span>⍋</span> h2n<span>¨</span> hands<span>]</span>
</span></span><span><span>
</span></span><span><span>modes <span>←</span> <span>{</span> ⍵<span>≡</span><span>⍬</span> : <span>⍬</span> ⋄ <span>∪</span>⍵<span>⌷</span><span>⍨</span><span>⊂</span>(<span>⍸⌈</span><span>/</span><span>=⊢</span>)<span>+</span><span>/∘.</span><span>=</span><span>⍨</span>⍵ <span>}</span>
</span></span><span><span>change_joker <span>←</span> <span>{</span> (<span>⊃</span> <span>&#39;A&#39;</span> <span>,</span><span>⍨</span> modes (⍵<span>~</span><span>&#39;J&#39;</span>))<span>@</span>(<span>⍸</span>⍵<span>=</span><span>&#39;J&#39;</span>) <span>⊢</span> ⍵ <span>}</span>
</span></span><span><span>
</span></span><span><span>c2n <span>←</span> <span>&#39;J23456789TQKA&#39;</span><span>∘</span><span>⍳</span>
</span></span><span><span>h2n <span>←</span> <span>13</span><span>⊥</span>(classify change_joker)<span>,</span>(<span>¯1</span><span>∘</span><span>+</span>c2n)
</span></span><span><span>
</span></span><span><span>⎕ <span>←</span> <span>+</span><span>/</span> (<span>⍳≢</span>bids) <span>×</span> bids<span>[</span><span>⍋</span> h2n<span>¨</span> hands<span>]</span></span></span></code></pre></div><p>As you might expect, learning to write programs like this<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup> requires a totally different mind-set.
Array programming is similar to functional programming – the primary way to control execution involves composition of functions – but APL tends to encourage the reliance on global properties and sweeping operations rather than low-level recursion<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup>.</p><p>I’d like to think that learning to approach problems this way provides greater insights for programming in general.</p><h2 id="why-haskell">Why Haskell?</h2><p>I originally planned this project to be a deep-dive into APL, and learning Haskell was more of a side-quest.
It ended up the other way around: the hardest aspect of this project, by far, was learning work with Haskell<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup>.</p><p>In all honesty, Haskell probably isn’t an ideal tool for an array-language interpreter:
it makes parsing and combination of functions much more elegant, but at the expense of
ease of working with state, data structures, and performance.</p><p>As a result, this project isn’t intended to be especially practically useful, nor to be a replacement for existing interpreters.</p><h2 id="the-big-picture">The Big Picture</h2><p>The program at large works exactly how you would expect any interpreter to work.</p><ul><li>Read Text As Input</li><li>Convert Raw Text to Tokens (Lexing/Scanning)</li><li>Convert Token Stream Into Syntax Tree (Parsing)</li><li>Evaluate the parsed tree</li><li>Print the result</li><li>Repeat</li></ul><p>The interpreter state (a mapping from variable names to values) is read/updated throughout.</p><h2 id="parsing">Parsing</h2><p>Haskell has some powerful parsing libraries, but I decided to write my parser from scratch, partly to make sure I really understood what the code was doing, and partly because I was scared off by the type signatures<sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup> of said libraries.
I initially attempted to write the parser in a similar style to those in my <a href="https://scharenbroch.dev/projects/bash-with-floats">other</a> <a href="https://scharenbroch.dev/projects/graphing-calculator">projects</a>, but was forced into using a series of helper “match-functions” to translate the imperative code into a functional style.
Then, through a series of refactors, the majority of those helpers dissolved into calls to standard Haskell functions, resulting in syntax very similar to the aforementioned parsing libraries.</p><h3 id="parser-version-1-context-free">Parser, Version 1 (Context-Free)</h3><p>The core unit of logic in the parser if the <strong><code>MatchFn</code></strong>. Its definition changed across the versions of the parser, but its main purpose did not: it takes a list of tokens as input, and possibly returns the thing that was matched, along with the new list of tokens.</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>type</span> <span>MatchFn</span> a <span>=</span> [<span>Token</span>] <span>-&gt;</span> <span>Maybe</span> (a, [<span>Token</span>])</span></span></code></pre></div><p><strong><code>MatchFn</code></strong>’s for <a href="https://en.wikipedia.org/wiki/Terminal_and_nonterminal_symbols" target="_blank">terminals</a> can now be trivially described.</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>data</span> <span>Token</span> <span>=</span> <span>NumTok</span> <span>Double</span>
</span></span><span><span>           <span>|</span> <span>StrTok</span> <span>String</span>
</span></span><span><span>           <span>|</span> <span>IdTok</span> <span>String</span>
</span></span><span><span>           <span>|</span> <span>ChTok</span> <span>Char</span>
</span></span><span><span>
</span></span><span><span><span>matchCh</span> <span>::</span> <span>Char</span> <span>-&gt;</span> <span>MatchFn</span> <span>Char</span>
</span></span><span><span><span>matchCh</span> c (<span>ChTok</span> c&#39;<span>:</span>ts)
</span></span><span><span>    <span>|</span> c <span>==</span> c&#39; <span>=</span> <span>Just</span> (c, ts)
</span></span><span><span>    <span>|</span> otherwise <span>=</span> <span>Nothing</span>
</span></span><span><span><span>matchCh</span> <span>_</span> <span>_</span> <span>=</span> <span>Nothing</span>
</span></span><span><span>
</span></span><span><span><span>matchId</span> <span>::</span> <span>MatchFn</span> <span>String</span>
</span></span><span><span><span>matchId</span> (<span>IdTok</span> s<span>:</span>ts) <span>=</span> <span>Just</span> (s, ts)
</span></span><span><span><span>matchId</span> <span>_</span> <span>=</span> <span>Nothing</span>
</span></span><span><span>
</span></span><span><span><span>matchStrLiteral</span> <span>::</span> <span>MatchFn</span> <span>String</span>
</span></span><span><span><span>matchStrLiteral</span> (<span>StrTok</span> s<span>:</span>ts) <span>=</span> <span>Just</span> (s, ts)
</span></span><span><span><span>matchStrLiteral</span> <span>_</span> <span>=</span> <span>Nothing</span>
</span></span><span><span>
</span></span><span><span><span>matchNumLiteral</span> <span>::</span> <span>MatchFn</span> <span>Double</span>
</span></span><span><span><span>matchNumLiteral</span> (<span>NumTok</span> n<span>:</span>ts) <span>=</span> <span>Just</span> (n, ts)
</span></span><span><span><span>matchNumLiteral</span> <span>_</span> <span>=</span> <span>Nothing</span></span></span></code></pre></div><sup id="fnref:7"><a href="#fn:7" role="doc-noteref">7</a></sup><p>From here, it isn’t really obvious how to combine the above functions to parse arbitrary nonterminals.
This is addressed by adding a few more helpers that combine (chain) <strong><code>MatchFn</code></strong>’s.</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>matchOne</span> <span>::</span> [<span>MatchFn</span> a] <span>-&gt;</span> <span>MatchFn</span> a
</span></span><span><span><span>-- return first successful match, else Nothing</span>
</span></span><span><span><span>matchOne</span> fns toks <span>=</span> foldl try <span>Nothing</span> fns
</span></span><span><span>    <span>where</span> try (<span>Just</span> x) <span>_</span> <span>=</span> <span>Just</span> x <span>-- already found match</span>
</span></span><span><span>          try <span>Nothing</span> f <span>=</span> f toks
</span></span><span><span>
</span></span><span><span><span>matchAll</span> <span>::</span> [<span>MatchFn</span> a] <span>-&gt;</span> <span>MatchFn</span> [a]
</span></span><span><span><span>-- match every function in list (sequentially), returning their results, else Nothing</span>
</span></span><span><span><span>matchAll</span> fns toks <span>=</span> chFst (reverse) <span>.</span> foldl try (<span>Just</span> (<span>[]</span>, toks)) <span>$</span> fns
</span></span><span><span>    <span>where</span> try <span>Nothing</span> <span>_</span> <span>=</span> <span>Nothing</span>
</span></span><span><span>          try (<span>Just</span> (rs, ts)) f <span>=</span> <span>case</span> f ts <span>of</span>
</span></span><span><span>              <span>Just</span> (r, ts&#39;) <span>-&gt;</span> <span>Just</span>(r<span>:</span>rs, ts&#39;)
</span></span><span><span>              <span>_</span> <span>-&gt;</span> <span>Nothing</span>
</span></span><span><span>
</span></span><span><span><span>matchMax</span> <span>::</span> [<span>MatchFn</span> a] <span>-&gt;</span> <span>MatchFn</span> [[a]]
</span></span><span><span><span>-- match 0 or more repetitions of the entire function list</span>
</span></span><span><span><span>matchMax</span> fns toks <span>=</span> <span>case</span> matchAll fns toks <span>of</span>
</span></span><span><span>    <span>Nothing</span> <span>-&gt;</span> <span>Nothing</span>
</span></span><span><span>    <span>Just</span> (r, ts) <span>-&gt;</span> <span>case</span> matchMax fns ts <span>of</span>
</span></span><span><span>        <span>Nothing</span> <span>-&gt;</span> <span>Just</span> ([r], ts)
</span></span><span><span>        <span>Just</span> (rs, ts&#39;) <span>-&gt;</span> <span>Just</span> (r<span>:</span>rs, ts&#39;)
</span></span><span><span>
</span></span><span><span><span>matchAllThenMax</span> <span>::</span> [<span>MatchFn</span> a] <span>-&gt;</span> <span>MatchFn</span> [[a]]
</span></span><span><span><span>-- ... similar definition</span></span></span></code></pre></div><p>The <strong><code>chFst</code></strong> function is a convenient way to conditionally apply an arbitrary function to the result of a MatchFn (<strong><code>Maybe (a, [Token])</code></strong>) without doing a case-analysis.</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>chFst</span> <span>::</span> (a <span>-&gt;</span> b) <span>-&gt;</span> <span>Maybe</span> (a, c) <span>-&gt;</span> <span>Maybe</span> (b, c)
</span></span><span><span><span>-- chain first: apply function to first element of maybe-wrapped tuple</span>
</span></span><span><span><span>chFst</span> f m <span>=</span> <span>case</span> m <span>of</span>
</span></span><span><span>    <span>Nothing</span> <span>-&gt;</span> <span>Nothing</span>
</span></span><span><span>    <span>Just</span> (x, y) <span>-&gt;</span> <span>Just</span> (f x, y)</span></span></code></pre></div><p>There’s also another variant, <strong><code>mchFst</code></strong>, which allows the chaining-function to fail (return Nothing), in which case the entire construct also becomes nothing.</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>mchFst</span> <span>::</span> (a <span>-&gt;</span> <span>Maybe</span> b) <span>-&gt;</span> <span>Maybe</span> (a, c) <span>-&gt;</span> <span>Maybe</span> (b, c)
</span></span><span><span><span>-- maybe chain first</span>
</span></span><span><span><span>mchFst</span> f m <span>=</span> <span>case</span> m <span>of</span>
</span></span><span><span>    <span>Nothing</span> <span>-&gt;</span> <span>Nothing</span>
</span></span><span><span>    <span>Just</span> (x, y) <span>-&gt;</span> <span>case</span> (f x) <span>of</span>
</span></span><span><span>        <span>Nothing</span> <span>-&gt;</span> <span>Nothing</span>
</span></span><span><span>        <span>Just</span> z <span>-&gt;</span> <span>Just</span>(z, y)</span></span></code></pre></div><p>All of the above helper match-functions only deal with combining homogeneous <strong><code>MatchFn</code></strong>’s (i.e. <strong><code>MatchFn Int</code></strong> and <strong><code>MatchFn Int</code></strong>, not <strong><code>MatchFn String</code></strong> and <strong><code>MatchFn Int</code></strong>).
Tuples are one solution to this.</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>matchT2</span> <span>::</span> (<span>MatchFn</span> a, <span>MatchFn</span> b) <span>-&gt;</span> <span>MatchFn</span> (a, b)
</span></span><span><span><span>matchT2</span> (fa, fb) ts <span>=</span> <span>case</span> fa ts <span>of</span>
</span></span><span><span>    <span>Nothing</span> <span>-&gt;</span> <span>Nothing</span>
</span></span><span><span>    <span>Just</span> (a, ts&#39;) <span>-&gt;</span> <span>case</span> fb ts&#39; <span>of</span>
</span></span><span><span>        <span>Nothing</span> <span>-&gt;</span> <span>Nothing</span>
</span></span><span><span>        <span>Just</span> (b, ts&#39;&#39;) <span>-&gt;</span> <span>Just</span> ((a, b), ts&#39;&#39;)
</span></span><span><span>
</span></span><span><span><span>matchT3</span> <span>::</span> (<span>MatchFn</span> a, <span>MatchFn</span> b, <span>MatchFn</span> c) <span>-&gt;</span> <span>MatchFn</span> (a, b, c)
</span></span><span><span><span>matchT3</span> (fa, fb, fc) ts <span>=</span> <span>case</span> fa ts <span>of</span>
</span></span><span><span>    <span>Nothing</span> <span>-&gt;</span> <span>Nothing</span>
</span></span><span><span>    <span>Just</span> (a, ts&#39;) <span>-&gt;</span> <span>case</span> fb ts&#39; <span>of</span>
</span></span><span><span>        <span>Nothing</span> <span>-&gt;</span> <span>Nothing</span>
</span></span><span><span>        <span>Just</span> (b, ts&#39;&#39;) <span>-&gt;</span> <span>case</span> fc ts&#39;&#39; <span>of</span>
</span></span><span><span>            <span>Nothing</span> <span>-&gt;</span> <span>Nothing</span>
</span></span><span><span>            <span>Just</span> (c, ts&#39;&#39;&#39;) <span>-&gt;</span> <span>Just</span> ((a, b, c), ts&#39;&#39;&#39;)
</span></span><span><span>
</span></span><span><span><span>matchT4</span> <span>::</span> (<span>MatchFn</span> a, <span>MatchFn</span> b, <span>MatchFn</span> c, <span>MatchFn</span> d) <span>-&gt;</span> <span>MatchFn</span> (a, b, c, d)
</span></span><span><span><span>-- ... etc.</span></span></span></code></pre></div><p>These helpers alone make for a relatively elegant<sup id="fnref:8"><a href="#fn:8" role="doc-noteref">8</a></sup> parser, with syntax kind of similar to <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form" target="_blank">BNF</a> (or at least a lot closer than an average imperative implementation).</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>-- der_arr =&gt; train der_arr</span>
</span></span><span><span><span>--         =&gt; arr der_fn der_arr</span>
</span></span><span><span><span>--         =&gt; arr</span>
</span></span><span><span>
</span></span><span><span><span>parseDerArr</span> <span>::</span> <span>MatchFn</span> <span>ArrTreeNode</span>
</span></span><span><span><span>parseDerArr</span> <span>=</span> matchOne [
</span></span><span><span>        chFst (<span>\</span>(t, da) <span>-&gt;</span> <span>ArrInternalMonFn</span> t da) <span>.</span> matchT2 (parseTrain, parseDerArr),
</span></span><span><span>        chFst (<span>\</span>(lhs, f, rhs) <span>-&gt;</span> <span>ArrInternalDyadFn</span> f lhs rhs) <span>.</span> matchT3 (
</span></span><span><span>            parseArr,
</span></span><span><span>            parseDerFn,
</span></span><span><span>            parseDerArr
</span></span><span><span>        ),
</span></span><span><span>        parseArr
</span></span><span><span>    ]</span></span></code></pre></div><sup id="fnref:9"><a href="#fn:9" role="doc-noteref">9</a></sup><h3 id="parser-version-2-context">Parser, Version 2 (+Context)</h3><p>It turns out that APL doesn’t have a <a href="https://en.wikipedia.org/wiki/Context-free_grammar" target="_blank">context-free grammar</a>.<sup id="fnref:10"><a href="#fn:10" role="doc-noteref">10</a></sup>
This means that it requires more information than the tokens alone to form the syntax tree, namely the values of variables.</p><p>This foils the current definition of <strong><code>MatchFn</code></strong>: because Haskell is purely functional, <strong><code>MatchFn</code></strong>’s must solely deal in their arguments<sup id="fnref:11"><a href="#fn:11" role="doc-noteref">11</a></sup> (otherwise they have side-effects), so the global state (<strong><code>IdMap</code></strong>) must be added as an argument to <strong><code>MatchFn</code></strong>. Parsing shouldn’t modify the <strong><code>IdMap</code></strong>, so the return value can remain the same.</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>type</span> <span>MatchFn</span> a <span>=</span> (<span>IdMap</span>, [<span>Token</span>]) <span>-&gt;</span> <span>Maybe</span> (a, [<span>Token</span>])</span></span></code></pre></div><sup id="fnref:12"><a href="#fn:12" role="doc-noteref">12</a></sup><p>The beauty of this change is that only the terminal matching functions and the matching helpers (only the functions with “match” as a prefix) need to be changed – this is because the nonterminal parsing (“parse-”) functions never actually directly touch to the arguments to MatchFn: they solely serve as <em>definitions of combinations</em> of helper functions<sup id="fnref:13"><a href="#fn:13" role="doc-noteref">13</a></sup>.</p><p>The “match-” functions can be easily updated, with some minor syntactic inconvenience.</p><div><pre tabindex="0"><code data-lang="diff"><span><span> matchCh :: Char -&gt; MatchFn Char
</span></span><span><span><span>-matchCh c (ChTok c&#39;:ts)
</span></span></span><span><span><span></span><span>+matchCh c (_, (ChTok c&#39;:ts))
</span></span></span><span><span><span></span>     | c == c&#39; = Just (c, ts)
</span></span><span><span>     | otherwise = Nothing
</span></span><span><span> matchCh _ _ = Nothing
</span></span><span><span>
</span></span><span><span>
</span></span><span><span> matchStrLiteral :: MatchFn String
</span></span><span><span><span>-matchStrLiteral (StrTok s:ts) = Just (s, ts)
</span></span></span><span><span><span></span><span>+matchStrLiteral (_, (StrTok s:ts)) = Just (s, ts)
</span></span></span><span><span><span></span> matchStrLiteral _ = Nothing
</span></span><span><span>
</span></span><span><span> -- ... etc.
</span></span><span><span>
</span></span><span><span> matchOne :: [MatchFn a] -&gt; MatchFn a
</span></span><span><span> -- return first successful match, else Nothing
</span></span><span><span><span>-matchOne fns toks = foldl try Nothing fns
</span></span></span><span><span><span></span><span>+matchOne fns args = foldl try Nothing fns
</span></span></span><span><span><span></span>     where try (Just x) _ = Just x -- already found match
</span></span><span><span><span>-          try Nothing f = f toks
</span></span></span><span><span><span></span><span>+          try Nothing f = f args
</span></span></span><span><span><span></span>
</span></span><span><span> matchAll :: [MatchFn a] -&gt; MatchFn [a]
</span></span><span><span> -- match every function in list (sequentially), returning their results, else Nothing
</span></span><span><span><span>-matchAll fns toks = chFst (reverse) . foldl try (Just ([], toks)) $ fns
</span></span></span><span><span><span></span><span>+matchAll fns (idm, toks) = chFst (reverse) . foldl try (Just ([], toks)) $ fns
</span></span></span><span><span><span></span>     where try Nothing _ = Nothing
</span></span><span><span><span>-          try (Just (rs, ts)) f = case f ts of
</span></span></span><span><span><span></span><span>+          try (Just (rs, ts)) f = case f (idm, ts) of
</span></span></span><span><span><span></span>               Just (r, ts&#39;) -&gt; Just(r:rs, ts&#39;)
</span></span><span><span>               _ -&gt; Nothing
</span></span><span><span>
</span></span><span><span> -- ... etc.
</span></span><span><span>
</span></span><span><span> matchT2 :: (MatchFn a, MatchFn b) -&gt; MatchFn (a, b)
</span></span><span><span><span>-matchT2 (fa, fb) ts = case fa ts of
</span></span></span><span><span><span></span><span>+matchT2 (fa, fb) (idm, ts) = case fa (idm, ts) of
</span></span></span><span><span><span></span>     Nothing -&gt; Nothing
</span></span><span><span><span>-    Just (a, ts&#39;) -&gt; case fb ts&#39; of
</span></span></span><span><span><span></span><span>+    Just (a, ts&#39;) -&gt; case fb (idm, ts&#39;) of
</span></span></span><span><span><span></span>         Nothing -&gt; Nothing
</span></span><span><span>         Just (b, ts&#39;&#39;) -&gt; Just ((a, b), ts&#39;&#39;)
</span></span><span><span> -- ... etc.
</span></span></code></pre></div><h3 id="parser-version-3-monads">Parser, Version 3 (+Monads)</h3><p>Throughout writing and refactoring the parser, while I was generally happy with its functionality, there were three main inconveniences that bothered me.</p><ol><li>The existence of the <strong><code>parseT</code></strong> functions: they are too hard-coded. There must be a more general way to fix this.</li><li>The existence and syntactic clumsiness of <strong><code>chFst</code></strong> and <strong><code>mchFst</code></strong>.</li><li><strong><code>parseDerFn</code></strong></li></ol><p>The majority of the “parse-” functions were relatively concise and readable, but there was one particular function that had a heavy reliance on the global state (IdMap) that made its implementation monstrous.</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>-- der_fn =&gt; (f|a) op [f|a] {op [f|a]}       (where (f|a) is fn or arr; match the</span>
</span></span><span><span><span>--                                            optional iff op is dyadic)</span>
</span></span><span><span>
</span></span><span><span><span>parseDerFn</span> <span>::</span> <span>MatchFn</span> <span>FnTreeNode</span>
</span></span><span><span><span>parseDerFn</span> (idm, ts) <span>=</span> matchOne [
</span></span><span><span>        (<span>=&lt;&lt;</span>) (parseDerFnRec) <span>.</span> (<span>=&lt;&lt;</span>) (finishOpMatch) <span>.</span> matchT2 (_parseArg, parseOp),
</span></span><span><span>        parseFn
</span></span><span><span>    ] (idm, ts)
</span></span><span><span>    <span>where</span> _parseArg <span>=</span> matchOne [parseFn, chFst (<span>FnLeafArr</span>) <span>.</span> parseArr]
</span></span><span><span>          finishOpMatch <span>::</span> ((<span>FnTreeNode</span>, <span>Operator</span>), [<span>Token</span>]) <span>-&gt;</span> <span>Maybe</span> (<span>FnTreeNode</span>, [<span>Token</span>])
</span></span><span><span>          finishOpMatch ((lhs, op<span>@</span>(<span>DyadOp</span> <span>_</span> <span>_</span>)), toks) <span>=</span> chFst (<span>FnInternalDyadOp</span> op lhs) <span>$</span> _parseArg (idm, toks)
</span></span><span><span>          finishOpMatch ((lhs, op), toks) <span>=</span> <span>Just</span> (<span>FnInternalMonOp</span> op lhs, toks)
</span></span><span><span>          parseDerFnRec <span>::</span> (<span>FnTreeNode</span>, [<span>Token</span>]) <span>-&gt;</span> <span>Maybe</span> (<span>FnTreeNode</span>, [<span>Token</span>])
</span></span><span><span>          parseDerFnRec (lhs, toks) <span>=</span> <span>case</span> (<span>=&lt;&lt;</span>) (finishOpMatch) <span>.</span> chFst (<span>\</span>op <span>-&gt;</span> (lhs, op)) <span>$</span> parseOp (idm, toks) <span>of</span>
</span></span><span><span>              <span>Nothing</span> <span>-&gt;</span> <span>Just</span> (lhs, toks)
</span></span><span><span>              <span>Just</span> res <span>-&gt;</span> parseDerFnRec res</span></span></code></pre></div><p><strong><code>parseDerFn</code></strong> is the exception to the above statement that “parse-” functions never directly manipulate the argument to <strong><code>MatchFn</code></strong> (<strong><code>(IdMap, [Token])</code></strong>).
<strong><code>parseDerFn</code></strong> breaks this rule because it needs to have the <strong><code>IdMap</code></strong> to check whether the parsed operator is monadic or dyadic.
This can’t be done with <strong><code>chFst</code></strong> or <strong><code>mchFst</code></strong>, because neither takes the <strong>IdMap</strong> as an argument, which <strong><code>finishOpMatch</code></strong> requires.</p><p>At this point, I had already realized the similarity between <strong><code>mchFst</code></strong> and <strong><code>(=&lt;&lt;)</code></strong>.</p><div><pre tabindex="0"><code data-lang="haskell"><span><span>(<span>=&lt;&lt;</span>) <span>::</span> (a <span>-&gt;</span> m b) <span>-&gt;</span> m a <span>-&gt;</span> m b
</span></span><span><span><span>-- (let a = (a, c); b = (b, c); m = Maybe in the definition of (=&lt;&lt;))</span>
</span></span><span><span><span>-- (=&lt;&lt;) :: ((a, c) -&gt; Maybe (b, c)) -&gt; Maybe (a, c) -&gt; Maybe (b, c)</span>
</span></span><span><span><span>-- let c = [Token]</span>
</span></span><span><span><span>-- (=&lt;&lt;) :: ((a, [Token]) -&gt; Maybe (b, [Token])) -&gt; Maybe (a, [Token]) -&gt; Maybe (b, [Token])</span>
</span></span><span><span>
</span></span><span><span><span>mchFst</span> <span>::</span> (a <span>-&gt;</span> <span>Maybe</span> b) <span>-&gt;</span> <span>Maybe</span> (a, c) <span>-&gt;</span> <span>Maybe</span> (b, c)
</span></span><span><span><span>-- let c = [Token]</span>
</span></span><span><span><span>-- mchFst :: (a -&gt; Maybe b) -&gt; Maybe (a, [Token]) -&gt; Maybe (b, [Token])</span>
</span></span><span><span>
</span></span><span><span><span>-- (=&lt;&lt;) ::  ((a, [Token]) -&gt; Maybe (b, [Token])) -&gt; Maybe (a, [Token]) -&gt; Maybe (b, [Token])</span>
</span></span><span><span><span>-- mchFst :: (a            -&gt; Maybe b           ) -&gt; Maybe (a, [Token]) -&gt; Maybe (b, [Token])</span></span></span></code></pre></div><p>So <strong><code>mchFst</code></strong> is just a specialized version of <strong><code>(=&lt;&lt;)</code></strong> that assumes that the token-list remains unchanged.</p><p>I decided I ought to try to figure out what other patterns in my parser were mimicking those of built-in monadic functions<sup id="fnref:14"><a href="#fn:14" role="doc-noteref">14</a></sup>, and attempt to refactor accordingly.</p><p><strong><code>chFst</code></strong> and <strong><code>mchFst</code></strong> could not directly be substituted for monadic functions, because they heavily rely on the knowledge that the value they receive is a tuple (wrapped in a Maybe), and that the first element of that tuple is the one that gets modified, while the second element (the <strong><code>[Token]</code></strong>) stays the same<sup id="fnref:15"><a href="#fn:15" role="doc-noteref">15</a></sup>.</p><p>The key point here is that <strong><code>chFst</code></strong> and <strong><code>mchFst</code></strong> are <em>not general enough</em>. Their main use is to (in conjunction with composition) convert a <strong><code>MatchFn</code></strong> parameterized by one type to a <strong><code>MatchFn</code></strong> parameterized by another (see below).
But they assume that that function (<strong><code>f</code></strong>) only deals with the type parameter of <strong><code>MatchFn</code></strong> (<strong><code>a</code></strong>/<strong><code>b</code></strong>), and has no effect on the <strong><code>[Token]</code></strong>, and cannot read the <strong><code>IdMap</code></strong>.</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>-- (MatchFn from version 2)</span>
</span></span><span><span><span>type</span> <span>MatchFn</span> a <span>=</span> (<span>IdMap</span>, [<span>Token</span>]) <span>-&gt;</span> <span>Maybe</span> (a, [<span>Token</span>])
</span></span><span><span>
</span></span><span><span><span>mfFmap</span>  f <span>=</span> (<span>.</span>) (chFst  f) <span>::</span> (a <span>-&gt;</span>       b) <span>-&gt;</span> <span>MatchFn</span> a <span>-&gt;</span> <span>MatchFn</span> b
</span></span><span><span><span>mfFBind</span> f <span>=</span> (<span>.</span>) (mchFst f) <span>::</span> (a <span>-&gt;</span> <span>Maybe</span> b) <span>-&gt;</span> <span>MatchFn</span> a <span>-&gt;</span> <span>MatchFn</span> b</span></span></code></pre></div><sup id="fnref:16"><a href="#fn:16" role="doc-noteref">16</a></sup><p>This lack of generality is clearly the cause of inconvenience #3.</p><p>One solution to this is to expand the definition of <strong><code>MatchFn</code></strong> to also return an IdMap (so chained functions can access it), and to write a few new chaining helper-functions that allow access to different parts of the returned tuple.</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>type</span> <span>MatchFn</span> a <span>=</span> (<span>IdMap</span>, [<span>Token</span>]) <span>-&gt;</span> <span>Maybe</span> (a, [<span>Token</span>], <span>IdMap</span>)
</span></span><span><span>
</span></span><span><span><span>mfFmap</span>            <span>::</span> (         a <span>-&gt;</span>         b) <span>-&gt;</span> <span>MatchFn</span> a <span>-&gt;</span> <span>MatchFn</span> b
</span></span><span><span><span>mfFBindMaybe</span>      <span>::</span> (         a <span>-&gt;</span> <span>Maybe</span>   b) <span>-&gt;</span> <span>MatchFn</span> a <span>-&gt;</span> <span>MatchFn</span> b
</span></span><span><span><span>mfFBindIdm</span>        <span>::</span> (<span>IdMap</span> <span>-&gt;</span> a <span>-&gt;</span>         b) <span>-&gt;</span> <span>MatchFn</span> a <span>-&gt;</span> <span>MatchFn</span> b
</span></span><span><span><span>mfFBindIdm&#39;</span>       <span>::</span> (<span>IdMap</span> <span>-&gt;</span> a <span>-&gt;</span> <span>MatchFn</span> b) <span>-&gt;</span> <span>MatchFn</span> a <span>-&gt;</span> <span>MatchFn</span> b
</span></span><span><span><span>mfFBindIdmMaybe</span>   <span>::</span> (<span>IdMap</span> <span>-&gt;</span> a <span>-&gt;</span> <span>Maybe</span>   b) <span>-&gt;</span> <span>MatchFn</span> a <span>-&gt;</span> <span>MatchFn</span> b
</span></span><span><span><span>mfFBind</span>           <span>::</span> (         a <span>-&gt;</span> <span>MatchFn</span> b) <span>-&gt;</span> <span>MatchFn</span> a <span>-&gt;</span> <span>MatchFn</span> b</span></span></code></pre></div><p>This isn’t a very good solution, though, as it adds a lot of boilerplate (much of which is rarely used), and it doesn’t fix the other inconveniences.
Additionally, by adding <strong><code>IdMap</code></strong> to the return type, it introduces the (albeit unlikely) possibility that a parsing function may modify the <strong><code>IdMap</code></strong>.</p><p>A better solution is to change <strong><code>MatchFn</code></strong> into a monad whose functions exactly match the desired behavior, then to use generic monadic functions instead of chFst and mchFst.</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>type</span> <span>MatchFn</span> a <span>=</span> <span>StateT</span> [<span>Token</span>] (<span>MaybeT</span> (<span>Reader</span> <span>IdMap</span>)) a</span></span></code></pre></div><p>It’s probably a little steep to try to completely explain this type, so I’ll keep it high-level.
The names that end with ‘T’ are <a href="https://en.wikipedia.org/wiki/Monad_transformer" target="_blank">Monad Transformers</a>, which take another monad as one of their type parameters, to form a single resulting monad. Each of the following is a monad.</p><ul><li><strong><code>Reader IdMap</code></strong></li><li><strong><code>MaybeT (Reader IdMap)</code></strong></li><li><strong><code>StateT [Token] (MaybeT (Reader IdMap))</code></strong></li></ul><p>Monad transformers preserve the behavior of the monad they receive, and add their own behavior on top<sup id="fnref:17"><a href="#fn:17" role="doc-noteref">17</a></sup>.</p><p>It’s interesting to note that <strong><code>MatchFn</code></strong> itself is no longer a function: it is a monad whose state internal state is a function<sup id="fnref:18"><a href="#fn:18" role="doc-noteref">18</a></sup>.</p><p>This requires another reworking of the “match-” functions, but the “parse-” functions can (again) stay mostly the same, except <strong><code>(&lt;$&gt;)</code></strong> (fmap) replaces <strong><code>chFst</code></strong>, and <strong><code>(=&lt;&lt;)</code></strong> (or <strong><code>(&gt;&gt;=)</code></strong> or do-notation) replaces <strong><code>mchFst</code></strong>.</p><div><pre tabindex="0"><code data-lang="diff"><span><span><span>+evalMatchFn :: IdMap -&gt; [Token] -&gt; MatchFn a -&gt; Maybe (a, [Token])
</span></span></span><span><span><span>+evalMatchFn idm toks = (flip runReader) idm . runMaybeT . (flip runStateT) toks
</span></span></span><span><span><span></span>
</span></span><span><span><span>+maybeMatch :: MatchFn a -&gt; MatchFn (Maybe a)
</span></span></span><span><span><span>+maybeMatch f = do
</span></span></span><span><span><span>+    idm &lt;- getIdm
</span></span></span><span><span><span>+    toks &lt;- get
</span></span></span><span><span><span>+    case evalMatchFn idm toks f of
</span></span></span><span><span><span>+        Nothing -&gt; return Nothing
</span></span></span><span><span><span>+        Just (x, toks&#39;) -&gt; do
</span></span></span><span><span><span>+            put toks&#39;
</span></span></span><span><span><span>+            return $ Just x
</span></span></span><span><span><span></span>
</span></span><span><span> matchOne :: [MatchFn a] -&gt; MatchFn a
</span></span><span><span> -- return first successful match, else Nothing
</span></span><span><span><span>-matchOne fns args = foldl try Nothing fns
</span></span></span><span><span><span>-    where try (Just x) _ = Just x -- already found match
</span></span></span><span><span><span>-          try Nothing f = f args
</span></span></span><span><span><span></span><span>+matchOne [] = mzero
</span></span></span><span><span><span>+matchOne (f:fs) = do
</span></span></span><span><span><span>+    mb &lt;- maybeMatch f
</span></span></span><span><span><span>+    case mb of
</span></span></span><span><span><span>+        Nothing -&gt; matchOne fs
</span></span></span><span><span><span>+        Just x -&gt; return x
</span></span></span><span><span><span></span>
</span></span><span><span> matchAll :: [MatchFn a] -&gt; MatchFn [a]
</span></span><span><span><span>--- match every function in list (sequentially), returning their results, else Nothing
</span></span></span><span><span><span>-matchAll fns (idm, toks) = chFst (reverse) . foldl try (Just ([], toks)) $ fns
</span></span></span><span><span><span>-    where try Nothing _ = Nothing
</span></span></span><span><span><span>-          try (Just (rs, ts)) f = case f (idm, ts) of
</span></span></span><span><span><span>-              Just (r, ts&#39;) -&gt; Just(r:rs, ts&#39;)
</span></span></span><span><span><span>-              _ -&gt; Nothing
</span></span></span><span><span><span></span><span>+matchAll [] = return []
</span></span></span><span><span><span>+matchAll (f:fs) = do
</span></span></span><span><span><span>+    a &lt;- f
</span></span></span><span><span><span>+    as &lt;- matchAll fs
</span></span></span><span><span><span>+    return $ a:as
</span></span></span><span><span><span></span>
</span></span><span><span> -- ... etc.
</span></span><span><span>
</span></span><span><span> matchT2 :: (MatchFn a, MatchFn b) -&gt; MatchFn (a, b)
</span></span><span><span><span>-matchT2 (fa, fb) (idm, ts) = case fa (idm, ts) of
</span></span></span><span><span><span>-    Nothing -&gt; Nothing
</span></span></span><span><span><span>-    Just (a, ts&#39;) -&gt; case fb (idm, ts&#39;) of
</span></span></span><span><span><span>-        Nothing -&gt; Nothing
</span></span></span><span><span><span>-        Just (b, ts&#39;&#39;) -&gt; Just ((a, b), ts&#39;&#39;)
</span></span></span><span><span><span></span><span>+matchT2 (fa, fb) = do
</span></span></span><span><span><span>+    a &lt;- fa
</span></span></span><span><span><span>+    b &lt;- fb
</span></span></span><span><span><span>+    return (a, b)
</span></span></span><span><span><span></span>
</span></span><span><span> -- .. etc.
</span></span><span><span>
</span></span><span><span> parseOpOrFn :: MatchFn (Operator, FnTreeNode)
</span></span><span><span> parseOpOrFn = matchOne [
</span></span><span><span><span>-        chFst (\_ -&gt; (oReduce, FnLeafFn fReplicate)) . matchCh &#39;/&#39;,
</span></span></span><span><span><span>-        chFst (\_ -&gt; (oScan, FnLeafFn fExpand)) . matchCh &#39;\\&#39;,
</span></span></span><span><span><span>-        chFst (\_ -&gt; (oReduceFirst, FnLeafFn fReplicateFirst)) . matchCh &#39;⌿&#39;,
</span></span></span><span><span><span>-        chFst (\_ -&gt; (oScanFirst, FnLeafFn fExpandFirst)) . matchCh &#39;⍀&#39;
</span></span></span><span><span><span></span><span>+        (\_ -&gt; (oReduce, FnLeafFn fReplicate)) &lt;$&gt; matchCh &#39;/&#39;,
</span></span></span><span><span><span>+        (\_ -&gt; (oScan, FnLeafFn fExpand)) &lt;$&gt; matchCh &#39;\\&#39;,
</span></span></span><span><span><span>+        (\_ -&gt; (oReduceFirst, FnLeafFn fReplicateFirst)) &lt;$&gt; matchCh &#39;⌿&#39;,
</span></span></span><span><span><span>+        (\_ -&gt; (oScanFirst, FnLeafFn fExpandFirst)) &lt;$&gt; matchCh &#39;⍀&#39;
</span></span></span><span><span><span></span>     ]
</span></span><span><span>
</span></span><span><span> parseArr :: MatchFn ArrTreeNode -- parse an entire literal array
</span></span><span><span><span>-parseArr = chFst (_roll) . matchT2 (
</span></span></span><span><span><span></span><span>+parseArr = (_roll) &lt;$&gt; matchT2 (
</span></span></span><span><span><span></span>         parseArrComp,
</span></span><span><span><span>-        chFst (concat) . matchMax [ matchOne [
</span></span></span><span><span><span>-            chFst (Left) . parseArrComp,
</span></span></span><span><span><span>-            chFst (\(_, il, _) -&gt; Right il) . matchT3 (
</span></span></span><span><span><span></span><span>+        (concat) &lt;$&gt; matchMax [ matchOne [
</span></span></span><span><span><span>+            (Left) &lt;$&gt; parseArrComp,
</span></span></span><span><span><span>+            (\(_, il, _) -&gt; Right il) &lt;$&gt; matchT3 (
</span></span></span><span><span><span></span>                 matchCh &#39;[&#39;,
</span></span><span><span>                 parseIdxList,
</span></span><span><span>                 matchCh &#39;]&#39;
</span></span><span><span>             )
</span></span><span><span>         ]]
</span></span><span><span>     )
</span></span><span><span>
</span></span><span><span> -- .. etc.
</span></span></code></pre></div><p>Evaluating <strong><code>mzero</code></strong> in the monad at any time causes the internal function to unconditionally return Nothing (effectively short-circuit).
This behavior comes from <strong><code>MaybeT</code></strong>.</p><p>The new version of parseDerFn:</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>parseDerFn</span> <span>=</span> matchOne [_parseOpExpr, parseFn]
</span></span><span><span>    <span>where</span> _parseOpExpr <span>=</span> <span>do</span>
</span></span><span><span>              lhs <span>&lt;-</span> _parseArg
</span></span><span><span>              otn <span>&lt;-</span> parseOp
</span></span><span><span>              _parseOpExprRec lhs otn
</span></span><span><span>          _parseArg <span>=</span> matchOne [parseFn, <span>FnLeafArr</span> <span>&lt;$&gt;</span> parseArr]
</span></span><span><span>          _parseOpExprRec <span>::</span> <span>FnTreeNode</span> <span>-&gt;</span> <span>OpTreeNode</span> <span>-&gt;</span> <span>MatchFn</span> <span>FnTreeNode</span>
</span></span><span><span>          _parseOpExprRec lhs otn <span>=</span> <span>do</span>
</span></span><span><span>              df <span>&lt;-</span> <span>case</span> unwrapOpTree otn <span>of</span>
</span></span><span><span>                        (<span>MonOp</span> <span>_</span> <span>_</span>) <span>-&gt;</span> return <span>$</span> <span>FnInternalMonOp</span> otn lhs
</span></span><span><span>                        (<span>DyadOp</span> <span>_</span> <span>_</span>) <span>-&gt;</span> <span>do</span> rhs <span>&lt;-</span> _parseArg
</span></span><span><span>                                           return <span>$</span> <span>FnInternalDyadOp</span> otn lhs rhs
</span></span><span><span>              mb <span>&lt;-</span> maybeMatch parseOp
</span></span><span><span>              <span>case</span> mb <span>of</span>
</span></span><span><span>                   <span>Nothing</span> <span>-&gt;</span> return <span>$</span> df
</span></span><span><span>                   (<span>Just</span> otn2) <span>-&gt;</span> _parseOpExprRec df otn2</span></span></code></pre></div><h3 id="parser-version-4-applicative">Parser, Version 4 (+Applicative)</h3><p>My favorite part about Haskell: realizing a built-in function does precisely what you want.</p><p>It turns out that, <a href="https://wiki.haskell.org/Functor-Applicative-Monad_Proposal" target="_blank">circa 2014</a>, all Monads in Haskell are also <a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Control-Applicative.html" target="_blank">Applicative Functors</a>.
<strong><code>(&lt;*&gt;)</code></strong>, <strong><code>(&lt;*)</code></strong>, and <strong><code>(*&gt;)</code></strong> remove the need for the <strong><code>MatchT</code></strong> functions, and the vast majority of lambdas (typically as the LHS’s of <strong><code>&lt;$&gt;</code></strong>).</p><div><pre tabindex="0"><code data-lang="diff"><span><span> parseDerArr :: MatchFn ArrTreeNode
</span></span><span><span> parseDerArr = matchOne [
</span></span><span><span>         parseArrAss,
</span></span><span><span><span>-        (\(f, da) -&gt; ArrInternalMonFn f da) &lt;$&gt; matchT2 (parseDerFn, parseDerArr),
</span></span></span><span><span><span>-        (\(lhs, f, rhs) -&gt; ArrInternalDyadFn f lhs rhs) &lt;$&gt; matchT3 (
</span></span></span><span><span><span>-            parseArr,
</span></span></span><span><span><span>-            parseDerFn,
</span></span></span><span><span><span>-            parseDerArr
</span></span></span><span><span><span>-        ),
</span></span></span><span><span><span></span><span>+        ArrInternalMonFn &lt;$&gt; parseDerFn &lt;*&gt; parseDerArr,
</span></span></span><span><span><span>+        (flip ArrInternalDyadFn) &lt;$&gt; parseArr &lt;*&gt; parseDerFn &lt;*&gt; parseDerArr,
</span></span></span><span><span><span></span>         parseArr
</span></span><span><span>     ]
</span></span><span><span>
</span></span><span><span> parseArrAss :: MatchFn ArrTreeNode
</span></span><span><span> parseArrAss = matchOne [
</span></span><span><span><span>-        (\(id, _, da) -&gt; ArrInternalAssignment id da) &lt;$&gt; matchT3 (
</span></span></span><span><span><span>-            matchId,
</span></span></span><span><span><span>-            matchCh &#39;←&#39;,
</span></span></span><span><span><span>-            parseDerArr
</span></span></span><span><span><span>-        ),
</span></span></span><span><span><span>-        (\(id, df, _, da) -&gt; ArrInternalModAssignment id df da) &lt;$&gt; matchT4 (
</span></span></span><span><span><span>-            matchId,
</span></span></span><span><span><span>-            parseDerFn,
</span></span></span><span><span><span>-            matchCh &#39;←&#39;,
</span></span></span><span><span><span>-            parseDerArr
</span></span></span><span><span><span>-        )
</span></span></span><span><span><span></span><span>+        ArrInternalAssignment &lt;$&gt; matchId &lt;*&gt; (matchCh &#39;←&#39; *&gt; parseDerArr),
</span></span></span><span><span><span>+        ArrInternalModAssignment &lt;$&gt; matchId &lt;*&gt; parseDerFn &lt;*&gt; (matchCh &#39;←&#39; *&gt; parseDerArr)
</span></span></span><span><span><span></span>     ]
</span></span><span><span>
</span></span><span><span> -- ... etc.
</span></span></code></pre></div><p>Version 4 is over 100 lines shorter than version 3.</p><h2 id="evaluation">Evaluation</h2><p>This project was relatively large in scope (at least in comparison to what I’m used to), so there are a lot of nuances in the evaluation of the syntax trees.
I’ve picked a few of the more-interesting ones to highlight.</p><h3 id="functions-as-data">Functions as Data</h3><p>APL makes combination of functions very natural; adjacent functions and operators alone form trees (even before application to arrays)<sup id="fnref:19"><a href="#fn:19" role="doc-noteref">19</a></sup>.</p><p>For example, here’s the tree for the function <strong><code>h2n</code></strong> (from an earlier example):</p><pre tabindex="0"><code>    c2n ← &#39;23456789TJQKA&#39;∘⍳
    classify ← (5-≢⍤∪),(⌈/(+/∘.=⍨)),((5≡∪)×(⌈/c2n))
    h2n ← 13⊥classify,(¯1∘+c2n)
    h2n
 ┌──┼────────────┐
 13 ⊥ ┌──────────┼────────────────────────┐
  ┌───┼────────┐ ,                   ┌────┴─────┐
┌─┼─┐ ,    ┌───┼───────┐             ∘          ∘
5 - ⍤    ┌─┴─┐ ,   ┌───┼─────┐      ┌┴─┐ ┌──────┴──────┐
   ┌┴┐   / ┌─┴─┐ ┌─┼─┐ × ┌───┴────┐ ¯1 + 23456789TJQKA ⍳
   ≢ ∪ ┌─┘ /   ⍨ 5 ≡ ∪   /        ∘
       ⌈ ┌─┘ ┌─┘       ┌─┘ ┌──────┴──────┐
         +   ∘.        ⌈   23456789TJQKA ⍳
           ┌─┘
           =
</code></pre><p><sup id="fnref:20"><a href="#fn:20" role="doc-noteref">20</a></sup></p><p>Since functions are higher-order in Haskell, it’s natural to store them as normal data.
Thus, upon evaluation (in this case, evaluation happens when <code>h2n</code> is assigned to<sup id="fnref:21"><a href="#fn:21" role="doc-noteref">21</a></sup>), the variable <strong><code>h2n</code></strong> no longer has access to the syntax tree, it only holds a primitive haskell function, a string which represents the scrapped tree, and a few other values describing the behavior of the function.</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>type</span> <span>FuncM</span> <span>=</span> <span>Array</span> <span>-&gt;</span> <span>StateT</span> <span>IdMap</span> <span>IO</span> <span>Array</span>
</span></span><span><span><span>type</span> <span>FuncD</span> <span>=</span> <span>Array</span> <span>-&gt;</span> <span>FuncM</span>
</span></span><span><span>
</span></span><span><span><span>data</span> <span>Function</span> <span>=</span> <span>MonFn</span> <span>FnInfoM</span> <span>FuncM</span>
</span></span><span><span>              <span>|</span> <span>DyadFn</span> <span>FnInfoD</span> <span>FuncD</span>
</span></span><span><span>              <span>|</span> <span>AmbivFn</span> <span>FnInfoA</span> <span>FuncM</span> <span>FuncD</span>
</span></span><span><span>
</span></span><span><span><span>-- &#34;function tree&#34;: a tree that makes up a derived function:</span>
</span></span><span><span><span>-- the internal nodes are operators, and the leaves are functions or (derived) arrays</span>
</span></span><span><span><span>data</span> <span>FnTreeNode</span> <span>=</span> <span>FnLeafFn</span> <span>Function</span>
</span></span><span><span>                <span>|</span> <span>FnLeafVar</span> <span>String</span>
</span></span><span><span>                <span>|</span> <span>FnLeafArr</span> <span>ArrTreeNode</span>
</span></span><span><span>                <span>|</span> <span>FnInternalMonOp</span> <span>OpTreeNode</span> <span>FnTreeNode</span>
</span></span><span><span>                <span>|</span> <span>FnInternalDyadOp</span> <span>OpTreeNode</span> <span>FnTreeNode</span> <span>FnTreeNode</span>
</span></span><span><span>                <span>|</span> <span>FnInternalAtop</span> <span>FnTreeNode</span> <span>FnTreeNode</span>
</span></span><span><span>                <span>|</span> <span>FnInternalFork</span> <span>FnTreeNode</span> <span>FnTreeNode</span> <span>FnTreeNode</span>
</span></span><span><span>                <span>|</span> <span>FnInternalAssignment</span> <span>String</span> <span>FnTreeNode</span>
</span></span><span><span>                <span>|</span> <span>FnInternalQuadAssignment</span> <span>FnTreeNode</span>
</span></span><span><span>                <span>|</span> <span>FnInternalAxisSpec</span> <span>FnTreeNode</span> <span>ArrTreeNode</span>
</span></span><span><span>                <span>|</span> <span>FnInternalDummyNode</span> <span>FnTreeNode</span>
</span></span><span><span>
</span></span><span><span><span>evalFnTree</span> <span>::</span> <span>FnTreeNode</span> <span>-&gt;</span> <span>StateT</span> <span>IdMap</span> <span>IO</span> (<span>Either</span> <span>Array</span> <span>Function</span>)</span></span></code></pre></div><h3 id="practical-typeclasses">Practical Typeclasses</h3><p>Like the parser, evaluation uses monads to handle state.
Since any arbitrary function might have full control over the program state, in order to have a universal function type, that type (<strong><code>Function</code></strong> (see above)) must be impure<sup id="fnref:22"><a href="#fn:22" role="doc-noteref">22</a></sup>.</p><p>The majority of built-in <strong><code>Functions</code></strong> don’t touch the global state, and the ones that do usually only use it for a very narrow purpose.
I wanted a mechanism that allowed me to define these <strong><code>Functions</code></strong> with maximally constraining types, yet to easily convert them into the full (non-constrained) monad (<strong><code>EvalM</code></strong>) without causing a combinatorial explosion of helper functions.
I used the typeclass <strong><code>SubEvalM</code></strong> to do this.</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>{- SubEvalM (subset of EvalM): typeclass for wrapper monads -}</span>
</span></span><span><span>
</span></span><span><span><span>type</span> <span>EvalM</span> <span>=</span> <span>StateT</span> <span>IdMap</span> <span>IO</span>
</span></span><span><span>
</span></span><span><span><span>class</span> (<span>Monad</span> m) <span>=&gt;</span> <span>SubEvalM</span> m <span>where</span>
</span></span><span><span>    toEvalM <span>::</span> m a <span>-&gt;</span> <span>EvalM</span> a
</span></span><span><span>
</span></span><span><span><span>instance</span> <span>SubEvalM</span> <span>Identity</span> <span>where</span>
</span></span><span><span>    toEvalM <span>=</span> return <span>.</span> runIdentity
</span></span><span><span>
</span></span><span><span><span>newtype</span> <span>IdxOriginM</span> a <span>=</span> <span>IdxOriginM</span> { unIdxOriginM <span>::</span> <span>Reader</span> <span>Int</span> a }
</span></span><span><span>    <span>deriving</span> (<span>Functor</span>, <span>Applicative</span>, <span>Monad</span>, <span>MonadReader</span> <span>Int</span>) via (<span>Reader</span> <span>Int</span>)
</span></span><span><span>
</span></span><span><span><span>instance</span> <span>SubEvalM</span> <span>IdxOriginM</span> <span>where</span>
</span></span><span><span>    toEvalM iom <span>=</span> <span>do</span>
</span></span><span><span>        idm <span>&lt;-</span> get
</span></span><span><span>        <span>let</span> iO <span>=</span> <span>case</span> mapLookup <span>&#34;⎕IO&#34;</span> idm <span>of</span>
</span></span><span><span>                  <span>Just</span> (<span>IdArr</span> a)
</span></span><span><span>                      <span>|</span> <span>ScalarNum</span> n <span>&lt;-</span> a `at` <span>0</span> <span>-&gt;</span> <span>Prelude</span><span>.</span>floor <span>$</span> n
</span></span><span><span>                  <span>Just</span> <span>_</span> <span>-&gt;</span> undefined <span>-- unexpected val for ⎕IO</span>
</span></span><span><span>                  <span>_</span> <span>-&gt;</span> undefined <span>-- no val for ⎕IO</span>
</span></span><span><span>        return <span>.</span> (flip runReader) iO <span>.</span> unIdxOriginM <span>$</span> iom
</span></span><span><span>
</span></span><span><span><span>newtype</span> <span>RandAndIoM</span> a <span>=</span> <span>RandAndIoM</span> { unRandomAndIoM <span>::</span> <span>StateTStrict</span><span>.</span><span>StateT</span> <span>StdGen</span> (<span>Reader</span> <span>Int</span>) a }
</span></span><span><span>    <span>deriving</span> (<span>Functor</span>, <span>Applicative</span>, <span>Monad</span>, <span>MonadReader</span> <span>Int</span>, <span>MonadState</span> <span>StdGen</span>) via <span>StateTStrict</span><span>.</span><span>StateT</span> <span>StdGen</span> (<span>Reader</span> <span>Int</span>)
</span></span><span><span>
</span></span><span><span><span>instance</span> <span>SubEvalM</span> <span>RandAndIoM</span> <span>where</span>
</span></span><span><span>    toEvalM rm <span>=</span> <span>do</span>
</span></span><span><span>        gen <span>&lt;-</span> lift <span>$</span> newStdGen
</span></span><span><span>        toEvalM <span>.</span> <span>IdxOriginM</span> <span>.</span> runStateGenT_ gen <span>$</span> <span>\</span><span>_</span> <span>-&gt;</span> unRandomAndIoM rm
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>{- Monad Wrappers -}</span>
</span></span><span><span>
</span></span><span><span><span>mkMonFn</span> <span>::</span> <span>SubEvalM</span> m <span>=&gt;</span> <span>FnInfoM</span> <span>-&gt;</span> (<span>Array</span> <span>-&gt;</span> m <span>Array</span>) <span>-&gt;</span> <span>Function</span>
</span></span><span><span><span>mkMonFn</span> i f <span>=</span> <span>MonFn</span> i (<span>\</span>a <span>-&gt;</span> toEvalM <span>$</span> f a)
</span></span><span><span>
</span></span><span><span><span>mkDyadFn</span> <span>::</span> <span>SubEvalM</span> m <span>=&gt;</span> <span>FnInfoD</span> <span>-&gt;</span> (<span>Array</span> <span>-&gt;</span> <span>Array</span> <span>-&gt;</span> m <span>Array</span>) <span>-&gt;</span> <span>Function</span>
</span></span><span><span><span>mkDyadFn</span> i f <span>=</span> <span>DyadFn</span> i (<span>\</span>a b <span>-&gt;</span> toEvalM <span>$</span> f a b)
</span></span><span><span>
</span></span><span><span><span>mkAmbivFn</span> <span>::</span> (<span>SubEvalM</span> m0, <span>SubEvalM</span> m1) <span>=&gt;</span> <span>FnInfoA</span> <span>-&gt;</span> (<span>Array</span> <span>-&gt;</span> m0 <span>Array</span>) <span>-&gt;</span> (<span>Array</span> <span>-&gt;</span> <span>Array</span> <span>-&gt;</span> m1 <span>Array</span>) <span>-&gt;</span> <span>Function</span>
</span></span><span><span><span>mkAmbivFn</span> ia fm fd <span>=</span> <span>AmbivFn</span> ia (<span>\</span>a <span>-&gt;</span> toEvalM <span>$</span> fm a) (<span>\</span>a b <span>-&gt;</span> toEvalM <span>$</span> fd a b)
</span></span><span><span>
</span></span><span><span><span>-- (mkMonOp, ... etc.)</span>
</span></span><span><span>
</span></span><span><span><span>{- Pure Wrappers -}</span>
</span></span><span><span>
</span></span><span><span><span>pureMonFn</span> <span>::</span> <span>FnInfoM</span> <span>-&gt;</span> (<span>Array</span> <span>-&gt;</span> <span>Array</span>) <span>-&gt;</span> <span>Function</span>
</span></span><span><span><span>pureMonFn</span> i f <span>=</span> mkMonFn i (<span>Identity</span> <span>.</span> f)
</span></span><span><span>
</span></span><span><span><span>pureDyadFn</span> <span>::</span> <span>FnInfoD</span> <span>-&gt;</span> (<span>Array</span> <span>-&gt;</span> <span>Array</span> <span>-&gt;</span> <span>Array</span>) <span>-&gt;</span> <span>Function</span>
</span></span><span><span><span>pureDyadFn</span> i f <span>=</span> mkDyadFn i (<span>Identity</span> <span>.:</span> f)
</span></span><span><span>
</span></span><span><span><span>pureAmbivFn</span> <span>::</span> <span>FnInfoA</span> <span>-&gt;</span> (<span>Array</span> <span>-&gt;</span> <span>Array</span>) <span>-&gt;</span> (<span>Array</span> <span>-&gt;</span> <span>Array</span> <span>-&gt;</span> <span>Array</span>) <span>-&gt;</span> <span>Function</span>
</span></span><span><span><span>pureAmbivFn</span> ia fm fd <span>=</span> mkAmbivFn ia (<span>Identity</span> <span>.</span> fm) (<span>Identity</span> <span>.:</span> fd)
</span></span><span><span>
</span></span><span><span><span>-- (pureMonOp, ... etc.)</span></span></span></code></pre></div><h3 id="selective-assignment">Selective Assignment</h3><p>APL has a feature called “selective assignment” where the left-hand-side of an assignment can be an expression, so long as it only uses (pre-verified) functions that solely permute/select items of the argument array.
For example:</p><pre tabindex="0"><code>    x ← 2 2⍴⍳4
    x
1 2
3 4
    (,⌽x) ← ⍳4 ⍝ assign ⍳4 to the ravel (,) of
    x          ⍝ the reversed (along the last axis) (⌽) x
2 1
4 3
</code></pre><p>At first glance, this seems like implementing this will require a re-implementation of each selectable function, which can be called to determine which cells of the variable are selected, and their shape.
However, after making the above assumption (all selectable functions do not mutate the cells of their argument), the selected array (x, in the above example) can simply be replaced by an array of the same shape whose cells are the indices of x (⍳⍴x), then, after applying the selecting functions, the result will be some permutation/selection of the indices of (⍳⍴x), which can then be assigned to.
So, for the above example, we have</p><pre tabindex="0"><code>    x ← 2 2⍴⍳4
    x
1 2
3 4
    ⍴x
2 2
    ⍳⍴x
┌───┬───┐
│1 1│1 2│
├───┼───┤
│2 1│2 2│
└───┴───┘
    ⌽⍳⍴x
┌───┬───┐
│1 2│1 1│
├───┼───┤
│2 2│2 1│
└───┴───┘
    ,⌽⍳⍴x
┌───┬───┬───┬───┐
│1 2│1 1│2 2│2 1│
└───┴───┴───┴───┘
    x[,⌽⍳⍴x]
2 1 4 3
    x[,⌽⍳⍴x] ← ⍳4
    x
2 1
4 3
</code></pre><h3 id="higher-dimensional-arrays-its-just-indexing">Higher-Dimensional Arrays: It’s Just Indexing</h3><p>One of the hardest aspects of implementing the built-in functions/operators was making them work on higher-dimensional arrays.
The majority APL primitives are trivially implemented on vectors and scalars, but their behavior becomes much harder to understand when they operate on n-dimensional arrays.</p><p>For example, dyadic (<strong><code>,</code></strong>) ([con]catenate).
Just put the two arrays together, no problem, right?</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>catenate</span> <span>::</span> <span>Double</span> <span>-&gt;</span> <span>Array</span> <span>-&gt;</span> <span>Array</span> <span>-&gt;</span> <span>IdxOriginM</span> <span>Array</span>
</span></span><span><span><span>catenate</span> ax x y
</span></span><span><span>    <span>|</span> isIntegral ax <span>=</span> ask <span>&gt;&gt;=</span> <span>\</span>iO <span>-&gt;</span> <span>let</span> ax&#39; <span>=</span> (<span>Prelude</span><span>.</span>floor ax) <span>-</span> iO <span>+</span> <span>1</span>
</span></span><span><span>                                     <span>in</span> return <span>$</span> _catenate ax&#39;
</span></span><span><span>    <span>|</span> otherwise <span>=</span> ask <span>&gt;&gt;=</span> <span>\</span>iO <span>-&gt;</span> <span>let</span> ax&#39; <span>=</span> (<span>Prelude</span><span>.</span>ceiling ax) <span>-</span> iO
</span></span><span><span>                                 <span>in</span> return <span>$</span> _laminate ax&#39;
</span></span><span><span>    <span>where</span> _catenate ax&#39;
</span></span><span><span>              <span>|</span> ax&#39; <span>&lt;=</span> <span>0</span> <span>||</span> ax&#39; <span>&gt;</span> rank <span>=</span> throw <span>.</span> <span>RankError</span> <span>$</span> <span>&#34;(,): invalid axis&#34;</span>
</span></span><span><span>              <span>|</span> x <span>==</span> zilde <span>=</span> y
</span></span><span><span>              <span>|</span> y <span>==</span> zilde <span>=</span> x
</span></span><span><span>              <span>|</span> (shape&#39;&#39; x&#39;) <span>/=</span> (shape&#39;&#39; y&#39;) <span>=</span> throw <span>.</span> <span>LengthError</span> <span>$</span> <span>&#34;(,): mismatched argument shapes&#34;</span>
</span></span><span><span>              <span>|</span> otherwise <span>=</span> zipVecsAlongAxis ax&#39;&#39; ax&#39;&#39; ax&#39;&#39; (<span>++</span>) x&#39; y&#39;
</span></span><span><span>              <span>where</span> (x&#39;, y&#39;) <span>=</span> _rankMorph (x, y)
</span></span><span><span>                    rank <span>=</span> arrRank x&#39;
</span></span><span><span>                    _rankMorph (a, b)
</span></span><span><span>                        <span>|</span> shape a <span>==</span> [<span>1</span>] <span>&amp;&amp;</span> arrNetSize b <span>&gt;</span> <span>0</span> <span>=</span> (shapedArrFromList (shape&#39;1 b) <span>$</span> <span>Prelude</span><span>.</span>replicate (foldr (<span>*</span>) <span>1</span> <span>$</span> shape&#39;1 b) (a `at` <span>0</span>), b)
</span></span><span><span>                        <span>|</span> shape b <span>==</span> [<span>1</span>] <span>&amp;&amp;</span> arrNetSize a <span>&gt;</span> <span>0</span> <span>=</span> (a, shapedArrFromList (shape&#39;1 a) <span>$</span> <span>Prelude</span><span>.</span>replicate (foldr (<span>*</span>) <span>1</span> <span>$</span> shape&#39;1 a) (b `at` <span>0</span>))
</span></span><span><span>                        <span>|</span> arrRank a <span>==</span> arrRank b <span>=</span> (a, b)
</span></span><span><span>                        <span>|</span> arrRank a <span>==</span> arrRank b <span>+</span> <span>1</span> <span>&amp;&amp;</span> ax&#39; <span>&lt;=</span> arrRank a <span>=</span> (a, b {shape <span>=</span> take _ax&#39; (shape b) <span>++</span> [<span>1</span>] <span>++</span> drop _ax&#39; (shape b)})
</span></span><span><span>                        <span>|</span> arrRank a <span>+</span> <span>1</span> <span>==</span> arrRank b <span>&amp;&amp;</span> ax&#39; <span>&lt;=</span> arrRank b <span>=</span> (a {shape <span>=</span> take (_ax&#39; <span>+</span> <span>1</span>) (shape a) <span>++</span> [<span>1</span>] <span>++</span> drop (_ax&#39; <span>+</span> <span>1</span>) (shape a)}, b)
</span></span><span><span>                        <span>|</span> otherwise <span>=</span> throw <span>.</span> <span>RankError</span> <span>$</span> <span>&#34;(,): mismatched argument ranks&#34;</span>
</span></span><span><span>                        <span>where</span> _ax&#39; <span>=</span> ax&#39; <span>-</span> <span>1</span>
</span></span><span><span>                    shape&#39;1 a <span>=</span> take (ax&#39; <span>-</span> <span>1</span>) (shape a) <span>++</span> [<span>1</span>] <span>++</span> drop ax&#39; (shape a)
</span></span><span><span>                    shape&#39;&#39; a <span>=</span> take (ax&#39;&#39; <span>-</span> <span>1</span>) (shape a) <span>++</span> drop ax&#39;&#39; (shape a)
</span></span><span><span>                    ax&#39;&#39; <span>=</span> <span>if</span> arrRank x&#39; <span>==</span> arrRank x <span>+</span> <span>1</span> <span>then</span> ax&#39; <span>+</span> <span>1</span> <span>else</span> ax&#39;
</span></span><span><span>          _laminate ax&#39;
</span></span><span><span>              <span>|</span> ax&#39; <span>&lt;</span> <span>0</span> <span>||</span> ax&#39; <span>&gt;</span> rank <span>=</span> throw <span>.</span> <span>RankError</span> <span>$</span> <span>&#34;(,): invalid axis&#34;</span>
</span></span><span><span>              <span>|</span> (shape x&#39;) <span>/=</span> (shape y&#39;) <span>=</span> throw <span>.</span> <span>LengthError</span> <span>$</span> <span>&#34;(,): mismatched argument shapes&#34;</span>
</span></span><span><span>              <span>|</span> otherwise <span>=</span> unAlongAxis (ax&#39; <span>+</span> <span>1</span>) [x&#39;, y&#39;]
</span></span><span><span>              <span>where</span> (x&#39;, y&#39;) <span>=</span> _rankMorph (x, y)
</span></span><span><span>                    rank <span>=</span> arrRank x&#39;
</span></span><span><span>                    _rankMorph (a, b)
</span></span><span><span>                        <span>|</span> shape a <span>==</span> [<span>1</span>] <span>&amp;&amp;</span> arrNetSize b <span>&gt;</span> <span>0</span> <span>=</span> (shapedArrFromList (shape b) <span>$</span> <span>Prelude</span><span>.</span>replicate (arrNetSize b) (a `at` <span>0</span>), b)
</span></span><span><span>                        <span>|</span> shape b <span>==</span> [<span>1</span>] <span>&amp;&amp;</span> arrNetSize a <span>&gt;</span> <span>0</span> <span>=</span> (a, shapedArrFromList (shape a) <span>$</span> <span>Prelude</span><span>.</span>replicate (arrNetSize a) (b `at` <span>0</span>))
</span></span><span><span>                        <span>|</span> shape a <span>==</span> shape b <span>=</span> (a, b)
</span></span><span><span>                        <span>|</span> otherwise <span>=</span> throw <span>.</span> <span>RankError</span> <span>$</span> <span>&#34;(,): mismatched argument ranks&#34;</span></span></span></code></pre></div><p>The majority of this code is actually just edge-cases (which are difficult in their own right), but the key functions to note are <strong><code>zipVecsAlongAxis</code></strong> and <strong><code>unAlongAxis</code></strong> (which are applied after the edge-cases are resolved).
All primitives functions that operate on higher-dimensional arrays can be expressed using a handful of helper functions.
All of those helpers are built on top of three core functions.</p><div><pre tabindex="0"><code data-lang="haskell"><span><span><span>alongAxis</span> <span>::</span> <span>Int</span> <span>-&gt;</span> <span>Array</span> <span>-&gt;</span> [<span>Array</span>]
</span></span><span><span><span>alongAxis</span> ax a
</span></span><span><span>    <span>|</span> ax <span>-</span> _iO <span>&gt;=</span> (length <span>.</span> shape <span>$</span> a) <span>=</span> throw <span>$</span> <span>RankError</span> <span>&#34;invalid axis&#34;</span>
</span></span><span><span>    <span>|</span> (length <span>.</span> shape <span>$</span> a) <span>==</span> <span>0</span> <span>=</span> <span>[]</span>
</span></span><span><span>    <span>|</span> arrNetSize a <span>==</span> <span>0</span> <span>=</span> <span>[]</span>
</span></span><span><span>    <span>|</span> otherwise <span>=</span> map (subarrayAt) [<span>0</span><span>..</span>(n <span>-</span> <span>1</span>)]
</span></span><span><span>        <span>where</span> n <span>=</span> (shape a) <span>!!</span> (ax <span>-</span> _iO)
</span></span><span><span>              shape&#39; <span>=</span> <span>if</span> (length <span>.</span> shape <span>$</span> a) <span>==</span> <span>1</span>
</span></span><span><span>                       <span>then</span> [<span>1</span>]
</span></span><span><span>                       <span>else</span> take (ax <span>-</span> _iO) (shape a) <span>++</span> drop (ax <span>-</span> _iO <span>+</span> <span>1</span>) (shape a)
</span></span><span><span>              sz <span>=</span> arrNetSize a
</span></span><span><span>              subarrayAt i <span>=</span> shapedArrFromList shape&#39; <span>.</span> map (arrIndex a) <span>$</span> indicesAt i
</span></span><span><span>              indicesAt i <span>=</span>  map (<span>\</span>is <span>-&gt;</span> take (ax <span>-</span> _iO) is <span>++</span> [i] <span>++</span> drop (ax <span>-</span> _iO) is) <span>$</span> map (calcIndex) [<span>0</span><span>..</span>(sz `div` n <span>-</span> <span>1</span>)]
</span></span><span><span>              indexMod <span>=</span> tail <span>.</span> scanr (<span>*</span>) <span>1</span> <span>$</span> shape&#39;
</span></span><span><span>              calcIndex i <span>=</span> map (<span>\</span>(e, m) <span>-&gt;</span> i `div` m `mod` e) <span>$</span> zip shape&#39; indexMod
</span></span><span><span>              _iO <span>=</span> <span>1</span> <span>-- axis supplied is with respect to _iO = 1, not actual ⎕IO</span>
</span></span><span><span>
</span></span><span><span><span>alongRank</span> <span>::</span> <span>Int</span> <span>-&gt;</span> <span>Array</span> <span>-&gt;</span> <span>Array</span>
</span></span><span><span><span>alongRank</span> r a
</span></span><span><span>    <span>|</span> foldr (<span>*</span>) <span>1</span> (shape a) <span>==</span> <span>0</span> <span>=</span> zilde
</span></span><span><span>    <span>|</span> n <span>&lt;=</span> <span>0</span> <span>=</span> listToArr [<span>ScalarArr</span> a]
</span></span><span><span>    <span>|</span> n <span>&gt;=</span> (length <span>$</span> shape a) <span>=</span> a
</span></span><span><span>    <span>|</span> otherwise <span>=</span> shapedArrFromList outerShape <span>.</span> map (<span>ScalarArr</span> <span>.</span> shapedArrFromList innerShape) <span>.</span> groupsOf groupSz <span>.</span> arrToList <span>$</span> a
</span></span><span><span>        <span>where</span> outerShape <span>=</span> take n <span>$</span> shape a
</span></span><span><span>              innerShape <span>=</span> drop n <span>$</span> shape a
</span></span><span><span>              n <span>=</span> <span>if</span> r <span>&gt;=</span> <span>0</span> <span>then</span> (length <span>$</span> shape a) <span>-</span> r <span>else</span> <span>-</span><span>1</span> <span>*</span> r
</span></span><span><span>              groupSz <span>=</span> foldr (<span>*</span>) <span>1</span> innerShape
</span></span><span><span>
</span></span><span><span><span>arrReorderAxes</span> <span>::</span> [<span>Int</span>] <span>-&gt;</span> <span>Array</span> <span>-&gt;</span> <span>Array</span>
</span></span><span><span><span>arrReorderAxes</span> targetIdxs a
</span></span><span><span>    <span>|</span> length targetIdxs <span>/=</span> (length <span>$</span> shape a) <span>=</span> undefined
</span></span><span><span>    <span>|</span> otherwise <span>=</span> shapedArrFromList shape&#39; vals&#39;
</span></span><span><span>        <span>where</span> shape&#39; <span>=</span> map (foldr min intMax <span>.</span> map snd) <span>.</span> groupBy (on (<span>==</span>) fst) <span>.</span> sortBy (on compare fst) <span>$</span> zip targetIdxs (shape a)
</span></span><span><span>              n <span>=</span> foldr (<span>*</span>) <span>1</span> shape&#39;
</span></span><span><span>              vals&#39; <span>=</span> map ((a`arrIndex`) <span>.</span> calcIndex) [<span>0</span><span>..</span>(n <span>-</span> <span>1</span>)]
</span></span><span><span>              calcIndex i <span>=</span> map ((idxList<span>!!</span>) <span>.</span> (<span>+</span>(<span>-</span><span>1</span>))) targetIdxs
</span></span><span><span>                  <span>where</span> idxList <span>=</span> calcIndex&#39; i
</span></span><span><span>              calcIndex&#39; i <span>=</span> map (<span>\</span>(e, m) <span>-&gt;</span> i `div` m `mod` e) <span>$</span> zip shape&#39; indexMod
</span></span><span><span>              indexMod <span>=</span> tail <span>.</span> scanr (<span>*</span>) <span>1</span> <span>$</span> shape&#39;</span></span></code></pre></div><p>The details of the implementation doesn’t matter so much as the fact that these functions only do two main things:</p><ol><li>Index arithmetic</li><li>Manipulation of shapes (array dimensions)</li></ol><p>That’s all it takes to work with multi-dimensional arrays.</p><h2 id="mimicking-dyalog">Mimicking Dyalog</h2><p><a href="https://www.dyalog.com/" target="_blank">Dyalog</a> APL is the de-facto modern implementation of APL.
This project is heavily based off of Dyalog APL.
All of the syntax and glyphs come directly from Dyalog, and
the behavior of the functions and operators was almost entirely taken/tweaked from the <a href="https://docs.dyalog.com/latest/Dyalog%20APL%20Language%20Reference%20Guide.pdf" target="_blank">Dyalog Reference Guide</a>.</p><p>This was convenient in many ways, because it provided an oracle to test against<sup id="fnref:23"><a href="#fn:23" role="doc-noteref">23</a></sup>, and at any point when I was uncertain of the behavior of something, it gave me a definitive answer, or at least a model which I could analyze to come to my own answer.</p><p>However, attempting to clone Dyalog made the project harder in a lot of ways, namely</p><ul><li>Getting printing of arrays, function trees, and (high-precision, scientific-notation, floating-point) numbers to exactly match Dyalog</li><li>Trying to match Dyalog’s behavior in weird edge-cases</li><li>The sheer generality of many of the glyphs (catenate (above) is a good example of this)</li></ul><p>I ended up making a lot of compromises between what I thought was doable (or even possible: some behavior of Dyalog was seemingly incomprehensible), what seemed the most simple<sup id="fnref:24"><a href="#fn:24" role="doc-noteref">24</a></sup>, and what Dyalog did.</p><p>The following is a (far from complete) laundry-list of discrepancies between my interpreter and Dyalog’s.</p><ul><li>Differing properties:<ul><li>Amount of whitespace when printing arrays with non-zero rank, but with 0 ∊ shape</li><li>Whitespace and some number formatting when printing matrices of real-numbers</li><li>Printing format of arrays as leaves of function trees</li><li>Printing format of arrays as axis specifications</li><li>Printing of dfns/dops (∇)</li><li>Exact rules for sorting order</li><li>Propigation rules for function properties (i.e. identity, ability to select, axis specification) on derived functions</li><li>Fine-grained behavior of execute (⍎) and format (⍕)</li></ul></li><li>In Dyalog, …<ul><li>Variables have nameclasses and weird behavior after reassignment<sup id="fnref:25"><a href="#fn:25" role="doc-noteref">25</a></sup></li><li>Some dops can’t be used inline</li><li>Dyadic operators can’t be in the right-hand-side of assignments</li><li>The default ⍺ can be a function in dops</li></ul></li><li>In my interpreter, …<ul><li>Dops/dfns are not strongly short-circuited: if the condition in a guard is false, the rhs isn’t evaluated, but it is still parsed (in Dyalog, it isn’t parsed)</li><li>Scalars are not 0-rank: they are vectors with a single element (this approach seems more simple<sup id="fnref:26"><a href="#fn:26" role="doc-noteref">26</a></sup>, but it causes some incompatibilities in the behavior of certain functions)</li><li>Arrays with non-1 rank cannot have zero as an element in their shape (Dyalog allows this)</li><li>LCM, GCD, factorial, and binomial only work on integers (Dyalog allows reals and complex numbers)</li><li>The circle function (dyadic ○) only supports 1 2 3, ¯1, ¯2, ¯3</li><li>Dfns cannot <em>modify</em> global variables</li><li>⎕IO can be <em>any integer</em> (not just 0 or 1)</li><li>Axis spec operator is more limited (several functions don’t support it (e.g. ⊂)), it also only takes singleton numbers, never vectors</li><li>Dyadic ⍒/⍋ is limited to vector (not higher-dimensional array) collation sequences</li><li>Reduce can’t take a negative or zero argument on left (window)</li><li>Encode only works on integers</li></ul></li><li>My interpreter does not support …<ul><li>Complex numbers</li><li>Dyadic thorn (⍎) and dyadic hydrant (⍕)</li><li>&amp;, ⌸, ⌺, and ⌹</li><li>Monadic squad (⌷)</li><li>I-Beam (⌶)</li><li>Traditional Functions</li><li>Array prototypes, fill elements other than 0</li><li>Many System Names</li><li>Many other Dyalog features</li></ul></li></ul><h2 id="haskell-the-good-and-the-ugly">Haskell: the Good and the Ugly</h2><h3 id="the-good">The Good</h3><h4 id="the-compiler">The Compiler</h4><p>I am generally a fan of the guarantees the compiler gives, and the Haskell complier has given me more guarantees<sup id="fnref:27"><a href="#fn:27" role="doc-noteref">27</a></sup> than any other I have used.
The time I spent debugging runtime errors in Haskell was significantly smaller in proportion to imperative languages, and there were many times where I was astonished<sup id="fnref:28"><a href="#fn:28" role="doc-noteref">28</a></sup> that my code worked after I fixed the compilation errors.</p><p>That being said, runtime errors still happened, and many of them had similar nature to those in other languages (typically logic errors, or panics). Such errors grew more common and more difficult to debug as the project grew in scale<sup id="fnref:29"><a href="#fn:29" role="doc-noteref">29</a></sup>.</p><p>It was also relatively difficult to get code to compile (and writing code in general) (in comparison to in other languages).
It’s hard to tell how much of this has to do with the fact that I’m new to Haskell, and how much easier it will become over time.
It’s hard to gage my progress over the course of project, because the nature of the problems I’m solving (and their complexity) has fluctuated a lot.
I’ve certainly become more fluent in Haskell, but I’ve continued to battle compilation errors.</p><h4 id="the-libraries">The Libraries</h4><p>The standard libraries have a lot of useful functions.
I made frequent use of Data.List, Control.Monad, and Data.Function, among others.</p><p>Most simple operations you might want to do are often well within reach, and it’s a lot of fun using standard functions to replace boilerplate.</p><h4 id="currying-combinators-tacit">Currying, Combinators, Tacit</h4><p>I probably used these way too much, but they’re a lot of fun.</p><h3 id="the-ugly">The Ugly</h3><h4 id="the-elephant-in-the-room">The Elephant In The Room</h4><p>Haskell is incomprehensible if you haven’t spent time with it (or languages like it).
Functional style alone is probably a big enough gap from imperative to make it difficult<sup id="fnref:30"><a href="#fn:30" role="doc-noteref">30</a></sup>, but combine that with all the category theory and crazy type stuff, and the learning curve becomes a cliff.</p><p>I’m not suggesting that Haskell should be watered down – I see the utility in its more esoteric style – but this doesn’t change the fact that it makes communication (one of the most important aspects of programming) difficult in many situations.</p><h4 id="over-generalization">Over-Generalization</h4><p>Perhaps this is a contradiction (you can’t have your cake and eat it), since I just raved about the benefits of generality, but I found that it goes both ways: generality can be bad in excess.</p><p>My best example of this is the System.Random (and System.Random.Stateful) library: even after I felt like I had a solid grasp on monads and monad transformers, it took me several hours (and even reading some of the source) to comprehend the library<sup id="fnref:31"><a href="#fn:31" role="doc-noteref">31</a></sup> enough to feel comfortable using it<sup id="fnref:32"><a href="#fn:32" role="doc-noteref">32</a></sup>.</p><h4 id="efficiency">Efficiency</h4><p>This goes without saying.
Apparently Haskell’s performance isn’t <em>that bad</em>, but I don’t plan on using Haskell for anything that is remotely performance-sensitive.</p><p>Trying to optimize Haskell code does sound like an interesting problem, but it might be a lost cause.</p><h4 id="laziness">Laziness</h4><p>Generally it doesn’t matter <em>when values are evaluated</em>, so long as you have them when you need them, but since I made excess use of <em>exceptions</em> and <em>undefined</em>’s in this program, understanding laziness became important.</p><p>It’s funny how, when using Haskell, laziness creeps into your program where you don’t expect it.</p><p>After implementing assignment, it took me a while to realize that, if the RHS of an expression threw an error when evaluated, that error wouldn’t show itself until I tried to <em>print</em> the variable to which the value was given. For example:</p><pre tabindex="0"><code>    x ← 1 + &#39;c&#39; ⍝ this statement succeeds
    1 + 2       ⍝ execution continues as normal
3
    y ← x + 1   ⍝ this is fine as well
    y           ⍝ x is only evaluated when the concrete value of y is needed for printing
DOMAIN ERROR: expected number
</code></pre><p>Funnily enough, I thought I fixed this, but after running this example, the current version of the interpreter produces the same result.</p><p>Laziness can be convenient when you want to avoid throwing errors unless absolutely necessary (which is usually the case), but when you want to deliberately throw an error, you must force execution into a single path towards that error.</p><p>This uncertainty of time of evaluation also makes catching errors difficult, because calling <strong><code>catch</code></strong> on the function that throws the error <em>will not necessarily catch that error</em>.
Catch must be called on the function that <em>forces evaluation</em> on that error.
This is something that is hard to trace, and something that types don’t help much with.</p><p>The solution to this is probably to use monads instead of exceptions.</p><h4 id="debugging">Debugging</h4><p>Haskell’s lazy evaluation also makes debugging much harder.
Evaluation is not linear: stepping doesn’t go line-by-line: it jumps around between functions as their values are needed.</p><p>GHCi does have a built-in debugger (which is pretty impressive), but for this reason, it’s not really the most useful.</p><p>As I mentioned earlier, runtime errors are much less prevalent due to strict typing, but when they do arise, this could become an issue.</p></div></div>
  </body>
</html>
