<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://idle.nprescott.com/2020/ray-tracing-in-j.html">Original</a>
    <h1>Ray Tracing in J</h1>
    
    <div id="readability-page-1" class="page">
    <header>
      <a href="https://idle.nprescott.com/index.html">index</a> • <a href="https://idle.nprescott.com/archive.html">post archive</a> • <a href="https://idle.nprescott.com/feed.atom">atom feed
        <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1em" height="1em" viewBox="0 0 8 8">
          <title>syndication feed icon</title>
          <circle cx="1" cy="6.5" r="1" fill="#000"></circle>
          <path d="m 0 4.5 a 3 3 0 0 1 3 3 h 1 a 4 4 0 0 0 -4 -4 z
                   M 0 2.5 a 5 5 0 0 1 5 5 h 1 a 6 6 0 0 0 -6 -6" fill="#000"></path>
        </svg>
      </a>
    </header>

<span>2020-04-18</span>

<p>I&#39;ve been reading up on J and decided another small project was in
order, this time I&#39;ve written a minimal ray tracer.</p>
<h2>Brevity</h2>
<p>J is, perhaps infamously, a terse language. I think it may sometimes
get unfairly discounted for this brevity because of the flavor of the
syntax (namely, ASCII). It can be a little hard to describe, but the
syntax isn&#39;t the hard part of learning J, the jarring parts are a
result of the paradigm differences in array programming. By the time
I&#39;ve started to wrap my head around the very functional, array
oriented style of programming the syntax has started to fall away. At
least in the case of my own code I don&#39;t find the syntax being an
obstacle, I&#39;m curious how this would hold up in the face of someone
else&#39;s code.</p>
<h3>Tacit Verbs</h3>
<p>One piece of syntax that bears explaining is J&#39;s means of tacit
programming (that is, functions which make no reference to their
arguments). While there is a bit more depth to it than I bother using,
I&#39;ve limited myself to using mostly trains of three verbs, so-called
<em>forks</em>. A fork is a function comprised of three verbs, F G and H and
might look like this:</p>
<pre><code>myNewVerb=. F G H    NB. results in application (F(y)) G (H(y))
</code></pre>
<p>The parsing rules for J identify this pattern and apply the function
in a specific way; the canonical example is to define &#34;average&#34;:</p>
<pre><code>sum=. +/
divide=. %
count=. #
average=. sum divide count
</code></pre>
<p>If you applied it to an array <code>1 2 3 4 5</code>:</p>
<pre><code>average 1 2 3 4 5
NB. (sum 1 2 3 4 5) divide (count 1 2 3 4 5)
</code></pre>
<p>One last thing that may confuse the untrained eye is the order of
evaluation. Sentences respect the traditional means of evaluating
parenthesized phrases first, but otherwise proceed from right to
left. An example:</p>
<pre><code>   - +/ 1 2 3
_6
</code></pre>
<p>The result will be the sum of <code>1 2 3</code> (6), which is then negated, so
the result is -6 (which is written as <code>_6</code> to avoid confusion with the
minus/negate symbol).</p>
<h2>Utility Verbs</h2>
<p>I&#39;ve written several verbs in the tacit style that are generally
useful or improve the reading of the program, even when they&#39;re only
used once. The first is <em>magnitude</em>, which returns the magnitude of a
vector:</p>
<pre><code>magnitude=: [: %: [: +/ *:      NB. sqrt of sum of squares
</code></pre>
<p>The comment should suffice for those who don&#39;t yet know the syntax of
J but it may be worth pointing out two interesting details. The first
is the fact that this &#34;train&#34; looks like it is 5 verbs, which doesn&#39;t
sound like a <em>fork</em> at first. The thing to keep in mind is that forks
can compose on top of other forks, so this may be viewed like:</p>
<ul>
<li><code>[: %: [: +/ *:</code> a train of 5 verbs</li>
<li><code>[: %: ([: +/ *:)</code> the first fork is parenthesized</li>
<li>the second fork is now F G H, where H is the parenthesized fork</li>
<li>the resulting application is like <code>([: y) %: (([: +/ *:) y)</code></li>
</ul>
<p>The use of <code>[:</code> is a little weird to understand, but it is basically a
no-operation left argument to ensure that the verb is evaluated as a
function of one argument instead of two. This is a consequence of J&#39;s
overloading of verbs for the two cases, e.g. <code>3 % 4</code> is &#34;3 divided by
4&#34;, but <code>% 4</code> is &#34;reciprocal of 4&#34;. By using <code>[:</code> in a train we ensure
that whatever is left of <code>%</code> isn&#39;t taken as a left argument and
instead we use the monadic form of the verb.</p>
<p>Although it isn&#39;t used much here, one thing that is really attractive
about array programming is the way verbs can operate independent of
dimensionality. Here I take the magnitude of a two-dimensional vector
and then a three-dimensional vector (which is what I use throughout
the ray tracer):</p>
<pre><code>   magnitude 6 8
10

   magnitude 3 4 12
13
</code></pre>
<pre><code>normalize=: ] * [: % magnitude  NB. scale by reciprocal of magnitude
dotproduct=: +/ . *
</code></pre>
<p>Both normalize and dot product aren&#39;t particularly interesting,
normalize is notable for composing a new verb train from the
previously defined <code>magnitude</code> without any special syntax or handling.</p>
<pre><code>toRGB=: ([: &lt;.&amp;255 &gt;.&amp;0) &amp; ([: &lt;. 255&amp;*) NB. 0-&gt;1 becomes 0-&gt;255 (clamped)
</code></pre>
<p>Throughout the ray tracer I deal with color as vectors of 3 floating
point numbers, intended to be between 0 and 1.0. In order to map the
range into the RGB space I&#39;m doing <em>max(0, min(floor(x * 255),
255))</em>. <code>&amp;</code> (&#34;bond&#34;) is used to partially apply arguments to a verb, a
simple example would be to define &#34;addOne&#34; as <code>+&amp;1</code>. Interestingly,
<code>&amp;</code> can bond nouns to verbs to apply arguments but it may also be used
to compose functions as in math, e.g. <em>(f ∘ g)(x) = f(g(x))</em> is
analogous to <code>f&amp;g y</code> (eliding <a href="https://code.jsoftware.com/wiki/Vocabulary/ampv">a few
details</a> here).</p>
<p>Reflection is defined as a verb taking two argument, a vector and a
normal. It works by subtracting the vector and the normal scaled by
twice the dot product of the vector and the normal.</p>
<pre><code>reflect=: [ - ] * +:@dotproduct          NB. (vector normal)
</code></pre>
<p><img src="https://idle.nprescott.com/2020/static/reflection.png" alt="illustration of four 
vectors for light, eye, reflection, and normal along with the 
interaction along a surface"/>
</p>

<p>Given an array of intersections (defined later) a &#34;hit&#34; is defined as
the smallest positive intersection. This identifies which of the
points the ray &#34;touches&#34; are to be drawn, since the vector &#34;moves&#34; in
the time dimension it means we pick the first contact of the ray with
the sphere:</p>
<pre><code>hit=: ([: {. /:~) &amp; (0&amp;&lt; # ])   NB. smallest positive intersection
</code></pre>
<p>It is a little interesting due to the way the filter works as part of
the first train <code>(0&amp;&lt; # ])</code>. The predicate (F) is defined as <code>&lt;</code>
(greater than) bonded (<code>&amp;</code>) with 0, the right-most verb (H) is simply
right-argument (<code>]</code>) and doesn&#39;t do anything but return the argument
supplied to it. Finally these two are combined with copy (<code>#</code>), the
verb G in the train so that an application looks like this:</p>
<pre><code>0&amp;&lt; # ]    NB. F G H
(0&amp;&lt; # ]) 3 6 0 8 1 0    NB. applied to an array y
(0&amp;&lt; y) # (] y)    NB. turns into (F(y)) G (H(y))
(1 1 0 1 1 0) # (3 6 0 8 1 0)    NB. copy uses a boolean array
                                 NB. to decide which to copy
3 6 8 1
</code></pre>
<p>From there I just sort ascending (<code>/:~</code>) and take the first item
(<code>{.</code>).</p>
<h2>Non-Tacit Verbs</h2>
<p>While the tacit &#34;utility&#34; verbs I&#39;ve defined are (at least to me)
interesting in their own right, the remaining pieces of the ray tracer
don&#39;t lend themselves to similar definition. It is entirely seamless
to switch to explicit verb definitions where they make more sense,
here in the case of defining <code>intersect</code>:</p>
<pre><code>intersect=: dyad define         NB. (origin direction)
a=. y dotproduct y
b=. 2 * y dotproduct x
c=. (x dotproduct x) - 1
discriminant=. (*: b) - (4 * a * c)
if. discriminant &gt;: 0 do.
  i1=. ((- b) - (%: discriminant)) % +: a
  i2=. ((- b) + (%: discriminant)) % +: a
  i1 ; i2
else.
  0                             NB. lest we return the last calculated value...
end.
)
</code></pre>
<p><img src="https://idle.nprescott.com/2020/static/ray-intersections.png" alt="illustration of a 
ray intersecting a sphere twice"/>
</p>

<p>The definition for the intersection is pretty much straight out of a
textbook and J really shines in a nearly direct translation. The one
oddity I added was to return 0 in the case of a discriminant
(<em>b<sup>2</sup>-4ac</em>) less than 0, this allows me to modify the
behavior later in the program when coloring pixels based on the time
of intersection.</p>
<p>Thus far all of my verbs have taken only 1 or 2 arguments, as is usual
for J verbs. There are occasions where it is too onerous to write
everything in this way, such was the case for rendering the lighting
of a point. It really needs a number of pieces of information, some of
them composite, J supports this with a kind of argument unpacking seen
here on lines 2-4:</p>
<pre><code>lighting=: monad define
&#39;light material position eye normal&#39;=. y
&#39;lPosition lIntensity&#39;=. light
&#39;mAmbient mDiffuse mSpecular mShiny mColor&#39;=. material
effectiveColor=. mColor * lIntensity
ambient=. effectiveColor * mAmbient
lightv=. normalize lPosition - position
l=. lightv dotproduct normal
r=. ((- lightv) reflect normal) dotproduct eye
diffuse=. (l&gt;:0) { &gt; (0 0 0) ; l * effectiveColor * mDiffuse
specular=. (r&gt;:0) { &gt; (0 0 0) ; lIntensity * mSpecular * r ^ mShiny
ambient + diffuse + specular
)
</code></pre>
<p>In order to &#34;drive&#34; the program there&#39;s one important bit left to
write. It&#39;ll be responsible for sizing an area to &#34;draw&#34; onto, along
with a small bit of math to orient the &#34;eye&#34; to the scene and define
our light source and material:</p>
<pre><code>trace=: dyad define             NB. (width (x y))
&#39;xcoord ycoord&#39;=. y
rOrigin=. 0 0 _5
wallZ=. 10
wallSize=. 7.0
pixelSize=. wallSize % x
position=. ((- -: wallSize) + pixelSize * xcoord) , ((-: wallSize) - pixelSize * ycoord) , wallZ
rDirection=. normalize position - rOrigin
contactTime=. hit &gt;rOrigin intersect rDirection
if. contactTime do.
  pos=. rOrigin + rDirection * contactTime
  normal=. normalize pos
  eye=. -rDirection
  light=. (_10 _8 _10); (1 1 1) NB. position intensity
  material=. 0.1 ; 0.9 ; 0.9 ; 200 ; 0.5 0.2 1 NB. ambient diffuse specular shiny color
  lighting light; material ; pos; eye; normal
else.
  0 0 0
end.
)
</code></pre>
<p>This verb takes two arguments, one of them compound, the first is a
&#34;canvas&#34; size, only square images are supported; the second is a
single <em>x, y</em> position. Because <code>trace</code> takes a single <em>x, y</em> position
I need an array of <em>all</em> the coordinates of the &#34;canvas&#34;, for that I
define:</p>
<pre><code>coordinates=: [: (] ,&#34;0 |:) 2&amp;# $ ] # i. NB. y is square array width
</code></pre>
<p>This is another tacit verb of multiple forks, it isn&#39;t particularly
interesting but boxing the result reveals the work it is
accomplishing:</p>
<pre><code>   &lt;&#34;1 coordinates 5
┌───┬───┬───┬───┬───┐
│0 0│0 1│0 2│0 3│0 4│
├───┼───┼───┼───┼───┤
│1 0│1 1│1 2│1 3│1 4│
├───┼───┼───┼───┼───┤
│2 0│2 1│2 2│2 3│2 4│
├───┼───┼───┼───┼───┤
│3 0│3 1│3 2│3 3│3 4│
├───┼───┼───┼───┼───┤
│4 0│4 1│4 2│4 3│4 4│
└───┴───┴───┴───┴───┘
</code></pre>
<p>It creates an array of the coordinates for each point in a square
2-dimensional array.</p>
<p><img src="https://idle.nprescott.com/2020/static/scene.png" width="600" alt="a wall with a grid, in front a blue 
ball looking at the ball is an eye with lines traces from the eye to the ball 
and the wall behind it. Up and to the right of the eye is a light source with 
the light traced down to the ball to the point of reflection"/>
</p>

<p>Finally, to output an image I have a verb to write an array into a
PPM file format<sup>*</sup>:</p>
<pre><code>writePPM=: dyad define          NB. (array filename) TODO wrap at 70 characters
header=. &#39;P3&#39;, LF, (&#34;: 0 1 { $x), LF, &#39;255&#39;, LF
(header, (&#34;: toRGB ,,/x), LF) fwrite y
)
</code></pre>
<p>This verb just concatenates the multidimensional array contents to a
single string, along with dimension and color depth information.</p>
<p><sup>*</sup> To conform with &#34;the standard&#34; the resulting file has to
be wrapped at 70 characters wide, which this doesn&#39;t do. If it really
matters there&#39;s always the Unix fold program: <code>fold -s -w70</code>.</p>
<h2>The Result</h2>
<p><img src="https://idle.nprescott.com/2020/static/ray-traced-sphere.png" alt="a ray traced sphere 
with a heavy shadow"/>
</p>

<h3>Not Included</h3>
<p>In order to limit the scope down to a manageable size I&#39;ve not
implemented multiple objects or sphere transformations (shearing,
rotation, etc.). In the case of transformations I don&#39;t think they
would present much further work, partly due to the fact that J
natively provides an operation to invert a matrix (<code>%.</code>).</p>
<h2>Thoughts</h2>
<p>Developing all of this in J proved to be an impressively interactive
experience. The combination of a pretty good console and editor meant
trying things out iteratively and debugging errors on the fly was
nearly painless. Paired with a few helpful features of the J editor
like context-sensitive help meant I could jump to the documentation
where there are plenty of examples.</p>
<p>Frankly I&#39;ve been surprised at how much I like J; when I first learned
some <a href="http://www.t3x.org/klong/">Klong</a> and later read about
<a href="https://www.kparc.com/">K</a> I thought that J looked off-putting for
the &#34;needlessly weird&#34; syntax and went so far as to try out APL which
I reasoned had more cause for weird syntax owing to <a href="https://en.wikipedia.org/wiki/APL_%28programming_language%29#History">its
history</a>. Finally
digging into J some more reveals a lot of thought has gone into the
design of the language and things feel very...regular? It is hard to
explain exactly, but I keep finding myself surprised when things just
work. I&#39;ll type something out, feed some test input, make an amendment
and it&#39;ll be done. No weird edge cases, no confusing discrepancies, it
takes a little while to get up to speed but the learning curve has not
been so steep as I imagined.</p>
<p>I should also mention, it is <em>fast</em>. I&#39;ve written a very similar ray
tracer <a href="https://git.sr.ht/~nprescott/ray-tracer">in Common Lisp</a>
(which I won&#39;t claim to be any good at, but certainly have at least as
much experience in) and without optimizing anything in either
implementation J is performing around 5 times as fast. While it isn&#39;t
very fair to CL or indicative of what can be done in the language it
does seem telling that a fast solution is more apparent in J, at least
to <em>this</em> novice.</p>
<p>The full program <a href="https://idle.nprescott.com/2020/static/ray-tracer.ijs.txt">is here</a>.</p>

  

</div>
  </body>
</html>
