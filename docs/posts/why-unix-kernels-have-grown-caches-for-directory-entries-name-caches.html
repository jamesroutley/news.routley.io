<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://utcc.utoronto.ca/~cks/space/blog/unix/KernelNameCachesWhy">Original</a>
    <h1>Why Unix kernels have grown caches for directory entries (&#39;name caches&#39;)</h1>
    
    <div id="readability-page-1" class="page"><div><h2>Why Unix kernels have grown caches for directory entries (&#39;name caches&#39;)</h2>

	<p><small>December  2, 2023</small></p>
</div><div><p>An interesting feature of modern Unix kernels is that they generally
know the names of things like current directories and open files.
Traditionally the only thing Unix knew about open files, current
directories, active memory mapped files, and so on was their inode
(as an in-kernel data structure, including pointers to the inode&#39;s
mount point and so on). However, some time back various Unixes added
in kernel caches of directory entry names and associated data (in
Linux these are <em>dentries</em> and the dcache; in FreeBSD there
is the <em>name cache</em>). Once a Unix kernel had such a general cache,
it could pin all of the entries for active file and directory objects
and so generally be able to supply their names, either for system
monitoring purposes (such as Linux&#39;s /proc/&lt;pid&gt;/fd subdirectory)
or so <a href="https://utcc.utoronto.ca/~cks/space/blog/unix/ShellsAndCurrentDirectory">they could support a system call to return the name of the
current directory if it had one</a>.</p>

<p>The reason that several Unixes all added these name caches is
straightforward; running Unix systems generally do a lot of directory
name lookups. The steady addition of shared libraries (which may
live in a number of different places), data files for locales and
timezones, lots of $PATH entries, and so on didn&#39;t improve the
situation. Before name caches, each of these lookups had to call
into the specific filesystem, which would generally check through
<a href="https://utcc.utoronto.ca/~cks/space/blog/tech/HardNonlinearDirectories">whatever the on-disk data structure for directories was</a>; hopefully the actual disk blocks
for these directories would already be in the kernel&#39;s disk cache,
so they didn&#39;t have to be read in.</p>

<p>A kernel name cache provides a fast path for all of these lookups.
This cache is especially useful for looking up things that are
almost certainly already in active use, such as /bin/sh, the core
shared library loader, or the C shared library. These are almost
always in memory already, so with the right efficient in-memory
data structures for name caches, the kernel can go from &#34;/bin/sh&#34;
to an inode quite efficiently (and directly, without having to do
a bunch of indirection through things like <a href="https://en.wikipedia.org/wiki/Virtual_file_system">its Virtual Filesystem
Switch</a>.</p>

<p>An explicit kernel name cache also has the additional benefit that
it can store negative entries (in Linux, <em>negative dentries</em>), which
say that a particular name isn&#39;t present. There are a fair number
of situations on modern Unixes where programs will attempt to find
a file in a succession of directories; with negative entries, those
checks of all of the directories that the file isn&#39;t in can still
be pretty efficient. Without some sort of support for &#39;this name
is definitely not here&#39; in the name cache, the kernel would have
no choice but to ask the filesystem to search the on-disk directory
for the name.</p>

<p>I don&#39;t know if there are performance studies for current name
caches in current Unix kernels, but I&#39;m sure that they make a real
difference (both in lookup speed and in reducing kernel CPU usage).
Even in the late 1980s, name lookups were a quite common thing and
they relied very heavily on high hit rates in the kernel block cache
(I was once involved in studying this in a BSD derived kernel, and
I remember hit rates in the high 90%s).</p>

<p>(An interesting read on kernel name translation overhead and
optimizing it is the relevant sections in the <a href="https://docs-archive.freebsd.org/44doc/">4.4 BSD Lite &#34;System
Performance&#34; paper</a>.)</p>

<p>PS: Since I looked it up, all of Linux, FreeBSD, OpenBSD, and NetBSD
have some form of kernel name caches. I don&#39;t know about <a href="https://www.illumos.org/">Illumos</a> or the few surviving commercial Unixes.</p>

<h3>Sidebar: The (potential) names of filesystem objects</h3>

<p>A directory in a conventional Unix filesystem has either one name
or no name (if it&#39;s been removed). Because of this, the kernel&#39;s
name cache can always know the directory&#39;s current name if it has
one. If it wants to, the name cache can go further and provide the
last name that the directory was known by before it was deleted,
along with a mark that it was deleted.</p>

<p>A file can have no name (if it&#39;s been removed since it was opened
or mmap()&#39;d), it can have one name, or it can have several names
because there are several hardlinks to it. Because of this the
kernel name cache may not necessarily know the current name of an
open file. If it started out having multiple hardlinks, was opened
through one hardlink, and then that hardlink was removed, the name
cache may not know the name of the other remaining hardlink(s).</p>

<p>Even if the name cache does know other names for the file, it&#39;s a
policy decision if the name cache should provide them or if it
should return the original name the file was opened under, along
with an indication that the name was removed. In at least some
implementations of /proc/&lt;pid&gt;/fd or the equivalent, you can still
read the data of now-deleted files, so you don&#39;t need a current
name to do this and knowing the original now-deleted name the program
used may be more useful than knowing a current alternate name.</p>
</div></div>
  </body>
</html>
