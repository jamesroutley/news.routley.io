<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/EmberEmu/Hexi">Original</a>
    <h1>Show HN: Hexi â€“ Modern header-only network binary serialisation for C&#43;&#43;</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text"><p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://victorpoughon.fr/EmberEmu/Hexi/blob/master/docs/assets/header.png"><img src="https://victorpoughon.fr/EmberEmu/Hexi/raw/master/docs/assets/header.png" alt="Hexi, Easy Peasy Binary Streaming"/></a></p>
<p dir="auto">
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/67c9ada79023e3b1ef117c1ca7612d1a400889248d0a338dde8ebe7cc09f5d45/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f432532422532422d32332d454337314130"><img src="https://camo.githubusercontent.com/67c9ada79023e3b1ef117c1ca7612d1a400889248d0a338dde8ebe7cc09f5d45/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f432532422532422d32332d454337314130" data-canonical-src="https://img.shields.io/badge/C%2B%2B-23-EC71A0"/></a>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/dc060948d856eec5622f32dffb4abc9227172bdf04fb4da0879bf4930916885b/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4743432d31332d454337314130"><img src="https://camo.githubusercontent.com/dc060948d856eec5622f32dffb4abc9227172bdf04fb4da0879bf4930916885b/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4743432d31332d454337314130" data-canonical-src="https://img.shields.io/badge/GCC-13-EC71A0"/></a>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/25285f6ee2b43e22154556e473bef0c788484ea703a9beda1e52c5011eca7ae8/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f436c616e672d31372d454337314130"><img src="https://camo.githubusercontent.com/25285f6ee2b43e22154556e473bef0c788484ea703a9beda1e52c5011eca7ae8/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f436c616e672d31372d454337314130" data-canonical-src="https://img.shields.io/badge/Clang-17-EC71A0"/></a>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/24efb1d28db4ff3c9aa2ad0236671f92c9b3ad9360c8a710c0d4e4cb1b3b72c2/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4d5356432d31372d454337314130"><img src="https://camo.githubusercontent.com/24efb1d28db4ff3c9aa2ad0236671f92c9b3ad9360c8a710c0d4e4cb1b3b72c2/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4d5356432d31372d454337314130" data-canonical-src="https://img.shields.io/badge/MSVC-17-EC71A0"/></a>
</p>
<p dir="auto">
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/8f5d298e3316491ef0d54f042284289d02edd9c4df8623545474c12cb1994f57/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f616374696f6e732f776f726b666c6f772f7374617475732f656d626572656d752f686578692f636d616b652d6d756c74692d706c6174666f726d2e796d6c3f6c6f676f3d676974687562616374696f6e73266c6162656c3d556e69742532305465737473266c6f676f436f6c6f723d776869746526636f6c6f723d454337314130"><img src="https://camo.githubusercontent.com/8f5d298e3316491ef0d54f042284289d02edd9c4df8623545474c12cb1994f57/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f616374696f6e732f776f726b666c6f772f7374617475732f656d626572656d752f686578692f636d616b652d6d756c74692d706c6174666f726d2e796d6c3f6c6f676f3d676974687562616374696f6e73266c6162656c3d556e69742532305465737473266c6f676f436f6c6f723d776869746526636f6c6f723d454337314130" data-canonical-src="https://img.shields.io/github/actions/workflow/status/emberemu/hexi/cmake-multi-platform.yml?logo=githubactions&amp;label=Unit%20Tests&amp;logoColor=white&amp;color=EC71A0"/></a>
</p>
<p dir="auto">Hexi is a lightweight, header-only C++23 library for safely handling binary data from arbitrary sources (but primarily network data). It sits somewhere between manually memcpying bytes from network buffers and full-blown serialisation libraries.</p>
<p dir="auto">The design goals are ease of use, safety when dealing with untrusted data, a reasonable level of flexibility, and keeping overhead to a minimum.
</p><p dir="auto">What Hexi doesn&#39;t offer: versioning, conversion between different formats, handling of text-based formats, unloading the dishwasher.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://victorpoughon.fr/EmberEmu/Hexi/blob/master/docs/assets/frog-getting-started.png"><img src="https://victorpoughon.fr/EmberEmu/Hexi/raw/master/docs/assets/frog-getting-started.png" alt="Getting started"/></a></p>
<p dir="auto">Incorporating Hexi into your project is simple! The easiest way is to simply copy <code>hexi.h</code> from <code>single_include</code> into your own project. If you&#39;d rather only include what you use, you can add <code>include</code> to your include paths or incorporate it into your own CMake project with <code>target_link_library</code>. To build the unit tests, run CMake with <code>ENABLE_TESTING</code>.</p>
<p dir="auto">Here&#39;s what some libraries might call a very simple motivating example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;hexi.h&gt;
#include &lt;array&gt;
#include &lt;vector&gt;
#include &lt;cstddef&gt;

struct UserPacket {
    uint64_t user_id;
    uint64_t timestamp;
    std::array&lt;uint8_t, 16&gt; ipv6;
};

auto deserialise(std::span&lt;const char&gt; network_buffer) {
    hexi::buffer_adaptor adaptor(network_buffer); // wrap the buffer
    hexi::binary_stream stream(adaptor);          // create a binary stream
    
    // deserialise!
    UserPacket packet;
    stream &gt;&gt; packet;
    return packet;
}

auto serialise(const UserPacket&amp; packet) {
    std::vector&lt;uint8_t&gt; buffer;
    hexi::buffer_adaptor adaptor(buffer); // wrap the buffer
    hexi::binary_stream stream(adaptor);  // create a binary stream
    
    // serialise!
    stream &lt;&lt; packet;
    return buffer;
}"><pre>#<span>include</span> <span><span>&lt;</span>hexi.h<span>&gt;</span></span>
#<span>include</span> <span><span>&lt;</span>array<span>&gt;</span></span>
#<span>include</span> <span><span>&lt;</span>vector<span>&gt;</span></span>
#<span>include</span> <span><span>&lt;</span>cstddef<span>&gt;</span></span>

<span>struct</span> <span>UserPacket</span> {
    <span>uint64_t</span> user_id;
    <span>uint64_t</span> timestamp;
    std::array&lt;<span>uint8_t</span>, <span>16</span>&gt; ipv6;
};

<span>auto</span> <span>deserialise</span>(std::span&lt;<span>const</span> <span>char</span>&gt; network_buffer) {
    hexi::buffer_adaptor <span>adaptor</span>(network_buffer); <span><span>//</span> wrap the buffer</span>
    hexi::binary_stream <span>stream</span>(adaptor);          <span><span>//</span> create a binary stream</span>
    
    <span><span>//</span> deserialise!</span>
    UserPacket packet;
    stream &gt;&gt; packet;
    <span>return</span> packet;
}

<span>auto</span> <span>serialise</span>(<span>const</span> UserPacket&amp; packet) {
    std::vector&lt;<span>uint8_t</span>&gt; buffer;
    hexi::buffer_adaptor <span>adaptor</span>(buffer); <span><span>//</span> wrap the buffer</span>
    hexi::binary_stream <span>stream</span>(adaptor);  <span><span>//</span> create a binary stream</span>
    
    <span><span>//</span> serialise!</span>
    stream &lt;&lt; packet;
    <span>return</span> buffer;
}</pre></div>
<p dir="auto">By default, Hexi will try to serialise basic structures such as our <code>UserPacket</code> if they meet requirements for being safe to directly copy the bytes. Now, for reasons of portability, it&#39;s not recommended that you do things this way unless you&#39;re positive that the data layout is identical on the system that wrote the data. Not to worry, this is easily solved. Plus, we didn&#39;t do any error handling. All in good time.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://victorpoughon.fr/EmberEmu/Hexi/blob/master/docs/assets/frog-remember.png"><img src="https://victorpoughon.fr/EmberEmu/Hexi/raw/master/docs/assets/frog-remember.png" alt="Remember these two classes, if nothing else!"/></a></p>
<p dir="auto">The two classes you&#39;ll primarily deal with are <code>buffer_adaptor</code> and <code>binary_stream</code>.</p>
<p dir="auto"><code>binary_stream</code> takes a container as its argument and is used to do the reading and writing. It doesn&#39;t know much about the details of the underlying container.</p>
<p dir="auto">To support containers that weren&#39;t written to be used with Hexi, <code>buffer_adaptor</code> is used as a wrapper that <code>binary_stream</code> can interface with. As with <code>binary_stream</code>, it also provides read and write operations but at a lower level.</p>
<p dir="auto"><code>buffer_adaptor</code> can wrap any contiguous container or view that provides <code>data</code> and <code>size</code> member functions and optionally <code>resize()</code> for write support. From the standard library, that means the following can be used out of the box:</p>
<ul>
<li> std::array</li>
<li> std::span</li>
<li> std::string_view</li>
<li> std::string</li>
<li> std::vector</li>
</ul>
<p dir="auto">Plenty of non-standard library containers will work out of the box, too, as long as they provide a vaguely similar API.</p>
<p dir="auto">The container&#39;s value type must be a byte type (e.g. <code>char</code>, <code>std::byte</code>, <code>uint8_t</code>). <code>std::as_bytes</code> can be used as a workaround if this poses a problem.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://victorpoughon.fr/EmberEmu/Hexi/blob/master/docs/assets/frog-bring-your-own-containers.png"><img src="https://victorpoughon.fr/EmberEmu/Hexi/raw/master/docs/assets/frog-bring-your-own-containers.png"/></a></p>
<p dir="auto">Hexi supports custom containers, including non-contiguous containers. In fact, there&#39;s a non-contiguous container included in the library. You simply need to provide a few functions such as <code>read</code> and <code>size</code> to allow the <code>binary_stream</code> class to be able to use it.</p>
<p dir="auto"><code>static_buffer.h</code> provides a simple example of a custom container that can be used directly with <code>binary_stream</code>.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://victorpoughon.fr/EmberEmu/Hexi/blob/master/docs/assets/frog-i-can-help-you-avoid-segfaults.png"><img src="https://victorpoughon.fr/EmberEmu/Hexi/raw/master/docs/assets/frog-i-can-help-you-avoid-segfaults.png"/></a></p>
<p dir="auto">As mentioned, Hexi is intended to be safe to use even when dealing with untrusted data. An example might be network messages that have been manipulated to try to trick your code into reading out of bounds.</p>
<p dir="auto"><code>binary_stream</code> performs bounds checking to ensure that it will never read more data than the buffer has available and optionally allows you to specify an upper bound on the amount of data to read. This can be useful when you have multiple messages in a buffer and want to limit the deserialisation from potentially eating into the next.</p>
<div dir="auto" data-snippet-clipboard-copy-content="buffer_t buffer;
// ... read data
hexi::binary_stream stream(buffer, 32); // will never read more than 32 bytes"><pre><span>buffer_t</span> buffer;
<span><span>//</span> ... read data</span>
hexi::binary_stream <span>stream</span>(buffer, <span>32</span>); <span><span>//</span> will never read more than 32 bytes</span></pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://victorpoughon.fr/EmberEmu/Hexi/blob/master/docs/assets/frog-errors-happen.png"><img src="https://victorpoughon.fr/EmberEmu/Hexi/raw/master/docs/assets/frog-errors-happen.png" alt="Errors happen, it&#39;s up to you to handle &#39;em"/></a></p>
<p dir="auto">The default error handling mechanism is exceptions. Upon encountering a problem with reading data, an exception derived from <code>hexi::exception</code> will be thrown. These are:</p>
<ul dir="auto">
<li><code>hexi::buffer_underrun</code> - attempt to read out of bounds</li>
<li><code>hexi::stream_read_limit</code> - attempt to read more than the imposed limit</li>
</ul>
<p dir="auto">Exceptions from <code>binary_stream</code> can be disabled by specifying <code>no_throw</code> as a template argument, as shown:</p>
<div dir="auto" data-snippet-clipboard-copy-content="hexi::binary_stream&lt;buf_type, hexi::no_throw&gt; stream(...);"><pre>hexi::binary_stream&lt;buf_type, hexi::no_throw&gt; <span>stream</span>(...);</pre></div>
<p dir="auto">While this prevents <code>binary_stream</code> itself from throwing, it does not prevent propagation of exceptions from lower levels. For example, a wrapped <code>std::vector</code> could still throw <code>std::bad_alloc</code> if allocation fails when writing to it.</p>
<p dir="auto">Regardless of the error handling mechanism you use, the state of a <code>binary_stream</code> can be checked as follows:</p>
<div dir="auto" data-snippet-clipboard-copy-content="hexi::binary_stream&lt;buf_type, hexi::no_throw&gt; stream(...);
// ... assume an error happens

// simplest way to check whether any errors have occurred
if (!stream) {
    // handle error
}

// or we can get the state
if (auto state = stream.state(); state != hexi::stream_state::ok) {
    // handle error
}"><pre>hexi::binary_stream&lt;buf_type, hexi::no_throw&gt; <span>stream</span>(...);
<span><span>//</span> ... assume an error happens</span>

<span><span>//</span> simplest way to check whether any errors have occurred</span>
<span>if</span> (!stream) {
    <span><span>//</span> handle error</span>
}

<span><span>//</span> or we can get the state</span>
<span>if</span> (<span>auto</span> state = stream.state(); state != hexi::stream_state::ok) {
    <span><span>//</span> handle error</span>
}</pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://victorpoughon.fr/EmberEmu/Hexi/blob/master/docs/assets/frog-writing-portable-code-is-easy-peasy.png"><img src="https://victorpoughon.fr/EmberEmu/Hexi/raw/master/docs/assets/frog-writing-portable-code-is-easy-peasy.png" alt="Writing portable code is easy peasy"/></a></p>
<p dir="auto">In the first example, reading our <code>UserPacket</code> would only work as expected if the program that wrote the data laid everything out in the same way as our own program.
This might not be the case for reasons of architecture differences, compiler flags, etc.</p>
<p dir="auto">Here&#39;s the same example but doing it portably.</p>
<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;hexi.h&gt;
#include &lt;span&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cstddef&gt;
#include &lt;cstdint&gt;

struct UserPacket {
    uint64_t user_id;
    std::string username;
    uint64_t timestamp;
    uint8_t has_optional_field;
    uint32_t optional_field;  // pretend this is big endian in the protocol

    // deserialise
    auto&amp; operator&gt;&gt;(auto&amp; stream) {
        stream &gt;&gt; user_id &gt;&gt; username &gt;&gt; timestamp &gt;&gt; has_optional_field;

        if (has_optional_field) {
            stream &gt;&gt; optional_field;
            hexi::endian::big_to_native_inplace(optional_field);
        }

        // we can manually trigger an error if something went wrong
        // stream.set_error_state();
        return stream;
    }

    // serialise
    auto&amp; operator&lt;&lt;(auto&amp; stream) const {
        stream &lt;&lt; user_id &lt;&lt; username &lt;&lt; timestamp &lt;&lt; has_optional_field;

        if (has_optional_field) {
            stream &lt;&lt; hexi::endian::native_to_big(optional_field);
        }

        return stream;
    }
};

// pretend we&#39;re reading network data
void read() {
    std::vector&lt;char&gt; buffer;
    const auto bytes_read = socket.read(buffer);

    // ... logic for determing packet type, etc

    bool result {};

    switch (packet_type) {
        case packet_type::user_packet:
            result = handle_user_packet(buffer);
            break;
    }

    // ... handle result
}

auto handle_user_packet(std::span&lt;const char&gt; buffer) {
    hexi::buffer_adaptor adaptor(buffer);
    hexi::binary_stream stream(adaptor);

    UserPacket packet;
    stream &gt;&gt; packet;

    if (stream) {
        // ... do something with the packet
        return true;
    } else {
        return false;
    }
}"><pre>#<span>include</span> <span><span>&lt;</span>hexi.h<span>&gt;</span></span>
#<span>include</span> <span><span>&lt;</span>span<span>&gt;</span></span>
#<span>include</span> <span><span>&lt;</span>string<span>&gt;</span></span>
#<span>include</span> <span><span>&lt;</span>vector<span>&gt;</span></span>
#<span>include</span> <span><span>&lt;</span>cstddef<span>&gt;</span></span>
#<span>include</span> <span><span>&lt;</span>cstdint<span>&gt;</span></span>

<span>struct</span> <span>UserPacket</span> {
    <span>uint64_t</span> user_id;
    std::string username;
    <span>uint64_t</span> timestamp;
    <span>uint8_t</span> has_optional_field;
    <span>uint32_t</span> optional_field;  <span><span>//</span> pretend this is big endian in the protocol</span>

    <span><span>//</span> deserialise</span>
    <span>auto</span>&amp; <span>operator</span>&gt;&gt;(<span>auto</span>&amp; stream) {
        stream &gt;&gt; user_id &gt;&gt; username &gt;&gt; timestamp &gt;&gt; has_optional_field;

        <span>if</span> (has_optional_field) {
            stream &gt;&gt; optional_field;
            <span>hexi::endian::big_to_native_inplace</span>(optional_field);
        }

        <span><span>//</span> we can manually trigger an error if something went wrong</span>
        <span><span>//</span> stream.set_error_state();</span>
        <span>return</span> stream;
    }

    <span><span>//</span> serialise</span>
    <span>auto</span>&amp; <span>operator</span>&lt;&lt;(<span>auto</span>&amp; stream) <span>const</span> {
        stream &lt;&lt; user_id &lt;&lt; username &lt;&lt; timestamp &lt;&lt; has_optional_field;

        <span>if</span> (has_optional_field) {
            stream &lt;&lt; <span>hexi::endian::native_to_big</span>(optional_field);
        }

        <span>return</span> stream;
    }
};

<span><span>//</span> pretend we&#39;re reading network data</span>
<span>void</span> <span>read</span>() {
    std::vector&lt;<span>char</span>&gt; buffer;
    <span>const</span> <span>auto</span> bytes_read = socket.<span>read</span>(buffer);

    <span><span>//</span> ... logic for determing packet type, etc</span>

    <span>bool</span> result {};

    <span>switch</span> (packet_type) {
        <span>case</span> packet_type::user_packet:
            result = <span>handle_user_packet</span>(buffer);
            <span>break</span>;
    }

    <span><span>//</span> ... handle result</span>
}

<span>auto</span> <span>handle_user_packet</span>(std::span&lt;<span>const</span> <span>char</span>&gt; buffer) {
    hexi::buffer_adaptor <span>adaptor</span>(buffer);
    hexi::binary_stream <span>stream</span>(adaptor);

    UserPacket packet;
    stream &gt;&gt; packet;

    <span>if</span> (stream) {
        <span><span>//</span> ... do something with the packet</span>
        <span>return</span> <span>true</span>;
    } <span>else</span> {
        <span>return</span> <span>false</span>;
    }
}</pre></div>
<p dir="auto">Because <code>binary_stream</code> is a template, it&#39;s easiest to allow the compiler to perform type deduction magic.</p>
<p dir="auto">If you want the function bodies to be in a source file, it&#39;s recommended that you provide your own <code>using</code> alias for your <code>binary_stream</code> type.
The alternative is to use the polymorphic equivalents, <code>pmc::buffer_adaptor</code> and <code>pmc::binary_stream</code>, which allow you to change the underlying buffer type at runtime but at the cost of virtual call overhead and lacking some functionality that doesn&#39;t mesh well with polymorphism.</p>
<p dir="auto">How you structure your code is up to you, this is just one way of doing it.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://victorpoughon.fr/EmberEmu/Hexi/blob/master/docs/assets/frog-uh.png"><img src="https://victorpoughon.fr/EmberEmu/Hexi/raw/master/docs/assets/frog-uh.png" alt="Uh, one more thing..."/></a></p>
<p dir="auto">When using <code>binary_stream</code>, strings are always treated as null-terminated. Writing a <code>char*</code>, <code>std::string_view</code> or <code>std::string</code> will always write a terminating byte to the stream. If you require otherwise, use one of the <code>put</code> functions.</p>
<p dir="auto">Likewise, reading to <code>std::string</code> assumes the buffer contains a null-terminator. If it does not, an empty string will be returned. If you know the length of the string or need to support a custom terminating/sentinel value, use <code>get()</code> and <code>find_first_of()</code>.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://victorpoughon.fr/EmberEmu/Hexi/blob/master/docs/assets/frog-what-else-is-in-the-box.png"><img src="https://victorpoughon.fr/EmberEmu/Hexi/raw/master/docs/assets/frog-what-else-is-in-the-box.png" alt="What else is in the box?"/></a></p>
<p dir="auto">Here&#39;s a very quick rundown on some of the included extras.</p>
<ul dir="auto">
<li><code>hexi::file_buffer</code>
<ul dir="auto">
<li>For dealing with binary files. Simples.</li>
</ul>
</li>
<li><code>hexi::static_buffer</code>
<ul dir="auto">
<li>Fixed-size networking buffer for when you know the upper bound on the amount of data you&#39;ll need to send or receive in one go. Essentially a wrapper around <code>std::array</code> but with added state tracking. Handy if you need to deserialise in multiple steps (read packet header, dispatch, read packet body).</li>
</ul>
</li>
<li><code>hexi::dynamic_buffer</code>
<ul dir="auto">
<li>Resizeable buffer for when you want to deal with occasional large read/writes without having to allocate the space up front. Internally, it adds additional allocations to accomodate extra data rather than requesting a larger allocation and copying data as <code>std::vector</code> would. It reuses allocated blocks where possible and has support for Asio (Boost or standalone). Effectively, it&#39;s a linked list buffer.</li>
</ul>
</li>
<li><code>hexi::tls_block_allocator</code>
<ul dir="auto">
<li>Allows many instances of <code>dynamic_buffer</code> to share a larger pool of pre-allocated memory, with each thread having its own pool. This is useful when you have many network sockets to handle and want to avoid the general purpose allocator. The caveat is that a deallocation must be made by the same thread that made the allocation, thus limiting access to the buffer to a single thread (with some exceptions).</li>
</ul>
</li>
<li><code>hexi::endian</code>
<ul dir="auto">
<li>Provides functionality for handling endianness of integral types.</li>
</ul>
</li>
</ul>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://victorpoughon.fr/EmberEmu/Hexi/blob/master/docs/assets/frog-before.png"><img src="https://victorpoughon.fr/EmberEmu/Hexi/raw/master/docs/assets/frog-before.png" alt="Before we wrap up, look at these tidbits..."/></a></p>
<p dir="auto">We&#39;re at the end of the overview, but there&#39;s more to discover if you decide to give Hexi a shot. Here&#39;s a selection of tasty morsels:</p>
<ul dir="auto">
<li><code>binary_stream</code> allows you to perform write seeking within the stream, when the underlying buffer supports it. This is nice if, for example, you need to update a message header with information that you might not know until the rest of the message has been written; checksums, sizes, etc.</li>
<li><code>binary_stream</code> provides overloaded <code>put</code> and <code>get</code> member functions, which allow for fine-grained control, such as reading/writing a specific number of bytes.</li>
<li><code>binary_stream</code> allows for writing to <code>std::string_view</code> and <code>std::span</code> with <code>view()</code> and <code>span()</code> as long as the underlying container is contiguous. This allows you to create views into the buffer&#39;s data, providing a fast, zero-copy way to read strings and arrays from the stream. If you do this, you should avoid writing to the same buffer while holding views to the data.</li>
<li><code>buffer_adaptor</code> provides a template option, <code>space_optimise</code>. This is enabled by default and allows it to avoid resizing containers in cases where all data has been read by the stream. Disabling it allows for preserving data even after having been read. This option is only relevant in scenarios where a single buffer is being both written to and read from.</li>
<li><code>buffer_adaptor</code> provides <code>find_first_of</code>, making it easy to find a specific sentinel value within your buffer.</li>
</ul>
<p dir="auto">To learn more, check out the examples in <code>docs/examples</code>!</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://victorpoughon.fr/EmberEmu/Hexi/blob/master/docs/assets/footer.png"><img src="https://victorpoughon.fr/EmberEmu/Hexi/raw/master/docs/assets/footer.png" alt="Thanks for listening! Now go unload the dis[C Make Lists](include/CMakeLists.txt)hwasher."/></a></p>
</article></div></div>
  </body>
</html>
