<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://amontalenti.com/2023/11/25/dependency-rejection">Original</a>
    <h1>Dependency rejection</h1>
    
    <div id="readability-page-1" class="page"><article id="post-3388">
	
	<!-- .entry-header -->

	<div>
		<p>Sam Altman once said: “Minimize your own cognitive load from distracting things that don’t really matter. It’s hard to overstate how important this is, and how bad most are at it. Get rid of distractions in your life. Develop very strong ways to avoid letting crap pile up.”</p>
<p>In programming, there is a technique that is almost the opposite of this, called “<a href="https://en.wikipedia.org/wiki/Dependency_injection">dependency injection</a>.” It’s a way of worrying, up front, about how to split the modules in your program from other code. You aim to give yourself the future benefit of being able to swap out a module dependency later.</p>
<p>In some communities, this little technique led to a temporary fad of constructing programs within a baroque superstructure. Programmers fretted about a future that usually never arrived, and their worries expressed themselves as defensive code, all in the name of “future-proofing.” This often meant they adopted a dependency (already a distraction) and then introduced yet another meta-distraction: building a “management framework” for that dependency and any others. This often took these programmers very far away from the core “<a href="https://en.wikipedia.org/wiki/No_Silver_Bullet">essential complexity</a>” at the heart of their code.<sup id="fnref-3388-1"><a href="#fn-3388-1" title="Read footnote.">1</a></sup></p>
<p>Dependencies seem to be all around us, both in the real world, and in programming. And they are perniciously distracting in just this way. Have you ever noticed how rare it is for you to just <b>do something</b>?</p>
<p>If so, you might have been worrying, up front, about dependencies.<sup id="fnref-3388-2"><a href="#fn-3388-2" title="Read footnote.">2</a></sup></p>
<p><img decoding="async" src="https://amontalenti.com/wordpress/wp-content/uploads/2023/11/sakura-craft-pen.jpg"/></p>
<p>In the back of your mind, you wonder: has this been solved? The world is full of solutions in search of problems, and the internet is always nearby. You convince yourself to research if some of these happen to apply to your problem.</p>
<p>Even if you don’t find something off-the-shelf, you still might think to yourself: I could <strong>just do this</strong>, but is this a good use of my time? Lacking a ready-made solution, you then turn to delegation: whom shall I ask to solve this? After all, the market usually obliges with eager participants willing to sell their labor for a price.</p>
<p>But whether your proposed solution is an object or a person (and whether it is free or paid), there’s one thing it always is: a dependency.</p>

<p>John Cleese once said: “It’s easier to do trivial things that are urgent than to do important things that are not urgent. It’s also easier to do little things we know we can do… than to start on big things we’re not so sure about.”</p>
<p>Is programming about code re-use? After all, that is what day-to-day computing is all about. When we run a program, we re-use code someone else has written. This extends to when we use a service over the web, or when the programmers behind that service use cloud computing to run their workloads and servers. It is thus no surprise that a creative programmer, today, spends a good deal of time reasoning about which code to re-use (and how, precisely, to re-use it). Sometimes, they spend more on that than they do on writing original code.</p>
<p>But, consider <em>writing</em>. Is it about text re-use? Or concept re-mixing? Or is writing, truly good writing, somehow about <strong>new insight creation</strong>?</p>
<p>Some in the tech industry might claim a majority of programmers spend a majority of their time wiring together existing code. What’s the harm in helping this process along? And, indeed, this re-mixing of originality is spreading outside of the craft of programming, and very rapidly — into areas of text (prose), images (art), and video (film) with the rise of <a href="https://en.wikipedia.org/wiki/Generative_artificial_intelligence">generative AI</a>.<sup id="fnref-3388-3"><a href="#fn-3388-3" title="Read footnote.">3</a></sup></p>
<p>But whether your proposed re-use comes from an object or a person (and whether it is free or paid), there’s one thing it always is: a dependency.</p>
<p>Here’s the thing: creativity isn’t just about piecing together dependencies.</p>
<p>That’s not to say that people haven’t been creative in doing so — of course, they have. But, there is a way in which the world today feels very derivative. We sometimes marvel at the originality of these new works, and especially at the sheer speed of output. But many of us have this nagging feeling of something being lost in this flourishing of a derivative kind of productivity.</p>
<p>We can sense, deep down, that the ingenuity of a tool is no substitute for our human ingenuity.</p>
<p>We also know, with certainty, that the value of a tool is never a guarantee of the value of its output.</p>
<p><img decoding="async" src="https://amontalenti.com/wordpress/wp-content/uploads/2023/11/sakura-pens.jpg"/></p>
<p>Thanks to our gift of birth, our human intellect, and aided by a sturdy educational and technological foundation, in some domains we are as gods who can <em>will-to-creation</em> these <em>things-of-value</em> from <em>pure-thought-stuff</em>. But I wonder whether some of us have been conditioned into being too frightened to even try.</p>
<p>Let us cast aside the question, perhaps the empty question, of who (or what) deserves credit for some artifact. My main point is that there are ways in which we distract ourselves (and diffract our efforts) when we set our sights so low as to be just above the horizon of today’s tools.</p>
<p>We can sense it, too — this is often the moment at which a given dependency feels “heavyweight” and runs the risk of snaring us in a self-defeating maze, falsely giving us a sense of progress while maddeningly taking us farther from our goal.</p>
<p>Reflecting on how to create a space for creativity, John Cleese went on to say: “You can’t become playful (and therefore creative) if you’re under your usual pressures. […] You have to create some space for yourself away from those demands. And that means sealing yourself off. You must make a quiet space for yourself where you will be undisturbed. […] When I say: ‘create an oasis of quiet’ … know that when you have, your mind will pretty soon start racing again.”</p>
<p>I find this idea quite calming. Reading it, I feel the urge to create — not merely to go through the motions, not merely to surround myself with the impressive output of carefully-chosen dependencies.</p>
<p>Let us consider one particular open source project and its creator, <a href="https://en.wikipedia.org/wiki/Redis">Redis</a> and Salvatore Sanfilippo (aka <a href="http://antirez.com">antirez</a>). Redis is one of the world’s most popular “in-memory databases,” a piece of server infrastructure used by programmers for any number of important tasks, such as the caching, ranking, and indexing of data. Redis is written in C, a language that doesn’t even have a dependency manager. This was also the language used to develop <a href="https://en.wikipedia.org/wiki/Doom_(1993_video_game)">DOOM</a>, in a world before 3D game engines.<sup id="fnref-3388-4"><a href="#fn-3388-4" title="Read footnote.">4</a></sup></p>
<p>Redis has very few formal dependencies. Thus all the data structures, internals, and commands are implemented from scratch. Which is to say: designed from first principles.</p>
<p>By having a simple wire protocol for how clients talk to the Redis server, the open source community is free to innovate around that wire protocol, and innovate it has, with <a href="https://redis.io/resources/clients/">an implementation in pretty much every programming language</a>. This creates clarity around what, exactly, Redis is: it’s a program that acts as a network server that implements this wire protocol, so that clients can stick data into Redis and get data back out of it.</p>
<p>When antirez used to sit down to write a feature, he knew exactly what tools he would use. That is: the C programming language, his background in programming and computer science, his knowledge of operating systems, his design instincts. He didn’t need to pull in much else, and he never had to worry much about making sure his code “fit in” with the millions (billions? trillions?) of lines of open source code already written in undoubtedly “relevant” areas.</p>
<p>He once implemented a complex algorithm called <a href="https://en.wikipedia.org/wiki/HyperLogLog">“HyperLogLog”</a> in precisely this fashion, and it resulted not only in a novel implementation, but also in <a href="http://antirez.com/news/75">an insightful technical blog post</a>. Most programmers would have attempted to embed or extend an existing implementation, since there are hundreds of such implementations floating around on the internet, including under liberal open source licenses. But antirez just studied the algorithm itself, ran some of his own tests and experiments, and wrote a unique contribution that made sense for Redis, while sharing his results with the world.</p>
<p>This minimalist setup gave him a very focused way to ship new stuff. And he used that for more than a decade to great effect. In the last few years, <a href="http://antirez.com/news/135">he’s taking a break from programming</a> to write sci-fi novels. But throughout his creative life, he has rarely carried the baggage of anyone else’s past contributions.</p>
<p>Through this example of antirez and Redis, we can reflect a bit and widen our view. There is something pathological about trying to constantly fit together all your upcoming contributions into someone else’s (or, the world’s) past contributions. Whether in your code, in your writing, or in any other pursuit. The goal, after all, is to make a novel contribution. To do this, you don’t need better dependencies. No — to create something new, you need to <b>reject</b> your dependencies! Even if only temporarily. You need to operate from a “sealed-off” place of constraint and focus.</p>
<p>I think of the billboard advertisement that once provocatively stated, in large and bold type:</p>
<p>“YESTERDAY YOU SAID TOMORROW”</p>
<p>Then, in small print at the bottom of the billboard was the company’s slogan and admonition:</p>
<p>“Just do it.”</p>
<p>Because even the future can be a dependency, clinging you ceaselessly to the past.</p>
<p>The next time you strive to create something truly new, try <b>dependency rejection</b> for a change. It’s amazing how fast you can move when you trust your instincts and pack light.</p>
<hr/>

<hr/>
<p><small><strong>Acknowledgements —</strong></small></p><p><small>
<p>The idea for this essay came from reflections on how one of my friends approaches his own creativity. He also provided some very useful suggestions and edits to an early draft of this essay — thanks, Rom.</p>
<p>The photos embedded in this post come from a brochure for a specific pen I bought while in Japan, the <b><a href="https://craft.lab.craypas.com/004.html">Sakura Craft Lab 004</a></b>. I really enjoyed how they described the design of their pen, and it is in line with some of the thinking in this post:</p>
<p>“By avoiding excessive decoration and pursuing a simple design, we have created a form that will become your partner. The central knob is pleasant to the touch and reminiscent of antique items. If you turn it, it’s a ballpoint pen, and if you press it, it’s a mechanical pencil. A simplicity that eliminates waste. What is important? What do you need? This is where a new relationship between the author and the pen is born, especially in today’s age of information overload.”</p>
<p>I edited a printed copy of this post with the red ink from this pen. I wrote the original post on macOS using iA Writer, with the text stored in Markdown format. To quickly apply the red ink edits and improve formatting, I used vim — with the help of the Livedown and Goyo plugins — on Linux. I shared a draft with friends using a “public preview” plug-in and then I published the final draft to the wider internet via WordPress.</p>
<p>But do any of those details really matter? I wrote an essay, and I tried to say something new. Now, you’ve read it, and you can go off and make something new!</p>
</small></p>
	</div><!-- .entry-content -->

	
	<!-- .entry-footer -->

</article></div>
  </body>
</html>
