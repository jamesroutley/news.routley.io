<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://maggieappleton.com/programming-portals">Original</a>
    <h1>Programming Portals</h1>
    
    <div id="readability-page-1" class="page"><article><h2>The Context</h2>
<p>In the mid 1980&#39;s the world of computer interfaces cracked in two<!-- -->, leaving a gaping divide between two opposing paradigms.</p>
<!-- -->
<!-- -->
<p>Most of us consider GUIs as an enormous leap forward for computing accessibility and usability. Design patterns like <!-- -->, point and click interactions, <!-- -->, <!-- -->, and <!-- --> all made computers far easier to use and drove the rise of personal computing throughout the rest of 80&#39;s and 90&#39;s. </p>
<!-- -->
<p>Scroll forward a few decades and we now live in an overwhelmingly GUI world. At least most of us do. That crack in the interface world wasn&#39;t a division in time, with CLIs in the past and GUIs in the future. It was a crack in the population of computer users. It created two distinct categories: <strong>end users</strong> and <strong>programmers</strong>.</p>
<p><strong>End users</strong> are the 99%. They&#39;re all the regular folk who interact with computers through the carefully designed GUI applications built for them by teams of designers, developers, and product managers. They have little control over what actions and affordances are made available to them.</p>
<p><strong>Programmers</strong> are the tiny, elite subsection of the population who control what computers can do.<!-- --> They decide what information appears on the dashboard, what actions are avaliable in the menu, and whether you&#39;re allowed to delete your data. They stayed behind in the world of CLIs and text editors.</p>
<h3 id="the-joys-of-text-and-clis">The Joys of Text and CLIs</h3>
<p>Programmers had good reason to stick with text-based CLIs. While GUIs gave us many gifts, they come with a set of tradeoffs. Ones that are particularly troublesome for the type of work programmers do. CLIs are better for...</p>
<ul>
<li><strong>Speed</strong>: it&#39;s slower to physically navigate a cursor through stacks of panels and windows and drop downs to execute a command, rather than simply typing a few keystrokes. You have to spend time <em>looking</em> for things, even when you know what they&#39;re called.</li>
<li><strong>Space</strong>: When you have to visually represent every command a programme is capable of, you run out of screen space fairly quickly. There are only so many sub-sub-sub menus and tabbed panels you can stuff in before an interface becomes overwhelming. The CLI hides all its commands out of sight, and only brings them into view when called.</li>
<li><strong>Composability</strong>: In programming the number of possible keywords, functions, and combinations is exponential. When you&#39;re working in programmatic code you have a wide range of flexibility. You can write your own scripts to do anything you wish. Including remixing other people&#39;s scripts and utilities. Programmers need access to those powerful, lower level abstractions with fewer constraints to create software.</li>
</ul>
<p>I&#39;m distracting you though. This isn&#39;t an extended and tiresome debate about whether GUIs or CLIs are the superior interface choice. It&#39;s clear each has its place depending on the context and task at hand.</p>
<p>It&#39;s about that gaping divide. When we confined end users to the GUIs and hid the command line away from them, we took away access to powerful primitives and the flexibility to write custom code the way programmers can. Their experience of how a computer works and what it can do diverged dramatically. They have no control over how the system works or what functions are avaliable <!-- -->. There is very little opportunity to built novel, customised systems.</p>
<p>If a regular user in 1980 wanted to write a small programme to automate part of their workflow, the tools to do so were ready at hand. They could chain together small, composable UNIX commands in the same environment they do everything else in.</p>
<p>If someone wants to try that nowadays, they&#39;ll need to enter a strange and unfamiliar environment: the terminal. They&#39;ll have to learn to navigate it with an unfamiliar language and set of commands. If they want to augment or interact with any third-party software – aka. all the software they have ever known – they&#39;re in rough awakening. They now need to download an IDE, install homebrew, install node or python, troubleshoot $PATH errors, navigate API documentation, and finally figure out how to execute the programme.</p>
<!-- -->
<p>The problem isn&#39;t just that development environments have grown complex and unweildy. It&#39;s that we&#39;ve failed to find ways to integrate the benefits of text-based programming and command line interfaces back into graphical interfaces. We&#39;re starting to see hints of it though – patterns are appearing that try to bridge the gap.</p>
<p>Search inputs are becoming more structured and programmatic. <!-- --> are popping up in the middle of complex dashboards. And I keep finding tiny portals back into the programmatic realm; windows I&#39;m calling <strong>programming portals</strong>.</p>
<hr/>
<h2>The Pattern</h2>
<p>Programming portals are small, scoped areas within a graphical interface that give users access to command lines and text-based programmaing. They open a little window into the underlying functionality of an interface. One that lets the user view the underlying properties of their environment, and control a specific set of data, objects, or features of the application.</p>
<p>I&#39;ve made a reductively simple example to demonstrate how these portals work. Here&#39;s an imaginary drawing app – let&#39;s call it <em>Drawper</em> – where you can make circles and squares and that sort of thing:</p>
<!-- -->
<p>It allows you to right click and inspect any shape on the canvas:</p>
<!-- -->
<p>You can see its X and Y coordinates, width, height, fill, stroke, and so on. Just the sort of thing you can see when you open the developer tools in the browser. But these are now part of the interface as a first class citizen. They&#39;re discoverable by regular users who aren&#39;t rooting around in complex browser menus.</p>
<p>Seeing metadata about objects is great, but having the power to change them is better. All programming portals give users a ways to write simple logic statements that change the interface. Here I&#39;ve entered some logic into the formula bar to change the styling of the circle:</p>
<!-- -->
<p>This <code>height &gt; 200 ? stroke(&#34;10px gold&#34;) : null</code> statement is a JavaScript expression that says: &#34;If this element&#39;s height is over 200px, then make the stroke 10px and gold. Otherwise leave it as is (null).&#34;</p>
<p>Once we run this code, the circle&#39;s styling should update:</p>
<!-- -->
<p>Could I have changed the stroke through a set of GUI elements like input boxes and a colour pickers? Sure! But it wouldn&#39;t have been conditional on the circle&#39;s size.</p>
<p>In this world, if I resize the circle to make it less than 200px, it would lose the gold border. This is the power of programming. We&#39;re writing dynamic rules, not absolute properties of a static image.</p>
<p>The theoretical groundwork for why this kind of dynamic, interactive medium is critical to the future of interfaces has been well-trodden by <!-- -->. In pieces like <!-- --> and <!-- --> Bret outlines a series of principles that make programmatic systems learnable. Such as being able to <strong>read the vocabulary</strong> of a programme, <strong>see the state</strong>, and <strong>create by reacting</strong> to what&#39;s on the screen in front of you. Programming portals are one way into these design patterns.</p>
<p>Composing rules with linear syntax is open ended and flexible in a way that&#39;s difficult to recreate in visual interface elements. But that doesn&#39;t mean we should use <em>only</em> syntax. Intertwining graphical representations with logical syntax gives users the best of both worlds.</p>
<p>The syntax in these systems doesn&#39;t even need to be that comprehensive. Most programming portals don&#39;t use fully fledged programming languages like Python or JavaScript. Instead they offer a simplified language or limited set of commands designed specifically for this context.</p>
<p>They might allow users to define and reuse variables, write and call functions, or create chains of if-then logic. Some other common affordances include:</p>
<ul>
<li>Query for specific properties and data of elements within the interface</li>
<li>Reference objects within the environment as variables</li>
<li>Run functions that change how objects are displayed</li>
<li>Run functions that change how objects behave</li>
<li>Run calculations with the avaliable data</li>
</ul>
<p>It also doesn&#39;t give users access to rewrite the actual source code of the application. They simply have access to a limited programatic interface that gives them more control over how it works.</p>
<p>While <em>Drawper</em> was a decent example, here are some real programming portals out in the wild:</p>
<h3 id="1-hypercard">1. HyperCard</h3>
<p> is the grand OG example of programming portals. Developed by Bill Atkinson at Apple in 1987, its interface married all the accessibility of simple, graphical user interfaces with the power of writing programmatic logic. Its core concepts were the card and the stack.</p>
<p>Cards could contain text, images, videos, audio, buttons, and links to one another. One of the earliest hypermedia authoring experiences! Stacks were groups of interlinked cards you could save and share with others.</p>
<!-- -->
<p>The remarkable thing about HyperCard is it gave users an enourmous range of control and flexibility. It came with a high-level, built-in programming language called <!-- --> that let users any edit any element on a card.</p>
<p>Here&#39;s a quick 30 second clip showing how users could easily view and edit a Hypertalk script:</p>
<!-- -->

<p>The Hypertalk language tried to closely mimic natural written English. It&#39;s command were simple; <code>find</code>, <code>calculate</code>, and <code>go to</code>. These could be built up into sentences like <code>go to next card</code> or <code>put 2*6 into theValue</code> or <code>set the location of card button x to pos</code>. It&#39;s not too different to today&#39;s <!-- --> which allows MacOS users to automate small processes.</p>
<!-- -->
<p>HyperCard was a hit in its day. Users talked about how empowering it was to create beautiful things quickly and easily, without needing to know how to programme. The <!-- --> </p>
<h3 id="2-fermat">2. Fermat</h3>
<p> is a new <!-- --> for brainstorming with generative AI systems. Similar to some of the apps I pointed out <span></span></p>, it gives people an infinite canvas to lay out their ideas and then riff on them.
<p>The <!-- --> was heavily influenced by HyperCard and implemented many of the same design patterns. Each element on a Fermat canvas is a progrogrammable object. By right-clicking on it, you can inspect it to see its properties and edit them inline.</p>
<!-- -->
<p>We can also pop open an editing panel to write programmatic logic in <!-- --> – Fermat&#39;s simple language for controlling elements. Here&#39;s me writing a small script on a button that changes the value of a connected text block.</p>
<!-- -->
<p>This gives the user access to a live programming environment that&#39;s not drastically different from what they&#39;re already used to. Right-click menus, pop up windows, and icon buttons all make this feel like a balance of GUI-ness and text-based-CLI-ness.</p>
<h3 id="3-notion-before-it-was-notion">3. Notion, before it was Notion</h3>
<p>This example is slightly tragic. People really love the current <!-- -->. But the original vision of Notion – what I&#39;ll call <em>pre-Notion</em> – was far more ambitious and powerful than the Notion of today. I&#39;m sure there are plenty of good reasons for this. Building software is complex and cutting scope is the only way to get anything real shipped. Perhaps pre-Notion was killed by investors or bureaucracy or usability issues or <!-- -->.</p>
<p>Anyway, <em>pre-Notion</em> had lots of interesting and powerful programming portals. Here&#39;s a video of how you could drop down into CSS on any element to restyle it:</p>
<!-- -->

<p>Here&#39;s another where they show how you could write JavaScript as well:</p>
<!-- -->

<p>I&#39;ve jumped you to the key bits in these videos, but I&#39;d recommend watching them all the way through. The beauty of this vision is they&#39;re letting users work with web-native CSS and JS. They simply expose it in a way that&#39;s more user friendly than the built-in tooling browsers give us. It openly <em>invites</em> you to modify the code, and allows you to save your changes to &#34;blocks&#34; so they can be shared with other users and persist between sessions.</p>
<p>This kind of accessible end-user programming on the web feels like something we&#39;ve been dancing around for a decade. I <em>really</em> want to someone build pre-Notion. And it&#39;s unlikely to be Notion.</p>
<h3 id="4-inkbase">4. Inkbase</h3>
<p>Inkbase is a prototype rather than an up-and-running platform, but follows the same pattern as the other examples here. A few members of the <!-- --> research lab have been playing with the idea of “programmable ink” – a dynamic, live programming tool based around drawing – and <!-- --> it <!-- -->.</p>
<!-- -->
<p>Inkbase is more flexible than the previous examples. You can draw anything freehand onto a canvas using the ipad, then pop open the programming portal to manipulate its behaviour.</p>
<p>Their portal is one of the more elaborate ones I&#39;ve seen. They made it easy to see properties update in real time, which means you can observe reactive data flows. They also have extra affordances to make it usable on a touch screen like large toggle buttons to control state, and tap-to-insert buttons for their common syntax characters like <code>( ) [ ] { } each for on</code>. But they <!-- --> they think the current UI of this inspector pane is &#34;incidental to the project&#34; and a &#34;crutch to get to other ideas.&#34; I&#39;m keen to see how it evolves in future iterations.</p>
<p>The combination of loose drawing and scripting seems like an odd pairing until you see what&#39;s possible in these demos. Any quickly scrawled doodle can be turned into a set of ad-hoc interface controls. You can draw your own sliders or handles or checkboxes, then connect it to any other data on the canvas.</p>
<p>For example, tracking the Y coordinate around a circle to create graphs for sin and cos:</p>
<!-- -->
<p>Or dynamically changing numerical values with touch and drag slider:</p>
<!-- -->
<p>There&#39;s something about the hand-drawn aesthetic and touch interactions which makes this feel very far away from Serious Coding. There&#39;s no pretense this tool is for making commerical apps. It&#39;s clearly personal and low stakes. Yet is capable of sophisticated programming logic in the same way HyperCard and Fermat are.</p>
<p>I want more of it. These portals act as entry ways into a very different relationship with the computer. One where you learn to think programmatically – in rules and dynamic interactions and conditional statements – rather than just manipulating the static object in front of you. It&#39;s closing that crack in the interface world between the restrictive GUI and the open-ended CLI, and ultimately between end-users and programmers.</p>
</article></div>
  </body>
</html>
