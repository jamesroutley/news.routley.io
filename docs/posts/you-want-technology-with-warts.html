<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://entropicthoughts.com/you-want-technology-with-warts">Original</a>
    <h1>You Want Technology with Warts</h1>
    
    <div id="readability-page-1" class="page"><div>
                <p>
I normally skip presentations because I prefer reading, but <a href="https://www.youtube.com/watch?v=lASLZ9TgXyc">Building the
Hundred-Year Web Service (YouTube)</a> was worth the time.<span><sup>1</sup> Note that despite
“htmx” featuring in the title, very little of the presentation is actually about
htmx.</span> It is about choosing and using technology in such a way that it won’t
require maintenance suddenly due to external factors changing. That’s a drum
I’ve been banging for the last few years too, although less visibly.
</p>

<hr/>

<p>
Petros observes that we know how to build bridges that last hundreds of years:
stone, concrete, and steel can all do this with the right engineering. We also
know how to build hypertext that is likely to last at least a few decades: use
plain <abbr>html</abbr> and <abbr>css</abbr>. But, Petros asks, how do we create database-y web
services that lasts for decades?
</p>

<p>
Where do we store the data? Where do we perform business logic? He answers
thusly:
</p>

<ul>
<li><abbr>sql</abbr>ite for data storage,</li>
<li><abbr>sql</abbr> queries for most of the application logic,</li>
<li>Express-on-Node.js for routing and presentation logic,</li>
<li>Jinja2 templates for additional presentation logic, and</li>
<li><abbr>html</abbr> and vanilla <abbr>js</abbr> for triggering <abbr>http</abbr> requests.</li>
</ul>

<p>
I won’t debate the specifics here. <span><sup>2</sup> I’d be tempted to jam Perl into the
backend instead of Node.js if I wanted truly low maintenance. I have a feeling a
Perl script is more likely to run unmodified 20 years from now than some Node.js
thing. But maybe I’m wrong on this.</span> But there were other nuggets in the
presentation. For example:
</p>

<ul>
<li>I’ve frequently wondered why I turn to the web browser when I want to make
cross-platform software. There’s a chart in the presentation that shows how
environmental churn and <abbr>api</abbr> deprecation leads desktop applications to have
an expected lifetime of maybe a decade, and phone apps closer to a couple of
years. On the other hand, simple web pages have worked unmodified for over 40
years! That’s a good reason to default to the web as a technology.</li>

<li>When a page load is fast enough, the browser does not do the whole
flicker-a-blank-page-before-doing-a-full-repaint, it just shows the new
content right away as a sort of partial update. This is apparently a recent
browser innovation, but it is what allows e.g. <a href="https://xkqr.org/decision/">Decision Drill</a> to do a full
page reload when a user interacts with it, and it still feels like one of them
smooth <abbr>xml</abbr>HttpRequest things. Rest assured, it’s a full page reload.</li>
</ul>

<p>
But then the thing that triggered this article: <abbr>sql</abbr>ite. One of the more
powerful arguments I’ve read against <abbr>sql</abbr>ite is that it has a few warts in its
defaults, such tables being flexibly typed, foreign keys not being enforced,
primary keys being nullable, etc.
</p>

<p>
I’ve usually thought of these warts as a bad thing. Haskell has them too, like
how the built in <code>String</code> type is bad data structure for storing text, and how
we’re stuck with a bunch of misnamed functions (mapM, ap, msum, etc.) because we
didn’t know better. Oh and the list of Perl’s warts is probably longer than its
implementation.
</p>

<p>
Petros reframes this problem. Every single wart that annoys us today, used to be
a reasonable feature that someone relied on in their production code. Every wart
we see today is a testament to the care the maintainers put into backward
compatibility. If we choose a technology today, we want one that saves us from
future maintenance by keeping our wartful code running – even if we don’t yet
know it is wartful. The best indicator of this is whether the technology has
warts today.
</p>

<blockquote>
<p>
I would much rather, the first time I install an application, “enable foreign
keys” – it’s just one line of config – I’d rather do that once, build the thing
correctly, and then be confident that if there’s any other built-in behaviour
that I didn’t account for, that behaviour isn’t going to change on me and break
my application at some point in the future.
</p>
</blockquote>

<p>
Right on.
</p>

            </div></div>
  </body>
</html>
