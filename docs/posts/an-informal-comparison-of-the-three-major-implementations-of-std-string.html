<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://devblogs.microsoft.com/oldnewthing/20240510-00/?p=109742">Original</a>
    <h1>An informal comparison of the three major implementations of std:string</h1>
    
    <div id="readability-page-1" class="page"><div id="featured">

	<div>
                         <p>
            May 10th, 2024</p><!-- .entry-meta -->
        <p>We saw some time ago that <a title="Inside STL: The string" href="https://devblogs.microsoft.com/oldnewthing/20230803-00/?p=108532"> the three major implementations of <code>std::string</code> are all quite different</a>. To summarize:</p>
<pre>// gcc
struct string
{
    char* ptr;
    size_t size;
    union {
        size_t capacity;
        char buf[16];
    };

    bool is_large() { return ptr != buf; }
    auto data() { return ptr; }
    auto size() { return size; }
    auto capacity() { return is_large() ? capacity : 15; }
};

// msvc
struct string
{
    union {
        char* ptr;
        char buf[16];
    };
    size_t size;
    size_t capacity;

    bool is_large() { return capacity &gt; 15; }
    auto data() { return is_large() ? ptr : buf; }
    auto size() { return size; }
    auto capacity() { return capacity; }
};

// clang
union string
{
    struct {
        size_t capacity;
        size_t size;
        char* ptr;
    } large;

    struct {
        unsigned char is_small:1;
        unsigned char size:7;
        char buf[sizeof(large) - 1];
    } small;

    bool is_large() { return !small.is_small; }
    auto data() { return is_large() ? large.ptr : small.buf; }
    auto size() { return is_large() ? large.size : small.size; }
    auto capacity() { return is_large() ? large.capacity : sizeof(large) - 2; }
};
</pre>
<p>We’ll compare these versions based on the complexity of some commonly-used operations.</p>
<p>Detecting whether the string is small or large is a single member comparison with msvc and clang, but on gcc, it involves comparing a member against the address of another member, so it will take an extra instruction to calculate that address.</p>
<table>
<tbody>
<tr>
<th>gcc is_large</th>
<th>msvc is_large</th>
<th>clang is_large</th>
</tr>
<tr>
<td><code>lea rdx, [rcx].buf</code></td>
<td><code>cmp [rcx].capacity, 15</code></td>
<td><code>test [rcx].is_small, 1</code></td>
</tr>
</tbody>
</table>
<p>Note: gcc could have shaved an instruction by reordering the members so that the <code>buf</code> comes first (thereby avoiding the need to calculate its address). On the other hand, it increases the cost of accessing <code>ptr</code> on some processors: On the x86 family, it forces a larger encoding because the offset is nonzero. On the Itanium, it requires two instructions because the Itanium cannot perform an offset load in a single instruction. On most other processors, the offset can be folded into the load instruction at no extra cost. My guess is that gcc biased their design to optimize for x86.</p>
<p>On the other hand, gcc wins the race to access the <code>data()</code>, since the <code>ptr</code> is always valid, and that’s probably why they chose their design.</p>
<table>
<tbody>
<tr>
<th>gcc data()</th>
<th>msvc data()</th>
<th>clang data()¹</th>
</tr>
<tr>
<td><code>mov rdx, [rcx].ptr</code></td>
<td><code>lea rdx, [rcx].buf</code></td>
<td><code>lea rdx, [rcx].small.buf</code></td>
</tr>
</tbody>
</table>
<p>The clang implementation also has extra work to calculate the size.</p>
<table>
<tbody>
<tr>
<th>gcc size()</th>
<th>msvc size()</th>
<th>clang size()²</th>
</tr>
<tr>
<td><code>mov rdx, [rcx].size</code></td>
<td><code>mov rdx, [rcx].size</code></td>
<td><code>movzx rax, [rcx].small.is_small</code></td>
</tr>
</tbody>
</table>
<p>A special case of checking the size is checking whether the string is empty.</p>
<table>
<tbody>
<tr>
<th>gcc empty()</th>
<th>msvc empty()</th>
<th>clang empty()</th>
</tr>
<tr>
<td><code>cmp [rcx].size, 0</code></td>
<td><code>cmp [rcx].size, 0</code></td>
<td><code>movzx rax, [rcx].small.is_small</code></td>
</tr>
</tbody>
</table>
<p>The capacity comes into play behind the scenes when extending the string. For example, <code>append(char)</code> can do a fast-append if there is excess capacity, and delegate to a function call if the capacity needs to be increased. Here, msvc has an edge.</p>
<table>
<tbody>
<tr>
<th>gcc capacity()</th>
<th>msvc capacity()</th>
<th>clang capacity()</th>
</tr>
<tr>
<td><code>lea rax, [rcx].buf</code></td>
<td><code>mov rax, [rcx].capacity</code></td>
<td><code>test [rcx].small.is_small, 1</code></td>
</tr>
</tbody>
</table>
<p>The clang implementation does have an edge in terms of memory usage: Despite an overall smaller size, it has a larger small-string capacity in 64-bit mode.</p>
<table>
<tbody>
<tr>
<th>sizeof / SSO capacity</th>
<th>gcc</th>
<th>msvc</th>
<th>clang</th>
</tr>
<tr>
<td>32-bit mode</td>
<td>24 / 16</td>
<td>24 / 16</td>
<td>12 / 11</td>
</tr>
<tr>
<td>64-bit mode</td>
<td>32 / 16</td>
<td>32 / 16</td>
<td>24 / 22</td>
</tr>
</tbody>
</table>
<p>If you <code>reserve()</code> a lot of space for a string, but use only a little bit of it, and then call <code>shrink_<wbr/>to_<wbr/>fit()</code>, you can potentially get into a mixed state where the string is allocated externally (as if it were a large string), even though the capacity is smaller than the capacity of a small string.</p>
<p>The msvc implementation uses the capacity to detect whether it is using the small string optimization, so this mixed state is illegal for msvc, and it must convert large strings to small strings if <code>shrink_<wbr/>to_<wbr/>fit()</code> shrinks the string below the small-string threshold.</p>
<p>The gcc and clang implementations allow external allocations to have a small capacity. Nevertheless, the clang implementation does convert externally-allocated strings to small strings if they shrink below the small-string threshold.</p>
<p>The gcc implementation takes a different approach: With gcc, <code>shrink_<wbr/>to_<wbr/>fit()</code> is a nop! This is legal according to the C++ standard: The <code>shrink_<wbr/>to_<wbr/>fit()</code> method is an advisory call, and the implementation is permitted to ignore the advice.</p>
<p>One final point of comparison is how the three implementations deal with static initialization.</p>
<table>
<tbody>
<tr>
<th>gcc</th>
<th>msvc</th>
<th>clang</th>
</tr>
<tr>
<td><code>{ buf, 15, { 0 } }</code></td>
<td><code>{ { 0 }, 0, 15 }</code></td>
<td><code>{ 1, 0, 0, ... }</code></td>
</tr>
</tbody>
</table>
<p>A statically-initiaized empty string in gcc consists of a pointer to the internal buffer, a constant 15 (size), and a bunch of zeroes (buf). The presence of a pointer introduces a relocation into the data segment and <a title="Just how constexpr is C++20&#39;s std::string?" href="https://quuxplusone.github.io/blog/2023/09/08/constexpr-string-firewall/"> silently messes up string’s <code>constexpr</code>-ness</a>.</p>
<p>Statically-initiaized empty strings in msvc and clang consist of integer constant data; no pointers. This means no relocations and a better shot at <code>constexpr</code>-ness.</p>
<p>Okay, so let’s summarize all this information into a table.</p>
<table>
<tbody>
<tr>
<th> </th>
<th>gcc</th>
<th>msvc</th>
<th>clang</th>
</tr>
<tr>
<th>is_large</th>
<td>slower</td>
<td>faster</td>
<td>faster</td>
</tr>
<tr>
<th>data()</th>
<td>fast</td>
<td>slower</td>
<td>slower</td>
</tr>
<tr>
<th>size()</th>
<td>fast</td>
<td>fast</td>
<td>much slower</td>
</tr>
<tr>
<th>empty()</th>
<td>fast</td>
<td>fast</td>
<td>much slower</td>
</tr>
<tr>
<th>capacity()</th>
<td>slowest</td>
<td>fast</td>
<td>slower</td>
</tr>
<tr>
<th>32-bit size</th>
<td>24</td>
<td>24</td>
<td>12</td>
</tr>
<tr>
<th>64-bit size</th>
<td>32</td>
<td>32</td>
<td>24</td>
</tr>
<tr>
<th>32-bit SSO capacity</th>
<td>16</td>
<td>16</td>
<td>11</td>
</tr>
<tr>
<th>64-bit SSO capacity</th>
<td>16</td>
<td>16</td>
<td>22</td>
</tr>
<tr>
<th>shrink_to_fit()</th>
<td>nop</td>
<td>must convert to SSO</td>
<td>choose to convert to SSO³</td>
</tr>
<tr>
<th>Static initialization</th>
<td>relocation</td>
<td>no relocation</td>
<td>no relocation</td>
</tr>
</tbody>
</table>
<p>¹ I don’t see clang generating this slightly smaller alternative</p>
<pre>lea rdx, [rcx].small.buf
test [rcx].small.is_small, 1
cmovz rdx, [rcx].large.ptr
</pre>
<p>perhaps because the <code>cmov</code> instruction always reads from its second parameter even if the value is not used, and there might be a store-forward penalty because in the case of a small string, the read is unlikely to match the size of the previous write.</p>
<p>² I don’t see clang generating this slightly smaller alternative</p>
<pre>movzx rax, [rcx].small.is_small
shr rax, 1
jc @1
mov rax, [rcx].large.size
@1:
</pre>
<p>probably because “shift right and look at carry” is not something natively expressible in C++. If you really went for it, you could also fold in a <code>cmov</code>.</p>
<pre>movzx rax, [rcx].small.is_small
shr rax, 1
cmovnc rax, [rcx].large.size
</pre>
<p>³ Although the ABI allows the implementation to choose whether or not shrinking to an SSO-friendly size actually converts to SSO, the current implementation always converts.</p>

        

        
		
        
	</div><!-- .entry-content -->

</div></div>
  </body>
</html>
