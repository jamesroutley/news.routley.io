<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.fermyon.com/blog/introducing-spin">Original</a>
    <h1>Spin – WebAssembly Framework</h1>
    
    <div id="readability-page-1" class="page"><div> <article>   <p>We are pleased to announce our new WebAssembly framework, <a href="https://spin.fermyon.dev">Spin</a>. Spin is a foundational piece of the Fermyon Platform. It is also a great way to get started writing WebAssembly for the cloud.</p><h2>What is a WebAssembly Framework?</h2><p>We think of WebAssembly primarily <a href="https://www.fermyon.com/blog/how-to-think-about-wasm">as a compile target</a>. Pick a language, write your code, and compile it to Wasm. But what kinds of code does one write in WebAssembly?</p><p>The original way to run a WebAssembly module was in the browser. For that reason, early WebAssembly effort was focused on optimizing performance-intensive code to be executed on a web page or client-side web app.</p><p>WebAssembly has now moved beyond the browser. Some platforms, like the Envoy proxy, allow you to write <a href="https://medium.com/trendyol-tech/extending-envoy-proxy-wasm-filter-with-golang-9080017f28ea">plugins in Wasm</a>. Command line runtimes like <a href="https://wasmtime.dev">Wasmtime</a> and <a href="https://github.com/bytecodealliance/wasm-micro-runtime">WAMR</a> run Wasm binaries on the command line, allowing developers to write a single CLI application that can run on Windows, macOS, and Linux (regardless of the underlying architecture).</p><p>Here at Fermyon, we are most excited about the prospect of writing microservices and server-side web applications in WebAssembly. We gave a preview of this when we built Wagi. But with Spin, we’re taking things to a new level. Most specifically, Spin offers a framework for building apps.</p><p>What do we mean when we talk about a “framework”? A framework provides a set of features and conventions that assist a developer in reaching their desired goal faster and with less work. Ruby on Rails and Python Django are two good examples.</p><p>Spin is a framework for web apps, microservices, and other server-like applications. It provides the interfaces for writing WebAssembly modules that can do things like answer HTTP requests. One unique thing about Spin is that it is a multi-language framework. Rust and Go both have robust support in Spin, but you can also write Python, Ruby, AssemblyScript, Grain, C/C++, and other languages.</p><p>We are excited to already be using Spin in production. The <a href="https://spin.fermyon.dev/">Spin docs</a> are (appropriately enough) running on Spin. That website is powered by the <a href="https://www.fermyon.com/blog/introducing-bartholomew">Bartholomew CMS system</a> and is running on an HA <a href="https://www.nomadproject.io/">Nomad cluster</a>.</p><p>Spin is a foundational new technology that sets the pace for what we at Fermyon are building.</p><h2>Spin is a Foundation</h2><p>We have talked about the way we build applications in Spin. Part of the reason that Spin provides a framework is because by doing so, we can take advantage of some of the compelling features of WebAssembly. And in so doing, we can create <a href="https://www.fermyon.com/blog/serverless-reckoning">serverless-style programs</a> with many benefits.</p><p>Over the last few years, our discussions with developers have turned up some common themes:</p><ul><li>Ease of development is very important</li><li>Function-as-a-Service systems like Lambda are nice to develop, but frustrating to operate</li><li>Being locked into a proprietary platform is no fun</li><li>Developers are not operators, and shouldn’t have to solve operations problems</li></ul><p>As we built Spin, these ideas were foremost in our minds. We set out to build something that delivered on the promises of serverless, but had all the virtues of local development and modern frameworks. We’re building based on standards and open source tooling, and we’re working hard to please both developers and platform operators (including DevOps).</p><p>Beyond that, Spin has given us a chance to <a href="https://www.fermyon.com/blog/rethinking-microservices">rethink microservices</a>. When we built Wagi, our goal was to make something that worked with WebAssembly as it was in 2020. WebAssembly technology has gone through two highly productive years of development since then. Spin takes advantage of the new directions taken with WebAssembly, like components, WIT, and improvements to WASI (We’ll cover these things later in the post). Doing so has led us to build a framework that makes it easy for developers to achieve top-of-mind goals (like <a href="https://www.fermyon.com/blog/log4sh-and-webassembly">security</a>) without having to spend countless cycles maintaining the low-level code.</p><p>Rather than explain further, let’s just look at an example. Here’s what a <a href="https://spin.fermyon.dev/rust-components/">Spin “Hello World” looks like written in Rust</a>:</p><pre><code>#[http_component]​
fn hello_world(_req: Request) -&gt; Result&lt;Response&gt; {​
    Ok(Response::builder()​
        .status(200)​
        .body(Some(&#34;Hello, Fermyon!&#34;.into()))?)​
}​
</code></pre><p>Rust coder or not, most developers are familiar with the <a href="https://spin.fermyon.dev/http-trigger/">HTTP request/response model</a> used here. Writing a Spin module is <a href="https://spin.fermyon.dev/go-components/">not much different in Go</a>:</p><pre><code>func main() {
 spin.HandleRequest(func(w http.ResponseWriter, r *http.Request) {
  fmt.Fprintln(w, &#34;Hello, Fermyon!&#34;)
 })
}
</code></pre><p>Again, we just use the common request/response model that is <a href="https://pkg.go.dev/net/http">idiomatic for Go</a>.</p><p>Most important, though, is what we <em>don’t</em> have to do. There is no requirement that you create a web server to handle requests or start long-lived listeners or manage a pool for network connections. A Spin app can be as simple as a function. Of course, you can also add your preferred libraries to build out far more sophisticated apps… but at no time do you have to manage all of the low-level server duties like setting up SSL, handling interrupts, or wiring up sockets and ports. Such duties are delegated to Spin itself.</p><p>Following the model of stateless microservices, a Spin application can be bootstrapped, executed, and shut down again in milliseconds (or even nanoseconds if you are careful). And that means you don’t have idle WebAssembly modules hanging around consuming memory and processor space while waiting for inbound requests. Because Spin is fast, it can also be light on resources.</p><p>When you’re ready to see for yourself, Spin provides a simple <code>spin up</code> command to locally run your code.</p><p>Fermyon currently only supports a top-level HTTP request/response model for a few languages. We’re adding more. But you don’t need to wait to use Spin to run <a href="https://www.fermyon.com/wasm-languages/assemblyscript">AssemblyScript</a>, <a href="https://www.fermyon.com/wasm-languages/python">Python</a>, <a href="https://www.fermyon.com/wasm-languages/ruby">Ruby</a>, <a href="https://www.fermyon.com/wasm-languages/grain">Grain</a>, or others. Spin ships with a 100% compatible Wagi implementation. As long as your chosen language supports the <a href="https://wasi.dev/">WASI specification for files and environment variables</a>, you can use it to write Spin apps.</p><h3>Not Just HTTP</h3><p>For supported languages like <a href="https://www.fermyon.com/wasm-languages/rust">Rust</a> and <a href="https://www.fermyon.com/wasm-languages/go">Go</a>, Spin supports more than just HTTP responders. Here’s an example that <a href="https://spin.fermyon.dev/redis-trigger/">listens on a Redis channel</a>:</p><pre><code>use anyhow::Result;
use bytes::Bytes;
use spin_sdk::redis_component;
use std::str::from_utf8;

/// A simple Spin Redis component.
#[redis_component]
fn on_message(message: Bytes) -&gt; Result&lt;()&gt; {
    println!(&#34;{}&#34;, from_utf8(&amp;message)?);
    Ok(())
}
</code></pre><p>In this case, the Spin component listens for a message, and then prints the message. Every time a new message is pushed onto the relevant channel, the WebAssembly component is started, and the <code>on_message</code> function is executed. Again, this whole process happens in milliseconds. Spin is fast!</p><p>HTTP and Redis are the first two responders for Spin, and more are on the way. Jump into the discussion on <a href="https://discord.gg/FKFe5mthQB">Discord</a> or peruse the <a href="https://github.com/fermyon/spin/issues">issue queue</a> to see what else is in the works.</p><p>If you’re ready to dive in to some practical coding, you can walk through a <a href="https://spin.fermyon.dev/url-shortener/">tutorial on building a URL shortener with Spin</a>.</p><h2>Where is Fermyon Going with Spin?</h2><p>Spin is our framework, and our execution environment. Already, it has some key features that we will make use of, including:</p><ul><li>100% compatibility with <a href="https://github.com/deislabs/wagi">Wagi modules</a></li><li>Support for the <a href="https://github.com/deislabs/bindle">Bindle packaging system</a></li><li>Basic support for the <a href="https://github.com/WebAssembly/component-model">WebAssembly Component Model</a> and <a href="https://github.com/bytecodealliance/wit-bindgen/blob/main/WIT.md">WIT</a> (formerly WITX)</li><li>Existing projects like <a href="https://github.com/fermyon/bartholomew">Bartholomew</a> and <a href="https://github.com/deislabs/wagi-fileserver">Wagi-Fileserver</a> already run (without modification) on Spin</li><li>We also wrote a <a href="https://github.com/fermyon/spin-fileserver">Spin Fileserver</a> to show a useful production-ready Spin app</li></ul><p>We are hard at work linking up to storage (like key/value, object storage, and RDBMS) as well as improved support for a variety of languages. And we are working closely with <a href="https://bytecodealliance.org">Bytecode Alliance</a> to continue building standards and reference implementations.</p><p>Our goal is to build an excellent development platform for the next generation of microservices and web apps, achieving many of the goals that serverless computing has long pursued.</p><h2>Getting Involved</h2><p>As with the rest of Fermyon’s open source projects, Spin is licensed under the Apache 2 licenses. The source is hosted <a href="https://github.com/fermyon/spin">on GitHub</a>. We’re happy to receive issues and PRs in the project. We’re working hard to make our documentation top-grade. If you have any trouble, please <a href="https://github.com/fermyon/spin/issues">file an issue</a> and help us improve. We want Spin to be easy!</p><p>If you’re interested in chatting, join the <a href="https://discord.gg/FKFe5mthQB">Fermyon Discord server</a>. There’s a dedicated Spin channel, and you can also stay on top of other Fermyon news.</p><p>If you want to be the first to know what we’re up to, click the <strong>👋 Get Updates</strong> button in the top-right corner or follow us on Twitter at <a href="https://twitter.com/fermyontech">@FermyonTech</a>.</p> </article> </div></div>
  </body>
</html>
