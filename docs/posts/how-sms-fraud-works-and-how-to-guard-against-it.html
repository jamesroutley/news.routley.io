<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://apuchitnis.substack.com/p/how-sms-fraud-works-and-how-to-guard-against-it">Original</a>
    <h1>How SMS fraud works and how to guard against it</h1>
    
    <div id="readability-page-1" class="page"><div><div><article><div class=""><div><div dir="auto"><p><span>With Twitter </span><a href="https://blog.twitter.com/en_us/topics/product/2023/an-update-on-two-factor-authentication-using-sms-on-twitter" rel="nofollow ugc noopener">disabling</a><span> text message two-factor authentication, I thought it’d be fun to do a deep-dive into how SMS fraud works and how app developers can guard against it.</span></p><p>It’s a fascinating story of perverse incentives, short-sighted regulation, and technical ingenuity.</p><p>Let’s dig in! 👇</p><blockquote><p><span>Note to all subscribers of </span><a href="https://apuchitnis.substack.com/" rel="nofollow ugc noopener">Mindful Musings</a><span> — this post (and others that will follow) are part of a new series that I’m calling </span><em>Technically Thinking</em><span>. The focus of this section will be more engineering-related, with deep dives, introduction pieces, and more for engineers and hackers.</span></p><p>If that’s not your cup of tea, feel free to opt-out of Technically Thinking in your subscription — I won’t mind! 😊</p></blockquote><p>To start, let’s recap Twitter’s recent announcement:</p><p>In plain English, this simply means that only users of the paid version of Twitter will get a code sent to their phone during login.</p><p><span>The key to understanding SMS fraud is understanding that some numbers are  </span><em><a href="https://www.notion.so/6574a2f457c942f1b5ef13187e22e8b0" rel="nofollow ugc noopener">premium</a></em><span>. If you want to call or send an SMS to this number, it’ll cost </span><em>you</em><span> some money — typically tens of cents — and the owner of the number gets a portion of those tens of cents for themselves.</span></p><p>Owners of these phone numbers typically offer legitimate services that cost money to supply and offer value to their users, such as tele-voting, dating, and tech support.</p><p>However, these numbers can be gamed for easy profit 🤑</p><p><span>A bad actor, let’s call him </span><em>Bob</em><span>, gets hold of several premium phone numbers</span></p><p><span>. Bob  could be a hacker, or could be a mobile phone network operator gone bad.</span></p><p><span>Bob finds a web service that will send text messages to his premium phone numbers. These messages could be two-factor authentication codes, one time passwords, or any other text message sent to the user as part of the service (eg </span><a href="http://partiful.com" rel="nofollow ugc noopener">partiful.com</a><span> sends event reminders via SMS).</span></p><p><span>Bob finds a way to make the service send </span><em>thousands</em><span> of SMSs to his premium phone numbers. This might be very easy. The front end service might be easy to manipulate, and the backend endpoints might be unprotected and easy to reverse-engineer.</span></p><p><span>Even worse, many services use a standardised endpoint for sending SMSs. This makes it vastly easier to for Bob to find sites to attack. For example, if the service uses a third party for authenticating users and sending out 2FA or OTP codes, such as Auth0, then the endpoint for sending SMSs is mostly known: all Bob needs to do is to figure out a way to discover the Auth0’s ID for a web service (fairly easy, since the web service’s front-end makes a request containing this ID), and then they can attack </span><em>all</em><span> sites that use that third party service.</span></p><p>Finally, Bob makes the service send thousands of SMSs to his premium phone numbers. The web service loses 💵💵💵, and Bob profits.</p><p>There’s no one silver bullet to prevent SMS fraud. But here are a few ideas that could work:</p><ul><li><p>If using a third-party service to authenticate users, such as Auth0, you could obfuscate the endpoint used to send SMSs. Whilst this won’t prevent an attack outright, it does make it much harder to discover that an attack is possible.</p></li><li><p>Block all requests from IPs that originate in cloud providers, fraudulent ISPs, or are otherwise sketchy. This should be fairly simple to implement — many services exist that allow you to rate the quality of an IP address — and would probably be very effective.</p></li><li><p><span>Add IP-based </span><a href="https://en.wikipedia.org/wiki/Rate_limiting" rel="nofollow ugc noopener">rate-limiting</a><span> to the endpoint that sends out SMS to block Bob’s attack. If set up correctly, this won’t affect legitimate users. However, this only works against a simple attack. If Bob architects his attack to send requests from a variety of IP addresses — a </span><em>distributed</em><span> attack — then this wouldn’t work.</span></p></li><li><p><span>Only send an SMS to a specific phone number a small number of times before blocking that phone number for a cool-off period. We could do this on the front-end, but if Bob is determined, he could figure out the backend endpoint to attack instead. Blocking the phone number on the backend is harder: it requires keeping a record of phone numbers and their recent login attempts.</span></p></li><li><p>Force the user to solve a CAPTCHA before sending them an SMS. Whilst this approach works well at blocking attackers — solving the CAPTCHA is hard and expensive to do at scale — it does degrade the user’s experience of the service.</p></li><li><p><span>Identify and block </span><em>premium</em><span> rate phone numbers, using </span><a href="https://github.com/google/libphonenumber" rel="nofollow ugc noopener">libphonenumber</a><span>. Whilst this seems promising, I don’t know how reliable the data and how effective this approach is.</span></p></li><li><p>Only send text messages to paid accounts. This is the approach Twitter has gone with. It’s not a bad option, but as you can see from the list above, there’re many other approaches you could take.</p></li><li><p>Block mobile phone network operators with a high number of fraudulent users. This would block clearly bad network operators, but wouldn’t work well if the network has many legitimate users.</p></li></ul><p>A good solution would make use of enough of the approaches above, prioritising by time investment and effectiveness, until the attackers move onto easier targets.</p><p>I’ve got some personal experience implementing the above measures, and have a story or two to share about how my team handled the fallout. But that’s a story for another time… 👨‍💻</p><p>This brings me to my final point:</p><blockquote><p><span>IMO, Twilio — a dominant SMS API — has a </span><strong>huge</strong><span> </span><strong>opportunity</strong><span> to offer this as a (free?) add-on to their standard APIs.</span></p><p><span>Since Twilio has data on fraudulent phone numbers and carriers across all their accounts, Twilio are in the unique position to block bad numbers and carriers </span><em>fast</em><span> — before they becomes a big issue for multiple web services.</span></p></blockquote><p>I’d love to hear any other thoughts, ideas and approaches folks have used — please share by writing a comment below, and we can all learn.</p><p>That’s it for now — protect those endpoints, and have a great week!</p></div></div></div></article></div></div></div>
  </body>
</html>
