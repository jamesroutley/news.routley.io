<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.debuisne.com/writing/geo-tiles/">Original</a>
    <h1>How to build vector tiles from scratch</h1>
    
    <div id="readability-page-1" class="page"><div> <p>As I add more data to the <a href="https://dash.hudsonshipping.co">NYC Chaos Dashboard</a>, a website that maps live urban activity, I have been looking for a more efficient way to render the map.
Since I collect all of the data in one process and return the Dashboard as one HTML file, I kept wondering how I could
optimize the map’s loading time by pre-processing the data as much as possible in the backend. This is where vector tiles come in.</p>

<p>Initially, all of the map’s data was passed to the rendering library in GeoJSON format (embedded directly in the HTML file).
For those who don’t know, GeoJSON is a JSON based standard to represent geographic information. You can go see the full RFC <a href="https://www.rfc-editor.org/rfc/rfc7946">here</a>,
but here’s a quick preview of what it looks like so you can get an idea:</p>
<pre tabindex="0" data-language="json"><code><span><span>{</span></span>
<span><span>  &#34;</span><span>type</span><span>&#34;</span><span>:</span><span> &#34;</span><span>Feature</span><span>&#34;</span><span>,</span></span>
<span><span>  &#34;</span><span>geometry</span><span>&#34;</span><span>:</span><span> {</span></span>
<span><span>    &#34;</span><span>type</span><span>&#34;</span><span>:</span><span> &#34;</span><span>Point</span><span>&#34;</span><span>,</span></span>
<span><span>    &#34;</span><span>coordinates</span><span>&#34;</span><span>:</span><span> [</span><span>-74.04452395542852</span><span>,</span><span> 40.68987850656795</span><span>]</span></span>
<span><span>  },</span></span>
<span><span>  &#34;</span><span>properties</span><span>&#34;</span><span>:</span><span> {</span></span>
<span><span>    &#34;</span><span>name</span><span>&#34;</span><span>:</span><span> &#34;</span><span>Statue of Liberty</span><span>&#34;</span><span>,</span></span>
<span><span>    &#34;</span><span>status</span><span>&#34;</span><span>:</span><span> &#34;</span><span>open</span><span>&#34;</span></span>
<span><span>  }</span></span>
<span><span>}</span></span></code></pre>
<p>Now, I’m definitely not JSON’s greatest fan. It’s all text, meaning that a number is stored in a base 10 ASCII representation, where a number like <code>42</code> gets stored as <code>&#34;4&#34;</code> and <code>&#34;2&#34;</code>.
I could go on, but I think you see the problem: it’s not the most efficient way to store data. Nonetheless, JSON has a lot of merits: it’s human-readable and easy to share between systems, so I find myself using it more
than I’d like to - more often than not, simplicity is the way to go, and a simple format like GeoJSON just gets the job done, and that alone makes it a worthy geographic standard.</p>
<p>So what happens when I start adding more layers to the map? It gets slow. I’m working on adding flood sensor data (thank you <a href="https://www.floodnet.nyc/">Floodnet</a> for granting me access to the API), LIRR and MetroNorth data, NYISO power data,
and many more datasets which will start adding a lot of layers to the map. I can already see that the HTML file, at the time of writing, is <em>4.5Mb</em> (once decompressed) and takes <em>~770ms</em> to transfer from Cloudflare’s CDN to my browser.
This seems pretty reasonable for now, but it won’t scale as the future datasets are much larger, and running a quick check on the website, chrome is already telling me that the site has performance issues:
<img src="https://www.debuisne.com/_astro/chrome-unhappy-1.DOGARS3z_1pQmRC.webp" alt="Chrome not happy" width="1458" height="801" loading="lazy" decoding="async"/></p>
<p>And if I look more closely, I can see that it’s the result of a long rendering (over 2s!), which I can see here:
<img src="https://www.debuisne.com/_astro/chrome-unhappy-2.JEz4mjqZ_Z1QqoFC.webp" alt="Chrome really not happy" width="951" height="325" loading="lazy" decoding="async"/></p>
<p>Now, I suspect this is the result of a few things:</p>
<ol>
<li>As mentioned above, all of the embedded data is GeoJSON. This means the rendering library (<a href="https://maplibre.org/maplibre-gl-js/docs/">MapLibre GL JS</a>) needs to parse the JSON. There’s a lot, with a lot of properties, so this takes time.</li>
<li>MapLibre GL needs to then take the coordinates and then place the lines, points and polygons on the map accordingly. This takes time, and it all happens on your browser.</li>
</ol>
<p>I don’t like this - I want a map that people can use to check on the status of their city, and not a bloated HTML page that gets slower as more data gets onboarded, ironically making it less and less usable.</p>

<p>An obvious, and honestly wise, solution would be to simply load the GeoJSONs separately, via a GET request. You can do this simply in MapLibre:</p>
<pre tabindex="0" data-language="javascript"><code><span><span>map</span><span>.</span><span>addSource</span><span>(</span><span>&#39;</span><span>resurfacing</span><span>&#39;</span><span>,</span><span> {</span></span>
<span><span>    type</span><span>:</span><span> &#39;</span><span>geojson</span><span>&#39;</span><span>,</span></span>
<span><span>    data</span><span>:</span><span> &#39;</span><span>https://dash.hudsonshipping.co/data/resurfacing.geojson</span><span>&#39;</span></span>
<span><span>}</span><span>)</span><span>;</span></span></code></pre>
<p>This is so much better than my current solution:</p>
<pre tabindex="0" data-language="javascript"><code><span><span>map</span><span>.</span><span>addSource</span><span>(</span><span>&#39;</span><span>resurfacing</span><span>&#39;</span><span>,</span><span> {</span></span>
<span><span>    type</span><span>:</span><span> &#39;</span><span>geojson</span><span>&#39;</span><span>,</span></span>
<span><span>    data</span><span>:</span><span> {{.</span><span>Geo</span><span>.</span><span>Resurfacing</span><span>}}</span></span>
<span><span>}</span><span>)</span><span>;</span></span></code></pre>
<p><code>{{.Geo.Resurfacing}}</code> is the code in my HTML template that gets rendered in my Go process.</p>
<p>Loading GeoJSONs via a GET request will result in a lighter HTML file and a faster rendering of the Dashboard (the non-map components at least), but MapLibre still needs to parse that JSON and figure out how and where to plot the geometries.
This is still not optimal.
So how do big companies handle this? To display large amounts of data on map at scale and with performance, they use <strong>Vector Tiles</strong>, loading geometries sector by sector.</p>

<p>Vector Tiles are small files that also represent geographic features, similar to GeoJSON. The key difference is that they represent a specific sector, a <em>tile</em> (thus the name), at a specific zoom.
That means if I want to display a map of the world with Vector Tiles, it will actually be a collection of square tiles pieced together.
Imagine taking a globe and cutting it up in multiple squares - that’s what vector tiles are (we’ll ignore distortion and projections for now, that’ll be a post for another time).</p>
<p>You may already be familiar with them when interacting with online maps, like Google Maps, where you can notice your features contained in squares, with some squares loaded before others:
<img src="https://www.debuisne.com/_astro/tiles-gmaps.DwNzsc2M_Z20nsP6.webp" alt="Google Maps Tiles" width="400" height="271" loading="lazy" decoding="async"/></p>
<p>MapTiler made a <a href="https://docs.maptiler.com/google-maps-coordinates-tile-bounds-projection/">great demonstration of Tiles</a>, showing the tile coordinates at different zoom levels.</p>
<p><img src="https://www.debuisne.com/_astro/geojson-to-mvt.C2sQMDE6_gJHk3.svg" alt="GeoJSON to MVT" width="750" height="500" loading="lazy" decoding="async"/>
Unlike GeoJSON where all features (point, line or polygon) of a layer are stored in one file, Vector Tiles (MVT) store features in smaller files that represent a specific area (at a specific zoom, or resolution).
In the above image, the points from the GeoJSON file are split into 3 tiles (tile 4 being empty).</p>

<p>No, and this is where vector tiles get even more interesting. Like <a href="https://support.esri.com/en-us/gis-dictionary/raster">rasters</a>, they represent data in a specific part of the world. But unlike rasters,
vector tiles don’t store an image, they store instructions. This is very, very similar (you’ll see just how much in the next section) to a JPEG vs an SVG.
This means vector tiles contain commands to draw layers and features that can then be customized in the rendering library:</p>
<ul>
<li>Have a road you want to display as congested? Just set the line-color to red</li>
<li>Have a live event you want to display? Go for it, just add some custom animation to make the point pulsate</li>
</ul>
<p><img src="https://www.debuisne.com/_astro/mvt-file.DBqG-Dz7_gJHk3.svg" alt="MVT file" width="750" height="500" loading="lazy" decoding="async"/>
AS you can see in the above illustration, an Vector Tile file contains commands on how to plot the data using a local coordinate system, and not just a grid of pixels.</p>

<p>Ok, this is the fun part - and it’s a lot easier than I first thought it would be. We’ll use the current
standard for vector tiles, which you may have glimpsed in the previous sections: Mapbox Vector Tiles (MVT). <a href="https://maplibre.org/maplibre-gl-js/docs/API/classes/VectorTileSource/">MapLibre can handle this natively</a>, and the documentation seems
pretty easy:</p>
<pre tabindex="0" data-language="javascript"><code><span><span>map</span><span>.</span><span>addSource</span><span>(</span><span>&#39;</span><span>some id</span><span>&#39;</span><span>,</span><span> {</span></span>
<span><span>    type</span><span>:</span><span> &#39;</span><span>vector</span><span>&#39;</span><span>,</span></span>
<span><span>    tiles</span><span>:</span><span> [</span><span>&#39;</span><span>https://dash.hudsonshipping.co/{z}/{x}/{y}/tile.mvt</span><span>&#39;</span><span>]</span><span>,</span></span>
<span><span>    minzoom</span><span>:</span><span> 6</span><span>,</span></span>
<span><span>    maxzoom</span><span>:</span><span> 14</span></span>
<span><span>}</span><span>)</span><span>;</span></span></code></pre>
<p>So I need to have an endpoint that serves up MVT files for a given tile <em>(x,y)</em> at a given zoom <em>z</em>. That part isn’t too hard,
it’s a simple HTTP endpoint. So now, I need to actually be able to generate the MVT file.</p>
<p>Mapbox has done a great job documenting the spec, you can find it <a href="https://github.com/mapbox/vector-tile-spec/blob/master/2.1/README.md">here</a>.
I used this as the main reference for the project, as it contains everything you need to construct a vector tile. For all transformations, I simply used
the <a href="https://gist.githubusercontent.com/maptiler/fddb5ce33ba995d5523de9afdf8ef118/raw/d7565390d2480bfed3c439df5826f1d9e4b41761/globalmaptiles.py">code</a> made available my MapTiler.</p>
<p>An MVT represents information in binary format - this means it’s not human-readable, unlike GeoJSON. To generate the binary output,
Mapbox has opted for Protobuf. If you don’t know Protobuf, it’s Google’s standard to normalize structured data in a binary format with predefined fields and datatypes described in a <code>.proto</code> file. If you want to learn more about the project, I recommend checking <a href="https://protobuf.dev/">this</a> out. This is what the MVT proto file looks like:</p>
<pre tabindex="0" data-language="proto"><code><span><span>message</span><span> Tile</span><span> {</span></span>
<span><span>        enum</span><span> GeomType</span><span> {</span></span>
<span><span>             UNKNOWN</span><span> =</span><span> 0</span><span>;</span></span>
<span><span>             POINT</span><span> =</span><span> 1</span><span>;</span></span>
<span><span>             LINESTRING</span><span> =</span><span> 2</span><span>;</span></span>
<span><span>             POLYGON</span><span> =</span><span> 3</span><span>;</span></span>
<span><span>        }</span></span>
<span></span>
<span><span>        message</span><span> Value</span><span> {</span></span>
<span><span>                optional</span><span> string</span><span> string_value</span><span> =</span><span> 1</span><span>;</span></span>
<span><span>                optional</span><span> float</span><span> float_value</span><span> =</span><span> 2</span><span>;</span></span>
<span><span>                optional</span><span> double</span><span> double_value</span><span> =</span><span> 3</span><span>;</span></span>
<span><span>                optional</span><span> int64</span><span> int_value</span><span> =</span><span> 4</span><span>;</span></span>
<span><span>                optional</span><span> uint64</span><span> uint_value</span><span> =</span><span> 5</span><span>;</span></span>
<span><span>                optional</span><span> sint64</span><span> sint_value</span><span> =</span><span> 6</span><span>;</span></span>
<span><span>                optional</span><span> bool</span><span> bool_value</span><span> =</span><span> 7</span><span>;</span></span>
<span></span>
<span><span>                extensions 8 to max;</span></span>
<span><span>        }</span></span>
<span><span>        message</span><span> Feature</span><span> {</span></span>
<span><span>                optional</span><span> uint64</span><span> id</span><span> =</span><span> 1</span><span> [ default = </span><span>0</span><span> ]</span><span>;</span></span>
<span><span>                repeated</span><span> uint32</span><span> tags</span><span> =</span><span> 2</span><span> [ packed = </span><span>true</span><span> ]</span><span>;</span></span>
<span><span>                optional</span><span> GeomType</span><span> type</span><span> =</span><span> 3</span><span> [ default = </span><span>UNKNOWN</span><span> ]</span><span>;</span></span>
<span><span>                repeated</span><span> uint32</span><span> geometry</span><span> =</span><span> 4</span><span> [ packed = </span><span>true</span><span> ]</span><span>;</span></span>
<span><span>        }</span></span>
<span></span>
<span><span>        message</span><span> Layer</span><span> {</span></span>
<span><span>                required</span><span> uint32</span><span> version</span><span> =</span><span> 15</span><span> [ default = </span><span>1</span><span> ]</span><span>;</span></span>
<span><span>                required</span><span> string</span><span> name</span><span> =</span><span> 1</span><span>;</span></span>
<span><span>                repeated</span><span> Feature</span><span> features</span><span> =</span><span> 2</span><span>;</span></span>
<span><span>                repeated</span><span> string</span><span> keys</span><span> =</span><span> 3</span><span>;</span></span>
<span><span>                repeated</span><span> Value</span><span> values</span><span> =</span><span> 4</span><span>;</span></span>
<span><span>                optional</span><span> uint32</span><span> extent</span><span> =</span><span> 5</span><span> [ default = </span><span>4096</span><span> ]</span><span>;</span></span>
<span></span>
<span><span>                extensions 16 to max;</span></span>
<span><span>        }</span></span>
<span></span>
<span><span>        repeated</span><span> Layer</span><span> layers</span><span> =</span><span> 3</span><span>;</span></span>
<span><span>        extensions 16 to 8191;</span></span>
<span><span>}</span></span></code></pre>
<p>Ok, so looking at the proto, we can see that a tile is essentially an array of layers, each layer being able to contain multiple features.
To make this more understandable, here’s an example of what you could put in a tile:</p>
<ul>
<li>
<p>Layer 1: Monuments</p>
<ul>
<li>Feature 1: Statue of Liberty (type: Point)</li>
<li>Feature 2: Eiffel Tower (type: Point)</li>
</ul>
</li>
<li>
<p>Layer 2: Airports</p>
<ul>
<li>Feature 1: JFK (type: Point)</li>
<li>Feature 2: CDG (type: Point)</li>
</ul>
</li>
</ul>
<p>We’ll use this example throughout this section to construct a tile, and specifically focus on the Statue of Liberty. We can see that a layer represents a dataset you want to display on a map,
and a feature is a datapoint in that dataset. A tile can contain multiple layers, and thus multiple datasets. At a certain resolution,
we expect the Statue of Liberty to be in the same tile as the JFK airport, same for the Eiffel Tower and CDG, meaning they’ll be in the same MVT file.</p>
<p>Ok, so now we understand what’s contained in a tile. But how do you actually construct it?
Here are the steps required:</p>
<ol>
<li>For a given zoom level, identify what tile (x, y) a feature belongs to</li>
<li>Create the tile and add the geometry</li>
<li>Add properties via tags</li>
<li>Return the tile via HTTP</li>
</ol>
<h2 id="1-identifying-the-tiles">1. Identifying the tiles</h2>
<p>Let’s restate the problem we’re trying to solve: we have a GeoJSON file that we want to convert into multiple MVT tiles for performance reasons.
As stated earlier, to use MVT tiles in MapLibre we need to be able to return a response for:</p>
<pre tabindex="0" data-language="plaintext"><code><span><span>https://dash.hudsonshipping.co/{z}/{x}/{y}/tile.mvt</span></span></code></pre>
<p>So, this means I need to have multiple tiles generated in the backend, and return the correct one. But how do I know what tile each feature belongs to?
For example, when I am currently at zoom level 9, I can see that the the Statue of Liberty will be in the tile <code>x = 150, y = 192</code>:
<img src="https://www.debuisne.com/_astro/tile-selection-1.CmSvNVbd_UantI.webp" alt="Selecting the right tile at zoom 9" width="750" height="500" loading="lazy" decoding="async"/>
And if I zoom to level 10, I can see that the Statue of Liberty will be in the tile
<code>x = 301, y = 385</code>:
<img src="https://www.debuisne.com/_astro/tile-selection-2.CWEub5wZ_Z10YFAm.webp" alt="Selecting the right tile at zoom 10" width="750" height="500" loading="lazy" decoding="async"/></p>
<p>To properly identify the tile, we need to do a few conversions. At this point, all of my geographic data is normalized to use EPSG:4326, a format most people are familiar with to represent coordinates. For example,
the Statue of Liberty’s coordinates in EPSG:4326, expressed in degrees, are:</p>
<p><code>longitude:-74.04452395542852, latitude: 40.68987850656795</code>.</p>
<p>For vector tiles, the coordinate system used is called Web Mercator (EPSG:3857). In this system, expressed in meters, the
Statue is Liberty is located at:</p>
<p><code>x = -8242598.70274865, y = 4966705.869136138</code></p>
<p>So we need to convert the Statue of Liberty’s coordinates from degrees to meters, and then identify which square it belongs to at a specific
zoom level. This is pretty straight forward, so let’s get right to it.</p>
<p>Let’s finally get our hands dirty and write some code (please add proper error handling, this code is only for demonstration purposes).</p>
<p>First off, I want to convert my coordinates from <code>EPSG:4326</code> (lon/lat) to <code>EPSG:3857</code> (meters):</p>
<pre tabindex="0" data-language="go"><code><span><span>// We will use these constants throughout</span></span>
<span><span>const</span><span> (</span></span>
<span><span>	EarthRadius</span><span> =</span><span> 6378137</span><span> // meters</span></span>
<span><span>	TileSize</span><span>    =</span><span> 512</span><span> // pixels</span></span>
<span><span>	OriginShift</span><span> =</span><span> 2</span><span> *</span><span> math</span><span>.</span><span>Pi</span><span> *</span><span> EarthRadius</span><span> /</span><span> 2.0</span></span>
<span><span>)</span></span>
<span></span>
<span><span>func</span><span> LonLatToMeters</span><span>(</span><span>lon</span><span> float64</span><span>,</span><span> lat</span><span> float64</span><span>)</span><span> (</span><span>x</span><span> float64</span><span>,</span><span> y</span><span> float64</span><span>)</span><span> {</span></span>
<span><span>	mx</span><span> :=</span><span> lon</span><span> *</span><span> OriginShift</span><span> /</span><span> 180.0</span></span>
<span><span>	my</span><span> :=</span><span> math</span><span>.</span><span>Log</span><span>(</span><span>math</span><span>.</span><span>Tan</span><span>((</span><span>90</span><span> +</span><span> lat</span><span>)</span><span> *</span><span> math</span><span>.</span><span>Pi</span><span> /</span><span> 360.0</span><span>))</span><span> /</span><span> (</span><span>math</span><span>.</span><span>Pi</span><span> /</span><span> 180.0</span><span>)</span></span>
<span><span>	my</span><span> =</span><span> my</span><span> *</span><span> OriginShift</span><span> /</span><span> 180.0</span></span>
<span><span>	return</span><span> mx</span><span>,</span><span> my</span></span>
<span><span>}</span></span></code></pre>
<p>The spec refers to 4096 tile sizes, but <a href="https://github.com/maplibre/maplibre-gl-js/blob/6d02b8fbdd4b0cd2573adbcafb30cbc6e823f4b5/src/source/vector_tile_source.ts#L99">MapLibre seems to use 512 pixels</a>, so we’ll stick with this.
Once we’ve successfully written the function to convert our coordinates, we can now write the code to get the appropriate tile:</p>
<pre tabindex="0" data-language="go"><code><span><span>func</span><span> Resolution</span><span>(</span><span>zoom</span><span> int</span><span>)</span><span> float64</span><span> {</span></span>
<span><span>	// Returns meters / pixel</span></span>
<span><span>	initialResolution</span><span> :=</span><span> 2</span><span> *</span><span> math</span><span>.</span><span>Pi</span><span> *</span><span> EarthRadius</span><span> /</span><span> TileSize</span></span>
<span><span>	return</span><span> initialResolution</span><span> /</span><span> (</span><span>math</span><span>.</span><span>Pow</span><span>(</span><span>2</span><span>,</span><span> float64</span><span>(</span><span>zoom</span><span>)))</span></span>
<span><span>}</span></span>
<span></span>
<span><span>func</span><span> MetersToTile</span><span>(</span><span>mx</span><span> float64</span><span>,</span><span> my</span><span> float64</span><span>,</span><span> zoom</span><span> int</span><span>)</span><span> (</span><span>x</span><span> int</span><span>,</span><span> y</span><span> int</span><span>)</span><span> {</span></span>
<span><span>	res</span><span> :=</span><span> Resolution</span><span>(</span><span>zoom</span><span>)</span><span> // meters / pixel</span></span>
<span><span>	px</span><span> :=</span><span> (</span><span>mx</span><span> +</span><span> OriginShift</span><span>)</span><span> /</span><span> res</span></span>
<span><span>	py</span><span> :=</span><span> (</span><span>my</span><span> +</span><span> OriginShift</span><span>)</span><span> /</span><span> res</span></span>
<span></span>
<span><span>	tx</span><span> :=</span><span> int</span><span>(</span><span>math</span><span>.</span><span>Ceil</span><span>(</span><span>px</span><span> /</span><span> float64</span><span>(</span><span>TileSize</span><span>))</span><span> -</span><span> 1</span><span>)</span></span>
<span><span>	ty</span><span> :=</span><span> int</span><span>(</span><span>math</span><span>.</span><span>Ceil</span><span>(</span><span>py</span><span> /</span><span> float64</span><span>(</span><span>TileSize</span><span>))</span><span> -</span><span> 1</span><span>)</span></span>
<span><span>	return</span><span> tx</span><span>,</span><span> ty</span></span>
<span><span>}</span></span>
<span></span>
<span><span>func</span><span> GoogleTile</span><span>(</span><span>tx</span><span> int</span><span>,</span><span> ty</span><span> int</span><span>,</span><span> zoom</span><span> int</span><span>)</span><span> (</span><span>x</span><span> int</span><span>,</span><span> y</span><span> int</span><span>)</span><span> {</span></span>
<span><span>	ty</span><span> =</span><span> int</span><span>(</span><span>math</span><span>.</span><span>Pow</span><span>(</span><span>2</span><span>,</span><span> float64</span><span>(</span><span>zoom</span><span>))</span><span>-</span><span>1</span><span>)</span><span> -</span><span> ty</span></span>
<span><span>	return</span><span> tx</span><span>,</span><span> ty</span></span>
<span><span>}</span></span></code></pre>
<p>Once we have these utility functions, determining the appropriate tile only requires a few lines of code:</p>
<pre tabindex="0" data-language="go"><code><span><span>mx</span><span>,</span><span> my</span><span>   :=</span><span> LonLatToMeters</span><span>(</span><span>lon</span><span>,</span><span> lat</span><span>)</span></span>
<span><span>tx</span><span>,</span><span> ty</span><span>   :=</span><span> MetersToTile</span><span>(</span><span>mx</span><span>,</span><span> my</span><span>,</span><span> zoom</span><span>)</span></span>
<span><span>gtx</span><span>,</span><span> gty</span><span> :=</span><span> GoogleTile</span><span>(</span><span>tx</span><span>,</span><span> ty</span><span>,</span><span> zoom</span><span>)</span></span></code></pre>
<p>We use <code>GoogleTile()</code> because it seems MapLibre uses this standard (simply shift the origin to the top left). I couldn’t find documentation on it,
but I was able to see this behavior during my tests. I’ll update this part if I find the relevant documentation.</p>
<p>Here is what we now have:</p>
<ol>
<li><code>mx</code> and <code>my</code> are the point’s coordinates in meters, using the Web Mercator projection.</li>
<li><code>tx</code> and <code>ty</code> are the tile coordinates in <a href="https://en.wikipedia.org/wiki/Tile_Map_Service"><code>TMS</code> format</a>.</li>
<li><code>gtx</code> and <code>gty</code> are the tile coordinates in Google format (also known as the XYZ format).</li>
</ol>
<p>Great, we know what tile our feature belongs to for a given zoom. Let’s go create the tile.</p>
<h2 id="2-create-the-tile-and-add-the-geometry">2. Create the tile and add the geometry</h2>
<p>Now that we know which tile a feature belongs to, let’s create the MVT file. You’ll need to install protoc for Go:</p>
<pre tabindex="0" data-language="shell"><code><span><span>go</span><span> install</span><span> google.golang.org/protobuf/cmd/protoc-gen-go@latest</span></span></code></pre>
<p>Go ahead and get the official .proto here: <a href="https://github.com/mapbox/vector-tile-spec/blob/master/2.1/vector_tile.proto">https://github.com/mapbox/vector-tile-spec/blob/master/2.1/vector_tile.proto</a></p>
<p>Generate the struct:</p>
<pre tabindex="0" data-language="shell"><code><span><span>protoc</span><span> --go_out=./path/to/dir/mvt</span><span> ./path/to/dir/mvt/vector_tile.proto</span></span></code></pre>
<p>This will generate a <code>vector_tile.pb.go</code> that will look something like this:</p>
<pre tabindex="0" data-language="go"><code><span><span>// Code generated by protoc-gen-go. DO NOT EDIT.</span></span>
<span><span>// versions:</span></span>
<span><span>// 	protoc-gen-go v1.36.8</span></span>
<span><span>// 	protoc        v3.21.12</span></span>
<span><span>// source: internal/geo/mvt/vector_tile.proto</span></span>
<span></span>
<span><span>package</span><span> mvt </span><span>// Make sure to use the correct package here</span></span>
<span></span>
<span><span>import</span><span> (</span></span>
<span><span>	protoreflect</span><span> &#34;</span><span>google.golang.org/protobuf/reflect/protoreflect</span><span>&#34;</span></span>
<span><span>	protoimpl</span><span> &#34;</span><span>google.golang.org/protobuf/runtime/protoimpl</span><span>&#34;</span></span>
<span><span>	reflect</span><span> &#34;</span><span>reflect</span><span>&#34;</span></span>
<span><span>	sync</span><span> &#34;</span><span>sync</span><span>&#34;</span></span>
<span><span>	unsafe</span><span> &#34;</span><span>unsafe</span><span>&#34;</span></span>
<span><span>)</span></span>
<span></span>
<span><span>const</span><span> (</span></span>
<span><span>	// Verify that this generated code is sufficiently up-to-date.</span></span>
<span><span>	_</span><span> =</span><span> protoimpl</span><span>.</span><span>EnforceVersion</span><span>(</span><span>20</span><span> -</span><span> protoimpl</span><span>.</span><span>MinVersion</span><span>)</span></span>
<span><span>	// Verify that runtime/protoimpl is sufficiently up-to-date.</span></span>
<span><span>	_</span><span> =</span><span> protoimpl</span><span>.</span><span>EnforceVersion</span><span>(</span><span>protoimpl</span><span>.</span><span>MaxVersion</span><span> -</span><span> 20</span><span>)</span></span>
<span><span>)</span></span>
<span></span>
<span><span>// GeomType is described in section 4.3.4 of the specification</span></span>
<span><span>type</span><span> Tile_GeomType </span><span>int32</span></span>
<span></span>
<span><span>const</span><span> (</span></span>
<span><span>	Tile_UNKNOWN</span><span>    Tile_GeomType </span><span>=</span><span> 0</span></span>
<span><span>	Tile_POINT</span><span>      Tile_GeomType </span><span>=</span><span> 1</span></span>
<span><span>	Tile_LINESTRING</span><span> Tile_GeomType </span><span>=</span><span> 2</span></span>
<span><span>	Tile_POLYGON</span><span>    Tile_GeomType </span><span>=</span><span> 3</span></span>
<span><span>)</span></span>
<span><span>// ...</span></span></code></pre>
<p>Once we have generated the protobuf class, we can create an empty tile like this:</p>
<pre tabindex="0" data-language="go"><code><span><span>func</span><span> NewTile</span><span>(</span><span>layerName</span><span> string</span><span>)</span><span> *</span><span>Tile </span><span>{</span></span>
<span><span>    // The Tile struct comes from the generated protobuf</span></span>
<span><span>	version</span><span> :=</span><span> uint32</span><span>(</span><span>0</span><span>)</span></span>
<span><span>	extent</span><span> :=</span><span> uint32</span><span>(</span><span>TileSize</span><span>)</span></span>
<span><span>	layers</span><span> :=</span><span> []</span><span>*</span><span>Tile_Layer</span><span>{</span></span>
<span><span>	    {</span></span>
<span><span>	        Name</span><span>:</span><span>     &amp;</span><span>layerName</span><span>,</span></span>
<span><span>	        Version</span><span>:</span><span>  &amp;</span><span>version</span><span>,</span></span>
<span><span>	        Features</span><span>:</span><span> make</span><span>([]</span><span>*</span><span>Tile_Feature</span><span>,</span><span> 0</span><span>),</span></span>
<span><span>	        Extent</span><span>:</span><span>   &amp;</span><span>extent</span><span>,</span></span>
<span><span>	    },</span></span>
<span><span>	}</span></span>
<span><span>	return</span><span> &amp;</span><span>Tile</span><span>{</span><span>Layers</span><span>:</span><span> layers</span><span>}</span></span>
<span><span>}</span></span>
<span><span>t</span><span> =</span><span> NewTile</span><span>(</span><span>&#34;</span><span>monuments</span><span>&#34;</span><span>)</span></span></code></pre>
<p>Great, we now have an empty tile. Let’s add our monument to ut, as a feature in the first layer called <code>monuments</code>.
A feature is defined by a few things:</p>
<ul>
<li>A geometry type, in our case a Point</li>
<li>Tags (properties for that feature, which we’ll add in the next section)</li>
<li>A geometry</li>
</ul>
<p>As mentioned earlier, a vector tile behaves similarly to an SVG file: you specify instructions to move a cursor. And that’s
exactly what goes into the geometry field: a series of instructions for a cursor.
Since our monument is a Point, we only have one instruction: move to location <code>(x, y)</code>:
<img src="https://www.debuisne.com/_astro/mvt-instructions.B5NLLLay_gJHk3.svg" alt="MVT instructions" width="750" height="500" loading="lazy" decoding="async"/></p>
<p>As you can see in the above example, we’re telling the cursor to move from the Origin to a specific part of the tile.
In this case, we’re letting MapLibre GL know to move the cursor 200 pixels to the right (x axis) and 75 pixels down (y axis).</p>
<p>But how do we get these instructions? Instructions are relative to the Origin of the tile, which is located at the top-left corner.
Coordinates go from 0 to 512 (the <code>Extent</code> of the tile, which we defined above).:
<img src="https://www.debuisne.com/_astro/mvt-coordinates.Bc2L7DDF_gJHk3.svg" alt="MVT coordinate system" width="750" height="500" loading="lazy" decoding="async"/></p>
<p>This means we need a few things:</p>
<ul>
<li>Get the Web Mercator coordinates of the tile’s Origin</li>
<li>Calculate the offset, <code>dx</code> and <code>dy</code> for a given Point</li>
<li>Convert the offset in meters to an offset in pixels</li>
</ul>
<p>Getting the tile’s origin is pretty straight forward:</p>
<pre tabindex="0" data-language="go"><code><span><span>func</span><span> GetTileOrigin</span><span>(</span><span>tx</span><span> int</span><span>,</span><span> ty</span><span> int</span><span>,</span><span> zoom</span><span> int</span><span>)</span><span> (</span><span>minx</span><span> int64</span><span>,</span><span> maxy</span><span> int64</span><span>)</span><span> {</span></span>
<span><span>	res</span><span> :=</span><span> Resolution</span><span>(</span><span>zoom</span><span>)</span></span>
<span><span>	minX</span><span> :=</span><span> int64</span><span>(</span><span>float64</span><span>(</span><span>tx</span><span>)</span><span> *</span><span> TileSize</span><span> *</span><span> res</span><span> -</span><span> OriginShift</span><span>)</span></span>
<span><span>	maxY</span><span> :=</span><span> int64</span><span>(</span><span>float64</span><span>(</span><span>ty</span><span> +</span><span> 1</span><span>)</span><span> *</span><span> TileSize</span><span> *</span><span> res</span><span> -</span><span> OriginShift</span><span>)</span></span>
<span><span>	return</span><span> minX</span><span>,</span><span> maxY</span></span>
<span><span>}</span></span>
<span><span>originX</span><span>,</span><span> originY</span><span> :=</span><span> TileBounds</span><span>(</span><span>tx</span><span>,</span><span> ty</span><span>,</span><span> zoom</span><span>)</span></span></code></pre>
<p>Now that we have the Origin’s coordinates in meters, let’s calculate the offsets <code>dx</code> and <code>dy</code>:</p>
<pre tabindex="0" data-language="go"><code><span><span>dx</span><span> :=</span><span> mx</span><span> -</span><span> originX</span></span>
<span><span>dy</span><span> :=</span><span> originY</span><span> -</span><span> my</span></span></code></pre>
<p>Finally, let’s divide the offsets by the resolution, expressed in meters / pixel, to get the parameters for the instruction:</p>
<pre tabindex="0" data-language="go"><code><span><span>res</span><span> :=</span><span> Resolution</span><span>(</span><span>zoom</span><span>)</span></span>
<span><span>shiftX</span><span> :=</span><span> uint32</span><span>(</span><span>math</span><span>.</span><span>Floor</span><span>(</span><span>float64</span><span>(</span><span>dx</span><span>)</span><span> /</span><span> res</span><span>))</span></span>
<span><span>shiftY</span><span> :=</span><span> uint32</span><span>(</span><span>math</span><span>.</span><span>Floor</span><span>(</span><span>float64</span><span>(</span><span>dy</span><span>)</span><span> /</span><span> res</span><span>))</span></span></code></pre>
<p>We now have everything we need to construct our feature:</p>
<pre tabindex="0" data-language="go"><code><span><span>geomType</span><span> :=</span><span> Tile_POINT</span></span>
<span><span>feature</span><span> :=</span><span> Tile_Feature</span><span>{</span></span>
<span><span>    Type</span><span>:</span><span> &amp;</span><span>geomType</span><span>,</span></span>
<span><span>    Geometry</span><span>:</span><span> []</span><span>uint32</span><span>{</span></span>
<span><span>        1</span><span> &amp;</span><span> 0x</span><span>7</span><span> |</span><span> 1</span><span> &lt;&lt;</span><span> 3</span><span>,</span><span> // Command 1 (moveTo), count of 1</span></span>
<span><span>        (</span><span>shiftX</span><span> &lt;&lt;</span><span> 1</span><span>)</span><span> ^</span><span> (</span><span>shiftX</span><span> &gt;&gt;</span><span> 31</span><span>),</span></span>
<span><span>        (</span><span>shiftY</span><span> &lt;&lt;</span><span> 1</span><span>)</span><span> ^</span><span> (</span><span>shiftY</span><span> &gt;&gt;</span><span> 31</span><span>),</span></span>
<span><span>    },</span></span>
<span><span>}</span></span></code></pre>
<p>The geometry is a little odd, but here’s what’s happening:</p>
<ul>
<li>We pass in a slice of instructions, which is made up of a command followed by parameters</li>
<li>To place a Point, we use the command <code>moveTo</code>, to move the cursor</li>
<li>This command expects two parameters, <code>dX</code> and <code>dY</code>, which we pass in using <code>zigzag</code> encoding</li>
</ul>
<p>We can go ahead and add this feature to our tile:</p>
<pre tabindex="0" data-language="go"><code><span><span>t</span><span>.</span><span>Layers</span><span>[</span><span>0</span><span>].</span><span>Features</span><span> =</span><span> append</span><span>(</span><span>t</span><span>.</span><span>Layers</span><span>[</span><span>0</span><span>].</span><span>Features</span><span>,</span><span> &amp;</span><span>feature</span><span>)</span></span></code></pre>
<h2 id="3-add-properties">3. Add properties</h2>
<p>We now have a tile that meets the basic requirements:</p>
<ul>
<li>1 layer</li>
<li>1 feature in the layer with a valid geometry</li>
</ul>
<p>I now want to add the properties defined in the GeoJSON, in this case, the name and the status for the Statue of Liberty.</p>
<p>As with GeoJSON, you can store properties for each feature. So here, the status could be one of three:</p>
<ol>
<li><code>open</code>: Open for visit.</li>
<li><code>closed</code>: Closed for visit.</li>
<li><code>maintenance</code>: Closed for maintenance.</li>
</ol>
<p>Adding the status <code>open</code> to the Statue of Liberty in GeoJSON looks like this:</p>
<pre tabindex="0" data-language="json"><code><span><span>{</span></span>
<span><span>  &#34;</span><span>type</span><span>&#34;</span><span>:</span><span> &#34;</span><span>Feature</span><span>&#34;</span><span>,</span></span>
<span><span>  &#34;</span><span>geometry</span><span>&#34;</span><span>:</span><span> {</span></span>
<span><span>    &#34;</span><span>type</span><span>&#34;</span><span>:</span><span> &#34;</span><span>Point</span><span>&#34;</span><span>,</span></span>
<span><span>    &#34;</span><span>coordinates</span><span>&#34;</span><span>:</span><span> [</span><span>-74.04452395542852</span><span>,</span><span> 40.68987850656795</span><span>]</span></span>
<span><span>  },</span></span>
<span><span>  &#34;</span><span>properties</span><span>&#34;</span><span>:</span><span> {</span></span>
<span><span>    &#34;</span><span>name</span><span>&#34;</span><span>:</span><span> &#34;</span><span>Statue of Liberty</span><span>&#34;</span><span>,</span></span>
<span><span>    &#34;</span><span>status</span><span>&#34;</span><span>:</span><span> &#34;</span><span>open</span><span>&#34;</span></span>
<span><span>  }</span></span>
<span><span>}</span></span></code></pre>
<p>So, if I have 10’000 monuments, I’ll have 10,000 dictionaries like this:</p>
<pre tabindex="0" data-language="json"><code><span><span>&#34;</span><span>properties</span><span>&#34;</span><span>: </span><span>{</span></span>
<span><span>    &#34;</span><span>name</span><span>&#34;</span><span>:</span><span> &#34;</span><span>&lt;Monument Name&gt;</span><span>&#34;</span><span>,</span></span>
<span><span>    &#34;</span><span>status</span><span>&#34;</span><span>:</span><span> &#34;</span><span>&lt;Monument Status&gt;</span><span>&#34;</span></span>
<span><span>  }</span></span></code></pre>
<p>That means repeating <code>open</code>, <code>closed</code> or <code>maintenance</code> 10,000 times. Best case scenario, that’s 40,000 bytes (<code>open</code> 10,000 times),
and you probably want a unique name for your monument, so add another 10,000 strings to your file.
You can definitely improve this by shortening the status to something like <code>o</code> for <code>open</code>, and <code>s</code> for <code>status</code>, but this will only
get you so far as you scale (especially if you’re dealing with numbers, where these tricks won’t work) and add more properties and features.</p>
<p>Vector Tiles use a different approach: <strong>tags</strong>. In each layer, you define a set of keys and a set of values.
In our previous example, the keys would be <code>[name, status]</code> and the values would be <code>[Statue of Liberty, open, closed, maintenance]</code>:
<img src="https://www.debuisne.com/_astro/mvt-tags.CxRsRkDB_gJHk3.svg" alt="MVT tags" width="750" height="500" loading="lazy" decoding="async"/></p>
<p>So let’s add the known keys and values to our layer:</p>
<pre tabindex="0" data-language="go"><code><span><span>t</span><span>.</span><span>Layers</span><span>[</span><span>0</span><span>].</span><span>Keys</span><span> =</span><span> []</span><span>string</span><span>{</span><span>&#34;</span><span>name</span><span>&#34;</span><span>,</span><span> &#34;</span><span>status</span><span>&#34;</span><span>}</span></span>
<span></span>
<span><span>SoLName</span><span> :=</span><span> &#34;</span><span>Statue of Liberty</span><span>&#34;</span></span>
<span><span>StatusOpen</span><span> :=</span><span> &#34;</span><span>open</span><span>&#34;</span></span>
<span><span>StatusClosed</span><span> :=</span><span> &#34;</span><span>closed</span><span>&#34;</span></span>
<span><span>StatusMaintenance</span><span> :=</span><span> &#34;</span><span>maintenance</span><span>&#34;</span></span>
<span><span>t</span><span>.</span><span>Layers</span><span>[</span><span>0</span><span>].</span><span>Values</span><span> =</span><span> []</span><span>*</span><span>Tile_Value</span><span>{</span></span>
<span><span>    {</span><span>StringValue</span><span>:</span><span> &amp;</span><span>SoLName</span><span>},</span><span>           // 0</span></span>
<span><span>    {</span><span>StringValue</span><span>:</span><span> &amp;</span><span>StatusOpen</span><span>},</span><span>        // 1</span></span>
<span><span>    {</span><span>StringValue</span><span>:</span><span> &amp;</span><span>StatusClosed</span><span>},</span><span>      // 2</span></span>
<span><span>    {</span><span>StringValue</span><span>:</span><span> &amp;</span><span>StatusMaintenance</span><span>},</span><span> // 3</span></span>
<span><span>}</span></span></code></pre>
<p>Now that our layer knows what keys and values to expect, we can go ahead and set the property for the Statue of Liberty:</p>
<pre tabindex="0" data-language="go"><code><span><span>t</span><span>.</span><span>Layers</span><span>[</span><span>0</span><span>].</span><span>Features</span><span>[</span><span>0</span><span>].</span><span>Tags</span><span> =</span><span> []</span><span>uint32</span><span>{</span><span>0</span><span>,</span><span> 0</span><span>,</span><span> 1</span><span>,</span><span> 1</span><span>}</span><span> // name: Statue of Liberty, status: open</span></span></code></pre>
<p>If we wanted to update the status to inform users the Statue of Liberty is closed for maintenance, we would simply update the tags to:</p>
<pre tabindex="0" data-language="go"><code><span><span>t</span><span>.</span><span>Layers</span><span>[</span><span>0</span><span>].</span><span>Features</span><span>[</span><span>0</span><span>].</span><span>Tags</span><span> =</span><span> []</span><span>uint32</span><span>{</span><span>0</span><span>,</span><span> 0</span><span>,</span><span> 1</span><span>,</span><span> 3</span><span>}</span><span> // name: Statue of Liberty, status: maintenance</span></span></code></pre>
<h2 id="4-return-the-tile-via-http">4. Return the tile via HTTP</h2>
<p>Our tile <code>t</code> isready to be returned to the frontend via an HTTP GET request.
To convert our tile to the MVT binary, simply use:</p>
<pre tabindex="0" data-language="go"><code><span><span>import</span><span> 	&#34;</span><span>github.com/gogo/protobuf/proto</span><span>&#34;</span></span>
<span></span>
<span><span>out</span><span>,</span><span> _</span><span> :=</span><span> proto</span><span>.</span><span>Marshal</span><span>(</span><span>t</span><span>)</span></span></code></pre>
<p><code>out</code> contains the <code>[]byte</code> data that represents the .mvt file. Be sure to set the following header in your HTTP response:</p>
<pre tabindex="0" data-language="plaintext"><code><span><span>&#34;Content-Type&#34; : &#34;application/vnd.mapbox-vector-tile&#34;</span></span></code></pre>
<p>And there it is - a vector tile built entirely from scratch, using geographic information contained in a GeoJSON file.
When you’re using a map, you’ll almost always be visualizing more than one tile at a time, and zooming in and out. This means
each feature will be on multiple tiles, one per zoom level, so you’ll need to design a strategy to handle this. The below code is
a quick snippet of the implementation used for the Dashboard (some of the HTTP code is using an internal library, it can easily be replaced with
your own HTTP server implementation / library):</p>
<pre tabindex="0" data-language="go"><code><span><span>type</span><span> TileMap </span><span>struct</span><span> {</span></span>
<span><span>	Tiles</span><span> map</span><span>[</span><span>int</span><span>]</span><span>map</span><span>[</span><span>int</span><span>]</span><span>map</span><span>[</span><span>int</span><span>]</span><span>*</span><span>Tile </span><span>// [z][x][y]Tile</span></span>
<span><span>}</span></span>
<span></span>
<span><span>func</span><span> NewTileMap</span><span>()</span><span> *</span><span>TileMap </span><span>{</span></span>
<span><span>	tiles</span><span> :=</span><span> make</span><span>(</span><span>map</span><span>[</span><span>int</span><span>]</span><span>map</span><span>[</span><span>int</span><span>]</span><span>map</span><span>[</span><span>int</span><span>]</span><span>*</span><span>Tile</span><span>)</span></span>
<span><span>	for</span><span> _</span><span>,</span><span> zoom</span><span> :=</span><span> range</span><span> Zooms</span><span> {</span></span>
<span><span>		tiles</span><span>[</span><span>zoom</span><span>]</span><span> =</span><span> make</span><span>(</span><span>map</span><span>[</span><span>int</span><span>]</span><span>map</span><span>[</span><span>int</span><span>]</span><span>*</span><span>Tile</span><span>)</span></span>
<span><span>	}</span></span>
<span><span>	return</span><span> &amp;</span><span>TileMap</span><span>{</span><span>Tiles</span><span>:</span><span> tiles</span><span>}</span></span>
<span><span>}</span></span>
<span></span>
<span><span>func</span><span> (</span><span>tm </span><span>*</span><span>TileMap</span><span>)</span><span> GetTile</span><span>(</span><span>z</span><span> int</span><span>,</span><span> x</span><span> int</span><span>,</span><span> y</span><span> int</span><span>)</span><span> *</span><span>Tile </span><span>{</span></span>
<span><span>	if</span><span> xyMap</span><span>,</span><span> zExists</span><span> :=</span><span> tm</span><span>.</span><span>Tiles</span><span>[</span><span>z</span><span>];</span><span> zExists</span><span> {</span></span>
<span><span>		if</span><span> yMap</span><span>,</span><span> xExists</span><span> :=</span><span> xyMap</span><span>[</span><span>x</span><span>];</span><span> xExists</span><span> {</span></span>
<span><span>			if</span><span> tile</span><span>,</span><span> yExists</span><span> :=</span><span> yMap</span><span>[</span><span>y</span><span>];</span><span> yExists</span><span> {</span></span>
<span><span>				return</span><span> tile</span></span>
<span><span>			}</span></span>
<span><span>		}</span></span>
<span><span>	}</span></span>
<span><span>	return</span><span> nil</span></span>
<span><span>}</span></span>
<span><span>tm</span><span> :=</span><span> NewTileMap</span><span>()</span></span>
<span></span>
<span><span>// Generate the tiles here and populate the tile map using the above code</span></span>
<span><span>// ...</span></span>
<span></span>
<span><span>h</span><span>.</span><span>PublicHandler</span><span>(</span><span>&#34;</span><span>GET</span><span>&#34;</span><span>,</span><span> &#34;</span><span>/layer/potholes/{z}/{x}/{y}/tile.mvt</span><span>&#34;</span><span>,</span><span> func</span><span>(</span><span>r</span><span> *</span><span>http</span><span>.</span><span>Request</span><span>)</span><span> web</span><span>.</span><span>HttpResp </span><span>{</span></span>
<span><span>		z</span><span> :=</span><span> r</span><span>.</span><span>PathValue</span><span>(</span><span>&#34;</span><span>z</span><span>&#34;</span><span>)</span></span>
<span><span>		x</span><span> :=</span><span> r</span><span>.</span><span>PathValue</span><span>(</span><span>&#34;</span><span>x</span><span>&#34;</span><span>)</span></span>
<span><span>		y</span><span> :=</span><span> r</span><span>.</span><span>PathValue</span><span>(</span><span>&#34;</span><span>y</span><span>&#34;</span><span>)</span></span>
<span><span>		zInt</span><span>,</span><span> _</span><span> :=</span><span> strconv</span><span>.</span><span>Atoi</span><span>(</span><span>z</span><span>)</span></span>
<span><span>		xInt</span><span>,</span><span> _</span><span> :=</span><span> strconv</span><span>.</span><span>Atoi</span><span>(</span><span>x</span><span>)</span></span>
<span><span>		yInt</span><span>,</span><span> _</span><span> :=</span><span> strconv</span><span>.</span><span>Atoi</span><span>(</span><span>y</span><span>)</span></span>
<span><span>		var</span><span> out</span><span> []</span><span>byte</span></span>
<span><span>		if</span><span> tm</span><span> ==</span><span> nil</span><span> {</span></span>
<span><span>			out</span><span>,</span><span> _</span><span> =</span><span> proto</span><span>.</span><span>Marshal</span><span>(</span><span>mvt</span><span>.</span><span>NewTile</span><span>(</span><span>&#34;</span><span>empty</span><span>&#34;</span><span>))</span></span>
<span><span>		}</span><span> else</span><span> {</span></span>
<span><span>			tile</span><span> :=</span><span> tm</span><span>.</span><span>GetTile</span><span>(</span><span>zInt</span><span>,</span><span> xInt</span><span>,</span><span> yInt</span><span>)</span></span>
<span><span>			out</span><span>,</span><span> err</span><span> =</span><span> proto</span><span>.</span><span>Marshal</span><span>(</span><span>tile</span><span>)</span></span>
<span><span>			if</span><span> err</span><span> !=</span><span> nil</span><span> {</span></span>
<span><span>				// Generate an empty tile</span></span>
<span><span>				out</span><span>,</span><span> _</span><span> =</span><span> proto</span><span>.</span><span>Marshal</span><span>(</span><span>mvt</span><span>.</span><span>NewTile</span><span>(</span><span>&#34;</span><span>empty</span><span>&#34;</span><span>))</span></span>
<span><span>			}</span></span>
<span><span>		}</span></span>
<span><span>		return</span><span> web</span><span>.</span><span>HttpResp</span><span>{</span></span>
<span><span>			Data</span><span>:</span><span>        out</span><span>,</span></span>
<span><span>			StatusCode</span><span>:</span><span>  http</span><span>.</span><span>StatusOK</span><span>,</span></span>
<span><span>			ContentType</span><span>:</span><span> &#34;</span><span>application/vnd.mapbox-vector-tile</span><span>&#34;</span><span>,</span></span>
<span><span>		}</span></span>
<span><span>	})</span></span></code></pre>
<p>We’ve now created an HTTP server that returns MVT files on demand, as a user explores the map.</p>
<h2 id="did-the-performance-improve">Did the performance improve?</h2>
<p>After deploying the MVT tile server for my GeoJSON layers that contain points, this is what we get:</p>
<ul>
<li>File size decreased to 3.7Mb (I mean, we removed GeoJSON data, so no surprise there), meaning the site now loads in 500ms</li>
<li>The paint time has decreased (by about 200ms, not bad for migrating just 2 datasets over), and the performance score went up by 8% according to Lighthouse:
<img src="https://www.debuisne.com/_astro/improvement.C-JWtcI3_1JjPpF.webp" alt="Yay" width="877" height="862" loading="lazy" decoding="async"/></li>
</ul>
<p>I’m running this process off of a server in my office, and I use Cloudflare Tunnels to expose the site, which unfortunately means
the tiles don’t return very fast. This means I’m going to have to move this over to AWS, something I’ve been meaning to do, and I expect
the tiles to return a lot faster, hopefully sub 100ms.</p>
<p>I still have to move over the non-Point layers that are still GeoJSON, so I expect a big gain in performance there. More soon!</p>
<h2 id="whats-next">What’s next?</h2>
<p>This simple example only focuses on Points. Implementing lines and polygons requires more work, as they can span multiple tiles.
I’ll put out a new post once I’ve implemented these, along with performance metrics of the <a href="https://dash.hudsonshipping.co">Dashboard</a>.</p>
<p>I’m also looking forward to seeing <a href="https://github.com/maplibre/maplibre-tile-spec">MapLibre tiles</a> ready for production use, so I can generate MapLibre tiles
and get some additional performance gain and contribute to the MapLibre ecosystem.</p>
<p>I’m working on making the Go code open source in a small geographic library, which I’ll put on Hudson Shipping Co’s <a href="https://github.com/hudsonshipping">github</a>.</p>
<h3 id="thank-you">Thank you!</h3>
<p>Thank you for reading until the end! Feel free to reach out to me at <a href="https://www.debuisne.com/cdn-cgi/l/email-protection#3e5f505a4c5b7e5a5b5c4b574d505b105d5153"><span data-cfemail="50313e342235103435322539233e357e333f3d">[email protected]</span></a> for comments or questions.</p> </div></div>
  </body>
</html>
