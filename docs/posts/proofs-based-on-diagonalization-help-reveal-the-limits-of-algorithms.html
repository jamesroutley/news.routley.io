<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.quantamagazine.org/alan-turing-and-the-power-of-negative-thinking-20230905/">Original</a>
    <h1>Proofs based on diagonalization help reveal the limits of algorithms</h1>
    
    <div id="readability-page-1" class="page"><div><p>Algorithms have become ubiquitous. They optimize our commutes, process payments and coordinate the flow of internet traffic. It seems that for every problem that can be articulated in precise mathematical terms, there’s an algorithm that can solve it, at least in principle.</p>
<p>But that’s not the case — some seemingly simple problems can never be solved algorithmically. The pioneering computer scientist Alan Turing <a href="https://londmathsoc.onlinelibrary.wiley.com/doi/abs/10.1112/plms/s2-42.1.230">proved</a> the existence of such “uncomputable” problems nearly a century ago, in the same paper where he formulated the <a href="https://www.quantamagazine.org/alan-turings-most-important-machine-was-never-built-20230503/">mathematical model of computation</a> that launched modern computer science.</p>
<p>Turing proved this groundbreaking result using a counterintuitive strategy: He defined a problem that simply rejects every attempt to solve it.</p>
<p>“I ask you what you’re doing, and then I say, ‘No, I’m going to do something different,’” said <a href="https://toc.csail.mit.edu/user/351">Rahul Ilango</a>, a graduate student at the Massachusetts Institute of Technology studying theoretical computer science.</p>
<p>Turing’s strategy was based on a mathematical technique called diagonalization that has a distinguished history. Here’s a simplified account of the logic behind his proof.</p>
<h2><strong>String Theory      </strong></h2>
<p>Diagonalization stems from a clever trick for solving a mundane problem that involves strings of bits, each of which can be either 0 or 1. Given a list of such strings, all equally long, can you generate a new string that isn’t on the list?</p>
<p>The most straightforward strategy is to consider each possible string in turn. Suppose you have five strings, each five bits long. Start by scanning the list for 00000. If it’s not there, you can stop; if it is, you move on to 00001 and repeat the process. This is simple enough, but it’s slow for long lists of long strings.</p>
<p>Diagonalization is an alternate approach that builds up a missing string bit by bit. Start with the first bit of the first string on the list and invert it — that’ll be the first bit of your new string. Then invert the second bit of the second string and use that as the second bit of the new string, and repeat until you get to the end of the list. The bits you flip ensure that the new string differs from every string on the original list in at least one place. (They also form a diagonal line through the list of strings, giving the technique its name.)</p>

<p>Diagonalization only needs to examine one bit from each string on the list, so it’s often much faster than other methods. But its true power lies in how well it plays with infinity.</p>
<p>“The strings can now be infinite; the list can be infinite — it still works,” said <a href="https://people.csail.mit.edu/rrw/">Ryan Williams</a>, a theoretical computer scientist at MIT.</p>
<p>The first person to harness this power was Georg Cantor, the founder of the mathematical subfield of set theory. In 1873, Cantor used diagonalization to prove that some infinities are <a href="https://www.quantamagazine.org/how-many-numbers-exist-infinity-proof-moves-math-closer-to-an-answer-20210715/">larger than others</a>. Six decades later, Turing adapted Cantor’s version of diagonalization to the theory of computation, giving it a distinctly contrarian flavor.</p>
<h2><strong>The Limitation Game</strong></h2>
<p>Turing wanted to prove the existence of mathematical problems that no algorithm can solve — that is, problems with well-defined inputs and outputs but no foolproof procedure for getting from input to output. He made this vague task more manageable by focusing exclusively on decision problems, where the input can be any string of 0s and 1s and the output is either 0 or 1.</p>

<p>Determining whether a number is prime (divisible only by 1 and itself) is one example of a decision problem — given an input string representing a number, the correct output is 1 if the number is prime and 0 if it isn’t. Another example is checking computer programs for syntax errors (the equivalent of grammatical mistakes). There, input strings represent code for different programs — all programs can be represented this way, since that’s how they’re stored and executed on computers — and the goal is to output 1 if the code contains a syntax error and 0 if it doesn’t.</p>
<p>An algorithm solves a problem only if it produces the correct output for every possible input — if it fails even once, it’s not a general-purpose algorithm for that problem. Ordinarily, you’d first specify the problem you want to solve and then try to find an algorithm that solves it. Turing, in search of unsolvable problems, turned this logic on its head — he imagined an infinite list of all possible algorithms and used diagonalization to construct an obstinate problem that would thwart every algorithm on the list.</p>
<p>Imagine a rigged game of 20 questions, where rather than starting with a particular object in mind, the answerer invents an excuse to say no to each question. By the end of the game, they’ve described an object defined entirely by the qualities it lacks.</p>
<p>Turing’s diagonalization proof is a version of this game where the questions run through the infinite list of possible algorithms, repeatedly asking, “Can this algorithm solve the problem we’d like to prove uncomputable?”</p>
<p>“It’s sort of ‘infinity questions,’” Williams said.</p>
<p>To win the game, Turing needed to craft a problem where the answer is no for every algorithm. That meant identifying a particular input that makes the first algorithm output the wrong answer, another input that makes the second one fail, and so on. He found those special inputs using a trick similar to one Kurt Gödel had recently used to <a href="https://www.quantamagazine.org/how-godels-proof-works-20200714/">prove</a> that self-referential assertions like “this statement is unprovable” spelled trouble for the foundations of mathematics.</p>

<p>The key insight was that every algorithm (or program) can be represented as a string of 0s and 1s. That means, as in the example of the error-checking program, that an algorithm can take the code of another algorithm as an input. In principle, an algorithm can even take its own code as an input.</p>
<p>With this insight, we can define an uncomputable problem like the one in Turing’s proof: “Given an input string representing the code of an algorithm, output 1 if that algorithm outputs 0 when its own code is the input; otherwise, output 0.” Every algorithm that tries to solve this problem will produce the wrong output on at least one input — namely, the input corresponding to its own code. That means this perverse problem can’t be solved by any algorithm whatsoever.</p>
<h2><strong>What Negation Can’t Do</strong></h2>
<p>Computer scientists weren’t yet through with diagonalization. In 1965, Juris Hartmanis and Richard Stearns adapted Turing’s argument to <a href="https://www.cambridge.org/core/journals/journal-of-symbolic-logic/article/abs/j-hartmanis-and-r-e-stearns-on-the-computational-complexity-of-algorithms-transactions-of-the-american-mathematical-society-vol-117-1965-pp-285306/755FBE08C14CDA3DB5FC46BD73984293">prove</a> that not all computable problems are created equal — some are intrinsically harder than others. That result launched the field of computational complexity theory, which studies the difficulty of computational problems.</p>
<p>But complexity theory also revealed the limits of Turing’s contrary method. In 1975, Theodore Baker, John Gill and Robert Solovay <a href="https://epubs.siam.org/doi/10.1137/0204037">proved</a> that many open questions in complexity theory can never be resolved by diagonalization alone. Chief among these is the famous P versus NP problem, which asks whether all problems with easily checkable solutions are also easy to solve with the right ingenious algorithm.</p>
<p>Diagonalization’s blind spots are a direct consequence of the high level of abstraction that makes it so powerful. Turing’s proof didn’t involve any uncomputable problem that might arise in practice — instead, it concocted such a problem on the fly. Other diagonalization proofs are similarly aloof from the real world, so they can’t resolve questions where real-world details matter.</p>
<p>“They handle computation at a distance,” Williams said. “I imagine a guy who is dealing with viruses and accesses them through some glove box.”</p>

<p>The failure of diagonalization was an early indication that solving the P versus NP problem would be <a href="https://www.quantamagazine.org/complexity-theorys-50-year-journey-to-the-limits-of-knowledge-20230817/">a long journey</a>. But despite its limitations, diagonalization remains one of the key tools in complexity theorists’ arsenal. In 2011, Williams used it together with a raft of other techniques to <a href="https://ieeexplore.ieee.org/document/5959801">prove</a> that a certain restricted model of computation couldn’t solve some extraordinarily hard problems — a result that had eluded researchers for 25 years. It was a far cry from resolving P versus NP, but it still represented major progress.</p>
<p>If you want to prove that something’s not possible, don’t underestimate the power of just saying no.</p>
</div></div>
  </body>
</html>
