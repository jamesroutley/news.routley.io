<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://30fps.net/pages/pvs-portals-and-quake/">Original</a>
    <h1>Portals and Quake</h1>
    
    <div id="readability-page-1" class="page"><div id="text">

<blockquote>
<p>This is the first installment in the “Demystifying the PVS” series.</p>
<ol type="1">
<li><strong>Portals and Quake</strong></li>
<li><a href="https://30fps.net/pages/pvs-coarse-visibility/">Coarse base visibility</a></li>
<li><a href="https://30fps.net/pages/pvs-fine-visibility/">Fine visibility via clipping</a></li>
<li>Portal flow brings it all together (to be published)</li>
</ol>
</blockquote>
<figure>
<img src="https://30fps.net/pages/pvs-portals-and-quake/e1m1_pvs.jpg" alt="Precomputed visibility in Quake’s first level. The camera location is shown in red."/>
<figcaption aria-hidden="true">Precomputed visibility in Quake’s first level. The camera location is shown in red.</figcaption>
</figure>
<p><em>Ever wanted to know how exactly did Quake’s precomputed visibility work?
I did, so I wrote <a href="https://github.com/pekkavaa/vis.py">vis.py</a>, a reimplementation of their algorithm in Python.
This guide has all the information you need to understand <strong>vis</strong>, the tool used by Quake, Half-Life and Source Engine games.</em></p>
<p>During the development of Quake, <em>overdraw</em> became a concern.
It means the same pixel getting written many times during the rendering of a frame.
Only the last color stays visible and the earlier writes go to waste.
This is bad if your game is software rendered and already pushing the mid 90’s PCs to their limits.</p>
<p>How to reduce overdraw?
Let’s begin with a very high-level overview of the solution landscape.</p>
<h2 id="portal-culling-helps-with-overdraw">Portal culling helps with overdraw</h2>
<p>In 3D games, it’s a good idea to reduce the number of drawn objects.
<!-- The earlier they can get culled, the better. -->
<em>Frustum culling</em> is one fundamental method for this, in which objects confirmed to be outside the virtual camera’s view are skipped during rendering.
This can be done for example with object bounding boxes or bounding spheres.</p>
<p>Frustum culling still leaves some performance on the table.
Many objects may still be within the field of view of the camera even if they don’t contribute any pixels to the final image. This is not a performance catastrophe if everything is rendered from front to back.
GPU’s early-z testing will help here.
Still, in large worlds it would be faster to never submit these objects for rendering in the first place.</p>
<p><em>Occlusion culling</em> is a process where you discard objects that you deem to lie behind other objects in the scene. Its purpose is to discard as many <em>occluded</em> objects as possible. It’s not strictly needed, since you’ll get the correct image thanks to the z-buffer anyway. There are a few ways to do this such as the hierarchical z-buffer, occlusion queries, portal culling, and potentially visible sets (PVS). In this article I talk about the last two: portals and the PVS.</p>
<p>In portal culling, the world is divided into spaces where the virtual camera can move around and the openings between them. The spaces are called <em>cells</em>, <em>viewcells</em>, <em>zones</em>, <em>clusters</em> or <em>sectors</em>, and the openings <em>portals</em>. This is a useful split especially in architectural models with cleanly separated rooms connected by doorways or windows.
It also works for mostly-indoor video game levels :)</p>
<figure>
<img src="https://30fps.net/pages/pvs-portals-and-quake/portals_topdown_crop.png" alt="The floorplan of our example level with three hand-placed portals shown. Cells have the color of their entry portal. In this case also the cell where the camera lies is visible."/>
<figcaption aria-hidden="true">The floorplan of our example level with three hand-placed portals shown. Cells have the color of their entry portal. In this case also the cell where the camera lies is visible.</figcaption>
</figure>
<p>Portal rendering starts from the camera’s cell.
The game renders everything inside that cell, and then recursively looks into portals leading away from that first cell to find out what else to draw.
It renders all objects in every cell and then examines the cell’s portals.
If a portal doesn’t line up with another one on screen, it won’t be visited.
Each successive portal shrinks the visible screen area smaller and smaller until the whole portal is clipped away.</p>
<p>A straightforward way to test portals for visibility is to intersect their screenspace bounding boxes.
Those are shown in white in the picture below.
If two bounding boxes overlap, we can see through the respective portals.
More accurate tests can be performed with 3D clipping or per-pixel operations.</p>
<figure>
<img src="https://30fps.net/pages/pvs-portals-and-quake/portals_sprite.jpg" alt="This is how three portals could look in game. Portal openings are shown as colored polygons and their screenspace bounding boxes are in white. Objects have dashed bounding boxes. The star object is culled because it doesn’t overlap with the red portal."/>
<figcaption aria-hidden="true">This is how three portals could look in game. Portal openings are shown as colored polygons and their screenspace bounding boxes are in white. Objects have dashed bounding boxes. The star object is culled because it doesn’t overlap with the red portal.</figcaption>
</figure>
<p>The Quake engine uses portals but only during map preparation time.
At runtime, the portals are nowhere to be seen.
This technique is a variant of Seth Teller’s PVS method presented <a href="https://www2.eecs.berkeley.edu/Pubs/TechRpts/1992/CSD-92-708.pdf">in his 1992 dissertation</a> that only worked with axis-aligned walls.</p>
<h2 id="portals-of-a-quake-map-disappear">Portals of a Quake map disappear</h2>
<p>Often portals are placed by hand by a level designer. Quake’s <strong>bsp</strong> map compilation tool places portals automatically, which is nice, but unfortunately it creates a lot of them!</p>
<figure>
<img src="https://30fps.net/pages/pvs-portals-and-quake/e1m1_start_withportals.jpg" alt="Quake’s first map viewed in the TrenchBroom map editor with portals shown in red. As you can see, not just doorways act as portals."/>
<figcaption aria-hidden="true">Quake’s first map viewed in the TrenchBroom map editor with portals shown in red. As you can see, not just doorways act as portals.</figcaption>
</figure>
<p>You see, in Quake the cells are very small.
But no portals are tested at runtime.
Instead, each cell gets a precomputed list of other cells that can been seen from it.
This is the <em>Potentially Visible Set</em> (PVS) for that cell.</p>
<p>In Quake, a cell is a small convex volume of space, so a single room will usually get split into multiple cells.
These cells correspond to leaves of a binary space partitioning (BSP) tree.
The BSP tree was used to divide the map into cells and portals.
For us, the exact method is irrelevant though.
But BSP does make it easy to find the cell the camera is in at runtime.</p>
<p>Since we have now entered the Quake territory in our discussion, I’ll start calling a cell a <em>leaf</em>.
Leaf is the term used in all source code, level editors, error messages, and other resources on Quake.
The meaning stays exactly the same though, it’s just a convex cell connected to other cells via portals.
This is how leaves look in our example level:</p>
<figure>
<img src="https://30fps.net/pages/pvs-portals-and-quake/colored_leaves.png" alt="The example map divided to convex leaves. Leaf colors are random."/>
<figcaption aria-hidden="true">The example map divided to convex leaves. Leaf colors are random.</figcaption>
</figure>
<p>The portals appear in between leaves, as expected:</p>
<figure>
<img src="https://30fps.net/pages/pvs-portals-and-quake/example_top_notextures_small.png" alt="Portals placed automatically by the bsp tool. This map is pretty much 2D but everything discussed works just fine in 3D too. Leaf indices are shown in white."/>
<figcaption aria-hidden="true">Portals placed automatically by the <strong>bsp</strong> tool. This map is pretty much 2D but everything discussed works just fine in 3D too. Leaf indices are shown in white.</figcaption>
</figure>
<p>Nothing would’ve stopped them from grouping multiple leaves to form larger cells with fewer portals in between.
In fact, this is exactly what they did for Quake 2 with its “clusters” of leaves.</p>
<p>With larger clusters of leaves, you do get more overdraw.
Also, a cluster made of convex leaves may not be convex itself any more.
But even in that case you can still act as if it still is, and assume the portals inside can be seen from anywhere in the cluster.
It’s less accurate but works.</p>
<!-- More overdraw 
I don't know how they clusters looked for Quake 2.
assume other portals to be visible and just render a bit too much in the worst case.

and may not be convex (I don't know if that was the case for Quake 2).
In general, the cells in a portal system don't have to be convex.
I mean it's neat, since you can be sure that all portals of a cell are visible to each other (unless coplanar). -->
<h2 id="high-level-overview-of-vis">High-level overview of vis</h2>
<p>The Quake map tool <strong>vis</strong> takes in portals generated by another tool, <strong>bsp</strong>, precomputes a leaf-to-leaf visibility matrix, and writes the matrix back to the compiled map file.
This article series describes how <strong>vis</strong> functions.</p>
<p>We know that leaves can see each other only through portals.
So we don’t even need to know how exactly the leaves look like, only how they are connected together.</p>
<p>At its most basic level, <strong>vis</strong> does two recursive depth-first traversals, followed by a quick resolve pass before writing the visibility results back to a compiled map file. Three steps:</p>
<ol type="1">
<li><strong>Base visibility.</strong> Estimate a coarse leaf-to-portal visibility.</li>
<li><strong>Full visibility.</strong> Refine the coarse results via portal clipping.</li>
<li><strong>Resolve.</strong> Combine the refined portal-to-leaf results to the final leaf-to-leaf visibility.</li>
</ol>
<p>For a quick visual overview, I can recommend Matthew Earl’s <a href="https://www.youtube.com/watch?v=IfCRHSIg6zo">great video on Quake’s PVS</a>.</p>
<h3 id="portals-have-a-direction">Portals have a direction</h3>
<p>In a portal system, the cells and portals are structured as a cell-and-portal graph.
Quake’s map tooling follows this pattern and connects leaves with portals, even though this structure isn’t present at runtime.
Leafs are connected by portals:</p>
<figure>
<img src="https://30fps.net/pages/pvs-portals-and-quake/undirected_graph.png" alt="Leaves (nodes) connected by portals (edges) in a cell-and-portal graph."/>
<figcaption aria-hidden="true">Leaves (nodes) connected by portals (edges) in a cell-and-portal graph.</figcaption>
</figure>
<p>Each portal is a 3D polygon.
They are written by <strong>bsp</strong> to a plain text file with a version code, the number of leaves and portals, followed by one portal per line. Like this:</p>
<pre><code>PRT1
11
12
4 0 1 (880 -224 -8 ) (880 -272 -8 ) (880 -272 72 ) (880 -224 72 ) 
4 1 2 (832 -224 -8 ) (832 -272 -8 ) (832 -272 72 ) (832 -224 72 ) 
4 2 4 (768 -272 -8 ) (768 -320 -8 ) (768 -320 72 ) (768 -272 72 ) 
4 2 3 (768 -112 72 ) (768 -112 -8 ) (768 -160 -8 ) (768 -160 72 ) 
4 3 5 (720 -112 72 ) (720 -112 -8 ) (720 -160 -8 ) (720 -160 72 ) 
4 4 5 (720 -272 -8 ) (720 -320 -8 ) (720 -320 72 ) (720 -272 72 ) 
4 5 6 (640 -224 -8 ) (640 -288 -8 ) (640 -288 72 ) (640 -224 72 ) 
4 6 7 (592 -224 -8 ) (592 -288 -8 ) (592 -288 72 ) (592 -224 72 ) 
4 7 10 (384 -304 -8 ) (384 -368 -8 ) (384 -368 72 ) (384 -304 72 ) 
4 7 8 (384 -112 -8 ) (384 -176 -8 ) (384 -176 72 ) (384 -112 72 ) 
4 8 9 (240 -176 -8 ) (336 -176 -8 ) (336 -176 72 ) (240 -176 72 ) 
4 9 10 (240 -304 -8 ) (336 -304 -8 ) (336 -304 72 ) (240 -304 72 ) </code></pre>
<p>Each portal is a loop of 3D points:</p>
<pre><code>┌ the number of points
│ 
▽      x    y    z   x     y    z    x    y   z     x    y   z
4 0 1 (880 -224 -8 ) (880 -272 -8 ) (880 -272 72 ) (880 -224 72 ) 
  △ △ 
  └─┴─ the two leaves the portal is in between</code></pre>
<p>Since portals are interfaces between convex leaves, the polygons are also convex.
In 3D, a portal looks like this:</p>
<figure>
<img src="https://30fps.net/pages/pvs-portals-and-quake/portal_onedirection.jpg" alt="Each portal is stored as a convex polygon."/>
<figcaption aria-hidden="true">Each portal is stored as a convex polygon.</figcaption>
</figure>
<p>Conceptually, each portal is a two way opening. You can see through it in both directions.
However, it’s convenient to make the portals directed.
This way we can keep track on what’s visible in different directions.
We give each portal a normal vector, the direction the portal can be seen through.</p>
<p>Now a single input portal becomes two directed portals:</p>
<figure>
<img src="https://30fps.net/pages/pvs-portals-and-quake/portal_two_directions.jpg" alt="Each input portal is split into a so called forward (red) and backward (yellow) portal before processing. There’s a small gap here for demonstration purposes but actually they overlap. The arrows show the directions the portals can be seen through."/>
<figcaption aria-hidden="true">Each input portal is split into a so called forward (red) and backward (yellow) portal before processing.
There’s a small gap here for demonstration purposes but actually they overlap.
The arrows show the directions the portals can be seen through.</figcaption>
</figure>
<p>Therefore the graph will now have directed edges instead:</p>
<figure>
<img src="https://30fps.net/pages/pvs-portals-and-quake/directed_graph_with_colors.png" alt="Each portal is represented by two edges in the graph. The earlier forward and backwards portal edges are highlighted with red and gold, respectively."/>
<figcaption aria-hidden="true">Each portal is represented by two edges in the graph. The earlier forward and backwards portal edges are highlighted with red and gold, respectively.</figcaption>
</figure>
<h3 id="the-graph-in-code">The graph in code</h3>
<p>Now is the time to present the main data structures of <strong>vis.py</strong>, the <a href="https://github.com/pekkavaa/vis.py/blob/main/portaltypes.py"><strong>Portal</strong> and <strong>Leaf</strong> classes</a>:</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span>class</span> Portal:</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  winding: <span>list</span>[np.ndarray]   <span># polygon&#39;s 3D points</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  leaf: <span>int</span>                   <span># the leaf this portal leads to</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  plane: Plane                <span># plane normal points to destination leaf</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  ...                         <span># (other class attributes omitted)</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span>class</span> Leaf:</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>  portals: <span>list</span>[<span>int</span>]    <span># indices of portals leading away from this leaf</span></span></code></pre></div>
<p>Note that a leaf stores only indices of portals <em>leading away</em> from that leaf.
The graph is stored in two global arrays called <strong>portals</strong> and <strong>leaves</strong> with objects of the respective types.
Since the graph is accessed both via indices and direct object references, I came up with the following naming convention:</p>
<ul>
<li><code>pi</code> is the index of a portal, <code>Pi</code> is the actual object <code>Pi = portals[pi]</code>, and</li>
<li><code>li</code> is the index of a leaf, <code>Li</code> is the actual object <code>Li = leaves[li]</code>.</li>
</ul>
<p>Our goal is to compute which nodes can reach each other in this graph while honoring the 3D visibility relations between portals associated with each edge.
But what on earth are those “visibility relations”?</p>
<p><em>In <a href="https://30fps.net/pages/pvs-coarse-visibility/">the next part</a> we’ll use the graph for some quick checks.</em></p>
<hr/>
<p><em>I’m also thinking of writing a book. <a href="https://30fps.net/book">Sign up here</a> if you’re interested.</em></p>



</div></div>
  </body>
</html>
