<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.bowerbyte.com/posts/blocky-planet/">Original</a>
    <h1>Making Minecraft Spherical</h1>
    
    <div id="readability-page-1" class="page"><div data-astro-cid-kcr6xuaf=""> <div data-astro-cid-kcr6xuaf="">  <div data-astro-cid-egg7nqdx=""> <p>Blocky Planet is a tech demo I created in the <!-- add attributes and maintain a <slot /> for the link text --><a href="https://unity.com/" target="_blank" rel="noopener noreferrer">Unity game engine</a> that attempts to map Minecraft’s cubic voxels onto a spherical planet. The planet is procedurally generated and fully destructible, allowing players to place or remove more than 20 different block types.</p>
<p>While much of the implementation relies on common techniques you’d expect from your average Kirkland brand Minecraft clone, the spherical structure introduces a number of unique design considerations. This post will focus on these more novel challenges.</p>
<h2 id="faq">FAQ</h2>
<p><strong>How can I play it?</strong></p>
<p>The latest build is available for free on my Itch.io page <!-- add attributes and maintain a <slot /> for the link text --><a href="https://bowerbyte.itch.io/blocky-planet" target="_blank" rel="noopener noreferrer">here</a>. While it’s optimized to run natively for Windows, there is a playable web build available to run in the browser (<em>some jankiness may apply</em>).</p>
<p><strong>Why did you make this?</strong></p>
<p>I was inspired by an old <!-- add attributes and maintain a <slot /> for the link text --><a href="https://jordanpeck.me/2015/02/voxel-planet/" target="_blank" rel="noopener noreferrer">tech demo</a> by Jordan Peck that I happened to stumble across. As someone who loves procedural geometry and voxel games, recreating it seemed like a fun challenge. There were also some missing features that I hoped to implement in my version (block textures, large-scale destruction, etc.).</p>
<p><strong>Are you going to make this into a full game?</strong></p>
<p>Probably not, or at least not to a level of polish I would feel comfortable charging for. Unfortunately working full time doesn’t leave much room for these side projects, and the amount of work to go from tech demo to finished product can be monumental. Though there’s a good chance I’ll push an update from time to time.</p>
<p><strong>How long did it take to make?</strong></p>
<p>It took me a little over a month to code, during which time I was able to dedicate about 15 hours per week. I did have previous experience with voxels, so the main challenge was just making it spherical. Ironically, it took over twice as long to write/illustrate this blog post.</p>
<p><strong>What did you use to make it?</strong></p>
<p>I built the project with Unity 6 using C#. While I made heavy use of Unity’s Job system and Burst compiler, I didn’t opt to go all in on <!-- add attributes and maintain a <slot /> for the link text --><a href="https://unity.com/dots" target="_blank" rel="noopener noreferrer">DOTS</a>. From my (admittedly limited) understanding, it seems like a significant amount of effort for a small-to-moderate performance gain, while still lacking in some basic features.</p>
<p><strong>Can I see the source code?</strong></p>
<p>Not currently, but I may make it public later. The current state of the code isn’t the <em>cleanest</em>, so my sense of pride prevents me from sharing it.</p>
<p><strong>Which texture pack did you use for the blocks?</strong></p>
<p>All textures were <em>painstakingly</em> crafted by yours truly, either using a pixel art editor or programmatically via scripts. On an unrelated note, a surprising amount of Minecraft textures can be approximated by color-tinting random noise.</p>
<p><strong>I have a cool idea or question for you. Where should I ask it?</strong></p>
<p>Great! Please leave any questions or feedback on the corresponding reddit post <!-- add attributes and maintain a <slot /> for the link text --><a href="https://www.reddit.com/user/Bowerbyte/comments/1myy3cm/blocky_planet_making_minecraft_spherical/" target="_blank" rel="noopener noreferrer">here</a>.</p>
<p>If a suggestion is reasonable I might just add it (no promises though).</p>
<h2 id="lets-get-spherical">Let’s Get Spherical</h2>
<p>Building a sphere out of blocks — while tricky to do by hand — is trivial with code. You can just filter for blocks whose centers lie within some distance from a central point, and <em>voilà</em>: a blocky sphere!</p>
<figure data-astro-cid-pkqnntql=""> <img src="https://res.cloudinary.com/dj38sdngx/image/upload/v1/bower/posts/blocky-planet/cube-sphere.png?_a=BAMAJace0" loading="lazy" onerror="this.onerror=null; this.src=&#39;/local/posts/blocky-planet/cube-sphere.png&#39;;" data-astro-cid-pkqnntql=""/> <figcaption data-astro-cid-pkqnntql=""><p><strong>Left:</strong> 2D blocks (squares) selected if their center lies within the red disk.</p><p><strong>Right:</strong> 3D blocks (cubes) selected if their center lies within the red ball.</p></figcaption> </figure> 
<p>This works great for architecture, but makes for a rather lackluster planet. The issue is that the surface of our blocky sphere <strong>does not align with the direction of gravity</strong>. This causes problems when trying to build “upward” on the planet or walk along its surface.</p>
<figure data-astro-cid-pkqnntql=""> <img src="https://res.cloudinary.com/dj38sdngx/image/upload/v1/bower/posts/blocky-planet/gravity-aligned-blocks.svg?_a=BAMAJace0" loading="lazy" onerror="this.onerror=null; this.src=&#39;/local/posts/blocky-planet/gravity-aligned-blocks.svg&#39;;" data-astro-cid-pkqnntql=""/> <figcaption data-astro-cid-pkqnntql=""><p><strong>Left:</strong> 2D representation of planet constructed from grid-aligned blocks.</p><p><strong>Right:</strong> Planet with gravity-aligned blocks.</p></figcaption> </figure> 
<p>So what we want instead is a way to arrange our blocks such that their vertical faces always align with the direction of gravity (top face points towards space, bottom face points towards planet center).</p>
<p>There are two (2) parts to this problem:</p>
<ol>
<li>Mapping a 2D square grid onto a 3D sphere</li>
<li>Preserving block width as you move outward</li>
</ol>
<p>Like most things in life, these problems don’t have a single “right” answer — only a bunch of potential solutions with tradeoffs. Let’s take a look at the solutions I settled on.</p>
<h3 id="cartographers-bane">Cartographer’s Bane</h3>
<p>Thanks to <!-- add attributes and maintain a <slot /> for the link text --><a href="https://en.wikipedia.org/wiki/Theorema_Egregium" target="_blank" rel="noopener noreferrer">Gauss</a>, we know that mapping a flat grid to a sphere is impossible without <em>some</em> distortion. This problem has plagued cartographers for centuries, and in their madness drove them to invent <!-- add attributes and maintain a <slot /> for the link text --><a href="https://en.wikipedia.org/wiki/Map_projection" target="_blank" rel="noopener noreferrer">dozens of map projections</a>, each one wrong in its own special way.</p>

<p>Many of these projections attempt to map the entire globe to a single rectangle. This results in an unfortunate artifact where the entire top of the rectangle represents the same point on the sphere, leading to rather extreme distortion.</p>
<figure data-astro-cid-pkqnntql=""> <img src="https://res.cloudinary.com/dj38sdngx/image/upload/v1/bower/posts/blocky-planet/latitudinal-distortion.png?_a=BAMAJace0" loading="lazy" onerror="this.onerror=null; this.src=&#39;/local/posts/blocky-planet/latitudinal-distortion.png&#39;;" data-astro-cid-pkqnntql=""/> <figcaption data-astro-cid-pkqnntql="">Example of latitudinal distortion with an equirectangular projection. <strong>Left:</strong> 2D world map. <strong>Center:</strong> World map projected onto the globe. <strong>Right:</strong> 2D world map adjusted to show relative projected size.</figcaption> </figure> 
<p>To avoid this, many game developers use something called a <strong>quad sphere</strong>. Instead of mapping a single rectangle to the entire globe, quad spheres divide it into six (6) equivalent sectors, one for each face of a cube. Then a separate square can be mapped to each sector, resulting in much less distortion overall.</p>
<figure data-astro-cid-pkqnntql=""> <img src="https://res.cloudinary.com/dj38sdngx/image/upload/v1/bower/posts/blocky-planet/quad-sphere-sectors.png?_a=BAMAJace0" width="600px" loading="lazy" onerror="this.onerror=null; this.src=&#39;/local/posts/blocky-planet/quad-sphere-sectors.png&#39;;" data-astro-cid-pkqnntql=""/> <figcaption data-astro-cid-pkqnntql="">Six (6) squares (left) being mapped to their corresponding spherical sectors on the quad sphere (right).</figcaption> </figure> 

<p>The recipe to construct a quad sphere is fairly straightforward:</p>
<ol>
<li>Start with a cube centered at the origin</li>
<li>Subdivide each face into a square grid</li>
<li>Push each vertex (corner in the grid) outward until it is exactly one (1) unit distance from the origin</li>
</ol>
<p>Step 3 is done by normalizing each vertex point, which is equivalent to projecting it onto the unit sphere. Visually, I like to think of this as inflating the cube like you would a balloon.</p>
<figure data-astro-cid-pkqnntql=""> <img src="https://res.cloudinary.com/dj38sdngx/image/upload/v1/bower/posts/blocky-planet/quad-sphere-process.png?_a=BAMAJace0" loading="lazy" onerror="this.onerror=null; this.src=&#39;/local/posts/blocky-planet/quad-sphere-process.png&#39;;" data-astro-cid-pkqnntql=""/> <figcaption data-astro-cid-pkqnntql="">Process of constructing a quad sphere. <strong>Left:</strong> Cube centered at origin. <strong>Center:</strong> Cube with subdivided faces. <strong>Right:</strong> Cube projected onto unit sphere by normalizing each vertex.</figcaption> </figure> 
<p>Due to mapping distortion, the projected squares are, well, no longer <em>squares</em>. So instead we refer to them by the more general term <strong>quads</strong> (hence the name <em>quad sphere</em>).</p>
<p>While some distortion is unavoidable, the default quad sphere has far too much for my liking. Luckily, there are some ways to reduce how much our poor quads get squished and stretched. I initially included the full explanation here, but out of respect for your time I decided to move it to a separate post (still a WIP). The gist is we want to pre-distort our square grid to counteract the distortion introduced during normalization. The outcome is quads that do a much better job of preserving the area, angles, and side lengths of the original squares.</p>
<figure data-astro-cid-mzag3dcf=""> <astro-island uid="Zz8pQr" prefix="v0" component-url="/_astro/ImageComparisonSlider.DeN44oFN.js" component-export="default" renderer-url="/_astro/client.BS7eKi2a.js" props="{&#34;beforeImage&#34;:[0,&#34;https://res.cloudinary.com/dj38sdngx/image/upload/v1/bower/posts/blocky-planet/quad-sphere-normalized.png?_a=BAMAJace0&#34;],&#34;afterImage&#34;:[0,&#34;https://res.cloudinary.com/dj38sdngx/image/upload/v1/bower/posts/blocky-planet/quad-sphere-langen.png?_a=BAMAJace0&#34;],&#34;beforeImageLocal&#34;:[0,&#34;/local/posts/blocky-planet/quad-sphere-normalized.png&#34;],&#34;afterImageLocal&#34;:[0,&#34;/local/posts/blocky-planet/quad-sphere-langen.png&#34;],&#34;beforeAlt&#34;:[0,&#34;Before image&#34;],&#34;afterAlt&#34;:[0,&#34;After image&#34;],&#34;width&#34;:[0,400],&#34;height&#34;:[0,400],&#34;data-astro-cid-mzag3dcf&#34;:[0,true]}" ssr="" client="load" opts="{&#34;name&#34;:&#34;ImageComparisonSlider&#34;,&#34;value&#34;:true}" await-children=""><div data-astro-cid-mzag3dcf="true" data-v-0d871491=""><p><img src="https://res.cloudinary.com/dj38sdngx/image/upload/v1/bower/posts/blocky-planet/quad-sphere-normalized.png?_a=BAMAJace0" alt="Before image" onerror="this.onerror=null; this.src=&#39;/local/posts/blocky-planet/quad-sphere-normalized.png&#39;;" data-v-0d871491=""/></p><p><img src="https://res.cloudinary.com/dj38sdngx/image/upload/v1/bower/posts/blocky-planet/quad-sphere-langen.png?_a=BAMAJace0" alt="After image" onerror="this.onerror=null; this.src=&#39;/local/posts/blocky-planet/quad-sphere-langen.png&#39;;" data-v-0d871491=""/></p><div data-v-0d871491=""><div data-v-0d871491=""><p><span data-v-0d871491="">◄</span><span data-v-0d871491="">►</span></p></div></div></div><!--astro:end--></astro-island> <figcaption data-astro-cid-mzag3dcf=""><strong>Left:</strong> Default quad sphere mapping. <strong>Right:</strong> Improved mapping for reduced quad distortion.</figcaption> </figure> 
<p>To convey the importance of reducing quad distortion in practice, let’s take a look at how blocks <strong>in the same location</strong> along the border of two (2) sectors differ between mappings.</p>
<figure data-astro-cid-mzag3dcf=""> <astro-island uid="ZI94u8" prefix="v1" component-url="/_astro/ImageComparisonSlider.DeN44oFN.js" component-export="default" renderer-url="/_astro/client.BS7eKi2a.js" props="{&#34;beforeImage&#34;:[0,&#34;https://res.cloudinary.com/dj38sdngx/image/upload/v1/bower/posts/blocky-planet/screenshot_checker_normalized.png?_a=BAMAJace0&#34;],&#34;afterImage&#34;:[0,&#34;https://res.cloudinary.com/dj38sdngx/image/upload/v1/bower/posts/blocky-planet/screenshot_checker_langen.png?_a=BAMAJace0&#34;],&#34;beforeImageLocal&#34;:[0,&#34;/local/posts/blocky-planet/screenshot_checker_normalized.png&#34;],&#34;afterImageLocal&#34;:[0,&#34;/local/posts/blocky-planet/screenshot_checker_langen.png&#34;],&#34;beforeAlt&#34;:[0,&#34;Before image&#34;],&#34;afterAlt&#34;:[0,&#34;After image&#34;],&#34;width&#34;:[0,714],&#34;height&#34;:[0,515],&#34;data-astro-cid-mzag3dcf&#34;:[0,true]}" ssr="" client="load" opts="{&#34;name&#34;:&#34;ImageComparisonSlider&#34;,&#34;value&#34;:true}" await-children=""><div data-astro-cid-mzag3dcf="true" data-v-0d871491=""><p><img src="https://res.cloudinary.com/dj38sdngx/image/upload/v1/bower/posts/blocky-planet/screenshot_checker_normalized.png?_a=BAMAJace0" alt="Before image" onerror="this.onerror=null; this.src=&#39;/local/posts/blocky-planet/screenshot_checker_normalized.png&#39;;" data-v-0d871491=""/></p><p><img src="https://res.cloudinary.com/dj38sdngx/image/upload/v1/bower/posts/blocky-planet/screenshot_checker_langen.png?_a=BAMAJace0" alt="After image" onerror="this.onerror=null; this.src=&#39;/local/posts/blocky-planet/screenshot_checker_langen.png&#39;;" data-v-0d871491=""/></p><div data-v-0d871491=""><div data-v-0d871491=""><p><span data-v-0d871491="">◄</span><span data-v-0d871491="">►</span></p></div></div></div><!--astro:end--></astro-island> <figcaption data-astro-cid-mzag3dcf=""><strong>Left:</strong> Block pattern with default quad sphere normalization. <strong>Right:</strong> Block pattern with reduced distortion mapping.</figcaption> </figure> 
<p>The blocks with the default mapping are clearly squeezed into rectangles, while with the improved mapping they look much more like squares. This is even more noticeable when actually playing the game.</p>
<p>And just for fun — let’s look at a small blocky planet before and after applying <em>any</em> spherical projection.</p>
<figure data-astro-cid-mzag3dcf=""> <astro-island uid="1KaaE4" prefix="v2" component-url="/_astro/ImageComparisonSlider.DeN44oFN.js" component-export="default" renderer-url="/_astro/client.BS7eKi2a.js" props="{&#34;beforeImage&#34;:[0,&#34;https://res.cloudinary.com/dj38sdngx/image/upload/v1/bower/posts/blocky-planet/screenshot-world-cube.jpg?_a=BAMAJace0&#34;],&#34;afterImage&#34;:[0,&#34;https://res.cloudinary.com/dj38sdngx/image/upload/v1/bower/posts/blocky-planet/screenshot-world-sphere.jpg?_a=BAMAJace0&#34;],&#34;beforeImageLocal&#34;:[0,&#34;/local/posts/blocky-planet/screenshot-world-cube.jpg&#34;],&#34;afterImageLocal&#34;:[0,&#34;/local/posts/blocky-planet/screenshot-world-sphere.jpg&#34;],&#34;beforeAlt&#34;:[0,&#34;Before image&#34;],&#34;afterAlt&#34;:[0,&#34;After image&#34;],&#34;width&#34;:[0,764],&#34;height&#34;:[0,602],&#34;data-astro-cid-mzag3dcf&#34;:[0,true]}" ssr="" client="load" opts="{&#34;name&#34;:&#34;ImageComparisonSlider&#34;,&#34;value&#34;:true}" await-children=""><div data-astro-cid-mzag3dcf="true" data-v-0d871491=""><p><img src="https://res.cloudinary.com/dj38sdngx/image/upload/v1/bower/posts/blocky-planet/screenshot-world-cube.jpg?_a=BAMAJace0" alt="Before image" onerror="this.onerror=null; this.src=&#39;/local/posts/blocky-planet/screenshot-world-cube.jpg&#39;;" data-v-0d871491=""/></p><p><img src="https://res.cloudinary.com/dj38sdngx/image/upload/v1/bower/posts/blocky-planet/screenshot-world-sphere.jpg?_a=BAMAJace0" alt="After image" onerror="this.onerror=null; this.src=&#39;/local/posts/blocky-planet/screenshot-world-sphere.jpg&#39;;" data-v-0d871491=""/></p><div data-v-0d871491=""><div data-v-0d871491=""><p><span data-v-0d871491="">◄</span><span data-v-0d871491="">►</span></p></div></div></div><!--astro:end--></astro-island> <figcaption data-astro-cid-mzag3dcf="">The same small blocky planet before projecting vertices onto the sphere (left) and after projecting vertices (right).</figcaption> </figure> 
<p>Technically the pre-projection version is fully playable. Though it feels like you’re constantly walking on a slope since gravity still pushes you towards the planet center.</p>
<h3 id="digging-deep">Digging Deep</h3>
<p>Now that we have a fairly nice surface mapping, we need to handle the distortion that comes with depth.</p>
<p>Depth in a flat blocky world is simple — you can just keep stacking identical layers on top of one another without issue. However, on a spherical blocky world this will lead to thin blocks near the the planet’s center and wide blocks near the surface (assuming constant block height, which we want).</p>
<figure data-astro-cid-pkqnntql=""> <img src="https://res.cloudinary.com/dj38sdngx/image/upload/v1/bower/posts/blocky-planet/layer-depth.svg?_a=BAMAJace0" loading="lazy" onerror="this.onerror=null; this.src=&#39;/local/posts/blocky-planet/layer-depth.svg&#39;;" data-astro-cid-pkqnntql=""/> <figcaption data-astro-cid-pkqnntql=""><strong>Left:</strong> 2D block column from a flat world. <strong>Right:</strong> 2D block column from a spherical world using a constant number of blocks per layer.</figcaption> </figure> 

<p>The way to minimize this distortion is to add more blocks to each layer as you move outward from the center. We could technically calculate the ideal number of blocks for each layer and use that, but this would cause the edges of blocks to not align properly — making for unsatisfying walls and pillars.</p>
<figure data-astro-cid-pkqnntql=""> <img src="https://res.cloudinary.com/dj38sdngx/image/upload/v1/bower/posts/blocky-planet/layer-offset.svg?_a=BAMAJace0" loading="lazy" onerror="this.onerror=null; this.src=&#39;/local/posts/blocky-planet/layer-offset.svg&#39;;" data-astro-cid-pkqnntql=""/> <figcaption data-astro-cid-pkqnntql=""><strong>Left:</strong> 2D block column from a flat world. <strong>Right:</strong> 2D block column from a spherical world using the “ideal” number of blocks per layer.</figcaption> </figure> 
<p>A compromise is to only add more blocks to a layer when the block distortion becomes too great. In addition, to ensure that the seams of the previous layer align with those of the next layer, we need to increase the number of blocks by some integer multiple. We could use any integer ≥ 2, though using the smallest value of 2 will lead to the least distortion.</p>
<p>This results in our block layers being grouped into <strong>shells</strong>, where within each shell all the block sides will align nicely. But as we move outward, each shell quadruples (2^2) the number of blocks per layer to keep their size roughly consistent. This does mean that the blocks at the bottom of a shell will be a quarter of the size of the blocks at the top, but I consider that a fair compromise for edge alignment. It also has the added benefit of organizing the blocks of each shell into a regular grid, which will make the code much cleaner and more efficient.</p>
<figure data-astro-cid-pkqnntql=""> <img src="https://res.cloudinary.com/dj38sdngx/image/upload/v1/bower/posts/blocky-planet/layer-shells.svg?_a=BAMAJace0" loading="lazy" onerror="this.onerror=null; this.src=&#39;/local/posts/blocky-planet/layer-shells.svg&#39;;" data-astro-cid-pkqnntql=""/> <figcaption data-astro-cid-pkqnntql=""><strong>Left:</strong> 2D block column from a flat world. <strong>Right:</strong> 2D block column from a spherical world divided into shells. In the 2D case, each shell doubles the number of blocks per layer, as well as increases in the number of layers per shell as you move outward.</figcaption> </figure> 
<div data-astro-cid-ndrrxbv4="">  <div data-astro-cid-ndrrxbv4=""> <p>Yes, an alternative approach is to limit the player to a single shell, essentially enforcing a minimum and maximum build height. This is reasonable for large planets, since the shells get exponentially bigger as you move away from the planet origin. You can even reduce the amount of visible distortion by restricting players to a <em>portion</em> of a shell, so they never see the full difference in block size at its top and bottom.</p><p>From what I can tell, this seems to be the approach used by the upcoming game <!-- add attributes and maintain a <slot /> for the link text --><a href="https://planetsmith.world/" target="_blank" rel="noopener noreferrer">PlanetSmith</a> for its hexagonal-blocky planets.</p><p>I opted to use the multi-shell approach for Blocky Planet, both because I want to support tiny planets and because I find the ability to dig all the way to the planet’s center to be particularly satisfying.</p> </div> </div>  
<h2 id="planet-structure">Planet Structure</h2>
<p>Now that we’ve addressed the various distortions, let’s focus on how the planet is represented in practice.</p>
<p>In a flat blocky world, the structure for storing blocks is fairly simple. You have the world divided into <strong>column chunks</strong>, which span from the minimum to maximum build heights. Each column chunk is then subdivided vertically into <strong>render chunks</strong>. For instance, Minecraft uses column chunks of size 16x320x16 blocks, which get divided into render chunks of size 16x16x16 blocks.</p>
<figure data-astro-cid-pkqnntql=""> <img src="https://res.cloudinary.com/dj38sdngx/image/upload/v1/bower/posts/blocky-planet/structure-flat.svg?_a=BAMAJace0" loading="lazy" onerror="this.onerror=null; this.src=&#39;/local/posts/blocky-planet/structure-flat.svg&#39;;" data-astro-cid-pkqnntql=""/> <figcaption data-astro-cid-pkqnntql=""><strong>Left:</strong> Flat blocky world divided into column chunks. <strong>Center:</strong> Single column chunk. <strong>Right:</strong> Zoomed-in view of single render chunk.</figcaption> </figure> 
<p>In contrast, the spherical world is divided into six (6) wedge-like <strong>sectors</strong>, one for each axis direction. This comes from our choice to represent the planet surface with a quad sphere.</p>
<p>Each sector is then subdivided “vertically” into <strong>shells</strong>. As you move alway from the planet origin, these shells get larger both in terms of the number of layers, as well as the number of blocks per layer. There is no restriction on the number of shells, meaning this structure can “cover” all of 3D space (for now I do set a max build height, but that’s not a limit of the planet structure itself).</p>
<p>For efficiency, I further separate these variable-sized shells into regularly sized <strong>chunks</strong> with dimension 16x16x16 blocks.</p>
<div data-astro-cid-ndrrxbv4="">  <div data-astro-cid-ndrrxbv4=""> <p>Computers generally perform better when batching work rather than doing tasks separately. This is especially true in the case of simulating physics and rendering objects.</p><p>This is why almost all voxel games group voxels into chunks that can be batch-processed whenever one or more voxels are modified. These chunks tend to have a consistent size so they can be processed identically.</p><p>Blocky Planet is no exception, which is why I further subdivide each shell into multiple chunks, where each chunk is the same size regardless of the shell it falls in. With this setup, all of the computations that run on chunks can be (mostly) agnostic to where the chunk is on the planet.</p><p>One drawback to having a constant size for all chunks is that certain shells near the planet’s center will be too small to be represented with a chunk. For now I simply don’t allow blocks to exist in these lower shells (creating a hollow core), but I would like to address this in the future.</p> </div> </div>  
<figure data-astro-cid-pkqnntql=""> <img src="https://res.cloudinary.com/dj38sdngx/image/upload/v1/bower/posts/blocky-planet/structure-spherical.svg?_a=BAMAJace0" loading="lazy" onerror="this.onerror=null; this.src=&#39;/local/posts/blocky-planet/structure-spherical.svg&#39;;" data-astro-cid-pkqnntql=""/> <figcaption data-astro-cid-pkqnntql=""><strong>Left:</strong> Spherical blocky world divided into six (6) sectors. <strong>Center:</strong> Single sector split into shells (three shown here). <strong>Right:</strong> Zoomed-in view of single chunk from outer shell.</figcaption> </figure> 
<p>To give you an idea of how this looks in-game, here are two (2) screenshots of from early versions of Blocky Planet that show an exploded view of the world.</p>
<figure data-astro-cid-pkqnntql=""> <img src="https://res.cloudinary.com/dj38sdngx/image/upload/v1/bower/posts/blocky-planet/exploded-duel-view.jpg?_a=BAMAJace0" loading="lazy" onerror="this.onerror=null; this.src=&#39;/local/posts/blocky-planet/exploded-duel-view.jpg&#39;;" data-astro-cid-pkqnntql=""/> <figcaption data-astro-cid-pkqnntql=""><p>Screenshots showing a spherical planet “exploded” into its distinct sectors and shells with a glowing core.</p><p><strong>Left:</strong> Randomly colored chunks with every other block missing. <strong>Right:</strong> Fully filled shells with more natural colors.</p></figcaption> </figure> 
<h3 id="whats-my-address">What’s my address?</h3>
<p>For mechanics like placing blocks, we need to be able to take a world position and get the corresponding <strong>block address</strong>.</p>
<p>A block address specifies the exact location of a block’s data within the planet’s overall structure. It works much like a postal address that becomes increasingly precise, going from Country → State → City → Building. For a block address, the sequence is Sector → Shell → Chunk → Block.</p>
<p>If code is more your thing, here’s an example of how I represent this address as a C# struct:</p>
<pre tabindex="0" data-language="csharp"><code><span><span>struct</span><span> BlockAddress</span></span>
<span><span>{</span></span>
<span><span>    public</span><span> int</span><span> sectorIndex</span><span>; </span><span>// 0 - 5</span></span>
<span><span>    public</span><span> int</span><span> shellIndex</span><span>;  </span><span>// 0 - +Infinity</span></span>
<span><span>    public</span><span> int3</span><span> chunkIndex</span><span>; </span><span>// [0-n, 0-n, 0-n]</span></span>
<span><span>    public</span><span> int3</span><span> blockIndex</span><span>; </span><span>// [0-15, 0-15, 0-15]</span></span>
<span><span>}</span></span></code></pre>
<p>Finding the address from a world position requires a few steps that you probably don’t care about, so I’ll skip them for now. Oh, and in case you were wondering, this is all trivial to do on a flat blocky world.</p>
<div data-astro-cid-ndrrxbv4="">  <div data-astro-cid-ndrrxbv4=""> <p><em>Okay then, but I warned you…</em></p><p>Given a position relative to the planet’s center (i.e. vector from planet origin to world position), we calculate the address in the following ways:</p><p><strong>Sector Index</strong>: Find the index of the coordinate with the maximum absolute value. This will give you the sector’s axis. You can then use the sign of the coordinate to get the actual sector. For example, the relative position (50, -30, -64) will have its sector along the z-axis since abs(-64) is the max value. Then the fact that it is negative tells you that it corresponds to the “Back” sector instead of the “Front” sector.</p><p><strong>Shell Index</strong>: Find the distance of the position from the planet origin, then determine which shell this falls in. This is a little tricky since shells have different layer counts (i.e. heights), so I need to use a loop instead of just dividing the distance by some fixed height.</p><p><strong>ChunkIndex</strong>: For the x and z indices, we perform a reverse projection to get the position on the cube face. We then normalize this projected position so each coordinate goes from -1 to 1. We then remap this to go from 0-(# of horizontal chunks in the current shell). For the y index, we inverse lerp the position’s radius between the shell’s min and max radii, then multiply the result by the # of vertical chunks in the shell.</p><p><strong>BlockIndex</strong>: Do the same thing we did for the chunk index, except remap it to the # of blocks and then mod the chunk size.</p> </div> </div>  
<h3 id="whos-my-neighbor">Who’s my Neighbor?</h3>
<p>A vital operation in any blocky game is the ability to efficiently find neighboring blocks. This is used for mechanics like placing/breaking multiple blocks at once, as well as optimizations like only drawing block faces that are visible to the player. As you can probably guess, finding neighboring blocks is trivial in a flat voxel world. However, I found solving this problem <em>consistently</em> to be the most challenging part of this project (and to be honest, I think I still missed an edge case).</p>
<p><strong>Goal:</strong> Given an block address and one of six (6) axis directions, return the address of the neighboring block in that direction.</p>
<p>These axis directions correspond to the positive and negative directions of the 3D coordinate axes, which are: Left = -X, Right = +X, Down = -Y, Up = +Y, Back = -Z, and Front = +Z.</p>
<figure data-astro-cid-pkqnntql=""> <img src="https://res.cloudinary.com/dj38sdngx/image/upload/v1/bower/posts/blocky-planet/block-axes.svg?_a=BAMAJace0" width="400px" loading="lazy" onerror="this.onerror=null; this.src=&#39;/local/posts/blocky-planet/block-axes.svg&#39;;" data-astro-cid-pkqnntql=""/> <figcaption data-astro-cid-pkqnntql="">Diagram of six (6) axis directions where a block can have a neighbor.</figcaption> </figure> 
<p>If the neighbor is within the same chunk, or even within the same shell, their address is fairly easy to find. However, it gets trickier when crossing shell boundaries.</p>
<h4 id="vertical-shell-boundaries">Vertical Shell Boundaries</h4>
<p>Vertical shell boundaries already break one of our assumptions — that a block only has a <strong>single</strong> neighbor in a given direction. <em>How very inconvenient…</em></p>
<p>This comes from our attempt to minimize depth distortion by adding more blocks in successive shells. In my case, that means a block at the top of shell N will map to four (4) separate blocks at the bottom of shell N+1. The inverse is also true — those four (4) blocks will share a single downward neighbor.</p>
<p>This complicates the code a bit, but isn’t <em>too</em> difficult to account for. It just means some extra checks when handling vertical neighbors.</p>
<figure data-astro-cid-pkqnntql=""> <img src="https://res.cloudinary.com/dj38sdngx/image/upload/v1/bower/posts/blocky-planet/vertical-block-boundary.svg?_a=BAMAJace0" width="800px" loading="lazy" onerror="this.onerror=null; this.src=&#39;/local/posts/blocky-planet/vertical-block-boundary.svg&#39;;" data-astro-cid-pkqnntql=""/> <figcaption data-astro-cid-pkqnntql="">Diagram showing how one block can have four (4) neighbors in the up direction. Each of these neighbors will be a quarter the size of the base block.</figcaption> </figure> 
<p>And in case you’re curious, here’s how these vertical shell boundaries look in-game:</p>
<figure data-astro-cid-pkqnntql=""> <img src="https://res.cloudinary.com/dj38sdngx/image/upload/v1/bower/posts/blocky-planet/screenshot-vertical-boundary.png?_a=BAMAJace0" loading="lazy" onerror="this.onerror=null; this.src=&#39;/local/posts/blocky-planet/screenshot-vertical-boundary.png&#39;;" data-astro-cid-pkqnntql=""/> <figcaption data-astro-cid-pkqnntql="">Screenshot showing a vertical shell boundary. Four (4) blocks of different types are placed on top of a single glass block in a lower shell.</figcaption> </figure> 
<h4 id="sector-boundaries">Sector Boundaries</h4>
<p>Sector boundaries are tricky because unlike neighboring chunks, we cannot assume the neighboring sector will share the same local alignment. For example, let’s consider the flat squares that corresponds to our six (6) sectors (think back to the quad sphere). Each square will have its own local 2D coordinate system, which I’ll refer to here using the variables <strong>u</strong> and <strong>v</strong>.</p>
<figure data-astro-cid-pkqnntql=""> <img src="https://res.cloudinary.com/dj38sdngx/image/upload/v1/bower/posts/blocky-planet/orientation-local-face-uv.svg?_a=BAMAJace0" width="864px" loading="lazy" onerror="this.onerror=null; this.src=&#39;/local/posts/blocky-planet/orientation-local-face-uv.svg&#39;;" data-astro-cid-pkqnntql=""/> <figcaption data-astro-cid-pkqnntql=""><p>Six (6) sector squares with local (u, v) coordinate systems.</p><p>From left-to-right and top-to-bottom: Front, Up, Down, Left, Right, Back.</p></figcaption> </figure> 
<p>In order to assemble the planet surface from these squares, we have to glue their edges together. This results in twelve (12) edge pairings. Where things get difficult is that each pairing can be misaligned in one or both of the following ways:</p>
<ol>
<li>Axes are mismatched (a <strong>u</strong> axis glued to a <strong>v</strong> axis)</li>
<li>Axes are flipped (pointed in opposite directions)</li>
</ol>
<figure data-astro-cid-pkqnntql=""> <img src="https://res.cloudinary.com/dj38sdngx/image/upload/v1/bower/posts/blocky-planet/orientation-misaligned-faces.svg?_a=BAMAJace0" loading="lazy" onerror="this.onerror=null; this.src=&#39;/local/posts/blocky-planet/orientation-misaligned-faces.svg&#39;;" data-astro-cid-pkqnntql=""/> <figcaption data-astro-cid-pkqnntql="">Diagram showing all four (4) alignment combinations between sector faces.</figcaption> </figure> 
<p>These misalignments are unavoidable, but can be accounted for by swapping/flipping indices. Though the matter of <em>how</em> each pairing is misaligned comes down to how you decide to glue everything together. This is an arbitrary decision, but it’s important to stay consistent once decided. The diagram below shows the <!-- add attributes and maintain a <slot /> for the link text --><a href="https://en.wikipedia.org/wiki/Net_(polyhedron)" target="_blank" rel="noopener noreferrer">cube net</a> corresponding to my choices for how to glue the sides of my planet together.</p>
<figure data-astro-cid-pkqnntql=""> <img src="https://res.cloudinary.com/dj38sdngx/image/upload/v1/bower/posts/blocky-planet/orientation-cube-net.svg?_a=BAMAJace0" width="800px" loading="lazy" onerror="this.onerror=null; this.src=&#39;/local/posts/blocky-planet/orientation-cube-net.svg&#39;;" data-astro-cid-pkqnntql=""/> <figcaption data-astro-cid-pkqnntql="">Cube net representing the way sector faces are joined in Blocky Planet (think of this as an unrolled cube).</figcaption> </figure> 

<h2 id="miscellaneous-functionality">Miscellaneous Functionality</h2>
<p><em>Whew!</em> That concludes the discussion of the more structural aspects of making a spherical blocky planet. Now the rest of this post will touch on a few other considerations regarding gravity and world generation.</p>
<h3 id="player-gravity">Player Gravity</h3>
<p>The player uses a fairly standard physics-driven controller that applies forces to a rigidbody to move around. However, in order to stop the player from just <em>falling off</em> the side of the planet, I disable the built-in downward gravity and apply my own custom gravity that accelerates the player towards the center of the planet.</p>
<p>While I do adjust the strength of gravity based on distance, it’s more <em>vibes-based</em> than physically accurate. I keep the gravity constant when above the surface terrain so the gameplay stays predictable. However as you dig towards the planet’s center the gravity decreases towards zero (0) to simulate the planet pulling on you equally in all directions.</p>
<p>I also added a “thruster” ability that can be triggered by holding <em>SPACE</em> while in the air. This applies an opposite force to counteract and overpower gravity, making it easy to get into orbit around the planet.</p>
<figure data-astro-cid-pkqnntql=""> <img src="https://res.cloudinary.com/dj38sdngx/image/upload/v1/bower/posts/blocky-planet/player-gravity-updated.svg?_a=BAMAJace0" width="664px" loading="lazy" onerror="this.onerror=null; this.src=&#39;/local/posts/blocky-planet/player-gravity-updated.svg&#39;;" data-astro-cid-pkqnntql=""/> <figcaption data-astro-cid-pkqnntql="">Diagram showing gravity accelerating the player towards the center of the planet. Players can fly using their thruster, and with enough horizontal velocity they can even get into a stable orbit. Gravity decreases towards zero (0) near the center of the planet.</figcaption> </figure> 
<div data-astro-cid-ndrrxbv4="">  <p>I rotate the player’s local up vector to be aligned with the negative direction of gravity (i.e. the ground is always “down”). If you try to do this yourself, I suggest smoothly interpolating the player’s rotation instead of snapping it each frame. I initially did the latter, which led to some stuttering and disorienting snapping near the planet origin.</p> </div>  
<h3 id="terrain-generation">Terrain Generation</h3>
<p>Like most terrain generators, I use smooth noise to determine the terrain height. Once the height is known, the types for all the blocks can be calculated using the following steps:</p>
<ol>
<li>Set all blocks to empty (air) blocks</li>
<li>If a block falls below the terrain height, set it to stone</li>
<li>Convert blocks to grass or dirt depending on their distance from the top of their respective column</li>
<li>If a block falls below the planetary water level, then make the following conversions:
<ul>
<li>Grass → Sand</li>
<li>Air → Water</li>
</ul>
</li>
</ol>
<figure data-astro-cid-pkqnntql=""> <img src="https://res.cloudinary.com/dj38sdngx/image/upload/v1/bower/posts/blocky-planet/terrain-generation.svg?_a=BAMAJace0" loading="lazy" onerror="this.onerror=null; this.src=&#39;/local/posts/blocky-planet/terrain-generation.svg&#39;;" data-astro-cid-pkqnntql=""/> <figcaption data-astro-cid-pkqnntql="">Process of generating chunks based on terrain height.</figcaption> </figure> 
<p>The specifics of exactly <em>how</em> the terrain height is generated for all the columns is where spherical worlds differ from flat ones. Games with flat worlds (i.e. most of them) use 2D noise to generate a <!-- add attributes and maintain a <slot /> for the link text --><a href="https://en.wikipedia.org/wiki/Heightmap" target="_blank" rel="noopener noreferrer">height map</a>. You can then just look up a column’s corresponding height using its (x,z) coordinates.</p>
<p>There are two (2) issues that make this challenging to apply to a spherical world:</p>
<ol>
<li>The noise values need to smoothly tile across the sphere (i.e. produce no visible seams)</li>
<li>Mapping 2D noise to the sphere will introduce some distortion (<em>see first half of this post</em>)</li>
</ol>
<p>Luckily, there’s a far easier solution — <strong>sample a 3D noise function on a sphere</strong>. This solves both the tiling problem (since there are no seams) and the distortion problem (since we’re not converting from 2D to 3D). We can sample the unit sphere by default, but we are free to sample spheres with a different radii to create noise at different scales (for different planet sizes). In addition, we can translate the sphere in our noise space to implement random seeds.</p>
<p>This type of noise could also be used for a biome system like in the real Minecraft, however for now I use a simpler approach. My planets only have two (2) biomes — forest and arctic. To determine if a given block column is in the arctic biome, I look at its angular distance to either pole (North and South). If this falls below some threshold angle, it’s considered to be arctic, otherwise it’s forest. I also add some smooth noise to this threshold to prevent a perfect circular border between these two (2) biomes.</p>
<figure data-astro-cid-pkqnntql=""> <img src="https://res.cloudinary.com/dj38sdngx/image/upload/v1/bower/posts/blocky-planet/screenshot-north-pole.jpg?_a=BAMAJace0" width="800px" loading="lazy" onerror="this.onerror=null; this.src=&#39;/local/posts/blocky-planet/screenshot-north-pole.jpg&#39;;" data-astro-cid-pkqnntql=""/> <figcaption data-astro-cid-pkqnntql="">Screenshot showing planet’s arctic biome surrounding the North pole. Notice the irregular border where snow turns to grass.</figcaption> </figure> 
<h3 id="block-structures">Block Structures</h3>
<p>I consider <strong>block structures</strong> to be any saved arrangement of blocks that can be <em>pasted</em> into the world. This includes natural structures like trees that get placed during world generation, as well as saved player-built structures like this house below.</p>
<figure data-astro-cid-pkqnntql=""> <img src="https://res.cloudinary.com/dj38sdngx/image/upload/v1/bower/posts/blocky-planet/screenshot-block-structures.jpg?_a=BAMAJace0" loading="lazy" onerror="this.onerror=null; this.src=&#39;/local/posts/blocky-planet/screenshot-block-structures.jpg&#39;;" data-astro-cid-pkqnntql=""/> <figcaption data-astro-cid-pkqnntql="">Example of two (2) types of block structures: oak trees and a player-built house.</figcaption> </figure> 
<p>These structures are saved as 3D arrays of blocks (referred to below as the <em>source zone</em>). In theory placing them should be as straightforward as:</p>
<ol>
<li>Determining the destination zone on the planet where the structure should be placed</li>
<li>Copying each block from the source zone to its corresponding position in the destination zone</li>
</ol>
<figure data-astro-cid-pkqnntql=""> <img src="https://res.cloudinary.com/dj38sdngx/image/upload/v1/bower/posts/blocky-planet/block-structure-zone.svg?_a=BAMAJace0" loading="lazy" onerror="this.onerror=null; this.src=&#39;/local/posts/blocky-planet/block-structure-zone.svg&#39;;" data-astro-cid-pkqnntql=""/> <figcaption data-astro-cid-pkqnntql="">Example of source zone (blue) being mapped to a corresponding destination zone (orange) on the blocky planet.</figcaption> </figure> 
<p>But as we’ve seen many times now, nothing is ever easy on a spherical blocky world.</p>
<p>When it comes to placing block structures, there are two (2) edge cases that can throw a wrench into things:</p>
<ol>
<li>The corners where three (3) sectors meet break the regular horizontal grid topology, since three (3) blocks meet at the corner instead of four (4)</li>
<li>Vertical shell boundaries break the regular vertical grid topology, since a block can have four (4) vertical neighbors instead of just one (1)</li>
</ol>
<p>This means that there are places on our planet where it’s <strong>impossible</strong> to define a box-shaped zone of blocks that corresponds to the block structure’s source zone. I could just detect and prevent structures from being placed at these locations, but I opted for a more general solution.</p>
<p>Instead of viewing the block structure as a single box being placed at once, I interpret it as placing an origin block that I then build out from to create the structure. This results in each block having its own series of directions from the origin block to its relative address. We can then leverage the previous work we did for finding neighboring block addresses to navigate using these directions.</p>
<figure data-astro-cid-pkqnntql=""> <img src="https://res.cloudinary.com/dj38sdngx/image/upload/v1/bower/posts/blocky-planet/block-structure-directions.svg?_a=BAMAJace0" loading="lazy" onerror="this.onerror=null; this.src=&#39;/local/posts/blocky-planet/block-structure-directions.svg&#39;;" data-astro-cid-pkqnntql=""/> <figcaption data-astro-cid-pkqnntql="">Visualization of block structures stored as relative directions from an origin block. In this case, the player would only need to place the destination origin block, and then the rest of structure would “grow” out from it.</figcaption> </figure> 
<p>Placing structures will now “work” everywhere, though it can get a little wonky around the problematic areas. Still, I prefer this to having dead zones where no structures can be placed at all.</p>
<figure data-astro-cid-pkqnntql=""> <img src="https://res.cloudinary.com/dj38sdngx/image/upload/v1/bower/posts/blocky-planet/screenshot-house-vertical-border.jpg?_a=BAMAJace0" loading="lazy" onerror="this.onerror=null; this.src=&#39;/local/posts/blocky-planet/screenshot-house-vertical-border.jpg&#39;;" data-astro-cid-pkqnntql=""/> <figcaption data-astro-cid-pkqnntql="">Screenshot showing house structure being placed across a vertical shell boundary. This results in the roof blocks appearing shrunk to a quarter the size of the base blocks since they are in the higher shell.</figcaption> </figure> 
<figure data-astro-cid-pkqnntql=""> <img src="https://res.cloudinary.com/dj38sdngx/image/upload/v1/bower/posts/blocky-planet/screenshot-house-corner.jpg?_a=BAMAJace0" loading="lazy" onerror="this.onerror=null; this.src=&#39;/local/posts/blocky-planet/screenshot-house-corner.jpg&#39;;" data-astro-cid-pkqnntql=""/> <figcaption data-astro-cid-pkqnntql="">Screenshot showing house structure placed on the corner of three (3) sectors. This causes the house to “wrap” in upon itself. In cases like this, some blocks in the structure may navigate to the same block address, causing them to overwrite one another.</figcaption> </figure> 
<h2 id="future-work">Future Work</h2>
<p>I’m not sure how much time I’ll spend on Blocky Planet going forward. Nevertheless, I already have a long backlog of features I’d like to implement. Some have already been mentioned earlier in this post, but I’ll repeat them here for clarity.</p>
<p><strong>Multiple Planets/Moons:</strong> Since starting this project I’ve envisioned an <!-- add attributes and maintain a <slot /> for the link text --><a href="https://store.steampowered.com/app/753640/Outer_Wilds/" target="_blank" rel="noopener noreferrer">Outer Wilds</a> style solar system filled with blocky planets that the player can navigate between. These planets could follow a simple clockwork style movement, or use a more advanced gravity simulation (ex. Sebastian Lague’s <!-- add attributes and maintain a <slot /> for the link text --><a href="https://www.youtube.com/watch?v=7axImc1sxa0" target="_blank" rel="noopener noreferrer">solar system project</a>).</p>
<p><strong>Chunk-Based Gravity:</strong> Gravity should be calculated dynamically per chunk based on the blocks in said chunk. This should be doable with little to no performance hit, and would result in more “realistic” gravity when inside a planet.</p>
<p><strong>Planet Collisions:</strong> Assuming multiple planet’s are implemented, I’d like to support some form of collision between them (ex. blocky asteroids crashing into planets). However, just thinking about implementing this gives me a headache, so I wouldn’t expect it in the near future (if ever).</p>
<p><strong>Cave Generation</strong>: As fun as walking on the planet is, I think exploring caves leading from the surface to the planet’s core would be even better.</p>
<p><strong>Proper Biomes</strong>: Procedural generation on a planet allows for more realistic biome generation, since you can take into account factors like distance to the equator.</p>
<p><strong>Voxel-Based Lighting</strong>: I currently use Unity’s direct lighting and shadowing system for the planet. This works well enough, though to get better <!-- add attributes and maintain a <slot /> for the link text --><a href="https://en.wikipedia.org/wiki/Global_illumination" target="_blank" rel="noopener noreferrer">global illumination</a> I’d like to combine this direct lighting with a proper voxel-based lighting system (similar to actual Minecraft).</p>
<p>If there’s any features you would like me to implement, or if you have any feedback in general, feel free to leave a comment on the Reddit post <!-- add attributes and maintain a <slot /> for the link text --><a href="https://www.reddit.com/user/Bowerbyte/comments/1myy3cm/blocky_planet_making_minecraft_spherical/" target="_blank" rel="noopener noreferrer">here</a>.</p>
 </div>  </div> </div></div>
  </body>
</html>
