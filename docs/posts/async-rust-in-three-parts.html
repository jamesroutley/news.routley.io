<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jacko.io/async_intro.html">Original</a>
    <h1>Async Rust in Three Parts</h1>
    
    <div id="readability-page-1" class="page"><article>
<p><a href="https://theleo.zone/">↫ Home</a></p>

<p>2024 October 23</p>
<section>

<ul>
<li>Introduction (you are here)

<ul>
<li><a href="#threads">Threads</a></li>
<li><a href="#async">Async</a></li>
<li><a href="#important_mistakes">Important Mistakes</a></li>
</ul></li>
<li><a href="https://theleo.zone/books/how-to-know-a-person/async_futures.html">Part One: Futures</a></li>
<li><a href="https://theleo.zone/books/how-to-know-a-person/async_tasks.html">Part Two: Tasks</a></li>
<li><a href="https://theleo.zone/books/how-to-know-a-person/async_io.html">Part Three: IO</a></li>
</ul>

<p>Async/await, or &#34;async IO&#34;, is a new-ish<span>​<label for="sidenote-new_ish"></label><span>Rust added async/await in 2019. For comparison, C# added it in
2012, Python in 2015, JS in 2017, and C++ in 2020.</span></span> language feature that lets
our programs do more than one thing at a time. It&#39;s sort of an alternative to
multithreading, though Rust programs often use both. Async is popular with
websites and network services that handle many connections at once,<span>​<label for="sidenote-lots"></label><span>&#34;Many&#34; here conventionally means ten thousand or more. This is
sometimes called the <a href="https://en.wikipedia.org/wiki/C10k_problem">&#34;C10K problem&#34;</a>, short for 10,000 clients or
connections.</span></span>
because running lots of &#34;futures&#34; or &#34;tasks&#34; is more efficient than running
lots of threads.</p>

<p>This series is an introduction to futures, tasks, and async IO in Rust. Our
goal will be to get a good look at the machinery, so that async code doesn&#39;t
feel like magic. We&#39;ll start by translating (&#34;desugaring&#34;) async examples into
ordinary Rust, and gradually we&#39;ll build our own async &#34;runtime&#34;.<span>​<label for="sidenote-runtime"></label><span>For now, a &#34;runtime&#34; is a library or framework that we use to write
async programs. Building our own futures, tasks, and IO will gradually make
it clear what a runtime does for us.</span></span>
I&#39;ll assume that you&#39;ve written some Rust before and that you&#39;ve read <a href="https://doc.rust-lang.org/book">The Rust
Programming Language</a> (&#34;The Book&#34;) or similar.<span>​<label for="sidenote-ch20"></label><span>The multithreaded web server project in <a href="https://doc.rust-lang.org/book/ch20-00-final-project-a-web-server.html">Chapter 20</a> is
especially relevant.</span></span></p>

<p>Let&#39;s get started by doing more than one thing at a time with threads. This
will go well at first, but we&#39;ll run into trouble as the number of threads
grows. Then we&#39;ll get the same thing working with async/await, to see what all
the fuss is about. That&#39;ll give us some example code to play with, and in <a href="https://theleo.zone/books/how-to-know-a-person/async_futures.html">Part
One</a> we&#39;ll start digging into it.</p>
</section>

<section>
<h2 id="threads">Threads</h2>

<p>Here&#39;s an example function <code>foo</code> that takes a second to run:</p>

<pre><code><span>fn </span><span>foo</span><span>(</span><span>n</span><span>: </span><span>u64</span><span>) {</span></code></pre>

<p>If we want to make several calls to <code>foo</code> at the same time, we can spawn a
thread for each one. Click on the Playground button to see that this takes one
second instead of ten:<span>​<label for="sidenote-threads_order"></label><span>You&#39;ll probably also see the &#34;start&#34; and &#34;end&#34; prints appear
out of order. Different threads running at the same time run in an
unpredictable order, and that can be true of futures too.</span></span></p>

<pre><code><span>fn </span><span>main</span><span>() {</span></code></pre>

<p>Note that <code>join</code> here means &#34;wait for the thread to finish&#34;. Threads start
running in the background as soon as we call <code>spawn</code>, so all of them are making
progress while we wait on the first one, and the rest of the calls to <code>join</code>
return quickly.</p>

<p>We can bump this example up to <a href="https://play.rust-lang.org/?edition=2021&amp;code=use+std%3A%3Athread%3B%0Ause+std%3A%3Atime%3A%3ADuration%3B%0A%0Afn+foo%28n%3A+u64%29+%7B%0A++++println%21%28%22start+%7Bn%7D%22%29%3B%0A++++thread%3A%3Asleep%28Duration%3A%3Afrom_secs%281%29%29%3B%0A++++println%21%28%22end+%7Bn%7D%22%29%3B%0A%7D%0A%0Afn+main%28%29+%7B%0A++++let+mut+threads+%3D+Vec%3A%3Anew%28%29%3B%0A++++for+n+in+1..%3D100+%7B%0A++++++++threads.push%28thread%3A%3Aspawn%28move+%7C%7C+foo%28n%29%29%29%3B%0A++++%7D%0A++++for+thread+in+threads+%7B%0A++++++++thread.join%28%29.unwrap%28%29%3B%0A++++%7D%0A%7D">a hundred threads</a>, and it
works just fine. But if we try to run <a href="https://play.rust-lang.org/?edition=2021&amp;code=use+std%3A%3Athread%3B%0Ause+std%3A%3Atime%3A%3ADuration%3B%0A%0Afn+foo%28n%3A+u64%29+%7B%0A++++println%21%28%22start+%7Bn%7D%22%29%3B%0A++++thread%3A%3Asleep%28Duration%3A%3Afrom_secs%281%29%29%3B%0A++++println%21%28%22end+%7Bn%7D%22%29%3B%0A%7D%0A%0Afn+main%28%29+%7B%0A++++let+mut+threads+%3D+Vec%3A%3Anew%28%29%3B%0A++++for+n+in+1..%3D1_000+%7B%0A++++++++threads.push%28thread%3A%3Aspawn%28move+%7C%7C+foo%28n%29%29%29%3B%0A++++%7D%0A++++for+thread+in+threads+%7B%0A++++++++thread.join%28%29.unwrap%28%29%3B%0A++++%7D%0A%7D">a thousand
threads</a>,<span>​<label for="sidenote-thread_limit"></label><span>On my Linux laptop I can spawn almost 19k threads before I hit
this crash, but the Playground has tighter resource limits.</span></span> it doesn&#39;t work anymore:</p>

<pre><code>thread &#39;main&#39; panicked at /rustc/3f5fd8dd41153bc5fdca9427e9e05...</code></pre>

<p>Each thread uses a lot of memory,<span>​<label for="sidenote-stack_space"></label><span>In particular, each thread allocates space for its &#34;stack&#34;,
which is 8 MiB by default on Linux. The OS uses fancy tricks to
allocate this space &#34;lazily&#34;, but it&#39;s still a lot if we spawn thousands of
threads.</span></span> so there&#39;s a limit on how many
threads we can spawn. It&#39;s harder to see on the Playground, but we can also
cause performance problems by switching between lots of threads at
once.<span>​<label for="sidenote-basketball_demo"></label><span>Here&#39;s a <a href="https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2021&amp;gist=fd952dba2f51ee595cd9ff6dbbc08c38">demo of passing &#34;basketballs&#34; back and forth
among many threads</a>, to show how thread switching
overhead affects performance as the number of threads grows. It&#39;s longer
and more complicated than the other examples here, and it&#39;s ok to skip it.</span></span> Threads are a fine way to run a few jobs in parallel,
or even a few hundred, but for various reasons they don&#39;t scale well beyond
that.<span>​<label for="sidenote-thread_pool"></label><span>A thread pool can be a good approach for CPU-intensive work,
but when each job spends most of its time blocked on IO, the pool quickly
runs out of worker threads, and <a href="https://play.rust-lang.org/?edition=2021&amp;code=use+std%3A%3Athread%3B%0Ause+std%3A%3Atime%3A%3ADuration%3B%0A%0Afn+foo%28n%3A+u64%29+%7B%0A++++println%21%28%22start+%7Bn%7D%22%29%3B%0A++++thread%3A%3Asleep%28Duration%3A%3Afrom_secs%281%29%29%3B%0A++++println%21%28%22end+%7Bn%7D%22%29%3B%0A%7D%0A%0Afn+main%28%29+%7B%0A++++println%21%28%22Run+a+thousand+jobs+on+a+thread+pool...%22%29%3B%0A++++rayon%3A%3Ascope%28%7Cscope%7C+%7B%0A++++++++for+n+in+1..%3D1_000+%7B%0A++++++++++++scope.spawn%28move+%7C_%7C+foo%28n%29%29%3B%0A++++++++%7D%0A++++++++println%21%28%22All+the+jobs+have+been+spawned...%22%29%3B%0A++++%7D%29%3B%0A%7D">there&#39;s not enough parallelism to go
around</a>.</span></span> If we want to run thousands of jobs, we need something
different.</p>
</section>

<section>
<h2 id="async">Async</h2>

<p>Let&#39;s try the same thing with async/await. For now we&#39;ll just type it out and
run it on the Playground without explaining anything. Our async <code>foo</code> function
looks like this:<span>​<label for="sidenote-tokio"></label><span>The async examples in this introduction and in most of <a href="https://theleo.zone/books/how-to-know-a-person/async_futures.html">Part One</a>
will use the <a href="https://tokio.rs/">Tokio</a> runtime. There are several async runtimes available in
Rust, but the differences between them aren&#39;t important for this series.
Tokio is the most popular and the most widely supported.</span></span></p>

<pre><code><span>async </span><span>fn </span><span>foo</span><span>(</span><span>n</span><span>: </span><span>u64</span><span>) {</span></code></pre>

<p>Making a few calls to <code>foo</code> one-at-a-time looks like this:<span>​<label for="sidenote-tokio_main"></label><span>In Parts Two and Three of this series, we&#39;ll implement a lot of
what <code>#[tokio::main]</code> is doing. Until then we can just take it on faith
that it&#39;s &#34;the thing we put before <code>main</code> when we use Tokio.&#34;</span></span></p>

<pre><code><span>#[</span><span>tokio</span><span>::</span><span>main</span><span>]</span></code></pre>

<p>The first thing that&#39;s different about async functions is that we declare them
with the <code>async</code> keyword, and we write <code>.await</code> when we call them. Fair enough.</p>

<p>Making several calls to <code>foo</code> at the same time looks like this:<span>​<label for="sidenote-async_order"></label><span>Unlike the version with threads above, you&#39;ll always see this
version print its start messages in order, and you&#39;ll <em>usually</em> see it
print the end messages in order too. However, it&#39;s possible for the end
messages to appear out of order, because <a href="https://tokio.rs/blog/2018-03-timers">Tokio&#39;s timer implementation is
complicated</a>.</span></span></p>

<pre><code><span>#[</span><span>tokio</span><span>::</span><span>main</span><span>]</span></code></pre>

<p>Note that we don&#39;t <code>.await</code> each call to <code>foo</code> this time. Each un-awaited <code>foo</code>
returns a &#34;future&#34;, which we collect in a <code>Vec</code>, kind of like the <code>Vec</code> of
thread handles above. But <a href="https://docs.rs/futures/latest/futures/future/fn.join_all.html"><code>join_all</code></a> is very different from the <a href="https://doc.rust-lang.org/std/thread/struct.JoinHandle.html#method.join"><code>join</code></a>
method we used with threads. Previously joining meant waiting on something, but
here it means combining multiple &#34;futures&#34; together somehow. We&#39;ll get to the
details in <a href="https://theleo.zone/books/how-to-know-a-person/async_futures.html">Part One</a>, but for now we can <a href="https://play.rust-lang.org/?edition=2021&amp;code=use+futures%3A%3Afuture%3B%0Ause+std%3A%3Atime%3A%3ADuration%3B%0A%0Aasync+fn+foo%28n%3A+u64%29+%7B%0A++++println%21%28%22start+%7Bn%7D%22%29%3B%0A++++tokio%3A%3Atime%3A%3Asleep%28Duration%3A%3Afrom_secs%281%29%29.await%3B%0A++++println%21%28%22end+%7Bn%7D%22%29%3B%0A%7D%0A%0A%23%5Btokio%3A%3Amain%5D%0Aasync+fn+main%28%29+%7B%0A++++let+mut+futures+%3D+Vec%3A%3Anew%28%29%3B%0A++++for+n+in+1..%3D10+%7B%0A++++++++futures.push%28foo%28n%29%29%3B%0A++++%7D%0A++++println%21%28%22Joining+the+foo+futures...%22%29%3B%0A++++let+joined_future+%3D+future%3A%3Ajoin_all%28futures%29%3B%0A++++println%21%28%22That+didn%27t+take+any+time.%22%29%3B%0A%0A++++tokio%3A%3Atime%3A%3Asleep%28Duration%3A%3Afrom_secs%281%29%29.await%3B%0A%0A++++println%21%28%22Awaiting+the+joined+futures...%22%29%3B%0A++++joined_future.await%3B%0A%7D">add some more prints</a>
to see that <code>join_all</code> doesn&#39;t take any time, and none of <code>foo</code>s start running
until we <code>.await</code> the joined future.</p>

<p>Unlike the threads example above, this works even if we bump it up to <a href="https://play.rust-lang.org/?edition=2021&amp;code=use+futures%3A%3Afuture%3B%0Ause+std%3A%3Atime%3A%3ADuration%3B%0A%0Aasync+fn+foo%28n%3A+u64%29+%7B%0A++++println%21%28%22start+%7Bn%7D%22%29%3B%0A++++tokio%3A%3Atime%3A%3Asleep%28Duration%3A%3Afrom_secs%281%29%29.await%3B%0A++++println%21%28%22end+%7Bn%7D%22%29%3B%0A%7D%0A%0A%23%5Btokio%3A%3Amain%5D%0Aasync+fn+main%28%29+%7B%0A++++let+mut+futures+%3D+Vec%3A%3Anew%28%29%3B%0A++++for+n+in+1..%3D1_000+%7B%0A++++++++futures.push%28foo%28n%29%29%3B%0A++++%7D%0A++++let+joined_future+%3D+future%3A%3Ajoin_all%28futures%29%3B%0A++++joined_future.await%3B%0A%7D">a
thousand futures</a>. In fact, if we <a href="https://play.rust-lang.org/?mode=release&amp;edition=2021&amp;code=use+futures%3A%3Afuture%3B%0Ause+std%3A%3Atime%3A%3A%7BDuration%2C+Instant%7D%3B%0A%0Aasync+fn+foo%28_n%3A+u64%29+%7B%0A++++%2F%2F+Don%27t+print.+A+million+prints+is+too+much+output+for+the+Playground.%0A++++tokio%3A%3Atime%3A%3Asleep%28Duration%3A%3Afrom_secs%281%29%29.await%3B%0A%7D%0A%0A%23%5Btokio%3A%3Amain%5D%0Aasync+fn+main%28%29+%7B%0A++++let+start+%3D+Instant%3A%3Anow%28%29%3B%0A++++let+mut+futures+%3D+Vec%3A%3Anew%28%29%3B%0A++++for+n+in+1..%3D1_000_000+%7B%0A++++++++futures.push%28foo%28n%29%29%3B%0A++++%7D%0A++++let+joined_future+%3D+future%3A%3Ajoin_all%28futures%29%3B%0A++++joined_future.await%3B%0A++++let+time+%3D+Instant%3A%3Anow%28%29+-+start%3B%0A++++println%21%28%22time%3A+%7B%3A.3%7D+seconds%22%2C+time.as_secs_f32%28%29%29%3B%0A%7D">comment out the prints and
build in release mode</a>, we can run a <em>million</em> futures at
once. This sort of thing is why async is popular.</p>
</section>

<section>
<h2 id="important_mistakes">Important Mistakes</h2>

<p>We can get some hints about how async works if we start making mistakes. First,
let&#39;s try using <a href="https://doc.rust-lang.org/std/thread/fn.sleep.html"><code>thread::sleep</code></a> instead of <a href="https://docs.rs/tokio/latest/tokio/time/fn.sleep.html"><code>tokio::time::sleep</code></a> in our
async function:</p>

<pre><code><span>async </span><span>fn </span><span>foo</span><span>(</span><span>n</span><span>: </span><span>u64</span><span>) {</span></code></pre>

<p>(Playground running…)</p>

<p>Oh no! Everything is one-at-a-time again. It&#39;s an easy mistake to make,
unfortunately.<span>​<label for="sidenote-detect_blocking"></label><span>There have been <a href="https://async.rs/blog/stop-worrying-about-blocking-the-new-async-std-runtime/">attempts</a> to
automatically detect and handle blocking in async functions, but that&#39;s led
to <a href="https://tokio.rs/blog/2020-04-preemption#a-note-on-blocking">performance problems</a>, and it hasn&#39;t been possible
to handle <a href="https://www.reddit.com/r/rust/comments/ebfj3x/stop_worrying_about_blocking_the_new_asyncstd/fb4i9z5/">all cases</a>.</span></span> As we work through <a href="https://theleo.zone/books/how-to-know-a-person/async_futures.html">Part One</a>, it&#39;ll become
clear how <code>thread::sleep</code> gets in the way of async. For now, we might guess
that these <code>foo</code> functions running &#34;at the same time&#34; are actually all running
on one thread.</p>

<p>We can also try awaiting each future in a loop, the same way we originally
joined threads in a loop:</p>

<pre><code><span><span>#[</span><span>tokio</span><span>::</span><span>main</span><span>]</span></span></code></pre>

<p>This also doesn&#39;t work! What we&#39;re seeing is that futures don&#39;t do any work &#34;in
the background&#34;.<span>​<label for="sidenote-tasks"></label><span>&#34;Tasks&#34; are futures that run in the background. We&#39;ll get to those in
<a href="https://theleo.zone/books/how-to-know-a-person/async_tasks.html">Part Two</a>.</span></span> Instead, they do their work when we <code>.await</code> them. If
we <code>.await</code> them one-at-a-time, they do their work one-at-a-time. But somehow
<code>join_all</code> lets us <code>.await</code> all of them at the same time.</p>

<p>Ok, we&#39;ve got a lot of mysteries here. Let&#39;s start solving them.</p>

<hr/>


</section>
</article></div>
  </body>
</html>
