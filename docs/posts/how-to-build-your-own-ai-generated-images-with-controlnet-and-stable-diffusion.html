<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.datature.io/blog/how-to-build-your-own-ai-generated-image-with-controlnet-and-stable-diffusion">Original</a>
    <h1>How to Build Your Own AI-Generated Images with ControlNet and Stable Diffusion</h1>
    
    <div id="readability-page-1" class="page"><div fs-codehighlight-element="code" fs-toc-element="contents" fs-toc-offsettop="6rem" fs-toc-hideurlhash="true" fs-codehighlight-theme="base16/phd"><h2>What is Generative AI?</h2><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/62e939ff79009c74307c8d3e/646b2da25475be2a2a5f6aac_d7a7a360.png" alt=""/></p><figcaption>Example of background AI generated images</figcaption></figure><p>Generative AI refers to a type of artificial intelligence that is capable of generating new content that has not been explicitly programmed into the system. This is achieved by using machine learning algorithms to analyze and learn from large datasets, and then using that knowledge to create new content such as images, music, text, or even video.</p><p>Generative AI models are typically based on neural networks that use probabilistic methods to generate content that is similar to the training data, but not identical. For example, a generative AI model trained on a dataset of bird images might be able to generate new images of birds that have never been seen before.</p><h2>Why is Generative AI Useful?</h2><p>Generative AI has the potential to automate and streamline many tasks and processes, improve the quality and diversity of content, and provide new insights and predictions that can help individuals and organizations make better decisions. Specifically, it can be used in a variety of ways, such as:</p><ol role="list"><li><strong>Content Creation</strong>: Generative AI can be used to create new and original content, such as images, music, and text, that can be used in various industries, such as advertising, marketing, and entertainment.</li><li><strong>Data Augmentation</strong>: Generative AI can be used to create new data samples that are similar to existing data, which can be used to train machine learning models and improve their performance.</li><li><strong>Simulation</strong>: Generative AI can be used to create simulated environments and scenarios that can be used to test and evaluate new technologies, such as autonomous vehicles and robots.</li><li><strong>Personalization</strong>: Generative AI can be used to create personalized content, such as product recommendations and news articles, based on individual user preferences and behaviour.</li><li><strong>Predictive Analysis</strong>: Generative AI can be used to generate predictions and insights based on large datasets, such as predicting stock prices or identifying potential health risks.</li></ol><h2>What Images Can You Expect to Generate?</h2><p>Generative AI models excel at generating varying images in which there is a prominent object in the foreground and contextualized background. In these conditions, the models are capable of seamlessly replacing objects or backgrounds, changing graphic styles, or creating similar variations on images. This can allow users to easily create high quality art, create production quality product advertisement photos, or even augment and populate computer vision datasets by replacing backgrounds or foreground objects to cover edge cases.</p><h2>What are Some Generative AI Methods?</h2><p>There are many methods to generate data, ranging from more traditional cut-and-paste methods to from-scratch generation using state-of-the-art probabilistic models.</p><h4>Generative Adversarial Networks (GANs)</h4><p>Generative Adversarial Networks (GANs) are a type of generative AI technique that uses a system of two neural networks to generate new content. The first network, called the generator, creates new samples, such as images or text, from a random noise signal. The second network, called the discriminator, evaluates whether the generated samples are similar enough to the training data.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/62e939ff79009c74307c8d3e/646b302a33d628c34a69a920_7de59d54.png" alt=""/></p><figcaption>GAN architecture diagram (<a href="https://developers.google.com/machine-learning/gan/gan_structure" target="_blank">source</a>).</figcaption></figure><p>The generator and discriminator are trained together in a process known as adversarial training. The generator tries to create samples that can fool the discriminator into thinking they are real, while the discriminator tries to correctly classify the generated samples as fake. The result of this process is a generator network that is able to create new samples that are similar to the training data.</p><p>Despite their impressive results, GANs can be challenging to train and can suffer from issues such as mode collapse, where the generator produces a limited set of outputs rather than diverse and unique samples.</p><h4>Stable Diffusion</h4><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/62e939ff79009c74307c8d3e/646b305d23fd983a2c83ee95_4170454c.png" alt=""/></p><figcaption>Stable Diffusion model architecture diagram (<a href="https://scholar.harvard.edu/binxuw/classes/machine-learning-scratch/materials/stable-diffusion-scratch">source</a>).</figcaption></figure><p>Stable Diffusion is a variant of the diffusion process, which is a probabilistic model used in statistical physics to describe the behaviour of particles in a fluid. In the context of generative AI, <a href="https://stability.ai/blog/stable-diffusion-public-release" target="_blank">Stable Diffusion</a> refers to a method that gradually generates an image from a noise signal. The noise signal is passed through a sequence of increasingly complex convolutional neural networks (CNNs), with each network generating a slightly more refined version of the image. This process continues until the final output is generated, which is a high-quality image that is similar to the original training data.</p><p>The Stable Diffusion technique is designed to address some of the limitations of other generative AI techniques, such as generative adversarial networks (GANs), which can be unstable and difficult to train. Stable Diffusion is more stable and can produce high-quality, diverse, and realistic images that are suitable for a wide range of applications.</p><h2>Generating Product Images with Generative AI</h2><p>In this example, we will look at how we can combine certain methods together with traditional Computer Vision algorithms to generate more pristine images. The task for this example will be background augmentation for single objects, which can be used for a variety of applications such as object identification and product placement.</p><p>The three key ingredients for convincing and sufficiently varied images are:</p><ol role="list"><li><strong>Object Transform and Color Augmentations</strong>: creates more variation of the object to widen the variety of environments and scenarios it can be placed in.</li><li><strong>Background In-Painting</strong>: creates environmental variation in the background.</li><li><strong>Object In-Painting</strong>: fills in the background completely for a smoother transition between foreground and background.</li></ol><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/62e939ff79009c74307c8d3e/646b30ca6c21bdbdd8611f1f_e34a2ec3.png" alt=""/></p><figcaption>(a) Input image of a bottle of turmeric and ginger gummies (<a href="https://cdn.shopify.com/s/files/1/0542/8677/8559/products/Tumeric-and-Ginger-Gummy-Vitamin_a_1200x1200.jpg?v=1621213802" target="_blank">source</a>), and (b) binary mask of the bottle. The object is filled with black pixels which are preserved during the in-painting process, while the remaining parts of the image with white pixels will be regenerated by Stable Diffusion.</figcaption></figure><p>All experiments below are run on a NVIDIA RTX 3080. If you wish to replicate the results or perform your own testing, it is recommended to use a GPU with at least 12GB of VRAM.</p><h4>Stable Diffusion In-Painting</h4><p>The original intent of Stable Diffusion was to generate new images from pure noise. However, one modification that has been gaining attention is the process of in-painting. It is traditionally a computer vision technique used to fill in or restore missing or damaged parts of an image. It involves automatically filling in the missing regions of an image with plausible content, such that the filled-in areas appear visually coherent and seamless with the surrounding areas. By masking certain areas of an image, we can direct Stable Diffusion to modify only the masked areas by iteratively re-noising and then denoising them based on a textual prompt.</p><p>We first need to obtain a segmentation mask of the object, which we can annotate on Datature’s Nexus to obtain a segmentation polygon. We then convert the polygon into a binary mask, where black pixels are preserved and white pixels will be in-painted.</p><div><pre><code>def annotation_to_mask(image, annotation):
   &#34;&#34;&#34;Converts annotation to binary mask and saves it to disk.


   Args:
       image (np.array): Image to be masked.
       annotation (list):
           Annotation coordinates in the form of [x1, y1, x2, y2, ...].
   &#34;&#34;&#34;
   annotation = np.array([(int(x), int(y))
                          for x, y in zip(*[iter(annotation)] * 2)])
   mask = np.ones(image.shape[:2], np.float32) * 255
   cv2.fillPoly(mask, [annotation], color=(0, 0, 0))
   cv2.imwrite(f&#34;./mask/{IMAGE_NAME}&#34;, mask)</code></pre></div><p>We can then set up the Stable Diffusion pipeline by loading the image, mask, and set various parameters that are listed in the full code. To learn more on how the experimental parameters affect image generation, check out this <a href="https://blog.openart.ai/2023/02/13/the-most-complete-guide-to-stable-diffusion-parameters/" target="_blank">handy guide</a>. The prompt we will be using is “<em>on a table with turmeric and ginger</em>”.</p><div><pre><code># Load Stable Diffusion v2.1 checkpoint
pipe = StableDiffusionInpaintPipeline.from_pretrained(
    &#34;stabilityai/stable-diffusion-2-inpainting&#34;).to(DEVICE)


# Set generator seed for reproducibility
generator = torch.Generator(device=DEVICE)
generator = generator.manual_seed(SEED)


# Run inpainting to vary background
out_images = pipe(prompt=prompt,
                   negative_prompt=NEGATIVE_PROMPT,
                   image=input_image,
                   mask_image=mask,
                   height=HEIGHT,
                   width=WIDTH,
                   num_images_per_prompt=NUM_IMAGES_PER_PROMPT,
                   num_inference_steps=NUM_INFERENCE_STEPS,
                   guidance_scale=GUIDANCE_SCALE,
                   generator=generator).images
out_image = out_images[-1]</code></pre></div><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/62e939ff79009c74307c8d3e/646b318cdf737f5a46f60ca0_c2bc9523.png" alt=""/></p><figcaption>Output images after Stable Diffusion in-painting.</figcaption></figure><p>By in-painting the background instead of regenerating the whole image from scratch, Stable Diffusion is able to match the lighting conditions of the background with the object. However, there are a few imperfections, most notably that the borders between the object and the background are not pristine. The denoising process can sometimes warp the object which might not be ideal.</p><p>A less noticeable imperfection can be seen in the bottom row of text, which becomes gibberish. Though Stable Diffusion is known to be decent in generating text, especially in StabilityAI’s <a href="https://stability.ai/stablediffusion">latest XL model</a>, the text generation is typically guided by the prompt. In this case where there is existing text, it is not able to accurately reconstruct the text as this semantic information is not retained during the re-noising process. While larger text can be accurately reconstructed to a large degree, smaller text will suffer from being completely unintelligible. This is an issue that increasing the number of inference (denoising) steps to improve image quality and detail cannot solve.</p><h4>Two-Stage Background In-Painting</h4><p>To workaround this issue, we can perform object in-painting as a second stage to generate a pristine background. We then overlay the object (segmented from the original image using the binary mask) on top of the pristine background.</p><div><pre><code>
# Invert the binary mask so that object is in-painted
# while the background is preserved
inverted_mask = cv2.bitwise_not(mask)


# Mask out the object to use as an input image
out_image_foreground_extracted = cv2.bitwise_and(
    out_image, out_image, mask=inverted_mask)


# Run inpainting to fill in background
out_backgrounds = pipe(prompt=prompt,
                       negative_prompt=NEGATIVE_PROMPT,
                       image=out_image_foreground_extracted,
                       mask_image=inverted_mask,
                       height=HEIGHT,
                       width=WIDTH,
                       num_images_per_prompt=NUM_IMAGES_PER_PROMPT,
                       num_inference_steps=NUM_INFERENCE_STEPS,
                       guidance_scale=GUIDANCE_SCALE,
                       generator=generator).images
out_background = out_backgrounds[-1]


# Overlay object on background
for i in range(input_image.shape[0]):
   for j in range(input_image.shape[1]):
       if mask_image[i][j] &lt;= 100:
           out_image[i][j][:] = input_image[i][j][:]
       else:
           out_image[i][j][:] = out_background[i][j][:]

</code></pre></div><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/62e939ff79009c74307c8d3e/646b31e3e6c2b20c08bfb064_0af1d71d.png" alt=""/></p><figcaption>(a) Output image from Stable Diffusion in-painting with the object masked out, (b) output image of the full background after a second pass through Stable Diffusion, and (c) final image after overlaying the segmented object onto the background.</figcaption></figure><p>The final image is crisper and looks more realistic. This seems to be a potential solution that can be used for image augmentation. However, we note that the object is still static. Its dimensions, location, and orientation are unchanged. This limits the amount of variation in the resulting generated dataset, and also limits Stable Diffusion in its generative power.</p><p>A solution to this is to perform traditional augmentations to the original image before it is fed into the Stable Diffusion pipeline. A popular library to do this is <a href="https://albumentations.ai/" target="_blank">Albumentations</a>, which efficiently implements a rich variety of image transform operations that are optimized for performance. It is widely used both in industry and in deep learning research.</p><div><pre><code>
TRANSFORM = A.ReplayCompose([
   A.ShiftScaleRotate(shift_limit=0.3,
                      scale_limit=[-0.4, -0.3],
                      rotate_limit=10,
                      p=1.0,
                      border_mode=cv2.BORDER_CONSTANT,
                      value=[255, 255, 255],
                      mask_value=[255, 255, 255])
])

</code></pre></div><p>A sample transformation is shown by shifting, scaling, and rotating the object with varying parameters. When the transformed image is fed into the Stable Diffusion pipeline, we obtain the following images:</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/62e939ff79009c74307c8d3e/646b35988a08e9c914fc737d_fda0e507.png" alt=""/></p><figcaption>Output images after transformations and in-painting.</figcaption></figure><p>Further testing with other input images yields the following results:</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/62e939ff79009c74307c8d3e/646b35988a08e9c914fc73f4_e6b5802e.png" alt=""/></p><figcaption>(a) Input image of a pink luggage (<a href="https://hips.hearstapps.com/hmg-prod/images/gh-072522-away-luggage-1658760915.png?crop=0.651xw:1.00xh;0.175xw,0&amp;resize=1200:*">source</a>), and (b) binary mask of the pink luggage.</figcaption></figure><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/62e939ff79009c74307c8d3e/646b3599a725242fc8b4f2f9_345d9441.png" alt=""/></p><figcaption>Output images with prompt: “<em>luggage on the sidewalk</em>”.</figcaption></figure><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/62e939ff79009c74307c8d3e/646b35992bb254ea3ad44b68_87c9a5e9.png" alt=""/></p><figcaption>Output images with prompt: “<em>luggage in a train station</em>”.</figcaption></figure><p>The benefit of using transformation augmentations is that segmentation masks already exist for the objects, as the same transformations can be easily applied to the original mask.</p><h4>Colour Augmentation with InstructPix2Pix</h4><p>To create even more variation, we can utilize InstructPix2Pix to modify other aspects of the object. InstructPix2Pix is a conditional diffusion method for editing images from human instructions that combines the powers of Stable Diffusion and GPT-3. It is currently not robust enough to make drastic modifications to images without losing semantic information, hence our example will simply be to modify the colour of an object.</p><div><pre><code>
from diffusers import StableDiffusionInstructPix2PixPipeline

# Load InstructPix2Pix checkpoint
ip2p_pipe = StableDiffusionInstructPix2PixPipeline.from_pretrained(
   &#34;timbrooks/instruct-pix2pix&#34;, safety_checker=None).to(DEVICE)
ip2p_pipe.scheduler = EulerAncestralDiscreteScheduler.from_config(
   ip2p_pipe.scheduler.config)


# Run InstructPix2Pix to vary object
out_images = ip2p_pipe(prompt=object_prompt,
                   image=input_image,
                   num_images_per_prompt=NUM_IMAGES_PER_PROMPT,
                   num_inference_steps=NUM_INFERENCE_STEPS,
                   guidance_scale=GUIDANCE_SCALE,
                   generator=generator).images
out_image = out_images[-1]

</code></pre></div><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/62e939ff79009c74307c8d3e/646b35fca9c0297251dd31a3_ddf998ee.png" alt=""/></p><figcaption>(a) Input image of a pink luggage (<a href="https://hips.hearstapps.com/hmg-prod/images/gh-072522-away-luggage-1658760915.png?crop=0.651xw:1.00xh;0.175xw,0&amp;resize=1200:*">source</a>), and (b) output image from InstructPix2Pix with the prompt: “<em>make the luggage green in colour</em>”.</figcaption></figure><p>The resulting image can then be passed on to Stable Diffusion in-painting to obtain the following results:</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/62e939ff79009c74307c8d3e/646b35fc7d38f55421ed0655_c384a2dc.png" alt=""/></p><figcaption>Output images with prompt: “<em>luggage in a train station</em>”.</figcaption></figure><h4>Control Image Generation and Style Transfer with ControlNet</h4><blockquote>P.S. As pointed out by a fellow HackerNews reader, we clearly forgot to include our code snippet for ControlNet in the article.</blockquote><p>ControlNet can be similarly utilized If you wish to have some control over what is being generated, or perform some style transfers to your objects and backgrounds. Any input images can first be preprocessed to generate a Canny edge map, which is then fed into the ControlNet pipeline for directed generation. Further preprocessing may be needed depending on your input image and the level of detail desired for the image generation to be visually realistic.</p><div><pre><code>
from diffusers import ControlNetModel, StableDiffusionControlNetPipeline

# ... image loading code ...
image = ...

# Preprocess image to a Canny edge mask
# Modify these values to change the edge detection depending on your image
low_threshold = 100
high_threshold = 200

image = cv2.Canny(image, low_threshold, high_threshold)
image = image[:, :, None]
image = np.concatenate([image, image, image], axis=2)
canny_image = Image.fromarray(image)

# Load ControlNet and SD1.5 model
controlnet = ControlNetModel.from_pretrained(&#34;lllyasviel/sd-controlnet-canny&#34;, torch_dtype=torch.float16)
pipe = StableDiffusionControlNetPipeline.from_pretrained(
    &#34;runwayml/stable-diffusion-v1-5&#34;, controlnet=controlnet, torch_dtype=torch.float16
).to(DEVICE)

# Run image generation
out_images = pipe(
    prompt=PROMPT,
    negative_prompt=NEGATIVE_PROMPT,
    image=canny_image,
    height=HEIGHT,
    width=WIDTH,
    num_images_per_prompt=NUM_IMAGES_PER_PROMPT,
    num_inference_steps=NUM_INFERENCE_STEPS,
    guidance_scale=GUIDANCE_SCALE,
    generator=generator,
)

</code></pre></div><p>If you wish to replicate the results or experiment with your own images, check out this <a href="https://github.com/datature/resources/tree/script-library-refactor/example-scripts/generative-ai">link</a> to view the full suite of demo scripts.</p><h2>Limitations of Generative AI</h2><p>Generative AI is a potential solution for image augmentation/generation, however, it is not yet ready for any large-scale generation at this stage. There is no universal solution that can reliably work on custom datasets and there is insufficient fine-grained control over how images can be specifically augmented.</p><p>The generation is also not fully automatic since there is a lot of prompt engineering and cherry picking involved, which requires a lot of user intervention and a deeper understanding of the nature of the dataset. Due to the compute power and time necessary to generate these images, it would be impractical to scale up to large dataset generation without investing heavily in dedicated hardware.</p><div>
<div>
<table>
    <thead>
        <tr>
            <th>
                <span>Stage</span>
            </th>
            <th>
                <span>25 it</span>
            </th>
            <th>
                <span>50 it</span>
            </th>
            <th>
                <span>100 it</span>
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>InstructPix2Pix</td>
            <td>5.65</td>
            <td>10.25</td>
            <td>19.45</td>
        </tr>
        <tr>
            <td>SD In-Painting (Background)</td>
            <td>3.35</td>
            <td>6.35</td>
            <td>12.36</td>
        </tr>
        <tr>
            <td>SD In-Painting (Object)</td>
            <td>3.17</td>
            <td>6.42</td>
            <td>12.86</td>
        </tr>
        <tr>
            <td>
                <span>Total</span>
            </td>
            <td>12.17</td>
            <td>23.02</td>
            <td>44.67</td>
        </tr>
    </tbody>
</table>
</div></div><p>‍</p><p><em>Table of generation times (in seconds) for each stage against varying iteration steps.</em></p><p>Given the rate of development of methods like Stable Diffusion over the recent months, perhaps future research developments in this field would solve these limitations and render a more practical tool that can be easily adopted on any platform.</p><h3>Our Developer’s Roadmap</h3><p>Generative AI is a powerful tool that can boost the development of ML applications by reducing the effort required to curate and annotate large datasets. As the power of Generative AI grows, we plan to incorporate some of these techniques to quickly populate your datasets on <a href="https://www.datature.io/nexus">Nexus</a> for improved training performance and model robustness. Generative AI can also boost the expansion of our Public Datasets for the community to easily utilize for any use case.</p><h3>Want to Get Started?</h3><p>Check out the <a href="https://github.com/datature/resources/blob/main/example-scripts/generative-ai/product_generation_demo.ipynb">full notebook</a> if you wish to try augmenting your own images! If you have questions or would like to show off your custom-generated images, feel free to join our <a href="https://datature.io/community">Community Slack</a> or contact us about how Generative AI fits in with your usage. </p><p>For more detailed information about the functionality of different Generative AI models, customization options, or answers to any common questions you might have, read more about the process on our <a href="https://developers.datature.io/">Developer Portal</a>.</p></div></div>
  </body>
</html>
