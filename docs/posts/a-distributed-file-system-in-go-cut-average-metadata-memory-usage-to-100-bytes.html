<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://juicefs.com/en/blog/engineering/reduce-metadata-memory-usage">Original</a>
    <h1>A Distributed File System in Go Cut Average Metadata Memory Usage to 100 Bytes</h1>
    
    <div id="readability-page-1" class="page"><div>
                    
                        
                            <p><strong><em>TL;DR:</em></strong></p>
<p><em>JuiceFS, written in Go, can manage tens of billions of files in a single namespace. Its metadata engine uses an all-in-memory approach and achieves remarkable memory optimization, handling 300 million files with 30 GiB of memory and 100 microseconds response time. Techniques like memory pools, manual memory management, directory compression, and compact file formats reduced metadata memory usage by 90%.</em></p>
<p><a href="https://juicefs.com/docs/cloud/">JuiceFS Enterprise Edition</a>, a cloud-native distributed file system written in Go, can manage tens of billions of files in a single namespace. After years of iteration, <strong>it can manage about 300 million files with a single metadata service process using 30 GiB of memory, while maintaining the average processing time of metadata requests at 100 microseconds</strong>. In production, 10 metadata nodes each with 512 GB of memory collectively manage over 20 billion files.</p>
<p>For ultimate performance, our metadata engine uses an all-in-memory approach and undergoes continuous optimization. Managing the same number of files, <strong>it requires about only 27% of the memory of HDFS NameNode or 3.7% of CephFS Metadata Server (MDS)</strong>. This extremely high memory efficiency means that with the same hardware resources, JuiceFS can handle more files and more complex operations, thus achieving higher system performance.</p>
<p>In this post, we’ll delve into JuiceFS’ architecture, our metadata engine design, and <strong>optimization methods that reduced our average memory usage for metadata to 100 bytes</strong>. Our goal is to provide JuiceFS users with deeper insights and confidence in handling extreme scenarios. We also hope this post will serve as a valuable reference for designing large-scale systems.</p>
<h2>JuiceFS architecture</h2>
<p>JuiceFS consists of three major components:</p>
<ul>
<li>Client: This is the access layer that interacts with the application. JuiceFS supports multiple protocols, including POSIX, Java SDK, Kubernetes CSI Driver, and S3 Gateway.</li>
<li>Metadata engine: It maintains the directory tree structure of the file system and the properties of individual files.</li>
<li>Data storage: It stores the actual content of regular files, typically handled by object storage services like Amazon S3.</li>
</ul>
                        
                    
                        
                        
                        <figure>
                            <img data-src="https://static1.juicefs.com/images/JuiceFS_architecture.original.png" alt="JuiceFS Community Edition architecture"/>
                            <figcaption>JuiceFS Community Edition architecture</figcaption>
                        </figure>
                        
                    
                        
                            <p>Currently, JuiceFS offers two editions: <a href="https://juicefs.com/docs/community/introduction/">Community Edition</a> and Enterprise Edition. While their architectures share similarities, the key distinction lies in the implementation of the metadata engine:</p>
<ul>
<li>The Community Edition&#39;s metadata engine uses existing database services, such as Redis, PostgreSQL, and TiKV.</li>
<li>The Enterprise Edition features an in-house developed metadata engine. This proprietary engine not only delivers enhanced performance with reduced resource consumption but also provides additional support for enterprise-level requirements.</li>
</ul>
<p>The subsequent sections will explore our considerations and methodologies in developing the exclusive metadata engine for JuiceFS Enterprise Edition.</p>
<h2>Metadata engine design</h2>
<h3>Choosing Go as the development language</h3>
<p>The development of underlying system software is usually based on C or C++, while JuiceFS chose Go as the development language. This is because Go has the following advantages:</p>
<ul>
<li><strong>High development efficiency</strong>: Go syntax is more concise compared to C, with stronger expressive capabilities. Additionally, Go comes with built-in memory management functionality and powerful toolchains like pprof.</li>
<li><strong>Excellent program execution performance</strong>: Go itself is a compiled language, and programs written in Go generally do not lag behind C programs in the vast majority of cases.</li>
<li><strong>Better program portability</strong>: Go has better support for static compilation, making it easier for programs to run directly on different operating systems.</li>
<li><strong>Support for multi-language SDKs</strong>: With the help of the native cgo tool, Go code can also be compiled into shared library files (.so files), facilitating loading by other languages.</li>
</ul>
<p>While Go brings convenience, it hides some low-level details. This may affect the program&#39;s efficiency in using hardware resources to a certain extent, especially the management of memory by the garbage collector (GC). Therefore, targeted optimizations are needed at critical performance points.</p>
<h3>Performance boost strategies: all-in-memory, lock-free services</h3>
<p>To improve performance, we need to understand the core responsibilities of the metadata engine in a distributed file system. Typically, it’s mainly responsible for two important tasks:</p>
<ul>
<li>Managing metadata for a massive number of files</li>
<li>Quickly processing metadata requests</li>
</ul>
<h4>All-in-memory mode for managing massive files’ metadata</h4>
<p>To accomplish this task, there are two common design approaches:</p>
<ul>
<li><strong>Loading all file metadata into memory</strong>, such as HDFS NameNode. This can provide excellent performance but inevitably requires a large amount of memory resources.</li>
<li><strong>Caching only part of the metadata in memory</strong>, such as CephFS MDS. When the requested metadata is not in the cache, the MDS holds the request temporarily, retrieves the corresponding content from the disk (metadata pool) over the network, parses it, and then retries the operation. This can easily lead to latency spikes, affecting the user experience. Therefore, in practice, to meet the low-latency access needs of the application, the MDS memory limit is increased as much as possible to cache more files, even all files.</li>
</ul>
<p><strong>JuiceFS Enterprise Edition pursues ultimate performance and thus adopted the first all-in-memory approach</strong>, continuously optimizing to reduce the memory usage of file metadata. All-in-memory mode typically uses real-time transaction logs to persist data for reliability. JuiceFS also uses the Raft consensus algorithm to implement metadata multi-server replication and automatic failover.</p>
<h4>Lock-free approach for quick metadata processing</h4>
<p>The key performance metric of the metadata engine is the number of requests it can process per second. Typically, metadata requests need to ensure transactions and involve multiple data structures. Complex locking mechanisms are required during concurrent multithreading to ensure data consistency and security. When transactions conflict frequently, multithreading does not effectively improve throughput; instead, it may increase latency due to too many lock operations. This is especially evident in high-concurrency scenarios.</p>
<p><strong>JuiceFS adopted a different approach, similar to Redis&#39; lock-free mode</strong>. In this mode, all core data structure operations are executed in a single thread. This approach has the following advantages:</p>
<ul>
<li>The single-threaded approach ensures the atomicity of each operation (avoiding operations being interrupted by other threads) and reduces thread context switching and resource contention. Thereby it improves the overall efficiency of the system.</li>
<li>At the same time, it significantly reduces system complexity, enhances stability, and maintainability.</li>
<li>Thanks to the all-in-memory metadata storage mode, requests can be efficiently processed, and the CPU is not easily bottlenecked.</li>
</ul>
<h3>Multi-partition horizontal scaling</h3>
<p>The memory available to a single metadata service process has its limits, and efficiency gradually declines as memory usage per process increases. <strong>JuiceFS achieves horizontal scaling by aggregating metadata distributed across multiple nodes in virtual partitions, supporting larger data scales and higher performance demands</strong>.</p>
<p>Specifically, each partition is responsible for a portion of the file system&#39;s subtree, and clients coordinate and manage files across partitions to assemble the files into a single namespace. These files in the partitions can dynamically migrate as needed. For example, a cluster managing over 20 billion files may use 10 metadata nodes with 512 GB of memory each, deployed across 80 partitions. Typically, it&#39;s recommended to limit the memory of a single metadata service process to 40 GiB and manage more files through multi-partition horizontal scaling.</p>
<p>File system access often has strong locality, with files moving within the same directory or adjacent directories. Therefore, JuiceFS implemented a dynamic subtree splitting mechanism that maintains larger subtrees, minimizing most metadata operations to occur within a single partition. This approach significantly reduced the use of distributed transactions, ensuring that even after extensive scaling, the cluster maintains metadata response latencies similar to those of a single partition.</p>
<h2>How to reduce memory usage</h2>
<p>As data volume increases, the memory requirements for metadata services also rise. This impacts system performance and escalates hardware costs. Thus, reducing metadata memory usage is critical for maintaining system stability and cost control in scenarios involving massive files.</p>
<p>To achieve this goal, we&#39;ve explored and implemented extensive optimizations in memory allocation and usage. Below, we&#39;ll discuss some measures that have proven effective through years of iteration and optimization.</p>
<h3>Using memory pools to reduce allocation</h3>
<p>Using memory pools to reduce allocation is a common optimization technique in Go programs, primarily using the <code>sync.Pool</code> structure from the standard library. The principle is not discarding data structures after use but returning them to a pool. When the same type of data structure is needed again, it can be retrieved directly from the pool without allocation. This approach effectively reduces the frequency of memory allocation and deallocation, thereby enhancing performance.</p>
<p>For example:</p>
<pre><code>pool := sync.Pool{
   New: func() interface{} {
       buf := make([]byte, 1&lt;&lt;17)
       return &amp;buf
 },
}
buf := pool.Get().(*[]byte)
// do some work
pool.Put(buf)
</code></pre>

<p>During initialization, typically we need to define a <code>New</code> function to create a new structure. When we use the structure, we use the <code>Get</code> method to obtain the object and convert it to the corresponding type. After we finish using it, we use the <code>Put</code> method to return the structure to the pool. It&#39;s worth noting that after being returned, the structure in the pool has only a weak reference and may be garbage-collected at any time.</p>
<p>The structure in the example above is a segment of pre-allocated memory slices, essentially creating a simple memory pool. When combined with the finer management techniques discussed in the next section, it enables efficient memory utilization in programs.</p>
<h3>Manual management of small memory allocations</h3>
<p>In the JuiceFS metadata engine, the most critical aspect is maintaining the directory tree structure, which roughly looks like this:</p>
                        
                    
                        
                        
                        <figure>
                            <img data-src="https://static1.juicefs.com/images/MuLuShuJieGou.original.png" alt="Directory tree structure"/>
                            <figcaption>Directory tree structure</figcaption>
                        </figure>
                        
                    
                        
                            <p>In this structure:</p>
<ul>
<li>A node records attributes of each file or directory, typically occupying 50 to 100 bytes.</li>
<li>An edge describes the relationship between parent and child nodes, generally occupying 60 to 70 bytes.</li>
<li>An extent records the location of data, typically occupying about 40 bytes.</li>
</ul>
<p>These structures are small but numerous. Go&#39;s GC does not support generations. This means if they are all managed by the GC, it needs to scan them all during each memory scan and mark all referenced objects. This process can be slow, preventing timely memory reclamation and consuming excessive CPU resources.</p>
<p>To efficiently manage these massive small objects, we used the <code>unsafe</code> pointer (including <code>uintptr</code>) to bypass Go&#39;s GC for manual memory allocation and management. In implementation, the metadata engine requests large blocks of memory from the system and then splits them into small blocks of the same size. When saving pointers to these manually allocated memory blocks, we preferred using <code>unsafe.Pointer</code> or even <code>uintptr</code> types, relieving the GC from scanning these pointers and significantly reducing its workload during memory reclamation.</p>
<p>We designed a metadata memory pool named Arena, containing multiple buckets to isolate structures of varying sizes. Each bucket holds large memory blocks, such as 32 KiB or 128 KiB. When metadata structures are needed, the Arena interface locates the corresponding bucket and allocates a small segment from it. After use, it informs Arena to return it to the memory pool. Arena’s design diagram is as follows:</p>
                        
                    
                        
                        
                        <figure>
                            <img data-src="https://static1.juicefs.com/images/NeiCunChi_Arena.original.png" alt="Design of a JuiceFS metadata memory pool"/>
                            <figcaption>Design of a JuiceFS metadata memory pool</figcaption>
                        </figure>
                        
                    
                        
                            <p>The management details are complicated. If you’re interested, you can learn more about the implementation principles of memory allocators such as <code>tcmalloc</code> and <code>jemalloc</code>. Our design ideas are similar to them.
Below is a block of key code in Arena:</p>
<pre><code>// Resident memory blocks
var slabs = make(map[uintptr][]byte)
p := pagePool.Get().(*[]byte) // 128 KiB
ptr := unsafe.Pointer(&amp;(*p)[0])
slabs[uintptr(ptr)] = *p
</code></pre>

<p>Here, <code>slabs</code> is a global map that records all allocated memory blocks in Arena. It allows the GC to know that these large memory blocks are in use.
The following code creates structures:</p>
<pre><code>func (a *arena) Alloc(size int) unsafe.Pointer {...}

size := nodeSizes[type]
n := (*node)(nodeArena.Alloc(size))

// var nodeMap map[uint32, uintptr]
nodeMap[n.id] = uintptr(unsafe.Pointer(n)))
</code></pre>

<p>The <code>Alloc</code> function of Arena requests memory of a specific size and returns an <code>unsafe.Pointer</code> pointer. When we create a node, we first determine the size required by its type and then convert the obtained pointer to the desired structure type. If necessary, we convert this <code>unsafe.Pointer</code> to <code>uintptr</code> and store it in <code>nodeMap</code>. This map is a large mapping used to quickly find the corresponding structure based on the node ID.</p>
<p>From the perspective of the GC, it appears that the program has requested many 128 KiB memory blocks that are constantly in use, but it doesn&#39;t need to worry about the content inside. Additionally, although <code>nodeMap</code> contains hundreds of millions or even billions of elements, all its key-value pairs are of numeric types, so the GC doesn&#39;t need to scan each key-value pair. This design is friendly to the GC, and even with hundreds of gigabytes of memory, it can easily complete the scan.</p>
<h3>Compressing idle directories</h3>
<p>As mentioned above, file system access has strong locality, with applications often accessing only a few specific directories frequently, leaving other parts idle. Based on this observation, we compressed inactive directory metadata to reduce memory usage. The process is as below:</p>
                        
                    
                        
                        
                        <figure>
                            <img data-src="https://static1.juicefs.com/images/MuLuXuLieHuaHeYaSuo.original.png" alt="JuiceFS directory serialization and compression"/>
                            <figcaption>JuiceFS directory serialization and compression</figcaption>
                        </figure>
                        
                    
                        
                            <p>When the <code>dir</code> directory is idle, its metadata, along with all its immediate child items, can be compactly serialized into a contiguous memory buffer according to a predefined format. Then, this buffer can be compressed to a smaller size.</p>
<p>Typically, serializing multiple structures together can save nearly half of the memory, and compression can further reduce memory usage by approximately one-half to two-thirds. Thus, this method significantly lowers the average memory usage of individual file metadata. However, the serialization and compression processes consume certain CPU resources and may increase request latency. To balance efficiency, we monitor CPU status internally and trigger this process only when the CPU is idle, limiting the number of files processed to 1,000 per operation to ensure quick completion.</p>
<h3>Designing more compact formats for small files</h3>
<p>To support efficient random read and write operations, JuiceFS indexes metadata of regular files into three levels: fnodes, chunks, and slices. Chunks are an array, and slices are stored in a hash table. Initially, each file required allocation of these three memory blocks. However, we found this method inefficient for most small files, because they typically have only one chunk, which in turn has only one slice, and the slice&#39;s length is the same as the file&#39;s length.</p>
<p>Therefore, we introduced a more compact and efficient memory format for such small files. In the new format, we only need to record the slice ID and derive the slice length from the file&#39;s length, without storing the slice itself. Additionally, we adjusted the structure of fnodes. Previously, fnodes stored a pointer to the chunks array, which contained only an 8-byte slice ID. Now, we store this ID in the pointer variable. This usage is similar to a union structure in the C language, storing different types of data in the same memory location based on the situation. After these adjustments, each small file only has one fnode object, without requiring additional chunk lists and slice information.</p>
                        
                    
                        
                        
                        <figure>
                            <img data-src="https://static1.juicefs.com/images/chunks.original.png" alt="Small file optimization"/>
                            <figcaption>Small file optimization</figcaption>
                        </figure>
                        
                    
                        
                            <p>The optimized format saved about 40 bytes of memory per small file. Moreover, it reduced memory allocation and indexing operations, resulting in faster access.</p>
<h2>Overall optimization effects</h2>
<p>The figure below summarizes our optimization results:</p>
                        
                    
                        
                        
                        <figure>
                            <img data-src="https://static1.juicefs.com/images/avg.original.png" alt="Memory usage optimization results"/>
                            <figcaption>Memory usage optimization results</figcaption>
                        </figure>
                        
                    
                        
                            <p>In the figure, the average metadata size of files significantly decreased:</p>
<ol>
<li>Initially, the average metadata size per file was nearly 600 bytes.</li>
<li><strong>Through manual memory management, this number dropped to about 300 bytes, substantially reducing GC overhead</strong>. </li>
<li>Subsequently, <strong>by serializing idle directories, it was further reduced to about 150 bytes</strong>.</li>
<li>Finally, <strong>through memory compression techniques, the average size decreased to about 50 bytes</strong>.</li>
</ol>
<p>However, the metadata service is also doing tasks such as status monitoring, session management, and handling network transfers. This may increase memory usage beyond this core value. Therefore, we generally estimate hardware resources based on 100 bytes per file.</p>
<p>The single-file memory usage of common distributed file systems is as follows:</p>
<ul>
<li>HDFS: 370 bytes (source: online cluster monitoring — 52 GB memory, 140 million files)</li>
<li>CephFS: 2,700 bytes (source: Nautilus version cluster monitoring — 32 GB memory, 12 million files)</li>
<li>Alluxio (heap mode): 2,100 bytes (source: <a href="https://docs.alluxio.io/ee-da/user/stable/en/operation/Metastore.html">Alluxio documentation</a> — 64 GB memory, 30 million files)</li>
<li>JuiceFS Community Edition Redis engine: 430 bytes (source: <a href="https://juicefs.com/docs/community/redis_best_practices/">Redis Best Practices</a>)</li>
<li>JuiceFS Enterprise Edition: 100 bytes (source: online cluster monitoring — 30 GB memory, 300 million files)</li>
</ul>
<p><strong>JuiceFS demonstrates outstanding performance in metadata memory usage, accounting for only 27% of HDFS NameNode and 3.7% of CephFS MDS</strong>. This not only signifies higher memory efficiency but also means that JuiceFS, with the same hardware resources, can handle more files and more complex operations, thereby improving overall system performance.</p>
<h2>Conclusion</h2>
<p>One of the core components of a file system lies in its metadata management. When building a distributed file system capable of handling tens of billions of files, this design task becomes particularly complex.</p>
<p>This article introduced JuiceFS’ key decisions in designing its metadata engine and elaborated on <strong>four memory optimization techniques: memory pools, manual management of small memory blocks, compression of idle directories, and optimization of small file formats</strong>. These measures are the results of our continuous exploration, experimentation, and iteration, ultimately <strong>reducing JuiceFS’ average memory usage for file metadata to 100 bytes</strong>. This makes JuiceFS more adaptable to a wider range of extreme application scenarios.</p>
<p>If you have any questions or would like to learn more, feel free to join JuiceFS <a href="https://github.com/juicedata/juicefs/discussions">discussions on GitHub</a> and our <a href="https://juicefs.slack.com/ssb/redirect">community on Slack</a>.</p>
                        
                    
                        
                        <div>
                            <h2>Author</h2>
                            
                            <div>
                                
                                <div>
                                    <p><span>Sandy</span></p><p>JuiceFS Core System Engineer</p>
                                </div>
                            </div>
                            
                        </div>
                        
                    </div></div>
  </body>
</html>
