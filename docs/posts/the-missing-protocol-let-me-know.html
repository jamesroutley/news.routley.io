<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://deanebarker.net/tech/blog/let-me-know/">Original</a>
    <h1>The Missing Protocol: Let Me Know</h1>
    
    <div id="readability-page-1" class="page"><article>

    


<hgroup>
  
  
</hgroup>



<header data-no-index="">
    
  

    
      
    
    
      
    
    <span>•</span>
  

  
    <span><time datetime="2025-08-05">August 5, 2025</time></span>
    <span>•</span>
  
  
  

</header>





    




    


    

    










<img src="https://deanebarker.net/tech/blog/images/lmk.png?w=400" loading="lazy"/>



<p>I want a new protocol, tentatively called “Let Me Know” (LMK). The purpose is to provide someone an anonymous way to get notified when a singular, specific event occurs.</p>
<p>Here’s a basic use case:</p>
<blockquote>
<p>Some random blog author has published Parts 1 and 2 of a series. You enjoyed it, and you want to know when Part 3 is published.</p>
<p>You don’t want to give away any personal information, you don’t want to subscribe to an RSS feed of other content, you don’t want to follow them on social media, etc. You just want an anonymous way to find out when Part 3 is published without having to manually check their website and evaluate it for the content.</p>
</blockquote>
<p>My idea is that there’s a button at the bottom of Part 2, called “Let Me Know.”</p>
<p>The user clicks this, and it registers an endpoint with some agent.</p>
<ul>
<li>The “endpoint” is a URL specific to that singular event.</li>
<li>An “agent” is a persistent background service of some kind that will check to see if this event has occurred. For example, a browser extension will add it to a “check list.” Alternately, some subscription service could add it to a list.</li>
</ul>
<p>Whatever agent registers the endpoint will ping the end point at a specific interval. Let’s say once per day by default.</p>
<p>The endpoint will often simply return:</p>
<pre><code>{
  &#34;happened&#34;: false
}
</code></pre>
<p>Or:</p>
<pre><code>204 No Content
</code></pre>
<p>Either of those responses mean, “The subscribed event has not happened yet. Check back later.”</p>
<p>Alternately, the endpoint can advise the agent when to check again.</p>
<pre><code>{
  &#34;happened&#34;: &#34;false&#34;,
  &#34;delay&#34;: 604800 // Don&#39;t check again for one week
}
</code></pre>
<p>Your agent will keep dutifully checking on its default schedule, or obeying the delay response if it’s provided.</p>
<p>But hopefully, on some bright shining day in the future, something like this will be returned:</p>
<pre><code>{
  &#34;happened&#34;: true,
  &#34;when&#34;: &#34;2025-08-06T05:38:20.234Z&#34;,

  // This can be included in the notification
  &#34;message&#34;: &#34;Part 3 of the Awesome Blog Post Series has finally been published!&#34;,

  // The notification can provide one or more things to do from here
  &#34;actions&#34;:
  [
    {
      &#34;Read the post&#34;,
      &#34;https://domain.com/part-3&#34;
    },
    {
      &#34;Visit the home page&#34;,
      &#34;https://domain.com/&#34;
    }
  ]
}
</code></pre>
<p>You will get this notification… somehow.</p>
<ul>
<li>If your agent is in a browser extension, you might get a pop-up.</li>
<li>If you agent is some subscription service, you might get an email.</li>
<li>If your agent is a mobile app, you might get a push notification.</li>
</ul>
<p>But <em>somehow</em>, you will be notified that the event – whatever the thing was you were waiting for – has occured.</p>








<picture><source srcset="/tech/blog/images/lmk-alert.png?w=480" media="(max-width: 480px)"/><img src="https://deanebarker.net/tech/blog/images/lmk-alert.png?w=500" loading="lazy" width="500" height="124"/></picture>



<p>And then – and this is key – <em>the endpoint is automatically deleted from your agent</em>.</p>
<p>The event has happened, so the agent does not check again. The one task you assigned to it has been completed. If you want to find out about Part 4, you’ll subscribe (presumably) using a button at the bottom of Part 3. Or not. Whatever.</p>
<p>At any given time, you can review the endpoints registered in your agent, see when they were registered, when they were last checked, when they are scheduled to check again, force then to check again, etc. And you can delete any that you don’t really care about anymore.</p>
<p>As for the button that lets you subscribe to the event (which has now occurred), a few things could happen:</p>
<ol>
<li>The author could manually delete it.</li>
<li>If the endpoint architecture was built into their CMS, it could be automatically suppressed when the event happens (or, more likely, proactively display when the event hasn’t happened yet; default would be to not display).</li>
<li>The button could consist of some client-side code that would ping the endpoint itself and decide whether or not to display.</li>
</ol>
<p>If the button still shows up after the event has occured, it’s not that big of a deal. If an agent tries to register an endpoint for an event that has occured, the worst that could happen is that it notifies immediately. Alternately, the agent could detect this when it tries to register and notify the user that there’s no point in registering it and provide the actions from the response.</p>
<p>From the author’s standpoint, their CMS or other system could have an “LMK Control Panel” that would let them register new endpoints, manually resolve endpoints by providing messages and actions (they would “publish a resolution,” archive endpoints, get “ping analytics” of the traffic to specific endpoints, etc.</p>
<p>And… that’s it. That’s all it does.</p>
<p>You register an endpoint, the agent starts checking it, and then the agent lets you know when the endpoint returns in the affirmative.</p>
<p>You have never given anyone any personal information. Your agent checking the endpoint is as anonymous as you visiting the website. There is no commitment or cognitive overhead – you’re not exposed to a bunch of other events of content you don’t care about, and if the event never happens, you will never hear about it again.</p>
<p>There’s no AI to this. No magic. No problems to be solved. Like any standard or protocol, it’s just a matter of agreeing on it and evangelizing it.</p>
<p>But…</p>
<p>I showed this all to a friend, and he pointed out the “Subscribe” button “at the bottom of every YouTube video.”</p>
<p>I responded:</p>
<blockquote>
<p>Yeah, but I don’t want to “subscribe.” I just want to know when this ONE THING happens.</p>
<p>There might be 20 unrelated videos between the one I watched and the Part 2 that I want to see. Just yell when Part 2 is out, and then never talk to me again and forget we ever had this interaction, unless I subscribe to something else.</p>
</blockquote>
<p>And he responded with the cold, hard truth:</p>
<blockquote>
<p>That makes sense. I can understand why you’re asking for that, and can understand why creators would never want to build it</p>
</blockquote>
<p>…[sigh]. Yeah.</p>
<h2>Technical Postscript</h2>
<p>The only thing I might add is a <code>/meta</code> pseudo-endpoint that would provide data about the endpoint. It could return something like this:</p>
<pre><code>{
  &#34;created&#34;: &#34;2025-08-05&#34;,
  &#34;purpose&#34;: &#34;To notify when Part 2 of Awesome Blog Post Series is published&#34;
  &#34;contact&#34;: &#34;deane@deanebarker.net &lt;Deane Barker&gt;&#34;,
  &#34;happened&#34;: false // So the agent can filter for active events
}
</code></pre>
<p>Your agent could retrieve this when the endpoint is registered and use the data to maintain its list and give you more information about the endpoints you’re checking.</p>



<!--
<link rel="stylesheet" href="/assets/highlight/styles/base16/railscasts.min.css"/>
<script src="/assets/highlight/highlight.min.js"></script>
<script src="/assets/highlight/languages/javascript.min.js"></script>
<script src="/assets/highlight/languages/html.min.js"></script>
<script src="/assets/highlight/languages/css.min.js"></script>
<script src="/assets/highlight/languages/json.min.js"></script>

<script>document.addEventListener('DOMContentLoaded', (e) => { hljs.highlightAll(); });</script>
-->
<!-- 2025-08-05: I changed how this is managed. This code will gradually get removed from the site. -->




    



    

</article><p>
            This is item <strong>#2</strong> in a sequence of <strong>364</strong> items.
        </p></div>
  </body>
</html>
