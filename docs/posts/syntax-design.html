<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cs.lmu.edu/~ray/notes/syntaxdesign/">Original</a>
    <h1>Syntax Design</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div>
        

<p>One of the most recognizable features of a languages is its syntax. What are some of the things about syntax that matter?</p>

<h2>Motivation</h2>

<p>A programming language <strong>gives us a way structure our thoughts</strong>. Each program, has a kind of internal structure, for example:</p>

<p><img src="https://cs.lmu.edu/~ray/images/ast.png%20" alt="ast.png"/></p>
<p>How can we capture this structure? One way is directly, via pictures. The elements in such a language can be high-level or low-level:</p>
<p>
  <img src="https://cs.lmu.edu/~ray/images/snap.png"/>
    
  <img src="https://cs.lmu.edu/~ray/images/blueprints.png"/>
</p>

<p>But <strong>text is more dense than pictures</strong>, and more directly machine readable at times (no computer vision machine learning necessary). Even if your language was expressed with pictures, there will be an underlying byte-array, or string, representation for storage and transmission. So our focus from now on will be on text.</p>

<p><b>Exercise</b>: But don’t miss Bret Victor’s <a href="https://vimeo.com/71278954">The Future of Programming</a> for thoughts on programming visually.
</p>
<h2>Bracketing</h2>

<p>We really do want our languages to be close to the <dfn>abstract syntax tree</dfn> that represents them. We didn&#39;t always do this: in the early days programs were lists of statements with jumps, otherwise known as <dfn>gotos</dfn>. But how do we capture trees as text?</p>

<p>There are two main approaches. The first is to just give a <b>direct representation</b> of the syntax tree. The other is to be <b>creative with syntax</b>, making something that a human might possibly like to read.

</p><p>Let’s play around with the above tree and see what we come up with.

</p><h3>S-Expressions</h3>

<p>The usual direct representation of trees in strings is that of <dfn>S-expressions</dfn>—parenthesized forms such as (A B C D) where A is the root and B, C, and D are A’s (ordered) children. The children can be primitive values or even...wait for it...trees.

</p><pre>(function f (params x y)
    (block
        (var b 3)
        (if (&lt; x (* a (+ b 7)))
            (while found
                (block
                    (for i (range 2 5) (print i))
                    (if (== a 2) (break))))
            (= p (cos 5)))
        (return (/ a 5))))
</pre>

<p>Beautiful, right? Well-loved languages like LISP, Scheme, Racket, and Clojure use S-expressions (though with a few little extensions here and there so as not to drive programmers totally insane).

</p><p>Notice in the example above, some of the objects aren’t actually evaluated. We’re seeing the distinction between <dfn>symbols</dfn> and <dfn>value expressions</dfn>. Can we make this explicit in the syntax? Yes we can:

</p><pre>(function :f (params :x :y)
    (block
        (var :b 3)
        (if (&lt; x (* a (+ b 7)))
            (while found
                (block
                    (for :i (range 2 5) (print i))
                    (if (== a 2) (break))))
            (= p (cos 5)))
        (return (/ a 5))))
</pre>

<p>Here <code>:x</code> means just “the symbol <code>x</code>.” It’s just a symbol, nothing more, nothing less. On the other hand, <code>x</code> is an expression that means “go look up the value associated with the symbol <code>:x</code> an use this value.”

</p><p>That is a pretty huge difference, isn’t it?

</p><p><b>Exercise</b>: Explain this difference to your neighbor.
</p>
<h3>XML Style</h3>

<p>The tree can be given directly in XML, too. This is ridiculously verbose, not only because we have some markup characters, but because we have to invent elements for leaf nodes. Why are we looking at this? Not to ruin your day, but rather, to show, viscerally, that it’s possible to show hierarchical structures as strings in more than one way.

</p><p>Please do not do anything like this.</p>

<pre>&lt;function name=&#34;f&#34; params=&#34;x,y&#34;&gt;
  &lt;block&gt;
    &lt;var id=&#34;b&#34;&gt;&lt;intlit value=&#34;3&#34;/&gt;&lt;/var&gt;
    &lt;if&gt;
      &lt;less&gt;
        &lt;ref id=&#34;x&#34;/&gt;
        &lt;times&gt;
          &lt;ref id=&#34;a&#34;/&gt;
          &lt;plus&gt;&lt;ref id=&#34;b&#34;/&gt;&lt;intlit value=&#34;7&#34;&gt;&lt;/plus&gt;
        &lt;/times&gt;
      &lt;/less&gt;
      &lt;while&gt;
        &lt;ref id=&#34;found&#34;/&gt;
        &lt;block&gt;
          &lt;for var=&#34;i&#34;&gt;
            &lt;range&gt;&lt;intlit value=&#34;2&#34;/&gt;&lt;intlit value=&#34;5&#34;/&gt;&lt;/range&gt;
            &lt;print&gt;&lt;ref id=&#34;i&#34;/&gt;&lt;/print&gt;
          &lt;/for&gt;
          &lt;if&gt;
            &lt;eq&gt;&lt;ref id=&#34;a&#34;/&gt;&lt;intlit value=&#34;2&#34;/&gt;&lt;/eq&gt;
            &lt;break/&gt;
          &lt;/if&gt;
        &lt;/block&gt;
      &lt;/while&gt;
      &lt;assign&gt;
        &lt;ref id=&#34;p&#34;/&gt;
        &lt;cos&gt;&lt;intlit value=&#34;5&#34;/&gt;&lt;/cos&gt;
      &lt;/assign&gt;
    &lt;/if&gt;
    &lt;return&gt;&lt;intlit value=&#34;5&#34;/&gt;&lt;/return&gt;
  &lt;/block&gt;
&lt;/function&gt;
</pre>

<p>A slight simplification is to make something like this:</p>

<pre>Function { 
    name: &#34;f&#34;, 
    params: [&#34;x&#34;, &#34;y&#34;], 
    body: Block { statements: [
        Var { id: &#34;b&#34;, init: 3 },
        If {
            condition: Less { 
                left: &#34;x&#34;, 
                right: Multiply { 
                    left: &#34;a&#34;, right: Plus { left: &#34;b&#34;, right: 7 } } },
            truePart: While {
                condition: &#34;found&#34;, 
                body: Block { statements: [
                    For {
                        var: &#34;i&#34;,
                        range: Range { low: 2, high: 5 },
                        body: Print { args: [&#34;i&#34;] } },
                    If {
                        condition: Eq { left: &#34;a&#34;, right: 2 },
                        truePart: Break { } } ] } },
            falsePart: Assign { target: &#34;p&#34;, source: Cos { args: [ 5 ] } } },
        Return { value: 5 } ] } }
</pre>

<h3>Indentation</h3>

<p>Okay, let’s move away from direct representations and use some “real syntax.” By real syntax we mean creatively arranging symbols in a pleasing and readable way but still having it be possible to unambiguously recapture the tree structure. How about indenting? (The technical term for this approach is the <a href="https://en.wikipedia.org/wiki/Off-side_rule">Off-side rule</a>.)

</p><pre>function f(x, y)
    var b = 3
    if x &lt; a * (b + 7)
        while found
            for i in 2..5
                print i
            if a == 2
                break
    else
        p = cos(5)
    return a / 5
</pre>

<h3>Curly Braces</h3>

<p>The use of curly braces to define subtrees is, for some reason, very popular.</p>

<pre>function f(x, y) {
    var b = 3;
    if x &lt; a * (b + 7) {
        while found {
            for i in 2..5 {
                print i;
            }
            if a == 2 {
                break;
            }
        }
    } else {
        p = cos(5);
    }
    return a / 5;
}
</pre>

<h3>Terminating Keywords</h3>

<p>Rather than marking the beginning and end of a block, as is done with the curly brace style and its equivalents, we can get away with just marking the end. It’s true! This can be done simply with the word <code>end</code>:</p>

<pre>function f(x, y)
    var b = 3
    if x &lt; a * (b + 7)
        while found
            for i in 2..5
                print i
            end
            if a == 2
                break
            end
        end
    else
        p = cos(5)
    end
    return a / 5
end
</pre>

<p>or by spelling the initial word backwards (yes, laugh if you want but this is a real thing):</p>

<pre>function f(x, y)
    var b = 3
    if x &lt; a * (b + 7)
        while found
            for i in 2..5
                print i
            rof
            if a == 2
                break
            fi
        elihw
    else
        p = cos(5)
    fi
    return a / 5
noitcnuf
</pre>

<h3>Postfix Style</h3>

<p>A postfix style representation allows pretty simple evaluation on a stack machine. Here it’s crucial to distinguish symbols from variables—it’s pretty hard (impossible in general?) to distinguish a defining occurrence of an identifier from a using occurrence. We sometimes have to bundle <dfn>code blocks</dfn>; here I used square brackets for that purpose:</p>

<pre>[ :x param :y param ]
[
    3 :b var
    x a b 7 + * &lt;
    [
        found
        [
            :i 2 5 [i print] for
            2 a == [break] [] if
        ]
    while]
    [5 cos p assign]
    if
    a 5 / return
] :f function
</pre>

<p>How do you make sense of this? Evaluate the code directly on a stack. When you see a value, including a block, push it on the stack. When you see an operator, apply it to the element(s) on the stack top.</p>

<p><b>Exercise</b>: If you’ve ever taken a compilers class, or written a compiler or interpreter for fun, write an interpreter for the little “language” above.
</p>
<h3>Sugary Functional Style</h3>

<p>Did you know it’s possible for everything in a language to be the composition of function calls, and yet look like it has statements?</p>

<pre>function f(x, y) =
    let
        b = 3
    in
        if x &lt; a * (b + 7) then
            while found do (
                for i in 2..5
                    print i
                ;
                if a == 2 then
                    break
                else
                    nil
            )
        else
            p = cos(5)
        ;
        a / 5
    end
</pre>

<h2>Delimiters</h2>

<p>How to separate one construct from another is a really big issue in syntax design, believe it or not.
We can identify two main classes of languages: those in which newlines are significant and those in which
they are not.</p>

<h3>“Insignificant” Newlines</h3>

<p>In many languages, newlines are just like any other whitespace character (except for minor exceptions such as single-line comments and single-line string literals. Then, unless you have an S-Expression-based syntax as in LISP, Scheme, and Clojure, you’ll need semicolons to terminate (or separate) statements. This means you <em>can</em> (but shouldn’t) write code like:

</p><pre>#define ZERO 0
    unsigned  gcd(   unsigned   int  // Euclid&#39;s algorithm
      x,unsigned   y) {   while ( /* hello */  x&gt;   ZERO
   ){unsigned temp=x;x=y   %x;y  = temp ;}return

   y ;}
<img src="https://cs.lmu.edu/~ray/images/c-logo32.png"/></pre>

<h3>“Significant” Newlines</h3>

<p>Where you place your newlines matters greatly in, let’s see, Assembly languages, Python, Ruby, JavaScript, CoffeeScript, Elm, Haskell, Go, Swift, and yes, many others. The rules can get pretty technical.

</p><p><b>Python</b> scripts are defined as sequences of <dfn>logical lines</dfn>, delimited by the token NEWLINE. A statement may not cross logical lines, except in the case of <dfn>compound statements</dfn> in which each constituent <dfn>simple statement</dfn> ends with a NEWLINE. Logical lines are made up of one or more physical lines according to line joining rules. Lines are <em>implicitly</em> jointed within parentheses, brackets, or braces; lines can be <em>explicitly</em> joined by ending with a backslash. These rules are somewhat exclusive of comments and string literals.</p>

<p><b>Ruby</b> looks at the end of each line and says “well if up to here it looks like we’ve completed a statement the we have.”  This means you have to be careful where you break lines:</p>

<pre>puts 5
  + 3
puts 5 +
  3
<img src="https://cs.lmu.edu/~ray/images/ruby-logo32.png"/></pre>

<p>prints 5 then 8.</p>

<p><b>Exercise</b>: Why?
</p>
<h3>“Possibly Significant” Newlines</h3>

<p>JavaScript requires most statements to be terminated by semicolons, but the <em>compiler will put one in for you if it looks like you might have missed one</em>. The rules by which this <dfn>automatic semicolon insertion</dfn> (ASI) is done have to be learned and they might be hard to remember.

</p><blockquote data-lang="en"><p lang="en" dir="ltr">[God creating JavaScript]</p>— Neckbeard Hacker (@NeckbeardHacker) <a href="https://twitter.com/NeckbeardHacker/status/768475375399755776">August 24, 2016</a></blockquote>


<p>If you are going to be a serious JavaScript programmer, you need to learning the rules of ASI <b>whether you choose to use semicolons or not</b>.

</p><p><b>Exercise</b>: Research the famous <a href="http://www.ecma-international.org/ecma-262/9.0/index.html#sec-rules-of-automatic-semicolon-insertion">Rules of Automatic Semicolon Insertion</a>. Which statements are supposed to be terminated by a semicolon? When is a semicolon inserted? Give four examples of how writing JavaScript in a &#34;free-form&#34; manner is impossible because of semicolon insertion.
</p>

<p>Some people feel very strongly whether to use or not to use semicolons:</p>

<p><img src="https://cs.lmu.edu/~ray/images/zzzzing.png%20" alt="zzzzing.png"/></p>
<h2>Function Calls</h2>

<p>Questions to ask when invoking functions: Exactly one argument, or zero or more arguments? Parens or no parens? Positional or keyword arguments? If no arguments, can we omit parens then? Arguments first or last?</p>

<p>Let&#39;s play around and see what we come up with:</p>

<pre>    push(myStack, 55)
    push myStack 55
    puts(on: myStack, theValue: 55)
    push(theValue: 55, on: myStack)
    push on:myStack theValue:55
    [push myStack 55]
    (push myStack 55)
    push({on: myStack, theValue: 55})
    push {on: myStack, theValue: 55}

    sum (filter even (map square a))
    sum $ filter even $ map square $ a
    sum &lt;| filter even &lt;| map square &lt;| a
    a |&gt; filter even |&gt; map square |&gt; sum
</pre>

<h2>Syntactic Sugar</h2>

<p><dfn>Syntactic sugar</dfn> refers to forms in a language that make certain things easier to express, but
can be considered surface translations of more basic forms.</p>

<p>This is best understood by example. There are zillions of examples out there. Here are a few.
(<b>Disclaimer</b>: Some of these are just examples I made up and are not part of any real language.)

</p><table>
<tbody><tr><th>Construct</th><th>Desugared Form</th><th>Description
</th></tr><tr><td><code>x += n</code></td><td><code>x = x + n</code></td><td>Compound assignment

</td></tr><tr><td><code>a + b</code></td><td><code>operator+(a, b)</code> <i>or</i></td><td>Common in languages that allow overloading

</td></tr><tr><td><code>a[i]</code></td><td><code>*(a + i)</code></td><td>(C, C++) Because C does not have real arrays

</td></tr><tr><td><code>p -&gt; x</code></td><td><code>(*p).x</code></td><td>(C, C++) Field of struct being pointed to

</td></tr><tr><td><code>f</code></td><td><code>f()</code></td><td>Some languages let you leave off parentheses in calls with no arguments

</td></tr><tr><td><code>f x</code></td><td><code>f(x)</code> <i>or</i></td><td>Some languages let you leave off parentheses in calls with one argument

</td></tr><tr><td><code>x op y</code></td><td><code>op(x, y)</code> <i>or</i></td><td>Some languages let you leave off parentheses in calls with two arguments

</td></tr><tr><td><code>let x=E1 in E2</code></td><td><code>(x =&gt; E2)(E1)</code></td><td>Let-expression (in functional languages)</td></tr>

<tr><td><code>(E1 ; E2)</code></td><td><code>(() =&gt; E2)(E1)</code></td><td>Expression sequencing (in eager functional languages)</td></tr>

<tr><td><code>r = [s</code></td><td><code>r = []</code></td><td>List comprehension

</td></tr><tr><td><code>x orelse y</code></td><td><code>if x then x else y</code></td><td>(Standard ML) short-circuit disjunction

</td></tr><tr><td><code>x andalso y</code></td><td><code>if x then y else x</code></td><td>(Standard ML) short-circuit conjunction

</td></tr><tr><td><code>[x, y, z]</code></td><td><code>x :: y :: z :: nil</code></td><td>Lists in Standard ML

</td></tr><tr><td><code>&#34;a${x}b&#34;</code></td><td><code>&#34;a&#34; + x + &#34;b&#34;</code></td><td>String interpolation
</td></tr></tbody></table>

<p><b>Exercise</b>: Find some more examples.
</p>
<p>When the sugared form is completely gratuitous or actually makes the code <em>less</em> readable, you
sometimes hear the term <dfn>syntactic syrup</dfn> or <dfn>syntactic saccharin</dfn>.

</p><h2>Syntactic Salt</h2>

<p>Here’s the definition from <a href="http://www.outpost9.com/reference/jargon/jargon_toc.html">The
New Hacker’s Dictionary</a>:</p>

<blockquote>The opposite of syntactic sugar, a feature designed to make it harder to write bad code.
Specifically, syntactic salt is a hoop the programmer must jump through just to prove that he knows what’s going on, rather than to express a program action. Some programmers consider required type declarations to be syntactic salt. A requirement to write “<code>end if</code>”, “<code>end while</code>”, “<code>end do</code>”, etc. to terminate the last block controlled by a control construct (as opposed to just “<code>end</code>”) would definitely be syntactic salt. Syntactic salt is like the real thing in that it tends to raise hackers’ blood pressures in an unhealthy way.</blockquote>

<h2>Compactness and Verbosity</h2>

<p>Some people love a very verbose syntax, where you say everything, because <em>explicit is better than implicit</em>. Some people love very terse syntax, as there is less cognitive load and less noise in the code. Please be reasonable, though. There is such a thing as code that is too terse, and such a thing as code that is too verbose.</p>

<h3>Terseness</h3>

<p>Some languages pride themselves on doing a whole lot with few characters:</p>

<p>An example from Ruby (do you see what this does?):</p>

<pre>c = Hash.new 0
ARGF.each {|l| l.scan(/[A-Z&#39;]+/i).map {|w| c[w.downcase] += 1}}
c.keys.sort.each {|w| puts &#34;#{w}, #{c[w]}&#34;}
<img src="https://cs.lmu.edu/~ray/images/ruby-logo32.png"/></pre>

<p>An example from APL (The 99 bottles of beer program taken from Rosetta Code):</p>

<pre>bob  ←  { (⍕⍵), &#39; bottle&#39;, (1=⍵)↓&#39;s of beer&#39;}
bobw ←  {(bob ⍵) , &#39; on the wall&#39;}
beer ←  { (bobw ⍵) , &#39;, &#39;, (bob ⍵) , &#39;; take one down and pass it around, &#39;, bobw ⍵-1}
↑beer¨ ⌽(1-⎕IO)+⍳99
<img src="https://cs.lmu.edu/~ray/images/apl-logo32.png"/></pre>

<p>Here’s APL again, with an expression to find all the prime numbers up to R:</p>

<pre>(~R∊R∘.×R)/R←1↓⍳R
<img src="https://cs.lmu.edu/~ray/images/apl-logo32.png"/></pre>

<h3>Candygrammars</h3>

<p>Somtimes you will encounter languages that tend to look like a natrual language. What do you think about this?</p>

<p>An example in Hypertalk (taken from Wikipedia):</p>

<pre>on mouseDown
  answer file &#34;Please select a text file to open.&#34;
  if it is empty then exit mouseDown
  put it into filePath
  if there is a file filePath then
    open file filePath
    read from file filePath until return
    put it into cd fld &#34;some field&#34;
    close file filePath
    set the textStyle of character 1 to 10 of card field &#34;some field&#34; to bold
  end if
end mouseDown
</pre>

<p>An example from Manatee:</p>

<pre>to get the truth value prime of whole number n:
    return no if n &lt; 2
    for each d in 3 to n - 1 by 2:
        return no if d divides n
    end
    return yes
end
for each k in 1 to 100:
    write k if prime(k)
end
</pre>

<p>In practice this kind of verbosity is worse than it sounds. Here’s what the New Hacker’s Dictionary
has to say about this:</p>

<blockquote>
<b>candygrammar /n./</b> A programming-language grammar that is mostly syntactic sugar; the term is also a play on “candygram.” COBOL, Apple’s Hypertalk language, and a lot of the so-called “4GL” database languages share this property. The usual intent of such designs is that they be as English-like as possible, on the theory that they will then be easier for unskilled people to program. This intention comes to grief on the reality that syntax isn’t what makes programming hard; it’s the mental effort and organization required to specify an algorithm precisely that costs. Thus the invariable result is that candygrammar languages are just as difficult to program in as terser ones, and far more painful for the experienced hacker.
</blockquote>


      </div>
    </div></div>
  </body>
</html>
