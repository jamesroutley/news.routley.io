<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/tc39/proposal-pipeline-operator">Original</a>
    <h1>Pipe Operator (|&gt;) For JavaScript</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<ul dir="auto">
<li><strong>Stage</strong>: 2</li>
<li><strong>Champions</strong>: J. S. Choi, James DiGioia, Ron Buckton, Tab Atkins-Bittner, [list incomplete] </li>
<li><strong>Former champions</strong>: Daniel Ehrenberg</li>
<li><strong><a href="http://tc39.github.io/proposal-pipeline-operator/" rel="nofollow">Specification</a></strong></li>
<li><strong><a href="https://github.com/tc39/proposal-pipeline-operator/blob/main/CONTRIBUTING.md">Contributing guidelines</a></strong></li>
<li><strong><a href="https://github.com/tc39/proposal-pipeline-operator/blob/main/HISTORY.md">Proposal history</a></strong></li>
<li><strong>Babel plugin</strong>: <a href="https://babeljs.io/blog/2021/07/26/7.15.0#hack-style-pipeline-operator-support-13191httpsgithubcombabelbabelpull13191-13416httpsgithubcombabelbabelpull13416" rel="nofollow">Implemented in v7.15</a>. See <a href="https://babeljs.io/docs/en/babel-plugin-proposal-pipeline-operator" rel="nofollow">Babel documentation</a>.</li>
</ul>
<p dir="auto">(This document uses <code>%</code>
as the placeholder token for the topic reference.
This will <em><strong>almost certainly not be the final choice</strong></em>;
see <a href="https://github.com/tc39/proposal-pipeline-operator/issues/91" data-hovercard-type="issue" data-hovercard-url="/tc39/proposal-pipeline-operator/issues/91/hovercard">the token bikeshedding discussion</a> for details.)</p>
<h2 dir="auto"><a id="user-content-why-a-pipe-operator" aria-hidden="true" href="#why-a-pipe-operator"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Why a pipe operator</h2>
<p dir="auto">In the State of JS 2020 survey, the <strong>fourth top answer</strong> to
<a href="https://2020.stateofjs.com/en-US/opinions/#missing_from_js" rel="nofollow">“What do you feel is currently missing from
JavaScript?”</a>
was a <strong>pipe operator</strong>. Why?</p>
<p dir="auto">When we perform <strong>consecutive operations</strong> (e.g., function calls)
on a <strong>value</strong> in JavaScript,
there are currently two fundamental styles:</p>
<ul dir="auto">
<li>passing the value as an argument to the operation
(<strong>nesting</strong> the operations if there are multiple operations),</li>
<li>or calling the function as a method on the value
(<strong>chaining</strong> more method calls if there are multiple methods).</li>
</ul>
<p dir="auto">That is, <code>three(two(one(value)))</code> versus <code>value.one().two().three()</code>.
However, these styles differ much in readability, fluency, and applicability.</p>
<h3 dir="auto"><a id="user-content-deep-nesting-is-hard-to-read" aria-hidden="true" href="#deep-nesting-is-hard-to-read"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Deep nesting is hard to read</h3>
<p dir="auto">The first style, <strong>nesting</strong>, is generally applicable –
it works for any sequence of operations:
function calls, arithmetic, array/object literals, <code>await</code> and <code>yield</code>, etc.</p>
<p dir="auto">However, nesting is <strong>difficult to read</strong> when it becomes deep:
the flow of execution moves <strong>right to left</strong>,
rather than the left-to-right reading of normal code.
If there are <strong>multiple arguments</strong> at some levels,
reading even bounces <strong>back and forth</strong>:
our eyes must <strong>jump left</strong> to find a function name,
and then they must <strong>jump right</strong> to find additional arguments.
Additionally, <strong>editing</strong> the code afterwards can be fraught:
we must find the correct <strong>place to insert</strong> new arguments
among <strong>many nested parentheses</strong>.</p>
<details>
<summary><strong>Real-world example</strong></summary>
<p dir="auto">Consider this <a href="https://github.com/facebook/react/blob/17.0.2/scripts/jest/jest-cli.js#L295">real-world code from React</a>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="console.log(
  chalk.dim(
    `$ ${Object.keys(envars)
      .map(envar =&gt;
        `${envar}=${envars[envar]}`)
      .join(&#39; &#39;)
    }`,
    &#39;node&#39;,
    args.join(&#39; &#39;)));"><pre><span>console</span><span>.</span><span>log</span><span>(</span>
  <span>chalk</span><span>.</span><span>dim</span><span>(</span>
    <span>`$ <span><span>${</span><span>Object</span><span>.</span><span>keys</span><span>(</span><span>envars</span><span>)</span></span></span>
<span><span>      <span>.</span><span>map</span><span>(</span><span>envar</span> <span>=&gt;</span></span></span>
<span><span>        <span>`<span><span>${</span><span>envar</span><span>}</span></span>=<span><span>${</span><span>envars</span><span>[</span><span>envar</span><span>]</span><span>}</span></span>`</span><span>)</span></span></span>
<span><span>      <span>.</span><span>join</span><span>(</span><span>&#39; &#39;</span><span>)</span></span></span>
<span><span>    <span>}</span></span>`</span><span>,</span>
    <span>&#39;node&#39;</span><span>,</span>
    <span>args</span><span>.</span><span>join</span><span>(</span><span>&#39; &#39;</span><span>)</span><span>)</span><span>)</span><span>;</span></pre></div>
<p dir="auto">This real-world code is made of <strong>deeply nested expressions</strong>.
In order to read its flow of data, a human’s eyes must first:</p>
<ol dir="auto">
<li>
<p dir="auto">Find the <strong>initial data</strong> (the innermost expression, <code>envars</code>).</p>
</li>
<li>
<p dir="auto">And then scan <strong>back and forth</strong> repeatedly from <strong>inside out</strong>
for each data transformation,
each one either an easily missed prefix operator on the left
or a suffix operators on the right:</p>
<ol dir="auto">
<li><code>Object.keys()</code> (left side),</li>
<li><code>.map()</code> (right side),</li>
<li><code>.join()</code> (right side),</li>
<li>A template literal (both sides),</li>
<li><code>chalk.dim()</code> (left side), then</li>
<li><code>console.log()</code> (left side).</li>
</ol>
</li>
</ol>
<p dir="auto">As a result of deeply nesting many expressions
(some of which use <strong>prefix</strong> operators,
some of which use <strong>postfix</strong> operators,
and some of which use <strong>circumfix</strong> operators),
we must check <strong>both left and right sides</strong>
to find the <strong>head</strong> of <strong>each expression</strong>.</p>
</details>
<h3 dir="auto"><a id="user-content-method-chaining-is-limited" aria-hidden="true" href="#method-chaining-is-limited"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Method chaining is limited</h3>
<p dir="auto">The second style, <strong>method chaining</strong>, is <strong>only</strong> usable
if the value has the functions designated as <strong>methods</strong> for its class.
This <strong>limits</strong> its applicability.
But <strong>when</strong> it applies, thanks to its postfix structure,
it is generally more usable and <strong>easier</strong> to read and write.
Code execution flows <strong>left to right</strong>.
Deeply nested expressions are <strong>untangled</strong>.
All arguments for a function call are <strong>grouped</strong> with the function’s name.
And editing the code later to <strong>insert or delete</strong> more method calls is trivial,
since we would just have to put our cursor in one spot,
then start typing or deleting one <strong>contiguous</strong> run of characters.</p>
<p dir="auto">Indeed, the benefits of method chaining are <strong>so attractive</strong>
that some <strong>popular libraries contort</strong> their code structure
specifically to allow <strong>more method chaining</strong>.
The most prominent example is <strong><a href="https://jquery.com/" rel="nofollow">jQuery</a></strong>, which
still remains the <strong>most popular JS library</strong> in the world.
jQuery’s core design is a single über-object with dozens of methods on it,
all of which return the same object type so that we can <strong>continue chaining</strong>.
There is even a name for this style of programming:
<strong><a href="https://en.wikipedia.org/wiki/Fluent_interface" rel="nofollow">fluent interfaces</a></strong>.</p>
<p dir="auto">Unfortunately, for all of its fluency,
<strong>method chaining</strong> alone cannot accomodate JavaScript’s <strong>other syntaxes</strong>:
function calls, arithmetic, array/object literals, <code>await</code> and <code>yield</code>, etc.
In this way, method chaining remains <strong>limited</strong> in its <strong>applicability</strong>.</p>
<h3 dir="auto"><a id="user-content-pipe-operators-combine-both-worlds" aria-hidden="true" href="#pipe-operators-combine-both-worlds"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Pipe operators combine both worlds</h3>
<p dir="auto">The pipe operator attempts to marry the <strong>convenience</strong> and ease of <strong>method chaining</strong>
with the wide <strong>applicability</strong> of <strong>expression nesting</strong>.</p>
<p dir="auto">The general structure of all the pipe operators is
<code>value |&gt;</code> <var>e1</var> <code>|&gt;</code> <var>e2</var> <code>|&gt;</code> <var>e3</var>,
where <var>e1</var>, <var>e2</var>, <var>e3</var>
are all expressions that take consecutive values as their parameters.
The <code>|&gt;</code> operator then does some degree of magic to “pipe” <code>value</code>
from the lefthand side into the righthand side.</p>
<details>
<summary><strong>Real-world example</strong>, continued</summary>
<p dir="auto">Continuing this deeply nested <a href="https://github.com/facebook/react/blob/17.0.2/scripts/jest/jest-cli.js">real-world code from React</a>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="console.log(
  chalk.dim(
    `$ ${Object.keys(envars)
      .map(envar =&gt;
        `${envar}=${envars[envar]}`)
      .join(&#39; &#39;)
    }`,
    &#39;node&#39;,
    args.join(&#39; &#39;)));"><pre><span>console</span><span>.</span><span>log</span><span>(</span>
  <span>chalk</span><span>.</span><span>dim</span><span>(</span>
    <span>`$ <span><span>${</span><span>Object</span><span>.</span><span>keys</span><span>(</span><span>envars</span><span>)</span></span></span>
<span><span>      <span>.</span><span>map</span><span>(</span><span>envar</span> <span>=&gt;</span></span></span>
<span><span>        <span>`<span><span>${</span><span>envar</span><span>}</span></span>=<span><span>${</span><span>envars</span><span>[</span><span>envar</span><span>]</span><span>}</span></span>`</span><span>)</span></span></span>
<span><span>      <span>.</span><span>join</span><span>(</span><span>&#39; &#39;</span><span>)</span></span></span>
<span><span>    <span>}</span></span>`</span><span>,</span>
    <span>&#39;node&#39;</span><span>,</span>
    <span>args</span><span>.</span><span>join</span><span>(</span><span>&#39; &#39;</span><span>)</span><span>)</span><span>)</span><span>;</span></pre></div>
<p dir="auto">…we can <strong>untangle</strong> it as such using a pipe operator
and a placeholder token (<code>%</code>) standing in for the previous operation’s value:</p>
<div dir="auto" data-snippet-clipboard-copy-content="Object.keys(envars)
  .map(envar =&gt; `${envar}=${envars[envar]}`)
  .join(&#39; &#39;)
  |&gt; `$ ${%}`
  |&gt; chalk.dim(%, &#39;node&#39;, args.join(&#39; &#39;))
  |&gt; console.log(%);"><pre><span>Object</span><span>.</span><span>keys</span><span>(</span><span>envars</span><span>)</span>
  <span>.</span><span>map</span><span>(</span><span>envar</span> <span>=&gt;</span> <span>`<span><span>${</span><span>envar</span><span>}</span></span>=<span><span>${</span><span>envars</span><span>[</span><span>envar</span><span>]</span><span>}</span></span>`</span><span>)</span>
  <span>.</span><span>join</span><span>(</span><span>&#39; &#39;</span><span>)</span>
  <span>|</span><span>&gt;</span> `$ ${<span>%</span><span>}</span>`
  <span>|</span><span>&gt;</span> <span>chalk</span><span>.</span><span>dim</span><span>(</span><span>%</span><span>,</span> <span>&#39;node&#39;</span><span>,</span> <span>args</span><span>.</span><span>join</span><span>(</span><span>&#39; &#39;</span><span>)</span><span>)</span>
  <span>|</span><span>&gt;</span> <span>console</span><span>.</span><span>log</span><span>(</span><span>%</span><span>)</span><span>;</span></pre></div>
<p dir="auto">Now, the human reader can <strong>rapidly find</strong> the <strong>initial data</strong>
(what had been the most innermost expression, <code>envars</code>),
then <strong>linearly</strong> read, from <strong>left to right</strong>,
each transformation on the data.</p>
</details>
<h3 dir="auto"><a id="user-content-temporary-variables-are-often-tedious" aria-hidden="true" href="#temporary-variables-are-often-tedious"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Temporary variables are often tedious</h3>
<p dir="auto">One could argue that using <strong>temporary variables</strong>
should be the only way to untangle deeply nested code.
Explicitly naming every step’s variable
causes something similar to method chaining to happen,
with similar benefits to reading and writing code.</p>
<details>
<summary><strong>Real-world example</strong>, continued</summary>
<p dir="auto">For example, using our previous modified
<a href="https://github.com/facebook/react/blob/17.0.2/scripts/jest/jest-cli.js">real-world example from React</a>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="Object.keys(envars)
  .map(envar =&gt; `${envar}=${envars[envar]}`)
  .join(&#39; &#39;)
  |&gt; `$ ${%}`
  |&gt; chalk.dim(%, &#39;node&#39;, args.join(&#39; &#39;))
  |&gt; console.log(%);"><pre><span>Object</span><span>.</span><span>keys</span><span>(</span><span>envars</span><span>)</span>
  <span>.</span><span>map</span><span>(</span><span>envar</span> <span>=&gt;</span> <span>`<span><span>${</span><span>envar</span><span>}</span></span>=<span><span>${</span><span>envars</span><span>[</span><span>envar</span><span>]</span><span>}</span></span>`</span><span>)</span>
  <span>.</span><span>join</span><span>(</span><span>&#39; &#39;</span><span>)</span>
  <span>|</span><span>&gt;</span> `$ ${<span>%</span><span>}</span>`
  <span>|</span><span>&gt;</span> <span>chalk</span><span>.</span><span>dim</span><span>(</span><span>%</span><span>,</span> <span>&#39;node&#39;</span><span>,</span> <span>args</span><span>.</span><span>join</span><span>(</span><span>&#39; &#39;</span><span>)</span><span>)</span>
  <span>|</span><span>&gt;</span> <span>console</span><span>.</span><span>log</span><span>(</span><span>%</span><span>)</span><span>;</span></pre></div>
<p dir="auto">…a version using temporary variables would look like this:</p>
<div dir="auto" data-snippet-clipboard-copy-content="const envarString = Object.keys(envars)
  .map(envar =&gt; `${envar}=${envars[envar]}`)
  .join(&#39; &#39;);
const consoleText = `$ ${envarString}`;
const coloredConsoleText = chalk.dim(consoleText, &#39;node&#39;, args.join(&#39; &#39;));
console.log(coloredConsoleText);"><pre><span>const</span> <span>envarString</span> <span>=</span> <span>Object</span><span>.</span><span>keys</span><span>(</span><span>envars</span><span>)</span>
  <span>.</span><span>map</span><span>(</span><span>envar</span> <span>=&gt;</span> <span>`<span><span>${</span><span>envar</span><span>}</span></span>=<span><span>${</span><span>envars</span><span>[</span><span>envar</span><span>]</span><span>}</span></span>`</span><span>)</span>
  <span>.</span><span>join</span><span>(</span><span>&#39; &#39;</span><span>)</span><span>;</span>
<span>const</span> <span>consoleText</span> <span>=</span> <span>`$ <span><span>${</span><span>envarString</span><span>}</span></span>`</span><span>;</span>
<span>const</span> <span>coloredConsoleText</span> <span>=</span> <span>chalk</span><span>.</span><span>dim</span><span>(</span><span>consoleText</span><span>,</span> <span>&#39;node&#39;</span><span>,</span> <span>args</span><span>.</span><span>join</span><span>(</span><span>&#39; &#39;</span><span>)</span><span>)</span><span>;</span>
<span>console</span><span>.</span><span>log</span><span>(</span><span>coloredConsoleText</span><span>)</span><span>;</span></pre></div>
</details>
<p dir="auto">But there are reasons why we encounter deeply nested expressions
in each other’s code <strong>all the time in the real world</strong>,
<strong>rather than</strong> lines of temporary variables.
And there are reasons why the <strong>method-chain-based <a href="https://en.wikipedia.org/wiki/Fluent_interface" rel="nofollow">fluent interfaces</a></strong>
of jQuery, Mocha, and so on are still <strong>popular</strong>.</p>
<p dir="auto">It is often simply too <strong>tedious and wordy</strong> to <strong>write</strong>
code with a long sequence of temporary, single-use variables.
It is arguably even tedious and visually noisy for a human to <strong>read</strong>, too.</p>
<p dir="auto">If <a href="https://martinfowler.com/bliki/TwoHardThings.html" rel="nofollow"><strong>naming</strong> is one of the <strong>most difficult tasks</strong> in programming</a>,
then programmers will <strong>inevitably avoid naming</strong> variables
when they perceive their benefit to be relatively small.</p>
<h3 dir="auto"><a id="user-content-reusing-temporary-variables-is-prone-to-unexpected-mutation" aria-hidden="true" href="#reusing-temporary-variables-is-prone-to-unexpected-mutation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Reusing temporary variables is prone to unexpected mutation</h3>
<p dir="auto">One could argue that using a single <strong>mutable variable</strong> with a short name
would reduce the wordiness of temporary variables, achieving
similar results as with the pipe operator.</p>
<details>
<summary><strong>Real-world example</strong>, continued</summary>
<p dir="auto">For example, our previous modified
<a href="https://github.com/facebook/react/blob/17.0.2/scripts/jest/jest-cli.js">real-world example from React</a>
could be re-written like this:</p>
<div dir="auto" data-snippet-clipboard-copy-content="let _;
_ = Object.keys(envars)
  .map(envar =&gt; `${envar}=${envars[envar]}`)
  .join(&#39; &#39;);
_ = `$ ${_}`;
_ = chalk.dim(_, &#39;node&#39;, args.join(&#39; &#39;));
_ = console.log(_);"><pre><span>let</span> <span>_</span><span>;</span>
<span>_</span> <span>=</span> <span>Object</span><span>.</span><span>keys</span><span>(</span><span>envars</span><span>)</span>
  <span>.</span><span>map</span><span>(</span><span>envar</span> <span>=&gt;</span> <span>`<span><span>${</span><span>envar</span><span>}</span></span>=<span><span>${</span><span>envars</span><span>[</span><span>envar</span><span>]</span><span>}</span></span>`</span><span>)</span>
  <span>.</span><span>join</span><span>(</span><span>&#39; &#39;</span><span>)</span><span>;</span>
<span>_</span> <span>=</span> <span>`$ <span><span>${</span><span>_</span><span>}</span></span>`</span><span>;</span>
<span>_</span> <span>=</span> <span>chalk</span><span>.</span><span>dim</span><span>(</span><span>_</span><span>,</span> <span>&#39;node&#39;</span><span>,</span> <span>args</span><span>.</span><span>join</span><span>(</span><span>&#39; &#39;</span><span>)</span><span>)</span><span>;</span>
<span>_</span> <span>=</span> <span>console</span><span>.</span><span>log</span><span>(</span><span>_</span><span>)</span><span>;</span></pre></div>
</details>
<p dir="auto">But code like this is <strong>not common</strong> in real-world code.
One reason for this is that mutable variables can <strong>change unexpectedly</strong>,
causing silent bugs that are hard to find.
For example, the variable might be accidentally referenced in a closure.
Or it might be mistakenly reassigned within an expression.</p>
<details>
<summary>Example code</summary>
<div dir="auto" data-snippet-clipboard-copy-content="// setup
function one () { return 1; }
function double (x) { return x * 2; }

let _;
_ = one(); // _ is now 1.
_ = double(_); // _ is now 2.
_ = Promise.resolve().then(() =&gt;
  // This does *not* print 2!
  // It prints 1, because `_` is reassigned downstream.
  console.log(_));

// _ becomes 1 before the promise callback.
_ = one(_);"><pre><span>// setup</span>
<span>function</span> <span>one</span> <span>(</span><span>)</span> <span>{</span> <span>return</span> <span>1</span><span>;</span> <span>}</span>
<span>function</span> <span>double</span> <span>(</span><span>x</span><span>)</span> <span>{</span> <span>return</span> <span>x</span> <span>*</span> <span>2</span><span>;</span> <span>}</span>

<span>let</span> <span>_</span><span>;</span>
<span>_</span> <span>=</span> <span>one</span><span>(</span><span>)</span><span>;</span> <span>// _ is now 1.</span>
<span>_</span> <span>=</span> <span>double</span><span>(</span><span>_</span><span>)</span><span>;</span> <span>// _ is now 2.</span>
<span>_</span> <span>=</span> <span>Promise</span><span>.</span><span>resolve</span><span>(</span><span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span>
  <span>// This does *not* print 2!</span>
  <span>// It prints 1, because `_` is reassigned downstream.</span>
  <span>console</span><span>.</span><span>log</span><span>(</span><span>_</span><span>)</span><span>)</span><span>;</span>

<span>// _ becomes 1 before the promise callback.</span>
<span>_</span> <span>=</span> <span>one</span><span>(</span><span>_</span><span>)</span><span>;</span></pre></div>
<p dir="auto">This issue would not happen with the pipe operator.
The topic token cannot be reassigned, and
code outside of each step cannot change its binding.</p>
<div dir="auto" data-snippet-clipboard-copy-content="let _;
_ = one()
  |&gt; double(%)
  |&gt; Promise.resolve().then(() =&gt;
    // This prints 2, as intended.
    console.log(%));

_ = one();"><pre><span>let</span> <span>_</span><span>;</span>
<span>_</span> <span>=</span> <span>one</span><span>(</span><span>)</span>
  <span>|</span><span>&gt;</span> <span>double</span><span>(</span><span>%</span><span>)</span>
  <span>|</span><span>&gt;</span> <span>Promise</span><span>.</span><span>resolve</span><span>(</span><span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span>
    <span>// This prints 2, as intended.</span>
    <span>console</span><span>.</span><span>log</span><span>(</span><span>%</span><span>)</span><span>)</span><span>;</span>

<span>_</span> <span>=</span> <span>one</span><span>(</span><span>)</span><span>;</span></pre></div>
</details>
<p dir="auto">For this reason, code with mutable variables is also harder to read.
To determine what the variable represents at any given point,
you must to <strong>search the entire preceding scope</strong> for places where it is <strong>reassigned</strong>.</p>
<p dir="auto">The topic reference of a pipeline, on the other hand, has a limited lexical scope,
and its binding is immutable within its scope.
It cannot be accidentally reassigned, and it can be safely used in closures.</p>
<p dir="auto">Although the topic value also changes with each pipeline step,
we only scan the previous step of the pipeline to make sense of it,
leading to code that is easier to read.</p>
<h3 dir="auto"><a id="user-content-temporary-variables-must-be-declared-in-statements" aria-hidden="true" href="#temporary-variables-must-be-declared-in-statements"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Temporary variables must be declared in statements</h3>
<p dir="auto">Another benefit of the pipe operator over sequences of assignment statements
(whether with mutable or with immutable temporary variables)
is that they are <strong>expressions</strong>.</p>
<p dir="auto">Pipe expressions are expressions that can be directly returned,
assigned to a variable, or used in contexts such as JSX expressions.</p>
<p dir="auto">Using temporary variables, on the other hand, requires sequences of statements.</p>
<details>
<summary>Examples</summary>
<table>
<thead>
<tr><th>Pipelines</th>
<th>Temporary Variables</th>
</tr></thead>
<tbody>
<tr>
<td>
<div dir="auto" data-snippet-clipboard-copy-content="const envVarFormat = vars =&gt;
  Object.keys(vars)
    .map(var =&gt; `${var}=${vars[var]}`)
    .join(&#39; &#39;)
    |&gt; chalk.dim(%, &#39;node&#39;, args.join(&#39; &#39;));"><pre><span>const</span> <span>envVarFormat</span> <span>=</span> <span>vars</span> <span>=&gt;</span>
  <span>Object</span><span>.</span><span>keys</span><span>(</span><span>vars</span><span>)</span>
    <span>.</span><span>map</span><span>(</span><span>var</span> <span>=&gt;</span> <span>`<span><span>${</span><span>var</span><span>}</span></span>=<span><span>${</span><span>vars</span><span>[</span><span>var</span><span>]</span><span>}</span></span>`</span><span>)</span>
    <span>.</span><span>join</span><span>(</span><span>&#39; &#39;</span><span>)</span>
    <span>|</span><span>&gt;</span> <span>chalk</span><span>.</span><span>dim</span><span>(</span><span>%</span><span>,</span> <span>&#39;node&#39;</span><span>,</span> <span>args</span><span>.</span><span>join</span><span>(</span><span>&#39; &#39;</span><span>)</span><span>)</span><span>;</span></pre></div>
</td>
<td>
<div dir="auto" data-snippet-clipboard-copy-content="const envVarFormat = (vars) =&gt; {
  let _ = Object.keys(vars);
    .map(var =&gt; `${var}=${vars[var]}`);
    .join(&#39; &#39;);
  return chalk.dim(_, &#39;node&#39;, args.join(&#39; &#39;));
}"><pre><span>const</span> <span>envVarFormat</span> <span>=</span> <span>(</span><span>vars</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>let</span> <span>_</span> <span>=</span> <span>Object</span><span>.</span><span>keys</span><span>(</span><span>vars</span><span>)</span><span>;</span>
    <span>.</span><span>map</span><span>(</span><span>var</span> <span>=&gt;</span> <span>`<span><span>${</span><span>var</span><span>}</span></span>=<span><span>${</span><span>vars</span><span>[</span><span>var</span><span>]</span><span>}</span></span>`</span><span>)</span><span>;</span>
    <span>.</span><span>join</span><span>(</span><span>&#39; &#39;</span><span>)</span><span>;</span>
  <span>return</span> <span>chalk</span><span>.</span><span>dim</span><span>(</span><span>_</span><span>,</span> <span>&#39;node&#39;</span><span>,</span> <span>args</span><span>.</span><span>join</span><span>(</span><span>&#39; &#39;</span><span>)</span><span>)</span><span>;</span>
<span>}</span></pre></div>
</td>
</tr>
<tr>
<td>
<div dir="auto" data-snippet-clipboard-copy-content="// This example uses JSX.
return (
  &lt;ul&gt;
    {
      values
        |&gt; Object.keys(%)
        |&gt; [...Array.from(new Set(%))]
        |&gt; %.map(envar =&gt; (
          &lt;li onClick={
            () =&gt; doStuff(values)
          }&gt;{envar}&lt;/li&gt;
        ))
    }
  &lt;/ul&gt;
);"><pre><span>// This example uses JSX.</span>
<span>return</span> <span>(</span>
  <span>&lt;</span><span>ul</span><span>&gt;</span>
    <span>{</span>
      <span>values</span>
        <span>|</span><span>&gt;</span> <span>Object</span><span>.</span><span>keys</span><span>(</span><span>%</span><span>)</span>
        <span>|</span><span>&gt;</span> <span>[</span>...<span>Array</span><span>.</span><span>from</span><span>(</span><span>new</span> <span>Set</span><span>(</span><span>%</span><span>)</span><span>)</span><span>]</span>
        <span>|</span><span>&gt;</span> <span>%</span><span>.</span><span>map</span><span>(</span><span>envar</span> <span>=&gt;</span> <span>(</span>
          <span>&lt;</span><span>li</span> <span>onClick</span><span>=</span><span>{</span>
            <span>(</span><span>)</span> <span>=&gt;</span> <span>doStuff</span><span>(</span><span>values</span><span>)</span>
          <span>}</span><span>&gt;</span><span>{</span><span>envar</span><span>}</span><span>&lt;</span><span>/</span><span>li</span><span>&gt;</span>
        <span>)</span><span>)</span>
    <span>}</span>
  <span>&lt;</span><span>/</span><span>ul</span><span>&gt;</span>
<span>)</span><span>;</span></pre></div>
</td>
<td>
<div dir="auto" data-snippet-clipboard-copy-content="// This example uses JSX.
let _ = values;
_= Object.keys(_);
_= [...Array.from(new Set(_))];
_= _.map(envar =&gt; (
  &lt;li onClick={
    () =&gt; doStuff(values)
  }&gt;{envar}&lt;/li&gt;
));
return (
  &lt;ul&gt;{_}&lt;/ul&gt;
);"><pre><span>// This example uses JSX.</span>
<span>let</span> <span>_</span> <span>=</span> <span>values</span><span>;</span>
<span>_</span><span>=</span> <span>Object</span><span>.</span><span>keys</span><span>(</span><span>_</span><span>)</span><span>;</span>
<span>_</span><span>=</span> <span>[</span>...<span>Array</span><span>.</span><span>from</span><span>(</span><span>new</span> <span>Set</span><span>(</span><span>_</span><span>)</span><span>)</span><span>]</span><span>;</span>
<span>_</span><span>=</span> <span>_</span><span>.</span><span>map</span><span>(</span><span>envar</span> <span>=&gt;</span> <span>(</span>
  <span>&lt;</span><span>li</span> <span>onClick</span><span>=</span><span>{</span>
    <span>(</span><span>)</span> <span>=&gt;</span> <span>doStuff</span><span>(</span><span>values</span><span>)</span>
  <span>}</span><span>&gt;</span><span>{</span><span>envar</span><span>}</span><span>&lt;</span><span>/</span><span>li</span><span>&gt;</span>
<span>)</span><span>)</span><span>;</span>
<span>return</span> <span>(</span>
  <span>&lt;</span><span>ul</span><span>&gt;</span><span>{</span><span>_</span><span>}</span><span>&lt;</span><span>/</span><span>ul</span><span>&gt;</span>
<span>)</span><span>;</span></pre></div>
</td>
</tr>
</tbody>
</table>
</details>
<h2 dir="auto"><a id="user-content-why-the-hack-pipe-operator" aria-hidden="true" href="#why-the-hack-pipe-operator"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Why the Hack pipe operator</h2>
<p dir="auto">There were <strong>two competing proposals</strong> for the pipe operator: Hack pipes and F# pipes.
(Before that, there <strong>was</strong> a <a href="https://github.com/js-choi/proposal-smart-pipelines/">third proposal for a “smart mix” of the first two proposals</a>,
but it has been withdrawn,
since its syntax is strictly a superset of one of the proposals’.)</p>
<p dir="auto">The two pipe proposals just differ <strong>slightly</strong> on what the “magic” is,
when we spell our code when using <code>|&gt;</code>.</p>
<p dir="auto"><strong>Both</strong> proposals <strong>reuse</strong> existing language concepts:
Hack pipes are based on the concept of the <strong>expression</strong>,
while F# pipes are based on the concept of the <strong>unary function</strong>.</p>
<p dir="auto">Piping <strong>expressions</strong> and piping <strong>unary functions</strong>
correspondingly have <strong>small</strong> and nearly <strong>symmetrical trade-offs</strong>.</p>
<h3 dir="auto"><a id="user-content-this-proposal-hack-pipes" aria-hidden="true" href="#this-proposal-hack-pipes"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>This proposal: Hack pipes</h3>
<p dir="auto">In the <strong>Hack language</strong>’s pipe syntax,
the righthand side of the pipe is an <strong>expression</strong> containing a special <strong>placeholder</strong>,
which is evaluated with the placeholder bound to the result of evaluating the lefthand side&#39;s expression.
That is, we write <code>value |&gt; one(%) |&gt; two(%) |&gt; three(%)</code>
to pipe <code>value</code> through the three functions.</p>
<p dir="auto"><strong>Pro:</strong> The righthand side can be <strong>any expression</strong>,
and the placeholder can go anywhere any normal variable identifier could go,
so we can pipe to any code we want <strong>without any special rules</strong>:</p>
<ul dir="auto">
<li><code>value |&gt; foo(%)</code> for unary function calls,</li>
<li><code>value |&gt; foo(1, %)</code> for n-ary function calls,</li>
<li><code>value |&gt; %.foo()</code> for method calls,</li>
<li><code>value |&gt; % + 1</code> for arithmetic,</li>
<li><code>value |&gt; [%, 0]</code> for array literals,</li>
<li><code>value |&gt; {foo: %}</code> for object literals,</li>
<li><code>value |&gt; `${%}`</code> for template literals,</li>
<li><code>value |&gt; new Foo(%)</code> for constructing objects,</li>
<li><code>value |&gt; await %</code> for awaiting promises,</li>
<li><code>value |&gt; (yield %)</code> for yielding generator values,</li>
<li><code>value |&gt; import(%)</code> for calling function-like keywords,</li>
<li>etc.</li>
</ul>
<p dir="auto"><strong>Con:</strong> Piping through <strong>unary functions</strong>
is <strong>slightly more verbose</strong> with Hack pipes than with F# pipes.
This includes unary functions
that were created by <strong><a href="https://en.wikipedia.org/wiki/Currying" rel="nofollow">function-currying</a> libraries</strong> like <a href="https://ramdajs.com/" rel="nofollow">Ramda</a>,
as well as <a href="https://github.com/js-choi/proposal-hack-pipes/issues/4#issuecomment-817208635" data-hovercard-type="issue" data-hovercard-url="/tc39/proposal-hack-pipes/issues/4/hovercard">unary arrow functions
that perform <strong>complex destructuring</strong> on their arguments</a>:
Hack pipes would be slightly more verbose
with an <strong>explicit</strong> function call suffix <code>(%)</code>.</p>
<p dir="auto">(Complex destructuring of the topic value
will be easier when <a href="https://github.com/tc39/proposal-do-expressions/">do expressions</a> progress,
as you will then be able to do variable assignment/destructuring
inside of a pipe body.)</p>
<h3 dir="auto"><a id="user-content-alternative-proposal-f-pipes" aria-hidden="true" href="#alternative-proposal-f-pipes"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Alternative proposal: F# pipes</h3>
<p dir="auto">In the <a href="https://github.com/valtech-nyc/proposal-fsharp-pipelines"><strong>F# language</strong>’s pipe syntax</a>,
the righthand side of the pipe is an expression
that must <strong>evaluate into a unary function</strong>,
which is then <strong>tacitly called</strong>
with the lefthand side’s value as its <strong>sole argument</strong>.
That is, we write <code>value |&gt; one |&gt; two |&gt; three</code> to pipe <code>value</code>
through the three functions.
<code>left |&gt; right</code> becomes <code>right(left)</code>.
This is called <a href="https://en.wikipedia.org/wiki/Tacit_programming" rel="nofollow">tacit programming or point-free style</a>.</p>
<details>
<summary><strong>Real-world example</strong>, continued</summary>
<p dir="auto">For example, using our previous modified
<a href="https://github.com/facebook/react/blob/17.0.2/scripts/jest/jest-cli.js">real-world example from React</a>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="Object.keys(envars)
  .map(envar =&gt; `${envar}=${envars[envar]}`)
  .join(&#39; &#39;)
  |&gt; `$ ${%}`
  |&gt; chalk.dim(%, &#39;node&#39;, args.join(&#39; &#39;))
  |&gt; console.log(%);"><pre><span>Object</span><span>.</span><span>keys</span><span>(</span><span>envars</span><span>)</span>
  <span>.</span><span>map</span><span>(</span><span>envar</span> <span>=&gt;</span> <span>`<span><span>${</span><span>envar</span><span>}</span></span>=<span><span>${</span><span>envars</span><span>[</span><span>envar</span><span>]</span><span>}</span></span>`</span><span>)</span>
  <span>.</span><span>join</span><span>(</span><span>&#39; &#39;</span><span>)</span>
  <span>|</span><span>&gt;</span> `$ ${<span>%</span><span>}</span>`
  <span>|</span><span>&gt;</span> <span>chalk</span><span>.</span><span>dim</span><span>(</span><span>%</span><span>,</span> <span>&#39;node&#39;</span><span>,</span> <span>args</span><span>.</span><span>join</span><span>(</span><span>&#39; &#39;</span><span>)</span><span>)</span>
  <span>|</span><span>&gt;</span> <span>console</span><span>.</span><span>log</span><span>(</span><span>%</span><span>)</span><span>;</span></pre></div>
<p dir="auto">…a version using F# pipes instead of Hack pipes would look like this:</p>
<div dir="auto" data-snippet-clipboard-copy-content="Object.keys(envars)
  .map(envar =&gt; `${envar}=${envars[envar]}`)
  .join(&#39; &#39;)
  |&gt; x=&gt; `$ ${x}`
  |&gt; x=&gt; chalk.dim(x, &#39;node&#39;, args.join(&#39; &#39;))
  |&gt; console.log;"><pre><span>Object</span><span>.</span><span>keys</span><span>(</span><span>envars</span><span>)</span>
  <span>.</span><span>map</span><span>(</span><span>envar</span> <span>=&gt;</span> <span>`<span><span>${</span><span>envar</span><span>}</span></span>=<span><span>${</span><span>envars</span><span>[</span><span>envar</span><span>]</span><span>}</span></span>`</span><span>)</span>
  <span>.</span><span>join</span><span>(</span><span>&#39; &#39;</span><span>)</span>
  <span>|</span><span>&gt;</span> <span>x</span><span>=&gt;</span> <span>`$ <span><span>${</span><span>x</span><span>}</span></span>`</span>
  <span>|</span><span>&gt;</span> <span>x</span><span>=&gt;</span> <span>chalk</span><span>.</span><span>dim</span><span>(</span><span>x</span><span>,</span> <span>&#39;node&#39;</span><span>,</span> <span>args</span><span>.</span><span>join</span><span>(</span><span>&#39; &#39;</span><span>)</span><span>)</span>
  <span>|</span><span>&gt;</span> <span>console</span><span>.</span><span>log</span><span>;</span></pre></div>
</details>
<p dir="auto"><strong>Pro:</strong> The restriction that the righthand side
<strong>must</strong> resolve to a unary function
lets us write very terse pipes
<strong>when</strong> the operation we want to perform
is a <strong>unary function call</strong>:</p>
<ul dir="auto">
<li><code>value |&gt; foo</code> for unary function calls.</li>
</ul>
<p dir="auto">This includes unary functions
that were created by <strong><a href="https://en.wikipedia.org/wiki/Currying" rel="nofollow">function-currying</a> libraries</strong> like <a href="https://ramdajs.com/" rel="nofollow">Ramda</a>,
as well as <a href="https://github.com/js-choi/proposal-hack-pipes/issues/4#issuecomment-817208635" data-hovercard-type="issue" data-hovercard-url="/tc39/proposal-hack-pipes/issues/4/hovercard">unary arrow functions
that perform <strong>complex destructuring</strong> on their arguments</a>:
F# pipes would be <strong>slightly less verbose</strong>
with an <strong>implicit</strong> function call (no <code>(%)</code>).</p>
<p dir="auto"><strong>Con:</strong> The restriction means that <strong>any operations</strong>
that are performed by <strong>other syntax</strong>
must be made <strong>slightly more verbose</strong> by <strong>wrapping</strong> the operation
in a unary <strong>arrow function</strong>:</p>
<ul dir="auto">
<li><code>value |&gt; x=&gt; x.foo()</code> for method calls,</li>
<li><code>value |&gt; x=&gt; x + 1</code> for arithmetic,</li>
<li><code>value |&gt; x=&gt; [x, 0]</code> for array literals,</li>
<li><code>value |&gt; x=&gt; ({foo: x})</code> for object literals,</li>
<li><code>value |&gt; x=&gt; `${x}`</code> for template literals,</li>
<li><code>value |&gt; x=&gt; new Foo(x)</code> for constructing objects,</li>
<li><code>value |&gt; x=&gt; import(x)</code> for calling function-like keywords,</li>
<li>etc.</li>
</ul>
<p dir="auto">Even calling <strong>named functions</strong> requires <strong>wrapping</strong>
when we need to pass <strong>more than one argument</strong>:</p>
<ul dir="auto">
<li><code>value |&gt; x=&gt; foo(1, x)</code> for n-ary function calls.</li>
</ul>
<p dir="auto"><strong>Con:</strong> The <strong><code>await</code> and <code>yield</code></strong> operations are <strong>scoped</strong>
to their <strong>containing function</strong>,
and thus <strong>cannot be handled by unary functions</strong> alone.
If we want to integrate them into a pipe expression,
<a href="https://github.com/valtech-nyc/proposal-fsharp-pipelines/"><code>await</code> and <code>yield</code> must be handled as <strong>special syntax cases</strong></a>:</p>
<ul dir="auto">
<li><code>value |&gt; await</code> for awaiting promises, and</li>
<li><code>value |&gt; yield</code> for yielding generator values.</li>
</ul>
<h3 dir="auto"><a id="user-content-hack-pipes-favor-more-common-expressions" aria-hidden="true" href="#hack-pipes-favor-more-common-expressions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Hack pipes favor more common expressions</h3>
<p dir="auto"><strong>Both</strong> Hack pipes and F# pipes respectively impose
a small <strong>syntax tax</strong> on different expressions:</p>
<p dir="auto">In <strong>both</strong> proposals, the syntax tax per taxed expression is <strong>small</strong>
(<strong>both</strong> <code>(%)</code> and <code>x=&gt;</code> are <strong>only three characters</strong>).
However, the tax is <strong>multiplied</strong> by the <strong>prevalence</strong>
of its respectively taxed expressions.
It therefore might make sense
to impose a tax on whichever expressions are <strong>less common</strong>
and to <strong>optimize</strong> in favor of whichever expressions are <strong>more common</strong>.</p>
<p dir="auto">Unary function calls are in general <strong>less common</strong>
than <strong>all</strong> expressions <strong>except</strong> unary functions.
In particular, <strong>method</strong> calling and <strong>n-ary function</strong> calling
will <strong>always</strong> be <strong>popular</strong>;
in general frequency,
<strong>unary</strong> function calling is equal to or exceeded by
those two cases <strong>alone</strong> –
let alone by other ubiquitous syntaxes
such as <strong>array literals</strong>, <strong>object literals</strong>,
and <strong>arithmetic operations</strong>.
This explainer contains several <a href="#real-world-examples">real-world examples</a>
of this difference in prevalence.</p>
<p dir="auto">Furthermore, several other proposed <strong>new syntaxes</strong>,
such as <strong><a href="https://github.com/tc39/proposal-extensions/">extension calling</a></strong>,
<strong><a href="https://github.com/tc39/proposal-do-expressions/">do expressions</a></strong>,
and <strong><a href="https://github.com/tc39/proposal-record-tuple/">record/tuple literals</a></strong>,
will also likely become <strong>pervasive</strong> in the <strong>future</strong>.
Likewise, <strong>arithmetic</strong> operations would also become <strong>even more common</strong>
if TC39 standardizes <strong><a href="https://github.com/tc39/proposal-operator-overloading/">operator overloading</a></strong>.
Untangling these future syntaxes’ expressions would be more fluent
with Hack pipes compared to F# pipes.</p>
<h3 dir="auto"><a id="user-content-hack-pipes-might-be-simpler-to-use" aria-hidden="true" href="#hack-pipes-might-be-simpler-to-use"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Hack pipes might be simpler to use</h3>
<p dir="auto">The syntax tax of Hack pipes on unary function calls
(i.e., the <code>(%)</code> to invoke the righthand side’s unary function)
is <strong>not a special case</strong>:
it simply is <strong>explicitly writing ordinary code</strong>,
in <strong>the way we normally would</strong> without a pipe.</p>
<p dir="auto">On the other hand, <strong>F# pipes require</strong> us to <strong>distinguish</strong>
between “code that resolves to an unary function”
versus <strong>“any other expression”</strong> –
and to remember to add the arrow-function wrapper around the latter case.</p>
<p dir="auto">For example, with Hack pipes, <code>value |&gt; someFunction + 1</code>
is <strong>invalid syntax</strong> and will <strong>fail early</strong>.
There is no need to recognize that <code>someFunction + 1</code>
will not evaluate into a unary function.
But with F# pipes, <code>value |&gt; someFunction + 1</code> is <strong>still valid syntax</strong> –
it’ll just <strong>fail late</strong> at <strong>runtime</strong>,
because <code>someFunction + 1</code> isn’t callable.</p>
<h3 dir="auto"><a id="user-content-tc39-has-rejected-f-pipes-multiple-times" aria-hidden="true" href="#tc39-has-rejected-f-pipes-multiple-times"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>TC39 has rejected F# pipes multiple times</h3>
<p dir="auto">The pipe champion group has presented F# pipes for Stage 2 to TC39 <strong>twice</strong>.
It was <strong>unsuccessful</strong> in advancing to Stage 2 both times.
Both F# pipes (and <a href="https://github.com/tc39/proposal-partial-application">partial function application (PFA)</a>)
have run into strong pushback from multiple other TC39 representatives
due to various concerns. These have included:</p>
<ul dir="auto">
<li>Memory performance concerns (e.g., <a href="https://github.com/tc39/proposal-pipeline-operator/blob/main/HISTORY.md#2021-07">especially from browser-engine implementors</a>),</li>
<li>Syntax concerns about <code>await</code>.</li>
<li>Concerns about encouraging ecosystem bifurcation/forking, etc.</li>
</ul>
<p dir="auto">This pushback has occurred from <strong>outside</strong> the pipe champion group.
See <a href="https://github.com/tc39/proposal-pipeline-operator/blob/main/HISTORY.md">HISTORY.md</a> for more information.</p>
<p dir="auto">It is the pipe champion group’s belief that any pipe operator is better than none,
in order to <a href="#why-a-pipe-operator">easily linearize deeply nested expressions</a>
without resorting to named variables.
Many members of the champion group believe that Hack pipes are slightly better than F# pipes,
and some members of the champion group believe that F# pipes are slightly better than Hack pipes.
But everyone in the champion group agrees that F# pipes have met with far too much resistance
to be able to pass TC39 in the foreseeable future.</p>
<p dir="auto">To emphasize, it is likely that an attempt to switch from Hack pipes back to F# pipes
will result in TC39 never agreeing to any pipes at all.
<a href="https://github.com/tc39/proposal-partial-application">PFA syntax</a> is similarly facing an uphill battle in TC39 (see <a href="https://github.com/tc39/proposal-pipeline-operator/blob/main/HISTORY.md">HISTORY.md</a>).
Many members of the pipe champion group think this is unfortunate,
and they are willing to fight again <strong>later</strong> for an <a href="#tacit-unary-function-application-syntax">F#-pipe split mix</a> and <a href="https://github.com/tc39/proposal-partial-application">PFA syntax</a>.
But there are quite a few representatives (including <a href="https://github.com/tc39/proposal-pipeline-operator/blob/main/HISTORY.md#2021-07">browser-engine implementers</a>)
outside of the Pipe Champion Group
who are generally against encouraging <a href="https://en.wikipedia.org/wiki/Tacit_programming" rel="nofollow">tacit programming</a> (and <a href="https://github.com/tc39/proposal-partial-application">PFA syntax</a>),
regardless of Hack pipes.</p>
<h2 dir="auto"><a id="user-content-description" aria-hidden="true" href="#description"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Description</h2>
<p dir="auto">(A <a href="http://tc39.github.io/proposal-pipeline-operator/" rel="nofollow">formal draft specification</a> is available.)</p>
<p dir="auto">The <strong>topic reference</strong> <code>%</code> is a <strong>nullary operator</strong>.
It acts as a placeholder for a <strong>topic value</strong>,
and it is <strong>lexically scoped</strong> and <strong>immutable</strong>.</p>
<details>
<summary><code>%</code> is not a final choice</summary>
<p dir="auto">(The precise <a href="https://github.com/tc39/proposal-pipeline-operator/issues/91" data-hovercard-type="issue" data-hovercard-url="/tc39/proposal-pipeline-operator/issues/91/hovercard"><strong>token</strong> for the topic reference is <strong>not final</strong></a>.
<code>%</code> could instead be <code>^</code>, or many other tokens.
We plan to <a href="https://github.com/tc39/proposal-pipeline-operator/issues/91" data-hovercard-type="issue" data-hovercard-url="/tc39/proposal-pipeline-operator/issues/91/hovercard"><strong>bikeshed</strong> what actual token to use</a>
before advancing to Stage 3.
However, <code>%</code> seems to be the <a href="https://github.com/js-choi/proposal-hack-pipes/issues/2" data-hovercard-type="issue" data-hovercard-url="/tc39/proposal-hack-pipes/issues/2/hovercard">least syntactically problematic</a>,
and it also resembles the placeholders of <strong><a href="https://en.wikipedia.org/wiki/Printf_format_string" rel="nofollow">printf format strings</a></strong>
and <a href="https://clojure.org/reference/reader#_dispatch" rel="nofollow"><strong>Clojure</strong>’s <code>#(%)</code> <strong>function literals</strong></a>.)</p>
</details>
<p dir="auto">The <strong>pipe operator</strong> <code>|&gt;</code> is an <strong>infix operator</strong>
that forms a <strong>pipe expression</strong> (also called a <strong>pipeline</strong>).
It evaluates its lefthand side (the <strong>pipe head</strong> or <strong>pipe input</strong>),
immutably <strong>binds</strong> the resulting value (the <strong>topic value</strong>) to the <strong>topic reference</strong>,
then evaluates its righthand side (the <strong>pipe body</strong>) with that binding.
The resulting value of the righthand side
becomes the whole pipe expression’s final value (the <strong>pipe output</strong>).</p>
<p dir="auto">The pipe operator’s precedence is the <strong>same</strong> as:</p>
<ul dir="auto">
<li>the function arrow <code>=&gt;</code>;</li>
<li>the assignment operators <code>=</code>, <code>+=</code>, etc.;</li>
<li>the generator operators <code>yield</code> and <code>yield *</code>;</li>
</ul>
<p dir="auto">It is <strong>tighter</strong> than only the comma operator <code>,</code>.</p>
<p dir="auto">For example, <code>v =&gt; v |&gt; % == null |&gt; foo(%, 0)</code></p>
<p dir="auto">A pipe body <strong>must</strong> use its topic value <strong>at least once</strong>.
For example, <code>value |&gt; foo + 1</code> is <strong>invalid syntax</strong>,
because its body does not contain a topic reference.
This design is because <strong>omission</strong> of the topic reference
from a pipe expression’s body
is almost certainly an <strong>accidental</strong> programmer error.</p>
<p dir="auto">Likewise, a topic reference <strong>must</strong> be contained in a pipe body.
Using a topic reference outside of a pipe body
is also <strong>invalid syntax</strong>.</p>
<p dir="auto">To prevent confusing grouping,
it is <strong>invalid</strong> syntax to use <strong>other</strong> operators that have <strong>similar precedence</strong>
(i.e., the arrow <code>=&gt;</code>, the ternary conditional operator <code>?</code> <code>:</code>,
the assignment operators, and the <code>yield</code> operator)
as a <strong>pipe head or body</strong>.
When using <code>|&gt;</code> with these operators, we must use <strong>parentheses</strong>
to explicitly indicate what grouping is correct.
For example, <code>a |&gt; b ? % : c |&gt; %.d</code> is invalid syntax;
it should be corrected to either <code>a |&gt; (b ? % : c) |&gt; %.d</code>
or <code>a |&gt; (b ? % : c |&gt; %.d)</code>.</p>
<p dir="auto">Lastly, topic bindings <strong>inside dynamically compiled</strong> code
(e.g., with <code>eval</code> or <code>new Function</code>)
<strong>cannot</strong> be used <strong>outside</strong> of that code.
For example, <code>v |&gt; eval(&#39;% + 1&#39;)</code> will throw a syntax error
when the <code>eval</code> expression is evaluated at runtime.</p>
<p dir="auto">There are <strong>no other special rules</strong>.</p>
<p dir="auto">A natural result of these rules is that,
if we need to interpose a <strong>side effect</strong>
in the middle of a chain of pipe expressions,
without modifying the data being piped through,
then we could use a <strong>comma expression</strong>,
such as with <code>value |&gt; (sideEffect(), %)</code>.
As usual, the comma expression will evaluate to its righthand side <code>%</code>,
essentially passing through the topic value without modifying it.
This is especially useful for quick debugging: <code>value |&gt; (console.log(%), %)</code>.</p>
<h2 dir="auto"><a id="user-content-real-world-examples" aria-hidden="true" href="#real-world-examples"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Real-world examples</h2>
<p dir="auto">The only changes to the original examples were dedentation and removal of comments.</p>
<p dir="auto">From <a href="https://github.com/jquery/jquery/blob/2.2-stable/build/tasks/sourcemap.js">jquery/build/tasks/sourceMap.js</a>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Status quo
var minLoc = Object.keys( grunt.config( &#34;uglify.all.files&#34; ) )[ 0 ];

// With pipes
var minLoc = grunt.config(&#39;uglify.all.files&#39;) |&gt; Object.keys(%)[0];"><pre><span>// Status quo</span>
<span>var</span> <span>minLoc</span> <span>=</span> <span>Object</span><span>.</span><span>keys</span><span>(</span> <span>grunt</span><span>.</span><span>config</span><span>(</span> <span>&#34;uglify.all.files&#34;</span> <span>)</span> <span>)</span><span>[</span> <span>0</span> <span>]</span><span>;</span>

<span>// With pipes</span>
<span>var</span> <span>minLoc</span> <span>=</span> <span>grunt</span><span>.</span><span>config</span><span>(</span><span>&#39;uglify.all.files&#39;</span><span>)</span> <span>|</span><span>&gt;</span> <span>Object</span><span>.</span><span>keys</span><span>(</span><span>%</span><span>)</span><span>[</span><span>0</span><span>]</span><span>;</span></pre></div>
<p dir="auto">From <a href="https://github.com/nodejs/node/blob/v16.x/deps/npm/lib/unpublish.js">node/deps/npm/lib/unpublish.js</a>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Status quo
const json = await npmFetch.json(npa(pkgs[0]).escapedName, opts);

// With pipes
const json = pkgs[0] |&gt; npa(%).escapedName |&gt; await npmFetch.json(%, opts);"><pre><span>// Status quo</span>
<span>const</span> <span>json</span> <span>=</span> <span>await</span> <span>npmFetch</span><span>.</span><span>json</span><span>(</span><span>npa</span><span>(</span><span>pkgs</span><span>[</span><span>0</span><span>]</span><span>)</span><span>.</span><span>escapedName</span><span>,</span> <span>opts</span><span>)</span><span>;</span>

<span>// With pipes</span>
<span>const</span> <span>json</span> <span>=</span> <span>pkgs</span><span>[</span><span>0</span><span>]</span> <span>|</span><span>&gt;</span> <span>npa</span><span>(</span><span>%</span><span>)</span><span>.</span><span>escapedName</span> <span>|</span><span>&gt;</span> <span>await</span> <span>npmFetch</span><span>.</span><span>json</span><span>(</span><span>%</span><span>,</span> <span>opts</span><span>)</span><span>;</span></pre></div>
<p dir="auto">From <a href="https://underscorejs.org/docs/underscore-esm.html" rel="nofollow">underscore.js</a>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Status quo
return filter(obj, negate(cb(predicate)), context);

// With pipes
return cb(predicate) |&gt; _.negate(%) |&gt; _.filter(obj, %, context);"><pre><span>// Status quo</span>
<span>return</span> <span>filter</span><span>(</span><span>obj</span><span>,</span> <span>negate</span><span>(</span><span>cb</span><span>(</span><span>predicate</span><span>)</span><span>)</span><span>,</span> <span>context</span><span>)</span><span>;</span>

<span>// With pipes</span>
<span>return</span> <span>cb</span><span>(</span><span>predicate</span><span>)</span> <span>|</span><span>&gt;</span> <span>_</span><span>.</span><span>negate</span><span>(</span><span>%</span><span>)</span> <span>|</span><span>&gt;</span> <span>_</span><span>.</span><span>filter</span><span>(</span><span>obj</span><span>,</span> <span>%</span><span>,</span> <span>context</span><span>)</span><span>;</span></pre></div>
<p dir="auto">From <a href="https://github.com/ramda/ramda/blob/v0.27.1/dist/ramda.js">ramda.js</a>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Status quo
return xf[&#39;@@transducer/result&#39;](obj[methodName](bind(xf[&#39;@@transducer/step&#39;], xf), acc));

// With pipes
return xf
  |&gt; bind(%[&#39;@@transducer/step&#39;], %)
  |&gt; obj[methodName](%, acc)
  |&gt; xf[&#39;@@transducer/result&#39;](%);"><pre><span>// Status quo</span>
<span>return</span> <span>xf</span><span>[</span><span>&#39;@@transducer/result&#39;</span><span>]</span><span>(</span><span>obj</span><span>[</span><span>methodName</span><span>]</span><span>(</span><span>bind</span><span>(</span><span>xf</span><span>[</span><span>&#39;@@transducer/step&#39;</span><span>]</span><span>,</span> <span>xf</span><span>)</span><span>,</span> <span>acc</span><span>)</span><span>)</span><span>;</span>

<span>// With pipes</span>
<span>return</span> <span>xf</span>
  <span>|</span><span>&gt;</span> <span>bind</span><span>(</span><span>%</span><span>[</span><span>&#39;@@transducer/step&#39;</span><span>]</span><span>,</span> <span>%</span><span>)</span>
  <span>|</span><span>&gt;</span> <span>obj</span><span>[</span><span>methodName</span><span>]</span><span>(</span><span>%</span><span>,</span> <span>acc</span><span>)</span>
  <span>|</span><span>&gt;</span> <span>xf</span><span>[</span><span>&#39;@@transducer/result&#39;</span><span>]</span><span>(</span><span>%</span><span>)</span><span>;</span></pre></div>
<p dir="auto">From <a href="https://github.com/ramda/ramda/blob/v0.27.1/dist/ramda.js">ramda.js</a>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Status quo
try {
  return tryer.apply(this, arguments);
} catch (e) {
  return catcher.apply(this, _concat([e], arguments));
}

// With pipes: Note the visual parallelism between the two clauses.
try {
  return arguments
    |&gt; tryer.apply(this, %);
} catch (e) {
  return arguments
    |&gt; _concat([e], %)
    |&gt; catcher.apply(this, %);
}"><pre><span>// Status quo</span>
<span>try</span> <span>{</span>
  <span>return</span> <span>tryer</span><span>.</span><span>apply</span><span>(</span><span>this</span><span>,</span> <span>arguments</span><span>)</span><span>;</span>
<span>}</span> <span>catch</span> <span>(</span><span>e</span><span>)</span> <span>{</span>
  <span>return</span> <span>catcher</span><span>.</span><span>apply</span><span>(</span><span>this</span><span>,</span> <span>_concat</span><span>(</span><span>[</span><span>e</span><span>]</span><span>,</span> <span>arguments</span><span>)</span><span>)</span><span>;</span>
<span>}</span>

<span>// With pipes: Note the visual parallelism between the two clauses.</span>
<span>try</span> <span>{</span>
  <span>return</span> <span>arguments</span>
    <span>|</span><span>&gt;</span> <span>tryer</span><span>.</span><span>apply</span><span>(</span><span>this</span><span>,</span> <span>%</span><span>)</span><span>;</span>
<span>}</span> <span>catch</span> <span>(</span><span>e</span><span>)</span> <span>{</span>
  <span>return</span> <span>arguments</span>
    <span>|</span><span>&gt;</span> <span>_concat</span><span>(</span><span>[</span><span>e</span><span>]</span><span>,</span> <span>%</span><span>)</span>
    <span>|</span><span>&gt;</span> <span>catcher</span><span>.</span><span>apply</span><span>(</span><span>this</span><span>,</span> <span>%</span><span>)</span><span>;</span>
<span>}</span></pre></div>
<p dir="auto">From <a href="https://github.com/expressjs/express/blob/5.0/lib/response.js">express/lib/response.js</a>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Status quo
return this.set(&#39;Link&#39;, link + Object.keys(links).map(function(rel){
  return &#39;&lt;&#39; + links[rel] + &#39;&gt;; rel=&#34;&#39; + rel + &#39;&#34;&#39;;
}).join(&#39;, &#39;));

// With pipes
return links
  |&gt; Object.keys(%).map(function (rel) {
    return &#39;&lt;&#39; + links[rel] + &#39;&gt;; rel=&#34;&#39; + rel + &#39;&#34;&#39;;
  })
  |&gt; link + %.join(&#39;, &#39;)
  |&gt; this.set(&#39;Link&#39;, %);"><pre><span>// Status quo</span>
<span>return</span> <span>this</span><span>.</span><span>set</span><span>(</span><span>&#39;Link&#39;</span><span>,</span> <span>link</span> <span>+</span> <span>Object</span><span>.</span><span>keys</span><span>(</span><span>links</span><span>)</span><span>.</span><span>map</span><span>(</span><span>function</span><span>(</span><span>rel</span><span>)</span><span>{</span>
  <span>return</span> <span>&#39;&lt;&#39;</span> <span>+</span> <span>links</span><span>[</span><span>rel</span><span>]</span> <span>+</span> <span>&#39;&gt;; rel=&#34;&#39;</span> <span>+</span> <span>rel</span> <span>+</span> <span>&#39;&#34;&#39;</span><span>;</span>
<span>}</span><span>)</span><span>.</span><span>join</span><span>(</span><span>&#39;, &#39;</span><span>)</span><span>)</span><span>;</span>

<span>// With pipes</span>
<span>return</span> <span>links</span>
  <span>|</span><span>&gt;</span> <span>Object</span><span>.</span><span>keys</span><span>(</span><span>%</span><span>)</span><span>.</span><span>map</span><span>(</span><span>function</span> <span>(</span><span>rel</span><span>)</span> <span>{</span>
    <span>return</span> <span>&#39;&lt;&#39;</span> <span>+</span> <span>links</span><span>[</span><span>rel</span><span>]</span> <span>+</span> <span>&#39;&gt;; rel=&#34;&#39;</span> <span>+</span> <span>rel</span> <span>+</span> <span>&#39;&#34;&#39;</span><span>;</span>
  <span>}</span><span>)</span>
  <span>|</span><span>&gt;</span> <span>link</span> <span>+</span> <span>%</span><span>.</span><span>join</span><span>(</span><span>&#39;, &#39;</span><span>)</span>
  <span>|</span><span>&gt;</span> <span>this</span><span>.</span><span>set</span><span>(</span><span>&#39;Link&#39;</span><span>,</span> <span>%</span><span>)</span><span>;</span></pre></div>
<p dir="auto">From <a href="https://github.com/facebook/react/blob/17.0.2/scripts/jest/jest-cli.js">react/scripts/jest/jest-cli.js</a>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Status quo
console.log(
  chalk.dim(
    `$ ${Object.keys(envars)
      .map(envar =&gt; `${envar}=${envars[envar]}`)
      .join(&#39; &#39;)}`,
    &#39;node&#39;,
    args.join(&#39; &#39;)
  )
);

// With pipes
Object.keys(envars)
  .map(envar =&gt; `${envar}=${envars[envar]}`)
  .join(&#39; &#39;)
  |&gt; `$ ${%}`
  |&gt; chalk.dim(%, &#39;node&#39;, args.join(&#39; &#39;))
  |&gt; console.log(%);"><pre><span>// Status quo</span>
<span>console</span><span>.</span><span>log</span><span>(</span>
  <span>chalk</span><span>.</span><span>dim</span><span>(</span>
    <span>`$ <span><span>${</span><span>Object</span><span>.</span><span>keys</span><span>(</span><span>envars</span><span>)</span></span></span>
<span><span>      <span>.</span><span>map</span><span>(</span><span>envar</span> <span>=&gt;</span> <span>`<span><span>${</span><span>envar</span><span>}</span></span>=<span><span>${</span><span>envars</span><span>[</span><span>envar</span><span>]</span><span>}</span></span>`</span><span>)</span></span></span>
<span><span>      <span>.</span><span>join</span><span>(</span><span>&#39; &#39;</span><span>)</span><span>}</span></span>`</span><span>,</span>
    <span>&#39;node&#39;</span><span>,</span>
    <span>args</span><span>.</span><span>join</span><span>(</span><span>&#39; &#39;</span><span>)</span>
  <span>)</span>
<span>)</span><span>;</span>

<span>// With pipes</span>
<span>Object</span><span>.</span><span>keys</span><span>(</span><span>envars</span><span>)</span>
  <span>.</span><span>map</span><span>(</span><span>envar</span> <span>=&gt;</span> <span>`<span><span>${</span><span>envar</span><span>}</span></span>=<span><span>${</span><span>envars</span><span>[</span><span>envar</span><span>]</span><span>}</span></span>`</span><span>)</span>
  <span>.</span><span>join</span><span>(</span><span>&#39; &#39;</span><span>)</span>
  <span>|</span><span>&gt;</span> `$ ${<span>%</span><span>}</span>`
  <span>|</span><span>&gt;</span> <span>chalk</span><span>.</span><span>dim</span><span>(</span><span>%</span><span>,</span> <span>&#39;node&#39;</span><span>,</span> <span>args</span><span>.</span><span>join</span><span>(</span><span>&#39; &#39;</span><span>)</span><span>)</span>
  <span>|</span><span>&gt;</span> <span>console</span><span>.</span><span>log</span><span>(</span><span>%</span><span>)</span><span>;</span></pre></div>
<p dir="auto">From <a href="https://github.com/ramda/ramda/blob/v0.27.1/dist/ramda.js">ramda.js</a>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Status quo
return _reduce(xf(typeof fn === &#39;function&#39; ? _xwrap(fn) : fn), acc, list);

// With pipes
return fn
  |&gt; (typeof % === &#39;function&#39; ? _xwrap(%) : %)
  |&gt; xf(%)
  |&gt; _reduce(%, acc, list);"><pre><span>// Status quo</span>
<span>return</span> <span>_reduce</span><span>(</span><span>xf</span><span>(</span><span>typeof</span> <span>fn</span> <span>===</span> <span>&#39;function&#39;</span> ? <span>_xwrap</span><span>(</span><span>fn</span><span>)</span> : <span>fn</span><span>)</span><span>,</span> <span>acc</span><span>,</span> <span>list</span><span>)</span><span>;</span>

<span>// With pipes</span>
<span>return</span> <span>fn</span>
  <span>|</span><span>&gt;</span> <span>(</span><span>typeof</span> <span>%</span> <span>===</span> <span>&#39;function&#39;</span> ? <span>_xwrap</span><span>(</span><span>%</span><span>)</span> : <span>%</span><span>)</span>
  <span>|</span><span>&gt;</span> <span>xf</span><span>(</span><span>%</span><span>)</span>
  <span>|</span><span>&gt;</span> <span>_reduce</span><span>(</span><span>%</span><span>,</span> <span>acc</span><span>,</span> <span>list</span><span>)</span><span>;</span></pre></div>
<p dir="auto">From <a href="https://github.com/jquery/jquery/blob/2.2-stable/src/core/init.js">jquery/src/core/init.js</a>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Status quo
jQuery.merge( this, jQuery.parseHTML(
  match[ 1 ],
  context &amp;&amp; context.nodeType ? context.ownerDocument || context : document,
  true
) );

// With pipes
context
  |&gt; (% &amp;&amp; %.nodeType ? %.ownerDocument || % : document)
  |&gt; jQuery.parseHTML(match[1], %, true)
  |&gt; jQuery.merge(%);"><pre><span>// Status quo</span>
<span>jQuery</span><span>.</span><span>merge</span><span>(</span> <span>this</span><span>,</span> <span>jQuery</span><span>.</span><span>parseHTML</span><span>(</span>
  <span>match</span><span>[</span> <span>1</span> <span>]</span><span>,</span>
  <span>context</span> <span>&amp;&amp;</span> <span>context</span><span>.</span><span>nodeType</span> ? <span>context</span><span>.</span><span>ownerDocument</span> <span>||</span> <span>context</span> : <span>document</span><span>,</span>
  <span>true</span>
<span>)</span> <span>)</span><span>;</span>

<span>// With pipes</span>
<span>context</span>
  <span>|</span><span>&gt;</span> <span>(</span><span>%</span> <span>&amp;&amp;</span> <span>%</span><span>.</span><span>nodeType</span> ? <span>%</span><span>.</span><span>ownerDocument</span> <span>||</span> <span>%</span> : <span>document</span><span>)</span>
  <span>|</span><span>&gt;</span> <span>jQuery</span><span>.</span><span>parseHTML</span><span>(</span><span>match</span><span>[</span><span>1</span><span>]</span><span>,</span> <span>%</span><span>,</span> <span>true</span><span>)</span>
  <span>|</span><span>&gt;</span> <span>jQuery</span><span>.</span><span>merge</span><span>(</span><span>%</span><span>)</span><span>;</span></pre></div>
<h2 dir="auto"><a id="user-content-relationships-with-other-proposals" aria-hidden="true" href="#relationships-with-other-proposals"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Relationships with other proposals</h2>
<h3 dir="auto"><a id="user-content-function-helpers" aria-hidden="true" href="#function-helpers"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>Function</code> helpers</h3>
<p dir="auto">Hack pipes can and would coexist with the <a href="https://github.com/js-choi/proposal-function-helpers"><code>Function</code> helpers proposal</a>,
including its <code>pipe</code> and <code>flow</code> functions.
These simple (and commonly downloaded) convenience functions
manipulate unary functions without extra syntax.</p>
<p dir="auto"><a href="#tc39-has-rejected-f-pipes-multiple-times">TC39 has rejected the F# pipe operator twice</a>.
Given this reality, TC39 is considerably more likely to pass
<code>pipe</code> and <code>flow</code> helper functions than a similar syntactic operator.</p>
<p dir="auto">Standardized <code>pipe</code> and <code>flow</code> convenience functions
may also obviate some of the need for a F#-pipe infix operator.
(They would not preclude standardizing an equivalent operator later.
For example, TC39 standardized binary <code>**</code> even when <code>Math.pow</code> existed.)</p>
<h3 dir="auto"><a id="user-content-partial-function-application-syntax" aria-hidden="true" href="#partial-function-application-syntax"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Partial-function-application syntax</h3>
<p dir="auto">Hack pipes can coexist with a syntax for <strong>partial function application</strong> (PFA).
There are two approaches with which they may coexist.</p>
<p dir="auto">The <strong>first approach</strong> is with an <strong>eagerly</strong> evaluated PFA syntax,
which has <a href="https://github.com/tc39/proposal-partial-application">already been proposed in proposal-partial-application</a>.
This eager PFA syntax would add an <code>…~(…)</code> operator.
The operator’s right-hand side would be a list of arguments,
each of which is an ordinary expression or a <code>?</code> placeholder.
Each consecutive <code>?</code> placeholder would represent another parameter.</p>
<p dir="auto">Ordinary expressions would be evaluated <strong>before</strong> the function is created.
For example, <code>f~(g(), ?, h(), ?)</code> would evaluate <code>f</code>, then <code>g()</code>, then <code>h()</code>,
and <em>then</em> it would create a partially applied version of <code>f</code> with two arguments.</p>
<p dir="auto">An optional number after <code>?</code> placeholder
would override the parameter’s position.
For example, <code>f~(?1, ?0)</code> would have two parameters but would switch them when calling <code>f</code>.</p>
<p dir="auto">The <strong>second approach</strong> is with a <strong>lazily</strong> evaluated syntax.
This could be handled with an <strong>extension to Hack pipes</strong>,
with a syntax further inspired by
<a href="https://clojure.org/reference/reader#_dispatch" rel="nofollow">Clojure’s <code>#(^1 ^2)</code> function literals</a>.
It would do so by <strong>combining</strong> the Hack pipe <code>|&gt;</code>
with the <strong>arrow function</strong> <code>=&gt;</code>
into a <strong>pipe-function</strong> operator <code>+&gt;</code>,
which would use the same general rules as <code>|&gt;</code>.</p>
<p dir="auto"><code>+&gt;</code> would be a <strong>prefix operator</strong> that <strong>creates a new function</strong>,
which in turn <strong>binds its argument(s)</strong> to topic references.
<strong>Non-unary functions</strong> would be created
by including topic references with <strong>numbers</strong> (<code>%0</code>, <code>%1</code>, <code>%2</code>, etc.) or <code>...</code>.
<code>%0</code> (equivalent to plain <code>%</code>) would be bound to the <strong>zeroth argument</strong>,
<code>%1</code> would be bound to the next argument, and so on.
<code>%...</code> would be bound to an array of <strong>rest arguments</strong>.
And just as with <code>|&gt;</code>, <code>+&gt;</code> would require its body
to contain at least one topic reference
in order to be syntactically valid.</p>
<table>
<thead>
<tr>
<th>Eager PFA</th>
<th>Pipe functions</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>a.map(f~(?, 0))</code></td>
<td><code>a.map(+&gt; f(%, 0))</code></td>
</tr>
<tr>
<td><code>a.map(f~(?, ?, 0))</code></td>
<td><code>a.map(+&gt; f(%0, %1, 0))</code></td>
</tr>
<tr>
<td><code>a.map(x=&gt; x + 1)</code></td>
<td><code>a.map(+&gt; % + 1)</code></td>
</tr>
<tr>
<td><code>a.map(x=&gt; x + x)</code></td>
<td><code>a.map(+&gt; % + %)</code></td>
</tr>
<tr>
<td><code>a.map(x=&gt; f(x, x))</code></td>
<td><code>a.map(+&gt; f(%, %))</code></td>
</tr>
</tbody>
</table>
<p dir="auto">In contrast to the <a href="https://github.com/tc39/proposal-partial-application">eagerly evaluated PFA syntax</a>,
topic functions would <strong>lazily</strong> evaluate its arguments,
just like how an arrow function would.</p>
<p dir="auto">For example, <code>+&gt; f(g(), %0, h(), %1)</code> would evaluate <code>f</code>,
and then it would create an arrow function that closes over <code>g</code> and <code>h</code>.
The created function would <strong>not</strong> evaluate <code>g()</code> or <code>h()</code>
until the every time the created function is called.</p>
<p dir="auto">No matter the approach taken, Hack pipes could coexist with PFA.</p>
<h3 dir="auto"><a id="user-content-eventual-sending--pipelining" aria-hidden="true" href="#eventual-sending--pipelining"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Eventual sending / pipelining</h3>
<p dir="auto">Despite sharing the word “pipe” in their name,
the pipe operator and the <a href="https://github.com/tc39/proposal-eventual-send/">eventual-send proposal</a>’s remote-object pipelines
are orthogonal and independent.
They can coexist and even work together.</p>
<div dir="auto" data-snippet-clipboard-copy-content="const fileP = E(
  E(target).openDirectory(dirName)
).openFile(fileName);

const fileP = target
|&gt; E(%).openDirectory(dirName)
|&gt; E(%).openFile(fileName);"><pre><span>const</span> <span>fileP</span> <span>=</span> <span>E</span><span>(</span>
  <span>E</span><span>(</span><span>target</span><span>)</span><span>.</span><span>openDirectory</span><span>(</span><span>dirName</span><span>)</span>
<span>)</span><span>.</span><span>openFile</span><span>(</span><span>fileName</span><span>)</span><span>;</span>

<span>const</span> <span>fileP</span> <span>=</span> <span>target</span>
<span>|</span><span>&gt;</span> <span>E</span><span>(</span><span>%</span><span>)</span><span>.</span><span>openDirectory</span><span>(</span><span>dirName</span><span>)</span>
<span>|</span><span>&gt;</span> <span>E</span><span>(</span><span>%</span><span>)</span><span>.</span><span>openFile</span><span>(</span><span>fileName</span><span>)</span><span>;</span></pre></div>
<h2 dir="auto"><a id="user-content-possible-future-extensions" aria-hidden="true" href="#possible-future-extensions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Possible future extensions</h2>
<h3 dir="auto"><a id="user-content-hack-pipe-syntax-for-if-catch-and-forof" aria-hidden="true" href="#hack-pipe-syntax-for-if-catch-and-forof"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Hack-pipe syntax for <code>if</code>, <code>catch</code>, and <code>for</code>–<code>of</code></h3>
<p dir="auto">Many <strong><code>if</code>, <code>catch</code>, and <code>for</code> statements</strong> could become pithier
if they gained <strong>“pipe syntax”</strong> that bound the topic reference.</p>
<p dir="auto"><code>if () |&gt;</code> would bind its condition value to <code>%</code>,</p>
<table>
<thead>
<tr>
<th>Status quo</th>
<th>Hack-pipe statement syntax</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>const c = f(); if (c) g(c);</code></td>
<td><code>if (f()) |&gt; g(%);</code></td>
</tr>
<tr>
<td><code>catch (e) f(e);</code></td>
<td><code>catch |&gt; f(%);</code></td>
</tr>
<tr>
<td><code>for (const v of f()) g(v);</code></td>
<td><code>for (f()) |&gt; g(%);</code></td>
</tr>
</tbody>
</table>
<h3 dir="auto"><a id="user-content-optional-hack-pipes" aria-hidden="true" href="#optional-hack-pipes"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Optional Hack pipes</h3>
<p dir="auto">A <strong>short-circuiting</strong> optional-pipe operator <code>|?&gt;</code> could also be useful,
much in the way <code>?.</code> is useful for optional method calls.</p>
<p dir="auto">For example, <code>value |&gt; (% == null ? % : await foo(%) |&gt; (% == null ? % : % + 1))</code></p>
<h3 dir="auto"><a id="user-content-tacit-unary-function-application-syntax" aria-hidden="true" href="#tacit-unary-function-application-syntax"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Tacit unary function application syntax</h3>
<p dir="auto"><strong>Syntax</strong> for <strong>tacit unary function application</strong> – that is, the F# pipe operator –
has been <a href="#tc39-has-rejected-f-pipes-multiple-times">rejected twice by TC39</a>.
However, they could still eventually be added to the language in two ways.</p>
<p dir="auto">First, it can be added as a convenience function <code>Function.pipe</code>.
This is what the <a href="https://github.com/js-choi/proposal-function-helpers">function-helpers proposal</a> proposes.
<code>Function.pipe</code> may obviate much of the need for an F#-pipe operator,
while still not closing off the possibility of an F#-pipe operator.</p>
<p dir="auto">Secondly, it can be added as <strong>another pipe operator</strong> <code>|&gt;&gt;</code> –
similarly to how <a href="https://clojure.org/guides/threading_macros" rel="nofollow">Clojure has multiple pipe macros</a>
<code>-&gt;</code>, <code>-&gt;&gt;</code>, and <code>as-&gt;</code>.</p>
<p dir="auto">There was an <a href="#tacit-unary-function-application-syntax">informal proposal for such a <strong>split mix</strong> of two pipe operators</a>,
which was set aside in favor of single-operator proposals.
This split mix might return as a proposal after Hack pipes.</p>
</article>
          </div></div>
  </body>
</html>
