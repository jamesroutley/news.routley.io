<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bernsteinbear.com/blog/type-inference/?utm_source=rss">Original</a>
    <h1>Damas-Hindley-Milner inference two ways</h1>
    
    <div id="readability-page-1" class="page"><div>
            <h2 id="what-is-damas-hindley-milner">What is Damas-Hindley-Milner?</h2>

<p>Damas-Hindley-Milner (HM) is a type system for the lambda calculus (later
adapted for Standard ML and the ML-family languages) with parametric
polymorphism, aka generic functions. It sits at a sweet spot in PL design: the
type system is quite expressive, and there are well known type inference
algorithms that require absolutely no annotations from the programmer.</p>

<p>It seems to have been discovered independently multiple times over the years,
but the most famous papers are the <a href="https://bernsteinbear.com/assets/img/milner-theory-type-polymorphism.pdf">original</a> (PDF) by Milner
and the <a href="https://bernsteinbear.com/assets/img/damas-milner-original.pdf">follow-on</a> (PDF) by Damas and Milner. Damas continued on
to write his <a href="https://bernsteinbear.com/assets/img/damas-thesis.pdf">thesis</a> (PDF) about it. (If you have a link to the
appropriate Hindley paper, please let me know.)</p>

<p>The type system is limited, but by virtue of being limited, it confers these
advantages:</p>

<ul>
  <li>Inference algorithms tend to be fast (roughly O(size of code), but there are
pathological cases if you have tuple or record types)</li>
  <li>Something something principal types</li>
  <li>??? <a href="https://stackoverflow.com/a/399392">It’s a good type system, reader!</a></li>
</ul>

<!--As a general note: the more constrained your language/system is, the more you
can optimize-->

<p>In this post, we implement HM in two ways (W, J, and mention a third, M), and
then extend it a little bit. We’ll do this in the context of
<a href="https://bernsteinbear.com/blog/scrapscript">scrapscript</a>, but the goal is to get a better understanding
of HM in general.</p>

<h2 id="the-main-idea">The main idea</h2>

<p>The core idea in HM is to generate type constraints based on how variables and
other expressions are used together and then solve these constraints. These
constraints are based on equality (as opposed to inequality, set subset, etc).
For example, one might look at the expression <code>a+b</code> (where <code>a</code> and <code>b</code> are any
expression, but in this case variables) and deduce that since <code>+</code> is a function
that takes two <code>int</code>s and returns an <code>int</code>,</p>

<ul>
  <li><code>a</code> must have type <code>int</code></li>
  <li><code>b</code> must have type <code>int</code></li>
  <li><code>a+b</code> must have type <code>int</code></li>
</ul>

<p>Perhaps, in the same example, later in a function, one might see <code>f a</code> (the
application of the variable <code>f</code> to the argument <code>a</code>) and deduce that <code>f</code> must
be a function.</p>

<p>We can compose all of these constraints together to infer that <code>f</code> must be a
function <em>that can take an integer as an argument</em>.</p>

<p>Similarly, if we saw <code>[a, c]</code> (a list containing elements <code>a</code> and <code>c</code>) <em>and we
require that our lists have homogeneous type elements</em>, then we can add the
constraint that <code>a</code> and <code>c</code> have the same type. Then we can infer that <code>c</code> too
must have type <code>int</code>.</p>

<p>To keep track of all this information, we need some infrastructure. We need a
notion of types, which we’ll call <em>type constructors</em>, and placeholders in our
system of type equations, which we’ll call <em>type variables</em>.</p>

<h2 id="the-data-structures">The data structures</h2>

<p>Every expression has exactly one type, called a <em>monotype</em>. For our purposes, a
monotype is either a type variable like <code>&#39;a</code> or the application of a type
constructor like <code>-&gt;</code> (a function, as in OCaml or Haskell), <code>list</code>, etc to
monotype arguments (<code>&#39;a list</code>, <code>&#39;a -&gt; &#39;b</code>).</p>

<p>We represent those two kinds in Python with classes:</p>

<div><div><pre><code><span>@</span><span>dataclasses</span><span>.</span><span>dataclass</span>
<span>class</span> <span>MonoType</span><span>:</span>
    <span>pass</span>


<span>@</span><span>dataclasses</span><span>.</span><span>dataclass</span>
<span>class</span> <span>TyVar</span><span>(</span><span>MonoType</span><span>):</span>
    <span>name</span><span>:</span> <span>str</span>


<span>@</span><span>dataclasses</span><span>.</span><span>dataclass</span>
<span>class</span> <span>TyCon</span><span>(</span><span>MonoType</span><span>):</span>
    <span>name</span><span>:</span> <span>str</span>
    <span>args</span><span>:</span> <span>list</span><span>[</span><span>MonoType</span><span>]</span>
</code></pre></div></div>

<p>A lot of people make HM type inference implementations by hard-coding functions
and other type constructors like <code>list</code> as the only type constructors but we
instead model them all in terms of <code>TyCon</code>:</p>

<div><div><pre><code><span>IntType</span> <span>=</span> <span>TyCon</span><span>(</span><span>&#34;int&#34;</span><span>,</span> <span>[])</span>
<span>BoolType</span> <span>=</span> <span>TyCon</span><span>(</span><span>&#34;bool&#34;</span><span>,</span> <span>[])</span>

<span>def</span> <span>list_type</span><span>(</span><span>ty</span><span>:</span> <span>MonoType</span><span>)</span> <span>-&gt;</span> <span>MonoType</span><span>:</span>
    <span>return</span> <span>TyCon</span><span>(</span><span>&#34;list&#34;</span><span>,</span> <span>[</span><span>ty</span><span>])</span>

<span>def</span> <span>func_type</span><span>(</span><span>arg</span><span>:</span> <span>MonoType</span><span>,</span> <span>ret</span><span>:</span> <span>MonoType</span><span>)</span> <span>-&gt;</span> <span>MonoType</span><span>:</span>
    <span>return</span> <span>TyCon</span><span>(</span><span>&#34;-&gt;&#34;</span><span>,</span> <span>[</span><span>arg</span><span>,</span> <span>ret</span><span>])</span>
</code></pre></div></div>

<p>We’ll also have something called a forall (also known as a type scheme,
universal quantification, polytype, etc used for polymorphism), which we’ll
talk about more later, but for now is a thin wrapper around a monotype:</p>

<div><div><pre><code><span>@</span><span>dataclasses</span><span>.</span><span>dataclass</span>
<span>class</span> <span>Forall</span><span>:</span>
    <span>tyvars</span><span>:</span> <span>list</span><span>[</span><span>TyVar</span><span>]</span>
    <span>ty</span><span>:</span> <span>MonoType</span>
</code></pre></div></div>

<p>With these, we model the world.</p>

<h2 id="algorithm-w">Algorithm W</h2>

<p>Algorithm W is probably the most famous one (citation needed) because it was
presented in the paper as the easiest to prove correct. It’s also free of side
effects, which probably appeals to <a href="https://hackage.haskell.org/package/union-find-array-0.1.0.4/docs/Control-Monad-Union.html">Haskell nerds</a>.</p>

<p>(Because it is side effect free, it requires threading all the state through by
hand. This can look intimidating compared to Algorithm J, where we mutate
global state as we go. If you get discouraged, you might want to skip ahead to
Algorithm J.)</p>

<p>The idea is that you have a function <code>infer_w</code> that takes an expression and an
<em>environment</em> (a “context”) and returns a <em>substitution</em> and a type. The type
is the type of the expression that you passed in. We’ll use the substitution to
keep track of constraints on types that we learn as we walk the tree. It’s a
mapping from type variables to monotypes. As we learn more information, the
substitution will grow.</p>

<p>In Python syntax, that’s:</p>

<div><div><pre><code><span>Subst</span> <span>=</span> <span>typing</span><span>.</span><span>Mapping</span><span>[</span><span>str</span><span>,</span> <span>MonoType</span><span>]</span>  <span># type variable -&gt; monotype
</span><span>Context</span> <span>=</span> <span>typing</span><span>.</span><span>Mapping</span><span>[</span><span>str</span><span>,</span> <span>Forall</span><span>]</span>  <span># program variable -&gt; type scheme
</span><span>def</span> <span>infer_w</span><span>(</span><span>expr</span><span>:</span> <span>Object</span><span>,</span> <span>ctx</span><span>:</span> <span>Context</span><span>)</span> <span>-&gt;</span> <span>tuple</span><span>[</span><span>Subst</span><span>,</span> <span>MonoType</span><span>]:</span> <span>...</span>
</code></pre></div></div>

<p>Before diving into the code, let’s go over the algorithm in prose. The rules of
inference are as follows:</p>

<ul>
  <li>if you see an integer literal
    <ul>
      <li>return <code>IntType</code></li>
    </ul>
  </li>
  <li>if you see a variable <code>e</code>,
    <ul>
      <li>look up the scheme of <code>e</code> in the environment</li>
      <li><strong>unwrap the shallow type scheme to get the monotype</strong> (we’ll return to
this later)</li>
    </ul>
  </li>
  <li>if you see a function <code>e</code>,
    <ul>
      <li>invent a new type variable <code>t</code> for the parameter, and add it to the
environment while type checking the body <code>b</code> (call that <code>type(b)</code>)</li>
      <li>return a function type from <code>t</code> to <code>type(b)</code></li>
    </ul>
  </li>
  <li>if you see function application <code>e</code>,
    <ul>
      <li>infer the type of callee <code>f</code></li>
      <li>infer the type of the argument <code>a</code></li>
      <li>invent a new type variable <code>r</code></li>
      <li>constrain <code>type(f)</code> to be a function from <code>type(a)</code> to <code>r</code></li>
      <li>return <code>r</code></li>
    </ul>
  </li>
  <li>if you see a let binding <code>let n = v in b</code> (called “where” in scrapscript) <code>e</code>,
    <ul>
      <li>infer the type of the value <code>v</code></li>
      <li>construct a <strong>superficial type scheme <code>s</code> containing <code>type(v)</code></strong> (we’ll
return to this later)</li>
      <li>add <code>n: s</code> to the environment while type checking the body <code>b</code></li>
      <li>return <code>type(b)</code></li>
    </ul>
  </li>
</ul>

<p>In general, we either constrain existing type variables or invent new ones to
stand for types about which we don’t yet have complete information.</p>

<p>In order to keep the constraints (substitutions) flowing after each recursive
call to <code>infer_w</code>, we need to be able to compose substitutions. It’s not just a
union of two dictionaries, but instead more like function composition.</p>

<div><div><pre><code><span>def</span> <span>compose</span><span>(</span><span>newer</span><span>:</span> <span>Subst</span><span>,</span> <span>older</span><span>:</span> <span>Subst</span><span>)</span> <span>-&gt;</span> <span>Subst</span><span>:</span> <span>...</span>
</code></pre></div></div>

<p>Let’s look at a manual “type inference” session where we incrementally learn
that <code>a</code> is found equivalent to <code>b</code> (subst 1), then <code>b</code> to <code>c</code> (subst 2), and
finally that <code>c</code> is an <code>int</code> (subst 3). These three separate facts must be
combined in order to fully realize that all three type variables are <code>int</code>.</p>

<div><div><pre><code><span>&gt;&gt;&gt;</span><span> </span><span>s1</span> <span>=</span> <span>{</span><span>&#34;a&#34;</span><span>:</span> <span>TyVar</span><span>(</span><span>&#34;b&#34;</span><span>)}</span>
<span>&gt;&gt;&gt;</span><span> </span><span>s2</span> <span>=</span> <span>{</span><span>&#34;b&#34;</span><span>:</span> <span>TyVar</span><span>(</span><span>&#34;c&#34;</span><span>)}</span>
<span>&gt;&gt;&gt;</span><span> </span><span>s3</span> <span>=</span> <span>{</span><span>&#34;c&#34;</span><span>:</span> <span>TyCon</span><span>(</span><span>&#34;int&#34;</span><span>,</span> <span>[])}</span>
<span>&gt;&gt;&gt;</span><span> </span><span>compose</span><span>(</span><span>s2</span><span>,</span> <span>s1</span><span>)</span>
<span>{&#39;a&#39;: TyVar(name=&#39;c&#39;), &#39;b&#39;: TyVar(name=&#39;c&#39;)}
</span><span>&gt;&gt;&gt;</span><span> </span><span>compose</span><span>(</span><span>s3</span><span>,</span> <span>compose</span><span>(</span><span>s2</span><span>,</span> <span>s1</span><span>))</span>
<span>{&#39;a&#39;: TyCon(name=&#39;int&#39;, args=[]),
 &#39;b&#39;: TyCon(name=&#39;int&#39;, args=[]),
 &#39;c&#39;: TyCon(name=&#39;int&#39;, args=[])}
</span><span>&gt;&gt;&gt;</span><span>
</span></code></pre></div></div>

<p>Now that we can create these substitutions, we also have to have some machinery
for transforming types with the substitutions. For that, we have <code>apply_ty</code>
(transform a type) and <code>apply_ctx</code> (transform all the types within a context).</p>

<p>In the above example, <code>apply_ctx(TyVar(&#34;a&#34;), the_big_subst)</code> would return
<code>TyCon(name=&#39;int&#39;, args=[])</code> (<code>int</code>).</p>

<div><div><pre><code><span>def</span> <span>apply_ty</span><span>(</span><span>ty</span><span>:</span> <span>MonoType</span><span>,</span> <span>subst</span><span>:</span> <span>Subst</span><span>)</span> <span>-&gt;</span> <span>MonoType</span><span>:</span> <span>...</span>

<span>def</span> <span>apply_ctx</span><span>(</span><span>ctx</span><span>:</span> <span>Context</span><span>,</span> <span>subst</span><span>:</span> <span>Subst</span><span>)</span> <span>-&gt;</span> <span>Context</span><span>:</span> <span>...</span>
</code></pre></div></div>

<p>This “constrain” process we talked about in the inference rules refers to
<em>unification</em>, which we call <code>unify_w</code>. In Algorithm W, unification involves
building up a substitution. Type variables are “easy”; bind them to a monotype.
For type constructors, we have to check that the constructor name matches, then
that they each have the same number of arguments, and finally build up
constraints by unifying the arguments pairwise.</p>

<p>There’s one catch for binding type variables: we have to check that we’re not
accidentally building recursive types. For example, consider: what does it mean
to unify <code>&#39;a</code> and <code>&#39;a list</code>? Or <code>&#39;b</code> and <code>&#39;a -&gt; &#39;b</code>? OCaml supports a limited
version of recursive types with <code>-rectypes</code> but we will not (and do not
currently know how to)… so we raise an exception.</p>

<!--
-- Z combinator doesn't type check, similar to OCaml (we don't have -rectypes)
Z factr 5

. Z = f -> (x -> f (v -> (x x) v)) (x -> f (v -> (x x) v))

. factr = facti ->
  | 0 -> 1
  | n -> n * (facti (n - 1))
-->

<div><div><pre><code><span>def</span> <span>unify_w</span><span>(</span><span>ty1</span><span>:</span> <span>MonoType</span><span>,</span> <span>ty2</span><span>:</span> <span>MonoType</span><span>)</span> <span>-&gt;</span> <span>Subst</span><span>:</span>
    <span>if</span> <span>isinstance</span><span>(</span><span>ty1</span><span>,</span> <span>TyVar</span><span>):</span>
        <span>if</span> <span>occurs_in</span><span>(</span><span>ty1</span><span>,</span> <span>ty2</span><span>):</span>
            <span>raise</span> <span>InferenceError</span><span>(</span><span>f</span><span>&#34;Occurs check failed for </span><span>{</span><span>ty1</span><span>}</span><span> and </span><span>{</span><span>ty2</span><span>}</span><span>&#34;</span><span>)</span>
        <span>return</span> <span>bind_var</span><span>(</span><span>ty2</span><span>,</span> <span>ty1</span><span>.</span><span>name</span><span>)</span>
    <span>if</span> <span>isinstance</span><span>(</span><span>ty2</span><span>,</span> <span>TyVar</span><span>):</span>  <span># Mirror
</span>        <span>return</span> <span>unify_w</span><span>(</span><span>ty2</span><span>,</span> <span>ty1</span><span>)</span>
    <span>if</span> <span>isinstance</span><span>(</span><span>ty1</span><span>,</span> <span>TyCon</span><span>)</span> <span>and</span> <span>isinstance</span><span>(</span><span>ty2</span><span>,</span> <span>TyCon</span><span>):</span>
        <span>if</span> <span>ty1</span><span>.</span><span>name</span> <span>!=</span> <span>ty2</span><span>.</span><span>name</span><span>:</span>
            <span>unify_fail</span><span>(</span><span>ty1</span><span>,</span> <span>ty2</span><span>)</span>
        <span>if</span> <span>len</span><span>(</span><span>ty1</span><span>.</span><span>args</span><span>)</span> <span>!=</span> <span>len</span><span>(</span><span>ty2</span><span>.</span><span>args</span><span>):</span>
            <span>unify_fail</span><span>(</span><span>ty1</span><span>,</span> <span>ty2</span><span>)</span>
        <span>result</span><span>:</span> <span>Subst</span> <span>=</span> <span>{}</span>
        <span>for</span> <span>l</span><span>,</span> <span>r</span> <span>in</span> <span>zip</span><span>(</span><span>ty1</span><span>.</span><span>args</span><span>,</span> <span>ty2</span><span>.</span><span>args</span><span>):</span>
            <span>result</span> <span>=</span> <span>compose</span><span>(</span>
                <span>unify_w</span><span>(</span><span>apply_ty</span><span>(</span><span>l</span><span>,</span> <span>result</span><span>),</span> <span>apply_ty</span><span>(</span><span>r</span><span>,</span> <span>result</span><span>)),</span>
                <span>result</span><span>,</span>
            <span>)</span>
        <span>return</span> <span>result</span>
    <span>raise</span> <span>TypeError</span><span>(</span><span>f</span><span>&#34;Unexpected type </span><span>{</span><span>type</span><span>(</span><span>ty1</span><span>)</span><span>}</span><span>&#34;</span><span>)</span>
</code></pre></div></div>

<p>As an example of this pairwise unification, we can see that unifying a <code>&#39;a
list</code> with an <code>int list</code> means that <code>&#39;a</code> gets marked equivalent to <code>int</code> in the
substitution:</p>

<div><div><pre><code><span>&gt;&gt;&gt;</span><span> </span><span>ty1</span> <span>=</span> <span>TyCon</span><span>(</span><span>&#34;list&#34;</span><span>,</span> <span>[</span><span>TyVar</span><span>(</span><span>&#34;a&#34;</span><span>)])</span>
<span>&gt;&gt;&gt;</span><span> </span><span>ty2</span> <span>=</span> <span>TyCon</span><span>(</span><span>&#34;list&#34;</span><span>,</span> <span>[</span><span>TyCon</span><span>(</span><span>&#34;int&#34;</span><span>,</span> <span>[])])</span>
<span>&gt;&gt;&gt;</span><span> </span><span>unify_w</span><span>(</span><span>ty1</span><span>,</span> <span>ty2</span><span>)</span>
<span>{&#39;a&#39;: TyCon(name=&#39;int&#39;, args=[])}
</span><span>&gt;&gt;&gt;</span><span>
</span></code></pre></div></div>

<p>OK, great. That’s most of our lower-level type machinery done. Let’s go back to
our plaintext algorithm description and write it in Python using <code>apply_ty</code> and
friends. We’ll handle variables, integers, functions, function application, and
<code>let</code> binding.</p>

<div><div><pre><code><span>def</span> <span>infer_w</span><span>(</span><span>expr</span><span>:</span> <span>Object</span><span>,</span> <span>ctx</span><span>:</span> <span>Context</span><span>)</span> <span>-&gt;</span> <span>tuple</span><span>[</span><span>Subst</span><span>,</span> <span>MonoType</span><span>]:</span>
    <span>if</span> <span>isinstance</span><span>(</span><span>expr</span><span>,</span> <span>Var</span><span>):</span>
        <span>scheme</span> <span>=</span> <span>ctx</span><span>.</span><span>get</span><span>(</span><span>expr</span><span>.</span><span>name</span><span>)</span>
        <span>if</span> <span>scheme</span> <span>is</span> <span>None</span><span>:</span>
            <span>raise</span> <span>TypeError</span><span>(</span><span>f</span><span>&#34;Unbound variable </span><span>{</span><span>expr</span><span>.</span><span>name</span><span>}</span><span>&#34;</span><span>)</span>
        <span>return</span> <span>{},</span> <span>scheme</span><span>.</span><span>ty</span>
    <span>if</span> <span>isinstance</span><span>(</span><span>expr</span><span>,</span> <span>Int</span><span>):</span>
        <span>return</span> <span>{},</span> <span>IntType</span>
    <span>if</span> <span>isinstance</span><span>(</span><span>expr</span><span>,</span> <span>Function</span><span>):</span>
        <span>arg_tyvar</span> <span>=</span> <span>fresh_tyvar</span><span>()</span>
        <span>body_ctx</span> <span>=</span> <span>{</span><span>**</span><span>ctx</span><span>,</span> <span>expr</span><span>.</span><span>arg</span><span>.</span><span>name</span><span>:</span> <span>Forall</span><span>([],</span> <span>arg_tyvar</span><span>)}</span>
        <span>body_subst</span><span>,</span> <span>body_ty</span> <span>=</span> <span>infer_w</span><span>(</span><span>expr</span><span>.</span><span>body</span><span>,</span> <span>body_ctx</span><span>)</span>
        <span>return</span> <span>body_subst</span><span>,</span> <span>TyCon</span><span>(</span><span>&#34;-&gt;&#34;</span><span>,</span> <span>[</span><span>apply_ty</span><span>(</span><span>arg_tyvar</span><span>,</span> <span>body_subst</span><span>),</span> <span>body_ty</span><span>])</span>
    <span>if</span> <span>isinstance</span><span>(</span><span>expr</span><span>,</span> <span>Apply</span><span>):</span>
        <span>s1</span><span>,</span> <span>ty</span> <span>=</span> <span>infer_w</span><span>(</span><span>expr</span><span>.</span><span>func</span><span>,</span> <span>ctx</span><span>)</span>
        <span>s2</span><span>,</span> <span>p</span> <span>=</span> <span>infer_w</span><span>(</span><span>expr</span><span>.</span><span>arg</span><span>,</span> <span>apply_ctx</span><span>(</span><span>ctx</span><span>,</span> <span>s1</span><span>))</span>
        <span>r</span> <span>=</span> <span>fresh_tyvar</span><span>()</span>
        <span>s3</span> <span>=</span> <span>unify_w</span><span>(</span><span>apply_ty</span><span>(</span><span>ty</span><span>,</span> <span>s2</span><span>),</span> <span>TyCon</span><span>(</span><span>&#34;-&gt;&#34;</span><span>,</span> <span>[</span><span>p</span><span>,</span> <span>r</span><span>]))</span>
        <span>return</span> <span>compose</span><span>(</span><span>s3</span><span>,</span> <span>compose</span><span>(</span><span>s2</span><span>,</span> <span>s1</span><span>)),</span> <span>apply_ty</span><span>(</span><span>r</span><span>,</span> <span>s3</span><span>)</span>
    <span>if</span> <span>isinstance</span><span>(</span><span>expr</span><span>,</span> <span>Where</span><span>):</span>
        <span>name</span><span>,</span> <span>value</span><span>,</span> <span>body</span> <span>=</span> <span>expr</span><span>.</span><span>binding</span><span>.</span><span>name</span><span>.</span><span>name</span><span>,</span> <span>expr</span><span>.</span><span>binding</span><span>.</span><span>value</span><span>,</span> <span>expr</span><span>.</span><span>body</span>
        <span>s1</span><span>,</span> <span>ty1</span> <span>=</span> <span>infer_w</span><span>(</span><span>value</span><span>,</span> <span>ctx</span><span>)</span>
        <span>ctx1</span> <span>=</span> <span>dict</span><span>(</span><span>ctx</span><span>)</span>  <span># copy
</span>        <span>ctx1</span><span>.</span><span>pop</span><span>(</span><span>name</span><span>,</span> <span>None</span><span>)</span>
        <span>ctx2</span> <span>=</span> <span>{</span><span>**</span><span>ctx</span><span>,</span> <span>name</span><span>:</span> <span>Forall</span><span>([],</span> <span>ty1</span><span>)}</span>
        <span>s2</span><span>,</span> <span>ty2</span> <span>=</span> <span>infer_w</span><span>(</span><span>body</span><span>,</span> <span>apply_ctx</span><span>(</span><span>ctx2</span><span>,</span> <span>s1</span><span>))</span>
        <span>return</span> <span>compose</span><span>(</span><span>s2</span><span>,</span> <span>s1</span><span>),</span> <span>ty2</span>
    <span>raise</span> <span>TypeError</span><span>(</span><span>f</span><span>&#34;Unexpected type </span><span>{</span><span>type</span><span>(</span><span>expr</span><span>)</span><span>}</span><span>&#34;</span><span>)</span>
</code></pre></div></div>

<p>Alright, so substitutions are a little clunky. Maybe there’s a neat way to do
this in functional languages by threading the state through automatically or
something, but we’re in Python and I’m a bit of a programming caveman, so we’re
doing side effects.</p>

<h2 id="algorithm-j">Algorithm J</h2>

<p>Unlike Algorithm W, which builds up a map of substitutions, Algorithm J uses
union-find on the type variables to store equivalences. (I wrote about
union-find previously in my intro to <a href="https://bernsteinbear.com/blog/vectorizing-ml-models/">Vectorizing ML
models</a>.)</p>

<p>We have to add the usual <code>forwarded</code>/<code>find</code>/<code>make_equal_to</code> infrastructure to
the types we defined above.</p>

<div><div><pre><code><span>@</span><span>dataclasses</span><span>.</span><span>dataclass</span>
<span>class</span> <span>MonoType</span><span>:</span>
    <span>def</span> <span>find</span><span>(</span><span>self</span><span>)</span> <span>-&gt;</span> <span>MonoType</span><span>:</span>
        <span>return</span> <span>self</span>

<span>@</span><span>dataclasses</span><span>.</span><span>dataclass</span>
<span>class</span> <span>TyVar</span><span>(</span><span>MonoType</span><span>):</span>
    <span>forwarded</span><span>:</span> <span>MonoType</span> <span>|</span> <span>None</span> <span>=</span> <span>dataclasses</span><span>.</span><span>field</span><span>(</span><span>init</span><span>=</span><span>False</span><span>,</span> <span>default</span><span>=</span><span>None</span><span>)</span>
    <span>name</span><span>:</span> <span>str</span>

    <span>def</span> <span>find</span><span>(</span><span>self</span><span>)</span> <span>-&gt;</span> <span>MonoType</span><span>:</span>
        <span># Exercise for the reader: path compression
</span>        <span>result</span><span>:</span> <span>MonoType</span> <span>=</span> <span>self</span>
        <span>while</span> <span>isinstance</span><span>(</span><span>result</span><span>,</span> <span>TyVar</span><span>):</span>
            <span>it</span> <span>=</span> <span>result</span><span>.</span><span>forwarded</span>
            <span>if</span> <span>it</span> <span>is</span> <span>None</span><span>:</span>
                <span>return</span> <span>result</span>
            <span>result</span> <span>=</span> <span>it</span>
        <span>return</span> <span>result</span>

    <span>def</span> <span>make_equal_to</span><span>(</span><span>self</span><span>,</span> <span>other</span><span>:</span> <span>MonoType</span><span>)</span> <span>-&gt;</span> <span>None</span><span>:</span>
        <span>chain_end</span> <span>=</span> <span>self</span><span>.</span><span>find</span><span>()</span>
        <span>assert</span> <span>isinstance</span><span>(</span><span>chain_end</span><span>,</span> <span>TyVar</span><span>),</span> <span>f</span><span>&#34;already resolved to </span><span>{</span><span>chain_end</span><span>}</span><span>&#34;</span>
        <span>chain_end</span><span>.</span><span>forwarded</span> <span>=</span> <span>other</span>

<span>@</span><span>dataclasses</span><span>.</span><span>dataclass</span>
<span>class</span> <span>TyCon</span><span>(</span><span>MonoType</span><span>):</span>
    <span>name</span><span>:</span> <span>str</span>
    <span>args</span><span>:</span> <span>list</span><span>[</span><span>MonoType</span><span>]</span>
</code></pre></div></div>

<p>While it doesn’t really make sense to <code>find</code> on a type constructor (it should
always be a leaf in the union-find DAG), we still define <code>find</code> to make MyPy
happy and make some code look a little more natural.</p>

<p>Once we do that, we can write our unify implementation for Algorithm J. You can
see that the general structure has not changed much, but the recursive bits
in the <code>TyCon</code> case have gotten much simpler to read.</p>

<div><div><pre><code><span>def</span> <span>unify_j</span><span>(</span><span>ty1</span><span>:</span> <span>MonoType</span><span>,</span> <span>ty2</span><span>:</span> <span>MonoType</span><span>)</span> <span>-&gt;</span> <span>None</span><span>:</span>
    <span>ty1</span> <span>=</span> <span>ty1</span><span>.</span><span>find</span><span>()</span>
    <span>ty2</span> <span>=</span> <span>ty2</span><span>.</span><span>find</span><span>()</span>
    <span>if</span> <span>isinstance</span><span>(</span><span>ty1</span><span>,</span> <span>TyVar</span><span>):</span>
        <span>if</span> <span>occurs_in</span><span>(</span><span>ty1</span><span>,</span> <span>ty2</span><span>):</span>
            <span>raise</span> <span>InferenceError</span><span>(</span><span>f</span><span>&#34;Occurs check failed for </span><span>{</span><span>ty1</span><span>}</span><span> and </span><span>{</span><span>ty2</span><span>}</span><span>&#34;</span><span>)</span>
        <span>ty1</span><span>.</span><span>make_equal_to</span><span>(</span><span>ty2</span><span>)</span>
        <span>return</span>
    <span>if</span> <span>isinstance</span><span>(</span><span>ty2</span><span>,</span> <span>TyVar</span><span>):</span>  <span># Mirror
</span>        <span>return</span> <span>unify_j</span><span>(</span><span>ty2</span><span>,</span> <span>ty1</span><span>)</span>
    <span>if</span> <span>isinstance</span><span>(</span><span>ty1</span><span>,</span> <span>TyCon</span><span>)</span> <span>and</span> <span>isinstance</span><span>(</span><span>ty2</span><span>,</span> <span>TyCon</span><span>):</span>
        <span>if</span> <span>ty1</span><span>.</span><span>name</span> <span>!=</span> <span>ty2</span><span>.</span><span>name</span><span>:</span>
            <span>unify_fail</span><span>(</span><span>ty1</span><span>,</span> <span>ty2</span><span>)</span>
        <span>if</span> <span>len</span><span>(</span><span>ty1</span><span>.</span><span>args</span><span>)</span> <span>!=</span> <span>len</span><span>(</span><span>ty2</span><span>.</span><span>args</span><span>):</span>
            <span>unify_fail</span><span>(</span><span>ty1</span><span>,</span> <span>ty2</span><span>)</span>
        <span>for</span> <span>l</span><span>,</span> <span>r</span> <span>in</span> <span>zip</span><span>(</span><span>ty1</span><span>.</span><span>args</span><span>,</span> <span>ty2</span><span>.</span><span>args</span><span>):</span>
            <span>unify_j</span><span>(</span><span>l</span><span>,</span> <span>r</span><span>)</span>
        <span>return</span>
    <span>raise</span> <span>TypeError</span><span>(</span><span>f</span><span>&#34;Unexpected type </span><span>{</span><span>type</span><span>(</span><span>ty1</span><span>)</span><span>}</span><span>&#34;</span><span>)</span>
</code></pre></div></div>

<!-- TODO: pictures -->

<p>Now that we have unify (which, remember, makes side-effecty changes using
<code>make_equal_to</code>), we can write our infer function. It will look pretty similar
to Algorithm J in overall structure, and in fact our plaintext algorithm
applies just as well.</p>

<p>The main difference is that we invent a new type variable for every AST node
and unify it with some expected type. I don’t think this is strictly necessary
(we don’t need a type variable to return <code>IntType</code> for int literals, for
example<sup id="fnref:annotate-phase" role="doc-noteref"><a href="#fn:annotate-phase" rel="footnote">1</a></sup>), but I think it makes for easier reading. If I were
to slim it down a bit, I think the rule I would use is “only invent a type
variable if it needs to be constrained in the type of something else”. Like in
<code>Apply</code>.</p>

<div><div><pre><code><span>def</span> <span>infer_j</span><span>(</span><span>expr</span><span>:</span> <span>Object</span><span>,</span> <span>ctx</span><span>:</span> <span>Context</span><span>)</span> <span>-&gt;</span> <span>MonoType</span><span>:</span>
    <span>result</span> <span>=</span> <span>fresh_tyvar</span><span>()</span>
    <span>if</span> <span>isinstance</span><span>(</span><span>expr</span><span>,</span> <span>Var</span><span>):</span>
        <span>scheme</span> <span>=</span> <span>ctx</span><span>.</span><span>get</span><span>(</span><span>expr</span><span>.</span><span>name</span><span>)</span>
        <span>if</span> <span>scheme</span> <span>is</span> <span>None</span><span>:</span>
            <span>raise</span> <span>TypeError</span><span>(</span><span>f</span><span>&#34;Unbound variable </span><span>{</span><span>expr</span><span>.</span><span>name</span><span>}</span><span>&#34;</span><span>)</span>
        <span>unify_j</span><span>(</span><span>result</span><span>,</span> <span>scheme</span><span>.</span><span>ty</span><span>)</span>
        <span>return</span> <span>result</span>
    <span>if</span> <span>isinstance</span><span>(</span><span>expr</span><span>,</span> <span>Int</span><span>):</span>
        <span>unify_j</span><span>(</span><span>result</span><span>,</span> <span>IntType</span><span>)</span>
        <span>return</span> <span>result</span>
    <span>if</span> <span>isinstance</span><span>(</span><span>expr</span><span>,</span> <span>Function</span><span>):</span>
        <span>arg_tyvar</span> <span>=</span> <span>fresh_tyvar</span><span>(</span><span>&#34;a&#34;</span><span>)</span>
        <span>assert</span> <span>isinstance</span><span>(</span><span>expr</span><span>.</span><span>arg</span><span>,</span> <span>Var</span><span>)</span>
        <span>body_ctx</span> <span>=</span> <span>{</span><span>**</span><span>ctx</span><span>,</span> <span>expr</span><span>.</span><span>arg</span><span>.</span><span>name</span><span>:</span> <span>Forall</span><span>([],</span> <span>arg_tyvar</span><span>)}</span>
        <span>body_ty</span> <span>=</span> <span>infer_j</span><span>(</span><span>expr</span><span>.</span><span>body</span><span>,</span> <span>body_ctx</span><span>)</span>
        <span>unify_j</span><span>(</span><span>result</span><span>,</span> <span>TyCon</span><span>(</span><span>&#34;-&gt;&#34;</span><span>,</span> <span>[</span><span>arg_tyvar</span><span>,</span> <span>body_ty</span><span>]))</span>
        <span>return</span> <span>result</span>
    <span>if</span> <span>isinstance</span><span>(</span><span>expr</span><span>,</span> <span>Apply</span><span>):</span>
        <span>func_ty</span> <span>=</span> <span>infer_j</span><span>(</span><span>expr</span><span>.</span><span>func</span><span>,</span> <span>ctx</span><span>)</span>
        <span>arg_ty</span> <span>=</span> <span>infer_j</span><span>(</span><span>expr</span><span>.</span><span>arg</span><span>,</span> <span>ctx</span><span>)</span>
        <span>unify_j</span><span>(</span><span>func_ty</span><span>,</span> <span>TyCon</span><span>(</span><span>&#34;-&gt;&#34;</span><span>,</span> <span>[</span><span>arg_ty</span><span>,</span> <span>result</span><span>]))</span>
        <span>return</span> <span>result</span>
    <span>if</span> <span>isinstance</span><span>(</span><span>expr</span><span>,</span> <span>Where</span><span>):</span>
        <span>name</span><span>,</span> <span>value</span><span>,</span> <span>body</span> <span>=</span> <span>expr</span><span>.</span><span>binding</span><span>.</span><span>name</span><span>.</span><span>name</span><span>,</span> <span>expr</span><span>.</span><span>binding</span><span>.</span><span>value</span><span>,</span> <span>expr</span><span>.</span><span>body</span>
        <span>value_ty</span> <span>=</span> <span>infer_j</span><span>(</span><span>value</span><span>,</span> <span>ctx</span><span>)</span>
        <span>body_ty</span> <span>=</span> <span>infer_j</span><span>(</span><span>body</span><span>,</span> <span>{</span><span>**</span><span>ctx</span><span>,</span> <span>name</span><span>:</span> <span>Forall</span><span>([],</span> <span>value_ty</span><span>)})</span>
        <span>unify_j</span><span>(</span><span>result</span><span>,</span> <span>body_ty</span><span>)</span>
        <span>return</span> <span>result</span>
    <span>raise</span> <span>TypeError</span><span>(</span><span>f</span><span>&#34;Unexpected type </span><span>{</span><span>type</span><span>(</span><span>expr</span><span>)</span><span>}</span><span>&#34;</span><span>)</span>
</code></pre></div></div>

<p>There you have it. Algorithm J: looks like W, but simpler and (apparently)
faster.</p>

<h2 id="let-polymorphism">Let polymorphism</h2>

<p>We alluded to polymorphism earlier because it was already baked into our
implementation (and we had to scratch it out temporarily to write the post),
and we’re coming back to it now.</p>

<p>Hindley Milner types also include a <code>forall</code> quantifier that allows for some
amount of polymorphism. Consider the function <code>id = x -&gt; x</code>. The type of <code>id</code>
is <code>forall &#39;a. &#39;a -&gt; &#39;a</code>. This is kind of like a lambda for type variables. The
<code>forall</code> construct binds type variables like normal lambdas bind normal
variables. Some of the literature calls these <em>type schemes</em>.</p>

<p>In order to make inference for polymorphism decidable (I think), you have to
pick some limited set of points in the concrete syntax to generalize types. The
usual place is in <code>let</code> bindings. This is why all <code>let</code>-bound program variables
(including top-level definitions) are associated with <em>type schemes</em> in the
context. I think you could also do it with a <code>generalize</code> or <code>template</code> keyword
or something, but people tend to use <code>let</code> as the signal.</p>

<p>The change to the inference algorithm is as follows:</p>

<ul>
  <li>if you see a variable <code>e</code>,
    <ul>
      <li>look up the scheme of <code>e</code> in the environment</li>
      <li><strong>instantiate the scheme and return it</strong></li>
    </ul>
  </li>
  <li>if you see a let binding <code>let n = v in b</code> (called “where” in scrapscript) <code>e</code>,
    <ul>
      <li>infer the type of the value <code>v</code></li>
      <li><strong>generalize <code>type(v)</code> to get a scheme <code>s</code></strong></li>
      <li>add <code>n: s</code> to the environment while type checking the body <code>b</code></li>
      <li>return <code>type(b)</code></li>
    </ul>
  </li>
</ul>

<p>Note that even though we generalize the type to store it into the environment,
we <em>still return a monotype</em>.</p>

<p>Generalize is kind of like the opposite of instantiate. It takes a type and
turns it into a scheme using its free variables:</p>

<div><div><pre><code><span>def</span> <span>generalize</span><span>(</span><span>ty</span><span>:</span> <span>MonoType</span><span>,</span> <span>ctx</span><span>:</span> <span>Context</span><span>)</span> <span>-&gt;</span> <span>Forall</span><span>:</span> <span>...</span>
</code></pre></div></div>

<p>For example, generalizing <code>&#39;a</code> would be <code>forall &#39;a. &#39;a</code>. Or generalizing <code>&#39;a
list -&gt; int</code> would result in <code>forall &#39;a. &#39;a list -&gt; int</code> (the type scheme of
the list <code>length</code> function).</p>

<p>You can’t directly use a type scheme, a <code>Forall</code>, in a type expression.
Instead, you have to <em>instantiate</em> (similar to “call” or “apply”) the <code>Forall</code>.
This replaces the bound variables (“parameters”) with new variables in the
right hand side—in the type. For example, instantiating <code>forall &#39;a. &#39;a -&gt; &#39;a</code>
might give you <code>&#39;t123 -&gt; &#39;t123</code>, where <code>&#39;t123</code> is a fresh variable.</p>

<div><div><pre><code><span>def</span> <span>instantiate</span><span>(</span><span>scheme</span><span>:</span> <span>Forall</span><span>)</span> <span>-&gt;</span> <span>MonoType</span><span>:</span> <span>...</span>
</code></pre></div></div>

<p>Now, to integrate let polymorphism into our Algorithm J inference engine, we
need only change two lines (marked “changed!”):</p>

<div><div><pre><code><span>def</span> <span>infer_j</span><span>(</span><span>expr</span><span>:</span> <span>Object</span><span>,</span> <span>ctx</span><span>:</span> <span>Context</span><span>)</span> <span>-&gt;</span> <span>MonoType</span><span>:</span>
    <span># ...
</span>    <span>if</span> <span>isinstance</span><span>(</span><span>expr</span><span>,</span> <span>Var</span><span>):</span>
        <span>scheme</span> <span>=</span> <span>ctx</span><span>.</span><span>get</span><span>(</span><span>expr</span><span>.</span><span>name</span><span>)</span>
        <span>if</span> <span>scheme</span> <span>is</span> <span>None</span><span>:</span>
            <span>raise</span> <span>TypeError</span><span>(</span><span>f</span><span>&#34;Unbound variable </span><span>{</span><span>expr</span><span>.</span><span>name</span><span>}</span><span>&#34;</span><span>)</span>
        <span>unify_j</span><span>(</span><span>result</span><span>,</span> <span>instantiate</span><span>(</span><span>scheme</span><span>))</span>  <span># changed!
</span>        <span>return</span> <span>result</span>
    <span>if</span> <span>isinstance</span><span>(</span><span>expr</span><span>,</span> <span>Where</span><span>):</span>
        <span>name</span><span>,</span> <span>value</span><span>,</span> <span>body</span> <span>=</span> <span>expr</span><span>.</span><span>binding</span><span>.</span><span>name</span><span>.</span><span>name</span><span>,</span> <span>expr</span><span>.</span><span>binding</span><span>.</span><span>value</span><span>,</span> <span>expr</span><span>.</span><span>body</span>
        <span>value_ty</span> <span>=</span> <span>infer_j</span><span>(</span><span>value</span><span>,</span> <span>ctx</span><span>)</span>
        <span>value_scheme</span> <span>=</span> <span>generalize</span><span>(</span><span>recursive_find</span><span>(</span><span>value_ty</span><span>),</span> <span>ctx</span><span>)</span>  <span># changed!
</span>        <span>body_ty</span> <span>=</span> <span>infer_j</span><span>(</span><span>body</span><span>,</span> <span>{</span><span>**</span><span>ctx</span><span>,</span> <span>name</span><span>:</span> <span>value_scheme</span><span>})</span>
        <span>unify_j</span><span>(</span><span>result</span><span>,</span> <span>body_ty</span><span>)</span>
        <span>return</span> <span>result</span>
    <span># ...
</span></code></pre></div></div>

<p>Note that due to our union-find implementation, we also need to do this
“recursive find” thing that calls <code>.find()</code> recursively to discover all of the
type variables in the type. Otherwise we might just see <code>&#39;t0</code> as our only free
type variable or something.</p>

<h2 id="algorithm-m">Algorithm M</h2>

<p>Apparently there is a secret third thing that people do, which wasn’t formally
proven until 1998 in a paper called <a href="https://www.classes.cs.uchicago.edu/archive/2007/spring/32001-1/papers/p707-lee.pdf">Proofs about a Folklore Let-Polymorphic Type
Inference Algorithm</a> (PDF) by Lee and Yi. They call it Algorithm M
because it’s a top-down version of Algorithm W (ha ha).</p>

<p>It looks pretty similar to W but there’s a third parameter to the inference
function, which is the monotype that you expect the expression to
have<sup id="fnref:bidirectional" role="doc-noteref"><a href="#fn:bidirectional" rel="footnote">2</a></sup>. We won’t have an implementation here, but you should go
take a look at the paper which does a nice side-by-side of W and M. Reader, if
you would like to contribute a small version of Algorithm M using our data
structures, I would be happy to include it.</p>

<p>This concludes the section on basic HM. I don’t think any in-use language uses
HM like this; they all build on extensions. We have added some of these
extensions to make Scrapscript’s type system more expressive.</p>

<h2 id="extensions-for-scrapscript">Extensions for Scrapscript</h2>

<h3 id="recursion">Recursion</h3>

<p>Another quality of life feature that people tend to want in programming
languages, especially programming languages without loops, is recursion. Right
now our infer function won’t support functions referring to themselves; we
don’t add the function name to the environment when running inference on the
function body.</p>

<p>To add a limited form of recursion, we do the following:</p>

<ul>
  <li>if typing the pattern <code>f = FUNCTION</code> or <code>f = MATCH_FUNCTION</code>,
    <ul>
      <li>then bind <code>f</code> to some new type variable to “tie the knot” in
the context</li>
    </ul>
  </li>
</ul>

<div><div><pre><code><span>def</span> <span>infer_j</span><span>(</span><span>expr</span><span>:</span> <span>Object</span><span>,</span> <span>ctx</span><span>:</span> <span>Context</span><span>)</span> <span>-&gt;</span> <span>MonoType</span><span>:</span>
    <span># ...
</span>    <span>if</span> <span>isinstance</span><span>(</span><span>expr</span><span>,</span> <span>Where</span><span>):</span>
        <span>name</span><span>,</span> <span>value</span><span>,</span> <span>body</span> <span>=</span> <span>expr</span><span>.</span><span>binding</span><span>.</span><span>name</span><span>.</span><span>name</span><span>,</span> <span>expr</span><span>.</span><span>binding</span><span>.</span><span>value</span><span>,</span> <span>expr</span><span>.</span><span>body</span>
        <span>if</span> <span>isinstance</span><span>(</span><span>value</span><span>,</span> <span>Function</span><span>):</span>
            <span># Letrec
</span>            <span>func_ty</span> <span>=</span> <span>fresh_tyvar</span><span>()</span>
            <span>value_ty</span> <span>=</span> <span>infer_j</span><span>(</span><span>value</span><span>,</span> <span>{</span><span>**</span><span>ctx</span><span>,</span> <span>name</span><span>:</span> <span>Forall</span><span>([],</span> <span>func_ty</span><span>)})</span>
        <span>else</span><span>:</span>
            <span># Let
</span>            <span>value_ty</span> <span>=</span> <span>infer_j</span><span>(</span><span>value</span><span>,</span> <span>ctx</span><span>)</span>
        <span># ...
</span></code></pre></div></div>

<p>This is helpful, but it’s not a full solution. OCaml, for example, has <code>let
rec</code>/<code>and</code> to write mutually recursive functions. We don’t have the syntax to
express that in Scrapscript.</p>

<p>In an ideal world, we would have a way to type mutual recursion anyway. I think
this involves identifying call graphs and strongly connected components within
those graphs. Sounds trickier than it’s worth right now<sup id="fnref:cfa" role="doc-noteref"><a href="#fn:cfa" rel="footnote">3</a></sup>.</p>

<h3 id="more-datatypes">More datatypes</h3>

<p>Scrapscript has lists. While Scrapscript allows for heterogeneous lists
(a list can contain elements of different types at the same time), our type
system will not (at least to start). In order to type these lists, we need to
constrain all the list elements to be the same type when we see a list
constructor.</p>

<div><div><pre><code><span>def</span> <span>infer_j</span><span>(</span><span>expr</span><span>:</span> <span>Object</span><span>,</span> <span>ctx</span><span>:</span> <span>Context</span><span>)</span> <span>-&gt;</span> <span>MonoType</span><span>:</span>
    <span># ...
</span>    <span>if</span> <span>isinstance</span><span>(</span><span>expr</span><span>,</span> <span>List</span><span>):</span>
        <span>list_item_ty</span> <span>=</span> <span>fresh_tyvar</span><span>()</span>
        <span>for</span> <span>item</span> <span>in</span> <span>expr</span><span>.</span><span>items</span><span>:</span>
            <span>item_ty</span> <span>=</span> <span>infer_j</span><span>(</span><span>item</span><span>,</span> <span>ctx</span><span>)</span>
            <span>unify_j</span><span>(</span><span>list_item_ty</span><span>,</span> <span>item_ty</span><span>)</span>
        <span>return</span> <span>TyCon</span><span>(</span><span>&#34;list&#34;</span><span>,</span> <span>[</span><span>list_item_ty</span><span>])</span>
</code></pre></div></div>

<p>This means that an empty list will have type <code>&#39;a list</code>. And, interestingly
enough, a <code>let</code>-bound empty list will have type scheme <code>forall &#39;a. &#39;a list</code>.
Note that this is only legal if your lists are immutable, as they are in
Scrapscript.</p>

<h3 id="pattern-matching">Pattern matching</h3>

<p>What’s the type of a match case pattern? Until a couple of days ago, I didn’t
know. Turns out, it’s the type that it looks like it should be, as long as you
bind all the variables in the pattern to fresh type variables.</p>

<p>For example, the type of <code>| [x, y] -&gt; x</code> is <code>&#39;a list -&gt; &#39;a</code> because the list
constructor tells us this should be a list. But in order to avoid raising
an <code>Unbound variable</code> exception when we see <code>x</code> in the pattern, we have to
prefill the context with <code>x</code> bound to a fresh type variable.</p>

<p>Similarly, the type of <code>| [x, 5] -&gt; x</code> is <code>int list -&gt; int</code> because the <code>5</code>
literal makes the whole thing an <code>int list</code>. This means that we gain additional
type information about <code>x</code> too!</p>

<p>Let’s look at the Python code for inferring a singular match case:</p>

<div><div><pre><code><span>def</span> <span>infer_j</span><span>(</span><span>expr</span><span>:</span> <span>Object</span><span>,</span> <span>ctx</span><span>:</span> <span>Context</span><span>)</span> <span>-&gt;</span> <span>MonoType</span><span>:</span>
    <span># ...
</span>    <span>if</span> <span>isinstance</span><span>(</span><span>expr</span><span>,</span> <span>MatchCase</span><span>):</span>
        <span>pattern_ctx</span> <span>=</span> <span>collect_vars_in_pattern</span><span>(</span><span>expr</span><span>.</span><span>pattern</span><span>)</span>
        <span>body_ctx</span> <span>=</span> <span>{</span><span>**</span><span>ctx</span><span>,</span> <span>**</span><span>pattern_ctx</span><span>}</span>
        <span>pattern_ty</span> <span>=</span> <span>infer_j</span><span>(</span><span>expr</span><span>.</span><span>pattern</span><span>,</span> <span>body_ctx</span><span>)</span>
        <span>body_ty</span> <span>=</span> <span>infer_j</span><span>(</span><span>expr</span><span>.</span><span>body</span><span>,</span> <span>body_ctx</span><span>)</span>
        <span>unify_j</span><span>(</span><span>result</span><span>,</span> <span>TyCon</span><span>(</span><span>&#34;-&gt;&#34;</span><span>,</span> <span>ppattern_ty</span><span>,</span> <span>body_ty</span><span>]))</span>
        <span>return</span> <span>result</span>
</code></pre></div></div>

<p>Then for an entire match function, we unify all of the case functions to make
the pattern types line up and the return types line up.</p>

<div><div><pre><code><span>def</span> <span>infer_j</span><span>(</span><span>expr</span><span>:</span> <span>Object</span><span>,</span> <span>ctx</span><span>:</span> <span>Context</span><span>)</span> <span>-&gt;</span> <span>MonoType</span><span>:</span>
    <span># ...
</span>    <span>if</span> <span>isinstance</span><span>(</span><span>expr</span><span>,</span> <span>MatchFunction</span><span>):</span>
        <span>for</span> <span>case</span> <span>in</span> <span>expr</span><span>.</span><span>cases</span><span>:</span>
            <span>case_ty</span> <span>=</span> <span>infer_j</span><span>(</span><span>case</span><span>,</span> <span>ctx</span><span>)</span>
            <span>unify_j</span><span>(</span><span>result</span><span>,</span> <span>case_ty</span><span>)</span>
        <span>return</span> <span>result</span>
</code></pre></div></div>

<p>Similar to typing lists, match patterns have to (for now?) be homogeneous. That
means that the following snippet of code, which is perfectly legal Scrapscript,
wouldn’t fly with our type inference:</p>



<p>It would be nice to support this but I don’t know how right now.</p>

<p>(Also remember to add <code>MatchFunction</code> to the type check in the recursive
<code>let</code>!)</p>

<h3 id="row-polymorphism">Row polymorphism</h3>

<p>Scrapscript has records (kind of like structs) and run-time row polymorphism.
This means that you can have a function that pulls out a field from a record
and any record with that field is a legal argument to the function.</p>

<p>See for example two different looking records (2D point and 3D point):</p>

<div><div><pre><code>get_x left + get_x right
. left  = { x = 1, y = 2 }
. right = { x = 1, y = 2, z = 3 }
. get_x = | { x = x, ... } -&gt; x
</code></pre></div></div>

<p>Hindley Milner doesn’t come with support for this right out of the box. If you
add support for records, then you end up with a more rigid system: the records
have to have the same number of fields and same names of fields and same types
of fields. This is safe but overly restrictive.</p>

<p>I think it’s possible to “easily” add row polymorphism but we haven’t done it
yet. Finding a simple, distilled version of the ideas in the papers has so far
been elusive.</p>

<!--
RowSelect, RowExtend, RowRestrict
-->

<p>We’re currently reading:</p>

<ul>
  <li><a href="https://web.cecs.pdx.edu/~mpj/pubs/96-3.pdf">A Polymorphic Type System for Extensible Records and Variants</a> (PDF, 1996)</li>
  <li><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/scopedlabels.pdf">Extensible records with scoped labels</a> (PDF, 2005)</li>
  <li><a href="https://dl.acm.org/doi/pdf/10.1145/1159803.1159836">Extensible Programming with First-Class Cases</a> (PDF, 2006)</li>
  <li><a href="https://dl.acm.org/doi/10.1145/2951913.2951928">Set-Theoretic Types for Polymorphic Variants</a> (2016)</li>
  <li><a href="https://arxiv.org/pdf/1812.11665">Generic programming in OCaml</a> (PDF, 2018)</li>
  <li><a href="https://dl.acm.org/doi/pdf/10.1145/3290325">Abstracting extensible data types: or, rows by any other name</a> (PDF, 2019)
    <ul>
      <li>Incredible paper title</li>
    </ul>
  </li>
  <li><a href="https://dl.acm.org/doi/abs/10.1145/3622836">Structural Subtyping as Parametric Polymorphism</a> (PDF, 2023)</li>
  <li><a href="https://osa1.net/posts/2023-01-23-fast-polymorphic-record-access.html">Fast polymorphic record access</a> (2023)</li>
</ul>

<p>Please recommend additional papers, blog posts, and implementations.</p>

<!--
### Subtyping?

TODO: Mention something about algebraic subtyping

"semi-unification"; "inequations"
-->

<h3 id="defer-dynamic">Defer-dynamic</h3>

<p>Scrapscript is designed to do significantly more than its current HM-based type
system allows. Type inference is opt-in, so it’s possible—encouraged,
even—to run in dynamic mode. But it would be really cool to be able to use
type inference in the compiler to optimize the code when possible, and leave in
run-time checks when not possible. This probably involves inserting type-check
nodes into the AST when unification fails. Something like <code>CheckInt</code> which has
type <code>forall &#39;a. &#39;a -&gt; int</code> (but aborts the program if given a non-integer at
run-time).</p>

<h3 id="variants">Variants</h3>

<p>Scrapscript supports variants or tags similar to OCaml’s notion of <a href="https://ocaml.org/manual/5.2/polyvariant.html">polymorphic
variants</a>. We don’t have any
encoding in the type system for these right now.</p>

<p>We’re currently reading:</p>

<ul>
  <li><a href="https://caml.inria.fr/pub/papers/garrigue-polymorphic_variants-ml98.pdf">Programming with Polymorphic Variants</a> (PDF, 1998)</li>
  <li><a href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol263-ecoop2023/LIPIcs.ECOOP.2023.17/LIPIcs.ECOOP.2023.17.pdf">Restrictable Variants: A Simple and Practical Alternative to Extensible Variants</a> (PDF, 2003)</li>
</ul>

<p>Please recommend additional papers, blog posts, and implementations.</p>

<h3 id="canonicalization-or-minification-of-type-variables">Canonicalization or minification of type variables</h3>

<p>When presenting a type to the programmer, it’s not useful to spew out a bunch
of generated type variable names like <code>&#39;t123467</code> in errors. For this reason, we
also support minimizing types to make them more presentable.</p>

<div><div><pre><code><span>def</span> <span>minimize</span><span>(</span><span>ty</span><span>:</span> <span>MonoType</span><span>)</span> <span>-&gt;</span> <span>MonoType</span><span>:</span>
    <span># Fingers crossed an expression that we&#39;re presenting to the programmer
</span>    <span># doesn&#39;t have more than 26 distinct type variables...
</span>    <span>letters</span> <span>=</span> <span>iter</span><span>(</span><span>&#34;abcdefghijklmnopqrstuvwxyz&#34;</span><span>)</span>
    <span>free</span> <span>=</span> <span>ftv_ty</span><span>(</span><span>ty</span><span>)</span>
    <span>subst</span> <span>=</span> <span>{</span><span>ftv</span><span>:</span> <span>TyVar</span><span>(</span><span>next</span><span>(</span><span>letters</span><span>))</span> <span>for</span> <span>ftv</span> <span>in</span> <span>sorted</span><span>(</span><span>free</span><span>)}</span>
    <span>return</span> <span>apply_ty</span><span>(</span><span>ty</span><span>,</span> <span>subst</span><span>)</span>
</code></pre></div></div>

<h3 id="type-carrying-code">Type-carrying code</h3>

<p>Can we make hashes of types? Something like proof-carrying code? TODO: think
more about this…</p>

<h2 id="conclusion">Conclusion</h2>

<p>Thanks for getting this far. There’s a lot of new words and some historical
baggage in terminology, notation, and general vibes that can make things
confusing to the casual reader (like myself).</p>

<p>Take a look at our <a href="https://github.com/tekknolagi/scrapscript/pull/195">PR to add HM inference to
Scrapscript</a>. We use
Algorithm J. For Algorithm W and associated machinery, check out <a href="https://github.com/tekknolagi/scrapscript/blob/b8bc5fb24a97c997f3f0228b243d9a739409feb9/lc.py">this old
commit on an unused
branch</a>.
It has a bunch of tests that hopefully make things clearer.</p>

<h2 id="acknowledgements">Acknowledgements</h2>

<p>Thank you to <a href="https://k-monk.org/">River Dillon Keefer</a> for co-authoring the
code and this post with me at <a href="https://www.recurse.com/scout/click?t=e8845120d0b98bbc3341fa6fa69539bb">Recurse Center</a>. Thank you to the following
fine folks who reviewed the post before it went out:</p>

<ul>
  <li><a href="https://burakemir.ch/">Burak Emir</a></li>
  <li><a href="https://cfallin.org/">Chris Fallin</a></li>
  <li><a href="https://github.com/iamcdonald">Iain McDonald</a></li>
  <li><a href="https://osa1.net/">Sinan</a></li>
</ul>

<h2 id="see-also">See also</h2>

<ul>
  <li><a href="https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.28">Static Basic Block Versioning</a></li>
  <li>CFA / <a href="https://dl.acm.org/doi/abs/10.1145/3591260">Lambda set defunctionalization</a> (PDF)
    <ul>
      <li><a href="https://github.com/rdck/compiler">River’s STLC</a></li>
    </ul>
  </li>
  <li><a href="https://www.reddit.com/r/ProgrammingLanguages/comments/ijij9o/beyond_hindleymilner_but_keeping_principal_types/">Beyond Hindley-Milner (but Keeping Principal Types)</a></li>
  <li><a href="https://okmij.org/ftp/ML/generalization.html">More efficient generalization</a></li>
  <li>Better error messages with <a href="https://dl.acm.org/doi/10.1145/512644.512648">Wand 1986</a> (PDF)</li>
  <li>Thanks to <a href="https://github.com/bynect/algorithm-w">bynect’s implementation</a> of
Algorithm W, which we used as inspiration.</li>
</ul>

<!-- Feedback:

1)

- AFAICS the section on generalization doesn't mention the issues with
  variables escaping their binder's scope. Maybe fine for the purposes of this
  blog post.

-->


        </div></div>
  </body>
</html>
