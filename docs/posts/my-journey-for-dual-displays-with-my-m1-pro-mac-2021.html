<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.derekseaman.com/2021/11/my-journey-for-dual-displays-with-my-m1-pro-mac.html">Original</a>
    <h1>My journey for dual displays with my M1 Pro Mac (2021)</h1>
    
    <div id="readability-page-1" class="page"><article><h2 id="hytradboi">HYTRADBOI</h2><p>I just published the <a href="https://www.hytradboi.com/#schedule">schedule</a> and you can now <a href="https://www.hytradboi.com/#tickets">buy tickets</a>!</p><h2 id="imp">Imp</h2><p>In <a href="https://www.scattered-thoughts.net/#imp_v2">imp v2</a>, the database was accessible as a value. You could write code that described a transaction and then use a keyboard shortcut in the editor to apply it to the database (<a href="https://twitter.com/sc13ts/status/1481432895105363973">demo</a>). These transactions formed a crdt, so you could make changes to offline copies of the database on different devices and merge them later. The database itself was schemaless and <a href="https://youtu.be/2V1FtfBDsLU?t=2328">self-describing</a> but the language allowed building up gradually typed views over the database.</p><p>So far so good. But where does the code go? I had just sort of assumed that I would figure out a way to insert code as a value in the database, but nothing I came up with felt satisfying. The problem is that the code would have to be stored unevaluated, but this led to all sorts of questions about evaluation order and environment that were not answered by the language itself. Tacking those on after the fact felt clumsy.</p><p>After <a href="https://www.scattered-thoughts.net/log/0020#milestones">taking a step back</a> and thinking about the problem from scratch I had an epiphany - why is there even a database? If you have a declarative language which can describe data and computation, why use that to compute an imperative action to apply to a totally different system for describing the same data. This is implementation driven thinking.</p><p>Let&#39;s just mutate the source code instead.</p><p>This totally solves the question of evaluation semantics, because it&#39;s just the same old code. And it means both data and code can live together in a single file with a single textual representation.</p><p>The only hard question is how to describe applying a mutation to a program.</p><p>I decided to start out easy with a simple datalog implementation. Right now I have a very basic interpreter and some cli tools. The history of the program lives in a sqlite database. You can use the cli tools to spit out the current version of the program into a text file, edit it in a text editor and then commit the diff back into the database.</p><pre><code><span>&gt; zig build run -- checkout tmp/db1 tmp/code1
</span><span>
</span><span>&gt; cat tmp/code1                              
</span><span>#2280651848495541
</span><span>parent(&#34;Bob&#34;, &#34;Eve&#34;).
</span><span>
</span><span>#3378495017200132
</span><span>ancestor(x, z) &lt;-
</span><span>  parent(x, y),
</span><span>  ancestor(y, z).
</span><span>
</span><span>#3531648068531767
</span><span>ancestor(x, y) &lt;-
</span><span>  parent(x, y).
</span><span>
</span><span>#4337023847553130
</span><span>parent(&#34;Alice&#34;, &#34;Bob&#34;).
</span><span>
</span><span>&gt; cat &gt; tmp/code1                            
</span><span>#2280651848495541
</span><span>parent(&#34;Bob&#34;, &#34;Charlie&#34;).
</span><span>
</span><span>parent(&#34;Charlie&#34;, &#34;Eve&#34;).
</span><span>
</span><span>#3378495017200132
</span><span>ancestor(x, z) &lt;-
</span><span>  parent(x, y),
</span><span>  ancestor(y, z).
</span><span>
</span><span>#3531648068531767
</span><span>ancestor(x, y) &lt;-
</span><span>  parent(x, y).
</span><span>
</span><span>#4337023847553130
</span><span>parent(&#34;Alice&#34;, &#34;Bob&#34;).
</span><span>
</span><span>&gt; zig build run -- checkin tmp/db1 tmp/code1 
</span><span>
</span><span>&gt; cat tmp/code1                              
</span><span>#2280651848495541
</span><span>parent(&#34;Bob&#34;, &#34;Charlie&#34;).
</span><span>
</span><span>#3378495017200132
</span><span>ancestor(x, z) &lt;-
</span><span>  parent(x, y),
</span><span>  ancestor(y, z).
</span><span>
</span><span>#3531648068531767
</span><span>ancestor(x, y) &lt;-
</span><span>  parent(x, y).
</span><span>
</span><span>#3610246625719134
</span><span>parent(&#34;Charlie&#34;, &#34;Eve&#34;).
</span><span>
</span><span>#4337023847553130
</span><span>parent(&#34;Alice&#34;, &#34;Bob&#34;).
</span><span>
</span><span>&gt; zig build run -- run tmp/db1               
</span><span>ancestor(&#34;Alice&#34;, &#34;Bob&#34;).
</span><span>ancestor(&#34;Alice&#34;, &#34;Charlie&#34;).
</span><span>ancestor(&#34;Alice&#34;, &#34;Eve&#34;).
</span><span>ancestor(&#34;Bob&#34;, &#34;Charlie&#34;).
</span><span>ancestor(&#34;Bob&#34;, &#34;Eve&#34;).
</span><span>ancestor(&#34;Charlie&#34;, &#34;Eve&#34;).
</span><span>parent(&#34;Alice&#34;, &#34;Bob&#34;).
</span><span>parent(&#34;Bob&#34;, &#34;Charlie&#34;).
</span><span>parent(&#34;Charlie&#34;, &#34;Eve&#34;).
</span></code></pre><p>You can also make multiple copies of a database, edit each copy and then merge the changes back together. Each rule get assigned a random id when it&#39;s first seen. The programmer never has to type these themselves, only avoid deleting them when editing code. When merging changes these rules are used together with causal information to detect concurrent edits of the same rule.</p><pre><code><span>&gt; cp tmp/db1 tmp/db2                                                        
</span><span>
</span><span>&gt; cat &gt; tmp/code1                                                           
</span><span>#2280651848495541
</span><span>parent(&#34;Bob&#34;, &#34;Charlie&#34;).
</span><span>
</span><span>#3378495017200132
</span><span>ancestor(x, z) &lt;-
</span><span>  parent(x, y),
</span><span>  ancestor(y, z).
</span><span>
</span><span>#3531648068531767
</span><span>ancestor(x, y) &lt;-
</span><span>  parent(x, y).
</span><span>
</span><span>#3610246625719134
</span><span>parent(&#34;Charlie&#34;, &#34;Eve&#34;).
</span><span>
</span><span>#4337023847553130
</span><span>parent(&#34;Alice&#34;, &#34;Qube&#34;).
</span><span>
</span><span>
</span><span>&gt; cat &gt; tmp/code2                                                           
</span><span>#2280651848495541
</span><span>parent(&#34;Bob&#34;, &#34;Charlie&#34;).
</span><span>
</span><span>#3378495017200132
</span><span>ancestor(x, z) &lt;-
</span><span>  parent(x, y),
</span><span>  ancestor(y, z).
</span><span>
</span><span>#3531648068531767
</span><span>ancestor(x, y) &lt;-
</span><span>  parent(x, y).
</span><span>
</span><span>#3610246625719134
</span><span>parent(&#34;Charlie&#34;, &#34;Eve&#34;).
</span><span>
</span><span>#4337023847553130
</span><span>parent(&#34;Alice&#34;, &#34;Zed&#34;).
</span><span>
</span><span>&gt; zig build run -- checkin tmp/db1 tmp/code1                                
</span><span>
</span><span>&gt; zig build run -- checkin tmp/db2 tmp/code2                                
</span><span>
</span><span>&gt; zig build run -- pull tmp/db1 tmp/db2                                     
</span><span>
</span><span>&gt; zig build run -- run tmp/db1                                              
</span><span>WARNING: Conflicting definitions for id 4337023847553130.
</span><span>
</span><span>First rule:
</span><span>#4337023847553130
</span><span>parent(&#34;Alice&#34;, &#34;Zed&#34;).
</span><span>
</span><span>Second rule:
</span><span>#4337023847553130
</span><span>parent(&#34;Alice&#34;, &#34;Qube&#34;).
</span><span>
</span><span>ancestor(&#34;Alice&#34;, &#34;Qube&#34;).
</span><span>ancestor(&#34;Alice&#34;, &#34;Zed&#34;).
</span><span>ancestor(&#34;Bob&#34;, &#34;Charlie&#34;).
</span><span>ancestor(&#34;Bob&#34;, &#34;Eve&#34;).
</span><span>ancestor(&#34;Charlie&#34;, &#34;Eve&#34;).
</span><span>parent(&#34;Alice&#34;, &#34;Qube&#34;).
</span><span>parent(&#34;Alice&#34;, &#34;Zed&#34;).
</span><span>parent(&#34;Bob&#34;, &#34;Charlie&#34;).
</span><span>parent(&#34;Charlie&#34;, &#34;Eve&#34;).
</span></code></pre><p>With the cli tools alone this is a horrible workflow but with a little editor support &#39;checkin and run&#39; could be a single keypress.</p><p>For any reasonable size database converting the entire thing into text in a single file is probably not gonna fly either, so I imagine the workflow would have to involve picking subsets of the database to checkout and edit. The <a href="https://www.unisonweb.org/">unison</a> folks have spent a lot of time thinking about this and have what looks like a reasonable developer experience.</p><h2 id="recordings">Recordings</h2><p>For one week I recorded all the time I spent coding. I can&#39;t share these because I also looked at email etc while recording but they&#39;re useful for checking where my time goes.</p><p>For the toy datalog implementation, for example, it looked like this:</p><pre><code><span>40m parser
</span><span>27m parser tests and debugging
</span><span>  formatting these tests was time consuming and I deleted them later, so mostly a waste of time - would have been better off just getting to end-to-end tests quicker
</span><span>32m planner
</span><span>29m planner tests and debugging
</span><span>  switched to tests in a separate file - less time formatting
</span><span>  but still manually edited the tests instead of adding an automatic rewrite
</span><span>  couldn&#39;t remember @embedFile, spent 3m looking it up because when it wasn&#39;t under the name I expected I checked the zig issues to see if it had been removed - should have just read the names of all the builtin functions first
</span><span>30m interpreter
</span><span>23m interpreter test setup
</span><span>  mostly just mucking around with formatting and trimming whitespace from the tests
</span><span>10m debugging a segfault caused by self-assignment
</span><span>10m being confused about sort order
</span><span>  the rows in the test output weren&#39;t printing in sorted order
</span><span>  took me a while to realize that it was because in my generic comparison function I copied over from imp v2 I compare slices by length before contents
</span><span>  this is fine for internal data-structures, but not nice for user-visible output
</span></code></pre><p>First thing I noticed is that I spent a bunch of time writing tests that I later deleted. I would have been better off writing the whole thing up-front and just doing end-to-end tests.</p><p>I also spent a lot of time, maybe 30-50m total, just on formatting objects. Makes me appreciate <a href="https://github.com/edn-format/edn">edn</a> more. The existing formatting machinery in zig has many flaws and is due to be overhauled at some point before 1.0. In the meantime I&#39;ve been copy-pasting my own hacks between several projects without ever cleaning up. I could probably save a lot of time in future by turning those hacks into something sensible.</p><p>The segfault was due to a nasty cluster of footguns in the current version of zig - <a href="https://github.com/ziglang/zig/issues/3696">1</a>, <a href="https://github.com/ziglang/zig/issues/6216">2</a>, <a href="https://github.com/ziglang/zig/issues/5973">3</a>. All involve pointer aliasing that is not obvious when reading the code. I also ran into <a href="https://github.com/ziglang/zig/issues/6043">#6043</a> at the same time and it took me a while to realize I had two separate bugs.</p><h2 id="books">Books</h2><p><a href="https://www.goodreads.com/book/show/1291973.The_Real_World_of_Technology">The real world of technology</a>. The notion of <a href="https://aworkinglibrary.com/writing/prescriptive-technologies">holistic vs prescriptive technologies</a> is useful. Much of the rest of the book discusses replacement of various holistic technologies by prescriptive technologies over the last century, and how this ties in with globalization and the transfer of many government functions to private companies.</p><blockquote><p>It is characteristic of prescriptive technologies that they require external management, control, and planning. They reduce workers&#39; skill and autonomy.</p></blockquote><blockquote><p>What the Luddites and other groups of the period clearly perceived was the difference between work-related and control-related technologies.</p></blockquote><blockquote><p>In order to operate successfully, the industrial production technologies require permanent transportation and distribution structures. In all countries the public sphere has supplied these infrastructures and has adjusted itself accordingly. Arranging to provide such infrastructures has become a normal and legitimate function of all governments.</p></blockquote><blockquote><p>The political systems in most of today&#39;s real world of technology are not structured to allow public debate and public input at the point of planning technological enterprises of national scope.</p></blockquote><blockquote><p>Public planning for the needs of private industry and for the expansion of technology has gone well beyond the provision of physical infrastructures. There are tax and grant structures, and there is the impact of the needs of technology on the preparation and training of the labour force.</p></blockquote><blockquote><p>The early phase of technology often occurs in a take-it-or-leave-it atmosphere. Users are involved and have a feeling of control that gives them the impression that they are entirely free to accept or reject a particular technology and its products. But when a technology, together with the supporting infrastructures, becomes institutionalized, users often become captive supporters of both the technology and the infrastructures. (At this point, the technology itself may stagnate, improvements may become cosmetic or marginal, and competition becomes ritualized.) In the case of the automobile, the railways are gone - the choice of taking the car or leaving it at home no longer exists.</p></blockquote><blockquote><p>...assumed that the introduction of the sewing machine would result in more sewing - and easier sewing - by those who had always sewn. They would do the work they had always done in an unchanged setting. Reality turned out to be quite different. With the help of the new machines, sewing came to be done in a factory setting, in sweatshops that exploited the labour of women and particularly the labour of women immigrants. Sewing machines became, in fact, synonymous not with liberation but with exploitation.</p></blockquote><p><a href="https://www.goodreads.com/book/show/1752380.Changing_Minds">Changing minds</a>. An older book in the same vein as <a href="https://www.goodreads.com/book/show/703532.Mindstorms">Mindstorms</a>. 20 years later, computers have failed to transform education. Hard to say whether the vision is just wrong or just incompatible with the current education system, but either way I wasn&#39;t excited by it.</p><p><a href="https://www.goodreads.com/book/show/58885974-the-essence-of-software">The essence of software</a>. Describes a design/modeling methodology for software. It&#39;s far from fleshed out, but it is the first methodology I&#39;ve come across that actually felt like it would help me design better software. You can see an early case study in the design of gitless (<a href="https://spderosso.github.io/oopsla16.pdf">paper</a>, <a href="https://gitless.com/">website</a>) - tackling hard problems and actually producing results lends it a lot of credibility in my mind. I think I will actually try to apply this.</p><h2 id="papers">Papers</h2><p><a href="https://arxiv.org/pdf/2110.08993.pdf">Typed Image-based Programming with Structure Editing</a>. Dealing with type/schema migration by recording changes to types in a structural editor and using an OT-like process to reconcile conflicts. I&#39;m not sold on this approach - it spends a lot of complexity dealing with changes to anonymous product types, but given that you&#39;re editing in a structural editor already there is no need for anonymous product types - just insert ids under the hood. But I think the paper is still valuable for elucidating the problem. Version control of code and schema migration of persistent data are clearly two facets of the same problem but our current tools treat them as entirely separate domains.</p><h2 id="fosdem">FOSDEM</h2><p>My favorite talks from FOSDEM 2022:</p><ul><li><a href="https://fosdem.org/2022/schedule/event/langdesert/">Designing a programming language for the desert</a>. Deliberately designing a language that doesn&#39;t need to eat the world to be useful, and minimizes the long-term maintenance burden.</li><li><a href="https://fosdem.org/2022/schedule/event/lg_qbe/">Introduction to qbe</a>. Goal: 70% of the performance of LLVM in 10% of the code. Current state: 25-75% of the runtime performance and 380% the compile performance in 0.1% of the code. Can boostrap itself in a few seconds - very different from the nightmare that is bootstrapping LLVM.</li><li><a href="https://fosdem.org/2022/schedule/event/matrix_state_of_the_union/">The Matrix State of the Union</a>. Matrix finally has threads!!! And some other news :)</li><li><a href="https://fosdem.org/2022/schedule/event/relational_model_dev/">The relational model in the modern development age</a>. Schema migrations suck. The state of the art has barely changed since the first SQL databases. Vitess has put a ton of effort into fixing this.</li></ul><h2 id="introspecting-async">Introspecting async</h2><p>I&#39;m still thinking about <a href="https://vimeo.com/handmadeseattle/cute-framework-devilish-details#t=1660s">this async gui pattern</a>.</p><p>If I convert code that uses explicit state machines to use async/await then it&#39;s easier to read, easier to write, and I can use defer to manage lifetimes. But I can no longer just print out the state, or make debugging tools that tell me eg which users have requests that are currently waiting on database io. Are there any implementations of async that let you inspect the closed-over state of awaited futures/promises/frames?</p></article></div>
  </body>
</html>
