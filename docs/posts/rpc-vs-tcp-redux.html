<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://systemsapproach.substack.com/p/rpc-vs-tcp-redux">Original</a>
    <h1>RPC vs. TCP (Redux)</h1>
    
    <div id="readability-page-1" class="page"><div><div><article><div class=""><div><div dir="auto"><p>We’ve given serious thought to the question of whether there is an entire book to be written about RPC from the perspective of networking. We have been writing about the possibilities for a request/response transport paradigm (as an alternative to TCP’s reliable byte stream) since the 1990s, and yet we seem to keep finding new angles to approach the problem. We’re not sure yet if there is a whole book in this topic, but we certainly have enough material for this week’s newsletter and probably more to come.</p><p><span>Reposts of our recent </span><a href="https://systemsapproach.substack.com/p/its-tcp-vs-rpc-all-over-again" rel="">RPC vs TCP</a><span> article generated considerable commentary (for example, see </span><a href="https://discuss.systems/@SystemsAppr/109899233965152258" rel="">Mastodon</a><span>), and some of the feedback was quite helpful. (Some comments on other sites reminded us why we don’t spend a lot of time reading comment threads.) The considerable interest in the topic convinced me that a follow-up post would be worth doing. I have three observations, which for your reading convenience, are filtered to exclude all </span><em>ad hominem </em><span>flamethrowing.</span></p><p><span>The first observation is that there has long been a “parallel universe” in which the High Performance Computing (HPC) community has created their own networking substrate—from communication hardware (</span><a href="https://en.wikipedia.org/wiki/InfiniBand" rel="">InfiniBand</a><span>) to end-to-end software (</span><a href="https://www.open-mpi.org/" rel="">MPI</a><span>,  </span><a href="https://dl.acm.org/doi/10.1145/139669.140382" rel="">Active Messages</a><span>)—without being overly concerned about broad interoperability (which is the hallmark of Internet technology). The goal is simple: maximize throughput and minimize latency, under the simplifying assumption that you have full control over both sides of the communication. This approach started on purpose-built multiprocessors, but as those architectures gave way to cloud-based commodity hardware, solutions like RDMA (Remote DMA) over Converged Ethernet (</span><a href="https://en.wikipedia.org/wiki/RDMA_over_Converged_Ethernet" rel="">RoCE</a><span>) started to get traction.</span></p><p>RDMA gives the sender (caller) the ability to directly address memory on the receiver (callee). This requires tight coupling between the two parties, as would be the case in a parallel program, but is less generally applicable when building distributed systems since (a) someone else is likely responsible for the service you’re calling, and (b) you can’t be sure if that service runs on the same server, another server in the same datacenter, or in a datacenter across the country. RDMA was originally included as part of InfiniBand; RoCE is a variant of that idea suitable for running over commodity ethernet. It runs on top of UDP, sacrificing performance (compared to InfiniBand) in return for supporting commodity cloud deployments.</p><p><span>The second observation is that there is a feature of QUIC that I had not appreciated. Christian Huitema pointed out that QUIC can be used without HTTP/3, and as a consequence, could serve as a general-purpose request/reply protocol underpinning </span><em>any</em><span> RPC framework. It is reassuring to see the request/reply protocol decoupled from the application domain. That’s a major step forward, and caused me to wonder if it might be possible to fold some of Homa’s latency optimizations into QUIC, giving </span><a href="https://arxiv.org/abs/2210.00714" rel="">Homa</a><span> an alternative path to wider adoption. But I see two issues that will need to be addressed.</span></p><p><span>The first is that a claimed advantage of QUIC is that it runs in user space, and if that remains its dominant deployment scenario, it negates some of Homa’s latency improvements—those that are due to being kernel-resident. While QUIC can also be implemented in the kernel (for example see the work of </span><a href="https://dl.acm.org/doi/10.1145/3242102.3242106" rel="">Peng Want, et al</a><span>), it’s not clear why retrofitting Homa-inspired techniques into QUIC is an improvement over natively running Homa in the kernel. There’s more to say on this topic, but I’ll save it for my third observation. The second issue centers around Homa’s approach to congestion control, which I consider its main contribution. Debates about congestion control seldom turn out well for the new kid on the block, but QUIC does do a good job of modularizing congestion control (particularly when it runs in user space), and so it may offer a viable deployment path.</span></p><p><span>Saving the best for last, my third observation is the consequence of an exchange between David Reed and John Ousterhout. David argued that </span><em>“RPC was one big reason for creating UDP as a datagram ‘process addressing’ support layer”</em><span> and that </span><em>“...argument passing and waiting for a return was way too high level for a transport protocol.”</em><span> John’s response was to call out the distinction between </span><em>“RPC transport”</em><span> and things like </span><em>“argument processing </em><span>[that]</span><em> fit pretty naturally at the application level.”</em><span> These two positions are consistent with the overall framing I laid out in my </span><a href="https://systemsapproach.substack.com/p/its-tcp-vs-rpc-all-over-again" rel="">original post</a><span>, and worth a closer look.</span></p><p><span>On the one hand, both the </span><a href="https://web.mit.edu/Saltzer/www/publications/endtoend/endtoend.pdf" rel="">End-to-End Argument</a><span> and </span><a href="https://dl.acm.org/doi/10.1145/99517.99553" rel="">Application-Level Framing (ALF)</a><span>—two stalwart Internet design principles—point to the end-point (with the application process being the ultimate end-point) as knowing best. On the other hand, good system design is always looking for opportunities to carve out common functionality that can be packaged as a general-purpose tool and pushed down into the underlying platform. (The e2e paper acknowledges this tension, albeit from a performance perspective.) Doing so both frees applications from having to reinvent the wheel, and perhaps more importantly, makes sure complex functionality is implemented correctly.</span></p><p>Let’s apply that tradeoff to TCP and RPC. No one would argue that implementing a reliable byte stream service, bundled with a fair congestion control algorithm, should be left to the application. (Unless, of course, the application is real-time multimedia, which is exactly the use case that motivated ALF.) So why is an RPC transport any different? I don’t see how it is: Its complexity is on par with TCP’s, ensuring (enforcing) well-behaved congestion control is important, and the set of applications it supports is substantial. It’s a nearly perfect example of an end-to-end networking substrate that your OS should provide. Of course an RPC transport can always be implemented on top of UDP, but the same is true of TCP.</p><p><span>If we weren’t assuming a monolithic kernel, we might be able to have a different discussion. For example, an </span><a href="https://en.wikipedia.org/wiki/Exokernel" rel="">Exokernel</a><span> would let me run Homa in my LibraryOS, TCP in your LibraryOS, and perhaps RoCE or QUIC in yet another LibraryOS. But that’s not the world we live in. Someone has to decide what functionality does and does not get to run in privileged mode (and by extension, in the SmartNIC or IPU), and that decision impacts performance—especially latency—which is at the heart of the case for RPC in the datacenter. The HPC community realized this years ago, and deviated from Internet standards in response. My view of Homa is that it tries to achieve similar performance in low-latency environments, but in a more interoperable way. After 40 years, it makes sense that a second design point—a request/reply transport protocol, perhaps some variant of Homa/QUIC—sits side-by-side with TCP in the kernel.</span></p><p>But that’s just my opinion, and I don’t have a vote. What I find fascinating is questions about how systems evolve over time, and the Internet is fertile ground for such an archeological dig (especially as it relates to the OS kernel). Given all the competition TCP/IP has faced over the years—in a battle for survival of the fittest—I now better appreciate the symbiotic role UDP played in its success. If you’re going to promote a take-over-the-world substrate, pair it with a minimal side-kick as a way of postponing decisions about alternative designs.</p><p><span>Somewhat belatedly we came across Scott Shenker’s position </span><a href="https://dl.acm.org/doi/abs/10.1145/3577929.3577933" rel="">paper</a><span> suggesting some significant changes to the SIGCOMM conference (starting with much higher acceptance rates). We think they warrant consideration; you can join the </span><a href="https://sigcomm.slack.com/join/shared_invite/zt-uhdre6eo-dcEZe7iZWLPMlMdaEMAl5g#/shared-invite/email" rel="">SIGCOMM slack channel</a><span> to discuss, and also to get access to this paper, which should be freely available but somehow ended up paywalled. We found Cory Doctorow was on target (as usual) with his </span><a href="https://pluralistic.net/2023/03/09/autocomplete-worshippers/" rel="">latest</a><span> on Large Language Models, which has a fair bit in common with our </span><a href="https://open.substack.com/pub/systemsapproach/p/putting-large-language-models-in?r=cxpek&amp;utm_campaign=post&amp;utm_medium=web" rel="">recent post</a><span> but is longer and funnier. </span></p></div></div></div></article></div></div></div>
  </body>
</html>
