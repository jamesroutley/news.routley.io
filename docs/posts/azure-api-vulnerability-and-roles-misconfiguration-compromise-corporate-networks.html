<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.token.security/blog/azures-role-roulette-how-over-privileged-roles-and-api-vulnerabilities-expose-enterprise-networks">Original</a>
    <h1>Azure API vulnerability and roles misconfiguration compromise corporate networks</h1>
    
    <div id="readability-page-1" class="page"><div fs-richtext-element="rich-text"><h2>TL;DR</h2><p>Token Security researchers have discovered several Azure built-in roles that are misconfigured to be over-privileged - they grant more permissions than intended by Azure.</p><p>Combined, these two issues create a new attack chain that lets a <strong>weak user gain access to both internal cloud assets and on-premises networks.</strong></p><p>In this report, we detail the research process that led to the discoveries, their implications, and what organizations can do to stay safe against these threats and other identity-driven attacks.</p><h2>What is Azure RBAC?</h2><p>Before jumping in, let’s discuss some basics.</p><ol role="list"><li><strong>Security Principal</strong> - Who is given the permissions?</li><li><strong>Role Definition</strong> - Which role is assigned? What permissions does it grant? This section states the name of the role and the <strong><em>Actions</em></strong> and <strong><em>Not Actions</em></strong> (allow or deny) that this role is granting.</li><li><strong>Scope</strong> - What resources is the principal given access to? The scope can be vast, such as an entire management group or subscription, or more specific, like a resource group or a single resource (e.g., a specific VM or storage account).</li></ol><figure><p><img src="https://cdn.prod.website-files.com/661a822ae40a7d51ecf449bc/685a80d8cade8cb56dcc47b1_image%20(3).webp" loading="lazy" alt=""/></p><figcaption>Role assignment</figcaption></figure><h3><strong>Azure roles</strong></h3><p>In Azure, there are more than 400 built-in roles, which can be divided into 2 categories:</p><ol role="list"><li><strong>Generic</strong> - Roles that grant permissions that apply across all resources and all Azure services in the given scope (e.g., <strong><em>Contributor</em>, <em>Owner</em>, <em>Reader</em>,</strong> etc.<em>)</em></li><li><strong>Service-specific</strong> - Roles that grant permissions for a specific service or function in the given scope (e.g., <strong><em>Storage Blob Data Reader</em></strong><em> or </em><strong><em>Virtual Machine Contributor</em></strong>).</li></ol><p>If you assign the <strong><em>Contributor</em></strong> role over a subscription scope, it will grant permissions to perform actions over all of the resources in this subscription, regardless if they’re storage accounts, virtual machines, or any other resource. But if you assign the <strong><em>Virtual Machine Contributor</em></strong>, it will grant these permissions only to perform actions over virtual machines in the subscription.</p><h2><strong>The Problem</strong></h2><p>Let’s take a look at few roles and their permissions. See if you can tell where things go wrong.</p><h3><strong>The Reader role</strong></h3><p>One of Azure’s built-in roles, called <strong><em>Reader,</em></strong> is a generic role. As you’d expect, it gives read-only permissions over the resources in the chosen scope. Let’s examine its <strong>role definition</strong>:</p><div><figure>
<pre>

<code>
{
  &#34;assignableScopes&#34;: [
    &#34;/&#34;
  ],
  &#34;description&#34;: &#34;View all resources, but does not allow you to make any changes.&#34;,
  &#34;id&#34;: &#34;/providers/Microsoft.Authorization/roleDefinitions/acdd72a7-3385-48ef-bd42-f606fba81ae7&#34;,
  &#34;name&#34;: &#34;acdd72a7-3385-48ef-bd42-f606fba81ae7&#34;,
  &#34;permissions&#34;: [
    {
      &#34;actions&#34;: [
        &#34;*/read&#34;
      ],
      &#34;notActions&#34;: [],
      &#34;dataActions&#34;: [],
      &#34;notDataActions&#34;: []
    }
  ],
  &#34;roleName&#34;: &#34;Reader&#34;,
  &#34;roleType&#34;: &#34;BuiltInRole&#34;,
  &#34;type&#34;: &#34;Microsoft.Authorization/roleDefinitions&#34;
}
</code>

</pre>
<figcaption>Reader role definition</figcaption>
</figure></div><p>As we can see in the <code>actions</code> property, the permission given is <code>*/read</code>, which means it lets you perform any read action in the given scope.</p><p>*Note that this does not include data actions (reading data objects like files in storage accounts, key vault secrets, etc). Those require different, service-specific sensitive permissions.</p><p>Okay, so a generic role giving generic read permissions, that makes sense.</p><h3><strong>Workbook Reader</strong></h3><div><figure>
<pre><code>
{
  &#34;assignableScopes&#34;: [
    &#34;/&#34;
  ],
  &#34;description&#34;: &#34;Can read workbooks.&#34;,
  &#34;id&#34;: &#34;/providers/Microsoft.Authorization/roleDefinitions/b279062a-9be3-42a0-92ae-8b3cf002ec4d&#34;,
  &#34;name&#34;: &#34;b279062a-9be3-42a0-92ae-8b3cf002ec4d&#34;,
  &#34;permissions&#34;: [
    {
      &#34;actions&#34;: [
        &#34;microsoft.insights/workbooks/read&#34;,
        &#34;microsoft.insights/workbooks/revisions/read&#34;,
        &#34;microsoft.insights/workbooktemplates/read&#34;
      ],
      &#34;notActions&#34;: [],
      &#34;dataActions&#34;: [],
      &#34;notDataActions&#34;: []
    }
  ],
  &#34;roleName&#34;: &#34;Workbook Reader&#34;,
  &#34;roleType&#34;: &#34;BuiltInRole&#34;,
  &#34;type&#34;: &#34;Microsoft.Authorization/roleDefinitions&#34;
}
</code>
</pre>
<figcaption>Workbook Reader role definition</figcaption>
</figure></div><p>If we analyze the <code>actions</code> property, we can see that as the description states, it grants read permissions to a few workbook-related objects. So a service-specific role that grants access to a specific service! So far so good.</p><h3><strong>Managed Applications Reader</strong></h3><p>Now, let’s check the <strong><em>Managed Applications Reader</em></strong> role, which its description is <strong>“Lets you read resources in a managed app and request JIT access.”</strong></p><div><pre><code>
{
  &#34;assignableScopes&#34;: [
    &#34;/&#34;
  ],
  &#34;description&#34;: &#34;Lets you read resources in a managed app and request JIT access.&#34;,
  &#34;id&#34;: &#34;/providers/Microsoft.Authorization/roleDefinitions/b9331d33-8a36-4f8c-b097-4f54124fdb44&#34;,
  &#34;name&#34;: &#34;b9331d33-8a36-4f8c-b097-4f54124fdb44&#34;,
  &#34;permissions&#34;: [
    {
      &#34;actions&#34;: [
        &#34;Microsoft.Resources/deployments/*&#34;,
        &#34;Microsoft.Solutions/jitRequests/*&#34;,
        &#34;*/read&#34;
      ],
      &#34;notActions&#34;: [],
      &#34;dataActions&#34;: [],
      &#34;notDataActions&#34;: []
    }
  ],
  &#34;roleName&#34;: &#34;Managed Applications Reader&#34;,
  &#34;roleType&#34;: &#34;BuiltInRole&#34;,
  &#34;type&#34;: &#34;Microsoft.Authorization/roleDefinitions&#34;
}
</code>
</pre></div><p>We can see it has access to deployments, jitRequests, and… <strong>read everything???</strong>So this role, which is supposed to grant access to read managed apps and JIT access, actually also allows the user to read every Azure resource?</p><p><strong>Essentially, the role’s name and description are misleading the user into thinking the role grants specific permissions, when in fact it grants generic permissions to every resource.</strong></p><h2>How bad is it?</h2><p>I saw this and thought to myself, okay, this is just a read permission... how bad can it be?</p><p>Let’s dive into what we can actually do with this permission and how can it be useful for an attacker.</p><p>Since there are so many actions possible here, I divided them into three categories and gave some examples for each.</p><figure><p><img src="https://cdn.prod.website-files.com/661a822ae40a7d51ecf449bc/685a8131a3c0150ab5f9b294_image%20(4).webp" loading="lazy" alt=""/></p></figure><p><strong>Credential theft:</strong></p><ul role="list"><li><strong>Automation Accounts, Deployment scripts, Web applications</strong> - This one really surprised me: this permission actually allows you to read source code and environment variables of scripts and applications. The common thing among the three services I listed here, is that they all interact with your environment, <strong>which makes them very likely to contain credentials and secrets!</strong></li></ul><p><strong>Sensitive data discovery</strong>:</p><ul role="list"><li><strong>Storage accounts, container registries, databases</strong> - Enumerating all instances and their metadata to find sensitive data spots</li><li><strong>Resource locks</strong> - Helps identify resources that are considered critical or sensitive</li><li><strong>Backup vaults</strong> - Find DB exports, storage account backups and more</li></ul><p><strong>Attack planning</strong>:</p><ul role="list"><li><strong>Role assignments</strong> - Know about who can access what. Useful for planning privilege escalation paths</li><li><strong>Diagnostics settings, alerts, and log analytics workspaces</strong> - Know what is being logged, and where, and view security alerts. Useful for OpSec and detection avoidance</li><li><strong>Network configurations, network security groups, public IPs, virtual network gateways</strong> - Further plan attack paths and network advancements</li><li><strong>Key Vaults</strong> - Listing all vaults and their metadata</li></ul><h2>How wide is it?</h2><p>So you might think to yourself - Okay that’s cool… but I don’t use the <strong>Managed Applications Reader</strong> role, so I am safe, right?</p><p>After analyzing all Azure built-in roles, I found that this problem (having an un-needed <code>*/read</code> permission, basically including the <strong><em>Reader</em></strong> role) recurs in <strong>10 different roles(!):</strong></p><div><div>
<table>
	<thead>
		<tr>
			<th>Role name</th>
			<th>Actions</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Log Analytics Reader</td>
			<td><div>
<p><strong>*/read</strong></p></div>
			</td>
		</tr>
		<tr>
			<td>Log Analytics Contributor</td>
			<td>
				<div>
<p><strong>*/read</strong></p></div>
<div><p>
Microsoft.HybridCompute/machines/extensions/write</p></div><p>See More</p></td>
		</tr>
		<tr>
			<td>App Compliance Automation Administrator</td>
			<td> <div>
<p><strong>*/read</strong></p></div>
<div><p>
Microsoft.Storage/storageAccounts/listKeys/action</p></div><p>See More</p>
			</td>
		</tr>
		<tr>
			<td>App Compliance Automation Reader</td>
			<td>
<strong>*/read</strong>
			</td>
		</tr>
		<tr>
			<td>Managed Application Contributor Role</td>
			<td> <div>
<p><strong>*/read</strong></p></div>
<p>
Microsoft.Resources/deployments/*<br/>
</p><p>See More</p>
			</td>
		</tr>
		<tr>
			<td>Managed Application Operator Role</td>
			<td> <div>
<p><strong>*/read</strong></p></div>
			</td>
		</tr>
		<tr>
			<td>Managed Application Operator Role</td>
			<td> <div>
<p><strong>*/read</strong></p></div>
			</td>
		</tr>
		<tr>
			<td>Managed Applications Reader</td>
			<td> <div>
<p><strong>*/read</strong></p></div>
			</td>
		</tr>
		<tr>
			<td>Monitoring Contributor</td>
			<td> <div>
<p><strong>*/read</strong></p></div>
<div><p>
Microsoft.Insights/activityLogAlerts/*</p></div><p>See More</p>
			</td>
		</tr>
		<tr>
			<td>Monitoring Reader</td>
			<td> <div>
<p><strong>*/read</strong></p></div>
			</td>
		</tr>
		<tr>
			<td>Resource Policy Contributor</td>
			<td> <div>
<p><strong>*/read</strong></p></div>
<div><p>
Microsoft.Authorization/policysetdefinitions/*</p></div> <p>See More</p>
			</td>
		</tr>
	</tbody>
</table>
</div>



</div><p><strong>This risk exists in every user, service principal, managed identity, or group members that are assigned one of these seemingly innocent service-specific roles.</strong></p><p>As we can see in the table, some of the roles have more specific read permissions in addition to the <code>*/read</code>, like the <code>Microsoft.Solutions/applications/read</code> permission in <strong><em>Managed Application Operator Role</em>,</strong> which is already included in the *<strong>/read</strong> expression. This shows that one of the permissions is redundant, and may point to it being added by mistake or by laziness.</p><figure><p><img src="https://cdn.prod.website-files.com/661a822ae40a7d51ecf449bc/685a818acf7ec89ffc6a969c_image%20(5).webp" loading="lazy" alt=""/></p></figure><p>So this is pretty bad… but can we exploit it even further?</p><h2>VPN Vulnerability</h2><p>I wanted to make this attack scenario even stronger, and find more quirks that are possible using the <code>*/read</code> permission.</p><figure><p><img src="https://cdn.prod.website-files.com/661a822ae40a7d51ecf449bc/685a81b5226b749fe002583a_image%20(6).webp" loading="lazy" alt=""/></p></figure><p>So we understand that identities with read permissions should not be allowed to read secrets (which makes sense because those secrets can then be used to elevate privileges to more than read-only, access more resources, etc.)</p><p>So my thought was:</p><p>If I can find one action, out of those 9,618, that will allow me to leak a secret, I will have a serious vulnerability here!</p><p>After going through many permissions in the list, I found one that piqued my interest:</p><figure><p><img src="https://cdn.prod.website-files.com/661a822ae40a7d51ecf449bc/685a81cce23660a335fbb701_image%20(7).webp" loading="lazy" alt=""/></p></figure><p>What is a VPN link? What is a connection? What is a shared key? I don’t know, but it has the word ‘key’ in it, so it must be interesting :)</p><h3>The bug</h3><p>So we have an API call that retrieves some sort of a secret even if I only have read permissions. But why is that happening? What is the mistake that the Azure developer made here?</p><p>In Azure, API calls are implemented with different HTTP methods. For example, the <a href="https://learn.microsoft.com/en-us/rest/api/compute/virtual-machines/list" target="_blank">Virtual Machines - List</a> API call is implemented with <strong>GET</strong>, and <a href="https://learn.microsoft.com/en-us/rest/api/compute/virtual-machines/install-patches" target="_blank">Virtual Machines - Install Patches</a> is implemented with <strong>POST</strong>. That makes sense, because the <em>Install Patches</em> API requires data from the user (a body in the request), while the <em>List VMs</em> only retrieves data from the server, and does not require any data from the user.</p><p>To prove this, I performed an API call to a URL that doesn’t exist, using a read-only identity. When I issue a GET request, I get <code>HttpResourceNotFound</code> error. But when I issue a POST request to the same non-existent URL, I get  <code>AuthorizationFailed</code> error. This further proves that permission enforcement is determined by the HTTP method, and not by the checking specific API call and whether or not I have access to it.</p><figure><p><img src="https://cdn.prod.website-files.com/661a822ae40a7d51ecf449bc/6863df08ecdfb9351eb218ab_getvspost.jpg" loading="lazy" alt=""/></p></figure><p>So why is that problematic? Because when you choose to design your software in a way that doesn’t make sense and isn’t intuitive, your developers are bound to make some critical mistakes…</p><p>If we take a look at the API call that we found earlier, we see that our theory was right! It was accidentally implemented with a GET, allowing read-only users to fetch the key!</p><figure><p><img src="https://cdn.prod.website-files.com/661a822ae40a7d51ecf449bc/685a8223f0eeced7a7202d84_image%20(9).webp" loading="lazy" alt=""/></p></figure><p>So now we have a vulnerability. The only thing that is left is to find out what that shared key is…</p><h3><strong>Azure VPN Gateway</strong></h3><p>VPN Gateway is an Azure service that acts as a VPN, allowing customers to connect networks over the internet. Organizations mainly use this service to support hybrid environments (connecting cloud and on-premise), as well as connecting between on-premise sites (aka Site-to-Site, or S2S). Individual users can also connect to it, for scenarios such as working remotely (aka Point-to-Site, or P2S).</p><p>P2S connection types require additional authentication (certificate/radius server/Entra ID login).</p><h2>The full attack</h2><ol role="list"><li>The attacker compromises a weak identity (identity with read permissions or one that is assigned one of the many over-privileged roles we listed earlier).</li><li>The attacker fetches the VPN Gateway pre-shared key.</li><li>Using the key, the attacker connects to the S2S connection and accesses internal networks, including VPCs and on-premise networks that are connected to the same Azure VPN Gateway.</li></ol><p><strong>Proof-of-concept video:</strong></p><div><p><iframe src="https://player.vimeo.com/video/1095886498?h=d6400a9059&amp;title=0&amp;byline=0&amp;portrait=0&amp;badge=0&amp;autopause=0&amp;player_id=0&amp;app_id=58479" frameborder="0" allow="autoplay; fullscreen; picture-in-picture; clipboard-write; encrypted-media; web-share" title="How Over-Privileged Roles and API Vulnerabilities Expose Enterprise Networks - attack demonstration"></iframe></p></div><p>With this access, attackers can create a “rogue site”, essentially granting them access to cloud resources, other sites, and secure networks of the target organization.</p><p>Depending on the configuration of the VPN Gateway, this may work only when the connection attempt is originating from the IP address configured in the Azure VPN gateway.</p><p>In that case, an attacker that has some on-premise foothold can use this trick to access sensitive cloud infrastructure and data.</p><p>There are even more sensitive values you can access using the Reader privileges. <a href="https://binarysecurity.no/posts/2024/11/apim-privesc" target="_blank">Excellent research published by Binary Security</a> shows how you can escalate your Reader privileges in Azure API Management service by fetching subscription keys and SSO tokens, effectively resulting in a full takeover of the service.</p><h2><strong>Vendor response</strong></h2><h3>Over-privileged roles</h3><p>After reporting this issue to Microsoft, their response was that this is a ‘low severity’ security issue and they decided to not fix it. I later noticed some major documentation changes based on my report: All 10 over-privileged roles’ documentations were added the following sentence:</p><figure><p><img src="https://cdn.prod.website-files.com/661a822ae40a7d51ecf449bc/685a82ed78f3671d4a965aff_image%20(10).webp" loading="lazy" alt=""/></p></figure><p>So they chose to fix the documentation instead of fixing the actual issue, which still endangers customers.</p><figure><p><img src="https://cdn.prod.website-files.com/661a822ae40a7d51ecf449bc/685a83108bd1ef47c4c44c0c_image%20(11).webp" loading="lazy" alt=""/></p></figure><h3>VPN PSK leak</h3><p>This was acknowledged by Microsoft as an ‘Important’ severity vulnerability, and the issue was fixed. They also awarded me with a US$7,500 bounty award.</p><p>I was happy to find out that the fix was not changing the API HTTP method to POST.</p><figure><p><img src="https://cdn.prod.website-files.com/661a822ae40a7d51ecf449bc/685a833224ecf51ec2142a4f_image%20(12).webp" loading="lazy" alt=""/></p></figure><p>This is a very good fix!</p><h2>Mitigations and recommendations</h2><h3>Audit the use of the problematic roles</h3><p>As we saw, the over-privileged roles issue is not going to be fixed. Refrain from using those roles in your environment, and use alternatives.</p><h3><strong>Use particular and limited scopes</strong></h3><p>Instead of assigning roles on a wide scope, such as an entire management group or subscription level, limit them only to the specific resource that the principal needs access to, or to a resource group if access to multiple resources is needed.</p><h3><strong>Build custom roles</strong></h3><p>Instead of using built-in roles that are not managed by you, use custom roles and grant only the needed permissions. Replace your current role assignments (at least of the problematic roles mentioned here) with custom roles that have fine-grained permissions.</p><h2><strong>Summary</strong></h2><p>Securing cloud environments and their identities is not easy.</p><p>The shared responsibility model, which is adopted and presented by all major cloud providers, clearly states which security tasks are the cloud provider’s responsibility, and which are the customer’s. But the issues we discussed here are in the gray area: when the cloud provider is giving you a service that is supposed to help you with identities and permissions management, but in fact misleads you into making dangerous decisions, who is to blame? Is it the cloud provider who caused you to create the security issue, or is it you, who actually created it?</p><p>There is no easy answer here, but one thing is clear - don’t fully and blindly trust the services that are given to you. Always double check, and be proactive and vigilant about the security of your organization.</p><p>When you have many identities and big infrastructure, this becomes a real challenge. When you have to question every role, permission, and API call, things can get complicated. But luckily, there is a solution.</p><p>To learn more about Token Security and how we can help secure your Azure environment (and many more), book a demo <a href="https://www.token.security/book-a-demo" target="_blank">here</a>.</p><h3>Reach out anytime</h3><p>I’m Ariel Simon, a security researcher from the Token research team, primarily focused on uncovering vulnerabilities and finding new attack techniques in cloud environments.</p></div></div>
  </body>
</html>
