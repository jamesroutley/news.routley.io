<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bloop.ai/blog/evaluating-llms-on-cobol">Original</a>
    <h1>How well can LLMs write COBOL?</h1>
    
    <div id="readability-page-1" class="page"><div><article><p><img src="https://bloop-web-app.s3.eu-west-1.amazonaws.com/blog/evaluation-on-cobol-chart.png"/></p><p><strong>How well can LLMs write COBOL?</strong></p><p>LLMs are fast-changing the way that we write software. Over a million developers now <a href="https://www.linkedin.com/posts/ashtom_microsoft-has-over-a-million-paying-github-activity-7123051140115562497-7Hbq/">pay for GitHub Copilot</a> and recent breakthroughs in LLM reasoning have brought the dream of a <a href="https://www.cognition-labs.com/introducing-devin">fully AI Software Engineer</a> closer to reality. But while itâ€™s not hard to find a demo of an LLM coding a website or a clone of Flappy Bird, not much is known about their ability to write code in older â€˜legacyâ€™ languages like COBOL.</p><p>The opportunity for LLM COBOL generation is huge. Although the language was first released in 1959, it continues to power critical systems - <a href="https://fortune.com/2023/09/26/github-ceo-wall-street-relies-software-developed-ai-next-financial-crisis-thomas-dohmke/">95% of US ATM transactions are processed in COBOL</a>. But it&#39;s not taught in computer science courses or bootcamps, and the engineers who write it professionally are steadily retiring. If LLMs could understand and write COBOL they could help maintain the <a href="https://www.microfocus.com/en-us/press-room/press-releases/2022/cobol-market-shown-to-be-three-times-larger-than-previously-estimated-in-new-independent-survey">800 billion lines</a> still in production today.Â Â </p><p>So, how well can LLMs write COBOL? As far as we know, nobody has publicly tried to answer this question. Until nowâ€¦</p><p><strong>Introducing COBOLEval</strong></p><p>Today weâ€™re releasing COBOLEval, the first evaluation benchmark for LLM code completions in COBOL. It consists of 146 challenging coding problems that have been converted into COBOL from the widely-used <a href="https://github.com/openai/human-eval">HumanEval Python generation benchmark</a>. Each problem is paired with an average of 6 test cases. An LLM-generated solution has to pass all of them to be correct. Weâ€™re also releasing a test harness that you can use to evaluate your own models, as well as <em>mAInframer-1</em> - a series of open-source models based on CodeLlama that weâ€™ve fine-tuned specifically to write COBOL - which outperform GPT-4.</p><p>You can get started with COBOLEval here: <a href="https://github.com/BloopAI/cobolEval">https://github.com/BloopAI/cobolEval</a></p><p><strong>From HumanEval to COBOLEval</strong></p><p><strong><em>Functions</em></strong></p><p>Converting HumanEval to COBOL isnâ€™t as straightforward as it sounds. Each HumanEval problem consists of a <em>prompt</em>, a typed Python function signature and docstring, which is passed directly to an LLM, which then implements the body of the function.</p><pre><code><span>from</span><span> typing </span><span>import</span><span> List
</span>
<span></span><span>def</span><span> </span><span>has_close_elements</span><span>(</span><span>numbers</span><span>:</span><span> List</span><span>[</span><span>float</span><span>]</span><span>,</span><span> threshold</span><span>:</span><span> </span><span>float</span><span>)</span><span> </span><span>-</span><span>&gt;</span><span> </span><span>bool</span><span>:</span><span>
</span><span>    </span><span>&#34;&#34;&#34; Check if in given list of numbers, are any two numbers closer to each other than
</span><span>    given threshold.
</span><span>    &gt;&gt;&gt; has_close_elements([1.0, 2.0, 3.0], 0.5)
</span><span>    False
</span><span>    &gt;&gt;&gt; has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)
</span><span>    True
</span><span>    &#34;&#34;&#34;</span></code></pre><p>But this immediately poses a problem. COBOL is a procedural programming language; it doesnâ€™t have functions.</p><p>It does, however, have subprograms. So we transform each problem into a COBOL program where arguments and return variables are defined in the <code>LINKAGE SECTION</code> so they can be passed and read from a calling program.</p><pre><code><span>       </span><span>IDENTIFICATION</span><span> </span><span>DIVISION</span><span>.</span><span>
</span><span>       </span><span>PROGRAM-ID</span><span>.</span><span> HAS-CLOSE-ELEMENTS</span><span>.</span><span>
</span>
<span>       </span><span>ENVIRONMENT</span><span> </span><span>DIVISION</span><span>.</span><span>
</span>
<span>       </span><span>INPUT-OUTPUT</span><span> </span><span>SECTION</span><span>.</span><span>
</span>
<span>       </span><span>DATA</span><span> </span><span>DIVISION</span><span>.</span><span>
</span>
<span>       </span><span>LINKAGE</span><span> </span><span>SECTION</span><span>.</span><span>
</span>
<span>       </span><span>01</span><span> LINKED-ITEMS</span><span>.</span><span>
</span><span>           </span><span>05</span><span> L-NUMBERS </span><span>OCCURS</span><span> </span><span>100</span><span> </span><span>TIMES</span><span> </span><span>INDEXED</span><span> </span><span>BY</span><span> NI </span><span>COMP-2</span><span>.</span><span>
</span><span>           </span><span>05</span><span> L-THRESHOLD </span><span>COMP-2</span><span>.</span><span>
</span><span>           </span><span>05</span><span> RESULT </span><span>PIC</span><span> </span><span>9</span><span>.</span><span>
</span>
<span>      </span><span>* Check if in given list of numbers, are any two numbers closer to each other than</span><span>
</span><span>      </span><span>* given threshold.</span><span>
</span><span>      </span><span>* &gt;&gt;&gt; has_close_elements([1.0, 2.0, 3.0], 0.5)</span><span>
</span><span>      </span><span>* False</span><span>
</span><span>      </span><span>* &gt;&gt;&gt; has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)</span><span>
</span><span>      </span><span>* True</span><span>
</span><span>      </span><span>*</span><span>
</span>
<span>      </span><span>* Complete the WORKING-STORAGE SECTION and the PROCEDURE DIVISION</span><span>
</span><span>      </span><span>* Store the result in the RESULT variable and mark the end of your program with END PROGRAM</span><span>
</span>
<span>       </span><span>WORKING-STORAGE</span><span> </span><span>SECTION</span><span>.</span></code></pre><p>This is the format of COBOLEval prompts that are passed to the LLM.</p><p><strong><em>Types</em></strong></p><p>COBOLâ€™s type system is radically different to modern programming languages. Variables are declared with <code>PICTURE</code> clauses (<code>PIC</code> for short) which specify the number of characters they occupy in memory. For example, <code>PIC X(100)</code> is a string with 100 characters, while <code>PIC S9(10)</code> is a 10-digit signed integer. Unlike Python, COBOL doesnâ€™t have variable-length strings, integers or arrays, so we fix these lengths to upper-bounds (no COBOLEval problems accept or return an array with a length greater than 100).</p><p>This gives us our mapping from Python to COBOL types:</p><pre><code><span>Int</span><span> </span><span>=&gt;</span><span> </span><span>PIC</span><span> </span><span>S9</span><span>(</span><span>10</span><span>)</span><span>
</span><span></span><span>Float</span><span> </span><span>=&gt;</span><span> </span><span>COMP</span><span>-</span><span>2</span><span>
</span><span></span><span>Str</span><span> </span><span>=&gt;</span><span> </span><span>PIC</span><span> </span><span>X</span><span>(</span><span>100</span><span>)</span><span>
</span><span></span><span>List</span><span>[</span><span>Int</span><span>]</span><span> </span><span>=&gt;</span><span> </span><span>OCCURS</span><span> </span><span>100</span><span> </span><span>TIMES</span><span> </span><span>INDEXED</span><span> </span><span>BY</span><span> </span><span>I</span><span> </span><span>PIC</span><span> </span><span>S9</span><span>(</span><span>10</span><span>)</span></code></pre><p>Note that some Python types, like <code>Any</code> or <code>Dict</code>, canâ€™t easily be represented in COBOL. We ignore HumanEval problems that accept or return them. Luckily there arenâ€™t many of them.</p><p><strong><em>Working-Storage Section</em></strong></p><p>The veteran COBOL programmers among you will have spotted a bug in the prompt program above. The <code>LINKAGE SECTION</code> and <code>WORKING-STORAGE SECTION</code> are the wrong way round. If we tried to compile it, weâ€™d get an error.</p><p>Why are they in the wrong order? The problem is that - unlike modern languages (youâ€™ll be used to hearing that by now) - COBOL does not have local variables. All variables - even temporary ones - that are used in the program logic have to be declared ahead o time in the <code>WORKING-STORAGE SECTION</code>.</p><p>Clearly, the LLM needs to generate the <code>WORKING-STORAGE SECTION</code> so that it can declare variables it will use in its solution. But at the same time, it needs to know the variables that have already been declared in the <code>LINKAGE SECTION</code>. COBOLs strict structure prevents an LLM from generating solutions in neat left-to-right order.</p><p>We offer two possible approaches. One is illustrated above: we swap the order of the sections in the prompt, and have the model generate the <code>WORKING-STORAGE SECTION</code> and the <code>PROCEDURE DIVISION</code> one after the other. We then reinsert the implemented <code>WORKING-STORAGE SECTION</code> into the program at the correct position. This approach is simple, but requires the LLM generalise beyond its training data (it wonâ€™t have seen many programs where the sections are out-of-order).</p><p>The other approach is to use a technique called <a href="https://openai.com/research/efficient-training-of-language-models-to-fill-in-the-middle">infilling</a>. Here, we decompose the program into <em>prefix</em>, <em>middle</em>, and <em>suffix</em> (delimited by the special tokens <code>&lt;PRE&gt;</code>, <code>&lt;MID&gt;</code> and <code>&lt;SUF&gt;</code>) and generate a completion in the order: <em>prefix</em>, <em>suffix</em>, <em>middle</em>. This allows us to <em>fill-in</em> code in the middle of a program.</p><p>If we wanted to fill in the third line of this Python function</p><div><pre><code><span><span><span><span><span>def</span><span> </span><span>factorial</span><span>(</span><span>n</span><span>)</span><span>:</span><span>
</span></span><span><span>  </span><span>if</span><span> n </span><span>&gt;</span><span> </span><span>1</span><span>:</span><span>
</span></span><span></span></span></span></span><span><span><span><span><span>    </span><span>return</span><span> n </span><span>*</span><span> factorial</span><span>(</span><span>n </span><span>-</span><span> </span><span>1</span><span>)</span><span>
</span></span><span><span>  </span><span>elif</span><span> n </span><span>==</span><span>1</span><span>:</span><span>
</span></span><span><span>    </span><span>return</span><span> </span><span>1</span></span></span></span></span></code></pre></div><p>Our infilling prompt would look like this (where the prompt is green, and the completion is red):</p><div><pre><code><span><span><span><span><span>&lt;</span><span>PRE</span><span>&gt;</span><span>def</span><span> factorial</span><span>(</span><span>n</span><span>)</span><span>:</span><span>
</span></span><span><span>  </span><span>if</span><span> n </span><span>&gt;</span><span> </span><span>1</span><span>:</span><span>
</span></span><span><span></span><span>&lt;</span><span>SUF</span><span>&gt;</span><span>  </span><span>elif</span><span> n </span><span>==</span><span>1</span><span>:</span><span>
</span></span><span><span>    </span><span>return</span><span> </span><span>1</span><span>
</span></span><span><span></span><span>&lt;</span><span>MID</span><span>&gt;</span></span></span></span></span><span><span><span><span><span>   </span><span>return</span><span> n </span><span>*</span><span> factorial</span><span>(</span><span>n </span><span>-</span><span> </span><span>1</span><span>)</span></span></span></span></span></code></pre></div><p>Back to COBOL, we can generate both the <code>WORKING-STORAGE SECTION</code> and the <code>PROCEDURE DIVISION</code> by prompting the LLM like this:</p><div><pre><code><span><span><span><span><span>&lt;</span><span>PRE</span><span>&gt;</span><span>
</span></span><span><span>       </span><span>IDENTIFICATION</span><span> </span><span>DIVISION</span><span>.</span><span>
</span></span><span><span>       </span><span>PROGRAM-ID</span><span>.</span><span>  SUM-OF-CUBES</span><span>.</span><span>
</span></span><span><span>       </span><span>ENVIRONMENT</span><span> </span><span>DIVISION</span><span>.</span><span>
</span></span><span>       
</span><span><span>       </span><span>INPUT-OUTPUT</span><span> </span><span>SECTION</span><span>.</span><span>
</span></span><span>
</span><span><span>       </span><span>DATA</span><span> </span><span>DIVISION</span><span>.</span><span>
</span></span><span><span></span><span>&lt;</span><span>SUF</span><span>&gt;</span><span>
</span></span><span><span>       </span><span>LINKAGE</span><span> </span><span>SECTION</span><span>.</span><span>
</span></span><span>
</span><span><span>       </span><span>01</span><span> LINKED-ITEMS</span><span>.</span><span>
</span></span><span><span>           </span><span>05</span><span> L-MAX-STEP </span><span>PIC</span><span> </span><span>S9</span><span>(</span><span>10</span><span>)</span><span>.</span><span>
</span></span><span><span>           </span><span>05</span><span> RESULT </span><span>PIC</span><span> </span><span>S9</span><span>(</span><span>10</span><span>)</span><span>.</span><span>
</span></span><span>
</span><span><span>      </span><span>* </span><span>
</span></span><span><span>      </span><span>* Given an integer number, return the sum of all the integers below it.</span><span>
</span></span><span><span>      </span><span>* </span><span>
</span></span><span><span>      </span><span>* Example:</span><span>
</span></span><span><span>      </span><span>* </span><span>
</span></span><span><span>      </span><span>* sum_of_cubes(3) == 1**3 + 2**3 == 9</span><span>
</span></span><span><span>      </span><span>* sum_of_cubes(5) == 100</span><span>
</span></span><span><span>      </span><span>*  </span><span>
</span></span><span>
</span><span><span>      </span><span>* Store the result in the RESULT variable and mark the end of your program with END PROGRAM</span><span>
</span></span><span>
</span><span></span></span></span></span><span><span><span><span><span>       </span><span>PROCEDURE</span><span> </span><span>DIVISION</span><span> </span><span>USING</span><span> LINKED-ITEMS</span><span>.</span><span>
</span></span><span>       
</span><span><span>           </span><span>PERFORM</span><span> </span><span>VARYING</span><span> STEP </span><span>FROM</span><span> </span><span>0</span><span> </span><span>BY</span><span> </span><span>1</span><span> 
</span></span><span><span>               </span><span>UNTIL</span><span> STEP </span><span>IS</span><span> </span><span>EQUAL</span><span> </span><span>TO</span><span> L-MAX-STEP
</span></span><span><span>               </span><span>COMPUTE</span><span> CUBE </span><span>=</span><span> STEP </span><span>*</span><span>*</span><span> </span><span>3</span><span>
</span></span><span><span>               </span><span>ADD</span><span> CUBE </span><span>TO</span><span> CUBE-SUM
</span></span><span><span>           </span><span>END-PERFORM</span><span>
</span></span><span><span>           </span><span>.</span><span>
</span></span><span><span>           </span><span>MOVE</span><span> CUBE-SUM </span><span>TO</span><span> RESULT</span><span>.</span><span>
</span></span><span><span>           </span><span>DISPLAY</span><span> </span><span>&#39;THE SUM OF THE CUBES IS &#39;</span><span> RESULT</span><span>.</span><span>
</span></span><span><span>           </span><span>GOBACK</span><span>.</span><span>
</span></span><span>
</span><span><span>       </span><span>END</span><span> </span><span>PROGRAM</span><span> SUM-OF-CUBES</span><span>.</span><span>
</span></span><span><span></span><span>&lt;</span><span>MID</span><span>&gt;</span><span>
</span></span><span><span>       </span><span>WORKING-STORAGE</span><span> </span><span>SECTION</span><span>.</span><span>
</span></span><span>       
</span><span><span>       </span><span>01</span><span> STEP         </span><span>PIC</span><span> </span><span>S9</span><span>(</span><span>10</span><span>)</span><span>.</span><span>
</span></span><span><span>       </span><span>01</span><span> CUBE         </span><span>PIC</span><span> </span><span>9</span><span>(</span><span>7</span><span>)</span><span>.</span><span>
</span></span><span><span>       </span><span>01</span><span> CUBE-SUM     </span><span>PIC</span><span> </span><span>9</span><span>(</span><span>7</span><span>)</span><span> </span><span>VALUE</span><span> </span><span>0</span><span>.</span></span></span></span></span></code></pre></div><p>We cut the <code>WORKING-STORAGE SECTION</code> out of the program, so the LLM first generates the solution logic in the <code>PROCEDURE DIVISION</code> and the special <code>&lt;MID&gt;</code> token, then declares the variables it used by generating the <code>WORKING-STORAGE SECTION</code>.</p><p><em>Note that this works best with models that have been trained to support infilling (e.g. CodeLlama).</em></p><p><strong><em>Putting it all together</em></strong></p><p>Each HumanEval problem is accompanied by a set of test cases.</p><pre><code><span>def</span><span> </span><span>check</span><span>(</span><span>candidate</span><span>)</span><span>:</span><span>
</span><span>    </span><span>assert</span><span> candidate</span><span>(</span><span>[</span><span>1.0</span><span>,</span><span> </span><span>2.0</span><span>,</span><span> </span><span>3.9</span><span>,</span><span> </span><span>4.0</span><span>,</span><span> </span><span>5.0</span><span>,</span><span> </span><span>2.2</span><span>]</span><span>,</span><span> </span><span>0.3</span><span>)</span><span> </span><span>==</span><span> </span><span>True</span><span>
</span><span>    </span><span>assert</span><span> candidate</span><span>(</span><span>[</span><span>1.0</span><span>,</span><span> </span><span>2.0</span><span>,</span><span> </span><span>3.9</span><span>,</span><span> </span><span>4.0</span><span>,</span><span> </span><span>5.0</span><span>,</span><span> </span><span>2.2</span><span>]</span><span>,</span><span> </span><span>0.05</span><span>)</span><span> </span><span>==</span><span> </span><span>False</span><span>
</span><span>    </span><span>assert</span><span> candidate</span><span>(</span><span>[</span><span>1.0</span><span>,</span><span> </span><span>2.0</span><span>,</span><span> </span><span>5.9</span><span>,</span><span> </span><span>4.0</span><span>,</span><span> </span><span>5.0</span><span>]</span><span>,</span><span> </span><span>0.95</span><span>)</span><span> </span><span>==</span><span> </span><span>True</span><span>
</span><span>    </span><span>assert</span><span> candidate</span><span>(</span><span>[</span><span>1.0</span><span>,</span><span> </span><span>2.0</span><span>,</span><span> </span><span>5.9</span><span>,</span><span> </span><span>4.0</span><span>,</span><span> </span><span>5.0</span><span>]</span><span>,</span><span> </span><span>0.8</span><span>)</span><span> </span><span>==</span><span> </span><span>False</span><span>
</span><span>    </span><span>assert</span><span> candidate</span><span>(</span><span>[</span><span>1.0</span><span>,</span><span> </span><span>2.0</span><span>,</span><span> </span><span>3.0</span><span>,</span><span> </span><span>4.0</span><span>,</span><span> </span><span>5.0</span><span>,</span><span> </span><span>2.0</span><span>]</span><span>,</span><span> </span><span>0.1</span><span>)</span><span> </span><span>==</span><span> </span><span>True</span><span>
</span><span>    </span><span>assert</span><span> candidate</span><span>(</span><span>[</span><span>1.1</span><span>,</span><span> </span><span>2.2</span><span>,</span><span> </span><span>3.1</span><span>,</span><span> </span><span>4.1</span><span>,</span><span> </span><span>5.1</span><span>]</span><span>,</span><span> </span><span>1.0</span><span>)</span><span> </span><span>==</span><span> </span><span>True</span><span>
</span><span>    </span><span>assert</span><span> candidate</span><span>(</span><span>[</span><span>1.1</span><span>,</span><span> </span><span>2.2</span><span>,</span><span> </span><span>3.1</span><span>,</span><span> </span><span>4.1</span><span>,</span><span> </span><span>5.1</span><span>]</span><span>,</span><span> </span><span>0.5</span><span>)</span><span> </span><span>==</span><span> </span><span>False</span></code></pre><p>We generate a COBOLEval calling program for each test case. The calling program defines the data and passes it to the LLM generated solution. It then writes the <code>RESULT</code> variable to a file.</p><pre><code><span>       </span><span>IDENTIFICATION</span><span> </span><span>DIVISION</span><span>.</span><span>
</span><span>       </span><span>PROGRAM-ID</span><span>.</span><span> CAR-RACE-COLLISION-CALL</span><span>.</span><span>
</span>
<span>       </span><span>ENVIRONMENT</span><span> </span><span>DIVISION</span><span>.</span><span>
</span>
<span>       </span><span>INPUT-OUTPUT</span><span> </span><span>SECTION</span><span>.</span><span>
</span>
<span>       </span><span>FILE-CONTROL</span><span>.</span><span>
</span>
<span>       </span><span>SELECT</span><span> OUTPUT-FILE </span><span>ASSIGN</span><span> </span><span>TO</span><span> </span><span>&#34;CAR-RACE-COLLISION.TXT&#34;</span><span>
</span><span>           </span><span>ORGANIZATION</span><span> </span><span>IS</span><span> </span><span>LINE</span><span> </span><span>SEQUENTIAL</span><span>
</span><span>           </span><span>STATUS</span><span> </span><span>IS</span><span> OUTPUT-FILE-STATUS</span><span>.</span><span>
</span>
<span>       </span><span>DATA</span><span> </span><span>DIVISION</span><span>.</span><span>
</span>
<span>       </span><span>FILE</span><span> </span><span>SECTION</span><span>.</span><span>
</span><span>       </span><span>FD</span><span> OUTPUT-FILE</span><span>.</span><span>
</span><span>       </span><span>01</span><span> OUTPUT-RECORD </span><span>PIC</span><span> </span><span>S9</span><span>(</span><span>10</span><span>)</span><span> </span><span>SIGN</span><span> </span><span>LEADING</span><span>.</span><span>
</span>
<span>       </span><span>WORKING-STORAGE</span><span> </span><span>SECTION</span><span>.</span><span>
</span>
<span>       </span><span>01</span><span> OUTPUT-FILE-STATUS </span><span>PIC</span><span> </span><span>X</span><span>(</span><span>02</span><span>)</span><span>.</span><span>
</span>
<span>       </span><span>01</span><span> LINKED-ITEMS</span><span>.</span><span>
</span><span>           </span><span>05</span><span> L-N </span><span>PIC</span><span> </span><span>S9</span><span>(</span><span>10</span><span>)</span><span>.</span><span>
</span><span>           </span><span>05</span><span> RESULT </span><span>PIC</span><span> </span><span>S9</span><span>(</span><span>10</span><span>)</span><span>.</span><span>
</span>
<span>       </span><span>PROCEDURE</span><span> </span><span>DIVISION</span><span>.</span><span>
</span>
<span>       </span><span>MOVE</span><span> </span><span>10</span><span> </span><span>TO</span><span> L-N
</span>
<span>       </span><span>CALL</span><span> </span><span>&#34;CAR-RACE-COLLISION&#34;</span><span> </span><span>USING</span><span> LINKED-ITEMS
</span>
<span>       </span><span>OPEN</span><span> </span><span>OUTPUT</span><span> OUTPUT-FILE
</span>
<span>       </span><span>IF</span><span> OUTPUT-FILE-STATUS </span><span>NOT</span><span> </span><span>=</span><span> </span><span>&#34;00&#34;</span><span>
</span><span>           </span><span>DISPLAY</span><span> </span><span>&#34;ERROR OPENING OUTPUT FILE&#34;</span><span>
</span><span>           </span><span>STOP</span><span> </span><span>RUN</span><span>
</span><span>        </span><span>END-IF</span><span>
</span>
<span>       </span><span>MOVE</span><span> RESULT </span><span>TO</span><span> OUTPUT-RECORD
</span><span>       </span><span>WRITE</span><span> OUTPUT-RECORD
</span>
<span>        </span><span>IF</span><span> OUTPUT-FILE-STATUS </span><span>NOT</span><span> </span><span>=</span><span> </span><span>&#34;00&#34;</span><span>
</span><span>            </span><span>DISPLAY</span><span> </span><span>&#34;ERROR WRITING TO OUTPUT FILE&#34;</span><span>
</span><span>            </span><span>STOP</span><span> </span><span>RUN</span><span>
</span><span>        </span><span>END-IF</span><span>
</span>
<span>        </span><span>CLOSE</span><span> OUTPUT-FILE</span></code></pre><p>Solution outputs are compared to the true values and a score is calculated. The COBOLEval repo includes an evaluation harness that fully automates this process. <em>Note: COBOLEval uses the open-source GnuCOBOL compiler.</em></p><p><strong>So how good are they?</strong></p><p>We have a benchmark, so how well can state-of-the-art LLMs write COBOL? We calculated pass@1 scores (with <em>temperature = 0</em>) for some widely used models.</p><table><thead><tr><th>Model</th><th>Pass@1</th><th>% Compile</th></tr></thead><tbody><tr><td><span>GPT 3.5 Turbo</span></td><td><span>4.11</span></td><td><span>19.17</span></td></tr><tr><td><span>GPT-4</span></td><td><span><strong>8.90</strong></span></td><td><span>47.94</span></td></tr><tr><td><span>CodeLlama-7b</span></td><td><span>0.68</span></td><td><span>25.34</span></td></tr><tr><td><span>CodeLlama-13b</span></td><td><span>1.36</span></td><td><span>13.01</span></td></tr><tr><td><span>CodeLlama-34b</span></td><td><span>2.05</span></td><td><span><strong>78.76</strong></span></td></tr></tbody></table><p>GPT-4 - the best-performing model - generates a correct solution for 10.27% of problems. Compare this to HumanEval, where it solves <em>67%</em> of problems. CodeLlama, one of the best open-source coding models, fares even worse, with the 34b variant only clocking 2%. COBOLEval is hard.</p><p>Looking at the failure cases, we can see that state-of-the-art LLMs struggle to generate COBOL that even compiles. Only 47.94% of GPT-4 generated solutions compile with GnuCOBOL.</p><pre><code><span>          </span><span>PERFORM</span><span> </span><span>VARYING</span><span> I </span><span>FROM</span><span> Y </span><span>BY</span><span> </span><span>-1</span><span> </span><span>UNTIL</span><span> I </span><span>&lt;</span><span> X
</span><span>               </span><span>IF</span><span> I MOD </span><span>2</span><span> </span><span>=</span><span> </span><span>0</span><span> </span><span>THEN</span><span>
</span><span>                   </span><span>MOVE</span><span> I </span><span>TO</span><span> MAX-EVEN
</span><span>                   </span><span>EXIT</span><span> </span><span>PERFORM</span><span>
</span><span>               </span><span>END-IF</span><span>
</span><span>           </span><span>END-PERFORM</span><span>
</span></code></pre><p>Here GPT-4 has tried to use the <code>MOD</code> function without preceding it with the <code>FUNCTION</code> keyword.</p><p><strong><em>mAInframer-1</em></strong></p><p>Weâ€™re also releasing <em>mAInframer-1</em>, a series of models that weâ€™ve fine-tuned to write COBOL. You can download them here: <a href="https://huggingface.co/bloopai">https://huggingface.co/bloopai</a></p><table><thead><tr><th>Model</th><th>Pass@1</th><th>% Compile</th></tr></thead><tbody><tr><td><span>mAInframer-7b</span></td><td><span>6.16</span></td><td><span>69.17</span></td></tr><tr><td><span>mAInframer-13b</span></td><td><span>8.9</span></td><td><span>54.1</span></td></tr><tr><td><span>mAInframer-34b</span></td><td><span><strong>10.27</strong></span></td><td><span><strong>73.97</strong></span></td></tr></tbody></table><p>All three mAInframer models considerably outperform CodeLlama models, while the 34b model gets a higher pass@1 than GPT-4! More details about how we did that coming soon ðŸ˜€</p><p><strong>Whatâ€™s next?</strong></p><p>Thereâ€™s clearly a lot of room to improve LLM-generated COBOL. We hope that the community can use COBOLEval to track the performance of the latest models and build LLMs that help maintain the worldâ€™s supply of critical COBOL code.</p><hr/></article></div></div>
  </body>
</html>
