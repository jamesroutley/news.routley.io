<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bloop.ai/blog/evaluating-llms-on-cobol">Original</a>
    <h1>How well can LLMs write COBOL?</h1>
    
    <div id="readability-page-1" class="page"><div><article><p><img src="https://bloop-web-app.s3.eu-west-1.amazonaws.com/blog/evaluation-on-cobol-chart.png"/></p><p><strong>How well can LLMs write COBOL?</strong></p><p>LLMs are fast-changing the way that we write software. Over a million developers now <a href="https://www.linkedin.com/posts/ashtom_microsoft-has-over-a-million-paying-github-activity-7123051140115562497-7Hbq/">pay for GitHub Copilot</a> and recent breakthroughs in LLM reasoning have brought the dream of a <a href="https://www.cognition-labs.com/introducing-devin">fully AI Software Engineer</a> closer to reality. But while it’s not hard to find a demo of an LLM coding a website or a clone of Flappy Bird, not much is known about their ability to write code in older ‘legacy’ languages like COBOL.</p><p>The opportunity for LLM COBOL generation is huge. Although the language was first released in 1959, it continues to power critical systems - <a href="https://fortune.com/2023/09/26/github-ceo-wall-street-relies-software-developed-ai-next-financial-crisis-thomas-dohmke/">95% of US ATM transactions are processed in COBOL</a>. But it&#39;s not taught in computer science courses or bootcamps, and the engineers who write it professionally are steadily retiring. If LLMs could understand and write COBOL they could help maintain the <a href="https://www.microfocus.com/en-us/press-room/press-releases/2022/cobol-market-shown-to-be-three-times-larger-than-previously-estimated-in-new-independent-survey">800 billion lines</a> still in production today.  </p><p>So, how well can LLMs write COBOL? As far as we know, nobody has publicly tried to answer this question. Until now…</p><p><strong>Introducing COBOLEval</strong></p><p>Today we’re releasing COBOLEval, the first evaluation benchmark for LLM code completions in COBOL. It consists of 146 challenging coding problems that have been converted into COBOL from the widely-used <a href="https://github.com/openai/human-eval">HumanEval Python generation benchmark</a>. Each problem is paired with an average of 6 test cases. An LLM-generated solution has to pass all of them to be correct. We’re also releasing a test harness that you can use to evaluate your own models, as well as <em>mAInframer-1</em> - a series of open-source models based on CodeLlama that we’ve fine-tuned specifically to write COBOL - which outperform GPT-4.</p><p>You can get started with COBOLEval here: <a href="https://github.com/BloopAI/cobolEval">https://github.com/BloopAI/cobolEval</a></p><p><strong>From HumanEval to COBOLEval</strong></p><p><strong><em>Functions</em></strong></p><p>Converting HumanEval to COBOL isn’t as straightforward as it sounds. Each HumanEval problem consists of a <em>prompt</em>, a typed Python function signature and docstring, which is passed directly to an LLM, which then implements the body of the function.</p><pre><code><span>from</span><span> typing </span><span>import</span><span> List
</span>
<span></span><span>def</span><span> </span><span>has_close_elements</span><span>(</span><span>numbers</span><span>:</span><span> List</span><span>[</span><span>float</span><span>]</span><span>,</span><span> threshold</span><span>:</span><span> </span><span>float</span><span>)</span><span> </span><span>-</span><span>&gt;</span><span> </span><span>bool</span><span>:</span><span>
</span><span>    </span><span>&#34;&#34;&#34; Check if in given list of numbers, are any two numbers closer to each other than
</span><span>    given threshold.
</span><span>    &gt;&gt;&gt; has_close_elements([1.0, 2.0, 3.0], 0.5)
</span><span>    False
</span><span>    &gt;&gt;&gt; has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)
</span><span>    True
</span><span>    &#34;&#34;&#34;</span></code></pre><p>But this immediately poses a problem. COBOL is a procedural programming language; it doesn’t have functions.</p><p>It does, however, have subprograms. So we transform each problem into a COBOL program where arguments and return variables are defined in the <code>LINKAGE SECTION</code> so they can be passed and read from a calling program.</p><pre><code><span>       </span><span>IDENTIFICATION</span><span> </span><span>DIVISION</span><span>.</span><span>
</span><span>       </span><span>PROGRAM-ID</span><span>.</span><span> HAS-CLOSE-ELEMENTS</span><span>.</span><span>
</span>
<span>       </span><span>ENVIRONMENT</span><span> </span><span>DIVISION</span><span>.</span><span>
</span>
<span>       </span><span>INPUT-OUTPUT</span><span> </span><span>SECTION</span><span>.</span><span>
</span>
<span>       </span><span>DATA</span><span> </span><span>DIVISION</span><span>.</span><span>
</span>
<span>       </span><span>LINKAGE</span><span> </span><span>SECTION</span><span>.</span><span>
</span>
<span>       </span><span>01</span><span> LINKED-ITEMS</span><span>.</span><span>
</span><span>           </span><span>05</span><span> L-NUMBERS </span><span>OCCURS</span><span> </span><span>100</span><span> </span><span>TIMES</span><span> </span><span>INDEXED</span><span> </span><span>BY</span><span> NI </span><span>COMP-2</span><span>.</span><span>
</span><span>           </span><span>05</span><span> L-THRESHOLD </span><span>COMP-2</span><span>.</span><span>
</span><span>           </span><span>05</span><span> RESULT </span><span>PIC</span><span> </span><span>9</span><span>.</span><span>
</span>
<span>      </span><span>* Check if in given list of numbers, are any two numbers closer to each other than</span><span>
</span><span>      </span><span>* given threshold.</span><span>
</span><span>      </span><span>* &gt;&gt;&gt; has_close_elements([1.0, 2.0, 3.0], 0.5)</span><span>
</span><span>      </span><span>* False</span><span>
</span><span>      </span><span>* &gt;&gt;&gt; has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)</span><span>
</span><span>      </span><span>* True</span><span>
</span><span>      </span><span>*</span><span>
</span>
<span>      </span><span>* Complete the WORKING-STORAGE SECTION and the PROCEDURE DIVISION</span><span>
</span><span>      </span><span>* Store the result in the RESULT variable and mark the end of your program with END PROGRAM</span><span>
</span>
<span>       </span><span>WORKING-STORAGE</span><span> </span><span>SECTION</span><span>.</span></code></pre><p>This is the format of COBOLEval prompts that are passed to the LLM.</p><p><strong><em>Types</em></strong></p><p>COBOL’s type system is radically different to modern programming languages. Variables are declared with <code>PICTURE</code> clauses (<code>PIC</code> for short) which specify the number of characters they occupy in memory. For example, <code>PIC X(100)</code> is a string with 100 characters, while <code>PIC S9(10)</code> is a 10-digit signed integer. Unlike Python, COBOL doesn’t have variable-length strings, integers or arrays, so we fix these lengths to upper-bounds (no COBOLEval problems accept or return an array with a length greater than 100).</p><p>This gives us our mapping from Python to COBOL types:</p><pre><code><span>Int</span><span> </span><span>=&gt;</span><span> </span><span>PIC</span><span> </span><span>S9</span><span>(</span><span>10</span><span>)</span><span>
</span><span></span><span>Float</span><span> </span><span>=&gt;</span><span> </span><span>COMP</span><span>-</span><span>2</span><span>
</span><span></span><span>Str</span><span> </span><span>=&gt;</span><span> </span><span>PIC</span><span> </span><span>X</span><span>(</span><span>100</span><span>)</span><span>
</span><span></span><span>List</span><span>[</span><span>Int</span><span>]</span><span> </span><span>=&gt;</span><span> </span><span>OCCURS</span><span> </span><span>100</span><span> </span><span>TIMES</span><span> </span><span>INDEXED</span><span> </span><span>BY</span><span> </span><span>I</span><span> </span><span>PIC</span><span> </span><span>S9</span><span>(</span><span>10</span><span>)</span></code></pre><p>Note that some Python types, like <code>Any</code> or <code>Dict</code>, can’t easily be represented in COBOL. We ignore HumanEval problems that accept or return them. Luckily there aren’t many of them.</p><p><strong><em>Working-Storage Section</em></strong></p><p>The veteran COBOL programmers among you will have spotted a bug in the prompt program above. The <code>LINKAGE SECTION</code> and <code>WORKING-STORAGE SECTION</code> are the wrong way round. If we tried to compile it, we’d get an error.</p><p>Why are they in the wrong order? The problem is that - unlike modern languages (you’ll be used to hearing that by now) - COBOL does not have local variables. All variables - even temporary ones - that are used in the program logic have to be declared ahead o time in the <code>WORKING-STORAGE SECTION</code>.</p><p>Clearly, the LLM needs to generate the <code>WORKING-STORAGE SECTION</code> so that it can declare variables it will use in its solution. But at the same time, it needs to know the variables that have already been declared in the <code>LINKAGE SECTION</code>. COBOLs strict structure prevents an LLM from generating solutions in neat left-to-right order.</p><p>We offer two possible approaches. One is illustrated above: we swap the order of the sections in the prompt, and have the model generate the <code>WORKING-STORAGE SECTION</code> and the <code>PROCEDURE DIVISION</code> one after the other. We then reinsert the implemented <code>WORKING-STORAGE SECTION</code> into the program at the correct position. This approach is simple, but requires the LLM generalise beyond its training data (it won’t have seen many programs where the sections are out-of-order).</p><p>The other approach is to use a technique called <a href="https://openai.com/research/efficient-training-of-language-models-to-fill-in-the-middle">infilling</a>. Here, we decompose the program into <em>prefix</em>, <em>middle</em>, and <em>suffix</em> (delimited by the special tokens <code>&lt;PRE&gt;</code>, <code>&lt;MID&gt;</code> and <code>&lt;SUF&gt;</code>) and generate a completion in the order: <em>prefix</em>, <em>suffix</em>, <em>middle</em>. This allows us to <em>fill-in</em> code in the middle of a program.</p><p>If we wanted to fill in the third line of this Python function</p><div><pre><code><span><span><span><span><span>def</span><span> </span><span>factorial</span><span>(</span><span>n</span><span>)</span><span>:</span><span>
</span></span><span><span>  </span><span>if</span><span> n </span><span>&gt;</span><span> </span><span>1</span><span>:</span><span>
</span></span><span></span></span></span></span><span><span><span><span><span>    </span><span>return</span><span> n </span><span>*</span><span> factorial</span><span>(</span><span>n </span><span>-</span><span> </span><span>1</span><span>)</span><span>
</span></span><span><span>  </span><span>elif</span><span> n </span><span>==</span><span>1</span><span>:</span><span>
</span></span><span><span>    </span><span>return</span><span> </span><span>1</span></span></span></span></span></code></pre></div><p>Our infilling prompt would look like this (where the prompt is green, and the completion is red):</p><div><pre><code><span><span><span><span><span>&lt;</span><span>PRE</span><span>&gt;</span><span>def</span><span> factorial</span><span>(</span><span>n</span><span>)</span><span>:</span><span>
</span></span><span><span>  </span><span>if</span><span> n </span><span>&gt;</span><span> </span><span>1</span><span>:</span><span>
</span></span><span><span></span><span>&lt;</span><span>SUF</span><span>&gt;</span><span>  </span><span>elif</span><span> n </span><span>==</span><span>1</span><span>:</span><span>
</span></span><span><span>    </span><span>return</span><span> </span><span>1</span><span>
</span></span><span><span></span><span>&lt;</span><span>MID</span><span>&gt;</span></span></span></span></span><span><span><span><span><span>   </span><span>return</span><span> n </span><span>*</span><span> factorial</span><span>(</span><span>n </span><span>-</span><span> </span><span>1</span><span>)</span></span></span></span></span></code></pre></div><p>Back to COBOL, we can generate both the <code>WORKING-STORAGE SECTION</code> and the <code>PROCEDURE DIVISION</code> by prompting the LLM like this:</p><div><pre><code><span><span><span><span><span>&lt;</span><span>PRE</span><span>&gt;</span><span>
</span></span><span><span>       </span><span>IDENTIFICATION</span><span> </span><span>DIVISION</span><span>.</span><span>
</span></span><span><span>       </span><span>PROGRAM-ID</span><span>.</span><span>  SUM-OF-CUBES</span><span>.</span><span>
</span></span><span><span>       </span><span>ENVIRONMENT</span><span> </span><span>DIVISION</span><span>.</span><span>
</span></span><span>       
</span><span><span>       </span><span>INPUT-OUTPUT</span><span> </span><span>SECTION</span><span>.</span><span>
</span></span><span>
</span><span><span>       </span><span>DATA</span><span> </span><span>DIVISION</span><span>.</span><span>
</span></span><span><span></span><span>&lt;</span><span>SUF</span><span>&gt;</span><span>
</span></span><span><span>       </span><span>LINKAGE</span><span> </span><span>SECTION</span><span>.</span><span>
</span></span><span>
</span><span><span>       </span><span>01</span><span> LINKED-ITEMS</span><span>.</span><span>
</span></span><span><span>           </span><span>05</span><span> L-MAX-STEP </span><span>PIC</span><span> </span><span>S9</span><span>(</span><span>10</span><span>)</span><span>.</span><span>
</span></span><span><span>           </span><span>05</span><span> RESULT </span><span>PIC</span><span> </span><span>S9</span><span>(</span><span>10</span><span>)</span><span>.</span><span>
</span></span><span>
</span><span><span>      </span><span>* </span><span>
</span></span><span><span>      </span><span>* Given an integer number, return the sum of all the integers below it.</span><span>
</span></span><span><span>      </span><span>* </span><span>
</span></span><span><span>      </span><span>* Example:</span><span>
</span></span><span><span>      </span><span>* </span><span>
</span></span><span><span>      </span><span>* sum_of_cubes(3) == 1**3 + 2**3 == 9</span><span>
</span></span><span><span>      </span><span>* sum_of_cubes(5) == 100</span><span>
</span></span><span><span>      </span><span>*  </span><span>
</span></span><span>
</span><span><span>      </span><span>* Store the result in the RESULT variable and mark the end of your program with END PROGRAM</span><span>
</span></span><span>
</span><span></span></span></span></span><span><span><span><span><span>       </span><span>PROCEDURE</span><span> </span><span>DIVISION</span><span> </span><span>USING</span><span> LINKED-ITEMS</span><span>.</span><span>
</span></span><span>       
</span><span><span>           </span><span>PERFORM</span><span> </span><span>VARYING</span><span> STEP </span><span>FROM</span><span> </span><span>0</span><span> </span><span>BY</span><span> </span><span>1</span><span> 
</span></span><span><span>               </span><span>UNTIL</span><span> STEP </span><span>IS</span><span> </span><span>EQUAL</span><span> </span><span>TO</span><span> L-MAX-STEP
</span></span><span><span>               </span><span>COMPUTE</span><span> CUBE </span><span>=</span><span> STEP </span><span>*</span><span>*</span><span> </span><span>3</span><span>
</span></span><span><span>               </span><span>ADD</span><span> CUBE </span><span>TO</span><span> CUBE-SUM
</span></span><span><span>           </span><span>END-PERFORM</span><span>
</span></span><span><span>           </span><span>.</span><span>
</span></span><span><span>           </span><span>MOVE</span><span> CUBE-SUM </span><span>TO</span><span> RESULT</span><span>.</span><span>
</span></span><span><span>           </span><span>DISPLAY</span><span> </span><span>&#39;THE SUM OF THE CUBES IS &#39;</span><span> RESULT</span><span>.</span><span>
</span></span><span><span>           </span><span>GOBACK</span><span>.</span><span>
</span></span><span>
</span><span><span>       </span><span>END</span><span> </span><span>PROGRAM</span><span> SUM-OF-CUBES</span><span>.</span><span>
</span></span><span><span></span><span>&lt;</span><span>MID</span><span>&gt;</span><span>
</span></span><span><span>       </span><span>WORKING-STORAGE</span><span> </span><span>SECTION</span><span>.</span><span>
</span></span><span>       
</span><span><span>       </span><span>01</span><span> STEP         </span><span>PIC</span><span> </span><span>S9</span><span>(</span><span>10</span><span>)</span><span>.</span><span>
</span></span><span><span>       </span><span>01</span><span> CUBE         </span><span>PIC</span><span> </span><span>9</span><span>(</span><span>7</span><span>)</span><span>.</span><span>
</span></span><span><span>       </span><span>01</span><span> CUBE-SUM     </span><span>PIC</span><span> </span><span>9</span><span>(</span><span>7</span><span>)</span><span> </span><span>VALUE</span><span> </span><span>0</span><span>.</span></span></span></span></span></code></pre></div><p>We cut the <code>WORKING-STORAGE SECTION</code> out of the program, so the LLM first generates the solution logic in the <code>PROCEDURE DIVISION</code> and the special <code>&lt;MID&gt;</code> token, then declares the variables it used by generating the <code>WORKING-STORAGE SECTION</code>.</p><p><em>Note that this works best with models that have been trained to support infilling (e.g. CodeLlama).</em></p><p><strong><em>Putting it all together</em></strong></p><p>Each HumanEval problem is accompanied by a set of test cases.</p><pre><code><span>def</span><span> </span><span>check</span><span>(</span><span>candidate</span><span>)</span><span>:</span><span>
</span><span>    </span><span>assert</span><span> candidate</span><span>(</span><span>[</span><span>1.0</span><span>,</span><span> </span><span>2.0</span><span>,</span><span> </span><span>3.9</span><span>,</span><span> </span><span>4.0</span><span>,</span><span> </span><span>5.0</span><span>,</span><span> </span><span>2.2</span><span>]</span><span>,</span><span> </span><span>0.3</span><span>)</span><span> </span><span>==</span><span> </span><span>True</span><span>
</span><span>    </span><span>assert</span><span> candidate</span><span>(</span><span>[</span><span>1.0</span><span>,</span><span> </span><span>2.0</span><span>,</span><span> </span><span>3.9</span><span>,</span><span> </span><span>4.0</span><span>,</span><span> </span><span>5.0</span><span>,</span><span> </span><span>2.2</span><span>]</span><span>,</span><span> </span><span>0.05</span><span>)</span><span> </span><span>==</span><span> </span><span>False</span><span>
</span><span>    </span><span>assert</span><span> candidate</span><span>(</span><span>[</span><span>1.0</span><span>,</span><span> </span><span>2.0</span><span>,</span><span> </span><span>5.9</span><span>,</span><span> </span><span>4.0</span><span>,</span><span> </span><span>5.0</span><span>]</span><span>,</span><span> </span><span>0.95</span><span>)</span><span> </span><span>==</span><span> </span><span>True</span><span>
</span><span>    </span><span>assert</span><span> candidate</span><span>(</span><span>[</span><span>1.0</span><span>,</span><span> </span><span>2.0</span><span>,</span><span> </span><span>5.9</span><span>,</span><span> </span><span>4.0</span><span>,</span><span> </span><span>5.0</span><span>]</span><span>,</span><span> </span><span>0.8</span><span>)</span><span> </span><span>==</span><span> </span><span>False</span><span>
</span><span>    </span><span>assert</span><span> candidate</span><span>(</span><span>[</span><span>1.0</span><span>,</span><span> </span><span>2.0</span><span>,</span><span> </span><span>3.0</span><span>,</span><span> </span><span>4.0</span><span>,</span><span> </span><span>5.0</span><span>,</span><span> </span><span>2.0</span><span>]</span><span>,</span><span> </span><span>0.1</span><span>)</span><span> </span><span>==</span><span> </span><span>True</span><span>
</span><span>    </span><span>assert</span><span> candidate</span><span>(</span><span>[</span><span>1.1</span><span>,</span><span> </span><span>2.2</span><span>,</span><span> </span><span>3.1</span><span>,</span><span> </span><span>4.1</span><span>,</span><span> </span><span>5.1</span><span>]</span><span>,</span><span> </span><span>1.0</span><span>)</span><span> </span><span>==</span><span> </span><span>True</span><span>
</span><span>    </span><span>assert</span><span> candidate</span><span>(</span><span>[</span><span>1.1</span><span>,</span><span> </span><span>2.2</span><span>,</span><span> </span><span>3.1</span><span>,</span><span> </span><span>4.1</span><span>,</span><span> </span><span>5.1</span><span>]</span><span>,</span><span> </span><span>0.5</span><span>)</span><span> </span><span>==</span><span> </span><span>False</span></code></pre><p>We generate a COBOLEval calling program for each test case. The calling program defines the data and passes it to the LLM generated solution. It then writes the <code>RESULT</code> variable to a file.</p><pre><code><span>       </span><span>IDENTIFICATION</span><span> </span><span>DIVISION</span><span>.</span><span>
</span><span>       </span><span>PROGRAM-ID</span><span>.</span><span> CAR-RACE-COLLISION-CALL</span><span>.</span><span>
</span>
<span>       </span><span>ENVIRONMENT</span><span> </span><span>DIVISION</span><span>.</span><span>
</span>
<span>       </span><span>INPUT-OUTPUT</span><span> </span><span>SECTION</span><span>.</span><span>
</span>
<span>       </span><span>FILE-CONTROL</span><span>.</span><span>
</span>
<span>       </span><span>SELECT</span><span> OUTPUT-FILE </span><span>ASSIGN</span><span> </span><span>TO</span><span> </span><span>&#34;CAR-RACE-COLLISION.TXT&#34;</span><span>
</span><span>           </span><span>ORGANIZATION</span><span> </span><span>IS</span><span> </span><span>LINE</span><span> </span><span>SEQUENTIAL</span><span>
</span><span>           </span><span>STATUS</span><span> </span><span>IS</span><span> OUTPUT-FILE-STATUS</span><span>.</span><span>
</span>
<span>       </span><span>DATA</span><span> </span><span>DIVISION</span><span>.</span><span>
</span>
<span>       </span><span>FILE</span><span> </span><span>SECTION</span><span>.</span><span>
</span><span>       </span><span>FD</span><span> OUTPUT-FILE</span><span>.</span><span>
</span><span>       </span><span>01</span><span> OUTPUT-RECORD </span><span>PIC</span><span> </span><span>S9</span><span>(</span><span>10</span><span>)</span><span> </span><span>SIGN</span><span> </span><span>LEADING</span><span>.</span><span>
</span>
<span>       </span><span>WORKING-STORAGE</span><span> </span><span>SECTION</span><span>.</span><span>
</span>
<span>       </span><span>01</span><span> OUTPUT-FILE-STATUS </span><span>PIC</span><span> </span><span>X</span><span>(</span><span>02</span><span>)</span><span>.</span><span>
</span>
<span>       </span><span>01</span><span> LINKED-ITEMS</span><span>.</span><span>
</span><span>           </span><span>05</span><span> L-N </span><span>PIC</span><span> </span><span>S9</span><span>(</span><span>10</span><span>)</span><span>.</span><span>
</span><span>           </span><span>05</span><span> RESULT </span><span>PIC</span><span> </span><span>S9</span><span>(</span><span>10</span><span>)</span><span>.</span><span>
</span>
<span>       </span><span>PROCEDURE</span><span> </span><span>DIVISION</span><span>.</span><span>
</span>
<span>       </span><span>MOVE</span><span> </span><span>10</span><span> </span><span>TO</span><span> L-N
</span>
<span>       </span><span>CALL</span><span> </span><span>&#34;CAR-RACE-COLLISION&#34;</span><span> </span><span>USING</span><span> LINKED-ITEMS
</span>
<span>       </span><span>OPEN</span><span> </span><span>OUTPUT</span><span> OUTPUT-FILE
</span>
<span>       </span><span>IF</span><span> OUTPUT-FILE-STATUS </span><span>NOT</span><span> </span><span>=</span><span> </span><span>&#34;00&#34;</span><span>
</span><span>           </span><span>DISPLAY</span><span> </span><span>&#34;ERROR OPENING OUTPUT FILE&#34;</span><span>
</span><span>           </span><span>STOP</span><span> </span><span>RUN</span><span>
</span><span>        </span><span>END-IF</span><span>
</span>
<span>       </span><span>MOVE</span><span> RESULT </span><span>TO</span><span> OUTPUT-RECORD
</span><span>       </span><span>WRITE</span><span> OUTPUT-RECORD
</span>
<span>        </span><span>IF</span><span> OUTPUT-FILE-STATUS </span><span>NOT</span><span> </span><span>=</span><span> </span><span>&#34;00&#34;</span><span>
</span><span>            </span><span>DISPLAY</span><span> </span><span>&#34;ERROR WRITING TO OUTPUT FILE&#34;</span><span>
</span><span>            </span><span>STOP</span><span> </span><span>RUN</span><span>
</span><span>        </span><span>END-IF</span><span>
</span>
<span>        </span><span>CLOSE</span><span> OUTPUT-FILE</span></code></pre><p>Solution outputs are compared to the true values and a score is calculated. The COBOLEval repo includes an evaluation harness that fully automates this process. <em>Note: COBOLEval uses the open-source GnuCOBOL compiler.</em></p><p><strong>So how good are they?</strong></p><p>We have a benchmark, so how well can state-of-the-art LLMs write COBOL? We calculated pass@1 scores (with <em>temperature = 0</em>) for some widely used models.</p><table><thead><tr><th>Model</th><th>Pass@1</th><th>% Compile</th></tr></thead><tbody><tr><td><span>GPT 3.5 Turbo</span></td><td><span>4.11</span></td><td><span>19.17</span></td></tr><tr><td><span>GPT-4</span></td><td><span><strong>8.90</strong></span></td><td><span>47.94</span></td></tr><tr><td><span>CodeLlama-7b</span></td><td><span>0.68</span></td><td><span>25.34</span></td></tr><tr><td><span>CodeLlama-13b</span></td><td><span>1.36</span></td><td><span>13.01</span></td></tr><tr><td><span>CodeLlama-34b</span></td><td><span>2.05</span></td><td><span><strong>78.76</strong></span></td></tr></tbody></table><p>GPT-4 - the best-performing model - generates a correct solution for 10.27% of problems. Compare this to HumanEval, where it solves <em>67%</em> of problems. CodeLlama, one of the best open-source coding models, fares even worse, with the 34b variant only clocking 2%. COBOLEval is hard.</p><p>Looking at the failure cases, we can see that state-of-the-art LLMs struggle to generate COBOL that even compiles. Only 47.94% of GPT-4 generated solutions compile with GnuCOBOL.</p><pre><code><span>          </span><span>PERFORM</span><span> </span><span>VARYING</span><span> I </span><span>FROM</span><span> Y </span><span>BY</span><span> </span><span>-1</span><span> </span><span>UNTIL</span><span> I </span><span>&lt;</span><span> X
</span><span>               </span><span>IF</span><span> I MOD </span><span>2</span><span> </span><span>=</span><span> </span><span>0</span><span> </span><span>THEN</span><span>
</span><span>                   </span><span>MOVE</span><span> I </span><span>TO</span><span> MAX-EVEN
</span><span>                   </span><span>EXIT</span><span> </span><span>PERFORM</span><span>
</span><span>               </span><span>END-IF</span><span>
</span><span>           </span><span>END-PERFORM</span><span>
</span></code></pre><p>Here GPT-4 has tried to use the <code>MOD</code> function without preceding it with the <code>FUNCTION</code> keyword.</p><p><strong><em>mAInframer-1</em></strong></p><p>We’re also releasing <em>mAInframer-1</em>, a series of models that we’ve fine-tuned to write COBOL. You can download them here: <a href="https://huggingface.co/bloopai">https://huggingface.co/bloopai</a></p><table><thead><tr><th>Model</th><th>Pass@1</th><th>% Compile</th></tr></thead><tbody><tr><td><span>mAInframer-7b</span></td><td><span>6.16</span></td><td><span>69.17</span></td></tr><tr><td><span>mAInframer-13b</span></td><td><span>8.9</span></td><td><span>54.1</span></td></tr><tr><td><span>mAInframer-34b</span></td><td><span><strong>10.27</strong></span></td><td><span><strong>73.97</strong></span></td></tr></tbody></table><p>All three mAInframer models considerably outperform CodeLlama models, while the 34b model gets a higher pass@1 than GPT-4! More details about how we did that coming soon 😀</p><p><strong>What’s next?</strong></p><p>There’s clearly a lot of room to improve LLM-generated COBOL. We hope that the community can use COBOLEval to track the performance of the latest models and build LLMs that help maintain the world’s supply of critical COBOL code.</p><hr/></article></div></div>
  </body>
</html>
