<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://amodernist.com/texts/fun-c.html">Original</a>
    <h1>Consistently Making Wrong Decisions Whilst Writing Recreational C</h1>
    
    <div id="readability-page-1" class="page">
<header id="top">
<b id="name">Webpresence of Philip Kaludercic</b>
<nav>
<a href="https://norasandler.com/">Start</a> |
<a href="https://norasandler.com/index.html">Index</a> |
<a href="https://norasandler.com/about.html">About</a> |
<a href="https://norasandler.com/index.html#feed">⚛ Feed</a> |
<a href="https://norasandler.com/#email">Contact</a>
</nav>
</header>

<p>For the past few days I have had a lot of fun polishing a small
program written in C. I call it “<a href="https://codeberg.org/pkal/trip">Trip</a>” and the idea is to
automatically intercept specific Libc functions and simulate their
failure.</p>
<p>The background for writing a tool like this, is that I am a TA for a
systems-programming course at my university. All assignments are to be
written in C, and we place emphasis on robustness and portability. My
intention is to make it easier to provoke specific errors that would
usually only occur when the operating system refuses or is incapable of
providing the (finite) resources it virtualises (like memory, time and
access to peripheral devices).</p>
<p>One example, that is interesting when discussion the example of how a
Unix/CLI shell is implemented, is what happens when the
<code>fork(2)</code> system call fails — and what the appropriate way to
handle this error is. Out of habit, a lot of people would just write</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>pid_t pid <span>=</span> fork<span>();</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span>if</span> <span>(</span>pid <span>==</span> <span>-</span><span>1</span><span>)</span> <span>{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  perror<span>(</span><span>&#34;fork&#34;</span><span>);</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  exit<span>(</span>EXIT_FAILURE<span>);</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span>/* ... */</span></span></code></pre></div>
<p>But running into this case is tricky, as <code>fork</code> usually
only fails when the number of (dead or alive) processes on a system is
too high, which is a generally uncomfortable situation.</p>
<p>So the problem I am interested in is a <em>comfortable</em> way to
<em>intentionally</em> but <em>safely</em> provoke <code>fork</code> to
fail.</p>
<p>One could use <code>prlimit -u</code> to limit the maximal number of
processes or GDB’s <code>return</code> command to modify the process
state and return the “right” value indicating an error had occurred.
While feasible, it is not what I wanted.</p>
<p>Instead, what I came up with looks like this:</p>
<pre><code>icterid$ trip fork:0.5 bash # after this point we are in a new shell:
icterid$ date
bash: fork: Cannot allocate memory
icterid$ date
Sun Jun 16 03:59:21 PM CEST 2024
icterid$ date
bash: fork: retry: Resource temporarily unavailable
bash: fork: retry: Resource temporarily unavailable
Sun Jun 16 03:59:28 PM CEST 2024</code></pre>
<p>This demonstrates the behaviour of Bash, when on average
<code>fork(2)</code> were to fail 50% of the time. As you can see, it
might set <code>errno</code> to <code>ENOMEM</code>, in which case Bash
gives up immediately. Sometimes it works, and if <code>errno</code> is
set to <code>EAGAIN</code> then it tries to handle the request a few
times, and in this case eventually succeeding. In the last case, it
waits for a bit between attempts, which makes sense as the number of
processes on a system is time-dependent and will hopefully decrease.</p>
<p>Additionally, we could also list multiple functions that could fail,
give these different chances of failure and fix specific
<code>errno</code> values that we want to provoke.</p>
<p>I think that this is a simple and neat tool that can help students
think about what robust error handling entails.</p>

<p>My intention behind writing this text isn’t to advertise “Trip”. The
core functionality isn’t what is fun to work on. What I want to
highlight, are some of the inane decisions I insisted on following
through, that led me to work on the program for over three years (on and
off) before getting it into a functional state.</p>
<h2 id="the-core-mechanism">The core mechanism</h2>
<p>As mentioned above, one idea would be to take a debugger-like
approach and use something like <code>ptrace</code> to control and
manipulate a program.</p>
<p>But I did not do that, instead I use the <a href="https://man.bsd.lv/Linux-5.13/ld.so.8#LD_PRELOAD"><code>LD_PRELOAD</code>
hack</a>. By setting this environmental variable, we can instruct the
dynamic linker/loader (<code>ld.so</code>) to look up the definition of
certain symbols in a shared object of our own, before it checks the
usual places, such as the actual standard library
(<code>libc.so</code>).</p>
<p>The reasonable approach would be to have one executable and one
shared object, and have the executable set <code>LD_PRELOAD</code> to
point to the shared object before <code>exec</code>uting the intended
program (e.g. <code>bash</code> in the above example).</p>
<p>But no, <em>then I’d have to figure out where to find the shared
object</em> and <em>the user would have to install <strong>two</strong>
files</em>! Just imagine all the wasted disk space of having a multi
kilobyte ELF headers lying around. Entirely unreasonable!</p>
<p>Instead, I want one file, which is both an executable file, and a
shared object (seeing as both are just ELF files with different “Types”,
<code>DYN</code> vs <code>EXEC</code>). An example of this already
existing in some form is the aforementioned shared object for the C
standard library:</p>
<pre><code>icterid$ /usr/lib/x86_64-linux-gnu/libc.so.6
GNU C Library (Debian GLIBC 2.36-9+deb12u7) stable release version 2.36.
Copyright (C) 2022 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.
There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.
Compiled by GNU CC version 12.2.0.
libc ABIs: UNIQUE IFUNC ABSOLUTE
Minimum supported kernel: 3.2.0
For bug reporting instructions, please see:
&lt;http://www.debian.org/Bugs/&gt;.</code></pre>
<p>Glibc does this by <a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=Makerules;h=275110dda82fa77e91e7064a77e98ca2bb19d5db;hb=HEAD#l600">setting</a>
<a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=csu/version.c;h=bf402d4afc8aed6cebde2f0ed3ce6b4957e2c900;hb=HEAD#l70">a
custom</a> <a href="https://sourceware.org/binutils/docs/ld/Entry-Point.html">entry
point</a>.</p>
<p>Instead Trip compiles a regular <a href="https://en.wikipedia.org/wiki/Position-independent_code">position
independent executable</a>, which should be sufficient for
<code>ld.so</code> to preload, but it is not. If you try that, you get
the error message</p>
<pre><code>$ LD_PRELOAD=.../preload-this ./execute-this
ERROR: ld.so: object &#39;.../preload-this&#39;&#39; from LD_PRELOAD cannot be preloaded (cannot dynamically load position-independent executable): ignored.
this is the output ouf ./execeute-this.
...</code></pre>
<p>which is not what I want. Luckly, due to a <a href="https://gist.github.com/x-projs/6820491646f9d01980a7eadb16564ddf">helpful
program</a> by Yubo Xie, I found a trick to circumvent this draconian
ordinance. And it involves editing the ELF file generated by GCC with
the intent of flipping a single bit (<code>DF_1_PIE</code>). With this
change, <code>ld.so</code> doesn’t <em>object</em>, while the file
remains executable. So that means I can preload the executable being
executed as it <code>exec</code>utes some other program. This brings me
to the next step,</p>
<h2 id="preloading-onself">Preloading onself</h2>
<p>This is not <em>that</em> interesting, but worth mentioning
nevertheless. The issue is that <code>LD_PRELOAD</code> requires an
absolute path to the shared object file it should use. But using
<code>argv[0]</code> I can only determine what the string was that
invoked Trip.</p>
<p>Seeing as <code>LD_PRELOAD</code> is not portable<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a>, we
can use a Linux-specific hack to determine what the file of the program
currently being executed. This involves the <code>/proc</code>
filesystem, specifically the <code>/proc/self</code> directory.</p>
<p>As you might know, each Process with some PID has a
<code>/proc/[PID]/</code> directory with process metadata, such as the
command line arguments, the environmental variables, file descriptors,
and so on exposed using the file system interface. The
<code>/proc/self/</code> is a shorthand for the <code>/proc/[PID]</code>
directory of the current process. And in this directory, there is a
symbolic link called <code>exe</code>, that points to the file we are
looking for.</p>
<p>So the absolute path is just a <code>readlink(2)</code> away, that we
can use to construct the environmental assignment that we realise using
<code>execvpe(2)</code>, a GNU extension of <code>execvp</code> that
allows passing a list of <code>&#34;VAR=VALUE&#34;</code> strings to specify the
environment right after <code>exec</code>uting the new file (we use
<code>getopt(3)</code> to parse command line options, hence the
<code>optint</code>):</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>execvpe<span>(</span>argv<span>[</span>optind<span>],</span> argv <span>+</span> optind<span>,</span> <span>(</span><span>char</span><span>*[])</span> <span>{</span>preload<span>,</span> conf<span>,</span> NULL<span>});</span></span></code></pre></div>
<p>What’s <code>conf</code>? What we did not discuss up until now, is
how we preserve state between Trip “the executable” and Trip “the
library”. That is were we use <code>conf</code>, a special environmental
variable encoding the options specified when invoking Trip.</p>
<h2 id="trip_configuration"><code>____TRIP_CONFIGURATION</code></h2>
<p>We are too deep into this rabbit-hole to give up now. There is no
going back. Once again, there will be an obvious and necessary decision,
though it might offend a few of the <em>bluenoses</em> amongst us.</p>
<p>As a reminder, we invoke Trip with a list of functions, optionally
specifying a chance it should “trip” (by default
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>X</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">P(X) = 1</annotation></semantics></math>)
and optionally fixing a specific <code>errno</code> value to set
(otherwise this will also decided on randomly from the list of known
<code>errno</code> values for the function, more on that below).</p>
<p>E.g.,</p>
<pre><code>mkdir:0.25:ELOOP</code></pre>
<p>says that <code>mkdir(2)</code> will fail 25% of the time, but when
it does it will set <code>errno</code> to <code>ELOOP</code> (“Too many
levels of symbolic links”).</p>
<p>Environmental variables give us a C string to encode the value. So no
NUL-bytes! This means we cannot just encode arbitrary binary data, such
as a <code>struct</code> containing a floating point value, that
<em>might</em> include a <a href="https://float.exposed/0x3fe0000000000000">NUL-byte on
<code>char</code> level</a>.</p>
<p>Instead, we will to pass a list of triples, respectively
specifying,</p>
<ol type="1">
<li>The function to trip</li>
<li>A chance encoded by a floating-point value serialised in hexadecimal
(<code>%a</code>), to use a radix with a higher information density – if
we disregard the <code>0x</code> prefix…</li>
<li>An <code>errno</code> value, also in hexadecimal, or <code>0</code>
to indicate an absence.</li>
</ol>
<p>How do we encode the triple? By using ASCII group separators of
course. <code>ascii(7)</code> tells us these 35 in octal encodes these.
And the list? Isn’t it obvious… By using ASCII record separators,
<em>naturellement</em> (36 in octal). As these aren’t pretty to write,
we define two macros,</p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span>#define GS </span><span>&#34;</span><span>\035</span><span>&#34;</span><span>           </span><span>/* group separator */</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span>#define RS </span><span>&#34;</span><span>\036</span><span>&#34;</span><span>           </span><span>/* record separator */</span></span></code></pre></div>
<p>where the octal encoding of arbitrary charachters comes to use (a lot
of people are just familiar with the one special case, <code>&#39;\0&#39;</code>
to encode the NUL-byte, which is next to <code>chmod</code> probably one
of the most common places where octal notation is used – be it that it
coincides with most other bases).</p>
<p>To construct the value itself, I’d like to use
<code>printf(3)</code>-style format strings, to make parsing the value
easier, but now much memory will I need? Just any arbitrary constant
won’t do it! So I’ll allocate it dynamically, but here again, a mere
<code>malloc</code> is so pedestrian. Instead using
<code>open_memstream(3)</code> we write into a <code>FILE*</code> that
will construct a string of sufficient size as needed.</p>
<p>Now we can write,</p>
<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>fprintf<span>(</span>h<span>,</span> <span>&#34;</span><span>%s</span><span>&#34;</span> GS <span>&#34;</span><span>%a</span><span>&#34;</span> GS <span>&#34;</span><span>%x</span><span>&#34;</span> RS<span>,</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>        entries<span>[</span>i<span>].</span>name<span>,</span> entries<span>[</span>i<span>].</span>chance<span>,</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>        entries<span>[</span>i<span>].</span>error<span>)</span></span></code></pre></div>
<p>which also makes use of C’s string concatenation of literals, as
<code>GS</code> and <code>RS</code> are just strings that are
substituted by the preprocessor.</p>
<p>Now we have encoded the intended state of the library. As discussed,
we set this while <code>exec</code>ing and later on will decode it when
the library is initialised. But how does that happen? Some brief
comments on the topic follow below.</p>
<h2 id="break-on-through-to-the-other-side-of-the-moon">Break on through
to the other side of the moon</h2>
<p>As we are relying on <code>LD_PRELOAD</code>, all the functions that
we intend to support, will have a little stump which either will invoke
the function in the usual fashion or simulate a failure. To decide which
of the two we should do, Trip exposes a little function called
<code>____trip_should_fail</code> (the <code>_</code>s indicate that it
is <em>very</em> internal).</p>
<p>Basically it checks the configuration and rolls a dice if necessary.
But to do this, we first have to parse the configuration. To this end,
begin <code>____trip_should_fail</code> by calling the sensibly named
function called <code>init</code>.</p>
<p>But wait, seeing the invocation of this function depends on the
execution of the tripped program, which might involve multiple threads
or otherwise concurrent execution, what happens when two functions wish
to check a yet-uninitialised <code>____trip_should_fail</code>
contemporaneously? Why, that could mean that the internal state might be
initialised twice over, leaving us in an inconsistent disarray.</p>
<p>We might use a kind of “lock”, e.g. <code>pthread_mutex</code> but
consider the costs of depending on <em>yet another</em> library, not to
speak of the enormous overhead that passive locking effectuates!</p>
<p>No, we need something more <sub>fancy</sub> appropriate. Luckly, C11
has just the thing: <code>atomic_flag</code>! By statically allocating
such a flag <em>inside</em> <code>init</code>,</p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span>static</span> atomic_flag done <span>=</span> ATOMIC_FLAG_INIT<span>;</span></span></code></pre></div>
<p>we can use <code>atomic_flag_test_and_set</code> to ensure that only
one execution will set the flag. The others we keep busy using a naive
spin-lock, we release as soon as the “chosen one” (whoever first
completed <code>atomic_flag_test_and_set</code>) parses the state and
unlocks the spin-lock.</p>
<p>A nice of example of non-blocking synchronisation. I just think there
is something neat about it.</p>
<h2 id="as-an-aside-parsing-errno">As an aside, parsing
<code>errno</code></h2>
<p>One thing I omitted to mention above is how we convert a symbol
representation of an <code>errno</code> value, such as
<code>ELOOP</code>, <code>EAGAIN</code>, <code>ENOENT</code>, … into a
hexadecimal number. The last part is easy, as soon as I have the
numerical representation we use the <code>%x</code> format string (we
have seen that part already). The more interesting part is how the
rest.</p>
<p>Here, some might argue that I could just define an associative array,
of the form</p>
<div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span>#define ENTRY</span><span>(</span><span>e</span><span>)</span><span> </span><span>{</span><span> </span><span>.</span><span>name </span><span>=</span><span> </span><span>#</span><span>e</span><span>,</span><span> </span><span>.</span><span>val </span><span>=</span><span> e </span><span>},</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span>struct</span> errno_names <span>{</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span>char</span> <span>*</span>name<span>;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span>int</span> val<span>;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span>}</span> names<span>[]</span> <span>=</span> <span>{</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>ENTRY<span>(</span>ELOOP<span>),</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>ENTRY<span>(</span>EAGAIN<span>),</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>ENTRY<span>(</span>ENOENT<span>),</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span>/* ... */</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>but where’s the fun in that? Instead, how about this? Each time we
want to look up what <code>ELOOP</code> does, we manually invoke
<code>cpp</code> (the standalone preprocessor) and just write the value
we wish to expand into its standard input? And what better tool for that
than <code>popen(3)</code>, <code>fopen(3)</code>’s lesser known
relative (with alleged ties to <code>system(3)</code>)?</p>
<p>But the issue is, that with <code>popen(3)</code>, we can only read
<em>or</em> write, quote the Linux manpage,</p>
<blockquote>
<p>Since a pipe is by definition unidirectional, the type argument may
specify only reading or writing, not both; the resulting stream is
correspondingly read-only or write-only.</p>
</blockquote>
<p><em>Pity</em>, the unimaginative and ill-willed might say.
<em>No</em>, I retort, there is a way! Remember, gentle reader that
<code>popen</code> takes a shell command. We can easily include a pipe
in there, and with a little <code>echo</code> inject the input into the
command being executed. So in effect, to resolve <code>ELOOP</code>, we
execute</p>
<pre><code>echo &#34;ELOOP&#34; | cpp -include errno.h</code></pre>
<p>and then read the output, until we encounter a lone number, that is
the value we were looking for! We just have to skip over some noise to
get to this point (try executing the above yourself, and be surprise to
see what you see).</p>
<p>There remains a nibble to quibble! <em>Where do you get the memory
for that command, which you pass to <code>popen(2)</code></em>, the
irksomely inquisitive inquire inappropriately. Why, we just allocate it
on the stack! After all, if you invoke <code>snprintf</code> the right
way, it will tell you how much space a format string will require. We
reserve the requisive space with a simple VLA, and <em>bada-bing
bada-bum</em>, done.</p>
<p>But do we really want to invoke <code>sprintf</code> ourselves
<strong>twice</strong>? Here’s the shtick: We don’t. Instead, we put on
our intermediate macrology hats and summon this construct:</p>
<div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span>FILE</span> <span>*</span>cpp<span>;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>$sprintf<span>(</span>cmd<span>,</span> <span>&#34;echo </span><span>\&#34;%s\&#34;</span><span> | cpp -include errno.h&#34;</span><span>,</span> name<span>)</span> <span>{</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    cpp <span>=</span> popen<span>(</span>cmd<span>,</span> <span>&#34;r&#34;</span><span>);</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Here, <code>$sprintf</code> is a macro (we needlessly make use of the
fact that dollar-signs are (apparently<a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a>)
valid constituents of identifiers), which will format some data into a
local variable called <code>cmd</code>, visible only in the subsequent
block. How done this? Using the old trick, that expands the above to a
<code>for</code>-loop that executes exactly once. In effect, it would
look something like this:</p>
<div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span>FILE</span> <span>*</span>cpp<span>;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span>for</span> <span>(</span><span>char</span> cmd<span>[</span>snprintf<span>(</span>NULL<span>,</span> <span>0</span><span>,</span> <span>&#34;...&#34;</span><span>,</span> name<span>)</span> <span>+</span> <span>1</span><span>],</span> c <span>=</span> <span>1</span><span>;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>     c <span>==</span> <span>1</span> <span>&amp;&amp;</span> <span>(</span>snprintf<span>(</span>buf<span>,</span> <span>sizeof</span> buf<span>,</span> <span>&#34;...&#34;</span><span>,</span> name<span>),</span> <span>1</span><span>);</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>     c <span>=</span> <span>0</span><span>)</span> <span>{</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    cpp <span>=</span> popen<span>(</span>cmd<span>,</span> <span>&#34;r&#34;</span><span>);</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Note that the second <code>sprintf</code> is executed only once, due
to the short-circuiting of <code>&amp;&amp;</code> and that we disregard
the return value of <code>sprintf</code> even though tisn’t
necessary.</p>
<p>In Reality, we add some <code>__COUNTER__</code> magic on top to
avoid variable capture (a problem which we do not encounter), which
requires us to glue together new symbols. Business as usual for the
hat-wearers.</p>
<h2 id="one-more-time">One more time</h2>
<p>We were adroitly reticent on a crucial matter, up until now. But
behold, as all cards are now exposed, for all to see, for all detest and
abhore!</p>
<p>I never really thought about it, but there is no easy,
machine-readable way to figure out what <code>errno</code> values a
function might set. It is not encoded in the type system (if we might
even speak of such a thing), and parsing it out of the man pages is not
something I’d like to imagine doing reliably. So I must satisfy myself
by manually writing these facts down. And this turns out to be the
bottleneck of the entire operation.</p>
<p>We write these down, in a custom file format. In effect, these just
list blocks of this form:</p>
<pre><code>errno   ENOMEM
fail    NULL
name    strdup
params  const char *s
return  char *</code></pre>
<p>separated by empty lines. How does this help us? Easy, we use a
little bit of AWK to convert these into C files. But do I really want to
write C code in AWK? Perhaps, but not today (or whenever I wrote this
initially). So instead, I define a little macro in C and convert the
block into an expression that the macro will use. That will look like
this:</p>
<div id="cb15"><pre><code><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>DEF<span>(</span><span>char</span> <span>*,</span> strdup<span>,</span> <span>(</span><span>const</span> <span>char</span> <span>*</span>s<span>),</span> <span>(</span> s<span>),</span> <span>(</span>NULL<span>),</span> ENOMEM<span>)</span></span></code></pre></div>
<p>When compiling the definition, this will expand to the kind of
function we described above: This will be our definition of
<code>strdup</code>, which <code>LD_PRELOAD</code> injects into the real
executable and calls <code>____trip_should_fail</code> from!</p>
<p>And while we are at it, the most devilishly delightful stratagem
remains: We need a table of all functions inside of the
<code>trip</code> module itself, among other things to implement the
<code>-l</code> flag that lists all supported functions. And while we
could create a temporary file with the requisite data, and
<code>#include</code> that as usual, why bother our destitute disk and
not just inject what we need right into the array?</p>
<div id="cb16"><pre><code><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span>/* list of known commands */</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span>#define DEF</span><span>(</span><span>ret</span><span>,</span><span> name</span><span>,</span><span> params</span><span>,</span><span> args</span><span>,</span><span> fail</span><span>,</span><span> </span><span>...)</span><span> </span><span>{</span><span> </span><span>#</span><span>name</span><span>,</span><span> </span><span>{</span><span> __VA_ARGS__ </span><span>}},</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span>static</span> <span>struct</span> entry_name <span>{</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span>char</span> <span>*</span>name<span>;</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span>int</span> errs<span>[</span><span>256</span><span>/</span><span>sizeof</span><span>(</span><span>int</span><span>)-</span><span>sizeof</span><span>(</span><span>char</span><span>*)];</span> <span>/* adjust if necessary */</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span>}</span> names<span>[]</span> <span>=</span> <span>{</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span>#include </span><span>&#34;/dev/stdin&#34;</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span>};</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span>#undef DEF</span></span></code></pre></div>
<p>After a moment, I am certain everyone will realise that including
from <code>/dev/sdtdin</code> means that we are reading from the
standard input of the compiler herself! But what will the input be?
Here, as we are knee-deep into GNU-isms we use a target-specific
variable assignment, that will take effect only when compiling
<code>trip.c</code> to <code>trip.o</code>:</p>
<div id="cb17"><pre><code><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span>trip.o:</span><span> CC</span> <span>:=</span><span> grep -h &#39;^DEF&#39; </span><span>$(</span><span>GENSRC</span><span>)</span><span> | sort -k2,2d -t, | </span><span>$(</span><span>CC</span><span>)</span><span> </span><span>\</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span>              -DCOMPILER=&#34;\&#34;</span><span>$(</span><span>shell</span><span> </span><span>$(</span><span>CC</span><span>)</span><span> --version | sed 1q</span><span>)</span><span>\&#34;&#34;</span></span></code></pre></div>
<p>Where <code>GENSRC</code> are the list of files containing
<code>DEF</code> forms. Yes, we <code>grep</code> through all of these,
sort by the function name (as we of course wish to use
<code>bsearch(3)</code> later on when looking up an entry) and then pipe
this into the C compiler<a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a>. As prior to the
<code>#include</code> statement, we have re-defined <code>DEF</code>, we
will discard the uninteresting arguments and only use what we need to
construct the table in a single go.</p>
<p>The best part about this is watching the output of
<code>make</code>:</p>
<pre><code>$ time make -j8
awk -f gen.awk db/stdio.db &gt; db/stdio.c
awk -f gen.awk db/stdlib.db &gt; db/stdlib.c
awk -f gen.awk db/string.db &gt; db/string.c
awk -f gen.awk db/sys-socket.db &gt; db/sys-socket.c
awk -f gen.awk db/unistd.db &gt; db/unistd.c
cc -std=c11 -Wall -Wextra -Wformat=2 -Wuninitialized -Warray-bounds -Os -pipe -fsanitize=undefined,nonnull-attribute -fhardened -fanalyzer  -ldl -fanalyzer -fsanitize=undefined,nonnull-attribute -fhardened  fix-pie.c   -o fix-pie
cc -std=c11 -Wall -Wextra -Wformat=2 -Wuninitialized -Warray-bounds -Os -pipe -fsanitize=undefined,nonnull-attribute -fhardened -fanalyzer   -c -o db/string.o db/string.c
cc -std=c11 -Wall -Wextra -Wformat=2 -Wuninitialized -Warray-bounds -Os -pipe -fsanitize=undefined,nonnull-attribute -fhardened -fanalyzer   -c -o db/stdio.o db/stdio.c
cc -std=c11 -Wall -Wextra -Wformat=2 -Wuninitialized -Warray-bounds -Os -pipe -fsanitize=undefined,nonnull-attribute -fhardened -fanalyzer   -c -o db/stdlib.o db/stdlib.c
cc -std=c11 -Wall -Wextra -Wformat=2 -Wuninitialized -Warray-bounds -Os -pipe -fsanitize=undefined,nonnull-attribute -fhardened -fanalyzer   -c -o db/sys-socket.o db/sys-socket.c
cc -std=c11 -Wall -Wextra -Wformat=2 -Wuninitialized -Warray-bounds -Os -pipe -fsanitize=undefined,nonnull-attribute -fhardened -fanalyzer   -c -o db/unistd.o db/unistd.c
grep -h &#39;^DEF&#39; db/stdio.c db/stdlib.c db/string.c db/sys-socket.c db/unistd.c | sort -k2,2d -t, | cc -DCOMPILER=&#34;\&#34;cc (GCC) 14.1.1 20240522 (Red Hat 14.1.1-4)\&#34;&#34; -std=c11 -Wall -Wextra -Wformat=2 -Wuninitialized -Warray-bounds -Os -pipe -fsanitize=undefined,nonnull-attribute -fhardened -fanalyzer   -c -o trip.o trip.c
cc -o trip db/stdio.o db/stdlib.o db/string.o db/sys-socket.o db/unistd.o trip.o -ldl -fanalyzer -fsanitize=undefined,nonnull-attribute -fhardened
./fix-pie trip

real    0m1.177s
user    0m1.504s
sys 0m0.170s</code></pre>
<p>Another fun thing is that this breaks LSP servers…</p>
<p>And there we have it. These were the most fun highlights of my little
hobby program. There are a few more points of interest, such as
function-internal <code>typedef</code>s, a custom <code>assert</code>
implementation, and a lagged Fibonacci random number generator taken
from <a href="https://www-cs-faculty.stanford.edu/~knuth/taocp.html">TAOCP</a>,
just to quote Knuth in a comment, the persistent usage of
<code>dprintf</code> and user-dependent installation destinations, but
those interested in that can take a look on their own. I’m done
explaining my code – as the saying goes, if it was hard to write, it
should be hard to read!</p>
<hr/>
<p>Reflecting on the program, and having reminded myself of the internal
structure over the last few days, I do think that “polishing” is the
right word to describe what I enjoy. Compared to CS homework
assignments, competitive programming or the hacks that keep my servers
alive, the changes I make to this program are increasingly insignificant
and the commit messages are progressively elaborate. I get to pin-point
my focus on as little of a fragment of the code as I wish, and
pointlessly rewrite it to no semantic effect. While at it, I get to try
out ideas I had but no opportunity to apply and to skim manuals and
standards for inspiration on what I could do.</p>
<p>It is obvious even to me that this isn’t everyone’s idea of a fun
weekend, but for me there is something to it — and I don’t just mean the
unvarying grin on my face as I explain to a visibly disturbed person how
Trip works — especially if I know that I actually should be doing other
stuff.</p>



</div>
  </body>
</html>
