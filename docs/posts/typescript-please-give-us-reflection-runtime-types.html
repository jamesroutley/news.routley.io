<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/akutruff/typescript-needs-types">Original</a>
    <h1>TypeScript please give us reflection/runtime types</h1>
    
    <div id="readability-page-1" class="page"><article>
        <span>
            <time datetime="2023-07-06">06 Jul 2023</time>
        </span>
        
        <section>
            <!--kg-card-begin: markdown--><p>In 2023, the way to use AES is AES-GCM. Anything else is very unlikely to make sense. We might not like that, we might wish OCB hadn‚Äôt been patented, but with hardware support in most processors these days GCM is both faster than the alternatives, ubiquitous, and just tolerable to implement.</p>
<p>Still, I don‚Äôt want to use AES-GCM, I want to use XAES-256-GCM/11, which has a number of nice properties and only the annoying defect of not existing.</p>
<p>The problem with AES-GCM is that its nonce is a little too small to comfortably select at random. At 96 bit, the probability of a <a href="https://en.wikipedia.org/wiki/Birthday_attack?ref=words.filippo.io">birthday bound</a> collision becomes uncomfortable (2<sup>-32</sup>) after a few billion messages (2<sup>32</sup>), and <a href="https://eprint.iacr.org/2016/475?ref=words.filippo.io">the consequences of a collision are catastrophic</a>.<sup><a href="#fn1" id="fnref1">[1]</a></sup> Some applications know they will never encrypt that many messages under a single key, but those numbers are a little too low and the consequences too dire to make that assumption at the API level, so we‚Äôre forced to delegate nonce management to the user.<sup><a href="#fn2" id="fnref2">[2]</a></sup></p>
<p>ChaCha20Poly1305 has the same issue, which is why the <em>extended-nonce</em> construction XChaCha20Poly1305 exists. It resolves the issue by taking a 192-bit nonce<sup><a href="#fn3" id="fnref3">[3]</a></sup>, and ‚Äúhashing‚Äù it along with the key into a fresh key.<sup><a href="#fn4" id="fnref4">[4]</a></sup> The key is 256 bits, so there is no need to ever worry about collisions there. (More on that later.) You should <em>always</em> use the X variant unless the nonce is fully implicit, like when it‚Äôs always zero (like in age), a record counter (like in TLS), or a chunk number (like in STREAM). You can also make nice APIs for the X variant that generate the nonce at random from the system CSPRNG (and we are thinking about how to best do that in the Go standard library).</p>
<p>XChaCha20Poly1305 uses ChaCha20 itself to do the hashing to avoid introducing a new primitive, but this would work just as well using SHA-256 or HKDF to derive a regular key and nonce for ChaCha20Poly1305 from a key and a larger nonce. This means you could do the same for AES-GCM, and some schemes do in fact do just that. Regrettably, we don‚Äôt have a name for it, so you can‚Äôt just say to people ‚Äúyou should <em>always</em> use the X variant‚Äù or make a nice interoperable API for it.</p>
<p>Anyway, that‚Äôs the X in my <s>pony</s> XAES-256-GCM/11.</p>
<p>I don‚Äôt care if it uses HKDF, or SHA-256, or the AES function<sup><a href="#fn5" id="fnref5">[5]</a></sup>: I want a well-defined scheme that takes a key and 192 bits of nonce and hashes them into a derived key and 96 bits of nonce for use with AES-GCM.</p>
<p>Even with AES-128, the combined 224 bits of space for key and nonce are juuuust enough not to worry about collisions in the derived values. Still, this hints to the second part of the <s>pony</s> problem with AES-GCM: while <a href="https://words.filippo.io/dispatches/post-quantum-age/#128-bits-are-enough">actually enough for post-quantum cryptography</a>, 128-bit keys are still too tight for <em>multi-user security</em>. If for example an application encrypts 2<sup>48</sup> messages under different 128-bit keys, and all messages start with the same few bytes, an attacker can build a lookup table, try and lookup the ciphertext of 2<sup>64</sup> keys, and <a href="https://www.wolframalpha.com/input?i=log2%281+-+%281+-+2%5E48+%2F+2%5E128%29+%5E+%282%5E64%29%29&amp;ref=words.filippo.io">have a 2<sup>-16</sup> chance</a> to decrypt one message. Not good.</p>
<p>Multi-user attacks can be mitigated by many things‚Äîthey require fixed nonces and partially known plaintext‚Äîbut the only way to avoid that complexity escaping the AEAD abstraction and leaking into the rest of the protocol is to use 256-bit keys. For AES-GCM, that means using AES-256. Too bad that AES-256 is slower than AES-128, not because of its bigger key size, but because it was specified with more rounds, presumably under the assumption that users of bigger keys would also want more security margin against cryptanalysis. AES is an iterated cipher, where four core operations are performed multiple times in sequence: AES-128 performs them ten times, while AES-256 performs them fourteen times. AES-256 doesn‚Äôt <em>have to be</em> slower than AES-128, it was just defined to be slower. That‚Äôs regrettable, because it applies an artificial performance tax on the use of longer keys, which are desirable for reasons that have nothing to do with the risk of AES cryptanalysis.</p>
<p>Picking the ‚Äúright‚Äù number of rounds is hard, and it‚Äôs kind of an open secret in the community that there is no rigorous and scientific way to do it. ‚Äú<em><a href="https://eprint.iacr.org/2019/1492?ref=words.filippo.io">Too much crypto</a></em>‚Äù by Aumasson is all about this, and suggests eleven rounds for AES-256. I started this aiming for ten, which would have been exactly as fast as AES-128, but AES-256 does need more margin than AES-128 in some rare cases for <em>reasons</em><sup><a href="#fn6" id="fnref6">[6]</a></sup> and I guess it‚Äôd be silly to introduce a different abstraction-leaking edge case while trying to remove two, so AES-256/11 it is.</p>
<p>Summing up, I would like to provide to my users the extended-nonce 256-bit reduced-rounds XAES-256-GCM/11 (or XAES-256/11-GCM?) AEAD. It has infinitely randomizable nonces, a comfortable margin of multi-user security, and nearly the same performance as AES-128-GCM. It would also be a true drop-in replacement for XChaCha20Poly1305. Only issue is that it doesn‚Äôt exist.</p>
<p>(I guess it would also not be FIPS 140 compliant. We could make a FIPS version that‚Äôs slower but equivalent by using HKDF to derive the key, and the full-rounds AES-256.)</p>
<p><strong>Edit 2023-07-06</strong>: Soatok has <a href="https://soatok.blog/2022/12/21/extending-the-aes-gcm-nonce-without-nightmare-fuel/?ref=words.filippo.io">previously suggested an extended-nonce AES-GCM construction</a>. His AES-XGCM uses CBC-MAC for key derivation, which might be a good pick as both primitive-parsimonious and potentially FIPS 140 compliant. @NohatCoder@mastodon.gamedev.place on Mastodon suggests that since we&#39;re KDF&#39;ing, we might as well generate all the subkeys directly, solving the AES-256-specific issues that require the extra rounds (see <sup><a href="#fn6" id="fnref6:1">[6:1]</a></sup>). I&#39;m a bit wary to diverge too much from the well-established primitives, since at that point might as well use something novel (such as <a href="https://datatracker.ietf.org/doc/draft-irtf-cfrg-aegis-aead/?ref=words.filippo.io">AEGIS</a>, like Soatok says). The point here is that I&#39;d like a thin construction that&#39;s easy to get confidence for if you already trust AES-GCM.</p>
<p>If for some reason you&#39;re curious about what other ponies I want, you might want to follow me <a href="https://bsky.app/profile/filippo.abyssdomain.expert?ref=words.filippo.io">on Bluesky</a> or <a href="https://abyssdomain.expert/@filippo?ref=words.filippo.io">on Mastodon</a>.</p>
<h2 id="the-picture">The picture</h2>
<p>Cats! Amongst Roman ruins! What else do you need in life? (Better AEAD modes I guess.)</p>
<p><img src="https://words.filippo.io/content/images/2023/07/news---1.jpeg" alt="A calico cat sleeps in the foreground, another cat is sitting down a step behind it, and behind them and a rail is a archaeological site with trees and columns. Further back, buildings." loading="lazy"/></p>
<p>My awesome clients‚Äî<a href="https://www.sigsum.org/?ref=words.filippo.io">Sigsum</a>, <a href="https://protocol.ai/?ref=words.filippo.io">Protocol Labs</a>, <a href="https://www.latacora.com/?ref=words.filippo.io">Latacora</a>, <a href="https://interchain.io/?ref=words.filippo.io">Interchain</a>, <a href="https://smallstep.com/?ref=words.filippo.io">Smallstep</a>, and <a href="https://tailscale.com/?ref=words.filippo.io">Tailscale</a>‚Äîare funding all this work and through our retainer contracts they get face time about its direction, as well as unlimited access to advice.</p>
<p>Here are a few words from some of them!</p>
<p>Protocol Labs ‚Äî <a href="https://cryptonet.org/?ref=words.filippo.io">Cryptonet</a> is hosting <a href="https://lu.ma/tm8v78rl?ref=words.filippo.io">Proof of Space days</a> in Paris on July 20-21, a gathering of cryptographers, Web3 researchers and engineers to share knowledge on <a href="http://proofofspace.org/?ref=words.filippo.io">Proof of Space</a>. We‚Äôll have talks and workshops to collaborate, share ideas and onboard new researchers into this exciting field. You‚Äôll also have a chance to meet us (we‚Äôre currently looking for a senior cryptography engineer), <a href="https://lu.ma/tm8v78rl?ref=words.filippo.io">register and join us</a>!</p>
<p>Latacora ‚Äî <a href="https://www.latacora.com/?ref=words.filippo.io">Latacora</a> bootstraps security practices for startups. Instead of wasting your time trying to hire a security person who is good at everything from Android security to AWS IAM strategies to SOC2 and apparently has the time to answer all your security questionnaires plus never gets sick or takes a day off, you hire us. We provide a crack team of professionals prepped with processes and power tools, coupling individual security capabilities with strategic program management and tactical project management.</p>
<hr/>
<section>
<ol>
<li id="fn1"><p>You‚Äôll sometimes hear that any single-key AES mode can only produce 2<sup>48</sup> blocks before the advantage of a distinguishing attacker gets uncomfortable. That would seem contradictory with a limit of 2<sup>32</sup> messages for AES-GCM, since each message can be up to 2<sup>32</sup> blocks. The thing is that the only thing that an attacker can do by observing more than 2<sup>48</sup> blocks is confirm that they‚Äôre looking at AES rather than at complete randomness. A completely random stream would be expected to show some output block collisions after that many blocks, while AES, being an invertible permutation applied on a counter and unique nonce, will never repeat. The <em>lack</em> of collisions is the distinguisher. NIST doesn‚Äôt care, and neither do I. <a href="#fnref1">‚Ü©Ô∏é</a></p>
</li>
<li id="fn2"><p>Technically, GCM accepts longer nonces. However, nonces longer than 96 bits are hashed into a starting 128-bit counter value, leaving no dedicated counter space. (96-bit nonces are instead concatenated with a 32-bit counter.) The birthday bound of 128 bits is better, allowing us to encrypt in theory 2<sup>48</sup> messages (the approximate formula is 2<sup>(N-32)/2</sup>), but that‚Äôs only if every message was precisely one block long. If messages are longer, there‚Äôs a risk the counter will overlap across messages, which is not as catastrophic and easy to detect as nonce reuse, but leads to loss of confidentiality. In general, it‚Äôs very inconvenient for bounds to depend on the message size, because that‚Äôs yet another assessment we have to delegate to the application. AES-GCM-SIV has the same issue: it has better bounds for shorter messages, but worse for messages longer than 8 GiB, and the answer to ‚Äúhow many messages can I encrypt‚Äù is a double entry table instead of a number. <a href="#fnref2">‚Ü©Ô∏é</a></p>
</li>
<li id="fn3"><p>Technically, 128 bits of nonce are hashed with 256 bits of key into 256 bits of key, and 64 bits of nonce are used as nonce, which leaves 32 bits of nonce space that can be reassigned to counter, if you need to encrypt more than 256 GB. In practice, <a href="https://cs.opensource.google/go/x/crypto/+/refs/tags/v0.10.0:chacha20poly1305/xchacha20poly1305.go;l=46-53;drc=c084706c2272f3d44b722e988e70d4a58e60e7f4?ref=words.filippo.io">we don‚Äôt support that</a>. What counts as key, nonce, and counter in ChaCha20 is really just arbitrary: 384 bits of variable state are mixed with 128 bits of constants for each block, and you need to make sure you never reuse the same state. The original ChaCha20 had 64 bits of nonce and 64 bits of counter, the IETF moved 32 bits from nonce to counter, making random nonces juuust tempting but not quite safe. Anyway. <a href="#fnref3">‚Ü©Ô∏é</a></p>
</li>
<li id="fn4"><p>In a sense XChaCha20Poly1305 is a SIV construction in the same way AES-GCM-SIV is: they both compute a synthetic (key, nonce) rather than a synthetic nonce alone. ü§î However, the message is not one of the inputs in the XChaCha20Poly1305 derivation, so it‚Äôs not misuse resistant. There are some interesting parallels here with <a href="https://words.filippo.io/dispatches/avoid-the-randomness-from-the-sky/">signature nonce generation</a>, where the best design turns out to be hashing message <em>and</em> randomness into it. <a href="#fnref4">‚Ü©Ô∏é</a></p>
</li>
<li id="fn5"><p>Although if we‚Äôre doing this, we might as well do it cleanly and use AES like XChaCha20Poly1305 or GHASH like AES-GCM-SIV. <a href="#fnref5">‚Ü©Ô∏é</a></p>
</li>
<li id="fn6"><p>Interestingly enough, AES-256 turned out to actually have a legitimate (if maybe unexpected) need for more rounds, because the 256-bit key schedule (the way the key is expanded into subkeys for the various rounds) is simpler and more vulnerable to related-key attacks. In 2009/2010 we got some impractical related-key attacks against AES-256/14, and <a href="https://eprint.iacr.org/2009/374?ref=words.filippo.io">some ‚Äúpractical‚Äù related-key attacks against AES-256/9</a>. The paper does a good job of explaining the background in the first few sections. The related-key attack setting is very contrived: an attacker can recover a key K if it‚Äôs able to get an encryption oracle for a K <em>and</em> for K‚äïC. There is apparently one protocol that somehow managed that, but these days I‚Äôd hope all keys are the output of a CSPRNG or a KDF, not some haphazard XOR operation. (There was also an attack against AES-256/11 which required even more implausible relations between the keys.) I also suspect that the key derivation step of the extended-nonce construction we discussed above would rule out these related-key attacks. Anyway. <a href="#fnref6">‚Ü©Ô∏é</a> <a href="#fnref6:1">‚Ü©Ô∏é</a></p>
</li>
</ol>
</section>
<!--kg-card-end: markdown-->
        </section>
    </article></div>
  </body>
</html>
