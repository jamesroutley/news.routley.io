<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.josephmorag.com/posts/databass3/">Original</a>
    <h1>Databass, Part 3: Using the database</h1>
    
    <div id="readability-page-1" class="page"><article><section><p>In parts <a href="https://fabiensanglard.net/posts/databass1">1</a> and <a href="https://fabiensanglard.net/posts/databass2">2</a> we defined our core query types and figured out how to insert into the database. Here, we&#39;ll actually write some queries. We&#39;re going to port the professional hitmen example from William Yao&#39;s <a href="https://williamyaoh.com/posts/2019-12-14-typesafe-db-libraries.html">which type-safe database library should you use</a> blog post to Databass and see how it stacks up. Full source is <a href="https://github.com/jmorag/databass/blob/main/app/Hitmen.hs">on github</a>, as always. Note, I&#39;m straying a bit from the exact implementation that we built up in the previous parts and using the more user friendly API that I hope to release to Hackage once it&#39;s sufficiently polished. The core types and implementation remains the same, but moved to an <code>Internal</code> module in favor of exposing smart constructors for <code>Query</code> with fewer <code>Proxy</code> arguments as the main API.</p><h2 id="headline-1">Data model</h2><p><img src="https://fabiensanglard.net/images/hitmen-er-diagram.svg" alt="/images/hitmen-er-diagram.svg" title="/images/hitmen-er-diagram.svg"/></p><p>Handlers handle multiple hitmen and hitmen pursue multiple marks. In Haskell,</p><div><div><pre><code data-lang="haskell"><span>type</span> <span>Handler</span> <span>=</span>
  <span>&#39;[ &#34;id&#34; ::: Int
</span><span>   , &#34;codename&#34; ::: Text
</span><span>   , &#34;created_at&#34; ::: UTCTime
</span><span>   , &#34;updated_at&#34; ::: UTCTime
</span><span>   ]</span>

<span>type</span> <span>Hitman</span> <span>=</span>
  <span>&#39;[ &#34;id&#34; ::: Int
</span><span>   , &#34;codename&#34; ::: Text
</span><span>   , &#34;handler_id&#34; ::: Int
</span><span>   , &#34;created_at&#34; ::: UTCTime
</span><span>   , &#34;updated_at&#34; ::: UTCTime
</span><span>   ]</span>

<span>type</span> <span>PursuingMark</span> <span>=</span>
  <span>&#39;[ &#34;hitman_id&#34; ::: Int
</span><span>   , &#34;mark_id&#34; ::: Int
</span><span>   , &#34;created_at&#34; ::: UTCTime
</span><span>   , &#34;updated_at&#34; ::: UTCTime
</span><span>   ]</span>

<span>type</span> <span>ErasedMark</span> <span>=</span>
  <span>&#39;[ &#34;hitman_id&#34; ::: Int
</span><span>   , &#34;mark_id&#34; ::: Int
</span><span>   , &#34;awarded_bounty&#34; ::: Int
</span><span>   , &#34;created_at&#34; ::: UTCTime
</span><span>   , &#34;updated_at&#34; ::: UTCTime
</span><span>   ]</span>

<span>type</span> <span>Mark</span> <span>=</span>
  <span>&#39;[ &#34;id&#34; ::: Int
</span><span>   , &#34;list_bounty&#34; ::: Int
</span><span>   , &#34;first_name&#34; ::: Text
</span><span>   , &#34;last_name&#34; ::: Text
</span><span>   , &#34;description&#34; ::: Maybe Text
</span><span>   , &#34;created_at&#34; ::: UTCTime
</span><span>   , &#34;updated_at&#34; ::: UTCTime
</span><span>   ]</span>

<span>type</span> <span>Schema</span> <span>=</span>
  <span>Sort</span>
    <span>&#39;[ &#34;handlers&#34; ::: T (Sort Handler) &#39;[&#34;id&#34;]</span>
     , <span>&#34;hitmen&#34;</span> <span>:::</span> <span>T</span> (<span>Sort</span> <span>Hitman</span>) <span>&#39;[&#34;id&#34;]</span>
     , <span>&#34;pursuing_marks&#34;</span> <span>:::</span> <span>T</span> (<span>Sort</span> <span>PursuingMark</span>) <span>&#39;[&#34;hitman_id&#34;, &#34;mark_id&#34;]</span>
     , <span>&#34;erased_marks&#34;</span> <span>:::</span> <span>T</span> (<span>Sort</span> <span>ErasedMark</span>) <span>&#39;[&#34;hitman_id&#34;, &#34;mark_id&#34;]</span>
     , <span>&#34;marks&#34;</span> <span>:::</span> <span>T</span> (<span>Sort</span> <span>Mark</span>) <span>&#39;[&#34;id&#34;]</span>
     ]</code></pre></div></div><p>If we want, we can factor our the common <code>created_at</code> and <code>updated_at</code> columns.</p><div><div><pre><code data-lang="haskell"><span>type</span> <span>TimeStamps</span> <span>=</span> <span>&#39;[&#34;created_at&#34; ::: UTCTime, &#34;updated_at&#34; ::: UTCTime]</span>

<span>type</span> <span>Handler</span> <span>=</span> <span>&#39;[&#34;id&#34; ::: Int, &#34;codename&#34; ::: Text]</span> <span>:++</span> <span>TimeStamps</span></code></pre></div></div><h2 id="headline-2">Populating the database</h2><p>The original blog uses the following seed data in sql.</p><div><div><pre><code data-lang="sql"><span>INSERT</span> <span>INTO</span> handlers ( id, codename )
<span>VALUES</span>
  ( <span>1</span>, <span>&#39;Olive&#39;</span> ),
  ( <span>2</span>, <span>&#39;Pallas&#39;</span> );

<span>INSERT</span> <span>INTO</span> hitmen ( id, codename, handler_id )
<span>VALUES</span>
  ( <span>1</span>, <span>&#39;Callaird&#39;</span>, <span>1</span> ),
  ( <span>2</span>, <span>&#39;Bomois&#39;</span>, <span>1</span>),
  ( <span>3</span>, <span>&#39;Dune&#39;</span>, <span>2</span>);

<span>INSERT</span> <span>INTO</span> marks ( id, first_name, last_name, list_bounty )
<span>VALUES</span>
  ( <span>1</span>, <span>&#39;John&#39;</span>, <span>&#39;Tosti&#39;</span>, <span>25000</span> ),
  ( <span>2</span>, <span>&#39;Macie&#39;</span>, <span>&#39;Jordan&#39;</span>, <span>50000</span> ),
  ( <span>3</span>, <span>&#39;Sal&#39;</span>, <span>&#39;Aspot&#39;</span>, <span>33000</span> ),
  ( <span>4</span>, <span>&#39;Lars&#39;</span>, <span>&#39;Andersen&#39;</span>, <span>10000</span> );

<span>INSERT</span> <span>INTO</span> pursuing_marks ( hitman_id, mark_id, created_at )
<span>VALUES</span>
  ( <span>1</span>, <span>2</span>, <span>&#39;2018-07-01&#39;</span> ),
  ( <span>2</span>, <span>2</span>, <span>&#39;2018-07-02&#39;</span> ),
  ( <span>2</span>, <span>4</span>, <span>&#39;2019-05-05&#39;</span> ),
  ( <span>3</span>, <span>3</span>, <span>&#39;2018-05-13&#39;</span> ),
  ( <span>3</span>, <span>2</span>, <span>&#39;2019-02-15&#39;</span> );

<span>INSERT</span> <span>INTO</span> erased_marks ( hitman_id, mark_id, awarded_bounty, created_at )
<span>VALUES</span>
  ( <span>1</span>, <span>2</span>, <span>30000</span>, <span>&#39;2018-09-03&#39;</span> ),
  ( <span>1</span>, <span>1</span>, <span>55000</span>, <span>&#39;2019-02-02&#39;</span> ),
  ( <span>3</span>, <span>3</span>, <span>27000</span>, <span>&#39;2018-06-30&#39;</span> );</code></pre></div></div><p>Being able to specify which columns to insert and defaulting the remaining ones seems nice, so I&#39;ve replicated that API for Databass, but with explicit defaults for unspecified columns. Note that this version of insert, unlike the one in part 2, doesn&#39;t return <code>Nothing</code> for duplicate keys and just silently overwrites them. This is more convenient when hard coding data but can be a problem when called with user input.</p><div><div><pre><code data-lang="haskell"><span>insertManyWithDefault</span> <span>::</span>
  forall name cols relations heading k v t<span>.</span>
  ( <span>IsHeading</span> heading k v
  , (<span>RelationsToDB</span> relations <span>:!</span> name) <span>~</span> relation
  , <span>Relation</span> heading k v <span>~</span> relation
  , <span>IsMember</span> name (<span>RelationToMap</span> relation) (<span>RelationsToDB</span> relations)
  , <span>Updatable</span> name (<span>RelationToMap</span> relation) (<span>RelationsToDB</span> relations) (<span>RelationsToDB</span> relations)
  , <span>Ord</span> (<span>Tuple</span> k)
  , <span>Unionable</span> (heading <span>:!!</span> cols) (heading <span>:\\</span> cols)
  , <span>Union</span> (heading <span>:!!</span> cols) (heading <span>:\\</span> cols) <span>~</span> heading
  , <span>Foldable</span> t
  ) <span>=&gt;</span>
  <span>Tuple</span> (heading <span>:\\</span> cols) <span>-&gt;</span>
  t (<span>Tuple</span> (heading <span>:!!</span> cols)) <span>-&gt;</span>
  <span>Tuple</span> (<span>RelationsToDB</span> relations) <span>-&gt;</span>
  <span>Tuple</span> (<span>RelationsToDB</span> relations)</code></pre></div></div><p>Heinous type signature notwithstanding, this function makes populating the database almost as pleasant as in sql.</p><div><div><pre><code data-lang="haskell"><span>makeDB</span> <span>::</span> <span>IO</span> (<span>RelationsToDB</span> <span>Schema</span>)
<span>makeDB</span> <span>=</span> <span>do</span>
  now <span>&lt;-</span> getCurrentTime
  <span>let</span> defaultTimeStamps <span>::</span> <span>Tuple</span> <span>TimeStamps</span>
      defaultTimeStamps <span>=</span> now <span>&lt;|</span> now <span>&lt;|</span> <span>Empty</span>
  pure <span>$</span>
    initDB <span>@</span><span>Schema</span>
      <span>&amp;</span> insertManyWithDefault <span>@</span><span>&#34;handlers&#34;</span> <span>@</span><span>&#39;[&#34;id&#34;, &#34;codename&#34;]</span> <span>@</span><span>Schema</span>
        defaultTimeStamps
        [ <span>1</span> <span>&lt;|</span> <span>&#34;Olive&#34;</span> <span>&lt;|</span> <span>Empty</span>
        , <span>2</span> <span>&lt;|</span> <span>&#34;Pallas&#34;</span> <span>&lt;|</span> <span>Empty</span>
        ]
      <span>&amp;</span> insertManyWithDefault <span>@</span><span>&#34;hitmen&#34;</span> <span>@</span><span>&#39;[&#34;id&#34;, &#34;codename&#34;, &#34;handler_id&#34;]</span> <span>@</span><span>Schema</span>
        defaultTimeStamps
        [ <span>1</span> <span>&lt;|</span> <span>&#34;Callaird&#34;</span> <span>&lt;|</span> <span>1</span> <span>&lt;|</span> <span>Empty</span>
        , <span>2</span> <span>&lt;|</span> <span>&#34;Bomois&#34;</span> <span>&lt;|</span> <span>1</span> <span>&lt;|</span> <span>Empty</span>
        , <span>3</span> <span>&lt;|</span> <span>&#34;Dune&#34;</span> <span>&lt;|</span> <span>2</span> <span>&lt;|</span> <span>Empty</span>
        ]
      <span>&amp;</span> insertManyWithDefault
        <span>@</span><span>&#34;marks&#34;</span>
        <span>@</span><span>&#39;[&#34;id&#34;, &#34;list_bounty&#34;, &#34;first_name&#34;, &#34;last_name&#34;]</span>
        <span>@</span><span>Schema</span>
        (t <span>@</span><span>&#39;[&#34;description&#34;, &#34;created_at&#34;, &#34;updated_at&#34;]</span> (<span>Nothing</span> <span>&lt;|</span> now <span>&lt;|</span> now <span>&lt;|</span> <span>Empty</span>))
        [ <span>1</span> <span>&lt;|</span> <span>25000</span> <span>&lt;|</span> <span>&#34;John&#34;</span> <span>&lt;|</span> <span>&#34;Tosti&#34;</span> <span>&lt;|</span> <span>Empty</span>
        , <span>2</span> <span>&lt;|</span> <span>50000</span> <span>&lt;|</span> <span>&#34;Macie&#34;</span> <span>&lt;|</span> <span>&#34;Jordan&#34;</span> <span>&lt;|</span> <span>Empty</span>
        , <span>3</span> <span>&lt;|</span> <span>33000</span> <span>&lt;|</span> <span>&#34;Sal&#34;</span> <span>&lt;|</span> <span>&#34;Aspot&#34;</span> <span>&lt;|</span> <span>Empty</span>
        , <span>4</span> <span>&lt;|</span> <span>10000</span> <span>&lt;|</span> <span>&#34;Lars&#34;</span> <span>&lt;|</span> <span>&#34;Andersen&#34;</span> <span>&lt;|</span> <span>Empty</span>
        ]
      <span>&amp;</span> insertMany <span>@</span><span>&#34;pursuing_marks&#34;</span> <span>@</span><span>Schema</span>
        ( map
            (asMap <span>@</span><span>PursuingMark</span>)
            [ <span>1</span> <span>&lt;|</span> <span>2</span> <span>&lt;|</span> read <span>&#34;2018-07-01 00:00:00 UTC&#34;</span> <span>&lt;|</span> now <span>&lt;|</span> <span>Empty</span>
            , <span>2</span> <span>&lt;|</span> <span>2</span> <span>&lt;|</span> read <span>&#34;2018-07-02 00:00:00 UTC&#34;</span> <span>&lt;|</span> now <span>&lt;|</span> <span>Empty</span>
            , <span>2</span> <span>&lt;|</span> <span>4</span> <span>&lt;|</span> read <span>&#34;2019-05-05 00:00:00 UTC&#34;</span> <span>&lt;|</span> now <span>&lt;|</span> <span>Empty</span>
            , <span>3</span> <span>&lt;|</span> <span>3</span> <span>&lt;|</span> read <span>&#34;2018-05-13 00:00:00 UTC&#34;</span> <span>&lt;|</span> now <span>&lt;|</span> <span>Empty</span>
            , <span>3</span> <span>&lt;|</span> <span>2</span> <span>&lt;|</span> read <span>&#34;2019-02-15 00:00:00 UTC&#34;</span> <span>&lt;|</span> now <span>&lt;|</span> <span>Empty</span>
            ]
        )
      <span>&amp;</span> insertMany <span>@</span><span>&#34;erased_marks&#34;</span> <span>@</span><span>Schema</span>
        ( map
            (asMap <span>@</span><span>ErasedMark</span>)
            [ <span>1</span> <span>&lt;|</span> <span>2</span> <span>&lt;|</span> <span>30000</span> <span>&lt;|</span> read <span>&#34;2018-09-03 00:00:00 UTC&#34;</span> <span>&lt;|</span> now <span>&lt;|</span> <span>Empty</span>
            , <span>1</span> <span>&lt;|</span> <span>1</span> <span>&lt;|</span> <span>55000</span> <span>&lt;|</span> read <span>&#34;2019-02-02 00:00:00 UTC&#34;</span> <span>&lt;|</span> now <span>&lt;|</span> <span>Empty</span>
            , <span>3</span> <span>&lt;|</span> <span>3</span> <span>&lt;|</span> <span>27000</span> <span>&lt;|</span> read <span>&#34;2018-06-30 00:00:00 UTC&#34;</span> <span>&lt;|</span> now <span>&lt;|</span> <span>Empty</span>
            ]
        )</code></pre></div></div><p>When writing and debugging queries, I <em>strongly</em> recommend putting the model types and inserting code into their own module, as they tend not to change once written and then ghc doesn&#39;t have to re-compile them when you change a query, which can take forever.</p><h2 id="headline-3">Queries</h2><h3 id="headline-4">Get all the hitmen</h3><p>Easy!</p><div><div><pre><code data-lang="haskell"><span>getAllHitmen</span> <span>::</span> <span>Query</span> (<span>Sort</span> <span>Hitmen</span>) <span>Schema</span>
<span>getAllHitmen</span> <span>=</span> table <span>@</span><span>&#34;hitmen&#34;</span> <span>-- &#39;table&#39; is the smart constructor for &#39;RelationId&#39;</span>

<span>-- Results</span>
<span>-- {codename :-&gt; &#34;Callaird&#34;, created_at :-&gt; 2022-01-20 15:41:46.2046 UTC, handler_id :-&gt; 1, id :-&gt; 1, updated_at :-&gt; 2022-01-20 15:41:46.2046 UTC}</span>
<span>-- {codename :-&gt; &#34;Bomois&#34;, created_at :-&gt; 2022-01-20 15:41:46.2046 UTC, handler_id :-&gt; 1, id :-&gt; 2, updated_at :-&gt; 2022-01-20 15:41:46.2046 UTC}</span>
<span>-- {codename :-&gt; &#34;Dune&#34;, created_at :-&gt; 2022-01-20 15:41:46.2046 UTC, handler_id :-&gt; 2, id :-&gt; 3, updated_at :-&gt; 2022-01-20 15:41:46.2046 UTC}</span></code></pre></div></div><h3 id="headline-5">Get all the hitmen that are pursuing active marks (i.e. marks that haven’t been erased yet)</h3><p>This is the set difference of the pursuing marks relation and the erased marks relation. We have to project only the hitman and mark ids to remove the timestamps and awards which are immaterial to this query. Note that we didn&#39;t implement set difference in previous parts but it behaves exactly the same as the <code>\\</code> operator from <code>Data.List</code>.</p><div><div><pre><code data-lang="haskell"><span>getAllHitmenActiveMarks</span> <span>=</span>
   (table <span>@</span><span>&#34;pursuing_marks&#34;</span> <span>&amp;</span> project <span>@</span><span>&#39;[&#34;hitman_id&#34;, &#34;mark_id&#34;]</span>)
      <span>\\</span> (table <span>@</span><span>&#34;erased_marks&#34;</span> <span>&amp;</span> project <span>@</span><span>&#39;[&#34;hitman_id&#34;, &#34;mark_id&#34;]</span>)</code></pre></div></div><p>If we don&#39;t want just the hitman and mark ids in the final result, we can join with the hitman relation to get the full hitman tuple.</p><div><div><pre><code data-lang="haskell"><span>getAllHitmenActiveMarks</span> <span>=</span>
  ( (table <span>@</span><span>&#34;pursuing_marks&#34;</span> <span>&amp;</span> project <span>@</span><span>&#39;[&#34;hitman_id&#34;, &#34;mark_id&#34;]</span>)
      <span>\\</span> (table <span>@</span><span>&#34;erased_marks&#34;</span> <span>&amp;</span> project <span>@</span><span>&#39;[&#34;hitman_id&#34;, &#34;mark_id&#34;]</span>)
  )
    <span>&amp;</span> project <span>@</span><span>&#39;[&#34;hitman_id&#34;]</span>
    <span>&amp;</span> rename <span>@</span><span>&#34;hitman_id&#34;</span> <span>@</span><span>&#34;id&#34;</span>
    <span>&amp;</span> join (table <span>@</span><span>&#34;hitmen&#34;</span>)

<span>-- Results</span>
<span>-- {codename :-&gt; &#34;Bomois&#34;, created_at :-&gt; 2022-01-20 15:41:46.2046 UTC, handler_id :-&gt; 1, id :-&gt; 2, updated_at :-&gt; 2022-01-20 15:41:46.2046 UTC}</span>
<span>-- {codename :-&gt; &#34;Dune&#34;, created_at :-&gt; 2022-01-20 15:41:46.2046 UTC, handler_id :-&gt; 2, id :-&gt; 3, updated_at :-&gt; 2022-01-20 15:41:46.2046 UTC}</span></code></pre></div></div><h3 id="headline-6">Get all the marks that have been erased since a given date</h3><p>This query will take a <code>UTCTime</code> as an argument.</p><div><div><pre><code data-lang="haskell"><span>erasedSince</span> <span>::</span> <span>UTCTime</span> <span>-&gt;</span> <span>Query</span> <span>_</span> <span>Schema</span>
<span>erasedSince</span> time <span>=</span>
  table <span>@</span><span>&#34;erased_marks&#34;</span>
    <span>&amp;</span> restrict (<span>\</span>mark <span>-&gt;</span> mark <span>^.</span> <span>#</span>created_at <span>&gt;=</span> time)</code></pre></div></div><p>Note that Databass includes machinery to use <code>OverloadedLabels</code> to create lenses for tuples. For a superlative coverage of lenses, see Chris Penner&#39;s <a href="https://leanpub.com/optics-by-example">Optics By Example</a>. If, for some reason, adding the complexity of lenses and label syntax to the complexity of the type level shenanigans we&#39;ve been doing here doesn&#39;t appeal to you, the following is equivalent.</p><div><div><pre><code data-lang="haskell"><span>erasedSince</span> time <span>=</span>
  table <span>@</span><span>&#34;erased_marks&#34;</span>
    <span>&amp;</span> restrict (<span>\</span>mark <span>-&gt;</span> lookp (<span>Var</span> <span>@</span><span>&#34;created_at&#34;</span>) mark <span>&gt;=</span> time)</code></pre></div></div><h3 id="headline-7">Get the total bounty awarded to each hitman</h3><p>This requires the <code>summarize</code> relational operator from Tutorial D that we haven&#39;t implemented yet. For relations <code>a</code> and <code>b</code>, where <code>b</code> has a heading that is a projection of <code>a</code>, <code>SUMMARIZE a PER (b) ADD (summary AS Z)</code> groups all the tuples in <code>a</code> that have the same values for the attributes in <code>b</code>, runs some aggregation operator <code>summary</code> over them, and adds them to an attribute called <code>Z</code>. <code>Z</code> must not appear already in <code>b</code>. Tutorial D defines a large set of aggregation operators like <code>COUNT</code>, <code>AVG</code>, and <code>SUM</code>. Instead of manually reproducing all of those, we capture the essense of aggregation using <code>Fold</code> from the <a href="https://hackage.haskell.org/package/foldl-1.4.12"><code>foldl</code> library</a>.</p><div><div><pre><code data-lang="haskell">  <span>Summarize</span> <span>::</span>
    forall name a t t&#39; relations<span>.</span>
    ( <span>Submap</span> t&#39; t
    , <span>Member</span> name t&#39; <span>~</span> <span>&#39;False</span>
    , <span>Eq</span> (<span>Tuple</span> t&#39;)
    , <span>Sortable</span> (name <span>:::</span> a <span>&#39;</span>: <span>t&#39;</span>)
    ) <span>=&gt;</span>
    <span>Var</span> name <span>-&gt;</span>
    <span>Query</span> t&#39; relations <span>-&gt;</span>
    <span>Fold</span> (<span>Tuple</span> t) a <span>-&gt;</span>
    <span>Query</span> t relations <span>-&gt;</span>
    <span>Query</span> (<span>Sort</span> (name <span>:::</span> a <span>&#39;</span>: <span>t&#39;</span>)) relations
<span>------------------------------------------------</span>
<span>-- implementation in &#39;runQuery&#39;</span>
<span>------------------------------------------------</span>
  <span>Summarize</span> var projection folder q <span>-&gt;</span>
    <span>let</span> proj <span>=</span> <span>Data</span><span>.</span><span>List</span><span>.</span>nub <span>$</span> runQuery projection mem
        tuples <span>=</span> runQuery q mem
     <span>in</span> go proj tuples
    <span>where</span>
      go <span>[]</span> <span>_</span> <span>=</span> <span>[]</span>
      go (p <span>:</span> ps) tuples <span>=</span>
        <span>let</span> (these, rest) <span>=</span> <span>Data</span><span>.</span><span>List</span><span>.</span>partition (<span>\</span>tuple <span>-&gt;</span> p <span>==</span> submap tuple) tuples
         <span>in</span> quicksort (<span>Ext</span> var (<span>Control</span><span>.</span><span>Foldl</span><span>.</span>fold folder these) p) <span>:</span> go ps rest</code></pre></div></div><p>Now, to get the total bounty awarded to each hitman, we summarize the erased marks relation over hitman ids, summing over awarded bounties.</p><div><div><pre><code data-lang="haskell"><span>totalBounties</span> <span>::</span> <span>Query</span> <span>_</span> <span>Schema</span>
<span>totalBounties</span> <span>=</span>
  table <span>@</span><span>&#34;erased_marks&#34;</span>
    <span>&amp;</span> summarize <span>@</span><span>&#34;total_bounty&#34;</span>
      (project <span>@</span><span>&#39;[&#34;id&#34;]</span> (table <span>@</span><span>&#34;hitmen&#34;</span>) <span>&amp;</span> rename <span>@</span><span>&#34;id&#34;</span> <span>@</span><span>&#34;hitman_id&#34;</span>)
      (<span>Control</span><span>.</span><span>Foldl</span><span>.</span>premap (view <span>#</span>awarded_bounty) <span>Control</span><span>.</span><span>Foldl</span><span>.</span>sum)

<span>-- Results</span>
<span>-- {hitman_id :-&gt; 1, total_bounty :-&gt; 85000}</span>
<span>-- {hitman_id :-&gt; 2, total_bounty :-&gt; 0}</span>
<span>-- {hitman_id :-&gt; 3, total_bounty :-&gt; 27000}</span></code></pre></div></div><p>Tutorial D has a shorthand for when the <code>b</code> relation is an actual projection of <code>a</code> which allows users to just supply attributes instead of writing out the full projection on the same initial relation. Databass supports that via the <code>summarize&#39;</code> smart constructor. Note, however, that if we use that for this query,</p><div><div><pre><code data-lang="haskell"><span>totalBounties&#39;</span> <span>=</span>
  table <span>@</span><span>&#34;erased_marks&#34;</span>
    <span>&amp;</span> summarize&#39; <span>@</span><span>&#34;total_bounty&#34;</span> <span>@</span><span>&#39;[&#34;hitman_id&#34;]</span>
      (<span>Control</span><span>.</span><span>Foldl</span><span>.</span>premap (view <span>#</span>awarded_bounty) <span>Control</span><span>.</span><span>Foldl</span><span>.</span>sum)</code></pre></div></div><p>we get</p><div><div><pre><code data-lang="text">{hitman_id :-&gt; 1, total_bounty :-&gt; 85000}
{hitman_id :-&gt; 3, total_bounty :-&gt; 27000}</code></pre></div></div><p>because hitman 2 doesn&#39;t appear in the erased marks table whereas it does in the hitmen table.</p><h3 id="headline-8">Get each hitman’s latest kill</h3><p>Fortunately we get to use <code>summarize</code> again.</p><div><div><pre><code data-lang="haskell"><span>latestHits</span> <span>::</span> <span>Query</span> <span>_</span> <span>Schema</span>
<span>latestHits</span> <span>=</span>
  table <span>@</span><span>&#34;erased_marks&#34;</span>
    <span>&amp;</span> summarize <span>@</span><span>&#34;latest_kill&#34;</span>
      (table <span>@</span><span>&#34;hitmen&#34;</span> <span>&amp;</span> project <span>@</span><span>&#39;[&#34;id&#34;]</span> <span>&amp;</span> rename <span>@</span><span>&#34;id&#34;</span> <span>@</span><span>&#34;hitman_id&#34;</span>)
      (<span>L</span><span>.</span>premap (view <span>#</span>created_at) <span>L</span><span>.</span>maximum)

<span>-- Results</span>
<span>-- {hitman_id :-&gt; 1, latest_kill :-&gt; Just 2019-02-02 00:00:00 UTC}</span>
<span>-- {hitman_id :-&gt; 2, latest_kill :-&gt; Nothing}</span>
<span>-- {hitman_id :-&gt; 3, latest_kill :-&gt; Just 2018-06-30 00:00:00 UTC}</span></code></pre></div></div><p>Again, with the short summarize form, we&#39;d get the same result without hitman 2.</p><div><div><pre><code data-lang="text">{hitman_id :-&gt; 1, latest_kill :-&gt; Just 2019-02-02 00:00:00 UTC}
{hitman_id :-&gt; 3, latest_kill :-&gt; Just 2018-06-30 00:00:00 UTC}</code></pre></div></div><p>This is slightly different from the versions of the query presented in the original post which use a sql <code>LEFT OUTER JOIN</code> to also get the mark associated with each of these kills. We can retrieve the associated marks with</p><div><div><pre><code data-lang="haskell"><span>latestKills</span> <span>=</span>
  table <span>@</span><span>&#34;erased_marks&#34;</span>
    <span>&amp;</span> summarize <span>@</span><span>&#34;latest_kill&#34;</span>
      (table <span>@</span><span>&#34;hitmen&#34;</span> <span>&amp;</span> project <span>@</span><span>&#39;[&#34;id&#34;]</span> <span>&amp;</span> rename <span>@</span><span>&#34;id&#34;</span> <span>@</span><span>&#34;hitman_id&#34;</span>)
      (<span>L</span><span>.</span>premap (view <span>#</span>created_at) <span>L</span><span>.</span>maximum)
    <span>&amp;</span> join (table <span>@</span><span>&#34;erased_marks&#34;</span>)
    <span>&amp;</span> restrict (<span>\</span>mark <span>-&gt;</span> (mark <span>^.</span> <span>#</span>latest_kill) <span>==</span> <span>Just</span> (mark <span>^.</span> <span>#</span>created_at))

<span>-- Results</span>
<span>-- {awarded_bounty :-&gt; 55000, created_at :-&gt; 2019-02-02 00:00:00 UTC, hitman_id :-&gt; 1, latest_kill :-&gt; Just 2019-02-02 00:00:00 UTC, mark_id :-&gt; 1, updated_at :-&gt; 2022-01-20 15:41:46.2046 UTC}</span>
<span>-- {awarded_bounty :-&gt; 27000, created_at :-&gt; 2018-06-30 00:00:00 UTC, hitman_id :-&gt; 3, latest_kill :-&gt; Just 2018-06-30 00:00:00 UTC, mark_id :-&gt; 3, updated_at :-&gt; 2022-01-20 15:41:46.2046 UTC}</span></code></pre></div></div><p>but this will throw out the results for hitman 2 who has no latest kills whereas the sql version will return nulls for all of the columns not present in the erased marks table. Semantically, these have the same interpretation – hitman 2 has no latest kill – but the difference in cardinality is noteworthy.</p><h3 id="headline-9">Get all the active marks that have only a single pursuer</h3><p>To get all active marks with only one pursuer, we group the pursuing marks over their hitman id and restrict the resulting tuples to ones with a single pursuer. It&#39;s helpful to see the intermediate steps here. First, we get rid of the time stamps and perform the initial grouping operation.</p><div><div><pre><code data-lang="haskell"><span>table</span> <span>@</span><span>&#34;pursuing_marks&#34;</span>
  <span>&amp;</span> project <span>@</span><span>&#39;[&#34;hitman_id&#34;, &#34;mark_id&#34;]</span>
  <span>&amp;</span> group <span>@</span><span>&#34;pursuers&#34;</span> <span>@</span><span>&#39;[&#34;hitman_id&#34;]</span>

<span>-- Results</span>
<span>-- {mark_id :-&gt; 2, pursuers :-&gt; [{hitman_id :-&gt; 1},{hitman_id :-&gt; 2},{hitman_id :-&gt; 3}]}</span>
<span>-- {mark_id :-&gt; 3, pursuers :-&gt; [{hitman_id :-&gt; 3}]}</span>
<span>-- {mark_id :-&gt; 4, pursuers :-&gt; [{hitman_id :-&gt; 2}]}</span></code></pre></div></div><p>From there, the rest of the filtering and projecting is straightforward.</p><div><div><pre><code data-lang="haskell"><span>singlePursuer</span> <span>=</span>
  table <span>@</span><span>&#34;pursuing_marks&#34;</span>
    <span>&amp;</span> project <span>@</span><span>&#39;[&#34;hitman_id&#34;, &#34;mark_id&#34;]</span>
    <span>&amp;</span> group <span>@</span><span>&#34;pursuers&#34;</span> <span>@</span><span>&#39;[&#34;hitman_id&#34;]</span>
    <span>&amp;</span> restrict (<span>\</span>mark <span>-&gt;</span> length (mark <span>^.</span> <span>#</span>pursuers) <span>==</span> <span>1</span>)
    <span>&amp;</span> project <span>@</span><span>&#39;[&#34;mark_id&#34;]</span>

<span>-- Results</span>
<span>-- {mark_id :-&gt; 3}</span>
<span>-- {mark_id :-&gt; 4}</span></code></pre></div></div><h3 id="headline-10">Get all the “marks of opportunity” (i.e. marks that a hitman erased without them marking the mark as being pursued first)</h3><p>To get this information, we join the pursuing marks and the erased marks on their mark ids and keep only the ones with different hitman ids. Again, the time stamps are irrelevant here and get in the way of our joins. Projecting them away has gotten a bit annoying, but fortunately we can create a function to do it for us.</p><div><div><pre><code data-lang="haskell"><span>removeTimeStamps</span> <span>::</span>
  forall t t&#39;<span>.</span>
  ( <span>Submap</span> <span>TimeStamps</span> t
  , <span>Submap</span> t&#39; t
  , t <span>:\\</span> <span>GetLabels</span> <span>TimeStamps</span> <span>~</span> t&#39;
  , t <span>:!!</span> <span>GetLabels</span> t&#39; <span>~</span> t&#39;
  ) <span>=&gt;</span>
  <span>Query</span> t <span>Schema</span> <span>-&gt;</span>
  <span>Query</span> t&#39; <span>Schema</span>
<span>removeTimeStamps</span> q <span>=</span> project <span>@</span>(<span>GetLabels</span> t&#39;) q</code></pre></div></div><p>Refactoring the previous queries to use this is left as an exercise for the reader. Now, the full query.</p><div><div><pre><code data-lang="haskell"><span>opportunity</span> <span>=</span>
  (table <span>@</span><span>&#34;erased_marks&#34;</span> <span>&amp;</span> rename <span>@</span><span>&#34;hitman_id&#34;</span> <span>@</span><span>&#34;erased_hitman_id&#34;</span> <span>&amp;</span> removeTimeStamps)
      <span>&amp;</span> join (table <span>@</span><span>&#34;pursuing_marks&#34;</span> <span>&amp;</span> rename <span>@</span><span>&#34;hitman_id&#34;</span> <span>@</span><span>&#34;pursuing_hitman_id&#34;</span> <span>&amp;</span> removeTimeStamps)
      <span>&amp;</span> restrict (<span>\</span>m <span>-&gt;</span> m <span>^.</span> <span>#</span>erased_hitman_id <span>/=</span> m <span>^.</span> <span>#</span>pursuing_hitman_id)

<span>-- Results</span>
<span>-- {awarded_bounty :-&gt; 30000, erased_hitman_id :-&gt; 1, mark_id :-&gt; 2, pursuing_hitman_id :-&gt; 2}</span>
<span>-- {awarded_bounty :-&gt; 30000, erased_hitman_id :-&gt; 1, mark_id :-&gt; 2, pursuing_hitman_id :-&gt; 3}</span></code></pre></div></div><p>In both cases, hitman 1 killed mark 2 whereas both hitmen 2 and 3 were pursuing mark 2. These both refer to the same mark of opportunity, which becomes clear when we project away the pursuing hitman id.</p><h2 id="headline-11">Conclusion</h2><p>That concludes our port of &#34;Fiver, but for paid killers.&#34; I don&#39;t have concrete plans for future installments in this series, but some potential ideas are</p><ul><li><p>optimizing common query cases and storage</p></li><li><p>using Databass as backing storage for a servant api</p></li><li><p>adding a real persistence layer and storing data transparently on disk instead of in memory</p></li></ul><p>Do let me know which of these you&#39;d like to see most or if you have any other ideas. Thanks for reading!</p></section></article></div>
  </body>
</html>
