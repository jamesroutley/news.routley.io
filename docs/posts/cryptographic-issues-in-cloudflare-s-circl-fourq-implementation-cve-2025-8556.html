<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.botanica.software/blog/cryptographic-issues-in-cloudflares-circl-fourq-implementation">Original</a>
    <h1>Cryptographic Issues in Cloudflare&#39;s Circl FourQ Implementation (CVE-2025-8556)</h1>
    
    <div id="readability-page-1" class="page"><div id="info"><div><section>
  <h2>Brief</h2>
  <p>
    In early 2025, while working on a project which required us to perform a broad audit of OSS elliptic curve implementations – we discovered several cryptographic issues in Cloudflare&#39;s CIRCL library – specifically with the implementation of the FourQ elliptic curve.
  </p>
  <p>
    We reported the issues through Cloudflare&#39;s HackerOne bug bounty plan in March 2025, and subsequently contacted Cloudflare directly, after having received a lukewarm and laconic response from the HackerOne triage team.
  </p>
  <p>
    Once the team at Cloudflare stepped in the issues were appropriately acknowledged and fixed.
  </p>

  <h2>FourQ, Cloudflare&#39;s CIRCL</h2>
  <p>
    <a href="https://github.com/cloudflare/circl" target="_blank">CIRCL</a>, which is Cloudflare&#39;s cryptography library, offers a basic implementation of the FourQ curve, as well as a Diffie-Hellman implementation named <code>Curve4Q</code> which offers shared secret functionality.
  </p>
  <p>
    FourQ is an elliptic curve with 128-bit security, developed by Microsoft Research and is defined by a twisted Edwards curve equation.
  </p>
  <p>
    The curve is defined over a two-dimensional extension of the prime field defined by the Mersenne prime \(p = 2^{127} - 1\), the curve twist parameter \(a = -1\) and \(d\) set to a quadratic nonresidue in \(F_{p^2}\).
  </p>
  <p>
    Simply put, much like the complex numbers are an extension field of the real numbers – the FourQ curve is defined over an extension of a prime field, its elements being of the form \(a + bi\) where \(a\) and \(b\) are in the integers\(\mod p\).
  </p>
  <p>
    In addition, the FourQ curve defines two endomorphisms, or structure-preserving functions, which serve as &#34;shortcuts&#34; to perform computations on the curve more efficiently.
  </p>
  <p>
    These endomorphisms, along with the other characteristics of the FourQ curve, make it fast and suitable for use-cases where computational resources are scarce – such as in embedded systems.
  </p>

  <h2>Invalid point attacks</h2>
  <p>
    A certain class of attacks on elliptic curve implementations allows an attacker to force the server to perform a calculation which discloses information about the secret key used.
  </p>
  <p>
    This type of attack is often called an invalid curve or invalid point attack, and stems from insufficient validation of the points used to perform the calculation.
  </p>
  <p>
    Elliptic Curve Diffie-Hellman or ECDH involves each side taking a secret scalar \(k\) and multiplying it with a fixed generator point \(G\) to compute the point \(Q = k*G\). Each side transmits its \(Q\) point, and receives the other side&#39;s \(Q\) point, multiplying it by his own \(k\) scalar. Since scalar multiplication in elliptic curves is commutative – both sides will end up with the same point.
  </p>
  <pre><code>// Shared calculates a shared key k from Alice&#39;s secret and Bob&#39;s public key.
// Returns true on success.
func Shared(shared, secret, public *Key) bool {
    var P, Q fourq.Point
    ok := P.Unmarshal((*[Size]byte)(public))
    Q.ScalarMult((*[Size]byte)(secret), &amp;P)
    Q.Marshal((*[Size]byte)(shared))
    ok = ok &amp;&amp; Q.IsOnCurve()
    return ok
}
</code>
  </pre>
  <p>
    An example from CIRCL&#39;s <code>Curve4Q</code> implementation (pre-remediation), shows a shared secret being calculated, by taking as input a public point (<code>P</code>) and a secret scalar, and multiplying them.
  </p>
  <p>
    The issue arises when the computation is done without first verifying that the other side&#39;s point is a valid point on the curve. The reason is that in order to be secure – all points on an elliptic curve must be members of an \(N\)-torsion subgroup, where \(N\) is the order of the curve – the total amount of points on the curve.</p>
  <p>
    Meaning if one multiplies a certain point \(Q\) by the secret scalar \(k\), if the point is valid and on the expected curve, the result should land in any of the \(N\) points on the curve. For the curve to be considered secure, it must have an order \(N\) which is either a prime number, or composed from a large prime number and a small cofactor.
  </p>
  <p>
    This is what makes the discrete logarithm problem difficult with regards to scalar multiplication, thus creating a &#34;trap-door&#34; function where it is easy to perform the multiplication, but hard to reverse it.
  </p>
  <p>
    If an attacker is able to force the server to perform the scalar multiplication of his secret \(k\) with an invalid point \(\widehat{Q}\) which is not on the curve – he may choose \(\widehat{Q}\) such that it belongs to a curve with a smooth (composed of many small factors) subgroup order \(\widehat{N}\).
  </p>
  <p>
    As a result – instead of \(k*Q\) computing any possible point on the original curve, it will instead land in any of a smaller set of points.</p>
  <p>
    If repeated for multiple invalid points, with different subgroup orders, and in combination with the Chinese Remainder Theorem, the attacker will eventually be able to extract the server&#39;s secret \(k\) value.
  </p>

  <h2>Degenerate curve attacks on Edwards curves</h2>
  <p>
    The above attack is applicable on a form of elliptic curves called Weierstrass curves. While Edwards curves are birationally equivalent to Weierstrass curves, meaning a curve such as FourQ may be represented using Weierstrass formulas – the invalid curve attack as presented in the previous section does not generalize to Edwards curve.
  </p>
  <!-- Load MathJax -->



<div>
<p><strong>Weierstrass addition</strong> (x₁ != x₂):</p>
  <p>
  \[
  \lambda = \frac{y_2 - y_1}{x_2 - x_1}
  \]
  </p>

  <p>
  \[
  x_3 = \lambda^2 - x_1 - x_2
  \]
  </p>

  <p>
  \[
  y_3 = \lambda (x_1 - x_3) - y_1
  \]
  </p>

  <p><strong>Edwards addition:</strong></p>

  <p>
  \[
  x_3 = \frac{x_1 y_2 + y_1 x_2}{1 + d x_1 x_2 y_1 y_2}
  \]
  </p>

  <p>
  \[
  y_3 = \frac{y_1 y_2 - a x_1 x_2}{1 - d x_1 x_2 y_1 y_2}
  \]
  </p>
</div>
  <p>
    The reason for this is that while addition using the Weierstrass formulas is independent of the curve parameters, Edwards addition formulas are dependent on both curve parameters \(a\) and \(d\), which makes it impossible (or more accurately very difficult) to pass arbitrary points, i.e. points which are not on the curve and have the server perform addition on them correctly.
  </p>
  <p>
    If we take a closer look at the Edwards addition formula, we see that the curve parameters (\(a\) and \(d\)) are coefficients of the \(x\) variable – meaning if we affix \(x\) to 0, the curve parameters cancel out and we are left with a less generalized invalid point attack which does work on all Edwards curves.
  </p>
  <p>
    Concretely – if we pass in a point of form \((0, y)\), the result of multiplying it by the secret value \(k\) computes \((0, y^k)\). As such, if we select an appropriate \(y\) value such that the point \((0, y)\) has a small multiplicative subgroup order, and receive the value \((0, y^k)\) – solving the discrete logarithm problem to recover \(k\) becomes trivial.
  </p>

  <h2>CVE-2015-8556</h2>
  <p>
    In consideration of the invalid curve attacks presented above, the main adversarial threat to ECC implementation lies with performing computations on invalid points – points which are not on the graph.
    As such – points should always be validated before being relied upon for any computation.
  </p>
  <p>
    At minimum, the process of unmarshalling a point, meaning loading an appropriate length byte-array and converting it to a point on the curve – should ensure that the point loaded is indeed a valid point on the curve – simply by checking if the curve equation holds.
  </p>
  <p>
    For added security – the point should also be validated before being used in any of the basic computations – addition, doubling/scalar multiplication.
  </p>
  <p>
    While auditing CIRCL&#39;s FourQ implementation we pinpointed 7 total issues related to these security primitives, as well as to the testing code – which incorrectly demonstrated some security proofs.
  </p>
  <p>
    Below is a short description of the 4 major points we raised, and were to some extent addressed by the fixes to CIRCL.
  </p>

  <h3>Incorrect point validation in <code>Point.Unmarshal</code></h3>
  <p>
    The issue here is a missing step – the IETF spec for FourQ accounts for some ambiguity in the unmarshalling process by conjugating the point&#39;s \(x\) value – if not the unmarshalled point nor its conjugate are valid points on the curve – the unmarshalled point is invalid.
  </p>
  <p>
    The IETF spec contains the following pseudocode:
  </p>
  <pre>if -x^2+y^2 != 1+d*x^2*y^2:  # Check curve equation with x
     x = conj(x)
if -x^2+y^2 != 1+d*x^2*y^2:  # ... or its conjugate
     return FAILED
return P = (x,y)
  </pre>
  <p>
    The CIRCL implementation fails to re-validate the point being on the curve after conjugating its \(x\) value:
  </p>
  <pre>if !P.IsOnCurve() {
    fpNeg(&amp;P.X[1], &amp;P.X[1])
}
return true
  </pre>

  <h3>Faulty point comparison in <code>pointR1.isEqual</code></h3>
  <p>
    The CIRCL code, as per the IETF spec, uses several representations of projected coordinates – this means that in addition to the \(x\) and \(y\) value, each point also has an additional \(Z\), \(Ta\) and \(Tb\) values, where \(Z * Ta * Tb \equiv x * y\).
  </p>
  <p>
    The issue here is that if \(Z\) is set to 0 – which is invalid in the context of the projected representation – the <code>isEqual</code> check always returns true.
  </p>
  <p>
    Several checks in the code were affected by the issue, including faulty tests.
  </p>

  <h3>Lack of point validation in <code>pointR1.ClearCofactor</code></h3>
  <p>
    Since the FourQ curve has a cofactor of 392 – meanings its order is not a prime number but rather a prime number multiplied by 392 – in order to ensure that the point being used for computation is an \(N\)-torsion point, the cofactor must be cleared by multiplying the point by 392 prior to any additional scalar multiplications.</p>
  <p>
    The CIRCL implementation deviates from the spec by failing to perform this verification after clearing the cofactor.
  </p>

  <h3>Lack of point validation in <code>pointR1.ScalarMult</code></h3>
  <p>
    The scalar multiplication implementation on <code>pointR1</code> assumes that the projected values are valid, and that the point is indeed on the curve.</p>
  <p>
    Fixing the unmarshalling issue prevents this issue, as does the change to the code in <code>Curve4Q</code> which performs the DH computation.</p>

  <h2>References</h2>
  <ul>
    <li><a href="https://eprint.iacr.org/2015/1233.pdf" target="_blank">https://eprint.iacr.org/2015/1233.pdf</a></li>
    <li><a href="https://www.ietf.org/archive/id/draft-ladd-cfrg-4q-01.txt" target="_blank">https://www.ietf.org/archive/id/draft-ladd-cfrg-4q-01.txt</a></li>
    <li><a href="https://eprint.iacr.org/2015/565.pdf" target="_blank">https://eprint.iacr.org/2015/565.pdf</a></li>
  </ul>
  
  


</section></div></div></div>
  </body>
</html>
