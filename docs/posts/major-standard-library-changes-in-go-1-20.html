<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.carlmjohnson.net/post/2023/golang-120-arenas-errors-responsecontroller/">Original</a>
    <h1>Major standard library changes in Go 1.20</h1>
    
    <div id="readability-page-1" class="page"><div><div><main><article><header><time datetime="2023-01-17T00:00:00Z">Tuesday, January 17, 2023</time></header><section><p>In <a href="http://pepijndevos.nl/post/2023/golang-120-language-changes/">the first part of <strong>What‚Äôs New in Go 1.20</strong></a>, we looked at language changes. For part two, I would like to introduce three changes to the standard library that address problems that the community has been thinking about and debating solutions to for years.</p><hr/><p>First of all, a whole new package has been added. But you can‚Äôt import it by default, and <strong>you probably shouldn‚Äôt be using it at all</strong>. It‚Äôs the new experimental arena package.</p><p>The arena package <a href="https://golang.org/issue/51317">was proposed</a> by Dan Scales and has been added to the Go standard library in 1.20. But if you just try to add <code>import &#34;arena&#34;</code> to a program, you get the following, somewhat cryptic error message:</p><pre tabindex="0"><code>imports arena: build constraints exclude all Go files in GOROOT/src/arena
</code></pre><p>To opt into using arenas, you need to set <code>GOEXPERIMENT=arenas</code> when calling the go tool, like <code>GOEXPERIMENT=arenas go build .</code>.</p><p>So what are arenas and why is the Go team trying so hard to keep you from using them? I asked <a href="https://chat.openai.com">ChatGPT</a>, and this is what it said (this is the equivalent of quoting Webster‚Äôs Dictionary for the 21st century):</p><blockquote><p>Memory arenas are a memory management technique used in some programming languages and libraries to allocate and deallocate large blocks of memory efficiently. They are typically used in situations where the program needs to frequently allocate and deallocate a large number of small objects. By allocating and deallocating memory in large blocks, rather than individually for each object, memory arenas can reduce the overhead associated with memory management and improve performance.</p></blockquote><p>If you want to go more in-depth, Uptrace has <a href="https://uptrace.dev/blog/posts/go-memory-arena.html">a nice guide to the arena package</a> (presumably written by a human, but who knows nowadays), but I‚Äôll try to just give a basic overview here.</p><p>As you probably know, Go is a <strong>garbage collected</strong> language. This means that when you refer to a variable, the compiler and the runtime automatically keep track of the uses of that variable to see when it comes into use and when it is no longer being used. Once a variable is no longer used, it is ‚Äúgarbage‚Äù waiting to be collected.</p><p>For many kinds of applications, garbage comes in waves. For example, if you have a web server, it may allocate a lot of memory in order to build up a response to some user request, but once it responds, it no longer needs any of the memory that it allocated, so it can all be returned to the system at once. Another example is a game might want to free all of the objects created for a level once the level is over. The arena package lets Gophers opt into this approach to memory management in performance critical code. Instead of having the garbage collector start a root and then travel down to ‚Äúmark and sweep‚Äù the live memory and return the dead objects, the whole arena can be marked as dead all at once. The release notes for Go 1.20 claim that</p><blockquote><p>When used appropriately, [using package arena] has the potential to improve CPU performance by up to 15% in memory-allocation-heavy applications.</p></blockquote><p>This is highly efficient, but also highly dangerous. What if the programmer makes a mistake, and for example, adds some strings to a logger call that outlives the request? The log might be overwritten by a subsequent request and the string become replaced with junk data, leading to crashes or worse‚Äîsecurity exploits.</p><p>To mitigate the risk of these kinds of bugs, the arena package will deliberately cause a panic if can detect someone reusing memory after it has been freed. Dan Scales <a href="https://golang.org/issue/51317">explains</a>,</p><blockquote><ul><li>Each arena A uses a distinct range in the 64-bit virtual address space</li><li>A.Free unmaps the virtual address range for arena A</li><li>The physical pages for the arena can then be reused by the operating system for other arenas.</li><li>If a pointer to an object in arena A still exists and is dereferenced, it will get a memory access fault, which will cause the Go program to terminate. Because the implementation knows the address ranges of arenas, it can give an arena-specific error message during the termination.</li></ul></blockquote><p>There is a similar comment <a href="https://github.com/golang/go/blob/1c65b69bd1dbc930c6246877f6c21c81f2a60d55/src/runtime/arena.go#L14:L18">in the Go runtime package</a> that implements memory arenas:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>// What makes the arenas here safe is that once they are freed, accessing the
</span></span></span><span><span><span>// arena&#39;s memory will cause an explicit program fault, and the arena&#39;s address
</span></span></span><span><span><span>// space will not be reused until no more pointers into it are found. There&#39;s one
</span></span></span><span><span><span>// exception to this: if an arena allocated memory that isn&#39;t exhausted, it&#39;s placed
</span></span></span><span><span><span>// back into a pool for reuse. This means that a crash is not always guaranteed.
</span></span></span></code></pre></div><p>So, it is still possible to write buggy code with arenas, but hopefully, the bugs will translate into simple crashes rather than full blown memory corruption or security exploits.</p><p>The arena package has a fairly simple API. Here‚Äôs some example code from <code>arenas_test.go</code>:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>a</span> <span>:=</span> <span>arena</span><span>.</span><span>NewArena</span><span>()</span>
</span></span><span><span><span>defer</span> <span>a</span><span>.</span><span>Free</span><span>()</span>
</span></span><span><span>
</span></span><span><span><span>tt</span> <span>:=</span> <span>arena</span><span>.</span><span>New</span><span>[</span><span>T1</span><span>](</span><span>a</span><span>)</span>
</span></span><span><span><span>tt</span><span>.</span><span>n</span> <span>=</span> <span>1</span>
</span></span><span><span>
</span></span><span><span><span>ts</span> <span>:=</span> <span>arena</span><span>.</span><span>MakeSlice</span><span>[</span><span>T1</span><span>](</span><span>a</span><span>,</span> <span>99</span><span>,</span> <span>100</span><span>)</span>
</span></span><span><span><span>// ‚Ä¶
</span></span></span></code></pre></div><p>There is also an <code>arena.Clone</code> function for when you want to move an object out of an arena and onto the regular Go memory heap.</p><p>With luck, the arena experiment will succeed, and we will see it introduced as a regular package in a future version of Go.</p><hr/><p>While most Go programmers probably will never need to use the arena package directly, I suspect virtually all Go programmers will have some occasion to use a different new feature in Go 1.20: multierrors.</p><p>The concept of multierrors in Go is not new. Hashicorp‚Äôs go-multierror package <a href="https://github.com/hashicorp/go-multierror/commit/31fee45604949934710ada68f0b307c4726fb4e8">goes all the way back to 2014</a> and there was at least one proposal to add multierrors to the standard library <a href="https://github.com/golang/go/issues/20984">by 2017</a>.</p><p>Multierrors also exist in other languages. Python added <a href="https://peps.python.org/pep-0654/">exception groups</a> to Python 3.11, for example. In the case of Python, while there was a popular third party MultiError class, it ultimately needed to be added to the language for full operability:</p><blockquote><p>Changes to the language are required in order to extend support for exception groups in the style of existing exception handling mechanisms. At the very least we would like to be able to catch an exception group only if it contains an exception of a type that we choose to handle. Exceptions of other types in the same group need to be automatically reraised, otherwise it is too easy for user code to inadvertently swallow exceptions that it is not handling.</p></blockquote><p>Unlike Python, in Go, <a href="https://go.dev/blog/errors-are-values">errors are just values</a>, so it was easy enough to create your own multierror type and expose it <a href="http://pepijndevos.nl/post/2020/working-with-errors-as/">using errors.As</a>. Indeed, I wrote <a href="https://github.com/carlmjohnson/errutil">my own multierror package</a> that worked this same way. This was clearly an idea that was being created and recreated by the community, so did it really need to be solved at the level of the standard library?</p><p>Suppose I have some code like this:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>a</span> <span>:=</span> <span>errors</span><span>.</span><span>New</span><span>(</span><span>&#34;a&#34;</span><span>)</span>
</span></span><span><span><span>b</span> <span>:=</span> <span>errors</span><span>.</span><span>New</span><span>(</span><span>&#34;b&#34;</span><span>)</span>
</span></span><span><span><span>c</span> <span>:=</span> <span>join</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span>
</span></span><span><span><span>d</span> <span>:=</span> <span>fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;more context: %w&#34;</span><span>,</span> <span>c</span><span>)</span>
</span></span><span><span><span>e</span> <span>:=</span> <span>errors</span><span>.</span><span>New</span><span>(</span><span>&#34;e&#34;</span><span>)</span>
</span></span><span><span><span>f</span> <span>:=</span> <span>join</span><span>(</span><span>d</span><span>,</span> <span>e</span><span>)</span>
</span></span></code></pre></div><p>If <code>join</code> flattens the error list, then <code>d</code> (‚Äúmore context‚Äù) will be lost from the resulting multierror. Inside of <code>f</code> will be <code>a</code>, <code>b</code>, and <code>e</code>, but not <code>d</code>.</p><figure><p><svg xmlns="http://www.w3.org/2000/svg" font-family="Menlo,Lucida Console,monospace" viewBox="0 0 104 57"><g transform="translate(8,16)"><path d="M24 0h8" fill="none" stroke="currentcolor"></path><path d="M64 0h8" fill="none" stroke="currentcolor"></path><path d="M48 8V24" fill="none" stroke="currentcolor"></path><path d="M24 0A16 16 0 008 16" fill="none" stroke="currentcolor"></path><path d="M72 0A16 16 0 0188 16" fill="none" stroke="currentcolor"></path><text text-anchor="middle" x="8" y="36" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="48" y="4" fill="currentcolor" style="font-size:1em">f</text><text text-anchor="middle" x="48" y="36" fill="currentcolor" style="font-size:1em">b</text><text text-anchor="middle" x="88" y="36" fill="currentcolor" style="font-size:1em">e</text></g></svg></p></figure><p>If you are just using your own multierror package in your own application, this is basically a theoretical concern, because you can make sure not to add context around a multierror wherever it might be lost. But if multierrors are part of the standard library and can be expected to be used regularly, then losing <code>d</code> is a real problem that could pop up at unwanted times and places. This problem is what sunk <a href="https://github.com/golang/go/issues/47811">one of the more recent multierror proposals</a>.</p><p>The reason that Damien Neil‚Äôs <a href="https://github.com/golang/go/issues/53435">latest multierror proposal</a> has succeeded where other multierror proposals did not is that it creates a <em>tree</em> of errors, rather than a slice. The accepted <a href="https://pkg.go.dev/errors@go1.20rc2#Join">errors.Join</a> code instead represents the error hierarchy like this:</p><figure><p><svg xmlns="http://www.w3.org/2000/svg" font-family="Menlo,Lucida Console,monospace" viewBox="0 0 144 121"><g transform="translate(8,16)"><path d="M64 0h8" fill="none" stroke="currentcolor"></path><path d="M104 0h8" fill="none" stroke="currentcolor"></path><path d="M24 64h8" fill="none" stroke="currentcolor"></path><path d="M64 64h8" fill="none" stroke="currentcolor"></path><path d="M48 40V56" fill="none" stroke="currentcolor"></path><path d="M64 0A16 16 0 0048 16" fill="none" stroke="currentcolor"></path><path d="M112 0a16 16 0 0116 16" fill="none" stroke="currentcolor"></path><path d="M24 64A16 16 0 008 80" fill="none" stroke="currentcolor"></path><path d="M72 64A16 16 0 0188 80" fill="none" stroke="currentcolor"></path><text text-anchor="middle" x="8" y="100" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="48" y="36" fill="currentcolor" style="font-size:1em">d</text><text text-anchor="middle" x="48" y="68" fill="currentcolor" style="font-size:1em">c</text><text text-anchor="middle" x="88" y="4" fill="currentcolor" style="font-size:1em">f</text><text text-anchor="middle" x="88" y="100" fill="currentcolor" style="font-size:1em">b</text><text text-anchor="middle" x="128" y="36" fill="currentcolor" style="font-size:1em">e</text></g></svg></p></figure><p>This means that all of the nodes in the tree are still available for inspection using <code>errors.Is</code> or <code>errors.As</code>.</p><p>In Go 1.20, multierrors can be created either with <code>errors.Join(errs ...error) error</code> or by using multiple <code>%w</code> verbs with <code>fmt.Errorf</code> like <code>fmt.Errorf(&#34;%w: %w&#34;, notFoundErr, dbErr)</code>. Once created, <code>errors.Is</code> and <code>errors.As</code> can extract any of the values in the tree, whether they are in a leaf like <code>a</code>, <code>b</code> and <code>e</code> or a branch like <code>d</code>. Users can also create their own multierror types by adding an <code>Unwrap() []error</code> method to their custom error type.</p><p>One wrinkle in the implementation is that for now at least, there is no <code>errors.Split(error) []error</code> function. This is a deliberate omission, since that would flatten the tree. Instead, if you need to inspect every node in a tree (for example, for logging purposes), you are encouraged to traverse the tree yourself. I suspect that if we ever see <a href="https://github.com/golang/go/discussions">a generic iterator type</a> in Go, something that automatically walks the tree might be added then.</p><hr/><p>Finally, lets look at <code>http.ResponseController</code>.</p><p>Interfaces are one Go‚Äôs defining features as a language. With an interface, you can specify that your code can accept any value that has a certain method, no matter what its concrete type is.</p><p>From the early days of Go, interfaces have also been used for what <a href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoInterfaceSmuggling">Chris Siebenmann has called ‚Äúinterface smuggling‚Äù</a>:</p><blockquote><p>In interface smuggling, the actual implementation is augmented with additional well known APIs, such as <a href="https://golang.org/pkg/io/#ReaderFrom">io.ReaderFrom</a> and <a href="https://golang.org/pkg/io/#WriterTo">io.WriterTo</a>. Functions that want to work more efficiently when possible, such as <a href="https://golang.org/pkg/io/#Copy">io.Copy()</a>, attempt to convert the io.Reader or io.Writer they obtained to the relevant API and then use it if the conversion succeeded:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>if</span> <span>wt</span><span>,</span> <span>ok</span> <span>:=</span> <span>src</span><span>.(</span><span>WriterTo</span><span>);</span> <span>ok</span> <span>{</span>
</span></span><span><span>   <span>return</span> <span>wt</span><span>.</span><span>WriteTo</span><span>(</span><span>dst</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span><span><span><span>if</span> <span>rt</span><span>,</span> <span>ok</span> <span>:=</span> <span>dst</span><span>.(</span><span>ReaderFrom</span><span>);</span> <span>ok</span> <span>{</span>
</span></span><span><span>   <span>return</span> <span>rt</span><span>.</span><span>ReadFrom</span><span>(</span><span>src</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span><span><span><span>[</span><span>...</span> <span>do</span> <span>copy</span> <span>ourselves</span> <span>...</span><span>]</span>
</span></span></code></pre></div><p>I call this interface smuggling because we are effectively smuggling a different, more powerful, and broader API through a limited one. In the case of types supporting io.WriterTo and io.ReaderFrom, io.Copy completely bypasses the nominal API; the .Read() and .Write() methods are never actually used, at least directly by io.Copy (they may be used by the specific implementations of .WriteTo() or .ReadFrom(), or more interface smuggling may take place).</p></blockquote><p>Russ Cox deemed this pattern the somewhat less pejorative sounding <a href="https://www.youtube.com/watch?v=yx7lmuwUNv8&amp;t=931s">‚Äúextension interface pattern‚Äù</a>. Whatever you call it, this pattern can be a great way to expose a simple API and still leave room for adding more complicated extensions later.</p><p>Extension interfaces are useful, but not without their pitfalls. There can be be cases where it would be good to implement an extended interface, but an implementation author isn‚Äôt aware of it, so they fail to implement it. This can be addressed with documentation, but it‚Äôs not as clear as using the type system directly.</p><p>What if you want to create a wrapper a simple interface that you <em>do</em> know might also implement an extended interface? How to do this depends on what exactly you‚Äôre wrapping and why. If you were creating a new version of <a href="https://pkg.go.dev/io#LimitedReader">io.LimitedReader</a>, it wouldn‚Äôt make sense to add a <code>WriteTo</code> method. The whole point is to put a cap on how much can be read from the source reader, not bypass it and hook it up to the writer directly. As an implementation author, you need to think carefully about how extended interfaces interact with your type.</p><p>Another problem is if the extended interface can only be tested for through a <a href="https://go.dev/ref/spec#Type_assertions">type assertion</a>. In that case, as the author of a wrapper, you need to provide two wrapping types: one that has the extended interface and passes calls through to the underlying type, and one that doesn‚Äôt have the method, so it won‚Äôt spuriously trigger the type assertion. Worse still, if there are multiple extended interfaces you want to be able to wrap, you need to provide a 2<sup>N</sup> number of types to provide for every variation of extended interfaces coexisting<i>!</i> This may seem absurd, but this is exactly the situation that library authors who wanted to wrap <a href="https://pkg.go.dev/net/http#ResponseWriter">http.ResponseWriter</a> found themselves in.</p><p><code>http.ResponseWriter</code> is a fairly simple interface used for HTTP servers in the Go standard library:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>type</span> <span>ResponseWriter</span> <span>interface</span> <span>{</span>
</span></span><span><span>    <span>Header</span><span>()</span> <span>Header</span>
</span></span><span><span>    <span>WriteHeader</span><span>(</span><span>statusCode</span> <span>int</span><span>)</span>
</span></span><span><span>    <span>io</span><span>.</span><span>Writer</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>You can set the headers on a response. You can set the status code on the response (which also causes the headers to be written on the wire). And you can write the body of a response. Simple<i>!</i></p><p>But of course, the Go http package also supports a number of extended interfaces for <code>ResponseWriter</code>. These are <a href="https://pkg.go.dev/net/http#Flusher">http.Flusher</a> (which lets you flush an in progress write to its clients), <a href="https://pkg.go.dev/net/http#Pusher">http.Pusher</a> (which lets you do HTTP/2 server push requests), <a href="https://pkg.go.dev/net/http#Hijacker">http.Hijacker</a> (which provides access to the underlying <code>net.Conn</code>), and <a href="https://pkg.go.dev/io#ReaderFrom">io.ReaderFrom</a> (which allows for nice things like automatic <a href="https://man7.org/linux/man-pages/man2/sendfile.2.html">sendfile</a> support). As a result, the go-chi project has <a href="https://github.com/go-chi/chi/blob/master/middleware/wrap_writer.go">six different types to implement its <code>WrapResponseWriter</code> interface type</a>. (This is cut down from 2<sup>4</sup> to 2<sup>3</sup> on the theory that anything which implements HTTP/2 server push must be maximally fancy.)</p><p>So then all the way back in 2016, Filippo Valsorda opened <a href="https://github.com/golang/go/issues/16100">an issue about setting timeouts in an <code>http.Handler</code></a>. This was clearly a real need the Go community had, but it was hard to see how to make it work while retrofitting it into the existing <code>http.ResponseWriter</code> interface. It would be great to set server timeouts for a client based on what we know about that client, but how can this functionality be exposed? Do we just <a href="https://www.theonion.com/fuck-everything-were-doing-five-blades-1819584036">go straight from 3 to 5</a> optional methods defined in the http package?</p><p>Despite a lot of careful thought about the problem, this was the situation until Go 1.20, when Damien Neil successfully landed the <a href="https://github.com/golang/go/issues/54136"><code>http.ResponseController</code> proposal</a>. As he wrote,</p><blockquote><p>A problem is that we have no good place at the moment to add functions that adjust these timeouts. We might add methods to the <code>ResponseWriter</code> implementation and access them via type assertions (as is done with the existing <code>Flush</code> and <code>Hijack</code> methods), but this proliferation of undiscoverable magic methods scales poorly and does not interact well with middleware which wraps the <code>ResponseWriter</code> type.</p></blockquote><p>The solution he came up with based on prior discussions was to add a new concrete type, <a href="https://pkg.go.dev/net/http@go1.20rc2#ResponseController">http.ResponseController</a>:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>// NewResponseController creates a ResponseController for a request.
</span></span></span><span><span><span>//
</span></span></span><span><span><span>// The ResponseWriter should be the original value passed to the Handler.ServeHTTP method,
</span></span></span><span><span><span>// or have an Unwrap method returning the original ResponseWriter.
</span></span></span><span><span><span>//
</span></span></span><span><span><span>// If the ResponseWriter implements any of the following methods, the ResponseController
</span></span></span><span><span><span>// will call them as appropriate:
</span></span></span><span><span><span>//
</span></span></span><span><span><span>//  Flush()
</span></span></span><span><span><span>//  FlushError() error // alternative Flush returning an error
</span></span></span><span><span><span>//  Hijack() (net.Conn, *bufio.ReadWriter, error)
</span></span></span><span><span><span>//  SetReadDeadline(deadline time.Time) error
</span></span></span><span><span><span>//  SetWriteDeadline(deadline time.Time) error
</span></span></span><span><span><span>//
</span></span></span><span><span><span>// If the ResponseWriter does not support a method, ResponseController returns
</span></span></span><span><span><span>// an error matching ErrNotSupported.
</span></span></span><span><span><span></span><span>func</span> <span>NewResponseController</span><span>(</span><span>rw</span> <span>ResponseWriter</span><span>)</span> <span>*</span><span>ResponseController</span>
</span></span></code></pre></div><p>There are two aspects of <code>http.ResponseController</code> that fix the problems with the earlier extension interfaces. One, the addition of an <code>Unwrap() http.ResponseWriter</code> method allows middleware to easily wrap a <code>ResponseWriter</code> without needing to provide all the extended interface methods. Two, the addition of <a href="https://pkg.go.dev/net/http@go1.20rc2#ErrNotSupported">ErrNotSupported</a> makes it easy for types that do have extended methods to signal to their callers when the types they wrap don‚Äôt have the same extended methods they do. These are best practices for extended interfaces that have emerged from experience using them. If you provide an extended interface, also provide an escape hatch for wrapper types that don‚Äôt know if their wrapped types will have the extended types or not.</p><p>This is my blog, so I will immodestly mention that I had <a href="https://github.com/golang/go/issues/39558">a proposal for adding an <code>Unwrap</code> method to <code>ResponseWriter</code></a> back in 2020, but my proposal didn‚Äôt have a concrete type to handle the unwrapping or <code>ErrNotSupported</code>, and I‚Äôm not sufficiently in the weeds of the http package to have been able to implement read/write deadlines if I had known to suggest it as a motivating problem. The 3 line long <a href="https://github.com/golang/go/commit/55e6e825d4c90544248c3a725b4dee9fb45848e7">http.MaxBytesHandler</a> is about the limit of my ability to contribute. üòÜ</p><hr/><p>For all three of these changes written about above, the moral of the story is that when it comes to the Go standard library, it can take sometimes years for all the pieces of a good solution to come together in one place, but when they do, it can solve a longstanding problem in a way that makes things easier for everyone involved going forward. Even the authors of Go didn‚Äôt know what idiomatic Go code looked like when they wrote the standard library, but working together today we can evolve the standard library in a way that adds new capabilities while preserving backwards compatibility, so that everyone benefits.</p></section></article></main></div></div></div>
  </body>
</html>
