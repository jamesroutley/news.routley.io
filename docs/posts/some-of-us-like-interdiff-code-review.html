<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gist.github.com/thoughtpolice/9c45287550a56b2047c6311fbadebed2">Original</a>
    <h1>Some of us like &#34;interdiff&#34; code review</h1>
    
    <div id="readability-page-1" class="page"><div>
  <div id="file-index-md">
      
      <div id="file-index-md-readme">
    <article itemprop="text">
<p dir="auto">I am currently in the process of evaluating <a href="https://www.gerritcodereview.com/" rel="nofollow">Gerrit Code Review</a> for work. Gerrit is an open source code review tool, as the name might imply, and works with Git repositories. What that means is that given some repository, you can:</p>
<ol dir="auto">
<li>Write patches to the codebase, and submit them for review</li>
<li>Other people look at the code you wrote</li>
<li>They leave comments telling you to fix various problems</li>
<li>You might even fix some of them</li>
<li>Code review is a pretty good idea, in general</li>
<li>If it&#39;s open source, someone might merge your code, and you let out a sigh of relief, knowing that you are off the hook and have increased their responsibilities and technical debt for all time</li>
<li>If it&#39;s open source, you then disappear into an eternal void, never to be seen or heard from again by the maintainer</li>
</ol>
<p dir="auto">There are many tools you can use to increase the burden on all future developers like this, such as:</p>
<ul dir="auto">
<li>Gerrit</li>
<li>GitHub (the website you are on)</li>
<li>Phabricator (RIP)</li>
<li>Uploading <code>.patch</code> files into a bug tracker and waiting until the maintainer sees it, downloads it, and reads it</li>
<li>Emailing someone via <code>git send-email</code> telling them to pull from a <code>git://</code> URL that is hosted on a 7 year old &#34;server&#34; somewhere in your house and then reading the email they send back</li>
<li>Implainting the idea in your coworkers head with a long discussion so that they end up implementing it while you do something else</li>
</ul>
<p dir="auto">I have done all of these, both as the person writing <em>and</em> reviewing the patches, and they are all workable to various degrees.</p>
<p dir="auto">Some open source projects also use Gerrit, such as the Go programming language. Some, like KDE and LLVM, used Phabricator. We have entertained the idea of using Gerrit for <a href="https://github.com/martinvonz/jj">Jujutsu</a>. Linux, the kernel itself, uses the email workflow in a particular and special way. Most projects use GitHub, because it is easy and has zero activation energy.</p>
<p dir="auto">But why are these tools important? Doesn&#39;t everyone just use GitHub? Isn&#39;t that good enough? Are all these really the same? No, they are not.</p>

<p dir="auto">The following image indicates a series of 3 patches, to be submitted to a software project. They have a typical child/parent relationship, like any linear sequence of commits in Git would have. We call this a <em>series</em> because it isn&#39;t just a <em>patch</em>. It&#39;s a &#34;series&#34; of &#34;three&#34; &#34;patches.&#34; Get it?</p>
<p dir="auto">This series represents, believe it or not, something close to the <em>ideal</em> patch series — for the author, the reviewer, and the future schmuck who will inherit your codebase. You can ignore the exact numbers for a second and whether 500LOC is too much (we&#39;ll get back to it.)</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://private-user-images.githubusercontent.com/3416/304284460-8c866c0e-0d8e-43d5-90cb-647c29799cc2.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjYwNDY1MzMsIm5iZiI6MTcyNjA0NjIzMywicGF0aCI6Ii8zNDE2LzMwNDI4NDQ2MC04Yzg2NmMwZS0wZDhlLTQzZDUtOTBjYi02NDdjMjk3OTljYzIucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI0MDkxMSUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDA5MTFUMDkxNzEzWiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9NmEwZTE5YmU1YTlhNzAxYWMyZGZlZTU2MjQ3OTNmOTFhNTIwMDY1MmZiY2UxMzVhOWRlZWM3Y2RhN2YxMzJlZCZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QmYWN0b3JfaWQ9MCZrZXlfaWQ9MCZyZXBvX2lkPTAifQ.-GRrTMgXiqrk78r1ZQ7-L4C77pbgFsGXPEfA2QdXIGQ"><img width="510" alt="image" src="https://private-user-images.githubusercontent.com/3416/304284460-8c866c0e-0d8e-43d5-90cb-647c29799cc2.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjYwNDY1MzMsIm5iZiI6MTcyNjA0NjIzMywicGF0aCI6Ii8zNDE2LzMwNDI4NDQ2MC04Yzg2NmMwZS0wZDhlLTQzZDUtOTBjYi02NDdjMjk3OTljYzIucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI0MDkxMSUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDA5MTFUMDkxNzEzWiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9NmEwZTE5YmU1YTlhNzAxYWMyZGZlZTU2MjQ3OTNmOTFhNTIwMDY1MmZiY2UxMzVhOWRlZWM3Y2RhN2YxMzJlZCZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QmYWN0b3JfaWQ9MCZrZXlfaWQ9MCZyZXBvX2lkPTAifQ.-GRrTMgXiqrk78r1ZQ7-L4C77pbgFsGXPEfA2QdXIGQ"/></a>
</p>
<ol dir="auto">
<li>You&#39;re going to do a &#34;thing&#34;, but notice you can clean up some code, coincidentally.</li>
<li>You write a bunch of code — in this case, you add a new API to the codebase. Maybe it&#39;s a fast data structure, intended to replace a slower one.</li>
<li>You migrate the users of the old API to the new API. Your program is now faster.</li>
</ol>
<p dir="auto">The most important point is that changes are:</p>
<ol dir="auto">
<li>Logically separated. And,</li>
<li>I can read the code <em>as if</em> each patch was individually applied in the series. So I start with the first patch, then the second, then the third. The series represents an <em>evolution of the code</em>, step by step.</li>
</ol>
<p dir="auto">The specifics here aren&#39;t too important. Sometimes, there will be no refactoring. Sometimes, it will be 100 lines. Sometimes, it will be 500 lines because it&#39;s a core API change and you have to break every call site and fix them. And so on and so forth.</p>
<p dir="auto">But even if this is the ideal series in a logical sense, it still needs to go through code review. Which brings us to...</p>

<p dir="auto">GitHub encourages you to do code review by <em>adding new commits on top of the original commits</em> to address reviews.</p>
<p dir="auto">GitHub encourages this both explicitly but also implicitly, for a few reasons and due to the way the UX is designed.</p>
<p dir="auto">Two of your coworkers, Alice and Bob, leave comments on the GitHub review. They tell you to make various fixes and adjustments, which you dutifully perform.</p>
<p dir="auto">Also, you didn&#39;t add tests to the new API yet; it worked before, but everyone wants tests of course. So you need to add those on top as well.</p>
<p dir="auto">Also, you made a small tweak after all that, a change to the implementation API, which is very small. Maybe you noticed a simple tweak in your fast, cutting edge data structure. Surely it can&#39;t a chain reaction that leads massive regression in production that will cause a pager to light up at 3am, right? It&#39;s only a <code>+/- 2 lines</code> delta! That&#39;s silly.</p>
<p dir="auto">This is now what your commit series has become, and this is what you will push to your branches on GitHub for review. The original 3 commits, then several &#34;address review&#34; commits (orange), and finally your regression (red).</p>
<a target="_blank" rel="noopener noreferrer" href="https://private-user-images.githubusercontent.com/3416/304287432-c4e37fa8-111e-4323-8834-e9b1973181eb.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjYwNDY1MzMsIm5iZiI6MTcyNjA0NjIzMywicGF0aCI6Ii8zNDE2LzMwNDI4NzQzMi1jNGUzN2ZhOC0xMTFlLTQzMjMtODgzNC1lOWIxOTczMTgxZWIucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI0MDkxMSUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDA5MTFUMDkxNzEzWiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9ODY2NWFjODQ0MjU4MzgzYWEyYTA3OWU2OTlkMzc2MzM4OGFhNzc3NmRhODNlNDQ4ZmI4OTJhZGFjNWI0MzlmZCZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QmYWN0b3JfaWQ9MCZrZXlfaWQ9MCZyZXBvX2lkPTAifQ.46i1qtqtTWqaaWBRh_kl3py1hnK7vSrDbC4KDVytVzg"><img width="1218" alt="image" src="https://private-user-images.githubusercontent.com/3416/304287432-c4e37fa8-111e-4323-8834-e9b1973181eb.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjYwNDY1MzMsIm5iZiI6MTcyNjA0NjIzMywicGF0aCI6Ii8zNDE2LzMwNDI4NzQzMi1jNGUzN2ZhOC0xMTFlLTQzMjMtODgzNC1lOWIxOTczMTgxZWIucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI0MDkxMSUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDA5MTFUMDkxNzEzWiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9ODY2NWFjODQ0MjU4MzgzYWEyYTA3OWU2OTlkMzc2MzM4OGFhNzc3NmRhODNlNDQ4ZmI4OTJhZGFjNWI0MzlmZCZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QmYWN0b3JfaWQ9MCZrZXlfaWQ9MCZyZXBvX2lkPTAifQ.46i1qtqtTWqaaWBRh_kl3py1hnK7vSrDbC4KDVytVzg"/></a>
<p dir="auto">The black lines represent edges in the commit graph, i.e. the things that show up in <code>git log</code>. While the dotted colored lines represent the &#34;implicit dependencies&#34; caused by review. Bob for example told you to change one extra call site in the third commit (blue dotted line) and one thing in the refactored code (purple dotted line). Alice however told you to fix something in the API you added, <em>and</em> fix something in the refactoring commit (purple and green dotted lines.) Your freshly written tests are really just related to your lack of tests in the new API (green dotted line.) Finally, the <code>&#34;minor&#34;</code> change is a tweak to the new API code (red dotted line).</p>
<p dir="auto">This is what your code has become, and this <em>sucks</em>. It sucks because:</p>
<ol dir="auto">
<li>The implicit relationship between the &#34;fix review&#34; commits and the original is not really visible. Only the actual parent/child relationship between Git commits remains, but that isn&#39;t the whole story, because now you don&#39;t know <em>why</em> these commits are related. (This is essentially a loss of &#34;provenance.&#34;)
<ul dir="auto">
<li>Notice how all the original commits were a single color, because they had one &#34;purpose.&#34; But the orange commits have <em>multiple</em> arrows, with different colors, establishing implicit relationships. The fact that a single orange commit touches multiple original commits means that the conceptual model is now more complex; some commits represent single changes, while others might address multiple changes at once.</li>
<li>You can fix this by having each Orange commit only address exactly one complaint-per-change, i.e. only one dotted line leaving it. However, now you have 6 fixup commits instead of 4.</li>
</ul>
</li>
<li><code>git blame</code> now sucks completely because changes overlap. <code>blame</code> works on the level of a line, so if <code>&#34;fix alice review&#34;</code> changes a single bit in a line that came from <code>&#34;minor refactoring&#34;</code>, that line is now misattributed. You have to go N commits deeper to find the real change.</li>
<li><code>git bisect</code> now also sucks. When you do bisection on these commits, the <code>&#34;minor&#34;</code> commit may not be the actual root cause commit; it may only be a <em>trigger</em> for a bug that existed from the moment the new API was added. It&#39;s unclear whether <code>&#34;minor&#34;</code> or <code>&#34;new API&#34;</code> are at fault, but realistically you probably have to just revert both after figuring it out because the word <code>&#34;minor&#34;</code> does not tell you anything about why the change was made.
<ul dir="auto">
<li>Backing out both changes may not always be desirable or even <em>possible</em> if, for example, the new API is a massive performance uplift and backing it out will cause cascading downstream effects.</li>
<li>And also this regression may only pop up weeks later.</li>
<li>If I am your coworker, and I do <code>git bisect</code> on a 3am production issue to find the root cause of a regression, and I land on a commit that says <code>&#34;minor&#34;</code> from the above PR that landed 3 weeks ago, and it has your name on it? You are going to get a phone call from me within seconds where I will give you a <a href="https://www.youtube.com/watch?v=jZOywn1qArI" rel="nofollow">monologue about how scary I can be</a>.</li>
<li>Even if the <code>&#34;minor&#34;</code> commit was never added, maybe the regression would still happen, and the above might all still be true, but at least you didn&#39;t have to spend an extra 15 minutes doing archaeology bullshit while you are in a P1 conference call with 5 other people.</li>
</ul>
</li>
</ol>
<p dir="auto">Just to be clear, this example is what it looks like <strong>when only two reviews take place</strong>. If your review is cycling 5 times, well, the above becomes far, far worse. And yes, in open source contexts, you will often go back and forth multiple times with someone, because they may not have context you do, and there may be no point in doing further review until other nits are addressed. Many projects like this go through multiple review cycles.</p>
<p dir="auto">Part of the problem, the reason why this happens, is due to some design and UX flaws:</p>
<ul dir="auto">
<li><strong>The new commits are the only way to do incremental reviews on GitHub</strong>. In the above model, if you don&#39;t want to review the 500 lines of code in the new API over and over again, the only way to do it is by adding new commits on top, and viewing those. It&#39;s much easier to read the <code>&#34;fix alice review&#34;</code> patch, which is <code>+/- 10 lines</code>, than it is to read the new API — which is 500 LOC.</li>
<li><strong>Github always shows you the whole diff by default</strong>: When you have a PR on GitHub and view the &#34;diff&#34; tab, it shows you <em>all</em> the commits crammed together as a single diff; it is the moral equivalent of running <code>git diff master..foo-branch</code> and looking at that. But that isn&#39;t how people write changes, and it isn&#39;t how people read them either. This behavior <em>further</em> encourages you to add new commits on top of old ones, and then the reviewers just read those commits individually because the alternative is to re-read things you already reviewed, constantly.</li>
<li><strong>It&#39;s difficult to view the differences between anything except branches</strong>. In general, all of GitHub&#39;s whole UX works on the named branch model — and to a large extent so does Git itself. Because of that, it&#39;s difficult to use workflows like <code>git rebase</code>, because force-pushing a branch removes the old branch entirely. And at that point, you can&#39;t do things like <code>git range-diff</code> between branches.
<ul dir="auto">
<li>Actually, this isn&#39;t fully true. If you force push on GitHub, you <em>can</em> see <em>a diff</em>, if you click on this weird little un-identifiable &#34;Compare&#34; button that pops up on the &#34;Force Push&#34; line that appears in a PR: <a target="_blank" rel="noopener noreferrer" href="https://private-user-images.githubusercontent.com/3416/305154958-1b81aeab-e1fc-4d03-8d42-c096fcb2c795.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjYwNDY1MzMsIm5iZiI6MTcyNjA0NjIzMywicGF0aCI6Ii8zNDE2LzMwNTE1NDk1OC0xYjgxYWVhYi1lMWZjLTRkMDMtOGQ0Mi1jMDk2ZmNiMmM3OTUucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI0MDkxMSUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDA5MTFUMDkxNzEzWiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9ZjFmOTRhNDk0Y2U4ZDlhMmJmYjYyOGIzMThhZTIwZGQ3OWUyMWU4MThiYTQ4OWUwMDE3OWZkNWJhYmI4NjVjZSZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QmYWN0b3JfaWQ9MCZrZXlfaWQ9MCZyZXBvX2lkPTAifQ.v_mD_9SoGGd04KVMlZD-wPNh1gikWq953-4YALbZdzs"><img width="553" alt="image" src="https://private-user-images.githubusercontent.com/3416/305154958-1b81aeab-e1fc-4d03-8d42-c096fcb2c795.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjYwNDY1MzMsIm5iZiI6MTcyNjA0NjIzMywicGF0aCI6Ii8zNDE2LzMwNTE1NDk1OC0xYjgxYWVhYi1lMWZjLTRkMDMtOGQ0Mi1jMDk2ZmNiMmM3OTUucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI0MDkxMSUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDA5MTFUMDkxNzEzWiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9ZjFmOTRhNDk0Y2U4ZDlhMmJmYjYyOGIzMThhZTIwZGQ3OWUyMWU4MThiYTQ4OWUwMDE3OWZkNWJhYmI4NjVjZSZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QmYWN0b3JfaWQ9MCZrZXlfaWQ9MCZyZXBvX2lkPTAifQ.v_mD_9SoGGd04KVMlZD-wPNh1gikWq953-4YALbZdzs"/></a></li>
<li>Except it this button only shows you <em>the whole diff</em> from the previous branch head to the current branch head. Again, this means you end up re-reading</li>
<li>You&#39;re on your own figuring out the Commit IDs and punching them into the URL bar if you want something more granular.</li>
<li>Why is this button so hard to see? Nobody knows.</li>
</ul>
</li>
</ul>
<p dir="auto">I call this review model &#34;diff soup&#34;, because that&#39;s what it is: GitHub just shows you a big bundle of changes mixed together in a big bowl of gruel, and then you are expected to live with it and shovel it down your throat. Beggars can&#39;t be choosers.</p>

<p dir="auto">The idea is actually simple: instead of publishing new commits on <em>top</em> of the three original commits, just publish a new <em>version</em> of the three commits, addressing the changes.</p>
<p dir="auto">So you start off with &#34;version 1&#34; or &#34;v1&#34; of your patch, like above.</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://private-user-images.githubusercontent.com/3416/304319502-ae00c29d-7157-4cdf-9f49-f5f4c557e41a.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjYwNDY1MzMsIm5iZiI6MTcyNjA0NjIzMywicGF0aCI6Ii8zNDE2LzMwNDMxOTUwMi1hZTAwYzI5ZC03MTU3LTRjZGYtOWY0OS1mNWY0YzU1N2U0MWEucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI0MDkxMSUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDA5MTFUMDkxNzEzWiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9ZmM1MWI1MmMxMDFjMDY5ODhiNTBiNGNlY2VhMDNlOWU4Njk4OWQ1MTIwNjhlNDJiZDgyZWMyNzQwNTc4NmY3OSZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QmYWN0b3JfaWQ9MCZrZXlfaWQ9MCZyZXBvX2lkPTAifQ.oOMLNzQdV4co9fzdY1ueMbg5JW_bprFrJdN1Z7a75QA"><img width="654" alt="image" src="https://private-user-images.githubusercontent.com/3416/304319502-ae00c29d-7157-4cdf-9f49-f5f4c557e41a.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjYwNDY1MzMsIm5iZiI6MTcyNjA0NjIzMywicGF0aCI6Ii8zNDE2LzMwNDMxOTUwMi1hZTAwYzI5ZC03MTU3LTRjZGYtOWY0OS1mNWY0YzU1N2U0MWEucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI0MDkxMSUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDA5MTFUMDkxNzEzWiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9ZmM1MWI1MmMxMDFjMDY5ODhiNTBiNGNlY2VhMDNlOWU4Njk4OWQ1MTIwNjhlNDJiZDgyZWMyNzQwNTc4NmY3OSZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QmYWN0b3JfaWQ9MCZrZXlfaWQ9MCZyZXBvX2lkPTAifQ.oOMLNzQdV4co9fzdY1ueMbg5JW_bprFrJdN1Z7a75QA"/></a>
</p>
<p dir="auto">In Git terminology, the orange <code>v1</code> on the side is, roughly speaking, the name of a branch, though normally it would be something like <code>aseipp/new-foobar-api</code> or something.</p>
<p dir="auto">Next, Bob leaves comments, asking you to fix the refactoring and update a new call site (before Alice is done.) So you address his review by updating the first commit and third commit. This creates a new series, which would be &#34;version 2&#34;, which we send out wholesale:</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://private-user-images.githubusercontent.com/3416/304319742-b7b4aef4-5bc0-4c12-aaaa-14e87b9fbe2e.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjYwNDY1MzMsIm5iZiI6MTcyNjA0NjIzMywicGF0aCI6Ii8zNDE2LzMwNDMxOTc0Mi1iN2I0YWVmNC01YmMwLTRjMTItYWFhYS0xNGU4N2I5ZmJlMmUucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI0MDkxMSUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDA5MTFUMDkxNzEzWiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9ODNiZDhjNmUyNzFlOWYzOTQ5NDRkYTEzNmI3ODU3YzE3ZTg5NjMwZTZjNWFmZDFlZWNiM2ZlZGEzYjA1ZjU0NCZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QmYWN0b3JfaWQ9MCZrZXlfaWQ9MCZyZXBvX2lkPTAifQ.guho5thq1z3znCmdoO4uTR7AeSynjNPY0e16Y8_Ux7s"><img width="711" alt="image" src="https://private-user-images.githubusercontent.com/3416/304319742-b7b4aef4-5bc0-4c12-aaaa-14e87b9fbe2e.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjYwNDY1MzMsIm5iZiI6MTcyNjA0NjIzMywicGF0aCI6Ii8zNDE2LzMwNDMxOTc0Mi1iN2I0YWVmNC01YmMwLTRjMTItYWFhYS0xNGU4N2I5ZmJlMmUucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI0MDkxMSUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDA5MTFUMDkxNzEzWiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9ODNiZDhjNmUyNzFlOWYzOTQ5NDRkYTEzNmI3ODU3YzE3ZTg5NjMwZTZjNWFmZDFlZWNiM2ZlZGEzYjA1ZjU0NCZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QmYWN0b3JfaWQ9MCZrZXlfaWQ9MCZyZXBvX2lkPTAifQ.guho5thq1z3znCmdoO4uTR7AeSynjNPY0e16Y8_Ux7s"/></a>
</p>
<p dir="auto">There is now a <code>v2</code> branch, containing 3 commits, and the patches are updated as Bob wanted them.</p>
<p dir="auto">The orange dotted arrows take place of the previous colored dotted arrows; they effectively represent the fact the given commit has &#34;evolved&#34; and changed. Note that there are only dotted orange lines, and no other colors; the &#34;implicit relationship&#34; established by the earlier graph is no longer a concern, because there aren&#39;t any extra commits. The relationship between <code>v1</code> and <code>v2</code> is obvious. Commit A version 1 becomes Commit A version 2, and so on and so forth. The entire issue somewhat vanishes.</p>
<p dir="auto">We repeat this process to address Alice&#39;s concerns, to add tests, and to introduce the <code>&#34;minor&#34;</code> regression. The result looks like this, where we end up with a final version of the three patches, version 5:</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://private-user-images.githubusercontent.com/3416/304320399-1c40e4c4-e7dd-443a-9078-501da9b0e612.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjYwNDY1MzMsIm5iZiI6MTcyNjA0NjIzMywicGF0aCI6Ii8zNDE2LzMwNDMyMDM5OS0xYzQwZTRjNC1lN2RkLTQ0M2EtOTA3OC01MDFkYTliMGU2MTIucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI0MDkxMSUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDA5MTFUMDkxNzEzWiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9NGVkNWE5ZTczMzBkYTFjZWU0ZTU1OTI0NDg4OTU0ZDlhOGFiYzZjMDVkZDVmODU0M2E2NGJiYzA2ZGRjNzIxZiZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QmYWN0b3JfaWQ9MCZrZXlfaWQ9MCZyZXBvX2lkPTAifQ.xUa0uJmabOmj2UDMLcuTEzxBpGvQzPLO1_0Uy9F9XbY"><img width="618" alt="image" src="https://private-user-images.githubusercontent.com/3416/304320399-1c40e4c4-e7dd-443a-9078-501da9b0e612.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjYwNDY1MzMsIm5iZiI6MTcyNjA0NjIzMywicGF0aCI6Ii8zNDE2LzMwNDMyMDM5OS0xYzQwZTRjNC1lN2RkLTQ0M2EtOTA3OC01MDFkYTliMGU2MTIucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI0MDkxMSUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNDA5MTFUMDkxNzEzWiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9NGVkNWE5ZTczMzBkYTFjZWU0ZTU1OTI0NDg4OTU0ZDlhOGFiYzZjMDVkZDVmODU0M2E2NGJiYzA2ZGRjNzIxZiZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QmYWN0b3JfaWQ9MCZrZXlfaWQ9MCZyZXBvX2lkPTAifQ.xUa0uJmabOmj2UDMLcuTEzxBpGvQzPLO1_0Uy9F9XbY"/></a>
</p>
<p dir="auto">The entire evolutionary process of the series has been inverted. At the end of this process, there are still only three commits, that address all review comments. Note that:</p>
<ul dir="auto">
<li><code>git blame</code> will now assign lines to changes <em>with less noise</em>. You no longer have to worry about running <code>git show abcdefg</code> on a blamed line and seeing it came from <code>&#34;fix alice review&#34;</code>, it will come from a change like the first commit, <code>&#34;refactor and deduplicate controller code&#34;</code> or whatnot.</li>
<li><code>git bisect</code> is now far more likely to tell you the new API code introduced this regression, without having to dig further.</li>
</ul>
<p dir="auto">Two of your best tools now work <em>much</em> more reliably because there is simply a better signal to noise ratio. But there&#39;s a very important and subtle difference that only the code <em>reviewer</em>, not <em>author</em>, can appreciate, which is...</p>
<p dir="auto"><strong>You now can review code incrementally, and not re-read the whole diff</strong></p>
<p dir="auto">When Alice leaves her review on v2, telling you to change the green commit with 500 lines of code, you will eventually respond by doing so. But for Alice, <strong>re-reading the 500 lines of code again in <code>v3</code> is a waste of time</strong>. She wants to see an <em>incremental diff</em> that can prove that you actually listened to her. This means she might only need to read a 50 line diff — a 10x difference in code.</p>
<p dir="auto">Alice can use a tool called <code>git range-diff</code> to do this, like so:</p>
<div dir="auto"><pre>git range-diff \
  main..v1 \
  main..v2</pre></div>
<p dir="auto">In English, this means &#34;Take the 3 commits from branch <code>v1</code>, and show the pairwise diff between the 3 commits from branch <code>v2</code>.&#34; So if <code>v1</code> has the following commit IDs:</p>
<pre><code>A -&gt; B -&gt; C
</code></pre>
<p dir="auto">And <code>v2</code> has the commit IDs:</p>
<pre><code>X -&gt; Y -&gt; Z
</code></pre>
<p dir="auto">You will see the changes between commit 1 <code>diff(A, X)</code>, followed by commit 2 <code>diff(B, Y)</code>, and commit 3 <code>diff(C, Z)</code>.</p>
<p dir="auto">In contrast, <strong>Github always shows you <code>diff(main, C)</code> or <code>diff(main, Z)</code></strong>, i.e. it shows you the entire branch as one diff, AKA diff soup.</p>
<p dir="auto">This is the essence of &#34;interdiff code review.&#34; You</p>
<ul dir="auto">
<li>Don&#39;t publish new changes on top, you publish <em>new versions</em></li>
<li>You don&#39;t diff between the base branch and the tip of the developer&#39;s branch, you diff between <em>versions of commits</em></li>
<li>Now, reviewers get an incremental review process, while authors don&#39;t have to clutter the history with 30 &#34;address review&#34; noise commits.</li>
<li>Your basic diagnostic tools work better, with a better signal-to-noise ratio.</li>
</ul>

<p dir="auto">TODO: Explain how the above is independent of your merge strategy (e.g. <code>git rebase</code> on tip versus multi-parent <code>git merge</code> commits).</p>

<p dir="auto">It&#39;s fine. Just don&#39;t use it on public branches that you expect others to base their own commits off of. It&#39;s that simple.</p>
<p dir="auto">Interdiff review systems typically encourage smaller, more &#34;juicy&#34; patches that land in the main branch more quickly than the alternative. You don&#39;t have to wait on all 5 commits to be ready to go; maybe the first 3 are OK, and the last 2 need more work. You merge 3 out of 5.</p>
<p dir="auto">The intent of the system is that others will just base their work off the main branch, mitigating the need to have cases where you merge a remote that merged 5 remotes that merged... and so on and so forth. So you don&#39;t have long lived patches, typically, and most users don&#39;t base branches off other branches.</p>
<div dir="auto"><p dir="auto"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p><p dir="auto">Some projects tend to explicitly publish branches off of other branches, or merge public branches across repos. The most famous example is the Linux kernel. Therefore, most Linux developers will use <code>git rebase</code> to <em>create</em> a patch series and refine it, but they won&#39;t force-push any public branches after they create them, because they might get merged into someone elses tree (without them knowing.) They will just create new branches with new commits.</p>
</div>


<p dir="auto">That&#39;s the sales pitch. I&#39;ll write more here later.</p>
</article>
  </div>

  </div>
</div></div>
  </body>
</html>
