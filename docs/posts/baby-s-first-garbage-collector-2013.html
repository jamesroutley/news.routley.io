<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://journal.stuffwithstuff.com/2013/12/08/babys-first-garbage-collector/">Original</a>
    <h1>Baby’s First Garbage Collector (2013)</h1>
    
    <div id="readability-page-1" class="page"><article>
<header>


  <a href="https://journal.stuffwithstuff.com/2013/08/26/what-is-open-recursion/" title="Older Post “What is “Open Recursion”?”">↩</a>


  <a href="https://journal.stuffwithstuff.com/2014/03/02/nostalgia-rathole/" title="Newer Post “Nostalgia Rathole”">↪</a>

</header>
<h4><a href="https://journal.stuffwithstuff.com/archive">December 08, 2013</a>
    <span><a href="https://journal.stuffwithstuff.com/category/c">c</a> <a href="https://journal.stuffwithstuff.com/category/code">code</a> <a href="https://journal.stuffwithstuff.com/category/language">language</a></span>
</h4>

<p>When I get stressed out and have too much to do, I have this paradoxical
reaction where I escape from that by coming up with <em>another</em> thing to do.
Usually it’s a tiny self-contained program that I can write and finish.</p>

<p>The other morning, I was freaking myself out about <a href="http://gameprogrammingpatterns.com">the book I’m working
on</a> and the <a href="http://dart.dev">stuff I have to do at work</a> and <a href="https://www.infoq.com/presentations/dart-introduction/">a talk I’m preparing
for Strange Loop</a>, and all of the sudden, I thought, “I should write a
garbage collector.”</p>

<p>Yes, I realize how crazy that paragraph makes me seem. But my faulty wiring is
your free tutorial on a fundamental piece of programming language
implementation! In about a hundred lines of vanilla C, I managed to whip up a
basic <a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Na%C3%AFve_mark-and-sweep">mark-and-sweep</a> collector that actually, you know, collects.</p>

<p>Garbage collection is considered one of the more shark-infested waters of
programming, but in this post, I’ll give you a nice kiddie pool to paddle around
in. (There may still be sharks in it, but at least it will be shallower.)</p>

<h2>Reduce, reuse, recycle</h2>

<p>The basic idea behind garbage collection is that the language (for the most
part) appears to have access to infinite memory. The developer can just keep
allocating and allocating and allocating and, as if by magic, never run out.</p>

<p>Of course, machines don’t have infinite memory. So the way the implementation
does this is that when it needs to allocate a bit of memory and it realizes it’s
running low, it <em>collects garbage</em>.</p>

<p>“Garbage” in this context means memory it previously allocated that is no longer
being used. For the illusion of infinite memory to work, the language needs to
be very safe about “no longer being used”. It would be no fun if random objects
just started getting reclaimed while your program was trying to access them.</p>

<p>In order to be collectible, the language has to ensure there’s no way for the
program to use that object again. If the program can’t get a reference to the
object, then it obviously can’t use it again. So the definition of “in use” is
actually pretty simple:</p>

<ol>
<li><p>Any object being referenced by a variable still in scope is in use.</p></li>
<li><p>Any object referenced by another in-use object is in use.</p></li>
</ol>

<p>The second rule is the recursive one. If object A is referenced by a variable,
and it has some field that references object B, then B is in use since you can
get to it through A.</p>

<p>The end result is a graph of <em>reachable</em> objects—all of the objects in the
world that you can get to by starting at a variable and traversing through
objects. Any object <em>not</em> in that graph of reachable objects is dead to the
program and its memory is ripe for a reaping.</p>

<h2>Marking and sweeping</h2>

<p>There are a <a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection">bunch of different ways</a> you can implement the process of
finding and reclaiming all of the unused objects, but the simplest and first
algorithm ever invented for it is called “mark-sweep”. It was invented by John
McCarthy, the man who invented Lisp and beards, so implementing today is like
communing with one of the Elder Gods, but hopefully not in some Lovecraftian way
that ends with you having your mind and retinas blasted clean.</p>

<p>The algorithm works almost exactly like our definition of reachability:</p>

<ol>
<li><p>Starting at the roots, traverse the entire object graph. Every time you
reach an object, set a “mark” bit on it to true.</p></li>
<li><p>Once that’s done, find all of the objects whose mark bits are <em>not</em> set and
delete them.</p></li>
</ol>

<p>That’s it. I know, you could have come up with that, right? If you had, <em>you’d</em>
be the author of a paper cited hundreds of times. The lesson here is that to be
famous in CS, you don’t have to come up with really obscure stuff, you just have
to come up with obvious stuff <em>first</em>.</p>

<h2>A pair of objects</h2>

<p>Before we can get to implementing those two steps, let’s get a couple of
preliminaries out of the way. We won’t be actually implementing an interpreter
for a language—no parser, bytecode, or any of that foolishness—but we do
need some minimal amount of code to create some garbage to collect.</p>

<p>Let’s play pretend that we’re writing an interpreter for a little language. It’s
dynamically typed, and has two types of objects: ints and pairs. Here’s an enum
to identify an object’s type:</p>
<div><pre><code data-lang="c"><span></span><span>typedef</span> <span>enum</span> <span>{</span>
  <span>OBJ_INT</span><span>,</span>
  <span>OBJ_PAIR</span>
<span>}</span> <span>ObjectType</span><span>;</span>
</code></pre></div>
<p>A pair can be a pair of anything, two ints, an int and another pair, whatever.
You can go <a href="http://www.flickr.com/photos/raganwald/212588975/">surprisingly far</a> with just that. Since an object in the VM can
be either of these, the typical way in C to implement it is with a <a href="http://en.wikipedia.org/wiki/Tagged_union">tagged
union</a>. We define it thusly:</p>
<div><pre><code data-lang="c"><span></span><span>typedef</span> <span>struct</span> <span>sObject</span> <span>{</span>
  <span>ObjectType</span> <span>type</span><span>;</span>

  <span>union</span> <span>{</span>
    <span>/* OBJ_INT */</span>
    <span>int</span> <span>value</span><span>;</span>

    <span>/* OBJ_PAIR */</span>
    <span>struct</span> <span>{</span>
      <span>struct</span> <span>sObject</span><span>*</span> <span>head</span><span>;</span>
      <span>struct</span> <span>sObject</span><span>*</span> <span>tail</span><span>;</span>
    <span>};</span>
  <span>};</span>
<span>}</span> <span>Object</span><span>;</span>
</code></pre></div>
<p>The main Object struct has a <code>type</code> field that identifies what kind of value it
is—either an int or a pair. Then it has a union to hold the data for the int
or pair. If your C is rusty, a union is a struct where the fields overlap in
memory. Since a given object can only be an int <em>or</em> a pair, there’s no reason
to have memory in a single object for all three fields at the same time. A union
does that. Groovy.</p>

<h2>A minimal virtual machine</h2>

<p>Now we can use that datatype in a little virtual machine. The VM’s role in this
story is to have a stack that stores the variables that are currently in scope.
Most language VMs are either stack-based (like the JVM and CLR) or
register-based (like Lua). In both cases, there is actually still a stack. It’s
used to store local variables and temporary variables needed in the middle of an
expression. We model that explicitly and simply like so:</p>
<div><pre><code data-lang="c"><span></span><span>#define STACK_MAX 256</span>

<span>typedef</span> <span>struct</span> <span>{</span>
  <span>Object</span><span>*</span> <span>stack</span><span>[</span><span>STACK_MAX</span><span>];</span>
  <span>int</span> <span>stackSize</span><span>;</span>
<span>}</span> <span>VM</span><span>;</span>
</code></pre></div>
<p>Now that we’ve got our basic data structures in place, let’s slap together a bit
of code to create some stuff. First, let’s write a function that creates and
initializes a VM:</p>
<div><pre><code data-lang="c"><span></span><span>VM</span><span>*</span> <span>newVM</span><span>()</span> <span>{</span>
  <span>VM</span><span>*</span> <span>vm</span> <span>=</span> <span>malloc</span><span>(</span><span>sizeof</span><span>(</span><span>VM</span><span>));</span>
  <span>vm</span><span>-&gt;</span><span>stackSize</span> <span>=</span> <span>0</span><span>;</span>
  <span>return</span> <span>vm</span><span>;</span>
<span>}</span>
</code></pre></div>
<p>Once we have a VM, we need to be able to manipulate its stack:</p>
<div><pre><code data-lang="c"><span></span><span>void</span> <span>push</span><span>(</span><span>VM</span><span>*</span> <span>vm</span><span>,</span> <span>Object</span><span>*</span> <span>value</span><span>)</span> <span>{</span>
  <span>assert</span><span>(</span><span>vm</span><span>-&gt;</span><span>stackSize</span> <span>&lt;</span> <span>STACK_MAX</span><span>,</span> <span>&#34;Stack overflow!&#34;</span><span>);</span>
  <span>vm</span><span>-&gt;</span><span>stack</span><span>[</span><span>vm</span><span>-&gt;</span><span>stackSize</span><span>++</span><span>]</span> <span>=</span> <span>value</span><span>;</span>
<span>}</span>

<span>Object</span><span>*</span> <span>pop</span><span>(</span><span>VM</span><span>*</span> <span>vm</span><span>)</span> <span>{</span>
  <span>assert</span><span>(</span><span>vm</span><span>-&gt;</span><span>stackSize</span> <span>&gt;</span> <span>0</span><span>,</span> <span>&#34;Stack underflow!&#34;</span><span>);</span>
  <span>return</span> <span>vm</span><span>-&gt;</span><span>stack</span><span>[</span><span>--</span><span>vm</span><span>-&gt;</span><span>stackSize</span><span>];</span>
<span>}</span>
</code></pre></div>
<p>Now that we can stick stuff in “variables”, we need to be able to actually
create objects. First, a little helper function:</p>
<div><pre><code data-lang="c"><span></span><span>Object</span><span>*</span> <span>newObject</span><span>(</span><span>VM</span><span>*</span> <span>vm</span><span>,</span> <span>ObjectType</span> <span>type</span><span>)</span> <span>{</span>
  <span>Object</span><span>*</span> <span>object</span> <span>=</span> <span>malloc</span><span>(</span><span>sizeof</span><span>(</span><span>Object</span><span>));</span>
  <span>object</span><span>-&gt;</span><span>type</span> <span>=</span> <span>type</span><span>;</span>
  <span>return</span> <span>object</span><span>;</span>
<span>}</span>
</code></pre></div>
<p>That does the actual memory allocation and sets the type tag. We’ll be revisiting this in a bit. Using that, we can write functions to push each kind of object onto the VM’s stack:</p>
<div><pre><code data-lang="c"><span></span><span>void</span> <span>pushInt</span><span>(</span><span>VM</span><span>*</span> <span>vm</span><span>,</span> <span>int</span> <span>intValue</span><span>)</span> <span>{</span>
  <span>Object</span><span>*</span> <span>object</span> <span>=</span> <span>newObject</span><span>(</span><span>vm</span><span>,</span> <span>OBJ_INT</span><span>);</span>
  <span>object</span><span>-&gt;</span><span>value</span> <span>=</span> <span>intValue</span><span>;</span>
  <span>push</span><span>(</span><span>vm</span><span>,</span> <span>object</span><span>);</span>
<span>}</span>

<span>Object</span><span>*</span> <span>pushPair</span><span>(</span><span>VM</span><span>*</span> <span>vm</span><span>)</span> <span>{</span>
  <span>Object</span><span>*</span> <span>object</span> <span>=</span> <span>newObject</span><span>(</span><span>vm</span><span>,</span> <span>OBJ_PAIR</span><span>);</span>
  <span>object</span><span>-&gt;</span><span>tail</span> <span>=</span> <span>pop</span><span>(</span><span>vm</span><span>);</span>
  <span>object</span><span>-&gt;</span><span>head</span> <span>=</span> <span>pop</span><span>(</span><span>vm</span><span>);</span>

  <span>push</span><span>(</span><span>vm</span><span>,</span> <span>object</span><span>);</span>
  <span>return</span> <span>object</span><span>;</span>
<span>}</span>
</code></pre></div>
<p>And that’s it for our little VM. If we had a parser and an interpreter that
called those functions, we’d have an honest to God language on our hands. And,
if we had infinite memory, it would even be able to run real programs. Since we
don’t, let’s start collecting some garbage.</p>

<h2>Marky mark</h2>

<p>The first phase is <em>marking</em>. We need to walk all of the reachable objects and
set their mark bit. The first thing we need then is to add a mark bit to
<code>Object</code>:</p>
<div><pre><code data-lang="c"><span></span><span>typedef</span> <span>struct</span> <span>sObject</span> <span>{</span>
  <span>unsigned</span> <span>char</span> <span>marked</span><span>;</span>
  <span>/* Previous stuff... */</span>
<span>}</span> <span>Object</span><span>;</span>
</code></pre></div>
<p>When we create a new object, we modify <code>newObject()</code> to initialize <code>marked</code> to
zero.</p>

<p>To mark all of the reachable objects, we start with the variables that are in
memory, so that means walking the stack. That looks like this:</p>
<div><pre><code data-lang="c"><span></span><span>void</span> <span>markAll</span><span>(</span><span>VM</span><span>*</span> <span>vm</span><span>)</span>
<span>{</span>
  <span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>vm</span><span>-&gt;</span><span>stackSize</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
    <span>mark</span><span>(</span><span>vm</span><span>-&gt;</span><span>stack</span><span>[</span><span>i</span><span>]);</span>
  <span>}</span>
<span>}</span>
</code></pre></div>
<p>That in turn calls <code>mark</code>. We’ll build that in phases. First:</p>
<div><pre><code data-lang="c"><span></span><span>void</span> <span>mark</span><span>(</span><span>Object</span><span>*</span> <span>object</span><span>)</span> <span>{</span>
  <span>object</span><span>-&gt;</span><span>marked</span> <span>=</span> <span>1</span><span>;</span>
<span>}</span>
</code></pre></div>
<p>This is the most important bit, literally. We’ve marked the object itself as
reachable. But remember we also need to handle references in objects—reachability is <em>recursive</em>. If the object is a pair, its two fields are
reachable too. Handling that is simple:</p>
<div><pre><code data-lang="c"><span></span><span>void</span> <span>mark</span><span>(</span><span>Object</span><span>*</span> <span>object</span><span>)</span> <span>{</span>
  <span>object</span><span>-&gt;</span><span>marked</span> <span>=</span> <span>1</span><span>;</span>

  <span>if</span> <span>(</span><span>object</span><span>-&gt;</span><span>type</span> <span>==</span> <span>OBJ_PAIR</span><span>)</span> <span>{</span>
    <span>mark</span><span>(</span><span>object</span><span>-&gt;</span><span>head</span><span>);</span>
    <span>mark</span><span>(</span><span>object</span><span>-&gt;</span><span>tail</span><span>);</span>
  <span>}</span>
<span>}</span>
</code></pre></div>
<p>There’s a bug here. Do you see it? We’re recursing now, but we aren’t checking
for <em>cycles</em>. If you have a bunch of pairs that point to each other in a loop,
this will overflow the C callstack and crash.</p>

<p>To handle that, we simply need to bail out if we get to an object that we’ve
already processed. So the complete <code>mark()</code> function is:</p>
<div><pre><code data-lang="c"><span></span><span>void</span> <span>mark</span><span>(</span><span>Object</span><span>*</span> <span>object</span><span>)</span> <span>{</span>
  <span>/* If already marked, we&#39;re done. Check this first
     to avoid recursing on cycles in the object graph. */</span>
  <span>if</span> <span>(</span><span>object</span><span>-&gt;</span><span>marked</span><span>)</span> <span>return</span><span>;</span>

  <span>object</span><span>-&gt;</span><span>marked</span> <span>=</span> <span>1</span><span>;</span>

  <span>if</span> <span>(</span><span>object</span><span>-&gt;</span><span>type</span> <span>==</span> <span>OBJ_PAIR</span><span>)</span> <span>{</span>
    <span>mark</span><span>(</span><span>object</span><span>-&gt;</span><span>head</span><span>);</span>
    <span>mark</span><span>(</span><span>object</span><span>-&gt;</span><span>tail</span><span>);</span>
  <span>}</span>
<span>}</span>
</code></pre></div>
<p>Now we can call <code>markAll()</code> and it will correctly mark every reachable object in
memory. We’re halfway done!</p>

<h2>Sweepy sweep</h2>

<p>The next phase is to sweep through all of the objects we’ve allocated and free
any of them that aren’t marked. But there’s a problem here: all of the unmarked
objects are, by definition, unreachable! <em>We</em> can’t get to them!</p>

<p>The VM has implemented the <em>language’s</em> semantics for object references, so
we’re only storing pointers to objects in variables and the pair fields. As soon
as an object is no longer pointed to by one of those, the VM has lost it
entirely and actually leaked memory.</p>

<p>The trick to solve this is that the VM can have its <em>own</em> references to objects
that are distinct from the semantics that are visible to the language <em>user</em>. In
other words, we can keep track of them ourselves.</p>

<p>The simplest way to do this is to just maintain a linked list of every object
we’ve ever allocated. We extend <code>Object</code> itself to be a node in that list:</p>
<div><pre><code data-lang="c"><span></span><span>typedef</span> <span>struct</span> <span>sObject</span> <span>{</span>
  <span>/* The next object in the list of all objects. */</span>
  <span>struct</span> <span>sObject</span><span>*</span> <span>next</span><span>;</span>

  <span>/* Previous stuff... */</span>
<span>}</span> <span>Object</span><span>;</span>
</code></pre></div>
<p>The VM keeps track of the head of that list:</p>
<div><pre><code data-lang="c"><span></span><span>typedef</span> <span>struct</span> <span>{</span>
  <span>/* The first object in the list of all objects. */</span>
  <span>Object</span><span>*</span> <span>firstObject</span><span>;</span>

  <span>/* Previous stuff... */</span>
<span>}</span> <span>VM</span><span>;</span>
</code></pre></div>
<p>In <code>newVM()</code> we make sure to initialize <code>firstObject</code> to <code>NULL</code>. Whenever we
create an object, we add it to the list:</p>
<div><pre><code data-lang="c"><span></span><span>Object</span><span>*</span> <span>newObject</span><span>(</span><span>VM</span><span>*</span> <span>vm</span><span>,</span> <span>ObjectType</span> <span>type</span><span>)</span> <span>{</span>
  <span>Object</span><span>*</span> <span>object</span> <span>=</span> <span>malloc</span><span>(</span><span>sizeof</span><span>(</span><span>Object</span><span>));</span>
  <span>object</span><span>-&gt;</span><span>type</span> <span>=</span> <span>type</span><span>;</span>
  <span>object</span><span>-&gt;</span><span>marked</span> <span>=</span> <span>0</span><span>;</span>

  <span>/* Insert it into the list of allocated objects. */</span>
  <span>object</span><span>-&gt;</span><span>next</span> <span>=</span> <span>vm</span><span>-&gt;</span><span>firstObject</span><span>;</span>
  <span>vm</span><span>-&gt;</span><span>firstObject</span> <span>=</span> <span>object</span><span>;</span>

  <span>return</span> <span>object</span><span>;</span>
<span>}</span>
</code></pre></div>
<p>This way, even if the <em>language</em> can’t find an object, the language
<em>implementation</em> still can. To sweep through and delete the unmarked objects, we
traverse the list:</p>
<div><pre><code data-lang="c"><span></span><span>void</span> <span>sweep</span><span>(</span><span>VM</span><span>*</span> <span>vm</span><span>)</span>
<span>{</span>
  <span>Object</span><span>**</span> <span>object</span> <span>=</span> <span>&amp;</span><span>vm</span><span>-&gt;</span><span>firstObject</span><span>;</span>
  <span>while</span> <span>(</span><span>*</span><span>object</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span><span>(</span><span>*</span><span>object</span><span>)</span><span>-&gt;</span><span>marked</span><span>)</span> <span>{</span>
      <span>/* This object wasn&#39;t reached, so remove it from the list
         and free it. */</span>
      <span>Object</span><span>*</span> <span>unreached</span> <span>=</span> <span>*</span><span>object</span><span>;</span>

      <span>*</span><span>object</span> <span>=</span> <span>unreached</span><span>-&gt;</span><span>next</span><span>;</span>
      <span>free</span><span>(</span><span>unreached</span><span>);</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>/* This object was reached, so unmark it (for the next GC)
         and move on to the next. */</span>
      <span>(</span><span>*</span><span>object</span><span>)</span><span>-&gt;</span><span>marked</span> <span>=</span> <span>0</span><span>;</span>
      <span>object</span> <span>=</span> <span>&amp;</span><span>(</span><span>*</span><span>object</span><span>)</span><span>-&gt;</span><span>next</span><span>;</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre></div>
<p>That code is a bit tricky to read because of that pointer to a pointer, but if
you work through it, you can see it’s pretty straightforward. It just walks the
entire linked list. Whenever it hits an object that isn’t marked, it frees its
memory and removes it from the list. When this is done, we will have deleted
every unreachable object.</p>

<p>Congratulations! We have a garbage collector! There’s just one missing piece:
actually calling it. First let’s wrap the two phases together:</p>
<div><pre><code data-lang="c"><span></span><span>void</span> <span>gc</span><span>(</span><span>VM</span><span>*</span> <span>vm</span><span>)</span> <span>{</span>
  <span>markAll</span><span>(</span><span>vm</span><span>);</span>
  <span>sweep</span><span>(</span><span>vm</span><span>);</span>
<span>}</span>
</code></pre></div>
<p>You couldn’t ask for a more obvious mark-sweep implementation. The trickiest
part is figuring out when to actually call this. What does “low on memory” even
mean, especially on modern computers with near-infinite virtual memory?</p>

<p>It turns out there’s no precise right or wrong answer here. It really depends on
what you’re using your VM for and what kind of hardware it runs on. To keep this
example simple, we’ll just collect after a certain number of allocations. That’s
actually how some language implementations work, and it’s easy to implement.</p>

<p>We extend <code>VM</code> to track how many we’ve created:</p>
<div><pre><code data-lang="c"><span></span><span>typedef</span> <span>struct</span> <span>{</span>
  <span>/* The total number of currently allocated objects. */</span>
  <span>int</span> <span>numObjects</span><span>;</span>

  <span>/* The number of objects required to trigger a GC. */</span>
  <span>int</span> <span>maxObjects</span><span>;</span>

  <span>/* Previous stuff... */</span>
<span>}</span> <span>VM</span><span>;</span>
</code></pre></div>
<p>And then initialize them:</p>
<div><pre><code data-lang="c"><span></span><span>VM</span><span>*</span> <span>newVM</span><span>()</span> <span>{</span>
  <span>/* Previous stuff... */</span>

  <span>vm</span><span>-&gt;</span><span>numObjects</span> <span>=</span> <span>0</span><span>;</span>
  <span>vm</span><span>-&gt;</span><span>maxObjects</span> <span>=</span> <span>INITIAL_GC_THRESHOLD</span><span>;</span>
  <span>return</span> <span>vm</span><span>;</span>
<span>}</span>
</code></pre></div>
<p>The <code>INITIAL_GC_THRESHOLD</code> will be the number of objects at which we kick off
the <em>first</em> GC. A smaller number is more conservative with memory, a larger
number spends less time on garbage collection. Adjust to taste.</p>

<p>Whenever we create an object, we increment <code>numObjects</code> and run a collection if
it reaches the max:</p>
<div><pre><code data-lang="c"><span></span><span>Object</span><span>*</span> <span>newObject</span><span>(</span><span>VM</span><span>*</span> <span>vm</span><span>,</span> <span>ObjectType</span> <span>type</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>vm</span><span>-&gt;</span><span>numObjects</span> <span>==</span> <span>vm</span><span>-&gt;</span><span>maxObjects</span><span>)</span> <span>gc</span><span>(</span><span>vm</span><span>);</span>

  <span>/* Create object... */</span>

  <span>vm</span><span>-&gt;</span><span>numObjects</span><span>++</span><span>;</span>
  <span>return</span> <span>object</span><span>;</span>
<span>}</span>
</code></pre></div>
<p>I won’t bother showing it, but we’ll also tweak <code>sweep()</code> to <em>decrement</em>
<code>numObjects</code> every time it frees one. Finally, we modify <code>gc()</code> to update the
max:</p>
<div><pre><code data-lang="c"><span></span><span>void</span> <span>gc</span><span>(</span><span>VM</span><span>*</span> <span>vm</span><span>)</span> <span>{</span>
  <span>int</span> <span>numObjects</span> <span>=</span> <span>vm</span><span>-&gt;</span><span>numObjects</span><span>;</span>

  <span>markAll</span><span>(</span><span>vm</span><span>);</span>
  <span>sweep</span><span>(</span><span>vm</span><span>);</span>

  <span>vm</span><span>-&gt;</span><span>maxObjects</span> <span>=</span> <span>vm</span><span>-&gt;</span><span>numObjects</span> <span>*</span> <span>2</span><span>;</span>
<span>}</span>
</code></pre></div>
<p>After every collection, we update <code>maxObjects</code> based on the number of <em>live</em>
objects left after the collection. The multiplier there lets our heap grow as
the number of living objects increases. Likewise, it will shrink automatically
if a bunch of objects end up being freed.</p>

<h2>Simple</h2>

<p>You made it! If you followed all of this, you’ve now got a handle on a simple
garbage collection algorithm. If you want to see it all together, <a href="https://github.com/munificent/mark-sweep">here’s the
full code</a>. Let me stress here that while this collector is <em>simple</em>, it
isn’t a <em>toy</em>.</p>

<p>There are a ton of optimizations you can build on top of this—in GCs and
programming languages, optimization is 90% of the effort—but the core code
here is a legitimate <em>real</em> GC. It’s very similar to the collectors that were in
Ruby and Lua until recently. You can ship production code that uses something
exactly like this. Now go build something awesome!</p>

  

  
  
  
</article></div>
  </body>
</html>
