<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.koehntopp.info/2023/03/14/tracing-python.html">Original</a>
    <h1>Tracing Python</h1>
    
    <div id="readability-page-1" class="page"><div>
			
			<div>
				<p>Based on a discussion on IRC and Mastodon: “How can I get access to the return values of my (Python-) programs functions?”
And more generally, how can I trace function execution in Python, showing function parameters and return values?</p>

<p>Of course, you can always simply turn on this in the PyCharm debugger:</p>
<p>
  <img src="https://blog.koehntopp.info/uploads/2023/03/python-tracing-01.png" alt=""/>
</p>


<p><em>PyCharm, Debug Window, Gear Icon, “Show Return Values”</em></p>

<p>You can also implement such a thing from first principles, in Python:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>import</span> <span>functools</span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>args_to_str</span><span>(</span><span>*</span><span>args</span><span>):</span>
</span></span><span><span>    <span>return</span> <span>&#34;, &#34;</span><span>.</span><span>join</span><span>(</span><span>map</span><span>(</span><span>str</span><span>,</span> <span>args</span><span>))</span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>kwargs_to_str</span><span>(</span><span>**</span><span>kwargs</span><span>):</span>
</span></span><span><span>    <span>ret</span> <span>=</span> <span>&#34;&#34;</span>
</span></span><span><span>    <span>for</span> <span>k</span><span>,</span> <span>v</span> <span>in</span> <span>kwargs</span><span>.</span><span>items</span><span>():</span>
</span></span><span><span>        <span>ret</span> <span>+=</span> <span>f</span><span>&#34;</span><span>{</span><span>k</span><span>}</span><span>=</span><span>{</span><span>v</span><span>}</span><span>,&#34;</span>
</span></span><span><span>
</span></span><span><span>    <span>return</span> <span>ret</span><span>[:</span><span>-</span><span>1</span><span>]</span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>logging</span><span>(</span><span>func</span><span>):</span>
</span></span><span><span>    <span>func</span><span>.</span><span>__indent__</span> <span>=</span> <span>0</span>
</span></span><span><span>
</span></span><span><span>    <span>@functools.wraps</span><span>(</span><span>func</span><span>)</span>
</span></span><span><span>    <span>def</span> <span>wrapper_logging</span><span>(</span><span>*</span><span>args</span><span>,</span> <span>**</span><span>kwargs</span><span>):</span>
</span></span><span><span>        <span>func_indent</span> <span>=</span> <span>&#34; &#34;</span> <span>*</span> <span>func</span><span>.</span><span>__indent__</span>
</span></span><span><span>        <span>func</span><span>.</span><span>__indent__</span> <span>+=</span> <span>2</span>
</span></span><span><span>
</span></span><span><span>        <span>func_name</span> <span>=</span> <span>func</span><span>.</span><span>__qualname__</span>
</span></span><span><span>        <span>func_args</span> <span>=</span> <span>args_to_str</span><span>(</span><span>*</span><span>args</span><span>)</span>
</span></span><span><span>        <span>func_kwargs</span> <span>=</span> <span>kwargs_to_str</span><span>(</span><span>**</span><span>kwargs</span><span>)</span>
</span></span><span><span>
</span></span><span><span>        <span>print</span><span>(</span><span>f</span><span>&#34;</span><span>{</span><span>func_indent</span><span>}</span><span> -&gt; Enter: </span><span>{</span><span>func_name</span><span>}</span><span>(</span><span>{</span><span>func_args</span><span>}</span><span>&#34;</span><span>,</span> <span>end</span><span>=</span><span>&#34;&#34;</span><span>)</span>
</span></span><span><span>        <span>if</span> <span>func_kwargs</span> <span>!=</span> <span>&#34;&#34;</span><span>:</span>
</span></span><span><span>            <span>print</span><span>(</span><span>f</span><span>&#34;, </span><span>{</span><span>func_kwargs</span><span>}</span><span>&#34;</span><span>,</span> <span>end</span><span>=</span><span>&#34;&#34;</span><span>)</span>
</span></span><span><span>        <span>print</span><span>(</span><span>&#34;)&#34;</span><span>)</span>
</span></span><span><span>
</span></span><span><span>        <span>result</span> <span>=</span> <span>func</span><span>(</span><span>*</span><span>args</span><span>,</span> <span>**</span><span>kwargs</span><span>)</span>
</span></span><span><span>
</span></span><span><span>        <span>print</span><span>(</span><span>f</span><span>&#34;</span><span>{</span><span>func_indent</span><span>}</span><span> &lt;- Leave: </span><span>{</span><span>func_name</span><span>}</span><span>(</span><span>{</span><span>result</span><span>}</span><span>)&#34;</span><span>)</span>
</span></span><span><span>        <span>return</span> <span>result</span>
</span></span><span><span>
</span></span><span><span>    <span>return</span> <span>wrapper_logging</span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>@logging</span>
</span></span><span><span><span>def</span> <span>fac</span><span>(</span><span>n</span><span>:</span> <span>int</span><span>)</span> <span>-&gt;</span> <span>int</span><span>:</span>
</span></span><span><span>    <span>if</span> <span>n</span> <span>==</span> <span>1</span><span>:</span>
</span></span><span><span>        <span>return</span> <span>1</span>
</span></span><span><span>    <span>else</span><span>:</span>
</span></span><span><span>        <span>return</span> <span>n</span> <span>*</span> <span>fac</span><span>(</span><span>n</span> <span>-</span> <span>1</span><span>)</span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>if</span> <span>__name__</span> <span>==</span> <span>&#39;__main__&#39;</span><span>:</span>
</span></span><span><span>    <span>result</span> <span>=</span> <span>fac</span><span>(</span><span>3</span><span>)</span>
</span></span><span><span>    <span>print</span><span>(</span><span>f</span><span>&#34;</span><span>{</span><span>result</span><span>=}</span><span>&#34;</span><span>)</span>
</span></span></code></pre></div><p>This makes use of <code>@functools.wraps()</code> to define a <a href="https://python101.pythonlibrary.org/chapter25_decorators.html" target="_blank" rel="noopener">decorator</a>

, <code>@logging</code>.
It also leverages the fact, that anything, including a callable, can have properties, which we are using to maintain an indent count in <code>func.__indent__</code>.
This is initialized to 0, and then incremented by 2 for each call in the call stack. Unwinding the call stack resets the counter, so we don’t have to do that manually.</p>
<p>We have two helper functions to turn the functions <code>*args</code> and <code>**kwargs</code> into proper strings, and we access <code>func.__qualname__</code> to get the functions <a href="https://docs.python.org/3/glossary.html#term-qualified-name" target="_blank" rel="noopener">name</a>

.
We are using <code>__qualname__</code> to handle inner functions properly here, even if that is sometimes creating less readable output.</p>
<p>Running the code results in</p>
<p>
  <img src="https://blog.koehntopp.info/uploads/2023/03/python-tracing-02.png" alt=""/>
</p>


<p><em>Output from the Python program above shows function calls and results.</em></p>

<p>The <a href="https://github.com/mzipay/Autologging" target="_blank" rel="noopener">autologging</a>

 package makes this simpler, even if it lacks the nice indentation.</p>
<p>Our code becomes much shorter:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>import</span> <span>logging</span>
</span></span><span><span><span>import</span> <span>sys</span>
</span></span><span><span><span>from</span> <span>autologging</span> <span>import</span> <span>logged</span><span>,</span> <span>traced</span><span>,</span> <span>TRACE</span>
</span></span><span><span>
</span></span><span><span><span>logging</span><span>.</span><span>basicConfig</span><span>(</span>
</span></span><span><span>    <span>level</span><span>=</span><span>TRACE</span><span>,</span>
</span></span><span><span>    <span>stream</span><span>=</span><span>sys</span><span>.</span><span>stdout</span><span>,</span>
</span></span><span><span>    <span>format</span><span>=</span><span>&#34;</span><span>%(levelname)s</span><span>:</span><span>%(name)s</span><span>:</span><span>%(funcName)s</span><span>:</span><span>%(message)s</span><span>&#34;</span>
</span></span><span><span><span>)</span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>@logged</span>
</span></span><span><span><span>@traced</span>
</span></span><span><span><span>class</span> <span>Fac</span><span>:</span>
</span></span><span><span>    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>):</span>
</span></span><span><span>        <span>pass</span>
</span></span><span><span>
</span></span><span><span>    <span>def</span> <span>fac</span><span>(</span><span>self</span><span>,</span> <span>n</span><span>:</span> <span>int</span><span>)</span> <span>-&gt;</span> <span>int</span><span>:</span>
</span></span><span><span>        <span>self</span><span>.</span><span>__log</span><span>.</span><span>debug</span><span>(</span><span>&#34;OHAI&#34;</span><span>)</span>
</span></span><span><span>
</span></span><span><span>        <span>if</span> <span>n</span> <span>==</span> <span>1</span><span>:</span>
</span></span><span><span>            <span>return</span> <span>1</span>
</span></span><span><span>        <span>else</span><span>:</span>
</span></span><span><span>            <span>return</span> <span>n</span> <span>*</span> <span>self</span><span>.</span><span>fac</span><span>(</span><span>n</span> <span>-</span> <span>1</span><span>)</span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>if</span> <span>__name__</span> <span>==</span> <span>&#39;__main__&#39;</span><span>:</span>
</span></span><span><span>    <span>f</span> <span>=</span> <span>Fac</span><span>()</span>
</span></span><span><span>    <span>print</span><span>(</span><span>f</span><span>.</span><span>fac</span><span>(</span><span>10</span><span>))</span>
</span></span></code></pre></div><p>We get to use a new loglevel <code>TRACE</code>, and import <code>@logged</code> and <code>@traced</code> decorators from the package.
After setting up a log channel with proper formatting, we can mark functions with the decorator, get their execution traced and can simply log.</p>
<p>The output:</p>
<p>
  <img src="https://blog.koehntopp.info/uploads/2023/03/python-tracing-03.png" alt=""/>
</p>


<p><em>Output of our program using the <code>autologging</code> package.</em></p>

<p>At this point Andreas Thienemann mentioned <code>icecream</code>, which is remarkable comfortable.
Versions of <code>icecream</code> exist for many programming languages, so this is not Python specific.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> <span>icecream</span> <span>import</span> <span>ic</span>
</span></span><span><span>
</span></span><span><span><span>ic</span><span>.</span><span>configureOutput</span><span>(</span><span>includeContext</span><span>=</span><span>True</span><span>)</span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>class</span> <span>Fac</span><span>:</span>
</span></span><span><span>    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>):</span>
</span></span><span><span>        <span>pass</span>
</span></span><span><span>
</span></span><span><span>    <span>def</span> <span>fac</span><span>(</span><span>self</span><span>,</span> <span>n</span><span>:</span> <span>int</span><span>)</span> <span>-&gt;</span> <span>int</span><span>:</span>
</span></span><span><span>        <span>ic</span><span>(</span><span>n</span><span>)</span>
</span></span><span><span>        <span>if</span> <span>n</span> <span>==</span> <span>1</span><span>:</span>
</span></span><span><span>            <span>return</span> <span>ic</span><span>(</span><span>1</span><span>)</span>
</span></span><span><span>        <span>else</span><span>:</span>
</span></span><span><span>            <span>return</span> <span>ic</span><span>(</span><span>n</span> <span>*</span> <span>self</span><span>.</span><span>fac</span><span>(</span><span>n</span> <span>-</span> <span>1</span><span>))</span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>if</span> <span>__name__</span> <span>==</span> <span>&#39;__main__&#39;</span><span>:</span>
</span></span><span><span>    <span>f</span> <span>=</span> <span>Fac</span><span>()</span>
</span></span><span><span>    <span>print</span><span>(</span><span>f</span><span>.</span><span>fac</span><span>(</span><span>10</span><span>))</span>
</span></span></code></pre></div><p>Icecream defined a function <code>ic()</code>, which you can call with parameters (<code>ic(n)</code>, <code>ic(1)</code>, and <code>ic(n * self.fac(n - 1))</code>), or without (<code>ic()</code>).
The function will print its parameters, just like a debug print, or when called without parameters, just log its execution including source file and line.
Options to prettify the output exist.</p>
<p>The package also provides a function <code>install()</code>, which will simply make <code>ic()</code> available as a builtin:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> <span>icecream</span> <span>import</span> <span>ic</span>
</span></span><span><span><span>install</span><span>()</span>
</span></span><span><span><span># this basically does builtin.ic = ic</span>
</span></span><span><span>
</span></span><span><span><span># ic() is now available in all your modules </span>
</span></span><span><span><span># without having to include it in every submodule.</span>
</span></span></code></pre></div><p>The output looks like this:</p>
<p>
  <img src="https://blog.koehntopp.info/uploads/2023/03/python-tracing-04.png" alt=""/>
</p>


<p><em>Running our code with <code>icecream</code> produces this output, nicely colorized and pretty printed.
We enabled <code>includeContext=True</code>, so we also get file names and line numbers.</em></p>

<p>Of course, this is not the end of it.
The package <a href="https://github.com/alexmojaki/snoop" target="_blank" rel="noopener">snoop</a>

 provides tracing of one or all functions,
comes with its own version of icecream called <code>pp</code> (PrettyPrint).
Using <code>pp.deep()</code>, it will show expression evaluation step by step.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> <span>snoop</span> <span>import</span> <span>pp</span>
</span></span><span><span><span>pp</span><span>.</span><span>deep</span><span>(</span><span>lambda</span><span>:</span> <span>x</span> <span>+</span> <span>1</span> <span>+</span> <span>max</span><span>(</span><span>y</span> <span>+</span> <span>2</span><span>,</span> <span>y</span> <span>+</span> <span>3</span><span>))</span>
</span></span></code></pre></div><p>logs</p>
<div><pre tabindex="0"><code data-lang="console"><span><span><span>12:34:56.78 LOG:
</span></span></span><span><span><span>12:34:56.78 ............ x = 1
</span></span></span><span><span><span>12:34:56.78 ........ x + 1 = 2
</span></span></span><span><span><span>12:34:56.78 ................ y = 2
</span></span></span><span><span><span>12:34:56.78 ............ y + 2 = 4
</span></span></span><span><span><span>12:34:56.78 ................ y = 2
</span></span></span><span><span><span>12:34:56.78 ............ y + 3 = 5
</span></span></span><span><span><span>12:34:56.78 ........ max(y + 2, y + 3) = 5
</span></span></span><span><span><span>12:34:56.78 .... x + 1 + max(y + 2, y + 3) = 7
</span></span></span></code></pre></div><p>Snoop understands Python:
It shows not just file numbers, but actual code call context, parameters.
It handles debugging Decorators, can log Exceptions properly, and can log call stacks of a configurable depth.</p>
<p>Check out the examples in the link above.</p>
<p><a href="https://github.com/alexmojaki/birdseye" target="_blank" rel="noopener">birdseye</a>

 is a continuation of <code>snoop</code> to the extreme, and integrated with it.
It captures the same data as <code>snoop</code>, but logs it to a SQLite file in your <code>$HOME</code>.
It will then allow you to start a <code>flask</code>-based Webserver on port 7777 to evaluate the trace file and replay it step by step.</p>
<p><code>@spy</code> allows you to run <code>snoop</code> and <code>birdseye</code> in tandem.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> <span>birdseye</span> <span>import</span> <span>eye</span>
</span></span><span><span><span>from</span> <span>snoop</span> <span>import</span> <span>snoop</span><span>,</span> <span>spy</span>
</span></span><span><span>
</span></span><span><span><span>@spy</span>
</span></span><span><span><span>def</span> <span>fac</span><span>(</span><span>n</span><span>:</span> <span>int</span><span>)</span> <span>-&gt;</span> <span>int</span><span>:</span>
</span></span><span><span>    <span>if</span> <span>n</span> <span>&lt;=</span> <span>1</span><span>:</span>
</span></span><span><span>        <span>return</span> <span>1</span>
</span></span><span><span>    <span>else</span><span>:</span>
</span></span><span><span>        <span>return</span> <span>n</span> <span>*</span> <span>fac</span><span>(</span><span>n</span><span>-</span><span>1</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>if</span> <span>__name__</span> <span>==</span> <span>&#39;__main__&#39;</span><span>:</span>
</span></span><span><span>    <span>result</span> <span>=</span> <span>fac</span><span>(</span><span>3</span><span>)</span>
</span></span><span><span>    <span>print</span><span>(</span><span>f</span><span>&#34;</span><span>{</span><span>result</span><span>=}</span><span>&#34;</span><span>)</span>
</span></span></code></pre></div><p>This will instrument the code to run with <code>snoop</code>, and also log into the database file.</p>
<p>The trace is pretty:</p>
<p>
  <img src="https://blog.koehntopp.info/uploads/2023/03/python-tracing-05.png" alt=""/>
</p>


<p><em>Output of <code>snoop</code> running on our test function. We instrumented with <code>@spy</code>, which will also create a trace file.</em></p>
<p>Running the Birdseye decoder is easy: <code>python -m birdeye</code> will start it on the default port, <code>7777</code>.</p>
<p>
  <img src="https://blog.koehntopp.info/uploads/2023/03/python-tracing-06.png" alt=""/>
</p>


<p><em>Starting the <code>birdseye</code> web server to serve trace files. It is bound to localhost, and listens by default on Port <code>7777</code>.</em></p>
<p>The rendered trace looks like this:</p>
<p>
  <img src="https://blog.koehntopp.info/uploads/2023/03/python-tracing-07.png" alt=""/>
</p>


<p><em><code>birdseye</code> webserver showing a trace. You can click through the program execution.</em></p>

<p>The package <a href="https://github.com/gergelyk/peepshow" target="_blank" rel="noopener">peepshow</a>

 then offers a full scale commandline debugger, which allows you to trace program execution, set breakpoints and so on.</p>
<p>Unfortunately, it has been abandoned (the last commit was in November 2020), and does not support modern Python.</p>

<p>What if you cannot access the host your code runs on, for example, because that host is variable and many, because you are running in Kubernetes?
In this case, Honeycomb and other OpenTelemetry packages have you covered.
They do the same logging as above, but package data in OpenTelemetry Spans, and send these over the network.</p>
<p>The old, original Honeycomb Beeline for Python is documented here: <a href="https://docs.honeycomb.io/getting-data-in/beeline/python/" target="_blank" rel="noopener">Python Beeline</a>

.
The current OTel compatible implementation is here: <a href="https://docs.honeycomb.io/getting-data-in/opentelemetry/python/" target="_blank" rel="noopener">OTel replacement</a>

.</p>
<p>A medium article discussion the same decorator usage as we do here, but in the context of OpenTelemetry, is available:
<a href="https://digma.ai/blog/using-decorators-to-instrument-python-code-with-opentelemetry-traces/" target="_blank" rel="noopener">Using Decorators to Instrument Python Code With OpenTelemetry Traces</a>

.</p>

<p>A similar solution exists for the C programming language since 1987, in the form of the Fred Fish Debug Macros.</p>
<p>See the usage <a href="https://github.com/mysql/mysql-server/blob/1bfe02bdad6604d54913c62614bde57a055c8332/mysys/list.cc#L44-L56" target="_blank" rel="noopener">in MySQL</a>

,
and grab <a href="https://github.com/mysql/mysql-server/blob/1bfe02bdad6604d54913c62614bde57a055c8332/mysys/dbug.cc" target="_blank" rel="noopener">the source</a>

.</p>
<p>This is older than time itself, and C is a bit limited compared to Python, but it basically does the same thing, in 36 years old code.</p>
<p>The code for these samples has been made avialable <a href="https://github.com/isotopp/logging-experiments" target="_blank" rel="noopener">on GitHub</a>

.</p>

			</div>
		</div></div>
  </body>
</html>
