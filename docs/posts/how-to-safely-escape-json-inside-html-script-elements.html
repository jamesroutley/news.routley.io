<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sirre.al/2025/08/06/safe-json-in-script-tags-how-not-to-break-a-site/">Original</a>
    <h1>How to safely escape JSON inside HTML SCRIPT elements</h1>
    
    <div id="readability-page-1" class="page"><div>
<p><code>&lt;script&gt;</code> tags follow unintuitive parsing rules that can break a webpage in surprising ways. Fortunately, it’s relatively straightforward to escape JSON for script tags.</p>



<h2>Just do this</h2>



<ul>
<li>Replace <code>&lt;</code> with <code>\x3C</code> or <code>\u003C</code> in JSON strings.</li>



<li>In PHP, use <code>json_encode($data, JSON_HEX_TAG | JSON_UNESCAPED_SLASHES)</code> for safe JSON in <code>&lt;script&gt;</code> tags.</li>



<li>In WordPress, use <code><a href="https://developer.wordpress.org/reference/functions/wp_json_encode/">wp_json_encode</a></code> with the same flags.</li>
</ul>



<p>You don’t have to take my word for it, the <a href="https://html.spec.whatwg.org/multipage/scripting.html#restrictions-for-contents-of-script-elements">HTML standard recommends this type of escaping</a>:</p>



<blockquote>
<p>The easiest and safest … is to always escape an ASCII case-insensitive match for “<code>&lt;!--</code>” as “<code>\x3C!--</code>“, “<code>&lt;script</code>” as “<code>\x3Cscript</code>“, and “<code>&lt;/script</code>” as “<code>\x3C/script</code>“…</p>
</blockquote>



<p>This post will dive deep into the exotic script tag parsing rules in order to understand how they work and why this is the appropriate way to escape JSON.</p>



<h2>What’s so gnarly about a script tag?</h2>



<p>Script tags are used to embed other languages in HTML. The most common example is JavaScript:</p>







<p>This is great, JavaScript can be embedded directly. Imagine if script tags required HTML escaping:</p>







<p>In fact, script tags can contain any language (not necessarily JavaScript) or even arbitrary data. In order to support this behavior, script tags have special parsing rules. For the most part, the browser accepts <em>whatever</em> is inside the script tag until it finds the script close tag <code>&lt;/script&gt;</code><sup data-fn="7b3580c4-6ee3-49a2-9c93-2178535174da"><a href="#7b3580c4-6ee3-49a2-9c93-2178535174da" id="7b3580c4-6ee3-49a2-9c93-2178535174da-link">1</a></sup>.</p>



<p>So, what happens when we embed this perfectly valid JavaScript that contains a script close tag?</p>







<p>Oops! We can see that <code>&lt;/script&gt;</code> was part of a JavaScript string, but the browser is just parsing the HTML. This script element closes prematurely, resulting in the following tree:</p>



<pre><code>├─SCRIPT
│ └─#text console.log(&#39;
└─#text &#39;)</code></pre>



<p>Ok, let’s use <code>json_encode()</code> and we should be all set:</p>







<p>Now we’ve got this HTML:</p>







<p><code>&lt;/script&gt;</code> has become <code>&lt;\/script&gt;</code>. The JavaScript string value is preserved and the script element does not close prematurely. Perfect, right?</p>



<h2>Not so fast, things are about to get messy</h2>



<p>Let’s expand with a more complex example. Here’s some data used by an imaginary HTML library. We’ll escape the JSON again with <code>json_encode</code><sup data-fn="57f5126d-21a4-41e0-a4fa-9589b6599e43"><a href="#57f5126d-21a4-41e0-a4fa-9589b6599e43" id="57f5126d-21a4-41e0-a4fa-9589b6599e43-link">2</a></sup>:</p>







<p>Our HTML page includes the following, with a safely escaped script close tag:</p>







<p>Lovely. We’re good at this. Let’s just ship that 🚀</p>



<hr/>



<p>🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥</p>



<hr/>



<p>Great. Production is now a blank page and we need to write a post-mortem. What happened? The HTML looks just fine. <a href="https://software.hixie.ch/utilities/js/live-dom-viewer/?%3Cscript%3E%7B%0A%20%20%20%20%22closeComment%22%3A%20%22--%3E%22%2C%0A%20%20%20%20%22closeScript%22%3A%20%22%3C%5C%2Fscript%3E%22%2C%0A%20%20%20%20%22openComment%22%3A%20%22%3C!--%22%2C%0A%20%20%20%20%22openScript%22%3A%20%22%3Cscript%3E%22%0A%7D%3C%2Fscript%3E%0A%3Ch1%3ESuccess!%20%F0%9F%8E%89%3C%2Fh1%3E">Let’s inspect the document tree</a>:</p>



<pre><code>└─SCRIPT
  └─#text {␊
              &#34;closeComment&#34;: &#34;--&gt;&#34;,␊
              &#34;closeScript&#34;: &#34;&lt;\/script&gt;&#34;,␊
              &#34;openComment&#34;: &#34;&lt;!--&#34;,␊
              &#34;openScript&#34;: &#34;&lt;script&gt;&#34;␊
          }&lt;/script&gt;␊
          &lt;h1&gt;Success! 🎉&lt;/h1&gt;</code></pre>



<p>The script tag did not close as expected at <code>&lt;/script&gt;</code>. The script close tag and all of the subsequent HTML are <em>part of the script tag contents</em>.</p>



<h2>Wait, what???</h2>



<p>We’ve just discovered some of those unintuitive parsing rules. In short, the <a href="https://html.spec.whatwg.org/multipage/parsing.html#script-data-double-escaped-state">HTML parser entered <em>script data double escaped state</em></a> and got stuck. <a href="https://core.trac.wordpress.org/ticket/62797">Yes, this does break real pages.</a></p>



<p>If you’re not steeped in HTML arcana, fear not, this handy chart should clarify things 🙃</p>



<figure><a href="https://i0.wp.com/sirre.al/wp-content/uploads/2025/08/html-script-data.png?ssl=1"><img data-recalc-dims="1" fetchpriority="high" decoding="async" width="1024" height="253" src="https://i0.wp.com/sirre.al/wp-content/uploads/2025/08/html-script-data.png?resize=1024%2C253&amp;ssl=1" alt="" srcset="https://i0.wp.com/sirre.al/wp-content/uploads/2025/08/html-script-data.png?resize=1024%2C253&amp;ssl=1 1024w, https://i0.wp.com/sirre.al/wp-content/uploads/2025/08/html-script-data.png?resize=300%2C74&amp;ssl=1 300w, https://i0.wp.com/sirre.al/wp-content/uploads/2025/08/html-script-data.png?resize=768%2C189&amp;ssl=1 768w, https://i0.wp.com/sirre.al/wp-content/uploads/2025/08/html-script-data.png?resize=1536%2C379&amp;ssl=1 1536w, https://i0.wp.com/sirre.al/wp-content/uploads/2025/08/html-script-data.png?resize=2048%2C505&amp;ssl=1 2048w, https://i0.wp.com/sirre.al/wp-content/uploads/2025/08/html-script-data.png?resize=1200%2C296&amp;ssl=1 1200w, https://i0.wp.com/sirre.al/wp-content/uploads/2025/08/html-script-data.png?w=3000&amp;ssl=1 3000w" sizes="(max-width: 1000px) 100vw, 1000px"/></a></figure>



<p>This is a real and mostly accurate diagram of how script tag tokenization works. I’ve taken some liberties with things like end-of-file tokens and null bytes that aren’t relevant to the discussion.</p>



<p>You may be wondering, like I did, why HTML would work like this. <a href="https://stackoverflow.com/a/52157140/1432801">Well, the web wasn’t always the mature platform we know and love today:</a></p>



<blockquote>
<p>When JavaScript was first introduced, many browsers did not support it. So they would render the content of the script tag – the JavaScript code itself. The normal way to get around that was to put the script into a comment — things like</p>
</blockquote>







<p>This kind of practice was commonplace on the web. As the web evolved, browsers continued to support the behavior so they wouldn’t break existing pages. Then, HTML5 came along and standardized the behavior so folks knew what to expect, even if it’s surprising. We can see other remnants of this practice in the <a href="https://html.spec.whatwg.org/multipage/scripting.html#restrictions-for-contents-of-script-elements">HTML scripting specification:</a></p>



<blockquote>
<p>for related historical reasons, the string “&lt;!–” in classic scripts is actually treated as a line comment start, just like “//”.</p>
</blockquote>



<p>Back to our <em>script data double escaped state</em>. We can simplify the diagram above to collapse some states and focus on the interesting transitions:</p>



<figure data-wp-context="{&#34;imageId&#34;:&#34;689bd36d5f925&#34;}" data-wp-interactive="core/image"><img data-recalc-dims="1" decoding="async" width="1024" height="191" data-wp-class--hide="state.isContentHidden" data-wp-class--show="state.isContentVisible" data-wp-init="callbacks.setButtonStyles" data-wp-on-async--click="actions.showLightbox" data-wp-on-async--load="callbacks.setButtonStyles" data-wp-on-async-window--resize="callbacks.setButtonStyles" src="https://i0.wp.com/sirre.al/wp-content/uploads/2025/08/html-script-data-simple.png?resize=1024%2C191&amp;ssl=1" alt="" srcset="https://i0.wp.com/sirre.al/wp-content/uploads/2025/08/html-script-data-simple.png?resize=1024%2C191&amp;ssl=1 1024w, https://i0.wp.com/sirre.al/wp-content/uploads/2025/08/html-script-data-simple.png?resize=300%2C56&amp;ssl=1 300w, https://i0.wp.com/sirre.al/wp-content/uploads/2025/08/html-script-data-simple.png?resize=768%2C143&amp;ssl=1 768w, https://i0.wp.com/sirre.al/wp-content/uploads/2025/08/html-script-data-simple.png?resize=1536%2C287&amp;ssl=1 1536w, https://i0.wp.com/sirre.al/wp-content/uploads/2025/08/html-script-data-simple.png?resize=2048%2C382&amp;ssl=1 2048w, https://i0.wp.com/sirre.al/wp-content/uploads/2025/08/html-script-data-simple.png?w=3000&amp;ssl=1 3000w" sizes="(max-width: 1000px) 100vw, 1000px"/></figure>



<p>This diagram names some transitions <code>&lt;script</code> and <code>&lt;/script</code>. This is true, but the tag name only matches when the name <em>script</em> is followed by a byte that terminates a tag name — Space, Tab, “/”, “&gt;”, or a newline (<code>\n</code>, <code>\f</code>, <code>\r</code>). For example, <code>&lt;script-o-rama</code> or <code>&lt;/scripty</code> do not transition.</p>



<p>To understand the problem with our example above, locate the three transitions for <code>&lt;/script</code>:</p>



<ul>
<li>script data → close</li>



<li>script data escaped → close</li>



<li>‼️ <strong>script data double escaped → script data escaped</strong> ‼️</li>
</ul>



<p><code>&lt;/script&gt;</code> does not close a script element from the <em>script data double escaped state</em>.</p>



<p><a href="https://software.hixie.ch/utilities/js/live-dom-viewer/?%3Cscript%3E%0A%2F%2F%20The%20following%20line%20will%20enter%20_script%20data%20double%20escaped%20state_%20%F0%9F%98%B1%0A%3C!--%3Cscript%0A%0A%2F%2F%20Remove%20the%20%22x%22%20here%20to%20exit%20_double%20escaped_%3A%20%3C%2Fscriptx%0A%2F%2F%20Complete%20comment%20closer%20here%20(add%20%22-%22)%20to%20exit%20_double%20escaped_%3A%20-%3E%0A%3C%2Fscript%3E%0A%3Ch1%3EIf%20this%20renders%2C%20you%20closed%20the%20script%20tag!%3C%2Fh1%3E">I encourage you to pause for a moment and play with this example to get a feel for how the script tag escaped states work.</a></p>



<h2>Avoid the doubled escaped state</h2>



<p>The complexity of script tag parsing and escaping comes from the escaped states. <strong>Avoid the <em>script data double escaped state</em> and script tags become simple.</strong> Everything until the tag closer <code>&lt;/script&gt;</code> is inside the script element.</p>



<p>How can we avoid the double escaped state? Script tag parsing always starts in the <em>script data state</em> and there’s a pattern in its transitions:</p>



<ul>
<li><code>&lt;/script</code>: <em>script data</em> → close</li>



<li><code>&lt;!--</code>: <em>script data</em> → <em>script data escaped</em></li>
</ul>



<p>Both require “<code>&lt;</code>” as their first character!<sup data-fn="fe8aa7b6-0506-40e9-b4b8-cfd3422d52ed"><a href="#fe8aa7b6-0506-40e9-b4b8-cfd3422d52ed" id="fe8aa7b6-0506-40e9-b4b8-cfd3422d52ed-link">3</a></sup> Everything will be handled predictably if <code>&lt;</code> never appears inside of the script tag. <a href="https://html.spec.whatwg.org/multipage/scripting.html#restrictions-for-contents-of-script-elements">Remember what the HTML standard on scripting said?</a> It recommends escaping <code>&lt;</code> in specific places:</p>



<blockquote>
<p>[Escape] “<code>&lt;!--</code>” as “<code>\x3C!--</code>“, “<code>&lt;script</code>” as “<code>\x3Cscript</code>“, and “<code>&lt;/script</code>” as “<code>\x3C/script</code>” [in literals.]</p>
</blockquote>



<p>PHP has the <strong><code><a href="https://www.php.net/manual/en/json.constants.php#constant.json-hex-tag">JSON_HEX_TAG</a></code></strong> flag that will escape all <code>&lt;</code> as <code>\u003C</code> and <code>&gt;</code> <code>\u003E</code>. This will escape much more than is strictly necessary, but it’s sufficient and is provided by the language. Perfect!</p>



<h2>How to escape JSON escaping in PHP</h2>



<p>For JSON that will be printed in a script tag, use the following flags:</p>



<ul>
<li><code><a href="https://www.php.net/manual/en/json.constants.php#constant.json-hex-tag">JSON_HEX_TAG</a></code></li>



<li><code><a href="https://www.php.net/manual/en/json.constants.php#constant.json-unescaped-slashes">JSON_UNESCAPED_SLASHES</a></code></li>
</ul>



<p>If everything is UTF-8 (both the data and the charset of the page) you can add these flags for cleaner and shorter JSON:</p>



<ul>
<li><code><a href="https://www.php.net/manual/en/json.constants.php#constant.json-unescaped-unicode">JSON_UNESCAPED_UNICODE</a></code></li>



<li><code><a href="https://www.php.net/manual/en/json.constants.php#constant.json-unescaped-line-terminators">JSON_UNESCAPED_LINE_TERMINATORS</a></code></li>
</ul>



<p><code>JSON_UNESCAPED_LINE_TERMINATORS</code> is a fun one. Before ES2019, JavaScript strings did not accept two characters <code>U+2028 (LINE SEPARATOR)</code> and <code>U+2029 (PARAGRAPH SEPARATOR)</code> that JSON strings <em>do</em> allow. Some valid JSON was invalid JavaScript. Since the <a href="https://github.com/tc39/proposal-json-superset">JavaScript is a superset of JSON proposal</a> landed in ES2019, that’s no longer the case and those characters no longer require escaping. Phew! <a href="https://caniuse.com/mdn-javascript_builtins_json_json_superset">Browser support today is very good.</a></p>



<h2>JSON escaping in action</h2>



<p>Here’s the problematic example again, now with the recommended flags:</p>







<p>Let’s see the printed HTML and its resulting tree:</p>







<pre><code>├─SCRIPT
│ └─#text {␊
│             &#34;closeComment&#34;: &#34;--\u003E&#34;,␊
│             &#34;closeScript&#34;: &#34;\u003C/script\u003E&#34;,␊
│             &#34;openComment&#34;: &#34;\u003C!--&#34;,␊
│             &#34;openScript&#34;: &#34;\u003Cscript\u003E&#34;␊
│         }
├─#text ␊ 
└─H1
  └─#text Success! 🎉</code></pre>



<p>“Success! 🎉” is displayed and the tree structure is exactly what we expected.</p>



<h2>What about JavaScript?</h2>



<p>The problems with JSON seem to be solved. But what about JavaScript source text? Or what if we decide to embed XML, Python, or Haskell in a script tag? All of those are permitted but bring different challenges.</p>



<p>Given what we learned here, see if you can find a general solution for escaping JavaScript safely. Remember that <em>script data double escaped state</em> is dangerous and should be avoided. We also can’t allow the script tag to close prematurely with <code>&lt;/script&gt;</code>. The path from our entry state to double-escaped looks like this:</p>



<ul>
<li><em>Script data state</em>: “<code>&lt;!--</code>” transition to</li>



<li><em>Script data escaped state</em>: “<code>&lt;script&gt;</code>” transition to</li>



<li><em>Script data double escaped state</em>: ‼️</li>
</ul>



<hr/>



<p>The diagrams in this post were generated with <a href="https://mermaid.js.org/">Mermaid</a>. <a href="https://gist.github.com/sirreal/806e5afdac1094164cff0037a6e175ab">Their source is available in this gist</a>.</p>


</div></div>
  </body>
</html>
