<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/tomhea/c2fj">Original</a>
    <h1>Show HN: Compile C to Not Gates</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text"><p dir="auto"><a href="https://github.com/tomhea/c2fj/blob/main/LICENSE"><img src="https://camo.githubusercontent.com/374f407140f12d3231e2372cd262efe797423d76ceb5767606dfca26ff6adc2f/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f6c6963656e73652f746f6d6865612f6332666a" alt="GitHub" data-canonical-src="https://img.shields.io/github/license/tomhea/c2fj"/></a>
<a href="https://esolangs.org/wiki/FlipJump" rel="nofollow"><img src="https://camo.githubusercontent.com/36d3a6fb034708ad2e1e392abd9ac46c902bc03cf307aff7ab388d3364512a92/68747470733a2f2f696d672e736869656c64732e696f2f776562736974653f646f776e5f636f6c6f723d72656426646f776e5f6d6573736167653d646f776e2675705f6d6573736167653d75702675726c3d687474707325334125324625324665736f6c616e67732e6f726725324677696b69253246466c69704a756d70" alt="Website" data-canonical-src="https://img.shields.io/website?down_color=red&amp;down_message=down&amp;up_message=up&amp;url=https%3A%2F%2Fesolangs.org%2Fwiki%2FFlipJump"/></a>
<a href="https://pypi.org/project/c2fj/" rel="nofollow"><img src="https://camo.githubusercontent.com/e5304c16795d7b9fc0409a1ae042cfb36829707a615ef4e026b91d2aa1361ef2/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f6332666a" alt="PyPI - Version" data-canonical-src="https://img.shields.io/pypi/v/c2fj"/></a></p>

<p dir="auto">Compiling C --&gt; RiscV --&gt; <a href="https://github.com/tomhea/flip-jump">Flipjump</a> --&gt; .fjm</p>
<p dir="auto">This compiler is a proof that any program can be compiled into a bunch of <code>NOT</code> operations. Read more about FlipJump: <a href="https://github.com/tomhea/flip-jump">Github</a>, <a href="https://esolangs.org/wiki/FlipJump" rel="nofollow">esolangs</a>.</p>
<p dir="auto">An example program, <a href="https://github.com/tomhea/c2fj/blob/main/tests/programs/primes/main.c">primes/main.c</a>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="int main() {
    printf(&#34;Calculate primes up to: &#34;);
    int max_number;
    scanf(&#34;%d&#34;, &amp;max_number);
    
    ...
    
    for (int p = 3; p &lt;= max_number; p += 2) {
        if (non_prime[p] == false) {
            for (int i = p*p; i &lt;= max_number; i += p) {
                non_prime[i] = true;
            }
            printf(&#34;%d\n&#34;, p);
        }
    }
    
    return 0;
}"><pre><span>int</span> <span>main</span>() {
    <span>printf</span>(<span>&#34;Calculate primes up to: &#34;</span>);
    <span>int</span> <span>max_number</span>;
    <span>scanf</span>(<span>&#34;%d&#34;</span>, <span>&amp;</span><span>max_number</span>);
    
    ...
    
    <span>for</span> (<span>int</span> <span>p</span> <span>=</span> <span>3</span>; <span>p</span> &lt;= <span>max_number</span>; <span>p</span> <span>+=</span> <span>2</span>) {
        <span>if</span> (<span>non_prime</span>[<span>p</span>] <span>==</span> false) {
            <span>for</span> (<span>int</span> <span>i</span> <span>=</span> <span>p</span><span>*</span><span>p</span>; <span>i</span> &lt;= <span>max_number</span>; <span>i</span> <span>+=</span> <span>p</span>) {
                <span>non_prime</span>[<span>i</span>] <span>=</span> true;
            }
            <span>printf</span>(<span>&#34;%d\n&#34;</span>, <span>p</span>);
        }
    }
    
    <span>return</span> <span>0</span>;
}</pre></div>
<p dir="auto">Compiled into this:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/tomhea/c2fj/blob/main/res/compiled_elf.png"><img src="https://github.com/tomhea/c2fj/raw/main/res/compiled_elf.png" alt="img.png"/></a></p>
<p dir="auto">Which was compiled into this:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/tomhea/c2fj/blob/main/res/compiled_fj_files.png"><img src="https://github.com/tomhea/c2fj/raw/main/res/compiled_fj_files.png" alt="img.png"/></a></p>
<p dir="auto">Which in turn compiled into:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/tomhea/c2fj/blob/main/res/compiled_fjm.png"><img src="https://github.com/tomhea/c2fj/raw/main/res/compiled_fjm.png" alt="img.png"/></a></p>
<p dir="auto">Now, run it (Remember, these are flipjump ops that are running):</p>
<div data-snippet-clipboard-copy-content="Calculate primes up to: 20
2
3
5
7
11
13
17
19
Program exited with exit code 0x0."><pre lang="text"><code>Calculate primes up to: 20
2
3
5
7
11
13
17
19
Program exited with exit code 0x0.
</code></pre></div>

<div data-snippet-clipboard-copy-content="&gt;&gt;&gt; pip install c2fj
&gt;&gt;&gt; sudo apt install picolibc-riscv64-unknown-elf"><pre><code>&gt;&gt;&gt; pip install c2fj
&gt;&gt;&gt; sudo apt install picolibc-riscv64-unknown-elf
</code></pre></div>

<p dir="auto">Simply <code>python3 c2fj.py file.c</code> will compile your c file into an elf, into fj files, into fjm, then run it.</p>
<p dir="auto"><code>c2fj</code> supports the next flags:</p>
<ul dir="auto">
<li><code>--breakpoints</code> Place a fj-breakpoint at the start of the specified riscv addresses</li>
<li><code>--single-step</code> Place fj-breakpoints at the start of all riscv opcodes</li>
<li><code>--unify_fj</code> Unify the generated fj files into a single file</li>
<li><code>--finish-after</code> Stop the compilation at any step (before running, before creating fjm, etc.)</li>
<li><code>--build-dir</code> Save the builds in this directory</li>
</ul>
<div dir="auto"><h2 tabindex="-1" dir="auto">What if my project is more then a single c?</h2><a id="user-content-what-if-my-project-is-more-then-a-single-c" aria-label="Permalink: What if my project is more then a single c?" href="#what-if-my-project-is-more-then-a-single-c"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">We support specifying a <code>Makefile</code> path, instead of the c file!</p>
<div dir="auto" data-snippet-clipboard-copy-content="C2FJ_GCC_OPTIONS
C2FJ_LINKER_SCRIPT
C2FJ_SOURCES
C2FJ_INCLUDE_DIRS
ELF_OUT_PATH"><pre><span>C2FJ_GCC_OPTIONS</span>
<span>C2FJ_LINKER_SCRIPT</span>
<span>C2FJ_SOURCES</span>
<span>C2FJ_INCLUDE_DIRS</span>
<span>ELF_OUT_PATH</span></pre></div>
<p dir="auto">An example Makefile:</p>
<div dir="auto" data-snippet-clipboard-copy-content="GCC := riscv64-unknown-elf-gcc
GCC_FLAGS := -O3

SOURCES := $(C2FJ_SOURCES) main.c globals.c calculate_int.c
OBJECTS := $(SOURCES:.c=.o)

all: |
	$(GCC) $(C2FJ_GCC_OPTIONS) $(GCC_FLAGS) $(SOURCES) -I $(C2FJ_INCLUDE_DIRS) -T $(C2FJ_LINKER_SCRIPT) -o $(ELF_OUT_PATH)

clean:
	rm -r build 2&gt;/dev/null || true

.PHONY: clean all
"><pre><span>GCC</span> := riscv64-unknown-elf-gcc
<span>GCC_FLAGS</span> := -O3

<span>SOURCES</span> := <span>$(<span>C2FJ_SOURCES</span>)</span> main.c globals.c calculate_int.c
<span>OBJECTS</span> := <span>$(<span>SOURCES:.c=.o</span>)</span>

<span>all</span>: |
	<span>$(<span>GCC</span>)</span> <span>$(<span>C2FJ_GCC_OPTIONS</span>)</span> <span>$(<span>GCC_FLAGS</span>)</span> <span>$(<span>SOURCES</span>)</span> -I <span>$(<span>C2FJ_INCLUDE_DIRS</span>)</span> -T <span>$(<span>C2FJ_LINKER_SCRIPT</span>)</span> -o <span>$(<span>ELF_OUT_PATH</span>)</span>

<span>clean</span>:
	rm -r build <span>2&gt;</span>/dev/null <span>||</span> <span>true</span>

<span>.PHONY</span>: clean all
</pre></div>
<p dir="auto">You can also specify your own linker script. It should contain the following:</p>
<ul dir="auto">
<li><code>_stack_end</code> (just after the end of the stack)</li>
<li><code>_sdata</code> (start of the data section)</li>
<li><code>__heap_start</code> (start of the heap)</li>
</ul>

<p dir="auto">First your C files are being compile to a RiscV elf.</p>
<p dir="auto">For example, look at <code>exit</code> (<a href="https://github.com/tomhea/c2fj/blob/main/c2fj/compilation_files/c2fj_init.c">c2fj_init.c</a>):</p>
<div dir="auto" data-snippet-clipboard-copy-content="void exit(int status) {
    asm volatile (&#34;jal %0, .+10&#34; ::&#34;r&#34;(status):&#34;memory&#34;);
    __builtin_unreachable();
}"><pre><span>void</span> <span>exit</span>(<span>int</span> <span>status</span>) {
    asm <span>volatile</span> (<span>&#34;jal %0, .+10&#34;</span> ::<span>&#34;r&#34;</span>(<span>status</span>):<span>&#34;memory&#34;</span>);
    <span>__builtin_unreachable</span>();
}</pre></div>
<p dir="auto">It uses jal with bad offset, thus will be parsed here as: (<a href="https://github.com/tomhea/c2fj/blob/main/c2fj/riscv_instructions.py">riscv_instructions.py</a>)</p>
<div dir="auto" data-snippet-clipboard-copy-content="elif imm == JAL_EXIT_IMMEDIATE:
    return f&#39;    .syscall.exit {register_name(rd)}\n&#39;"><pre><span>elif</span> <span>imm</span> <span>==</span> <span>JAL_EXIT_IMMEDIATE</span>:
    <span>return</span> <span>f&#39;    .syscall.exit <span><span>{</span><span>register_name</span>(<span>rd</span>)<span>}</span></span><span>\n</span>&#39;</span></pre></div>
<p dir="auto">Thus, will get to the flipjump implementation of: (<a href="https://github.com/tomhea/c2fj/blob/main/c2fj/compilation_files/riscvlib.fj">riscvlib.fj</a>)</p>
<div dir="auto" data-snippet-clipboard-copy-content="def exit src_register {
    stl.output &#34;Program exited with exit code &#34;
    hex.print_uint 2, src_register, 1, 1
    stl.output &#34;.\n&#34;
    stl.loop
}"><pre><span>def</span> <span>exit</span> <span>src_register</span> {
    <span>stl</span>.<span>output</span> <span>&#34;Program exited with exit code &#34;</span>
    <span>hex</span>.<span>print_uint</span> <span>2</span>, <span>src_register</span>, <span>1</span>, <span>1</span>
    <span>stl</span>.<span>output</span> <span>&#34;.<span>\n</span>&#34;</span>
    <span>stl</span>.<span>loop</span>
}</pre></div>
<p dir="auto">You can think of it like this: The C-&gt;RiscV compilation compiles the syscalls to a special (invalid) RiscV op, that gets parsed and further compiled into the fj implementation of the &#34;requested syscall&#34;.
The supported syscalls can be found in <a href="https://github.com/tomhea/c2fj/blob/main/c2fj/compilation_files/c2fj_init.c">c2fj_init.c</a>, and they contain <code>_getc</code>, <code>_putc</code>, <code>exit</code>, <code>sbrk</code>.</p>
<p dir="auto">Every other opcode (Let&#39;s follow <code>addi x10, x11, 7</code> for example), will be compiled into itself.</p>
<p dir="auto">The RiscV -&gt; FlipJump part of the compilation parses the compiled elf, and matches each opcode with the appropriate flipjump macro. For example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="elif opcode == RV_ALU_IMM:
    if funct3 == RV_ADDI:
        ops_file.write(i_type(&#39;addi&#39;, full_op))"><pre><span>elif</span> <span>opcode</span> <span>==</span> <span>RV_ALU_IMM</span>:
    <span>if</span> <span>funct3</span> <span>==</span> <span>RV_ADDI</span>:
        <span>ops_file</span>.<span>write</span>(<span>i_type</span>(<span>&#39;addi&#39;</span>, <span>full_op</span>))</pre></div>
<p dir="auto">Then the <code>riscv.addi</code> macro is being used. The riscv ops macros are space-optimized. They are so much optimized, that each takes <code>30-40</code> fj-ops in space.</p>
<p dir="auto">The way it works, is that each opcode is implemented once in the <code>riscv.start</code> macro.
For example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="do_add:
    hex.add .HLEN, .rs1, .rs2
    stl.fret .ret"><pre><span>do_add</span>:
    <span>hex</span>.<span>add</span> .<span>HLEN</span>, .<span>rs1</span>, .<span>rs2</span>
    <span>stl</span>.<span>fret</span> .<span>ret</span></pre></div>
<p dir="auto">Note how <code>addi</code> is implemented:</p>
<div dir="auto" data-snippet-clipboard-copy-content="def addi mov_from_rs1, mov_to_rs1, imm &lt; .do_add {
    .reg_imm_fast_op mov_from_rs1, mov_to_rs1, imm, .do_add
}

// Sets rs1 according to the given &#34;fcall_label&#34;, rs2 to the given imm,
//  fcalls &#34;do_op&#34;, then moves the result to the appropriate dst reg.
def reg_imm_fast_op mov_from_dest, mov_to_rs1, imm, do_op @ table, xor_imm_to_rs2, end &lt; .ret, .zero_rs2, .rs2 {
    wflip .ret+w, table+dw, .ret

    pad 16
  table:
    .ret+dbit+2; do_op          // 4th
    .ret+dbit+1; mov_to_rs1     // 1st
    .ret+dbit+1; xor_imm_to_rs2 // 3rd
    .ret+dbit+0; .zero_rs2      // 2nd
    .ret+dbit+0; mov_from_dest  // 5th
    wflip .ret+w, table+5*dw, end   // 6th

  xor_imm_to_rs2:
    .__xor_by_hex_const .HLEN, .rs2, imm
    stl.fret .ret

  end:
}

def moves_to_from_middle_regs {
  zero_rs2:
    hex.zero .HLEN, .rs2
    stl.fret .ret
  ...
}"><pre><span>def</span> <span>addi</span> <span>mov_from_rs1</span>, <span>mov_to_rs1</span>, <span>imm</span> <span>&lt;</span> .<span>do_add</span> {
    .<span>reg_imm_fast_op</span> <span>mov_from_rs1</span>, <span>mov_to_rs1</span>, <span>imm</span>, .<span>do_add</span>
}

<span>//</span> <span>Sets</span> <span>rs1</span> <span>according</span> <span>to</span> <span>the</span> <span>given</span> <span>&#34;fcall_label&#34;</span>, <span>rs2</span> <span>to</span> <span>the</span> <span>given</span> <span>imm</span>,
<span>//</span>  <span>fcalls</span> <span>&#34;do_op&#34;</span>, <span>then</span> <span>moves</span> <span>the</span> <span>result</span> <span>to</span> <span>the</span> <span>appropriate</span> <span>dst</span> <span>reg</span>.
<span>def</span> <span>reg_imm_fast_op</span> <span>mov_from_dest</span>, <span>mov_to_rs1</span>, <span>imm</span>, <span>do_op</span> @ <span>table</span>, <span>xor_imm_to_rs2</span>, <span>end</span> <span>&lt;</span> .<span>ret</span>, .<span>zero_rs2</span>, .<span>rs2</span> {
    <span>wflip</span> .<span>ret</span><span>+</span><span>w</span>, <span>table</span><span>+</span><span>dw</span>, .<span>ret</span>

    <span>pad</span> <span>16</span>
  <span>table</span>:
    .<span>ret</span><span>+</span><span>dbit</span><span>+</span><span>2</span>; <span>do_op</span>          <span>//</span> <span>4</span><span>th</span>
    .<span>ret</span><span>+</span><span>dbit</span><span>+</span><span>1</span>; <span>mov_to_rs1</span>     <span>//</span> <span>1</span><span>st</span>
    .<span>ret</span><span>+</span><span>dbit</span><span>+</span><span>1</span>; <span>xor_imm_to_rs2</span> <span>//</span> <span>3</span><span>rd</span>
    .<span>ret</span><span>+</span><span>dbit</span><span>+</span><span>0</span>; .<span>zero_rs2</span>      <span>//</span> <span>2</span><span>nd</span>
    .<span>ret</span><span>+</span><span>dbit</span><span>+</span><span>0</span>; <span>mov_from_dest</span>  <span>//</span> <span>5</span><span>th</span>
    <span>wflip</span> .<span>ret</span><span>+</span><span>w</span>, <span>table</span><span>+</span><span>5</span><span>*</span><span>dw</span>, <span>end</span>   <span>//</span> <span>6</span><span>th</span>

  <span>xor_imm_to_rs2</span>:
    .<span>__xor_by_hex_const</span> .<span>HLEN</span>,<span></span> .<span>rs2</span>, <span>imm</span>
    <span>stl</span>.<span>fret</span> .<span>ret</span>

  <span>end</span>:
}

<span>def</span> <span>moves_to_from_middle_regs</span> {
  <span>zero_rs2</span>:
    <span>hex</span>.<span>zero</span> .<span>HLEN</span>, .<span>rs2</span>
    <span>stl</span>.<span>fret</span> .<span>ret</span>
  ...
}</pre></div>
<p dir="auto">Most of the space goes on the two <code>wflip</code>s (total <code>@-4</code> ops).</p>
<p dir="auto">So as you see, the macro gets a <code>mov_to_rs1</code> and <code>mov_from_dest</code> macros. For the example of the <code>addi x10, x11, 7</code>, the next macro names will be specified:</p>
<div dir="auto" data-snippet-clipboard-copy-content="ns riscv {
  mov_rs1_to_x10:
    hex.mov .HLEN, .regs.x10, .rs1
    stl.fret .ret

  mov_x11_to_rs1:
    hex.mov .HLEN, .rs1, .regs.x11
    stl.fret .ret
}"><pre><span>ns</span> <span>riscv</span> {
  <span>mov_rs1_to_x10</span>:
    <span>hex</span>.<span>mov</span> .<span>HLEN</span>, .<span>regs</span>.<span>x10</span>, .<span>rs1</span>
    <span>stl</span>.<span>fret</span> .<span>ret</span>

  <span>mov_x11_to_rs1</span>:
    <span>hex</span>.<span>mov</span> .<span>HLEN</span>, .<span>rs1</span>, .<span>regs</span>.<span>x11</span>
    <span>stl</span>.<span>fret</span> .<span>ret</span>
}</pre></div>
<p dir="auto">And the <code>addi x10, x11, 7</code> opcode will be compiled into <code>riscv.addi mov_rs1_to_x10, mov_x11_to_rs1, 7</code>.</p>
<p dir="auto">So when the <code>1st</code> line is executed, the <code>mov_x11_to_rs1</code> code will be executed, and it will return to the start of the <code>2nd</code> line.</p>
<p dir="auto">If you want to understand it better, feel free to <em>jump</em> into the FlipJump and read how things work in the bits and bytes level.</p>
<p dir="auto">The next phase uses the <code>flipjump</code> python package to compile the given <code>.fj</code> files into the compiles <code>.fjm</code> file (which is segments of data, and by data I mean bits of flips and jumps).</p>

<p dir="auto">In the previous section I talked about the <code>ops.fj</code> file that was created in the compilation process, but there are two more files that gets created in that process too.</p>

<p dir="auto">The entire loadable memory of the compiled elf is being loaded into flipjump using this file. It contains all the loadable bytes of the memory in fj <code>hex</code> variables.</p>

<p dir="auto">That&#39;s a jump table to every runnable riscv address. That helps us in jumping ops, because the macro addresses of the ops in the <code>ops.fj</code> can&#39;t be predicted easily.</p>
<div dir="auto" data-snippet-clipboard-copy-content="segment .JMP + 0x00000000/4*dw
;.ADDR_00000000
;.ADDR_00000004
...
;.ADDR_00000144"><pre><span>segment</span> .<span>JMP</span> <span>+</span> <span>0x00000000</span><span>/</span><span>4</span><span>*</span><span>dw</span>
;.<span>ADDR_00000000</span>
;.<span>ADDR_00000004</span>
...
;.<span>ADDR_00000144</span></pre></div>
<p dir="auto">The <code>0x144</code> address is at fixed offset from the global <code>.JMP</code> address, thus jumping to riscv memory address <code>0x144</code> became as easy as jumping to fj-address <code>.JMP + 0x144*dw</code> (as <code>dw</code> is the length of one fj opcode, in bits).</p>

<p dir="auto">Simply run <code>pytest</code> to run the tests.
This package is tested on linux and python 3.13.</p>

<ul dir="auto">
<li><a href="https://github.com/tomhea/bf2fj">bf2fj</a> - Brainfuck to FlipJump compiler.</li>
<li><a href="https://github.com/tomhea/flip-jump">FlipJump</a> - The flipjump language macro assembler, standard library, and interpreter.</li>
<li><a href="https://github.com/tomhea/fji-cpp">fji-cpp</a> - Faster C++ interpreter for FlipJump.</li>
</ul>
</article></div></div>
  </body>
</html>
