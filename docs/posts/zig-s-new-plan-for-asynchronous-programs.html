<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/SubscriberLink/1046084/4c048ee008e1c70e/">Original</a>
    <h1>Zig&#39;s new plan for asynchronous programs</h1>
    
    <div id="readability-page-1" class="page"><div>

<p>
The designers of the
<a href="https://ziglang.org/">
Zig programming language</a> have been working to find a
suitable design for asynchronous code for some time.
Zig is a carefully minimalist language, and its
<a href="https://ziglang.org/documentation/0.5.0/#Async-Functions">
initial design</a> for
asynchronous I/O did not fit well with its other
features. Now, the project has
<a href="https://zig.show/episodes/41/">
announced</a> (in a Zig SHOWTIME video) a new approach to asynchronous I/O that
promises to solve the
<a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">
function coloring</a> problem, and allows writing code that will execute
correctly using either synchronous or asynchronous I/O.
</p>

<p>
In many languages (including Python, JavaScript, and Rust), asynchronous code
uses special syntax. This can make it difficult to reuse code between
synchronous and asynchronous parts of a program, introducing a number of headaches for
library authors. Languages that don&#39;t make a syntactical distinction (such as
Haskell) essentially solve the problem by making everything asynchronous, which
typically requires the language&#39;s runtime to bake in ideas about how programs
are allowed to execute.
</p>

<p>
Neither of those options was deemed suitable for Zig. Its designers wanted to
find an approach that did not add too much complexity to the language, that
still permitted fine control over asynchronous operations, and that still made
it relatively painless to actually write high-performance event-driven I/O. The
new approach solves this by hiding asynchronous operations behind a new generic
interface,
<a href="https://ziglang.org/documentation/master/std/#std.Io">
<tt>Io</tt></a>.
</p>

<blockquote>
<b>No AI slop, all substance: subscribe to LWN today</b>
<p>
LWN has always been about quality over quantity; we need your help
to continue publishing in-depth, reader-focused articles about Linux
and the free-software community. Please subscribe today to support our work
and keep LWN on the air; we are offering <a href="https://lwn.net/Promo/no-slop/claim">a free one-month trial subscription</a> to get you started.
</p></blockquote>
<p>
Any function that needs to perform an I/O operation will need to have access to
an instance of the interface. Typically, that is provided by passing the
instance to the function as a parameter, similar to Zig&#39;s
<a href="https://ziglang.org/documentation/master/std/#std.mem.Allocator">
<tt>Allocator</tt></a>
interface for memory allocation. The standard library will include two built-in
implementations of the interface: <tt>Io.Threaded</tt> and <tt>Io.Evented</tt>.
The former uses synchronous
operations except where explicitly asked to run things in parallel (with a
special function; see below), in which
case it uses threads. The latter (which is still a work-in-progress) uses an
event loop and asynchronous I/O. Nothing in the design prevents a Zig programmer
from implementing their own version, however, so Zig&#39;s users retain their fine
control over how their programs execute.
</p>

<p>
Loris Cro, one of Zig&#39;s community organizers,
wrote <a href="https://kristoff.it/blog/zig-new-async-io/">
an explanation</a> of the new behavior to justify the approach.
Synchronous code is not much changed,
other than using the standard library functions that have moved under
<tt>Io</tt>, he explained. Functions like the example below, which don&#39;t involve explicit
asynchronicity, will continue to work. This example creates a file, sets the
file to close at the end of the function, and then writes a buffer of data to
the file. It uses Zig&#39;s <tt>try</tt> keyword to handle errors, and
<tt>defer</tt> to ensure the file is closed. The return type, <tt>!void</tt>,
indicates that it could return an error, but doesn&#39;t return any data:
</p>

<pre>    const std = @import(&#34;std&#34;);
    const Io = std.Io;

    fn saveFile(io: Io, data: []const u8, name: []const u8) !void {
        const file = try Io.Dir.cwd().createFile(io, name, .{});
        defer file.close(io);
        try file.writeAll(io, data);
    }
</pre>

<p>
If this function is given an instance of <tt>Io.Threaded</tt>, it will create
the file, write data to it, and then close it using ordinary system calls. If it
is given an instance of <tt>Io.Evented</tt>, it will instead use
<a href="https://man7.org/linux/man-pages/man7/io_uring.7.html">
io_uring</a>,
<a href="https://en.wikipedia.org/wiki/Kqueue">
kqueue</a>, or some other asynchronous backend suitable to the target operating
system. In doing so, it might pause the current execution and go work on a
different asynchronous function.
Either way, the operation is guaranteed to be complete by the time
<tt>writeAll()</tt> returns.
A library author writing a function that involves I/O doesn&#39;t need to
care about which of these things the ultimate user of the library chooses to do.
</p>

<p>
On the other hand, suppose that a program wanted to save two files. These
operations could profitably be done in parallel. If a library author wanted to
enable that, they could use the <tt>Io</tt> interface&#39;s <tt>async()</tt>
function to express that it does not matter which order the two files are saved in:
</p>

<pre>    fn saveData(io: Io, data: []const u8) !void {
        // Calls saveFile(io, data, &#34;saveA.txt&#34;)
        var a_future = io.async(saveFile, .{io, data, &#34;saveA.txt&#34;});
        var b_future = io.async(saveFile, .{io, data, &#34;saveB.txt&#34;});

        const a_result = a_future.await(io);
        const b_result = b_future.await(io);

        try a_result;
        try b_result;

        const out: Io.File = .stdout();
        try out.writeAll(io, &#34;save complete&#34;);
    }
</pre>

<p>
When using an <tt>Io.Threaded</tt> instance, the <tt>async()</tt> function
<s>doesn&#39;t actually</s> isn&#39;t actually required to do anything asynchronously [although the actual implementation may dispatch the function to a separate thread, depending on how it was configured] — it can just run the provided function
right away. So, with that version of the interface, the function first saves
file A and then file B. With an <tt>Io.Evented</tt> instance, the operations are
actually asynchronous, and the program can save both files at once.
</p>

<p>
The real advantage of this approach is that it turns asynchronous code into a
performance optimization. The first version of a program or library can write
normal straight-line code. Later, if asynchronicity proves to be useful for
performance, the author can come back and write it using asynchronous
operations. If the ultimate user of the function has not enabled asynchronous
execution, nothing changes. If they have, though, the function becomes faster
transparently — nothing about the function signature or how it interacts with
the rest of the code base changes.
</p>

<p>
One problem, however, is with programs where two parts are actually required to
execute simultaneously for correctness. For example, suppose that a program
wants to listen for connections on a port and simultaneously respond to user
input. In that scenario, it wouldn&#39;t be correct to wait for a connection and
only then ask for user input. For that use case, the <tt>Io</tt> interface
provides a separate function, <s><tt>asyncConcurrent()</tt></s><tt>concurrent()</tt> [this function was renamed during development; <tt>concurrent()</tt> is the most recent name] that explicitly asks for
the provided function to be run in parallel. <tt>Io.Threaded</tt> uses a thread
in a thread pool to accomplish this. <tt>Io.Evented</tt> treats it exactly the
same as a normal call to <tt>async()</tt>.
</p>

<pre>    const socket = try openServerSocket(io);
    var server = try io.concurrent(startAccepting, .{io, socket});
    defer server.cancel(io) catch {};

    try handleUserInput(io);
</pre>

<p>
If the programmer uses <tt>async()</tt> where they should have used
<tt>concurrent()</tt>, that is a bug. Zig&#39;s new model does not (and cannot)
prevent programmers from writing incorrect code, so there are still some
subtleties to keep in mind when adapting existing Zig code to use the new
interface.
</p>

<p>
The style of code that results from this design is a bit more verbose than
languages that give asynchronous functions special syntax, but Andrew Kelley,
creator of the language, <a href="https://ziglang.org/devlog/2025/#2025-10-15">said</a> that &#34;<q>it reads
like standard, idiomatic Zig code.</q>&#34; In particular, he noted that this
approach lets the programmer use all of Zig&#39;s typical control-flow primitives,
such as <tt>try</tt> and <tt>defer</tt>; it doesn&#39;t introduce any new language
features specific to asynchronous code.
</p>

<p>
To demonstrate this,
Kelley gave an example of using the new interface to implement asynchronous DNS
resolution. The standard
<a href="https://www.man7.org/linux/man-pages/man3/getaddrinfo.3.html">
<tt>getaddrinfo()</tt></a>
function for querying DNS information falls short because, although it makes
requests to multiple servers (for IPv4 and IPv6) in parallel, it waits for all of the queries to
complete before returning an answer. Kelley&#39;s example Zig code returns the first
successful answer, canceling the other inflight requests.
</p>

<p>
Asynchronous I/O in Zig is far from done, however. <tt>Io.Evented</tt> is still experimental, and
doesn&#39;t have implementations for all supported operating systems yet. A third
kind of <tt>Io</tt>, one that is compatible with WebAssembly, is
<a href="https://github.com/ziglang/zig/issues/23446">planned</a> (although, as
that issue details, implementing it depends on some other new language
features). The original
<a href="https://github.com/ziglang/zig/pull/25592">pull request for <tt>Io</tt></a> lists 24
planned follow-up items, most of which still need work.
</p>

<p>
Still, the overall design of asynchronous code in Zig appears to be set. Zig has
not yet had its 1.0 release, because the community is still experimenting with
the correct way to implement many features. Asynchronous I/O was one of the
larger remaining priorities (along with native code generation, which was also
enabled by default for debug builds on some architectures this year). Zig seems
to be steadily working its way toward a finished design — which should decrease
the number of times Zig programmers are asked to rewrite their I/O because the
interface has changed
<a href="https://ziglang.org/download/0.15.1/release-notes.html#Writergate">
again</a>.
</p></div></div>
  </body>
</html>
