<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://secret.club/2022/05/11/fuzzing-solana.html">Original</a>
    <h1>Earn $200K by fuzzing for a weekend: Part 1</h1>
    
    <div id="readability-page-1" class="page"><p>If youâ€™re not familiar with llvm coverage output, the first column is the line number, the second column is the number of times that that particular line was hit, and the third column is the code itself.</p><div><div><pre><code><span>&lt;</span><span>solana_rbpf</span>::<span>vm</span>::EbpfVm<span>&lt;</span><span>solana_rbpf</span>::<span>user_error</span>::UserError, <span>solana_rbpf</span>::<span>vm</span>::TestInstructionMeter<span>&gt;&gt;</span>::execute_program_interpreted_inner:
  <span>709</span>|    <span>763</span>|    <span>fn</span> execute_program_interpreted_inner(
  <span>710</span>|    <span>763</span>|        <span>&amp;</span><span>mut</span> <span>self</span>,
  <span>711</span>|    <span>763</span>|        instruction_meter: <span>&amp;</span><span>mut</span> I,
  <span>712</span>|    <span>763</span>|        initial_insn_count: <span>u64</span>,
  <span>713</span>|    <span>763</span>|        last_insn_count: <span>&amp;</span><span>mut</span> <span>u64</span>,
  <span>714</span>|    <span>763</span>|    ) <span>-&gt;</span> ProgramResult<span>&lt;</span>E<span>&gt;</span> {
  <span>715</span>|    <span>763</span>|        <span>// R1 points to beginning of input memory, R10 to the stack of the first frame</span>
  <span>716</span>|    <span>763</span>|        <span>let</span> <span>mut</span> reg: [<span>u64</span>; <span>11</span>] <span>=</span> [<span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>0</span>, <span>self</span><span>.stack</span>.get_frame_ptr()];
  <span>717</span>|    <span>763</span>|        reg[<span>1</span>] <span>=</span> <span>ebpf</span>::MM_INPUT_START;
  <span>718</span>|    <span>763</span>|
  <span>719</span>|    <span>763</span>|        <span>// Loop on instructions</span>
  <span>720</span>|    <span>763</span>|        <span>let</span> config <span>=</span> <span>self</span><span>.executable</span>.get_config();
  <span>721</span>|    <span>763</span>|        <span>let</span> <span>mut</span> next_pc: <span>usize</span> <span>=</span> <span>self</span><span>.executable</span>.get_entrypoint_instruction_offset()<span>?</span>;
                                                                                                  <span>^</span><span>0</span>
  <span>722</span>|    <span>763</span>|        <span>let</span> <span>mut</span> remaining_insn_count <span>=</span> initial_insn_count;
  <span>723</span>|   <span>136</span>k|        <span>while</span> (next_pc <span>+</span> <span>1</span>) <span>*</span> <span>ebpf</span>::INSN_SIZE <span>&lt;=</span> <span>self</span><span>.program</span>.len() {
  <span>724</span>|   <span>135</span>k|            <span>*</span>last_insn_count <span>+=</span> <span>1</span>;
  <span>725</span>|   <span>135</span>k|            <span>let</span> pc <span>=</span> next_pc;
  <span>726</span>|   <span>135</span>k|            next_pc <span>+=</span> <span>1</span>;
  <span>727</span>|   <span>135</span>k|            <span>let</span> <span>mut</span> instruction_width <span>=</span> <span>1</span>;
  <span>728</span>|   <span>135</span>k|            <span>let</span> <span>mut</span> insn <span>=</span> <span>ebpf</span>::get_insn_unchecked(<span>self</span><span>.program</span>, pc);
  <span>729</span>|   <span>135</span>k|            <span>let</span> dst <span>=</span> insn<span>.dst</span> <span>as</span> <span>usize</span>;
  <span>730</span>|   <span>135</span>k|            <span>let</span> src <span>=</span> insn<span>.src</span> <span>as</span> <span>usize</span>;
  <span>731</span>|   <span>135</span>k|
  <span>732</span>|   <span>135</span>k|            <span>if</span> config<span>.enable_instruction_tracing</span> {
  <span>733</span>|      <span>0</span>|                <span>let</span> <span>mut</span> state <span>=</span> [<span>0u64</span>; <span>12</span>];
  <span>734</span>|      <span>0</span>|                state[<span>0</span><span>..</span><span>11</span>].copy_from_slice(<span>&amp;</span>reg);
  <span>735</span>|      <span>0</span>|                state[<span>11</span>] <span>=</span> pc <span>as</span> <span>u64</span>;
  <span>736</span>|      <span>0</span>|                <span>self</span><span>.tracer</span>.trace(state);
  <span>737</span>|   <span>135</span>k|            }
  <span>738</span>|       |
  <span>739</span>|   <span>135</span>k|            <span>match</span> insn<span>.opc</span> {
  <span>740</span>|   <span>135</span>k|                <span>_</span> <span>if</span> dst <span>==</span> STACK_PTR_REG <span>&amp;&amp;</span> config<span>.dynamic_stack_frames</span> <span>=&gt;</span> {
  <span>741</span>|    <span>361</span>|                    <span>match</span> insn<span>.opc</span> {
  <span>742</span>|     <span>16</span>|                        <span>ebpf</span>::SUB64_IMM <span>=&gt;</span> <span>self</span><span>.stack</span>.resize_stack(<span>-</span>insn<span>.imm</span>),
  <span>743</span>|    <span>345</span>|                        <span>ebpf</span>::ADD64_IMM <span>=&gt;</span> <span>self</span><span>.stack</span>.resize_stack(insn<span>.imm</span>),
  <span>744</span>|       |                        <span>_</span> <span>=&gt;</span> {
  <span>745</span>|       |                            <span>#[cfg(debug_assertions)]</span>
  <span>746</span>|      <span>0</span>|                            <span>unreachable!</span>(<span>&#34;unexpected insn on r11&#34;</span>)
  <span>747</span>|       |                        }
  <span>748</span>|       |                    }
  <span>749</span>|       |                }
  <span>750</span>|       |
  <span>751</span>|       |                <span>// BPF_LD class</span>
  <span>752</span>|       |                <span>// Since this pointer is constant, and since we already know it (ebpf::MM_INPUT_START), do not</span>
  <span>753</span>|       |                <span>// bother re-fetching it, just use ebpf::MM_INPUT_START already.</span>
  <span>754</span>|       |                <span>ebpf</span>::LD_ABS_B   <span>=&gt;</span> {
  <span>755</span>|      <span>3</span>|                    <span>let</span> vm_addr <span>=</span> <span>ebpf</span>::MM_INPUT_START.wrapping_add(insn<span>.imm</span> <span>as</span> <span>u32</span> <span>as</span> <span>u64</span>);
  <span>756</span>|      <span>3</span>|                    <span>let</span> host_ptr <span>=</span> <span>translate_memory_access!</span>(<span>self</span>, vm_addr, <span>AccessType</span>::Load, pc, <span>u8</span>);
                                      <span>^</span><span>0</span>
  <span>757</span>|      <span>0</span>|                    reg[<span>0</span>] <span>=</span> <span>unsafe</span> { <span>*</span>host_ptr <span>as</span> <span>u64</span> };
  <span>758</span>|       |                },
  <span>759</span>|       |                <span>ebpf</span>::LD_ABS_H   <span>=&gt;</span>  {
  <span>760</span>|      <span>3</span>|                    <span>let</span> vm_addr <span>=</span> <span>ebpf</span>::MM_INPUT_START.wrapping_add(insn<span>.imm</span> <span>as</span> <span>u32</span> <span>as</span> <span>u64</span>);
  <span>761</span>|      <span>3</span>|                    <span>let</span> host_ptr <span>=</span> <span>translate_memory_access!</span>(<span>self</span>, vm_addr, <span>AccessType</span>::Load, pc, <span>u16</span>);
                                      <span>^</span><span>0</span>
  <span>762</span>|      <span>0</span>|                    reg[<span>0</span>] <span>=</span> <span>unsafe</span> { <span>*</span>host_ptr <span>as</span> <span>u64</span> };
  <span>763</span>|       |                },
  <span>764</span>|       |                <span>ebpf</span>::LD_ABS_W   <span>=&gt;</span> {
  <span>765</span>|      <span>2</span>|                    <span>let</span> vm_addr <span>=</span> <span>ebpf</span>::MM_INPUT_START.wrapping_add(insn<span>.imm</span> <span>as</span> <span>u32</span> <span>as</span> <span>u64</span>);
  <span>766</span>|      <span>2</span>|                    <span>let</span> host_ptr <span>=</span> <span>translate_memory_access!</span>(<span>self</span>, vm_addr, <span>AccessType</span>::Load, pc, <span>u32</span>);
                                      <span>^</span><span>0</span>
  <span>767</span>|      <span>0</span>|                    reg[<span>0</span>] <span>=</span> <span>unsafe</span> { <span>*</span>host_ptr <span>as</span> <span>u64</span> };
  <span>768</span>|       |                },
  <span>769</span>|       |                <span>ebpf</span>::LD_ABS_DW  <span>=&gt;</span> {
  <span>770</span>|      <span>4</span>|                    <span>let</span> vm_addr <span>=</span> <span>ebpf</span>::MM_INPUT_START.wrapping_add(insn<span>.imm</span> <span>as</span> <span>u32</span> <span>as</span> <span>u64</span>);
  <span>771</span>|      <span>4</span>|                    <span>let</span> host_ptr <span>=</span> <span>translate_memory_access!</span>(<span>self</span>, vm_addr, <span>AccessType</span>::Load, pc, <span>u64</span>);
                                      <span>^</span><span>0</span>
  <span>772</span>|      <span>0</span>|                    reg[<span>0</span>] <span>=</span> <span>unsafe</span> { <span>*</span>host_ptr <span>as</span> <span>u64</span> };
  <span>773</span>|       |                },
  <span>774</span>|       |                <span>ebpf</span>::LD_IND_B   <span>=&gt;</span> {
  <span>775</span>|      <span>2</span>|                    <span>let</span> vm_addr <span>=</span> <span>ebpf</span>::MM_INPUT_START.wrapping_add(reg[src]).wrapping_add(insn<span>.imm</span> <span>as</span> <span>u32</span> <span>as</span> <span>u64</span>);
  <span>776</span>|      <span>2</span>|                    <span>let</span> host_ptr <span>=</span> <span>translate_memory_access!</span>(<span>self</span>, vm_addr, <span>AccessType</span>::Load, pc, <span>u8</span>);
                                      <span>^</span><span>0</span>
  <span>777</span>|      <span>0</span>|                    reg[<span>0</span>] <span>=</span> <span>unsafe</span> { <span>*</span>host_ptr <span>as</span> <span>u64</span> };
  <span>778</span>|       |                },
  <span>779</span>|       |                <span>ebpf</span>::LD_IND_H   <span>=&gt;</span> {
  <span>780</span>|      <span>3</span>|                    <span>let</span> vm_addr <span>=</span> <span>ebpf</span>::MM_INPUT_START.wrapping_add(reg[src]).wrapping_add(insn<span>.imm</span> <span>as</span> <span>u32</span> <span>as</span> <span>u64</span>);
  <span>781</span>|      <span>3</span>|                    <span>let</span> host_ptr <span>=</span> <span>translate_memory_access!</span>(<span>self</span>, vm_addr, <span>AccessType</span>::Load, pc, <span>u16</span>);
                                      <span>^</span><span>0</span>
  <span>782</span>|      <span>0</span>|                    reg[<span>0</span>] <span>=</span> <span>unsafe</span> { <span>*</span>host_ptr <span>as</span> <span>u64</span> };
  <span>783</span>|       |                },
  <span>784</span>|       |                <span>ebpf</span>::LD_IND_W   <span>=&gt;</span> {
  <span>785</span>|      <span>7</span>|                    <span>let</span> vm_addr <span>=</span> <span>ebpf</span>::MM_INPUT_START.wrapping_add(reg[src]).wrapping_add(insn<span>.imm</span> <span>as</span> <span>u32</span> <span>as</span> <span>u64</span>);
  <span>786</span>|      <span>7</span>|                    <span>let</span> host_ptr <span>=</span> <span>translate_memory_access!</span>(<span>self</span>, vm_addr, <span>AccessType</span>::Load, pc, <span>u32</span>);
                                      <span>^</span><span>0</span>
  <span>787</span>|      <span>0</span>|                    reg[<span>0</span>] <span>=</span> <span>unsafe</span> { <span>*</span>host_ptr <span>as</span> <span>u64</span> };
  <span>788</span>|       |                },
  <span>789</span>|       |                <span>ebpf</span>::LD_IND_DW  <span>=&gt;</span> {
  <span>790</span>|      <span>3</span>|                    <span>let</span> vm_addr <span>=</span> <span>ebpf</span>::MM_INPUT_START.wrapping_add(reg[src]).wrapping_add(insn<span>.imm</span> <span>as</span> <span>u32</span> <span>as</span> <span>u64</span>);
  <span>791</span>|      <span>3</span>|                    <span>let</span> host_ptr <span>=</span> <span>translate_memory_access!</span>(<span>self</span>, vm_addr, <span>AccessType</span>::Load, pc, <span>u64</span>);
                                      <span>^</span><span>0</span>
  <span>792</span>|      <span>0</span>|                    reg[<span>0</span>] <span>=</span> <span>unsafe</span> { <span>*</span>host_ptr <span>as</span> <span>u64</span> };
  <span>793</span>|       |                },
  <span>794</span>|       |
  <span>795</span>|      <span>0</span>|                <span>ebpf</span>::LD_DW_IMM  <span>=&gt;</span> {
  <span>796</span>|      <span>0</span>|                    <span>ebpf</span>::augment_lddw_unchecked(<span>self</span><span>.program</span>, <span>&amp;</span><span>mut</span> insn);
  <span>797</span>|      <span>0</span>|                    instruction_width <span>=</span> <span>2</span>;
  <span>798</span>|      <span>0</span>|                    next_pc <span>+=</span> <span>1</span>;
  <span>799</span>|      <span>0</span>|                    reg[dst] <span>=</span> insn<span>.imm</span> <span>as</span> <span>u64</span>;
  <span>800</span>|      <span>0</span>|                },
  <span>801</span>|       |
  <span>802</span>|       |                <span>// BPF_LDX class</span>
  <span>803</span>|       |                <span>ebpf</span>::LD_B_REG   <span>=&gt;</span> {
  <span>804</span>|     <span>18</span>|                    <span>let</span> vm_addr <span>=</span> (reg[src] <span>as</span> <span>i64</span>).wrapping_add(insn<span>.off</span> <span>as</span> <span>i64</span>) <span>as</span> <span>u64</span>;
  <span>805</span>|     <span>18</span>|                    <span>let</span> host_ptr <span>=</span> <span>translate_memory_access!</span>(<span>self</span>, vm_addr, <span>AccessType</span>::Load, pc, <span>u8</span>);
                                      <span>^</span><span>2</span>
  <span>806</span>|      <span>2</span>|                    reg[dst] <span>=</span> <span>unsafe</span> { <span>*</span>host_ptr <span>as</span> <span>u64</span> };
  <span>807</span>|       |                },
  <span>808</span>|       |                <span>ebpf</span>::LD_H_REG   <span>=&gt;</span> {
  <span>809</span>|     <span>18</span>|                    <span>let</span> vm_addr <span>=</span> (reg[src] <span>as</span> <span>i64</span>).wrapping_add(insn<span>.off</span> <span>as</span> <span>i64</span>) <span>as</span> <span>u64</span>;
  <span>810</span>|     <span>18</span>|                    <span>let</span> host_ptr <span>=</span> <span>translate_memory_access!</span>(<span>self</span>, vm_addr, <span>AccessType</span>::Load, pc, <span>u16</span>);
                                      <span>^</span><span>6</span>
  <span>811</span>|      <span>6</span>|                    reg[dst] <span>=</span> <span>unsafe</span> { <span>*</span>host_ptr <span>as</span> <span>u64</span> };
  <span>812</span>|       |                },
  <span>813</span>|       |                <span>ebpf</span>::LD_W_REG   <span>=&gt;</span> {
  <span>814</span>|    <span>365</span>|                    <span>let</span> vm_addr <span>=</span> (reg[src] <span>as</span> <span>i64</span>).wrapping_add(insn<span>.off</span> <span>as</span> <span>i64</span>) <span>as</span> <span>u64</span>;
  <span>815</span>|    <span>365</span>|                    <span>let</span> host_ptr <span>=</span> <span>translate_memory_access!</span>(<span>self</span>, vm_addr, <span>AccessType</span>::Load, pc, <span>u32</span>);
                                      <span>^</span><span>348</span>
  <span>816</span>|    <span>348</span>|                    reg[dst] <span>=</span> <span>unsafe</span> { <span>*</span>host_ptr <span>as</span> <span>u64</span> };
  <span>817</span>|       |                },
  <span>818</span>|       |                <span>ebpf</span>::LD_DW_REG  <span>=&gt;</span> {
  <span>819</span>|     <span>15</span>|                    <span>let</span> vm_addr <span>=</span> (reg[src] <span>as</span> <span>i64</span>).wrapping_add(insn<span>.off</span> <span>as</span> <span>i64</span>) <span>as</span> <span>u64</span>;
  <span>820</span>|     <span>15</span>|                    <span>let</span> host_ptr <span>=</span> <span>translate_memory_access!</span>(<span>self</span>, vm_addr, <span>AccessType</span>::Load, pc, <span>u64</span>);
                                      <span>^</span><span>5</span>
  <span>821</span>|      <span>5</span>|                    reg[dst] <span>=</span> <span>unsafe</span> { <span>*</span>host_ptr <span>as</span> <span>u64</span> };
  <span>822</span>|       |                },
  <span>823</span>|       |
  <span>824</span>|       |                <span>// BPF_ST class</span>
  <span>825</span>|       |                <span>ebpf</span>::ST_B_IMM   <span>=&gt;</span> {
  <span>826</span>|     <span>26</span>|                    <span>let</span> vm_addr <span>=</span> (reg[dst] <span>as</span> <span>i64</span>).wrapping_add( insn<span>.off</span> <span>as</span> <span>i64</span>) <span>as</span> <span>u64</span>;
  <span>827</span>|     <span>26</span>|                    <span>let</span> host_ptr <span>=</span> <span>translate_memory_access!</span>(<span>self</span>, vm_addr, <span>AccessType</span>::Store, pc, <span>u8</span>);
                                      <span>^</span><span>20</span>
  <span>828</span>|     <span>20</span>|                    <span>unsafe</span> { <span>*</span>host_ptr <span>=</span> insn<span>.imm</span> <span>as</span> <span>u8</span> };
  <span>829</span>|       |                },
  <span>830</span>|       |                <span>ebpf</span>::ST_H_IMM   <span>=&gt;</span> {
  <span>831</span>|     <span>23</span>|                    <span>let</span> vm_addr <span>=</span> (reg[dst] <span>as</span> <span>i64</span>).wrapping_add(insn<span>.off</span> <span>as</span> <span>i64</span>) <span>as</span> <span>u64</span>;
  <span>832</span>|     <span>23</span>|                    <span>let</span> host_ptr <span>=</span> <span>translate_memory_access!</span>(<span>self</span>, vm_addr, <span>AccessType</span>::Store, pc, <span>u16</span>);
                                      <span>^</span><span>13</span>
  <span>833</span>|     <span>13</span>|                    <span>unsafe</span> { <span>*</span>host_ptr <span>=</span> insn<span>.imm</span> <span>as</span> <span>u16</span> };
  <span>834</span>|       |                },
  <span>835</span>|       |                <span>ebpf</span>::ST_W_IMM   <span>=&gt;</span> {
  <span>836</span>|     <span>12</span>|                    <span>let</span> vm_addr <span>=</span> (reg[dst] <span>as</span> <span>i64</span>).wrapping_add(insn<span>.off</span> <span>as</span> <span>i64</span>) <span>as</span> <span>u64</span>;
  <span>837</span>|     <span>12</span>|                    <span>let</span> host_ptr <span>=</span> <span>translate_memory_access!</span>(<span>self</span>, vm_addr, <span>AccessType</span>::Store, pc, <span>u32</span>);
                                      <span>^</span><span>5</span>
  <span>838</span>|      <span>5</span>|                    <span>unsafe</span> { <span>*</span>host_ptr <span>=</span> insn<span>.imm</span> <span>as</span> <span>u32</span> };
  <span>839</span>|       |                },
  <span>840</span>|       |                <span>ebpf</span>::ST_DW_IMM  <span>=&gt;</span> {
  <span>841</span>|     <span>17</span>|                    <span>let</span> vm_addr <span>=</span> (reg[dst] <span>as</span> <span>i64</span>).wrapping_add(insn<span>.off</span> <span>as</span> <span>i64</span>) <span>as</span> <span>u64</span>;
  <span>842</span>|     <span>17</span>|                    <span>let</span> host_ptr <span>=</span> <span>translate_memory_access!</span>(<span>self</span>, vm_addr, <span>AccessType</span>::Store, pc, <span>u64</span>);
                                      <span>^</span><span>11</span>
  <span>843</span>|     <span>11</span>|                    <span>unsafe</span> { <span>*</span>host_ptr <span>=</span> insn<span>.imm</span> <span>as</span> <span>u64</span> };
  <span>844</span>|       |                },
  <span>845</span>|       |
  <span>846</span>|       |                <span>// BPF_STX class</span>
  <span>847</span>|       |                <span>ebpf</span>::ST_B_REG   <span>=&gt;</span> {
  <span>848</span>|     <span>17</span>|                    <span>let</span> vm_addr <span>=</span> (reg[dst] <span>as</span> <span>i64</span>).wrapping_add(insn<span>.off</span> <span>as</span> <span>i64</span>) <span>as</span> <span>u64</span>;
  <span>849</span>|     <span>17</span>|                    <span>let</span> host_ptr <span>=</span> <span>translate_memory_access!</span>(<span>self</span>, vm_addr, <span>AccessType</span>::Store, pc, <span>u8</span>);
                                      <span>^</span><span>3</span>
  <span>850</span>|      <span>3</span>|                    <span>unsafe</span> { <span>*</span>host_ptr <span>=</span> reg[src] <span>as</span> <span>u8</span> };
  <span>851</span>|       |                },
  <span>852</span>|       |                <span>ebpf</span>::ST_H_REG   <span>=&gt;</span> {
  <span>853</span>|     <span>13</span>|                    <span>let</span> vm_addr <span>=</span> (reg[dst] <span>as</span> <span>i64</span>).wrapping_add(insn<span>.off</span> <span>as</span> <span>i64</span>) <span>as</span> <span>u64</span>;
  <span>854</span>|     <span>13</span>|                    <span>let</span> host_ptr <span>=</span> <span>translate_memory_access!</span>(<span>self</span>, vm_addr, <span>AccessType</span>::Store, pc, <span>u16</span>);
                                      <span>^</span><span>3</span>
  <span>855</span>|      <span>3</span>|                    <span>unsafe</span> { <span>*</span>host_ptr <span>=</span> reg[src] <span>as</span> <span>u16</span> };
  <span>856</span>|       |                },
  <span>857</span>|       |                <span>ebpf</span>::ST_W_REG   <span>=&gt;</span> {
  <span>858</span>|     <span>19</span>|                    <span>let</span> vm_addr <span>=</span> (reg[dst] <span>as</span> <span>i64</span>).wrapping_add(insn<span>.off</span> <span>as</span> <span>i64</span>) <span>as</span> <span>u64</span>;
  <span>859</span>|     <span>19</span>|                    <span>let</span> host_ptr <span>=</span> <span>translate_memory_access!</span>(<span>self</span>, vm_addr, <span>AccessType</span>::Store, pc, <span>u32</span>);
                                      <span>^</span><span>7</span>
  <span>860</span>|      <span>7</span>|                    <span>unsafe</span> { <span>*</span>host_ptr <span>=</span> reg[src] <span>as</span> <span>u32</span> };
  <span>861</span>|       |                },
  <span>862</span>|       |                <span>ebpf</span>::ST_DW_REG  <span>=&gt;</span> {
  <span>863</span>|      <span>8</span>|                    <span>let</span> vm_addr <span>=</span> (reg[dst] <span>as</span> <span>i64</span>).wrapping_add(insn<span>.off</span> <span>as</span> <span>i64</span>) <span>as</span> <span>u64</span>;
  <span>864</span>|      <span>8</span>|                    <span>let</span> host_ptr <span>=</span> <span>translate_memory_access!</span>(<span>self</span>, vm_addr, <span>AccessType</span>::Store, pc, <span>u64</span>);
                                      <span>^</span><span>2</span>
  <span>865</span>|      <span>2</span>|                    <span>unsafe</span> { <span>*</span>host_ptr <span>=</span> reg[src] <span>as</span> <span>u64</span> };
  <span>866</span>|       |                },
  <span>867</span>|       |
  <span>868</span>|       |                <span>// BPF_ALU class</span>
  <span>869</span>|  <span>1.06</span>k|                <span>ebpf</span>::ADD32_IMM  <span>=&gt;</span> reg[dst] <span>=</span> (reg[dst] <span>as</span> <span>i32</span>).wrapping_add(insn<span>.imm</span> <span>as</span> <span>i32</span>)   <span>as</span> <span>u64</span>,
  <span>870</span>|    <span>695</span>|                <span>ebpf</span>::ADD32_REG  <span>=&gt;</span> reg[dst] <span>=</span> (reg[dst] <span>as</span> <span>i32</span>).wrapping_add(reg[src] <span>as</span> <span>i32</span>)   <span>as</span> <span>u64</span>,
  <span>871</span>|    <span>710</span>|                <span>ebpf</span>::SUB32_IMM  <span>=&gt;</span> reg[dst] <span>=</span> (reg[dst] <span>as</span> <span>i32</span>).wrapping_sub(insn<span>.imm</span> <span>as</span> <span>i32</span>)   <span>as</span> <span>u64</span>,
  <span>872</span>|    <span>345</span>|                <span>ebpf</span>::SUB32_REG  <span>=&gt;</span> reg[dst] <span>=</span> (reg[dst] <span>as</span> <span>i32</span>).wrapping_sub(reg[src] <span>as</span> <span>i32</span>)   <span>as</span> <span>u64</span>,
  <span>873</span>|  <span>1.03</span>k|                <span>ebpf</span>::MUL32_IMM  <span>=&gt;</span> reg[dst] <span>=</span> (reg[dst] <span>as</span> <span>i32</span>).wrapping_mul(insn<span>.imm</span> <span>as</span> <span>i32</span>)   <span>as</span> <span>u64</span>,
  <span>874</span>|  <span>2.07</span>k|                <span>ebpf</span>::MUL32_REG  <span>=&gt;</span> reg[dst] <span>=</span> (reg[dst] <span>as</span> <span>i32</span>).wrapping_mul(reg[src] <span>as</span> <span>i32</span>)   <span>as</span> <span>u64</span>,
  <span>875</span>|  <span>1.03</span>k|                <span>ebpf</span>::DIV32_IMM  <span>=&gt;</span> reg[dst] <span>=</span> (reg[dst] <span>as</span> <span>u32</span> <span>/</span> insn<span>.imm</span> <span>as</span> <span>u32</span>)               <span>as</span> <span>u64</span>,
  <span>876</span>|       |                <span>ebpf</span>::DIV32_REG  <span>=&gt;</span> {
  <span>877</span>|      <span>4</span>|                    <span>if</span> reg[src] <span>as</span> <span>u32</span> <span>==</span> <span>0</span> {
  <span>878</span>|      <span>2</span>|                        <span>return</span> Err(<span>EbpfError</span>::DivideByZero(pc <span>+</span> <span>ebpf</span>::ELF_INSN_DUMP_OFFSET));
  <span>879</span>|      <span>2</span>|                    }
  <span>880</span>|      <span>2</span>|                    reg[dst] <span>=</span> (reg[dst] <span>as</span> <span>u32</span> <span>/</span> reg[src] <span>as</span> <span>u32</span>) <span>as</span> <span>u64</span>;
  <span>881</span>|       |                },
  <span>882</span>|       |                <span>ebpf</span>::SDIV32_IMM  <span>=&gt;</span> {
  <span>883</span>|    <span>346</span>|                    <span>if</span> reg[dst] <span>as</span> <span>i32</span> <span>==</span> <span>i32</span>::MIN <span>&amp;&amp;</span> insn<span>.imm</span> <span>==</span> <span>-</span><span>1</span> {
                                                                    <span>^</span><span>0</span>
  <span>884</span>|      <span>0</span>|                        <span>return</span> Err(<span>EbpfError</span>::DivideOverflow(pc <span>+</span> <span>ebpf</span>::ELF_INSN_DUMP_OFFSET));
  <span>885</span>|    <span>346</span>|                    }
  <span>886</span>|    <span>346</span>|                    reg[dst] <span>=</span> (reg[dst] <span>as</span> <span>i32</span> <span>/</span> insn<span>.imm</span> <span>as</span> <span>i32</span>) <span>as</span> <span>u64</span>;
  <span>887</span>|       |                }
  <span>888</span>|       |                <span>ebpf</span>::SDIV32_REG  <span>=&gt;</span> {
  <span>889</span>|     <span>13</span>|                    <span>if</span> reg[src] <span>as</span> <span>i32</span> <span>==</span> <span>0</span> {
  <span>890</span>|      <span>2</span>|                        <span>return</span> Err(<span>EbpfError</span>::DivideByZero(pc <span>+</span> <span>ebpf</span>::ELF_INSN_DUMP_OFFSET));
  <span>891</span>|     <span>11</span>|                    }
  <span>892</span>|     <span>11</span>|                    <span>if</span> reg[dst] <span>as</span> <span>i32</span> <span>==</span> <span>i32</span>::MIN <span>&amp;&amp;</span> reg[src] <span>as</span> <span>i32</span> <span>==</span> <span>-</span><span>1</span> {
                                                                    <span>^</span><span>0</span>
  <span>893</span>|      <span>0</span>|                        <span>return</span> Err(<span>EbpfError</span>::DivideOverflow(pc <span>+</span> <span>ebpf</span>::ELF_INSN_DUMP_OFFSET));
  <span>894</span>|     <span>11</span>|                    }
  <span>895</span>|     <span>11</span>|                    reg[dst] <span>=</span> (reg[dst] <span>as</span> <span>i32</span> <span>/</span> reg[src] <span>as</span> <span>i32</span>) <span>as</span> <span>u64</span>;
  <span>896</span>|       |                },
  <span>897</span>|    <span>346</span>|                <span>ebpf</span>::OR32_IMM   <span>=&gt;</span>   reg[dst] <span>=</span> (reg[dst] <span>as</span> <span>u32</span>             | insn<span>.imm</span> <span>as</span> <span>u32</span>) <span>as</span> <span>u64</span>,
  <span>898</span>|    <span>351</span>|                <span>ebpf</span>::OR32_REG   <span>=&gt;</span>   reg[dst] <span>=</span> (reg[dst] <span>as</span> <span>u32</span>             | reg[src] <span>as</span> <span>u32</span>) <span>as</span> <span>u64</span>,
  <span>899</span>|    <span>345</span>|                <span>ebpf</span>::AND32_IMM  <span>=&gt;</span>   reg[dst] <span>=</span> (reg[dst] <span>as</span> <span>u32</span>             <span>&amp;</span> insn<span>.imm</span> <span>as</span> <span>u32</span>) <span>as</span> <span>u64</span>,
  <span>900</span>|  <span>1.03</span>k|                <span>ebpf</span>::AND32_REG  <span>=&gt;</span>   reg[dst] <span>=</span> (reg[dst] <span>as</span> <span>u32</span>             <span>&amp;</span> reg[src] <span>as</span> <span>u32</span>) <span>as</span> <span>u64</span>,
  <span>901</span>|      <span>0</span>|                <span>ebpf</span>::LSH32_IMM  <span>=&gt;</span>   reg[dst] <span>=</span> (reg[dst] <span>as</span> <span>u32</span>).wrapping_shl(insn<span>.imm</span> <span>as</span> <span>u32</span>) <span>as</span> <span>u64</span>,
  <span>902</span>|    <span>369</span>|                <span>ebpf</span>::LSH32_REG  <span>=&gt;</span>   reg[dst] <span>=</span> (reg[dst] <span>as</span> <span>u32</span>).wrapping_shl(reg[src] <span>as</span> <span>u32</span>) <span>as</span> <span>u64</span>,
  <span>903</span>|      <span>0</span>|                <span>ebpf</span>::RSH32_IMM  <span>=&gt;</span>   reg[dst] <span>=</span> (reg[dst] <span>as</span> <span>u32</span>).wrapping_shr(insn<span>.imm</span> <span>as</span> <span>u32</span>) <span>as</span> <span>u64</span>,
  <span>904</span>|    <span>346</span>|                <span>ebpf</span>::RSH32_REG  <span>=&gt;</span>   reg[dst] <span>=</span> (reg[dst] <span>as</span> <span>u32</span>).wrapping_shr(reg[src] <span>as</span> <span>u32</span>) <span>as</span> <span>u64</span>,
  <span>905</span>|    <span>690</span>|                <span>ebpf</span>::NEG32      <span>=&gt;</span> { reg[dst] <span>=</span> (reg[dst] <span>as</span> <span>i32</span>).wrapping_neg()                <span>as</span> <span>u64</span>; reg[dst] <span>&amp;=</span> <span>u32</span>::MAX <span>as</span> <span>u64</span>; },
  <span>906</span>|    <span>347</span>|                <span>ebpf</span>::MOD32_IMM  <span>=&gt;</span>   reg[dst] <span>=</span> (reg[dst] <span>as</span> <span>u32</span>             <span>%</span> insn<span>.imm</span> <span>as</span> <span>u32</span>) <span>as</span> <span>u64</span>,
  <span>907</span>|       |                <span>ebpf</span>::MOD32_REG  <span>=&gt;</span> {
  <span>908</span>|      <span>4</span>|                    <span>if</span> reg[src] <span>as</span> <span>u32</span> <span>==</span> <span>0</span> {
  <span>909</span>|      <span>2</span>|                        <span>return</span> Err(<span>EbpfError</span>::DivideByZero(pc <span>+</span> <span>ebpf</span>::ELF_INSN_DUMP_OFFSET));
  <span>910</span>|      <span>2</span>|                    }
  <span>911</span>|      <span>2</span>|                                      reg[dst] <span>=</span> (reg[dst] <span>as</span> <span>u32</span>            <span>%</span> reg[src]  <span>as</span> <span>u32</span>) <span>as</span> <span>u64</span>;
  <span>912</span>|       |                },
  <span>913</span>|  <span>1.04</span>k|                <span>ebpf</span>::XOR32_IMM  <span>=&gt;</span>   reg[dst] <span>=</span> (reg[dst] <span>as</span> <span>u32</span>            <span>^</span> insn<span>.imm</span>  <span>as</span> <span>u32</span>) <span>as</span> <span>u64</span>,
  <span>914</span>|  <span>2.74</span>k|                <span>ebpf</span>::XOR32_REG  <span>=&gt;</span>   reg[dst] <span>=</span> (reg[dst] <span>as</span> <span>u32</span>            <span>^</span> reg[src]  <span>as</span> <span>u32</span>) <span>as</span> <span>u64</span>,
  <span>915</span>|    <span>349</span>|                <span>ebpf</span>::MOV32_IMM  <span>=&gt;</span>   reg[dst] <span>=</span> insn<span>.imm</span>  <span>as</span> <span>u32</span>                                <span>as</span> <span>u64</span>,
  <span>916</span>|  <span>1.03</span>k|                <span>ebpf</span>::MOV32_REG  <span>=&gt;</span>   reg[dst] <span>=</span> (reg[src] <span>as</span> <span>u32</span>)                               <span>as</span> <span>u64</span>,
  <span>917</span>|      <span>0</span>|                <span>ebpf</span>::ARSH32_IMM <span>=&gt;</span> { reg[dst] <span>=</span> (reg[dst] <span>as</span> <span>i32</span>).wrapping_shr(insn<span>.imm</span> <span>as</span> <span>u32</span>) <span>as</span> <span>u64</span>; reg[dst] <span>&amp;=</span> <span>u32</span>::MAX <span>as</span> <span>u64</span>; },
  <span>918</span>|      <span>2</span>|                <span>ebpf</span>::ARSH32_REG <span>=&gt;</span> { reg[dst] <span>=</span> (reg[dst] <span>as</span> <span>i32</span>).wrapping_shr(reg[src] <span>as</span> <span>u32</span>) <span>as</span> <span>u64</span>; reg[dst] <span>&amp;=</span> <span>u32</span>::MAX <span>as</span> <span>u64</span>; },
  <span>919</span>|      <span>0</span>|                <span>ebpf</span>::LE         <span>=&gt;</span> {
  <span>920</span>|      <span>0</span>|                    reg[dst] <span>=</span> <span>match</span> insn<span>.imm</span> {
  <span>921</span>|      <span>0</span>|                        <span>16</span> <span>=&gt;</span> (reg[dst] <span>as</span> <span>u16</span>).to_le() <span>as</span> <span>u64</span>,
  <span>922</span>|      <span>0</span>|                        <span>32</span> <span>=&gt;</span> (reg[dst] <span>as</span> <span>u32</span>).to_le() <span>as</span> <span>u64</span>,
  <span>923</span>|      <span>0</span>|                        <span>64</span> <span>=&gt;</span>  reg[dst].to_le(),
  <span>924</span>|       |                        <span>_</span>  <span>=&gt;</span> {
  <span>925</span>|      <span>0</span>|                            <span>return</span> Err(<span>EbpfError</span>::InvalidInstruction(pc <span>+</span> <span>ebpf</span>::ELF_INSN_DUMP_OFFSET));
  <span>926</span>|       |                        }
  <span>927</span>|       |                    };
  <span>928</span>|       |                },
  <span>929</span>|      <span>0</span>|                <span>ebpf</span>::BE         <span>=&gt;</span> {
  <span>930</span>|      <span>0</span>|                    reg[dst] <span>=</span> <span>match</span> insn<span>.imm</span> {
  <span>931</span>|      <span>0</span>|                        <span>16</span> <span>=&gt;</span> (reg[dst] <span>as</span> <span>u16</span>).to_be() <span>as</span> <span>u64</span>,
  <span>932</span>|      <span>0</span>|                        <span>32</span> <span>=&gt;</span> (reg[dst] <span>as</span> <span>u32</span>).to_be() <span>as</span> <span>u64</span>,
  <span>933</span>|      <span>0</span>|                        <span>64</span> <span>=&gt;</span>  reg[dst].to_be(),
  <span>934</span>|       |                        <span>_</span>  <span>=&gt;</span> {
  <span>935</span>|      <span>0</span>|                            <span>return</span> Err(<span>EbpfError</span>::InvalidInstruction(pc <span>+</span> <span>ebpf</span>::ELF_INSN_DUMP_OFFSET));
  <span>936</span>|       |                        }
  <span>937</span>|       |                    };
  <span>938</span>|       |                },
  <span>939</span>|       |
  <span>940</span>|       |                <span>// BPF_ALU64 class</span>
  <span>941</span>|    <span>402</span>|                <span>ebpf</span>::ADD64_IMM  <span>=&gt;</span> reg[dst] <span>=</span> reg[dst].wrapping_add(insn<span>.imm</span> <span>as</span> <span>u64</span>),
  <span>942</span>|    <span>351</span>|                <span>ebpf</span>::ADD64_REG  <span>=&gt;</span> reg[dst] <span>=</span> reg[dst].wrapping_add(reg[src]),
  <span>943</span>|  <span>1.12</span>k|                <span>ebpf</span>::SUB64_IMM  <span>=&gt;</span> reg[dst] <span>=</span> reg[dst].wrapping_sub(insn<span>.imm</span> <span>as</span> <span>u64</span>),
  <span>944</span>|    <span>721</span>|                <span>ebpf</span>::SUB64_REG  <span>=&gt;</span> reg[dst] <span>=</span> reg[dst].wrapping_sub(reg[src]),
  <span>945</span>|  <span>3.06</span>k|                <span>ebpf</span>::MUL64_IMM  <span>=&gt;</span> reg[dst] <span>=</span> reg[dst].wrapping_mul(insn<span>.imm</span> <span>as</span> <span>u64</span>),
  <span>946</span>|  <span>1.71</span>k|                <span>ebpf</span>::MUL64_REG  <span>=&gt;</span> reg[dst] <span>=</span> reg[dst].wrapping_mul(reg[src]),
  <span>947</span>|  <span>1.39</span>k|                <span>ebpf</span>::DIV64_IMM  <span>=&gt;</span> reg[dst] <span>/=</span> insn<span>.imm</span> <span>as</span> <span>u64</span>,
  <span>948</span>|       |                <span>ebpf</span>::DIV64_REG  <span>=&gt;</span> {
  <span>949</span>|     <span>23</span>|                    <span>if</span> reg[src] <span>==</span> <span>0</span> {
  <span>950</span>|     <span>12</span>|                        <span>return</span> Err(<span>EbpfError</span>::DivideByZero(pc <span>+</span> <span>ebpf</span>::ELF_INSN_DUMP_OFFSET));
  <span>951</span>|     <span>11</span>|                    }
  <span>952</span>|     <span>11</span>|                                    reg[dst] <span>/=</span> reg[src];
  <span>953</span>|       |                },
  <span>954</span>|       |                <span>ebpf</span>::SDIV64_IMM  <span>=&gt;</span> {
  <span>955</span>|  <span>1.40</span>k|                    <span>if</span> reg[dst] <span>as</span> <span>i64</span> <span>==</span> <span>i64</span>::MIN <span>&amp;&amp;</span> insn<span>.imm</span> <span>==</span> <span>-</span><span>1</span> {
                                                                    <span>^</span><span>0</span>
  <span>956</span>|      <span>0</span>|                        <span>return</span> Err(<span>EbpfError</span>::DivideOverflow(pc <span>+</span> <span>ebpf</span>::ELF_INSN_DUMP_OFFSET));
  <span>957</span>|  <span>1.40</span>k|                    }
  <span>958</span>|  <span>1.40</span>k|
  <span>959</span>|  <span>1.40</span>k|                    reg[dst] <span>=</span> (reg[dst] <span>as</span> <span>i64</span> <span>/</span> insn<span>.imm</span>) <span>as</span> <span>u64</span>
  <span>960</span>|       |                }
  <span>961</span>|       |                <span>ebpf</span>::SDIV64_REG  <span>=&gt;</span> {
  <span>962</span>|     <span>12</span>|                    <span>if</span> reg[src] <span>==</span> <span>0</span> {
  <span>963</span>|      <span>5</span>|                        <span>return</span> Err(<span>EbpfError</span>::DivideByZero(pc <span>+</span> <span>ebpf</span>::ELF_INSN_DUMP_OFFSET));
  <span>964</span>|      <span>7</span>|                    }
  <span>965</span>|      <span>7</span>|                    <span>if</span> reg[dst] <span>as</span> <span>i64</span> <span>==</span> <span>i64</span>::MIN <span>&amp;&amp;</span> reg[src] <span>as</span> <span>i64</span> <span>==</span> <span>-</span><span>1</span> {
                                                                    <span>^</span><span>0</span>
  <span>966</span>|      <span>0</span>|                        <span>return</span> Err(<span>EbpfError</span>::DivideOverflow(pc <span>+</span> <span>ebpf</span>::ELF_INSN_DUMP_OFFSET));
  <span>967</span>|      <span>7</span>|                    }
  <span>968</span>|      <span>7</span>|                    reg[dst] <span>=</span> (reg[dst] <span>as</span> <span>i64</span> <span>/</span> reg[src] <span>as</span> <span>i64</span>) <span>as</span> <span>u64</span>;
  <span>969</span>|       |                },
  <span>970</span>|    <span>838</span>|                <span>ebpf</span>::OR64_IMM   <span>=&gt;</span> reg[dst] |<span>=</span>  insn<span>.imm</span> <span>as</span> <span>u64</span>,
  <span>971</span>|  <span>1.37</span>k|                <span>ebpf</span>::OR64_REG   <span>=&gt;</span> reg[dst] |<span>=</span>  reg[src],
  <span>972</span>|  <span>2.14</span>k|                <span>ebpf</span>::AND64_IMM  <span>=&gt;</span> reg[dst] <span>&amp;=</span>  insn<span>.imm</span> <span>as</span> <span>u64</span>,
  <span>973</span>|  <span>4.47</span>k|                <span>ebpf</span>::AND64_REG  <span>=&gt;</span> reg[dst] <span>&amp;=</span>  reg[src],
  <span>974</span>|      <span>0</span>|                <span>ebpf</span>::LSH64_IMM  <span>=&gt;</span> reg[dst] <span>=</span> reg[dst].wrapping_shl(insn<span>.imm</span> <span>as</span> <span>u32</span>),
  <span>975</span>|  <span>1.73</span>k|                <span>ebpf</span>::LSH64_REG  <span>=&gt;</span> reg[dst] <span>=</span> reg[dst].wrapping_shl(reg[src] <span>as</span> <span>u32</span>),
  <span>976</span>|      <span>0</span>|                <span>ebpf</span>::RSH64_IMM  <span>=&gt;</span> reg[dst] <span>=</span> reg[dst].wrapping_shr(insn<span>.imm</span> <span>as</span> <span>u32</span>),
  <span>977</span>|  <span>1.03</span>k|                <span>ebpf</span>::RSH64_REG  <span>=&gt;</span> reg[dst] <span>=</span> reg[dst].wrapping_shr(reg[src] <span>as</span> <span>u32</span>),
  <span>978</span>|  <span>5.59</span>k|                <span>ebpf</span>::NEG64      <span>=&gt;</span> reg[dst] <span>=</span> (reg[dst] <span>as</span> <span>i64</span>).wrapping_neg() <span>as</span> <span>u64</span>,
  <span>979</span>|  <span>2.85</span>k|                <span>ebpf</span>::MOD64_IMM  <span>=&gt;</span> reg[dst] <span>%=</span> insn<span>.imm</span>  <span>as</span> <span>u64</span>,
  <span>980</span>|       |                <span>ebpf</span>::MOD64_REG  <span>=&gt;</span> {
  <span>981</span>|      <span>3</span>|                    <span>if</span> reg[src] <span>==</span> <span>0</span> {
  <span>982</span>|      <span>2</span>|                        <span>return</span> Err(<span>EbpfError</span>::DivideByZero(pc <span>+</span> <span>ebpf</span>::ELF_INSN_DUMP_OFFSET));
  <span>983</span>|      <span>1</span>|                    }
  <span>984</span>|      <span>1</span>|                                    reg[dst] <span>%=</span> reg[src];
  <span>985</span>|       |                },
  <span>986</span>|  <span>2.28</span>k|                <span>ebpf</span>::XOR64_IMM  <span>=&gt;</span> reg[dst] <span>^=</span> insn<span>.imm</span> <span>as</span> <span>u64</span>,
  <span>987</span>|  <span>1.41</span>k|                <span>ebpf</span>::XOR64_REG  <span>=&gt;</span> reg[dst] <span>^=</span> reg[src],
  <span>988</span>|    <span>383</span>|                <span>ebpf</span>::MOV64_IMM  <span>=&gt;</span> reg[dst] <span>=</span>  insn<span>.imm</span> <span>as</span> <span>u64</span>,
  <span>989</span>|  <span>4.24</span>k|                <span>ebpf</span>::MOV64_REG  <span>=&gt;</span> reg[dst] <span>=</span>  reg[src],
  <span>990</span>|      <span>0</span>|                <span>ebpf</span>::ARSH64_IMM <span>=&gt;</span> reg[dst] <span>=</span> (reg[dst] <span>as</span> <span>i64</span>).wrapping_shr(insn<span>.imm</span> <span>as</span> <span>u32</span>) <span>as</span> <span>u64</span>,
  <span>991</span>|    <span>357</span>|                <span>ebpf</span>::ARSH64_REG <span>=&gt;</span> reg[dst] <span>=</span> (reg[dst] <span>as</span> <span>i64</span>).wrapping_shr(reg[src] <span>as</span> <span>u32</span>) <span>as</span> <span>u64</span>,
  <span>992</span>|       |
  <span>993</span>|       |                <span>// BPF_JMP class</span>
  <span>994</span>|  <span>4.43</span>k|                <span>ebpf</span>::JA         <span>=&gt;</span>                                          { next_pc <span>=</span> (next_pc <span>as</span> <span>isize</span> <span>+</span> insn<span>.off</span> <span>as</span> <span>isize</span>) <span>as</span> <span>usize</span>; },
  <span>995</span>|     <span>10</span>|                <span>ebpf</span>::JEQ_IMM    <span>=&gt;</span> <span>if</span>  reg[dst] <span>==</span> insn<span>.imm</span> <span>as</span> <span>u64</span>          { next_pc <span>=</span> (next_pc <span>as</span> <span>isize</span> <span>+</span> insn<span>.off</span> <span>as</span> <span>isize</span>) <span>as</span> <span>usize</span>; },
                                                                                           <span>^</span><span>0</span>
  <span>996</span>|  <span>1.36</span>k|                <span>ebpf</span>::JEQ_REG    <span>=&gt;</span> <span>if</span>  reg[dst] <span>==</span> reg[src]                 { next_pc <span>=</span> (next_pc <span>as</span> <span>isize</span> <span>+</span> insn<span>.off</span> <span>as</span> <span>isize</span>) <span>as</span> <span>usize</span>; },
                                                                                           <span>^</span><span>1.36</span>k                                                        <span>^</span><span>2</span>
  <span>997</span>|  <span>4.16</span>k|                <span>ebpf</span>::JGT_IMM    <span>=&gt;</span> <span>if</span>  reg[dst] <span>&gt;</span>  insn<span>.imm</span> <span>as</span> <span>u64</span>          { next_pc <span>=</span> (next_pc <span>as</span> <span>isize</span> <span>+</span> insn<span>.off</span> <span>as</span> <span>isize</span>) <span>as</span> <span>usize</span>; },
                                                                                           <span>^</span><span>1.42</span>k                                                        <span>^</span><span>2.74</span>k
  <span>998</span>|  <span>1.73</span>k|                <span>ebpf</span>::JGT_REG    <span>=&gt;</span> <span>if</span>  reg[dst] <span>&gt;</span>  reg[src]                 { next_pc <span>=</span> (next_pc <span>as</span> <span>isize</span> <span>+</span> insn<span>.off</span> <span>as</span> <span>isize</span>) <span>as</span> <span>usize</span>; },
                                                                                           <span>^</span><span>1.39</span>k                                                        <span>^</span><span>343</span>
  <span>999</span>|    <span>343</span>|                <span>ebpf</span>::JGE_IMM    <span>=&gt;</span> <span>if</span>  reg[dst] <span>&gt;=</span> insn<span>.imm</span> <span>as</span> <span>u64</span>          { next_pc <span>=</span> (next_pc <span>as</span> <span>isize</span> <span>+</span> insn<span>.off</span> <span>as</span> <span>isize</span>) <span>as</span> <span>usize</span>; },
                                                                                           <span>^</span><span>0</span>
 <span>1000</span>|  <span>2.04</span>k|                <span>ebpf</span>::JGE_REG    <span>=&gt;</span> <span>if</span>  reg[dst] <span>&gt;=</span> reg[src]                 { next_pc <span>=</span> (next_pc <span>as</span> <span>isize</span> <span>+</span> insn<span>.off</span> <span>as</span> <span>isize</span>) <span>as</span> <span>usize</span>; },
                                                                                           <span>^</span><span>1.70</span>k                                                        <span>^</span><span>342</span>
 <span>1001</span>|  <span>2.04</span>k|                <span>ebpf</span>::JLT_IMM    <span>=&gt;</span> <span>if</span>  reg[dst] <span>&lt;</span>  insn<span>.imm</span> <span>as</span> <span>u64</span>          { next_pc <span>=</span> (next_pc <span>as</span> <span>isize</span> <span>+</span> insn<span>.off</span> <span>as</span> <span>isize</span>) <span>as</span> <span>usize</span>; },
                                                                                           <span>^</span><span>2.04</span>k                                                        <span>^</span><span>1</span>
 <span>1002</span>|    <span>342</span>|                <span>ebpf</span>::JLT_REG    <span>=&gt;</span> <span>if</span>  reg[dst] <span>&lt;</span>  reg[src]                 { next_pc <span>=</span> (next_pc <span>as</span> <span>isize</span> <span>+</span> insn<span>.off</span> <span>as</span> <span>isize</span>) <span>as</span> <span>usize</span>; },
                                                                                           <span>^</span><span>0</span>
 <span>1003</span>|  <span>1.02</span>k|                <span>ebpf</span>::JLE_IMM    <span>=&gt;</span> <span>if</span>  reg[dst] <span>&lt;=</span> insn<span>.imm</span> <span>as</span> <span>u64</span>          { next_pc <span>=</span> (next_pc <span>as</span> <span>isize</span> <span>+</span> insn<span>.off</span> <span>as</span> <span>isize</span>) <span>as</span> <span>usize</span>; },
                                                                                                                                                         <span>^</span><span>0</span>
 <span>1004</span>|  <span>2.38</span>k|                <span>ebpf</span>::JLE_REG    <span>=&gt;</span> <span>if</span>  reg[dst] <span>&lt;=</span> reg[src]                 { next_pc <span>=</span> (next_pc <span>as</span> <span>isize</span> <span>+</span> insn<span>.off</span> <span>as</span> <span>isize</span>) <span>as</span> <span>usize</span>; },
                                                                                           <span>^</span><span>2.38</span>k                                                        <span>^</span><span>1</span>
 <span>1005</span>|  <span>1.76</span>k|                <span>ebpf</span>::JSET_IMM   <span>=&gt;</span> <span>if</span>  reg[dst] <span>&amp;</span>  insn<span>.imm</span> <span>as</span> <span>u64</span> <span>!=</span> <span>0</span>     { next_pc <span>=</span> (next_pc <span>as</span> <span>isize</span> <span>+</span> insn<span>.off</span> <span>as</span> <span>isize</span>) <span>as</span> <span>usize</span>; },
                                                                                           <span>^</span><span>1.42</span>k                                                        <span>^</span><span>347</span>
 <span>1006</span>|    <span>686</span>|                <span>ebpf</span>::JSET_REG   <span>=&gt;</span> <span>if</span>  reg[dst] <span>&amp;</span>  reg[src]        <span>!=</span> <span>0</span>     { next_pc <span>=</span> (next_pc <span>as</span> <span>isize</span> <span>+</span> insn<span>.off</span> <span>as</span> <span>isize</span>) <span>as</span> <span>usize</span>; },
                                                                                           <span>^</span><span>0</span>
 <span>1007</span>|  <span>6.48</span>k|                <span>ebpf</span>::JNE_IMM    <span>=&gt;</span> <span>if</span>  reg[dst] <span>!=</span> insn<span>.imm</span> <span>as</span> <span>u64</span>          { next_pc <span>=</span> (next_pc <span>as</span> <span>isize</span> <span>+</span> insn<span>.off</span> <span>as</span> <span>isize</span>) <span>as</span> <span>usize</span>; },
                                                                                                                                                         <span>^</span><span>0</span>
 <span>1008</span>|  <span>2.44</span>k|                <span>ebpf</span>::JNE_REG    <span>=&gt;</span> <span>if</span>  reg[dst] <span>!=</span> reg[src]                 { next_pc <span>=</span> (next_pc <span>as</span> <span>isize</span> <span>+</span> insn<span>.off</span> <span>as</span> <span>isize</span>) <span>as</span> <span>usize</span>; },
                                                                                           <span>^</span><span>1.40</span>k                                                        <span>^</span><span>1.03</span>k
 <span>1009</span>|  <span>18.1</span>k|                <span>ebpf</span>::JSGT_IMM   <span>=&gt;</span> <span>if</span>  reg[dst] <span>as</span> <span>i64</span> <span>&gt;</span>   insn<span>.imm</span>  <span>as</span> <span>i64</span> { next_pc <span>=</span> (next_pc <span>as</span> <span>isize</span> <span>+</span> insn<span>.off</span> <span>as</span> <span>isize</span>) <span>as</span> <span>usize</span>; },
                                                                                           <span>^</span><span>17.7</span>k                                                        <span>^</span><span>363</span>
 <span>1010</span>|  <span>2.08</span>k|                <span>ebpf</span>::JSGT_REG   <span>=&gt;</span> <span>if</span>  reg[dst] <span>as</span> <span>i64</span> <span>&gt;</span>   reg[src]  <span>as</span> <span>i64</span> { next_pc <span>=</span> (next_pc <span>as</span> <span>isize</span> <span>+</span> insn<span>.off</span> <span>as</span> <span>isize</span>) <span>as</span> <span>usize</span>; },
                                                                                           <span>^</span><span>2.07</span>k                                                        <span>^</span><span>12</span>
 <span>1011</span>|  <span>14.3</span>k|                <span>ebpf</span>::JSGE_IMM   <span>=&gt;</span> <span>if</span>  reg[dst] <span>as</span> <span>i64</span> <span>&gt;=</span>  insn<span>.imm</span>  <span>as</span> <span>i64</span> { next_pc <span>=</span> (next_pc <span>as</span> <span>isize</span> <span>+</span> insn<span>.off</span> <span>as</span> <span>isize</span>) <span>as</span> <span>usize</span>; },
                                                                                           <span>^</span><span>12.9</span>k                                                        <span>^</span><span>1.37</span>k
 <span>1012</span>|  <span>3.45</span>k|                <span>ebpf</span>::JSGE_REG   <span>=&gt;</span> <span>if</span>  reg[dst] <span>as</span> <span>i64</span> <span>&gt;=</span>  reg[src] <span>as</span> <span>i64</span>  { next_pc <span>=</span> (next_pc <span>as</span> <span>isize</span> <span>+</span> insn<span>.off</span> <span>as</span> <span>isize</span>) <span>as</span> <span>usize</span>; },
                                                                                           <span>^</span><span>3.44</span>k                                                        <span>^</span><span>12</span>
 <span>1013</span>|  <span>1.36</span>k|                <span>ebpf</span>::JSLT_IMM   <span>=&gt;</span> <span>if</span> (reg[dst] <span>as</span> <span>i64</span>) <span>&lt;</span>  insn<span>.imm</span>  <span>as</span> <span>i64</span> { next_pc <span>=</span> (next_pc <span>as</span> <span>isize</span> <span>+</span> insn<span>.off</span> <span>as</span> <span>isize</span>) <span>as</span> <span>usize</span>; },
                                                                                           <span>^</span><span>1.02</span>k                                                        <span>^</span><span>346</span>
 <span>1014</span>|      <span>2</span>|                <span>ebpf</span>::JSLT_REG   <span>=&gt;</span> <span>if</span> (reg[dst] <span>as</span> <span>i64</span>) <span>&lt;</span>  reg[src] <span>as</span> <span>i64</span>  { next_pc <span>=</span> (next_pc <span>as</span> <span>isize</span> <span>+</span> insn<span>.off</span> <span>as</span> <span>isize</span>) <span>as</span> <span>usize</span>; },
                                                                                           <span>^</span><span>0</span>
 <span>1015</span>|  <span>2.05</span>k|                <span>ebpf</span>::JSLE_IMM   <span>=&gt;</span> <span>if</span> (reg[dst] <span>as</span> <span>i64</span>) <span>&lt;=</span> insn<span>.imm</span>  <span>as</span> <span>i64</span> { next_pc <span>=</span> (next_pc <span>as</span> <span>isize</span> <span>+</span> insn<span>.off</span> <span>as</span> <span>isize</span>) <span>as</span> <span>usize</span>; },
                                                                                           <span>^</span><span>2.04</span>k                                                        <span>^</span><span>14</span>
 <span>1016</span>|  <span>6.83</span>k|                <span>ebpf</span>::JSLE_REG   <span>=&gt;</span> <span>if</span> (reg[dst] <span>as</span> <span>i64</span>) <span>&lt;=</span> reg[src] <span>as</span> <span>i64</span>  { next_pc <span>=</span> (next_pc <span>as</span> <span>isize</span> <span>+</span> insn<span>.off</span> <span>as</span> <span>isize</span>) <span>as</span> <span>usize</span>; },
                                                                                           <span>^</span><span>6.83</span>k                                                        <span>^</span><span>7</span>
 <span>1017</span>|       |
 <span>1018</span>|       |                <span>ebpf</span>::CALL_REG   <span>=&gt;</span> {
 <span>1019</span>|      <span>0</span>|                    <span>let</span> target_address <span>=</span> reg[insn<span>.imm</span> <span>as</span> <span>usize</span>];
 <span>1020</span>|      <span>0</span>|                    reg[<span>ebpf</span>::FRAME_PTR_REG] <span>=</span>
 <span>1021</span>|      <span>0</span>|                        <span>self</span><span>.stack</span>.push(<span>&amp;</span>reg[<span>ebpf</span>::FIRST_SCRATCH_REG<span>..</span><span>ebpf</span>::FIRST_SCRATCH_REG <span>+</span> <span>ebpf</span>::SCRATCH_REGS], next_pc)<span>?</span>;
 <span>1022</span>|      <span>0</span>|                    <span>if</span> target_address <span>&lt;</span> <span>self</span><span>.program_vm_addr</span> {
 <span>1023</span>|      <span>0</span>|                        <span>return</span> Err(<span>EbpfError</span>::CallOutsideTextSegment(pc <span>+</span> <span>ebpf</span>::ELF_INSN_DUMP_OFFSET, target_address <span>/</span> <span>ebpf</span>::INSN_SIZE <span>as</span> <span>u64</span> <span>*</span> <span>ebpf</span>::INSN_SIZE <span>as</span> <span>u64</span>));
 <span>1024</span>|      <span>0</span>|                    }
 <span>1025</span>|      <span>0</span>|                    next_pc <span>=</span> <span>self</span>.check_pc(pc, (target_address <span>-</span> <span>self</span><span>.program_vm_addr</span>) <span>as</span> <span>usize</span> <span>/</span> <span>ebpf</span>::INSN_SIZE)<span>?</span>;
 <span>1026</span>|       |                },
 <span>1027</span>|       |
 <span>1028</span>|       |                <span>// Do not delegate the check to the verifier, since registered functions can be</span>
 <span>1029</span>|       |                <span>// changed after the program has been verified.</span>
 <span>1030</span>|       |                <span>ebpf</span>::CALL_IMM <span>=&gt;</span> {
 <span>1031</span>|     <span>22</span>|                    <span>let</span> <span>mut</span> resolved <span>=</span> <span>false</span>;
 <span>1032</span>|     <span>22</span>|                    <span>let</span> (syscalls, calls) <span>=</span> <span>if</span> config<span>.static_syscalls</span> {
 <span>1033</span>|     <span>22</span>|                        (insn<span>.src</span> <span>==</span> <span>0</span>, insn<span>.src</span> <span>!=</span> <span>0</span>)
 <span>1034</span>|       |                    } <span>else</span> {
 <span>1035</span>|      <span>0</span>|                        (<span>true</span>, <span>true</span>)
 <span>1036</span>|       |                    };
 <span>1037</span>|       |
 <span>1038</span>|     <span>22</span>|                    <span>if</span> syscalls {
 <span>1039</span>|      <span>2</span>|                        <span>if</span> <span>let</span> Some(syscall) <span>=</span> <span>self</span><span>.executable</span>.get_syscall_registry().lookup_syscall(insn<span>.imm</span> <span>as</span> <span>u32</span>) {
                                                  <span>^</span><span>0</span>
 <span>1040</span>|      <span>0</span>|                            resolved <span>=</span> <span>true</span>;
 <span>1041</span>|      <span>0</span>|
 <span>1042</span>|      <span>0</span>|                            <span>if</span> config<span>.enable_instruction_meter</span> {
 <span>1043</span>|      <span>0</span>|                                <span>let</span> <span>_</span> <span>=</span> instruction_meter.consume(<span>*</span>last_insn_count);
 <span>1044</span>|      <span>0</span>|                            }
 <span>1045</span>|      <span>0</span>|                            <span>*</span>last_insn_count <span>=</span> <span>0</span>;
 <span>1046</span>|      <span>0</span>|                            <span>let</span> <span>mut</span> result: ProgramResult<span>&lt;</span>E<span>&gt;</span> <span>=</span> Ok(<span>0</span>);
 <span>1047</span>|      <span>0</span>|                            (<span>unsafe</span> { <span>std</span>::<span>mem</span>::<span>transmute</span>::<span>&lt;</span><span>u64</span>, <span>SyscallFunction</span>::<span>&lt;</span>E, <span>*</span><span>mut</span> <span>u8</span><span>&gt;&gt;</span>(syscall<span>.function</span>) })(
 <span>1048</span>|      <span>0</span>|                                <span>self</span><span>.syscall_context_objects</span>[SYSCALL_CONTEXT_OBJECTS_OFFSET <span>+</span> syscall<span>.context_object_slot</span>],
 <span>1049</span>|      <span>0</span>|                                reg[<span>1</span>],
 <span>1050</span>|      <span>0</span>|                                reg[<span>2</span>],
 <span>1051</span>|      <span>0</span>|                                reg[<span>3</span>],
 <span>1052</span>|      <span>0</span>|                                reg[<span>4</span>],
 <span>1053</span>|      <span>0</span>|                                reg[<span>5</span>],
 <span>1054</span>|      <span>0</span>|                                <span>&amp;</span><span>self</span><span>.memory_mapping</span>,
 <span>1055</span>|      <span>0</span>|                                <span>&amp;</span><span>mut</span> result,
 <span>1056</span>|      <span>0</span>|                            );
 <span>1057</span>|      <span>0</span>|                            reg[<span>0</span>] <span>=</span> result<span>?</span>;
 <span>1058</span>|      <span>0</span>|                            <span>if</span> config<span>.enable_instruction_meter</span> {
 <span>1059</span>|      <span>0</span>|                                remaining_insn_count <span>=</span> instruction_meter.get_remaining();
 <span>1060</span>|      <span>0</span>|                            }
 <span>1061</span>|      <span>2</span>|                        }
 <span>1062</span>|     <span>20</span>|                    }
 <span>1063</span>|       |
 <span>1064</span>|     <span>22</span>|                    <span>if</span> calls {
 <span>1065</span>|     <span>20</span>|                        <span>if</span> <span>let</span> Some(target_pc) <span>=</span> <span>self</span><span>.executable</span>.lookup_bpf_function(insn<span>.imm</span> <span>as</span> <span>u32</span>) {
                                                  <span>^</span><span>0</span>
 <span>1066</span>|      <span>0</span>|                            resolved <span>=</span> <span>true</span>;
 <span>1067</span>|       |
 <span>1068</span>|       |                            <span>// make BPF to BPF call</span>
 <span>1069</span>|      <span>0</span>|                            reg[<span>ebpf</span>::FRAME_PTR_REG] <span>=</span>
 <span>1070</span>|      <span>0</span>|                                <span>self</span><span>.stack</span>.push(<span>&amp;</span>reg[<span>ebpf</span>::FIRST_SCRATCH_REG<span>..</span><span>ebpf</span>::FIRST_SCRATCH_REG <span>+</span> <span>ebpf</span>::SCRATCH_REGS], next_pc)<span>?</span>;
 <span>1071</span>|      <span>0</span>|                            next_pc <span>=</span> <span>self</span>.check_pc(pc, target_pc)<span>?</span>;
 <span>1072</span>|     <span>20</span>|                        }
 <span>1073</span>|      <span>2</span>|                    }
 <span>1074</span>|       |
 <span>1075</span>|     <span>22</span>|                    <span>if</span> <span>!</span>resolved {
 <span>1076</span>|     <span>22</span>|                        <span>if</span> config<span>.disable_unresolved_symbols_at_runtime</span> {
 <span>1077</span>|      <span>6</span>|                            <span>return</span> Err(<span>EbpfError</span>::UnsupportedInstruction(pc <span>+</span> <span>ebpf</span>::ELF_INSN_DUMP_OFFSET));
 <span>1078</span>|       |                        } <span>else</span> {
 <span>1079</span>|     <span>16</span>|                            <span>self</span><span>.executable</span>.report_unresolved_symbol(pc)<span>?</span>;
 <span>1080</span>|       |                        }
 <span>1081</span>|      <span>0</span>|                    }
 <span>1082</span>|       |                }
 <span>1083</span>|       |
 <span>1084</span>|       |                <span>ebpf</span>::EXIT <span>=&gt;</span> {
 <span>1085</span>|     <span>14</span>|                    <span>match</span> <span>self</span><span>.stack.pop</span>::<span>&lt;</span>E<span>&gt;</span>() {
 <span>1086</span>|      <span>0</span>|                        Ok((saved_reg, frame_ptr, ptr)) <span>=&gt;</span> {
 <span>1087</span>|      <span>0</span>|                            <span>// Return from BPF to BPF call</span>
 <span>1088</span>|      <span>0</span>|                            reg[<span>ebpf</span>::FIRST_SCRATCH_REG
 <span>1089</span>|      <span>0</span>|                                <span>..</span><span>ebpf</span>::FIRST_SCRATCH_REG <span>+</span> <span>ebpf</span>::SCRATCH_REGS]
 <span>1090</span>|      <span>0</span>|                                .copy_from_slice(<span>&amp;</span>saved_reg);
 <span>1091</span>|      <span>0</span>|                            reg[<span>ebpf</span>::FRAME_PTR_REG] <span>=</span> frame_ptr;
 <span>1092</span>|      <span>0</span>|                            next_pc <span>=</span> <span>self</span>.check_pc(pc, ptr)<span>?</span>;
 <span>1093</span>|       |                        }
 <span>1094</span>|       |                        <span>_</span> <span>=&gt;</span> {
 <span>1095</span>|     <span>14</span>|                            <span>return</span> Ok(reg[<span>0</span>]);
 <span>1096</span>|       |                        }
 <span>1097</span>|       |                    }
 <span>1098</span>|       |                }
 <span>1099</span>|      <span>0</span>|                <span>_</span> <span>=&gt;</span> <span>return</span> Err(<span>EbpfError</span>::UnsupportedInstruction(pc <span>+</span> <span>ebpf</span>::ELF_INSN_DUMP_OFFSET)),
 <span>1100</span>|       |            }
 <span>1101</span>|       |
 <span>1102</span>|   <span>135</span>k|            <span>if</span> config<span>.enable_instruction_meter</span> <span>&amp;&amp;</span> <span>*</span>last_insn_count <span>&gt;=</span> remaining_insn_count {
 <span>1103</span>|       |                <span>// Use `pc + instruction_width` instead of `next_pc` here because jumps and calls don&#39;t continue at the end of this instruction</span>
 <span>1104</span>|    <span>130</span>|                <span>return</span> Err(<span>EbpfError</span>::ExceededMaxInstructions(pc <span>+</span> instruction_width <span>+</span> <span>ebpf</span>::ELF_INSN_DUMP_OFFSET, initial_insn_count));
 <span>1105</span>|   <span>135</span>k|            }
 <span>1106</span>|       |        }
 <span>1107</span>|       |
 <span>1108</span>|    <span>419</span>|        Err(<span>EbpfError</span>::ExecutionOverrun(
 <span>1109</span>|    <span>419</span>|            next_pc <span>+</span> <span>ebpf</span>::ELF_INSN_DUMP_OFFSET,
 <span>1110</span>|    <span>419</span>|        ))
 <span>1111</span>|    <span>763</span>|    }
</code></pre></div></div></div>
  </body>
</html>
