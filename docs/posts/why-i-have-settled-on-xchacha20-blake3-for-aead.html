<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mccarty.io/cryptography/2021/11/29/chacha20-blake3.html">Original</a>
    <h1>Why I Have Settled on XChaCha20&#43;Blake3 for AEAD</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>This might get me some looks, but I have pretty solidly decided to go in on using XChaCha20+Blake3 as the AE of choice
for my future open source work. There are numerous reasons for this decision, but it mainly comes down to the desire for
defense in depth, and a deep dislike of fundamental properties of polynomial MACs.</p>



<h2 id="why-not-just-use-poly1305">Why not just use poly1305?</h2>

<p>The burning question, I can hear it now:</p>

<blockquote>
  <p>Why not just use ChaCha20-poly1305? Its standard, and its good enough for &lt;insert application here&gt;?  Why roll your
own crypto?</p>
</blockquote>

<p>The reason for this gets at a fundamental property of polynomial MACs<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">1</a></sup> that opens them up to all kinds of fun
attacks, like the partitioning oracle<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" rel="footnote">2</a></sup>, you didn’t even know you needed to worry about. Polynomial MACs violate
intuitive expected properties of cryptosystems, and are so finicky to work with that even the specification for AES-GCM
contained invalid proofs of its security<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" rel="footnote">3</a></sup>.</p>

<p>There is a not-infrequently important property of cryptosystems, referred to as “commiting to their keys”, or simply
“being commiting”<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" rel="footnote">4</a></sup>. Simply put, a system has this property when it is impractical to produce a message that will
successfully decrypt or verify under multiple chosen keys. As a fundamental result of their construction, polynomial
MACs lack this property, and its even worse than simply being able to construct a message that will decrypt under two
chosen keys. Even for the more well behaved polynomial MACs, such as Poly1305, it is not only practical to construct
garden variety collisions, it is practical to construct multi-collisions that will decrypt under a large number of
chosen keys<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" rel="footnote">5</a></sup> .</p>

<p>This lack of even a facade of collision resistance can actually turn into quite a big deal, just as Mega<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" rel="footnote">6</a></sup> famously
experienced a loss of security due to their inappropriate use of CBC-MAC (another type of MAC that also lacks collision
resistance) polynomial MACs, in practice, worm their way into all kinds of places they shouldn’t be, places where a
collision resistant MAC would have been the only appropriate choice. Even in the context of more seemingly sane systems,
this lack of collision resistance can cause no end of problems, such as the partitioning oracle attack <sup id="fnref:1:1" role="doc-noteref"><a href="#fn:1" rel="footnote">1</a></sup>, which was
practically exploitable for over the network password recovery in Shadowsocks, and the always interesting Invisible
Salamander<sup id="fnref:7" role="doc-noteref"><a href="#fn:7" rel="footnote">7</a></sup>.</p>

<p>These issues alone are, personally, enough to turn me off from using poly1305 or any other polynomial MACs in any of my
future projects, given that it’s 2021 and hashes are fast now, but, it is my opinion that polynomial MACs being
non-collision resistant represents a huge foot gun, and as I am not a fan of handing foot guns to the consumers of my
code, I will refrain from offering this one, and provide a committing, collision resistant scheme instead.</p>

<h2 id="why-not-use-aes">Why not use AES</h2>

<p>This one should be a little bit easier to answer, its not exactly a hot take to say that AES is a lot closer to the
bottom of the acceptable ciphers barrel than ChaCha20<sup id="fnref:8" role="doc-noteref"><a href="#fn:8" rel="footnote">8</a></sup>. Even discounting the standard complaints, like how AES’s
construction is somewhat-intrinsically vulnerable to cache based timing attacks when implemented in software<sup id="fnref:9" role="doc-noteref"><a href="#fn:9" rel="footnote">9</a></sup> (though
bit-slicing and other tricks mitigate this, they are surprisingly rare to see in the wild, even in software running on
devices that lack hardware accelerated AES), and how the block size is too small<sup id="fnref:10" role="doc-noteref"><a href="#fn:10" rel="footnote">10</a></sup>, AES still has other concerning factors
in its corner, like how the PRP-PRF distinguishing attack reduces the effective security of AES in counter mode.</p>

<p>AES just, all around, isn’t ideal. Sure, ChaCha is naturally vulnerable to electromagnetic side channel attacks<sup id="fnref:12" role="doc-noteref"><a href="#fn:12" rel="footnote">11</a></sup>,
which have been an item of, ehm, <em>increasing concern</em> for me<sup id="fnref:13" role="doc-noteref"><a href="#fn:13" rel="footnote">12</a></sup>, AES is just as vulnerable in that regard, with even
side-channel resistant hardware implementations being a rare thing, and for most practical purposes, only existing in
the literature<sup id="fnref:14" role="doc-noteref"><a href="#fn:14" rel="footnote">13</a></sup>. ChaCha20’s much larger block size (512-bit) and more timing side channel resistant construction
just lends itself to fewer foot guns, and while hardware assisted AES is a bit faster, I don’t think there is enough of
a speed differential to warrant the loss of misuse resistance in most applications.</p>

<h2 id="why-not-panic">Why not Panic</h2>

<p>This is not intended to be an indictment of any particular protocol, while the issues I’ve brought up are real, and can
result in vulnerabilities in the real world, none of them are automatically going to lead to an exploitable
vulnerability. The people making the systems you rely on to keep your private data safe by and large understand the
state of the research on the matter, and are careful to design systems to avoid the foot guns. Your AES-GCM or
ChaCha20-Poly1305 TLS stream is not in immediate peril.</p>

<p>Cryptographic primitives don’t exist in a vacuum, any analysis of vulnerabilities must be done on complete systems, as
decisions on  any level above the choice of fundamental primitives may sink <em>or</em> save the ship<sup id="fnref:15" role="doc-noteref"><a href="#fn:15" rel="footnote">14</a></sup>.</p>

<p>My interest in writing this post is in informing the design of new systems, where I much prefer foot guns be avoided
categorically instead of case-by-case, when practical, and I believe the time has come where the use of cryptosystems
that categorically avoid these foot guns is practical in all but niche edge case scenarios.</p>



<h2 id="why-use-xchacha20">Why use XChaCha20</h2>

<p>ChaCha20 has a number of benefits over AES, and I don’t really feel the need to go <em>too</em> deep into them, but lets give
the overview. ChaCha20 is a stream cipher, but it acts like a block cipher being used in CTR mode. In this respect, it
has two major advantages over AES-CTR:</p>
<ol>
  <li>The block size is 512 bits, compared to AES’s 128 bits, making a wide variety of attacks, such as birthday bound or
  PRP-PRF distinguishing attacks <em>many</em> orders of magnitude less practical to pull of against ChaCha</li>
  <li>The nonce is provided to the underlying cipher independently from the stream position. This has the nice practical
effect of making accidental nonce-reuse <em>that</em> much harder, since while a given AES-CTR stream consumes a range of
nonces, a given ChaCha stream consumes only one</li>
</ol>

<p>ChaCha20 also has other advantages, like being more energy efficient when dedicated hardware isn’t available, and being
naturally resistant to timing side channel attacks. The only real disadvantage is that it is slower than commonly
available hardware accelerated AES, but not by an amount that I think makes a critical difference for all but the
pickiest of applications.</p>

<p>The choice of XChaCha20 over that of plain ChaCha20 is also easy to explain. ChaCha20 only gives you a 64 bit nonce,
which, while enough to encrypt the world with a given key, means that choosing a nonce at random can be incredibly
dangerous, even AES-GCM’s 96-bit nonce is much too small, leading to concrete failures in production<sup id="fnref:16" role="doc-noteref"><a href="#fn:16" rel="footnote">15</a></sup>, and even the
128-bit nonce of straight AES-CTR leaves me feeling uneasy, the birthday bound there is a lot lower than it feels like
it is. XChaCha20’s choice of a 192 bit nonce, however, leaves plenty of headroom to feel safe, even when randomly
selecting nonces, taking another foot gun out of the equation.</p>

<h2 id="why-use-blake3">Why use Blake3</h2>

<p>This is another easy one to answer. The biggest reason, is, well Blake3 is <em>fast</em>, several times faster than ChaCha20 on
my machine, and having an HMAC that can out run your cipher several times over is always handy when building HMAC based
cryptosystems. In my opinion having a hash, like Blake3, that’s truly <em>fast</em> changes the trade off analysis, making it
much less worth the trade off of using a polynomial MAC.</p>

<p>Blake3 also has some other nice properties, its a modern, secure, length-extension resistant hash based on a merkle tree
construction, which provides lots of other side benefits, such as the ability to use the hash for verified streaming. It
additionally has the nice property of not <em>really</em> having variants, with the HMAC, KDF, hash, and XOF modes all
operating in a very similar and consistent manner, easing the cognitive load on the programmer.</p>

<p>Being effectively an HMAC, Blake3 also provides a scheme that commits to its keys, almost for
free as a side effect of collision resistance, directly sidestepping my concerns about polynomial
MACs.</p>



<p>I believe that using XChaCha20-Blake3 in the encrypt-then-hmac construction provides a more-than-fast-enough base to
build more than useable cryptosystems on top of, and acts as a primitive for doing so that presents substantially fewer
foot guns than other competing options, while still remaining more than useably fast, even in the absence of dedicated
hardware acceleration. Humans are such fallible creatures, and accidental de-footings are <em>much</em> less likely to happen
when we are provided fewer chances to do so.</p>



  </div>
  
  
</article>

      </div>
    </div></div>
  </body>
</html>
