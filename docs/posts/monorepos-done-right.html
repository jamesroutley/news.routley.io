<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://felixmulder.com/writing/2022/03/12/Monorepos-done-right.html">Original</a>
    <h1>Monorepos done right</h1>
    
    <div id="readability-page-1" class="page"><div>
  
<p><em>8 minute read</em></p>
<p>There‚Äôs a lot of arguments for and against monorepos. Done right, I believe monorepos will help you move with urgency and focus as your engineering organization grows. That doesn‚Äôt mean it‚Äôs easy! I‚Äôve also seen monorepos turn into monoliths that block teams from getting anything out in a timely manner.</p>
<h2 id="the-basics">The basics</h2>
<p>If your organization puts all its code, and all assets that go along with that code into a single repository; you‚Äôve got yourself a monorepo.</p>
<p>The opposite of this is a multirepo setup where projects are split into several different repositories.</p>
<p>There are a number of things I really like about monorepos:</p>
<ul>
<li><p><strong>Single source of truth</strong></p>
<p>Code changes are atomic, no need to sync schemas over several repos.</p></li>
<li><p><strong>Visible cost of change</strong></p>
<p>Altering code now requires you to make sure that all existing code usage is updated or compatible with the change.</p></li>
<li><p><strong>Sharing and reusing code</strong></p>
<p>Discoverability for existing functionality and reusing existing components is greatly simplified. This also includes versioning and aligning dependencies across the org.</p></li>
<li><p><strong>Improved collaboration</strong></p>
<p>Having to wrangle permissions and aligning several repos is not an issue. Just change the code and get the proper reviews!</p></li>
</ul>
<p>There are real downsides to putting everything into a single repo.</p>
<ul>
<li><p><strong>Unrelated breakages</strong></p>
<p>Someone else‚Äôs code or tests are broken to no fault of yours</p></li>
<li><p><strong>Pipelines taking way too long</strong></p>
<p>Build, test, and deploy cycles growing linearly with the size of the codebase.</p></li>
<li><p><strong>VCS not scaling to meet your needs</strong></p>
<p>Your version control system not being able to handle the sheer number of references and operations done to the repo.</p></li>
<li><p><strong>Access and code ownership</strong></p>
<p>Your organization might not want you to have access to the entirety of the codebase, and conversely, you might not want everyone to be able to approve code changes to code owned by your team.</p></li>
<li><p><strong>Shared pain</strong></p>
<p>The health of the repo is now the health of developer productivity at your org.</p></li>
</ul>
<h2 id="getting-things-wrong-from-the-start">Getting things wrong from the start</h2>
<p>It‚Äôs incredibly tempting to take your usual set of tools and apply them to a single repo and call it a monorepo.</p>
<p>You set up up pipelines to run your tests, on merge you deploy your services.</p>
<p>
graph LR
 A(Merge PR) --&gt; B(&#34;Build üèó&#34;)
 A --&gt; C(&#34;Test üß™&#34;)
 B --&gt; D(&#34;‚úÖ ?&#34;)
 C --&gt; D
 D --&gt; E(Deploy services)
</p>
<p>This works really well for multirepo setups! It works rather well for a nascent monorepo as well.</p>
<p>This, however, gives you not a monorepo, but a monolith.</p>
<h5 id="testing-is-per-target">Testing is per target</h5>
<p>Testing and building is not the same thing! A hermetic build system will allow you to rebuild the minimum set of changes.</p>
<p>With monorepos, however, you need to also think about testing and deployment as a per-target concern. When changing the code for a service, what should be tested in order for you to confidently be able to deploy the service?</p>
<h5 id="flaky-tests">Flaky tests</h5>
<p>You also need to decide what to do about flaky tests. In a very small team, it‚Äôs quite possible to eliminate flakiness. For a whole org, it isn‚Äôt. It‚Äôs going to happen, so you have to figure out a way to deal with it.</p>
<h5 id="merge-races">Merge races</h5>
<p>A merge race occurs as a conflict due to a merge, on the semantic level as opposed to a conflict on the VCS level.</p>
<p>Consider two pull requests changing the same file. They both pass CI on their individual branches, but when merged even though they don‚Äôt conflict on the VCS level ‚Äì they introduce an error. It could be, for instance, that the first PR changes the signature of a method, and the second one introduces a new usage of the old version of said method.</p>
<p>This is not such a problem with multirepos, as the occurrence of merge races is (among other things) proportional to the amount of changes per time unit.</p>
<p>The easiest mitigation is to serialize merges to the main branch. However, naively serializing merges does not scale. At Stripe, my current project is to implement a speculative approach to testing and merging changes, this will allow us to scale merges to hundreds of commits per hour while keeping the main branch green.</p>
<h2 id="trying-to-get-things-right-from-the-start">Trying to get things right from the start</h2>
<p>This is why I‚Äôm writing this post. Most monorepos I‚Äôve been exposed to have a lot of history and it‚Äôs an interesting thought experiment how to do this if starting from scratch.</p>
<p>I want to be able to run a monorepo with a small team of engineers dedicated to the infrastructure, it should be obvious to other contributors how the repo works.</p>
<h3 id="ci">CI</h3>
<p>As a contributor, when I push a branch, I want CI to pick up my changes and run the associated tests. If the tests pass, I‚Äôll ask for the appropriate reviews and once approved merge a PR with my changes. Once the PR is merged, I want to be able to deploy my code changes.</p>
<p>A first stab at this is to use a hermetic build system that offers caching of unaffected build artifacts. That way, we‚Äôll only rebuild the minimum set of changes.</p>
<p>In real life, using a hermetic build system <em>for tests</em> does not actually scale. The dependency graph of your repo becomes entwined with how much of your repo gets tested. Change a deeply nested component often? Even though you only want to deploy one out of all your services, you‚Äôll get full rebuilds of your repo.</p>
<p>I still think a hermetic build system is the way to go; but I wouldn‚Äôt gate merges on testing the full repo. Instead, let‚Äôs give some flexibility to our engineers.</p>
<p>If we have the service <code>toy-srv</code>, the developers of that service should be comfortable in declaring what needs to pass in order for the service to be deployed.</p>
<p>Let‚Äôs say each service directory contains some <code>src</code> files and some <code>test</code> files. A <code>BUILD.bazel</code> file that specifies build targets, and a <code>metadata.yaml</code> file that we can populate with repo specific infra:</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1"></a>.</span>
<span id="cb1-2"><a href="#cb1-2"></a>‚îú‚îÄ‚îÄ toy</span>
<span id="cb1-3"><a href="#cb1-3"></a>‚îÇ   ‚îú‚îÄ‚îÄ src</span>
<span id="cb1-4"><a href="#cb1-4"></a>‚îÇ   ‚îú‚îÄ‚îÄ test</span>
<span id="cb1-5"><a href="#cb1-5"></a>‚îÇ   ‚îú‚îÄ‚îÄ BUILD.bazel</span>
<span id="cb1-6"><a href="#cb1-6"></a>‚îÇ   ‚îî‚îÄ‚îÄ metadata.yaml</span>
<span id="cb1-7"><a href="#cb1-7"></a>‚îú‚îÄ‚îÄ shop</span>
<span id="cb1-8"><a href="#cb1-8"></a>‚îÇ   ‚îú‚îÄ‚îÄ src</span>
<span id="cb1-9"><a href="#cb1-9"></a>‚îÇ   ‚îú‚îÄ‚îÄ test</span>
<span id="cb1-10"><a href="#cb1-10"></a>‚îÇ   ‚îú‚îÄ‚îÄ BUILD.bazel</span>
<span id="cb1-11"><a href="#cb1-11"></a>‚îÇ   ‚îî‚îÄ‚îÄ metadata.yaml</span>
<span id="cb1-12"><a href="#cb1-12"></a>‚îî‚îÄ‚îÄ metadata.yaml</span></code></pre></div>
<p>The <code>BUILD.bazel</code> file might contain the instructions for creating runnables for the two services. You can imagine that <code>shop-srv</code> depends on <code>toy-srv</code>.</p>
<p>In a monolithic world, all code would need to pass in order to deploy either service. Instead let‚Äôs imagine that the teams responsible for these services have defined the constraints in their respective YAML files:</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1"></a><span># ./toy/metadata.yaml</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span>ownership</span><span>:</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span>  </span><span>-</span><span> toy-team</span></span>
<span id="cb2-4"><a href="#cb2-4"></a></span>
<span id="cb2-5"><a href="#cb2-5"></a><span>merge_requirements</span><span>:</span></span>
<span id="cb2-6"><a href="#cb2-6"></a><span>  </span><span>-</span><span> </span><span>test</span><span>:</span><span> //toy/test/...</span></span>
<span id="cb2-7"><a href="#cb2-7"></a></span>
<span id="cb2-8"><a href="#cb2-8"></a><span>services</span><span>:</span></span>
<span id="cb2-9"><a href="#cb2-9"></a><span> </span><span>-</span><span> </span><span>name</span><span>:</span><span> toy-srv</span></span>
<span id="cb2-10"><a href="#cb2-10"></a><span>   </span><span>target</span><span>:</span><span> //toy:ToyService</span></span></code></pre></div>
<p>This file states that the current directory is owned by the <code>toy-team</code>, for now, we can assume that at least one member of the <code>toy-team</code> must review PRs to this directory.</p>
<p>When a branch is pushed with changes to this directory, CI will look at the diff to determine which <code>metadata.yaml</code> files are affected. It will then proceed to build all changes and test the required targets listed under <code>merge_requirements</code>. This file says to run all the tests for the <code>toy</code> directory, the syntax <code>//toy/test/...</code> is Bazel for, all the targets under <code>./toy/test</code>.</p>
<p>Given that we have an approval from the <code>toy-team</code> and the tests specified have succeeded, we may merge the change. However, we may not deploy <code>toy-srv</code> until the required build has completed.</p>
<p>Let‚Äôs take an example with a different service <code>shop-srv</code> that depends on <code>toy-srv</code>:</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1"></a><span># ./shop/metadata.yaml</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span>ownership</span><span>:</span></span>
<span id="cb3-3"><a href="#cb3-3"></a><span>  </span><span>-</span><span> shop-team</span></span>
<span id="cb3-4"><a href="#cb3-4"></a></span>
<span id="cb3-5"><a href="#cb3-5"></a><span>merge_requirements</span><span>:</span></span>
<span id="cb3-6"><a href="#cb3-6"></a><span>  </span><span>-</span><span> </span><span>test</span><span>:</span><span> //shop/test/...</span></span>
<span id="cb3-7"><a href="#cb3-7"></a></span>
<span id="cb3-8"><a href="#cb3-8"></a><span>services</span><span>:</span></span>
<span id="cb3-9"><a href="#cb3-9"></a><span>  </span><span>-</span><span> </span><span>name</span><span>:</span><span> shop-srv</span></span>
<span id="cb3-10"><a href="#cb3-10"></a><span>    </span><span>target</span><span>:</span><span> //shop:ShopService</span></span>
<span id="cb3-11"><a href="#cb3-11"></a><span>    </span><span>deploy_requirements</span><span>:</span></span>
<span id="cb3-12"><a href="#cb3-12"></a><span>      </span><span>-</span><span> </span><span>service</span><span>:</span><span> //toy:ToyService</span></span></code></pre></div>
<p>This team has been a bit stricter in what they require in order to merge changes to this directory. Both the tests for the shop and the build for the service have to complete successfully! Furthermore, they want to be certain that the toy service can be built for the same commit in order to allow a deploy.</p>
<p>For critical components, you may want to employ more rigor, it‚Äôs up to you!</p>
<p>It‚Äôs important to have the distinction that not all services are deployable in all commits on the main branch. Imagine that a merge race causes services‚Äô deployability to go red, you wouldn‚Äôt want that to stop any orthogonal change!</p>
<h3 id="test-flakiness">Test flakiness</h3>
<p>In the previous section we sort of closed our eyes to having flaky tests in the codebase. There are a couple of types of flaky tests that come to mind:</p>
<ul>
<li>Tests that perform network operations</li>
<li>Tests that depend on temporality</li>
<li>Tests that depend on randomness or side-effects</li>
</ul>
<p>The first one is easy, ban these. You don‚Äôt need them in the blocking portion of your pipelines.</p>
<p>The second one can be solved with things like <a href="https://github.com/wolfcw/libfaketime"><code>libfaketime</code></a> which fixes the system clock to be set to a specific date and time.</p>
<p>The last one is harder. It brings us to needing a flaky test mitigation system. There are a couple of strategies we can employ. Each test should be given a globally unique ID. Whenever a new ID appears, we run that test several times in different configurations in order to determine if it is flaky. If it is not deemed flaky, we let it out into the wild. If the test GUID starts showing up as failing intermittently, we automatically disable the test and open a ticket with the owning team.</p>
<p>This latter piece is hard to build yourself quickly, but a lot of CI vendors seem to be digging into this space finally.</p>
<h3 id="merge-races-1">Merge races</h3>
<p>This is very hard to get right. I‚Äôve yet to see an open-sourced alternative that works for generic monorepos.</p>
<p>Luckily, after you‚Äôve exhausted the throughput of a naive FIFO queue of merges, you‚Äôre most likely in a position where you can afford to throw money at a team to solve merge races for you permanently.</p>
<p>Until you‚Äôre in such a place, your best bet is to make sure that you keep time waiting on CI to a minimum. Luckily, you read the right post to provide you with the insight into how to do just that!</p>
<h2 id="in-summary">In summary</h2>
<p>We‚Äôve seen that by breaking up the monolithic test suite, using a hermetic build system, and providing flexibility in deployability we get a monorepo that is not monolithic.</p>
<p>There‚Äôs a lot more to discuss when it comes to managing a monorepo, and I‚Äôve left a lot of things out. I might write about this again in the future.</p>
<p>‚Äì Felix</p>
<hr/>
<h4 id="updates">Updates</h4>
<ul>
<li>2020-03-15: Improve phrasing as to why naively serializing merges does not scale (<a href="https://github.com/felixmulder/felixmulder.github.io/commit/6a484431e0b8acda13b4c01a20121c73df044280">commit</a>)</li>
</ul>
</div></div>
  </body>
</html>
