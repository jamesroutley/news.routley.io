<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/TimeSurgeLabs/athenadb">Original</a>
    <h1>Show HN: I built a vector database API on Cloudflare</h1>
    
    <div id="readability-page-1" class="page"><div>  <p>When I decided to build <a href="https://hazure.neocities.org/index.html">a new website</a> and publish some articles about what I
    am currently working on, I knew I wanted it to be as DIY as possible; but I felt that writing the
    articles themselves directly in HTML would be too much of a burden, and although I have written my
    share of Markdown, I still need to look up how to do simple things all the time, and I still need a
    way to render the articles anyway. So I just sat down and started jamming on what I would like my
    authoring format to be like; I (very quickly, as will perhaps become apparent soon) came up with
    something that seemed like it would be fun to use and hack on, picked up a name from my list of
    project codenames, and here we go. And while this project was started on a whim, it is turning out to
    be a great source of self-inspiration, motivation to try out new things, and more importantly, <strong>fun</strong>.</p> <p><a href="https://github.com/stcucufa/dodo">Dodo ü¶§</a> is a lightweight markup language similar to XML.
    It has <em>elements</em>, which are named, and have <em>attributes</em> and <em>children</em>, which can be
    elements or text. A Dodo <em>document</em> is a tree of elements, with a root element and some metadata.
    Dodo has comments. Dodo has no meaning; not in the sense that it has no reason to exist, but in that
    elements and attributes mean whatever we want them to mean. If Dodo has a philosophy, it could be <span>write first and ask questions later</span>. And one of this questions is: what should we do with a
    Dodo document once it is written? Before answering, let us have a look at the source for this
    article:</p> <figure><pre>{ article: &#34;I could not remember the Markdown syntax for links, so I
    made a pretty bad Lisp.&#34; lang: en date: 2024-02-16
    logo: ../images/logo-recursive.svg

    { abstract Dodo ü¶§ is a lightweight markup language that is used
    to author this website. It has no fixed semantics, except for a
    { em transformation language } that can produce other output
    formats. It is actually based on a simple Lisp evaluator that
    uses the same syntax as the markup language itself. }

    # Introduction

    { p When I decided to build { link: /index.html a new website }
    and publish some articles about what I am currently working on
    (...) }

}</pre> <figcaption>How this very document begins</figcaption></figure> <p>Elements are enclosed in a pair of braces <code>{</code> ... <code>}</code>. The element name comes
    first and is followed by zero or more attributes (which are <code>name: value</code> pairs), then text or
    other elements that make up the <em>content</em> of the parent element. There are no tags, no double
    quotes when not necessary (<em>i.e.</em>, when the attribute value has no whitespace), very few special
    characters, and those can be escaped with a <code>\</code>; hence the ‚Äúlightweight‚Äù adjective. Element
    names can even double as attribute names, as in the <code>article</code> and <code>link</code> elements; if
    all articles need a title and all links a URL, it makes sense for those to be the default attributes
    for their respective elements. The goal of Dodo is to be simple to write, and to remain somewhat
    legible as is.</p> <p>This article is written in Dodo of course, using a set of elements made up as they become needed: <code>article</code> is the root of the article, <code>link</code> is used for hyperlinks, <code>p</code> for
    paragraphs, <code>eg</code> is a shorthand for <em>e.g.</em>, &amp;c. But in order to reach readers, this Dodo document
    needs to be <em>transformed</em> into some more traditional output like good old HTML. This idea also
    comes straight from the world of XML, where authors can create their custom XML language and use <a href="https://www.w3.org/TR/xslt-30/">XSL Transformations</a> (XSLT) to output content in other formats.
    And just like XSLT itself is XML, transforming Dodo documents is also done with Dodo documents.</p> <figure><pre>{ transform

    # Do not show abstract

    { match { element abstract } }

    # Generic rules, use the same element and attributes as HTML.

    { match { element }
        &lt;{ name-of }{ apply { attributes-of } }&gt;
            { apply { content-of } }
        &lt;/{ name-of }&gt;
    }
    { match { attribute } { space }{ name-of }=&#34;{ value-of }&#34; }
    { match { text } { escape-html { value-of } } }

}</pre> <figcaption>Transforming Dodo to HTML (excerpt)</figcaption></figure> <p>The figure above shows a part of the transform from <code>article</code> to HTML. A transform consists
    of <em>rules</em> that attempt to <em>match</em> parts of the document, and produce some output when they
    do. The <code>match</code> element has two parts: its first child describes what it is trying to match
    (the <code>abstract</code> element in the first rule, or any element, attribute or text in the following
    rules), then the rest of the content is the output, which is generally a mixture of text and some other
    elements to fetch and match more content from the source document. Or it can output nothing, like in
    the first rule for <code>abstract</code> (the abstract is shown in the <a href="https://hazure.neocities.org/articles/index.html">table of
    contents</a>, but not in the article itself).</p> <p>In the case of the generic <code>element</code> rule, which matches any element (unless it was matched
    by a preceding rule), the output is a HTML tag, starting with <code>&lt;</code>, followed by the <em>name of</em> the matched element; then by whatever is produced by applying the transforms to the <em>attributes
    of</em> the matched element, then a closing <code>&gt;</code>. The rules are then applied recursively to the <em>content of</em> the matched element, and a closing tag is added, just like the opening tag was
    created. Attributes are also simply copied to HTML, and text is escaped to produce proper HTML output.
    As an example, <code>{ p Hello, family &amp; friends }</code> gets transformed into <code>&lt;p&gt;Hello, family
    &amp;amp; friends&lt;/p&gt;</code> by this rule.</p> <p>Compared to XSLT, the transform language is very simple and has few features; it also lacks a
    more compact syntax such as the <a href="https://www.w3.org/TR/xpath-31/">XML Path Language</a> (XPath)
    for matching content. But it is currently sufficient to generate the not completely trivial output
    seen here.</p> <p>The reader may get the impression that expressions such as <code>{ escape-html { value-of } }</code> look suspiciously like S-expressions, the main difference being that Dodo uses braces instead of
    parens (braces being much less common in common prose). So transforms can be implemented easily with
    a <a href="https://mitp-content-server.mit.edu/books/content/sectbyfn/books_pres_0/6515/sicp.zip/full-text/book/book-Z-H-26.html">SICP-style LISP evaluator</a> using the input of the Dodo parser, and we can transform <code>link</code> elements to HTML anchor tags, using the <code>link</code> attribute as <code>href</code> and the content of
    the element as the content of the anchor, defaulting to the link URL itself if there is no content.
    In order to do that, two possible outputs are combined with a regular boolean <code>or</code>:</p> <figure><pre>{ match { element link }
    &lt;a href=&#34;{ attribute link }&#34;&gt;{
        or { apply { content-of } } { attribute link }
    }&lt;/a&gt;
}</pre> <figcaption>Or</figcaption></figure> <p>But it turns out that Dodo markup and S-expressions are actually not the same thing at all. To
    Dodo, everything that is not an element, an attribute or an attribute value is just a continuous
    text string, with some funky whitespace handling rules (whitespace is trimmed at the beginning and the
    end of an element, but not inside it). So it is not <em>quite</em> possible to just turn a Lisp function
    to compute Fibonacci numbers like the one below into a form suitable for evaluation only by replacing
    parens with braces.</p> <figure><pre>(define (fib x)
    (if (&lt; x 2)
        x (+ (fib (- x 1) (fib (- x 2)))
    )
)</pre> <figcaption>Fibonacci in Lisp</figcaption></figure> <p>For example, converting <code>(&lt; x 2)</code> to <code>{ &lt; x 2 }</code> would give us an element with
    name <code>&lt;</code> (that‚Äôs fine, it is suitable for looking up a function or a special form to be
    evaluated) and content <code>x 2</code>, which is just a string of three characters, and not an
    indentifier <em>x</em> and a literal number 2. Even if the string was tokenized properly to produce
    two arguments for <code>&lt;</code>, these would still be string values; so we would need something more
    verbose like <code>{ &lt; { get x } { number 2 } }</code> to get the value of <em>x</em> from the
    environment, and the number value 2. This is starting more and more like trying to fit a square peg in
    a round hole. But... what if the section of the peg was more like a squircle?</p> <p>Lisp has a special form, <code>quote</code>, and syntactic sugar for it, <code>&#39;</code>, to prevent content
    from being evaluated. Well, Dodo has one extra special character, <code>`</code>, which does the opposite,
    and <em>unquotes</em> the following string, turning <code>`x</code> into <code>{ get x }</code> and <code>`2</code> into <code>{ number 2 }</code>; like its Lisp counterpart, a whole element can be unquoted
    to turn it into a list. So now the squircle peg can be jammed into the round hole like so:</p> <figure><pre>{ define `{ fib x }
    { if { &lt; `x `2 }
        `x { + { fib { - `x `1 } } { fib { - `x `2 } } }
    }
}</pre> <figcaption>Fibonacci in Dodo Lisp</figcaption></figure> <p>One last tweak is to allow elements to be <em>anonymous</em>, <em>i.e.</em>, to not have a name or
    attributes, but only child elements. This permits the evaluation of the first term of a function
    application (note also how attributes can be abused in the lambda definition to avoid unquoting):</p> <figure><pre>{ { Œª: x { + `x `1 } } `2 }</pre> <figcaption><code>((lambda (x) (+ x 1)) 2)</code> in Dodo Lisp</figcaption></figure> <p>So this can work, at the cost of a few splinters. One thing this has going for it though is that
    it is starting to look a little bit less like Lisp and a little bit more like Logo (in particular, <a href="https://en.wikipedia.org/wiki/UCBLogo#Data">UCB Logo</a>, with its <code>:</code> notation). This
    opens up a lot of doors for future work on Dodo as a programming language, but in the meantime,
    document transforms can rely on a proper, if wonky, programming language to support them; this is
    used to format dates for example. ‚öÅ‚öÇ</p> <p>The core of this work, namely turning the markup language into a Lisp, updating the parser and
    writing the evaluator, was done during the Winter 2 Impossible Stuff Day at the <a href="https://www.recurse.com">Recurse Center</a>.</p> </div></div>
  </body>
</html>
