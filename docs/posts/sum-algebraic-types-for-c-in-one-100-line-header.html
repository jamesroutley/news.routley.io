<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/grego/sumtype.h">Original</a>
    <h1>Show HN: Sum (algebraic) types for C in one 100 line header</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text"><div dir="auto" data-snippet-clipboard-copy-content="struct Node {
	struct BinaryTree *l;
	int x;
	struct BinaryTree *r;
};

Sumtype(
	BinaryTree,
	(int, leaf),
	(struct Node, node)
)

int sum(struct BinaryTree *tree) {
	match(struct BinaryTree, tree) {
		let(int, leaf) return *leaf;
		let(struct Node, node) return sum(node-&gt;l) + node-&gt;x + sum(node-&gt;r);
	}
	// Unreachable
	return 0;
}"><pre><span>struct</span> <span>Node</span> {
	<span>struct</span> <span>BinaryTree</span> <span>*</span><span>l</span>;
	<span>int</span> <span>x</span>;
	<span>struct</span> <span>BinaryTree</span> <span>*</span><span>r</span>;
};

<span>Sumtype</span>(
	<span>BinaryTree</span>,
	(<span>int</span>, <span>leaf</span>),
	(<span>struct</span> <span>Node</span>, <span>node</span>)
)

<span>int</span> <span>sum</span>(<span>struct</span> <span>BinaryTree</span> <span>*</span><span>tree</span>) {
	<span>match</span>(<span>struct</span> <span>BinaryTree</span>, <span>tree</span>) {
		<span>let</span>(<span>int</span>, <span>leaf</span>) <span>return</span> <span>*</span><span>leaf</span>;
		<span>let</span>(<span>struct</span> <span>Node</span>, <span>node</span>) <span>return</span> <span>sum</span>(<span>node</span><span>-&gt;</span><span>l</span>) <span>+</span> <span>node</span><span>-&gt;</span><span>x</span> <span>+</span> <span>sum</span>(<span>node</span><span>-&gt;</span><span>r</span>);
	}
	<span>// Unreachable</span>
	<span>return</span> <span>0</span>;
}</pre></div>
<p dir="auto">Safe, intuitive <a href="https://en.wikipedia.org/wiki/Sum_type" rel="nofollow">sum types</a> with exhaustive pattern matching in a single 100 line header, pure C99.</p>
<p dir="auto">Inspired by <a href="https://github.com/Hirrolot/datatype99">datatype99</a>, but consisting of
one small standard-conforming C99 macro-only header that is fast to compile.</p>

<p dir="auto">Just include the header file <code>sumtype.h</code>.</p>

<p dir="auto">The provided macros are a syntactic sugar over tagged unios. The above code is equivalent to:</p>
<div dir="auto" data-snippet-clipboard-copy-content="struct BinaryTree {
    enum { Leaf, Node } tag;
    union {
        int leaf;
        struct Node node;
    } data;
};

int sum(struct BinaryTree *tree) {
    switch (tree-&gt;tag) {
    case Leaf:
        return tree-&gt;data.leaf;
    case Node:
        return sum(tree-&gt;data.node.lhs) + tree-&gt;data.node.x + sum(tree-&gt;data.node.rhs);
    }

    // Unreachable.
    return 0;
}"><pre><span>struct</span> <span>BinaryTree</span> {
    <span>enum</span> { <span>Leaf</span>, <span>Node</span> } <span>tag</span>;
    <span>union</span> {
        <span>int</span> <span>leaf</span>;
        <span>struct</span> <span>Node</span> <span>node</span>;
    } <span>data</span>;
};

<span>int</span> <span>sum</span>(<span>struct</span> <span>BinaryTree</span> <span>*</span><span>tree</span>) {
    <span>switch</span> (<span>tree</span><span>-&gt;</span><span>tag</span>) {
    <span>case</span> <span>Leaf</span>:
        <span>return</span> <span>tree</span><span>-&gt;</span><span>data</span>.<span>leaf</span>;
    <span>case</span> <span>Node</span>:
        <span>return</span> <span>sum</span>(<span>tree</span><span>-&gt;</span><span>data</span>.<span>node</span>.<span>lhs</span>) <span>+</span> <span>tree</span><span>-&gt;</span><span>data</span>.<span>node</span>.<span>x</span> <span>+</span> <span>sum</span>(<span>tree</span><span>-&gt;</span><span>data</span>.<span>node</span>.<span>rhs</span>);
    }

    <span>// Unreachable.</span>
    <span>return</span> <span>0</span>;
}</pre></div>
<p dir="auto">The data type is generated with the <code>Sumtype</code> macro, which takes the name of the resulting
struct and and list of pairs of types and names of the variants, all separated by commas.</p>
<div dir="auto" data-snippet-clipboard-copy-content="Sumtype(Haha, (char *, name), (uint16_t, id), (uint32_t, var))"><pre><span>Sumtype</span>(<span>Haha</span>, (<span>char</span> <span>*</span>, <span>name</span>), (<span>uint16_t</span>, <span>id</span>), (<span>uint32_t</span>, <span>var</span>))</pre></div>
<p dir="auto">You can pattern-match over the instances of this type. The <code>match</code> macro takes a type
and an expression evaluating to a pointer to a value of this type.
Then, for each variant, the <code>let</code> macro takes a type and name of the given variant.
If the value being matched is of this variant, the <code>let</code> macro generates a binding
to a pointer to a value of this type with the provided name, which you may use in the
following statement.</p>
<div dir="auto" data-snippet-clipboard-copy-content="match(struct Haha, &amp;something) {
	let(char *, name) {
    		printf(&#34;%s\n&#34;, *name);
	}
	let(uint16_t, id) {
    		printf(&#34;%d\n&#34;, *id);
	}
	otherwise {
    		printf(&#34;var\n&#34;);
	}
};"><pre><span>match</span>(<span>struct</span> <span>Haha</span>, <span>&amp;</span><span>something</span>) {
	<span>let</span>(<span>char</span> <span>*</span>, <span>name</span>) {
    		<span>printf</span>(<span>&#34;%s\n&#34;</span>, <span>*</span><span>name</span>);
	}
	<span>let</span>(<span>uint16_t</span>, <span>id</span>) {
    		<span>printf</span>(<span>&#34;%d\n&#34;</span>, <span>*</span><span>id</span>);
	}
	<span>otherwise</span> {
    		<span>printf</span>(<span>&#34;var\n&#34;</span>);
	}
};</pre></div>
<p dir="auto"><code>otherwise</code> matches all variants.</p>
<p dir="auto">For each variant, a constructor with the name <code>Typename_variantname</code> is generated.</p>
<div dir="auto" data-snippet-clipboard-copy-content="struct BinaryTree leaf5 = BinaryTree_leaf(5);"><pre><span>struct</span> <span>BinaryTree</span> <span>leaf5</span> <span>=</span> <span>BinaryTree_leaf</span>(<span>5</span>);</pre></div>
<p dir="auto">If you want to just test for one variant, the <code>iflet</code> macro is provided, which takes
the sum type, the type and the name of the variant being matched and an expression that evaluates
to a pointer of the sum type. It provides a binding analogical to <code>let</code> in <code>match</code>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="iflet(struct BinaryTree, int, leaf, &amp;tree) {
	printf(&#34;A leaf with the value %d\n&#34;, *leaf);
} else {
	printf(&#34;Not a leaf\n&#34;);
}"><pre><span>iflet</span>(<span>struct</span> <span>BinaryTree</span>, <span>int</span>, <span>leaf</span>, <span>&amp;</span><span>tree</span>) {
	<span>printf</span>(<span>&#34;A leaf with the value %d\n&#34;</span>, <span>*</span><span>leaf</span>);
} <span>else</span> {
	<span>printf</span>(<span>&#34;Not a leaf\n&#34;</span>);
}</pre></div>
<p dir="auto">Finally, the <code>MATCHES</code> macro, taking a name of a variant and an expression, tests whether
the value of the expression is of the given variant.</p>

<p dir="auto">datatype99 is written using an impressive functional language built atop of preprocessor
macros, <a href="https://github.com/Hirrolot/metalang99">Metalang99</a>. While this is a powerful
language and the resulting macros are more flexible, there are several reasons why
<code>sumtype.h</code> may be considered:</p>
<ul dir="auto">
<li>It is a 100 line single header that you can just copy into your project and even quickly
understand and modify to your liking.</li>
<li>The compile times are much faster.</li>
<li>It allows matching against <code>const</code> pointers.</li>
<li>It doesn&#39;t pollute the namespace with any typedefs. It only expands to a struct with
the provided name (contrary to a separate new type for all variants).</li>
</ul>


<div dir="auto" data-snippet-clipboard-copy-content="&lt;sumtype&gt;       ::= &#34;Sumtype(&#34; &lt;ident&gt; { &#34;,&#34; &#34;(&#34; &lt;type&gt;, &lt;ident&gt; &#34;)&#34; }+ &#34;)&#34; ;

&lt;match&gt;         ::= &#34;match(&#34; &lt;type&gt; &#34;,&#34; &lt;expr&gt; &#34;) {&#34; { &lt;let&gt; }* [ &lt;otherwise&gt; ] &#34;}&#34; ;
&lt;of&gt;            ::= &#34;let(&#34; &lt;type&gt; &#34;,&#34; &lt;variant-name&gt; &#34;)&#34; &lt;stmt&gt; ;
&lt;otherwise&gt;     ::= &#34;otherwise&#34; &lt;stmt&gt; ;

&lt;if-let&gt;        ::= &#34;iflet(&#34; &lt;type&gt; &#34;,&#34; &lt;type&gt; &#34;,&#34; &lt;ident&gt; &#34;,&#34; &lt;expr&gt; &#34;)&#34; &lt;stmt&gt; ;
&lt;matches&gt;       ::= &#34;MATCHES(&#34; &lt;ident&gt; &#34;,&#34; &lt;expr&gt; &#34;)&#34; ;"><pre><span>&lt;sumtype&gt;</span>       <span>::=</span> <span><span>&#34;</span>Sumtype(<span>&#34;</span></span> &lt;<span>ident</span>&gt; { <span><span>&#34;</span>,<span>&#34;</span></span> <span><span>&#34;</span>(<span>&#34;</span></span> &lt;<span>type</span>&gt;, &lt;<span>ident</span>&gt; <span><span>&#34;</span>)<span>&#34;</span></span> }<span>+</span> <span><span>&#34;</span>)<span>&#34;</span></span> ;
<span></span>
<span>&lt;match&gt;</span>         <span>::=</span> <span><span>&#34;</span>match(<span>&#34;</span></span> &lt;<span>type</span>&gt; <span><span>&#34;</span>,<span>&#34;</span></span> &lt;<span>expr</span>&gt; <span><span>&#34;</span>) {<span>&#34;</span></span> { &lt;<span>let</span>&gt; }<span>*</span> [ &lt;<span>otherwise</span>&gt; ] <span><span>&#34;</span>}<span>&#34;</span></span> ;
<span>&lt;of&gt;</span>            <span>::=</span> <span><span>&#34;</span>let(<span>&#34;</span></span> &lt;<span>type</span>&gt; <span><span>&#34;</span>,<span>&#34;</span></span> &lt;<span>variant-name</span>&gt; <span><span>&#34;</span>)<span>&#34;</span></span> &lt;<span>stmt</span>&gt; ;
<span>&lt;otherwise&gt;</span>     <span>::=</span> <span><span>&#34;</span>otherwise<span>&#34;</span></span> &lt;<span>stmt</span>&gt; ;
<span></span>
<span>&lt;if-let&gt;</span>        <span>::=</span> <span><span>&#34;</span>iflet(<span>&#34;</span></span> &lt;<span>type</span>&gt; <span><span>&#34;</span>,<span>&#34;</span></span> &lt;<span>type</span>&gt; <span><span>&#34;</span>,<span>&#34;</span></span> &lt;<span>ident</span>&gt; <span><span>&#34;</span>,<span>&#34;</span></span> &lt;<span>expr</span>&gt; <span><span>&#34;</span>)<span>&#34;</span></span> &lt;<span>stmt</span>&gt; ;
<span>&lt;matches&gt;</span>       <span>::=</span> <span><span>&#34;</span>MATCHES(<span>&#34;</span></span> &lt;<span>ident</span>&gt; <span><span>&#34;</span>,<span>&#34;</span></span> &lt;<span>expr</span>&gt; <span><span>&#34;</span>)<span>&#34;</span></span> ;</pre></div>

<p dir="auto">The code</p>
<div dir="auto" data-snippet-clipboard-copy-content="Sumtype(A, (Type0, name0), ..., (TypeN, nameN))"><pre><span>Sumtype</span>(<span>A</span>, (<span>Type0</span>, <span>name0</span>), ..., (<span>TypeN</span>, <span>nameN</span>))</pre></div>
<p dir="auto">is expanded to</p>
<div dir="auto" data-snippet-clipboard-copy-content="struct A {
	enum {
		SUMTYPE_TAG_name0,
		...
		SUMTYPE_TAG_nameN,
	} tag;
	union {
		Type0 name0;
		...
		TypeN nameN;
	} variant;
}

struct A A_name0(Type0 name0) {
	return (struct A) {
		.tag = SUMTYPE_TAG_name0,
		.variant = {
			.name0 = name0
		}
	}
}

...

struct A A_nameN(TypeN nameN) {
	return (struct A) {
		.tag = SUMTYPE_TAG_nameN,
		.variant = {
			.nameN = nameN
		}
	}
}"><pre><span>struct</span> <span>A</span> {
	<span>enum</span> {
		<span>SUMTYPE_TAG_name0</span>,
		...
		<span>SUMTYPE_TAG_nameN</span>,
	} <span>tag</span>;
	<span>union</span> {
		<span>Type0</span> <span>name0</span>;
		...
		<span>TypeN</span> <span>nameN</span>;
	} <span>variant</span>;
}

<span>struct</span> <span>A</span> <span>A_name0</span>(<span>Type0</span> <span>name0</span>) {
	<span>return</span> (<span>struct</span> <span>A</span>) {
		.<span>tag</span> <span>=</span> <span>SUMTYPE_TAG_name0</span>,
		.<span>variant</span> <span>=</span> {
			.<span>name0</span> <span>=</span> <span>name0</span>
		}
	}
}

...

<span>struct</span> <span>A</span> <span>A_nameN</span>(<span>TypeN</span> <span>nameN</span>) {
	<span>return</span> (<span>struct</span> <span>A</span>) {
		.<span>tag</span> <span>=</span> <span>SUMTYPE_TAG_nameN</span>,
		.<span>variant</span> <span>=</span> {
			.<span>nameN</span> <span>=</span> <span>nameN</span>
		}
	}
}</pre></div>

<p dir="auto"><code>match</code> has the expected semantics: it sequentially tries to match the given instance of
a sum type against the given variants, and, if a match has succeeded, it executes the
corresponding statement and moves down to the next instruction
(<code>match(val) { ... } next-instruction;</code>). If all the matches have failed,
it executes the statement after <code>otherwise</code> and moves down to the next instruction.</p>
<p dir="auto">A complete <code>match</code> construct results in a single C statement.</p>

<p dir="auto"><code>let</code> accepts a type and a matched variant name as its arguments. If the variant is matched,
it binds a variable with the provided name to a pointer to the value of the provided type.</p>

<p dir="auto"><code>iflet</code> tries to match the given instance of a sum type against the given variant,
and, if a match has succeeded, it executes the corresponding statement.</p>
<p dir="auto">A complete <code>iflet</code> construct results in a single C statement.</p>

<p dir="auto"><code>MATCHES</code> just tests an instance of a sum type for a given variant.
If the given instance corresponds to the given variant, it expands to truthfulness, otherwise it expands to falsehood.</p>


<p dir="auto">The name of all the variants used, even in different types, need to be unique.
Otherwise, the names fo their tags will collide.</p>

<p dir="auto"><code>break</code>/<code>continue</code> inside a statement provided to <code>let</code>/<code>iflet</code>
but outside of any <code>for</code>/<code>while</code> loops in that statement just terminates the <code>match</code>/<code>iflet</code>
statement, but not any outside loop. Use a <code>goto</code> to break out of the outside loop.</p>

<p dir="auto">Bindings introduced by <code>let</code> are mutable, unless you write <code>const</code> in front of the name
of the type. The compiler will warn you about this if you match against a const pointer.</p>

<p dir="auto">Public domain or WTFPL, at your choice.</p>
</article></div></div>
  </body>
</html>
