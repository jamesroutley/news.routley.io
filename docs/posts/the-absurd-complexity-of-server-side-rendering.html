<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gist.github.com/Widdershin/98fd4f0e416e8eb2906d11fd1da62984">Original</a>
    <h1>The absurd complexity of server-side rendering</h1>
    
    <div id="readability-page-1" class="page"><div>
  <div id="file-ssr-md">
      
      <div id="file-ssr-md-readme">
    <article itemprop="text"><p dir="auto">In the olden days, HTML was prepared by the server, and JavaScript was little more than a garnish, considered by some to have a soapy taste.</p>
<p dir="auto">After a fashion, it was decided that sometimes our HTML is best rendered by JavaScript, running in a user&#39;s browser. While some would decry this new-found intimacy, the age of interactivity had begun.</p>
<p dir="auto">But all was not right in the world. Somewhere along the way, we had slipped. Our pages went uncrawled by Bing, time to first meaningful paint grew faster than npm, and it became clear: something must be done.</p>
<p dir="auto">And so it was decided that the applications first forged for the browser would also run on the server. We would render our HTML using the same logic on the server and the browser, and reap the advantages of both worlds. In a confusing series of events a name for this approach was agreed upon: Server-side rendering. What could go wrong?</p>
<p dir="auto">In dark rooms, in hushed tones, we <a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/" rel="nofollow">speak of colours</a>. We joke of nulls, commiserate about queues, but of colours we only whisper.</p>
<p dir="auto">That is because colours can hurt you. We shield our juniors from this knowledge, not because it&#39;s the wise thing to do, because once you confront the abyss there&#39;s no turning back.</p>
<p dir="auto">The common colours are no secret. Is a function synchronous or asynchronous? Does it mutate the arguments provided, or meekly return a value? Do I need to worry about it throwing an exception?</p>
<p dir="auto">In a certain light, colours are merely a way to categorise certain types of functions. Functions of a like colour can be used together without much consideration.</p>
<p dir="auto">It doesn&#39;t take much examination to see that colours beget complexity. Much of the art of application-level architecture is appropriately reducing and grouping colours to oppose this complexity.</p>
<p dir="auto">In the olden days, we had few colours to worry about. The task of managing incoming connections was abstracted to a simple mapping of request to response.</p>
<p dir="auto">All functions blocked execution for a while. Some would talk to databases or queues, and we were either content to wait, or to fire and forget while we returned the response.</p>
<p dir="auto">It&#39;s different in the browser. Our code competes with the user&#39;s ability to interact, and therefore we must be careful. We embrace asynchronous code, and with it all the complexity that comes from another colour.</p>
<p dir="auto">Server-side rendering (SSR) poses yet another problem on top of this one. Some functions were not designed to be used in both Node and the browser, and so we find another colour lurking.</p>
<p dir="auto">In order to support applications that make use of both server coloured functions and client coloured functions, bundlers were built, as clever as they are obtuse.</p>
<p dir="auto">Say you want to read a file as part of a request. This is only allowed in certain functions, designated by the framework to be  server-coloured.</p>
<p dir="auto">You cannot use a server-coloured function at the top level, since that implies it should be included in your browser, and you cannot use a client-coloured function with the framework&#39;s server-coloured functions.</p>
<p dir="auto">Next.js describes this approach as &#34;smart bundling&#34;. This may be smart, but it is not wise.</p>
<p dir="auto">It&#39;s hard enough to ensure that you&#39;re only using the correctly coloured function in the right place, until you consider that one of the main advantages of this sort of framework is sharing code across the server and the client.</p>
<p dir="auto">It&#39;s entirely up to you to ensure that you correctly manage your function colours. If you accidentally use the wrong sort of function in your shared code, your application will not work.</p>
<p dir="auto">If you&#39;re lucky, the bundler will catch this and throw a seemingly unrelated error. More likely, you&#39;ll experience a cryptic runtime error, followed by days of agony if you don&#39;t understand this problem. There is very little available in the way of static analysis to make this easier.</p>
<p dir="auto">To me, this seems like a very bad idea. What&#39;s worse, this important colour is generally treated as a footnote by the creators of these frameworks. Most developers only realise how bad this problem is when it&#39;s too late.</p>
<p dir="auto">I don&#39;t think that SSR apps are fundamentally a bad idea. That said, the way we&#39;re going about it right now is terrifyingly complex and error-prone.</p>
<p dir="auto">If you&#39;re considering using one of these frameworks, I would recommend you carefully consider if the complexity is worth it, especially for less-experienced members of your team.</p>
<p dir="auto">For those who do pursue SSR, I advise you to work towards better static analysis to help manage these problems. Rust has built a career by explicitly recognising that lifetimes exist and that we need better tools to work with them. A similar opportunity exists here for SSR apps.</p>
</article>
  </div>

  </div>
</div></div>
  </body>
</html>
