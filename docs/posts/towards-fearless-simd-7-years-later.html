<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://linebender.org/blog/towards-fearless-simd/">Original</a>
    <h1>Towards fearless SIMD, 7 years later</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
            <div>
                

<h3>Raph Levien, March 29, 2025</h3>
<p>Seven years ago I wrote a blog post <a href="https://raphlinus.github.io/rust/simd/2018/10/19/fearless-simd.html">Towards fearless SIMD</a>, outlining a vision for Rust as a compelling language for writing fast SIMD programs.
Where are we now?</p>
<p>Unfortunately, the present-day experience of writing SIMD in Rust is still pretty rough, though there has been progress, and there are promising efforts underway.
As in the previous post, this post will outline a possible vision.</p>
<p>Up to now, Linebender projects have not used SIMD, but that is changing.
As we work on CPU/GPU hybrid rendering techniques, it&#39;s clear that we need SIMD to get maximal performance of the CPU side.
We also see opportunities in faster color conversion and accelerated 2D geometry primitives.</p>
<p>This blog post is also a companion to a <a href="https://www.youtube.com/watch?v=y0WcCUKxk50">podcast</a> I recorded recently with André Popovitch.
That podcast is a good introduction to SIMD concepts, while this blog post focuses more on future directions.</p>
<h2 id="a-simple-example">A simple example</h2>
<p>As a running example, we&#39;ll compute a <a href="https://raphlinus.github.io/audio/2018/09/05/sigmoid.html">sigmoid</a> function for a vector of 4 values.
The scalar version is as follows:</p>
<pre data-lang="rust"><code data-lang="rust"><span>fn </span><span>sigmoid</span><span>(</span><span>x</span><span>: [</span><span>f32</span><span>; 4]) -&gt; [</span><span>f32</span><span>; </span><span>4</span><span>] {
</span><span>    x.</span><span>map</span><span>(|</span><span>y</span><span>| y / (</span><span>1.0 </span><span>+ y * y).</span><span>sqrt</span><span>())
</span><span>}
</span></code></pre>
<p>This particular simple code autovectorizes nicely (<a href="https://rust.godbolt.org/z/TfThE5r33">Godbolt link</a>), but more complex examples often fail to autovectorize, often because of subtle differences in floating point semantics.
(Editorial note: a previous version of this post didn&#39;t autovectorize (<a href="https://rust.godbolt.org/z/GoTEK3KT3">Godbolt</a>) because optimization level was set at <code>-O</code>, which is less aggressive than <code>-C opt-level=3</code>, the latter of which is the default for release builds)</p>
<h2 id="safety">Safety</h2>
<p>One of the biggest problems with writing SIMD in Rust is that all exposed SIMD intrinsics are marked as <code>unsafe</code>, even in cases where they can be used safely.
The reason is that support for SIMD features varies widely, and executing a SIMD instruction on a CPU that does not support it is undefined behavior – the chip can crash, ignore the instruction, or do something unexpected.
To be used safely, there must be some other mechanism to establish that the CPU does support the feature.</p>
<p>Here&#39;s the running example in hand-written intrinsic code, showing the need to write <code>unsafe</code> to access SIMD intrinsics at all:</p>
<pre data-lang="rust"><code data-lang="rust"><span>#[</span><span>cfg</span><span>(target_arch = &#34;</span><span>aarch64</span><span>&#34;)]
</span><span>fn </span><span>sigmoid_neon</span><span>(</span><span>x</span><span>: [</span><span>f32</span><span>; 4]) -&gt; [</span><span>f32</span><span>; </span><span>4</span><span>] {
</span><span>    </span><span>use </span><span>core::arch::aarch64::*;
</span><span>    </span><span>unsafe </span><span>{
</span><span>        </span><span>let</span><span> x_simd = core::mem::transmute(x);
</span><span>        </span><span>let</span><span> x_squared = </span><span>vmulq_f32</span><span>(x_simd, x_simd);
</span><span>        </span><span>let</span><span> ones = </span><span>vdupq_n_f32</span><span>(</span><span>1.0</span><span>);
</span><span>        </span><span>let</span><span> sum = </span><span>vaddq_f32</span><span>(ones, x_squared);
</span><span>        </span><span>let</span><span> sqrt = </span><span>vsqrtq_f32</span><span>(sum);
</span><span>        </span><span>let</span><span> ratio = </span><span>vdivq_f32</span><span>(x_simd, sqrt);
</span><span>        core::mem::transmute(ratio)
</span><span>    }
</span><span>}
</span><span>
</span><span>#[</span><span>cfg</span><span>(target_arch = &#34;</span><span>x86_64</span><span>&#34;)]
</span><span>fn </span><span>sigmoid_sse2</span><span>(</span><span>x</span><span>: [</span><span>f32</span><span>; 4]) -&gt; [</span><span>f32</span><span>; </span><span>4</span><span>] {
</span><span>    </span><span>use </span><span>core::arch::x86_64::*;
</span><span>    </span><span>unsafe </span><span>{
</span><span>        </span><span>let</span><span> x_simd = core::mem::transmute(x);
</span><span>        </span><span>let</span><span> x_squared = </span><span>_mm_mul_ps</span><span>(x_simd, x_simd);
</span><span>        </span><span>let</span><span> ones = </span><span>_mm_set1_ps</span><span>(</span><span>1.0</span><span>);
</span><span>        </span><span>let</span><span> sum = </span><span>_mm_add_ps</span><span>(ones, x_squared);
</span><span>        </span><span>let</span><span> sqrt = </span><span>_mm_sqrt_ps</span><span>(sum);
</span><span>        </span><span>let</span><span> ratio = </span><span>_mm_div_ps</span><span>(x_simd, sqrt);
</span><span>        core::mem::transmute(ratio)
</span><span>    }
</span><span>}
</span></code></pre>
<p>This is quite a simplified example.
For one, the SIMD width is fixed at 4 lanes (128 bits).
Most likely, in practice you&#39;d iterate over a larger slice, taking chunks equal to the natural SIMD width.</p>
<h2 id="multiversioning">Multiversioning</h2>
<p>A central problem important for SIMD is multiversioning and runtime dispatch.
In some cases, you know the exact CPU target, for example when compiling a binary you&#39;ll run only on your machine (in which case <code>target-cpu=native</code> is appropriate).
But when distributing software more widely, there may be a range of capabilities.
For highest performance, it&#39;s necessary to compile multiple versions of the code, and do runtime detection to dispatch to the best SIMD code the hardware can run.
This problem was expressed in the original fearless SIMD blog post, and there hasn&#39;t been significant advance at the Rust language level since then.</p>
<p>In the C++ world, the <a href="https://github.com/google/highway">Highway</a> library provides excellent SIMD support for a very wide range of targets, and also solves the multiversioning problem.
Among other uses are the codecs for the JPEG-XL image format.
Such codecs are an ideal use case for SIMD programming in general, and shipping them in a browser requires a good solution to multiversioning.
Highway has a really good explanation of <a href="https://github.com/kfjahnke/zimt/blob/multi_isa/examples/multi_isa_example/multi_simd_isa.md">their approach to multiversioning</a>.
It will be useful to study it carefully to see how they&#39;ve solved various problems.
And a concise way of saying what I&#39;d like to see is &#34;Highway for Rust.&#34;</p>
<p>One possible approach is a crate called <a href="https://docs.rs/multiversion/latest/multiversion/">multiversion</a>, which uses macros to replicate the code for multiple versions.
A more recent macro-based approach is <a href="https://github.com/a4lg/rust-target-feature-dispatch">rust-target-feature-dispatch</a>.
It is generally a similar approach to multiversion, and the specific differences are set out in that crate&#39;s <a href="https://github.com/a4lg/rust-target-feature-dispatch/blob/main/src/README.md">README</a>.</p>
<p>Another approach, as I believe first advocated in my 2018 blog post, is to write functions polymorphic on a zero-sized type representing the SIMD capabilities, then rely on monomorphization to create the various versions.
One motivation for this approach is to encode safety in Rust&#39;s type system.
Having the zero-sized token is proof of the underlying CPU having a certain level of SIMD capability, so calling those intrinsics is safe.
A major library that uses this approach is <a href="https://docs.rs/pulp/latest/pulp/">pulp</a>, which also powers the <a href="https://docs.rs/faer/latest/faer/">faer</a> linear algebra library.</p>
<p>I started putting together a pulp version of the running example, but ran into the immediate problem that it lacks a <code>sqrt</code> intrinsic (this would be easy enough to add, however).
It also works a bit differently, in that it only supports vectors of the natural width, not ones of a fixed width.
For general linear algebra, that&#39;s fine, but for some other applications it adds friction, for example colors with alpha are naturally chunks of 4 scalars.
To see an example of pulp code, as well as some discussion, see this <a href="https://xi.zulipchat.com/#narrow/channel/255911-rust/topic/Rust.20SIMD.20thoughts/near/489370476">Zulip thread</a>.</p>
<p>In <a href="https://github.com/raphlinus/fearless_simd/pull/2">fearless_simd#2</a> I propose a prototype of reasonably-ergonomic SIMD multiversioning.
Like the original fearless_simd prototype, vector data types are polymorphic on SIMD level.
The new prototype goes beyond that in several important ways.
For one, arithmetic traits in std::ops are implemented for vector types, so it&#39;s possible to add two vectors together, multiply vectors by scalars, etc.</p>
<p>Here&#39;s what the running example looks like in that prototype:</p>
<pre data-lang="rust"><code data-lang="rust"><span>#[</span><span>inline</span><span>(always)]
</span><span>fn </span><span>sigmoid_impl</span><span>&lt;S: Simd&gt;(</span><span>simd</span><span>: S, </span><span>x</span><span>: [</span><span>f32</span><span>; 4]) -&gt; [</span><span>f32</span><span>; </span><span>4</span><span>] {
</span><span>    </span><span>let</span><span> x_simd: f32x4&lt;S&gt; = x.</span><span>simd_into</span><span>(simd);
</span><span>    (x_simd / (</span><span>1.0 </span><span>+ x_simd * x_simd).</span><span>sqrt</span><span>()).</span><span>into</span><span>()
</span><span>}
</span><span>
</span><span>simd_dispatch!(</span><span>sigmoid</span><span>(level, rgba: [</span><span>f32</span><span>; </span><span>4</span><span>]) -&gt; [</span><span>f32</span><span>; </span><span>4</span><span>] = sigmoid_impl);
</span></code></pre>
<p>An advantage of the fearless_simd#2 prototype over pulp is a feature for downcasting based on SIMD level, so it&#39;s possible to write different code optimized for different chips.
See the <a href="https://github.com/raphlinus/fearless_simd/pull/2/files#diff-be8aece917a9235076ff8ec42749b1f1a803d2a3cbc2ccdd5425b405c74f7436">srgb example</a> in that pull request for more detail.
Though there are clear advantages, at this point I&#39;m not sure whether this is the direction to go.
It would be a lot of work to build out all the needed types and operations, with potentially a large amount of repetitive boilerplate code in the library, which in turn may cause issues with compile time.
Another possible direction is a smarter, compiler-like proc macro which synthesizes the SIMD intrinsics as needed based on the types and operations in the source program.</p>
<p>One additional consideration for Rust is that the implementation of runtime feature detection is <a href="https://internals.rust-lang.org/t/better-codegen-for-cpu-feature-detection/22083">slower than it should be</a>.
Thus, feature detection and dispatch shouldn&#39;t be done at every function call.
A good working solution is to do feature detection once, at the start of the program, then pass that token down through function calls.
It&#39;s workable but definitely an ergonomic paper cut.</p>
<h2 id="fp16-and-avx-512">FP16 and AVX-512</h2>
<p>A general trend in parallel computation, really fueled by AI workloads, is smaller scalars with higher throughputs.
While not yet common on x86_64, the FP16 extension is supported on all Apple Silicon desktop CPUs and most recent high-ish end ARM-based phones.
Since Neon is only 128 bits wide, having 8 lanes is welcome.
I find the f16 format to be especially useful for pixel values, as it can encode color values with more than enough precision to avoid visual artifacts (8 bits is not quite enough, though it is good enough for some applications, as long as you&#39;re not trying to do HDR).</p>
<p>Native Rust support for the <code>f16</code> type has not yet landed (tracked in <a href="https://github.com/rust-lang/rust/issues/125440">rust#125440</a>), which makes use of this scalar size harder.
However, there is some support in the <a href="https://docs.rs/half/latest/half/">half</a> library, and also the <a href="https://github.com/raphlinus/fearless_simd/pull/2">fearless_simd#2</a> prototype exports a number of FP16 Neon instructions through inline assembly.
When true f16 support lands, it will be possible to switch over to intrinsics, which will have better optimization and ergonomics (for example, the same method will splat constants converted to <code>f16</code> at compile time and <code>f32</code> variables to be converted at runtime).</p>
<p>AVX-512 is a somewhat controversial SIMD capability.
It first appeared in the ill-fated Larrabee project, which shipped in limited numbers as the Xeon Phi starting in 2010, and has since appeared in scattered Intel CPUs, but with compromises.
In particular, sprinkling even a small amount of AVX-512 code into a program could result in downclocking, reducing performance for all workloads (see <a href="https://stackoverflow.com/questions/56852812/simd-instructions-lowering-cpu-frequency#comment100256395_56852812">Stack Overflow thread on throttling</a> for more details).
These days, the most likely way to get a CPU with AVX-512 is an AMD Zen 4 or Zen 5; it is on their strength that AVX-512 makes up about 16% of computers in the Steam hardware survey.</p>
<p>The increased width is not the main reason to be enthusiastic about AVX-512.
Indeed, on Zen 4 and most Zen 5 chips, the datapath is 256 bits so full 512 bit instructions are &#34;double pumped.&#34; The most exciting aspect is predication based on masks, a common implementation technique on GPUs.
In particular, memory load and store operations are safe when the mask bit is zero, which is especially helpful for using SIMD efficiently on strings.
Without predication, a common technique is to write two loops, the first handling only even multiples of the SIMD width, and a second, usually written as scalars, to handle the odd-size &#34;tail&#34;.
There are lots of problems with this - code bloat, worse branch prediction, inability to exploit SIMD for chunks slightly less than the natural SIMD width (which gets worse as SIMD grows wider), and risks that the two loops don&#39;t have exactly the same behavior.</p>
<p>Going forward, Intel has proposed AVX10, and will hopefully ship AVX 10.2 chips in the next few years.
This extension has pretty much all of the features of AVX-512, with some cleanups and new features (until recently, AVX10 was defined has having a 256 bit base width and optionally 512, but 512 is now the baseline).
In addition, AVX10.2 will include 16-bit floats (currently available only in the Sapphire Rapids high-end server and workstation chips).</p>
<h2 id="about-std-simd">About std::simd</h2>
<p>The &#34;portable SIMD&#34; work has been going on for many years and currently has a home as the nightly <a href="https://doc.rust-lang.org/std/simd/index.html">std::simd</a>.
While I think it will be very useful in many applications, I am not personally very excited about it for my applications.
For one, because it emphasizes portability, it encourages a &#34;lowest common denominator&#34; approach, while I believe that for certain use cases it will be important to tune algorithms to best use the specific quirks of the different SIMD implementations.
For two, std::simd does not itself solve the multiversion problem.
From my perspective, it&#39;s probably best to consider it as a souped-up version of autovectorization.</p>
<h2 id="language-evolution">Language evolution</h2>
<p>Rust&#39;s out of the box support for SIMD is still quite rough, especially the need to use <code>unsafe</code> extensively.
While some of the gap can be filled with libraries, arguably it should be a goal of the language itself to support safe SIMD code.
There is progress in this direction.</p>
<p>First, the original version of <code>target_feature</code> requires <code>unsafe</code> to call into <em>any</em> function annotated with <code>#[target_feature]</code>.
A proposal to relax that so that functions already under a target_feature gate can call safely call into another function with the same gate is called &#34;<a href="https://rust-lang.github.io/rfcs/2396-target-feature-1.1.html">target_feature 1.1</a>&#34; and is scheduled to ship in 1.86.
Closely related, once inside the suitable target_feature gate, the majority of SIMD intrinsics (broadly, those that don&#39;t do memory access through pointers) should be considered safe by the compiler, and that feature (safe intrinsics in core::arch) is also in flight.</p>
<p>There&#39;s more that can be done to help the Rust compiler recognize when SIMD use is safe, in particular to allow target_features when a concrete witness to the SIMD level is passed in as a function argument.
The &#34;struct target_features&#34; proposal (<a href="https://github.com/rust-lang/rfcs/pull/3525">RFC 3525</a>) enables target_feature in such cases, and is one of the proposals considered in the proposed Rust project goal <a href="https://rust-lang.github.io/rust-project-goals/2025h1/simd-multiversioning.html">Nightly support for ergonomic SIMD multiversioning</a>.</p>
<p>In general, improving Rust SIMD support will require both libraries and support in the Rust language.
Different approaches at the library level may indicate different language features to best support them.</p>
<h2 id="looking-forward">Looking forward</h2>
<p>My main goal in putting these prototypes forward, as well as writing these blog posts, is to spark conversation on how best to support SIMD programming in Rust.
If done well, it is a great opportunity for the language, and fits in with its focus on performance and portability.</p>
<p>As we build out the <a href="https://xi.zulipchat.com/#narrow/channel/197075-vello/topic/Potato.20-.20a.20paper.20design.20for.20a.20CPU.2FGPU.20hybrid.20renderer">Vello hybrid CPU/GPU renderer</a>, performance of the CPU components will rely heavily on SIMD, so we need to invest in writing a lot of SIMD code.
The most conservative approach would be hand-writing unsafe intrinsics-based code for all targets, but that&#39;s a lot of work and the use of unsafe is unappealing.
I&#39;d love for the Rust ecosystem can come together and build good infrastructure, competitive with Highway.
For now, I think it&#39;s time to carefully consider the design space and try to come to consensus on what that should look like.</p>
<!-- TODO: not sure if this is the best link, we don't really have a project page for this -->


            </div>
        </div></div>
  </body>
</html>
