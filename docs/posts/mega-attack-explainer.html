<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://flaked.sockpuppet.org/2022/06/21/because-ive-obviously.html">Original</a>
    <h1>MEGA Attack Explainer</h1>
    
    <div id="readability-page-1" class="page"><div>
  <p>Because I’ve obviously gone all “Slurp Juice” on this MEGA attack thing, an attempt at a decoder ring.</p>

<p>First: the client doesn’t trust the server. That’s the whole point of the design. The attacker is Mega, the target is the client.</p>

<p>The client wants to store encrypted files on the server.</p>

<p>The client generates a mess of keys. An RSA key (we’ll spend a lot of time with this). A Curve25519 key. A key for every file they store. And then a master key, one key to rule them all, <code>k_m</code>.</p>

<p>The client is going to forget all of these keys. Mega wants you to be able to install a client somewhere else and log in and get all your files, and you can’t be schlepping the keys around on like a USB fob or something. So instead: as the client generates these keys, it encrypts them under <code>k_m</code> and uploads them to the server (along with the associated public keys, not encrypted, fine). The server doesn’t have <code>k_m</code> and so can’t decrypt them.</p>

<p>What the client remembers from machine to machine is their password. From the password they’ll derive everything else they need.</p>

<p>Decoder ring:</p>

<p><strong>PBKDF2</strong>: A hashy algorithm that takes a password (a “low entropy secret”) and spits out a crypto key (a “high entropy secret” suitable for plugging into AES or whatever).</p>

<p><strong>RSA-CRT</strong>: RSA where you precompute some of the values to make it go faster, notably <code>qInv</code>, which is 1/q mod p — p and q are the factors of your RSA modulus. You can sort of glaze over this.</p>

<p><strong>ECB</strong>: Block ciphers encrypt 16 byte chunks, not more not less. If you want to encrypt an arbitrary string, you need a “mode” that ties together multiple block cipher invocations. ECB is the default mode, and the dumbest mode: just feed every 16 bytes of the plaintext through the cipher and cat together the resulting ciphertexts.</p>

<p>ECB is <a href="https://cryptopals.com/sets/2/challenges/12">notoriously bad</a>. You can <a href="https://words.filippo.io/the-ecb-penguin/">see penguins through it</a>.</p>

<p><strong>Authenticated Ciphers</strong>: By itself, a cipher provides confidentiality: you can’t recover the plaintext from the ciphertext without a key. It doesn’t provide integrity: an attacker can flip bits in the ciphertext, and you’ll decrypt something different from the original plaintext (usually: with big random blocks of garbage).</p>

<p>Mega doesn’t authenticate the encrypted keys its client sends to the server; the server can rewrite chunks of those keys, and the client can’t easily tell that the server did that (the client forgot the keys, remember? The server is helping it remember).</p>

<p><strong>MAC</strong>: The hashy value that an authenticated cipher produces that you tack to the end of your ciphertext so clients can make sure that the value they’re decrypting is the original encrypted one, not some random thing an attacker rewrote into the ciphertext. Mega doesn’t use ‘em for encrypted keys.</p>

<p><strong>Oracles</strong>: You’re Alice, I’m Mallory. You hold Alice’s secret. I send you some value, and you use the secret to do some cryptography, wee! But you have a bug: something about the value Mallory sent you means you behave differently depending on what your secret is, and Mallory can watch carefully and notice your behavior changing. Mallory does this over and over again, using unauthenticated ciphertexts (see above) with successively better guesses. Mallory is conducting an “adaptive chosen ciphertext attack”; it’s adaptive because Mallory can see stepwise behavior from Alice and refine their guesses; it’s “chosen ciphertext” because Mallory controls the ciphertext values.</p>

<p><strong>Padding</strong>: Your crypto algorithm needs, say, 16 bytes of plaintext input. You have 6 bytes. Padding is the scheme you come up with to fill the other 10 bytes. With RSA, you have 40 bytes; your RSA key needs 216 more to make 256. Padding fills those bytes. Padding schemes are standardized.</p>

<p><strong>Bleichenbacher’s RSA Padding Attack</strong>: AKA BB’98. An oracle based on RSA padding mistakes: specifically, you ask someone to decrypt some ciphertext with an RSA key they have, but that ciphertext has bad padding. How the target handles that bad padding tells you something about the plaintext behind the ciphertext. Specifically: the attacker multiplies some value into the ciphertext (you can do that with RSA). The resulting ciphertext either does or doesn’t have valid padding, and the server either freaks out, or doesn’t freak out. If it doesn’t, you infer valid padding, and can further infer that the message is in some range of possible messages based on what you multiplied into the ciphertext. Repeat to gain more info about the message until you’ve recovered it.</p>

<p>This is the most popular attack against RSA. It happens because the most common standard padding mechanism for RSA (PKCS1v1.5) is super shitty and nobody can seem to get anyone to use anything else.</p>

<p><strong>The Padding Mega Uses</strong>: Just a bunch of zeroes. 😱</p>

<p><strong>The Encryption Mode Mega Uses</strong>: Unauthenticated ECB. 😱</p>

<p>You can:</p>

<ul>
<li><p>See penguins through their encrypted keys. (nbd)</p></li>

<li><p>Take an encrypted key and “randomize” a 16-bit block of it by flipping a bit (that block will decrypt to garbage)</p></li>

<li><p>Take a block and duplicate it to get that block to decrypt to itself twice (not that scary here but, like, a think you obviously shouldn’t be able to do!)</p></li>

<li><p>Remove a block to remove the associated 16 bytes of plaintext (same)</p>

<ul>
<li>Swap blocks with each other. They’ll decrypt to the original plaintext but in the new order you gave them. 😱</li>
</ul></li>
</ul>

<p>So then, the basic protocol works like this:</p>

<ol>
<li><p>You’re the client, you want to log in. You don’t have any of your keys, you just remember your password.</p>

<ol>
<li><p>You PBKDF2 the password to derive an identifier you send to the server so it knows you’re you. It looks you up with that identifier.</p></li>

<li><p>The server sends you back (<code>encrypted-sid</code>, <code>encrypted-rsa-key</code>) (not precisely, but close enough I think?). <code>encrypted-rsa-key</code> is something you, the client, originally sent to Mega. But Mega controls it; it can replace all or part of it with any bytes it wants.</p></li>

<li><p>You decrypt <code>encrypted-rsa-key</code>, using unauthenticated AES-ECB, with a key you derive from PBKDF2 of your password. You’ve now recovered your RSA key that you previously stored with mega.</p></li>

<li><p>You decrypt <code>encrypted-sid</code>, the encrypted session ID, encrypted under zero-padded RSA with the key Mega just had you decrypt.</p></li>

<li><p>You recover the ~40 byte SID from the 256-byte RSA plaintext. You ignore all the other bytes. You send the SID to the server.</p></li>

<li><p>The server’s like, yep, that’s the right SID. You’re now logged in I guess.</p></li>
</ol></li>
</ol>

<p>The <code>encrypted-rsa-key</code> from step 3 is a length-delimited 4-tuple (<code>p</code>, <code>q</code>, <code>d</code>, <code>qInv</code>), just basic RSA stuff. The client doesn’t check any of it; it just makes sure it gets 4 length-delimited values from the decrypted blob and assumes it’s a good RSA key and does RSA math with it.</p>

<p>But the server chooses the encrypted RSA key ciphertext. The server also chooses the encrypted SID value.</p>

<p>If the server is Backendal, Haller, and Paterson (BHP), the authors of this paper, the encrypted RSA key isn’t the one you sent. They flip bits in approximately the spot in the ciphertext corresponding to <code>qInv</code>, partially randomizing it. You trust it anyways, because it’s not authenticated. You do RSA math with this busted-ass CRT coefficient, and then you send a chunk of the result (which you don’t notice is fucky, because you aren’t checking the RSA padding, which is just all zeroes anyways) back to BHP for them to refine their guess.</p>

<p>BHP controls the SID along with the RSA key. The SID encodes a guess as to <code>q</code>, one of the RSA factors of the key. The busted-ass RSA key, plus the carefully chosen SID, set up a condition where the client will post back zero if the guess is less than <code>q</code>, and nonzero if greater.</p>

<p>Binary search, recover <code>q</code>, from <code>q</code> recover the whole RSA key.</p>

<p>It gets dumber!</p>

<p>Recall from the beginning that we generate a whole bunch of keys, not just one. One for each file. A Curve25519 key. They’re all encrypted under the same master key as the RSA key.</p>

<p>We can repeat the attack I just outlined, but instead of just randomizing <code>qInv</code>, because of ECB, we can swap in chunks of those other keys. Then we can run a similar oracle attack to the one we used to recover the RSA key to recover the plaintext of those chunks. We can do this with all the keys the user has uploaded, if we want.</p>

<p>Hopefully that makes more sense than my “Slurp Juice” tweets. I’m not trying to cover the attacks accurately or completely (I don’t fully grok them yet), just trying to clarify some jargon I was spouting.</p>

  </div></div>
  </body>
</html>
