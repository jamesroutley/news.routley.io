<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://unicorn-utterances.com/posts/documentation-driven-development">Original</a>
    <h1>Documentation Driven Development (2022)</h1>
    
    <div id="readability-page-1" class="page"><div> <article>   <div>   <section data-testid="post-body-div" aria-labelledby="blog-post-contents"> <h2 id="blog-post-contents" data-no-heading-link="">
Post contents
</h2> <div><p>If you&#39;ve spent much time in software development, you&#39;ve undoubtedly heard the expression ‚Äútest-driven development‚Äù or &#34;TDD&#34; for short.</p>
<p>The idea behind TDD is that you should write tests before programming an implementation. For example, say you want to implement a function called <code>calculateUserScore</code> based on a user&#39;s K/D in a video game. According to TDD, you should start by writing unit or integration tests to validate the input to an expected set of outputs.</p>
<p>Starting with tests can be a great help to ensure that your program runs the way it&#39;s intended when all is said and done. One downside, however, is that tests are still a form of coding; Yes, even when you follow good testing practices by <a href="https://unicorn-utterances.com/posts/five-suggestions-for-simpler-tests/#dont-include-logic">hardcoding values and avoiding complex logic</a>. It&#39;s still software development, and your tests still need to pass at the end of the day.</p>
<p>Making sure tests pass can be challenging to handle with the unknowns of implementation detail. After all, if you expect <code>parseInt</code> to act one way and it behaves another, you will likely have to rewrite all tests that worked off that assumption.</p>
<p>As a result, many choose to start implementing a function as a proof-of-concept, then adding tests incrementally alongside implementation: A TDD-lite, so to speak.</p>
<p>The problem is that, by doing so, you lose one of the most significant benefits of test-driven development: Its ability to force you to confront your API ahead of time.</p>
<h3 id="APIs-are-hard" data-header-text="APIs are hard"><span>APIs are hard</span></h3>
<p>You&#39;re working at an indie game company. A small top-down shooter that you&#39;ve written <a href="https://phaser.io/" target="_blank" rel="nofollow noopener noreferrer">in JavaScript with Phaser</a>. Your boss has asked you to implement a user score.</p>
<blockquote>
<p>&#34;No problem, <code>calculateUserScore</code> is going to be super simple - no need to overthink it.&#34;</p>
</blockquote>
<p>You think, typing out a basic implementation:</p>
<pre><code tabindex="0"><span><span>function</span><span> calculateUserScore</span><span>({</span><span>kills</span><span>, </span><span>deaths</span><span>}) {</span></span><span><span>    return</span><span> parseInt</span><span>(kills </span><span>/</span><span> deaths, </span><span>10</span><span>)</span></span><span><span>}</span></span></code></pre>
<p>But wait! What about assists? Do those count? Surely they should. Let&#39;s treat them as half of a kill.</p>
<pre><code tabindex="0"><span><span>function</span><span> calculateUserScore</span><span>({</span><span>kills</span><span>, </span><span>deaths</span><span>, </span><span>assists</span><span>}) {</span></span><span><span>    const</span><span> totalKills</span><span> =</span><span> kills </span><span>+</span><span> (assists </span><span>/</span><span> 2</span><span>);</span></span><span><span>    return</span><span> parseInt</span><span>(totalKills </span><span>/</span><span> deaths, </span><span>10</span><span>)</span></span><span><span>}</span></span></code></pre>
<p>Oh, but some kills should give bonus points. After all, who doesn&#39;t love a good 360 no-scope? While <code>kills</code> was simply a number before, let&#39;s change it to an array of objects like so:</p>
<pre><code tabindex="0"><span><span>const</span><span> killsArr</span><span> =</span><span> [</span></span><span><span>     {</span></span><span><span>          additionalPoints: </span><span>3</span></span><span><span>     }</span></span><span><span>]</span></span></code></pre>
<p>Now we can change out the function implementation for this:</p>
<pre><code tabindex="0"><span><span>function</span><span> calculateUserScore</span><span>({</span><span>killsArr</span><span>, </span><span>deaths</span><span>, </span><span>assists</span><span>}) {</span></span><span><span>    const</span><span> kills</span><span> =</span><span> killsArr.</span><span>length</span><span>;</span></span><span><span>    const</span><span> additionalPoints</span><span> =</span><span> killsArr.</span><span>reduce</span><span>((</span><span>prev</span><span>, </span><span>k</span><span>) </span><span>=&gt;</span><span> k.additionalPoints, </span><span>0</span><span>);</span></span><span><span>    const</span><span> totalKills</span><span> =</span><span> kills </span><span>+</span><span> (assists </span><span>/</span><span> 2</span><span>);</span></span><span><span>    return</span><span> parseInt</span><span>((totalKills </span><span>/</span><span> deaths) </span><span>+</span><span> additionalPoints, </span><span>10</span><span>);</span></span><span><span>}</span></span></code></pre>
<p>While we&#39;ve seen the function change, remember that your game may be making this calculation in multiple parts of the codebase. On top of this, maybe your API <em>still</em> isn&#39;t perfect for this function. What if you want to display the special kills with additional points after a match?</p>
<p>These drastic refactors mean that each iteration requires additional refactor work, likely delaying the time to ticket completion. This can impact releases dates or other scheduled launches.</p>
<p>Let&#39;s take a step back. Why did this happen?</p>
<p>These problems tend to happen because of miscommunication of scope. This miscommunication can be introduced between teams, from individual to individual, or even simply within your internal monolog.</p>
<h3 id="Testing-is-hard" data-header-text="Testing is hard"><span>Testing is hard</span></h3>
<p>One way that many suggest working around this problem is by following TDD. TDD can help force you to address your API ahead of time by adding in a feedback loop.</p>
<p>For example, before implementing the <code>calculateUserScore</code> function into your codebase, you might test against the first implementation, add a <code>test.todo</code> to add in assists, and realize you should update your API before moving forward.</p>
<p>However, while TDD forces you to address your API, it doesn&#39;t help you distinguish scope. This limitation of understanding of your scope may then, in turn, impact your API.</p>
<p>Let me explain:</p>
<p>Let&#39;s say that the ability to track special kills after the fact isn&#39;t possible to display on the match end until later in the development cycle. You know this and have decided to stop at the second implementation where <code>kills</code> is still a number. However, because the function is used repeatedly in the codebase, you&#39;ll need to do a larger refactor at a later date.</p>
<p>Had you spoken with other engineers, you may have realized that developments in the match-end screen were completed sooner than expected. Unfortunately, it&#39;s only caught now in code review after you&#39;ve made the implementation, forcing a refactor immediately.</p>
<h3 id="Getting-to-the-point" data-header-text="Getting to the point"><span>Getting to the point</span></h3>
<p>Okay, okay, I&#39;ll get to the point: There&#39;s a better way to address this &#34;API shift&#34; problem better than TDD. This &#34;better way&#34; is &#34;Documentation driven development.&#34;</p>
<picture><source type="image/avif" sizes="(max-width: 400) 480px, 896px" srcset="/_vercel/image?url=%2Fcontent%2Fcrutchcorn%2Fposts%2Fdocumentation-driven-development%2Fdrake.png&amp;w=480&amp;q=100 480w, /_vercel/image?url=%2Fcontent%2Fcrutchcorn%2Fposts%2Fdocumentation-driven-development%2Fdrake.png&amp;w=896&amp;q=100 896w"/><source type="image/webp" sizes="(max-width: 400) 480px, 896px" srcset="/_vercel/image?url=%2Fcontent%2Fcrutchcorn%2Fposts%2Fdocumentation-driven-development%2Fdrake.png&amp;w=480&amp;q=100 480w, /_vercel/image?url=%2Fcontent%2Fcrutchcorn%2Fposts%2Fdocumentation-driven-development%2Fdrake.png&amp;w=896&amp;q=100 896w"/><source type="image/png" sizes="(max-width: 400) 480px, 896px" srcset="/_vercel/image?url=%2Fcontent%2Fcrutchcorn%2Fposts%2Fdocumentation-driven-development%2Fdrake.png&amp;w=480&amp;q=100 480w, /_vercel/image?url=%2Fcontent%2Fcrutchcorn%2Fposts%2Fdocumentation-driven-development%2Fdrake.png&amp;w=896&amp;q=100 896w"/><img width="768" height="768" decoding="async" loading="lazy" alt="Drake looking away from &#34;Test Driven Development&#34; but a thumbs up for &#34;Documentation Driven Development&#34;" data-zoom-src="/content/crutchcorn/posts/documentation-driven-development/drake.png"/></picture>
<p>Writing docs first can help you iron out implementation details ahead of time before making tough calls about implementing a design. Even reference APIs can help you make a lot of designs.</p>
<p>Let&#39;s loop back to the older example of <code>calculateUserScore</code>. Just like before, you called a short meeting to gather the requirements from the team. This time though, you start by writing documentation instead of starting with the code.</p>
<p>You include a mention of what the API should look like based on these requirements:</p>
<pre><code tabindex="0"><span><span>/**</span></span><span><span> * This function should calculate the user score based on the K/D of the</span></span><span><span> * player.</span></span><span><span> *</span></span><span><span> * Assists should count as half of a kill</span></span><span><span> *</span></span><span><span> * TODO: Add specialty kills with bonus points</span></span><span><span> */</span></span><span><span>function</span><span> calculateUserScore</span><span>(</span><span>props</span><span>:</span><span> {</span><span>kills</span><span>:</span><span> number</span><span>, </span><span>deaths</span><span>:</span><span> number</span><span>, </span><span>assists</span><span>:</span><span> number</span><span>})</span><span>:</span><span> number</span><span>;</span></span></code></pre>
<p>You also decide to showcase some usages in your docs:</p>
<pre><code tabindex="0"><span><span>caluculateUserScore</span><span>({kills: </span><span>12</span><span>, deaths: </span><span>9</span><span>, assists: </span><span>3</span><span>});</span></span></code></pre>
<p>While working through these docs, you decide to quickly sketch out what the future API might look like when bonus points are added.</p>
<pre><code tabindex="0"><span><span>/*</span></span><span><span> * TODO: In the future, it might look something like this to accommodate</span></span><span><span> * bonus points</span></span><span><span> */</span></span><span><span>calculateUserScore</span><span>({kills: [{killedUser: </span><span>&#39;user1&#39;</span><span>, bonusPoints: </span><span>1</span><span>}], deaths: </span><span>0</span><span>, assists: </span><span>0</span><span>});</span></span></code></pre>
<p>After writing this, you realize you should utilize an array for the kills property first rather than later on. You don&#39;t have to have bonus points, but instead, you can simply track an <code>unknown</code> user for each kill and change it in the future.</p>
<pre><code tabindex="0"><span><span>calculateUserScore</span><span>({kills: [{killedUser: </span><span>&#39;unknown&#39;</span><span>}], deaths: </span><span>0</span><span>, assists: </span><span>0</span><span>});</span></span></code></pre>
<p>While this might seem obvious to us now, it may not be so clear at the moment. This is the benefit of Documentation-Driven Development: It forces you to go through a self-feedback cycle on your APIs and the scope of your work.</p>
<h3 id="Refining-the-process" data-header-text="Refining the process"><span>Refining the process</span></h3>
<p>OK, I get it. Documentation is seen as a chore. While I could go on about &#34;your medicine is good for you,&#34; I&#39;ve got good news for you: Documentation doesn&#39;t mean what you think it means.</p>
<p>Documentation can be found in many forms: design mockups, API reference docs, well-formed tickets, future plan writeups, and more.</p>
<p>Essentially, anything that can be used to communicate your thoughts on a topic is documentation.</p>
<p>In fact, this <em>includes</em> tests. üò± Tests are a good way of conveying API examples for your usage. TDD itself may be enough on its own to convey that information for future you, while other times, it may be a good companion alongside other forms of documentation.</p>
<p>In particular, if you&#39;re good about <a href="https://kentcdodds.com/blog/write-tests" target="_blank" rel="nofollow noopener noreferrer">writing primarily integration tests</a>, you&#39;re actually writing out usage API docs while writing testing code.</p>
<p>This is particularly true when writing developer tooling or libraries. Seeing a usage example of how to do something is extremely helpful, especially with a test to validate its behavior alongside it.</p>
<hr/>
<p>Another thing &#34;documentation-driven development&#34; does not prescribe is &#34;write once and done.&#34; This idea is a myth and may be harmful to your scope and budgets - time or otherwise.</p>
<p>As we showed with the <code>calculateUserScore</code> example, you may need to modify your designs before moving forward for the final release: that&#39;s okay. Docs influence code influence docs. The same is true for TDD.</p>
<hr/>
<p>DDD isn&#39;t just useful for developing code for production, either. In interviews, some good advice to communicate your development workflow is to write code comments and <strong>then</strong> write the solution. This allows you to make mistakes in the documentation phase (of writing comments) that will be less time-costly than if you&#39;d made a mistake in implementation.</p>
<p>By doing this, you can communicate with your interviewer that you know how to work in a team and find well-defined goals. These will allow you to work towards an edgecase-free* implementation with those understandings.</p>
<h3 id="Bring-it-back-now-yall" data-header-text="Bring it back now y&#39;all"><span>Bring it back now y&#39;all</span></h3>
<p>I realize this article already has more twists than an M. Night Shyamalan film, but here‚Äôs one more; documentation driven development, as we‚Äôve explored today, is an established concept. It‚Äôs simply called by other names:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Behavior-driven_development" target="_blank" rel="nofollow noopener noreferrer">Behavioral Driven Development (BDD)</a></li>
<li><a href="https://en.wikipedia.org/wiki/Acceptance_test%E2%80%93driven_development" target="_blank" rel="nofollow noopener noreferrer">Acceptance Test-Driven Development (ATDD)</a></li>
</ul>
<p>Each of these refers to a form of validating the functionality of code behind user behavior. Each encourages a stronger communication method that often includes documentation in the process. &#34;DDD&#34; is just another form of this type of logic.</p>
<h3 id="Conclusion" data-header-text="Conclusion"><span>Conclusion</span></h3>
<p>I&#39;ve been using documentation-driven development as a concept to drive my coding on some projects. Among them was my project <a href="https://github.com/crutchcorn/cli-testing-library" target="_blank" rel="nofollow noopener noreferrer"><code>CLI Testing Library</code></a>, which allowed me to write a <a href="https://github.com/crutchcorn/cli-testing-library/tree/main/docs" target="_blank" rel="nofollow noopener noreferrer">myriad of documentation pages</a> as well as <a href="https://github.com/crutchcorn/cli-testing-library/issues/2" target="_blank" rel="nofollow noopener noreferrer">verbose GitHub issues</a>.</p>
<p>Both of these forced me to better refine my goals and what I was looking for. The end-product, I believe, is better as a result.</p>
<p>What do you think? Is &#34;DDD&#34; a good idea? Will you be using it for your next project?</p>
<p>Let us know what you think, and <a href="https://discord.gg/FMcvc6T" target="_blank" rel="nofollow noopener noreferrer">join our Discord</a> to talk to us more about it!</p></div>  </section>    </div>  </article> </div></div>
  </body>
</html>
