<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.migops.com/blog/2022/06/09/important-postgresql-14-update-to-avoid-silent-corruption-of-indexes/">Original</a>
    <h1>Important PostgreSQL 14 update to avoid silent corruption of indexes</h1>
    
    <div id="readability-page-1" class="page"><article id="post-2204" itemtype="https://schema.org/CreativeWork" itemscope="itemscope">

	
	
<div>

	
	<!-- .entry-header -->

	
	<div itemprop="text">

		
		
<p>On June 16 2022, a new PostgreSQL 14 minor release will be published by the <a href="https://www.postgresql.org/community/">PostgreSQL Global Development Group</a>. The new <a href="https://www.postgresql.org/message-id/165473835807.573551.1512237163040609764%40wrigleys.postgresql.org" target="_blank" rel="noreferrer noopener"><strong><em>PostgreSQL 14.4 release</em></strong> </a>fixes an issue with all versions of PostgreSQL 14 that can lead to silent corruption of indexes. Usually, the community announces a minor version update on the second Tuesday of the second month of each quarter. However, when some emergency fixes are required, we may see such important release updates soon after a minor release. In this article, I am going to talk about the Important PostgreSQL 14 update to avoid silent corruption of indexes. We shall also discuss how to overcome this corruption with a rebuild of an impacted index.</p>



<figure><img width="649" height="321" src="https://www.migops.com/blog/wp-content/uploads/2022/06/Important_PostgreSQL_release_update.png" alt="Important PostgreSQL 14 release update to avoid silent corruption of indexes" srcset="https://www.migops.com/blog/wp-content/uploads/2022/06/Important_PostgreSQL_release_update.png 649w, https://www.migops.com/blog/wp-content/uploads/2022/06/Important_PostgreSQL_release_update-300x148.png 300w" sizes="(max-width: 649px) 100vw, 649px"/></figure>



<h5><strong><span>What PostgreSQL versions are impacted ?</span></strong></h5>



<p>Following minor releases of PostgreSQL 14 are all impacted.</p>



<ul><li><a href="https://www.postgresql.org/docs/release/14.0/"><span>14.0</span></a></li><li><a href="https://www.postgresql.org/docs/release/14.1/"><span>14.1</span></a></li><li><span><a href="https://www.postgresql.org/docs/release/14.2/">14.2</a></span></li><li><a href="https://www.postgresql.org/docs/release/14.3/"><span>14.3</span></a></li></ul>



<h5><span><strong>Description</strong></span></h5>



<p>The problem was introduced in PostgreSQL 14 by a VACUUM improvement to ignore certain transactions that are executing CREATE INDEX CONCURRENTLY and REINDEX CONCURRENTLY. These changes caused the indexes created with the CONCURRENTLY option to miss heap tuples that were HOT-updated and HOT-pruned during the index creation. CONCURRENTLY is generally used to rebuild or create an Index online without an <a href="https://www.postgresql.org/docs/14/explicit-locking.html" target="_blank" rel="noreferrer noopener"><strong><em>Access Exclusive lock</em></strong></a> on its table.</p>



<p>The cause of the silent data corruption in indexes is an existing issue in the concurrent build of indexes using CREATE INDEX CONCURRENTLY or REINDEX CONCURRENTLY. This leaves the newly rebuilt Indexes to remain in a silently corrupted state. Your databases with PostgreSQL 14 are impacted if you have run such Index rebuild commands. See <mark><a href="https://www.postgresql.org/message-id/flat/17485-396609c6925b982d%40postgresql.org"><strong><em>this discussion</em></strong></a></mark> for more details.</p>



<p>Due to this reason, everyone using PostgreSQL 14.0 or 14.1 or 14.2 or 14.3 should upgrade to PostgreSQL 14.4 as soon as the release is published.</p>



<h5><span><strong>How to identify whether any of your Indexes are impacted ? </strong></span></h5>



<p>In order to identify such corrupted Indexes, we could use <a href="https://www.postgresql.org/docs/current/app-pgamcheck.html" target="_blank" rel="noopener"><span>pg_amcheck</span></a> if it is a b-tree index. pg_amcheck verifies the presence of all heap tuples has index tuples in an index. It verifies whether tuple(or data) pointed in the index really exists. We may write a detailed article on <a href="https://www.postgresql.org/docs/current/app-pgamcheck.html" target="_blank" rel="noopener"><span>pg_amcheck</span></a> to help you understand it in detail. For now, following can be considered as an example.</p>



<pre>-- Create the extension</pre>



<p>If you need assistance in finding and fixing the corrupted indexes, please send an email to s<strong>ales@migops.com</strong> or fill the following form.</p>


  <!-- .wpforms-container -->


<h5><strong><span>How to fix it on existing PostgreSQL 14 versions ? </span></strong></h5>



<p>If you are facing this issue and need to solve the problem immediately, the solution is to run CREATE INDEX or REINDEX without using CONCURRENTLY. You have to drop the existing corrupted indexes and then then create them.</p>



<p>This could cause downtime as we are not using the concurrently flag. However, to speed up the Index creations, you may want to use the <span><a href="https://www.postgresql.org/docs/current/app-reindexdb.html" target="_blank" rel="noopener">reindexdb command</a></span> with -j (jobs) for increased parallelism, but do not set the <em><strong>--concurrently</strong></em> flag.</p>



<h5><span><strong>pg_repack may not support here</strong></span></h5>



<p><span><a href="https://github.com/reorg/pg_repack" target="_blank" rel="noopener">pg_repack</a></span> is a widely used extension to rebuild tables and indexes online. However, pg_repack does use the CONCURRENTLY option internally. In case you have used an automated job to rebuild indexes or tables using pg_repack, then, those indexes that got rebuilt may have got impacted too. In addition to that, pg_repack cannot be used a solution but you must follow the above mentioned approach of REINDEX without CONCURRENTLY as a solution instead.</p>



<h5><strong><span>What about your PostgreSQL databases on DBaaS ?</span></strong></h5>



<p>Customers using any of the following 3 cloud vendors to host their PostgreSQL 14 Instances are also impacted.</p>



<ul><li><span><a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_PostgreSQL.html#PostgreSQL.Concepts.General.DBVersions" target="_blank" rel="noopener">AWS - Amazon Web Services</a></span> <ul><li>Amazon RDS does support PostgreSQL 14. So, your databases may be impacted. Please validate and perform the necessary steps as discussed above. </li></ul></li><li><span>GCP - Google Cloud</span> <ul><li>Cloud SQL for PostgreSQL does allow customers to create database of version PostgreSQL 14. So, you may have to validate using the above steps and perform the necessary action. </li></ul></li><li><span>Azure - Microsoft Azure Cloud</span> <ul><li>Azure Database for PostgreSQL only supports up to PostgreSQL 11 version for Single Server and up to PostgreSQL 13 on flexible server. However, Hyperscale (Citus) on PostgreSQL 14 may have been impacted but we would recommend you to validate with your respective cloud vendor. </li></ul></li></ul>



<h5><span><strong>Conclusion</strong></span></h5>



<p>After upgrading to PostgreSQL 14.4 you can safely use CREATE INDEX CONCURRENTLY or REINDEX CONCURRENTLY. However, it is important to validate and make sure that your databases are not impacted with such corruption. In case you need assistance in verifying whether any of your databases are impacted and how to fix it, please <span><a href="https://www.migops.com/contact-us/">contact us</a></span> or send an email to <span>sales@migops.com</span>. You may also fill the following form.</p>


  <!-- .wpforms-container -->
		
		
			</div><!-- .entry-content .clear -->
</div>

	
</article></div>
  </body>
</html>
