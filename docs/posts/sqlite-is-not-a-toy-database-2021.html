<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://antonz.org/sqlite-is-not-a-toy-database/">Original</a>
    <h1>SQLite is not a toy database (2021)</h1>
    
    <div id="readability-page-1" class="page"><div>
<div>
<article>
<div>
<div>
<header>

</header>
<p><em>English â€¢ <a href="https://habr.com/ru/post/547448/">Russian</a> â€¢ <a href="https://sysarmy.com/blog/posts/sqlite-no-es-una-base-de-datos-de-juguete/">Spanish</a></em></p>
<p>Whether you are a developer, data analyst, QA engineer, DevOps person, or product manager - SQLite is a perfect tool for you. Here is why.</p>
<p>A few well-known facts to get started:</p>
<ul>
<li>SQLite is the most common DBMS in the world, shipped with all popular operating systems.</li>
<li>SQLite is serverless.</li>
<li>For developers, SQLite is embedded directly into the app.</li>
<li>For everyone else, there is a convenient database console (REPL), provided as a single file (sqlite3.exe on Windows, sqlite3 on Linux / macOS).</li>
</ul>
<h2 id="console-import-and-export">Console, import, and export</h2>
<p>The console is a killer SQLite feature for data analysis: more powerful than Excel and more simple than <code>pandas</code>. One can import CSV data with a single command, the table is created automatically:</p>
<pre tabindex="0"><code>&gt; .import --csv city.csv city
&gt; select count(*) from city;
1117
</code></pre><p>The console supports basic SQL features and shows query results in a nice ASCII-drawn table. Advanced SQL features are also supported, but more on that later.</p>
<div><pre tabindex="0"><code data-lang="sql"><span>select</span>
  <span>century</span> <span>||</span> <span>&#39; century&#39;</span> <span>as</span> <span>dates</span>,
  <span>count</span>(<span>*</span>) <span>as</span> <span>city_count</span>
<span>from</span> <span>history</span>
<span>group</span> <span>by</span> <span>century</span>
<span>order</span> <span>by</span> <span>century</span> <span>desc</span>;
</code></pre></div><pre tabindex="0"><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   dates    â”‚ city_count â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 21 century â”‚ 1          â”‚
â”‚ 20 century â”‚ 263        â”‚
â”‚ 19 century â”‚ 189        â”‚
â”‚ 18 century â”‚ 191        â”‚
â”‚ 17 century â”‚ 137        â”‚
â”‚ ...        â”‚ ...        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre><p>Data could be exported as SQL, CSV, JSON, even Markdown and HTML. Takes just a couple of commands:</p>
<pre tabindex="0"><code>.mode json
.output city.json
select city, foundation_year, timezone from city limit 10;
.shell cat city.json
</code></pre><div><pre tabindex="0"><code data-lang="json">[
    { <span>&#34;city&#34;</span>: <span>&#34;Amsterdam&#34;</span>, <span>&#34;foundation_year&#34;</span>: <span>1300</span>, <span>&#34;timezone&#34;</span>: <span>&#34;UTC+1&#34;</span> },
    { <span>&#34;city&#34;</span>: <span>&#34;Berlin&#34;</span>, <span>&#34;foundation_year&#34;</span>: <span>1237</span>, <span>&#34;timezone&#34;</span>: <span>&#34;UTC+1&#34;</span> },
    { <span>&#34;city&#34;</span>: <span>&#34;Helsinki&#34;</span>, <span>&#34;foundation_year&#34;</span>: <span>1548</span>, <span>&#34;timezone&#34;</span>: <span>&#34;UTC+2&#34;</span> },
    { <span>&#34;city&#34;</span>: <span>&#34;Monaco&#34;</span>, <span>&#34;foundation_year&#34;</span>: <span>1215</span>, <span>&#34;timezone&#34;</span>: <span>&#34;UTC+1&#34;</span> },
    { <span>&#34;city&#34;</span>: <span>&#34;Moscow&#34;</span>, <span>&#34;foundation_year&#34;</span>: <span>1147</span>, <span>&#34;timezone&#34;</span>: <span>&#34;UTC+3&#34;</span> },
    { <span>&#34;city&#34;</span>: <span>&#34;Reykjavik&#34;</span>, <span>&#34;foundation_year&#34;</span>: <span>874</span>, <span>&#34;timezone&#34;</span>: <span>&#34;UTC&#34;</span> },
    { <span>&#34;city&#34;</span>: <span>&#34;Sarajevo&#34;</span>, <span>&#34;foundation_year&#34;</span>: <span>1461</span>, <span>&#34;timezone&#34;</span>: <span>&#34;UTC+1&#34;</span> },
    { <span>&#34;city&#34;</span>: <span>&#34;Stockholm&#34;</span>, <span>&#34;foundation_year&#34;</span>: <span>1252</span>, <span>&#34;timezone&#34;</span>: <span>&#34;UTC+1&#34;</span> },
    { <span>&#34;city&#34;</span>: <span>&#34;Tallinn&#34;</span>, <span>&#34;foundation_year&#34;</span>: <span>1219</span>, <span>&#34;timezone&#34;</span>: <span>&#34;UTC+2&#34;</span> },
    { <span>&#34;city&#34;</span>: <span>&#34;Zagreb&#34;</span>, <span>&#34;foundation_year&#34;</span>: <span>1094</span>, <span>&#34;timezone&#34;</span>: <span>&#34;UTC+1&#34;</span> }
]
</code></pre></div><p>If you are more of a BI than a console person - popular data exploration tools like <a href="https://www.metabase.com/">Metabase</a>, <a href="https://redash.io/">Redash</a>, and <a href="https://superset.apache.org/">Superset</a> all support SQLite.</p>
<h2 id="native-json">Native JSON</h2>
<p>There is nothing more convenient than SQLite for analyzing and transforming JSON. You can select data directly from a file as if it were a regular table. Or import data into the table and select from there.</p>
<div><pre tabindex="0"><code data-lang="sql"><span>select</span>
  <span>json_extract</span>(<span>value</span>, <span>&#39;$.iso.code&#39;</span>) <span>as</span> <span>code</span>,
  <span>json_extract</span>(<span>value</span>, <span>&#39;$.iso.number&#39;</span>) <span>as</span> <span>num</span>,
  <span>json_extract</span>(<span>value</span>, <span>&#39;$.name&#39;</span>) <span>as</span> <span>name</span>,
  <span>json_extract</span>(<span>value</span>, <span>&#39;$.units.major.name&#39;</span>) <span>as</span> <span>unit</span>
<span>from</span>
  <span>json_each</span>(<span>readfile</span>(<span>&#39;currency.sample.json&#39;</span>))
;
</code></pre></div><pre tabindex="0"><code>â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ code â”‚ num â”‚      name       â”‚   unit   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ARS  â”‚ 032 â”‚ Argentine peso  | peso     â”‚
â”‚ CHF  â”‚ 756 â”‚ Swiss Franc     â”‚ franc    â”‚
â”‚ EUR  â”‚ 978 â”‚ Euro            â”‚ euro     â”‚
â”‚ GBP  â”‚ 826 â”‚ British Pound   â”‚ pound    â”‚
â”‚ INR  â”‚ 356 â”‚ Indian Rupee    â”‚ rupee    â”‚
â”‚ JPY  â”‚ 392 â”‚ Japanese yen    â”‚ yen      â”‚
â”‚ MAD  â”‚ 504 â”‚ Moroccan Dirham â”‚ dirham   â”‚
â”‚ RUR  â”‚ 643 â”‚ Russian Rouble  â”‚ rouble   â”‚
â”‚ SOS  â”‚ 706 â”‚ Somali Shilling â”‚ shilling â”‚
â”‚ USD  â”‚ 840 â”‚ US Dollar       â”‚ dollar   â”‚
â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre><p>Doesnâ€™t matter how deep the JSON is - you can extract any nested object:</p>
<div><pre tabindex="0"><code data-lang="sql"><span>select</span>
  <span>json_extract</span>(<span>value</span>, <span>&#39;$.id&#39;</span>) <span>as</span> <span>id</span>,
  <span>json_extract</span>(<span>value</span>, <span>&#39;$.name&#39;</span>) <span>as</span> <span>name</span>
<span>from</span>
  <span>json_tree</span>(<span>readfile</span>(<span>&#39;industry.sample.json&#39;</span>))
<span>where</span>
  <span>path</span> <span>like</span> <span>&#39;$[%].industries&#39;</span>
;
</code></pre></div><pre tabindex="0"><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   id   â”‚         name         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 7.538  â”‚ Internet provider    â”‚
â”‚ 7.539  â”‚ IT consulting        â”‚
â”‚ 7.540  â”‚ Software development â”‚
â”‚ 9.399  â”‚ Mobile communication â”‚
â”‚ 9.400  â”‚ Fixed communication  â”‚
â”‚ 9.401  â”‚ Fiber-optics         â”‚
â”‚ 43.641 â”‚ Audit                â”‚
â”‚ 43.646 â”‚ Insurance            â”‚
â”‚ 43.647 â”‚ Bank                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre><h2 id="ctes-and-set-operations">CTEs and set operations</h2>
<p>Of course, SQLite supports Common Table Expressions (<code>WITH</code> clause) and <code>JOIN</code>s, I wonâ€™t even give examples here. If the data is hierarchical (the table refers to itself through a column like <code>parent_id</code>) - <code>WITH RECURSIVE</code> will come in handy. Any hierarchy, no matter how deep, can be â€˜unrolledâ€™ with a single query.</p>
<div><pre tabindex="0"><code data-lang="sql"><span>with</span> <span>recursive</span> <span>tmp</span>(<span>id</span>, <span>name</span>, <span>level</span>) <span>as</span> (
  <span>select</span> <span>id</span>, <span>name</span>, <span>1</span> <span>as</span> <span>level</span>
  <span>from</span> <span>area</span>
  <span>where</span> <span>parent_id</span> <span>is</span> <span>null</span>

  <span>union</span> <span>all</span>

  <span>select</span>
    <span>area</span>.<span>id</span>,
    <span>tmp</span>.<span>name</span> <span>||</span> <span>&#39;, &#39;</span> <span>||</span> <span>area</span>.<span>name</span> <span>as</span> <span>name</span>,
    <span>tmp</span>.<span>level</span> <span>+</span> <span>1</span> <span>as</span> <span>level</span>
  <span>from</span> <span>area</span>
    <span>join</span> <span>tmp</span> <span>on</span> <span>area</span>.<span>parent_id</span> <span>=</span> <span>tmp</span>.<span>id</span>
)

<span>select</span> <span>*</span> <span>from</span> <span>tmp</span>;
</code></pre></div><pre tabindex="0"><code>â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”
â”‚  id  â”‚           name           â”‚ level â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 93   â”‚ US                       â”‚ 1     â”‚
â”‚ 768  â”‚ US, Washington DC        â”‚ 2     â”‚
â”‚ 1833 â”‚ US, Washington           â”‚ 2     â”‚
â”‚ 2987 â”‚ US, Washington, Bellevue â”‚ 3     â”‚
â”‚ 3021 â”‚ US, Washington, Everett  â”‚ 3     â”‚
â”‚ 3039 â”‚ US, Washington, Kent     â”‚ 3     â”‚
â”‚ ...  â”‚ ...                      â”‚ ...   â”‚
â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre><p>Sets? No problem: <code>UNION</code>, <code>INTERSECT</code>, <code>EXCEPT</code> are at your service.</p>
<div><pre tabindex="0"><code data-lang="sql"><span>select</span> <span>employer_id</span>
<span>from</span> <span>employer_area</span>
<span>where</span> <span>area_id</span> <span>=</span> <span>1</span>

<span>except</span>

<span>select</span> <span>employer_id</span>
<span>from</span> <span>employer_area</span>
<span>where</span> <span>area_id</span> <span>=</span> <span>2</span>;
</code></pre></div><p>Calculate one column based on several others? Enter generated columns:</p>
<div><pre tabindex="0"><code data-lang="sql"><span>alter</span> <span>table</span> <span>vacancy</span>
<span>add</span> <span>column</span> <span>salary_net</span> <span>integer</span> <span>as</span> (
  <span>case</span> <span>when</span> <span>salary_gross</span> <span>=</span> <span>true</span> <span>then</span>
    <span>round</span>(<span>salary_from</span><span>/</span><span>1</span>.<span>04</span>)
  <span>else</span>
    <span>salary_from</span>
  <span>end</span>
);
</code></pre></div><p>Generated columns can be queried in the same way as â€˜normalâ€™ ones:</p>
<div><pre tabindex="0"><code data-lang="sql"><span>select</span>
  <span>substr</span>(<span>name</span>, <span>1</span>, <span>40</span>) <span>as</span> <span>name</span>,
  <span>salary_net</span>
<span>from</span> <span>vacancy</span>
<span>where</span>
  <span>salary_currency</span> <span>=</span> <span>&#39;JPY&#39;</span>
  <span>and</span> <span>salary_net</span> <span>is</span> <span>not</span> <span>null</span>
<span>limit</span> <span>10</span>;
</code></pre></div><h2 id="math-statistics">Math statistics</h2>
<p>Descriptive statistics? Easy: mean, median, percentiles, standard deviation, you name it. Youâ€™ll have to load an extension, but itâ€™s also a single command (and a single file).</p>
<div><pre tabindex="0"><code data-lang="sql">.<span>load</span> <span>sqlite3</span><span>-</span><span>stats</span>

<span>select</span>
  <span>count</span>(<span>*</span>) <span>as</span> <span>book_count</span>,
  <span>cast</span>(<span>avg</span>(<span>num_pages</span>) <span>as</span> <span>integer</span>) <span>as</span> <span>mean</span>,
  <span>cast</span>(<span>median</span>(<span>num_pages</span>) <span>as</span> <span>integer</span>) <span>as</span> <span>median</span>,
  <span>mode</span>(<span>num_pages</span>) <span>as</span> <span>mode</span>,
  <span>percentile_90</span>(<span>num_pages</span>) <span>as</span> <span>p90</span>,
  <span>percentile_95</span>(<span>num_pages</span>) <span>as</span> <span>p95</span>,
  <span>percentile_99</span>(<span>num_pages</span>) <span>as</span> <span>p99</span>
<span>from</span> <span>books</span>;
</code></pre></div><pre tabindex="0"><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
â”‚ book_count â”‚ mean â”‚ median â”‚ mode â”‚ p90 â”‚ p95 â”‚ p99  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1483       â”‚ 349  â”‚ 295    â”‚ 256  â”‚ 640 â”‚ 817 â”‚ 1199 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
</code></pre><blockquote>
<p><strong>Note on extensions</strong>. SQLite is missing a lot of functions compared to other DBMSs like PostgreSQL. But they are easy to add, which is what people do - so it turns out quite a mess.</p>
<p>Therefore, I decided to make a consistent set of extensions, divided by domain area and compiled for major operating systems:</p>
<p><a href="https://github.com/nalgeon/sqlean/">sqlean @ GitHub</a></p>
</blockquote>
<p>More fun with statistics. You can plot the data distribution right in the console. Look how cute it is:</p>
<div><pre tabindex="0"><code data-lang="sql"><span>with</span> <span>slots</span> <span>as</span> (
  <span>select</span>
    <span>num_pages</span><span>/</span><span>100</span> <span>as</span> <span>slot</span>,
    <span>count</span>(<span>*</span>) <span>as</span> <span>book_count</span>
  <span>from</span> <span>books</span>
  <span>group</span> <span>by</span> <span>slot</span>
),
<span>max</span> <span>as</span> (
  <span>select</span> <span>max</span>(<span>book_count</span>) <span>as</span> <span>value</span>
  <span>from</span> <span>slots</span>
)
<span>select</span>
  <span>slot</span>,
  <span>book_count</span>,
  <span>printf</span>(<span>&#39;%.&#39;</span> <span>||</span> (<span>book_count</span> <span>*</span> <span>30</span> <span>/</span> <span>max</span>.<span>value</span>) <span>||</span> <span>&#39;c&#39;</span>, <span>&#39;*&#39;</span>) <span>as</span> <span>bar</span>
<span>from</span> <span>slots</span>, <span>max</span>
<span>order</span> <span>by</span> <span>slot</span>;
</code></pre></div><pre tabindex="0"><code>â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ slot â”‚ book_count â”‚              bar               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0    â”‚ 116        â”‚ *********                      â”‚
â”‚ 1    â”‚ 254        â”‚ ********************           â”‚
â”‚ 2    â”‚ 376        â”‚ ****************************** â”‚
â”‚ 3    â”‚ 285        â”‚ **********************         â”‚
â”‚ 4    â”‚ 184        â”‚ **************                 â”‚
â”‚ 5    â”‚ 90         â”‚ *******                        â”‚
â”‚ 6    â”‚ 54         â”‚ ****                           â”‚
â”‚ 7    â”‚ 41         â”‚ ***                            â”‚
â”‚ 8    â”‚ 31         â”‚ **                             â”‚
â”‚ 9    â”‚ 15         â”‚ *                              â”‚
â”‚ 10   â”‚ 11         â”‚ *                              â”‚
â”‚ 11   â”‚ 12         â”‚ *                              â”‚
â”‚ 12   â”‚ 2          â”‚ *                              â”‚
â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre><h2 id="performance">Performance</h2>
<p>SQLite works with hundreds of millions of records just fine. Regular <code>INSERT</code>s show about 240K records per second on my laptop. And if you connect the CSV file as a virtual table (there is an extension for that) - inserts become 2 times faster.</p>
<div><pre tabindex="0"><code data-lang="sql">.<span>load</span> <span>sqlite3</span><span>-</span><span>vsv</span>

<span>create</span> <span>virtual</span> <span>table</span> <span>temp</span>.<span>blocks_csv</span> <span>using</span> <span>vsv</span>(
    <span>filename</span><span>=</span><span>&#34;ipblocks.csv&#34;</span>,
    <span>schema</span><span>=</span><span>&#34;create table x(network text, geoname_id integer, registered_country_geoname_id integer, represented_country_geoname_id integer, is_anonymous_proxy integer, is_satellite_provider integer, postal_code text, latitude real, longitude real, accuracy_radius integer)&#34;</span>,
    <span>columns</span><span>=</span><span>10</span>,
    <span>header</span><span>=</span><span>on</span>,
    <span>nulls</span><span>=</span><span>on</span>
);
</code></pre></div><div><pre tabindex="0"><code data-lang="sql">.<span>timer</span> <span>on</span>
<span>insert</span> <span>into</span> <span>blocks</span>
<span>select</span> <span>*</span> <span>from</span> <span>blocks_csv</span>;

<span>Run</span> <span>Time</span>: <span>real</span> <span>5</span>.<span>176</span> <span>user</span> <span>4</span>.<span>716420</span> <span>sys</span> <span>0</span>.<span>403866</span>
</code></pre></div><div><pre tabindex="0"><code data-lang="sql"><span>select</span> <span>count</span>(<span>*</span>) <span>from</span> <span>blocks</span>;
<span>3386629</span>

<span>Run</span> <span>Time</span>: <span>real</span> <span>0</span>.<span>095</span> <span>user</span> <span>0</span>.<span>021972</span> <span>sys</span> <span>0</span>.<span>063716</span>
</code></pre></div><p>There is a popular opinion among developers that SQLite is not suitable for the web, because it doesnâ€™t support concurrent access. This is a myth. In the write-ahead log mode (available since long ago), there can be as many concurrent readers as you want. There can be only one concurrent writer, but often one is enough.</p>
<p>SQLite is a perfect fit for small websites and applications. <a href="https://sqlite.org/">sqlite.org</a> uses SQLite as a database, not bothering with optimization (â‰ˆ200 requests per page). It handles 700K visits per month and serves pages faster than 95% of websites Iâ€™ve seen.</p>
<h2 id="documents-graphs-and-search">Documents, graphs, and search</h2>
<p>SQLite supports partial indexes and indexes on expressions, as â€˜bigâ€™ DBMSs do. You can build indexes on generated columns and even turn SQLite into a document database. Just store raw JSON and build indexes on <code>json_extract()</code>-ed columns:</p>
<div><pre tabindex="0"><code data-lang="sql"><span>create</span> <span>table</span> <span>currency</span>(
  <span>body</span> <span>text</span>,
  <span>code</span> <span>text</span> <span>as</span> (<span>json_extract</span>(<span>body</span>, <span>&#39;$.code&#39;</span>)),
  <span>name</span> <span>text</span> <span>as</span> (<span>json_extract</span>(<span>body</span>, <span>&#39;$.name&#39;</span>))
);

<span>create</span> <span>index</span> <span>currency_code_idx</span> <span>on</span> <span>currency</span>(<span>code</span>);

<span>insert</span> <span>into</span> <span>currency</span>
<span>select</span> <span>value</span>
<span>from</span> <span>json_each</span>(<span>readfile</span>(<span>&#39;currency.sample.json&#39;</span>));
</code></pre></div><div><pre tabindex="0"><code data-lang="sql"><span>explain</span> <span>query</span> <span>plan</span>
<span>select</span> <span>name</span> <span>from</span> <span>currency</span> <span>where</span> <span>code</span> <span>=</span> <span>&#39;EUR&#39;</span>;

<span>QUERY</span> <span>PLAN</span>
<span>`</span><span>--SEARCH TABLE currency USING INDEX currency_code_idx (code=?)
</span></code></pre></div><blockquote>
<p>You can also use SQLite as a graph database. A bunch of complex <code>WITH RECURSIVE</code> will do the trick, or maybe youâ€™ll prefer to add a bit of Python:</p>
<p><a href="https://github.com/dpapathanasiou/simple-graph">simple-graph @ GitHub</a></p>
</blockquote>
<p>Full-text search works out of the box:</p>
<div><pre tabindex="0"><code data-lang="sql"><span>create</span> <span>virtual</span> <span>table</span> <span>books_fts</span>
<span>using</span> <span>fts5</span>(<span>title</span>, <span>author</span>, <span>publisher</span>);

<span>insert</span> <span>into</span> <span>books_fts</span>
<span>select</span> <span>title</span>, <span>author</span>, <span>publisher</span> <span>from</span> <span>books</span>;

<span>select</span>
  <span>author</span>,
  <span>substr</span>(<span>title</span>, <span>1</span>, <span>30</span>) <span>as</span> <span>title</span>,
  <span>substr</span>(<span>publisher</span>, <span>1</span>, <span>10</span>) <span>as</span> <span>publisher</span>
<span>from</span> <span>books_fts</span>
<span>where</span> <span>books_fts</span> <span>match</span> <span>&#39;ann&#39;</span>
<span>limit</span> <span>5</span>;
</code></pre></div><pre tabindex="0"><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       author        â”‚             title              â”‚ publisher  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Ruby Ann Boxcar     â”‚ Ruby Ann&#39;s Down Home Trailer P â”‚ Citadel    â”‚
â”‚ Ruby Ann Boxcar     â”‚ Ruby Ann&#39;s Down Home Trailer P â”‚ Citadel    â”‚
â”‚ Lynne Ann DeSpelder â”‚ The Last Dance: Encountering D â”‚ McGraw-Hil â”‚
â”‚ Daniel Defoe        â”‚ Robinson Crusoe                â”‚ Ann Arbor  â”‚
â”‚ Ann Thwaite         â”‚ Waiting for the Party: The Lif â”‚ David R. G â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre><p>Maybe you need an in-memory database for intermediate computations? Single line of python code:</p>
<div><pre tabindex="0"><code data-lang="python"><span>db</span> <span>=</span> <span>sqlite3</span><span>.</span><span>connect</span>(<span>&#34;:memory:&#34;</span>)
</code></pre></div><p>You can even access it from multiple connections:</p>
<div><pre tabindex="0"><code data-lang="python"><span>db</span> <span>=</span> <span>sqlite3</span><span>.</span><span>connect</span>(<span>&#34;file::memory:?cache=shared&#34;</span>)
</code></pre></div><h2 id="and-so-much-more">And so much more</h2>
<p>There are fancy window functions (just like in PostgreSQL). <code>UPSERT</code>, <code>UPDATE FROM</code>, and <code>generate_series()</code>. R-Tree indexes. Regular expressions, fuzzy-search, and geo. In terms of features, SQLite can compete with any â€˜bigâ€™ DBMS.</p>
<p>There is also great tooling around SQLite. I especially like <a href="https://datasette.io/">Datasette</a> - an open-source tool for exploring and publishing SQLite datasets. And <a href="https://dbeaver.io/">DBeaver</a> is an excellent open-source database IDE with the latest SQLite versions support.</p>
<p>I hope this article will inspire you to try SQLite. Thanks for reading!</p>
<p><a href="https://news.ycombinator.com/item?id=26580614">Comments on Hacker News</a></p>
<p><em>Follow <a href="https://twitter.com/ohmypy"><strong>@ohmypy</strong></a> on Twitter and <a href="http://digest.antonz.org/"><strong>subscribe by email</strong></a> to keep up with new posts</em>Â ğŸš€</p>
</div>
</div></article>

</div>
</div></div>
  </body>
</html>
