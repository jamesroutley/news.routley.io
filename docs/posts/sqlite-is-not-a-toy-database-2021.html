<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://antonz.org/sqlite-is-not-a-toy-database/">Original</a>
    <h1>SQLite is not a toy database (2021)</h1>
    
    <div id="readability-page-1" class="page"><div>
<div>
<article>
<div>
<div>
<header>

</header>
<p><em>English • <a href="https://habr.com/ru/post/547448/">Russian</a> • <a href="https://sysarmy.com/blog/posts/sqlite-no-es-una-base-de-datos-de-juguete/">Spanish</a></em></p>
<p>Whether you are a developer, data analyst, QA engineer, DevOps person, or product manager - SQLite is a perfect tool for you. Here is why.</p>
<p>A few well-known facts to get started:</p>
<ul>
<li>SQLite is the most common DBMS in the world, shipped with all popular operating systems.</li>
<li>SQLite is serverless.</li>
<li>For developers, SQLite is embedded directly into the app.</li>
<li>For everyone else, there is a convenient database console (REPL), provided as a single file (sqlite3.exe on Windows, sqlite3 on Linux / macOS).</li>
</ul>
<h2 id="console-import-and-export">Console, import, and export</h2>
<p>The console is a killer SQLite feature for data analysis: more powerful than Excel and more simple than <code>pandas</code>. One can import CSV data with a single command, the table is created automatically:</p>
<pre tabindex="0"><code>&gt; .import --csv city.csv city
&gt; select count(*) from city;
1117
</code></pre><p>The console supports basic SQL features and shows query results in a nice ASCII-drawn table. Advanced SQL features are also supported, but more on that later.</p>
<div><pre tabindex="0"><code data-lang="sql"><span>select</span>
  <span>century</span> <span>||</span> <span>&#39; century&#39;</span> <span>as</span> <span>dates</span>,
  <span>count</span>(<span>*</span>) <span>as</span> <span>city_count</span>
<span>from</span> <span>history</span>
<span>group</span> <span>by</span> <span>century</span>
<span>order</span> <span>by</span> <span>century</span> <span>desc</span>;
</code></pre></div><pre tabindex="0"><code>┌────────────┬────────────┐
│   dates    │ city_count │
├────────────┼────────────┤
│ 21 century │ 1          │
│ 20 century │ 263        │
│ 19 century │ 189        │
│ 18 century │ 191        │
│ 17 century │ 137        │
│ ...        │ ...        │
└────────────┴────────────┘
</code></pre><p>Data could be exported as SQL, CSV, JSON, even Markdown and HTML. Takes just a couple of commands:</p>
<pre tabindex="0"><code>.mode json
.output city.json
select city, foundation_year, timezone from city limit 10;
.shell cat city.json
</code></pre><div><pre tabindex="0"><code data-lang="json">[
    { <span>&#34;city&#34;</span>: <span>&#34;Amsterdam&#34;</span>, <span>&#34;foundation_year&#34;</span>: <span>1300</span>, <span>&#34;timezone&#34;</span>: <span>&#34;UTC+1&#34;</span> },
    { <span>&#34;city&#34;</span>: <span>&#34;Berlin&#34;</span>, <span>&#34;foundation_year&#34;</span>: <span>1237</span>, <span>&#34;timezone&#34;</span>: <span>&#34;UTC+1&#34;</span> },
    { <span>&#34;city&#34;</span>: <span>&#34;Helsinki&#34;</span>, <span>&#34;foundation_year&#34;</span>: <span>1548</span>, <span>&#34;timezone&#34;</span>: <span>&#34;UTC+2&#34;</span> },
    { <span>&#34;city&#34;</span>: <span>&#34;Monaco&#34;</span>, <span>&#34;foundation_year&#34;</span>: <span>1215</span>, <span>&#34;timezone&#34;</span>: <span>&#34;UTC+1&#34;</span> },
    { <span>&#34;city&#34;</span>: <span>&#34;Moscow&#34;</span>, <span>&#34;foundation_year&#34;</span>: <span>1147</span>, <span>&#34;timezone&#34;</span>: <span>&#34;UTC+3&#34;</span> },
    { <span>&#34;city&#34;</span>: <span>&#34;Reykjavik&#34;</span>, <span>&#34;foundation_year&#34;</span>: <span>874</span>, <span>&#34;timezone&#34;</span>: <span>&#34;UTC&#34;</span> },
    { <span>&#34;city&#34;</span>: <span>&#34;Sarajevo&#34;</span>, <span>&#34;foundation_year&#34;</span>: <span>1461</span>, <span>&#34;timezone&#34;</span>: <span>&#34;UTC+1&#34;</span> },
    { <span>&#34;city&#34;</span>: <span>&#34;Stockholm&#34;</span>, <span>&#34;foundation_year&#34;</span>: <span>1252</span>, <span>&#34;timezone&#34;</span>: <span>&#34;UTC+1&#34;</span> },
    { <span>&#34;city&#34;</span>: <span>&#34;Tallinn&#34;</span>, <span>&#34;foundation_year&#34;</span>: <span>1219</span>, <span>&#34;timezone&#34;</span>: <span>&#34;UTC+2&#34;</span> },
    { <span>&#34;city&#34;</span>: <span>&#34;Zagreb&#34;</span>, <span>&#34;foundation_year&#34;</span>: <span>1094</span>, <span>&#34;timezone&#34;</span>: <span>&#34;UTC+1&#34;</span> }
]
</code></pre></div><p>If you are more of a BI than a console person - popular data exploration tools like <a href="https://www.metabase.com/">Metabase</a>, <a href="https://redash.io/">Redash</a>, and <a href="https://superset.apache.org/">Superset</a> all support SQLite.</p>
<h2 id="native-json">Native JSON</h2>
<p>There is nothing more convenient than SQLite for analyzing and transforming JSON. You can select data directly from a file as if it were a regular table. Or import data into the table and select from there.</p>
<div><pre tabindex="0"><code data-lang="sql"><span>select</span>
  <span>json_extract</span>(<span>value</span>, <span>&#39;$.iso.code&#39;</span>) <span>as</span> <span>code</span>,
  <span>json_extract</span>(<span>value</span>, <span>&#39;$.iso.number&#39;</span>) <span>as</span> <span>num</span>,
  <span>json_extract</span>(<span>value</span>, <span>&#39;$.name&#39;</span>) <span>as</span> <span>name</span>,
  <span>json_extract</span>(<span>value</span>, <span>&#39;$.units.major.name&#39;</span>) <span>as</span> <span>unit</span>
<span>from</span>
  <span>json_each</span>(<span>readfile</span>(<span>&#39;currency.sample.json&#39;</span>))
;
</code></pre></div><pre tabindex="0"><code>┌──────┬─────┬─────────────────┬──────────┐
│ code │ num │      name       │   unit   │
├──────┼─────┼─────────────────┼──────────┤
│ ARS  │ 032 │ Argentine peso  | peso     │
│ CHF  │ 756 │ Swiss Franc     │ franc    │
│ EUR  │ 978 │ Euro            │ euro     │
│ GBP  │ 826 │ British Pound   │ pound    │
│ INR  │ 356 │ Indian Rupee    │ rupee    │
│ JPY  │ 392 │ Japanese yen    │ yen      │
│ MAD  │ 504 │ Moroccan Dirham │ dirham   │
│ RUR  │ 643 │ Russian Rouble  │ rouble   │
│ SOS  │ 706 │ Somali Shilling │ shilling │
│ USD  │ 840 │ US Dollar       │ dollar   │
└──────┴─────┴─────────────────┴──────────┘
</code></pre><p>Doesn’t matter how deep the JSON is - you can extract any nested object:</p>
<div><pre tabindex="0"><code data-lang="sql"><span>select</span>
  <span>json_extract</span>(<span>value</span>, <span>&#39;$.id&#39;</span>) <span>as</span> <span>id</span>,
  <span>json_extract</span>(<span>value</span>, <span>&#39;$.name&#39;</span>) <span>as</span> <span>name</span>
<span>from</span>
  <span>json_tree</span>(<span>readfile</span>(<span>&#39;industry.sample.json&#39;</span>))
<span>where</span>
  <span>path</span> <span>like</span> <span>&#39;$[%].industries&#39;</span>
;
</code></pre></div><pre tabindex="0"><code>┌────────┬──────────────────────┐
│   id   │         name         │
├────────┼──────────────────────┤
│ 7.538  │ Internet provider    │
│ 7.539  │ IT consulting        │
│ 7.540  │ Software development │
│ 9.399  │ Mobile communication │
│ 9.400  │ Fixed communication  │
│ 9.401  │ Fiber-optics         │
│ 43.641 │ Audit                │
│ 43.646 │ Insurance            │
│ 43.647 │ Bank                 │
└────────┴──────────────────────┘
</code></pre><h2 id="ctes-and-set-operations">CTEs and set operations</h2>
<p>Of course, SQLite supports Common Table Expressions (<code>WITH</code> clause) and <code>JOIN</code>s, I won’t even give examples here. If the data is hierarchical (the table refers to itself through a column like <code>parent_id</code>) - <code>WITH RECURSIVE</code> will come in handy. Any hierarchy, no matter how deep, can be ‘unrolled’ with a single query.</p>
<div><pre tabindex="0"><code data-lang="sql"><span>with</span> <span>recursive</span> <span>tmp</span>(<span>id</span>, <span>name</span>, <span>level</span>) <span>as</span> (
  <span>select</span> <span>id</span>, <span>name</span>, <span>1</span> <span>as</span> <span>level</span>
  <span>from</span> <span>area</span>
  <span>where</span> <span>parent_id</span> <span>is</span> <span>null</span>

  <span>union</span> <span>all</span>

  <span>select</span>
    <span>area</span>.<span>id</span>,
    <span>tmp</span>.<span>name</span> <span>||</span> <span>&#39;, &#39;</span> <span>||</span> <span>area</span>.<span>name</span> <span>as</span> <span>name</span>,
    <span>tmp</span>.<span>level</span> <span>+</span> <span>1</span> <span>as</span> <span>level</span>
  <span>from</span> <span>area</span>
    <span>join</span> <span>tmp</span> <span>on</span> <span>area</span>.<span>parent_id</span> <span>=</span> <span>tmp</span>.<span>id</span>
)

<span>select</span> <span>*</span> <span>from</span> <span>tmp</span>;
</code></pre></div><pre tabindex="0"><code>┌──────┬──────────────────────────┬───────┐
│  id  │           name           │ level │
├──────┼──────────────────────────┼───────┤
│ 93   │ US                       │ 1     │
│ 768  │ US, Washington DC        │ 2     │
│ 1833 │ US, Washington           │ 2     │
│ 2987 │ US, Washington, Bellevue │ 3     │
│ 3021 │ US, Washington, Everett  │ 3     │
│ 3039 │ US, Washington, Kent     │ 3     │
│ ...  │ ...                      │ ...   │
└──────┴──────────────────────────┴───────┘
</code></pre><p>Sets? No problem: <code>UNION</code>, <code>INTERSECT</code>, <code>EXCEPT</code> are at your service.</p>
<div><pre tabindex="0"><code data-lang="sql"><span>select</span> <span>employer_id</span>
<span>from</span> <span>employer_area</span>
<span>where</span> <span>area_id</span> <span>=</span> <span>1</span>

<span>except</span>

<span>select</span> <span>employer_id</span>
<span>from</span> <span>employer_area</span>
<span>where</span> <span>area_id</span> <span>=</span> <span>2</span>;
</code></pre></div><p>Calculate one column based on several others? Enter generated columns:</p>
<div><pre tabindex="0"><code data-lang="sql"><span>alter</span> <span>table</span> <span>vacancy</span>
<span>add</span> <span>column</span> <span>salary_net</span> <span>integer</span> <span>as</span> (
  <span>case</span> <span>when</span> <span>salary_gross</span> <span>=</span> <span>true</span> <span>then</span>
    <span>round</span>(<span>salary_from</span><span>/</span><span>1</span>.<span>04</span>)
  <span>else</span>
    <span>salary_from</span>
  <span>end</span>
);
</code></pre></div><p>Generated columns can be queried in the same way as ‘normal’ ones:</p>
<div><pre tabindex="0"><code data-lang="sql"><span>select</span>
  <span>substr</span>(<span>name</span>, <span>1</span>, <span>40</span>) <span>as</span> <span>name</span>,
  <span>salary_net</span>
<span>from</span> <span>vacancy</span>
<span>where</span>
  <span>salary_currency</span> <span>=</span> <span>&#39;JPY&#39;</span>
  <span>and</span> <span>salary_net</span> <span>is</span> <span>not</span> <span>null</span>
<span>limit</span> <span>10</span>;
</code></pre></div><h2 id="math-statistics">Math statistics</h2>
<p>Descriptive statistics? Easy: mean, median, percentiles, standard deviation, you name it. You’ll have to load an extension, but it’s also a single command (and a single file).</p>
<div><pre tabindex="0"><code data-lang="sql">.<span>load</span> <span>sqlite3</span><span>-</span><span>stats</span>

<span>select</span>
  <span>count</span>(<span>*</span>) <span>as</span> <span>book_count</span>,
  <span>cast</span>(<span>avg</span>(<span>num_pages</span>) <span>as</span> <span>integer</span>) <span>as</span> <span>mean</span>,
  <span>cast</span>(<span>median</span>(<span>num_pages</span>) <span>as</span> <span>integer</span>) <span>as</span> <span>median</span>,
  <span>mode</span>(<span>num_pages</span>) <span>as</span> <span>mode</span>,
  <span>percentile_90</span>(<span>num_pages</span>) <span>as</span> <span>p90</span>,
  <span>percentile_95</span>(<span>num_pages</span>) <span>as</span> <span>p95</span>,
  <span>percentile_99</span>(<span>num_pages</span>) <span>as</span> <span>p99</span>
<span>from</span> <span>books</span>;
</code></pre></div><pre tabindex="0"><code>┌────────────┬──────┬────────┬──────┬─────┬─────┬──────┐
│ book_count │ mean │ median │ mode │ p90 │ p95 │ p99  │
├────────────┼──────┼────────┼──────┼─────┼─────┼──────┤
│ 1483       │ 349  │ 295    │ 256  │ 640 │ 817 │ 1199 │
└────────────┴──────┴────────┴──────┴─────┴─────┴──────┘
</code></pre><blockquote>
<p><strong>Note on extensions</strong>. SQLite is missing a lot of functions compared to other DBMSs like PostgreSQL. But they are easy to add, which is what people do - so it turns out quite a mess.</p>
<p>Therefore, I decided to make a consistent set of extensions, divided by domain area and compiled for major operating systems:</p>
<p><a href="https://github.com/nalgeon/sqlean/">sqlean @ GitHub</a></p>
</blockquote>
<p>More fun with statistics. You can plot the data distribution right in the console. Look how cute it is:</p>
<div><pre tabindex="0"><code data-lang="sql"><span>with</span> <span>slots</span> <span>as</span> (
  <span>select</span>
    <span>num_pages</span><span>/</span><span>100</span> <span>as</span> <span>slot</span>,
    <span>count</span>(<span>*</span>) <span>as</span> <span>book_count</span>
  <span>from</span> <span>books</span>
  <span>group</span> <span>by</span> <span>slot</span>
),
<span>max</span> <span>as</span> (
  <span>select</span> <span>max</span>(<span>book_count</span>) <span>as</span> <span>value</span>
  <span>from</span> <span>slots</span>
)
<span>select</span>
  <span>slot</span>,
  <span>book_count</span>,
  <span>printf</span>(<span>&#39;%.&#39;</span> <span>||</span> (<span>book_count</span> <span>*</span> <span>30</span> <span>/</span> <span>max</span>.<span>value</span>) <span>||</span> <span>&#39;c&#39;</span>, <span>&#39;*&#39;</span>) <span>as</span> <span>bar</span>
<span>from</span> <span>slots</span>, <span>max</span>
<span>order</span> <span>by</span> <span>slot</span>;
</code></pre></div><pre tabindex="0"><code>┌──────┬────────────┬────────────────────────────────┐
│ slot │ book_count │              bar               │
├──────┼────────────┼────────────────────────────────┤
│ 0    │ 116        │ *********                      │
│ 1    │ 254        │ ********************           │
│ 2    │ 376        │ ****************************** │
│ 3    │ 285        │ **********************         │
│ 4    │ 184        │ **************                 │
│ 5    │ 90         │ *******                        │
│ 6    │ 54         │ ****                           │
│ 7    │ 41         │ ***                            │
│ 8    │ 31         │ **                             │
│ 9    │ 15         │ *                              │
│ 10   │ 11         │ *                              │
│ 11   │ 12         │ *                              │
│ 12   │ 2          │ *                              │
└──────┴────────────┴────────────────────────────────┘
</code></pre><h2 id="performance">Performance</h2>
<p>SQLite works with hundreds of millions of records just fine. Regular <code>INSERT</code>s show about 240K records per second on my laptop. And if you connect the CSV file as a virtual table (there is an extension for that) - inserts become 2 times faster.</p>
<div><pre tabindex="0"><code data-lang="sql">.<span>load</span> <span>sqlite3</span><span>-</span><span>vsv</span>

<span>create</span> <span>virtual</span> <span>table</span> <span>temp</span>.<span>blocks_csv</span> <span>using</span> <span>vsv</span>(
    <span>filename</span><span>=</span><span>&#34;ipblocks.csv&#34;</span>,
    <span>schema</span><span>=</span><span>&#34;create table x(network text, geoname_id integer, registered_country_geoname_id integer, represented_country_geoname_id integer, is_anonymous_proxy integer, is_satellite_provider integer, postal_code text, latitude real, longitude real, accuracy_radius integer)&#34;</span>,
    <span>columns</span><span>=</span><span>10</span>,
    <span>header</span><span>=</span><span>on</span>,
    <span>nulls</span><span>=</span><span>on</span>
);
</code></pre></div><div><pre tabindex="0"><code data-lang="sql">.<span>timer</span> <span>on</span>
<span>insert</span> <span>into</span> <span>blocks</span>
<span>select</span> <span>*</span> <span>from</span> <span>blocks_csv</span>;

<span>Run</span> <span>Time</span>: <span>real</span> <span>5</span>.<span>176</span> <span>user</span> <span>4</span>.<span>716420</span> <span>sys</span> <span>0</span>.<span>403866</span>
</code></pre></div><div><pre tabindex="0"><code data-lang="sql"><span>select</span> <span>count</span>(<span>*</span>) <span>from</span> <span>blocks</span>;
<span>3386629</span>

<span>Run</span> <span>Time</span>: <span>real</span> <span>0</span>.<span>095</span> <span>user</span> <span>0</span>.<span>021972</span> <span>sys</span> <span>0</span>.<span>063716</span>
</code></pre></div><p>There is a popular opinion among developers that SQLite is not suitable for the web, because it doesn’t support concurrent access. This is a myth. In the write-ahead log mode (available since long ago), there can be as many concurrent readers as you want. There can be only one concurrent writer, but often one is enough.</p>
<p>SQLite is a perfect fit for small websites and applications. <a href="https://sqlite.org/">sqlite.org</a> uses SQLite as a database, not bothering with optimization (≈200 requests per page). It handles 700K visits per month and serves pages faster than 95% of websites I’ve seen.</p>
<h2 id="documents-graphs-and-search">Documents, graphs, and search</h2>
<p>SQLite supports partial indexes and indexes on expressions, as ‘big’ DBMSs do. You can build indexes on generated columns and even turn SQLite into a document database. Just store raw JSON and build indexes on <code>json_extract()</code>-ed columns:</p>
<div><pre tabindex="0"><code data-lang="sql"><span>create</span> <span>table</span> <span>currency</span>(
  <span>body</span> <span>text</span>,
  <span>code</span> <span>text</span> <span>as</span> (<span>json_extract</span>(<span>body</span>, <span>&#39;$.code&#39;</span>)),
  <span>name</span> <span>text</span> <span>as</span> (<span>json_extract</span>(<span>body</span>, <span>&#39;$.name&#39;</span>))
);

<span>create</span> <span>index</span> <span>currency_code_idx</span> <span>on</span> <span>currency</span>(<span>code</span>);

<span>insert</span> <span>into</span> <span>currency</span>
<span>select</span> <span>value</span>
<span>from</span> <span>json_each</span>(<span>readfile</span>(<span>&#39;currency.sample.json&#39;</span>));
</code></pre></div><div><pre tabindex="0"><code data-lang="sql"><span>explain</span> <span>query</span> <span>plan</span>
<span>select</span> <span>name</span> <span>from</span> <span>currency</span> <span>where</span> <span>code</span> <span>=</span> <span>&#39;EUR&#39;</span>;

<span>QUERY</span> <span>PLAN</span>
<span>`</span><span>--SEARCH TABLE currency USING INDEX currency_code_idx (code=?)
</span></code></pre></div><blockquote>
<p>You can also use SQLite as a graph database. A bunch of complex <code>WITH RECURSIVE</code> will do the trick, or maybe you’ll prefer to add a bit of Python:</p>
<p><a href="https://github.com/dpapathanasiou/simple-graph">simple-graph @ GitHub</a></p>
</blockquote>
<p>Full-text search works out of the box:</p>
<div><pre tabindex="0"><code data-lang="sql"><span>create</span> <span>virtual</span> <span>table</span> <span>books_fts</span>
<span>using</span> <span>fts5</span>(<span>title</span>, <span>author</span>, <span>publisher</span>);

<span>insert</span> <span>into</span> <span>books_fts</span>
<span>select</span> <span>title</span>, <span>author</span>, <span>publisher</span> <span>from</span> <span>books</span>;

<span>select</span>
  <span>author</span>,
  <span>substr</span>(<span>title</span>, <span>1</span>, <span>30</span>) <span>as</span> <span>title</span>,
  <span>substr</span>(<span>publisher</span>, <span>1</span>, <span>10</span>) <span>as</span> <span>publisher</span>
<span>from</span> <span>books_fts</span>
<span>where</span> <span>books_fts</span> <span>match</span> <span>&#39;ann&#39;</span>
<span>limit</span> <span>5</span>;
</code></pre></div><pre tabindex="0"><code>┌─────────────────────┬────────────────────────────────┬────────────┐
│       author        │             title              │ publisher  │
├─────────────────────┼────────────────────────────────┼────────────┤
│ Ruby Ann Boxcar     │ Ruby Ann&#39;s Down Home Trailer P │ Citadel    │
│ Ruby Ann Boxcar     │ Ruby Ann&#39;s Down Home Trailer P │ Citadel    │
│ Lynne Ann DeSpelder │ The Last Dance: Encountering D │ McGraw-Hil │
│ Daniel Defoe        │ Robinson Crusoe                │ Ann Arbor  │
│ Ann Thwaite         │ Waiting for the Party: The Lif │ David R. G │
└─────────────────────┴────────────────────────────────┴────────────┘
</code></pre><p>Maybe you need an in-memory database for intermediate computations? Single line of python code:</p>
<div><pre tabindex="0"><code data-lang="python"><span>db</span> <span>=</span> <span>sqlite3</span><span>.</span><span>connect</span>(<span>&#34;:memory:&#34;</span>)
</code></pre></div><p>You can even access it from multiple connections:</p>
<div><pre tabindex="0"><code data-lang="python"><span>db</span> <span>=</span> <span>sqlite3</span><span>.</span><span>connect</span>(<span>&#34;file::memory:?cache=shared&#34;</span>)
</code></pre></div><h2 id="and-so-much-more">And so much more</h2>
<p>There are fancy window functions (just like in PostgreSQL). <code>UPSERT</code>, <code>UPDATE FROM</code>, and <code>generate_series()</code>. R-Tree indexes. Regular expressions, fuzzy-search, and geo. In terms of features, SQLite can compete with any ‘big’ DBMS.</p>
<p>There is also great tooling around SQLite. I especially like <a href="https://datasette.io/">Datasette</a> - an open-source tool for exploring and publishing SQLite datasets. And <a href="https://dbeaver.io/">DBeaver</a> is an excellent open-source database IDE with the latest SQLite versions support.</p>
<p>I hope this article will inspire you to try SQLite. Thanks for reading!</p>
<p><a href="https://news.ycombinator.com/item?id=26580614">Comments on Hacker News</a></p>
<p><em>Follow <a href="https://twitter.com/ohmypy"><strong>@ohmypy</strong></a> on Twitter and <a href="http://digest.antonz.org/"><strong>subscribe by email</strong></a> to keep up with new posts</em> 🚀</p>
</div>
</div></article>

</div>
</div></div>
  </body>
</html>
