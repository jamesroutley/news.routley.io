<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.trisul.org/blog/detecting-ssh-tunnels/">Original</a>
    <h1>Detecting SSH Tunnels (2017)</h1>
    
    <div id="readability-page-1" class="page"><div>
				
<h3>Detecting SSH tunnels</h3>



<p>SSH is an incredibly powerful protocol whose footprint needs to be monitored closely in enterprises. The most common use of SSH is for totally legitimate purposes like terminal (<code>ssh</code>) or for file transfer (<code>scp</code>,<code>sftp</code>). Many users also use the less well known <a href="https://www.ssh.com/ssh/tunneling/example">port forwarding</a> feature of SSH to create ‘tunnels’. SSH tunnels bore through firewalls, NATs, and are almost totally opaque to Network Security Monitoring tools like Trisul, Bro, Suricata, Snort, and others. SSHv2 even has SOCKS5 support – this allows anyone to setup a full SOCKS5 proxy <em>outside</em> your network and hide all HTTP activity from the prying eyes of NSM tools. With HTTPS/SSL, security tools can get atleast a look at the unencrypted certificates and perform checks, with SSH everything goes dark right after the initial capabilities exchange.</p>



<p>There are two types of SSH tunnels. The <em>forward tunnel</em> allows an insider to get on the outside bypassing the NSM and Firewall/NAT sentries. The <em>reverse tunnel</em> allows an outsider to get on the inside. The reverse tunnel is also called an <a href="https://linux.die.net/man/1/autossh">autossh tunnel</a> after the popular tool used to setup and maintain this connection.</p>



<p>Here is how a Forward SSH tunnel looks like</p>



<figure><img decoding="async" loading="lazy" width="730" height="216" src="http://104.248.118.224/wp-content/uploads/2020/03/fwdtunnel.png" alt="" srcset="https://www.trisul.org/wp-content/uploads/2020/03/fwdtunnel.png 730w, https://www.trisul.org/wp-content/uploads/2020/03/fwdtunnel-300x89.png 300w" sizes="(max-width: 730px) 100vw, 730px"/><figcaption> F<em>orward SSH tunnel hides activity. SSHv2 -D allows a full SOCK5 proxy outside your visibility zone</em> </figcaption></figure>



<p>and a Reverse SSH , or autossh Tunnel</p>



<div><figure><img decoding="async" loading="lazy" width="730" height="208" src="http://104.248.118.224/wp-content/uploads/2020/03/revtunnel-1.png" alt="" srcset="https://www.trisul.org/wp-content/uploads/2020/03/revtunnel-1.png 730w, https://www.trisul.org/wp-content/uploads/2020/03/revtunnel-1-300x85.png 300w" sizes="(max-width: 730px) 100vw, 730px"/><figcaption> <em>Reverse SSH tunnel allows someone to log on to an outside machine and pop up on the inside!</em> </figcaption></figure></div>



<h3>3 ways in which SSH tunnels create blind spots for monitoring</h3>



<p>Here are the top three ways in which SSH tunnels create blind spots for NSM tools</p>



<ol><li><strong>single flow</strong> : when you are monitoring on the perimeter SSH tunnels show up as a single flow while they multiplex several SSH or SFTP channels. So you miss that flow level insight.</li><li><strong>dynamic forwarding used as proxy</strong> using dynamic port forwarding users can proxy web traffic through the encrypted tunnel. This pretty much defeats every policy control you have at the boundary.</li><li><strong>24×7 access into your network</strong> : reverse ssh tunnels can give outsiders persistent presence into deep parts of your inside network. Autossh is a very advanced tool that maintains the tunnel and keeps it from timing out.</li></ol>



<p>It is quite obvious that any monitoring platform needs to help organizations stay right on top of SSH. Lets see what can be done.</p>



<h3>Tracking and detection of SSH tunnels</h3>



<p>In any large organization SSH is going to be pervasive. Therefore any naive SSH flow monitoring is going to be dominated by legitimate business applications. Here are some techniques we use in Trisul, you should be able to adapt these to your own toolchain.</p>



<p>We create a <a href="https://trisul.org/docs/lua/flow_tracker.html">SSH Flow Tracker</a> to first get baseline visibility and then to incrementally refine the tracking until we get a workable list of suspect flows. <em>Flow Tracking</em> is a streaming algorithm which plugs into the <em>flows stream</em> and continously snapshots <em>Top-K</em> every minute. There are several built-in Top-K algorithms (volume, upload, download, duration, based on ports, IPs, subnets, netflow). You can even write a fully customized tracker using the <a href="https://trisul.org/docs/lua/flow_tracker.html">flowtracker LUA script</a> ).</p>



<div><figure><img decoding="async" loading="lazy" width="888" height="348" src="http://104.248.118.224/wp-content/uploads/2020/03/ssh-ft1.png" alt="" srcset="https://www.trisul.org/wp-content/uploads/2020/03/ssh-ft1.png 888w, https://www.trisul.org/wp-content/uploads/2020/03/ssh-ft1-300x118.png 300w, https://www.trisul.org/wp-content/uploads/2020/03/ssh-ft1-768x301.png 768w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px"/><figcaption> <em>Flow tracker used to track long running SSH flows (sorted by duration)</em> </figcaption></figure></div>



<p>When you first enter a unmapped network, you need to build a baseline statistical and flow profile first. Statistical visibility includes actual bandwidth of SSH traffic, servers, clients, gateways, number of SSH flows, number of <em>concurrent SSH flows</em> , scanning activity, etc. Then you need to step down one level into flow visibility. Identify the normal SSH flows, the elephant flows, the long running but low traffic flows, flows that involved scanners, malicious hosts,etc.</p>



<p>Here we explain how we can use a ‘flow tracker’ to build a baseline model and then refine it in three steps and then end with a discussion of detection of SSH tunnels.</p>



<ul><li><strong>Visibility stage 1 : Use a “SSH Flow Tracker”</strong> – track Top-K SSH <strong>flows by volume</strong> – this gives you a baseline idea of very large elephant SSH flows. Most of them will be normal business activity that is okay. If you dont even have this insight, you are basically running blind.</li><li><strong>Visibility stage 2 : Use a “SSH Duration Tracker”</strong> – track Top-K SSH <strong>flows by duration</strong> – this gives you a really good idea of very long lived streams. Once again many of them will be legitimate business activity. That is okay – we will refine them and create a whitelist. Malicious Reverse SSH tunnels will typically not transmit much data as they “lie in wait” for the attacker to log in. They will be kept alive only because of ‘autossh’ keepalives. So right off the bat if you see long lived flows with very low traffic you can mark them for investigation. You can also create trackers for <strong>SSH flows by upload</strong> if you want to dig deeper.</li></ul>



<p>Once you have the baseline normal visibility we need to feedback knowledge gained from (1) and (2) into the realtime part of Trisul. To do this</p>



<ul><li><strong>Visibility stage 3 : Use “SSH Trackers but use a whitelist”</strong> – in addition to the two trackers above you create yet another trackers using the <code>flowtracker</code> LUA API that would track “All SSH flows by duration that arent whitelisted”. It is not that difficult because the whitelists can be automatically generated from (1) and (2). For example you can identify host pairs or subnet pairs that constitute normal traffic.</li><li><strong>Detection 1 : “Add detection”</strong> – In addition to the deep visibility above, if you can automatically detect SSH tunnels that would give you immediate rewards.</li></ul>



<p>In the next section, we show how you can plug in the detection part using a simple example.</p>



<h3>Detecting SSH tunnels using traffic analysis</h3>



<p>Recently I came across a great presentation by John B Althouse III [ <a href="https://twitter.com/4A4133/status/855541564067778561">link</a> ] where he used Bro (<a href="https://bro.org/">bro.org</a>) to detect SSH tunnels carrying TTY (terminal) using traffic analysis.</p>



<p>The key insight found by the author is : if you observe the packet lengths of keystrokes attached to SSH you notice the following.</p>



<ol><li>when SSH directly transports TTY keystrokes,<ol><li>packet length = SSH header + 1 byte char code + padding + HMAC. This could be 36,40,48 bytes or so</li></ol></li><li>when SSH tunnels another SSH channel transporting TTY traffic<ol><li>packet length = SSH header + [previous SSH pkt] + HMAC. This could be 76, 84, 98 bytes and so on</li><li>the exact lengths depend on the encryption block size and the HMAC algorithm + implementation of clients and servers.</li><li>each keystroke is echoed back, so we can use that fact to tighten it up a bit</li></ol></li></ol>



<p>If you can rig a NSM tool to detect consecutive tunnel packet sizes of <code>Server:76, Client:76,S:76,C:76,S:76,C:76</code> this is almost certainly a person typing in an interactive terminal on an SSH tunnel and getting echoed back. There you have it.</p>



<p>This is a traffic analysis attack essentially. OpenSSH does not implement the “random padding” feature of <em><a href="https://tools.ietf.org/html/rfc4253">RFC4253 The secure shell protocol</a></em> which says ” the insertion of variable amounts of ‘random padding’ may help thwart traffic analysis”. Until they fix that we can use this technique to detect tunnels.</p>



<figure><img decoding="async" loading="lazy" src="http://104.248.118.224/wp-content/uploads/2020/03/ssh_tunnel_alert.png" alt="" width="609" height="209" srcset="https://www.trisul.org/wp-content/uploads/2020/03/ssh_tunnel_alert.png 1008w, https://www.trisul.org/wp-content/uploads/2020/03/ssh_tunnel_alert-300x103.png 300w, https://www.trisul.org/wp-content/uploads/2020/03/ssh_tunnel_alert-768x264.png 768w" sizes="(max-width: 609px) 100vw, 609px"/><figcaption> <em>Alerts generated by Trisul when the script triggers</em> </figcaption></figure>



<p>Lets see how you can implement this analysis using the Trisul <a href="https://trisul.org/docs/lua/index.html">LUA API</a>.</p>



<h3>rev-ssh.lua</h3>



<p>You can think of Trisul roughly as Bro but with LUA and an emphasis on traffic metering and streaming analytics. The LUA API lets you hook into <a href="https://trisul.org/docs/lua/reassembly.html">TCP reassembly</a> , <a href="https://trisul.org/docs/lua/fileextractoverview.html">HTTP file extraction</a>, and a number of other <a href="https://trisul.org/docs/lua/basics.html">points</a>.</p>



<p>For more details about the script please visit <a href="https://github.com/trisulnsm/trisul-scripts/blob/master/lua/frontend_scripts/reassembly/revssh">Githiub rev-ssh.lua</a></p>



<h3>4. Alerting and tagging</h3>



<p>We dont want a flow to keep firing alerts when the user continues to type. So we use a dampening interval of 5 minutes.</p>



<pre><code>-- tag flow 
    engine:tag_flow(flowkey:id(),&#34;REVSSH&#34;);

    -- alert 
    engine:add_alert(&#34;{B5F1DECB-51D5-4395-B71B-6FA730B772D9}&#34;, flowkey:id(),&#34;REVSSH&#34;,1,&#34;rev ssh detected by keypress detect method&#34;);

    sshF.lastalertts=timestamp
  end</code></pre>



<p> <a href="https://trisul.org/docs/ug/tools/flow_tagger.html">Flow tagging</a> allows you to generate a ‘tag stream’ that are merged with the main “flows stream” and persisted at the end of a time window. Flow tags are nothing but text labels that are attached to flows. You can then search for flow by the tag value. </p>



<div><figure><img decoding="async" loading="lazy" src="http://104.248.118.224/wp-content/uploads/2020/03/revsshtag-1024x238.png" alt="" width="632" height="146" srcset="https://www.trisul.org/wp-content/uploads/2020/03/revsshtag-1024x238.png 1024w, https://www.trisul.org/wp-content/uploads/2020/03/revsshtag-300x70.png 300w, https://www.trisul.org/wp-content/uploads/2020/03/revsshtag-768x179.png 768w, https://www.trisul.org/wp-content/uploads/2020/03/revsshtag.png 1048w" sizes="(max-width: 632px) 100vw, 632px"/><figcaption> <em>Tags are arbitrary labels attached to flow. Showing a search <code>tag=REVSSH</code> in the <strong>Explore Flows</strong> tool</em><br/> </figcaption></figure></div>



<h3>Conclusion</h3>



<p>We think <strong>traffic and flow</strong> visibility is a very important part of Network Security Monitoring. As encryption spreads throughout the network we are going to need more and more of statistical and flow based approaches to gain insights into the network. You also need a real time API so you can plug in knowledge learnt from earlier “hunting expeditions”.</p>



<h2>Getting started</h2>



<p>If you want to get started on the Trisul platform and play with the scripting API, all you have to do is</p>



<ol><li>install Trisul using apt-get or yum (<strong>no signups or emails asked</strong> just apt-get/ yum)</li><li><strong>it runs free for the most recent 3 days window</strong></li><li>the LUA API is fully enabled</li><li>install the LUA script into the directory mentioned in <a href="https://trisul.org/docs/lua/basics.html#installing_and_uninstalling">Installing LUA scripts</a></li><li>now you can capture live traffic or process PCAP dumps</li></ol>



<figure><a href="https://trisul.org/"><img decoding="async" src="https://trisul.org/images/trisul.png" alt=""/></a></figure>



<p><strong>Free Download Trisul 6.0 ! Ready to go packages for Ubuntu and CentOS.</strong></p>







			</div></div>
  </body>
</html>
