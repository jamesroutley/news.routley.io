<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.xpnsec.com/building-a-mach-o-memory-loader-part-1/">Original</a>
    <h1>Building a Custom Mach-O Memory Loader for macOS</h1>
    
    <div id="readability-page-1" class="page"><div>
      <main role="main">
        <div>
  <article>
    <a href="https://blog.xpnsec.com" title="Back to homepage">« Back to home</a>


      





<p>In the <a href="https://blog.xpnsec.com/restoring-dyld-memory-loading/">last post</a> we looked at how we could patch dyld to restore in-memory execution. One of the advantages of this method is that we delegate many of the intricacies of loading Mach-O binaries to macOS. But what about if we wanted to stay clear of messing with dyld, and instead roll-up our sleeves and build our own loader? How does all of this byte mapping actually work?</p>
<p>In this blog we’ll look at what it takes to construct an in-memory loader for Mach-O bundles within MacOS Ventura without using dyld. We’ll walk through the lower-level details of what makes up a Mach-O file, how dyld processes load commands to map areas into memory, and how we can emulate this to avoid writing payloads to disk. I also recommend reading this post alongside the code published <a href="https://github.com/xpn/DyldDeNeuralyzer/blob/main/DyldDeNeuralyzer/MachoLoader/macholoader.m" target="_blank" rel="noopener">here</a> to fully understand the individual areas called out.</p>
<p>In keeping with Apple’s migration to ARM architecture, this post will focus on the AARCH64 version of MacOS Ventura and XCode targeting macOS 12.0 and higher. With that said, let’s dig in.</p>
<h2 id="What-Makes-a-Mach-O-File"><a href="#What-Makes-a-Mach-O-File" title="What Makes a Mach-O File?"></a>What Makes a Mach-O File?</h2><p>To begin we’ll need to understand the layout of a Mach-O file. One of the best resources out there to help us to get our head around the many bits of a Mach-O container is the <a href="https://github.com/aidansteele/osx-abi-macho-file-format-reference" target="_blank" rel="noopener">Mach-O File Format Reference</a> from <a href="https://twitter.com/__steele" target="_blank" rel="noopener">Aidan Steele</a> which I recommend reviewing.</p>
<p>As we’re dealing with the ARM version of MacOS, we will assume that the Mach-O that we’re looking at isn’t encapsulated in the <a href="https://en.wikipedia.org/wiki/Universal_binary#:~:text=Universal%202%20allows%20applications%20to,the%20transition%20to%20Apple%20silicon." target="_blank" rel="noopener">Universal 2</a> format (or has been lipo’d), so the first thing that we’ll encounter at the beginning of the file is the <code>mach_header_64</code>:</p>
<pre><code><span><span>struct</span> <span>mach_header_64</span> {</span>
    <span>uint32_t</span>    magic;
    <span>cpu_type_t</span>  cputype;
    <span>cpu_subtype_t</span>    cpusubtype;
    <span>uint32_t</span>    filetype;
    <span>uint32_t</span>    ncmds;
    <span>uint32_t</span>    sizeofcmds;
    <span>uint32_t</span>    flags;
    <span>uint32_t</span>    reserved;
};</code></pre>

<p>To construct our loader, we’ll need to sanity check a few of these fields:</p>
<ul>
<li><code>magic</code> - This field should hold a value of <code>MH_MAGIC_64</code>.</li>
<li><code>cputype</code> - For M1, this should be <code>CPU_TYPE_ARM64</code>.</li>
<li><code>filetype</code> - We’re going to be checking for <code>MH_BUNDLE</code> type for this post but loading different types should be easy as well.</li>
</ul>
<p>Once we’re happy that the Mach-O is sane, we move onto processing the load commands which immediately follow the <code>mach_header_64</code> struct.</p>
<h2 id="Load-Commands"><a href="#Load-Commands" title="Load Commands"></a>Load Commands</h2><p>A load command, as the name suggests, is a data structure used to instruct dyld on how it should load an area of the Mach-O. </p>
<p>Each load command is represented by the <code>load_command</code> struct:</p>
<pre><code><span><span>struct</span> <span>load_command</span> {</span>
    <span>unsigned</span> <span>long</span> cmd;
    <span>unsigned</span> <span>long</span> cmdsize;
};</code></pre>

<p>The <code>cmd</code> field ultimately determines what the <code>load_command</code> actually represents. For example, let’s take a very simple <code>load_command</code> of <code>LC_UUID</code> which is used to associate a UUID with the binary. This has the layout:</p>
<pre><code><span><span>struct</span> <span>uuid_command</span> {</span>
   <span>uint32_t</span> cmd;
   <span>uint32_t</span> cmdsize;
   <span>uint8_t</span> uuid[<span>16</span>];
};</code></pre>

<p>As you can see, this overlaps with the <code>load_command</code> struct, which is why we have the matching fields. This is the case for the various load command supported as we’ll see.</p>
<h2 id="Mach-O-Segments"><a href="#Mach-O-Segments" title="Mach-O Segments"></a>Mach-O Segments</h2><p>One of the first <code>load_command</code>‘s that we’re going to deal with when loading a Mach-O is <code>LC_SEGMENT_64</code>.</p>
<p>The segment command tells dyld how to map an area of the Mach-O into virtual memory, what size it should be, what protection is should have, and where the contents of the file are. Let’s look at its structure:</p>
<pre><code><span><span>struct</span> <span>segment_command_64</span> {</span>
    <span>uint32_t</span>    cmd;
    <span>uint32_t</span>    cmdsize;
    <span>char</span>        segname[<span>16</span>];
    <span>uint64_t</span>    vmaddr;
    <span>uint64_t</span>    vmsize;
    <span>uint64_t</span>    fileoff;
    <span>uint64_t</span>    filesize;
    <span>vm_prot_t</span>   maxprot;
    <span>vm_prot_t</span>   initprot;
    <span>uint32_t</span>    nsects;
    <span>uint32_t</span>    flags;
};</code></pre>

<p>For our purposes, we’re going to be paying attention to:</p>
<ul>
<li><code>segname</code> - The name of the segment, for example, <code>__TEXT</code>.</li>
<li><code>vmaddr</code> - The virtual address where the segment should be loaded. For example, if this is set to <code>0x4000</code>, then we’d load the segment at the allocated base of memory + <code>0x4000</code>.</li>
<li><code>vmsize</code> - The size of virtual memory to be allocated.</li>
<li><code>fileoff</code> - The offset from the beginning of the file to the contents of the Mach-O that should be copied to virtual memory.</li>
<li><code>filesize</code> - The number of bytes to copy from the file.</li>
<li><code>maxprot</code> - The maximum memory protection value that should be assigned to the region of virtual memory.</li>
<li><code>initprot</code> - The initial memory protection that should be assigned to the region of virtual memory.</li>
<li><code>nsects</code> - The number of sections which will follow this segment structure.</li>
</ul>
<p>At this point we should note that while <a href="https://github.com/apple-oss-distributions/dyld/blob/c8a445f88f9fc1713db34674e79b00e30723e79d/dyld/Loader.cpp#L1274" target="_blank" rel="noopener">dyld relies</a> on <code>mmap</code> to pull in segments of a Mach-O into memory, if our initial process is executing as a hardened process (and doesn’t have something like <code>com.apple.security.cs.allow-unsigned-executable-memory</code> in the entitlements), using <code>mmap</code> isn’t going to be possible unless the bundle we provide is signed using the same developer certificate as the surrogate app. Also, we’re trying to build a memory loader, so pulling in the binary from disk in this case wouldn’t make much sense.</p>
<p>To work around this, in our POC we will allocate our blob of memory up front and copy it over, for example:</p>
<pre><code>vm_allocate(mach_task_self(), (<span>vm_address_t</span>*)&amp;baseAlloc, maxVirtMemSize, VM_FLAGS_ANYWHERE);
<span>if</span> (baseAlloc == <span>NULL</span>) {
    <span>printf</span>(<span>&#34;[!] Error allocating %llx bytes of memory\n&#34;</span>, maxVirtMemSize);
    <span>return</span>;
}</code></pre>

<p>As with our dyld post <a href="https://blog.xpnsec.com/restoring-dyld-memory-loading/">previously</a>, we will need to use the correct entitlements in the host binary to allow unsigned executable memory.</p>
<h2 id="Sections"><a href="#Sections" title="Sections"></a>Sections</h2><p>So, as you can see from the fields above, another reference exists within a segment load command, and that’s a section.</p>
<p>As the section resides within a segment, while it will inherit its memory protection, it has its own size and file content to be loaded. The data structure for each segment is appended to the segment command and its structure is:</p>
  <pre><code><span><span>struct</span> <span>section_64</span> {</span>
    <span>char</span>        sectname[<span>16</span>];
    <span>char</span>        segname[<span>16</span>];
    <span>uint64_t</span>    addr;
    <span>uint64_t</span>    <span>size</span>;
    <span>uint32_t</span>    offset;
    <span>uint32_t</span>    align;
    <span>uint32_t</span>    reloff;
    <span>uint32_t</span>    nreloc;
    <span>uint32_t</span>    flags;
    <span>uint32_t</span>    reserved1;
    <span>uint32_t</span>    reserved2;
    <span>uint32_t</span>    reserved3;
};</code></pre>

<p>Again, we’ll just focus on a few of these fields which are useful for our immediate purpose of constructing a loader:</p>
<ul>
<li><code>sectname</code> - The name of the section, for example, <code>__text</code>. </li>
<li><code>segname</code> - The name of the segment associated with this section.</li>
<li><code>addr</code> - The virtual address offset to be used for this section.</li>
<li><code>size</code> - The size of the section in the file (and in virtual memory).</li>
<li><code>offset</code> - The offset to the contents of the section in the Mach-O file.</li>
<li><code>flags</code> - Flags can be assigned to a section which help determine the values in <code>reserved1</code>,<code>reserved2</code> and <code>reserved3</code>.</li>
</ul>
<p>As we’ve already allocated each segment, our loader will just walk through each section descriptor, ensuring that the correct file content is copied into virtual memory.</p>
<p>We need to note here that memory protection may need to be updated as we copy. MacOS for ARM does not allow Read/Write/Execute pages of memory (unless the <code>com.apple.security.cs.allow-jit</code> entitlement is used alongside <code>MAP_JIT</code>), so we need to accommodate this as we copy:</p>
<pre><code>sectionLoadAddr = VMADDR(section-&gt;addr);


ret = vm_protect(mach_task_self(), (<span>vm_address_t</span>)sectionLoadAddr, section-&gt;<span>size</span>, <span>false</span>, PROT_READ | PROT_WRITE);
<span>if</span> (ret != <span>0</span>) {
    <span>printf</span>(<span>&#34;\t[!] Error during vm_protect: %d\n&#34;</span>, ret);
}


<span>memcpy</span>(sectionLoadAddr, base + section-&gt;offset, section-&gt;<span>size</span>);


ret = vm_protect(mach_task_self(), (<span>vm_address_t</span>)sectionLoadAddr, section-&gt;<span>size</span>, <span>false</span>, segment-&gt;initprot);
<span>if</span> (ret != <span>0</span>) {
    <span>printf</span>(<span>&#34;\t[!] Error during vm_protect: %d\n&#34;</span>, ret);
}</code></pre>

<h2 id="Symbols"><a href="#Symbols" title="Symbols"></a>Symbols</h2><p>With our loader starting to take shape, we next need to look at how symbols are handled.</p>
<p>Symbols play an important role in the loading process of Mach-O binaries, associating names and ordinals to areas of memory for us to reference later.</p>
<p>Symbols are handled via a load command of <code>LC_SYMTAB</code>, which look like this:</p>
<pre><code><span><span>struct</span> <span>symtab_command</span> {</span>
    <span>unsigned</span> <span>long</span>    cmd;
    <span>unsigned</span> <span>long</span>    cmdsize;
    <span>unsigned</span> <span>long</span>    symoff;
    <span>unsigned</span> <span>long</span>    nsyms;
    <span>unsigned</span> <span>long</span>    stroff;
    <span>unsigned</span> <span>long</span>    strsize;
};</code></pre>

<p>Again, we’ll focus on the fields we need for constructing a loader:</p>
<ul>
<li><code>symoff</code> - Offset from start of the file to an array of <code>nlist</code> structures containing information on each symbol.</li>
<li><code>nsyms</code> - The number of symbols (or <code>nlist</code> structures).</li>
<li><code>stroff</code> - The file offset to the strings used by the symbol lookup.</li>
</ul>
<p>Obviously to follow along with this we’re going to need to know what an <code>nlist</code> is:</p>
<pre><code><span><span>struct</span> <span>nlist_64</span> {</span>
   <span>union</span> {
     <span>uint32_t</span> n_strx; 
   } n_un;
   <span>uint8_t</span>  n_type;
   <span>uint8_t</span>  n_sect;
   <span>uint16_t</span> n_desc;
   <span>uint64_t</span> n_value;
};</code></pre>

<p>This structure gives us information about a named symbol:</p>
<ul>
<li><code>n_strx</code> - Offset from the symbol strings field to the string of this symbol.</li>
<li><code>n_value</code> - Contains the value of the symbol, such as the address.</li>
</ul>
<p>As we will need to reference symbols later, our loader needs to store this information for later:</p>
<pre><code>symbols[@(stringTable + nl[i].n_un.n_strx)] = [NSValue valueWithPointer:(<span>void</span>*)nl[i].n_value];</code></pre>

<h2 id="Dylib’s"><a href="#Dylib’s" title="Dylib’s"></a>Dylib’s</h2><p>Next up we have the <code>LC_LOAD_DYLIB</code> load command, which references external dylib’s to be loaded at runtime.</p>
<pre><code><span><span>struct</span> <span>dylib_command</span> {</span>
    <span>unsigned</span> <span>long</span>    cmd;
    <span>unsigned</span> <span>long</span>    cmdsize;
    <span><span>struct</span> <span>dylib</span>    <span>dylib</span>;</span>
};</code></pre>

<p>The entry that we need from this is found in the <code>dylib</code> struct member, specifically <code>dylib.name.offset</code> which is an offset from the beginning of this load command to a string containing the dylib to load.</p>
<p>We’ll require this information later on when it comes to relocations, with the order in which dylib’s were imported playing an important role, so we’ll build an array of dylib’s that are referenced for later use:</p>
<pre><code><span>char</span> *dyldName = (<span>char</span> *)dylib + dylib-&gt;dylib.name.offset;
[dylds addObject:@(dyldName)];</code></pre>

<h2 id="Relocations"><a href="#Relocations" title="Relocations"></a>Relocations</h2><p>Now we move onto the more complicated part of Mach-O.. relocations. </p>
<p>Mach-O’s built with XCode targeting macOS 12.0 and higher use a load command of <code>LC_DYLD_CHAINED_FIXUPS</code>. There isn’t much documentation on how this all works, but one of the better resources out there was from <a href="https://www.emergetools.com/blog/posts/iOS15LaunchTime" target="_blank" rel="noopener">Noah Martin</a> reviewing lookup chains for iOS 15. We can also find details on the structs used in Apple’s XNU repo <a href="https://opensource.apple.com/source/xnu/xnu-7195.81.3/EXTERNAL_HEADERS/mach-o/fixup-chains.h.auto.html" target="_blank" rel="noopener">here</a>.</p>
<p>Dyld’s <a href="https://github.com/apple-oss-distributions/dyld/blob/c8a445f88f9fc1713db34674e79b00e30723e79d/common/MachOFile.cpp#L3390" target="_blank" rel="noopener">source</a> shows us that this load command starts with a <code>struct linkedit_data_command</code>:</p>
<p><img src="https://assets.xpnsec.com/macho-loader-part1/image3.png" alt=""/></p>
<p>Using the <code>dataoff</code> we get to the header:</p>
<pre><code><span><span>struct</span> <span>dyld_chained_fixups_header</span>
{</span>
    <span>uint32_t</span>    fixups_version;
    <span>uint32_t</span>    starts_offset;
    <span>uint32_t</span>    imports_offset;
    <span>uint32_t</span>    symbols_offset;
    <span>uint32_t</span>    imports_count;
    <span>uint32_t</span>    imports_format;
    <span>uint32_t</span>    symbols_format;
};</code></pre>

<p>The first thing we need to do is to gather all imports and construct an ordered array that we will later reference. To do this we’ll use the fields:</p>
<ul>
<li><code>symbols_offset</code> - Offset from the start of this struct to the symbol strings used by the imports.</li>
<li><code>imports_count</code> - Number of import entries.</li>
<li><code>imports_format</code> - The format of any imported symbols.</li>
<li><code>imports_offset</code> - Offset from the start of this struct to the import table.</li>
</ul>
<p>Each import entry data structure depends on the <code>imports_format</code> field, but typically I’ve seen this to be the <code>DYLD_CHAINED_IMPORT</code> format:</p>
<pre><code>
<span><span>struct</span> <span>dyld_chained_import</span>
{</span>
    <span>uint32_t</span>    lib_ordinal :  <span>8</span>,
                weak_import :  <span>1</span>,
                name_offset : <span>23</span>;
};</code></pre>

<p>So essentially this is an array of 32-bit entries. Here we have the <code>lib_ordinal</code> field, which is an index into the ordered <code>dylib</code> array that we constructed earlier from the <code>LC_LOAD_DYLIB</code> load command. The index starts at <code>1</code> rather than <code>0</code>, meaning that the first index is 1, then 2 etc:</p>
<pre><code><span>const</span> <span>char</span> *dyldName = [dylds[ordinal<span>-1</span>] UTF8String];</code></pre>

<p>If the index value is either <code>0</code> or <code>253</code>, then the entry is referencing <code>this-image</code> (the current executing binary). This is the reason we constructed our symbol dictionary earlier, as now we can simply resolve the referenced symbol name in our own binary to its address:</p>
<pre><code><span>if</span> (ordinal == <span>253</span> || ordinal == <span>0</span>) {
	
	<span>printf</span>(<span>&#34;\t[*] Library name: this-image\n&#34;</span>);
	func = [symbols[@(symbolNames + chainedImports[i].name_offset)] pointerValue];
	func = VMADDR((<span>unsigned</span> <span>long</span> <span>long</span>)func);
}</code></pre>

<p>The <code>name_offset</code> is an offset into the <code>symbols_offset</code> strings that we gathered from <code>dyld_chained_fixups_header</code>.</p>
<p>Using this information, we need to build up an ordered array of imports, as we’ll need to reference this ordered array in a moment.</p>
<p>With a list of imports constructed, we move onto chained starts, which can be found from the <code>starts_offset</code> header field of the <code>dyld_chained_fixups_header</code> struct.</p>
<p>The structure of the chained starts is:</p>
<pre><code><span><span>struct</span> <span>dyld_chained_starts_in_image</span>
{</span>
    <span>uint32_t</span>    seg_count;
    <span>uint32_t</span>    seg_info_offset[<span>1</span>];  
    
};</code></pre>

<p>To navigate this, we’ll need to iterate through each entry in <code>seg_info_offset</code>, which gives us a list of pointers to <code>dyld_chained_starts_in_segment</code>:</p>
<pre><code><span><span>struct</span> <span>dyld_chained_starts_in_segment</span>
{</span>
    <span>uint32_t</span>    <span>size</span>;               
    <span>uint16_t</span>    page_size;          
    <span>uint16_t</span>    pointer_format;     
    <span>uint64_t</span>    segment_offset;     
    <span>uint32_t</span>    max_valid_pointer;  
    <span>uint16_t</span>    page_count;         
    <span>uint16_t</span>    page_start[<span>1</span>];      
                                    
 
                                    
                                    
                                    
};</code></pre>

<p>First a note about this struct.. sometimes <code>segment_offset</code> is <code>0</code>… no idea why… and it looks like <a href="https://github.com/apple-oss-distributions/dyld/blob/c8a445f88f9fc1713db34674e79b00e30723e79d/cache-builder/AdjustDylibSegments.cpp#L533" target="_blank" rel="noopener">dyld identifies</a> this too and just ignores them, so we’ll do the same :/</p>
<p><img src="https://assets.xpnsec.com/macho-loader-part1/image4.png" alt=""/></p>
<p>The fields that we need to find the start of each reloc chain to follow will be:</p>
<ul>
<li><code>pointer_format</code> - The type of <code>DYLD_CHAINED_PTR_</code> struct that the chain uses.</li>
<li><code>segment_offset</code> - The absolute offset in memory of the segment start address.</li>
<li><code>page_count</code> - The number of pages that are in the <code>page_start</code> member array.</li>
<li><code>page_start</code> - The offset from the page to the chain start. </li>
</ul>
<p>When we have a valid offset into a segment, we can start following the reloc chain. Iterating over each entry, we need to check the first bit to determine if the entry is a <code>rebase</code> (set to 0) or a <code>bind</code> (set to 1):</p>
<p>In the case of a rebase, the entry is cast to a <code>dyld_chained_ptr_64_rebase</code> and we update the entry using the <code>target</code> offset to the base of our allocated memory. </p>
<pre><code><span><span>struct</span> <span>dyld_chained_ptr_64_rebase</span>
{</span>
    <span>uint64_t</span>    target    : <span>36</span>,    
                high8     :  <span>8</span>,    
                reserved  :  <span>7</span>,    
                next      : <span>12</span>,    
                bind      :  <span>1</span>;    
};</code></pre>

<p>In the case of a bind, we use a <code>dyld_chained_ptr_64_bind</code> and the <code>ordinal</code> field is the offset into the <code>import</code> array that we constructed earlier.</p>
<pre><code>
<span><span>struct</span> <span>dyld_chained_ptr_64_bind</span>
{</span>
    <span>uint64_t</span>    ordinal   : <span>24</span>,
                addend    :  <span>8</span>,   
                reserved  : <span>19</span>,   
                next      : <span>12</span>,   
                bind      :  <span>1</span>;   
};</code></pre>

<p>Then, we need to move onto the next bind or rebase, which is done by doing <code>next</code> * 4 (4 bytes is the stride size). We repeat this until the <code>next</code> field is <code>0</code>, indicating that the chain has ended.</p>
<h2 id="Putting-Everything-Together"><a href="#Putting-Everything-Together" title="Putting Everything Together"></a>Putting Everything Together</h2><p>Now we have all the parts, we need to actually construct the loader from start to finish. To recap, this will be:</p>
<ol>
<li>Allocate a region of memory.</li>
<li>Load each segment into virtual memory based on the <code>LC_SEGMENT_64</code> command.</li>
<li>Load each section into each segment.</li>
<li>Build an ordered collection of dylib’s from the <code>LC_LOAD_DYLIB</code> command.</li>
<li>Build a collection of symbols from the <code>LC_SYMTAB</code> command.</li>
<li>Walk the <code>LC_DYLD_CHAINED_FIXUPS</code> chain and rebase/bind each reloc.</li>
</ol>
<p>Once done, we can then use the data from <code>LC_SYMTAB</code> to reference the symbol that we want to enter as and pass execution over. If everything goes well, we’ll see that our Mach-O is loaded in memory and execution starts :)</p>
<p><img src="https://assets.xpnsec.com/macho-loader-part1/image6.png" alt=""/></p>
<p>All code for this POC has been added to the Dyld-DeNeuralyzer project <a href="https://github.com/xpn/DyldDeNeuralyzer" target="_blank" rel="noopener">here</a>.</p>
<h2 id="Next-Time…"><a href="#Next-Time…" title="Next Time…"></a>Next Time…</h2><p>So I think that’s a good place to stop for now, as we’ve covered quite a lot. One thing you’ll quickly see however is that while you can load a C/C++ bundle just fine, if you do try and load an Objective-C bundle, you’ll be greeted with something like this:</p>
<p><img src="https://assets.xpnsec.com/macho-loader-part1/image5.png" alt=""/></p>
<p>This is because of something that happens within dyld when Objective-C Mach-O’s are loaded. We’ll cover how to implement this the final part in this series.</p>
<h2 id="Standing-On-The-Shoulders…"><a href="#Standing-On-The-Shoulders…" title="Standing On The Shoulders…"></a>Standing On The Shoulders…</h2><p>There are plenty of resources out there which can help with constructing a loader, but the following were particularly useful in helping me to get my head around this. Thank you to all the authors for sharing their knowledge!</p>
<ul>
<li>Reference on the Mach-O file format - <a href="https://github.com/aidansteele/osx-abi-macho-file-format-reference" target="_blank" rel="noopener">https://github.com/aidansteele/osx-abi-macho-file-format-reference</a></li>
<li>Information on dyld reloc chains - <a href="https://opensource.apple.com/source/xnu/xnu-7195.81.3/EXTERNAL_HEADERS/mach-o/fixup-chains.h.auto.html" target="_blank" rel="noopener">https://opensource.apple.com/source/xnu/xnu-7195.81.3/EXTERNAL_HEADERS/mach-o/fixup-chains.h.auto.html</a></li>
<li>Brilliant blog post on why dyld reloc chains are now used - <a href="https://www.emergetools.com/blog/posts/iOS15LaunchTime" target="_blank" rel="noopener">https://www.emergetools.com/blog/posts/iOS15LaunchTime</a></li>
</ul>

  </article>
</div>

      </main> 
    </div></div>
  </body>
</html>
