<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://0x80.pl/notesen/2016-11-28-simd-strfind.html">Original</a>
    <h1>SIMD-friendly algorithms for substring searching (2018)</h1>
    
    <div id="readability-page-1" class="page"><div id="simd-friendly-algorithms-for-substring-searching">

<table>
<colgroup><col/>
<col/>
</colgroup><tbody>
<tr><th>Author:</th>
<td>Wojciech Muła</td></tr>
<tr><th>Added on:</th><td>2016-11-28</td>
</tr>
<tr><th>Updated on:</th><td>2018-02-14 (spelling), 2017-04-29 (ARMv8 results)</td>
</tr>
</tbody>
</table>
<div id="introduction">

<p>Popular programming languages provide methods or functions which locate a
substring in a given string. In C it is the function <tt>strstr</tt>, the C++
class <tt><span>std::string</span></tt> has the method <tt>find</tt>, Python&#39;s <tt>string</tt> has methods
<tt>pos</tt> and <tt>index</tt>, and so on, so forth. All these APIs were designed for
<strong>one-shot searches</strong>.  During past decades several algorithms to solve this
problem were designed, an excellent page by <strong>Christian Charras</strong> and
<strong>Thierry Lecroq</strong> <a href="http://www-igm.univ-mlv.fr/~lecroq/string/">lists most of them</a> (if not all). Basically these
algorithms could be split into two major categories: (1) based on
Deterministic Finite Automaton, like Knuth-Morris-Pratt, Boyer Moore, etc.,
and (2) based on a simple comparison, like the Karp-Rabin algorithm.</p>
<p>The main problem with these standard algorithms is a silent assumption
that comparing a pair of characters, looking up in an extra table and
conditions are cheap, while comparing two substrings is expansive.</p>
<p>But current desktop CPUs do not meet this assumption, in particular:</p>
<ul>
<li>There is no difference in comparing one, two, four or 8 bytes on a 64-bit
CPU.  When a processor supports SIMD instructions, then comparing vectors
(it means 16, 32 or even 64 bytes) is as cheap as comparing a single byte.</li>
<li>Thus comparing short sequences of chars can be faster than fancy algorithms
which avoids such comparison.</li>
<li>Looking up in a table costs one memory fetch, so at least a L1 cache round
(~3 cycles). Reading char-by-char also cost as much cycles.</li>
<li>Mispredicted jumps cost several cycles of penalty (~10-20 cycles).</li>
<li>There is a short chain of dependencies: read char, compare it, conditionally
jump, which make hard to utilize out-of-order execution capabilities present
in a CPU.</li>
</ul>

</div>
<div id="solution">

<p>This article shows two approaches utilizing SIMD instructions which I&#39;ve
already described in <a href="https://nmn.gl/blog/2014-03-11-simd-friendly-karp-rabin.html">SIMD-friendly Rabin-Karp modification</a> and <a href="https://nmn.gl/blog/2008-05-27-sse4-substring-locate.html">SSE4
string search — modification of Karp-Rabin algorithm</a>.  I merged the
articles, compared these two methods and extended material.  Article shows
also performance results for various implementations, ranging from
<a href="http://en.wikipedia.org/wiki/SWAR">SWAR</a> to AVX512F.</p>
<p>The Karp-Rabin algorithm does the exact substring comparison whenever <strong>weak
hashes</strong> are equal. One hash is calculated just once for searched substring,
and another one is calculated for string&#39;s portion; in every iteration the
second hash is updated at small cost. Following code shows the idea:</p>
<pre><span>k</span>  <span>:=</span> <span>substring</span> <span>length</span>
<span>h1</span> <span>:=</span> <span>hash</span><span>(</span><span>substring</span><span>)</span>
<span>h2</span> <span>:=</span> <span>hash</span><span>(</span><span>string</span><span>[</span><span>i</span> <span>..</span> <span>i</span> <span>+</span> <span>k</span><span>])</span>
<span>for</span> <span>i</span> <span>in</span> <span>0</span> <span>..</span> <span>n</span> <span>-</span> <span>k</span> <span>loop</span>
    <span>if</span> <span>h1</span> <span>==</span> <span>h2</span> <span>then</span>
        <span>if</span> <span>substring</span> <span>==</span> <span>string</span><span>[</span><span>i</span> <span>..</span> <span>i</span> <span>+</span> <span>k</span><span>]</span> <span>then</span>
            <span>return</span> <span>i</span>
        <span>end</span> <span>if</span>
    <span>end</span> <span>if</span>

    <span>h</span> <span>=</span> <span>next_hash</span><span>(</span><span>h</span><span>,</span> <span>...</span><span>)</span> <span>#</span> <span>this</span> <span>meant</span> <span>to</span> <span>be</span> <span>cheap</span>
<span>end</span> <span>loop</span>
</pre>
<p>SIMD solutions replace the hash predicate with <strong>a vector predicate</strong>, which
is calculated in parallel and, hopefully, is calculated fast.  For each
&#34;true&#34; element of the predicate vector an exact comparison of substrings is
performed.</p>
<p>This is one source of improvement, another is a careful implementation.
A generic implementation calls a function like <tt>memcmp</tt> to compare
substrings.  But while we know the length of searched substring, we may
provide specialisations for certain lengths, where a subprocedure call
is replaced by a few CPU instructions, even just one. Thanks to that
the cost of calling the procedure and all internal <tt>memcmp</tt> costs are
simply ridden off.</p>
</div>
<div id="algorithm-1-generic-simd">

<div id="algorithm">
<h2>Algorithm</h2>
<p>This algorithm is suitable for all SIMD instruction sets and also SWAR approach.  It
uses as a predicate equality of <strong>the first</strong> and <strong>the last</strong> characters from the
substring.</p>
<p>These two characters are populated in two registers, <strong>F</strong> and <strong>L</strong>
respectively.  Then in each iteration two chunks of strings are loaded.  The
first chunk (<strong>A</strong>) is read from offset <tt>i</tt> (where <tt>i</tt> is the current
offset) and the second chunk (<strong>B</strong>) is read from offset <tt>i + k - 1</tt>, where
<tt>k</tt> is substring&#39;s length.</p>
<p>Then we compute a vector expression <tt>F == A and B == L</tt>. This step yields a
byte vector (or a bit mask), where &#34;true&#34; values denote position of potential
substring occurrences.  Finally, just at these positions an exact comparisons of
substrings are performed.</p>
<div id="example">
<h3>Example</h3>
<p>Let&#39;s assume 8-byte registers. We&#39;re searching for word &#34;cat&#34;, thus:</p>
<pre>F    = [ c | c | c | c | c | c | c | c ]
L    = [ t | t | t | t | t | t | t | t ]
</pre>
<p>We&#39;re searching in the string &#34;a_cat_tries&#34;. In the first iteration the register
<strong>A</strong> gets data from offset 0, <strong>B</strong> from offset 2:</p>
<pre>A    = [ a | _ | c | a | t | _ | t | r ]
B    = [ c | a | t | _ | t | r | i | e ]
</pre>
<p>Now we compare:</p>
<pre>AF   = (A == F)
     = [ 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 ]

BL   = (B == L)
     = [ 0 | 0 | 1 | 0 | 1 | 0 | 0 | 0 ]
</pre>
<p>After merging comparison results, i.e. <tt>AF &amp; BL</tt>, we get following mask:</p>
<pre>mask = [ 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 ]
</pre>
<p>Since the mask is non-zero, it means there are possible substring occurrences.
As we see, there is only one non-zero element at index 2, thus only one
substring comparison must be performed.</p>
</div>
<div id="first-and-last">
<h3>First and last?</h3>
<p>Choosing the first and the last character from a substring is not always a
wise decision. Consider following scenario: a string contains mostly &#39;A&#39;
characters, and a user wants to find &#34;AjohndoeA&#34; — in such situation the
number of char-wise would be large.</p>
<p>In order to prevent such situations an implementation can pick &#34;last&#34; character
as the farthest character not equal to the first one. If there is no such
character, it means that all characters in substring are the same (for example
&#34;AAAAA&#34;). A specialised procedure may be used to handle such patterns.</p>
</div>
</div>
<div id="implementation">
<h2>Implementation</h2>
<div id="sse-avx2">
<h3>SSE &amp; AVX2</h3>
<p>Both SSE and AVX2 versions are practically the same, and both use the
minimum number of instruction. Below is a generic AVX2 version.</p>
<p>It&#39;s worth to note that since we already know that the first and the last
characters match, we don&#39;t need to compare them again with <tt>memcmp</tt>.</p>
<pre><span>size_t</span><span> </span><span>avx2_strstr_anysize</span><span>(</span><span>const</span><span> </span><span>char</span><span>*</span><span> </span><span>s</span><span>,</span><span> </span><span>size_t</span><span> </span><span>n</span><span>,</span><span> </span><span>const</span><span> </span><span>char</span><span>*</span><span> </span><span>needle</span><span>,</span><span> </span><span>size_t</span><span> </span><span>k</span><span>)</span><span> </span><span>{</span><span>

    </span><span>const</span><span> </span><span>__m256i</span><span> </span><span>first</span><span> </span><span>=</span><span> </span><span>_mm256_set1_epi8</span><span>(</span><span>needle</span><span>[</span><span>0</span><span>]);</span><span>
    </span><span>const</span><span> </span><span>__m256i</span><span> </span><span>last</span><span>  </span><span>=</span><span> </span><span>_mm256_set1_epi8</span><span>(</span><span>needle</span><span>[</span><span>k</span><span> </span><span>-</span><span> </span><span>1</span><span>]);</span><span>

    </span><span>for</span><span> </span><span>(</span><span>size_t</span><span> </span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>n</span><span>;</span><span> </span><span>i</span><span> </span><span>+=</span><span> </span><span>32</span><span>)</span><span> </span><span>{</span><span>

        </span><span>const</span><span> </span><span>__m256i</span><span> </span><span>block_first</span><span> </span><span>=</span><span> </span><span>_mm256_loadu_si256</span><span>(</span><span>reinterpret_cast</span><span>&lt;</span><span>const</span><span> </span><span>__m256i</span><span>*&gt;</span><span>(</span><span>s</span><span> </span><span>+</span><span> </span><span>i</span><span>));</span><span>
        </span><span>const</span><span> </span><span>__m256i</span><span> </span><span>block_last</span><span>  </span><span>=</span><span> </span><span>_mm256_loadu_si256</span><span>(</span><span>reinterpret_cast</span><span>&lt;</span><span>const</span><span> </span><span>__m256i</span><span>*&gt;</span><span>(</span><span>s</span><span> </span><span>+</span><span> </span><span>i</span><span> </span><span>+</span><span> </span><span>k</span><span> </span><span>-</span><span> </span><span>1</span><span>));</span><span>

        </span><span>const</span><span> </span><span>__m256i</span><span> </span><span>eq_first</span><span> </span><span>=</span><span> </span><span>_mm256_cmpeq_epi8</span><span>(</span><span>first</span><span>,</span><span> </span><span>block_first</span><span>);</span><span>
        </span><span>const</span><span> </span><span>__m256i</span><span> </span><span>eq_last</span><span>  </span><span>=</span><span> </span><span>_mm256_cmpeq_epi8</span><span>(</span><span>last</span><span>,</span><span> </span><span>block_last</span><span>);</span><span>

        </span><span>uint32_t</span><span> </span><span>mask</span><span> </span><span>=</span><span> </span><span>_mm256_movemask_epi8</span><span>(</span><span>_mm256_and_si256</span><span>(</span><span>eq_first</span><span>,</span><span> </span><span>eq_last</span><span>));</span><span>

        </span><span>while</span><span> </span><span>(</span><span>mask</span><span> </span><span>!=</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span>

            </span><span>const</span><span> </span><span>auto</span><span> </span><span>bitpos</span><span> </span><span>=</span><span> </span><span>bits</span><span>::</span><span>get_first_bit_set</span><span>(</span><span>mask</span><span>);</span><span>

            </span><span>if</span><span> </span><span>(</span><span>memcmp</span><span>(</span><span>s</span><span> </span><span>+</span><span> </span><span>i</span><span> </span><span>+</span><span> </span><span>bitpos</span><span> </span><span>+</span><span> </span><span>1</span><span>,</span><span> </span><span>needle</span><span> </span><span>+</span><span> </span><span>1</span><span>,</span><span> </span><span>k</span><span> </span><span>-</span><span> </span><span>2</span><span>)</span><span> </span><span>==</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span>
                </span><span>return</span><span> </span><span>i</span><span> </span><span>+</span><span> </span><span>bitpos</span><span>;</span><span>
            </span><span>}</span><span>

            </span><span>mask</span><span> </span><span>=</span><span> </span><span>bits</span><span>::</span><span>clear_leftmost_set</span><span>(</span><span>mask</span><span>);</span><span>
        </span><span>}</span><span>
    </span><span>}</span><span>

    </span><span>return</span><span> </span><span>std</span><span>::</span><span>string</span><span>::</span><span>npos</span><span>;</span><span>
</span><span>}</span>
</pre>
</div>
<div id="swar">
<h3>SWAR</h3>
<p>In SWAR approach, comparison for equality uses bit xor operation, which yields zero when
two bytes are equal. Therefore instead of anding partial results, the bitwise
or is used. Clearly this part of algorithm has the same complexity as the
SSE/AVX2 code.</p>
<p>However, SWAR requires more effort to locate zero bytes. Following procedure
calculates <strong>an exact byte mask</strong>, where MSBs of <tt>zeros</tt> are set when the
corresponding byte in <tt>x</tt> is zero.</p>
<pre><span>// 7th bit set if lower 7 bits are zero
</span><span>const</span><span> </span><span>uint64_t</span><span> </span><span>t0</span><span> </span><span>=</span><span> </span><span>(</span><span>~</span><span>x</span><span> </span><span>&amp;</span><span> </span><span>0x7f7f7f7f7f7f7f7fllu</span><span>)</span><span> </span><span>+</span><span> </span><span>0x0101010101010101llu</span><span>;</span><span>
</span><span>// 7th bit set if 7th bit is zero
</span><span>const</span><span> </span><span>uint64_t</span><span> </span><span>t1</span><span> </span><span>=</span><span> </span><span>(</span><span>~</span><span>x</span><span> </span><span>&amp;</span><span> </span><span>0x8080808080808080llu</span><span>);</span><span>
</span><span>uint64_t</span><span> </span><span>zeros</span><span> </span><span>=</span><span> </span><span>t0</span><span> </span><span>&amp;</span><span> </span><span>t1</span><span>;</span>
</pre>
<p>Below is the C++ implementation for 64-bit vectors. The while loop contains an
additional condition which might look not optimal. But searching the first set
bit and later clearing it (as the SSE version does) is slower.</p>
<pre><span>size_t</span><span> </span><span>swar64_strstr_anysize</span><span>(</span><span>const</span><span> </span><span>char</span><span>*</span><span> </span><span>s</span><span>,</span><span> </span><span>size_t</span><span> </span><span>n</span><span>,</span><span> </span><span>const</span><span> </span><span>char</span><span>*</span><span> </span><span>needle</span><span>,</span><span> </span><span>size_t</span><span> </span><span>k</span><span>)</span><span> </span><span>{</span><span>

    </span><span>const</span><span> </span><span>uint64_t</span><span> </span><span>first</span><span> </span><span>=</span><span> </span><span>0x0101010101010101llu</span><span> </span><span>*</span><span> </span><span>static_cast</span><span>&lt;</span><span>uint8_t</span><span>&gt;</span><span>(</span><span>needle</span><span>[</span><span>0</span><span>]);</span><span>
    </span><span>const</span><span> </span><span>uint64_t</span><span> </span><span>last</span><span>  </span><span>=</span><span> </span><span>0x0101010101010101llu</span><span> </span><span>*</span><span> </span><span>static_cast</span><span>&lt;</span><span>uint8_t</span><span>&gt;</span><span>(</span><span>needle</span><span>[</span><span>k</span><span> </span><span>-</span><span> </span><span>1</span><span>]);</span><span>

    </span><span>uint64_t</span><span>*</span><span> </span><span>block_first</span><span> </span><span>=</span><span> </span><span>reinterpret_cast</span><span>&lt;</span><span>uint64_t</span><span>*&gt;</span><span>(</span><span>const_cast</span><span>&lt;</span><span>char</span><span>*&gt;</span><span>(</span><span>s</span><span>));</span><span>
    </span><span>uint64_t</span><span>*</span><span> </span><span>block_last</span><span>  </span><span>=</span><span> </span><span>reinterpret_cast</span><span>&lt;</span><span>uint64_t</span><span>*&gt;</span><span>(</span><span>const_cast</span><span>&lt;</span><span>char</span><span>*&gt;</span><span>(</span><span>s</span><span> </span><span>+</span><span> </span><span>k</span><span> </span><span>-</span><span> </span><span>1</span><span>));</span><span>

    </span><span>for</span><span> </span><span>(</span><span>auto</span><span> </span><span>i</span><span>=</span><span>0u</span><span>;</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>n</span><span>;</span><span> </span><span>i</span><span>+=</span><span>8</span><span>,</span><span> </span><span>block_first</span><span>++</span><span>,</span><span> </span><span>block_last</span><span>++</span><span>)</span><span> </span><span>{</span><span>
        </span><span>const</span><span> </span><span>uint64_t</span><span> </span><span>eq</span><span> </span><span>=</span><span> </span><span>(</span><span>*</span><span>block_first</span><span> </span><span>^</span><span> </span><span>first</span><span>)</span><span> </span><span>|</span><span> </span><span>(</span><span>*</span><span>block_last</span><span> </span><span>^</span><span> </span><span>last</span><span>);</span><span>

        </span><span>const</span><span> </span><span>uint64_t</span><span> </span><span>t0</span><span> </span><span>=</span><span> </span><span>(</span><span>~</span><span>eq</span><span> </span><span>&amp;</span><span> </span><span>0x7f7f7f7f7f7f7f7fllu</span><span>)</span><span> </span><span>+</span><span> </span><span>0x0101010101010101llu</span><span>;</span><span>
        </span><span>const</span><span> </span><span>uint64_t</span><span> </span><span>t1</span><span> </span><span>=</span><span> </span><span>(</span><span>~</span><span>eq</span><span> </span><span>&amp;</span><span> </span><span>0x8080808080808080llu</span><span>);</span><span>
        </span><span>uint64_t</span><span> </span><span>zeros</span><span> </span><span>=</span><span> </span><span>t0</span><span> </span><span>&amp;</span><span> </span><span>t1</span><span>;</span><span>
        </span><span>size_t</span><span> </span><span>j</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span>

        </span><span>while</span><span> </span><span>(</span><span>zeros</span><span>)</span><span> </span><span>{</span><span>
            </span><span>if</span><span> </span><span>(</span><span>zeros</span><span> </span><span>&amp;</span><span> </span><span>0x80</span><span>)</span><span> </span><span>{</span><span>
                </span><span>const</span><span> </span><span>char</span><span>*</span><span> </span><span>substr</span><span> </span><span>=</span><span> </span><span>reinterpret_cast</span><span>&lt;</span><span>char</span><span>*&gt;</span><span>(</span><span>block_first</span><span>)</span><span> </span><span>+</span><span> </span><span>j</span><span> </span><span>+</span><span> </span><span>1</span><span>;</span><span>
                </span><span>if</span><span> </span><span>(</span><span>memcmp</span><span>(</span><span>substr</span><span>,</span><span> </span><span>needle</span><span> </span><span>+</span><span> </span><span>1</span><span>,</span><span> </span><span>k</span><span> </span><span>-</span><span> </span><span>2</span><span>)</span><span> </span><span>==</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span>
                    </span><span>return</span><span> </span><span>i</span><span> </span><span>+</span><span> </span><span>j</span><span>;</span><span>
                </span><span>}</span><span>
            </span><span>}</span><span>

            </span><span>zeros</span><span> </span><span>&gt;&gt;=</span><span> </span><span>8</span><span>;</span><span>
            </span><span>j</span><span> </span><span>+=</span><span> </span><span>1</span><span>;</span><span>
        </span><span>}</span><span>
    </span><span>}</span><span>

    </span><span>return</span><span> </span><span>std</span><span>::</span><span>string</span><span>::</span><span>npos</span><span>;</span><span>
</span><span>}</span>
</pre>
</div>
<div id="avx512f">
<h3>AVX512F</h3>
<p>AVX512F lacks of operations on bytes, the smallest vector item is a
32-bit word. The limitation forces us to use SWAR techniques.</p>
<ol>
<li>Using AVX512F instructions we compare two vectors, like in SWAR version,
i.e. two xors joined with bitwise or.
There is only one difference, a single <a href="https://nmn.gl/blog/2015-03-22-avx512-ternary-functions.html">ternary logic instruction</a>
expresses one xor and bitwise or.</li>
<li>Using AVX512F instructions we locate which 32-bit elements
contain any zero byte.</li>
<li>Then for such 32-bit element check four substrings for equality.</li>
</ol>
<p>Unlike the SWAR procedure, where we need a precise mask for zero bytes, an
AVX512F procedure requires just information &#34;a word has zero byte&#34;.  A
simpler algorithm, described in <a href="https://graphics.stanford.edu/~seander/bithacks.html">Bit Twiddling Hacks</a> is used; below
is its C++ implementation.</p>
<pre><span>__mmask16</span><span> </span><span>zero_byte_mask</span><span>(</span><span>const</span><span> </span><span>__m512i</span><span> </span><span>v</span><span>)</span><span> </span><span>{</span><span>

    </span><span>const</span><span> </span><span>__m512i</span><span> </span><span>v01</span><span>  </span><span>=</span><span> </span><span>_mm512_set1_epi32</span><span>(</span><span>0x01010101u</span><span>);</span><span>
    </span><span>const</span><span> </span><span>__m512i</span><span> </span><span>v80</span><span>  </span><span>=</span><span> </span><span>_mm512_set1_epi32</span><span>(</span><span>0x80808080u</span><span>);</span><span>

    </span><span>const</span><span> </span><span>__m512i</span><span> </span><span>v1</span><span>   </span><span>=</span><span> </span><span>_mm512_sub_epi32</span><span>(</span><span>v</span><span>,</span><span> </span><span>v01</span><span>);</span><span>
    </span><span>// tmp1 = (v - 0x01010101) &amp; ~v &amp; 0x80808080
</span><span>    </span><span>const</span><span> </span><span>__m512i</span><span> </span><span>tmp1</span><span> </span><span>=</span><span> </span><span>_mm512_ternarylogic_epi32</span><span>(</span><span>v1</span><span>,</span><span> </span><span>v</span><span>,</span><span> </span><span>v80</span><span>,</span><span> </span><span>0x20</span><span>);</span><span>

    </span><span>return</span><span> </span><span>_mm512_test_epi32_mask</span><span>(</span><span>tmp1</span><span>,</span><span> </span><span>tmp1</span><span>);</span><span>
</span><span>}</span>
</pre>
<p>Generic C++ implementation.</p>
<pre><span>#define _mm512_set1_epu8(c) _mm512_set1_epi32(uint32_t(c) * 0x01010101u)
</span><span>
</span><span>size_t</span><span> </span><span>avx512f_strstr_v2_anysize</span><span>(</span><span>const</span><span> </span><span>char</span><span>*</span><span> </span><span>string</span><span>,</span><span> </span><span>size_t</span><span> </span><span>n</span><span>,</span><span> </span><span>const</span><span> </span><span>char</span><span>*</span><span> </span><span>needle</span><span>,</span><span> </span><span>size_t</span><span> </span><span>k</span><span>)</span><span> </span><span>{</span><span>

    </span><span>assert</span><span>(</span><span>n</span><span> </span><span>&gt;</span><span> </span><span>0</span><span>);</span><span>
    </span><span>assert</span><span>(</span><span>k</span><span> </span><span>&gt;</span><span> </span><span>0</span><span>);</span><span>

    </span><span>const</span><span> </span><span>__m512i</span><span> </span><span>first</span><span> </span><span>=</span><span> </span><span>_mm512_set1_epu8</span><span>(</span><span>needle</span><span>[</span><span>0</span><span>]);</span><span>
    </span><span>const</span><span> </span><span>__m512i</span><span> </span><span>last</span><span>  </span><span>=</span><span> </span><span>_mm512_set1_epu8</span><span>(</span><span>needle</span><span>[</span><span>k</span><span> </span><span>-</span><span> </span><span>1</span><span>]);</span><span>

    </span><span>char</span><span>*</span><span> </span><span>haystack</span><span> </span><span>=</span><span> </span><span>const_cast</span><span>&lt;</span><span>char</span><span>*&gt;</span><span>(</span><span>string</span><span>);</span><span>
    </span><span>char</span><span>*</span><span> </span><span>end</span><span>      </span><span>=</span><span> </span><span>haystack</span><span> </span><span>+</span><span> </span><span>n</span><span>;</span><span>

    </span><span>for</span><span> </span><span>(</span><span>/**/</span><span>;</span><span> </span><span>haystack</span><span> </span><span>&lt;</span><span> </span><span>end</span><span>;</span><span> </span><span>haystack</span><span> </span><span>+=</span><span> </span><span>64</span><span>)</span><span> </span><span>{</span><span>

        </span><span>const</span><span> </span><span>__m512i</span><span> </span><span>block_first</span><span> </span><span>=</span><span> </span><span>_mm512_loadu_si512</span><span>(</span><span>haystack</span><span> </span><span>+</span><span> </span><span>0</span><span>);</span><span>
        </span><span>const</span><span> </span><span>__m512i</span><span> </span><span>block_last</span><span>  </span><span>=</span><span> </span><span>_mm512_loadu_si512</span><span>(</span><span>haystack</span><span> </span><span>+</span><span> </span><span>k</span><span> </span><span>-</span><span> </span><span>1</span><span>);</span><span>

        </span><span>const</span><span> </span><span>__m512i</span><span> </span><span>first_zeros</span><span> </span><span>=</span><span> </span><span>_mm512_xor_si512</span><span>(</span><span>block_first</span><span>,</span><span> </span><span>first</span><span>);</span><span>
        </span><span>// zeros = first_zeros | (block_last ^ last)
</span><span>        </span><span>const</span><span> </span><span>__m512i</span><span> </span><span>zeros</span><span> </span><span>=</span><span> </span><span>_mm512_ternarylogic_epi32</span><span>(</span><span>first_zeros</span><span>,</span><span> </span><span>block_last</span><span>,</span><span> </span><span>last</span><span>,</span><span> </span><span>0xf6</span><span>);</span><span>

        </span><span>uint32_t</span><span> </span><span>mask</span><span> </span><span>=</span><span> </span><span>zero_byte_mask</span><span>(</span><span>zeros</span><span>);</span><span>
        </span><span>while</span><span> </span><span>(</span><span>mask</span><span>)</span><span> </span><span>{</span><span>

            </span><span>const</span><span> </span><span>uint64_t</span><span> </span><span>p</span><span> </span><span>=</span><span> </span><span>__builtin_ctz</span><span>(</span><span>mask</span><span>);</span><span>

            </span><span>if</span><span> </span><span>(</span><span>memcmp</span><span>(</span><span>haystack</span><span> </span><span>+</span><span> </span><span>4</span><span>*</span><span>p</span><span> </span><span>+</span><span> </span><span>0</span><span>,</span><span> </span><span>needle</span><span>,</span><span> </span><span>k</span><span>)</span><span> </span><span>==</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span>
                </span><span>return</span><span> </span><span>(</span><span>haystack</span><span> </span><span>-</span><span> </span><span>string</span><span>)</span><span> </span><span>+</span><span> </span><span>4</span><span>*</span><span>p</span><span> </span><span>+</span><span> </span><span>0</span><span>;</span><span>
            </span><span>}</span><span>

            </span><span>if</span><span> </span><span>(</span><span>memcmp</span><span>(</span><span>haystack</span><span> </span><span>+</span><span> </span><span>4</span><span>*</span><span>p</span><span> </span><span>+</span><span> </span><span>1</span><span>,</span><span> </span><span>needle</span><span>,</span><span> </span><span>k</span><span>)</span><span> </span><span>==</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span>
                </span><span>return</span><span> </span><span>(</span><span>haystack</span><span> </span><span>-</span><span> </span><span>string</span><span>)</span><span> </span><span>+</span><span> </span><span>4</span><span>*</span><span>p</span><span> </span><span>+</span><span> </span><span>1</span><span>;</span><span>
            </span><span>}</span><span>

            </span><span>if</span><span> </span><span>(</span><span>memcmp</span><span>(</span><span>haystack</span><span> </span><span>+</span><span> </span><span>4</span><span>*</span><span>p</span><span> </span><span>+</span><span> </span><span>2</span><span>,</span><span> </span><span>needle</span><span>,</span><span> </span><span>k</span><span>)</span><span> </span><span>==</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span>
                </span><span>return</span><span> </span><span>(</span><span>haystack</span><span> </span><span>-</span><span> </span><span>string</span><span>)</span><span> </span><span>+</span><span> </span><span>4</span><span>*</span><span>p</span><span> </span><span>+</span><span> </span><span>2</span><span>;</span><span>
            </span><span>}</span><span>

            </span><span>if</span><span> </span><span>(</span><span>memcmp</span><span>(</span><span>haystack</span><span> </span><span>+</span><span> </span><span>4</span><span>*</span><span>p</span><span> </span><span>+</span><span> </span><span>3</span><span>,</span><span> </span><span>needle</span><span>,</span><span> </span><span>k</span><span>)</span><span> </span><span>==</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span>
                </span><span>return</span><span> </span><span>(</span><span>haystack</span><span> </span><span>-</span><span> </span><span>string</span><span>)</span><span> </span><span>+</span><span> </span><span>4</span><span>*</span><span>p</span><span> </span><span>+</span><span> </span><span>3</span><span>;</span><span>
            </span><span>}</span><span>

            </span><span>mask</span><span> </span><span>=</span><span> </span><span>bits</span><span>::</span><span>clear_leftmost_set</span><span>(</span><span>mask</span><span>);</span><span>
        </span><span>}</span><span>
    </span><span>}</span><span>

    </span><span>return</span><span> </span><span>size_t</span><span>(</span><span>-1</span><span>);</span><span>
</span><span>}</span>
</pre>
</div>
<div id="arm-neon-32-bit-code">
<h3>ARM Neon (32 bit code)</h3>
<p>The algorithm can be also easily realised using ARM Neon instructions, having
128-bit SIMD registers.  The only problem is caused by long round trip from
the Neon unit back to the CPU.</p>
<p>It was solved by saving back the comparison result in a 64 bit word in memory:
lower nibbles come from the lower half of a SIMD register, likewise higher
nibbles come from the higher half of the register.</p>
<p>Comparison is done in two loops, separately for lower and higher nibbles.
This split is required to detect substring occurrences in the correct order.</p>
<p>Below is a sample implementation.</p>
<pre><span>size_t</span><span> </span><span>FORCE_INLINE</span><span> </span><span>neon_strstr_anysize</span><span>(</span><span>const</span><span> </span><span>char</span><span>*</span><span> </span><span>s</span><span>,</span><span> </span><span>size_t</span><span> </span><span>n</span><span>,</span><span> </span><span>const</span><span> </span><span>char</span><span>*</span><span> </span><span>needle</span><span>,</span><span> </span><span>size_t</span><span> </span><span>k</span><span>)</span><span> </span><span>{</span><span>

    </span><span>assert</span><span>(</span><span>k</span><span> </span><span>&gt;</span><span> </span><span>0</span><span>);</span><span>
    </span><span>assert</span><span>(</span><span>n</span><span> </span><span>&gt;</span><span> </span><span>0</span><span>);</span><span>

    </span><span>const</span><span> </span><span>uint8x16_t</span><span> </span><span>first</span><span> </span><span>=</span><span> </span><span>vdupq_n_u8</span><span>(</span><span>needle</span><span>[</span><span>0</span><span>]);</span><span>
    </span><span>const</span><span> </span><span>uint8x16_t</span><span> </span><span>last</span><span>  </span><span>=</span><span> </span><span>vdupq_n_u8</span><span>(</span><span>needle</span><span>[</span><span>k</span><span> </span><span>-</span><span> </span><span>1</span><span>]);</span><span>
    </span><span>const</span><span> </span><span>uint8x8_t</span><span>  </span><span>half</span><span>  </span><span>=</span><span> </span><span>vdup_n_u8</span><span>(</span><span>0x0f</span><span>);</span><span>

    </span><span>const</span><span> </span><span>uint8_t</span><span>*</span><span> </span><span>ptr</span><span> </span><span>=</span><span> </span><span>reinterpret_cast</span><span>&lt;</span><span>const</span><span> </span><span>uint8_t</span><span>*&gt;</span><span>(</span><span>s</span><span>);</span><span>

    </span><span>union</span><span> </span><span>{</span><span>
        </span><span>uint8_t</span><span>  </span><span>tmp</span><span>[</span><span>8</span><span>];</span><span>
        </span><span>uint32_t</span><span> </span><span>word</span><span>[</span><span>2</span><span>];</span><span>
    </span><span>};</span><span>

    </span><span>for</span><span> </span><span>(</span><span>size_t</span><span> </span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>n</span><span>;</span><span> </span><span>i</span><span> </span><span>+=</span><span> </span><span>16</span><span>)</span><span> </span><span>{</span><span>

        </span><span>const</span><span> </span><span>uint8x16_t</span><span> </span><span>block_first</span><span> </span><span>=</span><span> </span><span>vld1q_u8</span><span>(</span><span>ptr</span><span> </span><span>+</span><span> </span><span>i</span><span>);</span><span>
        </span><span>const</span><span> </span><span>uint8x16_t</span><span> </span><span>block_last</span><span>  </span><span>=</span><span> </span><span>vld1q_u8</span><span>(</span><span>ptr</span><span> </span><span>+</span><span> </span><span>i</span><span> </span><span>+</span><span> </span><span>k</span><span> </span><span>-</span><span> </span><span>1</span><span>);</span><span>

        </span><span>const</span><span> </span><span>uint8x16_t</span><span> </span><span>eq_first</span><span> </span><span>=</span><span> </span><span>vceqq_u8</span><span>(</span><span>first</span><span>,</span><span> </span><span>block_first</span><span>);</span><span>
        </span><span>const</span><span> </span><span>uint8x16_t</span><span> </span><span>eq_last</span><span>  </span><span>=</span><span> </span><span>vceqq_u8</span><span>(</span><span>last</span><span>,</span><span> </span><span>block_last</span><span>);</span><span>
        </span><span>const</span><span> </span><span>uint8x16_t</span><span> </span><span>pred_16</span><span>  </span><span>=</span><span> </span><span>vandq_u8</span><span>(</span><span>eq_first</span><span>,</span><span> </span><span>eq_last</span><span>);</span><span>
        </span><span>const</span><span> </span><span>uint8x8_t</span><span> </span><span>pred_8</span><span>    </span><span>=</span><span> </span><span>vbsl_u8</span><span>(</span><span>half</span><span>,</span><span> </span><span>vget_low_u8</span><span>(</span><span>pred_16</span><span>),</span><span> </span><span>vget_high_u8</span><span>(</span><span>pred_16</span><span>));</span><span>

        </span><span>vst1_u8</span><span>(</span><span>tmp</span><span>,</span><span> </span><span>pred_8</span><span>);</span><span>

        </span><span>if</span><span> </span><span>((</span><span>word</span><span>[</span><span>0</span><span>]</span><span> </span><span>|</span><span> </span><span>word</span><span>[</span><span>1</span><span>])</span><span> </span><span>==</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span>
            </span><span>continue</span><span>;</span><span>
        </span><span>}</span><span>

        </span><span>for</span><span> </span><span>(</span><span>int</span><span> </span><span>j</span><span>=</span><span>0</span><span>;</span><span> </span><span>j</span><span> </span><span>&lt;</span><span> </span><span>8</span><span>;</span><span> </span><span>j</span><span>++</span><span>)</span><span> </span><span>{</span><span>
            </span><span>if</span><span> </span><span>(</span><span>tmp</span><span>[</span><span>j</span><span>]</span><span> </span><span>&amp;</span><span> </span><span>0x0f</span><span>)</span><span> </span><span>{</span><span>
                </span><span>if</span><span> </span><span>(</span><span>memcmp</span><span>(</span><span>s</span><span> </span><span>+</span><span> </span><span>i</span><span> </span><span>+</span><span> </span><span>j</span><span> </span><span>+</span><span> </span><span>1</span><span>,</span><span> </span><span>needle</span><span> </span><span>+</span><span> </span><span>1</span><span>,</span><span> </span><span>k</span><span> </span><span>-</span><span> </span><span>2</span><span>)</span><span> </span><span>==</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span>
                    </span><span>return</span><span> </span><span>i</span><span> </span><span>+</span><span> </span><span>j</span><span>;</span><span>
                </span><span>}</span><span>
            </span><span>}</span><span>
        </span><span>}</span><span>

        </span><span>for</span><span> </span><span>(</span><span>int</span><span> </span><span>j</span><span>=</span><span>0</span><span>;</span><span> </span><span>j</span><span> </span><span>&lt;</span><span> </span><span>8</span><span>;</span><span> </span><span>j</span><span>++</span><span>)</span><span> </span><span>{</span><span>
            </span><span>if</span><span> </span><span>(</span><span>tmp</span><span>[</span><span>j</span><span>]</span><span> </span><span>&amp;</span><span> </span><span>0xf0</span><span>)</span><span> </span><span>{</span><span>
                </span><span>if</span><span> </span><span>(</span><span>memcmp</span><span>(</span><span>s</span><span> </span><span>+</span><span> </span><span>i</span><span> </span><span>+</span><span> </span><span>j</span><span> </span><span>+</span><span> </span><span>1</span><span> </span><span>+</span><span> </span><span>8</span><span>,</span><span> </span><span>needle</span><span> </span><span>+</span><span> </span><span>1</span><span>,</span><span> </span><span>k</span><span> </span><span>-</span><span> </span><span>2</span><span>)</span><span> </span><span>==</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span>
                    </span><span>return</span><span> </span><span>i</span><span> </span><span>+</span><span> </span><span>j</span><span> </span><span>+</span><span> </span><span>8</span><span>;</span><span>
                </span><span>}</span><span>
            </span><span>}</span><span>
        </span><span>}</span><span>
    </span><span>}</span><span>

    </span><span>return</span><span> </span><span>std</span><span>::</span><span>string</span><span>::</span><span>npos</span><span>;</span><span>
</span><span>}</span>
</pre>
<p>It appeared that unrolling the two inner loops brought about 1.2 speedup.</p>
</div>
<div id="aarch64-64-bit-code">
<h3>AArch64 (64 bit code)</h3>
<p>AArch64 code is almost the exact copy of the above ARM Neon procedure.
The only exception is direct reading of SIMD registers lanes, as the
architecture made this operation fast.</p>
</div>
</div>
</div>
<div id="algorithm-2-sse-specific-mpsadbw">

<div id="algorithm-1">
<h2>Algorithm</h2>
<p>SSE4.1 and AVX2 provide instruction <tt>MPSADBW</tt>, which calculates eight
<a href="http://en.wikipedia.org/wiki/Taxicab_geometry">Manhattan distances</a> (L1) between given 4-byte
sub-vector from one register and eight subsequent 4-byte sub-vector from
second register. The instruction returns vector of eight words (16-bit values).</p>
<p>When two sub-vectors are equal, then the L1 distance is 0, and we may use this
property to locate possible substring locations. In other words <strong>equality of
four leading characters</strong> is used as a predicate.</p>
<p>Albeit it seems to be a stronger predicate than matching the first and the last
characters, a quadratic complexity is unavoidable.  For example, when the
searched string contains one letter &#34;a&#34;, and we&#39;re looking for &#34;aaaabcde&#34;, then
the predicate obviously will be true for all input characters.</p>
<p>If it isn&#39;t enough, there are following problems:</p>
<ul>
<li>This method handles substring not shorter than four characters.
Handling three-char substrings is viable, but require additional code.</li>
<li>SSE variant of <tt>MPSADBW</tt> processes only 8 bytes at once, while the
generic SIMD variant uses the whole register.</li>
<li>AVX2 variant of <tt>MPSADBW</tt> works on lanes, i.e. 128-bit helves of
a register rather than the whole 256-bit register. This imposes
additional code to properly load data.</li>
<li>Latency of the instruction is pretty hight — 5 or 7 cycles,
depending on CPU architecture. Luckily throughput is 1 or 2 cycles,
thus unrolling a loop can hide latency.</li>
</ul>
</div>
<div id="implementation-1">
<h2>Implementation</h2>
<div id="sse">
<h3>SSE</h3>
<p>The generic, simplest implementation.</p>
<pre><span>size_t</span><span> </span><span>sse4_strstr_anysize</span><span>(</span><span>const</span><span> </span><span>char</span><span>*</span><span> </span><span>s</span><span>,</span><span> </span><span>size_t</span><span> </span><span>n</span><span>,</span><span> </span><span>const</span><span> </span><span>char</span><span>*</span><span> </span><span>needle</span><span>,</span><span> </span><span>size_t</span><span> </span><span>needle_size</span><span>)</span><span> </span><span>{</span><span>

    </span><span>const</span><span> </span><span>__m128i</span><span> </span><span>prefix</span><span> </span><span>=</span><span> </span><span>_mm_loadu_si128</span><span>(</span><span>reinterpret_cast</span><span>&lt;</span><span>const</span><span> </span><span>__m128i</span><span>*&gt;</span><span>(</span><span>needle</span><span>));</span><span>
    </span><span>const</span><span> </span><span>__m128i</span><span> </span><span>zeros</span><span>  </span><span>=</span><span> </span><span>_mm_setzero_si128</span><span>();</span><span>

    </span><span>for</span><span> </span><span>(</span><span>size_t</span><span> </span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>n</span><span>;</span><span> </span><span>i</span><span> </span><span>+=</span><span> </span><span>8</span><span>)</span><span> </span><span>{</span><span>

        </span><span>const</span><span> </span><span>__m128i</span><span> </span><span>data</span><span>   </span><span>=</span><span> </span><span>_mm_loadu_si128</span><span>(</span><span>reinterpret_cast</span><span>&lt;</span><span>const</span><span> </span><span>__m128i</span><span>*&gt;</span><span>(</span><span>s</span><span> </span><span>+</span><span> </span><span>i</span><span>));</span><span>
        </span><span>const</span><span> </span><span>__m128i</span><span> </span><span>result</span><span> </span><span>=</span><span> </span><span>_mm_mpsadbw_epu8</span><span>(</span><span>data</span><span>,</span><span> </span><span>prefix</span><span>,</span><span> </span><span>0</span><span>);</span><span>

        </span><span>const</span><span> </span><span>__m128i</span><span> </span><span>cmp</span><span>    </span><span>=</span><span> </span><span>_mm_cmpeq_epi16</span><span>(</span><span>result</span><span>,</span><span> </span><span>zeros</span><span>);</span><span>

        </span><span>unsigned</span><span> </span><span>mask</span><span> </span><span>=</span><span> </span><span>_mm_movemask_epi8</span><span>(</span><span>cmp</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>0x5555</span><span>;</span><span>

        </span><span>while</span><span> </span><span>(</span><span>mask</span><span> </span><span>!=</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span>

            </span><span>const</span><span> </span><span>auto</span><span> </span><span>bitpos</span><span> </span><span>=</span><span> </span><span>bits</span><span>::</span><span>get_first_bit_set</span><span>(</span><span>mask</span><span>)</span><span>/</span><span>2</span><span>;</span><span>

            </span><span>if</span><span> </span><span>(</span><span>memcmp</span><span>(</span><span>s</span><span> </span><span>+</span><span> </span><span>i</span><span> </span><span>+</span><span> </span><span>bitpos</span><span> </span><span>+</span><span> </span><span>4</span><span>,</span><span> </span><span>needle</span><span> </span><span>+</span><span> </span><span>4</span><span>,</span><span> </span><span>needle_size</span><span> </span><span>-</span><span> </span><span>4</span><span>)</span><span> </span><span>==</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span>
                </span><span>return</span><span> </span><span>i</span><span> </span><span>+</span><span> </span><span>bitpos</span><span>;</span><span>
            </span><span>}</span><span>

            </span><span>mask</span><span> </span><span>=</span><span> </span><span>bits</span><span>::</span><span>clear_leftmost_set</span><span>(</span><span>mask</span><span>);</span><span>
        </span><span>}</span><span>
    </span><span>}</span><span>

    </span><span>return</span><span> </span><span>std</span><span>::</span><span>string</span><span>::</span><span>npos</span><span>;</span><span>
</span><span>}</span>
</pre>
</div>
<div id="avx512f-1">
<h3>AVX512F</h3>
<p>Although AVX512F doesn&#39;t support <tt>MPSADBW</tt> (AVX512BW defines it) we still
can use 4-byte prefix equality as a predicate, utilizing fact that 32-bit
elements are natively supported.</p>
<p>In each iteration we generate four AVX512 vectors containing all possible
4-byte prefixes. Example:</p>
<pre>string = &#34;the-cat-tries-to-eat...&#34;

vec0  = [ t | h | e | - ][ c | a | t | - ][ t | r | i | e ][ s | - | t | o ][ ... ]
vec1  = [ h | e | - | c ][ a | t | - | t ][ r | i | e | s ][ - | t | o | - ][ ... ]
vec2  = [ e | - | c | a ][ t | - | t | r ][ i | e | s | - ][ t | o | - | e ][ ... ]
vec3  = [ - | c | a | t ][ - | t | r | i ][ e | s | - | t ][ o | - ] e | a ][ ... ]
</pre>
<p>Vector <tt>vec0</tt> contains prefixes for position 0, 4, 8, 12, ...;
<tt>vec1</tt> — 1, 5, 9, 13, ..., <tt>vec2</tt> — 2, 6, 10, 14, ...;
<tt>vec3</tt> — 3, 7, 11, 15, etc.</p>
<p>Building each vector require two shifts and one bitwise or. In each iteration
four vector comparison are performed and then four bitmasks are examined. This
make a loop, which compares substrings, quite complicated.</p>
<p>Moreover, to properly fill the last elements of vectors we need four bytes
beyond vector.  This is accomplished by having two adjacent vectors per
iterations (one load per iteration is needed, though). Finally, instruction
<tt>VPALIGNR</tt> is used to extract required data.</p>
<pre><span>size_t</span><span> </span><span>avx512f_strstr_long</span><span>(</span><span>const</span><span> </span><span>char</span><span>*</span><span> </span><span>string</span><span>,</span><span> </span><span>size_t</span><span> </span><span>n</span><span>,</span><span> </span><span>const</span><span> </span><span>char</span><span>*</span><span> </span><span>needle</span><span>,</span><span> </span><span>size_t</span><span> </span><span>k</span><span>)</span><span> </span><span>{</span><span>

    </span><span>__m512i</span><span> </span><span>curr</span><span>;</span><span>
    </span><span>__m512i</span><span> </span><span>next</span><span>;</span><span>
    </span><span>__m512i</span><span> </span><span>v0</span><span>,</span><span> </span><span>v1</span><span>,</span><span> </span><span>v2</span><span>,</span><span> </span><span>v3</span><span>;</span><span>

    </span><span>char</span><span>*</span><span> </span><span>haystack</span><span> </span><span>=</span><span> </span><span>const_cast</span><span>&lt;</span><span>char</span><span>*&gt;</span><span>(</span><span>string</span><span>);</span><span>
    </span><span>char</span><span>*</span><span> </span><span>last</span><span>     </span><span>=</span><span> </span><span>haystack</span><span> </span><span>+</span><span> </span><span>n</span><span>;</span><span>

    </span><span>const</span><span> </span><span>uint32_t</span><span> </span><span>prf</span><span>   </span><span>=</span><span> </span><span>*</span><span>(</span><span>uint32_t</span><span>*</span><span>)</span><span>needle</span><span>;</span><span> </span><span>// the first 4 bytes of needle
</span><span>    </span><span>const</span><span> </span><span>__m512i</span><span> </span><span>prefix</span><span> </span><span>=</span><span> </span><span>_mm512_set1_epi32</span><span>(</span><span>prf</span><span>);</span><span>

    </span><span>next</span><span> </span><span>=</span><span> </span><span>_mm512_loadu_si512</span><span>(</span><span>haystack</span><span>);</span><span>

    </span><span>for</span><span> </span><span>(</span><span>/**/</span><span>;</span><span> </span><span>haystack</span><span> </span><span>&lt;</span><span> </span><span>last</span><span>;</span><span> </span><span>haystack</span><span> </span><span>+=</span><span> </span><span>64</span><span>)</span><span> </span><span>{</span><span>

        </span><span>curr</span><span> </span><span>=</span><span> </span><span>next</span><span>;</span><span>
        </span><span>next</span><span> </span><span>=</span><span> </span><span>_mm512_loadu_si512</span><span>(</span><span>haystack</span><span> </span><span>+</span><span> </span><span>64</span><span>);</span><span>
        </span><span>const</span><span> </span><span>__m512i</span><span> </span><span>shft</span><span> </span><span>=</span><span> </span><span>_mm512_alignr_epi32</span><span>(</span><span>next</span><span>,</span><span> </span><span>curr</span><span>,</span><span> </span><span>1</span><span>);</span><span>

        </span><span>v0</span><span> </span><span>=</span><span> </span><span>curr</span><span>;</span><span>

        </span><span>{</span><span>
            </span><span>const</span><span> </span><span>__m512i</span><span> </span><span>t1</span><span> </span><span>=</span><span> </span><span>_mm512_srli_epi32</span><span>(</span><span>curr</span><span>,</span><span> </span><span>8</span><span>);</span><span>
            </span><span>const</span><span> </span><span>__m512i</span><span> </span><span>t2</span><span> </span><span>=</span><span> </span><span>_mm512_slli_epi32</span><span>(</span><span>shft</span><span>,</span><span> </span><span>24</span><span>);</span><span>
            </span><span>v1</span><span> </span><span>=</span><span> </span><span>_mm512_or_si512</span><span>(</span><span>t1</span><span>,</span><span> </span><span>t2</span><span>);</span><span>
        </span><span>}</span><span>
        </span><span>{</span><span>
            </span><span>const</span><span> </span><span>__m512i</span><span> </span><span>t1</span><span> </span><span>=</span><span> </span><span>_mm512_srli_epi32</span><span>(</span><span>curr</span><span>,</span><span> </span><span>16</span><span>);</span><span>
            </span><span>const</span><span> </span><span>__m512i</span><span> </span><span>t2</span><span> </span><span>=</span><span> </span><span>_mm512_slli_epi32</span><span>(</span><span>shft</span><span>,</span><span> </span><span>16</span><span>);</span><span>
            </span><span>v2</span><span> </span><span>=</span><span> </span><span>_mm512_or_si512</span><span>(</span><span>t1</span><span>,</span><span> </span><span>t2</span><span>);</span><span>
        </span><span>}</span><span>
        </span><span>{</span><span>
            </span><span>const</span><span> </span><span>__m512i</span><span> </span><span>t1</span><span> </span><span>=</span><span> </span><span>_mm512_srli_epi32</span><span>(</span><span>curr</span><span>,</span><span> </span><span>24</span><span>);</span><span>
            </span><span>const</span><span> </span><span>__m512i</span><span> </span><span>t2</span><span> </span><span>=</span><span> </span><span>_mm512_slli_epi32</span><span>(</span><span>shft</span><span>,</span><span> </span><span>8</span><span>);</span><span>
            </span><span>v3</span><span> </span><span>=</span><span> </span><span>_mm512_or_si512</span><span>(</span><span>t1</span><span>,</span><span> </span><span>t2</span><span>);</span><span>
        </span><span>}</span><span>

        </span><span>uint16_t</span><span> </span><span>m0</span><span> </span><span>=</span><span> </span><span>_mm512_cmpeq_epi32_mask</span><span>(</span><span>v0</span><span>,</span><span> </span><span>prefix</span><span>);</span><span>
        </span><span>uint16_t</span><span> </span><span>m1</span><span> </span><span>=</span><span> </span><span>_mm512_cmpeq_epi32_mask</span><span>(</span><span>v1</span><span>,</span><span> </span><span>prefix</span><span>);</span><span>
        </span><span>uint16_t</span><span> </span><span>m2</span><span> </span><span>=</span><span> </span><span>_mm512_cmpeq_epi32_mask</span><span>(</span><span>v2</span><span>,</span><span> </span><span>prefix</span><span>);</span><span>
        </span><span>uint16_t</span><span> </span><span>m3</span><span> </span><span>=</span><span> </span><span>_mm512_cmpeq_epi32_mask</span><span>(</span><span>v3</span><span>,</span><span> </span><span>prefix</span><span>);</span><span>

        </span><span>int</span><span> </span><span>index</span><span> </span><span>=</span><span> </span><span>64</span><span>;</span><span>
        </span><span>while</span><span> </span><span>(</span><span>m0</span><span> </span><span>|</span><span> </span><span>m1</span><span> </span><span>|</span><span> </span><span>m2</span><span> </span><span>|</span><span> </span><span>m3</span><span>)</span><span> </span><span>{</span><span>
            </span><span>if</span><span> </span><span>(</span><span>m0</span><span>)</span><span> </span><span>{</span><span>
                </span><span>int</span><span> </span><span>pos</span><span> </span><span>=</span><span> </span><span>__builtin_ctz</span><span>(</span><span>m0</span><span>)</span><span> </span><span>*</span><span> </span><span>4</span><span> </span><span>+</span><span> </span><span>0</span><span>;</span><span>
                </span><span>m0</span><span> </span><span>=</span><span> </span><span>m0</span><span> </span><span>&amp;</span><span> </span><span>(</span><span>m0</span><span> </span><span>-</span><span> </span><span>1</span><span>);</span><span>

                </span><span>if</span><span> </span><span>(</span><span>pos</span><span> </span><span>&lt;</span><span> </span><span>index</span><span> </span><span>&amp;&amp;</span><span> </span><span>memcmp</span><span>(</span><span>haystack</span><span> </span><span>+</span><span> </span><span>pos</span><span> </span><span>+</span><span> </span><span>4</span><span>,</span><span> </span><span>needle</span><span> </span><span>+</span><span> </span><span>4</span><span>,</span><span> </span><span>k</span><span> </span><span>-</span><span> </span><span>4</span><span>)</span><span> </span><span>==</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span>
                    </span><span>index</span><span> </span><span>=</span><span> </span><span>pos</span><span>;</span><span>
                </span><span>}</span><span>
            </span><span>}</span><span>

            </span><span>if</span><span> </span><span>(</span><span>m1</span><span>)</span><span> </span><span>{</span><span>
                </span><span>int</span><span> </span><span>pos</span><span> </span><span>=</span><span> </span><span>__builtin_ctz</span><span>(</span><span>m1</span><span>)</span><span> </span><span>*</span><span> </span><span>4</span><span> </span><span>+</span><span> </span><span>1</span><span>;</span><span>
                </span><span>m1</span><span> </span><span>=</span><span> </span><span>m1</span><span> </span><span>&amp;</span><span> </span><span>(</span><span>m1</span><span> </span><span>-</span><span> </span><span>1</span><span>);</span><span>

                </span><span>if</span><span> </span><span>(</span><span>pos</span><span> </span><span>&lt;</span><span> </span><span>index</span><span> </span><span>&amp;&amp;</span><span> </span><span>memcmp</span><span>(</span><span>haystack</span><span> </span><span>+</span><span> </span><span>pos</span><span> </span><span>+</span><span> </span><span>4</span><span>,</span><span> </span><span>needle</span><span> </span><span>+</span><span> </span><span>4</span><span>,</span><span> </span><span>k</span><span> </span><span>-</span><span> </span><span>4</span><span>)</span><span> </span><span>==</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span>
                    </span><span>index</span><span> </span><span>=</span><span> </span><span>pos</span><span>;</span><span>
                </span><span>}</span><span>
            </span><span>}</span><span>

            </span><span>if</span><span> </span><span>(</span><span>m2</span><span>)</span><span> </span><span>{</span><span>
                </span><span>int</span><span> </span><span>pos</span><span> </span><span>=</span><span> </span><span>__builtin_ctz</span><span>(</span><span>m2</span><span>)</span><span> </span><span>*</span><span> </span><span>4</span><span> </span><span>+</span><span> </span><span>2</span><span>;</span><span>
                </span><span>m2</span><span> </span><span>=</span><span> </span><span>m2</span><span> </span><span>&amp;</span><span> </span><span>(</span><span>m2</span><span> </span><span>-</span><span> </span><span>1</span><span>);</span><span>

                </span><span>if</span><span> </span><span>(</span><span>pos</span><span> </span><span>&lt;</span><span> </span><span>index</span><span> </span><span>&amp;&amp;</span><span> </span><span>memcmp</span><span>(</span><span>haystack</span><span> </span><span>+</span><span> </span><span>pos</span><span> </span><span>+</span><span> </span><span>4</span><span>,</span><span> </span><span>needle</span><span> </span><span>+</span><span> </span><span>4</span><span>,</span><span> </span><span>k</span><span> </span><span>-</span><span> </span><span>4</span><span>)</span><span> </span><span>==</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span>
                    </span><span>index</span><span> </span><span>=</span><span> </span><span>pos</span><span>;</span><span>
                </span><span>}</span><span>
            </span><span>}</span><span>

            </span><span>if</span><span> </span><span>(</span><span>m3</span><span>)</span><span> </span><span>{</span><span>
                </span><span>int</span><span> </span><span>pos</span><span> </span><span>=</span><span> </span><span>__builtin_ctz</span><span>(</span><span>m3</span><span>)</span><span> </span><span>*</span><span> </span><span>4</span><span> </span><span>+</span><span> </span><span>3</span><span>;</span><span>
                </span><span>m3</span><span> </span><span>=</span><span> </span><span>m3</span><span> </span><span>&amp;</span><span> </span><span>(</span><span>m3</span><span> </span><span>-</span><span> </span><span>1</span><span>);</span><span>

                </span><span>if</span><span> </span><span>(</span><span>pos</span><span> </span><span>&lt;</span><span> </span><span>index</span><span> </span><span>&amp;&amp;</span><span> </span><span>memcmp</span><span>(</span><span>haystack</span><span> </span><span>+</span><span> </span><span>pos</span><span> </span><span>+</span><span> </span><span>4</span><span>,</span><span> </span><span>needle</span><span> </span><span>+</span><span> </span><span>4</span><span>,</span><span> </span><span>k</span><span> </span><span>-</span><span> </span><span>4</span><span>)</span><span> </span><span>==</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span>
                    </span><span>index</span><span> </span><span>=</span><span> </span><span>pos</span><span>;</span><span>
                </span><span>}</span><span>
            </span><span>}</span><span>
        </span><span>}</span><span>

        </span><span>if</span><span> </span><span>(</span><span>index</span><span> </span><span>&lt;</span><span> </span><span>64</span><span>)</span><span> </span><span>{</span><span>
            </span><span>return</span><span> </span><span>(</span><span>haystack</span><span> </span><span>-</span><span> </span><span>string</span><span>)</span><span> </span><span>+</span><span> </span><span>index</span><span>;</span><span>
        </span><span>}</span><span>
    </span><span>}</span><span>

    </span><span>return</span><span> </span><span>size_t</span><span>(</span><span>-1</span><span>);</span><span>
</span><span>}</span>
</pre>
</div>
</div>
</div>
<div id="algorithm-3-sse4-2-specific-pcmpestrm">

<div id="algorithm-2">
<h2>Algorithm</h2>
<p>SSE4.2 introduced <a href="http://en.wikipedia.org/wiki/SSE4#SSE4.2">String and Text New Instructions</a> (STNI), a set of very
complex instructions that were meant to be a building block for string
operations.  Unfortunately, Intel practically discontinued STNI in newer
processors, hasn&#39;t introduced AVX2 versions of STNI and make them extremely
slow (11 cycles latency is unacceptable).</p>
<p>Basically <tt>PCMPxSTRx</tt> instruction exists in four variants, which differs
only in:</p>
<ol>
<li>A way to determine string length: the length might be given explicitly
or the first zero byte marks string end, as in traditional C strings.</li>
<li>How the result is saved, it might be either a bit-mask/byte-mask or
the number of first/last bit set in the bit-mask.</li>
</ol>
<p>Additional instruction&#39;s argument (immediate constant) defines several aspects
of execution, specifically the algorithm of comparison.  There are four
different algorithms available, one we&#39;re using is called <strong>range ordered</strong>.
Despite the name, this algorithm locates substring, or its prefix if a
substring goes beyond register width.</p>
<p>For example, when we&#39;re searching &#34;ABCD&#34; in &#34;ABCD_ABC_ABCD_AB&#34; the instruction
returns bitmask 0b0100001000000001, treating suffix &#34;AB&#34; as a match. Thus we
can safely assume that only <strong>the first character matches</strong>, as tail might or
might not be present in a register. (Of course it can be determined, but
require additional calculations which is not very handy.)</p>
<p>Below is a code snippet which does the above operation.</p>
<pre><span>const</span><span> </span><span>char</span><span>*</span><span> </span><span>s1</span><span> </span><span>=</span><span> </span><span>&#34;ABCD_ABC_ABCD_AB&#34;</span><span>;</span><span>
</span><span>const</span><span> </span><span>char</span><span>*</span><span> </span><span>s2</span><span> </span><span>=</span><span> </span><span>&#34;ABCD____________&#34;</span><span>;</span><span>

</span><span>const</span><span> </span><span>int</span><span> </span><span>mode</span><span> </span><span>=</span><span> </span><span>_SIDD_UBYTE_OPS</span><span>
               </span><span>|</span><span> </span><span>_SIDD_CMP_EQUAL_ORDERED</span><span>
               </span><span>|</span><span> </span><span>_SIDD_BIT_MASK</span><span>;</span><span>

</span><span>const</span><span> </span><span>__m128i</span><span> </span><span>N</span><span>   </span><span>=</span><span> </span><span>_mm_loadu_si128</span><span>((</span><span>__m128i</span><span>*</span><span>)(</span><span>s2</span><span>));</span><span>
</span><span>const</span><span> </span><span>__m128i</span><span> </span><span>D</span><span>   </span><span>=</span><span> </span><span>_mm_loadu_si128</span><span>((</span><span>__m128i</span><span>*</span><span>)(</span><span>s1</span><span>));</span><span>
</span><span>const</span><span> </span><span>__m128i</span><span> </span><span>res</span><span> </span><span>=</span><span> </span><span>_mm_cmpestrm</span><span>(</span><span>N</span><span>,</span><span> </span><span>4</span><span>,</span><span> </span><span>D</span><span>,</span><span> </span><span>16</span><span>,</span><span> </span><span>mode</span><span>);</span><span>
</span><span>uint64_t</span><span> </span><span>mask</span><span> </span><span>=</span><span> </span><span>_mm_cvtsi128_si64</span><span>(</span><span>res</span><span>);</span><span> </span><span>// = 0b0100001000000001</span>
</pre>
</div>
<div id="implementation-2">
<h2>Implementation</h2>
<div id="sse-1">
<h3>SSE</h3>
<pre><span>size_t</span><span> </span><span>sse42_strstr_anysize</span><span>(</span><span>const</span><span> </span><span>char</span><span>*</span><span> </span><span>s</span><span>,</span><span> </span><span>size_t</span><span> </span><span>n</span><span>,</span><span> </span><span>const</span><span> </span><span>char</span><span>*</span><span> </span><span>needle</span><span>,</span><span> </span><span>size_t</span><span> </span><span>k</span><span>)</span><span> </span><span>{</span><span>

    </span><span>const</span><span> </span><span>__m128i</span><span> </span><span>N</span><span> </span><span>=</span><span> </span><span>_mm_loadu_si128</span><span>((</span><span>__m128i</span><span>*</span><span>)</span><span>needle</span><span>);</span><span>

    </span><span>for</span><span> </span><span>(</span><span>size_t</span><span> </span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>n</span><span>;</span><span> </span><span>i</span><span> </span><span>+=</span><span> </span><span>16</span><span>)</span><span> </span><span>{</span><span>

        </span><span>const</span><span> </span><span>int</span><span> </span><span>mode</span><span> </span><span>=</span><span> </span><span>_SIDD_UBYTE_OPS</span><span>
                       </span><span>|</span><span> </span><span>_SIDD_CMP_EQUAL_ORDERED</span><span>
                       </span><span>|</span><span> </span><span>_SIDD_BIT_MASK</span><span>;</span><span>

        </span><span>const</span><span> </span><span>__m128i</span><span> </span><span>D</span><span>   </span><span>=</span><span> </span><span>_mm_loadu_si128</span><span>((</span><span>__m128i</span><span>*</span><span>)(</span><span>s</span><span> </span><span>+</span><span> </span><span>i</span><span>));</span><span>
        </span><span>const</span><span> </span><span>__m128i</span><span> </span><span>res</span><span> </span><span>=</span><span> </span><span>_mm_cmpestrm</span><span>(</span><span>N</span><span>,</span><span> </span><span>k</span><span>,</span><span> </span><span>D</span><span>,</span><span> </span><span>n</span><span> </span><span>-</span><span> </span><span>i</span><span>,</span><span> </span><span>mode</span><span>);</span><span>
        </span><span>uint64_t</span><span> </span><span>mask</span><span> </span><span>=</span><span> </span><span>_mm_cvtsi128_si64</span><span>(</span><span>res</span><span>);</span><span>

        </span><span>while</span><span> </span><span>(</span><span>mask</span><span> </span><span>!=</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span>

            </span><span>const</span><span> </span><span>auto</span><span> </span><span>bitpos</span><span> </span><span>=</span><span> </span><span>bits</span><span>::</span><span>get_first_bit_set</span><span>(</span><span>mask</span><span>);</span><span>

            </span><span>// we know that at least the first character of needle matches
</span><span>            </span><span>if</span><span> </span><span>(</span><span>memcmp</span><span>(</span><span>s</span><span> </span><span>+</span><span> </span><span>i</span><span> </span><span>+</span><span> </span><span>bitpos</span><span> </span><span>+</span><span> </span><span>1</span><span>,</span><span> </span><span>needle</span><span> </span><span>+</span><span> </span><span>1</span><span>,</span><span> </span><span>k</span><span> </span><span>-</span><span> </span><span>1</span><span>)</span><span> </span><span>==</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span>
                </span><span>return</span><span> </span><span>i</span><span> </span><span>+</span><span> </span><span>bitpos</span><span>;</span><span>
            </span><span>}</span><span>

            </span><span>mask</span><span> </span><span>=</span><span> </span><span>bits</span><span>::</span><span>clear_leftmost_set</span><span>(</span><span>mask</span><span>);</span><span>
        </span><span>}</span><span>
    </span><span>}</span><span>

    </span><span>return</span><span> </span><span>std</span><span>::</span><span>string</span><span>::</span><span>npos</span><span>;</span><span>
</span><span>}</span>
</pre>
</div>
</div>
</div>
<div id="performance-results">

<p>Performance of various SIMD implementations were measured.  Test programs also
have got specialisation for short substrings, that are selected at run time.
Performance of a C <tt>strstr</tt> is included for comparison.  I omitted C++
<tt><span>string::find</span></tt> due to <a href="https://nmn.gl/blog/2016-10-08-slow-std-string-find.html">performance bug in GNU libc</a> which makes the method
10 times slower than <tt>strstr</tt>.</p>
<p>Test programs were run three times. Following computers, running either
Debian or Ubuntu, were tested:</p>
<ol>
<li>Westmere i5 M540, GCC 6.2.0,</li>
<li>Bulldozer FX-8150 CPU, GCC 4.8.4</li>
<li>Haswell i7 4470, GCC 5.4.1,</li>
<li>Skylake i7 6700, GCC 5.4.1,</li>
<li>Knights Landing (KNL) 7210, GCC 5.3.0.</li>
<li>ARMv7 (Raspberry Pi 3, 32-bit code), GCC 4.9.2</li>
<li>ARMv8 (<a href="https://shop.softiron.com/product/overdrive-1000/">ARM Cortex A57 - AMD Opteron A1100</a>, 64-bit code), Clang 3.8.0</li>
</ol>
<div id="x64-computers">
<h2>x64 computers</h2>
<table>
<colgroup>
<col width="34%"/>
<col width="13%"/>
<col width="13%"/>
<col width="13%"/>
<col width="13%"/>
<col width="13%"/>
</colgroup>
<thead>
<tr><th rowspan="2">procedure</th>
<th colspan="5">time in seconds</th>
</tr>
<tr><th>Westemere</th>
<th>Bulldozer</th>
<th>Haswell</th>
<th>Skylake</th>
<th>KNL</th>
</tr>
</thead>
<tbody>
<tr><td>std::strstr</td>
<td>0.82246</td>
<td>9.37792</td>
<td>0.52786</td>
<td>0.66148</td>
<td>4.94606</td>
</tr>
<tr><td>std::string::find</td>
<td>---</td>
<td>---</td>
<td>---</td>
<td>---</td>
<td>---</td>
</tr>
<tr><td><a href="#generic-swar">SWAR 64-bit (generic)</a></td>
<td>2.49859</td>
<td>2.93836</td>
<td>1.57715</td>
<td>1.40404</td>
<td>8.17075</td>
</tr>
<tr><td><a href="#generic-sse-avx2">SSE2 (generic)</a></td>
<td><strong>0.74589</strong></td>
<td><strong>0.78871</strong></td>
<td>0.55435</td>
<td><strong>0.48863</strong></td>
<td>6.10786</td>
</tr>
<tr><td><a href="#mpsadbw-sse-avx2">SSE4.1 (MPSADBW)</a></td>
<td>1.45040</td>
<td>1.98863</td>
<td>0.89775</td>
<td><strong>0.63875</strong></td>
<td>18.71666</td>
</tr>
<tr><td>SSE4.1 (MPSADBW unrolled)</td>
<td>1.23849</td>
<td>2.06008</td>
<td>0.99647</td>
<td>0.87919</td>
<td>13.72486</td>
</tr>
<tr><td><a href="#pcmpstr-sse">SSE4.2 (PCMPESTRM)</a></td>
<td>1.69968</td>
<td>2.00681</td>
<td>1.55992</td>
<td>1.39063</td>
<td>6.28869</td>
</tr>
<tr><td><a href="#mpsadbw-sse-avx2">AVX2 (MPSADBW)</a></td>
<td> </td>
<td> </td>
<td>0.61578</td>
<td><strong>0.56981</strong></td>
<td>13.15136</td>
</tr>
<tr><td><a href="#generic-sse-avx2">AVX2 (generic)</a></td>
<td> </td>
<td> </td>
<td><strong>0.38653</strong></td>
<td><strong>0.36309</strong></td>
<td><strong>4.09478</strong></td>
</tr>
<tr><td><a href="#mpsadbw-avx512f">AVX512F (MPSADBW-like)</a></td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
<td><strong>2.32616</strong></td>
</tr>
<tr><td><a href="#generic-avx512f">AVX512F (generic)</a></td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
<td><strong>1.14057</strong></td>
</tr>
<tr><td>biggest speed-up to <tt>strstr</tt></td>
<td>1.10</td>
<td>---</td>
<td>1.37</td>
<td>1.82</td>
<td>4.33</td>
</tr>
</tbody>
</table>
<ul>
<li>Performance of <tt>strstr</tt> on the machine with Bulldozer is terrible, it&#39;d pointless to use
it as a reference.</li>
</ul>
</div>

<div id="conclusions-and-remarks">
<h2>Conclusions and remarks</h2>
<ul>
<li>The generic SIMD algorithm outperforms C <tt>strstr</tt> on all platforms.
An implementation should use the highest SIMD version available on
a certain CPU.</li>
<li><tt>MPSADBW</tt> performs pretty bad, with an exception for Skylake.
Knights Landing performance is terrible.</li>
<li><tt>PCMPESTRM</tt> performs worse than <tt>MPSADBW</tt>.</li>
<li>ARM Neon performance is pretty good even for SWAR implementation.
The SWAR version is 1.7 times faster than <tt><span>string::find</span></tt>, SIMD
version is 3.1 times faster.</li>
<li>AArch64 performance of scalar SWAR64 is almost as good as 32-bit SIMD
procedure.</li>
<li>Comparison with <tt>strstr</tt> might be considered unfair, as the
procedure deals with string of unknown length, while my implementations
get lengths and take advantage of this. I fully agree.</li>
<li>Procedures I implemented are also unsafe, because might read data off
the input string. This may lead to access violation if strings are
located just before unmapped memory. And for sure address sanitizers
will complain. Making the procedures safe is feasible, but it wasn&#39;t
my goal.</li>
</ul>
</div>
</div>
<div id="acknowledgments">

<p><a href="http://lemire.me">Daniel Lemire</a> has gave me access to Haswell, Skylake, KNL, Bulldozer
and ARMv8 machines, where I compiled and run test programs. Thank you!</p>
</div>
<div id="source-code">

<p>All implementations and tests programs are available at <a href="https://github.com/WojciechMula/sse4-strstr">github</a>.</p>
</div>
<div id="history">

<ul>
<li>2017-04-29 — ARMv8 results</li>
<li>2017-01-30 — better timings from Raspberry Pi 3</li>
<li>2017-01-26 — ARM Neon &amp; results from Raspberry Pi 3</li>
<li>2017-01-25 — spelling</li>
<li>2016-12-22 — added results from Bulldozer</li>
<li>2016-11-30 — spelling</li>
</ul>
</div>
</div></div>
  </body>
</html>
