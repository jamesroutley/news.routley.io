<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://redpenguin101.github.io/html/posts/2025_11_23_emacs_for_code_editing.html">Original</a>
    <h1>Editing Code in Emacs</h1>
    
    <div id="readability-page-1" class="page">

<p>When you write code, you want to focus on the code, not on the text
of the code. This means a) you have to have a good text editing setup,
and b) you need to have a muscle-memory level instinct for using that
setup. The second comes with practice and with <em>consistency</em>
(i.e. not changing your config too much too quickly). The first is what
I will talk about here.</p>
<p>This document is meant for people who are current users of, or at
least slightly familiar with Emacs. I won’t spend much time explaining
Emacs basics - for example how incremental search, or compilation
buffers work (I would recommend <a href="https://www.masteringemacs.org/book">Mastering Emacs</a> for
that). But I will give rationales for the choices I’ve made in
encouraging or discouraging certain patterns.</p>
<p>You can read this in two ways: The general Emacs commands I use to
try to edit the text of programs efficiently, and the specific keybinds
I use in my modal ‘command’ mode to make those commands as convenient as
possible.</p>
<h2 id="no-mouse-no-arrows">No Mouse, No Arrows</h2>
<p>All text editing practices rely on minimising the work your fingers
do by minimising the number of keystrokes and keeping your fingers as
close to the home row as possible. This means no arrow keys and no
mouse. This can be enforced by remapping your arrow keys to
<code>ignore</code>, and by installing the package
<code>disable-mouse</code>.</p>
<h2 id="modal-editing-command-and-insert-modes">Modal Editing: Command
and Insert Modes</h2>
<p>Editing code is different from writing prose in that you spend a lot
more time moving around the document, and moving things around
<em>in</em> the document, than actually writing text. The actions for
moving are more important than the actions for typing, and should
therefore be closer to hand. This is the premise of <em>modal
editing</em>: the “default” actions of most keyboard keys are to move,
not to type. For example in the default ‘mode’, hitting ‘a’ doesn’t type
the ‘a’ character, it moves the cursor to the start of the line. To
actually type things, you need to hit a special key which puts you in
‘insert’ mode. Then when you are finished typing, you hit another key
which puts you in the default (or ‘command’) mode.</p>
<p>My modal system is <a href="https://github.com/RedPenguin101/dotfiles/blob/main/modal.el">custom
written</a> and very lightweight - about 150 lines, not including the
keybinds themselves. I recommend using <em>a</em> modal system, if not
mine then someone elses, such as Evil or Meow. But if you really dislike
them, you can still do everything I describe here in vanilla emacs, and
most of the commands already have default keybinds. There are only four
‘custom’ functions I use: the half page scrolls, and the
kill-whole-word/sexp. And all are very simple.</p>
<h2 id="a-note-on-defaults">A note on defaults</h2>
<p>A problem with customised setups is that they mean you can’t pick up
your friend’s Emacs setup and use it, because your muscle memory will
cause you to hit all the wrong keys. This effect can be mitigated by
sticking with the ‘language’ of the system. Emacs has pretty clear (if
arguably not very good) conventions for most of it’s keys:
<code>f</code> means forward, <code>n</code> means next,
<code>C-g</code> is always ‘cancel’. My setup tries to stick with these
conventions as much as possible. <code>f</code> in command mode is
‘forward-word’. <code>n</code> is ‘next line’.</p>
<p>Additionally there is basically no remapping <em>for insert
mode</em>. The idea being that editing in a vanilla Emacs is the same as
editing using only insert mode in my setup. I find that you spend a fair
amount of time navigating from <em>within</em> insert mode even in my
setup, so you won’t lose your muscle memory.</p>
<h2 id="leaders">Leaders</h2>
<p>The most common actions for moving around the screen are on a single
keystroke on command mode. For example, to go to the next line, you hit
<code>n</code>. To go forward by a word, press <code>f</code>.</p>
<p>Less common, but still important commands are usually two or three
keystrokes. For example, save file is <code>vs</code>. Kill word is
<code>kf</code>. In these cases, the first key is a ‘leader’ key. I use
a few leader keys:</p>
<ul>
<li><code>v</code>: A general leader key, but mostly for file, buffer
and window operations.</li>
<li><code>k</code>: Kill leader: most of the kill commands are under
this.</li>
<li><code>s</code>: Search leader: most searches are under this</li>
<li><code>vp</code>: Project leader: contains several operations that
are useful when working on a ‘project’ that consists of many files,
which is very common with programming projects.</li>
</ul>
<h2 id="getting-in-and-out-of-insert-mode">Getting in and out of insert
mode</h2>
<p>To transition from command to insert mode, press <code>i</code>. To
transition from insert to command mode, press <code>C-j</code>.</p>
<p>There are a few more ways to get into insert mode:</p>
<ul>
<li><code>I</code>: Insert after character</li>
<li><code>O</code>: Insert in overwrite mode (overwrite mode will be
cancelled when you return to command mode)</li>
<li><code>A</code>: Insert at start of (indented) line</li>
<li><code>E</code>: Insert at end of line</li>
<li><code>C-RET</code>: Newline and insert</li>
<li><code>S-RET</code>: Newline above and insert</li>
</ul>
<h2 id="moving-vertically">Moving Vertically</h2>
<p>I recommend you set up relative line numbers, and global-hl-line-mode
so you can clearly see which line your cursor is on and how far away
each line is.</p>
<pre><code>(setq-default display-line-numbers-type &#39;relative)
(global-display-line-numbers-mode 1)
(global-hl-line-mode +1)</code></pre>
<p>In command mode press <code>n</code> to move to the next line, and
<code>p</code> to move to the previous line. Often they will be used in
conjunction with a numeric prefix: type <code>12n</code> to move down 12
lines. This number-prefix pattern is general: you can do most commands
multiple times by typing digits before typing the command.</p>
<p><code>r</code> moves up by a half page, and <code>t</code> moves down
by a half page while keeping the cursor line in the middle of the
screen. These are used in preference to the usual <code>scroll-up</code>
and <code>scroll-down</code> commands, which move so much you have to
spend a second reorienting.</p>
<p>Two useful and related actions are <code>recenter-top-bottom</code>
and <code>move-to-window-line-top-bottom</code>. These are bound to
<code>l</code> and <code>L</code> respectively. <code>l</code> moves the
screen around the current highlighted line - first centring the screen
around the hl-line, then putting the hl-line at the top of the screen,
then at the bottom. It’s best to just try it out. <code>L</code> is sort
of the opposite, it moves the <em>cursor</em> around the screen, first
to the center, then to the top, then to the bottom.</p>
<p><code>.</code> and <code>,</code> are ‘beginning-of-defun’ and
‘end-of-defun’. You can think of these as moving by a top level ‘block’.
These are usually pretty useful, but depend on your language mode having
a good definition for what a ‘block’ is.</p>
<p>Less often used, but occasionally useful, are <code>&lt;</code> and
<code>&gt;</code> for moving to the beginning and end of the current
buffer.</p>
<h2 id="moving-horizontally">Moving Horizontally</h2>
<p>Moving horizontally is important, but when programming you should
really avoid using these commands too much in favour of moving in larger
syntactic units - see the later sections on moving by expression and
search.</p>
<p>You should turn on subword mode:</p>
<pre><code>(global-subword-mode 1)</code></pre>
<p>When moving horizontally, try to move in as large a unit as you can.
You should almost never move left or right by an individual character.
The smallest general unit is a “word” - similar to how most editors will
use <code>Ctrl-Right</code> to move right by a word. To move forward by
a word, press <code>f</code>. To move backward by a word, press
<code>b</code>.</p>
<p>The definition of a ‘word’ in Emacs can be a bit tricky, especially
when it comes to programming. <code>foo_bar_baz</code> is <em>three</em>
words. <code>fooBarBaz</code> (if you’ve got subword mode turned on) is
also three words. So for either of these, if your cursor is on the
<code>f</code> of <code>foo</code>, pressing <code>f</code> to go
forward will put you before the <code>baz</code> symbol. This is handy
for changing things within a long variable name. But it’s not great for
rapid navigation. Which is why I recommend moving by <em>expression</em>
over moving by <em>word</em>.</p>
<p>If you must move by a single character, use <code>C-f</code> and
<code>C-b</code> respectively.</p>
<p><code>e</code> moves to the end of the current line. <code>a</code>
moves to the start of the current line, but generally you should prefer
<code>m</code>, which moves to the first non-whitespace character of the
line - which is usually what you want when programming. However, if I’m
trying to move to the start or end of a line, it’s usually because I
want to type something there. And for doing that you can use
<code>A</code> and <code>E</code> respectively, which will move to the
start or end of the line and immediately enter insert mode.</p>
<p>This is it for moving strictly within a line. But for the various
reasons outlined above, you really you shouldn’t use these too much.
There are better ways to move within a line: moving by expression and
moving by search.</p>
<h2 id="moving-by-expression">Moving by Expression</h2>
<p>S-Expressions, or Sexps, are a big thing in lisps and therefore in
Emacs. Most programming languages are syntactically ‘blocks’ of symbols
enclosed in different bracket types. Many use curly braces to denote
execution blocks - function bodies, loops, structure definitions -
square brackets to denote arrays, and parentheses to denote
parameter/argument lists. All fit the s-expression definition. When
you’re moving around a program it can be useful to think in terms of
jumping in to, out of, over, or within those blocks. Emacs has lots of
commands for this, and there are extensions which add even more, but I
really only use four.</p>
<p><code>j</code> moves forward by a sexp. If the cursor is over an
opening bracket of any kind, pressing <code>j</code> will jump
<em>over</em> that whole block. <code>h</code> will do the same thing,
but backwards. This can effectively be used as a ‘jump to matching
bracket’ command.</p>
<p>If on a non-bracket character, these will jump forward or back by one
syntactic symbol. This should generally be preferred to moving by
<em>word</em> because in most cases when programming you want to jump
over the symbol, not the word. For example if are at the start of the
variable name <code>foo_bar_baz</code>, unless you want to change
something in that variable, you probably want to jump over the whole
thing. <code>j</code> will do that, whereas <code>f</code> will jump you
to <code>bar</code>.</p>
<p>The other two I use are ‘down-list’ (<code>d</code>) and up list
(<code>u</code>). These jump <em>into</em> and <em>out of</em> a block.
For example if my editor looks like this, where <code>|</code> is the
cursor position: <code>dele|te(state.im_temp_entity_buffer)</code>, and
I hit <code>d</code>, the cursor will be moved into the next block - in
this case the argument list for delete:
<code>delete(|state.im_temp_entity_buffer)</code>. Pressing
<code>u</code> will move the the cursor <em>out</em> of that list:
<code>delete(state.im_temp_entity_buffer)|</code>. This works on any
type of brackets. These can also be used with a negative argument
(e.g. <code>-d</code>) to go <em>back</em> into and <em>back</em> out of
an expression. You can reverse the above sequence with <code>-d</code>,
resulting in <code>delete(state.im_temp_entity_buffer|)</code>, and then
<code>-u</code> resulting in
<code>delete|(state.im_temp_entity_buffer)</code>.</p>
<p>Using these sexp expressions when programming is usually far more
effective than using the horizontal movements like ‘forward-word’, and
you should get into the habit of preferring them.</p>
<h2 id="moving-by-search">Moving by Search</h2>
<p>Sexps are great, but really the best way to move more than a few
words around your buffer is to move by searching for the string of text
you want to jump to. If the location you want to jump to is on the
screen, this creates a sort of ‘look at, jump to’ dynamic, where you
find where your want your cursor to be with your eyes, type some of the
text at that location, and your cursor is now there. But it also works
great if the location you’re looking for is off the screen.</p>
<p>The simplest commands are the usual ‘isearch-forward’ and
‘isearch-backward’. The mappings for these are unchanged from standard
Emacs: <code>C-s</code> and <code>C-r</code>. There are packages which
provide alternative versions of this - ‘jump-char’ and ‘avy’, for
example - but I find these work fine.</p>
<p>Sometimes you’re searching for something that is pretty common, and
using incremental search is a slog. In this case, you can use occur,
with <code>so</code>, which creates a buffer with all the instances of
the search term, hyperlinked so you can easily jump to that
location.</p>
<p>How to use occur not specific to my setup, but is very useful to
learn, so I’ll go into some detail. When you are in an occur buffer:</p>
<ul>
<li><code>M-n</code> and <code>M-p</code> will move up and down, but
<em>won’t</em> jump the original buffer to the relevant line</li>
<li><code>n</code> and <code>p</code> will do the same, but it
<em>will</em> update the original buffer to show the line</li>
<li><code>M-g M-n</code> and <code>M-g M-p</code> will not only update
the original buffer to show the selected line, but it will make the
original buffer active at that location. A bit hard to explain in words,
but it’s very useful, try it out.</li>
</ul>
<p>The other useful thing about occur is that, while it’s read only by
default, you can make it editable with <code>e</code>. And from here you
can edit <em>the original buffers</em> from in the occur window. Huge.
Get back to read-only mode with <code>C-c C-c</code></p>
<p>You can also create an occur window for multiple buffer with
<code>multi-occur-in-matching-buffers</code>. But I find that a bit
fiddly. What I would really like is a ‘project-occur’ which searches for
all instances of a term in a current project. But Emacs doesn’t have
that built in that I’m aware, though I believe it’s in the common
‘projectile’ external package. I use the ‘ag’ package and silver-surfer
search program to search project-wide for terms, but it’s not ideal.</p>
<h2 id="registers-and-the-mark">Registers and the Mark</h2>
<p>Another way to quickly jump around a buffer is to use registers.
These are short lived ‘bookmarks’, which you can set and return to.
Typically I’ll use these when I want to temporarily jump to another
location from a point I’ll want to return to afterwards. For example,
jumping into a function from the calling location, then back out to the
calling location. Typically I’ll hit <code>v SPC a</code> to set my
current location to the register <code>a</code>. Then jump to the other
place. Then when I’m done, <code>vja</code> will take me back to my
original location. If I want to chain these together, I’ll use the
registers <code>a</code>, <code>s</code> <code>d</code> and
<code>f</code> as a sort of ‘stack’ Often I’ll also want to jump between
two locations repeatedly, so I’ll set them up as <code>a</code> and
<code>s</code>.</p>
<p>An alternative way to get the above behaviour is to the use the
‘mark’ as a very transitory, but automatic, register. When you do most
‘jumps’ in emacs, e.g. using isearch, a temporary register called the
‘mark’ is created in the place you jumped from. Or, you can set it
manually using <code>gg</code>.Then, you can jump to that mark
(resetting it to the place you jumped from in the process) with
<code>C-x C-x</code>. This is a like the <code>a</code> and
<code>s</code> pattern I described above, but with the advantage that
you don’t have to set the register yourself. You can also ‘pop’ the mark
by hitting <code>C-u g</code>. And you can do this repeatedly by hitting
<code>C-u g g g</code>. The downside being that the mark is less
permanent than the registers, so you can accidental set it to something
else, and you’ll find your jumps will take you somewhere you don’t
expect, which is disorienting. For that reason I usually use manual
registers.</p>
<h2 id="find-and-replace">Find and replace</h2>
<p>While you can use occur mode to do find-replace, generally it’s
easier to use <code>sq</code> (query-replace). This is both standard
emacs functionality and works basically the same as other editors
find-replace so I won’t go into how it works.</p>
<p>A variant on that is <code>vpq</code>, which is <em>project</em>
query-replace. It works the same way, but runs through every file in
your project, not just the current buffer.</p>
<h2 id="killing-or-cut-copy-paste">Killing, or Cut Copy Paste</h2>
<p>In the hierarchy of importance of operations in program text editing,
moving around the buffer is top, cut/copy/paste is second, and typing is
third.</p>
<p>We’ve seen that there are lots of options for moving around the
screen using different syntactic units. Moving and ‘killing’ (as emacs
called the operation that is usually called cut) are sort of ‘twinned’:
for each move, there is usually an equivalent kill. And in my setup they
are, where possible, on the same keys, just with a <code>k</code>
prefix.</p>
<p>So <code>kf</code> is kill forward word, <code>kj</code> is kill
forward sexp. A full list is below, but if you just think about how you
move by a certain amount, you can usually get the equivalent kill
function this way.</p>
<p>There are a few special cases for kills though. There is
<code>kf</code> for kill forward word and <code>kj</code> for kill
forward sexp, often what you want to do is kill the whole word/sexp
<em>you are currently in</em>. These are the <code>ki</code> (kill whole
word) and <code>kn</code> (kill whole sexp) commands. Similarly,
<code>ke</code> will kill from your point to the end of the line, but
more often you will want to ‘kill whole line’ <code>kl</code>.</p>
<p>A convenient (though often inefficient) thing to do is kill all the
text in a highlighted region. You can do this is <code>kw</code> kill
region. Or you can <em>copy</em> a region with <code>ks</code> kill
save.</p>
<p>You will often find yourself wanting to kill from your cursor up to a
certain character. Emacs calls this a ‘zap’, and you can do it with
<code>kz</code> zap to character.</p>
<p>Finally, if you find yourself wanting to join the current line with
the line above it, <code>k6</code> will do that.</p>
<p>To paste, just hit <code>y</code> (for yank).</p>
<p>Here is the full list of kill commands.</p>
<ul>
<li><code>kf</code> kill word</li>
<li><code>kb</code> kill back</li>
<li><code>kj</code> kill sexp</li>
<li><code>kn</code> kill inner sexp</li>
<li><code>kh</code> kill sexp back</li>
<li><code>ke</code> kill to end of line</li>
<li><code>kl</code> kill whole line</li>
<li><code>kw</code> kill region</li>
<li><code>ks</code> kill ring save</li>
<li><code>k6</code> join line</li>
<li><code>kr</code> kill rectangle</li>
<li><code>kz</code> zap to character</li>
<li><code>ki</code> kill inner word</li>
</ul>
<h2 id="file-and-window-operations">File and window operations</h2>
<p>When programming you spend a lot of time jumping between files and
buffers within the ‘project’. The project usually being defined as the
root of the source repo.</p>
<p>Most of these operations are mapped with the <code>v</code> leader
key, and in the case of commands that operate on the whole project,
<code>vp</code>. None of them are particularly unusual, so I’ll just
list them:</p>
<h3 id="window-commands">Window commands</h3>
<ul>
<li><code>w</code> delete other windows</li>
<li><code>o</code> other window</li>
<li><code>v1</code> delete other window</li>
<li><code>v2</code> split window below</li>
<li><code>v3</code> split window right</li>
</ul>
<h3 id="file-commands">File commands</h3>
<ul>
<li><code>vf</code> find file</li>
<li><code>vpf</code> project find file</li>
<li><code>vs</code> save file</li>
<li><code>vps</code> save project files</li>
<li><code>vr</code> recent files (requires some custom setup)</li>
<li><code>vd</code> dired</li>
<li><code>vpd</code> project root dired</li>
</ul>
<h3 id="buffer-commands">Buffer commands</h3>
<ul>
<li><code>vk</code> kill buffer</li>
<li><code>vpk</code> project kill buffers</li>
<li><code>vb</code> switch buffer</li>
<li><code>vpb</code> project switch to buffer</li>
</ul>
<h2 id="other-useful-things-that-dont-fit-anywhere-else">Other useful
things that don’t fit anywhere else</h2>
<p>Macros are surprisingly usable in Emacs, though they are something of
an art. <code>v[</code> starts defining a macro, <code>v]</code> ends
it. <code>vm</code> applies the macro. You can apply it repeatedly with
<code>vmmmmm...</code></p>
<p>LSPs using Emacs LSP implementation eglot are something of a mixed
blessing in my experience. I usually keep it turned off. But sometimes
being able to use ‘xref-find-definition’ (<code>M-.</code>) and the
improved tab completion is too useful to ignore.</p>
<p>‘comment-line’ <code>;</code> I use all the time. If you have a
region highlighted, it will comment out the region.</p>
<p><code>/</code> for ‘undo’, <code>v\</code> for whitespace cleanup.
<code>q</code> for ‘fill or reindent’ will usually tidy the formatting
of whichever block you’re in. <code>x</code> is ‘execute command’.
<code>z</code> is repeat.</p>
<p>Rectangle editing is often useful. Highlight the region you want to
edit, and then <code>kr</code> to kill it, or <code>vt</code> to replace
the rectangle with the thing you type. I find this works for most cases
I would use multi-cursor in other editors.</p>
<p><code>vv</code> opens the VC interface (magit, in my case).</p>
<p>I tend to use <code>sh</code> to highlight a phrase in a certain
colour when I want something I’m currently working on to show up
clearly.</p>
<p><code>vi</code> for imenu, and <code>vI</code> for imenu-to-buffer
are reasonable ways to browse your code by ‘section’, provided the
major-mode implements it properly.</p>
<p>I disable a bunch of commands I sometimes hit accidentally with
unpleasant consequences, most annoying the two ‘suspend’ shortcuts
<code>C-z</code> and <code>C-x C-z</code>.</p>
<h2 id="non-editing-configuration">Non-editing Configuration</h2>
<p>I have some other stuff in my configuration apart from the above
keybindings. But most of it is either very common (fixing where
temporary files are saved), or very specific to how I like to do things
and not good general advice. For example I turn off transient mark mode,
but I wouldn’t recommend it generally.</p>
<p>Tab completion can be a pain to get it how you like it. I use this,
but it’s not perfect:</p>
<pre><code>(setq-default indent-tabs-mode t)
(setq-default tab-width 4)
(setq tab-always-indent &#39;complete)
(setq tab-first-completion &#39;word)</code></pre>
<p>I <em>would</em> recommend relying on as few external packages as
possible. I use, and would recommend, these ones:</p>
<ul>
<li><code>ag</code> an interface to the silver-surfer search program.
This is a way to search for a term across a whole project. grep is a
reasonable alternative, but I prefer the silver surfer. Use it with
<code>sa</code></li>
<li><code>diff-hl</code>: A utility for highlighting lines that have
changed since your last commit.</li>
<li><code>magit</code>: makes using git bearable (or possible, for
things like rebasing)</li>
<li><code>visible-mark</code>: indicate visually where the ‘mark’
is.</li>
</ul>
<p>And a couple of other, language specific ones.</p>
<h2 id="why-not-vim">Why not vim?</h2>
<p>No reason other than I’m used to emacs. There’s nothing here you
couldn’t equally do with vim.</p>
<h2 id="my-init.el">My init.el</h2>
<p>Is here: <a href="https://github.com/RedPenguin101/dotfiles/blob/main/init.el">https://github.com/RedPenguin101/dotfiles/blob/main/init.el</a></p>


</div>
  </body>
</html>
