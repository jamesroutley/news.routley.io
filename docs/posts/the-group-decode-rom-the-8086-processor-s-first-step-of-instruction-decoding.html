<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://www.righto.com/2023/05/8086-processor-group-decode-rom.html">Original</a>
    <h1>The Group Decode ROM: The 8086 processor&#39;s first step of instruction decoding</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-7453359098571162761" itemprop="description articleBody">



<p>A key component of any processor is instruction decoding: analyzing a numeric opcode and figuring out
what actions need to be taken.
The Intel 8086 processor (1978) has a complex instruction set, making instruction decoding a challenge.
The first step in decoding an 8086 instruction is something called the Group Decode ROM, which categorizes
instructions into about 35 types that control how the instruction is decoded and executed.
For instance, the Group Decode ROM determines if an instruction is executed in hardware or in microcode.
It also indicates how the instruction is structured: if the instruction has a bit specifying a byte or word operation,
if the instruction has a byte that specifies the addressing mode, and so forth.</p>
<p><a href="https://static.righto.com/images/8086-group/die-labeled.jpg"><img alt="The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip with the metal and polysilicon removed, revealing the silicon underneath. Click on this image (or any other) for a larger version." height="633" src="https://static.righto.com/images/8086-group/die-labeled-w600.jpg" title="The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip with the metal and polysilicon removed, revealing the silicon underneath. Click on this image (or any other) for a larger version." width="600"/></a></p><p>The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip with the metal and polysilicon removed, revealing the silicon underneath. Click on this image (or any other) for a larger version.</p>
<p>The diagram above shows the position of the Group Decode ROM on the silicon die, as well as other key functional blocks.
The 8086 chip is partitioned into a Bus Interface Unit that communicates with external components such as memory,
and the Execution Unit that executes instructions.
Machine instructions are fetched from memory by the Bus Interface Unit and stored in the prefetch queue registers,
which hold 6 bytes of instructions.
To execute an instruction, the queue bus transfers an instruction byte from the prefetch queue to the instruction register, under control of a state machine called the Loader.
Next, the Group Decode ROM categorizes the instruction according to its structure.
In most cases, the machine instruction is implemented in low-level microcode. The instruction byte is transferred
to the Microcode Address Register, where the Microcode Address Decoder selects the appropriate microcode routine
that implements the instruction.
The microcode provides the micro-instructions that control the Arithmetic/Logic Unit (ALU), registers, and other
components to execute the instruction.</p>
<p>In this blog post, I will focus on a small part of this process: how the Group Decode ROM decodes instructions.
Be warned that this post gets down into the weeds, so you might want to start with one of my higher-level
posts, such as <a href="https://www.righto.com/2022/11/how-8086-processors-microcode-engine.html">how the 8086&#39;s microcode engine works</a>.</p>
<!--
According to patent [4449184](https://patents.google.com/patent/US4449184A),
"A group decode ROM has its
inputs coupled to the instruction register. The group
decode ROM generates a plurality of group decode
signals which are indicative of the genera of the single
byte and multiple byte instructions being received and
decoded by the lower control means."
-->

<h2>Microcode</h2>
<p>Most instructions in the 8086 are implemented in microcode.
Most people think of machine instructions as the basic steps that a computer performs.
However, many processors have another layer of software underneath: microcode.
With microcode, instead of building the CPU&#39;s control circuitry from complex logic gates, the control logic is largely replaced with code.
To execute a machine instruction, the computer internally executes several simpler micro-instructions, specified by the microcode.</p>
<p>Microcode is only used if the Group Decode ROM indicates that the instruction is implemented in microcode.
In that case, the microcode address register is loaded with the instruction and the address decoder selects
the appropriate microcode routine.
However, there&#39;s a complication. If the second byte of the instruction is a Mod R/M byte, the Group Decode ROM
indicates this and causes a memory addressing micro-subroutine to be called.</p>
<p>Some simple instructions are implemented entirely in hardware and don&#39;t use microcode.
These are known as 1-byte logic instructions (1BL) and are also indicated by the Group Decode ROM.</p>
<h2>The Group Decode ROM&#39;s structure</h2>
<p>The Group Decode ROM takes an 8-bit instruction as input, along with an interrupt signal.
It produces 15 outputs that control how the instruction is handled.
In this section I&#39;ll discuss the physical implementation of the Group Decode ROM; the various outputs
are discussed in a later section.</p>
<p>Although the Group Decode ROM is called a ROM, its implementation is really a PLA (Programmable Logic Array),
two levels of highly-structured logic gates.<span id="fnref:rom"><a href="#fn:rom">1</a></span>
The idea of a PLA is to create two levels of NOR gates, each in a grid.
This structure has the advantages that it implements the logic densely and is easy to modify.
Although physically two levels of NOR gates, a PLA can be thought of as an <code>AND</code> layer followed by an <code>OR</code> layer.
The <code>AND</code> layer matches particular bit patterns and then the <code>OR</code> layer combines multiple values from the first
layer to produce arbitrary outputs.</p>
<p><a href="https://static.righto.com/images/8086-group/rom-labeled.jpg"><img alt="The Group Decode ROM. This photo shows the metal layer on top of the die." height="443" src="https://static.righto.com/images/8086-group/rom-labeled-w600.jpg" title="The Group Decode ROM. This photo shows the metal layer on top of the die." width="600"/></a></p><p>The Group Decode ROM. This photo shows the metal layer on top of the die.</p>
<p>Since the output values are highly structured, a PLA implementation is considerably more efficient than a ROM, since in a sense
it combines multiple entries.
In the case of the Group Decode ROM, using a ROM structure would require 256 columns (one for each 8-bit instruction pattern),
while the PLA implementation requires just 36 columns, about 1/7 the size.</p>
<p>The diagram below shows how one column of the Group Decode ROM is wired in the &#34;AND&#34; plane.
In this die photo, I removed the metal layer with acid to reveal the polysilicon and silicon underneath.
The vertical lines show where the metal line for ground and the column output had been.
The basic idea is that each column implements a NOR gate, with a subset of the input lines selected as inputs to the
gate.
The pull-up resistor at the top pulls the column line high by default. But if any of the selected inputs are high,
the corresponding transistor turns on, connecting the column line to ground and pulling it low.
Thus, this implements a NOR gate.
However, it is more useful to think of it as an AND of the complemented inputs (via <a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws">De Morgan&#39;s Law</a>):
if all the inputs are &#34;correct&#34;, the output is high.
In this way, each column matches a particular bit pattern.</p>
<p><a href="https://static.righto.com/images/8086-group/column-labeled.jpg"><img alt="Closeup of a column in the Group Decode ROM." height="575" src="https://static.righto.com/images/8086-group/column-labeled-w280.jpg" title="Closeup of a column in the Group Decode ROM." width="280"/></a></p><p>Closeup of a column in the Group Decode ROM.</p>
<p>The structure of the ROM is implemented through the silicon doping pattern, which is visible above.
A transistor is formed where a polysilicon wire crosses a doped silicon region: the polysilicon forms the gate, turning the transistor on or off.
At each intersection point, a transistor can be created or not, depending on the doping pattern.
If a particular transistor is created, then the corresponding input must be 0 to produce a high output.</p>
<p>At the top of the diagram above, the column outputs are switched from the metal layer to polysilicon wires and become the inputs to the upper &#34;OR&#34;
plane.
This plane is implemented in a similar fashion as a grid of NOR gates.
The plane is rotated 90 degrees, with the inputs vertical and each row forming an output.</p>
<h2>Intermediate decoding in the Group Decode ROM</h2>
<p>The first plane of the Group Decode ROM categorizes instructions into 36 types based on the instruction bit pattern.<span id="fnref:36"><a href="#fn:36">2</a></span>
The table below shows the 256 instruction values, colored according to their categorization.<span id="fnref:octal"><a href="#fn:octal">3</a></span>
For instance, the first blue block consists of the 32 ALU instructions
corresponding to the bit pattern <code>00XXX0XX</code>, where <code>X</code> indicates that the bit can be 0 or 1.
These instructions are all decoded and executed in a similar way.
Almost all instructions have a single category, that is, they activate a single column line in the Group Decode ROM. However, a few instructions activate two lines and have two colors below.</p>
<p><a href="https://static.righto.com/images/8086-group/grid.png"><img alt="Grid of 8086 instructions, colored according to the first level of the Group Decode Rom." height="600" src="https://static.righto.com/images/8086-group/grid-w600.png" title="Grid of 8086 instructions, colored according to the first level of the Group Decode Rom." width="600"/></a></p><p>Grid of 8086 instructions, colored according to the first level of the Group Decode Rom.</p>
<p>Note that the instructions do not have arbitrary numeric opcodes, but are assigned in a way that makes decoding simpler.
Because these blocks correspond to bit patterns, there is little flexibility. 
One of the challenges of instruction set design for early microprocessors was to assign numeric values to the opcodes
in a way that made decoding straightforward.
It&#39;s a bit like a jigsaw puzzle, fitting the instructions into the 256 available values, while making them easy to decode. </p>
<h2>Outputs from the Group Decode ROM</h2>
<p>The Group Decode ROM has 15 outputs, one for each row of the upper half.
In this section, I&#39;ll briefly discuss these outputs and their roles in the 8086.
For an interactive exploration of these signals, see <a href="https://righto.com/8086/groupRom.html">this page</a>,
which shows the outputs that are triggered by each instruction.</p>
<p>Out 0 indicates an <code>IN</code> or <code>OUT</code> instruction.
This signal controls the M/IO (S2) status line, which distinguishes between a memory read/write and an I/O read/write.
Apart from this, memory and I/O accesses are basically the same.</p>
<p>Out 1 indicates (inverted) that the instruction has a Mod R/M byte and performs a read/modify/write on its argument. This signal is used by the Translation ROM when dispatching
an address handler (<a href="https://www.righto.com/2023/02/8086-modrm-addressing.html">details</a>).
(This signal distinguishes between, say, <code>ADD [AX],BX</code> and <code>MOV [AX],BX</code>.
The former both reads and writes <code>[AX]</code>, while the latter only writes to it.)</p>
<p>Out 2 indicates a &#34;group 3/4/5&#34; opcode, an instruction where the second byte specifies the particular instruction,
and thus decoding needs to wait for the second byte.
This controls the loading of the microcode address register.</p>
<p>Out 3 indicates an instruction prefix (segment, <code>LOCK</code>, or <code>REP</code>).
This causes the next byte to be decoded as a new instruction, while blocking interrupt handling.</p>
<p>Out 4 indicates (inverted) a two-byte ROM instruction (2BR), i.e. an instruction is handled by the microcode ROM, but
requires the second byte for decoding.
This is an instruction with a Mod R/M byte.
This signal controls the loader indicating that it needs to fetch the second byte.
This signal is almost the same as output 1 with a few differences.</p>
<p>Out 5 specifies the top bit for an ALU operation. The 8086 uses a 5-bit field to specify an ALU operation.
If not specified explicitly by the microcode, the field uses bits 5 through 3 of the opcode.
(These bits distinguish, say, an <code>ADD</code> instruction from <code>AND</code> or <code>SUB</code>.)
This control line sets the top bit of the ALU field for instructions such as <code>DAA</code>, <code>DAS</code>, <code>AAA</code>, <code>AAS</code>, <code>INC</code>, and <code>DE</code> that fall into a different set from the &#34;regular&#34; ALU instructions.</p>
<p>Out 6 indicates an instruction that sets or clears a condition code directly: <code>CLC</code>, <code>STC</code>, <code>CLI</code>, <code>STI</code>, <code>CLD</code>, or <code>STD</code> (but not <code>CMC</code>). This signal is used by the flag circuitry to update the condition code.</p>
<p>Out 7 indicates an instruction that uses the <code>AL</code> or <code>AX</code> register, depending on the instruction&#39;s size bit.
(For instance <code>MOVSB</code> vs <code>MOVSW</code>.)
This signal is used by the register selection circuitry, the <code>M</code> register specifically.</p>
<p>Out 8 indicates a <code>MOV</code> instruction that uses a segment register.
This signal is used by the register selection circuitry, the <code>N</code> register specifically.</p>
<p>Out 9 indicates the instruction has a <code>d</code> bit, where bit 1 of the instruction swaps the source and destination.
This signal is used by the register selection circuitry, swapping the roles of the <code>M</code> and <code>N</code> registers according to the <code>d</code> bit.</p>
<p>Out 10 indicates a one-byte logic (1BL) instruction, a one-byte instruction that is implemented in logic, not microcode. These instructions are the prefixes, <code>HLT</code>, and the condition-code instructions.
This signal controls the loader, causing it to move to the next instruction.</p>
<p>Out 11 indicates instructions where bit 0 is the byte/word indicator. This signal controls the register handling
and the ALU functionality.</p>
<p>Out 12 indicates an instruction that operates only on a byte: <code>DAA</code>, <code>DAS</code>, <code>AAA</code>, <code>AAS</code>, <code>AAM</code>, <code>AAD</code>, and <code>XLAT</code>.
This signal operates in conjunction with the previous output to select a byte versus word.</p>
<p>Out 13 forces the instruction to use a byte argument if instruction bit 1 is set, overriding the regular byte/word pattern. Specifically, it forces the <code>L8</code> (length 8 bits) condition
for the <code>JMP</code> direct-within-segment and the ALU instructions that are immediate with sign extension (<a href="https://www.righto.com/2023/02/how-8086-processor-determines-length-of.html">details</a>).</p>
<p>Out 14 allows a carry update. This prevents the carry from being updated by the <code>INC</code> and <code>DEC</code> operations.
This signal is used by the flag circuitry.</p>
<h3>Columns</h3>
<p>Most of the Group Decode ROM&#39;s column signals are used to derive the outputs listed above.
However, some column outputs are also used as control signals directly. These are listed below.</p>
<p>Column 10 indicates an immediate <code>MOV</code> instruction. These instructions use instruction bit 3 (rather than bit 1) to select byte versus word, because the three low bits specify the register.
This signal affects the <code>L8</code> condition described earlier and also causes the <code>M</code> register selection to be converted from a word register to a byte register if necessary.</p>
<p>Column 12 indicates an instruction with bits 5-3 specifying the ALU instruction.
This signal causes the <code>X</code> register to be loaded with
the bits in the instruction that specify the ALU operation. (To be precise, this signal prevents the <code>X</code> register
from being reloaded from the second instruction byte.)</p>
<p>Column 13 indicates the <code>CMC</code> (Complement Carry) instruction. This signal is used by the flags circuitry to complement the carry flag (<a href="https://www.righto.com/2023/02/silicon-reverse-engineering-intel-8086.html">details</a>).</p>
<p>Column 14 indicates the <code>HLT</code> (Halt) instruction. This signal stops instruction processing by blocking the instruction queue.</p>
<p>Column 31 indicates a <code>REP</code> prefix. This signal causes the REPZ/NZ latch to be loaded with instruction bit 0 to
indicate if the prefix is <code>REPNZ</code> or <code>REPZ</code>. It also sets the <code>REP</code> latch.</p>
<p>Column 32 indicates a segment prefix. This signal loads the segment latches with the desired segment type.</p>
<p>Column 33 indicates a <code>LOCK</code> prefix. It sets the <code>LOCK</code> latch, locking the bus.</p>
<p>Column 34 indicates a <code>CLI</code> instruction. This signal immediately blocks interrupt handling to avoid an interrupt between the <code>CLI</code> instruction and when the interrupt flag bit is cleared.</p>
<h2>Timing</h2>
<p>One important aspect of the Group Decode ROM is that its outputs are not instantaneous.
It takes a clock cycle to get the outputs from the Group Decode ROM.
In particular, when instruction decoding starts, the timing signal <code>FC</code> (First Clock) is activated to indicate the first clock
cycle. However, the Group Decode ROM&#39;s outputs are not available until the Second Clock <code>SC</code>.</p>
<p>One consequence of this is that even the simplest instruction (such as a flag operation) takes two clock cycles, as does a prefix.
The problem is that even though the instruction could be performed in one clock cycle, it takes two clock cycles
for the Group Decode ROM to determine that the instruction only needs one cycle.
This illustrates how a complex instruction format impacts performance.</p>
<p>The <code>FC</code> and <code>SC</code> timing signals are generated by a state machine called the Loader.
These signals may seem trivial, but there are a few complications.
First, the prefetch queue may run empty, in which case the <code>FC</code> and/or <code>SC</code> signal is delayed until the prefetch queue has a byte available.
Second, to increase performance, the 8086 can start decoding an instruction during the last clock cycle of the previous instruction.
Thus, if the microcode indicates that there is one cycle left, the Loader can proceed with the next instruction.
Likewise, for a one-byte instruction implemented in hardware (one-byte logic or 1BL), the loader proceeds
as soon as possible.</p>
<p>The diagram below shows the timing of an <code>ADD</code> instruction. Each line is half of a clock cycle.
Execution is pipelined: the instruction is fetched during the first clock cycle (First Clock).
During Second Clock, the Group Decode ROM produces its output. The microcode address register also generates
the micro-address for the instruction&#39;s microcode.
The microcode ROM supplies a micro-instruction during the third clock cycle and execution of the micro-instruction
takes place during the fourth clock cycle.</p>
<p><a href="https://static.righto.com/images/8086-group/diagram-labeled.jpg"><img alt="This diagram shows the execution of an ADD instruction and what is happening in various parts of the 8086. The arrows show the flow from step to step. The character µ is short for &#34;micro&#34;." height="395" src="https://static.righto.com/images/8086-group/diagram-labeled-w750.jpg" title="This diagram shows the execution of an ADD instruction and what is happening in various parts of the 8086. The arrows show the flow from step to step. The character µ is short for &#34;micro&#34;." width="750"/></a></p><p>This diagram shows the execution of an ADD instruction and what is happening in various parts of the 8086. The arrows show the flow from step to step. The character µ is short for &#34;micro&#34;.</p>
<p>The Group Decode ROM&#39;s outputs during Second Clock control the decoding.
Most importantly, the <code>ADD imm</code> instruction used microcode; it is not a one-byte logic instruction (<code>1BL</code>).
Moreover, it does not have a Mod R/M byte, so it does not need two bytes for decoding (<code>2BR</code>).
For a <code>1BL</code> instruction, microcode execution would be blocked and the next instruction would be immediately fetched.
On the other hand, for a <code>2BR</code> instruction, the loader would tell the prefetch queue that it was done with the
second byte during the second half of Second Clock.
Microcode execution would be blocked during the third cycle and the fourth cycle would execute a microcode
subroutine to determine the memory address.</p>
<p>For more details, see my article on the <a href="https://www.righto.com/2023/01/the-8086-processors-microcode-pipeline.html">8086 pipeline</a>.</p>
<h2>Interrupts</h2>
<p>The Group Decode ROM takes the 8 bits of the instruction as inputs, but it has an additional input indicating that
an interrupt is being handled.
This signal blocks most of the Group Decode ROM outputs.
This prevents the current instruction&#39;s outputs from interfering with interrupt handling.
I wrote about the 8086&#39;s interrupt handling in detail <a href="https://www.righto.com/2023/02/8086-interrupt.html">here</a>, so I won&#39;t go into more detail in this post.</p>
<h2>Conclusions</h2>
<p>The Group Decode ROM indicates one of the key differences between CISC processors (Complex Instruction Set Computer) such as the 8086 and the RISC processors (Reduced Instruction Set Computer) that became popular a few years later.
A RISC instruction set is designed to make instruction decoding very easy, with a small number of uniform instruction forms.
On the other hand, the 8086&#39;s CISC instruction set was designed for compactness and high code density.
As a result, instructions are squeezed into the available opcode space.
Although there is a lot of structure to the 8086 opcodes, this structure is full of special cases and any patterns only apply to a subset of the instructions.
The Group Decode ROM brings some order to this chaotic jumble of instructions, and the number of outputs
from the Group Decode ROM is a measure of the instruction set&#39;s complexity.</p>
<p>The 8086&#39;s instruction set was extended over the decades to become the x86 instruction set in use today.
During that time, more layers of complexity were added to the instruction set.
Now, an x86 instruction can be up to 15 bytes long with multiple prefixes.
Some prefixes change the register encoding or indicate a completely different instruction set such as <code>VEX</code> (Vector Extensions) or <code>SSE</code> (Streaming SIMD Extensions).
Thus, x86 instruction decoding is very difficult, especially when trying to decode multiple instructions in parallel.
This has an impact in modern systems, where x86 processors typically have 4 complex instruction decoders while Apple&#39;s ARM processors have 8 simpler decoders; this is <a href="https://debugger.medium.com/why-is-apples-m1-chip-so-fast-3262b158cba2">said</a> to give Apple a performance benefit.
Thus, architectural decisions from 45 years ago are still impacting the performance of modern processors.</p>
<p>I&#39;ve written numerous <a href="https://www.righto.com/search/label/8086">posts on the 8086</a> so far and
plan to continue reverse-engineering the 8086 die so
follow me on Twitter <a href="https://twitter.com/kenshirriff">@kenshirriff</a> or <a href="http://www.righto.com/feeds/posts/default">RSS</a> for updates.
I&#39;ve also started experimenting with Mastodon recently as <a href="https://oldbytes.space/@kenshirriff">@<span data-cfemail="f8939d968b90918a8a919e9eb897949c9a818c9d8bd68b88999b9d">[email protected]</span></a>.
Thanks to Arjan Holscher for suggesting this topic.</p>
<h2>Notes and references</h2>


</div></div>
  </body>
</html>
