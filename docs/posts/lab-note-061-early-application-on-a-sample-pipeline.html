<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://interjectedfuture.com/lab-note-061-early-application-on-a-sample-pipeline/">Original</a>
    <h1>Lab note #061 Early application on a sample pipeline</h1>
    
    <div id="readability-page-1" class="page"><div>

    <article>

        <header>

                <a href="https://interjectedfuture.com/tag/lab-notes/">lab notes</a>
            

            <div>
                <p><a href="https://chicory.dev/author/wil/">
                                <img src="https://www.gravatar.com/avatar/915aac3dfde2fb502ce415d77643a72d?s=250&amp;r=x&amp;d=mp" alt="Wil Chung"/>
                            </a>
                </p>
                <div>
                    
                    <p><time datetime="2025-02-24">24 Feb 2025</time>
                            <span><span>â€”</span> 3 min read</span>
                    </p>
                </div>
            </div>

                <figure>
        <img srcset="/content/images/size/w320/2025/02/DALL-E-2025-02-24-00.04.09---An-illustrative-16_9-image-representing--Early-application-on-a-sample-pipeline--using-distinct--concrete-items.-The-image-features-a-whimsical-but-st.jpeg 320w,
                    /content/images/size/w600/2025/02/DALL-E-2025-02-24-00.04.09---An-illustrative-16_9-image-representing--Early-application-on-a-sample-pipeline--using-distinct--concrete-items.-The-image-features-a-whimsical-but-st.jpeg 600w,
                    /content/images/size/w960/2025/02/DALL-E-2025-02-24-00.04.09---An-illustrative-16_9-image-representing--Early-application-on-a-sample-pipeline--using-distinct--concrete-items.-The-image-features-a-whimsical-but-st.jpeg 960w,
                    /content/images/size/w1200/2025/02/DALL-E-2025-02-24-00.04.09---An-illustrative-16_9-image-representing--Early-application-on-a-sample-pipeline--using-distinct--concrete-items.-The-image-features-a-whimsical-but-st.jpeg 1200w,
                    /content/images/size/w2000/2025/02/DALL-E-2025-02-24-00.04.09---An-illustrative-16_9-image-representing--Early-application-on-a-sample-pipeline--using-distinct--concrete-items.-The-image-features-a-whimsical-but-st.jpeg 2000w" sizes="(max-width: 1200px) 100vw, 1120px" src="https://chicory.dev/content/images/size/w1200/2025/02/DALL-E-2025-02-24-00.04.09---An-illustrative-16_9-image-representing--Early-application-on-a-sample-pipeline--using-distinct--concrete-items.-The-image-features-a-whimsical-but-st.jpeg" alt="Lab note #061 Early application on a sample pipeline"/>
    </figure>

        </header>

        <section>
            <p>I started implementing a RAG pipeline for a simple RAG app to look up questions about Zig. Armed with just a basic reactive graph and a simple effect system, I wanted to know where the leaks were. </p><p>The good news is that it feels pretty good to have a reactive pipeline. Update dates, and the rest of the pipeline pertaining to the output I&#39;m querying just updates. However, there are some quality of life problems that I found:</p><ol><li>Nesting of raising effects in functions. <code>yield</code> vs <code>yield from</code>?</li><li>Nesting of handlers (solved)</li><li>Effect handlers with API clients is a hassle.</li><li>Triggering the pipeline to run again is a little odd.</li><li>When extracting, I want push, not just pull.</li><li>External effects backed by versions of previous runs is exactly what I want for the extract stage. I shouldn&#39;t have to implement it manually.</li><li>How to handle async effects?</li></ol><p>Of these, I only solved one, but the most glaring problem was the affordance that stems from #3. In the allowance for an Ability to group effects in an algebra, there&#39;s a lot of boilerplate involved. </p><p>First, we need a data representation of the effect both to type check the effectful generators and to hold a description of the effect for execution later.</p><pre><code>@dataclass
class Fetch(Effect):
    url: str
    mime_type: mime.MimeType</code></pre><p>Then we need the ability, to type check the handlers against a protocol.</p><pre><code>class RequestAbility(Ability, Protocol):    
    def fetch(self, effect: Fetch) -&gt; Result[Any, FetchException]: ...</code></pre><p>Then an implementation of the handler, which needs the ability type to fetch methods of handler dynamically.</p><pre><code>class RequestHandler(Handler):
    __ability__ = cast(Type[RequestAbility], RequestAbility)
    
    def fetch(self, effect: Fetch) -&gt; Result[Any, FetchException]:
        # An implementating of fetching from  url
        ...</code></pre><p>And lastly a type check that connects handlers and its ability before pass it into a <code>use_handler</code>.</p><pre><code>def as_request_ability(handler: RequestAbility) -&gt; RequestHandler:
    return cast(RequestHandler, handler)</code></pre><p>That&#39;s just too much. This is fine if effect handlers aren&#39;t often being written. This can be the case with effects libraries where library devs figured out the most common effects (fetch, get, put, query, etc) and how to compose them. But in the case of using a pre-made client library in a handler, it&#39;s completely impractical. So I&#39;ll have to go back and rework this part of it, so that it&#39;s far less boilerplate, but still retain some basic type checking. Without type checking, effects are rather impractical, I think. It&#39;s like having exceptions where you have no idea what kind of exceptions a method will possibly throw. </p><p>I don&#39;t like the idea of checked exceptions, but I&#39;ll cross the bridge later. I&#39;ve seen accumulated types, which seem nice for this.</p><p>Also, I spent a bunch of time wrestling with VSCode configuration for a monorepo. This is the kind of thing LLMs should be great at helping with, except o3-mini is just a bit confused as to what my current directory structure is, what path matches up to what directory layout. It would tell me solutions mixed up for different scenarios, and it would go back and forth between bad solutions. It ended up being a bunch trial and error to figure out.</p><p>I&#39;ve managed to fall into these kinds of weird holes, and I&#39;ve found the way out isn&#39;t to expect the LLM to just give you the whole answer. I have to ask it how the thing works, and do the last mile myself. </p><blockquote>Honestly, I like coding, but I hate configuration. The boon for me about AI is when it helps me with arcane configuration. IDE settings. Getting debuggers to work. Whatever transpiler flag. That&#39;s what I really want AI to help me with.</blockquote><p>Maybe it&#39;ll be better by next year.</p>
        </section>

    </article>


</div></div>
  </body>
</html>
