<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://boyter.org/posts/cost-of-integer-cast-in-go/">Original</a>
    <h1>Cost of a Integer Cast in Go</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Recently have been doing interviews at work for Go developers.</p>
<p>The filter for this is a simple review exercise. We present a small chunk of code and ask them to review it over 15 minutes pointing out any issues they see. The idea is to respect their and our time. It works pretty well and we can determine how much experience someone has by their ability to pick up the obvious vs subtle bugs.</p>
<p>One recent result came back with the following,</p>
<blockquote>
<p>Using an int32 forces the cast from int which is inefficient</p>
</blockquote>
<p>Which was interesting feedback. I don’t believe that to be the case. You lose data due to overflows which is what we expect but, I am fairly sure that the actual conversion is a single CPU operation and stupidly fast…</p>
<p>Of course, belief and hope are not a plan. So I thought I would actually test it.</p>
<blockquote>
<p>To save you scrolling down, the answer is for a integer to integer cast it’s as close to “free” as any other CPU operation. Intger to float is about 3x slower, but again for most things you can consider it free.</p>
</blockquote>
<p>I started by checking what the overhead of a bitwise &amp; operation is. Since this is almost free from a CPU point of view, taking a single operation.</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>BenchmarkBitwiseAnd</span>(<span>b</span> <span>*</span><span>testing</span>.<span>B</span>) {
</span></span><span><span>	<span>var</span> <span>x</span> <span>int</span>
</span></span><span><span>	<span>for</span> <span>i</span> <span>:=</span> <span>0</span>; <span>i</span> &lt; <span>b</span>.<span>N</span>; <span>i</span><span>++</span> {
</span></span><span><span>		<span>x</span> <span>+=</span> <span>i</span> <span>&amp;</span> <span>7</span>
</span></span><span><span>	}
</span></span><span><span>	<span>b</span>.<span>StopTimer</span>() 
</span></span><span><span>	<span>fmt</span>.<span>Println</span>(<span>x</span>)
</span></span><span><span>}</span></span></code></pre></div>
<p>We keep the result of the <code>i &amp; i</code> to ensure the compiler is not optimising anything away.</p>
<p>Running on a 2020 M1 Macbook Air produced the following.</p>
<pre tabindex="0"><code>BenchmarkBitwiseAnd-8   	1000000000	         0.5148 ns/op
</code></pre><p>So about 0.5 ns for each operation. Which given the clock speed of the CPU means we are observing a single operation. With this as the baseline lets try the int to int32 cast.</p>
<div><pre tabindex="0"><code data-lang="go"><span><span>	
</span></span><span><span><span>func</span> <span>BenchmarkIntToInt32</span>(<span>b</span> <span>*</span><span>testing</span>.<span>B</span>) {
</span></span><span><span>	<span>var</span> <span>x</span> <span>int32</span>
</span></span><span><span>	<span>for</span> <span>i</span> <span>:=</span> <span>0</span>; <span>i</span> &lt; <span>b</span>.<span>N</span>; <span>i</span><span>++</span> {
</span></span><span><span>		<span>x</span> <span>+=</span> int32(<span>i</span>)
</span></span><span><span>	}
</span></span><span><span>	<span>b</span>.<span>StopTimer</span>() 
</span></span><span><span>	<span>fmt</span>.<span>Println</span>(<span>x</span>)
</span></span><span><span>}</span></span></code></pre></div>
<pre tabindex="0"><code>BenchmarkIntToInt32-8   	1000000000	         0.5150 ns/op
</code></pre><p>Interesting. Almost the same as &amp; meaning from a code point of view this is a free operation. What about casts to other integer types?</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>BenchmarkIntToInt64</span>(<span>b</span> <span>*</span><span>testing</span>.<span>B</span>) {
</span></span><span><span>	<span>var</span> <span>x</span> <span>int64</span>
</span></span><span><span>	<span>for</span> <span>i</span> <span>:=</span> <span>0</span>; <span>i</span> &lt; <span>b</span>.<span>N</span>; <span>i</span><span>++</span> {
</span></span><span><span>		<span>x</span> <span>+=</span> int64(<span>i</span>)
</span></span><span><span>	}
</span></span><span><span>	<span>b</span>.<span>StopTimer</span>() 
</span></span><span><span>	<span>fmt</span>.<span>Println</span>(<span>x</span>)
</span></span><span><span>}</span></span></code></pre></div>
<pre tabindex="0"><code>BenchmarkIntToInt64-8   	1000000000	         0.5147 ns/op
</code></pre><p>I would expect the above to be just as fast as I am on a 64 bit machine and I suspect it compiles down to not even use the cast.</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>BenchmarkIntToInt16</span>(<span>b</span> <span>*</span><span>testing</span>.<span>B</span>) {
</span></span><span><span>	<span>var</span> <span>x</span> <span>int16</span>
</span></span><span><span>	<span>for</span> <span>i</span> <span>:=</span> <span>0</span>; <span>i</span> &lt; <span>b</span>.<span>N</span>; <span>i</span><span>++</span> {
</span></span><span><span>		<span>x</span> <span>+=</span> int16(<span>i</span>)
</span></span><span><span>	}
</span></span><span><span>	<span>b</span>.<span>StopTimer</span>() 
</span></span><span><span>	<span>fmt</span>.<span>Println</span>(<span>x</span>)
</span></span><span><span>}</span></span></code></pre></div>
<pre tabindex="0"><code>BenchmarkIntToInt16-8   	1000000000	         0.5143 ns/op
</code></pre><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>BenchmarkIntToInt8</span>(<span>b</span> <span>*</span><span>testing</span>.<span>B</span>) {
</span></span><span><span>	<span>var</span> <span>x</span> <span>int8</span>
</span></span><span><span>	<span>for</span> <span>i</span> <span>:=</span> <span>0</span>; <span>i</span> &lt; <span>b</span>.<span>N</span>; <span>i</span><span>++</span> {
</span></span><span><span>		<span>x</span> <span>+=</span> int8(<span>i</span>)
</span></span><span><span>	}
</span></span><span><span>	<span>b</span>.<span>StopTimer</span>() 
</span></span><span><span>	<span>fmt</span>.<span>Println</span>(<span>x</span>)
</span></span><span><span>}</span></span></code></pre></div>
<pre tabindex="0"><code>BenchmarkIntToInt8-8   	1000000000	         0.5149 ns/op
</code></pre><p>So, more or less free across the board! Which is as you would expect if you think about how a cast actually works on the CPU. However, what about unsigned ints?</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>BenchmarkIntToUInt32</span>(<span>b</span> <span>*</span><span>testing</span>.<span>B</span>) {
</span></span><span><span>	<span>var</span> <span>x</span> <span>uint32</span>
</span></span><span><span>	<span>for</span> <span>i</span> <span>:=</span> <span>0</span>; <span>i</span> &lt; <span>b</span>.<span>N</span>; <span>i</span><span>++</span> {
</span></span><span><span>		<span>x</span> <span>+=</span> uint32(<span>i</span>)
</span></span><span><span>	}
</span></span><span><span>	<span>b</span>.<span>StopTimer</span>() 
</span></span><span><span>	<span>fmt</span>.<span>Println</span>(<span>x</span>)
</span></span><span><span>}</span></span></code></pre></div>
<pre tabindex="0"><code>BenchmarkIntToUInt32-8   	1000000000	         0.5131 ns/op
</code></pre><p>Same story it seems. I tried the other unsigned types and got the same result. I then thought it worth trying casting to floats, just to get an idea of how much more expensive that is.</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>BenchmarkIntToFloat32</span>(<span>b</span> <span>*</span><span>testing</span>.<span>B</span>) {
</span></span><span><span>	<span>var</span> <span>x</span> <span>float32</span>
</span></span><span><span>	<span>for</span> <span>i</span> <span>:=</span> <span>0</span>; <span>i</span> &lt; <span>b</span>.<span>N</span>; <span>i</span><span>++</span> {
</span></span><span><span>		<span>x</span> <span>+=</span> float32(<span>i</span>)
</span></span><span><span>	}
</span></span><span><span>	<span>b</span>.<span>StopTimer</span>() 
</span></span><span><span>	<span>fmt</span>.<span>Println</span>(<span>x</span>)
</span></span><span><span>}</span></span></code></pre></div>
<pre tabindex="0"><code>BenchmarkIntToFloat32-8   	775237407	         1.540 ns/op
</code></pre><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>BenchmarkIntToFloat64</span>(<span>b</span> <span>*</span><span>testing</span>.<span>B</span>) {
</span></span><span><span>	<span>var</span> <span>x</span> <span>float64</span>
</span></span><span><span>	<span>for</span> <span>i</span> <span>:=</span> <span>0</span>; <span>i</span> &lt; <span>b</span>.<span>N</span>; <span>i</span><span>++</span> {
</span></span><span><span>		<span>x</span> <span>+=</span> float64(<span>i</span>)
</span></span><span><span>	}
</span></span><span><span>	<span>b</span>.<span>StopTimer</span>() 
</span></span><span><span>	<span>fmt</span>.<span>Println</span>(<span>x</span>)
</span></span><span><span>}</span></span></code></pre></div>
<pre tabindex="0"><code>BenchmarkIntToFloat64-8   	778829048	         1.555 ns/op
</code></pre><p>So about 3x the overhead to convert from int to float.</p>
<p>So in short, my inital throught seemed to hold up. What I also like is that I can stop stressing about casts in some of the more critical pieces of code I work on, as they are unlikely to be a bottleneck.</p>

</div></div>
  </body>
</html>
