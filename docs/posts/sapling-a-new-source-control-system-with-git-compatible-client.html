<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://engineering.fb.com/2022/11/15/open-source/sapling-source-control-scalable/">Original</a>
    <h1>Sapling: A new source control system with Git-compatible client</h1>
    
    <div id="readability-page-1" class="page"><div>

		<ul>
<li aria-level="1"><a href="https://www.sapling-scm.com/docs/introduction/getting-started" target="_blank" rel="noopener"><span>Sapling</span></a><span> is a new Git-compatible source control client.</span></li>
<li aria-level="1"><span>Sapling emphasizes usability while also scaling to the largest repositories in the world.</span></li>
<li aria-level="1"><span><a href="https://www.sapling-scm.com/docs/addons/reviewstack/" target="_blank" rel="noopener">ReviewStack</a> is a demonstration code review UI for GitHub pull requests that integrates with Sapling to make reviewing stacks of commits easy.</span></li>
<li aria-level="1"><span>You can </span><a href="https://www.sapling-scm.com/docs/introduction/getting-started" target="_blank" rel="noopener"><span>get started using Sapling</span></a><span> today. </span></li>
</ul>
<p><span>Source control is one of the most important tools for modern developers, and through tools such as Git and GitHub, it has become a foundation for the entire software industry. At Meta, source control is responsible for storing developers’ in-progress code, storing the history of all code, and serving code to developer services such as build and test infrastructure. It is a critical part of our developer experience and our ability to move fast, and we’ve invested heavily to build a world-class source control experience.</span></p>
<p><span>We’ve spent the past 10 years building Sapling, a scalable, user-friendly source control system, and today we’re open-sourcing the </span><a href="https://www.sapling-scm.com" target="_blank" rel="noopener"><span>Sapling client</span></a><span>. You can now try its </span><a href="https://www.sapling-scm.com/docs/overview/intro" target="_blank" rel="noopener"><span>various features</span></a><span> using Sapling’s built-in Git support to clone any of your existing repositories. This is the first step in a longer process of making the entire Sapling system available to the world. </span></p>
<h2><span>What is Sapling?</span></h2>
<p><span>Sapling is a source control system used at Meta that emphasizes usability and scalability. Git and Mercurial users will find that many of the basic concepts are familiar </span><span>— </span><span>and that workflows like understanding your repository, working with stacks of commits, and recovering from mistakes are substantially easier.</span></p>
<p><span>When used with our Sapling-compatible server and virtual file system (we hope to open-source these in the future), Sapling can serve Meta’s internal repository with tens of millions of files, tens of millions of commits, and tens of millions of branches. At Meta, Sapling is primarily used for our large monolithic repository (or monorepo, for short), but the Sapling client also supports cloning and interacting with Git repositories and can be used by individual developers to work with GitHub and other Git hosting services.</span></p>
<h2><span>Why build a new source control system?</span></h2>
<p><span>Sapling began 10 years ago as an initiative to make our monorepo scale in the face of tremendous growth. Public source control systems were not, and still are not, capable of handling repositories of this size. Breaking up the repository was also out of the question, as it would mean losing monorepo’s benefits, such as simplified dependency management and the ability to make broad changes quickly. Instead, we decided to go all in and make our source control system scale.</span></p>
<p><span>Starting as an extension to the Mercurial open source project, it rapidly grew into a system of its own with new storage formats, wire protocols, algorithms, and behaviors. Our ambitions grew along with it, and we began thinking about how we could improve not only the scale but also the actual experience of using source control.</span></p>
<h2><span>Sapling’s user experience</span></h2>
<p><span>Historically, the usability of version control systems has left a lot to be desired; developers are expected to maintain a complex mental picture of the repository, and they are often forced to use esoteric commands to accomplish seemingly simple goals. We aimed to fix that with Sapling.</span></p>
<p><span>A Git user who sits down with Sapling will initially find the basic commands familiar. Users clone a repository, make commits, amend, rebase, and push the commits back to the server. What will stand out, though, is how every command is designed for simplicity and ease of use. Each command does one thing. Local branch names are optional. There is no staging area. The list goes on.</span></p>
<p><span>It’s impossible to cover the entire user experience in a single blog post, so check out our </span><a href="https://www.sapling-scm.com/docs/overview/basic-commands" target="_blank" rel="noopener"><span>user experience documentation</span></a><span> to learn more.</span></p>
<p><img decoding="async" src="https://engineering.fb.com/wp-content/uploads/2022/11/Sapling-image-4.gif?w=701" alt="" width="701" height="264"/></p>
<p><span>Below, we’ll explore three particular areas of the user experience that have been so successful within Meta that we’ve had requests for them outside of Meta as well. </span></p>
<h3><span>Smartlog: Your repo at a glance</span></h3>
<p><span>The smartlog is one of the most important Sapling commands and the centerpiece of the entire user experience. By simply running the Sapling client with no arguments, </span><span>sl</span><span>, you can see all your local commits, where you are, where important remote branches are, what files have changed, and which commits are old and have new versions. Equally important, the smartlog hides all the information you don’t care about. Remote branches you don’t care about are not shown. Thousands of irrelevant commits in main are hidden behind a dashed line. The result is a clear, concise picture of your repository that’s tailored to what matters to you, no matter how large your repo.</span></p>
<p><img decoding="async" loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/11/Sapling-image-2.gif?w=684" alt="" width="684" height="409"/></p>
<p><span>Having this view at your fingertips changes how people approach source control. For new users, it gives them the right mental model from day one. It allows them to visually see the before-and-after effects of the commands they run. Overall, it makes people more confident in using source control. </span></p>
<p><span>We’ve even made an interactive smartlog web UI for people who are more comfortable with graphical interfaces. Simply run </span><span>sl web</span><span> to launch it in your browser. From there you can view your smartlog, commit, amend, checkout, and more.</span></p>
<p><img decoding="async" loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/11/Sapling-image-3.png?w=620" alt="" width="620" height="447" srcset="https://engineering.fb.com/wp-content/uploads/2022/11/Sapling-image-3.png 620w, https://engineering.fb.com/wp-content/uploads/2022/11/Sapling-image-3.png?resize=96,69 96w, https://engineering.fb.com/wp-content/uploads/2022/11/Sapling-image-3.png?resize=192,138 192w" sizes="(max-width: 992px) 100vw, 62vw"/></p>
<h3><span>Fixing mistakes with ease</span></h3>
<p><span>The most frustrating aspect of many version control systems is trying to recover from mistakes. Understanding what you did is hard. Finding your old data is hard. Figuring out what command you should run to get the old data back is hard. The Sapling development team is small, and in order to support our tens of thousands of internal developers, we needed to make it as easy as possible to solve your own issues and get unblocked.</span></p>
<p><span>To this end, Sapling provides a wide array of tools for understanding what you did and undoing it. Commands like </span><span>sl undo</span><span>, </span><span>sl redo</span><span>, </span><span>sl uncommit</span><span>, and </span><span>sl unamend</span><span> allow you to easily undo many operations. Commands like </span><span>sl hide</span><span> and </span><span>sl unhide</span><span> allow you to trivially and safely hide commits and bring them back to life. There is even an </span><span>sl undo -i</span><span> command for Mac and Linux that allows you to interactively scroll through old smartlog views to revert back to a specific point in time or just find the commit hash of an old commit you lost. Never again should you have to delete your repository and clone again to get things working.</span></p>
<p><img decoding="async" loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/11/Sapling-image-1.gif?w=701" alt="" width="701" height="285"/></p>
<p><span>See our </span><a href="https://www.sapling-scm.com/docs/overview/undo"><span>UX doc</span></a><span> for a more extensive overview of our many recovery features.</span></p>
<h3><span>First-class commit stacks</span></h3>
<p><span>At Meta, working with stacks of commits is a common part of our workflow. First, an engineer building a feature will send out the small first step of that feature as a commit for code review. While it’s being reviewed, they will start on the next step as a second commit that will later be sent for code review as well. A full feature will consist of many of these small, incremental, individually reviewed commits on top of one another.</span></p>
<p><span>Working with stacks of commits is particularly difficult in many source control systems. It requires complex stateful commands like </span><span>git rebase -i</span><span> to add a single line to a commit earlier in the stack. Sapling makes this easy by providing explicit commands and workflows for making even the newest engineer able to edit, rearrange, and understand the commits in the stack.</span></p>
<p><span>At its most basic, when you want to edit a commit in a stack, you simply check out that commit, via </span><span>sl goto COMMIT</span><span>, make your change, and amend it via </span><span>sl amend</span><span>. Sapling automatically moves, or rebases, the top of your stack onto the newly amended commit, allowing you to resolve any conflicts immediately. If you choose not to fix the conflicts now, you can continue working on that commit, and later run </span><span>sl restack</span><span> to bring your stack back together once again. Inspired by Mercurial’s Evolve extension, Sapling keeps track of the mutation history of each commit under the hood, allowing it to algorithmically rebuild the stack later, no matter how many times you edit the stack.</span></p>
<p><img decoding="async" loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/11/Sapling-image-5.gif?w=775" alt="" width="775" height="398"/></p>
<p><span>Beyond simply amending and restacking commits, Sapling offers a variety of commands for navigating your stack (</span><span>sl next</span><span>, </span><span>sl prev</span><span>, </span><span>sl goto top/bottom</span><span>), adjusting your stack (</span><span>sl fold</span><span>, </span><span>sl split</span><span>), and even allows automatically pulling uncommitted changes from your working copy down into the appropriate commit in the middle of your stack (</span><span>sl absorb</span><span>, </span><span>sl amend –to COMMIT</span><span>).</span></p>
<h2><span>ReviewStack: Stack-oriented code review</span></h2>
<p><span>Making it easy to work with stacks has many benefits: Commits become smaller, easier to reason about, and easier to review. But effectively reviewing stacks requires a code review tool that is tailored to them. Unfortunately, many external code review tools are optimized for reviewing the entire pull request at once instead of individual commits within the pull request. This makes it hard to have a conversation about individual commits and negates many of the benefits of having a stack of small, incremental, easy-to-understand commits.</span></p>
<p><span>Therefore, we put together a demonstration website that shows just how intuitive and powerful stacked commit review flows could be. Check out our </span><a href="https://reviewstack.dev/bolinfest/monaco-tm/pull/39" target="_blank" rel="noopener"><span>example stacked GitHub pull request</span></a><span>, or try it on your own pull request by visiting</span><a href="https://reviewstack.dev/" target="_blank" rel="noopener"> <span>ReviewStack</span></a><span>. You’ll see how  you can view the conversation and signal pertaining to a specific commit on a single page, and you can easily move between different parts of the stack with the drop down and navigation buttons at the top.</span></p>
<p><img decoding="async" loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/11/reviewstack-demo-loop.gif?w=1024" alt="Sapling" width="1024" height="645"/></p>
<h2><span>Scaling Sapling</span></h2>
<p><i><span>Note: Many of our scale features require using a Sapling-specific server and are therefore unavailable in our initial client release. We describe them here as a preview of things to come. When using Sapling with a Git repository, some of these optimizations will not apply.</span></i></p>
<p><span>Source control has numerous axes of growth, and making it scale requires addressing all of them: number of commits, files, branches, merges, length of file histories, size of files, and more. At its core, though, it breaks down into two parts: the history and the working copy.</span></p>
<h3><span>Scaling history: Segmented Changelog and the art of being lazy</span></h3>
<p><span>For large repositories, the history can be much larger than the size of the working copy you actually use. For instance, three-quarters of the 5.5 GB Linux kernel repo is the history. In Sapling, cloning the repository downloads almost no history. Instead, as you use the repository we download just the commits, trees, and files you actually need, which allows you to work with a repository that may be terabytes in size without having to actually download all of it. Although this requires being online, through efficient caching and indexes, we maintain a configurable ability to work offline in many common flows, like making a commit.</span></p>
<p><span>Beyond just lazily downloading data, we need to be able to efficiently query history. We cannot afford to download millions of commits just to find the common ancestor of two commits or to draw the Smartlog graph. To solve this, we developed the Segmented Changelog, which allows the downloading of the high-level shape of the commit graph from the server, taking just a few megabytes, and lazily filling in individual commit data later as necessary. This enables querying the graph relationship between any two commits in O(number-of-merges) time, with nothing but the segments and the position of the two commits in the segments. The result is that commands like smartlog are less than a second, regardless of how big the repository is.</span></p>
<p><img decoding="async" loading="lazy" src="https://engineering.fb.com/wp-content/uploads/2022/11/Sapling-image-7.png?w=1024" alt="" width="1024" height="426" srcset="https://engineering.fb.com/wp-content/uploads/2022/11/Sapling-image-7.png 1164w, https://engineering.fb.com/wp-content/uploads/2022/11/Sapling-image-7.png?resize=916,381 916w, https://engineering.fb.com/wp-content/uploads/2022/11/Sapling-image-7.png?resize=768,319 768w, https://engineering.fb.com/wp-content/uploads/2022/11/Sapling-image-7.png?resize=1024,426 1024w, https://engineering.fb.com/wp-content/uploads/2022/11/Sapling-image-7.png?resize=96,40 96w, https://engineering.fb.com/wp-content/uploads/2022/11/Sapling-image-7.png?resize=192,80 192w" sizes="(max-width: 992px) 100vw, 62vw"/></p>
<p><span>Segmented Changelog speeds up other algorithms as well. When running </span><span>log</span><span> or </span><span>blame</span><span> on a file, we’re able to bisect the segment graph to find the history in O(log n) time, instead of O(n), even in Git repositories. When used with our Sapling-specific server, we go even further, maintaining per-file history graphs that allow answering </span><span>sl log FILE</span><span> in less than a second, regardless of how old the file is.</span></p>
<h3><span>Scaling the working copy: Virtual or Sparse</span></h3>
<p><span>To scale the working copy, we’ve developed a virtual file system (not yet publicly available) that makes it look and act as if you have the entire repository. Clones and checkouts become very fast, and while accessing a file for the first time requires a network request, subsequent accesses are fast and prefetching mechanisms can warm the cache for your project.</span></p>
<p><span>Even without the virtual file system, we speed up </span><span>sl status</span><span> by utilizing Meta’s </span><a href="https://facebook.github.io/watchman/" target="_blank" rel="noopener"><span>Watchman file system monitor</span></a><span> to query which files have changed without scanning the entire working copy, and we have special support for sparse checkouts to allow checking out only part of the repository.</span></p>
<p><span>Sparse checkouts are particularly designed for easy use within large organizations. Instead of each developer configuring and maintaining their own list of which files should be included, organizations can commit “sparse profiles” into the repository. When a developer clones the repository, they can choose to enable the sparse profile for their particular product. As the product’s dependencies change over time, the sparse profile can be updated by the person changing the dependencies, and every other engineer will automatically receive the new sparse configuration when they checkout or rebase forward. This allows thousands of engineers to work on a constantly shifting subset of the repository without ever having to think about it.</span></p>
<p><span>To handle large files, Sapling even supports using a Git LFS server.</span></p>
<h2><span>More to Come</span></h2>
<p><span>The Sapling client is just the first chapter of this story. In the future, we aim to open-source the Sapling-compatible virtual file system, which enables working with arbitrarily large working copies and making checkouts fast, no matter how many files have changed.</span></p>
<p><span>Beyond that, we hope to open-source the Sapling-compatible server: the scalable, distributed source control Rust service we use at Meta to serve Sapling and (soon) Git repositories. The server enables a multitude of new source control experiences. With the server, you can incrementally migrate repositories into (or out of) the monorepo, allowing you to experiment with monorepos before committing to them. It also enables Commit Cloud, where all commits in your organization are uploaded as soon as they are made, and sharing code is as simple as sending your colleague a commit hash and having them run </span><span>sl goto HASH</span><span>.</span></p>
<p><span>The release of this post marks my 10th year of working on Sapling at Meta, almost to the day. It’s been a crazy journey, and a single blog post cannot cover all the amazing work the team has done over the last decade. I highly encourage you to check out our </span><a href="https://www.sapling-scm.com/docs/overview/intro" target="_blank" rel="noopener"><span>armchair walkthrough</span></a><span> of Sapling’s cool features. I’d also like to thank the Mercurial open source community for all their collaboration and inspiration in the early days of Sapling, which started the journey to what it is today.</span></p>
<p><span>I hope you find Sapling as pleasant to use as we do, and that Sapling might start a conversation about the current state of source control and how we can all hold the bar higher for the source control of tomorrow.</span><span>See the </span><a href="https://www.sapling-scm.com/docs/introduction/getting-started"><span>Getting Started</span></a><span> page to try Sapling today.</span></p>

		
	</div></div>
  </body>
</html>
