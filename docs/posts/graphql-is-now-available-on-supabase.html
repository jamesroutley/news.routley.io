<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://supabase.com/blog/2022/03/29/graphql-now-available">Original</a>
    <h1>GraphQL is now available on Supabase</h1>
    
    <div id="readability-page-1" class="page"><article><div><p>GraphQL support is now in general availability on the Supabase platform via our <a href="https://github.com/supabase/pg_graphql/">open source</a> PostgreSQL extension,
<a href="https://supabase.github.io/pg_graphql/">`pg_graphql</a> (beta)`.</p><p><img src="https://theleo.zone/images/blog/launch-week-4/tuesday-graphql/supameme.png" alt="supameme.png"/></p><p><code>pg_graphql</code> enables you to query existing PostgreSQL databases using GraphQL, either from within SQL or over HTTP:</p><p>From SQL:</p><pre><div><pre><code><span>select</span><span> graphql.resolve($$
</span>    {
<span>      accountCollection(</span><span>first</span><span>: </span><span>1</span><span>) {
</span>        edges {
          node {
            id
            firstName
            address {
              countryCode
            }
          }
        }
      }
    }
$$);

</code></pre></div></pre><p>or over HTTP:</p><pre><div><pre><code><span>curl -X POST https://&lt;PROJECT_REF&gt;.supabase.co/graphql/v1 \
</span><span>    -H </span><span>&#39;apiKey: &lt;API_KEY&gt;&#39;</span><span>\
</span><span>    -H </span><span>&#39;Content-Type: application/json&#39;</span><span> \
</span><span>    --data-raw </span><span>&#39;
</span><span>    {
</span><span>      &#34;query&#34;:&#34;{ accountCollection(first: 3) { edges { node { id } } } }&#34;
</span><span>    }&#39;</span><span>
</span>
</code></pre></div></pre><h2 id="schema-reflection">Schema Reflection</h2><p>GraphQL types and fields are reflected from the SQL schema:</p><ul><li>Tables become types</li><li>Columns become fields</li><li>Foreign keys become relations</li></ul><p>For example:</p><pre><div><pre><code><span>create</span><span> </span><span>table</span><span> &#34;Account&#34;(
</span><span>    &#34;id&#34; serial </span><span>primary</span><span> key,
</span><span>    &#34;email&#34; </span><span>varchar</span><span>(</span><span>255</span><span>) </span><span>not</span><span> </span><span>null</span><span>,
</span><span>    &#34;createdAt&#34; </span><span>timestamp</span><span> </span><span>not</span><span> </span><span>null</span><span>,
</span><span>    &#34;updatedAt&#34; </span><span>timestamp</span><span> </span><span>not</span><span> </span><span>null</span><span>
</span>);

<span></span><span>-- Rebuild the GraphQL Schema Cache</span><span>
</span><span></span><span>select</span><span> graphql.rebuild_schema();
</span>
</code></pre></div></pre><p>Translates to the GraphQL base type</p><pre><div><pre><code><span>type</span><span> </span><span>Account</span><span> {
</span><span>  id: </span><span>Int</span><span>!
</span><span>  email: </span><span>String</span><span>!
</span><span>  createdAt: </span><span>DateTime</span><span>!
</span><span>  updatedAt: </span><span>DateTime</span><span>!
</span>}

</code></pre></div></pre><p>And exposes bulk CRUD operations on the <code>Query</code> and <code>Mutation</code> types, complete with relay style keyset pagination, filters, and ordering and (optional) name inflection.</p><pre><div><pre><code><span>type</span><span> </span><span>Query</span><span> {
</span>  accountCollection(
<span>    first: </span><span>Int</span><span>
</span><span>    last: </span><span>Int</span><span>
</span><span>    before: </span><span>Cursor</span><span>
</span><span>    after: </span><span>Cursor</span><span>
</span><span>    filter: </span><span>AccountFilter</span><span>
</span><span>    orderBy: [</span><span>AccountOrderBy</span><span>!]
</span><span>  ): </span><span>AccountConnection</span><span>
</span>}

<span></span><span>type</span><span> </span><span>Mutation</span><span> {
</span>    insertIntoAccountCollection(
<span>        objects: [</span><span>AccountInsertInput</span><span>!]!
</span><span>    ): </span><span>AccountInsertResponse</span><span>
</span>
    updateAccountCollection(
<span>    set: </span><span>AccountUpdateInput</span><span>!
</span><span>    filter: </span><span>AccountFilter</span><span>
</span><span>    atMost: </span><span>Int</span><span>! = 1
</span><span>  ): </span><span>AccountUpdateResponse</span><span>!
</span>
  deleteFromAccountCollection(
<span>   filter: </span><span>AccountFilter</span><span>
</span><span>    atMost: </span><span>Int</span><span>! = 1
</span><span>  ): </span><span>AccountDeleteResponse</span><span>!
</span>
</code></pre></div></pre><p>For a complete example with relationships, check out the <a href="https://supabase.github.io/pg_graphql/reflection/">reflection docs</a>.</p><h2 id="security">Security</h2><p>An advantage to embedding GraphQL directly in the database is that we can lean on PostgreSQL&#39;s built-in primitives for authentication and authorization.</p><h3 id="authentication">Authentication</h3><p>The GraphQL types exposed by <code>pg_graphql</code> are filtered according to the SQL role&#39;s <a href="https://www.postgresql.org/docs/current/sql-grant.html">INSERT/UPDATE/DELETE permissions</a>.
At Supabase, each API request is resolved in the database using the role in the request&#39;s JWT.</p><p>Anonymous users receive the <code>anon</code> role, and logged in users get the <code>authenticated</code> role. In either case, pg_graphql resolves requests according to the SQL permissions.
The <a href="https://graphql.org/learn/introspection/">introspection schema</a> is similarly filtered to limit exposed types and fields to those that the user has permission to access.
That means we can serve multiple GraphQL schemas for users of differing privilege levels from a single endpoint!</p><p>Another nice side effect of making PostgreSQL do the heavy lifting is that GraphQL queries respect your existing
<a href="https://www.postgresql.org/docs/current/ddl-rowsecurity.html">row level security policies</a> right out-of-the-box. No additional configuration required.</p><h2 id="performance">Performance</h2><p>Each <a href="https://supabase.com/pricing">free tier database</a> on the Supabase platform runs on a dedicated AWS t4g.micro instance with 2 vCPUs and 1 GB of memory.
To squeeze the most out of that limited hardware we had to make a few significant optimizations:</p><p><strong>GraphQL queries are always transpiled into exactly one SQL query</strong></p><p>The SQL queries select and aggregate requested data into the shape of the GraphQL JSON response.
In addition to solving the <a href="https://medium.com/the-marcy-lab-school/what-is-the-n-1-problem-in-graphql-dd4921cb3c1a">N+1 query problem</a>, a common issue with GraphQL resolvers,
GraphQL queries requiring multiple joins typically produce significantly less IO due to reduced data duplication.</p><p>For example, when selecting all comments for a blog post:</p><pre><div><pre><code><span>select</span><span>
</span>    blog_posts.title,
<span>    comments.body </span><span>as</span><span> comment_body
</span><span></span><span>from</span><span>
</span>    blog_posts
<span></span><span>join</span><span>
</span><span>    comments </span><span>on</span><span> blog_posts.id </span><span>=</span><span> comments.blog_post_id
</span>
</code></pre></div></pre><p>a SQL response would duplicate all data from the <code>blog_posts</code> table (title).</p><pre><div><pre><code><span>| title      | comment</span><span>_body                   |
</span><span>| ---------- | ------------------------------ |
</span><span>| F1sRt P0$T | this guy gets it!              |
</span><span>| F1sRt P0$T | you should re-write it in rust |
</span><span>| F1sRt P0$T | 10% off daily vitamin http:... |
</span><span>
</span></code></pre></div></pre><p>Compared to the equivalent GraphQL response.</p><pre><div><pre><code><span>{
</span><span>    </span><span>&#34;blogPostCollection&#34;</span><span>: {
</span><span>    </span><span>&#34;edges&#34;</span><span>: {
</span><span>      </span><span>&#34;node&#34;</span><span>:
</span><span>        </span><span>&#34;title&#34;</span><span>: </span><span>&#34;F1sRt P0$T&#34;</span><span>
</span><span>        </span><span>&#34;commentCollection&#34;</span><span>: {
</span><span>          </span><span>&#34;edges&#34;</span><span>: [
</span><span>            </span><span>&#34;node&#34;</span><span>: {
</span><span>                    </span><span>&#34;body&#34;</span><span>: </span><span>&#34;this guy gets it!&#34;</span><span>
</span>                        },
<span>                        </span><span>&#34;node&#34;</span><span>: {
</span><span>                    </span><span>&#34;body&#34;</span><span>: </span><span>&#34;you should re-write it in rust&#34;</span><span>
</span>                        },
<span>                        </span><span>&#34;node&#34;</span><span>: {
</span><span>                      </span><span>&#34;body&#34;</span><span>: </span><span>&#34;10% off daily vitamin http:...&#34;</span><span>
</span>                }
          ]
        }
      }
    }
  }
}

</code></pre></div></pre><p>Which has no duplication of data.</p><p>The difference in payload size is negligible in this case, but as the number of 1-to-many joins grows, data duplication in the SQL response grows geometrically.</p><p><strong>Queries are cached as <a href="https://www.postgresql.org/docs/current/sql-prepare.html">prepared statements</a></strong></p><p>After a GraphQL query is transpiled to SQL, it is added to the prepared statement cache so subsequent requests with the same structure (think pagination) can skip the transpilation step.</p><p>Using prepared statements also allows PostgreSQL to skip the overhead of computing a query plan. For small, on-index, queries,
the query planning step can take several times as long as the query&#39;s execution time, so the saving is significant at scale.</p><p><strong>All operations are bulk</strong></p><p>Finally, all reflected query and mutation fields support bulk operations to nudge users towards consuming the API efficiently.
Batching similar operations reduces network round-trips and time spent in the database.</p><p><strong>Result</strong></p><p>As a result of these optimizations, the throughput of a ‚Äúhello world‚Äù equivalent query on Supabase free-tier hardware is:</p><ul><li>377.4 requests/second through the API (mean)</li><li>656.2 queries/second through SQL (single connection, mean)</li></ul><h2 id="getting-started">Getting Started</h2><p>To enable GraphQL in your Supabase instance, enable <code>pg_graphql</code> from the dashboard.</p><video width="99%" autoplay="" muted="" playsinline="" controls=""><source src="/videos/blog/launch-week-4/api-enable-graphql.mp4" type="video/mp4" muted="" playsinline=""/></video><p>Or create the extension in your database</p><pre><div><pre><code><span>create</span><span> extension pg_graphql;
</span>
</code></pre></div></pre><p>And we&#39;re done!</p><p>The GraphQL endpoint is available at: <code>https://&lt;project_ref&gt;.supabase.co/graphql/v1</code></p><h2 id="example-app-build-a-hn-clone-with-postgres-and-graphql">Example app: Build a HN clone with Postgres and GraphQL</h2><p><img src="https://theleo.zone/images/blog/launch-week-4/tuesday-graphql/graph-ql-example-app.png" alt="graph-ql-example-app.png"/></p><p>We&#39;re excited to have worked with <a href="https://www.the-guild.dev">The Guild</a> to show you <a href="https://supabase-graphql-example.vercel.app/about">how to use</a> <code>pg_graphql</code>
and their tools to build a <a href="https://supabase-graphql-example.vercel.app/">HackerNews clone</a>.</p><p>The <a href="https://supabase-graphql-example.vercel.app/">demo application</a> showcases:</p><ul><li><strong>CRUD (Query + Mutation Operations).</strong>
Data is fetched from the GraphQL layer auto-generated via <code>pg_graphql</code>.</li><li><strong>Cursor Based Pagination.</strong><code>pg_graphql</code> generates standardized pagination types and fields as defined by the GraphQL Cursor Connections Specification.</li><li><strong>Authorization / RLS.</strong>
GraphQL requests made include Supabase authorization headers so that Row Level Security on the Postgres layer ensures that viewers can only access what they are allowed to ‚Äî and authenticated users can only update what they should.</li><li><strong>Code generation.</strong>
Introspect your GraphQL schema and operations to generates the types for full backend to frontend type-safety.</li><li><strong>Postgres Triggers and Functions.</strong>
Recalculate the feed scoring each time someone votes.</li><li><strong>Supabase UI.</strong>
Use Auth widget straight out the box to handle logins and access tokens.</li></ul><p><img src="https://theleo.zone/images/blog/launch-week-4/tuesday-graphql/graph-ql-example-app-2.png" alt="graph-ql-example-app-2.png"/></p><p>Now instead of using the Supabase PostgREST API to query your database ...</p><pre><div><pre><code><span>// using Supabase PostgREST</span><span>
</span>
<span></span><span>const</span><span> { data, error } = </span><span>await</span><span> supabase
</span><span>  .from(</span><span>&#39;profile&#39;</span><span>)
</span><span>  .select(</span><span>&#39;id, username, bio, avatarUrl, website&#39;</span><span>)
</span>
</code></pre></div></pre><p>... all data fetching and updates are done using the same GraphQL operations you know and love! ü§Ø</p><pre><div><pre><code><span>// using GraphQL</span><span>
</span>
query ProfilesQuery {
    profileCollection {
      edges {
        node {
          id
          username
          bio
          avatarUrl
          website
      }
    }
  }
}

</code></pre></div></pre><p>üéÅ¬† Get the code on GitHub here: <a href="https://github.com/supabase-community/supabase-graphql-example">github.com/supabase-community/supabase-graphql-example</a></p><h2 id="supabase--the-guild">Supabase + The Guild</h2><p><img src="https://theleo.zone/images/blog/launch-week-4/tuesday-graphql/graphql-supabase-guild.png" alt="graphql-supabase-guild.png"/></p><p>This is just the start of what we hope to be a close collaboration with the Guild, whose expertise of the GraphQL ecosystem will guide the development of Supabase&#39;s GraphQL features.
The Guild and Supabase share a similar approach to open source - we both favor collaboration and composability, making collaboration easy and productive.</p><p>Be sure to visit <a href="https://www.the-guild.dev">The Guild</a> and <a href="https://twitter.com/TheGuildDev">follow them</a> to stay informed of the latest developments in GraphQL.</p><h2 id="limitations--roadmap">Limitations &amp; Roadmap</h2><p>Our first general availability release of <code>pg_graphql</code> supports:</p><ul><li>Full CRUD on table columns with scalar types</li><li>Read only support for array types</li><li>Extending types with <a href="https://supabase.github.io/pg_graphql/computed_fields/">computed fields</a></li><li>Configuration with <a href="https://supabase.github.io/pg_graphql/configuration/">SQL comments</a></li></ul><p>In the near term, we plan to fully support array and json/b types. Longer term, we intend to support views and custom mutations from user defined functions.</p><p>Didn&#39;t see the feature you&#39;re interested in? <a href="https://github.com/supabase/pg_graphql/issues">Let us know</a></p></div></article></div>
  </body>
</html>
