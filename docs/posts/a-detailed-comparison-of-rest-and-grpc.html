<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kreya.app/blog/rest-vs-grpc/">Original</a>
    <h1>A detailed comparison of REST and gRPC</h1>
    
    <div id="readability-page-1" class="page"><div id="post-content" itemprop="articleBody"><p>For a long time, REST was the one and only &#34;standard&#34; for building APIs. It kind of replaced SOAP, which was an ugly mess of &#34;too much XML&#34;.
But in recent years, new alternatives have emerged.
In 2015, Facebook released GraphQL to the public, and in 2016 Google followed suit with the release of <a href="https://grpc.io/" target="_blank" rel="noopener noreferrer">gRPC</a>.
In this article, we are going to focus on the latter and compare it with REST, which is still widely used.</p><h2 id="overview">Overview<a href="#overview" aria-label="Direct link to Overview" title="Direct link to Overview">​</a></h2><p>The following table will give you an overview of the discussed points and shows where REST and gRPC really shine.</p><table><thead><tr><th>Topic</th><th>REST</th><th>gRPC</th></tr></thead><tbody><tr><td><a href="#standardization">Standardization</a></td><td>No standard</td><td>Well defined</td></tr><tr><td><a href="#fundamental-differences">Paradigm</a></td><td>Resource based</td><td>RPC</td></tr><tr><td><a href="#service-modes">Service modes</a></td><td>Only unary</td><td>Unary, client streaming, server streaming and bidirectional streaming</td></tr><tr><td><a href="#requirements">Requirements</a></td><td>Any HTTP version, JSON parser</td><td>HTTP/2, gRPC implementation for language</td></tr><tr><td><a href="#api-design">API design</a></td><td>Code first</td><td>Design first</td></tr><tr><td><a href="#data-format">Default data format</a></td><td>JSON</td><td>Protobuf</td></tr><tr><td><a href="#browser-compatibility">Web browser support</a></td><td>Native</td><td>gRPC web, via workarounds</td></tr><tr><td><a href="#tooling">Tools</a></td><td>More established tools</td><td>Language support varies, some with excellent implementations</td></tr></tbody></table><h2 id="standardization">Standardization<a href="#standardization" aria-label="Direct link to Standardization" title="Direct link to Standardization">​</a></h2><p>One of the disadvantages of REST is the lack of standardization.
REST is more of a paradigm than an API standard and many folks mean different things when talking about it.
For most, the term &#34;REST API&#34; is used for HTTP-based JSON APIs. For others, REST is used interchangeably with certain specifications such as <a href="https://en.wikipedia.org/wiki/HATEOAS" target="_blank" rel="noopener noreferrer">HATEOAS</a> or <a href="https://jsonapi.org/" target="_blank" rel="noopener noreferrer">JSON:API</a>.
But using XML instead of JSON would still make an API RESTful, even though that is not widely understood. The term REST is not even tied to HTTP.
This can result in a lot of confusion when working with REST APIs.
For example, consumers may automatically expect idempotency or cacheability of certain REST API endpoints, even though that is not defined explicitly.</p><p>In comparison, gRPC is well defined.
For example, the <a href="https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md" target="_blank" rel="noopener noreferrer">gRPC implementation over HTTP/2</a> is pretty detailed.</p><h2 id="fundamental-differences">Fundamental differences<a href="#fundamental-differences" aria-label="Direct link to Fundamental differences" title="Direct link to Fundamental differences">​</a></h2><p>The paradigms of REST and gRPC are not the same.</p><p>With REST, everything centers around resources, which can be retrieved and manipulated.
If we take a book as an example resource, a REST API will typically provide the following endpoints:</p><ul><li><code>GET /books</code> (fetch all books, most likely with parameters to filter and page the results)</li><li><code>GET /books/{id}</code> (fetch a specific book)</li><li><code>POST /books</code> (create a book)</li><li><code>DELETE /books/{id}</code> (delete a book)</li></ul><p>and so on. Most HTTP-based REST APIs follow this pattern.
While this works well, certain cases are difficult to represent as a REST API.
For example, what if I want to create multiple books and do not want to call <code>POST /books</code> repeatedly for each book (for performance, idempotency or whatever reason)?
Do I create a <code>POST /books/batch</code> endpoint? Is that still &#34;RESTful&#34;? While easy to solve technically, it often creates long discussions among developers.</p><p>gRPC on the other hand is an RPC framework. It centers around service methods.
If we take the book API example, with gRPC we would create a <code>BookService</code> with the following methods:</p><ul><li><code>GetBooks()</code></li><li><code>GetBook()</code></li><li><code>CreateBook()</code></li><li><code>DeleteBook()</code></li></ul><p>We can name these methods however we like and require whatever parameters we need.
If we now want to add a method to create multiple books, nothing stops us from adding a <code>CreateBooks()</code> method.
gRPC offers more &#34;freedom&#34; when designing APIs, as there are less (self-imposed) restrictions.</p><h3 id="service-modes">Service modes<a href="#service-modes" aria-label="Direct link to Service modes" title="Direct link to Service modes">​</a></h3><p>gRPC supports four kind of service methods:</p><ul><li><strong>Unary:</strong> Send a single request, receive a single response</li><li><strong>Server streaming:</strong> Send a single request, receive multiple responses</li><li><strong>Client streaming:</strong> Send multiple requests, receive a single response</li><li><strong>Bidirectional streaming:</strong> Send multiple requests, receive multiple reponses</li></ul><p>This is a very nice advantage of gRPC in comparison to REST, which only supports unary requests.
Supporting other service modes in REST APIs would require the usage of a different protocol such as server-sent events or websockets, which isn&#39;t quite &#34;RESTful&#34;.</p><h3 id="requirements">Requirements<a href="#requirements" aria-label="Direct link to Requirements" title="Direct link to Requirements">​</a></h3><p>REST APIs often &#34;just work&#34; with any kind of HTTP version.
As long as a programming language has an HTTP client and a library for JSON parsing, consuming REST APIs is a breeze.</p><p>gRPC explicitely needs HTTP/2 support, otherwise it will not work.
In recent years, this has become less of a problem, as most proxies and frameworks have added support for HTTP/2.</p><p>As gRPC requires code generation (for creating clients or server stubs), only <a href="https://grpc.io/docs/languages/" target="_blank" rel="noopener noreferrer">a set of programming languages</a> are supported.</p><h2 id="api-design">API design<a href="#api-design" aria-label="Direct link to API design" title="Direct link to API design">​</a></h2><p>A REST API is often the result of its implementation, dubbed &#34;code-first.&#34;
While it is possible to design the API with OpenAPI first and then generate a server stub, it is not an approach that many developers take.
The OpenAPI definition is more likely generated from the API implementation, if there is an OpenAPI definition at all.
As a result, the API definition is tightly coupled to the implementation.
Changes in the wrong model/class can result in unintentional breaking changes of the API.</p><p>gRPC uses a different approach, where the API has to be defined before one can implement it (dubbed &#34;design-first&#34;).
Clients and server stubs are then generated from this API definition.
This requires some thinking ahead, as one cannot jump directly into implementing the API.</p><p>Both approaches have their pros and cons.
The usual REST API approach allows quicker iteration, as the server is always the source of truth.
With gRPC, it can be annoying to first change the API definition before being able to adjust the implementation.
However, it brings some safety benefits by having the API explicitly defined.</p><h2 id="data-format">Data format<a href="#data-format" aria-label="Direct link to Data format" title="Direct link to Data format">​</a></h2><p>Both REST and gRPC can use different formats to transfer data.
Most REST APIs use JSON, while gRPC uses <a href="https://protobuf.dev/" target="_blank" rel="noopener noreferrer">Protocol Buffers</a> (Protobuf) by default, so we will compare these two.</p><p>JSON has limited support for data types and also has some quirks (ex. big numbers need to be represented as strings).
It is a text format and human readable.
Field names are serialized, which takes up some space.
In some programming languages, this also requires the use of reflection to deserialize JSON messages, which is quite slow.</p><p>As written above, gRPC APIs and the respective message types are first defined as Protocol Buffers.
Each message is strongly typed, may contain useful comments and has lots of other interesting features.
For the supported list of programming languages, code to (de-)serialize messages can be automatically generated.
As it is a binary format and does not serialize the field names, it uses less space than an equivalent JSON message.
This does have the drawback that it is no longer human readable and requires the Protobuf definition to deserialize messages, which can hamper the developer experience.</p><p>The following JSON example would take up roughly 66 bytes (with whitespace removed).</p><div><div><pre tabindex="0"><code><span><span>{</span><span></span><br/></span><span><span>  </span><span>&#34;persons&#34;</span><span>:</span><span> </span><span>[</span><span></span><br/></span><span><span>    </span><span>{</span><span></span><br/></span><span><span>      </span><span>&#34;name&#34;</span><span>:</span><span> </span><span>&#34;Max&#34;</span><span>,</span><span></span><br/></span><span><span>      </span><span>&#34;age&#34;</span><span>:</span><span> </span><span>23</span><span></span><br/></span><span><span>    </span><span>}</span><span>,</span><span></span><br/></span><span><span>    </span><span>{</span><span></span><br/></span><span><span>      </span><span>&#34;name&#34;</span><span>:</span><span> </span><span>&#34;Mike&#34;</span><span>,</span><span></span><br/></span><span><span>      </span><span>&#34;age&#34;</span><span>:</span><span> </span><span>52</span><span></span><br/></span><span><span>    </span><span>}</span><span></span><br/></span><span><span>  </span><span>]</span><span></span><br/></span><span><span></span><span>}</span><br/></span></code></pre></div></div><p>An equivalent serialized protobuf message would only use 19 bytes.</p><div><div><pre tabindex="0"><code><span><span>0x0A070A034D617810170A080A0448616E731034</span><br/></span></code></pre></div></div><h3 id="large-messages">Large messages<a href="#large-messages" aria-label="Direct link to Large messages" title="Direct link to Large messages">​</a></h3><p>Protobuf is designed to serialize and deserialize messages in-memory.
As a result, transferring huge messages with Protobuf/gRPC is not recommended.
Most gRPC implementation place a default limit of 4 MB on individual messages.</p><p>Handling large data sizes with REST APIs, such as file uploads, is rather straight forward.
The received file can be treated as a stream, using very little memory.
This is not impossible with gRPC, but needs more manual effort.
The file would have to be chunked into several parts on the sender side.
Each chunk would then be sent as an individual message via a client-streaming method to the server.
The server receives each chunk and can construct a data stream from it, resulting in a similar behaviour to the REST API, although with more effort.</p><h2 id="browser-compatibility">Browser compatibility<a href="#browser-compatibility" aria-label="Direct link to Browser compatibility" title="Direct link to Browser compatibility">​</a></h2><p>This is where REST really shines. It is supported natively by web browsers, making it effortless to consume REST APIs from web applications.</p><p>gRPC is not directly supported by browsers, as it requires explicit HTTP/2 support and access to certain HTTP/2 features, which web browsers do not provide.
As a workaround, <a href="https://github.com/grpc/grpc-web" target="_blank" rel="noopener noreferrer">gRPC Web</a> can be used.
It is a slight variation of the gRPC protocol to make it consumable by web browsers.
For some programming languages, gRPC Web support is already included in the framework.
For others, a proxy is needed to translate gRPC traffic into gRPC Web traffic and vice versa.
In comparison to REST APIs, which require no dependencies, gRPC APIs are more cumbersome to consume from the web.</p><p>A workaround could be to use <a href="https://cloud.google.com/endpoints/docs/grpc/transcoding" target="_blank" rel="noopener noreferrer">JSON transcoding</a>,
which allows developers to expose a gRPC API as a REST API.</p><p>gRPC and REST tooling varies heavily between programming languages and frameworks.
In some, gRPC feels more &#34;native&#34; while in others, the REST tooling is much more advanced.</p><p>Proper language support for gRPC matters a lot more, since it requires tooling to generate clients and server stubs.
For non-supported programming, you are out of luck.
Clients for REST APIs can always be created manually, but this may take some effort.
While tools to create REST clients from OpenAPI definitions exist, their developer experience is often lackluster in comparison to the gRPC equivalent.</p><p>Since REST APIs have been around for much longer, more tools that help build, test and deploy REST APIs exist.
Their functionality is often more advanced than that of gRPC tools.
This is also one of the main reasons why we built <a href="https://kreya.app" target="_blank" rel="noopener noreferrer">Kreya</a>, which tries to be the best gRPC GUI client (while also supporting REST).</p><h2 id="conclusion">Conclusion<a href="#conclusion" aria-label="Direct link to Conclusion" title="Direct link to Conclusion">​</a></h2><p>REST and gRPC both have their advantages and disadvantages.</p><p>Consuming REST APIs from web apps is generally easier.
REST is also more widely used, making it simpler to use for some developers, as they may not know about gRPC.</p><p>In my opinion, gRPC definitely has advantages in server-to-server communications (ex. between microservices).
The ability to share the exact API definition and to create API clients in multiple programming languages is a huge win.</p><p>There is no definitive answer to &#34;Should we use REST or gRPC?&#34;.
Some APIs could have unique use cases for which gRPC or REST may prove a better fit.
Or developers could simply be more comfortable or experienced with either REST or gRPC.
All these reasons are fine. In the end, everyone has to decide for themselves which technology to use.</p></div></div>
  </body>
</html>
