<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://thoughtspile.github.io/2022/01/17/jsx-conditionals/">Original</a>
    <h1>Advice on JSX Conditionals</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody"><p>Conditional rendering is a cornerstone of any templating language. React / JSX bravely chose not to have a dedicated conditional syntax, like <code>ng-if=&#34;condition&#34;</code>, <a target="_blank" rel="noopener" href="https://reactjs.org/docs/conditional-rendering.html">relying</a> on JS <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_AND">boolean operators</a> instead:</p><ul><li><code>condition &amp;&amp; &lt;JSX /&gt;</code> renders <code>&lt;JSX /&gt;</code> iff <code>condition</code> is truthy,</li><li><code>condition ? &lt;JsxTrue /&gt; : &lt;JsxFalse /&gt;</code> renders <code>&lt;JsxTrue /&gt;</code> or <code>&lt;JsxFalse /&gt;</code> depending on the truthiness of <code>condition</code>.</li></ul><p>Courageous, but not always as intuitive as you’d expect. Time after time I shoot myself in the foot with JSX conditionals. In this article, I look at the trickier corners of JSX conditionals, and share some tips for staying safe:</p><ol><li>Number <code>0</code> likes to leak into your markup.</li><li>Compound conditions with <code>||</code> can surprise you because precedence</li><li>Ternaries don’t scale.</li><li><code>props.children</code> is not something to use as a condition</li><li>How to manage update vs remount in conditionals.</li></ol><p>If you’re in a hurry, I’ve made a cheat sheet:</p><p><img src="https://thoughtspile.github.io/images/jsx-conditional-cheatsheet-b8767f76d64c89489aee556042b356d5.png"/></p><h2 id="Beware-of-zero"><a href="#Beware-of-zero" title="Beware of zero"></a>Beware of zero</h2><p>Rendering on <em>numerical</em> condition is a common use case. It’s helpful for rendering a collection only if it’s loaded and non-empty:</p><pre data-language="jsx"><code><span>{</span>gallery<span>.</span>length <span>&amp;&amp;</span> <span><span><span>&lt;</span><span>Gallery</span></span> <span>slides</span><span><span>=</span><span>{</span>gallery<span>}</span></span><span>&gt;</span></span><span>}</span></code></pre><p>However, if the gallery <em>is</em> empty, we get an annoying <code>0</code> in out DOM instead of nothing. That’s because of the way <code>&amp;&amp;</code> works: a falsy left-hand side (like 0) is returned immediately. In JS, boolean operators do not cast their result to boolean — and for the better, since you don’t want the right-hand JSX to turn into <code>true</code>. React then proceeds to put that 0 into the DOM — unlike <code>false</code>, it’s a valid react node (again, for good — in <code>you have {count} tickets</code> rendering 0 is perfectly expected).</p><p>The fix? I have two. Cast the condition to boolean explicitly in any way you like. Now the expression value is <code>false</code>, not <code>0</code>, and <code>false</code> is not rendered:</p><pre data-language="jsx"><code>gallery<span>.</span>length <span>&gt;</span> <span>0</span> <span>&amp;&amp;</span> jsx

<span>!</span><span>!</span>gallery<span>.</span>length <span>&amp;&amp;</span> jsx

<span>Boolean</span><span>(</span>gallery<span>.</span>length<span>)</span> <span>&amp;&amp;</span> jsx</code></pre><p>Alternatively, replace <code>&amp;&amp;</code> with a ternary to explicitly provide the falsy value — <code>null</code> works like a charm:</p><pre data-language="jsx"><code><span>{</span>gallery<span>.</span>length <span>?</span> <span><span><span>&lt;</span><span>Gallery</span></span> <span>slides</span><span><span>=</span><span>{</span>gallery<span>}</span></span> <span>/&gt;</span></span> <span>:</span> <span>null</span><span>}</span></code></pre><h2 id="Mind-the-precedence"><a href="#Mind-the-precedence" title="Mind the precedence"></a>Mind the precedence</h2><p><em>And</em> (<code>&amp;&amp;</code>) has a higher precedence than <em>or</em> (<code>||</code>) — that’s how <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Boolean_algebra">boolean algebra</a> works. However, this also means that you must be very careful with JSX conditions that contain <code>||</code>. Watch as I try to render an access error for anonymous <em>or</em> restricted users…</p><pre data-language="jsx"><code>user<span>.</span>anonymous <span>||</span> user<span>.</span>restricted <span>&amp;&amp;</span> <span><span><span>&lt;</span>div</span> <span>className</span><span><span>=</span><span>&#34;</span>error<span>&#34;</span></span> <span>/&gt;</span></span></code></pre><p>… and I screw up! The code above is actually equivalent to:</p><pre data-language="jsx"><code>user<span>.</span>anonymous <span>||</span> <span>(</span>user<span>.</span>restricted <span>&amp;&amp;</span> <span><span><span>&lt;</span>div</span> <span>className</span><span><span>=</span><span>&#34;</span>error<span>&#34;</span></span> <span>/&gt;</span></span><span>)</span></code></pre><p>Which is <em>not</em> what I want. For anonymous users, you get <code>true || ...whatever...</code>, which is <code>true</code>, because JS <em>knows</em> the or-expression is true just by looking at the left-hand side and skips (<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/12554578/does-javascript-have-short-circuit-evaluation">short-circuits</a>) the rest. React doesn’t render <code>true</code>, and even if it did, <code>true</code> is not the error message you expect.</p><p>As a rule of thumb, parenthesize the condition as soon as you see the OR:</p><pre data-language="jsx"><code><span>{</span><span>(</span>user<span>.</span>anonymous <span>||</span> user<span>.</span>restricted<span>)</span> <span>&amp;&amp;</span> <span><span><span>&lt;</span>div</span> <span>className</span><span><span>=</span><span>&#34;</span>error<span>&#34;</span></span> <span>/&gt;</span></span><span>}</span></code></pre><p>For a more sneaky case, consider this ternary-inside-the-condition:</p><pre data-language="jsx"><code><span>{</span>user<span>.</span>registered <span>?</span> user<span>.</span>restricted <span>:</span> user<span>.</span>rateLimited <span>&amp;&amp;</span>
    <span><span><span>&lt;</span>div</span> <span>className</span><span><span>=</span><span>&#34;</span>error<span>&#34;</span></span> <span>/&gt;</span></span><span>}</span></code></pre><p>Parentheses still help, but avoiding ternaries in conditions is a better option — they’re very confusing, because you can’t even read the expression out in English (if the user is registered then if the user is restricted otherwise if the user is rate-limited, please make it stop).</p><h2 id="Don’t-get-stuck-in-ternaries"><a href="#Don’t-get-stuck-in-ternaries" title="Don’t get stuck in ternaries"></a>Don’t get stuck in ternaries</h2><p>A ternary is a fine way to switch between <em>two</em> pieces of JSX. Once you go beyond 2 items, the lack of an <code>else if ()</code> turns your logic into a bloody mess real quick:</p><pre data-language="jsx"><code><span>{</span>isEmoji
    <span>?</span> <span><span><span>&lt;</span><span>EmojiButton</span></span> <span>/&gt;</span></span>
    <span>:</span> isCoupon
        <span>?</span> <span><span><span>&lt;</span><span>CouponButton</span></span> <span>/&gt;</span></span>
        <span>:</span> isLoaded <span>&amp;&amp;</span> <span><span><span>&lt;</span><span>ShareButton</span></span> <span>/&gt;</span></span><span>}</span></code></pre><p>Any extra conditions inside a ternary branch, be it a nested ternary or a simple <code>&amp;&amp;</code>, are a red flag. Sometimes, a series of <code>&amp;&amp;</code> blocks works better, at the expense of duplicating some conditions:</p><pre data-language="jsx"><code><span>{</span>isEmoji <span>&amp;&amp;</span> <span><span><span>&lt;</span><span>EmojiButton</span></span> <span>/&gt;</span></span><span>}</span>
<span>{</span>isCoupon <span>&amp;&amp;</span> <span><span><span>&lt;</span><span>CouponButton</span></span> <span>/&gt;</span></span><span>}</span>
<span>{</span><span>!</span>isEmoji <span>&amp;&amp;</span> <span>!</span>isCoupon <span>&amp;&amp;</span> isLoaded <span>&amp;&amp;</span> <span><span><span>&lt;</span><span>ShareButton</span></span> <span>/&gt;</span></span><span>}</span></code></pre><p>Other times, a good old <code>if / else</code> is the way to go. Sure, you can’t inline these in JSX, but you can always extract a function:</p><pre data-language="jsx"><code><span>const</span> <span>getButton</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>if</span> <span>(</span>isEmoji<span>)</span> <span>return</span> <span><span><span>&lt;</span><span>EmojiButton</span></span> <span>/&gt;</span></span><span>;</span>
    <span>if</span> <span>(</span>isCoupon<span>)</span> <span>return</span> <span><span><span>&lt;</span><span>CouponButton</span></span> <span>/&gt;</span></span><span>;</span>
    <span>return</span> isLoaded <span>?</span> <span><span><span>&lt;</span><span>ShareButton</span></span> <span>/&gt;</span></span> <span>:</span> <span>null</span><span>;</span>
<span>}</span><span>;</span></code></pre><h2 id="Don’t-conditional-on-JSX"><a href="#Don’t-conditional-on-JSX" title="Don’t conditional on JSX"></a>Don’t conditional on JSX</h2><p>In case you’re wondering, react elements passed via props don’t work as a condition. Let me try wrapping the children in a div <em>only</em> if there are children:</p><pre data-language="js"><code><span>const</span> <span>Wrap</span> <span>=</span> <span>(</span><span>props</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>props<span>.</span>children<span>)</span> <span>return</span> <span>null</span><span>;</span>
    <span>return</span> <span>&lt;</span>div<span>&gt;</span><span>{</span>props<span>.</span>children<span>}</span><span>&lt;</span><span>/</span>div<span>&gt;</span>
<span>}</span><span>;</span></code></pre><p>I expect <code>Wrap</code> to render <code>null</code> when there is no content wrapped, but React doesn’t work like that:</p><ul><li><code>props.children</code> can be an empty array, e.g. <code>&lt;Wrap&gt;{[].map(e =&gt; &lt;div /&gt;)}&lt;/Wrap&gt;</code></li><li><code>children.length</code> fails, too: <code>children</code> can <em>also</em> be a single element, not an array (<code>&lt;Wrap&gt;&lt;div /&gt;&lt;/Wrap&gt;</code>).</li><li><code>React.Children.count(props.children)</code> <a target="_blank" rel="noopener" href="https://reactjs.org/docs/react-api.html#reactchildrencount">supports</a> both single and multiple children, but thinks that <code>&lt;Wrap&gt;{false &amp;&amp; &#39;hi&#39;}{false &amp;&amp; &#39;there&#39;}&lt;/Wrap&gt;</code> contains 2 items, while in reality there are none.</li><li>Next try: <code>React.Children.toArray(props.children)</code> <a target="_blank" rel="noopener" href="https://reactjs.org/docs/react-api.html#reactchildrentoarray">removes invalid nodes,</a> such as <code>false</code>. Sadly, you still get true for an empty fragment: <code>&lt;Wrap&gt;&lt;&gt;&lt;/&gt;&lt;Wrap&gt;</code>.</li><li>For the final nail in this coffin, if we move the conditional rendering inside a component: <code>&lt;Wrap&gt;&lt;Div hide /&gt;&lt;/Wrap&gt;</code> with <code>Div = (p) =&gt; p.hide ? null : &lt;div /&gt;</code>, we can <em>never</em> know if it’s empty during <code>Wrap</code> render, because react only renders the child <code>Div</code> after the parent, and a stateful child can re-render independently from its parent.</li></ul><p>For the only sane way to change anything if the interpolated JSX is empty, see <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/CSS/:empty">CSS <code>:empty</code> pseudo-class.</a></p><h2 id="Remount-or-update"><a href="#Remount-or-update" title="Remount or update?"></a>Remount or update?</h2><p>JSX written in separate ternary branches feels like completely independent code. Consider the following:</p><pre data-language="jsx"><code><span>{</span>hasItem <span>?</span> <span><span><span>&lt;</span><span>Item</span></span> <span>id</span><span><span>=</span><span>{</span><span>1</span><span>}</span></span> <span>/&gt;</span></span> <span>:</span> <span><span><span>&lt;</span><span>Item</span></span> <span>id</span><span><span>=</span><span>{</span><span>2</span><span>}</span></span> <span>/&gt;</span></span><span>}</span></code></pre><p>What happens when <code>hasItem</code> changes? Don’t know about you, but my guess would be that <code>&lt;Item id={1} /&gt;</code> unmounts, then <code>&lt;Item id={2} /&gt;</code> mounts, because I wrote 2 separate JSX tags. React, however, doesn’t know or care what I wrote, all it sees is the <code>Item</code> element in the same position, so it keeps the mounted instance, updating props (see <a target="_blank" rel="noopener" href="https://codesandbox.io/s/still-cherry-o123c?file=/src/App.js">sandbox</a>). The code above is equivalent to <code>&lt;Item id={hasItem ? 1 : 2} /&gt;</code>.</p><blockquote><p>When the branches contain different components, as in <code>{hasItem ? &lt;Item1 /&gt; : &lt;Item2 /&gt;}</code>, React remounts, because <code>Item1</code> can’t be updated to become <code>Item2</code>.</p></blockquote><p>The case above just causes some unexpected behavior that’s fine as long as you properly manage updates, and even a bit more optimal than remounting. However, with uncontrolled inputs you’re in for a disaster:</p><pre data-language="jsx"><code><span>{</span>mode <span>===</span> <span>&#39;name&#39;</span>
    <span>?</span> <span><span><span>&lt;</span>input</span> <span>placeholder</span><span><span>=</span><span>&#34;</span>name<span>&#34;</span></span> <span>/&gt;</span></span>
    <span>:</span> <span><span><span>&lt;</span>input</span> <span>placeholder</span><span><span>=</span><span>&#34;</span>phone<span>&#34;</span></span> <span>/&gt;</span></span><span>}</span></code></pre><p>Here, if you input something into <em>name</em> input, then switch the mode, your name unexpectedly leaks into the <em>phone</em> input. (again, see <a target="_blank" rel="noopener" href="https://codesandbox.io/s/still-cherry-o123c?file=/src/App.js">sandbox</a>) This can cause even more havoc with complex update mechanics relying on previous state.</p><p>One workaround here is using the <code>key</code> prop. Normally, we use it for <a target="_blank" rel="noopener" href="https://reactjs.org/docs/lists-and-keys.html">rendering lists,</a> but it’s actually an <em>element identity</em> hint for React — elements with the same <code>key</code> are the same logical element.</p><pre data-language="jsx"><code>
<span>{</span>mode <span>===</span> <span>&#39;name&#39;</span>
    <span>?</span> <span><span><span>&lt;</span>input</span> <span>placeholder</span><span><span>=</span><span>&#34;</span>name<span>&#34;</span></span> <span>key</span><span><span>=</span><span>&#34;</span>name<span>&#34;</span></span> <span>/&gt;</span></span>
    <span>:</span> <span><span><span>&lt;</span>input</span> <span>placeholder</span><span><span>=</span><span>&#34;</span>phone<span>&#34;</span></span> <span>key</span><span><span>=</span><span>&#34;</span>phone<span>&#34;</span></span> <span>/&gt;</span></span><span>}</span></code></pre><p>Another option is replacing the ternary with two separate <code>&amp;&amp;</code> blocks. When <code>key</code> is absent, React falls back to the index of the item in <code>children</code> array, so putting distinct elements into distinct positions works just as well as an explicit key:</p><pre data-language="jsx"><code><span>{</span>mode <span>===</span> <span>&#39;name&#39;</span> <span>&amp;&amp;</span> <span><span><span>&lt;</span>input</span> <span>placeholder</span><span><span>=</span><span>&#34;</span>name<span>&#34;</span></span> <span>/&gt;</span></span><span>}</span>
<span>{</span>mode <span>!==</span> <span>&#39;name&#39;</span> <span>&amp;&amp;</span> <span><span><span>&lt;</span>input</span> <span>placeholder</span><span><span>=</span><span>&#34;</span>phone<span>&#34;</span></span> <span>/&gt;</span></span><span>}</span></code></pre><p>Conversely, if you have <em>very different</em> conditional props on the same logical element, you can split the branching into two separate JSX tags for readability with <em>no</em> penalty:</p><pre data-language="jsx"><code>
<span><span><span>&lt;</span><span>Button</span></span>
    <span>aria-busy</span><span><span>=</span><span>{</span>loading<span>}</span></span>
    <span>onClick</span><span><span>=</span><span>{</span>loading <span>?</span> <span>null</span> <span>:</span> submit<span>}</span></span>
<span>&gt;</span></span><span>
    </span><span>{</span>loading <span>?</span> <span><span><span>&lt;</span><span>Spinner</span></span> <span>/&gt;</span></span> <span>:</span> <span>&#39;submit&#39;</span><span>}</span><span>
</span><span><span><span>&lt;/</span><span>Button</span></span><span>&gt;</span></span>

<span>{</span>loading
    <span>?</span> <span><span><span>&lt;</span><span>Button</span></span> <span>aria-busy</span><span>&gt;</span></span><span><span><span>&lt;</span><span>Spinner</span></span> <span>/&gt;</span></span><span><span><span>&lt;/</span><span>Button</span></span><span>&gt;</span></span>
    <span>:</span> <span><span><span>&lt;</span><span>Button</span></span> <span>onClick</span><span><span>=</span><span>{</span>submit<span>}</span></span><span>&gt;</span></span><span>submit</span><span><span><span>&lt;/</span><span>Button</span></span><span>&gt;</span></span><span>}</span>

<span>{</span>loading <span>&amp;&amp;</span> <span><span><span>&lt;</span><span>Button</span></span> <span>key</span><span><span>=</span><span>&#34;</span>submit<span>&#34;</span></span> <span>aria-busy</span><span>&gt;</span></span><span><span><span>&lt;</span><span>Spinner</span></span> <span>/&gt;</span></span><span><span><span>&lt;/</span><span>Button</span></span><span>&gt;</span></span><span>}</span>
<span>{</span><span>!</span>loading <span>&amp;&amp;</span> <span><span><span>&lt;</span><span>Button</span></span> <span>key</span><span><span>=</span><span>&#34;</span>submit<span>&#34;</span></span> <span>onClick</span><span><span>=</span><span>{</span>submit<span>}</span></span><span>&gt;</span></span><span>submit</span><span><span><span>&lt;/</span><span>Button</span></span><span>&gt;</span></span><span>}</span>
</code></pre><hr/><p>So, here are my top tips for using JSX conditionals like a boss:</p><ul><li><code>{number &amp;&amp; &lt;JSX /&gt;}</code> renders <code>0</code> instead of nothing. Use <code>{number &gt; 0 &amp;&amp; &lt;JSX /&gt;}</code> instead.</li><li>Don’t forget the parentheses around or-conditions: <code>{(cond1 || cond2) &amp;&amp; &lt;JSX /&gt;}</code></li><li>Ternaries don’t scale beyond 2 branches — try an <code>&amp;&amp;</code> block per branch, or extract a function and use <code>if / else</code>.</li><li>You can’t tell if <code>props.children</code> (or any interpolated element) actually contains some content — CSS <code>:empty</code> is your best bet.</li><li><code>{condition ? &lt;Tag props1 /&gt; : &lt;Tag props2 /&gt;}</code> will <em>not</em> remount <code>Tag</code> — use unique <code>key</code> or separate <code>&amp;&amp;</code> branches if you want the remount.</li></ul></div></div>
  </body>
</html>
