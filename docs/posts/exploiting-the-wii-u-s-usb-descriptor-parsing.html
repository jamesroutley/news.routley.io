<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://garyodernichts.blogspot.com/2022/06/exploiting-wii-us-usb-descriptor-parsing.html">Original</a>
    <h1>Exploiting the Wii U&#39;s USB Descriptor parsing</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-5367474975821152339" itemprop="description articleBody">
<p>In this write-up we&#39;re going to take a look at exploiting the Wii U&#39;s USB Host Stack. Over the past few months I spent a lot of time reverse engineering USB related things on the Wii U. </p><h2>Overview</h2><p>The Wii U contains an ARM chip running an embedded operating system called <a href="https://wiiubrew.org/wiki/IOSU">IOSU</a>. IOSU consists of several modules which contain device drivers and other components not handled on the main PPC CPU.</p><p>The most relevant module for this write-up is IOS-USB, which handles all USB devices which can be plugged into the external USB ports.</p><p>IOS-USB contains UHS which is the <b>U</b>SB <b>H</b>ost <b>S</b>tack of the Wii U.</p><h3>USB Descriptor parsing</h3><p>Every USB device contains several descriptors which describe different information about the device to the host. All devices have a device descriptor and several configuration descriptors. Each descriptor has a size and type field.</p><p>After plugging in a device, UHS starts with reading and parsing the device descriptor. The device descriptor contains things like the USB version, the Vendor and Product ID of the device, and the amount of config descriptors.</p><p>After that all configuration descriptors are read from the device. The configuration descriptor is a bit more complicated than the device descriptor. Instead of having a fixed sized, the configuration can have any size specified in the <span>wTotalLength</span><span> field of the configuration descriptor. After the configuration descriptor, multiple </span>interface and endpoint<span> descriptors are appended to the configuration.</span></p><p><span>UHS will load up to 32 configurations into memory, and then parses all interface and endpoint descriptors of the first configuration.</span></p><h2>The bug</h2><p>To read the full configuration into a buffer, UHS starts with reading the first 9 bytes of the configuration, which contains the configuration descriptor. It then allocates a buffer from the heap with the total configuration size, which is specified in the <span>wTotalLength</span><span> field. </span>The full configuration is now read into that buffer.</p><p>Since all USB descriptor values are stored as little-endian and the ARM is running as big-endian, some descriptor fields need to be byteswapped.</p><p>To byteswap all of the endpoint descriptor fields of the configuration the following code is used. This code usually also parses interface descriptors, which has been left out for simplicity.</p>

<p>The loop goes over all endpoint descriptors and byteswaps them until <span>wTotalLength</span><span> is reached. </span>So, <i>where&#39;s the bug?</i></p><p>UHS doesn&#39;t verify that <span>wTotalLength</span><span> matches the total length of the initially read config descriptor, which was used to determine the buffer size. This means the total length can be larger than the actual configuration, which allows pointing endpoint descriptors past the configuration buffer, causing out of bounds byteswaps.</span></p><h2><span>Exploiting a 16-bit byteswap</span></h2><p><span>So can that byteswap be exploited?</span></p><p><span>There are several devices which make emulating a USB device possible. Microcontrollers like the Raspberry Pi Pico allow full control over descriptors when </span>emulating a USB client<span>. </span></p><p><span>To perform a byteswap of an endpoint descriptor the second byte of the descriptor needs to be </span><span>0x05</span><span>, which is the endpoint descriptor type. Additionally the first byte cannot be 0, otherwise UHS will never break out of the byteswap loop and gets stuck since the offset never increases.</span></p><p><span>If these conditions are met, bytes 4 and 5 (</span><span>wMaxPacketSize</span><span>), containing the maximum packet size of that endpoint, will be swapped.</span></p><p><span>After looking for days for structures stored after the configuration on the heap which meet these conditions, I gave up. This seems extremely hard, if not impossible to exploit.</span></p><p><span>After working on other projects for a while, I decided to give this another try. This time I decided to look directly at the heap block headers. </span></p><h3>Heap Blocks</h3><p>Each allocated block on the heap has a header which contains a magic value, the size of the block, a pointer to the previous block, and a pointer to the next block.</p><div><div><table><tbody><tr><td><a href="https://blogger.googleusercontent.com/img/a/AVvXsEhPDnTjr-ExeTop5--xLEqdhSF8I1KcbvQlzjeS6womxSP3EYUy7ejyicz1Tuztkvkz7YBjT8hOjwOrtDEGpVKhAk9Hbdt-f2cU5b3lN6R9cu_95dqYaZvTVWClZqzNyxUiTeqWsmsd60N1EUFuoWkT2RnYaHj6JC0OwBe5To8g8CrSnVybPqxmWkfW"><img alt="" data-original-height="120" data-original-width="1324" height="58" src="https://blogger.googleusercontent.com/img/a/AVvXsEhPDnTjr-ExeTop5--xLEqdhSF8I1KcbvQlzjeS6womxSP3EYUy7ejyicz1Tuztkvkz7YBjT8hOjwOrtDEGpVKhAk9Hbdt-f2cU5b3lN6R9cu_95dqYaZvTVWClZqzNyxUiTeqWsmsd60N1EUFuoWkT2RnYaHj6JC0OwBe5To8g8CrSnVybPqxmWkfW=w640-h58" width="640"/></a></td></tr><tr><td>Example of a free heap block</td></tr></tbody></table><br/></div><p>The magic also indicates the state of this heap block. The following magic values are used:</p></div><div><ul><li><span>0xBABE0000: </span><span>Free block</span></li><li><span>0xBABE0001: </span><span>Allocated outer block</span></li><li><span>0xBABE0002: </span><span>Allocated inner block</span></li></ul><p>The magic never contains a <span>0x05</span><span>, the size is rounded to </span><span>0x10</span><span> and we can only allocates blocks up to </span><span>0x10000</span><span> bytes in size, so we can&#39;t use any of those fields.</span></p></div><p><span>What if the previous pointer contains a </span><span>0x05</span><span> though? This would swap 2 bytes in the next pointer! Ideally the previous pointer should look something like </span><span>XXXX05XX</span><span>, this would cause the 2 bytes in the middle of the next pointer (byte 4 and 5 of the endpoint descriptor) to be swapped.</span></p><p><span>To achieve this we need to prepare the heap a bit. IOSU will merge consecutive free blocks, so we need a way to create &#34;free holes&#34; in the heap.</span></p><p><span>By placing an endpoint descriptor right at the end of the first configuration and setting the total size accordingly, we can swap 2 bytes in the magic of the next heap block.</span></p><p><span><table><tbody><tr><td><a href="https://blogger.googleusercontent.com/img/a/AVvXsEgK1M89AMr72p-Zj3AO-mu3BXbw-UDQnXx7NiW72_e_f0CDxpW8XJ0_LJi_Zsah-OA_HRiEgwibmmKHaYY0wo-tUPHPQdX2OxgTfkcit97kGYV0zVVle3l1fWyCpVcf-PcHKdO1ECtsyYcJwoAsm5321egvRk6z2RHnhr3afUS_DpxnDrYAx0GhSaX7"><img alt="" data-original-height="303" data-original-width="1541" height="126" src="https://blogger.googleusercontent.com/img/a/AVvXsEgK1M89AMr72p-Zj3AO-mu3BXbw-UDQnXx7NiW72_e_f0CDxpW8XJ0_LJi_Zsah-OA_HRiEgwibmmKHaYY0wo-tUPHPQdX2OxgTfkcit97kGYV0zVVle3l1fWyCpVcf-PcHKdO1ECtsyYcJwoAsm5321egvRk6z2RHnhr3afUS_DpxnDrYAx0GhSaX7=w640-h126" width="640"/></a></td></tr><tr><td>Example of swapping the magic of the next configuration buffer</td></tr></tbody></table></span><span><span>0xBEBA0001</span><span> instead of </span></span><span>0xBABE0001</span><span>. Since the heap state is checked once the block is freed from the heap, this block can no longer be freed.</span></p><p><span>We can have up to 32 configurations, which will be allocated before parsing the first configuration. If we carefully choose various sizes for these descriptors we can create the ideal heap header. </span></p><p><span>Let&#39;s connect a device which uses 6 configurations. By controlling the size of buffer 1 we can make sure the address of buffer 2 contains a <span>0x05</span><span>. </span></span>This way we can create an ideal heap layout.</p><p><span>After disconnecting our emulated device, the heap looks like this:</span></p><p><span><table><tbody><tr><td><a href="https://blogger.googleusercontent.com/img/a/AVvXsEi_QyG5wUHwyLYiN2n1qZv_tsMG9fzPj8JzK2sU9ol1jZncA-LlrnMqGcDWyqzEkV9SSEkBiSZcJHlH6VbJMkRx7h4xo6saJ80ZEcgI0vX9mYSE-lZfEHbBe9sd2iPuhnBVpU0B6NL3AjapGyoU11l3c-0XlgNmcZiMZJi7Ti21Dw1cWqsNAoZmZpCe"><img alt="" data-original-height="296" data-original-width="1743" height="108" src="https://blogger.googleusercontent.com/img/a/AVvXsEi_QyG5wUHwyLYiN2n1qZv_tsMG9fzPj8JzK2sU9ol1jZncA-LlrnMqGcDWyqzEkV9SSEkBiSZcJHlH6VbJMkRx7h4xo6saJ80ZEcgI0vX9mYSE-lZfEHbBe9sd2iPuhnBVpU0B6NL3AjapGyoU11l3c-0XlgNmcZiMZJi7Ti21Dw1cWqsNAoZmZpCe=w640-h108" width="640"/></a></td></tr><tr><td>The ideal heap layout</td></tr></tbody></table>So what if we reconnect the emulated device and point an endpoint descriptor to the </span><span>prev</span><span> pointer, which now matches the </span><span>XXXX05XX</span><span> pattern</span><span>?</span></p><p><span><table><tbody><tr><td><a href="https://blogger.googleusercontent.com/img/a/AVvXsEiDRbHmHK42jSPcCG5gvK67n5rEm2lkhL_SBDmuDJV6TJh7mf_LuZe29yzuJdqvGE6zS3ahjrl7KSvAxtGG6_VzpV9wqGLoPVNctcxJs6N03iGMiXlFA9Rb3HiMtVM8xMOOl_lsagWDBuTNpMDNZxczIQPnwWVB8i3omaAAHkXT_8z0GrEKE3Ntl4GI"><img alt="" data-original-height="336" data-original-width="1530" height="140" src="https://blogger.googleusercontent.com/img/a/AVvXsEiDRbHmHK42jSPcCG5gvK67n5rEm2lkhL_SBDmuDJV6TJh7mf_LuZe29yzuJdqvGE6zS3ahjrl7KSvAxtGG6_VzpV9wqGLoPVNctcxJs6N03iGMiXlFA9Rb3HiMtVM8xMOOl_lsagWDBuTNpMDNZxczIQPnwWVB8i3omaAAHkXT_8z0GrEKE3Ntl4GI=w640-h140" width="640"/></a></td></tr><tr><td>Swapping the next pointer of buffer 4</td></tr></tbody></table>The </span><span>next</span><span> pointer gets swapped and now points <b>into the middle of the heap!</b></span></p><p><span>If we now reconnect the device, the next configuration buffer gets allocated in the middle of the heap, as long as what would be the </span><span>size</span><span> field of the memory </span><span>next</span><span> is pointing to</span><span> is large enough. </span>By controlling the size of buffer 5 we can control the address of the free heap block, allowing us to roughly control the next pointer.</p><p><span>This now a</span><span>llows overwriting existing buffers on the heap.</span></p><div><p><span>My initial idea was to point the next block directly into the stack, which is also allocated on the heap. Since UHS </span><span>memset</span><span>s the buffer after allocation, this would only result in a crash though. So I needed to find some other structure on the heap to overwrite.</span></p><h3><span>UhsCtrlXferMgr</span></h3><p><span>As the name implies, the &#34;UHS Control Transfer Manager (<span>UhsCtrlXferMgr</span>)&#34; manages transfers on the control endpoint of the device. In front of the transfer manager on the heap, is a large buffer where transfers on the control endpoint (Endpoint 0) are transferred to, called <span>pEp0DmaBuf</span>. If we point the <span>next</span><span> pointer into this buffer, we can overwrite the transfer manager after it.</span></span></p><p><span><span>Since each configuration can &#34;only&#34; be </span><span>0xffff</span><span> bytes in size, we&#39;ll use 2 buffers to reach the transfer manager.</span></span></p><p><span><table><tbody><tr><td><a href="https://blogger.googleusercontent.com/img/a/AVvXsEgRU3r_24S5M9mt_Yjgv4f4yR7dWeTpZikJNnxiniHhfe_0tBzHq0RPU_YF8asAp0sR5CoWJd4ADzpKJVCOcclPRoI2eYHwWV6W8Il-JpJhLZQhXZ1DKr-lRR8yErmsigjoVUJDFSJxpCBROffpizBmWuNNwdsfFj-ASQ9maEscOwBov7Neqzy_SrPW"><img alt="" data-original-height="282" data-original-width="992" height="182" src="https://blogger.googleusercontent.com/img/a/AVvXsEgRU3r_24S5M9mt_Yjgv4f4yR7dWeTpZikJNnxiniHhfe_0tBzHq0RPU_YF8asAp0sR5CoWJd4ADzpKJVCOcclPRoI2eYHwWV6W8Il-JpJhLZQhXZ1DKr-lRR8yErmsigjoVUJDFSJxpCBROffpizBmWuNNwdsfFj-ASQ9maEscOwBov7Neqzy_SrPW=w640-h182" width="640"/></a></td></tr><tr><td>Overwriting UhsCtrlXferMgr</td></tr></tbody></table></span></p></div><p><span>It is now possible to start a transfer into the stack and get kernel code execution using a ROP chain.</span></p><p><span>The data for the kernel code can simply be placed into one of the existing config descriptors which have been allocated on the heap.</span></p><h2>Conclusion</h2><p>So what am I calling this?</p><p><b>UDPIH</b> (pronounced like &#34;mud pie&#34; without the m), which stands for <b>U</b>SB <b>D</b>escriptor <b>P</b>arsing <b>I</b>s <b>H</b>ard, since apparently it&#39;s really hard to properly parse these descriptors :P</p><p>It is now possible to get IOSU code execution by simply plugging in a Raspberry Pi Pico/Zero or similar device into the console. This even works before the PPC side has booted properly, allowing for things like CBHC bricks to be fixed.</p><p>Since everything using IOS-USB will shift around the heap, UDPIH roughly works after you can see the &#34;Wii U&#34; logo. This is right after IOS-NET and IOS-FS have registered their drivers for USB Mass storage and USB Ethernet, and before the Wii U menu has booted and queries connected hard drives.</p><p>Additionally to UDPIH itself, I&#39;ll also release a simple recovery menu which allows to fix several bricks from the IOSU side.</p><div><p>Hope this is useful for someone :)</p><h3>Links:</h3></div>

</div></div>
  </body>
</html>
