<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.orioledb.com/blog/orioledb-bridged-indexes">Original</a>
    <h1>Bridged Indexes in OrioleDB: architecture, internals and everyday use?</h1>
    
    <div id="readability-page-1" class="page"><div id="__blog-post-container"><p>Since version beta10 OrioleDB supports building indexes other than B-tree. Bridged indexes are meant to support these indexes on OrioleDB tables.</p>
<h3 id="1-why-orioledb-needs-a-bridge"><strong>1. Why OrioleDB needs a “bridge”</strong><a href="#1-why-orioledb-needs-a-bridge" aria-label="Direct link to 1-why-orioledb-needs-a-bridge" title="Direct link to 1-why-orioledb-needs-a-bridge">​</a></h3>
<p>OrioleDB stores its table rows inside a B-tree built on a table primary key and keeps MVCC information in an undo log, so it can’t simply plug PostgreSQL’s existing Index Access Methods (GiST, GIN, SP-GiST, BRIN, …) into that structure. While PostgreSQL&#39;s Index Access Methods:</p>
<ul>
<li>reference a 6-byte <strong><code>ctid</code></strong> (block number and offset in the heap) -- not a logical key;</li>
<li>keep <strong>every live version</strong> of a row in the index, leaving visibility checks to the executor;</li>
<li>support <strong>inserts only in the index</strong> and rely on <code>VACUUM</code> for physical deletion.</li>
</ul>
<p>OrioleDB indexes, in contrast, are MVCC-aware: they point to the rows via <strong>primary-key values</strong> and support logical updates/deletes directly in the index. To remain heap-free while still allowing users build the rich ecosystem of non-B-tree indexes, OrioleDB introduces a <strong>bridge index layer</strong>.</p>
<p><img decoding="async" loading="lazy" alt="Illustration of a bridge index" src="https://www.orioledb.com/assets/images/bridge-index-34d0932d96a0f08c43f9cac8a896c842.png" width="1422" height="518"/></p>
<!-- -->
<h3 id="2-how-the-bridge-works-under-the-hood"><strong>2. How the bridge works under the hood</strong><a href="#2-how-the-bridge-works-under-the-hood" aria-label="Direct link to 2-how-the-bridge-works-under-the-hood" title="Direct link to 2-how-the-bridge-works-under-the-hood">​</a></h3>
<ol>
<li><strong>Virtual <code>iptr</code> column</strong> -- an incrementally increasing &#34;index pointer&#34; automatically added to the table. T<strong>he new value</strong> of iptr is assigned each time any column referenced by a bridged index is updated, ensuring the pointer remains stable for the indexed data.</li>
<li><strong>Bridge index</strong> -- a lightweight secondary index that maps <code>iptr</code> to primary-key value. It behaves like a normal OrioleDB secondary B-tree, except it doesn&#39;t use undo log for MVCC.</li>
<li><strong>PostgreSQL indexes (GIN/GiST/...)</strong> are built <strong>on the <code>iptr</code> values instead of ctids</strong>, so their structure stays compatible with the IndexAM API. During scans, the engine looks up iptr, translates it through the bridge index, and then fetches the row by primary key.</li>
<li><strong>The vacuum process</strong> collects stale <code>iptr</code>-s that are not visible to any snapshot, and asks the underlying IndexAM to clean up; then physically deletes the same pointers from the bridge index.</li>
</ol>
<p>The result is a <em>tri-level</em> lookup path: <strong>IndexAM index → <code>iptr</code> → bridge index → primary-key fetch</strong>, giving full AM compatibility at the cost of one extra index hop.</p>
<p><img decoding="async" loading="lazy" alt="Illustration of a bridge index querying" src="https://www.orioledb.com/assets/images/bridge-index-query-77d067d395fbc6b428d4eb5f9b342955.png" width="1070" height="388"/></p>
<h3 id="3-everyday-usage"><strong>3. Everyday usage</strong><a href="#3-everyday-usage" aria-label="Direct link to 3-everyday-usage" title="Direct link to 3-everyday-usage">​</a></h3>
<h4 id="31-automatic-bridging-the-it-just-works-path"><strong>3.1 Automatic bridging (the &#34;it just works&#34; path)</strong><a href="#31-automatic-bridging-the-it-just-works-path" aria-label="Direct link to 31-automatic-bridging-the-it-just-works-path" title="Direct link to 31-automatic-bridging-the-it-just-works-path">​</a></h4>
<p>The first time you create a non-B-tree index on an OrioleDB table, the extension implicitly adds the bridge:</p>
<div><div><pre tabindex="0"><code><span><span></span><br/></span><span><span></span><span>CREATE</span><span> </span><span>INDEX</span><span> blog_post_title_gin_idx</span><br/></span><span><span>    </span><span>ON</span><span> blog_post </span><span>USING</span><span> GIN </span><span>(</span><span>title</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><br/></span></code></pre></div></div>
<p>Behind the scenes OrioleDB:</p>
<ol>
<li>Adds the hidden column <code>iptr</code> to the <code>blog_post</code> table,</li>
<li>Builds a bridge index mapping <code>iptr</code> to primary key,</li>
<li>Builds the user-requested <code>blog_post_title_gin_idx</code> on the <code>iptr</code>s.</li>
</ol>
<p>So, for most applications <strong>you don’t have to do anything special</strong>.</p>
<h4 id="32-manual-control-when-you-need-it"><strong>3.2 Manual control (when you need it)</strong><a href="#32-manual-control-when-you-need-it" aria-label="Direct link to 32-manual-control-when-you-need-it" title="Direct link to 32-manual-control-when-you-need-it">​</a></h4>
<p>You may prepare the bridge layer on the table in advance to save time during adding an index. Also, you can remove the bridge layer if it’s not needed anymore.</p>
<div><div><pre tabindex="0"><code><span><span></span><br/></span><span><span></span><span>ALTER</span><span> </span><span>TABLE</span><span> blog_post </span><span>SET</span><span> </span><span>(</span><span>index_bridging</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span></span><br/></span><span><span></span><span>ALTER</span><span> </span><span>TABLE</span><span> blog_post RESET </span><span>(</span><span>index_bridging</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><br/></span></code></pre></div></div>
<p>You can even ask OrioleDB <strong>not</strong> to use the native B-tree implementation for testing purposes:</p>
<div><div><pre tabindex="0"><code><span><span></span><br/></span><span><span></span><span>CREATE</span><span> </span><span>INDEX</span><span> blog_post_title_idx</span><br/></span><span><span>    </span><span>ON</span><span> blog_post </span><span>USING</span><span> </span><span>btree</span><span>(</span><span>title</span><span>)</span><span></span><br/></span><span><span>    </span><span>WITH</span><span> </span><span>(</span><span>orioledb_index </span><span>=</span><span> </span><span>off</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><br/></span></code></pre></div></div>
<p>Commands and options are documented in the <a href="http://localhost:3000/docs/usage/getting-started" target="_blank" rel="noopener noreferrer">Getting Started guide</a>.</p>
<h3 id="4-performance-notes"><strong>4. Performance notes</strong><a href="#4-performance-notes" aria-label="Direct link to 4-performance-notes" title="Direct link to 4-performance-notes">​</a></h3>
<ul>
<li><strong>Expect an extra hop.</strong> A bridged plan adds roughly one more B-tree lookup per matched row. For complex AMs (e.g. pg_vector ANN search) the overhead is usually negligible; for indexes with cheaper lookups (e.g. GiST or GIN) you are expected to see some overhead.</li>
<li><strong>Updates pay twice.</strong> Similar to the heap tables, changing a column that participates in a bridged index bumps the <code>iptr</code>, which means <em>inserting</em> a new entry into every bridged IndexAM and into the bridge index. The good thing is that changing a column that participates in only OrioleDB built-in B-tree indexes, no overhead is expected.</li>
</ul>
<h3 id="5-conclusion"><strong>5. Conclusion</strong><a href="#5-conclusion" aria-label="Direct link to 5-conclusion" title="Direct link to 5-conclusion">​</a></h3>
<p>OrioleDB’s bridged indexes give you the best of both worlds:</p>
<ul>
<li><strong>Modern, MVCC-aware, index-organized storage</strong> for the table itself;</li>
<li><strong>Full access to Postgres’ rich IndexAM ecosystem</strong> — GIN for full-text, GiST for spatial, pgvector’s HNSW, RUM, BRIN and more — without rewriting those extensions.</li>
</ul>
<p>While a third-party index rewritten to be a native OrioleDB index will always be faster, the bridge means you no longer have to choose between raw speed and the extension you love. Try it out in your dev database, measure the overhead on <em>your</em> workload and keep an eye on the fast-moving roadmap — 2025 is shaping up to be a big year for OrioleDB.</p></div></div>
  </body>
</html>
