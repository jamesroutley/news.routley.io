<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.vjeux.com/2025/javascript/birth-of-prettier.html">Original</a>
    <h1>Birth of Prettier</h1>
    
    <div id="readability-page-1" class="page"><div>
				
<p>React Conf is around the corner and it&#39;s been almost 10 years since Prettier was released. I figured it would be a good time to recount the journey from its early days to now.</p>



<p>This is the story of how the &#34;Space vs Tabs Holy War&#34; ended, not through one side winning over the other but instead a technological invention making it the underlying source of tensions no longer being a thing.</p>



<figure><img src="https://blog.vjeux.com/wp-content/uploads/2025/10/image.png" alt=""/></figure>



<h3>Back Story</h3>



<h4>School time</h4>



<p>In order to understand my state of mind when I worked on Prettier, we need to go back in time when I did my college at EPITA, a French school dedicated to Computer Science.</p>



<p>When you start, you are given a PDF with the list of formatting rules you need to obey when turning your coding assignments. Not following them is extremely punishing where for each failure you are losing 2 points out of a grade over 20. So 10 formatting issues and you&#39;re getting a 0!</p>



<p>This taught people the hard way that they need to train themselves to format their code properly. As you can expect, I tried to code my way out of this and implement such a linter with fixers myself so that I wouldn&#39;t have to deal with it.</p>



<p>But it turns out that writing what is commonly called a linter + formatter for the C programming language was way out of my depth for a first year student. So I ended up learning these formatting rules but it engraved in the back of my mind the need for a way to solve this problem automatically.</p>



<h4>Facebook time</h4>



<p>A few years later, I joined Facebook and my first interaction with an awesome engineer there included a bunch of formatting style changes. Turns out the guidelines I learned at school was not the same ones that Facebook was using.</p>



<figure><img src="https://blog.vjeux.com/wp-content/uploads/2025/10/image-1.png" alt=""/></figure>



<p>It felt like a pretty bad setup for everyone involved. Yuan Tian had to spend her valuable time going through all my code and pointing out all the formatting issues (eslint wasn&#39;t yet created!). I then had to go back and fix everything.</p>



<p>At first I thought this was pointless but then a few months later a new person joined the team and I found myself in the same situation in reverse because having a different style convention really did make the code harder to read and understand!</p>



<h3>Potential Solutions</h3>



<p>One thing I&#39;ve learned is that if there&#39;s a big problem that a lot of people faced, many people must have tried to solve it. So I passively investigated over the years what were all these approaches and why they didn&#39;t succeed.</p>



<h4>Lint fixers</h4>



<p>The way most people approached this problem is by figuring out what rule you are breaking (eg: shouldn&#39;t be a space before a parenthesis) and writing custom logic to fix it.</p>



<p>This worked well for some rules, like spaces around operators, but didn&#39;t for the ones that revolve around line length. It also wasn&#39;t guaranteed that the operations converged so you could have rules fixing one and breaking another.</p>



<h4>gofmt</h4>



<p>When go was released, they published a formatter along with the programming language which they used for all their code and examples. As a result, it became the way most people wrote go.</p>



<p>For the first time it felt like there was a light at the end of the tunnel. But even though it was released in 2009, it didn&#39;t seem like any other programming language got such a similar treatment 8 years later in 2017 when Prettier was released.</p>



<p>Maybe they could only pull it off because they started with it...</p>



<h4>Dartfmt</h4>



<p>In 2015, dartfmt made the rounds with a blog post titled &#34;<a href="https://journal.stuffwithstuff.com/2015/09/08/the-hardest-program-ive-ever-written/">The Hardest Program I‚Äôve Ever Written&#34;</a>. This was the first time a proper formatter got traction on an existing popular language.</p>



<p>This gave me hope. But reading through the post, I also disagreed with the way the problem was approached. The idea is to create a scoring function for the &#34;prettyness&#34; of a given AST output and find the output that maximizes this function.</p>



<p>While it makes sense from a coding perspective, this feels terrible from a human perspective as there&#39;s no clear explanation as to why a specific code is printed the way it is and there&#39;s likely going to be big swings that can happen with small variations of input if two very far away branches have a similar score.</p>



<p>It&#39;s also not immediately clear to me how to build that scoring function. And as the article says, it&#39;s very hard to optimize as you may need to explore a huge amount of possible states.</p>



<h4>All the JavaScript formatters</h4>



<p>There&#39;s been a long list of people building JavaScript formatters since gofmt came out but none of them got any strong adoption. I was very curious to understand why so I reached out to their authors.</p>



<p>The good thing I learned is that I could just send cold emails to these authors. They spent months of their life working on this so they were super happy when somebody reach out to geek out on the subject.</p>



<p>After talking to many people, I came to the conclusion that we are facing a very different flavor of project. Most programming projects in the wild follow a Pareto curve where you can build 80% of the project in 20% of the time, ship and then iterate to improve on the last 20%.</p>



<p>But the problem with formatters is that you can&#39;t ship if it&#39;s doing the right thing 80% of the time. This would mean that every 5 lines it format things in a weird way. People are very sensitive to the way their code is written so this won&#39;t fly.</p>



<p>Most of the projects failed not because the approach wasn&#39;t sound but because the authors were not willing to commit to build the 99.999% before the project could be viable.</p>



<h3>Winter Break</h3>



<p>In December of 2016, two people I know, James Long who evangelized React thanks to his amazing blog posts and did great work on the Firefox devtools and Pieter Vanderwerff who built a lot of the JavaScript infrastructure at Facebook both started working on a JavaScript pretty printer.<br/></p>



<h4>Testing</h4>



<p>One of the most annoying part of working on such project is to have a good test setup. The usual way to set it up was to write manual tests for each examples. You put the input as a string within a test file, you need to make sure you escape it properly, run the printer and paste the output.</p>



<p>Unfortunately it&#39;s super annoying to have to do this for many tests and if you change the formatter output it may &#34;break&#34; a lot of tests and you need to manually repeat this process. This is a huge motivation killer.</p>



<p>Thankfully a few months earlier, Jest introduced &#34;snapshot testing&#34; support which was the perfect fit for this problem. With that, it was possible to just write js files in the test folder and all the &#34;output&#34; would be auto-generated.</p>



<p>When you run all the test suite again, you see the differences in formatting and you can figure out whether it&#39;s what you intended or not. With one command you can update all the output if it is.</p>



<p>Not only did it help with the person coding but it was invaluable for the reviewer. The pull request now shows all the differences that this change would do. This let us welcome contributions to the formatter as we could see all the changes. If nothing looks off, we can just merge it without fear.</p>



<h4>Friendly Competition</h4>



<p>I got super excited but I still didn&#39;t actually know how to build a pretty printer, so I instead took on the role of a &#34;cheerleader&#34;. I&#39;ve learned that motivation is a key aspect of having an ambitious project go through.</p>



<p>I setup the testing infra and created a leaderboard for how many AST nodes both their implementation supported, updating it every day and getting both to compete on who is going to support all of them first üôÇ</p>



<p>I also kept feeding real world code to both their implementation and categorize + prioritizing all the weird looking code and giving it to them to fix it.</p>



<p>This was super fun seeing so much progress done so quickly! This is for these kind of moments that I love being in tech.</p>



<h4>End of the break</h4>



<p>Speed of execution wasn&#39;t just a nice to have but a necessity for this project. As I mentioned, the shape of the project requires the huge long tail to be implemented before it would be usable. My goal was to get as much progress done as possible while both of them were able to dedicate time to it.</p>



<p>When the break was over, both of them decided to get back to their real job and to shelve this side project. At this point, the 80% was done and working, I could see the problem that has been bothering me for years being solved...</p>



<p>So I decided to drop everything I had on my plate at work and focus full time on this. As you can expect, my manager wasn&#39;t super happy about it but this felt like a now or never kind of situation, I used all my acquired political capital at the company to make that bet.</p>



<h3>Prettier</h3>



<p>First order of business was to make a choice on which of the two projects to build on-top of. In reality this was an easy decision. Pieter&#39;s project was built in Reason, a dialect of OCaml. While I&#39;ve written my fair share of OCaml at school, this was still not a language I was particularly comfortable with and it would drastically reduce the ability for people in the JavaScript ecosystem to contribute. So I went with James Long&#39;s project which was written in JavaScript.</p>



<h4>Open Source</h4>



<p>James Long did all the work to open source and used his incredible writing abilities to publish a blog post called &#34;<a href="https://archive.jlongster.com/A-Prettier-Formatter">A Prettier JavaScript Formatter</a>&#34; which got people really excited about the idea of the project and kick started its growth.</p>



<p>I ended up contracting James Long for him to work on it for a few more weeks but my inexperience going through the contracting process at Facebook made it a bad experience for him. On the bright side, this led me to discover Open Collective which is amazing at handling money exchanges for open source projects.</p>



<h4>Algorithm</h4>



<p>At this point, I still had no idea how the printer actually worked. I know it was based on the paper called &#34;<a href="https://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf">A prettier printer</a>&#34; from Philip Wadler but even today this paper reads like gibberish to me as it is written in Haskel and full of scientific verbiage.</p>



<p>The good news is that it&#39;s actually extremely elegant and powerful. There are just two concepts: a list of &#34;instructions&#34; with string literal, group, indent, softline, hardline... and an algorithm that takes these instructions along with a line length which outputs the final string. I wrote a <a href="https://blog.vjeux.com/2017/javascript/anatomy-of-a-javascript-pretty-printer.html">small blog post that explains how it works</a> if you are interested.</p>



<p>The mind blowing thing to me is that we&#39;ve been able to print all of JavaScript, CSS, HTML, Ruby... <a href="https://github.com/prettier/prettier/blob/main/commands.md">with only 23 commands</a>. This is a testament to the brilliancy of the design.</p>



<h4>Strategy</h4>



<p>At this point we had the first 80%, now we needed to do the next 19.999%. My approach was to &#34;go into a submarine&#34;, make as much progress as possible and once it would be ready for prime time, &#34;go back to the surface&#34; and get people to adopt it.</p>



<p>In 6 months, I shipped 500 commits, which is around 3 commits a day. The amazing thing with Open Source is that I only did half of the commits of the project during that period! 31 other people contributed and built many things that I would likely not been able to do.</p>



<figure><img src="https://blog.vjeux.com/wp-content/uploads/2025/08/image.png" alt=""/></figure>



<h4>Correctness</h4>



<p>The #1 thing I was concerned about is that the formatter would output code that actually executed the same as the original. You can have the prettiest code but if it introduces bugs, nobody will use the software.</p>



<p>I tried many approach to test for correctness. The obvious one was checking that the AST would be the same but the issue is that adding or removing parenthesis would sometimes change the AST, but it was required to print it the way we wanted to. So had to do a lot of massaging and it wasn&#39;t clear if it actually properly tested correctness anymore.</p>



<p>What ended up being the best indicator is a simple idempotency test:</p>



<blockquote><p>prettier(input) == prettier(prettier(input))</p></blockquote>



<p>It&#39;s not intuitive why it actually works but the vast vast majority of all the correctness issues we&#39;ve ever found broke this test.</p>



<p>The good news is that I had a massive JavaScript codebase within Facebook to play with. So for these 6 months I would wake up in the morning, run this test on the entire codebase, eye ball to see the most common issue, fix it and repeat. It was a grind but after about 4 months, we finally got it down to 0 correctness issues!</p>



<h4>Formatting Decisions</h4>



<p>The thing I was most anxious going into the project was figuring out how to deal with everyone&#39;s extremely strong opinions on formatting. People called &#34;Space vs Tabs Holy War&#34; for a reason.</p>



<p>My mindset going into it was that I would use my own judgement for printing most of the code and provide the minimum number of options so that I wouldn&#39;t have to deal with the most controversial takes.</p>



<p>So we ended up with a small set for tabs vs spaces, semicolons vs no semi, single quotes vs double quotes and a few smaller ones. While it would have been amazing to not have any options, I feel like this sidestepped the most likely distraction that would have killed the project.</p>



<p>For all the other decisions, the strategy I used was to grep the giant Facebook codebase to see what was the most used variant and use that one in case I needed to make a choice between two reasonable ways to print the same AST structure.</p>



<p>This also gave me some data driven way to justify my choices instead of just &#34;I think it looks better&#34;. Being able to communicate with people in this project removing the preferences was a key part of how to remain sane.</p>



<p>It&#39;s a really weird feeling to think that I ended up defining how most of JavaScript code looks like in the world these days.</p>



<h3>Printing Difficulties</h3>



<p>There&#39;s a reason why nobody had solved the problem before, we ran into many types of code that were not trivial to print.</p>



<h4>Comments</h4>



<p>Comments have become the bane of my existence. They can be inserted literally anywhere, they have bunch of different forms, you sometimes want them to extend past 80 columns but not always... The code for this is <a href="https://github.com/prettier/prettier/blob/73bdfb49eb18a657a54d35ae3e6bf0e7a582d187/src/language-js/comments/handle-comments.js#L51">a huge list of special cases</a> that doesn&#39;t fully work.</p>



<p>If I were to reimplement prettier, I would change the way we handle them. Most JavaScript parsers are AST parsers where the A stands for Abstract. Instead I would go for a CST parser where the C stands for Concrete. It gives access to the list of all the tokens including comments. This is how we did it for the <a href="https://github.com/skiplang/skip/blob/b63d2de7ed50a20519ba22b63b0a8a3d95728a65/src/tools/printer/printer.sk#L97C3">programming language Skip</a> which solved it elegantly. </p>



<h4>Chained Methods</h4>



<p>The other one is chained.method().calls(). The reason for this one is more subtle. In practice for most of the language constructs, they have a single &#34;intent&#34;. So you need to figure out what the meaning of it is and print it accordingly.</p>



<p>The issue with chaining is that people have used it to mean a ton of different things. People have built entire new languages out of it for example for building SQL queries, it is used to paper over the lack of namespaces, doing tons of various operations with jQuery...</p>



<p>As a result, we need 500 lines of code and a <a href="https://github.com/prettier/prettier/blob/73bdfb49eb18a657a54d35ae3e6bf0e7a582d187/src/language-js/print/member-chain.js#L398-L403">bunch of heuristics</a> just for this single node type.</p>



<h4>Expanded last argument</h4>



<p>If you put a function definition or an object as the last argument of a function call, you want to kind of inline it but also expand it. It doesn&#39;t neatly fall into the primitives that the core algorithm gives us.</p>





<div><div><pre><span>const</span> response <span>=</span> await fetch<span>(</span><span>&#34;https://example.org/post&#34;</span><span>,</span> <span>{</span> <span>&lt;--</span>
  method<span>:</span> <span>&#34;POST&#34;</span><span>,</span>
  body<span>:</span> JSON.<span>stringify</span><span>(</span><span>{</span> username<span>:</span> <span>&#34;example&#34;</span> <span>}</span><span>)</span><span>,</span>
<span>}</span><span>)</span><span>;</span></pre></div></div>






<p>We hacked it up with &#34;conditionalGroup&#34; primitive which is unfortunately <code>O(n¬≤)</code> so this is the only part of prettier that can actually spend a really large amount of time if you nest many of these. Thankfully this isn&#39;t a pattern that people actually do.</p>



<p>It haunted me so much that when I built the Skip pretty printer, I ended up finding a much more <a href="https://github.com/skiplang/skip/blob/b63d2de7ed50a20519ba22b63b0a8a3d95728a65/src/runtime/prelude/stdlib/debug/Doc.sk#L80">elegant solution using the notion of a &#34;marker&#34;</a>. If anyone reading is building a pretty printer based on the same infrastructure, I highly recommend using it instead.</p>



<h4>Object literals</h4>



<p>Like chained methods, object literals is used in a lot of different contexts. Unfortunately, there wasn&#39;t a heuristic that actually worked well for all the use cases.</p>



<p>We have a really important principle with prettier which is that we should print the code regardless of how it was formatted in the first place. This makes it so that however badly (or differently) the input was formatted, it&#39;ll always print the same way.</p>



<p>Sadly, we had to break this rule for object literals with a slight twist. If there&#39;s a new line anywhere in an object, we&#39;ll always print its expanded form. This means that if you want to shrink an object if it fits 80 columns, you&#39;ll have to manually remove all the empty lines.</p>



<p>To this day, nobody that I know about has come up with a better alternative unfortunately. If you have ideas please let me know!</p>



<h4>No-semi</h4>



<p>At that time there was a big movement around not putting semi-colons at the end of lines. While this worked most of the time, some of the edge cases were very subtle but completely changed the meaning of the code. For example this is how the following seemingly innocuous code would be evaluated:</p>





<div><div><pre>let start<span>,</span> end<span>;</span>
¬†
let range <span>=</span> getRange<span>(</span><span>)</span>
<span>[</span>start<span>,</span> end<span>]</span> <span>=</span> range
<span>// How it actually is executed by the language:</span>
<span>// let range = (getRange()[(start, end)] = range);</span>
¬†
<span>// How we print it with nosemi in prettier:</span>
let range <span>=</span> getRange<span>(</span><span>)</span>
<span>;</span><span>[</span>start<span>,</span> end<span>]</span> <span>=</span> range</pre></div></div>






<p>In order to get around, the convention was to put a semicolon at the start of the next line. Finding out how to make this happen was actually pretty complicated as we needed to figure out what is the last character we would print in the previous line and the first of the current line and put a semicolon if they would trigger issues.</p>



<p>One of the great thing about prettier is that it would reformat whatever code you pass in to a human readable variant. So if you see prettier do weird things with your code, at this point it&#39;s way more likely that your code triggered some JavaScript parsing edge case than prettier being wrong.</p>



<h3>Internal Rollout</h3>



<h4>Product Manager Shape</h4>



<p>One thing I&#39;ve learned through this experience is that I needed to learn how to shape shift based on what the project needed. At first it required me being a coding machine but then a lot more of coordination was required.</p>



<p>Within Meta, we needed to build all the integrations. It turns out having a working printer is only a piece of the puzzle. We needed to have IDE integration such that it would format on save, a linter and CI integration such that you couldn&#39;t ship incorrectly formatted code, a way to upgrade existing files in batch...</p>



<p>I ended up coding only a small part of these integrations but instead directed many people into the best way to do it.</p>



<h4>Options</h4>



<p>While prettier itself should support various options to help increase adoption, I wanted a single set of options within the company. That came with a challenge where it&#39;s really hard to enforce in a big company where people are one pull request away from changing the options.</p>



<p>The strategy I used was to figure out how to line up the incentives such that using a different set of options was orders of magnitude more annoying than not.</p>



<p>Prettier is used in two main places: CI and the IDE. I made it so that both would read their options from a different place with a different rollout schedule. CI would read the options from source control. The IDE would read the options from the IDE extension.</p>



<p>So if you wanted your own set of options, you&#39;d need to add a coordination system so that both would read from the same place, which was not trivial to do and would require you to work on a foreign codebase.</p>



<p>A few people that weren&#39;t using the standard IDE did rollout their own options but when they started working with more people within the company eventually ended up aligning.</p>



<h4>Granularity</h4>



<p>There were a lot of debates internally as to how we&#39;re going to roll it out. So far all the formatting fixes were rolled out only on lines changed by the person modifying the code. While we did implement this mode in prettier, it meant losing a lot of the value proposition.</p>



<p>So we needed to figure out a way to ship it such that it wouldn&#39;t update a bunch of unrelated lines when people modified a file. The solution we came up with was to add a @format annotation in the first comment of the file. If it&#39;s there, then the file is <strong>always</strong> formatted, both in the IDE and with a pre-commit hook to enforce it.<br/></p>



<h4>Rollout</h4>



<p>With that strategy planned, the rollout process was a script that took a list of files, would run the check mode to make sure prettier didn&#39;t change the meaning of the code, run the formatter and add the @format annotation to the top of the file.</p>



<p>My only rule with this rollout is that I would personally not reformat any single line of the codebase. The rationale behind it is that I wanted the printed code to be so good that people didn&#39;t need to be forced into it but instead they&#39;d want to do it on their own accord.</p>



<p>This strategy worked really well, after 6 months we got 50% of our giant codebase converted and after a year 75%. At that point it was clear that the value proposition was there and I organized a &#34;Getting to 100%&#34; event where a bunch of volunteers updated the rest of the codebase.</p>



<p>Up until then we were at 0 production issues caused by prettier (as far as I&#39;m aware) but we got the first and only one... Turns out it was caused by the script that added @format to the header, it accidentally reformatted the comment and a polyfill would no longer be bundled in.</p>



<p>The fact that we were able to do meaningful change to every JavaScript and CSS file at the company only causing one issue is one of my proudest engineering moment.</p>



<h4>Upgrades</h4>



<p>The setup described above worked really well for getting adoption but ended up being a nightmare to upgrade prettier. Since we were still pretty early in the evolution of prettier, we would update the way we print commonly written code pretty frequently.</p>



<p>As a result, anytime we needed to upgrade prettier, we would need to update a large percentage of the files in the codebase. Because we had a commit hook that prevents landing code that is not properly formatted, we needed to do it very quickly to avoid preventing people from shipping code.</p>



<p>So I ended up spending many weekends (where the chances of merge conflicts are the lowest) sending gigantic pull requests, hitting all sorts of limits of our source control and continuous integration infrastructure in the process.</p>



<p>Thankfully as time passed the amount of large changes in prettier&#39;s format went dramatically down and our infra got a lot better so it stopped becoming a big issue.</p>



<p>One interesting side effect is that I changed the most number of lines of code company wide that year and got my name on the &#34;blame&#34; for most of the JavaScript files that existed at that time. So over the years I kept getting random people or scripts pinging me about code I had no idea about!</p>



<h3>Solving the problem</h3>



<h4>Format on Save</h4>



<p>I completely underestimated the profound impact that format on save feature would have. I saw it as a nice to have feature but it ended up being the defining factor for the project.</p>



<p>The mindset of the programmer at the time was that you write your code mostly formatted and then you&#39;ve got this annoying linter that tells you that you did all these things wrong and you need to spent time correcting.</p>



<p>At the beginning people were doing the same thing with prettier and got a slight productivity boost as prettier would fix the issues. But then people realized that they could just write code in whatever shape, press save and it would automagically format itself.</p>



<h4>Ending the Tabs vs Spaces Holy War</h4>



<p>During a programmer career, you&#39;ve likely written millions of open curly bracket and based on your coding style put a space, newline or nothing before. If you do it wrong, you&#39;ve got linters or coworkers annoyed at you.</p>



<p>The big realization is that if you do something many many many times, at some point it becomes part of your identity. So programmers, due to the nature of the work have become fundamentally attached with how they format their code.</p>



<p>As a result, they have all sorts of opinions that are strongly held and end up being very spicy debates such as tabs vs spaces, semicolon vs nosemi... But the magic of prettier is that you no longer need to do this repetitive task anymore, so people cared a lot less.</p>



<p>The other aspect is that changing the formatting style used to be a huge endeavor, you not only needed to update the codebase but also rewire the brain of all the engineers working on it. But with prettier, you just change the config, send a big diff and you&#39;re done.</p>



<p>So at the end of the day, the way the war ended was not by picking a winner but lowering the stakes so people just stopped caring.</p>



<h3>Maintenance</h3>



<p>While the early days are the exciting stories people want to hear, the reality is that Prettier is now one of the foundation upon which most of the JavaScript and CSS code is written in the world. This requires people to maintain this project.</p>



<h4>Open Collective &lt;3</h4>



<p>After a few months somebody suggested that I open up a way for people to donate to the project. I signed up prettier on <a href="https://www.opencollective.com">opencollective.com</a> and added a link to the GitHub repo.</p>



<p>After a few years the project had received $50k of donations. I was very unsure on how to use that money. On one hand, this was a significant amount of money, but on the other hand, it was far from being enough to hire anyone competent to work on it.</p>



<p>My first attempt was to ask all the people that had significant contributions and give them a slice of that. But almost all of them declined. Either because they didn&#39;t feel justified to earn money on contributions that happened a few years prior at this point, or because the hassle of handling taxes on that money transfer were not worth it.</p>



<h4>Paid Maintainers</h4>



<p>A few years later, there were 2 people that kept contributing and were running the show. After doing the math of the amount of donations we receive, we could pay them $1.5k / month each. This is not enough to live off of but a not insignificant amount either.</p>



<p>So we started <a href="https://prettier.io/blog/2022/01/06/prettier-begins-paying-maintainers">paying Fisker Cheung and Sosuke Suzuki</a> and have been for the past many years. They&#39;ve been doing an amazing job at maintaining the project, supporting latest versions of the various JavaScript standards and language extensions (TypeScript, Flow) that came up over the years.</p>



<h4>Stressful Situation</h4>



<p>I have to be honest, this part of the project has caused me a lot of stress. Even though Prettier is used by the entire industry, the project has received a grand total of $200k of donations over its lifetime.</p>



<p>In the past few years, the $3k * 12 = $36k a year of maintenance costs have been more than the natural flow of money coming in. So I had to spend time fund raising.</p>



<p>The challenge is that there&#39;s not a clear value proposition. The way the world works is that you pay money in exchange for something. Since Prettier itself is free, people are not paying for that.</p>



<h4>Money Sources</h4>



<p>There are a few things that people are willing to pay for. One is advertising as the Prettier website and GitHub repo are getting a fair amount of traffic. But a lot of the project interested didn&#39;t feel like something I would want to put my name behind.</p>



<p>The second common one is doing consulting related to the project. In practice Prettier is very easy to install or integrate with your environment (by design) so there isn&#39;t a real need there. There could be work for supporting new language features but that&#39;s a very niche use case.</p>



<p>We tried unconventional avenues, the team at Sentry ran a swag store for Prettier tshirts but it was a lot of logistics for not a lot of revenue in the end. I also quickly looked at getting grants but the amount of paperwork needed for likely not getting any money didn&#39;t feel like a good use of time.</p>



<p>Big shoutout to Facebook / Meta that has been critical paying for my salary and contributing significantly to the Open Collective.</p>



<h4>Call for money</h4>



<p>If you as an individual or your company want to support Prettier maintainers, please send money to <a href="https://opencollective.com/prettier">opencollective.com/prettier</a>. The reality is that you&#39;re not going to get anything concrete for that donation except for the knowledge that you kept a critical piece of infrastructure running.<br/></p>



<p>If you have ideas on how to get it funded, please let me know. Or maybe there&#39;s a tech billionaire or VC reading this post that will do a one million dollar donation ¬Ø\_(„ÉÑ)_/¬Ø</p>



<h3>Aftermath</h3>



<p>My initial assumption was that I would down the submarine and only after I go back up would the adoption really kickstart. But thanks to the power of open source and adventurous people, people started adopting prettier extremely quickly.</p>



<figure><img src="https://blog.vjeux.com/wp-content/uploads/2025/08/image-1.png" alt=""/><figcaption><br/></figcaption></figure>



<p>By 2021, <a href="https://2021.stateofjs.com/en-US/other-tools/#utilities">83% mentioned that they were using Prettier</a> in the State of JS survey. After that, the people running the survey stopped asking because they felt like everyone was using it and it didn&#39;t provide much value.</p>



<h4>Other Languages</h4>



<p>≈Åukasz Langa who worked at Facebook at the time saw my work on prettier and built an equivalent for Python called Black. It eventually got adopted by The Python Software Foundation who is the organization behind Python.</p>



<p>Prettier started with JavaScript but then expanded to cover languages in the web space like CSS, JSON, HTML, YAML, Markdown, GraphQL... and many of their popular variants.</p>



<p>Nowadays, it&#39;s pretty rare to see a mainstream programming language not have a formatter that&#39;s widely adopted by its community.</p>



<h4>The End</h4>



<p>This is pretty insane to me where we went from formatting being one of the most controversial engineering topic to the problem being truly solved in only the span of a few years.</p>



<p>It feels surreal, even after all these years, that I got to be part of the solution and ended up deciding how a large part of the code written in the world looks like.</p>



<p>Now that this chapter is closed, onto solving the next big problem faced by engineers!</p>
			  
			</div></div>
  </body>
</html>
