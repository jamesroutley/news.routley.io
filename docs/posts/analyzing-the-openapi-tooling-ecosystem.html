<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://modern-json-schema.com/analyzing-the-openapi-tooling-ecosystem">Original</a>
    <h1>Analyzing the OpenAPI Tooling Ecosystem</h1>
    
    <div id="readability-page-1" class="page"><div id="post-content-parent"><div id="post-content-wrapper"><p>Welcome to a new series of posts that will take you on a visual journey through the OpenAPI Specification (OAS) and its tooling ecosystem!</p>

<p>As part of the efforts to design OAS 3.2 and 4.0 “<a target="_blank" href="https://www.openapis.org/blog/2023/12/06/openapi-moonwalk-2024">Moonwalk</a>”, I wanted to figure out how different sorts of tools work with the OAS. Moonwalk is an opportunity to re-think everything, and I want that re-thinking to make it easier to design, implement and maintain tools. We also want 3.2 to be an incremental step towards Moonwalk, so figuring out what improvements we can make to align with the needs of tools while maintaining strict compatibility with OAS 3.1 is also important.</p>
<p>To do that, we need to understand how the OAS-based tooling ecosystem works, and how the various tools relate to the current OAS version, 3.1. This eventually led me to create two groups of diagrams: One about the architecture of OAS-based tools, and one about the many objects and fields defined by the OAS and how they relate to what tools need to do. But this was not a simple process!</p>
<h2 id="heading-oas-tools-do-stuff">OAS tools do… stuff?</h2>
<p>I was surprised at how difficult it was to find patterns in tool design and OAS usage. I thought I could go look at how tools were categorized on sites that list them, figure out what each category needs, and see how that aligns with the current and proposed future OAS versions. I was wrong. Looking the OpenAPI Initiative’s own <a target="_blank" href="https://tools.openapis.org/">tools site</a> reveals categories that often overlap and tools that don’t map cleanly to categories.</p>
<p>One problem is that many “tools” aren’t so much OAS implementations as they are applications that include some OAS-based functionality. So maybe “tool” or “application” isn’t the right granularity for this research. Really, there are different tasks that can be done with an <a target="_blank" href="https://learn.openapis.org/specification/structure.html">OpenAPI Description (OAD)</a>, and each OAS-based tool, application, or library does at least one such task.</p>
<h2 id="heading-what-if-one-tool-did-it-all">What if one tool did it all?</h2>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1726866122677/93bdf607-059e-46da-9e27-e369cc679df3.webp?auto=compress,format&amp;format=webp" alt="Meme generated based on Allie Brosh&#39;s &#34;DO ALL THE THINGS!&#34; image from Hyperbole and a Half, captioned &#34;IMPLEMENT ALL THE TASKS!!!&#34; with the figure holding the OpenAPI logo in her upraised hand"/></p>
<p>I started thinking about all of the tasks, and how they relate to each other. The goal is not to <em>really</em> create a monolithic mega-tool architecture. Not all tasks happen on the same system, or at the same time in the development process. But it would help to understand which tasks directly relate to each other, which don’t, and what the interfaces among them ought to be.</p>

<p>After several iterations with valuable feedback from the regular OAS working group calls, here is what I came up with (based on OAS 3.1 plus ideas for 3.2 and Moonwalk):</p>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1726874852962/65312adf-7408-419f-b4cb-6bf566b716e0.webp?auto=compress,format&amp;format=webp" alt="A diagram with three labeled regions: &#34;Parsing Libraries&#34; across the bottom quarter, &#34;OAD Tools&#34; occupying the right quarter of the region above that, and &#34;API Tools&#34; occupying the rest of the image; the color key is explained in the next section"/></p>
<p>The first thing to notice is the that this “idealized architecture” breaks down into three main purposes or functional areas:</p>
<ul>
<li><p><strong>Parsing libraries</strong>: The foundation on which all other tools are built</p>
</li>
<li><p><strong>OAD tools</strong>: These work with <a target="_blank" href="https://learn.openapis.org/specification/structure.html">OpenAPI Descriptions</a> and their constituent documents</p>
</li>
<li><p><strong>API tools</strong>: Which work with the API that the OAD describes but (mostly) aren’t concerned with the mechanics of OAD documents and references</p>
</li>
</ul>
<h2 id="heading-color-coding-and-accessibility">Color coding and accessibility</h2>
<p>Before we look at the three purposes, let’s talk about how I’m using color in these diagrams:</p>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1726621444272/609037a4-5752-412a-a76a-593e95877ea4.webp?auto=compress,format&amp;format=webp" alt="A labeled grid of the colors named in the paragraph below the image"/></p>
<p>The colors here, named “pale grey”, “light yellow”, “pink”, “light cyan”, “pear”, “olive”, “light blue”, “orange”, and “mint”, are <a target="_blank" href="https://personal.sron.nl/~pault/#fig:scheme_light">a set designed by Paul Tol</a> to work well with dense grids of information labeled with black text, regardless of color vision ability.</p>
<p>I’ll always use these names (minus the “pale” and “light” qualifiers) to talk about the colors in these diagrams. Every diagram will include the color names so that no one has to guess which color is which, and all diagrams use the same colors to mean the same general things:</p>
<ul>
<li><p><strong>Gray</strong>: Documents and metadata</p>
</li>
<li><p><strong>Yellow</strong>: References and implicit connections</p>
</li>
<li><p><strong>Pink</strong>: Parsing</p>
</li>
<li><p><strong>Cyan</strong>: Interface modeling</p>
</li>
<li><p><strong>Pear</strong>: Runtime data validation</p>
</li>
<li><p><strong>Olive</strong>: Extended validation</p>
</li>
<li><p><strong>Blue</strong>: Data encoding</p>
</li>
<li><p><strong>Orange</strong>: HTTP modeling</p>
</li>
<li><p><strong>Mint</strong>: API documentation</p>
</li>
</ul>
<p>As we compare diagrams about tools with diagrams about the spec (which you’ll see in future posts), we will hope that consistent use of color will show clear alignment between these two perspectives. Wherever they do not, we probably have some work to do.</p>
<h2 id="heading-parsing-libraries">Parsing libraries</h2>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1726869119572/ab1dc05f-23f5-4f8d-a169-02ed6678d475.webp?auto=compress,format&amp;format=webp" alt="The &#34;Parsing Libraries&#34; region of the previous diagram, containing three horizontal blocks:  A grey block &#34;Document Interface&#34; across the entire bottom, a yellow &#34;URI Reference and Implicit Connection Resolver&#34; block above it, and an &#34;API Description API (ADA)&#34; block above and wrapping the yellow block, extending most of the width except the far left.  Arrows enter from the top edge pointing to the pink block except the left-most one to the grey block."/></p>
<p>The most fundamental functional area, “Parsing Libraries”, consists of a stack of wide blocks stretching across the bottom. From the color code, you can see that these blocks deal with the low-level document interface (grey), resolving references and implicit connections (yellow), and parsing (pink). “Implicit connections” is a term we’re introducing in OAS 3.0.4 and 3.1.1 that encompasses things like mapping Security Requirement Object keys to Security Scheme Object names under the <code>securitySchemes</code> field of the Components Object.</p>
<p>Every tool, application, or library that works with OADs or the APIs that they describe has to parse OADs and do at least some resolution of internal connections. While some references can be preprocessed out, others cannot, nor can any of the implicit connections. We’ll explore these challenges, as well as the interactions between the grey, yellow, and pink blocks, more deeply in future posts.</p>
<h3 id="heading-the-api-description-api-ada">The API Description API (ADA)</h3>
<p>For now, the most important thing is that the upper pink block, labeled “API Description API (ADA)”, is intended to provide a clean interface to the parsed and resolved OAD that insulates tools from the complexities of document managing and referencing. This ADA would be somewhat akin to <a target="_blank" href="https://dom.spec.whatwg.org/">the DOM</a>. There are, however, fundamental differences between OADs and web pages, so the analogy is not exact.</p>
<p>We’ve decided that we want to have an ADA in Moonwalk, and it’s an open question as to whether it would be worthwhile to start defining it in 3.x. The main concern is whether 3.x tools (or at least parsing libraries) would start supporting it. If you have thoughts on that concern, I’d like to hear from you!</p>
<h2 id="heading-oad-tools">OAD tools</h2>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1726939103049/fe73382e-c497-41cb-8f88-aaa11101bd74.webp?auto=compress,format&amp;format=webp" alt="The &#34;OAD Tools&#34; region from the first diagram.  Pink boxes labeled &#34;OAD Generator&#34;, &#34;OAD Editor&#34;, &#34;OAD Linter, &#34;OAD Validator&#34;, &#34;Format Translator&#34;, &#34;Arazzo Processor&#34;, and &#34;Overlay Processor&#34; have pink arrows out that merge downwards, then split to a pink &#34;Semantic Access&#34; and grey &#34;Structural Access&#34; arrows, both exiting the image at the bottom"/></p>
<p>The first change I would make to sites that classify OpenAPI tools would be to separate the tools that work with OADs from the tools the work with APIs.</p>
<p>These are fundamentally different use cases and mindsets, and they have different requirements when it comes to interacting with OADs. The blocks in this area are colored pink because they are primarily concerned with the structure of the OAD. The description semantics inform what can or should be done with the OAD, but it is the OAD rather than the described API that is the focus of these tools.</p>
<p>The left column includes OAD editors (including IDE plugins), validators, linters, and generators (producing an OAD from code). The right column includes tools connecting the OAD with other specifications, including <a target="_blank" href="https://spec.openapis.org/">the OpenAPI Initiative’s Arazzo and (forthcoming) Overlays specifications</a>. The right column also contains translators from other formats such as RAML, or from formats that offer an alternative syntax that “compiles” down to an OAD.</p>
<p>Semantic operations, such as a linting rule that applies to every Response Object, no matter its location, benefit from <em>semantic access</em> via the ADA (pink downward arrow). Structural operations, such as an overlay that inserts a field into each object matching a <a target="_blank" href="https://www.rfc-editor.org/rfc/rfc9535.html">JSON Path</a> applied to a specific document (or anything that requires writing to documents), benefit from <em>structural access</em> via the underlying document interface (grey downward arrow).</p>
<h2 id="heading-api-tools">API Tools</h2>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1726872418804/6fab8355-3050-426e-881b-385ec76c1805.webp?auto=compress,format&amp;format=webp" alt="&#34;API Tools&#34;: Flow of HTTP requests/responses through tasks.  Major boxes left to right after an &#34;end user &#34;emoji: &#34;API Documentation&#34; (mint), &#34;Data Interface Modeler and Validator&#34; (cyan), &#34;Data Encoder and Decoder&#34; (blue), &#34;HTTP Parser and Serializer&#34; (orange).  Arrows connecting boxes across the top (client) and bottom (server) show request/response flow, with cyan &#34;API Client Code&#34; and &#34;API Server Code&#34; (where the arrows U-turn) labels to the left of the cyan box.  Each box has an arrow down towards the ADA.  See later images for details of boxes above each main box, and flow labels on right-side client and left-side server arrows."/></p>
<p>Now that we’ve accounted for shared parsing tasks and OAD-specific tools, we’re ready to examine how the OAS supports working with an API. We’ll start on the left edge where our hypothetical end user is looking at an interactive documentation site that includes a test interface to send requests and display the resulting responses.</p>
<p>While our discussion will follow the progress of a request on the client side, the steps are reversed to parse, decode, and validate the request on the server, and then run again on the server to validate, encode, and assemble a response, which is parsed, decoded, validated, and displayed to the end user on the client side.</p>
<h3 id="heading-api-documentation-mint">API Documentation (mint)</h3>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1726942251208/babb475c-c3f9-4c6c-a833-af7b4029abfc.webp?auto=compress,format&amp;format=webp" alt="&#34;API Documentation&#34; (mint): upper boxes &#34;Markdown Rendering&#34;, &#34;PDF Rendering&#34;, &#34;HTML Rendering&#34;; flow: &#34;input to request&#34; out, &#34;response output&#34; in."/></p>
<p>Documentation is produce by mint-colored blocks that use the ADA to walk through the whole OAD, organize the information for human consumption, and render it to the end user in some format. Different formats could be handled as plugins in an extensible architecture, as shown above the main mint-colored block.</p>
<p>The API documentation block is the only one that looks at every part of the OAD that is visible through the ADA. Separating docs processing into its own block allows other blocks to ignore the fields that <em>only</em> impact documentation. This might influence how the ADA is designed.</p>
<p>If the documentation is interactive, then it would incorporate an interface generated by the next block that can take the appropriate session or operation input and render the results. The mint blocks are concerned with rendering that interface, but not with defining it.</p>
<h3 id="heading-interface-modeling-and-validation-cyan-pear-and-olive">Interface Modeling and Validation (cyan, pear, and olive)</h3>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1726942240345/0471a999-6f37-470b-a66c-2ebcba606e11.webp?auto=compress,format&amp;format=webp" alt="&#34;Data Interface Modeler and Validator&#34;: upper boxes &#34;CLI Interface&#34;, &#34;Web Form Generation&#34;, &#34;Client Code Generation&#34;, &#34;Server Code Generation&#34; (all cyan), &#34;Data Validation&#34; (pear), and &#34;Extended Validation&#34; (olive); flow: (client) &#34;validated data&#34; out, &#34;decoded data&#34; in; (server) &#34;handler input&#34; out, u-turn to &#34;handler output&#34; in."/></p>
<p>Following the arrow to the right, we reach the API client code. The boundary between the three differently-colored types of blocks within this larger area is somewhat ambiguous, and varies depending on the programming language(s) and types of tools being used.</p>
<p><strong><em>Interface definition (cyan)</em></strong></p>
<p>Cyan represents the static code-level (as opposed to HTTP-level) interface to the API. The diagram shows how there might be several form factors for this interface stacked in the left column above the main cyan block: Code libraries on the client and server, or a web or CLI interface for interactive documentation or manual testing. Such an interface might be very generic, or it might be custom-generated with elaborate static type-checking.</p>
<p><strong><em>Runtime data validation (pear)</em></strong></p>
<p>The pear-colored module is for runtime data validation, verifying constraints that are not inherent in the interface’s type-checking but only depend on the data passed to that interface. It&#39;s mostly synonymous with JSON Schema validation, although not entirely as we&#39;ll see when we color code individual fields in the next post.</p>
<p><strong><em>Extended validation (olive)</em></strong></p>
<p>The olive-colored module is for validation such as <code>readOnly</code> that requires additional context about how the data is being used, which often builds on the runtime validation by using <a target="_blank" href="https://www.ietf.org/archive/id/draft-bhutton-json-schema-01.html#name-collecting-annotations">annotations</a>.</p>
<p><strong><em>A confusing boundary</em></strong></p>
<p>As noted, the boundary between these three colors is ambiguous. <a target="_blank" href="https://modern-json-schema.com/json-schema-is-a-constraint-system">JSON Schema is not a data definition system</a>, and was not designed with a clear division between static data types (cyan) and runtime constraints (pear) in mind. Languages support differing type-checking paradigms, tools have variable levels of support for classes or other complex structures, and &#34;code generation&#34; can be taken to the extreme of generating a custom function for each JSON Schema.</p>
<p>Additionally, <code>format</code> values are sometimes handled as static types (cyan), sometimes as runtime validation (pear), and sometimes as annotation-based validation (olive).</p>
<p>All of this overlap and ambiguity is a major challenge for tooling vendors, an one we’ll examine in detail in a future post.</p>
<h3 id="heading-data-encoding-and-decoding-blue">Data Encoding and Decoding (blue)</h3>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1726942225013/bb3564a6-c528-4092-88f5-c29ca973d4ab.webp?auto=compress,format&amp;format=webp" alt="&#34;Data Encoding and Decoding&#34;: upper boxes &#34;JSON&#34;, &#34;YAML&#34;, &#34;XML&#34;, &#34;Plain Text&#34;, &#34;JSON Seq&#34;, &#34;Multipart&#34;, &#34;URL Encoded&#34; labeled &#34;media types&#34;; &#34;URL Path Variables&#34;, &#34;Cookies&#34;, &#34;RFC9110 Headers&#34;, &#34;Structured Headers&#34;, &#34;Other Headers&#34; labeled &#34;grammars&#34;;  flow: (client) &#34;encoded data&#34; out, &#34;parsed data&#34; in; (server) &#34;decoded data&#34; out, &#34;validated data&#34; in."/></p>
<p>The code interface is defined in terms of JSON-compatible data structures. Encoding such a structure as an <code>application/json</code> request body is trivial. But validated data also needs to be mapped into other media types, and into various bits and pieces governed by other rules such as ABNF grammars.</p>
<p>In this diagram, I&#39;m proposing a modular, extensible system to handle these encodings or translations. API innovation moves faster than specification development, and the OAS doesn’t currently have a good way to accommodate emerging data formats like JSON streams. We also haven’t ever addressed things like HTTP headers with complex structure.</p>
<p>Defining an extensible interface, where mappings to various targets could be defined in a <a target="_blank" href="https://github.com/OAI/OpenAPI-Specification/discussions/3771">registry</a> and supported with a plug-in architecture, would dramatically increase the flexibility of the OAS tooling ecosystem, as well as its responsiveness to innovation. It could also help us get the substantial complexity of the data encoding fields, which we’ll start to explore in the next post, under control.</p>
<h3 id="heading-http-modeling-orange">HTTP Modeling (orange)</h3>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1726942210619/725bec4e-97b3-4acf-95bb-4c1038f0a0cc.webp?auto=compress,format&amp;format=webp" alt="&#34;HTTP Parser and Serializer&#34;: upper boxes &#34;Auth Server Interactions&#34;, &#34;Requests&#34;, &#34;Responses&#34;, &#34;Runtime Expressions&#34;, &#34;Links&#34;, &#34;Callbacks&#34;, &#34;Webhooks&#34;; flow: u-turn &#34;http request/response in/out&#34; network transit on the right; (server) &#34;parsed data&#34; out and &#34;encoded data&#34; in on the left."/></p>
<p>Finally, we reach the orange block that is takes the bits and pieces of encoded data and assembles them into HTTP messages (or parses them back out). We see on our diagram how data passes through this module as a request to be constructed, then back through on the server side where the request is parsed, handled, and returned as a response.</p>
<p>This area breaks down into three sub-areas: Server configuration (which provides the URL prefix for HTTP calls), security configuration (which might involve HTTP interactions with an auth server), and the actual API operations.</p>
<p>Much of this HTTP parsing and serialization can be handled by standard libraries, which can also help define us the exact border with the data encoding blocks. Our goal is to organize the OAS aspect of things, not to re-invent the wheel of HTTP and related technologies.</p>

<p>The next step is to analyze OAS 3.1 and the likely 3.2 proposals in detail and correlate the Objects and fields with this idealized architecture. That starts to show where we have mismatches between the spec and tools, and what we might want to do about them, which will be the subject of the next post.</p>
<p>However, one aspect of this diagram is already driving real work: This past week’s Moonwalk working group call featured a <a target="_blank" href="https://learn.openapis.org/glossary.html">TSC</a> member demo-ing a small ADA proof-of-concept. The idealized architecture may be theoretical, but its impacts on the future of the OAS are already very real.</p>
</div></div></div>
  </body>
</html>
