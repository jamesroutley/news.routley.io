<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.fosskers.ca/en/blog/cl-windows">Original</a>
    <h1>Cross-Compiling Common Lisp for Windows</h1>
    
    <div id="readability-page-1" class="page"><div><p>I recently enabled Windows support for my <a href="https://github.com/fosskers/raylib/">Raylib</a> bindings library and a game of mine that uses it, <a href="https://github.com/fosskers/raylib/">Aero Fighter</a>. The process was surprisingly smooth.</p><p>This article describes how to:</p><ul><li>cross-compile C code for Windows from Linux</li><li>install a Windows-based SBCL with <a href="https://www.winehq.org/">Wine</a></li><li>run that SBCL as your REPL in Linux-based Emacs</li><li>load <code>.dll</code> files into a Lisp image</li><li>produce a <code>.exe</code> executable of a Lisp program</li></ul><h2 id="org5f9823">Cross-compiling C</h2><p>We can easily produce Windows executables from Linux with no extra configuration just by using the correct compiler toolchain. On Arch Linux:</p><pre>pacman -S mingw-w64-toolchain</pre><p>Then, given the following C code:</p><div><pre><code><span id="1"><a href="#1"></a><span>#include </span><span>&lt;stdio.h&gt;</span></span>
<span id="2"><a href="#2"></a></span>
<span id="3"><a href="#3"></a><span>int</span> main<span>()</span> <span>{</span></span>
<span id="4"><a href="#4"></a>  printf<span>(</span><span>&#34;Hello, World!</span><span>\n</span><span>&#34;</span><span>);</span></span>
<span id="5"><a href="#5"></a>  <span>return</span> <span>0</span><span>;</span></span>
<span id="6"><a href="#6"></a><span>}</span></span></code></pre></div><p>we can compile and run it like so:</p><pre>&gt; x86_64-w64-mingw32-gcc hello.c
&gt; wine ./a.exe
Hello, World!</pre><h3 id="org58c836">Linking to a DLL</h3><p>Feel free to skip this if you not interested in linking to C code.</p><p>Assuming you have a local clone of Raylib, it can be cross-compiled by setting the following within its <code>src/Makefile</code>:</p><pre>RAYLIB_LIBTYPE   ?= SHARED
HOST_PLATFORM_OS ?= LINUX
PLATFORM_OS      ?= WINDOWS
CC = x86_64-w64-mingw32-gcc
AR = x86_64-w64-mingw32-ar</pre><p>Then a call to <code>make PLATFORM_OS=WINDOWS</code> will produce a <code>.dll</code> file. Now, given this sample C:</p><div><pre><code><span id="1"><a href="#1"></a><span>#include </span><span>&#34;raylib.h&#34;</span></span>
<span id="2"><a href="#2"></a></span>
<span id="3"><a href="#3"></a><span>int</span> main<span>(</span><span>void</span><span>)</span> <span>{</span></span>
<span id="4"><a href="#4"></a>  <span>const</span> <span>int</span> screenWidth <span>=</span> <span>800</span><span>;</span></span>
<span id="5"><a href="#5"></a>  <span>const</span> <span>int</span> screenHeight <span>=</span> <span>450</span><span>;</span></span>
<span id="6"><a href="#6"></a></span>
<span id="7"><a href="#7"></a>  InitWindow<span>(</span>screenWidth<span>,</span> screenHeight<span>,</span> <span>&#34;raylib example 01 - Windows&#34;</span><span>);</span></span>
<span id="8"><a href="#8"></a>  SetTargetFPS<span>(</span><span>60</span><span>);</span></span>
<span id="9"><a href="#9"></a></span>
<span id="10"><a href="#10"></a>  <span>while</span> <span>(!</span>WindowShouldClose<span>())</span> <span>{</span></span>
<span id="11"><a href="#11"></a>    BeginDrawing<span>();</span></span>
<span id="12"><a href="#12"></a>    ClearBackground<span>(</span>RAYWHITE<span>);</span></span>
<span id="13"><a href="#13"></a>    DrawText<span>(</span><span>&#34;Saluete!&#34;</span><span>,</span> <span>190</span><span>,</span> <span>200</span><span>,</span> <span>20</span><span>,</span> LIGHTGRAY<span>);</span></span>
<span id="14"><a href="#14"></a>    EndDrawing<span>();</span></span>
<span id="15"><a href="#15"></a>  <span>}</span></span>
<span id="16"><a href="#16"></a></span>
<span id="17"><a href="#17"></a>  CloseWindow<span>();</span></span>
<span id="18"><a href="#18"></a></span>
<span id="19"><a href="#19"></a>  <span>return</span> <span>0</span><span>;</span></span>
<span id="20"><a href="#20"></a><span>}</span></span></code></pre></div><p>Copy (or symlink) <code>raylib.h</code>, <code>raylib.dll</code>, and <code>libraylibdll.a</code> to the same directory, and compile it with:</p><pre>&gt; x86_64-w64-mingw32-gcc hello.c -L&#34;.&#34; -lraylib</pre><p>Then, <code>wine ./a.exe</code> should open a Raylib window. Quit with <code>ESC</code>.</p><h2 id="org42ccbd">Installing SBCL</h2><p>Visit the <a href="https://www.sbcl.org/platform-table.html">SBCL Downloads</a> page and download the <code>.msi</code> installer file by clicking on the Windows cell of the Binaries matrix. Run <code>wine</code> on this. By default the <code>sbcl.exe</code> binary is installed to:</p><pre>$HOME/.wine/drive_c/Program Files/Steel Bank Common Lisp/</pre><p>You can confirm its function by running:</p><pre>wine $HOME/.wine/drive_c/Program Files/Steel Bank Common Lisp/sbcl.exe</pre><p>Try inspecting the content of the <code>*features*</code> list:</p><pre>(:ARENA-ALLOCATOR :X86-64 :GENCGC :64-BIT :ANSI-CL :COMMON-LISP
 :IEEE-FLOATING-POINT :LITTLE-ENDIAN :PACKAGE-LOCAL-NICKNAMES :SB-LDB
 :SB-PACKAGE-LOCKS :SB-SAFEPOINT :SB-THREAD :SB-UNICODE :SBCL :WIN32)</pre><p>Notice the presence of <code>:WIN32</code> and the lack of <code>:LINUX</code> and <code>:UNIX</code>. It&#39;s Windows!</p><h3 id="org6e7d08">Pathnames</h3><p>Feel free to ignore this section, it is optional information.</p><p>Filepaths work differently between Linux and Windows, and we can observe how SBCL handles this. In our REPL:</p><pre>&gt; (inspect #p&#34;Z:/home/colin/code/foo.json&#34;)

The object is a PATHNAME.
0. NAMESTRING: NIL
1. HOST: #&lt;SB-IMPL::WIN32-HOST {1100039A13}&gt;
2. DEVICE: &#34;Z&#34;
3. DIR+HASH: ((:ABSOLUTE &#34;home&#34; &#34;colin&#34; &#34;code&#34;) . 3675096247244793922)
4. NAME: &#34;foo&#34;
5. TYPE: &#34;json&#34;
6. VERSION: :NEWEST</pre><p>Notice that the <code>:device</code> field is actually populated. On Linux this would have been <code>nil</code>. Notice also that, for our convenience, the path component separator is <code>/</code> and not those accursed backslashes!</p><p>The <a href="https://github.com/fosskers/filepaths">filepaths</a> library offers additional convenience regarding paths, and supports both Linux and Windows.</p><h2 id="org1e149e">Wine-based SBCL in Emacs</h2><p><a href="https://github.com/fosskers/vend">vend</a> is a dependency manager for Common Lisp, and luckily it helps us simplify our Windows setup, since we don&#39;t need to bother with a Quicklisp installation within Wine. Since <code>vend repl</code> allows us to run any compiler and load our systems with all of our project dependencies available, why not just ask it to run SBCL through Wine as above?</p><pre>&gt; pwd
/home/colin/code/common-lisp/filepaths
&gt; vend repl wine /home/colin/.wine/drive_c/Program\ Files/Steel\ Bank\ Common\ Lisp/sbcl.exe
&gt; (asdf:test-system :filepaths)
;; ... compiling, etc. ...
Passed:    79
Failed:     0
Skipped:    0</pre><p>Likewise, <code>vend test</code> &#34;just works&#34;:</p><pre>&gt; vend test wine /home/colin/.wine/drive_c/Program\ Files/Steel\ Bank\ Common\ Lisp/sbcl.exe
[vend] Running tests.
;; ... yeah yeah ...
Passed:    79
Failed:     0
Skipped:    0</pre><p>It&#39;s able to find all of our vendored dependencies by virtue of the fact that our Linux filesystem is also available through Wine under <code>Z:</code>. When <code>vend</code> internally asks <code>uiop</code> where we currently are, we get what we&#39;d expect:</p><pre>&gt; (uiop:getcwd)
#P&#34;Z:/home/colin/code/common-lisp/filepaths/&#34;</pre><p>Now that we&#39;ve proven we can load systems through Wine, we can configure <a href="https://github.com/joaotavora/sly">Sly</a> to use our Wine-based SBCL as an in-editor REPL:</p><div><pre>(setq sly-lisp-implementations
      &#39;((sbcl (&#34;vend&#34; &#34;repl&#34; &#34;sbcl&#34; &#34;--dynamic-space-size&#34; &#34;4GB&#34;))
        ;; ... other compilers ...
        (wine (&#34;vend&#34; &#34;repl&#34; &#34;wine&#34; &#34;/home/colin/.wine/drive_c/Program Files/Steel Bank Common Lisp/sbcl.exe&#34;))))</pre></div><p>Adjust as necessary for <a href="https://github.com/slime/slime">Slime</a>. Then, <code>SPC m ;</code> in Doom (or <code>C-u sly</code>) and selecting <code>wine</code> will start our Windows SBCL. We can now develop interactively as normal, but with Windows assumptions.</p><h2 id="orgd30c2b">Loading Windows DLLs</h2><p>Remember those Raylib DLLs we built above? My bindings library assures they&#39;re loaded upon <code>asdf:load-system</code> via:</p><div><pre>(defun load-shared-objects (&amp;key (target nil))
  &#34;Dynamically load the necessary `.so&#39; files. This is wrapped as a function so that
downstream callers can call it again as necessary when the Lisp Image is being
restarted. Note the use of `:dont-save&#39; below. This is to allow the package to
be compiled with `.so&#39; files found in one location, but run with ones from another.&#34;
  (let ((dir (case target
               (:linux &#34;/usr/lib/&#34;)
               (t &#34;lib/&#34;))))
    #+linux
    (progn
      (load-shared-object (merge-pathnames &#34;liblisp-raylib.so&#34; dir) :dont-save t)
      (load-shared-object (merge-pathnames &#34;liblisp-raylib-shim.so&#34; dir) :dont-save t))
    #+win32
    (progn
      (load-shared-object (merge-pathnames &#34;lisp-raylib.dll&#34; dir) :dont-save t)
      (load-shared-object (merge-pathnames &#34;lisp-raylib-shim.dll&#34; dir) :dont-save t))))

(load-shared-objects)</pre></div><p>This works as-is. Essentially, you&#39;re able to call <code>load-shared-object</code> on any <code>.dll</code> file and it will be loaded into the Lisp image. Note also the presence of <code>:dont-save t</code>, which is important when building executables.</p><h2 id="orgfbd7ab">Building Executables</h2><p>Assuming all your <code>.dll</code> files are in place (if necessary), which you can ensure via a <a href="https://github.com/fosskers/aero-fighter/blob/master/Makefile">Makefile</a>, creating a <code>.exe</code> file of your Lisp program is as simple as writing a short <code>build.lisp</code>:</p><div><pre>(require :asdf)

;; Force ASDF to only look here for systems.
(asdf:initialize-source-registry `(:source-registry (:tree ,(uiop:getcwd)) :ignore-inherited-configuration))

(let ((bin (or #+win32 #p&#34;aero-fighter.exe&#34;
               #p&#34;aero-fighter&#34;)))
  (sb-ext:save-lisp-and-die
   bin
   :toplevel #&#39;aero-fighter:launch
   :executable t
   :compression (if (member :sb-core-compression *features*) t)))</pre></div><p>Note that Core Compression doesn&#39;t seem to be available for Windows, so the resulting binary will be quite a bit larger than its Linux one (~4x in the case of Aero Fighter, 11mb -&gt; 40mb. The Linux binary under ECL is only 1mb).</p><p><a href="https://github.com/fosskers/aero-fighter/blob/master/build.lisp">See here</a> for the full build script. Running <code>sbcl --load build.lisp</code> will build your Windows executable.</p><p>That&#39;s it!</p></div></div>
  </body>
</html>
