<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wingolog.org/archives/2022/08/18/just-in-time-code-generation-within-webassembly">Original</a>
    <h1>Just-in-time code generation within WebAssembly</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>Just-in-time (JIT) code generation is an important tactic when implementing a programming language.  Generating code at run-time allows a program to specialize itself against the specific data it is run against.  For a program that implements a programming language, that specialization is with respect to the program being run, and possibly with respect to the data that program uses.</p><p>The way this typically works is that the program generates bytes for the instruction set of the machine it&#39;s running on, and then transfers control to those instructions.</p><p>Usually the program has to put its generated code in memory that is specially marked as executable.  However, this capability is missing in WebAssembly.  How, then, to do just-in-time compilation in WebAssembly?</p><p><b>webassembly as a harvard architecture</b></p><p>In a von Neumman machine, like the ones that you are probably reading this on, code and data share an address space.  There&#39;s only one kind of pointer, and it can point to anything: the bytes that implement the <tt>sin</tt> function, the number <tt>42</tt>, the characters in <tt>&#34;biscuits&#34;</tt>, or anything at all.  WebAssembly is different in that its code is not addressable at run-time.  Functions in a WebAssembly module are numbered sequentially from 0, and the WebAssembly <tt>call</tt> instruction takes the callee as an immediate parameter.</p><p>So, to add code to a WebAssembly program, somehow you&#39;d have to augment the program with more functions.  Let&#39;s assume we will make that possible somehow -- that your WebAssembly module that had N functions will now have N+1 functions, and with function N being the new one your program generated.  How would we call it?  Given that the <tt>call</tt> instructions hard-code the callee, the existing functions 0 to N-1 won&#39;t call it.</p><p>Here the answer is <a href="https://webassembly.github.io/spec/core/exec/instructions.html#xref-syntax-instructions-syntax-instr-control-mathsf-call-indirect-x-y"><tt>call_indirect</tt></a>.  A bit of a reminder, this instruction take the callee as an operand, not an immediate parameter, allowing it to choose the callee function at run-time.  The callee operand is an index into a <i>table</i> of functions.  Conventionally, table 0 is called the <i>indirect function table</i> as it contains an entry for each function which might ever be the target of an indirect call.</p><p>With this in mind, our problem has two parts, then: (1) how to augment a WebAssembly module with a new function, and (2) how to get the original module to call the new code.</p><p><b>late linking of auxiliary webassembly modules</b></p><p>The key idea here is that to add code, the main program should generate a new WebAssembly module containing that code.  Then we run a linking phase to actually bring that new code to life and make it available.</p><p>System linkers like <tt>ld</tt> typically require a complete set of symbols and relocations to resolve inter-archive references.  However when performing a late link of JIT-generated code, we can take a short-cut:  the main program can embed memory addresses directly into the code it generates.  Therefore the generated module would import memory from the main module.  All references from the generated code to the main module can be directly embedded in this way.</p><p>The generated module would also import the indirect function table from the main module.  (We would ensure that the main module exports its memory and indirect function table via the toolchain.)  When the main module makes the generated module, it also embeds a special <tt>patch</tt> function in the generated module.  This function would add the new functions to the main module&#39;s indirect function table, and perform any relocations onto the main module&#39;s memory.  All references from the main module to generated functions are installed via the <tt>patch</tt> function.</p><p>We plan on two implementations of late linking, but both share the fundamental mechanism of a generated WebAssembly module with a <tt>patch</tt> function.</p><p><b>dynamic linking via the run-time</b></p><p>One implementation of a linker is for the main module to cause the run-time to dynamically instantiate a new WebAssembly module.  The run-time would provide the memory and indirect function table from the main module as imports when instantiating the generated module.</p><p>The advantage of dynamic linking is that it can update a live WebAssembly module without any need for re-instantiation or special run-time checkpointing support.</p><p>In the context of the web, JIT compilation can be triggered by the WebAssembly module in question, by calling out to functionality from JavaScript, or we can use a &#34;pull-based&#34; model to allow the JavaScript host to poll the WebAssembly instance for any pending JIT code.</p><p>For WASI deployments, you need a capability from the host.  Either you import a module that provides run-time JIT capability, or you rely on the host to poll you for data.</p><p><b>static linking via wizer</b></p><p>Another idea is to build on <a href="https://github.com/bytecodealliance/wizer">Wizer</a>&#39;s ability to take a snapshot of a WebAssembly module.  You could extend Wizer to also be able to augment a module with new code.  In this role, Wizer is effectively a late linker, linking in a new archive to an existing object.</p><p>Wizer already needs the ability to instantiate a WebAssembly module and to run its code.  Causing Wizer to ask the module if it has any generated auxiliary module that should be instantiated, patched, and incorporated into the main module should not be a huge deal.  Wizer can already run the <tt>patch</tt> function, to perform relocations to patch in access to the new functions.  After having done that, Wizer (or some other tool) would need to snapshot the module, as usual, but also adding in the extra code.</p><p>As a technical detail, in the simplest case in which code is generated in units of functions which don&#39;t directly call each other, this is as simple as just appending the functions to the code section and then and appending the generated <a href="https://webassembly.github.io/spec/core/exec/modules.html#element-segments">element segments</a> to the main module&#39;s element segment, updating the appended function references to their new values by adding the total number of functions in the module before the new module was concatenated to each function reference.</p><p><b>late linking appears to be async codegen</b></p><p>From the perspective of a main program, WebAssembly JIT code generation via late linking appears the same as aynchronous code generation.</p><p>For example, take the C program:</p><pre>struct Value;
struct Func {
  struct Expr *body;
  void *jitCode;
};

void recordJitCandidate(struct Func *func);
uint8_t* flushJitCode(); // Call to actually generate JIT code.

struct Value* interpretCall(struct Expr *body,
                            struct Value *arg);

struct Value* call(struct Func *func,
                   struct Value* val) {
  if (func-&gt;jitCode) {
    struct Value* (*f)(struct Value*) = jitCode;
    return f(val);
  } else {
    recordJitCandidate(func);
    return interpretCall(func-&gt;body, val);
  }
}
</pre><p>Here the C program allows for the possibility of JIT code generation:  there is a slot in a <tt>Func</tt> instance to fill in with a code pointer.  If this program generates code for a given <tt>Func</tt>, it won&#39;t be able to fill in the pointer -- it can&#39;t add new code to the image.  But, it could tell Wizer to do so, and Wizer could snapshot the program, link in the new function, and patch <tt>&amp;func-&gt;jitCode</tt>.  From the program&#39;s perspective, it&#39;s as if the code becomes available asynchronously.</p><p><b>demo!</b></p><p>So many words, right?  Let&#39;s see some code!  As a sketch for other JIT compiler work, I implemented a little Scheme interpreter and JIT compiler, targetting WebAssembly.  See <a href="https://github.com/wingo/wasm-jit/blob/main/interp.cc"><tt>interp.cc</tt></a> for the source.  You compile it like this:</p><pre>$ /opt/wasi-sdk/bin/clang++ -O2 -Wall \
   -mexec-model=reactor \
   -Wl,--growable-table \
   -Wl,--export-table \
   -DLIBRARY=1 \
   -fno-exceptions \
   interp.cc -o interplib.wasm
</pre><p>Here we are compiling with <a href="https://github.com/WebAssembly/wasi-sdk/releases">WASI SDK</a>.  I have version 14.</p><p>The <tt>-mexec-model=reactor</tt> argument means that this WASI module isn&#39;t just a run-once thing, after which its state is torn down; rather it&#39;s a multiple-entry component.</p><p>The two <tt>-Wl,</tt> options tell the linker to export the indirect function table, and to allow the indirect function table to be augmented by the JIT module.</p><p>The <tt>-DLIBRARY=1</tt> is used by <tt>interp.cc</tt>; you can actually run and debug it natively but that&#39;s just for development.  We&#39;re instead compiling to wasm and running with a WASI environment, giving us <tt>fprintf</tt> and other debugging niceties.</p><p>The <tt>-fno-exceptions</tt> is because WASI doesn&#39;t support exceptions currently.  Also we don&#39;t need them.</p><p>WASI is mainly for non-browser use cases, but this module does so little that it doesn&#39;t need much from WASI and I can just polyfill it in browser JavaScript.  So that&#39;s what we have here:</p><p><b id="wasm-jit-status">loading wasm-jit...</b></p><p>Each time you enter a Scheme expression, it will be parsed to an internal tree-like intermediate language.  You can then run a recursive interpreter over that tree by pressing the &#34;Evaluate&#34; button.  Press it a number of times, you should get the same result.</p><p>As the interpreter runs, it records any closures that it created.  The <tt>Func</tt> instances attached to the closures have a slot for a C++ function pointer, which is initially NULL.  Function pointers in WebAssembly are indexes into the indirect function table; the first slot is kept empty so that calling a NULL pointer (a pointer with value 0) causes an error.  If the interpreter gets to a closure call and the closure&#39;s function&#39;s JIT code pointer is NULL, it will interpret the closure&#39;s body.  Otherwise it will call the function pointer.</p><p>If you then press the &#34;JIT&#34; button above, the module will <a href="https://github.com/wingo/wasm-jit/blob/main/interp.cc#L809">assemble a fresh WebAssembly module containing JIT code</a> for the closures that it saw at run-time.  Obviously that&#39;s just one heuristic: you could be more eager or more lazy; this is just a detail.</p><p>Although the particular JIT compiler isn&#39;t much of interest---the point being to see JIT code generation at all---it&#39;s nice to see that the fibonacci example sees a good speedup; try it yourself, and try it on different browsers if you can.  Neat stuff!</p><p><b>not just the web</b></p><p>I was wondering how to get something like this working in a non-webby environment and it turns out that <a href="https://github.com/bytecodealliance/wasmtime-py/">the Python interface to wasmtime</a> is just the thing.  I wrote a little <a href="https://github.com/wingo/wasm-jit/blob/main/interp.py"><tt>interp.py</tt></a> harness that can do the same thing that we can do on the web; just run as `python3 interp.py`, after having `pip3 install wasmtime`:</p><pre>$ python3 interp.py
...
Calling eval(0x11eb0) 5 times took 1.716s.
Calling jitModule()
jitModule result: &lt;wasmtime._module.Module object at 0x7f2bef0821c0&gt;
Instantiating and patching in JIT module
... 
Calling eval(0x11eb0) 5 times took 1.161s.
</pre><p>Interestingly it would appear that the performance of wasmtime&#39;s code (0.232s/invocation) is somewhat better than both SpiderMonkey (0.392s) and V8 (0.729s).</p><p><b>reflections</b></p><p>This work is just a proof of concept, but it&#39;s a step in a particular direction.  As part of <a href="https://bytecodealliance.org/articles/making-javascript-run-fast-on-webassembly">previous work with Fastly</a>, we enabled the SpiderMonkey JavaScript engine to run on top of WebAssembly.  When combined with pre-initialization via Wizer, you end up with a system that can start in microseconds: fast enough to instantiate a fresh, shared-nothing module on every HTTP request, for example.</p><p>The SpiderMonkey-on-WASI work left out JIT compilation, though, because, you know, WebAssembly doesn&#39;t support JIT compilation.  JavaScript code actually ran via the C++ bytecode interpreter.  But as we just found out, actually you can compile the bytecode: just-in-time, but at a different time-scale.  What if you took a SpiderMonkey interpreter, pre-generated WebAssembly code for a user&#39;s JavaScript file, and then combined them into a single freeze-dried WebAssembly module via Wizer?  You get the benefits of fast startup while also getting decent baseline performance.  There are many engineering considerations here, but as part of work sponsored by Shopify, we have made good progress in this regard; details in another missive.</p><p>I think a kind of &#34;offline JIT&#34; has a lot of value for deployment environments like Shopify&#39;s and Fastly&#39;s, and you don&#39;t have to limit yourself to &#34;total&#34; optimizations: you can still collect and incorporate type feedback, and you get the benefit of taking advantage of adaptive optimization without having to actually run the JIT compiler at run-time.</p><p>But if we think of more traditional &#34;online JIT&#34; use cases, it&#39;s clear that relying on host JIT capabilities, while a good MVP, is not optimal.  For one, you would like to be able to freely emit direct calls from generated code to existing code, instead of having to call indirectly or via imports.  I think it still might make sense to have a language run-time express its generated code in the form of a WebAssembly module, though really you might want native support for compiling that code (asynchronously) from within WebAssembly itself, without calling out to a run-time.  Most people I have talked to that work on WebAssembly implementations in JS engines believe that a JIT proposal will come some day, but it&#39;s good to know that we don&#39;t have to wait for it to start generating code and taking advantage of it.</p><p><b>&amp; out</b></p><p>If you want to play around with the demo, do take a look at the <a href="https://github.com/wingo/wasm-jit">wasm-jit</a> Github project; it&#39;s fun stuff.  Happy hacking, and until next time!</p></div></div></div>
  </body>
</html>
