<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/hackware1993/ChenSort">Original</a>
    <h1>Show HN: I developed a fast general purpose sorting algorithm</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto">ChenSort is an improved bucket sort, which is a general-purpose sorting algorithm.</p>
<p dir="auto"><strong>The time complexity is O(n) at best and O(nlogn) at worst, the space complexity is O(n), and it is stable.</strong></p>
<p dir="auto">Randomly generate [1000,10000000] random numbers in the range [-2^63,2^63-1], average speed is 3 times faster than Quicksort, fastest is 20 times. Traditional counting sorts and bucket sorts cannot handle such a large range of values because the performance is worse than Quicksort.</p>
<p dir="auto"><a href="https://github.com/hackware1993/ChenSort/blob/master/ChenSort_Android.apk">Android APK demo, 6.05 MB</a></p>
<p dir="auto"><a href="https://github.com/hackware1993/ChenSort/blob/master/ChenSort_Windows.7z">Windows exe demo, 5.8 MB</a></p>
<p dir="auto">The demos are all built on Flutter.</p>
<p dir="auto">Currently writing an academic paper and expecting to be recognized by the academic community.</p>
<p dir="auto">Dart code:</p>
<div data-snippet-clipboard-copy-content="/// The essence of Chen Sort is an improved bucket sort
void chenSort(List&lt;int&gt; list) {
  if (list.length &lt; 2) {
    return;
  }

  int maxValue = list[0];
  int minValue = maxValue;
  for (final element in list.skip(1)) {
    if (element &gt; maxValue) {
      maxValue = element;
    }
    if (element &lt; minValue) {
      minValue = element;
    }
  }

  /// All elements are the same and do not need to be sorted.
  if (maxValue == minValue) {
    return;
  }

  /// Limit the maximum size of the bucket to ensure the performance of long list
  /// sorting, which can be adjusted according to the actual situation.
  ///
  /// The essential difference between this and bucket sorting is that the size of
  /// the bucket is only related to the length of the list, not the range of element values.
  int bucketSize = min(list.length, 50000);
  int maxBucketIndex = bucketSize - 1;

  List&lt;List&lt;int&gt;?&gt; buckets = List.filled(bucketSize, null);
  int slot;

  /// Calculate the bucket in which the element is located based on the value of the element
  /// and the maximum and minimum values.

  /// Overflow detection
  BigInt range = BigInt.from(maxValue) - BigInt.from(minValue);
  if (BigInt.from(range.toInt()) == range) {
    int range = maxValue - minValue;
    double factor = maxBucketIndex / range;
    for (final element in list) {
      // slot = (((element - minValue) / range) * maxBucketIndex).toInt();
      slot = ((element - minValue) * factor).toInt();
      if (buckets[slot] == null) {
        buckets[slot] = [];
      }
      buckets[slot]!.add(element);
    }
  } else {
    /// Overflowed(positive minus negative)
    int positiveRange = maxValue;
    int negativeRange = -1 - minValue;
    int positiveStartBucketIndex = maxBucketIndex ~/ 2 + 1;
    int positiveBucketLength = maxBucketIndex - positiveStartBucketIndex;
    int negativeBucketLength = positiveStartBucketIndex - 1;
    for (final element in list) {
      if (element &lt; 0) {
        slot = (((element - minValue) / negativeRange) * negativeBucketLength)
            .toInt();
      } else {
        slot = positiveStartBucketIndex +
            ((element / positiveRange) * positiveBucketLength).toInt();
      }
      if (buckets[slot] == null) {
        buckets[slot] = [];
      }
      buckets[slot]!.add(element);
    }
  }

  int compare(int left, int right) {
    return left - right;
  }

  int index = 0;
  for (final bucket in buckets) {
    if (bucket != null) {
      if (bucket.length &gt; 1) {
        if (bucket.length &gt;= 1000) {
          chenSort(bucket);
        } else {
          /// The sort method here represents the fastest comparison-type algorithm (Quick sort, Tim sort, etc.)
          bucket.sort(compare);
        }
        for (final element in bucket) {
          list[index++] = element;
        }
      } else {
        list[index++] = bucket[0];
      }
    }
  }
}"><pre><span>/// The essence of Chen Sort is an improved bucket sort</span>
<span></span><span>void</span> <span>chenSort</span>(<span>List&lt;<span>int</span>&gt;</span> list) {
  <span>if</span> (list.length <span>&lt;</span> <span>2</span>) {
    <span>return</span>;
  }

  <span>int</span> maxValue <span>=</span> list[<span>0</span>];
  <span>int</span> minValue <span>=</span> maxValue;
  <span>for</span> (<span>final</span> element <span>in</span> list.<span>skip</span>(<span>1</span>)) {
    <span>if</span> (element <span>&gt;</span> maxValue) {
      maxValue <span>=</span> element;
    }
    <span>if</span> (element <span>&lt;</span> minValue) {
      minValue <span>=</span> element;
    }
  }

  <span>/// All elements are the same and do not need to be sorted.</span>
<span></span>  <span>if</span> (maxValue <span>==</span> minValue) {
    <span>return</span>;
  }

  <span>/// Limit the maximum size of the bucket to ensure the performance of long list</span>
<span>  /// sorting, which can be adjusted according to the actual situation.</span>
<span>  ///</span>
<span>  /// The essential difference between this and bucket sorting is that the size of</span>
<span>  /// the bucket is only related to the length of the list, not the range of element values.</span>
<span></span>  <span>int</span> bucketSize <span>=</span> <span>min</span>(list.length, <span>50000</span>);
  <span>int</span> maxBucketIndex <span>=</span> bucketSize <span>-</span> <span>1</span>;

  <span>List&lt;<span>List&lt;<span>int</span>&gt;?&gt;</span></span> buckets <span>=</span> <span>List</span>.<span>filled</span>(bucketSize, <span>null</span>);
  <span>int</span> slot;

  <span>/// Calculate the bucket in which the element is located based on the value of the element</span>
<span>  /// and the maximum and minimum values.</span>
<span></span>
  <span>/// Overflow detection</span>
<span></span>  <span>BigInt</span> range <span>=</span> <span>BigInt</span>.<span>from</span>(maxValue) <span>-</span> <span>BigInt</span>.<span>from</span>(minValue);
  <span>if</span> (<span>BigInt</span>.<span>from</span>(range.<span>toInt</span>()) <span>==</span> range) {
    <span>int</span> range <span>=</span> maxValue <span>-</span> minValue;
    <span>double</span> factor <span>=</span> maxBucketIndex <span>/</span> range;
    <span>for</span> (<span>final</span> element <span>in</span> list) {
      <span>// slot = (((element - minValue) / range) * maxBucketIndex).toInt();</span>
      slot <span>=</span> ((element <span>-</span> minValue) <span>*</span> factor).<span>toInt</span>();
      <span>if</span> (buckets[slot] <span>==</span> <span>null</span>) {
        buckets[slot] <span>=</span> [];
      }
      buckets[slot]<span>!</span>.<span>add</span>(element);
    }
  } <span>else</span> {
    <span>/// Overflowed(positive minus negative)</span>
<span></span>    <span>int</span> positiveRange <span>=</span> maxValue;
    <span>int</span> negativeRange <span>=</span> <span>-</span><span>1</span> <span>-</span> minValue;
    <span>int</span> positiveStartBucketIndex <span>=</span> maxBucketIndex <span>~</span><span>/</span> <span>2</span> <span>+</span> <span>1</span>;
    <span>int</span> positiveBucketLength <span>=</span> maxBucketIndex <span>-</span> positiveStartBucketIndex;
    <span>int</span> negativeBucketLength <span>=</span> positiveStartBucketIndex <span>-</span> <span>1</span>;
    <span>for</span> (<span>final</span> element <span>in</span> list) {
      <span>if</span> (element <span>&lt;</span> <span>0</span>) {
        slot <span>=</span> (((element <span>-</span> minValue) <span>/</span> negativeRange) <span>*</span> negativeBucketLength)
            .<span>toInt</span>();
      } <span>else</span> {
        slot <span>=</span> positiveStartBucketIndex <span>+</span>
            ((element <span>/</span> positiveRange) <span>*</span> positiveBucketLength).<span>toInt</span>();
      }
      <span>if</span> (buckets[slot] <span>==</span> <span>null</span>) {
        buckets[slot] <span>=</span> [];
      }
      buckets[slot]<span>!</span>.<span>add</span>(element);
    }
  }

  <span>int</span> <span>compare</span>(<span>int</span> left, <span>int</span> right) {
    <span>return</span> left <span>-</span> right;
  }

  <span>int</span> index <span>=</span> <span>0</span>;
  <span>for</span> (<span>final</span> bucket <span>in</span> buckets) {
    <span>if</span> (bucket <span>!=</span> <span>null</span>) {
      <span>if</span> (bucket.length <span>&gt;</span> <span>1</span>) {
        <span>if</span> (bucket.length <span>&gt;=</span> <span>1000</span>) {
          <span>chenSort</span>(bucket);
        } <span>else</span> {
          <span>/// The sort method here represents the fastest comparison-type algorithm (Quick sort, Tim sort, etc.)</span>
<span></span>          bucket.<span>sort</span>(compare);
        }
        <span>for</span> (<span>final</span> element <span>in</span> bucket) {
          list[index<span>++</span>] <span>=</span> element;
        }
      } <span>else</span> {
        list[index<span>++</span>] <span>=</span> bucket[<span>0</span>];
      }
    }
  }
}</pre></div>
<p dir="auto">Java code(Multi-thread):</p>
<div data-snippet-clipboard-copy-content="static void chenSort(Integer[] list) {
    int length = list.length;
    if (length &lt; 2) {
        return;
    }

    Integer maxValue = Integer.MIN_VALUE;
    Integer minValue = Integer.MAX_VALUE;
    for (Integer element : list) {
        if (element &gt; maxValue) {
            maxValue = element;
        }
        if (element &lt; minValue) {
            minValue = element;
        }
    }

    /// All elements are the same and do not need to be sorted.
    if (maxValue.equals(minValue)) {
        return;
    }

    /// Limit the maximum size of the bucket to ensure the performance of long list
    /// sorting, which can be adjusted according to the actual situation.
    ///
    /// The essential difference between this and bucket sorting is that the size of
    /// the bucket is only related to the length of the list, not the range of element values.
    int bucketSize = Math.min(length, 50000);
    int maxBucketIndex = bucketSize - 1;

    ArrayList&lt;Integer&gt;[] buckets = new ArrayList[bucketSize];
    int slot;

    /// Calculate the bucket in which the element is located based on the value of the element
    /// and the maximum and minimum values.

    /// Overflow detection
    BigInteger bigRange = BigInteger.valueOf(maxValue).subtract(BigInteger.valueOf(minValue));
    if (BigInteger.valueOf(bigRange.intValue()).equals(bigRange)) {
        double factor = maxBucketIndex * 1.0 / (maxValue - minValue);
        for (Integer element : list) {
            slot = (int) ((element - minValue) * factor);
            if (buckets[slot] == null) {
                buckets[slot] = new ArrayList&lt;&gt;();
            }
            buckets[slot].add(element);
        }
    } else {
        /// Overflowed(positive minus negative)
        double positiveRange = maxValue;
        double negativeRange = -1 - minValue;
        int positiveStartBucketIndex = maxBucketIndex / 2 + 1;
        int positiveBucketLength = maxBucketIndex - positiveStartBucketIndex;
        int negativeBucketLength = positiveStartBucketIndex - 1;
        Integer zero = 0;
        for (Integer element : list) {
            if (element &lt; zero) {
                slot = (int) (((element - minValue) / negativeRange) * negativeBucketLength);
            } else {
                slot = (int) (positiveStartBucketIndex + ((element / positiveRange) * positiveBucketLength));
            }
            if (buckets[slot] == null) {
                buckets[slot] = new ArrayList&lt;&gt;();
            }
            buckets[slot].add(element);
        }
    }

    Comparator&lt;Integer&gt; comparator = Comparator.comparingInt(left -&gt; left);

    // Multi-thread sorting between buckets
    CountDownLatch countDownLatch = new CountDownLatch(buckets.length);
    for (ArrayList&lt;Integer&gt; bucket : buckets) {
        if (bucket != null) {
            if (bucket.size() &gt; 1) {
                executor.execute(() -&gt; {
                    bucket.sort(comparator);
                    countDownLatch.countDown();
                });
            } else {
                countDownLatch.countDown();
            }
        } else {
            countDownLatch.countDown();
        }
    }
    try {
        countDownLatch.await();
    } catch (InterruptedException ignored) {
    }

    int index = 0;
    for (ArrayList&lt;Integer&gt; bucket : buckets) {
        if (bucket != null) {
            if (bucket.size() &gt; 1) {
                for (Integer element : bucket) {
                    list[index++] = element;
                }
            } else {
                list[index++] = bucket.get(0);
            }
        }
    }
}"><pre><span>static</span> <span>void</span> <span>chenSort</span>(<span>Integer</span>[] <span>list</span>) {
    <span>int</span> <span>length</span> = <span>list</span>.<span>length</span>;
    <span>if</span> (<span>length</span> &lt; <span>2</span>) {
        <span>return</span>;
    }

    <span>Integer</span> <span>maxValue</span> = <span>Integer</span>.<span>MIN_VALUE</span>;
    <span>Integer</span> <span>minValue</span> = <span>Integer</span>.<span>MAX_VALUE</span>;
    <span>for</span> (<span>Integer</span> <span>element</span> : <span>list</span>) {
        <span>if</span> (<span>element</span> &gt; <span>maxValue</span>) {
            <span>maxValue</span> = <span>element</span>;
        }
        <span>if</span> (<span>element</span> &lt; <span>minValue</span>) {
            <span>minValue</span> = <span>element</span>;
        }
    }

    <span>/// All elements are the same and do not need to be sorted.</span>
    <span>if</span> (<span>maxValue</span>.<span>equals</span>(<span>minValue</span>)) {
        <span>return</span>;
    }

    <span>/// Limit the maximum size of the bucket to ensure the performance of long list</span>
    <span>/// sorting, which can be adjusted according to the actual situation.</span>
    <span>///</span>
    <span>/// The essential difference between this and bucket sorting is that the size of</span>
    <span>/// the bucket is only related to the length of the list, not the range of element values.</span>
    <span>int</span> <span>bucketSize</span> = <span>Math</span>.<span>min</span>(<span>length</span>, <span>50000</span>);
    <span>int</span> <span>maxBucketIndex</span> = <span>bucketSize</span> - <span>1</span>;

    <span>ArrayList</span>&lt;<span>Integer</span>&gt;[] <span>buckets</span> = <span>new</span> <span>ArrayList</span>[<span>bucketSize</span>];
    <span>int</span> <span>slot</span>;

    <span>/// Calculate the bucket in which the element is located based on the value of the element</span>
    <span>/// and the maximum and minimum values.</span>

    <span>/// Overflow detection</span>
    <span>BigInteger</span> <span>bigRange</span> = <span>BigInteger</span>.<span>valueOf</span>(<span>maxValue</span>).<span>subtract</span>(<span>BigInteger</span>.<span>valueOf</span>(<span>minValue</span>));
    <span>if</span> (<span>BigInteger</span>.<span>valueOf</span>(<span>bigRange</span>.<span>intValue</span>()).<span>equals</span>(<span>bigRange</span>)) {
        <span>double</span> <span>factor</span> = <span>maxBucketIndex</span> * <span>1.0</span> / (<span>maxValue</span> - <span>minValue</span>);
        <span>for</span> (<span>Integer</span> <span>element</span> : <span>list</span>) {
            <span>slot</span> = (<span>int</span>) ((<span>element</span> - <span>minValue</span>) * <span>factor</span>);
            <span>if</span> (<span>buckets</span>[<span>slot</span>] == <span>null</span>) {
                <span>buckets</span>[<span>slot</span>] = <span>new</span> <span>ArrayList</span>&lt;&gt;();
            }
            <span>buckets</span>[<span>slot</span>].<span>add</span>(<span>element</span>);
        }
    } <span>else</span> {
        <span>/// Overflowed(positive minus negative)</span>
        <span>double</span> <span>positiveRange</span> = <span>maxValue</span>;
        <span>double</span> <span>negativeRange</span> = -<span>1</span> - <span>minValue</span>;
        <span>int</span> <span>positiveStartBucketIndex</span> = <span>maxBucketIndex</span> / <span>2</span> + <span>1</span>;
        <span>int</span> <span>positiveBucketLength</span> = <span>maxBucketIndex</span> - <span>positiveStartBucketIndex</span>;
        <span>int</span> <span>negativeBucketLength</span> = <span>positiveStartBucketIndex</span> - <span>1</span>;
        <span>Integer</span> <span>zero</span> = <span>0</span>;
        <span>for</span> (<span>Integer</span> <span>element</span> : <span>list</span>) {
            <span>if</span> (<span>element</span> &lt; <span>zero</span>) {
                <span>slot</span> = (<span>int</span>) (((<span>element</span> - <span>minValue</span>) / <span>negativeRange</span>) * <span>negativeBucketLength</span>);
            } <span>else</span> {
                <span>slot</span> = (<span>int</span>) (<span>positiveStartBucketIndex</span> + ((<span>element</span> / <span>positiveRange</span>) * <span>positiveBucketLength</span>));
            }
            <span>if</span> (<span>buckets</span>[<span>slot</span>] == <span>null</span>) {
                <span>buckets</span>[<span>slot</span>] = <span>new</span> <span>ArrayList</span>&lt;&gt;();
            }
            <span>buckets</span>[<span>slot</span>].<span>add</span>(<span>element</span>);
        }
    }

    <span>Comparator</span>&lt;<span>Integer</span>&gt; <span>comparator</span> = <span>Comparator</span>.<span>comparingInt</span>(<span>left</span> -&gt; <span>left</span>);

    <span>// Multi-thread sorting between buckets</span>
    <span>CountDownLatch</span> <span>countDownLatch</span> = <span>new</span> <span>CountDownLatch</span>(<span>buckets</span>.<span>length</span>);
    <span>for</span> (<span>ArrayList</span>&lt;<span>Integer</span>&gt; <span>bucket</span> : <span>buckets</span>) {
        <span>if</span> (<span>bucket</span> != <span>null</span>) {
            <span>if</span> (<span>bucket</span>.<span>size</span>() &gt; <span>1</span>) {
                <span>executor</span>.<span>execute</span>(() -&gt; {
                    <span>bucket</span>.<span>sort</span>(<span>comparator</span>);
                    <span>countDownLatch</span>.<span>countDown</span>();
                });
            } <span>else</span> {
                <span>countDownLatch</span>.<span>countDown</span>();
            }
        } <span>else</span> {
            <span>countDownLatch</span>.<span>countDown</span>();
        }
    }
    <span>try</span> {
        <span>countDownLatch</span>.<span>await</span>();
    } <span>catch</span> (<span>InterruptedException</span> <span>ignored</span>) {
    }

    <span>int</span> <span>index</span> = <span>0</span>;
    <span>for</span> (<span>ArrayList</span>&lt;<span>Integer</span>&gt; <span>bucket</span> : <span>buckets</span>) {
        <span>if</span> (<span>bucket</span> != <span>null</span>) {
            <span>if</span> (<span>bucket</span>.<span>size</span>() &gt; <span>1</span>) {
                <span>for</span> (<span>Integer</span> <span>element</span> : <span>bucket</span>) {
                    <span>list</span>[<span>index</span>++] = <span>element</span>;
                }
            } <span>else</span> {
                <span>list</span>[<span>index</span>++] = <span>bucket</span>.<span>get</span>(<span>0</span>);
            }
        }
    }
}</pre></div>
<p dir="auto">Performance(10 million random numbers sorted):</p>
<div data-snippet-clipboard-copy-content="Random random = new Random();
Integer[] arr = new Integer[10000000];
long maxValue = Integer.MAX_VALUE;
long minValue = Integer.MIN_VALUE;
long range = maxValue - minValue + 1;
for (int i = 0; i &lt; arr.length; i++) {
    arr[i] = (int) (minValue + random.nextLong(range));
}
Integer[] copy = new Integer[arr.length];
System.arraycopy(arr, 0, copy, 0, arr.length);
long start = System.currentTimeMillis();
chenSort(arr);
long chenSortTimeUsage = System.currentTimeMillis() - start;
start = System.currentTimeMillis();
Arrays.sort(copy);
long quickSortTimeUsage = System.currentTimeMillis() - start;"><pre><span>Random</span> <span>random</span> = <span>new</span> <span>Random</span>();
<span>Integer</span>[] <span>arr</span> = <span>new</span> <span>Integer</span>[<span>10000000</span>];
<span>long</span> <span>maxValue</span> = <span>Integer</span>.<span>MAX_VALUE</span>;
<span>long</span> <span>minValue</span> = <span>Integer</span>.<span>MIN_VALUE</span>;
<span>long</span> <span>range</span> = <span>maxValue</span> - <span>minValue</span> + <span>1</span>;
<span>for</span> (<span>int</span> <span>i</span> = <span>0</span>; <span>i</span> &lt; <span>arr</span>.<span>length</span>; <span>i</span>++) {
    <span>arr</span>[<span>i</span>] = (<span>int</span>) (<span>minValue</span> + <span>random</span>.<span>nextLong</span>(<span>range</span>));
}
<span>Integer</span>[] <span>copy</span> = <span>new</span> <span>Integer</span>[<span>arr</span>.<span>length</span>];
<span>System</span>.<span>arraycopy</span>(<span>arr</span>, <span>0</span>, <span>copy</span>, <span>0</span>, <span>arr</span>.<span>length</span>);
<span>long</span> <span>start</span> = <span>System</span>.<span>currentTimeMillis</span>();
<span>chenSort</span>(<span>arr</span>);
<span>long</span> <span>chenSortTimeUsage</span> = <span>System</span>.<span>currentTimeMillis</span>() - <span>start</span>;
<span>start</span> = <span>System</span>.<span>currentTimeMillis</span>();
<span>Arrays</span>.<span>sort</span>(<span>copy</span>);
<span>long</span> <span>quickSortTimeUsage</span> = <span>System</span>.<span>currentTimeMillis</span>() - <span>start</span>;</pre></div>
<div data-snippet-clipboard-copy-content="chen sort: 3384 ms, quick sort: 9366 ms, 63.869314541960286%(2.767730496453901x) faster
chen sort: 3450 ms, quick sort: 7223 ms, 52.2359130555171%(2.093623188405797x) faster
chen sort: 1693 ms, quick sort: 5000 ms, 66.14%(2.9533372711163617x) faster
chen sort: 2306 ms, quick sort: 6267 ms, 63.204084889101644%(2.717692974848222x) faster
chen sort: 2922 ms, quick sort: 10145 ms, 71.19763430261213%(3.471937029431896x) faster
chen sort: 3285 ms, quick sort: 9211 ms, 64.33611985669309%(2.803957382039574x) faster
chen sort: 2661 ms, quick sort: 9236 ms, 71.18882633174535%(3.4708756106726795x) faster
chen sort: 2538 ms, quick sort: 6422 ms, 60.47960137028963%(2.530338849487786x) faster
chen sort: 1749 ms, quick sort: 4928 ms, 64.50892857142857%(2.8176100628930816x) faster
chen sort: 1775 ms, quick sort: 5254 ms, 66.21621621621621%(2.96x) faster
chen sort: 1626 ms, quick sort: 5155 ms, 68.45780795344326%(3.1703567035670357x) faster
chen sort: 2375 ms, quick sort: 4877 ms, 51.302029936436334%(2.0534736842105263x) faster
chen sort: 1923 ms, quick sort: 5250 ms, 63.37142857142857%(2.730109204368175x) faster
chen sort: 3028 ms, quick sort: 9237 ms, 67.21879398072967%(3.0505284015852046x) faster
chen sort: 2692 ms, quick sort: 9030 ms, 70.18826135105205%(3.3543833580980684x) faster"><pre><span>chen</span> <span>sort</span>: <span>3384</span> <span>ms</span>, <span>quick</span> <span>sort</span>: <span>9366</span> <span>ms</span>, <span>63.869314541960286</span>%(<span>2.767730496453901</span><span>x</span>) <span>faster</span>
<span>chen</span> <span>sort</span>: <span>3450</span> <span>ms</span>, <span>quick</span> <span>sort</span>: <span>7223</span> <span>ms</span>, <span>52.2359130555171</span>%(<span>2.093623188405797</span><span>x</span>) <span>faster</span>
<span>chen</span> <span>sort</span>: <span>1693</span> <span>ms</span>, <span>quick</span> <span>sort</span>: <span>5000</span> <span>ms</span>, <span>66.14</span>%(<span>2.9533372711163617</span><span>x</span>) <span>faster</span>
<span>chen</span> <span>sort</span>: <span>2306</span> <span>ms</span>, <span>quick</span> <span>sort</span>: <span>6267</span> <span>ms</span>, <span>63.204084889101644</span>%(<span>2.717692974848222</span><span>x</span>) <span>faster</span>
<span>chen</span> <span>sort</span>: <span>2922</span> <span>ms</span>, <span>quick</span> <span>sort</span>: <span>10145</span> <span>ms</span>, <span>71.19763430261213</span>%(<span>3.471937029431896</span><span>x</span>) <span>faster</span>
<span>chen</span> <span>sort</span>: <span>3285</span> <span>ms</span>, <span>quick</span> <span>sort</span>: <span>9211</span> <span>ms</span>, <span>64.33611985669309</span>%(<span>2.803957382039574</span><span>x</span>) <span>faster</span>
<span>chen</span> <span>sort</span>: <span>2661</span> <span>ms</span>, <span>quick</span> <span>sort</span>: <span>9236</span> <span>ms</span>, <span>71.18882633174535</span>%(<span>3.4708756106726795</span><span>x</span>) <span>faster</span>
<span>chen</span> <span>sort</span>: <span>2538</span> <span>ms</span>, <span>quick</span> <span>sort</span>: <span>6422</span> <span>ms</span>, <span>60.47960137028963</span>%(<span>2.530338849487786</span><span>x</span>) <span>faster</span>
<span>chen</span> <span>sort</span>: <span>1749</span> <span>ms</span>, <span>quick</span> <span>sort</span>: <span>4928</span> <span>ms</span>, <span>64.50892857142857</span>%(<span>2.8176100628930816</span><span>x</span>) <span>faster</span>
<span>chen</span> <span>sort</span>: <span>1775</span> <span>ms</span>, <span>quick</span> <span>sort</span>: <span>5254</span> <span>ms</span>, <span>66.21621621621621</span>%(<span>2.96</span><span>x</span>) <span>faster</span>
<span>chen</span> <span>sort</span>: <span>1626</span> <span>ms</span>, <span>quick</span> <span>sort</span>: <span>5155</span> <span>ms</span>, <span>68.45780795344326</span>%(<span>3.1703567035670357</span><span>x</span>) <span>faster</span>
<span>chen</span> <span>sort</span>: <span>2375</span> <span>ms</span>, <span>quick</span> <span>sort</span>: <span>4877</span> <span>ms</span>, <span>51.302029936436334</span>%(<span>2.0534736842105263</span><span>x</span>) <span>faster</span>
<span>chen</span> <span>sort</span>: <span>1923</span> <span>ms</span>, <span>quick</span> <span>sort</span>: <span>5250</span> <span>ms</span>, <span>63.37142857142857</span>%(<span>2.730109204368175</span><span>x</span>) <span>faster</span>
<span>chen</span> <span>sort</span>: <span>3028</span> <span>ms</span>, <span>quick</span> <span>sort</span>: <span>9237</span> <span>ms</span>, <span>67.21879398072967</span>%(<span>3.0505284015852046</span><span>x</span>) <span>faster</span>
<span>chen</span> <span>sort</span>: <span>2692</span> <span>ms</span>, <span>quick</span> <span>sort</span>: <span>9030</span> <span>ms</span>, <span>70.18826135105205</span>%(<span>3.3543833580980684</span><span>x</span>) <span>faster</span></pre></div>
<p dir="auto"><a href="https://mp.weixin.qq.com/s/uGNQxpBohPmlgxsHrE4pFg" rel="nofollow">Blog</a></p>
<p dir="auto"><a href="https://github.com/hackware1993/XiSort">XiSort</a> The slowest sorting algorithm I&#39;ve developed with the most efficient code execution in the world.</p>

<p dir="auto">If it helps you a lot, consider sponsoring me a cup of milk tea, or giving a star. Your support is
the driving force for me to continue to maintain.</p>
<p dir="auto"><a href="https://www.paypal.com/paypalme/hackware1993" rel="nofollow">Paypal</a></p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/hackware1993/ChenSort/blob/master/sponsorship.webp?raw=true"><img src="https://github.com/hackware1993/ChenSort/raw/master/sponsorship.webp?raw=true" alt="sponsorship.webp"/></a></p>
<p dir="auto">Thanks to the following netizens for their sponsorship.</p>
<ol dir="auto">
<li>小小鸟 2022.06.08</li>
<li>孟焱 2022.06.08</li>
</ol>
</article>
          </div></div>
  </body>
</html>
