<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cohost.org/jckarter/post/2955755-the-lost-language-ex">Original</a>
    <h1>High C Compiler – A C language extension ahead of its time</h1>
    
    <div id="readability-page-1" class="page"><div data-post-body="true" data-testid="post-body"><div><p>This book I got <!-- --><a href="https://cohost.org/jckarter/post/2953036-empty" target="_blank" rel="nofollow noopener">in a pile of FM TOWNS books<!-- --></a> turns out to be a lot more interesting that I was expecting an &#39;80s C compiler manual to be. For as long as C and its relatives have been in mainstream use, it has been necessary to use vendor language extensions to actually get anything done with it, though in today&#39;s GCC/Clang/MSVC oligopoly those extensions tend to be focused on the yak-shaving details of dealing with the underlying platform. Things were much more interesting in the 80s, when there were a lot more, smaller companies competing for adoption. Phar Lap wrote one of the first <!-- --><a href="https://en.wikipedia.org/wiki/DOS_extender" target="_blank" rel="nofollow noopener">DOS extenders<!-- --></a> that allowed programs to take full advantage of the 32-bit 80386 processor from the otherwise 16-bit-bound MS-DOS environment, and they hired MetaWare to port their High C Compiler to their SDK.<!-- --></p>
<!-- --><p>Fujitsu in turn chose Phar Lap&#39;s DOS extender to integrate into the OS for their 80386-based FM TOWNS platform, and High C became the first-party C compiler for the platform. The FM TOWNS came out in 1989, just barely in time for the first ANSI C standard C89 to be ratified. High C has its share of DOS-specific extensions, but it also contains a lot of interesting user-oriented language extensions I haven&#39;t seen in other C compilers I&#39;ve used, ranging from small quality of life improvements to fairly advanced features you wouldn&#39;t think would be possible in C, let alone a late-80s dialect of C! Some of these things would take literal decades to make it into some official standard of C or C++, and some of them still don&#39;t have equivalents in either language today. Here are some of the extensions I found interesting:<!-- --></p><hr/>
<!-- --><h2>Underscores in numeric literals<!-- --></h2>
<!-- --><p><img src="https://staging.cohostcdn.org/attachment/2ff0d014-ea10-49f8-b46b-06712d878528/IMG_9536.jpeg" alt="manual page explaining that _ can be placed in numeric literals, like 1_000_000 for 1000000" title="manual page explaining that _ can be placed in numeric literals, like 1_000_000 for 1000000"/></p>
<!-- --><p>It&#39;s a little thing, but it always bothers me when a programming language doesn&#39;t let you write long numeric literals with separators to make it readable. Many other languages have had this since C, but C++ didn&#39;t get anything like this till C++14, using the single quote as a separator like <!-- --><code>1&#39;000&#39;000<!-- --></code> instead of underscore, and C only followed suit earlier this year with C23.<!-- --></p>
<!-- --><h2>Labeled arguments<!-- --></h2>
<!-- --><p><img src="https://staging.cohostcdn.org/attachment/4b4c0113-00ca-43ce-a6e6-ed4ead2475bc/IMG_9539.jpeg" alt="manual page showing the use of labeled arguments. after declaring void P(int A, float B, Color C, Color D);, you can call it with named arguments as P(C =&gt; Red, D =› Blue, B =&gt; X*10. 0, A =&gt; y);" title="manual page showing the use of labeled arguments. after declaring void P(int A, float B, Color C, Color D);, you can call it with named arguments as P(C =&gt; Red, D =› Blue, B =&gt; X*10. 0, A =&gt; y);"/></p>
<!-- --><p>When calling functions with lots of parameters, or with parameters of nondescriptive types like <!-- --><code>bool<!-- --></code>, it&#39;s extremely helpful to be able to label the arguments in the call site. This is one of Python&#39;s most popular features, and High C&#39;s variant works a lot like Python. Argument labels are optional, but when they&#39;re present, you can specify the arguments in any order, using <!-- --><code>argumentName =&gt; value<!-- --></code> syntax, and you can combine unlabeled and labeled arguments arbitrarily as long as every parameter to the function has one matching argument. Neither standard C nor C++ has this feature yet.<!-- --></p>
<!-- --><h2>Case ranges<!-- --></h2>
<!-- --><p><img src="https://staging.cohostcdn.org/attachment/1db34471-3a60-45bb-bb4c-da6c85ed60ce/IMG_9537.jpeg" alt="manual page screenshot showing the use of case ranges case &#39;A&#39;..&#39;Z&#39;: to match all ASCII uppercase letters" title="manual page screenshot showing the use of case ranges case &#39;A&#39;..&#39;Z&#39;: to match all ASCII uppercase letters"/></p>
<!-- --><p>Pascal lets you match a range of values with <!-- --><code>case low..high<!-- --></code>; wouldn&#39;t it be great if C had that feature? High C does, another feature standard C and C++ never adopted.<!-- --></p>
<!-- --><h2>Nested functions<!-- --></h2>
<!-- --><p><img src="https://staging.cohostcdn.org/attachment/366e35a4-466b-44c4-8630-251f63cc2b0a/IMG_9541.jpeg" alt="manual page screenshot showing the use of nested functions, including the void Callme()! type syntax for declaring the &#34;full function value&#34; type, and the ability to goto from nested functions into the parent function" title="manual page screenshot showing the use of nested functions, including the void Callme()! type syntax for declaring the &#34;full function value&#34; type, and the ability to goto from nested functions into the parent function"/></p>
<!-- --><p>The previous features were just very nice to have, but here we get into features that start greatly increasing the expressivity of the language. High C lets you nest functions inside of other functions, another borrow from Pascal. However, High C&#39;s implementation is much more interesting and complete than standard Pascal or GCC&#39;s nested function extension. Not only can you declare nested functions, but you can declare &#34;full function value&#34; types. Unlike traditional C function pointers, these work as nonescaping closures, carrying a context pointer in addition to the function pointer to let the nested function find its captured context again. (GCC infamously did horrible things to allow for nested functions to be referenced by normal function pointers, by writing executable code into the callstack to thunk the context pointer, an obvious security nightmare causing many platforms to disable the feature entirely.) This allows local function references to be used as first-class values, though their lifetime doesn&#39;t extend past when the surrounding function returns. Nested functions can even <!-- --><code>goto<!-- --></code> back into their parent function, allowing for nonlocal exits to break out of nested functions like Smalltalk blocks, allowing control flow-like functions to be built using them.<!-- --></p>
<!-- --><p>Objective-C got blocks in 2009, which can be used as escaping closures, and C++ got lambdas in 2011, but neither language got the nonlocal exit ability. Standard C still has yet to have any official nested function feature.<!-- --></p>
<!-- --><h2>Generators<!-- --></h2>
<!-- --><p><img src="https://staging.cohostcdn.org/attachment/32e84688-f03c-4995-bc6e-dbbf38e4d9e2/IMG_9542.jpeg" alt="manual page demonstrating the generator and yield syntax, along with the for loop syntax to consume it" title="manual page demonstrating the generator and yield syntax, along with the for loop syntax to consume it"/></p>
<!-- --><p>MetaWare was clearly proud of this since they dedicate a whole chapter to explaining it. All the way back in 1989, they supported Python-style generator coroutines! In plain C! A function declared with the syntax <!-- --><code>void foo(Arg arguments) -&gt; (Yield yields)<!-- --></code> can call the magic function <!-- --><code>yield(values...)<!-- --></code> multiple times to generate a sequence of values. Callers can then use a new <!-- --><code>for<!-- --></code> loop syntax <!-- --><code>for variable... &lt;- foo(arguments...) do { ... }<!-- --></code> to run a loop over each of the generator&#39;s yielded values in turn.<!-- --></p>
<!-- --><p><img src="https://staging.cohostcdn.org/attachment/43287d6d-ce37-41a7-b5f8-5d90371ade79/IMG_9543.jpeg" alt="manual page showing an example of a recursive local function call traversing a tree, and yield-ing to the outer generator function" title="manual page showing an example of a recursive local function call traversing a tree, and yield-ing to the outer generator function"/></p>
<!-- --><p>The implementation even allows for some pretty intricate interactions with the nested function feature. A function nested in a generator can capture the <!-- --><code>yield<!-- --></code> operation from the outer generator, and the nested function can call itself recursively to traverse a tree or other recursive data structure, <!-- --><code>yield<!-- --></code>-ing at each level to produce values for the generator. I don&#39;t think you can do that in Python or in many other mainstream languages with generator coroutines.<!-- --></p>
<!-- --><p><img src="https://staging.cohostcdn.org/attachment/91f8494d-8d85-46c8-bd5f-8c44a8f8a2ce/IMG_9544.jpeg" alt="manual page demonstrating the desugaring of generators and for loops into nested functions" title="manual page demonstrating the desugaring of generators and for loops into nested functions"/></p>
<!-- --><p>How does all this work in plain C without a fancy runtime? High C&#39;s generators act as relatively straightforward syntax sugar over the nested function feature. When you declare a generator function <!-- --><code>void foo(Arg arguments) -&gt; (Yield yields)<!-- --></code>, that&#39;s equivalent to declaring a normal function <!-- --><code>void foo(void yield(Yield yields)!, Arg arguments)<!-- --></code>, where <!-- --><code>yield<!-- --></code> is an implicit parameter of &#34;full function value&#34; type. Using <!-- --><code>yield(values)<!-- --></code> inside the generator body is a regular function call into that implicit function parameter. On the caller&#39;s side, a <!-- --><code>for<!-- --></code> loop&#39;s body is transformed into a nested function, which is passed as the <!-- --><code>yield<!-- --></code> argument to the generator. Simple, yet effective. Since nested functions allow for nonlocal exits, <!-- --><code>break<!-- --></code>, <!-- --><code>continue<!-- --></code>, or <!-- --><code>goto<!-- --></code> out of the for loop body work too by doing a <!-- --><code>goto<!-- --></code> to the appropriate place outside of the loop.<!-- --></p>
<!-- --><p>It&#39;s unlikely that standard C would ever attempt to integrate a feature like this. C++20 now has an extremely flexible and complicated coroutine feature, based on compile-time coroutine transformations, and you can probably implement generators using it, though the resulting feature probably wouldn&#39;t be able to so straightforwardly compose with local functions.<!-- --></p></div></div></div>
  </body>
</html>
