<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://phoboslab.org/log/2021/11/qoi-fast-lossless-image-compression">Original</a>
    <h1>Lossless Image Compression in O(n) Time (2021)</h1>
    
    <div id="readability-page-1" class="page"><div>	
	<div>
		
		<p>— Wednesday, November 24th 2021</p>
	</div>
	

	<p>Introducing QOI — the <em><a href="https://qoiformat.org">Quite OK Image Format</a></em>. It losslessly compresses RGB and
RGBA images to a similar size of PNG, while offering a <strong>20x-50x</strong> speedup in 
compression and <strong>3x-4x</strong> speedup in decompression. All single-threaded, no 
SIMD. It&#39;s also <strong>stupidly simple</strong>.</p>
<p>tl;dr: 300 lines of C, single header, 
<a href="https://github.com/phoboslab/qoi">source on github</a>,
<a href="https://phoboslab.org/files/qoibench/">benchmark results here</a>.</p>
<p><img src="https://phoboslab.org/content/assets/qoi-sample.png" alt="QOI compression"/></p>
<p>I want to preface this article by saying that I have no idea what I&#39;m doing.
I&#39;m not a compression guy. I barely understand how Huffman Coding and DCT works.
Luckily, QOI uses neither. </p>
<p>I was just tinkering with some ideas that I <em>thought</em> would <em>maybe</em> compress 
images. The result surprised me quite a bit.</p>
<h2>Why? A Short Rant.</h2>
<p>File formats. They suck. I absolutely loathe the usual suspects. PNG, JPEG or
even worse MPEG, MOV, MP4. They burst with complexity at the seams. Every tiny
aspect screams <em>“design by consortium”</em>.</p>
<p>A while ago <a href="https://phoboslab.org/log/2019/06/pl-mpeg-single-file-library">I dabbled into MPEG</a> a 
bit. The basic ideas for video compression in MPEG are ingenious, even more so
for 1993, but the resulting file format is an abomination.</p>
<p>I can almost picture the meeting of the <em>Moving Picture <strong>Experts</strong> Group</em> where 
some random suit demanded there to be a way to indicate a video stream is 
copyrighted. And thus, the <code>copyright</code> bit flag made its way into the standard 
and successfully stopped movie piracy before it even began.</p>
<p>MPEG, an industry standard conceived 3 decades past, all patents long expired, 
all professional interest abandoned. Yet, the holy specification — 
there named <em>ISO/IEC 11172-2</em> — is a well guarded secret, revealed only to those
that fork over a cool $200 to endow the sacred work of the ISO.</p>
<p>Alternative open video codecs exist, but are again immensely complex. They
compete with the state of the art, require huge libraries, are compute hungry
and difficult to work with. Alternatives for PNG all compete on the compression
ratio too, with ever increasing complexity.</p>
<p>There absolutely is a market for video, audio and image codecs that trade
compression ratio for speed and simplicity, but no one is serving it. (Well, 
<a href="http://www.radgametools.com/">these guys maybe</a>, but it&#39;s all proprietary.)</p>
<p>Yes, <a href="https://github.com/nothings/stb">stb_image</a> saved us all from the pains of 
dealing with libpng and is therefore used in countless games and apps. A while 
ago I aimed to do the same for video with 
<a href="https://github.com/phoboslab/pl_mpeg">pl_mpeg</a>, with some success.</p>
<p>But with all that we learned, why did no one go back and implement a <em>simple</em>
compression scheme to compete with PNG, but without the cruft? Why did no one 
implement a <em>simple</em> video compression scheme similar to MPEG, but in a <em>sane</em> 
file format instead?</p>
<p>I was tinkering to do the latter: to take parts of MPEG-1 and make it easier to
parse, easier to accelerate on a GPU. A <em>good enough</em> video codec.</p>
<p>Instead I stumbled into a solution for the former: a lossless image format that
competes with PNG for some use cases. A slightly worse compression ratio, but 
magnitudes less complexity.</p>
<h2>Technical Details</h2>
<p>QOI encodes and decodes images in a single pass. It touches every pixel just
once.</p>
<p>Pixels are encoded as</p>
<ul>
<li>a run of the previous pixel</li>
<li>an index into an array of previously seen pixels</li>
<li>a difference to the previous pixel value in r,g,b</li>
<li>full r,g,b or r,g,b,a values</li>
</ul>
<p>The resulting values are packed into chunks starting with a 2- or 8-bit <code>tag</code> 
(indicating one of those methods) followed by a number of data bits. All of
these chunks (<code>tag</code> and data bits) are byte aligned, so there&#39;s no bit twiddling
needed between those chunks.</p>
<p>The different chunk types are:</p>
<h3>1. A run of the previous pixel</h3>
<p>If the current pixel is exactly the same as the previous pixel, the run length
is increased by 1. When a pixel is encountered that is different from the 
previous one, this run length is saved to the encoded data and the current pixel
is packed by one of the other 3 methods.</p>
<pre><code>┌─ QOI_OP_RUN ────────────┐
│         Byte[0]         │
│  7  6  5  4  3  2  1  0 │
│───────┼─────────────────│
│  1  1 │       run       │
└───────┴─────────────────┘
2-bit tag b11
6-bit run-length repeating the previous pixel: 1..62</code></pre>
<h3>2. An index into a previously seen pixel</h3>
<p>The encoder keeps a running array of the 64 pixels it previously encountered.
When the encoder finds the current pixel still present in this array, the index 
into this array is saved to the stream.</p>
<p>To keep things <code>O(n)</code> when encoding, there&#39;s only one lookup into this array. 
The lookup position is determined by a “hash” of the rgba value (really just 
<code>(r * 3 + g * 5 + b * 7 + a * 11</code>). A linear search or some more complex bookkeeping 
would result in a marginally better compression ratio, but would also slow things 
down a bit.</p>
<pre><code>┌─ QOI_OP_INDEX ──────────┐
│         Byte[0]         │
│  7  6  5  4  3  2  1  0 │
│───────┼─────────────────│
│  0  0 │     index       │
└───────┴─────────────────┘
2-bit tag b00
6-bit index into the color index array: 0..63</code></pre>
<h3>3. The difference to the previous pixel</h3>
<p>When the current pixel color is not too far from the previous one, the
difference to the previous pixel is saved to the stream.</p>
<p>This comes in 2 different flavors, depending on how big the difference is. Note
that this focuses on the RGB value; alpha changes are more costly.</p>
<pre><code>┌─ QOI_OP_DIFF ───────────┐
│         Byte[0]         │
│  7  6  5  4  3  2  1  0 │
│───────┼─────┼─────┼─────│
│  0  1 │  dr │  dg │  db │
└───────┴─────┴─────┴─────┘
2-bit tag b01
2-bit   red channel difference from the previous pixel -2..1
2-bit green channel difference from the previous pixel -2..1
2-bit  blue channel difference from the previous pixel -2..1


┌─ QOI_OP_LUMA ───────────┬─────────────────────────┐
│         Byte[0]         │         Byte[1]         │
│  7  6  5  4  3  2  1  0 │  7  6  5  4  3  2  1  0 │
│───────┼─────────────────┼─────────────┼───────────│
│  1  0 │   diff green    │   dr - dg   │  db - dg  │
└───────┴─────────────────┴─────────────┴───────────┘

2-bit tag b10
6-bit green channel difference from the previous pixel -32..31
4-bit   red channel difference minus green channel difference -8..7
4-bit  blue channel difference minus green channel difference -8..7</code></pre>
<h3>4. Full rgb/rgba values</h3>
<p>If all previous methods fail, the rgb or rgba values are saved to the stream as full bytes.</p>
<pre><code>┌─ QOI_OP_RGB ────────────┬─────────┬─────────┬─────────┐
│         Byte[0]         │ Byte[1] │ Byte[2] │ Byte[3] │
│  7  6  5  4  3  2  1  0 │ 7 .. 0  │ 7 .. 0  │ 7 .. 0  │
│─────────────────────────┼─────────┼─────────┼─────────│
│  1  1  1  1  1  1  1  0 │   red   │  green  │  blue   │
└─────────────────────────┴─────────┴─────────┴─────────┘
8-bit tag b11111110
8-bit   red channel value
8-bit green channel value
8-bit  blue channel value

┌─ QOI_OP_RGBA ───────────┬─────────┬─────────┬─────────┬─────────┐
│         Byte[0]         │ Byte[1] │ Byte[2] │ Byte[3] │ Byte[4] │
│  7  6  5  4  3  2  1  0 │ 7 .. 0  │ 7 .. 0  │ 7 .. 0  │ 7 .. 0  │
│─────────────────────────┼─────────┼─────────┼─────────┼─────────│
│  1  1  1  1  1  1  1  1 │   red   │  green  │  blue   │  alpha  │
└─────────────────────────┴─────────┴─────────┴─────────┴─────────┘
8-bit tag b11111111
8-bit   red channel value
8-bit green channel value
8-bit  blue channel value
8-bit alpha channel value</code></pre>
<p>That&#39;s it.</p>
<p>If you have a minute, please read through the 
<a href="https://github.com/phoboslab/qoi/blob/master/qoi.h">qoi.h</a> source.</p>
<h2>Onward</h2>
<p>Seriously, I&#39;m dumbfounded. BMP and TIFF have run-length-encoding and then GIF
comes around with LZW. But there&#39;s nothing in between. Why? I found the space
between RLE and LZW to be large enough to spend many days on. And there&#39;s a lot 
more to explore.</p>
<p>Working on QOI was a lot of fun. I had a &#34;test runner&#34; with some sample
images lying around. Seeing how every change I made affected the compression
ratio was quite exciting.</p>
<p>With some more work, QOI could serve as the basis for a lossless video codec, 
suitable for screencasts and the like.</p>
<p>SIMD acceleration for QOI would also be cool but (from my very limited knowledge
about some SIMD instructions on ARM), the format doesn&#39;t seem to be well suited
for it. Maybe someone with a bit more experience can shed some light?</p>
<p>I&#39;m also quite hyped to explore the even larger space of a <em>simple</em>, lossy
image compression format. Many texture compression schemes have very exciting
ideas, yet there&#39;s nothing that competes with JPEG but with <em>less</em> complexity.</p></div></div>
  </body>
</html>
