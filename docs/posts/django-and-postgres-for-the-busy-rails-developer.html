<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://andyatkinson.com/django-python-postgres-busy-rails-developer">Original</a>
    <h1>Django and Postgres for the Busy Rails Developer</h1>
    
    <div id="readability-page-1" class="page"><article>

            <!-- .post-header -->

            
            <div>
                <ul><li><a href="#ruby-versus-python">Ruby versus Python</a></li><li><a href="#language-runtime-management">Language runtime management</a></li><li><a href="#library-management">Library management</a></li><li><a href="#linting-and-formatting">Linting and formatting</a></li><li><a href="#postgres-adapter">Postgres adapter</a></li><li><a href="#migrations-in-rails">Migrations in Rails</a></li><li><a href="#migrations-in-django">Migrations in Django</a></li><li><a href="#command-line-vibes">Command line vibes</a></li><li><a href="#interactive-console-repl">Interactive console (REPL)</a></li><li><a href="#projects-and-apps">Projects and Apps</a></li><li><a href="#postgres-details">Postgres details</a></li><li><a href="#no-migration-safety-concept">No migration safety concept</a></li><li><a href="#adding-a-constraint">Adding a constraint</a></li><li><a href="#django-models">Django models</a></li><li><a href="#previewing-ddl">Previewing DDL</a></li><li><a href="#resources">Resources</a></li><li><a href="#wrap-up">Wrap Up</a></li></ul>
                <p>About 10 years ago I wrote a post <a href="https://metavee.github.io/blog/2014/01/02/postgres-for-the-busy-mysql-developer">PostgreSQL for the Busy MySQL Developer</a>, as part of switching from MySQL to Postgres for my personal and professional projects, wherever I could.</p>

<p>Recently I had the chance to work with Python, Django, and Postgres together, as a long-time and busy Rails developer.</p>

<p>There were some things I thought were really nice. So am I switching?</p>

<p>The team I worked with was experienced with Django, so I was curious to learn from them about popular libraries, idiomatic code, and tooling.</p>

<p>In this post, I‚Äôll briefly cover the database parts of Django using Postgres of course, highlight some libraries and tools, and compare things to Ruby on Rails. You‚Äôll find a small Django repo towards the end as well.</p>

<h2 id="ruby-versus-python">Ruby versus Python</h2>
<p>Ruby and Python are both general purpose programming languages. On the similarity side, they can both be used to write script style code, or organize code into classes using object oriented paradigms.</p>

<p>In local development, it felt like the execution of Python was perhaps faster than Ruby, however I‚Äôve noticed that new apps are always fast to work with, given how little code is being loaded and executed.</p>

<h2 id="language-runtime-management">Language runtime management</h2>
<p>As a developer we typically need to run multiple versions of Ruby, Python, Node, and other runtimes, to support different codebases, and to avoid modifying our system installation.</p>

<p>In Ruby I use <a href="https://github.com/rbenv/rbenv">rbenv</a> to manage multiple versions of Ruby, and to avoid using the version of Ruby that was installed by macOS, which is usually outdated compared with the version I want for a new app.</p>

<p>In Python, I used <a href="https://github.com/pyenv/pyenv">pyenv</a> to accomplish the same thing, which seemed quite similar in use.</p>

<p>Both have concepts of a local and global version, and roughly similar commands to install and change versions.</p>

<h2 id="library-management">Library management</h2>
<p>In Ruby on Rails, <a href="https://bundler.io">Bundler</a> has been the de facto standard forever, as a way to pull in Ruby library code and make sure it‚Äôs loaded and accessible in the Rails application.</p>

<p>In Python, the team selected the <a href="https://python-poetry.org">poetry</a> dependency management tool.</p>

<p>Commands are similar to Bundler commands, for example <code>poetry install</code> is about the same as <code>bundle install</code>.</p>

<p>Dependencies can be expressed in a <code>pyproject.toml</code> file and poetry creates a lock file with specific library versions. <a href="https://toml.io/en/">TOML</a> and YAML are similar.</p>

<h2 id="linting-and-formatting">Linting and formatting</h2>
<p>In Ruby on Rails, although I personally resisted rule detection etc. for years, <a href="https://github.com/rubocop/rubocop">Rubocop</a> has become the standard, even being built in to the most recent Rails version 8.</p>

<p>Rubocop has configurable rules that can automatically reformat code or lint code for issues.</p>

<p>Formatters like <a href="https://github.com/standardrb/standard">standardrb</a> are commonly used as well.</p>

<p>For the Django app, the team selected <a href="https://github.com/astral-sh/ruff">ruff</a>, which performed formatting of code and also linted for issues like missing imports.</p>

<p>I found ruff fast and easy to use and genuinely helpful.</p>

<p>For example, sometimes I‚Äôd fire up a Django shell, skipping ruff, only to realize there are issues it would have caught.</p>

<p>On this small codebase, ruff ran instantly, so it was a no-brainer to run regularly, or even include in my code editor.</p>

<h2 id="postgres-adapter">Postgres adapter</h2>
<p>In Rails and Django, SQLite is the default database, however I wanted to use Postgres.</p>

<p>In Ruby, we have the <a href="https://github.com/ged/ruby-pg">pg gem</a> which connects the application to Postgres as a driver. This does work at a lower level than the application like sending TCP requests, mapping Postgres query result responses into Ruby data types, and much more.</p>

<p>In Python, we used the <a href="https://pypi.org/project/psycopg2/">psycopg2 library</a> and I found it pretty easy to use.</p>

<p>Besides being used by the framework ORM, I created a wrapper class using psycopg2 to use for sending SQL queries outside of models.</p>

<p>For example, we inspected Postgres system catalog views to capture certain data as part of the product features.</p>

<h2 id="migrations-in-rails">Migrations in Rails</h2>
<p>Both Ruby on Rails and Django have the concept of <a href="https://guides.rubyonrails.org/active_record_migrations.html">Migrations</a>, which are Ruby or Python code files that describe a database structure change, and have a version.</p>

<p>From the Ruby or Python code files, SQL DDL (or DML) statements are generated which are run against the configured database.</p>

<p>For example, to add a table in Rails typically a developer uses the <code>create_table</code> Ruby helper as opposed to writing a <code>CREATE TABLE</code> SQL statement.</p>

<p>Adding or dropping an index or modifying a column type are other types of DDL statements that typically are performed via migrations.</p>

<h2 id="migrations-in-django">Migrations in Django</h2>
<p>The Django approach has noteworthy differences and a slightly different workflow that I enjoyed more in some ways.</p>

<p>For example, changes are started in a <code>models.py</code> file, which contains all the application models (multiple models in a single file), and the database layer details about each model attribute.</p>

<p>This means that we specify database data types for columns, whether fields are unique, indexed, and more in the models file.</p>

<p>The interesting difference compared with Rails is that the next step in Django is to run <code>makemigrations</code>, which <em>generates</em> Python migration files.</p>

<p>This is different from Rails, where Rails developers would first generate a migration file to place changes into.</p>

<p>In Django, the generated migration file can be inspected or simply applied using the <code>migrate</code> command. This command is nearly identical to the Rails equivalent command <code>db:migrate</code>.</p>

<p>For a new project where we were rapidly iterating on the models and their attributes, I preferred the way Django works here to how Rails works.</p>

<h2 id="command-line-vibes">Command line vibes</h2>
<p>Here are some commands like running <code>poetry install</code>, or running <code>manage.py</code> commands like <code>shell</code> or <code>makemigrations</code>, to give you a flavor.</p>
<div><div><pre><code><span>poetry</span> <span>install</span>
<span>poetry</span> <span>run</span> <span>python</span> <span>manage</span><span>.</span><span>py</span> <span>dbshell</span>   <span># psql in postgres
</span><span>poetry</span> <span>run</span> <span>python</span> <span>manage</span><span>.</span><span>py</span> <span>shell</span> <span># Django shell
</span><span>Poetry</span> <span>run</span> <span>python</span> <span>manage</span><span>.</span><span>py</span> <span>makemigrations</span>   <span># Generates Python migration files, can be customized
</span><span>Poetry</span> <span>run</span> <span>python</span> <span>manage</span><span>.</span><span>py</span> <span>migrate</span> <span># runs them. Doesn‚Äôt show SQL by default.
</span></code></pre></div></div>

<h2 id="interactive-console-repl">Interactive console (REPL)</h2>
<p>Both Django and Rails use interpreted languages, Python and Ruby respectively, that each support an interactive execution environment.</p>

<p>This environment is called a <em>read, eval, print loop</em> or REPL for short.</p>

<p>In Rails, the Ruby REPL ‚Äúirb‚Äù is launched and Rails application code is loaded automatically when running the <a href="https://guides.rubyonrails.org/command_line.html">rails console</a> command.</p>

<p>In Django, the equivalent command is running <a href="https://docs.djangoproject.com/en/5.1/ref/django-admin/#shell">shell</a>, however application code needs to be imported before it can be used, using <code>import</code> statements.</p>

<p>Both frameworks also support opening a database client, by running <code>dbconsole</code> in Rails or <code>dbshell</code> in Django.</p>

<p>When Postgres is configured, these both open a psql session.</p>

<h2 id="projects-and-apps">Projects and Apps</h2>
<p>In Django, projects and applications are separate concepts.</p>

<p>In my experimental project, I made a ‚Äúbooksproject‚Äù project and a ‚Äúbooks‚Äù app.</p>

<p>Check out the <a href="https://github.com/andyatkinson/booksproject">booksproject repo</a>.</p>

<h2 id="postgres-details">Postgres details</h2>
<p>The books app models are Author, Publisher, and Books.</p>

<p>The tables for those models are contained in a custom schema <code>booksapp</code>, and Django is configured to access it.</p>

<p>The application connects to Postgres as the <code>booksapp</code> user and the dev database is called <code>books_dev</code>.</p>

<h2 id="no-migration-safety-concept">No migration safety concept</h2>
<p>There‚Äôs no concept of what I‚Äôd call ‚Äúsafety‚Äù for migrations for either framework out of the box.</p>

<p>Operations like adding indexes in Postgres don‚Äôt use the concurrently keyword by default for example.</p>

<p>We can add safety using additional libraries. At a smaller scale of data and query volume, even unsafe operations will be fine, but I think some visibility into blocking operations would still be helpful earlier.</p>

<h2 id="adding-a-constraint">Adding a constraint</h2>
<p>In models, add <code>unique=True</code> to a field definition. After running <code>makemigrations</code> a migration for a unique index will be created.</p>

<p>In Active Record we might generate the migration file first, then fill in the create statement for a unique index.</p>

<h2 id="django-models">Django models</h2>
<p>When querying a model like Book, we‚Äôd use <code>objects</code>, which returns a QuerySet object with one or more books.</p>

<p>The <code>filter()</code> method will generate a SQL query with a <code>WHERE</code> clause to filter down the rows, or all rows can be accessed using <code>all()</code>.</p>

<p>For example:</p>
<div><div><pre><code><span>Model</span><span>.</span><span>objects</span><span>.</span><span>filter</span><span>()</span>
<span>Model</span><span>.</span><span>objects</span><span>.</span><span>first</span><span>()</span>
<span>Model</span><span>.</span><span>objects</span><span>.</span><span>all</span><span>()</span>
</code></pre></div></div>

<p>Since Python is a whitespace and indentation sensitive language, we‚Äôd indent the attributes within <code>create()</code> by 4 spaces, as shown below:</p>
<div><div><pre><code><span>Thing</span><span>.</span><span>models</span><span>.</span><span>create</span><span>(</span>
    <span>attr1</span><span>=</span><span>val</span><span>,</span>
    <span>attr2</span><span>=</span><span>val</span>
<span>)</span>
</code></pre></div></div>

<h2 id="previewing-ddl">Previewing DDL</h2>
<p>The generated SQL DDL isn‚Äôt displayed when running <code>migrate</code> by default.</p>

<p>However, unlike Rails, Django provides a mechanism to preview it.</p>

<p>To do that, run the <code>sqlmigrate</code> command instead of <code>migrate</code>.</p>

<p>For example, to print the 0001 migration DDL:</p>
<div><div><pre><code>python manage.py sqlmigrate books 0001
</code></pre></div></div>
<div><div><pre><code><span>BEGIN</span><span>;</span>
<span>--</span>
<span>-- Create model Author</span>
<span>--</span>
<span>CREATE</span> <span>TABLE</span> <span>&#34;books_author&#34;</span> <span>(</span><span>&#34;id&#34;</span> <span>bigint</span> <span>NOT</span> <span>NULL</span> <span>PRIMARY</span> <span>KEY</span> <span>GENERATED</span> <span>BY</span> <span>DEFAULT</span> <span>AS</span> <span>IDENTITY</span><span>,</span> <span>&#34;first_name&#34;</span> <span>varchar</span><span>(</span><span>200</span><span>)</span> <span>NOT</span> <span>NULL</span><span>,</span> <span>&#34;last_name&#34;</span> <span>varchar</span><span>(</span><span>200</span><span>)</span> <span>NOT</span> <span>NULL</span><span>);</span>
<span>COMMIT</span><span>;</span>
</code></pre></div></div>

<p>Note that Django uses an identity column for the primary key, and as of Rails 8 Active Record does not.</p>

<h2 id="resources">Resources</h2>
<p>For the basics of an Author, Publisher, and Books models, or Postgres configuration including a custom schema and user, check out <a href="https://github.com/andyatkinson/booksproject">booksproject</a> repo.</p>

<p>To collect random Django tips, I‚Äôve created a <a href="https://metavee.github.io/django-tips">django-tips</a> page, to be used in a similar way as my <a href="https://metavee.github.io/rails-tips">rails-tips</a> and <a href="https://metavee.github.io/postgresql-tips">postgresql-tips</a> pages, mostly as a reference for myself, and possibly as a useful resource for others.</p>

<h2 id="wrap-up">Wrap Up</h2>
<p>Do you have any similarities and differences between Django and Rails to share? I‚Äôd love to hear from you.</p>

<p>üòÖ And no, I‚Äôm not ‚Äúswitching‚Äù from Rails and Ruby, but I did enjoy working with Python and Django.</p>

<p>Thanks for reading.</p>

            </div>
            
            
<!-- .comments-area -->




        </article></div>
  </body>
</html>
