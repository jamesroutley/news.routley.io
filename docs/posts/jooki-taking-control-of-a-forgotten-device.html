<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nv1t.github.io/blog/reviving-jooki/">Original</a>
    <h1>Jooki – Taking Control of a Forgotten Device</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>Jooki was a dream come true for parents—an intuitive, screen-free audio player that let kids enjoy music and stories with the tap of a token. But that dream turned into frustration when the company behind Jooki went bankrupt, leaving countless devices bricked and families frustrated. But what if Jooki isn’t as dead as it seems?</p><p>This blog post isn’t just about fixing a broken audio player—it’s about peeling back the layers of its firmware, finding hidden exploits, a backdoor and unlocking code execution.</p><p>With a bit of ingenuity, we might just breathe new life into these abandoned devices—on our own terms. Ready to dive into the rabbit hole? Let’s crack this thing open.</p><div><p><span><svg><use href="#note-notice"></use></svg></span>Note</p><p><strong>A Call to the Creator of the Jooki Box</strong></p><p>If you are reading this, please consider open-sourcing your creation. Jooki is a well-crafted piece of hardware with a dedicated user base, and making it open-source could ensure its longevity beyond your company. By opening it up to the community, you would allow it to live on, evolve, and continue bringing joy to users for years to come.</p></div><p><img src="https://nv1t.github.io/blog/img/2025/74f34bded45f0241cb9ac4c4dfddd0c8.png" alt="An internal view of an electronic device with a visible circuit board and components. Key components include a cylindrical black component wrapped in foam on the right side (labeled 1), a round metal speaker unit on the left (labeled 2), a microSD card slot on the circuit board (labeled 3), a rectangular wireless module with labeled text and certification marks (labeled 4), and a smaller integrated circuit chip with a QR code printed on it (labeled 5). The device casing is blue with orange accents, and several wires and screws secure the components in place"/></p><ol><li>Battery</li><li>Noise Maker</li><li>8GB SD Card</li><li>ESP32 WROVER-E</li><li>???</li></ol><p>We are looking into the SD Card of a Jooki Gen 2. If you have a Gen 1 laying around, feel free to send one to me and I will have a look. Until then, i believe the main idea and software is similar on both devices.</p><h2 id="filesystem">Filesystem</h2><p><img src="https://nv1t.github.io/blog/img/2025/4abd4c11e2afaa1ec5b64aaeae5f68b5.png" alt="The image shows a screenshot of a partition table from a disk image file named ‘jooki.200.img,’ which has a total size of 7.95 GB. The table lists multiple partitions with details such as their labels, file systems, sizes, and sector ranges. At the top, there is an unallocated space of 25.1 MB. Below it, a partition labeled ‘factory’ uses the Ext4 file system and has a size of 268 MB. Two partitions, ‘$Noname 02’ and ‘$Noname 04,’ are also formatted as Ext4, each with a size of 772 MB. There is a ‘swap’ partition with a size of 67.1 MB, but its file system type is marked as unknown. Additional partitions include ‘data,’ which is 134 MB and uses the Ext4 file system, ‘config,’ which is 268 MB and formatted as FAT, and ‘content,’ which is 5.64 GB and also uses the Ext4 file system. The table also includes GUIDs and the starting and ending sector numbers for each partition."/>
There are multiple Partitions on the 8GB SD Card. The first 3 partitions contain linux filesystems. I think <code>$Noname 02</code> and <code>$Noname 04</code> are identical whereas factory contains a basic linux installation of this device without any fancy stuff. The partitioning and updating of the device is done over <code>mender</code> with a system redundancy with 2 partitions to keep the application from breaking. (see Part over <a href="https://mender.io">Mender</a> later on)</p><p>The <code>data</code> partition contains configuration stuff for spotify, mender and some “Flags” which we discuss later.</p><p>Logfiles are mostly stored on <code>config</code> partition on this device. Furthermore, a custom <code>jooki.conf</code> resides here as well. This config file can be written and seen through the web interface as well. We will look into this later on.
<img src="https://nv1t.github.io/blog/img/2025/1183145907839f57fbfe865520f494ce.png" alt="The image shows a screenshot of a file system explorer focused on a partition labeled ‘config’ from a 7.95 GB disk image. The explorer displays the folder structure within the ‘config’ partition. The main directory, labeled ‘$Root,’ contains several items, including folders named ‘LOG,’ ‘syslog-ng,’ and ‘System Volume Information,’ as well as individual files. Among the files listed are ‘jooki.conf,’ ‘syslog-ng.persist,’ ‘syslog-ng.persist-,’ and a file with a shortened name ‘_YSLOG~1.PER.’ The left pane provides a hierarchical view of the file system, showing the ‘config’ partition and its subdirectories, while the right pane displays the detailed contents of the ‘$Root’ directory."/></p><p>The last one is the <code>content</code> partition, which has, as you have guessed it, the content and multiple json files with token, audio configuration, uploads and more.
The filenames of the uploads are only the token ids and not encrypted. They are just normal MP3 files.
<img src="https://nv1t.github.io/blog/img/2025/2a12fd4f378470304c1920a78b8c7bab.png" alt="The image shows a screenshot of a file system explorer displaying the contents of a partition labeled ‘content’ from a 7.95 GB disk image. The file structure is focused on a folder named ‘$Root/jooki.’ The left pane shows a hierarchical view, highlighting folders such as ‘artwork,’ ‘assets,’ ‘uploads,’ and a system folder ’lost+found.’ The right pane displays the detailed contents of the ‘jooki’ folder, including files like ‘audiocfg.json,’ ‘audiocfg.json.bak,’ ‘audiocfg.json.new,’ ‘playlists.json,’ ‘playstate.json,’ ’tokens.json,’ ’tokens.json.bak,’ and ’tracks.json.’ Subfolders such as ‘artwork’ and ‘uploads’ contain additional files, including images like ‘2412c79406eccd56.jpg.’ The interface lists JSON configuration files and media files organized into subdirectories."/></p><p>As all of these configurations and stuff are located in different positions and are mounted on boot, it makes sense if you want to modify anything on the device to look into what you would like to achieve and where to put it best.</p><p><img src="https://nv1t.github.io/blog/img/2025/2cef3ddd728a125869c13c27985e1bbf.png" alt="The image displays the content of a Linux fstab configuration file, showing the mounting configuration for various filesystems. The root filesystem (/dev/root) is mounted on / with ‘auto’ as the type and ‘defaults’ as the options, with a dump frequency and pass number of 1 and 1, respectively. The proc filesystem is mounted on /proc with ‘proc’ as the type and ‘defaults’ as the options, while devpts is mounted on /dev/pts with ‘devpts’ as the type and options including mode=0620,ptmxmode=0666,gid=5. Two tmpfs filesystems are listed, one mounted on /run with options mode=0755,nodev,nosuid,strictatime and another on /var/volatile with default options. Additionally, /dev/mmcblk0p5 is mounted on /data with ‘auto’ as the type and ‘defaults’ as the options, /dev/mmcblk0p6 is mounted on /mnt/config using the VFAT file system with rw,sync options, and /dev/mmcblk0p7 is mounted on /jooki/external with ‘auto’ as the type and rw as the option. Dump frequencies and pass numbers are configured as 0 or 2 for most entries."/></p><h2 id="mender-ota">Mender OTA</h2><p>The Jooki box utilizes <a href="https://mender.io/">Mender</a>, an open-source over-the-air (OTA) software updater, to manage its software updates. It operates with a client-server architecture, where the <strong>Mender client</strong> runs on the device and periodically contacts the <strong>Mender server</strong> to check for available updates. Updates are delivered as <strong>atomic, dual-partition</strong> installations, ensuring that if an update fails, the device can automatically <strong>rollback</strong> to its previous working state, preventing bricked devices. Mender also supports <strong>state scripts</strong>, allowing pre- and post-update automation, and offers security features like TLS encryption and device authentication.</p><p>The configuration for the Mender client is primarily stored in the <code>/etc/mender/mender.conf</code> file on the device’s root filesystem. This JSON-formatted file defines various parameters for Mender’s operation, such as server URL, authentication settings, and polling intervals.</p><pre tabindex="0"><code>{
    &#34;InventoryPollIntervalSeconds&#34;: 3600,
    &#34;RetryPollIntervalSeconds&#34;: 60,
    &#34;ServerURL&#34;: &#34;https://mender2.muuselabs.com&#34;,
    &#34;StateScriptRetryIntervalSeconds&#34;: 300,
    &#34;StateScriptRetryTimeoutSeconds&#34;: 86400,
    &#34;StateScriptTimeoutSeconds&#34;: 60,
    &#34;TenantToken&#34;: &#34;dummy&#34;,
    &#34;UpdatePollIntervalSeconds&#34;: 120
}
</code></pre><p>Muuselabs uses their own Mender Server located at <code>https://mender2.musselabs.com</code> which is periodically queried if an update exists every 2 minutes. The Update Server seems to be down though. And i think Mender uses some way of checking the legitimacy of the server, so it can’t be intercepted.</p><p><strong>Note</strong>: if you can get control over <code>mender2.muuselabs.com</code> though, you can deploy a new firmware to all devices.</p><p>The command <code>mender</code> is the one, you want to look into. This controls everything related to this.</p><h2 id="booting-up-the-device">Booting up the device</h2><p>Everything is controlled over two possible methods:</p><ol><li>MQTT</li><li>HTTP Server</li></ol><p>The MQTT-Server basic and you can even set up a Home lab integration to control the jooki. I will not go into detail here, as i didn’t take a look into the MQTT integration and i don’t have a homelab.</p><p>But the HTTP Variant has some interesting quirks to know about.</p><h3 id="http-server">HTTP Server</h3><p>The HTTP Server provides multiple Endpoints to access:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>mg_register_http_endpoint</span>(iVar3,<span>&#34;/ui&#34;</span>,<span>&amp;</span>LAB_00419f24);
</span></span><span><span><span>mg_register_http_endpoint</span>(iVar3,<span>&#34;/favicon.ico&#34;</span>,<span>&amp;</span>LAB_00419e78);
</span></span><span><span><span>mg_register_http_endpoint</span>(iVar3,<span>&#34;/setup&#34;</span>,<span>&amp;</span>LAB_0041a0e4);
</span></span><span><span><span>mg_register_http_endpoint</span>(iVar3,<span>&#34;/upload&#34;</span>,handle_upload);
</span></span><span><span><span>mg_register_http_endpoint</span>(iVar3,<span>&#34;/ping&#34;</span>,<span>&amp;</span>LAB_0041a0c8);
</span></span><span><span><span>mg_register_http_endpoint</span>(iVar3,<span>&#34;/wifi&#34;</span>,<span>&amp;</span>LAB_00419dcc);
</span></span><span><span><span>mg_register_http_endpoint</span>(iVar3,<span>&#34;/cmd&#34;</span>,<span>&amp;</span>LAB_00419a80);
</span></span><span><span><span>mg_register_http_endpoint</span>(iVar3,<span>&#34;/api/wifi/v1/add&#34;</span>,<span>&amp;</span>LAB_004196a0);
</span></span><span><span><span>mg_register_http_endpoint</span>(iVar3,<span>&#34;/api/wifi/v1/restart&#34;</span>,<span>&amp;</span>LAB_004199c8);
</span></span><span><span><span>mg_register_http_endpoint</span>(iVar3,<span>&#34;/flags&#34;</span>,<span>&amp;</span>LAB_004194b4);
</span></span><span><span><span>mg_register_http_endpoint</span>(iVar3,<span>&#34;/config&#34;</span>,<span>&amp;</span>LAB_004192d4); <span>// displays config
</span></span></span><span><span><span></span><span>mg_register_http_endpoint</span>(iVar3,<span>&#34;/set_config&#34;</span>,<span>&amp;</span>LAB_00419140); <span>// writes jookie config
</span></span></span><span><span><span></span><span>mg_register_http_endpoint</span>(iVar3,<span>&#34;/ll&#34;</span>,<span>&amp;</span>LAB_00419010); <span>// system command
</span></span></span><span><span><span></span><span>mg_register_http_endpoint</span>(iVar3,<span>&#34;/rpc&#34;</span>,<span>&amp;</span>LAB_00418e90);
</span></span></code></pre></div><p>The most interesting ones are:</p><ul><li><code>/ll</code>: provides a root backdoor</li><li><code>/config</code>: displays the user controlled <code>jookie.conf</code> in a textarea</li><li><code>/set_config</code>: sets the config</li><li><code>/flags</code>: sets “flags”, which do certain things. they are basically the control mechanism for everything.</li></ul><p>We talk about the backdoor and possible ways of Remote Code Execution on the device in a later chapter.</p><h2 id="controlling-with-flags">Controlling with flags</h2><p>Flags are an interesting concept in controlling your device. I have used this concept in an early software of mine as well.
Startup Scripts check for the existence of certain files in the directory <code>/data/mode</code>. For example the file <code>S90_dropbear.sh</code> checks for the flag <code>IN_PRODUCTION</code> or <code>FACTORY</code> and start dropbear faster and not without a 20 seconds sleep.</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span>if</span> <span>[</span> -e /etc/jooki.conf <span>]</span>; <span>then</span>
</span></span><span><span>  source /etc/jooki.conf
</span></span><span><span><span>fi</span>
</span></span><span><span>
</span></span><span><span><span>if</span> <span>[</span> -r /data/mode/IN_PRODUCTION -o -r /data/mode/FACTORY <span>]</span>; <span>then</span>
</span></span><span><span>  /usr/sbin/dropbear &amp;
</span></span><span><span><span>else</span>
</span></span><span><span>  sleep <span>20</span> <span>&amp;&amp;</span> /usr/sbin/dropbear &amp;
</span></span><span><span><span>fi</span>
</span></span><span><span>
</span></span><span><span>/bin/chmod og-rwx /home/root/.ssh/authorized_keys
</span></span><span><span>/bin/chmod og-rwx /home/root/.ssh
</span></span></code></pre></div><p>A lot of these flags exist. The ones I identified are the ones below:</p><ul><li><strong>NO_APP</strong>: blocks the startup of the applications, like GPIO controls, esp32 controls, web controls. Only the Linux will boot</li><li><strong>ESP32_FIRMARE_LOADED</strong>: This flag is set after a successful reprogram of the ESP32. If you want to reprogram it, remove this flag and the Jooki will run the function <code>program_firmware</code> and reprogram the ESP32 with a known good firmware image.</li><li><strong>TOY_SAFE_ON / TOY_SAFE_OFF</strong>: Enables/Disables the Toy Safe functionality.</li><li><strong>WIFI_ON / WIFI_OFF</strong>: Enables/Disables Wifi.</li><li><strong>SPOTIFY_ON / SPOTIFY_OFF</strong>: controls the startup of the Spotify control application</li><li><strong>DISABLE_DHCP</strong>: The Jooki does not try to get a DHCP lease</li><li><strong>OTA2_STEP</strong>: Does an Over the air update (probably not wanted anymore)</li><li><strong>MENDER</strong>: ensures that the <code>mender</code> binary, used for OTA software updates, has the required <code>libpthread.so.0</code> dependency and executes it under specific conditions.</li><li><strong>MANUAL</strong>: see <code>MENDER</code></li><li><strong>FACTORY</strong>: This flag is automatically set, if the ESP32 is getting reprogrammed. It controls some startup behavior of applications</li><li><strong>IN_PRODUCTION</strong>: It skips the wifi configuration and does not let the application run its own wifi.</li></ul><p>There are multiple ways to execute code on the Jooki without opening it – and if necessary, you can always open it up in the end.</p><h2 id="access-to-the-webinterface">Access to the Webinterface</h2><h3 id="modifying-a-config-file">Modifying a config file</h3><p>The default <code>jooki.conf</code> file is located at <code>/etc/jooki.conf</code></p><div><pre tabindex="0"><code data-lang="bash"><span><span>export JOOKI_MACHINE<span>=</span>ml-j2000
</span></span><span><span>export JOOKI_WIFI_DEFAULT_SSID<span>=</span>mnet2
</span></span><span><span>export JOOKI_WIFI_DEFAULT_PWD<span>=</span>muuselabs256
</span></span><span><span>export JOOKI_SDCARD_MMC_DEV<span>=</span>mmc0
</span></span><span><span>export JOOKI_SDCARD_DEV<span>=</span>/dev/mmcblk0
</span></span><span><span>export JOOKI_PART_FACTORY<span>=</span><span>1</span>
</span></span><span><span>export JOOKI_PART_ROOTFS_A<span>=</span><span>2</span>
</span></span><span><span>export JOOKI_PART_ROOTFS_B<span>=</span><span>3</span>
</span></span><span><span>export JOOKI_PART_SWAP<span>=</span><span>4</span>
</span></span><span><span>export JOOKI_PART_DATA<span>=</span><span>5</span>
</span></span><span><span>export JOOKI_PART_CONFIG<span>=</span><span>6</span>
</span></span><span><span>export JOOKI_PART_CONTENT<span>=</span><span>7</span>
</span></span><span><span>
</span></span><span><span>export JOOKI_DISABLE_USB<span>=</span><span>1</span>
</span></span><span><span>
</span></span><span><span>export JOOKI_LOG_LEVEL<span>=</span><span>&#34;info&#34;</span>
</span></span><span><span>
</span></span><span><span>export ESP32_MMC_DEV<span>=</span>b
</span></span><span><span>export ESP32_MODULE_NAME<span>=</span>esp32sdio
</span></span><span><span>export ESP32_UART_DEV<span>=</span>/dev/ttyS0
</span></span><span><span>
</span></span><span><span>export ESP32_UART_BAUDRATE<span>=</span><span>1500000</span>
</span></span><span><span>
</span></span><span><span>export ESP32_LOG_SYSLOG<span>=</span><span>1</span>
</span></span><span><span>
</span></span><span><span>export JOOKI_DEFAULT_NFC_MODE<span>=</span><span>1</span>
</span></span><span><span>
</span></span><span><span><span>if</span> <span>[</span> -f /mnt/config/jooki.conf <span>]</span>; <span>then</span>
</span></span><span><span>  source /mnt/config/jooki.conf
</span></span><span><span><span>fi</span>
</span></span></code></pre></div><p>You can see in the end, the file <code>/mnt/config/jooki.conf</code> is being sourced.</p><p>Interestingly, this file can be set through the web server. The file is being displayed in a textarea if you call the <code>/config</code> endpoint through this function:</p><p><img src="https://nv1t.github.io/blog/img/2025/32d2e2f286f2ec8f58febf2a0cb46e44.png" alt="The image displays a snippet of C code defining a function FUN_004192e8 that takes an integer parameter param_1. The function appears to handle the reading and display of a configuration file, /mnt/config/jooki.conf. It declares a file pointer _stream, a buffer local_1018, and a stack array auStack_1014. The code initializes local_1018 and the stack array before attempting to open the configuration file in read mode using fopen. If the file cannot be opened, the function logs an error message using logger_print and sends a 500 error response with send500(param_1). If the file is successfully opened, the function sends an HTTP response with a content type of “text/html” and includes a simple HTML structure. This HTML contains a header  displaying “jooki.conf,” a  pre-filled with the file’s content, and a  for submitting changes to the configuration via /set_config. The file’s content is read into local_1018 and inserted into the response using fgets and mg_printf. The file is closed using fclose, and additional formatting is added to the response before returning. The function also modifies a value at an offset of param_1 using bitwise operations."/></p><p>If you look closely, you can spot the <code>/set_config</code> endpoint as well, which does write the config file back onto this location.</p><p>You can add a public key to the <code>authorized_keys</code>, as shown below.
<img src="https://nv1t.github.io/blog/img/2025/024b5216ae09d84a9541a98548d664b8.png" alt="The image shows a screenshot of a web page displaying the content of a configuration file named jooki.conf. At the top of the browser window, the address bar indicates a URL ending in /config, with a ‘Not secure’ warning. The page features a heading jooki.conf and a text box displaying shell commands. The commands include a conditional check [ ! -f /home/root/.ssh/authorized_keys.bak ] to verify if a backup file for SSH authorized keys exists. If it does not, a cp command is executed to create a backup of the existing /home/root/.ssh/authorized_keys file as authorized_keys.bak. The next command uses echo to overwrite the authorized_keys file with a new SSH public key, represented as ssh-rsa ."/>
After that, you should be able to connect via SSH as the user <code>root</code> with your private key and have full access to the device. You can just run arbitrary commands as well through this interface.</p><h3 id="using-the-backdoor-or-rce">Using the Backdoor or RCE</h3><p>The endpoint <code>/ll</code> takes one argument <code>action</code> which is piped into a system command. This looks like intended behavior, and it is not secured in any way.</p><p><img src="https://nv1t.github.io/blog/img/2025/1913004ef46e15485c2bcac46415ee36.png" alt="The image shows a decompiled C function, FUN_00419024, from a web controller module. The function retrieves an HTTP variable named “action” using mg_get_http_var and stores it in local_78. If the variable is not found, it logs an error and returns a 200 HTTP response with the message “Invalid request.” If the variable is found, it is executed as a system command using system. If the command fails, the function sends a 500 HTTP error response; otherwise, it returns a 200 response with the message “OK.” The use of system to execute user-provided input without sanitization could indicate a potential security vulnerability."/></p><p>One way to exploit, would be:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>curl <span>&#39;http://192.168.188.169/ll?action=touch%20/tmp/pwned&#39;</span>
</span></span></code></pre></div><p>You can do the same with the <code>/flags</code> endpoint, which is just a standard RCE.</p><p>The <code>/flags</code> endpoint is being used to set and remove flags from the device through the web interface. The flag parameter is being put together with a pre-written command with <code>snprintf</code> without being checked.
<img src="https://nv1t.github.io/blog/img/2025/db86701fefebf2a0fecd299c6627c329.png" alt="The image displays a decompiled C function FUN_004194c8 that handles HTTP requests. It retrieves the action parameter using mg_get_http_var and validates it. If the parameter is missing or invalid, the function logs an error and returns a 200 response with “Invalid request”. If the action is valid, the function determines whether to remove (rm) or create (touch) a file based on the parameter value, constructing the corresponding command string with snprintf. The command is executed using system, and if it fails, the function sends a 500 error response; otherwise, it responds with 200 and “OK”. This code highlights potential risks as it constructs and executes shell commands directly from user input without sufficient sanitization."/>
It is possible to simply add a semicolon to the command and run your own:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>curl <span>&#39;http://192.168.188.169/flags?flag=1;touch%20/tmp/pwned&amp;action=1&#39;</span>
</span></span></code></pre></div><h2 id="over-the-air-updates">Over-The-Air Updates</h2><p>In addition, the Jooki Box employs a heartbeat script, <code>/jooki/app/services/heartbeat.sh</code>, which routinely checks in at <code>https://my.jooki.rocks/api/discover/v1/heartbeat</code>. The script sends a POST request containing key device details, such as its ID, hostname, IP address, and firmware status. Under normal conditions, this endpoint simply returns a <code>200 OK</code>, signaling that all is well.</p><p>However, a critical flaw in the script’s execution mechanism introduces a significant security risk. The API can return up to 1,000 additional lines of code, prefixed by the sentinel value <code>## ML_OTA</code>, which are then executed on the Jooki device without any validation.</p><div><pre tabindex="0"><code data-lang="bash"><span><span>run_ota<span>()</span> <span>{</span>
</span></span><span><span>    /bin/ash $OTA 2&gt;&amp;<span>1</span> <span>||</span> true
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span>maybe_ota<span>()</span> <span>{</span>
</span></span><span><span>    rm -f $OTA
</span></span><span><span>    <span>if</span> grep -A1000 <span>&#39;## ML_OTA&#39;</span> <span>&#34;</span>$RESPONSE<span>&#34;</span> &gt; $OTA; <span>then</span>
</span></span><span><span>        echo <span>&#34;Running ota&#34;</span>
</span></span><span><span>        run_ota 2&gt;&amp;<span>1</span> &gt; $OTA_OUT
</span></span><span><span>        post_ota_out
</span></span><span><span>    <span>fi</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>This design appears to be intended for over-the-air (OTA) updates but, if exploited by a malicious actor, could enable remote code execution (RCE).</p><p>Worse yet, while HTTPS is used to secure these communications, the script employs <a href="http://www.dest-unreach.org/socat/">SOCAT</a> with <code>verify=0</code>, instructing it to ignore SSL certificate validation. This means an attacker could easily redirect <code>my.jooki.rocks</code> through DNS hijacking to execute arbitrary commands on affected devices.</p><p><img src="https://nv1t.github.io/blog/img/2025/d87b676565b24a27096ce5320462d9c2.png" alt="The image shows a shell script that configures API communication and sends HTTP POST requests. It defines variables such as API_SERVER (my.jooki.rocks), API_BASE (/api/discover/v1), and API_PORT (443), with the protocol set to SSL. The SOCAT variable constructs a connection string for socat with the server, port, and verify=0, disabling SSL certificate verification. The script also specifies file paths for responses (RESPONSE), OTA output (OTA_OUT), and voice files (VOICE_FILE). A function named post() formats an HTTP POST request with headers (Host, Content-Type, and Content-Length) and sends it using socat, saving the response to the RESPONSE file. The script checks for a successful response (HTTP 200) using grep. However, the use of verify=0 and socat without proper SSL verification highlights potential security vulnerabilities."/></p><p>The <code>maybe_ota</code> function only runs, when the <code>heartbeat.sh</code> scripts runs with the parameter <code>S_LIVE</code> as the first argument. This is being called in the script <code>/jooki/app/services/check_online.sh</code>. This script checks if the Box is online and afterward run the heartbeat script.</p><p><img src="https://nv1t.github.io/blog/img/2025/226ed32b0656e925f70d96050b8980a1.png" alt="The image displays a shell script designed for monitoring and interaction with a specified URL. The script starts by navigating to the directory of the script and initiating logging. A function testUrl() is defined to test the availability of a provided URL using curl, with a timeout of 30 seconds and the response time recorded. If the response begins with “OK,” it logs a successful ping and returns 0; otherwise, it checks for the presence of a temporary file (/tmp/wifi_home_connected) and logs a ping failure before returning 1. The script sets URL to my.jooki.rocks/api/discover/v1/ping and enters a loop, continuously testing the URL every 10 seconds until it succeeds. At the end, it executes a service script located at jooki/app/services/heartbeat.sh with the argument S_LIVE in the background."/>
While this oversight may not have been deliberately malicious, it creates a significant security vulnerability that could be leveraged by attackers to compromise Jooki devices at scale.</p><p><strong>Furthermore, If you get control over the <code>jooki.rocks</code> domain, you can takeover all jooki boxes remotely.</strong></p><h2 id="no-access-over-ip">No access over IP</h2><p>If you cannot access it over an IP, you have to open up the device and pop out the SD Card. This works with the Jooki Gen 2, at least. After that, you can mount the partition with the <code>/home/root/.ssh</code> directory on it. There are three of them. The Jooki only uses one. But if you want to be on the safe side, edit the file <code>authorized_keys</code> in all three. I am not sure which partition it uses to boot and didn’t want to check.</p><p><img src="https://nv1t.github.io/blog/img/2025/45bafb01d6f9b39449bc9fba197e65d9.png" alt="The image shows a file system explorer viewing the contents of a disk image named sdcard/sda.img. The left pane displays the hierarchical structure of directories, starting with the root (Root). Subdirectories include .cache, bin, boot, cgroup, data, dev, etc, home, root, jooki, lib, lost+found, and others. Within the root directory, the .ssh subdirectory is selected, and the right pane displays its contents. The .ssh folder contains a single file named authorized_keys. Additional sections in the hierarchy include Metafiles and Extra Found Files at the bottom of the directory tree."/>
Add your public key and bob’s your uncle.</p><p>Sometimes the jooki won’t connect to your Wifi or the mentioned default Wifi anymore. I didn’t find out why. But it is possible to reprogram the ESP32 with a known good image, which is located on the device itself. I tend to use the “Flags”-way more often, but that is just because it is faster.</p><h4 id="flags">Flags</h4><p>You can set and delete <code>Flags</code> in <code>/data/mode/*</code>. One of them is <code>ESP32_FIRMWARE_LOADED</code>. The existence of this file is being checked on Startup. If it doesn’t exist, it will reprogram the ESP32 and you will have a clean slate on the ESP32 again.</p><p>It will flash with the mnet2 hotspot and you can access it normally. :)</p><h4 id="official-way">Official Way</h4><p>There is also the official way. This only works, if the ESP32 is correctly working and reading the NFC Chips placed on it.</p><pre tabindex="0"><code>Turn Jooki on Start the Jooki App Tap &#34;Set up a new Jooki&#34; Tap and hold the WiFi icon for 2 seconds You should see the &#39;Fix your Jooki&#39; screen appear:
Find the orange token included in the Jooki box.
Follow the step-by-step instructions on the app screen: Hold the orange token at the back of your phone, near your phone’s rear camera (or where the NFC antenna is located on your phone). You should see the message: “Token detected successfully, please move your phone away from the token.&#34; Remove the orange token from the phone.

Hold your orange token to the phone&#39;s NFC antenna a second time Remove the orange token from the phone and place it on Jooki You will soon hear &#34;Production finished&#34; and Jooki will automatically turn off Hold the orange token a last time to the NFC antenna of the phone
</code></pre><p>This will basically reprogram the NFC Chip with this message below. You can find this message also in the references.</p><pre tabindex="0"><code>[+] TYPE: NTAG 213 144bytes (NT2H1311G0DU)
[+] Reading tag memory...

[=] MFU dump file information
[=] -------------------------------------------------------------
[=] Version..... 00 04 04 02 01 00 0F 03
[=] TBD 0....... 00 00
[=] TBD 1....... 00
[=] Signature... 27 A8 8E 6C A2 89 FA 3C 05 15 97 1E 6B 49 5F 2D
[=]              2F C3 5F 0A F0 FF E5 E5 28 07 64 1B 6A BE A4 99
[=] Counter 0... 00 00 00
[=] Tearing 0... 00
[=] Counter 1... 00 00 00
[=] Tearing 1... 00
[=] Counter 2... 00 00 00
[=] Tearing 2... BD
[=] Max data page... 43 ( 176 bytes )
[=] Header size..... 56 bytes

[=] -------------------------------------------------------------
[=] block#   | data        |lck| ascii
[=] ---------+-------------+---+------
[=]   0/0x00 | 04 60 FF 13 |   | .`..
[=]   1/0x01 | 9A 4B 70 80 |   | .Kp.
[=]   2/0x02 | 21 48 00 00 |   | !H..
[=]   3/0x03 | E1 10 12 00 | 0 | ....
[=]   4/0x04 | 01 03 A0 0C | 0 | ....
[=]   5/0x05 | 34 03 28 D1 | 0 | 4.(.
[=]   6/0x06 | 01 24 55 04 | 0 | .$U.
[=]   7/0x07 | 73 2E 6A 6F | 0 | s.jo
[=]   8/0x08 | 6F 6B 69 2E | 0 | oki.
[=]   9/0x09 | 72 6F 63 6B | 0 | rock
[=]  10/0x0A | 73 2F 73 2F | 0 | s/s/
[=]  11/0x0B | 3F 73 3D 58 | 0 | ?s=X
[=]  12/0x0C | 6A 68 48 4D | 0 | jhHM
[=]  13/0x0D | 52 5A 49 31 | 0 | RZI1
[=]  14/0x0E | 56 50 78 6C | 0 | VPxl
[=]  15/0x0F | 51 33 52 FE | 0 | Q3R.
[=]  16/0x10 | 54 03 47 6A | 0 | T.Gj
[=]  17/0x11 | 3A 73 30 45 | 0 | :s0E
[=]  18/0x12 | 02 20 4F 86 | 0 | . O.
[=]  19/0x13 | EA B0 78 42 | 0 | ..xB
[=]  20/0x14 | 78 F1 DF 3D | 0 | x..=
[=]  21/0x15 | AE BF 59 E3 | 0 | ..Y.
[=]  22/0x16 | 7E 0F 31 EA | 0 | ~.1.
[=]  23/0x17 | 87 56 C0 D3 | 0 | .V..
[=]  24/0x18 | 8A 63 71 49 | 0 | .cqI
[=]  25/0x19 | 37 7F 5E 4C | 0 | 7.^L
[=]  26/0x1A | 24 3E 02 21 | 0 | $&gt;.!
[=]  27/0x1B | 00 DE 96 AB | 0 | ....
[=]  28/0x1C | 7F 71 F9 3B | 0 | .q.;
[=]  29/0x1D | 69 D4 FF B4 | 0 | i...
[=]  30/0x1E | E6 06 3B FF | 0 | ..;.
[=]  31/0x1F | 93 3C 11 10 | 0 | .&lt;..
[=]  32/0x20 | CC 31 A3 FE | 0 | .1..
[=]  33/0x21 | 28 02 01 B4 | 0 | (...
[=]  34/0x22 | 13 7E A1 A2 | 0 | .~..
[=]  35/0x23 | 8A FE 00 00 | 0 | ....
[=]  36/0x24 | 00 00 00 00 | 0 | ....
[=]  37/0x25 | 00 00 00 00 | 0 | ....
[=]  38/0x26 | 00 00 00 00 | 0 | ....
[=]  39/0x27 | 00 00 00 00 | 0 | ....
[=]  40/0x28 | 00 00 00 BD | 0 | ....
[=]  41/0x29 | 04 00 00 FF | 0 | ....
[=]  42/0x2A | 00 05 00 00 | 0 | ....
[=]  43/0x2B | FF FF FF FF | 0 | ....
[=]  44/0x2C | 00 00 00 00 | 0 | ....
[=] ---------------------------------
</code></pre><h2 id="networking-over-usb">Networking over USB</h2><p>The script, <code>S91_ml-usb-gadget.sh</code>, is responsible for configuring the USB gadget mode on a Jooki device. It first determines if USB should be enabled by checking the <code>JOOKI_DISABLE_USB</code> variable in <code>jooki.conf</code>. If USB is disabled, the script logs a message and exits.</p><p>Otherwise, it loads necessary kernel modules and sets up the USB gadget framework under <code>/sys/kernel/config/usb_gadget/g1</code>. The script defines the device’s USB attributes (vendor ID, product ID, serial number, etc.), creates different USB functions (RNDIS networking, MTP, and ACM serial communication), and links them to a configuration.</p><p>If the required gadget directory does not exist, it falls back to using the <code>g_ether</code> kernel module for USB networking. Finally, it configures the USB network interface (<code>usb0</code>) with a static IP and, if the device is in production mode, starts the <code>dropbear</code> SSH server.</p><p>However, since <code>JOOKI_DISABLE_USB</code> is set to <code>1</code> in <code>jooki.conf</code> by default, the script does not run unless this configuration is modified. If altered, network communication over USB might be possible.</p><h2 id="connecting-to-mnet2-hotspot">Connecting to mnet2 Hotspot</h2><p>The mnet2 hotspot credentials are hardcoded into the ESP32 and i couldn’t find a way to delete it (2023-11-22)
<img src="https://nv1t.github.io/blog/img/2025/3a52c09d6c79c7e5a8ce3676b444b44b.png" alt="The image shows a Wi-Fi Hotspot configuration interface where the SSID is set to mnet2 and the password to muuselabs256"/>
By setting up a Hotspot with these credentials, the jooki box will connect to your hotspot first and can be exploited because the web interface is exposed.</p><h2 id="custom-dns">Custom DNS</h2><p>the <code>web_ctrl</code> binary opens up a DNS server on <code>UDP/53</code> which answers with his own IP for everything. I have no idea why…</p><p><img src="https://nv1t.github.io/blog/img/2025/9b1f88209a300d78fa675acbc00b1346.png" alt="The image displays the output of the dig command used to query the DNS server at 192.168.188.169 for the domain google.de. The response indicates that the query was successful with no errors (status: NOERROR) and provides the answer in the ANSWER SECTION. Here, the domain google.de resolves to the IP address 192.168.188.169 with a time-to-live (TTL) value of 10 seconds. Additional details include the query time (196 milliseconds), the server IP (192.168.188.169#53), the protocol used (UDP), and the time of the query (Wed Nov 22 09:58:12 CET 2023). The total message size is 52 bytes."/></p><h2 id="spotify-credentials">Spotify Credentials</h2><p>The Spotify credentials file ( <code>/data/spotify/credentials.bin</code>) is a binary file used to store login information for the Spotify client. It contains a username, a small identifier or flag, and an encrypted token blob. The token is stored in a Base64-encoded format but is further protected using AES encryption. The decryption process involves generating a key derived from a hashed value, making it difficult to extract the credentials without access to the correct parameters. It looks like a ZeroConf Login Mechanism.</p><p>The Spotify client reads this file during login, decrypts the stored token, and attempts authentication. I stopped here, as this seemed like a rabbit hole, but it should be possible to extract the credentials from this binary file.</p><p>However, take this information with a grain of salt, as further analysis are needed to fully understand the encryption and authentication mechanisms.</p><h2 id="logging">Logging</h2><p>Logging is not only done locally, but the logs are sent to papertrailapp, which is a logging service from solarwinds.</p><pre tabindex="0"><code>destination d_papertrail {
  tcp(
    &#34;logs6.papertrailapp.com&#34;
    port(13434)
    tls(ca_dir(&#34;/etc/ssl/certs&#34;))
    disk-buffer(
      reliable(no)
      mem-buf-length(1000)
      dir(&#34;/jooki/external/logs/syslog-ng/&#34;)
      disk-buf-size(10M)
    )
  );
};
</code></pre><h2 id="hardcoded-root">Hardcoded Root</h2><p>There is a hardcoded root password in the shadow file</p><pre tabindex="0"><code>root:$6$BHhel/vHNB8/X$k5QhO07If.9HEIKdogqNt2z0cdaPAG48meO20lU0sEAvgVGbrj8C0//8sku1aPLd/2ipzS45uKkoqYgLY48KJ/::0:99999:7:::
</code></pre><p>Maybe somebody finds the correct password for it, or the company exposes it. This way it would be possible to just connect to the device as root over SSH.</p><div><p><span><svg><use href="#tip-notice"></use></svg></span>Tip</p><p>Feel free to explore further on these questions. If you answer and write about any of them, give me shoutout and I will add your link to the list and cross that questions off.</p></div><ul><li>What is this USB behavior and how to trigger it? This would be a nice way in, if the WiFi is broken, as this has nothing to do with the ESP32 Chip.</li><li>How to add new Audio Tracks without the use of any Webinterface? What files do I have to modify?</li><li>Can we use more tokens than the provided ones? Can we create our own tokens?</li><li>What is the root password?</li><li>The Spotify connection will break eventually. I think it already has, as the API has changed since the company went out of business. Can we patch the relevant binaries?</li><li>It might be possible to reflash the ESP32 with a custom firmware, which is basically the brain of everything.</li><li>disassemble the <code>esp32_cmd binary</code>, as this communicates with the ESP32 chip and you can add wifi endpoints, configure bluetooth and other shenanigans.</li><li>Where are the system partitions on the Jooki gen1? (If anybody is willing to send me their gen1 I would look into it)</li><li>Should these RCEs be CVE Numbers? Maybe. But I don’t want to go through all the hassle of requesting numbers.</li></ul><ul><li><a href="https://blog.clickomania.ch/2019/08/29/ein-kleines-reverse-engineering-projekt/">https://blog.clickomania.ch/2019/08/29/ein-kleines-reverse-engineering-projekt/</a> (tags)</li><li><a href="https://github.com/RfidResearchGroup/proxmark3/blob/master/doc/jooki_notes.md">https://github.com/RfidResearchGroup/proxmark3/blob/master/doc/jooki_notes.md</a> (all tags)</li><li><a href="https://support.jooki.com/faq-landing">https://support.jooki.com/faq-landing</a> (Jooki Support Page)</li><li><a href="https://reddit.com/r/jooki">https://reddit.com/r/jooki</a> (best source for jooki information)</li></ul></div></div></div>
  </body>
</html>
