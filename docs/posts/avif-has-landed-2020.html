<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jakearchibald.com/2020/avif-has-landed/">Original</a>
    <h1>AVIF has landed (2020)</h1>
    
    <div id="readability-page-1" class="page"><div><p>Back in ancient July <a href="https://www.youtube.com/watch?v=F1kYBnY6mwg">I released a video</a> that dug into how lossy and lossless image compression works and how to apply that knowledge to compress a set of different images for the web. Well, that&#39;s already out of date because <em>AVIF has arrived</em>. Brilliant.</p>
<p>AVIF is a new image format derived from the keyframes of <a href="https://en.wikipedia.org/wiki/AV1">AV1 video</a>. It&#39;s a royalty-free format, and it&#39;s already supported in Chrome 85 on desktop. Android support will be added soon, Firefox is <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=avif">working on an implementation</a>, and although it took Safari 10 years to add WebP support, I don&#39;t think we&#39;ll see the same delay here, as Apple are a member of the group that created AV1.</p>
<p>What I&#39;m saying is, the time to care about AVIF is <em>now</em>. You don&#39;t need to wait for all browsers to support it – you can use <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation/List_of_default_Accept_values#Values_for_an_image">content negotiation</a> to determine browser support on the server, or use <code>&lt;picture&gt;</code> to provide a fallback on the client:</p>

<figure>
  
  <svg viewBox="0 0 679 187"><text transform="matrix(1 -.018 .018 1 3.594 22.076)"><tspan x="0" y="0">&lt;</tspan><tspan x="12.9" y="0">picture</tspan><tspan x="103.1" y="0">&gt;</tspan><tspan x="0" y="30.9">  &lt;</tspan><tspan x="38.7" y="30.9">source</tspan><tspan x="116" y="30.9"> </tspan><tspan x="128.9" y="30.9">type</tspan><tspan x="180.5" y="30.9">=&#34;</tspan><tspan x="206.3" y="30.9">image/avif</tspan><tspan x="335.2" y="30.9">&#34;</tspan><tspan x="0" y="61.9"> </tspan><tspan x="128.9" y="61.9">srcset</tspan><tspan x="206.3" y="61.9">=&#34;</tspan><tspan x="232.1" y="61.9">snow.avif</tspan><tspan x="348.1" y="61.9">&#34;&gt;</tspan><tspan x="0" y="92.8">  &lt;</tspan><tspan x="38.7" y="92.8">img</tspan><tspan x="77.4" y="92.8"> </tspan><tspan x="90.2" y="92.8">alt</tspan><tspan x="128.9" y="92.8">=&#34;</tspan><tspan x="154.7" y="92.8">Hut in the snow</tspan><tspan x="348.1" y="92.8">&#34;</tspan><tspan x="0" y="123.8"> </tspan><tspan x="90.2" y="123.8">src</tspan><tspan x="128.9" y="123.8">=&#34;</tspan><tspan x="154.7" y="123.8">snow.jpg</tspan><tspan x="257.9" y="123.8">&#34;&gt;</tspan><tspan x="0" y="154.7">&lt;/</tspan><tspan x="25.8" y="154.7">picture</tspan><tspan x="116" y="154.7">&gt;</tspan></text><path d="M659 110.7l-228.7 2-.8-98 228.6-2z"></path><text transform="matrix(1 -.008 .008 1 429.879 49.61)"><tspan x="0" y="0">If this type is supported, </tspan><tspan x="0" y="40">use this</tspan></text><path d="M368.6 40c37.6-2 58-2 58-2"></path><path d="M374.4 47l-3.4-7 2.8-7.4-16.8 8z"></path><path d="M395 69.5c33.7-1 34.5 2.8 34.5 2.8"></path><path d="M401 76.5l-3.5-7 2.8-7.4-16.8 8z"></path><text transform="translate(366 141.5)">…else this</text><path d="M307 133.4c37.3-1.5 55.5.5 55.5.5"></path><path d="M313 140.6l-3.5-7 2.8-7.4-16.8 7.8z"></path></svg>
</figure>

<p>Also, <strong><a href="https://squoosh.app">Squoosh</a> now supports AVIF</strong>, which is how I compressed the examples in this post.</p>
<p>Let&#39;s take a look at how AVIF performs against the image formats we already know and love…</p>


<h2 id="f1-photo">F1 photo</h2>
<figure>
<div><div><div><div></div></div><a href="https://jakearchibald.com/2020/avif-has-landed/demos/compare/?show=f1&amp;img=undefined" target="_blank"><svg viewBox="0 0 24 24" title="View in full page"><path d="M19 19H5V5h7V3H5a2 2 0 00-2 2v14c0 1.1.9 2 2 2h14a2 2 0 002-2v-7h-2v7zM14 3v2h3.6l-9.8 9.8 1.4 1.4L19 6.4V10h2V3h-7z"></path></svg></a></div></div>
</figure>

<p>I picked this image because it&#39;s a photo with a mixture of low frequency detail (the road) and high frequency detail (parts of the car livery). Also, there are some pretty sharp changes of colour between the red and blue. And I like F1.</p>
<p>Roughly speaking, at an acceptable quality, the WebP is almost half the size of JPEG, and AVIF is under half the size of WebP. I find it incredible that AVIF can do a good job of the image in just 18 kB.</p>
<p>Before I compare things further:</p>
<h3 id="what-is-acceptable-quality">What is &#39;acceptable quality&#39;?</h3>
<p>For the majority of images on the web, my rules are:</p>
<ul>
<li>If a user looks at the image in the context of the page, and it strikes them as ugly due to compression, then that level of compression is not acceptable. <em>But</em>, one tiny notch above that boundary is fine.</li>
<li>It&#39;s ok for the image to lose noticeable detail compared to the original, <em>unless</em> that detail is significant to the context of the image.</li>
</ul>
<p>Context is key here. Image compression should be judged at the size it&#39;ll be presented to the user, and in a similar surrounding. If you&#39;re presenting a picture as a piece of art to be examined, quality and detail preservation become more important, but that&#39;s an edge case.</p>
<p>Most images I see on the web are a much higher quality than they need to be, which results in a slower experience for users. I&#39;m generally impressed by <a href="https://www.theguardian.com/">The Guardian</a>&#39;s use of images. Take <a href="https://www.theguardian.com/world/2020/aug/28/ireland-pubs-to-remain-shut-coronavirus-cases-rise">this article</a>. If I open the image at the top of the article and zoom in, I can see the distinctive WebP artefacts. The street has been smoothed. There&#39;s some ringing around the graffiti. But we shouldn&#39;t optimise the user experience for people who might zoom in looking for flaws. When I look at the image within the article, in the size and context it&#39;s presented, I just see someone cycling past a closed pub, which is the intent of the image. The compression used there produces a small resource size, which means I saw the image quickly.</p>
<p>In this article, I&#39;m optimising images as if they were appearing in an article, where their CSS width is around 50% of their pixel width, meaning they&#39;re optimised for high-density displays.</p>
<h3 id="technique">Technique</h3>
<p>Well, &#39;technique&#39; might be too strong a word. To compress the images I used <a href="https://squoosh.app">Squoosh</a>. I zoomed the image out to 50%, dragged the quality slider down until it looked bad, then moved it back a bit. If the codec had an &#39;effort&#39; setting, I set it to maximum. I also used one or two advanced settings, and I&#39;ll point those out along the way.</p>
<p><strong>But these are just <em>my</em> reckons</strong>. I&#39;m comparing the images using the human balls of eye I keep safely inside my skull, rather than any kind of algorithm that tries to guess how humans perceive images. And of course, there are biases with human perception.</p>
<p>In fact, when I showed this article to <a href="https://twitter.com/kornelski">Kornel Lesiński</a> (who actually knows what he&#39;s talking about when it comes to image compression), he was unhappy with my F1 comparison above, because the <a href="https://github.com/kornelski/dssim">DDSIM score</a> of the JPEG is much lower than the others, meaning it&#39;s closer in quality to the original image, and… he&#39;s right.</p>
<p>I struggled to compress the F1 image as JPEG. If I went any lower than 74 kB, the banding on the road became really obvious to me, and some of the grey parts of the road appeared slightly purple in a noticeable way, but Kornel was able to tweak the quantization tables in MozJPEG to get a better result:</p>
<figure>
<div><div><div><div></div></div><a href="https://jakearchibald.com/2020/avif-has-landed/demos/compare/?show=f1&amp;img=undefined" target="_blank"><svg viewBox="0 0 24 24" title="View in full page"><path d="M19 19H5V5h7V3H5a2 2 0 00-2 2v14c0 1.1.9 2 2 2h14a2 2 0 002-2v-7h-2v7zM14 3v2h3.6l-9.8 9.8 1.4 1.4L19 6.4V10h2V3h-7z"></path></svg></a></div></div>
</figure>

<p>Although I&#39;m happy to spend time manually compressing key images of a web site, I don&#39;t really have the skills to tweak a JPEG encoder in that way. So the results in this post are also a reflection of what the codec can do with my moderate talent and perseverance.</p>
<p>I also realise that manually tuning codec settings per image doesn&#39;t scale. If you need to automate image compression, you can figure out the settings manually from a few representative images, then add a bit of extra quality for safety, and use those settings in an automated tool.</p>
<p>I&#39;m providing the full output for each image so you can make your own judgement, and you can try with your own images using <a href="https://squoosh.app">Squoosh</a>.</p>
<p><em>*cough*</em> Sorry about all that. Just trying to get ahead of the &#34;what if&#34;s, &#34;how about&#34;s, and &#34;well actually&#34;s.</p>
<h3 id="back-to-the-f1-image">Back to the F1 image</h3>
<p>Let&#39;s take a closer look and see how the codecs work:</p>
<figure>
<div><div><div><div></div></div><a href="https://jakearchibald.com/2020/avif-has-landed/demos/compare/?show=f1&amp;img=undefined" target="_blank"><svg viewBox="0 0 24 24" title="View in full page"><path d="M19 19H5V5h7V3H5a2 2 0 00-2 2v14c0 1.1.9 2 2 2h14a2 2 0 002-2v-7h-2v7zM14 3v2h3.6l-9.8 9.8 1.4 1.4L19 6.4V10h2V3h-7z"></path></svg></a></div></div>
</figure>

<p>The fine detail of the road is lost in all of the compressed versions, which I&#39;m ok with. However, you can see the difference in detail Kornel was talking about. Look at the red bodywork in the original, there are three distinct parts – the mirror, the wing connecting the bargeboard, and the top of the sidepod. In the AVIF, the smoothing removes the division between these parts, but they&#39;re still mostly there in the JPEG, especially the 74 kB version.</p>
<p>In the JPEG version you can also see the individual 8x8 blocks of the DCT, but they aren&#39;t obvious when zoomed out. WebP avoids this blockiness using decoding filters, and by, well, just being better. AVIF does much better at preserving sharp lines, but introduces smoothing. These are all ways of reducing data in the image, but the artefacts in AVIF are much less ugly.</p>
<p>If you&#39;re thinking &#34;wait, what&#39;s he talking about? The AVIF is really blocky around the red/blue&#34;, well, chances are you&#39;re looking at it in Chrome 85. There&#39;s a bug in the decoder when it comes to upscaling the colour detail. This is mostly fixed in 86, although there are <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1121579">some edge cases where it still happens</a>.</p>
<p>If you want more details on how lossy codecs work, <a href="https://youtu.be/F1kYBnY6mwg?t=284">check out my talk starting at 4:44</a>.</p>
<h3 id="at-equal-file-sizes">At equal file sizes</h3>
<p>One way to make the differences between the codecs really obvious is to test them at roughly the same file size:</p>
<figure>
<div><div><div><div></div></div><a href="https://jakearchibald.com/2020/avif-has-landed/demos/compare/?show=f1&amp;img=undefined" target="_blank"><svg viewBox="0 0 24 24" title="View in full page"><path d="M19 19H5V5h7V3H5a2 2 0 00-2 2v14c0 1.1.9 2 2 2h14a2 2 0 002-2v-7h-2v7zM14 3v2h3.6l-9.8 9.8 1.4 1.4L19 6.4V10h2V3h-7z"></path></svg></a></div></div>
</figure>

<p>I couldn&#39;t even get the JPEG and WebP down to 18 kB, even at lowest settings, so this isn&#39;t a totally fair test. The JPEG suffers from awful banding, which started to appear as soon as I went below 74 kB. The WebP is much better, but there&#39;s still noticeable blockiness compared to the AVIF. I guess that&#39;s what a decade or two of progress looks like.</p>
<h3 id="conclusion">Conclusion</h3>
<p>Unless it&#39;s automated, offering up 3 versions of the same image is a bit of a pain, but the savings here are pretty significant, so it seems worth it, especially given the number of users that can already benefit from AVIF.</p>
<p><a href="https://jakearchibald.com/2020/avif-has-landed/demos/compare/?show=f1">Here&#39;s a full-page comparison of the results</a>.</p>
<p>Ok, next image:</p>
<h2 id="flat-illustration">Flat illustration</h2>
<figure>
<div><div><div><div></div></div><a href="https://jakearchibald.com/2020/avif-has-landed/demos/compare/?show=team&amp;img=undefined" target="_blank"><svg viewBox="0 0 24 24" title="View in full page"><path d="M19 19H5V5h7V3H5a2 2 0 00-2 2v14c0 1.1.9 2 2 2h14a2 2 0 002-2v-7h-2v7zM14 3v2h3.6l-9.8 9.8 1.4 1.4L19 6.4V10h2V3h-7z"></path></svg></a></div></div>
</figure>

<p>This is an illustration by <a href="https://twitter.com/bruised_blood">Stephen Waller</a>. I picked it because of the sharp edges and solid colours, so it&#39;s a good test of lossless compression.</p>
<p>The image doesn&#39;t look like it has a lot of colours, but due to the antialiasing around the edges, it has thousands. I was able to reduce the colours to 68 before things started looking bad. This makes a huge difference for WebP lossless and PNG, which switch to &#39;paletted&#39; mode when there are 256 colours or fewer, which compresses really well.</p>
<p>In the same way AVIF is derived from the keyframes of AV1 video, WebP&#39;s lossy compression is based on the keyframes of VP8 video. However, <em>lossless</em> WebP is a different codec, written from scratch. It&#39;s often overlooked, but it outperforms PNG every time.</p>
<p>I don&#39;t have the original vector version of this image, but I created a &#39;traced&#39; SVG version using Adobe Illustrator to get a very rough feel for how SVG would perform.</p>
<p>What&#39;s notable is how badly AVIF performs here. It does have a specific lossless mode, but it isn&#39;t very good.</p>
<p>But wait…</p>
<h3 id="why-not-lossy">Why not lossy?</h3>
<p>I went straight for palette reduction and lossless compression with this image, because experience has taught me lossy compression <em>always</em> does a bad job on these kinds of images. Or so I thought…</p>
<figure>
<div><div><div><div></div></div><a href="https://jakearchibald.com/2020/avif-has-landed/demos/compare/?show=team&amp;img=undefined" target="_blank"><svg viewBox="0 0 24 24" title="View in full page"><path d="M19 19H5V5h7V3H5a2 2 0 00-2 2v14c0 1.1.9 2 2 2h14a2 2 0 002-2v-7h-2v7zM14 3v2h3.6l-9.8 9.8 1.4 1.4L19 6.4V10h2V3h-7z"></path></svg></a></div></div>
</figure>

<p>Turns out lossy AVIF can handle solid colour and sharp lines really well, and produces a file quite a bit smaller than the SVG. I disabled chroma subsampling in the AVIF to keep the colours sharp.</p>
<h3 id="a-closer-look">A closer look</h3>
<figure>
<div><div><div><div></div></div><a href="https://jakearchibald.com/2020/avif-has-landed/demos/compare/?show=team&amp;img=undefined" target="_blank"><svg viewBox="0 0 24 24" title="View in full page"><path d="M19 19H5V5h7V3H5a2 2 0 00-2 2v14c0 1.1.9 2 2 2h14a2 2 0 002-2v-7h-2v7zM14 3v2h3.6l-9.8 9.8 1.4 1.4L19 6.4V10h2V3h-7z"></path></svg></a></div></div>
</figure>

<p>I expected a lossy codec to destroy the edges, but it looks great! There&#39;s a very slight bit of blurring above the glasses of the guy on the left, and on the ear of the guy on the right. If anything, AVIF has introduced some sharpening – see the left-hand side of the glasses. That kind of sharpening is usually produced by palette reduction, but here it&#39;s just how AVIF works due to the <a href="https://hacks.mozilla.org/2018/06/av1-next-generation-video-the-constrained-directional-enhancement-filter/">directional transforms and filters</a>.</p>
<p>The PNG and WebP have sharp edges particularly around the green shirt due to the palette reduction, but it isn&#39;t really noticeable at normal size.</p>
<p>Of course, the SVG looks super sharp due to vector scaling, but you can see where the tracing lost details around the hair and pocket of the guy on the right.</p>
<h3 id="at-equal-file-sizes-1">At equal file sizes</h3>
<p>Let&#39;s push the other codecs down to the size of the AVIF:</p>
<figure>
<div><div><div><div></div></div><a href="https://jakearchibald.com/2020/avif-has-landed/demos/compare/?show=team&amp;img=undefined" target="_blank"><svg viewBox="0 0 24 24" title="View in full page"><path d="M19 19H5V5h7V3H5a2 2 0 00-2 2v14c0 1.1.9 2 2 2h14a2 2 0 002-2v-7h-2v7zM14 3v2h3.6l-9.8 9.8 1.4 1.4L19 6.4V10h2V3h-7z"></path></svg></a></div></div>
</figure>

<p>Things aren&#39;t as bad as they were with the F1 image, but the JPEG is very noisy and changes the colours significantly, the WebP is blurry, and the PNG shows that, well, you need more than 8 colours.</p>
<h3 id="conclusion-1">Conclusion</h3>
<p>AVIF has kinda blown my mind here. It&#39;s made me reconsider the kinds of images lossy codecs are suited to.</p>
<p>But all said and done, a proper SVG is probably the right choice here. But even if SVG couldn&#39;t be used, the difference between the PNG and AVIF is only a few kB. In this case it might not be worth the complexity of creating different versions of the image.</p>
<p><a href="https://jakearchibald.com/2020/avif-has-landed/demos/compare/?show=team">Here&#39;s a full-page comparison of the results</a>.</p>
<p>Right, it&#39;s time for the next image…</p>
<h2 id="heavy-svg">Heavy SVG</h2>
<figure>
<div><div><div><div></div></div><a href="https://jakearchibald.com/2020/avif-has-landed/demos/compare/?show=car&amp;img=undefined" target="_blank"><svg viewBox="0 0 24 24" title="View in full page"><path d="M19 19H5V5h7V3H5a2 2 0 00-2 2v14c0 1.1.9 2 2 2h14a2 2 0 002-2v-7h-2v7zM14 3v2h3.6l-9.8 9.8 1.4 1.4L19 6.4V10h2V3h-7z"></path></svg></a></div></div>
</figure>

<p>I find it incredible that this image was created with SVG. However, it comes at a cost. The number of shapes and filters involved means it takes a lot of CPU for the browser to render it. It&#39;s one of those edge cases where it&#39;s better to avoid the original SVG, even if the alternative is larger.</p>
<p>PNG struggles here due to the smooth gradients. I reduced the colours to 256, but I had to <a href="https://en.wikipedia.org/wiki/Dither">dither</a> them to avoid visible banding, which also hurt compression.</p>
<p>WebP performs significantly better by mixing lossy compression with an alpha channel. However, the alpha channel is always encoded losslessly in WebP (except for a bit of palette reduction), so it suffers in a similar way to PNG when it comes to the transparent gradient beneath the car.</p>
<p>AVIF aces it again at a significantly smaller size, even compared to the SVG. Part of AVIF&#39;s advantage here is it supports a lossy alpha channel.</p>
<h3 id="a-closer-look-1">A closer look</h3>
<figure>
<div><div><div><div></div></div><a href="https://jakearchibald.com/2020/avif-has-landed/demos/compare/?show=car&amp;img=undefined" target="_blank"><svg viewBox="0 0 24 24" title="View in full page"><path d="M19 19H5V5h7V3H5a2 2 0 00-2 2v14c0 1.1.9 2 2 2h14a2 2 0 002-2v-7h-2v7zM14 3v2h3.6l-9.8 9.8 1.4 1.4L19 6.4V10h2V3h-7z"></path></svg></a></div></div>
</figure>

<p>When zoomed into the PNG, you can see the effects of the palette reduction. The WebP is getting blurry, and suffers from some colour noise.</p>
<p>The AVIF looks similar to the WebP, but at a much smaller size. Interestingly, the AVIF just kinda gives up drawing the bonnet, but it&#39;s hardly noticeable when it&#39;s zoomed out.</p>
<h3 id="at-equal-file-sizes-2">At equal file sizes</h3>
<p>As always, let&#39;s push the other formats down to the size of the AVIF:</p>
<figure>
<div><div><div><div></div></div><a href="https://jakearchibald.com/2020/avif-has-landed/demos/compare/?show=car&amp;img=undefined" target="_blank"><svg viewBox="0 0 24 24" title="View in full page"><path d="M19 19H5V5h7V3H5a2 2 0 00-2 2v14c0 1.1.9 2 2 2h14a2 2 0 002-2v-7h-2v7zM14 3v2h3.6l-9.8 9.8 1.4 1.4L19 6.4V10h2V3h-7z"></path></svg></a></div></div>
</figure>

<p>The PNG version looks kinda cool! Whereas the WebP version makes me want to clean my glasses.</p>
<h3 id="conclusion-2">Conclusion</h3>
<p>Yeahhhh going from 86/50 kB down to 13 kB is a huge saving, and worth the extra effort.</p>
<p><a href="https://jakearchibald.com/2020/avif-has-landed/demos/compare/?show=car">Here&#39;s a full-page comparison of the results</a>.</p>
<p>Ok, one more:</p>
<h2 id="illustration-with-gradients">Illustration with gradients</h2>
<figure>
<div><div><div><div></div></div><a href="https://jakearchibald.com/2020/avif-has-landed/demos/compare/?show=machine&amp;img=undefined" target="_blank"><svg viewBox="0 0 24 24" title="View in full page"><path d="M19 19H5V5h7V3H5a2 2 0 00-2 2v14c0 1.1.9 2 2 2h14a2 2 0 002-2v-7h-2v7zM14 3v2h3.6l-9.8 9.8 1.4 1.4L19 6.4V10h2V3h-7z"></path></svg></a></div></div>
</figure>

<p>This is another one from <a href="https://twitter.com/bruised_blood">Stephen Waller</a>. I picked this because it has a lot of flat colour and sharp lines, which usually points to lossless compression, but it also has a lot of gradients, which lossless formats can struggle with.</p>
<p>Even if I take the colours down to 256 and let WebP work its lossless magic, the result is still 170 kB. In this case, the lossy codecs perform much better.</p>
<p>I disabled chroma subsampling for the JPEG and AVIF, to keep the colours sharp. Unfortunately lossy WebP doesn&#39;t have this option, but it has &#34;Sharp YUV&#34;, which tries to reduce the impact of the colour resolution reduction.</p>
<p>JPEG doesn&#39;t do a <em>great</em> job here – anything lower than 80 kB starts to introduce obvious blockiness. WebP handles the image much better, but again I&#39;m staggered by how well AVIF performs.</p>
<h3 id="a-closer-look-2">A closer look</h3>
<figure>
<div><div><div><div></div></div><a href="https://jakearchibald.com/2020/avif-has-landed/demos/compare/?show=machine&amp;img=undefined" target="_blank"><svg viewBox="0 0 24 24" title="View in full page"><path d="M19 19H5V5h7V3H5a2 2 0 00-2 2v14c0 1.1.9 2 2 2h14a2 2 0 002-2v-7h-2v7zM14 3v2h3.6l-9.8 9.8 1.4 1.4L19 6.4V10h2V3h-7z"></path></svg></a></div></div>
</figure>

<p>The JPEG is pretty noisy when zoomed in, and you can start to see the 8x8 blocks in the background.</p>
<p>With the reduced-palette WebP, you can start to see the effects of palette reduction, especially in the elf&#39;s hat.</p>
<p>The lossy WebP is pretty blurry, and suffers from colour artefacts, which are a side-effect of &#34;Sharp YUV&#34;.</p>
<p>The AVIF has really clean colours, but some blurring, and even changes some of the shapes a bit – the circle looks almost octagonal due to the edge detection. But c&#39;mon, 12 Kb!</p>
<h3 id="at-equal-file-sizes-3">At equal file sizes</h3>
<p>For one last time, let&#39;s push the other codecs down to AVIF&#39;s size:</p>
<figure>
<div><div><div><div></div></div><a href="https://jakearchibald.com/2020/avif-has-landed/demos/compare/?show=machine&amp;img=undefined" target="_blank"><svg viewBox="0 0 24 24" title="View in full page"><path d="M19 19H5V5h7V3H5a2 2 0 00-2 2v14c0 1.1.9 2 2 2h14a2 2 0 002-2v-7h-2v7zM14 3v2h3.6l-9.8 9.8 1.4 1.4L19 6.4V10h2V3h-7z"></path></svg></a></div></div>
</figure>

<p>At these sizes, JPEG has done its own art, and the WebP looks blocky and messy.</p>
<h3 id="conclusion-3">Conclusion</h3>
<p>In this case, WebP offers a huge drop in size compared to the JPEG, so it&#39;s definitely worth providing the WebP to browsers that support it. However, the difference between the WebP and AVIF isn&#39;t huge, so it might not be worth creating an AVIF too.</p>
<p><a href="https://jakearchibald.com/2020/avif-has-landed/demos/compare/?show=machine">Here&#39;s a full-page comparison of the results</a>.</p>
<h2 id="so-is-avif-the-champion">So, is AVIF the champion?</h2>
<p>I was initially sceptical of AVIF – I don&#39;t like the idea that the web has to pick up the scraps left by video formats. But wow, I&#39;m seriously impressed with the results above. That said, it isn&#39;t perfect.</p>
<h3 id="progressive-rendering">Progressive rendering</h3>
<p>Because AVIF is an off-cut of a video format, it&#39;s missing some useful image features and optimisations that aren&#39;t relevant to video:</p>
<figure>
<video src="/c/progressive-5f94067c.mp4" width="1000" height="666" controls=""></video>
<figcaption>JPEG, WebP, and AVIF loading at 2g speeds</figcaption>
</figure>

<p>The above shows a high-resolution (2000x1178), high-quality image loading at 2g speeds. To get roughly the same quality, the JPEG is 249 kB, the WebP is 153 kB, and the AVIF is 96 kB.</p>
<p>Although they&#39;re all loading at the same rate, the much-larger JPEG feels faster because of how it renders in multiple passes. WebP renders from top to bottom, which isn&#39;t as good, but at least you see the progress. Unfortunately, with AVIF it&#39;s all-or-nothing.</p>
<p>Video doesn&#39;t need to render a partial frame, so it isn&#39;t something the format is set up to do. It&#39;s possible to have a top-to-bottom render like WebP, but the implementation would be complicated, so we&#39;re unlikely to see it in browsers in the foreseeable future.</p>
<p>Because of this, AVIF feels better suited to smaller quicker-loading images. But that still covers most images on the web.</p>
<p>Maybe this could be solved if the format could provide a way to embed a &#39;preview&#39; version of the image at the start of the file. The browser would render this if it doesn&#39;t have the rest of the file. Because it&#39;s a different image, the developer would get to choose the quality, resolution, and even apply filters like blurring:</p>
<figure>
<div><div><div><div></div></div></div></div>
</figure>

<p>Adding 5 kB to a big image like this seems worth it to get a low-quality early render. Here&#39;s what it would look like:</p>
<figure id="progressive-avif-demo">
<video src="/c/progressive-avif-a3f535d9.mp4" width="1000" height="666" controls=""></video>
<figcaption>JPEG, WebP, and &#39;progressive&#39; AVIF loading at 2g speeds</figcaption>
</figure>

<p>I&#39;ve <a href="https://github.com/AOMediaCodec/av1-avif/issues/102">proposed this to the AVIF spec folks</a>.</p>
<h3 id="encoding-time">Encoding time</h3>
<p>Encoding AVIF takes a long time in general, but it&#39;s especially bad in <a href="https://squoosh.app">Squoosh</a> because we&#39;re using WebAssembly, which doesn&#39;t let us use <a href="https://en.wikipedia.org/wiki/SIMD">SIMD</a> or multiple threads. Those features are starting to arrive to standards and browsers, so hopefully we&#39;ll be able to improve things soon.</p>
<p>At an &#39;effort&#39; of 2, it takes a good few seconds to encode. &#39;Effort&#39; 3 is significantly better, but that can take a couple of minutes. &#39;Effort&#39; 10 (which I used for images in this article) can take over 10 minutes to encode a single image.</p>
<p>AVIF supports tiling images, which chops the image into smaller blocks that can be encoded and decoded separately. This is interesting for encoding, because it means the blocks can be encoded in parallel, making full use of CPU cores, although Squoosh doesn&#39;t take advantage of this yet.</p>
<p>The command line tools are orders of magnitude faster. You can either <a href="https://github.com/AOMediaCodec/libavif">compile libavif yourself</a>, or on OSX, install it via <a href="https://brew.sh/">Homebrew</a>:</p>
<div><pre>brew install joedrago/repo/avifenc</pre></div><p>There&#39;s also a Rust implementation, <a href="https://github.com/kornelski/cavif-rs">cavif</a>.</p>
<p>My current workflow is to use <a href="https://squoosh.app">Squoosh</a> to figure out decent settings at &#39;effort&#39; 2, then use libavif to try the same settings at &#39;effort&#39; 10. Hopefully we can speed up the Squoosh version soon!</p>
<h3 id="decoding-time">Decoding time</h3>
<p>There&#39;s also a question of CPU usage vs other formats when it comes to decoding, but I haven&#39;t dug into that yet. Although AV1 is <a href="https://www.nvidia.com/en-gb/geforce/news/rtx-30-series-av1-decoding/">starting to get</a> <a href="https://newsroom.intel.com/news-releases/11th-gen-tiger-lake-evo/">hardware support</a>, I&#39;m told that dedicated hardware will be tuned for video, and not so great at decoding a page full of images.</p>
<h2 id="what-about-jpeg-xl-and-webpv2">What about JPEG-XL and WebPv2?</h2>
<p>One of the reasons we built <a href="https://squoosh.app">Squoosh</a> is so developers could bypass the claims made about particular codecs, and instead just try it for themselves. JPEG-XL isn&#39;t quite ready yet, but we&#39;ll get it into Squoosh as soon as possible. In the meantime, I&#39;m trying to take JPEG-XL&#39;s claims of superiority with a pinch of salt. However, there&#39;s a lot to get excited about.</p>
<p>JPEG-XL is an image format, rather than an off-cut of a video format. It supports lossless and lossy compressions, and progressive multi-pass rendering. It looks like the lossless compression will be better than WebP&#39;s, which is great. However, the lossy compression is tuned for high quality rather than &#39;acceptable quality&#39;, so it might not be a great fit for most web images. But, the benefit of multi-pass rendering might mean it&#39;s worth taking a hit when it comes to file size. I guess we&#39;ll wait and see!</p>
<p>There aren&#39;t many details around WebPv2 yet, so again it&#39;s best to wait and see until we can test it with our own images.</p>
<h2 id="and-thats-it">And that&#39;s it!</h2>
<p>Phew! I didn&#39;t expect this post to get so long. I wanted to include a dive into the more obscure settings these codecs offer, but I&#39;ll save that for another day.</p>
<p>I really enjoyed building the demos for this article. In case you want to dig into the details:</p>
<ul>
<li>I built <a href="https://github.com/jakearchibald/jakearchibald.com/blob/main/shared/DecodedImg/index.tsx">a Preact component to handle image loading and decoding</a>, so AVIF/WebP works even without browser support. <a href="https://github.com/jakearchibald/jakearchibald.com/blob/main/client-worker/avif/decode/index.ts">A worker</a> handles the actual decoding, using the WebAssembly decoders from <a href="https://squoosh.app/">Squoosh</a>. I&#39;d usually use <a href="https://github.com/GoogleChromeLabs/comlink">comlink</a> to help with worker communication, but lack of worker-module compatibility meant I <a href="https://github.com/jakearchibald/jakearchibald.com/blob/main/shared/DecodedImg/decoder.ts">went for something smaller/hackier</a> instead.</li>
<li>I wanted the demos on this page to be part of the static build to avoid layout shifting, but I <a href="https://twitter.com/jaffathecake/status/1230388412806520833">didn&#39;t want to re-render the whole page with JS</a> (a pattern you see a lot with things like Gatsby and Next.JS). I hacked together a solution where my <a href="https://github.com/jakearchibald/jakearchibald.com/blob/main/static-build/posts/2020/09/avif-has-landed/index.md">markdown contains <code>&lt;​script type=&#34;component&#34;&gt;</code></a>, which is <a href="https://github.com/jakearchibald/jakearchibald.com/blob/main/lib/markdown-plugin.js#L79">replaced with the HTML for that component</a> when the markdown is parsed, and <a href="https://github.com/jakearchibald/jakearchibald.com/blob/main/lib/markdown-plugin.js#L109">becomes live on the client</a>.</li>
<li>The full page compare view uses the <a href="https://github.com/jakearchibald/jakearchibald.com/blob/main/client/demos/2020/avif-has-landed/compare/ZoomableTwoUp.tsx">two-up and pinch-zoom web components</a> from Squoosh.</li>
<li>Here&#39;s the <a href="https://jakearchibald.com/2020/avif-has-landed/demos/loading/">progressive image loading demo</a>. It uses a <a href="https://github.com/jakearchibald/jakearchibald.com/blob/main/client-worker/avif/avif-slow-sw.ts"><code>TransformStream</code> in a service worker</a> to throttle the image data.</li>
<li>For the talk rather than this article, I built a tool that lets you <a href="https://jakearchibald.github.io/image-experiments/channels/">experiment with chroma subsampling</a>.</li>
<li>Also from the talk, I built a tool to visualise the <a href="https://jakearchibald.github.io/image-experiments/quant/">DCT patterns that form an 8x8 block</a>.</li>
</ul>
<p>Thanks to <a href="https://twitter.com/kornelski">Kornel Lesiński</a>, <a href="https://twitter.com/DasSurma">Surma</a>, <a href="https://twitter.com/Paul_Kinlan">Paul Kinlan</a>, <a href="https://twitter.com/RReverser">Ingvar Stepanyan</a>, and Sam Jenkins for proof-reading and fact checking! And since publishing, thanks to <a href="https://twitter.com/hsablonniere">Hubert Sablonnière</a> and <a href="https://twitter.com/mathias">Mathias Bynens</a> for more typo-busting.</p>
</div></div>
  </body>
</html>
