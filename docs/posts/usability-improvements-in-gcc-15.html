<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://developers.redhat.com/articles/2025/04/10/6-usability-improvements-gcc-15">Original</a>
    <h1>Usability Improvements in GCC 15</h1>
    
    <div id="readability-page-1" class="page"><div>
                  
                <div>
          
<p>I work at Red Hat on <a href="https://gcc.gnu.org/">GCC, the GNU Compiler Collection</a>. I spent most of the past year working on how GCC emits diagnostics (errors and warnings) in the hope of making it easier to use. Let&#39;s take a look at 6 improvements to look forward to in the upcoming GCC 15.</p><h2>1. Prettier execution paths</h2><p>I added a <a href="https://developers.redhat.com/blog/2020/03/26/static-analysis-in-gcc-10">static analyzer to GCC in GCC 10</a> that prints visualizations of predicted paths of execution through the user&#39;s code, demonstrating each problem it predicts.</p><p>Here&#39;s an example that shows some of the improvements I&#39;ve made to this in GCC 15:</p><pre><code>infinite-loop-linked-list.c: In function ‘while_loop_missing_next’:
infinite-loop-linked-list.c:30:10: warning: infinite loop [CWE-835] [-Wanalyzer-infinite-loop]
   30 |   while (n)
      |          ^
  ‘while_loop_missing_next’: events 1-3
   30 |   while (n)
      |          ^
      |          |
      |          (1) ⚠️  infinite loop here
      |          (2) when ‘n’ is non-NULL: always following ‘true’ branch... ─&gt;─┐
      |                                                                         │
      |                                                                         │
      |┌────────────────────────────────────────────────────────────────────────┘
   31 |│    {
   32 |│      sum += n-&gt;val;
      |│             ~~~~~~
      |│              |
      |└─────────────&gt;(3) ...to here
  ‘while_loop_missing_next’: event 4
   32 |       sum += n-&gt;val;
      |       ~~~~^~~~~~~~~
      |           |
      |           (4) looping back... ─&gt;─┐
      |                                  │
  ‘while_loop_missing_next’: event 5
      |                                  │
      |┌─────────────────────────────────┘
   30 |│  while (n)
      |│         ^
      |│         |
      |└────────&gt;(5) ...to here
	</code></pre><p>I&#39;ve added a warning emoji (⚠️) to the event in the path where the problem occurs (event 1 in the above), and I&#39;ve added &#34;ASCII art&#34; to show control flow, such as the lines connecting events 2 and 3, and those connecting events 4 and 5 (compare with the <a href="https://developers.redhat.com/articles/2024/04/03/improvements-static-analysis-gcc-14-compiler#solving_the_halting_problem_">GCC 14 output seen here</a>).</p><p>Another example of an execution path can be seen in this new <a href="https://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html"><code>-fanalyzer</code></a> warning <a href="https://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html#index-Wanalyzer-undefined-behavior-ptrdiff"><code>-Wanalyzer-undefined-behavior-ptrdiff</code></a>, which warns about pointer subtractions involving different chunks of memory:</p><pre><code>demo.c: In function ‘test_invalid_calc_of_array_size’:
demo.c:9:20: warning: undefined behavior when subtracting pointers [CWE-469] [-Wanalyzer-undefined-behavior-ptrdiff]
    9 |   return &amp;sentinel - arr;
      |                    ^
  events 1-2
    │
    │    3 | int arr[42];
    │      |     ~~~
    │      |     |
    │      |     (2) underlying object for right-hand side of subtraction created here
    │    4 | int sentinel;
    │      |     ^~~~~~~~
    │      |     |
    │      |     (1) underlying object for left-hand side of subtraction created here
    │
    └──&gt; ‘test_invalid_calc_of_array_size’: event 3
           │
           │    9 |   return &amp;sentinel - arr;
           │      |                    ^
           │      |                    |
           │      |                    (3) ⚠️  subtraction of pointers has undefined behavior if they do not point into the same array object
           │
    </code></pre><p>There&#39;s a line on the left-hand side that visualizes the stack depth to highlight calls and returns.  As of GCC 15 this now uses unicode box-drawing characters (where the locale supports this), and for purely intraprocedual cases like the  <a href="https://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html#index-Wanalyzer-infinite-loop"><code>-Wanalyzer-infinite-loop</code></a> example above, we now omit it altogether, which saves some visual &#34;noise.&#34;</p><h2>2. A new look for C++ template errors</h2><p>Compiler errors involving C++ templates are notoriously difficult to read.</p><p>Consider this invalid C++ code:</p><pre><code>struct widget {};
void draw (widget &amp;);

struct diagram {};
void draw (diagram &amp;);

template &lt;class W&gt;
concept drawable = requires(W w) { w.draw (); };

template &lt;drawable T&gt;
void draw(T);

int main ()
{
  draw (widget ());
}</code></pre><p>Attempting to <a href="https://godbolt.org/z/5GqYnqd6E">compile it with GCC 14</a> with <code>-fconcepts -fconcepts-diagnostics-depth=2</code> gives 34 lines of output, which is relatively simple as far as these go, and even this can be hard to decipher. I&#39;ll post it here for reference, but I confess that my eyes tend to glaze over when I try to read it:</p><pre><code>&lt;source&gt;: In function &#39;int main()&#39;:
&lt;source&gt;:15:8: error: no matching function for call to &#39;draw(widget)&#39;
   15 |   draw (widget ());
      |   ~~~~~^~~~~~~~~~~
&lt;source&gt;:2:6: note: candidate: &#39;void draw(widget&amp;)&#39; (near match)
    2 | void draw (widget &amp;);
      |      ^~~~
&lt;source&gt;:2:6: note:   conversion of argument 1 would be ill-formed:
&lt;source&gt;:15:9: error: cannot bind non-const lvalue reference of type &#39;widget&amp;&#39; to an rvalue of type &#39;widget&#39;
   15 |   draw (widget ());
      |         ^~~~~~~~~
&lt;source&gt;:5:6: note: candidate: &#39;void draw(diagram&amp;)&#39;
    5 | void draw (diagram &amp;);
      |      ^~~~
&lt;source&gt;:5:12: note:   no known conversion for argument 1 from &#39;widget&#39; to &#39;diagram&amp;&#39;
    5 | void draw (diagram &amp;);
      |            ^~~~~~~~~
&lt;source&gt;:11:6: note: candidate: &#39;template&lt;class T&gt;  requires  drawable&lt;T&gt; void draw(T)&#39;
   11 | void draw(T);
      |      ^~~~
&lt;source&gt;:11:6: note:   template argument deduction/substitution failed:
&lt;source&gt;:11:6: note: constraints not satisfied
&lt;source&gt;: In substitution of &#39;template&lt;class T&gt;  requires  drawable&lt;T&gt; void draw(T) [with T = widget]&#39;:
&lt;source&gt;:15:8:   required from here
   15 |   draw (widget ());
      |   ~~~~~^~~~~~~~~~~
&lt;source&gt;:8:9:   required for the satisfaction of &#39;drawable&lt;T&gt;&#39; [with T = widget]
&lt;source&gt;:8:20:   in requirements with &#39;W w&#39; [with W = widget]
&lt;source&gt;:8:43: note: the required expression &#39;w.draw()&#39; is invalid, because
    8 | concept drawable = requires(W w) { w.draw (); };
      |                                    ~~~~~~~^~
&lt;source&gt;:8:38: error: &#39;struct widget&#39; has no member named &#39;draw&#39;
    8 | concept drawable = requires(W w) { w.draw (); };
      |                                    ~~^~~~</code></pre><p>One of the issues is that there is a hierarchical structure to these messages, but we&#39;re printing them as a &#34;flat&#34; list, which obscures the meaning.</p><p>I&#39;ve been experimenting with a new way of presenting this information, taking inspiration from <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2429r0.pdf">Sy Brand&#39;s excellent &#34;Concepts Error Messages for Humans&#34; paper</a>. It&#39;s not ready to turn on by default in GCC for all C++ users, but it&#39;s available in GCC 15 through a command-line option for people who want to try it out: <code>-fdiagnostics-set-output=text:experimental-nesting=yes</code></p><p>Here&#39;s the example we just saw, adding the <code>-fdiagnostics-set-output=text:experimental-nesting=yes</code> &#34;cheat code&#34;:</p><pre><code>demo.cc: In function ‘int main()’:
demo.cc:19:8: error: no matching function for call to ‘draw(widget)’
   19 |   draw (widget ());
      |   ~~~~~^~~~~~~~~~~
  • there are 3 candidates
    • candidate 1: ‘void draw(widget&amp;)’ (near match)
      demo.cc:6:6:
          6 | void draw (widget &amp;);
            |      ^~~~
      • conversion of argument 1 would be ill-formed:
      • error: cannot bind non-const lvalue reference of type ‘widget&amp;’ to an rvalue of type ‘widget’
        demo.cc:19:9:
           19 |   draw (widget ());
              |         ^~~~~~~~~
    • candidate 2: ‘void draw(diagram&amp;)’
      demo.cc:9:6:
          9 | void draw (diagram &amp;);
            |      ^~~~
      • no known conversion for argument 1 from ‘widget’ to ‘diagram&amp;’
        demo.cc:9:12:
            9 | void draw (diagram &amp;);
              |            ^~~~~~~~~
    • candidate 3: ‘template&lt;class T&gt;  requires  drawable&lt;T&gt; void draw(T)’
      demo.cc:15:6:
         15 | void draw(T);
            |      ^~~~
      • template argument deduction/substitution failed:
        • constraints not satisfied
          • demo.cc: In substitution of ‘template&lt;class T&gt;  requires  drawable&lt;T&gt; void draw(T) [with T = widget]’:
          • required from here
            demo.cc:19:8:   
               19 |   draw (widget ());
                  |   ~~~~~^~~~~~~~~~~
          • required for the satisfaction of ‘drawable&lt;T&gt;’ [with T = widget]
            demo.cc:12:9:   
               12 | concept drawable = requires(W w) { w.draw (); };
                  |         ^~~~~~~~
          • in requirements with ‘W w’ [with W = widget]
            demo.cc:12:20:   
               12 | concept drawable = requires(W w) { w.draw (); };
                  |                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
          • the required expression ‘w.draw()’ is invalid, because
            demo.cc:12:43:
               12 | concept drawable = requires(W w) { w.draw (); };
                  |                                    ~~~~~~~^~
            • error: ‘struct widget’ has no member named ‘draw’
              demo.cc:12:38:
                 12 | concept drawable = requires(W w) { w.draw (); };
                    |                                    ~~^~~~
</code></pre><p>This presentation of the errors uses indentation and nested bullet points to show the logical structure of what the compiler is doing, eliminates redundant &#34;visual noise&#34; where it can, and clarifies the wording to state clearly that the compiler tried 3 different candidates for the function call, and spells out why each candidate was unsuitable. </p><p>I&#39;ve tried turning this on for my day-to-day C++ work and it feels like a huge improvement. I hope we&#39;ll be able to turn it on by default in GCC 16; you can try it yourself <a href="https://godbolt.org/z/381oT3bxj">here</a>.</p><h2>3. Machine-readable diagnostics</h2><p><a href="https://gcc.gnu.org/wiki/SARIF">SARIF</a> is a file format intended for storing the results of static analysis tools in a machine-readable, interchangeable format; as such, it&#39;s a great fit for compiler diagnostics. I added support in GCC 13 for writing out GCC&#39;s diagnostics in SARIF form, but it was an all-or-nothing deal: you could choose either GCC&#39;s classic text output on stderr, or SARIF, but not both. </p><p>For GCC 15, I&#39;ve reworked the insides of how we handle diagnostics so that there can be multiple &#34;output sinks,&#34; and added a new command-line option <a href="https://gcc.gnu.org/onlinedocs/gcc/Diagnostic-Message-Formatting-Options.html#index-fdiagnostics-add-output"><code>-fdiagnostics-add-output=ARGS</code></a> for adding new sinks. For example, using <a href="https://gcc.gnu.org/onlinedocs/gcc/Diagnostic-Message-Formatting-Options.html#index-fdiagnostics-add-output"><code>-fdiagnostics-add-output=sarif</code></a> will get you diagnostics emitted both as text on stderr and in SARIF form to a file. </p><p>Various sub-options are available; for example, <a href="https://gcc.gnu.org/onlinedocs/gcc/Diagnostic-Message-Formatting-Options.html#index-fdiagnostics-add-output"><code>-fdiagnostics-add-output=sarif:version=2.2-prerelease</code></a> will select SARIF 2.2 output for that sink (though given that we&#39;re still working on the SARIF 2.2 specification, it uses an unofficial draft of the specification, and is subject to change).</p><p>I&#39;ve also improved the SARIF that GCC emits. The output now captures all locations and labeled source ranges associated with a diagnostic. For example, for:</p><pre><code>PATH/missing-semicolon.c: In function &#39;missing_semicolon&#39;:
PATH/missing-semicolon.c:9:12: error: expected &#39;;&#39; before &#39;}&#39; token
    9 |   return 42
      |            ^
      |            ;
   10 | }
      | ~
</code></pre><p>the GCC SARIF output now captures the secondary location (that of the trailing close brace), as well as that of the missing semicolon. Similarly, for:</p><pre><code>bad-binary-ops.c: In function ‘bad_plus’:
bad-binary-ops.c:64:23: error: invalid operands to binary + (have ‘S’ {aka ‘struct s’} and ‘T’ {aka ‘struct t’})
  64 |   return callee_4a () + callee_4b ();
     |          ~~~~~~~~~~~~ ^ ~~~~~~~~~~~~
     |          |              |
     |          |              T {aka struct t}
     |          S {aka struct s}
</code></pre><p>the SARIF output captures those underlined ranges and their labels. </p><p>GCC&#39;s SARIF output now captures the command-line arguments (<a href="https://docs.oasis-open.org/sarif/sarif/v2.1.0/errata01/os/sarif-v2.1.0-errata01-os-complete.html#_Toc141790819">§3.20.2</a>), timestamps for the start and end of compilation (<a href="https://docs.oasis-open.org/sarif/sarif/v2.1.0/errata01/os/sarif-v2.1.0-errata01-os-complete.html#_Toc141790824">§§3.20.7-8</a>), and the working directory (<a href="https://docs.oasis-open.org/sarif/sarif/v2.1.0/errata01/os/sarif-v2.1.0-errata01-os-complete.html#_Toc141790836">§3.20.19</a>). It also now sets the <code>roles</code> property for SARIF <code>artifact</code> objects (<a href="https://docs.oasis-open.org/sarif/sarif/v2.1.0/errata01/os/sarif-v2.1.0-errata01-os-complete.html#_Toc141790867">§3.24.6</a>), captures any embedded URLs in the text of messages (<a href="https://docs.oasis-open.org/sarif/sarif/v2.1.0/errata01/os/sarif-v2.1.0-errata01-os-complete.html#_Toc141790717">§3.11.6</a>). For diagnostics relating to header files, the SARIF output now captures the chain of <code>#include</code> directives that led to the diagnostic&#39;s location (using SARIF <code>locationRelationship</code> objects, <a href="https://docs.oasis-open.org/sarif/sarif/v2.1.0/errata01/os/sarif-v2.1.0-errata01-os-complete.html#_Toc141790978">§3.34</a>). </p><p>As well as improving the SARIF that GCC produces, I&#39;ve added a tool to GCC 15 for <strong>consuming</strong> SARIF: <code>sarif-replay</code>. This is a simple command-line tool for viewing <code>.sarif</code> files, showing (&#34;replaying&#34;) any diagnostics found in the <code>.sarif</code> files in text form as if they were GCC diagnostics, with support for details such as quoting source code, underlined ranges, fix-it hints, and diagnostic paths. </p><p>For example, here&#39;s a replay of a <code>.sarif</code> file emitted by GCC&#39;s <code>-fanalyzer</code> static analysis option:</p><pre><code>$ sarif-replay signal-warning.sarif
In function &#39;custom_logger&#39;:
signal.c:13:3: warning: call to ‘fprintf’ from within signal handler [-Wanalyzer-unsafe-call-within-signal-handler]
   13 |   fprintf(stderr, &#34;LOG: %s&#34;, msg);
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  &#39;main&#39;: events 1-2
    │
    │   21 | int main(int argc, const char *argv)
    │      |     ^~~~
    │      |     |
    │      |     (1) entry to ‘main’
    │......
    │   25 |   signal(SIGINT, handler);
    │      |   ~~~~~~~~~~~~~~~~~~~~~~~
    │      |   |
    │      |   (2) registering ‘handler’ as signal handler
    │
  event 3
    │
    │GNU C17:
    │ (3): later on, when the signal is delivered to the process
    │
    └──&gt; &#39;handler&#39;: events 4-5
           │
           │   16 | static void handler(int signum)
           │      |             ^~~~~~~
           │      |             |
           │      |             (4) entry to ‘handler’
           │   17 | {
           │   18 |   custom_logger(&#34;got signal&#34;);
           │      |   ~~~~~~~~~~~~~~~~~~~~~~~~~~~
           │      |   |
           │      |   (5) calling ‘custom_logger’ from ‘handler’
           │
           └──&gt; &#39;custom_logger&#39;: events 6-7
                  │
                  │   11 | void custom_logger(const char *msg)
                  │      |      ^~~~~~~~~~~~~
                  │      |      |
                  │      |      (6) entry to ‘custom_logger’
                  │   12 | {
                  │   13 |   fprintf(stderr, &#34;LOG: %s&#34;, msg);
                  │      |   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                  │      |   |
                  │      |   (7) call to ‘fprintf’ from within signal handler
                  │</code></pre><h2>4. An easier transition to C23</h2><p>When compiling C code, GCC 14 and earlier defaulted to <a href="https://gcc.gnu.org/onlinedocs/gcc/C-Dialect-Options.html#index-std-1"><code>-std=gnu17</code></a> (i.e., the &#34;C17&#34; version of the C standard, plus extensions). GCC 15 now defaults to <a href="https://gcc.gnu.org/onlinedocs/gcc/C-Dialect-Options.html#index-std-1"><code>-std=gnu23</code></a> (based on C23), so if your build system isn&#39;t specifying which C version to use, you might run into <a href="https://gcc.gnu.org/gcc-15/porting_to.html#c23">C17 versus C23 incompatibilities</a>.</p><p>I attempted to rebuild a large subset of Fedora with GCC 15 and thus defaulting to C23 to try to <a href="https://fedoraproject.org/wiki/F42-gcc-15-mass-prebuild">shake out problems</a> that would arise, and in doing so found various diagnostics that needed improving. For example, <code>bool</code>, <code>true</code>, and <code>false</code> are keywords in C23, so I&#39;ve tweaked the error message that occurs on <a href="https://godbolt.org/z/7W8fMT9zd">old code</a> such as:</p><pre><code>typedef int bool;</code></pre><p>so that you immediately know it&#39;s a C23 compatibility problem:</p><pre><code>&lt;source&gt;:1:13: error: &#39;bool&#39; cannot be defined via &#39;typedef&#39;
    1 | typedef int bool;
      |             ^~~~
&lt;source&gt;:1:13: note: &#39;bool&#39; is a keyword with &#39;-std=c23&#39; onwards</code></pre><p>Similarly, C17 and C23 treat function declarations without parameters such as <code>int foo(); </code>differently. In C23, it&#39;s equivalent to <code>int foo(void);</code> whereas, in earlier versions of C, such a declaration plays fast and loose with the type system—essentially meaning, &#34;we don&#39;t know how many parameters this function takes or their types; let&#39;s hope your code is correct!&#34;. In my tests, this led to lots of errors on old code, such as in <a href="https://godbolt.org/z/11hzWYEeK">this example</a>:</p><pre><code>#include &lt;signal.h&gt;

void test()
{
  void (*handler)();
  handler = signal(SIGQUIT, SIG_IGN);
}</code></pre><p>So I&#39;ve clarified these error messages so that they tell you the types of the functions (or function pointers) and show you where the pertinent <code>typedef</code> is:</p><pre><code>&lt;source&gt;: In function &#39;test&#39;:
&lt;source&gt;:6:11: error: assignment to &#39;void (*)(void)&#39; from incompatible pointer type &#39;__sighandler_t&#39; {aka &#39;void (*)(int)&#39;} [-Wincompatible-pointer-types]
    6 |   handler = signal(SIGQUIT, SIG_IGN);
      |           ^
In file included from &lt;source&gt;:1:
/usr/include/signal.h:72:16: note: &#39;__sighandler_t&#39; declared here
   72 | typedef void (*__sighandler_t) (int);
      |                ^~~~~~~~~~~~~~
</code></pre><p>Similarly, I&#39;ve clarified the C front end&#39;s error messages for bad call sites:</p><pre><code>struct p { int (*bar)(); };
    
void baz() {
    struct p q;
    q.bar(1);
}</code></pre><pre><code>t.c: In function &#39;baz&#39;:
t.c:7:5: error: too many arguments to function &#39;q.bar&#39;; expected 0, have 1
    7 |     q.bar(1);
      |     ^     ~
t.c:2:15: note: declared here
    2 |         int (*bar)();
      |               ^~~
   </code></pre><p>showing the expected parameter count versus the actual argument count, underlining the first extraneous argument at the call site, and showing the pertinent field declaration of the callback.</p><h2>5. A revamped color scheme</h2><p>GCC will use color when emitting its text messages on stderr at a suitably modern terminal, using a few colors that seem to work well in a number of different terminal themes—but the exact rules for choosing which color to use for each aspect of the output have been rather arbitrary.</p><p>For GCC 15, I&#39;ve gone through C and C++&#39;s errors, looking for places where two different things in the source are being contrasted, such as type mismatches. These diagnostics now use color to visually highlight and distinguish the differences. </p><p>For example, this error (Figure 1) shows a bogus attempt to use a binary <code>+</code> operator due to the two operands being structs (via <code>typedef</code>s <code>S</code> and <code>T</code>), rather than numeric types.</p><figure role="group">
<article>
  
      
        <div>  <picture><source srcset="/sites/default/files/screenshot_from_2025-04-01_11-29-19.png.webp" type="image/webp"/><img loading="lazy" src="https://developers.redhat.com/sites/default/files/screenshot_from_2025-04-01_11-29-19.png" width="710" height="210" alt="screenshot of a C type error from GCC 15 showing color usage" typeof="foaf:Image"/></picture>

</div>
  </article>

<figcaption>Figure 1: A new color scheme for errors in GCC 15.</figcaption>
</figure>
<p>The two significant things here are the types, so GCC 15 uses two colors to consistently highlight the different types: in the message itself, in the quoted source, and the labels. Here, the left-hand type (<code>typedef struct s S;</code>) is shown throughout in green and the right-hand type (<code>typedef struct t T;</code>) in dark blue. I hope this approach better ties together the message&#39;s text with the source code and makes such errors a little easier to figure out.</p><h2>6. libgdiagnostics</h2><p>Figure 1 above shows off some of the features that GCC&#39;s diagnostics subsystem has: code for colorization, quoting source code, labelling ranges of source, fix-it hints, execution paths, SARIF output, and so on. Previously this code was hidden inside GCC and only usable by GCC itself. </p><p>For GCC 15, I&#39;ve made this functionality available as a shared library for other projects to use: <a href="https://gcc.gnu.org/wiki/libgdiagnostics">libgdiagnostics</a>. There is a C API, along with C++ and Python bindings. For example, I was able to use the Python bindings to write a <a href="https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff;h=8d6de758cca6d16eb930ac1a7008ee54ec5489d9">&#34;linting&#34; script for our testsuite</a>, and &#34;for free&#34; got source quoting, colorization, and fix-it hints. Adding the ability to this script to output as SARIF would be a one-liner, rather than having to write lots of JSON-handling code.</p><h2>Try GCC 15</h2><p>We&#39;re still fixing bugs, but we hope that <a href="https://gcc.gnu.org/gcc-14/changes.html">GCC 15</a> will be ready to officially release (as 15.1) sometime later this month. With my &#34;downstream&#34; hat on, we&#39;re already using the prerelease (GCC 15.0) within <a href="https://fedoramagazine.org/announcing-fedora-linux-40-beta/">Fedora 42 Beta</a>.</p><p>Finally, you can use the <a href="https://godbolt.org/z/s18GhbdeM">excellent Compiler Explorer site</a> to play with the new compiler. Have fun!</p>

          
                            </div>
      </div></div>
  </body>
</html>
