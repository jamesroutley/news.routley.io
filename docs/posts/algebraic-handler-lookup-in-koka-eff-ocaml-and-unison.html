<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://interjectedfuture.com/algebraic-handler-lookup-in-koka-eff-ocaml-and-unison/">Original</a>
    <h1>Algebraic Handler Lookup in Koka, Eff, OCaml, and Unison</h1>
    
    <div id="readability-page-1" class="page"><div id="site-main">
<article>

    <header>

        

        


        <div>
        <section>

            <ul>
                <li>
                    <a href="https://github.com/author/wil/">
                        <img src="https://www.gravatar.com/avatar/915aac3dfde2fb502ce415d77643a72d?s=250&amp;d=mm&amp;r=x" alt="Wil Chung"/>
                    </a>
                </li>
            </ul>

            

        </section>
        </div>

            <figure>
                <img srcset="/content/images/size/w300/2025/02/algebraic_langs.jpeg 300w,
                            /content/images/size/w600/2025/02/algebraic_langs.jpeg 600w,
                            /content/images/size/w1000/2025/02/algebraic_langs.jpeg 1000w,
                            /content/images/size/w2000/2025/02/algebraic_langs.jpeg 2000w" sizes="(min-width: 1400px) 1400px, 92vw" src="https://github.com/content/images/size/w2000/2025/02/algebraic_langs.jpeg" alt="Algebraic Handler Lookup in Koka, Eff, OCaml, and Unison"/>
            </figure>

    </header>

    <section>
        <div><p>‚ùì</p><p>This was a report from GPT3o-mini with Deep Research</p></div><div><p>üí≠</p><div><p>What are the different ways to do handler look up in programming languages that support algebraic effects? I know sometimes, they&#39;re also called &#34;abilities&#34; in some languages. A starting point of languages that I know support algebraic effects are, Koka, Eff, Multicore OCaml, and Unison. There might be other languages that support algebraic effects, and I&#39;d like for you to add those languages to the list and look into them as well. </p></div></div><p>You&#39;re already asking very insightful and detailed questions! To ensure I provide the most useful information for you, here are a few clarifications:</p><ol><li><strong>Scope of Languages</strong>: Should I focus only on languages with first-class support for algebraic effects, or would you also like information on languages that approximate them with monads or delimited continuations?</li><li><strong>Practical Examples</strong>: Would you like code samples demonstrating how each language handles effect lookup, type enforcement, and algebra enforcement?</li><li><strong>Comparison and Trade-offs</strong>: Would you be interested in a comparison of different handler lookup mechanisms across languages, highlighting their trade-offs in terms of expressiveness, performance, and ease of reasoning?</li><li><strong>Runtime vs. Compile-Time Guarantees</strong>: Do you want an exploration of how much of effect handling is enforced statically by types vs. dynamically at runtime?</li><li><strong>Use Cases</strong>: Are you particularly interested in any real-world applications of these mechanisms, such as concurrency, error handling, or modular program composition?</li></ol><p>Let me know if these additional angles would be helpful, and I‚Äôll tailor my research accordingly!</p><div><p>üí≠</p><div><p>1. Only languages with first class support. </p></div></div><p>Great! I will investigate how handler lookup works in programming languages with first-class algebraic effects, including Koka, Eff, Multicore OCaml, and Unison, along with any other relevant languages. I will also explore how their type systems ensure correct effect raising and handling, and how they enforce the algebra of effects.</p><p>Additionally, I will:</p><ul><li>Use the same example across all languages to illustrate effect raising, handling, and enforcement.</li><li>Compare the different handler lookup mechanisms and their trade-offs.</li><li>Highlight the runtime capabilities of these languages regarding effect handling, especially in contrast to a dynamically typed language like Python.</li></ul><p>I&#39;ll get back to you with a detailed breakdown soon!</p><hr/><p>Algebraic effects allow defining <em>operations</em> (effects) separately from their implementation. A <em>handler</em> gives meaning to these operations by intercepting them and possibly resuming the computation. We compare how several languages with first-class algebraic effects implement handler lookup and enforce effect discipline.</p><h2 id="koka">Koka</h2><p><strong>1. Handler Lookup Mechanism:</strong> Koka uses <em>evidence passing</em> for handlers, meaning the compiler transforms effectful code to explicitly carry handler ‚Äúevidence‚Äù as hidden parameters‚Äã</p><p><a href="https://www.college-de-france.fr/en/agenda/seminar/control-structures-from-goto-to-algebraic-effects/design-and-compilation-of-efficient-effect-handlers-in-the-koka-language#:~:text=This%20seminar%20talk%20introduces%20the,for%20the%20correct%20effect%20handler" rel="noopener">college-de-france.fr</a>. Rather than a runtime stack search, an effect operation is dispatched in <strong>O(1)</strong> by directly calling the corresponding handler via the evidence. In other words, the nearest handler is determined at compile-time by the lexical scope and passed in, avoiding a linear search on the call stack‚Äã<a href="https://www.college-de-france.fr/en/agenda/seminar/control-structures-from-goto-to-algebraic-effects/design-and-compilation-of-efficient-effect-handlers-in-the-koka-language#:~:text=This%20seminar%20talk%20introduces%20the,for%20the%20correct%20effect%20handler" rel="noopener">college-de-france.fr</a>.</p><p><strong>2. Type System Enforcement (Correct Effects Raised):</strong> Koka‚Äôs type system tracks effects using <em>row polymorphism</em>‚Äã</p><p><a href="https://www.college-de-france.fr/en/agenda/seminar/control-structures-from-goto-to-algebraic-effects/design-and-compilation-of-efficient-effect-handlers-in-the-koka-language#:~:text=This%20seminar%20talk%20introduces%20the,for%20the%20correct%20effect%20handler" rel="noopener">college-de-france.fr</a>. The type of a function includes a set of effects it may perform. For example, one can define an effect and a function as:</p><pre><code>effect state&lt;a&gt; {
  fun get() : a
  fun set(x: a) : ()
}

fun addAndGet(n: int) : &lt;state&lt;int&gt;&gt; int {
  val x = get()
  set(x + n)
  x + n
}
</code></pre><p>Here <code>addAndGet</code> has type <code>int -&gt; &lt;state&lt;int&gt;&gt; int</code>, indicating it may perform the <code>state&lt;int&gt;</code> effect‚Äã</p><p><a href="https://github.com/koka-lang/koka/discussions/107#:~:text=Koka%20has%20effect%20types%20in,Example" rel="noopener">github.com</a>. The compiler ensures you can only call <code>get()</code> or <code>set()</code> inside a function whose effect type includes <code>state&lt;int&gt;</code>; attempting to perform an effect not listed in the type is a type error.</p><p><strong>3. Ensuring All Effects Are Handled:</strong> Koka provides <strong>effect safety</strong>, meaning any effect raised <em>must</em> be handled by some enclosing handler or be reflected in the function‚Äôs effect type‚Äã</p><p><a href="https://v2.ocaml.org/manual/effects.html#:~:text=Unlike%20languages%20such%20as%20Eff,exception%20when%20we%20run%20bar" rel="noopener">v2.ocaml.org</a>. If a function with an effect (e.g. <code>&lt;state&lt;int&gt;&gt;</code>) is called in a context that doesn‚Äôt allow that effect, the type checker rejects it. This ensures that by the time you reach a ‚Äúpure‚Äù boundary (like the program‚Äôs <code>main</code>), all effects have been handled (eliminated from the type). In practice, you handle effects by running a computation under a handler. For example, Koka‚Äôs standard library provides combinators to run a state effect:</p><pre><code>fun runStateExample(): int {
  // Run addAndGet with an initial state of 0 using a state handler
  handle (state&lt;Int&gt;) with { | get -&gt; currentState 
                              | set(newState) -&gt; () } in {
    // initial state
    var currentState: int = 0 
    addAndGet(5)            // performs state operations
  }
}</code></pre><p><em>The above is illustrative; actual Koka syntax may differ, but the idea is that the <code>handle</code> block provides implementations for <code>get</code> and <code>set</code> and an initial state.)</em></p><p>The type of <code>runStateExample</code> is pure (<code>int</code> with no effects) because the state effect is handled within it. Unhandled effects cannot ‚Äúleak‚Äù to the top level in Koka ‚Äì they must appear in the type and ultimately be handled.</p><p><strong>4. Enforcing the Algebra of Effects:</strong> In Koka, an effect is declared with a set of operations (an algebraic interface), and any handler for that effect must implement how each operation behaves. The effect <em>algebra</em> refers to the laws or behavior of those operations. Koka‚Äôs design doesn‚Äôt automatically enforce specific algebraic laws (e.g. commutativity of independent operations) ‚Äì that‚Äôs up to the semantics of your handler ‚Äì but it does enforce the structure: you cannot invoke an operation that wasn‚Äôt declared, and you must handle (or propagate) all operations in a pure context. Because effects are tracked in types, the compiler can reorder independent effects safely and even infer when an effect is effectively unused (e.g. a state handled and removed yields a pure result)‚Äã</p><p><a href="https://arxiv.org/pdf/1306.6316#:~:text=demonstrate%20their%20usefulness%2C%20we%20use,interfering%20references.%20We" rel="noopener">arxiv.org</a>‚Äã<a href="https://arxiv.org/pdf/1306.6316#:~:text=Of%20course%2C%20typing%20errors%20are,handles%20away%20lookups%20and%20updates" rel="noopener">arxiv.org</a>. This means the <em>presence or absence</em> of effects is rigorously checked, which aligns with treating effects as an algebraic theory in the type system.</p><p><strong>5. Dynamic Capabilities vs. Python:</strong> Algebraic effects allow capturing and manipulating the continuation of a computation ‚Äì for example, a handler can intercept an operation, perform some logic, and then <em>resume</em> the computation. This enables advanced control flow like resumable exceptions, backtracking, or coroutines within the language‚Äã</p><p><a href="https://v2.ocaml.org/manual/effects.html#:~:text=Effect%20handlers%20are%20a%20mechanism,be%20built%20using%20effect%20handlers" rel="noopener">v2.ocaml.org</a>‚Äã<a href="https://v2.ocaml.org/manual/effects.html#:~:text=jumps%20to%20the%20corresponding%20handler%2C,of%20perform%20and%20this%20handler" rel="noopener">v2.ocaml.org</a>. In Koka (and similar languages), you can dynamically install different handlers at runtime to change the behavior of effectful operations without changing the effectful code. For instance, the same <code>addAndGet</code> function could be run with one handler that logs state changes, or another that just provides a mutable cell, simply by choosing a different handler. This kind of <em>dynamic dispatch of effects with guaranteed type safety</em> is hard to achieve in a dynamically typed language like Python. Python lacks a built-in mechanism to capture a function‚Äôs continuation and resume it later ‚Äì you‚Äôd have to simulate with generators, context managers, or by manually passing callbacks, which is far less general and safe. Moreover, Python‚Äôs dynamic typing can‚Äôt enforce that a given ‚Äúeffect‚Äù (like an expected exception or callback) is handled; any mistakes would surface as runtime errors. In contrast, Koka ensures at compile time that effectful operations are accounted for, and at runtime its handlers can even resume or replay computations (e.g. try an operation multiple times) ‚Äì something not directly possible in Python without implementing a custom control flow.</p><h2 id="eff">Eff</h2><p><strong>1. Handler Lookup Mechanism:</strong> Eff (a research language by Bauer and Pretnar) treats effect handlers similarly to exception handlers, but generalized. You wrap a computation with a <code>with ... handle ...</code> block that installs a handler‚Äã</p><p><a href="https://math.andrej.com/wp-content/uploads/2012/03/eff.pdf#:~:text=A%20handler%20h%20%3D%20handler,1" rel="noopener">math.andrej.com</a>. When an effect operation is performed inside that computation, control transfers to the nearest enclosing handler that has a clause for that operation. This lookup is dynamic, following the call stack: an unhandled effect bubbles outward until a matching handler is found (just like unwinding for exceptions)‚Äã<a href="https://v2.ocaml.org/manual/effects.html#:~:text=earlier%2C%20effect%20handlers%20are%20a,of%20perform%20and%20this%20handler" rel="noopener">v2.ocaml.org</a>. Internally, Eff can be understood in terms of <em>multi-prompt delimited continuations</em>, where each effect type acts like a prompt/tag; performing an effect searches for the matching prompt in the stack. The first matching handler captures the continuation and handles the operation.</p><p><strong>2. Type System Enforcement (Correct Effects Raised):</strong> Eff is statically typed and has a <em>type and effect system</em>‚Äã</p><p><a href="https://math.andrej.com/wp-content/uploads/2012/03/eff.pdf#:~:text=Eff%20is%20a%20statically%20typed,records%2C%20and%20recursive%20type%20definitions" rel="noopener">math.andrej.com</a>. Every function‚Äôs type can include an effect component (often a set of effect labels) indicating which effects it may perform. You can only perform an operation if the effect is declared in the current context‚Äôs effect type. For example, in Eff one might declare:</p><pre><code>operation Get : int      (* declares an effect operation returning int *)
operation Put : int -&gt; () 
let addAndGet x = 
  let curr = Get in       (* perform Get operation *)
  let ()  = Put (curr + x) in  (* perform Put operation *)
  curr + x 
(* The inferred type of addAndGet might be: int -&gt; int !{State} *)</code></pre><p>The notation <code>!{State}</code> (hypothetical syntax) indicates this function can perform the <code>State</code> effect. Eff‚Äôs compiler will infer or check these effect annotations‚Äã</p><p><a href="https://arxiv.org/pdf/1306.6316#:~:text=An%20effect%20system%20supplements%20a,on%20the%20task%20of%20striking" rel="noopener">arxiv.org</a>‚Äã<a href="https://arxiv.org/pdf/1306.6316#:~:text=Our%20effect%20system%20is%20descriptive,In%20the" rel="noopener">arxiv.org</a>. If you attempt to perform an effect not in the type, the program is rejected.</p><p><strong>3. Ensuring All Effects Are Handled:</strong> Eff provides <strong>effect safety</strong> much like Koka‚Äã</p><p><a href="https://v2.ocaml.org/manual/effects.html#:~:text=Unlike%20languages%20such%20as%20Eff,exception%20when%20we%20run%20bar" rel="noopener">v2.ocaml.org</a>. An unhandled effect in Eff is a compile-time error; you cannot simply run a computation that might perform effects without handling them. To eliminate an effect from the type, you wrap the computation in an appropriate handler. Eff‚Äôs effect typing is <em>non-monotonic</em>, meaning that when you handle an effect, it is removed from the effect set of that computation‚Äôs type‚Äã<a href="https://arxiv.org/pdf/1306.6316#:~:text=Of%20course%2C%20typing%20errors%20are,handles%20away%20lookups%20and%20updates" rel="noopener">arxiv.org</a>. For instance, if <code>addAndGet</code> has effect <code>State</code>, then an expression <code>with stateHandler(initial=0) handle addAndGet(5)</code> would be pure (the handler consumes the <code>State</code> effect). If any effect remains unhandled by the time you reach the top level, the program won‚Äôt typecheck. Thus, all raised effects must be accounted for by some handler. (Eff does not provide a default behavior for effects‚Äî<em>‚Äúthere is no need for a default behaviour to start with‚Äù</em>, so unhandled effects are simply not allowed‚Äã<a href="https://www.eff-lang.org/#:~:text=Just%20like%20exceptions%20are%20a,prevented%20or%20grouped%20in%20transactions" rel="noopener">eff-lang.org</a>.)</p><p><strong>4. Enforcing the Algebra of Effects:</strong> In Eff, an <em>effect</em> is essentially an interface consisting of operations, and a handler gives an implementation (an algebra) for those operations‚Äã</p><p><a href="https://math.andrej.com/wp-content/uploads/2012/03/eff.pdf#:~:text=Eff%20is%20a%20programming%20language,14%2C%2017" rel="noopener">math.andrej.com</a>‚Äã<a href="https://math.andrej.com/wp-content/uploads/2012/03/eff.pdf#:~:text=backtracking%2C%20and%20many%20others,An%20experiment%20in" rel="noopener">math.andrej.com</a>. The language ensures that a handler covers the operations you care to handle, and any not handled explicitly will remain in the effect type, forcing an outer handler. This effectively means that to completely handle an effect, you must provide interpretations for all of its operations. Eff‚Äôs rigorous effect type system allows equational reasoning about effects ‚Äì for example, one can prove that two sequences of operations commute if their effect sets don‚Äôt interfere‚Äã<a href="https://arxiv.org/pdf/1306.6316#:~:text=demonstrate%20their%20usefulness%2C%20we%20use,interfering%20references.%20We" rel="noopener">arxiv.org</a>. However, the language itself doesn‚Äôt enforce algebraic laws like commutativity; it simply provides the framework (handlers and effect types) so that programmers or researchers can reason about and ensure such laws. In essence, Eff enforces the <em>structure</em> of the algebra (each operation is invoked and handled explicitly) and leaves the semantics (the laws) to the handler implementations and external reasoning.</p><p><strong>5. Dynamic Capabilities vs. Python:</strong> Eff demonstrates many dynamic tricks impossible or unsafe in Python. A handler in Eff can capture the <em>continuation</em> of a computation at the point an effect is performed, allowing the handler to decide if, when, and how to resume that computation‚Äã</p><p><a href="https://v2.ocaml.org/manual/effects.html#:~:text=jumps%20to%20the%20corresponding%20handler%2C,of%20perform%20and%20this%20handler" rel="noopener">v2.ocaml.org</a>‚Äã<a href="https://v2.ocaml.org/manual/effects.html#:~:text=with%20the%20delimited%20continuation%20k%2C,of%20perform%20and%20this%20handler" rel="noopener">v2.ocaml.org</a>. For example, one could implement backtracking search by capturing a continuation and invoking it multiple times with different choices ‚Äì effectively cloning the computation for each choice. Python does not support capturing an arbitrary call stack segment and re-running it; at best, one can use generators or threads to achieve limited forms of backtracking or coroutines, but these are ad-hoc and not enforced by the language‚Äôs type system. Moreover, in Eff you can dynamically layer handlers ‚Äì e.g., handle an output effect by appending to a log, or swap in a handler that completely silences the output‚Äã<a href="https://www.eff-lang.org/#:~:text=Eff%20is%20a%20functional%20programming,threads%2C%20and%20much%20much%20more%E2%80%A6" rel="noopener">eff-lang.org</a>‚Äã<a href="https://www.eff-lang.org/#:~:text=Just%20like%20exceptions%20are%20a,prevented%20or%20grouped%20in%20transactions" rel="noopener">eff-lang.org</a>. Achieving the same in Python would require monkey-patching global behavior or passing around callback hooks, with no compile-time guarantees. Eff‚Äôs approach allows, for instance, treating <em>all</em> state modifications as transactional by wrapping a state handler that can roll back on error, which would be extremely complex to do reliably in Python. All these dynamic control-flow manipulations in Eff are <em>type-safe</em>, meaning if your program compiles, you haven‚Äôt forgotten to handle a case ‚Äì a guarantee Python lacks.</p><p><em>Example (Eff):</em> To mirror the state example, in Eff you might write:</p><pre><code>operation Get : int
operation Put : int -&gt; ()

let addAndGet n : int !{State} =
  let curr = Get in           (* perform state read *)
  Put (curr + n);             (* perform state write *)
  curr + n

(* A handler for the State effect: *)
let stateHandler init = handler
  | val x       -&gt; x                        (* result case *)
  | #Get k      -&gt; k! init init             (* on Get, k is the continuation; pass the state as result and current state *)
  | #Put new k  -&gt; k! () new                (* on Put, update state and resume *)
in

with stateHandler(0) handle addAndGet 5    (* runs addAndGet with initial state 0, yielding 5 and final state discarded or accessible if handler returns it *)
</code></pre><p>This is pseudo-code illustrating an Eff handler. The handler treats the computation as a function from state to result (the continuation <code>k</code> is invoked with the appropriate state). After handling, the effect <code>{State}</code> is removed from the type. Trying to use <code>addAndGet</code> without a handler or outside a <code>{State}</code> context would be a compile error.</p><h2 id="multicore-ocaml-ocaml-5">Multicore OCaml (OCaml 5+)</h2><p><strong>1. Handler Lookup Mechanism:</strong> OCaml 5 introduced effect handlers as an extension to the language‚Äã</p><p><a href="https://news.ycombinator.com/item?id=38810073#:~:text=OCaml%205,html" rel="noopener">news.ycombinator.com</a>. In OCaml, performing an effect is done via <code>perform EffectName(arguments)</code> and handlers are installed with a syntax similar to exceptions using pattern matching. The lookup is <strong>dynamic</strong> and works like unwinding the call stack: when <code>perform E</code> is executed, the runtime jumps to the nearest surrounding handler that matches effect <code>E</code>‚Äã<a href="https://v2.ocaml.org/manual/effects.html#:~:text=earlier%2C%20effect%20handlers%20are%20a,of%20perform%20and%20this%20handler" rel="noopener">v2.ocaml.org</a>. If none is found in the current function, it unwinds to the caller, and so on. This is analogous to exception lookup, except the handler pattern is marked with the <code>effect</code> keyword. For example:</p><pre><code>effect Get : int        (* declare an effect *)
effect Put : int -&gt; unit

let addAndGet n =
  let x = perform Get in        (* raise Get effect *)
  let () = perform (Put (x + n)) in  (* raise Put effect *)
  x + n

(* Using the effect with a handler *)
let result =
  try addAndGet 5 with
  | effect Get k -&gt;       (* handle Get by providing a state *)
      (* here k is the continuation; resume it with the state value *)
      continue k state_value 
  | effect (Put new_val) k -&gt;
      state_value := new_val;   (* update state *)
      continue k ()</code></pre><p>This handler intercepts <code>Get</code> and <code>Put</code>. The special pattern <code>effect E p, k</code> binds <code>k</code> to the continuation. OCaml supports <strong>deep handlers</strong> (handle all effects in the block) and <strong>shallow handlers</strong> (handle one effect at a time)‚Äã</p><p><a href="https://v2.ocaml.org/manual/effects.html#:~:text=In%20this%20example%2C%20we%20use,6" rel="noopener">v2.ocaml.org</a>, but in both cases, it‚Äôs the innermost dynamically enclosing handler that catches a performed effect.</p><p><strong>2. Type System Enforcement (Correct Effects Raised):</strong> Unlike Koka or Eff, OCaml‚Äôs type system does <strong>not</strong> track effects in types. Effects are more like exceptions: any function can <code>perform E</code> without mentioning <code>E</code> in its type. The only static check is that the type of the performed effect‚Äôs payload matches its declaration. For instance, <code>perform Get</code> is only allowed if <code>Get : int Effect.t</code> (so it returns an int)‚Äã</p><p><a href="https://v2.ocaml.org/manual/effects.html#:~:text=We%20declare%20the%20exchange%20effect,primitive%20and%20returns%20their%20sum" rel="noopener">v2.ocaml.org</a>. But there‚Äôs no static annotation that <code>addAndGet</code> is effectful. In other words, OCaml functions do not have an effect signature ‚Äì the type system won‚Äôt stop you from calling an effectful function in a context that isn‚Äôt handling the effect. The responsibility is on the programmer to know which effects might be raised. The effect declaration itself uses OCaml‚Äôs extensible variant type mechanism (extending the built-in <code>Effect.t</code> type), which ensures only valid effect constructors can be performed‚Äã<a href="https://v2.ocaml.org/manual/effects.html#:~:text=We%20declare%20the%20exchange%20effect,primitive%20and%20returns%20their%20sum" rel="noopener">v2.ocaml.org</a>, but beyond that, ‚Äúcorrect effects‚Äù are not enforced by the type system.</p><p><strong>3. Ensuring All Effects Are Handled:</strong> OCaml does <strong>not</strong> provide compile-time effect safety‚Äã</p><p><a href="https://v2.ocaml.org/manual/effects.html#:~:text=Unlike%20languages%20such%20as%20Eff,exception%20when%20we%20run%20bar" rel="noopener">v2.ocaml.org</a>. If you perform an effect and no handler for it exists dynamically, the runtime will raise a special <code>Effect.Unhandled</code> exception at the point of the <code>perform</code>‚Äã<a href="https://v2.ocaml.org/manual/effects.html#:~:text=Unlike%20languages%20such%20as%20Eff,exception%20when%20we%20run%20bar" rel="noopener">v2.ocaml.org</a>. This is a runtime error analogous to an uncaught exception. For example, if <code>addAndGet 5</code> is called outside of any handler for <code>Get</code>/<code>Put</code>, the program will throw <code>Effect.Unhandled Get</code>. There is no static guarantee all effects are handled ‚Äì it‚Äôs up to the developer to ensure handlers are in place. (This is a deliberate design trade-off in OCaml to keep the type system simple; <em>‚Äúunlike languages such as Eff and Koka, effect handlers in OCaml do not provide effect safety‚Äù</em>‚Äã<a href="https://v2.ocaml.org/manual/effects.html#:~:text=Unlike%20languages%20such%20as%20Eff,exception%20when%20we%20run%20bar" rel="noopener">v2.ocaml.org</a>.)</p><p><strong>4. Enforcing the Algebra of Effects:</strong> OCaml‚Äôs language runtime enforces one important aspect of effect algebra: <strong>linearity of continuations</strong>. Once an effect‚Äôs continuation (<code>k</code>) is captured in a handler, OCaml ensures you resume it at most once‚Äã</p><p><a href="https://v2.ocaml.org/manual/effects.html#:~:text=As%20discussed%20earlier%C2%A012,For%20example" rel="noopener">v2.ocaml.org</a>‚Äã<a href="https://v2.ocaml.org/manual/effects.html#:~:text=raises%20a%20Continuation_already_resumed%20exception,example" rel="noopener">v2.ocaml.org</a>. If you attempt to <code>continue k</code> twice (or not at all), OCaml raises a runtime error (<code>Continuation_already_resumed</code> for double resume)‚Äã<a href="https://v2.ocaml.org/manual/effects.html#:~:text=As%20discussed%20earlier%C2%A012,For%20example" rel="noopener">v2.ocaml.org</a>. This effectively treats continuations as one-shot ‚Äì ensuring that effects like state or I/O aren‚Äôt accidentally performed more times than intended via multiple resumption (which could violate linear resource usage‚Äã<a href="https://v2.ocaml.org/manual/effects.html#:~:text=The%20primary%20motivation%20for%20adding,Hence%2C%20OCaml%20does%20not" rel="noopener">v2.ocaml.org</a>). [1] Aside from this, OCaml doesn‚Äôt enforce algebraic laws of effects ‚Äì you can implement any semantics in handlers. Because OCaml doesn‚Äôt require handlers to handle every operation of an effect (effects are declared individually), you could have an effect with multiple operations and only handle some of them, leaving others unhandled (leading to <code>Unhandled</code> exceptions if actually performed). The <strong>algebraic structure</strong> (which operations exist for an effect) is defined by how you extend the <code>Effect.t</code> type (each <code>effect X : ...</code> adds a constructor), but there‚Äôs no requirement that a handler provide cases for all of them. In practice, to fully define an effect‚Äôs meaning you‚Äôd handle all its operations, but the language won‚Äôt stop you from handling only a subset (unhandled ones just propagate outward).</p><p><strong>5. Dynamic Capabilities vs. Python:</strong> OCaml‚Äôs effect handlers bring powerful dynamic control to an otherwise statically typed language. At runtime, you can capture the execution state at an effect and decide what to do ‚Äì e.g., pause the computation or schedule it elsewhere. Indeed, a primary use-case in OCaml is to implement lightweight concurrency (threads, generators) using effect handlers‚Äã</p><p><a href="https://v2.ocaml.org/manual/effects.html#:~:text=Effect%20handlers%20are%20a%20mechanism,be%20built%20using%20effect%20handlers" rel="noopener">v2.ocaml.org</a>‚Äã<a href="https://v2.ocaml.org/manual/effects.html#:~:text=%EF%BB%BF24" rel="noopener">v2.ocaml.org</a>. For example, one can create a scheduler where an effect <code>Yield</code> captures a continuation representing a ‚Äúpaused thread‚Äù and the handler stores it, later resuming those continuations to round-robin schedule tasks‚Äã<a href="https://v2.ocaml.org/manual/effects.html#:~:text=A%20task%20either%20is%20in,the%20task%20status%20as%20follows" rel="noopener">v2.ocaml.org</a>‚Äã<a href="https://v2.ocaml.org/manual/effects.html#:~:text=completes%20or%20suspends%3A" rel="noopener">v2.ocaml.org</a>. This kind of inversion of control ‚Äì where a function deep in the call stack yields control and is resumed later ‚Äì cannot be done transparently in Python. Python‚Äôs generators and <code>async</code>/<code>await</code> provide <em>some</em> similar abilities, but those require the functions to be written in a specific style (using <code>yield</code> or <code>await</code>), whereas effect handlers can turn <em>any</em> regular function into a coroutine by handling an effect. Moreover, effect handlers can be composed: you can have multiple different handlers for different effects co-existing, intercepting different operations. In Python, composing different cross-cutting concerns (logging, exception handling, state threading) often requires messy combinations of context managers, decorators, or frameworks. OCaml‚Äôs approach lets you do this dynamically with clear separation of concerns. While Python can simulate some of these patterns, it cannot ensure at compile time that a given ‚Äúeffect‚Äù is handled, nor can it capture and resume arbitrary call stack segments as first-class values ‚Äì which is exactly what algebraic effects provide.</p><p><em>Example (OCaml):</em> Using the earlier <code>Get</code>/<code>Put</code> example, in OCaml:</p><pre><code>(* Define effects *)
effect Get : int
effect Put : int -&gt; unit

let addAndGet n =
  let x = perform Get in        (* might raise Get effect *)
  perform (Put (x + n));        (* might raise Put effect *)
  x + n

(* Running addAndGet with a handler *)
let (result, final_state) =
  let state = ref 0 in
  try 
    (addAndGet 5, !state) 
  with
  | effect Get k -&gt; 
      let curr = !state in
      continue k curr            (* resume addAndGet, substituting the result of perform Get with curr *)
  | effect (Put new_val) k -&gt;
      state := new_val; 
      continue k ()              (* resume, substituting perform Put with () *)
</code></pre><p>In this pseudo-code, <code>state</code> is a reference (since OCaml has mutable refs) capturing the state. After the <code>try</code>...<code>with</code>, <code>result</code> would be <code>5</code> and <code>final_state</code> would be <code>5</code> (the updated state). If we call <code>addAndGet</code> outside of the <code>try</code> handler, it would raise <code>Effect.Unhandled Get</code> at runtime‚Äã</p><p><a href="https://v2.ocaml.org/manual/effects.html#:~:text=Unlike%20languages%20such%20as%20Eff,exception%20when%20we%20run%20bar" rel="noopener">v2.ocaml.org</a>.</p><h2 id="unison">Unison</h2><p><strong>1. Handler Lookup Mechanism:</strong> Unison implements algebraic effects via its <em>abilities</em> system. The lookup of a handler in Unison is more structured: you use a <code>handle ... with ...</code> block to run a computation with a given ability handler‚Äã</p><p><a href="https://www.unison-lang.org/docs/language-reference/abilities-and-ability-handlers/#:~:text=,expressions" rel="noopener">unison-lang.org</a>. This is lexically scoped, but at runtime it acts similarly to dynamic scope ‚Äì when a computation requires an ability (performs an effect), it is handled by the nearest enclosing <code>handle</code> that provides that ability. Internally, Unison transforms the code so that calls to ability operations are routed to the handler. The handler is typically a function that pattern-matches on requests. For example:</p><pre><code>ability State a where
  get : a           -- operation to get the state
  put : a -&gt; ()     -- operation to set the state

-- A function using the State ability:
addAndGet n : &#39;{State Nat} Nat =    -- `{State Nat}` denotes an ability requirement
  x = State.get
  State.put (x + n)
  x + n

-- A handler for State that uses a mutable reference
handleState : Nat -&gt; Request (State Nat) r -&gt; r
handleState initial req =
  case req of
    {State.get -&gt; k}    -&gt;       -- handle `get` requests
      handleState initial (continue k initial)
    {State.put new -&gt; k} -&gt;      -- handle `put` requests
      handleState new (continue k ())
    {r -&gt; _} -&gt;                 -- final result `r` (when computation is done)
      (r, initial)
</code></pre><p><code>handle addAndGet 5 with handleState 0</code> will run <code>addAndGet 5</code> with initial state 0. The mechanism ensures that any call to <code>State.get</code> or <code>State.put</code> inside <code>addAndGet</code> is intercepted by <code>handleState</code>. In Unison, this lookup is guaranteed by the compiler transformation ‚Äì you cannot call an ability operation without a corresponding handler in scope (the code won‚Äôt compile)‚Äã</p><p><a href="https://www.unison-lang.org/docs/language-reference/abilities-and-ability-handlers/#:~:text=handler%20for%20the%20ability%20,by%20an%20enclosing%20handle%20expression" rel="noopener">unison-lang.org</a>.</p><p><strong>2. Type System Enforcement (Correct Effects Raised):</strong> Unison‚Äôs type system makes abilities explicit in function types. A function type is written <code>Input -&gt;{Ability} Output</code>‚Äã</p><p><a href="https://www.unison-lang.org/docs/language-reference/abilities-and-ability-handlers/#:~:text=The%20general%20form%20for%20a,A1%2CA2%2CA3%7D%20O" rel="noopener">unison-lang.org</a>. For example, <code>addAndGet</code> might have type <code>Nat -&gt;{State Nat} Nat</code>, meaning it requires the <code>State Nat</code> ability. The compiler checks that any call to a function is in a context that provides the required abilities‚Äã<a href="https://www.unison-lang.org/docs/language-reference/abilities-and-ability-handlers/#:~:text=The%20general%20typechecking%20rule%20used,is%20available%20and%20therefore" rel="noopener">unison-lang.org</a>. If you attempt to perform an ability operation without that ability in your context, you get a compile-time <em>ability check failure</em>‚Äã<a href="https://www.unison-lang.org/docs/language-reference/abilities-and-ability-handlers/#:~:text=The%20general%20typechecking%20rule%20used,is%20available%20and%20therefore" rel="noopener">unison-lang.org</a>‚Äã<a href="https://www.unison-lang.org/docs/language-reference/abilities-and-ability-handlers/#:~:text=%60,is%20available%20and%20therefore" rel="noopener">unison-lang.org</a>. In practice, this means you either call <code>addAndGet</code> inside a <code>handle ... with ...</code> for <code>State Nat</code>, or your calling function itself must be annotated to require <code>State Nat</code> (propagating the requirement). Thus, Unison ensures you only raise effects (make ability requests) that are declared. The ability set in the type acts like a contract ‚Äì you can‚Äôt do a sneaky effect that‚Äôs not in the type.</p><p><strong>3. Ensuring All Effects Are Handled:</strong> In Unison, any ability requirements must be satisfied by the environment. At the top level (in a program or a pure function), the ability set must be empty (top-level definitions are required to be pure)‚Äã</p><p><a href="https://www.unison-lang.org/docs/language-reference/abilities-and-ability-handlers/#:~:text=For%20top,For%20instance%2C%20this%20doesn%27t%20typecheck" rel="noopener">unison-lang.org</a>. This forces all effects to be handled by the time you leave a <code>handle</code> block or exit a function. If an ability is not handled, the program simply won‚Äôt typecheck (<em>‚Äúa type error will result if an ability is required in a scope where it is not provided by an enclosing handle‚Äù</em>‚Äã<a href="https://www.unison-lang.org/docs/language-reference/abilities-and-ability-handlers/#:~:text=handler%20for%20the%20ability%20,by%20an%20enclosing%20handle%20expression" rel="noopener">unison-lang.org</a>). This is strict effect safety. For example, if <code>main : &#39;{IO} ()</code> (meaning main does IO), the runtime will likely handle the <code>IO</code> ability by actually performing the IO (Unison has some built-in abilities like <code>IO</code> that are ultimately handled by the runtime), but you cannot have an ability like <code>State</code> unhandled at the top ‚Äì you‚Äôd need to wrap it in a handler that, say, uses a pure state or converts it to an output value. Unison thus statically guarantees all ability requests are accounted for by some handler.</p><p><strong>4. Enforcing the Algebra of Effects:</strong> Unison‚Äôs abilities are declared much like interfaces with a set of operations (see the <code>ability State a where ...</code> syntax above). The language requires that any handler for an ability provides a function that accepts a <code>Request</code> of that ability‚Äã</p><p><a href="https://www.unison-lang.org/docs/language-reference/abilities-and-ability-handlers/#:~:text=,expressions" rel="noopener">unison-lang.org</a>. This <code>Request</code> object encapsulates either a request (with a constructor corresponding to one of the ability‚Äôs operations and a continuation) or the final result. A handler function must pattern match on all possible request constructors it wants to handle. If it omits some (say a handler only matches <code>State.get</code> but not <code>State.put</code>), then any <code>State.put</code> will not be handled by that handler and will bubble to an outer handler (or cause a compile error if none). In practice, to fully handle an ability, you implement all its operations. The compiler doesn‚Äôt force you to cover every constructor in one handler (you could have a chain of handlers each handling different operations of the same ability), but it ensures that if something isn‚Äôt handled, it remains as a requirement in the type. Unison‚Äôs design (inspired by Frank‚Äã<a href="https://www.unison-lang.org/docs/language-reference/abilities-and-ability-handlers/#:~:text=processing%2C%20exception%20handling%2C%20parsing%2C%20distributed,In%20particular" rel="noopener">unison-lang.org</a>) maintains the algebraic structure by making the ability an explicit parameter of the computation. Notably, a Unison handler can choose to ignore the continuation (<code>k</code>) or call it multiple times‚Äã<a href="https://www.unison-lang.org/docs/language-reference/abilities-and-ability-handlers/#:~:text=A%20handler%20can%20choose%20to,or%20to%20call%20it%20multiple" rel="noopener">unison-lang.org</a>, enabling algebraic manipulations like aborting a computation or duplicating it (for nondeterminism). These are not arbitrary gotos; they must respect the ability‚Äôs interface. While Unison doesn‚Äôt check algebraic laws (e.g. you could implement handlers that don‚Äôt obey state laws, if you wanted), its pure functional nature means you can reason about handler behavior. The ability system <em>does</em> enforce that abilities compose and distribute correctly ‚Äì for instance, ability polymorphism is handled by type polymorphism, and an empty ability set means a computation is pure (no effects)‚Äã<a href="https://www.unison-lang.org/docs/language-reference/abilities-and-ability-handlers/#:~:text=detailed%20in%20this%20paper,particular" rel="noopener">unison-lang.org</a>‚Äã<a href="https://www.unison-lang.org/docs/language-reference/abilities-and-ability-handlers/#:~:text=,handle%20construct%20for%20this%20purpose" rel="noopener">unison-lang.org</a>.</p><p><strong>5. Dynamic Capabilities vs. Python:</strong> Unison‚Äôs abilities allow for very dynamic behaviors while still being statically checked. At runtime, you can provide different handlers to the same computation to change its outcome. For example, you might run a parser with an ability <code>Choice</code> using one handler that finds the first successful parse or another that collects <em>all</em> possible parses. The parser code doesn‚Äôt change; just the handler does. In a dynamically-typed language like Python, achieving this would require designing the parser to call into user-provided callbacks or using exceptions for backtracking ‚Äì techniques that are error-prone and not enforced by the language. Unison can also perform <em>multi-shot continuations</em> easily ‚Äì a handler can call the continuation multiple times to, say, explore different branches (for nondeterministic effects)‚Äã</p><p><a href="https://www.unison-lang.org/docs/language-reference/abilities-and-ability-handlers/#:~:text=,See%20below%20for%20an%20example" rel="noopener">unison-lang.org</a>. Python doesn‚Äôt support copying a call stack to implement such logic; you‚Äôd have to manually manage recursion or threads. Furthermore, Unison‚Äôs type system ensures that if a function is pure (no abilities), it really can‚Äôt do I/O or mutate state ‚Äì something you can never be sure of in Python without reading all the code. At runtime, Unison‚Äôs effect handling allows features like distributed computation (abilities for distributed nodes), where a handler might send requests over the network ‚Äì all while the core logic is written as a pure sequence of calls. This separation of concerns (pure logic vs. effect interpretation) is much harder to achieve in Python, where concerns tend to tangle (for instance, printing or logging can happen anywhere with no guarantee it‚Äôs caught or redirectable). In short, Unison offers the dynamic flexibility of hooking into a program‚Äôs operations (like one could with monkey-patching in Python) but in a disciplined, type-safe manner.</p><p><em>Example (Unison):</em> Using the same state example:</p><pre><code>ability State a where
  get : a
  put : a -&gt; ()

addAndGet : Nat -&gt;{State Nat} Nat
addAndGet n =
  x = State.get       -- perform get
  State.put (x + n)   -- perform put
  x + n

-- A simple state handler that threads an integer state
handleState : Nat -&gt; Request (State Nat) Nat -&gt; Nat
handleState curr req =
  case req of
    {State.get -&gt; k}      -&gt; continue k curr |&gt; handleState curr
    {State.put new -&gt; k}  -&gt; continue k ()   |&gt; handleState new
    {result -&gt; _}         -&gt; result

-- Running the computation with a handler:
(handle addAndGet 5 with handleState 0)  -- returns 5, with state internally updated to 5
</code></pre><p>In this pseudo-Unison code, <code>handleState</code> is a recursive function that processes a <code>Request (State Nat) Nat</code>. It uses pattern matching to handle <code>get</code> and <code>put</code> requests, updating the state accordingly, and when the computation finishes (<code>{result -&gt; _}</code> case), it returns the final result. The use of <code>continue k ...</code> resumes the captured continuation <code>k</code> with a value. If we didn‚Äôt provide a <code>handleState</code> handler and tried to use <code>addAndGet 5</code> in a pure context, the Unison compiler would complain that the ability <code>State Nat</code> is not available (i.e., unhandled).</p><h2 id="other-languages-with-native-algebraic-effects">Other Languages with Native Algebraic Effects</h2><ul><li><strong>Idris 2:</strong> Idris 2 is a dependently-typed language that includes algebraic effects in its core library. Its approach is similar to Unison‚Äôs abilities ‚Äì effects are described as interfaces (with operations), and programs requiring effects get those in their type. Handlers in Idris 2 can be written to interpret those effects. One unique aspect is that Idris 2 can use <em>linear types</em> to ensure certain effects (like IO) are handled linearly (each request used exactly once), combining effect safety with resource safety. The handler lookup in Idris 2 is lexical (you call effectful code within a do-block that provides a handler), and the type system, being very powerful, can even express dependencies between effect usage and program state.</li></ul><p><strong>Frank:</strong> Frank is a research language that heavily influenced Unison‚Äã<a href="https://www.unison-lang.org/docs/language-reference/abilities-and-ability-handlers/#:~:text=processing%2C%20exception%20handling%2C%20parsing%2C%20distributed,In%20particular" rel="noopener">unison-lang.org</a>. It explores a <em>type-directed</em> style of effect handling, where instead of an explicit <code>handle</code> syntax, functions can take handlers as arguments in a more seamless way. In Frank, an effectful function‚Äôs type specifies what handler it expects, and providing that handler is like passing an argument. This means handler lookup is almost entirely determined at compile time by function application. The algebra of effects in Frank is enforced by its type system in a very strict way: the empty ability in Frank means ‚Äúability polymorphic‚Äù (contrasting with Unison)‚Äã<a href="https://www.unison-lang.org/docs/language-reference/abilities-and-ability-handlers/#:~:text=detailed%20in%20this%20paper,particular" rel="noopener">unison-lang.org</a>, so to handle an effect you actually instantiate that polymorphism with a concrete ability. Frank‚Äôs design makes effect handling feel more like ordinary function calls, improving reasoning at the cost of a steeper learning curve.</p><ul><li><strong>Links (Effekt, etc.):</strong> Some other languages and research projects, like <strong>Links</strong> (a web programming language) and <strong>Effekt</strong> (research project in Scala), also support algebraic effects natively. They typically use row-polymorphic effect types (like Koka/Eff) to track effects and ensure handlers are provided. The handler lookup in these systems is dynamic (searching for the nearest handler), but the type systems guarantee that search will succeed (or else the program is rejected). These languages often enforce that effect operations cannot be invoked except under a matching handler context, effectively providing the same safety and flexibility we see in Eff and Koka.</li></ul><h2 id="comparison-of-handler-lookup-mechanisms">Comparison of Handler Lookup Mechanisms</h2><p><strong>Lookup Strategies:</strong> Broadly, we see two strategies: <strong>dynamic search</strong> versus <strong>static routing</strong>. Languages like Eff, Unison, and OCaml perform a dynamic lookup for the nearest handler at runtime (though guided by lexical scope). This is analogous to exception handling ‚Äì flexible, but potentially with a small runtime cost (scanning stack frames or jumping to handler addresses). Koka, by contrast, uses static routing via evidence passing‚Äã</p><p><a href="https://www.college-de-france.fr/en/agenda/seminar/control-structures-from-goto-to-algebraic-effects/design-and-compilation-of-efficient-effect-handlers-in-the-koka-language#:~:text=This%20seminar%20talk%20introduces%20the,for%20the%20correct%20effect%20handler" rel="noopener">college-de-france.fr</a>, essentially turning effect handling into direct function calls. This yields constant-time dispatch for effects and can be inlined or optimized by the compiler. The trade-off is complexity in the compiler (Koka‚Äôs compiler carries around evidence and does a monadic transformation‚Äã<a href="https://www.college-de-france.fr/en/agenda/seminar/control-structures-from-goto-to-algebraic-effects/design-and-compilation-of-efficient-effect-handlers-in-the-koka-language#:~:text=This%20seminar%20talk%20introduces%20the,for%20the%20correct%20effect%20handler" rel="noopener">college-de-france.fr</a>), whereas dynamic systems are often easier to implement (just like implementing exceptions).</p><p><strong>Expressiveness:</strong> All these languages achieve similar expressiveness in terms of what you can do with effects (since they all implement the theoretical concept of algebraic effects). However, certain choices impact multi-shot vs one-shot continuations. Eff (the research language) and Unison allow <em>multi-shot</em> continuations (a handler can invoke a continuation multiple times or not at all)‚Äã</p><p><a href="https://www.unison-lang.org/docs/language-reference/abilities-and-ability-handlers/#:~:text=,See%20below%20for%20an%20example" rel="noopener">unison-lang.org</a>, enabling powerful constructs like backtracking, probabilistic branching, or undoing and redoing computations. OCaml‚Äôs handlers are deliberately limited to <em>one-shot</em> continuations ‚Äì once resumed, a continuation cannot be reused‚Äã<a href="https://v2.ocaml.org/manual/effects.html#:~:text=As%20discussed%20earlier%C2%A012,For%20example" rel="noopener">v2.ocaml.org</a>. This restricts expressiveness slightly (you can‚Äôt directly implement nondeterministic branching by resuming twice), but simplifies reasoning about resources and improves performance for concurrency use-cases‚Äã<a href="https://v2.ocaml.org/manual/effects.html#:~:text=The%20primary%20motivation%20for%20adding,Hence%2C%20OCaml%20does%20not" rel="noopener">v2.ocaml.org</a>. Koka‚Äôs approach, being based on pure functions, conceptually could allow multi-shot usage (since a continuation is just a function), but it might rely on the programmer to not misuse linear resources if they do so. In practice, each language‚Äôs decision here reflects its goals: OCaml targets efficiency and predictable semantics for systems programming, whereas Eff and Unison, being more high-level, explore the full generality of algebraic effects.</p><p><strong>Performance:</strong> Dynamic handler lookup typically involves checking for a handler at the perform site. In OCaml, performing an effect is quite efficient ‚Äì it doesn‚Äôt copy the whole stack (the continuation is a linked stack slice)‚Äã</p><p><a href="https://v2.ocaml.org/manual/effects.html#:~:text=The%20delimited%20continuation%20k%20is,continue%20or%20discontinue%20are%20fast" rel="noopener">v2.ocaml.org</a>‚Äã<a href="https://v2.ocaml.org/manual/effects.html#:~:text=continuation%20does%20not%20involve%20copying,continue%20or%20discontinue%20are%20fast" rel="noopener">v2.ocaml.org</a>, and invoking the handler is similar to an exception throw plus a function call. Still, if effects are very frequent (e.g. millions of tiny operations), a dynamic search might incur overhead. Koka‚Äôs evidence-passing shines in that scenario: effect calls are basically direct calls (no search)‚Äã<a href="https://www.college-de-france.fr/en/agenda/seminar/control-structures-from-goto-to-algebraic-effects/design-and-compilation-of-efficient-effect-handlers-in-the-koka-language#:~:text=This%20seminar%20talk%20introduces%20the,for%20the%20correct%20effect%20handler" rel="noopener">college-de-france.fr</a>. This can make effectful code as fast as or faster than equivalent code using monads or other abstractions. On the other hand, evidence passing can make the generated code larger or more complex, as it threads extra parameters everywhere (though Koka‚Äôs compiler mitigates this with optimization). Another consideration is that static effect systems can enable <strong>compile-time optimizations</strong>: for example, if the compiler sees that an effect is handled by a handler that simply calls the default behavior, it could inline or remove the indirection. Dynamic systems have to handle it at runtime. That said, for most use-cases, the difference is minor unless you‚Äôre writing performance-critical code with lots of fine-grained effects.</p><p><strong>Ease of Reasoning:</strong> Static effect typing (as in Koka, Eff, Unison) makes reasoning about code easier for the programmer <em>and</em> the compiler. You can tell from a function‚Äôs type what it might do (e.g., <code>fn : A -&gt;{IO, State}</code> clearly might perform I/O and state). This is similar to how one reasons about checked exceptions in Java, but more flexible. It aids in understanding and refactoring ‚Äì the type will complain if you forgot to handle something. It also enables local reasoning: you know a pure function can‚Äôt suddenly do I/O or mutation. By contrast, OCaml‚Äôs lack of effect annotations means you must rely on documentation or naming conventions to know if a function might perform an effect. This can make larger codebases harder to reason about (similar to unchecked exceptions or global state). On the flip side, dynamic/untyped effect handling is more <em>ergonomic</em> when writing quick code: you don‚Äôt have to change type signatures or introduce polymorphism every time you add a new effect. It‚Äôs a trade-off between safety and convenience.</p><p><strong>Trade-offs and Conclusion:</strong> The handler lookup mechanisms reflect deeper design philosophies. <strong>Koka</strong> (and similar systems like <strong>Links/Effekt</strong>) chooses a compile-time, principled approach, yielding optimizable and statically verifiable code at the cost of a more complex type system. <strong>Eff</strong> and <strong>Unison</strong> aim to combine the best of both worlds: they have effect types for safety, but the runtime model is flexible and general (multi-shot continuations, etc.), which maximizes expressiveness. <strong>OCaml</strong> integrates effect handlers in a more conservative way ‚Äì dynamic lookup, no effect types ‚Äì making it easier to retrofit into an existing language and runtime, and easier for programmers who don‚Äôt want to deal with effect annotations, but giving up some static guarantees.</p><p>In terms of <em>reasoning</em>, languages with effect types allow equational reasoning and formal verification of effectful code (as seen in research, e.g., proving state effect laws‚Äã</p><p><a href="https://arxiv.org/pdf/1306.6316#:~:text=demonstrate%20their%20usefulness%2C%20we%20use,interfering%20references.%20We" rel="noopener">arxiv.org</a>‚Äã<a href="https://arxiv.org/pdf/1306.6316#:~:text=Of%20course%2C%20typing%20errors%20are,handles%20away%20lookups%20and%20updates" rel="noopener">arxiv.org</a>). They encourage thinking of effects as part of a function‚Äôs API. Dynamically-checked systems require you to reason in terms of possible runtime errors (uncaught effects) similarly to unchecked exceptions.</p><p>In summary, the choice of handler lookup and effect tracking affects how <em>predictable</em> and <em>composable</em> effectful code is. Static, lexically-resolved handlers (like in Koka) offer predictability and performance, while dynamic handler lookup (as in Eff/Unison/OCaml) offers flexibility ‚Äì especially with first-class continuations that can be manipulated in novel ways. All these languages illustrate that algebraic effects bring a level of modularity to effectful programming (you can add, remove, or change effects by swapping handlers) that is hard to replicate in a language like Python. Python might simulate one or two of these patterns, but algebraic effects provide a uniform, language-supported way to implement complex control-flow abstractions with clear semantics and (in most of these languages) strong safety guarantees‚Äã <a href="https://www.eff-lang.org/#:~:text=Algebraic%20effects%2C%20on%20which%20Eff,to%20read%20a%20global%20flag" rel="noopener">eff-lang.org</a>‚Äã<a href="https://www.eff-lang.org/#:~:text=Just%20like%20exceptions%20are%20a,prevented%20or%20grouped%20in%20transactions" rel="noopener">eff-lang.org</a>.</p><p>[1] But you can implement <a href="https://github.com/dhil/ocaml-multicont">multi-shot continuations as a library in OCaml</a>. (<a href="https://bsky.app/profile/tsmc.purely-functional.com/post/3lhv3yoijss2t">source</a>)</p>
    </section>


</article>
</div></div>
  </body>
</html>
