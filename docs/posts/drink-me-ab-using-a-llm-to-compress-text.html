<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://o565.com/llm-text-compression/">Original</a>
    <h1>Drink Me: (Ab)Using a LLM to Compress Text</h1>
    
    <div id="readability-page-1" class="page"><div id="site-main">
<article>

    <header>

        <p><span><svg width="16" height="17" viewBox="0 0 16 17" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M4.49365 4.58752C3.53115 6.03752 2.74365 7.70002 2.74365 9.25002C2.74365 10.6424 3.29678 11.9778 4.28134 12.9623C5.26591 13.9469 6.60127 14.5 7.99365 14.5C9.38604 14.5 10.7214 13.9469 11.706 12.9623C12.6905 11.9778 13.2437 10.6424 13.2437 9.25002C13.2437 6.00002 10.9937 3.50002 9.16865 1.68127L6.99365 6.25002L4.49365 4.58752Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
</svg> Featured</span>
        </p>

        


        


    </header>

    <section>
        <h3 id="introduction">Introduction</h3><p>Large language models are trained on huge datasets of text to learn the relationships and contexts of words within larger documents. These relationships are what allows the model to generate text.</p><p>Recently I&#39;ve <a href="https://www.nytimes.com/2023/12/27/business/media/new-york-times-open-ai-microsoft-lawsuit.html">read</a> concerns about LLMs being trained on copyrighted text and <a href="https://www.patronus.ai/press">reproducing</a> it. This got me thinking: Can training text be extracted from an LLM? The answer, of course, is yes, and this <a href="https://arxiv.org/abs/2311.17035">isn&#39;t</a> a <a href="https://arxiv.org/abs/2012.07805">new</a> (or open) question. This led me to wonder what it would take to extract entire books- or have an LLM reproduce text it&#39;s never directly been trained on. I figured that, for the most part, many texts contain sections that would naturally align with the language relationships the model has learned. If that&#39;s the case, then perhaps I could use the model to infer those relationships and correct its course whenever it deviates.</p><p>So that&#39;s how I got here. </p><p>To see if this would work, I decided to use technology that I am familiar with. I&#39;ll use <a href="https://github.com/ggerganov/llama.cpp">llama.cpp</a> via its <a href="https://github.com/abetlen/llama-cpp-python">python bindings</a>.</p><h3 id="how-it-works">How it Works...</h3><p>The solution I put together has the following key functions:</p><p><strong><code>load_document(filename)</code></strong>:</p><ul><li>This reads a text file and tokenizes it using the model&#39;s tokenizer. If the text is too long for the model&#39;s context window, it is split into smaller parts that fit within this window. This prevents token overflow.</li></ul><p><strong><code>generate_text(prompt, max_tokens=1)</code></strong>:</p><ul><li>This generates text, n tokens at a time, with 0.0 as the temperature and a static seed. It essentially continues the text from where the input text stopped.</li></ul><p><strong><code>compress_text(source_text)</code></strong>:</p><ul><li>This function attempts to compress the input text by generating parts of it using the LLM. If the generated text matches the start of the source text, it continuesâ€“ otherwise, it adds the character directly to the compressed string.</li><li>To record the generated text, the function notes how many tokens were generated and places that number between a delimiter.</li></ul><p><strong><code>decompress_text(compressed_text)</code></strong>:</p><ul><li>Decompresses text compressed by the <code>compress_text</code> function. It splits the text using the delimiter and reconstructs the original text by generating missing parts or directly appending the text.</li></ul><h3 id="testing">Testing</h3><p>I used two texts for test. For the first, I decided to use the first chapter of &#34;<a href="https://www.gutenberg.org/cache/epub/11/pg11.txt">Alice&#39;s Adventures in Wonderland</a>&#34; as I assumed it would be in the model&#39;s training data. As I expected, I got very good compression. </p><h4 id="compression">Compression</h4><p>Here&#39;s the meat of the compression function:</p><h5 id="code">Code</h5><!--kg-card-begin: markdown--><pre><code>    &#34;&#34;&#34;Compress text by generating and comparing segments to the source text.&#34;&#34;&#34;
    generated_text = &#34;&#34;
    compressed_string = &#34;&#34;
    gen_count = 0
    i = 0
    # let&#39;s loop until we have generated the entire source text
    while generated_text != source_text:
        # get a new token
        part = generate_text(generated_text)
        # if our generated text aligns with the source text then tally it
        if source_text.startswith(str(generated_text + part)) and len(part) &gt; 0:
            gen_count += 1
            generated_text += part
            i = len(generated_text)
            if debug:
                print(BLUE + part + RESET, end=&#34;&#34;, flush=True)
        # if not, then grab a letter from the source document 
        # hopefully we&#39;ll be back on track during the next loop
        else:
            i += 1
            if gen_count &gt; 0:
                compressed_string += f&#34;{re.escape(DELIMITER)}{gen_count}{re.escape(DELIMITER)}&#34;
                gen_count = 0
            
            generated_text += source_text[i - 1]
            compressed_string += source_text[i - 1]
            if debug:
                print(source_text[i - 1], end=&#34;&#34;,  flush=True)
</code></pre>
<!--kg-card-end: markdown--><h5 id="results">Results</h5><p>Here&#39;s the model processing the script. The text in blue matches text generated by the LLM and white is from the source text. Yes, it&#39;s slow. </p><figure><img src="https://o565.com/content/images/2024/04/compress-opt.gif" alt="" loading="lazy" width="691" height="490" srcset="https://o565.com/content/images/size/w600/2024/04/compress-opt.gif 600w, https://o565.com/content/images/2024/04/compress-opt.gif 691w"/></figure><h4 id="the-compressed-content">The &#34;Compressed&#34; content:</h4><p>Here&#39;s what the output looks like. Yes, it&#39;s in JSON format and yes it&#39;s ugly, but this is just a proof of concept, right? For the sake of clarity in this post, I picked an easy-to-read delimiter: @</p><p>This is the complete &#34;compressed&#34; text of Chapter 1.</p><!--kg-card-begin: markdown--><pre><code>[&#34;\ufeffCH@2@I.@1@Down@7@\n\n@15@\n@18@\n@13@\n@6@ \u201c@17@s@2@\n@79@ _@13@ _@72@ a\n@10@_,@106@ how@100@as@51@cup@24@ down@26@\u201d,@4@\n@17@\n@3@ underneath@11@cup@62@ fell@9@Which@23@?@4@\n@19@\n@35@ lear@2@se@12@room@2@\n@5@ _@25@ go@1@d\np@20@\n@19@ no@13@ thought@2@ nice@22@ _@2@\n@16@ walk@5@ward@12@she@3@gl@11@,@9@the@1@ word@7@ to@27@\n(and@21@\n@120@ Din@59@ here@5@ get@15@ream@19@\n@82@ tell@111@ the wind@21@ e@55@ a@50@ walked@11@\n@43@first@35@\n@104@\n@43@,@31@ would@7@ should@21@,@6@ h@43@\n@17@\n@17@\n@17@\n@8@,@11@,@21@,\u201d@2@ on@2@ large@23@ was@5@ _@1@_@21@ it@4@_@12@\nse@2@ nice@1@ hist@8@,@2@e@6@ and@9@_@34@\n@1@ th@1@t@5@ _@45@soon@11@ _@63@hot@3@,@10@*     @3@     @3@     @1@     @3@    *@10@\n@1@*@10@     @27@\n@20@right@5@ that@14@ that@9@wait@35@\n@36@fl@4@ is@36@ going@11@ for@3@ when@37@\n@13@ and@6@ cl@34@sat@7@Come@16@\nr@2@;@16@ very@2@,@24@\n@49@But@69@ very@3@ on@17@Well@14@ if@23@ can cre@11@\n@37@,@39@ generally@13@ much@28@ life&#34;]
</code></pre>
<h6 id="11994-to-986-characters">11,994 to 986 Characters</h6>
<!--kg-card-end: markdown--><p>Wow, that&#39;s a pretty big reduction. The compressed text is only about 8% of the original size. </p><p>For fun, I compressed the <a href="https://www.gutenberg.org/cache/epub/11/pg11.txt">whole file</a>. This method reduced the number of characters from 174,355 to 25,360 - the compressed text being 15% of the original.</p><h4 id="decompression">Decompression </h4><p>Compression is pointless if I can&#39;t reverse it. Let&#39;s look at the decompress function:</p><h5 id="code-1">Code</h5><!--kg-card-begin: markdown--><pre><code>    decompressed_text = &#34;&#34;
    # split the parts into sections, text and generation counts
    parts = re.split(rf&#39;({re.escape(DELIMITER)}\d+{re.escape(DELIMITER)})&#39;, compressed_text)  
    
    for part in parts:
        # if we&#39;re looking at a generation count, then generate text
        if re.match(rf&#39;{re.escape(DELIMITER)}\d+{re.escape(DELIMITER)}&#39;, part): 
            number = int(part[1:-1])   
            for count in range(number):
                part = generate_text(decompressed_text)    
                if debug:
                    print(GREEN + part + RESET, end=&#34;&#34;,  flush=True)
                decompressed_text = decompressed_text + part
        else:
            # just add the text to the decompressed string
            decompressed_text += part
            if debug:
                print(part, end=&#34;&#34;,  flush=True)
</code></pre>
<!--kg-card-end: markdown--><h5 id="results-1">Results</h5><figure><img src="https://o565.com/content/images/2024/04/decompress-opt.gif" alt="" loading="lazy" width="691" height="490" srcset="https://o565.com/content/images/size/w600/2024/04/decompress-opt.gif 600w, https://o565.com/content/images/2024/04/decompress-opt.gif 691w"/></figure><p>It works!</p><h3 id="one-more-thing">One more thing</h3><ul><li>I don&#39;t know how well this will perform across different GPUs, as I&#39;ve heard that outputs could vary. While I don&#39;t have the ability to test this, I confirmed that the results were consistent between a GPU and a CPU.</li><li>I haven&#39;t gotten around to uploading the script to Github. Once I do, I&#39;ll post it here.</li></ul><h4 id="heres-a-draft-version-of-this-post-compressed">Here&#39;s a draft version of this post, compressed:</h4><!--kg-card-begin: markdown--><pre><code>[&#34;\nWarning@1@ What f@1@ows@1@ not practical, well@1@written,@1@ finished@5@lso probably not the@1@ idea. It was fun th@1@u@1@h.@1@Int@1@duction@1@Large language@1@ are trained@1@ huge datas@3@ to learn the relationships and contexts of@1@ within larger doc@1@ments@1@ These relationships are what@1@s the@3@ text.\nRec@1@ I@2@ read concerns@1@ LL@2@ trained@1@ copyright@1@ text and repro@1@ing@1@.@1@ got@2@: Can training text be extracted@5@ The@1@, of@4@, and this@1@n@4@ (@1@ open@1@ question@1@ This led@3@ what it@1@ take@1@ extract entire@1@- or have an LL@1@ repro@1@e text it&#39;@1@ ne@1@r dire@1@tly been@3@ I fig@1@ed that, for@1@ most@2@ many texts contain sections@1@ would natur@1@y align@2@ language relationships the@4@ If that@2@ the@2@ then@1@ I@2@ the@2@ infer those relationships@1@ correct its course whenever@1@ dev@2@.@1@So th@1@t@2@ how@1@ got@1@. @1@To see@2@ would@5@ use technology th@1@t I am@2@.@1@&#39;ll use ll@3@ via its p@1@hon bind@1@.\nHow@1@ Works...\n@1@ solution I put@1@ has the@1@ key fun@2@ns@2@load@1@document(fil@1@ame@1@\n@1@ reads a@3@ token@2@ using@1@ model@2@ to@1@n@2@ If@1@ text@3@ for@2@&#39;@5@ is@2@ smaller parts th@1@t fit@1@ this@2@ This prev@1@ token over@1@ow.@13@):@2@ generates@1@, n@1@ at@3@ w@1@h 0.0 as@3@ a static@1@. It ess@1@i@1@y continues@1@ text@2@ the input text stopped@2@compress@3@sour@1@e_@1@):@3@ attempts@3@ input@1@ by generating parts@4@ LL@3@ the@1@ te@1@ mat@1@s@1@ start@2@ source@2@ it continues\u2013 o@1@rwise@2@ adds@1@ character directly to@1@ comp@1@ string@1@\nTo record@1@ generated@2@ the fun@1@ion notes how@1@ tokens@1@ gener@1@ed@1@ places that@1@ between a del@1@.\nde@10@De@2@ text comp@2@ the compress@8@ te@1@ using@3@er@1@ recon@5@ by generating missing@1@ or directly app@1@ the text.@1@Testing\nI used two texts for t@1@t. For@2@,@1@ decided@2@ the@4@Al@8@\&#34;@1@ I ass@1@med@3@ in@7@ As I@2@ I got very good compression. @1@Com@1@\nHere&#39;@1@ the meat@2@ compression function@2@Code@1@\nResults@1@Here&#39;@1@ the model processing@1@ script. The text in blue mat@1@s text gener@1@ed@2@ LL@1@ and white is from@1@ source@2@ Yes@4@ slow. @2@The \&#34;Com@2@ content:@1@Here@2@ wh@1@t@1@ output@2@. Yes@4@ in JSON@1@ and@1@ it@2@ u@1@y,@1@ this@1@ just@4@, right@1@ For@3@ clarity in@4@ pic@1@d an easy@4@ del@1@: @\nThis@3@lete \&#34;@4@ of Chapter@2@.@2@De@2@ @1@Com@1@ion is point@1@ if I@3@ reverse@2@ Let@2@ look@1@ the@1@p@1@s@8@\nIt@2@\nNot@2@I don@2@ know@3@ will perform ac@1@s@1@ GP@1@, as@1@&#39;@1@ heard@1@ outputs cou@1@d@2@ While I don@3@ the ability@3@,@1@ confirmed@1@ the results@2@ bet@1@en a GPU@5@I haven@2@ gotten arou@1@d@1@ u@1@oad@1@ the sc@1@t@2@hub. Once I@5@ post it@3@Here&#39;@1@ this post, comp&#34;]
</code></pre>
<h6 id="3436-to-2691-characters">3,436 to 2,691 Characters</h6>
<!--kg-card-end: markdown--><p>As expected, the method performs better better on data that the model has been trained on, but there&#39;s still some reduction in size.</p><h4 id="thoughts">Thoughts</h4><ul><li>The model is huge</li><li>Would it practical to train a model for the purpose of compression?</li><li>Could this method be used to identify any data that was used to train a model?</li><li>Do different models yield better results?</li><li>Can this be extended to other data types, like images?</li></ul>
    </section>


</article>
</div></div>
  </body>
</html>
