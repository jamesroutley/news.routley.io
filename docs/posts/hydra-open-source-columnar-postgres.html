<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.hydra.so/blog-posts/hydra-1-generally-available">Original</a>
    <h1>Show HN: Hydra - Open-Source Columnar Postgres</h1>
    
    <div id="readability-page-1" class="page"><div><section><div><div><div><div>

<p>
    <iframe src="https://www.youtube.com/embed/1yzxgb0Oyrw?si=Sz3c0KzfqEbHHZnm" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</p></div><p>‚Äç</p><p>‚Äç<strong>Hydra is an open-source extension that adds columnar tables to Postgres for efficient analytical reporting. With Hydra, you can analyze billions of rows instantly without changing code.</strong></p><p>Hydra augments Postgres‚Äô existing row-based tables, enabling developers to tailor Postgres to their application‚Äôs custom transactional and analytical needs. Hydra combines a columnar format, vectorized execution, and parallelism to supercharge modern applications that aren‚Äôt wholly transactional or fully analytical, such as real-time dashboards, IOT, geospatial &amp; logistics apps, and time-series workloads.</p><h3>Tailor Postgres to your modern, real-time apps</h3><h5>üë∏ <strong>Columnar tables = OLAP</strong></h5><p>OLAP (Online Analytical Processing) is designed to support analytical workloads, such as data mining, reporting, and business intelligence. OLAP systems typically use a multidimensional data model, which allows users to analyze data from multiple perspectives and at different levels of detail. OLAP systems are often used in decision support applications, where users need to quickly and easily analyze large amounts of data.</p><h5>ü§¥ <strong>Row tables (heap) = OLTP</strong></h5><p>OLTP (Online Transactional Processing) is optimized for a large number of small, frequent transactions that insert, update, delete, and retrieve data from a database. This type of system manages real-time data processing for record lookups, fast writes, high concurrency, and useful for order entry, sales, financial applications, and more.</p><h5>üë∏ü§ùü§¥ <strong>Row + Columnar tables = HTAP</strong></h5><p>HTAP (Hybrid Transactional Analytical Processing) combines the strengths of OLTP and OLAP into a single system. When transactions occur, they are instantly accessible for analytics and machine learning. HTAP is commonly used when reporting latency must be low, such as financial analysis, IOT alerting, fraud detection, supply chain management, customer-facing dashboards, and applications with real-time decision making.</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/640edc15766e12e0d8f226dc/6508c75d0cea27729aea81ca_OLTP%2C%20HTAP%2C%20OLAP%20diagram%20(3).png" loading="lazy" alt="Graph showing OLTP. HTAP and OLAP"/></p></figure><h3>Columnar tables 101</h3><p>Columnar tables are organized transversely from row tables. For example, take the following table stored in row format:</p><div>

<table>
    <tbody><tr>
        <td>Joe</td>
        <td>156789</td>
        <td>Blue</td>
        <td>Platinum</td>
    </tr>
    <tr>
        <td>Felisha</td>
        <td>119988</td>
        <td>Red</td>
        <td>Gold</td>
    </tr>
    <tr>
        <td>Sam</td>
        <td>232667</td>
        <td>Green</td>
        <td>Silver</td>
    </tr>
</tbody></table></div><p> 
    The order of the data would be: 
    <span>
        | Joe | 156789 | Blue | Platinum | Felisha | 119988 | Red | Gold | Sam | 232667 | Green | Silver |
    </span>
</p><p>The same data stored in columnar can be visualized as follows:</p><div>

<table>
    <tbody><tr>
        <td>Joe</td>
        <td>Felisha</td>
        <td>Sam</td>
    </tr>
    <tr>
        <td>156789</td>
        <td>119988</td>
        <td>232667</td>
    </tr>
    <tr>
        <td>Blue</td>
        <td>Red</td>
        <td>Green</td>
    </tr>
    <tr>
        <td>Platinum</td>
        <td>Gold</td>
        <td>Silver</td>
    </tr>
</tbody></table></div><p> 
As columnar, the order of the data would be:
    <span>
   | Joe | Felisha | Sam | 156789 | 119988 | 232667 | Blue | Red | Green | Platinum | Gold | Silver |
   </span>
</p><p>Learn more in <a href="https://docs.hydra.so/organize/data-modeling/row-vs-column-tables">our docs</a>.</p><h3>Using Hydra</h3><p>Hydra makes use of <span>tableam</span> (table access method API), which was added in Postgres 12 released in 2019. Using <span>tableam</span> engineers can flexibly define when a table is row (heap) or column-oriented in their Postgres database.</p><div>

<p>postgres=# <span>CREATE TABLE</span> heap_table (id INT) USING <span>heap</span>;
<span>CREATE TABLE</span>
postgres=# <span>CREATE TABLE</span> columnar_table (id INT) USING <span>columnar</span>;
<span>CREATE TABLE</span>
postgres=# \dt+
List of <span>relations</span>
<span>Schema</span>    | Name          | <span>Type</span>   | Owner    | Persistence | <span>Access method</span> | Size  | Description
-------------+--------------+-------+---------+-------------+-------------------+-------+-------------
<span>public</span>     | columnar_table | <span>table</span>   | postgres | permanent    | <span>columnar</span>         | 16 kB |              
<span>public</span>     | heap_table     | <span>table</span>   | postgres | permanent    | <span>heap</span>            | 0 bytes |
(2 <span>rows</span>)
</p></div><p>It‚Äôs super simple to swap table format:</p><div>

<p><span>CREATE TABLE</span> my_table (i INT8) <span>USING</span> heap;

<span>SELECT</span> columnar.alter_table_set_access_method(<span>&#39;my_table&#39;</span>, <span>&#39;columnar&#39;</span>);

<span>SELECT</span> columnar.alter_table_set_access_method(<span>&#39;my_table&#39;</span>, <span>&#39;heap&#39;</span>);
</p></div><div>

<div>
    <p>üîî</p> <!-- This is an emoji, you can replace with any other or an SVG icon -->
    <p>
    Please note: When creating tables in Hydra the table access method has been set to <span>USING columnar</span> by default. For example, when data is first loaded into a Hydra database, all tables are formatted as column-oriented.
</p> </div></div><h3>Benchmarks</h3><p><strong>Hydra columnar tables enable the fastest Postgres aggregates</strong> <strong>on earth.</strong></p><p><a href="https://tinyurl.com/clickbench"><strong>Review Clickbench</strong></a> for comprehensive results and the list of 42 queries tested.</p><p>This benchmark represents typical workload in the following areas: clickstream and traffic analysis, web analytics, machine-generated data, structured logs, and events data.</p><p>Benchmarks were run on a c6a.4xlarge (16 vCPU, 32 GB RAM) with 500 GB of GP2 storage.</p><p><strong>For our continuous benchmark results, see </strong><a href="https://github.com/hydradatabase/hydra/blob/main/BENCHMARKS.md"><strong>BENCHMARKS</strong></a><strong>.</strong></p><h3>Release Notes</h3><p>Aggregate queries are over <strong>60% faster</strong> compared to Hydra 1.0 beta release. Spatial indexes and pg_hint_plan are now enabled for performance optimization.</p><p>Please refer to Hydra 1.0 <a href="https://www.notion.so/0332c439427b4e7e92ec2a2b7f40a81b?pvs=21">beta release notes</a> here.</p><h4>Aggregate vectorization</h4><p>We added vectorization of integer and date data that is stored in a columnar table. Vectorization happens automatically whenever applicable. The following aggregate functions are vectorized:</p><ul role="list"><li>MIN</li><li>MAX</li><li>COUNT</li><li>SUM</li><li>AVG</li></ul><p>‚Äç</p><p>Vectorization can result in aggregate queries being over <a href="https://bencher.dev/perf/hydra-postgres?benchmarks_page=2&amp;testbeds_page=1&amp;branches_page=1&amp;reports_page=1&amp;tab=benchmarks&amp;branches=e6bcbe0c-210d-4ab1-8fe4-5d9498800980&amp;testbeds=1d3283b3-3e52-4dd0-a018-fb90c9361a2e&amp;metric_kind=query-time&amp;reports_per_page=4&amp;branches_per_page=8&amp;testbeds_per_page=8&amp;benchmarks_per_page=8&amp;clear=true&amp;benchmarks=e5249f00-a108-4164-8c36-d39fed2bdfd2%2Cd488714b-81cd-4183-9856-334980ef16f3%2Cce4c8327-46d1-4bb3-95ca-be810fd818ee"><strong>60% faster</strong></a>. If vectorized aggregate is not found or execution plan is not suitable, Hydra falls back to standard Postgres execution.</p><p>
    Hydra uses automatic vectorization by the compiler for vectorization. We have enabled <span>-O3</span> optimizations in our compilation process to maximize this effect.
</p><p>This optimization is for Postgres 14+ only.</p><h4>Spatial index types and pg_hint_plan</h4><p>
    After testing, we have enabled gin, gist, spgist, and rum indexes on columnar tables, enabling indexes for geospatial queries. We have also added <span>pg_hint_plan</span> to enable you to experiment with the query plan to maximize performance. Recommendations for indexing and using pg_hint_plan are available in our documentation.
</p><h3>Developer Changelog</h3><p><a href="https://github.com/hydradatabase/hydra/blob/main/CHANGELOG.md"><strong>View or full CHANGELOG¬†on Github.</strong></a></p><div>

<div>
    <p>Limitations</p>
    <p>Hydra Columnar currently does not support the following Postgres features. These features are available on 
    <span>heap</span> tables for transactional workloads.</p>

    <ul>
        <li>Upsert (<a href="https://www.postgresql.org/docs/12/sql-insert.html#SQL-ON-CONFLICT">ON CONFLICT</a> statements, except <span>DO NOTHING</span> actions with no target specified)
            <ul>
                <li>We are <a href="https://github.com/hydradatabase/hydra/issues/49">targeting upsert for version 1.1</a>.</li>
            </ul>
        </li>
        <li>Tuple locks (<span>SELECT ... FOR SHARE, SELECT ... FOR UPDATE</span>)</li>
        <li><span>SERIALIZABLE</span> isolation level</li>
        <li>Foreign keys</li>
        <li>Logical decoding</li>
        <li><span>AFTER ... FOR EACH ROW</span> triggers</li>
        <li><span>UNLOGGED</span> columnar tables</li>
    </ul>
</div></div><p>‚Äç</p></div><div id="w-node-e8906123-60de-38d8-3d94-5057c616fcd4-242aa040"><div><div><p>Thank you! Your submission has been received!</p></div><div><p>Oops! Something went wrong while submitting the form.</p></div></div></div></div></div></section><section></section></div></div>
  </body>
</html>
