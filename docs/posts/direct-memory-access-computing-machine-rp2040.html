<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://people.ece.cornell.edu/land/courses/ece4760/RP2040/C_SDK_DMA_machine/DMA_machine_rp2040.html">Original</a>
    <h1>Direct Memory Access computing machine RP2040</h1>
    
    <div id="readability-page-1" class="page">
<p><SPAN size="+2">Cornell University ECE4760 </SPAN></p>
<p><b>DMA on RP2040</b></p>
<p>DMA uses memory controllers separate from the CPU to accelerate data movment between memory locations, or between peripherials and memory. The RP2040 has 12 DMA channels which can stream an agregate of over 100 megabytes/sec without affecting CPU performance, in many cases. There are a huge number of options available to set up a DMA transfer. You can think of a DMA channel controller as a separate, programmable, processor with the main job of moving data.  Memory on the rp2040 is arranged as a bus matrix with  separate memory bus control masters for each ARM core and for the DMA system, and several memory bus targets accessed by the masters. Each bus target can be accessed on each machine cycle.</p>
<p>Here we  use the DMA subsystem to produce a complete computing system, independent of the main ARM cpus. The DMA  machine makes use of memory-copy ability, transport_triggered operations, and self-modifying code. The <em>code</em> consists of a sequence of DMA block descriptors stored in an array. The implemented operations are <a href="https://en.wikipedia.org/wiki/Counter_machine">Turing Complete</a>, and run at about the speed of an Arduino. About 8 million DMA blocks/second can be fetched/executed. There is a history of using only memory-moves to build a general cpu. In 2013 Stephen Dolan published   <span><a href="https://people.ece.cornell.edu/land/courses/ece4760/RP2040/C_SDK_DMA_machine/mov.pdf">x86 mov</a></span><a href="https://people.ece.cornell.edu/land/courses/ece4760/RP2040/C_SDK_DMA_machine/mov.pdf"> is Turing-Complete</a> describing an example of a one-opcode machine. The paper <a href="https://www.usenix.org/system/files/conference/woot15/woot15-paper-rushanan.pdf">Run-DMA</a> by <span role="presentation" dir="ltr">Michael Rushanan</span> <span role="presentation" dir="ltr">and</span> <span role="presentation" dir="ltr">Stephen Checkoway</span> shows how to do this with one version (Raspbery Pi 2) of ARM DMA. The DMA system on the RP2040 has more transport-triggered functions and is a little easier to build. Joseph Primmer and I built a DMA processor using the Microchip PIC32 DMA system. Addition and branching had to be based on table-lookup. See <a href="https://people.ece.cornell.edu/land/courses/ece4760/PIC32/index_DMA_weird_machine.html">DMA Weird machine</a>.</p>
<p>The DMA machine is a fetch-execute cpu where the fetch function is done by one DMA channel, which  loads DMA control block images from RAM into another (execute) DMA channel. The &#39;program&#39; which is  loaded consists of a carefully crafted series of DMA control blocks which together  act as a general purpose computer. By using DMA1 blocks to  modify following DMA1 control block images in the array, just before they are transfered to the hardware DMA1 control registers, we can perform addition, increments, conditional jumps, and/or/not logic operations, and any other operations required. The design is made easier by several transport-  triggered actions in the DMA subsystem. These include an adder in the &#39;channel sniffer&#39;  and atomic SET/CLEAR/XOR write functions on all SFRs. The basic fetch/execute machine uses the channel DMA0 read address as a program counter. Every fetch that occurs leaves the read address pointing to the next block location. DMA0 reads the next block from the RAM array and copies it to the DMA1 channel hardware control registers, then chains to the newly loaded DMA1 channel. The DMA1 channel performs whatever daata move is specified, then chains to DMA2. DMA2 resets the DMA0 write_address to point to DMA1 control registers. Program branching is implemented by using DMA1 to load a new DMA0 read address to the DMA0 control registers. Writing a program of DMA blocks is very much like programming in some strange assembly language for a machine with one accumulator register and only memory-to-accumulator operations.</p>
<p>The following diagram is an attempt to summarize all this madness. </p>
<p><img src="https://people.ece.cornell.edu/land/courses/ece4760/RP2040/C_SDK_DMA_machine/DMAcpu2.png" width="903" height="510" alt=""/></p>
<p>In addition to a straight copy operation, there are a few   <a href="https://en.wikipedia.org/wiki/Transport_triggered_architecture">transport-triggered operations</a> in the RP2040 DMA system which happen as a side effect of reading or writing  a specific address:</p>
  <ul>
    <li>Writing to certain shadow registers associated with each <em>special function register</em> (SFR) clears, sets, or XORs bits in the SFR. </li>
    <li>The DMA sniffer system itself supports computing a CRC32 on-the-fly while a channel is transfering data. </li>
    <li>Data being copied out of the sniffer data register can be logically inverted or bit-reversed.
      <br/>
    </li>
    <li>Any DMA channel transfer can be byte-swapped. </li>
    <li>Of course, writing certain SFRs may have system functions. </li>
  </ul>
<p>The programming process has to map these unusual primitive operations into familiar mathematical and logical operations, and some form of conditional branch or jump. The sniffer add operation and the bitwise SFR operations means we can directly implement these functions. <em></em></p>
<p>For <em>add </em> a sequence of DMA blocks could be:</p>
  <ol>
    <li>move one operand to the sniffer_data register</li>
    <li>move the other operand to the bit_bucket (discard) with sniffer enabled (this does the add)</li>
    <li>move sniffer_data register to the result address.</li>
  </ol>
  <p>For <em>shift-left</em> we just do an ADD of a variable to itself (multiply by two).</p>
  <p>For a <em>logic</em> operation (OR, AND, XOR, etc):</p>
  <ol>
    <li>move one operand to the sniffer_data register</li>
    <li>move the other operand to the sniffer SET, CLR, or XOR write address (e.g. DMA_SNIFF_DATA_CLR)</li>
    <li>move sniffer_data register to the result address.</li>
  </ol>
  <p>For <em>subtract</em> of (A-B) we have to explicitly compute the 2&#39;s complement negative of B:</p>
  <ol>
    <li>move B to the sniffer_data register</li>
    <li>move 0xFFFFFFFF to the XOR write address ( DMA_SNIFF_DATA_XOR) to invert bits</li>
    <li>move unity   to the bit_bucket (discard) with sniffer enabled (this  adds 1 to from the 2&#39;s complement)</li>
    <li>move the A operand to the bit_bucket (discard) with sniffer enabled (this does an add)</li>
    <li>move sniffer_data register to the result address.  </li>
  </ol>
  <p>For a <em>shift-right</em> the process is much more annoying. A right-shift is a bit-reversed left-shift
  :</p>
  <ol>
    <li>move the variable to the sniffer_data register</li>
    <li>move the sniff_rev_mask to the DMA_SNIFF_CTRL_SET. </li>
    <li>move the sniff_data register to a temp_register (with bits reverse-order)</li>
    <li>move the temp_register back to sniff_data</li>
    <li>move the temp_register to the bit_bucket (discard) with sniffer enabled (doubling it; left-shift)</li>
    <li>move the sniff_data register to the result address (with bits reverse-order, restoring the correct order)</li>
    <li>move the sniff_rev_mask to the DMA_SNIFF_CTRL_CLR. </li>
  </ol>
<p>An <em>unconditional jump</em> is easy. </p>
<p>The hardest operation to get right is a <em>conditional jump</em>. Every jump condition (e.g. jump on negative number) must be converted into an absolute address and all data possibilities (e.g. positive, zero, negative) <em>MUST JUM</em>P! This is because the last step of setting up the conditional jump is to push data to the DMA0 hardware. This weird constraint means that jump conditions need to be converted to small integers representing block addresses. I will outline the <em>jump-on-negative-number-in-variable</em> scheme.</p>
<ol>
  <li>move variable to be tested to the sniffer_data register with <em>DMA byte-swap</em> turned on.</li>
  <li>move 0xFFFFFFeF to the CLR write address ( DMA_SNIFF_DATA_CLR) to isolate bit 4.</li>
  <li>move the desired address ADDR of a jump for positive input to the bit_bucket (discard) with sniffer enabled.</li>
  <li>move the sniff_data register to the DMA0 hadware read address control word to force the actual jump to one of the two locations.</li>
</ol>
<hr/>
  <p><em>The programs below are in blog-style reverse time order, newest stuff at the top.</em></p>
  <ol>
    <li>Test program to validate basic execution model and test GPIO output, add, OR operation, conditional branch, and unconditional jump.(23dec2022)</li>
    <li>Direct Digital Synthesis is used to test timer-regulated execution speed, SPI output, and combining the DMA channel byte-swap function and CLR-masking to isolate the top byte of the 32-bit accumulator  to use as an index into a sine-table. Insertion of the pointer to the sine table requires self-modifying code. Performance is good enough to use for audio synthesis rates. (28dec2022)</li>
    <li>Updated test program which implements add, subtract, shift-left, shift-right, and a couple of different  ways of generating a conditional jump. (2jan2023)</li>
    <li>Refactored and generalized version. DMA channel dependencies are cleaned up for compatability with other software (e.g. VGA generation). The fetch/execute architecture is separated from the DMA program definition. (3jan2023)</li>
    <li>Use the DMAcpu machine to read the ROSC random-bit, shift it into the sniffer, then use the result to compute a CRC32 value using the sniffer hardware, and then output that to an SPI channel to make audio white noise. (7jan2023)</li>
    <li>The white noise generator was low-passed filtered using a 1-pole IIR, mostly just to see if the DMAcpu could do the arithmetic. It took a 38 step program about 4 uSec to compute a low-passed sample. (11jan2023)</li>
    <li>Merging the DMAcpu with VGA generation. Since both use the DMA system heavily, a test was necessary to see if either one broke when merged. Video also gave a way to visually test the random number generation quality. (11jan2023)</li>
    <li>Refining the DMAcpu random number generator and simulating <a href="https://en.wikipedia.org/wiki/Diffusion-limited_aggregation">Diffusion-Limited Aggregation</a> (<strong>DLA</strong>). While testing the DLA, I noticed that there is some serial correlation in the DMAcpu random number generation. This code eliminates the correlation. (13jan2023)<br/>
    </li>
  </ol>
  <hr/>
  <p><strong>DMAcpu and DLA, with refined random number generation</strong>. (13jan2023)</p>
  <p><a href="https://people.ece.cornell.edu/land/courses/ece4760/RP2040/C_SDK_DMAcpu_VGA256/Decorrelated_RNG/vga256_DMA_diffusion_DLA.c"><strong>DLA code</strong></a><strong>, <a href="https://people.ece.cornell.edu/land/courses/ece4760/RP2040/C_SDK_DMAcpu_VGA256/Decorrelated_RNG/Updated%20rand.zip">ZIP</a></strong> ( also <a href="https://people.ece.cornell.edu/land/courses/ece4760/RP2040/C_SDK_DMAcpu_VGA256/Decorrelated_RNG/vga256_DMA_serail_corr.c">corellation test code</a>, <a href="https://people.ece.cornell.edu/land/courses/ece4760/RP2040/C_SDK_DMAcpu_VGA256/Decorrelated_RNG/vga256_DMA_noise.c">random distributions code</a>)</p>
  <p><strong><em>DISCLAIMER! </em></strong><em>The ROSC is not shown by the manufacturer or by me to have any reliable level of random generation. Further, of the three rp2040&#39;s I have tested, each gives a somewhat different oscillator speed, and different distributions of bits. Do not use this for any critical project without doing your own tests!</em></p>
  <hr/>
  <p><strong>DMAcpu and 256 color VGA. -- Distribution testing.</strong> (11jan2023)</p>
  <p><strong><em>DISCLAIMER! </em></strong><em>The ROSC is not shown by the manufacturer or by me to have any reliable level of random generation. Further, of the three rp2040&#39;s I have tested, each gives a somewhat different oscillator speed, and different distributions of bits. Do not use this for any critical project without doing your own tests!</em></p>
  <p><a href="https://people.ece.cornell.edu/land/courses/ece4760/RP2040/C_SDK_DMAcpu_VGA256/vga256_DMA_noise.c"><strong>Code</strong></a><strong>, <a href="https://people.ece.cornell.edu/land/courses/ece4760/RP2040/C_SDK_DMAcpu_VGA256/Web_%20DMAcpu%20+%20vga%20normal%20and%20binomial.zip">ZIP</a></strong></p>
  <hr/>
  <p><strong>Filtering white noise using DMAcpu</strong>.(11jan2023)</p>
  <p><a href="https://people.ece.cornell.edu/land/courses/ece4760/RP2040/C_SDK_DMA_machine/white_noise_filter/DMA_machine_filtered_noise.c"><strong>Code</strong></a><strong>, <a href="https://people.ece.cornell.edu/land/courses/ece4760/RP2040/C_SDK_DMA_machine/white_noise_filter/filtered%20noise%20for%20web.zip">ZIP</a></strong></p>
  <hr/>
  <p><strong>Generating white noise from the DMAcpu</strong>. (7jan2023)</p>
<p>The code shows the simplifed block syntax. </p>
  <p><strong><a href="https://people.ece.cornell.edu/land/courses/ece4760/RP2040/C_SDK_DMA_machine/white_noise/DMA_machine_white_noise.c">Code</a>, <a href="https://people.ece.cornell.edu/land/courses/ece4760/RP2040/C_SDK_DMA_machine/white_noise/white%20noise%20dma%20machine%20for%20web.zip">ZIP</a></strong></p>
  <hr/>
  <p><strong>Improved organization of the test program</strong> (3jan2023)</p>
  <p><a href="https://people.ece.cornell.edu/land/courses/ece4760/RP2040/C_SDK_DMA_machine/refactored/DMA_machine_refactored.c"><strong>Code</strong></a><strong>, <a href="https://people.ece.cornell.edu/land/courses/ece4760/RP2040/C_SDK_DMA_machine/refactored/refactored_improved_test.zip">ZIP</a></strong></p>
  <hr/>
  <p><strong>More operations and better conditional jumps</strong> (2jan2023)</p>
  <p><a href="https://people.ece.cornell.edu/land/courses/ece4760/RP2040/C_SDK_DMA_machine/Test3/DMA_machine_test3.c"><strong>Test program</strong></a><strong>, <a href="https://people.ece.cornell.edu/land/courses/ece4760/RP2040/C_SDK_DMA_machine/Test3/test3_to_web.zip">project ZIP</a></strong></p>
  <hr/>
  <p><strong>An application: <a href="https://vanhunteradams.com/DDS/DDS.html">Direct Digital Synthesis</a></strong> (12/28/2022)</p>
  <ol>
    <li>dds_accum += dds_inc (32 bits) where dds_accum is the DDS phase accumulator </li>
    <li>The high byte of dds_accum becomes the index into sine table: </li>
    <li>add byte-count to the base address of the sine_table to form a pointer to the next entry</li>
    <li>Shove the pointer just computed into the NEXT BLOCK read address, so it can copy the table value to the SPI channel</li>
    <li>Do a 2-byte transfer from sine table to SPI_data register. </li>
    <li>Stall waiting for pacing timer, then jump back to step 1<br/>
    </li>
  </ol>
  <p>The DMA-machine program:</p>
  <ol>
    <li><strong>Send a timing  pulse to GPIO2</strong>. The length of the pulse will be the execution time of the loop.
      </li>
    <li><strong>ADD increment to the accumulator</strong>. This is the phasor used to look up a sine value</li>
    <li><strong>Form pointer to next sine-table entry from the accumulator</strong></li>
    <li><strong>Move the just-formed sine table pointer into the <em>NEXT BLOCK read address</em></strong></li>
    <li><strong>Move sine table entry to SPI connected to DAC-- spi0_hw-&gt;dr</strong></li>
    <li>Clear the timing GPIO pin</li>
    <li>Jump back to the beginning, but wait for the DMA pacing timer.</li>
  </ol>
  <p><span><a href="https://people.ece.cornell.edu/land/courses/ece4760/RP2040/C_SDK_DMA_machine/DDS/DMA_machine_clocked_DDS.c"><strong>DDS program</strong></a><strong>, <a href="https://people.ece.cornell.edu/land/courses/ece4760/RP2040/C_SDK_DMA_machine/DDS/DMA_DDS_for_web.zip">ZIP</a></strong></span><br/>
  </p>
  <hr/>
  <p><strong>First DMA test program.</strong> (12/23/2022)</p>
  <p>The DMA-machine program:</p>
  <ol>
    <li><strong>Sends a two trigger pulses to GPIO2</strong>, for an oscilloscope, and to time the machine.</li>
    <li><strong>Adds two 32-bit variables</strong> and store the result back to a variable.</li>
    <li><strong>Computes the OR of two 32-bit variables</strong> and stores the result</li>
    <li><strong>Multiply a variable by a constant</strong>.</li>
    <li><strong>Computes a conditional skip</strong> based on user input from a thread.</li>
    <li>The skip targets are in steps of 16 bytes/DMA block stored in the array. </li>
</ol>
  <p><a href="https://people.ece.cornell.edu/land/courses/ece4760/RP2040/C_SDK_DMA_machine/Test1/DMA_machine.c"><strong>Test code</strong></a><strong>, <a href="https://people.ece.cornell.edu/land/courses/ece4760/RP2040/C_SDK_DMA_machine/Test1/DMA_test_program_for_web.zip">ZIP</a></strong></p>
  <hr/>
  
  
  <hr/>
  <p><strong>Not current below this line!</strong></p>
  <p>The DMA <strong><a href="https://people.ece.cornell.edu/land/courses/ece4760/RP2040/C_SDK_DMA_machine/DMA_weird_machines/dma_fetch_execute_min_block_mod_branch.c">test program</a></strong> performs several operations using only DMA-logic. the DMA machine is completely asynchronous and independent of MAIN, once started. MAIN sets up the DMA machine program, defines  tables for the machine, then prints the results of an ADD and NOR operation on the serial console. No other microcontroller resources are needed (except memory, of course) to make the machine run. The execution speed is about 200,000 blocks/sec.</p>
  <ol>
    <li><strong>Sends a trigger pulse to PortA</strong>, for an oscilloscope</li>
    <li><strong>Increments a variable</strong> to be used in the arithmetic below</li>
    <li><strong>Adds two 8-bit variables</strong> and stores the result (<a href="https://people.ece.cornell.edu/land/courses/ece4760/RP2040/C_SDK_DMA_machine/DMA_weird_machines/putty.PNG">terminal image</a> showing sum, modulo 256, and result of NOR operation below)</li>
    <li><strong>Computes the NOR of the two 8-bit variables</strong> and stores the result</li>
    <li><strong>Sets a print strobe</strong>, to be cleared by MAIN when the variables are printed.</li>
    <li><strong>Computes a conditional branch</strong> to see if the print strobe is cleared, and loop until it is cleared.</li>
    <li><strong>Increments a variable, modulo 3</strong>, to choose one of three output wavefroms to send to PortB</li>
    <li><strong>Computes a conditional branch</strong> to one of three waveform generators based on the mod 3 variable:</li>
    <li><strong>Unconditional jump back</strong> to the beginning of the program (item 1 on this list)</li>
  </ol>
  <p><strong>Fetch/execute machine details:</strong></p>
  <ul>
    <li>Output to a port:</li>
    <li>Increment a variable:</li>
    <li>Logic operations:</li>
    <li>Add two variables:</li>
    <li>Conditional jump:</li>
    <li>Unconditional jump:</li>
  </ul>
  <p><strong>Direct Digital Synthesis -- A possible practical use for the DMA machine (and optimizing execution)</strong></p>
  <p><strong>Pseudorandom or random sequence generation</strong></p>
  <hr/>
<p><strong>Older versions</strong>:</p>
  <p><strong>Time synced operation</strong>:</p>
  <p><strong>Optimizing test code execution speed</strong></p>
  <p><strong>A different (and probably inferior) way to run the Fetch/Execute cycle</strong></p>
  <hr/>
<p><SPAN size="-1">Copyright Cornell University </SPAN>
  <!-- #BeginDate format:Am1 -->January 13, 2023<!-- #EndDate -->
</p>



</div>
  </body>
</html>
