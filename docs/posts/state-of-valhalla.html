<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://openjdk.java.net/projects/valhalla/design-notes/state-of-valhalla/01-background">Original</a>
    <h1>State of Valhalla</h1>
    
    <div id="readability-page-1" class="page"><article>
<header>

<p>Part 1: The Road to Valhalla</p>

<p>December 2021</p></header>
<blockquote>
<p><em>This is the first of three documents describing the current State of Valhalla. The second is <a href="https://scattered-thoughts.net/writing/coding/02-object-model">The Language Model</a>; the third is <a href="https://scattered-thoughts.net/writing/coding/03-vm-model">The JVM Model</a>.</em></p>
</blockquote><section id="background">
<h2><a href="#background">Background</a></h2>
<p><a href="https://openjdk.java.net/projects/valhalla"><em>Project Valhalla</em></a> got its start in 2014, with the goal of bringing more flexible flattened data types to JVM-based languages, in order to restore alignment between the programming model and the performance characteristics of modern hardware. (In some ways, it got started much earlier; the designers of Java wanted to include value types in the initial version of the language.)</p>
<p>Valhalla anticipates adding three core features to the platform: <em>value objects</em>, <em>primitive classes</em>, and <em>specialized generics</em>. In the initial phase of the project, we focused primarily on understanding how the language and JVM would have to evolve to support these features, and what the migration compatibility implications for user code would be.</p>
<p>While it is possible to release these features incrementally, it is necessary to have an end-to-end picture of how they will all work together before committing to an implementation. We present here a path to enhancing the Java language and virtual machine with value classes and primitive classes, migrating the existing primitive types and value-based classes to make use of these features, and allowing primitive types to interoperate cleanly with generics. This set of documents summarizes that path, to be delivered in stages. The first three of these are described in <a href="https://openjdk.java.net/jeps/8277163">a draft JEP</a>, <a href="https://openjdk.java.net/jeps/401">JEP 401</a>, and <a href="https://openjdk.java.net/jeps/402">JEP 402</a>. (If you want to compare with where we started, see our <a href="https://cr.openjdk.java.net/~jrose/values/values-0.html">founding document</a>.)</p>
<p>However, Project Valhalla is not just about the features it will deliver, or about improving performance; it has the more ambitious agenda to <em>heal the rift</em> between primitives and objects.</p>
<section id="the-costs-of-indirection">
<h3><a href="#the-costs-of-indirection">The costs of indirection</a></h3>
<p>The JVM type system includes eight primitive types (<code>int</code>, <code>long</code>, etc.), objects (heterogeneous aggregates with identity), and arrays (homogeneous aggregates with identity). This set of building blocks is flexible — you can model any data structure you need to. Data that does not fit neatly into the available primitive types (such as complex numbers, 3D points, tuples, decimal values, strings, etc.), can be easily modeled with objects. However, objects are allocated in the heap (unless the VM can prove they are sufficiently narrowly scoped and unaliased), require an object header (generally two machine words), and must be referred to via a memory indirection. For example, an array of XY point objects has the following memory layout:</p>
<figure><img src="https://scattered-thoughts.net/writing/coding/xy-points.png" alt="Layout of XY points"/></figure>
<p>When the Java Virtual Machine was being designed in the early 1990s, the cost of a memory fetch was comparable in magnitude to computational operations such as addition. With the multi-level memory caches and instruction-level parallelism of today’s CPUs, a single cache miss may cost as much as 1000 arithmetic issue slots — a huge increase in relative cost. As a result, the pointer-rich layouts favored by the JVM, which involves many indirections between small islands of data, is no longer an ideal match for today’s hardware. We aim to enable data layouts better suited to the performance model of today’s hardware by providing Java developers with an easier path to <em>flat</em> (cache-efficient) and <em>dense</em> (memory-efficient) data layouts without compromising abstraction or type safety.</p>
<p>What we would like is to have the option to get a layout more like this:</p>
<figure><img src="https://scattered-thoughts.net/writing/coding/flattened-points.png" alt="Flattened layout of XY points"/></figure>
<p>This layout is both flatter (no indirections) and denser (no headers) than the previous version. Project Valhalla offers us a natural way to get to this layout, without having to obsessively focus on low-level details, by separating out, and giving users control over, the semantic concerns than necessitate the first layout.</p>
<p>Flattening is not only about layout in the heap; we can also flatten the <em>calling convention</em>, which is how the JVM passes values from one method to another (on the stack, or in registers). In the absence of heroic JVM optimizations, when a method passes a <code>Point</code> to another today, it passes a pointer and the callee dereferences the pointer to access the object’s state. We would like a flatter calling convention, where a <code>Point</code> can be passed by passing the <code>x</code> and <code>y</code> components by value. In some cases, calling convention flattening can yield even more significant performance improvements than heap flattening.</p>
</section>
<section id="the-costs-of-a-split-type-system">
<h3><a href="#the-costs-of-a-split-type-system">The costs of a split type system</a></h3>
<p>As an object-oriented language, the separation between primitives and objects embodies a significant compromise: an OO language would like to start from the premise of “everything is an object”. But, an <code>int</code> is not an object; it is something special and magical (and so are its arrays), and this non-uniformity ripples throughout the language, libraries, and runtime.</p>
<p>The compromise made in 1995 was that <em>everything the user can define</em> is an object, but there are eight additional built-in types that are not objects, and we cannot define new ones. It was surely a forced move at the time; it was not yet known how to get away with “everything is an object” and still offer reasonable numeric performance. It didn’t seem so bad at the time, and we’ve been able to accomplish great things despite it, but it is an ongoing tax on developers, library designers, and users.</p>
<p>When generics came along in 2004, it got slightly better — and a lot worse. The “better” part is that autoboxing papered over some of the visible seams (though at a significant cost to the complexity of overload resolution), so we could freely use an <code>int</code> where an <code>Integer</code> was expected and vice-versa. But, this addressed only the surface problem, not the underlying rift; the set of places where we had to be aware of the rift between primitive and reference types grew, because primitives could not be used as generic type parameters. Again, this was a pragmatic compromise — and the only way known at the time to add generics to Java without massive compatibility pain — but the ongoing tax only grew larger.</p>
<p>It got worse again when lambdas came along in in 2014. Lambdas build heavily on generics, so many of the consequences faced by generics were inherited by lambdas. This rippled into the libraries: <code>java.util.function</code> suffers a combinatorial explosion of hand-specialized versions (<code>IntPredicate</code>, <code>IntToLongFunction</code>), rather than being able to parameterize more general types (<code>Predicate&lt;int&gt;</code>, <code>Function&lt;int, long&gt;</code>). The goal of generics is to abstract over representational differences, but the primitive-reference divide was getting harder to bridge.</p>
</section>
<section id="the-costs-of-boxing">
<h3><a href="#the-costs-of-boxing">The costs of boxing</a></h3>
<p>Java’s eight built-in primitive types are not objects, but they have <em>boxes</em>. When primitives want to interact in the world of objects, we transparently convert them to and from their corresponding box. Primitives don’t implement interfaces like <code>Comparable</code> — their boxes do. <code>Object</code> is the top type — but only for classes. So primitives cannot directly participate in generics or dynamically typed libraries such as reflection (where everything is expressed as <code>Object</code> or <code>Object[]</code>) — they can only do so through their boxes.</p>
<p>Going through boxes is not necessarily bad; the meaning of <code>ArrayList&lt;Integer&gt;</code> is clear enough, and autoboxing lets us deal with such types in a syntactically convenient way. But there are sharp edges. Boxed <code>int</code>s have identity, whereas primitives do not; boxing is not able to fully paper over this gap. Each time we convert from <code>Integer</code> to <code>int</code> the identity is lost, and each time we convert from <code>int</code> to an <code>Integer</code>, a fresh (but accidental) identity is created (which can inhibit valuable runtime optimizations). While <code>int</code> boxes to <code>Integer</code>, <code>int[]</code> does not box to <code>Integer[]</code>. And the relationships between primitive types and their corresponding box types are entirely ad-hoc (they’re even sometimes, but not always, spelled the same way!); you just have to keep this in your head (and in your code).</p>
<p>Developers know that boxing is not only irregular, but also expensive; absent heroic optimizations, boxing conversion entails heap allocation, and using box types as fields entails indirection. Boxes have the same problems as we saw with points above, just with smaller payloads.</p>
</section>
<section id="and-the-costs-roll-on">
<h3><a href="#and-the-costs-roll-on">And the costs roll on</a></h3>
<p>At the library level, developers face further difficult choices. The most fundamental libraries — collections and streams — are prime examples of the tradeoffs that library designers have to navigate. Collections reasonably made the choice to avoid specializing (there are libraries in the ecosystem, such as <code>trove</code> or Eclipse Collections, that go the other way, and that’s fine too), and streams tried to walk a narrow line with hand-rolled specializations for <code>int</code>, <code>long</code>, and <code>double</code>, but the existence of <code>IntStream</code> at all is evidence of the contortions that library designers often have to twist themselves into. Worse, hand specialization begets more hand specialization (<code>IntStream</code> gave rise to <code>IntToLongFunction</code> and <code>PrimitiveIterator.OfInt</code>), and there are always calls for more (“where’s my <code>CharStream</code>?”). And hand-specialization almost always introduces asymmetries. Finally, the mere existence of hand-specialized stream types was a significant constraint on the design and implementation of the library.</p>
<blockquote>
<p><em>Library designers are too often faced with the bad choice between good memory behavior and good abstraction.</em></p>
</blockquote>
<p>Users are not immune from having to reason about the gap between primitives and boxes either. Nearly every Java developer has written an ad-hoc, hand-rolled equivalent of <code>ArrayList&lt;int&gt;</code>, because <code>ArrayList&lt;Integer&gt;</code> was not (or was perceived to be not) good enough for the situation. And this hand-rolled version rarely has any connection to <code>List</code>, which inhibits interoperability and further distorts any APIs that want to use it. The tradeoff between good memory behavior and good abstraction hits users as hard as it does library designers.</p>
</section>
</section><section id="the-root-cause">
<h2><a href="#the-root-cause">The root cause</a></h2>
<p>The unfortunate layout of <code>Point[]</code> above derives from <em>object identity</em>; that all object instances are uniquely identified. Identity enables mutability; in order to mutate a field of an object, we must know <em>which</em> object we are trying to modify. Identity also enables <em>layout polymorphism</em>, where subclasses share a common layout prefix with their superclasses, allowing a subclass instance to be safely operated on through a superclass reference. Even for classes that eschew mutability and layout polymorphism (which includes most immutable concrete classes), identity can still be observed by various identity-sensitive operations, including object equality (<code>==</code>), synchronization, <code>System::identityHashCode</code>, weak references, etc.</p>
<p>Identity effectively requires that an object live in exactly one place, and if we want to access it, we go to the source. This is why the <code>Point[]</code> layout is full of pointers; the array elements are merely references to the actual object. And identity requires that the VM pessimistically preserve identity just in case someone might eventually perform an identity-sensitive operation, inhibiting many useful optimizations. In the early 90s, “everything is an Object” was an attractive mantra, and the performance costs of identity did not seem onerous at the time, but over time, the costs have increased.</p>
<p>The basic feature of Valhalla is that some classes may disavow their identity. An object that lacks identity is a <em>value object</em>, and its class is a <em>value class</em>. These classes give up some flexibility — for example, they must be immutable and cannot be layout-polymorphic — but in return are rewarded with optimized performance. The lack of identity allows the JVM to freely copy and re-encode these objects, preserving just their state and requiring fewer indirections.</p>
<p>Despite the restrictions on mutability and subclassing, value classes can use most mechanisms available to classes: methods, constructors, fields, encapsulation, interfaces, generics, annotations, etc.</p>
<p>Additionally, some value classes may opt to represent a primitive type. Primitive types can’t be <code>null</code> and are less strongly encapsulated than reference types. But their values are bare sequences of instance fields, maximizing the JVM’s ability to achieve flat, dense memory layouts and optimized calling conventions. These so-called <em>primitive classes</em> can combine the expressive power of classes with the runtime behavior of primitives. The slogan for Valhalla is:</p>
<blockquote>
<p><em>Codes like a class, works like an int.</em></p>
</blockquote>
<p>Unlike the basic primitive types (<code>int</code>, <code>double</code>, etc.), primitive types declared by classes have fields and methods, and their values can be freely converted to value objects, as needed, without the overhead and ad hoc nature of boxing. Their arrays can be treated as object arrays.</p>
<p>There are applications for primitive classes and value classes at every level. Aside from the obvious — turning the built-in primitive types into real classes — many API abstractions, such as numerics, dates, cursors, and wrappers like <code>Optional</code>, can be naturally modeled as value classes or primitive classes. Additionally, many data structures can profitably use primitive classes in their implementations to improve efficiency. And language compilers can use them as a compilation target for features like built-in numeric types, tuples, or multiple return.</p>
</section><section id="what-about-generics">
<h2><a href="#what-about-generics">What about generics?</a></h2>
<p>One of the early compromises of Java Generics is that generic type variables can only be instantiated with reference types, not primitive types. This is both inconvenient (we have to say <code>List&lt;Integer&gt;</code> when we mean <code>List&lt;int&gt;</code>) and expensive (boxing has performance overhead). With eight primitive types, this restriction is something we learned to live with, but if we can write our own flattenable data types like our <code>Point</code> above, having an <code>ArrayList&lt;Point&gt;</code> not be backed by a flattened array of <code>Point</code> seems to defeat, well, the point.</p>
<p>Parametric polymorphism always entails tradeoffs between code footprint, abstraction, and specificity, and different languages have chosen different tradeoffs. At one end of the spectrum, <code>C++</code> creates a specialized class for each instantiation of a template, and different specializations have no type-system relationship with each other. Such a <em>heterogeneous translation</em> provides a high degree of specificity but entails a large code footprint as well as a loss of abstraction — there is no type that is the equivalent of <code>List&lt;?&gt;</code> in Java.</p>
<p>At the other end of the spectrum, we have Java’s current erased implementation which produces one class for all reference instantiations and no support for primitive instantiations. Such a <em>homogeneous translation</em> yields a high degree of reuse, since there is only one class and one object layout for all (reference) instantiations. It carries the restriction that we can only range over types that have a common runtime representation, which in Java is the set of reference types. This restriction has its roots deep in the design of the JVM; there are different bytecodes for operations on reference vs primitive values.</p>
<p>While most developers have a certain degree of distaste for <a href="https://scattered-thoughts.net/writing/in-defense-of-erasure.md">erasure</a>, this approach has a powerful advantage that we could not have gotten any other way: <em>gradual migration compatibility</em>. This is the ability to compatibly evolve a class from non-generic to generic, without breaking existing sources or binary class files, and leaving clients and subclasses with the flexibility to migrate immediately, later, or never. Offering users generics, but at the cost of throwing away all their libraries, would have been a bad trade in 2004, when Java already had a large and vibrant installed base — and would be a worse trade today.</p>
<p>The plan for generics has two phases: <a href="https://openjdk.java.net/jeps/8261529"><em>universal generics</em></a> and <em>specialized generics</em>. In the first phase, we heal the rift at the language level that prevents us from using primitive types as generic type parameters, allowing generics to range over all types — but still implemented via erasure. (This yields a more uniform and expressive language, but does not yet optimize the performance — though some boxing costs have already been replaced with lighter-weight value object conversions.) In the second phase, we enable layout and code specialization in the JVM for generic classes and methods — while retaining the all-important gradual migration capability that made generics successful the first time around.</p>
</section><section id="moving-forward">
<h2><a href="#moving-forward">Moving forward</a></h2>
<p>Project Valhalla has ambitious goals, and its intrusion is both deep and broad, affecting the <code>class</code> file format, JVM, language, libraries, and user model. (In 2014, James Gosling described it as “six Ph.D theses, knotted together.”)</p>
<p>We intend to divide delivery of Project Valhalla into three broad phases: identity-free <a href="https://openjdk.java.net/jeps/8277163">value objects</a> first; then <a href="https://openjdk.java.net/jeps/401">primitive classes</a>, <a href="https://openjdk.java.net/jeps/402">migrating the existing primitives</a>, and <a href="https://openjdk.java.net/jeps/8261529">universal generics</a>; and finally specialized generics.</p>
</section>

</article></div>
  </body>
</html>
