<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.skyvern.com/blog/asking-ai-to-build-scrapers-should-be-easy-right/">Original</a>
    <h1>Asking AI to build scrapers should be easy right?</h1>
    
    <div id="readability-page-1" class="page"><section>
        <p><strong>TL;DR - We just gave Skyvern the ability to write and maintain its own code, making it 2.7x cheaper and 2.3x faster. Give it a prompt (or a series of prompts), and the AI will generate and maintain playwright code while it runs. Try out the via </strong><a href="https://github.com/Skyvern-AI/Skyvern?ref=skyvern.com"><strong>Open Source</strong></a><strong> or </strong><a href="http://app.skyvern.com/?ref=skyvern.com"><strong>Cloud</strong></a></p><p>💡 <strong>Recap: What is Skyvern?</strong> It’s <a href="https://github.com/Skyvern-AI/Skyvern?ref=skyvern.com">an open source tool</a> that helps companies automate things in the browser with AI. We use computer vision + LLMs to turn prompts into automations that run. We serve both technical and non-technical customers, and have helped them automate things like applying to jobs, fetching invoices or utility bills, filling out government forms, and purchase products from hundreds of different websites.</p><figure><img src="https://www.skyvern.com/blog/content/images/2025/10/image---2025-10-17T132106.418.png" alt="" loading="lazy" width="603" height="269" srcset="https://www.skyvern.com/blog/content/images/size/w600/2025/10/image---2025-10-17T132106.418.png 600w, https://www.skyvern.com/blog/content/images/2025/10/image---2025-10-17T132106.418.png 603w"/></figure><p>Some of you may remember our <a href="https://news.ycombinator.com/item?id=39706004&amp;ref=skyvern.com">Hackernews launch</a> from last year. All of the discussion circled around the same idea: “Building the automation is the hard part… we just want Skyvern to write the code”.</p><p>We agreed. Keeping the agent in the loop means invoking an expensive and non-deterministic LLM call on every run. If Skyvern could compile its reasoning into code and run that instead of keeping an LLM in the loop, automations would become <strong>faster, cheaper, and more reliable.</strong></p><p>So we tried to teach Skyvern to do exactly that… but it turns out, asking AI to write code the same way you and I would wasn’t easy. We ran into two big problems:</p><ol><li>Requirements for automations are ambiguous at best, and misleading at worst — even humans struggle to define them clearly</li><li>The internet is messy: drop-downs masquerade as textboxes, checkboxes that are always checked, and search bars that are secretly buttons.</li></ol><p>Getting an agent to navigate that chaos, understand intent, and still produce maintainable code came through one major breakthrough: <strong>reasoning models</strong>.</p><p>Reasoning models unlock two important capabilities:</p><ol><li>They <a href="https://www.skyvern.com/blog/web-bench-a-new-way-to-compare-ai-browser-agents/">boosted the agent accuracy</a> enough for production use</li><li>They let the agent leverage its trajectory to write a script resembling something an engineer would write</li></ol><p>Before we dive into the solution, let’s look at a real-world example: Registering new companies for payroll with <a href="https://sa.www4.irs.gov/modiein/individual/index.jsp?ref=skyvern.com">Delaware.gov</a></p><figure><img src="https://www.skyvern.com/blog/content/images/2025/10/image---2025-10-17T132100.688.png" alt="" loading="lazy" width="1920" height="1664" srcset="https://www.skyvern.com/blog/content/images/size/w600/2025/10/image---2025-10-17T132100.688.png 600w, https://www.skyvern.com/blog/content/images/size/w1000/2025/10/image---2025-10-17T132100.688.png 1000w, https://www.skyvern.com/blog/content/images/size/w1600/2025/10/image---2025-10-17T132100.688.png 1600w, https://www.skyvern.com/blog/content/images/2025/10/image---2025-10-17T132100.688.png 1920w" sizes="(min-width: 720px) 720px"/></figure><p>Here’s a simple prompt that reliably powers the workflow:</p><blockquote>Your goal is to fill out the EIN registration form. Fill out the form until you&#39;re at the form confirmation page with a summary of all information. Your goal is complete once you see a summary of all of the information.</blockquote><p>ein_info: {{ein_info}}</p><p>Writing deterministic code should be easy right?</p><p>Here’s what a naive AI Generated implementation looks like:</p><figure><img src="https://www.skyvern.com/blog/content/images/2025/10/image-1.png" alt="" loading="lazy" width="894" height="428" srcset="https://www.skyvern.com/blog/content/images/size/w600/2025/10/image-1.png 600w, https://www.skyvern.com/blog/content/images/2025/10/image-1.png 894w" sizes="(min-width: 720px) 720px"/></figure><p>And here’s where it falls apart almost immediately.</p><ol><li>Coupled interactions. Choices on this form aren’t independent. Sometimes radio buttons are linked together, but aren’t represented as such in the DOM. Other times, different buttons trigger different follow-up questions, so a static script breaks as soon as you pick something unexpected.</li></ol><figure><img src="https://www.skyvern.com/blog/content/images/2025/10/image---2025-10-17T132055.697.png" alt="" loading="lazy" width="606" height="295" srcset="https://www.skyvern.com/blog/content/images/size/w600/2025/10/image---2025-10-17T132055.697.png 600w, https://www.skyvern.com/blog/content/images/2025/10/image---2025-10-17T132055.697.png 606w"/></figure><p><strong>Random failures.</strong> Government websites love to go down at night, change field layouts between sessions, or throw you a “try again later” page mid-run.</p><figure><img src="https://www.skyvern.com/blog/content/images/2025/10/image---2025-10-17T132051.371.png" alt="" loading="lazy" width="352" height="240"/></figure><h3 id="coupled-interactions"><strong>Coupled interactions</strong></h3><p>Consider the radio button example above. Any seasoned developer would know that these legal structures are linked together. You’d instinctively model them as a finite set of entity types, and create a tree-like script that branches into different paths based on the input.</p><p>But that abstraction doesn’t exist for an agent. To agents like Skyvern, this is just a list of buttons. The relationship between the users’ input and the available set of legal structures doesn’t exist ahead of time — it must be discovered at runtime.</p><p>The agent has to infer, from the DOM and the page transitions, which choices lead where.</p><h3 id="random-non-deterministic-failures">Random non-deterministic failures</h3><p>Agents shine when things don’t go as planned. We don’t want to hard code every single edge case when compiling an agent into a deterministic script.. because we’re back to writing brittle scripts. Instead, we want to leverage agents for these situations.</p><p>Take this government form: Delaware’s portal is unavailable at night or over the weekend. Or sometimes, it’ll require you to call the IRS or sending them a fax / mail to proceed with the form. You want some intelligence in the loop to handle these scenarios gracefully.</p><p>After a few runs like the ones above, we realized “have the agent write code” wasn’t enough. We needed to copy how developers actually work: figure out the flow, add logic where it breaks, and bake that behavior into Skyvern.</p><p>So we split its job into two:</p><ol><li>Explore mode, where the agent learns how to navigate a website for a given flow, generating any metadata necessary for it to operate in subsequent runs</li></ol><p>Replay mode, it compiles those learnings into deterministic Playwright and runs fast and cheap, only falling back to the agent when something new or weird happens</p><figure><img src="https://www.skyvern.com/blog/content/images/2025/10/image---2025-10-17T132046.901.png" alt="" loading="lazy" width="1329" height="583" srcset="https://www.skyvern.com/blog/content/images/size/w600/2025/10/image---2025-10-17T132046.901.png 600w, https://www.skyvern.com/blog/content/images/size/w1000/2025/10/image---2025-10-17T132046.901.png 1000w, https://www.skyvern.com/blog/content/images/2025/10/image---2025-10-17T132046.901.png 1329w" sizes="(min-width: 720px) 720px"/></figure><h3 id="explore-once-get-the-agents%E2%80%99-trajectory">Explore once: get the agents’ trajectory</h3><p>Let’s start with a plain prompt for Skyvern. The <code>ein_info</code> field is just a json blob with all of a company’s metadata (entity type, responsible party, etc). The goal of this explore run isn’t to finish fast, it’s to learn the flow and record a trajectory we can compile later.</p><blockquote>Go to <a href="https://sa.www4.irs.gov/modiein/individual/index.jsp?ref=skyvern.com">https://sa.www4.irs.gov/modiein/individual/index.jsp</a></blockquote><h3 id="step-1-generate-a-naive-script">Step 1: generate a naive script</h3><p>From that trajectory, the agent can spit out a basic Playwright script. It runs, but it’s brittle—no context, no fallbacks:</p><figure><img src="https://www.skyvern.com/blog/content/images/2025/10/image-2.png" alt="" loading="lazy" width="889" height="335" srcset="https://www.skyvern.com/blog/content/images/size/w600/2025/10/image-2.png 600w, https://www.skyvern.com/blog/content/images/2025/10/image-2.png 889w" sizes="(min-width: 720px) 720px"/></figure><p><strong>What’s missing:</strong> it doesn’t know <em>why</em> it’s clicking “Corporation,” what should appear next, or how to recover if the DOM shifts (or the portal is down). That’s the gap we close in the next section (intent metadata + deterministic replay with targeted fallbacks).</p><h3 id="step-2-ask-the-agent-to-write-down-its-intention-so-we-can-re-use-it-later">Step 2: Ask the agent to write down its intention so we can re-use it later</h3><p>Exploration gives us a working script, but it’s brittle because it only knows <em>what</em> to click, not <em>why</em>. The fix was to capture <strong>intents</strong> to every action so the run can recover when the page shifts.</p><figure><img src="https://www.skyvern.com/blog/content/images/2025/10/image---2025-10-17T132041.611.png" alt="" loading="lazy" width="842" height="625" srcset="https://www.skyvern.com/blog/content/images/size/w600/2025/10/image---2025-10-17T132041.611.png 600w, https://www.skyvern.com/blog/content/images/2025/10/image---2025-10-17T132041.611.png 842w" sizes="(min-width: 720px) 720px"/></figure><p>To get to this intention, we generate 2 additional parameters at runtime: <code>user_detail_query</code> and <code>user_detail_answer</code> to capture the <strong>essence</strong> of the action (beyond the interaction itself)</p><figure><img src="https://www.skyvern.com/blog/content/images/2025/10/image-3.png" alt="" loading="lazy" width="892" height="274" srcset="https://www.skyvern.com/blog/content/images/size/w600/2025/10/image-3.png 600w, https://www.skyvern.com/blog/content/images/2025/10/image-3.png 892w" sizes="(min-width: 720px) 720px"/></figure><p>Then, we pass it through another LLM call to reverse engineer the action into the following:</p><figure><img src="https://www.skyvern.com/blog/content/images/2025/10/image-4.png" alt="" loading="lazy" width="892" height="213" srcset="https://www.skyvern.com/blog/content/images/size/w600/2025/10/image-4.png 600w, https://www.skyvern.com/blog/content/images/2025/10/image-4.png 892w" sizes="(min-width: 720px) 720px"/></figure><p>If this fails at replay time, we don’t blindly guess a new selector—we reuse the <strong>intention</strong> to recover:</p><ol><li>Try an alternate selector for the same intention (looser match, nearby label, aria text)</li><li>If the flow changed, ask the model <strong>once</strong>: “How do I ‘Select legal structure: Corporation’ on this page?”</li><li>If we hit a dead end (downtime/error), fallback to the original prompt to decide what to do next</li></ol><p>At this point, we have generated code that looks like this:</p><figure><img src="https://www.skyvern.com/blog/content/images/2025/10/image-5.png" alt="" loading="lazy" width="892" height="468" srcset="https://www.skyvern.com/blog/content/images/size/w600/2025/10/image-5.png 600w, https://www.skyvern.com/blog/content/images/2025/10/image-5.png 892w" sizes="(min-width: 720px) 720px"/></figure><h3 id="step-3run-it-on-the-cheap">Step 3 - Run it on the cheap</h3><p>Now that we have a plan and a fallback in place, subsequent runs are all using plain playwright — no LLM in the loop.</p><p>We benchmarked this across our customers and saw:</p><ul><li>Average automation run time goes from 278.95s → 119.92s (2.3x faster)</li><li>Average run cost goes from $0.11 → $0.04 (2.7x cheaper)</li><li>And maybe more important than either: <strong>runs are now deterministic.</strong></li></ul><figure><img src="https://www.skyvern.com/blog/content/images/2025/10/Screenshot-2025-10-16-at-14.18.17.png" alt="" loading="lazy" width="1068" height="532" srcset="https://www.skyvern.com/blog/content/images/size/w600/2025/10/Screenshot-2025-10-16-at-14.18.17.png 600w, https://www.skyvern.com/blog/content/images/size/w1000/2025/10/Screenshot-2025-10-16-at-14.18.17.png 1000w, https://www.skyvern.com/blog/content/images/2025/10/Screenshot-2025-10-16-at-14.18.17.png 1068w" sizes="(min-width: 720px) 720px"/></figure><figure><img src="https://www.skyvern.com/blog/content/images/2025/10/Screenshot-2025-10-16-at-14.18.07-1.png" alt="" loading="lazy" width="1072" height="538" srcset="https://www.skyvern.com/blog/content/images/size/w600/2025/10/Screenshot-2025-10-16-at-14.18.07-1.png 600w, https://www.skyvern.com/blog/content/images/size/w1000/2025/10/Screenshot-2025-10-16-at-14.18.07-1.png 1000w, https://www.skyvern.com/blog/content/images/2025/10/Screenshot-2025-10-16-at-14.18.07-1.png 1072w" sizes="(min-width: 720px) 720px"/></figure><p>Skyvern’s “explore → replay” pattern is already running quietly inside a bunch of workflows that used to require brittle, human-maintained scripts. A few examples:</p><ol><li><strong>Invoice Downloading</strong></li></ol><p>Agents log into vendor or utility portals with 1000s of different accounts, navigate to the right billing period, and pull invoices. When layouts or date filters change, the intent metadata lets them recover automatically instead of failing.</p><ol start="2"><li><strong>Purchasing</strong></li></ol><p>Teams use it to automate repeat purchases — think renewing software licenses or buying supplies through the same vendor dashboard each month. The first run learns the checkout path, the fallbacks handle the variety of products, and the replays run deterministically, flagging if a price or SKU changes.</p><ol start="3"><li><strong>Data Extraction from Legacy Systems</strong></li></ol><p>Skyvern navigates authenticated dashboards, scrapes tables or PDFs, and pushes the structured output into into a database via Webhooks. If the DOM shifts, Skyvern reuses the same intention (“extract transaction rows”) to remap selectors.</p><ol start="4"><li><strong>Government Form Filling</strong></li></ol><p>From payroll registration to business license renewals, Skyvern handles long, multi-step government forms that occasionally break static scripts. Explore mode figures out the flow once replay mode repeats it safely.</p><h2 id="what%E2%80%99s-next-is-it-perfect-today">What’s next? Is it perfect today?</h2><p>Not quite. The architecture works well, but there are still a few places where we can make it smarter and cheaper:</p><ol><li><strong>Analyze groups of runs when generating code</strong>.</li></ol><p>Right now, we don’t aggregate insights across failures. Each replay fixes itself in isolation. If we could analyze <em>many</em> runs together, spotting which selectors break, which flows diverge, we could automatically generalize better code and reduce the need for fallbacks. That’s especially useful for workflows that branch like trees (different inputs → different paths).</p><ol start="2"><li><strong>Cache data extractions</strong>.</li></ol><p>During data extraction, we still rely on the LLM to “read” the page each time because many of our users want to both extract and summarize information at the same time. For example, if you ask Skyvern to pull the summaries of the top five posts on Hacker News, it currently parses the DOM from scratch. We’d like to trace <em>how</em> the model found those elements (which selectors, which substrings) and reuse that mapping. That alone could make scraping and data-harvesting flows an order of magnitude cheaper.</p><ol start="3"><li><strong>Expose everything through the SDK.</strong></li></ol><p>We think it will be valuable for developers using the Skyvern SDK to auto-generate these scripts for any ai actions / workflows they run, and use them automatically for subsequent runs. It currently requires a Skyvern server running, but soon it will be the default behaviour.</p><h2 id="give-it-a-try">Give it a try!</h2><p>Run it via our <a href="https://github.com/Skyvern-AI/Skyvern?ref=skyvern.com">Skyvern Open Source</a> or <a href="http://app.skyvern.com/?ref=skyvern.com">Skyvern Cloud</a> versions and let us know what you think!</p>
    </section></div>
  </body>
</html>
