<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jub0bs.com/posts/2025-02-28-cost-of-panic-recover/">Original</a>
    <h1>The cost of Go&#39;s panic and recover</h1>
    
    <div id="readability-page-1" class="page"><div>
                <h2 id="tldr">TL;DR <a href="#tldr">¶</a></h2>
<ul>
<li>Some of the wisdom contained in Josh Bloch’s <em>Effective Java</em> book is
relevant to Go.</li>
<li><code>panic</code> and <code>recover</code> are best reserved for exceptional circumstances.</li>
<li>Reliance on <code>panic</code> and <code>recover</code> can noticeably slow down execution, incurs
heap allocations, and precludes inlining.</li>
<li>Internal handling of failure cases via <code>panic</code> and <code>recover</code> is tolerable and
sometimes beneficial.</li>
</ul>
<h2 id="abusing-java-exceptions-for-control-flow">Abusing Java exceptions for control flow <a href="#abusing-java-exceptions-for-control-flow">¶</a></h2>
<p>Even though my Java days are long gone and Go has been my language of predilection
for a while, I still occasionally revisit <a href="https://www.informit.com/store/effective-java-9780134685991" target="_blank" rel="noopener"><em>Effective Java</em></a>,
<a href="https://en.wikipedia.org/wiki/Joshua_Bloch" target="_blank" rel="noopener">Joshua Bloch</a>’s seminal and award-winning book, and I never fail to rediscover
nuggets of wisdom in it.
In item 69 (entitled <em>Use exceptions only for exceptional conditions</em>) of the
book’s third edition, Bloch presents an example of abusing Java exceptions
for control flow. I’m hesitant to quote the content of
that section in full here for fear of a copyright strike from Bloch’s publishing
company, but it—and, in fact, the whole book—is well worth a read.</p>
<p>Bloch opens with the following code snippet, which demonstrates a rather peculiar
way of iterating over an array (named <code>range</code>) of objects of some <code>Mountain</code> class
so as to invoke their <code>climb</code> method:</p>
<div><pre tabindex="0"><code data-lang="java"><span><span><span>try</span> <span>{</span>
</span></span><span><span>  <span>int</span> i <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>  <span>while</span> <span>(</span><span>true</span><span>)</span>
</span></span><span><span>    range<span>[</span>i<span>++].</span><span>climb</span><span>();</span>
</span></span><span><span><span>}</span> <span>catch</span> <span>(</span>ArrayIndexOutOfBoundsException e<span>)</span> <span>{</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Note that variable <code>i</code> eventually gets incremented up to the length of the array,
at which point an attempt to access the array at index <code>i</code> raises an
<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/ArrayIndexOutOfBoundsException.html" target="_blank" rel="noopener"><code>ArrayIndexOutOfBoundsException</code></a>, which gets caught and promptly ignored.
Of course, a functionally equivalent but far clearer and more idiomatic approach
consists in relying on a “for-each” loop,
which itself amounts to a classic three-clause loop:</p>
<div><pre tabindex="0"><code data-lang="java"><span><span><span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> range<span>.</span><span>length</span><span>;</span> i<span>++)</span> <span>{</span>
</span></span><span><span>  range<span>[</span>i<span>].</span><span>climb</span><span>();</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Bloch patiently proceeds to explain why some misguided practitioners may favour
the exception-based approach over the more idiomatic one: not only do they
perceive the termination test (<code>i &lt; range.length</code>) as costly, but they deem
it superfluous. Why? Because they believe that the Java compiler
introduces a <a href="https://en.wikipedia.org/wiki/Bounds_checking" target="_blank" rel="noopener">bounds check</a> for <em>every</em> array access (<code>range[i]</code>).
If memory safety is guaranteed by those systematic bounds checks, they reason,
why even bother checking whether the index variable goes out of bounds?</p>
<p>Bloch then debunks this theory via three counterarguments:</p>
<blockquote>
<ol>
<li>Because exceptions are designed for exceptional circumstances, there is
little incentive for JVM implementors to make them as fast as explicit tests.</li>
<li>Placing code inside a <code>try</code>-<code>catch</code> block inhibits certain optimizations
that JVM implementations might otherwise perform.</li>
<li>The standard idiom for looping through an array doesn’t necessarily result
in redundant checks. Many JVM implementations optimize them away.</li>
</ol>
</blockquote>
<p>Follows this empirical observation:</p>
<blockquote>
<p>[…] the exception-based idiom is far slower than the standard one.
On my machine, the exception-based idiom is about twice as slow as the
standard one for arrays of one hundred elements.</p>
</blockquote>
<h2 id="how-is-this-relevant-to-go">How is this relevant to Go? <a href="#how-is-this-relevant-to-go">¶</a></h2>
<p>The designers of Go <a href="https://go.dev/doc/faq#exceptions" target="_blank" rel="noopener">deliberately</a> shied away from equipping
the language with an exception system like Java’s:</p>
<blockquote>
<p>We believe that coupling exceptions to a control structure,
as in the <code>try</code>-<code>catch</code>-<code>finally</code> idiom, results in convoluted code.
It also tends to encourage programmers to label too many ordinary errors,
such as failing to open a file, as exceptional.</p>
<p>Go takes a different approach. For plain error handling, Go’s multi-value
returns make it easy to report an error without overloading the return value.
A canonical error type, coupled with Go’s other features, makes error
handling pleasant but quite different from that in other languages.</p>
<p>Go also has a couple of built-in functions to signal and recover from truly
exceptional conditions. The recovery mechanism is executed only as part of a
function’s state being torn down after an error, which is sufficient to handle
catastrophe but requires no extra control structures and, when used well,
can result in clean error-handling code.</p>
</blockquote>
<p>However, some newcomers to Go may, at least at first, struggle to adopt the
language’s idiom of communicating anticipated failure cases as
<a href="https://www.youtube.com/watch?v=PAAkCSZUG1c&amp;t=16m13s" target="_blank" rel="noopener">values</a> rather than as exceptions; they may be tempted to
abuse Go’s built-in <a href="https://pkg.go.dev/builtin#panic" target="_blank" rel="noopener"><code>panic</code></a> and <a href="https://pkg.go.dev/builtin#recover" target="_blank" rel="noopener"><code>recover</code></a>
functions for communicating even benign failure cases.</p>
<p>Go’s ecosystem (language, compiler, runtime, etc.) may be vastly different from
Java’s, but transposing Bloch’s experiment from Java to Go is nonetheless an
instructive and playful way to discuss the cost of <code>panic</code> and
<code>recover</code>, and perhaps stifle newcomers’ urge to unduly rely on that mechanism
in their programmes.</p>
<h2 id="abusing-gos-panicrecover-for-control-flow">Abusing Go’s panic/recover for control flow <a href="#abusing-gos-panicrecover-for-control-flow">¶</a></h2>
<p>In the remainder of this post, I’ll assume Go 1.24 semantics and use the Go
compiler (gc) of the same version.</p>
<p>Roughly translated to Go and molded into a self-contained package, Bloch’s code
snippet becomes the following programme (<a href="https://github.com/jub0bs/panicabused" target="_blank" rel="noopener">available on GitHub</a>):</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span><span>22
</span><span>23
</span><span>24
</span><span>25
</span><span>26
</span><span>27
</span><span>28
</span><span>29
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="go"><span><span><span>package</span> <span>main</span>
</span></span><span><span>
</span></span><span><span><span>type</span> <span>Mountain</span> <span>struct</span>{
</span></span><span><span>  <span>climbed</span> <span>bool</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> (<span>m</span> <span>*</span><span>Mountain</span>) <span>Climb</span>() {
</span></span><span><span>  <span>m</span>.<span>climbed</span> = <span>true</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>main</span>() {
</span></span><span><span>  <span>mountains</span> <span>:=</span> make([]<span>Mountain</span>, <span>8</span>)
</span></span><span><span>  <span>ClimbAllPanicRecover</span>(<span>mountains</span>)
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>ClimbAllPanicRecover</span>(<span>mountains</span> []<span>Mountain</span>) {
</span></span><span><span>  <span>defer</span> <span>func</span>() {
</span></span><span><span>    recover()
</span></span><span><span>  }()
</span></span><span><span>  <span>for</span> <span>i</span> <span>:=</span> <span>0</span>; ; <span>i</span><span>++</span> {
</span></span><span><span>    <span>mountains</span>[<span>i</span>].<span>Climb</span>() <span>// panics when i == len(mountains)
</span></span></span><span><span><span></span>  }
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>ClimbAll</span>(<span>mountains</span> []<span>Mountain</span>) {
</span></span><span><span>  <span>for</span> <span>i</span> <span>:=</span> <span>range</span> <span>mountains</span> {
</span></span><span><span>    <span>mountains</span>[<span>i</span>].<span>Climb</span>()
</span></span><span><span>  }
</span></span><span><span>}</span></span></code></pre></td></tr></tbody></table>
</div>
</div>
<p>(<a href="https://go.dev/play/p/RF9o-RIfoxM" target="_blank" rel="noopener">playground</a>)</p>
<p>As its name suggests, function <code>ClimbAllPanicRecover</code> abuses <code>panic</code> and
<code>recover</code> for iterating over the input slice, whereas function <code>ClimbAll</code>
stands for the more idiomatic reference implementation.</p>
<p>Bloch never reveals what his <code>Mountain</code> class is made of or what its <code>climb</code>
method does. To forestall any dead-code elimination by the compiler,
I’ve opted to make my <code>(*Mountain).Climb</code> method mutate the
<code>climbed</code> field of its receiver.</p>
<h3 id="the-overhead-of-panic-and-recover-is-non-negligible">The overhead of panic and recover is non-negligible <a href="#the-overhead-of-panic-and-recover-is-non-negligible">¶</a></h3>
<p>Below are some <a href="https://pkg.go.dev/testing#hdr-Benchmarks" target="_blank" rel="noopener">benchmarks</a> pitting <code>ClimbAllPanicRecover</code> against
<code>ClimbAll</code>:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>package</span> <span>main</span>
</span></span><span><span>
</span></span><span><span><span>import</span> (
</span></span><span><span>  <span>&#34;fmt&#34;</span>
</span></span><span><span>  <span>&#34;testing&#34;</span>
</span></span><span><span>)
</span></span><span><span>
</span></span><span><span><span>var</span> <span>cases</span> [][]<span>Mountain</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>init</span>() {
</span></span><span><span>  <span>for</span> <span>_</span>, <span>size</span> <span>:=</span> <span>range</span> []<span>int</span>{<span>0</span>, <span>1</span>, <span>1e1</span>, <span>1e2</span>, <span>1e3</span>, <span>1e4</span>, <span>1e5</span>} {
</span></span><span><span>    <span>s</span> <span>:=</span> make([]<span>Mountain</span>, <span>size</span>)
</span></span><span><span>      <span>cases</span> = append(<span>cases</span>, <span>s</span>)
</span></span><span><span>  }
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>BenchmarkClimbAll</span>(<span>b</span> <span>*</span><span>testing</span>.<span>B</span>) {
</span></span><span><span>  <span>benchmark</span>(<span>b</span>, <span>&#34;idiomatic&#34;</span>, <span>ClimbAll</span>)
</span></span><span><span>  <span>benchmark</span>(<span>b</span>, <span>&#34;panic-recover&#34;</span>, <span>ClimbAllPanicRecover</span>)
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>benchmark</span>(<span>b</span> <span>*</span><span>testing</span>.<span>B</span>, <span>impl</span> <span>string</span>, <span>climbAll</span> <span>func</span>([]<span>Mountain</span>)) {
</span></span><span><span>  <span>for</span> <span>_</span>, <span>ns</span> <span>:=</span> <span>range</span> <span>cases</span> {
</span></span><span><span>    <span>f</span> <span>:=</span> <span>func</span>(<span>b</span> <span>*</span><span>testing</span>.<span>B</span>) {
</span></span><span><span>      <span>for</span> <span>b</span>.<span>Loop</span>() {
</span></span><span><span>        <span>climbAll</span>(<span>ns</span>)
</span></span><span><span>      }
</span></span><span><span>    }
</span></span><span><span>    <span>desc</span> <span>:=</span> <span>fmt</span>.<span>Sprintf</span>(<span>&#34;impl=%s/size=%d&#34;</span>, <span>impl</span>, len(<span>ns</span>))
</span></span><span><span>    <span>b</span>.<span>Run</span>(<span>desc</span>, <span>f</span>)
</span></span><span><span>  }
</span></span><span><span>}
</span></span></code></pre></div><p>(Incidentally, if you’re not yet familiar with <a href="https://pkg.go.dev/testing#B.Loop" target="_blank" rel="noopener">the new <code>(*testing.B).Loop</code>
method</a> do check out <a href="https://tip.golang.org/doc/go1.24#new-benchmark-function" target="_blank" rel="noopener">the Go 1.24 release notes</a>.)</p>
<p>Let’s run those benchmarks on a relatively idle machine
and feed the results to <a href="https://pkg.go.dev/golang.org/x/perf/cmd/benchstat" target="_blank" rel="noopener"><code>benchstat</code></a>:</p>
<div><pre tabindex="0"><code data-lang="shell"><span><span>$ go version 
</span></span><span><span>go version go1.24.0 darwin/amd64
</span></span><span><span>$ go test -run <span>&#39;^$&#39;</span> -bench . -count <span>10</span> -benchmem &gt; results.txt
</span></span><span><span>$ benchstat -col <span>&#39;/impl@(idiomatic panic-recover)&#39;</span> results.txt
</span></span><span><span>goos: darwin
</span></span><span><span>goarch: amd64
</span></span><span><span>pkg: github.com/jub0bs/panicabused
</span></span><span><span>cpu: Intel<span>(</span>R<span>)</span> Core<span>(</span>TM<span>)</span> i7-6700HQ CPU @ 2.60GHz
</span></span><span><span>                       │  idiomatic  │              panic-recover              │
</span></span><span><span>                       │   sec/op    │    sec/op      vs base                  │
</span></span><span><span>ClimbAll/size<span>=</span>0-8        2.239n ± 8%   193.900n ± 1%  +8560.12% <span>(</span>p<span>=</span>0.000 n<span>=</span>10<span>)</span>
</span></span><span><span>ClimbAll/size<span>=</span>1-8        2.638n ± 1%   196.400n ± 2%  +7346.45% <span>(</span>p<span>=</span>0.000 n<span>=</span>10<span>)</span>
</span></span><span><span>ClimbAll/size<span>=</span>10-8       5.424n ± 1%   199.300n ± 2%  +3574.41% <span>(</span>p<span>=</span>0.000 n<span>=</span>10<span>)</span>
</span></span><span><span>ClimbAll/size<span>=</span>100-8      44.69n ± 1%    238.65n ± 4%   +434.01% <span>(</span>p<span>=</span>0.000 n<span>=</span>10<span>)</span>
</span></span><span><span>ClimbAll/size<span>=</span>1000-8     371.6n ± 0%     565.8n ± 1%    +52.27% <span>(</span>p<span>=</span>0.000 n<span>=</span>10<span>)</span>
</span></span><span><span>ClimbAll/size<span>=</span>10000-8    3.646µ ± 1%     3.906µ ± 0%     +7.15% <span>(</span>p<span>=</span>0.000 n<span>=</span>10<span>)</span>
</span></span><span><span>ClimbAll/size<span>=</span>100000-8   36.27µ ± 0%     36.54µ ± 1%     +0.73% <span>(</span>p<span>=</span>0.000 n<span>=</span>10<span>)</span>
</span></span><span><span>geomean                  95.10n          759.9n        +699.03%
</span></span><span><span>
</span></span><span><span>                       │  idiomatic  │        panic-recover         │
</span></span><span><span>                       │    B/op     │    B/op     vs base          │
</span></span><span><span>ClimbAll/size<span>=</span>0-8        0.00 ± 0%     24.00 ± 0%  ? <span>(</span>p<span>=</span>0.000 n<span>=</span>10<span>)</span>
</span></span><span><span>ClimbAll/size<span>=</span>1-8        0.00 ± 0%     24.00 ± 0%  ? <span>(</span>p<span>=</span>0.000 n<span>=</span>10<span>)</span>
</span></span><span><span>ClimbAll/size<span>=</span>10-8       0.00 ± 0%     24.00 ± 0%  ? <span>(</span>p<span>=</span>0.000 n<span>=</span>10<span>)</span>
</span></span><span><span>ClimbAll/size<span>=</span>100-8      0.00 ± 0%     24.00 ± 0%  ? <span>(</span>p<span>=</span>0.000 n<span>=</span>10<span>)</span>
</span></span><span><span>ClimbAll/size<span>=</span>1000-8     0.00 ± 0%     24.00 ± 0%  ? <span>(</span>p<span>=</span>0.000 n<span>=</span>10<span>)</span>
</span></span><span><span>ClimbAll/size<span>=</span>10000-8    0.00 ± 0%     24.00 ± 0%  ? <span>(</span>p<span>=</span>0.000 n<span>=</span>10<span>)</span>
</span></span><span><span>ClimbAll/size<span>=</span>100000-8   0.00 ± 0%     24.00 ± 0%  ? <span>(</span>p<span>=</span>0.000 n<span>=</span>10<span>)</span>
</span></span><span><span>geomean                            ¹   24.00       ?
</span></span><span><span>¹ summaries must be &gt;0 to compute geomean
</span></span><span><span>
</span></span><span><span>                       │  idiomatic   │        panic-recover         │
</span></span><span><span>                       │  allocs/op   │ allocs/op   vs base          │
</span></span><span><span>ClimbAll/size<span>=</span>0-8        0.000 ± 0%     1.000 ± 0%  ? <span>(</span>p<span>=</span>0.000 n<span>=</span>10<span>)</span>
</span></span><span><span>ClimbAll/size<span>=</span>1-8        0.000 ± 0%     1.000 ± 0%  ? <span>(</span>p<span>=</span>0.000 n<span>=</span>10<span>)</span>
</span></span><span><span>ClimbAll/size<span>=</span>10-8       0.000 ± 0%     1.000 ± 0%  ? <span>(</span>p<span>=</span>0.000 n<span>=</span>10<span>)</span>
</span></span><span><span>ClimbAll/size<span>=</span>100-8      0.000 ± 0%     1.000 ± 0%  ? <span>(</span>p<span>=</span>0.000 n<span>=</span>10<span>)</span>
</span></span><span><span>ClimbAll/size<span>=</span>1000-8     0.000 ± 0%     1.000 ± 0%  ? <span>(</span>p<span>=</span>0.000 n<span>=</span>10<span>)</span>
</span></span><span><span>ClimbAll/size<span>=</span>10000-8    0.000 ± 0%     1.000 ± 0%  ? <span>(</span>p<span>=</span>0.000 n<span>=</span>10<span>)</span>
</span></span><span><span>ClimbAll/size<span>=</span>100000-8   0.000 ± 0%     1.000 ± 0%  ? <span>(</span>p<span>=</span>0.000 n<span>=</span>10<span>)</span>
</span></span><span><span>geomean                             ¹   1.000       ?
</span></span><span><span>¹ summaries must be &gt;0 to compute geomean
</span></span></code></pre></div><p>The results are plain to see: <code>ClimbAllPanicRecover</code> is lumberingly slow in
comparison to <code>ClimbAll</code> in the case of small enough input slices, for which
the cost of <code>panic</code> and <code>recover</code> appears to dominate execution time.  This
observation echoes Bloch’s first counterargument: <code>panic</code> and <code>recover</code>,
because their use is intended for truly exceptional circumstances, have no
reason to be particularly fast.</p>
<p>Moreover, each call to <code>ClimbAllPanicRecover</code> incurs an allocation of 24 bytes
(on my 64-bit system, at least); although <a href="https://gophers.slack.com/archives/C0VP8EF3R/p1740484183419749" target="_blank" rel="noopener">details are scarce</a>, this
heap allocation can be attributed to a <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.24.0:src/runtime/error.go;l=116" target="_blank" rel="noopener"><code>runtime.boundsError</code></a>
with which the Go runtime eventually panics when the value of variable <code>i</code>
reaches <code>len(mountains)</code>.  In comparison, <code>ClimbAll</code> never allocates and,
therefore, doesn’t exert any unnecessary pressure on the garbage collector.</p>
<p>The performance gap between the two implementations only closes as the length
of the input slice increases and the cost of <code>panic</code> and <code>recover</code> drowns out
in the rest of the workload.</p>
<h3 id="recover-precludes-inlining">Recover precludes inlining <a href="#recover-precludes-inlining">¶</a></h3>
<p>At this stage, astute readers may suggest that <code>ClimbAllPanicRecover</code>’s
disadvantage can be explained, at least in part, by <a href="https://en.wikipedia.org/wiki/Inline_expansion" target="_blank" rel="noopener"><em>inlining</em></a>.
Inlining is a compiler strategy that can be roughly described as “replacing a
function call by the body of that function”. In many cases, inlining results in
a speedup of execution.
However, <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.24.0:src/cmd/compile/internal/inline/inl.go;l=640" target="_blank" rel="noopener">functions that contain defer statements cannot be
inlined</a>, and <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.24.0:src/cmd/compile/internal/inline/inl.go;l=620" target="_blank" rel="noopener">neither can functions that contain calls to
<code>recover</code></a>.  Therefore, contrary to <code>ClimbAll</code>,
neither <code>ClimbAllPanicRecover</code> nor the anonymous function whose call it defers can be
inlined.  Close inspection of the optimisation decisions made by the compiler
while building our programme confirms that much:</p>
<div><pre tabindex="0"><code data-lang="shell"><span><span>$ go build -gcflags <span>&#39;-m=2&#39;</span>
</span></span><span><span><span># github.com/jub0bs/panicabused</span>
</span></span><span><span>./main.go:7:6: can inline <span>(</span>*Mountain<span>)</span>.Climb with cost <span>4</span> as: method<span>(</span>*Mountain<span>)</span> func<span>()</span> <span>{</span> m.climbed <span>=</span> true <span>}</span>
</span></span><span><span>./main.go:17:8: cannot inline ClimbAllPanicRecover.func1: call to recover
</span></span><span><span>./main.go:16:6: cannot inline ClimbAllPanicRecover: unhandled op DEFER
</span></span><span><span>./main.go:11:6: can inline main with cost <span>66</span> as: func<span>()</span> <span>{</span> mountains :<span>=</span> make<span>([]</span>Mountain, 8<span>)</span>; ClimbAllPanicRecover<span>(</span>mountains<span>)</span> <span>}</span>
</span></span><span><span>./main.go:25:6: can inline ClimbAll with cost <span>14</span> as: func<span>([]</span>Mountain<span>)</span> <span>{</span> <span>for</span> loop <span>}</span>
</span></span><span><span>-snip-
</span></span></code></pre></div><p>This observation echoes Bloch’s second counterargument: relying on <code>panic</code>
and <code>recover</code> inhibits certain optimisations that the Go compiler might otherwise
perform.</p>
<p>Is the lack of inlining to blame for <code>ClimbAllPanicRecover</code>’s lacklustre
performance, though? Evidently not: I selectively disabled inlining for
<code>ClimbAll</code> by slapping a <code>go:noinline</code> directive on it and re-ran the
benchmarks, but found that <code>ClimbAll</code> still vastly outperformed
<code>ClimbAllPanicRecover</code> for all but large input slices.
However, do keep in mind that, in more realistic scenarios, an impossibility
to inline a given function may noticeably harm performance.</p>
<h3 id="no-bounds-check-elimination-for-the-unidiomatic-implementation">No bounds-check elimination for the unidiomatic implementation <a href="#no-bounds-check-elimination-for-the-unidiomatic-implementation">¶</a></h3>
<p>Like Java, Go is said to be memory-safe; in particular, <a href="https://go.dev/ref/spec#Index_expressions" target="_blank" rel="noopener">per the language
specification</a>, implementations must trigger a run-time panic
if a slice-indexing operation is ever out of bounds.  Such bounds checks are
relatively cheap, but they are not free.  When the compiler can prove, perhaps
via some heuristics, that some slice access cannot be out of bounds, it may
<a href="https://en.wikipedia.org/wiki/Bounds-checking_elimination" target="_blank" rel="noopener">omit, for better performance, the corresponding bounds check</a> from the
resulting executable.  Besides, <a href="https://go101.org/article/bounds-check-elimination.html" target="_blank" rel="noopener">advanced programming techniques</a>
exist for gently nudging the compiler towards more bounds-check elimination.</p>
<p>In the specific case of our little programme,
the compiler can eliminate the bounds checks in <code>ClimbAll</code>’s loop,
but not in <code>ClimbAllPanicRecover</code>’s:</p>
<div><pre tabindex="0"><code data-lang="shell"><span><span>$ go build -gcflags<span>=</span><span>&#34;-d=ssa/check_bce/debug=1&#34;</span>
</span></span><span><span><span># github.com/jub0bs/panicabused</span>
</span></span><span><span>./main.go:17:12: Found IsInBounds
</span></span></code></pre></div><p>This observation echoes Bloch’s third counterargument:
the idiomatic approach is more conducive to bounds-check elimination.</p>
<h2 id="what-about-internal-handling-of-failure-cases">What about internal handling of failure cases? <a href="#what-about-internal-handling-of-failure-cases">¶</a></h2>
<p>At this stage, my facetious example may have convinced you that abusing
<code>panic</code> and <code>recover</code> for control flow is not only unidiomatic but also detrimental
to performance.
More seriously, though, you may come across open-source projects that rely on
panic and recover for handling internal failure cases. In fact, look no further
than the standard library: this style is in full display in packages such as
<a href="https://pkg.go.dev/text/template" target="_blank" rel="noopener">text/template</a>, <a href="https://pkg.go.dev/encoding/json" target="_blank" rel="noopener">encoding/json</a>,
<a href="https://pkg.go.dev/encoding/gob" target="_blank" rel="noopener">encoding/gob</a>, and <a href="https://pkg.go.dev/regexp/syntax" target="_blank" rel="noopener">regexp/syntax</a>.</p>
<p>Expediency seems to be the primary motivation. Indeed, when the call stack is
deep (perhaps on account of numerous recursive calls), relying on <code>panic</code> and
<code>recover</code> obviates the need for much boilerplate; the error-handling logic can
be centralised further up the stack, at the point of panic recovery, and the
happy path can remain in focus.</p>
<hr/>
<p>Panics should not be recovered too indiscrimately, though;
a bug that triggers a panic will remain masked if a call to <code>recover</code>
inadvertently swallows that panic:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>ClimbAllPanic</span>(<span>mountains</span> []<span>Mountain</span>) {
</span></span><span><span>  <span>defer</span> <span>func</span>() {
</span></span><span><span>    recover()
</span></span><span><span>  }()
</span></span><span><span>  <span>for</span> <span>i</span> <span>:=</span> <span>0</span>; ; <span>i</span><span>++</span> {
</span></span><span><span>    <span>mountains</span>[<span>i</span><span>-</span><span>1</span>].<span>Climb</span>() <span>// off-by-one error
</span></span></span><span><span><span></span>  }
</span></span><span><span>}
</span></span></code></pre></div><p>(<a href="https://go.dev/play/p/VEsR04kjEp3" target="_blank" rel="noopener">playground</a>)</p>
<p>See <a href="https://github.com/golang/go/issues/23012" target="_blank" rel="noopener">issue 23012</a> for an example of such a problem in package
<a href="https://pkg.go.dev/encoding/json" target="_blank" rel="noopener">encoding/json</a>.</p>
<hr/>
<p>But another, more surprising motivation for such a style is… performance!
For instance, <a href="https://www.dolthub.com/blog/2023-04-14-keep-calm-and-panic/" target="_blank" rel="noopener">Max Hoffman</a> and <a href="https://dr-knz.net/go-errors-vs-exceptions-2020.html" target="_blank" rel="noopener">Raphael Poss</a> separately report
impressive speedups (on the happy path of their programme, at least) thanks to
this style.  Explanations include</p>
<ul>
<li>a decreased need for intermediate function results, and</li>
<li>comparatively fewer code branches, hence fewer opportunities for <a href="https://en.wikipedia.org/wiki/Branch_predictor" target="_blank" rel="noopener">branch mispredictions</a>.</li>
</ul>
<p>So it seems that <code>panic</code> and <code>recover</code> <em>can</em> be beneficial to performance in at
least <em>some</em> situations.</p>
<p>Should you try to emulate this style? Up to you. However, if you go down that road,
do justify your design decision by a clarifying comment and perhaps
some benchmark results; if you cannot provide such justification, you’re perhaps
being <em>too</em> clever.  Also, make sure to <a href="https://golang.org/doc/effective_go#recover" target="_blank" rel="noopener">keep this design decision as an
implementation detail of your package</a>; don’t let panics that
should remain internal leak through your package’s API, as your clients would
then regrettably be forced to deal with them.</p>
<h2 id="acknowledgements">Acknowledgements <a href="#acknowledgements">¶</a></h2>
<p>Thanks to the members of <a href="https://gophers.slack.com/" target="_blank" rel="noopener">the Gophers Slack workspace</a> who lurk in
<a href="https://app.slack.com/client/T029RQSE6/C0VP8EF3R" target="_blank" rel="noopener">the #performance channel</a> for <a href="https://gophers.slack.com/archives/C0VP8EF3R/p1740068676116669" target="_blank" rel="noopener">an enlightening discussion</a>,
which fed into this post.</p>

            </div></div>
  </body>
</html>
