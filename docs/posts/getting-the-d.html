<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://owengage.com/writing/2023-04-08-getting-the-ctrl-d/">Original</a>
    <h1>Getting the ^D</h1>
    
    <div id="readability-page-1" class="page"><div><article><p>2023-04-08</p><p>What does <code>Ctrl-D </code> do when typed into a terminal? The typical and unsatisfying
answer is it sends end-of-file (EOF) to the terminal. But what is EOF exactly?
What does this trigger? Where in the immense stack of code involved is the
behaviour found?</p>
<p>This article is in several parts. Each part answers the question, with later
parts going into more detail and being more pedantic. We start with just what it
does from the perspective of the user, move on to a more detailed explanation,
and finally dig into the source code of the Linux kernel.</p>
<h2>The &#39;short&#39; answer</h2>
<p>If you just want the short answer: <code>^D</code> sends a character called &#39;end of
transmission&#39; to the terminal. This indicates to the foreground process that
input can be read, and wakes that process up.</p>
<p>Why does the process need waking up? Because the kernel will suspend a process
when it tries to read input with none to be read.</p>
<p>A typical flow would be</p>
<ol>
<li>You run some command, creating a process.</li>
<li>This process attempts to read input and gets suspended by the kernel, because
there is none.</li>
<li>You type some input, each character being sent to the kernel by the terminal.
this does not go to the process yet.</li>
<li>You press <code>^D</code> and the terminal sends the &#39;end of transmission&#39; character to the kernel.</li>
<li>The kernel makes the data ready to be read by the process, and wakes it up.</li>
<li>The process resumes and the process receives the input.</li>
</ol>
<p>When a user types <code>^D</code> they&#39;re often trying to exit some command or shell. The
process is exactly the same as above, except for (3): no input is typed.</p>
<p>This means that the reading process receives zero bytes of data. This is the
condition used to indicate the <em>end of file</em>. Processes typically finish
executing at this point.</p>
<p>You can see this behaviour if you run <code>cat</code> with no arguments. With <code>cat</code> running, type
without pressing enter. You can see <code>cat</code> has not yet printed what you have
typed (you only see what you have typed yourself). If you press <code>^D</code>, <code>cat</code> will
wake up, resume its reading, then print what you typed. If you press <code>^D</code>
without typing anything more, <code>cat</code> reads zero bytes and takes that to mean
there will never be more input and exits.</p>
<h2>A longer answer</h2>
<p>There are a lot of assumptions and simplifications in the above section. This
section will be more pedantic and detailed.</p>
<h3>The character</h3>
<p>I said that the &#39;end of transmission&#39; character is sent to the kernel by the
terminal. What is this character? It is part of the ASCII character set, which
is a mapping of common English characters to the numbers 0-127. ASCII also
includes <a href="https://en.wikipedia.org/wiki/ASCII#Control_code_chart"><em>control
codes</em></a>, which are
special non-printed characters for things like a new line, a tab, backspace, and
even a bell sound. The character with a numeric value of 4 is our <em>end of
transmission</em> character, sometimes called <code>EOT</code>.</p>
<p>This is what is sent to the terminal when you press <code>^D</code>. In this sense it is a
character, just not an end of <em>file</em> character. The reason that it&#39;s <code>D</code> and
not some other letter is because <code>D</code> is the fourth letter of the alphabet. <code>^A</code>
sends ASCII value 1, <code>^B</code> ASCII value two, etc. This is potentially due to
old mechanical keyboards<sup><a href="#user-content-fn-1" id="user-content-fnref-1" data-footnote-ref="true" aria-describedby="footnote-label">1</a></sup>.</p>
<p>This is partly why there is confusion about <code>EOF</code> being a character. <code>^D</code> <em>does</em>
send a character, but not <code>EOF</code>. Another reason for the confusion is the library
function <code>getc</code> (&#39;get
character&#39;), which has a <a href="https://linux.die.net/man/3/getc">synopsis</a>
of:</p>
<blockquote>
<p><code>int getc(FILE *stream)</code> is equivalent to <code>fgetc()</code> ...</p>
<p><code>int fgetc(FILE *stream)</code> reads the next character from stream and returns it
as an unsigned char cast to an int, <strong>or <code>EOF</code> on end of file or error</strong>.</p>
</blockquote>
<p>Because this function is called &#39;get character&#39; people assume everything it
returns must be a character, hence <code>EOF</code> must be a character. The reality is
that it is indicating an error, not returning a character. It does not have
a value within 0-127 as an ASCII character would<sup><a href="#user-content-fn-2" id="user-content-fnref-2" data-footnote-ref="true" aria-describedby="footnote-label">2</a></sup>.</p>
<p>Okay, so <code>EOT</code> gets sent to the kernel. What does the kernel do with it? For
that we need to talk about &#39;line discipline&#39;.</p>
<h3>Line discipline</h3>
<p><em>Line discipline</em> is a part of the Linux kernel that controls how input from a
terminal gets to the foreground process in a shell (meaning the currently
running command, or the shell itself). Let&#39;s quickly jump into the difference
between a terminal and shell.</p>
<p>A terminal is software or hardware that accepts input from a user and displays
output. This is the TTY or teletype. It used to be real hardware, but
typically is now just a software program.</p>
<p>A shell is the software program that receives input from and produces output for
the terminal. Examples of shells are Bash, Zsh, and Fish. This is the part that
turns commands into actual execution.</p>

<p>There are several glue layers between terminals and shells implemented in the
kernel. One of these layers is line discipline, there is a default/fallback
implementation of this as part of the terminal/TTY driver called <code>n_tty</code>. It
exists to make application developers&#39; lives easier, and users&#39; lives more
consistent.</p>
<p>The <code>n_tty</code> default line discipline has two modes: <em>raw</em> and <em>canonical</em>. In raw
mode the kernel gives processes fine-grained access to input, whereas in
canonical mode the kernel waits for the user to finish editing a line before
providing input to the process. Most processes will read from the terminal in
canonical mode. Raw mode is mostly used by applications like shells and text
editors that require exact control over what is shown.</p>
<p>In canonical mode, when a program reads from input, it will only receive input
once the user has sent <code>^D</code> or a newline. This allows the kernel itself to
handle the user editing the current line on behalf of the process. A user might
move left and right, backspace, delete, and add new characters before finally
hitting enter. The kernel handling this is convenient for program developers, as
they don&#39;t each have to implement line editing features.</p>
<h3><code>^D</code></h3>
<p><code>^D</code> is almost the same as pressing enter. The difference is that the character
is never seen by the reading process; the kernel swallows it. When pressing
enter, the produced newline <em>is</em> sent to the process.</p>
<p>A process reads input by calling the <code>read</code> system call (<em>syscall</em>) on standard
input (<code>stdin</code>). A syscall is a function call into the kernel. This <code>read</code> is
what indicates the end of file condition by returning zero bytes. This is
impossible when pressing enter, as the newline will always be there, meaning at
least one character is returned. With <code>^D</code>, it&#39;s possible for <code>read</code> to return
zero bytes because <code>^D</code> is dropped by the kernel.</p>
<p>It&#39;s worth noting the process has to be programmed to stop if <code>read</code> returns no
bytes. A process could carry on regardless, or not read <code>stdin</code> at all. In Bash,
if you type half a command and press <code>^D</code> repeatedly, nothing happens. Bash is
ignoring the end of file condition. It only exits if you press <code>^D</code> with no
command typed.</p>
<h2>Digging into the kernel</h2>
<p>This final section will dig into the exact code in the Linux kernel where this
behaviour occurs, and round off any assumptions left standing in the previous sections.</p>
<p>I will explain a bit about what the kernel is, dig into the <code>read</code> syscall, and
talk about the terminal driver.</p>
<p>But first, you should understand that in Linux, &#39;everything is a file&#39;. Almost.
Terminals have a file associated with them. These files can be created, read and
deleted almost like &#39;regular&#39; files. This is why the <code>read</code> syscall is important
for us to explore.</p>
<h3>The kernel</h3>
<p>Almost all interaction between processes and the rest of the world is mediated
by the kernel. At any given time a process may be in <em>kernel mode</em> or <em>user
mode</em>.</p>
<p>Kernel mode means the kernel is currently executing code; this handles
interaction with hardware such as reading/writing files on disk, sending data
over the network, and sending sound to your speakers. User mode is pretty much
everything else. All your code runs in this mode, even as root<sup><a href="#user-content-fn-3" id="user-content-fnref-3" data-footnote-ref="true" aria-describedby="footnote-label">3</a></sup>.</p>
<p>This mediation by the kernel to the outside world is through <em>system calls</em> (or
<em>syscalls</em>). These are functions<sup><a href="#user-content-fn-4" id="user-content-fnref-4" data-footnote-ref="true" aria-describedby="footnote-label">4</a></sup> a program can call that transition from
user mode to kernel mode to perform some kernel action. For example, opening a
file is through the <a href="https://www.man7.org/linux/man-pages/man2/open.2.html"><code>open</code>
syscall</a>, and reading
from that file is through the already mentioned <a href="https://man7.org/linux/man-pages/man2/read.2.html"><code>read</code>
syscall</a>. If you&#39;re polite,
you&#39;ll <a href="https://www.man7.org/linux/man-pages/man2/close.2.html"><code>close</code></a> it.</p>
<p>Let&#39;s see what the <code>read</code> syscall looks like.</p>
<h3><code>read</code> syscall</h3>
<p>In the Linux codebase you can find the <code>read</code> syscall in <a href="https://github.com/torvalds/linux/blob/99ddf2254febae9eab7fb0bcc02c5322243f5c49/fs/read_write.c#L621-L624"><code>fs/read_write.c</code></a>:</p>
<pre><code>SYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count)
{
  return ksys_read(fd, buf, count);
}
</code></pre>
<p>The <code>SYSCALL_DEFINE3</code> is a macro that expands into some <a href="https://github.com/torvalds/linux/blob/99ddf2254febae9eab7fb0bcc02c5322243f5c49/include/linux/syscalls.h#L237-L256">quite complex
macro-magic</a>
that I won&#39;t go into (different architectures can redefine this macro, so it
varies). The macro takes a list of arguments starting with the name of the
syscall followed by the type then name of each syscall argument. In this case it
simply calls
<a href="https://github.com/torvalds/linux/blob/99ddf2254febae9eab7fb0bcc02c5322243f5c49/fs/read_write.c#L602-L619"><code>ksys_read</code></a>.
This in turn calls
<a href="https://github.com/torvalds/linux/blob/99ddf2254febae9eab7fb0bcc02c5322243f5c49/fs/read_write.c#L450-L479"><code>vfs_read</code></a>,
which trimmed down looks like:</p>
<pre><code>ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)
{
	ssize_t ret;
	// snip

	if (file-&gt;f_op-&gt;read)
		ret = file-&gt;f_op-&gt;read(file, buf, count, pos);
	else if (file-&gt;f_op-&gt;read_iter)
		ret = new_sync_read(file, buf, count, pos);
	else
		ret = -EINVAL;
	// snip
	return ret;
}
</code></pre>
<p>This is where following the trail gets more tricky. The next key part here is
the call to <code>file-&gt;f_op-&gt;read()</code>. This is some good old C-style object oriented
programming. This <code>read</code> is actually a <em>function pointer</em>. The exact function
that gets called depends on how the <code>f_op</code> field was set up, and the way it is
set up is determined by the type of file that it is. This is very similar to
interfaces and their implementations in high-level languages.</p>
<p>The type for the <code>f_op</code> field <a href="https://github.com/torvalds/linux/blob/99ddf2254febae9eab7fb0bcc02c5322243f5c49/include/linux/fs.h#L1754-L1798">is rather
complex</a>,
but represents all of the operations you can perform on a file in Linux. Here is
a cut down version:</p>
<pre><code>struct file_operations {
	ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
	ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
	int (*open) (struct inode *, struct file *);
	// snip
};
</code></pre>
<p>You can see the <code>read</code> field here that was called by <code>vfs_read</code>. A naive
search of the Linux codebase shows a conservative 1500 variables implementing
this <code>file_operations</code> type. Lots of types of files...</p>
<p>The one we&#39;re interested in, the one that is for terminals, is in
<a href="https://github.com/torvalds/linux/blob/99ddf2254febae9eab7fb0bcc02c5322243f5c49/drivers/tty/tty_io.c#L465-L478"><code>n_tty.c</code></a>:</p>
<pre><code>static const struct file_operations tty_fops = {
	.read_iter	= tty_read,
	.write_iter	= tty_write,
	.open		= tty_open,
	// snip
};
</code></pre>
<p>Here we can see the <code>read</code> points to the normal <code>tty_read</code> function. So while a
terminal isn&#39;t what you&#39;d think of as a &#39;file&#39;, it exposes itself as one. In
Linux it&#39;s better to think of a file as an abstraction for anything that can
sensibly implement the file operations we saw above. This gives
us a good point to jumping into terminals.</p>
<h3>TTY driver</h3>
<p>The terminal/teletype/TTY driver exists in <code>drivers/tty</code> of the kernel source.
We saw that <code>tty_read</code> is the function that gets called when a process reads
standard input. This turns out to be only half the story.</p>
<p>If you follow the code for <code>tty_read</code> it is ultimately reading a pre-existing
buffer of data. This buffer fills as input is typed by the user by a
different set of functions.</p>
<p><strong>Looking at the <code>tty_read</code> side</strong>, to avoid showing masses of source code, I&#39;ll
just list the path through the code:</p>
<ol>
<li><code>tty_read</code> calls <code>file_tty(file)</code>  which pulls out a <code>tty_struct*</code> from
the file object.</li>
<li>This <code>tty_struct</code> has an <code>ldisc</code> field of type <code>tty_ldisc*</code>. <code>ldisc</code> means line discipline.</li>
<li><code>ldisc</code> has an <code>ops</code> field with type <code>tty_ldisc_ops*</code>, similar to the file
operations we saw already.</li>
<li>The <code>n_tty</code> implementation of this is <code>n_tty_ops</code>, which has a <code>read</code> function
pointer set to <code>n_tty_read</code>. This is the point where other line disciplines
could instead be chosen. This <code>ops</code> field would point to a different implementation.</li>
</ol>
<p><code>n_tty_read</code> makes received input from the terminal available to the caller of
<code>read</code> by copying it to a kernel buffer (a buffer only accessible in kernel
mode). This data ultimately ends up in the buffer provided by the caller to
<code>read</code>. If there is no data to be read, this also puts the current process to
sleep<sup><a href="#user-content-fn-5" id="user-content-fnref-5" data-footnote-ref="true" aria-describedby="footnote-label">5</a></sup>.</p>
<p>This doesn&#39;t explain how the data actually got in the TTY buffer. This is from a
different operation, <code>receive_buf</code>.</p>
<p><strong>The other side</strong> that actually fills the buffer is much harder to track down.
The <code>tty_ldisc_ops</code> mentioned earlier with its <code>read</code> function also has a
<code>receive_buf</code> function. It is this function that gets called as a result of a
user typing into a terminal. It is also where the majority of the line
discipline logic gets handled.</p>
<p>For <code>n_tty</code>:</p>
<ol>
<li><code>receive_buf</code> points to <code>n_tty_receive_buf</code>,</li>
<li>which calls <code>n_tty_receive_buf_common</code>,</li>
<li>which calls <code>__receive_buf</code>,</li>
<li>which calls <code>n_tty_receive_buf_standard</code>.</li>
</ol>
<p>And finally things are relevant to <code>^D</code>. This function looks at each character
received, and looks up in a configured bitmap if the character is &#39;special&#39;,
meaning ones that have actions beyond just adding a character to the input. This
includes things like sending <code>SIGINT</code> with <code>^C</code>, backspace, left, right, delete
and our <code>^D</code>.</p>
<p>This bitmap that informs the kernel if a character is special can be different
per terminal. Our assumption that the EOT character causes a <code>read</code> call to
return breaks down here. The character to cause it actually depends on this
bitmap and another field of the TTY structure: <code>tty-&gt;termios-&gt;c_cc</code>. This is an
array of characters that is also configurable per TTY. Here <code>cc</code> refers to
control characters and generally maps to its equivalent ASCII control codes.</p>
<p>When a character is received and determined to be special, this <code>c_cc</code> array is
checked. The index that the character is found in determines what action the
kernel will take. <code>^D</code> only performs EOF because these fields are set up that
way. The element with index 4 in this array happens to be the one that indicates
<em>end of file</em>, and it so happens that EOT (ASCII value 4) is typically the value
of this element. In theory any character could be set up to trigger EOF.</p>
<p>When in canonical mode, <a href="https://github.com/torvalds/linux/blob/aa318c48808c0aa73216bd94c54c4553d3663add/drivers/tty/n_tty.c#L1341-L1344">the
following</a>
executes for a special character:</p>
<pre><code>if (c == EOF_CHAR(tty)) {
  c = __DISABLED_CHAR;
  goto handle_newline;
}
</code></pre>
<p><code>EOF_CHAR</code> is a macro that returns the element of the <code>c_cc</code> array representing
the EOF (more potential for confusion about being a character).
This sets the currently read character (in our case <code>^D</code>) to a special disabled
character used later, and jumps to the <code>handle_newline</code> label<sup><a href="#user-content-fn-6" id="user-content-fnref-6" data-footnote-ref="true" aria-describedby="footnote-label">6</a></sup>.</p>
<p>This looks like:</p>
<pre><code>handle_newline:
  set_bit(ldata-&gt;read_head &amp; (N_TTY_BUF_SIZE - 1), ldata-&gt;read_flags);
  put_tty_queue(c, ldata);
  smp_store_release(&amp;ldata-&gt;canon_head, ldata-&gt;read_head);
  kill_fasync(&amp;tty-&gt;fasync, SIGIO, POLL_IN);
  wake_up_interruptible_poll(&amp;tty-&gt;read_wait, EPOLLIN | EPOLLRDNORM);
</code></pre>
<p>The two key bits here for us are:</p>
<ol>
<li><code>put_tty_queue</code>, and</li>
<li><code>kill_fasync</code>.</li>
</ol>
<p>The <code>put_tty_queue</code> simply adds the character to the buffer ready for a <code>read</code>
syscall. It does this unconditionally, so the disabled character does end up
written to this buffer. This is necessary, as the <code>read</code> side needs some
indication that it should stop reading once it gets to that point. This
indication is the disabled character.</p>
<p>The <code>kill_fasync</code> ultimately causes the process listening to the terminal inputs
to wake up telling it data is available<sup><a href="#user-content-fn-6" id="user-content-fnref-6-2" data-footnote-ref="true" aria-describedby="footnote-label">6</a></sup>. The process then re-enters the
<code>read</code> syscall it slept on, reads the data, and does whatever it needs with it.
This completes our journey for <code>^D</code>.</p>
<h2>Ending remarks</h2>
<p>We started with a very terminal-user focused explanation of <code>^D</code>, and got
progressively deeper into the kernel focused explanation, quite frankly
stretching the limits of my understanding. I&#39;ve tried to be accurate where I&#39;m
sure, and vague where I&#39;m not.</p>
<p><strong>Raw mode line discipline</strong> is something I only touched on. This can be set up
so that processes receive input immediately, or after a certain amount of time,
or a certain number of characters typed. The details can be found in
<a href="https://linux.die.net/man/3/termios">termios(3)</a>.</p>
<p>This mode is used by, among others, Bash and Vim to get better control over
input, where the kernel&#39;s canonical line discipline isn&#39;t sufficient. Bash uses
the <a href="https://en.wikipedia.org/wiki/GNU_Readline">readline</a> library to do this.</p>
<p>My hope is this explains <code>^D</code> in sufficient detail for anyone. Though I&#39;d love
to be able to trace this from physical keypress on a keyboard, it&#39;s beyond my
abilities at the moment!</p>
<p>Cheers.</p>
<h2>Further reading:</h2>
<ul>
<li><a href="https://linux.die.net/man/3/termios">termios(3) manpage</a></li>
<li><a href="https://docs.kernel.org/driver-api/tty/index.html">Kernel docs for TTY</a></li>
<li><a href="http://www.linusakesson.net/programming/tty/">TTY demystified</a></li>
</ul>
</article></div></div>
  </body>
</html>
