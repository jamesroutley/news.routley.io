<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.singleton.io/posts/2021-01-31-i-wrote-a-compiler/">Original</a>
    <h1>I Wrote a Compiler</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
            <p>I have a Computer Science degree. I attended a whole course of lectures on compilers (and have a certain fondness for “<a href="https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools">the red dragon book</a>” as a result). However, I had never actually <em>written</em> a compiler from start to finish until a rainy day last weekend. Yes, this is what I do for fun.</p>
<p>I wanted to make a compiler for a real language, but a simple one so I could complete the project in a few hours. I’ve always had a bit of a soft spot for BASIC - it’s the first progamming language I learned as a kid. Luckily there’s a practical variant called TinyBASIC (thank you, wikipedia, for that tip). My version is even simpler than TinyBASIC (no <code>INPUT</code> statement). Hence I call it <code>toybasic</code>. The code is all <a href="https://github.com/dps/toybasic">available on GitHub</a>.</p>
<p>It’s written in Go and it generates Go code from BASIC.</p>
<h2 id="demo">Demo</h2>
<p>Example program <code>example/hello.bas</code></p>
<pre tabindex="0"><code data-lang="VB">10 PRINT &#34;Hello, world.&#34;
20 LET x = (3 * 2) + 3
30 LET x = x + 1
40 IF x == 10 THEN PRINT &#34;Ten!&#34;
45 PRINT x
50 IF x &gt;= 15 THEN GOTO 70
60 GOTO 30
70 END
</code></pre><p>Example output</p>
<pre tabindex="0"><code>$ ./toybasic &lt;example/hello.bas
$ go run out.go
Hello, world.
Ten!
10
11
12
13
14
15
</code></pre><h2 id="structure">Structure</h2>
<p>My compiler has three stages:</p>
<ul>
<li><em>Lexer</em> - which converts the sequence of characters in your source code into a sequence of <em>tokens</em> with meaning which can be passed to the…</li>
<li><em>Parser</em> - builds a tree from the tokens. This gives us a structural representation of the program which is easy to traverse in the next stage. It also checks that the structure of the program provided is syntactically correct and generates helpful error messages if not.</li>
<li><em>Compiler</em> - walks the parsed syntax tree and writes out Go code equivalent to the original BASIC.</li>
</ul>
<p>It’s possible to write the lexer and parser entirely by hand, but there are great off the shelf tools available that make this much simpler. The venerable <code>lex</code> and <code>yacc</code> have been helping solve this problem in C since 1975. The original authors of <code>yacc</code> were Mike Lesk and Eric Schmidt - yes <a href="https://en.wikipedia.org/wiki/Eric_Schmidt"><em>that</em></a> Eric Schmidt.</p>
<p>There are a bunch of <code>lex</code> clones available for Go. I decided to use <a href="https://github.com/blynn/nex"><code>nex</code></a> to help write my lexer. Nex has an intuitive <code>awk</code> like syntax and a very easy to follow README.</p>
<p>Go has a variant of <code>yacc</code> called <code>goyacc</code> built right in to its default tools, so that was the obvious choice to work with for the parser.</p>
<h2 id="the-parser">The parser</h2>
<p>It’s the second step in processing your code, but the parser is the best place to start writing or explaining the compiler because it contains the <em>grammar</em> for toybasic. My grammar was inspired by
Bogdan Kravtsov’s <a href="https://github.com/bkboggy/tinybasic">tinybasic</a>, but I modified it to include strings and removed <code>INPUT</code>. The full grammar is <a href="https://github.com/dps/toybasic/blob/main/parser.y">here</a>. Let’s take a look at a little excerpt:</p>
<pre tabindex="0"><code>statement:
    PRINT expr_list                                 { $$ = opr(PRINT, 1, $2); }
    | IF expression relop expression THEN statement { $$ = opr(IF, 4, $2, $3, $4, $6); }
    | GOTO expression                               { $$ = opr(GOTO, 1, $2); }
    | LET v &#39;=&#39; expression                          { $$ = opr(LET, 2, $2, $4); }
    | END                                           { $$ = opr(END, 0);  }
    ;
</code></pre><p>We define the grammar of the language in a <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">special syntax</a> and give <code>goyacc</code> a little snippet of Go code to run when it parses the relevant symbol in order to generate the parsed tree. Here you can see the part of the grammar which parses all the statements my toy BASIC supports. That <code>opr</code> function is defined in my compiler code to make the right kind and shape of objects for our syntax tree.</p>
<p>The net result is that a line of BASIC like:</p>
<pre tabindex="0"><code>10 PRINT &#34;Look!&#34;, (2 + 3) * 3
</code></pre><p>Is parsed out to a tree of objects like:</p>
<pre tabindex="0"><code>PrintOp
    |
  ListOp --------.
    |            |
  StringOp      *Op --------.
                 |          |
              GroupOp      INTEGER
                 |      
              InfixOp
              |  |  |
        INTEGER  +  INTEGER
</code></pre><p>There’s also a pretty important little table defined alongside the grammar where you define the attributes that need to be populated for every node in the tree:</p>
<pre tabindex="0"><code>%union {
    v string    /* Variable */
    s string    /* String */
    num int     /* Integer constant */
    dec float64 /* Decimal constant */
    node Node   /* Node in the AST */
};
</code></pre><h2 id="the-lexer">The lexer</h2>
<p><code>nex</code> generates the Go code necessary to tokenize a language using a series of Deterministic Finite Automata. Here’s a tiny snippet of the more than 1000 lines of code it generated for toybasic - it’s a relief not to have to write this by hand.</p>
<pre tabindex="0"><code>...
var dfas = []dfa{
	// LET
	{[]bool{false, false, false, true}, []func(rune) int{ // Transitions
		func(r rune) int {
			switch r {
			case 69:
				return -1
			case 76:
				return 1
			case 84:
				return -1
			}
			return -1
		},
...
	}, []int{ /* Start-of-input transitions */ -1, -1, -1, -1}, []int{ /* End-of-input transitions */ -1, -1, -1, -1}, nil},
...
</code></pre><p>Instead, <code>nex</code> takes a config file (<a href="https://github.com/dps/toybasic/blob/main/lexer.nex">here’s mine</a>) where you specify a set of regular expresions which capture all the keywords and identifiers for your language. Here are a few examples:</p>
<pre tabindex="0"><code>/PRINT/ {return PRINT}
/==/ {return EQ}
/[0-9]+/                {lval.num, _ = strconv.Atoi(yylex.Text()); return INTEGER}
/[0-9]+\.[0-9]*/        {lval.dec, _ = strconv.ParseFloat(yylex.Text(), 64);return DECIMAL}
/&#34;[^&#34;]*&#34;/               {lval.s = yylex.Text(); return STRING}
</code></pre><p>Those are regular expressions on the left between <code>/</code> chars. You provide them in precedence order. This code ends up being very tightly coupled with the <code>yacc</code> grammar. Each regex match runs the Go code in curly braces on the right which must return a token type and fill out the per-type properties for any leaf nodes in the tree.</p>
<h2 id="compiler">Compiler</h2>
<p>This is the only piece I needed to write directly in Go. It defines types for each possible node in the syntax tree and each <code>Node</code> type has a <code>Generate</code> function for each of them which knows how to transform that node into Go code (also calling <code>Generate</code> on any relevant children).</p>
<pre tabindex="0"><code>type Node interface {
	Generate()
}
...
type PrintOp struct {
	expression Node
}

func (op PrintOp) Generate() {
	fmt.Fprint(writer, &#34;fmt.Println(&#34;)
	op.expression.Generate()
	fmt.Fprintln(writer, &#34;)&#34;)
}
</code></pre><p>This is what <code>PrintOp</code> looks like - it simply knows how to write <code>fmt.Println([whatever code my children generate])</code> in Go!</p>
<h2 id="putting-it-all-together">Putting it all together</h2>
<p>So there we have it - a toy BASIC to Go compiler. To test it out I wrote a little BASIC program that uses every single construct in the language and made sure it works and generates the expected output. While I had a good idea how every step in the process works in the abstract it was elucidating and a tremendous amount of fun to do it for real. Definitely a good way to spend a rainy Saturday afternoon.</p>
<p>I can now verify that the very first BASIC program I ever wrote still works as expected.</p>
<pre tabindex="0"><code>10 PRINT &#34;David is cool&#34;
20 GOTO 10
</code></pre>
        </div></div>
  </body>
</html>
