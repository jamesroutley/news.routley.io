<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://iafisher.com/blog/2024/10/is-c-simple">Original</a>
    <h1>Is C simple?</h1>
    
    <div id="readability-page-1" class="page"><div class="page">
  <header>
  <a href="http://iafisher.com/">home</a>
  <a href="http://iafisher.com/blog">blog</a>
  <a href="http://iafisher.com/portfolio">portfolio</a>
  <a href="https://outsiderart.substack.com/" target="_blank">outsider art</a>
  <a href="https://github.com/iafisher" target="_blank">github</a>
</header>


  
  

  <p>Linus Torvalds is quoted in a recent <a href="https://lwn.net/Articles/990534/">LWN article</a> as saying:</p>
<blockquote>
<p>C is, in the end, a very simple language.</p>
</blockquote>
<p>Some of the commenters disagree:</p>
<blockquote>
<p><a href="https://lwn.net/Articles/991737/">roc</a>: When you first write some programs which produce correct output, you think C is simple. Then you gradually learn the rules and get better at applying them, until it&#39;s not really simple at all, but you still think it&#39;s simple from your first impression. In the meantime, you have unfortunately written a lot of garbage C code.</p>
</blockquote>
<p>And:</p>
<blockquote>
<p><a href="https://lwn.net/Articles/991743/">NYKevin</a>: C is simple if you learn it wrong. For example, if you are told that pointers are integers representing the (arbitrary) memory address of a variable, then you will think that pointers are &#34;simple.&#34; But pointers are not, on the abstract machine, integers referencing memory addresses. Rather, a pointer is an opaque handle given out by the abstract machine which may only be manipulated in very specific ways, or else it&#39;s UB.</p>
</blockquote>
<p>And a similar sentiment elsewhere:</p>
<blockquote>
<p><a href="https://news.ycombinator.com/item?id=17440590">gilgoomesh</a>: C sounds simple when you look through K&amp;R C… But the reality is filled with a staggering number of weird special cases that exist because memory doesn&#39;t work like a simple flat address space; or the compiler needs to optimise field layouts, loops, functions, allocations, register assignments and local variables; or your CPU doesn&#39;t use the lower 4 bits or upper 24 bits when addressing.</p>
</blockquote>
<p>I think there are actually two distinct viewpoints that are expressed in these objections:</p>
<ul>
<li>C <em>is</em> simple, but its simplicity offloads complexity onto the programmer, e.g. manual memory management is undeniably simpler than automated garbage collection, but it doesn&#39;t make it any simpler to write correct programs.</li>
<li>C <em>is not</em> simple, because the language specification is much more complex and abstract than &#34;portable assembly&#34; and there are many strange and surprising edge cases.</li>
</ul>
<p>The first point is really about semantics (in the linguistic sense), and – setting aside the larger question of language design – I don&#39;t think there&#39;s much substantive disagreement on the actual facts.</p>
<p>The second point is covered in depth by two excellent articles:</p>
<ul>
<li><a href="https://blog.regehr.org/archives/213">A Guide to Undefined Behavior in C and C++, Part 1</a> by John Regehr: Undefined behavior is an umbrella term for conditions that your program must not meet. Two common examples are signed integer overflow and dereferencing a null pointer. The key point that I did not understand for a long time was that it is <em>not</em> only an issue if at runtime your code &#34;triggers&#34; undefined behavior, e.g. by overflowing a signed integer. The mere <em>presence</em> of possible undefined behavior in your program can cause the compiler to emit code that is quite different from your wishes, for example by <a href="https://issuetracker.google.com/issues/42402087?pli=1">compiling &#34;dead&#34; code into a no-op</a>.</li>
<li><a href="https://stefansf.de/post/pointers-are-more-abstract-than-you-might-expect/">Pointers Are More Abstract Than You Might Expect in C</a> by Stefan Schulze Frielinghaus: The key point here is that, while pointers are normally represented as integers on modern hardware, they do not behave like them. The article gives an especially surprising example: for two pointers <code>p</code> and <code>q</code> with the same numeric value, <code>p == q</code> may be <em>false</em> if <code>p</code> and <code>q</code> were constructed from different objects and just happen to have the same address because of the stack-frame layout. More prosaically, adding 1 to an <code>int*</code> will increase its numeric value by <code>sizeof (int)</code>, not by 1.</li>
</ul>
<p>So, is C simple? I still don&#39;t know. I&#39;d like to hold on to my fond impression of C as a straightforward language that does not get in your way. But I have to concede that these arguments have given me pause. ∎</p>

  
</div></div>
  </body>
</html>
