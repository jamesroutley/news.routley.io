<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.swift.org/blog/swift-5.9-backtraces/">Original</a>
    <h1>On-Crash Backtraces in Swift</h1>
    
    <div id="readability-page-1" class="page"><div role="main">
<article>
  <header>
    

    <time pubdate="" datetime="2023-11-08T06:00:00-04:00">November 8, 2023</time>
    
    
    
      
      
      
      <p>Alastair Houghton works on the Swift and Objective-C language runtimes at Apple.</p>
      
    
    
  </header>

  <p>The new Swift 5.9 release contains a number of helpful, new features for debugging code, including an out-of-process, interactive
crash handler to inspect crashes in real time, the ability to trigger
the debugger for just-in-time debugging, along with concurrency-aware
backtracing to make it easier to understand control flow in a program
that uses structured concurrency.</p>

<h3 id="out-of-process-crash-handling">Out-of-Process Crash Handling</h3>

<p>Prior to Swift 5.9, all you would get when your program fails is a message
from the parent process (often the shell) telling you that the child
process crashed:</p>

<div><div>
<pre><span>$ </span><span>./crash</span>
I&#39;m going to crash now
zsh: segmentation fault  ./crash
</pre>
</div></div>

<p>On Apple platforms or on Windows, you could look at the crash logs
captured by the operating system’s built-in crash reporter, but on
Linux that’s typically all you had to go on.</p>

<p>Now, instead of the opaque message above, the result looks something like this:</p>

<div><div>
<pre><span>$ </span><span>./crash</span>
I&#39;m going to crash now

💣 <span>Program crashed: Bad pointer dereference at 0x0000000000000004</span>

Thread 0 crashed:

<span>0</span> <span>reallyCrashMe()</span><span> + 404</span> in <span>crash</span> at <span>/Users/alastair/Source/crashDotSwift/crash.swift:4:15</span>

  <span>   2</span>│   print(&#34;I&#39;m going to crash now&#34;)
  <span>   3</span>│   let ptr = UnsafeMutablePointer&lt;Int&gt;(bitPattern: 4)!
  <span><span><span>   4<span>│   ptr.pointee = 42</span></span></span>                                                    </span>
  <span>    </span>│               <span>▲</span>
  <span>   5</span>│ }
  <span>   6</span>│

<span>1</span> <span>crashMe()</span><span> + 12</span> in <span>crash</span> at <span>/Users/alastair/Source/crashDotSwift/crash.swift:8:3</span>

  <span>   6</span>│ 
  <span>   7</span>│ func crashMe() {
  <span><span><span>   8<span>│   reallyCrashMe()</span></span></span>                                                     </span>
  <span>    </span>│   <span>▲</span>
  <span>   9</span>│ }
  <span>  10</span>│

<span>2</span> <span>main</span><span> + 12</span> in <span>crash</span> at <span>/Users/alastair/Source/crashDotSwift/crash.swift:11:1</span>

  <span>   9</span>│ }
  <span>  10</span>│ 
  <span><span><span>  11<span>│ crashMe()</span></span></span>                                                             </span>
  <span>    </span>│ <span>▲</span>
  <span>  12</span>│

Press space to interact, D to debug, or any other key to quit (30s)

</pre>
</div></div>

<p>Or if you run the same program within a pipeline (not attached to
a terminal), you’ll see a report like this:</p>

<div><div><pre><code>*** Program crashed: Bad pointer dereference at 0x0000000000000004 ***

Thread 0 crashed:

0               0x00000001045a3df0 reallyCrashMe() + 404 in crash at /Users/alastair/Source/crashDotSwift/crash.swift:4:15
1 [ra]          0x00000001045a3ea4 crashMe() + 12 in crash at /Users/alastair/Source/crashDotSwift/crash.swift:8:3
2 [ra]          0x00000001045a3c50 main + 12 in crash at /Users/alastair/Source/crashDotSwift/crash.swift:11:1
3 [ra] [system] 0x000000018705d058 start + 2224 in dyld


Registers:

 x0 0x0000000000000001  1
 x1 0x0000000000000000  0
 x2 0x0000000000000000  0
 x3 0x000060000016c1c0  c0 c1 28 fd 79 96 00 00 fb 07 00 00 00 00 00 00  ÀÁ(ýy···û·······

...

x26 0x0000000000000000  0
x27 0x0000000000000000  0
x28 0x0000000000000000  0
 fp 0x000000016b85f310  20 f3 85 6b 01 00 00 00 a4 3e 5a 04 01 00 00 00   ó·k····¤&gt;Z·····
 lr 0x72268001045a3d44  8225402511295135044
 sp 0x000000016b85f280  a0 f2 85 6b 01 00 00 00 00 00 00 00 00 00 00 00   ò·k············
 pc 0x00000001045a3df0  28 01 00 f9 fd 7b 49 a9 ff 83 02 91 c0 03 5f d6  (··ùý{I©ÿ···À·_Ö


Images (42 omitted):

0x00000001045a0000–0x00000001045a4000 6776aba03ad432b68bc57220ac4e6ef8 crash /Users/alastair/Source/crashDotSwift/crash
0x0000000187057000–0x00000001870ea874 ee3f4181cec538c2b8a84d310be33491 dyld  /usr/lib/dyld

</code></pre></div></div>

<p>This new feature greatly improves the on-crash debugging experience on Linux, where it is on by default. It is useful on macOS as well, but must be manually
enabled. It is not presently supported on Windows.</p>

<h3 id="interactive-backtraces">Interactive Backtraces</h3>

<p>You might be wondering about the message on the last line of the
in-terminal backtrace above, where it says:</p>

<div><div><pre><code>Press space to interact, D to debug, or any other key to quit (30s)
</code></pre></div></div>

<p>Often when developing a program at the terminal, you might find that
the program crashes, but you aren’t able to reproduce the problem.
Without a suitable crash log, that can be very frustrating — you know
your program has a bug, but you don’t know what it was or how to
reproduce it.</p>

<p>The idea behind this feature is that it leaves the program suspended
(by default for 30 seconds, but this is configurable) and provides you
with the opportunity to either attach a debugger, or perform some
additional inspection of the crashed process.</p>

<p>If you tap the spacebar when this prompt appears, you will be
presented with a simple command prompt that allows you to change the
backtracer settings, generate a new backtrace, list loaded images,
display register and memory contents, and get a listing of all of the
threads in the process.  Typing <code>help</code> at the prompt will bring up a
list of available commands:</p>

<div><div>
<pre><span>&gt;&gt;&gt; </span>help
Available commands:

backtrace  Display a backtrace.
bt         Synonym for backtrace.
debug      Attach the debugger.
exit       Exit interaction, allowing program to crash normally.
help       Display help.
images     List images loaded by the program.
mem        Synonym for memory.
memory     Inspect memory.
process    Show information about the process.
quit       Synonym for exit.
reg        Synonym for registers.
registers  Display the registers.
set        Set or show options.
thread     Show or set the current thread.
threads    Synonym for process.
</pre>
</div></div>

<p>If you use the <code>debug</code> command or press <code>D</code> at the prompt, the
backtracer will help you to attach a debugger to your program.
Exactly what happens here is platform-dependent.</p>

<p>If you press any other key, or if the 30 second timer runs down, the
program will be allowed to crash normally.</p>

<p>By default, the interactive feature will trigger if your program’s
standard input and output are both attached to a terminal. In many
cases, this means you’ll get the right behavior automatically if
you’re running in a CI system or as part of an automated script,
as those tend to run with the program’s output redirected to a
pipe or a file.</p>

<p>In situations where you do not want this feature enabled, you can
explicitly disable it by setting the environment variable
<code>SWIFT_BACKTRACE</code> to <code>interactive=no</code>. You can also disable the color
output with <code>color=no</code>, as well as combine multiple options like <code>interactive=no,color=no</code>.</p>

<h3 id="structured-concurrency-support">Structured Concurrency Support</h3>

<p>The backtracer is concurrency-aware and will correctly step back
through asynchronous frames.  For example, given the program:</p>

<div><div><pre><code><span>func</span> <span>level</span><span>(</span><span>n</span><span>:</span> <span>Int</span><span>)</span> <span>async</span> <span>{</span>
  <span>if</span> <span>n</span> <span>&lt;</span> <span>5</span> <span>{</span>
    <span>await</span> <span>level</span><span>(</span><span>n</span><span>:</span> <span>n</span> <span>+</span> <span>1</span><span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>let</span> <span>ptr</span> <span>=</span> <span>UnsafeMutablePointer</span><span>&lt;</span><span>Int</span><span>&gt;</span><span>(</span><span>bitPattern</span><span>:</span> <span>4</span><span>)</span><span>!</span>
    <span>ptr</span><span>.</span><span>pointee</span> <span>=</span> <span>42</span>
  <span>}</span>
<span>}</span>

<span>@main</span>
<span>struct</span> <span>CrashAsync</span> <span>{</span>
  <span>static</span> <span>func</span> <span>main</span><span>()</span> <span>async</span> <span>{</span>
    <span>await</span> <span>level</span><span>(</span><span>n</span><span>:</span> <span>1</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>the backtrace will look like:</p>

<div><div>
<pre><span>$ </span><span>./crashAsync</span>

💣 <span>Program crashed: Bad pointer dereference at 0x0000000000000004</span>

Thread 1 crashed:

<span>0</span> <span>level(n:)</span><span> + 308</span> in <span>crashAsync</span> at <span>/Users/alastair/Source/crashDotSwift/crashAsync.swift:6:17</span>

  <span>   4</span>│   } else {
  <span>   5</span>│     let ptr = UnsafeMutablePointer&lt;Int&gt;(bitPattern: 4)!
  <span><span><span>   6<span>│     ptr.pointee = 42</span></span></span>                                                  </span>
  <span>    </span>│                 <span>▲</span>
  <span>   7</span>│   }
  <span>   8</span>│ }

<span>1</span> <span>level(n:)</span> in <span>crashAsync</span> at <span>/Users/alastair/Source/crashDotSwift/crashAsync.swift:3</span>

  <span>   1</span>│ func level(n: Int) async {
  <span>   2</span>│   if n &lt; 5 {
  <span><span><span>   3<span>│     await level(n: n + 1)</span></span></span>                                             </span>
  <span>    </span>│     <span>▲</span>
  <span>   4</span>│   } else {
  <span>   5</span>│     let ptr = UnsafeMutablePointer&lt;Int&gt;(bitPattern: 4)!

<span>2</span> <span>level(n:)</span> in <span>crashAsync</span> at <span>/Users/alastair/Source/crashDotSwift/crashAsync.swift:3</span>
<span>3</span> <span>level(n:)</span> in <span>crashAsync</span> at <span>/Users/alastair/Source/crashDotSwift/crashAsync.swift:3</span>
<span>4</span> <span>level(n:)</span> in <span>crashAsync</span> at <span>/Users/alastair/Source/crashDotSwift/crashAsync.swift:3</span>
<span>5</span> <span>static CrashAsync.main()</span> in <span>crashAsync</span> at <span>/Users/alastair/Source/crashDotSwift/crashAsync.swift:13</span>

  <span>  11</span>│ struct CrashAsync {
  <span>  12</span>│   static func main() async {
  <span><span><span>  13<span>│     await level(n: 1)</span></span></span>                                                 </span>
  <span>    </span>│     <span>▲</span>
  <span>  14</span>│   }
  <span>  15</span>│ }

Press space to interact, D to debug, or any other key to quit (30s)

</pre>
</div></div>

<p>On Apple platforms, this feature has no special requirements, but for
other platforms the backtracer needs to be able to look up symbols
to determine whether or not a given frame is asynchronous.  If the
necessary symbols are not available, the backtrace will follow the
normal program stack rather than the async activation chain.  This
will usually result in it showing frames from the concurrency runtime,
which are unlikely to be helpful when debugging most types of problem.</p>

<h3 id="improving-readability">Improving Readability</h3>

<p>The new backtracer also has a number of options to improve readability.</p>

<p>You can configure the maximum number of frames that the backtracer
will generate (the default is 64), but since you might also want to
see frames at the top of the stack, the backtracer also has a setting
for the number of frames to capture there (by default 16).  This is
particularly handy if your program crashes due to excessive recursion,
as you’ll usually see both the recursion and the cause of it, without
being overwhelmed by thousands and thousands of frames.</p>

<p>The backtracer also skips over system frames and Swift thunks by
default.  These are usually not relevant except to compiler or runtime
engineers, and generally result in more confusing output for most
developers.</p>

<p>Additionally, the backtracer will automatically demangle both Swift
and C++ mangled names.</p>

<h3 id="summary">Summary</h3>

<p>The new on-crash debugging options in Swift 5.9 help you
debug your programs when they misbehave. The backtracer has a
number of helpful features including:</p>

<ul>
  <li>Out-of-process crash handling</li>
  <li>Smart, in-line display of program source, where available</li>
  <li>The option to pause and inspect your crashed program, or even
trigger the debugger for just-in-time debugging</li>
  <li>Support for Swift Concurrency</li>
  <li>Support for C++ name mangling in addition to Swift</li>
  <li>Colorized output for readability</li>
  <li>Expanded configuration options (<a href="https://github.com/apple/swift/blob/main/docs/Backtracing.rst">see
documentation</a>).</li>
</ul>

<p>The new feature is enabled by default on Linux and can be enabled for macOS (<a href="https://github.com/apple/swift/blob/main/docs/Backtracing.rst">see
documentation</a>).
There is no Windows support at present.</p>


  
  
  
</article>
</div></div>
  </body>
</html>
