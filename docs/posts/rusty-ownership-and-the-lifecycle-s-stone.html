<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blogs.harvard.edu/kapolos/rusty-ownership-and-the-lifecycles-stone/49">Original</a>
    <h1>Rusty ownership and the lifecycle’s stone</h1>
    
    <div id="readability-page-1" class="page"><article id="post-123">
	
	<!-- .entry-header -->

	<div>
		<p><em>This blog post is an exposition of the <a href="https://github.com/devstaff-crete/DevStaff-Heraklion/blob/c87706496b11815efc0cf240ef474c7f72af7a22/meetups/meetup74-Rust/Rusty%20Ownership%20and%20the%20Lifecycle%20Stone.pdf">presentation</a> I gave at a <a href="https://github.com/devstaff-crete/DevStaff-Heraklion">Dev Staff</a>, a Developer Community in Crete. </em><em>This post approaches the matter from a high-level language perspective, just like my <a href="https://blogs.harvard.edu/kapolos/rust-from-a-javascript-perspective/">previous one</a> on Rust.<br/>
</em></p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2021/06/vivaldi_NWSXzaPKix.png" alt="" width="143" height="144"/></p>
<p>Rust is a low-level language that has the trappings of a high-level language. Rust developers gleefully enjoy a modern, streamlined experience.</p>
<p>Fact of life – just like oxygen and Doritos – is that for a long long time there existed an orthogonal relationship between performance and memory safety. You could pick only one.</p>
<p>Rust feels like a managed language (e.g. Node, Ruby) but under-the-hood, it (like C/C++) is not. That is to say, Rust produces very performant software – it is really fast.</p>
<p>In order to achieve this feat, Rust has introduced some new ways of solving the good-ole problems – and it is the only non-academic language that has managed to do so. When it comes down to memory management, Rust is a huge innovator.</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/11/firefox_YMqwh2AHdF.png" alt="" width="267" height="272" srcset="https://blogs.harvard.edu/kapolos/files/2022/11/firefox_YMqwh2AHdF.png 714w, https://blogs.harvard.edu/kapolos/files/2022/11/firefox_YMqwh2AHdF-294x300.png 294w" sizes="(max-width: 267px) 100vw, 267px"/></p>
<p>Rust disposes of the garbage collector but does not impose on the developer the burden of dealing with the memory garbage. Traditionally, you either have to manage the memory yourself (<em>à la</em> C), or pass the burden down to a run-time feature of the language – heroically called “<em>the garbage collector</em>“.</p>
<p>This means that within your executable there exists another software bundled, and that software is responsible for cleaning up the memory mess we create as the user enjoys our application.</p>
<p>While deferring the hard work to the garbage collector sounds fantastic (and it mostly is so), that comes with its own sets of problems. The biggest of said problems is that the garbage collector has the annoying habit to “pause the world”. The garbage collector literally stops the application execution to do the cleanup, and then magnanimously resumes it.</p>
<p>This can and does lead to loss of performance, which is bad in situations that depend on it. In general, the garbage collector is an inefficient beast.</p>
<p><em>Random unrelated image.</em></p>
<p><img title="Random unrelated image..." src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRkCq5DQtoANjOY2okLZgU_3Y_WQEH4ZqzhBg&amp;usqp=CAU" alt="Java Logo png download - 650*652 - Free Transparent Java png Download. - CleanPNG / KissPNG" width="246" height="180"/></p>
<p>It is not just 60-frames-per-second games that long for high performance. Any CPU-bound or repeated process also requires it.</p>
<p>Suppose for a moment the <em>UN Committee of Software Developer Experience</em> <span>mandated</span> that <em>Python</em> is now the only legal programming language in the world to code with. Python is two Orders of Magnitude (<em>100x</em>) slower than C. Suddenly, your <em>$3,000 MacBook Pro</em> barely beats an <em>early-1990s-era 386DX</em> computer.</p>
<p>Performance matters in systems programming. Keeping the the memory from blowing up not only prevents software crashes but also keeps the bad actors away from your personal data &amp; financial assets. Therefore, we <strong>need both</strong>.</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/11/firefox_WkHdNMRRVo.png" alt="" width="436" height="253" srcset="https://blogs.harvard.edu/kapolos/files/2022/11/firefox_WkHdNMRRVo.png 436w, https://blogs.harvard.edu/kapolos/files/2022/11/firefox_WkHdNMRRVo-300x174.png 300w" sizes="(max-width: 436px) 100vw, 436px"/></p>
<p>Before Rust, we relied on the genius of the developers to juggle inside their heads the two giant boulders of the application:<strong> the business domain</strong> and<strong> the security domain</strong>.</p>
<p>Experience (i.e. a multitude of bugs, exploits &amp; hacks) has clearly demonstrated that <em>this is not a good path to walk</em>. This path has been walked only because historically it was the only path in existence. Not any more!</p>
<h3>Memory Basics</h3>
<p>Developers working with high level languages almost never need to come in contact with how their application memory is structured and its mechanics. For this reason, let’s do a quick and dirty overview of how it all works.</p>
<p>There are two memory kinds that are available for your beautiful Rust application to use.</p>
<h4>The Stack</h4>
<p>The stack has a rigid structure. This makes the stack is easy to reason with.</p>
<ul>
<li>Last-in, First-out.</li>
<li>Data stored has <strong>fixed</strong> length.</li>
</ul>
<p><img src="https://miro.medium.com/max/537/0*pNowghhFZRCaXS7N." alt="Make It Real Elite — Week 1: Stack &amp; Queue | by Sebastian Zapata Mardini | Medium"/></p>
<p>You add (<em>push</em>) to the stack by adding to the top, and you remove (<em>pop</em>) from the stack by grabbing a plate from the top. Easy, peasy.</p>
<p>The stack is super fast and straightforward, but also limited in size. That’s because our applications can’t work only with data that can never be resized. For dynamically sized data (such as…, I don’t know…, useless things like <em>Strings</em> and <em>Vectors</em>), we need another type of memory.</p>
<h3>The Heap</h3>
<p>What is the heap?  Is it something like this?</p>
<p><img src="http://www2.hawaii.edu/~janst/311_f19/Notes/Topic-09/Fig-6-2-max-heapify.jpg" alt="ICS 311 #09: Heaps"/></p>
<p>No, put aside all the fancy CS stuff for a moment and let’s get back to the fundamentals.</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/vivaldi_5ovV55wvhK.png" alt="" width="767" height="416" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/vivaldi_5ovV55wvhK.png 767w, https://blogs.harvard.edu/kapolos/files/2022/10/vivaldi_5ovV55wvhK-300x163.png 300w" sizes="(max-width: 767px) 100vw, 767px"/></p>
<p>Which basically translates to this in your application memory:</p>
<p><img src="https://warehousesolutionsinc.com/mws/wp-content/uploads/2019/11/Before_All-Product-1024x576.jpg" alt="Automated Vertical Storage - Midwest Warehouse Solutions"/></p>
<h4>The good part</h4>
<p>You can mostly do whatever you want.</p>
<h4>The bad part</h4>
<p>You have to manage it or it will blow up.</p>
<h5>But what exactly does memory management mean?</h5>
<p>You <strong>must</strong>:</p>
<ul>
<li>Keep a mapping between the parts of code the the data they use of the heap.</li>
<li>Minimize data duplication.</li>
<li>Cleanup unused data.</li>
</ul>
<p>Ideally, you want your heap neat, tidy and pristine.</p>
<p><img src="http://www.avitas.com/wp-content/uploads/2014/10/Warehouse.jpg" alt="AVITAS Inventory Appraisal Services -"/></p>
<p>But <em>that’s a lot of pain to do.</em> We have AGILE constraints. We have to pair program, mob program, extreme program and get those pesky story points done before the sprint ends because the burnout chart must look a specific way.</p>
<p>So in high level languages we’re back to deferring to the garbage collector.</p>
<p>Unless we code in Rust.</p>
<h5>But how does Rust do it?</h5>
<p>To understand this, we need to explore some new concepts that Rusts brings into play.</p>
<h3>Ownership</h3>
<p>This is an easy concept to understand, but the effects it has on the way you approach problem solving may be a bit more complex.</p>
<h4>The players</h4>
<p>Ownership of <strong>what</strong>? Ownership of <strong>values.</strong></p>
<p><strong>Who</strong> owns values? <strong>Variables</strong> own values.</p>
<blockquote><p>let x = 5;</p></blockquote>
<p><strong>x </strong>owns<strong> 5</strong></p>
<h4>The rules</h4>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/11/firefox_9HaFQquzq3.png" alt="" width="515" height="285" srcset="https://blogs.harvard.edu/kapolos/files/2022/11/firefox_9HaFQquzq3.png 515w, https://blogs.harvard.edu/kapolos/files/2022/11/firefox_9HaFQquzq3-300x166.png 300w" sizes="(max-width: 515px) 100vw, 515px"/></p>
<p>The 3 rules of ownership are:</p>
<p><strong>1.</strong> Thou shall <strong>not have a value without an owner</strong>.</p>
<p><strong>2.</strong> Thou shall <strong>not have multiple owners for a single value</strong>.</p>
<p><strong>3.</strong> Thou shall sacrifice the value in a pyre once its owner’s life has no scope left.</p>
<h4>Wut?</h4>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/11/firefox_YdEnBIvy7Y.png" alt="" width="353" height="383" srcset="https://blogs.harvard.edu/kapolos/files/2022/11/firefox_YdEnBIvy7Y.png 353w, https://blogs.harvard.edu/kapolos/files/2022/11/firefox_YdEnBIvy7Y-277x300.png 277w" sizes="(max-width: 353px) 100vw, 353px"/></p>
<p>Let’s begin with the last rule (translated in modern vernacular):</p>
<h5>3. Out of scope, out of memory.</h5>
<p>What is the problem with this code?</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/rust-ownership-snippet1.png" alt="" width="1156" height="852" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/rust-ownership-snippet1.png 1156w, https://blogs.harvard.edu/kapolos/files/2022/10/rust-ownership-snippet1-300x221.png 300w, https://blogs.harvard.edu/kapolos/files/2022/10/rust-ownership-snippet1-768x566.png 768w, https://blogs.harvard.edu/kapolos/files/2022/10/rust-ownership-snippet1-1024x755.png 1024w" sizes="(max-width: 1156px) 100vw, 1156px"/></p>
<p>The problem is that <strong>it does not compile</strong>.</p>
<p>😮</p>
<p>I can loudly hear your righteously undignified screams. Why on Earth wouldn’t THIS compile?</p>
<p>The compiler is our friend. And the compiler stops us on <em>println!</em>, complaining that it:</p>
<pre><code><span>cannot find value `b` in this scope</span></code></pre>
<p>Let’s take a look at the code again, noticing the scope.</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/N5BFGbaPJE.png" alt="" width="1152" height="847" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/N5BFGbaPJE.png 1152w, https://blogs.harvard.edu/kapolos/files/2022/10/N5BFGbaPJE-300x221.png 300w, https://blogs.harvard.edu/kapolos/files/2022/10/N5BFGbaPJE-768x565.png 768w, https://blogs.harvard.edu/kapolos/files/2022/10/N5BFGbaPJE-1024x753.png 1024w" sizes="(max-width: 1152px) 100vw, 1152px"/></p>
<ul>
<li>The value <strong>7</strong> was owned by the variable <strong>b</strong>.</li>
<li>The variable <strong>b</strong> lives only for the duration of the<strong> inner scope</strong>. It is gone from memory after that.</li>
<li>Therefore, <strong>b</strong> does not exist when we try to reference it in <em>println!()</em></li>
</ul>
<p>The Rust compiler is a good butler. It wants to reduce our cognitive load. And there’s a lot of that involved on the art of making software. That is good. If something is trivial and doesn’t incur a cost, the compiler will do it on its own and hide that fact from us.</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/11/firefox_iYi8EX2YuE.png" alt="" width="380" height="499" srcset="https://blogs.harvard.edu/kapolos/files/2022/11/firefox_iYi8EX2YuE.png 380w, https://blogs.harvard.edu/kapolos/files/2022/11/firefox_iYi8EX2YuE-228x300.png 228w" sizes="(max-width: 380px) 100vw, 380px"/></p>
<p>The hidden piece of action here is that <strong>the compiler tracked the variables scopes and then freed the values once each respected scope ended</strong>. We didn’t have to type <em>drop()</em> – and since <strong>we</strong> didn’t have to do it, it’s impossible to forget it by mistake.</p>
<p>Ok, sweet, nothing too radical here. Let’s move on.</p>
<h5>2. One value, one ownER</h5>
<p>Next question – what’s the problem with this code?</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled2.png" alt="" width="1040" height="762" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled2.png 1040w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled2-300x220.png 300w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled2-768x563.png 768w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled2-1024x750.png 1024w" sizes="(max-width: 1040px) 100vw, 1040px"/></p>
<p>There is no problem, it compiles fine.</p>
<p><strong>But you can’t compile it if your value is a string instead of a number.</strong></p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled1.png" alt="" width="1040" height="762" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled1.png 1040w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled1-300x220.png 300w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled1-768x563.png 768w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled1-1024x750.png 1024w" sizes="(max-width: 1040px) 100vw, 1040px"/></p>
<p>Wtf?</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2021/06/vivaldi_u2HCVqycfn.png" alt="" width="280" height="280" srcset="https://blogs.harvard.edu/kapolos/files/2021/06/vivaldi_u2HCVqycfn.png 280w, https://blogs.harvard.edu/kapolos/files/2021/06/vivaldi_u2HCVqycfn-150x150.png 150w" sizes="(max-width: 280px) 100vw, 280px"/></p>
<p>This comes back to what we discussed earlier about the Stack and the Heap. The strings need dynamic allocation. You can append to a string. Therefore, they must live in the Heap.</p>
<p>Remember that one of the things we need to be mindful of when using the heap is to not perform unnecessary data duplication. So when we do<em> let s2 = s</em>, the compiler does <strong>NOT copy</strong> the memory value of “<em>hello</em>” into an new memory block. It simply creates <em>a new pointer</em> to the existing block in memory, like this:</p>
<p><img src="https://doc.rust-lang.org/book/img/trpl04-02.svg" alt="s1 and s2 pointing to the same value" width="472" height="472"/></p>
<h6>OK, but why doesn’t it compile?</h6>
<p>This code uses the Heap and we have <strong>two</strong> pointers referencing “<em>hello</em>” in memory. <strong>So what?</strong> Well, let’s go back to the rule we discussed.</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/2PrrROgfpi.png" alt="" width="1040" height="762" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/2PrrROgfpi.png 1040w, https://blogs.harvard.edu/kapolos/files/2022/10/2PrrROgfpi-300x220.png 300w, https://blogs.harvard.edu/kapolos/files/2022/10/2PrrROgfpi-768x563.png 768w, https://blogs.harvard.edu/kapolos/files/2022/10/2PrrROgfpi-1024x750.png 1024w" sizes="(max-width: 1040px) 100vw, 1040px"/></p>
<p>That’s what we’d expect the compiler to do, right?</p>
<p>But the compiler refuses. Why?</p>
<p><strong>It’s a double free condition!</strong> Basically, we enter undefined behavior territory. Which is bad. Really bad. So the compiler won’t let us do it.</p>
<h6>The Burdens of Ownership</h6>
<p>Unfortunately, this “<em>no copy</em>” strategy creates some troubling inconveniences, especially with passing values to functions. Functions have their own scope, just like the <em>if {}</em> block above.</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled4.png" alt="" width="1040" height="942" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled4.png 1040w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled4-300x272.png 300w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled4-768x696.png 768w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled4-1024x928.png 1024w" sizes="(max-width: 1040px) 100vw, 1040px"/></p>
<p>This code won’t compile, because the ownership of the “<em>hello</em>” String value has moved from <em>main()</em> to <em>foo()</em>.</p>
<p>Passing a variable to a function means moving its ownership. And that ownership doesn’t magically come back on its own after the function scope ends.</p>
<p>The naive solution is obvious (because <em>why bother RTFM?</em>). We can pass the ownership back and forth, like this:</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled7.png" alt="" width="1040" height="1032" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled7.png 1040w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled7-150x150.png 150w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled7-300x298.png 300w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled7-768x762.png 768w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled7-1024x1016.png 1024w" sizes="(max-width: 1040px) 100vw, 1040px"/></p>
<p>Obviously,<strong> this doesn’t scale at all.</strong> We’re supposed to reduce our cognitive load, not increase it geometrically.</p>
<p><img src="https://media.tenor.com/images/804f6be3b2e3668f9bf965bda3f48993/raw" alt="Now What GIF - Finding Nemo Bags Floating - Discover &amp; Share GIFs"/></p>
<h3>References &amp; Borrowing</h3>
<p>Naturally, Rust has a solution for that. It’s called temporary ownership, or “<em>borrowing</em>” for friends, with benefits.</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled6.png" alt="" width="1040" height="942" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled6.png 1040w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled6-300x272.png 300w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled6-768x696.png 768w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled6-1024x928.png 1024w" sizes="(max-width: 1040px) 100vw, 1040px"/></p>
<p>This code now works. We told Rust that <em>foo()</em> needs to read the value of <strong>s</strong> but that <strong>we also need it back once it’s done</strong>. No interest needed. Just give it back.</p>
<h6>But can I play with it?</h6>
<p>Rust variables are immutable by default. But they don’t have to be. And the same goes for borrowed references.</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled8.png" alt="" width="1040" height="942" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled8.png 1040w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled8-300x272.png 300w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled8-768x696.png 768w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled8-1024x928.png 1024w" sizes="(max-width: 1040px) 100vw, 1040px"/></p>
<p>The <strong><em>mut</em> </strong>modifier marks the variable as mutable. And since we want foo() to be able to modify s as well, we need to explicitly let the compiler be aware of it. So we use <strong><em>&amp;mut</em> </strong>to pass a reference in a way that allows for modifying the value.</p>
<p>But – <strong>surprise!</strong> – there are <strong>rules</strong> for borrowing. And the compiler will enforce the rules – <em>the tyrant that it is</em> – so we should be aware of them.</p>
<p>So, within the same scope:</p>
<h5>1a. One mutable borrow at a time.</h5>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled9.png" alt="" width="1040" height="806" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled9.png 1040w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled9-300x233.png 300w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled9-768x595.png 768w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled9-1024x794.png 1024w" sizes="(max-width: 1040px) 100vw, 1040px"/></p>
<p>This will not compile. <strong>If it did, it could lead a race condition</strong>. Because there’s no mechanism used here for synchronizing access to the data value.</p>
<h6>1A++.</h6>
<p>It gets even worse: <strong>You can’t have read-only references at the same time with a mutable reference.</strong></p>
<p>The code below works fine (mutable variable, no mutable borrowing, multiple read-only references):</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled11.png" alt="" width="1040" height="806" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled11.png 1040w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled11-300x233.png 300w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled11-768x595.png 768w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled11-1024x794.png 1024w" sizes="(max-width: 1040px) 100vw, 1040px"/></p>
<p>The following though does not work:</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled12.png" alt="" width="1040" height="806" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled12.png 1040w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled12-300x233.png 300w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled12-768x595.png 768w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled12-1024x794.png 1024w" sizes="(max-width: 1040px) 100vw, 1040px"/></p>
<p>Because we have a mutable reference to <strong>s</strong> and it must be the <strong>only</strong> reference to <strong>s</strong>.</p>
<p><strong>So at any given time, you can have either one mutable reference OR any number of immutable references.</strong></p>
<h5>`1b. No Invalid References</h5>
<p>An artistic depiction of a Dangling Pointer:</p>
<p><img src="https://miro.medium.com/max/1400/1*7NqaDyCtLbgOmamYwgUhLg.png" alt="Beware of chasing the dangling carrot in front of your nose | by Tom Kupka | Designing Kiwi.com | Medium"/></p>
<p>What <strong>is</strong> a dangling pointer? It’s a step to towards nothingness.</p>
<p>Let’s look at the example bellow:</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled13.png" alt="" width="1064" height="852" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled13.png 1064w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled13-300x240.png 300w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled13-768x615.png 768w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled13-1024x820.png 1024w" sizes="(max-width: 1064px) 100vw, 1064px"/></p>
<p>The dangle function creates a string value, owned by <strong>s</strong>.</p>
<p>Then it returns a <em>reference</em> to <strong>s</strong>. But remember that <strong>s</strong> goes out of scope once dangle() completes, so the value “hello” gets cleaned up from memory.</p>
<p>Then what does <strong>&amp;s</strong> point to?</p>
<p>We will never know because the compiler refuses to build a binary. And the application users won’t get an exploitable binary.</p>
<h3>Lifetimes</h3>
<p>All the rules we’ve discussed so far are emerging properties of the Rust compiler’s inner workings. It’s like how you have rules for driving your car – they exist because of the nature of all the machinery under the hood.</p>
<p>While Ownership and Borrowing are fine concepts, they do not cover all cases. There are things that the compiler simply can’t infer based on those rules only. Even if it theoretically can do deeply nested inference, that is super <em>super </em><strong>slow</strong>. So it won’t chose to.</p>
<p>In that case, it needs US – the benevolent, intelligent and beautifully handsome (or handsomely beautiful) programmers to give it a push.</p>
<p>But first, we need to dive into how the compiler works when it comes to borrowing – and talk about the concept of life.</p>
<p><img src="https://i.pinimg.com/originals/27/76/cf/2776cf8c8b3a0ce51e7f80f4577490f8.jpg" alt="Épinglé sur The Life Cycle of Plants"/></p>
<p>Not that one exactly.</p>
<p>The compiler needs to keep track of where a variable MIGHT get used. In all the places in the code where that variable MIGHT get used, the variable is considered &amp; marked as <strong>LIVE</strong>.</p>
<p>The same concept exists in Borrowing. A reference is LIVE at some parts of the code and … dead everywhere else.</p>
<p>An easy way to think about it is by looking at the lines of code. Obviously the compiler does not use “<em>line of code</em>” to reason about but it’s a good enough approximation for our purposes.</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled17.png" alt="" width="1040" height="806" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled17.png 1040w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled17-300x233.png 300w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled17-768x595.png 768w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled17-1024x794.png 1024w" sizes="(max-width: 1040px) 100vw, 1040px"/></p>
<p>We note that:</p>
<pre><strong>x</strong> is LIVE on lines <strong>{1, 2, 3}</strong>. 

<strong>r</strong> is LIVE on lines <strong>{2,3}</strong>

The set {1, 2, 3} is <strong>larger</strong> than the set {2,3}</pre>
<p>Consider this though:</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled18.png" alt="" width="1040" height="896" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled18.png 1040w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled18-300x258.png 300w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled18-768x662.png 768w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled18-1024x882.png 1024w" sizes="(max-width: 1040px) 100vw, 1040px"/></p>
<p>Here, things are a bit different:</p>
<pre><strong>x</strong> is LIVE on lines {3,4} 

<strong>r</strong> is LIVE on lines {1,2,3,4,5,6}

r <strong>outlives</strong> x, but its value comes from a loan from x.</pre>
<p>This is the<strong> dangling pointer</strong> issue we saw earlier.</p>
<p>The critical point <em>(pun intended)</em> here is that the compiler can reason about it. That’s because it has a way of figuring out when <strong>r</strong> &amp; <strong>x</strong> are LIVE.</p>
<p>This area of code where a variable is LIVE, is called a <strong>lifetime</strong>.</p>
<p>OK, so we understand the compiler was able to calculate here the lifetime of a variable. But let us look at this code:</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled15.png" alt="" width="1156" height="1166" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled15.png 1156w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled15-150x150.png 150w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled15-297x300.png 297w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled15-768x775.png 768w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled15-1015x1024.png 1015w" sizes="(max-width: 1156px) 100vw, 1156px"/></p>
<p>This code does not compile. Why not this time?</p>
<p>The problem is that the compiler can’t calculate the lifetime for the value of <strong>z</strong> (i.e. the return value of <em>max()</em>).</p>
<p>Is the lifetime of <strong>z</strong> related to the lifetime of <strong>s1</strong> or the lifetime of <strong>s2</strong>? We can’t tell before runtime.</p>
<blockquote>
<pre>As an aside, yes, technically, we COULD have the compiler analyze all the calling cases of <em>max()</em> and have it decide that in this specific case, the lifetime of <strong>z</strong> should equal the lifetime of <strong>s1</strong>. And it would work for this toy code. Now imagine asking the compiler to do that for a real code-base. You&#39;d be taking very very long compilation breaks.</pre>
</blockquote>
<p>Therefore the compiler stops and asks: “<em>Oh mighty coder, shed your light here</em>“.</p>
<h6>The compiler wants us to enhance the function signature.</h6>
<p>So we need a way to tell the compiler, “<em>you know what, have the function require that the lifetime of its return value is related to <strong>s1</strong> &amp; <strong>s2</strong> somehow</em>“.</p>
<p>And we’ll do that by using <strong>lifetime annotations</strong>.</p>
<p>They look like generics and they’re ugly looking. Thankfully, we don’t have to use them often.</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled16.png" alt="" width="1392" height="1166" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled16.png 1392w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled16-300x251.png 300w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled16-768x643.png 768w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled16-1024x858.png 1024w" sizes="(max-width: 1392px) 100vw, 1392px"/></p>
<p>Hey, this compiles now! Sweet.</p>
<p>The compiler knows that the lifetime of the return value of <em>max()</em> <strong>MUST</strong> be such that matches <strong>s1</strong> &amp; <strong>s2</strong>.</p>
<p>Because the function now is expressively clear, the compiler can reason about the code <em>main()</em>. And in this case, the program compiles.</p>
<blockquote><p>DO NOTE: Lifetime annotation does not enforce. It requires, in the sense of a contract. It’s up to the programmer to make sure the contract requirements hold when calling the function, lest the compiler throws a fit.</p></blockquote>
<p>If <em>main()</em> was a bit different, the compiler would stop us.</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled19.png" alt="" width="1392" height="1302" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled19.png 1392w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled19-300x281.png 300w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled19-768x718.png 768w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled19-1024x958.png 1024w" sizes="(max-width: 1392px) 100vw, 1392px"/></p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/firefox_DHv8xO5HqU.png" alt="" width="657" height="204" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/firefox_DHv8xO5HqU.png 657w, https://blogs.harvard.edu/kapolos/files/2022/10/firefox_DHv8xO5HqU-300x93.png 300w" sizes="(max-width: 657px) 100vw, 657px"/></p>
<p>The compiler stopped us from making a mistake because it knows exactly what the function <em>max()</em> needs in term of its parameter lifecycle.</p>
<h3>Outro</h3>
<p>Rust offers an innovative, breakthrough solution to the “<em>Fast or Safe?</em>” dilemma.</p>
<h6>The good news</h6>
<p>The compiler is there to help us.</p>
<h6>The bad news</h6>
<p>It takes a bit of practice to learn how to ride a bike well.</p>
<h4>Is it worth it?</h4>
<p>All in all, Rust is a fun and enjoyable <strong>systems</strong> programming language. It also happens to be fast &amp; safe.</p>
<p>That’s not to say that Rust is the end-all-be-all of software development though. High-level languages thrive for good reasons. Rust’s domain isn’t the same and it doesn’t try to replace them. The Rust domain is the lower level applications and it does not pretend to conquer the world. Don’t use Rust to replace Python or Node because your productivity will take a hit. At least, for now. Rust lang is evolving and it may come a time that it does make sense to use it in the core domain of managed languages.</p>
	</div><!-- .entry-content -->

	
	<!-- .entry-footer -->

</article></div>
  </body>
</html>
