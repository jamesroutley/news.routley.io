<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blogs.harvard.edu/kapolos/rusty-ownership-and-the-lifecycles-stone/49">Original</a>
    <h1>Rusty ownership and the lifecycle‚Äôs stone</h1>
    
    <div id="readability-page-1" class="page"><article id="post-123">
	
	<!-- .entry-header -->

	<div>
		<p><em>This blog post is an exposition of the <a href="https://github.com/devstaff-crete/DevStaff-Heraklion/blob/c87706496b11815efc0cf240ef474c7f72af7a22/meetups/meetup74-Rust/Rusty%20Ownership%20and%20the%20Lifecycle%20Stone.pdf">presentation</a> I gave at a <a href="https://github.com/devstaff-crete/DevStaff-Heraklion">Dev Staff</a>, a Developer Community in Crete. </em><em>This post approaches the matter from a high-level language perspective, just like my <a href="https://blogs.harvard.edu/kapolos/rust-from-a-javascript-perspective/">previous one</a> on Rust.<br/>
</em></p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2021/06/vivaldi_NWSXzaPKix.png" alt="" width="143" height="144"/></p>
<p>Rust is a low-level language that has the trappings of a high-level language. Rust developers gleefully enjoy a modern, streamlined experience.</p>
<p>Fact of life ‚Äì just like oxygen and Doritos ‚Äì is that for a long long time there existed an orthogonal relationship between performance and memory safety. You could pick only one.</p>
<p>Rust feels like a managed language (e.g. Node, Ruby) but under-the-hood, it¬†(like C/C++) is not. That is to say, Rust produces very performant software ‚Äì it is really fast.</p>
<p>In order to achieve this feat, Rust has introduced some new ways of solving the good-ole problems ‚Äì and it is the only non-academic language that has managed to do so. When it comes down to memory management, Rust is a huge innovator.</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/11/firefox_YMqwh2AHdF.png" alt="" width="267" height="272" srcset="https://blogs.harvard.edu/kapolos/files/2022/11/firefox_YMqwh2AHdF.png 714w, https://blogs.harvard.edu/kapolos/files/2022/11/firefox_YMqwh2AHdF-294x300.png 294w" sizes="(max-width: 267px) 100vw, 267px"/></p>
<p>Rust disposes of the garbage collector but does not impose on the developer the burden of dealing with the memory garbage. Traditionally, you either have to manage the memory yourself (<em>√† la</em> C), or pass the burden down to a run-time feature of the language ‚Äì heroically called ‚Äú<em>the garbage collector</em>‚Äú.</p>
<p>This means that within your executable there exists another software bundled, and that software is responsible for cleaning up the memory mess we create as the user enjoys our application.</p>
<p>While deferring the hard work to the garbage collector sounds fantastic (and it mostly is so), that comes with its own sets of problems. The biggest of said problems is that the garbage collector has the annoying habit to ‚Äúpause the world‚Äù. The garbage collector literally stops the application execution to do the cleanup, and then magnanimously resumes it.</p>
<p>This can and does lead to loss of performance, which is bad in situations that depend on it. In general, the garbage collector is an inefficient beast.</p>
<p><em>Random unrelated image.</em></p>
<p><img title="Random unrelated image..." src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRkCq5DQtoANjOY2okLZgU_3Y_WQEH4ZqzhBg&amp;usqp=CAU" alt="Java Logo png download - 650*652 - Free Transparent Java png Download. - CleanPNG / KissPNG" width="246" height="180"/></p>
<p>It is not just 60-frames-per-second games that long for high performance. Any CPU-bound or repeated process also requires it.</p>
<p>Suppose for a moment the <em>UN Committee of Software Developer Experience</em> <span>mandated</span> that <em>Python</em> is now the only legal programming language in the world to code with. Python is two Orders of Magnitude (<em>100x</em>) slower than C. Suddenly, your <em>$3,000 MacBook Pro</em> barely beats an <em>early-1990s-era 386DX</em> computer.</p>
<p>Performance matters in systems programming. Keeping the the memory from blowing up not only prevents software crashes but also keeps the bad actors away from your personal data &amp; financial assets. Therefore, we <strong>need both</strong>.</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/11/firefox_WkHdNMRRVo.png" alt="" width="436" height="253" srcset="https://blogs.harvard.edu/kapolos/files/2022/11/firefox_WkHdNMRRVo.png 436w, https://blogs.harvard.edu/kapolos/files/2022/11/firefox_WkHdNMRRVo-300x174.png 300w" sizes="(max-width: 436px) 100vw, 436px"/></p>
<p>Before Rust, we relied on the genius of the developers to juggle inside their heads the two giant boulders of the application:<strong> the business domain</strong> and<strong> the security domain</strong>.</p>
<p>Experience (i.e. a multitude of bugs, exploits &amp; hacks) has clearly demonstrated that <em>this is not a good path to walk</em>. This path has been walked only because historically it was the only path in existence. Not any more!</p>
<h3>Memory Basics</h3>
<p>Developers working with high level languages almost never need to come in contact with how their application memory is structured and its mechanics. For this reason, let‚Äôs do a quick and dirty overview of how it all works.</p>
<p>There are two memory kinds that are available for your beautiful Rust application to use.</p>
<h4>The Stack</h4>
<p>The stack has a rigid structure. This makes the stack is easy to reason with.</p>
<ul>
<li>Last-in, First-out.</li>
<li>Data stored has <strong>fixed</strong> length.</li>
</ul>
<p><img src="https://miro.medium.com/max/537/0*pNowghhFZRCaXS7N." alt="Make It Real Elite ‚Äî Week 1: Stack &amp; Queue | by Sebastian Zapata Mardini | Medium"/></p>
<p>You add (<em>push</em>) to the stack by adding to the top, and you remove (<em>pop</em>) from the stack by grabbing a plate from the top. Easy, peasy.</p>
<p>The stack is super fast and straightforward, but also limited in size. That‚Äôs because our applications can‚Äôt work only with data that can never be resized. For dynamically sized data (such as‚Ä¶, I don‚Äôt know‚Ä¶, useless things like <em>Strings</em> and <em>Vectors</em>), we need another type of memory.</p>
<h3>The Heap</h3>
<p>What is the heap?¬† Is it something like this?</p>
<p><img src="http://www2.hawaii.edu/~janst/311_f19/Notes/Topic-09/Fig-6-2-max-heapify.jpg" alt="ICS 311 #09: Heaps"/></p>
<p>No, put aside all the fancy CS stuff for a moment and let‚Äôs get back to the fundamentals.</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/vivaldi_5ovV55wvhK.png" alt="" width="767" height="416" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/vivaldi_5ovV55wvhK.png 767w, https://blogs.harvard.edu/kapolos/files/2022/10/vivaldi_5ovV55wvhK-300x163.png 300w" sizes="(max-width: 767px) 100vw, 767px"/></p>
<p>Which basically translates to this in your application memory:</p>
<p><img src="https://warehousesolutionsinc.com/mws/wp-content/uploads/2019/11/Before_All-Product-1024x576.jpg" alt="Automated Vertical Storage - Midwest Warehouse Solutions"/></p>
<h4>The good part</h4>
<p>You can mostly do whatever you want.</p>
<h4>The bad part</h4>
<p>You have to manage it or it will blow up.</p>
<h5>But what exactly does memory management mean?</h5>
<p>You <strong>must</strong>:</p>
<ul>
<li>Keep a mapping between the parts of code the the data they use of the heap.</li>
<li>Minimize data duplication.</li>
<li>Cleanup unused data.</li>
</ul>
<p>Ideally, you want your heap neat, tidy and pristine.</p>
<p><img src="http://www.avitas.com/wp-content/uploads/2014/10/Warehouse.jpg" alt="AVITAS Inventory Appraisal Services -"/></p>
<p>But <em>that‚Äôs a lot of pain to do.</em> We have AGILE constraints. We have to pair program, mob program, extreme program and get those pesky story points done before the sprint ends because the burnout chart must look a specific way.</p>
<p>So in high level languages we‚Äôre back to deferring to the garbage collector.</p>
<p>Unless we code in Rust.</p>
<h5>But how does Rust do it?</h5>
<p>To understand this, we need to explore some new concepts that Rusts brings into play.</p>
<h3>Ownership</h3>
<p>This is an easy concept to understand, but the effects it has on the way you approach problem solving may be a bit more complex.</p>
<h4>The players</h4>
<p>Ownership of <strong>what</strong>? Ownership of <strong>values.</strong></p>
<p><strong>Who</strong> owns values? <strong>Variables</strong> own values.</p>
<blockquote><p>let x = 5;</p></blockquote>
<p><strong>x </strong>owns<strong> 5</strong></p>
<h4>The rules</h4>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/11/firefox_9HaFQquzq3.png" alt="" width="515" height="285" srcset="https://blogs.harvard.edu/kapolos/files/2022/11/firefox_9HaFQquzq3.png 515w, https://blogs.harvard.edu/kapolos/files/2022/11/firefox_9HaFQquzq3-300x166.png 300w" sizes="(max-width: 515px) 100vw, 515px"/></p>
<p>The 3 rules of ownership are:</p>
<p><strong>1.</strong> Thou shall <strong>not have a value without an owner</strong>.</p>
<p><strong>2.</strong> Thou shall <strong>not have multiple owners for a single value</strong>.</p>
<p><strong>3.</strong> Thou shall sacrifice the value in a pyre once its owner‚Äôs life has no scope left.</p>
<h4>Wut?</h4>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/11/firefox_YdEnBIvy7Y.png" alt="" width="353" height="383" srcset="https://blogs.harvard.edu/kapolos/files/2022/11/firefox_YdEnBIvy7Y.png 353w, https://blogs.harvard.edu/kapolos/files/2022/11/firefox_YdEnBIvy7Y-277x300.png 277w" sizes="(max-width: 353px) 100vw, 353px"/></p>
<p>Let‚Äôs begin with the last rule (translated in modern vernacular):</p>
<h5>3. Out of scope, out of memory.</h5>
<p>What is the problem with this code?</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/rust-ownership-snippet1.png" alt="" width="1156" height="852" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/rust-ownership-snippet1.png 1156w, https://blogs.harvard.edu/kapolos/files/2022/10/rust-ownership-snippet1-300x221.png 300w, https://blogs.harvard.edu/kapolos/files/2022/10/rust-ownership-snippet1-768x566.png 768w, https://blogs.harvard.edu/kapolos/files/2022/10/rust-ownership-snippet1-1024x755.png 1024w" sizes="(max-width: 1156px) 100vw, 1156px"/></p>
<p>The problem is that <strong>it does not compile</strong>.</p>
<p>üòÆ</p>
<p>I can loudly hear your righteously undignified screams. Why on Earth wouldn‚Äôt THIS compile?</p>
<p>The compiler is our friend. And the compiler stops us on <em>println!</em>, complaining that it:</p>
<pre><code><span>cannot find value `b` in this scope</span></code></pre>
<p>Let‚Äôs take a look at the code again, noticing the scope.</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/N5BFGbaPJE.png" alt="" width="1152" height="847" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/N5BFGbaPJE.png 1152w, https://blogs.harvard.edu/kapolos/files/2022/10/N5BFGbaPJE-300x221.png 300w, https://blogs.harvard.edu/kapolos/files/2022/10/N5BFGbaPJE-768x565.png 768w, https://blogs.harvard.edu/kapolos/files/2022/10/N5BFGbaPJE-1024x753.png 1024w" sizes="(max-width: 1152px) 100vw, 1152px"/></p>
<ul>
<li>The value <strong>7</strong> was owned by the variable <strong>b</strong>.</li>
<li>The variable <strong>b</strong> lives only for the duration of the<strong> inner scope</strong>. It is gone from memory after that.</li>
<li>Therefore, <strong>b</strong> does not exist when we try to reference it in <em>println!()</em></li>
</ul>
<p>The Rust compiler is a good butler. It wants to reduce our cognitive load. And there‚Äôs a lot of that involved on the art of making software. That is good. If something is trivial and doesn‚Äôt incur a cost, the compiler will do it on its own and hide that fact from us.</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/11/firefox_iYi8EX2YuE.png" alt="" width="380" height="499" srcset="https://blogs.harvard.edu/kapolos/files/2022/11/firefox_iYi8EX2YuE.png 380w, https://blogs.harvard.edu/kapolos/files/2022/11/firefox_iYi8EX2YuE-228x300.png 228w" sizes="(max-width: 380px) 100vw, 380px"/></p>
<p>The hidden piece of action here is that <strong>the compiler tracked the variables scopes and then freed the values once each respected scope ended</strong>. We didn‚Äôt have to type <em>drop()</em> ‚Äì and since <strong>we</strong> didn‚Äôt have to do it, it‚Äôs impossible to forget it by mistake.</p>
<p>Ok, sweet, nothing too radical here. Let‚Äôs move on.</p>
<h5>2. One value, one ownER</h5>
<p>Next question ‚Äì what‚Äôs the problem with this code?</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled2.png" alt="" width="1040" height="762" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled2.png 1040w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled2-300x220.png 300w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled2-768x563.png 768w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled2-1024x750.png 1024w" sizes="(max-width: 1040px) 100vw, 1040px"/></p>
<p>There is no problem, it compiles fine.</p>
<p><strong>But you can‚Äôt compile it if your value is a string instead of a number.</strong></p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled1.png" alt="" width="1040" height="762" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled1.png 1040w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled1-300x220.png 300w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled1-768x563.png 768w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled1-1024x750.png 1024w" sizes="(max-width: 1040px) 100vw, 1040px"/></p>
<p>Wtf?</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2021/06/vivaldi_u2HCVqycfn.png" alt="" width="280" height="280" srcset="https://blogs.harvard.edu/kapolos/files/2021/06/vivaldi_u2HCVqycfn.png 280w, https://blogs.harvard.edu/kapolos/files/2021/06/vivaldi_u2HCVqycfn-150x150.png 150w" sizes="(max-width: 280px) 100vw, 280px"/></p>
<p>This comes back to what we discussed earlier about the Stack and the Heap. The strings need dynamic allocation. You can append to a string. Therefore, they must live in the Heap.</p>
<p>Remember that one of the things we need to be mindful of when using the heap is to not perform unnecessary data duplication. So when we do<em> let s2 = s</em>, the compiler does <strong>NOT copy</strong> the memory value of ‚Äú<em>hello</em>‚Äù into an new memory block. It simply creates <em>a new pointer</em> to the existing block in memory, like this:</p>
<p><img src="https://doc.rust-lang.org/book/img/trpl04-02.svg" alt="s1 and s2 pointing to the same value" width="472" height="472"/></p>
<h6>OK, but why doesn‚Äôt it compile?</h6>
<p>This code uses the Heap and we have <strong>two</strong> pointers referencing ‚Äú<em>hello</em>‚Äù in memory. <strong>So what?</strong> Well, let‚Äôs go back to the rule we discussed.</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/2PrrROgfpi.png" alt="" width="1040" height="762" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/2PrrROgfpi.png 1040w, https://blogs.harvard.edu/kapolos/files/2022/10/2PrrROgfpi-300x220.png 300w, https://blogs.harvard.edu/kapolos/files/2022/10/2PrrROgfpi-768x563.png 768w, https://blogs.harvard.edu/kapolos/files/2022/10/2PrrROgfpi-1024x750.png 1024w" sizes="(max-width: 1040px) 100vw, 1040px"/></p>
<p>That‚Äôs what we‚Äôd expect the compiler to do, right?</p>
<p>But the compiler refuses. Why?</p>
<p><strong>It‚Äôs a double free condition!</strong> Basically, we enter undefined behavior territory. Which is bad. Really bad. So the compiler won‚Äôt let us do it.</p>
<h6>The Burdens of Ownership</h6>
<p>Unfortunately, this ‚Äú<em>no copy</em>‚Äù strategy creates some troubling inconveniences, especially with passing values to functions. Functions have their own scope, just like the <em>if {}</em> block above.</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled4.png" alt="" width="1040" height="942" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled4.png 1040w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled4-300x272.png 300w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled4-768x696.png 768w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled4-1024x928.png 1024w" sizes="(max-width: 1040px) 100vw, 1040px"/></p>
<p>This code won‚Äôt compile, because the ownership of the ‚Äú<em>hello</em>‚Äù String value has moved from <em>main()</em> to <em>foo()</em>.</p>
<p>Passing a variable to a function means moving its ownership. And that ownership doesn‚Äôt magically come back on its own after the function scope ends.</p>
<p>The naive solution is obvious (because <em>why bother RTFM?</em>). We can pass the ownership back and forth, like this:</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled7.png" alt="" width="1040" height="1032" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled7.png 1040w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled7-150x150.png 150w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled7-300x298.png 300w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled7-768x762.png 768w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled7-1024x1016.png 1024w" sizes="(max-width: 1040px) 100vw, 1040px"/></p>
<p>Obviously,<strong> this doesn‚Äôt scale at all.</strong> We‚Äôre supposed to reduce our cognitive load, not increase it geometrically.</p>
<p><img src="https://media.tenor.com/images/804f6be3b2e3668f9bf965bda3f48993/raw" alt="Now What GIF - Finding Nemo Bags Floating - Discover &amp; Share GIFs"/></p>
<h3>References &amp; Borrowing</h3>
<p>Naturally, Rust has a solution for that. It‚Äôs called temporary ownership, or ‚Äú<em>borrowing</em>‚Äù for friends, with benefits.</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled6.png" alt="" width="1040" height="942" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled6.png 1040w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled6-300x272.png 300w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled6-768x696.png 768w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled6-1024x928.png 1024w" sizes="(max-width: 1040px) 100vw, 1040px"/></p>
<p>This code now works. We told Rust that <em>foo()</em> needs to read the value of <strong>s</strong> but that <strong>we also need it back once it‚Äôs done</strong>. No interest needed. Just give it back.</p>
<h6>But can I play with it?</h6>
<p>Rust variables are immutable by default. But they don‚Äôt have to be. And the same goes for borrowed references.</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled8.png" alt="" width="1040" height="942" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled8.png 1040w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled8-300x272.png 300w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled8-768x696.png 768w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled8-1024x928.png 1024w" sizes="(max-width: 1040px) 100vw, 1040px"/></p>
<p>The <strong><em>mut</em> </strong>modifier marks the variable as mutable. And since we want foo() to be able to modify s as well, we need to explicitly let the compiler be aware of it. So we use <strong><em>&amp;mut</em> </strong>to pass a reference in a way that allows for modifying the value.</p>
<p>But ‚Äì <strong>surprise!</strong> ‚Äì there are <strong>rules</strong> for borrowing. And the compiler will enforce the rules ‚Äì <em>the tyrant that it is</em> ‚Äì so we should be aware of them.</p>
<p>So, within the same scope:</p>
<h5>1a. One mutable borrow at a time.</h5>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled9.png" alt="" width="1040" height="806" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled9.png 1040w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled9-300x233.png 300w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled9-768x595.png 768w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled9-1024x794.png 1024w" sizes="(max-width: 1040px) 100vw, 1040px"/></p>
<p>This will not compile. <strong>If it did, it could lead a race condition</strong>. Because there‚Äôs no mechanism used here for synchronizing access to the data value.</p>
<h6>1A++.</h6>
<p>It gets even worse: <strong>You can‚Äôt have read-only references at the same time with a mutable reference.</strong></p>
<p>The code below works fine (mutable variable, no mutable borrowing, multiple read-only references):</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled11.png" alt="" width="1040" height="806" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled11.png 1040w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled11-300x233.png 300w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled11-768x595.png 768w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled11-1024x794.png 1024w" sizes="(max-width: 1040px) 100vw, 1040px"/></p>
<p>The following though does not work:</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled12.png" alt="" width="1040" height="806" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled12.png 1040w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled12-300x233.png 300w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled12-768x595.png 768w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled12-1024x794.png 1024w" sizes="(max-width: 1040px) 100vw, 1040px"/></p>
<p>Because we have a mutable reference to <strong>s</strong> and it must be the <strong>only</strong> reference to <strong>s</strong>.</p>
<p><strong>So at any given time, you can have either one mutable reference OR any number of immutable references.</strong></p>
<h5>`1b. No Invalid References</h5>
<p>An artistic depiction of a Dangling Pointer:</p>
<p><img src="https://miro.medium.com/max/1400/1*7NqaDyCtLbgOmamYwgUhLg.png" alt="Beware of chasing the dangling carrot in front of your nose | by Tom Kupka | Designing Kiwi.com | Medium"/></p>
<p>What <strong>is</strong> a dangling pointer? It‚Äôs a step to towards nothingness.</p>
<p>Let‚Äôs look at the example bellow:</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled13.png" alt="" width="1064" height="852" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled13.png 1064w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled13-300x240.png 300w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled13-768x615.png 768w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled13-1024x820.png 1024w" sizes="(max-width: 1064px) 100vw, 1064px"/></p>
<p>The dangle function creates a string value, owned by <strong>s</strong>.</p>
<p>Then it returns a <em>reference</em> to <strong>s</strong>. But remember that <strong>s</strong> goes out of scope once dangle() completes, so the value ‚Äúhello‚Äù gets cleaned up from memory.</p>
<p>Then what does <strong>&amp;s</strong> point to?</p>
<p>We will never know because the compiler refuses to build a binary. And the application users won‚Äôt get an exploitable binary.</p>
<h3>Lifetimes</h3>
<p>All the rules we‚Äôve discussed so far are emerging properties of the Rust compiler‚Äôs inner workings. It‚Äôs like how you have rules for driving your car ‚Äì they exist because of the nature of all the machinery under the hood.</p>
<p>While Ownership and Borrowing are fine concepts, they do not cover all cases. There are things that the compiler simply can‚Äôt infer based on those rules only. Even if it theoretically can do deeply nested inference, that is super <em>super </em><strong>slow</strong>. So it won‚Äôt chose to.</p>
<p>In that case, it needs US ‚Äì the benevolent, intelligent and beautifully handsome (or handsomely beautiful) programmers to give it a push.</p>
<p>But first, we need to dive into how the compiler works when it comes to borrowing ‚Äì and talk about the concept of life.</p>
<p><img src="https://i.pinimg.com/originals/27/76/cf/2776cf8c8b3a0ce51e7f80f4577490f8.jpg" alt="√âpingl√© sur The Life Cycle of Plants"/></p>
<p>Not that one exactly.</p>
<p>The compiler needs to keep track of where a variable MIGHT get used. In all the places in the code where that variable MIGHT get used, the variable is considered &amp; marked as <strong>LIVE</strong>.</p>
<p>The same concept exists in Borrowing. A reference is LIVE at some parts of the code and ‚Ä¶ dead everywhere else.</p>
<p>An easy way to think about it is by looking at the lines of code. Obviously the compiler does not use ‚Äú<em>line of code</em>‚Äù to reason about but it‚Äôs a good enough approximation for our purposes.</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled17.png" alt="" width="1040" height="806" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled17.png 1040w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled17-300x233.png 300w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled17-768x595.png 768w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled17-1024x794.png 1024w" sizes="(max-width: 1040px) 100vw, 1040px"/></p>
<p>We note that:</p>
<pre><strong>x</strong> is LIVE on lines <strong>{1, 2, 3}</strong>. 

<strong>r</strong> is LIVE on lines <strong>{2,3}</strong>

The set {1, 2, 3} is <strong>larger</strong> than the set {2,3}</pre>
<p>Consider this though:</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled18.png" alt="" width="1040" height="896" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled18.png 1040w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled18-300x258.png 300w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled18-768x662.png 768w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled18-1024x882.png 1024w" sizes="(max-width: 1040px) 100vw, 1040px"/></p>
<p>Here, things are a bit different:</p>
<pre><strong>x</strong> is LIVE on lines {3,4} 

<strong>r</strong> is LIVE on lines {1,2,3,4,5,6}

r <strong>outlives</strong> x, but its value comes from a loan from x.</pre>
<p>This is the<strong> dangling pointer</strong> issue we saw earlier.</p>
<p>The critical point <em>(pun intended)</em> here is that the compiler can reason about it. That‚Äôs because it has a way of figuring out when <strong>r</strong> &amp; <strong>x</strong> are LIVE.</p>
<p>This area of code where a variable is LIVE, is called a <strong>lifetime</strong>.</p>
<p>OK, so we understand the compiler was able to calculate here the lifetime of a variable. But let us look at this code:</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled15.png" alt="" width="1156" height="1166" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled15.png 1156w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled15-150x150.png 150w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled15-297x300.png 297w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled15-768x775.png 768w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled15-1015x1024.png 1015w" sizes="(max-width: 1156px) 100vw, 1156px"/></p>
<p>This code does not compile. Why not this time?</p>
<p>The problem is that the compiler can‚Äôt calculate the lifetime for the value of <strong>z</strong> (i.e. the return value of <em>max()</em>).</p>
<p>Is the lifetime of <strong>z</strong> related to the lifetime of <strong>s1</strong> or the lifetime of <strong>s2</strong>? We can‚Äôt tell before runtime.</p>
<blockquote>
<pre>As an aside, yes, technically, we COULD have the compiler analyze all the calling cases of <em>max()</em> and have it decide that in this specific case, the lifetime of <strong>z</strong> should equal the lifetime of <strong>s1</strong>. And it would work for this toy code. Now imagine asking the compiler to do that for a real code-base. You&#39;d be taking very very long compilation breaks.</pre>
</blockquote>
<p>Therefore the compiler stops and asks: ‚Äú<em>Oh mighty coder, shed your light here</em>‚Äú.</p>
<h6>The compiler wants us to enhance the function signature.</h6>
<p>So we need a way to tell the compiler, ‚Äú<em>you know what, have the function require that the lifetime of its return value is related to <strong>s1</strong> &amp; <strong>s2</strong> somehow</em>‚Äú.</p>
<p>And we‚Äôll do that by using <strong>lifetime annotations</strong>.</p>
<p>They look like generics and they‚Äôre ugly looking. Thankfully, we don‚Äôt have to use them often.</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled16.png" alt="" width="1392" height="1166" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled16.png 1392w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled16-300x251.png 300w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled16-768x643.png 768w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled16-1024x858.png 1024w" sizes="(max-width: 1392px) 100vw, 1392px"/></p>
<p>Hey, this compiles now! Sweet.</p>
<p>The compiler knows that the lifetime of the return value of <em>max()</em> <strong>MUST</strong> be such that matches <strong>s1</strong> &amp; <strong>s2</strong>.</p>
<p>Because the function now is expressively clear, the compiler can reason about the code <em>main()</em>. And in this case, the program compiles.</p>
<blockquote><p>DO NOTE: Lifetime annotation does not enforce. It requires, in the sense of a contract. It‚Äôs up to the programmer to make sure the contract requirements hold when calling the function, lest the compiler throws a fit.</p></blockquote>
<p>If <em>main()</em> was a bit different, the compiler would stop us.</p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled19.png" alt="" width="1392" height="1302" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled19.png 1392w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled19-300x281.png 300w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled19-768x718.png 768w, https://blogs.harvard.edu/kapolos/files/2022/10/raycast-untitled19-1024x958.png 1024w" sizes="(max-width: 1392px) 100vw, 1392px"/></p>
<p><img src="http://blogs.harvard.edu/kapolos/files/2022/10/firefox_DHv8xO5HqU.png" alt="" width="657" height="204" srcset="https://blogs.harvard.edu/kapolos/files/2022/10/firefox_DHv8xO5HqU.png 657w, https://blogs.harvard.edu/kapolos/files/2022/10/firefox_DHv8xO5HqU-300x93.png 300w" sizes="(max-width: 657px) 100vw, 657px"/></p>
<p>The compiler stopped us from making a mistake because it knows exactly what the function <em>max()</em> needs in term of its parameter lifecycle.</p>
<h3>Outro</h3>
<p>Rust offers an innovative, breakthrough solution to the ‚Äú<em>Fast or Safe?</em>‚Äù dilemma.</p>
<h6>The good news</h6>
<p>The compiler is there to help us.</p>
<h6>The bad news</h6>
<p>It takes a bit of practice to learn how to ride a bike well.</p>
<h4>Is it worth it?</h4>
<p>All in all, Rust is a fun and enjoyable <strong>systems</strong> programming language. It also happens to be fast &amp; safe.</p>
<p>That‚Äôs not to say that Rust is the end-all-be-all of software development though. High-level languages thrive for good reasons. Rust‚Äôs domain isn‚Äôt the same and it doesn‚Äôt try to replace them. The Rust domain is the lower level applications and it does not pretend to conquer the world. Don‚Äôt use Rust to replace Python or Node because your productivity will take a hit. At least, for now. Rust lang is evolving and it may come a time that it does make sense to use it in the core domain of managed languages.</p>
	</div><!-- .entry-content -->

	
	<!-- .entry-footer -->

</article></div>
  </body>
</html>
