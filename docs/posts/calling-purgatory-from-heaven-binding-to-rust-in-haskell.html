<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://well-typed.com/blog/2023/03/purgatory/">Original</a>
    <h1>Calling Purgatory from Heaven: Binding to Rust in Haskell</h1>
    
    <div id="readability-page-1" class="page"><div>
        <div>
          <p><a href="https://dl.acm.org/doi/10.1145/317636.317790">Calling hell from heaven and heaven from hell</a> is a classic paper from the previous century, introducing the Haskell foreign function interface (FFI). It describes the facilities that Haskell offers for calling functions written in C (and vice versa). In this blog post, we will consider how to call functions written in <em>Rust</em> instead: not quite hell, but not quite heaven either.</p>
<p>We will make use of two libraries that we wrote to streamline this process: a Haskell-side library called <a href="https://github.com/BeFunctional/haskell-foreign-rust">foreign-rust</a>, and a Rust-side library called <a href="https://github.com/BeFunctional/haskell-rust-ffi">haskell-ffi</a>. We developed these libraries as part of the development of <a href="https://www.be.exchange/">Be</a>, a (smart) contract platform; we are thankful to them for making these libraries open source. That said, this blog post should also be useful for people who do not want to use these libraries, and indeed, we will also show examples of interop that do not rely on them. The source code for the examples discussed in this blog post can be found at <a href="https://github.com/well-typed/blogpost-purgatory">https://github.com/well-typed/blogpost-purgatory</a>.</p>
<!-- more -->
<h2 id="getting-started">Getting started</h2>
<p>Binding to Rust functions from Haskell is not quite as convenient as binding to C functions. The common denominator between Rust and Haskell is C, and so we have to do two things: we have to write a Rust-side wrapper that exposes the functionality we want to bind against as C functions, and then write Haskell-side bindings against these C functions.</p>
<p>Our running example in this blog post will therefore consist of a Rust library which we will call <code>rust-wrapper</code>, and a Haskell library which we will call <code>haskell-wrapper</code>. To get us started, let’s see if we can pass two numbers from Haskell to Rust, add them Rust-side, and then print the result Haskell-side.</p>
<h3 id="rust">Rust</h3>
<p>Create a new Rust crate for our new <code>rust-wrapper</code> library, and then add the following to the <code>Cargo.toml</code> file:</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span>[</span><span>dependencies</span><span>]</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span>haskell-ffi</span><span>.git</span> <span>=</span> <span>&#34;https://github.com/BeFunctional/haskell-rust-ffi.git&#34;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span>haskell-ffi</span><span>.rev</span> <span>=</span> <span>&#34;2bf292e2e56eac8e9fb0fb2e1450cf4a4bd01274&#34;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span>[</span><span>features</span><span>]</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span>capi</span> <span>=</span> <span>[]</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span>[</span><span>package</span><span>.</span><span>metadata</span><span>.</span><span>capi</span><span>.</span><span>library</span><span>]</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span>versioning</span> <span>=</span> <span>false</span></span></code></pre></div>
<p>After declaring the dependency on the <code>haskell-ffi</code> library, the <code>features</code> and <code>package.metadata.capi.library</code> sections are for the benefit of <a href="https://github.com/lu-zero/cargo-c">cargo cbuild</a>; we will see momentarily how to use this tool. First, however, add this function to the library’s <code>lib.rs</code>:</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span>#[</span>no_mangle<span>]</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>extern</span> <span>&#34;C&#34;</span> <span>fn</span> rust_wrapper_add(x<span>:</span> <span>u64</span><span>,</span> y<span>:</span> <span>u64</span>) <span>-&gt;</span> <span>u64</span> <span>{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    x <span>+</span> y</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>The <code>extern &#34;C&#34;</code> directive tells the Rust compiler that this function should use the C calling convention. The <code>no_mangle</code> attribute ensures that the Rust compiler won’t change the name of our function to something unrecognizable, so that we know what the function is called in our Haskell bindings. This does mean that the function name should be unique across any C libraries that we might link against, which is why we will prefix the names of all external functions with <code>rust_wrapper_</code>. (See <a href="https://doc.rust-lang.org/nomicon/ffi.html#calling-rust-code-from-c">Calling Rust code from C</a> from the Rustonomicon for more details.)</p>
<p>Now compile the library with</p>
<pre><code>cargo cbuild</code></pre>
<p>(you might need to install the <a href="https://github.com/lu-zero/cargo-c">cargo-c</a> applet for <code>cargo</code> first.) This will create a bunch of files, but three are of particular interest:</p>
<ul>
<li><p><code>target/&lt;arch&gt;/debug/librust_wrapper.so</code>: this is the shared object that our Haskell application will need to link against.</p></li>
<li><p><code>target/arch&gt;/debug/rust_wrapper.h</code>: this is the C header file that we will need to compile our Haskell-side bindings. For our running example so far, this header will contain</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span>uint64_t</span> rust_wrapper_add<span>(</span><span>uint64_t</span> x<span>,</span> <span>uint64_t</span> y<span>);</span></span></code></pre></div></li>
<li><p><code>target/&lt;arch&gt;/debug/rust_wrapper-uninstalled.pc</code>: this is a <a href="https://people.freedesktop.org/~dbn/pkg-config-guide.html">pkg-config</a> file which contains the C compiler and linker flags (including paths) that we will need Haskell-side to know where the <code>.so</code> and <code>.h</code> files that we just described are.<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a></p></li>
</ul>
<p>Finally, we will need to set two environment variables; the first will ensure that we can find the <code>pkg-config</code> file, and the second ensures that when we <em>run</em> our application (after building and linking it), the <code>.so</code> file can still be found:</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span>export</span> <span>PKG_CONFIG_PATH</span><span>=&lt;</span>path<span>&gt;</span>/rust-wrapper/target/<span>&lt;</span>arch<span>&gt;</span>/debug</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span>export</span> <span>LD_LIBRARY_PATH</span><span>=&lt;</span>path<span>&gt;</span>/rust-wrapper/target/<span>&lt;</span>arch<span>&gt;</span>/debug</span></code></pre></div>
<h3 id="haskell">Haskell</h3>
<p>On the Haskell side, create a new package, and then add this to the <code>library</code> section of the <code>.cabal</code> file:</p>
<pre><code>build-depends: .., foreign-rust
build-tool-depends: c2hs:c2hs
pkgconfig-depends: rust_wrapper-uninstalled</code></pre>
<p>The first declares a dependency on <a href="https://hackage.haskell.org/package/c2hs">c2hs</a>; this is a preprocessor that we will use to write our bindings; the second declares the dependency on the Rust library; <code>cabal</code> will use <code>pkg-config</code> to figure out which compiler and linker flags are required (thereby also figuring out where that Rust library <em>is</em>). While the library is not yet released to Hackage, we’ll need to add the repo to our <code>cabal.project</code> file:</p>
<pre><code>source-repository-package
  type: git
  location: https://github.com/BeFunctional/haskell-foreign-rust.git
  tag: 90b1c210ae4e753c39481a5f3b141b74e6b6d96e</code></pre>
<p>For this simple example we don’t benefit much from <code>c2hs</code>, but will nonetheless use it to bind to our add function, to give us a chance to introduce its basic syntax. (For a detailed discussion of the syntax of <code>c2hs</code>, see the <a href="https://github.com/haskell/c2hs/wiki/User-Guide">c2hs User Guide</a>.)</p>
<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span>module</span> <span>C.GettingStarted</span> (rustWrapperAdd) <span>where</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span>#include &#34;rust_wrapper.h&#34;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span>import</span> <span>Data.Word</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span>{# </span><span>fun</span><span> </span><span>pure</span><span> </span><span>unsafe</span><span> rust_wrapper_add </span><span>as</span><span> rustWrapperAdd</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span>     { </span><span>`Word64&#39;</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span>     , </span><span>`Word64&#39;</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span>     }</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span>  -&gt; </span><span>`Word64&#39;</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span>#}</span></span></code></pre></div>
<p>This declares a function which</p>
<ul>
<li><p>is called <code>rust_wrapper_add</code> C-side, but should be called <code>rustWrapperAdd</code> Haskell-side</p></li>
<li><p>has two arguments, both of type <code>Word64</code></p></li>
<li><p>has a result also of type <code>Word64</code></p></li>
<li><p>is pure: the signature of the function should be</p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span>rustWrapperAdd ::</span> <span>Word64</span> <span>-&gt;</span> <span>Word64</span> <span>-&gt;</span> <span>Word64</span></span></code></pre></div>
<p>rather than</p>
<div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span>rustWrapperAdd ::</span> <span>Word64</span> <span>-&gt;</span> <span>Word64</span> <span>-&gt;</span> <span>IO</span> <span>Word64</span> <span>-- unnecessary</span></span></code></pre></div>
<p>(because calling the function twice with the same inputs will give the same results)</p></li>
<li><p>uses an <a href="https://www.haskell.org/onlinereport/haskell2010/haskellch8.html#x15-1540008.4">unsafe call</a>: unsafe calls can be used for foreign functions that do not call back into the Haskell runtime; this gives the RTS some guarantees which it can take advantage of to make the foreign call more efficient (see also <a href="https://downloads.haskell.org/ghc/latest/docs/users_guide/exts/ffi.html#guaranteed-call-safety">Guaranteed call safety</a> in the ghc manual)</p></li>
</ul>
<p>This should be sufficient; if we now start a repl (<code>cabal repl</code>) and import our module, we should be able to test our function:</p>
<pre><code>ghci&gt; rustWrapperAdd 2 3
5</code></pre>
<h2 id="marshalling-data">Marshalling data</h2>
<p>It is easy enough to ferry individual <code>Word64</code> over and back, but Haskell and Rust are both languages with rich type systems. If we want to transfer more complex values across the language barrier, we have two choices: we can either serialize and deserialize, or we can use <em>pointers</em> to the data. The first option is the easier and less fragile, as it avoids Haskell-side managing of values that live on the Rust-side heap; it is this approach that the <code>haskell-ffi</code> and <code>foreign-rust</code> libraries aim to streamline. We will consider the second option in section <a href="#avoiding-serialization">Avoiding serialization</a>.</p>
<p>For a more realistic example, therefore, we will consider binding against a Rust function that constructs a self-signed <a href="https://docs.rs/x509-cert/latest/x509_cert/certificate/struct.Certificate.html">x509 certificate</a> with corresponding <a href="https://docs.rs/p256/latest/p256/type.SecretKey.html">secret key</a>, given a list of domain names:</p>
<div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span>fn</span> generate_simple_self_signed(alt_names<span>:</span> <span>Vec</span><span>&lt;</span><span>String</span><span>&gt;</span>) <span>-&gt;</span> (Certificate<span>,</span> SecretKey)</span></code></pre></div>
<h3 id="interlude-no-orphans-in-rust">Interlude: (no) orphans in Rust</h3>
<p>Although of course the precise definitions differ, the basic concept of an orphan instance is similar in Haskell and in Rust. An orphan instance is an instance of some type class (or trait) <code>C</code> for some type <code>T</code></p>

<p>or</p>

<p>which is not “bundled with” either the definition of <code>C</code> or the definition of <code>T</code> (where “bundled with” means “same module” in Haskell, and “same package” in Rust). This ensures <em>coherence</em>: it can never happen that we get two different instances in scope (for the same <code>C</code> and <code>T</code>) when we import two different modules.</p>
<p>However, where the introduction of an orphan instance in Haskell is merely a compiler warning, which we can choose to ignore (thereby taking on the responsibility ourselves to ensure coherence), in Rust it is an error: we really cannot introduce an orphan instance.</p>
<p>This can be quite a serious limitation. For example, suppose we want to have a (Rust side) type class for “things we can marshall to Haskell.” If this type class is defined in an external package, and we want to marshall a type defined in a <em>different</em> package, unless there is instance already defined in either of these two packages, we are stuck: we cannot provide an instance ourselves (since it would be an orphan). The <code>haskell-ffi</code> library therefore adopts a workaround, which we will discuss now.</p>
<h3 id="marshalling-in-haskell-ffi">Marshalling in <code>haskell-ffi</code></h3>
<p>Central to the <code>haskell-ffi</code> library is the definition of two traits (type classes), for data that can be marshalled to and from Haskell respectively:</p>
<div id="cb15"><pre><code><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>type</span> Error     <span>=</span> <span>Box</span><span>&lt;</span><span>dyn</span> <span>std::error::</span><span>Error</span> <span>+</span> <span>Send</span> <span>+</span> <span>Sync</span><span>&gt;;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>type</span> Result<span>&lt;</span>T<span>&gt;</span> <span>=</span> <span>core::result::</span><span>Result</span><span>&lt;</span>T<span>,</span> <span>Error</span><span>&gt;;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>trait</span> ToHaskell<span>&lt;</span>Tag<span>&gt;</span> <span>{</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span>fn</span> to_haskell<span>&lt;</span>W<span>:</span> <span>Write</span><span>&gt;</span>(<span>&amp;</span><span>self</span><span>,</span> writer<span>:</span> <span>&amp;</span><span>mut</span> W<span>,</span> tag<span>:</span> PhantomData<span>&lt;</span>Tag<span>&gt;</span>) <span>-&gt;</span> <span>Result</span><span>&lt;</span>()<span>&gt;;</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>trait</span> FromHaskell<span>&lt;</span>Tag<span>&gt;:</span> <span>Sized</span> <span>{</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    <span>fn</span> from_haskell(buf<span>:</span> <span>&amp;</span><span>mut</span> <span>&amp;</span>[<span>u8</span>]<span>,</span> tag<span>:</span> PhantomData<span>&lt;</span>Tag<span>&gt;</span>) <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>Self</span><span>,</span> <span>Error</span><span>&gt;;</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>These are similar to the <a href="https://docs.rs/borsh/latest/borsh/ser/trait.BorshSerialize.html">BorshSerialize</a> and <a href="https://docs.rs/borsh/latest/borsh/de/trait.BorshDeserialize.html">BorshDeserialize</a> traits from the <a href="https://crates.io/crates/borsh">borsh</a> crate (package), and indeed, <code>ToHaskell</code> and <code>FromHaskell</code> have all the standard instances that make it compatible with the <a href="https://borsh.io/">Borsh binary serialization format</a>.</p>
<p>The definition of these two traits might look a bit obscure to a Haskell programmer; a rough Haskell translation might be</p>
<div id="cb16"><pre><code><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span>class</span> <span>ToHaskell</span> tag a <span>where</span> <span>-- illustration only</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span>  toHaskell ::</span> <span>forall</span> w<span>.</span> <span>Write</span> w <span>=&gt;</span> a <span>-&gt;</span> <span>IORef</span> w <span>-&gt;</span> <span>Proxy</span> tag <span>-&gt;</span> <span>IO</span> ()</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span>class</span> <span>Sized</span> a <span>=&gt;</span> <span>FromHaskell</span> tag a <span>where</span> <span>-- illustration only</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span>  fromHaskell ::</span> <span>IORef</span> (<span>Vector</span> <span>Word8</span>) <span>-&gt;</span> <span>Proxy</span> tag <span>-&gt;</span> <span>IO</span> a</span></code></pre></div>
<p>Some points:</p>
<ul>
<li><p>The definition of <code>Error</code> is describing a boxed value of existential type, which is required to satisfy a few instance (aka implement a few traits), most notably <code>std::error::Error</code>; this corresponds nearly 1:1 with <code>SomeException</code> in Haskell:</p>
<div id="cb17"><pre><code><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>SomeException</span> <span>=</span> <span>forall</span> e<span>.</span> <span>Exception</span> e <span>=&gt;</span> <span>SomeException</span> e</span></code></pre></div></li>
<li><p><code>W: Write</code> is known as a <em>trait bound</em> in Rust, and corresponds to ad-hoc polymorphism in Haskell.</p></li>
<li><p>Rust does not really have multi-parameter type classes; the additional <code>Tag</code> parameter is an example of what is (confusingly) called <em>generics</em> in Rust, and corresponds roughly to parametric polymorphism in Haskell (although the two concepts don’t align perfectly).</p></li>
<li><p><code>PhantomData</code> in Rust, like <code>Proxy</code> in Haskell, serves only as a hint to the type checker: here, to determine the type <code>Tag</code>.</p></li>
</ul>
<p>The <code>Tag</code> argument allows us to work around the no-orphans limitation. The <code>haskell-ffi</code> library can introduce instances that are polymorphic in a choice of tag, such as</p>
<div id="cb18"><pre><code><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span>impl</span><span>&lt;</span>Tag<span>,</span> T<span>:</span> ToHaskell<span>&lt;</span>Tag<span>&gt;&gt;</span> ToHaskell<span>&lt;</span>Tag<span>&gt;</span> <span>for</span> <span>Option</span><span>&lt;</span>T<span>&gt;</span></span></code></pre></div>
<p>corresponding to</p>
<div id="cb19"><pre><code><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span>instance</span> <span>ToHaskell</span> tag t <span>=&gt;</span> <span>ToHaskell</span> tag (<span>Maybe</span> t) <span>-- illustration only</span></span></code></pre></div>
<p>but, as we shall see momentarily, we can also introduce additional instances in other libraries (such as our <code>rust-wrapper</code> library), provided that we choose a specific tag.</p>
<h3 id="example-rust">Example: Rust</h3>
<p>Let’s now get back to our example. Recall that we want to bind to a Rust function with this signature:</p>
<div id="cb20"><pre><code><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span>fn</span> generate_simple_self_signed(alt_names<span>:</span> <span>Vec</span><span>&lt;</span><span>String</span><span>&gt;</span>) <span>-&gt;</span> (Certificate<span>,</span> SecretKey)</span></code></pre></div>
<p>To do that, we need to write a wrapper function that we expose as a C function. The wrapper will have <em>two</em> arguments for each argument of the function we are wrapping, as well as two arguments for the result:</p>
<div id="cb21"><pre><code><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span>#[</span>no_mangle<span>]</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>extern</span> <span>&#34;C&#34;</span> <span>fn</span> rust_wrapper_generate_simple_self_signed(</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    alt_names<span>:</span> <span>*</span><span>const</span> <span>u8</span><span>,</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    alt_names_len<span>:</span> <span>usize</span><span>,</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    out<span>:</span> <span>*</span><span>mut</span> <span>u8</span><span>,</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    out_len<span>:</span> <span>&amp;</span><span>mut</span> <span>usize</span><span>,</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>) <span>{</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    <span>..</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>For each <em>argument</em> of the original function, we have a pair of C arguments: the first is a pointer to a buffer containing a serialized form of the argument, and the second is the length of that buffer. For the <em>result</em> of the original function we likewise have a pair of C arguments: the first points to a buffer that the result will be serialized to, and the second must initially contain the size of that buffer, and is overwritten to contain the <em>required</em> size of the buffer when the function returns (so that the caller can try again if the buffer is too small; see <a href="#using-the-c-function">Using the C function</a>, below).</p>
<p>Before we can write the body of the wrapper, we need to choose a <code>Tag</code> to use (see previous section):</p>
<div id="cb22"><pre><code><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>enum</span> RW <span>{}</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>const</span> RW<span>:</span> PhantomData<span>&lt;</span>RW<span>&gt;</span> <span>=</span> PhantomData<span>;</span></span></code></pre></div>
<p><code>RW</code> (for <code>rust-wrapper</code>) is just an empty type; it will only serve as a type-level tag. The body of our wrapper function is now simple:</p>
<div id="cb23"><pre><code><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>extern</span> <span>&#34;C&#34;</span> <span>fn</span> rust_wrapper_generate_simple_self_signed(</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    alt_names<span>:</span> <span>*</span><span>const</span> <span>u8</span><span>,</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    alt_names_len<span>:</span> <span>usize</span><span>,</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    out<span>:</span> <span>*</span><span>mut</span> <span>u8</span><span>,</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    out_len<span>:</span> <span>&amp;</span><span>mut</span> <span>usize</span><span>,</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>) <span>{</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>    <span>let</span> alt_names<span>:</span> <span>Vec</span><span>&lt;</span><span>String</span><span>&gt;</span> <span>=</span> marshall_from_haskell_var(alt_names<span>,</span> alt_names_len<span>,</span> RW)<span>;</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>    <span>let</span> result <span>=</span> generate_simple_self_signed(alt_names)<span>;</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>    marshall_to_haskell_var(<span>&amp;</span>result<span>,</span> out<span>,</span> out_len<span>,</span> RW)<span>;</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>We will discuss the <code>_var</code> suffix in section on <a href="#bounded-size-data">bounded size data</a>.</p>
<h3 id="example-haskell">Example: Haskell</h3>
<p>On the Haskell side, we first have to decide what we want to do with the serialized data we get from Rust. We can try to deserialize it, or we could just leave it in serialized form, relying on Rust-side functions to interact with it. The <code>foreign-rust</code> library helps us with deserialization if we choose to do so, and provides tools for working with serialized data if we choose not to.</p>
<p>For our example it is simplest to just leave the data in serialized form:</p>
<div id="cb24"><pre><code><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span>newtype</span> <span>Certificate</span> <span>=</span> <span>Certificate</span> <span>Strict.ByteString</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> <span>newtype</span> (<span>BorshSize</span>, <span>ToBorsh</span>, <span>FromBorsh</span>)</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> <span>newtype</span> (<span>IsRaw</span>)</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> (<span>Show</span>, <span>Data.Structured.Show</span>, <span>IsString</span>) via <span>AsBase64</span> <span>Certificate</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span>newtype</span> <span>SecretKey</span> <span>=</span> <span>SecretKey</span> (<span>FixedSizeArray</span> <span>32</span> <span>Word8</span>)</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> <span>newtype</span> (<span>BorshSize</span>, <span>BorshMaxSize</span>, <span>ToBorsh</span>, <span>FromBorsh</span>)</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> <span>newtype</span> (<span>IsRaw</span>)</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> (<span>Show</span>, <span>Data.Structured.Show</span>, <span>IsString</span>) via <span>AsBase64</span> <span>SecretKey</span></span></code></pre></div>
<p>Some comments:</p>
<ul>
<li><p><code>BorshSize</code>, <code>ToBorsh</code>, <code>FromBorsh</code> and <code>BorshMaxSize</code> come from the Haskell <a href="https://hackage.haskell.org/package/borsh">borsh</a> library. We will see the use of <code>BorshSize</code> and <code>BorshMaxSize</code> when we discuss <a href="#bounded-size-data">bounded size data</a>.</p></li>
<li><p><code>IsRaw</code> is a type class from the <code>foreign-rust</code> library capturing “raw” values: values that are essentially just bytestrings:</p>
<div id="cb25"><pre><code><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span>class</span> <span>IsRaw</span> a <span>where</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span>  rawSize ::</span> a <span>-&gt;</span> <span>Word32</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span>  toRaw   ::</span> a <span>-&gt;</span> <span>Lazy.ByteString</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span>  fromRaw ::</span> <span>Lazy.ByteString</span> <span>-&gt;</span> <span>Either</span> <span>String</span> a</span></code></pre></div></li>
<li><p><code>FixedSizeArray</code> is a datatype from the Haskell <code>borsh</code> package which corresponds to bytestrings of a known, static, length; <code>FixedSizeArray 32   Word8</code> is a precise analogue of <code>[u8; 32]</code> in Rust.</p></li>
<li><p><code>Data.Structured.Show</code>, from <code>foreign-rust</code>, is like <code>Show</code> from the prelude, but producing a structured value, which can be pretty-printed a bit nicer. It’s similar to the <code>PrettyVal</code> class from the <a href="https://hackage.haskell.org/package/pretty-show">pretty-show</a> package, but unlike <code>PrettyVal</code> (and like <code>Show</code> from the prelude), its pretty-printed values are valid Haskell.</p></li>
<li><p>Finally, <code>AsBase64</code> is a newtype that can be used to conveniently derive <code>Show</code>, <code>Data.Structured.Show</code> and <code>IsString</code> instances, all using a base-64 encoding. Similarly <code>foreign-haskell</code> also provides <code>AsBase16</code>, <code>AsBase58</code>, and <code>AsDecimal</code> (list of decimal values).</p></li>
</ul>
<p>With our datatypes defined, we can now bind our function:</p>
<div id="cb26"><pre><code><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span>{# </span><span>fun</span><span> </span><span>unsafe</span><span> rust_wrapper_generate_simple_self_signed </span><span>as</span><span> rustWrapperSelfSigned</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span>     { toBorshVar*  </span><span>`[Text]&#39;</span><span>&amp;</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span>     , getVarBuffer </span><span>`Buffer (Certificate, SecretKey)&#39;</span><span>&amp;</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span>     }</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span>  -&gt; </span><span>`()&#39;</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span>#}</span></span></code></pre></div>
<p>This is not really any more difficult than the function which just passed numbers around: <code>c2hs</code> provides explicit support for arguments that correspond to a <em>single</em> argument Haskell-side and <em>two</em> arguments C-side (that’s what the ampersand <code>&amp;</code> means), and it allows us to define specific marshalling functions; we use <code>toBorshVar</code> and <code>getVarBuffer</code>, both from <code>foreign-rust</code>. The syntax is a bit arcane, but the good news is that all functions you wrap will look very similar.</p>
<h3 id="using-the-c-function">Using the C function</h3>
<p>The signature of the Haskell function that <code>c2hs</code> made for us is not quite as convenient as we might like:</p>
<div id="cb27"><pre><code><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span>rustWrapperSelfSigned ::</span> [<span>Text</span>] <span>-&gt;</span> <span>Buffer</span> (<span>Certificate</span>, <span>SecretKey</span>) <span>-&gt;</span> <span>IO</span> ()</span></code></pre></div>
<p>When we discussed <a href="#example-rust">the Rust-side function</a>, we mentioned that it expects a buffer to write its output to, along with the size of that buffer. Since we are trying to avoid managing memory allocated Rust-side in Haskell, or vice versa, we will create that buffer Haskell side; but what size buffer should we allocate? The generated function just punts on this question, and doesn’t allocate a buffer at all.</p>
<p>But not to worry, <code>foreign-rust</code> has us covered. The main function it provides here is <code>withBorshVarBuffer</code>:</p>
<div id="cb28"><pre><code><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span>withBorshVarBuffer ::</span> (<span>FromBorsh</span> a, <span>..</span>) <span>=&gt;</span> (<span>Buffer</span> a <span>-&gt;</span> <span>IO</span> ()) <span>-&gt;</span> <span>IO</span> a</span></code></pre></div>
<p>It will allocate a 1kB buffer and then call the function; if it turns out this buffer is not large enough, the Rust-side function will tell it what the right size buffer is, and so it will just try once more with a larger buffer. We can use this to provide a <code>selfSigned</code> function with the signature we’d expect:</p>
<div id="cb29"><pre><code><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span>selfSigned ::</span> [<span>Text</span>] <span>-&gt;</span> <span>IO</span> (<span>Certificate</span>, <span>SecretKey</span>)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>selfSigned <span>=</span> withBorshVarBuffer <span>.</span> rustWrapperSelfSigned</span></code></pre></div>
<p>We can try this now in <code>ghci</code>:</p>
<pre><code>ghci&gt; selfSigned [&#34;example.com&#34;]
(&#34;MIIB..uZ04&#34;,&#34;mjAEvFcSD1DD8ZTf9hCSbCJjA259wI+rmlXQA5JU8Oc=&#34;)</code></pre>
<h2 id="working-with-foreign-values">Working with foreign values</h2>
<p>We now have a Haskell side representation of the Rust <code>Certificate</code> type but we can’t yet do much with it; in this section we will therefore explore this a bit more.</p>
<h3 id="binding-another-function">Binding another function</h3>
<p>Let’s bind another function, which returns the certificate’s “subject.” Rust-side, we can define</p>
<div id="cb31"><pre><code><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span>#[</span>no_mangle<span>]</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>extern</span> <span>&#34;C&#34;</span> <span>fn</span> rust_wrapper_get_certificate_subject(</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    cert<span>:</span> <span>*</span><span>const</span> <span>u8</span><span>,</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    cert_len<span>:</span> <span>usize</span><span>,</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>    out<span>:</span> <span>*</span><span>mut</span> <span>u8</span><span>,</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>    out_len<span>:</span> <span>&amp;</span><span>mut</span> <span>usize</span><span>,</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>) <span>{</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>    <span>let</span> cert<span>:</span> Certificate <span>=</span> marshall_from_haskell_var(cert<span>,</span> cert_len<span>,</span> RW)<span>;</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>    <span>let</span> result <span>=</span> <span>format!</span>(<span>&#34;{}&#34;</span><span>,</span> cert<span>.</span>tbs_certificate<span>.</span>subject)<span>;</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>    marshall_to_haskell_var(<span>&amp;</span>result<span>,</span> out<span>,</span> out_len<span>,</span> RW)<span>;</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>This function has exactly the same shape as the previous we wrote (indeed, an important goal of the <code>haskell-ffi</code>/<code>foreign-rust</code> library pair is precisely to make this kind of work as “boring” as possible). The <code>c2hs</code> declaration Haskell-side is also very similar:</p>
<div id="cb32"><pre><code><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span>{# </span><span>fun</span><span> </span><span>unsafe</span><span> rust_wrapper_get_certificate_subject </span><span>as</span><span> rustWrapperCertificateSubject</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span>     { toBorshVar*  </span><span>`Certificate&#39;</span><span>&amp;</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span>     , getVarBuffer </span><span>`Buffer Text&#39;</span><span>&amp;</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span>     }</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span>  -&gt; </span><span>`()&#39;</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span>#}</span></span></code></pre></div>
<p>Unlike <code>selfSigned</code>, however, which really must live in IO (each time the function is called, it produces a different certificate), this function is morally pure:</p>
<div id="cb33"><pre><code><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span>certificateSubject ::</span> <span>Certificate</span> <span>-&gt;</span> <span>Text</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>certificateSubject <span>=</span> withPureBorshVarBuffer <span>.</span> rustWrapperCertificateSubject</span></code></pre></div>
<p>We can try it out:</p>
<pre><code>ghci&gt; (cert, pkey) &lt;- selfSigned [&#34;example.com&#34;]
ghci&gt; certificateSubject cert
&#34;CN=rcgen self signed cert&#34;</code></pre>
<h3 id="using-the-isstring-instance">Using the <code>IsString</code> instance</h3>
<p>We mentioned above that <code>foreign-rust</code> introduces <code>Data.Structured.Show</code>, to replace <code>PrettyVal</code> from <code>pretty-show</code>, in order to ensure that pretty-printed values are still valid Haskell. Indeed, we derived <code>IsString</code> for <code>Certificate</code> above, which means that we can denote Rust-side values in our Haskell code:</p>
<pre><code>ghci&gt; certificateSubject &#34;MIIB..uZ04&#34; -- same string that we got above
&#34;CN=rcgen self signed cert&#34;</code></pre>
<p>This can be very useful when experimenting, in (regression) tests, etc.</p>
<h3 id="annotations">Annotations</h3>
<p>It’s nice that we can show and even denote Rust-side values in Haskell, but a long base-64 string is not the most informative. To make things like debugging a little easier, <code>foreign-rust</code> therefore provides a way to annotate values:</p>
<div id="cb36"><pre><code><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span>class</span> <span>CanAnnotate</span> a <span>where</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>  <span>type</span> <span>Annotated</span><span> a ::</span> <span>Type</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span>  annotate       ::</span> a <span>-&gt;</span> <span>Annotated</span> a</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span>  dropAnnotation ::</span> <span>Annotated</span> a <span>-&gt;</span> a</span></code></pre></div>
<p>In many (but by no means all) cases, an annotated form of a value just pairs that value with some additional value; we can use this for <code>Certificate</code>:</p>
<div id="cb37"><pre><code><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span>deriving</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>  via <span>PairWithAnnotation</span> <span>Certificate</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>  <span>instance</span> <span>CanAnnotate</span> <span>Certificate</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a><span>type</span> <span>instance</span> <span>Annotation</span> <span>Certificate</span> <span>=</span> <span>Text</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a><span>instance</span> <span>ComputeAnnotation</span> <span>Certificate</span> <span>where</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>  computeAnnotation <span>=</span> certificateSubject</span></code></pre></div>
<p>Trying it out:</p>
<pre><code>ghci&gt; (cert, pkey) &lt;- selfSigned [&#34;example.com&#34;]
ghci&gt; annotate cert
WithAnnotation {value = &#34;MIIB..uZ04&#34;, annotation = &#34;CN=rcgen self signed cert&#34;}</code></pre>
<p>or we can use <code>Data.Structured</code> to make this a little cleaner:</p>
<pre><code>ghci&gt; Data.Structured.print $ annotate cert
WithAnnotation {
  value = &#34;MIIB..uZ04&#34;
, annotation = &#34;CN=rcgen self signed cert&#34;
}</code></pre>
<p>Annotations are designed to be “transitive” (and there is support for generically deriving <code>CanAnnotate</code> for your own types if you just want to transitively get all annotations). As a simple example, here’s what we get if we annotate something of type <code>[Maybe Certificate]</code>:</p>
<pre><code>ghci&gt; Data.Structured.print $ annotate [Just cert]
WithAnnotation {
  value = [
      Just
        WithAnnotation {
          value = &#34;MIIB..uZ04&#34;
        , annotation = &#34;CN=rcgen self signed cert&#34;
        }
    ]
, annotation = Length 1
}</code></pre>
<p>This can be very helpful during debugging (there is also <code>dropAnnotation</code> which goes in the opposite direction).</p>
<h2 id="fixed-size-data">Fixed size data</h2>
<p>When we <a href="#using-the-c-function">discussed binding <code>rust_wrapper_self_signed</code></a>, we said that <code>withBorshVarBuffer</code> will allocate an initial buffer of a certain size, then call the Rust function, hoping the buffer will be big enough, and then call the Rust function a <em>second</em> time if it turns out the buffer was too small after all.</p>
<p>If we know ahead of time how big the value will be, however, we can do better. For example, we know that the size of (this type of) a secret key is always 32 bytes; indeed, we said so right in the type:</p>
<div id="cb41"><pre><code><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span>newtype</span> <span>SecretKey</span> <span>=</span> <span>SecretKey</span> (<span>FixedSizeArray</span> <span>32</span> <span>Word8</span>)</span></code></pre></div>
<h3 id="rust-1">Rust</h3>
<p>Let’s consider binding to a Rust function which constructs an example key, generated from a PRNG with specified seed:</p>
<div id="cb42"><pre><code><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span>#[</span>no_mangle<span>]</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>extern</span> <span>&#34;C&#34;</span> <span>fn</span> rust_wrapper_example_key(seed<span>:</span> <span>u64</span><span>,</span> out<span>:</span> <span>*</span><span>mut</span> <span>u8</span><span>,</span> out_len<span>:</span> <span>usize</span>) <span>{</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>    <span>let</span> <span>mut</span> prng<span>:</span> StdRng <span>=</span> <span>StdRng::</span>seed_from_u64(seed)<span>;</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>    <span>let</span> result<span>:</span> SecretKey <span>=</span> <span>SecretKey::</span>random(<span>&amp;</span><span>mut</span> prng)<span>;</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>    marshall_to_haskell_fixed(<span>&amp;</span>result<span>,</span> out<span>,</span> out_len<span>,</span> RW)<span>;</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>The seed is a simple C value so no need for any serialization. This is not true for the result of the function, but unlike before, the size of the output is statically known. This means we can use <code>marshall_to_haskell_fixed</code> Rust-side, instead of <code>marshall_to_haskell_var</code>; usage is almost identical, except that the <code>out_len</code> is now a simple <code>usize</code>, rather than a pointer <em>to</em> a <code>usize</code>: the <code>haskell-ffi</code> Rust code will verify the size of the buffer allocated Haskell-side, and panic if it’s not of the right size (this would be a bug), but there is no need for it to communicate a new size back to the Haskell code.</p>
<p>This depends on an additional trait which provides the size:</p>
<div id="cb43"><pre><code><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>trait</span> HaskellSize<span>&lt;</span>Tag<span>&gt;</span> <span>{</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>    <span>fn</span> haskell_size(tag<span>:</span> PhantomData<span>&lt;</span>Tag<span>&gt;</span>) <span>-&gt;</span> <span>usize</span><span>;</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>This class comes with all the instances we’d expect for the Borsh serialization format; for example, we have</p>
<div id="cb44"><pre><code><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span>impl</span><span>&lt;</span>Tag<span>,</span> T<span>:</span> HaskellSize<span>&lt;</span>Tag<span>&gt;,</span> <span>const</span> N<span>:</span> <span>usize</span><span>&gt;</span> HaskellSize<span>&lt;</span>Tag<span>&gt;</span> <span>for</span> [T<span>;</span> N] <span>{</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>    <span>fn</span> haskell_size(tag<span>:</span> PhantomData<span>&lt;</span>Tag<span>&gt;</span>) <span>-&gt;</span> <span>usize</span> <span>{</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>        <span>T::</span>haskell_size(tag) <span>*</span> N</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>(This instance uses what is known as “const generics” in Rust parlance; in the Haskell world that <code>const N: usize</code> parameter would correspond to a <code>KnownNat n</code> constraint.) There is also a macro available you can use to derive <code>HaskellSize</code> for your own structs (enums do not have a statically known size).</p>
<h3 id="haskell-1">Haskell</h3>
<p>The <code>c2hs</code> declaration of this function looks like this:</p>
<div id="cb45"><pre><code><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span>{# </span><span>fun</span><span> </span><span>pure</span><span> </span><span>unsafe</span><span> rust_wrapper_example_key </span><span>as</span><span> exampleKey</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span>     {                   </span><span>`Word64&#39;</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span>     , allocFixedBuffer- </span><span>`SecretKey&#39;</span><span>&amp; fromBorsh*</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span>     }</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a><span>  -&gt; </span><span>`()&#39;</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a><span>#}</span></span></code></pre></div>
<p>Since we are sure we only need to call the Rust function once (with an appropriately size buffer), we can do everything right within the <code>c2hs</code> incantation: <code>allocFixedBuffer</code> will allocate the appropriate buffer before calling the function, and <code>fromBorsh</code> will get the value from the buffer afterwards. Moreover, since this function is now morally pure, we can use the <code>c2hs</code> keyword for pure functions, and the signature of the function constructed by <code>c2hs</code> is exactly what we’d expect, with no further wrapping required:</p>
<div id="cb46"><pre><code><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span>exampleKey ::</span> <span>Word64</span> <span>-&gt;</span> <span>SecretKey</span></span></code></pre></div>
<h3 id="bounded-size-data">Bounded size data</h3>
<p>For the case where there is no fixed size, but there <em>is</em> a bound on the size, we have <code>marshall_to_haskell_max</code> on the Rust side (depending on a <code>HaskellMaxSize</code> trait) and <code>allocMaxBuffer</code> on the Haskell side (depending on a <code>BorshMaxSize</code> class). The most important use case for this is Rust’s <code>Option</code> type, corresponding to <code>Maybe</code> in Haskell. For example, here is a Rust function which deserializes a secret key in PEM format:</p>
<div id="cb47"><pre><code><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span>#[</span>no_mangle<span>]</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>extern</span> <span>&#34;C&#34;</span> <span>fn</span> rust_wrapper_key_from_pem(</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    key<span>:</span> <span>*</span><span>const</span> <span>u8</span><span>,</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>    key_len<span>:</span> <span>usize</span><span>,</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>    out<span>:</span> <span>*</span><span>mut</span> <span>u8</span><span>,</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>    out_len<span>:</span> <span>usize</span><span>,</span></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>) <span>{</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>    <span>let</span> key<span>:</span> <span>String</span> <span>=</span> marshall_from_haskell_var(key<span>,</span> key_len<span>,</span> RW)<span>;</span></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>    <span>let</span> result<span>:</span> <span>Option</span><span>&lt;</span>SecretKey<span>&gt;</span> <span>=</span> <span>match</span> <span>elliptic_curve::SecretKey::</span>from_sec1_pem(<span>&amp;</span>key) <span>{</span></span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>        <span>Ok</span>(key) <span>=&gt;</span> <span>Some</span>(key)<span>,</span></span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a>        <span>Err</span>(<span>elliptic_curve::</span><span>Error</span>) <span>=&gt;</span> <span>None</span><span>,</span></span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a>    <span>};</span></span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a>    marshall_to_haskell_max(<span>&amp;</span>result<span>,</span> out<span>,</span> out_len<span>,</span> RW)<span>;</span></span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>and here is the corresponding <code>c2hs</code> binding:</p>
<div id="cb48"><pre><code><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span>{# </span><span>fun</span><span> </span><span>pure</span><span> </span><span>unsafe</span><span> rust_wrapper_key_from_pem </span><span>as</span><span> fromPem</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span>     { toBorshVar*     </span><span>`Text&#39;</span><span>&amp;</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span>     , allocMaxBuffer- </span><span>`Maybe SecretKey&#39;</span><span>&amp; fromBorsh*</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a><span>     }</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a><span>  -&gt; </span><span>`()&#39;</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a><span>#}</span></span></code></pre></div>
<p>As before, no additional wrapping is necessary Haskell-side; the signature of the function constructed by <code>c2hs</code> is</p>
<div id="cb49"><pre><code><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span>fromPem ::</span> <span>Text</span> <span>-&gt;</span> <span>Maybe</span> <span>SecretKey</span></span></code></pre></div>
<h2 id="composite-types">Composite types</h2>
<p>Suppose we have this datatype Rust-side:</p>
<div id="cb50"><pre><code><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span>#[</span>derive<span>(</span><span>serde::</span>Serialize<span>,</span> <span>serde::</span>Deserialize<span>,</span> BorshSerialize<span>,</span> BorshDeserialize<span>,</span> HaskellSize<span>)]</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>struct</span> Color <span>{</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>    r<span>:</span> <span>f64</span><span>,</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>    g<span>:</span> <span>f64</span><span>,</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>    b<span>:</span> <span>f64</span><span>,</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>We can piggyback on the <code>BorshSerialize</code> and <code>BorshDeserialize</code> instances derived by macros from the <a href="https://borsh.io/">borsh</a> crate to define our <code>FromHaskell</code> and <code>ToHaskell</code> instances:</p>
<div id="cb51"><pre><code><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span>impl</span><span>&lt;</span>Tag<span>&gt;</span> ToHaskell<span>&lt;</span>Tag<span>&gt;</span> <span>for</span> Color <span>{</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>    <span>fn</span> to_haskell<span>&lt;</span>W<span>:</span> <span>Write</span><span>&gt;</span>(<span>&amp;</span><span>self</span><span>,</span> writer<span>:</span> <span>&amp;</span><span>mut</span> W<span>,</span> _tag<span>:</span> PhantomData<span>&lt;</span>Tag<span>&gt;</span>) <span>-&gt;</span> <span>Result</span><span>&lt;</span>()<span>&gt;</span> <span>{</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>        <span>self</span><span>.</span>serialize(writer)<span>?;</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>        <span>Ok</span>(())</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a><span>impl</span><span>&lt;</span>Tag<span>&gt;</span> FromHaskell<span>&lt;</span>Tag<span>&gt;</span> <span>for</span> Color <span>{</span></span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>    <span>fn</span> from_haskell(buf<span>:</span> <span>&amp;</span><span>mut</span> <span>&amp;</span>[<span>u8</span>]<span>,</span> _tag<span>:</span> PhantomData<span>&lt;</span>Tag<span>&gt;</span>) <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>Self</span><span>&gt;</span> <span>{</span></span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a>        <span>let</span> x <span>=</span> <span>Color::</span>deserialize(buf)<span>?;</span></span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a>        <span>Ok</span>(x)</span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Here is a simple function that constructs the “red” color:</p>
<div id="cb52"><pre><code><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span>#[</span>no_mangle<span>]</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>extern</span> <span>&#34;C&#34;</span> <span>fn</span> rust_wrapper_red(out<span>:</span> <span>*</span><span>mut</span> <span>u8</span><span>,</span> out_len<span>:</span> <span>usize</span>) <span>{</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>    <span>let</span> result <span>=</span> Color <span>{</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>        r<span>:</span> <span>1.0</span><span>,</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>        g<span>:</span> <span>0.0</span><span>,</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>        b<span>:</span> <span>0.0</span><span>,</span></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>    <span>};</span></span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>    marshall_to_haskell_fixed(<span>&amp;</span>result<span>,</span> out<span>,</span> out_len<span>,</span> RW)<span>;</span></span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>We now have two choices how we represent this datatype Haskell-side: we can represent it by a proper Haskell value, or we can leave the Haskell-side representation opaque. We will consider these separately.</p>
<h3 id="structured-haskell-representation">Structured Haskell representation</h3>
<p>The cleanest representation of this datatype is of course the corresponding Haskell datatype</p>
<div id="cb53"><pre><code><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>Color</span> <span>=</span> <span>Color</span> {<span> r ::</span> <span>Double</span>,<span> g ::</span> <span>Double</span>,<span> b ::</span> <span>Double</span> }</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> stock (<span>Show</span>, <span>GHC.Generic</span>)</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> anyclass (<span>SOP.Generic</span>, <span>SOP.HasDatatypeInfo</span>)</span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> anyclass (<span>Data.Structured.Show</span>)</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> <span>CanAnnotate</span> via <span>NoAnnotation</span> <span>Color</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> (<span>BorshSize</span>, <span>ToBorsh</span>, <span>FromBorsh</span>) via <span>AsStruct</span> <span>Color</span></span></code></pre></div>
<p>After we have derived the necessary instances, interacting with Rust is trivial; for example, here’s how we can bind the <code>red</code> function:</p>
<div id="cb54"><pre><code><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span>{# </span><span>fun</span><span> </span><span>pure</span><span> </span><span>unsafe</span><span> rust_wrapper_red </span><span>as</span><span> red</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span>     { allocFixedBuffer- </span><span>`Color&#39;</span><span>&amp; fromBorsh*</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a><span>     }</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a><span>  -&gt; </span><span>`()&#39;</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a><span>#}</span></span></code></pre></div>
<p>Nothing else to do.</p>
<pre><code>ghci&gt; red
Color {r = 1.0, g = 0.0, b = 0.0}</code></pre>
<h3 id="opaque-haskell-representation">Opaque Haskell representation</h3>
<p>However, in some cases we don’t want to try and parse the value Haskell-side; perhaps it’s just unnecessarily difficult, or perhaps we consider the exact serialized form of the Rust value an implementation detail of the Rust code. Perhaps we don’t even <em>have</em> a Haskell-side representation, and all we have is a pointer to a value on the Rust heap (see section <a href="#avoiding-serialization">Avoiding serialization</a>).</p>
<p>For example, we might represent <code>Color</code> as<a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<div id="cb56"><pre><code><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span>newtype</span> <span>Color</span> <span>=</span> <span>Color</span> (<span>FixedSizeArray</span> <span>24</span> <span>Word8</span>)</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> <span>newtype</span> (<span>BorshSize</span>, <span>ToBorsh</span>, <span>FromBorsh</span>)</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> <span>newtype</span> (<span>IsRaw</span>)</span></code></pre></div>
<p>Even with this representation, however, we might still prefer a more informative <code>Show</code> instance. The final trick that <code>foreign-rust</code> has up its sleeve is support for “Rust side JSON serialization/deserialization.” This works as follows. First, we define functions Rust-side that convert a value to and from JSON. In most cases, this is easy, because we can derive <a href="https://crates.io/crates/serde">serde</a> <code>Serialize</code> and <code>Deserialize</code> instances, and then use <a href="https://crates.io/crates/serde_json">serde_json</a>:<a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<div id="cb57"><pre><code><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span>#[</span>no_mangle<span>]</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>extern</span> <span>&#34;C&#34;</span> <span>fn</span> rust_wrapper_color_from_json(</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>    json<span>:</span> <span>*</span><span>const</span> <span>u8</span><span>,</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>    json_len<span>:</span> <span>usize</span><span>,</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>    out<span>:</span> <span>*</span><span>mut</span> <span>u8</span><span>,</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>    out_len<span>:</span> <span>&amp;</span><span>mut</span> <span>usize</span><span>,</span></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>) <span>{</span></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>    <span>let</span> json<span>:</span> <span>String</span> <span>=</span> marshall_from_haskell_var(json<span>,</span> json_len<span>,</span> RW)<span>;</span></span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a>    <span>let</span> result<span>:</span> <span>core::result::</span><span>Result</span><span>&lt;</span>Color<span>,</span> <span>serde_json::</span><span>Error</span><span>&gt;</span> <span>=</span> <span>serde_json::</span>from_str(<span>&amp;</span>json)<span>;</span></span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a>    marshall_result_to_haskell_var(<span>&amp;</span>result<span>,</span> out<span>,</span> out_len<span>,</span> RW)<span>;</span></span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-13"><a href="#cb57-13" aria-hidden="true" tabindex="-1"></a><span>#[</span>no_mangle<span>]</span></span>
<span id="cb57-14"><a href="#cb57-14" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>extern</span> <span>&#34;C&#34;</span> <span>fn</span> rust_wrapper_color_to_json(</span>
<span id="cb57-15"><a href="#cb57-15" aria-hidden="true" tabindex="-1"></a>    color<span>:</span> <span>*</span><span>const</span> <span>u8</span><span>,</span></span>
<span id="cb57-16"><a href="#cb57-16" aria-hidden="true" tabindex="-1"></a>    color_len<span>:</span> <span>usize</span><span>,</span></span>
<span id="cb57-17"><a href="#cb57-17" aria-hidden="true" tabindex="-1"></a>    out<span>:</span> <span>*</span><span>mut</span> <span>u8</span><span>,</span></span>
<span id="cb57-18"><a href="#cb57-18" aria-hidden="true" tabindex="-1"></a>    out_len<span>:</span> <span>&amp;</span><span>mut</span> <span>usize</span><span>,</span></span>
<span id="cb57-19"><a href="#cb57-19" aria-hidden="true" tabindex="-1"></a>) <span>{</span></span>
<span id="cb57-20"><a href="#cb57-20" aria-hidden="true" tabindex="-1"></a>    <span>let</span> color<span>:</span> Color <span>=</span> marshall_from_haskell_var(color<span>,</span> color_len<span>,</span> RW)<span>;</span></span>
<span id="cb57-21"><a href="#cb57-21" aria-hidden="true" tabindex="-1"></a>    <span>let</span> json<span>:</span> <span>String</span> <span>=</span> <span>serde_json::</span>to_string(<span>&amp;</span>color)<span>.</span>unwrap()<span>;</span></span>
<span id="cb57-22"><a href="#cb57-22" aria-hidden="true" tabindex="-1"></a>    marshall_to_haskell_var(<span>&amp;</span>json<span>,</span> out<span>,</span> out_len<span>,</span> RW)<span>;</span></span>
<span id="cb57-23"><a href="#cb57-23" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Binding to these functions follows the now-familiar pattern:</p>
<div id="cb58"><pre><code><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span>{# </span><span>fun</span><span> </span><span>unsafe</span><span> rust_wrapper_color_from_json </span><span>as</span><span> rustWrapperColorFromJSON</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a><span>     { toBorshVar*  </span><span>`Text&#39;</span><span>&amp;</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a><span>     , getVarBuffer </span><span>`Buffer (Either Text Color)&#39;</span><span>&amp;</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a><span>     }</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a><span>  -&gt; </span><span>`()&#39;</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a><span>#}</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a><span>{# </span><span>fun</span><span> </span><span>unsafe</span><span> rust_wrapper_color_to_json </span><span>as</span><span> rustWrapperColorToJSON</span></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a><span>     { toBorshFixed* </span><span>`Color&#39;</span><span>&amp;</span></span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a><span>     , getVarBuffer  </span><span>`Buffer Text&#39;</span><span>&amp;</span></span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a><span>     }</span></span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a><span>  -&gt; </span><span>`()&#39;</span></span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a><span>#}</span></span></code></pre></div>
<p>with corresponding wrappers:</p>
<div id="cb59"><pre><code><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span>colorToJSON ::</span> <span>Color</span> <span>-&gt;</span> <span>JSON</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>colorToJSON <span>=</span> withPureBorshVarBuffer <span>.</span> rustWrapperColorToJSON</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a><span>colorFromJSON ::</span> <span>HasCallStack</span> <span>=&gt;</span> <span>JSON</span> <span>-&gt;</span> <span>Either</span> <span>Failure</span> <span>Color</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>colorFromJSON <span>=</span> first mkFailure <span>.</span> withPureBorshVarBuffer <span>.</span> rustWrapperColorFromJSON</span></code></pre></div>
<p>where <code>JSON</code> is a newtype wrapper around a lazy bytestring, and <code>Failure</code> pairs a <code>Text</code> error message with a <code>CallStack</code>. With these functions defined, we can provide instances for <code>ToJSON</code> and <code>FromJSON</code> instances from <code>Foreign.Rust.External.JSON</code>:</p>
<div id="cb60"><pre><code><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span>instance</span> <span>External.ToJSON</span> <span>Color</span> <span>where</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>  toJSON <span>=</span> colorToJSON</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a><span>instance</span> <span>External.FromJSON</span> <span>Color</span> <span>where</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>  fromJSON <span>=</span> colorFromJSON</span></code></pre></div>
<p>This gives us two things: we can, if we wish, derive standard <a href="https://hackage.haskell.org/package/aeson">aeson</a> <code>FromJSON</code> and <code>ToJSON</code> instances; but we can also use JSON in our <code>Show</code> instance:</p>
<div id="cb61"><pre><code><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span>deriving</span> via <span>UseExternalJSON</span> <span>Color</span> <span>instance</span> <span>Aeson.ToJSON</span>   <span>Color</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a><span>deriving</span> via <span>UseExternalJSON</span> <span>Color</span> <span>instance</span> <span>Aeson.FromJSON</span> <span>Color</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a><span>deriving</span> via <span>AsJSON</span> <span>Color</span> <span>instance</span> <span>Show</span>                 <span>Color</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a><span>deriving</span> via <span>AsJSON</span> <span>Color</span> <span>instance</span> <span>Data.Structured.Show</span> <span>Color</span></span></code></pre></div>
<p>Trying it out:</p>
<pre><code>ghci&gt; red
asJSON @Color
  [aesonQQ|
    {
      &#34;b&#34;: 0.0
    , &#34;g&#34;: 0.0
    , &#34;r&#34;: 1.0
    }
  |]</code></pre>
<p>As mentioned above, the library always attempts to ensure that <code>Show</code> produces valid Haskell expressions. If we are using JSON, it does this by using the <a href="https://hackage.haskell.org/package/aeson-2.1.2.1/docs/Data-Aeson-QQ-Simple.html#v:aesonQQ">aesonQQ</a> quasi-quoter, along with a wrapper and a type annotation, to avoid ambiguous type errors.</p>
<h2 id="avoiding-serialization">Avoiding serialization</h2>
<p>Finally, we will consider when we don’t want to use serialization to transfer values between Haskell and Rust (because it’s too expensive), or we <em>can’t</em> use it (perhaps it’s a value that cannot be serialized). For example, suppose we have this Rust-side type of handles:</p>
<div id="cb63"><pre><code><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>struct</span> Handle(<span>usize</span>)<span>;</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a><span>impl</span> <span>Drop</span> <span>for</span> Handle</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>fn</span> new_handle() <span>-&gt;</span> Handle</span></code></pre></div>
<p>We can expose C functions in our Rust code that allocate a handle, query a handle’s ID, and free a handle:</p>
<div id="cb64"><pre><code><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span>#[</span>no_mangle<span>]</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>extern</span> <span>&#34;C&#34;</span> <span>fn</span> rust_wrapper_new_handle() <span>-&gt;</span> <span>*</span><span>mut</span> Handle <span>{</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>    <span>let</span> handle<span>:</span> <span>Box</span><span>&lt;</span>Handle<span>&gt;</span> <span>=</span> <span>Box</span><span>::</span>new(new_handle())<span>;</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>    <span>Box</span><span>::</span>into_raw(handle)</span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a><span>#[</span>no_mangle<span>]</span></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>extern</span> <span>&#34;C&#34;</span> <span>fn</span> rust_wrapper_handle_id(handle<span>:</span> <span>*</span><span>mut</span> Handle) <span>-&gt;</span> <span>usize</span> <span>{</span></span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>    <span>let</span> handle<span>:</span> <span>&amp;</span>Handle <span>=</span> <span>unsafe</span> <span>{</span> <span>&amp;*</span>handle <span>};</span></span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a>    handle<span>.</span><span>0</span></span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a><span>#[</span>no_mangle<span>]</span></span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>extern</span> <span>&#34;C&#34;</span> <span>fn</span> rust_wrapper_free_handle(handle<span>:</span> <span>*</span><span>mut</span> Handle) <span>{</span></span>
<span id="cb64-15"><a href="#cb64-15" aria-hidden="true" tabindex="-1"></a>    <span>let</span> _handle<span>:</span> <span>Box</span><span>&lt;</span>Handle<span>&gt;</span> <span>=</span> <span>unsafe</span> <span>{</span> <span>Box</span><span>::</span>from_raw(handle) <span>};</span></span>
<span id="cb64-16"><a href="#cb64-16" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>On the Haskell side, we can use <code>c2hs</code> to create a <code>newtype</code> around a pointer to a handle, expose C functions that allocate a handle and query its ID, and use <code>rust_wrapper_free_handle</code> as the finalizer (called by the garbage collector):</p>
<div id="cb65"><pre><code><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span>{#</span><span>pointer</span><span> *</span><span>Handle</span><span> </span><span>foreign</span><span> finalizer rust_wrapper_free_handle </span><span>newtype</span><span> #}</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a><span>{# </span><span>fun</span><span> </span><span>unsafe</span><span> rust_wrapper_new_handle </span><span>as</span><span> newHandle</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a><span>      {</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a><span>      }</span></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a><span>   -&gt; </span><span>`Handle&#39;</span></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a><span>#}</span></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a><span>{# </span><span>fun</span><span> </span><span>pure</span><span> </span><span>unsafe</span><span> rust_wrapper_handle_id </span><span>as</span><span> handleId</span></span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a><span>      { </span><span>`Handle&#39;</span></span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a><span>      }</span></span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a><span>   -&gt; </span><span>`Word64&#39;</span></span>
<span id="cb65-13"><a href="#cb65-13" aria-hidden="true" tabindex="-1"></a><span>#}</span></span></code></pre></div>
<p>The signatures generated by <code>c2hs</code> are</p>
<div id="cb66"><pre><code><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span>newtype</span> <span>Handle</span> <span>=</span> <span>Handle</span> (<span>ForeignPtr</span> <span>Handle</span>)</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a><span>newHandle ::</span> <span>IO</span> <span>Handle</span></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a><span>handleId  ::</span> <span>Handle</span> <span>-&gt;</span> <span>Word64</span></span></code></pre></div>
<p>The biggest drawback of this approach is that we now no longer have any representation of these values Haskell-side; we cannot provide a “legal” <code>Show</code> instances. This can be quite inconvenient, especially in tests. Managing values on the Rust heap through the Haskell GC (even if we are using the Rust-side deallocator) is also simply more error prone, and if things go wrong, hard to debug. It is probably only the better choice if serialization is either impossible or prohibitively expensive.</p>
<h2 id="efficiency">Efficiency</h2>
<p>The design of <code>haskell-ffi</code> and <code>foreign-rust</code> is optimized for ease of integration, not necessarily for optimal performance. This is almost certainly fine for most applications, but you probably don’t want the overhead of serialization and deserialization when doing FFI calls to Rust in a tight Haskell loop (of course, it is almost never a good idea to do that anyway).</p>
<p>Alongside <code>withBorshVarBuffer</code>, <code>foreign-rust</code> offers <code>withBorshBufferOfInitSize</code> which can be used to specify a different initial buffer size, which can be used to reduce the probability that a second round-trip is necessary (in the case that the initial buffer was not big enough). In principle, you could use this in conjunction with a Rust-side function that <em>computes</em> the required buffer size, but there isn’t much point: this would still require two FFI calls, with the same parameters; <em>if</em> there is a cheap way Rust-side to compute the necessary buffer size, then that behaviour should just be baked into the <em>one</em> Rust function: check if the allocated buffer is big enough before doing anything else. The standard marshalling functions offered by <code>haskell-ffi</code> do <em>not</em> do this, since in general it is difficult to know exactly how large the serialized form of some data is without actually serializing it.</p>
<p>In the case where a Rust function must <em>really</em> only be called once (perhaps because it has side effects), you can choose to forgo serialization altogether, as we described above in <a href="#avoiding-serialization">Avoiding serialization</a>. Alternatively, <code>foreign-rust</code> offers a hybrid approach, where we allocate a buffer Rust-side, pass a pointer to the buffer to Haskell, deserialize it Haskell-side, and then free the buffer when no longer required. For our example where we convert a secret key to PEM, the Rust-side wrapper would look like this:</p>
<div id="cb67"><pre><code><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span>#[</span>no_mangle<span>]</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a><span>pub</span> <span>extern</span> <span>&#34;C&#34;</span> <span>fn</span> rust_wrapper_key_to_pem_external(key<span>:</span> <span>*</span><span>const</span> <span>u8</span><span>,</span> key_len<span>:</span> <span>usize</span>) <span>-&gt;</span> <span>*</span><span>mut</span> <span>Vec</span><span>&lt;</span><span>u8</span><span>&gt;</span> <span>{</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>    <span>// .. construction of `result` exactly as before</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>    marshall_to_haskell_external(result<span>,</span> RW)</span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>with Haskell counter-part:</p>
<div id="cb68"><pre><code><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span>{# </span><span>fun</span><span> </span><span>pure</span><span> </span><span>unsafe</span><span> rust_wrapper_key_to_pem_external </span><span>as</span><span> toPemExternal</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a><span>     { toBorshFixed* </span><span>`SecretKey&#39;</span><span>&amp;</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a><span>     }</span></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a><span>  -&gt; </span><span>`Text&#39;</span><span> fromExternalBorsh*</span></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a><span>#}</span></span></code></pre></div>
<p>The type of the function constructed by <code>c2hs</code> is then <code>SecretKey -&gt; Text</code>. The advantages of this approach is that no initial buffer size needs to be estimated (we just use whatever buffer was allocated Rust-side), a second round-trip is guaranteed not to be needed, and we avoid copying the buffer. We still have the serialization/deserialization overhead, of course, and—perhaps more importantly—it is difficult to predict quite how long we will hold on to that Rust-allocated buffer. The deserializer might return values that directly or indirectly point to that buffer, and since these buffers are allocated on the Rust heap, not the Haskell heap, memory profiling might be difficult. In most cases, this approach is therefore probably not the right choice.</p>
<h2 id="conclusions">Conclusions</h2>
<p>This was a long blog post, so let’s summarize:</p>
<ul>
<li>Expose <code>extern &#34;C&#34;</code> functions in your Rust-code; you can use the Rust library <code>haskell-ffi</code> to serialize and deserialize data in a convenient manner.</li>
<li>Build your Rust library with <code>cargo cbuild</code>, to generate a header file and a <code>pkg-config</code> file.</li>
<li>Declare a <code>pkg-config</code> dependency on the Rust library in your <code>cabal</code> file, as well as a dependency on the build tool (preprocessor) <code>c2hs</code>.</li>
<li>Use <code>c2hs</code> to add bindings to the C functions; the Haskell library <code>foreign-rust</code> is a companion library to <code>haskell-ffi</code> that makes this process very streamlined.</li>
<li>For data types with a fixed size encoding, the <code>c2hs</code> declaration might be all you need; otherwise you will write a simple wrapper function, again using functionality from <code>foreign-rust</code>.</li>
<li>To <code>Show</code> Rust-side values, <code>foreign-rust</code> offers various ways, which show a value in base-16, base-58, base-64, or JSON format; each of these generate valid Haskell, so that you can denote Rust-side values within your Haskell source code.</li>
<li>In addition, <code>foreign-rust</code> offers functionality for annotating values with additional information, which can be quite helpful to get further information about Rust-side values during debugging.</li>
<li>Finally, if serialization of Rust-side values is undesirable or impossible, you can just pass pointers back and forth, using the Haskell garbage collector to call the Rust-side deallocator when a value is no longer in use. However, when you do this, you will have no way of denoting these values Haskell-side.</li>
</ul>

        </div>
      </div></div>
  </body>
</html>
