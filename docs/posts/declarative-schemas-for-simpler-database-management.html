<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://supabase.com/blog/declarative-schemas">Original</a>
    <h1>Declarative Schemas for simpler database management</h1>
    
    <div id="readability-page-1" class="page"><article><div><p><img alt="Declarative Schemas for Simpler Database Management" loading="lazy" decoding="async" data-nimg="fill" sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw" srcset="/_next/image?url=%2Fimages%2Fblog%2Flaunch-week-14%2Fday-4-declarative-schemas%2Fthumb.png&amp;w=256&amp;q=100&amp;dpl=dpl_C9dgStL1Ty5gqDHZR2MShCDENzwW 256w, /_next/image?url=%2Fimages%2Fblog%2Flaunch-week-14%2Fday-4-declarative-schemas%2Fthumb.png&amp;w=384&amp;q=100&amp;dpl=dpl_C9dgStL1Ty5gqDHZR2MShCDENzwW 384w, /_next/image?url=%2Fimages%2Fblog%2Flaunch-week-14%2Fday-4-declarative-schemas%2Fthumb.png&amp;w=640&amp;q=100&amp;dpl=dpl_C9dgStL1Ty5gqDHZR2MShCDENzwW 640w, /_next/image?url=%2Fimages%2Fblog%2Flaunch-week-14%2Fday-4-declarative-schemas%2Fthumb.png&amp;w=750&amp;q=100&amp;dpl=dpl_C9dgStL1Ty5gqDHZR2MShCDENzwW 750w, /_next/image?url=%2Fimages%2Fblog%2Flaunch-week-14%2Fday-4-declarative-schemas%2Fthumb.png&amp;w=828&amp;q=100&amp;dpl=dpl_C9dgStL1Ty5gqDHZR2MShCDENzwW 828w, /_next/image?url=%2Fimages%2Fblog%2Flaunch-week-14%2Fday-4-declarative-schemas%2Fthumb.png&amp;w=1080&amp;q=100&amp;dpl=dpl_C9dgStL1Ty5gqDHZR2MShCDENzwW 1080w, /_next/image?url=%2Fimages%2Fblog%2Flaunch-week-14%2Fday-4-declarative-schemas%2Fthumb.png&amp;w=1200&amp;q=100&amp;dpl=dpl_C9dgStL1Ty5gqDHZR2MShCDENzwW 1200w, /_next/image?url=%2Fimages%2Fblog%2Flaunch-week-14%2Fday-4-declarative-schemas%2Fthumb.png&amp;w=1920&amp;q=100&amp;dpl=dpl_C9dgStL1Ty5gqDHZR2MShCDENzwW 1920w, /_next/image?url=%2Fimages%2Fblog%2Flaunch-week-14%2Fday-4-declarative-schemas%2Fthumb.png&amp;w=2048&amp;q=100&amp;dpl=dpl_C9dgStL1Ty5gqDHZR2MShCDENzwW 2048w, /_next/image?url=%2Fimages%2Fblog%2Flaunch-week-14%2Fday-4-declarative-schemas%2Fthumb.png&amp;w=3840&amp;q=100&amp;dpl=dpl_C9dgStL1Ty5gqDHZR2MShCDENzwW 3840w" src="https://supabase.com/_next/image?url=%2Fimages%2Fblog%2Flaunch-week-14%2Fday-4-declarative-schemas%2Fthumb.png&amp;w=3840&amp;q=100&amp;dpl=dpl_C9dgStL1Ty5gqDHZR2MShCDENzwW"/></p>
<p>Today weâ€™re releasing declarative schemas to simplify managing and maintaining complex database schemas. With declarative schemas, you can define your database structure in a clear, centralized, and version-controlled manner.</p>
<p><iframe src="https://www.youtube-nocookie.com/embed/ts7HEeCuVH0" title="Declarative Schemas for Simpler Database Management" allow="accelerometer; autoplay; clipboard-write; encrypted-media; fullscreen; gyroscope; picture-in-picture; web-share"></iframe></p>

<p>Declarative schemas store the final desired state of the database in <code>.sql</code> files that can be saved and versioned alongside a project. For example, here is the declarative schema for a classic <code>products</code> table:</p>

<p>Declarative schemas offer numerous benefits over making changes to your database schema directly:</p>
<ul>
<li><strong>Single pane of glass</strong>. Maintain your entire database schema in one place, reducing redundancy and potential errors.</li>
<li><strong>Versioned migrations</strong>. Automatically generate migration files, ensuring consistent schema updated across environments. Store your declarative schema files alongside your project files in your version control system.</li>
<li><strong>Concise code reviews</strong>. Easily review changes to tables, views, and functions without manually repeating complex migration scripts.</li>
</ul>

<p>It&#39;s best practice to use <a href="https://supabase.com/docs/guides/deployment/database-migrations">Migrations</a> to track and apply changes to databases. Every time you make a change, you create a new new file with all the changes, keeping changes versioned and reproducible.</p>
<p>However, as the complexity of a database schemas grows, it becomes increasingly difficult to develop using versioned migrations as there isn&#39;t a single place to see the entire database schema.</p>
<p>For example, at Supabase we have a complex and frequently-updated <code>projects</code> table. Here&#39;s partially what it looks like with RLS enabled:</p>

<p>The <code>projects</code> table is created in a private schema, with a public view exposed for reads. Attribute-based access control (ABAC) is implemented on top of RLS policies to ensure queries only return projects that the user has access to.</p>
<p>Since Postgres views are not updatable by default, we have defined trigger functions to cascade writes to the underlying table when a Supabase user creates a new project. This makes development easier because the <code>projects</code> view can be inserted with regular PostgREST calls while invoking the appropriate RLS policies on the underlying table.</p>

<p>This complexity slows down development velocity, as changes to the table might break other views or functions. Back in early 2022, a simple change to add a new column involved the following steps.</p>
<ol>
<li>Find the latest schema for <code>projects</code> table in our migration files or by querying our database.</li>
<li>Write the <code>alter table</code> statement in a new migration file.</li>
<li>Copy and update the <code>projects</code> view definition to include the new column.</li>
<li>Copy and update the trigger function definition to include the new column.</li>
<li>Add new pgTAP tests and verify that existing tests pass.</li>
<li>Submit the new migration file for review, which would be at least a few hundred lines.</li>
</ol>
<p>This process is tedious and it&#39;s frustrating to have multiple engineers working on the <code>projects</code> table concurrently. Merging PRs would result in a merge conflict that must be resolved by repeating steps 1-5.</p>

<p>Adopting declarative schemas gave our engineers a single pane of glass when updating database schemas. Instead of manually duplicating affected postgres entities in a migration file, we only need to change the schema definition in one place.</p>
<p>We then use a schema diff tool, like <a href="https://github.com/djrobstep/migra">migra</a>, to figure out the necessary updates to views and functions when generating the migration file.</p>
<p>For example, adding a new <code>metadata</code> column to the <code>projects</code> table now becomes a single line diff.</p>

<p>The same process also applies to views, database functions, RLS policies, role grants, custom types, and constraints. While manual reviews are still required on the generated migration file, it has cut down our development from hours to minutes. It&#39;s also much easier to rebase on merge conflicts introduced by other PRs.</p>

<p>Declarative schemas are available today on Supabase.</p>
<ul>
<li><a href="https://supabase.com/docs/guides/local-development/declarative-database-schemas">Read the documentation</a> to learn how to manage your database schemas in one place and generate versioned migrations.</li>
<li><a href="https://supabase.com/dashboard/sign-up">Sign up for Supabase</a> and get started today.</li>
</ul>
<p>We added the same set of tools that we used internally for the last 2 years to <a href="https://supabase.com/docs/guides/local-development/cli/getting-started">Supabase CLI</a>. Whether you are just getting started with migrations or already fed up with managing hundreds of migration files, give declarative schemas a try as it will likely simplify your development process.</p>
<p>Check out our blog post on <a href="https://supabase.com/blog/postgres-language-server">Postgres Language Server</a> for better tooling and IDE integration when developing with declarative schemas.</p></div></article></div>
  </body>
</html>
