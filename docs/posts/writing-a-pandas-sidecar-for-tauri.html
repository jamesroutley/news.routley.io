<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mclare.blog/posts/writing-a-pandas-sidecar-for-tauri">Original</a>
    <h1>Writing a pandas Sidecar for Tauri</h1>
    
    <div id="readability-page-1" class="page"><div id="observablehq-main">

<p>I&#39;m currently working on a <a href="https://tauri.app/" target="_blank" rel="noopener noreferrer">Tauri</a> project that needs to utilize a series of  <a href="https://pandas.pydata.org/" target="_blank" rel="noopener noreferrer">pandas</a> scripts for data cleaning before loading them into my database in Tauri. While Tauri supports <a href="https://v2.tauri.app/develop/sidecar/" target="_blank" rel="noopener noreferrer">embedding external binaries</a> the documentation is pretty limited and generic, so I hit a few problems that were Python specific, which I&#39;m documenting here for future me.</p>
<h2 id="hello-world" tabindex="-1"><a href="#hello-world">Hello World</a></h2>
<p>A quick search for &#34;python sidecar&#34; turned up the <code>example-tauri-v2-python-server-sidecar</code> <a href="https://github.com/dieharders/example-tauri-v2-python-server-sidecar" target="_blank" rel="noopener noreferrer">repo</a>, which worked for me out of the box. It also put me on the path to use <a href="https://pyinstaller.org/en/stable/" target="_blank" rel="noopener noreferrer">PyInstaller</a> for my own sidecar implementation.</p>
<p>After successfully building the app, I went ahead and stripped out as much of the code as I could to just run a basic <code>hello</code> program (since the example repo included complications like writing concurrent Rust ðŸ˜…).</p>
<p><code>main.rs</code></p>
<pre data-language="rust"><code>
<span>#![cfg_attr(not(debug_assertions), windows_subsystem = <span>&#34;windows&#34;</span>)]</span>
 
<span>use</span> tauri::Emitter;
<span>use</span> tauri_plugin_shell::process::{CommandChild, CommandEvent};
<span>use</span> tauri_plugin_shell::ShellExt;
<span>use</span> tauri::{App, Manager};
 
<span>#[tokio::main]</span>
<span>async</span> <span>fn</span> <span>main</span>() {
    
    <span>let</span> <span>app</span> = tauri::Builder::<span>default</span>()
        .<span>plugin</span>(tauri_plugin_dialog::<span>init</span>())
        .<span>plugin</span>(tauri_plugin_shell::<span>init</span>())
        .<span>invoke_handler</span>(tauri::generate_handler![])
        .<span>build</span>(tauri::generate_context!())
        .<span>expect</span>(<span>&#34;error building the app&#34;</span>);

    
    <span>let</span> <span>app_handle</span> = app.<span>handle</span>().<span>clone</span>();
    <span>println!</span>(<span>&#34;[tauri] Creating sidecar...&#34;</span>);
    <span>let</span> <span>_status</span> = <span>run_sidecar</span>(app_handle);
    <span>println!</span>(<span>&#34;[tauri] Sidecar run&#34;</span>);

    app.<span>run</span>(|_, _| {});
}
</code></pre>
<pre data-language="rust"><code><span>pub</span> <span>fn</span> <span>run_sidecar</span>(app_handle: tauri::AppHandle) <span>-&gt;</span> <span>Result</span>&lt;(), <span>String</span>&gt; {
    
    <span>let</span> <span>sidecar_command</span> = app_handle.<span>shell</span>().<span>sidecar</span>(<span>&#34;hello&#34;</span>).<span>unwrap</span>();
    <span>let</span> (<span>mut</span> rx, _child) = sidecar_command.<span>spawn</span>().<span>expect</span>(<span>&#34;Failed to spawn sidecar&#34;</span>);

    
    tauri::async_runtime::<span>spawn</span>(<span>async</span> <span>move</span> {
        <span>while</span> <span>let</span> <span>Some</span>(event) = rx.<span>recv</span>().<span>await</span> {
            <span>match</span> event {
                CommandEvent::<span>Stdout</span>(line_bytes) =&gt; {
                    <span>let</span> <span>line</span> = <span>String</span>::<span>from_utf8_lossy</span>(&amp;line_bytes);
                    <span>println!</span>(<span>&#34;Sidecar stdout: {}&#34;</span>, line);
                    
                    app_handle
                        .<span>emit</span>(<span>&#34;sidecar-stdout&#34;</span>, line.<span>to_string</span>())
                        .<span>expect</span>(<span>&#34;Failed to emit sidecar stdout event&#34;</span>);
                }
                CommandEvent::<span>Stderr</span>(line_bytes) =&gt; {
                    <span>let</span> <span>line</span> = <span>String</span>::<span>from_utf8_lossy</span>(&amp;line_bytes);
                    <span>eprintln!</span>(<span>&#34;Sidecar stderr: {}&#34;</span>, line);
                    
                    app_handle
                        .<span>emit</span>(<span>&#34;sidecar-stderr&#34;</span>, line.<span>to_string</span>())
                        .<span>expect</span>(<span>&#34;Failed to emit sidecar stderr event&#34;</span>);
                }
                _ =&gt; {}
            }
        }
    });

    <span>Ok</span>(())
}
</code></pre>
<p>For the python compilation, all I needed to do was run:</p>
<pre><code>pyinstaller -n hello-aarch64-apple-darwin hello.py
</code></pre>
<p>and make sure the binary was accessible at:</p>
<pre><code>~/workspaces/my-app/src-tauri/binaries/hello/dist/hello-aarch64-apple-darwin
</code></pre>
<p>which produced the following in my terminal when run:</p>
<pre><code>[tauri] Creating sidecar...
[tauri] Sidecar run
Sidecar stdout: hello world
</code></pre>
<h2 id="my-complications" tabindex="-1"><a href="#my-complications">My Complications</a></h2>
<p>The actual sidecar I need to run included the following complications:</p>
<ol>
<li>Use additional reference files (xlsx, yaml)</li>
<li>Use external libraries (pandas, etc)</li>
<li>Ingest a variable number of arguments to the sidecar</li>
</ol>
<p>Following the same steps as for my hello world example resulted in a binary that worked when called on its own, but when called within Tauri, I got the following error:</p>
<pre data-language="shell"><code>Sidecar stderr: [PYI-39539:ERROR] Failed to load Python shared library &#39;/Users/mclare/workspaces/my-app/src-tauri/target/debug/_internal/Python&#39;: dlopen: dlopen(/Users/maryannewachter/workspaces/blt-app/src-tauri/target/debug/_internal/Python, 0x000A): tried: &#39;/Users/mclare/workspaces/my-app/src-tauri/target/debug/_internal/Python&#39; (no such file), &#39;/System/Volumes/Preboot/Cryptexes/OS/Users/mclare/workspaces/my-app/src-tauri/target/debug/_internal/Python&#39; (no such file), &#39;/Users/mclare/workspaces/my-app/src-tauri/target/debug/_internal/Python&#39; (no such file)
</code></pre>
<p>As it turned out, I needed to make three key changes to the <code>pyinstaller</code> command:</p>
<pre data-language="rust"><code>pyinstaller  --add-data references:references --onefile --name run-$(rustc -Vv | grep <span>&#34;host:&#34;</span> | cut -d <span>&#39; &#39;</span> -f <span>2</span>) run.py
</code></pre>
<p>I needed to add a mapping for the external assets (csvs) referenced by the binary via the <code>--add-data source:target</code> flag</p>
<p>I also needed to indicate that the binary should be compiled as a single file (which is what produced the error above)</p>
<p>Finally, so I can automate this elsewhere, I needed to capture the results of the <code>rustc -Vv</code> into the resulting binary name, as <a href="https://v2.tauri.app/develop/sidecar/" target="_blank" rel="noopener noreferrer">required</a> by Tauri</p>
<p>I set up my sidecar to accept a variable number of filepaths for input csvs to be batch processed, with the first argument as the output file location. That meant I needed to modify the <code>file_names</code> Vec passed from the frontend and prepend it with Tauri&#39;s <a href="https://docs.rs/tauri/2.5.0/tauri/path/struct.PathResolver.html#method.app_data_dir" target="_blank" rel="noopener noreferrer"><code>app_data_dir</code></a></p>
<p>After removing the old sidecar, I was left with:</p>
<p><code>import.rs</code></p>
<pre data-language="rust"><code><span>#[tauri::command]</span>
<span>pub</span> <span>async</span> <span>fn</span> <span>process_csvs</span>(
    app_handle: tauri::AppHandle,
    state: tauri::State&lt;<span>&#39;_</span>, AppState&gt;,
    <span>mut</span> file_names: <span>Vec</span>&lt;<span>String</span>&gt;,
) <span>-&gt;</span> <span>Result</span>&lt;(), <span>String</span>&gt; {
    <span>let</span> <span>app_data_dir</span> = app_handle
        .<span>path</span>()
        .<span>app_data_dir</span>()
        .<span>map_err</span>(|e| <span>format!</span>(<span>&#34;Failed to get app data directory: {}&#34;</span>, e))?
        .<span>to_str</span>()
        .<span>ok_or_else</span>(|| <span>&#34;Failed to convert path to string&#34;</span>.<span>to_string</span>())?
        .<span>to_string</span>();
    file_names.<span>insert</span>(<span>0</span>, app_data_dir);
    <span>let</span> <span>sidecar_command</span> = app_handle
        .<span>shell</span>()
        .<span>sidecar</span>(<span>&#34;run&#34;</span>)
        .<span>map_err</span>(|e| <span>format!</span>(<span>&#34;Failed to create sidecar command: {}&#34;</span>, e))?
        .<span>args</span>(file_names);

    <span>let</span> (<span>mut</span> rx, _child) = sidecar_command
        .<span>spawn</span>()
        .<span>map_err</span>(|e| <span>format!</span>(<span>&#34;Failed to spawn sidecar process: {}&#34;</span>, e))?;

    tauri::async_runtime::<span>spawn</span>(<span>async</span> <span>move</span> {
        <span>while</span> <span>let</span> <span>Some</span>(event) = rx.<span>recv</span>().<span>await</span> {
            <span>match</span> event {
                CommandEvent::<span>Stdout</span>(line_bytes) =&gt; {
                    <span>let</span> <span>line</span> = <span>String</span>::<span>from_utf8_lossy</span>(&amp;line_bytes);
                    <span>println!</span>(<span>&#34;Sidecar stdout: {}&#34;</span>, line);
                    
                    app_handle
                        .<span>emit</span>(<span>&#34;sidecar-stdout&#34;</span>, line.<span>to_string</span>())
                        .<span>expect</span>(<span>&#34;Failed to emit sidecar stdout event&#34;</span>);
                }
                CommandEvent::<span>Stderr</span>(line_bytes) =&gt; {
                    <span>let</span> <span>line</span> = <span>String</span>::<span>from_utf8_lossy</span>(&amp;line_bytes);
                    <span>eprintln!</span>(<span>&#34;Sidecar stderr: {}&#34;</span>, line);
                    
                    app_handle
                        .<span>emit</span>(<span>&#34;sidecar-stderr&#34;</span>, line.<span>to_string</span>())
                        .<span>expect</span>(<span>&#34;Failed to emit sidecar stderr event&#34;</span>);
                }
                _ =&gt; {}
            }
        }
    });
    <span>Ok</span>(())
}
</code></pre>
<h2 id="next-steps" tabindex="-1"><a href="#next-steps">Next Steps</a></h2>
<p>I&#39;m writing a temporary file to the app data directory, which I will then load into the database I&#39;m building, but eventually, I could probably just stream the csv results directly to Rust. Ultimately, I should probably get rid of the Python dependency and port all the data frame manipulation to <a href="https://pola.rs/" target="_blank" rel="noopener noreferrer">Polars</a>, but this was a worth sidequest (ha!) to learn a bit more about Tauri&#39;s features.</p>
</div></div>
  </body>
</html>
