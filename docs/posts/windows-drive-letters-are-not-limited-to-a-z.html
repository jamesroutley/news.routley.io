<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.ryanliptak.com/blog/windows-drive-letters-are-not-limited-to-a-z/">Original</a>
    <h1>Windows drive letters are not limited to A-Z</h1>
    
    <div id="readability-page-1" class="page"><div>

<p><time>2025-11-30</time>
 - <a href="https://www.ryanliptak.com/blog/categories/programming">Programming</a>
 - <a href="https://www.ryanliptak.com/blog/categories/windows">Windows</a></p><p>On its own, the title of this post is just a true piece of trivia, verifiable with <a href="https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/subst">the built-in <code>subst</code> tool</a> (among other methods).</p>
<p>Here&#39;s an example creating the drive <code>+:\</code> as an alias for a directory at <code>C:\foo</code>:</p>
<pre><code>subst +: C:\foo
</code></pre>
<p>The <code>+:\</code> drive then works as normal (at least in cmd.exe, this will be discussed more later):</p>
<pre><code>&gt; cd /D +:\

+:\&gt; tree .
Folder PATH listing
Volume serial number is 00000001 12AB:23BC
+:\
â””â”€â”€â”€bar
</code></pre>
<p>However, understanding <em>why</em> it&#39;s true elucidates a lot about how Windows works under the hood, and turns up a few curious behaviors.</p>
<h2>What is a drive letter, anyway?<a id="what-is-a-drive-letter-anyway" href="#what-is-a-drive-letter-anyway">ðŸ”—</a></h2>
<p>The paths that most people are familiar with are <a href="https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#namespaces">Win32 namespace paths</a>, e.g. something like <code>C:\foo</code> which is a drive-absolute Win32 path. However, the high-level APIs that take Win32 paths like <a href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew"><code>CreateFileW</code></a> ultimately will convert a path like <code>C:\foo</code> into a NT namespace path before calling into a lower level API within <code>ntdll.dll</code> like <a href="https://learn.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntcreatefile"><code>NtCreateFile</code></a>.</p>
<p>This can be confirmed with <a href="https://github.com/rogerorr/NtTrace">NtTrace</a>, where a call to <code>CreateFileW</code> with <code>C:\foo</code> ultimately leads to a call of <code>NtCreateFile</code> with <code>\??\C:\foo</code>:</p>
<pre><code>NtCreateFile( FileHandle=0x40c07ff640 [0xb8], DesiredAccess=SYNCHRONIZE|GENERIC_READ|0x80, ObjectAttributes=&#34;\??\C:\foo&#34;, IoStatusBlock=0x40c07ff648 [0/1], AllocationSize=null, FileAttributes=0, ShareAccess=7, CreateDisposition=1, CreateOptions=0x4000, EaBuffer=null, EaLength=0 ) =&gt; 0
NtClose( Handle=0xb8 ) =&gt; 0
</code></pre>

<details>
<summary>Test code, reproduction info</summary>
<p><code>createfilew.zig</code>:</p>
<pre><code><span>const</span><span> </span><span>std</span><span> </span><span>=</span><span> </span><span>@import</span><span>(</span><span>&#34;std&#34;</span><span>);</span><span>
</span><span>const</span><span> </span><span>windows</span><span> </span><span>=</span><span> </span><span>std</span><span>.</span><span>os</span><span>.</span><span>windows</span><span>;</span><span>
</span><span>const</span><span> </span><span>L</span><span> </span><span>=</span><span> </span><span>std</span><span>.</span><span>unicode</span><span>.</span><span>wtf8ToWtf16LeStringLiteral</span><span>;</span><span>

</span><span>pub</span><span> </span><span>extern</span><span> </span><span>&#34;kernel32&#34;</span><span> </span><span>fn</span><span> </span><span>CreateFileW</span><span>(</span><span>
    </span><span>lpFileName</span><span>:</span><span> </span><span>windows</span><span>.</span><span>LPCWSTR</span><span>,</span><span>
    </span><span>dwDesiredAccess</span><span>:</span><span> </span><span>windows</span><span>.</span><span>DWORD</span><span>,</span><span>
    </span><span>dwShareMode</span><span>:</span><span> </span><span>windows</span><span>.</span><span>DWORD</span><span>,</span><span>
    </span><span>lpSecurityAttributes</span><span>:</span><span> </span><span>?*</span><span>windows</span><span>.</span><span>SECURITY_ATTRIBUTES</span><span>,</span><span>
    </span><span>dwCreationDisposition</span><span>:</span><span> </span><span>windows</span><span>.</span><span>DWORD</span><span>,</span><span>
    </span><span>dwFlagsAndAttributes</span><span>:</span><span> </span><span>windows</span><span>.</span><span>DWORD</span><span>,</span><span>
    </span><span>hTemplateFile</span><span>:</span><span> </span><span>?</span><span>windows</span><span>.</span><span>HANDLE</span><span>,</span><span>
</span><span>)</span><span> </span><span>callconv</span><span>(.</span><span>winapi</span><span>)</span><span> </span><span>windows</span><span>.</span><span>HANDLE</span><span>;</span><span>

</span><span>pub</span><span> </span><span>fn</span><span> </span><span>main</span><span>()</span><span> </span><span>!</span><span>void</span><span> </span><span>{</span><span>
    </span><span>const</span><span> </span><span>path</span><span> </span><span>=</span><span> </span><span>L</span><span>(</span><span>&#34;C:\\foo&#34;</span><span>);</span><span>
    </span><span>const</span><span> </span><span>dir_handle</span><span> </span><span>=</span><span> </span><span>CreateFileW</span><span>(</span><span>
        </span><span>path</span><span>,</span><span>
        </span><span>windows</span><span>.</span><span>GENERIC_READ</span><span>,</span><span>
        </span><span>windows</span><span>.</span><span>FILE_SHARE_DELETE</span><span> </span><span>|</span><span> </span><span>windows</span><span>.</span><span>FILE_SHARE_READ</span><span> </span><span>|</span><span> </span><span>windows</span><span>.</span><span>FILE_SHARE_WRITE</span><span>,</span><span>
        </span><span>null</span><span>,</span><span>
        </span><span>windows</span><span>.</span><span>OPEN_EXISTING</span><span>,</span><span>
        </span><span>windows</span><span>.</span><span>FILE_FLAG_BACKUP_SEMANTICS</span><span> </span><span>|</span><span> </span><span>windows</span><span>.</span><span>FILE_FLAG_OVERLAPPED</span><span>,</span><span>
        </span><span>null</span><span>,</span><span>
    </span><span>);</span><span>
    </span><span>if</span><span> </span><span>(</span><span>dir_handle</span><span> </span><span>==</span><span> </span><span>windows</span><span>.</span><span>INVALID_HANDLE_VALUE</span><span>)</span><span> </span><span>return</span><span> </span><span>error</span><span>.</span><span>FailedToOpenDir</span><span>;</span><span>
    </span><span>defer</span><span> </span><span>windows</span><span>.</span><span>CloseHandle</span><span>(</span><span>dir_handle</span><span>);</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>Built with:</p>
<pre><code>zig build-exe createfilew.zig
</code></pre>
<p>To run with NtTrace:</p>
<pre><code>nttrace createfilew.exe &gt; createfilew.log
</code></pre>
</details>
<p>That <code>\??\C:\foo</code> is a <a href="https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#nt-namespaces">NT namespace path</a>, which is what <code>NtCreateFile</code> expects. To understand this path, though, we need to talk about the Object Manager, which is responsible for handling NT paths.</p>
<h3>The Object Manager<a id="the-object-manager" href="#the-object-manager">ðŸ”—</a></h3>

<p>The Object Manager is responsible for keeping track of named objects, which we can explore using <a href="https://learn.microsoft.com/en-us/sysinternals/downloads/winobj">the WinObj tool</a>. The <code>\??</code> part of the <code>\??\C:\foo</code> path is actually a special virtual folder within the Object Manager that combines the <code>\GLOBAL??</code> folder and a per-user <code>DosDevices</code> folder together.</p>
<p>For me, the object <code>C:</code> is within <code>\GLOBAL??</code>, and is actually a symbolic link to <code>\Device\HarddiskVolume4</code>:</p>
<p><img src="https://www.ryanliptak.com/images/windows-drive-letters-are-not-limited-to-a-z/cdrive.png"/>
</p>
<p>So, <code>\??\C:\foo</code> ultimately resolves to <code>\Device\HarddiskVolume4\foo</code>, and then it&#39;s up to the actual device to deal with the <code>foo</code> part of the path.</p>
<p>The important thing here, though, is that <code>\??\C:\foo</code> is just <em>one way</em> of referring to the device path <code>\Device\HarddiskVolume4\foo</code>. For example, volumes will also get a named object created using their GUID with the format <code>Volume{18123456-abcd-efab-cdef-1234abcdabcd}</code> that is also a symlink to something like <code>\Device\HarddiskVolume4</code>, so a path like <code>\??\Volume{18123456-abcd-efab-cdef-1234abcdabcd}\foo</code> is effectively equivalent to <code>\??\C:\foo</code>.</p>

<p>All this is to say that there&#39;s nothing innately special about the named object <code>C:</code>; the Object Manager treats it just like any other symbolic link and resolves it accordingly.</p>
<h3>So, what <em>is</em> a drive letter, really?<a id="so-what-is-a-drive-letter-really" href="#so-what-is-a-drive-letter-really">ðŸ”—</a></h3>
<p>How I see it, drive letters are essentially just a convention borne out of the conversion of a Win32 path into a NT path. In particular, that would be down to the implementation of <a href="https://learn.microsoft.com/en-us/windows/win32/devnotes/rtldospathnametontpathname_u_withstatus"><code>RtlDosPathNameToNtPathName_U</code></a>.</p>
<p>In other words, since <code>RtlDosPathNameToNtPathName_U</code> converts <code>C:\foo</code> to <code>\??\C:\foo</code>, then an object named <code>C:</code> will behave like a drive letter. To give an example of what I mean by that: in an alternate universe, <code>RtlDosPathNameToNtPathName_U</code> could convert the path <code>FOO:\bar</code> to <code>\??\FOO:\bar</code> and then <code>FOO:</code> could behave like a drive letter.</p>
<p>So, getting back to the title, how does <code>RtlDosPathNameToNtPathName_U</code> treat something like <code>+:\foo</code>? Well, exactly the same as <code>C:\foo</code>:</p>
<pre><code>&gt; paths.exe C:\foo
path type: .DriveAbsolute
  nt path: \??\C:\foo

&gt; paths.exe +:\foo
path type: .DriveAbsolute
  nt path: \??\+:\foo
</code></pre>
<details>
<summary>Test program code</summary>
<p><code>paths.zig</code>:</p>
<pre><code><span>const</span><span> </span><span>std</span><span> </span><span>=</span><span> </span><span>@import</span><span>(</span><span>&#34;std&#34;</span><span>);</span><span>
</span><span>const</span><span> </span><span>windows</span><span> </span><span>=</span><span> </span><span>std</span><span>.</span><span>os</span><span>.</span><span>windows</span><span>;</span><span>

</span><span>pub</span><span> </span><span>fn</span><span> </span><span>main</span><span>()</span><span> </span><span>!</span><span>void</span><span> </span><span>{</span><span>
    </span><span>var</span><span> </span><span>arena_state</span><span> </span><span>=</span><span> </span><span>std</span><span>.</span><span>heap</span><span>.</span><span>ArenaAllocator</span><span>.</span><span>init</span><span>(</span><span>std</span><span>.</span><span>heap</span><span>.</span><span>page_allocator</span><span>);</span><span>
    </span><span>defer</span><span> </span><span>arena_state</span><span>.</span><span>deinit</span><span>();</span><span>
    </span><span>const</span><span> </span><span>arena</span><span> </span><span>=</span><span> </span><span>arena_state</span><span>.</span><span>allocator</span><span>();</span><span>

    </span><span>const</span><span> </span><span>args</span><span> </span><span>=</span><span> </span><span>try</span><span> </span><span>std</span><span>.</span><span>process</span><span>.</span><span>argsAlloc</span><span>(</span><span>arena</span><span>);</span><span>
    </span><span>if</span><span> </span><span>(</span><span>args</span><span>.</span><span>len</span><span> </span><span>&lt;=</span><span> </span><span>1</span><span>)</span><span> </span><span>return</span><span> </span><span>error</span><span>.</span><span>ExpectedArg</span><span>;</span><span>

    </span><span>const</span><span> </span><span>path</span><span> </span><span>=</span><span> </span><span>try</span><span> </span><span>std</span><span>.</span><span>unicode</span><span>.</span><span>wtf8ToWtf16LeAllocZ</span><span>(</span><span>arena</span><span>,</span><span> </span><span>args</span><span>[</span><span>1</span><span>]);</span><span>

    </span><span>const</span><span> </span><span>path_type</span><span> </span><span>=</span><span> </span><span>RtlDetermineDosPathNameType_U</span><span>(</span><span>path</span><span>);</span><span>
    </span><span>std</span><span>.</span><span>debug</span><span>.</span><span>print</span><span>(</span><span>&#34;path type: {}\n&#34;</span><span>,</span><span> </span><span>.{</span><span>path_type</span><span>});</span><span>
    </span><span>const</span><span> </span><span>nt_path</span><span> </span><span>=</span><span> </span><span>try</span><span> </span><span>RtlDosPathNameToNtPathName_U</span><span>(</span><span>path</span><span>);</span><span>
    </span><span>std</span><span>.</span><span>debug</span><span>.</span><span>print</span><span>(</span><span>&#34;  nt path: {f}\n&#34;</span><span>,</span><span> </span><span>.{</span><span>std</span><span>.</span><span>unicode</span><span>.</span><span>fmtUtf16Le</span><span>(</span><span>nt_path</span><span>.</span><span>span</span><span>())});</span><span>
</span><span>}</span><span>

</span><span>const</span><span> </span><span>RTL_PATH_TYPE</span><span> </span><span>=</span><span> </span><span>enum</span><span>(</span><span>c_int</span><span>)</span><span> </span><span>{</span><span>
    </span><span>Unknown</span><span>,</span><span>
    </span><span>UncAbsolute</span><span>,</span><span>
    </span><span>DriveAbsolute</span><span>,</span><span>
    </span><span>DriveRelative</span><span>,</span><span>
    </span><span>Rooted</span><span>,</span><span>
    </span><span>Relative</span><span>,</span><span>
    </span><span>LocalDevice</span><span>,</span><span>
    </span><span>RootLocalDevice</span><span>,</span><span>
</span><span>};</span><span>

</span><span>pub</span><span> </span><span>extern</span><span> </span><span>&#34;ntdll&#34;</span><span> </span><span>fn</span><span> </span><span>RtlDetermineDosPathNameType_U</span><span>(</span><span>
    </span><span>Path</span><span>:</span><span> </span><span>[</span><span>*:</span><span>0</span><span>]</span><span>const</span><span> </span><span>u16</span><span>,</span><span>
</span><span>)</span><span> </span><span>callconv</span><span>(.</span><span>winapi</span><span>)</span><span> </span><span>RTL_PATH_TYPE</span><span>;</span><span>

</span><span>fn</span><span> </span><span>RtlDosPathNameToNtPathName_U</span><span>(</span><span>path</span><span>:</span><span> </span><span>[</span><span>:</span><span>0</span><span>]</span><span>const</span><span> </span><span>u16</span><span>)</span><span> </span><span>!</span><span>windows</span><span>.</span><span>PathSpace</span><span> </span><span>{</span><span>
    </span><span>var</span><span> </span><span>out</span><span>:</span><span> </span><span>windows</span><span>.</span><span>UNICODE_STRING</span><span> </span><span>=</span><span> </span><span>undefined</span><span>;</span><span>
    </span><span>const</span><span> </span><span>rc</span><span> </span><span>=</span><span> </span><span>windows</span><span>.</span><span>ntdll</span><span>.</span><span>RtlDosPathNameToNtPathName_U</span><span>(</span><span>path</span><span>,</span><span> </span><span>&amp;</span><span>out</span><span>,</span><span> </span><span>null</span><span>,</span><span> </span><span>null</span><span>);</span><span>
    </span><span>if</span><span> </span><span>(</span><span>rc</span><span> </span><span>!=</span><span> </span><span>windows</span><span>.</span><span>TRUE</span><span>)</span><span> </span><span>return</span><span> </span><span>error</span><span>.</span><span>BadPathName</span><span>;</span><span>
    </span><span>defer</span><span> </span><span>windows</span><span>.</span><span>ntdll</span><span>.</span><span>RtlFreeUnicodeString</span><span>(</span><span>&amp;</span><span>out</span><span>);</span><span>

    </span><span>var</span><span> </span><span>path_space</span><span>:</span><span> </span><span>windows</span><span>.</span><span>PathSpace</span><span> </span><span>=</span><span> </span><span>undefined</span><span>;</span><span>
    </span><span>const</span><span> </span><span>out_path</span><span> </span><span>=</span><span> </span><span>out</span><span>.</span><span>Buffer</span><span>.</span><span>?</span><span>[</span><span>0</span><span> </span><span>..</span><span> </span><span>out</span><span>.</span><span>Length</span><span> </span><span>/</span><span> </span><span>2</span><span>];</span><span>
    </span><span>@memcpy</span><span>(</span><span>path_space</span><span>.</span><span>data</span><span>[</span><span>0</span><span>..</span><span>out_path</span><span>.</span><span>len</span><span>],</span><span> </span><span>out_path</span><span>);</span><span>
    </span><span>path_space</span><span>.</span><span>len</span><span> </span><span>=</span><span> </span><span>out</span><span>.</span><span>Length</span><span> </span><span>/</span><span> </span><span>2</span><span>;</span><span>
    </span><span>path_space</span><span>.</span><span>data</span><span>[</span><span>path_space</span><span>.</span><span>len</span><span>]</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span>

    </span><span>return</span><span> </span><span>path_space</span><span>;</span><span>
</span><span>}</span><span>
</span></code></pre>
</details>
<p>Therefore, if an object with the name <code>+:</code> is within the virtual folder <code>\??</code>, we can expect the Win32 path <code>+:\</code> to behave like any other drive-absolute path, which is exactly what we see.</p>

<h2>Some exploration of the implications<a id="some-exploration-of-the-implications" href="#some-exploration-of-the-implications">ðŸ”—</a></h2>
<p>This section only focuses on a few things that were relevant to what I was working on. I encourage others to investigate the implications of this further if they feel so inclined.</p>
<h3><code>explorer.exe</code> doesn&#39;t play ball<a id="explorer-exe-doesn-t-play-ball" href="#explorer-exe-doesn-t-play-ball">ðŸ”—</a></h3>
<p>Drives with a drive-letter other than A-Z do not appear in File Explorer, and cannot be navigated to in File Explorer.</p>
<p><img src="https://www.ryanliptak.com/images/windows-drive-letters-are-not-limited-to-a-z/explorer.png"/>
<i>Error when attempting to navigate to <code>+:\</code> in File Explorer</i>
</p>
<p>For the &#34;do not appear&#34; part, my guess as to what&#39;s happening is that <code>explorer.exe</code> is walking <code>\??</code> and looking specifically for objects named <code>A:</code> through <code>Z:</code>. For the &#34;cannot be navigated to&#34; part, that&#39;s a bit more mysterious, but my guess is that <code>explorer.exe</code> has a lot of special logic around handling paths typed into the location bar, and part of that restricts drive letters to <code>A</code>-<code>Z</code> (i.e. it&#39;s short-circuiting before it ever tries to actually open the path).</p>
<h3>PowerShell doesn&#39;t, either<a id="powershell-doesn-t-either" href="#powershell-doesn-t-either">ðŸ”—</a></h3>
<p>PowerShell seems to reject non-<code>A</code>-<code>Z</code> drives as well:</p>
<pre><code>PS C:\&gt; cd +:\
cd : Cannot find drive. A drive with the name &#39;+&#39; does not exist.
At line:1 char:1
+ cd +:\
+ ~~~~~~
    + CategoryInfo          : ObjectNotFound: (+:String) [Set-Location], DriveNotFoundException
    + FullyQualifiedErrorId : DriveNotFound,Microsoft.PowerShell.Commands.SetLocationCommand
</code></pre>
<h3>Non-ASCII drive letters<a id="non-ascii-drive-letters" href="#non-ascii-drive-letters">ðŸ”—</a></h3>
<p>Drive letters don&#39;t have to be within the ASCII range at all; they can also be non-ASCII characters.</p>
<pre><code>&gt; subst â‚¬: C:\foo

&gt; cd /D â‚¬:\

â‚¬:\&gt; tree .
Folder PATH listing
Volume serial number is 000000DE 12AB:23BC
â‚¬:\
â””â”€â”€â”€bar
</code></pre>
<p>Non-ASCII drive letters are even case-insensitive like <code>A</code>-<code>Z</code> are:</p>
<pre><code>&gt; subst Î›: C:\foo

&gt; cd /D Î»:\

Î»:\&gt; tree .
Folder PATH listing
Volume serial number is 000000DE 12AB:23BC
Î»:\
â””â”€â”€â”€bar
</code></pre>
<p>However, drive-letters cannot be <em>arbitrary</em> Unicode graphemes or even arbitrary code points; they are restricted to a single <a href="https://wtf-8.codeberg.page/#motivation">WTF-16</a> code unit (a <code>u16</code>, so &lt;= <code>U+FFFF</code>). The tool that we&#39;ve been using so far (<code>subst.exe</code>) errors with <code>Invalid parameter</code> if you try to use a drive letter with a code point larger than <code>U+FFFF</code>, but you can get around that by going through the <code>MountPointManager</code> directly:</p>
<p><img src="https://www.ryanliptak.com/images/windows-drive-letters-are-not-limited-to-a-z/u24b62drive.png"/>
</p>
<details>
<summary>Code used to create the <code>ð¤­¢:</code> symlink</summary>
<pre><code><span>const</span><span> </span><span>std</span><span> </span><span>=</span><span> </span><span>@import</span><span>(</span><span>&#34;std&#34;</span><span>);</span><span>
</span><span>const</span><span> </span><span>windows</span><span> </span><span>=</span><span> </span><span>std</span><span>.</span><span>os</span><span>.</span><span>windows</span><span>;</span><span>
</span><span>const</span><span> </span><span>L</span><span> </span><span>=</span><span> </span><span>std</span><span>.</span><span>unicode</span><span>.</span><span>wtf8ToWtf16LeStringLiteral</span><span>;</span><span>

</span><span>const</span><span> </span><span>MOUNTMGR_CREATE_POINT_INPUT</span><span> </span><span>=</span><span> </span><span>extern</span><span> </span><span>struct</span><span> </span><span>{</span><span>
    </span><span>SymbolicLinkNameOffset</span><span>:</span><span> </span><span>windows</span><span>.</span><span>USHORT</span><span>,</span><span>
    </span><span>SymbolicLinkNameLength</span><span>:</span><span> </span><span>windows</span><span>.</span><span>USHORT</span><span>,</span><span>
    </span><span>DeviceNameOffset</span><span>:</span><span> </span><span>windows</span><span>.</span><span>USHORT</span><span>,</span><span>
    </span><span>DeviceNameLength</span><span>:</span><span> </span><span>windows</span><span>.</span><span>USHORT</span><span>,</span><span>
</span><span>};</span><span>

</span><span>pub</span><span> </span><span>fn</span><span> </span><span>main</span><span>()</span><span> </span><span>!</span><span>void</span><span> </span><span>{</span><span>
    </span><span>const</span><span> </span><span>mgmt_handle</span><span> </span><span>=</span><span> </span><span>try</span><span> </span><span>windows</span><span>.</span><span>OpenFile</span><span>(</span><span>L</span><span>(</span><span>&#34;\\??\\MountPointManager&#34;</span><span>),</span><span> </span><span>.{</span><span>
        </span><span>.</span><span>access_mask</span><span> </span><span>=</span><span> </span><span>windows</span><span>.</span><span>SYNCHRONIZE</span><span> </span><span>|</span><span> </span><span>windows</span><span>.</span><span>GENERIC_READ</span><span> </span><span>|</span><span> </span><span>windows</span><span>.</span><span>GENERIC_WRITE</span><span>,</span><span>
        </span><span>.</span><span>share_access</span><span> </span><span>=</span><span> </span><span>windows</span><span>.</span><span>FILE_SHARE_READ</span><span> </span><span>|</span><span> </span><span>windows</span><span>.</span><span>FILE_SHARE_WRITE</span><span> </span><span>|</span><span> </span><span>windows</span><span>.</span><span>FILE_SHARE_DELETE</span><span>,</span><span>
        </span><span>.</span><span>creation</span><span> </span><span>=</span><span> </span><span>windows</span><span>.</span><span>FILE_OPEN</span><span>,</span><span>
    </span><span>});</span><span>
    </span><span>defer</span><span> </span><span>windows</span><span>.</span><span>CloseHandle</span><span>(</span><span>mgmt_handle</span><span>);</span><span>

    </span><span>const</span><span> </span><span>volume_name</span><span> </span><span>=</span><span> </span><span>L</span><span>(</span><span>&#34;\\Device\\HarddiskVolume4&#34;</span><span>);</span><span>
    </span><span>const</span><span> </span><span>mount_point</span><span> </span><span>=</span><span> </span><span>L</span><span>(</span><span>&#34;\\DosDevices\\ð¤­¢:&#34;</span><span>);</span><span>

    </span><span>const</span><span> </span><span>buf_size</span><span> </span><span>=</span><span> </span><span>@sizeOf</span><span>(</span><span>MOUNTMGR_CREATE_POINT_INPUT</span><span>)</span><span> </span><span>+</span><span> </span><span>windows</span><span>.</span><span>MAX_PATH</span><span> </span><span>*</span><span> </span><span>2</span><span> </span><span>+</span><span> </span><span>windows</span><span>.</span><span>MAX_PATH</span><span> </span><span>*</span><span> </span><span>2</span><span>;</span><span>
    </span><span>var</span><span> </span><span>input_buf</span><span>:</span><span> </span><span>[</span><span>buf_size</span><span>]</span><span>u8</span><span> </span><span>align</span><span>(</span><span>@alignOf</span><span>(</span><span>MOUNTMGR_CREATE_POINT_INPUT</span><span>))</span><span> </span><span>=</span><span> </span><span>[</span><span>_</span><span>]</span><span>u8</span><span>{</span><span>0</span><span>}</span><span> </span><span>**</span><span> </span><span>buf_size</span><span>;</span><span>

    </span><span>var</span><span> </span><span>input_struct</span><span>:</span><span> </span><span>*</span><span>MOUNTMGR_CREATE_POINT_INPUT</span><span> </span><span>=</span><span> </span><span>@ptrCast</span><span>(</span><span>&amp;</span><span>input_buf</span><span>[</span><span>0</span><span>]);</span><span>
    </span><span>input_struct</span><span>.</span><span>SymbolicLinkNameOffset</span><span> </span><span>=</span><span> </span><span>@sizeOf</span><span>(</span><span>MOUNTMGR_CREATE_POINT_INPUT</span><span>);</span><span>
    </span><span>input_struct</span><span>.</span><span>SymbolicLinkNameLength</span><span> </span><span>=</span><span> </span><span>mount_point</span><span>.</span><span>len</span><span> </span><span>*</span><span> </span><span>2</span><span>;</span><span>
    </span><span>input_struct</span><span>.</span><span>DeviceNameOffset</span><span> </span><span>=</span><span> </span><span>input_struct</span><span>.</span><span>SymbolicLinkNameOffset</span><span> </span><span>+</span><span> </span><span>input_struct</span><span>.</span><span>SymbolicLinkNameLength</span><span>;</span><span>
    </span><span>input_struct</span><span>.</span><span>DeviceNameLength</span><span> </span><span>=</span><span> </span><span>volume_name</span><span>.</span><span>len</span><span> </span><span>*</span><span> </span><span>2</span><span>;</span><span>

    </span><span>@memcpy</span><span>(</span><span>input_buf</span><span>[</span><span>input_struct</span><span>.</span><span>SymbolicLinkNameOffset</span><span>..][</span><span>0</span><span>..</span><span>input_struct</span><span>.</span><span>SymbolicLinkNameLength</span><span>],</span><span> </span><span>@as</span><span>([</span><span>*</span><span>]</span><span>const</span><span> </span><span>u8</span><span>,</span><span> </span><span>@ptrCast</span><span>(</span><span>mount_point</span><span>)));</span><span>
    </span><span>@memcpy</span><span>(</span><span>input_buf</span><span>[</span><span>input_struct</span><span>.</span><span>DeviceNameOffset</span><span>..][</span><span>0</span><span>..</span><span>input_struct</span><span>.</span><span>DeviceNameLength</span><span>],</span><span> </span><span>@as</span><span>([</span><span>*</span><span>]</span><span>const</span><span> </span><span>u8</span><span>,</span><span> </span><span>@ptrCast</span><span>(</span><span>volume_name</span><span>)));</span><span>

    </span><span>const</span><span> </span><span>IOCTL_MOUNTMGR_CREATE_POINT</span><span> </span><span>=</span><span> </span><span>windows</span><span>.</span><span>CTL_CODE</span><span>(</span><span>windows</span><span>.</span><span>MOUNTMGRCONTROLTYPE</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>.</span><span>METHOD_BUFFERED</span><span>,</span><span> </span><span>windows</span><span>.</span><span>FILE_READ_ACCESS</span><span> </span><span>|</span><span> </span><span>windows</span><span>.</span><span>FILE_WRITE_ACCESS</span><span>);</span><span>
    </span><span>try</span><span> </span><span>windows</span><span>.</span><span>DeviceIoControl</span><span>(</span><span>mgmt_handle</span><span>,</span><span> </span><span>IOCTL_MOUNTMGR_CREATE_POINT</span><span>,</span><span> </span><span>&amp;</span><span>input_buf</span><span>,</span><span> </span><span>null</span><span>);</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>(the compiled executable must be run as administrator)</p>
</details>
<p>However, having the symlink in place doesn&#39;t solve anything on its own:</p>
<pre><code>&gt; cd /D ð¤­¢:\
The filename, directory name, or volume label syntax is incorrect.
</code></pre>
<p>This is because there&#39;s no way to get the drive-absolute Win32 path <code>ð¤­¢:\</code> to end up as the relevant NT path. As mentioned earlier, the behavior of <code>RtlDosPathNameToNtPathName_U</code> is what matters, and we can verify that it will not convert a drive-absolute path with a drive letter bigger than <code>U+FFFF</code> to the relevant NT path:</p>
<pre><code>C:\foo&gt; paths.exe ð¤­¢:\foo
path type: .Relative
  nt path: \??\C:\foo\ð¤­¢:\foo
</code></pre>

<h3>Path classification mismatch<a id="path-classification-mismatch" href="#path-classification-mismatch">ðŸ”—</a></h3>
<p>It&#39;s very common for path-related functions to be written without the use of system-specific APIs, which means that there&#39;s high potential for a mismatch between how <code>RtlDosPathNameToNtPathName_U</code> treats a file path and how something like a particular implementation of <code>path.isAbsolute</code> treats a file path.</p>
<p>As a random example, Rust only considers paths with <code>A</code>-<code>Z</code> drive letters as absolute:</p>
<pre><code><span>use</span><span> </span><span>std</span><span>::</span><span>path</span><span>::</span><span>Path</span><span>;</span><span>

</span><span>fn</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span><span>
    </span><span>println</span><span>!</span><span>(</span><span>&#34;C:\\ {}&#34;</span><span>,</span><span> </span><span>Path</span><span>::</span><span>new</span><span>(</span><span>&#34;C:\\foo&#34;</span><span>).</span><span>is_absolute</span><span>());</span><span>
    </span><span>println</span><span>!</span><span>(</span><span>&#34;+:\\ {}&#34;</span><span>,</span><span> </span><span>Path</span><span>::</span><span>new</span><span>(</span><span>&#34;+:\\foo&#34;</span><span>).</span><span>is_absolute</span><span>());</span><span>
    </span><span>println</span><span>!</span><span>(</span><span>&#34;â‚¬:\\ {}&#34;</span><span>,</span><span> </span><span>Path</span><span>::</span><span>new</span><span>(</span><span>&#34;â‚¬:\\foo&#34;</span><span>).</span><span>is_absolute</span><span>());</span><span>
</span><span>}</span><span>
</span></code></pre>
<pre><code>&gt; rustc test.rs

&gt; test.exe
C:\ true
+:\ false
â‚¬:\ false
</code></pre>
<p>Whether or not this represents a problem worth fixing is left as an exercise for the reader (I genuinely don&#39;t know if it is a problem), but there&#39;s a second wrinkle (hinted at previously) involving text encoding that can make something like an <code>isAbsolute</code> implementation return different results for the same path. This wrinkle is the reason I looked into this whole thing in the first place, as when I was doing <a href="https://github.com/ziglang/zig/pull/25993">some work on Zig&#39;s path-related functions recently</a> I realized that looking at <code>path[0]</code>, <code>path[1]</code>, and <code>path[2]</code> for a pattern like <code>C:\</code> will look at different parts of the path depending on the encoding. That is, for something like <code>â‚¬:\</code> (which is made up of the code points <code>&lt;U+20AC&gt;&lt;U+003A&gt;&lt;U+005C&gt;</code>):</p>
<ul>
<li>Encoded as WTF-16 where <code>U+20AC</code> can be encoded as the single <code>u16</code> code unit <code>0x20AC</code>, that&#39;d mean <code>path[0]</code> will be <code>0x20AC</code>, <code>path[1]</code> will be <code>0x3A</code> (<code>:</code>), and <code>path[2]</code> will be <code>0x5C</code> (<code>\</code>), which looks like a drive-absolute path</li>
<li>Encoded as <a href="https://wtf-8.codeberg.page/">WTF-8</a> where <code>U+20AC</code> is encoded as three <code>u8</code> code units (<code>0xE2 0x82 0xAC</code>), that&#39;d mean <code>path[0]</code> will be <code>0xE2</code>, <code>path[1]</code> will be <code>0x82</code>, and <code>path[2]</code> will be <code>0xAC</code>, meaning it will look nothing like a drive-absolute path</li>
</ul>
<p>So, to write an implementation that treats paths the same regardless of encoding, <a href="https://codeberg.org/ziglang/zig/src/commit/bfe3317059131ab552f7583b88d6bc82609d198c/lib/std/os/windows.zig#L2564-L2585"><em>some</em> decision has to be made</a>:</p>
<ul>
<li>If strict compatibility with <code>RtlDetermineDosPathNameType_U</code>/<code>RtlDosPathNameToNtPathName_U</code> is desired, decode the first code point and check for <code>&lt;= 0xFFFF</code> when dealing with WTF-8 (this is the option I went with for the Zig standard library, but I&#39;m not super happy about it)</li>
<li>If you want to be able to always check <code>path[0]</code>/<code>path[1]</code>/<code>path[2]</code> and don&#39;t care about non-ASCII drive letters, check for <code>path[0] &lt;= 0x7F</code> regardless of encoding</li>
<li>If you don&#39;t care about anything other than the standard <code>A</code>-<code>Z</code> drive letters, then check for that explicitly (<a href="https://github.com/rust-lang/rust/blob/3ff30e7eafc1da7104c3960187d17939172428ed/library/std/src/sys/path/windows_prefix.rs#L132-L134">this is what Rust does</a>)</li>
</ul>
<h3>That&#39;s NOT the EURO drive<a id="that-s-not-the-euro-drive" href="#that-s-not-the-euro-drive">ðŸ”—</a></h3>
<p>Something bizarre that I found with this whole thing is that the <code>kernel32.dll</code> API <a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setvolumemountpointw"><code>SetVolumeMountPointW</code></a> has it&#39;s own unique quirk when dealing with non-ASCII drive letters. Specifically, this code (attempting to create the drive <code>â‚¬:\</code>) will succeed:</p>
<pre><code><span>const</span><span> </span><span>std</span><span> </span><span>=</span><span> </span><span>@import</span><span>(</span><span>&#34;std&#34;</span><span>);</span><span>
</span><span>const</span><span> </span><span>windows</span><span> </span><span>=</span><span> </span><span>std</span><span>.</span><span>os</span><span>.</span><span>windows</span><span>;</span><span>
</span><span>const</span><span> </span><span>L</span><span> </span><span>=</span><span> </span><span>std</span><span>.</span><span>unicode</span><span>.</span><span>wtf8ToWtf16LeStringLiteral</span><span>;</span><span>

</span><span>extern</span><span> </span><span>&#34;kernel32&#34;</span><span> </span><span>fn</span><span> </span><span>SetVolumeMountPointW</span><span>(</span><span>
    </span><span>VolumeMountPoint</span><span>:</span><span> </span><span>windows</span><span>.</span><span>LPCWSTR</span><span>,</span><span>
    </span><span>VolumeName</span><span>:</span><span> </span><span>windows</span><span>.</span><span>LPCWSTR</span><span>,</span><span>
</span><span>)</span><span> </span><span>callconv</span><span>(.</span><span>winapi</span><span>)</span><span> </span><span>windows</span><span>.</span><span>BOOL</span><span>;</span><span>

</span><span>pub</span><span> </span><span>fn</span><span> </span><span>main</span><span>()</span><span> </span><span>!</span><span>void</span><span> </span><span>{</span><span>
    </span><span>const</span><span> </span><span>volume_name</span><span> </span><span>=</span><span> </span><span>L</span><span>(</span><span>&#34;\\\\?\\Volume{18123456-abcd-efab-cdef-1234abcdabcd}\\&#34;</span><span>);</span><span>
    </span><span>const</span><span> </span><span>mount_point</span><span> </span><span>=</span><span> </span><span>L</span><span>(</span><span>&#34;â‚¬:\\&#34;</span><span>);</span><span>
    </span><span>if</span><span> </span><span>(</span><span>SetVolumeMountPointW</span><span>(</span><span>mount_point</span><span>,</span><span> </span><span>volume_name</span><span>)</span><span> </span><span>==</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span>
        </span><span>const</span><span> </span><span>err</span><span> </span><span>=</span><span> </span><span>windows</span><span>.</span><span>GetLastError</span><span>();</span><span>
        </span><span>std</span><span>.</span><span>debug</span><span>.</span><span>print</span><span>(</span><span>&#34;{any}\n&#34;</span><span>,</span><span> </span><span>.{</span><span>err</span><span>});</span><span>
        </span><span>return</span><span> </span><span>error</span><span>.</span><span>Failed</span><span>;</span><span>
    </span><span>}</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>However, when we look at the Object Manager, the <code>â‚¬:</code> symlink won&#39;t exist... but <code>Â¬:</code> will:</p>
<p><img src="https://www.ryanliptak.com/images/windows-drive-letters-are-not-limited-to-a-z/notdrive.png"/>
</p>
<p>My time <a href="https://www.ryanliptak.com/blog/every-rc-exe-bug-quirk-probably/">dealing extensively with Windows quirks</a> made me recognize what might be happening here: <code>0x20AC</code> is likely being truncated to <code>0xAC</code> by <code>SetVolumeMountPointW</code>, and <code>U+00AC</code> happens to be <code>Â¬</code>. If that is indeed what&#39;s going on, it seems pretty strange to truncate the drive letter instead of reject the path, but it also makes sense that non-ASCII drive letters are an edge case that no one has really thought about at all.</p>
<h2>Wrapping up<a id="wrapping-up" href="#wrapping-up">ðŸ”—</a></h2>
<p>I have no idea if anything I wrote about here is novel, although my cursory searches didn&#39;t turn up much. The only mention of non-<code>A</code>-<code>Z</code> drive letters I&#39;m currently aware of is from the article <a href="https://googleprojectzero.blogspot.com/2016/02/the-definitive-guide-on-win32-to-nt.html">The Definitive Guide on Win32 to NT Path Conversion</a> which says:</p>
<blockquote>
<p>it&#39;s natural to assume that drive &#34;letters&#34; can only be A through Z. It turns out the <code>RtlGetFullPathName_U</code> API does not enforce this requirement, although the Explorer shell and command prompt almost certainly do. Therefore as long as the second character of a path is a colon, the conversion will treat it as a Drive Absolute or Drive Relative path. Of course if the DosDevices object directory doesn&#39;t have an appropriate symbolic link it&#39;s not going to do you much good.</p>
</blockquote>
<p>Well, it turns out that the command prompt also doesn&#39;t enforce the requirement, and I&#39;d guess that there&#39;s at least some more weirdness around this quirk that&#39;s waiting to be discovered.</p>


</div></div>
  </body>
</html>
