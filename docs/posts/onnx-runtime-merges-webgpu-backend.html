<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/microsoft/onnxruntime/pull/14579">Original</a>
    <h1>ONNX Runtime merges WebGPU backend</h1>
    
    <div id="readability-page-1" class="page"><div>
        <div>
  
  <task-lists disabled="" sortable="">
    <div>
      <h3 dir="auto">Description</h3>
<p dir="auto">This change introduced the following new components into ONNX Runtime Web:</p>
<ul dir="auto">
<li>JavaScript Execution Provider (JSEP)
<ul dir="auto">
<li>Asynchronized inferencing execution powered by Emscripten&#39;s Asyncify</li>
</ul>
</li>
<li>WebGPU backend implemented in TypeScript
<ul dir="auto">
<li>initial implementation of kernels:
<ul dir="auto">
<li>elementwise operators (22)</li>
<li>binary operators (5)</li>
<li>tensor: Shape, Reshape, Transpose, Gemm</li>
<li>nn: Conv, {Global}Maxpool, {Global}AveragePool</li>
</ul>
</li>
</ul>
</li>
</ul>
<p dir="auto">Code need to be polished. still working on it.</p>
<h2 dir="auto">Q&amp;A</h2>
<p dir="auto">What is JSEP?</p>
<blockquote>
<p dir="auto">JSEP, aka JavaScript Execution Provider, is a new ONNXRuntime execution provider that specifically works on Web environment (browsers). JSEP allows JavaScript code to kick in from various places when ONNX Runtime inferences a model.</p>
</blockquote>
<p dir="auto">Why JSEP?</p>
<blockquote>
<p dir="auto">JSEP is a hybrid mode EP that contains both C/C++ and TypeScript/JavaScript implementation. There are 2 strong reasons why we introduces JSEP:</p>
<ol dir="auto">
<li>the C/C++ part helps JSEP to leverage ONNX Runtime&#39;s capabilities as much as possible including graph transformer, optimizers and also the capabilities to fallback to CPU EP. TypeScript/JavaScript helps JSEP to develop and debug much easier in the browser for the kernel implementation.</li>
<li>the requirement of asynchronized execution from JavaScript API (eg. <code>buffer.mapAsync()</code>) makes it impossible to run <code>OrtRun()</code> in a synchronized context (see &#34;async problem&#34; section below). This is done by using Emscripten&#39;s Asyncify.</li>
</ol>
</blockquote>
<p dir="auto">What is WebGPU?</p>
<blockquote>
<p dir="auto">WebGPU is the new GPU API that available in browser. It&#39;s one of the only 2 APIs that currently available to access the GPU from browser (the other is WebGL).</p>
</blockquote>
<p dir="auto">What is the async problem and why we have the problem?</p>
<blockquote>
<p dir="auto">The &#34;async problem&#34; is a problem that you cannot call an async function in a synchronous context. Think about the following C++ code:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// C-style declarations (API)
typedef void (*ON_COMPLETE)(PVOID state, DATA *data);
void read_data_from_file(FILEHANDLE file, ON_COMPLETE on_complete);

// implementation
DATA * my_impl_read_data_from_file_sync(FILEHANDLE file) {
  // how to implement?
}"><pre><span><span>//</span> C-style declarations (API)</span>
<span>typedef</span> <span>void</span> (*ON_COMPLETE)(PVOID state, DATA *data);
<span>void</span> <span>read_data_from_file</span>(FILEHANDLE file, ON_COMPLETE on_complete);

<span><span>//</span> implementation</span>
DATA * <span>my_impl_read_data_from_file_sync</span>(FILEHANDLE file) {
  <span><span>//</span> how to implement?</span>
}</pre></div>
<p dir="auto">The answer is, it&#39;s impossible to implement this function. Usually we try to find a sync version API, or launch a thread to call the async function and sync-wait on the main thread. Unfortunately, in browser environment, neither is possible.</p>
<p dir="auto">WebGPU does not offer any synchronized API for data downloading (GPU to CPU). This is the only operation that MUST be async. As <code>OrtRun()</code> will eventually call into DataTransfer for copy data from GPU to CPU, and <code>OrtRun()</code> is a synchronized function, this cannot be done in normal way.</p>
</blockquote>
<p dir="auto">What is Emscripten? How is the Asyncify feature resolved the problem?</p>
<blockquote>
<p dir="auto">Emscripten is the C/C++ compiler for WebAssembly. It&#39;s what we use to compile ORT and generates the WebAssembly artifacts which runs on browsers.</p>
<p dir="auto">Asyncify is a <a href="https://emscripten.org/docs/porting/asyncify.html" rel="nofollow">compiler feature</a> that allows calling async functions from a synchronized context. In short, it generates code to unwind and rewind call stack to emulate async execution. With this feature, we are able to call the async function inside <code>OrtRun()</code> call.</p>
</blockquote>
<h2 dir="auto">Design Overview</h2>
<p dir="auto"><strong>Inter-op</strong></p>
<p dir="auto">JSEP is doing pretty much same thing to just another EP. It exposes an interface for inter-op with JavaScript, which is defined in onnxruntime/wasm/js_internal_api.js:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// init JSEP
Module[&#34;jsepInit&#34;] = function (backend, alloc, free, copy, copyAsync, createKernel, releaseKernel, run) {
    Module.jsepBackend = backend;
    Module.jsepAlloc = alloc;
    Module.jsepFree = free;
    Module.jsepCopy = copy;
    Module.jsepCopyAsync = copyAsync;
    Module.jsepCreateKernel = createKernel;
    Module.jsepReleaseKernel = releaseKernel;
    Module.jsepRun = run;
};"><pre><span>// init JSEP</span>
<span>Module</span><span>[</span><span>&#34;jsepInit&#34;</span><span>]</span> <span>=</span> <span>function</span> <span>(</span><span>backend</span><span>,</span> <span>alloc</span><span>,</span> <span>free</span><span>,</span> <span>copy</span><span>,</span> <span>copyAsync</span><span>,</span> <span>createKernel</span><span>,</span> <span>releaseKernel</span><span>,</span> <span>run</span><span>)</span> <span>{</span>
    <span>Module</span><span>.</span><span>jsepBackend</span> <span>=</span> <span>backend</span><span>;</span>
    <span>Module</span><span>.</span><span>jsepAlloc</span> <span>=</span> <span>alloc</span><span>;</span>
    <span>Module</span><span>.</span><span>jsepFree</span> <span>=</span> <span>free</span><span>;</span>
    <span>Module</span><span>.</span><span>jsepCopy</span> <span>=</span> <span>copy</span><span>;</span>
    <span>Module</span><span>.</span><span>jsepCopyAsync</span> <span>=</span> <span>copyAsync</span><span>;</span>
    <span>Module</span><span>.</span><span>jsepCreateKernel</span> <span>=</span> <span>createKernel</span><span>;</span>
    <span>Module</span><span>.</span><span>jsepReleaseKernel</span> <span>=</span> <span>releaseKernel</span><span>;</span>
    <span>Module</span><span>.</span><span>jsepRun</span> <span>=</span> <span>run</span><span>;</span>
<span>}</span><span>;</span></pre></div>
<p dir="auto">This simple JavaScript snippet defines all language barrier level functions that requires by JSEP to achieve implementing kernels and data transfers using JavaScript inside ONNX Runtime:</p>
<ul dir="auto">
<li><code>jsepBackend</code>: assign the singleton object to webassembly module</li>
<li><code>jsepAlloc</code> and <code>jsepFree</code>: implementation of data transfer&#39;s Alloc() and Free()</li>
<li><code>jsepCopy</code>: synchronized copy ( GPU to GPU, CPU to GPU)</li>
<li><code>jsepCopyAsync</code>: asynchronized copy ( GPU to CPU)</li>
<li><code>jsepCreateKernel</code> and <code>jsepReleaseKernel</code>: a corresponding object that maintained in JS to match lifecycle of Kernel in ORT</li>
<li><code>jsepRun</code>: OpKernel::Compute() should call into this</li>
</ul>
<p dir="auto">The abstraction above allows to tie as little as possible connections and dependencies between C/C++ and TypeScript/JavaScript.</p>
<p dir="auto"><strong>Resource Management</strong></p>
<p dir="auto">Lifecycle of tensor data and kernels are managed by ORT(C/C++) but the implementation are left to JavaScript. JavaScript code are responsible to implement the callbacks correctly.</p>
<p dir="auto">For WebGPU, the GPU data is managed by JavaScript using a singleton map (tensot_data_id =&gt; GPUBuffer). GPU pipeline is managed as singleton. Shaders are managed using a singletonmap (shader_key =&gt; gpu_program), while shader_key is generated by cache_key (OP specific, including attributes) and input shapes.</p>
<p dir="auto"><strong>about data transfer</strong></p>
<p dir="auto"><strong>run kernel in JS</strong></p>
<p dir="auto">Kernel class constructor calls once <code>jsepCreateKernel()</code> with an optional per-kernel specific serialization to pass attributes into JavaScript.</p>
<p dir="auto"><code>Compute()</code> are implemented in a way that a metadata serialization is performed in a base class and JavaScript code can access the data using the Emscripten specific builtin macro <code>EM_ASM_*</code>.</p>
<p dir="auto"><strong>disabled features</strong></p>
<p dir="auto"><strong>prefer channels last</strong></p>
<p dir="auto"><strong>Testing code</strong></p>
    </div>
  </task-lists>
  
</div>

      </div></div>
  </body>
</html>
