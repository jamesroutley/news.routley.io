<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://johnnysswlab.com/horrible-code-clean-performance/">Original</a>
    <h1>Horrible Code, Clean Performance</h1>
    
    <div id="readability-page-1" class="page"><div><p><em>We at <strong>Johnny’s Software Lab LLC</strong> are experts in performance. If performance is in any way concern in your software project, feel free to <a href="https://johnnysswlab.com/contact/">contact us</a>.</em></p><p>When it comes to software performance, it seems there is no limit to how much one can complicate things in order to make performance improvements. Here we present a short example of optimizations went wild – horrible code with clean performance. Homage to <a href="https://www.computerenhance.com/p/clean-code-horrible-performance" target="_blank" rel="noreferrer noopener">Clean Code, Horrible Performance</a>.</p><h2>Clean Code</h2><p>Let’s say we have a class called <code>my_string</code>, that looks like this:</p><pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">class my_string {
    char* ptr;
    size_t size;
};</pre><p>The class implements a string, but not a null-terminated kind. Pointer to character block is kept in <code>ptr</code>, and the size of string is stored in <code>size</code>.</p><p>Let’s say we want to implement a <code>find_substring(substring)</code> method, which, tries to find the first occurrence of substring in a string. Here is the naive and straightforward implementation of such method:</p><pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">std::pair&lt;bool, size_t&gt; find_substring(const my_string&amp; substr) {
    if (substr.size &gt; size) {
        return { false, 0 };
    }

    size_t s = size - substr.size;
    char* ptr_str = ptr;
    char* ptr_substr = substr.ptr;
    size_t size_substr = substr.size;

    for (int i = 0; i &lt; s; ++i) {
        bool found = true;
        for (int j = 0; j &lt; size_substr; j++) {
            if (ptr_str[i + j] != ptr_substr[j]) {
                found = false;
                break;
            }
        }
        if (found) {
            return { true, i };
        }
    }

    return { false, 0 };
}</pre><p>The hot loop is on lines 10-21. The loop over <code>i</code> iterates the string, and the loop over <code>j</code> tries to find the substring inside the string at position <code>i</code>. This is a very simple and straight-forward solution.</p><h2>The Problem</h2><p>The problem with this approach is the inner loop, which iterates over the substring. It reads  the same data from the data cache to the registers over and over. The inner loop over <code>j</code> will most likely break very quickly after it starts.</p><p>From the performance point of view, it would be very convenient if the data belonging to the substring were kept in CPU registers and not the data caches. If the size of substring were known at compile-time, and small, the compiler could perform an optimization: place the whole substring in registers and never touch memory again.</p><p>In our case, the compiler doesn’t know the size of the substring. In theory, it could put a part of the substring in a register, in our case, the first part. And, when needed, grab the rest from the memory. This would be very beneficial, as part of the substring that is accessed the most is the beginning of the substring. But compilers never do that automatically.</p><p><i>Like what you are reading? Follow us on <a rel="noreferrer noopener" href="https://www.linkedin.com/company/johnysswlab" target="_blank">LinkedIn </a>, <a rel="noreferrer noopener" href="https://twitter.com/johnnysswlab" target="_blank">Twitter</a> or <a rel="noreferrer noopener" href="https://mastodon.online/@johnnysswlab" target="_blank">Mastodon</a> and get notified as soon as new content becomes available.</i></p><h2>Horrible Code</h2><p>Well, what the compiler can’t do, we can do for it. Let’s rewrite the original code by allocating a small, fixed sized array to hold the beginning of the substring. Here is the code:</p><pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">std::pair&lt;bool, size_t&gt; find_substring2(const my_string&amp; substr) {
    if (substr.size &gt; size) {
        return { false, 0 };
    }

    static constexpr size_t substring_buffer_max_size = 8;
    char substring_buffer[substring_buffer_max_size];

    // Fill the statically allocated substring        
    size_t substring_buffer_size = std::min(substring_buffer_max_size, substr.size);
    for (int i = 0; i &lt; substring_buffer_size; ++i) {
        substring_buffer[i] = substr.ptr[i];
    }

    size_t s = size - substr.size;
    char* ptr_str = ptr;
    char* ptr_substr = substr.ptr;
    size_t size_substr = substr.size;
    for (int i = 0; i &lt; s; ++i) {
        bool found = true;
        int j;
        for (j = 0; j &lt; substring_buffer_size; ++j) {
            if (ptr_str[i + j] != substring_buffer[j]) {
                found = false;
                break;
            }
        }

        if (found) {
            for (; j &lt; size_substr; ++j) {
                if (ptr_str[i + j] != ptr_substr[j]) {
                    found = false;
                    break;
                }
            }
        }

        if (found) {
            return { true, i };
        }
    }

    return { false, 0 };
}</pre><p>This code is much more complex than the original. We introduce a new fixed size array <code>substring_buffer</code> (line 7) and fill it with data from the original substring lines 11-13. In hot loop, we first check if we have a match from the <code>substring_buffer</code> (lines 22-27). If no, we break the inner loop and move to the next value of <code>i</code>. Else, we check if the rest of the <code>substring</code> is a match (lines 30-35).</p><p>The compiler actually takes this into account when generating code. Here is the assembly output:</p><div><figure><img decoding="async" width="862" height="754" src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20862%20754%22%3E%3C/svg%3E" data-src="https://johnnysswlab.com/wp-content/uploads/image-13.png" alt="" data-srcset="https://johnnysswlab.com/wp-content/uploads/image-13.png 862w, https://johnnysswlab.com/wp-content/uploads/image-13-300x262.png 300w, https://johnnysswlab.com/wp-content/uploads/image-13-768x672.png 768w" data-sizes="(max-width: 862px) 100vw, 862px"/></figure></div><p>First four characters are kept in registers <code>sil</code>, <code>dil</code>, <code>r8b</code> and <code>r9b</code>. The rest of the characters for the substring are reloaded from memory, but this is not a problem with us because comparison most of the time fails on first character of the substring. Yet, this assembly indicates it makes sense to decrease the size of <code>substring_buffer</code> to 4 characters.</p><p>It is quite clear why we call this code horrible. A developer unfamiliar with compiler optimizations would look with disgust at this code. But is it worth it? Let’s find out.</p><p><i>Like what you are reading? Follow us on <a rel="noreferrer noopener" href="https://www.linkedin.com/company/johnysswlab" target="_blank">LinkedIn </a>, <a rel="noreferrer noopener" href="https://twitter.com/johnnysswlab" target="_blank">Twitter</a> or <a rel="noreferrer noopener" href="https://mastodon.online/@johnnysswlab" target="_blank">Mastodon</a> and get notified as soon as new content becomes available.</i></p><h2>Benchmarking</h2><p>We measure the performance of this solution on both GCC 11 and Clang 15. As an input we use a string which is 256 MB in size. We are looking for a substring that is not present; this will make sure that the whole string is processed. Here are the runtimes:</p><figure><table><thead><tr><th></th><th>Original</th><th>With substring caching</th></tr></thead><tbody><tr><td>GCC 11</td><td>Runtime: 0.368 s</td><td>Runtime: 0.255 s</td></tr><tr><td>Clang 15</td><td>Runtime: 0.272 s</td><td>Runtime: 0.169 s</td></tr></tbody></table></figure><p>On both compilers the runtime of the original is worse and the optimized version is both faster and more efficient.</p><h2>Bottom Line</h2><p>Is this code horrible? Yes, it is.</p><p>Is it fast? As demonstrated, it is fast.</p><p>Is this performance portable? The speed improvement is portable between GCC and CLANG. It would be possible for a compiler to make this optimization without our intervention, but my gut feeling suggest that compilers that do this are rare.</p><p>Is it worth it? This is debatable and to a certain extent more a preference than a fact. For me personally, you should never write such a code as a first implementation. It is messy, and the intention is not clear to an average developer. But, if there is a performance bottleneck that you need to address, then this solution would be acceptable.</p><p><i>Like what you are reading? Follow us on <a rel="noreferrer noopener" href="https://www.linkedin.com/company/johnysswlab" target="_blank">LinkedIn </a>, <a rel="noreferrer noopener" href="https://twitter.com/johnnysswlab" target="_blank">Twitter</a> or <a rel="noreferrer noopener" href="https://mastodon.online/@johnnysswlab" target="_blank">Mastodon</a> and get notified as soon as new content becomes available.</i></p></div></div>
  </body>
</html>
