<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://artem.krylysov.com/blog/2024/06/28/timeseries-indexing-at-scale/">Original</a>
    <h1>Timeseries Indexing at Scale</h1>
    
    <div id="readability-page-1" class="page"><article>
        

        


        <div>
<p>Note</p>
<p>This blog post was co-authored with May Lee and is cross-posted on the <a href="https://www.datadoghq.com/blog/engineering/timeseries-indexing-at-scale/" target="_blank">Datadog blog</a>.</p>
</div>
<p>Datadog collects billions of events from millions of hosts every minute and that number keeps growing and fast. Our data volumes grew 30x between 2017 and 2022. On top of that, the kind of queries we receive from our users has changed significantly. Why? Because our customers have grown in sophistication: they run more complex stacks, want to monitor more data, and run more complex analyses. That, in turn, puts pressure on our timeseries data store.</p>
<p>Data stores have a number of tricks in their bag to offer good performance. One of the most critical ones is the judicious use of indices, a key data structure that can make queries fast and efficient, or unbearably slow. Over the years, our homegrown indices that were put in place in 2016 became a performance bottleneck for queries and a source of increased maintenance. We knew that we had to learn from these challenges and come up with something better.</p>
<p>This blog post provides an overview of the Datadog timeseries database and the challenges of timeseries indexing at scale. We’ll compare the performance and reliability of two generations of indexing services.</p>
<div id="metrics-platform-overview">
<h3>Metrics platform overview<a href="#metrics-platform-overview" title="Permalink to this headline"> #</a></h3>
<p>From a high level, the metrics platform consists of three major components: intake, storage, and query. As shown in the image below, the Datadog Agent receives data and sends it to the load balancer. The data then gets ingested by metrics intake and written to the message broker. The metrics storage component then reads the data from the message broker and stores it on a disk in the timeseries database. When a Datadog user sends a query (see the example below), the query is sent to the API gateway and gets executed by the metrics query engine.</p>
<div>
<p><img alt="" src="https://artem.krylysov.com/images/2024-timeseries-indexing-at-scale/architecture.png"/></p><p>A high-level overview of the metrics platform architecture</p>
</div>
<div id="intake">
<h4>Intake<a href="#intake" title="Permalink to this headline"> #</a></h4>
<p>Metrics intake is responsible for ingesting a stream of data points that consist of a metric name, zero or more tags, a timestamp, and a value. Tags are a way of adding dimensions to Datadog metrics so they can be filtered, aggregated, and compared. A tag can be in the format of <span>value</span> or <span>key:value</span>. Commonly used tag keys are <span>env</span>, <span>host</span>, and <span>service</span>. Additionally, Datadog allows users to submit custom tags. The timestamp records the time when the data point was generated. Finally, the value is a numerical value that can track anything about the monitored environment, from CPU usage and error rates to the number of user sign-ups.</p>
<p>This is what a typical ingested data point looks like:</p>
<div>
<p><img alt="" src="https://artem.krylysov.com/images/2024-timeseries-indexing-at-scale/point.png"/></p><p>A metric named containerd.cpu.total, with the tags eng:prod, service:event-consumer, and host:I-ABC, a timestamp, and a value</p>
</div>
<p>The ingested points are processed and written into <a href="https://www.youtube.com/watch?v=J7RRJ1iBeAg" target="_blank">Kafka</a>, a durable message broker. Kafka allows multiple services and teams to consume the same data stream independently and for different purposes, such as analysis, indexing, and archiving for long-term storage.</p>
</div>
<div id="storage">
<h4>Storage<a href="#storage" title="Permalink to this headline"> #</a></h4>
<p>One of these Kafka consumers is the short-term metrics storage layer, which is split into two individually deployed services. The first one is the Timeseries Database service, which stores the timeseries identifiers, timestamps, and values as tuples of <span>&lt;timeseries_id, timestamp, float64&gt;</span>. The second service is responsible for indexing the identifiers and tags associated with them and stores them as tuples of <span>&lt;timeseries_id, tags&gt;</span>. This is the Timeseries Index service, which is a custom database built on top of RocksDB and is responsible for filtering and grouping timeseries points during query execution.</p>
<div>
<p><img alt="" src="https://artem.krylysov.com/images/2024-timeseries-indexing-at-scale/metrics-storage.png"/></p><p>The metrics storage layer consists of the Timeseries Index and Timeseries Database (DB)</p>
</div>
</div>
<div id="query">
<h4>Query<a href="#query" title="Permalink to this headline"> #</a></h4>
<p>The distributed query layer connects to the individual timeseries index nodes, fetches intermediate query results from the timeseries database, and combines them.</p>
<div>
<p><img alt="" src="https://artem.krylysov.com/images/2024-timeseries-indexing-at-scale/metrics-storage-query.png"/></p><p>The metrics query service communicating with the Timeseries Index and Timeseries DB</p>
</div>
<p>This is what a typical query looks like:</p>
<div>
<p><img alt="" src="https://artem.krylysov.com/images/2024-timeseries-indexing-at-scale/query.png"/></p><p>A metric name with tag filters, grouped by host and aggregated using the average function</p>
</div>
<p>Filters are used to narrow down a queried metric to a specific subset of data points, based on their tags. They are particularly useful when the same metric is submitted by many hosts and services, but you need to look at a specific one. In this particular example, the <span>env:prod AND <span>service:event-consumer</span></span> filter tells the query engine to include only data points that come from the service called <span><span>event-consumer</span></span> that is running in the production environment.</p>
<p>The groups, which are also based on tags, drive the query results. The grouping process produces a single timeseries, or a single line in a line graph, for each unique group. For example, if you have hundreds of hosts spread across four services, grouping by <span>service</span> allows you to graph one line for each service.</p>
<p>The data points within each group are then combined according to the aggregator function. In the following example, the <span>avg</span> aggregator computes an average value across all hosts for a specific service, grouped by environment:</p>
<div>
<p><img alt="" src="https://artem.krylysov.com/images/2024-timeseries-indexing-at-scale/metrics-graph.png"/></p><p>A metrics query result visualized in a Datadog graph</p>
</div>
</div>
</div>
<div id="original-indexing-service">
<h3>Original indexing service<a href="#original-indexing-service" title="Permalink to this headline"> #</a></h3>
<p>Now that you know where the timeseries database fits into the architecture, let’s get back to indexing. We index timeseries points by their tags to make query execution more efficient and avoid scanning the data for the entire metric when only a small subset is requested. Scanning the data for the entire metric would be similar to a full table scan in SQL databases.</p>
<p>Datadog’s original indexing strategy relied heavily on automatically generating indexes based on the query log of a live system. Every time the system encountered a slow or resource-consuming query, it would record the information about the received query in a log that was periodically analyzed by a background process. The process looked at the number of queries, the query execution time, the number of input (scanned) timeseries identifiers, and the number of output (returned) identifiers. Based on these parameters, the process would then find and create indexes for highly selective queries, meaning queries with high input-to-output ratios.</p>
<p>Additionally, the indexes that became obsolete and stopped receiving queries would get removed from the system. Automatically generated indexes were highly effective in reducing the amount of CPU and memory resources spent on repetitive queries. The indexes would create materialized views of resource-consuming queries, turning a slow full table scan into a single key-value lookup.</p>
<div id="design">
<h4>Design<a href="#design" title="Permalink to this headline"> #</a></h4>
<p>The original timeseries index service was implemented in Go with the help of embedded data stores: <a href="https://www.sqlite.org/" target="_blank">SQLite</a> and <a href="https://rocksdb.org/" target="_blank">RocksDB</a>. Embedded means these data stores are not running on a separate server or a standalone process, and instead are integrated directly into an application. We used SQLite, the <a href="https://www.sqlite.org/mostdeployed.html" target="_blank">most widely</a> deployed SQL engine, to store metadata such as the index definitions and the query log:</p>
<pre><code><span>CREATE</span><span> </span><span>TABLE</span><span> </span><span>index_definitions</span><span> </span><span>(</span><span>
    </span><span>metric_name</span><span> </span><span>TEXT</span><span>,</span><span>
    </span><span>filter_tags</span><span> </span><span>TEXT</span><span>,</span><span>
    </span><span>query_count</span><span> </span><span>INTEGER</span><span>,</span><span>    </span><span>-- number of times the index was queried
</span><span>    </span><span>timestamp</span><span> </span><span>INTEGER</span><span>,</span><span>
    </span><span>PRIMARY</span><span> </span><span>KEY</span><span> </span><span>(</span><span>metric</span><span>,</span><span> </span><span>filters</span><span>)</span><span>
</span><span>);</span><span>

</span><span>CREATE</span><span> </span><span>TABLE</span><span> </span><span>query_log</span><span> </span><span>(</span><span>
    </span><span>metric_name</span><span> </span><span>TEXT</span><span>,</span><span>
    </span><span>filter_tags</span><span> </span><span>TEXT</span><span>,</span><span>
    </span><span>inputs</span><span> </span><span>INTEGER</span><span>,</span><span>     </span><span>-- number of input (scanned) ids
</span><span>    </span><span>outputs</span><span> </span><span>INTEGER</span><span>,</span><span>    </span><span>-- number of output (returned) ids
</span><span>    </span><span>duration_msec</span><span> </span><span>INTEGER</span><span>,</span><span>
    </span><span>timestamp</span><span> </span><span>INTEGER</span><span>,</span><span>
    </span><span>PRIMARY</span><span> </span><span>KEY</span><span> </span><span>(</span><span>query_id</span><span>)</span><span>
</span><span>);</span></code></pre>
<p>The index definition table was read-heavy, updated infrequently and cached entirely in memory. The query log was bulk updated in the background outside of the ingest and query paths. The flexibility of SQL was convenient for debugging because we could easily inspect and modify the tables using the sqlite3 CLI.</p>
<p>The heavy-lifting was the handling of all writes, required for indexing trillions of events per day, and done using RocksDB. RocksDB is a key-value store that powers production databases and indexing services at big tech companies such as <a href="https://engineering.fb.com/2021/07/22/data-infrastructure/mysql/" target="_blank">Meta</a>, <a href="https://blogs.bing.com/Engineering-Blog/october-2021/RocksDB-in-Microsoft-Bing" target="_blank">Microsoft</a>, and <a href="https://netflixtechblog.com/application-data-caching-using-ssds-5bf25df851ef" target="_blank">Netflix</a>. The Datadog timeseries index service maintained three RocksDB databases per node: Tagsets, Metrics, and Indexes.</p>
<div>
<p><img alt="" src="https://artem.krylysov.com/images/2024-timeseries-indexing-at-scale/original-dbs.png"/></p><p>The data stores used by the Timeseries Index</p>
</div>
<p>The Tagsets database stored a mapping of timeseries IDs to tags associated with them. The key was the timeseries ID and the value was the set of tags. If you consider these six data points:</p>
<table>
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr><th><p>Metric Name</p></th>
<th><p>Timeseries ID</p></th>
<th><p>Tags</p></th>
</tr>
</thead>
<tbody>
<tr><td><p>cpu.total</p></td>
<td><p>1</p></td>
<td><p>env:prod,service:web,host:i-187</p></td>
</tr>
<tr><td><p>cpu.total</p></td>
<td><p>2</p></td>
<td><p>env:prod,service:web,host:i-223</p></td>
</tr>
<tr><td><p>cpu.total</p></td>
<td><p>3</p></td>
<td><p>env:staging,service:web,host:i-398</p></td>
</tr>
<tr><td><p>cpu.total</p></td>
<td><p>7</p></td>
<td><p>env:prod,service:db,host:i-409</p></td>
</tr>
<tr><td><p>cpu.total</p></td>
<td><p>8</p></td>
<td><p>env:prod,service:db,host:i-543</p></td>
</tr>
<tr><td><p>cpu.total</p></td>
<td><p>9</p></td>
<td><p>env:staging,service:db,host:i-681</p></td>
</tr>
</tbody>
</table>
<p>This is how the data was stored in the Tagsets database:</p>
<table>
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr><th><p>Key (timeseries ID)</p></th>
<th><p>Value (tags)</p></th>
</tr>
</thead>
<tbody>
<tr><td><p>1</p></td>
<td><p>env:prod,service:web,host:i-187</p></td>
</tr>
<tr><td><p>2</p></td>
<td><p>env:prod,service:web,host:i-223</p></td>
</tr>
<tr><td><p>3</p></td>
<td><p>env:staging,service:web,host:i-398</p></td>
</tr>
<tr><td><p>7</p></td>
<td><p>env:prod,service:db,host:i-409</p></td>
</tr>
<tr><td><p>8</p></td>
<td><p>env:prod,service:db,host:i-543</p></td>
</tr>
<tr><td><p>9</p></td>
<td><p>env:staging,service:db,host:i-681</p></td>
</tr>
</tbody>
</table>
<p>And the Metrics database contained a list of timeseries IDs per metric:</p>
<table>
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr><th><p>Key (metric)</p></th>
<th><p>Value (timeseries ID)</p></th>
</tr>
</thead>
<tbody>
<tr><td><p>cpu.total</p></td>
<td><p>1,2,3,7,8,9</p></td>
</tr>
</tbody>
</table>
<p>The Tagsets and Metrics databases alone were enough to run queries. Consider the query <span>cpu.total{service:web AND <span>host:i-187}</span></span>. To execute it, first you need to get all the timeseries IDs for the metric <span>cpu.total</span> from the Metrics database. This then translates into a single RocksDB key-value lookup for the key <span>cpu.total</span>, which returns the values: <span>1,2,3,7,8,9</span>.</p>
<p>After we get all the timeseries IDs, we query each ID from the Tagsets database to check whether the associated tags matched the filters. The approach was similar to full table scans in SQL databases where we had to look at all possible tag sets for the metric. Its main downside was that the number of Tagsets lookups grew linearly with the number of timeseries per metric, which in some cases was a challenge for high cardinality metrics. In this particular example, we needed to look up seven keys in total; one key from the Metrics database and six keys from the Tagsets database, one key for each timeseries ID.</p>
<p>To avoid full scans, resource-consuming queries were indexed in the Indexes RocksDB database. Every resource-consuming query was logged in the query_log SQLite table. Periodically, a background process queried the table and would create a new index in the index_definitions table for those resource-consuming queries. The ingestion path checked whether the ingested timeseries belonged to an index, and if it did, the ID would be written to the Indexes database in addition to the Tagsets and Metrics databases.</p>
<div>
<p><img alt="" src="https://artem.krylysov.com/images/2024-timeseries-indexing-at-scale/original-components.png"/></p><p>How the data stores were used by the index query, ingestion, and generator</p>
</div>
<p>This is how the Indexes database would look like if we created two indexes for the metric <span>cpu.total</span>; one index for the <span>service:web</span>, <span><span>host:i-187</span></span> filters and another for the <span>service:db</span> filter.</p>
<table>
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr><th><p>Key (metric;tags)</p></th>
<th><p>Value (timeseries IDs)</p></th>
</tr>
</thead>
<tbody>
<tr><td><p>cpu.total;service:web,host:i-187</p></td>
<td><p>1</p></td>
</tr>
<tr><td><p>cpu.total;service:db</p></td>
<td><p>7,8,9</p></td>
</tr>
</tbody>
</table>
<p>Now, if someone queries <span>cpu.total{service:web AND <span>host:i-187}</span></span>, the query planner tries to match the metric and the filters against the index definitions. Because there was an index for the exact filters the query was asking for (the tags <span>service:web</span> and <span><span>host:i-187</span></span>), the query would get its results directly from the Indexes database, without having to access the Tagsets and Metrics databases. The query that previously required scanning Tagsets and making seven RocksDB lookups, now only needed a single lookup.</p>
<div id="advantages">
<h5>Advantages<a href="#advantages" title="Permalink to this headline"> #</a></h5>
<p>For Datadog Metrics, like most monitoring systems, the ratio of queried-to-written timeseries data points is typically low. On average, we see roughly only 30% of the written data being consistently queried, making this indexing strategy space efficient. We had to cover only a subset of the ingested data with indexes to make most queries perform well.</p>
</div>
<div id="challenges">
<h5>Challenges<a href="#challenges" title="Permalink to this headline"> #</a></h5>
<p>Automatically generated indexes worked well for programmatic query sources such as periodic jobs or alerting. However, user-facing queries are less predictable, and they often fell back to full table scans, leading to query timeouts and poor user experiences. Additionally, even programmatic query sources occasionally change their query patterns significantly, making the existing indexes inefficient and overloading the database with many new resource-consuming queries. It wasn’t uncommon for such incidents to require manual intervention where an engineer would remove or create indexes by hand.</p>
</div>
</div>
</div>
<div id="next-gen-indexing-service">
<h3>Next-gen indexing service<a href="#next-gen-indexing-service" title="Permalink to this headline"> #</a></h3>
<p>The manual operational toil was growing and the metrics queries were slowly getting less performant. It was time to rethink how we index timeseries data at Datadog. The new indexing strategy we came up with was inspired by the core data structure behind search engines, the inverted index. In search engines, the inverted index associates every word in a document with document identifiers that contain the word.</p>
<p>For example:</p>
<pre><code><span>documents</span> <span>=</span> <span>{</span><span>
</span>    <span>1</span><span>:</span> <span>&#34;a donut on a glass plate&#34;</span><span>,</span><span>
</span>    <span>2</span><span>:</span> <span>&#34;only the donut&#34;</span><span>,</span><span>
</span>    <span>3</span><span>:</span> <span>&#34;listen to the drum machine&#34;</span><span>,</span><span>
</span><span>}</span><span>

</span><span>index</span> <span>=</span> <span>{</span><span>
</span>    <span>&#34;a&#34;</span><span>:</span> <span>[</span><span>1</span><span>],</span><span>
</span>    <span>&#34;donut&#34;</span><span>:</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>],</span><span>
</span>    <span>&#34;on&#34;</span><span>:</span> <span>[</span><span>1</span><span>],</span><span>
</span>    <span>&#34;glass&#34;</span><span>:</span> <span>[</span><span>1</span><span>],</span><span>
</span>    <span>&#34;plate&#34;</span><span>:</span> <span>[</span><span>1</span><span>],</span><span>
</span>    <span>&#34;only&#34;</span><span>:</span> <span>[</span><span>2</span><span>],</span><span>
</span>    <span>&#34;the&#34;</span><span>:</span> <span>[</span><span>2</span><span>,</span> <span>3</span><span>],</span><span>
</span>    <span>&#34;listen&#34;</span><span>:</span> <span>[</span><span>3</span><span>],</span><span>
</span>    <span>&#34;to&#34;</span><span>:</span> <span>[</span><span>3</span><span>],</span><span>
</span>    <span>&#34;drum&#34;</span><span>:</span> <span>[</span><span>3</span><span>],</span><span>
</span>    <span>&#34;machine&#34;</span><span>:</span> <span>[</span><span>3</span><span>],</span><span>
</span><span>}</span></code></pre>
<p>A real-world example of the inverted index is an index in a book where a term references a page number:</p>
<div>
<p><img alt="" src="https://artem.krylysov.com/images/2020-fts/book-index.png"/></p><p>From Designing Data-Intensive Applications by Martin Kleppmann, 2017</p>
</div>
<p>Taking the definition of an inverted index for search engines, if we replace the term “document identifier” with “timeseries identifier” and “word” with “tag,” we have a definition for an inverted index for timeseries data. The inverted index associates every tag in a timeseries with the identifiers of timeseries that contain the tag.</p>
<div id="id1">
<h4>Design<a href="#id1" title="Permalink to this headline"> #</a></h4>
<p>The new design required rewriting almost the entire timeseries index service. It gave us an opportunity to reevaluate the tech stack we used. The new approach didn’t require maintaining any metadata, so that removed the SQLite dependency. RocksDB for the original implementation was a solid choice—we didn’t have any issues with it in production—so we kept it as the key-value store for indexes.</p>
<div>
<p><img alt="" src="https://artem.krylysov.com/images/2024-timeseries-indexing-at-scale/next-components.png"/></p><p>The next-gen architecture is simpler and with fewer components inside a single node</p>
</div>
<p>We’ll use the same six data points from the previous example to see how the next-gen strategy works. The Tagsets and Metrics databases look almost the same as in the original implementation so we won’t go over them again. The major difference between the original and next-gen implementation is the Indexes database, where we now unconditionally index every ingested tag, similarly to what search engines do with the inverted index:</p>
<table>
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr><th><p>Key (metric;tag)</p></th>
<th><p>Value (timeseries IDs)</p></th>
</tr>
</thead>
<tbody>
<tr><td><p>cpu.total;env:prod</p></td>
<td><p>1,2,7,8</p></td>
</tr>
<tr><td><p>cpu.total;env:staging</p></td>
<td><p>2,9</p></td>
</tr>
<tr><td><p>cpu.total;service:web</p></td>
<td><p>1,2,3</p></td>
</tr>
<tr><td><p>cpu.total;service:db</p></td>
<td><p>7,8,9</p></td>
</tr>
<tr><td><p>cpu.total;host:i-187</p></td>
<td><p>1</p></td>
</tr>
<tr><td><p>cpu.total;host:i-223</p></td>
<td><p>2</p></td>
</tr>
<tr><td><p>cpu.total;host:i-398</p></td>
<td><p>3</p></td>
</tr>
<tr><td><p>cpu.total;host:i-409</p></td>
<td><p>7</p></td>
</tr>
<tr><td><p>cpu.total;host:i-543</p></td>
<td><p>8</p></td>
</tr>
<tr><td><p>cpu.total;host:i-681</p></td>
<td><p>9</p></td>
</tr>
</tbody>
</table>
<p>The timeseries queries map well to the inverted index. To execute a query, the query engine makes a single key-value lookup for each queried tag and retrieves a set of relevant timeseries identifiers. Then, depending on the query, the sets are combined either by computing a set intersection or a set union.</p>
<p>For example, for the query <span>cpu.total{service:web AND <span>host:i-187}</span></span>, we do two key-value lookups from the Indexes databases. The first is to retrieve the <span>cpu.total;service:web</span> key, which returns the values: <span>1,2,3</span>. The second key-value lookup is for the key <span><span>cpu.total;host:i-187</span></span>, which returns the value: <span>1</span>.</p>
<p>To get the final result, we compute the set intersection between the two returned values, <span>1,2,3</span> and <span>1</span>, which is <span>1</span>. For the same query, the previous indexing strategy required a single lookup when the index existed, and seven lookups when there was no index. With the new indexing strategy we get a consistent query performance because the query always requires exactly two lookups.</p>
<div id="id2">
<h5>Challenges<a href="#id2" title="Permalink to this headline"> #</a></h5>
<p>One downside of this strategy is the write and space amplification. Every unique timeseries identifier has to be stored multiple times, once for each tag. With tens of tags per single timeseries, we have to store each timeseries identifier more than 10 times. Our early tests confirmed the concern that the timeseries index had to write and store noticeably more data on the disk. However, previously the timeseries index barely utilized the disk and was strictly CPU bound, so the disk space utilization wouldn’t become a problem even if we had to start storing an order of magnitude more data.</p>
<p>The write amplification and the increased CPU utilization the new strategy could bring was still a concern. However, it turned out not to be an issue, as we will see.</p>
</div>
<div id="id3">
<h5>Advantages<a href="#id3" title="Permalink to this headline"> #</a></h5>
<p>The new timeseries index doesn’t rely on the query log or a list of automatically generated indexes. It simplifies the ingestion path and makes it less CPU-intensive because it doesn’t have to match every ingested timeseries against the list of indexes to find which index it belongs to. Same is true for queries: we no longer need to do any index matching because we know that an index for every tag always exists. It also removes the need for running several CPU-consuming background jobs responsible for maintaining the indexes. The timeseries index doesn’t have to scan the query log anymore and we never need to backfill newly created indexes. Overall, while we have to write more data, we now spend less CPU time doing it.</p>
<p>On the query side, on average, indexed queries become slightly more expensive because some queries, which previously required a single key-value lookup, now require multiple lookups. On the other hand, every possible query now always has a partial index available. Since we don’t have to ever fall back to a full table scan, the worst case scenario for query performance improved and became more predictable.</p>
</div>
</div>
<div id="intranode-sharding">
<h4>Intranode Sharding<a href="#intranode-sharding" title="Permalink to this headline"> #</a></h4>
<p>Another performance issue with the original implementation was that the query path didn’t scale with CPU cores available on a node. No matter how many CPU cores a node had, a single query couldn’t use more than a single core. At some point, the single-core performance would always become a bottleneck for how quickly the service could execute a query. One of the goals of designing the new service was being able to scale ingest and queries with CPU cores. We accomplished this by making each node split RocksDB indexes into multiple isolated instances (shards), each responsible for a subset of timeseries. To ensure the data is distributed evenly across the shards, we hash the ingested timeseries IDs and assign a timeseries to a particular shard based on the hash.</p>
<div>
<p><img alt="" src="https://artem.krylysov.com/images/2024-timeseries-indexing-at-scale/db-shards.png"/></p><p>The hashes of four timeseries subsets determines which of the two RocksDB shards the timeseries are stored in</p>
</div>
<p>To execute a single query, the service fetches data from each RocksDB shard in parallel and then merges the results.</p>
<div>
<p><img alt="" src="https://artem.krylysov.com/images/2024-timeseries-indexing-at-scale/db-shards-query.png"/></p><p>The index query fetches data from two RocksDB shards</p>
</div>
<p>After running experiments in production, we settled on creating eight shards on a node with 32 CPU cores. It gave us a nearly 8x performance boost without adding too much overhead from splitting and having to merge the timeseries back. Additionally, the intranode sharding allowed us to switch to larger cloud node types with more CPU cores, reducing the total number of nodes we had to run.</p>
</div>
<div id="switching-to-rust">
<h4>Switching to Rust<a href="#switching-to-rust" title="Permalink to this headline"> #</a></h4>
<p>While the Go language worked well for most services at Datadog, it wasn’t the best fit for our resource-intensive use case. The service spent nearly 30% of CPU resources on garbage collection, and we reached the point where implementing performance optimizations was very time consuming. We needed a compiled language with no garbage collector. We decided to give Rust a chance, which turned out to be the right choice. To illustrate the performance differences, we’ll compare Go and Rust on two CPU-demanding operations that the indexing service executes.</p>
<p>When grouping timeseries, the service needs to extract tags for relevant tag keys. For example, grouping <span><span>env:prod,service:web,host:i-187</span></span> by <span>env</span> and <span>host</span> is expected to produce a group <span><span>env:prod,host:i-187</span></span>. Here is a simplified version of what we run in production:</p>
<pre><code><span>fn</span> <span>has_group</span><span>(</span><span>tag</span>: <span>&amp;</span><span>str</span><span>,</span><span> </span><span>group</span>: <span>&amp;</span><span>str</span><span>)</span><span> </span>-&gt; <span>bool</span> <span>{</span><span>
    </span><span>tag</span><span>.</span><span>len</span><span>()</span><span> </span><span>&gt;</span><span> </span><span>group</span><span>.</span><span>len</span><span>()</span><span> </span><span>&amp;&amp;</span><span> </span><span>tag</span><span>.</span><span>as_bytes</span><span>()[</span><span>group</span><span>.</span><span>len</span><span>()]</span><span> </span><span>==</span><span> </span><span>b&#39;:&#39;</span><span> </span><span>&amp;&amp;</span><span> </span><span>tag</span><span>.</span><span>starts_with</span><span>(</span><span>group</span><span>)</span><span>
</span><span>}</span><span>

</span><span>fn</span> <span>group_key</span><span>(</span><span>tags</span>: <span>&amp;</span><span>[</span><span>&amp;</span><span>str</span><span>],</span><span> </span><span>groups</span>: <span>&amp;</span><span>[</span><span>&amp;</span><span>str</span><span>])</span><span> </span>-&gt; <span>String</span> <span>{</span><span>
    </span><span>let</span><span> </span><span>mut</span><span> </span><span>key_tags</span><span> </span><span>=</span><span> </span><span>Vec</span>::<span>with_capacity</span><span>(</span><span>groups</span><span>.</span><span>len</span><span>());</span><span>
    </span><span>for</span><span> </span><span>tag</span><span> </span><span>in</span><span> </span><span>tags</span><span> </span><span>{</span><span>
        </span><span>for</span><span> </span><span>group</span><span> </span><span>in</span><span> </span><span>groups</span><span> </span><span>{</span><span>
            </span><span>if</span><span> </span><span>has_group</span><span>(</span><span>tag</span><span>,</span><span> </span><span>group</span><span>)</span><span> </span><span>{</span><span>
                </span><span>key_tags</span><span>.</span><span>push</span><span>(</span><span>*</span><span>tag</span><span>);</span><span>
            </span><span>}</span><span>
        </span><span>}</span><span>
    </span><span>}</span><span>
    </span><span>key_tags</span><span>.</span><span>sort_unstable</span><span>();</span><span>
    </span><span>key_tags</span><span>.</span><span>dedup</span><span>();</span><span>
    </span><span>key_tags</span><span>.</span><span>join</span><span>(</span><span>&#34;,&#34;</span><span>)</span><span>
</span><span>}</span></code></pre>
<p>And here is a one-to-one translation to Go:</p>
<pre><code><span>func</span><span> </span><span>hasKey</span><span>(</span><span>s</span><span> </span><span>string</span><span>,</span><span> </span><span>group</span><span> </span><span>string</span><span>)</span><span> </span><span>bool</span><span> </span><span>{</span><span>
    </span><span>return</span><span> </span><span>len</span><span>(</span><span>s</span><span>)</span><span> </span><span>&gt;</span><span> </span><span>len</span><span>(</span><span>group</span><span>)</span><span> </span><span>&amp;&amp;</span><span> </span><span>s</span><span>[</span><span>len</span><span>(</span><span>group</span><span>)]</span><span> </span><span>==</span><span> </span><span>&#39;:&#39;</span><span> </span><span>&amp;&amp;</span><span> </span><span>strings</span><span>.</span><span>HasPrefix</span><span>(</span><span>s</span><span>,</span><span> </span><span>group</span><span>)</span><span>
</span><span>}</span><span>

</span><span>func</span><span> </span><span>groupKey</span><span>(</span><span>tags</span><span> </span><span>[]</span><span>string</span><span>,</span><span> </span><span>groups</span><span> </span><span>[]</span><span>string</span><span>)</span><span> </span><span>string</span><span> </span><span>{</span><span>
    </span><span>keyTags</span><span> </span><span>:=</span><span> </span><span>make</span><span>([]</span><span>string</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>len</span><span>(</span><span>groups</span><span>))</span><span>
    </span><span>for</span><span> </span><span>_</span><span>,</span><span> </span><span>tag</span><span> </span><span>:=</span><span> </span><span>range</span><span> </span><span>tags</span><span> </span><span>{</span><span>
        </span><span>for</span><span> </span><span>_</span><span>,</span><span> </span><span>group</span><span> </span><span>:=</span><span> </span><span>range</span><span> </span><span>groups</span><span> </span><span>{</span><span>
            </span><span>if</span><span> </span><span>hasKey</span><span>(</span><span>tag</span><span>,</span><span> </span><span>group</span><span>)</span><span> </span><span>{</span><span>
                </span><span>keyTags</span><span> </span><span>=</span><span> </span><span>append</span><span>(</span><span>keyTags</span><span>,</span><span> </span><span>tag</span><span>)</span><span>
            </span><span>}</span><span>
        </span><span>}</span><span>
    </span><span>}</span><span>
    </span><span>sort</span><span>.</span><span>Strings</span><span>(</span><span>keyTags</span><span>)</span><span>
    </span><span>keyTags</span><span> </span><span>=</span><span> </span><span>slices</span><span>.</span><span>Compact</span><span>(</span><span>keyTags</span><span>)</span><span>
    </span><span>return</span><span> </span><span>strings</span><span>.</span><span>Join</span><span>(</span><span>keyTags</span><span>,</span><span> </span><span>&#34;,&#34;</span><span>)</span><span>
</span><span>}</span></code></pre>
<p>While the functions look very similar, our benchmarks on production data on an AWS c7i.xlarge instance (Intel Xeon Platinum 8488C) showed that the Rust version is three times faster than the Go version.</p>
<p>As a part of the ingest and the query paths, the indexing service needs to merge many timeseries IDs together. The IDs are integers, stored as sorted arrays. For example, merging three arrays of IDs <span>[3,6], [4,5], [1,2]</span> is expected to produce a single sorted array containing a union of all IDs: <span>[1,2,3,4,5,6]</span>. The problem can be solved with the <a href="https://en.wikipedia.org/wiki/K-way_merge_algorithm" target="_blank">k-way merge</a> algorithm using a <a href="https://en.wikipedia.org/wiki/Heap_(data_structure)" target="_blank">min-heap</a>. Luckily, the Rust and the Go standard libraries come with a heap implementation we can use to implement this. Let’s start with the Rust version, as the implementation is slightly more straightforward:</p>
<pre><code><span>#[derive(Eq)]</span><span>
</span><span>struct</span> <span>Item</span><span>&lt;&#39;</span><span>a</span><span>&gt;</span><span> </span><span>{</span><span>
    </span><span>first</span>: <span>u64</span><span>,</span><span>
    </span><span>remainder</span>: <span>&amp;</span><span>&#39;</span><span>a</span> <span>[</span><span>u64</span><span>],</span><span>
</span><span>}</span><span>

</span><span>impl</span><span> </span><span>Ord</span><span> </span><span>for</span><span> </span><span>Item</span><span>&lt;&#39;</span><span>_</span><span>&gt;</span><span> </span><span>{</span><span>
    </span><span>fn</span> <span>cmp</span><span>(</span><span>&amp;</span><span>self</span><span>,</span><span> </span><span>other</span>: <span>&amp;</span><span>Self</span><span>)</span><span> </span>-&gt; <span>Ordering</span><span> </span><span>{</span><span>
        </span><span>other</span><span>.</span><span>first</span><span>.</span><span>cmp</span><span>(</span><span>&amp;</span><span>self</span><span>.</span><span>first</span><span>)</span><span>
    </span><span>}</span><span>
</span><span>}</span><span>
</span><span>impl</span><span> </span><span>PartialOrd</span><span> </span><span>for</span><span> </span><span>Item</span><span>&lt;&#39;</span><span>_</span><span>&gt;</span><span> </span><span>{</span><span>
    </span><span>fn</span> <span>partial_cmp</span><span>(</span><span>&amp;</span><span>self</span><span>,</span><span> </span><span>other</span>: <span>&amp;</span><span>Self</span><span>)</span><span> </span>-&gt; <span>Option</span><span>&lt;</span><span>Ordering</span><span>&gt;</span><span> </span><span>{</span><span>
        </span><span>Some</span><span>(</span><span>self</span><span>.</span><span>cmp</span><span>(</span><span>other</span><span>))</span><span>
    </span><span>}</span><span>
</span><span>}</span><span>
</span><span>impl</span><span> </span><span>PartialEq</span><span> </span><span>for</span><span> </span><span>Item</span><span>&lt;&#39;</span><span>_</span><span>&gt;</span><span> </span><span>{</span><span>
    </span><span>fn</span> <span>eq</span><span>(</span><span>&amp;</span><span>self</span><span>,</span><span> </span><span>other</span>: <span>&amp;</span><span>Self</span><span>)</span><span> </span>-&gt; <span>bool</span> <span>{</span><span>
        </span><span>self</span><span>.</span><span>first</span><span> </span><span>==</span><span> </span><span>other</span><span>.</span><span>first</span><span>
    </span><span>}</span><span>
</span><span>}</span><span>

</span><span>fn</span> <span>merge_u64s</span><span>(</span><span>sets</span>: <span>&amp;</span><span>[</span><span>Vec</span><span>&lt;</span><span>u64</span><span>&gt;</span><span>])</span><span> </span>-&gt; <span>Vec</span><span>&lt;</span><span>u64</span><span>&gt;</span><span> </span><span>{</span><span>
    </span><span>let</span><span> </span><span>mut</span><span> </span><span>heap</span><span> </span><span>=</span><span> </span><span>sets</span><span>
        </span><span>.</span><span>iter</span><span>()</span><span>
        </span><span>.</span><span>map</span><span>(</span><span>|</span><span>set</span><span>|</span><span> </span><span>Item</span><span> </span><span>{</span><span>
            </span><span>first</span>: <span>set</span><span>[</span><span>0</span><span>],</span><span>
            </span><span>remainder</span>: <span>&amp;</span><span>set</span><span>[</span><span>1</span><span>..</span><span>],</span><span>
        </span><span>})</span><span>
        </span><span>.</span><span>collect</span>::<span>&lt;</span><span>BinaryHeap</span><span>&lt;</span><span>Item</span><span>&gt;&gt;</span><span>();</span><span>
    </span><span>let</span><span> </span><span>mut</span><span> </span><span>result</span><span> </span><span>=</span><span> </span><span>Vec</span>::<span>new</span><span>();</span><span>
    </span><span>// Use peek_mut instead of pop + push to avoid sifting the heap twice.
</span><span>    </span><span>while</span><span> </span><span>let</span><span> </span><span>Some</span><span>(</span><span>mut</span><span> </span><span>item</span><span>)</span><span> </span><span>=</span><span> </span><span>heap</span><span>.</span><span>peek_mut</span><span>()</span><span> </span><span>{</span><span>
        </span><span>let</span><span> </span><span>Item</span><span> </span><span>{</span><span> </span><span>first</span><span>,</span><span> </span><span>remainder</span><span> </span><span>}</span><span> </span><span>=</span><span> </span><span>&amp;*</span><span>item</span><span>;</span><span>
        </span><span>if</span><span> </span><span>result</span><span>.</span><span>last</span><span>()</span><span> </span><span>!=</span><span> </span><span>Some</span><span>(</span><span>first</span><span>)</span><span> </span><span>{</span><span>
            </span><span>result</span><span>.</span><span>push</span><span>(</span><span>*</span><span>first</span><span>);</span><span>
        </span><span>}</span><span>
        </span><span>if</span><span> </span><span>!</span><span>remainder</span><span>.</span><span>is_empty</span><span>()</span><span> </span><span>{</span><span>
            </span><span>*</span><span>item</span><span> </span><span>=</span><span> </span><span>Item</span><span> </span><span>{</span><span>
                </span><span>first</span>: <span>remainder</span><span>[</span><span>0</span><span>],</span><span>
                </span><span>remainder</span>: <span>&amp;</span><span>remainder</span><span>[</span><span>1</span><span>..</span><span>],</span><span>
            </span><span>};</span><span>
        </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span>
            </span><span>PeekMut</span>::<span>pop</span><span>(</span><span>item</span><span>);</span><span>
        </span><span>}</span><span>
    </span><span>}</span><span>
    </span><span>result</span><span>
</span><span>}</span></code></pre>
<p>Merging 100 sets of 10K integers in Rust using the code above takes 33ms.</p>
<p>And here is the Go version:</p>
<pre><code><span>type</span><span> </span><span>Item</span><span> </span><span>struct</span><span> </span><span>{</span><span>
    </span><span>first</span><span>     </span><span>uint64</span><span>
    </span><span>remainder</span><span> </span><span>[]</span><span>uint64</span><span>
</span><span>}</span><span>

</span><span>type</span><span> </span><span>Uint64SetHeap</span><span> </span><span>[]</span><span>Item</span><span>
</span><span>func</span><span> </span><span>(</span><span>h</span><span> </span><span>Uint64SetHeap</span><span>)</span><span> </span><span>Len</span><span>()</span><span> </span><span>int</span><span>           </span><span>{</span><span> </span><span>return</span><span> </span><span>len</span><span>(</span><span>h</span><span>)</span><span> </span><span>}</span><span>
</span><span>func</span><span> </span><span>(</span><span>h</span><span> </span><span>Uint64SetHeap</span><span>)</span><span> </span><span>Less</span><span>(</span><span>i</span><span>,</span><span> </span><span>j</span><span> </span><span>int</span><span>)</span><span> </span><span>bool</span><span> </span><span>{</span><span> </span><span>return</span><span> </span><span>h</span><span>[</span><span>i</span><span>].</span><span>first</span><span> </span><span>&lt;</span><span> </span><span>h</span><span>[</span><span>j</span><span>].</span><span>first</span><span> </span><span>}</span><span>
</span><span>func</span><span> </span><span>(</span><span>h</span><span> </span><span>Uint64SetHeap</span><span>)</span><span> </span><span>Swap</span><span>(</span><span>i</span><span>,</span><span> </span><span>j</span><span> </span><span>int</span><span>)</span><span>      </span><span>{</span><span> </span><span>h</span><span>[</span><span>i</span><span>],</span><span> </span><span>h</span><span>[</span><span>j</span><span>]</span><span> </span><span>=</span><span> </span><span>h</span><span>[</span><span>j</span><span>],</span><span> </span><span>h</span><span>[</span><span>i</span><span>]</span><span> </span><span>}</span><span>

</span><span>func</span><span> </span><span>mergeUint64s</span><span>(</span><span>sets</span><span> </span><span>[][]</span><span>uint64</span><span>)</span><span> </span><span>[]</span><span>uint64</span><span> </span><span>{</span><span>
    </span><span>h</span><span> </span><span>:=</span><span> </span><span>make</span><span>(</span><span>Uint64SetHeap</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>len</span><span>(</span><span>sets</span><span>))</span><span>
    </span><span>for</span><span> </span><span>_</span><span>,</span><span> </span><span>set</span><span> </span><span>:=</span><span> </span><span>range</span><span> </span><span>sets</span><span> </span><span>{</span><span>
        </span><span>h</span><span> </span><span>=</span><span> </span><span>append</span><span>(</span><span>h</span><span>,</span><span> </span><span>Item</span><span>{</span><span>first</span><span>:</span><span> </span><span>set</span><span>[</span><span>0</span><span>],</span><span> </span><span>remainder</span><span>:</span><span> </span><span>set</span><span>[</span><span>1</span><span>:]})</span><span>
    </span><span>}</span><span>
    </span><span>heap</span><span>.</span><span>Init</span><span>(</span><span>&amp;</span><span>h</span><span>)</span><span>
    </span><span>var</span><span> </span><span>result</span><span> </span><span>[]</span><span>uint64</span><span>
    </span><span>for</span><span> </span><span>h</span><span>.</span><span>Len</span><span>()</span><span> </span><span>&gt;</span><span> </span><span>0</span><span> </span><span>{</span><span>
        </span><span>item</span><span> </span><span>:=</span><span> </span><span>h</span><span>[</span><span>0</span><span>]</span><span>
        </span><span>if</span><span> </span><span>len</span><span>(</span><span>result</span><span>)</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>||</span><span> </span><span>result</span><span>[</span><span>len</span><span>(</span><span>result</span><span>)</span><span>-</span><span>1</span><span>]</span><span> </span><span>!=</span><span> </span><span>item</span><span>.</span><span>first</span><span> </span><span>{</span><span>
            </span><span>result</span><span> </span><span>=</span><span> </span><span>append</span><span>(</span><span>result</span><span>,</span><span> </span><span>item</span><span>.</span><span>first</span><span>)</span><span>
        </span><span>}</span><span>
        </span><span>if</span><span> </span><span>len</span><span>(</span><span>item</span><span>.</span><span>remainder</span><span>)</span><span> </span><span>&gt;</span><span> </span><span>0</span><span> </span><span>{</span><span>
            </span><span>h</span><span>[</span><span>0</span><span>]</span><span> </span><span>=</span><span> </span><span>Item</span><span>{</span><span>first</span><span>:</span><span> </span><span>item</span><span>.</span><span>remainder</span><span>[</span><span>0</span><span>],</span><span> </span><span>remainder</span><span>:</span><span> </span><span>item</span><span>.</span><span>remainder</span><span>[</span><span>1</span><span>:]}</span><span>
        </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span>
            </span><span>// No more elements in the set, remove the set from the heap.</span><span>
            </span><span>n</span><span> </span><span>:=</span><span> </span><span>len</span><span>(</span><span>h</span><span>)</span><span> </span><span>-</span><span> </span><span>1</span><span>
            </span><span>h</span><span>[</span><span>0</span><span>]</span><span> </span><span>=</span><span> </span><span>h</span><span>[</span><span>n</span><span>]</span><span>
            </span><span>h</span><span> </span><span>=</span><span> </span><span>h</span><span>[:</span><span>n</span><span>]</span><span>
        </span><span>}</span><span>
        </span><span>// The value of the head changed. Re-establish the heap ordering.</span><span>
        </span><span>heap</span><span>.</span><span>Fix</span><span>(</span><span>&amp;</span><span>h</span><span>,</span><span> </span><span>0</span><span>)</span><span>
    </span><span>}</span><span>
    </span><span>return</span><span> </span><span>result</span><span>
</span><span>}</span></code></pre>
<p>We see a similar result again: in Go, merging the same 100 sets, 10K integers each, takes three times longer—101ms. To make this benchmark more fair, however, there is one optimization we can do in Go. If we look closer at the heap implementation in Rust, we notice that the <a href="https://doc.rust-lang.org/std/collections/binary_heap/struct.BinaryHeap.html" target="_blank">BinaryHeap</a> structure in Rust is generic, meaning the generic type <span>T</span> is replaced with our concrete type <span>Item</span> during compilation. The Go heap implementation does not use generics: instead, it uses the <a href="https://pkg.go.dev/container/heap#Interface" target="_blank">heap.Interface</a> interface. Interfaces in Go come with an additional cost in runtime and make some optimizations, such as inlining, impossible. Go supports generics since version 1.18, but unfortunately there is no generic heap in the standard library yet (see the GitHub <a href="https://github.com/golang/go/issues/47632" target="_blank">issue</a> discussing adding it). Instead of trying to write a generic heap in Go, we can do what the Rust compiler does for us by hand: copy the <span>container/heap</span> package and manually replace all instances of <span>heap.Interface</span> with <span>Item</span>. There is a lot of code to copy and paste, so I won’t include it here. This new version is faster—it takes 76ms to run, but is still more than twice as slow as the Rust version.</p>
<p>These are not isolated cases, we found several other CPU-demanding operations being faster in Rust. We learned that while in many cases it’s possible to make Go as fast as Rust, writing performance-sensitive code in Go requires a relatively larger time investment and deeper language expertise.</p>
</div>
</div>
<div id="conclusion">
<h3>Conclusion<a href="#conclusion" title="Permalink to this headline"> #</a></h3>
<p>To summarize the changes we made, we adapted an entirely different indexing strategy: we now always index the timeseries to avoid full scans. We sharded the indexing nodes internally to parallelize query execution and take advantage of larger nodes with more CPU cores. Finally, we rewrote the service from Go to Rust, making CPU-demanding operations up to 6x faster. Combined, these changes allowed us to query 20 times higher cardinality metrics on the same hardware, and we significantly reduced the tail query latency. This resulted in a 99% reduction of query timeouts and made the timeseries index nearly 50% cheaper to run.</p>
<div>
<p><img alt="" src="https://artem.krylysov.com/images/2024-timeseries-indexing-at-scale/query-latency.png"/></p><p>The tail query latency graph with the original indexing service in blue and the next-gen service in orange</p>
</div>
</div>

    </article><p>I&#39;m not a native English speaker, and I&#39;m trying to improve my language skills. Feel free to correct me if you spot any spelling or grammatical errors!</p></div>
  </body>
</html>
