<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mwilczynski.dev/posts/riscv-gpu-zink/">Original</a>
    <h1>Igniting the GPU: From Kernel Plumbing to 3D Rendering on RISC-V</h1>
    
    <div id="readability-page-1" class="page"><div>

<article>
   
  <div><h2 id="introduction-enabling-the-hardware">Introduction: Enabling the Hardware</h2>
<p>For years, PowerVR GPUs ubiquitous in the embedded world relied entirely on out of tree vendor drivers (often named <code>pvrsrvkm</code>). While source code was provided in Board Support Packages, these drivers were never accepted into the mainline kernel due to their non standard architecture.</p>
<p>That changed when Imagination Technologies <a href="https://lists.freedesktop.org/archives/mesa-dev/2022-March/225699.html">announced their commitment</a> to an upstream, open source driver. The resulting <code>drm/imagination</code> driver has been upstream for some time, but it wasn’t usable on RISC-V platforms like the T-HEAD TH1520 (used in the Lichee Pi 4A).</p>
<p><strong>This marks a significant milestone: with the enablement work described below, the TH1520 becomes the first RISC-V SoC to feature fully mainline, hardware accelerated 3D graphics support.</strong></p>
<p>This effort has followed a long road of development, generating significant community interest along the way from the <a href="https://www.phoronix.com/news/RISC-V-PowerVR-Driver-Support">initial driver support discussions</a> to the <a href="https://www.phoronix.com/news/T-HEAD-GPU-Power-Sequence">power sequencing challenges</a>, and finally culminating in the <a href="https://www.phoronix.com/news/Linux-6.18-PowerVR-RISC-V">official upstream merge in Linux 6.18</a>.</p>
<p>While the GPU driver itself is generic, the hardware surrounding the GPU on this SoC specifically the power, clock, and reset controllers required significant enablement work before the GPU could actually be probed.</p>
<p>This post details the architectural “plumbing” required to bring up the full graphics stack on the TH1520. This involved implementing the necessary platform drivers to handle the SoC’s power sequencing, enabling the mainline <code>drm/imagination</code> driver for RISC-V, and validating the stack with a modern, Vulkan based userspace.</p>
<hr/>
<h2 id="part-1-the-dependency-chain">Part 1: The Dependency Chain</h2>
<p>Enabling the GPU wasn’t just a matter of changing a Kconfig entry. The TH1520 GPU subsystem is gated behind a chain of hardware dependencies that had no existing Linux drivers.</p>
<p>To reach the point where I could submit the final patch <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=6b53cf48d9339c75fa51927b0a67d8a6751066bd">enabling the PowerVR driver for RISC-V</a>, I first had to implement and upstream the drivers for these underlying subsystems.</p>
<p>The hierarchy looks like this, from the bottom up:</p>
<ol>
<li><strong>Mailbox (<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=5d4d263e1c6b6b18acb4d67fd3b9af71b7404924"><code>mailbox-th1520</code></a>)</strong>: The SoC uses a safety coprocessor (E902) to manage power. The first step was writing a mailbox driver to establish a physical communication link between the main CPUs and this coprocessor.</li>
<li><strong>Firmware Protocol (<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=e4b3cbd840e565484d0ad8d260d27c057466ed17"><code>thead-aon-protocol</code></a>)</strong>: On top of the mailbox, I implemented the AON (Always-On) firmware protocol. This driver handles the specific message format required to request power state changes from the coprocessor.</li>
<li><strong>Power Domains (<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=dc9a897dbb03dfd46c3bd2ce69e42e378bd12ca0"><code>pmdomain-thead</code></a>)</strong>: With the protocol active, I could expose the GPU’s power rail as a standard Linux Generic Power Domain (GenPD). This allows the kernel to manage the GPU’s power state generically.</li>
<li><strong>Resets and Clocks</strong>: Finally, I extended the clock driver (<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=50d4b157fa96bfeb4f383d7dad80f8bdef0d1d2a"><code>clk-th1520-vo</code></a>) and implemented a new reset controller (<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=4a65326311aba694faafcef9e3c0ef7ae1b722e6"><code>reset-th1520</code></a>) to handle the specific requirements of the Video Output (VO) subsystem where the GPU resides.</li>
</ol>
<h3 id="the-power-sequencer-a-novel-application">The Power Sequencer: A Novel Application</h3>
<p>With the platform drivers in place, one integration challenge remained. The TH1520 requires a specific, time sensitive sequence to power up the GPU: enable the power domain, wait for voltage stabilization, and then de-assert resets in a specific order.</p>
<p>Historically, power sequencing in the kernel was mostly confined to the MMC/Bluetooth subsystems (for toggling GPIOs on WiFi chips). However, the kernel recently introduced a generic <strong>Power Sequencing (<code>pwrseq</code>)</strong> subsystem (authored by Bartosz Golaszewski) to standardize this problem.</p>
<p>During the upstream review process, <strong>Ulf Hansson</strong> (the Power Management subsystem maintainer) suggested that the TH1520’s GPU was the perfect candidate for this new framework. It behaves almost like an external component: it needs a dedicated “manager” to orchestrate its wake-up routine before the main driver can even touch it.</p>
<p>I implemented this in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=d4c2d9b5b7ceed14a3a835fd969bb0699b9608d3"><code>pwrseq-thead-gpu</code></a>. The most interesting part of this driver is the <code>match</code> function, which allows the sequencer to “adopt” the GPU’s resources:</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span><span> 6
</span></span><span><span> 7
</span></span><span><span> 8
</span></span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span><span>19
</span></span><span><span>20
</span></span><span><span>21
</span></span><span><span>22
</span></span><span><span>23
</span></span><span><span>24
</span></span><span>25
</span><span>26
</span><span>27
</span><span>28
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="c"><span><span><span>static</span> <span>int</span> <span>pwrseq_thead_gpu_match</span><span>(</span><span>struct</span> <span>pwrseq_device</span> <span>*</span><span>pwrseq</span><span>,</span>
</span></span><span><span>				  <span>struct</span> <span>device</span> <span>*</span><span>dev</span><span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>	<span>struct</span> <span>pwrseq_thead_gpu_ctx</span> <span>*</span><span>ctx</span> <span>=</span> <span>pwrseq_device_get_drvdata</span><span>(</span><span>pwrseq</span><span>);</span>
</span></span><span><span>
</span></span><span><span>	<span>/* 1. We only match the specific T-HEAD TH1520 GPU compatible */</span>
</span></span><span><span>	<span>if</span> <span>(</span><span>!</span><span>of_device_is_compatible</span><span>(</span><span>dev</span><span>-&gt;</span><span>of_node</span><span>,</span> <span>&#34;thead,th1520-gpu&#34;</span><span>))</span>
</span></span><span><span>		<span>return</span> <span>0</span><span>;</span>
</span></span><span><span>
</span></span><span><span>	<span>/*  validation omitted  */</span>
</span></span><span><span>
</span></span><span><span>	<span>/* 2. Dynamically acquire resources FROM the consumer device node */</span>
</span></span><span><span>	<span>ctx</span><span>-&gt;</span><span>num_clks</span> <span>=</span> <span>ARRAY_SIZE</span><span>(</span><span>clk_names</span><span>);</span>
</span></span><span><span>	<span>ctx</span><span>-&gt;</span><span>clks</span> <span>=</span> <span>kcalloc</span><span>(</span><span>ctx</span><span>-&gt;</span><span>num_clks</span><span>,</span> <span>sizeof</span><span>(</span><span>*</span><span>ctx</span><span>-&gt;</span><span>clks</span><span>),</span> <span>GFP_KERNEL</span><span>);</span>
</span></span><span><span>
</span></span><span><span>	<span>for</span> <span>(</span><span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>ctx</span><span>-&gt;</span><span>num_clks</span><span>;</span> <span>i</span><span>++</span><span>)</span>
</span></span><span><span>		<span>ctx</span><span>-&gt;</span><span>clks</span><span>[</span><span>i</span><span>].</span><span>id</span> <span>=</span> <span>clk_names</span><span>[</span><span>i</span><span>];</span>
</span></span><span><span>
</span></span><span><span>	<span>/* The sequencer grabs the &#39;core&#39; and &#39;sys&#39; clocks defined in the GPU&#39;s DT node */</span>
</span></span><span><span>	<span>ret</span> <span>=</span> <span>clk_bulk_get</span><span>(</span><span>dev</span><span>,</span> <span>ctx</span><span>-&gt;</span><span>num_clks</span><span>,</span> <span>ctx</span><span>-&gt;</span><span>clks</span><span>);</span>
</span></span><span><span>	<span>if</span> <span>(</span><span>ret</span><span>)</span>
</span></span><span><span>		<span>goto</span> <span>err_free_clks</span><span>;</span>
</span></span><span><span>
</span></span><span><span>	<span>ctx</span><span>-&gt;</span><span>gpu_reset</span> <span>=</span> <span>reset_control_get_shared</span><span>(</span><span>dev</span><span>,</span> <span>NULL</span><span>);</span>
</span></span><span><span>
</span></span><span><span>	<span>/* ... */</span>
</span></span><span><span>	<span>return</span> <span>1</span><span>;</span>
</span></span><span><span><span>}</span></span></span></code></pre></td></tr></tbody></table>
</div>
</div>
<h4 id="the-integration-in-drmimagination">The Integration in <code>drm/imagination</code></h4>
<p>To make this work, I also had to introduce a small but strategic change to the generic <code>drm/imagination</code> driver (see commit <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=e38e8391f30b41c5a24bb46dc6ef4161921e782d"><code>e38e8391f30b</code></a>).</p>
<p>Following a suggestion from <strong>Matt Coster</strong>, I implemented a new abstraction, <code>pvr_power_sequence_ops</code>. This interface allows the driver to select its power strategy at runtime based on the device compatible string, keeping the core driver logic generic while accommodating platform specific needs.</p>
<p>For the TH1520, the driver simply selects the <code>pwrseq</code> backend:</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="c"><span><span><span>static</span> <span>const</span> <span>struct</span> <span>pvr_device_data</span> <span>pvr_device_data_pwrseq</span> <span>=</span> <span>{</span>
</span></span><span><span>    <span>.</span><span>pwr_ops</span> <span>=</span> <span>&amp;</span><span>pvr_power_sequence_ops_pwrseq</span><span>,</span>
</span></span><span><span><span>};</span>
</span></span><span><span>
</span></span><span><span><span>static</span> <span>const</span> <span>struct</span> <span>of_device_id</span> <span>dt_match</span><span>[]</span> <span>=</span> <span>{</span>
</span></span><span><span>    <span>{</span>
</span></span><span><span>        <span>.</span><span>compatible</span> <span>=</span> <span>&#34;thead,th1520-gpu&#34;</span><span>,</span>
</span></span><span><span>        <span>.</span><span>data</span> <span>=</span> <span>&amp;</span><span>pvr_device_data_pwrseq</span><span>,</span>
</span></span><span><span>    <span>},</span>
</span></span><span><span>    <span>/* ... */</span>
</span></span><span><span><span>};</span></span></span></code></pre></td></tr></tbody></table>
</div>
</div>
<p>This architecture offers three major benefits:</p>
<ol>
<li><strong>Clean Abstraction:</strong> The GPU driver doesn’t need to know about T-HEAD’s specific reset order or microsecond delays. It simply calls the generic <code>pwr_ops-&gt;power_on()</code>.</li>
<li><strong>Inversion of Control:</strong> The sequencer “steals” the resource handles (clocks and resets) from the GPU’s device tree node during the match phase (lines 19-24 in the first snippet). This allows the sequencer to control resources that conceptually belong to the GPU, ensuring the correct power up order without modifying the GPU driver logic.</li>
<li><strong>Strict Ordering:</strong> By centralizing this logic in a dedicated driver, we guarantee that the <code>clkgen</code> reset (controlled by the parent node) and the <code>gpu_core</code> reset (controlled by the consumer node) are de-asserted in the exact order required by the hardware manual.</li>
</ol>
<hr/>
<h2 id="part-2-the-display-pipeline-connecting-the-pixels">Part 2: The Display Pipeline (Connecting the Pixels)</h2>
<p>Powering up the GPU is a massive victory, but it solves only half the problem. A GPU can render beautiful 3D scenes into memory, but without a <strong>Display Controller</strong> to scan those buffers out to a screen, you’re still looking at a black terminal.</p>
<p>On the TH1520, the display duties are handled by a <strong>Verisilicon DC8200</strong> IP block, connected to a Synopsys DesignWare HDMI bridge.</p>
<blockquote>
<p><strong>Ecosystem Note:</strong> If you are following the RISC-V space, this IP might sound familiar. The <strong>StarFive JH7110</strong> (used in the VisionFive 2) uses the exact same Verisilicon DC8200 display controller.</p>
<p>I am actually working on enabling the display stack for the JH7110 in <a href="https://lore.kernel.org/all/20251108-jh7110-clean-send-v1-0-06bf43bb76b1@samsung.com/">parallel</a>. While the IP is the same, the integration is vastly different the JH7110 has a complex circular dependency between the HDMI PHY and the clock generator that requires a complete architectural rethink. But that is a story for a future blog post.</p></blockquote>
<h3 id="the-collaborative-puzzle">The Collaborative Puzzle</h3>
<p>While I focused on the TH1520 power sequencing and GPU enablement, the display driver work here was led by <strong>Icenowy Zheng</strong>, another brilliant engineer in the RISC-V ecosystem.</p>
<p>This is the beauty of upstream kernel development: you don’t have to build the world alone. Icenowy has been working on a generic DRM driver for <a href="https://lore.kernel.org/all/20251224161205.1132149-1-zhengxingda@iscas.ac.cn/">Verisilicon display controllers</a>, adapting it to support the specific HDMI PHY found on the TH1520.</p>
<p>Since these patches are currently in the review process (v4), they aren’t in mainline yet. To build the working demo, I applied Icenowy’s patch series on top of mainline kernel.</p>
<p>With Icenowy’s display driver handling the “scan out” and my infrastructure handling the “power up,” we finally had a complete pipeline: <strong>Memory -&gt; GPU Render -&gt; Memory -&gt; Display Controller -&gt; HDMI</strong>.</p>
<h2 id="part-3-the-vulkan-only-future">Part 3: The “Vulkan-Only” Future</h2>
<p>Now that the kernel could talk to the hardware, we needed a userspace stack to render graphics.</p>
<p>Historically, enabling a new GPU meant writing two massive drivers for Mesa: one for Vulkan and one for OpenGL. But the open-source graphics world has shifted. The <code>drm/imagination</code> driver is designed to be <strong>Vulkan-native</strong>.</p>
<p>Instead of writing a complex, legacy OpenGL driver, we use <strong>Zink</strong>.</p>
<h3 id="the-stack-rendering-vs-display">The Stack: Rendering vs. Display</h3>
<p>Since the TH1520 uses a split DRM architecture, the flow isn’t just a straight line. The GPU and Display Controller are separate devices that share data via memory (DMA-BUF).</p>
<div><pre tabindex="0"><code data-lang="text"><span><span>      [ Application (glmark2) ]
</span></span><span><span>                 │
</span></span><span><span>                 ▼
</span></span><span><span>      [    Zink (OpenGL)      ]
</span></span><span><span>                 │
</span></span><span><span>                 ▼
</span></span><span><span>      [ Mesa PowerVR (Vulkan) ]
</span></span><span><span>                 │
</span></span><span><span>      ┌──────────┴──────────┐
</span></span><span><span>      │     Linux Kernel    │
</span></span><span><span>      ▼                     ▼
</span></span><span><span>[ GPU Driver ]       [ Display Driver ]
</span></span><span><span> (Render Node)         (KMS/Card Node)
</span></span><span><span>      │                     │
</span></span><span><span>      ▼        DMA-BUF      ▼
</span></span><span><span> [ GPU HW ] ──(Memory)──▶ [ Display HW ] ──▶ HDMI</span></span></code></pre></div>
<p>This separation is why the kernel plumbing in Part 1 (GPU) and Part 2 (Display) had to be done independently before they could work together.</p>
<h3 id="building-the-stack-reproduction-guide">Building the Stack (Reproduction Guide)</h3>
<p>For those who want to reproduce this on their own Lichee Pi 4A, exact version matching is critical.</p>
<p><strong>1. The Kernel</strong>
I used Linux 6.19 as the base, with unmerged Display Controller patches applied on top. You can find the exact tree here:</p>
<ul>
<li><strong>Kernel Branch:</strong> <a href="https://github.com/mwilczy/linux/tree/blog_code"><code>github.com/mwilczy/linux/tree/blog_code</code></a></li>
</ul>
<p><strong>2. Mesa (Userspace)</strong>
I used a fork of Icenowy Zheng’s work, which includes the necessary glue to make Zink play nicely with this specific hardware combination.</p>
<ul>
<li><strong>Mesa Branch:</strong> <a href="https://github.com/mwilczy/mesa"><code>github.com/mwilczy/mesa</code></a></li>
</ul>
<p>Here is the exact Meson configuration I used to build a pure Vulkan+Zink stack:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>meson setup build <span>\
</span></span></span><span><span><span></span>    -D <span>buildtype</span><span>=</span>release <span>\
</span></span></span><span><span><span></span>    -D <span>platforms</span><span>=</span>x11,wayland <span>\
</span></span></span><span><span><span></span>    -D vulkan-drivers<span>=</span>imagination <span>\
</span></span></span><span><span><span></span>    -D gallium-drivers<span>=</span>zink <span>\
</span></span></span><span><span><span></span>    -D <span>glx</span><span>=</span>disabled <span>\
</span></span></span><span><span><span></span>    -D <span>gles1</span><span>=</span>disabled <span>\
</span></span></span><span><span><span></span>    -D <span>gles2</span><span>=</span>enabled <span>\
</span></span></span><span><span><span></span>    -D <span>egl</span><span>=</span>enabled <span>\
</span></span></span><span><span><span></span>    -D <span>tools</span><span>=</span>imagination <span>\
</span></span></span><span><span><span></span>    -D <span>glvnd</span><span>=</span>disabled</span></span></code></pre></div>
<hr/>
<h2 id="part-4-the-result">Part 4: The Result</h2>
<p>With the kernel compiled (including the pending display patches) and the Mesa stack built, we can finally run accelerated 3D workloads.</p>
<h3 id="the-secret-sauce-environment-variables">The “Secret Sauce” (Environment Variables)</h3>
<p>Because the driver is still in active development and not yet fully conformant, we need to pass a few flags to convince Mesa to run.</p>
<p>The most important one is <code>PVR_I_WANT_A_BROKEN_VULKAN_DRIVER=1</code>. Without this, the driver safeguards would prevent loading. We also force the use of the Zink driver and explicitly select our device:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span>export</span> <span>PVR_I_WANT_A_BROKEN_VULKAN_DRIVER</span><span>=</span><span>1</span>
</span></span><span><span><span>export</span> <span>GALLIUM_DRIVER</span><span>=</span>zink
</span></span><span><span><span>export</span> <span>MESA_VK_DEVICE_SELECT</span><span>=</span>1010:36104182!</span></span></code></pre></div>
<h3 id="the-benchmark">The Benchmark</h3>
<p>I started a Weston compositor session using the DRM backend:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>weston --backend<span>=</span>drm-backend.so --continue-without-input <span>&amp;</span></span></span></code></pre></div>
<p>And then, the moment of truth - running <code>glmark2-es2-wayland</code>:</p>
<p><img alt="glmark2 running on RISC-V" loading="lazy" src="https://mwilczynski.dev/images/glmark.png"/>
<em>Above: glmark2 running on the Lichee Pi 4A.</em></p>
<p>Here is the output, confirming we are running fully accelerated on the PowerVR GPU via Zink:</p>
<div><pre tabindex="0"><code data-lang="text"><span><span>root@revyos-lpi4a:~/test_mesa/Vulkan/build4/bin# glmark2-es2-wayland
</span></span><span><span>MESA: warning: Core count fetching is unimplemented. Setting 1 for now.
</span></span><span><span>WARNING: powervr is not a conformant Vulkan implementation, testing use only.
</span></span><span><span>=======================================================
</span></span><span><span>    glmark2 2023.01
</span></span><span><span>=======================================================
</span></span><span><span>    OpenGL Information
</span></span><span><span>    GL_VENDOR:      Mesa
</span></span><span><span>    GL_RENDERER:    zink Vulkan 1.2(PowerVR B-Series BXM-4-64 MC1 (IMAGINATION_OPEN_SOURCE_MESA))
</span></span><span><span>    GL_VERSION:     OpenGL ES 2.0 Mesa 26.0.0-devel (git-601d20e81e)
</span></span><span><span>    Surface Config: buf=32 r=8 g=8 b=8 a=8 depth=24 stencil=0 samples=0
</span></span><span><span>    Surface Size:   800x600 windowed
</span></span><span><span>=======================================================
</span></span><span><span>[build] use-vbo=false:[  510.861554] verisilicon-dc ffef600000.display: swiotlb buffer is full (sz: 524288 bytes), total 32768 (slots), used 4 (slots)
</span></span><span><span>[  510.887018] verisilicon-dc ffef600000.display: swiotlb buffer is full (sz: 1847296 bytes), total 32768 (slots), used 36 (slots)
</span></span><span><span>[  510.900771] verisilicon-dc ffef600000.display: swiotlb buffer is full (sz: 1847296 bytes), total 32768 (slots), used 36 (slots)
</span></span><span><span>[  510.923956] verisilicon-dc ffef600000.display: swiotlb buffer is full (sz: 1921024 bytes), total 32768 (slots), used 0 (slots)
</span></span><span><span>[  510.954656] verisilicon-dc ffef600000.display: swiotlb buffer is full (sz: 458752 bytes), total 32768 (slots), used 0 (slots)
</span></span><span><span>[  510.966931] verisilicon-dc ffef600000.display: swiotlb buffer is full (sz: 458752 bytes), total 32768 (slots), used 0 (slots)
</span></span><span><span>[  511.038586] verisilicon-dc ffef600000.display: swiotlb buffer is full (sz: 1921024 bytes), total 32768 (slots), used 0 (slots)
</span></span><span><span>[  512.165193] verisilicon-dc ffef600000.display: swiotlb buffer is full (sz: 1900544 bytes), total 32768 (slots), used 10 (slots)
</span></span><span><span>[  512.187871] verisilicon-dc ffef600000.display: swiotlb buffer is full (sz: 1900544 bytes), total 32768 (slots), used 10 (slots)
</span></span><span><span>[  512.209524] verisilicon-dc ffef600000.display: swiotlb buffer is full (sz: 745472 bytes), total 32768 (slots), used 0 (slots)
</span></span><span><span> FPS: 67 FrameTime: 14.960 ms
</span></span><span><span>[build] use-vbo=true: FPS: 98 FrameTime: 10.252 ms
</span></span><span><span>[texture] texture-filter=nearest: FPS: 97 FrameTime: 10.332 ms
</span></span><span><span>[texture] texture-filter=linear: FPS: 93 FrameTime: 10.868 ms
</span></span><span><span>[texture] texture-filter=mipmap: FPS: 101 FrameTime: 9.957 ms
</span></span><span><span>[shading] shading=gouraud: FPS: 93 FrameTime: 10.851 ms
</span></span><span><span>[shading] shading=blinn-phong-inf: FPS: 98 FrameTime: 10.274 ms
</span></span><span><span>[shading] shading=phong: FPS: 97 FrameTime: 10.356 ms
</span></span><span><span>[shading] shading=cel: FPS: 91 FrameTime: 11.086 ms
</span></span><span><span>[bump] bump-render=high-poly: FPS: 75 FrameTime: 13.404 ms
</span></span><span><span>[bump] bump-render=normals: FPS: 97 FrameTime: 10.356 ms
</span></span><span><span>[bump] bump-render=height: FPS: 88 FrameTime: 11.449 ms
</span></span><span><span>[effect2d] kernel=0,1,0;1,-4,1;0,1,0;: FPS: 94 FrameTime: 10.646 ms
</span></span><span><span>[effect2d] kernel=1,1,1,1,1;1,1,1,1,1;1,1,1,1,1;: FPS: 57 FrameTime: 17.590 ms
</span></span><span><span>[pulsar] light=false:quads=5:texture=false: FPS: 92 FrameTime: 10.953 ms
</span></span><span><span>[desktop] blur-radius=5:effect=blur:passes=1:separable=true:windows=4: FPS: 10 FrameTime: 105.957 ms
</span></span><span><span>[desktop] effect=shadow:windows=4: FPS: 37 FrameTime: 27.465 ms
</span></span><span><span>
</span></span><span><span>...</span></span></code></pre></div>
<p>We have successfully turned “dark silicon” into a modern, Vulkan capable graphics platform.</p>
<hr/>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>Bringing a new GPU architecture to life in the mainline kernel is never a solo effort. It requires navigating complex subsystems - from power domains to clocks and relies heavily on the patience and expertise of subsystem maintainers.</p>
<p>This work went through many iterations, and the code is significantly better thanks to the rigorous feedback from the community.</p>
<p>A huge thank you to everyone who helped review the code, suggested architectural improvements, and tested the stack:</p>
<ul>
<li><strong>Marek Szyprowski</strong> - For the guidance and mentorship throughout the upstreaming process.</li>
<li><strong>Drew Fustini</strong> - For his long standing work maintaining the TH1520 platform.</li>
<li><strong>Krzysztof Kozłowski</strong> - For ensuring the Device Tree bindings were strictly compliant.</li>
<li><strong>Ulf Hansson</strong> - For his guidance on the AON power domains and for suggesting the use of the Power Sequencing framework, which simplified the architecture significantly.</li>
<li><strong>Bartosz Gołaszewski</strong> -  For creating the Power Sequencing subsystem and helping merge the TH1520 driver.</li>
<li><strong>Matt Coster</strong> - For reviewing the driver changes and helping navigate the PowerVR internals.</li>
<li><strong>Stephen Boyd</strong>  - For the feedback on the video output clock controller.</li>
<li><strong>Philipp Zabel</strong> - For reviewing the reset controller implementation.</li>
<li><strong>Icenowy Zheng</strong> - For the incredible work on the display controller and Mesa/Zink integration.</li>
<li><strong>Jassi Brar</strong> - For reviewing the mailbox driver implementation.</li>
<li><strong>Conor Dooley</strong> - For reviewing Device Tree patches.</li>
</ul>


  </div>

  

</article>
    </div></div>
  </body>
</html>
