<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://elijer.github.io/garden/devnotes/LeetCode-Journal/30%29-Longest-Repeating-Character-Replacement">Original</a>
    <h1>30) Longest Repeating Character Replacement</h1>
    
    <div id="readability-page-1" class="page"><article><p>This was what I had at about 15 minutes in:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>// Okay let me think of the human thing to do</span></span>
<span data-line=""><span>// As a human, I would look for the longest cluster of strings</span></span>
<span data-line=""><span>// I would also look for the longest clusters of strings that are separated only by k, especially if K is small.</span></span>
<span data-line=""><span>// But I mean, mostly I&#39;m looking for the longest clusters of strings. That&#39;s what I&#39;m working with mostly.</span></span>
<span data-line=""><span>// I would also be looking to see if K was at least -1 of the overall character count, because if it is, then regardless</span></span>
<span data-line=""><span>// of characters, I really don&#39;t need to do much</span></span>
<span data-line=""> </span>
<span data-line=""><span>function</span><span> characterReplacement</span><span>(</span><span>s</span><span>:</span><span> string</span><span>, </span><span>k</span><span>:</span><span> number</span><span>)</span><span>:</span><span> number</span><span> {</span></span>
<span data-line=""> </span>
<span data-line=""><span>    // Handle the case where we have so many of K that we really don&#39;t need to check what to change - we can change it all</span></span>
<span data-line=""><span>    if</span><span> (k </span><span>&gt;=</span><span> s.</span><span>length</span><span>-</span><span>1</span><span>) </span><span>return</span><span> s.</span><span>length</span></span>
<span data-line=""> </span>
<span data-line=""><span>    // Create a map that stores the index of places were repeat characters start.</span></span>
<span data-line=""><span>    // The key is the index, and the value is where we record how many times they recur</span></span>
<span data-line=""><span>    // Like AAAB would be a map of 0-&gt;3, 3-&gt;1</span></span>
<span data-line=""><span>    let</span><span> islands</span><span>:</span><span> Map</span><span>&lt;</span><span>number</span><span>, </span><span>number</span><span>&gt; </span><span>=</span><span> new</span><span> Map</span><span>()</span></span>
<span data-line=""><span>    </span></span>
<span data-line=""><span>    // Here we save the index of the last recurrence</span></span>
<span data-line=""><span>    // It starts as null</span></span>
<span data-line=""><span>    let</span><span> currentIsland </span><span>=</span><span> null</span></span>
<span data-line=""> </span>
<span data-line=""><span>    // Iterate through the whole string</span></span>
<span data-line=""><span>    for</span><span> (</span><span>let</span><span> i </span><span>=</span><span> 0</span><span>; i </span><span>&lt;</span><span> s.</span><span>length</span><span>; i</span><span>++</span><span>){</span></span>
<span data-line=""> </span>
<span data-line=""><span>        // If the value of the current index we&#39;re on matches the currentIsland&#39;s value, go ahead and increment that current island</span></span>
<span data-line=""><span>        if</span><span> (s[currentIsland] </span><span>===</span><span> s[i]){</span></span>
<span data-line=""><span>            islands.</span><span>set</span><span>(i, islands.</span><span>get</span><span>(i)</span><span>+</span><span>1</span><span>)</span></span>
<span data-line=""> </span>
<span data-line=""><span>        // Otherwise, we need to change the currentIsland. There&#39;s been a character change</span></span>
<span data-line=""><span>        // and we need to create a new entry for it.</span></span>
<span data-line=""><span>        } </span><span>else</span><span> {</span></span>
<span data-line=""><span>            currentIsland </span><span>=</span><span> i</span></span>
<span data-line=""><span>            let</span><span> currentIslandValue </span><span>=</span><span> s[i]</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    console.</span><span>log</span><span>(islands)</span></span>
<span data-line=""> </span>
<span data-line=""> </span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>And this is what I had at 28 minutes in:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> characterReplacement</span><span>(</span><span>s</span><span>:</span><span> string</span><span>, </span><span>k</span><span>:</span><span> number</span><span>)</span><span>:</span><span> number</span><span> {</span></span>
<span data-line=""> </span>
<span data-line=""><span>    if</span><span> (k </span><span>&gt;=</span><span> s.</span><span>length</span><span>-</span><span>1</span><span>) </span><span>return</span><span> s.</span><span>length</span></span>
<span data-line=""><span>    let</span><span> islands</span><span>:</span><span> Map</span><span>&lt;</span><span>number</span><span>, </span><span>number</span><span>&gt; </span><span>=</span><span> new</span><span> Map</span><span>()</span></span>
<span data-line=""><span>    let</span><span> currentIsland</span><span>:</span><span> number</span><span> |</span><span> string</span><span> =</span><span> &#34;noodles&#34;</span></span>
<span data-line=""><span>    for</span><span> (</span><span>let</span><span> i </span><span>=</span><span> 0</span><span>; i </span><span>&lt;</span><span> s.</span><span>length</span><span>; i</span><span>++</span><span>){</span></span>
<span data-line=""><span>        if</span><span> (currentIsland </span><span>===</span><span> &#34;noodles&#34;</span><span>){</span></span>
<span data-line=""><span>            currentIsland </span><span>=</span><span> 0</span></span>
<span data-line=""><span>            islands.</span><span>set</span><span>(</span><span>0</span><span>, </span><span>1</span><span>)</span></span>
<span data-line=""><span>        } </span><span>else</span><span> if</span><span> (s[currentIsland] </span><span>===</span><span> s[i]){</span></span>
<span data-line=""><span>            let</span><span> count </span><span>=</span><span> islands.</span><span>get</span><span>(i)</span></span>
<span data-line=""><span>            console.</span><span>log</span><span>(count)</span></span>
<span data-line=""><span>            islands.</span><span>set</span><span>(i, islands.</span><span>get</span><span>(i)</span><span>+</span><span>1</span><span>)</span></span>
<span data-line=""><span>        } </span><span>else</span><span> {</span></span>
<span data-line=""><span>            currentIsland </span><span>=</span><span> i</span></span>
<span data-line=""><span>            islands.</span><span>set</span><span>(i, </span><span>1</span><span>)</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    return</span><span> 4</span></span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>This second example is written poorly, but I am really getting brainfreezing and it was the best I could do to just fight through and write something that made sense to me.</p>
<p>This creates the Map I wanted, but I don’t totally know what to do with it.</p>
<p>It feels like I should do some combo of finding the longest strings, and of finding the shortest spaces between them.</p>
<p>I suppose what I need to figure out is this</p>
<ol>
<li>which gaps are of a length equal to or less than <code>k</code>?</li>
<li>If I filled those gaps, which would result in the longest contiguous strings?</li>
</ol>
<p>This sort of falls apart in my head when I consider how <em>multiple</em> gaps of different characters might be filled, in all sorts of different ways. Time to look this up - it’s beyond me for now.</p>
<p>Here’s a pretty performant and simple example to look at:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>const</span><span> characterReplacement</span><span> =</span><span> (</span><span>s</span><span>:</span><span> string</span><span>, </span><span>k</span><span>:</span><span> number</span><span>)</span><span>:</span><span> number</span><span> =&gt;</span><span> {</span></span>
<span data-line=""><span>  const</span><span> hashMap</span><span>:</span><span> { [</span><span>key</span><span>:</span><span> string</span><span>]</span><span>:</span><span> number</span><span> } </span><span>=</span><span> {}</span></span>
<span data-line=""><span>  let</span><span> longest</span><span>:</span><span> number</span><span> =</span><span> 0</span></span>
<span data-line=""><span>  let</span><span> maxFreq</span><span>:</span><span> number</span><span> =</span><span> 0</span></span>
<span data-line=""><span>  let</span><span> leftPointer</span><span>:</span><span> number</span><span> =</span><span> 0</span></span>
<span data-line=""> </span>
<span data-line=""><span>  for</span><span> (</span><span>let</span><span> rightPointer </span><span>=</span><span> 0</span><span>; rightPointer </span><span>&lt;</span><span> s.</span><span>length</span><span>; rightPointer</span><span>++</span><span>) {</span></span>
<span data-line=""><span>    // Increment the frequency count by 1 upon encountering a character</span></span>
<span data-line=""><span>    hashMap[s[rightPointer]] </span><span>=</span><span> (hashMap[s[rightPointer]] </span><span>||</span><span> 0</span><span>) </span><span>+</span><span> 1</span></span>
<span data-line=""> </span>
<span data-line=""><span>    // Maximum frequency of any character encountered so far in the current window.</span></span>
<span data-line=""><span>    maxFreq </span><span>=</span><span> Math.</span><span>max</span><span>(maxFreq, hashMap[s[rightPointer]])</span></span>
<span data-line=""> </span>
<span data-line=""><span>    // Move the window from the left until reaching `k` replacements</span></span>
<span data-line=""><span>    if</span><span> (maxFreq </span><span>+</span><span> k </span><span>&lt;</span><span> rightPointer </span><span>-</span><span> leftPointer </span><span>+</span><span> 1</span><span>) {</span></span>
<span data-line=""><span>      hashMap[s[leftPointer]]</span><span>--</span></span>
<span data-line=""><span>      leftPointer</span><span>++</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    // Calculate the longest repeating character</span></span>
<span data-line=""><span>    longest </span><span>=</span><span> Math.</span><span>max</span><span>(longest, rightPointer </span><span>-</span><span> leftPointer </span><span>+</span><span> 1</span><span>)</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""> </span>
<span data-line=""><span>  return</span><span> longest</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<p>Okay I’ve been defeated for now. I’m spent. Bed time. I will hopefully return to this.</p>
<hr/>
<p>Okay got a full night’s rest and this is looking much better!</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> characterReplacement</span><span>(</span><span>s</span><span>:</span><span> string</span><span>, </span><span>k</span><span>:</span><span> number</span><span>)</span><span>:</span><span> number</span><span> {</span></span>
<span data-line=""><span>    const</span><span> hashMap</span><span>:</span><span> {[</span><span>key</span><span>:</span><span> string</span><span>]</span><span>:</span><span> number</span><span> } </span><span>=</span><span> {}</span></span>
<span data-line=""><span>    let</span><span> longest</span><span>:</span><span> number</span><span> =</span><span> 0</span></span>
<span data-line=""><span>    let</span><span> maxFreq</span><span>:</span><span> number</span><span> =</span><span> 0</span></span>
<span data-line=""><span>    let</span><span> leftPointer</span><span>:</span><span> number</span><span> =</span><span> 0</span></span>
<span data-line=""> </span>
<span data-line=""><span>    for</span><span> (</span><span>let</span><span> rightPointer </span><span>=</span><span> 0</span><span>; rightPointer </span><span>&lt;</span><span> s.</span><span>length</span><span>; rightPointer</span><span>++</span><span>){</span></span>
<span data-line=""> </span>
<span data-line=""><span>        rightChar</span><span>=</span><span> hashMap[s[rightPointer]]</span></span>
<span data-line=""> </span>
<span data-line=""><span>        // increment frequency count of this character by 1, or set to initial value of 1</span></span>
<span data-line=""><span>        rightChar </span><span>=</span><span> (rightChar </span><span>||</span><span> 0</span><span> ) </span><span>+</span><span>1</span></span>
<span data-line=""> </span>
<span data-line=""><span>        // having incremented character frequency,</span></span>
<span data-line=""><span>        // check if the last character found now has more than max frequency</span></span>
<span data-line=""><span>        // if so, update maxFreq</span></span>
<span data-line=""><span>        // This could be the same character or a different one</span></span>
<span data-line=""><span>        maxFreq </span><span>=</span><span> Math.</span><span>max</span><span>(maxFreq, rightChar)</span></span>
<span data-line=""> </span>
<span data-line=""><span>        // Is the occurence of most frequent characters in this window</span></span>
<span data-line=""><span>        // + K</span></span>
<span data-line=""><span>        // less than the number of positions in the window?</span></span>
<span data-line=""><span>        // If so, shrink the window from the left.</span></span>
<span data-line=""><span>        // This is the tricky part for me though</span></span>
<span data-line=""><span>        if</span><span> (maxFreq </span><span>+</span><span> k </span><span>&lt;</span><span> rightPointer </span><span>-</span><span> leftPointer </span><span>+</span><span> 1</span><span>){</span></span>
<span data-line=""><span>            hashMap[s[leftPointer]]</span><span>--</span></span>
<span data-line=""><span>            leftPointer</span><span>++</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>Working through the solution of someone named Jamestargia on leetcode. The solution makes a lot of sense until this part:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>if</span><span> (maxFreq </span><span>+</span><span> k </span><span>&lt;</span><span> rightPointer </span><span>-</span><span> leftPointer </span><span>+</span><span> 1</span><span>){</span></span>
<span data-line=""><span>	hashMap[s[leftPointer]]</span><span>--</span></span>
<span data-line=""><span>	leftPointer</span><span>++</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<p>What this part of the algorithm seems to be saying is this - as soon as the most frequent character we’ve found so far as we’ve expanded right, when added with k, is <em>less</em> than the total positions we have in our current window, let’s shrink the window. Because we’re going from left to right, like a flashlight swept deliberately over a field looking for something. So we’ll shrink it from the left; we’ve already looked over there.</p>
<p>We can keep doing this until the number of positions <em>at least</em> reaches <code>maxFreq + k</code>. Because as long as we’re in that situation, we can use k to fill in the window so they are all of one character.</p>
<p>Looking at this, I had two concerns:</p>
<ol>
<li>What if decrementing <code>hashMap[s[leftPointer]]</code>leads to a different <code>maxFreq</code>?</li>
<li>What if, as the window expands to the right, and another character becomes more frequent, we want to <em>retroactively</em> go back left to check that we couldn’t find a longer contiguous string with replacements using <em>that</em> character?</li>
</ol>
<h3 id="concern-1">Concern #1<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#concern-1"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>This is fine. maxFreq doesn’t</p>
<h3 id="concern-2">Concern #2<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#concern-2"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>What I’m worried about is just that, if we shrink the window, what if later on we end up find a maxFreq of a different character and actually we should go back and check to see if that character can be joined with our current, later window, now that we’ve found more.</p>
<p>This isn’t logical though, because the left can only ‘shrink’ at the same rate that we’re adding more characters.</p>
<p>Let me think of it this way - K isn’t going to change. That’s set. But maxFreq can as we move along. maxFreq can potentially increase by one anytime the rightPointer increments. As long as it does, we can afford to keep the left pointer. But if we move right one and maxPointer DOESN’T increase, we can’t afford to keep our current left pointer.</p>
<p>But what if that leftPointer contains a character contributing to the maxFreq???</p>
<p>Well, if that’s the case, we’ve already calculated the farthest we can ‘afford’ to reach right <em>from that character</em>, and exhausted the extent of that reach. It’s farther than we can ‘reach’ using the combined power of our <code>k</code>and the recurring characters we’ve found. That may be the winning window! If so, those results will remain unrivaled for the remainder of our loop.</p>
<p>Ah. I get it in theory. But the order of some of these operations…I think I may still not entirely no know what I don’t know.</p>
<p>Anyway, after re-writing it, this is what I have:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> characterReplacement</span><span>(</span><span>s</span><span>:</span><span> string</span><span>, </span><span>k</span><span>:</span><span> number</span><span>)</span><span>:</span><span> number</span><span> {</span></span>
<span data-line=""><span>    const</span><span> hashMap</span><span>:</span><span> {[</span><span>key</span><span>:</span><span> string</span><span>]</span><span>:</span><span> number</span><span> } </span><span>=</span><span> {}</span></span>
<span data-line=""><span>    let</span><span> longest</span><span>:</span><span> number</span><span> =</span><span> 0</span><span> // &lt;answer</span></span>
<span data-line=""><span>    let</span><span> maxFreq</span><span>:</span><span> number</span><span> =</span><span> 0</span><span> // temp value to store most frequent char</span></span>
<span data-line=""><span>    let</span><span> left</span><span>:</span><span> number</span><span> =</span><span> 0</span><span> // temp value to store our leftmost extent</span></span>
<span data-line=""> </span>
<span data-line=""><span>    for</span><span> (</span><span>let</span><span> right </span><span>=</span><span> 0</span><span>; right </span><span>&lt;</span><span> s.</span><span>length</span><span>; right</span><span>++</span><span>){</span></span>
<span data-line=""> </span>
<span data-line=""><span>        hashMap[s[right]] </span><span>=</span><span> (hashMap[s[right]] </span><span>||</span><span> 0</span><span> ) </span><span>+</span><span>1</span><span> // increment our right value&#39;s count</span></span>
<span data-line=""><span>        maxFreq </span><span>=</span><span> Math.</span><span>max</span><span>(maxFreq, hashMap[s[right]])</span></span>
<span data-line=""> </span>
<span data-line=""><span>        // bump left to the right one</span></span>
<span data-line=""><span>        if</span><span> (maxFreq </span><span>+</span><span> k </span><span>&lt;</span><span> right </span><span>-</span><span> left </span><span>+</span><span> 1</span><span>){</span></span>
<span data-line=""><span>            hashMap[s[left]]</span><span>--</span></span>
<span data-line=""><span>            left</span><span>++</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""> </span>
<span data-line=""><span>        // check if we have a longer window now, every time</span></span>
<span data-line=""><span>        longest </span><span>=</span><span> Math.</span><span>max</span><span>(longest, right </span><span>-</span><span> left </span><span>+</span><span> 1</span><span>)</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    return</span><span> longest</span></span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>Let’s see if I can write it from memory now.</p>
<hr/>
<p>Nope! That was messy. It’s just a lot of steps. Okay I’m going to rewrite this as a story. I really does feel like a drama, with characters and a plot.</p>
<p>Okay so it’s obviously a revolution. We have three revolutionaries, and they are surrounded by a dystopian tyranny. Think 1984 but leetcode. The problem is that everyone is expected to leetcode at least one problem everyday - not only that, but there’s a doublethink happening where leetcoding is considered the path to intelligence, beauty, rationality, and love. Goodness in all things. Our heroes are actually expert leetcoders, which is exactly <em>why</em> they know there is more to life than the grind. They want to rise above. They heard that once, there existed a thing called ‘art’. An irrational discipline, incomprehensible to their reality’s ruling class.</p>
<p>They want to overrule the status queue. But they can’t do it alone. They need to find more compatriots - but they know that if they play their hands wrong, they’ll get narced on. So they need to establish some way to find the highest concentration of sympathizers in any given leetcoding line (people line up to do leetcode on public consoles in the street, like out of pride or something).</p>
<p>They know that groupthink is a powerful force, one that can aide them, <em>or</em> work against them. If they get a critical mass within any contiguous window of people in a given line, just waiting to do their daily leetcoding, they know that they can change the minds of <code>k</code> people as long as the rest are already secretly sympathizers. <code>K</code> is a dynamic value because depending on how close the console is to the tyrants, they can get away with more or fewer converts per window.</p>
<p>Going one by one, they feel that they know how to determine if each individual is a sympathizer or not. Actually - it’s not so much about being a sympathizer. <em>Everyone</em> is a sympathizer in one way or another - the challenge is figuring out how, and making that appeal to the max number of people. Such is public speaking. So if they can find the one message to become demagogues, they can efficiently appeal to just that initial window of people, and turn them all! Revolution!</p>
<p>Meet our characters:</p>
<p><strong>Hash</strong>: Hash is a quant. He has an excellent memory for faces <em>and</em> names. Everything, really. He will be counting where the sympathies of each person lie. Or rather, how many people have each type of sympathy. For example - appeal to freedom. or to love. To art. To curiosity, etc. (That’s what the numbers represent.) Hash’s job is simple, but crucial - this plan couldn’t be executed without him.</p>
<p><strong>Cynthia Long</strong>: Cynthia is cantonese and knows all too from previous generations in her family what it is like to hail from a minority in world ruled by a more powerful majority. She is the leader of the group, and will be the one to make the final call - which group of people to take aside and make their crucial play. As such, she is in charge of recording the length of that group, and returning it, even though she may not pay attention to where it starts and ends.</p>
<p><strong>Max Freq</strong>: Max will stick with Hash, looking over his shoulder and assisting him. They have similar jobs, but Max’s is to constantly re-assess which message will have the greatest impact based on where people’s sympathies lie. He’ll relay this to Cynthia so she knows who to address her message to.</p>
<p><strong>Lefty</strong>: Every group has one - our man on the ground, our jack of all trades. Lefty is, in fact, Cynthia’s left hand man, quick to alert her to when they have overextended and need to do damage control. Maybe this is a violent operation, maybe not. They didn’t tell me.</p>
<p><strong>Mr. Right</strong>: Right is the inside man.</p>
<p>Stay tuned! I’ll finish this story when I revisit this problem. If it’s later than November of 2024 and I still haven’t, let me know!</p></article></div>
  </body>
</html>
