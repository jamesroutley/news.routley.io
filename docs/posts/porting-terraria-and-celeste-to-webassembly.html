<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://velzie.rip/blog/celeste-wasm">Original</a>
    <h1>Show HN: Porting Terraria and Celeste to WebAssembly</h1>
    
    <div id="readability-page-1" class="page"><div id="blogcontent">
  
  <!-- <p>Absurdly cursed mono webassembly hacks, and a journey to create a project that definitely shouldn't exist</p> -->

  <hr/>

  <p>(tldr: terraria in the browser <a href="https://terraria.mercurywork.shop/">here</a>, celeste in the
browser <a href="https://celeste.r58playz.dev">here</a>. <a href="https://github.com/MercuryWorkshop/terraria-wasm">terraria git
repository</a>, <a href="https://github.com/MercuryWorkshop/celeste-wasm">celeste git
repository</a>)</p>

<p>In early 2024 I came across an old post of someone running a half
working copy of the game <a href="https://www.celestegame.com">Celeste</a> entirely in the browser.
When I saw that they had never posted their work publicly, I became
about as obsessed with the idea as you would expect, leading to a year
long journey of bytecode hacks, runtime bugs, patch files, and horrible
build systems all to create something that really should have never
existed in the first place.</p>
<figure><img src="https://velzie.rip/static/celeste-wasm/celeste-sj.webp"/><figcaption><i>Strawberry Jam</i> mod running in celeste-wasm</figcaption></figure>

<p>Credits to <a href="https://www.r58playz.dev">r58</a> for figuring
most of this stuff out with me and <a href="https://bomberfish.ca">bomberfish</a> for making the neat UI.</p>

<p>I knew that both Celeste and Terraria were written in C# using the
FNA engine, so we should have been able to port Terraria in the same way
they did for Celeste, so we set that as a goal.</p>
<p>The original post didn&#39;t have too many details to go off of, but we
figured a good place to start was setting up a development environment
for modding. In theory, all we needed to do was decompile the game,
change the target to webassembly, and then recompile it.</p>
<p>It turns out that we were very lucky with the game being C#— since
the bytecode format (referred to as MSIL or just IL) maps very closely
to the original code, and the game was shipped with the .pdb symbol
database for mapping function names (and local variables!), we could get
decompilation output that was more or less identical to the original
code.</p>
<h2 id="setting-up-a-project">Setting up a project</h2>
<p>Running <code>ilspycmd</code> on Terraria.exe, decompilation
<em>failed</em> because of a missing <code>ReLogic.dll</code>. It turned
out that the library was actually embedded into the game itself as a
resource.</p>
<p>That&#39;s.. odd, but we can extract it from the binary pretty easily.
Easiest way is just to create a new c# project and dynamically load in
the assembly..</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>Assembly assembly <span>=</span> Assembly<span>.</span><span>LoadFile</span><span>(</span><span>&#34;Terraria.exe&#34;</span><span>);</span></span></code></pre></div>
<p>And then since all the terraria code is loaded, we can just extract
it the same way the game does!</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>Stream<span>?</span> stream <span>=</span> assembly<span>.</span><span>GetManifestResourceStream</span><span>(</span><span>&#34;Terraria.Libraries.NET.ReLogic.dll&#34;</span><span>);</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>FileStream outstream <span>=</span> File<span>.</span><span>OpenWrite</span><span>(</span><span>&#34;ReLogic.dll&#34;</span><span>);</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>stream<span>.</span><span>CopyTo</span><span>(</span>outstream<span>);</span></span></code></pre></div>
<p>After putting <code>ReLogic.dll</code> into the library path,
decompilation succeeded, and after installing all the dependencies
Terraria uses, the project recompiles and launches on linux. Now that we
knew the decompilation was good, I created a project file for the new
code targetting WASM and configuring emscripten.</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>&lt;<span>Project</span><span> Sdk=</span><span>&#34;Microsoft.NET.Sdk.WebAssembly&#34;</span>&gt;</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>&lt;<span>PropertyGroup</span>&gt;</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        &lt;<span>StartupObject</span>&gt;Program&lt;/<span>StartupObject</span>&gt;</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        &lt;<span>EmccExtraLDFlags</span>&gt;-sMIN_WEBGL_VERSION=2 -sWASMFS&lt;/<span>EmccExtraLDFlags</span>&gt;</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        &lt;<span>EmccEnvironment</span>&gt;web,worker&lt;/<span>EmccEnvironment</span>&gt;</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>&lt;/<span>PropertyGroup</span>&gt;</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>&lt;<span>ItemGroup</span>&gt;</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        &lt;<span>PackageReference</span><span> Include=</span><span>&#34;Newtonsoft.Json&#34;</span><span> Version=</span><span>&#34;13.0.3&#34;</span> /&gt;</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        &lt;<span>PackageReference</span><span> Include=</span><span>&#34;Newtonsoft.Json.Bson&#34;</span><span> Version=</span><span>&#34;1.0.3&#34;</span> /&gt;</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        &lt;<span>PackageReference</span><span> Include=</span><span>&#34;DotNetZip&#34;</span><span> Version=</span><span>&#34;1.16.0&#34;</span> /&gt;</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        &lt;<span>PackageReference</span><span> Include=</span><span>&#34;MP3Sharp&#34;</span><span> Version=</span><span>&#34;1.0.5&#34;</span> /&gt;</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        &lt;<span>PackageReference</span><span> Include=</span><span>&#34;NVorbis&#34;</span><span> Version=</span><span>&#34;0.10.5&#34;</span> /&gt;</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>&lt;/<span>ItemGroup</span>&gt;</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>&lt;/<span>Project</span>&gt;</span></code></pre></div>
<p>Somewhat surprisingly, all of the project code compiles without
issue, but the FNA engine is partially written in c++ and needs to be
linked against its native components. The web target isn&#39;t officially
supported by FNA, but its native components compile without issue under
emscripten&#39;s <a href="https://emscripten.org/docs/porting/multimedia_and_graphics/OpenGL-support.html#opengl-support-opengl-es2-0-emulation">opengl
emulation layer</a>. This process is automated by <a href="https://github.com/r58Playz/FNA-WASM-Build">FNA-WASM-BUILD</a> on
github actions to make things slightly less painful.</p>
<p>The archive files from the build system can be added with
<code>&lt;NativeFileReference&gt;</code> and then will automatically get
linked together with the rest of the runtime during emscripten
compilation.</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span>&lt;!-- FNA --&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>&lt;<span>NativeFileReference</span><span> Include=</span><span>&#34;SDL3.a&#34;</span> /&gt;</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>&lt;<span>NativeFileReference</span><span> Include=</span><span>&#34;FNA3D.a&#34;</span> /&gt;</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>&lt;<span>NativeFileReference</span><span> Include=</span><span>&#34;libmojoshader.a&#34;</span> /&gt;</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>&lt;<span>NativeFileReference</span><span> Include=</span><span>&#34;FAudio.a&#34;</span> /&gt;</span></code></pre></div>
<p>After an eight minute compile step dotnet spit out the full
webassembly and JS bundle, which I almost couldn&#39;t believe at first,
since at this point we had just basically just pasted in the terraria
source and barely had to tweak anything. Now we just had to figure out
how to run the actual game.</p>
<h2 id="running-the-game">Running the game</h2>
<p>We ended up just gutting terraria&#39;s linux entry point and creating a
minimal Init() function tagged with <code>[JSExport]</code> so it was
callable, then writing a simple loop to drive the FNA game loop from
JS.</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span>const</span> runtime <span>=</span> <span>await</span> dotnet<span>.</span><span>create</span>()<span>;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span>const</span> config <span>=</span> runtime<span>.</span><span>getConfig</span>()<span>;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span>const</span> exports <span>=</span> <span>await</span> runtime<span>.</span><span>getAssemblyExports</span>(config<span>.</span><span>mainAssemblyName</span>)<span>;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span>const</span> canvas <span>=</span> <span>document</span><span>.</span><span>getElementById</span>(<span>&#34;canvas&#34;</span>)<span>;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>dotnet<span>.</span><span>instance</span><span>.</span><span>Module</span><span>.</span><span>canvas</span> <span>=</span> canvas<span>;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span>console</span><span>.</span><span>debug</span>(<span>&#34;Init...&#34;</span>)<span>;</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span>await</span> exports<span>.</span><span>Program</span><span>.</span><span>Init</span>()<span>;</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span>console</span><span>.</span><span>debug</span>(<span>&#34;MainLoop...&#34;</span>)<span>;</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span>const</span> main <span>=</span> <span>async</span> () <span>=&gt;</span> {</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span>const</span> ret <span>=</span> <span>await</span> exports<span>.</span><span>Program</span><span>.</span><span>MainLoop</span>()<span>;</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span>requestAnimationFrame</span>(main)<span>;</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a><span>requestAnimationFrame</span>(main)<span>;</span></span></code></pre></div>
<p>Since we could access the save path property on the Terraria class,
we didn&#39;t even need to patch the code to get all the paths correct.
After launching, we started to see some signs of life from terraria
code. At this point, the only thing missing was the game assets
themselves.</p>
<p>This means we have another chance to use one of my favorite browser
APIs, the <a href="https://developer.mozilla.org/en-US/docs/Web/API/File_System_API/Origin_private_file_system">Origin
Private File System</a>! Since everything goes through emscripten&#39;s
filesystem emulation, we can just ask the user to select their game
directory with <code>window.showDirectoryPicker()</code>, then copy in
the assets and mount it in the emscripten filesystem.</p>
<p>And sure enough, after a <a href="https://github.com/MercuryWorkshop/terraria-wasm/blob/master/FNA.patch">quick
patch to FNA</a> to resolve a generics issue, the game launched.</p>
<figure><img src="https://velzie.rip/static/celeste-wasm/relogic.png"/><figcaption>Terraria makes it all the way to the loading splash screen!</figcaption></figure>

<p>Annoyingly, uploading files with <code>showDirectoryPicker()</code>
does not work on Firefox. Mozilla has a <a href="https://wicg.github.io/file-system-access/">negative standards
position</a> on the file system access api, and refuses to implement it.
Curiously enough though, they do implement <a href="https://developer.mozilla.org/en-US/docs/Web/API/DataTransferItem/webkitGetAsEntry">DataTransferItem.webkitGetAsEntry</a>
which allows you to do... more or less the same thing as
showdirectorypicker, as long as the user drags in a folder.</p>
<p>Confusing decision, but convienent for us. WebKit also doesn&#39;t
currently support showDirectoryPicker, so I had initially assumed that
it would be impossible to upload assets on iOS Safari, but funnily
enough I was sent a video proving it possible through some funny ui
manuvering:</p>
<blockquote data-theme="dark"><p lang="en" dir="ltr">My Celeste folder? Yeah, it’s in my Files app, hold on let me get it lmfao. <a href="https://t.co/Yo0lcdr3mg">pic.twitter.com/Yo0lcdr3mg</a></p>— EnergeticBark (@energeticbark) <a href="https://twitter.com/energeticbark/status/1927441336141041791?ref_src=twsrc%5Etfw">May 27, 2025</a></blockquote> 

<p>...and then immediately crashed, after trying to create a new thread,
which was not supported in .NET 8.0 wasm.</p>
<p>Fortunately we found a clever solution: waiting about a month for NET
9.0 to get a stable release. Once it was packaged, we could just toggle
the new <code>WasmEnableThreads</code> option.</p>
<p>I upgraded NET, waited for it to compile, and... FNA threw an error
during initialization</p>
<p>It turns out that in NET threaded mode, <em>all</em> code runs inside
web workers, not just the secondary threads. What would usually be
called the &#34;main&#34; thread is actually running on
<code>dotnet-worker-001</code>, referred to as the &#34;deputy thread&#34;.</p>
<p>This is an issue since FNA is solely in the worker, and the
<code>&lt;canvas&gt;</code> can only be accessed on the DOM thread. This
is solved by the browser&#39;s <code>OffscreenCanvas</code> API, but we were
still working with SDL2, which didn&#39;t support it, and FNA didn&#39;t work
with SDL3 at the time we wrote this.</p>
<h2 id="fna-proxy">FNA Proxy</h2>
<p>If we couldn&#39;t run the game on the main thread, and we couldn&#39;t
transfer the canvas over to the worker, the only option left was to
proxy the OpenGL calls to the main thread.</p>
<p>We wrote a <a href="https://github.com/r58Playz/FNA-WASM-Build/blob/b05cbc703753c917499bf955091f62c3b845ba8f/wrap_fna.fish">fish
script</a> that would automatically parse every single method from
FNA3D&#39;s exported symbols (FNA&#39;s native C component), and automatically
compile and export a wrapper method that would use
<code>emscripten_proxy_sync</code> to proxy the call from
<code>dotnet-worker-001</code> to the DOM thread.</p>
<p>Let&#39;s look at the native method
<code>FNA3D_Device* FNA3D_CreateDevice(FNA3D_PresentationParameters *presentationParameters,uint8_t debugMode);</code>,
the first one that gets called in any program</p>
<p>The script automatically generates a C file containing the wrapper
method, <code>WRAP_FNA3D_CreateDevice</code></p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span>typedef</span> <span>struct</span> <span>{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    FNA3D_PresentationParameters <span>*</span>presentationParameters<span>;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span>uint8_t</span> debugMode<span>;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    FNA3D_Device<span>*</span> <span>*</span>WRAP_RET<span>;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span>}</span> WRAP__struct_FNA3D_CreateDevice<span>;</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span>void</span> WRAP__MAIN__FNA3D_CreateDevice<span>(</span><span>void</span> <span>*</span>wrap_struct_ptr<span>)</span> <span>{</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    WRAP__struct_FNA3D_CreateDevice <span>*</span>wrap_struct <span>=</span> <span>(</span>WRAP__struct_FNA3D_CreateDevice<span>*)</span>wrap_struct_ptr<span>;</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span>*(</span>wrap_struct<span>-&gt;</span>WRAP_RET<span>)</span> <span>=</span> FNA3D_CreateDevice<span>(</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        wrap_struct<span>-&gt;</span>presentationParameters<span>,</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        wrap_struct<span>-&gt;</span>debugMode</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span>);</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>FNA3D_Device<span>*</span> WRAP_FNA3D_CreateDevice<span>(</span>FNA3D_PresentationParameters <span>*</span>presentationParameters<span>,</span><span>uint8_t</span> debugMode<span>)</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    <span>// func: `FNA3D_Device* FNA3D_CreateDevice(FNA3D_PresentationParameters *presentationParameters,uint8_t debugMode)`</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    <span>// ret: `FNA3D_Device*`</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    <span>// name: `FNA3D_CreateDevice`</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    <span>// args: `FNA3D_PresentationParameters *presentationParameters,uint8_t debugMode`</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    <span>// argsargs: `presentationParameters,debugMode`</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    <span>// argc: `2`</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>    <span>//</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>    <span>// return FNA3D_CreateDevice(presentationParameters,debugMode);</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>    FNA3D_Device<span>*</span> wrap_ret<span>;</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>    WRAP__struct_FNA3D_CreateDevice wrap_struct <span>=</span> <span>{</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>        <span>.</span>presentationParameters <span>=</span> presentationParameters<span>,</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>        <span>.</span>debugMode <span>=</span> debugMode<span>,</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>        <span>.</span>WRAP_RET <span>=</span> <span>&amp;</span>wrap_ret</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>    <span>};</span></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>    <span>if</span> <span>(!</span>emscripten_proxy_sync<span>(</span>emscripten_proxy_get_system_queue<span>(),</span> emscripten_main_runtime_thread_id<span>(),</span> WRAP__MAIN__FNA3D_CreateDevice<span>,</span> <span>(</span><span>void</span><span>*)&amp;</span>wrap_struct<span>))</span> <span>{</span></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>        emscripten_run_script<span>(</span><span>&#34;console.error(&#39;wrap.fish: failed to proxy FNA3D_CreateDevice&#39;)&#34;</span><span>);</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>        assert<span>(</span><span>0</span><span>);</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>    <span>return</span> wrap_ret<span>;</span></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>And the wrapper is compiled in with the rest of FNA3D.</p>
<p>Then in the FNA C# code, where the native C is linked to, we replace
the PInvoke binding:</p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span>[</span><span>DllImport</span><span>(</span>FNA3D<span>,</span> EntryPoint <span>=</span> <span>&#34;FNA3D_CreateDevice&#34;</span><span>,</span> CallingConvention <span>=</span> CallingConvention<span>.</span><span>Cdecl</span><span>)]</span>`</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span>public</span> <span>static</span> <span>extern</span> IntPtr <span>FNA3D_CreateDevice</span><span>(...);</span></span></code></pre></div>
<p>...With one that calls our wrapper instead</p>
<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span>[</span><span>DllImport</span><span>(</span>FNA3D<span>,</span> EntryPoint <span>=</span> <span>&#34;WRAP_FNA3D_CreateDevice&#34;</span><span>,</span> CallingConvention <span>=</span> CallingConvention<span>.</span><span>Cdecl</span><span>)]</span>`</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span>public</span> <span>static</span> <span>extern</span> IntPtr <span>FNA3D_CreateDevice</span><span>(...);</span></span></code></pre></div>
<p>Ensuring that all the native calls to SDL went through the DOM thread
instead of C#&#39;s &#34;main&#34; deputy thread.</p>
<p>Okay. That was a lot. It was worth it seeing the menu finally load
though, even if it was missing localization.</p>
<figure><img src="https://velzie.rip/static/celeste-wasm/tmenu.webp"/><figcaption>Terraria main menu, minus the apparently important localization files</figcaption></figure>

<p>And then I tried entering a world, to be met with:</p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span>- Uncaught ManagedError: Cryptography_AlgorithmNotSupported, Aes</span></span></code></pre></div>
<p>Alright. I guess AES just doesn&#39;t exist in NET wasm anymore. &#34;write
once, run everywhere&#34; and then they stop supporting parts of the
standard library for some reason. Awesome.</p>
<p>It&#39;s not too hard to shim the implementation though, and I could use
the same <code>&lt;NativeFileReference&gt;</code> block to link
emscripten OpenSSL and implement the cryptography myself. And after a
bit of extra tweaking, worlds could load.</p>
<figure><img src="https://velzie.rip/static/celeste-wasm/tworlds.png"/><figcaption>My current best progressed save file (I lost my old ones)</figcaption></figure>

<p>The framerate of around 2 FPS wasn&#39;t promising, but fortunately
enabling <a href="https://learn.microsoft.com/en-us/aspnet/core/blazor/webassembly-build-tools-and-aot?view=aspnetcore-9.0">Ahead-Of-Time
Compilation</a> was able to get the performace up to being completely
usable, even on low end devices.</p>
<p>You can play our port right now <a href="https://terraria.mercurywork.shop">here</a>, as long as you own a
copy of the game, or check out our <a href="https://github.com/MercuryWorkshop/terraria-wasm">git
repository</a>.</p>

<p>Of course, terraria wasn&#39;t enough. We also wanted to get Celeste
working, since the person who shared the initial snippet had never
released their work publicly. We also had some far away hopes of maybe
also getting the <a href="https://everestapi.github.io">Everest mod
loader</a> to run in the browser.</p>
<p>Since it&#39;s the same game engine, we just copied and pasted the
existing code. At this point, the SDL3 tooling was also stable enough
for us to upgrade, giving us access to <code>OffscreenCanvas</code>, so
we would no longer need the proxy hack. Naturally, we still needed to <a href="https://github.com/MercuryWorkshop/celeste-wasm/blob/threads-v2/Makefile#L52">patch
emscripten</a> to work around some bugs. nothing is ever without jank
:)</p>
<p>We had another dependency issue though: Celeste uses the proprietary
<a href="https://www.fmod.com">FMOD</a> library for game audio instead
of FAudio like Terraria. FMOD <em>does</em> provide emscripten builds,
distributed as archive files, but as luck would have it- it also didn&#39;t
like being run in a worker. We could use the wrap script again, but it
isn&#39;t open source, so we couldn&#39;t just recompile it like we did for FNA.
But, since we weren&#39;t modifying the native code itself, we could just
extract the <code>.o</code> files from the FMOD build, and insert the
codegenned c compiled as an object.</p>
<p>After a couple of patches that aren&#39;t worth mentioning here:</p>
<figure><img src="https://velzie.rip/static/celeste-wasm/celeste.png"/><figcaption>Celeste splash screen!</figcaption></figure>

<p>Base game celeste was awesome, but what I was really looking forward
to was getting the <a href="https://gamebanana.com/mods/424541">strawberry jam</a> mod to
load, one of the largest and most complete level compilation in the
community. This would mean supporting Everest mods.</p>
<p>A mod loader is generally built around two components, a patched
version of the game that provides an api, and a method of loading code
at runtime and modifying behavior. In Everest, both are provided by
MonoMod, an instrumentation framework for c# specifically built for game
modding.</p>
<p>The patcher part modifies the game on disk, so no problem there, it&#39;s
the same in the browser. But the runtime modifications use a module
called <code>RuntimeDetour</code>, which is essential to most mods, and
<em>very not supported</em> on WebAssembly.</p>

<p>We knew this would be the hardest part of the project, and had put it
off for a while. Internally, as the name would suggest, RuntimeDetour is
powered by function detouring, a common tool for game modding/cheating.
Typically though, it&#39;s associated with unmanaged languages like c/c++.
It works a little differently in a language like c#.</p>
<p>Oversimplifying a little, the process MonoMod uses to hook into
functions on desktop is:</p>
<ul>
<li>Copy the original method&#39;s IL bytecode into a new controlled method
with modifications</li>
<li>Call MethodBase.GetFunctionPointer() or &#34;thunk&#34; the runtime to
retrieve pointers to the executable regions in memory that the jit code
is held in</li>
<li>Ask the OS kernel to disable write protection on the pages of memory
where the jitted code is</li>
<li>Write the bytes for a long jmp
(<code>0xFF 0x25 &lt;pointer&gt;</code>) into the start of the function
to redirect the control flow back into MonoMod.</li>
<li>Force the JIT code for the new modified method to generate and move
the control flow there.</li>
</ul>
<p>This works because on desktop, all functions run through the CoreCLR
JIT before they&#39;re executed, so all functions are guaranteed to have
corresponding native code regions before they&#39;re even executed.</p>
<p>However, Mono WASM does not work this way. It runs in mostly
interpreted mode with a limited “jit-traces” engine called the
&#34;jiterpreter&#34;, meaning not every method will have corresponding native
code.</p>
<p>And even if it did - WebAssembly modules are <em>read only</em>, you
can add new code at runtime, but you can&#39;t just hot patch existing code
to mess with the internal state. WebAssembly is AOT compiled to native
code on module instantiation, so it would be infeasible to allow runtime
modification while keeping internal guarantees.</p>
<p>So instead of creating a detour by modifying raw assembly, what if we
just disabled the jiterpreter and modified the IL bytecode? Since it&#39;s
all interpreted on the fly, we should just be able to mess with the
instructions loaded into memory.</p>
<p>To check the feasibility, I ran a simple test: run
<code>MethodBase.GetILAsByteArray()</code>, then brute force search for
those bytes in the webassembly memory and replace them with a bytecode
NOP (<code>0x00 0x2A</code>)</p>
<figure><img src="https://velzie.rip/static/celeste-wasm/mod-poc.webp"/><figcaption>Console output showing overwriting RealTargetFunc() with a NOP sequence. The function doesn&#39;t print anything when called, meaning the patch worked</figcaption></figure>

<p>Perfect! Now if we could just find the bytecode pointer
programmatically...</p>
<p>There was the address from
<code>MethodBase.GetFunctionPointer()</code>, but it wasn&#39;t anywhere
near the code, and it definitely wasn&#39;t a native code region like on
desktop. Eventually we realized that it was a pointer to the mono
runtime&#39;s <a href="https://github.com/dotnet/runtime/blob/a2e1d21bb4faf914363968b812c990329ba92d8e/src/mono/mono/mini/interp/interp-internals.h#L121">internal
<code>InterpMethod</code> struct</a>.</p>
<p>Since it would be easier to work with the structs in c, we added a
new c file to the project with <code>&lt;NativeFileReference&gt;</code>
and copied in the mono headers. Sure enough, when we passed in the
address from GetFunctionPointer, we could read
<code>ptr-&gt;method-&gt;name</code> and extract metadata from the
function. Even with this though, we couldn&#39;t find the actual code
pointer, as it was in a hash table that we didn&#39;t have the pointer
to.</p>
<p>Suddenly, we noticed something really cool: since everything was
eventually compiling to a single <code>.wasm</code> file, the c program
that we had just created was linked in the same step as the mono runtime
itself. This meant that we could access any internal mono function or
object just by name. We were more or less executing code inside the
runtime itself.</p>
<p>With our new ability to call any internal function, we found
<code>mono_method_get_header_internal</code>, and calling it with the
pointer we found earlier finally allowed us to get to the code
region.</p>
<p>Now we just needed to find out what bytes to inject into the method
that would let us override the control flow in a way that&#39;s compatible
with monomod.</p>
<p>By looking at the MSIL documentation and <a href="https://phrack.org/issues/70/6">this post</a> we were eventually
able to come up with something that worked:</p>
<ul>
<li>insert one <code>ldarg.i</code> (<code>0xFE 0x0X</code>)
corresponding to each argument in the original method</li>
<li>call <code>System.Reflection.Emit</code> to generate a new dynamic
function with the exact same signature as the original method</li>
<li>insert an <code>ldc.i4</code> (<code>0x20 &lt;int32&gt;</code>) and
put in the delegate pointer for the function we just created</li>
<li>insert <code>calli</code> (<code>0x29</code>) to jump to the dynamic
method</li>
<li>add a return (<code>0x2A</code>) to prevent executing the rest of
the function</li>
</ul>
<p>Once the hooked function is called, it runs our dynamic method, which
will:</p>
<ul>
<li><code>ldarg</code> each argument and store it in a temporary
array</li>
<li>call into our c method, restoring the original IL and invalidating
the source method</li>
<li>run the mod&#39;s hook function and return to monomod</li>
</ul>
<p>Calling the function would make Mono assert at runtime though. It
turns out that we need to load a &#34;metadata token&#34; to determine the
method&#39;s signature before we run <code>calli</code>, and since the
dynamic method is technically in a different assembly, it wouldn&#39;t be
able to resolve it by default.</p>
<p>This was a simple fix though, since the dyn method has the same
signature as the original one, we just had to clone the parent method&#39;s
metadata in C and insert it into the internal mono hash table. This gave
us a working detour system, but it turned out that last step broke in
multithreaded mode, since each thread had it&#39;s own struct that needed to
be modified.</p>
<p>There&#39;s probably a bypass for that, but at this point we figured it
would just be easier to patch the runtime itself. After all, it&#39;s not
like we have to worry about a user&#39;s individual setup, it&#39;s all running
on the web.</p>
<p>Here&#39;s a simple patch, it would just clone the caller&#39;s signature
when it saw our magic token <code>(0xF0F0F0F0)</code>, and we wouldn&#39;t
need to mess with any tables</p>
<div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span>--- a/src/mono/mono/mini/interp/transform.c</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span>+++ b/src/mono/mono/mini/interp/transform.c</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span>@@ -3489,7 +3489,9 @@ interp_transform_call (TransformData *td, MonoMethod *method, MonoMethod *target</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    if (target_method == NULL) {</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        if (calli) {</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span>-           if (method-&gt;wrapper_type != MONO_WRAPPER_NONE)</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span>+           if (token == 0xF0F0F0F0)</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span>+               csignature = method-&gt;signature;</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span>+           else if (method-&gt;wrapper_type != MONO_WRAPPER_NONE)</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>                csignature = (MonoMethodSignature *)mono_method_get_wrapper_data (method, token);</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>            else {</span></code></pre></div>
<p>Then, after recompiling dotnet, we could just put the patched sdk
into the NuGet folder and have dotnet build the webassembly with our
custom runtime.</p>
<p>Naturally, as with Everything C, we had somehow managed to trigger
some memory corruption that the runtime wasn&#39;t happy about. But we got
everything polished up eventually.</p>
<p>Now that we had a functional detour factory that worked in
WebAssembly, we could slot it into MonoMod and start compiling
everest.</p>

<p>So far, we&#39;ve just been porting games by decompiling, editing source,
then making a new project with all the celeste code included and
recompiling. How is that going to work with everest? It patches the
celeste binary&#39;s bytecode itself, and we can&#39;t just use that as the base
for decompilation because the patcher&#39;s output can&#39;t be translated to
normal c#.</p>
<p>What we could do though is load the game binary at runtime, instead
of compiling it with the project. The project we compile to wasm would
just be a stub loader, and we could load any celeste binary.</p>
<div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>Assembly celeste <span>=</span> Assembly<span>.</span><span>LoadFrom</span><span>(</span><span>&#34;/libsdl/Celeste.exe&#34;</span><span>);</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span>var</span> Celeste <span>=</span> celeste<span>.</span><span>GetType</span><span>(</span><span>&#34;Celeste.Celeste&#34;</span><span>);</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>celeste<span>.</span><span>GetType</span><span>(</span><span>&#34;Celeste.RunThread&#34;</span><span>).</span><span>GetMethod</span><span>(</span><span>&#34;WaitAll&#34;</span><span>).</span><span>Invoke</span><span>(</span><span>null</span><span>,</span> <span>[]);</span></span></code></pre></div>
<p>It feels a little weird to be talking about running an <em>exe
file</em> in the browser, but since it&#39;s really just CIL bytecode inside
a PE32 container, there&#39;s no reason it shouldn&#39;t work. And since we have
dependencies directly added to the loader project, the runtime will find
our web FNA before the real game&#39;s desktop FNA, so the game will call
our libraries with no need for patching.</p>
<p>Of course, the game won&#39;t work, since we needed patches in a few
places to get it to run in the browser without crashing.</p>
<p>We just made an entire framework for patching code at runtime though,
so we can just use that, we just need to instantiate a <code>Hook</code>
for the functions we need to patch then make our changes.</p>
<p>Here&#39;s an example hook, we need to force the window buffer to a
specific size after the screen initializes, which we can do by finding
<code>ApplyScreen</code> on the dynamically loaded assembly and running
our code after it</p>
<div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>Hook hook <span>=</span> <span>new</span> <span>Hook</span><span>(</span>Celeste<span>.</span><span>GetMethod</span><span>(</span><span>&#34;ApplyScreen&#34;</span><span>),</span> <span>(</span>Action<span>&lt;</span><span>object</span><span>&gt;</span> orig<span>,</span> <span>object</span> self<span>)</span> <span>=&gt;</span> <span>{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span>var</span> Engine <span>=</span> celeste<span>.</span><span>GetType</span><span>(</span><span>&#34;Monocle.Engine&#34;</span><span>);</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span>var</span> Graphics <span>=</span> Engine<span>.</span><span>GetProperty</span><span>(</span><span>&#34;Graphics&#34;</span><span>,</span> BindingFlags<span>.</span><span>Public</span> <span>|</span> BindingFlags<span>.</span><span>Static</span><span>);</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span>orig</span><span>(</span>self<span>);</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    GraphicsDeviceManager graphics <span>=</span> <span>(</span>GraphicsDeviceManager<span>)</span>Graphics<span>.</span><span>GetValue</span><span>(</span><span>null</span><span>);</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span>if</span> <span>(</span>graphics <span>==</span> <span>null</span><span>)</span> <span>throw</span> <span>new</span> <span>Exception</span><span>(</span><span>&#34;Failed to get GraphicsDeviceManager&#34;</span><span>);</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    graphics<span>.</span><span>PreferredBackBufferWidth</span> <span>=</span> <span>1920</span><span>;</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    graphics<span>.</span><span>PreferredBackBufferHeight</span> <span>=</span> <span>1080</span><span>;</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    graphics<span>.</span><span>IsFullScreen</span> <span>=</span> <span>false</span><span>;</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    graphics<span>.</span><span>ApplyChanges</span><span>();</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a><span>});</span></span></code></pre></div>
<p>Now that the loader doesn&#39;t care where the code comes from, we can
just swap out <code>Celeste.exe</code> with the patched version from an
everest install.</p>
<figure><img src="https://velzie.rip/static/celeste-wasm/everest-load.webp"/><figcaption>Everest loading on an old version of the celeste-wasm frontend</figcaption></figure>

<p>Do mods load? Nope, apparently it&#39;s crashing after trying to patch a
mod DLL with monomod.</p>
<p>Wait, why is the mod loader patching the mod file?</p>
<p>Ah. I see. <strong>Everest is using monomod to modify the mod&#39;s calls
to monomod</strong>. Sure. Why not.</p>
<p>I think this is for compatibility reasons? Anyway there&#39;s no reason
monomod.patcher shouldn&#39;t just work at runtime, it&#39;s just the thing that
patches il binaries on disk. We just needed to copy all the original
dependencies into the filesystem so that monomod has all the symbols.
And since we&#39;re already shipping MonoMod.Patcher, we might as well just
install Everest all in the browser by downloading the everest dll
directly from github and running the patcher on Celeste.exe</p>
<p>That&#39;s a lot of patches!! Throughout the project, our patching system
went from: uploading entire source code to a git repo -&gt; automated
diff generation of <code>.patch</code> files -&gt; hooking functions
with RuntimeDetour -&gt; patching Celeste.exe bytecode in the browser
before the game starts</p>
<p>And as a bonus, now we&#39;re not hosting any Celeste IP, since all
proprietary code gets loaded and patched inside the user&#39;s browser.</p>
<p>finally, mods and custom maps work</p>
<figure><img src="https://velzie.rip/static/celeste-wasm/mods.webp"/><figcaption>Hyperline and Ultra Skool mods loaded into celeste-wasm with Everest</figcaption></figure>

<h2 id="race-to-strawberry-jam">race to strawberry jam</h2>
<p>The Strawberry Jam mod has dependencies on over 60 individual mods.
Most would load fine, but a lot didn&#39;t. We had to get all of them
working.</p>
<p>Here&#39;s a fun issue - one of the mods tries to RuntimeDetour a
function that&#39;s so small that the bytes of our jump patch overflow the
code buffer. For cases like these, we found out how to abuse mono&#39;s hot
reload module to replace function bodies instead of directly modifying
the memory.</p>
<p>As we progressed it became increasingly clear that apparently wasm
.NET is just straight up broken in a lot of cases. It makes sense, it&#39;s
a pretty niche piece of software. The main use case is the Blazor web
framework, and no one really uses it, not even microsoft. A
not-insignificant portion of our time was simply spent working around
.NET bugs. <a href="https://github.com/dotnet/runtime/issues/112262">(like this
one)</a></p>
<p>Other than the runtime bugs, the rest of the mod compatibility issues
were actually just subtle differences between the Mono Runtime (used for
webassembly and Wine) and CoreCLR (used for most desktop applications).
No one plays Celeste on Mono so no one noticed it. First issue was a mod
tripping a mono error during some reflection.</p>
<p>Again, the easiest way to get around this was just to patch the
runtime. We&#39;re already running a modified sdk anyway, one more hackfix
can&#39;t hurt.</p>
<p>FrostHelper won&#39;t load because the class override isn&#39;t valid? Well
it is now.</p>
<div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span>--- a/src/mono/mono/metadata/class-setup-vtable.c</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span>+++ b/src/mono/mono/metadata/class-setup-vtable.c</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span>@@ -773,6 +773,7 @@ mono_method_get_method_definition (MonoMethod *method)</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a> static gboolean</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a> verify_class_overrides (MonoClass *klass, MonoMethod **overrides, int onum)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a> {</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span>+   return TRUE;</span></span></code></pre></div>
<p>SecurityException? Who needs security anyway?</p>
<div id="cb14"><pre><code><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span>+++ b/src/mono/mono/metadata/class.c</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span>@@ -6480,6 +6480,7 @@ can_access_member (MonoClass *access_klass, MonoClass *member_klass, MonoClass*</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a> gboolean</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a> mono_method_can_access_field (MonoMethod *method, MonoClassField *field)</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a> {</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span>+   return TRUE;</span></span></code></pre></div>
<p>And.. uhh. oh. ok</p>
<p>So it turns out that mono&#39;s internal implementation of
<code>System.Reflection.Module.GetTypes</code> is Broken and does not
follow spec. Since the mods we&#39;re loading have extremely excessive use
of reflection, a few of them are crashing. That&#39;s not a trivial fix, but
after patching the runtime again with a <a href="https://github.com/r58Playz/FNA-WASM-Build/blob/1231d08a85a236bbae04c49803f36b80833bc2ac/dotnet.patch#L85">reimplementation
of the broken icall</a> in c, all the the mono bugs are finally fixed
and we can move on.</p>
<p>Just kidding. Apparently static initializer order <a href="https://github.com/dotnet/runtime/issues/77513">doesn&#39;t follow
spec</a> and is breaking some of our mods. Another runtime patch?
Another runtime <a href="https://github.com/r58Playz/FNA-WASM-Build/blob/main/dotnet.patch#L193">patch</a>.</p>
<p>Finally, it looked like we had gotten all of the issues sorted out.
200 lines of mono patches, 53 mods, and roughly a year passed since we
started the project.</p>
<p>Was it worth it? Probably.</p>
<figure><img src="https://velzie.rip/static/celeste-wasm/celeste-sj.webp"/><figcaption><i>Strawberry Jam</i> mod running in celeste-wasm</figcaption></figure>

<p>Fun side quest: how about we get the celeste multiplayer mod running
in a browser?</p>
<figure><img src="https://velzie.rip/static/celeste-wasm/celestenet.webp"/><figcaption>Two browser windows connected to the same celeste game through celestenet, routed through the wisp server running in the bottom terminal</figcaption></figure>

<p>The helpful <code>[MonoModRelinkFrom]</code> attribute lets us
declare a class to replace any system one, letting us intercept <a href="https://github.com/0x0ade/CelesteNet">CelesteNet</a>&#39;s creation of
a `System.Net.Socket` with our own class that makes TCP connections over
a <a href="https://github.com/MercuryWorkshop/wisp-protocol">wisp
protocol</a> proxy.</p>
<p>We&#39;ll use the same wisp connection to download mods from gamebananna
too, since it&#39;s normally blocked by CORS policy.</p>
<figure><img src="https://velzie.rip/static/celeste-wasm/modinstaller.png"/><figcaption>Mod installer tab, showing the featured celeste mods on gamebananna</figcaption></figure>

<p>That&#39;s about it! You can play it on our deployment <a href="https://celeste.r58playz.dev">here</a> or check out the <a href="https://github.com/MercuryWorkshop/celeste-wasm">git
repository</a>.</p>
<p>I guess there&#39;s only one question left...</p>

<p>Short answer: Chromebooks! They do ship with a linux emulator, but
it&#39;s slow, and a &#34;native&#34; version of the game is cooler.</p>
<p>Long Answer:</p>
<p>As much as I <em>can</em> justify it, this project is probably going
to be useless to most people. Not many people are seriously going to
play all of celeste or terraria in the browser, and the novel things we
<em>did</em> discover along the way are probably too niche to be of any
help to anyone else.</p>
<p>Even so, I can confidently say that this was one of the most fun
projects I&#39;ve ever worked on, having unique constraints, revolving
around an interesting technology, and putting me in contact with some
cool people.</p>
<p>Sometimes it pays off to just have fun with a project. Mess around
with some obscure technologies, do something impractical on the web. And
whether it was worth my time or not, you can play celeste in the browser
now, and i think that&#39;s pretty cool.</p>
</div></div>
  </body>
</html>
