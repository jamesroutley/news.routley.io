<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.felixge.de/blazingly-fast-shadow-stacks-for-go/">Original</a>
    <h1>Fast Shadow Stacks for Go</h1>
    
    <div id="readability-page-1" class="page"><div>
        <p><strong>tl;dr</strong>: Software shadow stacks could deliver <strong>up to 8x faster stack trace capturing</strong> in the Go runtime when compared to the frame pointer unwinding that landed in go1.21. This doesn&#39;t mean that this idea should escape from the laboratory right away, but it offers a fun glimpse into a potential future of hardware accelerated stack trace capturing via shadow stacks.</p><h2 id="inspiration">Inspiration</h2><p>A couple of days ago I came across an <a href="https://news.ycombinator.com/item?id=40456666&amp;ref=blog.felixge.de" rel="noreferrer">interesting comment</a> from the author of the  <a href="https://github.com/koute/bytehound?ref=blog.felixge.de" rel="noreferrer">Bytehound profiler</a> on Hacker News. The comment was in response to somebody asking if the fast stack trace capturing technique mentioned in the project&#39;s README is based on frame pointers. The response was:</p><blockquote>No. It&#39;s DWARF based.</blockquote><h2 id="background">Background</h2><p>Before we get into the gnarly details, let&#39;s briefly remember that capturing a stack trace for a native language such as C/C++/Go/Rust is essentially the act of traversing all call frames on the stack and collecting the return addresses that are stored inside of them.</p><p>The simplest way to do this is via a compiler (option) that adds a preamble to every function, causing it to push a pointer to the previous frame onto the stack. This effectively turns the stack frames into a linked list and allows for very <a href="https://blog.felixge.de/reducing-gos-execution-tracer-overhead-with-frame-pointer-unwinding/" rel="noreferrer">fast stack trace capturing</a> which I helped to <a href="https://blog.felixge.de/waiting-for-go1-21-execution-tracing-with-less-than-one-percent-overhead/" rel="noreferrer">implement for go1.21</a>.</p><p>However, for legacy reasons going back to the days when we had only 32bit CPUs with limited registers, compilers other than Go generally omit frame pointers for optimized builds (<code>-O1</code> or greater). The tide on this is <a href="https://www.brendangregg.com/blog/2024-03-17/the-return-of-the-frame-pointers.html?ref=blog.felixge.de" rel="noreferrer">currently turning</a>, but for the time being, in many cases DWARF or other unwind tables have to be used in order to lookup the distance between the frames of the stack.</p><p>Since DWARF unwind tables are expressed in terms of opcodes for a Turing-complete VM (I wish I was making this up), it&#39;s pretty common to preprocess this data for better lookup performance. In fact, there is a <a href="https://dl.acm.org/doi/10.1145/3360572?ref=blog.felixge.de" rel="noreferrer">neat paper</a> that goes as far as directly precompiling these unwind tables into x86_64 code. I&#39;m not sure if that&#39;s the kind of preprocessing the Bytehound profiler does, but it doesn&#39;t really matter.</p><p>Because at the end of the day, no matter how well this kind of preprocessing is done, frame pointer unwinding tends to outperform these approaches by at least an order of magnitude. Pitting a table lookup against linked list traversal is simply like bringing a knife to a gun fight ... or so I thought.</p><p>It turns out that the main advantage of a gun is to quickly attack a target over a distance. But, as we&#39;ll now explore, the second trick mentioned by the Bytehound author is to shrink the distance between the knife and the gun, turning the situation into more of a close-quarter combat.</p><h2 id="shadow-stacks">Shadow Stacks</h2><p>So, what do I mean by shrinking the distance? Well, it turns out that the act of repeatedly capturing stack traces often involves a lot of duplicated work. That&#39;s because most of the time only a few leaf frames have changed in between two stack traces being captured, yet we end up re-traversing the unchanged frames over and over again. This insight naturally leads to the idea of maintaining a cache of return addresses that allows us to avoid this duplicate work at the cost of maintaining the cache. Such a cache is also know as a &#34;shadow stack&#34;.</p><p>One way to maintain such a shadow stack is to push return addresses to both the normal as well as the shadow stack for every function call and to pop addresses from both places upon return. This could be managed by the compiler, but would add a fixed cost to all function calls and returns that is likely to be significantly larger than the act of pushing a frame pointer. Alternatively this could be done by hardware, and it turns out this has <a href="https://www.phoronix.com/news/Intel-Shadow-Stack-Linux-6.6?ref=blog.felixge.de" rel="noreferrer">recently landed</a> as a security feature for modern Intel CPUs in the Linux kernel.</p><p>But as far as I can tell, it&#39;s <a href="https://docs.kernel.org/next/x86/shstk.html?ref=blog.felixge.de" rel="noreferrer">not yet possible</a> to access these hardware shadow stacks from user space, nor is the technology widely available at this point. So until I saw the comment from Bytehound&#39;s author, I had assumed that shadow stacks would not be a feasible user space technique.</p><p>It turns out that I was wrong. An alternative approach is to populate a shadow stack when a stack trace is captured. This eliminates the overhead of having to update the shadow stack for every function call. However, it still leaves the problem of popping return addresses when the function that populated the cache returns. This is where the clever trampoline trick from the Bytehound author comes in. The idea is to exploit the very security problem hardware shadow stacks are supposed to prevent, and overwrite return addresses on the stack to inject a trampoline function that pops an address from the shadow stack before returning control to this address.</p><p>I was immediately intrigued by the potential of this idea. In theory it seems like it could amortize most of the costs associated with DWARF unwinding on the happy path. However, I was skeptical how well the approach would fare under what I imagined to be a worst-case workload.</p><figure><img src="https://blog.felixge.de/content/images/2024/05/2024-05-28-profiling-team--Channel----Datadog---70-new-items---Slack-at-00.22.57@2x.png" alt="" loading="lazy" width="936" height="202" srcset="https://blog.felixge.de/content/images/size/w600/2024/05/2024-05-28-profiling-team--Channel----Datadog---70-new-items---Slack-at-00.22.57@2x.png 600w, https://blog.felixge.de/content/images/2024/05/2024-05-28-profiling-team--Channel----Datadog---70-new-items---Slack-at-00.22.57@2x.png 936w" sizes="(min-width: 720px) 720px"/><figcaption><span>Message from an internal slack channel at work</span></figcaption></figure><h2 id="implementing-shadow-stacks-in-go">Implementing Shadow Stacks in Go</h2><p>One of the things I like about my org at Datadog, is that we do research weeks regularly. During those one week periods, we are encouraged to learn new things or research difficult problems. I didn&#39;t find much time last week for this yet, but trying out a potentially feasible shadow stack technique was too exciting for me to pass up, so I got to work.</p><p>My goal was to see if it was possible to use the shadow stack idea to accelerate frame pointer unwinding in Go even further. Unlike DWARF, frame pointers don&#39;t really need any additional acceleration, but I figured it would be a fun challenge.</p><p>So I decided to implement a <code>ShadowFPCallers</code> function that combines frame pointer unwinding and shadow stacks, and benchmark it against a regular frame pointer unwinding function called <code>FPCallers</code>. </p><p>You can see the full source code <a href="https://go-review.googlesource.com/c/go/+/588615?ref=blog.felixge.de" rel="noreferrer">here</a>, but the core of the implementation is rather simple. First I added a new <code>shadowStack</code> field to the goroutine struct <code>g</code>. I also declared a new type for it thinking I&#39;d need multiple fields. But I ended up just needing a single <code>pcs []uintptr</code> field.</p><pre><code>type g struct {
  ...
  shadowStack
}

type shadowStack struct {
	pcs []uintptr
}</code></pre><p>The <code>ShadowFPCallers</code> function is a little more complex, but generally speaking it&#39;s a frame pointer unwinding loop that injects a special <code>shadowTrampolineASM</code> return address and uses it as a marker to realize that the rest of the return addresses can be copied from the shadow stack. It&#39;s also smart enough to incrementally update the shadow stack when the stack depth increases.</p><pre><code>func ShadowFPCallers(pcs []uintptr) (i int) {
	const shadowDepth = 2
	var (
		gp           = getg()
		fp           = unsafe.Pointer(getfp())
		oldShadowPtr unsafe.Pointer
		newShadowPtr unsafe.Pointer
	)
	for i = 0; i &lt; len(pcs) &amp;&amp; fp != nil; i++ {
		pcPtr := unsafe.Pointer(uintptr(fp) + goarch.PtrSize)
		pc := *(*uintptr)(pcPtr)
		if i == shadowDepth {
			newShadowPtr = pcPtr
		}
		if pc == abi.FuncPCABIInternal(shadowTrampolineASM) {
			i += copy(pcs[i:], gp.shadowStack.pcs)
			oldShadowPtr = pcPtr
			break
		}
		pcs[i] = pc
		fp = unsafe.Pointer(*(*uintptr)(fp))
	}
	if oldShadowPtr == newShadowPtr {
		return
	}
	if oldShadowPtr != nil {
		*(*uintptr)(oldShadowPtr) = gp.shadowStack.pcs[0]
	}
	gp.shadowStack.pcs = append(gp.shadowStack.pcs[0:0], pcs[shadowDepth:i]...)
	*(*uintptr)(newShadowPtr) = abi.FuncPCABIInternal(shadowTrampolineASM)
	return
}</code></pre><p>The <code>shadowTrampolineASM</code> function itself is a thin wrapper around a <code>shadowTrampolineGo</code> function. Together they take care of popping an address from the shadow stack, injecting the trampoline into the parent caller and restoring the popped address in the link register <code>R30</code> (arm64).</p><pre><code>TEXT ·shadowTrampolineASM&lt;ABIInternal&gt;(SB),NOSPLIT|NOFRAME,$0-0
	CALL runtime·shadowTrampolineGo&lt;ABIInternal&gt;(SB)
	MOVD R0, R30
	RET</code></pre><pre><code>func shadowTrampolineGo() (retpc uintptr) {
	gp := getg()
	retpc = gp.shadowStack.pcs[0]
	gp.shadowStack.pcs = gp.shadowStack.pcs[1:]
	*(*uintptr)(unsafe.Pointer(getcallersp())) = abi.FuncPCABIInternal(shadowTrampolineASM)
	return
}</code></pre><p>Last but not least, I had to teach Go&#39;s lookup table unwinder how to navigate the injected trampoline functions. Without that change, <code>panic()</code>, <code>copystack()</code> and the cpu/memory profiler would break due to the unwinding getting stuck.</p><pre><code>func (u *unwinder) resolveInternal(innermost, isSyscall bool) {
    // ...
	if f.funcID == abi.FuncID_shadowTrampolineASM || f.funcID == abi.FuncID_shadowTrampolineGo {
		frame.pc = gp.shadowStack.pcs[0]
		frame.fn = findfunc(frame.pc)
		f = frame.fn
	}
    // ...</code></pre><p>It took quite a bit of hacking to get the details right, but as far as I can tell, the implementation seems to be working.</p><p>This allowed me to do some benchmarking. The first benchmark shown below is a best-case scenario of capturing stack traces in a loop at a fixed stack depth. As you can see, the <code>ShadowFPCallers</code> approach is <strong>8x faster</strong> than the <code>FPCallers</code> implementation which is already really fast 🚀.</p><figure><img src="https://blog.felixge.de/content/images/2024/05/2024-05-28-Untitled-spreadsheet---Google-Sheets-at-00.38.21@2x.png" alt="" loading="lazy" width="2000" height="889" srcset="https://blog.felixge.de/content/images/size/w600/2024/05/2024-05-28-Untitled-spreadsheet---Google-Sheets-at-00.38.21@2x.png 600w, https://blog.felixge.de/content/images/size/w1000/2024/05/2024-05-28-Untitled-spreadsheet---Google-Sheets-at-00.38.21@2x.png 1000w, https://blog.felixge.de/content/images/size/w1600/2024/05/2024-05-28-Untitled-spreadsheet---Google-Sheets-at-00.38.21@2x.png 1600w, https://blog.felixge.de/content/images/2024/05/2024-05-28-Untitled-spreadsheet---Google-Sheets-at-00.38.21@2x.png 2000w" sizes="(min-width: 720px) 720px"/><figcaption><b><strong>Best-case:</strong></b><span> Regular FPCaller unwinding vs ShadowFPCallers</span></figcaption></figure><p>But as suspected, performance is mixed when it comes to a worst-case benchmark where the stack depth is increased up to a limit and then decreased back down while taking a stack trace upon entering a certain depth level as well as when leaving it. Here it seems like the shadow stack approach is only competitive for stacks that are a little deeper than 32 frames. At lower stack depths, the approach is <strong>up to 4x slower</strong> 🐌.</p><figure><img src="https://blog.felixge.de/content/images/2024/05/2024-05-28-Untitled-spreadsheet---Google-Sheets-at-00.38.35@2x.png" alt="" loading="lazy" width="2000" height="878" srcset="https://blog.felixge.de/content/images/size/w600/2024/05/2024-05-28-Untitled-spreadsheet---Google-Sheets-at-00.38.35@2x.png 600w, https://blog.felixge.de/content/images/size/w1000/2024/05/2024-05-28-Untitled-spreadsheet---Google-Sheets-at-00.38.35@2x.png 1000w, https://blog.felixge.de/content/images/size/w1600/2024/05/2024-05-28-Untitled-spreadsheet---Google-Sheets-at-00.38.35@2x.png 1600w, https://blog.felixge.de/content/images/2024/05/2024-05-28-Untitled-spreadsheet---Google-Sheets-at-00.38.35@2x.png 2000w" sizes="(min-width: 720px) 720px"/><figcaption><b><strong>Worst-case:</strong></b><span> Regular FPCaller unwinding vs ShadowFPCallers</span></figcaption></figure><p>I can think of a few ways to mitigate the worst-case scenario. For example, the shadow stack could be disabled for stack depths below 32 frames. Or perhaps we could keep some statistics about the stack depths and use some more advanced heuristics. The implementation itself could probably also be further optimized. But, since this was just a small side project, I didn&#39;t have time to explore this further.</p><h2 id="conclusion">Conclusion</h2><p>Software shadow stacks are a potentially viable technique for accelerating stack trace capturing. I have only measured the approach on top of frame pointer unwinding in Go, but I would imagine DWARF unwinding to also become very competitive with this acceleration. And while it wasn&#39;t easy to get right, the approach requires relatively little additional code.</p><p>However, the approach also comes with a lot of downsides, in particular:</p><ol><li>Worst-case performance can be problematic at lower stack depths. (But it&#39;s not clear how often this will be encountered in the wild).</li><li>Upcoming hardware security features will likely break this approach.</li><li>External unwinders (such as linux perf) will produce broken stack traces when encountering the manipulated return addresses.</li><li>Programs using similar bespoke control-flow techniques might break when running them with shadow stacks.</li><li>Great care needs to be taken to avoid breaking unwinding for panics, exceptions and similar situations.</li><li>Shadow stacks require 8 bytes of additional memory per stack frame. This should usually be fine, but some programs might not want to make such a tradeoff.</li></ol><p>Considering that frame pointer unwinding is less than a few percent of overhead for Go&#39;s execution tracer, which is the most demanding use case we have, my conclusion is that the technique is interesting, but not warranted at this point.</p><p>My personal hope is that hardware shadow stacks will become widely available and accessible from user space. This is probably still many years away, but once this future arrives, we should be able to get rid of DWARF unwinding and perhaps also frame pointers and enjoy blazing fast stack trace capturing across the board.</p><h2 id="online-discussions">Online Discussions</h2><ul><li><a href="https://www.reddit.com/r/golang/comments/1d2h33i/blazingly_fast_shadow_stacks_for_go/?ref=blog.felixge.de" rel="noreferrer">Reddit</a></li><li><a href="https://news.ycombinator.com/item?id=40509535&amp;ref=blog.felixge.de" rel="noreferrer">Hacker News</a></li></ul>
    </div></div>
  </body>
</html>
