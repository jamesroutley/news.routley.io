<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://healeycodes.com/compiling-a-forth">Original</a>
    <h1>Compiling a Forth</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>I was curious how Forth worked so I built a bytecode compiler and a VM for a Forth-like language, as well as some visualizations to show how it all works.</p><p>You don&#39;t need to know anything about Forth to follow along, aside from the fact it&#39;s a stack-oriented language.</p><p>Here&#39;s a small program that prints the number three.</p><pre><div><div><p><span>3</span><span> .</span></p></div></div></pre><p>The number (<code>3</code>) is pushed to the data stack, and then the dot (<code>.</code>) pops it from the data stack and prints it.</p><p>We&#39;ll need more Forth features than this to build interesting programs.</p><p>Forth has two built-in stacks. The data stack (sometimes just called &#34;the stack&#34;) and the return stack. When a word is called in Forth (words are like functions) the address of the next instruction is pushed to the return stack. When the word finishes executing, the return stack is popped into the instruction pointer.</p><pre><div><div><p><span>\ (1) word declaration</span><span></span></p><p><span>:</span><span> </span><span>PRINT10</span><span></span></p><p><span>  </span><span>\ (3) the word body is executed</span><span></span></p><p><span>  </span><span>10</span><span> .</span></p><p><span>  </span><span>\ (4) &#34;;&#34; compiles an exit â€“ at runtime it pops the return stack</span><span></span></p><p><span>  </span><span>\     into the instruction pointer.</span><span></span></p><p><span></span><span>;</span><span></span></p><p><span></span><span>\   (2) instruction pointer lands on a word,</span><span></span></p><p><span></span><span>\       the next address is pushed to the return stack,</span><span></span></p><p><span></span><span>\       and the instruction pointer is set to the word address</span><span></span></p><p><span>PRINT10</span></p><p><span></span><span>\   (5) next address is executed</span></p></div></div></pre><p>As well as words, my compiler also supports <code>DO</code>/<code>LOOP</code>s. These use the return stack too. When <code>DO</code> executes, it pops the limit and the iterator from the data stack and stores them in the return stack. This allows the inner loop to freely operate on the data stack. When <code>LOOP</code> executes, it pops the limit and iterator from the return stack, adds one to the iterator and compares it to the limit (and exits or loops again).</p><p>There are also variables, which can be declared with <code>VARIABLE X</code>, loaded with <code>X @</code>, and stored with <code>1 X !</code>.</p><p>Putting these features together, here&#39;s how you can build <code>10</code> by adding <code>1</code> repeatedly.</p><pre><div><div><p><span>VARIABLE</span><span> </span><span>A</span><span></span></p><p><span>:</span><span> </span><span>RUN</span><span></span></p><p><span>  </span><span>0</span><span> </span><span>A</span><span> !          </span><span>\ initialize A</span><span></span></p><p><span>  </span><span>10</span><span> </span><span>0</span><span> </span><span>DO</span><span>        </span><span>\ push limit and iterator for DO</span><span></span></p><p><span>                 </span><span>\ DO places these on the return stack</span><span></span></p><p><span>    </span><span>A</span><span> @ </span><span>1</span><span> + </span><span>A</span><span> !  </span><span>\ A = A + 1</span><span></span></p><p><span>  </span><span>LOOP</span><span>           </span><span>\ increment i and exits when i == limit</span><span></span></p><p><span>  </span><span>A</span><span> @ .          </span><span>\ prints 10</span><span></span></p><p><span></span><span>;</span><span></span></p><p><span></span><span>RUN</span></p></div></div></pre><p>This set of features is enough for us to calculate numbers from the Fibonacci series, which is the example program I&#39;ll be using throughout the rest of this post.</p><h2 id="tokenizing">Tokenizing</h2><p>Tokenization translates raw text into meaningful symbols.</p><p>To turn source code into tokens, we scan through the code, skipping over whitespace and appending tokens to a list. Syntax that&#39;s a single character is turned straight into a token but multi-character syntax needs to be grouped together. For example, entire comments are discarded, and while they are being discarded, we need to track that we&#39;re &#34;within&#34; a comment.</p><p>Identifiers, like keywords like <code>DO</code> or <code>LOOP</code>, or custom variables like <code>MYLONGVAR</code>, become single tokens.</p><p>First, a visualization of what&#39;s happening:</p><p>And here&#39;s a trimmed version of my tokenizer:</p><pre><div><div><p><span>function</span><span> </span><span>tokenize</span><span>(</span><span>source</span><span>:</span><span> </span><span>string</span><span>)</span><span>:</span><span> </span><span>Token</span><span>[</span><span>]</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>const</span><span> tokens</span><span>:</span><span> </span><span>Token</span><span>[</span><span>]</span><span> </span><span>=</span><span> </span><span>[</span><span>]</span><span>;</span><span></span></p><p><span>    </span><span>let</span><span> index </span><span>=</span><span> </span><span>0</span><span>;</span><span></span></p><p><span>    </span><span>while</span><span> </span><span>(</span><span>index </span><span>&lt;</span><span> source</span><span>.</span><span>length</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>        </span><span>// Consume and discard everything on a line after &#39;\&#39;</span><span></span></p><p><span>        </span><span>if</span><span> </span><span>(</span><span>source</span><span>[</span><span>index</span><span>]</span><span> </span><span>===</span><span> </span><span>&#34;\\&#34;</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>            </span><span>const</span><span> commentStart </span><span>=</span><span> index</span><span>;</span><span></span></p><p><span>            </span><span>while</span><span> </span><span>(</span><span>index </span><span>&lt;</span><span> source</span><span>.</span><span>length</span><span> </span><span>&amp;&amp;</span><span> source</span><span>[</span><span>index</span><span>]</span><span> </span><span>!==</span><span> </span><span>&#34;\n&#34;</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>                index</span><span>++</span><span>;</span><span></span></p><p><span>            </span><span>}</span><span></span></p><p><span>            index</span><span>++</span><span>;</span><span></span></p><p><span>            </span><span>continue</span><span>;</span><span></span></p><p><span>        </span><span>}</span><span></span></p><p><span>        </span><span>// Skip over whitespace</span><span></span></p><p><span>        </span><span>if</span><span> </span><span>(</span><span>isWhitespace</span><span>(</span><span>source</span><span>[</span><span>index</span><span>]</span><span>)</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>            index</span><span>++</span><span>;</span><span></span></p><p><span>            </span><span>continue</span><span>;</span><span></span></p><p><span>        </span><span>}</span><span></span></p><p><span>        </span><span>if</span><span> </span><span>(</span><span>source</span><span>[</span><span>index</span><span>]</span><span> </span><span>===</span><span> </span><span>&#34;@&#34;</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>            tokens</span><span>.</span><span>push</span><span>(</span><span>{</span><span> type</span><span>:</span><span> </span><span>&#34;load&#34;</span><span> </span><span>}</span><span>)</span><span>;</span><span></span></p><p><span>            index</span><span>++</span><span>;</span><span></span></p><p><span>            </span><span>continue</span><span>;</span><span></span></p><p><span>        </span><span>}</span><span></span></p><p><span>        </span><span>// Handle identifiers</span><span></span></p><p><span>        </span><span>if</span><span> </span><span>(</span><span>isLetter</span><span>(</span><span>source</span><span>[</span><span>index</span><span>]</span><span>)</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>            </span><span>const</span><span> start </span><span>=</span><span> index</span><span>;</span><span></span></p><p><span>            </span><span>let</span><span> value </span><span>=</span><span> </span><span>&#34;&#34;</span><span>;</span><span></span></p><p><span>            </span><span>while</span><span> </span><span>(</span><span>isLetter</span><span>(</span><span>source</span><span>[</span><span>index</span><span>]</span><span>)</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>                value </span><span>+=</span><span> source</span><span>[</span><span>index</span><span>]</span><span>;</span><span></span></p><p><span>                index</span><span>++</span><span>;</span><span></span></p><p><span>            </span><span>}</span><span></span></p><p><span>            </span><span>// Special-case the keywords</span><span></span></p><p><span>            </span><span>if</span><span> </span><span>(</span><span>value </span><span>===</span><span> </span><span>&#34;DO&#34;</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>                tokens</span><span>.</span><span>push</span><span>(</span><span>{</span><span> type</span><span>:</span><span> </span><span>&#34;do&#34;</span><span> </span><span>}</span><span>)</span><span>;</span><span></span></p><p><span>                </span><span>continue</span><span>;</span><span></span></p><p><span>            </span><span>}</span><span></span></p><p><span>            </span><span>if</span><span> </span><span>(</span><span>value </span><span>===</span><span> </span><span>&#34;LOOP&#34;</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>                tokens</span><span>.</span><span>push</span><span>(</span><span>{</span><span> type</span><span>:</span><span> </span><span>&#34;loop&#34;</span><span> </span><span>}</span><span>)</span><span>;</span><span></span></p><p><span>                </span><span>continue</span><span>;</span><span></span></p><p><span>            </span><span>}</span><span></span></p><p><span>            tokens</span><span>.</span><span>push</span><span>(</span><span>{</span><span> type</span><span>:</span><span> </span><span>&#34;identifier&#34;</span><span>,</span><span> value </span><span>}</span><span>)</span><span>;</span><span></span></p><p><span>            </span><span>continue</span><span>;</span><span></span></p><p><span>        </span><span>}</span><span></span></p><p><span>        </span><span>// .. trimmed other tokens, see source</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>    </span><span>return</span><span> tokens</span><span>;</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>With our list of tokens, we&#39;re ready to start generating bytecode for the VM.</p><h2 id="generating-bytecode">Generating Bytecode</h2><p>Usually, in a compiler, the step after tokenization is <em>parsing</em> where an abstract syntax tree is built. However, the feature set of my Forth is so small, that I decided to generate bytecode directly from the list of tokens.</p><p><em>After</em> bytecode generation, my VM needs two things:</p><ul><li>A list of operations for the VM&#39;s instruction pointer to navigate</li><li>The number of variables that the program refers to</li></ul><p>The latter tells the VM how many variables to allocate (a zero-initialized array). Variables in source (e.g., <code>A</code>, <code>B</code>) become integer indices into this array.</p><p>This means that my bytecode generation step needs to keep track of variables that have been seen before so that I can output the correct memory address (i.e. an index into the variable table).</p><p>I&#39;ll show the full list of bytecode operations and then a few of the steps for handling specific tokens.</p><pre><div><div><p><span>type</span><span> </span><span>Op</span><span> </span><span>=</span><span> </span><span>{</span><span></span></p><p><span>    op</span><span>:</span><span> </span><span>&#34;lit&#34;</span><span>,</span><span>     </span><span>// Push value or address to DS</span><span></span></p><p><span>    value</span><span>:</span><span> </span><span>number</span><span>;</span><span></span></p><p><span></span><span>}</span><span> </span><span>|</span><span> </span><span>{</span><span></span></p><p><span>    op</span><span>:</span><span> </span><span>&#34;load&#34;</span><span>,</span><span>    </span><span>// Pop address from DS, push value at address</span><span></span></p><p><span></span><span>}</span><span> </span><span>|</span><span> </span><span>{</span><span></span></p><p><span>    op</span><span>:</span><span> </span><span>&#34;store&#34;</span><span>,</span><span>   </span><span>// Pop address from DS, pop value from DS, store value at address</span><span></span></p><p><span></span><span>}</span><span> </span><span>|</span><span> </span><span>{</span><span></span></p><p><span>    op</span><span>:</span><span> </span><span>&#34;dup2&#34;</span><span>,</span><span>    </span><span>// Duplicate top two values on DS [a, b] -&gt; [a, b, a, b]</span><span></span></p><p><span></span><span>}</span><span> </span><span>|</span><span> </span><span>{</span><span></span></p><p><span>    op</span><span>:</span><span> </span><span>&#34;add&#34;</span><span>,</span><span>     </span><span>// Pop top two values from DS, push sum to DS</span><span></span></p><p><span></span><span>}</span><span> </span><span>|</span><span> </span><span>{</span><span></span></p><p><span>    op</span><span>:</span><span> </span><span>&#34;eq&#34;</span><span>,</span><span>      </span><span>// Pop top two values from DS, push 1 if equal, 0 if not</span><span></span></p><p><span></span><span>}</span><span> </span><span>|</span><span> </span><span>{</span><span></span></p><p><span>    op</span><span>:</span><span> </span><span>&#34;jz&#34;</span><span>,</span><span>      </span><span>// Pop value from DS, if zero, jump to address</span><span></span></p><p><span>    address</span><span>:</span><span> </span><span>number</span><span>;</span><span></span></p><p><span></span><span>}</span><span> </span><span>|</span><span> </span><span>{</span><span></span></p><p><span>    op</span><span>:</span><span> </span><span>&#34;jmp&#34;</span><span>,</span><span>     </span><span>// Jump to address</span><span></span></p><p><span>    address</span><span>:</span><span> </span><span>number</span><span>;</span><span></span></p><p><span></span><span>}</span><span> </span><span>|</span><span> </span><span>{</span><span></span></p><p><span>    op</span><span>:</span><span> </span><span>&#34;call&#34;</span><span>,</span><span>    </span><span>// Push IP to RS, jump to address</span><span></span></p><p><span>    address</span><span>:</span><span> </span><span>number</span><span>;</span><span></span></p><p><span></span><span>}</span><span> </span><span>|</span><span> </span><span>{</span><span></span></p><p><span>    op</span><span>:</span><span> </span><span>&#34;ret&#34;</span><span>,</span><span>     </span><span>// Pop IP from RS, jump to IP</span><span></span></p><p><span></span><span>}</span><span> </span><span>|</span><span> </span><span>{</span><span></span></p><p><span>    op</span><span>:</span><span> </span><span>&#34;rs_push&#34;</span><span>,</span><span> </span><span>// Pop from DS, push to RS</span><span></span></p><p><span></span><span>}</span><span> </span><span>|</span><span> </span><span>{</span><span></span></p><p><span>    op</span><span>:</span><span> </span><span>&#34;rs_pop&#34;</span><span>,</span><span>  </span><span>// Pop from RS, push to DS</span><span></span></p><p><span></span><span>}</span><span> </span><span>|</span><span> </span><span>{</span><span></span></p><p><span>    op</span><span>:</span><span> </span><span>&#34;drop&#34;</span><span>,</span><span>    </span><span>// Discard top value from DS</span><span></span></p><p><span></span><span>}</span><span> </span><span>|</span><span> </span><span>{</span><span></span></p><p><span>    op</span><span>:</span><span> </span><span>&#34;print&#34;</span><span>,</span><span>   </span><span>// Pop value from DS, print it</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>The bytecode generation step scans through the list of tokens and, as it processes them, it appends to a list of bytecode and increments the variable count to set up the correct references.</p><p>Identifier tokens are either variable references, or words (function calls).</p><pre><div><div><p><span>let</span><span> index </span><span>=</span><span> </span><span>0</span><span>;</span><span></span></p><p><span></span><span>while</span><span> </span><span>(</span><span>index </span><span>&lt;</span><span> tokens</span><span>.</span><span>length</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>const</span><span> token </span><span>=</span><span> tokens</span><span>[</span><span>index</span><span>]</span><span>;</span><span></span></p><p><span>    </span><span>if</span><span> </span><span>(</span><span>token</span><span>.</span><span>type</span><span> </span><span>===</span><span> </span><span>&#34;identifier&#34;</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>        </span><span>if</span><span> </span><span>(</span><span>token</span><span>.</span><span>value</span><span> </span><span>===</span><span> </span><span>&#34;VARIABLE&#34;</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>            </span><span>const</span><span> nextToken </span><span>=</span><span> tokens</span><span>[</span><span>index </span><span>+</span><span> </span><span>1</span><span>]</span><span>;</span><span></span></p><p><span>            </span><span>// Store a binding of variable name to memory address</span><span></span></p><p><span>            variableTable</span><span>[</span><span>nextToken</span><span>.</span><span>value</span><span>]</span><span> </span><span>=</span><span> </span><span>Object</span><span>.</span><span>keys</span><span>(</span><span>variableTable</span><span>)</span><span>.</span><span>length</span><span>;</span><span></span></p><p><span>            index </span><span>+=</span><span> </span><span>2</span><span>;</span><span></span></p><p><span>            </span><span>continue</span><span>;</span><span></span></p><p><span>        </span><span>}</span><span></span></p><p><span>        </span><span>// If the variable has been declared as a word like `: FIB10`</span><span></span></p><p><span>        </span><span>// then we have previously stored the bytecode offset which we</span><span></span></p><p><span>        </span><span>// will set the instruction pointer to at runtime</span><span></span></p><p><span>        </span><span>if</span><span> </span><span>(</span><span>wordTable</span><span>[</span><span>token</span><span>.</span><span>value</span><span>]</span><span> </span><span>!==</span><span> </span><span>undefined</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>            bytecode</span><span>.</span><span>push</span><span>(</span><span>{</span><span> op</span><span>:</span><span> </span><span>&#34;call&#34;</span><span>,</span><span> address</span><span>:</span><span> wordTable</span><span>[</span><span>token</span><span>.</span><span>value</span><span>]</span><span> </span><span>}</span><span>)</span><span>;</span><span></span></p><p><span>            index</span><span>++</span><span>;</span><span></span></p><p><span>            </span><span>continue</span><span>;</span><span></span></p><p><span>        </span><span>}</span><span></span></p><p><span>        </span><span>// If it&#39;s not a variable declaration, or a word, then we</span><span></span></p><p><span>        </span><span>// look up the memory address</span><span></span></p><p><span>        bytecode</span><span>.</span><span>push</span><span>(</span><span>{</span><span> op</span><span>:</span><span> </span><span>&#34;lit&#34;</span><span>,</span><span> value</span><span>:</span><span> variableTable</span><span>[</span><span>token</span><span>.</span><span>value</span><span>]</span><span> </span><span>}</span><span>)</span><span>;</span><span></span></p><p><span>        index</span><span>++</span><span>;</span><span></span></p><p><span>        </span><span>continue</span><span>;</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>    </span><span>// ..</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>Setting up the <code>DO</code>/<code>LOOP</code> bytecode generation was the trickiest part of this project. It&#39;s a minefield of possible off-by-one errors. It&#39;s also not easy to read and understand but I&#39;ve chosen to put it here anyway because even just glancing over it should help you understand how the loop variables (limit, iterator) and instruction pointer jumps are combined to execute loops in Forth.</p><pre><div><div><p><span>  </span><span>// ..</span><span></span></p><p><span>  </span><span>if</span><span> </span><span>(</span><span>token</span><span>.</span><span>type</span><span> </span><span>===</span><span> </span><span>&#34;do&#34;</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>      index</span><span>++</span><span>;</span><span></span></p><p><span>      </span><span>// Expect: DS has [limit, start] (start is top)</span><span></span></p><p><span>      </span><span>// Move both to RS: start then limit (RS top becomes limit)</span><span></span></p><p><span>      bytecode</span><span>.</span><span>push</span><span>(</span><span>{</span><span> op</span><span>:</span><span> </span><span>&#34;rs_push&#34;</span><span> </span><span>}</span><span>)</span><span> </span><span>// start -&gt; RS</span><span></span></p><p><span>      bytecode</span><span>.</span><span>push</span><span>(</span><span>{</span><span> op</span><span>:</span><span> </span><span>&#34;rs_push&#34;</span><span> </span><span>}</span><span>)</span><span> </span><span>// limit -&gt; RS</span><span></span></p><p><span>      </span><span>// Mark first instruction of loop body</span><span></span></p><p><span>      loopStart</span><span>.</span><span>push</span><span>(</span><span>bytecode</span><span>.</span><span>length</span><span>)</span><span>;</span><span></span></p><p><span>      </span><span>continue</span><span>;</span><span></span></p><p><span>  </span><span>}</span><span></span></p><p><span>  </span><span>if</span><span> </span><span>(</span><span>token</span><span>.</span><span>type</span><span> </span><span>===</span><span> </span><span>&#34;loop&#34;</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>      </span><span>// Pop limit and i from RS (RS top is limit)</span><span></span></p><p><span>      bytecode</span><span>.</span><span>push</span><span>(</span><span>{</span><span> op</span><span>:</span><span> </span><span>&#34;rs_pop&#34;</span><span> </span><span>}</span><span>)</span><span> </span><span>// limit -&gt; DS</span><span></span></p><p><span>      bytecode</span><span>.</span><span>push</span><span>(</span><span>{</span><span> op</span><span>:</span><span> </span><span>&#34;rs_pop&#34;</span><span> </span><span>}</span><span>)</span><span> </span><span>// i -&gt; DS</span><span></span></p><p><span>      </span><span>// Increment i</span><span></span></p><p><span>      bytecode</span><span>.</span><span>push</span><span>(</span><span>{</span><span> op</span><span>:</span><span> </span><span>&#34;lit&#34;</span><span>,</span><span> value</span><span>:</span><span> </span><span>1</span><span> </span><span>}</span><span>)</span><span></span></p><p><span>      bytecode</span><span>.</span><span>push</span><span>(</span><span>{</span><span> op</span><span>:</span><span> </span><span>&#34;add&#34;</span><span> </span><span>}</span><span>)</span><span> </span><span>// i on DS</span><span></span></p><p><span>      </span><span>// Duplicate i and limit for compare and possible restore</span><span></span></p><p><span>      bytecode</span><span>.</span><span>push</span><span>(</span><span>{</span><span> op</span><span>:</span><span> </span><span>&#34;dup2&#34;</span><span> </span><span>}</span><span>)</span><span></span></p><p><span>      bytecode</span><span>.</span><span>push</span><span>(</span><span>{</span><span> op</span><span>:</span><span> </span><span>&#34;eq&#34;</span><span> </span><span>}</span><span>)</span><span> </span><span>// eq flag on DS</span><span></span></p><p><span>      </span><span>const</span><span> loopStartAddress </span><span>=</span><span> loopStart</span><span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span><span> </span><span>// first instr of loop body</span><span></span></p><p><span>      </span><span>// Branch: continue when not equal (eq==0), exit when equal</span><span></span></p><p><span>      </span><span>const</span><span> continueAddress </span><span>=</span><span> bytecode</span><span>.</span><span>length</span><span> </span><span>+</span><span> </span><span>4</span><span>;</span><span> </span><span>// skip equal-path (2 drops + jmp)</span><span></span></p><p><span>      bytecode</span><span>.</span><span>push</span><span>(</span><span>{</span><span> op</span><span>:</span><span> </span><span>&#34;jz&#34;</span><span>,</span><span> address</span><span>:</span><span> continueAddress </span><span>}</span><span>)</span><span></span></p><p><span>      </span><span>// Equal path (fallthrough): cleanup and exit</span><span></span></p><p><span>      bytecode</span><span>.</span><span>push</span><span>(</span><span>{</span><span> op</span><span>:</span><span> </span><span>&#34;drop&#34;</span><span> </span><span>}</span><span>)</span><span> </span><span>// drop i</span><span></span></p><p><span>      bytecode</span><span>.</span><span>push</span><span>(</span><span>{</span><span> op</span><span>:</span><span> </span><span>&#34;drop&#34;</span><span> </span><span>}</span><span>)</span><span> </span><span>// drop limit</span><span></span></p><p><span>      </span><span>const</span><span> afterBlockAddress </span><span>=</span><span> bytecode</span><span>.</span><span>length</span><span> </span><span>+</span><span> </span><span>1</span><span> </span><span>/* jmp */</span><span> </span><span>+</span><span> </span><span>3</span><span> </span><span>/* continue block */</span><span>;</span><span></span></p><p><span>      bytecode</span><span>.</span><span>push</span><span>(</span><span>{</span><span> op</span><span>:</span><span> </span><span>&#34;jmp&#34;</span><span>,</span><span> address</span><span>:</span><span> afterBlockAddress </span><span>}</span><span>)</span><span></span></p><p><span>      </span><span>// Continue path:</span><span></span></p><p><span>      </span><span>// address == continueAddress</span><span></span></p><p><span>      bytecode</span><span>.</span><span>push</span><span>(</span><span>{</span><span> op</span><span>:</span><span> </span><span>&#34;rs_push&#34;</span><span> </span><span>}</span><span>)</span><span> </span><span>// i -&gt; RS (top)</span><span></span></p><p><span>      bytecode</span><span>.</span><span>push</span><span>(</span><span>{</span><span> op</span><span>:</span><span> </span><span>&#34;rs_push&#34;</span><span> </span><span>}</span><span>)</span><span> </span><span>// limit -&gt; RS</span><span></span></p><p><span>      bytecode</span><span>.</span><span>push</span><span>(</span><span>{</span><span> op</span><span>:</span><span> </span><span>&#34;jmp&#34;</span><span>,</span><span> address</span><span>:</span><span> loopStartAddress </span><span>}</span><span>)</span><span></span></p><p><span>      index</span><span>++</span><span>;</span><span></span></p><p><span>      </span><span>continue</span><span>;</span><span></span></p><p><span>  </span><span>}</span><span></span></p><p><span>  </span><span>// ..</span></p></div></div></pre><p>The rest of the token branches are more straightforward. Tokens like dot, store, load, and print all map directly to bytecode operations.</p><p>The colon token branch sets the bytecode offset for the word name which allows identifiers to become word calls as we saw above.</p><p>Now we&#39;ve earned a visualization break.</p><h2 id="vm">VM</h2><p>Writing the VM felt a little bit like dessert. Manually stepping through the bytecode as I worked on the generation logic gave me fairly good confidence that I was heading in the right direction, I only came across one or two off-by-one bugs when putting the VM together. Essentially, I had designed it ahead-of-time.</p><p>The VM scans through the bytecode operations using the instruction pointer (which starts at <code>0</code>). The instruction pointer can jump around as it encounters <code>jmp</code> (jump to offset) or <code>jz</code> (conditional jump).</p><p>It manages the data stack, return stack, and the variable table (i.e. memory addresses).</p><p>Here&#39;s a trimmed version of the VM:</p><pre><div><div><p><span>function</span><span> </span><span>vm</span><span>(</span><span>program</span><span>:</span><span> </span><span>Program</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>const</span><span> dataStack</span><span>:</span><span> </span><span>number</span><span>[</span><span>]</span><span> </span><span>=</span><span> </span><span>[</span><span>]</span><span>;</span><span></span></p><p><span>    </span><span>const</span><span> returnStack</span><span>:</span><span> </span><span>number</span><span>[</span><span>]</span><span> </span><span>=</span><span> </span><span>[</span><span>]</span><span>;</span><span></span></p><p><span>    </span><span>const</span><span> variableTable</span><span>:</span><span> </span><span>number</span><span>[</span><span>]</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>Array</span><span>(</span><span>program</span><span>.</span><span>variableCount</span><span>)</span><span>.</span><span>fill</span><span>(</span><span>0</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>let</span><span> ip </span><span>=</span><span> </span><span>0</span><span>;</span><span></span></p><p><span>    </span><span>while</span><span> </span><span>(</span><span>ip </span><span>&lt;</span><span> program</span><span>.</span><span>bytecode</span><span>.</span><span>length</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>        </span><span>const</span><span> cur </span><span>=</span><span> program</span><span>.</span><span>bytecode</span><span>[</span><span>ip</span><span>]</span><span>;</span><span></span></p><p><span>        </span><span>if</span><span> </span><span>(</span><span>cur</span><span>.</span><span>op</span><span> </span><span>===</span><span> </span><span>&#34;lit&#34;</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>            dataStack</span><span>.</span><span>push</span><span>(</span><span>cur</span><span>.</span><span>value</span><span>)</span><span>;</span><span> </span><span>// Literal or memory address</span><span></span></p><p><span>            ip</span><span>++</span><span>;</span><span></span></p><p><span>            </span><span>continue</span><span>;</span><span></span></p><p><span>        </span><span>}</span><span> </span><span>else</span><span> </span><span>if</span><span> </span><span>(</span><span>cur</span><span>.</span><span>op</span><span> </span><span>===</span><span> </span><span>&#34;store&#34;</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>            </span><span>const</span><span> address </span><span>=</span><span> </span><span>dsPop</span><span>(</span><span>)</span><span>;</span><span></span></p><p><span>            </span><span>const</span><span> value </span><span>=</span><span> </span><span>dsPop</span><span>(</span><span>)</span><span>;</span><span></span></p><p><span>            variableTable</span><span>[</span><span>address</span><span>]</span><span> </span><span>=</span><span> value</span><span>;</span><span></span></p><p><span>            ip</span><span>++</span><span>;</span><span></span></p><p><span>            </span><span>continue</span><span>;</span><span></span></p><p><span>        </span><span>}</span><span> </span><span>else</span><span> </span><span>if</span><span> </span><span>(</span><span>cur</span><span>.</span><span>op</span><span> </span><span>===</span><span> </span><span>&#34;jmp&#34;</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>            ip </span><span>=</span><span> cur</span><span>.</span><span>address</span><span>;</span><span></span></p><p><span>            </span><span>continue</span><span>;</span><span></span></p><p><span>        </span><span>}</span><span> </span><span>else</span><span> </span><span>if</span><span> </span><span>(</span><span>cur</span><span>.</span><span>op</span><span> </span><span>===</span><span> </span><span>&#34;jz&#34;</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>            </span><span>if</span><span> </span><span>(</span><span>dsPop</span><span>(</span><span>)</span><span> </span><span>===</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>                ip </span><span>=</span><span> cur</span><span>.</span><span>address</span><span>;</span><span></span></p><p><span>                </span><span>continue</span><span>;</span><span></span></p><p><span>            </span><span>}</span><span></span></p><p><span>            ip</span><span>++</span><span>;</span><span></span></p><p><span>            </span><span>continue</span><span>;</span><span></span></p><p><span>        </span><span>}</span><span> </span><span>else</span><span> </span><span>if</span><span> </span><span>(</span><span>cur</span><span>.</span><span>op</span><span> </span><span>===</span><span> </span><span>&#34;call&#34;</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>            ip</span><span>++</span><span></span></p><p><span>            returnStack</span><span>.</span><span>push</span><span>(</span><span>ip</span><span>)</span><span>;</span><span></span></p><p><span>            ip </span><span>=</span><span> cur</span><span>.</span><span>address</span><span>;</span><span></span></p><p><span>            </span><span>continue</span><span>;</span><span></span></p><p><span>        </span><span>}</span><span> </span><span>else</span><span> </span><span>if</span><span> </span><span>(</span><span>cur</span><span>.</span><span>op</span><span> </span><span>===</span><span> </span><span>&#34;ret&#34;</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>            ip </span><span>=</span><span> </span><span>rsPop</span><span>(</span><span>)</span><span>;</span><span></span></p><p><span>            </span><span>continue</span><span>;</span><span></span></p><p><span>        </span><span>}</span><span></span></p><p><span>        </span><span>// .. trimmed other ops, see source</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>The code for my compiler and VM are <a href="https://github.com/healeycodes/healeycodes.com/blob/main/components/visuals/forth/components.tsx">embedded in this website</a>. I&#39;ve been iterating on it by just running the TypeScript file:</p><pre><div><div><p><span>bun ./components/visuals/forth/components.tsx</span></p><p><span></span><span>55</span><span>  </span><span># 10th Fibonacci number</span></p></div></div></pre><p>The visuals are React components with sleeps. In order to display the progress of the different steps (tokenizing, bytecode generation, VM), I first got each working and then added a callback which takes the current data and then sleeps.</p><p>So the VM function is actually async and accepts this callback:</p><pre><div><div><p><span>// VM</span><span></span></p><p><span></span><span>async</span><span> </span><span>function</span><span> </span><span>vm</span><span>(</span><span>program</span><span>:</span><span> </span><span>Program</span><span>,</span><span> </span><span>callback</span><span>:</span><span></span></p><p><span>  </span><span>(</span><span></span></p><p><span>    highlight</span><span>:</span><span> </span><span>{</span><span> ip</span><span>:</span><span> </span><span>number</span><span> </span><span>}</span><span>,</span><span></span></p><p><span>    dataStack</span><span>:</span><span> </span><span>number</span><span>[</span><span>]</span><span>,</span><span></span></p><p><span>    returnStack</span><span>:</span><span> </span><span>number</span><span>[</span><span>]</span><span>,</span><span></span></p><p><span>    variableTable</span><span>:</span><span> </span><span>number</span><span>[</span><span>]</span><span></span></p><p><span>  </span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>Promise</span><span>&lt;</span><span>void</span><span>&gt;</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>// .. inside VM loop</span><span></span></p><p><span>  </span><span>await</span><span> </span><span>callback</span><span>(</span><span>{</span><span> ip </span><span>}</span><span>,</span><span> dataStack</span><span>,</span><span> returnStack</span><span>,</span><span> variableTable</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>// ..</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>And the component calls it and passes <code>setState</code> functions:</p><pre><div><div><p><span>// Component</span><span></span></p><p><span></span><span>export</span><span> </span><span>function</span><span> </span><span>VM</span><span>(</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>// .. inside useEffect</span><span></span></p><p><span>    </span><span>await</span><span> </span><span>vm</span><span>(</span><span>program</span><span>,</span><span> </span><span>async</span><span> </span><span>(</span><span>highlight</span><span>,</span><span> newDataStack</span><span>,</span><span> newReturnStack</span><span>,</span><span> newVariableTable</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span></p><p><span>        </span><span>setHighlightIP</span><span>(</span><span>highlight</span><span>.</span><span>ip</span><span>)</span><span>;</span><span></span></p><p><span>        </span><span>setDataStack</span><span>(</span><span>[</span><span>...</span><span>newDataStack</span><span>]</span><span>)</span><span>;</span><span></span></p><p><span>        </span><span>setReturnStack</span><span>(</span><span>[</span><span>...</span><span>newReturnStack</span><span>]</span><span>)</span><span>;</span><span></span></p><p><span>        </span><span>setVariableTable</span><span>(</span><span>[</span><span>...</span><span>newVariableTable</span><span>]</span><span>)</span><span>;</span><span></span></p><p><span>        </span><span>await</span><span> </span><span>new</span><span> </span><span>Promise</span><span>(</span><span>resolve </span><span>=&gt;</span><span> </span><span>setTimeout</span><span>(</span><span>resolve</span><span>,</span><span> </span><span>500</span><span>)</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>}</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>// ..</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>For the Forth code snippets in this post, I had to write <a href="https://github.com/healeycodes/healeycodes.com/blob/main/lib/prism-forth.js">a Prism plugin</a> to get syntax highlighting working. Now that I&#39;ve learned how to do this, I&#39;ll be using this method for syntax highlighting for the more esoteric (or, original) programming languages I write about!</p><h2 id="discrepancies">Discrepancies</h2><p>I described my compiler/VM as <em>Forth-like</em> because it&#39;s a little bit different from how Forth works.</p><p>My implementation compiles to bytecode ahead-of-time. Forth is traditionally interactive. Words are interpreted and executed as they are entered, and only colon definitions are compiled. Forth uses threaded code where words contain lists of addresses pointing to other words instead of a different bytecode offset.</p><p>Real Forth uses a dynamic dictionary that can be altered at runtime with new variables or word definitions. As I mentioned earlier, my word bodies are compiled with jump-over logic in the main execution stream. Also, my variables compile to <code>lit address</code> operations but real Forth variables return their address when executed directly.</p><p>These are just a few of the differences but I feel like my Forth-like compiler and VM capture enough of the spirit of Forth!</p></div></div></div>
  </body>
</html>
