<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fprasx.github.io/articles/type-system-arithmetic/">Original</a>
    <h1>Doing First Grade Math in Rust&#39;s Type System</h1>
    
    <div id="readability-page-1" class="page"><div>
            
<div>
  
  <p><span>2024-01-04</span></p><p>Arithmetic is hard. Luckily, we can fix that using Rust&#39;s Expressive Type
System™️.</p>
<h3 id="math">Math</h3>
<p>Let&#39;s start with Church Encodings. There&#39;s
this idea in functional programming that functions are good, and type theorists
took it pretty far. So far that they sometimes define numbers as functions that
look like this:</p>
<pre><code><span>0 = |f, x| x                             # f applied 0 times
</span><span>1 = |f, x| f(x)                          # f applied 1 times
</span><span>2 = |f, x| f(f(x))                       # f applied 2 times
</span><span>3 = |f, x| f(f(f(x)))                    # f applied 3 times
</span><span>...                                      # f applied . times
</span><span>n = |f, x| f( .. n - 2 more f&#39;s .. f(x)) # f applied n times
</span></code></pre>
<p>The nth natural number is <em>literally</em> defined as a function that takes a
value and function, and applies that function n times.</p>
<p>There&#39;s another concept from math called the Peano Axioms. It&#39;s also an
Extremely Useful way to characterize the natural numbers that is basically as
follows (omitting some details):</p>
<pre><code><span>0. 0 is a natural number.
</span><span>1. The successor, S(n), of a natural number is a natural number.
</span></code></pre>
<p>This inductively defines the natural numbers as:</p>
<pre><code><span>0 = 0
</span><span>1 = S(0)
</span><span>2 = S(1) = S(S(0))
</span><span>3.= S(2) = S(S(S(0)))
</span><span>...
</span><span>n = S( .. n - 2 more S&#39;s .. S(0))
</span></code></pre>
<p>where <code>S</code> is called the Successor Function. It doesn&#39;t really matter what it
actually is, since we&#39;re going for a more . . . abstract view of things.</p>
<p>Notice any similarity to the Church Encodings?</p>
<p>The main idea is that we can represent a number as a <em>repeated function
application</em>.</p>
<h3 id="enter-rust">Enter Rust</h3>
<p>So how do we replicate this in Rust? And how do we make it performant? We
could just do it using regular lambdas, but that would probably be slow since
closures are boxed, etc, etc.</p>
<p>The ultimate strategy is to play God and compute our numbers at compile time!
After all, that&#39;s the Rust way. But how do we call functions at compile time?
Well, we can borrow another idea from type theory, and notice that a generic
struct is sort of like a function. Consider:
<code>struct Wrapper&lt;T&gt;(PhantomData&lt;T&gt;)</code>. Instantiating <code>T</code> is sort of like computing
a function on types, starting with a type <code>T</code> and ending with a type
<code>Wrapper&lt;T&gt;</code>. And one could conceivably construct a type
<code>Wrapper&lt;Wrapper&lt;Wrapper&lt;T&gt;&gt;&gt;</code> . . . </p>
<p>I bet this is starting to get repetitive. Let&#39;s define the following types:</p>
<pre data-lang="rust"><code data-lang="rust"><span>struct </span><span>Zero;
</span><span>struct </span><span>Succ&lt;T&gt;(PhantomData&lt;T&gt;);
</span></code></pre>
<p>Yeah I know <code>Succ</code> sounds like a funny word, but it&#39;s really just convention for
<code>Successor</code>. We can now define some natural numbers:</p>
<pre data-lang="rust"><code data-lang="rust"><span>type </span><span>One = Succ&lt;Zero&gt;;
</span><span>type </span><span>Two = Succ&lt;Succ&lt;Zero&gt;&gt;;
</span><span>type </span><span>Three = Succ&lt;Succ&lt;Succ&lt;Zero&gt;&gt;&gt;;
</span><span>...
</span></code></pre>
<p>This is going to get annoying. Let&#39;s write a little macro to help us out:</p>
<pre data-lang="rust"><code data-lang="rust"><span>#[</span><span>macro_export</span><span>]
</span><span>macro_rules! </span><span>encode {
</span><span>    () =&gt; {
</span><span>        Zero
</span><span>    };
</span><span>    (</span><span>$_a</span><span>:</span><span>tt </span><span>$(</span><span>$tail</span><span>:</span><span>tt</span><span>)*) =&gt; {
</span><span>        Succ&lt;encode</span><span>!</span><span>($(</span><span>$tail</span><span>)*)&gt;
</span><span>    };
</span><span>}
</span></code></pre>
<p>Basically, we feed this bad boy tokens, and it&#39;ll gobble them up one at a time,
each time adding a new layer of <code>Succ</code> to the type it&#39;s constructing. Here&#39;s
an example expansion:</p>
<pre data-lang="rust"><code data-lang="rust"><span>  encode!(* ***)
</span><span>            ^ these tokens correspond to </span><span>$tail
</span><span>= Succ&lt;encode</span><span>!</span><span>(* **)&gt;
</span><span>= Succ&lt;Succ&lt;encode</span><span>!</span><span>(* *)&gt;&gt;
</span><span>= Succ&lt;Succ&lt;Succ&lt;encode</span><span>!</span><span>(*)&gt;&gt;&gt;
</span><span>= Succ&lt;Succ&lt;Succ&lt;Succ&lt;encode</span><span>!</span><span>()&gt;&gt;&gt;&gt;
</span><span>                      ^ input is empty, so encode!() expands to Zero
</span><span>= Succ&lt;Succ&lt;Succ&lt;Succ&lt;Zero&gt;&gt;&gt;&gt;
</span></code></pre>
<p>Now we can construct decently large numbers using <code>encode!(***** ... *****)</code>,
although the compiler will overflow its stack at about 3200 tokens due to 
recursion.</p>
<h3 id="evaluation">Evaluation</h3>
<p>Now, remember, we&#39;re trying to do arithmetic with these numbers, so we need
to be able to extract them out of this encoded form at some point. Hopefully,
we can do all our computation at compile time (so infinitely fast?) and then
extract them as constants into our final binary. This means we need a function
from types to . . . values? Hmm. Well, if you look at them hard enough, traits
are kind of like functions from types to values.</p>
<pre data-lang="rust"><code data-lang="rust"><span>trait </span><span>SpecialNumber {
</span><span>    </span><span>const </span><span>MAGIC</span><span>: </span><span>usize</span><span>;
</span><span>}
</span><span>
</span><span>impl </span><span>SpecialNumber </span><span>for </span><span>Foo {
</span><span>    </span><span>const </span><span>MAGIC</span><span>: </span><span>usize </span><span>= </span><span>13</span><span>;
</span><span>}
</span><span>
</span><span>impl </span><span>SpecialNumber </span><span>for </span><span>Bar {
</span><span>    </span><span>const </span><span>MAGIC</span><span>: </span><span>usize </span><span>= </span><span>29</span><span>;
</span><span>}
</span></code></pre>
<p>In a sense, we&#39;ve mapped the type <code>Foo</code> to <code>13</code>, and the type <code>Bar</code> to 29. Let&#39;s
keep going with this idea and define the <code>Value</code> trait:</p>
<pre data-lang="rust"><code data-lang="rust"><span>trait </span><span>Value {
</span><span>    </span><span>const </span><span>VALUE</span><span>: </span><span>usize</span><span>;
</span><span>}
</span><span>
</span><span>impl </span><span>Value </span><span>for </span><span>Zero {
</span><span>    </span><span>const </span><span>VALUE</span><span>: </span><span>usize </span><span>= </span><span>0</span><span>;
</span><span>}
</span><span>
</span><span>impl</span><span>&lt;T&gt; Value </span><span>for </span><span>Succ&lt;T&gt; </span><span>where</span><span> T: Value {
</span><span>    </span><span>const </span><span>VALUE</span><span>: </span><span>usize </span><span>= </span><span>1 </span><span>+ T::</span><span>VALUE</span><span>;
</span><span>}
</span></code></pre>
<p>We can now recursively &#34;evaluate&#34; a type - or get how many time&#39;s <code>Succ</code> has
been applied, since the second case strips off one <code>Succ</code> layer each iteration.</p>
<h3 id="addition-and-subtraction">Addition and Subtraction</h3>
<p>Alright, we&#39;re on to something a little juicier. The main idea is still the
same though. We&#39;ll use this weird type recursion to construct new types. Instead
of using traits to map types to values, we can also use them to map types to
other types, using associated constants. Let&#39;s define the trait <code>Add</code> like so:</p>
<pre data-lang="rust"><code data-lang="rust"><span>trait </span><span>Add {
</span><span>    </span><span>type </span><span>Sum;
</span><span>}
</span></code></pre>
<p>We can now define some base cases for our recursion:</p>
<pre data-lang="rust"><code data-lang="rust"><span>impl </span><span>Add </span><span>for</span><span> (Zero, Zero) { </span><span>// 0 + 0 = 0
</span><span>    </span><span>type </span><span>Sum = Zero;
</span><span>}
</span><span>
</span><span>impl</span><span>&lt;T&gt; Add </span><span>for</span><span> (Succ&lt;T&gt;, Zero) { </span><span>// x + 0 = x
</span><span>    </span><span>type </span><span>Sum = Succ&lt;T&gt;;
</span><span>}
</span><span>
</span><span>impl</span><span>&lt;T&gt; Add </span><span>for</span><span> (Zero, Succ&lt;T&gt;) { </span><span>// 0 + x = x
</span><span>    </span><span>type </span><span>Sum = Succ&lt;T&gt;;
</span><span>}
</span></code></pre>
<p>And now for our recursive rule:</p>
<pre data-lang="rust"><code data-lang="rust"><span>impl</span><span>&lt;T, U&gt; Add </span><span>for</span><span> (Succ&lt;T&gt;, Succ&lt;U&gt;)
</span><span>where
</span><span>    (T, Succ&lt;Succ&lt;U&gt;&gt;): Add,
</span><span>{
</span><span>    </span><span>type </span><span>Sum = &lt;(T, Succ&lt;Succ&lt;U&gt;&gt;) as Add&gt;::Sum;
</span><span>}
</span></code></pre>
<p>Let&#39;s break it down. We firstly are taking two nonzero numbers - since both
type parameters are wrapped in <code>Succ</code>, and could also be <code>Succ&lt;..&gt;</code> themselves.
The idea of this rule is to take one layer of <code>Succ</code> off of the first type
parameter, and stick it on the other. Then eventually, the second type parameter
will have all the <code>Succ</code>&#39;s - precisely the total number of <code>Succ</code>&#39;s that they
both started with, which means it represents the sum of the two starting
numbers. Let&#39;s do a small example (I won&#39;t do this for all of them):</p>
<pre><code><span>  Add&lt;Succ&lt;Succ&lt;Zero&gt;&gt;, Succ&lt;Succ&lt;Zero&gt;&gt;&gt;
</span><span>= Add&lt;Succ&lt;Zero&gt;, Succ&lt;Succ&lt;Succ&lt;Zero&gt;&gt;&gt;&gt; // move one Succ to the right
</span><span>= Add&lt;Zero, Succ&lt;Succ&lt;Succ&lt;Succ&lt;Zero&gt;&gt;&gt;&gt;&gt; // again
</span><span>= Succ&lt;Succ&lt;Succ&lt;Succ&lt;Zero&gt;&gt;&gt;&gt;&gt;           // base case :)
</span></code></pre>
<p>Finally, there are also some trait bounds - we&#39;re telling rustc we&#39;ll only
call this trait (weird idea right?) on types that can be added.</p>
<p>Subtraction is pretty similar (division is where it really goes crazy). We
define our base cases:</p>
<pre data-lang="rust"><code data-lang="rust"><span>trait </span><span>Sub {
</span><span>    </span><span>type </span><span>Diff;
</span><span>}
</span><span>
</span><span>impl </span><span>Sub </span><span>for</span><span> (Zero, Zero) { </span><span>// 0 - 0 = 0
</span><span>    </span><span>type </span><span>Diff = Zero;
</span><span>}
</span><span>
</span><span>impl</span><span>&lt;T&gt; Sub </span><span>for</span><span> (Succ&lt;T&gt;, Zero) { </span><span>// x - 0 = x
</span><span>    </span><span>type </span><span>Diff = Succ&lt;T&gt;;
</span><span>}
</span><span>
</span><span>impl</span><span>&lt;T&gt; Sub </span><span>for</span><span> (Zero, Succ&lt;T&gt;) { </span><span>// 0 - x = 0, we&#39;ll saturate
</span><span>    </span><span>type </span><span>Diff = Zero;
</span><span>}
</span></code></pre>
<p>The only interesting thing here is that we define subtraction as <em>saturating</em>.
This will help with implementing division. If you leave out that rule 
completely, the compiler will actually prevent you from having underflows!</p>
<p>Anyways, here&#39;s our recursive rule:</p>
<pre data-lang="rust"><code data-lang="rust"><span>impl</span><span>&lt;T, U&gt; Sub </span><span>for</span><span> (Succ&lt;T&gt;, Succ&lt;U&gt;)
</span><span>where
</span><span>    (T, U): Sub,
</span><span>{
</span><span>    </span><span>type </span><span>Diff = &lt;(T, U) as Sub&gt;::Diff;
</span><span>}
</span></code></pre>
<p>We basically just peel one layer of <code>Succ</code> off of each type parameter until one
of them is zero. The remaining one is then our difference. You can think about
it pictorially as this:</p>
<pre><code><span>5 [***] **
</span><span>-
</span><span>3 [***]
</span><span>=
</span><span>2 [   ] **
</span></code></pre>
<p>where we got rid of the shared terms in the brackets one at a time.</p>

<p>Ok, this task is a bit more complex, but we can use our building blocks from
before. As always, we define a trait-function and some base cases:</p>
<pre data-lang="rust"><code data-lang="rust"><span>trait </span><span>Mul {
</span><span>    </span><span>type </span><span>Product;
</span><span>}
</span><span>
</span><span>impl</span><span>&lt;T&gt; Mul </span><span>for</span><span> (T, Zero) { </span><span>// x * 0 = 0
</span><span>    </span><span>type </span><span>Product = Zero;
</span><span>}
</span><span>
</span><span>impl</span><span>&lt;T&gt; Mul </span><span>for</span><span> (Zero, Succ&lt;T&gt;) { </span><span>// 0 * x = 0
</span><span>    </span><span>type </span><span>Product = Zero;
</span><span>}
</span></code></pre>
<p>We now have to be a little more careful with what we implement <code>Mul</code> for. If
we were to do the second implementation on <code>(Zero, T)</code>, then we would have
two implementations covering <code>(Zero, Zero)</code>. Thus, we implement it on
<code>(Zero, Succ&lt;T&gt;)</code>, since <code>Succ&lt;T&gt;</code> is never equal to <code>Zero</code>. And now for the
recursion, we have this baby monstrosity:</p>
<pre data-lang="rust"><code data-lang="rust"><span>impl</span><span>&lt;T, U&gt; Mul </span><span>for</span><span> (Succ&lt;T&gt;, Succ&lt;U&gt;)
</span><span>where
</span><span>    (T, Succ&lt;U&gt;): Mul,
</span><span>    (Succ&lt;U&gt;, &lt;(T, Succ&lt;U&gt;) as Mul&gt;::Product): Add,
</span><span>{
</span><span>    </span><span>type </span><span>Product = &lt;(
</span><span>        Succ&lt;U&gt;,                       // y
</span><span>        &lt;(T, Succ&lt;U&gt;) as Mul&gt;::Product // (x - 1) * y
</span><span>    ) as Add&gt;::Sum;
</span><span>}
</span></code></pre>
<p>Here, we&#39;re using the fact that <code>x * y = y + (x - 1) * y</code>. We recursively
calculate the second term, and then add it to the first factor!. Remember that
if <code>Succ&lt;T&gt;</code> represents <code>T + 1</code>, then <code>T</code> represents <code>Succ&lt;T&gt; - 1</code>.</p>
<p>And finally . . .</p>
<h3 id="division">Division</h3>
<p>I won&#39;t lie, this one really is a monstrosity. We&#39;ll first need to define
<code>GreaterThanEq</code> to check if <code>x &gt;= y</code>, since some divisions aren&#39;t clean, e.g.
<code>7 / 3</code>. I&#39;ll explain more later. We&#39;ll do this similarly to how we did
<code>Subtraction</code>:</p>
<pre data-lang="rust"><code data-lang="rust"><span>trait </span><span>GreaterThanEq {
</span><span>    </span><span>type </span><span>Greater;
</span><span>}
</span><span>
</span><span>impl </span><span>GreaterThanEq </span><span>for</span><span> (Zero, Zero) { </span><span>// 0 &gt;= 0
</span><span>    </span><span>type </span><span>Greater = Succ&lt;Zero&gt;;
</span><span>}
</span><span>
</span><span>impl</span><span>&lt;T&gt; GreaterThanEq </span><span>for</span><span> (Zero, Succ&lt;T&gt;) { </span><span>// 0 &gt;!= { 1 .. }
</span><span>    </span><span>type </span><span>Greater = Zero;
</span><span>}
</span><span>
</span><span>impl</span><span>&lt;T&gt; GreaterThanEq </span><span>for</span><span> (Succ&lt;T&gt;, Zero) { </span><span>// { 1 .. } &gt;= 0
</span><span>    </span><span>type </span><span>Greater = Succ&lt;Zero&gt;;
</span><span>}
</span><span>
</span><span>impl</span><span>&lt;T, U&gt; GreaterThanEq </span><span>for</span><span> (Succ&lt;T&gt;, Succ&lt;U&gt;)
</span><span>where
</span><span>    (T, U): GreaterThanEq, </span><span>// x &gt;= y -&gt; x - 1 &gt;= y - 1
</span><span>{
</span><span>    </span><span>type </span><span>Greater = &lt;(T, U) as GreaterThanEq&gt;::Greater;
</span><span>}
</span></code></pre>
<p>With that out of the way, let&#39;s handle division. We&#39;ll first start with 
perfect quotients, like <code>6 / 3</code>. Here&#39;s our boilerplate:</p>
<pre data-lang="rust"><code data-lang="rust"><span>trait </span><span>Div {
</span><span>    </span><span>type </span><span>Quotient;
</span><span>}
</span><span>
</span><span>impl</span><span>&lt;T&gt; Div </span><span>for</span><span> (Zero, T) { </span><span>// 0 / x = 0
</span><span>    </span><span>type </span><span>Quotient = Zero;
</span><span>}
</span><span>
</span><span>impl</span><span>&lt;T&gt; Div </span><span>for</span><span> (Succ&lt;T&gt;, Succ&lt;Zero&gt;) { </span><span>// x / 1 = x
</span><span>    </span><span>type </span><span>Quotient = Succ&lt;T&gt;;
</span><span>}
</span></code></pre>
<p>Once again, we have to be careful with our type arguments. Instead of
doing the second implementation on <code>(T, Succ&lt;Zero&gt;)</code>, we implement it on
<code>(Succ&lt;T&gt;, Succ&lt;Zero&gt;)</code> to avoid overlapping with the first implementation on
<code>(Zero, Succ&lt;Zero&gt;)</code>. We can now make use of the identity
<code>x / y = 1 + (x - y) / y</code>. Intuitively, this means we just take one copy of
<code>y</code> out of <code>x</code>, and then count the rest recursively. In code, it looks like:</p>
<pre data-lang="rust"><code data-lang="rust"><span>type </span><span>RawQuotient&lt;T, U&gt; = &lt;(
</span><span>    Succ&lt;Zero&gt;, // 1
</span><span>    &lt;(
</span><span>        &lt;(Succ&lt;T&gt;, Succ&lt;Succ&lt;U&gt;&gt;) as Sub&gt;::Diff,
</span><span>        Succ&lt;Succ&lt;U&gt;&gt; 
</span><span>    ) as Div&gt;::Quotient, // (x - y) / y
</span><span>) as Add&gt;::Sum;
</span></code></pre>
<p>The only problem is that this expression is incorrect if <code>x &lt; y</code>, and will
return 1. The subtraction saturates to 0, so we get <code>1 + 0 / y = 1 + 0 = 1</code>.</p>
<p>We just need to combine this <code>RawQuotient</code> with the fact that
<code>x / y</code> is  0 if <code>x &lt; y</code>. Since we have this number as a boolean, we can do a
trick for replacing a conditional jump with a multiplication (or a cmov in
assembly). Observe the following table:</p>
<pre><code><span>   Case       Boolean of Gte       RawQuotient       Desired
</span><span>+--------+  +----------------+   +-------------+   +---------+ 
</span><span>| x &gt;= y |: |       1        | x |   nonzero   | = | nonzero |
</span><span>+--------+  +----------------+   +-------------+   +---------+ 
</span><span>| x &lt; y  |: |       0        | x |     ???     | = |    0    |
</span><span>+--------+  +----------------+   +-------------+   +---------+ 
</span></code></pre>
<p>We can just multiply our <code>RawQuotient</code> by whether <code>x &gt;= y</code>! If <code>x &gt;= y</code>, we&#39;ll
be left with our <code>RawQuotient</code>. If <code>x &lt; y</code>, we&#39;ll be multiplying by 0 and get
0 no matter what, as desired. This leads to the final form of division:</p>
<pre data-lang="rust"><code data-lang="rust"><span>impl</span><span>&lt;T, U&gt; Div </span><span>for</span><span> (Succ&lt;T&gt;, Succ&lt;Succ&lt;U&gt;&gt;)
</span><span>where
</span><span>    (T, Succ&lt;U&gt;): Sub,
</span><span>    (&lt;(T, Succ&lt;U&gt;) as Sub&gt;::Diff, Succ&lt;Succ&lt;U&gt;&gt;): Div,
</span><span>    (
</span><span>        Succ&lt;Zero&gt;,
</span><span>        &lt;(&lt;(T, Succ&lt;U&gt;) as Sub&gt;::Diff, Succ&lt;Succ&lt;U&gt;&gt;) as Div&gt;::Quotient,
</span><span>    ): Add,
</span><span>    (
</span><span>        &lt;(Succ&lt;T&gt;, Succ&lt;Succ&lt;U&gt;&gt;) as GreaterThanEq&gt;::Greater,
</span><span>        &lt;(
</span><span>            Succ&lt;Zero&gt;,
</span><span>            &lt;(&lt;(T, Succ&lt;U&gt;) as Sub&gt;::Diff, Succ&lt;Succ&lt;U&gt;&gt;) as Div&gt;::Quotient,
</span><span>        ) as Add&gt;::Sum,
</span><span>    ): Mul,
</span><span>    (Succ&lt;T&gt;, Succ&lt;Succ&lt;U&gt;&gt;): GreaterThanEq,
</span><span>{
</span><span>    </span><span>// Hi I&#39;m the important part
</span><span>    </span><span>type </span><span>Quotient = &lt;(
</span><span>        &lt;(Succ&lt;T&gt;, Succ&lt;Succ&lt;U&gt;&gt;) as GreaterThanEq&gt;::Greater,
</span><span>        RawQuotient&lt;T, U&gt;,
</span><span>    ) as Mul&gt;::Product;
</span><span>}
</span></code></pre>
<p>We have a bunch of trait bounds because we have a bunch more subexpressions we
need to make sure are evaluatable. At the end of the day though, all this
basically comes down to is only passing in chains of <code>Succ</code> with a <code>Zero</code> at the
bottom.</p>
<p>You also might notice that we&#39;re implementing the recursive case of <code>Div</code> on
<code>(Succ&lt;T&gt;, Succ&lt;Succ&lt;U&gt;&gt;)</code>. This means the denominator is greater than 1, so it
doesn&#39;t overlap with any other implementation.</p>
<p>In true Rust fashion, this implementation actually won&#39;t allow us to divide by
0, since we never implemented <code>Div</code> for <code>(*, Zero)</code>!</p>
<p>And somewhat anticlimactically . . . that&#39;s it! I don&#39;t know how to convey the
elation of little green test case dots passing, so you can run it yourself
by getting the code from 
<a href="https://github.com/fprasx/arts">Arithmetic in Rust&#39;s Type System</a>, or arts for
short.</p>

<p>I should note I&#39;m not the first person to do this - although I thought I
might have been when I first started haha. For prior art, see the
<a href="https://crates.io/crates/typenum">typenum</a> and
<a href="https://crates.io/crates/peano">peano</a> crates. <code>typenum</code> is much faster and is
what you would actually use in practice.</p>
<p>Once again, I highly recommend running the
<a href="https://crates.io/crates/peano">code</a> for yourself. It&#39;s a really cool feeling
seeing these abstract traits materialize into numbers on your terminal.
Feel free to drop a star as well!</p>
<p>That&#39;s it for me. Have a nice day :)</p>

</div>

        </div></div>
  </body>
</html>
