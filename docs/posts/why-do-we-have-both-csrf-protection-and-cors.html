<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://smagin.fyi/posts/cross-site-requests/">Original</a>
    <h1>Why do we have both CSRF protection and CORS?</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>Hello, Internet. I thought about cross-site requests and realised we have both CSRF protection and CORS and it doesn’t make sense from the first glance. It does generally, but I need a thousand words to make it so.</p>
<p><strong>CSRF</strong> stands for Cross-Site Request Forgery. It was rather popular in the earlier internet but now it’s almost a non-issue thanks to standard prevention mechanisms built into most of popular web frameworks. The forgery is to make user click on a form that will send a cross-site request. The protection is to check that the request didn’t come from a third-party site.</p>
<p><strong>CORS</strong> stands for Cross-Origin Resource Sharing. It’s a part of HTTP specification that describes how to permit certain cross-site requests. This includes preflight requests and response headers that state which origins are allowed to send requests.</p>
<p>So, by default, are cross-origin requests allowed and we need CSRF protection, or they are forbidden and we need CORS to allow them? The answer is both.</p>
<h3 id="the-default-behaviour">The default behaviour</h3>
<p>The default behaviour is defined by Same-origin policy, and is enforced by browsers. The policy states that, generally speaking, cross-site <strong>writes are allowed</strong>, and cross-site <strong>reads are not</strong>. You can send a POST request by submitting a form, you browser won’t let you read the response of it.</p>
<p>There is a newer part of this spec that sort of solves CSRF. In 2019, there was an initiative to change default cookies behaviour. Before that, cookies were always sent in cross-site requests. The default was changed to not send cookies in cross-site POST requests. To do that, a new <code>SameSite</code> attribute for the set-cookie header was introduced. The attribute value to make the old default is <code>None</code>, and the new default would be <code>Lax</code>.</p>
<p>In 2025, <a href="https://caniuse.com/mdn-http_headers_set-cookie_samesite_lax_default">96% browsers</a> support the <code>SameSite</code> attribute, and <a href="https://caniuse.com/same-site-cookie-attribute">75%</a> support the new default. Notably, Safari haven’t adopted the default, and UCBrowser doesn’t support any nice things.</p>
<p>Sidenote: I can’t understand how UCBrowser remains relatively popular among users, given that there are settings in js builders to build for N% of the users and next to nobody puts 99% there.</p>
<p>Sidenote 2: Origin is not the same as Site. Origin is a combination of a scheme, a hostname, and a port. Site is a combination of scheme and <em>effective top level domain</em> + 1. Subdomains and ports don’t matter for sites.</p>
<p><strong>Links:</strong> <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy">Same-origin policy</a> |
<a href="https://caniuse.com/?search=samesite">caniuse SameSite cookie attribute</a></p>
<h3 id="cors">CORS</h3>
<p>CORS is a way to override the same origin policy per origin.</p>
<p>The spec describes a certain browser-server interaction. Browser sends <em>preflight</em> requests of type <code>OPTIONS</code> before actual requests, server replies with rules for the origin. The rules are in a form of response headers. The rules may specify if the reply can be read, if headers can be sent and received, allowed HTTP methods. Header names start with <code>Access-Control</code>. Browser then follows the rules.</p>
<p>CORS applies for several types of the requests:</p>
<ul>
<li>js-initiated <code>fetch</code> and <code>XMLHttpRequest</code></li>
<li>web fonts</li>
<li>webgl textures</li>
<li>images/video frames drawn to a canvas using <code>drawImage</code></li>
<li>css shapes from images</li>
</ul>
<p>What is notoriously not in this list is form submissions, otherwise known as simple requests. This is part of the internet being backward-compatible:</p>
<blockquote>
<p>The motivation is that the <code>&lt;form&gt;</code> element from HTML 4.0 (which predates cross-site fetch() and XMLHttpRequest) can submit simple requests to any origin, so anyone writing a server must already be protecting against cross-site request forgery (CSRF). Under this assumption, the server doesn’t have to opt-in (by responding to a preflight request) to receive any request that looks like a form submission, since the threat of CSRF is no worse than that of form submission. However, the server still must opt-in using Access-Control-Allow-Origin to share the response with the script.</p></blockquote>
<p>From <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">the CORS page on MDN</a>.</p>
<p><strong>Question to readers:</strong> How is that in line with the <code>SameSite</code> initiative?</p>
<h3 id="csrf-protection">CSRF protection</h3>
<p>So, cross-site write requests are allowed, but responses won’t be shared. At the same time, as website developers, we mostly don’t want to allow that.</p>
<p>The standard protection is to include into a write request a user-specific token available only on read:</p>
<ul>
<li>for forms this token is put into a hidden input,</li>
<li>for js-initiated requests the token can be stored in a cookie or in a meta tag, and is put into params or request headers.</li>
</ul>
<p>JS-initiated requests are not allowed cross-site by default anyway, but they <em>are</em> allowed same-site. Adding a csrf token into js requests lets us do the check the same way for all the requests.</p>
<p>This way we still depend on browser in a way that it still has to prevent responses to be read cross-site by default, but a bit less than if we were also reading something like <code>Origin</code> request header instead of checking for the token.</p>
<p><strong>Question to readers:</strong> In some of the frameworks CSRF tokens are rotated. Why?</p>
<h3 id="browser-is-important">Browser is important</h3>
<p>I want to emphasise how important browsers are in this whole security scheme. All the client state for all the sites is stored in browser, and it decides which parts to expose and when. It’s browsers that enforce Same-origin policy, it’s browsers that don’t let read responses if it’s not allowed by server. It’s browsers that decide if they adopt the new <code>SameSite=Lax</code> default. It’s browsers that implement CORS and send safe preflight requests before actual PATCH or DELETE.</p>
<p>We really have to trust browsers that we use.</p>
<h3 id="conclusion">Conclusion</h3>
<figure>

    <p><img loading="lazy" alt="What I learned" src="https://smagin.fyi/posts/cross-site-requests/%20/pics/cross-site-requests.png"/>
    </p>

    
</figure>
<p>The internet will become more secure and maybe a bit less backward-compatible when the <code>SameSite=Lax</code> default will be adopted by 100% of the browsers. Until then, we will have to live with the situation where simple POST requests are special and allowed cross-site, while others fall into the CORS bucket.</p>
<p>Thanks Nikita Skazki for reviewing this post more times than I care to admit.</p>
<p><a href="https://news.ycombinator.com/item?id=43231411">This post on Hackernews</a></p>
<h3 id="sources">Sources</h3>
<ol>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy">Same-origin policy</a></li>
<li><a href="https://caniuse.com/?search=samesite">caniuse SameSite cookie attribute</a></li>
<li><a href="https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html">OWASP CSRF cheatsheet</a></li>
<li><a href="https://www.w3.org/wiki/CORS">CORS wiki with requirements</a></li>
<li><a href="https://www.w3.org/TR/2020/SPSD-cors-20200602/">CORS spec</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">CORS on MDN</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request">Preflight request</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin">Origin request header</a></li>
<li><a href="https://web.dev/articles/same-site-same-origin">Origin and Site</a></li>
</ol>

    
  </div></div>
  </body>
</html>
