<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://brashandplucky.com/2025/09/28/procedural-island-generation-vi.html">Original</a>
    <h1>Procedural Island Generation (VI)</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p><img src="https://brashandplucky.com/uploads/2025/procedural-island-generation-vi/chemaguerra-island-final-beauty.png" alt="Final rendered island with all systems"/></p>

<p>This is the final installment of our procedural island generation series. After building the mesh foundation (<a href="https://brashandplucky.com/2025/09/07/procedural-island-generation-i.html">Part I</a>), painting elevation hints (<a href="https://brashandplucky.com/2025/09/10/procedural-island-generation-ii.html">Part II</a>), adding mountain detail (<a href="https://brashandplucky.com/2025/09/13/procedural-island-generation-iii.html">Part III</a>), simulating hydrology (<a href="https://brashandplucky.com/2025/09/16/procedural-island-generation-iv.html">Part IV</a>), and colouring the terrain with our biome ramp (<a href="https://brashandplucky.com/2025/09/19/procedural-island-generation-v.html">Part V</a>), it is time to package the result. CartoKit finishes by baking the terrain into a compact mesh, visualising it through an egui viewer, and exporting artefacts for other tools.</p>

<p>The journey from mathematical representation to visual output ends with three components:</p>

<ol>
  <li><strong><code>Terrain::from_terrain</code></strong> – a baked mesh carrying elevation, moisture, biome, and river metadata.</li>
  <li><strong>The debug renderer &amp; viewer</strong> – CPU rasterisers that turn the data into diagnostic images.</li>
  <li><strong>Export helpers</strong> – GLB export, PNG captures, and GIF generation built on the same primitives.</li>
</ol>

<p>Let’s look at each piece.</p>

<h2 id="baked-terrain-output">Baked Terrain Output</h2>

<p><code>Terrain::from_terrain</code> (<code>src/terrain.rs:368</code>) distils the incremental <code>TerrainBuilder</code> state into a reusable asset. The bake step:</p>

<ul>
  <li>Keeps only faces whose centroids lie inside the unit square, trimming the guard ring used during generation.</li>
  <li>Copies vertex elevation and moisture into mesh attributes so downstream tools can query them directly.</li>
  <li>Tags every face with average elevation, a <code>TerrainType</code> (land vs. ocean), and the coarse <code>BiomeType</code> classification introduced in Part V.</li>
  <li>Marks edges as regular, coastline, or river and stores river-flow magnitudes when a <code>RiverSystem</code> is present.</li>
</ul>

<p>The baked mesh is still a <code>TopoMesh</code>, meaning we retain the halfedge connectivity that made the earlier stages convenient. When you call <code>Terrain::from_terrain(&amp;builder)</code>, you get a self-contained structure that is ready for export or further processing without touching the heavy generation code again.</p>

<h2 id="cpu-debug-renderer">CPU Debug Renderer</h2>

<p>All of CartoKit’s imagery is rendered on the CPU. The <code>cartokit::debug</code> module contains a suite of rasterisers—triangle fill, watertight line drawing, paint-map sampling, rainfall heatmaps—that output directly into <code>image::RgbaImage</code> buffers. The viewer’s <code>DisplayRenderer</code> (<code>examples/viewer/display_modes.rs</code>) wires those helpers together:</p>

<ul>
  <li>Mesh modes (<code>SeedPoints</code>, <code>Delaunay</code>, <code>Voronoi</code>, <code>Quads</code>, <code>FinalTriangulation</code>) call <code>draw_topokit_mesh</code> with optional vertex overlays.</li>
  <li>Scalar fields (<code>TriangleElevation</code>, <code>DistanceField</code>, <code>Rainfall</code>, <code>Humidity</code>, <code>RiverFlow</code>, <code>Biome</code>) delegate to <code>draw_triangles_opt</code>/<code>draw_regions_opt</code> with palette swaps.</li>
  <li>Noise visualisations reuse the same pipeline, just swapping in different <code>TriangleProperty</code> variants.</li>
</ul>

<p>Because everything renders to software images, the viewer behaves the same on every platform, and the exported screenshots and GIFs are bit-for-bit identical to what you see on screen.</p>

<h2 id="interactive-viewer">Interactive Viewer</h2>

<p>The <code>cartokit_viewer</code> example wraps those images in an egui/eframe interface:</p>

<ul>
  <li>The right-hand parameter panel exposes seeds, Bridson separation, rainfall, and river controls, regenerating the terrain whenever you tweak them.</li>
  <li>The “Paint Terrain” mode lets you brush elevation hints onto the 128×128 paint map; the next regeneration integrates those hints into the terrain.</li>
  <li>Display modes cover the full pipeline: seed classification, mesh structure, mountain distance fields, rainfall, humidity, river diagnostics, biome colours, and the final shaded map.</li>
  <li>Animation tools (<code>examples/viewer/animation.rs</code>) let you scrub parameters over time and queue frame exports.</li>
</ul>

<p>Each frame, the viewer renders the active mode into an <code>RgbaImage</code>, uploads it as an egui texture, and then recycles the same image for exports. There is no separate rendering path—what you export is exactly what you preview.</p>

<h2 id="export-helpers">Export Helpers</h2>

<p>Three helpers in <code>examples/viewer/export.rs</code> turn the baked data into files:</p>

<div><div><pre><code><span>// 1. Bake + GLB export via MeshKit</span>
<span>display</span><span>::</span><span>export_mesh</span><span>(</span><span>&amp;</span><span>terrain_builder</span><span>,</span> <span>seed</span><span>);</span>

<span>// 2. One PNG per display mode</span>
<span>display</span><span>::</span><span>export_all_images</span><span>(</span><span>seed</span><span>,</span> <span>&amp;</span><span>modes</span><span>,</span> <span>|</span><span>mode</span><span>|</span> <span>renderer</span><span>.render</span><span>(</span><span>mode</span><span>));</span>

<span>// 3. Thumbnail tiles for quick comparisons</span>
<span>display</span><span>::</span><span>export_all_images_tile</span><span>(</span><span>seed</span><span>,</span> <span>&amp;</span><span>modes</span><span>,</span> <span>|</span><span>mode</span><span>|</span> <span>renderer</span><span>.render</span><span>(</span><span>mode</span><span>));</span>
</code></pre></div></div>

<ul>
  <li><code>export_mesh</code> clones the baked <code>Terrain</code>, rescales coordinates for GLTF’s Y‑up convention, and calls <code>meshkit::io::save_mesh</code> to produce a <code>.glb</code> file that loads cleanly in Blender or other viewers.</li>
  <li><code>export_all_images</code> walks every display mode and drops the rendered PNGs into <code>exports/images_seed_&lt;seed&gt;/</code>.</li>
  <li><code>export_all_images_tile</code> cuts out the top-left 1/8×1/8 tile from each image—handy for diffing or documentation thumbnails.</li>
</ul>

<p>For animated parameter studies, <code>examples/viewer/gif_export.rs</code> converts a list of pre-rendered frames into a looping GIF, with options for downsampling, FPS, and output directory naming.</p>

<h2 id="performance-snapshot">Performance Snapshot</h2>

<p>Generation times were covered in the earlier posts (≈80 ms for the default 27 K-site map on a modern desktop). The finishing steps add little overhead:</p>

<table>
  <thead>
    <tr>
      <th>Stage</th>
      <th>Time (2048×2048 render)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>Terrain::from_terrain</code> bake</td>
      <td>~6 ms</td>
    </tr>
    <tr>
      <td>CPU render – biome view</td>
      <td>~8 ms</td>
    </tr>
    <tr>
      <td>GLB export (<code>meshkit::io::save_mesh</code>)</td>
      <td>~15 ms</td>
    </tr>
    <tr>
      <td>PNG capture per display mode</td>
      <td>5–10 ms</td>
    </tr>
    <tr>
      <td>GIF encoding (20 frames @ 1024²)</td>
      <td>~9 ms</td>
    </tr>
  </tbody>
</table>

<p>Numbers vary with map resolution and active mode (mesh overlays with AA lines take longer than simple heatmaps), but everything remains comfortably interactive.</p>

<h2 id="future-directions">Future Directions</h2>

<p>With a solid foundation in place, the obvious extensions are clear:</p>

<ul>
  <li><strong>GPU shading</strong> – real-time lighting, water reflections, and atmospheric effects on top of the baked mesh.</li>
  <li><strong>Mesh decimation</strong> – level-of-detail generation or streaming tiles for massive worlds.</li>
  <li><strong>Additional exporters</strong> – heightmaps, splatmaps, or direct integrations for Unity/Unreal/Godot.</li>
  <li><strong>Dynamic overlays</strong> – weather, vegetation instancing, or settlement placement driven by the existing attributes.</li>
</ul>

<p>These items all build on the baked <code>Terrain</code> structure and export scaffolding we now have.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Through six posts we moved from random seeds to a fully packaged island:</p>

<ol>
  <li>Poisson disk sampling and dual meshes establish the geometric scaffold.</li>
  <li>A paint map and layered noise sculpt elevation.</li>
  <li>Hydrology adds rivers and erosion cues.</li>
  <li>A simple elevation/moisture colormap paints believable biomes.</li>
  <li>The baked <code>Terrain</code>, debug renderer, and export helpers ship the result.</li>
</ol>

<p>The complete system generates a richly annotated island in under a tenth of a second and provides everything you need to inspect, tweak, and export it. The modular architecture welcomes experimentation—swap out any component and the rest of the pipeline keeps working.</p>

<p>Thanks for following along. I hope CartoKit inspires your own explorations into procedural worlds.</p>

<h2 id="valuable-resources">Valuable Resources</h2>

<ul>
  <li><a href="https://github.com/brash-and-plucky/meshkit">MeshKit</a> – Halfedge library used throughout the project</li>
  <li><a href="https://www.egui.rs/">EGUI</a> – Immediate-mode GUI powering the viewer</li>
  <li><a href="https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.pdf">glTF 2.0</a> – Asset format we export to</li>
  <li><a href="https://www.redblobgames.com/maps/mapgen2/">Red Blob Games: Polygonal Map Generation</a> – Foundational reading for the dual-mesh approach</li>
</ul>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
