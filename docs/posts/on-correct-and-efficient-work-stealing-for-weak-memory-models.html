<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wingolog.org/archives/2022/10/03/on-correct-and-efficient-work-stealing-for-weak-memory-models">Original</a>
    <h1>On “correct and efficient work-stealing for weak memory models”</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>Hello all, a quick post today.  Inspired by <a href="http://users.cecs.anu.edu.au/~steveb/pubs/papers/rust-ismm-2016.pdf">Rust as a Language for High Performance GC Implementation</a> by Yi Lin et al, a few months ago I had a look to see how the basic Rust concurrency facilities that they used were implemented.</p><p>One of the key components that Lin et al used was a Chase-Lev work-stealing double-ended queue (deque).  The 2005 article <a href="https://www.dre.vanderbilt.edu/~schmidt/PDF/work-stealing-dequeue.pdf">Dynamic Circular Work-Stealing Deque</a> by David Chase and Yossi Lev is a nice read defining this data structure.  It&#39;s used when you have a single producer of values, but multiple threads competing to claim those values.  This is useful when implementing per-CPU schedulers or work queues; each CPU pushes on any items that it has to its own deque, and pops them also, but when it runs out of work, it goes to see if it can steal work from other CPUs.</p><p>The 2013 paper <a href="https://fzn.fr/readings/ppopp13.pdf">Correct and Efficient Work-Stealing for Weak Memory Models</a> by Nhat Min Lê et al updates the Chase-Lev paper by relaxing the concurrency primitives from the original big-hammer sequential-consistency operations used in the Chase-Lev paper to an appropriate mix of C11 relaxed, acquire/release, and sequentially-consistent operations.  The paper therefore has a C11 translation of the original algorithm, and a proof of correctness.  It&#39;s quite pleasant.  Here&#39;s the <a href="https://docs.rs/crossbeam/0.3.2/src/crossbeam/sync/chase_lev.rs.html#11-605">a version in Rust&#39;s <tt>crossbeam</tt> crate</a>, and <a href="https://github.com/wingo/whippet-gc/blob/main/parallel-tracer.h#L14">here&#39;s the same thing in C</a>.</p><p>I had been using this updated C11 Chase-Lev deque implementation for a while with no complaints in a parallel garbage collector.  Each worker thread would keep a local unsynchronized work queue, which when it grew too large would donate half of its work to a per-worker Chase-Lev deque.  Then if it ran out of work, it would go through all the workers, seeing if it could steal some work.</p><p>My use of the deque was thus limited to only the <a href="https://github.com/wingo/whippet-gc/blob/main/parallel-tracer.h#L158-L170"><tt>push</tt></a> and <a href="https://github.com/wingo/whippet-gc/blob/main/parallel-tracer.h#L213-L230"><tt>steal</tt></a> primitives, but not <a href="https://github.com/wingo/whippet-gc/blob/main/parallel-tracer.h#L187-L211"><tt>take</tt></a> (using the language of the Lê et al paper).  <tt>take</tt> is like <tt>steal</tt>, except that it takes values from the producer end of the deque, and it can&#39;t run concurrently with <tt>push</tt>.  In practice <tt>take</tt> only used by the the thread that also calls <tt>push</tt>.  Cool.</p><p>Well I thought, you know, before a worker thread goes to steal from some other thread, it might as well see if it can do a cheap <tt>take</tt> on its own deque to see if it could take back some work that it had previously offloaded there.  But here I ran into a bug.  A brief internet search didn&#39;t turn up anything, so here we are to mention it.</p><p>Specifically, there is a bug in the Lê et al paper that is not in the Chase-Lev paper.  The original paper is in Java, and the C11 version is in, well, C11.  The issue is.... integer overflow!  In brief, <tt>push</tt> will increment <tt>bottom</tt>, and <tt>steal</tt> increments <tt>top</tt>.  <tt>take</tt>, on the other hand, can decrement <tt>bottom</tt>.  It uses <tt>size_t</tt> to represent <tt>bottom</tt>.  I think you see where this is going; if you <tt>take</tt> on an empty deque in the initial state, you create a situation that looks just like a deque with <tt>(size_t)-1</tt> elements, causing garbage reads and all kinds of delightful behavior.</p><p>The funny thing is that I looked at the proof and I looked at the industrial applications of the deque and I thought well, I just have to transcribe the algorithm exactly and I&#39;ll be golden.  But it just goes to show that proving one property of an algorithm doesn&#39;t necessarily imply that the algorithm is correct.</p></div></div></div>
  </body>
</html>
