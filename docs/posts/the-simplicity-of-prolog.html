<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bitsandtheorems.com/the-simplicity-of-prolog/">Original</a>
    <h1>The Simplicity of Prolog</h1>
    
    <div id="readability-page-1" class="page"><article>
            <header>
                
                
                <a target="_blank" href="https://veryth.ink/blog/index.html">Back to homepage</a>
            </header>
            <p>
                Nowadays the most popular programming languages are Python, Javascript, Java, C++, C#, Kotlin and Ruby, and the average programmer is probably familiar with one or more of these languages. It&#39;s relatively easy to switch from one to another (barring any framework specific knowledge that may be needed), since they are all <a target="_blank" href="https://en.wikipedia.org/wiki/Imperative_programming">imperative</a> (and for the most part <a target="_blank" href="https://en.wikipedia.org/wiki/Object-oriented_programming">object-oriented</a>) languages, and are thus alike in their design.
            </p>
            <p>
                Imperative languages focus on <i>how</i> a problem is solved, using sequences of instructions to manipulate state. There are multiple reasons for their popularity. Firstly, they are considered easy to learn, since it&#39;s easy to visualize physical cells of memory containing values and getting updates through a set of instructions. Secondly, the computational model maps nicely to hardware, and so instructions from imperative languages can often easily be translated to machine code that can be optimized quite a lot. For the same reason, imperative languages were developed way before other programming paradigms, and so have historically speaking had a larger backing.
            </p>
            <p>
                In contrast, <a target="_blank" href="https://en.wikipedia.org/wiki/Declarative_programming">declarative</a> languages focus on describing <i>what</i> the problem or desired outcome is. An example of a declarative language you are probably familiar with is SQL. When specifying a SELECT-statement, you usually don&#39;t really care <i>how</i> the records are retrieved, only that they adhere to specified conditions. While SQL isn&#39;t normally used as a general purpose programming language I think it&#39;s quite illustrative for those otherwise unfamiliar with declarative languages (though apparently it <i>is</i> <a target="_blank" href="https://en.wikipedia.org/wiki/Turing_completeness">Turing complete</a>). There are entire paradigms of actual general purpose programming languages that are declarative. The main two of these are <a target="_blank" href="https://en.wikipedia.org/wiki/Functional_programming">functional programming</a> and <a target="_blank" href="https://en.wikipedia.org/wiki/Logic_programming">logic programming</a>.
            </p>
            <figure>
                <img src="https://imgs.xkcd.com/comics/formal_logic.png" title="Note that this implies you should NOT honk solely because I stopped for a pedestrian and you&#39;re behind me."/>
                <figcaption>Source:  <a target="_blank" target="_blank" href="https://xkcd.com/1033/">https://xkcd.com/1033/</a></figcaption>
            </figure>
            <p>
                A programmer writing code in a functional programming language does not write statements to update some state. In fact, there is no state <i>at all</i>. Rather, they apply, and compose functions to transform data. And so a program is nothing more than a chain of data transformations. Examples of concepts from functional languages that are now adopted into imperative languages are functions like <code><span>map</span></code>, <code><span>fold</span></code>, and <code><span>filter</span></code>. The most popular example of a functional programming language is <a target="_blank" href="https://www.haskell.org/">Haskell</a>.
            </p>
            <p>
                A programmer writing in a logic programming language does not write statements or functions. In a logic program, you only define relations between things, and then can ask a question to which the system responds with all possible answers to your question that are deducible from the relations. This has the advantage of sounding horribly vague, and incredibly tedious at the same time - but it really is not. The most popular example of a logic programming language is <a target="_blank" href="https://en.wikipedia.org/wiki/Prolog">Prolog</a>, at which we&#39;ll be taking a look in this article. Additionally, we&#39;ll compare the implementation of a simple application in Kotlin versus the same application in Prolog. In the coming articles, we&#39;ll use Prolog to tackle some more complicated problems.
            </p>
            <h2>A short introduction to logic programming</h2>
            <p>
                Prolog is a simple language: there are only a few language constructs, and so not a lot of moving parts to be mindful of. Well-written Prolog programs are often also simple, in the sense that they add little to no extra complexity to the problem being solved. At the same time, the language can be hard to learn, as it functions quite differently from languages people are usually already familiar with. 
            </p>
            <p>
                The only basic language constructs in Prolog are facts, rules, and queries. These are composed of logical combinations of predicates. Simply put: a fact is something that is inherently true in your program, a rule is a conditional relation &#34;if A is true, then B is true&#34;, and a query is anything we would like to have answered according to the facts and rules in our system. Prolog finds the answers to these queries through <i>unification</i>, which is a sort of fancy <a target="_blank" href="https://en.wikipedia.org/wiki/Pattern_matching">pattern matching</a>.
            </p>
            
            <p>
                Let&#39;s start with an example: <a target="_blank" href="https://en.wikipedia.org/wiki/Palindrome">palindromes</a>. A sequence, string or array is a palindrome if it remains unchanged if we reverse all its elements. We&#39;ll first define what list reversal means, and use it to define palindromes. For the helper predicate our goal will be to <i>relate</i> one list to another, such that they are each others reversal.
            </p>
            <code>
<span>reverse</span><span>(</span>[], []<span>)</span>.
<span>reverse</span><span>(</span>[<span>Element</span>|<span>Tail</span>], <span>Reversed</span><span>)</span> :-
  <span>reverse</span><span>(</span><span>Tail</span>, <span>ReversedTail</span><span>)</span>,
  <span>append</span><span>(</span><span>ReversedTail</span>, [<span>Element</span>], <span>Reversed</span><span>)</span>.


<span>palindrome</span><span>(</span><span>List</span><span>)</span> :- <span>reverse</span><span>(</span><span>List</span>, <span>List</span><span>)</span>.</code>
            <p>
                The snippet starts with a comment. There are only single line comments in Prolog, and they start with a percentage symbol.
            </p>
            <p>
                Next up is a <i>fact</i>. They are written as <code><span>Fact</span>.</code> - a single predicate followed by a dot. In this case, we simply state that the reverse of the empty list is the empty list.
            </p>
            <p>
                Next, we have a <i>rule</i>. They are written as <code><span>Head</span> :- <span>Body</span>.</code>, where the <code><span>Head</span></code> is derived if the <code><span>Body</span></code> is true.  The <code><span>Body</span></code> can consist of multiple comma-separated predicates, all of which must hold (so commas denote <a target="_blank" href="https://en.wikipedia.org/wiki/Logical_conjunction">conjunction/&#34;and&#34;</a> in the rule body) in order to derive <code><span>Head</span></code>. In this case, we are &#34;pattern matching&#34; on a non-empty list in the first argument (note that <code>[<span>X</span>|<span>Y</span>]</code> simply means, that we are considering a list where the first element is <code><span>X</span></code> and the remainder is <code><span>Y</span></code>). Hence, this rule states that the reversal of a list of which the first element is <code><span>Element</span></code> and the (possibly empty) remainder is <code><span>Tail</span></code>, is the list <code><span>Reversed</span></code> if <code><span>Reversed</span></code> is the list we get when we reverse the <code><span>Tail</span></code> and then add the <code><span>Element</span></code> to the end of it (<code><span>append</span><span>(</span><span>X</span>, <span>Y</span>, <span>Z</span><span>)</span></code> denotes that list <code><span>X</span></code> and <code><span>Y</span></code> together form list <code><span>Z</span></code>). Words startings with an uppercase letter or underscore are considered variables in Prolog. Variables can only be bound once.
            </p>
            <p>
                These two clauses complete the definition of <code><span>reverse</span></code>, which we can now use to define <code><span>palindrome</span></code>. The definition of <code><span>palindrome</span></code> consists of a single rule which states: <code><span>List</span></code> is considered a palindrome if its reversal is itself.
            </p>
            <p>
                Alright, so now what? Well, now we can ask our system questions (queries). A query starts with <code>:-</code> or <code>?-</code>, followed by the question. If there are any variables in our query, the response to our query will tell us for which value assignment(s) of those variables the given query holds. If there are no solutions at all, we will get <code><span>false</span></code>, or if the query is vacuously true regardless of variables, we will get <code><span>true</span></code>.
            </p>
            <p>
                Here are some example queries and corresponding results for <code><span>reverse</span></code>:
            </p>
            <code>
:- <span>reverse</span><span>(</span>[<span>1</span>, <span>2</span>, <span>3</span>], [<span>3</span>, <span>2</span>, <span>1</span>]<span>)</span>.
<span>true</span>.


:- <span>reverse</span><span>(</span>[<span>1</span>, <span>2</span>, <span>3</span>], []<span>)</span>.
<span>false</span>.


:- <span>reverse</span><span>(</span>[<span>1</span>, <span>2</span>, <span>3</span>], <span>X</span><span>)</span>.
<span>X</span> = [<span>3</span>, <span>2</span>, <span>1</span>].


:- <span>reverse</span><span>(</span>[<span>1</span>, <span>2</span>, <span>3</span>], [<span>X</span>, <span>_</span>, <span>_</span>]<span>)</span>.
<span>X</span> = <span>3</span>.


:- <span>reverse</span><span>(</span>[<span>A</span>, <span>B</span>, <span>C</span>], [<span>X</span>, <span>Y</span>, <span>Z</span>]<span>)</span>.
<span>A</span> = <span>Z</span>, <span>B</span> = <span>Y</span>, <span>C</span> = <span>X</span>.


:- <span>reverse</span><span>(</span><span>X</span>, [<span>3</span>, <span>2</span>, <span>1</span>]<span>)</span>.
<span>X</span> = [<span>1</span>, <span>2</span>, <span>3</span>].


:- <span>reverse</span><span>(</span><span>A</span>, <span>B</span><span>)</span>.
<span>A</span> = <span>B</span>, <span>B</span> = [];
<span>A</span> = <span>B</span>, <span>B</span> = [<span>_</span>];
<span>A</span> = [<span>_A</span>, <span>_B</span>], <span>B</span> = [<span>_B</span>, <span>_A</span>];
<span>A</span> = [<span>_A</span>, <span>_B</span>, <span>_C</span>], <span>B</span> = [<span>_C</span>, <span>_B</span>, <span>_A</span>];
</code>
            <p>
                (Where <code><span>_</span></code> denotes the &#34;anonymous variable&#34;, which can be anything, but we don&#39;t care what it actually is. And <code><span>_A</span></code>, <code><span>_B</span></code> and <code><span>_C</span></code> are &#34;helper&#34; variables generated by the system to answer our question.)
            </p>
            <p>
                This reveals a few interesting properties of Prolog: we need not specify each parameter of a predicate, we can execute our code &#34;in multiple directions&#34; so to speak, we can get more than one answer if there are any (separated by semicolons), we can &#34;complete&#34; partial solutions, and even generate every single solution - all using the same piece of code!
            </p>
            <p>
                Similarly, here are some example queries and results for <code><span>palindrome</span></code>:
            </p>
            <code>
:- <span>palindrome</span><span>(</span>[<span>1</span>, <span>2</span>]<span>)</span>.
<span>false</span>.
                

:- <span>palindrome</span><span>(</span>[<span>1</span>, <span>A</span>]<span>)</span>.
<span>A</span> = <span>1</span>.


:- <span>palindrome</span><span>(</span>[<span>1</span>, <span>A</span>, <span>B</span>, <span>4</span> | <span>C</span>]<span>)</span>.
<span>A</span> = <span>4</span>, <span>C</span> = [<span>1</span>];
<span>B</span> = <span>4</span>, <span>C</span> = [<span>A</span>, <span>1</span>];
<span>C</span> = [<span>B</span>, <span>A</span>, <span>1</span>];
<span>C</span> = [<span>4</span>, <span>B</span>, <span>A</span>, <span>1</span>];



:- <span>palindrome</span><span>(</span><span>X</span><span>)</span>.
<span>X</span> = [];
<span>X</span> = [_];
<span>X</span> = [<span>_A</span>, <span>_A</span>];
<span>X</span> = [<span>_A</span>, _, <span>_A</span>];
<span>X</span> = [<span>_A</span>, <span>_B</span>, <span>_B</span>, <span>_A</span>];
<span>X</span> = [<span>_A</span>, <span>_B</span>, _, <span>_B</span>, <span>_A</span>];
<span>X</span> = [<span>_A</span>, <span>_B</span>, <span>_C</span>, <span>_C</span>, <span>_B</span>, <span>_A</span>];
</code>
            <p>
                Take a moment to appreciate how little work we had to do to support all these different ways of calling these predicates. Additionally, try to come up with how you would even begin to implement such functionality (testing, completing, and generating palindromes) in a language you are already familiar with - it would probably take a lot more work!
            </p>
            <p>
                You can play around with the code on <a target="_blank" href="https://swish.swi-prolog.org/p/Palindromes%20example.pl">SWISH</a>, and try some queries yourself. Queries should be written in the bottom-right text field, you don&#39;t need to specify <code>:-</code> at the start. (SWISH doesn&#39;t work on all mobile devices. There should be a blue button titled &#34;Run!&#34; in the bottom right corner; this button does not always appear.)
            </p>
            
            <h2>Case study: authorization system</h2>
            <p>
                Let&#39;s consider a simple system you might be faced with building as a software engineer: a service that tracks users, roles, and rights, and is able to answer whether a user has a right through a role. We&#39;re going to look at the core application logic only, so, among other things, we abstract away database interaction, MVC structure, etc. We&#39;ll build the system twice: once in  <a target="_blank" href="https://kotlinlang.org/">Kotlin</a> (object-oriented programming), and once in  <a target="_blank" href="https://www.swi-prolog.org/">Prolog</a> (logic programming).
            </p>
            <p>
                Let&#39;s start off with Kotlin.
            </p>
            <p>
                A  <a target="_blank" href="https://en.wikipedia.org/wiki/Class_diagram">class diagram</a> (generated using <a target="_blank" target="_blank" href="https://mermaid.js.org/">Mermaid</a>) for our system could look like this:
            </p>
            <pre>                ---
                  config:
                    class:
                      hideEmptyMembersBox: true
                ---
                classDiagram
                class User {
                    roles : Set~Role~
                    isAuthorized(right: Right) Boolean
                }
                class Role {
                    rights : Set~Right~
                    isAuthorized(right: Right) Boolean
                }
                class Right
                
                User --* Role : has many
                Role --* Right : has many

                classDef default fill:#f9f,stroke:#333,stroke-width:2px
            </pre>
            <p>
                Each of the three core components are modeled as a class, roles belong to users through composition, and the same holds for rights with respect to roles. Authorization checks from the user are delegated to the authorization check of the roles the user has assigned to them. An implementation could look like this:
            </p>
            <code>
<span>data class</span> <span>User</span><span>(</span>
  <span>val</span> <span>name</span>: <span>String</span>,
  <span>val</span> <span>roles</span>: <span>Set</span>&lt;<span>Role</span>&gt;
<span>) {</span>
  <span>fun</span> <span>isAuthorized</span><span>(</span><span>right</span>: <span>Right</span><span>)</span> = <span>roles</span>.<span>any</span> <span>{</span>
    <span>role</span> <span>-&gt;</span> <span>role</span>.<span>isAuthorized</span><span>(</span><span>right</span><span>)</span>
  <span>}</span>
<span>}</span>

<span>data class</span> <span>Role</span><span>(</span>
  <span>val</span> <span>name</span>: <span>String</span>,
  <span>val</span> <span>rights</span>: <span>Set</span>&lt;<span>Right</span>&gt;
<span>) {</span>
  <span>fun</span> <span>isAuthorized</span><span>(</span><span>right</span>: <span>Right</span><span>)</span> = <span>rights</span>.<span>contains</span><span>(</span><span>right</span><span>)</span>
<span>}</span>

<span>data class</span> <span>Right</span><span>(</span><span>val</span> <span>name</span>: <span>String</span><span>)</span>


<span>val</span> <span>manage</span> = <span>Right</span><span>(</span><span>&#34;manage&#34;</span><span>)</span>
<span>val</span> <span>view</span> = <span>Right</span><span>(</span><span>&#34;view&#34;</span><span>)</span>

<span>val</span> <span>admin</span> = <span>Role</span><span>(</span><span>&#34;admin&#34;</span>, <span>setOf</span><span>(</span><span>view</span>, <span>manage</span><span>))</span>
<span>val</span> <span>supervisor</span> = <span>Role</span><span>(</span><span>&#34;supervisor&#34;</span>, <span>setOf</span><span>(</span><span>view</span>, <span>manage</span><span>))</span>
<span>val</span> <span>employee</span> = <span>Role</span><span>(</span><span>&#34;employee&#34;</span>, <span>setOf</span><span>(</span><span>view</span><span>))</span>

<span>val</span> <span>damian</span> = <span>User</span><span>(</span><span>&#34;Damian&#34;</span>, <span>setOf</span><span>(</span><span>admin</span><span>))</span>
<span>val</span> <span>kai</span> = <span>User</span><span>(</span><span>&#34;Kai&#34;</span>, <span>setOf</span><span>(</span><span>supervisor</span><span>))</span>
<span>val</span> <span>nela</span> = <span>User</span><span>(</span><span>&#34;Nela&#34;</span>, <span>setOf</span><span>(</span><span>supervisor</span><span>))</span>
<span>val</span> <span>anna</span> = <span>User</span><span>(</span><span>&#34;Anna&#34;</span>, <span>setOf</span><span>(</span><span>employee</span><span>))</span>
<span>val</span> <span>reinier</span> = <span>User</span><span>(</span><span>&#34;Reinier&#34;</span>, <span>setOf</span><span>(</span><span>employee</span><span>))</span>


<span>fun</span> <span>main</span><span>() {</span>
  <span>listOf</span><span>(</span><span>damian</span>, <span>kai</span>, <span>nela</span>, <span>anna</span>, <span>reinier</span><span>)</span>.<span>forEach</span> <span>{</span> <span>user</span> -&gt;
    <span>val</span> <span>canManage</span> = <span>user</span>.<span>isAuthorized</span><span>(</span><span>manage</span><span>)</span>
    <span>val</span> <span>canView</span> = <span>user</span>.<span>isAuthorized</span><span>(</span><span>view</span><span>)</span>
    <span>println</span><span>(</span><span>&#34;User: ${</span><span>user</span>.<span>name</span><span>},\tmanage: $</span><span>canManage</span><span>\tview: $</span><span>canView</span><span>&#34;</span><span>)</span>
  <span>}</span>
<span>}</span></code>
            <p>
                You can play around with the code in the  <a target="_blank" href="https://play.kotlinlang.org/#eyJ2ZXJzaW9uIjoiMi4xLjAiLCJwbGF0Zm9ybSI6ImphdmEiLCJhcmdzIjoiIiwibm9uZU1hcmtlcnMiOnRydWUsInRoZW1lIjoiaWRlYSIsImNvZGUiOiIvLyBDbGFzcyBzdHJ1Y3R1cmVcbmRhdGEgY2xhc3MgVXNlcihcbiAgdmFsIG5hbWU6IFN0cmluZyxcbiAgdmFsIHJvbGVzOiBTZXQ8Um9sZT5cbikge1xuICBmdW4gaXNBdXRob3JpemVkKHJpZ2h0OiBSaWdodCkgPSByb2xlcy5hbnkge1xuICAgIHJvbGUgLT4gcm9sZS5pc0F1dGhvcml6ZWQocmlnaHQpXG4gIH1cbn1cblxuZGF0YSBjbGFzcyBSb2xlKFxuICB2YWwgbmFtZTogU3RyaW5nLFxuICB2YWwgcmlnaHRzOiBTZXQ8UmlnaHQ+XG4pIHtcbiAgZnVuIGlzQXV0aG9yaXplZChyaWdodDogUmlnaHQpID0gcmlnaHRzLmNvbnRhaW5zKHJpZ2h0KVxufVxuXG5kYXRhIGNsYXNzIFJpZ2h0KHZhbCBuYW1lOiBTdHJpbmcpXG5cbi8vIEV4YW1wbGUgZGF0YVxudmFsIG1hbmFnZSA9IFJpZ2h0KFwibWFuYWdlXCIpXG52YWwgdmlldyA9IFJpZ2h0KFwidmlld1wiKVxuXG52YWwgYWRtaW4gPSBSb2xlKFwiYWRtaW5cIiwgc2V0T2YodmlldywgbWFuYWdlKSlcbnZhbCBzdXBlcnZpc29yID0gUm9sZShcInN1cGVydmlzb3JcIiwgc2V0T2YodmlldywgbWFuYWdlKSlcbnZhbCBlbXBsb3llZSA9IFJvbGUoXCJlbXBsb3llZVwiLCBzZXRPZih2aWV3KSlcblxudmFsIGRhbWlhbiA9IFVzZXIoXCJEYW1pYW5cIiwgc2V0T2YoYWRtaW4pKVxudmFsIGthaSA9IFVzZXIoXCJLYWlcIiwgc2V0T2Yoc3VwZXJ2aXNvcikpXG52YWwgbmVsYSA9IFVzZXIoXCJOZWxhXCIsIHNldE9mKHN1cGVydmlzb3IpKVxudmFsIGFubmEgPSBVc2VyKFwiQW5uYVwiLCBzZXRPZihlbXBsb3llZSkpXG52YWwgcmVpbmllciA9IFVzZXIoXCJSZWluaWVyXCIsIHNldE9mKGVtcGxveWVlKSlcblxuLy8gTWFpbiBtZXRob2RcbmZ1biBtYWluKCkge1xuICAgIGxpc3RPZihkYW1pYW4sIGthaSwgbmVsYSwgYW5uYSwgcmVpbmllcikuZm9yRWFjaCB7IHVzZXIgLT5cbiAgICAgICAgdmFsIGNhbk1hbmFnZSA9IHVzZXIuaXNBdXRob3JpemVkKG1hbmFnZSlcbiAgICAgICAgdmFsIGNhblZpZXcgPSB1c2VyLmlzQXV0aG9yaXplZCh2aWV3KVxuICAgICAgICBwcmludGxuKFwiVXNlcjogJHt1c2VyLm5hbWV9LFxcdG1hbmFnZTogJGNhbk1hbmFnZVxcdHZpZXc6ICRjYW5WaWV3XCIpXG4gICAgfVxufSJ9">Kotlin Playground</a>.
            </p>
            <p>
                I would say this is the stereotypical object-oriented solution to the question. And while it&#39;s definitely an approach that solves the problem, there&#39;s a bit of &#34;fluff&#34; involved that unnecessarily complicates the program. For example, the fact that a <code><span>User</span></code> actually <i>contains</i> <code><span>roles</span></code> through composition doesn&#39;t help answer the core question for which we designed the system: is a user authorized to do a specific thing?
            </p>
            <p>
                If you&#39;re only familiar with OOP languages, you may not even be aware of this fluff, as thinking in terms of classes and objects is an important part of the IT and CS curricula, and defining the interactions between classes is the crux of OOP. But regardless whether you&#39;re aware of it or not, the fluff is there, and it can have an impact on the adaptability of your program.
            </p>
            
            <p>
                Now, let&#39;s try the same thing in Prolog.
            </p>
            <p>
                Rather than subdivide the problem into classes, we try to define the <i>relations</i> that must hold in the system: what does it <i>mean</i> to be authorized?
            </p>
            <code>
<span>authorized</span><span>(</span><span>User</span>, <span>Right</span><span>)</span> :-
  <span>user_role</span><span>(</span><span>User</span>, <span>Role</span><span>)</span>,
  <span>role_right</span><span>(</span><span>Role</span>, <span>Right</span><span>)</span>.


<span>user_role</span><span>(</span><span>damian</span>, <span>admin</span><span>)</span>.
<span>user_role</span><span>(</span><span>kai</span>, <span>supervisor</span><span>)</span>.
<span>user_role</span><span>(</span><span>nela</span>, <span>supervisor</span><span>)</span>.
<span>user_role</span><span>(</span><span>anna</span>, <span>employee</span><span>)</span>.
<span>user_role</span><span>(</span><span>reinier</span>, <span>employee</span><span>)</span>.

<span>role_right</span><span>(</span><span>admin</span>, <span>_</span><span>)</span>.
<span>role_right</span><span>(</span><span>supervisor</span>, <span>manage</span><span>)</span>.
<span>role_right</span><span>(</span><span>supervisor</span>, <span>view</span><span>)</span>.
<span>role_right</span><span>(</span><span>employee</span>, <span>view</span><span>)</span>.</code>
            <p>
                And we&#39;re done already! Remember: words starting with an uppercase letter are considered variables. Those starting with lowercase letters are &#34;terms&#34; (either predicates or atoms, atoms like <code><span>admin</span></code> are a type of constant). You can play around with the code on <a target="_blank" href="https://swish.swi-prolog.org/p/Simple%20authorization%20example.pl">SWISH</a>.
            </p>
            <p>
                The definition of the <code><span>authorized</span></code> predicate can be read as: you can say that a <code><span>User</span></code> has a <code><span>Right</span></code> if the <code><span>User</span></code> has a <code><span>Role</span></code>, for which the <code><span>Role</span></code> has that <code><span>Right</span></code>.
            </p>
            <p>
                As before, we can now query our Prolog system. For example, we could ask the system whether <code><span>authorized</span><span>(</span><span>reinier</span>, <span>manage</span><span>)</span>.</code> holds in our program. Since this isn&#39;t true, we get <code><span>false</span></code>. Similarly, asking <code><span>authorized</span><span>(</span><span>damian</span>, <span>manage</span><span>)</span>.</code> yields <code><span>true</span></code>.
            </p>
            <p>
                And, just as in our introduction, the true strength of Prolog now comes from its generality. We can for example ask the Prolog system: <code><span>authorized</span><span>(</span><span>nela</span>, <span>Right</span><span>)</span>.</code>, where the second argument <code><span>Right</span></code> is a variable. This yields all possible assignments to this variable for which the predicate holds, i.e. it yields all rights that <code><span>nela</span></code> has. Similarly, we could ask the converse: <code><span>authorized</span><span>(</span><span>User</span>, <span>manage</span><span>)</span>.</code>, yielding all values of <code><span>User</span></code> that are authorized to <code><span>manage</span></code>. Informally speaking, we can execute our code in multiple directions!
            </p>
            <p>
                In fact, we can ask the system something that&#39;s known as <i>the most general query</i> of a predicate, where we leave <i>all</i> arguments unspecified: <code><span>authorized</span><span>(</span><span>User</span>, <span>Right</span><span>)</span>.</code>. This enumerates all possible solutions to the question: does <code><span>User</span></code> have <code><span>Right</span></code>? Try it out if you haven&#39;t already.
            </p>
            
            <p>
                In total the <code><span>authorized</span></code> predicate can be called 4 different ways, since each of the 2 arguments can either be specified or be a variable. Our Kotlin system would require an function for each of these ways to be able to do the same things. Below is the resulting Kotlin code if we want to support the same functionality:
            </p>
            <code>
<span>data class</span> <span>User</span><span>(</span>
  <span>val</span> <span>name</span>: <span>String</span>,
  <span>val</span> <span>roles</span>: <span>Set</span>&lt;<span>Role</span>&gt;
<span>) {</span>
  <span>fun</span> <span>isAuthorized</span><span>(</span><span>right</span>: <span>Right</span><span>)</span> = <span>roles</span>.<span>any</span> <span>{</span>
    <span>role</span> <span>-&gt;</span> <span>role</span>.<span>isAuthorized</span><span>(</span><span>right</span><span>)</span>
  <span>}</span>

  <span>fun</span> <span>allRights</span><span>()</span> =
    <span>roles</span>.<span>fold</span><span>(</span><span>mutableSetOf</span>&lt;<span>Right</span>&gt;<span>()) {</span>
      <span>rights</span>, <span>role</span> -&gt;
        <span>rights</span>.<span>addAll</span><span>(</span><span>role</span>.<span>rights</span><span>)</span>
        <span>rights</span>
    <span>}</span>

  <span>companion object</span> <span>{</span>
    <span>fun</span> <span>usersWithRight</span><span>(</span><span>users</span>: <span>Collection</span>&lt;<span>User</span>&gt;, <span>right</span>: <span>Right</span><span>)</span> =
      <span>users</span>.<span>filter</span> <span>{</span> <span>it</span>.<span>isAuthorized</span><span>(</span><span>right</span><span>) }</span>
    
    <span>fun</span> <span>userRightPairs</span><span>(</span><span>users</span>: <span>Collection</span>&lt;<span>User</span>&gt;<span>)</span> =
      <span>buildList</span> <span>{</span>
        <span>users</span>.<span>forEach</span> <span>{</span> <span>user</span> -&gt;
          <span>user</span>.<span>allRights</span><span>()</span>.<span>forEach</span> <span>{</span> <span>right</span> -&gt;
            <span>add</span><span>(</span><span>Pair</span><span>(</span><span>user</span>, <span>right</span><span>))</span>
          <span>}</span>
        <span>}</span>
      <span>}</span>
  <span>}</span>
<span>}</span>

<span>data class</span> <span>Role</span><span>(</span>
  <span>val</span> <span>name</span>: <span>String</span>,
  <span>val</span> <span>rights</span>: <span>Set</span>&lt;<span>Right</span>&gt;
<span>) {</span>
  <span>fun</span> <span>isAuthorized</span><span>(</span><span>right</span>: <span>Right</span><span>)</span> = <span>rights</span>.<span>contains</span><span>(</span><span>right</span><span>)</span>
<span>}</span>

<span>data class</span> <span>Right</span><span>(</span><span>val</span> <span>name</span>: <span>String</span><span>)</span>


<span>val</span> <span>manage</span> = <span>Right</span><span>(</span><span>&#34;manage&#34;</span><span>)</span>
<span>val</span> <span>view</span> = <span>Right</span><span>(</span><span>&#34;view&#34;</span><span>)</span>

<span>val</span> <span>admin</span> = <span>Role</span><span>(</span><span>&#34;admin&#34;</span>, <span>setOf</span><span>(</span><span>view</span>, <span>manage</span><span>))</span>
<span>val</span> <span>supervisor</span> = <span>Role</span><span>(</span><span>&#34;supervisor&#34;</span>, <span>setOf</span><span>(</span><span>view</span>, <span>manage</span><span>))</span>
<span>val</span> <span>employee</span> = <span>Role</span><span>(</span><span>&#34;employee&#34;</span>, <span>setOf</span><span>(</span><span>view</span><span>))</span>

<span>val</span> <span>damian</span> = <span>User</span><span>(</span><span>&#34;Damian&#34;</span>, <span>setOf</span><span>(</span><span>admin</span><span>))</span>
<span>val</span> <span>kai</span> = <span>User</span><span>(</span><span>&#34;Kai&#34;</span>, <span>setOf</span><span>(</span><span>supervisor</span><span>))</span>
<span>val</span> <span>nela</span> = <span>User</span><span>(</span><span>&#34;Nela&#34;</span>, <span>setOf</span><span>(</span><span>supervisor</span><span>))</span>
<span>val</span> <span>anna</span> = <span>User</span><span>(</span><span>&#34;Anna&#34;</span>, <span>setOf</span><span>(</span><span>employee</span><span>))</span>
<span>val</span> <span>reinier</span> = <span>User</span><span>(</span><span>&#34;Reinier&#34;</span>, <span>setOf</span><span>(</span><span>employee</span><span>))</span>

<span>val</span> <span>allRights</span> = <span>listOf</span><span>(</span><span>view</span>, <span>manage</span><span>)</span>
<span>val</span> <span>allUsers</span> = <span>listOf</span><span>(</span><span>damian</span>, <span>kai</span>, <span>nela</span>, <span>anna</span>, <span>reinier</span><span>)</span>


<span>fun</span> <span>main</span><span>() {</span>
  <span>allUsers</span>.<span>forEach</span> <span>{</span> <span>user</span> -&gt;
    <span>val</span> <span>canManage</span> = <span>user</span>.<span>isAuthorized</span><span>(</span><span>manage</span><span>)</span>
    <span>val</span> <span>canView</span> = <span>user</span>.<span>isAuthorized</span><span>(</span><span>view</span><span>)</span>
    <span>println</span><span>(</span><span>&#34;User: ${</span><span>user</span>.<span>name</span><span>},\tmanage: $</span><span>canManage</span><span>\tview: $</span><span>canView</span><span>&#34;</span><span>)</span>
    <span>println</span><span>(</span><span>user</span>.<span>allRights</span><span>())</span>
  <span>}</span>
    
  <span>allRights</span>.<span>forEach</span> <span>{</span> <span>right</span> -&gt;
    <span>val</span> <span>users</span> = <span>User</span>.<span>usersWithRight</span><span>(</span><span>allUsers</span>, <span>right</span><span>)</span>
    <span>println</span><span>(</span><span>&#34;Right: $</span><span>{</span><span>right</span>.<span>name</span><span>}</span><span>\t$</span><span>users</span><span>&#34;</span><span>)</span>
  <span>}</span>
    
  <span>println</span><span>(</span><span>User</span>.<span>userRightPairs</span><span>(</span><span>allUsers</span><span>))</span>
<span>}</span></code>
            <p>
                You can play around with the code in the <a target="_blank" href="https://play.kotlinlang.org/?_gl=1*1ra79ys*_gcl_au*MTE0ODY5NDQ5My4xNzM3MzAxMDAy*_ga*MjgxNDYyNzA5LjE3MzczMDEwMDE.*_ga_9J976DJZ68*MTczNzQxMDA3Ny45LjEuMTczNzQxMDA4NC41My4wLjA.#eyJ2ZXJzaW9uIjoiMi4xLjAiLCJwbGF0Zm9ybSI6ImphdmEiLCJhcmdzIjoiIiwibm9uZU1hcmtlcnMiOnRydWUsInRoZW1lIjoiaWRlYSIsImNvZGUiOiIvLyBDbGFzcyBzdHJ1Y3R1cmVcbmRhdGEgY2xhc3MgVXNlcihcbiAgdmFsIG5hbWU6IFN0cmluZyxcbiAgdmFsIHJvbGVzOiBTZXQ8Um9sZT5cbikge1xuICBmdW4gaXNBdXRob3JpemVkKHJpZ2h0OiBSaWdodCkgPSByb2xlcy5hbnkge1xuICAgIHJvbGUgLT4gcm9sZS5pc0F1dGhvcml6ZWQocmlnaHQpXG4gIH1cblxuICBmdW4gYWxsUmlnaHRzKCkgPVxuICAgIHJvbGVzLmZvbGQobXV0YWJsZVNldE9mPFJpZ2h0PigpKSB7XG4gICAgICByaWdodHMsIHJvbGUgLT5cbiAgICAgICAgcmlnaHRzLmFkZEFsbChyb2xlLnJpZ2h0cylcbiAgICAgICAgcmlnaHRzXG4gICAgfVxuXG4gIGNvbXBhbmlvbiBvYmplY3Qge1xuICAgIGZ1biB1c2Vyc1dpdGhSaWdodCh1c2VyczogQ29sbGVjdGlvbjxVc2VyPiwgcmlnaHQ6IFJpZ2h0KSA9XG4gICAgICB1c2Vycy5maWx0ZXIgeyBpdC5pc0F1dGhvcml6ZWQocmlnaHQpIH1cbiAgICBcbiAgICBmdW4gdXNlclJpZ2h0UGFpcnModXNlcnM6IENvbGxlY3Rpb248VXNlcj4pID1cbiAgICAgIGJ1aWxkTGlzdCB7XG4gICAgICAgIHVzZXJzLmZvckVhY2ggeyB1c2VyIC0+XG4gICAgICAgICAgdXNlci5hbGxSaWdodHMoKS5mb3JFYWNoIHsgcmlnaHQgLT5cbiAgICAgICAgICAgIGFkZChQYWlyKHVzZXIsIHJpZ2h0KSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfVxufVxuXG5kYXRhIGNsYXNzIFJvbGUoXG4gIHZhbCBuYW1lOiBTdHJpbmcsXG4gIHZhbCByaWdodHM6IFNldDxSaWdodD5cbikge1xuICBmdW4gaXNBdXRob3JpemVkKHJpZ2h0OiBSaWdodCkgPSByaWdodHMuY29udGFpbnMocmlnaHQpXG59XG5cbmRhdGEgY2xhc3MgUmlnaHQodmFsIG5hbWU6IFN0cmluZylcblxuLy8gRXhhbXBsZSBkYXRhXG52YWwgbWFuYWdlID0gUmlnaHQoXCJtYW5hZ2VcIilcbnZhbCB2aWV3ID0gUmlnaHQoXCJ2aWV3XCIpXG5cbnZhbCBhZG1pbiA9IFJvbGUoXCJhZG1pblwiLCBzZXRPZih2aWV3LCBtYW5hZ2UpKVxudmFsIHN1cGVydmlzb3IgPSBSb2xlKFwic3VwZXJ2aXNvclwiLCBzZXRPZih2aWV3LCBtYW5hZ2UpKVxudmFsIGVtcGxveWVlID0gUm9sZShcImVtcGxveWVlXCIsIHNldE9mKHZpZXcpKVxuXG52YWwgZGFtaWFuID0gVXNlcihcIkRhbWlhblwiLCBzZXRPZihhZG1pbikpXG52YWwga2FpID0gVXNlcihcIkthaVwiLCBzZXRPZihzdXBlcnZpc29yKSlcbnZhbCBuZWxhID0gVXNlcihcIk5lbGFcIiwgc2V0T2Yoc3VwZXJ2aXNvcikpXG52YWwgYW5uYSA9IFVzZXIoXCJBbm5hXCIsIHNldE9mKGVtcGxveWVlKSlcbnZhbCByZWluaWVyID0gVXNlcihcIlJlaW5pZXJcIiwgc2V0T2YoZW1wbG95ZWUpKVxuXG52YWwgYWxsUmlnaHRzID0gbGlzdE9mKHZpZXcsIG1hbmFnZSlcbnZhbCBhbGxVc2VycyA9IGxpc3RPZihkYW1pYW4sIGthaSwgbmVsYSwgYW5uYSwgcmVpbmllcilcblxuLy8gTWFpbiBtZXRob2RcbmZ1biBtYWluKCkge1xuICAgIGFsbFVzZXJzLmZvckVhY2ggeyB1c2VyIC0+XG4gICAgICAgIHZhbCBjYW5NYW5hZ2UgPSB1c2VyLmlzQXV0aG9yaXplZChtYW5hZ2UpXG4gICAgICAgIHZhbCBjYW5WaWV3ID0gdXNlci5pc0F1dGhvcml6ZWQodmlldylcbiAgICAgICAgcHJpbnRsbihcIlVzZXI6ICR7dXNlci5uYW1lfSxcXHRtYW5hZ2U6ICRjYW5NYW5hZ2VcXHR2aWV3OiAkY2FuVmlld1wiKVxuICAgICAgICBwcmludGxuKHVzZXIuYWxsUmlnaHRzKCkpXG4gICAgfVxuICAgIFxuICAgIGFsbFJpZ2h0cy5mb3JFYWNoIHsgcmlnaHQgLT5cbiAgICAgICAgdmFsIHVzZXJzID0gVXNlci51c2Vyc1dpdGhSaWdodChhbGxVc2VycywgcmlnaHQpXG4gICAgICAgIHByaW50bG4oXCJSaWdodDogJHtyaWdodC5uYW1lfVxcdCR1c2Vyc1wiKVxuICAgIH1cbiAgICBcbiAgICBwcmludGxuKFVzZXIudXNlclJpZ2h0UGFpcnMoYWxsVXNlcnMpKVxufSJ9">Kotlin Playground</a>.
            </p>
            <p>
                The following snippets can be considered equivalent across the systems:
            </p>
            <ul>
                <li><code><span>authorized</span><span>(</span><span>anna</span>, <span>manage</span><span>)</span>.</code> is equivalent to <code><span>anna</span>.<span>isAuthorized</span><span>(</span><span>manage</span><span>)</span></code>;</li>
                <li><code><span>authorized</span><span>(</span><span>User</span>, <span>manage</span><span>)</span>.</code> is equivalent to <code><span>User</span>.<span>usersWithRight</span><span>(</span><span>allUsers</span>, <span>manage</span><span>)</span></code>;</li>
                <li><code><span>authorized</span><span>(</span><span>anna</span>, <span>Right</span><span>)</span>.</code> is equivalent to <code><span>anna</span>.<span>allRights</span><span>()</span></code>;</li>
                <li><code><span>authorized</span><span>(</span><span>User</span>, <span>Right</span><span>)</span>.</code> is equivalent to <code><span>User</span>.<span>userRightPairs</span><span>(</span><span>allUsers</span><span>)</span></code>.</li>
            </ul>
            <p>
                Not all of these may make sense to support in an actual system, but if we did want to support them, not having to maintain multiple methods for the same piece of logic makes the Prolog code much easier to refactor in this case.
            </p>
            <h2>Changing requirements: accounting for time</h2>
            <p>
                After having run your system for some time, your clients have expressed a wish for a new functionality: rather than solely tracking the authorization state at the current moment, they want to be able to track and query it over time. So someone may only be assigned a role for a specific time frame, and a role may only have a right for a specific time frame. You should now only be considered authorized at a point in time if you have a role at that point in time that has that right at that point in time.
            </p>
            <p>
                So we go back to the drawing board for our class diagram, and start adding <a target="_blank" href="https://en.wikipedia.org/wiki/Associative_entity">associative entities</a> (also referred to as join tables in database jargon). Rather than assigning a role directly to a user, we assign them the role for a specific time range, and similar for roles and rights. We still maintain roles and rights as entities in their own right, so we can add properties on them independently from their assignment to users and roles respectively.
            </p>
            <p>
                All in all, this gives us the new diagram (I&#39;ve omitted the new methods from the previous section for clarity):
            </p>
            <pre>                ---
                  config:
                    class:
                      hideEmptyMembersBox: true
                ---
                classDiagram
                class User {
                    userRoleAssignments: Set~UserRoleAssignment~
                    isAuthorized(right: Right, timestamp: Instant) Boolean
                }
                class UserRoleAssignment {
                    validFrom: Instant
                    validTo: Instant
                    validDuring(timestamp: Instant) Boolean
                }
                class Role {
                    roleRightAssignment : Set~RoleRightAssignment~
                    isAuthorized(right: Right, timestamp: Instant) Boolean
                }
                class RoleRightAssignment {
                    validFrom: Instant
                    validTo: Instant
                    validDuring(timestamp: Instant) Boolean
                }
                class Right
                
                User -- UserRoleAssignment
                UserRoleAssignment -- Role
                Role -- RoleRightAssignment
                RoleRightAssignment -- Right

                classDef default fill:#f9f,stroke:#333,stroke-width:2px
            </pre>
            <p>
                The required code changes follow rather naturally from our new choice of class hierarchy, but are quite far-reaching. We need to add new classes <code><span>UserRoleAssignment</span></code> and <code><span>RoleRightAssignment</span></code>, replace the <code><span>roles</span></code> and <code><span>rights</span></code> fields, refactor the <code><span>isAuthorized</span></code> method of both <code><span>User</span></code> and <code><span>Role</span></code> by adding a time parameter, and add this parameter to each call site of either of these methods (so far, in <code><span>allRights</span></code>, <code><span>usersWithRight</span></code>, and <code><span>userRightPairs</span></code> - and probably only more as the system ages).
            </p>
            <p>
                I&#39;ll leave this refactoring as an exercise to the reader.
            </p>
            <p>
                Making the same change in our Prolog system turns out to be much simpler: since there is no separate logic for the different ways in which the predicate can be queried, there are less places that need to be refactored, just one, in fact. We add a <code><span>Timestamp</span></code> argument to the <code><span>authorized</span></code> predicate, and add two timestamps to each fact - for simplicity assume timestamps are represented by integers (for example representing <a target="_blank" href="https://en.wikipedia.org/wiki/Unix_time">Unix time</a>). Using <a target="_blank" href="https://www.swi-prolog.org/pldoc/man?section=clp">constraint logic programming</a>, we can restrict the domain of <code><span>Timestamp</span></code>, to get:
            </p>
            <code>:- <span>use_module(library(clpfd))</span>.


<span>authorized</span><span>(</span><span>User</span>, <span>Right</span>, <span>Timestamp</span><span>)</span> :-
  <span>user_role</span><span>(</span><span>User</span>, <span>Role</span>, <span>URFrom</span>, <span>URTo</span><span>)</span>,
  <span>Timestamp</span> #&gt;= <span>URFrom</span>,
  <span>Timestamp</span> #&lt; <span>URTo</span>,
  <span>role_right</span><span>(</span><span>Role</span>, <span>Right</span>, <span>RRFrom</span>, <span>RRTo</span><span>)</span>,
  <span>Timestamp</span> #&gt;= <span>RRFrom</span>,
  <span>Timestamp</span> #&lt; <span>RRTo</span>.


<span>user_role</span><span>(</span><span>damian</span>, <span>admin</span>, <span>0</span>, <span>300</span><span>)</span>.
<span>user_role</span><span>(</span><span>kai</span>, <span>supervisor</span>, <span>0</span>, <span>150</span><span>)</span>.
<span>user_role</span><span>(</span><span>nela</span>, <span>supervisor</span>, <span>150</span>, <span>300</span><span>)</span>.
<span>user_role</span><span>(</span><span>anna</span>, <span>employee</span>, <span>0</span>, <span>200</span><span>)</span>.
<span>user_role</span><span>(</span><span>reinier</span>, <span>employee</span>, <span>100</span>, <span>300</span><span>)</span>.

<span>role_right</span><span>(</span><span>admin</span>, <span>_</span>, <span>0</span>, <span>300</span><span>)</span>.
<span>role_right</span><span>(</span><span>supervisor</span>, <span>manage</span>, <span>100</span>, <span>200</span><span>)</span>.
<span>role_right</span><span>(</span><span>supervisor</span>, <span>view</span>, <span>0</span>, <span>300</span><span>)</span>.
<span>role_right</span><span>(</span><span>employee</span>, <span>view</span>, <span>0</span>, <span>300</span><span>)</span>.</code>
            <p>
                You can play around with the code on <a target="_blank" href="https://swish.swi-prolog.org/p/Extended%20authorization%20example.pl">SWISH</a>.
            </p>
            <p>
                Since each of the three variables in the <code><span>authorized</span></code> predicate (<code><span>User</span></code>, <code><span>Right</span></code>, and <code><span>Timestamp</span></code>) can either be specified or be left unbound, the new <code><span>authorized</span></code> predicate now permits <math><msup><mn>2</mn><mn>3</mn></msup><mo>=</mo><mn>8</mn></math> modes of execution!
            </p>
            <p>
                For example:
            </p>
            <ul>
                <li><code><span>authorized</span><span>(</span><span>nela</span>, <span>manage</span>, <span>100</span><span>)</span>.</code> asks: was <code><span>nela</span></code> allowed to <code><span>manage</span></code> at <code><span>100</span></code>? <code><span>false</span></code> (no).</li>
                <li><code><span>authorized</span><span>(</span><span>User</span>, <span>manage</span>, <span>100</span><span>)</span>.</code> asks: which <code><span>User</span></code> was allowed to <code><span>manage</span></code> at <code><span>100</span></code>? <code><span>damian</span></code> and <code><span>kai</span></code>.</li>
                <li><code><span>authorized</span><span>(</span><span>nela</span>, <span>Right</span>, <span>100</span><span>)</span>.</code> asks: which <code><span>Right</span></code> did <code><span>nela</span></code> have at <code><span>100</span></code>? <code><span>false</span></code> (none).</li>
                <li><code><span>authorized</span><span>(</span><span>nela</span>, <span>manage</span>, <span>Timestamp</span><span>)</span>.</code> asks: at which <code><span>Timestamp</span></code> was <code><span>nela</span></code> allowed to <code><span>manage</span></code>? From <code><span>150</span></code> until <code><span>199</span></code>.</li>
            </ul>
            <p>
                And again, none of these modes of execution required additional code - they all originated from the same relation! In our Kotlin system, we would first need to refactor our object model to include time, including refactoring <i>each</i> method that depended on it, making it harder to make such changes in the presence of more methods. And even after this refactor, we still miss the 4 extra modes of execution offered by Prolog.
            </p>
            <p>
                Finally, note the elegance of what the last example listed above is telling us: any <code><span>Timestamp</span></code> within a certain range will do to make the statement true. We didn&#39;t even need to define the concept of a period! Imagine how much additional effort would be required to support this in our Kotlin system.
            </p>
            <h2>Wrapping up</h2>
            <p>
                So what should you to take away from all of this?
            </p>
            <p>
                Obviously, no programming language is &#34;the best&#34;. Some languages may be more suitable to model specific types of systems (and even that is subjective). But there are many more factors at play that can make one language a more reasonable choice over another besides language features, including but not limited to: availability of tooling, active maintenance, community support, existing knowledge within a team/company, probability of new hirees knowing the language, start up costs, etc.
            </p>
            <p>
                Realistically, a lot of these factors are not in favor of choosing Prolog, because while it is a <i>simple</i> language (there is often little additional complexity added to the problem you&#39;re solving), it is definitely not an <i>easy</i> language (it can have a steep learning curve due to being very different from &#34;traditional&#34; languages): it sometimes requires you to really think.
            </p>
            <p>
                Sadly, after more than 50 years, it still somewhat suffers from the &#34;bootstrapping problem&#34;. There&#39;s a vicious cycle: outside of niche fields and research, there is little usage because there aren&#39;t many programmers that know it, and there aren&#39;t many programmers that learn it because there is no demand...
            </p>
            <p>
                Nonetheless I think there is value in knowing the language, for multiple reasons. Different paradigms offer different ways to look at a problem, and in some cases this may involve much less hassle than working in a paradigm you might already know. Some may interpret this as: &#34;Prolog is a suitable language only when your system <i>is</i> simple.&#34;, but I think the converse is true: &#34;Prolog helps <i>keep</i> your system simple!&#34;
            </p><p>
                To sum it all up:
            </p>
            <p>
                <a target="_blank" href="https://en.wikipedia.org/wiki/Law_of_the_instrument"><i>&#34;If all you have is object-oriented programming, everything looks like an object.&#34;</i></a>
            </p>
            <p>
                So try and learn new things! If you are excited to learn more, here are some excellent resources to start you on your journey:
            </p>
            <ul>
                <li><a target="_blank" href="https://cliplab.org/~logalg/doc/The_Art_of_Prolog.pdf">The Art of Prolog (PDF)</a> is <i>the</i> book for beginning with Prolog. It teaches by example, and gives you a good foundational understanding of the language, as well as showing some advanced concepts;</li>
                <li><a target="_blank" href="https://www.metalevel.at/prolog">The Power of Prolog</a> is also a great resource for foundational and more advanced concepts like definite clause grammars and constraint logic programming. The Power of Prolog can also be found on <a target="_blank" href="https://www.youtube.com/@ThePowerOfProlog">YouTube</a> if you prefer that to reading. I recommend to start with the <a target="_blank" href="https://www.youtube.com/playlist?list=PLEvH6T-1oh75UagVp5BqeOVageBljdmaC">Syntax and Semantics</a> playlist.
                </li>
                <li>If you want to sharpen your skills, check out the <a target="_blank" href="https://www.ic.unicamp.br/~meidanis/courses/mc336/2009s2/prolog/problemas/">P-99</a>. It is a set of Prolog programming problems designed to train your relational thinking.</li>
                <li>Also check out the <a target="_blank" href="https://www.reddit.com/r/prolog/">r/prolog</a> subreddit. It&#39;s not a very active community, but any questions you may have are sure to be answered. I&#39;m also semi-active there.</li>
            </ul>
            <p>
                In my next posts, I will show some problems that lend themselves well to being solved using Prolog, so stay tuned!
            </p>
            
        </article></div>
  </body>
</html>
