<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://arighi.blogspot.com/2024/05/extend-your-battery-life-with.html">Original</a>
    <h1>Extend your battery life with scx_rustland</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-1658548608697488006" itemprop="description articleBody">
<p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhlUQ8IRIzR7COIaGUGw4MbJEishEeTdJy7XMq1OX0C1xC4PVU8IQmkvuDfb565ICO0Zo6oH6-43lg8J2a0njQ3j5mWQuN688intxzYMLfcov-eQczIQJ6Qo3EZjUiFDMhMGnrAJ-MQYVTEL9Y07NMyHDbeg7fnUU3v1cyS2YCvmwXtiW4EWy2GfJCr/s844/power.png"><img alt="" data-original-height="472" data-original-width="844" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhlUQ8IRIzR7COIaGUGw4MbJEishEeTdJy7XMq1OX0C1xC4PVU8IQmkvuDfb565ICO0Zo6oH6-43lg8J2a0njQ3j5mWQuN688intxzYMLfcov-eQczIQJ6Qo3EZjUiFDMhMGnrAJ-MQYVTEL9Y07NMyHDbeg7fnUU3v1cyS2YCvmwXtiW4EWy2GfJCr/s400/power.png" width="400"/></a></p>
<h2 id="overview">Overview</h2>
<p>The CPU scheduler can play a significant role to save energy in the
system. Typically we talk about Energy Aware Scheduling (EAS) when
scehduling decisions can impact on the energy consumed by the CPUs. EAS
relies on an Energy Model (EM) of the CPUs to select the most energy
efficient CPU for each task, with a minimal impact on throughput.</p>
<p>Effective energy-saving techniques can also be applied by maximizing
the idle time of the CPUs. Modern CPUs’ power consumption is heavily
influenced by how long they remain idle, sometimes yielding more
significant energy savings than Dynamic Voltage and Frequency Scaling
(DVFS) techniques (e.g., the cpufreq governor).</p>
<h2 id="forcing-cpus-to-stay-idle">Forcing CPUs to stay idle</h2>
<p>The scheduler can force specific CPUs to stay idle by not assigning
tasks to them. However, it is essential to find a good balance between
energy savings and performance. For example, a drastic solution could be
scheduling all tasks on a single CPU while keeping others idle. This can
save energy in emergency situations, such as when a battery-powered
device is nearly out of power, but it can severely degrades the overall
system performance.</p>
<h2 id="energy-saving-with-scx_rustland">Energy saving with
<code>scx_rustland</code></h2>
<p><a href="https://github.com/sched-ext/scx/tree/main/scheds/rust/scx_rustland">scx_rustland</a>
uses a very simple, yet effective, strategy to save energy: when a CPU
enters an idle state, it attempts to keep it idle if other CPUs are
active, even if there are tasks queued for scheduling.</p>
<p>Since <code>scx_rustland</code> uses a vruntime-based policy,
latency-sensitive tasks are likely placed at the top of the queue. Thus,
active CPUs can quickly dispatch these tasks, maintaining system
responsiveness. CPU-intensive tasks, on the other hand, will spend more
time in the scheduler queue, waiting for an active CPU.</p>
<p>This approach reduces overall system throughput by intentionally
introducing bubbles in the scheduling, but it helps save power without
compromising system responsiveness.</p>
<p>Of course the overall throughput in the system is strongly reduced
(CPUs are explicitly under-utilized), but the “CPU throttling” is mostly
affecting background CPU-intensive tasks.</p>
<p>For this reason, this strategy is disabled by default and it can be
enabled starting the scheduler with the <code>--low-power</code>
option.</p>
<h2 id="implementation">Implementation</h2>
<p>The implementation of this strategy is also very simple, technically
just a <a href="https://github.com/sched-ext/scx/blob/main/rust/scx_rustland_core/assets/bpf/main.bpf.c#L787">one-liner</a>.</p>
<p>All the logic is implemented in the
<code>rustland_update_idle()</code> callback, that is executed when a
CPU changes its idle state:</p>
<pre><code>/*
 * A CPU is about to change its idle state.
 */
void BPF_STRUCT_OPS(rustland_update_idle, s32 cpu, bool idle)
{
    /*
     * Don&#39;t do anything if we exit from and idle state, a CPU owner will
     * be assigned in .running().
     */
    if (!idle)
        return;
    /*
     * A CPU is now available, notify the user-space scheduler that tasks
     * can be dispatched.
     */
    if (usersched_has_pending_tasks()) {
        set_usersched_needed();
        /*
         * Wake up the idle CPU, so that it can immediately accept
         * dispatched tasks.
         */
        if (!low_power || !nr_running)
            scx_bpf_kick_cpu(cpu, 0);
    }
}</code></pre>
<p>In low-power mode the key part is:</p>
<pre><code>...
    if (usersched_has_pending_tasks()) {
...
        /*
         * Wake up the idle CPU, so that it can immediately accept
         * dispatched tasks.
         */
        if (!low_power || !nr_running)
            scx_bpf_kick_cpu(cpu, 0);
    }
...</code></pre>
<p>The variable <code>nr_running</code> keeps track of the active CPUs
and <code>scx_bpf_kick_cpu()</code> is used, in this context, to
immediately wake up a CPU when it enters an idle state.</p>
<p>In general immediately waking up the CPU at this point would be
totally reasonable if there are still tasks that are waiting to be
scheduled (see the <code>usersched_has_pending_tasks()</code> check a
few lines above).</p>
<p>However, in a “low power” scenario we can avoid to immediately wake
up the CPU, if other CPUs are active (<code>nr_running != 0</code>), in
order to maximize the idle state effectiveness and save power at the
cost of throttling CPU-intensive tasks even more.</p>
<h2 id="result">Result</h2>
<p>The benefits of the low-power mode can be illustrated with the
following test case:</p>
<ul>
<li>play a video game (Terraria) while recompiling the kernel</li>
<li>measure game performance (fps) and core power consumption (W)</li>
<li>compare the result of normal mode vs low-power mode</li>
</ul>
<p>Results:</p>
<pre><code>                      Game performance | Power consumption |
         ------------+-----------------+-------------------+
         normal mode |          60 fps |               6W  |
      low-power mode |          60 fps |               3W  |</code></pre>
<p>As we can see from these results, the game performance were pretty
much unaffected by the low-power mode, while the CPU consumption is cut
in half.</p>
<p>Real-world tests showed around 20-30% increase in laptop battery life
using <code>scx_rustland</code> in low-power mode with typical workloads
like reading emails, web browsing, listening to music, and compiling
code.</p>
<h2 id="conclusion">Conclusion</h2>
<p>This experiment highlights the ease and effectiveness of using
<code>sched_ext</code> and <code>scx_rustland</code> for kernel
scheduling development.</p>
<p>The ability to quickly edit-compile-run kernel scheduling changes
represents a significant improvement over traditional methods that
require kernel recompilation and rebooting, with potential for
catastrophic results in case of bugs.</p>
<p>The simplicity of the code change also demonstrates how easy it can
be to implement and test theories aimed at improving performance,
responsiveness, or energy savings. Moreover, operating in user-space
(remember that <code>scx_rustland</code> performs 100% of the scheduling
decisions in user-space) can be particularly advantageous for debugging
and profiling.</p>
<h2 id="future-development">Future development</h2>
<p>While the described technique for energy saving is simple and
effective, there is room for improvement.</p>
<p>For instance, incorporating topology awareness could make the
low-power mode less aggressive in keeping CPUs idle. Avoiding idle
states for CPUs in the same core as an active CPU, for example, could
minimize unnecessary throttling of CPU-intensive tasks while
maintaining, potentially, the same level of energy savings.</p>

</div></div>
  </body>
</html>
