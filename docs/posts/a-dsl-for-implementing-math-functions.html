<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.sigplan.org/2024/06/03/a-dsl-for-implementing-math-functions/">Original</a>
    <h1>A DSL for Implementing Math Functions</h1>
    
    <div id="readability-page-1" class="page"><div>
					<p>Software for physics, geometry, finance, and probability often calls library functions like <code>sin</code>, <code>cos</code>, <code>exp</code>, and <code>log</code>. These library functions should be fast and accurate for science, engineering, and finance to work best.</p>
<p>Unsurprisingly, lots of algorithms have been invented over the years for implementing these math functions, and new algorithms are still being discovered. For example, the RLIBM project—<a href="https://blog.sigplan.org/2022/04/28/one">previously featured on this blog</a>—has developed new tools for deriving approximating polynomials for single-precision functions.</p>
<p>The performance benefits of platform-, language-, and application-specific implementations are large. In some <a href="https://dl.acm.org/doi/10.1145/3519939.3523452">previous work</a>, we saw speedups as large as 5× on microbenchmarks, and 10% on full applications. For this reason, hardware vendors (like NVIDIA and Intel), compiler projects (like GCC and LLVM), and applications (like CERN’s <a href="https://geant4.web.cern.ch/">Geant4</a>) all use custom math libraries specialized for their hardware, language, and application domain.</p>
<p>But writing a platform-, language-, or application-specific math library is error-prone: opaque constants, low-level bit-twiddling, and tricky algebraic transformations abound. Get any wrong, and the resulting function silently returns the wrong result—no crashes or exceptions help narrow down the issue. Even just spot-checking outputs requires numerical sophistication and access to a known-good library.</p>
<p>So <a href="https://dl.acm.org/doi/10.1145/3632874">we created a DSL</a>, MegaLibm, to make writing math function implementations simpler and safer. It’s all thanks to the classic tools of programming language theory: languages, type systems, and compilation.</p>

<p>Typically, math library functions are written in a low-level language like C or raw assembler to maximize performance. But general purpose languages (like these) don’t help developers avoid semantic errors in mathematical code.</p>
<p>How many times has this happened to you: you’re writing some math computation, and you accidentally write a plus sign instead of a minus sign, or put in the wrong constant? Your programming language can’t catch these bugs for you because its types, like <code>float</code> and <code>double</code>, don’t distinguish between <code>x</code> and <code>-x</code> or between different constants.</p>
<p>But numerical code could really benefit from compiler assistance with precisely this task, especially since we expect the user to test out several different implementations of some mathematical expression and compare them for accuracy and performance. Numerical errors really throw a wrench in that process (through misleading performance or accuracy numbers) and MegaLibm therefore aims to prevent them.</p>
<p>It does this through a more stringent type system that tracks the real-valued expression that MegaLibm code is implementing. The main type is <code>Impl&lt;e&gt;</code>, whose members are implementations of the symbolic mathematical expression <code>e</code>. Operators like negation have signatures like <code>Impl&lt;e&gt; -&gt; Impl&lt;-e&gt;</code> where the input and output have different types and can be distinguished. Two expressions that have the same real-number semantics, like <code>(1 - x)*(1 + x)</code> and <code>1 - x*x</code>, have the same type.</p>
<p>To make this more concrete, here’s an example MegaLibm program:</p>
<pre><code>from megalibm import x
e = 1 - x*x/2
e.typecheck() # returns Impl&lt;1 - x*x/2, [-inf, inf]&gt;
</code></pre>
<p>Note that the syntax here looks like Python. It actually is Python; MegaLibm is a DSL embedded in Python making heavy use of operator overloading. Each operation builds up a MegaLibm AST, starting from the MegaLibm variable <code>x</code>, and methods like <code>typecheck</code> operate over that AST. Also note that <code>Impl</code> actually has a second argument, which is the input range for <code>x</code>. The default range is all real numbers, <code>[-inf, inf]</code>.</p>

<p>Of course there’s a downside to reflecting the program source to the type level: we can’t hide implementation details, and thus lose modularity, if every real expression gets a different type. Luckily, that’s not the case: MegaLibm also has an <code>approx</code> function if some computation doesn’t exactly evaluate a given expression.</p>
<p>For example, <code>1 - x*x/2</code> is a passable approximation to <code>cos(x)</code>, at least near 0. The MegaLibm <code>approx</code> function lets us express this:</p>
<pre><code>from megalibm import cos, approx, narrow
p = narrow(1 - x*x/2, [-1e-7, 1e-7])
e = approx(cos(x), 1e-12, p)
e.typecheck() # returns Impl&lt;cos(x), [-1e-7, 1e-7]&gt;
</code></pre>
<p>Here <code>p</code> is the same <code>1 - x*x/2</code> expression as before, except that <code>narrow</code> reduces the input range being considered to <code>[-1e-7, 1e-7]</code>. The <code>approx</code> line then expresses that in evaluating <code>1 - x*x/2</code>, <code>p</code> is approximating <code>cos(x)</code> to an accuracy of <code>1e-12</code>. In other words, <code>approx</code> implements a mathematical function by evaluating something that approximates it, usually a polynomial or rational function.</p>
<p>At the type level, <code>approx</code> behaves like a cast, an escape hatch, sort of like <code>unsafe</code> or <code>Obj.magic</code> in mainstream programming languages. But in MegaLibm it’s also a place where we can plug in additional tools. MegaLibm, for example, can use a verification tool like <a href="https://sollya.org/">Sollya</a> or <a href="https://github.com/soarlab/gelpia">Gelpia</a> to check that the approximation bound actually holds, making this “escape hatch” safe.</p>

<p>This type information helps MegaLibm catch common implementation bugs. For example, consider how the <a href="https://www.netlib.org/fdlibm/">fdlibm library</a> implements the <code>asin</code> function. For small inputs, <code>asin</code> is well approximated by a polynomial. But near ±1, <code>asin</code> has an asymptote, and approximating it by polynomial becomes hard. So fdlibm instead leverages this identity:</p>
<pre><code>asin(x) = pi/2 - 2 asin(sqrt((1-x)/2))
</code></pre>
<p>The genius of this identity is that, if <code>x</code> is between <code>0.5</code> and <code>1</code>, then <code>sqrt((1 - x) / 2)</code> is between <code>0</code> and <code>0.5</code>. So this identity is a kind of “Rosetta’s Stone” that lets us translate <code>asin</code> calls with arguments between <code>0.5</code> and <code>1</code> to <code>asin</code> calls with easier arguments between <code>0</code> and <code>0.5</code>. The C code would look something like this:</p>
<pre><code>double asin(double original_x) {
    double x = original_x &gt; 0.5
      ? sqrt((1 - original_x) / 2)
      : original_x;
    
    double y = /* … compute asin(x) */;
    
    return original_x &gt; 0.5 ? M_PI_2 - 2*y : y;
}
</code></pre>
<p>Tricks like this are common in library function implementations, and are absolutely necessary for some functions like <code>sin</code>. But they’re easy to get wrong. For example, in the <code>asin</code> identity, it’s pretty easy to forget the “multiply by 2” step, which only matters for values close to 0.5.</p>
<p>MegaLibm can catch these kinds of mistakes using types. MegaLibm’s <code>right</code> construct, which captures this pattern of reducing <code>x</code> to a smaller domain and then using the output on that smaller domain to reconstruct the output for the original <code>x</code>, has the following type:</p>
<pre><code>right(
    reduce : Impl&lt;s, I&gt;,
    body : Impl&lt;e, J&gt;,
    reconstruct : Impl&lt;t, K&gt;
) -&gt; Impl&lt;e, I | J&gt;
</code></pre>
<p>Our example would look like this:</p>
<pre><code>from megalibm import x, y, sqrt, pi
p = # …
p.typecheck() # =&gt; Impl&lt;asin(x), [0, 0.5]&gt;
e = right(sqrt(1 - x)/2, p, pi/2 - 2*y)
e.typecheck() # =&gt; Impl&lt;asin(x), [0, 1.0]&gt;
</code></pre>
<p>Here <code>p</code> is only called on inputs in <code>[0, 0.5]</code>, so it can be something like a polynomial approximation, and <code>right</code> wraps that implementation to handle inputs on <code>[0, 1.0]</code>. Importantly, every time you use <code>right</code>, MegaLibm can try to check the identity you’re trying to use, and warn you if it doesn’t check out. Formally, MegaLibm checks this side condition:</p>
<p><img loading="lazy" decoding="async" src="https://blog.sigplan.org/wp-content/uploads/2024/05/Screenshot-2024-05-29-at-1.36.43 PM-1024x48.png" alt="" width="1024" height="48" srcset="https://blog.sigplan.org/wp-content/uploads/2024/05/Screenshot-2024-05-29-at-1.36.43 PM-1024x48.png 1024w, https://blog.sigplan.org/wp-content/uploads/2024/05/Screenshot-2024-05-29-at-1.36.43 PM-300x14.png 300w, https://blog.sigplan.org/wp-content/uploads/2024/05/Screenshot-2024-05-29-at-1.36.43 PM-768x36.png 768w, https://blog.sigplan.org/wp-content/uploads/2024/05/Screenshot-2024-05-29-at-1.36.43 PM-1536x72.png 1536w, https://blog.sigplan.org/wp-content/uploads/2024/05/Screenshot-2024-05-29-at-1.36.43 PM-2048x96.png 2048w, https://blog.sigplan.org/wp-content/uploads/2024/05/Screenshot-2024-05-29-at-1.36.43 PM-1080x51.png 1080w, https://blog.sigplan.org/wp-content/uploads/2024/05/Screenshot-2024-05-29-at-1.36.43 PM-1280x60.png 1280w, https://blog.sigplan.org/wp-content/uploads/2024/05/Screenshot-2024-05-29-at-1.36.43 PM-980x46.png 980w, https://blog.sigplan.org/wp-content/uploads/2024/05/Screenshot-2024-05-29-at-1.36.43 PM-480x23.png 480w" sizes="(max-width: 1024px) 100vw, 1024px"/></p>
<p>You can check these side conditions by invoking MegaLibm’s <code>verify</code> function:</p>
<pre><code>e.verify() # Should not error
</code></pre>
<p>Like with <code>approx</code>, MegaLibm dispatches these side conditions (and a variety of other type checking constraints) to verification tools, including both sound rewrite-based equality checkers and also unsound options like <a href="https://sollya.org/">Sollya</a>’s <code>dirtyinfnorm</code>. (It can even just compare randomly-sampled inputs up to a tolerance.) The unsound tools enable faster iteration, and then a final check can use a sound tool.</p>
<p>Overall, I think MegaLibm’s type system is a good example of taking a complex design problem (range reduction and reconstruction algorithms) and extracting its natural modularity into a type system. That type system can then make the design problem easier to solve and safer as well.</p>

<p>So MegaLibm’s type system helps catch the kinds of typos and errors that make math functions so hard to implement. But how are the resulting functions run?</p>
<p>Naturally, for maximum performance, MegaLibm compiles to a low-level language: C. But compiling to a low-level language reintroduces all the challenges MegaLibm aimed to solve: the developer might now want low-level control over exactly how a polynomial is evaluated or what precision various computations are done in. In C, the need to control all of these factors is exactly why the compiler has to be fairly ignorant of the code itself.</p>
<p>For example, a polynomial <code>a + b x + c x^2 + d x^3</code> can be evaluated in either Horner form:</p>
<pre><code>a + x (b + x (c + x (d)))
</code></pre>
<p>Or in Estrin form:</p>
<pre><code>(a + x b) + x^2 (c + x d)
</code></pre>
<p>The choice matters: Horner form is typically more accurate while Estrin form is typically faster (due to a shorter critical path). For longer polynomials, it’s also possible to mix the two forms (Horner form for the first few terms, and then Estrin for later ones) and to use different precisions for different steps in the evaluation. For MegaLibm to be useful, it has to expose this level of control.</p>
<p>Still, it’s usually best to delay low-level choices like polynomial evaluation until the implementation can be run on real inputs to test various options. So MegaLibm takes inspiration from projects like <a href="https://halide-lang.org/">Halide</a>, which separate the semantics of the language from the semantics of tuning parameters that developers can adjust to maximize performance.</p>
<p>In MegaLibm, the tuning parameters are simple keyword arguments that can be added to MegaLibm constructs. For example, the polynomial above can be defined in MegaLibm with the <code>polynomial</code> shorthand:</p>
<pre><code>from megalibm import polynomial
p = polynomial([a, b, c, d])
</code></pre>
<p>Then to evaluate it in Estrin form (rather than the default Horner form) one would use:</p>
<pre><code>p = polynomial([a, b, c, d], scheme=&#34;estrin&#34;)
</code></pre>
<p>And to evaluate the polynomial in a higher precision, one could pass:</p>
<pre><code>p = polynomial([a, b, c, d], scheme=&#34;estrin&#34;, prec=&#34;fp64&#34;)
</code></pre>
<p>More generally, all of the MegaLibm constructs have these kinds of tuning parameters, which are guaranteed not to affect the real-number semantics (that is, they don’t influence the type system) and can be freely tuned by the developer to tweak accuracy or precision until the implementation is perfect for the developer’s use case.</p>
<p>I think this kind of tunable compilation is a powerful language design primitive for performance-sensitive code. Separating performance tuning from correctness reasoning makes it easier to do both: correctness reasoning can happen at a higher level, and performance tuning can be done fearlessly. Moreover, it supports an iterative, data-driven tuning workflow.</p>

<p>The type system and tuning parameter design ultimately enables an iterative workflow for writing math functions. Developers write an implementation, type check it, and then tune it for accuracy and performance by tweaking tuning parameters. To really make this workflow click, MegaLibm is made for use in Jupyter:</p>
<p><img fetchpriority="high" decoding="async" src="https://blog.sigplan.org/wp-content/uploads/2024/05/Screenshot-2024-05-29-at-1.39.41 PM-1024x567.png" alt="" width="1024" height="567" srcset="https://blog.sigplan.org/wp-content/uploads/2024/05/Screenshot-2024-05-29-at-1.39.41 PM-1024x567.png 1024w, https://blog.sigplan.org/wp-content/uploads/2024/05/Screenshot-2024-05-29-at-1.39.41 PM-300x166.png 300w, https://blog.sigplan.org/wp-content/uploads/2024/05/Screenshot-2024-05-29-at-1.39.41 PM-768x425.png 768w, https://blog.sigplan.org/wp-content/uploads/2024/05/Screenshot-2024-05-29-at-1.39.41 PM-1536x850.png 1536w, https://blog.sigplan.org/wp-content/uploads/2024/05/Screenshot-2024-05-29-at-1.39.41 PM-2048x1133.png 2048w, https://blog.sigplan.org/wp-content/uploads/2024/05/Screenshot-2024-05-29-at-1.39.41 PM-1080x598.png 1080w, https://blog.sigplan.org/wp-content/uploads/2024/05/Screenshot-2024-05-29-at-1.39.41 PM-1280x708.png 1280w, https://blog.sigplan.org/wp-content/uploads/2024/05/Screenshot-2024-05-29-at-1.39.41 PM-980x542.png 980w, https://blog.sigplan.org/wp-content/uploads/2024/05/Screenshot-2024-05-29-at-1.39.41 PM-480x266.png 480w" sizes="(max-width: 1024px) 100vw, 1024px"/></p>
<p>Of course, in one sense any Python library is usable from Jupyter (and Jupyter increasingly supports other languages as well). But MegaLibm makes a specific effort to support the Jupyter workflow.</p>
<p>Part of that is plotting. Any implementation can be run and its accuracy plotted using the <code>plot_lambda</code> function, and two implementations compared with <code>compare_plot_lambda</code>. The Jupyter environment means that the result plot can be shown inline, allowing the developer to test several implementations and record why a specific design decision was made.</p>
<p>Other MegaLibm functions, synthesize polynomials (and even full implementations) with Sollya, also leverage Jupyter’s ability to show synthesis results inline, where they can be copy-and-pasted into a new cell to form a new implementation:</p>
<p><img loading="lazy" decoding="async" src="https://blog.sigplan.org/wp-content/uploads/2024/05/Screenshot-2024-05-29-at-1.39.52 PM-1024x563.png" alt="" width="1024" height="563" srcset="https://blog.sigplan.org/wp-content/uploads/2024/05/Screenshot-2024-05-29-at-1.39.52 PM-1024x563.png 1024w, https://blog.sigplan.org/wp-content/uploads/2024/05/Screenshot-2024-05-29-at-1.39.52 PM-300x165.png 300w, https://blog.sigplan.org/wp-content/uploads/2024/05/Screenshot-2024-05-29-at-1.39.52 PM-768x422.png 768w, https://blog.sigplan.org/wp-content/uploads/2024/05/Screenshot-2024-05-29-at-1.39.52 PM-1536x845.png 1536w, https://blog.sigplan.org/wp-content/uploads/2024/05/Screenshot-2024-05-29-at-1.39.52 PM-2048x1127.png 2048w, https://blog.sigplan.org/wp-content/uploads/2024/05/Screenshot-2024-05-29-at-1.39.52 PM-1080x594.png 1080w, https://blog.sigplan.org/wp-content/uploads/2024/05/Screenshot-2024-05-29-at-1.39.52 PM-1280x704.png 1280w, https://blog.sigplan.org/wp-content/uploads/2024/05/Screenshot-2024-05-29-at-1.39.52 PM-980x539.png 980w, https://blog.sigplan.org/wp-content/uploads/2024/05/Screenshot-2024-05-29-at-1.39.52 PM-480x264.png 480w" sizes="(max-width: 1024px) 100vw, 1024px"/></p>
<p>Jupyter notebooks have proven successful in data science, and MegaLibm is similar in many ways: it, too, involves writing a program iteratively, testing lots of approaches, and paying attention to evaluation results. Jupyter makes that workflow convenient, much more so than the usual mess of bash scripts, shell commands, and copy-and-paste. It also makes it easy to record why specific decisions were made, which helps maintainability.</p>
<p>Using Jupyter as the UI for MegaLibm was an unexpected success, and I plan to try it for future projects. While it’s not as good as a <a href="https://github.com/herbie-fp/odyssey">dedicated user interface for numerical programming</a> might be, it involved almost no additional work and immediately made using MegaLibm easier. Where it required changes to MegaLibm’s APIs, those changes were almost always positive ones.</p>

<p>MegaLibm is a research project, and not directly usable. <a href="https://ianbriggs.dev/">Ian Briggs</a>, who built most of it, recently defended his PhD and joined <a href="https://www.amazon.jobs/content/en/teams/amazon-web-services/annapurna-labs">Annapurna Labs</a>, a part of Amazon. Co-author Yash Lad has also moved on to other pursuits. And some of MegaLibm’s dependencies have already broken compatibility. So the code, which can be <a href="https://github.com/IanBriggs/megalibm">found on Github</a>, is not in good health.</p>
<p>But the real test of a research project is transfer to other projects, and in that sense MegaLibm has already shown results. The Herbie numerical repair tool is investigating using a MegaLibm-like DSL as an IR, thanks to the work of undergraduate <a href="https://github.com/broughjt">Jackson Brough</a> (he’ll be looking for PhD programs soon—get in touch!) and graduate student <a href="https://www.bsaiki.com/">Brett Saiki</a>. MegaLibm-like explicit <code>approx</code> and structured range reduction should help organize and simplify Herbie’s internal passes. And I also hope that MegaLibm’s incremental, iterative design style becomes more widely used in other verification and synthesis tools.</p>
<p><strong>Bio:</strong> <a href="https://pavpanchekha.com/">Pavel Panchekha</a> is an assistant professor at the University of Utah. Besides his research on numerical methods, including maintaining the <a href="https://herbie.uwplse.org/">Herbie numerical assistant</a>, he is also interested in web page layout and <a href="https://browser.engineering/">web browsers more generally</a>. <a href="https://ianbriggs.dev/">Ian Briggs</a> is a Formal Verification Engineer at <a href="https://www.amazon.jobs/content/en/teams/amazon-web-services/annapurna-labs">Annapurna Labs</a> and was the lead researcher on MegaLibm. <a href="https://www.linkedin.com/in/yashladd/">Yash Lad</a> is an MS student at the University of Utah.</p>
<p><strong>Disclaimer:</strong> <em>These posts are written by individual contributors to share their thoughts on the SIGPLAN blog for the benefit of the community. Any views or opinions represented in this blog are personal, belong solely to the blog author and do not represent those of ACM SIGPLAN or its parent organization, ACM.</em></p>
					</div></div>
  </body>
</html>
