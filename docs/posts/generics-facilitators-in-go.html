<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rakyll.org/generics-facilititators/">Original</a>
    <h1>Generics facilitators in Go</h1>
    
    <div id="readability-page-1" class="page"><div>
			<div>
			 	
			  <p><span>Mon, Dec 20, 2021</span></p><p>Go 1.18 is going to be released with <a href="https://go.dev/blog/generics-proposal">generics support</a>. Adding generics to Go was a multi-year effort and was a difficult one. Go <a href="https://rakyll.org/typesystem/">type system</a> is not a traditional type system and it was not possible just to bring an existing generics implementation from other language and be done. The current proposal was accepted after years of user research, experiments and discussions. The proposal got iterated a few times during the implementation phase. I found the final result delightful.</p>
<p>The proposal notes several limitations of the current implementation. When I was first reviewing the proposal a year ago, one limitation stood out the most: <a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md#No-parameterized-methods">no parameterized methods</a>. As someone who has been maintaining various database clients for Go, the limitation initially sounded as a major compromise. I spent a week redesigning our clients based on the new proposal but felt unsatisfied. If you are coming from another language to Go, you might be familiar with the following API pattern:</p>
<pre><code>// NOTE: NOT POSSIBLE TO COMPILE THIS CODE AT THE MOMENT.

db, err := database.Connect(&#34;....&#34;)
if err != nil {
    log.Fatal(err)
}

all, err := db.All[Person](ctx) // Reads all person entities
if err != nil {
    log.Fatal(err)
}
</code></pre><p>Once you open a connection, you can share among entity types by writing generic
methods that have access to the connection. We often see this pattern implemented as generic methods, and not being able to compile the snippet above felt unideal to achieve a similar result.
Being able to write generic method bodies in cases like above are useful for framework
developers to handle boilerplate and common tasks in the framework while keeping
the implementation generic from entity types.</p>
<h2 id="facilitators">Facilitators</h2>
<p>If you are looking into the Go generics for the first time, it may not be
immediately clear at first that the language allows to have parameterized receivers. Parameterized receivers
are a useful tool and helped me develop a common pattern, facilitators, to overcome the shortcomings of having no parameterized methods. Facilitators are simply
a new type that has access to the type you wished you had generic methods on. For example, if you are an ORM framework designer and want to provide
several methods of querying a table, you introduce an intermediate type, Querier, and do the wiring to Client via NewQuerier. Then, Querier allows you to write generic querying functions against types provided by your users. I found it useful to keep the facilitators in the same package to have full access to unexported fields but it’s
not necessarily.</p>
<pre><code>package database

type Client struct{ ... }

type Querier[T any] struct {
	client *Client
}

func NewQuerier[T any](c *Client) *Querier[T] {
	return &amp;Querier[T]{
		client: c,
	}
}

func (q *Querier[T]) All(ctx context.Context) ([]T, error) {
	// implementation
}

func (q *Querier[T]) Filter(ctx context.Context, filter ...Filter) ([]T, error) {
	// implementation
}
</code></pre><p>Later, your users can crete a new querier of any entity type and use
the existing client connection to query the database:</p>
<pre><code>var client *database.Client // initiate

querier := database.NewQuerier[Person](client)
all, err := querier.All(ctx)
if err != nil {
    log.Fatal(err)
}

for _, person := range all {
    log.Println(person)
}
</code></pre><p>Facilitators make the limitation of having no generic methods disappear and
they add only a tiny bit of verbosity.There is nothing novel about this pattern but it needs a name for those who don’t know how to use parameterized receivers to achieve the same.</p>
<p>A playground is <a href="https://go.dev/play/p/junNJF4p-dF?v=gotip">available</a> in case you want to try it out.</p>

			</div>

			

			

		</div></div>
  </body>
</html>
