<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/tlack/atree">Original</a>
    <h1>Atree: A simple and efficient pointer-free tree implementation</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto">Apter Trees are a simpler representation of trees using just two vectors: <code>[nodevalues, parentindices]</code>.</p>
<p dir="auto">This repo contains a tree-like data type implemented in C++17, in the style of Stevan Apter in
<a href="http://archive.vector.org.uk/art10500340" rel="nofollow">Treetable: a case-study in q</a>.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-who-cares" aria-hidden="true" tabindex="-1" href="#who-cares"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Who cares?</h2>
<p dir="auto">A tree is a data structure in which values have parent-child relationships to
each other. They come in many forms.</p>
<p dir="auto">In most software, trees are implemented like a typical binary tree, where each
node contains its own data and a pointer to each of its children, nominally just
left and right, which are also nodes. The cycle continues.</p>
<p dir="auto">Using such a data structure can be challenging due to recursion and slow due to
cache behavior in modern systems and frequent malloc()s. The concept of who
&#34;owns&#34; a tree node in such a system can become complex in multi-layered
software.</p>
<p dir="auto">Apter Trees are much faster, easier to reason about, and easier to implement.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-how-it-works" aria-hidden="true" tabindex="-1" href="#how-it-works"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>How it works</h2>
<p dir="auto">An Apter tree is implemented as two same-sized arrays.</p>
<p dir="auto">One is a vector (array) of data (we&#39;ll call it <code>d</code>). These correspond to the
values, or things that each node contains.</p>
<p dir="auto">The other is a vector of parent indices (<code>p</code>). The index of an item in the <code>d</code>
vector is used as its key, which we will call <code>c</code> in the examples below.</p>
<p dir="auto">Often, the key/index <code>c</code> will just be an int.</p>
<p dir="auto">So, if we had a dog family tree in which Coco was the father of Molly and Arca,
and Arca had a son named Cricket, you might have a data structure like:</p>
<div data-snippet-clipboard-copy-content="	tree.d = [&#34;Coco&#34;, &#34;Molly&#34;, &#34;Arca&#34;,&#34;Cricket&#34;]
	tree.p = [0,0,0,2]"><pre><code>	tree.d = [&#34;Coco&#34;, &#34;Molly&#34;, &#34;Arca&#34;,&#34;Cricket&#34;]
	tree.p = [0,0,0,2]
</code></pre></div>
<p dir="auto">A node with a key of <code>0</code> whose parent is zero is the root node. Apter trees
require a root node, or the use of <code>-1</code> to mean &#34;no parent&#34;, which is slightly
less elegant so I&#39;ll ignore it.</p>
<p dir="auto">Computers are very, very fast at manipulating vectors. They&#39;re so much faster
than pointer operations that comparisons of big-O notation for an algorithm
don&#39;t play out in practice.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-operations-in-psuedocode" aria-hidden="true" tabindex="-1" href="#operations-in-psuedocode"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Operations in psuedocode</h2>
<p dir="auto">The technique is applicable in all languages.  This library is written in C++
but I will use psuedocode to explain how it works.</p>
<ul dir="auto">
<li>Empty tree</li>
</ul>
<div data-snippet-clipboard-copy-content="tree() = { {d:[], p:[]} }       # some sort of [data,parentidxs] vector"><pre><code>tree() = { {d:[], p:[]} }       # some sort of [data,parentidxs] vector
</code></pre></div>
<ul dir="auto">
<li>Number of nodes</li>
</ul>
<div data-snippet-clipboard-copy-content="nodecnt(t) = { len(t.p) }"><pre><code>nodecnt(t) = { len(t.p) }
</code></pre></div>
<ul dir="auto">
<li>Keys of all nodes</li>
</ul>
<div data-snippet-clipboard-copy-content="join(x,y) = { flatten(x,y) }    # append to vec. i.e., x.push_back(y), x[]=y, etc.
range(x,y) = { # Q til, APL/C++ iota; return [x, x+1, x+2, ...y-1]
	i=x; ret=[]; while(i++&lt;y) ret=join(ret,i); return ret
}
keys(t) = { range(0, nodecnt(t)) }"><pre><code>join(x,y) = { flatten(x,y) }    # append to vec. i.e., x.push_back(y), x[]=y, etc.
range(x,y) = { # Q til, APL/C++ iota; return [x, x+1, x+2, ...y-1]
	i=x; ret=[]; while(i++&lt;y) ret=join(ret,i); return ret
}
keys(t) = { range(0, nodecnt(t)) }
</code></pre></div>
<ul dir="auto">
<li>Add an item to the tree:</li>
</ul>
<div data-snippet-clipboard-copy-content="insert(t, val, parentidx) = {
	t.d = join(t.d,val)
	t.p = join(t.p,parentidx)
}"><pre><code>insert(t, val, parentidx) = {
	t.d = join(t.d,val)
	t.p = join(t.p,parentidx)
}
</code></pre></div>
<ul dir="auto">
<li>Determine parent of a given node:</li>
</ul>
<p dir="auto">Remember, we use the numeric index of a node (<code>childidx</code>) as its identifier:</p>
<div data-snippet-clipboard-copy-content="parentof(t,childidx) = { t.p[childidx] }"><pre><code>parentof(t,childidx) = { t.p[childidx] }
</code></pre></div>
<ul dir="auto">
<li>Retrieve value of node:</li>
</ul>
<p dir="auto">We&#39;ll use <code>c</code> instead of <code>childidx</code>, from here on out.</p>

<ul dir="auto">
<li>Scan for keys that have a given value:</li>
</ul>
<div data-snippet-clipboard-copy-content="where(vec,val) = { # return indices of vec that contain val
	matches=[]
	for idx,v in vec: if(v==val, {matches=join(matches,idx)})
	return matches
}
search(t,val) = { where(t.d,val) }"><pre><code>where(vec,val) = { # return indices of vec that contain val
	matches=[]
	for idx,v in vec: if(v==val, {matches=join(matches,idx)})
	return matches
}
search(t,val) = { where(t.d,val) }
</code></pre></div>
<ul dir="auto">
<li>Determine children of a node:</li>
</ul>
<div data-snippet-clipboard-copy-content="childnodes(t,c) = { where(t.p,c) }"><pre><code>childnodes(t,c) = { where(t.p,c) }
</code></pre></div>
<ul dir="auto">
<li>Retrieve child nodes&#39; values</li>
</ul>
<div data-snippet-clipboard-copy-content="# We&#39;re assuming you can index with a vector; otherwise loop required
childdata(t,c) = { data(childnodes(c)) }"><pre><code># We&#39;re assuming you can index with a vector; otherwise loop required
childdata(t,c) = { data(childnodes(c)) }
</code></pre></div>
<ul dir="auto">
<li>Determine leaf nodes (those with no children):</li>
</ul>
<p dir="auto">First, build a vector of all the indices. Then remove those indices that are
also in <code>p</code>. The psuedocode below is a slow implementation; should be done as a
single loop.</p>
<div data-snippet-clipboard-copy-content="except(x,y) = { # return elements of x except those in y. set subtraction
	ret=[]; 
	for idx,xx in x: if(!xx in y, {ret=join(ret,xx)}); 
	return ret;
}
leaves(t) = { except(keys(t), t.p) }"><pre><code>except(x,y) = { # return elements of x except those in y. set subtraction
	ret=[]; 
	for idx,xx in x: if(!xx in y, {ret=join(ret,xx)}); 
	return ret;
}
leaves(t) = { except(keys(t), t.p) }
</code></pre></div>
<ul dir="auto">
<li>Determine vector of parents for a given node, or path to node:</li>
</ul>
<p dir="auto">Here we keep going up the tree until we can&#39;t go any further (ends at 0). When node zero&#39;s
parent is zero, we know we&#39;ve reached the root node - that the &#34;checking last value&#34; trick
works. We call this form of iteration <code>exhaust</code>. It&#39;s called <code>scan</code> in K and Q.</p>
<p dir="auto">We reverse the result so that it is in <code>parentA.parentB.parentC.child</code> order.</p>
<div data-snippet-clipboard-copy-content="exhaust(vec,start) = {
	ret=[]; last=x=start
	do {
		last=x
		ret=join(ret,x)
		x=vec[x]
	} until x==last
	return ret
}
parentnodes(t,c) = { reverse(exhaust(t.p, c) }"><pre><code>exhaust(vec,start) = {
	ret=[]; last=x=start
	do {
		last=x
		ret=join(ret,x)
		x=vec[x]
	} until x==last
	return ret
}
parentnodes(t,c) = { reverse(exhaust(t.p, c) }
</code></pre></div>
<ul dir="auto">
<li>Determine data for path through tree (i.e., all parents of a node)</li>
</ul>
<div data-snippet-clipboard-copy-content="parentdata(t,c) = { data(parentnodes(t,c)) }"><pre><code>parentdata(t,c) = { data(parentnodes(t,c)) }
</code></pre></div>
<ul dir="auto">
<li>In order traversal</li>
</ul>
<p dir="auto">The simplest way is to get the list of leaves, and then determine the path to each. We finally
sort those vectors.</p>
<p dir="auto">I believe there is a simpler way that can work in a single pass, or at least a single pass
with a sufficiently large stack. I&#39;m still exploring this idea. Let me know if you have any
suggestions.</p>
<p dir="auto">We&#39;re assuming a fairly flexible sort function here which can handle sorting vectors of vectors.</p>
<div data-snippet-clipboard-copy-content="all(t) = { sort(each(leaves(t), (c){ parent(t, c) })) }"><pre><code>all(t) = { sort(each(leaves(t), (c){ parent(t, c) })) }
</code></pre></div>
<ul dir="auto">
<li>Delete item</li>
</ul>
<p dir="auto">This can vary depending on your application. A sentinel value like <code>MAXINT</code> in
the parent column is probably easiest. Some systems uses <code>-1</code> to represent an
empty node if you can spare the sign bit.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-again-who-cares-unfounded-editorializing" aria-hidden="true" tabindex="-1" href="#again-who-cares-unfounded-editorializing"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Again, who cares? (Unfounded editorializing)</h2>
<p dir="auto">I think this is the most elegant implementation style of trees I&#39;ve seen.</p>
<p dir="auto">Given the right vector operations library, it&#39;s by far the shortest, which
means you can easily understand it, find bugs in it.</p>
<p dir="auto">Given the simplicity, it&#39;s easy to adapt for other usage scenarios. For
instance, you could maintain a third index of keys to create low overhead
sorted order for data.</p>
<p dir="auto">You can ignore the parent index vector and iterate
quickly through the values if you are searching for something, which is like a
deep map, for free. You can remap all parent-child relatioships in one go. You
can build a serialized version instantly or transmit it over a network without
iteration. It&#39;s GPU friendly. It&#39;s easy to use in an embedded context. It&#39;s
secure because you can easily impose boundaries (by not allowing the vectors
to grow beyond a certain size).</p>
<p dir="auto">Given common sense it&#39;s also the fastest. There&#39;s very little memory overhead,
and in many cases, access will be linear. Intermediate values and recursion is
minimized. Computers are great at handling ints cuz that&#39;s what the benchmarks
do.</p>
<p dir="auto">Pointers are annoying anyway.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-origins" aria-hidden="true" tabindex="-1" href="#origins"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Origins</h2>
<p dir="auto">I&#39;ve been lazily trying to figure out who invented this technique. It&#39;s so
obvious I would imagine it must have had a name during the vector-oriented 60s
and 70s.</p>
<p dir="auto">The first full explanation I saw was from Apter as explained above, but it was
also documented widely as early as K3. Here&#39;s a version in Q:</p>
<div data-snippet-clipboard-copy-content="/ nested directory: use a parent vector, e.g.
/ a
/ b
/  c
/   d
/  e
p:0N 0N 1 2 1 / parent
n:`a`b`c`d`e  / name
c:group p     / children
n p scan 3    / full path"><pre><code>/ nested directory: use a parent vector, e.g.
/ a
/ b
/  c
/   d
/  e
p:0N 0N 1 2 1 / parent
n:`a`b`c`d`e  / name
c:group p     / children
n p scan 3    / full path
</code></pre></div>
<p dir="auto">I must have read that a hundred times before I internalized its genius.  <a href="https://a.kx.com/q/tree.q" rel="nofollow">See
four other ways to represent trees in K</a> each in
about three lines of code.</p>
<p dir="auto">APL, or at least Dyalog, seems to implement trees in a more traditional way,
using nested boxes: <a href="https://dfns.dyalog.com/n_BST.htm" rel="nofollow">see here for more</a>.
They do however use a <a href="https://dfns.dyalog.com/n_Graphs.htm" rel="nofollow">similar technique for vector
graphs</a>.</p>
<p dir="auto">It appears to be known to J users as seen in <a href="https://rosettacode.org/wiki/Tree_traversal#J:_Alternate_implementation" rel="nofollow">Rosetta Code&#39;s tree
implementation in
J</a>
(with some illuminating comments).</p>
<p dir="auto">John Earnest goes into [much more detail about vector tree implementations]
(<a href="https://github.com/JohnEarnest/ok/blob/gh-pages/docs/Trees.md">https://github.com/JohnEarnest/ok/blob/gh-pages/docs/Trees.md</a>), including the
&#34;index of offsets&#34; approach to deleting entries. Worth a read.</p>
<p dir="auto">A more elaborate approach is to also track the depth of each item. <a href="http://dl.acm.org/citation.cfm?id=2935331" rel="nofollow">Details about
that approach</a> can be found in Aaron
W. Hsu&#39;s paper on the subject.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-other-common-tree-implementations" aria-hidden="true" tabindex="-1" href="#other-common-tree-implementations"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Other common tree implementations</h2>
<p dir="auto">Here are some other well known trees.</p>
<p dir="auto">None of these do the same thing as an Apter tree, and some are far larger due
to generalizations, but it&#39;s still interesting to consider how much code
different styles of trees requires to do simple operations.</p>
<ul dir="auto">
<li>
<p dir="auto"><a href="https://svnweb.freebsd.org/base/head/sys/sys/tree.h?revision=277642&amp;view=markup" rel="nofollow">FreeBSD&#39;s kernel tree implementation</a></p>
</li>
<li>
<p dir="auto"><a href="https://github.com/attractivechaos/klib/blob/master/kbtree.h">klib&#39;s tree</a></p>
</li>
<li>
<p dir="auto"><a href="https://github.com/ealdent/simple-tree/blob/master/lib/simple_tree.rb">a tree class in Ruby</a></p>
</li>
<li>
<p dir="auto"><a href="https://github.com/ShuaiW/Python/blob/master/POC/Tree.py">Python declarative tree class</a></p>
</li>
</ul>
<h2 tabindex="-1" dir="auto"><a id="user-content-status-of-this-code" aria-hidden="true" tabindex="-1" href="#status-of-this-code"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Status of this code</h2>
<p dir="auto">I&#39;ve made a sorta lazy attempt at implementing this in C++ as a way to learn C++17. Not really ready
for use or fully fleshed out. I still have a lot to learn about C++.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-thanks" aria-hidden="true" tabindex="-1" href="#thanks"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Thanks</h2>
<p dir="auto">Arthur Whitney, Apter, others: inspiration.</p>
<p dir="auto">John Earnest: source materials</p>
<p dir="auto">Dave Linn: proof reading.</p>
</article>
          </div></div>
  </body>
</html>
