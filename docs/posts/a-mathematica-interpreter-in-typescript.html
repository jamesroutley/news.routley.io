<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.spakhm.com/ts-wolfram">Original</a>
    <h1>A Mathematica interpreter in Typescript</h1>
    
    <div id="readability-page-1" class="page">
  <ul id="nav">
    <li><a href="https://www.spakhm.com/">home</a></li>
    <li id="subscribe">subscribe → <a href="https://www.spakhm.com/feed.rss">rss</a> | <a href="https://www.spakhm.com/subscribe.html">email</a></li>  
  </ul>
  
    
<p><strong>Try it on GitHub:</strong> <a href="https://github.com/coffeemug/ts-wolfram">https://github.com/coffeemug/ts-wolfram</a></p>
<p>I’ve been using Mathematica to help with learning math (and using math to help learn Mathematica). Too often my Mathematica code has surprising behavior, which means I don’t <em>really</em> understand the language or how it’s evaluated. So I thought I’d do two things to get better.</p>
<p>First, write a bunch of Mathematica rules to implement a toy symbolic differentiation operator. Second, write a toy Mathematica interpreter in Typescript that’s good enough to correctly run my custom differentiation code.</p>
<h2 id="toy-differentiation">Toy differentiation</h2>
<p>Writing a toy differentiator turns out to be shockingly easy. It’s a near verbatim transcription of differentiation rules from any calculus textbook:</p>
<pre><code><span>D</span><span>[</span><span>_</span><span>?</span><span>NumberQ</span><span>,</span> <span>x_Symbol</span><span>]</span> <span>=</span> <span>0</span><span>;</span>
<span>D</span><span>[</span><span>x_</span><span>,</span> <span>x_Symbol</span><span>]</span> <span>=</span> <span>1</span><span>;</span>
<span>D</span><span>[</span><span>Times</span><span>[</span><span>expr1_</span><span>,</span> <span>expr2_</span><span>]</span><span>,</span> <span>x_Symbol</span><span>]</span> <span>=</span>
  <span>D</span><span>[</span><span>expr1</span><span>,</span> <span>x</span><span>]</span> <span>expr2</span> <span>+</span> <span>D</span><span>[</span><span>expr2</span><span>,</span> <span>x</span><span>]</span> <span>expr1</span><span>;</span>
<span>D</span><span>[</span><span>Plus</span><span>[</span><span>expr1_</span><span>,</span> <span>expr2_</span><span>]</span><span>,</span> <span>x_Symbol</span><span>]</span> <span>=</span> <span>D</span><span>[</span><span>expr1</span><span>,</span> <span>x</span><span>]</span> <span>+</span> <span>D</span><span>[</span><span>expr2</span><span>,</span> <span>x</span><span>]</span><span>;</span>
<span>D</span><span>[</span><span>Sin</span><span>[</span><span>x_</span><span>]</span><span>,</span> <span>x_Symbol</span><span>]</span> <span>=</span> <span>Cos</span><span>[</span><span>x</span><span>]</span><span>;</span>
<span>D</span><span>[</span><span>Cos</span><span>[</span><span>x_</span><span>]</span><span>,</span> <span>x_Symbol</span><span>]</span> <span>=</span> <span>-</span><span>Sin</span><span>[</span><span>x</span><span>]</span><span>;</span>
<span>D</span><span>[</span><span>f_Symbol</span><span>[</span><span>expr_</span><span>]</span><span>,</span> <span>x_Symbol</span><span>]</span> <span>:=</span>
  <span>(</span><span>D</span><span>[</span><span>f</span><span>[</span><span>x</span><span>]</span><span>,</span> <span>x</span><span>]</span> <span>/.</span> <span>x</span> <span>-&gt;</span> <span>expr</span><span>)</span> <span>*</span> <span>D</span><span>[</span><span>expr</span><span>,</span> <span>x</span><span>]</span><span>;</span>
<span>D</span><span>[</span><span>Power</span><span>[</span><span>expr_</span><span>,</span> <span>p_Integer</span><span>]</span><span>,</span> <span>x_Symbol</span><span>]</span> <span>:=</span> <span>p</span> <span>expr</span><span>^</span><span>(</span><span>p</span> <span>-</span> <span>1</span><span>)</span> <span>*</span> <span>D</span><span>[</span><span>expr</span><span>,</span> <span>x</span><span>]</span><span>;</span></code></pre>
<p>My first implementation had three more rules (one for each of <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><msup><mi>x</mi><mi>k</mi></msup><mi mathvariant="normal">/</mi><mi>d</mi><mi>x</mi><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>c</mi><mo>⋅</mo><mi>f</mi><msup><mo stretchy="false">)</mo><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dx^k/dx, (cf)’(x)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>d</span><span><span>x</span><span><span><span><span><span><span></span><span><span>k</span></span></span></span></span></span></span></span><span>/</span><span>d</span><span>x</span><span>,</span><span></span><span>(</span><span>c</span><span></span><span>⋅</span><span></span></span><span><span></span><span>f</span><span><span>)</span><span><span><span><span><span><span></span><span><span><span>′</span></span></span></span></span></span></span></span></span><span>(</span><span>x</span><span>)</span></span></span></span>, and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>f</mi><msup><mo stretchy="false">)</mo><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1/f)’(x)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>(</span><span>1/</span><span>f</span><span><span>)</span><span><span><span><span><span><span></span><span><span><span>′</span></span></span></span></span></span></span></span></span><span>(</span><span>x</span><span>)</span></span></span></span>), which I later realized you don’t need. These are shortcuts for human differentiators, but they’re automagically covered by the multiplication and exponentiation rules above.</p>
<p>Some problems I encountered while writing these rules: infinite recursion, rules not matching, and rules matching but evaluating to a surprising result. The hobby edition of Mathematica has <em>some</em> tools for debugging these problems, but not much. Ultimately I fixed bad rules by staring at the code and thinking really hard. I found <code>Trace</code> impossible to read, and <code>TracePrint</code> (which is supposed to be better) not much better. Also <code>MatchQ</code> is good, but somehow not as useful for debugging as I would have liked.</p>
<h2 id="toy-interpreter">Toy interpreter</h2>
<p>I first implemented basic parsing of integers, symbols, forms, and arithmetic operators using <a href="https://www.spakhm.com/ts-parsec">ts-parsec</a> (which I wrote for this project). In Mathematica <code>a 2 b 3</code> evaluates to <code>Times[6, a, b]</code> because <code>Times</code> has a <code>Flat</code> attribute. To get this behavior I implemented attributes next– <code>Flat</code>, and also <code>HoldFirst</code>, <code>HoldRest</code>, and <code>HoldAll</code> which I’d eventually need. I also exposed <code>Attributes</code>, <code>SetAttributes</code>, and <code>ClearAttributes</code>. These all accept (and <code>Attributes</code> returns) lists, so I added those too. All this was easy enough.</p>
<p>I wanted to implement assignment next so I could say <code>a = 1</code>. In Mathematica even something this simple is implemented by adding <code>RuleDelayed[HoldPattern[a], 1]</code> to <code>OwnValues</code>.<a href="#footnote-1J44" id="ref-1J44" role="doc-noteref"><sup>1</sup></a> So the next step was to build the skeleton of a term rewriting system.<a href="#footnote-2J44" id="ref-2J44" role="doc-noteref"><sup>2</sup></a> I first implemented a version of <code>MatchQ</code> that does a deep equal, extended it to handle <code>Blank[]</code>, extended it again to handle <code>Blank[...]</code>, and extended it <em>again</em> to handle <code>Pattern[foo, Blank[...]]</code>. The version exposed to the interpreter returns <code>True</code> or <code>False</code>, but under the hood it also returns an environment with matched variables. I built on that next to implement term rewriting.</p>
<p>A really simple rewrite rule is <code>f[1] /. f[x_] :&gt; x + 1</code>. In Mathematica this parses to</p>
<pre><code><span>ReplaceAll</span><span>[</span><span>f</span><span>[</span><span>1</span><span>]</span><span>,</span> <span>RuleDelayed</span><span>[</span><span>f</span><span>[</span><span>Pattern</span><span>[</span><span>x</span><span>,</span> <span>Blank</span><span>[</span><span>]</span><span>]</span><span>]</span><span>,</span> <span>Plus</span><span>[</span><span>x</span><span>,</span> <span>1</span><span>]</span><span>]</span><span>]</span></code></pre>
<p>With my <code>MatchQ</code> implementation there was now enough machinery to get this working. I added operators <code>/.</code> and <code>:&gt;</code> to the grammar, implemented <code>Replace</code>, and built <code>ReplaceAll</code> on top. I tested a bunch of rewrite rules and they all worked! From here it was also easy to add <code>-&gt;</code> and <code>//.</code> which I did next.</p>
<p>I had enough machinery to implement assignment. I added <code>Set</code> and <code>SetDelayed</code>, and modified evaluation to apply the rules stored in <code>OwnValues</code> and <code>DownValues</code>. This let me assign values to symbols and define functions! I could now run code like this:</p>
<pre><code><span>fib</span><span>[</span><span>1</span><span>]</span> <span>:=</span> <span>1</span>
<span>fib</span><span>[</span><span>2</span><span>]</span> <span>:=</span> <span>1</span>
<span>fib</span><span>[</span><span>x_</span><span>]</span> <span>:=</span> <span>fib</span><span>[</span><span>x</span><span>-</span><span>2</span><span>]</span> <span>+</span> <span>fib</span><span>[</span><span>x</span><span>-</span><span>1</span><span>]</span></code></pre>
<p>One caveat is that Mathematica inserts rules into value lists in order of specificity, so specific rules are tried before general rules. I initially added rules in order of definition to get assignment working, <del>but then went back and added a simple specificity ordering function</del><a href="#footnote-3J44" id="ref-3J44" role="doc-noteref"><sup>3</sup></a>.</p>
<p><strong><span>EDIT</span>:</strong> I wrote specificity ordering code at late at night, and just realized it was completely broken. I removed it; rules are now processed in the order they’re entered. But everything else still works!</p>
<p>Finally, I added support for <code>PatternTest</code>/<code>?</code> and <code>NumberQ</code>. These were all the features needed to do differentiation!</p>
<h2 id="differentiating-in-ts-wolfram">Differentiating in <code>ts-wolfram</code></h2>
<p>I ran <code>D</code> in <code>ts-wolfram</code> on the following examples, and cross-checked with the results in Mathematica:</p>
<pre><code><span>D</span><span>[</span><span>1</span><span>,</span> <span>x</span><span>]</span>
<span>D</span><span>[</span><span>x</span><span>,</span> <span>x</span><span>]</span>
<span>D</span><span>[</span><span>x</span><span>^</span><span>5</span><span>,</span> <span>x</span><span>]</span>
<span>D</span><span>[</span><span>3</span> <span>x</span><span>^</span><span>2</span><span>,</span> <span>x</span><span>]</span>
<span>D</span><span>[</span><span>(</span><span>x</span> <span>+</span> <span>1</span><span>)</span> <span>(</span><span>x</span> <span>+</span> <span>2</span><span>)</span><span>,</span> <span>x</span><span>]</span>
<span>D</span><span>[</span><span>x</span><span>^</span><span>2</span> <span>+</span> <span>x</span><span>^</span><span>3</span><span>,</span> <span>x</span><span>]</span>
<span>D</span><span>[</span><span>Cos</span><span>[</span><span>x</span><span>]</span><span>,</span> <span>x</span><span>]</span>
<span>D</span><span>[</span><span>x</span><span>^</span><span>3</span><span>/</span><span>(</span><span>x</span><span>^</span><span>2</span> <span>+</span> <span>1</span><span>)</span><span>,</span> <span>x</span><span>]</span>
<span>D</span><span>[</span><span>Cos</span><span>[</span><span>Cos</span><span>[</span><span>x</span><span>]</span><span>]</span><span>,</span> <span>x</span><span>]</span>
<span>D</span><span>[</span><span>Cos</span><span>[</span><span>Cos</span><span>[</span><span>Cos</span><span>[</span><span>x</span><span>]</span><span>]</span><span>]</span><span>,</span> <span>x</span><span>]</span>
<span>D</span><span>[</span><span>Cos</span><span>[</span><span>x</span><span>^</span><span>2</span> <span>+</span> <span>1</span><span>]</span><span>,</span> <span>x</span><span>]</span>
<span>D</span><span>[</span><span>(</span><span>x</span> <span>+</span> <span>1</span><span>)</span><span>^</span><span>2</span><span>,</span> <span>x</span><span>]</span></code></pre>
<p>Somewhat miraculously, <code>ts-wolfram</code> got correct results on every test! Since I didn’t add any manipulation to simplify expressions, the results weren’t <em>exactly</em> the same. For example:</p>
<pre><code><span>D</span><span>[</span><span>Cos</span><span>[</span><span>Cos</span><span>[</span><span>x</span><span>]</span><span>]</span><span>,</span> <span>x</span><span>]</span> 


<span>Times</span><span>[</span><span>Minus</span><span>[</span><span>Sin</span><span>[</span><span>Cos</span><span>[</span><span>x</span><span>]</span><span>]</span><span>]</span><span>,</span> <span>Minus</span><span>[</span><span>Sin</span><span>[</span><span>x</span><span>]</span><span>]</span><span>]</span>


<span>Times</span><span>[</span><span>Sin</span><span>[</span><span>x</span><span>]</span><span>,</span> <span>Sin</span><span>[</span><span>Cos</span><span>[</span><span>x</span><span>]</span><span>]</span><span>]</span></code></pre>
<p>This would be easy to fix by adding the rule <code>Times[Minus[x_], Minus[y_]]=x y</code>, but (a) <code>Times</code> is implemented in typescript, and the interpreter doesn’t currently support mixing kernel and userspace rules, and (b) extending the system to simplify algebraic expressions feels like a different undertaking.</p>
<p>Overall, this has been a really fun and instructive project. I built it in four days hacking on it after work, and learned a great deal about Mathematica internals. Of course this is still only scratching the surface, but now I feel a lot less lost when Mathematica doesn’t behave the way I expect. I’m very happy with this outcome!</p>


  <p>
Oct 17, 2024  </p>





</div>
  </body>
</html>
