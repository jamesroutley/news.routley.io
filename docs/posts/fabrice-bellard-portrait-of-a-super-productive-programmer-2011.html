<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://smartbear.com/blog/fabrice-bellard-portrait-of-a-super-productive-pro/">Original</a>
    <h1>Fabrice Bellard: Portrait of a Super-Productive Programmer (2011)</h1>
    
    <div id="readability-page-1" class="page"><div>
                    <p><em>Hollywood portrayals of computing superstars are more rooted in comic-book super-heroics than the realities of software development. Except that in programming, superpowers do exist. Fabrice Bellard has them.</em></p><p>Computing in the movies is hard to recognize: Typographical errors are non-existent, crackers break through tested defenses in seconds, and practitioners create twenty-function-point programs in fewer keystrokes than the count of bullets whizzing by their heads. <a title="Hollywood portrayals" href="http://www.softwarequalityconnection.com/2011/01/fear-of-geeks/" target="_blank" rel="noopener noreferrer">Hollywood portrayals</a> are more rooted in comic-book superheroics than the realities of software development.</p><p>Except that in programming, superpowers <em>do</em> exist. <a title="Fabrice Bellard" href="http://bellard.org" target="_blank" rel="noopener noreferrer">Fabrice Bellard</a> has them.</p><h3>Serial achiever</h3><p>What other description can there be when one man successively produces a dozen important and widely-used software applications? Look at the (partial) record:</p><ul><li><strong>1989:</strong> <a title="LZEXE" href="http://bellard.org/lzexe.html" target="_blank" rel="noopener noreferrer">LZEXE</a></li></ul><ul><li><strong>1996:</strong> <a title="Harissa" href="http://web.archive.org/web/19990117093837/http:/www.irisa.fr/compose/harissa/harissa.html" target="_blank" rel="noopener noreferrer">Harissa</a></li></ul><ul><li><strong>1997:</strong> Publication of <a title="Bellard’s formula" href="http://en.wikipedia.org/wiki/Bellard%27s_formula" target="_blank" rel="noopener noreferrer">Bellard’s formula</a> for computation of digits of pi</li></ul><ul><li><strong>1999:</strong> <a title="Linmodem" href="http://bellard.org/linmodem.html" target="_blank" rel="noopener noreferrer">Linmodem</a></li></ul><ul><li><strong>2000:</strong> <a title="Calculation of the largest-known prime" href="http://bellard.org/mersenne.html" target="_blank" rel="noopener noreferrer">Calculation of the largest-known prime</a>. (Make sure you read this one—the source code is only 438 bytes long.)</li></ul><ul><li><strong>2000:</strong> <a title="FFmpeg" href="http://ffmpeg.org/" target="_blank" rel="noopener noreferrer">FFmpeg</a></li></ul><ul><li><strong>2001:</strong> A <a title="self-compiling compiler" href="http://bellard.org/tcc/" target="_blank" rel="noopener noreferrer">self-compiling compiler</a> of a subset of C that fits in 3 kilobytes of memory</li></ul><ul><li><strong>2002:</strong> <a title="TinyGL" href="http://bellard.org/TinyGL/" target="_blank" rel="noopener noreferrer">TinyGL</a></li></ul><ul><li><strong>2002:</strong> <a title="QEmacs" href="http://bellard.org/qemacs/" target="_blank" rel="noopener noreferrer">QEmacs</a></li></ul><ul><li><strong>2003:</strong> <a title="QEMU" href="http://wiki.qemu.org/Main_Page" target="_blank" rel="noopener noreferrer">QEMU</a></li></ul><ul><li><strong>2004:</strong> <a title="TinyCC Boot Loader" href="http://bellard.org/tcc/tccboot.html" target="_blank" rel="noopener noreferrer">TinyCC Boot Loader</a></li></ul><ul><li><strong>2005:</strong> <a title="DVB-T computer-hosted transmitter" href="http://bellard.org/dvbt/" target="_blank" rel="noopener noreferrer">DVB-T computer-hosted transmitter</a></li></ul><ul><li><strong>2009:</strong> <a title="et world record for calculation of the digits of pi" href="http://bellard.org/pi/pi2700e9/" target="_blank" rel="noopener noreferrer">et world record for calculation of the digits of pi</a></li></ul><p>Every one of these would be a proud accomplishment in any programming career. To produce so many, and so consistently, is very, very rare.</p><p>A bit of background provides the context to understand this record clearly. It’s common in programming folklore to talk about how a particular program was pulled together in one intense weekend, or during a vacation interval. Many of these tales are true, as far as they go; several of the best-known programs <em>were</em> first launched with a specific effort of just a few days. This leads some to expect that those few days define the life cycle of program development: A sufficiently clever programmer can create the <a title="What Wayland Means for Developers" href="http://blog.smartbear.com/software-quality/bid/241134/What-Wayland-Means-for-Developers" target="_blank" rel="noopener noreferrer">Linux</a> kernel this holiday season, take the next weekend off to invent the Ruby programming language, build an award-winning iPad game the following month, and so on.</p><p>It’s not so. Just because top sprinters finish a hundred meters in under ten seconds doesn’t mean they sustain that pace for the duration of a marathon. When Bellard wrote LZEXE, for example, he created a program that performed the data compression he needed at one particular time (it was the first widely-used executable file compressor for MS-DOS).</p><p>What’s notable is that he also invested the follow-up effort to ensure the software was engineered well-enough to work on other computers and on multiple operating systems, could be understood and maintained by others, was adequately documented, licensed to be useful, and so on. All those apparently secondary activities typically  take orders of magnitude more time than the original coding at the heart of a successful program.</p><p>Bellard isn’t unique as much for being a smart guy who has clever ideas about programs—although he certainly is and does—but for his achievement in refining and crafting those ideas into programs that make sense to others. He consistently creates applications that other programmers want to use and enhance.</p><p>Think about QEMU, for example. Like all Bellard’s best-known programs, it’s freely-available under the GNU Public License (GPL) or a close relative, originally developed under Linux, broadly portable, and now mostly maintained by others. Several programs preceded QEMU and roughly fit its description as “a generic and open source machine emulator and virtualizer;” QEMU, though, like many of Bellard’s creations, combines performance, robustness, portability, and flexibility in a way that none of its ancestors or rivals matched. Bellard’s contribution wasn’t to create the idea of a machine emulator, but to envision how to engineer one well enough to move it from the classroom or laboratory to “working-class” developers’ and testers’ toolboxes. It’s now indispensable to many testing teams, who can leverage QEMU to manage hundreds of distinct computing environments from a single underlying physical computer.</p><h3>Finding a Balance</h3><p>Bellard seems to balance nicely between extremes that threaten productivity. His techniques are modern without being faddish, and careful, yet not neurotic. While he moves every few years into new and fertile unconquered territory, he exercises  patterns that have served him well over and over: cleanly-styled C, data compression, numerical methods, signal processing, pertinent abstractions, media formats, open-source licensing, and “by-hand parsing.”</p><p>Bellard doesn’t appear to promote himself—he politely declined to be interviewed for this profile, for example—but others enthusiastically adopt his creations. Among the 654 Copyright notices QEMU 0.13.0 source code embeds, 216 are his. To put that another way: He was successful enough with QEMU during its first few years to entice others to put in over twice as much work (by this crude measure) as he has!</p><p><!-- img removed -->Bellard, born in 1972, began practicing his own coding techniques first on a TI-59 scientific calculator, at the beginning of the ‘80s. Many of the projects listed above, along with others in his <a title="portfolio" href="http://bellard.org/projects.html" target="_blank" rel="noopener noreferrer">portfolio</a>, originated as student assignments at <a title="l&#39;École Polytechnique" href="http://www.polytechnique.edu/" target="_blank" rel="noopener noreferrer">l&#39;École Polytechnique</a>, where he matriculated in 1990. TinyGL, for example, derives from the <a title="VReng" href="http://www.vreng.enst.fr/" target="_blank" rel="noopener noreferrer">VReng</a> Virtual Reality Engine distributed 3D application he began in 1998. Based on this experience, he eventually created and released in 2002 TinyGL as a very fast, very compact re-implementation of a substantial subset of <a title="OpenGL" href="http://www.opengl.org/" target="_blank" rel="noopener noreferrer">OpenGL</a>.</p><p>Similarly, his recent and relatively well-publicized calculation of several trillion (!) digits of pi was performed on a single desktop computer. Previous record-setting calculations of this class were done on million-dollar supercomputers. Bellard made it seem natural to pull together his mathematical insight, broad experience at instruction-level coding, and careful engineering to advance the field this way. The roots of the achievement reflect back to his experiments on a hand-held programmable calculator at the age of nine .</p><p>To describe fully even one of the projects already mentioned is beyond the scope of an article such as this; it would take several books to capture all that Bellard has already contributed, and at least another to explain <em>how</em> he works. A few broad conclusions are possible, though:</p><ul><li>As has often been observed before, the very best programmers are far, far more productive than the average, able to produce multiples of the usable output of others;</li></ul><ul><li>While it’s unrealistic to predict how programming would look without Fabrice Bellard or open-source licensing, there can be no doubt that such programs as QEMU, LZEXE, and FFmpeg are in pervasive use thousands of times each day around the world now; and</li></ul><ul><li>If there’s a secret to this superhero-level productivity, it appears to have less to do with comic-book mutation and radioactivity, and far more with discipline, confidence, rigor, and many years of practice.</li></ul><p>Mass media make it easy, especially in the United States, to believe that only “clashes of the Titans” matter. That is, the mindset is that progress with computers has to do with million-dollar budgets, celebrity announcements, and courtroom jousting. That’s a dangerously narrow view, dangerous because it neglects the creativity and insight of sufficiently dedicated individuals. While Fabrice Bellard seems unlikely ever to hire a publicist or otherwise elevate his profile in the public eye, he shapes our use of computers more indelibly than corporate executives and industry analysts.</p><p>How do <em>you</em> use FFmpeg or QEMU or his other productions?  Tell me about it in the comments.  Even more important: What great program will you write next?  What obstacles to superproductivity do you face?</p><p><strong>See also:</strong></p><ul><li><a title="Top 5 Software Quality eBooks of 2013 (Free for Download)" href="http://blog.smartbear.com/devops/top-5-software-quality-ebooks-of-2013-free-for-download/" rel="bookmark">Top 5 Software Quality eBooks of 2013 (Free for Download)</a></li><li><a title="A Taste of Salt: Like Puppet, Except It Doesn&#39;t Suck" href="http://blog.smartbear.com/devops/a-taste-of-salt-like-puppet-except-it-doesnt-suck/" target="_self">A Taste of Salt: Like Puppet, Except It Doesn&#39;t Suck</a></li><li><a title="14 Ways to Contribute to Open Source without Being a Programming Genius or a Rock Star" href="http://blog.smartbear.com/software-quality/bid/167051/14-Ways-to-Contribute-to-Open-Source-without-Being-a-Programming-Genius-or-a-Rock-Star" target="_blank" rel="noopener noreferrer">14 Ways to Contribute to Open Source without Being a Programming Genius or a Rock Star</a></li></ul><p>[dfads params=&#39;groups=937&amp;limit=1&amp;orderby=random&#39;]</p>
                    
                </div></div>
  </body>
</html>
