<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://buttondown.com/hillelwayne/archive/what-does-undecidable-mean-anyway/">Original</a>
    <h1>What does “Undecidable” mean, anyway</h1>
    
    <div id="readability-page-1" class="page"><div>
            
            <date>
                
                
                May 28, 2025
                
                
            </date>
            

            

            
            <h2>
                An explainer for people who don&#39;t know computer science and are mildly curious
            </h2>
            

            

            
            
            <h3>Systems Distributed</h3>
<p>I&#39;ll be speaking at <a href="https://systemsdistributed.com/" target="_blank">Systems Distributed</a> next month! The talk is brand new and will aim to showcase some of the formal methods mental models that would be useful in mainstream software development. It has added some extra stress on my schedule, though, so expect the next two monthly releases of <em>Logic for Programmers</em> to be mostly minor changes.</p>
<h2>What does &#34;Undecidable&#34; mean, anyway</h2>
<p>Last week I read <a href="https://liamoc.net/forest/loc-000S/index.xml" target="_blank">Against Curry-Howard Mysticism</a>, which is a solid article I recommend reading. But this newsletter is actually about <a href="https://lobste.rs/s/n0whur/against_curry_howard_mysticism#c_lbts57" target="_blank">one comment</a>:</p>
<blockquote>
<p>I like to see posts like this because I often feel like I can’t tell the difference between BS and a point I’m missing. Can we get one for questions like “Isn’t XYZ (Undecidable|NP-Complete|PSPACE-Complete)?” </p>
</blockquote>
<p>I&#39;ve already written one of these for <a href="https://www.hillelwayne.com/post/np-hard/" target="_blank">NP-complete</a>, so let&#39;s do one for &#34;undecidable&#34;. Step one is to pull a technical definition from the book <a href="https://link.springer.com/book/10.1007/978-1-4612-1844-9" target="_blank"><em>Automata and Computability</em></a>:</p>
<blockquote>
<p>A property P of strings is said to be decidable if ... there is a total Turing machine that accepts input strings that have property P and rejects those that do not. (pg 220)</p>
</blockquote>
<p>Step two is to translate the technical computer science definition into more conventional programmer terms. Warning, because this is a newsletter and not a blog post, I might be a little sloppy with terms.</p>
<h3>Machines and Decision Problems</h3>
<p>In automata theory, all inputs to a &#34;program&#34; are strings of characters, and all outputs are &#34;true&#34; or &#34;false&#34;. A program &#34;accepts&#34; a string if it outputs &#34;true&#34;, and &#34;rejects&#34; if it outputs &#34;false&#34;. You can think of this as automata studying all pure functions of type <code>f :: string -&gt; boolean</code>. Problems solvable by finding such an <code>f</code> are called &#34;decision problems&#34;.</p>
<p>This covers more than you&#39;d think, because we can bootstrap more powerful functions from these. First, as anyone who&#39;s programmed in bash knows, strings can represent any other data. Second, we can fake non-boolean outputs by instead checking if a certain computation gives a certain result. For example, I can reframe the function <code>add(x, y) = x + y</code> as a decision problem like this:</p>
<div><pre><span></span><code>IS_SUM(str) {
    x, y, z = split(str, &#34;#&#34;)
    return x + y == z
}
</code></pre></div>
<p>Then because <code>IS_SUM(&#34;2#3#5&#34;)</code> returns true, we know <code>2 + 3 == 5</code>, while <code>IS_SUM(&#34;2#3#6&#34;)</code> is false. Since we can bootstrap parameters out of strings, I&#39;ll just say it&#39;s <code>IS_SUM(x, y, z)</code> going forward.</p>
<p>A big part of automata theory is studying different models of computation with different strengths. One of the weakest is called <a href="https://en.wikipedia.org/wiki/Deterministic_finite_automaton" target="_blank">&#34;DFA&#34;</a>. I won&#39;t go into any details about what DFA actually can do, but the important thing is that it <em>can&#39;t</em> solve <code>IS_SUM</code>. That is, if you give me a DFA that takes inputs of form <code>x#y#z</code>, I can always find an input where the DFA returns true when <code>x + y != z</code>, <em>or</em> an input which returns false when <code>x + y == z</code>.</p>
<p>It&#39;s really important to keep this model of &#34;solve&#34; in mind: a program solves a problem if it correctly returns true on all true inputs and correctly returns false on all false inputs.</p>
<h3>(total) Turing Machines</h3>
<p>A Turing Machine (TM) is a particular type of computation model. It&#39;s important for two reasons: </p>
<ol>
<li>
<p>By the <a href="https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis" target="_blank">Church-Turing thesis</a>, a Turing Machine is the &#34;upper bound&#34; of how powerful (physically realizable) computational models can get. This means that if an actual real-world programming language can solve a particular decision problem, so can a TM. Conversely, if the TM <em>can&#39;t</em> solve it, neither can the programming language.<sup id="fnref:caveat"><a href="#fn:caveat">1</a></sup></p>
</li>
<li>
<p>It&#39;s possible to write a Turing machine that takes <em>a textual representation of another Turing machine</em> as input, and then simulates that Turing machine as part of its computations. </p>
</li>
</ol>
<p>Property (1) means that we can move between different computational models of equal strength, proving things about one to learn things about another. That&#39;s why I&#39;m able to write <code>IS_SUM</code> in a pseudocode instead of writing it in terms of the TM computational model (and why I was able to use <code>split</code> for convenience). </p>
<p>Property (2) does several interesting things. First of all, it makes it possible to compose Turing machines. Here&#39;s how I can roughly ask if a given number is the sum of two primes, with &#34;just&#34; addition and boolean functions:</p>
<div><pre><span></span><code>IS_SUM_TWO_PRIMES(z):
    x := 1
    y := 1
    loop {
        if x &gt; z {return false}
        if IS_PRIME(x) {
            if IS_PRIME(y) {
                if IS_SUM(x, y, z) {
                    return true;
                }
            }
        }
        y := y + 1
        if y &gt; x {
            x := x + 1
            y := 0
        }
    }
</code></pre></div>
<p>Notice that without the <code>if x &gt; z {return false}</code>, the program would loop forever on <code>z=2</code>. A TM that always halts for all inputs is called <strong>total</strong>.</p>
<p>Property (2) also makes &#34;Turing machines&#34; a possible input to functions, meaning that we can now make decision problems about the behavior of Turing machines. For example, &#34;does the TM <code>M</code> either accept or reject <code>x</code> within ten steps?&#34;<sup id="fnref:backticks"><a href="#fn:backticks">2</a></sup></p>
<div><pre><span></span><code>IS_DONE_IN_TEN_STEPS(M, x) {
    for (i = 0; i &lt; 10; i++) {
        `simulate M(x) for one step`
        if(`M accepted or rejected`) {
            return true
        }
    }
    return false
}
</code></pre></div>
<h3>Decidability and Undecidability</h3>
<p>Now we have all of the pieces to understand our original definition:</p>
<blockquote>
<p>A property P of strings is said to be decidable if ... there is a total Turing machine that accepts input strings that have property P and rejects those that do not. (220)</p>
</blockquote>
<p>Let <code>IS_P</code> be the decision problem &#34;Does the input satisfy P&#34;? Then <code>IS_P</code> is decidable if it can be solved by a Turing machine, ie, I can provide some <code>IS_P(x)</code> machine that <em>always</em> accepts if <code>x</code> has property P, and always rejects if <code>x</code> doesn&#39;t have property P. If I can&#39;t do that, then <code>IS_P</code> is undecidable. </p>
<p><code>IS_SUM(x, y, z)</code> and <code>IS_DONE_IN_TEN_STEPS(M, x)</code> are decidable properties. Is <code>IS_SUM_TWO_PRIMES(z)</code> decidable? Some analysis shows that our corresponding program will either find a solution, or have <code>x&gt;z</code> and return false. So yes, it is decidable.</p>
<p>Notice there&#39;s an asymmetry here. To prove some property is decidable, I need just to need to find <em>one</em> program that correctly solves it. To prove some property is undecidable, I need to show that any possible program, no matter what it is, doesn&#39;t solve it.</p>
<p>So with that asymmetry in mind, do are there <em>any</em> undecidable problems? Yes, quite a lot. Recall that Turing machines can accept encodings of other TMs as input, meaning we can write a TM that checks <em>properties of Turing machines</em>. And, by <a href="https://en.wikipedia.org/wiki/Rice%27s_theorem" target="_blank">Rice&#39;s Theorem</a>, almost every nontrivial semantic<sup id="fnref:nontrivial"><a href="#fn:nontrivial">3</a></sup> property of Turing machines is undecidable. The conventional way to prove this is to first find a single undecidable property <code>H</code>, and then use that to bootstrap undecidability of other properties.</p>
<p>The canonical and most famous example of an undecidable problem is the <a href="https://en.wikipedia.org/wiki/Halting_problem" target="_blank">Halting problem</a>: &#34;does machine M halt on input i?&#34; It&#39;s pretty easy to prove undecidable, and easy to use it to bootstrap other undecidability properties. But again, <em>any</em> nontrivial property is undecidable. Checking a TM is total is undecidable. Checking a TM accepts <em>any</em> inputs is undecidable. Checking a TM solves <code>IS_SUM</code> is undecidable. Etc etc etc.</p>
<h3>What this doesn&#39;t mean in practice</h3>
<p>I often see the halting problem misconstrued as &#34;it&#39;s impossible to tell if a program will halt before running it.&#34; <strong>This is wrong</strong>. The halting problem says that we cannot create an algorithm that, when applied to an arbitrary program, tells us whether the program will halt or not. It is absolutely possible to tell if many programs will halt or not. It&#39;s possible to find entire subcategories of programs that are guaranteed to halt. It&#39;s possible to say &#34;a program constructed following constraints XYZ is guaranteed to halt.&#34; </p>
<p>The actual consequence of undecidability is more subtle. If we want to know if a program has property P, undecidability tells us</p>
<ol>
<li>We will have to spend time and mental effort to determine if it has P</li>
<li>We may not be successful.</li>
</ol>
<p>This is subtle because we&#39;re so used to living in a world where everything&#39;s undecidable that we don&#39;t really consider what the counterfactual would be like. In such a world there might be no need for Rust, because &#34;does this C program guarantee memory-safety&#34; is a decidable property. The entire field of formal verification could be unnecessary, as we could just check properties of arbitrary programs directly. We could automatically check if a change in a program preserves all existing behavior. Lots of famous math problems could be solved overnight. </p>
<p>(This to me is a strong &#34;intuitive&#34; argument for why the halting problem is undecidable: a halt detector can be trivially repurposed as a program optimizer / theorem-prover / bcrypt cracker / chess engine. It&#39;s <em>too powerful</em>, so we should expect it to be impossible.)</p>
<p>But because we don&#39;t live in that world, all of those things are hard problems that take effort and ingenuity to solve, and even then we often fail.</p>
<h3>Update for the Internet</h3>
<p>This was sent as a weekly newsletter, which is usually on topics like <a href="https://buttondown.com/hillelwayne/archive/why-do-we-call-it-boilerplate-code" target="_blank">software history</a>, <a href="https://buttondown.com/hillelwayne/archive/the-seven-specification-ur-languages/" target="_blank">formal methods</a>, <a href="https://buttondown.com/hillelwayne/archive/i-formally-modeled-dreidel-for-no-good-reason/" target="_blank">unusual technologies</a>, and the <a href="https://buttondown.com/hillelwayne/archive/be-suspicious-of-success/" target="_blank">theory of software engineering</a>. You <a href="https://buttondown.email/hillelwayne/" target="_blank">can subscribe here</a>.</p>

            
            

            
            
            <p><em>If you&#39;re reading this on the web, you can subscribe <a href="https://buttondown.com/hillelwayne" target="_blank">here</a>. Updates are once a week. My main website is <a href="https://www.hillelwayne.com" target="_blank">here</a>.</em></p>
<p><em>My new book, </em>Logic for Programmers<em>, is now in early access! Get it <a href="https://leanpub.com/logic/" target="_blank">here</a>.</em></p>
            
            

            





        </div></div>
  </body>
</html>
