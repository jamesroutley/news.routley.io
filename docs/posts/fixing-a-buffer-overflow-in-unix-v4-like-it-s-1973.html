<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sigma-star.at/blog/2025/12/unix-v4-buffer-overflow/">Original</a>
    <h1>Fixing a Buffer Overflow in Unix v4 Like It&#39;s 1973</h1>
    
    <div id="readability-page-1" class="page"><div><h2 id="introduction">Introduction</h2><p>In 2025, the only known copy of UNIX v4 surfaced on a magnetic tape<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>.
This version marks a pivotal moment in computer history: the rewriting of UNIX into C.
Enthusiasts quickly recovered the data and successfully ran the system on a PDP-11 simulator<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>.</p><p>Fascinated by this artifact, I set up an instance to explore it.
Because the distribution includes the source code, I examined the implementation of several core utilities.
While auditing the <code>su(1)</code> program, I identified a bug. Let’s fix it.</p><h2 id="the-unix-v4-su1-program">The UNIX v4 su(1) program</h2><p>Although more than 50 years old, the <code>su</code> program functions similarly to its modern variant.
As a setuid-root executable, it validates the root password.
If the user provides the correct credentials, the program spawns a root shell, allowing an unprivileged user to escalate privileges.</p><p>The source file, <code>su.c</code>, contains fewer than 50 lines of code.</p><div><pre tabindex="0"><code data-lang="C"><span><span><span>/* su -- become super-user */</span>
</span></span><span><span>
</span></span><span><span><span>char</span>    <span>password</span><span>[</span><span>100</span><span>];</span>
</span></span><span><span><span>char</span>    <span>pwbuf</span><span>[</span><span>100</span><span>];</span>
</span></span><span><span><span>int</span>     <span>ttybuf</span><span>[</span><span>3</span><span>];</span>
</span></span><span><span><span>main</span><span>()</span>
</span></span><span><span><span>{</span>
</span></span><span><span>        <span>register</span> <span>char</span> <span>*</span><span>p</span><span>,</span> <span>*</span><span>q</span><span>;</span>
</span></span><span><span>        <span>extern</span> <span>fin</span><span>;</span>
</span></span><span><span>
</span></span><span><span>        <span>if</span><span>(</span><span>getpw</span><span>(</span><span>0</span><span>,</span> <span>pwbuf</span><span>))</span>
</span></span><span><span>                <span>goto</span> <span>badpw</span><span>;</span>
</span></span><span><span>        <span>(</span><span>&amp;</span><span>fin</span><span>)[</span><span>1</span><span>]</span> <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>        <span>p</span> <span>=</span> <span>pwbuf</span><span>;</span>
</span></span><span><span>        <span>while</span><span>(</span><span>*</span><span>p</span> <span>!=</span> <span>&#39;:&#39;</span><span>)</span>
</span></span><span><span>                <span>if</span><span>(</span><span>*</span><span>p</span><span>++</span> <span>==</span> <span>&#39;\0&#39;</span><span>)</span>
</span></span><span><span>                        <span>goto</span> <span>badpw</span><span>;</span>
</span></span><span><span>        <span>if</span><span>(</span><span>*++</span><span>p</span> <span>==</span> <span>&#39;:&#39;</span><span>)</span>
</span></span><span><span>                <span>goto</span> <span>ok</span><span>;</span>
</span></span><span><span>        <span>gtty</span><span>(</span><span>0</span><span>,</span> <span>ttybuf</span><span>);</span>
</span></span><span><span>        <span>ttybuf</span><span>[</span><span>2</span><span>]</span> <span>=&amp;</span> <span>~</span><span>010</span><span>;</span>
</span></span><span><span>        <span>stty</span><span>(</span><span>0</span><span>,</span> <span>ttybuf</span><span>);</span>
</span></span><span><span>        <span>printf</span><span>(</span><span>&#34;password: &#34;</span><span>);</span>
</span></span><span><span>        <span>q</span> <span>=</span> <span>password</span><span>;</span>
</span></span><span><span>        <span>while</span><span>((</span><span>*</span><span>q</span> <span>=</span> <span>getchar</span><span>())</span> <span>!=</span> <span>&#39;\n&#39;</span><span>)</span>
</span></span><span><span>                <span>if</span><span>(</span><span>*</span><span>q</span><span>++</span> <span>==</span> <span>&#39;\0&#39;</span><span>)</span>
</span></span><span><span>                        <span>return</span><span>;</span>
</span></span><span><span>        <span>*</span><span>q</span> <span>=</span> <span>&#39;\0&#39;</span><span>;</span>
</span></span><span><span>        <span>ttybuf</span><span>[</span><span>2</span><span>]</span> <span>=|</span> <span>010</span><span>;</span>
</span></span><span><span>        <span>stty</span><span>(</span><span>0</span><span>,</span> <span>ttybuf</span><span>);</span>
</span></span><span><span>        <span>printf</span><span>(</span><span>&#34;</span><span>\n</span><span>&#34;</span><span>);</span>
</span></span><span><span>        <span>q</span> <span>=</span> <span>crypt</span><span>(</span><span>password</span><span>);</span>
</span></span><span><span>        <span>while</span><span>(</span><span>*</span><span>q</span><span>++</span> <span>==</span> <span>*</span><span>p</span><span>++</span><span>);</span>
</span></span><span><span>        <span>if</span><span>(</span><span>*--</span><span>q</span> <span>==</span> <span>&#39;\0&#39;</span> <span>&amp;&amp;</span> <span>*--</span><span>p</span> <span>==</span> <span>&#39;:&#39;</span><span>)</span>
</span></span><span><span>                <span>goto</span> <span>ok</span><span>;</span>
</span></span><span><span>        <span>goto</span> <span>error</span><span>;</span>
</span></span><span><span>
</span></span><span><span><span>badpw</span><span>:</span>
</span></span><span><span>        <span>printf</span><span>(</span><span>&#34;bad password file</span><span>\n</span><span>&#34;</span><span>);</span>
</span></span><span><span><span>ok</span><span>:</span>
</span></span><span><span>        <span>setuid</span><span>(</span><span>0</span><span>);</span>
</span></span><span><span>        <span>execl</span><span>(</span><span>&#34;/bin/sh&#34;</span><span>,</span> <span>&#34;-&#34;</span><span>,</span> <span>0</span><span>);</span>
</span></span><span><span>        <span>printf</span><span>(</span><span>&#34;cannot execute shell</span><span>\n</span><span>&#34;</span><span>);</span>
</span></span><span><span><span>error</span><span>:</span>
</span></span><span><span>        <span>printf</span><span>(</span><span>&#34;sorry</span><span>\n</span><span>&#34;</span><span>);</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>In short, the program executes the following steps:</p><ol><li>It calls <code>getpw()</code> to retrieve the passwd entry for the root user (UID 0) from <code>/etc/passwd</code>. Surprisingly, if the read fails or the line format is incorrect, <code>su</code> continues execution rather than aborting. While unusual, this likely acts as a safeguard to ensure <code>su</code> remains usable on a partially corrupted system. This is a security issue on its own because an unprivileged user could consume enough resources to make the <code>getpw()</code> call fail. Ron Natalie pointed<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup> out that this attack vector was known at the time.</li><li>It disables the TTY echo mode and prompts the user for a password.</li><li>It reads byte-by-byte from the TTY into a buffer until it encounters a newline or <code>NUL</code> character, <code>NUL</code> causes the program to exit immediately.</li><li>Once reading is complete, it re-enables echo mode, hashes the input using the <code>crypt()</code> library function, and compares the result with the stored hash.</li><li>If the hashes match, it spawns a shell, otherwise, it terminates.</li></ol><p>The logic is standard, except for one critical flaw: the <code>password</code> buffer has a fixed size of <code>100</code> bytes, yet the input loop lacks a bounds check.
If a user enters more than <code>100</code> characters, a buffer overflow occurs.</p><p>I confirmed this behavior by testing with a long input string, which successfully crashed the program.
Not all long strings trigger a core dump.
The outcome depends on which area of adjacent memory is overwritten, sometimes, <code>su</code> simply exits.</p><pre tabindex="0"><code># su
password:&lt;long input&gt;Memory fault -- Core dumped
</code></pre><p>Note: Because <code>su</code> disables TTY echo mode, a crash prevents the terminal from displaying subsequent input.
To restore visibility, type <code>stty echo</code> blindly and press Enter.</p><h2 id="fixing-su1">Fixing su(1)</h2><p>UNIX traditionally includes the source code necessary for self-recompilation, and v4 is no exception.
This allows us to patch and compile <code>su</code> directly on the system.
In 1973, editor options were sparse. Neither <code>vi</code> nor <code>emacs</code> had been invented yet.
However, the system provides <code>ed</code>, a line-oriented text editor designed for teletype terminals where output was printed on paper rather than displayed on a screen.
<code>ed</code> allows us to list, delete, and append lines, which is sufficient for our needs.</p><p>We will edit <code>su.c</code> to prevent the overflow by maintaining a counter, <code>i</code>, and verifying it against the buffer size during the read loop.
I initially attempted a fix using pointer arithmetic, but the 1973 C compiler didn’t like it, while it didn’t refuse the syntax, the code had no effect.
I settled on a simpler index-based check instead.</p><div><pre tabindex="0"><code data-lang="diff"><span><span><span>--- a/s2/su.c
</span></span></span><span><span><span></span><span>+++ b/s2/su.c
</span></span></span><span><span><span></span><span>@@ -7,6 +7,7 @@ main()
</span></span></span><span><span><span></span> {
</span></span><span><span>        register char *p, *q;
</span></span><span><span>        extern fin;
</span></span><span><span><span>+       register int i;
</span></span></span><span><span><span></span> 
</span></span><span><span>        if(getpw(0, pwbuf))
</span></span><span><span>                goto badpw;
</span></span><span><span><span>@@ -22,9 +23,13 @@ main()
</span></span></span><span><span><span></span>        stty(0, ttybuf);
</span></span><span><span>        printf(&#34;password: &#34;);
</span></span><span><span>        q = password;
</span></span><span><span><span>-       while((*q = getchar()) != &#39;\n&#39;)
</span></span></span><span><span><span></span><span>+       i = 0;
</span></span></span><span><span><span>+       while((*q = getchar()) != &#39;\n&#39;) {
</span></span></span><span><span><span>+               if (++i &gt;= sizeof(password))
</span></span></span><span><span><span>+                       goto error;
</span></span></span><span><span><span></span>                if(*q++ == &#39;\0&#39;)
</span></span><span><span>                        return;
</span></span><span><span><span>+       }
</span></span></span><span><span><span></span>        *q = &#39;\0&#39;;
</span></span><span><span>        ttybuf[2] =| 010;
</span></span><span><span>        stty(0, ttybuf);
</span></span></code></pre></div><pre tabindex="0"><code># chdir /usr/source/s2
# ed su.c
</code></pre><p>Upon launch, <code>ed</code> outputs the file size in bytes and awaits input.
The command <code>i</code> inserts text before the current line, <code>d</code> deletes the line, and <code>p</code> prints it.
Entering a number moves the focus to that specific line, while pressing Return prints the current line’s content.</p><p>Below is a screen recording of the editing session:</p><pre tabindex="0"><code data-lang="ed">741
8
        register char *p, *q;

        extern fin;
i
        register int i;
.
24
        printf(&#34;password: &#34;);

        q = password;
i
        i = 0;
.
p
        i = 0;

        while((*q = getchar()) != &#39;\n&#39;)
d
i
        while((*q = getchar()) != &#39;\n&#39;) {
.

                if(*q++ == &#39;\0&#39;)
i
                if (++i &gt;= sizeof(password))
                        goto error;
.

                if(*q++ == &#39;\0&#39;)

                        return;

        *q = &#39;\0&#39;;
i
        }
.
w
811
q
</code></pre><p>First, we jump to line <code>8</code> and press Return several times to locate a suitable spot for the variable declaration.
We use <code>i</code> to enter insert mode, add the variable, and then type a single period (<code>.</code>) on a new line to exit insert mode.
The critical change occurs around the while loop: we initialize <code>i</code> and add a boundary check to the loop condition.
Finally, <code>w</code> writes the modified buffer to disk, confirming the file has grown by a few bytes, and <code>q</code> terminates the editor.</p><h2 id="building-and-deploying">Building and Deploying</h2><p>With the source code patched, we must rebuild the binary.
Since <code>su</code> consists of a single C file, the compilation process is trivial:</p><pre tabindex="0"><code># cc su.c
</code></pre><p>The compiler outputs a binary named <code>a.out</code>.
To deploy it, we move the file to <code>/bin/su</code>:</p><pre tabindex="0"><code># mv a.out /bin/su
</code></pre><p>However, the installation is incomplete.
Because <code>su</code> requires root privileges to function, we must set the setuid bit and adjust the file permissions:</p><pre tabindex="0"><code># ls -l /bin/su
-rwxrwxrwx 1 root     2740 Jun 12 19:58 /bin/su
# chmod 4755 /bin/su
# ls -l /bin/su
-rwsr-xr-x 1 root     2740 Jun 12 19:58 /bin/su
</code></pre><h2 id="summary">Summary</h2><p>UNIX v4 is a fascinating gem of computer history.
It feels surprisingly similar to our current systems.
While it lacks modern conveniences, the fundamental logic remains recognizable to anyone with modern UNIX experience.</p><p>The ability to fix <code>su</code> so quickly highlights the power of the early UNIX philosophy: shipping the operating system with its full source code and a C compiler.
We patched, compiled, and deployed the fix directly on the system, no external toolchains required.</p><p>Finally, this bug reminds us of the era’s different priorities.
In the trusted, isolated environments of 1973, security was not the critical concern it is today.
Furthermore, the knowledge that a buffer overflow could be exploited for arbitrary code execution had not yet come of age.</p><p>As an exercise for the reader to improve their <code>ed</code> skills, try adding the code to restore TTY echo mode to the overflow detection logic.
This ensures the terminal functions correctly even after the program catches the error.</p></div></div>
  </body>
</html>
