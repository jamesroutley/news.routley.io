<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pion.ly/blog/making-a-game-with-pion/">Original</a>
    <h1>Show HN: Making a cross-platform game in Go using WebRTC Datachannels</h1>
    
    <div id="readability-page-1" class="page"><section><div><p>(The following was adapted from a talk I gave at <a href="https://dwebseminar.org/weekend/">DWeb Weekend 2025</a> at the Internet Archive in San Francisco on August 17, 2025)</p><p>First of all, to get some stuff out of the way, instead of using the “super complicated” WebRTC datachannels, why don’t we use something simpler?</p><h2 id="why-not-use-websockets">Why Not Use Websockets?<a href="#why-not-use-websockets"><i></i></a></h2><ul><li><strong>Too slow</strong>: Most games use UDP with a reliability layer on top.</li><li><strong>Suitable for turn-based games</strong>: Fine for games that are turn-based/slow-paced, like Runescape.</li><li>For more details, see:<ul><li><a href="https://gafferongames.com/post/udp_vs_tcp/">UDP vs TCP</a></li><li><a href="https://gafferongames.com/post/client_server_connection/">Client-Server Connection</a></li></ul></li></ul><h2 id="the-case-for-web-transport">The Case for Web Transport<a href="#the-case-for-web-transport"><i></i></a></h2><ul><li>Replacement for Websockets, uses QUIC instead of TCP.</li><li>However, it has been in development for a long time, and I want to get started on making games now.</li><li>Current issues:<ul><li><a href="https://caniuse.com/webtransport">Caniuse WebTransport</a></li><li>Official demos on <a href="https://github.com/w3c/webtransport">GitHub</a> do not work on Firefox on Windows.</li><li><a href="https://github.com/w3c/webtransport/issues/675">GitHub Issue</a></li><li><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1969090">Firefox Bugzilla</a></li></ul></li><li><strong>Potential</strong>: Will probably solve most problems once finished and would be the best choice for making a multiplayer game on the web.</li></ul><ul><li><strong>Feature</strong>: Lets us send unreliable packets over the web using SCTP.</li><li>Advantage: We don’t need WebTransport; we can use this today.</li><li>They were created in part for exactly this use case<ul><li><a href="https://datatracker.ietf.org/doc/html/rfc8831#name-use-cases-for-unreliable-da">See the reasoning for unreliable datachannels in the official specification itself</a></li><li><a href="https://news.ycombinator.com/item?id=13264952">Not to mention that one of the original implementers of WebRTC wanted to enable this usecase</a>
<img src="https://pion.ly/img/comment_from_webrtc_team.png" alt="Comment from original WebRTC team member"/></li></ul></li></ul><h2 id="benefits-and-drawbacks-of-webrtc">Benefits and Drawbacks of WebRTC<a href="#benefits-and-drawbacks-of-webrtc"><i></i></a></h2><h3 id="benefits">Benefits<a href="#benefits"><i></i></a></h3><ul><li><strong>Host flexibility</strong>: Do not need to host servers - players can make their own.<ul><li>No more need for port forwarding or Hamachi!</li></ul></li><li><strong>Minimal server requirements</strong>: Only need one server for signaling.</li><li><strong>Community-supported specification</strong>: There are many options for making your own WebRTC-based app.</li></ul><h3 id="drawbacks">Drawbacks<a href="#drawbacks"><i></i></a></h3><ul><li><strong>Complex setup</strong>: Setting up WebRTC is challenging.</li><li><strong>Server dependence</strong>: You need to host or use two different servers (Signaling + STUN/TURN).<ul><li>Can use Google’s STUN, but combining signaling and STUN into one server would be nice.</li></ul></li></ul><h2 id="webrtc-implementations">WebRTC Implementations<a href="#webrtc-implementations"><i></i></a></h2><ul><li><a href="https://github.com/webrtc-sdk/libwebrtc?tab=readme-ov-file">libwebrtc</a> - (a fork of) the original WebRTC implementation.</li><li><a href="https://github.com/paullouisageneau/libdatachannel">libdatachannel</a> - C/C++.</li><li><a href="https://github.com/pion/webrtc">Pion WebRTC</a> - Go.</li><li><a href="https://github.com/webrtc-rs/webrtc">webrtc-rs</a> - Rust (using Tokio Runtime).</li><li><a href="https://github.com/algesten/str0m">str0m</a> - Rust (sans-io).</li><li><a href="https://github.com/sipsorcery-org/sipsorcery">sipsorcery</a> - C#</li><li><a href="https://github.com/ValveSoftware/GameNetworkingSockets">GameNetworkingSockets</a><ul><li>Uses ICE and STUN/TURN for Peer to Peer.</li><li>Created by Valve and made for Steam, which means if you’ve ever played a game like Counter Strike or Deadlock, you’ve already seen this library in action!</li></ul></li></ul><h3 id="existing-game-networking-libraries-using-webrtc">Existing Game Networking Libraries Using WebRTC<a href="#existing-game-networking-libraries-using-webrtc"><i></i></a></h3><ul><li><a href="https://github.com/geckosio/geckos.io">Geckos.io</a><ul><li>A client-server abstraction for WebRTC Datachannels written in Node.js.</li><li>Past experience: Really nice but a bit inefficient. See <a href="https://github.com/geckosio/geckos.io/issues/269">GitHub Issue</a>.</li></ul></li><li><a href="https://github.com/poki/netlib">Netlib</a> - Peer-to-peer WebRTC datachannel library for TypeScript.</li><li><a href="https://github.com/johanhelsing/matchbox">Matchbox</a> - WebRTC datachannel library for Rust, compiles to both native and WASM.</li><li><a href="https://github.com/peers/peerjs">PeerJS</a> - Great for browser-only apps/games, not specifically for game networking.</li><li><a href="https://github.com/rameshvarun/netplayjs">Netplayjs</a> - Untested but seems to work well.</li><li><a href="https://github.com/godotengine/webrtc-native">Godot Engine’s WebRTC Native</a> - Official Godot bindings to libdatachannel for Godot’s multiplayer API.</li></ul><h2 id="real-world-uses">Real-World Uses<a href="#real-world-uses"><i></i></a></h2><ul><li><strong>WebXash3D</strong>: Reimplementation of Half-Life 1 + Counter-Strike 1.6 using WebRTC.<ul><li><a href="https://github.com/yohimik/webxash3d-fwgs">GitHub WebXash3D</a></li><li><a href="https://github.com/ololoken/xash3d-launcher">Xash3D Launcher</a></li><li><a href="https://turch.in/cs/index.html">Counter Strike 1.6 on the web</a></li><li><img src="https://pion.ly/img/counter_strike_on_the_web.png" alt="Counter Strike"/></li></ul></li><li><strong>Hypersomnia</strong> - Open source 2D shooter made with C++ and libdatachannel<ul><li>Has cross platform capabilities between both<ul><li>The <a href="https://store.steampowered.com/app/2660970/Hypersomnia/">native Steam port</a></li><li>And in the browser (On <a href="https://www.crazygames.com/game/hypersomnia">CrazyGames</a> and <a href="https://hypersomnia.io/">the official website</a>)</li></ul></li><li><a href="https://github.com/TeamHypersomnia/Hypersomnia">Github Link</a></li></ul></li></ul><h2 id="why-go-for-development">Why Go for Development?<a href="#why-go-for-development"><i></i></a></h2><ul><li>Efficient: It just gets the job done.</li><li>Pion: Has a pure-Go implementation of WebRTC.</li><li>Minimal dependencies: No need for external dependencies like OpenSSL.</li></ul><h2 id="why-not-rust">Why Not Rust?<a href="#why-not-rust"><i></i></a></h2><ul><li>Preference: I like Rust, but Go has a more active scene/easier help for WebRTC.</li><li>Speed of development: It’s faster to code in Go compared to Rust.</li></ul><h2 id="why-ebitengine-for-game-development">Why Ebitengine for Game Development?<a href="#why-ebitengine-for-game-development"><i></i></a></h2><ul><li><a href="https://ebitengine.org/">Website Link</a></li><li><strong>Versatile</strong>: 2D game engine that works across various platforms.<ul><li>The creator, <a href="https://hajimehoshi.com/">Hajime Hoshi</a>, has ported the engine (and the Go language!) to <a href="https://ebitengine.org/en/blog/native_compiling_for_nintendo_switch.html">the Nintendo Switch</a> and other game consoles</li></ul></li><li><strong>Battle Tested</strong>: Has been used for actual games like<ul><li><a href="https://playism.com/en/game/frommadness-withlove/">From Madness with Love</a><ul><li><a href="https://store.steampowered.com/app/2101130/From_Madness_with_Love/">Steam Link</a></li></ul></li><li>Coral &amp; The Abyss<ul><li><a href="https://store.steampowered.com/app/3123920/Coral__The_Abyss/">Steam Link</a></li><li><a href="https://www.nintendo.com/us/store/products/coral-and-the-abyss-switch/">Nintendo eShop Link</a></li></ul></li><li>Rakuen<ul><li><a href="https://store.steampowered.com/app/559210/Rakuen/">Steam Link</a></li><li><a href="https://www.nintendo.com/us/store/products/rakuen-deluxe-edition-switch/">Nintendo eShop Link</a></li></ul></li><li>And more on the <a href="https://ebitengine.org/en/showcase.html">Ebitengine Showcase Page</a></li></ul></li><li><strong>Potential Crossplay</strong>: You could make a cross platform multiplayer game in pure Go that works between the Nintendo Switch, PC, and the browser!</li></ul><h2 id="official-pion-example">Official Pion Example<a href="#official-pion-example"><i></i></a></h2><ul><li>We now have an official example using Ebitengine in the Pion <a href="https://github.com/pion/example-webrtc-applications">example-webrtc-applications</a> repository</li><li>This includes an bundled in signaling server so you can host your own lobby, and connect with another player.</li><li><a href="https://github.com/pion/example-webrtc-applications/tree/master/ebiten-game"><strong>Github Link to Game</strong></a></li><li><strong>PR where it was merged in</strong>: <a href="https://github.com/pion/example-webrtc-applications/pull/351">Example WebRTC Applications</a></li><li><strong>Limitations</strong><ul><li>Right now, this can only support two players on the same computer<ul><li>Could probably work between two different computers, but we would need to figure out how to setup CORS properly for the signaling server</li><li>The machinery is there to support more than two players in a lobby, but as of writing this article it is <a href="https://github.com/pion/example-webrtc-applications/blob/5c7005933879d34fa19b4d0c744bb884a247f5dc/ebiten-game/game/main.go#L154">currently hardcoded</a> to just two
<img src="https://pion.ly/img/game_on_web_and_desktop.png" alt="Picture of game"/></li></ul></li></ul></li></ul><h2 id="other-games-that-use-webrtc">Other Games That Use WebRTC<a href="#other-games-that-use-webrtc"><i></i></a></h2><ul><li><a href="https://toughlovearena.com/">Tough Love Arena</a></li><li><a href="https://www.counterpicklabs.com/">Counterpick Labs</a></li><li><a href="https://2dsoccer.com/">2D Soccer</a></li></ul><h2 id="possibilities-with-webrtc">Possibilities with WebRTC<a href="#possibilities-with-webrtc"><i></i></a></h2><ul><li>Hosting a Minecraft-style game without dedicated servers or port forwarding.</li><li>Players host everything themselves: no need for VPN/Hamachi.</li></ul><hr/><ul><li>A big thanks to:<ul><li><a href="https://pion.ly/discord">The Pion Discord</a></li><li><a href="https://discord.gg/jXAP8jp3Nn">The libdatachannel Discord</a></li><li><a href="https://discord.gg/3tVdM5H8cC">The Ebitengine Discord</a></li><li><a href="https://discord.com/invite/game-development-in-rust-676678179678715904">The Rust gamedev Discord</a></li></ul></li><li>And many more who made this journey possible. I stand on the shoulders of giants.</li></ul></div></section></div>
  </body>
</html>
