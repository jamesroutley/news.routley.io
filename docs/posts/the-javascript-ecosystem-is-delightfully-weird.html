<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fly.io/blog/js-ecosystem-delightfully-wierd/">Original</a>
    <h1>The JavaScript ecosystem is delightfully weird</h1>
    
    <div id="readability-page-1" class="page"><article> <dl> <dt>Author</dt> <dd> <img src="https://fly.io/static/images/sam.webp" alt="Sam Ruby" srcset=""/> <dl> <dt>Name</dt> <dd> Sam Ruby </dd> <dt>Social Media</dt> <dd> <a href="https://ruby.social/@samruby" target="_blank" rel="noopener noreferrer"> <span aria-hidden="true">@samruby</span> <span>View Fediverse Profile</span> </a> </dd> </dl> </dd> </dl> <section> <figure> <img src="https://fly.io/blog/2023-05-11/js-weird-cover.webp" alt="A landscape vaguely inspired by Salvador Dali&#39;s The Persistence of Memory including a melted baloon clock, craters, a disembodied hand, mountains, and a JS logo in the sky"/> <figcaption> <span>Image by</span> <svg role="img" style="pointer-events: none; width: 17px; height: 17px;" viewBox="0 0 20 20" fill="currentColor" fill-rule="evenodd"> <g buffered-rendering="static"> <path fill-rule="evenodd" d="M1 8a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 018.07 3h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0016.07 6H17a2 2 0 012 2v7a2 2 0 01-2 2H3a2 2 0 01-2-2V8zm13.5 3a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0zM10 14a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd"></path> </g> </svg> <a href="https://annieruygtillustration.com/" target="_blank"> Annie Ruygt </a> </figcaption> </figure> <p>Note, I&#39;m not saying that JavaScript is weird, though it <a href="https://wtfjs.com/">definitely is weird</a>. But that&#39;s not the point of this blog post.</p> <p>Bear with me, instead of starting with <em>how</em> JavaScript ecosystem is weird, I&#39;m going to start with <em>why</em> the JavaScript ecosystem is weird.</p> <h2 id="historical-background"><a href="#historical-background" aria-label="Anchor"></a>Historical Background</h2><p>Less that 10 years ago, JavaScript sucked bad. It had no imports, no classes, no async, no arrow functions, no template literals, no destructuring assignment, no default parameters, no rest/spread parameters. And the environment it predominately ran in, namely the browser&#39;s DOM, sucked too. <a href="https://jquery.com/">JQuery</a> made it suck less. It still sucked, but was — at that point in time — relatively sane.</p> <p>Bundling JS to run in the browser was the first sign of weirdness. In that process you would also want to both minimize and tree shake the source, and perhaps even code split. In general the process involved reading a number of JavaScript sources as input and then producing one or more JavaScript sources as output. This meant that the code you were executing wasn&#39;t the code you wrote. <a href="https://sourcemaps.info/spec.html">Sourcemaps</a> helped.</p> <p>Then <a href="https://coffeescript.org/">CoffeeScript</a> came along. Instead of writing in JavaScript, you would write in a language which was compiled into JavaScript. This is a bit different than languages like <a href="https://elixir-lang.org/">Elixir</a> and <a href="https://kotlinlang.org/">Kotlin</a> which compile into the same byte codes as another language, CoffeeScript actually compiles into the other language. C++ started out this way.</p> <p>Then came ECMAScript 6 in 2015. JavaScript improved rapidly in the next few years. This eventually mostly displaced CoffeeScript, but presented a different problem: for a while the implementations were not keeping up so <em>transpilers</em> like <a href="https://babeljs.io/">Babel</a> came along that compiled current and future versions of JavaScript into older versions of JavaScript that ran on supported environments. Currently <a href="https://esbuild.github.io/">esbuild</a> is rapidly rising in popularity as a Javascript bundler/transpiler.</p> <p>Along the way, <a href="https://emscripten.org/">emscripten</a> came along which compiled actual machine code into a subset of JavaScript, though these days the new target for this tool is generally <a href="https://webassembly.org/">Wasm.</a></p> <p>Lately the pace of innovation in JavaScript has slowed, and JavaScript implementations are doing a better job of keeping up, so you would think that the need for transpilers would be waning, particularly on the server side where there is no need for bundlers. But that&#39;s not happening. And the reason why is an interesting story.</p> <h2 id="nobody-writes-javascript-any-more"><a href="#nobody-writes-javascript-any-more" aria-label="Anchor"></a>Nobody Writes JavaScript Any More</h2><p>OK, the title above is clearly hyperbole, but I&#39;ll describe a number of the many ways that people aren&#39;t writing JavaScript any more.</p> <p>If you write a Rails application, you write it in Ruby. If you write a Django application, you write it in Python. Phoenix, Elixir. Lavavel, PHP. Rails gets a lot of flack for doing magic using meta-programming, and Elixir has macros, but all of the above stay within the boundaries of what can be done by the language.</p> <p>JavaScript, however, is different. While it nominally is standardized by <a href="https://tc39.es/">EMCA TC39</a>, if you are using a popular framework like <a href="https://nextjs.org/">Next.JS</a>, <a href="http://remix.run/">Remix</a>, or <a href="https://svelte.dev/">Svelte</a> you are <strong>not</strong> coding in <a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-262/">ECMAScript</a> as standardized by ECMA TC39. Four examples:</p> <ul> <li>Once upon a time, nearly 20 years ago, the ECMA committee standardized <a href="https://www-archive.mozilla.org/js/language/ECMA-357.pdf">E4X</a> that enabled XML to be treated as a data type. This lost favor, got deprecated and archived. Years later what once was Facebook (now Meta) had a similar need and invented <a href="https://facebook.github.io/jsx/">JSX</a>. It differs from E4X in that it compiles into JS. </li><li>One thing that ECMA TC39 has never standardized is type annotations. Undeterred, Microsoft did it anyway with <a href="https://www.typescriptlang.org/">TypeScript</a>. It, too, compiles into JS. </li><li>Svelte has their own <a href="https://www.npmjs.com/package/svelte">compiler</a> that even <a href="https://svelte.dev/docs#component-format-script-3-$-marks-a-statement-as-reactive">deliberately misuses the JavaScript label syntax</a> to enable marking a statement as reactive. </li><li>It doesn&#39;t stop there. When a bundler/transpiler encounters an import statement, they don&#39;t necessarily presume that the file being imported is JavaScript or even any of the variants mentioned above. If configured properly and you want to import a CSS or PNG file, it will <a href="https://esbuild.github.io/content-types/">happily do so for you</a>. </li></ul> <p>I mentioned earlier that Rails gets a lot of flack for its use of meta programming. Nobody bats an eye at any of the &#34;abuses&#34; of the JavaScript language mentioned above. The JavaScript ecosystem is a Big Tent party.</p> <h2 id="use-server"><a href="#use-server" aria-label="Anchor"></a>&#34;use Server&#34;;</h2><p>The latest <a href="https://github.com/reactjs/rfcs/blob/main/text/0188-server-components.md#adoption-strategy">abuse of the bundler</a> is by <a href="https://legacy.reactjs.org/blog/2020/12/21/data-fetching-with-react-server-components.html">React Server Components (RSC)</a>. First <a href="https://github.com/reactjs/server-components-demo">demoed with express</a>, it is now adopted by <a href="https://nextjs.org/docs/getting-started/react-essentials#server-components">Next.js</a>.</p> <p>What &#34;<code>use server&#34;</code> and <code>&#34;use client&#34;</code> do, other than being a valid JavaScript statements that do absolutely nothing, is change the meaning of the code that follows them. This has gotten mixed reviews, but in my mind is very much in the spirit of <code>&#34;use strict&#34;</code>which also changes the meaning of the code that follows.</p> <p>While JSX often compiles to JS, the <a href="https://react.dev/reference/react-dom/server">Server React DOM APIs</a> enable compilation to HTML. RSC goes a different way, and compiles into a <a href="https://www.plasmic.app/blog/how-react-server-components-work">stream of tagged JSON</a>. This is all very transparent to you, but what it does enable is a <a href="https://twitter.com/levelsio/status/1654053489004417026">different style of programming. One that many are comparing to PHP</a> and even Rails:</p> <p><a href="https://twitter.com/wobsoriano/status/1654181584357019649"><img src="https://pbs.twimg.com/media/FvTVW3taUAEc1PM?format=jpg&amp;name=medium"/></a> <a href="https://twitter.com/jaredpalmer/status/1654178077356720164"><img src="https://pbs.twimg.com/media/FvTSI9TacAAQ0rg?format=png&amp;name=medium"/></a> <a href="https://twitter.com/jeremyopendata/status/1654297213781131266"><img src="https://pbs.twimg.com/media/FvU-T0iWwAIj6i5?format=jpg&amp;name=medium"/></a></p> <p>It is not clear to me whether these comparisons are meant in a positive way, but I will say that from my perspective it is a very good thing.</p> <p>From a fly.io perspective, RSC enabling an <a href="https://github.com/reactjs/rfcs/blob/main/text/0188-server-components.md#update-refetch-sequence">Update (Refetch) Sequence</a> is very much of interest. We&#39;ve always been especially shiny for frameworks that benefit from geographic distribution, like Elixir&#39;s <a href="https://fly.io/blog/how-we-got-to-liveview/">LiveView</a>, Laravel&#39;s <a href="https://laravel-livewire.com/">Livewire</a> and Ruby on Rail&#39;s <a href="https://hotwired.dev/">Hotwire</a>. We want those kinds of frameworks to succeed, because the better they do, the more valuable we are. Now we can add React&#39;s RSC to that list.</p> <p>Returning to the topic at hand, the fact that such a feature is only made possible through cooperation with bundlers — a statement tantamount to saying a change to the JavaScript language itself — is profound and, dare I say it, delightful.</p> <h2 id="another-dimension"><a href="#another-dimension" aria-label="Anchor"></a>Another Dimension</h2><p>Dan Abramov gave a talk at RemixConf entitled <u>React from Another Dimension</u>:</p> <div> <p> <iframe width="100%" height="100%" src="https://www.youtube.com/embed/wobP9yhrmhQ?start=21085&amp;end=23591" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""> </iframe></p></div><p>In Dan&#39;s talk he imagines an alternate universe in which React was first implemented in the late 90s on the server and still managed to converge to where it is today. During the talk he launches a Windows 95 emulator and runs Internet Explorer (specifically, IE6) with React. He even manages to get nine out of ten steps working using that operating system and browser combination.</p> <p>The mind bending parts of this presentation are where he first utilizes <code>use server</code> to implement a client side form action, and then later launches a client side alert from the server using <code>use client</code>.</p> <p>And he closes by saying that this requires new generation routers and new generation bundlers.</p> <p>And to think all of this is made possible by the fact that the JavaScript you write not only isn&#39;t the JavaScript you run, but under closer examination isn&#39;t even JavaScript at all.</p>  </section> <dl> <dt> Previous post  ↓ </dt> <dd> <a href="https://fly.io/blog/deploying-langchain-to-fly-io/"> Deploying LangChain to Fly.io </a> </dd> </dl> </article></div>
  </body>
</html>
