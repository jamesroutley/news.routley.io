<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/RyanWelly/lisp-in-rs-macros">Original</a>
    <h1>Lisp implemented in Rust macros</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">A simple, lexically scoped Lisp interpreter that operates fully in Rust&#39;s declarative macros. The <code>lisp!</code> macro expands to the lisp value computed by the code, and then stringifies it. This means that <code>lisp!(CAR (CONS (QUOTE A) (QUOTE (B))))</code> expands to the string &#34;A&#34; and that all this computation happens at compile time by rustc expanding macros.</p>

<p dir="auto">It&#39;s a lisp interpreter written fully in Rust&#39;s macros, I think that&#39;s pretty cool. It&#39;s also less than 250 lines, which is neat.</p>

<div dir="auto" data-snippet-clipboard-copy-content="let output = lisp!(CAR (LIST (QUOTE A) (QUOTE B) (QUOTE C)));
assert_eq!(output, &#34;A&#34;); 

lisp!(PROGN
    (DEFINE message (LAMBDA () (QUOTE &#34;hello there&#34;)))
    (DISPLAY (message))
    (DEFINE NOT (LAMBDA (X) (COND (X NIL) (TRUE TRUE))) )
    (DISPLAY (NOT NIL))
); // will print &#34;hello there&#34; and &#34;TRUE&#34;
// &#34;DISPLAY&#34; forms first evaluate their arguments, then expand to a println!(&#34;{}&#34;, stringify!(evaled_argument))
"><pre><span>let</span> output = <span>lisp</span><span>!</span><span>(</span><span>CAR</span> <span>(</span><span>LIST</span> <span>(</span><span>QUOTE</span> <span>A</span><span>)</span> <span>(</span><span>QUOTE</span> <span>B</span><span>)</span> <span>(</span><span>QUOTE</span> <span>C</span><span>)</span><span>)</span><span>)</span><span>;</span>
<span>assert_eq</span><span>!</span><span>(</span>output, <span>&#34;A&#34;</span><span>)</span><span>;</span> 

<span>lisp</span><span>!</span><span>(</span><span>PROGN</span>
    <span>(</span><span>DEFINE</span> message <span>(</span><span>LAMBDA</span> <span>(</span><span>)</span> <span>(</span><span>QUOTE</span> <span>&#34;hello there&#34;</span><span>)</span><span>)</span><span>)</span>
    <span>(</span><span>DISPLAY</span> <span>(</span>message<span>)</span><span>)</span>
    <span>(</span><span>DEFINE</span> <span>NOT</span> <span>(</span><span>LAMBDA</span> <span>(</span><span>X</span><span>)</span> <span>(</span><span>COND</span> <span>(</span><span>X</span> <span>NIL</span><span>)</span> <span>(</span><span>TRUE</span> <span>TRUE</span><span>)</span><span>)</span><span>)</span> <span>)</span>
    <span>(</span><span>DISPLAY</span> <span>(</span><span>NOT</span> <span>NIL</span><span>)</span><span>)</span>
<span>)</span><span>;</span> <span>// will print &#34;hello there&#34; and &#34;TRUE&#34;</span>
<span>// &#34;DISPLAY&#34; forms first evaluate their arguments, then expand to a println!(&#34;{}&#34;, stringify!(evaled_argument))</span></pre></div>
<p dir="auto">As another fun example, here is a quine:</p>
<div dir="auto" data-snippet-clipboard-copy-content="lisp!
       ((LAMBDA (s) (LIST s (LIST (QUOTE QUOTE) s)))
       (QUOTE (LAMBDA (s) (LIST s (LIST (QUOTE QUOTE) s)))));"><pre><span>lisp</span><span>!</span>
       <span>(</span><span>(</span><span>LAMBDA</span> <span>(</span>s<span>)</span> <span>(</span><span>LIST</span> s <span>(</span><span>LIST</span> <span>(</span><span>QUOTE</span> <span>QUOTE</span><span>)</span> s<span>)</span><span>)</span><span>)</span>
       <span>(</span><span>QUOTE</span> <span>(</span><span>LAMBDA</span> <span>(</span>s<span>)</span> <span>(</span><span>LIST</span> s <span>(</span><span>LIST</span> <span>(</span><span>QUOTE</span> <span>QUOTE</span><span>)</span> s<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>;</span></pre></div>
<p dir="auto">This code expands to:</p>
<div dir="auto" data-snippet-clipboard-copy-content="stringify!(((LAMBDA (s) (LIST s (LIST (QUOTE QUOTE) s)))
       (QUOTE (LAMBDA (s) (LIST s (LIST (QUOTE QUOTE) s))))));"><pre><span>stringify</span><span>!</span><span>(</span><span>(</span><span>(</span><span>LAMBDA</span> <span>(</span>s<span>)</span> <span>(</span><span>LIST</span> s <span>(</span><span>LIST</span> <span>(</span><span>QUOTE</span> <span>QUOTE</span><span>)</span> s<span>)</span><span>)</span><span>)</span>
       <span>(</span><span>QUOTE</span> <span>(</span><span>LAMBDA</span> <span>(</span>s<span>)</span> <span>(</span><span>LIST</span> s <span>(</span><span>LIST</span> <span>(</span><span>QUOTE</span> <span>QUOTE</span><span>)</span> s<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>;</span></pre></div>
<p dir="auto">In other words, the code evaluates to itself. Isn&#39;t that wonderful?</p>

<p dir="auto">This lisp does not currently support any explicit form of recursion. Luckily, explicit recursion is not needed, all we need is lambda.</p>
<p dir="auto">You can write a simple function that appends two lists by using self application:</p>
<div dir="auto" data-snippet-clipboard-copy-content="lisp!(PROGN
(DEFINE append 
    (LAMBDA (self X Y) 
        (COND 
            ((EQ X NIL) Y) 
            (TRUE (CONS (CAR X) (self self (CDR X) Y))) 
        )))
(append append (QUOTE (A B)) (QUOTE (C D)))

)"><pre><span>lisp</span><span>!</span><span>(</span><span>PROGN</span>
<span>(</span><span>DEFINE</span> append 
    <span>(</span><span>LAMBDA</span> <span>(</span><span>self</span> <span>X</span> <span>Y</span><span>)</span> 
        <span>(</span><span>COND</span> 
            <span>(</span><span>(</span><span>EQ</span> <span>X</span> <span>NIL</span><span>)</span> <span>Y</span><span>)</span> 
            <span>(</span><span>TRUE</span> <span>(</span><span>CONS</span> <span>(</span><span>CAR</span> <span>X</span><span>)</span> <span>(</span><span>self</span> <span>self</span> <span>(</span><span>CDR</span> <span>X</span><span>)</span> <span>Y</span><span>)</span><span>)</span><span>)</span> 
        <span>)</span><span>)</span><span>)</span>
<span>(</span>append append <span>(</span><span>QUOTE</span> <span>(</span><span>A</span> <span>B</span><span>)</span><span>)</span> <span>(</span><span>QUOTE</span> <span>(</span><span>C</span> <span>D</span><span>)</span><span>)</span><span>)</span>

<span>)</span></pre></div>
<p dir="auto">This results in &#34;(A B C D)&#34;. The append function does not mention <code>append</code> in its body, yet we can call it recursively. Wonderful!</p>

<p dir="auto">The lisp! macro only evaluates a single expression; if you want to evaluate multiple expressions, use <code>(PROGN expr1 expr2 expr3)</code>. This evaluates all the expressions, and returns the value of the last expression. The DISPLAY form evaluates a single expression, then generates a <code>println!(&#34;{}&#34;, stringify!(...))</code> statement which prints the stringified version of the tokens. The empty list is not self evaluating, you can use <code>NIL</code> or <code>(QUOTE ())</code> to obtain an empty list value. The empty list is the sole &#34;falsy&#34; object.
Dotted lists aren&#39;t supported, cons assumes its last argument is a list. The define form can be used anywhere and evaluates to the empty list, but does not support recursion. TRUE is the only self evaluating atom (that isn&#39;t a function).</p>

<div dir="auto" data-snippet-clipboard-copy-content="DEFINE 
QUOTE 
LAMBDA 
LET
PROGN 
CAR 
CDR 
CONS
LIST
EQ
ATOM
APPLY"><pre><span>DEFINE</span> 
<span>QUOTE</span> 
<span>LAMBDA</span> 
<span>LET</span>
<span>PROGN</span> 
<span>CAR</span> 
<span>CDR</span> 
<span>CONS</span>
<span>LIST</span>
<span>EQ</span>
<span>ATOM</span>
<span>APPLY</span></pre></div>
<p dir="auto">Note: dotted lists are not supported, CONS assumes its latter argument is a list. Define does not handle recursive definitions, it&#39;s more like internal definitions in Scheme than a true lispy define.</p>

<p dir="auto">Here is a lisp interpreter written in my lisp:</p>
<div dir="auto" data-snippet-clipboard-copy-content="lisp!(PROGN
            // Y &#34;combinator&#34; for two arguments
        (DEFINE Y2 
                        (LAMBDA (h)
                            ((LAMBDA (x) (h (LAMBDA (a b) ((x x) a b))))
                                (LAMBDA (x) (h (LAMBDA (a b) ((x x) a b)))))))
        
        (DEFINE CADR (LAMBDA (X) (CAR (CDR X))))
        (DEFINE CAAR (LAMBDA (X) (CAR (CAR X))))
        (DEFINE CADAR (LAMBDA (X) (CAR (CDR (CAR X)))))
        (DEFINE CADDR (LAMBDA (X) (CAR (CDR (CDR X)))))
        (DEFINE CADDAR (LAMBDA (X) (CAR (CDR (CDR (CAR X))))))
        (DEFINE CAADAR (LAMBDA (X) (CAR (CAR (CDR (CAR X))))))

        (DEFINE ASSOC (Y2 (LAMBDA (ASSOC) (LAMBDA (X ENV) 
                        (IF (EQ (CAAR ENV) X) (CADAR ENV) (ASSOC X (CDR ENV)))
                    )))
                )


            
        (DEFINE eval (Y2 (LAMBDA (EVAL) (LAMBDA (E A) 
                (COND
                    ((ATOM E) (ASSOC E A))
                    ((ATOM (CAR E)) 
                        (COND 
                            ((EQ (CAR E) (QUOTE quote)) (CADR E))
                            ((EQ (CAR E) (QUOTE atom)) (ATOM (EVAL (CADR E) A)))
                            ((EQ (CAR E) (QUOTE car)) (CAR (EVAL (CADR E) A)))
                            ((EQ (CAR E) (QUOTE cdr)) (CDR (EVAL (CADR E) A)))
                            ((EQ (CAR E) (QUOTE equal)) (EQ (EVAL (CADR E) A) (EVAL (CADDR E) A)))
                            ((EQ (CAR E) (QUOTE cons)) (CONS (EVAL (CADR E) A) (EVAL (CADDR E) A)))
                            (TRUE (EVAL (CONS (ASSOC (CAR E) A) (CDR E)) A)) 
                        )
                    )
                    ((EQ (CAAR E) (QUOTE lambda)) (EVAL (CADDAR E) (CONS (LIST (CAADAR E) (EVAL (CADR E) A)) A)  )) //Evaluate the inner expression of the lambda, in the environment with the argument bound to the parameter
                
                )
            ))))

        (eval (QUOTE (quote (A))) NIL)
        // (eval (QUOTE (atom (quote A))) NIL )
        // (eval (QUOTE (cdr (cdr (quote (A B))))) NIL)
        // (eval (QUOTE (cons (quote a) (quote (a)))) NIL)
        // (eval (QUOTE ((lambda (x) (quote a)) (quote b))) NIL)
        (eval (QUOTE ((lambda (X) X) (quote a))) NIL)

        );"><pre><span>lisp</span><span>!</span><span>(</span><span>PROGN</span>
            <span>// Y &#34;combinator&#34; for two arguments</span>
        <span>(</span><span>DEFINE</span> <span>Y2</span> 
                        <span>(</span><span>LAMBDA</span> <span>(</span>h<span>)</span>
                            <span>(</span><span>(</span><span>LAMBDA</span> <span>(</span>x<span>)</span> <span>(</span>h <span>(</span><span>LAMBDA</span> <span>(</span>a b<span>)</span> <span>(</span><span>(</span>x x<span>)</span> a b<span>)</span><span>)</span><span>)</span><span>)</span>
                                <span>(</span><span>LAMBDA</span> <span>(</span>x<span>)</span> <span>(</span>h <span>(</span><span>LAMBDA</span> <span>(</span>a b<span>)</span> <span>(</span><span>(</span>x x<span>)</span> a b<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
        
        <span>(</span><span>DEFINE</span> <span>CADR</span> <span>(</span><span>LAMBDA</span> <span>(</span><span>X</span><span>)</span> <span>(</span><span>CAR</span> <span>(</span><span>CDR</span> <span>X</span><span>)</span><span>)</span><span>)</span><span>)</span>
        <span>(</span><span>DEFINE</span> <span>CAAR</span> <span>(</span><span>LAMBDA</span> <span>(</span><span>X</span><span>)</span> <span>(</span><span>CAR</span> <span>(</span><span>CAR</span> <span>X</span><span>)</span><span>)</span><span>)</span><span>)</span>
        <span>(</span><span>DEFINE</span> <span>CADAR</span> <span>(</span><span>LAMBDA</span> <span>(</span><span>X</span><span>)</span> <span>(</span><span>CAR</span> <span>(</span><span>CDR</span> <span>(</span><span>CAR</span> <span>X</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
        <span>(</span><span>DEFINE</span> <span>CADDR</span> <span>(</span><span>LAMBDA</span> <span>(</span><span>X</span><span>)</span> <span>(</span><span>CAR</span> <span>(</span><span>CDR</span> <span>(</span><span>CDR</span> <span>X</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
        <span>(</span><span>DEFINE</span> <span>CADDAR</span> <span>(</span><span>LAMBDA</span> <span>(</span><span>X</span><span>)</span> <span>(</span><span>CAR</span> <span>(</span><span>CDR</span> <span>(</span><span>CDR</span> <span>(</span><span>CAR</span> <span>X</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
        <span>(</span><span>DEFINE</span> <span>CAADAR</span> <span>(</span><span>LAMBDA</span> <span>(</span><span>X</span><span>)</span> <span>(</span><span>CAR</span> <span>(</span><span>CAR</span> <span>(</span><span>CDR</span> <span>(</span><span>CAR</span> <span>X</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>

        <span>(</span><span>DEFINE</span> <span>ASSOC</span> <span>(</span><span>Y2</span> <span>(</span><span>LAMBDA</span> <span>(</span><span>ASSOC</span><span>)</span> <span>(</span><span>LAMBDA</span> <span>(</span><span>X</span> <span>ENV</span><span>)</span> 
                        <span>(</span><span>IF</span> <span>(</span><span>EQ</span> <span>(</span><span>CAAR</span> <span>ENV</span><span>)</span> <span>X</span><span>)</span> <span>(</span><span>CADAR</span> <span>ENV</span><span>)</span> <span>(</span><span>ASSOC</span> <span>X</span> <span>(</span><span>CDR</span> <span>ENV</span><span>)</span><span>)</span><span>)</span>
                    <span>)</span><span>)</span><span>)</span>
                <span>)</span>


            
        <span>(</span><span>DEFINE</span> eval <span>(</span><span>Y2</span> <span>(</span><span>LAMBDA</span> <span>(</span><span>EVAL</span><span>)</span> <span>(</span><span>LAMBDA</span> <span>(</span><span>E</span> <span>A</span><span>)</span> 
                <span>(</span><span>COND</span>
                    <span>(</span><span>(</span><span>ATOM</span> <span>E</span><span>)</span> <span>(</span><span>ASSOC</span> <span>E</span> <span>A</span><span>)</span><span>)</span>
                    <span>(</span><span>(</span><span>ATOM</span> <span>(</span><span>CAR</span> <span>E</span><span>)</span><span>)</span> 
                        <span>(</span><span>COND</span> 
                            <span>(</span><span>(</span><span>EQ</span> <span>(</span><span>CAR</span> <span>E</span><span>)</span> <span>(</span><span>QUOTE</span> quote<span>)</span><span>)</span> <span>(</span><span>CADR</span> <span>E</span><span>)</span><span>)</span>
                            <span>(</span><span>(</span><span>EQ</span> <span>(</span><span>CAR</span> <span>E</span><span>)</span> <span>(</span><span>QUOTE</span> atom<span>)</span><span>)</span> <span>(</span><span>ATOM</span> <span>(</span><span>EVAL</span> <span>(</span><span>CADR</span> <span>E</span><span>)</span> <span>A</span><span>)</span><span>)</span><span>)</span>
                            <span>(</span><span>(</span><span>EQ</span> <span>(</span><span>CAR</span> <span>E</span><span>)</span> <span>(</span><span>QUOTE</span> car<span>)</span><span>)</span> <span>(</span><span>CAR</span> <span>(</span><span>EVAL</span> <span>(</span><span>CADR</span> <span>E</span><span>)</span> <span>A</span><span>)</span><span>)</span><span>)</span>
                            <span>(</span><span>(</span><span>EQ</span> <span>(</span><span>CAR</span> <span>E</span><span>)</span> <span>(</span><span>QUOTE</span> cdr<span>)</span><span>)</span> <span>(</span><span>CDR</span> <span>(</span><span>EVAL</span> <span>(</span><span>CADR</span> <span>E</span><span>)</span> <span>A</span><span>)</span><span>)</span><span>)</span>
                            <span>(</span><span>(</span><span>EQ</span> <span>(</span><span>CAR</span> <span>E</span><span>)</span> <span>(</span><span>QUOTE</span> equal<span>)</span><span>)</span> <span>(</span><span>EQ</span> <span>(</span><span>EVAL</span> <span>(</span><span>CADR</span> <span>E</span><span>)</span> <span>A</span><span>)</span> <span>(</span><span>EVAL</span> <span>(</span><span>CADDR</span> <span>E</span><span>)</span> <span>A</span><span>)</span><span>)</span><span>)</span>
                            <span>(</span><span>(</span><span>EQ</span> <span>(</span><span>CAR</span> <span>E</span><span>)</span> <span>(</span><span>QUOTE</span> cons<span>)</span><span>)</span> <span>(</span><span>CONS</span> <span>(</span><span>EVAL</span> <span>(</span><span>CADR</span> <span>E</span><span>)</span> <span>A</span><span>)</span> <span>(</span><span>EVAL</span> <span>(</span><span>CADDR</span> <span>E</span><span>)</span> <span>A</span><span>)</span><span>)</span><span>)</span>
                            <span>(</span><span>TRUE</span> <span>(</span><span>EVAL</span> <span>(</span><span>CONS</span> <span>(</span><span>ASSOC</span> <span>(</span><span>CAR</span> <span>E</span><span>)</span> <span>A</span><span>)</span> <span>(</span><span>CDR</span> <span>E</span><span>)</span><span>)</span> <span>A</span><span>)</span><span>)</span> 
                        <span>)</span>
                    <span>)</span>
                    <span>(</span><span>(</span><span>EQ</span> <span>(</span><span>CAAR</span> <span>E</span><span>)</span> <span>(</span><span>QUOTE</span> lambda<span>)</span><span>)</span> <span>(</span><span>EVAL</span> <span>(</span><span>CADDAR</span> <span>E</span><span>)</span> <span>(</span><span>CONS</span> <span>(</span><span>LIST</span> <span>(</span><span>CAADAR</span> <span>E</span><span>)</span> <span>(</span><span>EVAL</span> <span>(</span><span>CADR</span> <span>E</span><span>)</span> <span>A</span><span>)</span><span>)</span> <span>A</span><span>)</span>  <span>)</span><span>)</span> <span>//Evaluate the inner expression of the lambda, in the environment with the argument bound to the parameter</span>
                
                <span>)</span>
            <span>)</span><span>)</span><span>)</span><span>)</span>

        <span>(</span>eval <span>(</span><span>QUOTE</span> <span>(</span>quote <span>(</span><span>A</span><span>)</span><span>)</span><span>)</span> <span>NIL</span><span>)</span>
        <span>// (eval (QUOTE (atom (quote A))) NIL )</span>
        <span>// (eval (QUOTE (cdr (cdr (quote (A B))))) NIL)</span>
        <span>// (eval (QUOTE (cons (quote a) (quote (a)))) NIL)</span>
        <span>// (eval (QUOTE ((lambda (x) (quote a)) (quote b))) NIL)</span>
        <span>(</span>eval <span>(</span><span>QUOTE</span> <span>(</span><span>(</span>lambda <span>(</span><span>X</span><span>)</span> <span>X</span><span>)</span> <span>(</span>quote a<span>)</span><span>)</span><span>)</span> <span>NIL</span><span>)</span>

        <span>)</span><span>;</span></pre></div>
<p dir="auto">It appears to work, but trying to evaluate <code>((lambda (X) X) (quote a))</code> in the interpreter takes more than 30 seconds and generates far more than a million tokens before cargo gets sigkilled. Using the explicit y combinator for recursion isn&#39;t particularly efficient here! To fix this, I should add an explicit recursion primitive. If you want a wonderful walktrhough of how to write something like a metacircular evaluator, Paul Graham&#39;s &#34;Roots of Lisp&#34; is awesome.</p>

<p dir="auto">Look at EXPLANATION.md. The macro essentially simulates a SECD machine, which is a simple stack-basd abstract machine for evaulating lambda calculus terms.</p>

<ul dir="auto">
<li>Functional Programming: Application and Implementation by Peter Henderson</li>
<li>Ager, Mads Sig, et al. &#34;A functional correspondence between evaluators and abstract machines.&#34; Proceedings of the 5th ACM SIGPLAN international conference on Principles and practice of declaritive programming. 2003.</li>
<li>The Implementation of Functional Programming Languages by Simon Peyton Jones</li>
<li>Anything Matt Might has ever written about lisp on his blog (<a href="https://matt.might.net" rel="nofollow">https://matt.might.net</a>)</li>
</ul>

<ul dir="auto">
<li>Add letrec</li>
<li>Add recursive defines</li>
</ul>
</article></div></div>
  </body>
</html>
