<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://lock.cmpxchg8b.com/symbols.html">Original</a>
    <h1>Unstripping Stripped Binaries</h1>
    
    <div id="readability-page-1" class="page">

<nav id="TOC">
<ul>
<li><a href="#intro">Intro</a></li>
<li><a href="#debugging">Debugging</a></li>
<li><a href="#stabs">Stabs</a><ul>
<li><a href="#tools">Tools</a></li>
</ul></li>
<li><a href="#examples">Examples</a></li>
<li><a href="#parameters">Parameters</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#symbol-porting">Symbol Porting</a><ul>
<li><a href="#string-references">String References</a></li>
<li><a href="#cfg">CFG</a></li>
</ul></li>
</ul>
</nav>
<section id="intro">

<p>I‚Äôve written before about how much I enjoy vintage software. Lately I‚Äôve been tinkering with <a href="https://github.com/taviso/wpunix">WordPerfect for UNIX</a>.</p>
<p>It‚Äôs working great, combined with <a href="https://github.com/taviso/123elf/">Lotus 1-2-3</a> you can have a full-featured office suite in an xterm! üòÇ</p>
<blockquote>
<p><a href="https://github.com/taviso/wpunix"><img src="http://lock.cmpxchg8b.com/img/wp-preview.gif" alt="WordPerfect"/></a></p>
</blockquote>
</section>
<section id="debugging">

<p>These are 30 year old stripped binaries that I‚Äôve somehow managed to patch into a working state. As you can imagine, when something doesn‚Äôt work, tracking down what went wrong can be a real challenge.</p>
<p>What I <em>really</em> want is to take the names and types I‚Äôve figured out from my disassembler, and make them visible to gdb.</p>
<p>I‚Äôve found a simple solution to this that‚Äôs been working well for me, here are some notes on it.</p>
</section>
<section id="stabs">

<p>You‚Äôre probably familiar with <a href="https://dwarfstd.org/">DWARF</a>, the debugging format used everywhere in Linux. DWARF is really neat, it‚Äôs capable of expressing the most complex locations and types possible.</p>
<p>In this context, ‚Äúlocation‚Äù means explaining to a debugger how to find a variable. In some cases that‚Äôs really easy, but it gets complicated fast. Perhaps the variable moves in and out of registers or requires complex address calculation logic (e.g.¬†a bitfield struct member stored in a stack frame).</p>
<p>Figuring out these locations requires the debugger to execute little bytecode programs called DWARF expressions ‚Äì crazy stuff!</p>
<p>Before DWARF, STABS (Symbol TABle Strings), was the predominant debugging format. STABS takes simple locations and types, encodes them into strings, and then stuffs them into the symbol table. It‚Äôs not very elegant, but it worked.</p>
<p>STABS is entirely obsolete, DWARF is superior in every way. However‚Ä¶ STABS does have one benefit that DWARF doesn‚Äôt ‚Äì expressing simple stuff (<em>very</em> simple) is so easy you can even do it by hand‚Ä¶</p>
<section id="tools">
<h2>Tools</h2>
<p>All the GNU tools still have native support for STABS. In fact, I‚Äôve noticed the GNU assembler even has pseudo-instructions that you can write manually:</p>
<p><a href="https://sourceware.org/binutils/docs/as/Stab.html">https://sourceware.org/binutils/docs/as/Stab.html</a>:</p>
<blockquote>
<p>There are three directives that begin ‚Äò.stab‚Äô. All emit symbols (see Symbols), for use by symbolic debuggers. Up to five fields are required:</p>
<p><strong>string</strong> </p>
<p><strong>type</strong> </p>
<p>[‚Ä¶]</p>
<p><strong>value</strong> </p>
</blockquote>
<p>If you just want basic native types and simple locations, nothing could be simpler than this.</p>
</section>
</section>
<section id="examples">

<p>Let‚Äôs say I‚Äôve figured out there is a function at <code>0x8005bba</code> like this:</p>

<p>The stab to declare that is just this:</p>
<pre><code>.stabs &#34;example:f-11&#34;, N_FUN, 0, 0, 0x8005bba</code></pre>
<p>Here <code>f</code> means this is a function, and <code>-11</code> is the pre-defined type for void. If you only want to use basic types, you don‚Äôt even have to define them!</p>
<p>Here is a list of some of the predefined types that GDB recognizes:</p>
<table>
<thead>
<tr>
<th>Num</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>-1</td>
<td>int, 32 bit signed integral type.</td>
</tr>
<tr>
<td>-2</td>
<td>char, 8 bit type holding a character.</td>
</tr>
<tr>
<td>-4</td>
<td>long, 32 bit signed integral type.</td>
</tr>
<tr>
<td>-5</td>
<td>unsigned char, 8 bit unsigned integral type.</td>
</tr>
<tr>
<td>-6</td>
<td>signed char, 8 bit signed integral type.</td>
</tr>
<tr>
<td>-7</td>
<td>unsigned short, 16 bit unsigned integral type.</td>
</tr>
<tr>
<td>-8</td>
<td>unsigned int, 32 bit unsigned integral type.</td>
</tr>
<tr>
<td>-9</td>
<td>unsigned, 32 bit unsigned integral type.</td>
</tr>
<tr>
<td>-10</td>
<td>unsigned long, 32 bit unsigned integral type.</td>
</tr>
<tr>
<td>-11</td>
<td>void, type indicating the lack of a value.</td>
</tr>
<tr>
<td>-31</td>
<td>long long, 64 bit signed integral type.</td>
</tr>
<tr>
<td>-32</td>
<td>unsigned long long, 64 bit unsigned integral type.</td>
</tr>
</tbody>
</table>
<p>There are some confusing choices in there, but there are about 30 predefined types that GDB knows about.</p>
<p>Notice I said ‚Äúknows about‚Äù, that‚Äôs because there is no STABS standard, just analyses of what crazy incompatible things all the 90s UNIX vendors were doing!</p>
<p>This cygnus document on stabs is great; it‚Äôs well written and thorough, but occasional glimpses of frustration with Sun and IBM for their incompatible undocumented extensions seep through.</p>
<p><a href="https://sourceware.org/gdb/onlinedocs/stabs.pdf">https://sourceware.org/gdb/onlinedocs/stabs.pdf</a></p>
</section>
<section id="parameters">

<p>Okay, functions are working, what about function parameters? If they‚Äôre one of the predefined types and this is a standard <a href="https://en.wikipedia.org/wiki/Cdecl#cdecl">cdecl</a> function, that‚Äôs easy too!</p>
<pre><code>.stabs &#34;foo:p*-8&#34;, N_PSYM, 0, 0, 8
.stabs &#34;bar:p-10&#34;, N_PSYM, 0, 0, 12</code></pre>
<p>This means there is a parameter <code>foo</code>, a pointer to an unsigned int at <code>bp+8</code> and an unsigned long called <code>bar</code> at <code>bp+12</code>.</p>
<p>I wrote some gas macros to make this less laborious, and now I can just write this:</p>
<pre><code>function main, 0x8128000, %int
    param argc, %int
    param argv, ** %char
    param envp, ** %char</code></pre>
<p>Pretty neat!</p>
<p>You don‚Äôt even need to specify the offset ‚Äì gas macros can store counters between invocations, so I just keep incrementing it for each new parameter, then reset it when you start a new function!</p>
<p>They‚Äôre really simple, they look like this (some code ommitted):</p>
<div id="cb5"><pre><code><a id="cb5-1" title="1">.<span>macro</span> <span>function</span> name, address, ptr=, type</a>
<a id="cb5-2" title="2">    .<span>set</span> _arg, <span>0</span></a>
<a id="cb5-3" title="3">    .<span>stabs</span> <span>&#34;</span><span>\n</span><span>ame:f\ptr</span><span>\t</span><span>ype&#34;</span>, N_FUN, <span>0</span>, <span>0</span>, \address</a>
<a id="cb5-4" title="4">.<span>endm</span></a>
<a id="cb5-5" title="5"></a>
<a id="cb5-6" title="6">.<span>macro</span> param name, ptr=, type</a>
<a id="cb5-7" title="7">    .<span>set</span> _arg, _arg + <span>1</span></a>
<a id="cb5-8" title="8">    .<span>stabs</span> <span>&#34;</span><span>\n</span><span>ame:p\ptr</span><span>\t</span><span>ype&#34;</span>, N_PSYM, <span>0</span>, <span>0</span>, PARAM_SIZE+_arg*PARAM_SIZE</a>
<a id="cb5-9" title="9">.<span>endm</span></a></code></pre></div>
<p>It works great, here is a sample gdb session. You can see I set breakpoints, examine values, print types, and so on.</p>
<pre><code>(gdb) add-symbol-file symbols.dbg
(gdb) pt rddec
type = boolean (char **, unsigned short *)
(gdb) x/i rddec
0x81dac90 &lt;rddec&gt;:   push   ebp
(gdb) b rddec
Breakpoint 1 at 0x81dac96
(gdb) c
Breakpoint 1, 0x081dac96 in rddec (numstr=0xffffc044, num=0x8350dbe)
(gdb) pt numstr
type = char **
(gdb) p *numstr
$1 = 0xffffc048 &#34;06&#34;</code></pre>
<p>Even conditional breakpoints on parameter values work, it‚Äôs just like unstripping the binary.</p>
<p>In order to get a symbol file, I assemble them like this:</p>
<pre><code>$ as --32 -gstabs -o wp.o wp.s
$ as --32 -gstabs -o types.o types.s
$ ld -m elf_i386 -shared -Tdata=082d7938 -Ttext=0804a5f0 -Tbss=083377c0 -o wp.dbg wp.o types.o
$ strip --only-keep-debug wp.dbg</code></pre>
<p>It‚Äôs important to have the sections lined up with the target binary, or gdb will get confused.</p>
<p>Now you can just do this:</p>
<pre><code>(gdb) add-symbol-file wp.dbg
add symbol table from file &#34;wp.dbg&#34;
Reading symbols from wp.dbg...</code></pre>
<p>I haven‚Äôt tried it, but I bet <code>objcopy --add-gnu-debuglink</code> would work too!</p>
</section>
<section id="usage">

<p>I can write these symbols manually when I need to, but also wrote a quick script to export these from my disassembler.</p>
<p>The output is just thousands of lines like this:</p>
<pre><code>function g_init, 0x0815EFA0, %int
function dflt_init, 0x0815F1A0, %int
function tool_init, 0x0815F620, %int
function g_close, 0x0815F630, %int
function g_inits, 0x0815F710, %int
function g_dint, 0x0815F720, %int
function g_dot, 0x0815F730, %int
function sub_8160290, 0x08160290, * %void</code></pre>
<p>Putting it all together, my stripped binary now has symbols and parameter information in gdb, woohoo!</p>
<pre><code>Breakpoint 2, 0x0815f1b9 in dflt_init ()
(gdb) bt
#0  0x0815f1b9 in dflt_init ()
#1  0x0815f02a in g_init ()
#2  0x0815acfc in int_dsp_xxx ()
#3  0x0814f8ad in gshow_init ()</code></pre>
</section>
<section id="symbol-porting">

<p>I actually have a huge advantage here that I didn‚Äôt mention.</p>
<p>After a few of hours digging around on <a href="https://archive.org/">archive.org</a>, I found a binary for an older version of WordPerfect that wasn‚Äôt stripped! It must have been a mistake while building the final <abbr title="Release To
Manufacturing">RTM</abbr> binaries.</p>
<pre><code>$ ls -l wp
-rw------- 1 taviso taviso 4.5M Jul 31  1996 wp
$ file wp
wp: ELF 32-bit MSB executable, SPARC, version 1 (SYSV), dynamically linked, interpreter /usr/lib/ld.so.1, not stripped</code></pre>
<p>Unfortunately it‚Äôs not only an older version, but also for a different architecture and operating system, Solaris SPARC. <a href="https://www.zynamics.com/bindiff.html">BinDiff</a> does do pretty well at matching these symbols to my i386 binary.</p>
<p>I‚Äôve found that people are sometimes surprised this works! Most of the clever tricks BinDiff uses to match functions between two binaries are actually architecture neutral. That means that If you have a stripped binary for ARM and an unstripped version of the same binary for MIPS, BinDiff can figure out which functions are which for you.</p>
<section id="string-references">
<h2>String References</h2>
<p>Some of the techniques used are easy to understand, like string reference matching. If only a single function references the string ‚Äúerror in function foo‚Äù, then it doesn‚Äôt matter if it‚Äôs SPARC or x86, clearly this is the same function, so you just learned a symbol name!</p>
</section>
<section id="cfg">
<h2>CFG</h2>
<p>It‚Äôs rare it‚Äôs that easy though, and BinDiff is full of insanely clever tricks. Many of them involve <abbr title="Control Flow Graph">CFG</abbr> matching.</p>
<p>If you generate a graph of all the function calls in two similar binaries, there should be lots of matches.</p>
<p>If function <code>foo</code> calls function <code>bar</code>, which calls function <code>baz</code> and <code>quux</code>. Then you don‚Äôt need to know what architecture this is or what the functions do, if you find the same unique graph you can be confident these are the same functions!</p>
<p>These tricks combined have let me debug and track down some pretty gnarly issues!</p>
</section>
</section>



</div>
  </body>
</html>
