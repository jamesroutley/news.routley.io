<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eng.uber.com/data-race-patterns-in-go/">Original</a>
    <h1>Data Race Patterns in Go</h1>
    
    <div id="readability-page-1" class="page"><div>
            <!-- image -->
                                <p><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/coverphoto.webp" alt="Data Race Patterns in Go" title="Data Race Patterns in Go"/>
                                            </p>
            
            <p><span>Uber has </span><a href="https://eng.uber.com/go-monorepo-bazel/"><span>adopted</span></a><span> Golang (Go for short) as a primary programming language for developing microservices. Our Go monorepo consists of about 50 million lines of code (and growing) and contains approximately 2,100 unique Go services (and growing).</span></p>
<p><span>Go makes concurrency a first-class citizen; prefixing function calls with the </span><span>go</span><span> keyword runs the call asynchronously. These asynchronous function calls in Go are called goroutines. Developers hide latency (e.g., IO or RPC calls to other services) by creating goroutines. Two or more goroutines can communicate data either via message passing (</span><a href="https://go101.org/article/channel.html"><span>channels</span></a><span>) or </span><a href="https://en.wikipedia.org/wiki/Shared_memory#:~:text=In%20computer%20science%2C%20shared%20memory,of%20passing%20data%20between%20programs."><span>shared memory</span></a><span>. Shared memory happens to be the most commonly used means of data communication in Go.</span></p>
<p><span>Goroutines are considered “</span><a href="https://medium.com/the-polyglot-programmer/what-are-goroutines-and-how-do-they-actually-work-f2a734f6f991"><span>lightweight</span></a><span>” and since they are easy to create, Go programmers use goroutines liberally. As a result, we notice that </span><i><span>programs written in Go, typically, expose significantly more concurrency than programs written in other languages</span></i><span>. For example, by scanning hundreds of thousands of microservice instances running our data centers, we found out that Go microservices expose ~8x more concurrency compared to Java microservices. Higher concurrency also means potential for more concurrency bugs. A data race is a concurrency bug that occurs when two or more goroutines access the same datum, at least one of them is a write, and there is no ordering between them. Data races are insidious bugs and must be </span><a href="https://www.usenix.org/legacy/events/hotpar11/tech/final_files/Boehm.pdf"><span>avoided at all costs</span></a><span>.</span></p>
<p><span>We developed a system to detect data races at Uber using a dynamic data race detection technique. This system, over a period of six months, detected about 2,000 data races in our Go code base, of which our developers already fixed ~1,100 data races.</span></p>
<p><span>In this blog, we will show various data race patterns we found in our Go programs. This study was conducted by analyzing over 1,100 data races fixed by 210 unique developers over a six-month period. Overall, we noticed that Go makes it easier to introduce data races, due to certain language design choices. There is a complicated interplay between the language features and data races. </span></p>


<p><span>We investigated each of the ~1,100 data races fixed by our developers and bucketed them into different categories. Our study of these data races showed some common patterns and some arcane reasons that cause data races in Go:</span></p>
<h3><span><br/>
</span><span>1. Go’s design choice to </span><i><span>transparently</span></i><span> capture free variables </span><i><span>by reference</span></i><span> in goroutines is a recipe for data races</span></h3>
<p><span>Nested functions (a.k.a., </span><a href="https://go.dev/tour/moretypes/25"><span>closures</span></a><span>), in Go transparently capture all free variables by reference. The programmer does not explicitly specify which free variables are captured in the closure syntax.</span></p>
<p><span>This mode of usage is different from Java and C++. Java </span><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html"><span>lambdas</span></a><span> only capture by value and they consciously took that design choice to avoid concurrency bugs [</span><a href="https://www.baeldung.com/java-lambda-effectively-final-local-variables"><span>1</span></a><span>, </span><a href="http://www.lambdafaq.org/what-are-the-reasons-for-the-restriction-to-effective-immutability/"><span>2</span></a><span>]. C++ requires developers to </span><a href="https://en.cppreference.com/w/cpp/language/lambda"><span>explicitly specify</span></a><span> capture by value or by reference.</span></p>
<p><span>Developers are quite often unaware that a variable used inside a closure is a free variable and captured by reference, especially when the closure is large. More often than not, Go developers use closures as goroutines. As a result of capture-by-reference and goroutine concurrency, Go programs end up potentially having unordered accesses to free variables unless explicit synchronization is performed. We demonstrate this with the following three examples:</span></p>
<h6><strong><i>Example 1: Data race due to loop index variable capture</i></strong></h6>
<p><span>The code in Figure 1A shows iterating over a Go slice </span><span>jobs</span><span> and processing each element </span><span>job</span><span> via the </span><span>ProcessJob</span><span> function.</span></p>
<figure id="attachment_9549" aria-describedby="caption-attachment-9549"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure1a-1024x196.png" alt="" width="581" height="111" srcset="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure1a-1024x196.png 1024w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure1a-300x57.png 300w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure1a-768x147.png 768w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure1a-1536x294.png 1536w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure1a-696x133.png 696w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure1a-1068x204.png 1068w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure1a.png 1580w" sizes="(max-width: 581px) 100vw, 581px"/><figcaption id="caption-attachment-9549">Figure 1A: Data race due to loop index variable capture.</figcaption></figure>

<p><span>Here, the developer wraps the expensive </span><span>ProcessJob</span><span> in an anonymous goroutine that is launched once per item. However, the loop index variable </span><span>job</span><span> is captured by reference inside the goroutine. When the goroutine launched for the first loop iteration is accessing the </span><span>job</span><span> variable, the </span><span>for</span><span> loop in the parent goroutine will be advancing through the slice and updating the same loop-index variable </span><span>job</span><span> to point to the second element in the slice, causing a data race. This type of data race happens for value and reference types; slices, array, and maps; and read-only and write accesses in the loop body. Go recommends a coding idiom to hide and privatize the loop index variable in the loop body, which is not always followed by developers, unfortunately.</span></p>
<h6><strong><i>Example 2: Data race due to idiomatic err variable capture. </i></strong></h6>
<figure id="attachment_9550" aria-describedby="caption-attachment-9550"><img loading="lazy" src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure1b.png" alt="" width="440" height="227" srcset="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure1b.png 1572w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure1b-300x155.png 300w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure1b-1024x528.png 1024w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure1b-768x396.png 768w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure1b-1536x791.png 1536w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure1b-696x359.png 696w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure1b-1068x550.png 1068w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure1b-815x420.png 815w" sizes="(max-width: 440px) 100vw, 440px"/><figcaption id="caption-attachment-9550">Figure 1B: Data race due to idiomatic “err” variable capture.</figcaption></figure>

<p><span>Go </span><a href="https://www.digitalocean.com/community/tutorials/handling-errors-in-go"><span>advocates multiple return values</span></a><span> from functions. It is common to return the actual return value(s) and an error object to indicate if there was an error as shown in Figure 1B. The actual return value is considered to be meaningful if and only if the error value is </span><span>nil</span><span>. It is a common practice to assign the returned error object to a variable named </span><span>err</span><span> followed by checking for its nilness. However, since multiple error-returning functions can be called inside a function body, there will be several assignments to the </span><span>err</span><span> variable followed by the nilness check each time. When developers mix this idiom with a goroutine, the </span><span>err</span><span> variable gets captured by reference in the closure. As a result, the accesses (both read and write) to </span><span>err</span><span> in the goroutine run concurrently with subsequent reads and writes to the same </span><span>err</span><span> variable in the enclosing function (or multiple instances of the goroutine), which causes a data race. </span></p>
<h6><strong><i>Example 3: Data race due to named return variable capture.</i></strong></h6>
<figure id="attachment_9551" aria-describedby="caption-attachment-9551"><img loading="lazy" src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure1c.png" alt="" width="2094" height="546" srcset="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure1c.png 2094w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure1c-300x78.png 300w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure1c-1024x267.png 1024w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure1c-768x200.png 768w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure1c-1536x401.png 1536w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure1c-2048x534.png 2048w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure1c-696x181.png 696w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure1c-1068x278.png 1068w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure1c-1920x501.png 1920w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure1c-1611x420.png 1611w" sizes="(max-width: 2094px) 100vw, 2094px"/><figcaption id="caption-attachment-9551">Figure 1C: Data race due to named return variable capture.</figcaption></figure>

<p><span>Go introduces a syntactic sugar called </span><a href="https://yourbasic.org/golang/named-return-values-parameters/"><i><span>named return values</span></i></a><span>. The named return variables are treated as variables defined at the top of the function, whose scope outlives the body of the function. A return statement without arguments, known as a “naked” return, returns the named return values. In the presence of a closure, mixing normal (non-naked) returns with named returns or using a deferred return in a function with a named return is risky, as it can introduce a data race. </span></p>
<p><span>The function </span><span>NamedReturnCallee</span><span> in Figure 1C returns an integer, and the return variable is named as </span><span>result</span><span>. The rest of the function body can read and write to </span><span>result</span><span> without having to declare it because of this syntax. If the function returns at line 4, which is a naked return, as a result of the assignment </span><span>result=10</span><span> on line 2, the caller at line 13 would see the return value of 10. The compiler arranges for copying </span><span>result</span><span> to </span><span>retVal</span><span>. A named return function can also use the standard return syntax, as shown on line 9. This syntax makes the compiler copy the return value, 20, in the return statement to be assigned to the named return variable result. Line 6 creates a goroutine, which captures the named return variable </span><span>result</span><span>. In setting up this goroutine, even a concurrency expert might believe that the read from </span><span>result</span><span> on line 7 is safe because there is no other write to the same variable; the statement </span><span>return 20</span><span> on line 9 is, after all, a constant return, and does not seem to touch the named return variable, </span><span>result</span><span>. The code generation, however, turns the </span><span>return 20</span><span> statement into a write to </span><span>result</span><span>, as previously mentioned. Now we suddenly have a concurrent read and a write to the shared </span><span>result</span><span> variable, a case of a data race.</span></p>
<h3><span></span></h3>
<p><a href="https://go.dev/ref/spec#Slice_types"><span>Slices</span></a><span> are dynamic arrays and reference types. Internally, a </span><a href="https://dev.to/herocod3r/understanding-slices-and-the-internals-in-go-4hb1"><span>slice</span></a><span> contains a pointer to the underlying array, its current length, and the maximum capacity to which the underlying array can expand. For ease of discussion, we refer to these variables as </span><i><span>meta fields</span></i><span> of a slice. A common operation on a slice is to grow it via the append operation. When the size reaches the capacity, a new allocation (e.g., double the current size) is made, and the meta fields are updated. When a slice is concurrently accessed by goroutines, it is natural to protect accesses to it by a mutex.</span></p>
<figure id="attachment_9552" aria-describedby="caption-attachment-9552"><img loading="lazy" src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure2.png" alt="" width="556" height="270" srcset="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure2.png 1800w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure2-300x146.png 300w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure2-1024x497.png 1024w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure2-768x373.png 768w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure2-1536x746.png 1536w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure2-696x338.png 696w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure2-1068x519.png 1068w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure2-865x420.png 865w" sizes="(max-width: 556px) 100vw, 556px"/><figcaption id="caption-attachment-9552">Figure 2: Data race in slices even after using locks.</figcaption></figure>

<p><span>In Figure 2, the developer thinks that lock-protecting the slice </span><span>append</span><span> on line 6 is sufficient to protect from data race. However, a data race happens when a slice is passed as an argument to the goroutine on line 14, which is not lock-protected. The invocation of the goroutine causes the meta fields of the slice to be copied from the call site (line 14) to the callee (line 11). Given that a slice is a reference type, the developer assumed its passing (copying) to a callee caused a data race. However, a slice is not the same as a pointer type (the meta fields are copied by value) and hence the subtle data race.</span></p>

<h3><span>3. Concurrent accesses to Go’s built-in, thread-unsafe maps cause frequent data races </span></h3>
<figure id="attachment_9553" aria-describedby="caption-attachment-9553"><img loading="lazy" src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure3.png" alt="" width="585" height="221" srcset="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure3.png 2018w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure3-300x113.png 300w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure3-1024x387.png 1024w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure3-768x290.png 768w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure3-1536x580.png 1536w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure3-696x263.png 696w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure3-1068x403.png 1068w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure3-1920x725.png 1920w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure3-1112x420.png 1112w" sizes="(max-width: 585px) 100vw, 585px"/><figcaption id="caption-attachment-9553">Figure 3: Data race due to concurrent map access.</figcaption></figure>

<p><span>Hash table (</span><a href="https://go.dev/blog/maps"><span>map</span></a><span>) is a built-in language feature in Go and is not thread-safe. If multiple goroutines simultaneously access the same hash table with at least one of them trying to modify the hash table (insert or delete an item), data race ensues. We observe that developers make a fundamental, but common assumption (and a mistake) that the different entries in the hash table can be concurrently accessed. This assumption stems from developers viewing the </span><span>table[key]</span><span> syntax used for map accesses and misinterpreting them to be accessing disjoint elements. However, a map (hash table), unlike an array or a slice, is a sparse data structure, and accessing one element might result in accessing another element; if during the same process another insertion/deletion happens, it will modify the sparse data structure and cause a data race. We even found more complex concurrent map access data races resulting from the same hash table being passed to deep call paths and developers losing track of the fact that these call paths mutate the hash table via asynchronous goroutines. Figure 3 shows an example of this type of data race.</span></p>
<p><span>While hashtable leading to data races is not unique to Go, the following reasons make it more prone to data races in Go:</span></p>
<ol>
<li aria-level="1"><span>Go developers use maps more frequently than the developers in other languages because the map is a built-in language construct. For example, in our Java repository, we found 4,389 map constructs per MLoC, whereas the same for Go is 5,950 per MLoC, which is 1.34x higher. </span></li>
<li aria-level="1"><span>The hash table access syntax is just like array-access syntax (unlike Java’s get/put APIs), making it easy to use and hence accidentally confused for a random access data structure. In Go, a non-existing map element can easily be queried with the </span><span>table[key]</span><span><span><span> syntax, which simply returns the default value without producing any error. This error tolerance makes developers complacent when using Go map.</span></span></span></li>
</ol>

<h3><span>4. Go developers often err on the side of pass-by-value (or methods over values), which can cause non-trivial data races</span></h3>
<p><span>Pass-by-value semantics are </span><a href="https://goinbigdata.com/golang-pass-by-pointer-vs-pass-by-value/"><span>recommended</span></a><span> in Go because it simplifies escape analysis and gives variables a better chance to be allocated on the stack, which reduces pressure on the garbage collector. </span></p>
<p><span>Unlike Java, where all objects are reference types, in Go, an object can be a value type (struct) or a reference type (interface). There is no syntactic difference, and this leads to incorrect use of synchronization constructs such as </span><span>sync.Mutex</span><span> and </span><span>sync.RWMutex</span><span>, which are value types (structures) in Go. If a function creates a mutex structure and passes by value to multiple  goroutine invocations, those concurrent executions of the goroutines operate on distinct mutex objects, which share no internal state. This defeats mutually exclusive access to the shared memory region that is guarded, exemplified in Figure 4 below.</span></p>
<figure id="attachment_9554" aria-describedby="caption-attachment-9554"><img loading="lazy" src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure4a.png" alt="" width="511" height="224" srcset="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure4a.png 1346w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure4a-300x132.png 300w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure4a-1024x449.png 1024w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure4a-768x337.png 768w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure4a-696x305.png 696w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure4a-1068x468.png 1068w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure4a-958x420.png 958w" sizes="(max-width: 511px) 100vw, 511px"/><figcaption id="caption-attachment-9554">Figure 4A: Data race due to method invocation by-reference or by-pointer.</figcaption></figure>

<figure id="attachment_9555" aria-describedby="caption-attachment-9555"><img loading="lazy" src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure4b.png" alt="" width="538" height="163" srcset="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure4b.png 1398w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure4b-300x91.png 300w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure4b-1024x311.png 1024w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure4b-768x233.png 768w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure4b-696x211.png 696w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure4b-1068x324.png 1068w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure4b-1385x420.png 1385w" sizes="(max-width: 538px) 100vw, 538px"/><figcaption id="caption-attachment-9555">Figure 4B: sync.Mutex Lock/Unlock signature.</figcaption></figure>

<p><span>Since Go syntax is the same for invoking a method over pointers vs. values, less attention is given by the developer to the question that </span><span>m.Lock()</span><span> is working on a copy of mutex instead of a pointer. The caller can still invoke these APIs on a mutex value, and the compiler transparently arranges to pass the address of the value. Had this transparency not been there, the bug could have been detected as a compiler type-mismatch error.</span></p>
<p><span>A converse of this situation happens when developers accidentally implement a method where the receiver is a pointer to the structure instead of a value/copy of the structure. In these situations, multiple goroutines invoking the method end up accidentally sharing the same internal state of the structure, whereas the developer intended otherwise. Here, also, the caller is unaware that the value type was transparently converted to a pointer type at the receiver.</span></p>

<h3><span>5. Mixed use of message passing (channels) and shared memory makes code complex and susceptible to data races</span></h3>
<figure id="attachment_9556" aria-describedby="caption-attachment-9556"><img loading="lazy" src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure5.png" alt="" width="564" height="270" srcset="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure5.png 1364w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure5-300x143.png 300w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure5-1024x489.png 1024w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure5-768x367.png 768w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure5-696x333.png 696w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure5-1068x511.png 1068w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure5-879x420.png 879w" sizes="(max-width: 564px) 100vw, 564px"/><figcaption id="caption-attachment-9556">Figure 5: Data race when mixing message passing with shared memory.</figcaption></figure>

<p><span>Figure 5 shows an example of a generic </span><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html"><span>future</span></a><span> implementation by a developer using a channel for signaling and waiting. The future can be started by calling the </span><span>Start()</span><span> method, and one can block for the future’s completion by calling the </span><span>Wait()</span><span> method on the Future. The </span><span>Start()</span><span>method creates a goroutine, which executes a function registered with the Future and records its return values (</span><span>response</span><span> and </span><span>err</span><span>). The goroutine signals the completion of the future to the </span><span>Wait()</span><span> method by sending a message on the channel </span><span>ch</span><span> as shown on line 6. Symmetrically, the </span><span>Wait()</span><span> method blocks to fetch the message from the channel (line 11).</span></p>
<p><span><a href="https://pkg.go.dev/context"><span>Contexts</span></a></span><span> in Go carry deadlines, cancelation signals, and other request-scoped values across API boundaries and between processes. This is a common pattern in microservices where timelines are set for tasks. Hence, </span><span>Wait()</span><span> blocks either on the context being canceled (line 13) or the future to have completed (line 11). Furthermore, the </span><span>Wait()</span><span> is wrapped inside a </span><a href="https://go.dev/ref/spec#Select_statements"><span>select</span></a><span> statement (line 10), which blocks until at least one of the select arms is ready.</span></p>
<p><span>If the context times out, the corresponding case records the err field of Future as </span><span>ErrCancelled</span><span> on line 14. This write to </span><span>err</span><span> races with the write to the same variable in the future on line 5.</span></p>

<h3><span>6. Go offers more leeway in its group synchronization construct sync.WaitGroup, but the incorrect placement of Add/Done methods leads to data races</span></h3>
<figure id="attachment_9557" aria-describedby="caption-attachment-9557"><img loading="lazy" src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure6a.png" alt="" width="605" height="245" srcset="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure6a.png 1562w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure6a-300x121.png 300w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure6a-1024x414.png 1024w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure6a-768x311.png 768w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure6a-1536x621.png 1536w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure6a-696x282.png 696w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure6a-1068x432.png 1068w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure6a-1038x420.png 1038w" sizes="(max-width: 605px) 100vw, 605px"/><figcaption id="caption-attachment-9557">Figure 6A: Data race due to incorrect WaitGroup.Add() placement.</figcaption></figure>

<p><span>The </span><span><a href="https://pkg.go.dev/sync#WaitGroup"><span>sync.WaitGroup</span></a></span><span> structure is a group synchronization construct in Go. Unlike </span><a href="https://en.cppreference.com/w/cpp/thread/barrier"><span>C++ barrier</span></a><span>, </span><a href="https://pubs.opengroup.org/onlinepubs/009696899/functions/pthread_barrier_init.html"><span>pthreads</span></a><span>, or Java </span><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CyclicBarrier.html"><span>barrier</span></a><span> or </span><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html"><span>latch</span></a><span> constructs, the number of participants in a WaitGroup is not determined at the time of construction but is updated dynamically. Three operations are allowed on a </span><span>WaitGroup</span><span> object — </span><span>Add(int)</span><span>,</span><span> Done()</span><span>, and </span><span>Wait()</span><span>. </span><span>Add()</span><span>increments the </span><i><span>count</span></i><span> of participants, and the</span><span> Wait()</span><span> blocks until </span><span>Done()</span><span> is called </span><i><span>count</span></i><span> number of times (typically once by each participant). </span><span>WaitGroup</span><span> is extensively used in Go. As shown previously in Table 1, group synchronization is 1.9x higher in Go than in Java.</span></p>
<p><span>In Figure 6, the developer intends to create as many goroutines as the number of elements in the slice </span><span>itemIds</span><span> and process the items concurrently. Each goroutine records its success or failure status in </span><span>results</span><span> slice at different indices and the parent function blocks at line 12 until all goroutines finish. It then accesses all elements of results serially to count the number of successful processings.</span></p>
<p><span>For this code to work correctly, when </span><span>Wait()</span><span> is invoked on line 12, the number of registered participants must be already equal to the length of </span><span>itemIds</span><span>. This is possible only if </span><span>wg.Add(1</span><span><span>)</span>is executed as many times as the length of </span><span>itemIds</span><span> prior to invoking </span><span>wg.Wait()</span><span>, which means </span><span>wg.Add(1)</span><span>should have been placed on line 5, prior to each goroutine invocation. However, the developer incorrectly places </span><span>wg.Add(1)</span><span>inside the body of the goroutines on line 7, which is not guaranteed to have been executed by the time the outer function </span><span>WaitGrpExample</span><span> invokes <span>Wait()</span>. As a result, there can be fewer than the length of </span><span>itemIds</span><span> registered with the </span><span>WaitGroup</span><span> when the </span><span>Wait()</span><span>is invoked. For that reason, the </span><span>Wait()</span><span>can unblock prematurely, and the </span><span>WaitGrpExample</span><span> function can start to read from the slice results (line 13) while some goroutines are concurrently writing to the same slice.</span></p>
<p><span>We also found data races arising from a premature placement of the </span><span>wg.Done()</span><span>call on a </span><span>Waitgroup</span><span>. A subtle version of premature </span><span>wg.Done()</span><span>is shown below in Figure B, which results from </span><span>its </span><span>interaction with Go’s defer statement. When multiple defer statements are encountered, they are executed in the last-in-first-out order. Here, </span><span>wg.Wait()</span><span>on line 9 finishes before the </span><span>doCleanup()</span><span><span>runs</span>. The parent goroutine accesses the </span><span>locationErr</span><span> on line 10 while the child goroutine may be still writing to the </span><span>locationErr</span><span> inside the deferred </span><span>doCleanup()</span><span>function (not shown for brevity).</span></p>
<figure id="attachment_9558" aria-describedby="caption-attachment-9558"><img loading="lazy" src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure6b.png" alt="" width="627" height="216" srcset="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure6b.png 1224w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure6b-300x103.png 300w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure6b-1024x353.png 1024w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure6b-768x265.png 768w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure6b-696x240.png 696w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure6b-1068x368.png 1068w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure6b-1218x420.png 1218w" sizes="(max-width: 627px) 100vw, 627px"/><figcaption id="caption-attachment-9558">Figure 6B: Data race due to defer statement ordering leading to incorrect WaitGroup.Done() placement.</figcaption></figure>

<h3><span>7. Running tests in parallel for Go’s table-driven test suite idiom can often cause data races, either in the product or test code</span></h3>
<p><a href="https://pkg.go.dev/testing"><span>Testing</span></a><span> is a built-in feature in Go. Any function with the prefix </span><i><span>Test</span></i><span> in a file with suffix</span><span> _test.go</span><span> can be run as a test via the Go build system. If the test code calls an API </span><span>testing.T.Parallel()</span><span>, it will run concurrently with other such tests. We found a large class of data races happen due to such concurrent test executions. The root causes of these data races were sometimes in the test code and sometimes in the product code. Additionally, within a single </span><span>Test</span><span>-prefixed function, Go developers often write many subtests and execute them via the Go-provided suite package. Go recommends a</span><a href="https://dave.cheney.net/2019/05/07/prefer-table-driven-tests"><span> table-driven test suite idiom</span></a><span> to write and run a test suite. Our developers extensively write tens or hundreds of subtests in a test, which our systems run in parallel. This idiom becomes a source of problem for a test suite where the developer either assumed serial test execution or lost track of using shared objects in a large complex test suite. Problems also arise when the product API(s) were written without thread safety (perhaps because it was not needed), but were invoked in parallel, violating the assumption.</span></p>


<p><span>We analyzed the fixed data races to classify the reasons behind them. These issues are tabulated as follows. The labels are not mutually exclusive.</span></p>
<figure id="attachment_9559" aria-describedby="caption-attachment-9559"><img loading="lazy" src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure7.png" alt="" width="502" height="257" srcset="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure7.png 984w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure7-300x154.png 300w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure7-768x393.png 768w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure7-696x356.png 696w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2022/06/Figure7-820x420.png 820w" sizes="(max-width: 502px) 100vw, 502px"/><figcaption id="caption-attachment-9559">Figure 7: Summary of data races.</figcaption></figure>

<p><span>An example for each pattern of a data race is available from </span><a href="https://zenodo.org/record/6330164"><span>this</span></a><span> link.</span></p>
<p><span>In summary, based on observed (including fixed) data races, we elaborated the Go language paradigms that make it easy to introduce races in Go programs. We hope that our experiences with data races in Go will help Go developers pay more attention to the subtleties of writing concurrent code. Future programming language designers should carefully weigh different language features and coding idioms against their potential to create common or arcane concurrency bugs. </span></p>

<h3><span>Threats to Validity</span></h3>
<p><span>The discussion herein is based on our experiences with data races in Uber’s Go monorepo and may have missed additional patterns of data races that may happen elsewhere. Also, as dynamic race detection does not detect all possible races due to code and interleaving coverage, our discussion may have missed a few patterns of races. Despite these threats to the universality of our results, the discussion on the patterns in this paper and the deployment experiences hold independently.</span></p>

<p><i><span>This is the second of a two-part blog post series on our experiences with data race in Go code. An elaborate </span></i><a href="https://arxiv.org/pdf/2204.00764.pdf"><i><span>version</span></i></a><i><span> of our experiences will appear in the ACM SIGPLAN Programming Languages Design and Implementation (PLDI), 2022. In the </span></i><a href="https://eng.uber.com/dynamic-data-race-detection-in-go-code/"><i><span>first part</span></i></a><i><span> of the blog series, we discuss our learnings pertaining to deploying dynamic race detection at scale for Go code.</span></i></p>
<p><span><span>Main Image Credit: </span><a href="https://creativecommons.org/licenses/by/2.0/"><span>https://creativecommons.org/licenses/by/2.0/</span></a></span></p>
        </div></div>
  </body>
</html>
