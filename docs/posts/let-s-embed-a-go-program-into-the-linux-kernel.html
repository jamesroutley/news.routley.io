<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sigma-star.at/blog/2023/07/embedded-go-prog/">Original</a>
    <h1>Let&#39;s Embed a Go Program into the Linux Kernel</h1>
    
    <div id="readability-page-1" class="page"><div>
        
<p>Today, we would like to present a lesser-known feature of the Linux kernel.
Instead of launching a program from a file system, regardless of whether it’s virtual or not, it is also possible to embed a user-space program directly into the kernel image itself and start it from there.</p>
<h2 id="introduction">Introduction</h2>
<p>At first glance, this might sound outlandish and of little use, but there are cases where the kernel needs to execute helper programs.
Prominent examples include the module loader helper, <code>/sbin/modprobe</code>, or the Spanning Tree Protocol (STP) helper for Linux’s 802.1d Ethernet bridge subsystem, <code>/sbin/bridge-stp</code>.
On Linux, programs are typically launched from a file system using the <code>execve()</code> system call.
The kernel reads the initial parts of the specified file and hands over execution to user space.
Various helper functions exist on top of this system call, but they all have in common that the program to be executed is started from a file.
The same applies to the Linux user mode helper API, which allows executing a program from a driver.
Both scenarios require the program to be installed and loadable.
In most cases, having the program installed is a trivial problem if you have control over all user space, as is the case with a typical Linux distribution.</p>
<p>However, things become complicated if you are a Board Support Package (BSP) supplier, either external or in-house, and don’t always have easy access to the workflow that determines what to install in the root file system.
Ensuring that a program is actually loadable from the current root file system is a different story.
A common problem arises in setups where the root file system is attached using network storage, such as NFS or iSCSI.
If the network connection is unavailable, all access to the root file system fails, and the kernel is unable to run helpers anymore.
This is where the mechanism we’d like to present in this blog post can help.</p>
<p>Let’s assume we have a device driver called <code>embedded_prog</code> that requires a user space helper program, which must be executable at any time.
First, we need the program we want to embed.
Strictly speaking, any program will do, but we need to ensure that the program in question has no dependencies on the file system.
Linking it statically provides benefits.
Go programs are statically linked by default, and to illustrate that the following approach works with any kind of program, we have chosen to embed a Go program into the kernel.
The driver itself is very simple.
All it does is execute the helper program as soon as the driver is loaded, and when the program writes something into the pipe, the contents are directly logged into the kernel log buffer.</p>
<h2 id="the-go-program">The Go Program</h2>
<p>To keep things simple, the program itself will be straightforward.
It will write ‘Hello, world!’ to standard output every five seconds.</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="go"><span><span><span>package</span> <span>main</span>
</span></span><span><span>
</span></span><span><span><span>import</span> <span>(</span>
</span></span><span><span>        <span>&#34;fmt&#34;</span>
</span></span><span><span>        <span>&#34;time&#34;</span>
</span></span><span><span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>main</span><span>()</span> <span>{</span>
</span></span><span><span>        <span>for</span> <span>{</span>
</span></span><span><span>                <span>fmt</span><span>.</span><span>Println</span><span>(</span><span>&#34;Hello, world!&#34;</span><span>)</span>
</span></span><span><span>                <span>time</span><span>.</span><span>Sleep</span><span>(</span><span>5</span> <span>*</span> <span>time</span><span>.</span><span>Second</span><span>)</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>Since we want to be independent of the root file system, we need to ensure that the program does not access files from the root file system.
We can achieve this by using strace to trace its system calls.</p>
<pre tabindex="0"><code>$ strace -fe trace=file ./eprog_user
execve(&#34;./eprog_user&#34;, [&#34;./eprog_user&#34;], 0x7fff743fbd50 /* 61 vars */) = 0
openat(AT_FDCWD, &#34;/sys/kernel/mm/transparent_hugepage/hpage_pmd_size&#34;, O_RDONLY) = 3
strace: Process 17908 attached
strace: Process 17909 attached
strace: Process 17910 attached
strace: Process 17911 attached
[pid 17905] --- SIGURG {si_signo=SIGURG, si_code=SI_TKILL, si_pid=17905, si_uid=1000} ---
Hello, world!
Hello, world!
^C
strace: Process 17905 detached
strace: Process 17908 detached
strace: Process 17909 detached
strace: Process 17910 detached
strace: Process 17911 detached
</code></pre><p>Looks good!
Access to files in <code>/proc</code> or <code>/sys</code> is fine.
These are virtual file systems and can be assumed to be present and working at all times.
They are part of the Linux ABI interface.</p>
<h2 id="linuxs-user-mode-helper-api">Linux’s User Mode Helper API</h2>
<p>If your device driver needs to execute a user space program, the User Mode Helper API is the way to go.
The core function to use the API is <code>call_usermodehelper()</code>, which has the following signature:</p>
<div><pre tabindex="0"><code data-lang="C"><span><span><span>int</span> <span>call_usermodehelper</span><span>(</span><span>const</span> <span>char</span> <span>*</span><span>path</span><span>,</span> <span>char</span> <span>**</span><span>argv</span><span>,</span> <span>char</span> <span>**</span><span>envp</span><span>,</span> <span>int</span> <span>wait</span><span>);</span>
</span></span></code></pre></div><p>Similar to the <code>execve()</code> system call, <code>call_usermodehelper()</code> takes parameters such as the filename of the program to be executed, supplied arguments, environment, and a flag denoting whether the call should be asynchronous or not.
However, this is not what we want for running an embedded program within the kernel image itself.</p>
<p>Since Linux v4.18, a more advanced API called user mode driver is available to run a user mode helper.
The basic idea behind this API is that instead of specifying a path to a file on the root file system, an arbitrary buffer can be provided.
The content of this buffer will be executed in user space just like a regular program.</p>
<div><pre tabindex="0"><code data-lang="C"><span><span><span>int</span> <span>umd_load_blob</span><span>(</span><span>struct</span> <span>umd_info</span> <span>*</span><span>info</span><span>,</span> <span>const</span> <span>void</span> <span>*</span><span>data</span><span>,</span> <span>size_t</span> <span>len</span><span>);</span>
</span></span><span><span><span>int</span> <span>fork_usermode_driver</span><span>(</span><span>struct</span> <span>umd_info</span> <span>*</span><span>info</span><span>);</span>
</span></span></code></pre></div><p>Using <code>umd_load_blob()</code>, a program context is created from a buffer, and later it is executed by <code>fork_usermode_driver()</code>.
In addition to running the program, the User Mode Driver API also establishes a pipe between the program and the kernel, enabling inexpensive communication between them.</p>
<p>But how do we get our Go program into that buffer?
We don’t want a new user space interface where the program has to be loaded into the kernel first.
We want it to be part of the kernel image.</p>
<h2 id="gnu-assember-to-the-rescue">GNU Assember to the Rescue!</h2>
<p>The kernel build system, specifically the GNU assembler (gas), can assist us in embedding the Go program into the resulting kernel image during the build process.
By using a gas file, <code>eprog_user_blob.S</code>, we can instruct the assembler to generate a C object file with two symbols: <code>embedded_umh_start</code> and <code>embedded_umh_end</code>.
These symbols will contain the contents of a binary file specified by the <code>.incbin</code> command, and this file can be arbitrary.</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="Gas"><span><span>        <span>.section</span> <span>.init.rodata</span><span>,</span> <span>&#34;a&#34;</span>
</span></span><span><span>        <span>.global</span> <span>embedded_umh_start</span>
</span></span><span><span><span>embedded_umh_start:</span>
</span></span><span><span>        <span>.incbin</span> <span>&#34;drivers/misc/embedded_prog/eprog_user&#34;</span>
</span></span><span><span>        <span>.global</span> <span>embedded_umh_end</span>
</span></span><span><span><span>embedded_umh_end:</span>
</span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>If we link the resulting object file, <code>eprog_user_blob.o</code>, with our Linux device driver, we can utilize the symbols to locate the contents of the Go program within the kernel image.
This makes loading and executing the program from a buffer straightforward.
In this case, the buffer passed to <code>umd_load_blob()</code> is a memory location within the read-only section of the in-memory kernel image.
The linker has kindly prepared everything for us at compile time!</p>
<p>The code snippet provided below demonstrates the essential segments of the device driver, <code>eprog_kern.c</code>, responsible for loading and executing the Go program:</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="C"><span><span><span>struct</span> <span>umd_info</span> <span>eprog_ctx</span> <span>=</span> <span>{</span>
</span></span><span><span>        <span>.</span><span>driver_name</span> <span>=</span> <span>&#34;eprog_user&#34;</span><span>,</span>
</span></span><span><span><span>};</span>
</span></span><span><span>
</span></span><span><span><span>umd_load_blob</span><span>(</span><span>&amp;</span><span>eprog_ctx</span><span>,</span> <span>&amp;</span><span>embedded_umh_start</span><span>,</span> <span>&amp;</span><span>embedded_umh_end</span> <span>-</span> <span>&amp;</span><span>embedded_umh_start</span><span>);</span>
</span></span><span><span><span>fork_usermode_driver</span><span>(</span><span>&amp;</span><span>eprog_ctx</span><span>);</span>
</span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>Using the <code>nm</code> command, we can observe the symbols in the driver.
If the driver is built as a loadable module, you can run <code>nm</code> on <code>eprog.o</code>.
Otherwise, if it is built directly into the kernel, you can run <code>nm</code> on <code>vmlinux</code>.</p>
<pre tabindex="0"><code>$ nm eprog.o | grep embedded_umh_
00000000001bc4e4 R embedded_umh_end
0000000000000000 R embedded_umh_start
</code></pre><pre tabindex="0"><code>$ nm vmlinux | grep embedded_umh_
0000000060688a00 d embedded_umh_end
00000000604cc51c d embedded_umh_start
</code></pre><h2 id="gluing-it-all-together">Gluing it all Together</h2>
<p>So far we have the following components:</p>
<ul>
<li><a href="https://git.kernel.org/pub/scm/linux/kernel/git/rw/misc.git/tree/drivers/misc/embedded_prog/eprog_kern.c?h=embedded_go_prog">eprog_kern.c</a>: The kernel driver that runs <code>umd_load_blob()</code> and <code>fork_usermode_driver()</code>.</li>
<li><a href="https://git.kernel.org/pub/scm/linux/kernel/git/rw/misc.git/tree/drivers/misc/embedded_prog/eprog_user_blob.S?h=embedded_go_prog">eprog_user_blob.S</a>, The assembly source file we use to embed the Go program into a C object.</li>
<li><a href="https://git.kernel.org/pub/scm/linux/kernel/git/rw/misc.git/tree/drivers/misc/embedded_prog/gohello/hello.go?h=embedded_go_prog">gohello/hello.go</a>, Our Go program, located in a subdirectory of our driver.</li>
</ul>
<p>Using the following Makefile, all components are build and connected together:</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="Makefile"><span><span><span>$(obj)/eprog_user_blob.o</span><span>:</span> <span>$(</span><span>obj</span><span>)</span>/<span>eprog_user</span>
</span></span><span><span><span>$(obj)/eprog_user</span><span>:</span> <span>$(</span><span>srctree</span><span>)</span>/<span>drivers</span>/<span>misc</span>/<span>embedded_prog</span>/<span>gohello</span>/<span>hello</span>.<span>go</span>
</span></span><span><span>        <span># TODO: Add support for cross builds</span>
</span></span><span><span>        go build -o <span>$(</span>obj<span>)</span>/eprog_user <span>$(</span>srctree<span>)</span>/drivers/misc/embedded_prog/gohello/hello.go
</span></span><span><span>
</span></span><span><span><span>obj-$(CONFIG_EMBEDDED_PROG)</span> <span>+=</span> eprog.o
</span></span><span><span><span>eprog-objs</span> <span>+=</span> eprog_kern.o eprog_user_blob.o
</span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>Linux’s GNU make-based build system is rather flexible: it allows us to build our Go program even while building the kernel.</p>
<p>The following graphic outlines how all components are connected:</p>
<figure>
<img src="https://sigma-star.at/blog/2023/07/embedded-go-prog/eprog.svg" alt="Relationship between C objects"/></figure>
<h2 id="demo">Demo</h2>
<pre tabindex="0"><code>$ insmod eprog.ko
$ ps fax
  PID TTY      STAT   TIME COMMAND
    2 ?        S      0:00 [kthreadd]
[..]
   25 ?        Sl     0:00  \_ eprog_user
[..]
   30 ?        R      0:00 ps fax
$ dmesg -w
[   53.300000] eprog: From userspace: Hello, world!
[   58.310000] eprog: From userspace: Hello, world!
[...]
</code></pre><p>We observe a new process, <code>eprog_user</code>, right after loading the driver module.
It is not a kernel thread, the name is not in square brackets and it is not a child
of PID 1 but of <code>kthreadd</code>.
Every five seconds the Go program will write <code>Hello, world!</code> via standard output
to the kernel driver which prints the string to the kernel log buffer.
Once the module is unloaded, the process is killed.</p>
<h2 id="summary">Summary</h2>
<p>We have seen that using a small assembly file and the User Mode Driver mechanism, it is possible to embed any kind of executable into the kernel image and run it later from there.
It works with any kind of program; we used a Go binary because it is statically linked and has no dependencies on the root file system.
If you’re using your own program and want to be completely independent of the root file system, make sure that you know in detail which files it will process.
While the number of valid use cases for the presented feature is arguably small, it is still interesting to have and opens the door to new possibilities.
The example driver is rather simple, but there are numerous other ways to utilize this feature.
Please keep in mind that adding programs to the kernel image comes with a cost: the program as a whole will always stay in memory.</p>
<p>The full example driver is available on <a href="https://git.kernel.org/pub/scm/linux/kernel/git/rw/misc.git/tree/drivers/misc/embedded_prog?h=embedded_go_prog">git.kernel.org</a>.</p>

        </div></div>
  </body>
</html>
