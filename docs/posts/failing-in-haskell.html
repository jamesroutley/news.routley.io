<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jappie.me/failing-in-haskell.html">Original</a>
    <h1>Failing in Haskell</h1>
    
    <div id="readability-page-1" class="page"><div><p><img alt="mtl-header" src="https://punchagan.muse-amuse.in/blog/made-in-2021/images/2022/failure.png"/></p><p>Some of my intelligent colleagues mucked up error handling. Not only were they failing, they were failing <span>WRONG</span> <sup id="fnref-anti-patterns"><a href="#fn-anti-patterns">1</a></sup>. This frustrates me because doing failing correctly in Haskell is quite easy, so why were they doing it wrong? I believe no-one has addressed failing with an opinion. Plenty people describe the <a href="http://www.randomhacks.net/2007/03/10/haskell-8-ways-to-report-errors/">various</a><a href="https://www.stackbuilders.com/blog/errors-and-exceptions-in-haskell/">ways</a><a href="https://www.fpcomplete.com/haskell/tutorial/exceptions/">you</a><a href="https://www.schoolofhaskell.com/school/starting-with-haskell/basics-of-haskell/10_Error_Handling">can</a><a href="https://wiki.haskell.org/Handling_errors_in_Haskell">fail</a>. But none give opinions on why certain ways are better then others. Therefore I shall share my failing expertise, and describe the correct way to fail in Haskell. In essence, this is an answer to Eric Kidd’s <a href="http://www.randomhacks.net/2007/03/10/haskell-8-ways-to-report-errors/">plea for consistency</a><sup id="fnref-15-years-ago"><a href="#fn-15-years-ago">2</a></sup>. These are the properties we want from failure:</p><ol><li>Preciseness, vague errors are bad.</li><li>Locality, we need to know where errors come from.</li><li>Recover ability, the program should be able to recover after an error.</li><li>Change ability, introduction of new error cases should be easy.</li></ol><p>We want all these properties to make debugging easier. This allows you to solve complicated bugs within minutes. We structure the program so that it tells what goes wrong, where and why. This isn’t magic. It takes effort, but not magic at all.</p><p>I’ll describe how to achieve above properties with some example code for both pure and side effectful code. However these principles apply to other languages as well <sup id="fnref-other-langs"><a href="#fn-other-langs">3</a></sup>. We’ll also go over some anti patterns and discuss their mediation.</p><p>Haskell programmers prefer so called ‘pure’ code. By which we mean in immutable memory computations<sup id="fnref-memory"><a href="#fn-memory">4</a></sup>. Therefore we start with the pure case. Ideally pure code fail management looks like this:</p><div><pre><span></span><span>newtype</span> <span>LookupError</span> <span>=</span> <span>NotFound</span> <span>Text</span>

<span>lookup</span> <span>::</span> <span>Map</span> <span>Text</span> <span>Double</span> <span>-&gt;</span> <span>Text</span> <span>-&gt;</span> <span>Either</span> <span>LookupError</span> <span>Double</span>
<span>lookup</span> <span>env</span> <span>argA</span> <span>=</span> <span>maybe</span> <span>(</span><span>Left</span> <span>(</span><span>NotFound</span> <span>argA</span><span>))</span> <span>Right</span> <span>$</span> <span>Map</span><span>.</span><span>lookup</span> <span>argA</span> <span>env</span>

<span>data</span> <span>DivideErrors</span> <span>=</span> <span>DivideLookup</span> <span>LookupError</span>
                  <span>|</span> <span>DivisionByZero</span> <span>Double</span> <span>Double</span>
                  <span>|</span> <span>DivNegativeDivision</span> <span>Double</span> <span>Double</span>
                  <span>|</span> <span>DivNumberThreeIsBad</span> <span>Double</span> <span>Double</span>

<span>divide</span> <span>::</span> <span>Map</span> <span>Text</span> <span>Double</span> <span>-&gt;</span> <span>Text</span> <span>-&gt;</span> <span>Text</span> <span>-&gt;</span> <span>Either</span> <span>DivideErrors</span> <span>Double</span>
<span>divide</span> <span>env</span> <span>argA</span> <span>argB</span> <span>=</span> <span>do</span>
    <span>valA</span> <span>&lt;-</span> <span>first</span> <span>DivideLookup</span> <span>$</span> <span>lookup</span> <span>env</span> <span>argA</span>
    <span>valB</span> <span>&lt;-</span> <span>first</span> <span>DivideLookup</span> <span>$</span> <span>lookup</span> <span>env</span> <span>argB</span>
    <span>when</span> <span>(</span><span>valB</span> <span>==</span> <span>0</span><span>)</span> <span>$</span> <span>Left</span> <span>$</span> <span>DivisionByZero</span> <span>valA</span> <span>valB</span>
    <span>when</span> <span>(</span><span>valB</span> <span>&lt;</span> <span>0</span><span>)</span> <span>$</span> <span>Left</span> <span>$</span> <span>DivNegativeDivision</span> <span>valA</span> <span>valB</span>
    <span>when</span> <span>(</span><span>valA</span> <span>==</span> <span>3.0</span> <span>||</span> <span>valB</span> <span>==</span> <span>3.0</span><span>)</span> <span>$</span> <span>Left</span> <span>$</span> <span>DivNumberThreeIsBad</span> <span>valA</span> <span>valB</span>
    <span>pure</span> <span>$</span> <span>valA</span> <span>/</span> <span>valB</span>
</pre></div><p>Here we introduce the divide function. Which takes an environment map, looks up the values of said map, and then performs division after doing some checks. We introduce the environment as a convenient common “this can fail” lookup. But business may give us other in-variants such as <code>DivNumberThreeIsBad</code>, which also neatly fits in this “pattern”. Errors are emitted by using the <code>Left</code> constructor, which is the error branch according to <code>Either</code><span>‘</span>s <code>Monad</code> instance.</p><p>This code will tell you exactly what went wrong if something goes wrong. Locality in this case can be improved a little by adding a different constructor for each <code>lookup</code> call, but in this case I’d argue locality is close enough. The developer has the opportunity to recover from these errors, a simple pattern match would suffice. Furthermore if business demands yet another weird constraint, such as <code>NumberFourIsBad</code>, pattern matches at call sites will emit a <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Wincomplete-patterns"><code>-Wincomplete-patterns</code></a> warning.</p><p>If we need to compose these errors in a larger program we can simply wrap previous errors in a bigger sumtype, consider the following function <code>plusDiv</code> which emulates <code>(a + b) / c</code></p><div><pre><span></span><span>data</span> <span>PlusErrors</span> <span>=</span> <span>PlusLookup</span> <span>LookupError</span>
                <span>|</span> <span>PlusNoZeroResults</span>
                <span>|</span> <span>PlusNumberThreeIsBad</span> <span>Double</span> <span>Double</span>

<span>plus</span> <span>::</span> <span>Map</span> <span>Text</span> <span>Double</span> <span>-&gt;</span> <span>Text</span> <span>-&gt;</span> <span>Text</span> <span>-&gt;</span> <span>Either</span> <span>PlusErrors</span> <span>Double</span>
<span>plus</span> <span>env</span> <span>argA</span> <span>argB</span> <span>=</span> <span>do</span>
    <span>valA</span> <span>&lt;-</span> <span>first</span> <span>PlusLookup</span> <span>$</span> <span>lookup</span> <span>env</span> <span>argA</span>
    <span>valB</span> <span>&lt;-</span> <span>first</span> <span>PlusLookup</span> <span>$</span> <span>lookup</span> <span>env</span> <span>argB</span>
    <span>when</span> <span>(</span><span>valA</span> <span>==</span> <span>3.0</span> <span>||</span> <span>valB</span> <span>==</span> <span>3.0</span><span>)</span> <span>$</span>
      <span>Left</span> <span>$</span> <span>PlusNumberThreeIsBad</span> <span>valA</span> <span>valB</span>
    <span>let</span> <span>res</span> <span>=</span> <span>valA</span> <span>+</span> <span>valB</span>
    <span>when</span> <span>(</span><span>res</span> <span>==</span> <span>0</span><span>)</span> <span>$</span> <span>Left</span> <span>PlusNoZeroResults</span>
    <span>pure</span> <span>$</span> <span>valA</span> <span>/</span> <span>valB</span>

<span>data</span> <span>PlusDivErrors</span> <span>=</span> <span>PDPlusError</span> <span>PlusErrors</span>
                   <span>|</span> <span>PDDivErrors</span> <span>DivideErrors</span>
                   <span>|</span> <span>PDLookup</span> <span>LookupError</span>

<span>-- | (a + b) / c</span>
<span>plusDiv</span> <span>::</span> <span>Map</span> <span>Text</span> <span>Double</span>
        <span>-&gt;</span> <span>Text</span> <span>-&gt;</span> <span>Text</span> <span>-&gt;</span> <span>Text</span>
        <span>-&gt;</span> <span>Either</span> <span>PlusDivErrors</span> <span>Double</span>
<span>plusDiv</span> <span>env</span> <span>argA</span> <span>argB</span> <span>argC</span> <span>=</span> <span>do</span>
  <span>res</span> <span>&lt;-</span> <span>first</span> <span>PDPlusError</span> <span>$</span> <span>plus</span> <span>env</span> <span>argA</span> <span>argB</span>
  <span>cres</span> <span>&lt;-</span> <span>first</span> <span>PDLookup</span> <span>$</span> <span>lookup</span> <span>env</span> <span>argC</span>
  <span>first</span> <span>PDDivErrors</span> <span>$</span>
    <span>divide</span> <span>(</span><span>Map</span><span>.</span><span>fromList</span> <span>[(</span><span>&#34;one&#34;</span><span>,</span> <span>res</span><span>),</span> <span>(</span><span>&#34;two&#34;</span><span>,</span> <span>cres</span><span>)])</span> <span>&#34;one&#34;</span> <span>&#34;two&#34;</span>
</pre></div><p>The higher ‘level’ function <code>plusDiv</code> absorbs all errors from other functions with extra constructors. This isn’t the most ergonomic approach because variables have to go through the environment map and in a real program you could factor this out and more typesafe rather then relying on runtime failure. However I think for an example or early prototype it’s good. Once more this tells us exactly what part of the computation failed, if any. In this case, the <a href="https://hackage.haskell.org/package/bifunctors-5/docs/Data-Bifunctor.html#v:first">first</a> function is being used like <a href="https://hackage.haskell.org/package/transformers-0.6.0.2/docs/Control-Monad-Trans-Class.html#v:lift">lift</a>: Transforming the function it wraps to run in the “higher level” <code>Either</code> environment. Some may even call this a natural transformation. </p><p>In certain cases you can use <a href="https://hackage.haskell.org/package/validation-1.1.2/docs/Data-Validation.html">Data.Validation</a> instead of <code>Either</code>. Which can collect more then one error. But usage of that is out of the scope of this blogpost.</p><p>It’s more difficult to recover from an exception then it is from a pure error value. As a rule of thumb you can use exceptions when you expect the program to stop. For example when you can’t find a critical resources from the database. Another consideration is the value of the error. If it’s important that an error is handled correctly, then exceptions should be avoided. However, this should only be done within a monad stack that has <code>IO</code> as base, because exceptions are part of the <code>IO</code> <span>‘</span>contract’<sup id="fnref-throw"><a href="#fn-throw">5</a></sup>. This contract extends to any transformer stack that has <code>IO</code> as base. For convenience however, I’ll write out the example in plain <code>IO</code>:</p><div><pre><span></span><span>data</span> <span>DivideException</span> <span>where</span>
    <span>MkDivideException</span> <span>::</span> <span>HasCallStack</span> <span>=&gt;</span>
        <span>DivideErrors</span> <span>-&gt;</span> <span>DivideException</span>

<span>deriving</span> <span>instance</span> <span>Exception</span> <span>DivideException</span>

<span>instance</span> <span>Show</span> <span>DivideException</span> <span>where</span>
    <span>show</span> <span>(</span><span>MkDivideException</span> <span>errors</span><span>)</span> <span>=</span>
        <span>renderExceptionWithCallstack</span> <span>errors</span> <span>&#34;MkDivideException&#34;</span>

<span>renderExceptionWithCallstack</span> <span>::</span>
        <span>(</span><span>HasCallStack</span><span>,</span> <span>Show</span> <span>a</span><span>)</span> <span>=&gt;</span> <span>a</span> <span>-&gt;</span> <span>String</span> <span>-&gt;</span> <span>String</span>
<span>renderExceptionWithCallstack</span> <span>errors</span> <span>valueConstructor</span> <span>=</span> <span>&#34;(&#34;</span> <span>&lt;&gt;</span> <span>valueConstructor</span> <span>&lt;&gt;</span> <span>&#34; $ &#34;</span>
      <span>&lt;&gt;</span> <span>show</span> <span>errors</span>
      <span>&lt;&gt;</span> <span>&#34;/*&#34;</span>
      <span>&lt;&gt;</span> <span>prettyCallStack</span> <span>callStack</span>
      <span>&lt;&gt;</span> <span>&#34; */)&#34;</span>

<span>throwDivide</span> <span>::</span> <span>HasCallStack</span> <span>=&gt;</span> <span>Either</span> <span>DivideErrors</span> <span>a</span> <span>-&gt;</span> <span>IO</span> <span>a</span>
<span>throwDivide</span> <span>=</span> <span>either</span> <span>(</span><span>throwIO</span> <span>.</span> <span>MkDivideException</span><span>)</span> <span>pure</span>

<span>myEnv</span> <span>::</span> <span>Map</span> <span>Text</span> <span>Double</span>
<span>myEnv</span> <span>=</span> <span>Map</span><span>.</span><span>fromList</span> <span>[(</span><span>&#34;zero&#34;</span><span>,</span> <span>0.0</span><span>),</span> <span>(</span><span>&#34;one&#34;</span><span>,</span> <span>-</span><span>1.0</span><span>),</span>
                      <span>(</span><span>&#34;two&#34;</span><span>,</span> <span>2.0</span><span>),</span> <span>(</span><span>&#34;three&#34;</span><span>,</span> <span>3.0</span><span>)]</span>

<span>main</span> <span>::</span> <span>IO</span> <span>()</span>
<span>main</span> <span>=</span> <span>do</span>
    <span>result1</span> <span>&lt;-</span> <span>throwDivide</span> <span>$</span> <span>divide</span> <span>myEnv</span> <span>&#34;one&#34;</span> <span>&#34;two&#34;</span>
    <span>result2</span> <span>&lt;-</span> <span>throwDivide</span> <span>$</span> <span>divide</span> <span>myEnv</span> <span>&#34;one&#34;</span> <span>&#34;three&#34;</span> <span>-- throws</span>
    <span>print</span> <span>(</span><span>result1</span> <span>,</span> <span>result2</span><span>)</span>
</pre></div><p>All this boilerplate attaches the callstack to our exception. We also put the entire pure error type directly into the exception. It composes. This is why pure error handling is more preferable, but if you don’t have time to do this, exceptions like above are good too. This idea of attaching call stacks to your exceptions is explained further in <a href="https://maksbotan.github.io/posts/2021-01-20-callstacks.html">this blogpost</a></p><p>If that’s to much work, the <a href="https://hackage.haskell.org/package/base/docs/Prelude.html#v:error"><code>error</code></a> call also has a stack trace, although it’s type allows vagueness unfortunately. Also make sure to attach it to <span>IO</span>, or the <a href="#throw">nullpointer</a> anti pattern may occur. I think the <a href="https://hackage.haskell.org/package/extra-1.7.10/docs/Control-Exception-Extra.html#v:errorIO"><code>errorIO</code></a> function is a good idea instead of <code>error</code> because it avoids that nullpointer scenario entirely. Don’t try to catch errors, use exceptions if you need to catch.</p><h2 id="mtl"><span>MTL</span></h2><p>I recently blogged about <a href="https://jappieklooster.nl/a-brief-intro-to-mtl.html">mtl</a>, so I’ll briefly cover how to modify this code into mtl style as well:</p><div><pre><span></span><span>throwDivide</span> <span>::</span> <span>(</span><span>HasCallStack</span><span>,</span> <span>MonadIO</span> <span>m</span><span>)</span>  <span>=&gt;</span> <span>ExceptT</span> <span>DivideFailures</span> <span>a</span> <span>-&gt;</span> <span>m</span> <span>a</span>
<span>throwDivide</span> <span>meow</span> <span>=</span> <span>do</span>
    <span>res</span> <span>&lt;-</span> <span>runExceptT</span> <span>meow</span>
    <span>case</span> <span>res</span> <span>of</span> 
      <span>Left</span> <span>err</span> <span>-&gt;</span> <span>liftIO</span> <span>$</span> <span>throwIO</span> <span>$</span> <span>MkDivideException</span> <span>err</span>
      <span>Right</span> <span>res</span> <span>-&gt;</span> <span>pure</span> <span>res</span>

<span>myDBFunc</span> <span>::</span> <span>(</span><span>MonadError</span> <span>DivideFailures</span> <span>m</span><span>,</span> <span>MonadDB</span> <span>m</span><span>)</span> <span>=&gt;</span> <span>m</span> <span>Double</span>
<span>myDBFunc</span> <span>=</span> <span>do</span>
    <span>myEnv</span> <span>&lt;-</span> <span>getMyEnv</span>
    <span>divide</span> <span>myEnv</span> <span>&#34;one&#34;</span> <span>&#34;two&#34;</span>

<span>main</span> <span>::</span> <span>IO</span> <span>()</span>
<span>main</span> <span>=</span> <span>do</span> 
    <span>result1</span> <span>&lt;-</span> <span>runDB</span> <span>$</span> <span>throwDivide</span> <span>$</span> <span>myDBFunc</span> 
    <span>print</span> <span>result1</span> 
</pre></div><p><code>throwDivide</code> works quite similarly as in the previous example but now it works with any transformer stack based on <code>IO</code>. This works because we pretend the <code>ExceptT</code> exists at the call site, which makes it come true. This is explained thoroughly in the previous <a href="https://jappieklooster.nl/a-brief-intro-to-mtl.html">blog post</a>.</p><p>Now I’ll cover several anti patterns I’ve seen and discuss what to do differently. Some of these patterns occur in the wild, for example <a href="https://hackage.haskell.org/package/aeson-2.0.3.0/docs/Data-Aeson.html#v:eitherDecode">aeson</a> famously exposes a <code>String</code> for errors, which is problematic for a library. The next section explains why.</p><h2 id="text-in-left-branch-of-either">Text in left branch of Either</h2><p>These examples contain text in the left branch:</p><div><pre><span></span><span>y</span> <span>::</span> <span>Either</span> <span>Text</span> <span>a</span>
<span>x</span> <span>::</span> <span>Either</span> <span>String</span> <span>a</span>
</pre></div><p>The problem is that we break the recover ability property. There is no way to make a closed pattern match on string. Instead we should create a sumtype for possible errors:</p><div><pre><span></span><span>data</span> <span>YErrors</span> <span>=</span> <span>YErrorOne</span>
             <span>|</span> <span>YErrorTwo</span> <span>Double</span>

<span>y</span> <span>::</span> <span>Either</span> <span>YErrors</span> <span>a</span>
</pre></div><p>This way client code can pattern match on all possible branches, and if the additional errors get introduced the compiler notifies the developer through <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Wincomplete-patterns"><code>-Wincomplete-patterns</code> warning</a>.</p><h2 id="throw"><code>throw</code></h2><p><code>throw</code> allows throwing exceptions in pure code. This is very wrong because the code ends up behaving like a null pointer in Java, due to Haskell’s non strict evaluation. In other words, this breaks the locality of errors. Consider for example:</p><div><pre><span></span><span>myInts</span> <span>::</span> <span>[</span><span>Int</span><span>]</span>
<span>myInts</span> <span>=</span> <span>[]</span>

<span>data</span> <span>EmptyException</span> <span>=</span> <span>MkEmptyException</span>
    <span>deriving</span> <span>(</span><span>Exception</span><span>,</span> <span>Show</span><span>)</span>

<span>myHead</span> <span>::</span> <span>[</span><span>Int</span><span>]</span> <span>-&gt;</span> <span>Int</span>
<span>myHead</span> <span>[]</span> <span>=</span> <span>throw</span> <span>$</span> <span>MkEmptyException</span>
<span>myHead</span> <span>(</span><span>x</span> <span>:</span> <span>y</span><span>)</span> <span>=</span> <span>x</span>

<span>main</span> <span>::</span> <span>IO</span> <span>()</span>
<span>main</span> <span>=</span> <span>do</span>
   <span>let</span> <span>x</span> <span>=</span> <span>myHead</span> <span>myInts</span>
   <span>print</span> <span>$</span> <span>[</span><span>0</span><span>..</span><span>5</span><span>]</span> <span>&lt;&gt;</span> <span>myInts</span>
   <span>print</span> <span>x</span>
</pre></div><p>It fails on that last line. Even though the error was at the <code>x</code> binding. Much better is to use <a href="https://hackage.haskell.org/package/base/docs/Control-Exception.html#v:throwIO"><code>throwIO</code></a>, modifying the above example:</p><div><pre><span></span><span>myInts</span> <span>::</span> <span>[</span><span>Int</span><span>]</span>
<span>myInts</span> <span>=</span> <span>[]</span>

<span>data</span> <span>EmptyException</span> <span>=</span> <span>MkEmptyException</span>
    <span>deriving</span> <span>Exception</span>

<span>myHead</span> <span>::</span> <span>[</span><span>Int</span><span>]</span> <span>-&gt;</span> <span>IO</span> <span>Int</span>
<span>myHead</span> <span>[]</span> <span>=</span> <span>throwIO</span> <span>$</span> <span>MkEmptyException</span>
<span>myHead</span> <span>(</span><span>x</span> <span>:</span> <span>y</span><span>)</span> <span>=</span> <span>pure</span> <span>x</span>

<span>main</span> <span>::</span> <span>IO</span> <span>()</span>
<span>main</span> <span>=</span> <span>do</span>
   <span>x</span> <span>&lt;-</span> <span>myHead</span> <span>myInts</span>
   <span>print</span> <span>$</span> <span>[</span><span>0</span><span>..</span><span>5</span><span>]</span> <span>&lt;&gt;</span> <span>myInts</span>
   <span>print</span> <span>x</span>
</pre></div><p>This will indeed fail on the first line. We lost purity, in this case <code>Either</code> could have been used as described above, which is even better. Alternatively we can use the <code>HasCallStack</code> trick, if we stick with exceptions.</p><h2 id="generic-app-exceptions">Generic app exceptions</h2><p>I’m talking about something like this:</p><div><pre><span></span><span>data</span> <span>AppException</span> <span>=</span> <span>MkAppException</span> <span>Text</span>
    <span>deriving</span> <span>Exception</span>
</pre></div><p>This is bad because it ends up being thrown at many places with no good way of recovering. Exceptions are already difficult to recover from, but if they’re re-used a lot, it becomes even more difficult. Now you’d have to pattern match on the <code>Text</code> to handle the correct error and hope no one re-uses that particular error text, ever! Furthermore the error may be vague, depending on what’s being put in the <code>Text</code> field.</p><p>It’s better to define a custom exception per situation. For example:</p><div><pre><span></span><span>data</span> <span>DBUserNotFound</span> <span>=</span> <span>MkDBUserNotFound</span> <span>{</span> <span>userId</span> <span>::</span> <span>UUID</span> <span>}</span>
    <span>deriving</span> <span>Exception</span>

<span>data</span> <span>AwsImgResourceNotFound</span> <span>=</span> <span>MkImgResourceNotFound</span> <span>{</span><span>name</span> <span>::</span> <span>Text</span><span>,</span> <span>awsId</span> <span>::</span> <span>UUID</span> <span>}</span>
    <span>deriving</span> <span>Exception</span>
</pre></div><p>These are precise and type safe, we no longer can be vague because you have to provide a <code>UUID</code> and tell what you’re talking about to throw.</p><p>However, you’ll likely already have generic app exception being called from different 400 places. Fortunately we can recover some of the locality property by rewriting the exception <a href="https://maksbotan.github.io/posts/2021-01-20-callstacks.html#capturing-stacks">in a <span>GADT</span></a> and using the <code>HasCallStack</code> trick.</p><h2 id="squashing-errors">Squashing errors</h2><p>This can occur when using bind <code>&gt;&gt;=</code> on <code>Maybe</code>, for example:</p><div><pre><span></span><span>x</span> <span>::</span> <span>Maybe</span> <span>Int</span>
<span>y</span> <span>::</span> <span>Maybe</span> <span>Int</span>

<span>z</span> <span>::</span> <span>Maybe</span> <span>Int</span>
<span>z</span> <span>=</span> <span>do</span>
   <span>x&#39;</span> <span>&lt;-</span> <span>x</span>
   <span>y&#39;</span> <span>&lt;-</span> <span>y</span>
   <span>pure</span> <span>$</span> <span>x&#39;</span> <span>+</span> <span>y&#39;</span>
</pre></div><p><code>Nothing</code> won’t tell us why <code>z</code> failed. This is wrong because it breaks preciseness. instead we should restructure like so:</p><div><pre><span></span><span>x</span> <span>::</span> <span>Maybe</span> <span>Int</span>
<span>y</span> <span>::</span> <span>Maybe</span> <span>Int</span>

<span>data</span> <span>ZFailures</span> <span>=</span> <span>NoX</span>
               <span>|</span> <span>NoY</span>

<span>z</span> <span>::</span> <span>Either</span> <span>ZFailures</span> <span>Int</span>
<span>z</span> <span>=</span> <span>do</span>
  <span>x&#39;</span> <span>&lt;-</span> <span>maybe</span> <span>(</span><span>Left</span> <span>NoX</span><span>)</span> <span>Right</span> <span>$</span> <span>x</span>
  <span>y&#39;</span> <span>&lt;-</span> <span>maybe</span> <span>(</span><span>Left</span> <span>NoY</span><span>)</span> <span>Right</span> <span>$</span> <span>y</span>
   <span>pure</span> <span>$</span> <span>x&#39;</span> <span>+</span> <span>y&#39;</span>
</pre></div><p>This will tell you exactly what went wrong, while retaining most of the power of bind. It’s fine to use <code>Maybe</code> if there is a single error case, but often this isn’t the case.</p><p>The preference relation of failing is like this:</p><div><pre><span></span>pure error handling &gt; exceptions *with* stack traces &gt; errorIO calls
</pre></div><p>Anything else is most likely <em>wrong</em> and should be avoided. Structure your programs so that it tells what goes wrong, where and why. I think most software would benefit from doing this, and these concepts are easy. Let me know if you disagree, or need help with this.</p><ul>
<li>https://github.com/waddlaw/haskell-stack-trace-plugin</li>
<li>https://www.stackbuilders.com/blog/errors-and-exceptions-in-haskell/</li>
<li>https://wiki.haskell.org/Handling_errors_in_Haskell</li>
<li>http://www.randomhacks.net/2007/03/10/haskell-8-ways-to-report-errors/</li>
<li>https://maksbotan.github.io/posts/2021-01-20-callstacks.html</li>
<li>https://hackage.haskell.org/package/validation-1.1.2/docs/Data-Validation.html</li>
</ul></div></div>
  </body>
</html>
