<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cghlewis.com/blog/joins/">Original</a>
    <h1>Let&#39;s talk about joins</h1>
    
    <div id="readability-page-1" class="page"><div>


<main role="main">
  <section>
    <article>
      
      <section>
        <p>Working with data would be so much simpler if we always only had one dataset to work with. However, in the world of research, we often have multiple datasets, collected from different instruments, participants, or time periods, and our research questions typically require these data to be linked in some way. Yet, before combining data, it‚Äôs important to consider what type of join makes the most sense for our specific purposes, as well as how to correctly perform those joins. This blog post reviews the various ways we may consider combining our data.</p>




<h2 id="types-of-joins">Types of joins
  <a href="#types-of-joins"><svg aria-hidden="true" height="26" width="26" viewBox="0 0 22 22" xmlns="http://www.w3.org/2000/svg">
      <path d="M0 0h24v24H0z" fill="currentColor"></path>
      <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path>
    </svg></a>
</h2>
<p>In general, there are two ways to link our data, horizontally or vertically. When linking or joining data horizontally we are matching rows by one or more variables (i.e., keys), making a wider dataset. When joining vertically, column names are matched and datasets are stacked on top of each other, making a longer dataset. Joins can be done in many different programs (e.g., SQL, R, Stata, SAS). Most of this post will be applicable to any language, but examples in R will be provided.</p>




<h3 id="horizontal-joins">Horizontal joins
  <a href="#horizontal-joins"><svg aria-hidden="true" height="26" width="26" viewBox="0 0 22 22" xmlns="http://www.w3.org/2000/svg">
      <path d="M0 0h24v24H0z" fill="currentColor"></path>
      <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path>
    </svg></a>
</h3>
<p>Joining data horizontally, also called merging, can be used in a variety of scenarios. A few examples include:</p>
<ol>
<li>Linking data across instruments (a student survey + a student assessment)</li>
<li>Linking data across time (a student survey in the fall + a student survey in the spring)</li>
<li>Linking data across participants (a student assessment + a teacher survey)</li>
<li>Linking for de-identification purposes (a student survey with name + a student roster with study ID)</li>
</ol>
<p>There are several different types of horizontal joins you can perform. In this post we are going to discuss mutating joins that increase the size of your dataset, as opposed to horizontal joins used for filtering data (learn more 
<a href="https://r4ds.hadley.nz/joins.html#sec-mutating-joins" target="_blank" rel="noopener">here</a>). While there are more, we will cover these four commonly used joins:</p>
<ol>
<li>Left join
<ul>
<li>In a left join, all cases in the dataset on the left (or our first selected dataset) are maintained. Any cases from the dataset on the left side are joined with any matching data that exists in the dataset on the right (or our second selected dataset). If additional, non-matching, cases exist in our right dataset, they will not be carried over.</li>
<li>Here we typically expect that the combined dataset will have the same number of rows as our original left side dataset.</li>
</ul>
</li>
<li>Right join
<ul>
<li>In a right join, all cases in the dataset on the right (or our second selected dataset) are maintained. Any cases from the dataset on the right side are joined with any matching data that exists in the dataset on the left (or our first selected dataset). If additional, non-matching, cases exist in our left dataset, they will not be carried over.</li>
<li>Here we typically expect that the combined dataset will have the same number of rows as our original right side dataset.</li>
</ul>
</li>
<li>Full join
<ul>
<li>In a full join, cases from both datasets are maintained. Any cases that exist in one dataset but not the other will be maintained in the final combined dataset.</li>
</ul>
</li>
<li>Inner join
<ul>
<li>In an inner join, only cases that exist in both datasets will be maintained. If a case exists in one but not the other, it will not exist in the combined dataset.</li>
</ul>
</li>
</ol>
<div>
<p><img src="https://cghlewis.com/blog/joins/img/fig00.PNG" alt="Four different types of horizontal joins" width="426"/></p><p>Figure 1: Four different types of horizontal joins</p>
</div>
<p>There are two important rules when performing horizontal joins.</p>
<ol>
<li>Variable names cannot repeat.
<ul>
<li>This means if a variable is named <code>gender</code> in your student survey dataset and a variable is also named <code>gender</code> in your district records demographics dataset, those names will need to be edited (e.g., district gender can be renamed to <code>d_gender</code>). You can learn more about variable naming 
<a href="https://datamgmtinedresearch.com/style#style-varname" target="_blank" rel="noopener">here</a>.</li>
<li>This rule does not apply to your linking keys (e.g., study ID), which are often named identically across datasets.</li>
</ul>
</li>
<li>Each dataset must contain a key.
<ul>
<li>There are two types of keys that allow you to link data files‚Äîprimary and foreign keys. Every dataset should include a primary key that uniquely identifies rows in a dataset. Datasets may also include foreign keys which contain values associated with a primary key in another table. While primary keys cannot include missing or duplicated values, these values are allowed with foreign keys.</li>
<li>Keys are typically one variable (e.g., a unique study ID), but they may also include more than one variable (e.g., first name + last name), in which case they are called a concatenated key (also called compound or composite key). In the Figure 2, primary keys are denoted by rectangles, and foreign keys are denoted by ovals. Arrows show how data can be linked through both primary and foreign keys.</li>
</ul>
</li>
</ol>
<div>
<p><img src="https://cghlewis.com/blog/joins/img/fig0.PNG" alt="Example of primary keys and foreign keys" width="396"/></p><p>Figure 2: Example of primary keys and foreign keys</p>
</div>




<h4 id="left-join">Left join
  <a href="#left-join"></a>
</h4>
<p>Left joins are probably one of the most common types of joins. While it can be used in many scenarios, this type of join is often helpful to use in the data de-identification process. Let‚Äôs say we have a teacher questionnaire dataset + a sample roster dataset.</p>
<div>
<p><img src="https://cghlewis.com/blog/joins/img/fig1.PNG" alt="Example datasets" width="572"/></p><p>Figure 3: Example datasets</p>
</div>
<p>Here we want to add our study ID (<code>tch_id</code>) to our questionnaire. In order to do this, we can join our questionnaire file with a roster file using a combined primary key (<code>f_name</code> and <code>l_name</code>). This works great as long as names are spelled identically across files. üòâ</p>
<div>
<p><img src="https://cghlewis.com/blog/joins/img/fig2.PNG" alt="Left join using data from Figure 3" width="406"/></p><p>Figure 4: Left join using data from Figure 3</p>
</div>
<p>We see that our combined dataset has only three cases which is exactly what we would expect when using a left join. The additional case in our right dataset should not carry over. While we could have used other types of joins, in this scenario we did not want to bring over the information for ‚ÄúDejana Robert‚Äù because she doesn‚Äôt exist in our questionnaire data and bringing her in would just create an empty row of data.</p>
<p>Let‚Äôs try this join using R. The order of the concatenated key should not matter but I tend to like to merge by last name, then first name. Here I will also fully de-identify the file by removing <code>f_name</code> and <code>l_name</code> after completing the join. I also reordered the variables to put <code>tch_id</code> at the front.</p>
<div><pre tabindex="0"><code data-lang="r"><span><span><span>library</span>(dplyr)
</span></span><span><span>
</span></span><span><span>tch_svy <span>|&gt;</span>
</span></span><span><span>  <span>left_join</span>(tch_roster, by <span>=</span> <span>c</span>(<span>&#34;l_name&#34;</span>, <span>&#34;f_name&#34;</span>)) <span>|&gt;</span>
</span></span><span><span>  <span>select</span>(tch_id, item1, item2, item3)
</span></span></code></pre></div><pre tabindex="0"><code># A tibble: 3 x 4
  tch_id item1 item2 item3
   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
1    407     4     5     4
2    409     5     1     3
3    410     3     2     3
</code></pre><p><strong>Note</strong> While that it is typically best practice, and much more convenient, if keys are identically named across files, in programs like R you can still join data even if keys are named differently. See this example where the variable names in the survey are <code>f_name</code> and <code>l_name</code> but in the roster they are <code>first_name</code> and <code>last_name</code>.</p>
<div><pre tabindex="0"><code data-lang="r"><span><span><span>library</span>(dplyr)
</span></span><span><span>
</span></span><span><span>tch_svy <span>|&gt;</span>
</span></span><span><span>  <span>left_join</span>(tch_roster, by <span>=</span> <span>c</span>(<span>&#34;l_name&#34;</span> <span>=</span> <span>&#34;last_name&#34;</span>, <span>&#34;f_name&#34;</span> <span>=</span> <span>&#34;first_name&#34;</span>)) <span>|&gt;</span>
</span></span><span><span>  <span>select</span>(tch_id, item1, item2, item3)
</span></span></code></pre></div><pre tabindex="0"><code># A tibble: 3 x 4
  tch_id item1 item2 item3
   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
1    407     4     5     4
2    409     5     1     3
3    410     3     2     3
</code></pre>



<h4 id="right-join">Right join
  <a href="#right-join"></a>
</h4>
<p>What if, however, we wanted a dataset with our full study sample in it and we did not care whether or not there was missing data for cases? In this case, we could use the same scenario as Figure 2, but instead do a right join (note that we could also just change the order of the datasets and use a left join again). Now when you join your datasets on your compound key, you will end up with four cases in your data.</p>
<div>
<p><img src="https://cghlewis.com/blog/joins/img/fig3.PNG" alt="Right join using data from Figure 3" width="397"/></p><p>Figure 5: Right join using data from Figure 3</p>
</div>
<p>Let‚Äôs try this again using R.</p>
<div><pre tabindex="0"><code data-lang="r"><span><span><span>library</span>(dplyr)
</span></span><span><span>
</span></span><span><span>tch_svy <span>|&gt;</span>
</span></span><span><span>  <span>right_join</span>(tch_roster, by <span>=</span> <span>c</span>(<span>&#34;l_name&#34;</span>, <span>&#34;f_name&#34;</span>)) <span>|&gt;</span>
</span></span><span><span>  <span>select</span>(tch_id, item1, item2, item3)
</span></span></code></pre></div><pre tabindex="0"><code># A tibble: 4 x 4
  tch_id item1 item2 item3
   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
1    407     4     5     4
2    409     5     1     3
3    410     3     2     3
4    406    NA    NA    NA
</code></pre>



<h4 id="full-join">Full join
  <a href="#full-join"></a>
</h4>
<p>Full joins are very common in research. Imagine a scenario where you are collecting multiple instruments on participants, or you are collecting the same instrument on participants over multiple time points. In those cases, you may have missing data for some participants (i.e., a participant was absent for one of those data collections), but you still want any data that you were able to collect to appear in your combined dataset.</p>
<p>Let‚Äôs say you have a student questionnaire + a student assessment. In this case we want all data from both forms to exist in our combined dataset.</p>
<div>
<p><img src="https://cghlewis.com/blog/joins/img/fig4.PNG" alt="Example datasets" width="606"/></p><p>Figure 6: Example datasets</p>
</div>
<p>If we performed a full join on these two datasets using <code>stu_id</code> as our key this time, we would expect our final dataset to have 5 cases (or rows). There is one case in each dataset that does not exist in the other.</p>
<div>
<p><img src="https://cghlewis.com/blog/joins/img/fig5.PNG" alt="Full join using data from Figure 6" width="412"/></p><p>Figure 7: Full join using data from Figure 6</p>
</div>
<p>Let‚Äôs see what a full join looks like in R.</p>
<div><pre tabindex="0"><code data-lang="r"><span><span><span>library</span>(dplyr)
</span></span><span><span>
</span></span><span><span>stu_svy <span>|&gt;</span>
</span></span><span><span>  <span>full_join</span>(stu_assess, by <span>=</span> <span>&#34;stu_id&#34;</span>)
</span></span></code></pre></div><pre tabindex="0"><code># A tibble: 5 x 7
  stu_id item1 item2 item3 math1 math2 math3
   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
1  20056     4     5     4    21    25    32
2  20134     5     1     3    15    22    41
3  20149     3     2     3    NA    NA    NA
4  20159     3     0     1    16    30    50
5  20160    NA    NA    NA    32    19    25
</code></pre>



<h4 id="inner-join">Inner join
  <a href="#inner-join"></a>
</h4>
<p>Our last horizontal join type is one that I personally use less often, but there are certainly many scenarios where this will be useful. Let‚Äôs take, for instance, the case of a pre and post survey. In this case, we may only want cases in our combined data where a participant has both pre and post data. This is when an inner join can be very useful.</p>
<p>Let‚Äôs take a look at our example pre questionnaire + post questionnaire.</p>
<div>
<p><img src="https://cghlewis.com/blog/joins/img/fig6.PNG" alt="Example datasets" width="606"/></p><p>Figure 8: Example datasets</p>
</div>
<p>Using an inner join we can merge data using our <code>stu_id</code> key again. However, in the case of longitudinal data, our variables are named identically over time which violates one of our horizontal join rules. Therefore, in order to create unique variable names, and to be able to associate each variable with a time point of data collection, we must first concatenate a time period to each repeating variable, before merging data. How time is assigned is completely up to the researcher (read 
<a href="https://datamgmtinedresearch.com/style#style-time" target="_blank" rel="noopener">here</a> for more information). In this case, I added the words ‚Äúpre‚Äù and ‚Äúpost‚Äù as prefixes, separated by a delimiter for clarity and ease of use.</p>
<div>
<p><img src="https://cghlewis.com/blog/joins/img/fig7.PNG" alt="Inner join using data from Figure 8" width="520"/></p><p>Figure 9: Inner join using data from Figure 8</p>
</div>
<p>We see that our combined dataset only shows three cases because those are the only cases with both pre and post data available. However, if there had been an empty row for <code>stud_id</code> = 20149 in the post questionnaire data, that case would have been pulled into the combined dataset.</p>
<p>Let‚Äôs see what an inner join looks like in R.</p>
<div><pre tabindex="0"><code data-lang="r"><span><span><span>library</span>(dplyr)
</span></span><span><span>
</span></span><span><span><span># First rename variables with pre and post suffix</span>
</span></span><span><span>
</span></span><span><span>stu_svy_pre <span>&lt;-</span> stu_svy_pre <span>|&gt;</span>
</span></span><span><span>  <span>rename_with</span>(<span>~</span> <span>paste0</span>(<span>&#34;pre_&#34;</span>, .), .cols <span>=</span> <span>-</span>stu_id)
</span></span><span><span>
</span></span><span><span>stu_svy_post <span>&lt;-</span> stu_svy_post <span>|&gt;</span>
</span></span><span><span>  <span>rename_with</span>(<span>~</span> <span>paste0</span>(<span>&#34;post_&#34;</span>, .), .cols <span>=</span> <span>-</span>stu_id)
</span></span><span><span>
</span></span><span><span><span># Then join data</span>
</span></span><span><span>
</span></span><span><span>stu_svy_pre <span>|&gt;</span>
</span></span><span><span>  <span>inner_join</span>(stu_svy_post, by <span>=</span> <span>&#34;stu_id&#34;</span>)
</span></span></code></pre></div><pre tabindex="0"><code># A tibble: 3 x 7
  stu_id pre_item1 pre_item2 pre_item3 post_item1 post_item2 post_item3
   &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;
1  20056         4         5         4          5          1          2
2  20134         5         1         3          5          0          3
3  20159         3         0         1          4          0          3
</code></pre><p><strong>Note</strong> Inner joins are not only for longitudinal data, they can be used for any other other scenarios we discussed. Similarly, longitudinal data can also be joined using any of the other methods we discussed.</p>




<h3 id="many-relationships">Many relationships
  <a href="#many-relationships"><svg aria-hidden="true" height="26" width="26" viewBox="0 0 22 22" xmlns="http://www.w3.org/2000/svg">
      <path d="M0 0h24v24H0z" fill="currentColor"></path>
      <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path>
    </svg></a>
</h3>
<p>Until now we have discussed scenarios that are considered <em>one-to-one</em> merges. In these cases, we only expect one participant in a dataset to be joined to one instance of that same participant in the other dataset.</p>
<p>However, there are scenarios where this will not be the case. Take for instance a case where we are merging information across participant groups (e.g., merging student data with teacher data, or merging teacher data with school data). In these cases, one teacher is often associated with multiple students and one school is often associated with multiple teachers. When we merge data like this, we are working with a <em>one-to-many</em> or a <em>many-to-one</em> merge, depending on which dataset is first or second. In this scenario, we would expect to see repeating data in our combined dataset.</p>
<p>As one example, let‚Äôs say we have a student questionnaire + a teacher questionnaire.</p>
<div>
<p><img src="https://cghlewis.com/blog/joins/img/fig8.PNG" alt="Example datasets" width="596"/></p><p>Figure 10: Example datasets</p>
</div>
<p>We can combine this data using the <code>tch_id</code> variable which exists in both datasets. However, when we join it will be a <em>one-to-many</em> or a <em>many-to-one</em> join depending on the order of the datasets and which type of join we use.</p>
<p>Let‚Äôs say for example, we use a left join, with the student questionnaire dataset on the left and the teacher questionnaire dataset on the right. Here we will be doing a <em>many-to-one</em> join, where each student is associated with multiple teachers‚Äîtwo students will be linked with <code>tch_id</code> = 406 and two students will be linked with <code>tch_id</code> = 407.</p>
<div>
<p><img src="https://cghlewis.com/blog/joins/img/fig9.PNG" alt="Many-to-one left join using data from Figure 10" width="476"/></p><p>Figure 11: Many-to-one left join using data from Figure 10</p>
</div>
<p>After combining data we see that we have four cases in our data, as we expect from using a left join, but the teacher information we merged in now repeats (twice for each <code>tch_id</code>).</p>
<p><strong>Note</strong> The typical rules of a left or right join do not apply when doing a <em>one-to-many</em> join though. Say for example we moved our teacher dataset to the left and performed a left join, this would now be a <em>one-to-many</em> join with one teacher being associated with many students. In this case, the final row number in your combined dataset will not match the count of rows in your original left dataset. Instead it will match the count of the <strong><em>many</em> dataset</strong> (i.e., the teacher level dataset will become a student level dataset). So instead of two, the final row final row count would be four.</p>
<p>Let‚Äôs perform a <em>many-to-one</em> left join using R, with our student data on the left and our teacher data on the right.</p>
<div><pre tabindex="0"><code data-lang="r"><span><span><span>library</span>(dplyr)
</span></span><span><span>
</span></span><span><span>stu_svy <span>|&gt;</span>
</span></span><span><span>  <span>left_join</span>(tch_svy, by <span>=</span> <span>&#34;tch_id&#34;</span>)
</span></span></code></pre></div><pre tabindex="0"><code># A tibble: 4 x 8
  stu_id tch_id item1 item2 item3    q1    q2    q3
   &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
1  20056    406     4     5     4     5     1     2
2  20134    407     5     1     3     5     0     3
3  20149    406     3     2     3     5     1     2
4  20159    407     3     0     1     5     0     3
</code></pre>



<h3 id="vertical-joins">Vertical joins
  <a href="#vertical-joins"><svg aria-hidden="true" height="26" width="26" viewBox="0 0 22 22" xmlns="http://www.w3.org/2000/svg">
      <path d="M0 0h24v24H0z" fill="currentColor"></path>
      <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path>
    </svg></a>
</h3>
<p>Similar to horizontal joins, there are many use cases for joining data vertically, also called appending data. Some examples include:</p>
<ol>
<li>Combining similar data across cohorts</li>
<li>Combining similar data collected from different sites or links</li>
<li>Combining similar data collected across time</li>
</ol>
<p>However, there are some fundamental differences between horizontal and vertical joins.</p>
<ol>
<li>Rather than joining data on keys, columns are matched by variable names.</li>
<li>In this case you do not want unique variable names. Here, it is imperative that variables are named and formatted identically across datasets.</li>
</ol>
<p>Let‚Äôs take an example where we have a questionnaire collected across two cohorts of teachers. We can append these data, creating a longer dataset. The inclusion of the cohort variable allows users to know which data is associated with which cohort in the combined data.</p>
<div>
<p><img src="https://cghlewis.com/blog/joins/img/fig11.PNG" alt="Appending data across cohorts" width="546"/></p><p>Figure 12: Appending data across cohorts</p>
</div>
<p>Let‚Äôs see what this type of join would look like in R. As a reminder, across the two datasets, if any of these variables are not identically named and formatted (e.g., numeric type, character type), you will get an error.</p>
<div><pre tabindex="0"><code data-lang="r"><span><span><span>library</span>(dplyr)
</span></span><span><span>
</span></span><span><span><span>bind_rows</span>(svy_c1, svy_c2)
</span></span></code></pre></div><pre tabindex="0"><code># A tibble: 7 x 5
  tch_id cohort item1 item2 item3
   &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
1    406      1     4     5     4
2    407      1     5     1     3
3    406      1     3     2     3
4    407      1     3     0     1
5    415      2     5     1     2
6    418      2     5     0     3
7    419      2     4     0     3
</code></pre><p>You can also append longitudinal data. For example, if your repeated measures analysis requires data to be in long format, rather than wide (as seen with horizontal joins), longitudinal data can be vertically joined. In this case, rather than concatenating a time component to your time varying variables, a time variable is added to the data to delineate which rows belong to which time period. How a time component is assigned is completely up to you. Here I chose to add a variable named <code>wave</code> and assign numeric values to my time points (read 
<a href="https://datamgmtinedresearch.com/style#style-time" target="_blank" rel="noopener">here</a> for more information).</p>
<p><strong>Note</strong> Even if one dataset contains variables that do not exist in the other (e.g., a variable was added to the questionnaire at a later time), appending will still work.</p>
<div>
<p><img src="https://cghlewis.com/blog/joins/img/fig12.PNG" alt="Appending data across time" width="620"/></p><p>Figure 13: Appending data across time</p>
</div>
<p>Let‚Äôs see this done using R.</p>
<div><pre tabindex="0"><code data-lang="r"><span><span><span>library</span>(dplyr)
</span></span><span><span>
</span></span><span><span><span># First add a wave variable</span>
</span></span><span><span>
</span></span><span><span>svy_w1 <span>&lt;-</span> svy_w1 <span>|&gt;</span>
</span></span><span><span>  <span>mutate</span>(wave <span>=</span> <span>1</span>)
</span></span><span><span>
</span></span><span><span>svy_w2 <span>&lt;-</span> svy_w2 <span>|&gt;</span>
</span></span><span><span>  <span>mutate</span>(wave <span>=</span> <span>2</span>)
</span></span><span><span>
</span></span><span><span><span># Then append data</span>
</span></span><span><span>
</span></span><span><span><span>bind_rows</span>(svy_w1, svy_w2) <span>|&gt;</span>
</span></span><span><span>  <span>relocate</span>(wave, .after <span>=</span> tch_id)
</span></span></code></pre></div><pre tabindex="0"><code># A tibble: 7 x 5
  tch_id  wave item1 item2 item3
   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
1    406     1     4     5    NA
2    407     1     5     1    NA
3    409     1     3     2    NA
4    410     1     3     0    NA
5    406     2     5     1     2
6    407     2     5     0     3
7    410     2     4     0     3
</code></pre><p><strong>Note</strong> Notice now that <code>tch_id</code> no longer uniquely identifies rows in our combined dataset. When appending longitudinal data, we now have a concatenated primary key that uniquely identifies rows (<code>tch_id</code> + <code>wave</code>)</p>




<h2 id="combining-joins">Combining joins
  <a href="#combining-joins"><svg aria-hidden="true" height="26" width="26" viewBox="0 0 22 22" xmlns="http://www.w3.org/2000/svg">
      <path d="M0 0h24v24H0z" fill="currentColor"></path>
      <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path>
    </svg></a>
</h2>
<p>In large research studies, it is common to combine horizontal and vertical joins. Take for instance a study that collects two waves of a teacher questionnaire, for two cohorts.</p>
<div>
<p><img src="https://cghlewis.com/blog/joins/img/fig13.PNG" alt="Example datasets" width="660"/></p><p>Figure 14: Example datasets</p>
</div>
<p>This data can be combined in many ways depending on your needs. One way we could combine this data might be</p>
<ul>
<li>First, horizontally join within cohort. Here I am choosing to do a full join.</li>
<li>Then, append the cohorts.</li>
</ul>
<p><strong>Note</strong> Since <code>cohort</code> appears in both datasets and we are joining horizontally, we will need to make a decision on which cohort variable to keep in our full join. We do not want to keep both, not only because this will cause confusion, but also because they are identically named, violating one of our rules of horizontal joins. In both cases, I choose to drop the <code>cohort</code> variable from the right side dataset because the left side dataset has the most complete information. This will not always be the case. In some cases, you may need to use the right side <strong>or</strong> combine information across both variables into one complete variable.</p>
<p>1. Let‚Äôs first join cohort 1.</p>
<div><pre tabindex="0"><code data-lang="r"><span><span><span>library</span>(dplyr)
</span></span><span><span>
</span></span><span><span><span># First rename variables with wave 1 (w1) and wave 2 (w2) suffix</span>
</span></span><span><span><span># Also, drop cohort from the wave 2 dataset</span>
</span></span><span><span>
</span></span><span><span>tch_svy_w1_c1 <span>&lt;-</span> tch_svy_w1_c1 <span>|&gt;</span>
</span></span><span><span>  <span>rename_with</span>(<span>~</span> <span>paste0</span>(<span>&#34;w1_&#34;</span>, .), .cols <span>=</span> <span>-</span><span>c</span>(tch_id, cohort))
</span></span><span><span>
</span></span><span><span>tch_svy_w2_c1 <span>&lt;-</span> tch_svy_w2_c1 <span>|&gt;</span>
</span></span><span><span>  <span>rename_with</span>(<span>~</span> <span>paste0</span>(<span>&#34;w2_&#34;</span>, .), .cols <span>=</span> <span>-</span><span>c</span>(tch_id, cohort)) <span>|&gt;</span>
</span></span><span><span>  <span>select</span>(<span>-</span>cohort)
</span></span><span><span>
</span></span><span><span><span># Then horizontally join across waves </span>
</span></span><span><span>
</span></span><span><span>tch_svy_w1w2_c1 <span>&lt;-</span> tch_svy_w1_c1 <span>|&gt;</span>
</span></span><span><span>  <span>full_join</span>(tch_svy_w2_c1, by <span>=</span> <span>&#34;tch_id&#34;</span>)
</span></span><span><span>
</span></span><span><span>
</span></span><span><span>tch_svy_w1w2_c1
</span></span></code></pre></div><pre tabindex="0"><code># A tibble: 3 x 6
  tch_id cohort w1_item1 w1_item2 w2_item1 w2_item2
   &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;
1    406      1        4        5        5        1
2    407      1        5        1        5        0
3    408      1        4        4       NA       NA
</code></pre><p>2. Next let‚Äôs join cohort 2.</p>
<div><pre tabindex="0"><code data-lang="r"><span><span><span># First rename variables with wave 1 (w1) and wave 2 (w2) suffix</span>
</span></span><span><span><span># Also, drop cohort from the wave 2 dataset</span>
</span></span><span><span>
</span></span><span><span>tch_svy_w1_c2 <span>&lt;-</span> tch_svy_w1_c2 <span>|&gt;</span>
</span></span><span><span>  <span>rename_with</span>(<span>~</span> <span>paste0</span>(<span>&#34;w1_&#34;</span>, .), .cols <span>=</span> <span>-</span><span>c</span>(tch_id, cohort))
</span></span><span><span>
</span></span><span><span>tch_svy_w2_c2 <span>&lt;-</span> tch_svy_w2_c2 <span>|&gt;</span>
</span></span><span><span>  <span>rename_with</span>(<span>~</span> <span>paste0</span>(<span>&#34;w2_&#34;</span>, .), .cols <span>=</span> <span>-</span><span>c</span>(tch_id, cohort)) <span>|&gt;</span>
</span></span><span><span>  <span>select</span>(<span>-</span>cohort)
</span></span><span><span>
</span></span><span><span><span># Then horizontally join across waves </span>
</span></span><span><span>
</span></span><span><span>tch_svy_w1w2_c2 <span>&lt;-</span> tch_svy_w1_c2 <span>|&gt;</span>
</span></span><span><span>  <span>full_join</span>(tch_svy_w2_c2, by <span>=</span> <span>&#34;tch_id&#34;</span>)
</span></span><span><span>
</span></span><span><span>
</span></span><span><span>tch_svy_w1w2_c2
</span></span></code></pre></div><pre tabindex="0"><code># A tibble: 3 x 6
  tch_id cohort w1_item1 w1_item2 w2_item1 w2_item2
   &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;
1    415      2        4        3        5        3
2    418      2        4        1        4        0
3    419      2        3        2       NA       NA
</code></pre><p>3. Now we can append the cohorts.</p>
<div><pre tabindex="0"><code data-lang="r"><span><span><span>bind_rows</span>(tch_svy_w1w2_c1, tch_svy_w1w2_c2)
</span></span></code></pre></div><pre tabindex="0"><code># A tibble: 6 x 6
  tch_id cohort w1_item1 w1_item2 w2_item1 w2_item2
   &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;
1    406      1        4        5        5        1
2    407      1        5        1        5        0
3    408      1        4        4       NA       NA
4    415      2        4        3        5        3
5    418      2        4        1        4        0
6    419      2        3        2       NA       NA
</code></pre><p><strong>Note</strong> We don‚Äôt have to combine data this way. We could change the order of how we join data (i.e., append cohorts first, then horizontally join waves), or we could change the structure of the data completely (e.g., append waves in long format, as well as append cohorts, creating a very long dataset).</p>
<hr/>
<p>Let‚Äôs look at one more scenario where we are combining joins. In this case we have a teacher questionnaire collected across two waves, and we have school-level demographic data, also collected across two waves.</p>
<div>
<p><img src="https://cghlewis.com/blog/joins/img/fig14.PNG" alt="Example datasets" width="648"/></p><p>Figure 15: Example datasets</p>
</div>
<p>Again, we could combine this data in multiple ways, but here we are going to</p>
<ul>
<li>First, append the two waves of data into long format.</li>
<li>Then, horizontally join the school data using a left join.</li>
</ul>
<p>1. Append within teacher data.</p>
<div><pre tabindex="0"><code data-lang="r"><span><span><span># First add a wave variable</span>
</span></span><span><span>
</span></span><span><span>tch_svy_w1 <span>&lt;-</span> tch_svy_w1 <span>|&gt;</span>
</span></span><span><span>  <span>mutate</span>(wave <span>=</span> <span>1</span>)
</span></span><span><span>
</span></span><span><span>tch_svy_w2 <span>&lt;-</span> tch_svy_w2 <span>|&gt;</span>
</span></span><span><span>  <span>mutate</span>(wave <span>=</span> <span>2</span>)
</span></span><span><span>
</span></span><span><span><span># Then append</span>
</span></span><span><span>
</span></span><span><span>tch_svy <span>&lt;-</span> <span>bind_rows</span>(tch_svy_w1, tch_svy_w2) <span>|&gt;</span>
</span></span><span><span>  <span>relocate</span>(wave, .after <span>=</span> tch_id)
</span></span><span><span>
</span></span><span><span>tch_svy
</span></span></code></pre></div><pre tabindex="0"><code># A tibble: 6 x 5
  tch_id  wave sch_id    q1    q2
   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
1    406     1     22     4     5
2    407     1     22     5     1
3    408     1     24     4     4
4    406     2     22     4     3
5    407     2     22     4     1
6    408     2     24     3     2
</code></pre><p>2. Append within school data.</p>
<div><pre tabindex="0"><code data-lang="r"><span><span><span># First add a wave variable</span>
</span></span><span><span>
</span></span><span><span>sch_w1 <span>&lt;-</span> sch_w1 <span>|&gt;</span>
</span></span><span><span>  <span>mutate</span>(wave <span>=</span> <span>1</span>)
</span></span><span><span>
</span></span><span><span>sch_w2 <span>&lt;-</span> sch_w2 <span>|&gt;</span>
</span></span><span><span>  <span>mutate</span>(wave <span>=</span> <span>2</span>)
</span></span><span><span>
</span></span><span><span><span># Then append</span>
</span></span><span><span>
</span></span><span><span>sch_svy <span>&lt;-</span> <span>bind_rows</span>(sch_w1, sch_w2) <span>|&gt;</span>
</span></span><span><span>  <span>relocate</span>(wave, .after <span>=</span> sch_id)
</span></span><span><span>
</span></span><span><span>sch_svy
</span></span></code></pre></div><pre tabindex="0"><code># A tibble: 4 x 4
  sch_id  wave item1 item2
   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
1     22     1   500    62
2     24     1   415    85
3     22     2   520    55
4     24     2   430    90
</code></pre><p>3. Then left join teacher data with school data.</p>
<p><strong>Note</strong> Notice that because we have longitudinal data appended in long format, I have to use a concatenated primary key to join our data.</p>
<div><pre tabindex="0"><code data-lang="r"><span><span>tch_svy <span>|&gt;</span>
</span></span><span><span>  <span>left_join</span>(sch_svy, by <span>=</span> <span>c</span>(<span>&#34;sch_id&#34;</span>, <span>&#34;wave&#34;</span>))
</span></span></code></pre></div><pre tabindex="0"><code># A tibble: 6 x 7
  tch_id  wave sch_id    q1    q2 item1 item2
   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
1    406     1     22     4     5   500    62
2    407     1     22     5     1   500    62
3    408     1     24     4     4   415    85
4    406     2     22     4     3   520    55
5    407     2     22     4     1   520    55
6    408     2     24     3     2   430    90
</code></pre>



<h2 id="additional-resources">Additional resources
  <a href="#additional-resources"><svg aria-hidden="true" height="26" width="26" viewBox="0 0 22 22" xmlns="http://www.w3.org/2000/svg">
      <path d="M0 0h24v24H0z" fill="currentColor"></path>
      <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path>
    </svg></a>
</h2>
<p>This blog post is just a primer to get you started thinking about joins. There are many more joins, as well as many more combinations of joins that can be used! In the end, it all depends on what is useful for your project and your purposes (read 
<a href="https://datamgmtinedresearch.com/structure#structure-datastructure" target="_blank" rel="noopener">here</a> for more information). Also, just because you can join data, doesn‚Äôt mean you need to rush into it. Datasets can be easily stored separately until it becomes necessary for you to join them. I usually think this is the best method because it allows you to more easily update individual files as needed, and it prevents you from potentially joining in a way that is ultimately not necessary or not aligned with what is needed (more information can be found 
<a href="https://datamgmtinedresearch.com/style#style-time" target="_blank" rel="noopener">here</a>).</p>
<p>For further learning, check out these additional very helpful resources!</p>
<ul>
<li>
<a href="https://r4ds.hadley.nz/joins.html#introduction" target="_blank" rel="noopener">R for Data Science (2e)</a></li>
<li>
<a href="https://tavareshugo.github.io/r-intro-tidyverse-gapminder/08-joins/index.html" target="_blank" rel="noopener">Data Carpentry: Joining Tables</a></li>
<li>
<a href="https://rforhr.com/join.html" target="_blank" rel="noopener">R for HR</a></li>
</ul>

        
        <details closed="">
  <dl>
    <dt>Posted on:</dt>
    <dd>January 10, 2024</dd>
  </dl>
  <dl>
    <dt>Length:</dt>
    <dd>19 minute read, 3939 words</dd>
  </dl>
  
  <dl>
    <dt>Categories:</dt>
    <dd> <a href="https://cghlewis.com/categories/tutorials">tutorials</a> </dd>
  </dl>
  
  
  
  <dl>
    <dt>Tags:</dt>
    <dd> <a href="https://cghlewis.com/tags/rstats">rstats</a>  <a href="https://cghlewis.com/tags/data-cleaning">data cleaning</a>  <a href="https://cghlewis.com/tags/data-organization">data organization</a> </dd>
  </dl>
  
  <dl>
    <dt>See Also:</dt>
    
    <dd><a href="https://cghlewis.com/blog/data_clean_03/">Cleaning sample data in standardized way</a></dd>
    
    <dd><a href="https://cghlewis.com/blog/data_clean_02/">Creating a data cleaning workflow</a></dd>
    
    <dd><a href="https://cghlewis.com/blog/data_clean_01/">Data cleaning for data sharing</a></dd>
    
  </dl>
</details>

      </section>
      
    </article>
    
      


    
  </section>
</main>


      </div></div>
  </body>
</html>
