<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://shaunlebron.github.io/parinfer/">Original</a>
    <h1>Parinfer: Simpler Lisp Editing</h1>
    
    <div id="readability-page-1" class="page"><div id="app">

<!------------------------------------------------------------------------------------>

<div>
<section>
  
  

<p><i></i>
<strong>Best viewed</strong> on wide desktop browsers.  Sorry for the inconvenience.
</p>

</section>
</div>

<!------------------------------------------------------------------------------------>

<div>
<section>
<p>
Let&#39;s simplify the way we write Lisp...
</p>

<p><i></i>
<strong>Try it!</strong> Interrupt the animations below to try it for yourself. Click outside to restore it.
</p>


<div>
<p><strong>Parinfer&#39;s &#34;Indent Mode&#34;</strong> rearranges parens when you change indentation:</p>
</div>

<div>
<p><strong>Insert or delete a line</strong> without rearranging parens:</p>
</div>

<div>
<p><strong>Comment a line</strong> without rearranging parens:</p>
</div>

<div>
<p><strong>Basic Paredit without hotkeys</strong> thanks to simple paren inference. (wrap, splice, slurp, barf)</p>
</div>

<div>
<p><strong>Preserve indentation</strong> when editing in &#34;Paren Mode&#34;:</p>
</div>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div>
<section>

<p>
<span>Parinfer</span> is a proof-of-concept editor mode for Lisp
programming languages.  It simplifies the way we write Lisp by auto-adjusting
parens when indentation changes and vice versa. The hope is to make basic
Lisp-editing easier for newcomers and experts alike, while still allowing
existing plugins like Paredit to satisfy the need for more advanced operations.
</p>

<ul>
  <li>Source code: <a href="http://github.com/shaunlebron/parinfer">http://github.com/shaunlebron/parinfer</a><br/>
  </li><li>Created by: <a href="http://github.com/shaunlebron">@shaunlebron</a><br/>
  </li><li>Download (work in progress): <a href="#editor-plugins">Editor Plugins</a>
</li></ul>

<p><i></i>
<strong>Read on</strong> for a full exploration of the motivations, rules, and effects of Parinfer.
</p>

</section>
</div>

<!------------------------------------------------------------------------------------>

<div>
<section id="introduction">
<h2>Introduction</h2>

<p>
<strong>Lisp is often dismissed</strong> as an undesirable programming syntax
due to excessive parentheses.  Those who have adopted Lisp have long recognized its
amazing strengths, but there is still a widely held uncertainty among newcomers about
how or even <em>why</em> we must manage so many parens.  As a result, Lisp&#39;s
unique power remains invisible to most under this guise of difficulty.
</p>

<p>
<strong>Newcomers aren&#39;t satisfied</strong> with the current tools designed for
editing Lisp.  Expert-level editors (Emacs, Vim) and advanced hotkeys (Paredit)
are powerful but steepen the learning curve.  And alternative syntaxes (Lisps
without parens) have faltered since they sacrifice some of Lisp&#39;s power that
seasoned users aren&#39;t willing to part with.
</p>

<p>
<strong>Parinfer is a new system</strong> that tries instead to fix this
problem at its source.  We formally define the relationship between Parens and
Indentation. With it, we create an intuitive editor mode to make paren
management fun and easy without sacrificing power.  We demonstrate this through
interactive proof-of-concept demos here, providing capabilities for:
</p>

<ul>
<li> making code auto-adhere to formatting conventions
</li><li> influencing expression-nesting with indentation
</li><li> maintaining indentation when expressions shift
</li><li> allowing
<a href="http://danmidwood.com/content/2014/11/21/animated-paredit.html">Paredit</a>-like
features without hotkeys
</li></ul>

<blockquote>
<p>
<strong>NOTE: When I say &#34;parens&#34;</strong> (parentheses), I also mean <em>[square]</em> or <em>{curly}</em>
brackets.  Some Lisps (e.g.
<a href="http://racket-lang.org/">Racket</a>,
<a href="http://clojure.org/">Clojure</a>)
use these extra delimiters to help visually separate certain constructs.
</p>
</blockquote>


</section>
</div>

<!------------------------------------------------------------------------------------>

<div>
<section id="uncovering-lisp">
<h3>Uncovering Lisp</h3>

<p>
Most programming languages have several syntax rules.  Lisp has one:
everything is a list.  The first element is a function name, and the rest are
its arguments.  Thus, the language is simply a collection of compile- and
run-time functions, trivially extensible.
</p>



<p>
But parentheses in Lisp are infamous for bunching together at the end of long
expressions. This indentation
<a href="https://en.wikipedia.org/wiki/Indent_style#Lisp_style">convention</a>
can be jarring at first if you are used to curly braces in other languages
being on their own lines:
</p>

<div>
<div>
<p><strong>C Style</strong> indentation (unusual in Lisp):</p>
</div>


</div>

<p>
The idea behind this convention is to make every line inform with content
rather than just parens. Readability is helped by employing a Python-like
indentation style.  This achieves a sort of balance— Indentation allows
you to <em>skim</em> while the parens allow you to <em>inspect</em>:</p>

<div>
<div>
<p><strong>Skim</strong> by focusing on indentation</p>
</div>

<div>
<p><strong>Inspect</strong> parens with your cursor when needed</p>
</div>
</div>

<p>
Though both <em>perspectives</em> are visible at once, we must focus on one at
a time.  A
<a href="https://twitter.com/paulg/status/588511912331055104">LEGO analogy</a>
helps here. Imagine each list in the previous example as a LEGO block
stacked over its parent. Checking the sides to see the layers below is like
checking the parens at the end of a line.
</p>

<div>
<div>
<p><strong>Indentation</strong> implies nesting.</p>
<p><img src="https://www.stevegattuso.me/2025/01/20/img/lego-indent.png"/>
</p></div>

<div>
<p><strong>Tilting</strong> clarifies nesting (close-parens shown).</p>
<p><img src="https://www.stevegattuso.me/2025/01/20/img/lego-parens.png"/>
</p></div>
</div>

<p>
This is a physical analog to the way we read Lisp code.  Now let&#39;s look at the
space of tooling solutions that we use for <em>writing</em> Lisp code and
specifically how Parinfer can help.
</p>

</section>
</div>

<!------------------------------------------------------------------------------------>

<div>
<section id="tools-for-writing-lisp">
<h3>Tools for Writing Lisp</h3>

<p>
In the previous section, we saw how Parens and Indentation provide two
perspectives for reading Lisp code.  Unfortunately, this incurs some redundancy
when <em>writing</em> Lisp since we must edit both for every change, ensuring
that one will correctly imply the other.
</p>

<p>
There are existing tools to help with this.  To best represent how Parinfer
compares to them, we will represent this complex space of tooling in a way that
can be visually compared below.
</p>

<p><i></i>
<strong>The black gear</strong> represents the current action we are taking.
</p>

<p>
<strong>The menial and default</strong> way to edit Lisp is to manually ensure
our parens are balanced after inserting or removing them.  Then, we adjust the
indentation to match it in kind.  This back-and-forth happens for most editing
tasks.
</p>



<p>
<strong>Existing tools automate</strong> some of these editing tasks.
For example, <em>Paredit</em> forces you to transform or add parens in a
balanced way through special hotkeys.  And <em>Auto-indent</em> allows you to
auto-correct indentation of selected lines when desired.  This automates
the tasks, but the back-and-forth actions are still manually triggered.</p>



<p>
<strong>Parinfer is a new tool to <em>combine and simplify</em></strong> this
type of automation by naturally keeping Parens and Indentation in lockstep.  It
formally <em>infers</em> changes to one based on the other.  The back-and-forth
actions have been reduced with special modes, which we will explore next.
</p>



</section>
</div>

<!------------------------------------------------------------------------------------>

<div>
<section id="writing-with-parinfer">
<h3>Writing with Parinfer</h3>

<p>
As we saw with the previous visualization, Parinfer will infer some changes to
keep Parens and Indentation inline with one another.  To keep this inference
simple and predictable, we have the user explicitly choose the degree of
freedom that <em>they</em> want full control of, while relinquishing some
control of the other to <em>Parinfer</em>.
</p>

<p>
Thus, Parinfer consists of two modes:
</p>

<ol>
<li>
<strong>Indent Mode</strong> gives you full control of indentation, while
Parinfer corrects parens.<br/>
</li>
<li>
<strong>Paren Mode</strong> gives you full control of parens, while Parinfer
corrects indentation.<br/>
</li>
</ol>

<p><i></i>
<strong>To make this easier</strong>, Indent Mode is default. Paren Mode can be an advanced option.
</p>

<p>
Some noteworthy unintended use-cases which we will explore later:
</p>

<ul>
  <li>Indent Mode allows Paredit-like features without hotkeys.</li>
  <li>Paren Mode can be used to fix incorrectly indented files before using with Indent Mode.</li>
</ul>

</section>
</div>

<!------------------------------------------------------------------------------------>

<div>
<section id="mathematical-foundation">
<h3>Mathematical Foundation</h3>

<p><i></i>
<strong>Feel free to <a href="#indent-mode">skip this</a></strong> if you have no interest in the math that makes Parinfer possible.
</p>

<p>
The foundation of Parinfer relies on a few somewhat formalized definitions and
properties:
</p>

<div>
<p>
We wish to define properties that each Parinfer mode should exhibit.
</p>

<p>
With the following definitions:
</p><ul>
  <li>$I$ = (Indent Mode) function accepting code text and returning new text.</li>
  <li>$P$ = (Paren Mode) function accepting code text and returning new text.</li>
  <li>$R$ = (Reader) function accepting code text and returning its AST data.</li>
</ul>


<p>
The following should be true:
</p><ul>
  <li>let $y = P(x)$
        <p>
          $\leftarrow$ run Paren-Mode on $x$ to get $y$
        </p>
    <ul>
      <li>$\Longrightarrow R(x) = R(y)$
        <p>
          $\leftarrow$ Paren-Mode should never change the AST
        </p>
      </li><li>$\Longrightarrow P(y) = y$
        <p>
          $\leftarrow$ Paren-Mode should be idempotent
        </p>
      </li><li>$\Longrightarrow I(y) = y$
        <p>
          $\leftarrow$ Indent-Mode should never change the result of Paren-Mode
        </p>
    </li></ul>
</li></ul>

<ul>
  <li>let $z = I(x)$
        <p>
          $\leftarrow$ run Indent-Mode on $x$ to get $z$
        </p>
    <ul>
      <li>$\mathrel{\rlap{\hskip .5em/}}\Longrightarrow R(x) = R(z)$
        <p>
          $\leftarrow$ Indent-Mode may change the AST (by design)
        </p>
      </li><li>$\Longrightarrow I(z) = z$
        <p>
          $\leftarrow$ Indent-Mode should be idempotent
        </p>
    </li></ul>
</li></ul>


</div>

<p>
The actual operations performed by the modes rely on a formal definition
of what it means for Lisp code to be &#34;correctly formatted&#34;.  We establish an
invariant— something that must be true for every line of code.  From that,
Parinfer corrects indentation or parens simply by choosing correct values for
$i_n$ or $p_n$ (defined later) to satisfy this invariant:
</p>

<ul>
  <li><strong>Indent Mode</strong> forces correct values of $p_n$</li>
  <li><strong>Paren Mode</strong> forces correct values of $i_n$</li>
</ul>

<p>
The following is a concise reference (not a guide) to establishing this
invariant that Parinfer&#39;s modes rely on.
</p>

<div>
<p>
We wish to define necessary conditions for determining if a given file of Lisp
code is &#34;correctly formatted&#34;.
</p>

<p>
We start with a clarification that we only consider non-empty lines (i.e. lines
that have at least one non-whitespace, non-comment token).  Thus, all following
references to line number $n$ will refer to the $n$th non-empty line.
</p>

<p>
To proceed, we define the following:

</p><ul>
<li>
$t_n$ = (tokens) index of non-whitespace, non-comment tokens at line $n$
</li>
<li>
$i_n$ = (indentation) x-position of $t_n[0]$
</li>
<li>
$p_n$ = (parens) number of close-parens at the end of $t_n$
</li>
<li>
$s_n$ = (stack) index of x-positions of all open-parens unclosed before $t_n[-p_n]$
</li>
</ul>


<p>
Next, we define a function which determines if a line&#39;s indentation is valid:

</p><ul>
  <li>$f(i,p,s) = ( x_\text{min} \lt i \leq x_\text{max} )$
    <p>$\leftarrow$ verifies indentation is within a threshold defined below</p>
  </li>
</ul>


<p>
where:
</p><ul>
  <li>$x_\text{min} = \begin{cases} s[-p-1] &amp; \text{if } |s| &gt; p, \\ -1 &amp; \text{otherwise} \end{cases}$
    <p>
      $\leftarrow$ x-position of open-paren of parent list if it exists
    </p>
  </li>
  <li>$x_\text{max} = \begin{cases} s[-p] &amp; \text{if } p \gt 0, \\ \infty &amp; \text{otherwise} \end{cases}$
    <p>
      $\leftarrow$ x-position of open-paren of previous sibling if it is a list
    </p>
  </li>
</ul>



<p>
Finally, we define that a file of Lisp code is &#34;correctly formatted&#34; if:

</p><ol>
  <li>for every line $n &gt; 0$:
    <ul>
      <li>$t_n[0] \ne $ &#34;)&#34;, and
        <p>
          $\leftarrow$ no line may start with a close-paren
        </p>
      </li>
      <li>$f(i_n, p_{n-1}, s_{n-1})$ is true
        <p>
          $\leftarrow$ indentation threshold that we defined above
        </p>
      </li>
    </ul>
  </li>
  <li>and for the last line $N$
    <ul>
      <li>$|s_N| = p_N$
        <p>
          $\leftarrow$ all open-parens must be closed at the last line
        </p>
      </li>
    </ul>
  </li>
</ol>


</div>

<p>
These rules are necessary and sufficient for determining when indentation is
what we consider &#34;unambiguous&#34;, but they are not sufficient in determining if
code is &#34;pretty&#34;. For example:

</p><ul>
<li>single-line files are okay</li>
<li>&#34;tab&#34; lengths are flexible (one space, two spaces, etc)</li>
<li>indentation of sibling lines are not required to be aligned</li>
</ul>


<p>
Formal descriptions of the actual operations performed by the modes are
pending, but informal ones follow in their respective sections below.
</p>

</section>
</div>

<!------------------------------------------------------------------------------------>

<div>
<section id="indent-mode">
<h2>Indent Mode</h2>

<p>
Indent Mode gives you full control of indentation, while Parinfer corrects or
inserts close-parens where appropriate.  Specifically, it only touches the
groups of close-parens at the end of each line.  As a visual cue, we
<em>slightly dim</em> these parens to signify their inferred nature.
</p>

<p><i></i>
<strong>Try it!</strong> Interrupt the animations below to try it for yourself. Click outside to restore it.
</p>

<div>
<p><strong>Indent</strong> to influence the structure of your code:</p>
</div>

<div>
<p><strong>Indent further</strong> to reach different thresholds:</p>
</div>

<div>
<p><strong>Indent multiple lines</strong> to see its effect:</p>
</div>

<p>
You can select multiple lines and adjust their indentation the standard way using
the controls below.  If you are familiar with Paredit, these operations are
roughly equivalent to those listed.
</p>

<table>
<tbody><tr>
<th>Controls</th>
<th>Description</th>
<th>Paredit equivalent</th>
</tr>
<tr>
<td><kbd>Tab</kbd></td>
<td>indent line(s)</td>
<td>slurp line(s) down</td>
</tr>
<tr>
<td><kbd>Shift</kbd> + <kbd>Tab</kbd></td>
<td>dedent line(s)</td>
<td>barf line(s) down</td>
</tr>
</tbody></table>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div>
<section id="interesting-consequences">
<h3>Interesting Consequences</h3>

<div>
<p><strong>Insert or delete a line</strong> without rearranging parens:</p>
</div>

<div>
<p><strong>Comment a line</strong> without rearranging parens:</p>
</div>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div>
<section id="indent-how-it-works">
<h3>How it works</h3>

<p>
We perform the following steps to rearrange close-parens based on indentation.</p>

<ol>
<li> <span>remove</span> all unmatched close-parens (for housekeeping)
</li><li> <span>remove</span> all close-parens at the start and end of each line
</li><li> <span>keep</span> all close-parens <em>inside</em> each line
</li><li> for every resulting unmatched open-paren:
  <ul>
  <li> <span>insert</span> a matching close-paren at the end of its line or its last non-empty indented line
  </li></ul>
</li></ol>

<p><i></i>
<strong>Try it!</strong> Edit the code below on the left to see how parens are inferred on the right.
</p>


<div>
<div>
<p><strong>Input:</strong> close-parens are removed or kept.</p>
</div>

<div>
<p><strong>Output:</strong> close-parens are inserted.</p>
</div>
</div>

<p>
This is the gist of what&#39;s happening.  There are more steps performed, but we
will just explore their effects in the next section.
</p>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div>
<section id="paredit-emerges">
<h3>Paredit emerges</h3>

<p>
You should be aware that the steps in the previous section have a side effect on
what you type.  Interestingly, these effects translate into four of the main
<a href="">Paredit</a>
 operations.
</p>

<table>
<tbody><tr>
<th>Cause</th>
<th>Effect</th>
<th>Description</th>
</tr>

<tr>
<td>Insert <kbd>(</kbd></td>
<td>Wrap</td>
<td>
inserts a matching <kbd>)</kbd> as far as it can
<p>
i.e. &#34;wraps&#34; all possible elements to the right of your cursor
</p>
</td>
</tr>

<tr>
<td>Insert <kbd>)</kbd></td>
<td>Barf</td>
<td>
removes the original <kbd>)</kbd> when inserted inside a matching pair
<p>
i.e. the current list &#34;barfs&#34; out all elements to the right of your cursor
</p>
</td>
</tr>

<tr>
<td>Delete <kbd>(</kbd></td>
<td>Splice</td>
<td>
removes the matching <kbd>)</kbd>
<p>
i.e. &#34;splices&#34; the current list into its parent (or simply &#34;unwraps&#34; it)
</p>
</td>
</tr>

<tr>
<td>Delete <kbd>)</kbd></td>
<td>Slurp</td>
<td>
inserts another <kbd>)</kbd> as far as it can
<p>
i.e. the current list &#34;slurps&#34; all elements to the right of your cursor
</p>
</td>
</tr>

</tbody></table>

<p>
We illustrate these operations in the following examples.
</p>

</section>
</div>

<!------------------------------------------------------------------------------------>

<div>
<section id="inserting-parens">
<h3>Inserting Parens</h3>

<div>
<p><strong>Wrap</strong> by inserting an open-paren. It will auto-close as far as it can, due to rule #4.</p>
</div>

<div>
<p><strong>Barf</strong> by inserting a close-paren before another.
Notice the original is removed, due to rule #1.</p>
</div>

<div>
<p><i></i>
Why can&#39;t I insert a close-paren in certain places?
</p>
<p>Its corresponding open-paren must be there first. (see rule #1)</p>
</div>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div>
<section id="deleting-parens">
<h3>Deleting Parens</h3>

<div>
<p><strong>Splice</strong> by removing an open-paren. Its corresponding close-paren is removed, due to rule #1.</p>
</div>

<div>
<p><strong>Slurp</strong> by deleting a close-paren inside a line. It is replaced further down, due to rule #4.</p>
</div>

<div>
<p><i></i>
Why can&#39;t I delete a close-paren in certain places?
</p>
<p>You cannot delete an inferred close-paren. It is replaced as soon as you delete it. (see rule #4)</p>
</div>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div>
<section id="knowing-when-parens-move-in-indent-mode">
<h3>Knowing When Parens Move</h3>

<p>
As a courtesy, <em>Indent Mode</em> will not move your parens until you are done typing
in front of them.  Just move your cursor away when you&#39;re done.  A helpful
analogy might be to think of your cursor as a <em>paperweight</em> that keeps your
parens from blowing away.
</p>

<div>
<p><strong>Paren displaced</strong> when your cursor moves to another line. (displaced due to indentation)</p>
</div>

<div>
<p><strong>Paren not displaced</strong> since you were given the chance to block it. (paren not at end of line)</p>
</div>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div>
<section id="inserting-quotes">
<h3>Inserting Quotes</h3>

<p>
<em>Parinfer</em> cannot infer anything about quote positions like it can with parens.
So it doesn&#39;t try to do anything special with them, other than abandon
processing if imbalanced quotes are detected.
</p>

<div>
<p><strong>Quote</strong> insertion allows temporary paren imbalances until quote is closed:</p>
</div>

<div>
<p><i></i>
WARNING: Always make sure quotes are balanced when inside comments!
</p>
<p>
If there is an unclosed quote before a comment, which itself contains
imbalanced quotes, they will balance each other out and fool <em>Parinfer</em> into
thinking it is okay for processing.
</p>
</div>

<div>
<div>
<p><i></i>
<strong>BAD:</strong> An unclosed string in a comment can cause corrupted strings.
</p>
</div>

<div>
<p><i></i>
<strong>GOOD</strong>: Balance the quotes in the comment to prevent the problem.
</p>
</div>
</div>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div>
<section id="paren-mode">
<h2>Paren Mode</h2>

<p>
Paren Mode gives you full control of parens, while Parinfer corrects indentation.
You can still adjust indentation, but you won&#39;t be able indent/dedent past certain
boundaries set by parens on previous lines.  As a courtesy, this mode also
maintains relative indentation of child elements when their parent expressions
shift.
</p>

<p>
Here are some things that cannot be done in Indent Mode:
</p>

<div>
<p><strong>Tune indentation</strong> without worrying about crossing a paren boundary:</p>
</div>

<div>
<p><strong>Avoid fracturing</strong> a multi-line expression when pushing its open-paren forward:</p>
</div>

<div>
<p><strong>Indentation is maintained</strong> when parens shift, ensuring reversible operations:</p>
</div>

<div>
<p><strong>Nested expressions</strong> become automatically indented (temporary imbalances allowed):</p>
</div>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div>
<section id="paren-how-it-works">
<h3>How it works</h3>

<p>
Paren Mode performs the following steps:
</p>

<ol>
<li> Move close-parens at the start of a line to the end of the previous non-empty line.
</li><li> Clamp the indentation of a line to the following range:
  <ul>
    <li> min: x-position of the parent open-paren (if it exists)
    </li><li> max: x-position of the open-paren belonging to the previous non-empty line&#39;s last close-paren
  </li></ul>
</li><li> Child elements of moved expressions should maintain their original relative indentation to them.
</li><li> Cancel processing if there are any unmatched parens.
</li></ol>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div>
<section id="switching-modes">
<h3>Switching Modes</h3>

<p>
If there are paren imbalances in Paren Mode, the code is not processed, and you
are prevented from switching to Indent Mode.  This safely quarantines the
imbalances that could be misinterpreted in Indent Mode.  Thus, Paren Mode gives
you an environment to fix them, after which the code is automatically formatted
and ready for Indent Mode should you choose to switch.
</p></section>
</div>


<!------------------------------------------------------------------------------------>

<div>
<section id="fixing-existing-files">
<h3>Fixing existing files</h3>

<p>
We must take parens literally when opening an existing file. Incidentally,
Paren Mode is perfect for this job, so we preprocess existing files with it
before allowing the switch to Indent Mode.
</p>

<p><i></i>
<strong>Try it!</strong> Edit the code below on the left to see how it is formatted on the right.
</p>

<div>
<div>
<p><strong>Input:</strong> Any existing file. Must be correctly balanced, but can be incorrectly formatted.</p>
</div>

<div>
<p><strong>Output:</strong> Made ready for Parinfer by correcting indentation and moving close-parens.</p>
</div>
</div>

<p>
Notice that this process is NOT an invasive pretty-printer.  Newline characters
are never added or removed.  It preserves as much as it can of the original
code, only moving close-parens and changing indentation.
</p>

<p>
<em>Parinfer</em> should remain in Paren Mode if the file cannot be processed, due
to the reasons stated in the previous section.
</p>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div>
<section id="knowing-when-parens-move-in-paren-mode">
<h3>Knowing When Parens Move</h3>

<p>
As a courtesy, <em>Paren Mode</em> will not move your parens while your cursor
is behind them. Just move your cursor away when you&#39;re done.  A helpful
analogy might be to think of your cursor as a <em>paperweight</em> that keeps
your parens from blowing away.
</p>

<div>
<p><strong>Parens displaced</strong> only after they are balanced.</p>
</div>

<div>
<p><strong>Parens not displaced</strong> if the cursor is behind it (allowing you to type).</p>
</div>

<div>
<p><strong>Parens displaced</strong> if the cursor is no longer behind them.</p>
</div>

</section>
</div>

<!------------------------------------------------------------------------------------>

<p>
<section id="conclusions">
<h2>Conclusions</h2>
</section>
</p>

<!------------------------------------------------------------------------------------>

<div>
<section id="benefits">
<h3>Benefits</h3>

<p>
Inferring parentheses based on indentation seems to lead to simpler editing
mechanics for Lisp code.  It leads to a system that keeps our code formatted
well. And it allows us to use paredit-like features without hotkeys.
</p>

<p>
I think the biggest win is its potential to quell fear of managing end-of-line
parens by enforcing a direct driving relationship with indentation.
</p>

<p>
And just like <em>Paredit</em> it maintains paren-balanced code.
</p>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div>
<section id="downsides">
<h3>Downsides</h3>

<p>
The rules for what happens when inserting/deleting parens must be learned.
Also, the case necessitating a &#34;Paren Mode&#34; comes at the cost of forcing the
user to understand when and how to switch editing modes.
</p>

<p>
Also, the preprocessor step performed when opening files will cause more
formatting-related changes in your commit history when collaborating with
others not using <em>Parinfer</em>.
</p>
</section>
</div>

<!------------------------------------------------------------------------------------>

<div>
<section id="final-thoughts">
<h3>Final Thoughts</h3>

<p>
Regardless of how we choose to edit our Lisp code, there seems to always be a
balancing act between maintaining the simplicity of how we interact with the
editor and accepting some editor complexity to gain automation over these
powerful but numerous parens.
</p>

<p>
Building the interactive examples for this page has allowed me to explore how
well Parinfer can play this balancing act, but only in a demo environment.
The <em>real test</em> will come once it becomes available to major editors.
See <a href="#editor-plugins">editor plugins</a> for progress.
</p>

</section>
</div>

<!------------------------------------------------------------------------------------>

<p>
<section id="appendix">
<h2>Appendix</h2>
</section>
</p>

<!------------------------------------------------------------------------------------>

<div>
<section id="source-code">
<h3>Source Code</h3>

<p>
The text formatting code is intended to be editor-agnostic.  It is implemented
in straightforward, imperative JavaScript, optimized for speed and designed
to be easy to port to other languages. There is a test suite which is also
designed to be easy to port with all test cases represented in JSON files.
</p>

<p>
The editor demos on this site are created in CodeMirror with hooks to apply our
formatters and update cursor position.  Source code for both the library and site
are available on github:
</p>

<p>
<i></i> <a href="http://github.com/shaunlebron/parinfer">http://github.com/shaunlebron/parinfer</a>
</p>

</section>
</div>

<!------------------------------------------------------------------------------------>



<!------------------------------------------------------------------------------------>

<div>
<section id="acknowledgements">
<h3>Acknowledgements</h3>

<ul>

  <li>
    <a href="https://elpa.gnu.org/packages/adjust-parens.html">adjust-parens</a>
    is an earlier idea for adjusting close-parens based on indentation in Emacs.
  </li>

  <li>
    <a href="https://github.com/Malabarba/aggressive-indent-mode">aggressive-indent-mode</a>
    re-indents code after every keystroke in Emacs, to remove the back-and-forth actions mentioned
    in the <a href="#tools-for-writing-lisp">Tools for Writing Lisp</a> section.
    I believe Parinfer&#39;s Paren Mode is less aggressive in that it keeps
    indentation within thresholds rather than hard limits (more on this in a
    future section).
  </li>

  <li>
    <a href="http://haml.info">Haml</a>,
    <a href="http://slim-lang.com/">Slim</a>,
    <a href="http://jade-lang.com/">Jade</a> —
    comparing these indented-templating languages to Clojure&#39;s Hiccups is what
    made me realize Lisp close-parens could be inferred from indentation.
  </li>

  <li>
    Thanks to
    <a href="https://github.com/boxed">Anders Hovmöller</a> and
    <a href="https://github.com/darwin">Antonin Hildebrand</a> for humoring me on an
    <a href="https://github.com/boxed/indent-clj/issues/1">early crazy idea</a>
    and connecting me to some ideas about indentation and structural editors.
  </li>

  <li>
    <a href="http://readable.sourceforge.net/">sweet-expressions</a>,
    <a href="http://srfi.schemers.org/srfi-49/srfi-49.html">i-expressions</a>,
    <a href="https://github.com/boxed/indent-clj">indent-clj</a>, et al
    explored how parentheses can be inferred (but hidden).
  </li>

  <li>
    <a href="http://learnyouahaskell.com/higher-order-functions#function-application">Haskell&#39;s $ operator</a>
    infers a closing paren after all expressions to the right, even after
    subsequent indented expressions, which is basically what Indent Mode in
    Parinfer does.
  </li>

  <li>
    <a href="https://github.com/Cirru/sepal.clj">Cirru Sepal in Clojure</a>
    has an interesting approach to inferring Clojure parens from indentation
    and other syntax sugar— <code>$</code>, <code>$ []</code>, <code>$
    {}</code> and <code>,</code>.
  </li>

  <li>
    It&#39;s worth mentioning
    <a href="https://github.com/mkremins/flense">Flense</a>
    and
    <a href="https://github.com/darwin/plastic">Plastic</a>
    as tools with ambitious structural editing concepts for Clojure text.
  </li>

  <li>
    <a href="http://www.greenfoot.org/frames/">Frame-Based Editing</a> and
    <a href="https://scratch.mit.edu/">Scratch</a> remove parens (or curly braces)
    using blocks (like the LEGO metaphor mentioned).
  </li>

  <li>
    <a href="http://danmidwood.com/content/2014/11/21/animated-paredit.html">Paredit animations</a>
    inspired the editor animations here.
  </li>

  <li>
    <a href="https://github.com/bbatsov/clojure-style-guide#source-code-layout--organization">The Clojure Style Guide</a>
    helped me confirm some indentation conventions when formalizing Parinfer.
  </li>

  <li>
    <a href="https://twitter.com/escherize">Bryan Maass</a>
    explained to me how Lisp is like Lego— everything being the same
    shape so they can snap together any way you see fit, while other syntaxes
    have different shaped pieces which only fit together in special ways.
  </li>

  <li>
    Thanks to
    <a href="http://chrisoakman.com/">Chris Oakman</a>
    for proof-reading this page, pushing me to make an efficient implementation
    of Indent Mode, and starting the
    <a href="https://github.com/oakmac/atom-parinfer">atom-parinfer</a>
    plugin.
  </li>

  <li>
    Thanks to my friends at PROS for looking at an early draft of this page.
  </li>

  <li>
    Thanks to the Clojure/ClojureScript community for making me fall in love
    with Lisp.
  </li>

  <li>
    When John Carmack adopted Lisp (Racket) for Oculus Rift scripting,
    it gave me a little more momentum to finish writing this!
  </li>

  <li>
    I used the really cool <a href="https://github.com/liabru/gears-d3-js">gears.d3.js</a>
    library for the animated gears here.
  </li>

  <li>
    I built Parinfer as an augmentation to the
    <a href="https://codemirror.net/">CodeMirror</a>
    editor, which I really enjoyed working with and studying to learn about
    editors.
  </li>

</ul>
</section>
</div>


<section>
<p><a href="https://xkcd.com/312/"><img src="https://www.stevegattuso.me/2025/01/20/img/xkcd-frost.png"/></a>
</p>
</section>

<!------------------------------------------------------------------------------------>

</div></div>
  </body>
</html>
