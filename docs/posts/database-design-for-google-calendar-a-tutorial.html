<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kb.databasedesignbook.com/posts/google-calendar/">Original</a>
    <h1>Database Design for Google Calendar: A Tutorial</h1>
    
    <div id="readability-page-1" class="page"><div><p>Author: Alexey Makhotkin <a href="mailto:squadette@gmail.com">squadette@gmail.com</a>.</p>
<h2 id="introductiona-idintroductiona">Introduction<a id="introduction"></a></h2>
<p>In this database design tutorial <em>(~9000 words)</em> I’m going to show how to design the database tables for a real-world project of substantial complexity.</p>
<p>We’ll design a clone of Google Calendar.  We will model as much as possible of the functionality that is directly related to the calendar.</p>
<p>This series illustrates an approach explained in the book called “Database Design using Minimal Modeling”, scheduled to be released in Summer 2024.  Here is the website of the book: <a href="https://databasedesignbook.com/">https://databasedesignbook.com/</a>.  You can leave your email address to receive occasional updates on the book and related materials.</p>
<p>We will first build a complete logical model that describes the calendar data to be stored.  This should take most of the effort (~80% of text by word count). After the logical model is finished, we’ll build table design directly based on the logical model.</p>
<h2 id="intended-audiencea-idintended-audiencea">Intended audience<a id="intended-audience"></a></h2>
<p>The goal of the book is to help you get from a vague idea of what you need to implement (e.g.: “I need to build a website to manage schedule and instructor appointments for our gym”), to the full and complete definition of database tables.</p>
<p>The first three quarters of the text require only a general understanding of what databases are and how information is stored there.  Parts 1-6 only talk about logical models, that do not depend on the specific database that you use (MySQL, Postgres, other classic relational servers, NoSQL solutions, cloud databases, etc.).  So the majority of the text describes how the business requirements are modeled.</p>
<p>The last quarter of the text shows how to get from the logical model to physical tables structure.  This part is absolutely not comprehensive, it only shows one of many possible approaches to the database table design.  This approach, however, is perfectly valid for not very demanding systems.  Also, many existing systems are designed in part using this strategy.   This part of the text requires more familiarity with common databases: how the tables are created, what physical data types exist, what is primary key and index, how the tables would be queried, and how to insert and update data.</p>
<h2 id="table-of-contents">Table of Contents</h2>
<p><a href="#introduction">Introduction</a></p>
<p><a href="#approach-of-this-book">Approach of this book</a></p>
<p><a href="#problem-description">Problem description</a></p>
<p><a href="#part-1-basic-all-day-events">Part 1: Basic all-day events</a></p>
<ul>
<li>
<p><a href="#anchors">Anchors</a></p>
</li>
<li>
<p><a href="#attributes-of-user">Attributes of User</a></p>
</li>
<li>
<p><a href="#attributes-of-dayevent">Attributes of DayEvent</a></p>
</li>
<li>
<p><a href="#links">Links</a></p>
</li>
<li>
<p><a href="#a-peek-into-the-physical-model">A peek into the physical model</a></p>
</li>
</ul>
<p><a href="#part-2-time-based-events">Part 2: Time-based events</a></p>
<ul>
<li>
<p><a href="#time-zones">Time zones</a></p>
</li>
<li>
<p><a href="#anchors-1">Anchors</a></p>
</li>
<li>
<p><a href="#attributes-of-timezone">Attributes of Timezone</a></p>
</li>
<li>
<p><a href="#attributes-of-timeevent">Attributes of TimeEvent</a></p>
</li>
<li>
<p><a href="#links-1">Links</a></p>
</li>
<li>
<p><a href="#similarities-between-dateevent-and-timeevent">Similarities between DateEvent and TimeEvent</a></p>
</li>
</ul>
<p><a href="#part-3-repeated-all-day-events">Part 3. Repeated all-day events</a></p>
<ul>
<li>
<p><a href="#attribute-1-cadence">Attribute #1, cadence</a></p>
</li>
<li>
<p><a href="#attribute-2-tangled-attributes">Attribute #2, tangled attributes</a></p>
</li>
<li>
<p><a href="#attribute-3">Attribute #3</a></p>
</li>
<li>
<p><a href="#days-of-the-week-micro-anchors">Days of the week: micro-anchors</a></p>
</li>
<li>
<p><a href="#are-we-done">Are we done?</a></p>
</li>
<li>
<p><a href="#repeat-limit-more-tangled-attributes">Repeat limit: more tangled attributes</a></p>
</li>
</ul>
<p><a href="#part-4-rendering-the-calendar-page">Part 4. Rendering the calendar page</a></p>
<ul>
<li>
<p><a href="#a-note-on-tempo">A note on tempo</a></p>
</li>
<li>
<p><a href="#general-idea">General idea</a></p>
</li>
<li>
<p><a href="#day-slots">Day slots</a></p>
</li>
<li>
<p><a href="#exercise-timeslots">Exercise: TimeSlots</a></p>
</li>
<li>
<p><a href="#how-far-ahead-do-you-need-to-think">How far ahead do you need to think?</a></p>
</li>
</ul>
<p><a href="#part-5-rendering-the-calendar-page-time-based-events">Part 5. Rendering the calendar page: time-based events.</a></p>
<p><a href="#part-6-complete-logical-model-so-far">Part 6. Complete logical model so far</a></p>
<p><a href="#part-7-creating-sql-tables">Part 7. Creating SQL tables</a></p>
<ul>
<li>
<p><a href="#anchors-choose-names-for-tables">Anchors: choose names for tables</a></p>
</li>
<li>
<p><a href="#attributes-choose-the-column-name-and-physical-type">Attributes: choose the column name and physical type</a></p>
</li>
<li>
<p><a href="#1n-links">1:N Links</a></p>
</li>
<li>
<p><a href="#mn-links">M:N links</a></p>
</li>
</ul>
<p><a href="#finally-the-tables">Finally: the tables</a></p>
<p><a href="#conclusion">Conclusion</a></p>
<p><a href="#whats-next">What’s next?</a></p>
<h2 id="approach-of-this-booka-idapproach-of-this-booka">Approach of this book<a id="approach-of-this-book"></a></h2>
<p>Often people start with designing the tables right away, but we take a different approach.  This tutorial is aimed at people who are new to database design.  The goal of the process is to answer several important questions:</p>
<ul>
<li>
<p>Where to begin? </p>
</li>
<li>
<p>How to make sure that we did not miss anything?</p>
</li>
<li>
<p>how to ask for feedback on our database design;</p>
</li>
<li>
<p>how to fix design mistakes;</p>
</li>
</ul>
<p>We begin with a logical model, written in a simple tabular format.  We use short formalized sentences to define data attributes and relationships between entities.  This helps us to make sure that our logical model aligns with the actual business requirements.   Logical model is independent from a specific database implementation.</p>
<p>As the second step, when the logical model is decided, we design the physical tables.  This process is very straightforward.  For each element of the logical model there would be a corresponding table or column.  Physical models can be as dependent on a specific database implementation as you need.</p>
<h2 id="problem-descriptiona-idproblem-descriptiona">Problem description<a id="problem-description"></a></h2>
<p>We’re going to implement a big part of Google Calendar functionality.  Some parts we’ll skip, but we’ll try and implement every feature of calendaring.  Some areas we’ll implement just enough to be able to discuss the more interesting parts.  In the end you will be able to add missing functionality to the schema, going through the same process.</p>
<p>Google Calendar is a multi-user system.  For example, users can share the events with other people.  We’re going to implement only a bare minimum of user-related data.</p>
<p>Events are the central part of Google Calendar, and we’re going to design them as closely as possible to the real thing.  Events have title and description, as well as some other minor attributes such as location.</p>
<p>The most complex part of calendar events is times and dates:</p>
<ul>
<li>
<p>“All day” events vs time-based;</p>
</li>
<li>
<p>Both can be repeated and non-repeated;</p>
</li>
<li>
<p>All day events:</p>
<ul>
<li>Can spread over multiple days;</li>
</ul>
</li>
<li>
<p>Time-based events:</p>
<ul>
<li>
<p>Can have associated time zone;</p>
</li>
<li>
<p>Have begin and end time;</p>
</li>
<li>
<p>Begin and end time can happen on different days;</p>
</li>
<li>
<p>Begin and end time can be in different timezones;</p>
</li>
</ul>
</li>
<li>
<p>Both all-day and time based events:</p>
<ul>
<li>
<p>Can be repeated daily, or every N days;</p>
</li>
<li>
<p>Can be repeated weekly, on certain days of the week; again, it can be every two or more weeks;</p>
</li>
<li>
<p>Can be repeated monthly, on a certain day or day of the week;</p>
</li>
<li>
<p>Can be repeated annually;</p>
</li>
<li>
<p>Repeating events can go on forever, until a certain date, or for a certain number of repetitions;</p>
</li>
</ul>
</li>
</ul>
<p>For the repeating events, the specific instances can be moved to a different date/time.  You can also delete some instances of the repeating events, for example, skipping a certain weekly meeting.</p>
<p>You can change the schedule of the repeated event, even if some of the events already happeneds.  For example, you can switch from two project meetings every week on Tuesday and Thursday to one meeting every two weeks, on Fridays.</p>
<p>Here is a screenshot of a day event editing form:</p>
<p><img src="https://kb.databasedesignbook.com/posts/google-calendar-screenshot.png" alt=""/></p>
<h2 id="part-1-basic-all-day-eventsa-idpart-1-basic-all-day-eventsa">Part 1: Basic all-day events<a id="part-1-basic-all-day-events"></a></h2>
<h3 id="anchorsa-idanchorsa">Anchors<a id="anchors"></a></h3>
<p>First thing we need is to find some so-called anchors.  Anchors are also known as entities.  Anchors are usually nouns, such as <em>User</em> and <em>Event</em>.</p>
<p>Anchors are something that can be counted.  “<em>No users</em>”, “<em>one user</em>”, “<em>two users</em>”, etc.  Also, one defining characteristic of an anchor is that it can be added: “adds a user record to the database”.</p>
<p>Anchors are extremely obvious in simple cases, but may get tricky in non-obvious cases.  We’re going to write down even the most obvious anchors, to get some experience with handling them.</p>
<p>The first two anchors that come to mind are:</p>
<table>
<thead>
<tr>
<th>Anchor</th>
<th>Physical table</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>User</strong></td>
<td></td>
</tr>
<tr>
<td><strong>DayEvent</strong></td>
<td></td>
</tr>
</tbody>
</table>
<p>Basically the only thing that anchors handle is IDs and counting.  All the data is handled by attributes, discussed in the next section.</p>
<p>So, for example, in our database tables there would be a User with, say, ID=23, and DayEvent with ID=100, etc.</p>
<p>We won’t be dealing with the last column (“Physical table”) for now, we’ll discuss the physical model in the “Creating SQL Tables” section below.</p>
<p>To validate that we have an anchor, we can write a sentence using the name of this anchor.  If this sentence makes sense, then this is an anchor.  Example sentences:</p>
<ul>
<li>
<p>“<em>There are 200 Users in our database</em>”;</p>
</li>
<li>
<p>“<em>When this form is submitted, a new User is added to the database</em>”;</p>
</li>
</ul>
<p>Same for DayEvent:</p>
<ul>
<li>
<p>“<em>There are 3000 DayEvents in our database</em>”;</p>
</li>
<li>
<p>“<em>When this button is clicked, a new DayEvent is created</em>”;</p>
</li>
</ul>
<p>Such sentences will be useful later in more complicated cases.</p>
<p>If the sentence does not make sense, then it may be an attribute:</p>
<ul>
<li>
<p>“<em>There are 400 Prices in our database</em>” (???);</p>
</li>
<li>
<p>“<em>When this form is submitted, a new Price is added to the database</em>” (???).</p>
</li>
</ul>
<h3 id="attributes-of-usera-idattributes-of-usera">Attributes of User<a id="attributes-of-user"></a></h3>
<p>Attributes store the actual information about anchors.</p>
<p>Which data about users should we model?  Users are ubiquitous, and different systems may want to store a lot of information about users.  For this post, we’re going to model just the bare minimum of user data: emails.</p>
<table>
<thead>
<tr>
<th>Anchor</th>
<th>Question</th>
<th>Logical type</th>
<th>Example value</th>
<th>Physical column</th>
<th>Physical type</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>User</strong></td>
<td><strong>What is the email of this User?</strong></td>
<td><strong>string</strong></td>
<td><em>“cjdate@example.org”</em></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>What can we see here?</p>
<ul>
<li>
<p>This attribute belongs to the User <strong>anchor</strong> that was defined in the previous section;</p>
</li>
<li>
<p>We use <strong>questions</strong> to describe all sorts of attributes.  Later on we’ll discuss why we prefer this style over “User’s email” and such;</p>
</li>
<li>
<p><strong>Logical type</strong> is quite simple.  If you expected to see “<code>VARCHAR(128)</code>” here or something like that: no, we’ll discuss this much later.</p>
</li>
<li>
<p>We show <strong>an example value</strong> that helps us to confirm our thinking.  Again, in simple cases this is very obvious, but it would help reviewers to confirm that everyone is on the same page.</p>
</li>
<li>
<p>We won’t be dealing with two last columns for now, we’ll discuss <strong>the physical model</strong> later in this post.</p>
</li>
</ul>
<p>We’re going to see more examples of logical types later. We extensively discuss the logical types in the book.</p>
<p>Let’s skip ahead a little bit, and show how the table data about the users looks like.  We’ll be using a simple strategy to design physical tables, so the result is going to be completely unsurprising:</p>
<table>
<thead>
<tr>
<th>Table <code>users</code></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>email</td>
<td>…</td>
</tr>
<tr>
<td>2</td>
<td><em>“cjdate@example.org”</em></td>
<td><em>…</em></td>
</tr>
<tr>
<td>3</td>
<td><em>“someone@else.com”</em></td>
<td>…</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>This is just to show the part of the final result so that you know where we’re heading to.  Here, a user with ID=2 has email “<em>cjdate@example.org</em>”, and a user with ID=3 has email “<em>someone@else.com</em>”.</p>
<p>Except for this, we won’t be talking much about the users here.</p>
<h3 id="attributes-of-dayeventa-idattributes-of-dayeventa">Attributes of DayEvent<a id="attributes-of-dayevent"></a></h3>
<p>Suppose that we want to schedule a two-day company retreat that begins on January 14th, 2024.  In terms of anchors, this is going to be a DayEvent.</p>
<p>Looking at the paragraph above, we can see that we need to store the following data about the DayEvents:</p>
<ul>
<li>
<p>Name of the event;</p>
</li>
<li>
<p>Begin date and end date of the event.</p>
</li>
</ul>
<p>Let’s write that down in our table:</p>
<table>
<thead>
<tr>
<th>Anchor</th>
<th>Question</th>
<th>Logical type</th>
<th>Example value</th>
<th>Physical column</th>
<th>Physical type</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>DayEvent</strong></td>
<td><strong>What is the name of this DayEvent?</strong></td>
<td><strong>string</strong></td>
<td><em>“Company retreat”</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>DayEvent</strong></td>
<td><strong>When does the DayEvent begin?</strong></td>
<td><strong>date</strong></td>
<td><em>2024-01-14</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>DayEvent</strong></td>
<td><strong>When does the DayEvent end?</strong></td>
<td><strong>date</strong></td>
<td><em>2024-01-15</em></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>What can we see here?</p>
<ul>
<li>
<p>We defined our first three attributes;</p>
</li>
<li>
<p>We don’t have any short names for the attributes, and this may bother us a little.  We’d expect to have something like “<em>DayEvent_name</em>” or some other identification to refer to the attribute later in the text.  We’ll return to this topic later.</p>
</li>
<li>
<p>We have a new logical type: date. We won’t need to deal with timezones in this section.</p>
</li>
<li>
<p>For most events in actual calendars the begin date and end date would probably be the same (most events are single-day).  We’ll just store the same date in both attributes.  This allows us to treat the special case (single-day events) as the general case (multi-day events).  This is a general design strategy, but we’re going to investigate later if this line of thinking is always applicable.</p>
</li>
</ul>
<h3 id="linksa-idlinksa">Links<a id="links"></a></h3>
<p>Where do we store the information that this particular user has created this particular DayEvent?  At the first glance, this may look like an attribute of DayEvent, right?  (Actually, no).</p>
<table>
<thead>
<tr>
<th>Anchor</th>
<th>Question</th>
<th>Logical type</th>
<th>Example value</th>
<th>Physical column</th>
<th>Physical type</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>DayEvent</strong></td>
<td><strong>Which User has created this DayEvent???</strong></td>
<td><strong>number???</strong></td>
<td><em>2???</em></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Attributes cannot contain IDs.  Instead, when two anchors are involved, we need to use links.</p>
<table>
<thead>
<tr>
<th><sup>⚓</sup>Anchor<sub>1</sub></th>
<th>Sentences (subject, verb, object, cardinality)</th>
<th>Cardinality (1:N, M:N, 1:1)</th>
<th>Physical table or column</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>User &lt; DayEvent</strong></td>
<td>User creates <em>several</em> DayEvents DayEvent is created by <em>only one</em> User</td>
<td><strong>1:N</strong></td>
<td></td>
</tr>
</tbody>
</table>
<p>Links help to pin down the correct design for many complicated scenarios.  To describe the link, you need to write down two sentences.  If the sentences don’t make sense or do not match the reality of the business — you’ve just prevented a design mistake!</p>
<p>What do we see in this table?</p>
<ul>
<li>
<p>Link connects <strong>two anchors</strong>.  Anchors could be different, like here, or the same. For example, “<em>Employee is a manager of Employee</em>” is one example of one such link.</p>
</li>
<li>
<p>To specify <strong>cardinality</strong>, we use a custom notation with the “<strong>&lt;</strong>” character (other possibilities are: “<strong>—</strong>”, “<strong>=</strong>”, and “<strong>&gt;</strong>”).  It is the same as “1:N”, but additionally it allows you to specify which anchor is “<em>only one</em>” and which is “<em>several</em>”.</p>
</li>
<li>
<p>We use <strong>two formalized sentences</strong> that involve two anchors, a verb, and information about cardinality.  Those sentences allow us to validate and document our design.</p>
</li>
<li>
<p>We write down the cardinality again, in a more familiar way in a separate column.  Pinning down cardinality is essential, so we make a lot of fuss about it.</p>
</li>
</ul>
<p>(We’ll discuss the links much more, of course).</p>
<h3 id="a-peek-into-the-physical-modela-ida-peek-into-the-physical-modela">A peek into the physical model<a id="a-peek-into-the-physical-model"></a></h3>
<p>Again skipping ahead: if we would have stopped right now, and tried to write down the physical design for the schema that we have so far, here is what we’d see.  This is just to confirm that we’re heading in a familiar direction.</p>
<table>
<thead>
<tr>
<th>Table: <code>day_events</code></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>id</code></td>
<td><code>name</code></td>
<td><code>begin_date</code></td>
<td><code>end_date</code></td>
<td><code>user_id</code></td>
</tr>
<tr>
<td><em>20</em></td>
<td><em>“Company retreat”</em></td>
<td><em>2024-01-14</em></td>
<td><em>2024-01-15</em></td>
<td><em>3</em></td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>We’ll discuss the physical model later in the “Creating SQL Tables” section.</p>
<h2 id="part-2-time-based-eventsa-idpart-2-time-based-eventsa">Part 2: Time-based events<a id="part-2-time-based-events"></a></h2>
<p>In the previous section, we discussed basic non-repeating date-based events.  Let’s see how our modeling approach handles time-based events.</p>
<p>We modeled date-based events as the <em>DayEvent</em> anchor with the following attributes:</p>
<ul>
<li>
<p><em>What is the name of this DayEvent?</em>;</p>
</li>
<li>
<p><em>When does the DayEvent begin?</em></p>
</li>
<li>
<p><em>When does the DayEvent end?</em></p>
</li>
</ul>
<p>Also, we defined the link between User and DayEvent: “<em>User creates several DayEvents</em>”.</p>
<p>Let’s write down a quick draft of time-based events and see how it compares to date-based events.  Quoting the “problem description” section:</p>
<ul>
<li>
<p>“Time-based events:</p>
<ul>
<li>
<p>Can have associated time zone;</p>
</li>
<li>
<p>Have begin and end time;</p>
</li>
<li>
<p>Begin and end time can happen on different days;</p>
</li>
<li>
<p>Begin and end time can be in different timezones;”</p>
</li>
</ul>
</li>
</ul>
<h3 id="time-zonesa-idtime-zonesa">Time zones<a id="time-zones"></a></h3>
<p>Every country and territory uses one or more time zones. Time zone definitions occasionally change.  Each country, being a sovereign state, can decide to change their time zone definition.</p>
<p>Time zones may use Daylight Savings Time, or can be uniform.  New time zones may be introduced, or retired.  In this text, we won’t go into complications of handling time zone definitions.  If you were really implementing a serious global calendaring solution, you’d probably have a separate team dealing with such issues.</p>
<p>However, in this tutorial we will implement full timezone-aware events that are usable in practice.</p>
<p>We have one motivating example: <strong>plane tickets</strong>.  Planes often cross time zone boundaries, and the take-off and landing times in your ticket would be in different time zones. Say, there is a flight from Amsterdam to London that departs on December 24, at 16:50 (Amsterdam time) and lands at 17:05 (London time).  So, the flight duration is 1 hour 15 minutes.</p>
<p>Time zones inspire a lot of programming folklore.  There are many blog posts, horror stories, “things every programmer should know” and other texts related to time zones, particularly in database context.  Also, many systems keep breaking in various ways around the daylight switch time.  We will discuss only as much as needed for our purposes, and briefly mention some important things to consider.</p>
<h3 id="anchorsa-idanchors-1a">Anchors<a id="anchors-1"></a></h3>
<p>Having said that, it seems that we need to add two anchors:</p>
<table>
<thead>
<tr>
<th>Anchor</th>
<th>Physical table</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Timezone</strong></td>
<td></td>
</tr>
<tr>
<td><strong>TimeEvent</strong></td>
<td></td>
</tr>
</tbody>
</table>
<p>There are dozens of time zones in the world. We can confirm the validity of the Timezone anchor by writing down example sentences:</p>
<ul>
<li>
<p>“<em>There are 120 Timezones in our database</em>”;</p>
</li>
<li>
<p>“<em>When this import script finishes, a new Timezone is added to our database</em>”.</p>
</li>
</ul>
<p>(Timezone data structure is discussed below.)</p>
<p>The sentences for TimeEvent are also straightforward:</p>
<ul>
<li>
<p>“<em>There are 2500 TimeEvents in our database</em>”;</p>
</li>
<li>
<p>“<em>When this button is clicked, a new TimeEvent is created</em>”;</p>
</li>
</ul>
<h3 id="attributes-of-timezonea-idattributes-of-timezonea">Attributes of Timezone<a id="attributes-of-timezone"></a></h3>
<p>For the purposes of this text, we’ll do only a very minimal model of Timezone.  Basically, the only attribute we’d introduce is:</p>
<table>
<thead>
<tr>
<th>Anchor</th>
<th>Question</th>
<th>Logical type</th>
<th>Example value</th>
<th>Physical column</th>
<th>Physical type</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Timezone</strong></td>
<td><strong>What is the human-readable name of this Timezone?</strong></td>
<td><strong>string</strong></td>
<td><em>“Europe/Kyiv”</em></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>We won’t go into details of how the timezone is actually defined.  We assume that there is a complementary logical model that describes the structure of timezones.  Also, we assume that there is some function that takes a local time in the specified timezone and returns UTC time (and vice-versa).  This will be discussed in more detail in the next section, when we will talk about repeating events.</p>
<p>For clarity, here is what else would be included into a time zone definition:</p>
<ul>
<li>
<p>What is the UTC offset of this time zone?</p>
</li>
<li>
<p>Does this time zone have Daylight Savings Time?</p>
</li>
<li>
<p>When does DST begin?  When does DST end?</p>
</li>
<li>
<p>What is the UTC offset when DST is on?</p>
</li>
<li>
<p>We’d also need to model previous definitions of a time zone.  For example, the government may decide to change the day when DST goes into force, or get rid of DST, etc.</p>
</li>
<li>
<p>Is this time zone active or retired?</p>
</li>
</ul>
<p>This is an incomplete list.  Modeling all of this data using our approach is possible, but is a separate, and quite technical exercise.</p>
<p>Let’s get back to events.</p>
<h3 id="attributes-of-timeeventa-idattributes-of-timeeventa">Attributes of TimeEvent<a id="attributes-of-timeevent"></a></h3>
<table>
<thead>
<tr>
<th>Anchor</th>
<th>Question</th>
<th>Logical type</th>
<th>Example value</th>
<th>Physical column</th>
<th>Physical type</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>TimeEvent</strong></td>
<td><strong>What is the name of this TimeEvent?</strong></td>
<td><strong>string</strong></td>
<td><em>“Catch-up meeting”</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>TimeEvent</strong></td>
<td><strong>When does the TimeEvent begin?</strong></td>
<td><strong>date/time (local)</strong></td>
<td><em>2024-01-14 12:30</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>TimeEvent</strong></td>
<td><strong>When does the TimeEvent end?</strong></td>
<td><strong>date/time (local)</strong></td>
<td><em>2024-01-14 13:15</em></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Note that we’re using local time here.  You may have read that time should be stored in UTC time (without any time zones), and then formatted for human readability using a preferred time zone.</p>
<p>Here we have a different situation.  Time zones can change.  Suppose that we scheduled a billiard game on September 6, 2058, from 09:30 to 11:00, Cologne time.  At the moment we don’t know what UTC offset is going to be in that time zone at that time.  So we must store the data exactly as entered by the user, and then adjust it as the local legislation changes.</p>
<h3 id="linksa-idlinks-1a">Links<a id="links-1"></a></h3>
<p>We have two very similar links here.</p>
<table>
<thead>
<tr>
<th><sup>⚓</sup>Anchor<sub>1</sub>* <sup>⚓</sup>Anchor<sub>2</sub></th>
<th>Sentences (subject, verb, object, cardinality)</th>
<th>Cardinality (1:N, M:N, 1:1)</th>
<th>Physical table or column</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Timezone &lt; TimeEvent</strong></td>
<td>Timezone is used for the <strong>start</strong> time of <em>many</em> TimeEvents TimeEvent uses <em>only one</em> Timezone for the <strong>start</strong> time</td>
<td><strong>1:N</strong></td>
<td></td>
</tr>
<tr>
<td><strong>Timezone &lt; TimeEvent</strong></td>
<td>Timezone is used for the <strong>end</strong> time of <em>many</em> TimeEvents TimeEvent uses <em>only one</em> Timezone for the <strong>end</strong> time</td>
<td><strong>1:N</strong></td>
<td></td>
</tr>
<tr>
<td><strong>User &lt; TimeEvent</strong></td>
<td>User creates <em>several</em> TimeEvents TimeEvent is created by <em>only one</em> User</td>
<td><strong>1:N</strong></td>
<td></td>
</tr>
</tbody>
</table>
<p>The definitions of both links differ only in a single word (“start” vs “end”).</p>
<p>Most of the time-based events would have the same time zone for both start and end times.  We design this as a general case: we always specify both, even if they are the same. This approach would help us to get used to handling more complicated cases.</p>
<h3 id="similarities-between-dateevent-and-timeeventa-idsimilarities-between-dateevent-and-timeeventa">Similarities between DateEvent and TimeEvent<a id="similarities-between-dateevent-and-timeevent"></a></h3>
<p>All-day events and time-based events look similar. Does it make sense to think about unification?</p>
<p>For example, both events have names.  Also, how different are “date” and “date with time” from each other? We can also observe that both types of events would have more common data, such as “location”, list of invited guests, “description”, etc.  Maybe we could extract that to some component shared between those two anchors?</p>
<p>Thankfully, logical modeling allows us to wait a little bit before making that decision.  After all, it’s just simple tables that we can reshuffle before we commit to a physical table implementation.</p>
<p>For now, though, we want to gather more information on similarities (and, more important, dissimilarities) of two types of events that we’ve seen so far.  Also, we want to see if there would be more types of events, and what attributes and links they have.</p>
<h2 id="part-3-repeated-all-day-eventsa-idpart-3-repeated-all-day-eventsa">Part 3. Repeated all-day events<a id="part-3-repeated-all-day-events"></a></h2>
<p>As we may remember from the initial problem description:</p>
<p><em>“Both all-day and time based events:</em></p>
<ul>
<li>
<p><em>Can be repeated daily, or every N days;</em></p>
</li>
<li>
<p><em>Can be repeated weekly, on certain days of the week; again, it can be every two or more weeks;</em></p>
</li>
<li>
<p><em>Can be repeated monthly, on a certain day or day of the week;</em></p>
</li>
<li>
<p><em>Can be repeated annually;</em></p>
</li>
<li>
<p><em>Repeating events can go on either forever, or until a certain date, or for a certain number of repetitions;”</em></p>
</li>
</ul>
<p>In this section we’ll only talk about all-day events. Later we’ll see how the Minimal Modeling method handles commonalities between different anchors, in this case time-based events.  Also, we’ll see how the logical schema gets changed: we would use this as an example of how the draft design is edited when a better design approach is introduced.  Remember that all of this happens before we even start thinking about database tables, so this is a very smooth process: you don’t need to worry about table migrations yet.</p>
<p>If you think about the bullet points listed above, your reaction may be: “we probably need JSON for that”.  That may well be true, but JSON belongs to the physical table design, so we won’t discuss this at this point.  We’ll design everything that is needed on a logical level, and later on we’ll see what physical options we have.</p>
<h3 id="attribute-1-cadencea-idattribute-1-cadencea">Attribute #1, cadence<a id="attribute-1-cadence"></a></h3>
<p>So, let’s ask the first question, hoping that it would help us find an attribute: “<em>How often is that event repeated?</em>”  Looking at event editing form we can see possible answers to that question: a) never; b) daily; c) weekly; d) monthly; e) annually.</p>
<p>We say that such attributes have an “either/or/or” type.  Let’s write it down as an attribute.</p>
<table>
<thead>
<tr>
<th>Anchor</th>
<th>Question</th>
<th>Logical type</th>
<th>Example value</th>
<th>Physical column</th>
<th>Physical type</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>DayEvent</strong></td>
<td><strong>How often is that DayEvent repeated?</strong></td>
<td><strong>either/or/or</strong></td>
<td><em>daily weekly monthly annually</em></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>For either/or/or attributes, we show the entire list of possible values in the “Example value” column.</p>
<p>What do we do with never-repeating events?  On the logical level, <strong>an attribute can either be set to a specific value, or unset: this is a basic principle of minimal modeling</strong>.  So if this attribute is not set then the event would be non-repeating.</p>
<h3 id="attribute-2-tangled-attributesa-idattribute-2-tangled-attributesa">Attribute #2, tangled attributes<a id="attribute-2-tangled-attributes"></a></h3>
<p>Reading further, we see that for all four frequencies, there is an additional possibility.  The events can repeat every N days, N weeks, N months, and N years.  Let’s write that down.</p>
<table>
<thead>
<tr>
<th>Anchor</th>
<th>Question</th>
<th>Logical type</th>
<th>Example value</th>
<th>Physical column</th>
<th>Physical type</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>DayEvent</strong></td>
<td><strong>For repeated events: what is the repetition step?</strong></td>
<td><strong>integer</strong></td>
<td><em>2 (every two days/weeks/etc)</em></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>This is our first example of <strong>tangled attributes</strong>.  Its value only makes sense when another attribute is set.  We specify that by adding “<em>For repeated events:</em> ” as part of the question.</p>
<p>Note that this is only a human-readable notation, we’re not going to discuss here how to write a machine-readable logical schema.</p>
<h3 id="attribute-3a-idattribute-3a">Attribute #3<a id="attribute-3"></a></h3>
<p>When you specify a monthly event, you have two options: repeat on the same day of the month (say, every 16th of the month), or repeat on the same weekday of the month as the original date (say, every second Tuesday).  The base date is taken from the normal “When does the DayEvent begin?” attribute that was discussed in the beginning.</p>
<p>Let’s try and define this attribute:</p>
<table>
<thead>
<tr>
<th>Anchor</th>
<th>Question</th>
<th>Logical type</th>
<th>Example value</th>
<th>Physical column</th>
<th>Physical type</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>DayEvent</strong></td>
<td><strong>For monthly repeated events: which day of the month does it fall on?</strong></td>
<td><strong>either/or/or</strong></td>
<td><em>same_day</em></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="days-of-the-week-micro-anchorsa-iddays-of-the-week-micro-anchorsa">Days of the week: micro-anchors<a id="days-of-the-week-micro-anchors"></a></h3>
<p>Events can be repeated weekly, on certain days of the week.  So, for example we can have a weekly event that happens on Mondays, Wednesdays and Fridays.  Where do we store this?</p>
<p>Let’s start with an attribute that may look like this:</p>
<table>
<thead>
<tr>
<th>Anchor</th>
<th>Question</th>
<th>Logical type</th>
<th>Example value</th>
<th>Physical column</th>
<th>Physical type</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>DayEvent</strong></td>
<td><strong>For weekly repeated events: which days of the week does it fall on?</strong></td>
<td><strong>Array of strings???</strong></td>
<td><em>[“Mon”, “Wed”, “Fri”] ???</em></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Would it work? Modern database systems such as Postgres and MySQL natively support storing arrays: Postgres has an array type, also they both have JSON type, so you can store an entire array in a single table column.  Even though we discuss the logical level, this parallel can help to at least confirm the plausibility of this approach.  Also, it’s entirely possible that we’ll decide to store that information in exactly this way, when we will discuss the physical table schema.</p>
<p>However, the approach taken by Minimal Modeling demands that we introduce a new anchor called <em>DayOfTheWeek</em>.</p>
<table>
<thead>
<tr>
<th>Anchor</th>
<th>Physical table</th>
<th>ID example</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>DayOfTheWeek</strong></td>
<td></td>
<td>“Mon”, “Tue”, “Wed”, “Thu”, “Fri”, “Sat”, “Sun”</td>
</tr>
</tbody>
</table>
<p>This is an example of a well-known anchor, similar to currencies, languages and countries.  We discuss well-known anchors in <a href="https://minimalmodeling.substack.com/p/currencies-countries-and-languages">https://minimalmodeling.substack.com/p/currencies-countries-and-languages</a>.</p>
<p><em>DayOfTheWeek</em> may look a bit awkward because it is so tiny. There are only seven possible IDs here, and new ones will never be added. Also, the IDs are unusual because they are strings, and not the commonly used integer numbers. But introducing it helps keep the modeling approach simple.</p>
<p>You can also introduce attributes for this anchor, such as human-readable names of the days of the week.  This is left as an exercise for the reader.</p>
<p>Now back to our task.  We have two anchors: <em>DayEvent</em> and <em>DayOfTheWeek</em>.  To connect them, we need a link.</p>
<table>
<thead>
<tr>
<th><sup>⚓</sup>Anchor<sub>1</sub></th>
<th>Sentences (subject, verb, object, cardinality)</th>
<th>Cardinality (1:N, M:N, 1:1)</th>
<th>Physical table or column</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>DayEvent = DayOfTheWeek</strong></td>
<td>For weekly repeated DayEvents: DayEvent may happen on <em>several</em> DaysOfTheWeek DayOfTheWeek can contain <em>several</em> DayEvents</td>
<td><strong>M:N</strong></td>
<td></td>
</tr>
</tbody>
</table>
<p>This is a pretty normal link, but tangled, like the attributes we’ve seen above.  This link only makes sense when it corresponds to the DayEvent that is repeated weekly. </p>
<h3 id="are-we-donea-idare-we-donea">Are we done?<a id="are-we-done"></a></h3>
<p>How can we make sure that we’re done with modeling?  If we are not </p>
<p>Let’s revisit the original requirements again, and highlight the parts that we’ve covered so far:</p>
<p>“<em>Both</em> <strong><em>all-day</em></strong> <em>and time based events:</em></p>
<ul>
<li>
<p><em>Can be repeated</em> <strong><em>daily</em></strong><em>, or</em> <strong><em>every N</em></strong> <em>days;</em></p>
</li>
<li>
<p><em>Can be repeated</em> <strong><em>weekly</em></strong><em>, on</em> <strong><em>certain days of the week</em></strong><em>; again, it can be</em> <strong><em>every two or more weeks</em></strong><em>;</em></p>
</li>
<li>
<p><em>Can be repeated</em> <strong><em>monthly</em></strong><em>, on a</em> <strong><em>certain day</em></strong> <em>or</em> <strong><em>day of the week</em></strong><em>;</em></p>
</li>
<li>
<p><em>Can be repeated</em> <strong><em>annually</em></strong><em>;</em></p>
</li>
<li>
<p><em>Repeating events can go on forever, until a certain date, or for a certain number of repetitions;&#34;</em></p>
</li>
</ul>
<p>Okay, we can now see that we forgot about the number of event repetitions.  The corresponding part of requirements is not marked in any way. Let’s fix this.</p>
<h3 id="repeat-limit-more-tangled-attributesa-idrepeat-limit-more-tangled-attributesa">Repeat limit: more tangled attributes<a id="repeat-limit-more-tangled-attributes"></a></h3>
<p>“For how long do the periodic events repeat?” This looks like a plausible sentence to define the attribute.  There are three possible answers: “forever”, “until a certain date”, and “for a certain number of reps”.</p>
<table>
<thead>
<tr>
<th>Anchor</th>
<th>Question</th>
<th>Logical type</th>
<th>Example value</th>
<th>Physical column</th>
<th>Physical type</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>DayEvent</strong></td>
<td><strong>For repeated events: for how long does the DayEvent repeat?</strong></td>
<td><strong>either/or/or</strong></td>
<td><em>forever</em></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Now we can add two final missing pieces: which date, and how many repetitions.</p>
<table>
<thead>
<tr>
<th>Anchor</th>
<th>Question</th>
<th>Logical type</th>
<th>Example value</th>
<th>Physical column</th>
<th>Physical type</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>DayEvent</strong></td>
<td><strong>For events repeated until a certain date: what is the date?</strong></td>
<td><strong>date</strong></td>
<td><em>2024-01-17</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>DayEvent</strong></td>
<td><strong>For events repeated for a certain number of reps: how many reps?</strong></td>
<td><strong>integer</strong></td>
<td><em>10</em></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>We’re done.</p>
<p>Let’s quickly summarize the pieces of data that we defined here:</p>
<ul>
<li>
<p>anchor: <em>DayEvent</em></p>
<ul>
<li>
<p>attribute: How often is it repeated?</p>
<ul>
<li>
<p>attribute: (for monthly) Which day does it fall on?</p>
</li>
<li>
<p>link: (for weekly) falls on certain <em>DaysOfTheWeek</em>;</p>
</li>
</ul>
</li>
<li>
<p>attribute: What is the repetition step?</p>
</li>
<li>
<p>attribute: For how long is it repeated?</p>
<ul>
<li>
<p>attribute: (until a certain date) When does the repetition end?</p>
</li>
<li>
<p>attribute: (for number of reps) How many times is it repeated?</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>anchor: <em>DayOfTheWeek</em></p>
</li>
</ul>
<p>One extra anchor; six attributes, some of them tangled; one link.</p>
<h2 id="part-4-rendering-the-calendar-pagea-idpart-4-rendering-the-calendar-pagea">Part 4. Rendering the calendar page<a id="part-4-rendering-the-calendar-page"></a></h2>
<p>So far we’ve discussed the book-keeping part of the calendar. We have only one record for the entire series of events.  Ten weekly project status meetings correspond to a <em>single</em> database record.  Unlimited number of birthdays of our friend correspond to a <em>single</em> database record.</p>
<p>Let’s get back to the application that we’re working on: a calendar.  We need to show a weekly view of the user’s calendar: say, seven days starting from 26th of Feb up to 3rd of Mar.  Which events do we need to show on that page?  Say, there is one of the weekly project status meetings (out of ten) happening that week. If the birthday (annual event) falls on that week we need to show it.</p>
<p>So, we need to write some sort of SQL query that looks like this pseudo-code:</p>
<pre><code>SELECT …
FROM …
WHERE &lt;date&gt; BETWEEN ‘2024-02-26’ AND ‘2024-03-26’;
</code></pre>
<p>Maybe this would even be several SQL queries, or even some code in a programming language.  The data structure that we’ve considered so far is quite complicated.  To find the events that must be shown on a certain week, you need to take a lot into account. This may quickly become impractical.</p>
<h3 id="a-note-on-tempoa-ida-note-on-tempoa">A note on tempo<a id="a-note-on-tempo"></a></h3>
<p>I’ve been writing this chapter in the course of a few months.  I’ve been thinking about this problem a lot.  I have a quite clear understanding of the end state that I have in mind,  I just need to write it down.</p>
<p>But if I were to present to you the complete table design right now, it wouldn’t be useful for our goal: to learn database design.  You won’t understand why I made certain decisions.</p>
<p>At the same time, I don’t want to present very small incremental changes, so that text is not too long.  So we need to find some middle ground.</p>
<p>We started this section with a question of how to render a weekly page.  Let’s remember another requirement that our calendar application definitely has: <strong>changing and canceling some events from the series</strong>. Say, you have ten weekly project meetings, but you want to cancel one of them because the weather is very good. The existing book-keeping part of our database model won’t change.  But we need to add some anchors, attributes and links for the second half: rendering and modification.</p>
<h3 id="general-ideaa-idgeneral-ideaa">General idea<a id="general-idea"></a></h3>
<p>We want to introduce a new anchor that would store the information about <em>each event in the series</em>.  So, if we have 10 weekly project status meetings, we’re going to have ten rows in some table.  Each record would correspond to a specific date (e.g., <em>2024-02-12</em>, <em>2024-02-19</em>, etc.).</p>
<p>First, this would make our rendering very simple.  You have a very easy way to find all the events that fall on a specific day.</p>
<p>Second, this would allow us to reschedule and cancel some events in the series.  If we have a project meeting at 12:00 normally, but on a certain week we want to move it to 14:00 (or even to a different day), we can do that. Data in the original book-keeping anchor, TimeEvent, that we defined previously, won’t change.</p>
<p>Also, if we just want to skip one project status meeting, we can mark this particular day as skipped.</p>
<h3 id="day-slotsa-idday-slotsa">Day slots<a id="day-slots"></a></h3>
<p>First, we have to find a name for those things.  In some cases this may be a challenge.  Just five minutes ago, having another cup of tea, I realized that a good word for this thing is “slot”.</p>
<p>Also, like before, we’re going to treat per-day and time-based events differently.  So, we’re going to have <em>DaySlot</em> and <em>TimeSlot</em> anchors.  Let’s discuss per-day slots first.</p>
<table>
<thead>
<tr>
<th>Anchor</th>
<th>Physical table</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>DaySlot</strong></td>
<td></td>
</tr>
</tbody>
</table>
<p><em>DaySlot</em> needs a surprisingly small number of attributes:</p>
<table>
<thead>
<tr>
<th>Anchor</th>
<th>Question</th>
<th>Logical type</th>
<th>Example value</th>
<th>Physical column</th>
<th>Physical type</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>DaySlot</strong></td>
<td><strong>On which day does this DaySlot happen?</strong></td>
<td><strong>date</strong></td>
<td><em>2024-02-12</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>DaySlot</strong></td>
<td><strong>Is this DaySlot skipped?</strong></td>
<td><strong>yes/no</strong></td>
<td><em>yes</em></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Note that the user can change the date for a specific slot!  So, we see that this requirement is handled cleanly.</p>
<p>Also, we need to establish a link between DaySlot and the corresponding DayEvent.</p>
<table>
<thead>
<tr>
<th><sup>⚓</sup>Anchor<sub>1</sub></th>
<th>Sentences (subject, verb, object, cardinality)</th>
<th>Cardinality (1:N, M:N, 1:1)</th>
<th>Physical table or column</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>DayEvent &lt; DaySlot</strong></td>
<td>DayEvent may generate <em>several</em> DaySlots DaySlot corresponds to <em>only one</em> DayEvent</td>
<td><strong>1:N</strong></td>
<td></td>
</tr>
</tbody>
</table>
<p>Some things to note: first, <strong>we always create a DaySlot for every DayEvent, even for non-repeating ones</strong>.  This is needed to simplify the rendering code.</p>
<p>Second, we have an interesting <strong>problem with “infinite” events</strong>.  Suppose that we added our friend’s birthday to the calendar, repeating annually.  How many corresponding DaySlots do we need to create?  One possible solution would be to choose some arbitrary limit such as 100 years in the future, and create all the slots for that.  Other solutions are possible, such as on-demand creation when user requests to show a calendar page in some distant future.</p>
<p>Third, if you think about this, it’s possible that more information could also be <strong>different for each slot</strong>.  For example, it’s possible that some meetings will take place in different locations.  Also, the guest list may change: you can invite extra people to a certain meeting.  Also, the attendance would certainly be different.  We won’t cover those aspects here, because modeling this it’s pretty straightforward: just add more links that connect DaySlot with other anchors.</p>
<p>Also, one thing to consider is that <strong>date arithmetics needs a bit of care</strong>.  How do we deal with birthdays of people who were born on February 29?  We will have to decide something.  Maybe we’ll prohibit the user from creating such events?  Maybe we’ll ask them where to move the slot: day earlier or day later?  Similar problem also exists for monthly events that happen on the 31st day of the month.</p>
<h3 id="exercise-timeslotsa-idexercise-timeslotsa">Exercise: TimeSlots<a id="exercise-timeslots"></a></h3>
<p>Here is an exercise for the determined reader.  Think about how you would model the <em>TimeSlot</em> anchor, its attributes and links.  Fill in the tables with anchors, links and attributes, using the format explained above.  Think about what role would time zones play.</p>
<h3 id="how-far-ahead-do-you-need-to-thinka-idhow-far-ahead-do-you-need-to-thinka">How far ahead do you need to think?<a id="how-far-ahead-do-you-need-to-think"></a></h3>
<p>Sometimes you can create a better design if you consider a slightly broader set of requirements.  We did it in this chapter: we started thinking about rendering the page, but then we also considered the need to modify some events in the series.</p>
<p>Sometimes you can create a better design if you consider requirements independently.  In the previous chapters, we looked at time-based and per-day events, and decided to handle them separately for now.</p>
<p>So far we did not even mention any hypothetical future requirements.  We’ve only been designing stuff that we know is needed.  Can we think up something that would be nice to have in the future, and design ahead? If you only include known requirements, there is a chance of overfitting design for known data points.</p>
<p>At the same time, people sometimes introduce considerations that never actually materialize.  In this case design may introduce extra complexity that is not needed for the actual requirements, adding a bit of friction.</p>
<p>There is always a chance of leaning towards one of those traps, or even falling into them.</p>
<p>Logical design based on Minimal Modeling insists on modeling only the parts that we actually know are needed.  We can afford that because Minimal Modeling treats changing requirements as a given.  Also, Minimal Modeling discourages you from adding more abstract concepts, and this is intentional.</p>
<p>We’ll discuss this aspect of physical design later in the book. We’ll introduce the concept of Game of Tables, and the idea of Date’s Demon.</p>
<h2 id="part-5-rendering-the-calendar-page-time-based-eventsa-idpart-5-rendering-the-calendar-page-time-based-eventsa">Part 5. Rendering the calendar page: time-based events.<a id="part-5-rendering-the-calendar-page-time-based-events"></a></h2>
<p>For repeated time-based events, we choose the same approach as with all-day events.  We’re going to introduce an anchor called “<em>TimeSlot</em>”.  <em>TimeSlot</em> corresponds to a specific event on a specific date and time.  A repeated event corresponds to several <em>TimeSlots</em>.</p>
<p>Time slots can be rescheduled or canceled manually, just like all-day slots.</p>
<p>Here is an anchor:</p>
<table>
<thead>
<tr>
<th>Anchor</th>
<th>Physical table</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>TimeSlot</strong></td>
<td></td>
</tr>
</tbody>
</table>
<p>And the attributes:</p>
<table>
<thead>
<tr>
<th>Anchor</th>
<th>Question</th>
<th>Logical type</th>
<th>Example value</th>
<th>Physical column</th>
<th>Physical type</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>TimeSlot</strong></td>
<td><strong>When does the TimeSlot begin?</strong></td>
<td><strong>date/time (local)</strong></td>
<td><em>2024-01-14 12:30</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>TimeSlot</strong></td>
<td><strong>When does the TimeSlot end?</strong></td>
<td><strong>date/time (local)</strong></td>
<td><em>2024-01-14 13:15</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>TimeSlot</strong></td>
<td><strong>Is this TimeSlot skipped?</strong></td>
<td><strong>yes/no</strong></td>
<td><em>yes</em></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>A specific time slot can generally be moved even to a different day, so we have to keep this information also.  Which time zone shall we use for the begin/end time?  As you may remember from Part 2, in Google Calendar you can have different time zones for begin and end time.  If you think about that, it makes sense to keep it for the time slots also.</p>
<table>
<thead>
<tr>
<th><sup>⚓</sup>Anchor<sub>1</sub></th>
<th>Sentences (subject, verb, object, cardinality)</th>
<th>Cardinality (1:N, M:N, 1:1)</th>
<th>Physical table or column</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Timezone &lt; TimeSlot</strong></td>
<td>Timezone is used for the <strong>start</strong> time of <em>many</em> TimeSlots TimeSlot uses <em>only one</em> Timezone for the <strong>start</strong> time</td>
<td><strong>1:N</strong></td>
<td></td>
</tr>
<tr>
<td><strong>Timezone &lt; TimeSlot</strong></td>
<td>Timezone is used for the <strong>end</strong> time of <em>many</em> TimeEvents TimeSlot uses <em>only one</em> Timezone for the <strong>end</strong> time</td>
<td><strong>1:N</strong></td>
<td></td>
</tr>
</tbody>
</table>
<p>Also, we need to connect TimeSlots with TimeEvents, same as we did with DaySlots/DayEvents:</p>
<table>
<thead>
<tr>
<th><sup>⚓</sup>Anchor<sub>1</sub></th>
<th>Sentences (subject, verb, object, cardinality)</th>
<th>Cardinality (1:N, M:N, 1:1)</th>
<th>Physical table or column</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>TimeEvent &lt; TimeSlot</strong></td>
<td>TimeEvent may generate <em>several</em> TimeSlots TimeSlot corresponds to <em>only one</em> TimeEvent</td>
<td><strong>1:N</strong></td>
<td></td>
</tr>
</tbody>
</table>
<p>Same as with <em>DaySlot</em>, we would create a <em>TimeSlot</em> even for non-repeated TimeEvents.</p>
<h2 id="part-6-complete-logical-model-so-fara-idpart-6-complete-logical-model-so-fara">Part 6. Complete logical model so far<a id="part-6-complete-logical-model-so-far"></a></h2>
<p>Let’s go back and collect everything that we’ve designed so far.</p>
<p>First, the complete list of anchors (7 in total):</p>
<table>
<thead>
<tr>
<th>Anchor</th>
<th>Physical table</th>
<th>ID example</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>User</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Timezone</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>DayEvent</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>TimeEvent</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>DayOfTheWeek</strong></td>
<td></td>
<td>“Mon”, “Tue”, “Wed”, “Thu”, “Fri”, “Sat”, “Sun”</td>
</tr>
<tr>
<td><strong>DaySlot</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>TimeSlot</strong></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Second, list of attributes (ordered by anchor):</p>
<table>
<thead>
<tr>
<th>Anchor</th>
<th>Question</th>
<th>Logical type</th>
<th>Example value</th>
<th>Physical column</th>
<th>Physical type</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>User</strong></td>
<td><strong>What is the email of this User?</strong></td>
<td><strong>string</strong></td>
<td><em>“cjdate@example.org”</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Timezone</strong></td>
<td><strong>What is the human-readable name of this Timezone?</strong></td>
<td><strong>string</strong></td>
<td><em>“Europe/Kyiv”</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>DayEvent</strong></td>
<td><strong>What is the name of this DayEvent?</strong></td>
<td><strong>string</strong></td>
<td><em>“Company retreat”</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>DayEvent</strong></td>
<td><strong>When does the DayEvent begin?</strong></td>
<td><strong>date</strong></td>
<td><em>2024-01-14</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>DayEvent</strong></td>
<td><strong>When does the DayEvent end?</strong></td>
<td><strong>date</strong></td>
<td><em>2024-01-15</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>DayEvent</strong></td>
<td><strong>How often is that DayEvent repeated?</strong></td>
<td><strong>either/or/or</strong></td>
<td><em>daily weekly monthly annually</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>DayEvent</strong></td>
<td><strong>For repeated events: what is the repetition step?</strong></td>
<td><strong>integer</strong></td>
<td><em>2 (every two days/weeks/etc)</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>DayEvent</strong></td>
<td><strong>For monthly repeated events: which day of the month does it fall on?</strong></td>
<td><strong>either/or/or</strong></td>
<td><em>same_day</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>DayEvent</strong></td>
<td><strong>For repeated events: for how long does the DayEvent repeat?</strong></td>
<td><strong>either/or/or</strong></td>
<td><em>forever</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>DayEvent</strong></td>
<td><strong>For events repeated until a certain date: what is the date?</strong></td>
<td><strong>date</strong></td>
<td><em>2024-01-17</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>DayEvent</strong></td>
<td><strong>For events repeated for a certain number of reps: how many reps?</strong></td>
<td><strong>integer</strong></td>
<td><em>10</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>TimeEvent</strong></td>
<td><strong>What is the name of this TimeEvent?</strong></td>
<td><strong>string</strong></td>
<td><em>“Catch-up meeting”</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>TimeEvent</strong></td>
<td><strong>When does the TimeEvent begin?</strong></td>
<td><strong>date/time (local)</strong></td>
<td><em>2024-01-14 12:30</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>TimeEvent</strong></td>
<td><strong>When does the TimeEvent end?</strong></td>
<td><strong>date/time (local)</strong></td>
<td><em>2024-01-14 13:15</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>DaySlot</strong></td>
<td><strong>On which day does this DaySlot happen?</strong></td>
<td><strong>date</strong></td>
<td><em>2024-02-12</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>DaySlot</strong></td>
<td><strong>Is this DaySlot skipped?</strong></td>
<td><strong>yes/no</strong></td>
<td><em>yes</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>TimeSlot</strong></td>
<td><strong>When does the TimeSlot begin?</strong></td>
<td><strong>date/time (local)</strong></td>
<td><em>2024-01-14 12:30</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>TimeSlot</strong></td>
<td><strong>When does the TimeSlot end?</strong></td>
<td><strong>date/time (local)</strong></td>
<td><em>2024-01-14 13:15</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>TimeSlot</strong></td>
<td><strong>Is this TimeSlot skipped?</strong></td>
<td><strong>yes/no</strong></td>
<td><em>no</em></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Third, list of links (in no particular order):</p>
<table>
<thead>
<tr>
<th><sup>⚓</sup>Anchor<sub>1</sub></th>
<th>Sentences (subject, verb, object, cardinality)</th>
<th>Cardinality (1:N, M:N, 1:1)</th>
<th>Physical table or column</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>User &lt; DayEvent</strong></td>
<td>User creates <em>many</em> DayEvents DayEvent is created by <em>only one</em> User</td>
<td><strong>1:N</strong></td>
<td></td>
</tr>
<tr>
<td><strong>User &lt; TimeEvent</strong></td>
<td>User creates <em>many</em> TimeEvents TimeEvent is created by <em>only one</em> User</td>
<td><strong>1:N</strong></td>
<td></td>
</tr>
<tr>
<td><strong>Timezone &lt; TimeEvent</strong></td>
<td>Timezone is used for the start time of <em>many</em> TimeEvents TimeEvent uses <em>only one</em> Timezone for the start time</td>
<td><strong>1:N</strong></td>
<td></td>
</tr>
<tr>
<td><strong>Timezone &lt; TimeEvent</strong></td>
<td>Timezone is used for the end time of <em>many</em> TimeEvents TimeEvent uses <em>only one</em> Timezone for the end time</td>
<td><strong>1:N</strong></td>
<td></td>
</tr>
<tr>
<td><strong>DayEvent = DayOfTheWeek</strong></td>
<td>For weekly repeated DayEvents: DayEvent may happen on <em>several</em> DaysOfTheWeek DayOfTheWeek can contain <em>several</em> DayEvents</td>
<td><strong>M:N</strong></td>
<td></td>
</tr>
<tr>
<td><strong>TimeEvent = DayOfTheWeek</strong></td>
<td>For weekly repeated TimeEvents: TimeEvent may happen on <em>several</em> DaysOfTheWeek DayOfTheWeek can contain <em>several</em> TimeEvents</td>
<td><strong>M:N</strong></td>
<td></td>
</tr>
<tr>
<td><strong>DayEvent &lt; DaySlot</strong></td>
<td>DayEvent may generate <em>several</em> DaySlots DaySlot corresponds to <em>only one</em> DayEvent</td>
<td><strong>1:N</strong></td>
<td></td>
</tr>
<tr>
<td><strong>TimeEvent &lt; TimeSlot</strong></td>
<td>TimeEvent may generate <em>several</em> TimeSlots TimeSlot corresponds to <em>only one</em> TimeEvent</td>
<td><strong>1:N</strong></td>
<td></td>
</tr>
<tr>
<td><strong>Timezone &lt; TimeSlot</strong></td>
<td>Timezone is used for the start time of <em>many</em> TimeSlots TimeSlot uses <em>only one</em> Timezone for the start time</td>
<td><strong>1:N</strong></td>
<td></td>
</tr>
<tr>
<td><strong>Timezone &lt; TimeSlot</strong></td>
<td>Timezone is used for the end time of <em>many</em> TimeEvents TimeSlot uses <em>only one</em> Timezone for the end time</td>
<td><strong>1:N</strong></td>
<td></td>
</tr>
</tbody>
</table>
<p>Finally, here is a diagram that shows all anchors and links (but not attributes):</p>
<p><img src="https://kb.databasedesignbook.com/posts/google-calendar-diagram.png" alt=""/></p>
<h2 id="part-7-creating-sql-tablesa-idpart-7-creating-sql-tablesa">Part 7. Creating SQL tables<a id="part-7-creating-sql-tables"></a></h2>
<p>In the previous chapters we defined the complete logical model, so most of the work is actually already done. The rest is pretty straightforward.</p>
<p>For teaching purposes we’re going to use one specific table design strategy: “one table per anchor”.  It is one of the most common approaches to physical table design. There are several more possible strategies, we’re going to discuss them in a book.</p>
<p>We have 7 anchors, 21 attributes and 10 links so far.  Given that we use “one table per anchor” strategy, we’re going to have 7 + 2 = 9 tables (number of anchors + number of M:N links), and 21 + 8 = 29 columns in total (number of attributes + number of 1:N links).</p>
<p>If our logical design correctly describes the business requirements then the tables will be automatically correct.  We’ll talk about evolving requirements in the book.  Also, we’ll discuss design mistakes and how to fix them.</p>
<p>We’re going to revisit the tables from the previous section, and fill in our choices:</p>
<ul>
<li>
<p>For anchors, fill in “Physical table” columns;</p>
</li>
<li>
<p>For each attribute, fill in “Physical column”, and choose the “Physical type”;</p>
</li>
<li>
<p>For each M:N link, choose the name of the physical table;</p>
</li>
<li>
<p>For each 1:N link, fill in the column name in the table that corresponds to the N-side anchor;</p>
</li>
</ul>
<h3 id="anchors-choose-names-for-tablesa-idanchors-choose-names-for-tablesa">Anchors: choose names for tables<a id="anchors-choose-names-for-tables"></a></h3>
<p>Here we just choose a straightforward plural name for each table.</p>
<table>
<thead>
<tr>
<th>Anchor</th>
<th>Physical table</th>
<th>ID example</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>User</strong></td>
<td><code>users</code></td>
<td></td>
</tr>
<tr>
<td><strong>Timezone</strong></td>
<td><code>timezones</code></td>
<td></td>
</tr>
<tr>
<td><strong>DayEvent</strong></td>
<td><code>day_events</code></td>
<td></td>
</tr>
<tr>
<td><strong>TimeEvent</strong></td>
<td><code>time_events</code></td>
<td></td>
</tr>
<tr>
<td><strong>DayOfTheWeek</strong></td>
<td><code>days_of_the_week</code> NB: <em>this table may be virtual, see below</em></td>
<td>“Mon”, “Tue”, “Wed”, “Thu”, “Fri”, “Sat”, “Sun”</td>
</tr>
<tr>
<td><strong>DaySlot</strong></td>
<td><code>day_slots</code></td>
<td></td>
</tr>
<tr>
<td><strong>TimeSlot</strong></td>
<td><code>time_slots</code></td>
<td></td>
</tr>
</tbody>
</table>
<p>Some companies or applications enforce different naming conventions (singular, camel case, etc.).  In that case, you would just use the names that comply with the convention.</p>
<h3 id="attributes-choose-the-column-name-and-physical-typea-idattributes-choose-the-column-name-and-physical-typea">Attributes: choose the column name and physical type<a id="attributes-choose-the-column-name-and-physical-type"></a></h3>
<p>For the <strong>physical column name</strong>, we choose some sensible name.  For example:</p>
<ul>
<li>
<p><code>day_events.end_date</code> would be the column name for the “When does the DayEvent begin?” attribute;</p>
</li>
<li>
<p>​​<code>time_slots.is_skipped </code>would be the column name for the “Is this TimeSlot skipped?” attribute</p>
</li>
</ul>
<p>And so on.  Due to the way relational databases work, you have to choose a very short name.  In many cases this name by itself is not enough to fully explain the meaning of the data.  That’s one of the reasons why we begin with the logical schema, and use longer human-readable questions to define the semantics of the attributes.</p>
<p>For the <strong>physical type</strong>, we choose a sensible type without much discussion.  This topic is covered extensively in the book. There is also a list of recommended data types for each logical type in the book, and we just use that directly.</p>
<p>If you’re working with an existing system, you may be required to choose an alternative physical data type for the column.  For example, your database server may support a better suited data type; or there could be some engineering guidelines that make you choose a different data type.</p>
<p>We’re going to discuss this variance in the book.  However, full discussion of all physical design concerns is well outside of the scope of <em>any</em> book.  This is the stuff that you spend your career on learning, and it changes as new technologies emerge.</p>
<table>
<thead>
<tr>
<th>Anchor</th>
<th>Question</th>
<th>Logical type</th>
<th>Example value</th>
<th>Physical column</th>
<th>Physical type</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>User</strong></td>
<td><strong>What is the email of this User?</strong></td>
<td><strong>string</strong></td>
<td><em>“cjdate@example.org”</em></td>
<td><code>users.email</code></td>
<td><code>VARCHAR(64) NOT NULL</code></td>
</tr>
<tr>
<td><strong>Timezone</strong></td>
<td><strong>What is the human-readable name of this Timezone?</strong></td>
<td><strong>string</strong></td>
<td><em>“Europe/Kyiv”</em></td>
<td><code>timezones.name</code></td>
<td><code>VARCHAR(64) NOT NULL</code></td>
</tr>
<tr>
<td><strong>DayEvent</strong></td>
<td><strong>What is the name of this DayEvent?</strong></td>
<td><strong>string</strong></td>
<td><em>“Company retreat”</em></td>
<td><code>day_events.name</code></td>
<td><code>VARCHAR(128) NOT NULL</code></td>
</tr>
<tr>
<td><strong>DayEvent</strong></td>
<td><strong>When does the DayEvent begin?</strong></td>
<td><strong>date</strong></td>
<td><em>2024-01-14</em></td>
<td><code>day_events.begin_date</code></td>
<td><code>DATE NOT NULL</code></td>
</tr>
<tr>
<td><strong>DayEvent</strong></td>
<td><strong>When does the DayEvent end?</strong></td>
<td><strong>date</strong></td>
<td><em>2024-01-15</em></td>
<td><code>day_events.end_date</code></td>
<td><code>DATE NOT NULL</code></td>
</tr>
<tr>
<td><strong>DayEvent</strong></td>
<td><strong>How often is that DayEvent repeated?</strong></td>
<td><strong>either/or/or</strong></td>
<td><em>daily weekly monthly annually</em></td>
<td><code>day_events.repeated</code></td>
<td><code>VARCHAR(24) NULL</code></td>
</tr>
<tr>
<td><strong>DayEvent</strong></td>
<td><strong>For repeated events: what is the repetition step?</strong></td>
<td><strong>integer</strong></td>
<td><em>2 (every two days/weeks/etc)</em></td>
<td><code>day_events.repetition_step</code></td>
<td><code>INTEGER NULL</code></td>
</tr>
<tr>
<td><strong>DayEvent</strong></td>
<td><strong>For monthly repeated events: which day of the month does it fall on?</strong></td>
<td><strong>either/or/or</strong></td>
<td><em>same_day</em></td>
<td><code>day_events.repeated_monthly_on</code></td>
<td><code>VARCHAR(24) NULL</code></td>
</tr>
<tr>
<td><strong>DayEvent</strong></td>
<td><strong>For repeated events: for how long does the DayEvent repeat?</strong></td>
<td><strong>either/or/or</strong></td>
<td><em>forever</em></td>
<td><code>day_events.repeated_until</code></td>
<td><code>VARCHAR(24) NULL</code></td>
</tr>
<tr>
<td><strong>DayEvent</strong></td>
<td><strong>For events repeated until a certain date: what is the date?</strong></td>
<td><strong>date</strong></td>
<td><em>2024-01-17</em></td>
<td><code>day_events.repeated_until_date</code></td>
<td><code>DATE NULL</code></td>
</tr>
<tr>
<td><strong>DayEvent</strong></td>
<td><strong>For events repeated for a certain number of reps: how many reps?</strong></td>
<td><strong>integer</strong></td>
<td><em>10</em></td>
<td><code>day_events.repeated_reps</code></td>
<td><code>INTEGER NULL</code></td>
</tr>
<tr>
<td><strong>TimeEvent</strong></td>
<td><strong>What is the name of this TimeEvent?</strong></td>
<td><strong>string</strong></td>
<td><em>“Catch-up meeting”</em></td>
<td><code>time_events.name</code></td>
<td><code>VARCHAR(128) NOT NULL</code></td>
</tr>
<tr>
<td><strong>TimeEvent</strong></td>
<td><strong>When does the TimeEvent begin?</strong></td>
<td><strong>date/time (local)</strong></td>
<td><em>2024-01-14 12:30</em></td>
<td><code>time_events.begin_local_time</code></td>
<td><code>DATETIME NOT NULL</code></td>
</tr>
<tr>
<td><strong>TimeEvent</strong></td>
<td><strong>When does the TimeEvent end?</strong></td>
<td><strong>date/time (local)</strong></td>
<td><em>2024-01-14 13:15</em></td>
<td><code>time_events.end_local_time</code></td>
<td><code>DATETIME NOT NULL</code></td>
</tr>
<tr>
<td><strong>DaySlot</strong></td>
<td><strong>On which day does this DaySlot happen?</strong></td>
<td><strong>date</strong></td>
<td><em>2024-02-12</em></td>
<td><code>day_slots.the_date</code></td>
<td><code>DATE NOT NULL</code></td>
</tr>
<tr>
<td><strong>DaySlot</strong></td>
<td><strong>Is this DaySlot skipped?</strong></td>
<td><strong>yes/no</strong></td>
<td><em>yes</em></td>
<td><code>day_slots.is_skipped</code></td>
<td><code>TINYINT UNSIGNED NOT NULL DEFAULT 0</code></td>
</tr>
<tr>
<td><strong>TimeSlot</strong></td>
<td><strong>When does the TimeSlot begin, in local time?</strong></td>
<td><strong>date/time (local)</strong></td>
<td><em>2024-01-14 12:30</em></td>
<td><code>time_slots.begin_local_time</code></td>
<td><code>DATETIME NOT NULL</code></td>
</tr>
<tr>
<td><strong>TimeSlot</strong></td>
<td><strong>When does the TimeSlot end, in local time?</strong></td>
<td><strong>date/time (local)</strong></td>
<td><em>2024-01-14 13:15</em></td>
<td><code>time_slots.end_local_time</code></td>
<td><code>DATETIME NOT NULL</code></td>
</tr>
<tr>
<td><strong>TimeSlot</strong></td>
<td><strong>Is this TimeSlot skipped?</strong></td>
<td><strong>yes/no</strong></td>
<td><em>yes</em></td>
<td><code>time_slots.is_skipped</code></td>
<td><code>TINYINT UNSIGNED NOT NULL DEFAULT 0</code></td>
</tr>
</tbody>
</table>
<p>For this problem, we’ve used around half of logical attribute types:</p>
<ul>
<li>
<p>string: 4 attributes;</p>
</li>
<li>
<p>date: 4 attributes;</p>
</li>
<li>
<p>either/or/or: 3 attributes;</p>
</li>
<li>
<p>integer: 2 attributes;</p>
</li>
<li>
<p>date/time (local): 4 attributes;</p>
</li>
<li>
<p>yes/no: 2 attributes.</p>
</li>
</ul>
<p>You can see that the physical definitions of attributes of the same logical type are almost the same.  The only differences are: a) maximum length of strings; and b) <code>NULL</code> vs <code>NOT NULL</code>.</p>
<p>We choose “<code>NOT NULL</code>” for attributes where the value always needs to be there due to business requirements.  For example, the name of the event, or the start date of the all-day event.  For tangled attributes, we choose nullable physical types (“<code>NULL</code>”).  We discuss nullability in the book, but note that “NULL” only exists in the physical schema.</p>
<p>Just as NULLs, so-called “sentinel values” also do not exist in logical modeling.</p>
<h3 id="1n-linksa-id1n-linksa">1:N Links<a id="1n-links"></a></h3>
<p>For 1:N links, we add a column to the N-side anchor table.  For example:</p>
<table>
<thead>
<tr>
<th><sup>⚓</sup>Anchor<sub>1</sub></th>
<th>Sentences (subject, verb, object, cardinality)</th>
<th>Cardinality (1:N, M:N, 1:1)</th>
<th>Physical table or column</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>User &lt; DayEvent</strong></td>
<td>User creates <em>many</em> DayEvents DayEvent is created by <em>only one</em> User</td>
<td><strong>1:N</strong></td>
<td><code>day_events.user_id</code></td>
</tr>
<tr>
<td><strong>DayEvent &lt; DaySlot</strong></td>
<td>DayEvent may generate <em>several</em> DaySlots DaySlot corresponds to <em>only one</em> DayEvent</td>
<td><strong>1:N</strong></td>
<td><code>day_slots.day_event_id</code></td>
</tr>
</tbody>
</table>
<p>Choosing the column name is usually quite easy.  The only complication could be when there are two and more different links between the same two anchors.  We have that situation with the timezones, and we’ll use two different columns.</p>
<h3 id="mn-linksa-idmn-linksa">M:N links<a id="mn-links"></a></h3>
<p>For M:N links we must use a separate table for each link.  Every such table will have almost identical structure, only the column names would be different.</p>
<p>We only need to find a good name for such a table.  There is no naming method that works in all cases, you will have to try some combinations, looking for readability.  For links this is especially difficult because it’s not clear which of the two anchors is more important and should come first.</p>
<p>Same as with attributes, due to the way relational databases work, the name of the table needs to be quite short.  In many cases the name by itself is not enough to fully explain the meaning of the data.  That’s one of the reasons why we prepare logical schema, and use human-readable sentences to define the semantics of the links.</p>
<p>Anyway, here is the full table of links with the names chosen for the tables and columns (see the last column).</p>
<table>
<thead>
<tr>
<th><sup>⚓</sup>Anchor<sub>1</sub></th>
<th>Sentences (subject, verb, object, cardinality)</th>
<th>Cardinality (1:N, M:N, 1:1)</th>
<th>Physical table or column</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>User &lt; DayEvent</strong></td>
<td>User creates <em>many</em> DayEvents DayEvent is created by <em>only one</em> User</td>
<td><strong>1:N</strong></td>
<td><code>day_events.user_id</code></td>
</tr>
<tr>
<td><strong>User &lt; TimeEvent</strong></td>
<td>User creates <em>many</em> TimeEvents TimeEvent is created by <em>only one</em> User</td>
<td><strong>1:N</strong></td>
<td><code>time_events.user_id</code></td>
</tr>
<tr>
<td><strong>Timezone &lt; TimeEvent</strong></td>
<td>Timezone is used for the start time of <em>many</em> TimeEvents TimeEvent uses <em>only one</em> Timezone for the start time</td>
<td><strong>1:N</strong></td>
<td><code>time_events.start_timezone_id</code></td>
</tr>
<tr>
<td><strong>Timezone &lt; TimeEvent</strong></td>
<td>Timezone is used for the end time of <em>many</em> TimeEvents TimeEvent uses <em>only one</em> Timezone for the end time</td>
<td><strong>1:N</strong></td>
<td><code>time_events.end_timezone_id</code></td>
</tr>
<tr>
<td><strong>DayEvent = DayOfTheWeek</strong></td>
<td>For weekly repeated DayEvents: DayEvent may happen on <em>several</em> DaysOfTheWeek DayOfTheWeek can contain <em>several</em> DayEvents</td>
<td><strong>M:N</strong></td>
<td><code>day_event_dows</code></td>
</tr>
<tr>
<td><strong>TimeEvent = DayOfTheWeek</strong></td>
<td>For weekly repeated TimeEvents: TimeEvent may happen on <em>several</em> DaysOfTheWeek DayOfTheWeek can contain <em>several</em> TimeEvents</td>
<td><strong>M:N</strong></td>
<td><code>time_event_dows</code></td>
</tr>
<tr>
<td><strong>DayEvent &lt; DaySlot</strong></td>
<td>DayEvent may generate <em>several</em> DaySlots DaySlot corresponds to <em>only one</em> DayEvent</td>
<td><strong>1:N</strong></td>
<td><code>day_slots.day_event_id</code></td>
</tr>
<tr>
<td><strong>TimeEvent &lt; TimeSlot</strong></td>
<td>TimeEvent may generate <em>several</em> TimeSlots TimeSlot corresponds to <em>only one</em> TimeEvent</td>
<td><strong>1:N</strong></td>
<td><code>time_slots.time_event_id</code></td>
</tr>
<tr>
<td><strong>Timezone &lt; TimeSlot</strong></td>
<td>Timezone is used for the start time of <em>many</em> TimeSlots TimeSlot uses <em>only one</em> Timezone for the start time</td>
<td><strong>1:N</strong></td>
<td><code>time_slots.start_timezone_id</code></td>
</tr>
<tr>
<td><strong>Timezone &lt; TimeSlot</strong></td>
<td>Timezone is used for the end time of <em>many</em> TimeEvents TimeSlot uses <em>only one</em> Timezone for the end time</td>
<td><strong>1:N</strong></td>
<td><code>time_slots.end_timezone_id</code></td>
</tr>
</tbody>
</table>
<h3 id="finally-the-tablesa-idfinally-the-tablesa">Finally: the tables<a id="finally-the-tables"></a></h3>
<p>As we mentioned in the previous section, we’re going to have 8 (eight) SQL tables: 6 for anchors and 2 for M:N links.  One anchor (<em>DayOfTheWeek</em>) is special, so we don’t create a physical table for that.  We use a very common approach to designing physical tables.  Other approaches are also possible, but this discussion is outside the scope of this post.  So, let’s just write down all the tables, and add all the attributes that we have.</p>
<p>This is a very straightforward and even boring process at this point.</p>
<pre><code>CREATE TABLE users (
  id INTEGER NOT NULL PRIMARY KEY AUTO_INCREMENT,
  email VARCHAR(64) NOT NULL
);

CREATE TABLE timezones (
  id INTEGER NOT NULL PRIMARY KEY AUTO_INCREMENT,
  name VARCHAR(64) NOT NULL
);

CREATE TABLE day_events (
  id INTEGER NOT NULL PRIMARY KEY AUTO_INCREMENT,
  user_id INTEGER NOT NULL,
  name VARCHAR(128) NOT NULL,
  begin_date DATE NOT NULL,
  end_date DATE NOT NULL,
  repeated VARCHAR(24) NULL,
  repetition_step INTEGER NULL,
  repeated_monthly_on VARCHAR(24) NULL,
  repeated_until VARCHAR(24) NULL,
  repeated_until_date VARCHAR(24) NULL,
  repeated_reps INTEGER NULL
);

CREATE TABLE time_events (
  id INTEGER NOT NULL PRIMARY KEY AUTO_INCREMENT,
  user_id INTEGER NOT NULL,
  start_timezone_id INTEGER NOT NULL,
  end_timezone_id INTEGER NOT NULL,
  name VARCHAR(128) NOT NULL,
  begin_local_time DATETIME NOT NULL,
  end_local_time DATETIME NOT NULL
);

CREATE TABLE day_slots (
  id INTEGER NOT NULL PRIMARY KEY AUTO_INCREMENT,
  day_event_id INTEGER NOT NULL,
  the_date DATE NOT NULL,
  is_skipped TINYINT UNSIGNED NOT NULL DEFAULT 0
);

CREATE TABLE time_slots (
  id INTEGER NOT NULL PRIMARY KEY AUTO_INCREMENT,
  time_event_id INTEGER NOT NULL,
  begin_local_time DATETIME NOT NULL,
  end_local_time DATETIME NOT NULL,
  start_timezone_id INTEGER NOT NULL,
  end_timezone_id INTEGER NOT NULL,
  is_skipped TINYINT UNSIGNED NOT NULL DEFAULT 0
);

CREATE TABLE day_event_dows (
   day_event_id INTEGER NOT NULL,
   day_of_week VARCHAR(3) NOT NULL,
   PRIMARY KEY (day_event_id, day_of_week),
   KEY (day_of_week)
);

CREATE TABLE time_event_dows (
   time_event_id INTEGER NOT NULL,
   day_of_week VARCHAR(3) NOT NULL,
   PRIMARY KEY (time_event_id, day_of_week),
   KEY (day_of_week)
);
</code></pre>
<p>Is that really it?  Mostly, yes. Though we need to talk a bit about indexes and about the attributes that we’ve skipped for brevity.</p>
<p>Most experienced database developers would look at the schema above and immediately notice that some “obvious” indexes are missing.  For example, <code>day_events.user_id</code> must certainly be indexed.  Unfortunately, there is no hard and fast rule on what columns (and combinations of columns) need to be indexed.  That depends on how the tables are going to be queried by the application.  The best book about database indexes is called “Use The Index, Luke” (<a href="https://use-the-index-luke.com/">https://use-the-index-luke.com/</a>).  Go read it.  We  will also discuss indexes in a bit more detail in the book.</p>
<p>When we were talking about logical schema (especially in the beginning), we skipped some of the attributes, because they were very much similar to other attributes. For example, we would probably want to add the name of the user, and the column that stores the user’s password hash.  Some of the data elements just don’t add anything new to this text, for example the event location, or the list of invited guests.  As an exercise, you could go ahead and add the elements that we did not discuss, the ones that you’re interested in.  Add a few rows to the catalog tables, fill in the contents of each cell, and then edit the schema definition above to include the missing pieces of data.</p>
<h2 id="conclusiona-idconclusiona">Conclusion<a id="conclusion"></a></h2>
<p>Here is a short summary of the process:</p>
<ul>
<li>
<p>start with a free-form text that describes the business problem you’re working on;</p>
</li>
<li>
<p>write down the list of anchors, as explained above;  use any collaborative tool, such as Google Docs;</p>
</li>
<li>
<p>write down the list of attributes, as explained above, pay particular attention to the questions;</p>
</li>
<li>
<p>write down the list of links, as explained above, pay particular attention to the sentences, because they help you make sure that you get cardinality right;</p>
</li>
<li>
<p>create a graphical schema based on the logical model, if visual representation helps you think;</p>
</li>
<li>
<p>fill in the physical model: table names, column names, physical data types;</p>
</li>
<li>
<p>write down the SQL schema as a series of CREATE TABLE operators, using information from the previous step;</p>
</li>
<li>
<p>submit the schema to your database server, fix typos, re-submit;</p>
</li>
<li>
<p>share the logical model with your team;</p>
</li>
</ul>
<h3 id="whats-nexta-idwhats-nexta">What’s next?<a id="whats-next"></a></h3>
<p>This tutorial is basically a chapter from the upcoming book “Database Design using Minimal Modeling” (<a href="https://databasedesignbook.com/">https://databasedesignbook.com/</a>).  You can leave your email and I’ll send you updates on the book progress and other materials on database design.</p>
<p>Particularly I’m looking for motivated beta readers for the current book draft.  Contact me if you’re interested (<a href="mailto:squadette@gmail.com">squadette@gmail.com</a>).</p>
<p>If this tutorial helped you in understanding some aspect of database design, I’d love to hear your feedback.</p>
<ul>
  
</ul>

    </div></div>
  </body>
</html>
