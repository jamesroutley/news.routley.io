<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.moment.dev/blog/lies-i-was-told-pt-1">Original</a>
    <h1>Lies I was told about collab editing, Part 1: Algorithms for offline editing</h1>
    
    <div id="readability-page-1" class="page"><div><p>In early 2024, I began investigating collaborative editing systems for use in Moment’s core text editor.</p><p>In some ways, we are in a golden era for the problem. Several algorithms now claim to solve not only the online case (where many people simultaneously edit a document), but also the offline case (where people edit offline for an unbounded amount of time, come online, and “magically” their changes are merged together). I had read the papers and listened to the talks, and like others, I was initially optimistic the community had settled on the “right answer” to the whole problem space.</p><p>One of the earliest surprises in the evaluation process was that this is not true——that despite the marketing copy, blog posts, and technical papers stating otherwise, these collaborative editing algorithms provide a systematically poor offline editing experience. Specifically:</p><p>The two most popular families of collab editing algorithms (CRDTs and OT) resolve direct editing conflicts unintuitively enough that users generally interpreted their results as data corruption.</p><p>Offline editing dramatically increases the likelihood of direct conflicts, which means these algorithms are not, on their own, appropriate for offline editing.</p><p>In many ways, this is bad news. And we will spend much of this post discussing why we think these things are true—example anomalies, failure modes, what the practical limitations are, and so on.</p><p>But, the news is not all bad. We are heartened to see some recent research (e.g.) reversing the trend of treating collab editing as a pure algorithms problem, and instead treating it as a UI/UX problem in which algorithms assist. One of the goals of this post is to help motivate this line of reasoning, and we will make time at the end to encourage that, too.</p><p>Example: a seemingly trivial editing conflict</p><p>Let’s start with a game. I provide a trivial editing conflict and you try to guess what happens. Ready? Here’s the scenario: Alice and Bob are both offline. They are editing a document containing the following text:</p><p>return render(() =&gt; (
	&lt;div className=&#34;flex text-sm -ml-1&#34;&gt;
        &lt;div className=&#34;flex flex-col space-y-2 py-2 border border-primary rounded&#34;&gt;
            &lt;div className=&#34;px-5&#34;&gt;Original document&lt;/div&gt;
            &lt;div className=&#34;-ml-px bg-tertiary border-primary p-2 px-4 font-mono font-medium text-sm&#34; style={{ borderLeftWidth: &#34;4px&#34;, }}&gt;
                The Color of Pomegranates
            &lt;/div&gt;
        &lt;/div&gt;
	&lt;/div&gt;
));
</p><p>Bob changes the spelling of Color to the British Colour. Alice deletes all of the text.</p><p>return render(() =&gt; (
	&lt;div className=&#34;flex -ml-1 text-sm&#34;&gt;
	    &lt;div className=&#34;flex space-x-2&#34;&gt;
	        &lt;div className=&#34;flex flex-col border border-primary py-2 grow space-y-2 rounded&#34;&gt;
	            &lt;div className=&#34;px-5&#34;&gt;Bob&#39;s version (adds &#39;u&#39; to &#39;color&#39;)&lt;/div&gt;
	            &lt;div className=&#34;bg-tertiary border-positive p-2 px-4 font-mono font-medium text-sm&#34; style={{ borderLeftWidth: &#34;4px&#34;, }}&gt;
	                The Colo&lt;span className=&#34;bg-positive py-0.5 text-inverse-primary&#34; style={{ padding: &#34;2px&#34; }}&gt;u&lt;/span&gt;r of Pomegranates
	            &lt;/div&gt;
	        &lt;/div&gt;
	        &lt;div className=&#34;flex flex-col border border-primary py-2 grow space-y-2 rounded&#34;&gt;
	            &lt;div className=&#34;px-5&#34;&gt;Alice&#39;s version (all contents deleted)&lt;/div&gt;
	            &lt;div className=&#34;-ml-px bg-tertiary border-negative p-2 px-4 font-mono font-medium text-sm&#34; style={{ borderLeftWidth: &#34;4px&#34;, }}&gt;
	                &lt;span className=&#34;bg-negative py-0.5 text-inverse-primary&#34;&gt;The Color of Pomegranates&lt;/span&gt;
	            &lt;/div&gt;
	        &lt;/div&gt;
	    &lt;/div&gt;
	&lt;/div&gt;
));
</p><p>Later, both Alice and Bob come online. These edits conflict. The system must reconcile these two conflicting edits, even though it has no knowledge of which one came first.</p><p>Q: When all reconciliation is complete and the machines agree, what text will the document contain? Guess by typing your answer into the text field below and clicking ‘submit.’ Note that we accept the empty string as a valid guess.</p><p>return render(({ useSetter }) =&gt; {
	const [value, setValue] = React.useState(&#34;&#34;);
	const [committedValue, setCommittedValue] = React.useState(null);
	useSetter(committedValue);

	return (
		&lt;form className=&#34;flex gap-2&#34; onSubmit={e =&gt; {
			e.preventDefault();
			e.stopPropagation();
			setCommittedValue(value);
		}}&gt;
			&lt;input
				type=&#34;text&#34;
				placeholder=&#34;Type your guess here...&#34;
				className=&#34;w-64 text-sm bg-transparent border border-primary hover:border-primary-hover focus:border-primary-focus focus:outline-none focus:ring ring-default rounded h-8 p-2&#34;
				onChange={e =&gt; setValue(e.target.value)}
			/&gt;
			&lt;designSystem.ButtonAlpha className=&#34;shrink-0&#34; size=&#34;xs&#34; label=&#34;Submit Guess&#34; onClick={() =&gt; setCommittedValue(value)} /&gt;
			&lt;designSystem.ButtonAlpha size=&#34;xs&#34; label=&#34;Reset&#34; onClick={() =&gt; setCommittedValue(null)} /&gt;
		&lt;/form&gt;
	);
})

return render(({ useSetter }) =&gt; (
    &lt;designSystem.InputTextAlpha
        id=&#34;qagejr7axyd1aEYuH5NggAlQ6gNCEEmTPSlYK1l4EU9se79X&#34;
        placeholder=&#34;Type your guess here...&#34;
        pushCondition=&#34;onSubmit&#34;
		allowEmpty={true}
        useSetter={useSetter}
    /&gt;
))
</p><p>return render(() =&gt; {
	const tests = [
	    {
	        library: &#34;yjs&#34;,
	        libraryHref: &#34;https://github.com/yjs/yjs&#34;,
	        libraryVersion: &#34;v13.6.20&#34;,
	        expectedDocumentContents: &#34;u&#34;,
	    },
	    {
	        library: &#34;share.js&#34;,
	        libraryHref: &#34;https://github.com/josephg/ShareJS&#34;,
	        libraryVersion: &#34;v0.7.40&#34;,
	        expectedDocumentContents: &#34;u&#34;,
	    },
	    {
	        library: &#34;Peritext&#34;,
	        libraryHref: &#34;https://github.com/inkandswitch/peritext&#34;,
	        libraryVersion: &#34;89c162d&#34;,
	        expectedDocumentContents: &#34;u&#34;,
	    },
	];
	
	const testResults = tests.map(test =&gt; {
		const result = structuredClone(test);
		result.passed = guess === result.expectedDocumentContents;
		result.resultIcon = result.passed
			? &lt;span className=&#34;font-bold&#34;&gt;[&lt;span className=&#34;text-positive&#34;&gt;PASS&lt;/span&gt;]&lt;/span&gt;
			: &lt;span className=&#34;font-bold&#34;&gt;[&lt;span className=&#34;text-negative&#34;&gt;FAIL&lt;/span&gt;]&lt;/span&gt;;
		result.resultMessage = result.passed
			? &#34;test passed!&#34;
			: &lt;&gt;expected document text &lt;code&gt;&#39;{result.expectedDocumentContents}&#39;&lt;/code&gt;, got &lt;code&gt;&#39;{guess}&#39;&lt;/code&gt;&lt;/&gt;;
		return result;
	})

	const anyErrors = testResults.filter(test =&gt; !test.passed).length &gt; 1;
	const summary = testResults.filter(test =&gt; !test.passed).length &gt; 1
		? &lt;div className=&#34;flex gap-2&#34;&gt;
			&lt;span className=&#34;text-sm mt-0.5&#34;&gt;❌&lt;/span&gt; 
			&lt;div style={{ maxWidth: &#34;32rem&#34; }}&gt;
				&lt;span className=&#34;text-negative font-bold&#34;&gt;You&#39;d think so, but no.&lt;/span&gt;{&#34; &#34;}
				&lt;span&gt;The final result for all {testResults.length} collaborative editing algorithms is a document containing &lt;strong&gt;only the string &lt;code&gt;&#39;u&#39;&lt;/code&gt;&lt;/strong&gt;. Yes, you read that right! &lt;code&gt;The Color of Pomegranates&lt;/code&gt; is deleted, but Bob&#39;s addition, &lt;code&gt;&#39;u&#39;&lt;/code&gt; is kept! The reason for this is that they all work roughly the same: in direct conflicts, they first accept any deletes, &lt;em&gt;and then&lt;/em&gt; apply any additions.&lt;/span&gt;
			&lt;/div&gt;
		&lt;/div&gt;
		: &lt;div className=&#34;flex gap-2&#34;&gt;
			&lt;span className=&#34;mt-0.5 text-sm&#34;&gt;✅&lt;/span&gt;
			&lt;div style={{ maxWidth: &#34;32rem&#34; }}&gt;
				&lt;span className=&#34;text-primary font-bold&#34;&gt;You did well.&lt;/span&gt;
				&lt;span&gt;You correctly guessed the output of {testResults.length}/{testResults.length} collab editing algorithms! But how did you know what the answer was?&lt;/span&gt;
			&lt;/div&gt;
		&lt;/div&gt;;

	if (guess === null) {
		return &lt;div className=&#34;-mt-2 text-tertiary italic text-sm&#34;&gt;Waiting for a guess...&lt;/div&gt;
	}

	return (
		&lt;&gt;
			&lt;div className=&#34;flex&#34;&gt;
			    &lt;div className=&#34;-mt-2 flex flex-col gap-2 border rounded border-primary p-4&#34;&gt;
					{summary}
					&lt;div className={`flex flex-col space-y-1 ${anyErrors ? &#34;mt-2&#34; : &#34;&#34;}`} style={{ marginLeft: &#34;1.25rem&#34; }}&gt;
				        {testResults.map((test) =&gt; {
				            return (
								&lt;div className=&#34;font-mono font-medium text-sm&#34;&gt;
									&lt;span&gt;{test.resultIcon}&lt;/span&gt;{&#34; &#34;}
									&lt;span className=&#34;font-bold text-secondary &#34;&gt;
										&lt;a href={test.libraryHref}&gt;{test.library}&lt;/a&gt;
									&lt;/span&gt;{&#34; &#34;}
									&lt;span className=&#34;text-sm text-secondary&#34;&gt;@&lt;/span&gt;{&#34; &#34;}
								    &lt;span className=&#34;font-mono text-sm text-secondary font-medium&#34;&gt;{test.libraryVersion}:&lt;/span&gt;{&#34; &#34;}
									{test.resultMessage}
					            &lt;/div&gt;
							);
						})}
					&lt;/div&gt;
			    &lt;/div&gt;
			&lt;/div&gt;
		&lt;/&gt;
	)
});
</p><p>✋ 🛑 Did you guess correctly? Seriously—you really should try this before continuing on.</p><p>These anomalies are common on direct conflicts.</p><p>The example above is interesting because it is a trivial, direct editing conflict which these (popular) collaborative editing algorithms do seem to claim to support, but which empirically produces a document that no human would ever write on their own. This is also a case where users interpreted the result as the Moment product corrupting their data.</p><p>So how common is this problem? Every use case is different, but, anecdotally we found that roughly 20-30% of direct conflicts we tried produced results that were similarly—in our opinion—unacceptable, for our use case of offline editing. [nb., I’m not sure if it’s helpful to list some of the anomalies we encountered here, if it is, let me know at <a href="https://www.moment.dev/cdn-cgi/l/email-protection" data-cfemail="f59499908db5989a98909b81db919083">[email protected]</a> or the Moment Discord server and I’ll follow up with a more thorough review.]</p><p>Ultimately, though, because of the negativity of the feedback and the frequency of its occurrence, we felt we could not defend this result to our users.</p><p>These algorithms do seem to claim to support offline editing.</p><p>Initially, when we encountered this result, we thought that we must have misunderstood the semantics offered by these tools. Even now, though, when I read the technical copy for these projects, I can’t help but think this scenario really is in scope.</p><p>The Yjs readme explicitly states that it “supports […] offline editing.”</p><p>The ShareJS landing page claims to allow collaboration “with any amount of lag (from zero to an extended holiday).”</p><p>The Peritext authors describe it as “allow[ing] users to edit independent copies of a document” which can be “automatically merg[ed] […] back together in a way that preserves the users’ intent as much as possible.”</p><p>I admit to still not being quite sure what to make of this. We are in the market for a solution to this problem! I want to believe! I just don’t see how to reconcile these claims with the frequency and kinds of errors we’re seeing in practice.</p><p>Coordination-free algorithms will always have anomalies on direct conflicts.</p><p>At some point in the evaluation process we resigned ourself to the fact that the algorithms did not do what we wanted. But a lingering question remained: is this a fundamental problem for the algorithms, or with some careful contributions, could we contribute back and fix it?</p><p>Unfortunately, we think it’s a fundamental problem for the algorithms, for a few reasons.</p><p>The algorithms only have enough information to guess what the result should be. The algorithms can’t email Alice and Bob to see what they wanted or review it in the GitHub Pull Request UI. It receives Alice’s proposal to delete all the text and Bob’s proposal to change the spelling without knowing what their intent was, and it must use a heuristic to decide what to do with them.</p><p>The algorithms operate on characters and have very, very poor guarantees about their output. This is why in the example above, Alice and Bob end up with a document simply containing the letter u. Not a valid sentence, and not even a valid word!</p><p>Alice and Bob might make different decisions if they knew what the other was doing. Alice and Bob both made decisions based on the document containing the text, The Color of Pomegranates. If Alice knew Bob changed the spelling, or Bob knew Alice deleted the paragraph, they might change their decision to edit at all.</p><p>I think this is probably worth a post all on its own, particularly with more treatment given to the fact that these algorithms don’t—and cannot—obey a causal ordering (cf., Jamie Brandon’s post). But for now, I think we can settle for the intuitive version of this argument.</p><p>Offline editing is a UI/UX problem, not an algorithms problem; and other conclusions.</p><p>So far the news has been bad. We entered the evaluation hopeful that we’d be able to support true offline editing “incidentally” for having implemented a tricky algorithm. And it is true that we left the evaluation left process, well, bereft of hope—forced to conclude that users were right to think of these algorithms were corrupting their data, that the anomalies were fundamental to the algorithms themselves, and that they would be frequent enough to be a real issue. YMMV, but that is where we ended up.</p><p>As I said, though, the news is not all bad. Another way to view this result is as a strong argument for putting significant resources into collaborative editing as a UI/UX problem. The algorithms cannot completely solve the problem, but they can play a role in the solution.</p><p>There are a few reasons to be optimistic about this. One is that we already have one widely-adopted UI for merging documents: git! So in some sense, the research question is how much better it can be—more approachable, more accessible, more automatic, etc.</p><p>I think this resemblance is not superficial. In 2009, a surprising amount of the discourse was focused on the algorithms git used to automatically merge changes together. git adapted the Myers O(ND) diff algorithm, then used mostly by biologists to do BLAST-like sequence analysis. Bram Cohen thought the diff results were unintuitive, and invented the patience diff algorithm, which was then adopted by bzr, a now-defunct git competitor. The list goes on. I think the primary change is that these debates were focused on producing diffs that humans read; now the debate is whether the algorithms can accomplish this result with no human involvement at all.</p><p>Another reason to be optimistic is that some researchers do seem to be concentrating on this problem as a UI/UX problem. I am thinking particularly of Ink &amp; Switch, e.g., the work on collaborative history. I understand Ink &amp; Switch to be operating purposefully a few years ahead of production, but I am excited to see where this lands when it settles down.</p><p>Acknowledgements</p><p>Heartfelt thanks to Kyle Kingsbury, Sean Gillespie, Ian Livingstone, David Adrian, Ben Linsay, Alex Rasmussen, Lita Cho, Lenny Pruss, Michael Yamnitsky, Camille Fournier, James Turnbull, and Ryan Cox for their comments and feedback.</p><p>return render(() =&gt; (
	&lt;div class=&#34;bg-brand-translucent p-8 rounded&#34;&gt;
		👋 If you enjoyed this, you may enjoy other entries in &lt;a href=&#34;https://www.moment.dev/blog&#34;&gt;the Moment devlog&lt;/a&gt;. We&#39;re also hiring! &lt;a href=&#34;mailto:<a href="https://www.moment.dev/cdn-cgi/l/email-protection" data-cfemail="fa90959889ba9795979f948ed49e9f8c">[email protected]</a>&#34;&gt;<a href="https://www.moment.dev/cdn-cgi/l/email-protection" data-cfemail="2842474a5b684547454d465c064c4d5e">[email protected]</a>&lt;/a&gt;
	&lt;/div&gt;
));
</p></div></div>
  </body>
</html>
