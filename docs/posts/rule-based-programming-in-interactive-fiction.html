<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eblong.com/zarf/essays/rule-based-if/index.html">Original</a>
    <h1>Rule-Based Programming in Interactive Fiction</h1>
    
    <div id="readability-page-1" class="page">

<em>
I presented this talk at <a href="http://penguicon.org/">Penguicon 7</a>,
on May 3, 2009.
I also gave a (high-speed) rendition at 
<a href="http://www.barcampboston.org/">BarCamp Boston 5</a>,
April 18, 2010.
</em>
<p>

<em>
Download the <a href="https://eblong.com/zarf/essays/rule-based-if/rule-based-if.pdf">slides for this talk</a> (PDF, 325k).
</em>
</p><hr/>



<a href="https://eblong.com/zarf/essays/rule-based-if/pics/slide-001.txt"><img width="614" height="461" src="https://eblong.com/zarf/essays/rule-based-if/pics/slide-001.png" alt="Slide 1"/></a>
<p>

As I write this, Inform 7 is approaching its third birthday. I7 is a tool
for creating interactive fiction (text adventure games). Like all the most
powerful IF development tools, I7 is a programming language -- a powerful
and peculiar one.
</p><p>

<a href="https://eblong.com/zarf/essays/rule-based-if/pics/slide-002.txt"><img width="614" height="461" src="https://eblong.com/zarf/essays/rule-based-if/pics/slide-002.png" alt="Slide 2"/></a>
</p><p>

Inform 7 gets a lot of attention for its English-like syntax. I&#39;m not going
to talk about the natural-language aspects of I7. I&#39;m going to talk about
the underlying programming model, the system of rules and rulebooks. That&#39;s
less attention-grabbing than the flashy syntax; but, in my opinion, it&#39;s
equally radical. And perhaps a more important development, in the long run.
</p><p>

To be fair, I also like talking about the rule-based programming model
because I contributed some of its ideas, back when I7 was first taking
shape. I&#39;m not claiming authorship here, mind you. I got into a long and
digressive email conversation with Graham Nelson and Emily Short, in which
we all threw ideas around, and then Graham went ahead and spent six years
developing his ideas. I shoved mine on the shelf.
</p><p>

This means that I will talk about I7 for a while, and then break into a wild
flight of &#34;but this is how <em>I</em> think it should be done!&#34; And then
finish up with all the reasons I haven&#39;t made it work yet. Such is a
hacker&#39;s life.
</p><p>

The rule-based programming model is not new. It&#39;s got connections to logical
programming languages, as in Prolog. It&#39;s related to (or maybe the same as)
aspect-oriented programming. But why do I like this model? Well, why does
anybody like any kind of programming model?
</p><p>

A programming language is a tool for handling design complexity. That&#39;s what
all of computer science is, really -- languages, libraries, type systems,
garbage collectors, everything you learn about programming. They&#39;re ways to
build more and more complex designs without losing your grip.
</p><p>

The way you manage complexity is to be able to ignore it. A good programming
tool lets you forget about some part of the problem, so that you can focus
on some other part. And it ensures that when you return to the parts you
forgot, you haven&#39;t accidentally broken them.
</p><p>

<a href="https://eblong.com/zarf/essays/rule-based-if/pics/slide-003.txt"><img width="614" height="461" src="https://eblong.com/zarf/essays/rule-based-if/pics/slide-003.png" alt="Slide 3"/></a>
</p><p>

The first work of IF, <em>Adventure</em>, was a messy FORTRAN hack. The
second, <em>Dungeon</em> (or <em>Zork</em>), was created at MIT, so it was a
messy LISP hack. (Actually a LISP dialect called MDL, which is why you see
angle brackets as well as parentheses.)
</p><p>

These were messy because they were built as games, not game-design tools.
The creators were figuring out how to build IF worlds on the fly. 
</p><p>

The MIT gang went on to create the first well-known IF design
<em>system</em>, under the Infocom banner. It consisted of a virtual
machine, a language called ZIL, a compiler for the language, and a parser
library written in the language. ZIL looked a lot like MDL, but it actually
had a much simpler structure; it was essentially BASIC written with
parentheses. (I mean angle brackets.)
</p><p>

<a href="https://eblong.com/zarf/essays/rule-based-if/pics/slide-004.txt"><img width="614" height="461" src="https://eblong.com/zarf/essays/rule-based-if/pics/slide-004.png" alt="Slide 4"/></a>
</p><p>

Adventure and Dungeon sparked lots of imitators. The next twenty years gave
us a whole roster of IF development systems. These were mostly created by
people who had learned to program in the 70s and 80s, so the languages
followed the programming models you&#39;d expect: BASIC-like, C-like,
Pascal-like. Although, to be fair, a couple were genuinely LISP-y.
</p><p>

How did these systems compare? Small code samples, like the ones above, show
off difference in syntax. But the underlying code model is important too.
For example, the version of <em>Adventure</em> I quoted was written almost
completely without functions. (Just two small utility functions are used.)
The parser and game logic are all one mass of loops and gotos. Nobody would
consider writing a complex program that way today.
</p><p>

So, the simplest IF systems had if/else statements. The more advanced ones
had functions and data structures. The most complex aspired to what people
thought of as the sacred peak of computer science: object-oriented
programming.
</p><p>

<a href="https://eblong.com/zarf/essays/rule-based-if/pics/slide-005.txt"><img width="614" height="461" src="https://eblong.com/zarf/essays/rule-based-if/pics/slide-005.png" alt="Slide 5"/></a>
</p><p>

It&#39;s not hard to imagine why designers moved towards OO design tools. Think
about what a typical IF game comprises. You&#39;ve got some rooms, which
contains objects. Some objects are containers, so they have other objects
inside them. And then you have some representation of the player, which can
also contain objects.
</p><p>

<a href="https://eblong.com/zarf/essays/rule-based-if/pics/slide-006.txt"><img width="614" height="461" src="https://eblong.com/zarf/essays/rule-based-if/pics/slide-006.png" alt="Slide 6"/></a>
</p><p>

Everybody likes to generalize, and the obvious generalization is to say that
a container is a kind of object. Then the player looks like a special
object, and rooms can be objects too (or maybe a special kind of container).
Presto, everything in the world is an object. Maybe object-oriented
programming would be a good fit!
</p><p>

<a href="https://eblong.com/zarf/essays/rule-based-if/pics/slide-007.txt"><img width="614" height="461" src="https://eblong.com/zarf/essays/rule-based-if/pics/slide-007.png" alt="Slide 7"/></a>
</p><p>

Here&#39;s a common OO pattern: an object field (or property). Every object in
the game has a description, its response to the &#34;EXAMINE&#34; command. A field
works nicely for that. We can define a description field in the base
class, of type string. This basic description applies to all objects, as a
default; we can then override it for specific objects.
</p><p>

This is working really well! It gets a little trickier, though, because many
objects have <em>dynamic</em> descriptions. They change over the course of
the game. For example, the bottle can be filled with either water or oil.
</p><p>

We could handle this by assigning a new value to Bottle.description every
time the bottle changed state. Sometimes that&#39;s practical. But we&#39;d like a
more flexible option; we&#39;d like to associate some code with the bottle which
computes the current description.
</p><p>

<a href="https://eblong.com/zarf/essays/rule-based-if/pics/slide-008.txt"><img width="614" height="461" src="https://eblong.com/zarf/essays/rule-based-if/pics/slide-008.png" alt="Slide 8"/></a>
</p><p>

Code associated with an object is, of course, an object method. Here&#39;s the
object description implemented as a method instead of a string field.
</p><p>

By the way, this model leaves us with a lot of one-line print methods. Many
descriptions <em>aren&#39;t</em> dynamic. So it winds up being convenient to
allow a shortcut, where you say &#34;description: STRING&#34; and interpret that as
a method that prints STRING. Inform 6 has this shortcut, for example. But
it&#39;s syntactic sugar; it doesn&#39;t change the model.
</p><p>

I&#39;ve used a more interesting shortcut here. Some OO languages, like Java,
are very strict about the distinction between objects and classes. You
define classes, and then instantiate them to create objects.
</p><p>

That&#39;s a nuisance in IF, because most objects in an IF game are unique.
<em>Adventure</em> only has one glass bottle. It would be tedious to have to
define a Bottle class and then do Bottle.new(). So OO IF languages tend to
use a prototyping model: you can define a one-off object with its own fields
and methods, and then maybe subclass it if you need to. That&#39;s what I&#39;ve
done above.
</p><p>

Descriptions are a bit of a special case. The basic behavior of an IF game
is a read-parse-perform loop: read a command from the player, parse it into
action data, and then execute the action. How does that look in an OO
system?
</p><p>

<a href="https://eblong.com/zarf/essays/rule-based-if/pics/slide-009.txt"><img width="614" height="461" src="https://eblong.com/zarf/essays/rule-based-if/pics/slide-009.png" alt="Slide 9"/></a>
</p><p>

Let the parser be a black box. (A black box with months of fiddly work
inside it, sure.) It sucks in the player&#39;s command, and spits out a tuple
(VERB, NOUN). OO doctrine says that a VERB is a method, and a NOUN is an
object. So we call that method of that object. End of turn, read the next
command.
</p><p>

So we define a bunch of objects, give them appropriate action methods, drop
the parser on top, and we&#39;ve got a game, right? Right... until we try to do
anything more complicated. Then it falls apart like a bundle of ball
bearings.
</p><p>

<a href="https://eblong.com/zarf/essays/rule-based-if/pics/slide-010.txt"><img width="614" height="461" src="https://eblong.com/zarf/essays/rule-based-if/pics/slide-010.png" alt="Slide 10"/></a>
</p><p>

When it&#39;s dark, you can&#39;t examine anything; or rather, you always get the
same response: &#34;It&#39;s too dark to do that.&#34; But where do we put that check?
It applies to all objects, but if we put it in the Object.examine() method,
any specific object method will short-circuit it. We could paste the same
check into Sword.examine(), Lamp.examine(), ... every object in the game...
but that&#39;s the kind of repetitive coding style that OO was supposed to
<em>fix</em>.
</p><p>

What about the &#34;LOOK&#34; command? That doesn&#39;t have an object at all, which is
a little problematic for object-oriented code. Maybe single-verb commands
should be routed to the room. That makes sense for &#34;LOOK&#34;, but not so much
for &#34;INVENTORY&#34;.
</p><p>

&#34;PUT MEAT IN BASKET&#34; is even worse -- it has <em>two</em> objects, a direct
object and an indirect object. We could invoke a method on the Meat object
or the Basket object. Really, we&#39;d want to invoke methods on <em>both</em>,
because either one could customize the default &#34;PUT X IN Y&#34; action. (A
thimble is too small to put most objects in; smoke is too diffuse to be put
<em>into</em> anything.)
</p><p>

The method we&#39;re writing might belong on some other object entirely. Imagine
a room with an orc and a pie. If you try to take the pie, the orc kills you,
unless you&#39;ve killed him first or otherwise removed him from the room. It
would be logical to send the orc object a message for every &#34;TAKE&#34; action in
the room. Where does this stop? Should we invoke a method on every object in
the room for every action? (In what order?)
</p><p>

Another fun case: some checks apply to multiple actions. An electrified
lever zaps you if you pull, push, or even touch it. We don&#39;t want to copy
that check into every touching method. Maybe we could have &#34;pull&#34; and &#34;push&#34;
be subclasses of a base &#34;touch&#34; class... except, hang on, that makes no
sense. OO has no notion of methods subclassing other methods.
</p><p>

I suppose we could drop the &#34;verbs are methods&#34; scheme, and represent verbs
as abstract objects. Pass the verb as a parameter. Instead of invoking
Flower.smell(), we&#39;d invoke Flower.do(Smell). But we also need those
multi-object checks, so we&#39;ll pass the object as a parameter too:
Player.do(Smell, Flower).
</p><p>

<a href="https://eblong.com/zarf/essays/rule-based-if/pics/slide-011.txt"><img width="614" height="461" src="https://eblong.com/zarf/essays/rule-based-if/pics/slide-011.png" alt="Slide 11"/></a>
</p><p>

This neatly covers all the cases I&#39;ve described. It&#39;s perfect. Except -- now
all of our game logic is jammed into one enormous method, full of if and
switch statements. Perfect, if your goal is to go stark staring bonkers.
</p><p>

<a href="https://eblong.com/zarf/essays/rule-based-if/pics/slide-012.txt"><img width="614" height="461" src="https://eblong.com/zarf/essays/rule-based-if/pics/slide-012.png" alt="Slide 12"/></a>
</p><p>

This is how Inform 6 manages its code. Every action invokes this wrapper
function, which invokes a whole slew of object methods: on the player, on
nearby objects, on the room itself, on the command target object. Each of
these in turn has its chance to determine the action outcome. If none of
them raise a hand, the action&#39;s default behavior is invoked.
</p><p>

This is usable. I&#39;ve written complex games in Inform 6. But you can&#39;t call
it &#34;object-oriented&#34; in any deep sense. It&#39;s the stilted result of deciding
that every bit of code must be associated with one object, and then trying
to name (in advance) every object that some action code might be associated
with. It gets the job done, as long as you&#39;re willing to force yourself into
its mold.
</p><p>

(Even when you do, it&#39;s not as flexible as you might hope. For example, the
order of method checks is rigid. You can&#39;t write a room effect that
overrides a nearby-object effect.)
</p><p>

<a href="https://eblong.com/zarf/essays/rule-based-if/pics/slide-013.txt"><img width="614" height="461" src="https://eblong.com/zarf/essays/rule-based-if/pics/slide-013.png" alt="Slide 13"/></a>
</p><p>

So I sat back and said to myself, player, how am I really using Inform 6?
I&#39;m not looking at objects and then deciding what methods to override.
Rather, I&#39;m thinking up conditions, and then working out what objects and
methods I6 wants me to attach them to. I feel like I&#39;m designing my game and
then porting it to I6.
</p><p>

The question, then, is what language am I porting it to I6 <em>from</em>?
</p><p>

If I were working in a language that fit my approach, I would create a cloud
of rules and conditions. The compiler would then knit them together into a
game. Some of my rules would be associated with objects, as in I6. But other
rules would be associated with actions, and others with global game state
(like the time of day). It&#39;s the compiler&#39;s job to ensure that every
relevant rule is considered in the course of handling an action.
</p><p>

<a href="https://eblong.com/zarf/essays/rule-based-if/pics/slide-014.txt"><img width="614" height="461" src="https://eblong.com/zarf/essays/rule-based-if/pics/slide-014.png" alt="Slide 14"/></a>
</p><p>

Here&#39;s a pass at what a rule might look like, as a program element.
</p><p>

The <em>atom</em> identifies what process we&#39;re carrying out or computing.
The behavior of an atom is defined by one or several rules. (The atom might
have parameters, but we&#39;ll get to that in a moment.)
</p><p>

The <em>code</em> is arbitrary code; it does something. (Let&#39;s take for
granted the shortcut I mentioned above, where a bare string means &#34;print
this string&#34;.)
</p><p>

The <em>condition</em> describes under what circumstances this code should
be used for the atom.
</p><p>

<a href="https://eblong.com/zarf/essays/rule-based-if/pics/slide-015.txt"><img width="614" height="461" src="https://eblong.com/zarf/essays/rule-based-if/pics/slide-015.png" alt="Slide 15"/></a>
</p><p>

This is less alien than it sounds. If we strip off the condition part of the
rule, what we&#39;re left with is -- an ordinary function. &#34;To do FuncName, run
this code.&#34; The condition is effectively &#34;always&#34;; you can read it as an
implied &#34;...if true&#34; condition.
</p><p>

<a href="https://eblong.com/zarf/essays/rule-based-if/pics/slide-016.txt"><img width="614" height="461" src="https://eblong.com/zarf/essays/rule-based-if/pics/slide-016.png" alt="Slide 16"/></a>
</p><p>

If we throw in an object parameter, we can effectively build an object
field. The first rule, with an &#34;if true&#34;, defines the general condition --
it always holds, unless another rule overrides it. The second rule applies
to a class of objects. The third rule applies to a specific object.
</p><p>

Of course we need the compiler to understand that the second rule overrides
the first rule, and the third overrides the second. That&#39;s doable, at least
in theory. The first condition is clearly totally generic. And if we&#39;ve
defined the Hope Diamond as being a treasure, then the compiler can tell
that the third condition is a specific case of the second. So these logical
relationships will get all the rules lined up in the right order -- at least
for this simple case.
</p><p>

<a href="https://eblong.com/zarf/essays/rule-based-if/pics/slide-017.txt"><img width="614" height="461" src="https://eblong.com/zarf/essays/rule-based-if/pics/slide-017.png" alt="Slide 17"/></a>
</p><p>

By the way, we don&#39;t really need the atom part of the rule at all. We could
treat the atom as just another parameter. That simplifies the syntax, at the
cost of making the conditions more complicated.
</p><p>

Maybe this is the theoretically pure path. It&#39;s certainly more powerful --
it lets us define rules that cover several different atoms. But it&#39;s one
step farther than I&#39;m willing to go. I need <em>some</em> irreducible
structure to hang my scarf on, and atoms are it. (That&#39;s why I call them
&#34;atoms&#34;. In Inform 7, they&#39;re called &#34;rulebooks&#34;.)
</p><p>

<a href="https://eblong.com/zarf/essays/rule-based-if/pics/slide-018.txt"><img width="614" height="461" src="https://eblong.com/zarf/essays/rule-based-if/pics/slide-018.png" alt="Slide 18"/></a>
</p><p>

We can set up many familiar programming structures using this rule
mechanism. For example, a constant is just a one-rule atom with no
parameters, which returns a value. (Again, we might want to write simple
actions as bare values.)
</p><p>

<a href="https://eblong.com/zarf/essays/rule-based-if/pics/slide-019.txt"><img width="614" height="461" src="https://eblong.com/zarf/essays/rule-based-if/pics/slide-019.png" alt="Slide 19"/></a>
</p><p>

An object method works just like an object property -- a list of rules based
on class membership.
</p><p>

<a href="https://eblong.com/zarf/essays/rule-based-if/pics/slide-020.txt"><img width="614" height="461" src="https://eblong.com/zarf/essays/rule-based-if/pics/slide-020.png" alt="Slide 20"/></a>
</p><p>

What about a property whose value can be reassigned? Computed property
values are nice, but sometimes you really do want to store a new value
somewhere. Here we have a delicate vase which is rendered worthless if you
hit it.
</p><p>

(I&#39;m sneaking another syntactic shortcut in on you. The condition of this
rule is really &#34;...if (obj is MingVase)&#34;. I&#39;ve just specified the parameter
condition directly.)
</p><p>

The assignment operator, :=, needs to fit into the rule system. Let&#39;s treat
it as this implicit, overriding rule:
</p><p>

<a href="https://eblong.com/zarf/essays/rule-based-if/pics/slide-021.txt"><img width="614" height="461" src="https://eblong.com/zarf/essays/rule-based-if/pics/slide-021.png" alt="Slide 21"/></a>
</p><p>

The compiler will have to generate these implicit rules for any atoms that
are assigned to in the program code. It will also have to keep track of what
values have been assigned where. No big deal; it&#39;s just a lookup table,
managed behind the scenes.
</p><p>

<a href="https://eblong.com/zarf/essays/rule-based-if/pics/slide-022.txt"><img width="614" height="461" src="https://eblong.com/zarf/essays/rule-based-if/pics/slide-022.png" alt="Slide 22"/></a>
</p><p>

This sort of assignment rule works just as well for simple global variables.
Here&#39;s a Score atom which starts out as zero, but increases at a particular
point in the game.
</p><p>

Note that the first rule defines a constant, same as we defined Pi earlier.
Then the second rule turns the constant into a variable. Don&#39;t let this
scare you. Plenty of programming languages let you rebind any identifier at
any time.
</p><p>

Let&#39;s get a bit more ambitious. I&#39;ve been writing rule conditions that use
the &#34;ofclass&#34; operator, as if I had a traditional object hierarchy to work
with. Pretend I don&#39;t <em>like</em> traditional object hierarchies, and want
to use atoms instead. 
</p><p>

<a href="https://eblong.com/zarf/essays/rule-based-if/pics/slide-023.txt"><img width="614" height="461" src="https://eblong.com/zarf/essays/rule-based-if/pics/slide-023.png" alt="Slide 23"/></a>
</p><p>

A class is just a set of objects; we can implement that as a membership
property. Three very simple rules. All objects are non-treasures, with these
two exceptions. Now we can rewrite the earlier Price rules without any need
for the &#34;ofclass&#34; operator.
</p><p>

When you get down to it, an inherited property value is just one property
(the Price) derived from another (the Treasure membership property). So we
have one atom whose computation depends on another atom.
</p><p>

The compiler will have to track this dependency in order to generate
appropriate code. But that will be a pretty simple job -- especially since
the Treasure rules are so simple. You could imagine more complex
dependencies; perhaps a subclass relationship, where one &#34;class&#34; atom
implies another. It&#39;ll work the same way. We know how to build dependency
graphs, and detect circular dependencies, and that&#39;s all we need.
</p><p>

Since all atoms play by the same rules, we can do some tricks that
traditional OO can&#39;t. We can change an object&#39;s class, or classes, at
runtime. Assign false to Treasure(MingVase), and the vase stops being a
treasure. Or we could make Treasure(MingVase) be a more complex computation,
derived from other game state, rather than a constant true or false.
</p><p>

<a href="https://eblong.com/zarf/essays/rule-based-if/pics/slide-024.txt"><img width="614" height="461" src="https://eblong.com/zarf/essays/rule-based-if/pics/slide-024.png" alt="Slide 24"/></a>
</p><p>

Now that I&#39;ve gotten all of these program structures built, it&#39;s time for
you all to raise your hands -- good -- and ask me: why? Why am I interested
in replacing functions, and classes, and variables and constants, with these
rule-based substitutes?
</p><p>

This <em>isn&#39;t</em> the path that Inform 7 went down. I7 uses rules for a
lot of its infrastructure, but it still has variables and constants and
classes and properties. Traditional ones, not made out of rule-stuff. I7&#39;s
rulebooks aren&#39;t very atomic, for that matter. They&#39;re fairly heavyweight
structures, which take some effort to set up and invoke. You wouldn&#39;t want
to define a single I7 constant using a rule.
</p><p>

But I think that a rule-based model is appropriate for IF. For big heavy
features, for tiny little low-level features, for everything.
</p><p>

<a href="https://eblong.com/zarf/essays/rule-based-if/pics/slide-025.txt"><img width="614" height="461" src="https://eblong.com/zarf/essays/rule-based-if/pics/slide-025.png" alt="Slide 25"/></a>
</p><p>

The reason, the big overarching reason, is that IF programming is full of
exceptions. I don&#39;t mean the catch/throw kind of exceptions; I mean
exceptional cases. And they&#39;re not the kind that you plan for in advance.
They&#39;re irregular, unpredictable, ad-hoc kinds of exceptions.
</p><p>

Each time you stumble over one of these cases, you write some code
that tweaks an existing part of the game logic -- modifying either
some library code, or some code you wrote last week. So you can&#39;t
afford to think about the interactions between <em>this</em> tweak and
every other tweak in the game. That&#39;s N-squared interactions as your
game grows -- too much complexity to handle. You have to be able to
ignore them. You have to say, this change applies under <em>these</em>
conditions, and all of those changes apply under different conditions,
so they&#39;re all safe from each other. 
</p><p>

I&#39;ve already talked about the ability to slip from a simple value, perhaps a
string, to a dynamic piece of code. You don&#39;t want to have to go back and
turn a static print statement into a function call, or a function call into
a method, just because you changed your mind about how one case should work.
The simplest mechanism in the design system should scale up to as much
complexity as you need.
</p><p>

IF work usually starts by loading up a standard library. This is a big
swathe of pre-built command logic and world logic; you need it, but you need
to be able to modify it, too. You need to be able to customize <em>all</em>
of it. Really, the characteristic Frustrating Moment of building a text
adventure is looking at some part of the library -- a string value, a
behavior, a command -- and saying &#34;How do I change that?&#34; (If you&#39;re
unlucky, it&#39;s &#34;Dammit, there&#39;s no way to change that.&#34;)
</p><p>

An example, so that you don&#39;t think I&#39;m making this stuff up. I was working
on a game a couple of years ago, and it had a lot of doors. In Inform, a
door can be open or closed. That&#39;s a boolean property -- you can set it one
way or the other. Well, I need one door whose open-ness was a function of
the open-ness of several other doors. So now it&#39;s a boolean property which,
in one case, is a function call.
</p><p>

IF design runs into this all the time. You give the player a numeric score,
and then decide that in chapter ten the player will go crazy and his score
will be a random number. Or &#34;rhinoceros&#34;. Treasures break and become
worthless. A telephone needs the attributes of a person, because the &#34;talk&#34;
verb is associated with people, and you have to be able to talk to a
telephone. (This was a real I7 bug report.)
</p><p>

Earlier I was making fun of the notion of redefining Pi. But redefining
string constants is the most elementary level of IF work. The standard
library has an message &#34;You are empty-handed&#34;; you want to change that to a
more distinctive &#34;You ain&#39;t got nothin&#39;.&#34; That kind of change should be
supported up-front. (It&#39;s a non-trivial amount of work in I7,
unfortunately.)
</p><p>

It&#39;s not just you and the library. Any well-used IF system will have a large
collection of third-party libraries, or library extensions. They
<em>also</em> want to modify the standard library. At the same time, you are
modifying <em>them</em>. There are code tweaks flying back and forth between
all these different code sources. Inevitably, some of them will collide. So
you need a system which is built from the ground up to resolve
separately-defined behaviors.
</p><p>

For that matter, once your game gets beyond a certain point, you&#39;re
effectively collaborating with yourself. You get chapter one working; then
you&#39;re working on chapter two, and all that chapter-one code is effectively
a library. It does its job, but you may have to make changes that intersect
it. You can&#39;t annoy the guy who wrote it -- who happens to be you.
</p><p>

One of the dirty open secrets of IF design is that testing is really, really
hard. There&#39;s no such thing as a complete unit test, because the range of
possible input is unbounded. You can go through a scene and tune every verb
the player might think of -- and I do -- but it&#39;s still not <em>safe</em>,
because tomorrow you&#39;re going to write more code that involves those verbs
and those objects. So, again, you need a development system which is smart
at the level of &#34;When does this code apply?&#34;
</p><p>

I am confident that my rule model provides all the flexibility and
customizability that I need. The question is, does it provide the safety --
the ability to tune out complexity and focus on one rule at a time, without
breaking the whole system. Does this model let you manage complexity, or
just bury yourself in it?
</p><p>

Answer: beats the heck out of me.
</p><p>

The tricky bit, and the bit I&#39;ve been glossing over in this whole rule
discussion, is how you handle conflicting rules in a rulebook (that is, an
atom).
</p><p>

<a href="https://eblong.com/zarf/essays/rule-based-if/pics/slide-026.txt"><img width="614" height="461" src="https://eblong.com/zarf/essays/rule-based-if/pics/slide-026.png" alt="Slide 26"/></a>
</p><p>

I mentioned one strategy already: logical precedence. A general rule is
always overridden by a more specific rule. For example, if you have a rule
for containers, and then a rule for <em>closed</em> containers, the latter
is clearly an exception to the former. (Formally: if condition X logically
implies condition Y, then rule X overrides rule Y.)
</p><p>

This is great as far as it goes... which is the easy cases. Most rule
conflicts are partial overlaps, not clean exceptions. For example, you have
a rule for describing living people, and then a rule for describing things
when it&#39;s dark. Those are two independent conditions. We intuitively feel
that the darkness rule takes precedence -- when it&#39;s dark, you can&#39;t see
anything at all. But how does the compiler decide?
</p><p>

All of the easy solutions are terrible. For example, the compiler could
decide that if two rules conflict, the earlier one (in the source code) is
overridden by the later one. This sucks because one day you reorganize your
program, to tidy it up a little, and everything starts working differently.
Not good.
</p><p>

Inform 7 has a painfully detailed schema for deciding which rules come
before which. It&#39;s in the manual, and nobody understands it. (The logical
precedence strategy is in there, but in a strange scattered way that I don&#39;t
understand.) I hate when fundamental language mechanisms are too complicated
to understand.
</p><p>

A simple strategy is &#34;don&#39;t cope with it.&#34; Throw an error and let the author
fix it. Fixing it means either declaring which rule takes precedence, or,
equivalently, writing a new rule to cover the overlap.
</p><p>

<a href="https://eblong.com/zarf/essays/rule-based-if/pics/slide-027.txt"><img width="614" height="461" src="https://eblong.com/zarf/essays/rule-based-if/pics/slide-027.png" alt="Slide 27"/></a>
</p><p>

But of course that&#39;s the worst possible plan for complexity management. One
new broadly-stated rule might conflict with dozens of existing rules, and
there&#39;s no way the author wants to resolve all those conflicts manually. 
</p><p>

Equally of course, the author will have to get involved at <em>some</em>
point. The compiler will never be smart enough to resolve every problem
on its own. So let&#39;s presume the compiler has done its best, and thrown
an error. The author is faced with what&#39;s left. We
need a model where the author can resolve many precedence conflicts at once,
in some general way, while still being able to adjust individual cases as
desired.
</p><p>

<a href="https://eblong.com/zarf/essays/rule-based-if/pics/slide-028.txt"><img width="614" height="461" src="https://eblong.com/zarf/essays/rule-based-if/pics/slide-028.png" alt="Slide 28"/></a>
</p><p>

The author&#39;s life would be simpler if he could declare precedence for entire
groups of rules at a time. We already have rules coming in groups, right?
The standard library is a group, each library extension is a group. If the
author has organized his code into chapters, or sections, or files, then
each one of those could be a group. Probably groups will be split into
subgroups, too.
</p><p>

Of course, we may want to override a <em>general</em> precedence statement
in particular cases. Maybe one rule in the group needs high priority, even
though most of the group is low priority. Maybe you just need to tweak a
specific case.
</p><p>

So the compiler will have to be able to figure out which precedence
statements are exceptions. It will have to detect circular precedence. If it
detects a conflict, it will have to ask for help in deciding which
precedence statement takes precedence...
</p><p>

This is the point where you raise your hands -- good -- and ask, didn&#39;t you
just <em>say</em> all that? Twenty minutes ago? Because the precedence
mechanism I&#39;m describing sounds exactly like the rule mechanism it&#39;s
supposed to fix. Precedence is an atom; all those precedence statements are
rules.
</p><p>

<a href="https://eblong.com/zarf/essays/rule-based-if/pics/slide-029.txt"><img width="614" height="461" src="https://eblong.com/zarf/essays/rule-based-if/pics/slide-029.png" alt="Slide 29"/></a>
</p><p>

So I honestly don&#39;t know whether I have a workable system. Maybe the rule
engine can manage itself, bootstrapping itself, with the complex cases
resting on the simple cases. Or maybe it&#39;s all circular logic and it can&#39;t
get off the ground.
</p><p>

<a href="https://eblong.com/zarf/essays/rule-based-if/pics/slide-030.txt"><img width="614" height="461" src="https://eblong.com/zarf/essays/rule-based-if/pics/slide-030.png" alt="Slide 30"/></a>
</p><p>

A quick survey of other trouble spots:
</p><p>

Some properties are related. If X is the parent of Y, then Y is the child of
X -- and it&#39;s also true that X is nonempty. We&#39;d like to implement all of
those computations as atoms, so that their behavior can be customized. But
what does it mean to redefine the Child relation? Do you have to redefine
Parent and Nonempty, too? That&#39;s fragile; keeping them in sync would be
difficult. (Inform 7 avoids this by working at the high level of relations,
instead of the low level of rules. That&#39;s clearly better for this case, but
I&#39;d like to find an approach that has the advantages of both.)
</p><p>

Some operations occur in several phases. An IF action typically has a
&#34;perform the work&#34; phase and a &#34;report what happened&#34; phase. Do we set this
up as one atom that does two things, or two atoms? The author probably wants
to define them at the same time; writing one rule is conceptually easiest.
And sometimes you want to override the whole thing with one rule. But then
sometimes you want to change the displayed message, or change the underlying
implementation, or maybe do the work silently. So we need to be able to
treat the two phases separately.
</p><p>

You might try to write two rules with the same condition, so that they stay
in sync automatically. But that&#39;s not always simple. The &#34;perform&#34; phase is
changing the game state, so the condition might not be true any more by the
time the &#34;report&#34; phase happens.
</p><p>

You might want to add a step to any atom -- something that happens before or
after the original code. It makes sense to do this with some recursive
rules, as shown above. You define a rule which does something and then calls
the original rule. Or the other way around.
</p><p>

But again, what if you come back later and want to customize just one step
of this multi-step process? Is there a model that makes sense?
</p><p>

<a href="https://eblong.com/zarf/essays/rule-based-if/pics/slide-031.txt"><img width="614" height="461" src="https://eblong.com/zarf/essays/rule-based-if/pics/slide-031.png" alt="Slide 31"/></a>
</p><p>

I have ideas for dealing with each of these problems -- individually, for
these short examples. Everything I&#39;ve shown you has been a small example.
The trouble is, I&#39;m trying to find a solution that works for <em>large</em>
examples. You can&#39;t use snippets that fit on a presentation slide to prove
anything about a full-scale IF design system.
</p><p>

Inform 7 has been in development for six years, and in widespread use for
three. It&#39;s still changing significantly with each release. That&#39;s how long
it takes to hammer out design problems -- never mind the underlying plan
that the design is built on.
</p><p>

If I&#39;m lucky, I can adapt some of I7&#39;s experience to my own approach. But I
won&#39;t know until I try putting together a complete IF library, and then
writing a game in it. Kind of a daunting development plan.
</p><p>

<a href="https://eblong.com/zarf/essays/rule-based-if/pics/slide-032.txt"><img width="614" height="461" src="https://eblong.com/zarf/essays/rule-based-if/pics/slide-032.png" alt="Slide 32"/></a>
</p><p>

References:
</p><ul>
<li>Dennis Jerz:  
<a href="http://www.digitalhumanities.org/dhq/vol/001/2/000009.html">Somewhere Nearby is Colossal Cave</a>

</li><li>Stephen Granade:  
<a href="http://www.brasslantern.org/community/history/timeline-c.html">A Brief History of Interactive Fiction</a>

</li><li>Graham Nelson:  
<a href="http://www.inform7.com/learn/documents/WhitePaper.pdf">Natural Language, Semantic Analysis and Interactive Fiction</a>

</li><li>The 
<a href="http://ifwiki.org/">Interactive Fiction Wiki</a>

</li><li>Andrew Plotkin:  
<a href="https://eblong.com/zarf/rule-language.html">ongoing and completely unorganized notes</a>
on rule-based programming
(includes this presentation)

</li></ul>

<hr/>

Last updated May 5, 2009.
<p>

<em><a href="https://eblong.com/zarf/rule-language.html">Notes on rule-based programming</a></em></p><p>

<em><a href="https://eblong.com/zarf/home.html">Zarfhome</a></em>
<em><a href="https://eblong.com/zarf/sitemap.html#if">(map)</a></em>
<em><a href="https://eblong.com/zarf/cave/if.html">(down)</a></em>




</p></div>
  </body>
</html>
