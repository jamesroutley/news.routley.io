<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.wiz.io/blog/wiz-research-codebreach-vulnerability-aws-codebuild">Original</a>
    <h1>Supply Chain Vuln Compromised Core AWS GitHub Repos &amp; Threatened the AWS Console</h1>
    
    <div id="readability-page-1" class="page"><div><p>Wiz Research uncovered <strong>CodeBreach</strong>, a critical vulnerability that placed the AWS Console supply chain at risk. The issue allowed a complete takeover of key AWS GitHub repositories - most notably the AWS JavaScript SDK, a core library that powers the AWS Console<strong>.</strong> By exploiting CodeBreach, <strong>attackers could have injected malicious code to launch a platform-wide compromise, potentially</strong> <strong>affecting not just the countless applications depending on the SDK, but the Console itself, threatening every AWS account</strong>.</p><figure><div aria-owns="rmiz-modal-" data-rmiz=""><div data-rmiz-content="not-found"></div></div></figure><p>The vulnerability stemmed from a subtle flaw in how the repositories’ <a target="_blank" href="https://aws.amazon.com/codebuild/"><u>AWS CodeBuild</u></a> CI pipelines handled build triggers. Just two missing characters in a Regex filter allowed unauthenticated attackers to infiltrate the build environment and leak privileged credentials. This post breaks down how we leveraged this subtle misconfiguration to achieve a full repository takeover, and provides key<strong> </strong>recommendations for CodeBuild users to harden their own projects against similar attacks.</p><p>Wiz responsibly disclosed all findings to AWS, who promptly remediated the issue. AWS also implemented global hardening measures within the CodeBuild service to prevent similar attacks. Most notably, the new <a target="_blank" href="https://docs.aws.amazon.com/codebuild/latest/userguide/pull-request-build-policy.html"><u>Pull Request Comment Approval</u></a> build gate offers organizations a simple and secure path to prevent untrusted builds. Read the AWS Advisory <a target="_blank" href="https://aws.amazon.com/security/security-bulletins/2026-002-AWS/"><u>here</u></a>.</p><p>This issue follows a familiar pattern seen in recent supply-chain attacks like the <a target="_blank" href="https://www.wiz.io/blog/s1ngularity-supply-chain-attack"><u>Nx S1ngularity</u></a> incident, where subtle CI/CD misconfigurations lead to disproportionately impactful attacks. Just last July, a threat actor abused a similar CodeBuild issue to <a target="_blank" href="https://aws.amazon.com/security/security-bulletins/AWS-2025-015/"><u>launch a supply chain attack</u></a> against users of the Amazon Q VS Code extension. This growing trend underscores the urgent need for organizations to harden their CI/CD pipelines.</p><figure><div aria-owns="rmiz-modal-" data-rmiz=""><div data-rmiz-content="not-found"></div></div></figure><p>While no immediate action is required by downstream consumers of the affected AWS GitHub repositories, we strongly recommend all AWS CodeBuild users implement the following safeguards to protect their own projects against similar issues.</p><ul><li><p><strong>Prevent Untrusted Pull Requests from Triggering Privileged Builds:</strong></p><ul><li><p>Enable the new <a target="_blank" href="https://docs.aws.amazon.com/codebuild/latest/userguide/pull-request-build-policy.html"><u>Pull Request Comment Approval</u></a> build gate.</p></li><li><p>Alternatively, use <a target="_blank" href="https://docs.aws.amazon.com/codebuild/latest/userguide/action-runner.html"><u>CodeBuild-hosted runners</u></a> to manage build triggers via GitHub workflows.</p></li><li><p>If you must rely on <a target="_blank" href="https://docs.aws.amazon.com/codebuild/latest/userguide/webhooks.html"><u>webhook filters</u></a>, ensure their regex patterns are anchored.</p></li></ul></li><li><p><strong>Secure the CodeBuild-GitHub Connection</strong></p><ul><li><p>Generate a <strong>unique, fine-grained Personal Access Token (PAT)</strong> for each CodeBuild project.</p></li><li><p>Strictly limit the PAT&#39;s permissions to the <strong>minimum</strong> required, as listed <a target="_blank" href="https://docs.aws.amazon.com/codebuild/latest/userguide/access-tokens-github.html"><u>here</u></a>.</p></li><li><p>Consider using a dedicated unprivileged GitHub account for the CodeBuild integration.</p></li></ul></li></ul><h2><a id="find-vulnerable-codebuild-projects-with-wiz-9"></a>Find Vulnerable CodeBuild Projects with Wiz</h2><p>Wiz customers can find CodeBuild projects that trigger builds based on untrusted pull requests using this pre-built query in the <a href="https://app.wiz.io/boards/threat-center/wiz-adv-2026-002">Wiz Threat Intel Center</a>.</p><figure><div aria-owns="rmiz-modal-" data-rmiz=""><div data-rmiz-content="not-found"></div></div></figure><p>Our investigation into AWS CodeBuild was sparked by the attempted <a target="_blank" href="https://aws.amazon.com/security/security-bulletins/AWS-2025-015/"><u>supply-chain attack</u></a> on the Amazon Q VS Code extension. In that incident, an attacker exploited a misconfigured CodeBuild project to compromise the extension’s GitHub repository and inject malicious code into the main branch. This code was then included in a release which users downloaded. Although the attacker’s payload ultimately failed due to a typo, it did execute on end users’ machines - clearly demonstrating the risk of misconfigured CodeBuild pipelines.</p><p>CodeBuild is a managed CI service that’s commonly connected to GitHub repositories, triggering builds on events like new pull requests. To interact with GitHub, CodeBuild requires <strong>GitHub credentials</strong>, which are, by default, present in the memory of the build environment. This creates a critical risk: if an attacker can compromise a single build, they are just a memory dump away from stealing credentials that often possess powerful permissions over the source repository.</p><h2><a id="to-build-or-not-to-build-the-pull-request-problem-15"></a>To Build or Not To Build: The Pull Request Problem </h2><p>The most common way to compromise a CI build is through a pull request. An attacker forks the target repository, adds malicious code, and then opens a PR against the original project. If CodeBuild is configured to spawn builds on PR events, it will trigger a build based on the attacker&#39;s branch. In the vast majority of build systems like make or yarn, controlling the source code of a build process is enough to run arbitrary code. This is the exact mechanism the attacker exploited to compromise the Amazon Q extension.</p><figure><div aria-owns="rmiz-modal-" data-rmiz=""><div data-rmiz-content="not-found"></div></div></figure><p>To prevent this attack scenario, CodeBuild offers <a target="_blank" href="https://docs.aws.amazon.com/codebuild/latest/userguide/github-webhook.html"><u><strong>webhook filters</strong></u></a> - a set of rules that an event must meet to trigger a build. Back in August, these filters were the primary defense against untrusted pull requests. Among the available options, the go-to solution was the <strong>ACTOR_ID</strong> filter: an allow-list of approved GitHub user IDs that ensures only trusted users can trigger a build.</p><p>This seemed like a robust defense, but maintaining a list of user IDs can be cumbersome. We wondered: were organizations actually using this filter correctly?</p><p>To find out, we decided to search for GitHub repositories connected to <a target="_blank" href="https://docs.aws.amazon.com/codebuild/latest/userguide/public-builds.html"><u><strong>Public CodeBuild projects</strong></u></a>. When set to public, CodeBuild projects expose their settings via a publicly accessible dashboard and automatically link to it in the status of any commit that triggers a build. From the dashboard, anyone can view the project&#39;s build logs and configurations - including the exact webhook filters being used.</p><figure><div aria-owns="rmiz-modal-" data-rmiz=""><div data-rmiz-content="not-found"></div></div></figure><h2><a id="an-apparent-dead-end-22"></a>An Apparent Dead End</h2><p>Our initial scan was promising. We quickly found seven AWS-owned repositories with public CodeBuild pages. Of those, four were active and configured to run builds on pull requests:</p><ul><li><p>The AWS SDK for JavaScript (<code>aws/aws-sdk-js-v3</code>)</p></li><li><p>AWS Libcrypto (<code>aws/aws-lc</code>)</p></li><li><p>Amazon Corretto Crypto Provider (<code>corretto/amazon-corretto-crypto-provider</code>)</p></li><li><p>The Registry of Open Data on AWS (<code>awslabs/open-data-registry</code>)</p></li></ul><p>At first glance, everything seemed secure. All four projects implemented an <code>ACTOR_ID</code> filter, locking down builds to a list of approved maintainers. It appeared to be a dead end.</p><figure><div aria-owns="rmiz-modal-" data-rmiz=""><div data-rmiz-content="not-found"></div></div></figure><p>But the filter&#39;s syntax, shown above, was unusual for a typical ID list. The user IDs weren’t separated by commas or spaces, but by a pipe <strong>|</strong> character. That small detail was the key: in regular expressions, the <strong>|</strong> character means &#34;OR&#34;. Reviewing the documentation confirmed it: the filter wasn&#39;t a simple list, <strong>it was a regex pattern</strong>. And it had a fatal flaw.</p><p>The issue was simple but critical: <strong>the regex patterns weren’t anchored</strong>. Without the start <code>^</code> and end <code>$</code> anchors to require an exact match, a regex engine doesn&#39;t look for a string that perfectly matches the pattern, but one that merely <em>contains</em> it. This meant that any GitHub user ID that is a superstring of an approved ID could bypass the filter.</p><p>This was a powerful primitive in theory, but its success depended on a practical question: is it possible to register a brand-new GitHub user ID that contained the ID of an existing user?</p><h2><a id="when-ids-align-31"></a>When IDs Align</h2><p>The answer is yes, and it hinges on how GitHub assigns IDs. Every user is given a unique and <strong>sequential numeric ID</strong>. Early accounts from 2008 have 5-digit IDs, while accounts from recent years ballooned to 9-digit IDs. As this sequence of numbers grows, it&#39;s inevitable that shorter, older IDs appear as substrings within longer, newer ones.</p><p>Based on our tests, GitHub creates roughly <strong>200,000</strong> new IDs each day. At that rate, for any given 6-digit maintainer ID, a new, longer ID containing it would become available for registration approximately <strong>every five days</strong>. </p><p>We dubbed this recurring window of opportunity an <strong>&#34;eclipse&#34; </strong>-- the moment a new, longer ID perfectly &#34;shadowed&#34; a trusted maintainer&#39;s ID.</p><figure><div aria-owns="rmiz-modal-" data-rmiz=""><div data-rmiz-content="not-found"></div></div></figure><p>All four AWS repositories had short maintainer IDs only 6 or 7 digits long, resulting in frequent eclipses that made them all valid targets. </p><h2><a id="catching-an-eclipse-winning-the-race-for-a-target-id-37"></a>Catching an Eclipse: Winning the Race for a Target ID</h2><p>Having confirmed that a new GitHub ID could contain a maintainer&#39;s ID, the challenge became operational: how could we claim a specific ID the instant it became available? This was practically a race condition against the entire world, with roughly two new GitHub users created every second. We needed a way to create a lot of GitHub users at once.</p><p>The standard user sign-up flow is protected by reCAPTCHA, making automated account creation impossible. We needed a different approach.</p><h3><a id="attempt-1-organizations-for-id-sampling-40"></a>Attempt #1: Organizations for ID Sampling</h3><p>Our first thought was to use the GitHub Enterprise API to create organizations, which share the same ID pool as users. While this could allow us to claim the target ID, GH organization accounts can&#39;t open pull requests, making them useless for the final exploit. It wasn&#39;t a total dead end though. We repurposed this API into an <strong>ID sampling tool</strong>: we could create an organization, check its ID to see how close we were to the target ID, and then immediately delete it.</p><h3><a id="the-breakthrough-the-github-app-manifest-flow-42"></a>The Breakthrough: The GitHub App Manifest Flow</h3><p>The real breakthrough came from <a target="_blank" href="https://docs.github.com/en/apps/overview"><u>GitHub Apps</u></a>. Creating an app generates a corresponding bot user (e.g. app-name[bot]) that <em>can</em> interact with pull requests. It’s also possible to automate app creation via the <a target="_blank" href="https://docs.github.com/en/apps/sharing-github-apps/registering-a-github-app-from-a-manifest"><u>manifest flow</u></a>. While it’s composed of a few steps, it can be made <strong>atomic</strong>: the app and its bot are only created when a final confirmation URL is visited. </p><p>This allowed us to prepare hundreds of app creation requests in advance and then, at the precise moment, visit all their confirmation URLs simultaneously. </p><p>With our strategy in place, it was time to execute. We routinely used the organization-creation API to sample the current GitHub ID, allowing us to accurately predict the moment of the eclipse. We also initiated the manifest flow for 200 new GitHub Apps, collecting their unique confirmation URLs. </p><p>We waited until the live ID count was just ~100 IDs away from the target ID, and then visited all 200 URLs at once, triggering a flood of new bot user registrations. The target ID was 226755743, which contained a trusted maintainer ID for the <code>aws/aws-sdk-js-v3 </code>repository.</p><p>After the registrations completed, a quick check confirmed our success:</p><figure><div aria-owns="rmiz-modal-" data-rmiz=""><div data-rmiz-content="not-found"></div></div></figure><p>We’d captured a user ID that could bypass the <code>ACTOR_ID </code>filter, and the method was reliable enough to be successfully repeated for each of the four target repositories.</p><p>With our bot user able to bypass the ACTOR_ID filter, we were ready to execute the proof-of-concept. We chose to target the <code>aws/aws-sdk-js-v3 </code>repository, preparing a pull request that fixes a legitimate issue. Buried within the PR was the real payload: a new NPM package dependency designed to execute in the build environment and extract the GitHub credentials.</p><p>We submitted the <a target="_blank" href="https://github.com/aws/aws-sdk-js-v3/pull/7280"><u>PR</u></a>, and soon after received a notification: <strong>a build had been triggered</strong>. Moments later, <strong>we had successfully obtained the GitHub credentials of the </strong><code><strong>aws-sdk-js-v3</strong></code><strong> CodeBuild project. </strong></p><p><em>(If you&#39;re up for a challenge, try to find the commit in the PR that triggered the build.)</em></p><p>Our payload retrieved the GH token by dumping the memory of a process within the build environment. A <a target="_blank" href="https://aws.amazon.com/security/security-bulletins/aws-2025-016/"><u>previous memory dump mitigation</u></a> in CodeBuild, which AWS implemented in response to the Amazon Q incident, overlooked this particular process. Following our disclosure, CodeBuild now protects this process as well. While this is a welcomed improvement, it isn’t bulletproof. GitHub credentials still reside in the build’s memory, and attackers with Linux privilege escalation exploits can circumvent memory protections. That’s why the most robust mitigation is using build gates to prevent untrusted builds from running in the first place.</p><h2><a id="the-blast-radius-55"></a>The Blast Radius </h2><p>The credentials we obtained were a GitHub Classic Personal Access Token (PAT) belonging to the <code>aws-sdk-js-automation</code> user. For an attacker, this was the perfect user to compromise, as it regularly interacts with the repository and releases new versions to GitHub:</p><figure><div aria-owns="rmiz-modal-" data-rmiz=""><div data-rmiz-content="not-found"></div></div></figure><p>We quickly confirmed that the <code>aws-sdk-js-automation </code>user had <strong>full admin privileges</strong> over the repository. Initially though, our access was scoped by the token&#39;s permissions: <code>repo</code> and <code>admin:repo_hook</code>. To escalate privileges, we abused the token’s <code>repo</code> scope, which can manage repository collaborators, and invited our own GitHub user to be a repository administrator.</p><figure><div aria-owns="rmiz-modal-" data-rmiz=""><div data-rmiz-content="not-found"></div></div></figure><p>As administrators, we could now push code directly to the main branch, approve any pull request, and exfiltrate repository secrets.</p><figure><div aria-owns="rmiz-modal-" data-rmiz=""><div data-rmiz-content="not-found"></div></div></figure><p>This level of control provided a clear path for supply chain attacks. The JavaScript SDK is released on a weekly basis to GitHub and then to NPM. Abusing this frequent release schedule, attackers could have injected malicious payloads right before a release was published, compromising it. Just a <a target="_blank" href="https://www.csoonline.com/article/4027963/hacker-inserts-destructive-code-in-amazon-q-as-update-goes-live.html"><u>month prior</u></a>, a threat actor using this exact method successfully infected downstream users of the Amazon Q VS Code extension. </p><p>While the Amazon Q incident was serious, the potential impact here was exponentially greater. <strong> Based on our analysis, a staggering 66% of cloud environments include the JavaScript SDK</strong> - meaning two out of every three environments host an instance with the SDK installed.<strong> </strong>It’s an exceptionally prominent software library, and among its users is perhaps the cloud’s most critical application: <strong>The AWS Console itself</strong>. Moreover, the Console bundles recent SDK versions; the image below shows a request from the console which includes user credentials and uses an SDK version released just 18 days prior:</p><figure><div aria-owns="rmiz-modal-" data-rmiz=""><div data-rmiz-content="not-found"></div></div></figure><p>Beyond the <code>aws-sdk-js-v3 </code>repository, the token we obtained had <strong>full admin privileges </strong>over several other repositories related to the JavaScript SDK. Among them were <strong>three private repositories</strong>, including what appeared to be AWS’s private mirrors of the JavaScript SDK. At this point though, given the demonstrated takeover and its potential impact, we halted further research and immediately reported the issues to AWS.</p><p>Crucially, this vulnerability extended beyond the SDK.<strong> </strong>While we only performed the CI takeover on the <code>aws-sdk-js-v3</code> repository, the same <code>ACTOR_ID </code>filter bypass was present in at least three other AWS GitHub repositories. Threat actors could have exploited these to compromise the GH credentials for three additional GH accounts. Two were automation accounts like <code>aws-sdk-js-automation</code>, but one was <strong>a personal GitHub account of an AWS employee</strong>.</p><p>This vulnerability is a textbook example of why adversaries target CI/CD environments: a subtle, easily overlooked flaw that can be exploited for massive impact. We&#39;ve seen this exact pattern in the recent <a target="_blank" href="https://www.wiz.io/blog/s1ngularity-supply-chain-attack"><u><strong>Nx S1ngularity</strong></u></a> and Amazon Q supply-chain attacks. </p><p>This trend is no accident. Attackers are increasingly drawn to CI/CD systems because they represent an ideal target:</p><ol><li><p>They’re<strong> complex</strong>, making them prone to subtle misconfigurations;</p></li><li><p>They <strong>handle untrusted data</strong>, often testing code from external contributors;</p></li><li><p>They’re <strong>highly privileged</strong>, requiring powerful credentials to access code, publish artifacts, and deploy to the cloud.</p></li></ol><p>This combination of complexity, untrusted data, and privileged credentials creates a perfect storm for high-impact breaches that require no prior access.</p><p>The success of recent attacks serves as a critical wake-up call. Adversaries have already shifted their focus to CI/CD pipelines, and defenders are trailing behind. Addressing this threat requires a joint effort: organizations need to reduce pipeline privileges and implement stricter build gates, and CI/CD platforms should make these secure baselines straightforward to adopt. For security teams, the first step is to enforce a simple yet powerful principle: <strong>untrusted contributions should never trigger privileged pipelines. </strong></p><blockquote><p>AWS investigated all reported concerns highlighted by Wiz’s research team in &#34;Infiltrating the AWS Console Supply Chain: Hijacking Core AWS GitHub Repositories via CodeBuild.&#34; In response, AWS took a number of steps to mitigate all issues discovered by Wiz, as well as additional steps and mitigations to protect against similar possible future issues. The core issue of actor ID bypass due to unanchored regexes for the identified repos was mitigated within 48 hours of first disclosure. Additional mitigations were implemented, including further protections of all build processes that contain Github tokens or any other credentials in memory. In addition, AWS audited all other public build environments to ensure that no such issues exist across the AWS open source estate. Finally, AWS audited the logs of all public build repositories as well as associated CloudTrail logs and determined that no other actor had taken advantage of the unanchored regex issue demonstrated by the Wiz research team. AWS determined there was no impact of the identified issue on the confidentiality or integrity of any customer environment or any AWS service.</p></blockquote><blockquote><p>We would like to thank Wiz’s research team for their work in identifying this issue and their responsible collaboration with us to ensure that our customers remain protected and secure.</p></blockquote><p><strong>August 25th, 2025</strong> – Wiz Research reports the actor ID bypass and repo takeover to AWS. </p><p><strong>August 25th, 2025</strong> – AWS and Wiz meet to review the findings and discuss mitigations.</p><p><strong>August 27th, 2025</strong> – AWS anchors the vulnerable actor ID filters and revokes the personal access token of <code>aws-sdk-js-automation</code>.</p><p><strong>September 2025</strong> – AWS implements additional hardening to prevent non-privileged builds from accessing the project’s credentials via memory dumping.</p><p><strong>January 15th, 2026</strong> – Public disclosure.</p><p>Hi there! We are Nir Ohfeld (<a target="_blank" href="https://x.com/nirohfeld"><u>@nirohfeld</u></a>), Sagi Tzadik (<a target="_blank" href="https://x.com/sagitz_"><u>@sagitz_</u></a>), Ronen Shustin (<a target="_blank" href="https://x.com/ronenshh"><u>@ronenshh</u></a>), Hillai Ben-Sasson (<a target="_blank" href="https://x.com/hillai"><u>@hillai</u></a>), and Yuval Avrahami (<a target="_blank" href="https://x.com/yuvalavra"><u>@yuvalavra</u></a>) from the Wiz Research Team (<a href="https://x.com/wiz_io"><u>@wiz_io</u></a>). We are a group of veteran white-hat hackers with a single goal: to make the cloud a safer place for everyone. We primarily focus on finding new attack vectors in the cloud and uncovering isolation issues in cloud vendors and service providers. We would love to hear from you! Feel free to contact us on X (Twitter) or via email: research@wiz.io. </p></div></div>
  </body>
</html>
