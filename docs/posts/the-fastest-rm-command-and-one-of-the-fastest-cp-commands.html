<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://alexsaveau.dev/blog/projects/performance/files/fuc/fast-unix-commands">Original</a>
    <h1>The fastest rm command and one of the fastest cp commands</h1>
    
    <div id="readability-page-1" class="page"><div><p><a href="https://github.com/SUPERCILEX/fuc">Fast Unix Commands</a> (FUC) is a project that aims to create the world‚Äôs fastest Unix commands. Currently, this means <code>rm</code> and <code>cp</code> replacements named <code>rmz</code> and <code>cpz</code> (the ‚Äòz‚Äô stands for ‚Äúzippy‚Äù). When better performance cannot be achieved, the next highest priority is efficiency. In practice, <code>rmz</code> appears to be the fastest file deleter available while <code>cpz</code> wins in most cases, only losing in flat directory hierarchies.</p><h2 id="myth-busting">Myth busting</h2><p>Many Stack Overflow answers will tell you to use this or that as a faster alternative to <code>rm</code> or <code>cp</code>. Let‚Äôs look at the <a href="https://github.com/SUPERCILEX/fuc/tree/master/comparisons">data</a>!</p><h3 id="rsync">Rsync</h3><p>Using <code>rsync</code> for copying is always slower than <code>cp</code> as far as I can tell. This should not come as a surprise given that it performs data integrity checks. Interestingly enough, <code>rsync</code> deletes very large directories faster than <code>rm</code>, but is slower in all other cases.</p><h3 id="find">Find</h3><p><code>find</code> and <code>rm</code> are approximately equivalent in terms of performance.</p><h3 id="tar">Tar</h3><p>Shockingly, collecting a directory into a tarball and then extracting it into a new directory to copy it is often faster than <code>cp</code>.</p><h2 id="technical-overview">Technical overview</h2><p>Both tools are built using the same scheduling algorithm, following similar principles to <a href="https://alexsaveau.dev/blog/ftzz-overview#scheduling-algorithm">FTZZ‚Äôs scheduler</a>. The key insight is that file operations in separate directories don‚Äôt (for the most part) interfere with each other, enabling parallel execution. Thus, the goal is to schedule one task per directory and execute each task in parallel.</p><p>Doing this for copies is relatively easy: iterate through every directory, spawn a new task when a directory is encountered and copy files in place. File removal is far more interesting because you cannot remove a directory until all of its children (including subdirectories) have been fully removed. As a consequence, file removal tasks must wait until their children have completed before finally removing the current directory. Unfortunately, this approach is slow: memory and time must be spent keeping track of child tasks, and children must somehow notify their parents of completion.</p><p>Flipping the problem on its head reveals a beautiful solution: what if children were in charge of deleting their parents? With a little bit of atomic reference counting, this solution is straightforward to implement and comes at almost no additional cost. While traversing directories, each spawned child directory task includes a parent (smart) pointer, implicitly creating a dynamic tree structure that models the directory hierarchy. These parent pointers are reference counted and trigger the directory deletion when fully freed. Additionally, each task decrements its reference count upon completion. That‚Äôs it! Now, regardless of whether a parent finishes after all of its children or vice versa, the last ‚Äúuser‚Äù of a directory will delete its directory chain.</p><p>Pseudocode might make this clearer:</p><div><div><pre><code><span>def</span> <span>delete_dir</span><span>(</span><span>node</span> <span>@</span> <span>Node</span> <span>{</span> <span>dir</span><span>,</span> <span>parent</span><span>,</span> <span>ref_count</span> <span>},</span> <span>task_queue</span><span>):</span>
    <span>for</span> <span>file</span> <span>in</span> <span>dir</span><span>:</span>
        <span>if</span> <span>file</span> <span>is</span> <span>dir</span><span>:</span>
            <span>ref_count</span><span>++</span>
            <span>task_queue</span><span>.</span><span>spawn</span><span>(</span><span>new</span> <span>Node</span> <span>{</span> <span>dir</span><span>:</span> <span>file</span><span>,</span> <span>parent</span><span>:</span> <span>node</span><span>,</span> <span>ref_count</span><span>:</span> <span>1</span> <span>})</span>
        <span>else</span><span>:</span>
            <span>file</span><span>.</span><span>delete</span><span>()</span>

    <span>ref_count</span><span>--</span>
    <span>while</span> <span>node</span><span>.</span><span>ref_count</span> <span>==</span> <span>0</span><span>:</span>
        <span>node</span><span>.</span><span>dir</span><span>.</span><span>delete</span><span>()</span>
        <span>node</span> <span>=</span> <span>node</span><span>.</span><span>parent</span>
        <span>node</span><span>.</span><span>ref_count</span><span>--</span>
</code></pre></div></div><hr/><p>Enjoy blazing fast copies and deletions! üöÄ</p></div></div>
  </body>
</html>
