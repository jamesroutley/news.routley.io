<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://observablehq.com/blog/observable-2-0">Original</a>
    <h1>Observable 2.0, a static site generator for data apps</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>Today we’re launching <a href="https://observablehq.com/product">Observable 2.0</a> with a bold new vision: an open-source static site generator for building fast, beautiful data apps, dashboards, and reports.</p><p>Our mission is to help teams communicate more effectively with data. Effective presentation of data is critical for deep insight, nuanced understanding, and informed decisions. Observable notebooks are great for ephemeral, <i>ad hoc</i> data exploration. But notebooks aren’t well-suited for polished dashboards and apps.</p><p>Enter <a href="https://observablehq.com/framework/">Observable Framework</a>.</p><div><figure><img src="https://images.ctfassets.net/uklh5xrq1p2j/26cJydaf6IQXGPmS7i13Gr/d4db342f8088003c3a4f004c13990940/1_-_Framework_Preview__1_.png" alt="Framework preview"/></figure></div><p>With Framework, you can build the best data apps your team has ever seen. Framework combines the power of <b>JavaScript on the front-end</b> for interactive graphics, with <b>any language on the back-end</b> for data preparation and analysis. SQL, Python, R, Rust, Go… you name it. It’s the polyglot programmer’s dream. Everything you need is at your fingertips: interactive charts and inputs, responsive grids, themes, dark mode, keyboard-friendly navigation, and more. And because it’s code, there’s no limit to customization!</p><p>Framework is free and <a href="https://github.com/observablehq/framework">open-source</a>. Projects are just local files. Use your favorite editor, preview locally, check it all into git, write unit tests, add CI/CD, even work offline. You can host projects anywhere or deploy instantly to Observable to share them securely with your team.</p><p>Observable Framework solves the “last mile” problem of data apps: loading data. Conventional dashboards are slow because they run queries on view while the user waits; Framework’s data loaders run <i>on build</i> so that pages load instantly. And because data loaders run on your servers, you control privacy and security.
If you’re ready to dive in, visit our <a href="https://observablehq.com/framework/getting-started">Getting started tutorial</a>, or open a terminal and run:
</p><p><span>    npm init @observablehq</span>
</p><p>If you’d like to hear more about why we built Framework, please read on.</p><h3>Beyond notebooks <b>📓</b></h3><p>This moment — Observable 2.0 — reflects lessons learned over many years.</p><p>We believe the lightweight, collaborative nature of computational notebooks makes them ideal for exploring data and answering <i>ad hoc</i> questions. We founded Observable in 2016, pioneering a <a href="https://medium.com/@mbostock/a-better-way-to-code-2b1d2876a3a0">reactive, web-first approach</a> to notebooks and seeking to make data visualization easier, more practicable, and more social. We dreamed that notebooks might be the “one ring to rule them all” — powering not just notes, but apps, dashboards, and reports.</p><p>Yet no single interface can excel at every task. As cool as reactive notebooks are, a notebook can’t compete with a custom web app in terms of user experience. Notebooks are constrained by:</p><ul><li><p>A single-column, narrow layout</p></li><li><p>Low visual information density</p></li><li><p>Always-visible editor chrome</p></li></ul><p>These same limitations make notebooks great for tinkering and learning — the code is always at your fingertips, adjacent to the output — but not so great for presentation. To fill that latter role, we need better data apps.</p><p>A good data app embodies an empirical perspective; it fosters a shared understanding. Whereas notebooks tend to be for individuals, data apps are more often for a team. And whereas notebooks tend to be transient byproducts of point-in-time exploration, data apps often sustain value over time as people return to see how things change.</p><p>The differences between notebooks and data apps extend to development. A notebook editor desires speed: jotting down thoughts, running a query, sketching a chart. A data app developer prioritizes correctness, performance, and maintainability: making careful, deliberate changes that others depend on, favoring code review and testing before publishing.</p><p>We had three goals in mind when we set out to reimagine data app development:</p><ol><li><p><b>A better developer workflow</b> — meeting the needs of developers</p></li><li><p><b>A better user experience</b> — the “proof is in the pudding”</p></li><li><p><b>A better data architecture</b> — solving the “last mile” problem</p></li></ol><div><figure><img src="https://images.ctfassets.net/uklh5xrq1p2j/5D9MHFW8goDgB7Fuczy9s4/28dec57555f601daaaee374d2d2c5347/2_-_Workflow.png" alt="Workflow"/></figure></div><h3>A better developer workflow <b>👩‍💻</b></h3><p>Modern development is built on <a href="https://stephango.com/file-over-app">files</a>. Files have myriad strengths, but the strongest is interoperability. When every tool uses files, it’s far easier to incorporate a new tool — and now Observable — into your workflow.</p><p>This isn’t just about using your preferred text editor. Now you can bring your own source control and code review system, too. You can write unit tests and run linters. You can automate builds with continuous integration or deployment. You can work offline. You can self-host. You can generate or edit content programmatically, say to format code or to find-and-replace across files.</p><p>As we break new ground with Observable Framework, we’re further improving interoperability by adopting vanilla JavaScript syntax. And we’re deprecating <span>require</span> in favor of modern ES <span>import</span>. These changes make Observable easier to learn, and to share code with other applications. (We’ll port these improvements back to Observable notebooks in the future.)</p><div><figure><a href="https://github.com/observablehq/framework/tree/main/examples"><img src="https://images.ctfassets.net/uklh5xrq1p2j/7EKYLd7vJn0TRcBoQZWRvV/d4976632216f1e072746e4910d827cc1/3_-_Examples.png" alt="Examples"/></a><figcaption></figcaption></figure></div><h3><b>A better user experience 😍</b></h3><p>A toolmaker can’t care only about the developer experience — what does the developer experience matter if the resulting app is not demonstrably better? The merit of a creative tool should be judged by the quality of its creations, not its process. Or: “the proof of the pudding is in the eating.”</p><p>We believe that well-designed tools help developers build more efficiently by focusing their efforts on high-value work. We favor opinionated tools, with defaults and conveniences that foster a good user experience. We nudge you into <a href="https://blog.codinghorror.com/falling-into-the-pit-of-success/">the pit of success</a>.</p><p>Framework’s lightweight Markdown syntax — with light and dark mode, thoughtful colors, responsive grids, and built-in navigation — gives you beautiful pages from the start. It’s highly customizable if you need it, but it’s quick to get started with batteries included.</p><p>Most importantly, Framework’s data architecture practically forces your app to be <i>fast</i> because data is precomputed. Performance is critical for dashboards: users don’t like to wait, and dashboards only create value if users look at them. Slow dashboards waste time. (And you certainly don’t want your database and dashboard falling over under load!)</p><div><figure><img src="https://images.ctfassets.net/uklh5xrq1p2j/6ATQajSu9ZLRVmgR0YIiYs/12f2da04080e37ef88f82f001c566107/4_-_Architecture.png" alt="Architecture"/></figure></div><h3>A better data architecture</h3><p>Every data visualization requires data. Obviously. But less obviously, each data visualization requires highly-specific data prepared with that visualization in mind. In fact, most of the work of visualization isn’t choosing visual encodings or laying out axes or visualizing <i>per se</i> — it’s preparing data. As I wrote <a href="https://observablehq.com/@mbostock/10-years-of-open-source-visualization">previously</a>,</p><div><figure><blockquote><p>working with data should be 80% of the work of visualization. Visualization is the end result of analysis — the visible manifestation of data, to be seen, shared, and appreciated by experts and non-experts alike — and as such it sometimes gets too much credit. To produce a visualization, one must first find data, clean it, transform, join, model, etc. Working with data is sometimes needlessly denigrated as “janitorial” when it represents the critical step of understanding the data as it is, warts and all.</p></blockquote></figure></div><p>Given how much work goes into preparing data, it follows that developers want</p><ul><li><p>to use any language (say Python or R or SQL),</p></li><li><p>to use any library (say NumPy or dplyr),</p></li><li><p>to use any data source (database, data warehouse, API, files, <i>etc</i>.), and</p></li><li><p>to crunch data ahead of time (offline)</p></li></ul><p>while still leveraging JavaScript in the browser for interactive graphics.</p><p>Framework’s data loaders solve this “last mile” problem by computing static data snapshots at build time. These snapshots can be highly-optimized (and aggregated and anonymized), minimizing the data you send to the client. And since a data loader is just a fancy way of generating a file on-demand (with clever caching and routing), loaders can be written in any language and use any library. This flexibility is not unlike <a href="https://en.wikipedia.org/wiki/Common_Gateway_Interface">CGI</a> from 30 years ago, and <a href="https://en.wikipedia.org/wiki/Pipeline_(Unix)">Unix pipes</a>. And since data loaders run on your servers, viewers don’t need direct access to the underlying data sources, and your dashboards are more secure and robust.</p><p>The speed of modern data warehouses is astonishing. But far too often something is missing for new analysis — some untapped data source, some not-yet-materialized view for a query to run at interactive speeds. Framework’s data loaders let you bypass these hurdles and produce a fast dashboard without “heavy lifting” in your data warehouse. And once your analysis demonstrates value, you can shift work to your data warehouse and simplify your data loaders. Framework lets you build faster and quickly validate your ideas.</p><p>We believe Framework will change how you think about data, and effect a better user experience. And by securely hosting apps alongside notebooks, Observable now offers an end-to-end solution for data analysis and presentation.</p><h3>Thank you <b>🙏</b></h3><p>We wouldn’t be here without the support, feedback, and encouragement from you — our community. Thank you for using Observable notebooks, Observable Plot, and D3. We’re thrilled to share Observable Framework with you now, and can’t wait to hear what you think.</p><p>To learn more about Framework, <a href="https://observablehq.com/framework/">read the docs</a>.</p><p>To share your questions or feedback, please <a href="https://talk.observablehq.com/latest">visit our forum</a>.
</p></div></div></div>
  </body>
</html>
