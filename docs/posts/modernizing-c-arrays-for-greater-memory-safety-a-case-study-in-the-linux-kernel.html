<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://people.kernel.org/kees/bounded-flexible-arrays-in-c">Original</a>
    <h1>Modernizing C arrays for greater memory safety: a case study in the Linux kernel</h1>
    
    <div id="readability-page-1" class="page"><div><h3 id="how-to-modernize-c-arrays-for-greater-memory-safety-a-case-study-in-refactoring-the-linux-kernel-and-a-look-to-the-future">How to modernize C arrays for greater memory safety: a case-study in refactoring the Linux kernel and a look to the future</h3>

<h2 id="kees-cook-mailto-kees-kernel-org"><a href="mailto:kees@kernel.org" rel="nofollow">Kees Cook</a></h2>

<h2 id="c-is-not-just-a-fancy-assembler-any-more">C is not just a fancy assembler any more</h2>

<p>Large projects written in C, especially those written close to the hardware layer like Linux, have long treated the language as a high-level assembler. Using C allowed for abstracting away much of the difficulty of writing directly in machine code while still providing easy low-level access to memory, registers, and CPU features. However, C has matured over the last <a href="https://en.wikipedia.org/wiki/C_%28programming_language%29#cite_note-dottcl_2-2" rel="nofollow">half century</a>, and many language features that improve robustness go unused in older codebases. This is especially true for arrays, where the historical <a href="https://cwe.mitre.org/data/definitions/129.html" rel="nofollow">lack of bounds checking</a> has been a consistent source of <a href="https://www.cvedetails.com/vulnerability-search.php?f=1&amp;product=Linux+Kernel&amp;cweid=129" rel="nofollow">security flaws</a>.</p>

<p>Converting such codebases to use “modern” language features, like those in <a href="https://en.wikipedia.org/wiki/Flexible_array_member" rel="nofollow">C99</a> (still from the prior millennium), can be a major challenge, but it is an entirely tractable problem. This post is a deep dive into an effort underway in the Linux kernel to make array index overflows (and more generally, buffer overflows) a thing of the <a href="https://git.kernel.org/linus/7f14c7227f342d9932f9b918893c8814f86d2a0d" rel="nofollow">past</a>, where they belong. Our success hinges on replacing anachronistic array definitions with well-defined C99 flexible arrays. This approach can be used by developers to refactor C code, making it possible to leverage <a href="https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc/Instrumentation-Options.html" rel="nofollow">21st century mitigations</a> (like <code>-fsanitize=bounds</code> and <code>FORTIFY_SOURCE</code>), since such things can finally be cleanly applied to the modernized codebase.</p>

<h2 id="the-fraught-history-of-arrays-in-c">The fraught history of arrays in C</h2>

<p>For the compiler to successfully apply array index bounds checking, array sizes must be defined unambiguously, which is not always easy in C. Depending on the array definition, bounds checking falls roughly into three categories: fixed-sized arrays, dynamically-sized arrays, and pointer offsets. Each category of array definitions must be made unambiguous before the next, as they mostly build on top of each other.  For example, if the compiler cannot protect a fixed-sized array, it certainly cannot protect a dynamically-sized array, and array indexing is just a specialized case of calculating a memory pointer offset.</p>

<p>Properly defined dynamically-sized arrays were introduced in C99 (<code>int foo[]</code>), and called “flexible arrays”. Before that, many C projects used the GNU extension of zero-length arrays (<code>int foo[0]</code>), which is not recognized by the C standard. This was done because, before the GNU extension, C projects would use single-element arrays (<code>int foo[1]</code>) which had several frustrating characteristics. (Using <code>sizeof()</code> on such a structure would include a single element as well, which would require additional handling to get allocation sizes to be accurate. This is not a problem for zero-element or true flexible arrays.)</p>

<p>However, due to yet more historical situations (e.g. <a href="https://www.gnu.org/software/libc/manual/html_node/Address-Formats.html#index-struct-sockaddr" rel="nofollow">struct sockaddr</a>, which has a fixed-size trailing array that is <em>not</em> supposed to actually be treated as fixed-size), GCC and Clang actually treat <em>all</em> trailing arrays as flexible arrays. This behavior makes things even more problematic, since it becomes impossible to limit a flexible array heuristic to only 1-element or 0-element (i.e. zero-length) arrays. For example, a compiler can&#39;t tell the intent of variable&#39;s use here:</p>

<pre><code>struct obj {
        ...
        unsigned char bytes;
        int variable[4];
};
</code></pre>

<p>Is it actually a 4 element array, or is it sized by the bytes member? As such, compilers have had to assume that trailing arrays must be intended to be dynamically sized (even though most are intended to be fixed-size).</p>

<p>To clear the way for sensible protection of fixed-size arrays, and to have a common framework for handling dynamically-sized arrays, Linux must have all the “fake” flexible array members replaced with <em>actual</em> C99 flexible array members so that the programmer&#39;s intent can actually be represented in an unambiguous way. With this done, <a href="https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc/Warning-Options.html#index-Warray-bounds" rel="nofollow"><code>-Warray-bounds</code></a> (and similar things like <a href="https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc/Object-Size-Checking.html#index-_005f_005fbuiltin_005fobject_005fsize-1" rel="nofollow"><code>__builtin_object_size()</code></a>) will catch compile-time problems, and <a href="https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc/Instrumentation-Options.html#index-fsanitize_003dbounds" rel="nofollow"><code>-fsanitize=bounds</code></a> (and similar things like <a href="https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc/Object-Size-Checking.html#index-_005f_005fbuiltin_005fdynamic_005fobject_005fsize-1" rel="nofollow"><code>__builtin_dynamic_object_size()</code></a>) can catch run-time problems.</p>

<p>Once fixed-sized arrays are protected, dynamically sized arrays can be protected as well, though this requires introducing a way to annotate structures that contain flexible arrays. Nearly all such structs also contain the count of allocated elements present in the flexible array:</p>

<pre><code>struct obj {
        ...
        unsigned short count;
        struct foo items[]; /* Has &#34;count&#34; many &#34;struct foo&#34;s */
} *ptr;
</code></pre>

<p>Such structs therefore fully describe their contents at runtime (and are called “flexible array structures” from here on). In other words, their size can be determined at run-time as:</p>

<pre><code>sizeof(*ptr) + sizeof(*ptr-&gt;items) * ptr-&gt;count
</code></pre>

<p>Teaching the compiler which struct member is associated with the count of a given flexible array member will allow <code>-fsanitize=bounds</code> and <code>__builtin_dynamic_object_size()</code> to reason about flexible array structure usage as well, covering all arrays in Linux with “known bounds”.</p>

<p>(Not covered here is the closely related work to tighten the <code>FORTIFY_SOURCE</code> <a href="https://outflux.net/slides/2022/lss-na/" rel="nofollow">implementation</a> for the <code>memcpy()</code>-family of functions which also depends on making flexible array sizes unambiguous.)</p>



<p>Compile-time diagnostics about the size of arrays use either internal value range checking or things similar to the <code>FORTIFY_SOURCE</code> macros (which use <code>__builtin_object_size()</code> for their implementations). This works well for arrays not at the end of the structure, but gets disabled for trailing arrays since the compiler must treat trailing arrays as flexible arrays (see struct sockaddr above). And for everything treated as a flexible array (i.e. dynamically sized), the compiler cannot know the array length at compile time, since it will be only known at runtime. To make such array declarations unambiguous (and therefore able to gain sane runtime bounds checking), compilers must gain an option to disable all “fake” flexible array heuristics, and treat only <em>true</em> flexible arrays as flexible arrays.</p>

<p>The creation of <code>-fstrict-flex-arrays</code> is now available in recent GCC and Clang builds, but any project using it will need to replace all fake flexible arrays with true flexible arrays first (to separate them from any fixed-size trailing arrays). This comes with several challenges.</p>

<h3 id="replace-0-length-arrays">Replace 0-length arrays</h3>

<p>Most replacement of 0-length arrays with flexible arrays requires no special handling. Simply removing the “0” in the array declaration is sufficient. For example,</p>

<pre><code>struct obj {
        ...
        int flex[0];
};
</code></pre>

<p>becomes:</p>

<pre><code>struct obj {
        ...
        int flex[];

};
</code></pre>

<p>However, there are a few things of note that can go wrong with these conversions:</p>

<h4 id="changes-to-sizeof">Changes to <code>sizeof()</code></h4>

<p>While <code>sizeof(instance-&gt;flex)</code> for a 0-length array returns 0, it becomes a compile-time failure once it becomes a true flexible array. This usually manifests within other complex macros that are examining the details of a given struct, and are usually hidden bugs that switching to a flexible array helps expose.</p>

<h4 id="pass-by-value">Pass by value</h4>

<p>Converting to a true flexible array will expose any strange cases of trying to pass a flexible array struct by value. These are almost always a bug, so it&#39;s another case where a problem is exposed by cleaning up fake flexible arrays. For <a href="https://lore.kernel.org/lkml/CAHk-=wiwRtpyMVn1F9KT14H64tajiWsPnd0FfL5-BFnPOuFa_w@mail.gmail.com/" rel="nofollow">example</a>:</p>

<pre><code>net/core/flow_dissector.c: In function &#39;is_pppoe_ses_hdr_valid&#39;:
net/core/flow_dissector.c:898:13: note: the ABI of passing struct with a flexible array member has changed in GCC 4.4

898 | static bool is_pppoe_ses_hdr_valid(struct pppoe_hdr hdr)
    |                                   ^~~~~~~~~~~~~~~~~~~~~~
</code></pre>

<h4 id="flexible-arrays-in-unions">Flexible arrays in unions</h4>

<p>C99 6.7.2.1 “Structure and union specifiers” #16 declares true flexible arrays may not be in unions nor otherwise empty structures: “As a special case, the last element of a structure with more than one named member may have an incomplete array type; this is called a flexible array member.”</p>

<p>However, this situation <em>is</em> allowed by the GNU “trailing array” extension, where such arrays are treated as flexible arrays. More importantly, flexible arrays (via the GNU extension) are used in unions in many places throughout Linux code. The C99 treatment of true flexible arrays appears to be only a definitional limitation (and likely just an oversight) since the restriction can be worked around with creative use of anonymous structs. For example, <a href="https://godbolt.org/z/T394GPndf" rel="nofollow">this</a> will build:</p>

<pre><code>struct obj {
        ...
        union {
                struct foo name1[0];
                struct bar name2[0];
        };
};
</code></pre>

<p>but <a href="https://godbolt.org/z/Grx4Msbq1" rel="nofollow">this</a> will not:</p>

<pre><code>struct obj {
        ...
        union {
                struct foo name1[];
                struct bar name2[];
        };
};
</code></pre>

<pre><code>&lt;source&gt;:5:22: error: flexible array member in union
  5 | struct foo name1[];
    |            ^~~~~
</code></pre>

<p>But in both cases, the compiler treats name1 and name2 as flexible arrays. What will <a href="https://godbolt.org/z/GeYjGsKjj" rel="nofollow">happily compile</a>, though, is wrapping true flexible arrays in a struct that has at least 1 other non-true-flexible array, including an empty anonymous struct (i.e. taking up no size):</p>

<pre><code>struct obj {
        ...
        union {
                struct {
                        struct { } __unused_member1;
                        struct foo name1[];
                };
                struct {
                        struct { } __unused_member2;
                        struct bar name2[];
                };
        };
};
</code></pre>

<p>Thankfully, this was wrapped in Linux with the <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/uapi/linux/stddef.h?h=v6.1#n32" rel="nofollow"><code>DECLARE_FLEX_ARRAY()</code></a> macro:</p>

<pre><code>struct obj {
        ...
        union {
                DECLARE_FLEX_ARRAY(struct foo, name1);
                DECLARE_FLEX_ARRAY(struct bar, name2);
        };
};
</code></pre>

<p>which makes this much more readable. I hope to see future C standards eliminate this restriction.</p>

<h4 id="overlapping-composite-structure-members">Overlapping composite structure members</h4>

<p>This is another case of a real bug being exposed by true flexible array usage, as it is possible to create an implicit union of a flexible array and something else by including a flexible array structure in another struct. For <a href="https://lore.kernel.org/lkml/202206281009.4332AA33@keescook/" rel="nofollow">example</a>:</p>

<pre><code>struct inner {
        ...
        int flex[0];
};

struct outer {
        ...
        struct inner header;
        int overlap;
        ...
} *instance;
</code></pre>

<p>Here, <code>instance-&gt;overlap</code> and <code>instance-&gt;header.flex[0]</code> share the same memory location. Whether or not this is <em>intentional</em> cannot be understood by the compiler. If it is a bug, then using a true flexible array will trigger a warning. If it&#39;s not a bug, rearranging the structures to use an actual union is needed (see above).</p>

<h4 id="struct-definition-parsed-by-something-other-than-a-c-compiler">struct definition parsed by something other than a C compiler</h4>

<p>If the converted struct is part of a source file that is parsed by something that is not a C compiler, it may not be prepared to handle empty square braces on arrays. For example, <a href="https://www.spinics.net/lists/fedora-devel/msg297996.html" rel="nofollow">SWIG broke</a> when the Linux Userspace API headers got converted.</p>

<h3 id="replace-1-element-arrays">Replace 1-element arrays</h3>

<p>Most 1-element array conversions are similar to 0-length array conversions, but with the effect that the surrounding structure&#39;s <code>sizeof()</code> changes. This leads to a few additional significant issues:</p>

<h4 id="size-calculations">Size calculations</h4>

<p>If a struct is used entirely internally to Linux, it is generally sufficient to make changes to both the struct and all size calculations, which will result in identical binary output. For example:</p>

<pre><code>struct object {
        ...
        int flex[1];
} *p;

p = kmalloc(sizeof(*p) + sizeof(p-&gt;flex[0]) * (count - 1)),
            GFP_KERNEL);
</code></pre>

<p>the above <code>count - 1</code> becomes just <code>count</code> now:</p>

<pre><code>struct object {
        ...
        int flex[];
} *p;

p = kmalloc(sizeof(*p) + sizeof(p-&gt;flex[0]) * count),
            GFP_KERNEL);
</code></pre>

<p>If all size calculations are correctly adjusted, there should be no differences in the resulting allocation size, etc. If a discrepancy is found, it is going to be either a bug introduced by the conversion, or the discovery of an existing bug in the original size calculations.</p>

<p>Note that depending on the sizes of the structure, its flexible array element, and count, there is also the risk associated with arithmetic overflow. Linux uses the <code>struct_size()</code> macro to perform these calculations so that the result saturates to at most <code>SIZE_MAX</code>, which will cause an allocation failure rather than wrapping around. So the best way to perform this allocation would be:</p>

<pre><code>p = kmalloc(struct_size(p, flex, count), GFP_KERNEL);
</code></pre>

<h4 id="padding-and-interface-sizes">Padding and interface sizes</h4>

<p>When a structure definition is also used by a codebase we don&#39;t control (e.g. firmware, userspace, virtualization), changing its layout or <code>sizeof()</code> may break such code. Specifically, it may break its ability to communicate correctly with the kernel across the shared interface. Such structures cannot suddenly lose the single element of its trailing array. In these cases, a new member needs to be used for kernel code, explicitly keeping the original member for backward compatibility. For example:</p>

<pre><code>struct object {
        ...
        int flex[1];
};
</code></pre>

<p>becomes:</p>

<pre><code>struct object {
        ...
        union {
                int flex[1];
                DECLARE_FLEX_ARRAY(int, data);
        };
};
</code></pre>

<p>Now the kernel will only use the newly named data member (and gain any potential bounds checking protections from the compiler), and external code that shares this structure definition can continue to use the flex member, all without changing the size of the structure.</p>

<p>This has the downside of needing to change the member name throughout Linux. However, if the other side of the interface doesn&#39;t actually use the original member, we can avoid this. We can convert the member to a flexible array and add explicit padding instead. This would mean no collateral changes with the member name in Linux are needed:</p>

<pre><code>struct object {
        ...
        union {
                int __padding;
                DECLARE_FLEX_ARRAY(int, flex);
        };
};
</code></pre>

<h3 id="replace-multi-element-arrays">Replace multi-element arrays</h3>

<p>In the cases of trailing arrays with larger element counts, the usage needs to be even more carefully studied. Most problems end up looking very similar to 1-element interface conversions above. For example, if there is some hardware interface that returns at least 4 bytes for an otherwise dynamically sized array, the conversion would start from here:</p>

<pre><code>struct object {
        ...
        unsigned char data[4];
};
</code></pre>

<p>which becomes:</p>

<pre><code>struct object {
        ...
        union {
                unsigned char __padding[4];
                DECLARE_FLEX_ARRAY(unsigned char, data);
        };
};
</code></pre>

<h2 id="enable-warray-bounds">Enable <code>-Warray-bounds</code></h2>

<p>With all fixed-size array bounds able to be determined at build time, <code>-Warray-bounds</code> can actually perform the checking, keeping provably bad code out of Linux. (This option is already part of <code>-Wall</code>, which Linux isn&#39;t quite able to use itself yet, but is strongly recommended for other C projects.) As a reminder, optimization level will impact this option. The kernel is built with <code>-O2</code>, which is likely the right choice for most C projects.</p>

<h2 id="enable-wzero-length-array">Enable <code>-Wzero-length-array</code></h2>

<p>If all zero length arrays have been removed from the code, future uses can be kept out of the code by using <a href="https://clang.llvm.org/docs/DiagnosticsReference.html#wzero-length-array" rel="nofollow"><code>-Wzero-length-array</code></a>.  This option is currently <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=94428" rel="nofollow">only</a> available in Clang, and will warn when finding the <em>definition</em> of such structure members, rather than warning when they are <em>accessed</em> in code. Because of this, it is unlikely to ever be enabled in Linux since some array sizes are constructed from build configurations, and may drop to 0 when they are unused (i.e. they were never used as flexible arrays). As such, it is sufficient to use <code>-fstrict-flex-arrays</code> (see below) and <code>-Warray-bounds</code>.</p>

<h2 id="enable-fstrict-flex-arrays">Enable <code>-fstrict-flex-arrays</code></h2>

<p>Once all the fake flexible arrays have been converted to true flexible arrays, the remaining fixed-sized trailing arrays can start being treated as actually fixed-size by enabling <code>-fstrict-flex-arrays</code>. Future attempts to add fake flexible arrays to the code will then elicit warnings as part of the existing diagnostics from <code>-Warray-bounds</code>, since all fake flexible arrays are now treated as fixed-size arrays. (Note that this option sees the subset of 0-length arrays caught by <code>-Wzero-length-array</code> when they are actually <em>used</em> in the code, so <code>-Wzero-length-array</code> may be redundant.)</p>

<h2 id="coming-soon-annotate-bounds-of-flexible-arrays">Coming soon: annotate bounds of flexible arrays</h2>

<p>With flexible arrays now a first-class citizen in Linux and the compilers, it becomes possible to extend their available diagnostics.  What the compiler is missing is knowledge of how the length of a given flexible array is tracked. For well-described flexible array structs, this means associating the member holding the element count with the flexible array member. This idea is not new, though prior <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2660.pdf" rel="nofollow">implementation proposals</a> have wanted to make changes to the C language syntax. A simpler approach is the addition of struct member attributes, and is under discussion and early development by both the GCC and Clang developer communities.</p>

<h3 id="add-attribute-element-count-member">Add <code>__attribute__((__element_count__(member)))</code></h3>

<p>In order to annotate flexible arrays, a new attribute could be used to describe the relationship between struct members. For example:</p>

<pre><code>struct object {
        ...
        signed char items;
        ...
        int flex[];
} *p;
</code></pre>

<p>becomes:</p>

<pre><code>struct object {
        ...
        signed char items;
        ...
        int flex[] __attribute__((__element_count__(items)));
} *p;
</code></pre>

<p>This would allow <code>-fsanitize=bounds</code> to check for out-of-bounds accesses.  For example, given the above annotation, each of the marked access into <code>p-&gt;flex</code> should trap:</p>

<pre><code>sum += p-&gt;flex[-1];  // trap all negative indexes
sum += p-&gt;flex[128]; // trap when index larger than bounds type
sum += p-&gt;flex[0];   // trap when p-&gt;items &lt;= 0
sum += p-&gt;flex[5];   // trap when p-&gt;items &lt;= 5
sum += p-&gt;flex[idx]; // trap when p-&gt;items &lt;= idx || idx &lt; 0
</code></pre>

<p>The type associated with the bounds check (<code>signed char</code> in the example above) should perhaps be required to be an unsigned type, but Linux has so many counters implemented as <code>int</code> that it becomes an additional refactoring burden to change these to unsigned, especially since sometimes they are sneakily being used with negative values in some other part of the code. Better to leave them as-is (though perhaps emit a warning), and just add a negativity check at access time. Switching the counter to unsigned then potentially becomes a small performance improvement.</p>

<p>Similar to <code>-fsanitize=bounds</code> above, <code>__builtin_dynamic_object_size()</code> will perform the expected calculations with the items member as the basis for the resulting size (and where values less than 0 are considered to be 0 to avoid pathological calculations):</p>

<pre><code>p-&gt;items = 5;
assert(__builtin_dynamic_object_size(p, 1) ==
        sizeof(*p) + 5 * sizeof(*p-&gt;flex));
assert(__builtin_dynamic_object_size(p-&gt;flex, 1) ==
        5 * sizeof(*p-&gt;flex));
assert(__builtin_dynamic_object_size(&amp;p-&gt;flex[0], 1) ==
        sizeof(*p-&gt;flex));
assert(__builtin_dynamic_object_size(&amp;p-&gt;flex[2], 0) ==
        3 * sizeof(*p-&gt;flex));

p-&gt;items = -10;
assert(__builtin_dynamic_object_size(p, 0) == sizeof(*p));
assert(__builtin_dynamic_object_size(p, 1) == sizeof(*p));
assert(__builtin_dynamic_object_size(p-&gt;flex, 1) == 0);
assert(__builtin_dynamic_object_size(&amp;p-&gt;flex[2], 1) == 0);
</code></pre>

<p>Additional attributes may be needed if structures explicitly use byte counts rather than element counts.</p>

<h4 id="scope-considerations">Scope considerations</h4>

<p>Composite structures need to be able to define <code>__element_count__</code> across struct boundaries:</p>

<pre><code>struct object {
        ...
        char items;
        ...
        struct inner {
                ...
                int flex[] __attribute__((__element_count__(.items)));
        };
} *ptr;
</code></pre>

<p>This may mean passing <code>&amp;ptr-&gt;inner</code> to a function will lose the bounds knowledge, but it may be possible to automatically include a bounds argument as an invisible function argument, as any function able to understand the layout of <code>struct inner</code> must by definition have visibility into the definition of <code>struct object</code>. For example, with this:</p>

<pre><code>struct object instance;
...
func(&amp;instance.inner);
...
void func(struct inner *ptr) {
        ...
        ptr-&gt;flex[foo]; /* &#34;items&#34; is not scope */
        ...
}
</code></pre>

<p>The prototype could either be rejected due to lack of available scope, or could be automatically converted into passing the outer object pointer with an injected scope:</p>

<pre><code>void func(struct object *__ptr) {
        struct inner *ptr = &amp;__ptr-&gt;inner;
        ...
        ptr-&gt;flex[foo]; /* __ptr-&gt;items is in scope */
        ...
}
</code></pre>

<h3 id="annotate-kernel-flexible-array-structs">Annotate kernel flexible array structs</h3>

<p>With the compiler attribute available, all of Linux&#39;s flexible arrays can be updated to include the annotation, and <code>CONFIG_FORTIFY_SOURCE</code> can be expanded to use <code>__builtin_dynamic_object_size()</code>.</p>

<h3 id="replace-declare-flex-array-with-declare-bounded-array">Replace <code>DECLARE_FLEX_ARRAY</code> with <code>DECLARE_BOUNDED_ARRAY</code></h3>

<p>Most uses of <code>DECLARE_FLEX_ARRAY()</code> can be replaced with <code>DECLARE_BOUNDED_ARRAY()</code>, explicitly naming the expected flex array bounds member. For example, if we had:</p>

<pre><code>struct obj {
        ...
        int items;
        ...
        union {
                DECLARE_FLEX_ARRAY(struct foo, name1);
                DECLARE_FLEX_ARRAY(struct bar, name2);
        };
};
</code></pre>

<p>it would become:</p>

<pre><code>struct obj {
        ...
        int items;
        ...
        union {
                DECLARE_BOUNDED_ARRAY(struct foo, name1, items);
                DECLARE_BOUNDED_ARRAY(struct bar, name2, items);
        };
};
</code></pre>

<h3 id="add-manual-annotations">Add manual annotations</h3>

<p>Any flexible array structures not already using <code>DECLARE_BOUNDED_ARRAY()</code> can be annotated manually with the new attribute. For example, assuming the proposed <code>__attribute__((__element_count__(member)))</code> is wrapped in a macro named <code>__bounds()</code>:</p>

<pre><code>struct obj {
        ...
        int items;
        ...
        int flex[];
};
</code></pre>

<p>becomes:</p>

<pre><code>struct obj {
        ...
        int items;
        ...
        int flex[] __bounds(items);
};
</code></pre>

<h2 id="future-work-expand-attribute-beyond-arrays">Future work: expand attribute beyond arrays</h2>

<p>It will also be possible to use the new attribute on pointers and function arguments as well as flexible arrays. All the same details are available, though there would be the obvious differences for enclosing structure sizes, as the pointers are aimed (usually) outside the struct itself. Regardless, having it be possible to check offsets and inform <code>__builtin_dynamic_object_size()</code> would allow for several more places where runtime checking could be possible. For example, given this:</p>

<pre><code>struct object {
        ...
        unsigned char items;
        ...
        int *data __attribute__((__element_count__(items)));
        ...
} *p;
</code></pre>

<p>It should be possible to detect sizing information:</p>

<pre><code>p-&gt;items = 5;
assert(__builtin_dynamic_object_size(p-&gt;data, 1) ==
        5 * sizeof(*p-&gt;data));
assert(__builtin_dynamic_object_size(*p-&gt;data, 1) ==
        sizeof(*p-&gt;data));
assert(__builtin_dynamic_object_size(*p-&gt;data, 0) ==
        5 * sizeof(*p-&gt;data));
</code></pre>

<p>And it should be possible to trap on the following bad accesses:</p>

<pre><code>int *ptr = p-&gt;data;
sum += ptr[-1];  // trap all negative indexes
sum += ptr[500]; // trap when index larger than bounds type
sum += ptr[0];   // trap when p-&gt;items &lt;= 0
sum += ptr[5];   // trap when p-&gt;items &lt;= 5
ptr += 5;        // don&#39;t trap yet: allow ptr++ in a for loop
sum += *ptr;     // trap when p-&gt;items &lt;= 5
</code></pre>

<h2 id="a-safer-code-base">A safer code base</h2>

<p>A C codebase that has refactored all of its arrays into proper flexible arrays can now finally build by using:</p>

<pre><code>        -Warray-bounds
        -fstrict-flex-arrays
        -fsanitize=bounds
        -fsanitize-undefined-trap-on-error
        -D_FORTIFY_SOURCE=3
</code></pre>

<p>With this, the burdens of C array index bounds checking will have been shifted to the toolchain, and array index overflow flaw exploitation can be a thing of the past, reducing severity to a simple denial of service (assuming the traps aren&#39;t handled gracefully). For the next trick, new code can be written in a language that is <a href="https://security.googleblog.com/2022/12/memory-safe-languages-in-android-13.html" rel="nofollow">memory safe</a> to start with (e.g. Rust).</p>

<h2 id="acknowledgements">Acknowledgements</h2>

<p>Thanks to many people who gave me feedback on this post: Nick Desaulniers, Gustavo A. R. Silva, Bill Wendling, Qing Zhao, Kara Olive, Chris Palmer, Steven Rostedt, Allen Webb, Julien Voisin, Guenter Roeck, Evan Benn, Seth Jenkins, Alexander Potapenko, Ricardo Ribalda, and Kevin Chowski.</p>

<h2 id="discussion">Discussion</h2>

<p>Please join <a href="https://fosstodon.org/@kees/109740441782167956" rel="nofollow">this thread</a> with your thoughts, comments, and corrections. :)</p>
</div></div>
  </body>
</html>
