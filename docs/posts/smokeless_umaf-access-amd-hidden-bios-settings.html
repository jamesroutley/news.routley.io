<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/DavidS95/Smokeless_UMAF">Original</a>
    <h1>Smokeless_UMAF: Access AMD hidden BIOS settings</h1>
    
    <div id="readability-page-1" class="page"><article>
    

    <p><strong>Monday, April 24, 2023</strong></p>

    <p>A lot of programming languages allow variable shadowing in new scopes.
Early on, you learn that it can cause errors and can be confusing, but is situationally appropriate sometimes.</p>
<p>Something that&#39;s less commonly allowed is <em>redeclaring</em> variables to shadow them locally.
And when it is allowed, it&#39;s often considered bad practice and confusing.</p>
<p>You&#39;re allowed to do this in JavaScript:</p>
<pre><code><span>var </span><span>x </span><span>= </span><span>10</span><span>;
</span><span>var </span><span>x</span><span>;

</span><span>console</span><span>.</span><span>log</span><span>(x)</span><span>; </span><span>// prints 10
</span></code></pre>
<p>The newer <code>let</code> keyword disallows this.
The following code will <em>not</em> run:</p>
<pre><code><span>let </span><span>x </span><span>= </span><span>10</span><span>;
</span><span>let </span><span>x</span><span>; </span><span>// ERROR: Identifier &#39;x&#39; has already been declared
</span></code></pre>
<p>Running it produces the error message &#34;Identifier &#39;x&#39; has already been declared.&#34;</p>
<p>This is an understandable message, because why would you redeclare something that already exists?
The vast majority of the time it is a mistake and a typo, so it probably should be disallowed.
This is exactly the point that Nystrom makes in <a href="http://www.craftinginterpreters.com/local-variables.html">Crafting Interpreters</a>:</p>
<blockquote>
<p>At the top level, Lox allows redeclaring a variable with the same name as a previous declaration because that’s useful for the REPL. But inside a local scope, that’s a pretty weird thing to do. It’s likely to be a mistake, and many languages, including our own Lox, enshrine that assumption by making this an error.</p>
</blockquote>
<p>In a sidebar, he notes that Rust <em>does</em> allow this and idiomatic code relies on it.
If it&#39;s so problematic in other languages, why does Rust allow and even <em>encourage</em> it?</p>
<p>There are a few common cases that it makes clearer.
Here are a few that come to mind quickly, and there are probably many more.</p>
<ol>
<li>Making something immutable once you&#39;re done with it.</li>
<li>Unwrapping containers while retaining clear naming.</li>
<li>Changing types (dynamic typing vibe) while retaining clear naming.</li>
</ol>
<p>Let&#39;s look at immutability.
One thing you do somewhat often is create a list and put a few items into it.
Pretending that we don&#39;t have convenient macros like <code>vec!</code> to build these, we would have to leave it mutable, or make a helper function for the construction.
Instead, we can just... say it&#39;s not mutable anymore, basically:</p>
<pre><code><span>let mut</span><span> xs</span><span>: </span><span>Vec</span><span>&lt;</span><span>u32</span><span>&gt; </span><span>= </span><span>Vec</span><span>::</span><span>new()</span><span>;
</span><span>xs</span><span>.</span><span>push</span><span>(</span><span>1</span><span>)</span><span>;
</span><span>xs</span><span>.</span><span>push</span><span>(</span><span>2</span><span>)</span><span>;
</span><span>let</span><span> xs </span><span>=</span><span> xs</span><span>; </span><span>// no longer can be changed!

// a few lines later

</span><span>xs</span><span>.</span><span>push</span><span>(</span><span>10</span><span>)</span><span>; </span><span>// error!
</span></code></pre>
<p>Since we redeclared <code>xs</code> without <code>mut</code>, we now can detect if we try to mutate it later on.
You can do the same thing in the opposite direction, too, which is handy for temporary mutability.</p>
<p>This pattern is really nice because it lets you be explicit about whether or not something should <em>currently</em> be mutable while also retaining a lot of flexibility.
All the power, with a compiler that&#39;s watching your back.</p>
<p>Now onto the next example: Unwrapping things!
Which is also changing their types!
This is something you run into fairly often.
You&#39;ll get back data of one type, then need to transform it to another.</p>
<p>Let&#39;s look at an example involving parsing an integer.
You might have a (slightly simplified) function like this:</p>
<pre><code><span>use </span><span>std</span><span>::</span><span>str</span><span>::</span><span>FromStr</span><span>;
</span><span>pub fn </span><span>get_port</span><span>() </span><span>-&gt; </span><span>Result</span><span>&lt;</span><span>u16</span><span>, std</span><span>::</span><span>num</span><span>::</span><span>ParseIntError&gt; {
  </span><span>// this is a constant here but would probably come from
  // a command-line arg or an environment variable.
  </span><span>let</span><span> port</span><span>: </span><span>&amp;</span><span>str </span><span>= </span><span>&#34;8080&#34;</span><span>;
  </span><span>let</span><span> port</span><span>: </span><span>u16 </span><span>= </span><span>u16</span><span>::</span><span>from_str(port)</span><span>?</span><span>;
  </span><span>println!</span><span>(</span><span>&#34;Parsed port as </span><span>{port}</span><span>&#34;</span><span>)</span><span>;
  </span><span>Ok</span><span>(port)
}
</span></code></pre>
<p>As a matter of style, you could name each of them different things.
<code>port_str</code> just grates on my sensibilities, though.
And <code>parsed_port</code> for the converted one is really quite unpleasant, too, in my opinion.</p>
<p>It&#39;s opinion, it&#39;s style, but I think it&#39;s wonderful that Rust lets us do this and keep clear (to us) names.
Some people will disagree and say it&#39;s less clear.
That&#39;s fine, but it&#39;s also generally idiomatic in Rust to do this, and it&#39;s also situationally dependent.
Usually the redeclaration is close to the original declaration, which greatly aids in clarity.</p>
<p>The other thing that makes this particularly nice in Rust is the type system.
In JavaScript, the type system (or lack thereof) will not save you at <em>all</em> if you redeclare a variable and accidentally break code that expects it to still be the old type.
But with Rust, the type system will quite robustly make sure you&#39;re not messing up the types.
If you redeclare an integer and now a string has that name?
Great, as long as it compiles.</p>
<p>You get a lot of the vibe of dynamic typing, because you can change what type a particular name binds to.
But you don&#39;t have as much of the danger, since things won&#39;t <em>unexpectedly</em> change out from under you.
Flexibility <em>with</em> safety.
That&#39;s beautiful.</p>

  </article><p>
    If this post was enjoyable or useful for you, <strong>please share it!</strong>
    If you have comments, questions, or feedback, please email <a href="mailto:~ntietz/public-inbox@lists.sr.ht">my public inbox</a> or <a href="mailto:me@ntietz.com">my personal email</a>.
    To get new posts, please use my <a href="https://ntietz.com/atom.xml">RSS feed</a>.
  </p></div>
  </body>
</html>
