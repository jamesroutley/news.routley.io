<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://macwright.com/2025/12/08/module-specifiers-and-protocols.html">Original</a>
    <h1>A brief history of specifiers and protocols</h1>
    
    <div id="readability-page-1" class="page"><div><p>If you‚Äôre running JavaScript on a server, how do you import a module? Traditionally, imports looked like this, with <a href="https://nodejs.org/api/modules.html#modules-commonjs-modules">CommonJS</a>:</p><div><div><pre><code><span>const</span> <span>axios</span> <span>=</span> <span>require</span><span>(</span><span>&#39;</span><span>axios</span><span>&#39;</span><span>);</span>
</code></pre></div></div><p>But now they look like this with <a href="https://nodejs.org/api/esm.html#modules-ecmascript-modules">ECMAScript Modules</a>:</p><div><div><pre><code><span>import</span> <span>axios</span> <span>from</span> <span>&#39;</span><span>axios</span><span>&#39;</span><span>;</span>
<span>// Or, less often, dynamically:</span>
<span>const</span> <span>axios</span> <span>=</span> <span>await</span> <span>import</span><span>(</span><span>&#39;</span><span>axios</span><span>&#39;</span><span>);</span>
</code></pre></div></div><p>However, there‚Äôs another layer of complexity: import <em>specifiers</em>.</p><h2 id="2021-nodejs-introduces-the-node-protocol">2021: Node.js introduces the <code>node:</code> protocol</h2><p>I think the first kind of specifier for a real runtime - and I‚Äôll be specific about that because the <a href="https://webpack.js.org/">Webpack</a> bundler supported a tremendous variety of import styles before this - was Node.js, in 2021 when they introduced the <a href="https://2ality.com/2021/12/node-protocol-imports.html">node:</a> protocol.</p><p>Before the <code>node:</code> protocol was introduced, in Node.js you‚Äôd import the OS library like this, by importing a module called <code>os</code>:</p><p>After they introduced the <code>node:</code> protocol, you‚Äôd do this:</p><div><div><pre><code><span>import</span> <span>os</span> <span>from</span> <span>&#39;</span><span>node:os</span><span>&#39;</span><span>;</span>
</code></pre></div></div><p>This has some benefits:</p><p>NPM modules can‚Äôt contain the <code>:</code> character, so there can‚Äôt be overlap between these <code>node:</code> modules and userspace modules from NPM. So Node.js can introduce more modules in the future without fearing overlap from NPM. Plus, it‚Äôs more explicit - you immediately know which modules are from Node.js itself.</p><p>Node.js supports both versions still, but there are linter rules like <a href="https://biomejs.dev/linter/rules/use-nodejs-import-protocol/">useNodejsImportProtocol</a> to push you to using the <code>node:</code> protocol.</p><h2 id="2018-deno-introduces-https-imports">2018: Deno introduces https imports</h2><p><a href="https://deno.com/">Deno</a> (a Node alternative) originated from Ryan Dahl (Node‚Äôs creator) reflecting on his mistakes and building something new. In his talk <a href="https://youtu.be/M3BM9TB-8yA?si=yECV4fjM9bP6LCHf&amp;t=1262">10 Things I Regret about Node.js</a> from 2018, he proposed that defaulting to NPM was bad because it centralized on only one module registry. And then he presented the first look at Deno, which would work with ‚Äúrelative or absolute URLs ONLY.‚Äù</p><p><img alt="Deno imports announcement" src="https://macwright.com/images/2025-12-08-module-specifiers-and-protocols-deno-imports-announcement.png"/></p><h2 id="2022-deno-introduces-the-npm-protocol">2022: Deno introduces the <code>npm:</code> protocol</h2><p>Unfortunately, this did not last. In 2022, Deno <a href="https://deno.com/blog/v1.28">stabilized NPM compatibility and introduced the <code>npm:</code> protocol</a>.</p><p>This let you import an NPM module like this:</p><div><div><pre><code><span>import</span> <span>{</span> <span>chalk</span> <span>}</span> <span>from</span> <span>&#34;</span><span>npm:chalk@5</span><span>&#34;</span><span>;</span>
</code></pre></div></div><p>Supporting the NPM ecosystem, which is the largest and most popular registry for JavaScript, was probably a necessity for Deno to have any traction. At this point, Deno did not support <code>package.json</code>, the NPM standard for storing which versions of NPM modules you were using. So compatibility looked like:</p><ul><li>Node &amp; Deno: <code>import * from &#34;chalk&#34;</code> only if Deno has an import map. In this case, you need an import map for Deno and a <code>package.json</code> file for Node.js.</li><li>Deno only:<ul><li><code>import * from &#34;https://esm.sh/chalk&#34;</code></li><li><code>import * from &#34;npm:chalk&#34;</code></li></ul></li></ul><h2 id="2023-deno-introduces-packagejson-support">2023: Deno introduces package.json support</h2><p>In 2023, <a href="https://deno.com/blog/v1.31">Deno introduced support for package.json</a>, which made it significantly more compatible with Node.js:</p><ul><li>Node &amp; Deno: <code>import * from &#34;chalk&#34;</code> with package.json</li><li>Deno only:<ul><li><code>import * from &#34;https://esm.sh/chalk&#34;</code></li><li><code>import * from &#34;npm:chalk&#34;</code></li></ul></li></ul><h2 id="2024-deno-introduces-the-jsr-protocol">2024: Deno introduces the <code>jsr:</code> protocol</h2><p>Then Deno <a href="https://deno.com/blog/jsr_open_beta">introduced JSR</a>, an alternative to NPM. You could import JSR modules a bunch of different ways, but one of them was:</p><div><div><pre><code><span>import</span> <span>*</span> <span>as</span> <span>chalk</span> <span>from</span> <span>&#34;</span><span>jsr:@nothing628/chalk</span><span>&#34;</span><span>;</span>
</code></pre></div></div><p>So now Deno supports three protocols (<code>jsr:</code>, <code>npm:</code>, and <code>node:</code>) and Node supports one (<code>node:</code>). JSR has been a <a href="https://dbushell.com/2025/06/23/jsr-and-deno-one-year-later-malware/">mixed bag so far</a>, not clearly ‚Äòbetter‚Äô than NPM in ways that the community values, and it‚Äôs very hard to overcome the network effects of something like NPM.</p><h2 id="2024-deno-moves-away-from-http-imports">2024: Deno moves away from HTTP imports</h2><p>Also in 2024, Deno started moving away from HTTP imports, with blog posts about <a href="https://deno.com/blog/http-imports">what HTTP imports got wrong</a> and then in 2025, they published <a href="https://deno.com/blog/not-using-npm-specifiers-doing-it-wrong">‚ÄòIf you‚Äôre not using npm specifiers, you‚Äôre doing it wrong‚Äô</a>.</p><h2 id="2025-the-current-messy-state-of-affairs">2025: The current messy state of affairs</h2><p>Here‚Äôs a basic chart of the module specifier situation as of today (December 8, 2025), the best I can see based on manual testing and reading documentation.</p><table><thead><tr><th>Specifier</th><th>Deno</th><th>Node</th><th>Bun</th><th>Val Town</th></tr></thead><tbody><tr><td>axios</td><td>‚úÖ (with deno.lock)</td><td>‚úÖ</td><td>‚úÖ</td><td>‚õîÔ∏è (no user-provided deno.lock yet)</td></tr><tr><td>npm:axios</td><td>‚úÖ</td><td>‚õîÔ∏è</td><td>‚õîÔ∏è</td><td>‚úÖ</td></tr><tr><td>https://esm.sh/axios</td><td>‚úÖ (discouraged)</td><td>üü† (in <a href="https://nodejs.org/api/module.html#import-from-https">userspace</a>)</td><td>‚õîÔ∏è</td><td>‚úÖ</td></tr><tr><td>jsr:axios</td><td>‚úÖ</td><td>‚õîÔ∏è</td><td>‚õîÔ∏è</td><td>‚úÖ</td></tr><tr><td>node:fs</td><td>‚úÖ</td><td>‚úÖ</td><td>‚úÖ</td><td>‚úÖ</td></tr></tbody></table><p>Note that <em>runtime support</em> trickles into downstream tools. So for example, the TypeScript compiler targets Node and doesn‚Äôt have any support for the <code>npm:</code> protocol, https imports, or other things that Deno does. The ‚Äòsafe subset‚Äô of features for tools is what Node does, which is bare imports and the <code>node:</code> protocol.</p><p>Certainly one of the lessons of the last years for both Deno and <a href="https://bun.sh/">Bun</a> is that in order to compete effectively with Node they need to provide all of the functionality of Node and then more: there isn‚Äôt an angle for support https imports <em>only</em>, as Dahl optimistically planned in 2018.</p><p>Having invested heavily into https imports for <a href="https://val.town/">Val Town</a>, the state of play for module import specifiers is pretty important to me, and this is a difficult ecosystem to play with. The elegance of importing <code>npm:chalk@9</code> from Deno - specifying the source, module, and version all in an import string - is super nice. HTTPS imports are really great in the sense that you don‚Äôt need to put everything on a huge filesystem and you don‚Äôt need to publish everything to NPM or create a lot of tarballs. But the future is unpredictable and sometimes we really take two steps forward and one step back.</p></div></div>
  </body>
</html>
