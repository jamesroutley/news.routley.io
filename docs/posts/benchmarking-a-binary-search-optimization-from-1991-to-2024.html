<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://moerner.com/posts/benchmarking-binary-search/">Original</a>
    <h1>Benchmarking a Binary Search Optimization, from 1991 to 2024</h1>
    
    <div id="readability-page-1" class="page"><div>
      

<article>
  <header>
    

    
    <p><time>Nov 8, 2024</time>
      
      
      
      
    </p>
    
  </header>

  <section><p>While reading Chris Okasaki’s <a href="https://www.cambridge.org/core/books/purely-functional-data-structures/0409255DA1B48FA731859AC72E34D494">Purely Functional Data Structures</a> I became aware of an interesting optimization for binary search proposed by Arne Andersson in his 1991 paper, <a href="https://user.it.uu.se/~arneande/ps/searchproc.pdf">A Note on Searching in a Binary Search Tree</a>. This blog post is an investigation of this optimization, including some updated benchmarks in Go and OCaml.</p>

<p>As a reminder, a binary search tree can be thought of as a data structure consisting of empty leaves and non-empty nodes; each node contains a value and pointers to left and right subtrees. A binary search tree must satisfy the BST Invariant: For any node <em>n</em>, every node in the left subtree of <em>n</em> has a value less than <em>n</em>’s value, and every node in the right subtree of <em>n</em> has a value greater than <em>n</em>’s value. This naturally suggests the following algorithm for binary search, implemented in Go:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>BSearch</span>(<span>t</span> <span>*</span><span>Tree</span>, <span>n</span> <span>int</span>) <span>bool</span> {
</span></span><span><span>	<span>for</span> <span>t</span> <span>!=</span> <span>nil</span> {
</span></span><span><span>		<span>if</span> <span>n</span> &lt; <span>t</span>.<span>v</span> {
</span></span><span><span>			<span>t</span> = <span>t</span>.<span>l</span>
</span></span><span><span>		} <span>else</span> <span>if</span> <span>n</span> &gt; <span>t</span>.<span>v</span> {
</span></span><span><span>			<span>t</span> = <span>t</span>.<span>r</span>
</span></span><span><span>		} <span>else</span> {
</span></span><span><span>			<span>return</span> <span>true</span>
</span></span><span><span>		}
</span></span><span><span>	}
</span></span><span><span>	<span>return</span> <span>false</span>
</span></span><span><span>}
</span></span></code></pre></div><p>This algorithm has a worst-case time complexity of O(n), in an unbalanced tree whose every node we need to traverse. In general, the best way to optimize an algorithm is to improve its big-O complexity: In the case of a binary tree, this would often take the form of implementing a self-balancing binary tree, like a red-black tree (hopefully to be discussed in a later blog post). However, even the possibility for constant improvements should not be ignored when looking for optimizations, particularly on smaller data sets where constant factors may be more significant..</p>
<p>Arne Andersson points out that in the worst case, this binary search algorithm has to perform two comparisons on each node: First a less-than, and then a greater-than. Is it possible to perform only one? Some languages have a builtin three-way comparison operator, but many do not. Even without a three-way comparison operator, it’s possible to search a binary tree with only one comparison in the loop. This is achieved by keeping track of a candidate match, and then performing a second comparison only once at the very end. Here’s an example implementation in Go:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>BSearchOneComp</span>(<span>t</span> <span>*</span><span>Tree</span>, <span>n</span> <span>int</span>) <span>bool</span> {
</span></span><span><span>	<span>var</span> <span>candidate</span> <span>*</span><span>Tree</span>
</span></span><span><span>	<span>for</span> <span>t</span> <span>!=</span> <span>nil</span> {
</span></span><span><span>		<span>if</span> <span>n</span> &lt; <span>t</span>.<span>v</span> {
</span></span><span><span>			<span>t</span> = <span>t</span>.<span>l</span>
</span></span><span><span>		} <span>else</span> {
</span></span><span><span>			<span>candidate</span> = <span>t</span>
</span></span><span><span>			<span>t</span> = <span>t</span>.<span>r</span>
</span></span><span><span>		}
</span></span><span><span>	}
</span></span><span><span>	<span>if</span> <span>candidate</span> <span>!=</span> <span>nil</span> <span>&amp;&amp;</span> <span>candidate</span>.<span>v</span> <span>==</span> <span>n</span> {
</span></span><span><span>		<span>return</span> <span>true</span>
</span></span><span><span>	}
</span></span><span><span>	<span>return</span> <span>false</span>
</span></span><span><span>}
</span></span></code></pre></div><p>Suppose we are searching in a tree for a value <em>n</em> which is somewhere in the tree, and suppose we reach the node which contains <em>n</em>. The candidate will now be set to <em>n</em>. Given the BST Invariant, we can now only make left turns, which do not update the candidate. The correct candidate is thus saved until the loop terminates.</p>
<p>The advantage of this potential optimization is that fewer numerical comparisons need to be made: In the worst case, <em>n+1</em> comparisons, rather than <em>2n</em> comparisons. The cost of this potential optimization is that if a match is near the root of the tree, in the worst case we will still need to traverse the whole tree before confirming that the candidate is a match. Benchmarking is therefore required.</p>

<p>Here I reproduce the 1991 results from Andersson:</p>
<p><img src="https://obdev.at/blog/a-memory-leak-in-apples-network-extension-framework/images/andersson-benchmarks.png" alt="Andersson 1991 Benchmarks"/></p>
<p>That’s a blast from the past! (Let’s not get into reading the Modula-2 sample code to even understand the algorithms.) These are some pretty significant results, on the order of a 30% or more speedup in most cases. As Andersson notes:</p>
<blockquote>
<p>[E]ven though the three-way comparison may exist at the machine-level this operation is not available in most high-level programming languages. […] [S]o far the author has never observed a compiler which actually translates these two comparisons in to one three-way comparison. (1125)</p>
</blockquote>
<p>Thus implementing the one-comparison algorithm in code could lead to significant improvements.</p>

<p>However, these results are ancient. Compilers may have improved, and languages may have improved. Indeed, some languages do implement a three-way comparison operator (C++20), and as far as I know, x86 does not at the assembly level. Obviously there’s a lot to potentially study here, and I hope to expand this discussion in future posts. For now, I want to focus on two case studies: Go (1.23) and OCaml (5.2.0).</p>
<p>All the code and test results for these studies is available on my <a href="https://github.com/dmoerner/bsearch_benchmark">Github</a>.</p>
<h2 id="go">Go</h2>
<p>It is well-known that Go has extensive support for benchmarking, which makes our job easier. Since computers are a little faster, I performed tests on two sizes of array. Note that in these results, a lower number is better.</p>
<p>Randomly inserted tree of 5000 integer elements, test performed five times, and results averaged:</p>
<pre tabindex="0"><code>OneComp: 94.77 ns/op
TwoComp: 81.33 ns/op
</code></pre><p>The one comparison algorithm is 16% slower! How about with larger trees of 100000 elements, again with the test performed five times and the results averaged?</p>
<pre tabindex="0"><code>OneComp: 197.92 ns/op
TwoComp: 178.70 ns/op
</code></pre><p>The one comparison algorithm in Go is still 10% slower!</p>
<h2 id="ocaml">OCaml</h2>
<p>What about OCaml? OCaml is how I initially got into thinking about some of these algorithms, and it provides the opportunity to test recursive implementations of these two binary search algorithms. Unfortunately, there appear to be significantly fewer resources for benchmarking in OCaml. I ended up using <a href="https://github.com/Chris00/ocaml-benchmark">ocaml-benchmark</a>, which hasn’t been updated in several years. This library has a few issues. FIrst, it seems that the tabulation support for prettying printing the results does not work on the newest versions of OCaml. Second, it requires the user to make an estimation of the appropriate sample size for benchmarking.</p>
<p>For OCaml, I did 10 million iterations with trees of 5000 and 100000 elements.  The OCaml benchmark library reports results differently from go: Number of iterations per second. I converted these to <em>ns/op</em> to make them comparable to the Go benchmarks.</p>
<p>Averaged results from five tests with a 5000-element, randomly inserted binary tree:</p>
<pre tabindex="0"><code>onecomp: 4893266.53/s = 204.36 ns/op
twocomp: 4436230.84/s = 225.42 ns/op
</code></pre><p>Averaged results from five tests with a 100000-element, randomly inserted binary tree:</p>
<pre tabindex="0"><code>onecomp: 3247907.21/s = 307.89 ns/op
twocomp: 2949312.62/s = 339.06 ns/op
</code></pre><p>With OCaml, Andersson’s algorithm is approximately 10% faster, with no significant difference between the trees of two different sizes.</p>
<p>Of course, these benchmarks also show that OCaml is significantly slower than Go on randomly inserted integer binary trees of the same size, although the gap is narrower with the larger trees.</p>

<p>Obviously, the answer is: It depends! Optimization can only be performed properly based on proper benchmarks for your own language and workload. It seemed unlikely that these benchmarking results from 1991, still cited by Okasaki in 1998, would be totally robust. The benchmarking differences I found for Go and OCaml were signficantly smaller than those found by Andersson. And it’s worth recognizing that the algorithm is not an improvement in Go, and while it is an improvement in OCaml, it’s only a small improvement relative to the comparative slowness of the language.</p>
<p>There are two directions to pursue next: First, testing with balanced binary trees, which I intend to get to get to this weekend. Second, it would be interesting to do a comparison with other languages, particularly one like C++20 which has a three-way comparison operator, although I probably won’t get to this.</p>
</section>

  
  

  
  
  
  
  

  
  

  
  

  


  
</article>


    </div></div>
  </body>
</html>
