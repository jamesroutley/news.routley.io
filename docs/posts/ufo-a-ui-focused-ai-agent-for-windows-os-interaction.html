<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/microsoft/UFO">Original</a>
    <h1>UFO: A UI-Focused AI Agent for Windows OS Interaction</h1>
    
    <div id="readability-page-1" class="page"><div>
		<p>When I describe my programming background these days, I say that I code “primarily in Python, JavaScript, Clojure, C… and Zig!” I put Python first in that list for good reason.</p>
<p>This is a post about the core Python language, but also the ways in which Python is evolving its single-core and multi-core CPU performance.</p>
<p>Python has been my go-to programming tool for a long time. When I started to build out <a href="https://amontalenti.com/2021/12/08/parsely-and-automattic">my last startup</a> and shipped the production core of its product, Python 2.7 had just stabilized, creating an excellent “core language.” This is a language that I truly respected, as evidenced by my <a href="https://github.com/amontalenti/elements-of-python-style">style guide</a>. And, as I discussed in my <a href="https://amontalenti.com/2015/06/06/pybooks">Python technical book review round-up</a>, this core language was best described by David Beazley in the first half of his <em>Python Essential Reference</em> book, which was also turned into an excellent standalone volume (which includes Python 3.x coverage), <a href="https://amzn.to/3T71drj"><em>Python Distilled</em></a>.</p>
<p><img decoding="async" src="https://amontalenti.com/wordpress/wp-content/uploads/2024/02/abstract-python-rocket.webp"/></p>
<p>Many, many useful open source projects, companies, and projects were built atop that Python 2.7 core foundation of a language. Its community truly flourished.</p>

<p>But in the early days of my first startup, the Python core team was in full swing with <a href="https://peps.python.org/pep-3000/">Python3000</a>, improving the language in a number of directions, which would eventually become the main Python 3.x releases we all use and love today. (See also <a href="https://amontalenti.com/2020/05/14/python-3-is-here-and-the-sky-is-not-falling">Python 3 is here and the sky is not falling</a>.)</p>
<p>With the benefit of hindsight, it’s clear that only a few Python 3.x features truly took the language in a different direction — and always in an add-on-to-the-core sort of way. For example: <a href="https://docs.python.org/3/library/typing.html">gradual typing</a> and <a href="https://docs.python.org/3/library/asyncio.html">asyncio</a>. These features <em>were</em> big and important. But, they didn’t <em>fundamentally change</em> the kinds of programs you could write in Python. They instead improved certain approaches to software craftsmanship — allowing for the documentation of large codebases (with type hints) and  allowing for a simpler approach to asynchronous I/O (with event loops).</p>
<p>Some Python 3.x features felt like they should have always been there in Python 2.7, such as <a href="https://docs.python.org/3/library/enum.html"><code>enum</code></a> and <a href="https://docs.python.org/3/library/dataclasses.html"><code>dataclasses</code></a> (we survived with <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple"><code>namedtuple</code></a>).  These new data types allowed for a change in the mental model of how to describe the data you work with day-to-day in a Python program. And that really matters for language ergonomics. Some Python 3 features still feel a bit more experimental. For example: <a href="https://peps.python.org/pep-0636/#tutorial">structural pattern matching</a> and <a href="https://docs.python.org/3/tutorial/errors.html#tut-exception-groups">exception groups</a> may feel a little awkward at first. But I do think they will start to click for Python programmers over time.</p>
<p>As for everyday conveniences, one can thank the Python core team profusely for  <a href="https://docs.python.org/3/tutorial/inputoutput.html#formatted-string-literals">f-strings</a> — yes, we survived with the ugly <code>%</code> formatter operator, but f-strings are much more flexible and readable, especially with proper syntax highlighters in editors.</p>
<p>Other new features felt more like a “clean-up” of learnings from years of production Python use. For example, <a href="https://docs.python.org/3/c-api/stable.html">the stable C ABI</a>. Super important for C extension authors, but mostly hidden from everyday Python users.</p>
<p>Perhaps unsurprisingly, the Python 3 developments that have generated the most buzz in the community are all centered around performance. Python long had a reputation as a “slow” language. This reputation never bothered me: I knew from experience that programmer time was expensive and CPU time was cheap and getting cheaper all the time.  Python 2.7 was a language that fit very nicely in the limited capacity of a programmer brain, but suffered a bit in terms of CPU execution speed, especially compared to its competitors. This mostly stemmed from Python’s focus on simplicity. Its interpreter did not use the fancy (and largely inscrutable) JIT compilation techniques popular in the Java, C++, and JavaScript compiler engineering world. Python’s language design insisted on keeping a highly dynamic runtime, which though a good fit for the flexible associative agility of programmer cognition, was deeply at odds with machine optimization techniques.</p>
<p>What’s more, Python stayed a single-core language due to its Global Interpreter Lock (aka GIL), which was a perpetual source of disappointment for those interested in multi-core parallel programming. Lots of hemming and hawing about Go and Rust comparisons, while the Python programmers I knew just plowed ahead with <a href="https://docs.python.org/3/library/multiprocessing.html">multiprocessing</a> and similar tools, despite their rough edges.</p>
<p>We now have a lot of performance improvements being actively developed for Python. These span a number of important PEPs and projects, such as:</p>
<ul>
<li><a href="https://peps.python.org/pep-0554/">PEP 554: Multiple Interpreters in the Stdlib (accepted)</a></li>
<li><a href="https://peps.python.org/pep-0659/">PEP 659: Specializing Adaptive Interpreter (draft)</a></li>
<li><a href="https://peps.python.org/pep-0684/">PEP 684: A Per-Interpreter GIL (accepted)</a></li>
<li><a href="https://www.theregister.com/2021/05/13/guido_van_rossum_cpython_3_11/">Guido’s Faster CPython team</a></li>
<li><a href="https://lwn.net/Articles/939981/">The working nogil implementation</a></li>
<li><a href="https://peps.python.org/pep-0703/">PEP 703: Making the Global Interpreter Lock Optional in CPython (accepted)</a></li>
</ul>
<p>Broadly, there are four performance approaches being explored, some of which are already successful:</p>
<ul>
<li><strong>Make CPython Faster at single-core performance.</strong> This is what Guido’s team is working on with the “Faster CPython” project. The idea is to focus on optimizing the C codebase that is CPython, to get speedups that affect everyday code. You then upgrade your Python interpreter (from, say, 3.13 to 3.14 in celebration of Pi!) and you get speedups in working code “for free.” There is also some <a href="https://www.youtube.com/watch?v=HxSHIpEQRjs">exciting and promising recent work</a> on a copy-and-patch JIT compiler that would run within the CPython interpreter.</li>
<li><strong>Make CPython support a “nogil” mode.</strong> This is what PEP 703 is all about. Since there is now support for a GIL-free Python, there is the option to write multi-threaded, shared memory Python code in such a way that it utilizes multiple cores on a single machine.</li>
<li><strong>Make CPython support multiple Python interpreters running in the same process, aka subinterpreters.</strong> This is what PEP 684 is about. This is halfway between <code>multiprocessing</code> and <code>nogil</code>. With <code>multiprocessing</code>, you run separate Python interpreters as separate processes, and create an operating-system-managed communication channel between them (e.g. a <code>fork()</code> copy-on-write memory space, a UNIX pipe, a file, or a <code>/dev/shm</code> shared buffer). With subinterpreters, you could run two entirely parallel Python interpreters within the same process, and this might allow easier cross-platform in-process shared memory approaches vs operating-system-specific approaches.</li>
<li><strong>Make CPython easier to run across multiple nodes.</strong> This is a hard problem attacked at the community level by projects like <a href="https://spark.apache.org/docs/latest/api/python/index.html"><code>pyspark</code></a>, <a href="https://www.ray.io/"><code>ray</code></a>, and <a href="https://www.dask.org/"><code>dask</code></a>. The CPython core team is staying away from this one.</li>
</ul>
<p>The core Python language remains a mental treat for programmers. The single-core performance of Python is getting faster. The option to go “natively” multi-core with Python is also becoming increasingly viable. The future of Python — light on your brain, fast on your machine — is bright!</p>
<hr/>
<p><strong>Acknowledgements:</strong> Thank you to Rom for reviewing a draft of this essay and sharing some pointers to recent Python performance projects. Also, thanks to <a href="https://www.codyhiar.com/">Cody Hiar</a> for sending me some feedback on the post and reminding me that a few years back, I gave a relevant PyData NYC talk that covers some of these GIL and multi-core and multi-node processing challenges. That’s this one on YouTube: <a href="https://www.youtube.com/watch?v=gVBLF0ohcrE">“Beating Python’s GIL to Max Out Your CPUs.”</a> You can also <a href="https://speakerdeck.com/amontalenti/beating-pythons-gil-to-max-out-your-cpus">skim the slides here</a>.</p>
	</div></div>
  </body>
</html>
