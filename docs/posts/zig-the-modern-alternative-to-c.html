<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.infoworld.com/article/3689648/meet-the-zig-programming-language.html">Original</a>
    <h1>Zig: The Modern Alternative to C</h1>
    
    <div id="readability-page-1" class="page"><div id="page-wrapper">
	
	
















			
		











	
	
	
	
	
	
	
	
	
	
	
	
	
	
	





	
	
 	


	
	<section role="main">
	
		
		
		

		<article itemscope="" itemtype="http://schema.org/Article">

		















<!-- Events Header -->

 
 
	
		
		
		
		
		
					    			
		
	
	
	
	
	

 
 
 
 
  
  
 
 












	
	
	
	
	
	
	
	
	
	
	
	
	
	
	


<!-- //end Events Header -->


	
	
	
	
	
	
		
	



	
		
	
	
		






















	
	
	
		
	



















	
		
	
	
















	
	




	
			












	
	
		<meta itemprop="keywords" content="programming languages, software development, c++ "/>
	







<header>

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
		
		
			
		
	
	

	
	
	
	
	
		<section>
			<h3 itemprop="description">Zig is an up-and-coming systems-oriented language that could one day replace C.  Here&#39;s what you need to know about Zig.</h3>
		</section>
	
	
	
	
	
	
	
	
			
	
	
	

	
		
			
				
				<div>		
					<div>
						
						<p>
						
							Software Architect, 
								
									
								












<span itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><span itemprop="name">InfoWorld</span><meta itemprop="url" content="https://www.infoworld.com"/><meta itemprop="logo" content="https://idge.staticworld.net/ifw/IFW_logo_social_300x300.png"/></span> <span>|</span>
							
	
							<span class="break-date" itemprop="datePublished" content="2023-03-09T02:00-0800"><span></span>
								
							</span>
						</p>
					</div>
				</div>
			
		
	
	
		
	
	
		
			
			
				
				
				
				
					
					
						
					
				
				
			
		
	
	
	
	
	
</header>




	<div>
		
		
		
		
			
				<div>
					
					
					
						
						
							
				                
				                	
				                	
				                
				                
								
								
								
							
							
								
							
							
							<figure itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject">
								<meta itemprop="representativeOfPage" content="1"/>
								<meta itemprop="height" content="800"/>
								<meta itemprop="width" content="1200"/>
								<meta itemprop="url" content="https://images.idgesg.net/images/article/2023/03/shutterstock_154385324-100938138-large.jpg?auto=webp&amp;quality=85,70"/>
							    								
								
								
								
								
								
								<img src="https://images.idgesg.net/images/article/2023/03/shutterstock_154385324-100938138-large.jpg?auto=webp&amp;quality=85,70" loading="eager" width="620" height="413" alt="Zig zag road sign. Yellow lines on asphalt." itemprop="contentUrl"/>

					    		<figcaption>
					    			
					    			
					    				<span itemprop="copyrightHolder">
					    					
							    				
							    				Shutterstock/Tom Gowanlock
						    				
				
							    			
							    				
							    				
							    				
												
												  	
												
												  	
												
												  	
												
												  	
												
												  	
												
												  	
												
												  	
												
												  	
												
												  	
												
												  	
												
												  	
												
												  	
												
							    				
							    				
												
											
									
										</span>
					    			
									
					    		</figcaption>
							</figure>
							
				
						
						
					
				</div>
			
			
		
	



<section id="drr-top-ad">

	
	
	
	
	
	
		
	
	
	
	
	
	
	
	
	
	
	
	
	

		
		
	
		
	
	
</section>

</div>














		
		



		<section>

			
				
				
					












	
		



























	



	
	
	
	
		
	
	
	
	
	
	
	
	
		
			
				<div data-tracking-category="In-article TOC">
					<legend>Table of Contents <i></i></legend>
					
					<p>Show More <i></i></p>
				</div>
	
					
				    
			
		
		
	
	
	
	
	
	
			
	
	
	
	
	
	
		
		
			
		
	
	
	
	
	
		
			
				
				
				
					
				
				
			
		
		
	
	
		
		
			<div id="drr-container" itemprop="articleBody">
		
		
		
		
	
		
			
			
				<p>Programmers are never satisfied. As soon as we&#39;ve accomplished one near-impossible goal, we start working toward a new one. A case in point is systems-oriented development, where we already have a complement of strong languages to work with: C, C++, Rust, and Go. Now we also have Zig, a newer language that seeks to absorb what&#39;s best about these languages and offer comparable performance with a better, more reliable developer experience. </p><p>Zig is a <a href="https://github.com/ziglang/zig/graphs/contributors" rel="nofollow">very active project</a>. It was started by <a href="https://andrewkelley.me/" rel="nofollow">Andrew Kelley</a> in 2015 and now seems to be reaching critical mass. Zig&#39;s ambition is rather momentous in software history: to become the heir to C’s longstanding reign as both the go-to portable low-level language and as a standard to which other languages are compared.</p><p>Before we dive into the specifics of programming with Zig, let’s consider where it fits within the larger programming language ecosystem. </p><h2 id="toc-1">A replacement for C?</h2><p>Zig is described as a “low-level systems language,” but what is <em>low-level</em>? <em>Systems language</em> is also fairly ambiguous. I asked Zig project developer <a href="https://sycl.it/speakers/karsten-schmidt/" rel="nofollow">Karsten Schmidt</a> how he describes Zig, and he said “I define Zig as a general-purpose programming language because, while it&#39;s an obvious good fit for systems programming, it&#39;s also suited for programming embedded devices, targeting WebAssembly, writing games, and even most tasks that would normally be handled by higher-level languages.”</p><p>Zig is perhaps easiest to understand in relation to C, as a general purpose, non-garbage collected, and portable language with pointers. Today, virtually all programming infrastructure rests on C in various ways, including being the foundation of other programming languages like Java, JavaScript, and Python. Imagine the ripple effect of evolving to a language that is like C, but safer, less buggy, and easier to maintain. If Zig were to be adopted broadly as an archetypal replacement for C, it could have enormous systemic benefits. </p><p>Karsten told me that, while Zig does compete with C, &#34;we don&#39;t expect it to supplant C without a very long stretch of time where both languages have to coexist.”</p><h2 id="toc-2">Zig&#39;s design goals and syntax</h2><p>Zig is a &#34;close to the metal&#34; language in that it allows developers to work directly with system memory, a requirement for writing code that can be maximally optimized to its task. Direct memory allocation is a characteristic shared by the C family, Rust, and other low-level systems languages. Zig offers similar capabilities but aims to <a href="https://ziglang.org/learn/why_zig_rust_d_cpp/" rel="nofollow">improve on them in several ways</a>.</p><p>Zig seeks to be a simpler systems-oriented language than its predecessors and make it easier to write safe, correct code. It also aims for a better developer experience by reducing the sharp edges found in writing C-like software. On the first review, Zig&#39;s features might not come across as earth-shattering, but the overall effect is of a platform that developers are finding easier to master and use.</p><p>Currently, Zig is being used to implement the <a href="https://www.infoworld.com/article/3688330/explore-bunjs-the-all-in-one-javascript-runtime.html">Bun.js JavaScript runtime</a> as an alternative to Node.js. Bun’s creator <a href="https://twitter.com/jarredsumner" rel="nofollow">Jarred Sumner</a> told me “Zig is sort of similar to writing C, but with better memory safety features in debug mode and modern features like <code>defer</code> (sort of similar to Go&#39;s) and arbitrary code can be executed at compile-time via <code>comptime</code>. It has very few keywords so it&#39;s a lot easier to learn than C++ or Rust.”</p><p>Zig differs from most other languages in its small feature footprint, which is the outcome of an explicit design goal: <em>Only one obvious way to do things</em>. Zig&#39;s developers take this goal so much to heart that for a time, <a href="https://github.com/ziglang/zig/issues/8292" rel="nofollow">Zig had no for loop</a>, which was deemed an unnecessary syntactic elaboration upon the already adequate <code>while</code> loop.</p><p>Kevin Lynagh, coming from a Rust background, <a href="https://kevinlynagh.com/rust-zig/" rel="nofollow">wrote</a>, “The language is so small and consistent that after a few hours of study I was able to load enough of it into my head to just do my work.” Nathan Craddock, a C developer, <a href="https://nathancraddock.com/blog/2022/consistency-in-zigs-type-system/" rel="nofollow">echoed the sentiment</a>. Programmers seem to really like the focused quality of Zig’s syntax.</p><h2 id="toc-3">How Zig handles memory</h2><p>A distinctive feature of Zig is that it does not deal with memory allocation directly in the language. There is no <code>malloc</code> keyword like in C/C++. Instead, access to the heap is handled explicitly in the standard library. When you need such a feature, you pass in an <code>Allocator</code> object. This has the effect of clearly denoting when memory is being engaged by libraries while abstracting how it should be addressed. Instead, your client code determines what kind of allocator is appropriate.</p><p>Making memory access an obvious library characteristic is meant to avoid <a href="https://ziglang.org/learn/why_zig_rust_d_cpp/#no-hidden-allocations" rel="nofollow">hidden allocations</a>, which is a boon to resource-limited and real-time environments. Memory is lifted out of the language syntax, where it can appear anywhere, and its handling is made more explicit.</p><p>Allowing client code to specify what type of allocator it passes into an API means the code gets to choose based on the environment it is targeting. That means library code becomes more obvious and reusable. An application can determine when exactly a library it is using will access memory, and hand it the type of allocator—embedded, server, WASM, etc.—that is most appropriate for the runtime.</p><p>As an example, the Zig standard library ships with a basic allocator called a page allocator, which requests memory from the operating system by issuing: <code>const allocator = std.heap.page_allocator;</code>. See the Zig documentation for <a href="https://ziglearn.org/chapter-2/#:~:text=The%20Zig%20standard%20library%20provides,heap." rel="nofollow">more about available allocators</a>.</p><p>Zig also includes <a href="https://ziglang.org/documentation/master/#Sentinel-Terminated-Pointers" rel="nofollow">safety features</a> for avoiding buffer overflows, and it ships with a debug allocator that detects memory leaks.</p><h2 id="toc-4">Conditional compilation</h2><p>Zig uses <a href="https://en.wikipedia.org/wiki/Conditional_compilation" rel="nofollow">conditional compilation</a>, which eliminates the need for a <a href="https://www.tutorialspoint.com/cprogramming/c_preprocessors.htm" rel="nofollow">preprocessor</a> as found in C. Therefore, Zig does not have macros like C/C++. From a design standpoint, Zig&#39;s development team views the need for a preprocessor as indicative of a language limitation that has been crudely patched over.</p><p>Instead of macros, Zig’s compiler determines what code can be evaluated at compilation time. For example, an <code>if</code> statement will actually eliminate its dead branch at compile-time if possible. Instead of using <code>#define</code> to create a compile-time constant, Zig will determine if the <code>const</code> value can be treated that way and just do it. This not only makes code easier to read, write, and think about, but also opens up the opportunity for optimization. </p><p>As <a href="https://itnext.io/what-makes-zig-unique-1b98bfb95701" rel="nofollow">Erik Engheim writes</a>, Zig makes compile-time computing a central feature instead of an afterthought. This allows Zig developers &#34;to write generic code and do meta programming without having any explicit support for generics or templates.”</p><p>A distinctive Zig feature is the <a href="https://ziglang.org/documentation/master/" rel="nofollow">comptime</a> keyword. This allows for executing code at compile time, which lets developers enforce types against generics, among other things. </p><h2 id="toc-5">Interoperability with C/C++</h2><p>Zig sports a high degree of interoperability with C and C++. As the Zig docs <a href="https://ziglang.org/learn/why_zig_rust_d_cpp/#a-portable-language-for-libraries" rel="nofollow">acknowledge</a>, “currently it is pragmatically true that C is the most versatile and portable language. Any language that does not have the ability to interact with C code risks obscurity.” </p><p><a href="https://ziglang.org/learn/overview/#cross-compiling-is-a-first-class-use-case" rel="nofollow">Zig can can compile C and C++</a>. It also <a href="https://ziglang.org/learn/overview/#zig-ships-with-libc" rel="nofollow">ships with libc</a> libraries for many platforms. It is able to build these without linking to external libc libraries. (For a detailed discussion of Zig’s relationship to libc, <a href="https://www.reddit.com/r/Zig/comments/y4rlzi/clarifications_on_zigs_relationship_to_libc/" rel="nofollow">see this Reddit thread</a>.)</p><p><a href="https://andrewkelley.me/post/zig-cc-powerful-drop-in-replacement-gcc-clang.html" rel="nofollow">Here is Zig’s creator discussing</a> the C compiler capability in depth, including a sample of Zig compiling the GCC LuaJIT compiler. The bottom line is that Zig attempts to not only supercede C with its own syntax, but actually absorb C into itself as much as possible. </p><p>Karsten told me that “Zig is a better C/C++ compiler than other C/C++ compilers since it supports cross-compilation out of the box, among other things. Zig can also trivially interoperate with C (you can import C header files directly) and it&#39;s overall better than C at using C libraries, thanks to a stronger type system and language features like defer.”</p><h2 id="toc-6">Error handling in Zig</h2><p>Zig has a unique <a href="https://ziglang.org/documentation/0.8.1/#Errors" rel="nofollow">error-handling system</a>. As part of its “avoid hidden control flow” design philosophy, Zig doesn’t use <code>throw</code> to raise exceptions. The <code>throw</code> function can branch execution in ways that are hard to follow. Instead, if necessary, statements and functions can return an error type, as part of a union type with whatever is returned on the happy path. Code can use the error object to respond accordingly or use the <code>try</code> keyword to pass up the error.</p><p>An error union type has the syntax <code>&lt;error set type&gt; ! &lt;primitive type&gt;</code>. You can see this in action with the simple &#34;Hello, world&#34; example (from the <a href="https://ziglang.org/documentation/0.8.1/#Hello-World" rel="nofollow">Zig docs</a>) in Listing 1.</p><h4>Listing 1. Helloworld.zig</h4><pre><code>
const std = @import(&#34;std&#34;);

pub fn main() !void {
    const stdout = std.io.getStdOut().writer();
    try stdout.print(&#34;Hello, {s}!\n&#34;, .{&#34;world&#34;});
}
</code></pre><p>Most of Listing 1 is self explanatory. The <code>!void</code> syntax is interesting. It says the function can return either void or an error. This means if the <code>main()</code> function runs without error, it’ll return nothing; but if it does error out, it’ll return an error object describing the error condition.</p><p>You can see how client code can use an error object in the line where the <code>try</code> keyword appears. Since <code>stdout.print</code> can return an error, the <code>try</code> expression here means the error will be passed up to the <code>main()</code> function&#39;s return value.</p><h2 id="toc-7">Toolchain and testing</h2><p>Zig also includes a <a href="https://ziglang.org/learn/overview/#zig-build-system" rel="nofollow">build tool</a>. As an example, we could build and run the program in Listing 1 with the commands in Listing 2 (this is again from the Zig docs).</p><h4>Listing 2. Build and run Helloworld.zig</h4><pre><code>
$ zig build-exe hello.zig
$ ./hello
Hello, world!
</code></pre><p>Zig&#39;s build tool works in a cross-platform way and replaces tools like <code>make</code> and <code>cmake</code>.</p><p>A package manager is <a href="https://github.com/ziglang/zig/issues/943" rel="nofollow">in the works</a>, and testing support is built directly into the language and runner.</p><h2 id="toc-8">State of Zig</h2><p>Zig has an active <a href="https://discord.gg/gxsFFjE" rel="nofollow">Discord community</a> and a lively <a href="https://github.com/ziglang/zig" rel="nofollow">GitHub ecosystem</a>. The in-house <a href="https://ziglang.org/documentation/master/" rel="nofollow">documentation</a> is pretty thorough, and Zig users have produced a good amount of third-party material, as well. </p><p>Zig is not yet in 1.0 release, but its creators say it is <a href="https://www.reddit.com/r/Zig/comments/ty1z6e/when_will_zig_be_ready_for_production_use/" rel="nofollow">approaching production ready</a>. On the topic of readiness, Karsten said, “Zig is not yet at v1.0, so things like webdev are still in their infancy, but the only usage that I would consider not recommending Zig for is data wrangling, for which I think a dynamic language like Python or Julia would be more practical.”</p><p>For now, the Zig team appears to be taking its time with the 1.0 release, which may <a href="https://www.reddit.com/r/Zig/comments/x6ibug/any_available_official_timeline_for_when_v10_is/" rel="nofollow">drop in 2025 or later</a>—but none of that stops us from building all sorts of things with the language today.</p><p>Zig&#39;s activity, goals, and uptake by the developer community make it an interesting project to watch.</p><h3>Learn more about Zig</h3><p>Here are a few articles where you can learn more about Zig and how it is shaking up the world of systems-oriented programming:</p><ul>
<li><a href="https://erik-engheim.medium.com/is-zig-the-long-awaited-c-replacement-c8eeace1e692" rel="nofollow">Is Zig the Long Awaited C Replacement?</a></li>
<li><a href="https://ziglang.org/learn/why_zig_rust_d_cpp" rel="nofollow">Why Zig When There is Already C++, D, and Rust?</a></li>
<li><a href="https://about.sourcegraph.com/blog/zig-programming-language-revisiting-design-approach" rel="nofollow">Revisiting the design approach to the Zig programming language</a></li>
<li><a href="https://www.duskborn.com/posts/2021-aoc-zig" rel="nofollow">A Review of the Zig Programming Language (using Advent of Code 2021)</a></li>
</ul>
			
		
		
	
		
		
			
		
		
		
		
			
			
			
			











		
		
	</div>
	
	
	
		
		
		
	
	
	
	
	
	
	
	
	    
	
	
	
	
	
	
	
	
	
			
	   		












	
	
		<div>	
			<p>Matthew Tyson is a founder of  <a href="http://darkhorse.tech/#home">Dark Horse Group, Inc.</a> He believes in people-first technology. When not playing guitar, Matt explores the backcountry and the philosophical hinterlands. He has written for JavaWorld since 2007.</p><!-- end .author-info -->
						
		</div>
	



	   		
	   		
			
	
	
	
	
		












	






	<p>Copyright © 2023 IDG Communications, Inc.</p>

	
		 
	
	
	
	
	
		
		
	

















	 
	







	



	

	
	
	
	
	
	












	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
		<!-- blx4 #1172 blox4.html  -->
			

		
			
				
					
					
					
						
							
					
						
					
					
					
					
					
					
						
					
				
				
			
		















	
	
	

	


























		

	
	















		






	
	
	
	




					










				
			
		
		</section><!-- /.bodee -->

		














 




	
		
			
				
				
					
						
					

				
			
			
		

		
			
			
		
			
				
					
							
	
	



	
		
			












	
	
	

			
		
	
	




		</article>

	</section><!-- /role=main -->

	
	
	

</div></div>
  </body>
</html>
