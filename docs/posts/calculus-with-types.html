<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://stackoverflow.com/questions/9190352/abusing-the-algebra-of-algebraic-data-types-why-does-this-work/41418365#41418365">Original</a>
    <h1>Calculus with types</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="text">
<h2>Dependent type theory and &#39;arbitrary&#39; type functions</h2>

<p>My first answer to this question was high on concepts and low on details and reflected on the subquestion, &#39;what is going on?&#39;; this answer will be the same but focused on the subquestion, &#39;can we get arbitrary type functions?&#39;.</p>

<p>One extension to the algebraic operations of sum and product are the so called &#39;large operators&#39;, which represent the sum and product of a sequence (or more generally, the sum and product of a function over a domain) usually written <code>Σ</code> and <code>Π</code> respectively. See <a href="https://en.m.wikipedia.org/wiki/Summation#Capital-sigma_notation" rel="noreferrer">Sigma Notation</a>.</p>

<p>So the sum</p>

<pre><code>a₀ + a₁X + a₂X² + ...
</code></pre>

<p>might be written</p>

<pre><code>Σ[i ∈ ℕ]aᵢXⁱ
</code></pre>

<p>where <code>a</code> is some sequence of real numbers, for example. The product would be represented similarly with <code>Π</code> instead of <code>Σ</code>.</p>

<p>When you look from a distance, this kind of expression looks a lot like an &#39;arbitrary&#39; function in <code>X</code>; we are limited of course to expressible series, and their associated analytic functions. Is this a candidate for a representation in a type theory? Definitely!</p>

<p>The class of type theories which have immediate representations of these expressions is the class of &#39;dependent&#39; type theories: theories with dependent types. Naturally we have terms dependent on terms, and in languages like Haskell with type functions and type quantification, terms and types depending on types. In a dependent setting, we additionally have types depending on terms. Haskell is not a dependently typed language, although many features of dependent types can be simulated <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.22.2636" rel="noreferrer">by torturing the language a bit</a>.</p>

<h2>Curry-Howard and dependent types</h2>

<p>The &#39;Curry-Howard isomorphism&#39; started life as an observation that the terms and type-judging rules of simply-typed lambda calculus correspond exactly to natural deduction (as formulated by Gentzen) applied to intuitionistic propositional logic, with types taking the place of propositions, and terms taking the place of proofs, despite the two being independently invented/discovered. Since then, it has been a huge source of inspiration for type theorists. One of the most obvious things to consider is whether, and how, this correspondence for propositional logic can be extended to predicate or higher order logics. Dependent type theories initially arose from this avenue of exploration.</p>

<p>For an introduction to the Curry-Howard isomorphism for simply-typed lambda calculus, see <a href="https://en.m.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence#Natural_deduction_and_lambda_calculus" rel="noreferrer">here</a>. As an example, if we want to prove <code>A ∧ B</code> we must prove <code>A</code> and prove <code>B</code>; a combined proof is simply a pair of proofs: one for each conjunct.</p>

<p>In natural deduction:</p>

<pre><code>Γ ⊢ A    Γ ⊢ B
Γ ⊢ A ∧ B
</code></pre>

<p>and in simply-typed lambda calculus:</p>

<pre><code>Γ ⊢ a : A    Γ ⊢ b : B
Γ ⊢ (a, b) : A × B
</code></pre>

<p>Similar correspondences exist for <code>∨</code> and sum types, <code>→</code> and function types, and the various elimination rules.</p>

<p>An unprovable (intuitionistically false) proposition corresponds to an uninhabited type.</p>

<p>With the analogy of types as logical propositions in mind, we can start to consider how to model predicates in the type-world. There are many ways in which this has been formalised (see <a href="https://plato.stanford.edu/entries/type-theory-intuitionistic/" rel="noreferrer">this introduction</a> to Martin-Löf&#39;s Intuitionistic Type Theory for a widely-used standard) but the abstract approach usually observes that a predicate is like a proposition with free term variables, or, alternatively, a function taking terms to propositions. If we allow type expressions to contain terms, then a treatment in lambda calculus style immediately presents itself as a possibility!</p>

<p>Considering only constructive proofs, what constitutes a proof of <code>∀x ∈ X.P(x)</code>? We can think of it as a proof function, taking terms (<code>x</code>) to proofs of their corresponding propositions (<code>P(x)</code>). So members (proofs) of the type (proposition) <code>∀x : X.P(x)</code> are &#39;dependent functions&#39;, which for each <code>x</code> in <code>X</code> give a term of type <code>P(x)</code>.</p>

<p>What about <code>∃x ∈ X.P(x)</code>? We need any member of <code>X</code>, <code>x</code>, together with a proof of <code>P(x)</code>. So members (proofs) of the type (proposition) <code>∃x : X.P(x)</code> are &#39;dependent pairs&#39;: a distinguished term <code>x</code> in <code>X</code>, together with a term of type <code>P(x)</code>.</p>

<p>Notation:
I will use</p>

<pre><code>∀x ∈ X...
</code></pre>

<p>for actual statements about members of the class <code>X</code>, and</p>

<pre><code>∀x : X...
</code></pre>

<p>for type expressions corresponding to universal quantification over type <code>X</code>. Likewise for <code>∃</code>.</p>

<h2>Combinatorial considerations: products and sums</h2>

<p>As well as the Curry-Howard correspondence of types with propositions, we have the combinatorial correspondence of algebraic types with numbers and functions, which is the main point of this question. Happily, this can be extended to the dependent types outlined above!</p>

<p>I will use the modulus notation</p>

<pre><code>|A|
</code></pre>

<p>to represent the &#39;size&#39; of a type <code>A</code>, to make explicit the correspondence outlined in the question, between types and numbers. Note that this is a concept outside of the theory; I do not claim that there need be any such operator within the language.</p>

<p>Let us count the possible (fully reduced, canonical) members of type</p>

<pre><code>∀x : X.P(x)
</code></pre>

<p>which is the type of dependent functions taking terms <code>x</code> of type <code>X</code> to terms of type <code>P(x)</code>. Each such function must have an output for every term of <code>X</code>, and this output must be of a particular type. For each <code>x</code> in <code>X</code>, then, this gives <code>|P(x)|</code> &#39;choices&#39; of output.</p>

<p>The punchline is</p>

<pre><code>|∀x : X.P(x)| = Π[x : X]|P(x)|
</code></pre>

<p>which of course doesn&#39;t make huge deal of sense if <code>X</code> is <code>IO ()</code>, but is applicable to algebraic types.</p>

<p>Similarly, a term of type</p>

<pre><code>∃x : X.P(x)
</code></pre>

<p>is the type of pairs <code>(x, p)</code> with <code>p : P(x)</code>, so given any <code>x</code> in <code>X</code> we can construct an appropriate pair with any member of <code>P(x)</code>, giving <code>|P(x)|</code> &#39;choices&#39;.</p>

<p>Hence,</p>

<pre><code>|∃x : X.P(x)| = Σ[x : X]|P(x)|
</code></pre>

<p>with the same caveats.</p>

<p>This justifies the common notation for dependent types in theories using the symbols <code>Π</code> and <code>Σ</code>, and indeed many theories blur the distinction between &#39;for all&#39; and &#39;product&#39; and between &#39;there is&#39; and &#39;sum&#39;, due to the above-mentioned correspondences.</p>

<p>We are getting close!</p>

<h2>Vectors: representing dependent tuples</h2>

<p>Can we now encode numerical expressions like</p>

<pre><code>Σ[n ∈ ℕ]Xⁿ
</code></pre>

<p>as type expressions?</p>

<p>Not quite. While we can informally consider the meaning of expressions like <code>Xⁿ</code> in Haskell, where <code>X</code> is a type and <code>n</code> a natural number, it&#39;s an abuse of notation; this is a type expression containing a number: distinctly <em>not</em> a valid expression.</p>

<p>On the other hand, with dependent types in the picture, types containing numbers is precisely the point; in fact, dependent tuples or &#39;vectors&#39; are a very commonly-cited example of how dependent types can provide <a href="https://www.schoolofhaskell.com/user/konn/prove-your-haskell-for-great-safety/dependent-types-in-haskell" rel="noreferrer">pragmatic type-level safety for operations like list access</a>. A vector is just a list along with type-level information regarding its length: precisely what we are after for type expressions like <code>Xⁿ</code>.</p>

<p>For the duration of this answer, let</p>

<pre><code>Vec X n
</code></pre>

<p>be the type of length-<code>n</code> vectors of <code>X</code>-type values.</p>

<p>Technically <code>n</code> here is, rather than an <em>actual</em> natural number, a representation in the system of a natural number. We can represent natural numbers (<code>Nat</code>) in Peano style as either zero (<code>0</code>) or the successor (<code>S</code>) of another natural number, and for <code>n ∈ ℕ</code> I write <code>˻n˼</code> to mean the term in <code>Nat</code> which represents <code>n</code>. For example, <code>˻3˼</code> is <code>S (S (S 0))</code>.</p>

<p>Then we have</p>

<pre><code>|Vec X ˻n˼| = |X|ⁿ
</code></pre>

<p>for any <code>n ∈ ℕ</code>.</p>

<h2>Nat types: promoting ℕ terms to types</h2>

<p>Now we can encode expressions like</p>

<pre><code>Σ[n ∈ ℕ]Xⁿ
</code></pre>

<p>as types. This particular expression would give rise to a type which is of course isomorphic to the type of lists of <code>X</code>, as identified in the question. (Not only that, but from a category-theoretic point of view, the type function - which is a functor - taking <code>X</code> to the above type is <a href="https://en.m.wikipedia.org/wiki/Natural_transformation" rel="noreferrer"><em>naturally</em> isomorphic</a> to the List functor.)</p>

<p>One final piece of the puzzle for &#39;arbitrary&#39; functions is how to encode, for</p>

<pre><code>f : ℕ → ℕ
</code></pre>

<p>expressions like</p>

<pre><code>Σ[n ∈ ℕ]f(n)Xⁿ
</code></pre>

<p>so that we can apply arbitrary coefficients to a power series.</p>

<p>We already understand the correspondence of algebraic types with numbers, allowing us to map from types to numbers and type functions to numerical functions. We can also go the other way! - taking a natural number, there is obviously a definable algebraic type with that many term members, whether or not we have dependent types. We can easily prove this <em>outside</em> of the type theory by induction. What we need is a way to map from natural numbers to types, <em>inside</em> the system.</p>

<p>A pleasing realisation is that, once we have dependent types, proof by induction and construction by recursion become intimately similar - indeed they are the very same thing in many theories. Since we can prove by induction that types exist which fulfil our needs, should we not be able to construct them?</p>

<p>There are several ways to represent types at the term level. I will use here an imaginary Haskellish notation with <code>*</code> for the universe of types, itself usually considered a type in a dependent setting.<sup>1</sup></p>

<p>Likewise, there are also at least as many ways to notate &#39;<code>ℕ</code>-elimination&#39; as there are dependent type theories. I will use a Haskellish pattern-matching notation.</p>

<p>We need a mapping, <code>α</code> from <code>Nat</code> to <code>*</code>, with the property</p>

<pre><code>∀n ∈ ℕ.|α ˻n˼| = n.
</code></pre>

<p>The following pseudodefinition suffices.</p>

<pre><code>data Zero -- empty type
data Successor a = Z | Suc a -- Successor ≅ Maybe

α : Nat -&gt; *
α 0 = Zero
α (S n) = Successor (α n)
</code></pre>

<p>So we see that the action of <code>α</code> mirrors the behaviour of the successor <code>S</code>, making it a kind of homomorphism. <code>Successor</code> is a type function which &#39;adds one&#39; to the number of members of a type; that is, <code>|Successor a| = 1 + |a|</code> for any <code>a</code> with a defined size.</p>

<p>For example <code>α ˻4˼</code> (which is <code>α (S (S (S (S 0))))</code>), is</p>

<pre><code>Successor (Successor (Successor (Successor Zero)))
</code></pre>

<p>and the terms of this type are</p>

<pre><code>Z
Suc Z
Suc (Suc Z)
Suc (Suc (Suc Z))
</code></pre>

<p>giving us exactly four elements: <code>|α ˻4˼| = 4</code>.</p>

<p>Likewise, for any <code>n ∈ ℕ</code>, we have</p>

<pre><code>|α ˻n˼| = n
</code></pre>

<p>as required.</p>

<ol>
<li><em>Many theories require that the members of <code>*</code> are mere representatives of types, and an operation is provided as an explicit mapping from terms of type <code>*</code> to their associated types. Other theories permit the literal types themselves to be term-level entities.</em></li>
</ol>

<h2>&#39;Arbitrary&#39; functions?</h2>

<p>Now we have the apparatus to express a fully general power series as a type!</p>

<p>The series</p>

<pre><code>Σ[n ∈ ℕ]f(n)Xⁿ
</code></pre>

<p>becomes the type</p>

<pre><code>∃n : Nat.α (˻f˼ n) × (Vec X n)
</code></pre>

<p>where <code>˻f˼ : Nat → Nat</code> is some suitable representation within the language of the function <code>f</code>. We can see this as follows.</p>

<pre><code>|∃n : Nat.α (˻f˼ n) × (Vec X n)|
    = Σ[n : Nat]|α (˻f˼ n) × (Vec X n)|          (property of ∃ types)
    = Σ[n ∈ ℕ]|α (˻f˼ ˻n˼) × (Vec X ˻n˼)|        (switching Nat for ℕ)
    = Σ[n ∈ ℕ]|α ˻f(n)˼ × (Vec X ˻n˼)|           (applying ˻f˼ to ˻n˼)
    = Σ[n ∈ ℕ]|α ˻f(n)˼||Vec X ˻n˼|              (splitting product)
    = Σ[n ∈ ℕ]f(n)|X|ⁿ                           (properties of α and Vec)
</code></pre>

<p>Just how &#39;arbitrary&#39; is this? We are limited not only to integer coefficients by this method, but to natural numbers. Apart from that, <code>f</code> can be anything at all, given a <a href="https://en.m.wikipedia.org/wiki/Turing_completeness" rel="noreferrer">Turing Complete</a> language with dependent types, we can represent any analytic function with natural number coefficients.</p>

<p>I haven&#39;t investigated the interaction of this with, for example, the case provided in the question of <code>List X ≅ 1/(1 - X)</code> or what possible sense such negative and non-integer &#39;types&#39; might have in this context.</p>

<p>Hopefully this answer goes some way to exploring how far we can go with arbitrary type functions.</p>
    </div></div>
  </body>
</html>
