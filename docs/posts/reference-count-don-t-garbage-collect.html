<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kevinlawler.com/refcount">Original</a>
    <h1>Reference count, don&#39;t garbage collect</h1>
    
    <div id="readability-page-1" class="page"><section>

<p>The basic rule of thumb is: if you have the option of reference counting, it&#39;s going to beat garbage collection, hands down. But there are a few scenarios where reference counting is not going to be available to you. Primarily I would guess these fall into the categories of:

</p><ol>
  <li><p>You have a buggy binary (or codebase) whose malloc library you want to replace with a GC because <code>malloc/free/new/delete</code> are being used incorrectly and swapping the library is simpler than fixing the code.</p></li>

  <li><p>You made an imperative object-oriented or scripting language, you want automatic memory management, you want object mutability, you want shallow references, you want reference cycles, you don&#39;t want any hint of cycle detection, you don&#39;t want weak pointers, and you&#39;re willing to pay a walloping performance penalty to have this configuration.

  </p><p>Note that this is a very specific case. In array languages, which are functional and not imperative, we typically don&#39;t garbage collect at all. You can see one method of acyclic reference counting <a href="https://github.com/kevinlawler/kerf1/tree/master/src">here</a> or <a href="https://github.com/kevinlawler/kerf">here</a>.</p></li>
</ol>

<h2>History</h2>

<p>I&#39;m not going to do a real history of GC, but I&#39;ll share what my experience with it has been since the 90s. A long time ago we had C and C++, and the problem with that was they used <code>malloc</code> or <code>new</code>, and programmers had a hard time managing this. Fair enough, they&#39;re tricky and it&#39;s easy to leak memory or whatnot. So, many of the languages that were released afterwards wanted to make programming easier, in part by adding automatic memory management. There are a lot of corner cases in automatic memory management, and one sure way to hammer them all down is to use an old piece of technology known as a garbage collector. Garbage collectors appeared in many higher level languages, perhaps most famously in Java. What we learned later from these deployments was that garbage collection is bad for performance. It&#39;s slow, it happens at random times, it can be long running, it touches all of the data in your app, etc. The promise of the GC was that programmers would not have to spend time debugging memory leaks and other such issues, but I witnessed deployments where probably as much developer time was spent tuning an uncontrollable GC; a GC, which, in addition, made other goals impossible, because it necessitated bad and unpredictable performance when steady and predictable performance was required. &#34;See this giant spike in the resource graph? This is where the garbage collector turned on.&#34;

</p><p>In the meantime, because GCs seemed to solve the problem of automatic memory management, a lot of research continued in this area and a lot of students were taught about the merits of garbage collection. Later on, as real deployments struggled with performance issues inherent in garbage collection, other people remembered the technique of reference counting and found ways to institute it in their language, potentially making small sacrifices to do so. Reference counting is a lot faster and doesn&#39;t have a long-running background process. Provided your problem admits certain concessions that let you retreat from full-on garbage collection into reference counting, you&#39;re going to come out way ahead in the bargain. Objective-C and Swift use a nearly transparent form of reference counting which requires the use of weak pointers to avoid cycles. Python doesn&#39;t want to add weak types to pointers, so it reference counts whatever it doesn&#39;t need to garbage collect, and the only thing it needs to garbage collect are the few objects capable of forming cycles. Functional languages can often depend on immutability to simply reference count without worrying about garbage collection at all. 

</p><h2>Misconceptions</h2>

<p>Because of the hangover from the preceding decades, there are still a lot of people around who think that garbage collection is a praiseworthy critical feature instead of sometimes-necessary evil. Here&#39;s this mistaken site that appeared on Hacker News: 

</p><p><a href="https://www.memorymanagement.org/mmref/faq.html#mmref-faq">https://www.memorymanagement.org/mmref/faq.html#mmref-faq</a>
</p><p>This thing is highly voted and has appeared many times over the years, so I feel confident in asserting it represents commonly held misconceptions in the field.

</p><p>I&#39;ll do a point-by-point refutation of their claims, since even though I think RC being on the defensive makes it sound like there is more of a case for GC than there is, the refutation is illustrative of the mechanics behinds the pros and cons of using reference counting in your application.

</p><p>Promoting garbage collection over reference counting is ridiculous, a bit like lobbying for hopping on one foot over running as a technique for racing. Hey, what if you broke your ankle the day before, then you might have to hop, right? What if you stepped on a piece of glass, huh? What if it&#39;s field day and you&#39;re not allowed to use your leg? And so on.

</p><p>Here&#39;s what their FAQ says:

</p><blockquote>
<p><code>Isn’t it much cheaper to use reference counts rather than garbage collection?</code>

</p><p>No, updating reference counts is quite expensive, and they have a couple of problems:

</p><p>They can’t cope with cyclic data structures; that is, sets of objects that are referred to only by objects in that set, but that don’t have a zero reference count.

</p><p>Reference counting gets more expensive if you have to allow for the count overflowing.

</p><p>There are many systems that use reference counts, and avoid the problems described above by using a conventional garbage collector to complement it. This is usually done for real-time benefits. Unfortunately, experience shows that this is generally less efficient than implementing a proper real-time garbage collector, except in the case where most reference counts are one.
</p>
</blockquote>

<p>Let&#39;s do a point by point:

</p><p>1. <em>Updating reference counts is quite expensive.</em>

</p><p>No, it isn&#39;t. It&#39;s an atomic increment, perhaps with overflow checks for small integer widths. This is about as minimal as you can get short of nothing at all. The comparison is the ongoing garbage collection routine, which is going to be more expensive and occur unpredictably.

</p><p>Increments and decrements happen once and at a predictable time. The GC is running all the time and traversing the universe of GC objects. Probably with bad locality, polluting the cache, etc.

</p><p>Arguing this is just weird. This is what I am talking about with the hopping on one foot. 

</p><p>2. <em>They can’t cope with cyclic data structures; that is, sets of objects that are referred to only by objects in that set, but that don’t have a zero reference count.</em>

</p><p>This is the only gripe with any merit. Arguably, this is the reason we have garbage collectors in the first place, because people got hung up on this issue before there was a better solution. Then they just kept building more garbage collectors.

</p><p>In functional languages cyclic data structures aren&#39;t an issue because data is &#34;immutable.&#34; You do a cycle-check at creation time and either error or split out a copy and reference that. RC still wins because the GC is going to have to make this traversal at least once anyway—this is game over for GC, there&#39;s no coming back from it. Performance-wise, a deep object cycle tends to be pathological, so it doesn&#39;t hurt your RC guarantees to check it.

</p><p>In object-oriented languages, where you can literally have a pointer to something, you simply mark a reference as a weak reference if it might create a cycle. Cycles are still detectable at runtime and I think even at compile-time, so it&#39;s not going to be a surprise like with leaked memory. You get all the benefits of automatic memory management in your code, but you&#39;ve made one concession to memory management instead of importing the slowness of GC. Apple did this with ARC and pretty much nobody had a problem with it. The whole point was putting this one requirement back on the developers was far and away worth it to avoid the garbage collector.

</p><p>You might tell me there are some OO developers who can&#39;t handle even this small amount of reference management, but I would say they&#39;re in a scripting language with a hidden notion of &#34;shallow&#34; and &#34;deep&#34; copies, and so they&#39;re already doing it or they&#39;re blissfully unaware and screwing it up anyway.

</p><p>Python uses a GC here but I wonder how the language would&#39;ve fared from the beginning with a runtime cycle checker instead.


</p><p>3. <em>Reference counting gets more expensive if you have to allow for the count overflowing.</em>

</p><p>Not really. With an 8-byte counter you will never overflow. So...you know...just expand up to 8-bytes as needed? Usually you can get by with a few bits.

</p><p>Overflow is typically a pathological case, so pathological that I hesitate to treat it because it gives a legitimacy to their claim that isn&#39;t there. The dominant pattern is that objects have only a few references. Like, 1 or 3, not 2^63. So, OK, let&#39;s say you start doing something weird.

</p><p>If you must overflow, e.g., you cannot afford an 8-byte counter and you need to overflow a 4-byte counter with billions of references, if you can copy it, you create a shallow copy. (Is a GC program even usable at this point?) Should this actually happen, and I can&#39;t think of any time that it does, RC is still going to beat GC. Making a shallow copy during a pathological case handily beats running a garbage collector all the time.

</p><p>If you can&#39;t copy the object, well, when does this happen ever? Any non-static in-memory object that is being referenced (literally pointed to with a address pointer) millions of times <em>from millions of different places</em> is almost certainly an engineering flaw in any language. This is rightly in the class of error like &#34;I tried to malloc 128 exabytes&#34; or &#34;I created too many objects on the stack and it crashed&#34; or &#34;I ran out of open file handles&#34;—system concerns that you won&#39;t be able to avoid even from the comfort of your preferred scripting language. (Also, again, does a GC program even run here?) 

</p><p>The answer is really just &#34;use up to 8 bytes of counter when needed.&#34; 

</p><p>4. <em>Experience shows that this is generally less efficient than implementing a proper real-time garbage collector.</em>

</p><p>The opposite of my experience.

</p><h2>Conclusions</h2>
<p>I talked with a few garbage collectors to sanity check my thoughts on the subject and I can already see that there is, I suppose not surprisingly, a lot more arguing to do before the issue is settled.

</p><p>One of the arguments against my position is that it is arguing from experience, which is a fair critique. Every time I use GC it&#39;s slow and every time I use RC it&#39;s fast, and I&#39;m telling you this. There is no way GC can ever cover the ground because it is broken by design.

</p><p>I suppose my case would be stronger with controlled, randomized, double-blinded, and peer reviewed benchmarks, complete with video, showing that hopping on one foot is indeed slower. While I would like to believe this is true, I&#39;m sure I&#39;d have to argue even that. And then I&#39;d have to explain why the latest papers demonstrating new and faster methods of hopping on one foot aren&#39;t really correct in one way or the other. I think I&#39;d prefer to wait another ten or twenty years until this issue settles itself.

</p><p>If I had to guess the cause of this situation, I would say it is a psychological one, that generations of computer programmers have been taught the wrong thing, so that when you tell them their thing is straight busted and that there is an alternative way to do things, internally they can&#39;t conceive why they weren&#39;t taught the simpler and faster way, and so this leads them to make faulty assumptions about how the alternative method works, in order to justify all the work they put in to understand the original thing. 

</p><p>For instance, I think there is this misconception that reference counting <em>must</em> work somehow like read-lock acquisition for functions, where you acquire and release the lock every time you inspect the element with a function call. This is not true. Basically, you attach the reference to the object graph once, and then free it when you&#39;re done with it. Most of the time you&#39;re not touching the reference at all. While your element is in scope, you can create an arbitrarily high stack of functions pointing back to it with zero additional cost. But this leads to an interesting realization. Even garbage collection has to touch the item once, probably many times, and free it, but then that would imply RC could only be strictly better and faster, which implies...(<em>puzzled expression</em>). Yes, exactly. People don&#39;t want to believe this so they view it as the conclusion to a reductio ad absurdem: RC must work some other way. No, it does not.

</p><p>Reference counting sounds simple but even that simple bit is widely misinterpreted. On top of that, there&#39;s an entire discipline to using RC correctly, that is not widely known, and this technique is probably deep enough to teach in the schoolbooks, at equal or greater length to the time spent on garbage collection. But I don&#39;t recall any in-depth treatments like this. I&#39;ve just seen lots of <a href="http://craftinginterpreters.com/sample.pdf">treatises on garbage collecting that skim over the reference counting part</a>.

</p><p>I&#39;ve already stated I&#39;m not going to do benchmarks. I am aware of two orgs who&#39;ve already run extensive and far-reaching experiments on this: Apple, for use in their mobile phones, and the Python project. Apple&#39;s thing is self-explanatory, and actually it runs their entire platform, desktops included. But it has the wrinkle that they skipped from manual user reference counting to automatic reference counting without attempting garbage collecting in between because the GC was so terrible in Xcode, plus, you know, ARC requires more work from the developers, so it&#39;s not an airtight case here. The Python case is more inarguable. If GC is so good, <em>why wouldn&#39;t Python just garbage collect everything, which they already did once and could trivially do, instead of going through the hassle of implementing reference counting for everything but the one case I mentioned</em>? It is because RC outperforms garbage collecting in all these standard cases.

</p>
</section></div>
  </body>
</html>
