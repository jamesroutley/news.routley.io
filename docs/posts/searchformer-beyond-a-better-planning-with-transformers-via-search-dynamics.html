<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/facebookresearch/searchformer">Original</a>
    <h1>Searchformer: Beyond A* â€“ Better planning with transformers via search dynamics</h1>
    
    <div id="readability-page-1" class="page"><article><p><em>Brian Hicks, April 23, 2024</em></p><p>Just a little update on tinyping: I have a system that mostly works! Yay! It doesn&#39;t do reporting, but it&#39;ll alert you about new pings correctly.</p><p>This actually doesn&#39;t feel like a huge win to me because it&#39;s so, so messy. I&#39;m still using Automerge for this, and I think it&#39;s a solid decision, but taking the distributed nature of the system into account while building this has been both tricky and instructive.</p><span id="continue-reading"></span><p>Anyway, while making what I have of tinyping so far, I kept running into issues with syncing information across the Elm/TS boundary. It&#39;s really annoying to have to update the types on both sides. This has bugged me for a while across multiple projects, even at work, so I decided to dive down the rabbit hole and try to fix this. Here&#39;s a preview in the form of the current README of the project:</p><hr/><p>Elm is great, and TypeScript is great, but the flags and ports between them are hard to use safely. They&#39;re the only part of the a system between those two languages that aren&#39;t typed by default.</p><p>You can get around this in various ways, of course, either by maintaining a definitions by hand or generating one side from the other. In general, though, you run into a couple different issues:</p><ul><li>It&#39;s easy for one side or the other to get out of date and errors to slip through CI and code review into production.</li><li>Definitions in one language may not be translatable to the other (despite the two type systems having pretty good overlap.)</li></ul><p><code>elm-duet</code> tries to get around this by creating a single source of truth to generate both TypeScript definitions and Elm types with decoders. We use <a href="https://jsontypedef.com/">JSON Type Definitions</a> (JTD, <a href="https://jsontypedef.com/docs/jtd-in-5-minutes/">five-minute tutorial</a>) to say precisely what we want and generate ergonomic types on both sides (plus helpers like encoders to make testing easy!)</p><p>Here&#39;s an example for an app that stores a <a href="https://jwt.io/">jwt</a> in <code>localStorage</code> or similar to present to Elm:</p><pre data-lang="json"><code data-lang="json"><span>{
</span><span>  </span><span>&#34;modules&#34;</span><span>: {
</span><span>    </span><span>&#34;Main&#34;</span><span>: {
</span><span>      </span><span>&#34;flags&#34;</span><span>: {
</span><span>        </span><span>&#34;properties&#34;</span><span>: {
</span><span>          </span><span>&#34;currentJwt&#34;</span><span>: {
</span><span>            </span><span>&#34;type&#34;</span><span>: </span><span>&#34;string&#34;</span><span>,
</span><span>            </span><span>&#34;nullable&#34;</span><span>: </span><span>true
</span><span>          }
</span><span>        }
</span><span>      },
</span><span>      </span><span>&#34;ports&#34;</span><span>: {
</span><span>        </span><span>&#34;newJwt&#34;</span><span>: {
</span><span>          </span><span>&#34;metadata&#34;</span><span>: {
</span><span>            </span><span>&#34;direction&#34;</span><span>: </span><span>&#34;ElmToJs&#34;
</span><span>          },
</span><span>          </span><span>&#34;type&#34;</span><span>: </span><span>&#34;string&#34;
</span><span>        },
</span><span>        </span><span>&#34;logout&#34;</span><span>: {
</span><span>          </span><span>&#34;metadata&#34;</span><span>: {
</span><span>            </span><span>&#34;direction&#34;</span><span>: </span><span>&#34;ElmToJs&#34;
</span><span>          }
</span><span>        }
</span><span>      }
</span><span>    }
</span><span>  }
</span><span>}
</span><span>
</span></code></pre><p>You can generate code from this by calling <code>elm-duet path/to/your/schema.json</code>:</p><pre><code><span>$ elm-duet examples/jwt_schema.json --typescript-dest examples/jwt_schema.ts
</span><span>wrote examples/jwt_schema.ts
</span></code></pre><p>Which results in this schema:</p><pre data-lang="typescript"><code data-lang="typescript"><span>// Warning: this file is automatically generated. Don&#39;t edit by hand!
</span><span>
</span><span>declare module </span><span>Elm {
</span><span>  </span><span>namespace </span><span>Main {
</span><span>    </span><span>type </span><span>Flags </span><span>= </span><span>{
</span><span>      </span><span>currentJwt</span><span>: </span><span>string </span><span>| </span><span>null;
</span><span>    }
</span><span>
</span><span>    </span><span>type </span><span>Ports </span><span>= </span><span>{
</span><span>      </span><span>logout</span><span>: </span><span>{
</span><span>        </span><span>subscribe</span><span>: </span><span>(</span><span>callback</span><span>: </span><span>(</span><span>value</span><span>: </span><span>Record&lt;string, never&gt;) </span><span>=&gt; </span><span>void) </span><span>=&gt; </span><span>void;
</span><span>      };
</span><span>      </span><span>newJwt</span><span>: </span><span>{
</span><span>        </span><span>subscribe</span><span>: </span><span>(</span><span>callback</span><span>: </span><span>(</span><span>value</span><span>: </span><span>string) </span><span>=&gt; </span><span>void) </span><span>=&gt; </span><span>void;
</span><span>      };
</span><span>    }
</span><span>
</span><span>    </span><span>function </span><span>init</span><span>(</span><span>config</span><span>: </span><span>{
</span><span>      </span><span>flags</span><span>: </span><span>Flags;
</span><span>      </span><span>node</span><span>: </span><span>HTMLElement;
</span><span>    })</span><span>: </span><span>void
</span><span>  }
</span><span>}
</span></code></pre><p>(Elm code generation is currently TODO.)</p><p>Here&#39;s the full help to give you an idea of what you can do with the tool:</p><pre><code><span>$ elm-duet --help
</span><span>Generate Elm and TypeScript types from a single shared definition.
</span><span>
</span><span>Usage: elm-duet [OPTIONS] &lt;SOURCE&gt;
</span><span>
</span><span>Arguments:
</span><span>  &lt;SOURCE&gt;  Location of the definition file
</span><span>
</span><span>Options:
</span><span>      --typescript-dest &lt;TYPESCRIPT_DEST&gt;  Destination for TypeScript types [default: elm.ts]
</span><span>      --elm-dest &lt;ELM_DEST&gt;                Destination for Elm types [default: src/]
</span><span>      --elm-prefix &lt;ELM_PREFIX&gt;            Prefix for Elm module path [default: Interop]
</span><span>  -h, --help                               Print help
</span><span>  -V, --version                            Print version
</span><span>
</span></code></pre></article></div>
  </body>
</html>
