<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://danlark.org/2022/04/20/changing-stdsort-at-googles-scale-and-beyond/">Original</a>
    <h1>Changing std:sort at Google’s scale and beyond</h1>
    
    <div id="readability-page-1" class="page"><div>
		
<p>TL;DR; We <a href="https://reviews.llvm.org/D122780" target="_blank" rel="noreferrer noopener">are changing</a> <code>std::sort</code> in LLVM’s libcxx. That’s a long story of what it took us to get there and all possible consequences, bugs you might encounter with examples from open source. We provide some benchmarks, perspective, why we did this in the first place and what it cost us with exciting ideas from Hyrum’s Law to reinforcement learning. All changes went into open source and thus I can freely talk about all of them.</p>



<p>This article is split into 3 parts, the first is history with all details of recent (and not so) past of sorting in C++ standard libraries. Second part is about what it takes to switch from one sorting algorithm to another with various bugs. The final one is about the implementation we have chosen with all optimizations we have done.</p>







<p>Sorting algorithms have been extensively researched since the start of computer science.<sup><a href="#footnotes">1</a></sup> Specifically, people tried to optimize the number of comparisons on average, in the worst case, in certain cases like partially sorted data. There is even a sorting algorithm that is based on machine learning<sup><a href="#footnotes">2</a></sup> — it tries to predict the position where the elements should go with pretty impressive benchmarks! One thing is clear—sorting algorithms do evolve even now with better constant factors and reduced number of comparisons made.</p>



<p>In every programming language, sorting calls exist and it’s up to the library to decide which one to use, we’ll talk about different choices in languages later. There are still debates over which sorting is the best on Hackernews<sup><a href="#footnotes">3</a></sup>, papers<sup><a href="#footnotes">4</a></sup>, repos<sup><a href="#footnotes">5</a></sup>.</p>



<p>As Donald Knuth said</p>



<blockquote><p><em>It would be nice if only one or two of the sorting methods would dominate all of the others, regardless of application or the computer being used. But in fact, each method has its own peculiar virtues. […] Thus we find that nearly all of the algorithms deserve to be remembered, since there are some applications in which they turn out to be best.</em> </p><cite>— Donald Knuth, The Art Of Computer Programming, Volume 3</cite></blockquote>



<h2>C++ history</h2>



<p><code>std::sort</code> has been in C++ since the invention of so-called “STL” by Alexander Stepanov<sup><a href="#footnotes">9</a></sup> and C++ standard overall got an interesting innovation back then called “complexity”. At the time the complexity was set to being <img src="https://s0.wp.com/latex.php?latex=O%28n+%5Clog+n%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=O%28n+%5Clog+n%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=O%28n+%5Clog+n%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="O(n \log n)"/> comparisons <em>on average</em>. We know from Computer Science courses that <em><a href="https://en.wikipedia.org/wiki/Quicksort">quicksort</a></em> is <img src="https://s0.wp.com/latex.php?latex=O%28n+%5Clog+n%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=O%28n+%5Clog+n%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=O%28n+%5Clog+n%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="O(n \log n)"/> comparisons <em>on average</em>, right? This algorithm was first implemented in the original STL.</p>



<h3>How was really the first <code>std::sort</code> implemented?</h3>



<p>It used a simple quicksort with a median of 3 (median from (first, middle, last) elements). Once the recursion hits less than 16 elements, it bails out and at the end uses insertion sort as it is believed to work faster for small arrays.</p>



<p>You can see the last stage where it tries to “smooth out” inaccurate blocks of size 16.</p>



<figure></figure>



<h2>A minor problem with quicksort</h2>



<p>Well, that’s definitely true that quicksort has <img src="https://s0.wp.com/latex.php?latex=O%28n+%5Clog+n%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=O%28n+%5Clog+n%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=O%28n+%5Clog+n%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="O(n \log n)"/> on average complexity, however, C++ STL may accept third parameter, called <em><strong>comp</strong></em> function:</p>



<figure><img data-attachment-id="792" data-permalink="https://danlark.org/image-3/" data-orig-file="https://danlarkorg.files.wordpress.com/2022/04/image-3.png" data-orig-size="1391,268" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-3" data-image-description="" data-image-caption="" data-medium-file="https://danlarkorg.files.wordpress.com/2022/04/image-3.png?w=300" data-large-file="https://danlarkorg.files.wordpress.com/2022/04/image-3.png?w=750" src="https://danlarkorg.files.wordpress.com/2022/04/image-3.png?w=1024" alt="" srcset="https://danlarkorg.files.wordpress.com/2022/04/image-3.png?w=1024 1024w, https://danlarkorg.files.wordpress.com/2022/04/image-3.png?w=150 150w, https://danlarkorg.files.wordpress.com/2022/04/image-3.png?w=300 300w, https://danlarkorg.files.wordpress.com/2022/04/image-3.png?w=768 768w, https://danlarkorg.files.wordpress.com/2022/04/image-3.png 1391w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>This actually gives us an opportunity to self-modify the array, or, in other words, make decisions along the way the <strong><em>comp</em></strong> function is called, and introduce a worst time complexity on any data. The code below will make sense in a little while:</p>



<figure><div>
<div id="gist115563329">
    <div translate="no">
      <div>
        <div>
  <div id="file-quadratic-cpp">
    
  <div itemprop="text">

      
<div>

  <template>
  <div data-view-component="true">
  <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
  
    <p><span>
      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
      <a href="https://github.co/hiddenchars" target="_blank">Learn more about bidirectional Unicode characters</a>
    </span></p>
</div></template>
<template>
  <span aria-label="This line has hidden Unicode characters" data-view-component="true">
    <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
</span></template>

  
</div>


  </div>

  </div>
</div>

      </div>
      
    </div>
</div>

</div></figure>



<p>If we consider any <em>quick sort algorithm</em> with the following semantics:</p>



<ol><li>Find some pivot <img src="https://s0.wp.com/latex.php?latex=X&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=X&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=X&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="X"/> among <img src="https://s0.wp.com/latex.php?latex=C&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=C&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=C&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="C"/> elements (constant number)</li><li>Partition by pivot, recurse on both sides</li></ol>



<p>“gas” value represents unknown, infinity, the value is set to the left element only when two unknown elements are compared, and if one element is gas, then it is always greater.</p>



<p>At the first step you pick some pivot among at most <img src="https://s0.wp.com/latex.php?latex=C&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=C&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=C&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="C"/> elements. While partitioning, all other <img src="https://s0.wp.com/latex.php?latex=n+-+C&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=n+-+C&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=n+-+C&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="n - C"/> elements will be to the right of the pivot.</p>



<p>At step <img src="https://s0.wp.com/latex.php?latex=i&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=i&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=i&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="i"/> you know the relation of at most <img src="https://s0.wp.com/latex.php?latex=C%5Ccdot+i&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=C%5Ccdot+i&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=C%5Ccdot+i&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="C\cdot i"/> elements and all <img src="https://s0.wp.com/latex.php?latex=n-C%5Ccdot+i&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=n-C%5Ccdot+i&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=n-C%5Ccdot+i&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="n-C\cdot i"/> elements will still be partitioned to the right. Take <img src="https://s0.wp.com/latex.php?latex=i&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=i&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=i&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="i"/> equals <img src="https://s0.wp.com/latex.php?latex=n%2F2C&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=n%2F2C&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=n%2F2C&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="n/2C"/> and you already have quadratic behavior.</p>



<p>If we run this code against the original STL<sup><a href="#footnotes">10</a></sup>, we clearly are having a quadratic number of comparisons.</p>



<figure><div>
<div id="gist115581436">
    <div translate="no">
      <div>
        <div>
  <div id="file-comparison_count-cpp">
    
  <div itemprop="text">

      
<div>

  <template>
  <div data-view-component="true">
  <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
  
    <p><span>
      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
      <a href="https://github.co/hiddenchars" target="_blank">Learn more about bidirectional Unicode characters</a>
    </span></p>
</div></template>
<template>
  <span aria-label="This line has hidden Unicode characters" data-view-component="true">
    <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
</span></template>

  
</div>


  </div>

  </div>
</div>

      </div>
      
    </div>
</div>

</div></figure>



<p>No matter which randomization we are going to introduce, even quicksort implementation of <code>std::sort</code> is quadratic on average (with respect to arbitrary comparator) and implementation technically is not compliant.</p>



<p>The example above does not try to prove something and is quite artificial, even though there were some problems with the wording in the standard regarding “average” case.</p>



<h2>Moving on with quadratic behavior</h2>



<p>Quicksort worst case testing was first introduced by Douglas McIlroy<sup><a href="#footnotes">11</a></sup> in 1998 and called <em>“Antiquicksort”</em>. In the end it influenced the decision to move <code>std::sort</code> complexity being worst case <img src="https://s0.wp.com/latex.php?latex=O%28n+%5Clog+n%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=O%28n+%5Clog+n%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=O%28n+%5Clog+n%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="O(n \log n)"/> rather than average which has been changed in the C++11 standard. The decision was partially made due to the fact there are lots of efficient <img src="https://s0.wp.com/latex.php?latex=O%28n+%5Clog+n%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=O%28n+%5Clog+n%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=O%28n+%5Clog+n%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="O(n \log n)"/> worst case sorts out there as well. </p>



<p>Well, however there is more to the story.</p>



<h2>Are modern C++ standard libraries actually compliant?</h2>



<p>There are not so many places C++ standard specifies the wording “<em>on average</em>“. One more example is <code>std::nth_element</code> call.</p>



<h3>What is <code>std::nth_element</code>?</h3>



<p>You might guess it finds the <code>nth element</code> in the range. More specifically <code>std::nth_element(first, nth, last, comp)</code> is a partial sorting algorithm that rearranges elements in a range such that:</p>



<ul><li>The element pointed at by <code>nth</code> is changed to whatever element would occur in that position if <code>[first, last)</code> were sorted.</li><li>All of the elements before this new <code>nth</code> element are less than or equal to the elements after the new <code>nth</code> element.</li></ul>



<p> You can see that the complexity still states “<em>on average</em>“.</p>



<figure><img data-attachment-id="805" data-permalink="https://danlark.org/image-4/" data-orig-file="https://danlarkorg.files.wordpress.com/2022/04/image-4.png" data-orig-size="1305,105" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-4" data-image-description="" data-image-caption="" data-medium-file="https://danlarkorg.files.wordpress.com/2022/04/image-4.png?w=300" data-large-file="https://danlarkorg.files.wordpress.com/2022/04/image-4.png?w=750" src="https://danlarkorg.files.wordpress.com/2022/04/image-4.png?w=1024" alt="" srcset="https://danlarkorg.files.wordpress.com/2022/04/image-4.png?w=1024 1024w, https://danlarkorg.files.wordpress.com/2022/04/image-4.png?w=150 150w, https://danlarkorg.files.wordpress.com/2022/04/image-4.png?w=300 300w, https://danlarkorg.files.wordpress.com/2022/04/image-4.png?w=768 768w, https://danlarkorg.files.wordpress.com/2022/04/image-4.png 1305w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>This decision was in place due to the existing quickselect<sup><a href="#footnotes">12</a></sup> algorithm. However, this algorithm is susceptible to the same trickery for both GNU and LLVM implementations.</p>



<figure><img data-attachment-id="824" data-permalink="https://danlark.org/image-6/" data-orig-file="https://danlarkorg.files.wordpress.com/2022/04/image-6.png" data-orig-size="1214,831" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-6" data-image-description="" data-image-caption="" data-medium-file="https://danlarkorg.files.wordpress.com/2022/04/image-6.png?w=300" data-large-file="https://danlarkorg.files.wordpress.com/2022/04/image-6.png?w=750" src="https://danlarkorg.files.wordpress.com/2022/04/image-6.png?w=1024" alt="" srcset="https://danlarkorg.files.wordpress.com/2022/04/image-6.png?w=1024 1024w, https://danlarkorg.files.wordpress.com/2022/04/image-6.png?w=150 150w, https://danlarkorg.files.wordpress.com/2022/04/image-6.png?w=300 300w, https://danlarkorg.files.wordpress.com/2022/04/image-6.png?w=768 768w, https://danlarkorg.files.wordpress.com/2022/04/image-6.png 1214w" sizes="(max-width: 1024px) 100vw, 1024px"/><figcaption><a href="https://gcc.godbolt.org/z/xqqqKWv4r" target="_blank" rel="noreferrer noopener">https://gcc.godbolt.org/z/xqqqKWv4r</a></figcaption></figure>



<p>For LLVM/clang version it’s obviously degrading to quadratic behavior, for GNU version <img src="https://s0.wp.com/latex.php?latex=2+%5Ccdot+n+%5Ccdot+%5Clog_2+n&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=2+%5Ccdot+n+%5Ccdot+%5Clog_2+n&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=2+%5Ccdot+n+%5Ccdot+%5Clog_2+n&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="2 \cdot n \cdot \log_2 n"/> for <img src="https://s0.wp.com/latex.php?latex=n+%3D+1600%2C3200%2C6400&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=n+%3D+1600%2C3200%2C6400&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=n+%3D+1600%2C3200%2C6400&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="n = 1600,3200,6400"/> is around <img src="https://s0.wp.com/latex.php?latex=34060%2C+74520%2C+161841&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=34060%2C+74520%2C+161841&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=34060%2C+74520%2C+161841&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="34060, 74520, 161841"/> which are very close to reported numbers. If you read carefully the implementation<sup><a href="#footnotes">13</a></sup>, you’ll see that the fallback algorithm uses heap select – by creating heap and extracting elements from it. And heap extraction is known to be logarithmic.</p>



<p>However, for finding <code>nth</code> element there are not so many worst case linear algorithms, one of them is median of medians<sup><a href="#footnotes">16</a></sup> which has a really bad constant. It took us around 20 years to find something really appropriate, thanks to Andrei Alexandrescu<sup><a href="#footnotes">14</a></sup> . My post on selection algorithms discussed that quite extensively but got too little attention in my humble opinion 🙂 (and it has an implementation from Andrei as well!). We found great speedups on real data for real SQL queries of type <code>SELECT * from table ORDER BY x LIMIT N</code>.</p>


<nav data-layout="grid"></nav>


<h2>What happened to <code>std::sort</code>?</h2>



<p>It started to use Introspective Sort, or, simply, introsort, upon too many levels of quicksort, more specifically <img src="https://s0.wp.com/latex.php?latex=2+%5Clog_2+n&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=2+%5Clog_2+n&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=2+%5Clog_2+n&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="2 \log_2 n"/>, fall back to heap sort, worst case known algorithm. Even Wikipedia has all good references<sup><a href="#footnotes">15</a></sup> regarding introsort implementations.</p>



<p>Here is the worst case sorting introsort for GNU implementation:</p>



<figure></figure>



<h2>LLVM history</h2>



<p>When LLVM tried to build C++0x version of STL, Howard Hinnant made a presentation<sup><a href="#footnotes">6</a></sup> on how it all was going with the implementation. Back then we recognized some really interesting benchmarks and more and more benchmarked sorts on different data patterns.</p>



<figure><img data-attachment-id="766" data-permalink="https://danlark.org/image/" data-orig-file="https://danlarkorg.files.wordpress.com/2022/04/image.png" data-orig-size="1163,795" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image" data-image-description="" data-image-caption="" data-medium-file="https://danlarkorg.files.wordpress.com/2022/04/image.png?w=300" data-large-file="https://danlarkorg.files.wordpress.com/2022/04/image.png?w=750" src="https://danlarkorg.files.wordpress.com/2022/04/image.png?w=1024" alt="" srcset="https://danlarkorg.files.wordpress.com/2022/04/image.png?w=1024 1024w, https://danlarkorg.files.wordpress.com/2022/04/image.png?w=150 150w, https://danlarkorg.files.wordpress.com/2022/04/image.png?w=300 300w, https://danlarkorg.files.wordpress.com/2022/04/image.png?w=768 768w, https://danlarkorg.files.wordpress.com/2022/04/image.png 1163w" sizes="(max-width: 1024px) 100vw, 1024px"/><figcaption>Howard Hinnant’s slide on sorting in 2010</figcaption></figure>



<p>That gave us one interesting thought when we found this slide on what makes a sorting successful and efficient. Clearly not all data is random and some patterns happen in prod, how important is it to balance or recognize it?</p>



<p>For example even at Google as we use lots of protobufs, there are frequent calls to <code>std::sort</code> which come from the proto library<sup><a href="#footnotes">7</a></sup> which sorts all tags of fields presented in the message:</p>



<div>
<div>
<div>
<div>
<figure><div>
<div id="gist115558198">
    <div translate="no">
      <div>
        <div>
  <div id="file-proto_sort-cpp">
    
  <div itemprop="text">

      
<div>

  <template>
  <div data-view-component="true">
  <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
  
    <p><span>
      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
      <a href="https://github.co/hiddenchars" target="_blank">Learn more about bidirectional Unicode characters</a>
    </span></p>
</div></template>
<template>
  <span aria-label="This line has hidden Unicode characters" data-view-component="true">
    <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
</span></template>

  
</div>


  </div>

  </div>
</div>

      </div>
      
    </div>
</div>

</div></figure>
</div>



<div>
<figure><div>
<div id="gist115558245">
    <div translate="no">
      <div>
        <div>
  <div id="file-message-proto">
    
  <div itemprop="text">

      
<div>

  <template>
  <div data-view-component="true">
  <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
  
    <p><span>
      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
      <a href="https://github.co/hiddenchars" target="_blank">Learn more about bidirectional Unicode characters</a>
    </span></p>
</div></template>
<template>
  <span aria-label="This line has hidden Unicode characters" data-view-component="true">
    <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
</span></template>

  
</div>


  </div>

  </div>
</div>

      </div>
      
    </div>
</div>

</div></figure>
</div>
</div>
</div>
</div>



<div><div>
<div>
<div>
<p>It makes a first quite important point: we need to recognize “almost sorted” patterns as they do happen. Obvious cases are ascending/descending, some easy mixes of those like pipes, and multiple consecutive increasing or decreasing runs. TL;DR; we did not do a very good job here but most modern algorithms do recognize quite obvious ones.</p>



<h2>Theory: presortedness</h2>



<p>Presortedness was first formally described in<sup><a href="#footnotes">8</a></sup>:</p>



<figure><img data-attachment-id="790" data-permalink="https://danlark.org/image-2/" data-orig-file="https://danlarkorg.files.wordpress.com/2022/04/image-2.png" data-orig-size="589,188" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-2" data-image-description="" data-image-caption="" data-medium-file="https://danlarkorg.files.wordpress.com/2022/04/image-2.png?w=300" data-large-file="https://danlarkorg.files.wordpress.com/2022/04/image-2.png?w=589" src="https://danlarkorg.files.wordpress.com/2022/04/image-2.png?w=589" alt="" srcset="https://danlarkorg.files.wordpress.com/2022/04/image-2.png 589w, https://danlarkorg.files.wordpress.com/2022/04/image-2.png?w=150 150w, https://danlarkorg.files.wordpress.com/2022/04/image-2.png?w=300 300w" sizes="(max-width: 589px) 100vw, 589px"/></figure>
</div>
</div>
</div></div>



<p>Condition 1 is a normalizer, condition 2 states that we should care only about comparisons and not elements, condition 3 shows that if you can sort a supersequence, you should be able to sort a subsequence in fewer amount of comparisons, condition 4 is an upper limit on sorted parts: you should be able to sort <img src="https://s0.wp.com/latex.php?latex=XY&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=XY&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=XY&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="XY"/> if you can sort <img src="https://s0.wp.com/latex.php?latex=X&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=X&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=X&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="X"/> and <img src="https://s0.wp.com/latex.php?latex=Y&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=Y&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=Y&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="Y"/>, condition 5 is a more general upper limit – you should be able to find position of <img src="https://s0.wp.com/latex.php?latex=a&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=a&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=a&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="a"/> in linear amount of comparisons.</p>



<p>There are many existing presortedness measures like</p>



<ul><li><em>m<sub>01</sub></em>: 1 if not sorted, 0 if sorted. A pretty stupid one.</li><li><em>Block</em>: Number of elements in a sequence that aren’t followed by the same element in the sorted sequence.</li><li><em>Mono</em>: Minimum number of elements that must be removed from <em>X</em> to obtain a sorted subsequence, which corresponds to |<em>X</em>| minus the size of the <a rel="noreferrer noopener" href="https://en.wikipedia.org/wiki/Longest_increasing_subsequence" target="_blank">longest non-decreasing subsequence</a> of <em>X</em>.</li><li><em>Dis</em>: Maximum distance determined by an inversion.</li><li><em>Runs</em>: number of non-decreasing runs in <em>X</em> minus one.</li><li>Etc</li></ul>



<p>Some presortedness measures are better than others, meaning if there exists an algorithm is optimal towards some measure (optimality means number of comparisons <img src="https://s0.wp.com/latex.php?latex=T%28X%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=T%28X%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=T%28X%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="T(X)"/> for all input <img src="https://s0.wp.com/latex.php?latex=X&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=X&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=X&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="X"/> behaves logarithmically on number on the inputs which have not bigger measure value: <img src="https://s0.wp.com/latex.php?latex=T%28X%29+%5Cleq++C%5Cmax%28X%2C+%5Clog%7C%5Cmathrm%7Bbelow%7D%28X%2C+M%29%7C%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=T%28X%29+%5Cleq++C%5Cmax%28X%2C+%5Clog%7C%5Cmathrm%7Bbelow%7D%28X%2C+M%29%7C%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=T%28X%29+%5Cleq++C%5Cmax%28X%2C+%5Clog%7C%5Cmathrm%7Bbelow%7D%28X%2C+M%29%7C%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="T(X) \leq  C\max(X, \log|\mathrm{below}(X, M)|)"/>), then it is also optimal towards another. And at this point, theory starts to differ much from reality. Theory found a nice “common” presortedness measure, it’s very complicated and out of scope for this article.</p>



<figure><p><a href="https://github.com/Morwenn/cpp-sort/wiki/images/mops-partial-ordering.png"><img src="https://github.com/Morwenn/cpp-sort/wiki/images/mops-partial-ordering.png"/></a>
</p><figcaption><a href="https://arxiv.org/pdf/1407.6183.pdf" target="_blank" rel="noreferrer noopener">https://arxiv.org/pdf/1407.6183.pdf</a></figcaption></figure>



<p>Unfortunately, among all measures above only Mono, Dis and Runs are linear time (others are <img src="https://s0.wp.com/latex.php?latex=%5COmega%28n+%5Clog+n%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5COmega%28n+%5Clog+n%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5COmega%28n+%5Clog+n%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="\Omega(n \log n)"/> and it’s an open question whether they have lower complexity). If you want to report some of these measures, you need to sample heavily or add extra <img src="https://s0.wp.com/latex.php?latex=%5COmega%28n+%5Clog+n%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5COmega%28n+%5Clog+n%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5COmega%28n+%5Clog+n%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="\Omega(n \log n)"/> to the sorting itself which is not great for performance. We could have done more work in that area but generally all we tried were microbenchmarks + several real world workloads.</p>



<p>Anyway, I guess you are tired of theory and let’s get to something more practical.</p>



<h2 id="sortsmall">LLVM history continues</h2>



<p>As LLVM libcxx was developed before C++11, the first version was also based on quicksort. What was the difference to the GNU sort?</p>



<p>The libcxx implementation handled a few particular cases specially. Collections of length 5 or less are sorted using special handwritten comparison based sortings.</p>



<div>
<div>
<figure><div>
<div id="gist115730564">
    <div translate="no">
      <div>
        <div>
  <div id="file-sort4-cpp">
    
  <div itemprop="text">

      
<div>

  <template>
  <div data-view-component="true">
  <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
  
    <p><span>
      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
      <a href="https://github.co/hiddenchars" target="_blank">Learn more about bidirectional Unicode characters</a>
    </span></p>
</div></template>
<template>
  <span aria-label="This line has hidden Unicode characters" data-view-component="true">
    <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
</span></template>

  
</div>


  </div>

  </div>
</div>

      </div>
      
    </div>
</div>

</div></figure>
</div>



<div>
<figure><div>
<div id="gist115730576">
    <div translate="no">
      <div>
        <div>
  <div id="file-sort5-cpp">
    
  <div itemprop="text">

      
<div>

  <template>
  <div data-view-component="true">
  <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
  
    <p><span>
      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
      <a href="https://github.co/hiddenchars" target="_blank">Learn more about bidirectional Unicode characters</a>
    </span></p>
</div></template>
<template>
  <span aria-label="This line has hidden Unicode characters" data-view-component="true">
    <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
</span></template>

  
</div>


  </div>

  </div>
</div>

      </div>
      
    </div>
</div>

</div></figure>
</div>
</div>



<p>Depending on the data type being sorted, collections of lengths up to 30 are sorted using insertion sort. Trivial types are easy to swap and assembly is quite good for them.</p>



<p>There is a special handling case for collections with most items being equal and for collections that are almost sorted. It tries to use insertion sort upon the limit of 8 transpositions: if during the outer loop we see more than 8 pair elements where <img src="https://s0.wp.com/latex.php?latex=x_i+%3E+x_%7Bi+%2B+1%7D&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=x_i+%3E+x_%7Bi+%2B+1%7D&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=x_i+%3E+x_%7Bi+%2B+1%7D&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="x_i &gt; x_{i + 1}"/>, we bail out to recursion, otherwise we sort it and don’t go there. That’s really great for almost sorted patterns.</p>



<figure><div>
<div id="gist115730721">
    <div translate="no">
      <div>
        <div>
  <div id="file-limited_ins_sort-cpp">
    
  <div itemprop="text">

      
<div>

  <template>
  <div data-view-component="true">
  <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
  
    <p><span>
      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
      <a href="https://github.co/hiddenchars" target="_blank">Learn more about bidirectional Unicode characters</a>
    </span></p>
</div></template>
<template>
  <span aria-label="This line has hidden Unicode characters" data-view-component="true">
    <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
</span></template>

  
</div>


  </div>

  </div>
</div>

      </div>
      
    </div>
</div>

</div></figure>



<figure><figcaption>LLVM libcxx sort on random input</figcaption></figure>



<p>However, if you look at ascending inputs, you can see libstdcxx does lots of unnecessary work compared to libcxx sort which matters in practice. First is literally running 4.5 times faster!</p>







<p>Last distinction was that the median of 5 was chosen when the number of elements in a quicksort partition is more than 1000. No more differences, for me the biggest impact of this sort is in trying to identify common patterns which is not cheap but gets lots of benefits for real world cases.</p>



<p>When we changed libstdcxx to libcxx at Google, we saw significant improvements (dozens of percent) spent in <code>std::sort</code>. From then, the algorithm hasn’t been changed, and the usage has been growing.</p>



<h2>Quadratic problem</h2>



<p>Given LLVM libcxx was developed for C++03, the first implementation targeted <em>on average</em> case we talked about earlier. That has been addressed several times in the past, in 2014, 2017, 2018<sup><a href="#footnotes">17, 18</a></sup>.</p>



<p>In the end we managed to submit an improvement same as GNU library has with introsort. We add an additional parameter to the algorithm that indicates the maximum depth of the recursion the algorithm can go, then the remaining sequence on that path is sorted using heapsort. The number of partitions allowed is set to <img src="https://s0.wp.com/latex.php?latex=2n+%5Clog_2+n&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=2n+%5Clog_2+n&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=2n+%5Clog_2+n&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="2n \log_2 n"/>.  Since heapsort’s worst case time complexity is <img src="https://s0.wp.com/latex.php?latex=O%28n+%5Clog+n%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=O%28n+%5Clog+n%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=O%28n+%5Clog+n%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="O(n \log n)"/>, the modified algorithm also has a worst case time complexity of <img src="https://s0.wp.com/latex.php?latex=O%28n+%5Clog+n%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=O%28n+%5Clog+n%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=O%28n+%5Clog+n%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="O(n \log n)"/>. This change<sup><a href="#footnotes">19</a></sup> has been committed to the LLVM trunk and released with LLVM 14.</p>



<figure><div>
<div id="gist115840213">
    <div translate="no">
      <div>
        <div>
  <div id="file-introsort_libcxx-h">
    
  <div itemprop="text">

      
<div>

  <template>
  <div data-view-component="true">
  <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
  
    <p><span>
      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
      <a href="https://github.co/hiddenchars" target="_blank">Learn more about bidirectional Unicode characters</a>
    </span></p>
</div></template>
<template>
  <span aria-label="This line has hidden Unicode characters" data-view-component="true">
    <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
</span></template>

  
</div>


  </div>

  </div>
</div>

      </div>
      
    </div>
</div>

</div></figure>



<h3>How many real world cases got there into heap sort?</h3>



<p>We also were curious how much performance went into deep levels of quicksort and confirmed that one in several thousand of all <code>std::sort</code> calls got into the fallback heapsort.</p>



<p>That was slightly unusual to discover. It also did not show any statistically significant performance improvements, i.e. no obvious or significant quadratic improvements have been found. Quicksort is really working ok on real world data, however, this algorithm can be exploitable.</p>







<p>At first it looks easy to just change the implementation and win resources: sorting has order and, for example, if you sort integers, the API does not care about the implementation; the range should be just ordered correctly.</p>



<p>However, the C++ API can take compare functions, which may be for simplicity lambda functions. We will call them “comparators.” These can break our assumptions about sorting being deterministic in several ways. Sometimes I refer to this problem a.k.a. “ties can be resolved differently”.</p>



<figure><div>
<div id="gist115741533">
    <div translate="no">
      <div>
        <div>
  <div id="file-stability-cpp">
    
  <div itemprop="text">

      
<div>

  <template>
  <div data-view-component="true">
  <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
  
    <p><span>
      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
      <a href="https://github.co/hiddenchars" target="_blank">Learn more about bidirectional Unicode characters</a>
    </span></p>
</div></template>
<template>
  <span aria-label="This line has hidden Unicode characters" data-view-component="true">
    <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
</span></template>

  
</div>


  </div>

  </div>
</div>

      </div>
      
    </div>
</div>

</div></figure>



<p>More serious examples might involve SQL queries of type:</p>



<div>




<div>
<figure><div>
<div id="gist115741653">
    <div translate="no">
      <div>
        <div>
  <div id="file-diff-sql">
    
  <div itemprop="text">

      
<div>

  <template>
  <div data-view-component="true">
  <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
  
    <p><span>
      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
      <a href="https://github.co/hiddenchars" target="_blank">Learn more about bidirectional Unicode characters</a>
    </span></p>
</div></template>
<template>
  <span aria-label="This line has hidden Unicode characters" data-view-component="true">
    <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
</span></template>

  
</div>


  </div>

  </div>
</div>

      </div>
      
    </div>
</div>

</div></figure>
</div>




</div>



<p>And we know that users like to write golden tests with queries of that sort. Even though nobody guarantees the order of equal elements, users do depend on that behavior as it might be buried down in code they have never heard of. That’s a classic example of <a rel="noreferrer noopener" href="https://www.hyrumslaw.com/" target="_blank">Hyrum’s Law</a></p>



<blockquote><p>With a sufficient number of users of an API,</p><p>it does not matter what you promise in the contract:</p><p>all observable behaviors of your system</p><p>will be depended on by somebody.</p><cite>Hyrum Wright</cite></blockquote>



<p>Golden tests can be confusing if the diff is too big: are we breaking something or is the test too brittle to show anything useful to us? Golden tests are not a typical unit test because they don’t enforce any behavior. They simply let you know that the output of the service changed. There is no contract about the meaning of these changes; it is entirely up to the user to do whatever they want with this information.</p>



<p>When we tried to find all such cases, we understood it made the migration almost impossible to automate — how did we know these changes were the ones that the users wanted? In the end we learned a pretty harsh lesson that even slight changes in how we use primitives lead us to problems with goldens. It’s better if you use unit tests instead of golden ones or pay more attention to determinism of the code written.</p>



<p>Actually, about finding all Hyrum’s Law cases.</p>



<h2>How to find all equal elements dependencies? </h2>



<p>As equal elements are mostly indistinguishable during the compare functions (we found only a small handful of examples of comparators doing changes to array along the way), it is enough to randomize the range before the actual call to <code>std::sort</code>. You can figure out the probabilities and prove it is enough on your own.</p>



<p>We decided to submit such functionality into LLVM under debug mode<sup><a href="#footnotes">20</a></sup> for calls <code>std::sort</code>, <code>std::nth_element</code>, <code>std::partial_sort</code>.</p>



<figure><div>
<div id="gist115743588">
    <div translate="no">
      <div>
        <div>
  <div id="file-randomize_ranges-cpp">
    
  <div itemprop="text">

      
<div>

  <template>
  <div data-view-component="true">
  <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
  
    <p><span>
      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
      <a href="https://github.co/hiddenchars" target="_blank">Learn more about bidirectional Unicode characters</a>
    </span></p>
</div></template>
<template>
  <span aria-label="This line has hidden Unicode characters" data-view-component="true">
    <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
</span></template>

  
</div>


  </div>

  </div>
</div>

      </div>
      
    </div>
</div>

</div></figure>



<h3>Seeding techniques</h3>



<p>We used <code>ASLR</code> (address space layout randomization)<sup><a href="#footnotes">21</a></sup> technique for seeding the random number generator, meaning static variables will be in random addresses upon the start of the program and we can use it as a seed. This provides the same stability guarantee within a run but not through different runs, for example, for tests to become flaky and eventually be seen as broken. For platforms which do not support ASLR, the seed is fixed during build. Using other techniques from header <code>&lt;random&gt;</code> was not possible as header <code>&lt;algorithm&gt;</code> recursively depended on <code>&lt;random&gt;</code> and in such a low level library, we implemented a very simple linear generator. </p>



<figure><div>
<div id="gist115743374">
    <div translate="no">
      <div>
        <div>
  <div id="file-seeding-cpp">
    
  <div itemprop="text">

      
<div>

  <template>
  <div data-view-component="true">
  <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
  
    <p><span>
      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
      <a href="https://github.co/hiddenchars" target="_blank">Learn more about bidirectional Unicode characters</a>
    </span></p>
</div></template>
<template>
  <span aria-label="This line has hidden Unicode characters" data-view-component="true">
    <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
</span></template>

  
</div>


  </div>

  </div>
</div>

      </div>
      
    </div>
</div>

</div></figure>



<p>This randomization was enabled in a debug build mode as performance penalty might be significant for shuffling for all cases.</p>



<h3>Partial vs nth danger</h3>



<p>Also if you look closely at the randomization changes above, you may notice some difference between <code>std::nth_element</code> and <code>std::partial_sort</code>. That can be misleading.</p>



<p><code>std::partial_sort</code> and <code>std::nth_element</code> have a difference in the meaning of their parameters that is easy to get confused. Both take 3 iterators:</p>



<ul><li><code>begin</code> – the beginning of the range</li><li><code>nth</code> or <code>middle</code> – the meaning (and name) of this parameter differs between these functions</li><li><code>end</code> – the end of the range</li></ul>



<p>For <code>std::partial_sort</code>, the middle parameter is called <code>middle</code>, and points right after the part of the range that should end up sorted. That means you have no idea which element <code>middle</code> will point to – you only know that it will be one of the elements that didn’t need to be sorted.</p>



<p>For <code>std::nth_element</code>, this middle parameter is <code>nth</code>. It points to the only element that will be sorted. For all of the elements in <code>[begin, nth)</code> you only know that they’ll be less than or equal to <code>*nth</code>, but you don’t know what order they’ll be in.</p>



<p>That means that if you want to find the 10th smallest element of a container, you have to call these functions a bit differently:</p>



<figure><img data-attachment-id="886" data-permalink="https://danlark.org/untitled-diagram-drawio/" data-orig-file="https://danlarkorg.files.wordpress.com/2022/04/untitled-diagram.drawio.png" data-orig-size="961,421" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="untitled-diagram.drawio" data-image-description="" data-image-caption="" data-medium-file="https://danlarkorg.files.wordpress.com/2022/04/untitled-diagram.drawio.png?w=300" data-large-file="https://danlarkorg.files.wordpress.com/2022/04/untitled-diagram.drawio.png?w=750" src="https://danlarkorg.files.wordpress.com/2022/04/untitled-diagram.drawio.png?w=961" alt="" srcset="https://danlarkorg.files.wordpress.com/2022/04/untitled-diagram.drawio.png 961w, https://danlarkorg.files.wordpress.com/2022/04/untitled-diagram.drawio.png?w=150 150w, https://danlarkorg.files.wordpress.com/2022/04/untitled-diagram.drawio.png?w=300 300w, https://danlarkorg.files.wordpress.com/2022/04/untitled-diagram.drawio.png?w=768 768w" sizes="(max-width: 961px) 100vw, 961px"/></figure>



<figure><div>
<div id="gist115743725">
    <div translate="no">
      <div>
        <div>
  <div id="file-first_ten-cpp">
    
  <div itemprop="text">

      
<div>

  <template>
  <div data-view-component="true">
  <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
  
    <p><span>
      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
      <a href="https://github.co/hiddenchars" target="_blank">Learn more about bidirectional Unicode characters</a>
    </span></p>
</div></template>
<template>
  <span aria-label="This line has hidden Unicode characters" data-view-component="true">
    <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
</span></template>

  
</div>


  </div>

  </div>
</div>

      </div>
      
    </div>
</div>

</div></figure>



<p>In the end, after dozens of runs of all tests at Google and with the help of a strong prevailing wind of randomness, we measured a couple of thousands of tests to be dependent on the stability of sorting and selection algorithms. As we also planned on updating sorting algorithms, this effort helped doing it gradually and sustainably.</p>



<p><em>All in all, it took us around a year to fix all of them.</em> </p>



<h2>Which failures will you probably discover?</h2>



<h3>Goldens</h3>



<p>First of all, we, of course, discovered numerous failures regarding golden tests described above, that’s inevitable. From open source, you can try to look at ClickHouse<sup><a href="#footnotes">22, 23</a></sup>, they also decided to introduce randomness described above.</p>



<figure><img data-attachment-id="899" data-permalink="https://danlark.org/image-11/" data-orig-file="https://danlarkorg.files.wordpress.com/2022/04/image-11.png" data-orig-size="1453,809" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-11" data-image-description="" data-image-caption="" data-medium-file="https://danlarkorg.files.wordpress.com/2022/04/image-11.png?w=300" data-large-file="https://danlarkorg.files.wordpress.com/2022/04/image-11.png?w=750" src="https://danlarkorg.files.wordpress.com/2022/04/image-11.png?w=1024" alt="" srcset="https://danlarkorg.files.wordpress.com/2022/04/image-11.png?w=1024 1024w, https://danlarkorg.files.wordpress.com/2022/04/image-11.png?w=150 150w, https://danlarkorg.files.wordpress.com/2022/04/image-11.png?w=300 300w, https://danlarkorg.files.wordpress.com/2022/04/image-11.png?w=768 768w, https://danlarkorg.files.wordpress.com/2022/04/image-11.png 1453w" sizes="(max-width: 1024px) 100vw, 1024px"/><figcaption>Typical golden test updates</figcaption></figure>



<p>Most changes will look like this by adjusting the right ordering and updating golden tests.</p>



<p>Unfortunately, golden tests might be quite sensitive to production workloads, for example, during streaming engine rollout — what if some instances produce slightly different results for the same shard? Or what if some compression algorithm by accident uses <code>std::sort</code> and compares the checksum from another service which hasn’t updated its implementation? That might cause checksum mismatch, higher error rate, users suffering and even data loss, and you cannot easily swap the algorithm right away as it can break production workloads in unusual ways. Hyrum’s Law at its best and worst. For example, we needed to inject in a couple of places old implementations to allow teams to migrate.</p>



<h3>Oh, crap, determinism</h3>



<p>Some other changes might require a transition from <code>std::sort</code> to <code>std::stable_sort</code> if determinism is required. We recommend writing a comment on why this is important as <code>stable_sort</code> guarantees that equal elements will be in the same order as before the sort. </p>



<figure><img data-attachment-id="900" data-permalink="https://danlark.org/image-12/" data-orig-file="https://danlarkorg.files.wordpress.com/2022/04/image-12.png" data-orig-size="1456,287" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-12" data-image-description="" data-image-caption="" data-medium-file="https://danlarkorg.files.wordpress.com/2022/04/image-12.png?w=300" data-large-file="https://danlarkorg.files.wordpress.com/2022/04/image-12.png?w=750" src="https://danlarkorg.files.wordpress.com/2022/04/image-12.png?w=1024" alt="" srcset="https://danlarkorg.files.wordpress.com/2022/04/image-12.png?w=1024 1024w, https://danlarkorg.files.wordpress.com/2022/04/image-12.png?w=150 150w, https://danlarkorg.files.wordpress.com/2022/04/image-12.png?w=300 300w, https://danlarkorg.files.wordpress.com/2022/04/image-12.png?w=768 768w, https://danlarkorg.files.wordpress.com/2022/04/image-12.png 1456w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<h3>Side note: defaults in other languages are different and that’s probably good</h3>



<p>In many languages<a href="https://danlarkorg.wordpress.com/wp-admin/post.php?post=758&amp;action=edit#footnotes"><sup>24</sup></a>, including Python, Java, Rust, <code>sort()</code> is stable by default and, if being honest, that’s a much better engineering decision, in my opinion. For example, Rust has <code>.sort_unstable()</code> which does not have stability guarantees but explicitly tells what it does. However, C++ has a different priority, or, you may say, direction, i.e. usages of something should not do more than requested (a.k.a “<em>You don’t pay for what you don’t use</em>“). From our benchmarks <code>std::stable_sort</code> was 10-15% slower than <code>std::sort</code>, and it allocated linear memory. For C++ code that was quite critical given performance benefits. I like to think sometimes that Rust assumes more restrictive defaults with possibilities to relax them whereas C++ assumes less restrictive defaults with possibilities to tighten them.</p>


<div>
<figure><img data-attachment-id="905" data-permalink="https://danlark.org/rust_cpp_tight-drawio/" data-orig-file="https://danlarkorg.files.wordpress.com/2022/04/rust_cpp_tight.drawio.png" data-orig-size="648,741" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="rust_cpp_tight.drawio" data-image-description="" data-image-caption="" data-medium-file="https://danlarkorg.files.wordpress.com/2022/04/rust_cpp_tight.drawio.png?w=262" data-large-file="https://danlarkorg.files.wordpress.com/2022/04/rust_cpp_tight.drawio.png?w=648" src="https://danlarkorg.files.wordpress.com/2022/04/rust_cpp_tight.drawio.png?w=648" alt="" srcset="https://danlarkorg.files.wordpress.com/2022/04/rust_cpp_tight.drawio.png 648w, https://danlarkorg.files.wordpress.com/2022/04/rust_cpp_tight.drawio.png?w=131 131w, https://danlarkorg.files.wordpress.com/2022/04/rust_cpp_tight.drawio.png?w=262 262w" sizes="(max-width: 648px) 100vw, 648px"/></figure></div>


<h3>Logical Bugs</h3>



<p>We found several places where users invoked undefined behavior or made inefficiencies. Let’s get them from less to more important.</p>



<h4>Sorting of binary data</h4>



<p>If you compare by a boolean variable, for example, partition data by existence of something, it’s very tempting to write <code>std::sort</code> call.</p>



<figure><div>
<div id="gist115776812">
    <div translate="no">
      <div>
        <div>
  <div id="file-boolean_sort-cpp">
    
  <div itemprop="text">

      
<div>

  <template>
  <div data-view-component="true">
  <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
  
    <p><span>
      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
      <a href="https://github.co/hiddenchars" target="_blank">Learn more about bidirectional Unicode characters</a>
    </span></p>
</div></template>
<template>
  <span aria-label="This line has hidden Unicode characters" data-view-component="true">
    <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
</span></template>

  
</div>


  </div>

  </div>
</div>

      </div>
      
    </div>
</div>

</div></figure>



<p>However, for compare functions that compare only by boolean variables, we have much faster linear algorithms, named <code>std::partition</code> and for stable version, <code>std::stable_partition</code>.</p>



<figure><div>
<div id="gist115776870">
    <div translate="no">
      <div>
        <div>
  <div id="file-partition-cpp">
    
  <div itemprop="text">

      
<div>

  <template>
  <div data-view-component="true">
  <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
  
    <p><span>
      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
      <a href="https://github.co/hiddenchars" target="_blank">Learn more about bidirectional Unicode characters</a>
    </span></p>
</div></template>
<template>
  <span aria-label="This line has hidden Unicode characters" data-view-component="true">
    <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
</span></template>

  
</div>


  </div>

  </div>
</div>

      </div>
      
    </div>
</div>

</div></figure>



<p>Even though modern algorithms do a good job in detection of cardinality, try to prefer <code>std::partition</code> at least for readability issues. </p>



<h4>Sorting more than needed</h4>



<p>We saw a pattern of sort+resize a lot.</p>



<figure><div>
<div id="gist115776926">
    <div translate="no">
      <div>
        <div>
  <div id="file-sort_resize-cpp">
    
  <div itemprop="text">

      
<div>

  <template>
  <div data-view-component="true">
  <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
  
    <p><span>
      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
      <a href="https://github.co/hiddenchars" target="_blank">Learn more about bidirectional Unicode characters</a>
    </span></p>
</div></template>
<template>
  <span aria-label="This line has hidden Unicode characters" data-view-component="true">
    <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
</span></template>

  
</div>


  </div>

  </div>
</div>

      </div>
      
    </div>
</div>

</div></figure>



<p>You can work out from the code above that although each element must be inspected, sorting the whole of ‘vector’ (beyond the <img src="https://s0.wp.com/latex.php?latex=n&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=n&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=n&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="n"/>-th element) is not necessary. The compiler likely cannot optimize it away.</p>



<figure><div>
<div id="gist115776936">
    <div translate="no">
      <div>
        <div>
  <div id="file-partial_sort-cpp">
    
  <div itemprop="text">

      
<div>

  <template>
  <div data-view-component="true">
  <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
  
    <p><span>
      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
      <a href="https://github.co/hiddenchars" target="_blank">Learn more about bidirectional Unicode characters</a>
    </span></p>
</div></template>
<template>
  <span aria-label="This line has hidden Unicode characters" data-view-component="true">
    <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
</span></template>

  
</div>


  </div>

  </div>
</div>

      </div>
      
    </div>
</div>

</div></figure>



<p>Unfortunately, there is no stable <code>std::partial_sort</code> analogue, so fix a comparator if the determinism is required.</p>



<h4>C++ is hard</h4>



<p>If you have a mismatched type in a comparator, C++ will not warn you even with <code>-Weverything</code>. In the picture below zero warnings have been produced when sorting a vector of floats with <code>std::greater&lt;int&gt;</code> comparator.</p>



<figure><img data-attachment-id="916" data-permalink="https://danlark.org/image-13/" data-orig-file="https://danlarkorg.files.wordpress.com/2022/04/image-13.png" data-orig-size="1456,540" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-13" data-image-description="" data-image-caption="" data-medium-file="https://danlarkorg.files.wordpress.com/2022/04/image-13.png?w=300" data-large-file="https://danlarkorg.files.wordpress.com/2022/04/image-13.png?w=750" src="https://danlarkorg.files.wordpress.com/2022/04/image-13.png?w=1024" alt="" srcset="https://danlarkorg.files.wordpress.com/2022/04/image-13.png?w=1024 1024w, https://danlarkorg.files.wordpress.com/2022/04/image-13.png?w=150 150w, https://danlarkorg.files.wordpress.com/2022/04/image-13.png?w=300 300w, https://danlarkorg.files.wordpress.com/2022/04/image-13.png?w=768 768w, https://danlarkorg.files.wordpress.com/2022/04/image-13.png 1456w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<h4>Not following strict weak ordering</h4>



<p>When you call any of the ordering functions in C++ including <code>std::sort</code>, compare functions much comply with the strict weak ordering which formally means the following:</p>







<p>All these conditions make sense and algorithms actually use all those for optimization purposes. First 3 conditions set strict partial order, the 4th one is introducing equivalence relations on incomparable elements.</p>



<p>As you might imagine, we faced the violation of all conditions. In order to demonstrate those, I will post screenshots below where I found them through Github codesearch (<a href="https://cs.github.com" target="_blank" rel="noreferrer noopener">https://cs.github.com</a>). I promise I haven’t tried much to find bugs. The biggest emphasis is that violations do happen. After them we will discuss how they can be exploited</p>



<h4>Violation of irreflexivity and asymmetry</h4>



<p>This is a slideshow, look through it.</p>







<p>All of them violate irreflexivity, <code>comp(x, x)</code> returns true. You may say this might not be used in practice, however, we learned a tough lesson that even testing does not always help. </p>



<h4>30 vs 31 elements. Happy execution vs SIGSEGV</h4>



<p>You may remember that up to 30 elements for trivial types (and 6 for non-trivial), LLVM/libcxx sort uses insertion sort and after that it bails out to quicksort. Well, <strong>if you submit a comparator where conditions for irreflexivity or asymmetry are not met</strong>, you will find that with 31 elements the program might get into <strong>segfault</strong> whereas with 30 elements it works just fine. Consider this example, we want to move all negative elements to the right and sort all positive, same as some examples above.</p>



<figure><img data-attachment-id="928" data-permalink="https://danlark.org/image-14/" data-orig-file="https://danlarkorg.files.wordpress.com/2022/04/image-14.png" data-orig-size="1789,578" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-14" data-image-description="" data-image-caption="" data-medium-file="https://danlarkorg.files.wordpress.com/2022/04/image-14.png?w=300" data-large-file="https://danlarkorg.files.wordpress.com/2022/04/image-14.png?w=750" src="https://danlarkorg.files.wordpress.com/2022/04/image-14.png?w=1024" alt="" srcset="https://danlarkorg.files.wordpress.com/2022/04/image-14.png?w=1024 1024w, https://danlarkorg.files.wordpress.com/2022/04/image-14.png?w=150 150w, https://danlarkorg.files.wordpress.com/2022/04/image-14.png?w=300 300w, https://danlarkorg.files.wordpress.com/2022/04/image-14.png?w=768 768w, https://danlarkorg.files.wordpress.com/2022/04/image-14.png 1789w" sizes="(max-width: 1024px) 100vw, 1024px"/><figcaption><a href="https://gcc.godbolt.org/z/17r76q7eo" target="_blank" rel="noreferrer noopener">https://gcc.godbolt.org/z/17r76q7eo</a></figcaption></figure>



<p>We saw users writing tests for small ranges, however, when the number of elements grows, <code>std::sort</code> can result in SIGSEGV, and this may slip during testing, and be an interesting attack vector to kill the program.</p>



<p>This is used in the implementation of libcxx to wait for some condition to be false knowing we will at some point compare two equal elements:</p>



<figure><div>
<div id="gist115799309">
    <div translate="no">
      <div>
        <div>
  <div id="file-sort_guarded-cpp">
    
  <div itemprop="text">

      
<div>

  <template>
  <div data-view-component="true">
  <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
  
    <p><span>
      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
      <a href="https://github.co/hiddenchars" target="_blank">Learn more about bidirectional Unicode characters</a>
    </span></p>
</div></template>
<template>
  <span aria-label="This line has hidden Unicode characters" data-view-component="true">
    <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
</span></template>

  
</div>


  </div>

  </div>
</div>

      </div>
      
    </div>
</div>

</div><figcaption><a href="https://github.com/llvm/llvm-project/blob/34a68037ddb4dff972c5d8c599cf5edf08fadf6b/libcxx/include/__algorithm/sort.h#L451" target="_blank" rel="noreferrer noopener">https://github.com/llvm/llvm-project/blob/34a68037ddb4dff972c5d8c599cf5edf08fadf6b/libcxx/include/__algorithm/sort.h#L451</a></figcaption></figure>



<h4>Violation of transitivity of incomparability</h4>



<figure><img data-attachment-id="943" data-permalink="https://danlark.org/transitivity/" data-orig-file="https://danlarkorg.files.wordpress.com/2022/04/transitivity.png" data-orig-size="960,540" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="transitivity" data-image-description="" data-image-caption="" data-medium-file="https://danlarkorg.files.wordpress.com/2022/04/transitivity.png?w=300" data-large-file="https://danlarkorg.files.wordpress.com/2022/04/transitivity.png?w=750" src="https://danlarkorg.files.wordpress.com/2022/04/transitivity.png" alt=""/><figcaption><a href="https://webrtc-review.googlesource.com/c/src/+/251681" target="_blank" rel="noreferrer noopener">https://webrtc-review.googlesource.com/c/src/+/251681</a></figcaption></figure>



<p>You can construct an example where the 4 condition is violated </p>



<p>The worst that can happen in that case with the current implementation that the elements would not be sorted (not segfaults, although this needs a proof but the article is already too big for that), check out:</p>



<figure><img data-attachment-id="995" data-permalink="https://danlark.org/image-18/" data-orig-file="https://danlarkorg.files.wordpress.com/2022/04/image-18.png" data-orig-size="1733,807" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-18" data-image-description="" data-image-caption="" data-medium-file="https://danlarkorg.files.wordpress.com/2022/04/image-18.png?w=300" data-large-file="https://danlarkorg.files.wordpress.com/2022/04/image-18.png?w=750" src="https://danlarkorg.files.wordpress.com/2022/04/image-18.png?w=1024" alt="" srcset="https://danlarkorg.files.wordpress.com/2022/04/image-18.png?w=1024 1024w, https://danlarkorg.files.wordpress.com/2022/04/image-18.png?w=150 150w, https://danlarkorg.files.wordpress.com/2022/04/image-18.png?w=300 300w, https://danlarkorg.files.wordpress.com/2022/04/image-18.png?w=768 768w, https://danlarkorg.files.wordpress.com/2022/04/image-18.png 1733w" sizes="(max-width: 1024px) 100vw, 1024px"/><figcaption><a href="https://gcc.godbolt.org/z/c71qzM97f" target="_blank" rel="noreferrer noopener">https://gcc.godbolt.org/z/c71qzM97f</a></figcaption></figure>



<p>And again, if you use fewer than 7 elements, insertion sort is used, and you will not construct a counter-example where <code>std::is_sorted</code> is not working. Even though, on paper this is undefined behavior, this is <strong>very hard to detect</strong> by sanitizers or tests, and in reality it passes simple cases.</p>



<p>Honestly, this snippet can be as simple as:</p>



<figure><div>
<div id="gist115820589">
    <div translate="no">
      <div>
        <div>
  <div id="file-sort_double-cpp">
    
  <div itemprop="text">

      
<div>

  <template>
  <div data-view-component="true">
  <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
  
    <p><span>
      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
      <a href="https://github.co/hiddenchars" target="_blank">Learn more about bidirectional Unicode characters</a>
    </span></p>
</div></template>
<template>
  <span aria-label="This line has hidden Unicode characters" data-view-component="true">
    <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
</span></template>

  
</div>


  </div>

  </div>
</div>

      </div>
      
    </div>
</div>

</div></figure>



<p>Why? As doubles/floats can be <code>NaN</code> which means <code>x &lt; NaN</code> and <code>NaN &lt; x</code> are both false and that means <code>x</code> is equivalent to <code>NaN</code> thus for every finite <code>x</code> we have <code>x == NaN</code> but clearly <code>x == NaN</code> and <code>y == NaN</code> does not imply <code>x == y</code>.</p>



<p>So, if you have <code>NaNs</code> in the vector, calling <code>std::sort</code> on paper invokes undefined behavior. This is a part of the problem which was described in</p>



<figure><p><span><iframe width="750" height="422" src="https://www.youtube.com/embed/2FAi2mNYjFA?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation"></iframe></span>
</p></figure>



<h4>Wait, but finding strict weak ordering violations takes cubic time</h4>



<p>In order to detect strict weak ordering violations, you need to check all triples of elements which takes <img src="https://s0.wp.com/latex.php?latex=O%28n%5E3%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=O%28n%5E3%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=O%28n%5E3%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="O(n^3)"/> time. Even though with the existence of <img src="https://s0.wp.com/latex.php?latex=O%28n%5E2%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=O%28n%5E2%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=O%28n%5E2%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="O(n^2)"/> algorithms (this is for another post), this takes much more time than <img src="https://s0.wp.com/latex.php?latex=O%28n+%5Clog+n%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=O%28n+%5Clog+n%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=O%28n+%5Clog+n%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="O(n \log n)"/> and likely cannot be used even in debug mode as programs will not finish for sorting a million elements in reasonable time.</p>



<p>And we did what most engineers would do. We decided after randomization to check <img src="https://s0.wp.com/latex.php?latex=%5Cmin%2820%2C+n%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=%5Cmin%2820%2C+n%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=%5Cmin%2820%2C+n%29&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="\min(20, n)"/> triples and fixed or reported all bugs. Worked like a charm 🙂 . This hasn’t been submitted to LLVM yet as I could not find time to do that properly.</p>



<h4 id="block-a0ce4272-1bb7-4c4a-9bfb-713358d77d91">std::nth_element bug to randomization ratio is the highest. Here is why</h4>



<p>Even though <code>std::sort</code> is used the most and found most failing test cases, we found that randomization for <code>std::nth_element</code> and <code>std::partial_sort</code> found more logical bugs per failing test case. I did a very simple codesearch query finding two close calls of <code>std::nth_element</code> and immediately found incorrect usages. Try to identify bugs on your own at first (you can find all of them in<sup><a href="#footnotes">25</a></sup>):</p>







<p>All of them follow the same pattern of ignoring the results from the first <code>nth_element</code> call. The visualization for the bug can be seen in the picture:</p>



<figure><img data-attachment-id="968" data-permalink="https://danlark.org/untitled-diagram-drawio-1/" data-orig-file="https://danlarkorg.files.wordpress.com/2022/04/untitled-diagram.drawio-1.png" data-orig-size="881,441" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="untitled-diagram.drawio-1" data-image-description="" data-image-caption="" data-medium-file="https://danlarkorg.files.wordpress.com/2022/04/untitled-diagram.drawio-1.png?w=300" data-large-file="https://danlarkorg.files.wordpress.com/2022/04/untitled-diagram.drawio-1.png?w=750" src="https://danlarkorg.files.wordpress.com/2022/04/untitled-diagram.drawio-1.png?w=881" alt="" srcset="https://danlarkorg.files.wordpress.com/2022/04/untitled-diagram.drawio-1.png 881w, https://danlarkorg.files.wordpress.com/2022/04/untitled-diagram.drawio-1.png?w=150 150w, https://danlarkorg.files.wordpress.com/2022/04/untitled-diagram.drawio-1.png?w=300 300w, https://danlarkorg.files.wordpress.com/2022/04/untitled-diagram.drawio-1.png?w=768 768w" sizes="(max-width: 881px) 100vw, 881px"/></figure>



<p>And yes, this happens often enough, I didn’t even try to find many bugs, this was a 10 minutes skim through the github codesearch results. Fixes are trivial, access the <code>nth</code> element only after the call being made. Be careful.</p>



<h3>How can you find bad sorting calls among hundreds of places in your codebase?</h3>



<p>Users even in small repositories call <code>std::sort</code> in dozens/hundreds or even thousands different places, how can you find which sorting call introduces bad behavior? Well, sometimes it’s obvious, sometimes it’s definitely not and exploration is another question which greatly simplifies the debugging process.</p>



<p>We used <em>inline variables</em><sup><a href="#footnotes">26</a></sup> (or sometimes compiler people call them <em>weak symbols</em>) in C++ which can be declared in headers and set from anywhere without linkage errors.</p>



<figure><div>
<div id="gist115821892">
    <div translate="no">
      <div>
        <div>
  <div id="file-algorithm-h">
    
  <div itemprop="text">

      
<div>

  <template>
  <div data-view-component="true">
  <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
  
    <p><span>
      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
      <a href="https://github.co/hiddenchars" target="_blank">Learn more about bidirectional Unicode characters</a>
    </span></p>
</div></template>
<template>
  <span aria-label="This line has hidden Unicode characters" data-view-component="true">
    <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
</span></template>

  
</div>


  </div>

  </div>
</div>

      </div>
      
    </div>
</div>

</div></figure>



<p>This helped to find all stacktraces of <code>std::sort</code> calls and do some statistical analysis on where they come from. This still required a person to look at but greatly simplified the debugging experience.</p>



<h5>A very small danger note</h5>



<p>If the function <code>backtrace_dumper</code> uses <code>std::sort</code> somehow, then you might get into an infinite recursion. This method didn’t work from the first run as at Google we use allocator TCMalloc and it uses <code>std::sort</code>.</p>



<figure><img data-attachment-id="976" data-permalink="https://danlark.org/2022-04-19-005452_1197x528_scrot/" data-orig-file="https://danlarkorg.files.wordpress.com/2022/04/2022-04-19-005452_1197x528_scrot.png" data-orig-size="1197,528" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="2022-04-19-005452_1197x528_scrot" data-image-description="" data-image-caption="" data-medium-file="https://danlarkorg.files.wordpress.com/2022/04/2022-04-19-005452_1197x528_scrot.png?w=300" data-large-file="https://danlarkorg.files.wordpress.com/2022/04/2022-04-19-005452_1197x528_scrot.png?w=750" src="https://danlarkorg.files.wordpress.com/2022/04/2022-04-19-005452_1197x528_scrot.png?w=1024" alt="" srcset="https://danlarkorg.files.wordpress.com/2022/04/2022-04-19-005452_1197x528_scrot.png?w=1024 1024w, https://danlarkorg.files.wordpress.com/2022/04/2022-04-19-005452_1197x528_scrot.png?w=150 150w, https://danlarkorg.files.wordpress.com/2022/04/2022-04-19-005452_1197x528_scrot.png?w=300 300w, https://danlarkorg.files.wordpress.com/2022/04/2022-04-19-005452_1197x528_scrot.png?w=768 768w, https://danlarkorg.files.wordpress.com/2022/04/2022-04-19-005452_1197x528_scrot.png 1197w" sizes="(max-width: 1024px) 100vw, 1024px"/><figcaption><a href="https://github.com/google/tcmalloc/blob/2bac28c802ce5e93b284803854417cfe6dde0fff/tcmalloc/huge_page_filler.h#L1414" target="_blank" rel="noreferrer noopener">https://github.com/google/tcmalloc/blob/2bac28c802ce5e93b284803854417cfe6dde0fff/tcmalloc/huge_page_filler.h#L1414</a></figcaption></figure>



<p>The same happened with <code>absl::Mutex</code>. These were funny hours finding out why unrelated tests failed 🙂</p>



<p>Also note that <code>backtrace_dumper</code> is likely needed to be thread safe.</p>



<h4>Automating process by a small margin</h4>



<p>Sometimes what you can do is the following:</p>



<ul><li>Find all <code>std::sort</code> calls through this backtrace finder</li><li>Replace one by one with <code>std::stable_sort</code></li><li>If tests become green, point to the user that this call is likely a culprit</li><li>Maybe suggest replacing it with <code>std::stable_sort</code><ul><li>Accepting a patch is sometimes easier than delegating to the team/person to fix it on their own</li></ul></li><li>If none found, send a bug/look manually</li></ul>



<p>This speeded up the process, and some teams accepted <code>std::stable_sort</code> understanding performance penalties, others realized that something was wrong and asked for a different fix.</p>







<p>In a way, that matters the least and does not require so much attention and effort from multiple people at the same time. If anybody decides to change the implementation, with the randomization above, it is easier to be prepared, switch and enjoy the savings (alongside with the benefits of mitigating serious bugs) right away. But our initial goal of this project was to provide better performance so we will talk a little about it.</p>



<p>I also want to admit that the debates around which sorting is the fastest are likely never going to stop and nonetheless it is important to move the needle towards greater algorithms. I am not going to claim the choice we proceed with is the best, it just significantly improves the status quo with several fascinating ideas.</p>



<h2>A side note on distribution</h2>



<p>We found that both cases are important to optimize, from sorting integers where comparisons are very cheap to extremely heavy where compare functions are even doing some codec decompression and thus are quite expensive. And as we said, it is quite important to figure out some patterns.</p>



<h2>Branch (mis)predictions for cheap comparisons </h2>



<figure><div>
<div id="gist115845618">
    <div translate="no">
      <div>
        <div>
  <div id="file-partitioning-cpp">
    
  <div itemprop="text">

      
<div>

  <template>
  <div data-view-component="true">
  <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
  
    <p><span>
      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
      <a href="https://github.co/hiddenchars" target="_blank">Learn more about bidirectional Unicode characters</a>
    </span></p>
</div></template>
<template>
  <span aria-label="This line has hidden Unicode characters" data-view-component="true">
    <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
</span></template>

  
</div>


  </div>

  </div>
</div>

      </div>
      
    </div>
</div>

</div></figure>



<p>In the current implementation, sorting executes a significant number of branch instructions while partitioning the input about the pivot. The branches are shown above where their results decide to continue looping or not. These branches are quite hard to predict especially in cases when pivot is chosen to be right in the middle (for example, in random arrays). The mispredicted branches cause the process pipeline to be flushed and generally are considered harmful for the execution. This was quite known and carefully analyzed<sup><a href="#footnotes">28, 29</a></sup>. In a way, it is sometimes better to choose a skewed pivot to avoid this heavy loop.</p>



<figure><img data-attachment-id="1015" data-permalink="https://danlark.org/2022-04-20-092440_996x536_scrot/" data-orig-file="https://danlarkorg.files.wordpress.com/2022/04/2022-04-20-092440_996x536_scrot.png" data-orig-size="996,536" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="2022-04-20-092440_996x536_scrot" data-image-description="" data-image-caption="" data-medium-file="https://danlarkorg.files.wordpress.com/2022/04/2022-04-20-092440_996x536_scrot.png?w=300" data-large-file="https://danlarkorg.files.wordpress.com/2022/04/2022-04-20-092440_996x536_scrot.png?w=750" src="https://danlarkorg.files.wordpress.com/2022/04/2022-04-20-092440_996x536_scrot.png?w=996" alt="" srcset="https://danlarkorg.files.wordpress.com/2022/04/2022-04-20-092440_996x536_scrot.png 996w, https://danlarkorg.files.wordpress.com/2022/04/2022-04-20-092440_996x536_scrot.png?w=150 150w, https://danlarkorg.files.wordpress.com/2022/04/2022-04-20-092440_996x536_scrot.png?w=300 300w, https://danlarkorg.files.wordpress.com/2022/04/2022-04-20-092440_996x536_scrot.png?w=768 768w" sizes="(max-width: 996px) 100vw, 996px"/><figcaption>How Branch Mispredictions Affect Quicksort<sup><a href="#footnotes">29</a></sup></figcaption></figure>



<p>In order to mitigate this, we use the technique described in BlockQuickSort<a href="#footnotes"><sup>28</sup></a>.</p>



<p>BlockQuickSort aims to avoid most branches by separating the data movement from the comparison operation. This is achieved by having two buffers of size B which store the comparison results (for example, you can choose B=64 and store just 64 bit integers), one for the left side and the other for the right side while traversing the chunks of size B. Unlike the implementation above, it does not introduce any branches and if you do it right, compiler generates good SIMD code with wide 16 or 32 byte <code>pcmpgt/pand/por</code> instructions for both SSE4.2 and AVX2 code.</p>



<figure><img data-attachment-id="1017" data-permalink="https://danlark.org/2022-04-20-093757_1418x880_scrot/" data-orig-file="https://danlarkorg.files.wordpress.com/2022/04/2022-04-20-093757_1418x880_scrot.png" data-orig-size="1418,880" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="2022-04-20-093757_1418x880_scrot" data-image-description="" data-image-caption="" data-medium-file="https://danlarkorg.files.wordpress.com/2022/04/2022-04-20-093757_1418x880_scrot.png?w=300" data-large-file="https://danlarkorg.files.wordpress.com/2022/04/2022-04-20-093757_1418x880_scrot.png?w=750" src="https://danlarkorg.files.wordpress.com/2022/04/2022-04-20-093757_1418x880_scrot.png?w=1024" alt="" srcset="https://danlarkorg.files.wordpress.com/2022/04/2022-04-20-093757_1418x880_scrot.png?w=1024 1024w, https://danlarkorg.files.wordpress.com/2022/04/2022-04-20-093757_1418x880_scrot.png?w=150 150w, https://danlarkorg.files.wordpress.com/2022/04/2022-04-20-093757_1418x880_scrot.png?w=300 300w, https://danlarkorg.files.wordpress.com/2022/04/2022-04-20-093757_1418x880_scrot.png?w=768 768w, https://danlarkorg.files.wordpress.com/2022/04/2022-04-20-093757_1418x880_scrot.png 1418w" sizes="(max-width: 1024px) 100vw, 1024px"/><figcaption><a href="https://godbolt.org/z/nrhT88MsM" target="_blank" rel="noreferrer noopener">https://godbolt.org/z/nrhT88MsM</a></figcaption></figure>



<p>Same for ARM</p>



<figure><img data-attachment-id="1019" data-permalink="https://danlark.org/2022-04-20-094544_1297x750_scrot/" data-orig-file="https://danlarkorg.files.wordpress.com/2022/04/2022-04-20-094544_1297x750_scrot.png" data-orig-size="1297,750" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="2022-04-20-094544_1297x750_scrot" data-image-description="" data-image-caption="" data-medium-file="https://danlarkorg.files.wordpress.com/2022/04/2022-04-20-094544_1297x750_scrot.png?w=300" data-large-file="https://danlarkorg.files.wordpress.com/2022/04/2022-04-20-094544_1297x750_scrot.png?w=750" src="https://danlarkorg.files.wordpress.com/2022/04/2022-04-20-094544_1297x750_scrot.png?w=1024" alt="" srcset="https://danlarkorg.files.wordpress.com/2022/04/2022-04-20-094544_1297x750_scrot.png?w=1024 1024w, https://danlarkorg.files.wordpress.com/2022/04/2022-04-20-094544_1297x750_scrot.png?w=150 150w, https://danlarkorg.files.wordpress.com/2022/04/2022-04-20-094544_1297x750_scrot.png?w=300 300w, https://danlarkorg.files.wordpress.com/2022/04/2022-04-20-094544_1297x750_scrot.png?w=768 768w, https://danlarkorg.files.wordpress.com/2022/04/2022-04-20-094544_1297x750_scrot.png 1297w" sizes="(max-width: 1024px) 100vw, 1024px"/><figcaption><a href="https://godbolt.org/z/W6sjrMnWf" target="_blank" rel="noreferrer noopener">https://godbolt.org/z/W6sjrMnWf</a></figcaption></figure>



<p>Once we fill all buffers, we should swap them around the pivot. Luckily, all we need to do is find the indices for the elements to swap next. Since the buffers reside in registers, we use <code>ctz</code> (count trailing zeros, in x86 <code>bsf</code> (Bit Scan Forward) or <code>tzcnt</code> (introduced in BMI)), <code>blsr</code> (Reset Lowest Set Bit, introduced in BMI) instructions to find the indices for the elements, thus avoiding any branch instructions.</p>



<figure><img data-attachment-id="1023" data-permalink="https://danlark.org/image-19/" data-orig-file="https://danlarkorg.files.wordpress.com/2022/04/image-19.png" data-orig-size="1210,858" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-19" data-image-description="" data-image-caption="" data-medium-file="https://danlarkorg.files.wordpress.com/2022/04/image-19.png?w=300" data-large-file="https://danlarkorg.files.wordpress.com/2022/04/image-19.png?w=750" src="https://danlarkorg.files.wordpress.com/2022/04/image-19.png?w=1024" alt="" srcset="https://danlarkorg.files.wordpress.com/2022/04/image-19.png?w=1024 1024w, https://danlarkorg.files.wordpress.com/2022/04/image-19.png?w=150 150w, https://danlarkorg.files.wordpress.com/2022/04/image-19.png?w=300 300w, https://danlarkorg.files.wordpress.com/2022/04/image-19.png?w=768 768w, https://danlarkorg.files.wordpress.com/2022/04/image-19.png 1210w" sizes="(max-width: 1024px) 100vw, 1024px"/><figcaption><a rel="noreferrer noopener" href="https://godbolt.org/z/YPTWT4exz" target="_blank">https://godbolt.org/z/YPTWT4exz</a>. Note that aarch64 does not have blsr analogue</figcaption></figure>



<p>Benchmarks showed about 50% savings on sorting random permutations of integers. You can look at them in <a rel="noreferrer noopener" href="https://reviews.llvm.org/D122780" target="_blank">https://reviews.llvm.org/D122780</a></p>



<h2>Heavy comparisons</h2>



<p>As we removed the mispredicted branches, now it is more reasonable to get other heuristics, for example, the pivot choice.</p>



<figure><div>
<div id="gist115848924">
    <div translate="no">
      <div>
        <div>
  <div id="file-tuckey_ninther-h">
    
  <div itemprop="text">

      
<div>

  <template>
  <div data-view-component="true">
  <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
  
    <p><span>
      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
      <a href="https://github.co/hiddenchars" target="_blank">Learn more about bidirectional Unicode characters</a>
    </span></p>
</div></template>
<template>
  <span aria-label="This line has hidden Unicode characters" data-view-component="true">
    <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
</span></template>

  
</div>


  </div>

  </div>
</div>

      </div>
      
    </div>
</div>

</div></figure>



<p>The intuition behind is that a good pivot decreases the number of comparisons but increases the number of branch mispredictions. If we fix the latter, we can try to do the former as well. The more elements for pivot we consider in random arrays, the fewer comparisons we are going to make in the end.</p>



<p>Other small optimizations include unguarded insertion sort for not leftmost ranges during the recursion (out of all ranges, there is only 1 leftmost per each level of recursion), they all give small but sustainable benefits.</p>



<p>These are all in line with the <em>pdqsort</em><sup><a href="https://danlarkorg.wordpress.com/wp-admin/post.php?post=758&amp;action=edit#footnotes">3</a></sup> implementation which was quite acclaimed as a choice of implementation in other languages as well. And we see around 20-30% improvements on random data without sacrificing much performance for almost sorted patterns. </p>



<h2>Reinforcement learning for small sorts</h2>



<p>Another submitted change got some innovations in assembly generation for small sorts including <code>cmov</code> (conditional move instructions). This is the change <a rel="noreferrer noopener" href="https://reviews.llvm.org/D118029" target="_blank">https://reviews.llvm.org/D118029</a>. What happened?</p>



<p>You might <a href="#sortsmall">remember</a> sort4 and sort5 functions from the beginning of the post. They are branchy, however, there are other ways to sort elements: <em>sorting networks</em>. They are the networks which abstract devices built up of a fixed number of “wires”, carrying values, and comparator modules that connect pairs of wires, swapping the values on the wires if they are not in a desired order. Optimal sorting networks are networks that sort the array with the least amount of such <em>compare-and-swap</em> operations made. For 3 elements you need to <em>compare-and-swap</em> 3 times, 5 times for 4 elements and an optimal sorting network for 5 elements consists of 9 <em>compare-and-swap</em> operations.</p>



<figure><img data-attachment-id="1038" data-permalink="https://danlark.org/sorting_networks-drawio-3/" data-orig-file="https://danlarkorg.files.wordpress.com/2022/04/sorting_networks.drawio-3.png" data-orig-size="853,1000" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="sorting_networks.drawio-3" data-image-description="" data-image-caption="" data-medium-file="https://danlarkorg.files.wordpress.com/2022/04/sorting_networks.drawio-3.png?w=256" data-large-file="https://danlarkorg.files.wordpress.com/2022/04/sorting_networks.drawio-3.png?w=750" src="https://danlarkorg.files.wordpress.com/2022/04/sorting_networks.drawio-3.png?w=853" alt="" srcset="https://danlarkorg.files.wordpress.com/2022/04/sorting_networks.drawio-3.png 853w, https://danlarkorg.files.wordpress.com/2022/04/sorting_networks.drawio-3.png?w=128 128w, https://danlarkorg.files.wordpress.com/2022/04/sorting_networks.drawio-3.png?w=256 256w, https://danlarkorg.files.wordpress.com/2022/04/sorting_networks.drawio-3.png?w=768 768w" sizes="(max-width: 853px) 100vw, 853px"/></figure>



<p>Optimal networks for bigger values remain an open question but how to break the conjecture the optimal networks for 11 and 12 elements you can read an absolutely amazing blog post <em>Proving 50-Year-Old Sorting Networks Optimal</em><sup><a href="#footnotes">30</a></sup> by Jannis Harder.</p>



<p>x86 and ARM assembly have instructions called <code>cmov reg1, reg2</code> and <code>csel reg1, reg2, flag</code> which move or select registers upon the value of comparisons. You can use that extensively for <em>compare-and-swap</em> operations.</p>



<figure><img data-attachment-id="1040" data-permalink="https://danlark.org/image-22/" data-orig-file="https://danlarkorg.files.wordpress.com/2022/04/image-22.png" data-orig-size="1534,536" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-22" data-image-description="" data-image-caption="" data-medium-file="https://danlarkorg.files.wordpress.com/2022/04/image-22.png?w=300" data-large-file="https://danlarkorg.files.wordpress.com/2022/04/image-22.png?w=750" src="https://danlarkorg.files.wordpress.com/2022/04/image-22.png?w=1024" alt="" srcset="https://danlarkorg.files.wordpress.com/2022/04/image-22.png?w=1024 1024w, https://danlarkorg.files.wordpress.com/2022/04/image-22.png?w=150 150w, https://danlarkorg.files.wordpress.com/2022/04/image-22.png?w=300 300w, https://danlarkorg.files.wordpress.com/2022/04/image-22.png?w=768 768w, https://danlarkorg.files.wordpress.com/2022/04/image-22.png 1534w" sizes="(max-width: 1024px) 100vw, 1024px"/><figcaption><a rel="noreferrer noopener" href="https://gcc.godbolt.org/z/eG1EnqdTa" target="_blank">https://gcc.godbolt.org/z/eG1EnqdTa</a></figcaption></figure>



<p>And in order to swap <img src="https://s0.wp.com/latex.php?latex=N&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=N&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=N&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="N"/> elements through <code>cmov</code> with <img src="https://s0.wp.com/latex.php?latex=M&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002" srcset="https://s0.wp.com/latex.php?latex=M&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002 1x, https://s0.wp.com/latex.php?latex=M&amp;bg=FFFFFF&amp;fg=181818&amp;s=0&amp;c=20201002&amp;zoom=4.5 4x" alt="M"/>, comparisons, you need to do the following things:</p>







<p>Together we have:</p>



<ul><li>Sort2 – 8 instructions (2 elements and 1 comparison)</li><li>Sort3 – 18 instructions (3 elements and 3 comparisons)</li><li>Sort4 – 28 instructions (4 elements and 5 comparisons)</li><li>Sort5 – 46 instructions (5 elements and 9 comparisons)</li></ul>



<figure><img data-attachment-id="1042" data-permalink="https://danlark.org/image-23/" data-orig-file="https://danlarkorg.files.wordpress.com/2022/04/image-23.png" data-orig-size="1685,730" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-23" data-image-description="" data-image-caption="" data-medium-file="https://danlarkorg.files.wordpress.com/2022/04/image-23.png?w=300" data-large-file="https://danlarkorg.files.wordpress.com/2022/04/image-23.png?w=750" src="https://danlarkorg.files.wordpress.com/2022/04/image-23.png?w=1024" alt="" srcset="https://danlarkorg.files.wordpress.com/2022/04/image-23.png?w=1024 1024w, https://danlarkorg.files.wordpress.com/2022/04/image-23.png?w=150 150w, https://danlarkorg.files.wordpress.com/2022/04/image-23.png?w=300 300w, https://danlarkorg.files.wordpress.com/2022/04/image-23.png?w=768 768w, https://danlarkorg.files.wordpress.com/2022/04/image-23.png 1685w" sizes="(max-width: 1024px) 100vw, 1024px"/><figcaption>Exactly 18 instuctions for sort3 on 64 bit integers, 1 for the name and 1 return instructions</figcaption></figure>



<p>However, as you can see, from the review above, sort3 is written in a little different way, with one conditional swap and <em>magic swap</em>.</p>



<figure><div>
<div id="gist115850728">
    <div translate="no">
      <div>
        <div>
  <div id="file-partial_swap-h">
    
  <div itemprop="text">

      
<div>

  <template>
  <div data-view-component="true">
  <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
  
    <p><span>
      This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
      <a href="https://github.co/hiddenchars" target="_blank">Learn more about bidirectional Unicode characters</a>
    </span></p>
</div></template>
<template>
  <span aria-label="This line has hidden Unicode characters" data-view-component="true">
    <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true">
    <path fill-rule="evenodd" d="M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z"></path>
</svg>
</span></template>

  
</div>


  </div>

  </div>
</div>

      </div>
      
    </div>
</div>

</div></figure>



<p>And if we paste it to Godbolt, we will see that such code produces 1 instruction less. The 19th line from the left got to the 16th on the right and the 15th line on the left was erased completely.</p>



<figure><img data-attachment-id="1045" data-permalink="https://danlark.org/image-24/" data-orig-file="https://danlarkorg.files.wordpress.com/2022/04/image-24.png" data-orig-size="1332,550" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-24" data-image-description="" data-image-caption="" data-medium-file="https://danlarkorg.files.wordpress.com/2022/04/image-24.png?w=300" data-large-file="https://danlarkorg.files.wordpress.com/2022/04/image-24.png?w=750" src="https://danlarkorg.files.wordpress.com/2022/04/image-24.png?w=1024" alt="" srcset="https://danlarkorg.files.wordpress.com/2022/04/image-24.png?w=1024 1024w, https://danlarkorg.files.wordpress.com/2022/04/image-24.png?w=150 150w, https://danlarkorg.files.wordpress.com/2022/04/image-24.png?w=300 300w, https://danlarkorg.files.wordpress.com/2022/04/image-24.png?w=768 768w, https://danlarkorg.files.wordpress.com/2022/04/image-24.png 1332w" sizes="(max-width: 1024px) 100vw, 1024px"/><figcaption><a href="https://gcc.godbolt.org/z/59TMfhs6v" target="_blank" rel="noreferrer noopener">https://gcc.godbolt.org/z/59TMfhs6v</a></figcaption></figure>



<p>I guess this is the reinforcement learning authors talk about in the patch. Generation helped to find an opportunity by finding that if in a triple (X, Y, Z) the last 2 elements (Y &lt;= Z) are sorted, it can be better done in 7 instructions rather than 8.</p>



<ol><li>Move Z into tmp.</li><li>Compare X and Z.</li><li>Conditionally move X into Z.</li><li>Conditionally move X into tmp</li><li><s>Move tmp into X.</s>                             <strong>this was deleted</strong></li><li>Compare tmp and Y.</li><li>Conditionally move Y into X.</li><li>Conditionally move tmp into Y.</li></ol>



<p>For sorting 4 integers there is no optimal network with such a pair of comparisons but for sort 5 there can be up to 3 pairs. In the end, patch found how to save 1 instruction in each red circle below. They are exactly pairs of wires where 2 elements are already sorted .</p>



<figure><img data-attachment-id="1048" data-permalink="https://danlark.org/sorting_networks-drawio-4/" data-orig-file="https://danlarkorg.files.wordpress.com/2022/04/sorting_networks.drawio-4.png" data-orig-size="853,667" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="sorting_networks.drawio-4" data-image-description="" data-image-caption="" data-medium-file="https://danlarkorg.files.wordpress.com/2022/04/sorting_networks.drawio-4.png?w=300" data-large-file="https://danlarkorg.files.wordpress.com/2022/04/sorting_networks.drawio-4.png?w=750" src="https://danlarkorg.files.wordpress.com/2022/04/sorting_networks.drawio-4.png?w=853" alt="" srcset="https://danlarkorg.files.wordpress.com/2022/04/sorting_networks.drawio-4.png 853w, https://danlarkorg.files.wordpress.com/2022/04/sorting_networks.drawio-4.png?w=150 150w, https://danlarkorg.files.wordpress.com/2022/04/sorting_networks.drawio-4.png?w=300 300w, https://danlarkorg.files.wordpress.com/2022/04/sorting_networks.drawio-4.png?w=768 768w" sizes="(max-width: 853px) 100vw, 853px"/></figure>



<p>In the end that helped to reduce the number of instructions per small cases from <strong>18-&gt;17</strong> when comparing 3 integers, <strong>46-&gt;43</strong> when comparing 5 integers. Then there comes a question: in order to minimize the number of instructions, we likely want to produce such networks with the most amount of such magic swaps, that’s an open and great question to think about.</p>



<p>Are they actually faster? Well, in <strong>18-&gt;17</strong> case it is not always like that because the removed <code>mov</code> is greatly pipelined. It is still less work for the processor frontend to decode the instruction but you are not likely to see anything in the benchmarks. For <strong>46-&gt;43</strong> the situation is the same.</p>



<figure><img data-attachment-id="1053" data-permalink="https://danlark.org/image-25/" data-orig-file="https://danlarkorg.files.wordpress.com/2022/04/image-25.png" data-orig-size="954,723" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-25" data-image-description="" data-image-caption="" data-medium-file="https://danlarkorg.files.wordpress.com/2022/04/image-25.png?w=300" data-large-file="https://danlarkorg.files.wordpress.com/2022/04/image-25.png?w=750" src="https://danlarkorg.files.wordpress.com/2022/04/image-25.png?w=954" alt="" srcset="https://danlarkorg.files.wordpress.com/2022/04/image-25.png 954w, https://danlarkorg.files.wordpress.com/2022/04/image-25.png?w=150 150w, https://danlarkorg.files.wordpress.com/2022/04/image-25.png?w=300 300w, https://danlarkorg.files.wordpress.com/2022/04/image-25.png?w=768 768w" sizes="(max-width: 954px) 100vw, 954px"/><figcaption>Sort3 18 vs 17 instructions <a rel="noreferrer noopener" href="https://gcc.godbolt.org/z/eaoKscqY4" target="_blank">https://quick-bench.com/q/0THJhOe5q2-vQsEy4v5DrAFGzBc</a>. For Sort5 46 vs 43, see <a rel="noreferrer noopener" href="https://quick-bench.com/q/NXRFUJdHUoG6KMFSQ9B3fiVSKZ4" target="_blank">https://quick-bench.com/q/NXRFUJdHUoG6KMFSQ9B3fiVSKZ4</a></figcaption></figure>



<p>LLVM review claimed to save around 2-3% for integer benchmarks but they all mostly come from the transition from branchy version to a branchless one. Instruction reduction does not help much but anyway is a good story how machine learning can help driving compiler optimizations in such primitives as sorting networks together with assembly generation. I highly recommend reading the patch for all C++ lovers, it has lots of lovely ideas and sophisticated discussions on how to make it right<a href="#footnotes"><sup>31</sup></a>.</p>







<h2>How can you help?</h2>



<p>There are many things that are not yet done. Here is by no means an exhaustive list of things you can help with:</p>



<ul><li>In debug modes introduce randomization described above.<ul><li>This can be done for the GNU library, Microsoft STL, other languages like Rust, D, etc.</li></ul></li><li>Introduce strict weak ordering debug checks in all functions that require it.<ul><li><code>std::sort, std::partial_sort, std::nth_element, std::min_element, std::max_element, std::stable_sort</code>, others, in all C++ standard libraries. In all other languages like Rust, Java, Python, D, etc. As we said, checking at most 20 elements per call seems to be ok. You can also introduce sampling if needed.</li></ul></li><li>In your C++ project try to introduce a debug mode which sets <code>_LIBCPP_DEBUG</code> to some level<sup><a href="#footnotes">27</a></sup>.</li><li>Consider randomization for the APIs that can be relied on at least in testing/debug mode. Seeding the hash function differently for not relying on the order of iteration of hashtables. If the function requires to be only associative, try to accumulate results in different order, etc.</li><li>Fix worst case <code>std::nth_element</code> in all standard library implementations.</li><li>Optimize assembly generation for sorts (small, big, partitions) even further. As you can see, there is room for optimizations there as well!</li></ul>



<h2>Final thoughts</h2>



<p>We started this process more than a year ago (of course, not full time), and the first primary goal was performance. However, it turned out to be a much more sophisticated issue. We found several hundred bugs (including pretty critical ones). In the end, we figured out a way to prevent bugs from happening in the future which will help us to adopt any correct implementation and, for example, see wins right away without being blocked by broken tests. We suggest if your codebase is huge, adopt the build flag from libcxx and prepare yourself for the migration. Most importantly, this effort produced a story on how to change even simplest things at scale, how to fight Hyrum’s Law, and I am glad to be a part of the effort to help open source learn from it.</p>



<h3>Acknowledgements</h3>



<p>Thanks to Nilay Vaish who pushed the changes for a new sort to LLVM, thanks to Louis Dionne, the maintainer of libcxx, who patiently accepted our changes. Thanks to Morwenn for outstanding work on sorting from which I learned a lot<sup><a href="#footnotes">5</a></sup>. Thanks to Orson Peters and pdqsort which greatly improved the performance of modern in-memory sorting.</p>







<ol><li>The famous textbook from Cormen and others <a rel="noreferrer noopener" href="https://mitpress.mit.edu/books/introduction-algorithms-fourth-edition" target="_blank">Introduction to Algorithms</a> devotes over 50 pages to sorting algorithms.</li><li>Ani Kristo, Kapil Vaidya, Ugur Çetintemel, Sanchit Misra, and Tim Kraska. 2020. <a rel="noreferrer noopener" href="https://doi.org/10.1145/3318464.3389752" target="_blank">The Case for a Learned Sorting Algorithm</a>. SIGMOD ’20.</li><li><a rel="noreferrer noopener" href="https://news.ycombinator.com/item?id=14666710" target="_blank">Hackernews: “I think it’s fair to say that pdqsort (pattern-defeating quicksort) is overall the best”</a></li><li><a rel="noreferrer noopener" href="https://arxiv.org/abs/1705.02257" target="_blank">In-place Parallel Super Scalar Samplesort (IPS4o)</a></li><li><a rel="noreferrer noopener" href="https://github.com/Morwenn/cpp-sort" target="_blank">https://github.com/Morwenn/cpp-sort</a> — collection of most fun and efficient sorting algorithms written in C++</li><li><a rel="noreferrer noopener" href="https://llvm.org/devmtg/2010-11/Hinnant-libcxx.pdf" target="_blank">libc++: A Standard Library for C++0x</a>, Howard Hinnant, 2010 LLVM Developers’ Meeting</li><li>One of the most popular sorting calls at Google <a rel="noreferrer noopener" href="https://github.com/protocolbuffers/protobuf/blob/61dcf50b85b7e2060e03bb99f88540d81eedb125/src/google/protobuf/generated_message_reflection.cc#L1548" target="_blank">ListFieldsMayFailOnStripped</a></li><li>H. Mannila, “Measures of Presortedness and Optimal Sorting Algorithms,” in IEEE Transactions on Computers, vol. C-34, no. 4, pp. 318-325, April 1985, doi: 10.1109/TC.1985.5009382.</li><li><a rel="noreferrer noopener" href="https://en.wikipedia.org/wiki/C%2B%2B_Standard_Library" target="_blank">https://en.wikipedia.org/wiki/C%2B%2B_Standard_Library</a></li><li><a rel="noreferrer noopener" href="https://github.com/lijiansong/stl-impl/blob/master/stl-impl/stl/ALGO.H" target="_blank">Original std::sort implementation by Stepanov and Lee</a></li><li>Antiquicksort: <a rel="noreferrer noopener" href="https://www.cs.dartmouth.edu/~doug/aqsort.c" target="_blank">https://www.cs.dartmouth.edu/~doug/aqsort.c</a></li><li><a rel="noreferrer noopener" href="https://en.wikipedia.org/wiki/Quickselect" target="_blank">Quickselect</a></li><li><a rel="noreferrer noopener" href="https://github.com/gcc-mirror/gcc/blob/16e2427f50c208dfe07d07f18009969502c25dc8/libstdc%2B%2B-v3/include/bits/stl_algo.h#L1972" target="_blank">nth_element worst case fallback in GNU libstdc++</a></li><li><a rel="noreferrer noopener" href="https://arxiv.org/abs/1606.00484" target="_blank">Fast Deterministic Selection by Andrei Alexandrescu</a></li><li><a rel="noreferrer noopener" href="https://en.wikipedia.org/wiki/Introsort" target="_blank">Introsort</a></li><li><a rel="noreferrer noopener" href="https://en.wikipedia.org/wiki/Median_of_medians" target="_blank">Median of medians</a></li><li><a rel="noreferrer noopener" href="https://reviews.llvm.org/D36423" target="_blank">[libc++] Introsort based sorting function (2017, unsubmitted)</a></li><li><a rel="noreferrer noopener" href="https://www.reddit.com/r/cpp/comments/2fa7i1/libc_has_quadratic_stdsort/" target="_blank">libc++ has quadratic std::sort (reddit discussion)</a></li><li><a rel="noreferrer noopener" href="https://reviews.llvm.org/D113413" target="_blank">Add introsort to avoid O(n^2) behavior and a benchmark for adversarial quick sort input (submitted).</a></li><li><a rel="noreferrer noopener" href="https://reviews.llvm.org/D96946" target="_blank">[libcxx][RFC] Unspecified behavior randomization in libcxx</a></li><li><a rel="noreferrer noopener" href="https://en.wikipedia.org/wiki/Address_space_layout_randomization" target="_blank">ASLR (address space layout randomization)</a></li><li><a rel="noreferrer noopener" href="https://github.com/ClickHouse/ClickHouse/pull/34393/files" target="_blank">Sort added equal items ranges randomization (ClickHouse)</a></li><li><a rel="noreferrer noopener" href="https://github.com/ClickHouse/ClickHouse/pull/34175/files" target="_blank">bitsetsort peformance check (ClickHouse)</a></li><li><a rel="noreferrer noopener" href="https://rosettacode.org/wiki/Sort_stability" target="_blank">Sort stability defaults in different programming languages</a></li><li><a rel="noreferrer noopener" href="https://docs.google.com/presentation/d/1cujdIkbwnbjd753rZH_qH7kmCGjR6rpoHIZEBkxdw9I/edit?usp=sharing" target="_blank">All found open source issues (slides with repo names, commits and files)</a></li><li><a rel="noreferrer noopener" href="https://en.cppreference.com/w/cpp/language/inline" target="_blank">Inline variables in C++</a></li><li><a rel="noreferrer noopener" href="https://libcxx.llvm.org/DesignDocs/DebugMode.html" target="_blank">Debug mode in libcxx</a></li><li>Stefan Edelkamp and Armin Weiß. 2019. BlockQuicksort: Avoiding Branch Mispredictions in Quicksort. ACM J. Exp. Algorithmics 24, Article 1.4 (2019), 22 pages. DOI:<a rel="noreferrer noopener" href="https://doi.org/10.1145/3274660" target="_blank">https://doi.org/10.1145/3274660</a>.</li><li>Kaligosi, K., &amp; Sanders, P. (2006). How Branch Mispredictions Affect Quicksort. Algorithms – ESA 2006, 780–791. doi:10.1007/11841036_69</li><li><a rel="noreferrer noopener" href="https://jix.one/proving-50-year-old-sorting-networks-optimal-part-1/" target="_blank">Proving 50-Year-Old Sorting Networks Optimal</a></li><li><a rel="noreferrer noopener" href="https://reviews.llvm.org/D118029" target="_blank">Introduce branchless sorting functions for sort3, sort4 and sort5 (LLVM review)</a></li></ol>



<figure><div>
<div><blockquote data-width="550" data-dnt="true"><p lang="en" dir="ltr">We are changing std::sort in libcxx. That’s a long story of what it took us to get there, all bugs you might encounter with many examples from OSS. We submitted almost all changes to upstream and thus I can freely talk about them and how you can use them<a href="https://t.co/3MzIJQD4wP">https://t.co/3MzIJQD4wP</a></p>— Danila Kutenin (@Danlark1) <a href="https://twitter.com/Danlark1/status/1516804524899459079?ref_src=twsrc%5Etfw">April 20, 2022</a></blockquote></div>
</div></figure>
	</div></div>
  </body>
</html>
