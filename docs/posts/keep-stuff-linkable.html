<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://animaomnium.github.io/keep-stuff-linkable/">Original</a>
    <h1>Keep stuff linkable</h1>
    
    <div id="readability-page-1" class="page"><div>
<p><i>
  2023-04-17 •
  8 minutes required •
  <a href="https://github.com/animaomnium">Anima Omnium</a>
</i></p>

<p>You’ve spent hours absorbing <a rel="noopener nofollow" target="_blank" href="https://news.ycombinator.com">incoming</a> <a rel="noopener nofollow" target="_blank" href="https://lobste.rs">bitstreams</a>, and a seed of an idea has germinated in your mind. You fire up your <a rel="noopener nofollow" target="_blank" href="https://neovim.io">favorite text editor</a>, plant it down, and spend a couple hours letting the idea grow out. You’ve finished! You are about to publish your freshly-grown bitstream on the interwebs when you get <em>that sinking feeling</em> in your gut: something’s missing…</p>
<p>You scan over the post. Is anything wrong? Nope: argument is solid, formatting is A-Ok: <a rel="noopener nofollow" target="_blank" href="https://en.wikipedia.org/wiki/OK">oll korrect</a>. But wait… what’s that?</p>
<p>Where are all the links?</p>
<p>No <a rel="noopener nofollow" target="_blank" href="https://en.wikipedia.org/wiki/Hyperlink">links</a>, no game. (It is the <em>Web</em> you are publishing to, after all.) Sighing, you stumble around with <a rel="noopener nofollow" target="_blank" href="https://duckduckgo.com">Google</a> for a bit before giving up. Maybe some other time. If only there were a better way…</p>
<p>Finding links sucks. </p>
<p>It may be my lack of discipline, but keeping track of the references principally responsible for each little bit of text I write is <em>hard</em>. I have so many linkless posts waiting to be published: I could go ahead and publish them as-is, but by doing so I feel as though I’d be treating you, dear reader, unjustly.</p>
<p>I wish there was a faster way to link the posts I write. I want to <a rel="noopener nofollow" target="_blank" href="https://simonwillison.net/2023/Apr/16/web-llm/">write about things that are happening <em>now</em></a>. If I wait a week to hunt down references, things will have already moved on. <a rel="noopener nofollow" target="_blank" href="https://blog.codinghorror.com/how-to-achieve-ultimate-blog-success-in-one-easy-step/">Writing consistently</a> requires rhythm, and nothing interrupts a consistent rhythm more effectively than haphazardly tumbling down <a rel="noopener nofollow" target="_blank" href="https://en.wikipedia.org/wiki/Rabbit_Hole">internet rabbit-holes</a> while in search of the perfect link.</p>
<p>In a perfect world, I imagine a little companion reading everything alongside me. He records the references and key ideas of each piece. After I write a post, he’d comb through my post sentence by sentence, linking every important phrase to its source. Now, I haven’t quite done this, but I’ve developed a quick-and-dirty <a rel="noopener nofollow" target="_blank" href="https://en.wikipedia.org/wiki/Order_of_approximation">first-order approximation</a>, which should hopefully let me link stuff with greater ease. Let’s dive in.</p>
<p><em>Linkoln</em>, no pun intended, is the name of my companion. It’s a short hacky <a rel="noopener nofollow" target="_blank" href="https://www.python.org">Python</a> script I wrote this morning, so I could link and publish this post. All links in this post are Linkoln’s fault, not mine.</p>
<p>Linkoln parses <a rel="noopener nofollow" target="_blank" href="https://en.wikipedia.org/wiki/Help:Link">wikilinks</a> out of a <a rel="noopener nofollow" target="_blank" href="https://commonmark.org/help/">markdown</a> document, and searches the <a rel="noopener nofollow" target="_blank" href="https://en.wikipedia.org/wiki/World_Wide_Web">world wide web</a> to find a <a rel="noopener nofollow" target="_blank" href="https://en.wikipedia.org/wiki/Hyperlink">hyperlink</a> for each one.</p>
<p>Here’s what Linkoln does, on a more concrete level. Given a Markdown post with wikilinks:</p>
<pre><code><span># Thoughts on Rust
</span><span>
</span><span>[[programming language:Rust]] is a [[systems programming language]] bootstrapped from [[rust prehistory|OCaml]].
</span></code></pre>
<p>Linkoln normalizes the post, replacing each wikilink with the best corresponding hyperlink it could find on the web, using <a rel="noopener nofollow" target="_blank" href="https://duckduckgo.com">Google</a>:</p>
<pre><code><span># Thoughts on Rust
</span><span>
</span><span>[Rust][1] is a [systems programming language][2] bootstrapped from [OCaml][3].
</span><span>
</span><span>[1]: https://www.rust-lang.org
</span><span>[2]: https://en.wikipedia.org/wiki/System_programming_language
</span><span>[3]: https://github.com/graydon/rust-prehistory
</span></code></pre>
<p>Linkoln supports three types of wikilinks:</p>
<ol>
<li>Literal Links: <code>[[text]]</code> </li>
<li>Query Links: <code>[[query|text]]</code></li>
<li>Context Links: <code>[[context:text]]</code></li>
</ol>
<p>Here’s a quick breakdown of each link type:</p>
<p><em>Literal Links</em> search the given query and include the query verbatim. For example:</p>
<pre><code><span>[[GitHub]]
</span></code></pre>
<p>Searches “GitHub” and becomes:</p>
<pre><code><span>[GitHub][0]
</span><span>
</span><span>[0]: https://github.com
</span></code></pre>
<p><em>Query Links</em> let you use a different query than the text of the link. For example:</p>
<pre><code><span>[[notes on a smaller rust|Rust *could* be easier]]
</span></code></pre>
<p>Searches “notes on a smaller rust” and becomes:</p>
<pre><code><span>[Rust *could* be easier][0]
</span><span>
</span><span>[0]: https://boats.gitlab.io/blog/posts/notes-on-a-smaller-rust
</span></code></pre>
<p><em>Context Links</em> are useful when qualifying a search for an otherwise generic term. The two halves are <a rel="noopener nofollow" target="_blank" href="https://en.wikipedia.org/wiki/Concatenation">concatenated</a> to form the entire query:</p>
<pre><code><span>[[wikipedia language:Python]]
</span></code></pre>
<p>Searches “wikipedia language Python” and becomes:</p>
<pre><code><span>[Python][0]
</span><span>
</span><span>[0]: https://en.wikipedia.org/wiki/Python_(programming_language)
</span></code></pre>
<p>Despite its simplicity, I’ve been getting a lot of mileage out of Linkoln. I can keep all my link-searching activity in one place: Once I’ve finished a post, I can bracket off terms to link, qualifying searches as necessary with advanced <a rel="noopener nofollow" target="_blank" href="https://www.urbandictionary.com/define.php?term=googlefoo">google-foo</a>, and Linkoln takes care of the rest.</p>
<details>
<summary>The script itself is… pretty dumb.</summary>
<p>But, since you asked for it, here it is:</p>
<pre data-lang="python"><code data-lang="python"><span>#!/usr/bin/python3
</span><span>
</span><span># Linkoln by Anima Omnium
</span><span># Dedicated to the Public Domain
</span><span>
</span><span># Just standard library for portability 
</span><span>import </span><span>sys
</span><span>import </span><span>urllib</span><span>.</span><span>request
</span><span>import </span><span>time
</span><span>
</span><span># Input from file, output to stdout
</span><span># Suggested usage:
</span><span># python linkoln.py INPUT.md &gt; OUTPUT.md
</span><span>
</span><span># Read input file name
</span><span>if </span><span>len</span><span>(</span><span>sys</span><span>.</span><span>argv</span><span>) != </span><span>2</span><span>:
</span><span>  </span><span>print</span><span>(&#34;</span><span>Usage: linkoln FILE</span><span>&#34;)
</span><span>  </span><span>exit</span><span>(</span><span>1</span><span>)
</span><span>
</span><span># Read file
</span><span>FILE </span><span>= </span><span>sys</span><span>.</span><span>argv</span><span>[</span><span>1</span><span>]
</span><span>with </span><span>open</span><span>(</span><span>FILE</span><span>, &#34;</span><span>r</span><span>&#34;) </span><span>as </span><span>fin</span><span>:
</span><span>  INPUT </span><span>= </span><span>fin</span><span>.</span><span>read</span><span>()
</span><span>
</span><span># Link numbering start
</span><span>OFFSET </span><span>= </span><span>1
</span><span>
</span><span># Ignore wikilinks in code, headings, frontmatter
</span><span>IGNORE </span><span>= [
</span><span>  </span><span>(&#34;</span><span>```</span><span>&#34;, &#34;</span><span>```</span><span>&#34;),
</span><span>  </span><span>(&#34;</span><span>#</span><span>&#34;, &#34;\n&#34;),
</span><span>  </span><span>(&#34;</span><span>`</span><span>&#34;, &#34;</span><span>`</span><span>&#34;),
</span><span>  </span><span>(&#34;</span><span>+++</span><span>&#34;, &#34;</span><span>+++</span><span>&#34;),
</span><span>]
</span><span>
</span><span># Syntax for links
</span><span>LINK_OPEN </span><span>= &#34;</span><span>[[</span><span>&#34;
</span><span>LINK_CLOSE </span><span>= &#34;</span><span>]]</span><span>&#34;
</span><span>LINK_QUERY </span><span>= &#34;</span><span>|</span><span>&#34;
</span><span>LINK_CONTEXT </span><span>= &#34;</span><span>:</span><span>&#34;
</span><span>
</span><span># Parser state enum
</span><span>S_IGNORE </span><span>= </span><span>0
</span><span>S_SCANIN </span><span>= </span><span>1
</span><span>S_EATING </span><span>= </span><span>2
</span><span>
</span><span># Initialize parser
</span><span>state </span><span>= </span><span>S_SCANIN
</span><span>rem </span><span>= </span><span>INPUT
</span><span>closing </span><span>= &#34;&#34;
</span><span>inside </span><span>= &#34;&#34;
</span><span>colophon </span><span>= []
</span><span>
</span><span># Skip amt chars
</span><span>def </span><span>skip</span><span>(</span><span>r</span><span>, </span><span>amt</span><span>):
</span><span>  </span><span>return </span><span>r</span><span>[</span><span>amt</span><span>:]
</span><span>
</span><span># Skip amt, echo what was skipped
</span><span>def </span><span>eat</span><span>(</span><span>r</span><span>, </span><span>amt</span><span>):
</span><span>  </span><span>print</span><span>(</span><span>r</span><span>[:</span><span>amt</span><span>], </span><span>end</span><span>=&#34;&#34;)
</span><span>  </span><span>return </span><span>skip</span><span>(</span><span>r</span><span>, </span><span>amt</span><span>)
</span><span>
</span><span># Check r prefix matches against
</span><span>def </span><span>check</span><span>(</span><span>r</span><span>, </span><span>against</span><span>):
</span><span>  </span><span>return </span><span>r</span><span>[:</span><span>len</span><span>(</span><span>against</span><span>)] == </span><span>against
</span><span>
</span><span># Parse inside wikilink
</span><span>def </span><span>extract</span><span>(</span><span>inside</span><span>):
</span><span>  </span><span>(</span><span>link</span><span>, </span><span>text</span><span>) = (</span><span>inside</span><span>, </span><span>inside</span><span>)
</span><span>  </span><span>if </span><span>LINK_QUERY </span><span>in </span><span>inside</span><span>:
</span><span>    </span><span>(</span><span>link</span><span>, </span><span>text</span><span>) = </span><span>inside</span><span>.</span><span>split</span><span>(</span><span>LINK_QUERY</span><span>)
</span><span>  </span><span>elif </span><span>LINK_CONTEXT </span><span>in </span><span>inside</span><span>:
</span><span>    </span><span>(</span><span>link</span><span>, </span><span>text</span><span>) = </span><span>inside</span><span>.</span><span>split</span><span>(</span><span>LINK_CONTEXT</span><span>)
</span><span>    link </span><span>= </span><span>f</span><span>&#34;{</span><span>link</span><span>} {</span><span>text</span><span>}&#34;
</span><span>  </span><span>return </span><span>(</span><span>link</span><span>, </span><span>text</span><span>)
</span><span>
</span><span># Echo formatted link
</span><span>def </span><span>emit_link</span><span>(</span><span>entry</span><span>):
</span><span>  </span><span>(</span><span>num</span><span>, </span><span>inside</span><span>) = </span><span>entry
</span><span>  </span><span>(</span><span>_</span><span>, </span><span>inside</span><span>) = </span><span>extract</span><span>(</span><span>inside</span><span>)
</span><span>  </span><span>print</span><span>(</span><span>f</span><span>&#34;</span><span>[</span><span>{</span><span>inside</span><span>}</span><span>][</span><span>{</span><span>num</span><span>}</span><span>]</span><span>&#34;, </span><span>end</span><span>=&#34;&#34;)
</span><span>
</span><span># Echo formatted link reference
</span><span>def </span><span>emit_entry</span><span>(</span><span>entry</span><span>):
</span><span>  </span><span>(</span><span>num</span><span>, </span><span>inside</span><span>) = </span><span>entry
</span><span>  </span><span>(</span><span>inside</span><span>, </span><span>_</span><span>) = </span><span>extract</span><span>(</span><span>inside</span><span>)
</span><span>  inside </span><span>= </span><span>google_it</span><span>(</span><span>inside</span><span>)
</span><span>  </span><span>print</span><span>(</span><span>f</span><span>&#34;</span><span>[</span><span>{</span><span>num</span><span>}</span><span>]: </span><span>{</span><span>inside</span><span>}&#34;)
</span><span>
</span><span># Locate link matching given query
</span><span>def </span><span>google_it</span><span>(</span><span>query</span><span>):
</span><span>  </span><span># Dumbest most fragile hack ever
</span><span>  quoted </span><span>= </span><span>urllib</span><span>.</span><span>parse</span><span>.</span><span>quote</span><span>(</span><span>query</span><span>, </span><span>safe</span><span>=&#39;&#39;)
</span><span>  </span><span># Don&#39;t hammer friends at DuckDuckGo
</span><span>  </span><span>time</span><span>.</span><span>sleep</span><span>(</span><span>0</span><span>.</span><span>5</span><span>)
</span><span>  </span><span>try</span><span>:
</span><span>    contents </span><span>= </span><span>urllib</span><span>.</span><span>request</span><span>.</span><span>urlopen</span><span>(</span><span>f</span><span>&#34;</span><span>https://lite.duckduckgo.com/lite/search&amp;q=</span><span>{</span><span>quoted</span><span>}&#34;).</span><span>read</span><span>()
</span><span>    </span><span># Parsing html is easy
</span><span>    top_result </span><span>= </span><span>contents</span><span>.</span><span>split</span><span>(</span><span>b</span><span>&#34;</span><span>link-text</span><span>&#34;)[</span><span>1</span><span>]
</span><span>    top_link </span><span>= </span><span>top_result</span><span>.</span><span>split</span><span>(</span><span>b</span><span>&#34;</span><span>&gt;</span><span>&#34;)[</span><span>1</span><span>].</span><span>split</span><span>(</span><span>b</span><span>&#34;</span><span>&lt;</span><span>&#34;)[</span><span>0</span><span>]
</span><span>  </span><span>except</span><span>:
</span><span>    </span><span># Leave for human to fix 
</span><span>    </span><span>return f</span><span>&#34;</span><span>ERROR: </span><span>{</span><span>query</span><span>}&#34;
</span><span>  </span><span>return </span><span>&#34;</span><span>https://</span><span>&#34; + </span><span>top_link</span><span>.</span><span>decode</span><span>(&#34;</span><span>utf-8</span><span>&#34;)
</span><span>
</span><span># State machine driving loop
</span><span>while </span><span>rem </span><span>!= &#34;&#34;:
</span><span>  </span><span># Scanning for next link or comment 
</span><span>  </span><span>if </span><span>state </span><span>== </span><span>S_SCANIN</span><span>:
</span><span>    </span><span>for </span><span>(</span><span>open</span><span>, </span><span>close</span><span>) </span><span>in </span><span>IGNORE</span><span>:
</span><span>      </span><span>try</span><span>:
</span><span>        </span><span>if </span><span>check</span><span>(</span><span>rem</span><span>, </span><span>open</span><span>):
</span><span>          rem </span><span>= </span><span>eat</span><span>(</span><span>rem</span><span>, </span><span>len</span><span>(</span><span>open</span><span>))
</span><span>          closing </span><span>= </span><span>close
</span><span>          state </span><span>= </span><span>S_IGNORE
</span><span>          </span><span>break
</span><span>      </span><span>except</span><span>:
</span><span>        </span><span>pass
</span><span>    </span><span>if </span><span>state </span><span>== </span><span>S_IGNORE</span><span>:
</span><span>      </span><span>continue
</span><span>    </span><span>try</span><span>:
</span><span>      </span><span>if </span><span>check</span><span>(</span><span>rem</span><span>, </span><span>LINK_OPEN</span><span>):
</span><span>        rem </span><span>= </span><span>skip</span><span>(</span><span>rem</span><span>, </span><span>len</span><span>(</span><span>LINK_OPEN</span><span>))
</span><span>        inside </span><span>= &#34;&#34;
</span><span>        state </span><span>= </span><span>S_EATING
</span><span>        </span><span>continue
</span><span>    </span><span>except</span><span>:
</span><span>      </span><span>pass
</span><span>    rem </span><span>= </span><span>eat</span><span>(</span><span>rem</span><span>, </span><span>1</span><span>)
</span><span>
</span><span>  </span><span># Eating contents of wikilink
</span><span>  </span><span>elif </span><span>state </span><span>== </span><span>S_EATING</span><span>:
</span><span>    </span><span>if </span><span>check</span><span>(</span><span>rem</span><span>, </span><span>LINK_CLOSE</span><span>):
</span><span>      rem </span><span>= </span><span>skip</span><span>(</span><span>rem</span><span>, </span><span>len</span><span>(</span><span>LINK_CLOSE</span><span>))
</span><span>      entry </span><span>= (</span><span>len</span><span>(</span><span>colophon</span><span>) + </span><span>OFFSET</span><span>, </span><span>inside</span><span>)
</span><span>      </span><span>emit_link</span><span>(</span><span>entry</span><span>)
</span><span>      </span><span>colophon</span><span>.</span><span>append</span><span>(</span><span>entry</span><span>)
</span><span>      state </span><span>= </span><span>S_SCANIN
</span><span>    </span><span>else</span><span>:
</span><span>      inside </span><span>= </span><span>inside </span><span>+ </span><span>rem</span><span>[:</span><span>1</span><span>]
</span><span>      rem </span><span>= </span><span>skip</span><span>(</span><span>rem</span><span>, </span><span>1</span><span>)
</span><span>
</span><span>  </span><span># Ignoring contents of comments
</span><span>  </span><span>elif </span><span>state </span><span>== </span><span>S_IGNORE</span><span>:
</span><span>    </span><span>if </span><span>check</span><span>(</span><span>rem</span><span>, </span><span>closing</span><span>):
</span><span>      rem </span><span>= </span><span>eat</span><span>(</span><span>rem</span><span>, </span><span>len</span><span>(</span><span>closing</span><span>))
</span><span>      state </span><span>= </span><span>S_SCANIN
</span><span>    </span><span>else</span><span>:
</span><span>      rem </span><span>= </span><span>eat</span><span>(</span><span>rem</span><span>, </span><span>1</span><span>)
</span><span>
</span><span>  </span><span># Frick your computer is on fire
</span><span>  </span><span>else</span><span>:
</span><span>    </span><span>assert </span><span>false, </span><span>&#34;</span><span>Invalid state</span><span>&#34;
</span><span>
</span><span># Google all the queries
</span><span>print</span><span>()
</span><span>for </span><span>entry </span><span>in </span><span>colophon</span><span>:
</span><span>  </span><span>emit_entry</span><span>(</span><span>entry</span><span>)
</span></code></pre>
</details>
<p>Linkoln is by no means a silver bullet: it’s not intended to be one. The point of this post is not to highlight some gimmicky throwaway python script, but to express, perhaps, a little worry over why I think linking stuff is so important.</p>
<p>Despite Linkoln’s reliance on them, the need for web-wide search engines could be said to be a failure in the organizational structure of the web. As the proliferation of <a rel="noopener nofollow" target="_blank" href="https://openai.com/research/gpt-4">GPT-4</a> leads to the crystallization of the <a rel="noopener nofollow" target="_blank" href="https://www.theatlantic.com/technology/archive/2021/08/dead-internet-theory-wrong-but-feels-true/619937/">Dead Internet</a>, how will we find a single live page in a soup of procedurally generated web-gloop?</p>
<p>Perhaps links <em>are</em> dead. Why link when ChatGPT can explain? Why post and upvote when <a rel="noopener nofollow" target="_blank" href="https://gantry.io/blog/papers-to-know-20230110">attention-maximizing algorithms</a> can recommend? Perhaps we’re at the end of the old-web, now a corner relegated to hobbyists, as all text ever written is absorbed in a single differentiable scream.</p>
<p>For us hobbyists, however, perhaps links <em>aren’t</em> dead: they’re vitally important. Links lend authority. Trace a hop away from your homepage, maybe two: can you still trust what you read? Does it matter?</p>
<p>So in this deluge, link <em>more</em>, not less. Don’t link to stuff you don’t trust, SEO or otherwise. If using a tool like Linkoln—script, chatbot, or otherwise—make sure you vet what you’re linking to. You are not <em>just</em> linking, but building a Web of Trust: <em>this</em> is <em>key</em>.</p>
<p>Links aren’t dead. Neither is the old web. Keep the dream of an open web alive: Keep Stuff Linkable! </p>
<p>Happy linking!</p>

<p><i>
  <a href="https://lobste.rs/stories/new?url=https%3A//animaomnium.github.io/keep-stuff-linkable/">Lobsters</a> •
  <a href="https://news.ycombinator.com/submitlink?u=https%3A//animaomnium.github.io/keep-stuff-linkable/&amp;t=Keep%20Stuff%20Linkable">HN</a> •
  <a href="https://www.reddit.com/submit?url=https%3A//animaomnium.github.io/keep-stuff-linkable/">Reddit</a> •
  <a href="http://twitter.com/share?url=https%3A//animaomnium.github.io/keep-stuff-linkable/&amp;text=Keep%20Stuff%20Linkable">Twitter</a>
</i></p>
</div></div>
  </body>
</html>
