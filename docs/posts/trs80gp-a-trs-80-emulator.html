<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://48k.ca/trs80gp.html">Original</a>
    <h1>Trs80gp – A TRS-80 Emulator</h1>
    
    <div id="readability-page-1" class="page"><div id="content">

<div><a href="https://ideasimagerystory.substack.com/p/trs80gp-2.4.10.zip"><b>Download</b></a></div>


<p>
trs80gp primarily emulates the &#34;gray&#34; line of TRS-80 computers made by Tandy in the
late 1970s and early 1980s.  They are known as the
<a href="http://en.wikipedia.org/wiki/TRS-80">Model I</a>,
<a href="https://en.wikipedia.org/wiki/TRS-80_Model_II">Model II</a>,
Model III, Model 4, Model 4P, Model 4D, Model 12, Model 16 and Model 6000.
It is generally easier to use ordinary digits for the Model 1, Model 2 and
Model 3.
The Model 1, 3 and 4 are a line of compatible computers as
is the Model 2, 12, 16 and 6000.

</p><p>Also emulated are the TRS-80 Micro Color Computer Model MC-10,
the TRS-80 DT-1 Data Terminal, TRS-80 Videotex and
the Electric Crayon external colour display.

</p><p>
The emulator runs on Windows from XP all the way up to Windows 10.
Included in the download are versions for MacOS, Linux and Raspberry Pi.
They may not be at full feature parity with the Windows version but the
emulator runs just fine under <a href="https://www.winehq.org/">Wine</a>.
It should run well on any machine produced in the past decade.

</p><p>
trs80gp provides accurate and near complete emulation with excellent
programmer support.  The source code is
fully organic and hand-crafted by myself and my brother Peter.

</p><p>
For older versions and checksums, please consult
<a href="https://ideasimagerystory.substack.com/p/trs80gp-release-notes.html">the release notes.</a>

</p><h3>Community</h3><p>

Bug reports, feature requests or other inquiries about the trs80gp emulator
are best e-mailed to me (see bottom of this page for the address).  There is
a community of TRS-80 users still out there who can help with questions
operating the machines (in both emulated or physical form) and even some
amount of expertise on trs80gp itself.

</p><p>
I&#39;ve recently created a
<a href="https://www.facebook.com/groups/trs80gp">trs80gp Facebook group</a>
and a
<a href="https://discord.gg/QNBnQP3f2q">trs80gp Discord server</a>
as venues for more interactive discussion.  You may not find many people there
but I will keep an eye on them myself.

</p><p>
The most active TRS-80 forum is the
<a href="https://forum.vcfed.org/index.php?forums/tandy-radio-shack.58/">Tandy Radio Shack</a>
section of the Vintage Computing Feduration forums.  There is also a somewhat
less busy <a href="https://atariage.com/forums/forum/174-tandy-computers/">Tandy Computers</a>
forum on AtariAge and a very lightly used
<a href="https://www.reddit.com/r/trs80">TRS-80 subreddit.</a>
There are also a handful of facebook groups dedicated to the TRS-80 models that
trs80gp emulates.

</p><h3>Features</h3>

<ul>
<li>Emulates floppy disk, hard drive, cassette, hires graphics, Orchestra 80/85/90 and printer.
</li><li>Window scalable to any size with realistic phosphor-dot rendering.
</li><li>Near perfect video emulation including beam drop-outs, wait states
and various other subtle effects.
</li><li>Can visually indicate Z-80 video memory conflicts.
</li><li>Cycle perfect sub-instruction Z-80 and video timing.
</li><li>Built-in Z-80 debugger with source level debugging using
	<a href="https://ideasimagerystory.substack.com/p/zmac.html">zmac</a> <tt>.bds</tt> output.
</li><li>6809 debugger for Videotex
</li><li>6800 debugger for Electric Crayon
</li><li>Switchable turbo mode for high speed yet still accurate operation.
</li><li>Auto-turbo modes to go fast during slow operations (e.g., disk, cassette)
	and back to normal when typing.
</li><li>AVI and FLV (Flash) video capture.
</li><li>GIF and animated GIF screenshot capture.
</li><li>Audio capture to WAV file.
</li><li>Load programs directly from command line for fast development and testing.
</li><li>Can both &#34;paste&#34; and send files as input to keyboard (aka &#34;fast type&#34;).
</li><li>&#34;Cut&#34; to copy the screen in ASCII, Unicode or graphics format.
</li><li>Keyboard selectable between normal and game mode.
</li><li>Software keyboard to get around limits of PC keyboards.
</li><li>Brightness, contrast and display colour controls.
</li><li>Batch mode and command line input to automate tasks.
</li><li>Can open files and disk images within .zip archives.
</li><li>Optional emulator extensions provide memory protection and timing to the
	Z-80.  And emulator exit.
</li><li>Bus tracing, disassembling, profiling, memory dumping and other features
	for reverse engineering and debugging.
</li></ul><p>

The emulator is still a work in progress.  Much needs to be done to perfect
the Model 2 timing and screen effects.  Some obscure Model 3 and 4 video effects
are not accurate.  Videotex, Electric Crayon and MC-10 don&#39;t have authentic
rendering modes.

</p><h3>Overview</h3><p>

By default trs80gp comes up in Model 3 mode with a full 48K of memory
and all supported hardware attached.  Command line arguments are used
to select different models, hardware configurations and startup options.
Run &#34;trs80gp -?&#34; or use the &#34;Help → Command Line Options...&#34; menu to get the
latest information on them.

</p><p>
Programs can be run directly on the command line.  Doing so loads them
much faster than reading from virtual <a href="#cass">cassette</a> files
and without the hassle of writing them to a virtual <a href="#floppy">disk</a>
image.  Files in &#34;DOS&#34; format (.cmd) are run at the TRS-DOS prompt.
Other machine language files and BASIC programs are run at the ROM BASIC
<tt>READY</tt> prompt or at machine boot for Model 2 and 4P which don&#39;t have
a ROM BASIC.

</p><p>
It may not be obvious that this direct running of programs is not the way
the TRS-80 normally loads and executes programs.  Some programs may not work
especially disk BASIC programs.  However it is very useful for program
development and is otherwise extremely handy when it does work.

</p><p>
To give it a try, <a href="https://ideasimagerystory.substack.com/p/trs80gp-2.4.10.zip">download the emulator</a> and
also <a href="https://ideasimagerystory.substack.com/p/ball.zip">my bouncing ball demo program</a>.  You can run it
directly from the .zip archive:

</p><pre>      trs80gp ball.zip
</pre><p>
Which will prompt for which file to use.  Or specify the file inside the .zip
archive directly like so:
</p><pre>      trs80gp ball.zip?ball.cas
</pre><p>

Or you can extract the virtual cassette file yourself and run it:

</p><pre>      trs80gp ball.cas
</pre><p>

You can load machine language programs in </p><tt>.cmd</tt><p>, </p><tt>.hex</tt><p>
and </p><tt>.bds</tt><p> formats.  My <a href="https://ideasimagerystory.substack.com/p/zmac.html">Z-80 cross assembler zmac</a>
produces all three formats and with </p><tt>.bds</tt><p> you get full source-level
debugging (see Debug → Z-80 Debugger... and Debug → Source Code...).

</p><p>
It also can load BASIC programs in tokenized form or plain ASCII.

</p><p>
There&#39;s so much more!  But I&#39;ll leave it at that and spend the rest of
this page more in &#34;reference manual&#34; mode.

</p><ul>
<li><a href="#cli">Command Line Options</a>
</li><li><a href="#mdl">Model Selection</a>
</li><li><a href="#keyboard">The Keyboard</a>
</li><li><a href="#otherinp">Light Pen and Joystick</a>
</li><li><a href="#floppy">Floppy Disks</a>
</li><li><a href="#hd">Hard Drives</a>
</li><li><a href="#cass">Cassette Tapes</a>
</li><li><a href="#wafer">Aculab Floppy Tapes</a>
</li><li><a href="#sound">Sound</a>
</li><li><a href="#memory">Memory</a>
</li><li><a href="#print">Printer</a>
</li><li><a href="#serial">Serial (RS-232) Ports</a>
</li><li><a href="#record">Recording movies, pictures and audio.</a>
</li><li><a href="#turbo">Turbo Mode</a>
</li><li><a href="#display">Display</a>
</li><li><a href="#prog">Programming</a>
</li><li><a href="#frehd">FreHD Emulation</a>
</li><li><a href="#dt1">DT-1 Terminal</a>
</li><li><a href="#videotex">TRS-80 Videotex</a>
</li><li><a href="#ec">Electric Crayon</a>
</li><li><a href="#linux">Linux Notes</a>
</li><li><a href="#mac">MacOS Notes</a>
</li></ul>


<h3><a name="cli">Command Line Option Summary</a></h3>
<center>

<!-- Reminder: use "perl cmdline.pl x" to generate the options TABLE -->
<!-- Better: !*perl cmdline.pl x -->

<table>
<tbody><tr><th>Option</th><th>Effect</th></tr>
<tr><td></td></tr>
<tr><th colspan="2">Hardware Selection</th></tr>
<tr><td></td></tr>
<tr><td>-m1</td><td>Emulate Model I</td></tr>
<tr><td>-mj</td><td>Emulate Japanese Model I</td></tr>
<tr><td>-m2</td><td>Emulate Model II</td></tr>
<tr><td>-m3</td><td>Emulate Model III (default)</td></tr>
<tr><td>-m3n</td><td>Emulate Norcom Model III clone that fit in a Model I case</td></tr>
<tr><td>-m4</td><td>Emulate Model 4 (same as -m4a)</td></tr>
<tr><td>-m4a</td><td>Emulate Model 4 with 2 wait states per instruction</td></tr>
<tr><td>-m4b</td><td>Emulate Model 4 with 1 wait state per instruction</td></tr>
<tr><td>-m4c</td><td>Emulate Model 4 with no wait states per instruction</td></tr>
<tr><td>-m4ga</td><td>Emulate Model 4 Gate Array</td></tr>
<tr><td>-m4p</td><td>Emulate Model 4P</td></tr>
<tr><td>-m4d</td><td>Emulate Model 4D</td></tr>
<tr><td>-m4ss</td><td>Emulate Model 4 Student Station</td></tr>
<tr><td>-m12</td><td>Emulate Model 12</td></tr>
<tr><td>-m16</td><td>Emulate Model 16</td></tr>
<tr><td>-m6000</td><td>Emulate Model 6000</td></tr>
<tr><td>-mc10</td><td>Emulate Micro Color Computer Model MC-10</td></tr>
<tr><td>-mdt1</td><td>Emulate DT-1 Terminal</td></tr>
<tr><td>-mv</td><td>Emulate Videotex Terminal</td></tr>
<tr><td>-mec</td><td>Emulate Electric Crayon</td></tr>
<tr><td>-mx70</td><td>Act like MX-70 Printer</td></tr>
<tr><td></td></tr>
<tr><td>-l1</td><td>Run Level I BASIC ROM (Model I or III)</td></tr>
<tr><td>-l2</td><td>Run Level II BASIC ROM (default) (Model I or III)</td></tr>
<tr><td>-rN</td><td>Use ROM revision N (-r0, -r1, -r2, ...)</td></tr>
<tr><td>-nlc</td><td>No lowercase for Model I</td></tr>
<tr><td>-nld</td><td>Do not load Model I lowercase driver from cassette</td></tr>
<tr><td>-nsc</td><td>Do not try to set the clock for the boot OS</td></tr>
<tr><td>-alt</td><td>Use alternate character set</td></tr>
<tr><td>-charrom file</td><td>Use character generator ROM from file</td></tr>
<tr><td>-50</td><td>Set frame rate to 50 Hz</td></tr>
<tr><td>-gX</td><td>Hires graphics: -g0 none, -gt Tandy, -gg Grafyx, -gc Grafyx clone</td></tr>
<tr><td></td><td>-gtp for Tandy with fixed PROMs for Model 2,3,12,16,6000.</td></tr>
<tr><td></td><td>-gl for Model 1 Lowe Electronics 18</td></tr>
<tr><td>-ddTYPE</td><td>Select Model I floppy doubler: -ddx none, -ddp Percom,</td></tr>
<tr><td></td><td>-ddr Radio Shack, -ddrp RS+Percom, -ddd detect at boot)</td></tr>
<tr><td>-dx</td><td>Disable floppy disk controller (boot into ROM BASIC).</td></tr>
<tr><td>-dNss</td><td>Set drive N (0,1,2,3) single-sided only.</td></tr>
<tr><td>-dNds</td><td>Set drive N (0,1,2,3) double-sided only.</td></tr>
<tr><td>-dNas</td><td>Set drive N (0,1,2,3) to automatically act as single or double-sided.</td></tr>
<tr><td></td></tr>
<tr><td>-hx</td><td>Disable hard drive controller</td></tr>
<tr><td>-mem n</td><td>Emulate n KB of RAM</td></tr>
<tr><td>-mem type:n</td><td>Emulate n KB of hyper/super/mega expansion RAM.</td></tr>
<tr><td>-mem16 n</td><td>Emulate n KB of 68000 RAM</td></tr>
<tr><td>-memgap16 b n</td><td>Unmap an n KB gap in 68000 RAM starting at KB b</td></tr>
<tr><td>-mmu16 bits</td><td>Set number of extension bits in 68000 MMU (default 3)</td></tr>
<tr><td>-rom file</td><td>Use ROM image from file</td></tr>
<tr><td>-rom1 file</td><td>Map ROM image from file to $3000 (Model 1 only)</td></tr>
<tr><td>-aft</td><td>Aculab floppy tape (Model I only)</td></tr>
<tr><td>-80-grafix</td><td>80-Grafix hires character generator (Model I only)</td></tr>
<tr><td>-80-grafix+</td><td>80-Grafix+ hires character generator (Model I only)</td></tr>
<tr><td>-pcg-80</td><td>PCG-80 hires character generator (Model I only)</td></tr>
<tr><td>-80-grafix3</td><td>80-Grafix3 hires character generator (Model III only)</td></tr>
<tr><td>-omikron</td><td>Omikron Mapper for Model I (for Omikron CP/M)</td></tr>
<tr><td>-omikron-a</td><td>Omikron Mapper using version A ROM</td></tr>
<tr><td></td></tr>
<tr><th colspan="2">Program/Media Selection</th></tr>
<tr><td></td></tr>
<tr><td>-c file.cas</td><td>Insert cassette file.cas</td></tr>
<tr><td>-w file.tape</td><td>Insert floppy tape wafer file.tape into next free drive</td></tr>
<tr><td>-dN file.dsk</td><td>Insert disk into drive N (0,1,2,3)</td></tr>
<tr><td>-d file.dsk</td><td>Insert disk into next free drive</td></tr>
<tr><td>-d dmk</td><td>Insert unformatted disk into next free drive (.dmk format)</td></tr>
<tr><td></td><td>(add -ds for double-sided and #N for tracks)</td></tr>
<tr><td>-d imd</td><td>Insert unformatted disk into next free drive (.imd format)</td></tr>
<tr><td>-d :name</td><td>Insert internal diskette &#34;:name&#34; into next free drive</td></tr>
<tr><td>-td</td><td>Boot TRS-DOS (default)</td></tr>
<tr><td>-ld</td><td>Boot LDOS or LS-DOS</td></tr>
<tr><td>-d0 -</td><td>Don&#39;t insert TRS-DOS disk</td></tr>
<tr><td>-h file.hdv</td><td>Attach hard drive to next free slot</td></tr>
<tr><td>-hN file.hdv</td><td>Attach hard drive to slot N</td></tr>
<tr><td>-cs -csx</td><td>Enable/disable cassette auto save</td></tr>
<tr><td>file.dsk</td><td>Insert disk into next free drive (also .dmk, .imd)</td></tr>
<tr><td>file.tape</td><td>Insert floppy tape wafer into next free drive</td></tr>
<tr><td>:name</td><td>Insert internal diskette or wafer into next free drive</td></tr>
<tr><td>file</td><td>One or more files to load and execute after auto-boot</td></tr>
<tr><td></td><td>.cmd files are run from dos prompt</td></tr>
<tr><td></td><td>.cas, .bas and .bds files are loaded into ROM BASIC</td></tr>
<tr><td></td></tr>
<tr><th colspan="2">Serial Port (RS-232) Options</th></tr>
<tr><td></td></tr>
<tr><td>-r host:port</td><td>Connect serial port to TCP/IP host, port endpoint.</td></tr>
<tr><td>-r @port</td><td>Listen for TCP/IP connections on port for serial line.</td></tr>
<tr><td></td><td>(also -rB for second and -rA for first serial port)</td></tr>
<tr><td>-r :mouse</td><td>Emulate 2 button mouse on serial port</td></tr>
<tr><td>-r :mouse3</td><td>Emulate 3 button mouse on serial port</td></tr>
<tr><td>-r :dt1</td><td>Run DT-1 emulator attached to serial port.</td></tr>
<tr><td>-r :v</td><td>Run Videotex emulator attached to serial port.</td></tr>
<tr><td></td></tr>
<tr><th colspan="2">Printer Port Options</th></tr>
<tr><td></td></tr>
<tr><td>-p host:port</td><td>Connect printer port to TCP/IP host, port endpoint.</td></tr>
<tr><td>-p @port</td><td>Listen for TCP/IP connections on port for printer.</td></tr>
<tr><td>-p :mx70</td><td>Run MX-70 emulator attached to printer port.</td></tr>
<tr><td>-p :ec</td><td>Run Electric Crayon emulator attached to printer port.</td></tr>
<tr><td>-poff</td><td>Printer appears powered off</td></tr>
<tr><td></td></tr>
<tr><th colspan="2">View Options</th></tr>
<tr><td></td></tr>
<tr><td>-va</td><td>Authentic display (default)</td></tr>
<tr><td>-vs</td><td>Sharp display</td></tr>
<tr><td>-vi</td><td>Sharp display but only allows integer scaling</td></tr>
<tr><td>-vh</td><td>Cheap display</td></tr>
<tr><td>-vN</td><td>Scale cheap or sharp display up by N times</td></tr>
<tr><td>-vf</td><td>Start in full-screen mode (use Alt+Enter to go windowed)</td></tr>
<tr><td>-vc #RRGGBB</td><td>Set display colour to 24 bit colour value (&#34;-vc - &#34; for default)</td></tr>
<tr><td>-vd #RRGGBB</td><td>Set beam conflict colour (&#34;-vd -&#34; for default)</td></tr>
<tr><td>-vb #RRGGBB</td><td>Set border colour (&#34;-vb -&#34; for default)</td></tr>
<tr><td>-win WxH</td><td>Set window width and height</td></tr>
<tr><td>-win full</td><td>Start in full-screen mode (use Alt+Enter to go windowed)</td></tr>
<tr><td>-bd</td><td>Turn beam debugging on</td></tr>
<tr><td>-na</td><td>Turn off authentic display</td></tr>
<tr><td>-wtfs N</td><td>Update window title only every N frames</td></tr>
<tr><td></td></tr>
<tr><th colspan="2">Sound Options</th></tr>
<tr><td></td></tr>
<tr><td>-s hardware</td><td>Enable third party audio for model 1,3 or 4.</td></tr>
<tr><td></td><td>orch80	Orchestra 80</td></tr>
<tr><td></td><td>orch85	Orchestra 85</td></tr>
<tr><td></td><td>orch90	Orchestra 90</td></tr>
<tr><td></td><td>-	Disable third party audio</td></tr>
<tr><td>-mute</td><td>Start with audio muted.</td></tr>
<tr><td>-vol N</td><td>Set audio volume percentage (0 to 100; -sv is synonymous)</td></tr>
<tr><td>-su</td><td>Turn off audio filtering (faster; slightly less accurate)</td></tr>
<tr><td>-sx</td><td>Disable all audio output</td></tr>
<tr><td>-s1</td><td>Force mono sound</td></tr>
<tr><td>-s2</td><td>Force stereo sound</td></tr>
<tr><td>-sbg</td><td>Mute audio if trs80gp does not have the focus</td></tr>
<tr><td>-sfg</td><td>Audio and sound effects always play (unlike -sbg)</td></tr>
<tr><td>-sfmute</td><td>Mute sound effects</td></tr>
<tr><td>-sfv N</td><td>Set sound effect volume percentage</td></tr>
<tr><td>-sf fx file.wav</td><td>Use file.wav for named sound effect fx:</td></tr>
<tr><td></td><td>   spin-empty	empty floppy drive motor on</td></tr>
<tr><td></td><td>   spin-floppy	floppy spinning in drive</td></tr>
<tr><td></td><td>   step		floppy drive seeking</td></tr>
<tr><td></td><td>   relay-on	cassette motor relay activating</td></tr>
<tr><td></td><td>   relay-off	cassette motor relay turning off</td></tr>
<tr><td></td></tr>
<tr><th colspan="2">Automation Options</th></tr>
<tr><td></td></tr>
<tr><td>-turbo</td><td>Run at top speed</td></tr>
<tr><td>-haste</td><td>Run fast by drawing once per second (graphics/timing inaccurate)</td></tr>
<tr><td>-batch</td><td>Have &#34;Record&#34; menu save files without prompting.</td></tr>
<tr><td>-fa hex</td><td>Update FPS when Z-80 hits address</td></tr>
<tr><td>-ta hex</td><td>Turbo for 5 frames at Z-80 address</td></tr>
<tr><td>-rand</td><td>Initialize RAM and the R register with random data.</td></tr>
<tr><td>-ct -ctx</td><td>Enable/disable cassette auto turbo</td></tr>
<tr><td>-dt -dtx</td><td>Enable/disable floppy disk auto turbo</td></tr>
<tr><td>-ht -htx</td><td>Enable/disable hard drive auto turbo</td></tr>
<tr><td>-wt -wtx</td><td>Enable/disable wafer drive auto turbo</td></tr>
<tr><td></td></tr>
<tr><th colspan="2">Keyboard, Joystick and Light Pen Input</th></tr>
<tr><td></td></tr>
<tr><td>-jx</td><td>Disable joystick input</td></tr>
<tr><td>-kl log|phys</td><td>Set keyboard layout to logical or physical</td></tr>
<tr><td>-kg -kgx</td><td>Enable/disable key ghosting on keyboard input</td></tr>
<tr><td>-kt -ktx</td><td>Enable/disable keyboard auto de-turbo</td></tr>
<tr><td>-kc</td><td>Clustered key layout in software keyboard (Model 4 only)</td></tr>
<tr><td>-i str</td><td>Send str as keyboard input (as if it were pasted)</td></tr>
<tr><td>-if file</td><td>Send file contents as keyboard input</td></tr>
<tr><td>-iw str</td><td>Wait until str appears on screen</td></tr>
<tr><td>-ik row mask</td><td>Set keyboard matrix row to mask</td></tr>
<tr><td>-ictl reset</td><td>Reset the TRS-80</td></tr>
<tr><td>-id N</td><td>Delay N frames</td></tr>
<tr><td>-itime N</td><td>Give up on input after N frames of waiting</td></tr>
<tr><td>-ix</td><td>Exit emulator when command line input has been sent</td></tr>
<tr><td>-is</td><td>Save a screenshot</td></tr>
<tr><td>-ics</td><td>Save a clean screenshot (no beam interference dropouts)</td></tr>
<tr><td>-it</td><td>Write text VRAM to file</td></tr>
<tr><td>-ig</td><td>Write hires graphics VRAM to file</td></tr>
<tr><td>-ic</td><td>Write programmable character generator VRAM to file</td></tr>
<tr><td>-im dump N file</td><td>Save ASCII image of disk N to file.</td></tr>
<tr><td>-im wp N on|off</td><td>Enable or disable write protect on disk N</td></tr>
<tr><td>-im trackdump N file</td></tr>
<tr><td></td><td>Save ASCII image of disk track data of disk N to file</td></tr>
<tr><td>-im insert N file</td></tr>
<tr><td></td><td>Insert disk image file into drive N</td></tr>
<tr><td>-im eject N 1</td><td>Eject disk image in drive N with no prompting</td></tr>
<tr><td>-ip host:port</td><td>Read keyboard input from TCP/IP host, port endpoint.</td></tr>
<tr><td>-ip @port</td><td>Listen for TCP/IP connections on port for keyboard.</td></tr>
<tr><td>-ir audio</td><td>Toggle audio recording (turn on if off, off if on)</td></tr>
<tr><td>-ir flash</td><td>Toggle flash video recording</td></tr>
<tr><td>-ir video</td><td>Toggle AVI video recording</td></tr>
<tr><td>-ir gif</td><td>Toggle animated GIF recording</td></tr>
<tr><td>-ir mhz</td><td>Toggle MHz recording</td></tr>
<tr><td>-lp</td><td>Enable light pen emulation (1,3,4)</td></tr>
<tr><td>-esc-exits</td><td>Pressing the escape key exits trs80gp</td></tr>
<tr><td></td></tr>
<tr><th colspan="2">Programmer Help</th></tr>
<tr><td></td></tr>
<tr><td>-b hex</td><td>Set debugger breakpoint (can use &#34;-b hex&#34; up to 4 times).</td></tr>
<tr><td>-b label</td><td>Set breakpoint at label (if .bds file loaded)</td></tr>
<tr><td>-b start:end</td><td>Set breakpoints from start to end (0:ffff can be handy)</td></tr>
<tr><td>-bm hex/label</td><td>Set Z-80/6800/6809 memory access breakpoint</td></tr>
<tr><td></td><td>also -bmr or -bmw to trap only reads or writes</td></tr>
<tr><td>-bio hex/label</td><td>Set Z-80 I/O access breakpoint</td></tr>
<tr><td></td><td>also -bior or -biow to trap only reads or writes</td></tr>
<tr><td>-b16 hex</td><td>Set 68000 debugger breakpoint</td></tr>
<tr><td>-b16m hex/label</td><td>Set 68000 memory access breakpoint</td></tr>
<tr><td></td><td>also -b16mr or -b16mw to trap only reads or writes</td></tr>
<tr><td>-l file</td><td>Load file into memory but don&#39;t run it</td></tr>
<tr><td>-ls file.bds</td><td>Load symbols from file but don&#39;t load its data.</td></tr>
<tr><td>-ee</td><td>Enable emulator extensions (debugging oriented)</td></tr>
<tr><td>-trace</td><td>Start with tracing on (Record → Trace)</td></tr>
<tr><td></td></tr>
<tr><th colspan="2">FreHD Emulation</th></tr>
<tr><td>-frehd</td><td>Enable FreHD emulation</td></tr>
<tr><td>-frehd_dir dir</td><td>Set directory used for FreHD external file import/export</td></tr>
<tr><td></td><td>Also enables FreHD emulation</td></tr>
<tr><td>-frehd_load fl</td><td>Use boot block in file instead of the built-in one</td></tr>
<tr><td>-frehd_patch</td><td>Apply FreHD auto-start patches to the ROM</td></tr>
<tr><td>-frehd_menu</td><td>Use built-in FreHD menu program rather than frehd.rom</td></tr>
<tr><td></td><td>in the -frehd_dir</td></tr>
<tr><td></td></tr>
<tr><th colspan="2">Esoterica</th></tr>
<tr><td></td></tr>
<tr><td>-sync</td><td>Try to maintain frame rate exactly (uses excessive CPU)</td></tr>
<tr><td>-trsnic</td><td>Preliminary trsnic emulation (model 1,3,4 only)</td></tr>
<tr><td>-time render|frame|emulation</td><td>Show timing in title bar</td></tr>
<tr><td>-showkey</td><td>Show Windows key code in title bar</td></tr>
<tr><td>-showframe</td><td>Show the frame number in title bar</td></tr>
<tr><td>-writerom</td><td>Make ROM writeable (Model 1 and 3 only)</td></tr>
<tr><td>-m1_vblank</td><td>VBLANK readable as bit 0 of port $FF (Model I only)</td></tr>
<tr><td>-x1hack</td><td>Temporary fix for Xenix 1 boot error (and TRSDOS-16)</td></tr>
<tr><td></td><td>(disables 68000 to Z-80 interrupt request through CTC1)</td></tr>
<tr><td>-mmu9f</td><td>Model I 16 RAM bank 0 when bit 0 of port $9F set.</td></tr>
<tr><td>-t1hack</td><td>Modification to when FDC switches to Type I status.</td></tr>
<tr><td></td><td>Only useful to make TRSDOS-II RESTORE work.</td></tr>
</tbody></table>

</center>

<h3><a name="mdl">Model Selection</a></h3><a name="mdl">

The various <tt>-m*</tt> options and the File → Change Model menu from
quite a wide variety of different computers, terminals and printers to emulate.
When trs80gp is run from the command line the model will default to <tt>-m3</tt>.
When run from a GUI the model will be whatever was selected by the menu.
In either case various preferences like display mode defaults are recalled
based on the model.

<p>
Many of the command line arguments may not be applicable vary depending on
the model.  For example, printers and terminals do not have cassette or disk
storage and ignore those options.  One meaningful difference is the
<tt>-r0, -r1, -r2, etc.</tt> ROM revision.  The lower the revision number
the earlier the original release of that ROM.  Here is a table of revisions
for each model which have more that one:

</p><center>
<table>
<tbody><tr><th>Model</th><th>Revision</th><th>Default?</th><th>Version</th></tr>
<tr><td rowspan="4">I</td>
    <td>-r0</td><td></td><td>1.0 - earliest version with a few bugs</td></tr>
<tr><td>-r1</td><td></td><td>1.1 - most bugs fixed</td></tr>
<tr><td>-r2</td><td></td><td>1.2 - nearly identical to 1.1</td></tr>
<tr><td>-r3</td><td>yes</td><td>1.3 - shortened <tt>MEM SIZE?</tt> prompt; some new features</td></tr>
<tr><td rowspan="2">II,12</td>
    <td>-r0</td><td></td><td>Early boot rom; no hard-drive boot.</td></tr>
<tr><td>-r1</td><td>yes</td><td>Checksum $1BBE with hard-drive boot.</td></tr>
<tr><td rowspan="2">III</td>
    <td>-r0</td><td></td><td>No shift-down control keys; prints screen if S+P pressed at same time</td></tr>
<tr><td>-r1</td><td>yes</td><td>Most common version</td></tr>
<tr><td rowspan="2">4</td>
    <td>-r0</td><td>yes</td><td>Usual Model 4 ROM</td></tr>
<tr><td>-r1</td><td></td><td>Later &#34;international&#34; ROM; default for <tt>-m4ga</tt></td></tr>
</tbody></table>
</center>

<p>
Both the Model I and Model III have Level I and Level II BASIC ROMs.  The
rom revsisions only select between different Level II ROMs.  There is only
one known version of the Level I ROMs for each.

</p></a><h3><a name="mdl"></a><a name="keyboard">Keyboard</a></h3><p>

The Keyboard menu lets you select between Logical Layout (the default)
and Physical Layout.  There is also Experimental Logical Layout which is
(hopefully) temporary.  It is identical to Logical Layout except for
a slight difference in handling shift key state to work better with
a custom CP/M BIOS.

</p><p>
Enable ghosting for a truely authentic experience.  Due to the way the
keyboard matrix works on the Model 1, 3 and 4 it is possible for a 4th
key to appear pressed when 3 others are down.  For example, if you press
and hold <tt>F</tt>, <tt>G</tt> and <tt>O</tt> in that order you will see
<tt>FGN</tt> on screen as those keys ghost with <tt>N</tt>.

</p><p>
Logical Layout means that what you see on the key is what gets sent to the TRS-80.
This is as you would expect but there are two things to keep in mind.
None of the TRS-80 Models sport the full variety of keys on a modern PC.
The Model 2 comes closest where the Model 1,3,4 machines lack even square
brackets, curly braces and many others.  They did, however, have some keys
which have no analogue on the PC. Both had a <tt>BREAK</tt> key for interrupting
programs.  Models 1,3,4 had <tt>CLEAR</tt> to clear the screen.  The Model 2
had <tt>HOLD</tt> to pause display.  The Model 4 and 4P have a CAPS key for
switching between upper and lower-case input.

</p><center>
<table>
<tbody><tr><th>To Get</th><th></th><th>Model 1,3,4 Press</th><th></th><th>On Model 2 Press</th></tr>
<tr><td><tt>BREAK</tt></td><td></td><td><tt>Esc, Pause/Break, End</tt></td><td></td><td><tt>ctl-C, Pause/Break, End</tt></td></tr>
<tr><td><tt>CLEAR</tt></td><td></td><td><tt>Home, \</tt></td><td></td><td>n/a</td></tr>
<tr><td><tt>CAPS</tt></td><td></td><td><tt>CapsLock, PageUp</tt></td><td></td><td>n/a</td></tr>
<tr><td><tt>HOLD</tt></td><td></td><td>n/a</td><td></td><td><tt>ctl-shift-@, Scroll Lock</tt></td></tr>
</tbody></table>
</center><p>

With Physical Layout the emulator is set up so TRS-80 keys are activated
by PC keys in roughly the same relative position on the keyboard.  Most of
the symbols on your keyboard will correspond to the same key on the TRS-80.
The letters, numbers, arrow keys and Enter will do what you expect and
</p><tt>!#$%;&lt;&gt;,.</tt><p> are in the same spot, otherwise:

</p><center>
<table>
<tbody><tr><th>To Get</th><th></th><th>Press</th></tr>
<tr><td><tt>`</tt></td><td>   </td><td><tt>shift [</tt></td></tr>
<tr><td><tt>@</tt></td><td> </td><td><tt>[</tt></td></tr>
<tr><td><tt>&amp;</tt></td><td> </td><td><tt>shift 6</tt></td></tr>
<tr><td><tt>*</tt></td><td> </td><td><tt>shift -</tt></td></tr>
<tr><td><tt>(</tt></td><td> </td><td><tt>shift 8</tt></td></tr>
<tr><td><tt>)</tt></td><td> </td><td><tt>shift 9</tt></td></tr>
<tr><td><tt>-</tt></td><td> </td><td><tt>=</tt></td></tr>
<tr><td><tt>+</tt></td><td> </td><td><tt>shift ;</tt></td></tr>
<tr><td><tt>=</tt></td><td> </td><td><tt>shift =</tt></td></tr>
<tr><td><tt>:</tt></td><td> </td><td><tt>-</tt></td></tr>
<tr><td><tt>&#39;</tt></td><td> </td><td><tt>shift 7</tt></td></tr>
<tr><td><tt>&#34;</tt></td><td> </td><td><tt>shift 2</tt></td></tr>
<tr><td><tt>Left</tt></td><td> </td><td><tt>], Left</tt></td></tr>
<tr><td><tt>Right</tt></td><td> </td><td><tt>\, Right</tt></td></tr>
<tr><td><tt>Up</tt></td><td> </td><td><tt>`, Up</tt></td></tr>
<tr><td><tt>Down</tt></td><td> </td><td><tt>Tab, Down</tt></td></tr>
<tr><td><tt>Break</tt></td><td> </td><td><tt>Backspace, Esc, Pause/Break, End</tt></td></tr>
<tr><td><tt>Clear</tt></td><td> </td><td><tt>&#39;, Home</tt></td></tr>
<tr><td><tt>Caps</tt></td><td> </td><td><tt>CapsLock, PageUp</tt></td></tr>
</tbody></table>
</center>

<p>
Physical Layout is generally only needed for games where a key activated
at a different position can make the game unplayable.
Note that the Model 2 does not support Physical Layout.


</p><h4>Special Keys</h4>

<tt>F9</tt><p> will pause and resume the emulation.

You can hold </p><tt>F12</tt><p> to make the TRS-80 run faster.  Pressing
</p><tt>shift-F12</tt><p> will keep it in fast (turbo) mode without having to
hold </p><tt>F12</tt><p>.  Tapping </p><tt>F12</tt><p> will put the emulator back to
normal speed. The </p><tt>-turbo</tt><p> command line option has the same effect.

</p><p>
In turbo mode keyboard input can get very difficult with characters
repeated frequently.  trs80gp addresses this by dropping out of turbo
mode whenever a key is pressed.  This automated return to normal speed
can be turned on or off by Keyboard → Auto De-Turbo menu.

</p><p>
<tt>Ctrl-Alt-C</tt> and <tt>Ctrl-Insert</tt> and
<tt>Ctrl-Alt-V</tt> and <tt>Shift-Insert</tt> are shortcuts for &#34;Copy&#34; and
&#34;Paste&#34; respectively.

</p><p>
Use <tt>F11</tt> to save a screenshot and <tt>Shift-F11</tt> to save a
cleanshot which is a screenshot without any beam drop-outs that appear
as they do on the real Model I.

</p><p>
<tt>Alt-F5</tt> activates the machine&#39;s reset button.  The Model I&#39;s reset
button is not a hard reset and will not reboot the machine in the case of
an especially bad crash.  In that case use <tt>Ctrl-Alt-F5</tt> to do a
warm restart to reboot the emulated Model I or File → Warm Restart.
<tt>Shift-Ctrl-Alt-F5</tt> or File → Cold Restart is the same as a
warm restart but it also re-initializes all RAM.

</p><p>
<tt>Alt-Enter</tt> will toggle between windowed and full screen mode.

</p><p>
<tt>Alt-F4</tt> is the standard Windows shortcut to exit the program which
may not be familiar to Wine users.
For that matter <tt>Alt</tt> by itself will move focus to the menu where you
can use the keyboard to navigate and <tt>Alt-F</tt>, <tt>Alt-E</tt> will
active the <tt>File</tt>, <tt>Edit</tt> and <tt>View</tt> menus respectively
and so on for other top-level menus.

</p><h4>Software Keyboard</h4><p>

In unusual circumstances you may need to use the Keyboard → Software Keyboard...
in order to press several keys at once.  Most PC keyboards can only show
3 or 4 keys held down at once but some TRS-80 games have easter eggs that
require holding down as many as 8 keys.
The software keyboard makes this easy as each keyboard button stays pressed when
clicked and only releases when clicked again.  Or if the corresponding
PC key is released.

</p><p>
If nothing else it is laid out the same as the original TRS-80 keyboard so
you can see the idea behind Physical Layout mode.  And the buttons go up and
down as you type.  Put the software keyboard window underneath the main one and
you&#39;ll feel like you&#39;re on a real TRS-80.  Minutes of fun.

</p><p>
The software keyboard also has an orange reset button.
There&#39;s also a &#34;RAM Badge&#34; showing how much memory is installed.
Incidentally, the Model 1 and Model 4P didn&#39;t have RAM badges and the
reset key was in a different location.

</p><h4><a name="autoin">Automatic Input</a></h4><p>

Programs that use the standard ROM or DOS routines for keyboard can have
input pushed to them through the Edit → Paste menu entry,
&#34;</p><tt>-i</tt><p>&#34; command line flags or Edit → Paste Macro N menu entries.
This doesn&#39;t work for most games and
programs that use their own keyboard input routines.  Still, it can be a
convenient way to &#34;fast-type&#34; a BASIC program or run a series of TRS-DOS
commands.  Also note on the Model 2 that trs80gp sends the input to the
keyboard hardware and TRS-DOS clears the buffer before reading each command
leading to most input being lost (hence the </p><tt>-iw</tt><p> option).

</p><p>
For example, the following command will go into BASIC, set the top of
memory to 60000 and then input and run a short BASIC program.

</p><pre>    trs80gp -i &#34;BASIC\r\r60000\r10 ?7*5\rRUN\r&#34;
</pre><p>

On the Model 2 we must wait for the &#34;Date&#34; prompt to appear thus making the
exercise a bit more complicated:

</p><pre>    trs80gp -m2 -iw Date -i &#34;02/02/1993\r\rBASIC\r10 ?7*5\rRUN\r&#34;
</pre><p>

The contents of entire files can be sent using </p><tt>-if filename</tt><p>.  Or
input can be sent interactively with the Edit → Paste or the
</p><tt>Ctrl-Alt-V</tt><p> or </p><tt>Shift-Insert</tt><p> keyboard shortcuts.

</p><p>
Since the characters are fed to keyboard input routines you can enter
graphics characters and other data that normally can&#39;t be typed in with
a real keyboard.  Consider this a handy way to put graphics characters
inside string literals in BASIC.  Normally that requires magic incantations
of <tt>VARPTR</tt> and has been the subject of countless 80 Microcomputer
magazine articles.

</p><p>
If the TRS-80 is not calling the standard keyboard input routine then trs80gp
will time-out and give up trying to send input after about one minute.
Specifically, 3600 frames which is one minute at 60 Hz and one minute and
12 seconds at 50 Hz.  Though the emulator automatically switches to turbo
mode during automated input so the real time will be less.  The timeout value
can be changed with the <tt>-itime N</tt> option.

</p><p>
A few of the options such as <tt>-id N</tt> (wait N frames) and any which
generate screenshots (<tt>-is</tt>, <tt>-ic</tt>), exit the emulator (<tt>-ix</tt>)
or write to files (<tt>-it</tt>, <tt>-im</tt>) do not wait for keyboard
polling and can be used to grab screenshots of games.  Though they are of
most use in writing the automated tests used by trs80gp&#39;s authors.  The
<tt>-showframe</tt> option is useful for screenshots as it shows the current
emulator frame in the title bar.  Thus you needn&#39;t guess how many frames to
wait before a program is ready for its screenshot.

</p><p>
A facility for entering input to games and other uncooperative programs is
being considered.

</p><h4><a name="pastemac">Paste Macros</a></h4><p>

The Edit → Define Macro... menu allows you to create up to 10
paste shortcuts.  The strings entered can be pasted either through the
Edit → Paste Macro 0 though 9 menu entires or by pressing Alt-0
though Alt-9.  Each macro is automatically saved and there is a different
set of macros for each TRS-80 model.

</p><p>
The mechanism is exactly the same as other automatic input so you can use
<tt>\</tt> escapes to enter control and graphics characters.
This is particularly useful for Xenix&#39;s virtual console feature where
entering <tt>\xFC</tt> followed by <tt>0</tt> though 9 will switch
to that console.  For example, to have Alt-4 switch to console 4 set up
the macro to send <tt>\xFC\x34</tt> or <tt>\xFC4</tt> (\x hex
escapes consume at most 2 digits).

</p><h3><a name="otherinp">Light Pen and Joystick</a></h3><p>

The Windows version supports joystick input on the Model 1, 3 and 4 and
light pen input on the Model 1.  The light pen must be enabled with the
</p><tt>-lp</tt><p> option; the joystick can be disabled with the </p><tt>-jx</tt><p> option.

</p><p>
An Alpha products joystick is emulated using any of the standard joysticks
attached to your computer.  The actual joystick was a bus hog that would
respond to reads on practically any I/O port.  Most programs use port $00, $13
or $F7 so only those are mapped by trs80gp.

</p><p>
With the light pen enabled pressing the mouse button down will simulate the
light pen making contact with that position on screen.  Releasing the mouse
button acts as if the pen were removed from the screen.  Very few programs
were found that have light pen support so please report any problems you
see.  We&#39;d be very much interested to run some test programs if you have
an original light pen.

</p><h3><a name="floppy">Working With Floppies</a></h3><p>

The Diskette menu shows all 4 floppy drives and what disk image is
inserted in them or </p><tt>&lt;empty&gt;</tt><p> if there is none.  Any
disk file name enclosed in </p><tt>&lt;&lt; .. &gt;&gt;</tt><p> is a built-in
disk image.  If the name has an asterisk (</p><tt>*</tt><p>) before it the
disk has been modified and must be saved.  For non-internal disk images
the changes are saved automatically, but changes to internal disk images
or disk images loaded from .zip archives must be explicitly saved to another
file.  trs80gp will remind you to do this if you try to eject a disk with
changes or exit the emulator with unsaved changes.

</p><p>
All built-in disk images have a <a href="#intflop">short name</a>
that starts with a colon. This is displayed in parenthesis on each entry
in the &#34;Insert disk...&#34; menu as a reminder that the short name can be used
on the command line to insert the floppy when starting trs80gp.

</p><p>
Each drive has a sub-menu that lets you eject diskettes, replace diskettes,
insert diskettes, save them to a new file or toggle their write protection.
This isn&#39;t the read-only flag of the PC file system but an internal one
corresponding to the physical write protect notch on the real floppy disks.
Besides saving a copy of a disk image file, Diskette → ... → Export...
can write out the disk image in ASCII format or as a track dump in ASCII
format for debugging purposes.

</p><p>
The internal diskettes <tt>unformatted dmk</tt> and <tt>unformatted imd</tt>
are single-sided unformatted diskettes in <tt>DMK</tt> and <tt>IMD</tt> format.
Equivalent to the <tt>-d dmk</tt> and <tt>-d imd</tt> command line options.
Your currently running DOS will need to format them before they can be used.
<tt>unformatted dmk DS</tt> and <tt>unformatted imd DS</tt> are double-sided
disk images also accessible from the command line as <tt>-d dmk-DS</tt>
and <tt>-d imd-DS</tt>.

</p><p>
The <tt>-d0, -d1, -d2, -d3, -td and -ld</tt> command line options allow you
to select disks to insert into the floppy drives when the emulator starts.
The default is to put a TRS-DOS floppy in drive <tt>:0</tt> so that the
TRS-80 will boot into TRS-DOS (which is the same as the <tt>-td</tt> option).
You can just use <tt>-d file.dsk</tt> to have a floppy disk inserted in the next
available drive or just the name of the floppy disk image if it ends in one
of the known suffixes (<tt>.dmk</tt>, <tt>.dsk</tt>, <tt>.imd</tt>,
<tt>.hfe</tt>, <tt>.jv1</tt> or <tt>.jv3</tt>).

</p><p>
Whenever a floppy is accessed trsg80p will go into turbo mode automatically.
This can be enabled or disabled with the Diskette → Auto Turbo menu.  Running
in turbo mode has no harmful effect on diskette usage as the necessary relative
timing remains the same.  Generally you&#39;d only want to turn the feature off
to experience the original pace of the machine or when faster disk operations
make it hard to read text.  Or to keep the TRS-80&#39;s real time clock in sync
with the current time.

</p><p>
Unlike actual floppy drives, the emulated drives operate in a special <em>any-sided</em> mode.
If a double-sided disk image is inserted, the drive will become double-sided.  If the drive has a single-sided
disk image and the operating system attempts to format a track on side 2, the drive
and disk image will automatically upgrade to double-sided.

</p><p>
To control this behaviour, the The <tt>-dNss</tt>, <tt>-dNds</tt> and <tt>-dNas</tt> command line options
allow you to force drive N in the system to behave as single-sided, double-sided or any-sided.
Alternatively, you can enable or disable any-sided mode via the Diskette → Drive → Emulate only ...
menu option. 

</p><p>
Because of problems with CP/M auto-detecting drive sides during FORMAT,
the any-sided drive behaviour is <em>not</em> the default on the Model II family.
The index hole position is different between single and doubled sided 8&#34; diskettes.
Real 8&#34; double-sided disk drives use the position change to actively detect doubled-sided or single-sided diskettes.
As a result (unless <tt>-dNas</tt> is used), the emulator will signal <tt>NOT READY</tt>
from the 8&#34; drive in the follow cases:

</p><ul>
<li>Double-sided image used in a single-sided drive
</li><li>Access the second side of single-sided image in a double-sided drive 
</li></ul>

<p>Note that in this strict mode if you wish to format a double-sided disk image you must
insert a double-sided blank as the single-sided blank will not be promoted to double-sided.

</p><p>Like the original machines, the Model II (<tt>-m2</tt>) will have single-sided 8&#34; drives
and the Models 12, 16, and 6000 (<tt>-m12 -m16 -m6000</tt>) will have double-sided 8&#34; drives.

</p><h4><a name="impexp">File Import and Export</a></h4>

<p>
The built-in <a name="intflop">utilities floppy</a> provides the <tt>IMPORT2</tt>
and <tt>EXPORT2</tt> to bring files into and out of the emulator.  They use
the FreHD emulation so trs80gp must be run with the <tt>-frehd</tt> option for
them to work or activated by the Hard Drive → FreHD menu.  Otherwise they
will say <tt>No FreHD attached</tt> and exit.  Most Model II operating systems
will require the hard drive controller to be disabled (<tt>-hx</tt>) for
the utilities to function.

</p><p>
<tt>IMPORT2</tt> will read a file from the host computer and write it to a
TRS-80 disk file.

</p><p>Usage: <tt>IMPORT2 [-lnep] hostfile [trs80file]</tt>

</p><p>
If the trs80file parameter is omitted the last component of the
<tt>hostfile</tt> is used with &#39;.&#39; changed to &#39;/&#39;.  If this is not a legal
TRS-80 file name you will get an error message.

</p><p>Options:
</p><dl>

<dt>-l</dt>
<dd>Convert the host file name to lower case.
This is needed for NEWDOS/80 which insists on uppercasing the command line.</dd>

<dt>-n</dt>
<dd>Change all newlines (&#39;\n&#39;) in the host file to carriage return (&#39;\r&#39;)</dd>

<dt>-e</dt>
<dd><b>Most Models:</b> Use the NEWDOS/80 end of file convention.  This is required for DOSes such
as DOSPLUS which use the NEWDOS/80 convention but are not detected by IMPORT2.
</dd>

<dt>-p</dt>
<dd>Model II only - write a program rather than data file.  This must be
speficied when importing executable (i.e., <tt>/CMD</tt> files).</dd><dd>

</dd></dl>

<p>
<tt>EXPORT2</tt>  will read a file from the TRS-80 and write it to the host computer.

</p><p>Usage: <tt>EXPORT2 [-lne] trs80file [hostfile]</tt>

</p><p>
If the <tt>hostfile</tt> parameter is omitted the <tt>trs80file</tt> is used
with &#39;/&#39; changed to &#39;.&#39;.

</p><p>Options:
</p><dl>

<dt>-l</dt>
<dd>Convert the host file name to lower case.
This is needed for NEWDOS/80 which insists on uppercasing the command line.</dd>

<dt>-n</dt>
<dd>Change all carriage returns (&#39;\r&#39;) in the TRS-80 file to newlines (&#39;\n&#39;)</dd>

<dt>-e</dt>
<dd>Use the NEWDOS/80 end of file convention.  This is required for DOSes such
as DOSPLUS which use the NEWDOS/80 convention but are not detected by EXPORT2.
</dd>

</dl>

<p>
<tt>IMPORT2</tt> and <tt>EXPORT2</tt> are my modified versions of Frederic
Vecoven&#39;s modified version of
<a href="https://github.com/TimothyPMann/xtrs">Timothy Mann&#39;s originals</a>.
<tt>VHDUTL</tt> is a modified version of Frederic Vecoven&#39;s original. 
My main change was to add support for the Model II operating systems.
Note that although there is a utility floppy image for each DOS and
model the executables are all identical.  The copies are only required because
of their incompatible file systems and floppies.  The executables themselves
detect the DOS they are run under and use the correct system calls.

</p><p>
Except for the Model II they should work on a real machine with
a FreHD hard drive emulator.  I have not tested this.

</p><p>
For bulk import and export I recommend either creating a <tt>/JCL</tt>
(batch/script file) containing all the commands or using the <tt>-i</tt>
options to have trs80gp do all the typing.
There are also command line and GUI utilities to read and write files
for many TRS-80 floppy image formats.
I recommend the graphical
<a href="http://www.trs-80emulators.com/trstools/">TRSTools</a> utility
or the command line
<a href="http://www.trs-80emulators.com/trsread-trswrite/">trsread &amp; trswrite</a>
utilities.  Neither have any support for the Model II which was the primary
motivation to add <tt>IMPORT2</tt> and <tt>EXPORT2</tt> to trs80gp.

</p><h4><a name="intflop">Internal Floppy Images</a></h4><p>

A handy table listing all the available internal floppy image files and
how they may be accessed from the command line.  trs80gp only shows
floppies made for the current model in the menu which is generally helpful
but you can&#39;t use them to boot a Model 4 with a Model III TRSDOS like
</p><tt>trs80gp -m4 :td3</tt><p> will do from the command line.  Unless you
export the internal </p><tt>:td3</tt><p> image to a file in Model III mode and
then insert that file in Model 4 mode.

</p><center>
<table>
<tbody><tr>
<th>Model</th>
<th>DOS</th>
<th>Menu Entry</th>
<th>Type</th>
<th>Command Line</th>
</tr>

<tr>
<td rowspan="9">I</td>
<td rowspan="4">TRSDOS 2.3</td>
<td>&lt;&lt; TRSDOS23.dmk &gt;&gt;</td>
<td>Boot</td>
<td>:td1 or -td</td>
</tr>

<tr>
<td>&lt;&lt; m1-trsdos-blank.dmk &gt;&gt;</td>
<td>Blank</td>
<td>:tb1</td>
</tr>

<tr>
<td>&lt;&lt; m1-trsdos-util.dmk &gt;&gt;</td>
<td>Utilities</td>
<td>:tu1</td>
</tr>

<tr>
<td>&lt;&lt; TRSDOS23j.dmk &gt;&gt;</td>
<td>Boot</td>
<td>:tj1</td>
</tr>

<tr>
<td rowspan="5">LDOS 5.3.1</td>
<td>&lt;&lt; ld351-1.dsk &gt;&gt;</td>
<td>Boot</td>
<td>:ld1 or -ld</td>
</tr>

<tr>
<td>&lt;&lt; ld351-2.dsk &gt;&gt;</td>
<td>Extras</td>
<td>:ld1e</td>
</tr>

<tr>
<td>&lt;&lt; m1-ldos-blank.dmk &gt;&gt;</td>
<td>Blank</td>
<td>:lb1</td>
</tr>

<tr>
<td>&lt;&lt; m1-ldos-util.dmk &gt;&gt;</td>
<td>Utilities</td>
<td>:lu1</td>
</tr>

<tr>
<td>&lt;&lt; ld531-1j.dmk &gt;&gt;</td>
<td>Boot</td>
<td>:lj1</td>
</tr>

<tr>
<td rowspan="8">II</td>
<td rowspan="3">TRSDOS 2.0a</td>
<td>&lt;&lt; TSDOS20A.IMD &gt;&gt;</td>
<td>Boot</td>
<td>:td2 or -td</td>
</tr>

<tr>
<td>&lt;&lt; m2-trsdos-blank.dmk &gt;&gt;</td>
<td>Blank</td>
<td>:tb2</td>
</tr>

<tr>
<td>&lt;&lt; m2-trsdos-util.dmk &gt;&gt;</td>
<td>Utilities</td>
<td>:tu2</td>
</tr>

<tr>
<td rowspan="3">LS-DOS 6.3.1a</td>
<td>&lt;&lt; l2-631a.dmk &gt;&gt;</td>
<td>Boot</td>
<td>:ld2 or -ld</td>
</tr>

<tr>
<td>&lt;&lt; m2-lsdos-blank.dmk &gt;&gt;</td>
<td>Blank</td>
<td>:lb2</td>
</tr>

<tr>
<td>&lt;&lt; m2-lsdos-util.dmk &gt;&gt;</td>
<td>Utilities</td>
<td>:lu2</td>
</tr>

<tr>
<td rowspan="2">TRSDOS II 4.2</td>
<td>&lt;&lt; m2-trsdos4-blank.dmk &gt;&gt;</td>
<td>Blank</td>
<td>:t4b2</td>
</tr>

<tr>
<td>&lt;&lt; m2-trsdos4-util.dmk &gt;&gt;</td>
<td>Utilities</td>
<td>:t4u2</td>
</tr>

<tr>
<td rowspan="6">III</td>
<td rowspan="3">TRSDOS 1.3</td>
<td>&lt;&lt; TRSDOS13.DSK &gt;&gt;</td>
<td>Boot</td>
<td>:td3 or -td</td>
</tr>

<tr>
<td>&lt;&lt; m3-trsdos-blank.dmk &gt;&gt;</td>
<td>Blank</td>
<td>:tb3</td>
</tr>

<tr>
<td>&lt;&lt; m3-trsdos-util.dmk &gt;&gt;</td>
<td>Utilities</td>
<td>:tu3</td>
</tr>

<tr>
<td rowspan="3">LDOS 5.3.1</td>
<td>&lt;&lt; ld3-531.dsk &gt;&gt;</td>
<td>Boot</td>
<td>:ld3 or -ld</td>
</tr>

<tr>
<td>&lt;&lt; m3-ldos-blank.dmk &gt;&gt;</td>
<td>Blank</td>
<td>:lb3</td>
</tr>

<tr>
<td>&lt;&lt; m3-ldos-util.dmk &gt;&gt;</td>
<td>Utilities</td>
<td>:lu3</td>
</tr>

<tr>
<td rowspan="6">4</td>
<td rowspan="3">TRSDOS 6.2.1</td>
<td>&lt;&lt; TRS621.DSK &gt;&gt;</td>
<td>Boot</td>
<td>:td4 or -td</td>
</tr>

<tr>
<td>&lt;&lt; m4-trsdos-blank.dmk &gt;&gt;</td>
<td>Blank</td>
<td>:tb4</td>
</tr>

<tr>
<td>&lt;&lt; m4-trsdos-util.dmk &gt;&gt;</td>
<td>Utilities</td>
<td>:tu4</td>
</tr>

<tr>
<td rowspan="3">LS-DOS 6.3.1</td>
<td>&lt;&lt; ld4-631.dsk &gt;&gt;</td>
<td>Boot</td>
<td>:ld4 or -ld</td>
</tr>

<tr>
<td>&lt;&lt; m4-lsdos-blank.dmk &gt;&gt;</td>
<td>Blank</td>
<td>:lb4</td>
</tr>

<tr>
<td>&lt;&lt; m4-lsdos-util.dmk &gt;&gt;</td>
<td>Utilities</td>
<td>:lu4</td>
</tr>

<tr>
<td rowspan="4">Any</td>
<td rowspan="4">Any</td>
<td>&lt;&lt; Unformatted dmk &gt;&gt;</td>
<td>Unformatted</td>
<td>:dmk</td>
</tr>

<tr>
<td>&lt;&lt; Unformatted imd &gt;&gt;</td>
<td>Unformatted</td>
<td>:imd</td>
</tr>

<tr>
<td>&lt;&lt; Unformatted dmk DS &gt;&gt;</td>
<td>Unformatted</td>
<td>:dmk-ds</td>
</tr>

<tr>
<td>&lt;&lt; Unformatted imd DS &gt;&gt;</td>
<td>Unformatted</td>
<td>:imd-ds</td>
</tr>

</tbody></table>
</center>

<center>
<table>
<tbody><tr><th>Type</th><th>Description</th></tr>

<tr><td>Boot</td>
<td>Boot floppy for the given DOS.  Must go into drive <tt>:0</tt></td>
</tr>

<tr><td>Blank</td>
<td>Formatted floppy for the given DOS.</td>
</tr>

<tr><td>Utility</td>
<td>Utility programs for copying files to and from emulated floppies.</td>
</tr>

<tr><td>Unformatted  </td>
<td>Floppy image without any data.  Will require a <tt>FORMAT</tt> before
it can be used by a particular DOS.
</td>
</tr>

<tr><td>Extras</td>
<td>Second floppy for Model I LDOS which doesn&#39;t have the space for
everything on a single floppy.</td>
</tr>

</tbody></table>
</center>

<h3><a name="hd">Working With Hard Drives</a></h3><p>

The Hard Drive menu can attach up to 4 drives.
There are only unformatted hard drive images built-in so you will have to
either supply your own or go through the process of formatting and otherwise
setting up the emulated hard drive for use under your choice of emulated
operating system.

</p><p>
Selecting Hard Drive → :slot → &lt;&lt; unformatted hdv &gt;&gt;
(or &#34;emu&#34; or &#34;DREM&#34;) will
connect an unformatted hard drive image to the selected controller slot.
It will immediately prompt for a file to save the hard drive data.
This is unlike the diskettes which will track changes internally and only
ask to save when they are ejected.

</p><p>
On the command line use <tt>-h :hdv</tt> (or <tt>:emu</tt> or <tt>:drem</tt>)
to attach a blank hard drive image and <tt>-hx</tt> to disable the hard drive
controller.

</p><p>
The &#34;drem&#34; format is compatible with the DREM hard drive emulator available
at <a href="https://www.drem.info/">https://www.drem.info/</a>.  It stores
hard drive images as a pair of files.  A <tt>file.cfg</tt> which gives the
geometry and other information and a <tt>file.dsk</tt> which holds the data
for all the blocks.

</p><p>
The &#34;emu&#34; format is compatible with the Gesswein MFM emulator available at
<a href="https://www.pdp8online.com/mfm/mfm.shtml">https://www.pdp8online.com/mfm/mfm.shtml</a>.
Both the &#34;drem&#34; and &#34;emu&#34; formats allow for convenient copying of hard drive
images to or from real TRS-80&#39;s.

</p><p>
FreHD emulation is not generally compatible with the Model II hard drive.
Model II operating systems like the built in TRSDOS-2.0a which are unaware
of the hard drive can import and export files using the FreHD utilities.
But TRSDOS-II will fail to boot with <tt>-frehd</tt> enabled.


</p><h3><a name="cass">Working With Cassettes</a></h3><p>

Cassette tape image files in the standard </p><tt>.cas</tt><p> format can be
inserted into the virtual cassette drive with the Cassette → Insert...
menu or the </p><tt>-c</tt><p> command line option.  Upon insertion trs80gp
adds entries to the Cassette menu corresponding to each cassette file
found in the </p><tt>.cas</tt><p> image.  Normally there is only one file.
You can &#34;fast forward&#34; or &#34;rewind&#34; the cassette by selecting the
menu entry for a file.  Each menu entry gives information on each
cassette file: counter position, 
format, name (if any), baud rate and length in seconds.

</p><p>
When the TRS-80 goes to read the cassette (usually as the result of
a <tt>CLOAD</tt> or <tt>SYSTEM</tt> command) the emulator will send the
data to the TRS-80 and go into turbo mode to load the data as quickly as
possible.  Cassette → Auto Turbo can be used to disable this feature.

</p><p>
When the TRS-80 saves a cassette file (e.g., a <tt>CSAVE&#34;A&#34;</tt> command
is entered) the emulator switches to turbo mode.  It will prompt you for
a PC file in which to save the <tt>.cas</tt> image when the save is done.
If you&#39;d rather just hear the cassette send to the speaker turn off
Cassette → Auto Save.

</p><p>
When loading a cassette file the emulator displays the cassette
counter in the title bar as <tt>Cr|123|</tt>.  When writing the
title bar will show <tt>Cw|001|</tt>.  If the counter stops when reading
then the emulator has reached the end of the inserted cassette tape image.
If the TRS-80 hasn&#39;t finished loading then the load has likely failed.

</p><h3><a name="wafer">Working With Aculab Floppy Tapes</a></h3><p>

The Wafer menu shows all 8 tape drives and what wafer image is inserted
in them or </p><tt>&lt;empty&gt;</tt><p> if there is none.  Any wafer name
enclosed in </p><tt>&lt;&lt; .. &gt;&gt;</tt><p> is a built-in wafer
image.  If the name has an asterisk (</p><tt>*</tt><p>) before it the wafer has been
modified and must exported to be saved.  For non-internal wafer images the
changes are saved automatically.  trs80gp will prompt to save modified
wafer images when you try to eject them or exit the emulator.

</p><p>
All built-in wafer images have a <a href="#intwafer">short name</a>
that starts with a colon. This is displayed in parenthesis on each entry
in the &#34;Insert wafer...&#34; menu as a reminder that the short name can be used
on the command line to insert the wafer when starting trs80gp.

</p><p>
Each drive has a sub-menu that lets you eject, replace, insert, export to a
new file or toggle the write protection of a wafer image.
This isn&#39;t the read-only flag of the PC file system but an internal one
corresponding to the physical write protect sticker on real floppy tapes.

</p><p>
You can also use the Wafer menu to manage files on the image.  The menu
shows a list of files on the wafer. Selecting one will prompt to save it
to your PC.  A Delete sub-menu also lists the files and selecting an entry
will delete that file from the wafer.  Finally, the Import... menu lets
you copy files from the PC into the wafer image.  Because the Aculab firmware
may have a copy of a sector in memory is best to <b><tt>@LIST</tt> a drive
before and after doing any file imports or deletes</b>.

</p><p>
Whenever a wafer is accessed trs80gp will go into turbo mode automatically.
This can be enabled or disabled with the Wafer → Auto Turbo menu.

</p><p>
The Wafer → Manual... brings up brief instructions how to activate
and use the Aculab Floppy and access the files from within the TRS-80.

</p><h4><a name="intwafer">Internal Wafer Images</a></h4>

<center>
<table>
<tbody><tr><th>Description</th><th>Command Line</th></tr>
<tr><td>5 foot (14 sectors)</td><td>:a5</td></tr>
<tr><td>10 foot (30 sectors)</td><td>:a10</td></tr>
<tr><td>20 foot (64 sectors)</td><td>:a20</td></tr>
<tr><td>30 foot (104 sectors)</td><td>:a30</td></tr>
<tr><td>50 foot (180 sectors)</td><td>:a50</td></tr>
<tr><td>75 foot (252 sectors)</td><td>:a75</td></tr>
<tr><td>Maximum (256 sectors)</td><td>:amax</td></tr>
</tbody></table>
</center>

<h4>.tape File Format</h4><p>

Aculab floppy tape wafers are stored in </p><tt>.tape</tt><p> format which is
designed to hold not only those images but also Exatron Stringy Floppy
images and cassette tapes in various formats.  It maintains 99% backwards
compatibility by putting an identifying trailer at the end of the file.
Simple formats such as </p><tt>.cas</tt><p> will see the trailer as noise at
the end of the tape while others will simply ignore it.

</p><p>
The trailer can be up to 255 bytes long and has the following format:

</p><center>
<table>
<tbody><tr><th>Size</th><th>Type</th><th>Description</th></tr>
<tr><td>4 bytes</td><td>Magic string</td>
	<td>Assist in identifying <tt>.tape</tt> format.</td></tr>
<tr><td>1 byte</td><td>Trailer length</td>
	<td>Currently 9 bytes.  Will be longer if <tt>.tape</tt> format extended.</td></tr>
<tr><td>2 bytes</td><td>Trailer checksum</td>
	<td>Computed by setting checksum to 0 and for each trailer byte doing
		<tt>checksum = checksum * 2 + trailer[i];</tt>  Stored little-endian
		and trailer bytes are treated as unsigned.</td></tr>
<tr><td>1 byte</td><td>Flags</td>
	<td>bit 0 - write protected if set</td></tr>
<tr><td>1 byte</td><td>Data type</td>
	<td>Character indicating the encoding of the data before the trailer.</td></tr>
</tbody></table>
</center>

<p>
trs80gp only creates and understands a specific variant of <tt>.tape</tt>
files for Aculab Floppy Tape emulation — flag bit 2 set, data type
<tt>&#39;d&#39;</tt> and data consisting of concatenated 256 byte sectors from 0
to the tape size.

</p><p>
When Extratron Stringy Floppy emulation is added to trs80gp it is expected
it will be capable of <tt>.esf</tt> wrapping and bit level encoding.


</p><h3><a name="sound">Sound</a></h3><p>

Output to the cassette, Orchestra 80/85/90 or built-in speaker on the Model 4)
is played as audio on your PC.
Unless the cassette motor is turned on in which case
trs80gp will convert cassette output to data (if Cassette → Auto Save is on).

</p><p>
Use File → Mute to toggle sound on and off.

</p><h3><a name="memory">Memory</a></h3><p>

The </p><tt>-mem</tt><p> option is used to set the main memory size in kilobytes.
It defaults to the maximum standard RAM for the model.
On Model 16 and 6000 systems
there is </p><tt>-mem16</tt><p> for the 68000 processor&#39;s available memory.  It
defaults to 1 MB as earlier versions of Xenix would crash if more memory
was available.  In the Record menu and debugger memory is referred to as
RAM and </p><tt>ram[]</tt><p> in <a href="#trace">Bus Trace</a> output.
</p><p>
The standard maximum RAM on a Model 4 was 128 KB.  HyperMEM expands
that up to a megabyte with <tt>-mem hyper:1024</tt> and is represented
as a larger RAM in the debugger, recording and trace.  For memory
sizes greater than 128 K hyperMEM is assumed.  <tt>-mem 256</tt> is
equivalent to <tt>-mem hyper:256</tt> on a Model 4.
</p><p>
The Model 4 also features two expansion RAMs, <tt>-mem super:1024</tt>
and <tt>-mem mega:16384</tt>.  These don&#39;t extend main memory but provide
a new tranche of banked RAM.  The Record menu and the debugger refer
to them as &#34;Expansion RAM&#34; and accesses to it show up as <tt>expram[]</tt>
in the trace log.


</p><h3><a name="print">The Printer</a></h3><p>

Many different types of printers could be attached to a TRS-80.  The
emulator supports a simple text mode printer.  Use Printer → Printer...
to see the current output in a &#34;Printer Output&#34; window.  There&#39;s a
Save button to save the output to a file.
</p><p>
The printer window can automatically pop up when the emulator prints
something.  Use Printer → Auto Popup to enable this feature.  You
can also simulate a powered-down (or disconnected) printer with
Printer → On.
</p><p>
Like the serial ports the printer port can be mapped to a TCP/IP connection.
To listen for a connection use <tt>-p @port</tt> or the &#34;TCP/IP Listen&#34;
option in the Printer → Connection... dialog.  To make a connection
use <tt>-p host:port</tt> or &#34;TCP/IP Connect&#34; in the connection dialog.
</p><p>
To attach an emulated MX-70 printer use <tt>-p :mx70</tt> on the command line
or use Printer → Connection... and select it from the drop-down.
</p><p>
The Electric Crayon colour display actually attaches via the printer port.
The idea was to make it easy to program.  For example, a BASIC
<tt>LPRINT&#34;ERS&#34;</tt> will erase the screen.  See the section on
the <a href="#ec">Electric Crayon</a> for some details on how to use it.

</p><p>
In batch mode and TRS-80 printer output is written to a file
called <tt>trs80-printer.txt</tt>.

</p><h3><a name="serial">Serial (RS-232) Ports</a></h3><p>

trs80gp can map serial ports to TCP/IP connections or emulate 2 and 3 button
serial mice.  To have a serial port connect to a TCP/IP server use
</p><tt>-r host:port</tt><p> or open Serial → Port A, fill in the hostname
and port and choose &#34;TCP/IP Connect&#34;.  Or the serial port can listen on a
TCP/IP port with </p><tt>-r @port</tt><p> or use &#34;TCP/IP Listen&#34; in the serial
port dialog box.  Most machines have a single serial port, the Model 2 line
has two ports accessible on the command line with </p><tt>-rA</tt><p> and </p><tt>-rB</tt><p>.

</p><p>
trs80gp instances can now be &#34;wired&#34; together through serial ports.
The ultimate setup is one trs80gp running Model 16 Xenix with two trs80gp&#39;s
attached running DT-1 terminals.  But here&#39;s a simple example of hooking
two DT-1 terminal emulations together.

</p><pre>     trs80gp -mdt1 -r :4000
     trs80gp -mdt1 -r @4000
</pre><p>

Characters typed on one of the DT-1&#39;s will appear on the second one.  Assuming
everything is working. If it does not work check the &#34;Status&#34; indicator of each
serial port.  Both sides should note they are &#34;connected&#34;.  But the &#34;@&#34; side
may only show &#34;Listening...&#34; or the other side &#34;Connecting...&#34; both indicating
no connection has been made.  Or &#34;-unbound-&#34; if there has been some error.

</p><p>
To break a connection use the &#34;None&#34; option in the dialog box dropdown.  The
other side may not see the loss of connection so you may need to manually
manage &#34;unplugging&#34; on both sides.  trs80gp is not quite ready to be an
internet &#34;dial-up&#34; BBS.

</p><p>
The status will also show the current transmission settings of the serial port.
Baud rate, bits per word, parity and number of stop bits.  These do not affect
TCP/IP connections but the emulation will limit transmit and receive speeds
based on port setup.  Most original TRS-80 hardware could be set up to have
different transmit and receive speeds.  That unlikely configuration will be
hidden from view.  In the Model 2 line the higher baud rate settings are not
exact.  trs80gp will display the exact baud rate (feature or bug? You tell me).

</p><p>
As a convenience trs80gp can launch <a href="#dt1">DT-1</a> and
<a href="#videotex">Videotex</a> terminals directly from the command line
or in the serial port connection dialog.  For example, you might launch a
two terminal Xenix system with:

</p><pre>     trs80gp -m6000 -h xenix33.cfg -rA :dt1 -rB :dt1
</pre><p>

Or you can choose the desired terminal from the dropdown in the
serial port connection dialog.  Either way, these terminals will act
as a unit with the main trs80gp emulator.  If you exit the main emulator
the terminals will also be forced to exit.

</p><p>There is not yet a facility to map serial ports to real serial ports on
the host machine.


</p><h3><a name="record">Recording</a></h3><p>

The screen display and sound of the emulator can be written to a file
using the Record → Flash Video and Record → Video menus the start
and stop recording.  The window title will flash either </p><tt>*flv*</tt><p>
or </p><tt>*avi*</tt><p> to remind that that recording is in progress.  The
&#34;Flash Video&#34; option is recommended as the resulting file size is <b>much</b>
smaller than &#34;Video&#34;&#39;s uncompressed </p><tt>.AVI</tt><p> output.

</p><p>
Use Record → Animated GIF to start and stop recording of the screen in
animated GIF format.  The window title will flash <tt>*gif*</tt> to let
you know GIF recording is in progress.  The resulting files are large and
not exactly the same frame rate as the TRS-80.

</p><p>
For a screen shot you can use Edit → Copy which copies ASCII text,
Unicode and bitmap versions of the screen to the clipboard.
Or use the <tt>Ctrl-Alt-C</tt> and <tt>Ctrl-Insert</tt> keyboard shortcuts.
You can then paste it in Notepad or Paint (or pretty much anything else).

</p><p>
There is also Record → Screenshot to save the screen display as a GIF
image (shortcut: <tt>F11</tt>).  Record → Cleanshot or <tt>Shift-F11</tt>
will save a clean screenshot (or &#34;cleanshot&#34;) that does not have the beam
drop-outs as normally appeared on the Model I and Model III.

</p><p>
Audio output can be captured in <tt>.WAV</tt> format using Record → Audio
with <tt>*wav*</tt> flashing in the title bar to let you know it is recording.
This is fine for sound effects but unfortunately does not work as a way
to create files that can be loaded on real TRS-80&#39;s.  Instead you should rely
on the automatic Cassette → Auto Save feature and use
<a href="https://ideasimagerystory.substack.com/p/trld.html">my trld program</a> to convert the <tt>.CAS</tt> file to
<tt>.WAV</tt> format.

</p><p>
The rest of the Record menu entries are meant for programmers and are
<a href="#prog">documented in the programming section</a>.  I will note
that Record → MHz Audio records audio files with a very high sampling rate
equal to the Z-80 processor speed.  Most times you do <b>not</b> need that
level of fidelity.

</p><p>
The <tt>-batch</tt> command line option causes all the Record menu entries
to save to a specific file name to allow for fully automated testing of
trs80gp itself.  It also can be thought of as a way for the emulated TRS-80
to act as a batch processor.  More on this in the
<a href="#prog">programming section</a>.


</p><h3><a name="turbo">Turbo Mode</a></h3><p>

trs80gp can be explicitly or manually told to enter turbo mode where the
emulated TRS-80 is run faster than real time, sometimes as much as 8 times faster.
The entire system and not just the Z-80 is sped up so any virtual I/O between
cassette and diskette is not affected nor are any active recordings.  It will
try to record faster but the resulting recording will be at normal speed.
Turn off authentic rendering with View → Authentic Display of the </p><tt>-na</tt><p>
command line option to let the TRS-80 run a bit faster.

</p><p>
Use the <tt>-turbo</tt> command line option to have it run constantly in
turbo mode.  Or hold the <tt>F12</tt> key for a temporary speed boost.
<tt>shift-F12</tt> will keep turbo mode active without having to hold
<tt>F12</tt> and will turn off when you release <tt>F12</tt>.

</p><p>
In order to let you experience the TRS-80 in the best light trs80gp
automatically enters turbo mode when doing cassette of diskette I/O.
That can be turned off with the Cassette → Auto Turbo and
Diskette → Auto Turbo menus.  

</p><p>
Normally a turbo mode would cause massive key repeats because your normal
typing speed will appear to the TRS-80 as if each key has been held down
for a very long time.  This is mitigated by trs80gp dropping out of turbo
mode whenever a key is pressed.  Use Keyboard → Auto De-turbo to turn
off this feature if it isn&#39;t a problem for your application.  Typically
games still work fine and you can challenge yourself by playing them at
high speed.

</p><p>
At the expense of graphical and timing accuracy the emulator can run up
to twice as fast as turbo mode with the <tt>-haste</tt> command line argument
(or by using the File → Haste menu item).  As the old saying goes,
haste makes waste so only use this when speed is vital.  Besides only
updating the display once per second, &#34;haste&#34; skips wait state calculations
which will throw off the timing of a program that accesses the display.
Any video capture will also be distorted.

</p><h3><a name="display">Display</a></h3><p>

By default trs80gp starts in authentic display mode.  This mode
looks most like the original TRS-80 display and scales very well to fit any
window size.  It is selected with </p><tt>-va</tt><p> or View → Authentic Display.

</p><p>
For a less realistic but still scalable display there is View → Sharp Display
or the <tt>-vs</tt> flag.  In this mode pixels are drawn as tiny rectangles
in a single colour rather than the fuzzy dots that are brightest in the middle
used in authentic mode.

</p><p>
Since the sharp display doesn&#39;t look as good at some scales due to poorer
antialiasing there is View → Fixed Sharp Display or <tt>-vi</tt>.  While
the window can be resized in this mode the display will only use whole number
scales (e.g., 1X, 2X, 3X, etc.) to make the display look as sharp as possible.

</p><p>
Finally there is View → Cheap Display or <tt>-vh</tt>.  It will
scale up in whole number jumps it always maintains a correspondence between
TRS-80 pixels and PC display pixels even if the aspect ratio is not the
same as the original TRS-80 display.  The Model I mode is particularly
distorted and the window size will change when a Model 4 switches between
80 and 64 character modes.  This mode is mainly of benefit to PCs with
small displays or less processing power.  It is also useful for testing since
the mapping from the resulting pixels to TRS-80 graphics is simpler.

</p><p>
While ignored in authentic mode, <tt>-vN</tt> can be used on the command line
to start the emulator at a fixed display scale (e.g., <tt>-v3</tt> for 3X scaling).
In any mode <tt>-win WxH</tt> can set the starting window size to W x H.

</p><p>
trs80gp can start in full screen mode (showing no menu bar, window borders
or system elements) using <tt>-vf</tt> or <tt>-win full</tt>.  Use the
View → Fullscreen menu entry to switch to full screen mode at any time
or toggle between fullscreen and windowed with the <tt>Alt-Enter</tt> keyboard
shortcut.  Or use the right-click context menu.
Full screen mode is nice for
those whose eyesight isn&#39;t what it used to be or if you want your PC to feel
more like a real TRS-80 instead of an emulation.

</p><p>
The View → Controls dialog allows additional control over the display.
There are sliders to adjust the brightness and contrast of the display much
like the original TRS-80.  It even permits adjustments that leave the display
dimmed or brightened beyond readability.

</p><p>
The display colour can be changed from the usual bluish-white to any colour
you like with quick presets for Green, Amber and white.  Similarly the colour
used to show beam conflicts (a programmer feature, more on that below) can
also be changed from the default blue.  Changes to colours become the default
on a per-model basis.  I personally like my Model 4 display green and amber
for the Model 2.  The <tt>-vc</tt> and <tt>-vd</tt> command line options can
change the display colour without saving it as a default.  Or they can
specify the factory default by using <tt>-</tt> as the colour
(e.g., <tt>-vc -</tt>).

</p><p>
Under Windows trs80gp remembers the display mode and window positions for
each particular model.  The windows can be set up just the way you like them
and will be in those positions the next time you run.  If you run more than
one trs80gp emulator for a model at once the second and subsequent instances
will have their own set of window positions and display settings.  They will
also indicate the instance as a <tt>#2</tt>, <tt>#3</tt>, etc. in the
window title bar.

</p><h4>Beam Debug</h4><p>

View → Beam Debug (or </p><tt>-bd</tt><p>) turns on beam debug mode which is
used to illustrate when the Z-80 and video circuitry conflict over access to
display memory.  When this happens on a real TRS-80 the video display will
show short black streaks (or white in hires) instead of the actual data
displayed.  This was most prevalent on the Model I and was colloquially
referred to as &#34;screen hash&#34; or &#34;snow&#34; or &#34;raster lines&#34;.  The Model 3 has
this to a generally lesser extent.  It should appear in Model 4 hires modes
and on the Model 2 but, much to my shame, I have not written that emulation yet.

</p><p>
In &#34;Beam Debug&#34; mode these dropouts are instead coloured in blue to made them
even more noticeable but yet show what would have been displayed had there
been no conflict in shades of blue.  This is very helpful for getting the
timing right when development programs that write to the display with very
precise timing to increase effective display resolution. For instance, see
<a href="https://ideasimagerystory.substack.com/p/ball.html">my bouncing ball demo</a>.  Beam debug mode reveals how
it secretly writes to the display where it is already black so beam conflict
remains hidden from view.

</p><p>
This mode also shows the V-Blank and H-Blank portions of the display as
rectangular regions below and to the right of the usual display respectively.
Z-80 access to video memory during those times will show up as beam conflicts
even though there is no actual conflict.  Instead they function as a sort of
oscilloscope to show when the Z-80 is accessing video memory.  H-Blank or
&#34;Horizontal Blank&#34; is the short time when the CRT electron beam is moving
from the end of a display line to the start of the next one.  V-Blank or
&#34;Vertical Blank&#34; is a longer interval when the beam is moving from the bottom
of the display to the top.

</p><p>
Beam Debug is not supported by the authentic display mode so if activated it
will automatically switch the TRS-80 to cheap display mode.

</p><h3><a name="frehd">FreHD Emulation</a></h3><p>

The FreHD is a modern-era TRS-80 Model 1, 3 and 4 peripheral which emulates
a hard drive using image files on an SD card.  It was designed by
Frdric Vecoven in 2013 and is fully
<a href="https://github.com/veco/FreHDv1">open source</a> but most users
purchase kits or pre-assembled versions from
<a href="http://frehd.com/">Ian Mavric</a>.  The open source hardware
<a href="https://github.com/apuder/TRS-IO">TRS-IO</a> (for Model 1, 3 and 4)
also operates in a hardware compatible fashion to the FreHD.

</p><p>
Since trs80gp can emulate a
hard drive itself, FreHD emulation just means the other handy features of the
FreHD such as the real time clock and access to the host file system for
<a href="#impexp">file import and export</a>.  It also means you can
experience <a href="http://48k.ca/trsvid.html">TRS-80 video</a> and test
your own FreHD files without needing a real TRS-80 or FreHD.

</p><p>
There are only two FreHD features not implemented.  The <tt>VHDUTIL</tt>
cannot set the clock and you cannot mount floppy disk images through the
FreHD using the special <tt>DSK/DTC</tt> device driver.

</p><p>
In most cases all that&#39;s needed is to copy the contents of a FreHD SD card
to a directory (or simply mount the SD card on your PC) and run:

</p><pre>     trs80gp -m4 -frehd_dir frehd_file_directory
</pre><p>

Or use the Hard Drive → FreHD → Directory... menu to
accomplish the same thing through the GUI.

</p><p>
FreHD setups often come with patched versions of the TRS-80 Model 1, 3 or 4
ROMs that will boot from the FreHD when the machine is powered on.  Normally
they will only boot from floppy disk and require a special boot floppy that
boots with the hard drive active.  Add the <tt>-frehd_patch</tt> option or
use Hard Drive → FreHD → ROM Patches to have trs80gp act the same way.

</p><p>
When FreHD emulation is enabled trs80gp will try to connect the image files
<tt>hard4-0</tt>, <tt>hard4-1</tt>, <tt>hard4-2</tt> and <tt>hard4-3</tt>
in the root of the FreHD directory as hard drives 0 through 3 respectively.
But it will only do it when the respective hard drive has no image connected.

</p><p>
The built-in FreHD loader block can be overriden with a custom 256 byte boot
block using <tt>-frehd_load file.bin</tt> or the
Hard Drive → FreHD → Loader... menu entry.
FreHD&#39;s auto-boot normally tries to load the FreHD menu from a
<tt>frehd.rom</tt> file in the FreHD directory.
For convenience, trs80gp has a version of the FreHD menu program built-in and
you can activate it with <tt>-frehd_menu</tt> or
Hard Drive → FreHD → Built-in Menu.

</p><h4>The FreHD Boot Sequence</h4><p>

On a real FreHD changing the loader block requires a rebuild of the firmware.
It is far easier to experiment with such changes on trs80gp.  However, the
FreHD boot sequence is not widely understood so I will go over it in some
detail to help anyone debugging or developing for the FreHD.

</p><p>
The Model 4P is the only TRS-80 in the 1,3,4 line that has hard drive boot
code in its ROM.  A properly configured hard drive image will boot on the 4P
without any FreHD auto-start patches to the 4P&#39;s 4K ROM.

</p><p>
The FreHD auto-start patches do not add direct hard-drive booting to the
Model 1, 3 or 4.  Instead, just before trying to boot off the floppy,
they load and execute 256 byte FreHD loader block
into RAM location $5000.  If the space-bar is held the loader block will
return to the ROM and the boot will proceed normally.
Otherwise, the loader block will then try to load and
execute the <tt>frehd.rom</tt> menu program from the SD card.  Despite it&#39;s
suffix, the <tt>frehd.rom</tt> file is actually in <tt>/CMD</tt> format.

</p><p>
The FreHD menu program displays a nice splash screen which includes
the version number of the FreHD firmware (as determined by querying the
FreHD itself).  It then uses the FreHDs extended facilities to list
available hard drive images to boot.  When the user selects one it
instructs the FreHD to mount that hard drive image and proceeds to
boot it.

</p><p>
Booting is mostly a matter of loading the second sector from the hard drive
into $4300 (or $4200 on the Model 1) and executing it.  Before doing so
the FreHD menu will write the current time and date into a few locations.
Most TRS-80 operating systems will check for a valid date in these locations
when they boot and not prompt for one.

</p><p>
Here is where I am not entirely clear on the exact operation for the FreHD
menu program.  It will also try to make patches to the boot block and perhaps
even the operating system itself.  I believe the intent of these patches it
to allow certain TRS-80 operating system to accept the pre-initialized
time and date.  There may well be other purposes.

</p><h4>Boot Sequence in Depth</h4>
<p>
Note that you could write your own <tt>frehd.rom</tt> menu program.  And
in the general sense it could do anything you want.  It could just be a
game that auto-boots on the FreHD.  But if you aim to improve the menu
or even make a different loader block then you&#39;ll want to
<a href="https://github.com/veco/FreHDv1">consult the source code</a>.
And continue reading as I have a few more details on how it all hangs
together.

</p><p>
On the Model 3 a fairly short sequence of ROM BASIC commands can be used to mimic
the auto-start ROM patch:

</p><pre>     POKE 16912,16
     10 OUT 197,3
     20 IF INP(196)&lt;&gt;254 THEN PRINT&#34;No frehd&#34;:END
     30 FORI=0TO255:POKE20480+I,INP(196):NEXT
     RUN
     SYSTEM
     /20480
</pre><p>

The same code will work on the Model 4, just change line 10 to output 4.
And on the Model 1 don&#39;t do the initial </p><tt>POKE</tt><p> and change line 10
to output 1.  The initial poke turns on </p><tt>EXTIO</tt><p> in the shadow register
of port $EC.  Without that the FreHD will not see accesses to it.
Note that the program will not work in Disk BASIC since the POKEs will
scramble the extra code loaded by Disk BASIC and crash the program.

</p><p>
Notice that the loader block must start with $FE or it will be ignored by
the auto-start patch.  That&#39;s so the auto-start patch has no effect when
there is no FreHD attached.  It is actually bytes 1 through 255 of loader
block that are put into RAM $5000 (20480).  The last byte at $50FF is the
first byte which is $FE.  The initial <tt>OUT</tt> to port 197 ($C5) serves
two purposes.  It tells the FreHD to start feeding byte 0 and on of the
load block when reads come in on port 196 ($C4).  And it outputs that
value as byte 2 of the loader block.  Since execution begins at byte 1
the loader block must put an instruction there which effectively skips
byte 2.  As such, loader blocks have byte 1 set to $FE which is the
Z-80 <tt>CP A,n</tt> instruction.

</p><p>
This byte is used by the auto-start patch to indicate to the FreHD menu
program what type of TRS-80 it is running on.  Hence the 1 for Model 2,
3 for Model 3 and 4 for Model 4.  The Model 4P auto-start patch puts in a 5.

</p><p>
If the loader block cannot find a <tt>frehd.rom</tt> file on the SD card
it will simply return and the TRS-80 will boot as normal.

</p><p>
Once the FreHD menu program is loaded it will load the model number from
location $5001.  Initially it uses the model number to decide if it should
use the ROM routine to read the keyboard (1, 2, 3, 4) or its own keyboard
scanning for model 5, the 4P.  It then scans the root directory of the SD
card looking for hard drive image files in
<a href="http://www.trs-80emulators.com/hdv1-format/">HDV</a> format.
A file must start with the bytes $56 $CB, have bit 0 of byte 8 set (indicating
autoboot) and byte 11, the OS type must be one of:

</p><pre>     0 for LS-DOS 6.3.1
     1 for LDOS 5.3.1
     2 for CP/M
     3 for Newdos 2.5
     4 for Model I LDOS 5.3.1
     5 for Model I NEWDOS 2.5
</pre><p>

trs80gp&#39;s built-in FreHD menu also experimentally accepts 6 for MULTIDOS.
Files meeting these criteria will be listed for the user to select but with
one more condition for model number 5 (Model 4P).  An OS type of 1 or 3
will only be listed if a &#39;modela.iii&#39; is on the SD card.  That&#39;s because
those are Model III OS&#39;s and will only work on the 4P if the ROM image
has been loaded.

</p><p>
As mentioned before, once an image is selected it will be mounted as hard
drive 0 and the menu will kick off the boot by loading sector 2 from the
hard drive into $4300 (or $4200 if the model number is 1).

</p><p>
It will also write the current date and time into one or more memory locations
depending on the model number and OS type.  This will make most TRS-80
operating systems skip prompting of the date and time as they are already
initalized.

</p><p>
Before executing the boot block the FreHD menu system may patch the hard
drive boot block (or even, I think, some of the code loaded by the boot
block) for unclear purposes.  I suspect it is to allow some of the
OS&#39;s to accept an initialized date.  And maybe even patch the OS to load
from the hard drive instead of diskette.
The menu will also load the <tt>modeala.iii</tt>
from the SD card on the Model 4P if the OS type is 1 or 3 so those Model 3
operating systems will work on a 4P which does not have the necessary
BASIC ROM to support them.

</p><p>
After that the FreHD system is out of the picture and the operating systems
boots as it would off a regular hard drive.

</p><p>
The diligent programmer can make use of the various memory locations
and I/O ports to set breakpoints to inspect the boot process at any point
in its various steps.  Special FreHD operations such as opening and reading
files on the SD card are recognized and displayed clearly in the
<a href="#trace">bus trace</a> allowing a high level view of what a
program is doing with the FreHD.


</p><h3><a name="prog">Programming</a></h3><p>

Whether you&#39;re writing programs for the TRS-80 or simply wish to
dissect existing programs trs80gp has much to offer.  As such this section
is rather brief on details.  Please do get in touch with me if you have
questions.

</p><h4><a name="batch">Running Programs</a></h4><p>

Normally on a TRS-80 programs are run either as </p><tt>/CMD</tt><p> files at the
TRS-DOS prompt or loaded from cassette with CLOAD or SYSTEM commands.
This is the best way to test programs you write but only needs to be done as a
final test.  For development trs80gp will directly load programs from
the command line or via the File → Run... menu or via drag and drop.
This is largely similar to standard procedure but does has its differences.
Existing TRS-80 games often work well when run directly but there&#39;s no guarantee.

</p><h4><a name="batch">Batch Mode</a></h4><p>

Activate batch mode using the </p><tt>-batch</tt><p> command line option.  In
this mode many operations (most in the Record menu) will not prompt for
a file name but will instead simple write the file to some fixed file name.
This may seem odd but is very useful for testing your programs or trs80gp
itself.  One way to use this is to have your program write status information
to the printer (out $F8 will do on Model 3,4) and use the
<a href="#ee">emulator extensions</a> to make trs80gp exit.  You can then
run it using:

</p><pre>     trs80gp -m4 -ee program.cmd
</pre><p>

And it will go through its paces writing output to </p><tt>trs80-printer.txt</tt><p>.
If trs80gp doesn&#39;t exit then you know your program went wrong.

</p><p>
In batch mode many of the menu entries switch to saving files without
prompting.  In most cases those files are named in sequence starting
with <tt>file-0.txt</tt>, <tt>file-1.txt</tt> and so on.  Those are
represented by <tt>file-%d.txt</tt>.

</p><center>
<table>
<tbody><tr><th>Menu</th><th>Output file(s)</th></tr>
<tr><td>Bus Use</td><td>bus-use-%d.txt</td></tr>
<tr><td>Backtrace</td><td>backtrace-%d.txt</td></tr>
<tr><td>Text VRAM</td><td>trs80-text-%d.bin</td></tr>
<tr><td>Character Generator VRAM</td><td>trs80-char-%d.bin</td></tr>
<tr><td>Graphics VRAM</td><td>trs80-graphics-%d.bin</td></tr>
<tr><td>RAM</td><td>trs80-ram-%d.bin</td></tr>
<tr><td>RAM16</td><td>trs80-ram16-%d.bin</td></tr>
<tr><td>Expansion RAM</td><td>trs80-expram-%d.bin</td></tr>
<tr><td>Cassette → Auto Save</td><td>trs80-cassette-%d.bin</td></tr>
<tr><td>Audio</td><td>trs80-%d.wav</td></tr>
<tr><td>MHz Audio</td><td>trs80-%d-mhz.wav</td></tr>
<tr><td>Z-80 Profile</td><td>profile-%d.txt</td></tr>
<tr><td>Trace</td><td>bus-trace-%d.txt</td></tr>
<tr><td>Flash Video</td><td>trs80-%d.flv</td></tr>
<tr><td>Video</td><td>trs80-%d.avi</td></tr>
<tr><td>Animated GIF</td><td>trs80-%d.gif</td></tr>
<tr><td>Screenshot</td><td>trs80-%d.gif</td></tr>
<tr><td>Printer</td><td>trs80-printer.txt</td></tr>
<tr><td>Diskette (on exit)</td><td>trs80-drive%d-%d.dsk</td></tr>
<tr><td>Hard Drive</td><td>trs80-hard-disk-%d.dsk</td></tr>
<tr><td>Wafer (on exit)</td><td>trs80-wafer%d-%d.tape</td></tr>
</tbody></table>
</center>

<p>
It is worth re-iterating that <a href="#autoin">automated input</a> options
are tantamount to scripting control over the emulated TRS-80 and can be used
to build up automated tests of your TRS-80 programs.


</p><h4><a name="debug">Z-80 Debugger</a></h4><p>

The Z-80 debugger may be activated at any time using Debug → Z-80 Debugger...
It will also come up automatically when a breakpoint is hit.  Breakpoints can
be set interactively in the debugger window in the section just below
the &#34;Go&#34; button.  Breakpoints cover a range of addresses from the value
in the left box to the one in the right which will be filled in semi-automatically
to specify a single address.  Make sure to tick the checkbox next to the
start address/label to enable the breakpoint.  PC breakpoints can also
be set by double-clicking on the Disassembly sub-window.  

</p><p>
You may set up to 4 breakpoints of each type.  A &#34;PC Breakpoint&#34; is the
traditional kind which is triggered whenever a program executes in the given
address range.  Other types trigger whenever memory is read or written in
the range or I/O is performed.  These types are useful to find when particular
variables are changed or accessed and finding when devices are accessed.
Breakpoints may also be set on the command
line by the <tt>-b</tt>, <tt>-bm</tt>, <tt>-bio</tt> and related options.

</p><p>
A <tt>&gt;</tt> appears in the disassembly window to indicate the next
instruction to execute and an asterisk (<tt>*</tt>) to show any active
PC breakpoints.

</p><p>
Memory and I/O breakpoints (or if the Z-80 has set breakpoints using the
the <a href="#ee">Emulator Extensions</a>) show extra information in the
debug window when they are triggered.
The Disassembly sub-window will show a <tt>!</tt> to indicate
the instruction that caused the fault and additional letter codes
indicating what kind of fault or faults occurred.  The <tt>&gt;</tt> will
point to the next instruction to execute as usual.

</p><pre>       R      Read protected memory
       W      Write protected memory
       E      Execute protected memory
       S      Stack protected memory
       I      Input protected I/O
       O      Output protected I/O
</pre><p>

Various sub-windows show the current Z-80 register contents with them displayed
in red if they changed during the previous step.  All values are displayed
in hexadecimal except for the T-state and cycles counters.
There is also a view of
the top of the stack and a T-state counter which can be changed as desired
to measure intervals interactively.

</p><p>
The Step button moves execution forward a single instruction.  Step Over
sets a breakpoint after the current instruction and resumes execution.  This
is useful for <tt>CALL</tt>s to run quickly though a subroutine.  Grizzled
Z-80 programmers know there&#39;s no guarantee a <tt>CALL</tt> will return right
after itself so caveat emptor.  &#34;Go&#34; resumes execution until the next breakpoint
or protection violation.  The &#34;Emulator Extensions&#34; checkbox may be
turned off to disable protection checks.

</p><p>
When single stepping the display will turn gray to give an indication where
the CRT beam is at that moment in execution.  There are also boxes in the
lower left which give the CRT beam raster Y and X coordinates.  The debugger
is still operational when the TRS-80 is running.  You can change registers and
memory locations which will show a light-blue background to indicate you&#39;ve
frozen your view of them so you may change it.

</p><p>
Since the screen shows the contents of the previous frame and the drawing of
the current frame you will not usually see an immediate change when writing
to screen memory.  It only shows up when the CRT beam reads and draws it.
The debugger memory view gives you the ability to see immediate changes to
the various different RAM systems.  The defaults is &#34;Z-80 Memory&#34; which shows
the Z-80&#39;s view of its 65536 memory locations.  In the Model 1 and 3 this
will show the BASIC ROM in the first 12 or 14 K or memory, the keyboard
matrix from $3800 to $3BFF, the video RAM from $3C00 to $3FFF and ordinary
RAM from $4000 up to $FFFF or less if a value lower than 48 was given to
the <tt>-mem</tt> command line option.  There may be no memory for some
of the address space (e.g., $3000 .. $37FF on the Model I).  Such regions
will display as <tt>~ff</tt> (or <tt>~00</tt> on the Model II) and cannot
be changed.

</p><p>
You can also select just the RAM to focus on the 48K of memory.  But keep
in mind these other views use their own addressing.  The RAM view starts at 0
but that is seen (by the Model 1 and 3) as starting at $4000.  The amount
and type of each varies depending on the Model but you&#39;ll typically see 
Text VRAM for the usual character display, and Hires VRAM for the high
resolution graphics option (which is usually only accessible to the Z-80
through I/O ports).

</p><p>
You can search through memory by typing a string into the search box.
The usual backslash escapes can be used for control and graphics characters:
<tt>\n</tt>, <tt>\r</tt>, <tt>\t</tt> and <tt>\HH</tt> for any hexadecimal value.
If the string starts with <tt>$</tt> then the rest is taken to be
hexadecimal digits with spaces ignored.
The <tt>&lt;</tt> and &gt; buttons cycle through the matches
which are highlighted in the memory window below.

</p><p>
In a clunky way RAM can be changed.  The easiest approach to to select
a memory byte and write a new hexadecimal value for it.  The emulator
simply reads back the memory dump so you can also delete a line and
enter any address followed by a colon and a series of space-separated
hexadecimal bytes to change memory locations without having to look at
them.

</p><p>
A few pseudo-memory regions are viewable but not changeable.  They
are intended to give a partial view of the TRS-80 hardware state.

</p><pre>   Z-80 Device        What the Z-80 would return if an I/O were read.
   Z-80 Port Writes   The last value written by the Z-80 to a port.
   Z-80 Port Reads    The last value read from an I/O port by the Z-80.
</pre>

<p>
At the bottom of the window are line of check boxes and drop-downs to
control <a href="#trace">bus tracing</a> which is discussed later.

</p><p>
Most of the Z-80 register state shown is familiar to Z-80 programmers
and can be directly altered by Z-80 programs.  The <tt>IFF1</tt> checkbox
is checked when interrupts are enabled (by an <tt>EI</tt>) instruction
and not when they are disabled by a <tt>DI</tt> instruction or entry into
an interrupt routine.  Relatedly, <tt>IM</tt> shows the interrupt mode
of the processor which pretty much has to be 1 for Model 1, 3 and 4 computers
and 2 for the Model 2 line.  The <tt>I</tt> register is mostly only relevant
in interrupt mode 2.

</p><p>
Other state is not directly accessible and pretty much just showing off how
accurate trs80gp&#39;s Z-80 emulation is.

</p><p>
<tt>WZ</tt> is an internal temporary register used by Z-80 during various
16 bit operations.  In an officially undocumented but reliable quirk of
implementation bits 3 and 5 of this register are put into bits 3 and 5 of
the flag register <tt>F</tt> whenever a <tt>BIT</tt> test is done on
<tt>(HL))</tt>.  Early investigators of this called the register MEMPTR.
Google &#34;Z80 MEMPTR&#34; or try
<a href="https://gist.github.com/drhelius/8497817">this link</a>
to learn more.

</p><p>
<tt>EXX</tt>, <tt>AFAF&#39;</tt>, <tt>DEHL</tt> and <tt>DE&#39;HL&#39;</tt> show the
state of internal flip-flops that select different banks of registers
when <tt>EXX</tt>, <tt>EX AF,AF&#39;</tt> and <tt>EX DE,HL</tt> instructions
are executed.  Effectively they show the number of times modulo 2
each instruction has been executed but the Z-80 program and trs80gp&#39;s
Z-80 debugger show the currently active sets are you would expect.

</p><p>
The dropdown shows special Z-80 processor states and will spend 99.999% of
its time in <tt>Normal</tt> mode.  The other modes are:

</p><ul>
<li>IntrDis - An <tt>EI</tt> instruction was just executed so the Z-80 will
not respond to a maskable interrupt until the next instruction finishes
execution.
</li><li> Halt - The Z-80 has executed a <tt>HALT</tt> instruction and will not
resume execution until an interrupt occurs.  During this time it will continue
to fetch and ignore the opcode of the current instruction.
</li><li> Pfix, PfIy - The Z-80 is in the middle of a series of <tt>$DD</tt>
and <tt>$FD</tt> bytes.  The Z-80 only pays attention to the last byte
in such a series to determine if it has an <tt>IX</tt> ($DD) or
<tt>IY</tt> ($FD) instruction.  The Z-80 cannot be interrupted during this
processing but for practical reasons trs80gp breaks such sequences down to a
progression of artificial <tt>pfix</tt> and <tt>pfiy</tt> instructions.
</li><li> PostIff2 - The Z-80 has just executed a <tt>LD A,I</tt> or <tt>LD A,R</tt>
instruction which will read the wrong value of <tt>IFF2</tt> if an interrupt
occurs at the same time as the instruction.  This is to emulate a Z-80 bug
and, unlike the others, does not correspond to a real internal state latch.
</li></ul>

<p>
The debugger also provides a sub-window for watching expressions.
For each expression you choose what result to show: The memory byte or word
at the calculated value, or the value itself (or the high/or low byte of the value)

</p><p>
Expressions use C-like syntax consisting of:
</p><ul>
<li>Decimal constants (use <tt>$</tt> or <tt>0x</tt> to prefix hexadecimal constants)
</li><li>Parenthesis to control order of evaluation
</li><li>C number operations: <tt>+ - * / %</tt>
</li><li>C bit operations: <tt>! ~ &lt;&lt; &gt;&gt; &amp; ^ |</tt>
</li><li>C comparisons: <tt>== != &lt; &gt; &lt;= &gt;=</tt>
</li><li>C logical and/or: <tt>&amp;&amp; ||</tt>
</li><li>Register names: e.g. <tt>A B C AF HL IX AF&#39;</tt>
</li><li>Register flags: e.g. <tt>F.C, F.N</tt>
</li><li>Source code symbol values (if loaded)
</li></ul><p>

There is a special syntax for reading memory inside an expression.
The expressions </p><tt>(expr)b</tt><p> and </p><tt>(expr)w</tt><p> return the
value of the byte or word at the memory location inside the expression.

</p><h4><a name="src">Source Level Debugging</a></h4><p>

My <a href="https://ideasimagerystory.substack.com/p/zmac.html">zmac</a> cross assembler will output machine
language programs in </p><tt>.bds</tt><p> format.  It is a text format so by
looking at it and the zmac source code you can probably figure out how
to generate it yourself.  But the important part here is that loading
</p><tt>.bds</tt><p> files from the command line will enable source level
debugging.

</p><p>
Use Debug → Source Code to bring up the source code that has been loaded.
It will look a bit like an assembler listing file.  The current program
location will be highlighted and follow the execution of the Z-80.

</p><p>
The format also defines symbolic labels so you can type these labels
in to the breakpoint or register windows instead of having to look up
the hexadecimal values yourself.  You can also use labels for the <tt>-b</tt>
and other command line option to set breakpoints.

</p><p>
In certain situations you may want to have symbols available for a program
but don&#39;t wish to load it into memory.  The <tt>-ls</tt> command line option
and File → Load Symbols... menu entry are used to only load the symbols
from a <tt>.bds</tt> file.  Doing so allows you to use symbolic names in
the debugger but does not alter RAM contents in case the program is already
underway.

</p><h4><a name="diskview">Disk Viewer</a></h4><p>

Under the Debug menu there is a Disk Viewer which allows you to browse
through all the floppy and hard drive images inserted and examine their data.
There is a search feature to look for strings or binary data.
The usual backslash escapes can be used for control and graphics characters:
</p><tt>\n</tt><p>, </p><tt>\r</tt><p>, </p><tt>\t</tt><p> and </p><tt>\HH</tt><p> for any hexadecimal value.
If the string starts with </p><tt>$</tt><p> then the rest is taken to be
hexadecimal digits with spaces ignored.
The </p><tt>&lt;</tt><p> and </p><tt>&gt;</tt><p> buttons will cycle through all the matches.

</p><p>
Use the drop downs to select disk images, sides, tracks and sectors.  The
sector dropdown presents both the physical and logical sector numbers.  The
logical number is the value written on the disk and is what is used when
we generically refer to reading or writing sector N.  The physical number
is the relative position of the sector in the track.

</p><h4><a name="devmap">Device Map</a></h4><p>

The debug menu also features the somewhat experimental &#34;Device Map&#34; feature.
It gives you a quick overview of the current mappings of Z-80 address and
I/O space to RAM and devices.  In short, something like the typical memory
map seen in programmer guides.  Do keep in mind that it shows the mapping
when it was brought up.  If the program subsequently switches memory maps
the window will not be updated.

</p><p>
The feature is experimental mainly because it doesn&#39;t yet display all
the emulator implicitly knows about the address space.  For example,
the Model I does not have any memory mapped from $3000 to $36FF but the
map will display that as read-only RAM.  And it says nothing at all about
the memory mapped printer and floppy disk devices accessible in the
$3700 - $37FF range.  In other words, the map can be incomplete or misleading.
But it seems more handy having it around even with its current shortcomings.

</p><h4><a name="arec">Advanced Recording</a></h4><p>

Sometimes examining memory in the debugger is too cumbersome.  The
&#34;Text VRAM&#34;, &#34;Graphics VRAM&#34;, &#34;RAM&#34;, &#34;RAM16&#34; and &#34;Expansion RAM&#34; entries
in the &#34;Record&#34; menu will save those RAM areas to a file where you can
use external tools to do a more thorough analysis.

</p><p>
The normal <a href="#record">recording</a> options can assist debugging.
It may be helpful to step through a video a frame at a time to see some
graphical glitch in detail.  The &#34;MHz Audio&#34; option takes this to the
extreme by recording audio output a sample rate equal to the speed of
the Z-80.  In effect this lets you see exactly when the audio changes.

</p><p>
The Trace option is the most useful so I&#39;ve dedicated
<a href="#trace">section to it</a>.  The other options attempt to
self-document in their output.  Unlike the Trace option these other
options don&#39;t record everything.  Typically they&#39;ll just track the
PC values to keep overhead low.  When they do their final output
the use whatever value is in RAM at the time for the disassembly.
If the program changes you may seen confusing output.  This gets even
worse if the memory mapping changes.

</p><p>
All these recording options can be activated and stopped at any time.
It is useful and often desirable to start them when the program is
stopped in the debugger and then stop them at the next breakpoint after
an interesting subroutine or full step of a game simulation has run.

</p><p>Record → Z-80 Profile tracks every instruction executed and shows you a list
of those instructions, the number of times each instruction was executed
and the total T-States spent on each instruction.  It is intended to
help measure where your program spends its time to be used as a guide
for optimization.  It can also be used to simply track what a program
as done during an interval.  However, &#34;Bus Use&#34; is better for that task
and <a href="#trace">Trace</a> will show every instruction in order.

</p><p>Record → Backtrace show the last 65536 instructions executed.  In theory
you can use this to respond to a crash.  But practically speaking that many
instructions is at most a tenth of a second so you&#39;re not likely to be quick
enough to catch it.

</p><p>Record → Bus Use tracks the execution of a program.  The output is
much like a disassembler but with markup indicating how memory was accessed:
read, written, executed, jumped to, called and so on.  The disassembly tends
to be better than a static disassembly since it uses the Z-80&#39;s execution
path to point out what is code and what is data.

</p><p>The disassembly will be entirely commented out except for any areas where
a program was loaded by the command line (or using File → Load/Run) into
memory.  The intent here is to distinguish the loaded program from the ROM
or operating system routines it uses.  If the program is sufficiently put
through its paces the result should be a good disassembly that can be
assembled to produce the original code.  Unlike the other trace options any
data uncommented in the disassembly is based on the original data loaded so
it won&#39;t be fooled by simple self-modifying code.  However, this is a problem
if the program relocates itself.  In which case you&#39;ll have to get a relocated
version of the program loaded.  At least &#34;Bus Use&#34; will help understand the
relocator code.

</p><h4><a name="ee">Emulator Extensions</a></h4><p>

These are enabled by the </p><tt>-ee</tt><p> command line option.  They can be
turned off using the &#34;Emulator Extensions&#34; checkbox in the Z-80 Debugger.
A Z-80 program accesses them by sending a function code to I/O port $47.
Here is a brief overview:

</p><pre>     0     Set bus permissions for address HL to DE to B
     2     Trigger bus fault B
     3     Disable (B=0) or enable (B=1) bus permissions
     4     Trigger execute fault (i.e., drop into the debugger)
     5     Reset (B=0) or get (B=1, into DEHL) T-state counter
     6     Control recording
              B=$41 - toggle audio recording
              B=$4D - toggle Mhz Audio recording
              B=$47 - toggle animated GIF recording
              B=$46 - toggle Flash video recording
              B=$56 - toggle video recording
              B=$53 - take screenshot
              B=$47 - take cleanshot
   64..127 Set parameter (see below)
     128   exit emulator with return code BC
     255   set carry flag (to detect if extensions active)
</pre><p>

Function 5 allows for automated profiling of Z-80 code.  Function 128
is typically used to end a test in batch mode.  The bus permissions are
very helpful in tracking down nasty bugs.  For example, you can set your
code section to execute-only.  The emulator will trap into the debugger
the instant something tries to overwrite over your code.  Or even read it.
Another useful technique is turning off stack permissions at the bottom
and top of your stack to detect stack overflow or underflow.

</p><p>For function 0 the lower 7 bits in B are set to indicate what Z-80
operation is allowed on that memory location.  Or for the first 256
addresses what I/O operation is allowed on a port.  Those bits are:

</p><pre>   Mask    Operation  Z-80 Debugger letter indicator
     1     Read       R
     2     Write      W
     4     Execute    E
     8     Stack      S
     16    In         I
     32    Out        O
     64    DMA        D
</pre>

<p>Stack permission is required for CALL, RET, PUSH, POP, RETI and RETN.

</p><p>For BASIC where <tt>OUT</tt> is readily available but controller register
contents is difficult there a way to trigger any function with just OUT
commands.

</p><p>
<tt>OUT 71,32+n</tt> will trigger function <tt>n</tt> using whatever parameters
were previously set.  A parameter is set by first doing an <tt>OUT 71,64+p</tt>
where <tt>p</tt> is the parameter number and then doing <tt>OUT 71,x</tt> to
set the value.  If a command requires a register then the parameter triggered
version of the command will read parameter 2 for register B, parameter 3 for
register C, parameter 8 for H and so on.  Or put another way, you select
the parameter for register R by sending the ascii value of the register letter.

</p><p>
For example, this will toggle animated GIF recording:
</p><pre>    OUT 71,66:OUT 71,71:OUT 71,32+6
</pre>

<h4><a name="trace">Bus Trace</a></h4><p>

The Record → Trace feature is a very powerful and comprehensive tool for
debugging Z-80 programs and the emulator itself.  It can log every
instruction executed, memory access, interrupt and I/O port access the
Z-80 or any DMA device does.  It also places markers in the output file
to indicate when a frame has ended and when one second of execution has
finished.  It can be activated a program start with the </p><tt>-trace</tt><p>
option.  The full log is recorded in the output file.  The last frame
or two of the log can be viewed using Debug → Trace Log...

</p><p>
The output can be voluminous.  You&#39;ll want to use breakpoints to
turn tracing on and off for as short a period as possible.  The &#34;Tracing&#34;
checkpoint in the Z-80 Debugger is a convenient shortcut.  And there
are additional check boxes to enable or disable tracing for Z-80
instruction, I/O accesses, memory accesses and interrupts.

</p><p>
For even finer control I/O logging can be enabled on a per-device basis.
This is handled by the device drop-down.  The interface is awkward.
As you select each device in the drop-down the checkmark to the right
changes to indicate if that device is being logged.  But you still must
check the I/O box to enable I/O logging.  To make it more confusing but
usable the best course is to turn I/O off, select the device you&#39;re
interested in, enable it and then turn I/O back on.  If you turn I/O
on first it will enable all devices by default.

</p><p>
Yes, it&#39;s bad but at least it gives some way to target particular devices.
Obviously these controls should be in some other window but the debugger
happened to be handy at the time.  trs80gp wasn&#39;t built in a day.

</p><p>
The actual logging looks something like this:

</p><pre>   8033317 @3018 z ex       jp     $35c2
   8033327 @35c2 z ex       push   af
       +11 @35c2 z wr _ffb4 00 ram[ffb4]
       +11 @35c2 z wr _ffb3 44 ram[ffb3]
   8033338 @35c3 z ex       in     a,($e0)
       +11 @35c3 z in _e0 fb
   8033349 @35c5 z ex       rra
   8033353 @35c6 z ex       jp     nc,$3365
   8033363 @35c9 z ex       rra
   8033367 @35ca z ex       jp     nc,$3369
   8033377 @35cd z ex       push   bc
       +11 @35cd z wr _ffb2 38 ram[ffb2]
       +11 @35cd z wr _ffb1 80 ram[ffb1]
</pre><p>

The first column is the T-State counter.  The second is the PC of the Z-80
when the operation occurred.  Next a letter code shows the device responsible
(&#39;z&#39; for Z-80 and &#39;d&#39; for DMA chip).  The type of access follows.  Most
are &#34;ex&#34; for instruction execution with a disassembly of the instruction
following.  But for reads, writes, ins and outs (rd, wr, in, ot) the
memory or I/O address is shown followed by the value read or written.
Other possible operations are:

</p><pre>     ht     Fetch during Z-80 halt
     i0     Interrupt mode 0 bus read
     i1     Interrupt mode 1 bus read
     i2     Interrupt mode 2 bus read
     ni     NMI (non-maskable interrupt) bus read
</pre><p>

After any access there may be a description of what the value means to that
device and possibly the internal state of the device.  A good example is
the CRTC video controller chip used in the Model 2 and 4.  An I/O write (out) to
its address register will be annotated with the name of the register
selected.  An I/O write will show the name of the register changed and
its current value.  Some devices are very simple in that any byte read
or written can only have one meaning.  But for the CRTC a write to a register
depends on which register was previously selected.  Without the annotation
you would have to search backwards for the last register selection.  And
if the register is 16 bits wide you&#39;d also have to look back for the last
time that other 8 bits were changed.  This is tedious and may not even appear
in the bus trace you&#39;ve made.

</p><p>
Not all devices provide annotations.  If they do then you can bet they were
giving us trouble in developing the emulator.  Most of the Model 2 devices
have annotations.

</p><p>
By the way, the underscore and @ signs in front of addresses are intentional
and useful.  vi (and maybe other editors) make it easy to search on words.
So starting a search on _ffb2 will only find other references to that
memory location being read or written.  But searching the word ffb2 will
find instructions that reference the address.  Or you can search for @ffb2
explicitly to restrict your search to only instructions executed at that
address.

</p><h3><a name="dt1">DT-1 Terminal</a></h3><p>

The TRS-80 DT-1 (Data Terminal 1) is not a computer but a terminal and as
such can do very little without being connected to a computer.  It does have
a built-in SET-UP screen that needs the
<a href="https://github.com/pski/model2archive/blob/master/Hardware/DT-1_Owners_Manual.pdf">DT-1 User&#39;s Manual</a>
to be understood.  Do note that you must press Page-Up on trs80gp to access
the setup screen as Ctrl+Shift+Enter will not work.  And if you&#39;re in the
setup screen use Page-Down to active the &#34;KL&#34; easter egg rather than
pressing Ctrl+Shift-4.

</p><p>
The trs80gp Setup menu provides all the functionality of the DT-1 SET-UP screen
in a somewhat more descriptive format.  It will also change the SET-UP screen
if you&#39;re in it so you can learn the cryptic settings.  Use Setup →
Duplex → Half to put the DT-1 into a mode where you will see each
character you type.  If you&#39;re feeling really adventurous type
<tt>&lt;ESC&gt;G2Blinking&lt;ESC&gt;G0text</tt> to see some blinking text.

</p><p>
trs80gp&#39;s DT-1 emulation is missing a few features of the original.  There&#39;s
no way to attach a printer, not all input keycodes can be generated, there&#39;s
no half-intensity text mode and no beep.  If you have a real DT-1 please get
in touch as a few tests could go along way to implementing the missing features.

</p><h3><a name="videotex">TRS-80 Videotex</a></h3><a name="videotex">

The TRS-80 Videotex terminal was an early foray into online information
access.  It had a 300 baud modem allowing it 
to get the latest news and information.
The built-in software is very minimal and trs80gp itself hasn&#39;t been
polished enough yet to help round off the rough edges.

<p>
The Videotex could run in offline mode.  It lets you enter pages of text
and it was possible to later upload that data to an online service.
To experience this, run <tt>trs80gp -mv</tt> or use
File → Change Model → Videotex.  Press almost any key
(except backspace) and you&#39;ll be entering text in the offline mode.
Take time to be amazed that it word-wraps text as you type.

</p><p>
If you press backspace (which is a physical mapping of the BREAK key;
sorry about that) it will then prompt you with &#34;PLACE CALL&#34;.  On the
real machine you&#39;d pick up your phone, dial the information service.
When in answered you&#39;d put the phone down and press ENTER to let it
know you&#39;re connected.  

</p></a><p><a name="videotex">
When you hung up the phone (or the server hung up) the terminal will
print <tt>OFF LINE</tt> indicating this.  There was also an LED, I gather.
There must be some way to proceed from this point but either I don&#39;t
know what it is or trs80gp doesn&#39;t quite emulate it yet.  You can reset
the emulator if necessary.

<pp>
You can use another terminal to act as the online service.  See the
</pp></a><a href="#serial">Serial</a> section for general information on how
to virtually hook up two trs80gp emulators.  Here&#39;s a quick rundown
of how to see it in action.

</p><ol>
<li>Start a Videotex with a DT-1 attached: <tt>trs80gp -mv -r :dt1</tt>
(or select &#34;DT-1 Data Terminal&#34; from the dropdown in the Serial port
dialog box).
</li><li>Press backspace on the Videotex to see the &#34;PLACE CALL&#34; prompt.
</li><li>Wait a second or two.
</li><li>Press Enter on the Videotex.
</li><li>Typing in the Videotex should now cause characters to appear on
the DT-1 side and vice-versa.
</li><li>Not really a step, but you can use paste on either one as another
way to enter text.
</li><li>Close the DT-1 window and see the Videotex say &#34;OFF LINE&#34;.
</li></ol><p>

You may find the 
<a href="https://colorcomputerarchive.com/repo/Documents/Manuals/Hardware/#U">
Videotex manual and technical documentation</a> helpful.  It does support
a monochrome 128 x 96 graphics mode.  And there was even a way to download
6809 code.  At which point the built-in 6809 debugger may see some use.


</p><h3><a name="ec">Electric Crayon</a></h3><p>

The Electric Crayon is an external device that provides a colour video
display.  It can work with practically any computer as it connects via
the printer port.  It was primarily targeted at Model 1 and 3 users
as the machines did not have a colour display nor high resolution graphics.

</p><p>
You may attach an emulated Electric Crayon to trs80gp by using
<tt>-p :ec</tt> on the command line or bringing up the
Printer → Connection... dialog box and choosing &#34;Electric Crayon&#34;
from the dropdown.  In either case a new instance of trs80gp will
run acting as an Electric Crayon emulator.  When launched this way
the Electric Crayon emulator will go away when you quit the main
trs80gp program.

</p><p>
Even with an Electric Crayon attached trs80gp still records the
output to the printer in the normal window.  This can be very handy
to capture a drawing or debug a program using the Electric Crayon.

</p><p>
You can also just run a standalone Electric Crayon emulation via
<tt>trs80gp -mec</tt> and hook it to
another trs80gp emulator using the <tt>-p</tt> command line options
to map TCP/IP connections to the printer port.  The <a href="#print">Printer</a>
section gives some more details on how to do that.

</p><p>
Although the owner had no direct control over the real Electric Crayon, trs80gp
supports pasting text to its command processor.  Thus even run standalone
you can draw using the usual paste methods: Edit → Paste, the
input macros or <tt>-i</tt> on the command line.  For example:

</p><center>
<pre>       trs80gp -mec -i &#34;A 10 4 HELLO WORLD\r&#34;
</pre>
</center>

<p>
Not many programs were written for the Electric Crayon.  Here&#39;s quick overview
of the available commands so you can write some yourself.  You can get more
detail from the January 1981 issue of 80 Microcomputer.  However, don&#39;t miss
out on the fun of playing with the commands and figuring it out yourself.

</p><center>
<table>
<tbody><tr><th>Command</th><th></th><th>Operation</th>
</tr><tr><td><tt>A x y string</tt></td>
	<td>   </td>
	<td>Display text string.</td></tr>
<tr><td><tt>C n</tt></td>
	<td>   </td>
	<td>Select colour.</td></tr>
<tr><td><tt>ERS</tt></td>
	<td>   </td>
	<td>Erase display.</td></tr>
<tr><td><tt>H x y len</tt></td>
	<td>   </td>
	<td>Draw horizontal line.</td></tr>
<tr><td><tt>M n</tt></td>
	<td>   </td>
	<td>Change graphics mode.</td></tr>
<tr><td><tt>I</tt></td>
	<td>   </td>
	<td>Invert. (swap between the two palettes)</td></tr>
<tr><td><tt>LD*</tt></td>
	<td>   </td>
	<td>Load data or code in S record format.</td></tr>
<tr><td><tt>P n</tt></td>
	<td>   </td>
	<td>Set semigraphics value written when drawing.</td></tr>
<tr><td><tt>R x y string</tt></td>
	<td>   </td>
	<td>Display string in reversed colours.</td></tr>
<tr><td><tt>S x y</tt></td>
	<td>   </td>
	<td>Set pixel (or P pattern if in semigraphics)</td></tr>
<tr><td><tt>V x y len</tt></td>
	<td>   </td>
	<td>Draw vertical line.</td></tr>
</tbody></table>

</center>

<pre>    Graphics Modes:

    0	alphanumerics and semigraphics-4
    1	2 x 3 semigraphics-6
    2	 64 x  64 x 4 graphics
    3	128 x  64 x 2 graphics
    4	128 x  64 x 4 graphics
    5	128 x  96 x 2 graphics
    6	128 x  96 x 4 graphics
    7	128 x 192 x 2 graphics
    8	128 x 192 x 4 graphics
    9	256 x 192 x 2 graphics
</pre>

<p>
The Electric Crayon&#39;s 6800 CPU is fullly emulated.  There&#39;s a debugger
and most of the usual trs80gp programming features.

</p><h3><a name="linux">Linux Notes</a></h3><p>

Version 2.4 was the first wide release of the Linux version of trs80gp.
It has had several releases since there but likely has a small user base.
Please get in touch if you run into problems.

</p><p>
Per-user preferences are stored in
<tt>$XDG_CONFIG_HOME/.config/trs80gp/prefs.ini</tt> if the
<tt>XDG_CONFIG_HOME</tt> environment variable
is set and not empty.  Otherwise <tt>$HOME/.config/trs80gp/prefs.ini</tt> is
used if the <tt>HOME</tt> environment variable is set.  If not, then
no preferences will be saved.

</p><h3><a name="mac">MacOS Notes</a></h3><p>

Some trs80gp features are only available through the command line.  The
easiest way to run from the command line is use the </p><tt>open</tt><p> command.
For example, here is how to start trs80gp in Model I mode with the PCG-80
programmable character graphics generator enabled:

</p><pre>    open trs80gp.app --args -m1 -pcg-80
</pre><p>

You can run the executable directly which may be preferable in some cases.
Just use the path to it inside the trs80gp.app directory.  Here&#39;s how to
start a Model II in turbo mode:

</p><pre>    trs80gp.app/Contents/MacOS/trs80gp -m2 -turbo
</pre>

<h3>The End</h3><p>

Pretty much anything else depends on knowing how to operate a TRS-80 or
program a Z-80.  While it surely would be good to provide links to
documentation I&#39;ll just leave you with your prior knowledge and good
hunting in your web searches.

</p><hr/><p><em>George Phillips, October 8, 2022.  george -at- 48k.ca</em>

</p></div></div>
  </body>
</html>
