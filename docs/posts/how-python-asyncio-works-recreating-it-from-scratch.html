<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jacobpadilla.com/articles/recreating-asyncio">Original</a>
    <h1>How Python asyncio works: recreating it from scratch</h1>
    
    <div id="readability-page-1" class="page"><div id="main-content">
<!-- 🌟 START OF MAIN CONTENT 🌟 -->
<p>Right now, asyncio is one of the trendier topics in Python, and rightfully so – It’s a great way to handle I/O-bound programs! When I was learning about asyncio, It took me a while to understand how it actually worked. But later, I came to find out that it’s basically just a really nice layer on top of Python Generators. In this article, I’m going to create a simplified version of asyncio using just Python generators. Then, I’m going to refactor the example to use the <code>async</code> and <code>await</code> keywords with the help of the <code>__await__</code> dunder method before coming full circle and swapping out my version for the real asyncio. By building a simple version of asyncio, hopefully, by the end of this article, you’ll be able to get a better grasp of how it does its magic!</p>



    <p>If you&#39;re already familiar with generators skip this part, but if you aren&#39;t, it&#39;s what asyncio is built off of, so it&#39;s very important to understand how they work.</p>
    <p>First of all, the reason why generators are a thing is because they allow you to make your code more memory efficient. Imagine if you had the following loop:</p>

    <pre><code>for i in range(100_000_000):
    print(i)</code></pre>

    <p>If <code>range</code> wasn&#39;t a generator, but rather was a function that returned a list for you to then loop over, code like the example above would be very memory inefficient since you would be creating a list with 100 million elements… However, because <code>range</code> is a generator, at least in Python 3+, you only generate the numbers as they are needed, one by one, without ever storing the entire sequence in memory.</p>
    <p>There are a few ways to create generators, but we&#39;re going to focus on generator functions. These generators are defined like any other function but use the <code>yield</code> statement to return data. This statement turns a regular function into a generator that, instead of executing all at once, can pause and resume its state when calling <code>next(iterator)</code>.</p>
    <p>Take the following generator function, for example:</p>

    <pre><code>def generator():
   yield &#39;hello&#39;
   yield &#39;world&#39;

iterator = generator()</code></pre>

    <p>When you call the generator, instead of running the code inside of the function like Python normally would, it sees the <code>yield</code> keyword and, therefore, returns a generator object. Once we have the generator object, we can then call <code>next(iterator)</code>, which will run the function’s code up until the first/next <code>yield</code> statement:</p>

    <pre><code>print(next(iterator))  # Output: hello
print(next(iterator))  # Output: world</code></pre>

    <p>If we try calling <code>next(iterator)</code> again, the generator will raise a <code>StopIteration</code> exception because there are no more yield statements in the generator function.</p>
    <p>Another cool feature of Python generators is <code>yield from</code>, which lets a generator call a sub-generator or an iterable object, enabling you to create a chain of generators!</p>

    <pre><code>def generator():
   yield &#39;hello&#39;

def another_generator():
   yield from generator()

iterable = another_generator()
print(next(iterable))  # Output: hello</code></pre>

    <p>There’s a bit more to generators than I’m talking about, such as generator comprehensions, which are like list comprehensions but created with parentheses instead of brackets, and the ability to send data to generators with <code>iterator.send(value)</code>. However, for this article, the important thing to remember about generators is that they allow a function to be started and stopped while maintaining its state!</p>



    <p>The event loop, which is in charge of running and managing all of the current tasks, is the core of asyncio and is the first thing we’ll recreate with generators. While the asyncio event loop is written in C, an easy way to think about it is as a list that holds all of the current tasks. For now, think of these tasks as just generator objects. The event loop manager will loop through each task in the list and use the <code>next(task)</code> function to run each of them. That task will then run, and when it&#39;s doing I/O-bound work like sleeping, it’ll use the <code>yield</code> keyword to pause its execution and give control back to this event loop, which will then go on to the next task in the loop.</p>
    <p>Here’s an example of that — we have two tasks that both print their task number and then yield, which stops their execution. Since the event loop manager is the one that calls <code>next()</code>, after the task yields, it gets back control and then goes to run the next task in the loop.</p>

    <pre><code>def task1():
   while True:
       print(&#39;Task 1&#39;)
       yield

def task2():
   while True:
       print(&#39;Task 2&#39;)
       yield

event_loop = [task1(), task2()]

while True:
   for task in event_loop:
       next(task)</code></pre>

    <p>Subsequently, the output of this code is going to look like the following and will go on forever since both of the generator functions never finish due to the <code>while True</code> loops.</p>

    <pre><code>Task 1
Task 2
Task 1
Task 2
…</code></pre>




    <p>If we take the same code from above, we can add sub-generators to our tasks via the use of <code>yield from</code>. Below, I added a sleeping generator which will pause the execution of the tasks until the specified time is up. This works because <code>sleep</code> will keep yielding until a certain amount of seconds has passed, at which point it will leave the <code>while</code> loop. Since there are no more <code>yield</code> statements in <code>sleep</code>, a <code>StopIteration</code> exception is raised which signals to the <code>yield from</code> in the task functions to continue to the next line of code.</p>

    <pre><code>import time

def sleep(seconds):
   start_time = time.time()
   while time.time() - start_time &lt; seconds:
       yield

def task1():
   while True:
       print(&#39;Task 1&#39;)
       yield from sleep(1)

def task2():
   while True:
       print(&#39;Task 2&#39;)
       yield from sleep(5)

event_loop = [task1(), task2()]

while True:
   for task in event_loop:
       next(task)</code></pre>

    <p>Output:</p>

    <pre><code>Task 1
Task 2
Task 1
Task 1
Task 1
Task 1
Task 2
Task 1
…</code></pre>




    <p>We can now take the above code, and transition from using <code>yield</code> to <code>await</code> by using the <code>__await__</code> dunder method and the <code>async</code> keyword. When a class has the <code>__await__</code> method, we can use the <code>await</code> keyword in front of an instance of the class to call it. In asyncio, you are generally working with <code>Task</code> objects via a function like <code>asyncio.create_task</code>. These <code>Task</code> objects inherit from the asyncio <code>Future</code> object, which has the <code>__await__</code>  method. We can also use <code>await</code> in front of a coroutine, which is an object created when calling a function with the <code>async</code> keyword in front of it. Coroutines are similar to generator functions in the sense that a coroutine’s execution can also be paused and resumed.</p>
    <p>You can think of the <code>await</code> keyword as just a synonym for <code>yield from</code> with some extra validation rules. So, when writing the code <code>await object</code>, you are basically saying to either yield from the <code>__await__</code> method in the “object” class instance OR “object” could be another coroutine (like a sub-generator).</p>
    <p>You can actually look in the Asyncio <a href="https://github.com/python/cpython/blob/main/Lib/asyncio/futures.py" target="_blank">source code</a> and see that the <code>__await__</code> method inside of the <code>Future</code> object basically just calls <code>yield</code> if the future (or task) is not done completing:</p>

    <!-- 🌟 END OF MAIN CONTENT 🌟 -->
</div></div>
  </body>
</html>
