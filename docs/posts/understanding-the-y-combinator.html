<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://8dcc.github.io/programming/understanding-y-combinator.html">Original</a>
    <h1>Understanding the Y Combinator</h1>
    
    <div id="readability-page-1" class="page"><div id="content">

<p>
<a href="https://8dcc.github.io/index.html">Index</a> | <a href="https://8dcc.github.io/programming/index.html">Up</a>
</p>

<hr/>



<div id="outline-container-quick-introduction-to-lambda-calculus">
<h2 id="quick-introduction-to-lambda-calculus"><span>1.</span> Quick introduction to lambda calculus</h2>
<p>
<b>Lambda calculus</b> (λ-calculus) is a mathematical system for computation
based on <b>function abstraction</b> and <b>application</b>, using <b>variable binding</b> and
substitution.<sup><a id="fnr.1" href="#fn.1" role="doc-backlink">1</a></sup>
</p>

<div id="outline-container-rules">
<h3 id="rules"><span>1.1.</span> Rules</h3>
<div id="text-rules">
<p>
The beauty of lambda calculus is its simplicity. These are the only 3 rules:
</p>

<ol>
<li>\(x\): A <b>variable</b> represents a parameter.</li>
<li>\((\lambda x. M)\): A <b>lambda abstraction</b> is an anonymous function, with a
parameter \(x\) (between the λ and the dot), that returns the body \(M\).</li>
<li>\((M\ N)\): An <b>application</b> of function \(M\) to an argument \(N\).</li>
</ol>

<p>
In the last rule, both \(M\) and \(N\) are lambda terms.
</p>
</div>
</div>

<div id="outline-container-lambda-terms">
<h3 id="lambda-terms"><span>1.2.</span> Lambda terms</h3>
<div id="text-lambda-terms">
<p>
A <b>lambda term</b> is just a valid expression in the lambda calculus system. Well,
what makes an expression valid? The following 3 rules are used to determine if a
lambda expression is valid:
</p>

<ol>
<li>A <b>variable</b> \(x\) is itself a valid lambda term.</li>
<li>If \(M\) is a lambda term, and \(x\) is a variable, then \((\lambda x. M)\) is also
a lambda term (An <b>abstraction</b>).</li>
<li>If \(M\) and \(N\) are lambda terms, then \((M\ N)\) is also a lambda term (An
<b>application</b>).</li>
</ol>

<p>
You can begin to feel the recursive magic of lambda calculus, before even
getting into an example.
</p>
</div>
</div>

<div id="outline-container-reduction-operations">
<h3 id="reduction-operations"><span>1.3.</span> Reduction operations</h3>
<div id="text-reduction-operations">
<p>
Lambda calculus also has 2 main reduction operations:
</p>

<ol>
<li>\((\lambda x. M[x])\) → \((\lambda y. M[y])\): <b>Alpha conversion</b>
(α-conversion), renaming the bound variables in the expression. Used to
avoid name collisions.</li>
<li>\(((\lambda x. M) N)\) → \((M[x := N])\): <b>Beta reduction</b> (β-reduction),
replacing the bound variables (\(x\)) with the argument expression (\(N\)) in the
body (\(M\)) of the abstraction.</li>
</ol>

<p>
There is also <b>eta reduction</b> (η-reduction), which expresses the idea of
<i>extensionality</i>,<sup><a id="fnr.2" href="#fn.2" role="doc-backlink">2</a></sup> which applied to this context establishes that two
functions are the same if and only if they give the same result for all
arguments.
</p>

<p>
<a href="#implementation-in-scheme">Later</a> we will also mention the opposite of the beta reduction, the <b>beta
abstraction</b>, which instead of simplifying an expression, it adds an extra
function call that might be useful (e.g. in Lisps) for delaying the evaluation
of the arguments.
</p>
</div>
</div>

<div id="outline-container-notation">
<h3 id="notation"><span>1.4.</span> Notation</h3>
<div id="text-notation">
<p>
For understanding lambda notation, you will also have to keep in mind these
conventions:
</p>

<ol>
<li>Outermost parentheses are dropped: \(M N\) instead of \((M N)\).</li>
<li>Applications are assumed to be left associative: \(M N P\) instead of
\(((M N) P)\).</li>
<li>The body of an abstraction extends as far right as possible:
\((\lambda x. M N)\) means \((\lambda x. (M N))\) and not \(((\lambda x. M) N)\).</li>
<li>A sequence of abstractions is contracted:
\((\lambda x. \lambda y. \lambda z. N)\) is abbreviated as
\((\lambda x\ y\ z. N)\).</li>
<li>When all variables are single-letter, the space in applications may be
omitted: \((M N P)\) instead of \((M\ N\ P)\).</li>
</ol>

<p>
Some of these look a bit confusing to me, specially when embedding expressions
in text, so I will try to make each expression as readable as possible.
</p>
</div>
</div>
</div>

<div id="outline-container-sicp-lisp-and-javascript">
<h2 id="sicp-lisp-and-javascript"><span>2.</span> SICP, Lisp and JavaScript</h2>
<div id="text-sicp-lisp-and-javascript">
<p>
<a href="https://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Computer_Programs">Structure and Interpretation of Computer Programs</a> is an amazing book by Harold
Abelson and Gerald Jay Sussman. The book teaches the fundamental principles of
computer programming, including recursion, abstraction, modularity, and much
more. I recommend the book to anyone who is interested in programming, I am sure
they will learn something.
</p>

<p>
This book has two editions. The first one uses <a href="https://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a> (a dialect of <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a>), for
its examples and explanations, while the second uses <a href="https://en.wikipedia.org/wiki/JavaScript">JavaScript</a>. I have not
programmed much in JavaScript at the time of writing this, but I will try to
provide all examples in both lambda notation, Scheme and JavaScript.
</p>

<p>
At one point, in section 1.3.3, they talk about finding fixed points of
functions. This was the first time I heard about this, and it’s what mainly
motivated me to write this article. If you are interested on the general Lisp
approach, and not on the Y combinator itself, I recommend you check it out.
</p>

<p>
One of the most valuable things that SICP has taught me is that sometimes it’s
extremely useful to treat functions as black boxes that are able to transform
some inputs into some outputs. They call this <i>wishful thinking</i>, and it has been
useful not only when using functions, but also when designing them.
</p>
</div>
</div>

<div id="outline-container-simple-example-factorial">
<h2 id="simple-example-factorial"><span>3.</span> Simple example: Factorial</h2>
<div id="text-simple-example-factorial">
<p>
This is the function for calculating the factorial of a number \(n\), using the
lambda calculus notation:
</p>

<p>
\[
\text{fact} = \lambda n. \Big(\Big(\text{iszero}\ n\Big) 1 \Big(\text{mult}\ n
\ \big(\text{fact}\ (\text{prec}\ n)\big)\Big)\Big)
\]
</p>

<p>
In Scheme:
</p>

<div>
<pre><span>(</span><span>define</span> <span>fact</span>
  <span>(</span><span>lambda</span> <span>(</span>n<span>)</span>
    <span>(</span><span>if</span> <span>(</span>equal? n <span>0</span><span>)</span>
        <span>1</span>
        <span>(</span>mult n <span>(</span>fact <span>(</span>prec n<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
</pre>
</div>

<p>
Or in JavaScript:
</p>

<div>
<pre><span>var</span> <span>fact</span> = (n) =&gt; (n == <span>0</span>)
    ? <span>1</span>
    : mult(n, (fact(prec(n))));
</pre>
</div>

<p>
We are defining <code>fact</code> as a function that takes a parameter <code>n</code>. This function
returns 1 if <code>n</code> is zero, and otherwise multiplies <code>n</code> by the factorial of the
number preceding <code>n</code>.
</p>

<p>
In this case, we can simply ignore how <code>iszero</code>, <code>mult</code>, <code>prec</code> and even <code>fact</code> work
<i>internally</i>, we just have to trust that they do what we expect. Another useful
way of thinking about lambda calculus and Lisp in general is as a language for
expressing processes.
</p>

<p>
In any case, we don’t have those name-defining commodities in lambda calculus. A
function can’t call itself by name, so we will have to find an alternative way.
</p>
</div>
</div>

<div id="outline-container-simple-recursion-with-anonymous-functions">
<h2 id="simple-recursion-with-anonymous-functions"><span>4.</span> Simple recursion with anonymous functions</h2>
<div id="text-simple-recursion-with-anonymous-functions">
<p>
Before trying to understand the Y combinator, let’s have a look at an example of
how an anonymous function might call itself without the need for symbols.
</p>

<p>
\[
(\lambda x. x\ x)(\lambda x. x\ x)
\]
</p>

<p>
Or in Scheme:
</p>

<div>
<pre><span>(</span><span>(</span><span>lambda</span> <span>(</span>x<span>)</span> <span>(</span>x x<span>)</span><span>)</span>
 <span>(</span><span>lambda</span> <span>(</span>x<span>)</span> <span>(</span>x x<span>)</span><span>)</span><span>)</span>
</pre>
</div>

<blockquote>
<p>
<b>Note:</b> Depending on the Lisp, you might need to use <code>(funcall x x)</code> instead of
<code>(x x)</code>, since variables and functions don’t share the same namespace. You can
search about the differences between Lisp-1 and Lisp-2.
</p>
</blockquote>

<p>
Or in JavaScript:
</p>

<div>
<pre>((x) =&gt; x(x))((x) =&gt; x(x))
</pre>
</div>

<p>
We can see that the two parenthesized expressions are identical, and that the
first is applied to the second one. Let’s try to simplify it by
β-reduction. The first parenthesized expression, is applied to the second
one. We replace each occurrence of \(x\) in the body of the first expression with
the whole second parenthesized expression.
</p>


<p><img src="https://8dcc.github.io/img/ycombinator1.png" alt="ycombinator1.png"/>
</p>

<p>
We are right back where we started. This function would call itself
indefinitely, and a similar form will be used for the Y combinator bellow.
</p>
</div>
</div>

<div id="outline-container-fixed-points">
<h2 id="fixed-points"><span>5.</span> Fixed points</h2>
<div id="text-fixed-points">
<p>
Before getting into the fixed-point combinators, we need to define what a fixed
point is.
</p>

<p>
A fixed point of function \(f\) is a value that is mapped to itself by the
function.<sup><a id="fnr.3" href="#fn.3" role="doc-backlink">3</a></sup> In other words, \(x\) is a fixed point of \(f\) if \(f(x) = x\). For
this to be possible, \(x\) has to belong to both the <i>domain</i> of \(f\) (set of values
that it can take), and the <i>codomain</i> of \(f\) (set of values that it can return).
</p>

<p>
For example, if \(f(x) = x!\), 1 and 2 are fixed points, since \(f(1) = 1\) and
\(f(2) = 2\).
</p>


<p><img src="https://8dcc.github.io/img/ycombinator2.png" alt="ycombinator2.png" width="250px"/>
</p>

<p>
The image shows the graph of a function \(f\), with 3 fixed points. When plotting
with \(y = f(x)\), these 3 points were also on the line \(x = y\).
</p>

<p>
For example, for some functions \(f\), we can locate a fixed point by beginning
with an initial guess and applying \(f\) repeatedly.
</p>

<p>
\[
f(x),\quad f(f(x)),\quad f(f(f(x))),\quad \dots,
\]
</p>

<p>
We would do that until the value doesn’t change very much, and we are satisfied
with the result.
</p>
</div>
</div>

<div id="outline-container-fixed-point-combinators">
<h2 id="fixed-point-combinators"><span>6.</span> Fixed-point combinators</h2>
<div id="text-fixed-point-combinators">
<p>
A <b>fixed-point combinator</b> is a higher-order function (i.e. a function that takes
a function as argument) that returns some fixed point of its argument
function.<sup><a id="fnr.4" href="#fn.4" role="doc-backlink">4</a></sup>
</p>

<p>
So, if a function <code>fix</code> is a fixed-point combinator, a function <code>f</code> has one or
more fixed points, then <code>fix(f)</code> is one of these fixed points:
</p>

<p>
\[
f(\text{fix}\ f) = \text{fix}\ f
\]
</p>

<p>
In lambda calculus, every function has a fixed point.
</p>
</div>
</div>

<div id="outline-container-y-combinator">
<h2 id="y-combinator"><span>7.</span> Y combinator</h2>
<div id="text-y-combinator">
<p>
An example of a fixed-point combinator is the Y combinator. This is the
definition of \(Y\).
</p>

<p>
\[
Y = \lambda f. \big(\lambda x. f (x\ x)\big) \big(\lambda x. f (x\ x)\big)
\]
</p>

<p>
Or in Scheme:
</p>

<div>
<pre><span>(</span><span>define</span> <span>Y</span>
  <span>(</span><span>lambda</span> <span>(</span>f<span>)</span>
    <span>(</span><span>(</span><span>lambda</span> <span>(</span>x<span>)</span> <span>(</span>f <span>(</span>x x<span>)</span><span>)</span><span>)</span>
     <span>(</span><span>lambda</span> <span>(</span>x<span>)</span> <span>(</span>f <span>(</span>x x<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
</pre>
</div>

<blockquote>
<p>
<b>Note:</b> This version is not accurate, see <a href="#implementation-in-scheme">Implementation in Scheme</a> bellow.
</p>
</blockquote>

<p>
Or in JavaScript:
</p>

<div>
<pre><span>var</span> <span>Y</span> = (f) =&gt;
    ((x) =&gt; f(x(x)))(
     (x) =&gt; f(x(x)));
</pre>
</div>

<p>
Since it’s a fixed-point combinator, calling \(Y\) with a function as its
argument would be reduced to \(Y\ f = f(Y\ f)\). This is a very interesting and
useful concept, and it’s where this image comes from.
</p>


<p><img src="https://8dcc.github.io/img/ycombinator3.png" alt="ycombinator3.png" width="250px"/>
</p>

<p>
Let’s try to understand what it does, and why it’s a fixed-point combinator. We
are saying that \(Y\) is a function that takes one parameter \(f\). The body
consists of the same lambda term applied to itself: \((\lambda x. f(x\ x))\). You
may realize why we explained how to do <a href="#simple-recursion-with-anonymous-functions">recursion with anonymous functions</a>
earlier. A similar principle applies here, but we are also calling the \(f\)
function.
</p>

<p>
Let’s simplify it with β-reduction step by step:
</p><p>

\begin{align*}
Y\ g &amp;= \lambda f. \big(\lambda x. f (x\ x)\big) \big(\lambda x. f (x\ x)\big) g
        &amp;&amp; \text{By definition of } Y \\
     &amp;= \big(\lambda x. g (x\ x)\big) \big(\lambda x. g (x\ x)\big)
        &amp;&amp; \text{By beta reduction: Replacing } f \text{ of } Y \text{ with } g \\
     &amp;= g \Big(\big(\lambda x. g (x\ x)\big) \big(\lambda x. g (x\ x)\big)\Big)
        &amp;&amp; \text{By beta reduction: Replacing } x \text{ of the first function with } \big(\lambda x. g (x\ x)\big) \\
     &amp;= g (Y\ g)
        &amp;&amp; \text{By equality}
\end{align*}

</p><p>
Note how the reduction on the third step is applying \(g\) to the same expression
in the second step, which we know is equal to \(Y\ g\). That’s how we can verify
that \(Y\ g = g(Y\ g)\).
</p>

<p>
An alternative (and slightly simpler) version of the Y combinator is the
following:
</p>

<p>
\[
X = \lambda f. (\lambda x. x\ x) (\lambda x. f(x\ x))
\]
</p>

<p>
Notice how the first call to \(f\) was not necessary, since this expression also
β-evaluates to the Y combinator.
</p>
</div>
</div>

<div id="outline-container-applications-of-the-y-combinator">
<h2 id="applications-of-the-y-combinator"><span>8.</span> Applications of the Y combinator</h2>
<div id="text-applications-of-the-y-combinator">
<p>
You might be wondering what makes the Y combinator so special. As we said,
lambda calculus doesn’t have any kind of “global symbols”, therefore a function
can’t reference itself by name. Let’s go back to the factorial example in
Scheme.
</p>

<div>
<pre><span>(</span><span>define</span> <span>fact</span>
  <span>(</span><span>lambda</span> <span>(</span>n<span>)</span>
    <span>(</span><span>if</span> <span>(</span>equal? n <span>0</span><span>)</span>
        <span>1</span>
        <span>(</span>* n <span>(</span>fact <span>(</span>- n <span>1</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
</pre>
</div>

<p>
This recursive form is possible because the <code>fact</code> function can reference itself
by name. More specifically, because a lambda body is evaluated whenever a <i>call</i>
is made, and by that time the <code>fact</code> symbol is already bound to the lambda, and
therefore the body can reference it. In OCaml, for example, the <code>rec</code> keyword is
needed when defining a recursive function to denote that it will reference
itself, and not an external function with the same name.
</p>

<p>
The Y combinator allows us to call a function recursively in a language that
<i>doesn’t implement recursion</i>. Let’s have a look at an alternative form of <code>fact</code>.
</p>

<div>
<pre><span>(</span><span>define</span> <span>fact-generator</span>
  <span>(</span><span>lambda</span> <span>(</span>self<span>)</span>        <span>; </span><span>Outer lambda (fact-generator)</span>
    <span>(</span><span>lambda</span> <span>(</span>n<span>)</span>         <span>; </span><span>Inner lambda (returned by fact-generator)</span>
      <span>(</span><span>if</span> <span>(</span>equal? n <span>0</span><span>)</span>
          <span>1</span>
          <span>(</span>* n <span>(</span>self <span>(</span>- n <span>1</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
</pre>
</div>

<p>
Let’s carefully look at what we just defined. We are defining <code>fact-generator</code> as
the outer lambda, a function with one argument <code>self</code>. This function <i>does not</i>
return the factorial of a number, but instead returns another <i>another lambda
function</i> that will receive a number <code>n</code>, and return its factorial.
</p>

<p>
This inner lambda, the one that will be returned when calling <code>fact-generator</code>, is
essentially the same as our previous <code>fact</code> function, but this time it’s able to
use recursion <i>without</i> referencing itself by name by accessing the <code>self</code> parameter
of the outer lambda.
</p>

<p>
The important detail is that <code>fact-generator</code> is supposed to <i>return</i> a factorial
function, but also expects to <i>receive</i> a factorial function as its <code>self</code>
parameter, which will be used whenever the inner lambda wants to make a
“recursive” call. How could we accomplish this? At first sight, we could try
something like this.
</p>

<div>
<pre><span>;; </span><span>Wrong.</span>
<span>(</span><span>define</span> <span>fact</span>
  <span>(</span>fact-generator fact<span>)</span><span>)</span>
</pre>
</div>

<p>
The code above is incorrect because of how Scheme evaluates the arguments. When
evaluating the <code>define</code> expression, it will first try to evaluate the call to
<code>fact-generator</code>, but before that it must evaluate its argument, the <code>fact</code>
symbol. Since at this point <code>fact</code> isn’t defined (we are trying to do just that),
Scheme will show an “Unbound variable” error.
</p>

<p>
Since the <code>fact-generator</code> function expects a function for calculating the
factorial, but also returns one, we are looking for something like:
</p>

<div>
<pre><span>(</span><span>define</span> <span>fact</span>
  <span>(</span>fact-generator <span>(</span>fact-generator <span>(</span>fact-generator ...<span>)</span><span>)</span><span>)</span><span>)</span>
</pre>
</div>

<p>
Does that look familiar? Indeed, this is just what the Y combinator allows us to
do.
</p>
</div>
</div>

<div id="outline-container-implementation-in-scheme">
<h2 id="implementation-in-scheme"><span>9.</span> Implementation in Scheme</h2>
<p>
Our Scheme version of the Y combinator was not really correct. Evaluation in
Scheme (and most Lisps) is <i>strict</i>, meaning that each argument is evaluated
<i>before</i> applying the function. This is not a problem in lambda calculus.
</p>

<div id="outline-container-beta-abstraction-in-scheme">
<h3 id="beta-abstraction-in-scheme"><span>9.1.</span> Delaying evaluation with beta abstraction</h3>
<div id="text-beta-abstraction-in-scheme">
<p>
Defining <code>Y</code> like we did before would result in infinite recursive calls when
trying to apply the <code>(x x)</code> expressions. This will be more obvious when analyzing
the combinator bellow, so let’s look at a possible solution first. We can fix
our Y combinator by <b>beta abstracting</b><sup><a id="fnr.5" href="#fn.5" role="doc-backlink">5</a></sup> those two applications.
</p>

<blockquote>
<p>
<b>JAO’s blog about the Y-combinator in Scheme (2014)</b>
</p>

<p>
If you have a function <code>F</code> in Scheme, you can define a totally equivalent function
<code>G</code> by <code>(define G (lambda (args) (F args)))</code>. We say that <code>G</code> is a <i>beta abstraction</i> of
<code>F</code>, or that <code>F</code> is a <i>beta reduction</i> of <code>G</code>.
</p>

<p>
The usual reason you would beta abstract a function in Scheme is in order to
delay the evaluation of its body, just what the doctor ordered.
</p>
</blockquote>

<p>
We can add this beta abstraction to the <code>(x x)</code> applications, effectively acting
as a “proxy”.
</p>

<div>
<pre><span>(</span><span>define</span> <span>Y</span>
  <span>(</span><span>lambda</span> <span>(</span>f<span>)</span>
    <span>(</span><span>(</span><span>lambda</span> <span>(</span>x<span>)</span> <span>(</span>f <span>(</span><span>lambda</span> <span>(</span>n<span>)</span> <span>(</span><span>(</span>x x<span>)</span> n<span>)</span><span>)</span><span>)</span><span>)</span>
     <span>(</span><span>lambda</span> <span>(</span>x<span>)</span> <span>(</span>f <span>(</span><span>lambda</span> <span>(</span>n<span>)</span> <span>(</span><span>(</span>x x<span>)</span> n<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
</pre>
</div>

<p>
Now, since the <code>(x x)</code> expression is inside the body of this “proxy” lambda, it
will not be evaluated until the proxy is called. This is not easy to understand,
so so let’s try to visualize the evaluation process of a call to our <code>Y</code> function.
</p>
</div>
</div>

<div id="outline-container-evaluation-process-of-our-y-combinator">
<h3 id="evaluation-process-of-our-y-combinator"><span>9.2.</span> Evaluation process of our Y combinator</h3>
<div id="text-evaluation-process-of-our-y-combinator">
<p>
The following diagram represents the evaluation of a call to our <code>Y</code>
function. Specifically, applying the first inner lambda to its copy. Note that
this isn’t the actual process that a Scheme interpreter would follow, instead I
have decided to make some changes to make it easier to understand.
</p>


<p><img src="https://8dcc.github.io/img/ycombinator4.svg" alt="ycombinator4.svg"/>
</p>

<p>
Let me explain briefly each step of the diagram.
</p>

<ol>
<li>The black lambda receives a copy of itself (gray lambda) as the argument
<code>x</code>. We have seen this <a href="#simple-recursion-with-anonymous-functions">above</a> with the \((\lambda x. x\ x)(\lambda x. x\ x)\)
expression.</li>
<li>With some <i>wishful thinking™</i>, since we know that <code>x</code> is a copy of the current
expression, we can assume that the result of the green <code>(x x)</code> expression is
whatever the current black expression returns. For now, it’s better to assume
that the value returned when calling <code>x</code> is <code>fact</code>, since this will be explained
in more detail below.</li>
<li>The blue <code>(lambda (n) (fact n))</code> expression acts as a proxy, receiving some
arguments, in this case <code>n</code>, and calling <code>fact</code> with them. We name this simple
lambda <code>fact-proxy</code>, since calling it is essentially the same as calling <code>fact</code>.</li>
<li>We know that <code>f</code> is the function that has been passed to <code>Y</code>, in this case
<code>fact-generator</code>. We substitute it for readability, along with substituting
<code>fact-proxy</code> with just <code>fact</code>.</li>
<li>Finally, the expression <code>(fact-generator fact)</code> gets passed to another lambda,
or returned by <code>Y</code>, depending on whether or not we are the first call in the
recursive cycle.</li>
</ol>

<p>
At this point, although there are some parts that might not be very clear, we
can believe that <code>(Y fact-generator)</code> is the same as
<code>(fact-generator (fact-generator ...))</code>, which returns a recursive <code>fact</code>
function, even though <code>fact</code> has not been defined yet.
</p>

<p>
Now that we can see that the black expression effectively returns <code>fact</code>, you can
verify that the second point was true. The <code>(x x)</code> expression is calling <code>x</code> with a
copy of itself (the gray expression) as argument. That argument will be used for
looping recursively, as mentioned in point one. Therefore, the call to <code>x</code> returns
<code>fact</code>, and that’s why we were able to replace it on point two.
</p>

<p>
By wishful thinking, we know the <code>(x x)</code> call returns <code>fact</code>, but since evaluation
in Scheme is strict, it will try to evaluate the call to <code>x</code>, which also contains
another call to <code>x</code>, and so on. That’s what the <code>fact-proxy</code> is for.
</p>

<p>
With this example, you can also realize that the following expression makes more
sense now.
</p><p>

\begin{align*}
Y f &amp;= f (Y f) \\
    &amp;= f (f (f (\dots)))
\end{align*}

</p><p>
Which is just what we wanted to achieve earlier.
</p>

<div>
<pre><span>(</span><span>define</span> <span>fact</span>
  <span>(</span>fact-generator <span>(</span>fact-generator <span>(</span>fact-generator ...<span>)</span><span>)</span><span>)</span><span>)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-complete-scheme-example">
<h3 id="complete-scheme-example"><span>9.3.</span> Complete Scheme example</h3>
<div id="text-complete-scheme-example">
<p>
Finally, we can <a href="https://try.scheme.org/">try</a> our full example.
</p>

<div>
<pre><span>(</span><span>define</span> <span>Y</span>
  <span>(</span><span>lambda</span> <span>(</span>f<span>)</span>
    <span>(</span><span>(</span><span>lambda</span> <span>(</span>x<span>)</span> <span>(</span>f <span>(</span><span>lambda</span> <span>(</span>n<span>)</span> <span>(</span><span>(</span>x x<span>)</span> n<span>)</span><span>)</span><span>)</span><span>)</span>
     <span>(</span><span>lambda</span> <span>(</span>x<span>)</span> <span>(</span>f <span>(</span><span>lambda</span> <span>(</span>n<span>)</span> <span>(</span><span>(</span>x x<span>)</span> n<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>

<span>(</span><span>define</span> <span>fact-generator</span>
  <span>(</span><span>lambda</span> <span>(</span>self<span>)</span>
    <span>(</span><span>lambda</span> <span>(</span>n<span>)</span>
      <span>(</span><span>if</span> <span>(</span>equal? n <span>0</span><span>)</span>
          <span>1</span>
          <span>(</span>* n <span>(</span>self <span>(</span>- n <span>1</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>

<span>(</span><span>define</span> <span>fact</span>
  <span>(</span>Y fact-generator<span>)</span><span>)</span>

<span>(</span>fact <span>5</span><span>)</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-final-note">
<h2 id="final-note"><span>10.</span> Final note</h2>
<p>
If you reached this far, I hope you have learned something. Everything in this
article is based on what I found while trying to learn about the Y combinator,
so if you feel like some explanations could be improved, feel free to
<a href="https://8dcc.github.io/index.html#contributing">contribute</a>.
</p>
</div>
</div></div>
  </body>
</html>
