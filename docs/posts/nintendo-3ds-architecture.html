<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.copetti.org/writings/consoles/nintendo-3ds/">Original</a>
    <h1>Nintendo 3DS Architecture</h1>
    
    <div id="readability-page-1" class="page"><article><h2 id="imagery">Supporting imagery</h2><section><ul><li><a href="#cover-model">Model</a></li><li><a href="#cover-motherboard">Motherboard</a></li><li><a href="#cover-diagram">Diagram</a></li></ul><div><h3>Model</h3><figure id="cover-model"><a href="https://www.copetti.org/images/consoles/nintendo3ds/international.283e187450b432e5ca6f46f4bb6a495bdfc36f08cb2e1da082b020d6022d1f8e.png"><picture><source type="image/webp" srcset="https://www.copetti.org/images/consoles/nintendo3ds/_hud950cf4543f954b474f553674fc302a5_240147_da7038c582d606c66574ccd907cc6aac.webp 500w,
https://www.copetti.org/images/consoles/nintendo3ds/_hud950cf4543f954b474f553674fc302a5_240147_a8b4b2a43322fb984cdf1b2394d5a99e.webp 800w,
https://www.copetti.org/images/consoles/nintendo3ds/_hud950cf4543f954b474f553674fc302a5_240147_bc329dbcc83d74e2fc1cf5fae9dfa34e.webp 1000w"/><img alt="Image" width="1000" height="907" src="https://www.copetti.org/images/consoles/nintendo3ds/international.283e187450b432e5ca6f46f4bb6a495bdfc36f08cb2e1da082b020d6022d1f8e.png" loading="lazy"/></picture></a><figcaption>The Nintendo 3DS.</figcaption></figure><h3>Motherboard</h3><figure id="cover-motherboard"></figure><h3>Diagram</h3><figure id="cover-diagram"><a href="https://www.copetti.org/images/consoles/nintendo3ds/diagram.d93d958258e776a00cde4f9e8eeec3ce047e6663b95f89a21c2e2a1b06602e19.png"><picture><source type="image/webp" srcset="https://www.copetti.org/images/consoles/nintendo3ds/_hu05662e9582b538ada21b1313ba043bdc_267_1deea0cbeb048c9d25432b932e0a90ac.webp 500w,
https://www.copetti.org/images/consoles/nintendo3ds/_hu05662e9582b538ada21b1313ba043bdc_267_0a0e4694da7507b7b751ae0751b96e14.webp 800w,
https://www.copetti.org/images/consoles/nintendo3ds/_hu05662e9582b538ada21b1313ba043bdc_267_f2e085be44ab8638344cf183e0dd619f.webp 2252w"/><img alt="Image" width="2252" height="1021" src="https://www.copetti.org/images/consoles/nintendo3ds/diagram.d93d958258e776a00cde4f9e8eeec3ce047e6663b95f89a21c2e2a1b06602e19.png" loading="lazy"/></picture></a><figcaption>Main architecture diagram</figcaption></figure></div></section><hr/><h2 id="a-quick-introduction">A quick introduction</h2><p>As smartphones surge in adoption, the videogame market is experiencing an unusual growth led by discount App Stores and affordable development licenses. With this, one can only wonder when kids will prefer an iPhone 4 over a Nintendo DSi.</p><p>In the midst of finding out the answer, Nintendo conceives a thrilling successor to its triumphant portable system. In it, users will find old, present and unfamiliar technology - many of which can’t be replicated by smartphones.</p><p>And so, this new production of the Architecture of Consoles series will give you a profound description of how this new console works, both internally and externally.</p><h3 id="recommended-reading">Recommended reading</h3><p>If you are new to this <a href="https://www.copetti.org/writings/consoles/">article series</a>, I strongly suggest reading the <a href="https://www.copetti.org/writings/consoles/gamecube/">GameCube</a>, <a href="https://www.copetti.org/writings/consoles/game-boy-advance/">Game Boy Advance</a> and <a href="https://www.copetti.org/writings/consoles/nintendo-ds/">Nintendo DS</a> articles beforehand, as they will explain various terms and concepts referenced in this one.</p><hr/><h2 id="models-and-variants">Models and variants</h2><p>Throughout the lifecycle (and struggles) of this console, Nintendo released numerous revisions in an attempt to correct its target audience and recover loyal customers.</p><figure><a href="https://www.copetti.org/images/consoles/nintendo3ds/photos/side_n3ds.305bcbf7b0cd255a64549d2027f9f6478a7b9777009c85e229f6f93b4c025cc5.webp"><picture><img alt="Image" width="1111" height="506" src="https://www.copetti.org/images/consoles/nintendo3ds/photos/_huc15dcfe92f3446e20d07697c5f45f979_25336_2089e178d0cad5b37d8d0bc91ff41544.png" loading="lazy"/></picture></a><figcaption>An original Nintendo 3DS (the first generation, from 2011) next to a New Nintendo 3DS XL (the last generation, from 2015).</figcaption></figure><p>From the architectural point of view, there were a total of six different models:</p><ul><li><strong>Nintendo 3DS</strong> (2011) and <strong>Nintendo 3DS XL</strong> (2012): The debuting series featuring the original architecture. The only relevant difference between the XL and non-XL models is the screen size.</li><li><strong>Nintendo 2DS</strong> (2013): A cheaper alternative to the original Nintendo 3DS by removing the stereoscopic screen and featuring a <a href="https://www.copetti.org/writings/consoles/game-boy/">Game Boy</a>-inspired shape.</li><li><strong>New Nintendo 3DS</strong> (2014) and <strong>New Nintendo 3DS XL</strong> (2015): A re-engineering of the standard 3DS models. The ‘New’ variants exhibit an incremental hardware upgrade, an NFC reader, a larger button set and an improved stereoscopic system.</li><li><strong>New Nintendo 2DS XL</strong> (2017): The ‘New’ affordable alternative to the New Nintendo 3DS XL by omitting stereoscopic functionality.</li></ul><p>Now, for this article, the focus will be on the original Nintendo 3DS (after all, it’s the lowest common denominator for games). However, since the architectural differences of the ‘New’ series are worth studying, these will receive a dedicated section.</p><hr/><h2 id="displays">Displays</h2><p>There’s only one company that keeps altering the standard structure of all my analyses, and that’s Nintendo. This time, I’ll start with the <strong>stereoscopic screens</strong> (a.k.a. ‘3D without glasses’).</p><p>First things first, the Nintendo 3DS, as a successor of the Nintendo DS, includes two LCD screens. The upper screen has a resolution of <strong>800 x 240 pixels</strong> and somehow can display images with a sense of depth. When I first read this, only questions popped into my head:</p><ul><li>What optics principles are they applying?</li><li>How is the screen designed?</li><li>How do games comply with this system?</li></ul><p>Well, here are the answers!</p><h3 id="principles">Principles</h3><p>Liked or not, the fundamentals are not so different from the <a href="https://www.copetti.org/writings/consoles/virtual-boy/">Virtual Boy</a>, which I’ve happened to analyse two years before. To recall, the Virtual Boy displays two images, one to each eye, and shows objects individually shifted from the centre. By looking at the two pictures at the same time, they are perceived as some objects are behind others (sense of depth). This is the basis of <strong>Stereoscopic Parallax</strong>.</p><figure><ul><li id="tab-1-1-left-link"><a href="#tab-1-1-left">Left</a></li><li id="tab-1-2-right-link"><a href="#tab-1-2-right">Right</a></li></ul><figure id="tab-1-1-left"><a href="https://www.copetti.org/images/consoles/virtualboy/tennis/left.5650091c8dae2d51fd18a73a5bc37e22b6d001e54d8a18a1ade37e73b8b4d14e.png"><picture><img alt="Image" width="384" height="224" src="https://www.copetti.org/images/consoles/virtualboy/tennis/left.5650091c8dae2d51fd18a73a5bc37e22b6d001e54d8a18a1ade37e73b8b4d14e.png" loading="lazy"/></picture></a><figcaption>Left display.</figcaption></figure><figure id="tab-1-2-right"><a href="https://www.copetti.org/images/consoles/virtualboy/tennis/right.3df8c5ee7cf0e2b8b6acab7349b10cd3b4b33183427fd6a58e813228962928b6.png"><picture><img alt="Image" width="384" height="224" src="https://www.copetti.org/images/consoles/virtualboy/tennis/right.3df8c5ee7cf0e2b8b6acab7349b10cd3b4b33183427fd6a58e813228962928b6.png" loading="lazy"/></picture></a><figcaption>Right display.</figcaption></figure><figcaption>Demonstration of how the Virtual Boy displayed stereoscopic imagery.</figcaption></figure><p>Now, the way the Virtual Boy executed this was a bit cumbersome: it required users to place their heads close to the eyepiece and then adjust the focal length and inter-pupil distance. 15 years later, Nintendo rightly said ‘No’ to all of that nuisance, and designed a new system where users could enjoy 3D-looking scenery without <em>considerable</em> intervention.</p><figure><ul><li id="tab-2-1-left-link"><a href="#tab-2-1-left">Left</a></li><li id="tab-2-2-right-link"><a href="#tab-2-2-right">Right</a></li></ul><figure id="tab-2-1-left"><a href="https://www.copetti.org/images/consoles/nintendo3ds/stereoscopy/top_left.296143904d4490fa7e10203667d603c4588adf55f7b2dc0b15d6426bbbb31676.png"><picture><img alt="Image" width="400" height="240" src="https://www.copetti.org/images/consoles/nintendo3ds/stereoscopy/top_left.296143904d4490fa7e10203667d603c4588adf55f7b2dc0b15d6426bbbb31676.png" loading="lazy"/></picture></a><figcaption>Top screen, left eye.</figcaption></figure><figure id="tab-2-2-right"><a href="https://www.copetti.org/images/consoles/nintendo3ds/stereoscopy/top_right.7d50fe7647f1d01ef0f864286c9e8909fee1821a91fd840fd8eda93ca934b026.png"><picture><img alt="Image" width="400" height="240" src="https://www.copetti.org/images/consoles/nintendo3ds/stereoscopy/top_right.7d50fe7647f1d01ef0f864286c9e8909fee1821a91fd840fd8eda93ca934b026.png" loading="lazy"/></picture></a><figcaption>Top screen, right eye.</figcaption></figure><figcaption>An example of two frames the Nintendo 3DS shows on its top screen at the same time. Looks like the fish is going to hit you. The same principle applies 15 years later.</figcaption></figure><p>This brings us to our next question.</p><h3 id="the-special-screen">The special screen</h3><p>Take a look again at the resolution of the upper LCD screen. On paper, it says it’s <strong>800 x 240 pixels</strong> wide, which results in a ludicrous aspect ratio.</p><div><figure><a href="https://www.copetti.org/images/consoles/nintendo3ds/international.283e187450b432e5ca6f46f4bb6a495bdfc36f08cb2e1da082b020d6022d1f8e.png"><picture><source type="image/webp" srcset="https://www.copetti.org/images/consoles/nintendo3ds/_hud950cf4543f954b474f553674fc302a5_240147_da7038c582d606c66574ccd907cc6aac.webp 500w,
https://www.copetti.org/images/consoles/nintendo3ds/_hud950cf4543f954b474f553674fc302a5_240147_a8b4b2a43322fb984cdf1b2394d5a99e.webp 800w,
https://www.copetti.org/images/consoles/nintendo3ds/_hud950cf4543f954b474f553674fc302a5_240147_bc329dbcc83d74e2fc1cf5fae9dfa34e.webp 1000w"/><img alt="Image" width="1000" height="907" src="https://www.copetti.org/images/consoles/nintendo3ds/international.283e187450b432e5ca6f46f4bb6a495bdfc36f08cb2e1da082b020d6022d1f8e.png" loading="lazy"/></picture></a><figcaption>The Nintendo 3DS again <sup id="bibref:1"><a href="#bib:photography-amos" role="doc-biblioref">[1]</a></sup>, take a closer look at its screens.</figcaption></figure><p>In reality, the physical screen is made of <strong>half-width pixels</strong> and operates in two modes:</p><ul><li><strong>Traditional/2D mode</strong>: When the stereoscopic function is disabled, groups of two horizontal pixel pairs are treated as a single one.<ul><li>Truth be told, the screen can still display a frame of 800 x 240 px, although no commercial game ever used this.</li></ul></li><li><strong>Stereoscopic/3D mode</strong>: All pixels are treated individually, and with it, the screen displays <strong>two frames</strong> of <strong>400 x 240 pixels</strong> at the same time.</li></ul><p>Moreover, to perform stereoscopic parallax, this particular LCD houses an extra layer called <strong>Parallax Barrier</strong> <sup id="bibref:2"><a href="#bib:graphics-display_teardown" role="doc-biblioref">[2]</a></sup>. These opaque shutters deviate the backlight beamed behind the pixels of the LCD, so each eye will receive the light of a different subset of pixels <sup id="bibref:3"><a href="#bib:graphics-display_howworks" role="doc-biblioref">[3]</a></sup>. The half-width pixels will also appear to be wider, thereby giving the feeling they have the traditional aspect ratio.</p><p>All in all, this recreates the original effect of the Virtual Boy without requiring controls for adjustment.</p></div><p>The technology is not perfect, however, as there are a few caveats:</p><ul><li>The parallax barrier requires extra brightness, thereby impacting the battery life.</li><li>The user must not hold the screen in a tilted position (compared to the user’s eyes). Otherwise, the user will end up seeing a confusing mix of the two parallax frames, which can be a disorienting experience. Not to mention the eyes won’t enjoy the extra fatigue.</li><li>Combining the fact the user must maintain a fixed posture while playing, and that stereoscopic parallax can tire the eyes quicker. The 3D feature, as a whole, can be an unnecessary hassle for most.</li></ul><div><figure><a href="https://www.copetti.org/images/consoles/nintendo3ds/stereoscopy/tilt.a90f13873f8d4fb7e34e72734a026aa48c63063ed1cfdcb7be0259533b637534.webp"><picture><img alt="Image" width="1000" height="750" src="https://www.copetti.org/images/consoles/nintendo3ds/stereoscopy/_hu68de68eb39eeb5477ffb3e92dc8b5860_29218_11a22cc1e2532e946c972f3f59bcc0ba.png" loading="lazy"/></picture></a><figcaption>My attempt to capture the tilt effect of the original 3DS. The 3D depth slider (at the right side of the screen) is all the way up, and by looking at the screen from one side, a ghosting effect appears on the top screen. This is quite eye-straining to look at in reality!</figcaption></figure><p>To remediate things, Nintendo added a slider control (called <strong>3D depth slider</strong>) to adjust the level of depth between objects. In doing so, it either increases or decreases the difference between the two frames. This was done to reduce the depth effect for people who didn’t find it enjoyable or too fatiguing.</p><p>Setting the 3D slider to the max can be disorienting at first. In my experience, my eyes eventually got focused, at which point I perceived the top LCD screen as if I were looking through a window. The main problem is that users will need to continuously shift their eyes to see the bottom screen, and the repeated action can be very straining.</p></div><p>As a side note, one can’t help but find it amusing how the graphics pipeline has gone full circle when rendering stereoscopic frames. During rendering, 3D data is projected into a 2D space, and now with the stereoscopic screen, that 2D space is displayed again as 3D. At this point, let’s just use holograms and skip the 3D projection stage altogether.</p><h4 id="a-small-update">A small update</h4><figure><a href="https://www.copetti.org/images/consoles/nintendo3ds/stereoscopy/new3ds.1ab0c98b61b0946592b63bc6732fcf95f0b6c312e1ce7814df84ec2cb1a8470f.webp"><picture><img alt="Image" width="900" height="158" src="https://www.copetti.org/images/consoles/nintendo3ds/stereoscopy/_hu025c37239d25a6aa4098cc524d1fdd78_10338_753f29eb89554cf724e8ee8dd01456e8.png" loading="lazy"/></picture></a><figcaption>Top part of the New 3DS XL. At its centre, there’s a front camera and an infrared LED, both used for head tracking.</figcaption></figure><p>With the advent of the ‘New 3DS’ model, Nintendo revisioned their stereoscopic screen in an effort to reach enjoyability levels. In the new model, the console incorporates a face-tracking mechanism to tackle the tilting effect, so issues don’t need to worry about keeping a good head-console posture anymore.</p><h3 id="the-special-games">The special games</h3><p>Now for this system to work, games must play along (pun intended). Just like they traditionally interact with the GPU to draw frames on the display, they must now broadcast two frames of the scenery but with objects slightly shifted.</p><p>To make life easier for developers, there are official APIs that assist in this, especially for those games with 3D sceneries. These APIs help by providing routines that construct two projection matrices, the graphics pipeline then uses them to render the two slightly-shifted frames.</p><hr/><h2 id="cpu">CPU</h2><p>Now that we know how the display works, let’s look at the internals of this console. If you get a hold of the motherboard, you’ll see three big chips, one being the <strong>CPU CTR</strong>. That’s the big System-On-Chip (SoC) that houses the entire system (aside from storage and RAM).</p><figure><a href="https://www.copetti.org/images/consoles/nintendo3ds/cpu/cpu_photo.f1977dfae04cf532272eac2f256cafc4571f4bd76d90ba92e509f80065d69b41.webp"><picture><source type="image/webp" srcset="https://www.copetti.org/images/consoles/nintendo3ds/cpu/_hue122ea6f63ebb1e353dc850f3274175f_71838_7aff8078eb7c7ec1542a270f9f966adc.webp 500w,
https://www.copetti.org/images/consoles/nintendo3ds/cpu/_hue122ea6f63ebb1e353dc850f3274175f_71838_c5342c8a4cc85707ed9853e78e1d98bf.webp 800w,
https://www.copetti.org/images/consoles/nintendo3ds/cpu/_hue122ea6f63ebb1e353dc850f3274175f_71838_7bba4f72e3e2d7084e976dc626153693.webp 1000w"/><img alt="Image" width="1000" height="534" src="https://www.copetti.org/images/consoles/nintendo3ds/cpu/_hue122ea6f63ebb1e353dc850f3274175f_71838_eac66c08da1275ec4651225b62bc7d48.png" loading="lazy"/></picture></a><figcaption>CPU CTR next to some FCRAM</figcaption></figure><p>CPU CTR follows the design methods of previous portable consoles from Nintendo. That is, squash all your engineering into a single block. In doing so, it will reduce the production of counterfeits, protect sensible components and improve heat dissipation.</p><p>In terms of the actual CPU, Nintendo partnered again with their old friend, <strong>ARM</strong>, to produce their next-generation core. ARM’s licensing model happens to be favourable to Nintendo as they have always offered synthesisable designs, which allows Nintendo to mould to their needs (including, fitting them into a big SoC). In the end, ARM gave them a relatively antiquated with substantial upgrades. Their choice was the <strong>ARM11</strong> core, a successor of the ARM9 (featured with the <a href="https://www.copetti.org/writings/consoles/nintendo-ds/#cpu">Nintendo DS</a>). More specifically, the <strong>MPCore</strong> variant, ARM’s first <strong>homogenous multi-core</strong> solution.</p><p>Using ARM’s designs, Nintendo crafted an ARM11 MPCore cluster housing <strong>two</strong> ARM11 cores <sup id="bibref:4"><a href="#bib:cpu-lioncash" role="doc-biblioref">[4]</a></sup>. Three years later, with the arrival of the ‘New’ 3DS, the SoC was expanded to contain <strong>four</strong> ARM11 cores. The effects of this will be explained in due time so, before anything else, let’s analyse what the new CPU cores offered to this console.</p><h3 id="an-iconic-industry">An iconic industry</h3><p>The ARM11 series originates from 2002, as a successor of the popular ARM9 and the short-lived ARM10.</p><figure><a href="https://www.copetti.org/images/consoles/nintendo3ds/cpu/devices.b32e1b8964b560bbeed11ec8ae0e743efb6b9cf4163964bc086ba8aa1b804a5c.webp"><picture><img alt="Image" width="1000" height="384" src="https://www.copetti.org/images/consoles/nintendo3ds/cpu/_hucd71f9346efedab899883028b66e7ae5_21546_4af778c28e8044da94eb7237b76f5f62.png" loading="lazy"/></picture></a><figcaption>A Nokia 5230 (2009), a red 3DS (2011) and a Raspberry Pi Model B (2012), all carrying an ARM11.</figcaption></figure><p>In case you haven’t heard about them before, ARM11s are best known for powering the 2006-2008 generation of smartphones (back when many of them featured a keypad or a clamshell design). If you owned a Nokia N95, 5230 or the first iPhone, you’ve used an ARM11. This also applied to many high-end cameras, GPS or similar peripherals. If you wonder, other manufacturers like RIM and Samsung held onto Intel XScale (the continuation of <a href="https://www.copetti.org/writings/consoles/nintendo-ds/##tab-2-2-a-question-about-the-hardware-choice">StrongARM</a>, implementing the ARMv5TE instruction set) until 2009, when they made the switch to ARM11 (this is a bit ironic, considering the iPhone’s CPU was supplied by Samsung!). Last but not least, the ARM11 was the choice of the CPU for the first model of the Raspberry Pi.</p><p>Now, by the time Nintendo adopted the ARM11, its creator had already succeeded it with the Cortex-A series. This is nothing but expected, as Nintendo’s model favours cost-effectiveness over avant-garde CPUs. Look at it from another way, saving in CPU costs allows them to focus their budget on other aspects of the console, you’ll soon see.</p><h4 id="new-dialects">New dialects…</h4><p>Along with the new shiny CPUs, a new instruction set arrived, the <strong>ARMv6</strong>.</p><p>From a programmer’s perspective, the ARMv6 ISA innovates with a new set of vector instructions and multi-core support <sup id="bibref:5"><a href="#bib:cpu-thomas" role="doc-biblioref">[5]</a></sup>. The new vector set provides SIMD instructions that operate groups of <strong>four 8-bit values</strong> or <strong>two 16-bit values</strong> at the same time (using the existing 32-bit registers) <sup id="bibref:6"><a href="#bib:cpu-armcc" role="doc-biblioref">[6]</a></sup>. The new multi-core instructions consist of <code>Store</code> and <code>Load</code> opcodes with special care for synchronisation (crucial for an environment of multiple CPUs using the same memory locations) <sup id="bibref:7"><a href="#bib:cpu-sync" role="doc-biblioref">[7]</a></sup>.</p><p>All in all, this may not seem that thriving for a new chip series, but remember that ARM’s CPUs speak many ‘languages’. In the case of an ARM11-based core, you are provided with:</p><ul><li>The main 32-bit ISA, called <strong>ARMv6</strong>.</li><li>A compressed alternative called <strong>Thumb</strong>. Its instructions fit in 16-bit words instead. If you’d like to know more, I go over it in the <a href="https://www.copetti.org/writings/consoles/game-boy-advance/#whats-new">Game Boy Advance article</a>, as it weighs significant importance in that console.</li><li><strong>Jazelle</strong>, a Java bytecode interpreter, mostly forgotten and left unused. I’ve mentioned a bit of it in the <a href="https://www.copetti.org/writings/consoles/wii/#the-hidden-co-processor">Wii article</a>.</li><li>Any extension bundled into the core. For instance, the MPCore includes a <strong>Vector Floating-point Coprocessor</strong> with additional instructions to control said coprocessor <sup id="bibref:8"><a href="#bib:cpu-vfp" role="doc-biblioref">[8]</a></sup>.</li></ul><p>To make matters less confusing, ARM tends to package all of these with a single nomenclature. For instance, in the case of the ARM11 MPCore opcodes, ARM refers to them as the <strong>ARMv6k</strong> instruction set.</p><h4 id="and-a-fragmented-distribution">… and a fragmented distribution</h4><p>The adoption of extensions and alternative instruction sets eventually made things very convoluted for developers targeting generic ARM hardware, you only have to look at the uncountable ARM ports devised for Linux distributions.</p><p>Debian, one of the most popular distributions, tried to tackle the disparities by developing two ports in parallel:</p><ul><li><code>armel</code>: unoptimized, compatible with ARMv4T onwards.</li><li><code>armhf</code>: accelerated with VFP, but only compatible with ARMv7 onwards.</li></ul><p>Yet, with the arrival of the Raspberry Pi (powered by ARMv6 and accelerated with VFP), neither of them was deemed acceptable. Thus, an unofficial port called ‘Raspbian’ was developed to provide a VFP-accelerated version for ARMv6 CPUs <sup id="bibref:9"><a href="#bib:cpu-armhf" role="doc-biblioref">[9]</a></sup>. Even so, the trend continued: years later, with the arrival of ARMv8 and AArch64, Debian spawned yet-another port, <code>arm64</code>, optimised for the new 64-bits ISA.</p><p>I don’t remember seeing this labyrinth with x86, but at least things are now getting more orderly. AArch64 has unified many extensions and dropped alternative modes (<em>farewell, Thumb and Jazelle</em>).</p><h3 id="core-functionality">Core functionality</h3><p>That was a big deviation. Let’s go back to the 3DS CPU, the ARM11, and check what’s inside.</p><p>For this study, we can divide the ARM11 MPCore into two areas:</p><ul><li>The <strong>MP11 cores</strong> that make up the cluster.</li><li>The <strong>Advanced eXtensible Interface (AXI)</strong> bus, a new invention that interconnects the cores and interfaces with the outside world.</li></ul><p>Let’s start with the cores now and then we’ll check the AXI bus.</p><div><ul><li id="tab-3-1-the-original-mpcore-link"><a href="#tab-3-1-the-original-mpcore">The original MPCore</a></li><li id="tab-3-2-the-new-mpcore-link"><a href="#tab-3-2-the-new-mpcore">The ‘New’ MPCore</a></li><li id="tab-3-3-the-axi-bus-link"><a href="#tab-3-3-the-axi-bus">The AXI bus</a></li></ul><div><div id="tab-3-1-the-original-mpcore"><h4 id="tab-3-1-the-original-mpcore">The original MPCore</h4><figure><a href="https://www.copetti.org/images/consoles/nintendo3ds/cpu/mpcore_overview.593ad79da3baa7e6b91e954dab46aff1bfe8dd75567506ad3626f9412aa91533.png"><picture><img alt="Image" width="513" height="542" src="https://www.copetti.org/images/consoles/nintendo3ds/cpu/mpcore_overview.593ad79da3baa7e6b91e954dab46aff1bfe8dd75567506ad3626f9412aa91533.png" loading="lazy"/></picture></a><figcaption>Overview of the ARM11 MPCore CPU cluster</figcaption></figure><p>The first ARM11 MPCore variant, which debuted with the original 3DS, includes two cores. Each is called <strong>MP11</strong> and runs at <strong>268 MHz</strong> <sup id="bibref:10"><a href="#bib:cpu-lioncash" role="doc-biblioref">[10]</a></sup>.</p><p>Apart from implementing the ARMv6k instruction set, the CPU features an <strong>8-stage pipeline</strong> <sup id="bibref:11"><a href="#bib:cpu-arm_reference" role="doc-biblioref">[11]</a></sup>. Furthermore, the core provides <strong>two levels of branch prediction</strong>, ‘dynamic’ (based on previous executions) and ‘static’ (based on the current instruction alone). Overall, both enhancements will be quickly noticed, considering the 5-stage ARM9 couldn’t predict a thing!</p><p>Additionally, since the ARM946E-S CPU, ARM has been fitting a <strong>System Control Coprocessor</strong> called <strong>CP15</strong>. This time, it provides <strong>Memory-Management</strong> (MMU functions) and registers that output information about the MPCore cluster.</p><p>Now, there’s no more <strong>Tightly-Coupled Memory</strong> (TCM). There are however <strong>16 KB of instruction cache</strong> and <strong>16 KB of data cache</strong>, this change of model resembles other systems of the same generation. If you are curious, this L1 cache is 4-way set associative.</p><p>Finally, each core houses a co-processor called <strong>Vector Floating-point Coprocessor</strong> (also known as ‘VFP11’). This accelerates arithmetic operations with floating-point numbers, both 32-bit single-precision (a.k.a. <code>float</code>) and 64-bit double-precision (a.k.a. <code>double</code>) ones <sup id="bibref:12"><a href="#bib:cpu-vfp" role="doc-biblioref">[12]</a></sup>. It’s not a big coprocessor though, as its register file is composed of 32 32-bit registers, so doubles will consume two registers. In any case, this processor implements the <strong>VFPv2 instruction set</strong> and follows the <strong>IEEE 754</strong> standard. The latter is a welcomed decision, considering the architecture of <a href="https://www.copetti.org/writings/consoles/playstation-2/#the-leader">previous generations</a>.</p></div><div id="tab-3-2-the-new-mpcore"><h4 id="tab-3-2-the-new-mpcore">The ‘New’ MPCore</h4><figure><a href="https://www.copetti.org/images/consoles/nintendo3ds/cpu/mpcore_new_overview.73042809fa9f8f34cbea6e462ef0d89128a814b522968e63bb28ae4e3a00b9e1.png"><picture><img alt="Image" width="960" height="624" src="https://www.copetti.org/images/consoles/nintendo3ds/cpu/mpcore_new_overview.73042809fa9f8f34cbea6e462ef0d89128a814b522968e63bb28ae4e3a00b9e1.png" loading="lazy"/></picture></a><figcaption>Overview of the ‘New’ CPU cluster</figcaption></figure><p>With the arrival of the New 3DS in 2014, a new SoC was included (<strong>CPU LGR</strong>) and with it, a luxurious CPU upgrade.</p><p>The most apparent change is that we have now <strong>four MP11 cores</strong> instead of two. The consequences of this, however, are not simple to disseminate, but we’ll see them in due time.</p><p>The second change is that the CPU incorporates <strong>2 MB of L2 cache</strong> shared between the four cores. This type of cache is 16-way associative, which anticipates four cores accessing it at the same time. If you’d like to know more, I went over associative caches with the <a href="https://www.copetti.org/writings/consoles/xbox-360/#shared-cache">Xbox 360 article</a>.</p><p>Moving on, all cores now run at <strong>804 MHz</strong> (three times the original speed, which will certainly raise a few eyebrows).</p></div><div id="tab-3-3-the-axi-bus"><h4 id="tab-3-3-the-axi-bus">The AXI bus</h4><figure><a href="https://www.copetti.org/images/consoles/nintendo3ds/cpu/axi.7e49c2473554d83f6944120a017622217417d3b8704a631434e0b4e609048377.png"><picture><img alt="Image" width="510" height="600" src="https://www.copetti.org/images/consoles/nintendo3ds/cpu/axi.7e49c2473554d83f6944120a017622217417d3b8704a631434e0b4e609048377.png" loading="lazy"/></picture></a><figcaption>Example of how the AXI protocol interconnects different types of components</figcaption></figure><p>Whether there are two or four cores, all of these are connected using a specialised bus, proudly authored by ARM, called the <strong>Advanced eXtensible Interface</strong> (AXI). This protocol is part of the AMBA3 model, a successor of the original AMBA revision that we’ve seen in the <a href="https://www.copetti.org/writings/consoles/wii/#the-hidden-co-processor">Wii</a> and <a href="https://www.copetti.org/writings/consoles/wiiu/#internal-interfaces">Wii U</a> (both housing an ARM9 CPU).</p><p>Generally speaking, the AMBA model provides a set of protocols for connecting components with distinct bandwidth requirements using a <strong>bus topology</strong>. Compare this to the token-ring model of the <a href="https://www.copetti.org/writings/consoles/playstation-3/#inside-cell-the-heart">PlayStation 3</a> or the mesh solution made for the <a href="https://www.copetti.org/writings/consoles/xbox-360/#inside-xenon-the-messenger">Xbox 360</a>. All of these consoles shared the same problem, but each came up with different solutions, neither better nor worse, just different.</p><p>Following AMBA’s methodologies for interconnecting components, there will be a master-slave hierarchy imposed to maintain order. The master components (typically, the CPU cores) will be the ones sending commands to the slaves (i.e. memory and I/O blocks).</p><p>Now, as part of the AMBA3 specification, ARM offered the AXI model as a critical ingredient for building <strong>System On Chips</strong> (SoC). Instead of using a single bus, AXI uses a dedicated block (called <strong>AXI interconnect</strong>) acting as a <strong>bus matrix</strong> <sup id="bibref:13"><a href="#bib:cpu-axi" role="doc-biblioref">[13]</a></sup>, this is connected to every single component using <strong>64-bit dedicated buses</strong> <sup id="bibref:14"><a href="#bib:cpu-arm11_overview" role="doc-biblioref">[14]</a></sup>. In doing so, AXI overcomes the limitations of high-bandwidth components sharing the same bus (as it happened with the <a href="https://www.copetti.org/writings/consoles/playstation-2/#cpu">PlayStation 2</a>). Moreover, multiple master devices can communicate with slave nodes using separate channels to avoid waiting for other masters to finish. Finally, traditional enhancements like <a href="https://www.copetti.org/writings/consoles/gamecube/#ibms-enhancements">burst transactions</a> are implemented, from which the MP11 cores take advantage.</p><p>In the case of the 3DS, the AXI interconnect is housed in a bigger block called <strong>Snoop Control Unit</strong> (SCU) that also takes care of automatically maintaining L1 cache coherency between the MP11 cores.</p></div></div></div><h3 id="any-other-cpus">Any other CPUs?</h3><p>Up to this moment, I’ve been talking about the MPCore as if it were the only CPU in this system, the reason being mixing up distinct CPUs for this analysis can turn it into an incomprehensible essay. That is, until now.</p><p>The truth is, Nintendo had extra requirements for this console. They wanted a proper security system, but also the possibility to turn the console into a <strong>Nintendo DSi or a GBA</strong> on-the-fly. So, for all of that, they ended up bundling <strong>three distinct CPU packages</strong> - one being the mentioned ARM11. The other two are well hidden, in the sense that games are completely unaware of them. In fact, 3DS emulators like Citra don’t care about them either <sup id="bibref:15"><a href="#bib:cpu-citra_cpu" role="doc-biblioref">[15]</a></sup>.</p><figure><a href="https://www.copetti.org/images/consoles/nintendo3ds/photos/side_ds.3eba2a2f3a4631917db480bd5069986d1298ec9182c0806ba209e2b55dd0eb09.webp"><picture><img alt="Image" width="1111" height="530" src="https://www.copetti.org/images/consoles/nintendo3ds/photos/_hufe4dbc5506e4ce358fb18d5a09cafc51_22792_04c9dc378631b6c66caa6384f2d190a3.png" loading="lazy"/></picture></a><figcaption>The Nintendo 3DS next to a predecessor (a Nintendo DS Lite), the latter has become a common denominator.</figcaption></figure><p>But we do! Here’s the complete list of CPUs this system houses:</p><ul><li>The <strong>ARM11 MPCore</strong> we’ve just seen.</li><li>An <strong>ARM946E-S</strong> from the <a href="https://www.copetti.org/writings/consoles/nintendo-ds/#cpu">Nintendo DS days</a>. It’s treated as a secret co-processor and it’s only managed by the operating system. Alternatively, it becomes the main processor whenever a DS or DSi game is executed.<ul><li>Thanks to its bundled CP15 co-processor, there’s a <a href="https://www.copetti.org/writings/consoles/playstation-portable/#focused-memory-management">Memory Protection Unit</a> (MPU) in place. This will protect the CPU from arbitrarily executing code from any location in memory.</li></ul></li><li>An <strong>ARM7TDMI</strong> from the <a href="https://www.copetti.org/writings/consoles/game-boy-advance/#cpu">Game Boy Advance days</a>. It’s a relatively ignored CPU, unless a DS or DSi game is being played, in which case it acts as a co-processor. However, on the special occasion when a Game Boy Advanced game is running, the main execution falls into this CPU.</li></ul><p>Unfortunately, or for obvious reasons, the three CPUs are never usable at the same time. Instead, the console has three modes of operation:</p><ul><li><strong>Native 3DS mode</strong>: The ARM11 MPCore executes a 3DS game while the ARM946E-S deals with I/O and security. The ARM7, on the other side, is switched off.</li><li><strong>Nintendo DSi mode</strong>: The ARM946E-S and ARM7TDMI operate in a multi-processor configuration to execute a Nintendo DS or DSi game. Just like with its predecessor, the ARM7TDMI has greater access to I/O. Meanwhile, the ARM11 MPCore will be working in the background to replicate missing and re-located DS hardware (real-time clock, power management, keypad, GBA/DS PPU display and so forth).</li><li><strong>Game Boy Advance mode</strong>: The ARM7TDMI is the only CPU executing instructions (in 99% of cases, that will come from a GBA game). The ARM11 MPCore and ARM9, both still operating within the capacities of ‘Native 3DS mode’, will be working in the background.</li></ul><p>If you stop to think about it, the Nintendo 3DS ends up housing four processors in total (Two MP11 cores + one ARM9 + one ARM7), or the absurd amount of six in the case of the New 3DS. How convoluted is that? Luckily, this system didn’t suffer the complications of the <a href="https://www.copetti.org/writings/consoles/sega-saturn/#cpu">Sega Saturn</a> and you can thank Nintendo and ARM’s engineering for that. After all, 3DS developers only had to deal with the MPCore.</p><p>Since the ARM9 and ARM7 are predominantly for I/O, security and backwards compatibility (neither of which require the developer’s awareness), I discuss them in later sections of this article. But if you’d like to know more about the design of the ARM7 and ARM9, I wrote about them in previous articles (the <a href="https://www.copetti.org/writings/consoles/game-boy-advance/#cpu">Game Boy Advance</a> and <a href="https://www.copetti.org/writings/consoles/nintendo-ds/#cpu">Nintendo DS</a> ones, respectively).</p><h4 id="multi-core-communication">Multi-core communication</h4><p>I guess the question now is, how can CPUs and cores talk to each other? Well, the easiest way is to share RAM… but you could also try a more efficient approach, depending on the cores trying to communicate:</p><figure><a href="https://www.copetti.org/images/consoles/nintendo3ds/cpu/inter_core.bb00bae6a6b8bc25be2a95f6c369baac03e16a1fcb64ff5029ed70f1eb5ac0a6.png"><picture><img alt="Image" width="1281" height="288" src="https://www.copetti.org/images/consoles/nintendo3ds/cpu/inter_core.bb00bae6a6b8bc25be2a95f6c369baac03e16a1fcb64ff5029ed70f1eb5ac0a6.png" loading="lazy"/></picture></a><figcaption>Representation of the communication channels each CPU is provided with.</figcaption></figure><ul><li>With <strong>inter-core ARM11 communication</strong>, a core can send interrupts to another core by writing on its <code>Software Interrupt Register</code> <sup id="bibref:16"><a href="#bib:cpu-arm_reference" role="doc-biblioref">[16]</a></sup>.</li><li>In the case of <strong>ARM11↔︎ARM9</strong> or <strong>ARM9↔︎ARM7 communication</strong>, the same <a href="https://www.copetti.org/writings/consoles/nintendo-ds/#interconnection">FIFO model</a> from the Nintendo DS is implemented. Plus, the ARM11↔︎ARM9 FIFO is also called ‘PXI’ <sup id="bibref:17"><a href="#bib:cpu-korth" role="doc-biblioref">[17]</a></sup>.</li></ul><h3 id="memory-available">Memory available</h3><p>Having three different CPUs also means the memory layout will not be simple, especially if you care about security.</p><figure><a href="https://www.copetti.org/images/consoles/nintendo3ds/cpu/memory.35bd0fe628c283231e7d16616a17ceaf4fd5d51e9dbca30ab8d8d10a0bfdba65.png"><picture><img alt="Image" width="621" height="650" src="https://www.copetti.org/images/consoles/nintendo3ds/cpu/memory.35bd0fe628c283231e7d16616a17ceaf4fd5d51e9dbca30ab8d8d10a0bfdba65.png" loading="lazy"/></picture></a><figcaption>Overview of memory organisation on the Nintendo 3DS.</figcaption></figure><p>To make a long story short, we’ve got the following blocks:</p><ul><li>From the developer’s perspective, the system provides <strong>128 MB of FCRAM</strong>. The New 3DS increased this to <strong>256 MB</strong>. The rest is redundant for games.</li><li>For predominantly security reasons, the ARM11 is also provided with a fast block of <strong>512 KB of SRAM</strong>. The ARM9 is also given a block of <strong>1 MB of SRAM</strong> (<strong>1.5 MB</strong> in the case of the New 3DS).</li><li>By inheriting the model of the <a href="https://www.copetti.org/writings/consoles/nintendo-ds/#tab-1-2-arm946e-s">Nintendo DS</a>, the ARM9 also houses <strong>Tightly-Coupled Memory</strong> (TCM). Particularly, there’s <strong>32 KB for instructions</strong> and <strong>16 KB for data</strong>.</li></ul><h4 id="a-new-type-of-memory-spotted">A new type of memory spotted</h4><p>It’s all jolly that the Nintendo 3DS includes 32 times the general-purpose memory of its predecessor, but what about that ‘FCRAM’? Is it any different from the other standards?</p><p>Well, <strong>Fast Cycle DRAM</strong> (FCRAM) is yet another RAM invention, this time authored in 2002 by Fujitsu and Toshiba. Presented as an alternative to DRAM-based technology (i.e. <a href="https://www.copetti.org/writings/consoles/xbox/#memory-layout">SDRAM</a>, <a href="https://www.copetti.org/writings/consoles/playstation/#the-offering">EDO DRAM</a>, <a href="https://www.copetti.org/writings/consoles/nintendo-64/#memory-design">RDRAM</a>, etc.), FCRAM excels on non-continuous reads, where it exhibits a lower latency than DRAM <sup id="bibref:18"><a href="#bib:cpu-fcram1" role="doc-biblioref">[18]</a></sup>. This was done to replicate the performance offered by the more expensive SRAM.</p><p>FCRAM competes directly with DDR DRAM by offering a revamped design of the memory arrays. In place of adding more circuitry on top of it, arrays are split into smaller subblocks, which are then accessed using a 3-stage pipeline <sup id="bibref:19"><a href="#bib:cpu-fcram2" role="doc-biblioref">[19]</a></sup>. In doing so, reading and writing on random locations become faster. These changes are still designed with backwards compatibility in mind. Thus, FCRAM is compatible with DDR DRAM controllers (hence, its full name is ‘DDR FCRAM’).</p><h3 id="faster-memory-transfers">Faster memory transfers</h3><p>The inventors of the MPCore and the AMBA bus happen to also offer a brand of <a href="https://www.copetti.org/writings/consoles/playstation/#taking-over-the-cpu">DMA controllers</a> called <strong>CoreLink</strong>, with Nintendo being a loyal client. So, it’s no mystery as to why the 3DS bundles multiple blocks of <strong>CoreLink DMA-330</strong> into their SoC <sup id="bibref:20"><a href="#bib:cpu-korth" role="doc-biblioref">[20]</a></sup>.</p><p>These DMAs in particular are attached to an AXI bus and act as master devices. They can transfer data between two slaves interconnected with the AMBA protocol (either AXI or the slower APB) with the following advantages:</p><ul><li>Faster transfer rates compared to either CPU.</li><li>Support of up to eight channels (eight transfers at the same time) <sup id="bibref:21"><a href="#bib:cpu-corelink" role="doc-biblioref">[21]</a></sup>.</li></ul><p>To be precise, Nintendo fitted one CoreLink DMA next to the ARM9, this is referred to as <strong>XDMA</strong> and provides <strong>up to four channels</strong>. There’s another DMA next to the ARM11 block, this time called <strong>CDMA</strong>, which provides <strong>up to eight channels</strong>. With the arrival of the New 3DS, another CoreLink DMA-330 is fitted next to the ARM11 block (now a quad-core cluster).</p><h3 id="programming">Programming</h3><p>With all being said, how do you program a system featuring this unorthodox CPU arrangement? To be fair, unusual systems are no strangers to videogame developers. But in this case, <strong>3DS programmers only have access to the ARM11 MPCore</strong>. Furthermore, once you reach the ‘Operating System’ section, you’ll learn the abilities with this cluster are further restricted.</p><p>In any case, no matter the console revision, programmers base their algorithms on the <strong>multi-threading model</strong>: the program groups sequences of instructions using <strong>threads</strong>, these are then dispatched by the operating system to the physical cores, as the former deems fit. Once a novelty for <a href="https://www.copetti.org/writings/consoles/xbox-360/#inside-xenon-programming-styles">Xbox 360 software</a>, this standard provides a layer of abstraction that blinds the developers from writing software only compatible with a fixed number and type of CPU cores.</p><h4 id="dealing-with-the-new-hardware">Dealing with the ‘New’ hardware</h4><p>Since the New 3DS diverts considerably from the original specification, Nintendo set up a thin compatibility layer to enable old 3DS games to work with the new hardware without manual intervention.</p><p>In essence, when a game is launched from a New 3DS console, the game’s code specifies if it’s specifically targeting the new models or not <sup id="bibref:22"><a href="#bib:cpu-applet_manager" role="doc-biblioref">[22]</a></sup>. If it is, the operating system will proceed to activate all the novelties (faster clock speed, extra RAM and use of L2 cache) for that game to enjoy. If it’s not, the operating system will keep its exclusive hardware deactivated until the user exits the game, so the game can safely assume it’s running on the old hardware and will do so without issue.</p><p>To keep supporting the old 3DS, games can be packaged with two codebases (one for the ‘New’ model and the other for the ‘Old’ one). It’s up to the game studios to decide whether to support the old and new 3DS, or only the new 3DS.</p><p>You may be wondering what happens with the rest of the exclusive hardware the New 3DS houses (i.e. extra ARM11 cores and DMA). Well, to properly understand the rationale, I explain this once you reach the ‘Operating System’ section, but I’m afraid you won’t like the answer!</p><hr/><h2 id="graphics">Graphics</h2><p>Next to a new CPU is always a modern GPU. So, what kind of <a href="https://www.copetti.org/writings/consoles/nintendo-ds/#graphics">Picture Processing Unit</a> did Nintendo build this time? To tell the truth, none. For the first time in their portable line, <strong>they resorted to a GPU supplier</strong>.</p><p>Nevertheless, the requirements of Nintendo haven’t shifted. The company still wanted a chip with acceptable performance… and the <strong>intellectual property</strong>. This will allow them to embed the GPU into their SoC, in the same way they did with the ARM CPUs.</p><figure><ul><li id="tab-4-1-kart-link"><a href="#tab-4-1-kart">Kart</a></li><li id="tab-4-2-sonic-link"><a href="#tab-4-2-sonic">Sonic</a></li><li id="tab-4-3-mario-link"><a href="#tab-4-3-mario">Mario</a></li><li id="tab-4-4-animal-link"><a href="#tab-4-4-animal">Animal</a></li><li id="tab-4-5-zelda-link"><a href="#tab-4-5-zelda">Zelda</a></li></ul><figure id="tab-4-1-kart"><a href="https://www.copetti.org/images/consoles/nintendo3ds/games/mario_kart.f3aee78ccef9f74a20c423ce9ea8803dd71a28438cbf4c9f0aed0ed8e3bca596.png"><picture><source type="image/webp" srcset="https://www.copetti.org/images/consoles/nintendo3ds/games/_hu5324041165f0a097655cc1fd8a33a74b_77731_31339cf3bb9271013ab1a183d3738ff6.webp 400w"/><img alt="Image" width="400" height="480" src="https://www.copetti.org/images/consoles/nintendo3ds/games/mario_kart.f3aee78ccef9f74a20c423ce9ea8803dd71a28438cbf4c9f0aed0ed8e3bca596.png" loading="lazy"/></picture></a><figcaption>Mario Kart 7 (2011)</figcaption></figure><figure id="tab-4-2-sonic"><a href="https://www.copetti.org/images/consoles/nintendo3ds/games/sonic.c943fd06acd604456c0cc247d4364116870b667443bf96ad3a023a50616c0a27.png"><picture><img alt="Image" width="400" height="480" src="https://www.copetti.org/images/consoles/nintendo3ds/games/sonic.c943fd06acd604456c0cc247d4364116870b667443bf96ad3a023a50616c0a27.png" loading="lazy"/></picture></a><figcaption>Sonic Generations (2011)</figcaption></figure><figure id="tab-4-3-mario"><a href="https://www.copetti.org/images/consoles/nintendo3ds/games/mario_bros.5d75761bef28df652709a0ad18ed54be183bd72e52c93558e78c9fddb6a2cbf6.png"><picture><img alt="Image" width="400" height="480" src="https://www.copetti.org/images/consoles/nintendo3ds/games/mario_bros.5d75761bef28df652709a0ad18ed54be183bd72e52c93558e78c9fddb6a2cbf6.png" loading="lazy"/></picture></a><figcaption>New Super Mario Bros. 2 (2012)</figcaption></figure><figure id="tab-4-4-animal"><a href="https://www.copetti.org/images/consoles/nintendo3ds/games/animal_crossing.7aded94c435aa5cce95ad2fe5395a7c699c3ad91af694f7cae42d43ac377aee5.png"><picture><img alt="Image" width="400" height="480" src="https://www.copetti.org/images/consoles/nintendo3ds/games/animal_crossing.7aded94c435aa5cce95ad2fe5395a7c699c3ad91af694f7cae42d43ac377aee5.png" loading="lazy"/></picture></a><figcaption>Animal Crossing: New Leaf (2012)</figcaption></figure><figure id="tab-4-5-zelda"><a href="https://www.copetti.org/images/consoles/nintendo3ds/games/zelda.d59e2d38f265b4ad9aca33e5213c11cbdf3313b468768abe4bc0914de2be3d68.png"><picture><source type="image/webp" srcset="https://www.copetti.org/images/consoles/nintendo3ds/games/_huc7d8aa9f2330731c61256ecd3c86f738_72234_d95f355bd8ccd2a1150852bb8d302ac0.webp 400w"/><img alt="Image" width="400" height="480" src="https://www.copetti.org/images/consoles/nintendo3ds/games/zelda.d59e2d38f265b4ad9aca33e5213c11cbdf3313b468768abe4bc0914de2be3d68.png" loading="lazy"/></picture></a><figcaption>The Legend of Zelda: Majora’s Mask 3D (2015)</figcaption></figure><figcaption>Example of Nintendo 3DS games. All render two frames of 400 x 240 pixels and one frame of 320 x 240 pixels.</figcaption></figure><p>Meanwhile, a potential candidate just finished unveiling their new invention at SIGGRAPH 2006 <sup id="bibref:23"><a href="#bib:graphics-dmp_insight" role="doc-biblioref">[23]</a></sup>. For some time, <strong>Digital Media Professionals Inc.</strong> (also known as ‘DMP’) have been building affordable GPUs for the embedded market and, while their chips are nothing out of the ordinary, they guarantee decent OpenGL ES support. Furthermore, their licensing framework offers <strong>synthesisable GPUs</strong>.</p><p>This seemed enough for Nintendo, who happily negotiated a license for DMP’s latest core, the <strong>PICA200</strong> and subsequently bundled it on CTR CPU (the Nintendo 3DS’ SoC). The GPU runs at <strong>268 MHz</strong>.</p><h3 id="architecture-of-the-pica200">Architecture of the PICA200</h3><p>If I had to summarise it in one sentence, the PICA200 is a budget low-power 3D processor that combines a pre-<a href="https://www.copetti.org/writings/consoles/xbox-360/#a-new-foundation-on-the-way">unified architecture</a> with a modernised API. The underlying architecture of the PICA200 is called <strong>Maestro 2G</strong> <sup id="bibref:24"><a href="#bib:graphics-siggraph" role="doc-biblioref">[24]</a></sup> and its design is compliant with <strong>OpenGL ES 1.1</strong>, but extended with elements from <strong>OpenGL ES 2.0</strong> <sup id="bibref:25"><a href="#bib:graphics-nintendo_gl" role="doc-biblioref">[25]</a></sup>. However, the PICA200’s APIs are not limited to either standard.</p><p>You see, even though the pipeline is segregated and the pixel stage is fixed-function (ala <a href="https://www.copetti.org/writings/consoles/playstation-2/#graphics">PlayStation 2</a>), DMP expanded the limited circuitry with a set of <strong>Maestro functions</strong> that provide capabilities beyond the expectations of the embedded market <sup id="bibref:26"><a href="#bib:graphics-ocp" role="doc-biblioref">[26]</a></sup>. This includes fragment lighting, multiple shadowing algorithms, polygon subdivision, bump mapping, procedural textures and many fog effects.</p><p>Additionally and in contrast to the <a href="https://www.copetti.org/writings/consoles/nintendo-ds/#tab-5-3-result">Nintendo DS</a>, the PICA200 <strong>only works with framebuffers</strong>. That’s it. The <a href="https://www.copetti.org/writings/consoles/nes/#graphics">sprite engine</a>, a popular workaround to tackle unaffordable memory requirements, is now a thing of the past. This also includes <a href="https://www.copetti.org/writings/consoles/nes/#secrets-and-limitations">scan-line tricks</a>, as contemporary GPUs work way faster than the refresh rate of a CRT.</p><h4 id="organising-the-content">Organising the content</h4><p>Now that we know that this console can draw 3D shapes, the question now is: where does it store its materials? There are two locations, the large <strong>FCRAM</strong> block and the smaller but faster <strong>VRAM</strong>.</p><p>Nintendo only provided <strong>6 MB of VRAM</strong> exclusively for the GPU. Ideally, programmers would fit as much as they can there, but since it will fill up pretty quickly, it is expected to be used to store data that needs instant access (i.e. commands, buffers and recurrent textures) while placing the rest on FCRAM. The PICA200 comes with a <strong>DMA unit</strong> that can transfer data between FCRAM and VRAM. So, at the end of the day, it’s the responsibility of the programmer to come up with an efficient placement to avoid bottlenecks.</p><figure><a href="https://www.copetti.org/images/consoles/nintendo3ds/gpu/content.6bb4820e85f8f07d78fa991cbd9cb8eb5f695a045b6ae921d87f081f5f592e84.png"><picture><img alt="Image" width="939" height="605" src="https://www.copetti.org/images/consoles/nintendo3ds/gpu/content.6bb4820e85f8f07d78fa991cbd9cb8eb5f695a045b6ae921d87f081f5f592e84.png" loading="lazy"/></picture></a><figcaption>Example of how data is organised across the memory available.</figcaption></figure><p>During rendering, programmers allocate dedicated render buffers (i.e. frame, stencil, depth, etc.) for many operations. That’s always been the case. With the 3DS, alongside these buffers, programmers are also expected to reserve extra space for <strong>Display buffers</strong>, these are bound to the physical screens. The 3DS requires to allocate <strong>three Display buffers</strong> (two for the stereoscopic upper screen and one for the bottom one). To give you an idea, the display process works as follows:</p><ol><li>The LCD continuously displays the content of the front (active) Display buffer, as instructed by the value of the buffer index.</li><li>Meanwhile, the GPU finishes rendering geometry in a framebuffer.</li><li>The framebuffer is exported to the back (inactive) Display buffer.</li><li>The GPU swaps the index of the front Display buffer.<ul><li>For practical reasons, the index swap should happen at the end of <a href="https://www.copetti.org/writings/consoles/nes/#tab-5-5-result">Vertical Sync</a> to avoid tearing down the picture <sup id="bibref:27"><a href="#bib:graphics-opengl_swap" role="doc-biblioref">[27]</a></sup>. The official APIs provide synchronisation functions to keep all operations at the correct pace.</li></ul></li><li>The LCD will now be scanning the recently updated Display buffer from now on.</li></ol><h4 id="adopting-open-standards">Adopting open standards</h4><p>On an interesting note, just like the ARM11 MPCore adopts ARM’s AXI protocol for interconnecting its cores, DMP adopted a less-proprietary option called <strong>Open Core Protocol</strong> (OCP) <sup id="bibref:28"><a href="#bib:graphics-ocp" role="doc-biblioref">[28]</a></sup>. As its name indicates, the Open Core protocol does not impose any licensing restrictions on its users, something that vendors using the PICA200 may find advantageous. For comparison purposes, AXI was released in 2003 (along with the AMBA 3 specification) while OCP was published in 2001. It does make me wonder what kind of technology Nintendo fitted to adapt the OCP signal coming from the PICA200 into an AXI-compliant signal, so the rest of the SoC understands it. I assume that there’s a bridge between the PICA200 and the AXI bus.</p><p>Interestingly enough, the predecessor of the PICA200, the ULTRAY2000, shares many similarities with its successor. The most notable difference, however, is that the data interfaces use the PCI and DDR-SDRAM protocols instead <sup id="bibref:29"><a href="#bib:graphics-hardware" role="doc-biblioref">[29]</a></sup>.</p><h3 id="constructing-the-frame">Constructing the frame</h3><p>Naturally, the GPU is not aware of the stereoscopic or dual-screen nature of the displays, it will only be tasked with rendering three screens during gameplay:</p><ul><li><strong>Top stereoscopic-left</strong>: 400 x 240 pixels wide.</li><li><strong>Top stereoscopic-right</strong>: 400 x 240 pixels wide.</li><li><strong>Bottom</strong>: 320 x 240 pixels wide.</li></ul><p>All of them can display 8-bit RGB colours, which equates to up to 16.78 million colours.</p><p>Considering players will expect acceptable frame rates on all three screens (especially on the first two), the single PICA200 will be subject to high amounts of workload throughout its operation, an important aspect to remember when judging its performance.</p><p>That being said, here is an overview of how data travels to draw a single frame:</p><figure><a href="https://www.copetti.org/images/consoles/nintendo3ds/gpu/pipeline.1242abb39bcb4fa2d51bfbaf5325b31977b76e5f0542e8847a06d84a447de79e.png"><picture><img alt="Image" width="548" height="479" src="https://www.copetti.org/images/consoles/nintendo3ds/gpu/pipeline.1242abb39bcb4fa2d51bfbaf5325b31977b76e5f0542e8847a06d84a447de79e.png" loading="lazy"/></picture></a><figcaption>Overview of the graphics pipeline in PICA200.</figcaption></figure><p>… and as customary in this series of articles, we’ll now take a look at what happens at each stage.</p><div><ul><li id="tab-5-1-commands-link"><a href="#tab-5-1-commands">Commands</a></li><li id="tab-5-2-vertex-link"><a href="#tab-5-2-vertex">Vertex</a></li><li id="tab-5-3-geometry-link"><a href="#tab-5-3-geometry">Geometry</a></li><li id="tab-5-4-rasteriser-link"><a href="#tab-5-4-rasteriser">Rasteriser</a></li><li id="tab-5-5-fragment-link"><a href="#tab-5-5-fragment">Fragment</a></li><li id="tab-5-6-post-processing-link"><a href="#tab-5-6-post-processing">Post-processing</a></li></ul><div><div id="tab-5-1-commands"><h4 id="tab-5-1-commands">Commands</h4><figure><a href="https://www.copetti.org/images/consoles/nintendo3ds/gpu/pipeline/command.1772409bf9d3938e254256094ca5ce70533f1645a965f019601248ced7fda6a7.png"><picture><img alt="Image" width="548" height="392" src="https://www.copetti.org/images/consoles/nintendo3ds/gpu/pipeline/command.1772409bf9d3938e254256094ca5ce70533f1645a965f019601248ced7fda6a7.png" loading="lazy"/></picture></a><figcaption>Overview of the command stage.</figcaption></figure><p>This is Nintendo’s first portable console to finally draw triangles in ‘the usual way’. That is, with the use of commands. But it’s not a surprising factor, as the PICA200 is expected to abide by the teachings of OpenGL ES.</p><p>In essence, the PICA200 draws polygons by reading a <a href="https://www.copetti.org/writings/consoles/xbox-360/#tab-6-1-commands">command buffer</a> <sup id="bibref:30"><a href="#bib:graphics-nintendo_gpu_reg" role="doc-biblioref">[30]</a></sup>. Furthermore, the vertex data can either be embedded within the command or stored in a separate buffer in VRAM, with the latter being the most efficient.</p></div><div id="tab-5-2-vertex"><h4 id="tab-5-2-vertex">Vertex</h4><figure><a href="https://www.copetti.org/images/consoles/nintendo3ds/gpu/pipeline/vertex.d863f782cc69f3351251f43b8bbf5f9d05d04d6e1ac080e7cebc7cf336a4424a.png"><picture><img alt="Image" width="885" height="482" src="https://www.copetti.org/images/consoles/nintendo3ds/gpu/pipeline/vertex.d863f782cc69f3351251f43b8bbf5f9d05d04d6e1ac080e7cebc7cf336a4424a.png" loading="lazy"/></picture></a><figcaption>Overview of the vertex stage.</figcaption></figure><p>The PICA200 provides <strong>four Vertex Processors</strong> (VP) that operate in parallel. However, if the geometry shader (the next pipeline stage) is activated, only <strong>three</strong> processors can be utilised.</p><p>Each core computes 96-bit vectors made of four 24-bit floating-point values <sup id="bibref:31"><a href="#bib:graphics-picasso" role="doc-biblioref">[31]</a></sup>, but unlike the ARM11’s VFP, they don’t comply with IEEE-754 <sup id="bibref:32"><a href="#bib:graphics-shader_isa" role="doc-biblioref">[32]</a></sup>. The vertex processors are programmed using assembly language specific to the PICA200 (reminiscent of the days of the <a href="https://www.copetti.org/writings/consoles/xbox/#graphics">Nvidia NV30</a>) and are operated as follows <sup id="bibref:33"><a href="#bib:graphics-game-vertex" role="doc-biblioref">[33]</a></sup>:</p><ol><li>Developers write the vertex shader using PICA200 assembly. For reference, the instruction set is very similar to Microsoft’s <code>vs_2_0</code> <sup id="bibref:34"><a href="#bib:graphics-vs2" role="doc-biblioref">[34]</a></sup>.</li><li>The shader is compiled using a proprietary assembler.</li><li>The 3DS program must copy the compiled binary to memory (either FCRAM or VRAM).</li><li>Then, the 3DS program issues a GPU command to load the binary and connect it with the program.</li></ol><p>Once the vertex cores finish processing, they output the results to the <strong>Sync Control</strong> block, which acts as a vertex cache and buffer. It has a capacity of <strong>384 Bytes</strong>, enabling it to hold up to 32 96-bit vectors. Finally, the next stage reads from this block.</p></div><div id="tab-5-3-geometry"><h4 id="tab-5-3-geometry">Geometry</h4><figure><a href="https://www.copetti.org/images/consoles/nintendo3ds/gpu/pipeline/geometry.0789eaa32552820dd323d1b845f38aa592644f3aa2df21051a90013cad21a0c5.png"><picture><img alt="Image" width="885" height="482" src="https://www.copetti.org/images/consoles/nintendo3ds/gpu/pipeline/geometry.0789eaa32552820dd323d1b845f38aa592644f3aa2df21051a90013cad21a0c5.png" loading="lazy"/></picture></a><figcaption>Overview of the geometry stage.</figcaption></figure><p>The geometry stage is a signature feature of 8th-generation consoles, allowing developers to spawn complex geometry out of simple vertex data.</p><p>In this case, the PICA200’s geometry stage is implemented by <strong>stealing one of the four Vertex Processors</strong>. Then, the ‘geometry’ vertex core is loaded with a different vertex shader. Finally, it receives the vertex data from the three other processors.</p><p>Even though the geometry shader is programmable, in practice, <strong>Nintendo doesn’t allow this</strong>. Thus, game developers can only choose from a pre-programmed set of geometry shader programs (found in the SDK). Examples of available geometry shaders include square and line generation (using point primitives), geometry subdivision, silhouette edge rendering; and random particle generation.</p></div><div id="tab-5-4-rasteriser"><h4 id="tab-5-4-rasteriser">Rasteriser</h4><figure><a href="https://www.copetti.org/images/consoles/nintendo3ds/gpu/pipeline/rasteriser.f08b4b3d24323cb39f25cf1bc0480ed1229a281438210c64066e59fb6283c992.png"><picture><img alt="Image" width="428" height="345" src="https://www.copetti.org/images/consoles/nintendo3ds/gpu/pipeline/rasteriser.f08b4b3d24323cb39f25cf1bc0480ed1229a281438210c64066e59fb6283c992.png" loading="lazy"/></picture></a><figcaption>Overview of the rasteriser stage.</figcaption></figure><p>At this stage, all primitives are converted into pixels.</p><p>The rasterizer unit on the PICA200 is very simple, it just generates triangles out of primitives, then applies culling and clipping to remove unseen triangles (hidden behind others and/or outside the view area, respectively). This is all very similar to OpenGL ES’ modus operandi, albeit developers have to watch out for some coordinate systems that are inverted when working with the PICA200.</p></div><div id="tab-5-5-fragment"><h4 id="tab-5-5-fragment">Fragment</h4><figure><a href="https://www.copetti.org/images/consoles/nintendo3ds/gpu/pipeline/fragment.95c8b5fb5695c54a540c32f09ae215f2e5e1274421e46761750fb3e7266fc49c.png"><picture><img alt="Image" width="705" height="482" src="https://www.copetti.org/images/consoles/nintendo3ds/gpu/pipeline/fragment.95c8b5fb5695c54a540c32f09ae215f2e5e1274421e46761750fb3e7266fc49c.png" loading="lazy"/></picture></a><figcaption>Overview of the fragment stage.</figcaption></figure><p>The fragment stage is made of two areas: the <strong>texture units</strong>, which can fetch textures in memory and process them. And the <strong>shading unit</strong>, which can perform extra operations on the texture data.</p><p>The PICA200 contains <strong>four</strong> texture units <sup id="bibref:35"><a href="#bib:graphics-fragment" role="doc-biblioref">[35]</a></sup>, each houses <strong>256 Bytes of L1</strong> cache and all of them share <strong>8 KB of L2</strong> cache. However, the units are not homogenous. Instead, the range of services varies between each unit <sup id="bibref:36"><a href="#bib:graphics-pica_pipeline_diagram" role="doc-biblioref">[36]</a></sup>:</p><ul><li>Only three units can process 2D textures.</li><li>Only one unit can perform shadow, cube and <a href="https://www.copetti.org/writings/consoles/playstation-portable/#tab-2-4-textures">projective texture</a> mapping.</li><li>The last unit is more of a noise generator, meaning it only outputs <strong>random textures</strong>. It uses a combination of a random number generator and a colour lookup table. This is a slender yet efficient way of implementing <a href="https://www.copetti.org/writings/consoles/playstation-2/#infinite-worlds">procedure generation</a> with textures, saving bandwidth along the way.</li></ul><p>Afterwards, it’s the job of the shading unit to creatively fiddle with the textures coming in. However - and something unexpected considering we’re talking about an 8th-generation console - is that the PICA200’s unit is <strong>not programmable with <a href="https://www.copetti.org/writings/consoles/xbox/#tab-2-3-pixel">pixel shaders</a></strong> <sup id="bibref:37"><a href="#bib:graphics-kazakov" role="doc-biblioref">[37]</a></sup>. Instead, we find six <strong>configurable colour combiners</strong>, each combiner receives three RGB or Alpha values and performs a logical operation on them. The result is passed to the next combiner and so forth. Each colour combiner can get its input from the previous combiner (except the first), a texture unit or a constant value.</p><p>All in all, a modern reflection of the <a href="https://www.copetti.org/writings/consoles/gamecube/#tab-1-3-texture">Flipper era</a> (while abiding by the OpenGL specification <sup id="bibref:38"><a href="#bib:graphics-glTexEnv" role="doc-biblioref">[38]</a></sup>), but don’t forget developers may also combine this with the aforementioned Maestro functions.</p></div><div id="tab-5-6-post-processing"><h4 id="tab-5-6-post-processing">Post-processing</h4><figure><a href="https://www.copetti.org/images/consoles/nintendo3ds/gpu/pipeline/post.23c51da1a21d56daf18466fbb6c4373d4b9b47d82f41956f636b096d7e6b8eca.png"><picture><img alt="Image" width="956" height="527" src="https://www.copetti.org/images/consoles/nintendo3ds/gpu/pipeline/post.23c51da1a21d56daf18466fbb6c4373d4b9b47d82f41956f636b096d7e6b8eca.png" loading="lazy"/></picture></a><figcaption>Overview of the post-processing stage.</figcaption></figure><p>After the frame is processed and ready to be written into the framebuffer (or <a href="https://www.copetti.org/writings/consoles/xbox-360/#tab-6-4-pixel-shader">render targets</a>), it goes through a sequence of final ‘corrections’. This is similar to the OpenGL ES 2.0’s pipeline.</p><p>That being said, the frame goes through <strong>alpha</strong>, <strong>stencil</strong> and <strong>depth</strong> testing. Afterwards, the result can be mixed with an existing frame (in the framebuffer) using the colour blender or logical operators (AND, XOR, etc.). Finally, the frame is written into the assigned buffer in memory either as a whole or through a stencil filter (for masking).</p><p>For additional smoothing of the edges, the PICA200 can render the framebuffer at twice the selected dimensions, and then average it with antialiasing 2x2. This is an <a href="https://www.copetti.org/writings/consoles/xbox/#tab-2-4-post-processing">old technique</a> known as <strong>supersampling</strong>.</p><p>Once the framebuffer is ready to be displayed, it must be copied into another block in memory called <strong>Display Buffer</strong> (whose format is better aligned to the scan-line procedure of the LCD screen) and then transferred to the LCD in the form of scan-lines.</p></div></div></div><h3 id="interactive-comparison">Interactive comparison</h3><p>Now that you’ve seen how the PICA200 draws its triangles on the screen, it’s time for some practical examples. Here I’ve gathered two Marios from Smash Bros games, the Wii and 3DS one. Notice how the level of detail of ‘angry Mario’ hasn’t changed that much, considering we’re comparing a 2006 home console with its 2011 portable.</p><div><figure><table><tbody><tr id="mario_brawl_wii_selection"><td canvas="wireframe">Wireframe</td><td canvas="surface">Surface</td><td canvas="complete">Textured</td></tr><tr><td colspan="3"><picture id="mario_brawl_wii_canvas" model="mario_brawl_wii" folder="" file="mario_brawl_wii"><img width="290" height="250" loading="lazy" alt="3D model" src="https://www.copetti.org/images/consoles/models/mario_brawl_wii.4d3949befc10cb5b9fed2c9aee3f827dc4237aa2e772d6c916721dc9aa38e3b1.png"/></picture></td></tr><tr><td colspan="3" id="mario_brawl_wii_selection_footer">Tap to enable interaction</td></tr></tbody></table><figcaption>Super Smash Bros Brawl (2008) for the Wii.</figcaption></figure><figure><table><tbody><tr id="mario_ssb_3ds_selection"><td canvas="wireframe">Wireframe</td><td canvas="surface">Surface</td><td canvas="complete">Textured</td></tr><tr><td colspan="3"><picture id="mario_ssb_3ds_canvas" model="mario_ssb_3ds" folder="" file="mario_ssb_3ds"><img width="344" height="297" loading="lazy" alt="3D model" src="https://www.copetti.org/images/consoles/models/mario_ssb_3ds.f030c439abdde487243a96adb2219a97467b9ba98b20b9218b0e9f7f10dcc600.png"/></picture></td></tr><tr><td colspan="3" id="mario_ssb_3ds_selection_footer">Tap to enable interaction</td></tr></tbody></table><figcaption>Super Smash Bros. for 3DS (2014).</figcaption></figure></div><p>It’s worth reminding again that, in practice, the PICA200 will be rendering three screens at the same time, something that the <a href="https://www.copetti.org/writings/consoles/wii/#graphics">Wii’s GPU</a> wasn’t subjected to.</p><h3 id="nostalgic-rendering">Nostalgic rendering</h3><p>After all that’s been explained, there’s one question left unanswered: How does the PICA200 render Nintendo DS and Game Boy Advanced games? You may remember that the DS and GBA’s GPU exhibit completely different modus operandi for <a href="https://www.copetti.org/writings/consoles/nintendo-ds/#the-3d-accelerator">rendering and broadcasting</a> frames.</p><figure><a href="https://www.copetti.org/images/consoles/nintendods/mario/complete.ad64c1f4bb4e348934057c8f4809801019adc8e0ad46312f00c17fd40c24b475.png"><picture><img alt="Image" width="256" height="192" src="https://www.copetti.org/images/consoles/nintendods/mario/complete.ad64c1f4bb4e348934057c8f4809801019adc8e0ad46312f00c17fd40c24b475.png" loading="lazy"/></picture></a><figcaption>A frame rendered by the Nintendo DS’ <a href="https://www.copetti.org/writings/consoles/nintendo-ds/#graphics">Graphics Engine</a>, whose pipeline segregates between 2D and 3D data. That’s something the OpenGL-compliant PICA200 doesn’t understand.</figcaption></figure><p>The explanation is that the <strong>DS and GBA PPUs are housed in the SoC</strong> and DSi/DS/GBA games will operate them as they originally did on previous consoles. The PPUs output (scanlines) is delivered to a block called <strong>LgyFB</strong>, which may optionally upscale the frame, and then forwarded to the framebuffer, where the PICA200 will take care of displaying it. It’s the job of the ARM11 and its DMA to take care of all memory transfers during this process.</p><p>Naturally, this arrangement will add some delay (a.k.a. lag), albeit negligible to the user.</p><hr/><h2 id="audio">Audio</h2><p>Overall, the SoC houses <strong>two audio blocks</strong>:</p><ul><li>A proprietary <strong>DSP</strong> exclusively programmed for sound operations. This is used by 3DS games.</li><li>A variant of the <a href="">Nintendo DS audio block</a> named <strong>CSND</strong>. 3DS, DS and GBA games use it.</li></ul><h3 id="the-3ds-only-hardware">The 3DS-only hardware</h3><p>You may know that this same DSP was previously bundled with the Nintendo DSi, but treated as an optional accelerator instead. With the 3DS, it’s become the designated audio processor, so it’s no longer a voluntary component.</p><p>The DSP is called <strong>CEVA TeakLite II</strong> <sup id="bibref:39"><a href="#bib:audio-teakra" role="doc-biblioref">[39]</a></sup> and operates at <strong>~134 MHz</strong> <sup id="bibref:40"><a href="#bib:audio-teakra_arch" role="doc-biblioref">[40]</a></sup>. It’s manufactured by ParthusCeva, a company that provides synthesisable cores for audio processing <sup id="bibref:41"><a href="#bib:audio-dsp_press" role="doc-biblioref">[41]</a></sup>, and I guess ‘synthesisable’ was the keyword Nintendo was looking for when they partnered.</p><p>Moving on, the DSP outputs stereo samples (<strong>2 channels</strong>) of up to <strong>32 kHz</strong> of sampling rate and <strong>16-bit</strong> resolution.</p><p>Next to this component, we can find <strong>512 KB of RAM</strong> that is used by the DSP as a working area. It’s double-buffered (256 KB per buffer), so both the CPU and DSP can read and write without interruption <sup id="bibref:42"><a href="#bib:audio-dsp_memory" role="doc-biblioref">[42]</a></sup>. Apart from that, the DSP comes with a dedicated DMA that can transfer data in and out of those 512 KB.</p><h4 id="operation">Operation</h4><p>For all intents and purposes, games treat this as an opaque DSP. Thus, only Nintendo knows how to program it.</p><p>3DS programs, as a consequence of being developed using the official SDK, bundle a DSP firmware (solely authored by Nintendo) which is then uploaded to the DSP chip at runtime <sup id="bibref:43"><a href="#bib:audio-dsp_binary" role="doc-biblioref">[43]</a></sup>. Afterwards, programs rely on that firmware to execute audio-related routines. Furthermore, the audio services provided by the operating system further abstract the communication between the program and the DSP’s firmware <sup id="bibref:44"><a href="#bib:audio-dsp_services" role="doc-biblioref">[44]</a></sup>.</p><p>In any case, while the DSP firmware may change over the years, some capabilities have remained the same. For instance, the DSP can mix <strong>ADPCM</strong> and <strong>PCM</strong> samples. with support of up to <strong>24 channels</strong> <sup id="bibref:45"><a href="#bib:audio-dsp_memory" role="doc-biblioref">[45]</a></sup>. There’s also functionality for filtering and sequencing, including the generation of <a href="https://www.copetti.org/writings/consoles/nes/#audio">PSG</a>-like sounds.</p><p>Interestingly enough, the steps followed for hacking the 3DS (so it can execute homebrew application) optionally involve extracting the HOME Menu’s DSP firmware, so homebrew may use it to provide audio output <sup id="bibref:46"><a href="#bib:audio-dsp_dump" role="doc-biblioref">[46]</a></sup>.</p><h3 id="the-backwards-compatible-block">The backwards-compatible block</h3><p>At the other end of the spectrum, we find the CSND block. 3DS may use it as an extension of the DSP and DS/DSi/GBA games rely on it to replicate their hardware.</p><p>In terms of functionality, the CSND features <strong>32 channels</strong> <sup id="bibref:47"><a href="#bib:audio-3ds_sound" role="doc-biblioref">[47]</a></sup>, which is twice the amount of the Nintendo DS counterpart.</p><p>Curiously enough, early homebrew defaulted to this block for providing sounds, while waiting for the DSP to be reverse-engineered.</p><h3 id="pipeline">Pipeline</h3><p>Both DSP and CSND work independently and separately output their audio to the speaker.</p><figure><a href="https://www.copetti.org/images/consoles/nintendo3ds/audio.57ad2d480615199c857bfd09b469bde2b54de077df9f05eefab4c38ceed8b390.png"><picture><img alt="Image" width="665" height="303" src="https://www.copetti.org/images/consoles/nintendo3ds/audio.57ad2d480615199c857bfd09b469bde2b54de077df9f05eefab4c38ceed8b390.png" loading="lazy"/></picture></a><figcaption>Overview of the audio pipeline.</figcaption></figure><p>As a curious note, the original Nintendo 3DS didn’t play well with the speaker’s capabilities, as Nintendo ended up providing troubleshooting guides for cases of buzzing noises and fluctuations with 3D slider <sup id="bibref:48"><a href="#bib:audio-buzzing" role="doc-biblioref">[48]</a></sup>, all caused by the design of the case.</p><hr/><h2 id="io">I/O</h2><p>This section tends to be very rich in technologies considering Nintendo’s consoles favour generous I/O before state-of-the-art CPUs and GPUs. Let’s see what the Nintendo 3DS offers.</p><h3 id="external-interfaces-and-peripherals">External interfaces and peripherals</h3><p>The Nintendo DS had tons of modules built-in and the Nintendo DSi added more on top of it (after removing the GBA Slot). Now we found ourselves with a new console combining interfaces from two decades (the 2000s and 2010s).</p><figure><a href="https://www.copetti.org/images/consoles/nintendo3ds/diagram.4c27d5fbaf9d12fd48f1f6fd2a03bbd5b6652a15e22d418a486fc874896b126c.png"><picture><source type="image/webp" srcset="https://www.copetti.org/images/consoles/nintendo3ds/_hud261010f8fda45b6fb91d14bdc6124f7_88175_01c078a07c7bbb5949a953c8edcc6b9f.webp 500w,
https://www.copetti.org/images/consoles/nintendo3ds/_hud261010f8fda45b6fb91d14bdc6124f7_88175_2c4c532e83c7d9e10248df14d45e089e.webp 800w,
https://www.copetti.org/images/consoles/nintendo3ds/_hud261010f8fda45b6fb91d14bdc6124f7_88175_678c74a178b4bb3822d17fa443a083bc.webp 2252w"/><img alt="Image" width="2252" height="971" src="https://www.copetti.org/images/consoles/nintendo3ds/diagram.4c27d5fbaf9d12fd48f1f6fd2a03bbd5b6652a15e22d418a486fc874896b126c.png" loading="lazy"/></picture></a><figcaption>Main diagram of the console’s architecture. You can sense that the I/O area on the left side was a strong selling point of this console.</figcaption></figure><p>To be fair, we still don’t have a standard like USB, but that may be expendable considering the Nintendo 3DS bundles the following:</p><ul><li>A keypad composed of <strong>digital buttons</strong>, an <strong>analogue circle pad</strong>.</li><li>3D and volume <strong>sliders</strong>.</li><li>A Wi-Fi <strong>switch</strong>.</li><li>A <strong>resistive touch sensor</strong> on the bottom screen.</li><li>A <strong>gyroscope</strong> measuring the console’s rotation changes.</li><li>An <strong>accelerometer</strong> to measure the console’s motion.</li><li><strong>One front camera</strong> and <strong>two back cameras</strong>, the latter allowing to take stereoscopic pictures.</li><li>An <strong>infrared transceiver</strong>, used to transfer data between external accessories.</li><li>An <strong>SD card</strong> slot, serving as external storage.</li><li>A standard <strong>3.5 mm jack socket</strong> for headphones.</li><li>A <strong>game card reader</strong>, where 3DS, DSi and DS retail games are read from.</li></ul><h4 id="the-new-enhancements">The ‘New’ enhancements</h4><p>If that wasn’t enough, the New 3DS came with more modules on top. This includes:</p><ul><li>Two <strong>extra digital buttons</strong> and an extra analogue circle pad (called <strong>‘C-Stick’</strong>).</li><li>An <strong>NFC Reader</strong> on the bottom screen.</li><li>An <strong>infrared LED</strong>, reserved for head tracking.</li><li>The SD slot is replaced with a <strong>microSD slot</strong>.</li><li>The Wi-Fi switch has been removed, now it’s only controlled through software.</li></ul><p>Now, to prevent leaving ‘old’ users behind, Nintendo provided external accessories to enhance the old models, although most of them relied on the single infrared transceiver to connect. Thus, only one accessory could be connected at the same time.</p><p>Not all the exclusive features of the New 3DS can be replicated, however. For instance, the New 3DS’ head tracking mechanism depends on the extra ARM11 core.</p><h3 id="internal-interfaces">Internal interfaces</h3><p>Now it’s time to check how are these interfaces - and others - internally wired up.</p><p>Firstly, a large subset is interconnected with the standard <strong>Serial Peripheral Interface</strong> (SPI) protocol. There are four SPI buses and all of them are accessed by the ARM9 (which I assume also includes the ARM7). The ARM11 only has access to <em>most</em> of them <sup id="bibref:49"><a href="#bib:io-spi_registers" role="doc-biblioref">[49]</a></sup>. In any case, the SPI buses connect the following modules <sup id="bibref:50"><a href="#bib:io-spi_devices" role="doc-biblioref">[50]</a></sup>:</p><ul><li>The flash memory found inside 3DS game cards, for storing save data.</li><li>DS’ Power Management.</li><li>Parts of the Wi-Fi chip.</li><li>Touch screen.</li><li>Sound.</li><li>Microphone.</li><li>Circle Pad.</li></ul><p>Curiously enough, some peripherals are interfaced twice to replicate the old DS/DSi’s I/O layout and also provide extended capabilities for 3DS software.</p><p>Secondly, there’s a <strong>Human-interface device</strong> (HID) module connected to both ARM11 and ARM9 data buses. This is how the digital keypad is accessed. The data is read through a 16-bit register.</p><p>Moving on, we got an <strong>I²C</strong> block which uses a more sophisticated serial protocol. This is connected to the following <sup id="bibref:51"><a href="#bib:io-i2c_devices" role="doc-biblioref">[51]</a></sup>:</p><ul><li>Front camera, also works in DSi mode.</li><li>Two back cameras, the right camera is accessible in DSi mode as well.</li><li>Infrared transceiver.</li><li>The NFC interface, in the case of the New 3DS.</li><li>The ‘QTM’ module, used for head-tracking (New 3DS only).</li><li>Gyroscope.</li><li>MCU chip, a separate controller that interfaces more components (explained in the next section).</li></ul><p>Finally, there are various <strong>registers</strong> interfacing FIFO blocks which, in turn, connect to two relatively high-speed (16 MB/s) peripherals <sup id="bibref:52"><a href="#bib:io-misc" role="doc-biblioref">[52]</a></sup>:</p><ul><li>Internal eMMC memory.</li><li>SD card slot.</li></ul><p>As confusing as it may sound, there’s more hardware left to discuss. The rest is handled by a middle-man chip called <strong>Auxiliary Microcontroller</strong> (MCU) <sup id="bibref:53"><a href="#bib:graphics-hardware" role="doc-biblioref">[53]</a></sup>. This is just a microcontroller designed by NEC and manufactured by Renesas. Particularly, the <strong>model 78K0R</strong>, which bundles a proprietary (yet low-power and relatively modern) processor and a ROM <sup id="bibref:54"><a href="#bib:io-renesas" role="doc-biblioref">[54]</a></sup>. The 78K0R stores a firmware handled by the console’s operating system, both ARM9 and ARM11 can interact with it but so do other peripherals.</p><p>The MCU chip exclusively controls the following <sup id="bibref:55"><a href="#bib:graphics-hardware" role="doc-biblioref">[55]</a></sup> <sup id="bibref:56"><a href="#bib:io-i2c_mcu" role="doc-biblioref">[56]</a></sup>:</p><ul><li>Accelerometer.</li><li>LCD screens.</li><li>LED indicators.</li><li>Power Management.</li><li>Battery fuel gauge and rejection (whether to enable the charging circuitry or not).</li><li>Wi-Fi’s EEPROM.</li><li>Real-Time Clock (RTC).</li><li>3D slider and Wi-Fi switch, the latter is only found on old 3DS models.</li><li>HOME and power buttons.</li></ul><p>A subset of this group is already accessible by the main CPUs. This is because the MCU also perform monitoring tasks, thereby saving resources from the ARM11 or ARM9.</p><h3 id="ready-for-trends">Ready for trends</h3><p>With such a heavy list of I/O hardware, you can now see how Nintendo tried to compete against the smartphone market. This led to interesting services deployed throughout the console’s lifecycle:</p><ul><li>A <strong>QR Reader</strong> bundled with the camera app.</li><li><strong>AR Games</strong>: Nintendo shipped ‘AR Cards’ that could be scanned with the 3DS camera using an app called ‘AR Games’. This would make static Nintendo characters pop up in your room, like any traditional augmented-reality-based application.</li><li><strong>Face Riders</strong>: Another camera-based app, but in this case, takes a photo of the player to compose the game’s characters. The player must then use the gyroscope and microphone to battle his/her evil clones.</li><li><strong>Amiibos</strong>: Uses the NFC reader to scan figurines and unlock game bonuses, the same service was also <a href="https://www.copetti.org/writings/consoles/wiiu/#the-supplemental-interface">implemented in the Wii U</a>.</li><li><strong>SpotPass</strong>: The continuation of <a href="https://www.copetti.org/writings/consoles/wii/#games">WiiConnect24</a>, now automatically connects to unsecured Wi-Fi access points.</li><li><strong>StreetPass</strong>: Automatically exchanges data between nearby 3DS systems. Nintendo marketed it as a way of connecting random 3DS players on the street.</li><li><strong>Play Coins</strong>: Unlocks game content by doing some exercise (walking).</li></ul><hr/><h2 id="operating-system">Operating System</h2><p>Having a large number of CPUs eventually impacts the overall complexity of the operating system. Not only that, but this console also stores more than one OS. This originates as a mechanism for providing large services (i.e. DSi/DS/GBA backwards compatible, rescue mode, etc.).</p><p>So, to avoid making this section any more confusing, let’s go by steps.</p><h3 id="architecture">Architecture</h3><p>The Nintendo 3DS, as a whole, comes with four firmware <sup id="bibref:57"><a href="#bib:operating_system-firm" role="doc-biblioref">[57]</a></sup>:</p><ul><li><strong>NATIVE_FIRM</strong>: Operates the console in ‘native’ mode (with the functionality exclusive to the Nintendo 3DS). Here, the ARM11 executes the main program.<ul><li>Curiously enough, there are two instances of NATIVE_FIRM installed (named <strong>FIRM0</strong> and <strong>FIRM1</strong>, respectively) in case the first one gets corrupted, for some reason.</li><li>This firmware is often referred to as ‘Horizon’ as well.</li></ul></li><li><strong>TWL_FIRM</strong>: It commands the Nintendo 3DS to behave like a Nintendo DSi. It does come at the expense of disabling all the exclusive features, but considering how the CPU, GPU, sound and I/O are intertwined; TWL_FIRM is truly a work of art. Consequently, the ARM9 and ARM7 are placed in the foreground (they execute the main program) <sup id="bibref:58"><a href="#bib:operating_system-gbatek_firm" role="doc-biblioref">[58]</a></sup>.<ul><li>The name ‘TWL’ comes from the codename of the Nintendo DSi.</li></ul></li><li><strong>AGB_FIRM</strong>: Similarly to TWL_FIRM but the 3DS now becomes a Game Boy Advance. Here, the ARM7 executes the main program.</li><li><strong>SAFE_FIRM</strong>: Used solely for maintenance-related tasks, such as system updates. This firmware is basically an early revision of NATIVE_FIRM (doesn’t go beyond version <code>3.0</code> on the old 3DS and version <code>8.1</code> on the New 3DS <sup id="bibref:59"><a href="#bib:operating_system-safehax" role="doc-biblioref">[59]</a></sup>).</li></ul><p>All of these firmware come with separate binaries for the ARM11, ARM9 and ARM7 CPUs. The only exception is that the ARM7 won’t be active under NATIVE_FIRM and SAFE_FIRM.</p><p>Generally speaking, the Nintendo 3DS will first launch a Boot ROM and then bootstrap NATIVE_FIRM. Afterwards, the running operating system may choose to reboot to another firmware based on the user’s actions (i.e. load a Nintendo DS game or run the firmware update assistant).</p><p>Let’s take a look now at how each CPU behaves in NATIVE_FIRM mode.</p><h4 id="the-security-processor">The security processor</h4><p>Once NATIVE_FIRM is bootstrapped, the ARM9 runs its own operating system made of a kernel called <strong>Kernel9</strong> and a single program called <strong>Process9</strong> <sup id="bibref:60"><a href="#bib:operating_system-overview" role="doc-biblioref">[60]</a></sup>.</p><p>Kernel9’s design follows the <strong>microkernel</strong> model, meaning it only provides essential abstraction with the hardware, including:</p><ul><li>Memory management.</li><li>Process scheduling.</li><li>Inter-Process Communication.</li></ul><p>On the other side, Process9 is a userland application that implements these services:</p><ul><li>Communication with the ARM11, called ‘PXI’.</li><li>Cryptography-related functions. This involves AES, RSA, SHA and ECDSA.</li><li>I/O management.</li><li>File System.</li><li>Title (3DS software) verification and installation.</li></ul><p>Both Kernel and Process9 reside on an ARM9-only block of 1 MB of SRAM (1.5 MB in the case of the New 3DS).</p><p>In terms of security, there’s no privilege distinction between Kernel9 and Process9, since the latter has unconditional access to a system call that runs arbitrary code in kernel mode.</p><p>In summary, combined with the exclusive I/O hardwired into the ARM9, this CPU has the role of a <strong>security processor</strong>, much like what the <a href="https://www.copetti.org/writings/consoles/wii/#the-hidden-co-processor">Wii and Wii U’s ARM9</a> also did, and unlike the <a href="https://www.copetti.org/writings/consoles/nintendo-ds/#design">co-processor architecture</a> of the Nintendo DS, where its second processor just offloaded I/O and audio tasks.</p><h4 id="the-user-processor">The user processor</h4><p>Likewise, the ARM11 runs a kernel of similar architecture to the ARM9 one (now called <strong>Kernel11</strong>). The big difference is that the ARM11 will be running multiple userland processes, and in doing so they provide services like:</p><ul><li>Communication with the ARM9, called ‘PXI’.</li><li>Multi-core processing.</li><li>Networking, HTTP and SSL.</li><li>Connection with Nintendo online infrastructure.</li><li>The graphical shell (called ‘HOME Menu’).</li><li>The ability to launch applications.</li><li>A layer of abstraction for apps called <strong>Services</strong>, which games must call to access hardware resources. Some components like the GPU are interfaced by a very thin API, nonetheless.<ul><li>Furthermore, services are implemented in a layered manner. Games only access a subset of these, and the latter in turn invokes greater privileged and specialised services.</li></ul></li></ul><p>The ARM11’s kernel resides on a dedicated block 512 KB of SRAM <sup id="bibref:61"><a href="#bib:operating_system-glossary" role="doc-biblioref">[61]</a></sup>, also called ‘AXI Work RAM’ or ‘AXI WRAM’, because it’s connected to the ARM11 using the AXI protocol.</p><h4 id="imposed-behaviour">Imposed behaviour</h4><p>Now for the bitter news, NATIVE_FIRM also enforces unusual restrictions on user programs.</p><figure><a href="https://www.copetti.org/images/consoles/nintendo3ds/os_levels.a8d96b55f3e7dd4e555220d3bbcf9a0dff72eb90418a51175a6abac405813dd3.png"><picture><img alt="Image" width="761" height="519" src="https://www.copetti.org/images/consoles/nintendo3ds/os_levels.a8d96b55f3e7dd4e555220d3bbcf9a0dff72eb90418a51175a6abac405813dd3.png" loading="lazy"/></picture></a><figcaption>Overview of the privilege levels in the Nintendo 3DS running NATIVE_FIRM, after combining both operating systems.</figcaption></figure><p>To start with, the ARM11’s scheduler is hard-coded with specific behaviour for each core (as opposed to treating every core as general-purpose units):</p><ul><li>The first core, called <strong>appcore</strong>, is for the game to use. Yet, its thread scheduling policy is FIFO, meaning that the game can deadlock itself if multi-threading is improperly used <sup id="bibref:62"><a href="#bib:operating_system-multithreading" role="doc-biblioref">[62]</a></sup>.</li><li>The second core, called <strong>syscore</strong>, gets assigned system-related tasks.</li></ul><p>Conversely, syscore can lend 30% of its execution time to user applications, which may be helpful to offload some operations, although not every routine may work under syscore (especially time-sensitive ones) <sup id="bibref:63"><a href="#bib:operating_system-dsx86" role="doc-biblioref">[63]</a></sup>.</p><p>The curtailment is further extended with the New 3DS, whose ARM11 MPCore now comes with four cores, namely:</p><ul><li><strong>The fourth MP11 is solely used for face-tracking</strong>. Instead of adding circuitry, Nintendo engineers implemented face-tracking through pure software. Thus, it reserves one MP11 for this. I’m guessing this was a cost-effective solution for Nintendo.</li><li><strong>The third MP11 core is permanently idle</strong>, as the scheduler is never instructed to dispatch threads there. Game meta-data does include a flag to enable thread scheduling on this core, albeit its usage on any commercial game is yet to be confirmed. It’s highly possible that at one point Nintendo considered it, but ultimately rendered it unfeasible for battery consumption reasons, or maybe because single-core games would suffer some compatibility issue.<ul><li>Considering the New Nintendo 2DS XL is a New Nintendo 3DS without the stereoscopic screen, that means half of its quad-core CPU is wasted!</li></ul></li><li>CDMA, the ‘New’ DMA unit, is only accessible during the console’s boot <sup id="bibref:64"><a href="#bib:operating_system-dma" role="doc-biblioref">[64]</a></sup>. After the boot process finishes, <strong>CDMA is never used again</strong>.</li></ul><p>Moving on, in terms of usable RAM for games, we know that the Nintendo 3DS and New Nintendo 3DS come with 128 MB and 256 MB of FCRAM, respectively. What you need to know now is that the available RAM for apps is only <strong>64 MB</strong> and <strong>124 MB</strong> <sup id="bibref:65"><a href="#bib:operating_system-memory" role="doc-biblioref">[65]</a></sup>, respectively. This means that the OS consumes ~50% of the console’s main memory, not a particularly pleasant quality! To alleviate this, games also have the option to set a flag in their metadata (called <code>APPMEMTYPE</code>) to claim more FCRAM from the system, up to <strong>96 MB</strong> and <strong>176 MB</strong>, respectively. Behind the scenes, that flag instructs the system to reboot the console and boot the game without launching the HOME Menu beforehand, saving memory in the way.</p><p>All things considered, you can now sense how not all extra hardware in the New 3DS will automatically imply faster software. It’s a shame, and it gives me the feeling that the New 3DS was a rushed product, from the software perspective. But to be fair, Nintendo never planned the ‘New’ 3DS to be a full successor of the original 3DS. The ‘New’ brand was a clear move to refresh the 3DS line, considering the sales number wasn’t satisfying, to say the least.</p><h3 id="storage-medium">Storage Medium</h3><p>Now that we know how the operating system is designed, let’s look at where and how data is stored in this console.</p><div><ul><li id="tab-6-1-boot-roms-link"><a href="#tab-6-1-boot-roms">Boot ROMs</a></li><li id="tab-6-2-otp-memory-link"><a href="#tab-6-2-otp-memory">OTP memory</a></li><li id="tab-6-3-emmc-nand-link"><a href="#tab-6-3-emmc-nand">eMMC NAND</a></li><li id="tab-6-4-sdmicrosd-link"><a href="#tab-6-4-sdmicrosd">SD/microSD</a></li></ul><div><div id="tab-6-1-boot-roms"><h4 id="tab-6-1-boot-roms">Boot ROMs</h4><p>Following its long ancestor, the <a href="https://www.copetti.org/writings/consoles/game-boy/#cpu">Game Boy</a>, the SoC stores a series of unencrypted ROMs containing the programs used for booting up NATIVE_FIRM <sup id="bibref:66"><a href="#bib:operating_system-bootloader" role="doc-biblioref">[66]</a></sup>. These bootstrappers are called <strong>Boot9</strong> and <strong>Boot11</strong>; and are executed by the ARM9 and ARM11, respectively. Likewise, they are physically and virtually kept hidden for security reasons. To give you an example, Boot9 stores AES decryption keys, which are not something to carelessly leave anywhere.</p><p>Interestingly enough, Boot9’s code has revealed that it’s more capable than just bootstrapping NATIVE_FIRM from eMMC NAND. However, due to certain routines having hardcoded directories and security layers added on top, the only firmware the Boot ROMs can ultimately load is NATIVE_FIRM from eMMC NAND.</p><p>Moreover, while multiple components have changed with the arrival of the New 3DS, the BootROMs have not changed a bit <sup id="bibref:67"><a href="#bib:operating_system-boot" role="doc-biblioref">[67]</a></sup>.</p></div><div id="tab-6-2-otp-memory"><h4 id="tab-6-2-otp-memory">OTP memory</h4><p>To further increase the level of security, the console stores a series of console-unique information in <strong>One-Time-Programmable</strong> (OTP) memory <sup id="bibref:68"><a href="#bib:operating_system-otp" role="doc-biblioref">[68]</a></sup>. Similarly to the <a href="https://www.copetti.org/writings/consoles/wii/#tab-7-1-shared-encryption">Wii</a> and <a href="https://www.copetti.org/writings/consoles/wiiu/#tab-7-1-dedicated-hardware">Wii U</a>, this information also includes encryption keys.</p><p>OTP is written once during manufacturing, so the keys differ between each console. Hence, one hacked console won’t necessarily be able to compromise the rest. This is a significant milestone for a portable console, considering a certain <a href="https://www.copetti.org/writings/consoles/nintendo-ds/#tab-10-1-encryption-system">previous implementation</a> included global keys.</p></div><div id="tab-6-3-emmc-nand"><h4 id="tab-6-3-emmc-nand">eMMC NAND</h4><figure><a href="https://www.copetti.org/images/consoles/nintendo3ds/photos/emmc.8c2a1c478ffded9127a1389a411ec8ff8eb6b16c39a7ebc62f693480261828e4.webp"><picture><img alt="Image" width="900" height="699" src="https://www.copetti.org/images/consoles/nintendo3ds/photos/_hua5f2cd62267f437d12e49c5b8a374e56_58072_86c90e2811a715b2aa2a3980f340716e.png" loading="lazy"/></picture></a><figcaption>Samsung-made eMMC chip on the original 3DS.</figcaption></figure><p>Next to the big SoC, there’s an eMMC NAND Flash chip. However, its size is slightly different depending on the manufacturer <sup id="bibref:69"><a href="#bib:operating_system-fs" role="doc-biblioref">[69]</a></sup>. For instance, Toshiba supplied <strong>943 MB</strong> and <strong>1,888 MB</strong> chips, while Samsung provided ones with <strong>954 MB</strong> and <strong>1,240 MB</strong>.</p><p>To tackle this disparity, Nintendo defined the 3DS partition table using a common size: <strong>943 MB</strong> for Old 3DS (Toshiba-size) and <strong>1,240 MB</strong> (Samsung-size) for New 3DS. So, if your console came with a larger eMMC chip, the extra space is unfortunately left unemployed.</p><p>In any case, the console relies on eMMC for storing its system data, including the multiple firmware, and user data (saves and configs within 3DS and DSi mode).</p></div><div id="tab-6-4-sdmicrosd"><h4 id="tab-6-4-sdmicrosd">SD/microSD</h4><p>Once an optional (and sometimes, symbolic) medium, SD cards now enjoy similar responsibilities to internal storage, as the 3DS is dependent on it to download software from the eShop and store user data (game saves, camera pictures and microphone recordings) <sup id="bibref:70"><a href="#bib:operating_system-sd" role="doc-biblioref">[70]</a></sup>.</p><p>Software and user data stored here are protected with AES-128-CTR encryption.</p></div></div></div><h3 id="boot-process">Boot process</h3><p>Now that we know how the operating system is structured and where data is stored, let’s see how the Nintendo 3DS goes from a glossy powered-off brick to becoming an operating console offering multiple services.</p><h4 id="multi-core-chaos">Multi-core chaos</h4><p>Considering the 3DS must be able to manage four processors (2-core ARM11 + ARM9 + ARM7) in its SoC - or six, if you look at the New 3DS - one can only wonder how these ‘central’ processors suddenly become exceptionally coordinated during the console’s startup. Well, it’s all about implementing a master-slave hierarchy.</p><p>With the ARM9 and ARM7, there’s not a lot of room for doubt, both can be powered on separately and load different binaries. So the challenge is mainly focused on disseminating the homogenous multi-core ARM11.</p><p>In the ARM11 MPCore cluster, all cores start execution at vector <code>0x00000000</code> <sup id="bibref:71"><a href="#bib:cpu-arm_reference" role="doc-biblioref">[71]</a></sup>. However, CP15 (the System Control co-processor) provides a register called <code>CPU ID</code> which, among other things, serves to identify the core currently executing instructions. Thus, programmers can query this register to decide whether the current CPU core should give orders (master) or wait for commands (slave). ARM later improved this technique by supplying a dedicated register called <code>mpidr</code>, found in ARMv7 CPUs.</p><p>Thanks to this, Nintendo engineers were able to identify any CPU core within the 3DS cluster and implement a bootloader where all cores become coordinated, and then carry out the necessary functions to bring the console to life.</p><h4 id="boot-procedure">Boot procedure</h4><p>Time to dive into the boot process. As with any other console of its generation, security is of great importance, which will have an impact on the boot stage. To avoid making this section too dense, I’ve simplified the stages where the security system is set up, but you’ll find more information in the ‘Anti-piracy’ section.</p><p>Having said that, once the console is powered on, the following sequence of events takes place <sup id="bibref:72"><a href="#bib:operating_system-boot" role="doc-biblioref">[72]</a></sup> <sup id="bibref:73"><a href="#bib:operating_system-bootrom" role="doc-biblioref">[73]</a></sup>:</p><ol><li>The ARM9 and ARM11 power up.</li><li>The ARM9’s reset vector is at address <code>0xFFFF0000</code>, which points to Boot9 <sup id="bibref:74"><a href="#bib:operating_system-memory" role="doc-biblioref">[74]</a></sup>. The ARM11 is induced in an infinite reset until its reset pin is lifted.</li><li>Boot9 clears ARM11’s reset pin and then initialises the ARM9’s MPU.</li></ol><p>The ARM11 MPCore will now start execution of Boot11 in parallel:</p><ol><li>ARM11’s reset vector is at address <code>0x00000000</code> <sup id="bibref:75"><a href="#bib:cpu-arm_reference" role="doc-biblioref">[75]</a></sup>, which happens to be in the same place as Boot11.</li><li>Boot11 will branch depending on which core is it being executed on. If it’s greater than core 2, it hangs indefinitely.</li><li>Wait until ARM9 is finished bootstrapping a firmware</li></ol><p>Meanwhile, the ARM9 will be busy continuig with Boot9 execution:</p><ol start="4"><li>The AES and RSA public keys are exported to the AES and RSA engines (these will be explained in the ‘Anti-piracy’ section).</li><li>Boot9 will try to boot from NAND.<ol><li>In NAND, there’s a partition at location <code>0x0</code> called ‘NCSD header’, this states that there are eight partitions, each with a firmware to boot from.</li><li>For each firmware partition listed, Boot9 will fetch its header, validate the SHA-256 hash and RSA-2048 signature (using a set of keys previously loaded from BootROM) and repeat this process until one validation succeeds. Then, it will boot from there.</li></ol></li><li>If all validations in NAND fail, Boot9 will try to boot from a Flash memory in the Wi-Fi module. If that also fails, the console will display an error screen.</li><li>The first partition validated happens to contain NATIVE_FIRM. Boot9 will proceed to copy the firmware to different memory areas based on the header’s parameters.</li><li>Disable half of Boot9 and Boot11. In doing so, FCRAM will be accessible.</li><li>Redirect ARM9 and ARM11’s execution to the firmware’s entry points.</li></ol><p>Now that NATIVE_FIRM is bootstrapped:</p><ol><li>The ARM9 will:<ol><li>Load Kernel9.</li><li>Kernel9 hides OTP memory and loads Process9.</li><li>The ARM9 CPU is now up and running Process9.</li></ol></li><li>Whilst the ARM11 does the following:<ol><li>Load Kernel11.</li><li>In the case of the New 3DS, Kernel11 will write to a new register called <code>CFG11_BOOTROM_OVERLAY_CNT</code> to overlay Boot11 code <sup id="bibref:76"><a href="#bib:operating_system-pdn" role="doc-biblioref">[76]</a></sup>. This will allow to redirect execution of the new ARM11 cores (core 3 and core 4) away from Boot11 to arbitrary functions in Kernel11, thereby taking control of them.</li><li>Kernel11 will start various system processes, including PM (Process Manager).</li><li>PM will start the ‘NS’ (Nintendo User Interface Shell) system module.</li><li>NS will either launch a game or the HOME Menu application.</li><li>The user is now in control.</li></ol></li></ol><h4 id="alternative-boot-processes">Alternative boot processes</h4><p>All of the previous explanations have been focused on booting up NATIVE_FIRM, which results in the traditional native 3DS mode. For other firmware such as TWL_FIRM, AGB_FIRM and SAFE_FIRM, it’s a bit more complicated. Turns out the previous boot process is still needed because only NATIVE_FIRM can be booted from a power cycle. But once this is running, it can bootstrap any of those firmware, and each will program the ARM9 differently. In either case, the security set-up during Boot9 will still be enforced.</p><p>TWL_FIRM and AGB_FIRM, in particular, operate a special set of registers that mould the 3DS hardware and memory layout in accordance with what DS, DSi or GBA games expect to find. FCRAM can still be accessed, allowing to boot a game ROM from those places as well (apart from the NTR card reader). However, FCRAM will be reconfigured to follow the DS and GBA bus specification (16-bit wide, instead of 32-bit).</p><p>A big difference about the backwards compatible firmware is that, at last, the ARM7 will be active (as Nintendo DSi/DS and GBA software require it).</p><p>To exit either mode, non-NATIVE firmware contain a routine that reboots the system and consequently returns it to NATIVE_FIRM. Thus, 3DS mode.</p><h3 id="interactive-shell">Interactive shell</h3><p>The 7th generation of console interfaces has landed on the Nintendo 3DS. A clear indication is that users don’t need a retail game to make the most out of their console, just navigate through the shell and you’ll find numerous apps and services bundled. This includes the special offering of this console (3D camera, stereoscopic view and augmented reality). The pressure to compete against smartphones couldn’t be clearer.</p><p>In terms of user interface design, I’m inclined to say there are many patterns borrowed from the <a href="https://www.copetti.org/writings/consoles/wii/#broadways-os">Wii System Menu</a>, yet ported to a dual-screen portable system. The <strong>HOME Menu</strong> (name of the interactive shell) uses a 1-page navigation system where every installed application is shown on a scrollable grid. Except for a few shortcuts here and there, every service is an application to be launched.</p><p>Now, being a Nintendo product, you can expect a special focus on creativity and attention to detail. Families are the target audience, nevertheless, adults are the ones paying, and Nintendo knows that.</p><h4 id="maintaining-consistency">Maintaining consistency</h4><p>The NS module is not only responsible for launching the interactive shell, it also offers 3DS software with the ability to invoke routines to handle certain interactions. One example is the ‘Back to HOME Menu’ overlay, which must be shown whenever the user presses the ‘HOME’ button.</p><figure><a href="https://www.copetti.org/images/consoles/nintendo3ds/shell/back_home.2ce3303f63dc4e934fb2426840b63819f305e9727fd44f5ff4de45a7c927d4c4.png"><picture><img alt="Image" width="400" height="480" src="https://www.copetti.org/images/consoles/nintendo3ds/shell/back_home.2ce3303f63dc4e934fb2426840b63819f305e9727fd44f5ff4de45a7c927d4c4.png" loading="lazy"/></picture></a><figcaption>Users can press the ‘HOME’ button midgame, this will reinstate the HOME Menu without closing the current application. This event is handled by the running application but the routines are provided by the NS service.</figcaption></figure><p>Furthermore, 3DS software may also invoke ‘mini applications’ for attending other events (i.e. show the virtual keyboard), these are known as <strong>Applets</strong> <sup id="bibref:77"><a href="#bib:operating_system-ns" role="doc-biblioref">[77]</a></sup>.</p><p>Both sets are a crucial dependency for all applications, as they are responsible for properly reacting to external events consistently. Interestingly enough, since Applets and NS routines are not part of the game itself, in the case of New 3DS systems, even if a game is running in compatibility mode (that is, with all the ‘New’ hardware disabled), they will still be executed using the full extend of hardware, giving a small performance boost to unoptimised 3DS games.</p><h4 id="the-legacy-shell">The legacy shell</h4><p>Whilst the special firmware includes the <a href="https://www.copetti.org/writings/consoles/game-boy-advance/#operating-system">old BIOS routines</a> DS/GBA games will expect, there’s no DS or DSi shell in sight.</p><p>The old <strong>Wi-Fi setup screens</strong> (invoked by DSi and DS games) are the only exceptions. Interestingly enough, while the original DS Wi-Fi settings are useless (as they can only connect to WEP-protected access points), the DSi counterpart (accessed from DSi and ‘DSi enhanced’ DS games) can alter the 3DS’ Wi-Fi settings. Yet, these games bundle an old Wi-Fi driver that only worked with the real DSi (the 3DS contains an Atheros AR6014 while the DSi came with an Atheros AR6002 or AR6013). So, to tackle this, both Wi-Fi settings are automatically synced when the firmware boots up <sup id="bibref:78"><a href="#bib:operating_system-firm" role="doc-biblioref">[78]</a></sup>.</p><h4 id="updatability">Updatability</h4><p>Well, of course, an updatable system is pretty much a requirement, not only for providing new functionality but also from a security perspective.</p><p>You can update the system software either online or through a game cartridge. Confusingly enough, both contain different update packages. Game cartridges only bundle system updates without the updated user apps, whereas network updates include everything <sup id="bibref:79"><a href="#bib:operating_system-home" role="doc-biblioref">[79]</a></sup>. Consequently, version names encode a mix of the two, in case the user used both channels.</p><p>To install updates, the NS service reboots into <code>SAFE_FIRM</code>, where the <strong>System Updater</strong> takes care of this process <sup id="bibref:80"><a href="#bib:operating_system-settings" role="doc-biblioref">[80]</a></sup>.</p><hr/><h2 id="games">Games</h2><p>It’s time to check how game development and distribution were carried out. Additionally, we’ll see some exclusive services Nintendo prepared for this console.</p><h3 id="development-ecosystem">Development ecosystem</h3><p>Before the Nintendo 3DS arrived, developing for embedded system involved monumental efforts and high levels of patience. Compared to desktop applications, the tooling wasn’t standardised and sometimes it didn’t converge well with each other (ActiveSync is the clearest example I remember). The range of documentation didn’t usually go beyond what the manufacturer provided, the same applied for technical support.</p><p>Enter the 2010s decade, coinciding with the influx of an ARM-based smartphone industry and more efficient compilers, development for those platforms was no longer a complicated endeavour. Consequently, game studios developing for the Nintendo 3DS were able to enjoy this evolution. Now, Nintendo was not providing a standard toolchain yet, but they were on the right track (finally reached with the Nintendo Switch).</p><p>Curiously enough (and this is an interesting contrast), back in 2011, Apple offered Clang/LLVM 1.3 and OpenGL ES 3.0 for developing iOS apps, this was considered state-of-the-art for mobile projects. Well, you’ll see throughout this section that this wasn’t the case for Nintendo. Yet, at present, if you grab an old iPhone 4s and try to install any app on the App Store (its only official medium), it will tell you your system is too old. Whereas you can still play any retail game on your 3DS. Food for thought.</p><div><ul><li id="tab-8-1-hardware-kits-link"><a href="#tab-8-1-hardware-kits">Hardware Kits</a></li><li id="tab-8-2-software-kits-link"><a href="#tab-8-2-software-kits">Software Kits</a></li></ul><div><div id="tab-8-1-hardware-kits"><h4 id="tab-8-1-hardware-kits">Hardware Kits</h4><p>Nintendo partnered with two suppliers to produce development kits <sup id="bibref:81"><a href="#bib:games-hardware" role="doc-biblioref">[81]</a></sup>. The first supplier was the well-known <strong>Intelligent Systems</strong> and the other was <strong>Kyoto MicroComputers</strong>.</p><p>Among the many options, studios could rent a general-purpose ‘CTR-BOX’. This is a metallic box housing the 3DS hardware, and connected to it is a ‘dummy’ 3DS case that serves as a controller and display. With it, developers could deploy, test and debug their code.</p><p>For more single-purpose tools, studios could get official <a href="https://www.copetti.org/writings/consoles/nintendo-ds/#tab-9-1-the-hardware">flashcards</a> to distribute game prototypes to external testers. These flashcards still only run on non-retail equipment, though this included cheaper options (with reduced functionality) than the fully-fledged CTR-BOX.</p><p>With the arrival of the New 3DS, IS and Partner offered the ‘SNAKE’ kits with updated hardware.</p></div><div id="tab-8-2-software-kits"><h4 id="tab-8-2-software-kits">Software Kits</h4><p>As always, licensed studios would also get an SDK package from Nintendo which included <sup id="bibref:82"><a href="#bib:games-software" role="doc-biblioref">[82]</a></sup>:</p><ul><li>A variant of <code>armcc</code> (ARM’s <strong>C</strong> and <strong>C++ compiler</strong>) modelled for the Nintendo 3DS and the ARM11 MPCore.<ul><li>This will just produce code for the ARM11 MPCore. Both ARM9 and ARM7 are out of the equation, as 3DS games only run within the ARM11 cluster.</li></ul></li><li><strong>Debuggers</strong> made for IS and Partner’s development kits.</li><li><strong>APIs</strong> to communicate with the hardware and operating system’s services.</li><li>Four <strong>graphics libraries</strong>:<ul><li><strong>GL</strong>: a simpler but slower OpenGL ES API.</li><li><strong>GD</strong>: a faster alternative to GL that generates PICA200 commands.</li><li><strong>GR</strong>: the closest-to-metal PICA200 command API, albeit with the steepest learning curve.</li><li><strong>GX</strong>: the general-purpose library used for PICA200 management.</li></ul></li><li>A 3DS <strong>app packager</strong>, so an executable can be created.</li><li>Further libraries to ease common development tasks, such as implementing network protocols, online gaming and audio/video decoding and processing.</li><li>A plugin for <strong>Visual Studio 2010</strong>, so it can be adopted as the main IDE.</li><li><strong>Assistant tools</strong> for the PICA200.</li><li><strong>Profilers</strong>, for measuring and optimising performance.</li></ul><p>If that wasn’t enough, developers also had access to NintendoWare to download code samples, libraries and further tools designed for Nintendo 3DS development. Furthermore, with the arrival of the New 3DS, game engines like Unity lent their support to this (once ignored) platform <sup id="bibref:83"><a href="#bib:games-unity" role="doc-biblioref">[83]</a></sup>.</p></div></div></div><h3 id="medium">Medium</h3><p>The Nintendo 3DS can run software from three different mediums.</p><div><ul><li id="tab-9-1-gamecards-link"><a href="#tab-9-1-gamecards">Gamecards</a></li><li id="tab-9-2-eshopsd-card-link"><a href="#tab-9-2-eshopsd-card">eShop/SD Card</a></li><li id="tab-9-3-local-wireless-link"><a href="#tab-9-3-local-wireless">Local wireless</a></li></ul><div><div id="tab-9-1-gamecards"><h4 id="tab-9-1-gamecards">Gamecards</h4><figure><a href="https://www.copetti.org/images/consoles/nintendo3ds/photos/gamecard.7848bd8ebfd8dcfe983d8f2883ce66afafff32cbd45fd9742c0a8161b400692c.webp"><picture><img alt="Image" width="815" height="571" src="https://www.copetti.org/images/consoles/nintendo3ds/photos/_hu73e8e42e37f2e81f9775ed553ee0b728_42910_ac83099bc32b8ab4125c6c805b799620.png" loading="lazy"/></picture></a><figcaption>Example of a retail game. Notice the creative touch with Luigi holding onto the 3DS banner.</figcaption></figure><p>This is the distribution channel for retail software. Internally called ‘CTR cards’, they’re just another proprietary card/cartridge designed by Nintendo. To be fair, they’re not very different from <a href="https://www.copetti.org/writings/consoles/nintendo-ds/#games">NTR Cards</a> (used by the Nintendo DS), aside from a cosmetic notch at the top right. Inside them, there is read-only and/or writable storage.</p><p>The variants of CTR cards range drastically. Their PCB can bundle a ROM chip ranging from <strong>128 MB</strong> to <strong>4 GB</strong> in size, while also including some ‘backup memory’ to store saves, this can be either <strong>128 KB or 512 KB</strong>. In other variants, the whole CTR storage is instead filled with <strong>Flash</strong> (up to 2 GB), and it’s partitioned to store both the game and saves in the same physical chip.</p><p>Moreover, since games will be bundling the official SDK as well, the usable capacity of ROM/RAM allowed to the game depends on the revision of the SDK linked to.</p><p>Internally, the ROM chip is connected to an 8-bit data bus <sup id="bibref:84"><a href="#bib:games-gamecards" role="doc-biblioref">[84]</a></sup>, while the backup memory relies on a serial bus. Both are connected to a 16.6 MHz clock. When the card is inserted into the console, the 3DS first queries it using NTR (Nintendo DS) commands <sup id="bibref:85"><a href="#bib:games-card_registers" role="doc-biblioref">[85]</a></sup>, and then switches to ‘CTR mode’ once it detects it’s a 3DS card.</p></div><div id="tab-9-2-eshopsd-card"><h4 id="tab-9-2-eshopsd-card">eShop/SD Card</h4><figure><a href="https://www.copetti.org/images/consoles/nintendo3ds/store/store_mario.68333a025886ba2f935c53f3da7502b46a56678e36170d0b904ac02ec8320e2c.png"><picture><img alt="Image" width="400" height="480" src="https://www.copetti.org/images/consoles/nintendo3ds/store/store_mario.68333a025886ba2f935c53f3da7502b46a56678e36170d0b904ac02ec8320e2c.png" loading="lazy"/></picture></a><figcaption>The Nintendo eShop store for the Nintendo 3DS.</figcaption></figure><p>Expandable storage, an icon of the 8th generation of consoles. The Nintendo 3DS now enjoys installing and launching software from the SD (or microSD) card; and with it, retail cards are no longer the only medium for games. In fact, SD storage is the result of an emerging distribution channel: The Nintendo online store, bundled into every Nintendo 3DS.</p><p>Thanks to the eShop, there were new distribution techniques: users could <strong>pre-order</strong> games and DLCs before the shipping date <sup id="bibref:86"><a href="#bib:games-preorder" role="doc-biblioref">[86]</a></sup>. These would get downloaded ahead of time, but can only be played once the release date arrived.</p><p>When it comes to storing the respective saves, Nintendo allows its downloaded software to request up to <strong>1 MB</strong> of SD card storage. However, this rule is waived if the retail counterpart already requires more space, in which case the system will allocate as much ‘backup memory’ as the respective CTR card already provides.</p></div><div id="tab-9-3-local-wireless"><h4 id="tab-9-3-local-wireless">Local wireless</h4><p><strong>Download Play</strong>, a <a href="https://www.copetti.org/writings/consoles/nintendo-ds/#medium">debuting feature</a> of the Nintendo DS that enabled players to transfer small games between their consoles, has been pushed into the Nintendo 3DS. It now comes with a revamped protocol that relies on a thick security layer, in line with the rest of the software executed in the new console.</p><p>I’d say the big difference now is that transferred games (or ‘demos’, for it’s worth), are now installed into NAND (as any other installable package) <sup id="bibref:87"><a href="#bib:games-download_play" role="doc-biblioref">[87]</a></sup>. There’s only one slot reserved for them, so the installed program is replaced whenever a new game is transferred in.</p></div></div></div><h3 id="virtual-consoles">Virtual console(s)</h3><p>If, after all explained, users still got bored, Nintendo prepared another offering for them: <strong>Virtual Console</strong>.</p><p>Once again, thanks to the bundled eShop app, Nintendo also expanded its 3DS-only catalogue by incorporating games originally published for the following consoles:</p><ul><li>Nintendo DSi (DSiWare only).</li><li>NES/Famicom.</li><li><em>Sega</em> Game Gear.</li><li>Game Boy.</li><li>Game Boy Color.</li></ul><p>Virtual Console games behave as any other application installed into the console. Except for DSiWare software, the application package includes a ROM and emulator. The latter implements interesting capabilities, such as Download Play (for some games) and save states.</p><p>Once again, things were different for New 3DS users, as they could also access the <a href="https://www.copetti.org/writings/consoles/super-nintendo/">Super Nintendo</a> catalogue. This particularly strikes me as odd, as I remember a time when (homebrew) SNES emulators were developed for the original Nintendo DS (with its mere ARM9-ARM7 and a couple of megs of RAM).</p><p>Now, here’s another peculiarity of Virtual console games: this console can also play <a href="https://www.copetti.org/writings/consoles/game-boy-advance/">Game Boy Advance</a> games, officially. Yet, they’re not available for everyone. Only those who purchased a Nintendo 3DS before August 2011 (right before the console received an $80 price cut), became members of the ‘Ambassador Program’ <sup id="bibref:88"><a href="#bib:games-ambassador" role="doc-biblioref">[88]</a></sup>. One of the perks included access to a selection of GBA games which, for one reason or another, were kept exclusive until date.</p><p>Even more puzzling, GBA titles don’t run on the ARM11 using an emulator (albeit there’s one installed, but never been used!). Instead, they kickstart the third firmware, AGB_FIRM, to run natively on top of the ARM7. What makes it puzzling, is that these GBA games, only offered through the Ambassador Program, remained the only purpose of AGB_FIRM, as if Nintendo planned for something bigger in the future, but never materialised. This is another example of how the Nintendo 3DS possessed more hardware than the software ever took advantage of.</p><p>If you’re curious, GBA titles make use of the bundled ARM7 core instead. Thus, they don’t allow for the extra features that emulators (running on ARM11 cores) provide. Although, this happens at the exchange of running at full speed and precision. Be as it may, since the 3DS doesn’t contain a GBA cartridge slot, the GBA game is instead copied into FCRAM before the system reboots into AGB_FIRM, and then lets the ARM7 take control (while the ARM11 and ARM9 provide basic support tasks) <sup id="bibref:89"><a href="#bib:io-misc" role="doc-biblioref">[89]</a></sup>.</p><p>With all these capabilities, and on top of being a portable console, one can’t help but wonder why Nintendo didn’t distribute GBA and Nintendo DS/DSi games on the eShop as well. Most probably a marketing and licensing issue, I sense.</p><h3 id="game-updates">Game updates</h3><p>Another requirement of the 8th generation of consoles, games can now receive patches after the shipping date. That’s right, no more need to quality control the game before selling it!</p><p>Leaving irony aside, game updates are distributed through the eShop as well <sup id="bibref:90"><a href="#bib:games-updates" role="doc-biblioref">[90]</a></sup>, which applies to all types of games (except Download Play). All updates are downloaded onto the SD card and eShop games get their updates applied altogether (along with the game itself).</p><h3 id="network-service">Network service</h3><p>Out with the old (<a href="https://www.copetti.org/writings/consoles/nintendo-ds/#network-service">Nintendo Wi-Fi Connection</a>), in with the new (<a href="https://www.copetti.org/writings/consoles/wiiu/#network-service">Nintendo Network</a>)! The same service offered with the Wii U is also implemented on the Nintendo 3DS, and they’re admirably unified, so I recommend checking the <a href="https://www.copetti.org/writings/consoles/wiiu/#network-service">Wii U article</a> where it’s been explained in detail.</p><hr/><h2 id="anti-piracy-and-homebrew">Anti-Piracy and Homebrew</h2><p>The history of hacking this console is a long and interesting sequence of events. At first, interests focused on cracking game card readers (in an attempt to replicate the success of the <a href="https://www.copetti.org/writings/consoles/nintendo-ds/#defeat">Nintendo DS</a>) and then shifted towards more sophisticated approaches, only involving the operating system.</p><h3 id="main-targets">Main targets</h3><p>First things first, let’s start by describing the two main targets of this system:</p><ul><li>The <strong>Game/CTR card reader</strong>: This is where physical games are loaded. Historically, the Nintendo DS implemented a <a href="https://www.copetti.org/writings/consoles/nintendo-ds/#security-mechanisms">weak security mechanism</a> that was eventually cracked and subsequently led to an influx of <a href="https://www.copetti.org/writings/consoles/game-boy-advance/#flashcarts">Flashcards</a>.</li><li>The <strong>Operating System</strong>: This area is responsible for verifying the authenticity and integrity of every single program before execution (aside from the Boot ROM). Disabling said mechanisms would grant the execution of Homebrew (unauthorised applications) without any restrictions, in theory.</li></ul><p>They may look like two independent fronts (similar to the <a href="https://www.copetti.org/writings/consoles/xbox-360/#main-targets">Xbox 360</a> and <a href="https://www.copetti.org/writings/consoles/wiiu/#main-targets">Wii U</a>), but in the case of this console, both are intertwined. You’ll see it in a bit.</p><h3 id="the-card-reader-front">The card reader front</h3><p>The card reader is the interface between the CPUs and the Gamecards’ memory chip. Its only job is to simplify the communication with the use of commands.</p><p>Inside the ROM/Flash of CTR Carts, the system will find a block of data in a secured format called <strong>NCSD</strong>, this will be handled by the operating system, who will be in charge of authenticating, validating and decrypting it.</p><p>In conclusion, it seems the OS is solely responsible for the communication with the card reader, so let’s move on to the next front.</p><h3 id="the-operating-system-front">The Operating System front</h3><p>Before we continue, if you’re not familiar with symmetric and asymmetric encryption systems, I recommend reading previous articles of this series. They will also explain why systems like this rely so much on asymmetric encryption systems (such as RSA and ECDSA).</p><div><ul><li id="tab-10-1-dedicated-hardware-link"><a href="#tab-10-1-dedicated-hardware">Dedicated hardware</a></li><li id="tab-10-2-chain-of-trust-link"><a href="#tab-10-2-chain-of-trust">Chain of trust</a></li><li id="tab-10-3-operating-system-functions-link"><a href="#tab-10-3-operating-system-functions">Operating system functions</a></li></ul><div><div id="tab-10-1-dedicated-hardware"><h4 id="tab-10-1-dedicated-hardware">Dedicated hardware</h4><p>You’d be right if you suspected that the ARM11 lacks the powerhouse to protect the whole system. Nintendo knew that too, so they took extra care and bundled extra components to compensate:</p><ul><li>The ARM11 cores implement the <strong>XN flag</strong> and the ARM9 bundles a <a href="https://www.copetti.org/writings/consoles/playstation-portable/#focused-memory-management">Memory Protection Unit</a> (MPU), meaning the CPUs won’t execute code from any location in memory just because the current program tells it to.</li><li>As said before, the ARM9 acts as a <strong>dedicated processor</strong> to handle all security-related tasks while the ARM11 MPCore executes the game. Additionally, the ARM9 is exclusively wired to a few hidden <strong>cryptographic accelerators</strong>:<ul><li>An <strong>AES engine</strong> that performs AES-128 encryption/decryption without consuming (and exposing) CPU resources. This was inherited from the Nintendo DSi, but can now store up to 64 keys and can operate in numerous block cipher modes, including CTR, CCM, CBC and ECB <sup id="bibref:91"><a href="#bib:anti_piracy-aes" role="doc-biblioref">[91]</a></sup>. Each key slot also features its own <strong>key-scrambler</strong>, meaning that two arbitrary keys can be used to generate the final AES key. Moreover, the key-scrambler won’t allow anyone to read the generated key, only to treat it as a blackbox to encrypt/decrypt data.</li><li>An <strong>RSA engine</strong>. By contrast, this performs RSA encryption/decryption using a given RSA public key. This time, it only contains four key slots and there’s no key-scrambler <sup id="bibref:92"><a href="#bib:anti_piracy-crypto" role="doc-biblioref">[92]</a></sup>. However, it’s still a write-only space, meaning no one will be able to read the keys stored there. You’ll soon see that this system is filled with RSA-2048 and RSA-4096 signatures, which explains why this component is as crucial as the AES engine.</li><li>A <strong>Pseudo Random Number Generator</strong> (PRNG): These are registers that return a different value every time they’re read from.</li></ul></li><li><strong>OTP</strong> (one-time programmable) memory that stores console-unique keys, information about the console and <strong>CTCert</strong> (an ECDSA private key to authenticate with Nintendo’s servers). To complicate things further, these keys will be encrypted with an AES-CBC key found in Boot9. Finally, this region includes a flag to disable its access once it’s not needed anymore.</li><li>Last but not least, the eMMC memory contains a register called <strong>CID</strong> (Card Identification) and stores unique information about the eMMC’s manufacturing, which will be fed to the AES’ key-scrambler for further obfuscation.</li></ul><p>To top it off, everything is sealed in an SoC, including the <strong>two boot ROMs</strong> (Boot9 and Boot11). These are unencrypted, but since they’re inaccessible, they don’t represent a concern.</p></div><div id="tab-10-2-chain-of-trust"><h4 id="tab-10-2-chain-of-trust">Chain of trust</h4><p>This should come as no surprise considering we’ve already introduced RSA, AES and the boot ROM as part of the security system. To give you an overview of the Nintendo 3DS’ change of trust:</p><ol><li>ARM9’s boot ROM (Boot9) bundles the public key for decrypting and validating the contents of the NAND. The AES engine will be initialised with the keys stored in Boot9. With this, the contents of OTP memory will be accessed.</li><li>The contents of eMMC are decrypted using Boot9’s AES keys combined with the eMMC CID.</li><li>NAND and CTR cards are formatted using the <strong>NCSD</strong> format <sup id="bibref:93"><a href="#bib:anti_piracy-ncsd" role="doc-biblioref">[93]</a></sup>. NCSD stores a header and a collection of up to eight partitions. The NCSD header contains a signature using RSA-2048 and SHA-258, which is quite strong. To decrypt this signature, the system finds its public RSA key in the boot ROM or ITCM memory (the latter was previously decrypted and copied from OTP). The choice depends on where the NCSD block came from (NAND or CTR card).</li><li>Once the NCSD block is validated, the system accesses each partition. These are structured using the <strong>NCCH</strong> (Nintendo Content Container Header) format. Independently whether the data was pulled from NAND, the CTR card or the SD card, the NCCH block also contains an RSA-2048 + SHA-258 signature <sup id="bibref:94"><a href="#bib:anti_piracy-ncch" role="doc-biblioref">[94]</a></sup>, and its payload is encrypted with AES-128 CTR.</li><li>Furthermore, installed software is catalogued in the form of <strong>Titles</strong> (similar to the <a href="https://www.copetti.org/writings/consoles/wii/#broadways-os">Wii System</a>). In this case, all titles are signed with either RSA-2048, RSA-4096 or ECDSA; plus SHA256 <sup id="bibref:95"><a href="#bib:anti_piracy-titles" role="doc-biblioref">[95]</a></sup>. The public keys are stored in <code>NATIVE_FIRM</code>.<ul><li>It does surprise me that some signatures are in the form of ECDSA, considering there’s no hardware accelerator installed for it.</li></ul></li><li>Once the payload is verified and decrypted, the system will find either an executable, library or asset (i.e. manual, icon or banner) that the ARM11 can read.</li></ol><p>Please note, this explanation focuses on the main 3DS firmware (<code>NATIVE_FIRM</code>). Yet, <code>TWL_FIRM</code> and <code>AGB_FIRM</code> will also have their share of cryptography implemented.</p><p>As time passed by and hackers got the handle on how this console was protected, Nintendo shuffled the chain of trust further to deter the decryption of NCCH data. In some ways, it achieved its purpose, but in others, Nintendo ended up revealing too much. You’ll see it in the following sections.</p></div><div id="tab-10-3-operating-system-functions"><h4 id="tab-10-3-operating-system-functions">Operating system functions</h4><p>Once <code>NATIVE_FIRM</code> is up and running, in addition to the aforementioned chain of trust, the following security mechanisms are present:</p><ul><li>User programs only access hardware functions through system calls, authorised at Kernel11’s discretion. Depending on the hardware, it will also involve Kernel9.</li><li>From an architecture perspective, ARM11 user programs are completely unaware of the ARM9 and its neighbouring components.</li><li>User applications are <strong>sandboxed</strong>, meaning they can’t access each other’s space.</li><li>Last but not least, with the increase in online services, users will require a legitimate game card and an updated firmware to access the new functions. This will deter users who may consider keeping their console on a vulnerable firmware.</li><li>Software downloaded from the eShop also comes with its quirks. In this scenario, the license of a Title is encoded in the form of a <strong>Ticket</strong> which, again, is signed with RSA-2048 and SHA-256 <sup id="bibref:96"><a href="#bib:anti_piracy-cdn" role="doc-biblioref">[96]</a></sup>. Tickets are either linked to a single console ID and the eShop’s user account; or made global for any console. Furthermore, Nintendo uses additional RSA certificates in the downloaded Title’s metadata to further enlarge the chain of trust <sup id="bibref:97"><a href="#bib:anti_piracy-tmd" role="doc-biblioref">[97]</a></sup>.</li></ul></div></div></div><h4 id="flaws">Flaws</h4><p>Even though the Nintendo 3DS enjoyed modern protection techniques, such as asymmetric cryptography and lots of hardware at its disposal, there were some fundamental flaws in its implementation. Take a look at the following findings discovered by the hacking community:</p><ul><li>While the XN flag in the ARM11 works without problems, Kernel11 sets up the page table in AXI WRAM (where Kernel11 resides) in a way that it grants Read, Write and Execute permissions to the whole memory block <sup id="bibref:98"><a href="#bib:anti_piracy-32c3" role="doc-biblioref">[98]</a></sup>, rendering the capabilities of XN a bit useless (at least for protecting Kernel11).</li><li>Before system version <code>3.0.0</code>, OTP memory was never hidden <sup id="bibref:99"><a href="#bib:operating_system-otp" role="doc-biblioref">[99]</a></sup>, meaning that with the help of any exploit, the OTP keys could be extracted without problem.</li><li>There’s no separation between Process9 and Kernel9, as Kernel9 provides a system call that allows Process9 to perform any function with Kernel9 privileges <sup id="bibref:100"><a href="#bib:anti_piracy-32c3" role="doc-biblioref">[100]</a></sup>.</li><li>There’s no <strong>ASLR</strong> (Address space layout randomization) implemented <sup id="bibref:101"><a href="#bib:anti_piracy-32c3" role="doc-biblioref">[101]</a></sup>, enabling Return-oriented programming (ROP) for exploitation purposes.</li><li>Similarly, there’s no protection against system <strong>downgrading</strong>.</li><li>Once again, this system also comes with a <strong>Web browser based on Webkit</strong>, which is under constant attack (especially if the fork is old).</li></ul><p>This will not only pave the way to the first exploitation attempts, but will also act as a constraint for Nintendo when they try to patch their system.</p><h3 id="defeat">Defeat</h3><p>The history of the Nintendo 3DS and Homebrew is a successful one. Tons of video tutorials can attest to that. Yet, the passage exposes very clever discoveries, which evolved from initially requiring proprietary and expensive equipment to just a couple of clicks on your computer.</p><h4 id="the-ds-flashcard-era-2011-2013">The DS flashcard era (2011-2013)</h4><p>Where to begin? Well, from where the Nintendo DSi left it off: <strong>Flashcards</strong>.</p><p>After the release of the Nintendo DSi in 2008, Nintendo incorporated a new element to fight against Flashcards: A <strong>whitelist file</strong> listing every single licensed card and thereby blocking the ‘unauthorised ones’ <sup id="bibref:102"><a href="#bib:anti_piracy-card_whitelist" role="doc-biblioref">[102]</a></sup>. By no means Flashcard manufacturers ceased their production, they just shipped new variants of their old Flashcards that allowed the user to re-program the cartridge header, enabling the card to identify as a different authorised game whilst Nintendo kept amending the list (through software updates).</p><p>This method encompassed the Nintendo 3DS as well, following the same process as the Nintendo DSi. On no account they would get access to the exclusive 3DS hardware, yet this is how Homebrew started in this console.</p><h4 id="the-3ds-flashcard-era-2013-2016">The 3DS flashcard era (2013-2016)</h4><p>There was much progress during the first two years of this console (a big achievement for Nintendo!). Yet, things took a turn in August 2013…</p><div><ul><li id="tab-11-1-the-first-real-3ds-flashcard-link"><a href="#tab-11-1-the-first-real-3ds-flashcard">The first real 3DS Flashcard</a></li><li id="tab-11-2-inside-the-gateway3ds-link"><a href="#tab-11-2-inside-the-gateway3ds">Inside the Gateway3DS</a></li><li id="tab-11-3-subsequent-anecdotes-link"><a href="#tab-11-3-subsequent-anecdotes">Subsequent anecdotes</a></li></ul><div><div id="tab-11-1-the-first-real-3ds-flashcard"><h5 id="tab-11-1-the-first-real-3ds-flashcard">The first real 3DS Flashcard</h5><figure><a href="https://www.copetti.org/images/consoles/nintendo3ds/homebrew/gateway3ds.628421a0ac282a6b29e0f974bc8c45a02539e71d5fa3e6bfe2ca0b3a54c003de.jpg"><picture><img alt="Image" width="650" height="650" src="https://www.copetti.org/images/consoles/nintendo3ds/homebrew/gateway3ds.628421a0ac282a6b29e0f974bc8c45a02539e71d5fa3e6bfe2ca0b3a54c003de.jpg" loading="lazy"/></picture></a><figcaption>The Gateway3DS package <sup id="bibref:103"><a href="#bib:anti_piracy-gateway_review" role="doc-biblioref">[103]</a></sup>.</figcaption></figure><p>Ignoring teasers of ‘3DS Flascards’ that never appeared <sup id="bibref:104"><a href="#bib:anti_piracy-crown3ds" role="doc-biblioref">[104]</a></sup>. <strong>Gateway3DS</strong> can be considered the first 3DS Flashcard to reach the stores. The instructions were not as simple as DS Flashcards, however. You can sense this by looking at the contents of the box:</p><ul><li>A whitelisted <strong>DS Flashcard</strong> (known as <em>Blue Gateway</em>) whose only purpose is to run a Nintendo DS ROM crafted by Gateway. As part of the ‘installation’ process, users were first required to run this ‘game’ and follow the instructions.</li><li>A <strong>Launcher.dat</strong> to be placed in the 3DS’ SD card.</li><li>A <strong>3DS Flashcard</strong> (known as <em>Red Gateway</em>) where the 3DS game is loaded from. Like any other Flashcard, it also features a microSD slot where the 3DS game is stored. The big difference, however, is that the 3DS game image is flashed into the microSD card, meaning that only one 3DS game can be stored at a time.<ul><li>This makes sense, as RSA signatures can’t be faked (at least, that’s computationally unfeasible). Yet, replicating an exact clone of the game (NCSD block) worked. Forget about Homebrew, for now.</li></ul></li></ul><p>After completing the installation process, users would have to follow these instructions to run any game:</p><ol><li>Insert the <em>Red</em> Gateway card. Nothing will appear, yet.</li><li>Open the 3DS settings app and navigate to the DS profile editor screen.</li><li>For some reason, the 3DS will restart and the flashed 3DS game will show up.</li><li>After finishing playing a game, returning to the HOME Menu will create a savefile in the 3DS’ SD card.</li></ol><p>And just like that, users were now able to download 3DS ROMs from the net and run them on their consoles… but how was all of this possible? How did anyone manage to extract decrypted games? What exploits did Gateway3DS employ (or even discover)?</p><p>Truth is, there’s a lot of hidden functionality within this product. Let’s analyse it step by step.</p></div><div id="tab-11-2-inside-the-gateway3ds"><h5 id="tab-11-2-inside-the-gateway3ds">Inside the Gateway3DS</h5><figure><a href="https://www.copetti.org/images/consoles/nintendo3ds/shell/settings_ds_profile.fd6a65c58c189a525f1d8e65f40cbbc48687a3d05127ff4bf17975477cf7bae2.png"><picture><img alt="Image" width="400" height="480" src="https://www.copetti.org/images/consoles/nintendo3ds/shell/settings_ds_profile.fd6a65c58c189a525f1d8e65f40cbbc48687a3d05127ff4bf17975477cf7bae2.png" loading="lazy"/></picture></a><figcaption>The DS Message editor found on the 3DS settings app. The character limit rule depends solely on the graphical interface.</figcaption></figure><p>Sometime in 2012, hacker ‘ichfly’ discovered interesting behaviour in the Nintendo DS’ old profile editor, found on both <code>NATIVE_FIRM</code> and <code>TWL_FIRM</code>. In one of its text fields, you can enter a ‘Message’ value, which will then be displayed as a greeting on PictoChat rooms <sup id="bibref:105"><a href="#bib:anti_piracy-profile" role="doc-biblioref">[105]</a></sup>. The 3DS’ settings app won’t allow you to enter more characters than allowed. Yet, nothing prevents a Nintendo DS game from doing so. When that happens, opening the 3DS’ System Settings app (called <strong>MSET</strong>) will crash, and what makes it interesting is that this is caused by <strong>stack overflow</strong> <sup id="bibref:106"><a href="#bib:anti_piracy-waffle" role="doc-biblioref">[106]</a></sup>. Does this remind you of <a href="https://www.copetti.org/writings/consoles/wii/#the-dawn-of-homebrew">a certain horse name</a>?</p><p>Now, the mysterious Launcher.dat by Gateway is a configuration file that the Settings app normally reads. What happened is that Gateway crafted their own Launcher.dat to embed data used for the next stages of their exploit. Curiously enough, Launcher.dat is stored in NAND (not in the SD), so the initial exploit chain also alters where the Settings app loads this from.</p><p>If you combine this with a Process9/Kernel9 exploit, you get full execution privileges on this console and can start fiddling with system services. Some hardware like OTP and the boot ROMs will still be out of reach. Yet, this is a significant milestone.</p><p>So far so good? Let’s now connect this information with Gateway’s package:</p><ul><li>The DS/Blue flashcard is just an entry point to install the corrupted DS profile (which will trigger the MSET exploit).</li><li>The 3DS/Red flashcard houses a ProASIC3 FPGA programmed with a firmware (distributed by Gateway). The FPGA and the microSD card are combined to replicate a retail game.</li><li>Launcher.dat is the payload of the MSET exploit. It bundles a Kernel exploit and a collection of system patches. In other words, a <strong>Custom Firmware</strong> (CFW). A console running Gateway’s CFW can extract games or load a 3DS game using the red flashcard. Surprisingly, Gateway also crafted their CFW so it requires the red flashcard inserted to work (<em>a DRM mechanism in a Flashcard, have the tables turned?</em>).</li></ul></div><div id="tab-11-3-subsequent-anecdotes"><h5 id="tab-11-3-subsequent-anecdotes">Subsequent anecdotes</h5><p>All seemed jolly for Gateway until November 2013, when a stream of clones of their card landed. ‘R4i Gold 3DS Deluxe’ came for some healthy competition, albeit by using some of Gateway’s firmware code. In retaliation, Gateway3DS took drastic measures: Subsequent firmware updates of Gateway3DS corrupted the 3DS NAND if a clone was detected. <em>The irony!</em></p><p>In October 2013, hacker ‘Smealum’ published a video showing his own MSET-based implementation that instead booted a copy of <code>NATIVE_FIRM</code> stored in the 3DS’ SD <sup id="bibref:107"><a href="#bib:anti_piracy-rednand" role="doc-biblioref">[107]</a></sup>. This meant that consoles stuck on system <code>4.5.0</code> could boot newer system versions without losing the ability to run exploits. Smealum called this function <strong>redNAND</strong> (from ‘redirected NAND’) and, while it wasn’t publicly released, Gateway later incorporated this functionality (now referred to as <strong>emuNAND</strong>) with their CFW released in December 2013 <sup id="bibref:108"><a href="#bib:anti_piracy-gateway3ds" role="doc-biblioref">[108]</a></sup>. This became a strong selling point for Gateway3DS.</p><p>It’s not known what Process9/Kernel9 exploit Gateway employed. Yet, in December 2013, Fierce_Waffle, Xerpi and Megazig reversed engineered and open-sourced Gateway’s payload in the form of a tool called ‘3DS Toolkit’ <sup id="bibref:109"><a href="#bib:anti_piracy-waffle" role="doc-biblioref">[109]</a></sup> <sup id="bibref:110"><a href="#bib:anti_piracy-ramdump" role="doc-biblioref">[110]</a></sup>.</p><p>In the following years, a second generation of 3DS flashcards will appear in the market. Examples include <strong>Stargate</strong>, <strong>Sky3DS</strong> and dozens of clones. This time, they didn’t rely on an operating system exploit to work and could load multiple games from their microSD. However, their utility will be entirely based on replicating retail 3DS games (including their signatures), in other words, for solely piracy purposes.</p></div></div></div><h4 id="nintendo-acts-fast">Nintendo acts fast</h4><p>Having an updatable system software meant Nintendo didn’t have to stand there and watch how its system got cracked:</p><ul><li>In March 2013, system update <code>5.0.0-11</code> updated the settings app, provisionally fixing the MSET exploit <sup id="bibref:111"><a href="#bib:anti_piracy-neko" role="doc-biblioref">[111]</a></sup>. If you check the timeline, this was before Gateway3DS shipped their card! Hence, it was a prerequisite for users to stay on older versions.<ul><li>It won’t be until 2015 when the Gateway team released a notable firmware update. From then on, the flashcard relied on a new Web Browser exploit (called <strong>spider exploit</strong>, discovered by MathewE) as the entry point. This method lasted until the end of Gateway3DS’ lifespan.</li></ul></li><li>In December 2013, system update <code>7.0.0-13</code> fixed the kernel exploits used in combination with MSET and, most importantly, added the RSA module into the chain of trust to decrypt NCCH blocks (where the game data is found) <sup id="bibref:112"><a href="#bib:anti_piracy-70013" role="doc-biblioref">[112]</a></sup>. RSA keys are cleared once Kernel9 finishes loading, meaning existing exploits won’t be able to decrypt games that adopted the new <code>7.0.0</code> encryption system (unless a vulnerability is used before Kernel9 boots).</li><li>As Gateway3DS’ Launcher.dat file contained copyrighted code by Nintendo, the latter company sent Cease &amp; Desist letters to many forums, including GBATemp, which in turn blocked the distribution of those files.</li></ul><p>As always, this marked the start of another cat-and-mouse game. Though, to make a long story short, system update <code>9.3.0</code> (released in December 2014) finally put an end to Gateway3DS by patching their private Kernel exploit <sup id="bibref:113"><a href="#bib:anti_piracy-gateway3ds" role="doc-biblioref">[113]</a></sup>. Since then, Gateway3DS’ firmware updates only improved emuNAND support with the latest system versions (for those who didn’t update past the breaking update). In 2016, Gateway’s last update was released. Meanwhile, Sky3DS enjoyed support until system software <code>11.0</code> (released in May 2016) <sup id="bibref:114"><a href="#bib:anti_piracy-sky3ds" role="doc-biblioref">[114]</a></sup>, when Nintendo blacklisted it for good.</p><p>I think now it’s fair to say that the 3DS flashcard market ended up being too turbulent and unreliable for the average user, compare this to the ‘plug &amp; play’ experience Nintendo DS flashcard offered. Finally some good news for Nintendo, so far.</p><h4 id="the-dawn-of-homebrew-2014">The dawn of homebrew (2014)</h4><p>2014 saw an emergence of homebrew-focused solutions in a circle populated by piracy-oriented developments <sup id="bibref:115"><a href="#bib:anti_piracy-proto_homebrew" role="doc-biblioref">[115]</a></sup>. Hacking a 3DS still required an old system version, a Gateway3DS card and emuNAND - but that would slowly shift once alternative tools gained traction.</p><figure><a href="https://www.copetti.org/images/consoles/nintendo3ds/homebrew/32c3.603e3f980c96df85d410f37756afa2355a73eecf8413059c6e11241ac60e4777.jpeg"><picture><img alt="Image" width="854" height="480" src="https://www.copetti.org/images/consoles/nintendo3ds/homebrew/32c3.603e3f980c96df85d410f37756afa2355a73eecf8413059c6e11241ac60e4777.jpeg" loading="lazy"/></picture></a><figcaption>Plutoo, Derrek and Smealum presenting their findings at the 32nd Chaos Communication Congress (2015) <sup id="bibref:116"><a href="#bib:anti_piracy-32c3" role="doc-biblioref">[116]</a></sup>, the following paragraphs will explain most of them.</figcaption></figure><div><ul><li id="tab-12-1-open-source-sdks-link"><a href="#tab-12-1-open-source-sdks">Open-source SDKs</a></li><li id="tab-12-2-ninjhax-chain-link"><a href="#tab-12-2-ninjhax-chain">Ninjhax chain</a></li><li id="tab-12-3-gaining-kernel11-access-link"><a href="#tab-12-3-gaining-kernel11-access">Gaining Kernel11 access</a></li></ul><div><div id="tab-12-1-open-source-sdks"><h5 id="tab-12-1-open-source-sdks">Open-source SDKs</h5><p>Initial Homebrew appeared in the form of Laucher.dat files, these were produced with the help of devkitARM (a general-purpose toolchain for ARM-based CPUs) and a set of scripts. Fierce Waffle provided ‘ROP Loader’, a toolkit that included a DS program to install the MSET exploit; and a Launcher.dat that triggered a Kernel11 exploit. It’s worth pointing out that there wasn’t any tool available, yet, that helped access the 3DS’ exclusive hardware.</p><p>At the start of 2014, Smealum, with the collaboration of yellows8, ichfly, WinterMute, fincs, mtheall and plutoo, released <strong>ctrulib</strong>, an open-source C library to facilitate Homebrew development <sup id="bibref:117"><a href="#bib:anti_piracy-libctru" role="doc-biblioref">[117]</a></sup>. This is now known as <strong>libctru</strong> and maintained by the devkitPro group, who have incorporated it into their toolchain.</p><p>A year later, neobrain released <strong>nihstro</strong> <sup id="bibref:118"><a href="#bib:anti_piracy-nihstro" role="doc-biblioref">[118]</a></sup>, a PICA200 shader assembler a disassembler, making the job of programming the PICA200 a bit more enjoyable.</p><p>To run Homebrew, users had the option to flash a homebrew binary into a microSD, and then use the Gateway3DS to boot it (as their CFW already disabled signature checks) <sup id="bibref:119"><a href="#bib:anti_piracy-gateway_homebrew" role="doc-biblioref">[119]</a></sup>.</p></div><div id="tab-12-2-ninjhax-chain"><h5 id="tab-12-2-ninjhax-chain">Ninjhax chain</h5><figure><a href="https://www.copetti.org/images/consoles/nintendo3ds/homebrew/launcher.a5ef019f4fd8b8aa7dc8af5beea6e53aba3af518a507b6a1f7f174ce4d627235.png"><picture><img alt="Image" width="400" height="480" src="https://www.copetti.org/images/consoles/nintendo3ds/homebrew/launcher.a5ef019f4fd8b8aa7dc8af5beea6e53aba3af518a507b6a1f7f174ce4d627235.png" loading="lazy"/></picture></a><figcaption>The Homebrew Launcher, inspired by the <a href="https://www.copetti.org/writings/consoles/wii/#a-permanent-state">iconic Wii counterpart</a>. Its arrival marked the sophistication of 3DS Homebrew.</figcaption></figure><p>The poisoned updates of Gateway left a bitter mark on their users. The time had come to look for nonproprietary alternatives.</p><p>Thankfully, people were working on this. During the second half of 2014, a new milestone awaited for the Homebrew community: Smealum published <strong>Ninjhax</strong>, a package composed of the following components <sup id="bibref:120"><a href="#bib:anti_piracy-32c3" role="doc-biblioref">[120]</a></sup>:</p><ol><li>A crafted <strong>QR code</strong> to be scanned by ‘Cubic Ninja’, a game that allows to share user-designed levels using QR codes. This served as a new entry point exploit.</li><li><strong>GSPWN</strong>: A userland vulnerability where the GPU’s DMA is used to write over the HOME Menu’s heap. Furthermore, the combination with ROP leads to privilege escalation. This resulted in the ability to create &amp; kill processes, SD card access, decrypt &amp; dump titles and override executable data.<ul><li><a href="https://www.copetti.org/writings/consoles/xbox-360/#graphics">Other GPUs</a> were also known for <a href="https://www.copetti.org/writings/consoles/xbox-360/#tab-20-3-king-kong-exploit">intruding</a> into the system’s RAM.</li></ul></li><li><strong>Homebrew launcher</strong>: A new service running under the HOME Menu process thanks to GSPWN. It provides a graphical user interface to load unsigned Homebrew apps (using a new portable .3dsx format) and take over processes. The launcher loads homebrew by opening an official application with enough privileges and then hijacks it with GSPWN, replaces the code with Homebrew code and finally executes it.<ul><li>With its ability to alter user data, the Homebrew launcher can also be used to install alternative entry points as they’re discovered (i.e. OotHax, Ironhax and so forth). Thus, reducing its dependency on Cubic Ninja. A notable aftermarket exploit was <strong>MenuHax</strong>, which exploited a vulnerability in the HOME Menu theme engine and was triggered at boot, <strong>making it a permanent solution to launch a payload</strong>.</li><li>If you are curious, the Wii U also experienced <a href="https://www.copetti.org/writings/consoles/wiiu/#fooling-iosu">similar methodologies</a> as early attempts to run Homebrew.</li></ul></li></ol><p>Notice how Gateway3DS is, for once, out of the equation. Be as it may, the Homebrew Launcher was still under the scope of userland (meaning homebrew apps could only access 64 MB of RAM and had no access to the audio DSP <sup id="bibref:121"><a href="#bib:anti_piracy-hbl_limitations" role="doc-biblioref">[121]</a></sup>).</p></div><div id="tab-12-3-gaining-kernel11-access"><h5 id="tab-12-3-gaining-kernel11-access">Gaining Kernel11 access</h5><p>Turns out that before the publication of Ninjhax, in February 2014, yellows8 made a very important discovery: An exploit leading to Kernel11 privileges.</p><p>Kernel11 keeps track of the unused memory pages in FCRAM using a structure called <code>memchunk header</code>. This data is stored as a linked list, where each header contains the address of the previous and next header. Well, it so happens <code>memchunk headers</code> <strong>are stored in FCRAM</strong>, which may be overwritten thanks to other exploits like GSPWN. Consequently, memchunk headers can be modified to grant userland access to AXI WRAM. In doing so, the attacker can eventually modify the Kernel11’s page table to grant all FCRAM access to user-space, leading to arbitrary control of Kernel11. This discovery was called <strong>memchunkhax</strong>.</p><p>Nevertheless, Nintendo patched it in December 2014 <sup id="bibref:122"><a href="#bib:anti_piracy-32c3" role="doc-biblioref">[122]</a></sup>. However, another hacker by the name of derrek found a race condition where the ‘next’ pointer of a <code>memchunk header</code> may be replaced with the location of a crafted one. So, when Kernel11 tries to access the crafted <code>memchunk header</code>, it will end up executing arbitrary code with Kernel11 privileges. Ipso facto, <strong>memchunkhax2</strong> came into existence.</p><p>Thanks to the new privilege escalation, Homebrew software gained complete control of the system up to the ARM9 area… but why stop there?</p></div></div></div><h4 id="most-wanted-tools">Most-wanted tools</h4><p>Considering the availability of Gateway3DS’ emuNAND, Ninjhax, CTRLib and the new Kernel exploits, the flood of new software was too great to ignore. To mention a few:</p><ul><li><strong>CtrBootManager</strong> by cpasjuste: An extra stage in HomeMenuHax’s chain that acts as a boot manager, enabling the selection of various payloads <sup id="bibref:123"><a href="#bib:anti_piracy-ctrbootmanager" role="doc-biblioref">[123]</a></sup>.<ul><li>Shortly after, a new implementation with extended functionality emerged: <strong>BootCtr</strong> by m45t3r <sup id="bibref:124"><a href="#bib:anti_piracy-bootctr" role="doc-biblioref">[124]</a></sup>.</li></ul></li><li><strong>RxTools</strong> by Roxas75: A Swiss knife for Gateway3DS users <sup id="bibref:125"><a href="#bib:anti_piracy-rxtools" role="doc-biblioref">[125]</a></sup>. This was offered as a replacement for Gateway3DS’ binaries. Among many things, it includes a CFW called <strong>RXMode</strong>. This alternative and open-source solution disables signature checks on 3DS binaries, provides emuNAND and removes <code>TWL_FIRM</code>’s whitelist checks, to mention a few.<ul><li>Other CFWs will soon make their appearance, like CakesFW, ReiNand and Pasta CFW <sup id="bibref:126"><a href="#bib:anti_piracy-cfw_old_list" role="doc-biblioref">[126]</a></sup>. These serve different purposes and include their own set of modifications.</li></ul></li><li><strong>Custom HomeMenu Manager</strong> (CHMM) by Rinnegatamante: Allows to install HOME Menu themes from the SD card <sup id="bibref:127"><a href="#bib:anti_piracy-chmm" role="doc-biblioref">[127]</a></sup>.</li><li><strong>AGB_FIRM Signature patcher</strong> by Riku. Loads arbitrary Game Boy Advance ROMs into AGB_FIRM <sup id="bibref:128"><a href="#bib:anti_piracy-agb_converter" role="doc-biblioref">[128]</a></sup>, finally expanding the abandoned catalogue of Nintendo Ambassador games.</li><li><strong>Ftpbrony</strong> by mtheall (later known as <strong>ftpd</strong>): A simple FTP server <sup id="bibref:129"><a href="#bib:anti_piracy-ftpbrony" role="doc-biblioref">[129]</a></sup>.</li><li><strong>DevMenu</strong>: Not exactly a homebrew app, but a <em>stolen</em> Nintendo-authored app from development units, enabling users to install app packages (in the form of ‘CIA’ files) into the system, just like the eShop did behind the scenes.<ul><li>Months later, <strong>BigBlueMenu</strong> was used instead, which also came from Nintendo’s development kit.</li><li>It wasn’t until a real open-source solution was brought forward some months after. <strong>FBI</strong> by Steveice10 became the standard dilemma-free tool for installing CIA files (notice the pun in the names) <sup id="bibref:130"><a href="#bib:anti_piracy-fbi" role="doc-biblioref">[130]</a></sup>.</li></ul></li></ul><h4 id="new-console-permanent-mods-2015">New console, permanent mods (2015)</h4><p>While homebrew developers were busy fiddling with their system, Nintendo released a <em>new</em> product to the surprise of everyone: The <strong>New 3DS</strong>.</p><p>Apart from the extra hardware (already mentioned throughout this article), a new stage was added to the boot process: <strong>arm9loader</strong>. With this, Nintendo enhanced their chain of trust by adding new keys, which must be decrypted with the help of a hash of OTP memory (therefore, using console-unique values) <sup id="bibref:131"><a href="#bib:anti_piracy-arm9loader" role="doc-biblioref">[131]</a></sup>. However, arm9loader and the new keys are still stored in NAND, meaning that the contents may be overwritten. This led to one of the most disrupting vulnerabilities of 2015, involving Plutoo, Yellows8 and Delebile.</p><h5 id="arm9loaderhax">arm9loaderhax</h5><p>The first implementation of arm9loader was flawed: the decryption key for the ARM9 system was never removed from the AES engine. So, with the help of additional exploitation, one could reconstruct part of the encryption keys <sup id="bibref:132"><a href="#bib:anti_piracy-arm9loaderhax" role="doc-biblioref">[132]</a></sup>. Consequently, Nintendo quickly tried again with <code>arm9loader v1.1</code> (found on system update <code>9.6.0</code>). As luck would have it, this led to a more powerful exploit: Plutoo discovered that the key used to decrypt the ARM9 system was never verified. Hence, arm9Loader will boot <code>NATIVE_FIRM</code> even if the decrypted data is wrong (a.k.a. garbage). Plus, if Firm0 (the first copy of <code>NATIVE_FIRM</code>) fails to boot, Boot9 will try to load Firm1 while the remains of Firm0 stay in the ARM9’s RAM.</p><p>All in all, if:</p><ul><li>NAND is modified (somehow) so the encrypted Firm0 contains extra crafted code at the end.</li><li>The ARM9 OS key is mangled in a way that the decrypted Firm1 will contain a jump instruction to Firm0’s crafted code.</li></ul><p>… you got yourself <strong>arm9loaderhax</strong>, a permanent exploit that provides <strong>arbitrary code execution</strong> with <strong>Kernel9 privileges</strong> at <strong>boot time</strong>!</p><p>Since Kernel9 access was now possible, albeit through difficult means, work was put into simplifying the process (i.e. developing an automated installer).</p><h5 id="the-effects-of-arm9loaderhax">The effects of arm9loaderhax</h5><p>New discoveries meant new developments. Over the following months, more advanced tools will become part of the ‘must have’ list of every homebrew user.</p><p>To start with, a new CFW to-rule-them-all shipped: <strong>Luma3DS</strong> <sup id="bibref:133"><a href="#bib:anti_piracy-luma3ds" role="doc-biblioref">[133]</a></sup>. Among many features, Luma3DS provides:</p><ul><li>The removal of signature and region checks.</li><li>A layered filesystem to redirect file operations to the SD card (enabling game modifications).</li><li>Rosalina Menu, an in-game menu overlay where many utilities can be accessed without closing any application.</li></ul><p>Initially, Luma3DS was bootstrapped with BootCtr, but that changed once arm9loaderhax became the de-facto hack for any 3DS. Thus, the arm9loaderhax + Luma3DS combination became part of any hacking tutorial.</p><p>Along it, other software appeared:</p><ul><li><strong>Godmode9</strong> by d0k3: A next-generation Swiss knife that takes advantage of the permissions granted by ARM9 exploits <sup id="bibref:134"><a href="#bib:anti_piracy-godmode" role="doc-biblioref">[134]</a></sup>, enabling the user to read and modify every corner of the console. It can be loaded by arm9loaderhax, Luma3DS or any other compatible hack. Now, the more powerful the exploit, the more functionality is provided. Examples of functionality include a file browser and NAND backup. Plus it’s further extended with scripts.</li><li><strong>Anemone3DS</strong> by astronautlevel: With a multitude of features, it soon became <em>the app</em> for managing HOME Menu themes <sup id="bibref:135"><a href="#bib:anti_piracy-anemone3ds" role="doc-biblioref">[135]</a></sup>.</li><li><strong>nds-bootstrap</strong> by Rocket Robz: As the name indicates, it loads Nintendo DS software (ROMs and homebrew) from the SD card <sup id="bibref:136"><a href="#bib:anti_piracy-nds_bootstrap" role="doc-biblioref">[136]</a></sup>. While it’s designed to support the three portable consoles (the Nintendo 3DS, DSi and DS, the latter requiring a flashcard), loading it from the 3DS will kickstart <code>TWL_FIRM</code>, meaning there’s no emulation at all. It’s most commonly used through ‘TWLMenu’ (now ‘TWiLight Menu++’), the front-end of nds-bootstrap.</li></ul><p>It’s worth mentioning that, at the time of this writing, these are the most popular utilities to install on a hacked 3DS.</p><h4 id="the-golden-age-2016-2017">The Golden Age (2016-2017)</h4><p>While a universal and powerful solution, installing arm9loaderhax was still considered a complicated and dangerous activity. Not only does this require dumping the console’s OTP memory beforehand (using other exploits), but neglecting any step could potentially turn a working Nintendo 3DS into a rock.</p><p>But fear not as new developments were in the works (a mighty effort considering Nintendo was still battling to protect their console).</p><figure><a href="https://www.copetti.org/images/consoles/nintendo3ds/homebrew/33c3.437cce691de5706d0c70eab1e6a3bb0427a28c33f4285a3c0bbd5c8083b49c5b.jpeg"><picture><img alt="Image" width="1280" height="720" src="https://www.copetti.org/images/consoles/nintendo3ds/homebrew/33c3.437cce691de5706d0c70eab1e6a3bb0427a28c33f4285a3c0bbd5c8083b49c5b.jpeg" loading="lazy"/></picture></a><figcaption>naehrwert, nedwill and derrek presenting a new set of findings at the 33nd Chaos Communication Congress (December 2016) <sup id="bibref:137"><a href="#bib:anti_piracy-33c3" role="doc-biblioref">[137]</a></sup>.</figcaption></figure><p>At the 33C3 conference, derrek unveiled two major discoveries <sup id="bibref:138"><a href="#bib:anti_piracy-33c3" role="doc-biblioref">[138]</a></sup>, which led to subsequent milestones.</p><div><ul><li id="tab-13-2-sighax-link"><a href="#tab-13-2-sighax">Sighax</a></li><li id="tab-13-3-boot9strap-link"><a href="#tab-13-3-boot9strap">Boot9strap</a></li><li id="tab-13-4-ntrboot-link"><a href="#tab-13-4-ntrboot">Ntrboot</a></li></ul><div><div id="tab-13-1-extracting-boot9"><p>For some reason, the contents of ARM9’s RAM are not cleared upon reset. Thus, Derrek discovered that, with the use of external hardware, he could override the exception vectors from ARM9’s RAM (previously copied from Boot9) with arbitrary code. Then, reset the system, glitch it at very precise timing (also using external hardware) to trigger an exception and hope for the ARM9 to have executed the new code. This will have included something like ‘Copy all contents of Boot9 to X location in RAM’.</p><p>Lo and behold, this did work. With this, Derrek and others managed to analyse the contents of the Boot9 ROM, allowing new vulnerabilities to be found.</p></div><div id="tab-13-2-sighax"><h5 id="tab-13-2-sighax">Sighax</h5><p>One vulnerability from Boot9 was <strong>Sighax</strong> <sup id="bibref:139"><a href="#bib:anti_piracy-sighax" role="doc-biblioref">[139]</a></sup>, a flaw in Boot9’s RSA-2048 signature verification. RSA signatures of type ‘PKCS #1 v1.5’ (adopted by this system) contain an area called <strong>padding</strong> to prevent being reversed. Additionally, they store an SHA-256 hash encoded with a model called ‘ASN.1’, this <strong>guarantees the authenticity of the data</strong> being decrypted.</p><p>Now, the respective parser found in Boot9 <strong>lacks several protections</strong>, including bounds checking. In the end, this allowed Derrek to produce a crafted RSA signature (through brute-forcing) that will always succeed on any data. In doing so, the <strong>entirety of the chain of trust was nullified</strong>.</p><p>For the curious, I recommend reading a comprehensive post in GBATemp describing the theory more calmly <sup id="bibref:140"><a href="#bib:anti_piracy-mrjason" role="doc-biblioref">[140]</a></sup>.</p><p>With this, one would now be allowed to craft a firmware for the ARM9 core, sign it with a crafted RSA signature, install it on NAND and Boot9 will ‘just run it’. The question now is, how can the average user do this using an unmodified console?</p></div><div id="tab-13-3-boot9strap"><h5 id="tab-13-3-boot9strap">Boot9strap</h5><p>The year is 2017. Most know about the existence of Sighax but only a handful can apply it, all because the new method requires a crafted RSA signature and writing access to the NAND, none of which is easy to come by (and let’s not forget Nintendo was still clamping down hard on user-land exploits through system updates). Luckily, Sighax was in the process of being democratised.</p><p>Even though Derrek’s announcement didn’t include a suitable RSA signature or a copy of Boot9 (due to copyright reasons, I’m guessing), that didn’t stop hackers SciresM and Myria from finding alternative resources that would enable them to craft an RSA signature.</p><p>In summary, they discovered that system versions before <code>1.0.0</code> shared similar flaws to those previously exposed with Sighax <sup id="bibref:141"><a href="#bib:anti_piracy-sighax_pres" role="doc-biblioref">[141]</a></sup> and, thanks to this, they were able to begin brute-forcing RSA signatures. The result was a success, a match was eventually found with the help of plenty of Nvidia GPUs <sup id="bibref:142"><a href="#bib:anti_piracy-sighax_math" role="doc-biblioref">[142]</a></sup>.</p><p>Now that they could craft an alternative firmware that Boot9 would accept, they needed to find a way to redirect Boot9 to their payload. The challenge was to redirect execution before Boot9 hides its Boot ROM. To tackle this, the duo found a route through the ARM9’s exception handlers. The ARM9 can’t override these, but the NDMA can - and the CPU can command the NDMA to do so.</p><p>All in all, the team were able to use the NDMA to fill the exception handlers with a jump to arbitrary code, and then instruct the ARM9 to copy to <code>NULL</code>, resulting in an exception that would execute the payload with unrestricted access. In the end, this was packaged in a solution called <strong>boot9strap</strong> and served as an alternative bootloader that could either load a payload from the SD card or continue to boot normally. Consequently, Godmode9 was extended to backup OTP and the Boot ROMs, if needed.</p><p>And so, boot9strap quickly displaced arm9loaderhax as the de facto solution for loading arbitrary code with maximum privileges.</p></div><div id="tab-13-4-ntrboot"><h5 id="tab-13-4-ntrboot">Ntrboot</h5><figure><a href="https://www.copetti.org/images/consoles/nintendo3ds/homebrew/ntrboot_flashcard.70f62f8dd94963d654415db4d0f2a190b5a1c15eb60acc6ba713c26bb295d849.jpg"><picture><img alt="Image" width="947" height="900" src="https://www.copetti.org/images/consoles/nintendo3ds/homebrew/ntrboot_flashcard.70f62f8dd94963d654415db4d0f2a190b5a1c15eb60acc6ba713c26bb295d849.jpg" loading="lazy"/></picture></a><figcaption>Some DS Flashcards sold after the discovery of ntrboot came with a switch to enable a ‘3DS mode’ (see the top corner of the photo), this enables trigger ntrboot.</figcaption></figure><p>At this point, there was only one question left: How could users install boot9strap?</p><p>Well, the team didn’t stop there. By taking a look at their recent Boot ROM dumps, they found an interesting routine: During boot, Boot9 will query if a specific <strong>key combination is pressed</strong> and the <strong>lid is closed</strong>. If so, Boot9 will redirect execution to the inserted Nintendo DS card (with full privileges).</p><p>Thus, <strong>ntrboot</strong> came to fruition: Flash a sighax-signed payload into a Nintendo DS flashcard, use a magnet to simulate a closed shell and press the required key combination. Instant Boot9 privileges.</p><p>If this wasn’t enough, Nintendo couldn’t fix any of these vulnerabilities through software updates, as they’re hardwired into the Boot ROM. A possible solution would’ve been to ship new hardware revisions, yet, none ever appeared.</p></div></div></div><h4 id="the-remaining-years-2018-present">The remaining years (2018-present)</h4><p>Now that the homebrew community has achieved its magnum opus, the remaining years of the Nintendo 3DS will only see the streamlining of hacking methods, all of which share the same objective: Install boot9strap.</p><figure><a href="https://www.copetti.org/images/consoles/nintendo3ds/homebrew/3dshacks.93122646fef0484a0abbe6ae842c573dc81e29a734f760d158547a50a2964172.png"><picture><source type="image/webp" srcset="https://www.copetti.org/images/consoles/nintendo3ds/homebrew/_hu1ed3670aa3a156a8d4deb11d9d975c6b_89755_67144305ea863bc41e118057e27ecc2f.webp 500w,
https://www.copetti.org/images/consoles/nintendo3ds/homebrew/_hu1ed3670aa3a156a8d4deb11d9d975c6b_89755_15f7a7c7977b5b7d951c8f22169b0417.webp 800w,
https://www.copetti.org/images/consoles/nintendo3ds/homebrew/_hu1ed3670aa3a156a8d4deb11d9d975c6b_89755_60452d1ade267dfc9302be1e561295f6.webp 985w"/><img alt="Image" width="985" height="640" src="https://www.copetti.org/images/consoles/nintendo3ds/homebrew/3dshacks.93122646fef0484a0abbe6ae842c573dc81e29a734f760d158547a50a2964172.png" loading="lazy"/></picture></a><figcaption>As the methodologies used to hack a 3DS drastically evolve, sometimes too quickly for new users, community-maintained websites like 3ds.hacks.guide currently holds a reputation as the most reliable and updated set of tutorials.</figcaption></figure><p>By this point in time, there were many exploits in the wild: ‘SoundHax’, ‘Safehax’, ‘Browserhax’… too many to mention here. For the curious, 3DBrew provides a comprehensive list <sup id="bibref:143"><a href="#bib:anti_piracy-user_flaws" role="doc-biblioref">[143]</a></sup>.</p><p>To give you an idea of how elegant exploitation became by 2023, let me show you a common method users relied on and didn’t require extra hardware. This process was called ‘seedminer + BannerBomb3’ and combined the following vulnerabilities, the majority of them authored by zoogie:</p><ol><li><strong>seedminer</strong>: User data installed in the 3DS’ SD card is encrypted using AES-128-CTR. Its key is constructed from other keys found in a file called <code>movable.sed</code> (console-unique, stored in NAND). Well, it was discovered that this file can be re-constructed by using the console’s Friend Code, subdirectory names in the SD card (generated by the console) and short-term brute-forcing. Once extracted, the keys allowed to tamper with DSiWare data in the SD card.</li><li><strong>BannerBomb3</strong>: An exploit that overflows the stack of the Settings app while it tries to parse the banner of an installed DSiWare title <sup id="bibref:144"><a href="#bib:anti_piracy-bannerbomb" role="doc-biblioref">[144]</a></sup>. Combined with seedminer, this serves as an entry-level exploit with Kernel11 privileges.</li><li>Now, how to take advantage of BannerBomb3 (i.e. which payload to use) depended on the tutorial the user was following at the time. For simplicity purposes, there were two routes:</li></ol><div><ul><li id="tab-14-1-the-safe-mode-route-link"><a href="#tab-14-1-the-safe-mode-route">The Safe Mode route</a></li></ul><div><div id="tab-14-1-the-safe-mode-route"><h5 id="tab-14-1-the-safe-mode-route">The Safe Mode route</h5><p>This route consisted of exploiting <code>SAFE_FIRM</code> and was described in earlier tutorials:</p><ol><li><strong>unSAFE_MODE</strong>: Users can boot into Safe Mode by pressing a combination of buttons during the console’s boot, the alternative firmware then enables the user to perform a system update, which is useful for repairing the console. Well, zoogie discovered that the proxy settings can be overflowed <sup id="bibref:145"><a href="#bib:anti_piracy-unsafe_mode" role="doc-biblioref">[145]</a></sup>. Hence, providing user-land execution within Safe Mode.</li><li><strong>safehax</strong>: a port of ‘firmlaunch-hax’ to work under SAFE_FIRM. Nintendo originally patched it with system update <code>9.5.0</code> released in February 2015 <sup id="bibref:146"><a href="#bib:anti_piracy-9_5" role="doc-biblioref">[146]</a></sup>. Yet, SAFE_FIRM is an immutable replica of the factory firmware, and thus it features old exploits NATIVE_FIRM once <em>enjoyed</em>.<ol><li><strong>firmlaunch-hax</strong>: When the firmware is booting, the ARM9 stores the firmware’s header in FCRAM for verifying and then parsing. With the help of a race condition, execution can take control of the ARM9, so the boot9strap installer can be launched. Nintendo fixed this by keeping the header in ARM9 RAM instead, although this stayed unpatched on SAFE_FIRM.</li></ol></li></ol></div><div id="tab-14-2-the-home-menu-route"><p>Sometime later, a new route was proposed by new tutorials. This exploited the HOME Menu with a new Menuhax-style hack:</p><ol><li><strong>menuhax67</strong>: The screen brightness configuration value can be overflown <sup id="bibref:147"><a href="#bib:anti_piracy-menuhax67" role="doc-biblioref">[147]</a></sup>, leading to user-land control from the HOME Menu.</li><li><strong>nimdsphax</strong>: An modern exploit chain combining ‘ctr-httpwn’, ‘nimhax’ and ‘dsp pwn’ <sup id="bibref:148"><a href="#bib:anti_piracy-nimdsphax" role="doc-biblioref">[148]</a></sup>.<ol><li><strong>ctr-httpwn</strong> by yellows8: The HTTP service used for network connections can be controlled by overriding its heap memory (using the old GPU DMA exploit) <sup id="bibref:149"><a href="#bib:anti_piracy-httpwn" role="doc-biblioref">[149]</a></sup>.</li><li><strong>nimhax</strong> by luigoalma: Uses ctr-httpwn to escalate and take over the services that control the user file system, console configuration and application management <sup id="bibref:150"><a href="#bib:anti_piracy-nimhax" role="doc-biblioref">[150]</a></sup>.</li><li><strong>dsp pwn</strong> by luigoalma: Uses nimhax to take control of the DSP, which in turn uses the GPU’s DMA to override the Kernel9 memory space. Thus, obtaining ARM9 privileges.</li></ol></li></ol></div></div></div><h5 id="post-2023-and-conclusions">Post-2023 and conclusions</h5><p>Be as it may, at the time of this writing, Nintendo hasn’t quite surrendered to the cat-and-mouse game. In May 2023, system update <code>11.17.0</code> patched BannerBomb3, nullifying one of the last entry points that didn’t require additional materials <sup id="bibref:151"><a href="#bib:anti_piracy-11_17" role="doc-biblioref">[151]</a></sup>. This means users will now need to either obtain a legitimate 3DS game (which can then be exploited), an ntrboot-compatible DS flashcard; or wait for a WebKit exploit (there’s one only left for the New 3DS browser <sup id="bibref:152"><a href="#bib:anti_piracy-skaterhax" role="doc-biblioref">[152]</a></sup>).</p><hr/><h2 id="thats-all-folks">That’s all folks</h2><figure><a href="https://www.copetti.org/images/consoles/nintendo3ds/photos/my3dss.291f0c00616803ac9f9b570af267a17901a729074ded39c03576c16d4cd6917f.webp"><picture><img alt="Image" width="1037" height="500" src="https://www.copetti.org/images/consoles/nintendo3ds/photos/_hu8ac0a8a08ff3edfea9a6be84b3a66ace_53002_245d657b9cd3a8518579bd5017c67086.png" loading="lazy"/></picture></a><figcaption>My Nintendo 3DS(s). Apart from the XL one on the left, I bought two extra for this article: The red one you see on the right (originally listed as ‘broken’, turned out the power socket is just flaky) and another one (<em>correctly</em> listed ‘for parts’) to take the motherboard photos.</figcaption></figure><p>Phew, that was another one of those long articles. I’m glad you managed to keep up and reach the end!</p><p>If you are curious, this article took me almost a year to finish, mainly due to a combination of multiple factors, but the important thing is that I ultimately managed to complete it.</p><p>Looking back, it’s hard to admit this console didn’t enjoy the same degree of success as the Nintendo DS. Considering all of its offerings analysed here, I think many external factors hindered its marketing. For starters, the timing was unfortunate and the price tag wasn’t exactly tempting. From my perspective, back when it launched in 2011, the ‘08 financial crisis was hitting hard (I was living in Spain back then), so the Nintendo 3DS wasn’t exactly on adults’ (and kids’) priorities. I eventually got mine in 2018, by then living in the UK.</p><p>In any case, I want to thank the #ReSwitched and #Godmode9 for spotting lots of mistakes in my initial drafts. This has been the most intricate console I’ve written about (to this date!), nevertheless, I’m very grateful to find communities willing to help out.</p><p>Until next time!</p></article></div>
  </body>
</html>
