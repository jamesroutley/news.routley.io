<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://olano.dev/blog/gleam-coming-from-erlang/">Original</a>
    <h1>Gleam, Coming from Erlang</h1>
    
    <div id="readability-page-1" class="page"><div lang="en">
      <header>
          
          
          
          

      </header>

      
      <p>
I recently took some time to try <a href="https://gleam.run/">Gleam</a>, the type-safe language that runs on the Erlang virtual machine.
For a couple of weeks, I used it to build a little <a href="https://github.com/facundoolano/news.olano.dev/">open-source</a> feed aggregator that’s now <a href="https://news.olano.dev/">live</a>.
These are my notes.</p>
<h2 id="why-i39m-interested-in-gleam">
why I’m interested in Gleam
</h2>
<p>
I spent most of my career working with dynamic languages: Python, JavaScript, Clojure, finally Erlang. I don’t claim to be an expert but the Erlang VM is the piece of technology I’ve become most intimately familiar with. There is no way around it, I think: if you’re running Erlang in production sooner or later you’ll be thinking in terms of processes, scheduling, failure modules, resource utilisation.</p>
<p>
After Erlang, I dabbled in Rust, both professionally and on <a href="https://jamiepalatnik.com/deconstructing-the-role-playing-videogame">personal projects</a>, and I was very impressed by its type system, its error handling, and the developer experience it enabled. The thing is: Rust comes with all the systems programming overhead, which in my opinion is not a good bargain if you are not, you know, programming systems. Alas, I’m too old to pick up my own garbage. And, coming from Erlang, Rust’s async concurrency (like JavaScript’s, like Python’s) just makes me very sad inside.</p>
<p>
By now you may imagine why Gleam looks interesting to me:</p>
<ul>
<li>I would like a Rust minus the memory management and with a gentler concurrency model;</li>
<li>I would like a BEAM language without Erlang’s rough edges and with the goodies of a modern type system.</li>
</ul>
<p>I’m not claiming Gleam is one of those things, but it seems close enough to spike my interest.</p>
<h2 id="the-project">
the project
</h2>
<p>
After happily running <a href="https://olano.dev/blog/reclaiming-the-web-with-a-personal-reader/">my personal feed reader</a> for over a year, several spin-off projects have been coming to mind: turning my list of feeds into a blog roll, my list of favorites into a link blog, making a public version of my feed, etc.</p>
<p>
The single remarkable feature of my reader is that I don’t sort posts chronologically but by “reverse frequency”. If I follow a news site that publishes twice an hour and an essayist that publishes every two months, I want the essayist at the top of my feed if they published yesterday, even if there are 30 more recent news posts. To get this effect I distribute the feeds in frequency buckets and sort by reverse frequency first, publish date later. This is what the bucket calculation looks like in Gleam:</p>
<div>
<div>
<pre><code><span><span><span>/// Calculate the frequency bucket of the feed,
</span></span></span><span><span><span>/// by checking the average post frequency from the current
</span></span></span><span><span><span>/// entry list. The higher rate the higher bucket.
</span></span></span><span><span><span></span><span>fn</span><span> </span><span>calc_bucket</span><span>(</span>entries<span>:</span><span> </span><span>List</span><span>(</span><span>F</span>eedEntry<span>))</span><span> </span><span>-&gt;</span><span> </span><span>I</span>nt<span> </span><span>{</span><span>
</span></span></span><span><span><span>  </span><span>let</span><span> </span>by_date<span> </span><span>=</span><span>
</span></span></span><span><span><span>    </span>list<span>.</span><span>sort</span><span>(</span>entries<span>,</span><span> </span>by<span>:</span><span> </span><span>fn</span><span>(</span>e1<span>,</span><span> </span>e2<span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>      </span>birl<span>.</span><span>compare</span><span>(</span>e1<span>.</span>published<span>,</span><span> </span>e2<span>.</span>published<span>)</span><span>
</span></span></span><span><span><span>    </span><span>})</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>  </span><span>case</span><span> </span>list<span>.</span><span>first</span><span>(</span>by_date<span>),</span><span> </span>list<span>.</span><span>last</span><span>(</span>by_date<span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>Ok</span><span>(</span>first<span>),</span><span> </span><span>Ok</span><span>(</span>last<span>)</span><span> </span><span>-&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>      </span><span>let</span><span> </span>delta<span> </span><span>=</span><span> </span>birl<span>.</span><span>difference</span><span>(</span>last<span>.</span>published<span>,</span><span> </span>first<span>.</span>published<span>)</span><span>
</span></span></span><span><span><span>      </span><span>let</span><span> </span>days<span> </span><span>=</span><span> </span>int<span>.</span><span>max</span><span>(</span><span>1</span><span>,</span><span> </span>duration<span>.</span><span>blur_to</span><span>(</span>delta<span>,</span><span> </span>duration<span>.</span><span>D</span>ay<span>))</span><span>
</span></span></span><span><span><span>      </span><span>let</span><span> </span>posts_per_day<span> </span><span>=</span><span>
</span></span></span><span><span><span>        </span>int<span>.</span><span>to_float</span><span>(</span>list<span>.</span><span>length</span><span>(</span>entries<span>))</span><span> </span><span>/.</span><span> </span>int<span>.</span><span>to_float</span><span>(</span>days<span>)</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>      </span><span>case</span><span> </span>posts_per_day<span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>// once a month or less
</span></span></span><span><span><span></span><span>        </span>n<span> </span><span>if</span><span> </span>n<span> </span><span>&lt;=.</span><span> </span><span>1.0</span><span> </span><span>/.</span><span> </span><span>30.0</span><span> </span><span>-&gt;</span><span> </span><span>0</span><span>
</span></span></span><span><span><span>        </span><span>// once week or less
</span></span></span><span><span><span></span><span>        </span>n<span> </span><span>if</span><span> </span>n<span> </span><span>&lt;=.</span><span> </span><span>1.0</span><span> </span><span>/.</span><span> </span><span>7.0</span><span> </span><span>-&gt;</span><span> </span><span>1</span><span>
</span></span></span><span><span><span>        </span><span>// once a day or less
</span></span></span><span><span><span></span><span>        </span>n<span> </span><span>if</span><span> </span>n<span> </span><span>&lt;=.</span><span> </span><span>1.0</span><span> </span><span>-&gt;</span><span> </span><span>2</span><span>
</span></span></span><span><span><span>        </span><span>// 5 times a day or less
</span></span></span><span><span><span></span><span>        </span>n<span> </span><span>if</span><span> </span>n<span> </span><span>&lt;=.</span><span> </span><span>5.0</span><span> </span><span>-&gt;</span><span> </span><span>3</span><span>
</span></span></span><span><span><span>        </span><span>// 20 times a day or less
</span></span></span><span><span><span></span><span>        </span>n<span> </span><span>if</span><span> </span>n<span> </span><span>&lt;=.</span><span> </span><span>20.0</span><span> </span><span>-&gt;</span><span> </span><span>4</span><span>
</span></span></span><span><span><span>        </span><span>// more
</span></span></span><span><span><span></span><span>        </span>_<span> </span><span>-&gt;</span><span> </span><span>5</span><span>
</span></span></span><span><span><span>      </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span>    </span>_<span>,</span><span> </span>_<span> </span><span>-&gt;</span><span> </span><span>0</span><span>
</span></span></span><span><span><span>  </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span></span></span></code></pre>
</div>
</div>
<p>
The minimal feed reader spin-off I could think of was then to:</p>
<ol>
<li>dump my followed feeds into a file,</li>
<li>write a program that periodically pulls entries from each feed on the list,</li>
<li>sorts them in reverse frequency,</li>
<li>serves them as a list of links.</li>
</ol>
<h2 id="the-design">
the design
</h2>
<p>
The approach I took to design the app was: try to do what you would do in Erlang and see if that fits in Gleam. I came up with this:</p>
<ul>
<li>A set of <a href="https://www.erlang.org/docs/24/man/gen_server">gen_servers</a>, one per feed, that would periodically request the feed URL, parse the entries, and store them in the process state.</li>
<li>Another gen_server that would periodically query each feed poller process for its most recent list of entries, sort them, and dump them into a globally accessible <a href="https://www.erlang.org/docs/24/man/ets">ETS table</a>. (That way, no process becomes a source of contention between clients trying to read the data, and the rebuilding of the table doesn’t delay its reading).</li>
<li>A minimal web server that would just query the table and build an HTML list of the current entries.</li>
</ul>
<p>I wouldn’t bother with persisting the entries to a data store, although I would keep a file cache of XML  responses to rebuild the state on app restarts without spamming the source sites.</p>
<p>
The final result was very close to this initial design, with the exception that I opted for a <a href="https://www.erlang.org/doc/apps/erts/persistent_term.html">persistent_term</a> instead of an ETS table, since I didn’t want to get entries by key but read the full list on every request.</p>
<h2 id="env-setup">
env setup
</h2>
<p>
As a digression, I want to echo something I <a href="https://batsov.com/articles/2024/02/27/m-x-reloaded-the-second-golden-age-of-emacs/">read recently</a>: this is a great time to be an Emacs user. Thanks to LSP, tree-sitter, and <a href="https://github.com/radian-software/apheleia">apheleia</a>, I get a very consistent UX for new languages practically out of the box, something that a couple of years ago required days of tweaking to get right.</p>
<p>
I don’t know if it’s a particular inclination of the language designer or that’s just how things are done today, but I was surprised to see how much emphasis is put on improving the developer experience and, specifically, adding features to the Language Server implementation. During my first week of development, I constantly missed the ability to <code>lsp-rename</code> I have in other languages; during my second week, <a href="https://gleam.run/news/gleam-gets-rename-variable/">a new Gleam version</a> came out adding that very feature!</p>
<h2 id="learning">
learning
</h2>
<ul>
<li>I learned most of what I needed to know in 30 minutes, through the <a href="https://tour.gleam.run/">official tour</a>. I had the advantage of being already familiar with Rust and Erlang, but I would say that the fact that everything can be covered so succinctly speaks of the effort that went into keeping the language small and simple.</li>
<li>For the standard libraries and external dependencies, their respective hex docs pages are the way to go.</li>
<li>To pick up on conceptual discussions, ask questions, and learn what’s idiomatic, I found that (unfortunately for me) the discord channel is more effective than searching GitHub.</li>
</ul>
<h2 id="the-language">
the language
</h2>
<ul>
<li>The language specification is already stable, having reached 1.0 about <a href="https://gleam.run/news/gleam-version-1/">a year ago</a>.</li>
<li>The syntax feels like a functional subset of Rust, with Elixir-like pipes (<code>|&gt;</code>) and a standard library adjusted to take advantage of them.</li>
<li>
<p>One of the things I pay more attention to in a programming language, and one that can be a good indicator of its “vibe”, is how it deals with imports and namespaces. I think Gleam gets this <em>exactly</em> right, with namespaces matching modules matching filenames, a single directive for imports, and qualified imports as <a href="https://tour.gleam.run/basics/modules/">the easy default</a>:</p>
<div>
<div>
<pre><code><span><span><span>import</span><span> </span>gleam<span>/</span>io<span>
</span></span></span><span><span><span></span><span>import</span><span> </span>gleam<span>/</span>string<span> </span><span>as</span><span> </span>text<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>fn</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>  </span><span>// Use a function from the `gleam/io` module
</span></span></span><span><span><span></span><span>  </span>io<span>.</span><span>println</span><span>(</span><span>&#34;Hello, Mike!&#34;</span><span>)</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>  </span><span>// Use a function from the `gleam/string` module
</span></span></span><span><span><span></span><span>  </span>io<span>.</span><span>println</span><span>(</span>text<span>.</span><span>reverse</span><span>(</span><span>&#34;Hello, Joe!&#34;</span><span>))</span><span>
</span></span></span><span><span><span></span><span>}</span></span></span></code></pre>
</div>
</div>
<p>
Qualified imports are the best default in my opinion, but they can be redundant when importing types. Gleam <a href="https://tour.gleam.run/basics/type-imports/">has that covered</a> too:</p>
<div>
<div>
<pre><code><span><span><span>import</span><span> </span>gleam<span>/</span>bytes_tree<span>
</span></span></span><span><span><span></span><span>import</span><span> </span>gleam<span>/</span>string_tree<span>.</span><span>{</span><span>type</span><span> </span><span>StringTree</span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>fn</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>  </span><span>// Referring to a type in a qualified way
</span></span></span><span><span><span></span><span>  </span><span>let</span><span> </span>_bytes<span>:</span><span> </span>bytes_tree<span>.</span><span>B</span>ytesTree<span> </span><span>=</span><span> </span>bytes_tree<span>.</span><span>new</span><span>()</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>  </span><span>// Refering to a type in an unqualified way
</span></span></span><span><span><span></span><span>  </span><span>let</span><span> </span>_text<span>:</span><span> </span><span>StringTree</span><span> </span><span>=</span><span> </span>string_tree<span>.</span><span>new</span><span>()</span><span>
</span></span></span><span><span><span></span><span>}</span></span></span></code></pre>
</div>
</div>
</li>
<li>
<p>There is no magic: no macros, no meta-programming, no traits, no default or rest arguments. This is usually fine for me, except when printing values for debugging, which becomes very tedious since everything needs to be coerced to a string and manually concatenated:</p>
<div>
<div>
<pre><code><span><span>io<span>.</span><span>println</span><span>(</span><span>
</span></span></span><span><span><span>  </span><span>&#34;ERROR requesting &#34;</span><span>
</span></span></span><span><span><span>  </span><span>&lt;&gt;</span><span> </span>feed<span>.</span>url<span>
</span></span></span><span><span><span>  </span><span>&lt;&gt;</span><span> </span><span>&#34;</span><span>\n</span><span>&#34;</span><span>
</span></span></span><span><span><span>  </span><span>&lt;&gt;</span><span> </span>string<span>.</span><span>inspect</span><span>(</span>resp<span>.</span>status<span>)</span><span>
</span></span></span><span><span><span>  </span><span>&lt;&gt;</span><span> </span><span>&#34; &#34;</span><span>
</span></span></span><span><span><span>  </span><span>&lt;&gt;</span><span> </span>string<span>.</span><span>inspect</span><span>(</span>error<span>),</span><span>
</span></span></span><span><span><span></span><span>)</span></span></span></code></pre>
</div>
</div>
</li>
</ul>
<h2 id="error-handling">
error handling
</h2>
<p>
Error handling is always a contentious topic, especially in languages that have errors as values. There’s usually some language support to ease the burden of checking results: Elixir has <a href="https://hexdocs.pm/elixir/1.15.8/Kernel.SpecialForms.html#with/1">with expressions</a>, Rust has the <a href="https://doc.rust-lang.org/rust-by-example/std/result/question_mark.html">question mark operator</a>, Go has, uh, if statements. The Gleam equivalent to those is the <a href="https://tour.gleam.run/advanced-features/use/">use &lt;- expression</a>.</p>
<p>
<code>use</code> is perhaps the only “special” bit of syntax of the language, and the one that requires more effort to get used to. One way to think about <code>use</code> is that it “absorbs” the callback argument of a function much like the pipe “absorbs” the first argument of an operation. For example:</p>
<div>
<div>
<pre><code><span><span><span>pub</span><span> </span><span>fn</span><span> </span><span>handle_request</span><span>(</span>request<span>:</span><span> </span><span>HttpRequest</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>  </span>logger<span>.</span><span>span</span><span>(</span><span>&#34;handle_request&#34;</span><span>,</span><span> </span><span>fn</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span>database<span>.</span><span>connection</span><span>(</span><span>fn</span><span>(</span>conn<span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>      </span><span>case</span><span> </span>request<span>.</span>method<span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>P</span>ost<span> </span><span>-&gt;</span><span>
</span></span></span><span><span><span>          </span><span>case</span><span> </span>database<span>.</span><span>insert</span><span>(</span>conn<span>,</span><span> </span>request<span>.</span>body<span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>Ok</span><span>(</span>record<span>)</span><span> </span><span>-&gt;</span><span> </span><span>created_response</span><span>(</span>record<span>)</span><span>
</span></span></span><span><span><span>            </span><span>Error</span><span>(</span>exc<span>)</span><span> </span><span>-&gt;</span><span> </span><span>bad_request_response</span><span>(</span>exc<span>)</span><span>
</span></span></span><span><span><span>          </span><span>}</span><span>
</span></span></span><span><span><span>        </span>_<span> </span><span>-&gt;</span><span> </span><span>method_not_allowed_response</span><span>()</span><span>
</span></span></span><span><span><span>      </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>})</span><span>
</span></span></span><span><span><span>  </span><span>})</span><span>
</span></span></span><span><span><span></span><span>}</span></span></span></code></pre>
</div>
</div>
<p>
Becomes:</p>
<div>
<div>
<pre><code><span><span><span>pub</span><span> </span><span>fn</span><span> </span><span>handle_request</span><span>(</span>request<span>:</span><span> </span><span>HttpRequest</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>  </span><span>use</span><span> </span><span>&lt;-</span><span> </span>logger<span>.</span><span>span</span><span>(</span><span>&#34;handle_request&#34;</span><span>)</span><span>
</span></span></span><span><span><span>  </span><span>use</span><span> </span><span>&lt;-</span><span> </span><span>require_method</span><span>(</span>request<span>,</span><span> </span><span>P</span>ost<span>)</span><span>
</span></span></span><span><span><span>  </span><span>use</span><span> </span>conn<span> </span><span>&lt;-</span><span> </span>database<span>.</span><span>connection</span><span>()</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>  </span><span>case</span><span> </span>database<span>.</span><span>insert</span><span>(</span>conn<span>,</span><span> </span>request<span>.</span>body<span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>Ok</span><span>(</span>record<span>)</span><span> </span><span>-&gt;</span><span> </span><span>created_response</span><span>(</span>record<span>)</span><span>
</span></span></span><span><span><span>    </span><span>Error</span><span>(</span>exc<span>)</span><span> </span><span>-&gt;</span><span> </span><span>bad_request_response</span><span>(</span>exc<span>)</span><span>
</span></span></span><span><span><span>  </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span></span></span></code></pre>
</div>
</div>
<p>
I admit I haven’t my got a-ha! moment with <code>use</code> yet, and I still struggle with error handling. Part of the problem, I think, is that <code>use</code> helps with callbacks, which are much less frequent than <code>Result</code> values, so function calls typically need to be wrapped in <a href="https://hexdocs.pm/gleam_stdlib/gleam/result.html#try"><code>result.try</code></a> and, since different functions tend to return different error types, this occasionally needs to be paired with <a href="https://hexdocs.pm/gleam_stdlib/gleam/result.html#replace_error"><code>result.replace_error</code></a> to make it work:</p>
<div>
<div>
<pre><code><span><span><span>use</span><span> </span>resp<span> </span><span>&lt;-</span><span> </span>result<span>.</span><span>try</span><span>(</span><span>
</span></span></span><span><span><span>  </span>httpc<span>.</span><span>configure</span><span>()</span><span>
</span></span></span><span><span><span>  </span><span>|&gt;</span><span> </span>httpc<span>.</span><span>follow_redirects</span><span>(</span><span>True</span><span>)</span><span>
</span></span></span><span><span><span>  </span><span>|&gt;</span><span> </span>httpc<span>.</span><span>dispatch</span><span>(</span>req<span>)</span><span>
</span></span></span><span><span><span>  </span><span>|&gt;</span><span> </span>result<span>.</span><span>replace_error</span><span>(</span><span>R</span>equestError<span>),</span><span>
</span></span></span><span><span><span></span><span>)</span><span>
</span></span></span><span><span><span></span>io<span>.</span><span>println</span><span>(</span>resp<span>.</span>body<span>)</span></span></span></code></pre>
</div>
</div>
<p>
One of the patterns that emerges from this, I believe, is to define an app-specific error type and use it everywhere, mapping external errors to it.</p>
<h2 id="erlang-interop">
erlang interop
</h2>
<p>The overall impression I got is that, compared to Elixir, Gleam is more distanced from Erlang. This in part a necessity, since they are fundamentally different languages: type safety is not a straight fit to the BEAM. But I also sense an intention in Gleam’s design to “make sense” on its own, to have conceptual integrity independently from its target platform (Gleam compiles to JavaScript in addition to Erlang). There is no direct mapping for some of the Erlang types, no REPL, no discussion of concurrency in the base documentation (not even in <a href="https://gleam.run/cheatsheets/gleam-for-erlang-users/">the section</a> targeted to Erlang users). Erlang processes and OTP seem more like add-on libraries than part of the language foundation.</p>
<p>
Interop is straightforward, just declaring a function and its Erlang counterpart, with some type specs:</p>
<div>
<div>
<pre><code><span><span><span>@external</span><span>(</span>erlang<span>,</span><span> </span><span>&#34;persistent_term&#34;</span><span>,</span><span> </span><span>&#34;put&#34;</span><span>)</span><span>
</span></span></span><span><span><span></span><span>fn</span><span> </span><span>put_entries</span><span>(</span>key<span>:</span><span> </span><span>String</span><span>,</span><span> </span>value<span>:</span><span> </span><span>List</span><span>(</span><span>E</span>ntry<span>))</span><span> </span><span>-&gt;</span><span> </span>atom<span>.</span><span>A</span>tom<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>@external</span><span>(</span>erlang<span>,</span><span> </span><span>&#34;persistent_term&#34;</span><span>,</span><span> </span><span>&#34;get&#34;</span><span>)</span><span>
</span></span></span><span><span><span></span><span>fn</span><span> </span><span>get_entries</span><span>(</span>key<span>:</span><span> </span><span>String</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>List</span><span>(</span><span>E</span>ntry<span>)</span></span></span></code></pre>
</div>
</div>
<p>
Things got tricky for me when I wanted to use <a href="https://github.com/willemdj/erlsom">erlsom</a>, a quirky Erlang library to parse XML documents. For one, I had to use <code>atom.create_from_string</code> and <code>charlist.to_string</code> pervasively to interface with Gleam, which was a minor inconvenience. What was more of a problem is that, with XML docs being structurally free form, parsing an Atom feed yielded a different data structure than parsing an RSS feed, and that didn’t make sense to Gleam’s type checker.</p>
<p>
My initial implementation <a href="https://github.com/facundoolano/news.olano.dev/blob/afc2dbff7870217744d09f106fce081367904f63/src/parser.gleam#L13-L26">hacked away</a> this problem by parsing the document multiple times to “fool” the compiler—once to figure out what type of feed the document was, another to extract the entry data. The proper Gleam way of treating dynamic structures like these would be through the <a href="https://hexdocs.pm/gleam_stdlib/gleam/dynamic/decode.html#run"><code>dynamic/decode</code></a> module, but I found that too complicated for my purposes. After looking at other libraries, I realized that the right solution was to write a thin Erlang FFI module to normalize the data before passing it to Gleam. So I put together a very basic feed parser that extracts the few fields I needed into an Erlang map:</p>
<div>
<div>
<pre><code><span><span><span>-</span><span>module</span><span>(</span>parser<span>).</span>
</span></span><span><span><span>-</span><span>export</span><span>([</span>parse_feed<span>/</span><span>1</span><span>]).</span>
</span></span><span><span>
</span></span><span><span><span>parse_feed</span><span>(</span><span>Body</span><span>)</span> <span>-&gt;</span>
</span></span><span><span>    <span>Result</span> <span>=</span> <span>erlsom</span><span>:</span><span>simple_form</span><span>(</span>
</span></span><span><span>               <span>Body</span><span>,</span>
</span></span><span><span>               <span>[{</span>nameFun<span>,</span> <span>fun</span><span>(</span><span>Name</span><span>,</span> <span>_,_)</span> <span>-&gt;</span>
</span></span><span><span>                                  <span>unicode</span><span>:</span><span>characters_to_binary</span><span>(</span><span>Name</span><span>)</span>
</span></span><span><span>                          <span>end</span> <span>}]</span>
</span></span><span><span>              <span>),</span>
</span></span><span><span>    <span>try</span> <span>Result</span> <span>of</span>
</span></span><span><span>        <span>{</span>ok<span>,</span> <span>{</span><span>&lt;&lt;</span><span>&#34;rss&#34;</span><span>&gt;&gt;</span><span>,</span> <span>_,</span> <span>[{_,</span> <span>_,</span> <span>Elements</span><span>}|_]},</span> <span>_}</span> <span>-&gt;</span>
</span></span><span><span>            <span>{</span><span>&lt;&lt;</span><span>&#34;rss&#34;</span><span>&gt;&gt;</span><span>,</span> parse_rss<span>(</span><span>Elements</span><span>)};</span>
</span></span><span><span>        <span>{</span>ok<span>,</span> <span>{</span><span>&lt;&lt;</span><span>&#34;feed&#34;</span><span>&gt;&gt;</span><span>,</span> <span>_,</span> <span>Elements</span><span>},</span> <span>_}</span> <span>-&gt;</span>
</span></span><span><span>            <span>{</span><span>&lt;&lt;</span><span>&#34;atom&#34;</span><span>&gt;&gt;</span><span>,</span> parse_atom<span>(</span><span>Elements</span><span>)};</span>
</span></span><span><span>        <span>Error</span> <span>-&gt;</span>
</span></span><span><span>            <span>{</span><span>&lt;&lt;</span><span>&#34;error&#34;</span><span>&gt;&gt;</span><span>,</span> <span>Error</span><span>}</span>
</span></span><span><span>    <span>catch</span> <span>_:_</span> <span>-&gt;</span>
</span></span><span><span>            <span>{</span><span>&lt;&lt;</span><span>&#34;error&#34;</span><span>&gt;&gt;</span><span>,</span> bad_parse<span>}</span>
</span></span><span><span>    <span>end</span><span>.</span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>parse_atom</span><span>(</span><span>Elements</span><span>)</span> <span>-&gt;</span>
</span></span><span><span>    <span>lists</span><span>:</span><span>foldl</span><span>(</span><span>fun</span><span>({</span><span>&lt;&lt;</span><span>&#34;entry&#34;</span><span>&gt;&gt;</span><span>,</span> <span>_,</span> <span>Attrs</span><span>},</span> <span>Acc</span><span>)</span> <span>-&gt;</span>
</span></span><span><span>                        <span>[</span>parse_atom_entry<span>(</span><span>Attrs</span><span>,</span> <span>#{})</span> <span>|</span><span>Acc</span><span>];</span>
</span></span><span><span>                   <span>(_,</span> <span>Acc</span><span>)</span> <span>-&gt;</span> <span>Acc</span>
</span></span><span><span>                <span>end</span><span>,</span> <span>[],</span> <span>Elements</span><span>).</span>
</span></span><span><span>
</span></span><span><span><span>parse_rss</span><span>(</span><span>Elements</span><span>)</span> <span>-&gt;</span>
</span></span><span><span>    <span>lists</span><span>:</span><span>foldl</span><span>(</span><span>fun</span><span>({</span><span>&lt;&lt;</span><span>&#34;item&#34;</span><span>&gt;&gt;</span><span>,</span> <span>_,</span> <span>Attrs</span><span>},</span> <span>Acc</span><span>)</span> <span>-&gt;</span>
</span></span><span><span>                        <span>[</span>parse_rss_entry<span>(</span><span>Attrs</span><span>,</span> <span>#{})</span> <span>|</span><span>Acc</span><span>];</span>
</span></span><span><span>                   <span>(_,</span> <span>Acc</span><span>)</span> <span>-&gt;</span> <span>Acc</span>
</span></span><span><span>                <span>end</span><span>,</span> <span>[],</span> <span>Elements</span><span>).</span>
</span></span><span><span>
</span></span><span><span><span>parse_atom_entry</span><span>(</span><span>Attrs</span><span>,</span> <span>Acc</span><span>)</span> <span>-&gt;</span>
</span></span><span><span>    <span>% ...
</span></span></span><span><span><span></span>
</span></span><span><span><span>parse_rss_entry</span><span>(</span><span>Attrs</span><span>,</span> <span>Acc</span><span>)</span> <span>-&gt;</span>
</span></span><span><span>    <span>%</span> <span>...</span></span></span></code></pre>
</div>
</div>
<h2 id="otp">
otp
</h2>
<p>
OTP in Gleam is what took me the most effort to figure out. The <a href="https://hexdocs.pm/gleam_otp/index.html">hexdocs</a> cover the basics but that wasn’t enough for me to get the concepts right, especially where they differed from their Erlang counterparts. For that, I reached out to <a href="https://github.com/bcpeinhardt/learn_otp_with_gleam">this GitHub project</a>, its tests and those of the <a href="https://github.com/gleam-lang/otp">gleam/otp</a> repo, and the Gleam Discord history.</p>
<p>
The first big difference is that, in Gleam, you typically don’t pass around process ids to send messages to; instead, a process “declares” what type of messages it expects to receive by creating a <a href="https://hexdocs.pm/gleam_erlang/gleam/erlang/process.html#Subject">Subject</a>:</p>
<div>
<div>
<pre><code><span><span><span>let</span><span> </span>subject<span> </span><span>=</span><span> </span><span>new_subject</span><span>()</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>// Send a message with the subject
</span></span></span><span><span><span></span><span>send</span><span>(</span>subject<span>,</span><span> </span><span>&#34;Hello, Joe!&#34;</span><span>)</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>// Receive the message
</span></span></span><span><span><span></span><span>receive</span><span>(</span>subject<span>,</span><span> </span>within<span>:</span><span> </span><span>10</span><span>)</span></span></span></code></pre>
</div>
</div>
<p>
Creating a subject is akin to opening a channel in other languages.</p>
<p>
Therefore, when you create an <a href="https://hexdocs.pm/gleam_otp/gleam/otp/actor.html">actor</a>—Gleam’s equivalent of a <code>gen_server</code>—what you get is not a Pid but a Subject. The basic boilerplate for a server, in this case the one managing the entry table, looks like this:</p>
<div>
<div>
<pre><code><span><span><span>// type alias for convenience
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>type</span><span> </span><span>Table</span><span> </span><span>=</span><span> </span><span>Subject</span><span>(</span><span>M</span>essage<span>)</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>// Declare what types of messages this actor is going to receive
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>type</span><span> </span><span>Message</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>  </span><span>// send a message to itself to rebuild the table
</span></span></span><span><span><span></span><span>  </span><span>// the subject is passed again for scheduling the next message
</span></span></span><span><span><span></span><span>  </span><span>Rebuild</span><span>(</span><span>T</span>able<span>)</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>  </span><span>// save a new feed poller to the internal state
</span></span></span><span><span><span></span><span>  </span><span>// the poller (another subject) is passed to request entries
</span></span></span><span><span><span></span><span>  </span><span>// during table building
</span></span></span><span><span><span></span><span>  </span><span>RegisterFeed</span><span>(</span><span>S</span>tring<span>,</span><span> </span><span>P</span>oller<span>)</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>// Declare the shape of the server&#39;s internal state
</span></span></span><span><span><span></span><span>type</span><span> </span><span>State</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>  </span><span>State</span><span>(</span>feeds<span>:</span><span> </span>dict<span>.</span><span>Dict</span><span>(</span><span>S</span>tring<span>,</span><span> </span><span>P</span>oller<span>))</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>fn</span><span> </span><span>start</span><span>()</span><span> </span><span>-&gt;</span><span> </span><span>T</span>able<span> </span><span>{</span><span>
</span></span></span><span><span><span>  </span><span>let</span><span> </span>state<span> </span><span>=</span><span> </span><span>State</span><span>(</span>dict<span>.</span><span>new</span><span>())</span><span>
</span></span></span><span><span><span>  </span><span>let</span><span> </span><span>assert</span><span> </span><span>Ok</span><span>(</span>table<span>)</span><span> </span><span>=</span><span> </span>actor<span>.</span><span>start</span><span>(</span>state<span>,</span><span> </span>handle_message<span>)</span><span>
</span></span></span><span><span><span>  </span><span>put_entries</span><span>(</span>table_key<span>,</span><span> </span><span>[])</span><span>
</span></span></span><span><span><span>  </span>process<span>.</span><span>send</span><span>(</span>table<span>,</span><span> </span><span>Rebuild</span><span>(</span>table<span>))</span><span>
</span></span></span><span><span><span>  </span>table<span>
</span></span></span><span><span><span></span><span>}</span></span></span></code></pre>
</div>
</div>
<p>
The loop function just deals with the different Message variants:</p>
<div>
<div>
<pre><code><span><span><span>fn</span><span> </span><span>handle_message</span><span>(</span>message<span>:</span><span> </span><span>Message</span><span>,</span><span> </span>state<span>:</span><span> </span><span>State</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>  </span><span>let</span><span> </span>state<span> </span><span>=</span><span> </span><span>case</span><span> </span>message<span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>RegisterFeed</span><span>(</span>name<span>,</span><span> </span>poller<span>)</span><span> </span><span>-&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>      </span><span>State</span><span>(</span>dict<span>.</span><span>insert</span><span>(</span>state<span>.</span>feeds<span>,</span><span> </span>name<span>,</span><span> </span>poller<span>))</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>Rebuild</span><span>(</span>self<span>)</span><span> </span><span>-&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>      </span><span>let</span><span> </span>entries<span> </span><span>=</span><span> </span><span>latest_entries</span><span>(</span>dict<span>.</span><span>values</span><span>(</span>state<span>.</span>feeds<span>))</span><span>
</span></span></span><span><span><span>      </span><span>put_entries</span><span>(</span>table_key<span>,</span><span> </span>entries<span>)</span><span>
</span></span></span><span><span><span>      </span>process<span>.</span><span>send_after</span><span>(</span>self<span>,</span><span> </span>rebuild_interval<span>,</span><span> </span><span>Rebuild</span><span>(</span>self<span>))</span><span>
</span></span></span><span><span><span>      </span>state<span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span>  </span><span>}</span><span>
</span></span></span><span><span><span>  </span>actor<span>.</span><span>continue</span><span>(</span>state<span>)</span><span>
</span></span></span><span><span><span></span><span>}</span></span></span></code></pre>
</div>
</div>
<p>
The module’s public API has a function to register a feed in the table and another to get the latest entries:</p>
<div>
<div>
<pre><code><span><span><span>/// Add a poller to the table manager process
</span></span></span><span><span><span>/// so its entries are included when refreshing the table.
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>fn</span><span> </span><span>register</span><span>(</span>table<span>:</span><span> </span><span>Table</span><span>,</span><span> </span>name<span>:</span><span> </span><span>String</span><span>,</span><span> </span>poller<span>:</span><span> </span><span>Poller</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>  </span>process<span>.</span><span>send</span><span>(</span>table<span>,</span><span> </span><span>RegisterFeed</span><span>(</span>name<span>,</span><span> </span>poller<span>))</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>/// Return the current list of entries.
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>fn</span><span> </span><span>get</span><span>()</span><span> </span><span>-&gt;</span><span> </span><span>List</span><span>(</span><span>F</span>eedEntry<span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>  </span><span>get_entries</span><span>(</span>table_key<span>)</span><span> </span><span>|&gt;</span><span> </span>list<span>.</span><span>map</span><span>(</span><span>fn</span><span>(</span>e<span>)</span><span> </span><span>{</span><span> </span>e<span>.</span>entry<span> </span><span>})</span><span>
</span></span></span><span><span><span></span><span>}</span></span></span></code></pre>
</div>
</div>
<p>
The latter doesn’t need to receive a table (i.e. a <code>Subject(Message)</code>) because the entries are stored in a globally accessible persistent term.</p>
<p>
Unlike the rest of the language, the OTP abstractions haven’t stabilized yet. In other words, gleam_otp hasn’t reached 1.0. This was most evident with Supervisors. They come in two flavors: the older <a href="https://hexdocs.pm/gleam_otp/gleam/otp/supervisor.html">otp/supervisor</a>, which is discouraged and has a few bugs, and the newer <a href="https://hexdocs.pm/gleam_otp/gleam/otp/static_supervisor.html">otp/static_supervisor</a>, which works better but is less flexible. I went with a static supervisor <a href="https://github.com/facundoolano/news.olano.dev/blob/55c4230cc454cdec1c4b81d45453580e4ae8b320/src/table_sup.gleam">for my project</a>. The supervision tree looks like this:</p>
<div>
<div>
<pre><code><span><span> table_sup
</span></span><span><span> ├── table_worker
</span></span><span><span> └── poller_sup
</span></span><span><span>     ├── feed_poller_worker
</span></span><span><span>     ├── feed_poller_worker
</span></span><span><span>     └── ...</span></span></code></pre>
</div>
</div>
<p>
I couldn’t find a way to either pass the pollers to the table or the table to the pollers while still having every actor spawned by its supervisor. And I couldn’t work around it by making the table a named process, since I needed a Subject, not a process, to send messages to. So I <a href="https://github.com/facundoolano/news.olano.dev/blob/55c4230cc454cdec1c4b81d45453580e4ae8b320/src/table.gleam#L45-L47">hacked it</a> by storing the Subject on another persistent term every time a new Table actor starts.</p>
<h2 id="deployment">
deployment
</h2>
<p>
The documentation always uses <code>gleam run</code> to run a program, but what if I want to deploy a release to a server without installing Gleam in it? Some digging revealed there’s a <code>gleam export erlang-shipment</code> command that will build the project with Erlang modules in production mode, and with an entrypoint script to run it (provided <code>erl</code> is in the path):</p>
<div>
<div>
<pre><code><span><span>run<span>()</span> <span>{</span>
</span></span><span><span>  erl <span>\
</span></span></span><span><span><span></span>    -pa <span>&#34;</span><span>$BASE</span><span>&#34;</span>/*/ebin <span>\
</span></span></span><span><span><span></span>    -eval <span>&#34;</span><span>$PACKAGE</span><span>@@main:run(</span><span>$PACKAGE</span><span>)&#34;</span> <span>\
</span></span></span><span><span><span></span>    -noshell <span>\
</span></span></span><span><span><span></span>    -extra <span>&#34;</span><span>$@</span><span>&#34;</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span>shell<span>()</span> <span>{</span>
</span></span><span><span>  erl -pa <span>&#34;</span><span>$BASE</span><span>&#34;</span>/*/ebin
</span></span><span><span><span>}</span></span></span></code></pre>
</div>
</div>
<p>
A neat trick is to change this script to make the shell command attach to a running node:</p>
<div>
<div>
<pre><code><span><span> run() {
</span></span><span><span>   erl \
</span></span><span><span>     -pa &#34;$BASE&#34;/*/ebin \
</span></span><span><span>     -eval &#34;$PACKAGE@@main:run($PACKAGE)&#34; \
</span></span><span><span>     -noshell \
</span></span><span><span><span>+    -name news@127.0.0.1 \
</span></span></span><span><span><span></span>     -extra &#34;$@&#34;
</span></span><span><span> }
</span></span><span><span>
</span></span><span><span> shell() {
</span></span><span><span><span>-   erl -pa &#34;$BASE&#34;/*/ebin
</span></span></span><span><span><span></span><span>+   erl -pa &#34;$BASE&#34;/*/ebin -name sh@127.0.0.1 -remsh news@127.0.0.1
</span></span></span><span><span><span></span> }
</span></span></code></pre>
</div>
</div>
<p>
That way one can interact with the (Erlang compiled) Gleam modules:</p>
<div>
<div>
<pre><code><span><span>$ build/erlang-shipment/entrypoint.sh shell
</span></span><span><span>Erlang/OTP 27 [erts-15.0] [source] [64-bit] [smp:10:10] [ds:10:10:10] [async-threads:1] [jit]
</span></span><span><span>
</span></span><span><span>Eshell V15.0 (press Ctrl+G to abort, type help(). for help)
</span></span><span><span>(news@127.0.0.1)1&gt; table:get().
</span></span><span><span>[{entry,&lt;&lt;&#34;Copy first, create later&#34;&gt;&gt;,
</span></span><span><span>        &lt;&lt;&#34;https://resextensa.co/p/copy-first-create-later&#34;&gt;&gt;,
</span></span><span><span>        {time,1740158441000000,0,none,none}},
</span></span><span><span> {entry,&lt;&lt;&#34;The CRPG Renaissance, Part 3: TSR is Dead&#34;...&gt;&gt;,
</span></span><span><span>        &lt;&lt;&#34;https://filfre.net/2025/02/the-crpg-renaissance-part-3-tsr-is-dead&#34;&gt;&gt;,
</span></span><span><span>        {time,1740157523000000,0,none,none}},
</span></span><span><span> {entry,...},
</span></span><span><span> {...}|...]</span></span></code></pre>
</div>
</div>
<p>
I briefly documented the rest of my deployment setup <a href="https://github.com/facundoolano/news.olano.dev/blob/55c4230cc454cdec1c4b81d45453580e4ae8b320/README.md#deploy">here</a>.</p>
<h2 id="thoughts">
thoughts
</h2>
<p>
I’m not sure if the designer or the community would agree but, to me, Gleam’s killer feature—the reason I would choose it over other languages—is its Erlang/OTP integration. Since that part of the language doesn’t seem stable yet, a custom Gleam wrapper to the Erlang libraries may be a better option for now. And, while I wouldn’t use this in production yet, it feels ready enough, and pleasant enough to work with, that I would make it my default for personal projects that are a good fit for the BEAM. The type system, the LSP integration, and the error handling bring something distinct to the ecosystem, and I only expect it to get better on those fronts.</p>
<p>
As far as a “Rust without memory management and with better concurrency” goes, I knew going in that Gleam could only be part of the answer. I don’t think Gleam can be a general-purpose language, just like Erlang cannot: the BEAM makes very specific and unusual trade-offs, which don’t make it a reasonable choice for applications that require computation efficiency, that need to be easy to distribute and operate, or that don’t benefit from high concurrency.</p>
<p>
Perhaps the most interesting question, which I certainly won’t try to answer here, is: are type safety and <em>let it crash</em> compatible? Can they be complementary? Erlang is <a href="https://ferd.ca/the-zen-of-erlang.html">all about</a> tolerating faults: accepting that you can’t possibly catch all errors, and you’d be better off designing your application to recover in the presence of the unexpected. This has the benefit that some error-handling code goes away, absorbed by the application structure and its supervision tree. Gleam, like Rust, makes you think preemptively about errors and spend more time dealing with them while writing code. One could argue that, by doing this, an entire problem space disappears—the silly type errors that inevitably slip into all dynamically typed programs—leaving OTP to deal with the truly unexpected. There’s a tension, but there’s also an interesting balance to strike here, and I’m curious to see where the Gleam community settles it.</p>
<h2 id="notes">
notes
</h2>


      

      </div></div>
  </body>
</html>
