<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://danluu.com/latency-pitfalls/">Original</a>
    <h1>Some latency measurement pitfalls</h1>
    
    <div id="readability-page-1" class="page"><i><b><a href="https://patreon.com/danluu">I&#39;m trying some experimental tiers on Patreon</a></b> to see if I can get to <a href="https://twitter.com/danluu/status/1456346963691991041">substack-like levels of financial support for this blog without moving to substack</a>!</i> <hr/> <strong>Some latency measurement pitfalls</strong> <p><small><i>This is a pseudo-transcript (actual words modified to be more readable than a 100% faithful transcription) of a short lightning talk I did at Twitter a year or two ago, on pitfalls of how we use latency metrics (with the actual service names anonymized per a comms request). Since this presentation, significant progress has been made on this on the infra side, so the situation is much improved over what was presented, but I think this is still relevant since, from talking to folks at peer companies, many folks are facing similar issues.</i></small></p> <p>We frequently use <a href="https://research.google/pubs/pub40801/">tail latency</a> metrics here at Twitter. Most frequently, service owners want to get cluster-wide or Twitter-wide latency numbers for their services. Unfortunately, the numbers that service owners tend to use differ from what we&#39;d like to measure due some historical quirks in our latency measurement setup:</p> <ul> <li>Opaque, uninstrumented, latency</li> <li>Lack of, cluster-wide, aggregation capability</li> <li>Minutely resolution</li> </ul> <h4 id="opaque-uninstrumented-latency">Opaque, uninstrumented, latency</h4> <p>When we look at the dashboards for most services, the latency metrics that are displayed and are used for alerting are usually from the server the service itself is running on. Some services that have dashboards set up by senior SREs who&#39;ve been burned by invisible latency before will also have the service&#39;s client-observed latency from callers of the service. I&#39;d like to discuss three issues with this setup.</p> <p>For the purposes of this talk, we can view a client request as passing through the following pipeline after client &#34;user&#34; code passes the request to our RPC layer, Finagle(<a href="https://twitter.github.io/finagle/">https://twitter.github.io/finagle/</a>), and before client user code receive the response (the way Finagle currently handles requests, we can&#39;t get timestamps for a particular request once the request is handled over to the network library we use, <a href="(https://netty.io/)">netty</a></p> <p><code>client netty -&gt; client Linux -&gt; network -&gt; server Linux -&gt; server netty -&gt; server &#34;user code&#34; -&gt; server netty -&gt; server Linux -&gt; network -&gt; client Linux -&gt; client netty</code></p> <p>As we previously saw in [an internal document quantifying the impact of <a href="https://www.kernel.org/doc/html/latest/scheduler/sched-bwc.html">CFS bandwidth control throttling</a> and how our use of excessively large thread pools causes throttling], we frequently get a lot of queuing in and below netty, which has the knock-off effect of causing services to get throttled by the kernel, which often results in a lot of opaque latency, especially when under high load, when we most want dashboards to show correct latency numbers..</p> <p>When we sample latency at the server, we basically get latency from</p> <ul> <li>Server service &#34;user&#34; code</li> </ul> <p>When we sample latency at the client, we basically get</p> <ul> <li>Server service &#34;user&#34; code</li> <li>Server-side netty</li> <li>Server-side Linux latency</li> <li>Client-side Linux latency</li> <li>Client-side netty latency</li> </ul> <p>Two issues with this are that we don&#39;t, with metrics data, have a nice way to tell if latency is in the opaque parts of the stack are coming from the client or the server. As a service owner, if you set alerts based on client latency, you&#39;ll get alerted when client latency rises because there&#39;s too much queuing in netty or Linux on the client even when your service is running smoothly.</p> <p>Also, the client latency metrics that are reasonable to look at given what we expose give you latency for all servers a client talks to, which is a really different view from what we see on server metrics, which gives us per-server latency numbers and there isn&#39;t a good way to aggregate per-server client numbers across all clients, so it&#39;s difficult to tell, for example, if a particular instance of a server has high latency in netty.</p> <p>Below are a handful examples of cluster-wide measurements of latency measured at the client vs. the server. These were deliberately selected to show a cross-section of deltas between the client and the server.</p> <p><img src="https://macwright.com/images/latency-pitfalls/service-1.png" alt="Graph showing large difference between latency measured at the client vs. at the server" width="1259" height="778"/></p> <p>This is a <a href="https://en.wikipedia.org/wiki/Cumulative_distribution_function">CDF</a>, presented with the standard orientation for a CDF, with the percentile is on the y-axis and the value on the x-axis, which makes down and to the right higher latency and up and to the left lower latency, and a flatter line meaning latency is increasing quickly and a steeper line meaning that latency is increasing more slowly.</p> <p>Because the chart is log scale on both axes, the difference between client and server latency is large even though the lines don&#39;t look all that far apart. For example, if we look at 99%-ile latency, we can see that it&#39;s ~16ms when measured at the server and ~240ms when measured at the client, a factor of 15 difference. Alternately, if we look at a fixed latency, like 240ms, and look up the percentile, we see that&#39;s 99%-ile latency on the client, but well above 99.9%-ile latency on the server.</p> <p>The graphs below have similar properties, although the delta between client and server will vary.</p> <p><img src="https://macwright.com/images/latency-pitfalls/service-2.png" alt="Graph showing moderate at the client vs. at the server until p99.5, with large difference above p99.5" width="1259" height="778"/> <img src="https://macwright.com/images/latency-pitfalls/service-3.png" alt="Graph showing small difference between latency measured at the client vs. at the server until p74, with increasing divergence after that" width="1259" height="778"/> <img src="https://macwright.com/images/latency-pitfalls/service-4.png" alt="Graph showing moderate difference between latency measured at the client vs. at the server until close to client timeout value, with large divergence near timeout value" width="1259" height="778"/> <img src="https://macwright.com/images/latency-pitfalls/service-5.png" alt="Graph showing small difference between latency measured at the client vs. at the server unil p999, with rapid increasing after that" width="1259" height="778"/></p> <p>We can see that latencies often differ significantly when measured at the client vs. when measured at the server and that, even in cases where the delta is small for lower percentiles, it sometimes gets large at higher percentiles, where more load can result in more queueing and therefore more latency in netty and the kernel.</p> <p>One thing to note is that, for any particular measured server latency value, we see a very wide range of client latency values. For example, here&#39;s a zoomed in scatterplot of client vs. server latency for <code>service-5</code>. If we were to zoom out, we&#39;d see that for a request with a server-measured latency of 10ms, we can see client-measured latencies as high as 500ms. More generally, we see many requests where the server-measured latency is very similar to the client-measured latency, with a smattering of requests where the server-measured latency is a very inaccurate representation of the client-measured latency. In almost all of those cases, the client-measured latency is higher due to queuing in a part of the stack that&#39;s opaque to us and, in a (very) few cases, the client-measured latency is lower due to some issues in our instrumentation. In the plot below, due to how we track latencies, we only have 1ms granularity on latencies. The points on the plots below have been randomly jittered by +/- 0.4ms to give a better idea of the distribution at points on the plot that are very dense.</p> <p><img src="https://macwright.com/images/latency-pitfalls/service-scatter.png" alt="Per-request scatterplot of client vs. server latency, showing that any particular server latency value can be associated with a very wide range of client latency values" width="1259" height="778"/></p> <p>While it&#39;s possible to plumb instrumentation through netty and the kernel to track request latencies after Finagle has handed them off (the kernel even has hooks that would make this somewhat straightforward), that&#39;s probably more work than is worth it in the near future. If you want to get an idea for how your service is impacted by opaque latency, it&#39;s fairly easy to get a rough idea with <a href="https://zipkin.io/">Zipkin</a> if you leverage <a href="https://macwright.com/tracing-analytics/">the work Rebecca Isaacs, Jonathan Simms, and Rahul Iyer have done</a>, which is how I generated the plots above. The code for these is checked into [a path in our monorepo] and you can plug in your own service names if you just want to check out a different service.</p> <h4 id="lack-of-cluster-wide-aggregation-capability">Lack of cluster-wide aggregation capability</h4> <p>In the examples above, we were able to get cluster-wide latency percentiles because we used data from Zipkin, which attempts to sample requests uniformly at random. For a variety of reasons, service owners mostly rely on metrics data which, while more complete because it&#39;s unsampled, doesn&#39;t let us compute cluster-wide aggregates because we pre-compute fixed aggregations on a per-shard basis and there&#39;s no way to reconstruct the cluster-wide aggregate from the per-shard aggregates.</p> <p>From looking at dashboards of our services, the most common latency target is a per-shard average of shard-level 99%-ile latency (with some services that are deep in the request tree, like cache, using numbers further in the tail). Unfortunately, taking the average of per-shard tail latency defeats the purpose of monitoring tail latency. If <a href="https://brooker.co.za/blog/2021/04/19/latency.html">we think about why we want to use tail latency</a> because, when we have high fanout and high depth request trees, a very small fraction of server responses slowing down can slow down many or most top-level requests, taking the average of tail latency fails to capture the value of using tail latency since the average of shard-level tail latencies fails to capture the property that a small fraction of server responses being slow can slow down many or most requests while <a href="https://brooker.co.za/blog/2017/12/28/mean.html">also missing out on the advantages of looking at cluster-wide averages</a>, which can be reconstructed from per-shard averages.</p> <p>For example, when we have a few bad nodes returning , that has a small impact on the average per-shard tail latency even though cluster-wide tail latency will be highly elevated. As we saw in [a document quantifying the extent of machine-level issues across the fleet as well as the impact on data integrity and performance], we frequently have host-level issues that can drive tail latency on a node up by one or more orders of magnitude, which can sometimes drive median latency on the node up past the tail latency on other nodes. Since a few or even one such node can determine the tail latency for a cluster, taking the average across all nodes can be misleading, e.g., if we have a 100 node cluster where tail latency is up by 10x on one node, this might cause our average of cluster-wide latencies to increase by a factor of 0.99 + 0.01 * 10 = 1.09 when the actual increase in tail latency is much larger.</p> <p>Some service owners try to get a better approximation of cluster-wide tail latency by taking a percentile of the 99%-ile, often the 90%-ile or the 99%-ile, but this doesn&#39;t work either and there is, in general, no per-shard percentile or other aggregation of per-shard tail latencies that can reconstruct the cluster-level tail latency.</p> <p>Below are plots of the various attempts that people have on dashboards to get cluster-wide latency with instance-level metrics data vs. actual (sampled) cluster-wide latency on a service which makes the percentile of percentile attempts more accurate than for smaller services. We can see the correlation is very weak and has the problem we expect, where the average of the tail isn&#39;t influenced by outlier shards as much as it &#34;should be&#34; and the various commonly used percentiles either aren&#39;t influenced enough or are influenced too much, on average and are also weakly correlated with the actual latencies. Because we track metrics with minutely granularity, each point in the graphs below represents one minute, with the sampled cluster-wide p999 latency on the x-axis and the dashboard aggregated metric value on the y-axis. Because we have 1ms granularity on individual latency measurements from our tracing pipeline, points are jittered horizontally +/- 0.3ms to give a better idea of the distribution (no such jitter is applied vertically since we don&#39;t have this limitation in our metrics pipeline, so that data is higher precision).</p> <p><img src="https://macwright.com/images/latency-pitfalls/cluster-1.png" alt="Per-minute scatterplot of average of per-shard p999 vs. actual p999, showing that average of per-shard p999 is a very poor approximation" width="1259" height="778"/> <img src="https://macwright.com/images/latency-pitfalls/cluster-2.png" alt="Per-minute scatterplot of p99 of per-shard p999 vs. actual p999, showing that p99 of per-shard p999 is a poor approximation" width="1259" height="778"/> <img src="https://macwright.com/images/latency-pitfalls/cluster-3.png" alt="Per-minute scatterplot of p999 of per-shard p999 vs. actual p999, showing that p999 of per-shard p999 is a very poor approximation" width="1259" height="778"/></p> <p>The correlation between cluster-wide latency and aggregations of per-shard latency is weak enough that even if you pick the aggregation that results in the correct average behavior, the value will still be quite wrong for almost all samples (minutes). Given our infra, the only solutions that can really work here are extending our tracing pipeline for use on dashboards and with alerts or adding metric histograms to Finagle and plumbing that data up through everything and the into [dashboard software] so that we can get proper cluster-level aggregations.</p> <p>While it&#39;s popular to take the average of tail latencies because it&#39;s easy and people are familiar with it (e.g., the TL of observability at [redacted peer company name] has said that they shouldn&#39;t bother with anything other than averages because everyone just wants averages), taking the average or another aggregation of shard-level tail latencies has neither the properties people want nor the properties people expect.</p> <h4 id="minutely-resolution">Minutely resolution</h4> <p>Another, independent, issue that&#39;s a gap in our ability to observe what&#39;s going on with our infrastructure is that we only collect metrics at a minutely granularity. Rezolus does metrics collection on a secondly (and in some cases, even sub-secondly) granularity, but for reasons that are beyond the scope of this talk, it&#39;s generally only used for system-level metrics (with a few exceptions).</p> <p>We&#39;ve all seen incidents where some bursty, sub-minutely event, is the cause of a problem. Let&#39;s look at an example of one such incident. In this incident, a service had elevated latency and error rate. Looking at the standard metrics we export wasn&#39;t informative, but looking at sub-minutely metrics immediately reveals a clue:</p> <p><img src="https://macwright.com/images/latency-pitfalls/minutely-1.png" alt="Plot of per-request latency for sampled requests, showing large spike followed by severely reduced request rate" width="1259" height="778"/></p> <p>For this particular shard of a cache (and many others, not shown), there&#39;s a very large increase in latency at <code>time 0</code>, followed by 30 seconds of very low request rate. The 30 seconds is because shards of <code>service-6</code> were configured to mark servers they talk to as dead for 30 seconds if <code>service-6</code> clients encounter too many failed requests. This decision is distributed, which is why the request rate to the impacted shard of <code>cache-1</code> isn&#39;t zero; some shards of <code>service-6</code> didn&#39;t send requests to that particular shard of <code>cache-1</code> during during the period of elevated latency, so they didn&#39;t mark that shard of <code>cache-1</code> as dead and continued to issue requests.</p> <p>A sub-minutely view of request latency made it very obvious what mechanism caused elevated error rates and latency in <code>service-6</code>.</p> <p>One thing to note is that the lack of sub-minutely visibility wasn&#39;t the only issue here. Much of the elevated latency was in places that are invisible to the latency metric, resulting in monitoring <code>cache-1</code> latencies insufficient to detect the issue. Below, the reported latency metrics for a single instance of <code>cache-1</code> are the blue points and the measured (sampled) latency the client observed is the black line. Reported p99 latency is 0.37ms, but actual p99 latency is ~580ms, an over three order of magnitude difference.</p> <p><img src="https://macwright.com/images/latency-pitfalls/minutely-2.png" alt="Plot of reported metric latency vs. latency from trace data, showing extremely large difference between metric latency and trace latency" width="1259" height="778"/></p> <h4 id="summary">Summary</h4> <p>Although our existing setup for reporting and alerting on latency works pretty decently, in that the site generally works and our reliability is actually quite good compared to peer companies in our size class, we do pay some significant costs as a result of our setup.</p> <p>One is that we often have incidents where it&#39;s difficult to see what&#39;s going on without using tools that are considered specialized that most people don&#39;t use, adding to the toil of being on call. Another is that, due to large margins of error in our estimates of cluster-wide latencies, we have to have to provision a very large amount of slack and keep latency SLOs that are much stricter than the actual latencies we want to achieve to avoid user-visible incidents. This increases operating costs as we&#39;ve seen in [a document comparing per-user operating costs to companies that serve similar kinds of and levels of traffic].</p> <p><i>If you enjoyed this post you might like to read about <b><a href="https://macwright.com/perf-tracing/">tracing on a single host vs. sampling profilers</a></b></i>.</p> <h4 id="appendix-open-vs-closed-loop-latency-measurements">Appendix: open vs. closed loop latency measurements</h4> <p>Some of our synthetic benchmarking setups, such as setup-1, use &#34;closed-loop&#34; measurement, where they effectively send a single request, wait for it to come back, and then send another request. Some of these allow for a degree of parallelism, where N request can be in flight at once but that still has similar problems in terms of realism.</p> <p>For a toy example of the problem, let&#39;s say that we have a service that, in production, receives exactly 1 request every second and that the service has a normal response time of 1/2 second. Under normal behavior, if we issue requests at 1 per second, we&#39;ll observe that the mean, median, and all percentile request times are 1/2 second. As an exercise for the reader, compute the mean and 90%-ile latency if the service has no parallelism and one request takes 10 seconds in the middle of a 1 minute benchmark run for a closed vs. open loop benchmark setup where the benchmarking setup issues requests at 1 per second for the open loop case, and 1 per second but waits for the previous request to finish in the closed loop case.</p> <p>For more info on this, see <a href="https://psy-lob-saw.blogspot.com/2015/03/fixing-ycsb-coordinated-omission.html">Nitsan Wakart&#39;s write-up on fixing this issue in the YCSB benchmark</a> or <a href="https://www.youtube.com/watch?v=9MKY4KypBzg">Gil Tene&#39;s presentation on this issue</a>.</p> <h4 id="appendix-use-of-unweighted-averages">Appendix: use of unweighted averages</h4> <p>An common issue with averages on dashboards that I&#39;ve looked at that&#39;s independent of the issues that come up when we take the average of tail latencies is that an unweighted average frequently underestimates the actual latency.</p> <p>Two places I commonly see an unweighted average are when someone gets an overall latency by taking an unweighted average across datacenters and when someone gets a cluster-wide latency by taking an average across shards. Both of these have the same issue, that shards that have lower load tend to have lower latency. This is especially pronounced when we fail away from a datacenter. Services that incorrectly use an unweighted average across datacenters will often show decreased latency even though actually served requests have increased latency.</p> <p><i>Thanks to Ben Kuhn for comments/corrections/discussion.</i></p>    </div>
  </body>
</html>
