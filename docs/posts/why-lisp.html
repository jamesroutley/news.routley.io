<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nyxt.atlas.engineer/article/why-lisp.org">Original</a>
    <h1>Why Lisp?</h1>
    
    <div id="readability-page-1" class="page"><p><small>Tested with Nyxt -.</small></p><p><small>Tags: lisp.</small></p><div>


  <meta charset="utf-8"/>
  <meta name="generator" content="pandoc"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes"/>
  <meta name="author" content="By John Mercouris and Pierre Neidhardt"/>
  <title>Why Lisp?</title>
  
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->


<header>


</header>
<p>A lot of people ask us the question, why do we choose to use Common Lisp as our primary development language? Often times the question comes disguised as a suggestion: &#34;Flask is a great webserver you should consider using&#34;. This is a well intentioned suggestion- of course we would like to use the best tools available! Below, we&#39;ll do our best to explain why we use Lisp, and why we think it is the best tool for our needs.</p>
<p>This is a difficult question to answer, because without knowing Lisp and the concepts from the language, it is impossible to deeply explain the benefits of said language. In the following article, we&#39;ll discover and briefly examine what makes Lisp a powerful and relevant language over 60 years after its conception.</p>

<p>Future proof is a term thrown around a lot in the tech industry. People talk about future proofing a technology as if it is as simple as thinking of every eventuality, and implementing it. This task, even if you could think of every eventuality, would be infinitely long in nature.</p>
<p>Other programming languages get around this problem by simply doing nothing about it. They expose a set of functions, syntax, libraries, run-time environment to you, and then they say &#34;this language is Turing complete and therefore should be able to do anything you want it to do.&#34;</p>
<p>Lisp takes a far different and far more pragmatic approach. The Lisp designers do not assume what syntax, features or functions will be necessary in the future. The developers of Lisp give you the full powers that they had to develop the language. You can develop macros for dynamically generating code. Without going into depth about how this mechanism works, a feat that was possible in Lisp was the implementation of an object oriented programming system without having to change the compiler!</p>

<p>Many languages have evolved in ways that have necesitated backwards compatibility breaking changes. One of the most famous examples is that of the Python 2 to the Python 3 transition. This meant that all code written in Python 2 could not be leveraged in Python 3. The end result was millions upon millions of libraries and lines of code were rendered obsolete with official support ending in 2020.</p>
<p>On the other hand, Lisp code written some 30 years ago will most of the time, without issue, work on a modern Common Lisp implementation (there are a few compatibility edge cases from the pre-unification era of Lisps under the banner of Common Lisp).</p>

<p>Traditional programming involves writing code, compiling code, and then testing the code. This is great if you can anticipate every single feature that you will want, or how everything should fit together. However, frequently, when embarking on a coding project, it helps to scratch some ideas down, and slowly build up concepts, learn things, decompose functions, and develop your program. Within the traditional compile-run loop, this process is very jarring, and takes up a lot of time.</p>
<p>Lisp solves this problem by introducing the REPL, and by being, for most implementations, image based. REPL stands for &#34;Read Evaluate Print Loop.&#34; It allows for interactive programming. When you have a running program you can compile functions, redefine classes, etc. all while the program is running. You are changing the internal state of the image.</p>
<p>For example, you remove an attribute from a class definition. Your existing objects get (lazily) updated to reflect that change, following a rule you even have control upon. You don&#39;t have to restart a process and then re-create your objects. The same is true for Lisp web development. You can create a new route, compile it and try it live without restarting the server. You didn&#39;t have to restart a process. It&#39;s all very interactive with instant feedback!</p>
<p>Furthermore, should you encounter the debugger while attempting to run something, you can re-evaluate the function that is problematic, and continue the execution of the function again (from the exact same point)!</p>

<p>There is a lot more to say about Lisp and what makes it great. I suggest you take a bit of a dive into it yourself. If my article didn&#39;t convince you, there are a few others that might:</p>
<ul>
<li><a href="http://ivy.io/common-lisp/2015/03/03/guerilla-lisp-opus.html">http://ivy.io/common-lisp/2015/03/03/guerilla-lisp-opus.html</a></li>
<li><a href="http://www.gigamonkeys.com/book/introduction-why-lisp.html">http://www.gigamonkeys.com/book/introduction-why-lisp.html</a></li>
</ul>

<p>A quick way to try Common Lisp for yourself can be seen below, I suggest you give it a try! Best of luck!</p>
<h2 id="an-editor">An Editor</h2>
<ul>
<li>Portacle, a portable and multiplatform Common Lisp development environment.</li>
<li><a href="https://portacle.github.io">https://portacle.github.io</a></li>
</ul>
<p>See also <a href="https://lispcookbook.github.io/cl-cookbook/editor-support.html">other editors</a> (Lem, Atom, Eclipse, notebooks,â€¦)</p>
<h2 id="a-quick-introduction">A Quick Introduction</h2>
<ul>
<li>Practical Common Lisp</li>
<li><a href="http://www.gigamonkeys.com/book/">http://www.gigamonkeys.com/book/</a></li>
</ul>
<h2 id="more-about-macros">More about Macros</h2>
<ul>
<li><a href="https://medium.com/@MartinCracauer/a-gentle-introduction-to-compile-time-computing-part-3-scientific-units-8e41d8a727ca">Compile Time Computing by Martin Cracauer</a></li>
</ul>
<h2 id="more-resources">More resources</h2>
<ul>
<li>The <a href="https://github.com/CodyReichert/awesome-cl">&#34;awesome-cl&#34;</a> list of libraries</li>
<li>The <a href="https://lispcookbook.github.io/cl-cookbook/">Cookbook</a></li>
<li><a href="http://stevelosh.com/blog/2018/08/a-road-to-common-lisp/">A Road to Lisp</a></li>
<li><a href="http://lisp-journey.gitlab.io/blog/these-years-in-common-lisp-2018/">These years in Common Lisp: 2018</a></li>
</ul>


</div><p>Did you enjoy this article? Register for our newsletter to
    receive the latest hacker news from the world of Lisp and
    browsers!</p></div>
  </body>
</html>
