<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/naver/lispe/wiki/6.16-Why-Lisp">Original</a>
    <h1>Why Lisp?</h1>
    
    <div id="readability-page-1" class="page"><div data-view-component="true">          <div id="wiki-body">
              <div>
                
<p><a href="https://github.com/naver/lispe/wiki/6.16-Pourquoi-Lisp">Version française</a></p>
<p><em>Lisp</em> is not dead. For a language born at the end of the 50&#39;s, this is a happy but also very surprising fact. The success of <a href="https://clojure.org" rel="nofollow"><em>Clojure</em></a> or the remarkable resistance of <a href="https://fr.wikipedia.org/wiki/Common_Lisp" rel="nofollow"><em>Common Lisp</em></a> represent a kind of anomaly in a world dominated by <em>javascript</em> and <em>Python</em>... By the way, <em>javascript</em> is in fact a <em>Lisp</em> in disguise.</p>
<p>Well, <em>Lisp</em> is not dead, and since the <em>proof has to be in the pudding</em>, we will show how our own <a href="https://github.com/naver/lispe"><em>LispE</em></a> interpreter was implemented.</p>
<p>But the question can be asked, how does a prefixed language, drowned in parentheses, still attract so much interest?</p>
<h2><a id="user-content-lisp-is-a-philosophy" aria-hidden="true" href="#lisp-is-a-philosophy"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>
<em>Lisp</em> is a philosophy</h2>
<p><em>Lisp</em> is not only one of the oldest languages still in use, but also one of the very first <em>functional languages</em> ever invented.</p>
<p><em>Lisp</em> is <em>homoiconic</em>. That is, the language is stored in the form of lists, which are also a basic data structure of the language.
This makes the language extraordinarily malleable, as this <a href="https://github.com/naver/lispe/wiki/6.13-Create-your-own-language-with-a-lot-of-transpiling:-in-LispE">example</a> shows.</p>
<p>Finally, there are few programming languages as easy to implement as <em>Lisp</em>.</p>
<p>There are two very paradoxical reasons for this.</p>
<h3><a id="user-content-the-parentheses" aria-hidden="true" href="#the-parentheses"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>The parentheses</h3>
<p>Let&#39;s take an aspect of the language that often stings the eyes of newbies: the <em>infamous parentheses</em> that the language seems to abuse.
Yes, <em>Lisp</em> uses these parentheses heavily and they sometimes make the language a bit obscure. But as <em>Lisp</em> programmers often point out, this is a bit of an illusion:</p>
<div data-snippet-clipboard-copy-content="(sin 10); Lisp
sin(10); Other language"><pre>(sin <span>10</span>)<span><span>;</span> Lisp</span>
sin(<span>10</span>)<span><span>;</span> Other language</span></pre></div>
<h3><a id="user-content-prefixed-notation" aria-hidden="true" href="#prefixed-notation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Prefixed notation</h3>
<p>Before we embark on yet another defense of the language along the lines of: <em>parentheses in Lisp are great, but only insiders can understand them</em>. Let&#39;s notice a second element that often confuses those who learn the language: in <em>Lisp everything is prefixed</em>.</p>
<p>Here we have the two most common complaints: <em>parentheses and prefixed notation</em>. And to top it all off, we also have our answer to what makes building a <em>Lisp</em> interpreter a bit of an easy ride. Well, compared to other languages, that is.</p>
<h2><a id="user-content-compiling-lisp" aria-hidden="true" href="#compiling-lisp"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Compiling <em>Lisp</em>
</h2>
<p>So here is this strange paradox which makes the highly parenthetized prefixed form of <em>Lisp</em> both the reason for rejecting the language but also for its simplicity to create interpreters to run it.</p>
<p>And all this is based on a fundamental notion in compilation theory: <em>the abstract syntax tree</em>.</p>
<h3><a id="user-content-the-abstract-syntax-tree-ast" aria-hidden="true" href="#the-abstract-syntax-tree-ast"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>The Abstract Syntax Tree (<em>AST</em>)</h3>
<p>One of the most important steps, when compiling a sequence of instructions in a language like <em>Python</em> or <em>C++</em>, is to reduce everything to trees.</p>
<p>The reason for this is very simple, a tree is the best way to express the relationships that the different objects have with each other in a program:</p>

<p>Generally, a compiler or interpreter takes the above expression and puts it through a series of transformations:</p>
<ul>
<li>tokenization</li>
<li>reorganization in the form of a tree via a formal grammar (BNF)</li>
</ul>
<p>Tokenization as its name indicates consists in cutting the string into as many autonomous units (<em>tokens</em>):</p>
<div data-snippet-clipboard-copy-content="toto=10 + a-20 # becomes: toto,=,10,+,a,-,20"><pre><span>toto</span><span>=</span><span>10</span> <span>+</span> <span>a</span><span>-</span><span>20</span> <span># becomes: toto,=,10,+,a,-,20</span></pre></div>
<p>This operation in <em>Lisp</em> is even easier than in a language like <em>Python</em>. Indeed, in most languages, tokenisation is done along the operators, spaces are rarely enough.</p>
<p>In <em>Lisp</em>, tokenisation is reduced to identifying parentheses and spaces.</p>
<div data-snippet-clipboard-copy-content="(setq toto (- (+ 10 a) 20)); becomes (,setq,toto,(,-,(,+,10,a,),20,),) "><pre>(<span>setq</span> toto (- (+ <span>10</span> a) <span>20</span>))<span><span>;</span> becomes (,setq,toto,(,-,(,+,10,a,),20,),) </span></pre></div>
<p>But above all, the fundamental difference is the construction of the tree. If we take our <em>Python</em> expression, the corresponding tree is as follows:</p>
<div data-snippet-clipboard-copy-content="                 =
               /   \
             toto   -
                   / \
                  +  20
                 / \
                10  a"><pre><code>                 =
               /   \
             toto   -
                   / \
                  +  20
                 / \
                10  a
</code></pre></div>
<p>This is the result of applying a grammar that might look like this:</p>
<div data-snippet-clipboard-copy-content="assignment :: name = expression|variable
expression :: value|variable operator variable|expression"><pre><code>assignment :: name = expression|variable
expression :: value|variable operator variable|expression
</code></pre></div>
<p>We will now perform a prefixed walk:</p>

<p>We will add parentheses to this prefixed walk, as follows, each non-terminal subtree will be injected between parentheses:</p>
<div data-snippet-clipboard-copy-content="(=)
(= toto)
(= toto (-))
(= toto (- (+)))
(= toto (- (+ 10)))
(= toto (- (+ 10 a)))
(= toto (- (+ 10 a) 20))"><pre><code>(=)
(= toto)
(= toto (-))
(= toto (- (+)))
(= toto (- (+ 10)))
(= toto (- (+ 10 a)))
(= toto (- (+ 10 a) 20))
</code></pre></div>
<p>So, this parenthetical representation is in every way similar to <em>Lisp</em>. And this is not by chance.</p>
<p>McCarthy&#39;s initial project consisted in integrating into <em>Fortran</em> symbolic expressions strongly inspired by Church&#39;s <em>lambda-calculus</em> theory: the <em>M-expressions</em>. However, it soon turned out that the intermediate step called <a href="https://arxiv.org/abs/1505.07375" rel="nofollow">S-expressions</a> was much simpler to implement.</p>
<p>If we add that the construction and application of grammars to reconstruct such a tree is far from trivial, we quickly understand how much the <em>Lisp</em> expressions avoid to a designer all the heavy architecture of traditional languages.</p>
<h3><a id="user-content-prefixed" aria-hidden="true" href="#prefixed"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Prefixed</h3>
<p>Finally, let&#39;s add that the systematic prefixed representation for operators and functions also greatly simplifies code compilation.</p>
<p>Remember for example that in <em>Python</em>, calling a function or writing a mathematical expression obey different rules. We are so used to manipulating these expressions, that we forget that this difference in syntax has a cost:</p>
<div data-snippet-clipboard-copy-content="toto = 10 + a - 20
titi = sin(a)"><pre><span>toto</span> <span>=</span> <span>10</span> <span>+</span> <span>a</span> <span>-</span> <span>20</span>
<span>titi</span> <span>=</span> <span>sin</span>(<span>a</span>)</pre></div>
<p>Indeed, we need different entry points in our grammar to understand each of these expressions.</p>
<p>If we compare these expressions to <em>Lisp</em>:</p>
<div data-snippet-clipboard-copy-content="(setq toto (- (+ 10 a) 20))
(setq titi (sin a))"><pre>(<span>setq</span> toto (- (+ <span>10</span> a) <span>20</span>))
(<span>setq</span> titi (sin a))</pre></div>
<p>You can immediately see the difference, in <em>Lisp</em> everything is a function, including operators. Thus, the compilation of numerical expressions or function calls is unified in the same formalism.</p>
<p>In a way, <em>Lisp</em> forces the user to do some of the compilation work, where other languages apply heavy grammars to build these <em>S-expressions</em>. But, it also removes many ambiguities that sometimes lead to bugs.</p>
<p>Just compare:</p>

<p>with the unambiguous form:</p>
<div data-snippet-clipboard-copy-content="(setq toto (- 10 (* 2 10))"><pre>(<span>setq</span> toto (- <span>10</span> (* <span>2</span> <span>10</span>))</pre></div>
<h3><a id="user-content-uniformity-of-syntax" aria-hidden="true" href="#uniformity-of-syntax"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Uniformity of syntax</h3>
<p>The other advantage of <em>Lisp</em> is that there is no need to invent different programming styles to integrate new features.</p>
<p><em>Python</em> offers particularly striking examples of this:</p>
<div data-snippet-clipboard-copy-content="fruits = [&#34;apple&#34;, &#34;pear&#34;, &#34;banana&#34;, &#34;strawberry&#34;]
v = [x for x in fruits if &#34;a&#34; in x]"><pre><span>fruits</span> <span>=</span> [<span>&#34;apple&#34;</span>, <span>&#34;pear&#34;</span>, <span>&#34;banana&#34;</span>, <span>&#34;strawberry&#34;</span>]
<span>v</span> <span>=</span> [<span>x</span> <span>for</span> <span>x</span> <span>in</span> <span>fruits</span> <span>if</span> <span>&#34;a&#34;</span> <span>in</span> <span>x</span>]</pre></div>
<p>Note that we have chosen <em>Python</em> as our comparison language, because it has the advantage of being simple and popular. Remember that most of these remarks could be applied to languages like <em>C++</em> or <em>Java</em>.</p>
<p>Thanks to its syntactic uniformity, <em>Lisp</em> does not need to reinvent the wheel to implement the above example:</p>
<p>Here is how we could translate this expression into <em>LispE</em>:</p>
<div data-snippet-clipboard-copy-content="(setq fruits &#39;(&#34;apple&#34; &#34;pear&#34; &#34;banana&#34; &#34;strawberry&#34;))
(setq v (filterlist (λ(x) (in x &#34;a&#34;)) fruits))"><pre>(<span>setq</span> fruits &#39;(<span><span>&#34;</span>apple<span>&#34;</span></span> <span><span>&#34;</span>pear<span>&#34;</span></span> <span><span>&#34;</span>banana<span>&#34;</span></span> <span><span>&#34;</span>strawberry<span>&#34;</span></span>))
(<span>setq</span> v (filterlist (λ(x) (in x <span><span>&#34;</span>a<span>&#34;</span></span>)) fruits))</pre></div>
<p>As we can see, the syntax remains the same.</p>
<p>Moreover, if we stay in the realm of legend, when engineers were asked to produce, in a few days, a new language for the Web, their first version looked like <em>Lisp</em>. Which the managers disliked, so they were asked to correct their copy, which gave the version of <em>javascript</em> that we know today.</p>
<p>The interest of <em>Lisp</em> is that it makes it possible to experiment with new operators or new features without having to re-implement the language grammar each time.
Many concepts in computer science, starting with object programming, started with implementations in <em>Lisp</em>.</p>
<h2><a id="user-content-lisp-is-my-guide" aria-hidden="true" href="#lisp-is-my-guide"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Lisp is my guide</h2>
<p>As I said before, <em>Lisp</em> is a philosophy. It is a way of representing and executing programs in an intermediate form between man and machine. The <em>S-expressions</em> offer a very elegant way of representing <em>code and data</em> in the same syntax.</p>
<p>Could this be used in other languages?</p>
<h3><a id="user-content-is-object-oriented-programming-soluble-in-lisp" aria-hidden="true" href="#is-object-oriented-programming-soluble-in-lisp"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Is Object Oriented Programming soluble in Lisp?</h3>
<p>I program in <em>C++</em>.</p>
<p>I know that the language has a bad reputation and some people advised me to switch to <em>Rust</em>. But, after 30 years of practice, I feel I have a certain familiarity with a language whose performances are no longer to be demonstrated.</p>
<p>Because of course, when you make your own interpreter, you expect a certain efficiency in terms of compilation and execution. <em>C++</em> allows you to tickle the processor at the edge of the metal while manipulating very high level abstractions.
But the price to pay is sometimes quite heavy, because the language is tortuous and often tricky, not to say <em>deceitful</em>.</p>
<p>The purpose of this blog is to show how one can build a <a href="https://github.com/naver/lispe"><em>Lisp</em></a> interpreter in <em>C++</em>, which is directly inspired by the <em>functional philosophy of Lisp</em>.</p>
<p>It&#39;s like <em>putting the code into a programmatic abyss</em> in a way...</p>
<h3><a id="user-content-so-what-is-this-mysterious-link-between-lisp-and-oop" aria-hidden="true" href="#so-what-is-this-mysterious-link-between-lisp-and-oop"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>So what is this mysterious link between <em>Lisp</em> and OOP?</h3>
<p>First of all, let&#39;s start with a banality: whether you practice functional programming or any other form of programming, your program will end up as machine code with lots of <em>jumps</em> in all corners.</p>
<p>I know, it&#39;s sad but that&#39;s the way it is. It&#39;s a bit like seeing a painting by a great Renaissance master. From a distance, it looks smooth and shiny, when you get closer, you see the brush strokes.</p>
<p>Anything you can program in one general purpose language, you must be able to program in another general purpose language. This is the conclusion of the famous <a href="https://fr.wikipedia.org/wiki/Th%C3%A8se_de_Church" rel="nofollow">Turing paper</a> where he explains that his machine and Alonzo Church&#39;s lambda-calculus are equivalent.</p>
<p>Without this equivalence, functional languages could not exist.</p>
<p>This does not mean that these languages are useless, on the contrary, we can reach programs of a rare sobriety and solidity within this paradigm. But basically, they exist because they can be compiled in an imperative form.</p>
<p>But conversely, the most powerful functional concepts can also be transcribed into more traditional languages:</p>
<div data-snippet-clipboard-copy-content="long factorial(long x) {
 if (x==1)
    return 1;
 else
    return x * factorial(x - 1);"><pre><span>long</span> <span>factorial</span>(<span>long</span> x) {
 <span>if</span> (x==<span>1</span>)
    <span>return</span> <span>1</span>;
 <span>else</span>
    <span>return</span> x * <span>factorial</span>(x - <span>1</span>);</pre></div>
<p>In other words, we can design a <em>C++</em> programming which is inspired by <em>Lisp</em>.</p>
<p>And it has some advantages...</p>
<h3><a id="user-content-the-list" aria-hidden="true" href="#the-list"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>The list</h3>
<p>The basic representation of <em>Lisp</em>, the one that has always defined the language and that lies at the heart of its name is the <em>list</em> (LISP = <em>LIST Processing</em>).</p>
<p>There are many ways to create lists in C++, but for now we will settle for the simplest form available: <em>vector</em>.</p>
<p>However, and this is obviously the heart of the matter, a vector in C++ can only be declared for a given type:</p>
<div data-snippet-clipboard-copy-content="std::vector&lt;Element*&gt; elements;"><pre>std::vector&lt;Element*&gt; elements;</pre></div>
<p>However, a list in <em>Lisp</em> can hold any type of elements, including values, operators and function calls.</p>
<p>For our vector to offer the same flexibility, experienced readers will have immediately guessed that it is sufficient that all objects in the language <em>derive</em> from the <em>Element</em> class.</p>
<p>Thus, if we derive from <em>Element</em>, an <em>Operator</em> class or an <em>Integer</em> class, we will be able to store operators or integers in the same structure. If moreover, we derive the <em>List</em> class from <em>Element</em>, we can then build embedded representations without any limit.</p>
<h4><a id="user-content-the-eval-function" aria-hidden="true" href="#the-eval-function"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>The <em>Eval</em> function</h4>
<p>There is just one missing element to complete our description: each derived class will have to override its own <em>Eval</em> method.</p>
<p>In the case of an integer or a string, this method will return the element itself, for a function or an operator, their <em>Eval</em> method will perform the corresponding execution.</p>
<p>Here is, for example, the main execution loop of a program:</p>
<div data-snippet-clipboard-copy-content="Element* v = null_;
for (const auto&amp; e : elements) {
   v-&gt;release()
   v = e-&gt;Eval();
}

return v;"><pre>Element* v = null_;
<span>for</span> (<span>const</span> <span>auto</span>&amp; e : elements) {
   v-&gt;<span>release</span>()
   v = e-&gt;<span>Eval</span>();
}

<span>return</span> v;</pre></div>
<p>Note the <em>release</em> method which cleans up the element when it is not used within a variable or a container. The life cycle of a data structure is based on the use of a reference counter. When this counter has the value 0, <em>release</em> cleans up this structure.</p>
<h3><a id="user-content-lisp-like-architecture" aria-hidden="true" href="#lisp-like-architecture"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Lisp-like architecture</h3>
<p>Let&#39;s take a closer look at this <em>Eval</em> function:</p>
<p>We first initialize <code>v</code> with the value <code>null_</code>, a constant value that cannot be destroyed. Thus, calling <code>release</code> here will have no effect on this variable at the entry of the loop.</p>
<p>Then we call the <code>Eval</code> method for each of the elements of the vector whose result is stored in <code>v</code>.</p>
<p>And this is where things get interesting. Each value in the interpreter is associated with a reference counter which increases by 1 when that value is stored in a variable or container. When a function is called that returns a result, two things can happen:</p>
<ul>
<li>The value comes from the application of a function</li>
<li>The value was returned by a variable or a container</li>
</ul>
<p>Now if we look closely at the loop, we see that the value of <code>v</code> is <em>systematically</em> released at each iteration, <em>except</em> for the last statement in <code>elements</code>. For values saved in a variable or a container, the call of this function has no impact. For the others, it destroys them or saves them in data pools.</p>
<p>This mode of operation is directly inspired by functional programming:</p>
<p><code>Each function returns one and only one value whose life cycle is decided locally.</code></p>
<p>If this value is not saved in a variable or in a container, it will be <em>released</em> in the loop at the next iteration, otherwise it will be returned.</p>
<p><strong>Note</strong> that <em>release</em> means that the value is either destroyed or stored in a value pool for later reuse.</p>
<p>In <em>Lisp</em>, this is exactly what a function call does:</p>
<div data-snippet-clipboard-copy-content="; the last line will return the final calculation
(defun calculus(x)
  (setq x (* x 2))
  (+ x 1)
)"><pre><span><span>;</span> the last line will return the final calculation</span>
(<span>defun</span> <span>calculus</span>(x)
  (<span>setq</span> x (* x <span>2</span>))
  (+ x <span>1</span>)
)</pre></div>
<p>What is fundamental in this approach is that the management of the returned values is purely local, there are <em>no side effects</em>. More exactly, if the value is not saved in any structure, its release in this loop can be done without any problem, it will have no impact elsewhere in the code.</p>
<p>Organizing the code in this way makes it possible to control step by step the life cycle of all data structures in memory. At each stage of the execution, data structures that are not stored in variables or containers can be safely <em>released</em>, even if the execution is done in a <em>thread</em>.</p>
<p>Thus, in the execution of: <code>(* 10 (+ 20 1) (- 15 1))</code>, the intermediate values <code>(+ 20 1)</code> or <code>(- 15 1)</code> will be used by the multiplication but <em>released</em> at the end:</p>
<div data-snippet-clipboard-copy-content="
long value = 1;
Element* v;
for (Element* e : elements) {
   v = e-&gt;Eval();
   value *= v-&gt;asNumber();
   v-&gt;release();
}

return new Integer(value);
"><pre><span>long</span> value = <span>1</span>;
Element* v;
<span>for</span> (Element* e : elements) {
   v = e-&gt;<span>Eval</span>();
   value *= v-&gt;<span>asNumber</span>();
   v-&gt;<span>release</span>();
}

<span>return</span> <span>new</span> Integer(value);
</pre></div>
<p>The above loop for example performs the multiplication of the integers in <code>elements</code>. At each iteration, the <code>v</code> that come from an intermediate calculation, are <em>released</em>.</p>
<p>Thus, we make sure that at each step, nothing is left in the memory space. Note that the final result of this loop is an intermediate object which can also be destroyed when calling this function.</p>
<h3><a id="user-content-immutability" aria-hidden="true" href="#immutability"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Immutability</h3>
<p>The other fundamental aspect of this architecture is that the objects, corresponding to instructions, <em>are by definition immutable</em>. In other words, the same object can be executed as many times as necessary without it ever being modified.</p>
<p>Finally, the execution of these instructions is done outside a virtual machine, since each object <em>necessarily</em> knows how to execute.</p>
<p>Thus, we find in this approach, the fundamental properties of functional programming.</p>
<ul>
<li>Everything is a function call (here reduced to an <em>Eval</em> call for each object)</li>
<li>Immutability of objects</li>
<li>No side effects.</li>
</ul>
<h3><a id="user-content-threads" aria-hidden="true" href="#threads"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Threads</h3>
<p>This mechanism makes it very easy to create independent <em>threads</em> which can execute the same functions in parallel. In fact, you only need to launch the <em>Eval</em> function on an object for it to run.</p>
<p>This is the most important difference with more traditional methods where instructions are translated into pseudo-code and executed by a virtual machine. For example, <em>Python</em> can only execute one virtual machine at a time, which restricts the possibility of writing threads, since they are all executed in the same space protected by the famous <em>GIL</em> (Global Interpreter Lock). <em>Python</em> can execute threads but one at a time.</p>
<p>Note that in our case, <em>threads arguments</em> are always duplicated at launch, which removes any needs to protect data from concurrent access. However, we still provide a mechanism to make it possible to share some <a href="https://github.com/naver/lispe/wiki/6.3-Threads">values across <em>threads</em></a>.</p>
<h3><a id="user-content-oop--functional" aria-hidden="true" href="#oop--functional"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>OOP + Functional</h3>
<p>On the other hand, object programming simplifies a lot some aspects that are sometimes very complex to master.
For example, the addition of objects of different types is a very difficult problem to manage and <em>Python</em> is no exception to the rule, just have a look at the implementation of <code>__add__</code> to be convinced.</p>
<div data-snippet-clipboard-copy-content="(+ 10 20 30) ; returns an integer
(+ 10.1 2.109) ; returns a float"><pre>(+ <span>10</span> <span>20</span> <span>30</span>) <span><span>;</span> returns an integer</span>
(+ <span>10.1</span> <span>2.109</span>) <span><span>;</span> returns a float</span></pre></div>
<p>In our case, this problem is actually very simple to solve.</p>
<p>The <em>Element</em> class contains the list of basic numerical methods of the language:</p>
<div data-snippet-clipboard-copy-content="virtual Element* plus(Element* e);
virtual Element* minus(Element* e);
virtual Element* multiply(Element* e);
virtual Element* divide(Element* e);    "><pre><span>virtual</span> Element* <span>plus</span>(Element* e);
<span>virtual</span> Element* <span>minus</span>(Element* e);
<span>virtual</span> Element* <span>multiply</span>(Element* e);
<span>virtual</span> Element* <span>divide</span>(Element* e);    </pre></div>
<p>So for the <em>Integer</em>, <em>Floating</em> or <em>String</em> classes, you just have to overload them to get the desired behavior.</p>
<h4><a id="user-content-list-of-instructions" aria-hidden="true" href="#list-of-instructions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>List of instructions</h4>
<p>As we said before, our implementation is based on the use of a vector of elements.
This element vector has the following form:</p>
<div data-snippet-clipboard-copy-content="std::vector&lt;Elements*&gt; list;"><pre>std::vector&lt;Elements*&gt; list;</pre></div>
<p>Taking our example again: <code>(+ 10 20 30)</code>, it could be compiled into the following form:</p>
<div data-snippet-clipboard-copy-content="list: [Operator(+), Integer(10), Integer(20), Integer(30)]"><pre>list: [Operator(+), Integer(<span>10</span>), Integer(<span>20</span>), Integer(<span>30</span>)]</pre></div>
<p><em>Operator</em> and <em>Integer</em> are instances of classes derived from: <em>Element</em>.</p>
<p>Let&#39;s override the <code>plus</code> method in our <em>Index</em> class:</p>
<div data-snippet-clipboard-copy-content="class Integer : public Element {
public:
  long value;

  Element* plus(Element* e) {
     long v = value;
     v += e-&gt;asInteger();
     return new Integer(v);
  }

  long asInteger() {
     return value;
  }
};"><pre><span>class</span> <span>Integer</span> : <span>public</span> <span>Element</span> {
<span>public:</span>
  <span>long</span> value;

  Element* <span>plus</span>(Element* e) {
     <span>long</span> v = value;
     v += e-&gt;<span>asInteger</span>();
     <span>return</span> <span>new</span> <span>Integer</span>(v);
  }

  <span>long</span> <span>asInteger</span>() {
     <span>return</span> value;
  }
};</pre></div>
<p>The <code>plus</code> method makes it possible to set the behavior of the addition for a particular type of object. Now we have to define the <code>+</code> operator within a list.</p>
<p>This gives us the method: <code>eval_plus</code> below:</p>
<div data-snippet-clipboard-copy-content="   Element* List::eval_plus() {
        //The element in position 0 is actually our &#34;plus&#34; operator.
        //We get the first element of our list of instructions at position 1
        Element* r = list[1]-&gt;Eval();
        Element* v;
        Element* inter;
        for (long i = 2; i &lt; size(); i++) {
          v = list[i]-&gt;Eval();
          inter = r-&gt;plus(v);
          v-&gt;release();
          if (r != inter) {
             r-&gt;release();
             r = inter;
          }
        }
        return r;
   }"><pre>   Element* <span>List::eval_plus</span>() {
        <span><span>//</span>The element in position 0 is actually our &#34;plus&#34; operator.</span>
        <span><span>//</span>We get the first element of our list of instructions at position 1</span>
        Element* r = list[<span>1</span>]-&gt;<span>Eval</span>();
        Element* v;
        Element* inter;
        <span>for</span> (<span>long</span> i = <span>2</span>; i &lt; <span>size</span>(); i++) {
          v = list[i]-&gt;<span>Eval</span>();
          inter = r-&gt;<span>plus</span>(v);
          v-&gt;<span>release</span>();
          <span>if</span> (r != inter) {
             r-&gt;<span>release</span>();
             r = inter;
          }
        }
        <span>return</span> r;
   }</pre></div>
<p>Note that the first data item (<em>in position 1</em>) will define the type of addition desired. Thus, if the list starts with an integer, the result will be a sum of integers at the end of the analysis. In the case of a string, it will be a concatenation.</p>
<p>The first element of the list (<em>at position 0</em>) is therefore the operator: <code>Operator(+)</code>. So we can easily imagine a mechanism, for example a <code>switch/case</code> that makes it possible to launch this particular method:</p>
<div data-snippet-clipboard-copy-content="
Element* List::Eval() {
   switch (list[0]-&gt;label()) {
     case l_cons:
          return eval_cons();
     ...
     case l_plus:
        return eval_plus();
}"><pre>Element* <span>List::Eval</span>() {
   <span>switch</span> (list[<span>0</span>]-&gt;<span>label</span>()) {
     <span>case</span> l_cons:
          <span>return</span> <span>eval_cons</span>();
     ...
     <span>case</span> l_plus:
        <span>return</span> <span>eval_plus</span>();
}</pre></div>
<p>So, each time the <em>Eval</em> method is executed from a <em>List</em> object, we will be able to execute the function placed at position 0 in our list.</p>
<p>And here is where the whole operation is revealed. If an instance in the list is an atomic value, <code>Eval</code> will return the instance itself. If, on the other hand, it is a list, we will recursively call the method above which will return the corresponding result.</p>
<p>This representation corresponds point by point to our list in <em>Lisp</em>. We just have to launch <code>Eval</code> from the root of this list to execute our whole program.</p>
<h4><a id="user-content-extensions" aria-hidden="true" href="#extensions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Extensions</h4>
<p>Extending the language is simply a matter of deriving the <em>Element</em> class and overloading the corresponding necessary methods. Thus, if we create a <em>Date</em> class, we will be able to define an addition or a subtraction specific to date management.</p>
<h2><a id="user-content-conclusion" aria-hidden="true" href="#conclusion"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Conclusion</h2>
<p>First, I want to stress how efficient the <em>interpreter</em> produced with this method is, as illustrated with this <a href="https://github.com/naver/lispe/wiki/2.5--LispE-vs.-Python:-A-Stochastic-Gradient-Descent-Comparison">experiment</a>.</p>
<p>Some people might complain that <em>Lisp</em> is too much of a niche language to engage in the effort of understanding how it was implemented.
However, what is really important in this article is that, if you create your own syntax and implement a grammar to turn it into a <em>tree</em>, you can use the underlying interpreter code in <em>C++</em> without any real modification.
In fact, we have also implemented another programming language: <a href="https://github.com/naver/tamgu"><em>TAMGU탐구</em></a>, which follows the same philosophy and still implements a language that is very similar to <em>Python</em>.</p>
<p><em>Lisp</em> might sound like some old language lost in the dark age of computer science, but when you implement a <em>Lisp</em> interpreter, what you actually create is a universal interpreter, which can run many of the programming languages in the world...</p>
<p>All you need is a tree...</p>
<p><em>And that&#39;s very cool, indeed...</em></p>

              </div>

          </div>
</div></div>
  </body>
</html>
