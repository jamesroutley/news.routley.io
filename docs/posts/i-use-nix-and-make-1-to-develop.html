<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://glorifiedgluer.com/blog/2023/developing-with-nix-and-make/">Original</a>
    <h1>I use Nix and make(1) to develop</h1>
    
    <div id="readability-page-1" class="page"><div>
  <h2>Why I use Nix and make(1) to develop
    <small>
      <time>April 19, 2023</time>
    by ~glorifiedgluer


    </small>
  </h2><p>üóíÔ∏è Initially, this blog post was called ‚Äú<em>Developing with Nix and
make(1)</em>‚Äù, however, I thought to rename it after a brief discussion
with <a href="https://github.com/soywod">soywod</a> on using Nix as the solo build system.</p>

<p>Today, <a href="https://kmaasrud.com">Magnus</a>, a friend of mine, posted <em><a href="https://kmaasrud.com/blog/make">a love letter to make</a></em>. In
his post he talks about how powerful and reliable <code>make(1)</code><sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> is,
I really recommend you go there and read it too!</p>
<p>In the meantime, he also posted his blog post to <a href="https://lobste.rs/s/mavub8/love_letter_make">lobste.rs</a>. It was a
really interesting thread as people discussed from alternatives (such
as <a href="https://github.com/casey/just">just</a> for a command runner) to lesser known features as <a href="https://lobste.rs/s/mavub8/love_letter_make#c_jjibsy">running
python as the default shell</a>. I went ahead and made <a href="https://lobste.rs/s/mavub8/love_letter_make#c_xnqvxt">a comment</a> about
using <a href="https://nixos.org">Nix</a> and Makefiles as development tools and <a href="https://lobste.rs/u/dkl">u/dkl</a> made a question
that really made me think:</p>
<blockquote>
<p>I don‚Äôt understand why Nix alone isn‚Äôt sufficient. Can you elaborate
on your setup a little?</p>
<p>‚Äîu/dkl</p>
</blockquote>
<p>I admit that my message was not clear: ‚Äú<em>using make(1) with Nix to
make dependencies easier to deal with</em>‚Äù. When I wrote this, I was
thinking about the concept of <code>prerequisites</code> make has on its <a href="https://www.gnu.org/software/make/manual/make.html#Rule-Introduction">rules</a>.
Which is nothing more than ‚Äúin order to generate this file, this other
thing has to be built successfully‚Äù.</p>
<p>Meanwhile, this made me wonder where I found Nix to not be sufficient
on my setup, more specifically, on my blog setup. As mentioned down
the same thread, this blog has a relatively simple build process:</p>
<ol>
<li>Content is written on a <a href="https://orgmode.org">Org</a> file</li>
<li>GNU Emacs transforms this file into multiple <em>hugo-compliant</em>
Markdown files</li>
<li>Hugo generates a website from the Markdown files</li>
<li>A <em>gzipped</em> archive is generated</li>
<li>The archive is sent to sourcehut pages</li>
</ol>
<p>If each step was represented in a shell line, it would look like this:</p>
<div><pre tabindex="0"><code data-lang="shell"><span><span><span># edit the Org file</span>
</span></span><span><span>emacs
</span></span><span><span><span># generate Markdown files</span>
</span></span><span><span>emacs <span>$(</span><span>pwd</span><span>)</span> --batch -load export.el
</span></span><span><span><span># generate website</span>
</span></span><span><span>hugo
</span></span><span><span><span># create gzipped archive</span>
</span></span><span><span>tar -cvzf site.tar.gz -C public .
</span></span><span><span><span># publish website to sourcehut pages</span>
</span></span><span><span>hut pages publish site.tar.gz --domain glorifiedgluer.com --not-found 404.html
</span></span></code></pre></div><h2 id="building-and-publishing-with-nix">Building and publishing with Nix</h2>
<p>This is the <strong>perfect</strong> scenario for Nix as I don‚Äôt have <em>any</em> external
dependencies to be fetched during the build steps. OK, how would one
build the website with Nix? It would probably look like this:</p>
<div><pre tabindex="0"><code data-lang="nix"><span><span><span>packages</span><span>.</span><span>website</span> <span>=</span> <span>stdenv</span><span>.</span><span>mkDerivation</span> <span>{</span>
</span></span><span><span>  <span>name</span> <span>=</span> <span>&#34;glorifiedgluercom&#34;</span><span>;</span>
</span></span><span><span>  <span>src</span> <span>=</span> <span>lib</span><span>.</span><span>cleanSource</span> <span>./.</span><span>;</span>
</span></span><span><span>
</span></span><span><span>  <span>buildInputs</span> <span>=</span> <span>[</span>
</span></span><span><span>    <span>emacs-nox</span>
</span></span><span><span>    <span>hugo</span>
</span></span><span><span>  <span>];</span>
</span></span><span><span>
</span></span><span><span>  <span>configurePhase</span> <span>=</span> <span>&#39;&#39;
</span></span></span><span><span><span>    emacs $(pwd) --batch -load export.el
</span></span></span><span><span><span>  &#39;&#39;</span><span>;</span>
</span></span><span><span>
</span></span><span><span>  <span>buildPhase</span> <span>=</span> <span>&#39;&#39;
</span></span></span><span><span><span>    hugo
</span></span></span><span><span><span>    tar -cvzf site.tar.gz -C public .
</span></span></span><span><span><span>  &#39;&#39;</span><span>;</span>
</span></span><span><span>
</span></span><span><span>  <span>installPhase</span> <span>=</span> <span>&#39;&#39;
</span></span></span><span><span><span>    mkdir -p $out
</span></span></span><span><span><span>    cp -r site.tar.gz $out
</span></span></span><span><span><span>  &#39;&#39;</span><span>;</span>
</span></span><span><span><span>};</span>
</span></span></code></pre></div><p>Running <code>nix build .#website</code> on this derivation would get you a
<code>site.tar.gz</code> file in a <code>result</code> directory. More than just declaring
the build steps, this will also ensure that all the dependencies
needed to build the website would be the same byte-by-byte.</p>
<p>What about the <em>developing experience</em>?<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup> How would I run <code>hugo serve</code> to get a feedback loop while I write and how would I publish
it? You can tell that my feedback loop is not going to happen inside
that derivation above as I have to keep running <code>nix build</code> in order
to see how things look like. Fortunately, this is easy to fix with <a href="https://nixos.org/manual/nix/stable/command-ref/new-cli/nix3-run.html">nix
run</a>.</p>
<div><pre tabindex="0"><code data-lang="nix"><span><span><span># this is using the helper function from github:numtide/flake-utils</span>
</span></span><span><span><span>apps</span><span>.</span><span>run</span> <span>=</span> <span>utils</span><span>.</span><span>lib</span><span>.</span><span>mkApp</span> <span>{</span>
</span></span><span><span>  <span>drv</span> <span>=</span> <span>pkgs</span><span>.</span><span>writeShellScriptBin</span> <span>&#34;run&#34;</span> <span>&#39;&#39;
</span></span></span><span><span><span>    </span><span>${</span><span>emacs</span><span>}</span><span>/bin/emacs $(pwd) --batch -load export.el
</span></span></span><span><span><span>    </span><span>${</span><span>hugo</span><span>}</span><span>/bin/hugo serve
</span></span></span><span><span><span>  &#39;&#39;</span><span>;</span>
</span></span><span><span><span>};</span>
</span></span></code></pre></div><p>Now I can just run the command <code>nix run .#run</code> and I‚Äôll have hugo
serving my website locally. The only missing step now is publishing it
with <code>hut</code>, the sourcehut CLI.</p>
<div><pre tabindex="0"><code data-lang="nix"><span><span><span>apps</span><span>.</span><span>publish</span> <span>=</span> <span>utils</span><span>.</span><span>lib</span><span>.</span><span>mkApp</span> <span>{</span>
</span></span><span><span>  <span>drv</span> <span>=</span> <span>pkgs</span><span>.</span><span>writeShellScriptBin</span> <span>&#34;publish&#34;</span> <span>&#39;&#39;
</span></span></span><span><span><span>    </span><span>${</span><span>hut</span><span>}</span><span>/bin/hut pages </span><span>${</span><span>website</span><span>}</span><span> site.tar.gz \
</span></span></span><span><span><span>        --domain glorifiedgluer.com \
</span></span></span><span><span><span>        --not-found 404.html
</span></span></span><span><span><span>  &#39;&#39;</span><span>;</span>
</span></span><span><span><span>};</span>
</span></span></code></pre></div><p>Running <code>nix run .#publish</code> will now publish the website to <a href="https://srht.site/">sourcehut
pages</a>. Note that I‚Äôm using the derivation we created above, this
will ensure that Nix actually built the package before publishing. How
cool is that? It‚Äôs really cool, but we are missing something here:
<strong>dependencies</strong>!</p>
<h2 id="makefile-to-the-rescue">Makefile to the rescue</h2>
<p>As previously mentioned, <code>make</code> has a concept of <em>prerequisites</em>. This
is exactly what we need to ensure all <em>dependencies</em> are met before
publishing the website.</p>
<p>Makefiles have something called <code>target</code>, it is supposed to be mapped
to a file. If not, it is called a <code>PHONY</code> target. You can understand
PHONY targets as command runners. Let‚Äôs write our Makefile to take
care of our website build steps:</p>
<div><pre tabindex="0"><code data-lang="makefile"><span><span><span>all</span><span>:</span> <span>publish</span>
</span></span><span><span>
</span></span><span><span>	content:
</span></span><span><span>	emacs <span>$(</span><span>pwd</span><span>)</span> --batch -load export.el
</span></span><span><span>
</span></span><span><span><span>public</span><span>:</span> <span>content</span>
</span></span><span><span>	hugo
</span></span><span><span>
</span></span><span><span><span>site.tar.gz</span><span>:</span> <span>public</span>
</span></span><span><span>	tar -cvzf site.tar.gz -C public .
</span></span><span><span>
</span></span><span><span><span>.PHONY</span><span>:</span> <span>publish</span>
</span></span><span><span><span>publish</span><span>:</span> <span>site</span>.<span>tar</span>.<span>gz</span>
</span></span><span><span>	hut pages publish site.tar.gz <span>\
</span></span></span><span><span><span></span>		--domain glorifiedgluer.com <span>\
</span></span></span><span><span><span></span>		--not-found 404.html
</span></span><span><span>
</span></span><span><span><span>.PHONY</span><span>:</span> <span>run</span>
</span></span><span><span><span>run</span><span>:</span> <span>content</span>
</span></span><span><span>	hugo serve
</span></span></code></pre></div><p>As you can see, we have targets such as <code>public</code> and <code>content</code> defined
in our Makefile, this means that <code>make</code> will generate the <code>public</code>
directory if it notices that something changed. Our <code>publish</code> target
is also interesting, it takes <code>site.tar.gz</code> as a prerequisite, and
<code>site.tar.gz</code> takes <code>public</code> as one too. This will ensure that every
<em>dependency</em> on our build is met before actually publishing.</p>
<h2 id="leveraging-nix-for-package-dependencies">Leveraging Nix for <em>package</em> dependencies</h2>
<p>One of the nicest things Nix provides, if not the nicest one, is the
<a href="https://nixos.org/manual/nix/stable/command-ref/new-cli/nix3-develop.html">nix develop</a> command. This can be used to give us a shell environment
with all the packages needed to build our project.</p>
<div><pre tabindex="0"><code data-lang="nix"><span><span><span>devShells</span><span>.</span><span>default</span> <span>=</span> <span>mkShell</span> <span>{</span>
</span></span><span><span>  <span>buildInputs</span> <span>=</span> <span>[</span>
</span></span><span><span>    <span>emacs</span>
</span></span><span><span>    <span>gnumake</span>
</span></span><span><span>    <span>hut</span>
</span></span><span><span>    <span>hugo</span>
</span></span><span><span>  <span>];</span>
</span></span><span><span><span>};</span>
</span></span></code></pre></div><p>If you run <code>nix develop</code>, you‚Äôll be thrown at a shell session with
these packages on <code>$PATH</code>. However, you can also run <code>nix develop -c &lt;cmd&gt;</code> to run commands without entering the shell. Do you see where we
are heading? We can run <code>nix develop -c make</code> and have all the needed
packages available for <code>make</code> to use.</p>
<div><pre tabindex="0"><code data-lang="shell"><span><span>user@host:~/glorifiedgluercom$ nix develop -c make
</span></span><span><span>rm -rf content
</span></span><span><span>rm -rf public
</span></span><span><span>rm -rf site.tar.gz
</span></span><span><span>emacs  --batch -load export.el
</span></span><span><span>...
</span></span><span><span>hugo
</span></span><span><span>...
</span></span><span><span>tar -cvzf site.tar.gz -C public .
</span></span><span><span>...
</span></span><span><span>hut pages publish site.tar.gz <span>\
</span></span></span><span><span><span></span>	--domain glorifiedgluer.com <span>\
</span></span></span><span><span><span></span>	--not-found 404.html
</span></span><span><span>
</span></span><span><span>Published site at glorifiedgluer.com
</span></span></code></pre></div><h2 id="wrapping-up">Wrapping up</h2>
<p>After some more thinking about this subject, it was clear to me that
using <code>make</code> the way it is presented here might give you the following
advantages:</p>
<ol>
<li>You have a <em>standard</em> way to build your system that Non-Nix users
can leverage</li>
<li>It‚Äôs relatively easier to reason about the build steps</li>
</ol>
<p><strong>ON THE OTHER HAND</strong>, this also gave me a really interesting idea that
got me excited to try. What are the advantages of using Nix as a
<code>make</code> <em>replacement</em>?</p>
<ol>
<li>You have a single tool to manage dependencies and <em>build steps</em></li>
</ol>
<p>In this case, <em>build steps</em> is such a broad thing on Nix that it would
add a lot more points here and I don‚Äôt think it‚Äôs fair. You get a
discoverable CLI with auto-completion (this is also true for <code>make</code>),
caching dependencies/build steps is rather straightforward and you can
share everything between your projects with Nix Flakes.</p>
<p>What about the interesting idea? Some time ago I had another idea and
wrote about my <a href="https://glorifiedgluer.com/blog/2022/starting-a-personal-monorepo/">personal monorepo</a>, this didn‚Äôt get too far<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>.
Anyway, most of the problems I faced resolved around tooling and how
weird it was to switch between multiple languages and tools. I think,
however, that it might be able possible to overcome this with the
ideas presented here. Let‚Äôs see how it goes! üòä</p>




   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   







      </div></div>
  </body>
</html>
