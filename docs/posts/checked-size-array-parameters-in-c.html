<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/SubscriberLink/1046840/3eb9029084cc9e1e/">Original</a>
    <h1>Checked-size array parameters in C</h1>
    
    <div id="readability-page-1" class="page"><p>

<h2>[LWN subscriber-only content]</h2>
</p><div>
<blockquote>
<div>
<h3>Welcome to LWN.net</h3>
<p>
The following subscription-only content has been made available to you 
by an LWN subscriber.  Thousands of subscribers depend on LWN for the 
best news from the Linux and free software communities.  If you enjoy this 
article, please consider <a href="https://lwn.net/subscribe/">subscribing to LWN</a>.  Thank you
for visiting LWN.net!
</p></div>
</blockquote>
<p>
There are many possible programmer mistakes that are not caught by the
minimal checks specified by the C language; among those is passing an array
of the wrong size to a function.  A recent attempt to add some safety
around array parameters within the crypto layer involved the use of some
clever tricks, but it turns out that clever tricks are unnecessary in this
case.  There is an obscure C feature that can cause this checking to
happen, and it is already in use in a few places within the kernel.
</p><p>
The discussion started when Ard Biesheuvel <a href="https://lwn.net/ml/all/20251114180706.318152-2-ardb+git@google.com">sought</a> to
improve the safety of the poetically  named function
<a href="https://elixir.bootlin.com/linux/v6.17.8/source/lib/crypto/chacha20poly1305.c#L112"><tt>xchacha20poly1305_encrypt()</tt></a>:
</p><pre>    void xchacha20poly1305_encrypt(u8 *dst, const u8 *src, const size_t src_len,
			           const u8 *ad, const size_t ad_len,
			       	   const u8 nonce[XCHACHA20POLY1305_NONCE_SIZE],
			       	   const u8 key[CHACHA20POLY1305_KEY_SIZE]);
</pre>
<p>
A potential problem with this function is that it takes as parameters
several pointers to arrays of type <tt>u8</tt>.  As Biesheuvel pointed out,
the size of the <tt>nonce</tt> and <tt>key</tt> arrays is not checked by
the compiler, even though it is clearly specified in the function
prototype.  That makes it easy to, for example, give the parameters in the
wrong order.  The resulting vulnerabilities are generally not the outcome
developers have in mind when they write cryptographic code.
</p><p>
Biesheuvel suggested that it was possible to write the prototype this way
instead (differences shown in bold):
</p><pre>    void xchacha20poly1305_encrypt(u8 *dst, const u8 *src, const size_t src_len,
			           const u8 *ad, const size_t ad_len,
			       	   const u8 <b>(*nonce)</b>[XCHACHA20POLY1305_NONCE_SIZE],
			       	   const u8 <b>(*key)</b>[CHACHA20POLY1305_KEY_SIZE]);
</pre>
<p>
The types of the last two arguments have changed; there is a new level of
pointer indirection, with the argument being a pointer to an array of a
given size.  Callers must change their calls by adding an additional
<tt>&amp;</tt> operator to obtain the desired pointer type, but the address
that is passed is the same.  In this case, though, the compiler will check
the sizes of the array passed, and will now catch a reordering of the
arguments to the function.
</p><p>
Jason Donenfeld <a href="https://lwn.net/ml/all/aRePu_IMV5G76kHK@zx2c4.com">was
interested</a> by the idea, but he knew of an arguably more straightforward
way to address this problem.  It seems that, buried deep within the C
standard, is a strange usage of the <tt>static</tt> keyword, making it
possible to write the prototype as:
</p><pre>    void xchacha20poly1305_encrypt(u8 *dst, const u8 *src, const size_t src_len,
			           const u8 *ad, const size_t ad_len,
			       	   const u8 nonce[<b>static</b> XCHACHA20POLY1305_NONCE_SIZE],
			       	   const u8 key[<b>static</b> CHACHA20POLY1305_KEY_SIZE]);
</pre>
<p>
This, too, will cause the compiler to check the sizes of the arrays, and it
does not require changes on the caller side.  Unlike the pointer trick,
which requires an exact match on the array size, use of <tt>static</tt>
will only generate a warning if the passed-in array is too small.  So it
will not catch all mistakes, though it is sufficient to prevent
memory-safety and swapped-argument problems.
</p><p>
Eric Biggers <a href="https://lwn.net/ml/all/20251115021430.GA2148@sol">pointed out</a>
that GCC can often generate &#34;array too small&#34; warnings even without
<tt>static</tt>, but that the kernel currently disables those warnings;
that would suppress them when <tt>static</tt> is used as well.  (The
warning was <a href="https://git.kernel.org/linus/021533194476">disabled in
6.8</a> due to false positives.)  But he thought that adding
<tt>static</tt> was worthwhile to get the warnings in Clang — if Linus
Torvalds would be willing to accept use of &#34;<q>this relatively obscure
feature of C</q>&#34;.
</p><p>
Torvalds, as it turns out, <a href="https://lwn.net/ml/all/CAHk-=wj6J5L5Y+oHc-i9BrDONpSbtt=iEemcyUm3dYnZ3pXxxg@mail.gmail.com">has
no objection</a> to this usage; he likes the feature, if not the way it was
designed:
</p><blockquote>
	The main issue with the whole &#39;static&#39; thing is just that the
	syntax is such a horrible hack, where people obviously picked an
	existing keyword that made absolutely no sense, but was also
	guaranteed to have no backwards compatibility issues.
</blockquote>
<p>
He pointed out that there are a number of places in the kernel that are
already using it; for a simple example, see <a href="https://elixir.bootlin.com/linux/v6.17.8/source/drivers/tty/vt/vt.c#L4981"><tt>getconsxy()</tt></a>
in the virtual-terminal driver.  He suggested perhaps hiding it with a
macro like <tt>min_array_size()</tt> just to make the usage more obvious,
but didn&#39;t seem convinced that it was necessary. Donenfeld <a href="https://lwn.net/ml/all/20251118170240.689299-1-Jason@zx2c4.com">followed up</a> with
a patch to that effect a few days later, but then pivoted to <a href="https://lwn.net/ml/all/20251122025510.1625066-4-Jason@zx2c4.com/">an
<tt>at_least</tt> marker</a> instead.
</p><p>
A lot of work has gone into the kernel to make its use of C as safe as
possible, but that does not mean that the low-hanging fruit has all been
picked.  The language has features, such as <tt>static</tt> when used to
define formal array parameters, that can improve safety, but which are not
generally known and not often used.  In this particular case, though, it
would not be surprising to see this &#34;<q>horrible hack</q>&#34; come into wider
use in the near future.<br clear="all"/></p><table>
           <tbody><tr><th colspan="2">Index entries for this article</th></tr>
           <tr><td><a href="https://lwn.net/Kernel/Index">Kernel</a></td><td><a href="https://lwn.net/Kernel/Index#C_language_safety">C language safety</a></td></tr>
            <tr><td><a href="https://lwn.net/Kernel/Index">Kernel</a></td><td><a href="https://lwn.net/Kernel/Index#Releases-6.19">Releases/6.19</a></td></tr>
            </tbody></table></div></div>
  </body>
</html>
