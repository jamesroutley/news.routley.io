<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://retrofun.pl/2024/01/03/70s-and-80s-forget-basic-we-had-pascal-and-c/">Original</a>
    <h1>Late 70s and 80s: forget BASIC, we had Pascal and C</h1>
    
    <div id="readability-page-1" class="page"><div>

			
<p><strong>Update 2024-04-01</strong>: I‚Äôve just learned, day after publishing this, that Niklaus Wirth, the creator of Pascal, has died on January 1st üôÅ </p>



<p>Since the post about the <a href="https://retrofun.pl/2023/12/18/was-basic-that-horrible-or-better/" data-type="post" data-id="417">state of BASIC as compared to popular languages at the time when Dijkstra made his hateful quote</a> became the most popular post of this site (note to self: hate sells well, at least for 50 years), it‚Äôs time to pick up some loose threads that have been deliberately left as such. What were the other options? How good were they? Do we still have them? <small>(<a href="https://www.youtube.com/watch?v=e1g_wNPmOsg" target="_blank" rel="noreferrer noopener">What do they know? Let‚Äôs find out</a>)</small></p>



<p><strong>Disclaimer: </strong>I am describing the beginnings of these languages and their first versions ‚Äî these things have been released and popular a few years before I was born. Please suggest edits if you see something incorrect!</p>



<p>I‚Äôve covered the big ones (back then) that never died: PL/I, COBOL, Fortran and, of course, BASIC. But following up on the promise:</p>







<p>To recap the BASIC pros and cons post:</p>



<div><div>
<ul>
<li>BASIC, looking purely at the language, not as much as the <a href="https://retrofun.pl/2021/05/18/hobbyarding/" data-type="post" data-id="49">enthusing environment it came in</a>, had some disadvantages:
<ul>
<li>No code structure (except being able to jump to a line of code with <code>GOSUB</code> and <code>RETURN</code> from there) ‚Äì no functions, procedures, all variables were global.</li>



<li>In the 70s, it didn‚Äôt even have <code>IF ... THEN ... END IF</code> ‚Äì you had to <code>GOTO</code> a line if the condition was met, like in assembly language.</li>



<li>When it was famously criticized, it didn‚Äôt support any user input, and had no graphics and sound support ‚Äì because there was no monitor and no speaker.</li>



<li>Once it gained this support, it wasn‚Äôt standarized, not all computers had equal access to their own capabilities from BASIC (sorry, C64, no <code>PLOT</code>ting a point or drawing a <code>LINE</code> for you), many other keywords and their behavior differed as well.</li>



<li>When Dijkstra made the infamous comment, it was Darmouth BASIC and it was a compiled language (not as we know it from the home computers such as C64). But so was PL/I with all the procedures, local variables, and structures support.</li>
</ul>
</li>



<li>But it also had its advantages:
<ul>
<li>It was simple enough for all beginners, to help create all purpose programs (BASIC stands for Beginners All Purpose Symbolic Instruction Code). Just a few control keywords to learn, and you‚Äôre ready, you‚Äôve mastered the language itself.</li>



<li>Once home computers appeared in the 80s, it have a lot of access to the capabilities of the computer ‚Äì disk, tape, graphics, sound, direct memory access, and direct hardware access (ok, I didn‚Äôt go into these features that deep, yet)!</li>



<li><strong>Thanks to its simplicity</strong>, it taught the users how the computer worked internally. Other languages hide the internals of how CPU and memory interact under many more levels of abstraction, but if you don‚Äôt have this abstraction, you discover and learn it yourself. <code>GOTO</code> and <code>GOSUB</code> statements are in fact same kind of jumps as the computer processor does internally. If your variables don‚Äôt have any structure in memory, you have to figure out how to manage them together.</li>
</ul>
</li>
</ul>
</div></div>







<p>The title mentions Pascal ‚Äì because the language was created by Niklaus Wirth ‚Äúaround 1970‚Äù, so it could have been something to compare to. However, to be historically correct, it wasn‚Äôt exactly built from scratch either. Pascal was losely based on Algol 60, that existed since the 60s. Algol 60 may look a little familiar, even if the name isn‚Äôt (sample src: <a href="https://en.wikipedia.org/wiki/ALGOL_60" target="_blank" rel="noreferrer noopener">wikipedia</a>):</p>



<pre><code lang="pascal">procedure Absmax(a) Size:(n, m) Result:(y) Subscripts:(i, k);
    value n, m; array a; integer n, m, i, k; real y;
comment The absolute greatest element of the matrix a, of size n by m,
    is copied to y, and the subscripts of this element to i and k;
begin
    integer p, q;
    y := 0; i := k := 1;
    for p := 1 step 1 until n do
        for q := 1 step 1 until m do
            if abs(a[p, q]) &gt; y then
                begin y := abs(a[p, q]);
                    i := p; k := q
                end
end Absmax</code></pre>


<div>
<figure><img decoding="async" width="768" height="1024" src="https://i0.wp.com/retrofun.pl/wp-content/uploads/sites/2/2023/12/Pdp-11-40.jpg?resize=768%2C1024&amp;ssl=1" alt="PDP-11 minicomputer" srcset="https://i0.wp.com/retrofun.pl/wp-content/uploads/sites/2/2023/12/Pdp-11-40.jpg?resize=768%2C1024&amp;ssl=1 768w, https://i0.wp.com/retrofun.pl/wp-content/uploads/sites/2/2023/12/Pdp-11-40.jpg?resize=225%2C300&amp;ssl=1 225w, https://i0.wp.com/retrofun.pl/wp-content/uploads/sites/2/2023/12/Pdp-11-40.jpg?resize=1152%2C1536&amp;ssl=1 1152w, https://i0.wp.com/retrofun.pl/wp-content/uploads/sites/2/2023/12/Pdp-11-40.jpg?w=1536&amp;ssl=1 1536w" sizes="(max-width: 768px) 100vw, 768px" data-recalc-dims="1"/></figure></div>


<p>In the 70s, Pascal was getting popular in the ‚Äúminicomputer‚Äù market. If you remember that a computer was a huge remote mainframe, you can guess that a mini computer is one that is smaller than a room, maybe at most 2 meters tall and a meter wide. And has reel-to-reel tape recorders built in.  </p>



<p>Beginning in the 80s, and certainly throughout the 2000s as well, Pascal could be found at Universities. ‚ÄúSo was BASIC‚Äù, you might remember from the previous article. But Pascal could serve a deeper purpose, than BASIC ‚Äì instead of learning how to <em>code</em>, you could now learn how to design <em>algorithms and data structures</em>. This is a course on many Computer Science majors, but it‚Äôs also a book by Niklaus Wirth (Pascal‚Äôs creator) from 1985. </p>



<p>Let‚Äôs mention Edsger Dijkstra for the last time. In 1960 he published a paper called  ‚Äú<a href="https://ics.uci.edu/~jajones/INF102-S18/readings/07_dijkstra.pdf" target="_blank" rel="noreferrer noopener">Recursive programming</a>‚Äú, defining what we have been referring to as ‚Äúa stack‚Äù (like in ‚Äúcall stack‚Äù, but also ‚Äústack vs heap‚Äù ‚Äì two main ways of storing variables in computer programs this day) for the next 64 years. As noted in the introduction of Algorithms and Data Structures, Dijkstra was also the author of the publication titled ‚Äú<a href="https://www.cs.utexas.edu/users/EWD/ewd02xx/EWD249.PDF" target="_blank" rel="noreferrer noopener">Notes on structured programming</a>‚Äù (1970),  that shaped structured programming for decades, if not literal ages. . In this paper, Dijkstra presents foundational concepts and principles for writing clear, reliable, and efficient computer programs using structured programming techniques. The ideas put forth in this paper have had a lasting impact on the development of programming methodologies and have contributed to the establishment of best practices in software design and development.</p>



<p>Structured programming is a programming paradigm aimed at improving the clarity, quality, and development time of a computer program by making extensive use of subroutines, block structures, for and while loops, and other control structures. It promotes the idea of breaking down a program into small, manageable sections, making it easier to understand and maintain.</p>



<p>This gives us background on how Pascal was born, taught, and how it helped spreading the good practice of introducing proper level of abstractions in the code, as well as in the data. In <em>Algorithms and data structures</em>, we may find descriptions of most common problems to solve in any computer program, illustrated with samples of code in Pascal:</p>



<figure><img decoding="async" width="940" height="360" src="https://i0.wp.com/retrofun.pl/wp-content/uploads/sites/2/2023/12/obraz.png?resize=940%2C360&amp;ssl=1" alt="MergeSort example, written in Pascal, or perhaps Modula-2, from &#34;Algorithms and Data Structures&#34;, N.Wirth, 1985" srcset="https://i0.wp.com/retrofun.pl/wp-content/uploads/sites/2/2023/12/obraz.png?resize=1024%2C392&amp;ssl=1 1024w, https://i0.wp.com/retrofun.pl/wp-content/uploads/sites/2/2023/12/obraz.png?resize=300%2C115&amp;ssl=1 300w, https://i0.wp.com/retrofun.pl/wp-content/uploads/sites/2/2023/12/obraz.png?resize=768%2C294&amp;ssl=1 768w, https://i0.wp.com/retrofun.pl/wp-content/uploads/sites/2/2023/12/obraz.png?w=1124&amp;ssl=1 1124w" sizes="(max-width: 940px) 100vw, 940px" data-recalc-dims="1"/></figure>



<p>The above example from the book describes MergeSort sorting algorithm, in academically concise, probably not the most reader-friendly format. Trust me, using fixed-width font for computer code was not a thing yet, especially in serious publications, and syntax highlighting is a whimsical idea of the PC era.</p>



<h2>Why did it make a difference?</h2>



<p>The widespread popularity of Pascal had some advantages that are definitely worth noting here. It was designed to make code more comprehensible ‚Äì both for the human, and the computer. </p>



<p>The human could benefit from encapsulating more complex logic into procedures or functions (in this distinction a function is a procedure that returns a value) that you can call from other places in the code, like we do in all modern programming languages ‚Äì like <code>padWithZeroes(&#39;123&#39;)</code>. The code could be organized and formatted in a more human comprehensible way, with the core idea being nested blocks, that were nested both logically and visually (oh the memory-costly whitespace!).</p>



<p>The language encouraged defining your own types and subtypes for everything ‚Äì which is a very good practice. For example (with uppercase still being the most common spelling for things quite often, but Pascal was not case sensitive):</p>



<pre><code lang="typescript">TYPE
  COLOR = (RED, YELLOW, BLUE, GREEN, ORANGE);
  SCORE = (LOST, TIED, WON);
  SKILL = (BEGINNER, NOVICE, ADVANCED, EXPERT, WIZARD);
  PRIMARY = RED .. BLUE;
  NUMERAL = &#39;0&#39; .. &#39;9&#39;;
  INDEX = 1 .. 100;</code></pre>



<p>In this instance, when we create a subtype, such as for a <code>NUMERAL</code>, it clarifies for both the code reader and the compiler that only specific values are permissible. Similarly, the <code>COLOR</code> type would be an enumeration, as commonly defined with the <code>enum</code> keyword in many modern languages, specifying the range of potential literal values. This approach not only informs <em>programmers</em> about what to anticipate when reading the code, but also enables <em>the compiler </em>to prohibit misuse and the assignment of inappropriate values, or operations that are nonsensical for the given type. As a bonus, the compiler knowing the range of values could decide to allocate less memory for them.</p>



<p>Being a compiled language obviously also meant that software written in it would of course executed faster than written in an interpreted language ‚Äì as by the time of execution, it‚Äôs already all machine code ready to run, without the extra step. For commercial software it also meant it‚Äôs hard to examine how it works internally, and hard to modify it ‚Äì features that commercial software authors would usually desire.</p>



<p>Before we proceed to the last benefit: let‚Äôs state a difference between two similar ideas in code: function <strong>declaration </strong>vs <strong>definition</strong>.</p>



<p>The language is designed to enable fast compilation, even on small machines, and to be completed in a single pass by reading the entire source file just once. This introduced the requirement for all variables to be <em>declared</em> before <em>use</em> within each block, and for every procedure to be declared before it is called, which may be seen as inconvenient and outdated in modern programming practices. However, it was implemented to simplify and speed up compilation, reduce memory usage, and encourage programmers to organize their code more systematically. </p>



<p>The biggest advantage of Pascal being both <em>taught</em>, and <em>popular</em> in any kind of programming, was that there has been ‚Äì and still is ‚Äì a lot of resources to read about it from, and a lot of examples, and reference code. </p>



<h2>I like being practical, where could I *use* Pascal?</h2>



<p>I‚Äôm glad you ask! Let‚Äôs assume we‚Äôre in the 80s for now. The answer is <strong>everywhere</strong>. Even though the UCSD Pascal variant created by Unversity of California in San Diego is fading after some time of being <strong>the</strong> Pascal implementation (created in 1977, latest release in 1984), most computers had a version of Pascal of some sort. Amstrad CPC464 and ZX Spectrum had HiSoft Pascal, Atari had Kyan Pascal, Commodore had Pascal-64, Macintosh users remember Lightspeed Pascal. </p>



<p>Thanks to the popularity of the CP/M system that could be shared by almost anything that was built with the Z80 CPU, any computer that could run it (Amstrad CPC, Spectrum +3, C128, Apple II with a Z80 card, MSX, IBM, Sam Coupe, TRS-80, and many others), could also run the most popular version of this language ‚Äì <strong>Turbo Pascal</strong> by Borland (most known from the later editions for the IBM PC compatibles).</p>



<figure><video autoplay="" controls="" loop="" muted="" src="https://retrofun.pl/wp-content/uploads/sites/2/2023/12/Sequence-01.mp4" playsinline=""></video></figure>



<p>Above, we see a screen capture of Turbo Pascal 3.0 running under CP/M operating system on Amstrad CPC6128 ‚Äì a machine with 4MHz (<a href="https://en.wikipedia.org/wiki/Amstrad_CPC#Processor" target="_blank" rel="noreferrer noopener">effectively ‚Äúaround 3.3 Mhz‚Äù</a>) Z80 CPU and 128 KiB of RAM. 128KiB of RAM is enough here to hold the operating system, the compiler and editor, the source code, and the program being compiled, as well as the contents of the entire screen. You may notice that each byte of code produced is counted meticulously, and we stil had over 28KiB of free memory.</p>



<p>This particular Pascal compiler got so popular, many people confuse it with the name of the language (for the last <a href="https://blog.marcocantu.com/blog/2023-november-turbopascal40.html" data-type="link" data-id="https://blog.marcocantu.com/blog/2023-november-turbopascal40.html" target="_blank" rel="noreferrer noopener">40 years</a>). The tool, and the language, heve been evolving together, along with the hardware it could run on. While there isn‚Äôt a newer version for CP/M than 3.0, some later versions brough significant improvements:</p>



<ul>
<li>v4.0 introduced units, making it much easier to create even more modular code, where each unit could be compiled separately. It also introduced the full-screen editor it was loved for; it was one of the first IDE (Integrated Development Environments) to ever exist, where one full-screen interface allowed editing the code, compiling and debugging it. In v5.0 it became colorful with a familiar mix of blue, white and yellow:</li>



<li>v5.5 introduced <em>object oriented programming</em> ‚Äì from now on, one could use <strong>classes</strong>, the main way to encapsulate our business logic since 1989, that only JavaScript and Golang refuse to accept ;-). </li>



<li>Turbo Pascal 7.0 introduced <strong>syntax highlighting</strong> in 1992. It was also the last text-based version of the interface, succeeded by Turbo Pascal for Windows, and later by Delphi. </li>
</ul>





<ul>
<li>Macintosh users enjoyed their Turbo Pascal for Macintosh 6 years earlier, in 1986! Winworld <a href="https://winworldpc.com/product/turbo-pascal/1x-mac" data-type="link" data-id="https://winworldpc.com/product/turbo-pascal/1x-mac">notes</a> about it: ‚ÄúTurbo Pascal for Macintosh was a short lived port of Borland‚Äôs Pascal product to the Apple Macintosh. It featured a more advanced compiler than the DOS version at the time.</li>
</ul>





<p>While it‚Äôs technically not Turbo Pascal anymore, and wasn‚Äôt released until 1995, it‚Äôs still Pascal ‚Äì so I definitely should mention Delphi. It was a huge evolution from just writing Pascal for DOS or Windows (which required knowing how Windows actually works, how the windows and buttons are rendered, and how to communicate with the operating system properly), allowing very easy application development ‚Äì requiring just to drop a button onto a window, and double-click it to write the code to execute when it‚Äôs clicked. To be honest, it‚Äôs often not even that easy today.</p>



<figure>
<figure><a href="https://i0.wp.com/retrofun.pl/wp-content/uploads/sites/2/2023/12/obraz-6.png?ssl=1"><img loading="lazy" decoding="async" width="300" height="225" data-id="562" src="https://i0.wp.com/retrofun.pl/wp-content/uploads/sites/2/2023/12/obraz-6.png?resize=300%2C225&amp;ssl=1" alt="Delphi 1.0 under Windows 3.x" srcset="https://i0.wp.com/retrofun.pl/wp-content/uploads/sites/2/2023/12/obraz-6.png?resize=300%2C225&amp;ssl=1 300w, https://i0.wp.com/retrofun.pl/wp-content/uploads/sites/2/2023/12/obraz-6.png?w=640&amp;ssl=1 640w" sizes="(max-width: 300px) 100vw, 300px" data-recalc-dims="1"/></a></figure>



<figure><a href="https://i0.wp.com/retrofun.pl/wp-content/uploads/sites/2/2023/12/obraz-5.png?ssl=1"><img loading="lazy" decoding="async" width="300" height="225" data-id="559" src="https://i0.wp.com/retrofun.pl/wp-content/uploads/sites/2/2023/12/obraz-5.png?resize=300%2C225&amp;ssl=1" alt="Delphi 2.0 under Windows 95" srcset="https://i0.wp.com/retrofun.pl/wp-content/uploads/sites/2/2023/12/obraz-5.png?resize=300%2C225&amp;ssl=1 300w, https://i0.wp.com/retrofun.pl/wp-content/uploads/sites/2/2023/12/obraz-5.png?resize=768%2C576&amp;ssl=1 768w, https://i0.wp.com/retrofun.pl/wp-content/uploads/sites/2/2023/12/obraz-5.png?w=800&amp;ssl=1 800w" sizes="(max-width: 300px) 100vw, 300px" data-recalc-dims="1"/></a></figure>



<figure><a href="https://i0.wp.com/retrofun.pl/wp-content/uploads/sites/2/2023/12/obraz-7.png?ssl=1"><img loading="lazy" decoding="async" width="300" height="225" data-id="563" src="https://i0.wp.com/retrofun.pl/wp-content/uploads/sites/2/2023/12/obraz-7.png?resize=300%2C225&amp;ssl=1" alt="" srcset="https://i0.wp.com/retrofun.pl/wp-content/uploads/sites/2/2023/12/obraz-7.png?resize=300%2C225&amp;ssl=1 300w, https://i0.wp.com/retrofun.pl/wp-content/uploads/sites/2/2023/12/obraz-7.png?w=640&amp;ssl=1 640w" sizes="(max-width: 300px) 100vw, 300px" data-recalc-dims="1"/></a></figure>
</figure>











<p>Except C, the language, does not support classes (reminder: C and C++ are not the same language). The name actually suggests an evolution from the <a href="https://www.bell-labs.com/usr/dmr/www/bintro.html" data-type="link" data-id="https://www.bell-labs.com/usr/dmr/www/bintro.html" target="_blank" rel="noreferrer noopener">language B</a> created at Bell Labs in 1969. </p>



<p>But the language <strong>did exist</strong> in the 70s (kinda) and 80s! It was in development (first book documenting it to be published in 1978, and referring to Fortran and Pascal a lot), and was not yet a valid alternative to BASIC when <a href="https://retrofun.pl/2023/12/18/was-basic-that-horrible-or-better/" data-type="post" data-id="417">the famous computer scientist was scolding BASIC, COBOL, Fortran and APL</a>. Maybe that‚Äôs why he didn‚Äôt criticize it. </p>



<p>The original design of C and Pascal had different goals in mind. C was initially developed <a href="https://retrofun.pl/2023/05/09/some-art-and-history-for-you/" data-type="post" data-id="343">to implement the Unix operating system</a>, with a focus on providing low-level access to memory and system resources, making it well-suited for system programming and developing operating systems. On the other hand, Pascal was designed as a language for teaching programming and software engineering principles, with a strong emphasis on readability, structured programming, and data structuring.</p>



<p>This difference is reflected in what both languages ‚Äúfeel like‚Äù and what they put emphasis on. Typically, C is ‚Äúcloser to metal‚Äù ‚Äì for example there is no distinction between the <code>char</code> type that represents a single character, and a <code>short int</code>. C is perfectly happy with expressions such as <code>int x = &#39;b&#39;-1</code> or <code>char c = 64</code>. This is in line with what the CPU would do ‚Äì a character was typically a single byte number, often in a single-byte register if operated upon, and it doesn‚Äôt matter to the computer, what it represents. Pascal aims for abstracting different meanings into different types, so even though for the processor wouldn‚Äôt need to know if it‚Äôs an <code>&#39;a&#39;</code> or the number <code>97</code>, the programmer should explicitly and unambiguisly use <code>ord(&#39;a&#39;)</code> to convert the letter to the ASCII code, or <code>chr(97)</code> to convert it back. </p>



<p>Similarly, we know that computers operate on <code>0</code>s and <code>1</code>s, so-called binary values (<em><strong>bi</strong>nary<strong> </strong></em>because there‚Äôs just two), representing <code>true</code> and <code>false</code> of some information. Naturally, Pascal therefore defines <code>true</code> and <code>false</code> as the two enum values for a <code>boolean</code> type, while C‚Ä¶ decides there‚Äôs no <code>bool</code> type, and all that exists is <code>1</code> and <code>0</code>. This is true even for values of operations such as comparison <code>a == b</code> ‚Äì technically it either returns <code>1</code> or <code>0</code> in C, but not true or false. This too feels close to metal.</p>



<p>At the time, it was a common convention in assembly to pass the return value in the <code>A</code> (for 8-bit, later <code>AX</code> for 16-bit, and <code>EAX</code> for 32-bit) register of the processor. </p>



<p>Let‚Äôs have a look on some very basic examples (no data structures):</p>



<pre><code lang="c">/* 1978 C example for checking palindrome */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

isPalindrome(char *str) {
    int len;
    int i, j;
    len = strlen(str);
    for (i = 0, j = len - 1; i &lt; j; i++, j--) {
        if (str[i] != str[j]) {
            return 0;  /* Not a palindrome */
        }
    }
    return 1;  /* Palindrome */
}

main() {
    char testStr[];
    testStr = &#34;radar&#34;;
    if (isPalindrome(testStr)) {
        printf(&#34;%s is a palindrome\n&#34;, testStr);
    } else {
        printf(&#34;%s is not a palindrome\n&#34;, testStr);
    }
    return 0;
}</code></pre>



<p>while in Pascal we‚Äôd have:</p>



<pre><code lang="matlab">
(* Pascal example for checking palindrome *)
program PalindromeCheck;

function IsPalindrome(str: string): Boolean;
var
    i, j: Integer;
begin
    j := Length(str);
    for i := 1 to j div 2 do
    begin
        if str[i] &lt;&gt; str[j - i + 1] then
        begin
            IsPalindrome := False;  { Not a palindrome }
            Exit;
        end;
    end;
    IsPalindrome := True;  { Palindrome }
end;

var
    testStr: string;
begin
    testStr := &#39;radar&#39;;
    if IsPalindrome(testStr) then
        writeln(testStr, &#39; is a palindrome&#39;)
    else
        writeln(testStr, &#39; is not a palindrome&#39;);
end.</code></pre>



<p>You can notice that C doesn‚Äôt bother using too many data types ‚Äì while Pascal has <code>string</code> type, C uses a pointer to a character. The assumption is that subsequent characters follow right after this pointer, and the string ends where a <code>00</code> byte is found (so-called null-terminated string). The example also shows that <code>char *</code> is basically the same as an array of characters ‚Äì the test string is declared as such. We also return an integer instead of a boolean. </p>



<p>In Pascal, functions have this interesting convention that didn‚Äôt catch on in many languages, that you can assign the result value to the function name. So once we do <code>IsPalindrome := False;</code>, it will be the result of the <code>IsPalindrome</code> call, unless updated later before exiting the function.</p>



<p>While both languages at the time separated variable declarations and usage, C had this nice feature of being able to initialize the variable with a value in its declaration (<code>int l = strlen(s)</code>. The original Pascal language did not support that (but for example todays Free Pascal does). C‚Äôs stdio package also provided the extremely useful <code>printf</code> function where <code>f</code> stands for ‚Äúformat‚Äù ‚Äì you can declare the entire message first, and the arguments to be inserted into it later. It makes a lot of string formatting much easier to read.</p>



<p>It‚Äôs also important to note that C started mostly on 16-bit machines, which existed in the 80s, but weren‚Äôt the ones you would find at home. So the regular home computer user, even if they wanted to get into compiled languages, would probably not see it as a popular option. </p>



<h2>C is for Change</h2>



<p>Today, if you say ‚Äúit‚Äôs written in C‚Äù, it‚Äôs not the same language that Ritchie and Kernighan would use. To be frank, what their standard suggested is often not allowed by the compilers used today. </p>



<p>Like many languages, C has been standarized, as well as it evolved. The first major change came with the ANSI C standard (<code>C89</code>), which was completed in 1989 and ratified as ANSI X3.159-1989. This version of the language is often referred to as ‚ÄúANSI C‚Äù, or C89, and brought about substantial changes to the language, such as introduction of new features like <code>volatile</code>, <code>enum</code>, <code>signed</code>, <code>void</code>, and‚Ä¶ <code>const</code>. </p>



<p>Subsequent standards, including C99 and C11, introduced additional features and modifications to the language, further expanding its capabilities and refining its syntax and semantics. </p>







<p>Most other C features aim more at making it easy to <em>write</em> ‚Äì a lot of shortcuts, abbreviations, shorter and less verbose operators (like <code>i++</code> instead of <code>i = i+1</code>), mixing types that are represented identically internally by the CPU.</p>



<p>Pascal went the other way, trying to make sure the code is easy to <em>read</em> without having to analyze it much. The structure of the code was clearly visible, types were encouraged to be defined as closely to their meaning as possible.</p>



<p>Seems like after 8 years of having Pascal, a need to type code <em>faster</em> emerged ;). For further reference, there‚Äôs an entire <a href="https://en.wikipedia.org/wiki/Comparison_of_Pascal_and_C" data-type="link" data-id="https://en.wikipedia.org/wiki/Comparison_of_Pascal_and_C" target="_blank" rel="noreferrer noopener">Wikipedia entry comparing the two languages </a>under many more aspects.</p>



<p>While these languages make writing more organized programs easier, the <strong>most efficient</strong> ones for the 8-bits were, and often still are, written directly in assembly. User <code>retrac</code> in <a href="https://news.ycombinator.com/item?id=38866899">one of the comments</a> has some nice insight on this: </p>



<blockquote>
<p>Languages like C and Pascal really demand that you have a nice, cheap stack. Classically, a function call means pushing all the parameters to the stack, and then the return address, and then jumping to the function, then pulling all the parameters off the stack, and pushing the return value on the stack, then modifying the stack pointer to drop the parameters, and then reading the return address off the stack.</p>



<p>Neither the Z80 or 6502, have instructions that provide an efficient stack, which works with multi-byte data. You end up constantly manipulating the stack pointer (usually for a software-implemented stack) with slow 8-bits-at-a-time arithmetic. Painful.</p>



<p>The PDP-11‚Äôs instruction set in comparison, provides not just one, but up to seven, flexible 16-bit stacks.</p>
</blockquote>







<p>Another language not mentioned in the ‚ÄúWas BASIC that horrible‚Ä¶‚Äù post that actually had huge significance in that era of computing is Forth. </p>



<pre><code lang="adoc">: isPalindrome ( addr -- flag )
  dup &gt;r                      \ Duplicate the address and move one copy to the return stack
  bounds ?do                  \ Iterate over the string
    i c@ r@ -                 \ Calculate the address of the corresponding character from the end
    dup i c@ &lt;&gt; if            \ Compare the characters
      drop r&gt; drop false exit \ Not a palindrome, cleanup and return false
    then
  loop
  drop r&gt; drop true           \ Palindrome, cleanup and return true
;
</code></pre>



<p>As you can see, it‚Äôs <strong>very</strong> different from all the languages discussed in this and previous post. I‚Äôm not a Forth expert. But I can pinpoint the main differences and mention, why it made sense to use it. I‚Äôll also share some further reading links for the curious. </p>



<p>First and foremost, in contrast to Pascal‚Äôs structured approach and C‚Äôs procedural paradigm, Forth offers a different programming model based on a stack-oriented execution and a minimalistic syntax. This means that arguments for each operation were pushed on the stack (same stack as we take the <code>RETURN</code> address from, described in the Recursive Programming document). The operation itself is then the last part of the command. A simple operation such as: </p>



<p>Via ‚Äú<a href="http://www.forth.org/lost-at-c.html?locale=en" data-type="link" data-id="http://www.forth.org/lost-at-c.html?locale=en">Lost at C? Forth may be the answer</a>‚Äú:</p>



<p>This means that Forth is <strong>extremely</strong> memory and CPU efficient to execute ‚Äì and let‚Äôs remember that CPUs were slower and memory was very expensive back then. This lets us find a sentence in the document quoted above that points out something we would take for granted today:</p>



<blockquote>
<p>It‚Äôs often possible to develop a Forth program on the target system itself. </p>
<cite>http://www.forth.org/lost-at-c.html?locale=en</cite></blockquote>



<p>It wasn‚Äôt always that easy to develop a program and run it <strong>on the same machine</strong>. This was not only due to the inconveniences mentioned earlier (such as switching between editor, compiler, and the created program), but also because of technical limitations. Compiling software requires loading a significantly larger amount of data into memory than the resulting program will contain. This is due to reasons as simple as the source code being larger in bytes than the compiled program (what is one line of code for a human can be three bytes for the target machine). Additionally, in order to resolve all references (such as variable names, function names, and types), they all need to fit in memory and be searchable in a reasonable amount of time.</p>



<p>For the same reason, if you want to target a CP/M system, an Amstrad, an Apple II, a Commodore 64, or a ZX Spectrum (and so on‚Ä¶) today, you would most likely try <a href="https://retrofun.pl/2023/02/19/writing-for-cpc6128-in-year-2023/" data-type="post" data-id="320">cross-compilation</a> (most likely with C though) ‚Äì write the code on a more powerful and resourceful PC, and only run it on the target platform.</p>



<p>Last but not least, going back to the language ‚Äì Forth also allows defining own keywords, and this extensibility allows developers to <a href="http://tangentstorm.github.io/winfield-pascal-83.html" data-type="link" data-id="http://tangentstorm.github.io/winfield-pascal-83.html">create</a> other, usually domain-specific languages and tailor the language to specific applications. </p>



<p>Is it still in use? Yes!</p>



<blockquote>
<p>Forth is still in use by IBM, Apple and Sun. It is used for device drivers, especially used during booting of OS. FORTH is very useful on microcontrollers, as it uses very little memory, can be fast, and easier to code than in assembly, even interactively.</p>
<cite>https://stackoverflow.com/questions/2147952/is-forth-still-in-use-if-so-how-and-where</cite></blockquote>







<p>The most common question to answer here would be ‚Äú(why) are C and Pascal not used today?‚Äù. </p>



<p>Based on recent discussions and developments, it seems that there is a growing trend to consider <a href="https://www.theregister.com/2022/09/28/is_it_time_to_retire_c/?locale=en" data-type="link" data-id="https://www.theregister.com/2022/09/28/is_it_time_to_retire_c/?locale=en">replacing <strong>C</strong> and C++ with Rust</a> in certain domains. Rust is being praised for its focus on performance and safety, which are areas where the C family has historically prioritized <em>speed over security</em>. Some sources suggest that Rust is gaining traction and could potentially replace C++ in certain applications, but it‚Äôs important to note that <strong>C (no ++) still actively used</strong> in many areas, especially in ‚Äúclose to the metal‚Äù development where fine control over operations and memory management is crucial.</p>



<p>While it may not be as prevalent in modern software development compared to languages like Python, Java, or C++, <strong>Pascal</strong>‚Äòs was significant and is still in use in certain area, so it has not completely disappeared from the programming landscape. However it‚Äôs not adapting </p>



<p>The language <strong>Object Pascal</strong> has been renamed to Delphi ‚Äì Delphi remains an expensive commercial Rapid Application Development tool. It supports writing code for both PCs and mobile devices, as well as multi-device (Windows, macOS, Linux, iOS and Android) applications with their <a href="https://docwiki.embarcadero.com/RADStudio/Alexandria/en/Developing_Multi-Device_Applications" data-type="link" data-id="https://docwiki.embarcadero.com/RADStudio/Alexandria/en/Developing_Multi-Device_Applications">FireMonkey</a> engine.</p>



<figure><blockquote><p>In my opinion, this is one of the greatest harms that happened to the language ‚Äì it became too associated with a single company.</p></blockquote></figure>



<p>In my opinion, this is one of the greatest harms that happened to the language ‚Äì it became too associated with a single company, with propriertary IDE and blocking price tag, that it killed its popularity. </p>



<p>Castle Game Engine is written in Pascal and actively developed ‚Äì <a href="https://castle-engine.io/" target="_blank" rel="noreferrer noopener">https://castle-engine.io/</a> </p>



<p><a href="https://www.lazarus-ide.org/" data-type="link" data-id="https://www.lazarus-ide.org/">Lazarus</a> is the free Delphi-like IDE for Free Pascal. Last release was a week ago.</p>



<p><a href="https://github.com/tebe6502/Mad-Pascal" data-type="link" data-id="https://github.com/tebe6502/Mad-Pascal" target="_blank" rel="noreferrer noopener">MAD Pascal</a> is a cross-compiler ‚Äì a 32-bit compiler for a PC to target Atari XL/XE.</p>



<h2>ADA</h2>





<p>Pascal spawned one more language! Named after the first programmer ever, countess Ada Lovelace, the Ada language is not as known as it should be, but it sure is a solid modernized descendant of Pascal, for different use-cases.</p>



<p>Ada, created in the late 1970s, with first implementation published in 1983, is defined as ‚Äúextremely strong typed‚Äù and ‚Äúsupporting <em><a href="https://en.wikipedia.org/wiki/Design_by_contract">design by contract</a></em> (DbC)‚Äù, but I would also argue that calling it ‚Äúparanoid‚Äù is fair. If a program in Ada compiles at all, it probably already handles all edge cases.</p>



<p>Some Ada features are very remarkable today ‚Äì explicit concurrency, tasks, synchronous message passing, protected objects, and non-determinism.</p>



<blockquote>
<p>The Ada programming language was initially designed following a contract from the United States Department of Defense (DoD) from 1977 to 1983 to supersede over 450 programming languages used by the DoD at that time. Over the past 30 years it has become a de facto standard for developers of high-integrity, military applications. It is designed specifically for large, long-lived applications where reliability, efficiency, safety and security are vital.</p>
<cite>https://www.adacore.com/industries/defense</cite></blockquote>



<p>While the language is your best friend if you want to code software for your nuclear reactor (<a href="http://archive.adaic.com/projects/atwork/nuclear.html" data-type="link" data-id="http://archive.adaic.com/projects/atwork/nuclear.html">example in Czechia</a>, the document ‚Äú<a href="https://www-pub.iaea.org/MTCD/Publications/PDF/TRS384_scr.pdf" data-type="link" data-id="https://www-pub.iaea.org/MTCD/Publications/PDF/TRS384_scr.pdf">Verification and Validation of Software</a>‚Äù also mentions ‚ÄúUse of modern real time languages such as ADA and OCCAM.‚Äù as the best starting point to define such verification and validation formalized description) or your military systems (quote above) it never got as much popularity as many others. </p>



<p>The language, as usual, is not dead. The last spec in from 2022. </p>



<figure><blockquote><p>It also seems like languages that use more and longer words are falling out of favor in times when everybody is in a rush. </p></blockquote></figure>



<p><code>begin</code> and <code>end</code> are less preferred than <code>{</code> and <code>}</code></p>



<p>The observation above relates to human languages just as much as to programming ones.</p>























<p>Niklaus Wirth‚Äôs <a href="https://archive.org/details/algorithmsdatast0000wirt_u9b4/page/n3/mode/2up" data-type="link" data-id="https://archive.org/details/algorithmsdatast0000wirt_u9b4/page/n3/mode/2up">Algorithms and Data Structures on Archive.org</a> ‚Äì can be borrowed</p>



<p><a href="https://www.reddit.com/r/Forth/comments/kqxxbt/why_forth/?locale=en">Why Forth?</a> ‚Äì a post on Reddit</p>



<p><a href="https://en.cppreference.com/w/c/language/history?locale=en" data-type="link" data-id="https://en.cppreference.com/w/c/language/history?locale=en">History of C</a> on cppreference.com</p>



<p><a href="http://www.ada-auth.org/standards/ada22.html" target="_blank" rel="noreferrer noopener"><strong>Ada 2022</strong> Language Reference Manual</a>. </p>



<p><a href="https://blogsystem5.substack.com/p/the-ides-we-had-30-years-ago-and" target="_blank" rel="noreferrer noopener">The IDEs we had 30 years ago‚Ä¶ and we lost</a> ‚Äì a recent and interesting post about the text interfaces of Turbo Pascal and similar!</p>



<p><a href="https://retrocomputing.stackexchange.com/questions/21852/how-common-was-programming-in-c-targeting-8-bit-processors-in-1983">8 bit microcomputers ‚Äì How common was programming in C targeting 8-bit processors in 1983? ‚Äì Retrocomputing Stack Exchange</a></p>

<p id="jp-relatedposts">
	<h3><em>Related</em></h3>
</p>
			<!-- clearfix -->
			

			
		</div></div>
  </body>
</html>
