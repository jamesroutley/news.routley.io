<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tomscii.sig7.se/2022/02/Guide-to-OpenBSD-on-the-PinebookPro">Original</a>
    <h1>The complete idiot&#39;s guide to OpenBSD on the Pinebook Pro</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">
  
  <div itemprop="articleBody">
    <p>Today I will show you how I installed the latest snapshot of OpenBSD
on my Pinebook Pro with plenty of detail so that you can do it, too.
I will include instructions for setting up full disk encryption, and
conclude with a summary of my experience running OpenBSD on this
device.</p>

<p>Why would you want to do such a thing? <em>Because you
can.</em><sup><a href="#f1">1</a></sup> That said, there are a couple CAVEATs around
this exercise. I will try my best to convey the pitfalls and
shortcomings of the state of the art—so you can decide whether this
is something for you or not.</p>

<p>The most important CAVEAT is, to quote OpenBSD’s <a href="https://ftp.openbsd.org/pub/OpenBSD/snapshots/arm64/INSTALL.arm64">INSTALL.arm64</a>:</p>

<blockquote>
  <p>Please be aware that OpenBSD support for this platform is far from
complete.</p>
</blockquote>

<p>Also worth stating that we are on moving ground: by the time you read
this, things might have changed (hopefully for the better), so be
mindful when following the steps and do not hesitate to deviate based
on your circumstances.  Exercise common sense and good judgment, and
strive to get an understanding of what you do before doing it.</p>

<p>You should read and understand this article in its entirety <em>before</em>
you even think of touching your Pinebook Pro. You might also want to
go through earlier reports of OpenBSD on the PBP, with snapshots of
6.7 <a href="https://xosc.org/pinebookpro.html">here</a> and 7.0
<a href="https://mfashby.net/posts/2021-10-30-openbsd/">here</a>.</p>

<p><strong>DISCLAIMER: all responsibility from tinkering with your laptop is
yours alone.</strong> This write-up is purely for entertainment purposes.
Please leave me alone if you managed to fry, smoke, brick, break, or
otherwise hurt your device.  Ditto if you lost precious data, sleep,
or hair.  <em>Any consequences of your decision to keep reading and
proceed with the below article are entirely yours to live with.</em></p>

<p>Still with me? You like to live dangerously? Okay, let’s get going.</p>



<p>We are going to install the latest OpenBSD snapshot on a <a href="https://wiki.pine64.org/index.php/Pinebook_Pro">Pinebook
Pro</a> (PBP) made in April, 2021. That manufacturing batch was a fairly
large one at Pine64, and I speculate the majority of PBPs in existence
is not significantly older than mine. Your hardware should therefore
be more or less the same (with the exception of the earliest batches,
where various issues were found and since have been ironed out).
Still, if there seem to be mysterious mismatches between what I
describe and what you see, your PBP might be different than mine.</p>

<p>We will install OpenBSD by writing the miniroot image directly to the
eMMC, and patching it with the bootloaders so the machine will boot
from the eMMC. To do this, you will need to unscrew the PBP’s bottom
plate and unplug the eMMC, attach it to another computer via a
USB-eMMC adapter, write (or “flash” or “burn” or “etch”) the data,
then stick the eMMC back into the PBP and boot the OpenBSD installer
from there. The installer will load from eMMC into memory and run from
a so-called ramdisk, allowing us to install the system directly on the
same eMMC. We will use the PBP’s serial console, so you will need a
serial cable plugged into the headphone jack, with the other end
connected to a second computer where you interact with the serial
terminal.</p>

<p>In addition to the eMMC, we will also prepare a USB memory stick to
carry the archives of the OpenBSD distribution set, as well as the
firmware binaries relevant to the PBP. This way, we will have access
to everything required to do the install all the way to a graphical
desktop and a working wireless network interface.  Without the USB
stick, we would need a temporary wired connection to download the sets
as well as the extra firmware to get the wifi working. Given that the
PBP does not have a wired Ethernet interface, that would cost us a
USB-Ethernet dongle.</p>

<p>Note that we <em>do not use</em> an SD card (we won’t need the PBP’s SD card
slot at all). SD cards are trickier than they seem.<sup><a href="#f2">2</a></sup>
On the other hand, a good old USB stick is easy to find and generally
pretty reliable, usable without issues even across operating systems.</p>

<p>Removing the eMMC from the laptop might seem like an unnecessary
hassle. We could, at least in theory, boot the installer from an SD
card, sidestepping the need for a USB-eMMC adapter and messing with
the PBP’s delicate eMMC. But this would not be without complications.
First, as mentioned above, SD cards present a host of potential
issues. Second, correctly landing the bootloader on the eMMC, while
certainly possible, is non-trivial (given that we could only patch it
on the SD card, but not the eMMC), adding complexity and making the
process even more error-prone. Finally, we would need to open the PBP
anyway, to toggle the internal switch to send the serial console on
the headphone jack.  Because OpenBSD does not (yet) support the PBP’s
“real” console, this is the only way to interact with the installer.</p>

<p>Therefore, I feel that at the time of writing, the method presented
below is probably the easiest way to reliably land OpenBSD on the PBP.
Further, it does not depend on the <em>a priori</em> state of the PBP at all:
no matter how hard you messed it up,<sup><a href="#f3">3</a></sup> this way you
can always do a clean reinstall.</p>





<p>Apart from the Pinebook Pro itself, you will need the following tools:</p>

<ul>
  <li>USB-eMMC adapter</li>
  <li>USB-to-serial cable with headphone jack connector</li>
  <li>USB memory stick</li>
  <li>Phillips screwdriver of a fairly small size (for the PBP’s delicate
bottom screws)</li>
</ul>

<p><a href="https://tomscii.sig7.se/images/pbp-openbsd/tools-big.jpg"><img src="https://tomscii.sig7.se/images/pbp-openbsd/tools.jpg" alt=""/></a></p>

<p>I got my USB-eMMC dongle from a local SBC shop here in Sweden; it is
made by Hardkernel and does not look exactly like the one sold on the
Pine64 store. You can probably do the same and grab one from your
nearest supplier.</p>

<p>I grabbed the first old, spare 8GB USB3.0 memory stick I had lying
around in my drawer. Its age in years is probably more than its
capacity in gigabytes, and by now it has spent most of its lifespan
hidden away as a spare. We will need less than a CD’s worth of free
capacity (around 500 MB); no need to reformat as long as it has a
commonly understood filesystem and enough free space.</p>

<p>I did not have the ready-made serial console cable offered by the
Pine64 store, but as an electronics nut, I did have the obligatory
FTDI USB-serial module floating around my desk. I found an audio cable
with 3.5” jack plugs on both ends. With some wires tightly twisted
around the plug on one end, a breadboard and duct tape, I created my
own console cable (close-up images
<a href="https://tomscii.sig7.se/images/pbp-openbsd/serial-cable-big.jpg">here</a> and
<a href="https://tomscii.sig7.se/images/pbp-openbsd/serial-cable2-big.jpg">here</a>). I’m not too proud
of it, but it works.<sup><a href="#f4">4</a></sup> If you also roll your own, the
wiring of the <a href="https://wiki.pine64.org/index.php/Pinebook_Pro#Using_the_UART">UART connection</a> goes like this:</p>

<ul>
  <li>tip: RX, connect to FTDI’s TX</li>
  <li>ring: TX, connect to FTDI’s RX</li>
  <li>sleeve: GND, connect to FTDI’s GND</li>
</ul>

<p>The three-way connector does not leave any lines for hardware flow
control (RTS/CTS). <em>Disable hardware flow control</em> in your serial
terminal, or it might refuse to send keyboard input on the wire.
Terminal programs have various options and defaults around this;
please check the relevant manuals.  By the way, the correct line speed
to communicate with the PBP console is <strong>115200 baud</strong>.</p>

<p>Please ensure that you use a USB-serial converter with <strong>3.3V pins</strong>,
or else you might fry (at least some pins of) the PBP SoC!  If in
doubt, plug it into a USB port and measure the DC voltage level of the
idle RX and TX lines with a digital instrument.</p>

<p>Lastly, you will need access to a second computer to prepare the eMMC
and the USB stick, and to access the serial console.  This computer
can be any regular Linux or BSD machine; it does not matter much as
long as it can access the Internet and has a functioning USB
port.<sup><a href="#f5">5</a></sup></p>

<h2 id="download-the-install-material">Download the install material</h2>

<p>First, familiarize yourself with the official OpenBSD installation
instructions for the ARM64 architecture. The file <a href="https://ftp.openbsd.org/pub/OpenBSD/snapshots/arm64/INSTALL.arm64">INSTALL.arm64</a> is
for the snapshot version we will use. Read it now. In general, you are
advised to follow the links throughout this article and study the
relevant materials to gain a fuller picture.</p>

<p>Let’s download everything needed to complete the installation. For
this, create a scratch folder on your second computer; I used
<code>~/openbsd70</code> but you can put the files wherever you like. You will
need less than a gigabyte of free space on the filesystem.</p>

<h3 id="snapshot-archives">Snapshot archives</h3>

<p>First, download the latest OpenBSD <a href="https://cdn.openbsd.org/pub/OpenBSD/snapshots/arm64/">snapshot archives</a> under your
scratch folder. The below commands should be shell-agnostic enough to
work on OpenBSD (ksh) and Linux (bash) alike, but on Linux, you will
want to use <code>wget</code> or <code>curl</code> instead of <code>ftp</code>. For example, write
<code>curl $BASE/$f -o $f</code> instead of <code>ftp $BASE/$f</code>.</p>

<div><div><pre><code>mkdir ~/openbsd70 &amp;&amp; cd ~/openbsd70
mkdir snapshot &amp;&amp; cd snapshot
BASE=&#34;https://cdn.openbsd.org/pub/OpenBSD/snapshots/arm64&#34;
FILES=&#34;SHA256 SHA256.sig base70.tgz bsd bsd.mp bsd.rd \
       comp70.tgz game70.tgz man70.tgz miniroot70.img \
       xbase70.tgz xfont70.tgz xserv70.tgz xshare70.tgz&#34;
for f in $FILES ; do ftp $BASE/$f ; done
</code></pre></div></div>

<p>Note that we did not download the largest image called <code>install70.img</code>,
because we won’t need it. On OpenBSD, use <code>signify</code> to verify the
integrity of the downloads:</p>

<div><div><pre><code>signify -C -p /etc/signify/openbsd-70-base.pub -x SHA256.sig
</code></pre></div></div>

<p>This should print an OK next to all the downloaded files. It will
print FAIL for all other files (listed in <code>SHA256.sig</code> but not
downloaded); that is fine. On Linux, use <code>sha256sum</code> to verify the
file hashes:</p>



<p>This is slightly less secure (it does not prove that the files were
published by OpenBSD) but still protects against corrupted downloads.</p>

<h3 id="firmware-archives">Firmware archives</h3>

<p>Next, download the latest OpenBSD <a href="http://firmware.openbsd.org/firmware/7.0/">firmware archives</a> in a similar
manner.  <em>Do not blindly copy-paste</em> the below snippet, because the
version numbers embedded into the filenames are bound to change! Visit
the previous link to see the actual list of files and adjust
accordingly.</p>

<div><div><pre><code>mkdir ~/openbsd70/firmware &amp;&amp; cd ~/openbsd70/firmware
BASE=&#34;http://firmware.openbsd.org/firmware/7.0&#34;
FILES=&#34;SHA256 SHA256.sig bwfm-firmware-20200316.1.2p2.tgz \
       uvideo-firmware-1.2p3.tgz&#34;
for f in $FILES ; do ftp $BASE/$f ; done
</code></pre></div></div>

<p>Given the PBP hardware, the two firmware archives (for <code>bwfm</code> and
<code>uvideo</code>) are all you need. But feel free to download all the firmware
if that makes you comfortable. Again, do not forget to verify the
integrity of your downloads. On OpenBSD:</p>

<div><div><pre><code>signify -C -p /etc/signify/openbsd-70-fw.pub -x SHA256.sig
</code></pre></div></div>

<p>On Linux, verification of the sha256 hashes is complicated by the fact
that OpenBSD started to use the base64 encoded binary hash values in
some of its <code>SHA256</code> files. This is not yet supported by <code>sha256sum</code>,
but here is a workaround using <code>openssl</code>:</p>

<div><div><pre><code>openssl sha256 -binary bwfm-firmware-20200316.1.2p2.tgz | openssl base64
</code></pre></div></div>

<p>Compare the output of the above command with the hash stored in <code>SHA256</code>:</p>



<p>Now you should be able to check that the two hashes are one and the same.</p>

<h3 id="bootloader-packages">Bootloader packages</h3>

<p>Finally, we need the contents of two OpenBSD packages to set up the
bootloader: <code>dtb</code> and <code>u-boot-aarch64</code>. We will download the packages
manually.<sup><a href="#f6">6</a></sup> To do so, navigate to the <a href="https://ftp.openbsd.org/pub/OpenBSD/snapshots/packages/aarch64/">snapshot
packages</a> with your browser and locate the files for <code>dtb</code> and
<code>u-boot-aarch64</code>. At the time of writing, these are <code>dtb-5.14p1.tgz</code>
and <code>u-boot-aarch64-2021.10p3.tgz</code>. Again, adapt the filenames:</p>

<div><div><pre><code>mkdir ~/openbsd70/packages &amp;&amp; cd ~/openbsd70/packages
BASE=&#34;https://ftp.openbsd.org/pub/OpenBSD/snapshots/packages/aarch64&#34;
FILES=&#34;SHA256 SHA256.sig dtb-5.14p1.tgz u-boot-aarch64-2021.10p3.tgz&#34;
for f in $FILES ; do ftp $BASE/$f ; done
</code></pre></div></div>

<p>After verification, untar them:</p>

<div><div><pre><code>tar xzf dtb-5.14p1.tgz
tar xzf u-boot-aarch64-2021.10p3.tgz
</code></pre></div></div>

<p>Now you have a <code>share/</code> directory beside the archives. We will use
some of the files from there when preparing the eMMC. But first, let’s
deal with the USB stick.</p>

<h2 id="prepare-the-usb-memory-stick">Prepare the USB memory stick</h2>

<p>With all install material conveniently at hand, it’s time to prepare
the USB stick. Verify that there is enough free space on it. We will
set it up with the OpenBSD archive structure. Assuming it is mounted
under <code>/mnt</code>, these are the commands you could use (should work on
both OpenBSD and Linux):</p>

<div><div><pre><code># cd /mnt
# mkdir -p 7.0/arm64
# cp ~/openbsd70/snapshot/* 7.0/arm64/
# cp -r ~/openbsd70/firmware .
</code></pre></div></div>

<p>Depending on how you mounted the USB stick, you might need elevated
rights to be able to write to it. In that case, do what you need to do
(i.e., precede the commands with <code>sudo</code>).</p>

<p>The directory structure on your USB stick should now look like this:</p>

<div><div><pre><code># ls -R /mnt
/mnt:
7.0      firmware

/mnt/7.0:
arm64

/mnt/7.0/arm64:
SHA256          bsd.mp          man70.tgz          xserv70.tgz
SHA256.sig      bsd.rd          miniroot70.img     xshare70.tgz
base70.tgz      comp70.tgz      xbase70.tgz
bsd             game70.tgz      xfont70.tgz

/mnt/firmware:
SHA256
SHA256.sig
bwfm-firmware-20200316.1.2p2.tgz
uvideo-firmware-1.2p3.tgz
</code></pre></div></div>

<p>We do not actually need the <code>miniroot70.img</code> on the USB stick, but it
was simpler to just copy everything. You can delete it if you wish.</p>

<p>Unmount and remove the USB stick; we will put it into the PBP before
powering it on to boot the installer. But that is for later. The next
logical step is to prepare the eMMC. But before we touch the PBP,
let’s make sure we really have everything in order.</p>

<h2 id="test-your-serial-cable">Test your serial cable</h2>

<p>Test your serial cable and get acquainted with the serial terminal
program you will use. Take the audio jack that you will plug into the
headphone socket of your PBP. By shorting the tip and ring (RX and TX)
together with a piece of bare wire (or a metal clamp, or a piece of
tinfoil…), you get an echo loop that prints everything you type. If
you remove the short, your typing should no longer echo (proving that
your typing really went through the cable).</p>

<p>On Linux, I like to use <code>minicom</code>, a very user-friendly menu-driven
terminal program. There is also <code>picocom</code>, <code>screen</code>, etc. On OpenBSD,
there is <code>cu</code>.</p>

<p>To discover the device node after plugging the serial cable in, check
the <code>dmesg</code> output. It is usually <code>ttyUSB0</code> on Linux and <code>ttyU0</code> on
OpenBSD. One of these commands should get you started:</p>

<div><div><pre><code>minicom -D /dev/ttyUSB0 -b 115200
picocom -b 115200 /dev/ttyUSB0
screen /dev/ttyUSB0 115200
cu -d -s 115200 -l ttyU0
</code></pre></div></div>

<p>You might need elevated privileges unless your user is set up with
permission to access the serial device.  <em>Do not proceed</em> until you
can echo characters through your cable!</p>



<p>Your second computer is fired up with the USB of the USB-serial cable
plugged into it, the serial terminal program of your choice up and
running and connected to it, and your cable verified to work. All
install media is downloaded, verified, and the parts that belong to
the USB stick have been copied there. Great progress! There is nothing
else we can do without touching the Pinebook Pro. This is your last
chance to close this page and walk away whistling, hands firmly
planted in your pockets.</p>

<p><em>« twiddling thumbs for a minute »</em></p>

<p>Still here? Alright, then you have some more studying to do: if you
haven’t already, thoroughly read through the PBP wiki page on
<a href="https://wiki.pine64.org/index.php/Pinebook_Pro#Disassembly_and_Reassembly">disassembling the laptop</a>. On top of being careful enough not to
break anything, not lose any small parts (shiny metal screws and hinge
screw stand-offs made of black plastic) and not cut your fingers, you
will need to locate the eMMC and two switches after removing the
bottom cover plate of the laptop. Here is a close-up of my PBP,
showing exactly what you need to look for:</p>

<p><a href="https://tomscii.sig7.se/images/pbp-openbsd/pbp-inside-big.jpg"><img src="https://tomscii.sig7.se/images/pbp-openbsd/pbp-inside.jpg" alt=""/></a></p>

<p>The way I like to open my PBP is this. First, I fully open the lid,
then put the laptop with keyboard facing down, resting on the table
surface, with the display pointing downwards into my lap. I remove the
screws (into a small box) and carefully take the bottom cover off.
Then, holding the laptop at its sides, I lift it up and place it on
the table, resting on its side edge with the display pointing away
from me. This allows me to inspect and manipulate the inside with no
risk of stressing the hinges.  When it is time to power on, I put the
bottom plate in place, but do not fasten it with screws. I just hold
everything together and turn the thing around, with bottom to the
table, just like a normal laptop so I can turn it on, look at the
screen and type as usual. The bottom cover should be in place because
it acts as the SoC heatsink. I <em>believe</em> the above is OK (at least my
PBP did not break yet). What you should <strong>never</strong> do is exercise
(open/close) the display lid with the bottom unscrewed, because the
unfastened hinges lack structural strength and <em>will break</em>.</p>

<p>After taking off the bottom of your PBP, set both switches (marked
with red circles above) as pictured, with their levers towards the
display hinge and away from the touchpad. They are number 9 and 24 on
the <a href="https://wiki.pine64.org/index.php/Pinebook_Pro#Mainboard_Switches_and_Buttons">PBP parts diagram</a>; these settings enable the eMMC and send the
serial console to the headphone jack. In your PBP, the eMMC will most
likely already be enabled, but you will have to toggle switch 9 for the
UART.</p>

<h2 id="remove-the-emmc">Remove the eMMC</h2>

<p>Now we need to remove the eMMC, the fairly small rectangular board
only slightly larger than the black memory chip itself. As you can see
in the photo above, mine is 64GB in size. On the underside of the eMMC
board, the socket is alongside the edge closest to the switch (24). In
my PBP, the eMMC was stuck to the mainboard with some two-sided
sticker tape holding it in place. Thus, removing it was a bit harder
than anticipated. It is probably safest to use a piece of hard plastic
with an edge, such as a guitar pick, to pry the eMMC off of the
mainboard and separate it from the sticky tape. Do not use a sharp
piece of metal (such as a knife or screwdriver), or you might hurt one
of the boards.</p>

<p>Once you have the eMMC between your fingers, immediately snap it on to
the socket of the USB-eMMC adapter. This reduces the chances of
dropping it, losing it, or smudging the electrical contacts with
sweaty fingers. Be careful to correctly position it over the adapter’s
socket, then connect with a gente but firm push. You should be able to
feel that it is now sitting in place.</p>

<h2 id="backup-emmc-data">Backup eMMC data</h2>

<p>Plug the USB-eMMC adapter into your second machine and check out the
storage device.  This is what I saw in the <code>dmesg</code> log on Linux:</p>

<div><div><pre><code>usb 4-2: new SuperSpeed Gen 1 USB device number 3 using xhci_hcd
usb 4-2: New USB device found, idVendor=05e3, idProduct=0749, bcdDevice=15.32
usb 4-2: New USB device strings: Mfr=3, Product=4, SerialNumber=2
usb 4-2: Product: USB3.0 Flash Disk
usb 4-2: Manufacturer: Generic
usb 4-2: SerialNumber: 000000001532
usb-storage 4-2:1.0: USB Mass Storage device detected
scsi host2: usb-storage 4-2:1.0
scsi 2:0:0:0: Direct-Access     Generic  USB Flash Disk   1532 PQ: 0 ANSI: 6
sd 2:0:0:0: Attached scsi generic sg0 type 0
sd 2:0:0:0: [sda] 122142720 512-byte logical blocks: (62.5 GB/58.2 GiB)
sd 2:0:0:0: [sda] Write Protect is off
sd 2:0:0:0: [sda] Mode Sense: 21 00 00 00
sd 2:0:0:0: [sda] Write cache: disabled, read cache: enabled, doesn&#39;t support DPO or FUA
sd 2:0:0:0: [sda] Attached SCSI removable disk
</code></pre></div></div>

<p>As you can see, my eMMC showed up as <code>sda</code> through the adapter. Yours
might be different.  <strong>Note the correct device</strong> and use it in all
subsequent commands! We want to use the device for the complete raw
storage, as opposed to the partitions (if any). On OpenBSD, you will
want to use something like <code>rsd0c</code>.</p>

<p>If you have an existing system on the PBP that is at all valuable,
start by saving the full content of the eMMC. This will allow you to
restore it later and get your old PBP back, should you get stuck or
tired of this adventure. You could also buy a second eMMC to install
OpenBSD on, allowing you to keep the original intact so you can swap
back and forth between different systems. I would actually advise you
to do that instead of destroying a working system if you routinely
relied on your PBP for… well, <em>anything</em>.</p>

<p>On Linux, the following command will write an image of the eMMC
content to <code>emmc_orig.img</code>. Remember, <strong>substitute your correct
device</strong> in place of <code>sda</code>. On OpenBSD, the command is identical
(modulo input device), except that you should use <code>bs=1m</code> instead of
<code>bs=1M</code>.</p>

<div><div><pre><code>dd if=/dev/sda of=emmc_orig.img bs=1M
</code></pre></div></div>

<p>This should take a couple minutes and you should see the light
flashing on the USB-eMMC adapter throughout, serving as proof that you
are using the correct device. At the end, you will get a nice summary
of the bulk read performance of your eMMC. This is what I saw:</p>

<div><div><pre><code># dd if=/dev/sda of=emmc_orig.img bs=1M
59640+0 records in
59640+0 records out
62537072640 bytes (63 GB, 58 GiB) copied, 390.282 s, 160 MB/s
</code></pre></div></div>

<p>Bulk write performance is significantly lower at around 60 MB/s,
according to my measurements.</p>

<h2 id="prepare-the-emmc">Prepare the eMMC</h2>

<p>Time to equip the eMMC with the bootable installer image!</p>

<p><strong>This is the very last moment you can put everything back together
and pretend that nothing happened.</strong></p>

<p>This <a href="https://www.exoticsilicon.com/jay/sbc_bootcamp_2021">SBC
bootcamp</a> by
Exotic Silicon is an interesting read if you want some more background
on booting ARM64 SBCs.</p>

<p>First, we will write the downloaded <code>miniroot70.img</code> to the eMMC. On
Linux:</p>

<div><div><pre><code>cd ~/openbsd70/snapshot
dd if=miniroot70.img of=/dev/sdX bs=1M
</code></pre></div></div>

<p>I hope you did not forget to use the correct device this time
either.<sup><a href="#f7">7</a></sup> Again, on OpenBSD you will want to use
something like <code>/dev/rsd0c</code> and <code>bs=1m</code>.</p>

<p>This should not take more than a second or two, as the miniroot image
is only 43 megabytes.</p>

<p>Now we will copy the Pinebook Pro-specific DTB (device tree blob) on
to the msdos-type boot partition containing u-boot data. The correct
partition to mount will be <code>sda1</code> or similar on Linux; on OpenBSD, it
will be something like <code>sd0i</code>.</p>

<div><div><pre><code>cd ~/openbsd70/packages
mount /dev/sdX1 /mnt
mkdir /mnt/rockchip
cp share/dtb/arm64/rockchip/rk3399-pinebook-pro.dtb /mnt/rockchip/
umount /mnt
</code></pre></div></div>

<p>Next, patch the U-Boot bootloader code into the eMMC image. On Linux:</p>

<div><div><pre><code>dd if=share/u-boot/pinebook-pro-rk3399/idbloader.img of=/dev/sdX seek=64
dd if=share/u-boot/pinebook-pro-rk3399/u-boot.itb of=/dev/sdX seek=16384
</code></pre></div></div>

<p>On OpenBSD, use something like <code>sd0c</code> (ending in <code>c</code> to operate on the
complete disk, but without <code>r</code> to use the block device as opposed to
the raw device).</p>



<p>With the eMMC prepared, we are finally ready to actually install
OpenBSD.  Carefully put the eMMC back into the laptop. If you followed
what I did and opened the lid before unscrewing the bottom, you can
just put the bottom cover in its place, and turn the laptop into the
normal position while holding it tight.  If you were working the PBP
in the more traditional way (with lid closed), you <strong>must</strong> screw on
the bottom cover before you can open the display hinges.</p>

<p>With the PBP now in working position, lid open, and bottom plate (SoC
heatsink) in place, plug the serial console into the headphone jack.
Plug in the USB stick as well. Make sure there is no SD card
accidentally left in the slot.  Take a deep breath and hold the power
button for about a second. If everything went well, you should see
something like this on the serial terminal (<a href="https://tomscii.sig7.se/files/pbp-openbsd/base-install-serial-log.txt">full console log</a>):</p>

<div><div><pre><code>U-Boot TPL 2021.10 (Jan 25 2022 - 00:18:46)
Channel 0: LPDDR4, 50MHz
BW=32 Col=10 Bk=8 CS0 Row=15 CS1 Row=15 CS=2 Die BW=16 Size=2048MB
Channel 1: LPDDR4, 50MHz
BW=32 Col=10 Bk=8 CS0 Row=15 CS1 Row=15 CS=2 Die BW=16 Size=2048MB

...

Found EFI removable media binary efi/boot/bootaa64.efi
178519 bytes read in 36 ms (4.7 MiB/s)
Booting /efi\boot\bootaa64.efi
disks: sd0*
&gt;&gt; OpenBSD/arm64 BOOTAA64 1.7
boot&gt;

...

Welcome to the OpenBSD/arm64 7.0 installation program.
(I)nstall, (U)pgrade, (A)utoinstall or (S)hell?
</code></pre></div></div>

<p>Congratulations, you are staring in the face of the OpenBSD installer.
From here it should be smooth sailing. If you get stuck, refer to my
<a href="https://tomscii.sig7.se/files/pbp-openbsd/base-install-serial-log.txt">full console log</a> to see what I did exactly.</p>

<h2 id="base-system-install">Base system install</h2>

<p>At startup, we have no way to configure the network, because we do not
(yet) have the necessary firmware:</p>

<div><div><pre><code>Available network interfaces are: bwfm0 vlan0.
Which network interface do you wish to configure? (or &#39;done&#39;) [bwfm0] done
DNS domain name? (e.g. &#39;example.com&#39;) [my.domain] lan
DNS nameservers? (IP address list or &#39;none&#39;) [none]
</code></pre></div></div>

<p>When it comes to available disks, use ‘?’ to get a list of storage
devices if you are not sure. But <code>sd0</code> should be the eMMC and <code>sd1</code>
should be the USB stick. For partitioning, use the whole disk; the
installer is smart enough to realize that the small msdos-type boot
partition containing u-boot must be left intact. Since this is a demo
install, I accepted the auto-allocated layout. You are of course free
(and encouraged) to adjust it however you see fit.</p>

<p>Next, when it comes to installing the sets, we direct the installer to
the USB stick recognised as <code>sd1</code>:</p>

<div><div><pre><code>Let&#39;s install the sets!
Location of sets? (disk http nfs or &#39;done&#39;) [http] disk
Is the disk partition already mounted? [yes] no
Available disks are: sd0 sd1.
Which disk contains the install media? (or &#39;done&#39;) [sd1]
  a:          1358848             1024  4.2BSD   2048 16384 16142
  i:              960               64   MSDOS
Available sd1 partitions are: a i.
Which sd1 partition has the install sets? (or &#39;done&#39;) [a]
Pathname to the sets? (or &#39;done&#39;) [7.0/arm64]
INSTALL.arm64 not found. Use sets found here anyway? [no] yes
</code></pre></div></div>

<p>You will get a warning about <code>INSTALL.arm64</code> missing from the archive;
just confirm that you want to continue. After selecting the sets, you
will also be warned about a missing <code>SHA256.sig</code> (which I do not fully
comprehend, given that we put that file in place). Again, confirm that
you want to continue:</p>

<div><div><pre><code>Select sets by entering a set name, a file name pattern or &#39;all&#39;. De-select
sets by prepending a &#39;-&#39;, e.g.: &#39;-game*&#39;. Selected sets are labelled &#39;[X]&#39;.
    [X] bsd           [X] base70.tgz    [X] game70.tgz    [X] xfont70.tgz
    [X] bsd.mp        [X] comp70.tgz    [X] xbase70.tgz   [X] xserv70.tgz
    [X] bsd.rd        [X] man70.tgz     [X] xshare70.tgz
Set name(s)? (or &#39;abort&#39; or &#39;done&#39;) [done] done
Directory does not contain SHA256.sig. Continue without verification? [no] yes
</code></pre></div></div>

<p>And that is all there is to it. Relinking the unique kernel takes a
bit of time, and I sure hope you have the heatsink in place over the
SoC. When the installer is done, reboot. Rebooting actually worked for
me, which came as a pleasant surprise (based on earlier reports, I
expected having to hold the power button).</p>

<div><div><pre><code>CONGRATULATIONS! Your OpenBSD install has been successfully completed!

When you login to your new system the first time, please read your mail
using the &#39;mail&#39; command.

Exit to (S)hell, (H)alt or (R)eboot? [reboot]
syncing disks... done
rebooting...

U-Boot TPL 2021.10 (Jan 25 2022 - 00:18:46)
Channel 0: LPDDR4, 50MHz

...
</code></pre></div></div>

<p>At the end of the first reboot, login to the brand new OpenBSD system as root:</p>

<div><div><pre><code>...

OpenBSD/arm64 (aurora.lan) (console)

login: root
Password:
OpenBSD 7.0-current (GENERIC.MP) #1516: Mon Jan 31 00:30:28 MST 2022

Welcome to OpenBSD: The proactively secure Unix-like operating system.
</code></pre></div></div>

<p>Now mount the USB stick (still plugged in, right?); look above for a
hint to the correct device (printed by the installer).<sup><a href="#f8">8</a></sup>
Run <code>fw_update</code> to install necessary firmware:</p>

<div><div><pre><code>aurora# mount /dev/sd1a /mnt
aurora# fw_update -p /mnt/firmware
fw_update: added bwfm,uvideo; updated none; kept none
</code></pre></div></div>

<p>To connect to the network, create the file <code>/etc/hostname.bwfm0</code> with
the network SSID and the WPA key (substitute <code>SSID</code> and <code>WPAKEY</code> with
your actual wireless credentials). We also enable <code>xenodm</code>, the X
display manager service to get X started on boot. Then reboot:</p>

<div><div><pre><code>aurora# echo &#34;join SSID wpakey WPAKEY&#34; &gt; /etc/hostname.bwfm0
aurora# echo &#34;inet autoconf&#34; &gt;&gt; /etc/hostname.bwfm0
aurora# rcctl enable xenodm
aurora# reboot
</code></pre></div></div>

<p>When you see the message <code>syncing disks... done</code>, remove the USB stick.</p>

<p>On the first bootup with X enabled, you will get a garbled screen (I
got a bunch of vertical lines against a grey backdrop). Unfortunately,
the serial console will be dead as well, so just hold the power button
until the laptop goes dark, and then wait a couple minutes. On the
next boot, you will get some unfriendly messages about filesystems
that were not cleanly unmounted, but OpenBSD should come up alright
(including the graphics).<sup><a href="#f9">9</a></sup></p>

<p><strong>Et voilà:</strong></p>

<p><a href="https://tomscii.sig7.se/images/pbp-openbsd/pbp-openbsd-big.jpg"><img src="https://tomscii.sig7.se/images/pbp-openbsd/pbp-openbsd.jpg" alt=""/></a></p>

<p>At this point, we can login via X as well as SSH over the network.</p>

<p>As you can probably tell from the ugly white stickers (actually,
patches of duct tape) on the keyboard: I use the Dvorak layout. At an
earlier time, while still running Linux, I updated the keyboard
firmware and as part of the process, converted the layout to Dvorak.
Since the mapping is handled by the keyboard controller, it is
transparent to OpenBSD which is set to the default <code>us</code> keyboard
layout. I find this to be very convenient, messing around with
different operating systems, bootloaders et al.</p>

<p>Even if you do not want to change the layout, it is advised to upgrade
the firmware, as it fixes some issues (I remember Alt + arrow keys did
not work).<sup><a href="#f10">10</a></sup> Something you might want to look into
while you still have Linux up and running (as that is what you need to
run the firmware updater). But you can also boot from an SD card
prepared with Linux to do this later. Check the Pine64 forums for
details.</p>

<p>If you reached this point, congratulations! Now you can login with the
regular user you created, start an <code>xterm</code> and compare your <code>dmesg</code> to
<a href="https://tomscii.sig7.se/files/pbp-openbsd/dmesg_2022-02.txt">mine</a>. What a grand luxury!</p>

<h2 id="full-disk-encryption">Full disk encryption</h2>

<p>Nowadays it is <em>de rigueur</em> to set up mobile computers with full disk
encryption, and OpenBSD provides a convenient way to do so via its
<a href="http://www.openbsd.org/faq/faq14.html#softraidFDE">softraid
subsystem</a>.  The
thought of using this might well be tempting—after all, if you want
an OpenBSD laptop, you probably want a <em>secure</em> laptop.  While it is
technically possible to install OpenBSD on the PBP with this today, I
would recommend against doing so for reasons that will become clear in
a moment.</p>

<p>That said, I did test the complete install with FDE to verify that it
is indeed possible to make it work, and here I give you all the
instructions you might need. I assume you have studied and understood
the OpenBSD documentation on softraid FDE; if not, please follow the
previous link before you read on. We will mostly rely on the steps
outlined there, but we need to deviate a little.</p>

<p>First, it is customary to overwrite the whole device with random data
at the start of an FDE install. If you want to do that, take it as the
first step of preparing the eMMC (while attached to the secondary,
presumably more powerful computer).  Then, continue to prepare it as
described above by writing the miniroot image to it, followed by
copying the DTB and finally patching in the bootloaders.</p>

<p>When you boot up the PBP with the installer, you will need to drop
into the live shell environment and prepare a softraid device on top
of which the operating system will be installed. We cannot directly
execute the commands as spelled out in the OpenBSD
<a href="http://www.openbsd.org/faq/faq14.html#softraidFDE">FAQ</a>, because that
assumes a “normal” architecture without the complications of ARM and
the U-Boot bootloader. In other words, we cannot yank the existing
disk content and reinitialize the partition table—instead, we need
to preserve the msdos-type boot partition at the beginning of the
disk.</p>

<p>What we will do is use
<a href="https://man.openbsd.org/disklabel">disklabel(8)</a> to extend the
partition table to the entire size of the disk, and substitute the
OpenBSD partition with a RAID-type area that takes up the whole
extent.  The offsets reflect the fact that I am doing this on a brand
new 128GB eMMC:</p>

<div><div><pre><code>Welcome to the OpenBSD/arm64 7.0 installation program.
(I)nstall, (U)pgrade, (A)utoinstall or (S)hell? s
# cd /dev &amp;&amp; sh MAKEDEV sd0
# disklabel -E sd0
Label editor (enter &#39;?&#39; for help at any prompt)
sd0&gt; p
OpenBSD area: 49152-88064; size: 38912; free: 0
#                size           offset  fstype [fsize bsize   cpg]
  a:            38912            49152  4.2BSD   2048 16384  1216
  c:        244285440                0  unused
  i:            16384            32768   MSDOS
sd0&gt; b
Starting sector: [49152]
Size (&#39;*&#39; for entire disk): [38912] *
sd0*&gt; d a
sd0*&gt; a a
offset: [49152]
size: [244236288]
FS type: [4.2BSD] RAID
sd0*&gt; w
sd0&gt; q
No label changes.
</code></pre></div></div>

<p>We set up the softraid device (it becomes <code>sd2</code>, since <code>sd1</code> is taken
by our USB stick), supplying the encryption password.  Then, we wipe
the first 1MB of the crypto device as recommended.</p>

<div><div><pre><code># bioctl -c C -l sd0a softraid0
New passphrase:
Re-type passphrase:
sd2 at scsibus2 targ 1 lun 0: &lt;OPENBSD, SR CRYPTO, 006&gt;
sd2: 119255MB, 512 bytes/sector, 244235760 sectors
softraid0: CRYPTO volume attached as sd2
# cd /dev &amp;&amp; sh MAKEDEV sd2
# dd if=/dev/zero of=/dev/rsd2c bs=1m count=1
1+0 records in
1+0 records out
1048576 bytes transferred in 0.183 secs (5710289 bytes/sec)
</code></pre></div></div>

<p>Finally, we exit from the shell and proceed to install OpenBSD as
usual:</p>

<div><div><pre><code># exit
erase ^?, werase ^W, kill ^U, intr ^C, status ^T

Welcome to the OpenBSD/arm64 7.0 installation program.
(I)nstall, (U)pgrade, (A)utoinstall or (S)hell? i
</code></pre></div></div>

<p>Just be mindful to use the correct device; <code>sd2</code> is our encrypted
volume:</p>

<div><div><pre><code>Available disks are: sd0 sd1 sd2.
Which disk is the root disk? (&#39;?&#39; for details) [sd0] sd2
</code></pre></div></div>

<p>There is literally no further change required from our previous
actions. Once we remove the USB stick, the encrypted volume will
auto-migrate to <code>sd1</code> on the next boot.</p>

<h3 id="caveats-with-fde">CAVEATs with FDE</h3>

<p>So what’s not to like about encrypting the PBP?</p>

<p>When you turn on your laptop, you will see this on the screen:</p>

<div><div><pre><code>disks: sd0* sr0
&gt;&gt; OpenBSD/arm64 BOOTAA64 1.7
Passphrase:
</code></pre></div></div>

<p>Even though the password prompt <em>will</em> appear on the screen, you <em>will
not</em> be able to type your password. It only works through the serial
console.  For me, this is a showstopper. This means you will not be
able to revert the headphone jack to its primary function, and you
will always need to have a second computer and serial adapter at hand,
just to turn on your laptop.</p>

<p>There is a second downside related to performance. Because of the
PBP’s limited compute power, disk operations will cause a noticeable
CPU load. This is especially apparent on bootup (before apmd gets to
fix the CPU frequencies); at least subjectively, finding the boot
blocks seems to take a great deal longer. But even after the system is
up and running, disk operations will tax the processor. While writing
1GB of zeroes to a file with <code>dd</code>, the process spent significant time
blocked in <code>bqwait</code> and <code>biowait</code>, with CPU usage around 20-30%. For
reference, on the same task but without FDE, CPUs were mostly idle.</p>

<p>For the above reasons, even though full disk encryption technically
works (clearly, you <em>can</em> enter the password via the serial console
and boot up your laptop), I decided against using it. I reinstalled
the base system without FDE on the 128GB eMMC, keeping my 64GB module
as a backup, and for possible future experiments.</p>

<h2 id="minimal-tuning-and-survival-tips">Minimal tuning and survival tips</h2>

<p>There are many great resources on how to set up OpenBSD in general and
for desktop use in particular. Here I will only link to <a href="https://www.c0ffee.net/blog/openbsd-on-a-laptop">this
guide</a> which I
personally found quite useful. Below are some essentials that are
PBP-specific or especially important from our perspective.</p>

<h3 id="enable-apmd">Enable apmd</h3>

<p>This is important for getting reasonable CPU clock speeds across all
the cores. Without this, the ARM cores will be stuck at 600 MHz or so.</p>

<p>The <code>-A</code> flag enables performance auto-adjustment mode, which is what
you want on a laptop.</p>

<div><div><pre><code>rcctl enable apmd
rcctl set apmd flags -A
rcctl start apmd
</code></pre></div></div>

<h3 id="adjust-display-brightness">Adjust display brightness</h3>

<p>The hotkeys do not work out of the box, but it is possible to query
and set the display brightness with <code>wsconsctl</code>:</p>

<div><div><pre><code># wsconsctl display.brightness
display.brightness=100.00%
# wsconsctl display.brightness=70
display.brightness -&gt; 69.41%
</code></pre></div></div>

<p>To set a permanent default brightness, put the command in
<code>/etc/wsconsctl.conf</code>, for example:</p>

<div><div><pre><code>echo &#34;display.brightness=70&#34; &gt;&gt; /etc/wsconsctl.conf
</code></pre></div></div>

<h3 id="fix-the-delete-key">Fix the Delete key</h3>

<p>Pressing <code>Delete</code> (that is, <code>Fn</code> + <code>Backspace</code>) in <code>xterm</code> does not
work out of the box the way most people would expect. This is not
strictly specific to the PBP, but something most users new to the
OpenBSD desktop will run into. To fix it, add the following entry to
<code>~/.Xresources</code> (creating it if it does not yet exist):</p>



<p>and then either issue <code>xrdb -merge ~/.Xresources</code> or restart
(logout/login) your X session. For background, see
<a href="https://man.openbsd.org/xterm.1#deleteIsDEL">xterm(1)</a>.</p>



<p>So now we have OpenBSD on the Pinebook Pro. But to what extent does it
actually work?</p>

<h2 id="things-that-work">Things that work</h2>

<ul>
  <li>
    <p>The graphical desktop, keyboard and touchpad all seem to work fine.</p>
  </li>
  <li>
    <p>Battery charge indicator seems fine (<code>i3status</code> suggests around 7
hours remaining near full charge while idling on 50% display
brightness, matching my expectations).</p>
  </li>
  <li>
    <p>Wireless network adapter seems to work. But do not expect great
performance: I <a href="https://tomscii.sig7.se/files/pbp-openbsd/iperf3-log.txt">measured</a> roughly
40-50 Mbits/sec of throughput on the 5GHz band, and around 20
Mbits/sec on the 2.4GHz band. For comparison, the same Pinebook Pro
with Manjaro ARM 21.12 (temporarily booted from an SD card) managed
around 85 Mbits/sec on 5GHz and around the same 20 Mbits/sec on
2.4GHz.  OpenBSD’s <code>bwfm</code> driver seems to deliver inferior
performance on 5GHz compared to what an up-to-date Linux kernel
offers; the performance on 2.4GHz seems to be on par.  For
reference, a contemporary AMD Ryzen 5 laptop with Debian scored
around 300-400 Mbits/sec on 5GHz and 50-60 Mbits/sec on 2.4GHz in
the same physical locations, on the same home network. For more
details, take a look at the <a href="https://tomscii.sig7.se/files/pbp-openbsd/iperf3-log.txt">measurement
logs</a>.</p>
  </li>
  <li>
    <p>Audio plays through the speakers (my headphone jack is still on
serial, did not yet switch back in anticipation of more tinkering).
As expected, the sound level is quite low (even with
<code>sndioctl output.level=1</code>).</p>
  </li>
  <li>
    <p>The webcam seems to work: following the steps in the Webcam section
of the <a href="https://www.openbsd.org/faq/faq13.html#webcam">Multimedia FAQ</a>,
I was able to bring up a live view of the webcam using this command:</p>
  </li>
  <li>
    <p>My usual <code>i3</code> setup that I have been using for the last decade or so
worked almost completely out of the box, so I felt right at home. In
fact, I only recall adjusting the device names in the <code>i3status</code>
config for network and free disk space indicators.</p>
  </li>
  <li>
    <p>I was able to <code>pkg_add firefox-esr</code>, and set it up with my preferred
(minimal) set of extensions such as Privacy Badger, adblocker, etc.
The browsing experience is a bit sluggish, but OK.</p>
  </li>
  <li>
    <p>After a couple days, I successfully
<a href="https://www.openbsd.org/faq/current.html">bumped</a> my OpenBSD
snapshot by running <code>sysupgrade -s</code>. While rebooting (both times), I
force-powered off the PBP and left it for about 5 minutes without
the charger plugged in to make sure it won’t hang on the wifi driver
(see below).</p>
  </li>
</ul>

<h2 id="things-that-do-not-fully-work">Things that do not (fully) work</h2>

<h3 id="wifi-driver-hangs-on-boot-with-workaround">Wifi driver hangs on boot (with workaround)</h3>

<p>As also reported on a <a href="https://xosc.org/pinebookpro.html">previous
account</a>, sometimes the PBP will
freeze during boot. It seems to get stuck in the <code>bwfm</code> driver. Once
stuck, immediate restarts will also likely run into this issue, so it
feels like you are trapped in an endless crash-restart-crash loop.</p>

<p>These are the relevant (and last) lines printed on the console:</p>

<div><div><pre><code>bwfm_sdio_buf_write: error 60
bwfm0: timeout on core reset
</code></pre></div></div>

<p>However, I found that the problem only happens on warm reboots and/or
reboots done shortly after the previous power-off, and with the
charger plugged in. I suspect some hardware state might not be
correctly reset or (re)initialized on reboot, so it only works if the
whole machine started up cold.  If this happens to you, try to give
the circuits some extra downtime so they can fully discharge and
“forget” everything. Disconnect the charger as well for the wait, and
boot before possibly plugging it in again. With this treatment, so far
I could almost always bring up OpenBSD on the first try.</p>

<h3 id="real-console">“Real” console</h3>

<p>As you’ve already seen, after U-Boot hands off execution to the
kernel, there is only a flicker on the LCD where console output should
be.  Eventually, X will appear and things will look normal. When the
system is up and running, I can even switch pseudo-terminals (with
Control-Alt-F<em>n</em> where <em>n</em> &gt; 1), and they seem to work fine.</p>

<p>Still, the lack of console support is a real impediment to a more
streamlined installation procedure and taking advantage of OpenBSD’s
otherwise excellent support for full disk encryption.</p>

<h3 id="poweroff">Poweroff</h3>

<p>After <code>shutdown -h -p now</code>, OpenBSD is not able to power down the
laptop.  After the below message appears, I have to keep the power
button depressed for several seconds to power off the hardware.</p>

<div><div><pre><code>*** FINAL System shutdown message from root@aurora.lan ***
System going down IMMEDIATELY

System shutdown time has arrived
syncing disks... done

Attempting to power down...
</code></pre></div></div>

<p>At least for me, this is not a big deal. If you don’t have the serial
terminal attached, count to ten after issuing the shutdown command and
before depressing the power button, and you should be fine.</p>

<h3 id="microphone-input">Microphone input</h3>

<p>I was not successful in trying to record (or otherwise detect the
presence of) audio input from the PBP’s microphones. Trying to <a href="https://www.openbsd.org/faq/faq13.html#audioprob">debug
the issue</a>, I found
that while recording with <code>aucat -o rec.wav</code>, the output of <code>audioctl</code>
showed lines <code>record.bytes=0</code> and <code>record.errors=0</code> (i.e., stuck at
zero) while <code>play.bytes</code> kept happily increasing. Neither decreasing
the sample rate from 48000 to 44100 to 32000, nor switching
<code>record.channels</code> from 2 to 1 changed the outcome.  I took this as a
sign of missing driver support and gave up.</p>

<h3 id="ac-adapter-state">AC adapter state</h3>

<p>While the battery capacity readout seems accurate, <code>apm</code> reports the
AC adapter state as “unknown”, so OpenBSD is seemingly unaware of
whether the PBP is on charger or running on battery.  The battery does
get charged if AC is connected (I guess that works on the hardware
level), and the capacity seems to be accurate (increasing while being
charged), so no big deal.</p>

<p>Update: I was advised that <code>hw.sensors</code> contains an entry for this:</p>

<div><div><pre><code>sysctl hw.sensors.gpiocharger0.indicator0
hw.sensors.gpiocharger0.indicator0=On (mains power supply)
</code></pre></div></div>

<h3 id="sd-card-slot">SD card slot</h3>

<p>I plugged in a known-good SD card, but nothing even appeared in
<code>dmesg</code>, so I assume this is a case of missing platform support. My
USB-connected SD card reader seems to work though, so this is not a
real issue for me. And I can still use the SD slot to boot a different
operating system on a temporary basis.</p>

<h3 id="suspend-and-resume">Suspend and resume</h3>

<p>This is something that clearly does not work; even the display screen
stays bright after I close the lid. Another clear case of missing
platform support.</p>



<p>Given the target audience of the Pinebook Pro is hardware tinkerers
and Linux/BSD enthusiasts: in case you are into OpenBSD, I feel this
is a workable state of affairs. Hardware support is a bit incomplete
here and there (but we knew that from the start). We still get a very
reasonable set of capabilities and the performance is roughly on par
with Linux (minus GPU acceleration of the desktop and diminished 5GHz
wireless throughput). Of course, this won’t cut it for those demanding
a “production quality” or “professional” laptop experience, but for us
tinkerers, I feel it’s a pretty comfortable place to be. Considering
that things are bound to improve even further, OpenBSD has earned its
stay on my Pinebook Pro.</p>

<hr/>

<p><b id="f1">1</b> Okay, okay. Because it’s a great way to learn more
about OpenBSD, and the Pinebook Pro, and the nascent ARM64
architecture. Because it’s the best excuse to tinker with hardware and
generally to appease your inner geek, and possibly to build the
ultimate geeky laptop for yourself.</p>

<p><b id="f2">2</b> Just look at all the SBC forums full of people
complaining about various install errors that turn out to be caused by
faulty or badly written SD cards.</p>

<p><b id="f3">3</b> With the obvious exceptions of breaking the hardware
or bricking the embedded controllers, such as that of the keyboard.
Then you will be in the market for a brand new PBP or two.</p>

<p><b id="f4">4</b> If you are also into the DIY route, try to scavenge
an audio plug on a cable that you can cut off, like an old pair of
headphones. Then you can blank and solder the wires from the cable to
a standard FTDI header (2.54mm pins). That is what I will do to build
my <em>real</em> serial console adapter as soon as I find a suitable “donor”.</p>

<p><b id="f5">5</b> You could probably use a computer with a different
operating system as long as you are able to perform the tasks with it,
but in that case you will have to come up with the equivalent programs
to use and commands to run.</p>

<p><b id="f6">6</b> If the machine we used for this preparation was
another OpenBSD running the same snapshot, we could just install these
via <code>pkg_add</code>. In general (and especially if you use Linux) that is
not feasible.</p>

<p><b id="f7">7</b> I changed it to <code>sdX</code> to protect those guilty of
mindless copy-pasting.</p>

<p><b id="f8">8</b> If it’s not <code>sd1a</code>, it is probably going to be
<code>sd1i</code>, which is how a single FAT32 partition looks to OpenBSD.</p>

<p><b id="f9">9</b> I have no idea why this happens, but I suspect the
graphics, since after a hard poweroff due to a wifi boot hang, the
filesystem will be clean thereafter.</p>

<p><b id="f10">10</b> This might not apply to you if your PBP is recent
enough. Please check the Pine64 forums.</p>


  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
