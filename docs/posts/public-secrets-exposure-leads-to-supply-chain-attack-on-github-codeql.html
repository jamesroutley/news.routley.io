<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.praetorian.com/blog/codeqleaked-public-secrets-exposure-leads-to-supply-chain-attack-on-github-codeql/">Original</a>
    <h1>Public secrets exposure leads to supply chain attack on GitHub CodeQL</h1>
    
    <div id="readability-page-1" class="page"><div data-id="887d2a1" data-element_type="container">
				<div data-id="7d4cb30" data-element_type="widget" data-widget_type="theme-post-content.default">
				<div>
					
<p>A potential supply chain attack on GitHub CodeQL started simply: a publicly exposed secret, valid for 1.022 seconds at a time.</p>



<p>In that second, an attacker could take a series of steps that would allow them to execute code within a GitHub Actions workflow in most repositories using CodeQL, GitHub’s code analysis engine trusted by hundreds of thousands of repositories. The impact would reach both public GitHub (GitHub Cloud) and GitHub Enterprise.</p>



<p>If backdooring GitHub Actions sounds familiar, that’s because it’s exactly what threat actors did in the recent tj-actions/changed-files supply chain attack. Imagine that very same supply chain attack, but instead of backdooring actions in tj-actions, they backdoored actions in GitHub CodeQL.</p>



<p>An attacker could use this to:</p>



<ol>
<li><strong>Compromise intellectual property</strong> by exfiltrating the source code of private repositories using CodeQL.</li>



<li><strong>Steal credentials within GitHub Actions secrets</strong> of workflow jobs using CodeQL and leverage those secrets to execute further supply chain attacks.</li>



<li><strong>Execute code on internal infrastructure</strong> running CodeQL workflows.</li>



<li><strong>Compromise GitHub Actions secrets</strong> of workflows using the GitHub Actions Cache within a repo that uses CodeQL.</li>
</ol>



<p>This is the story of how we uncovered an exposed secret leading to a race condition, a potential supply chain attack, and CVE-2025-24362.</p>



<p><em>Note: Per <a href="https://github.com/advisories/GHSA-vqf5-2xx6-9wfm" target="_blank" rel="noreferrer noopener">GitHub’s advisory</a>, they have found no evidence of compromise to its platform or systems.</em></p>



<h2>How Did We Get Here?</h2>



<p>In January 2025, I took a break from Praetorian’s <a href="https://www.praetorian.com/services/red-team/">Red Team</a> and began three months of research. I aimed to push the limits of public GitHub Actions exploitation, building on presentations we’ve given at <a href="https://johnstawinski.com/wp-content/uploads/2024/08/us24-khan-stawinski-self-hosted-github-cicd-runners-continuous-integration-continuous-destruction.pdf" target="_blank" rel="noreferrer noopener">Black Hat</a>, <a href="https://www.youtube.com/watch?v=5P7KatZBr_I" target="_blank" rel="noreferrer noopener">DEF CON</a>, <a href="https://www.praetorian.com/blog/introducing-gato-for-ci-cd-exploitation/">Schmoocon</a>, and Black Hat Arsenal. Tools and takeaways from this research will be implemented in our <a href="https://www.praetorian.com/services/ci-cd-security-engagement/">CI/CD Professional Services Engagements</a>, and into <a href="https://www.praetorian.com/chariot/">Chariot</a>, our Continuous Threat Exposure Management platform.</p>



<p>I began my research rotation by scanning GitHub Actions workflow artifacts for secrets.</p>



<h2>Secret Scanning</h2>



<p>In August 2024, Palo Alto researcher Yaron Avital <a href="https://unit42.paloaltonetworks.com/github-repo-artifacts-leak-tokens/" target="_blank" rel="noreferrer noopener">published an article</a> about identifying secrets in workflow artifacts. I had a hunch that there were still secrets to be found, especially since there hadn’t been much public follow-up work since the article.</p>



<p>I built a simple Actions Artifacts Secret Scanner to get started. It downloads artifacts from GitHub Actions workflows, recursively extracts their contents, and scans their contents for secrets with <a href="https://github.com/praetorian-inc/noseyparker">Nosey Parker</a>, Praetorian’s open-sourced secrets scanning tool.</p>



<p>The Actions Artifacts Secret Scanner has been integrated into Chariot and open-sourced as a <a href="https://github.com/praetorian-inc/gato">Gato</a> capability.</p>



<p>After running this scanner for one day, it found a secret that could lead to a supply chain attack on GitHub CodeQL.</p>



<p>But first, I needed to see if the key was usable.</p>



<h2>Background</h2>



<p>CI/CD vulnerabilities sound complicated until you understand the terminology. Let’s catch you up.</p>



<p>GitHub Actions is a continuous integration and continuous delivery (CI/CD) platform that allows the execution of code specified within workflows as part of the CI/CD process. When you push code to a GitHub repository or create a pull request, GitHub Actions can automatically build, test, and deploy your code using workflows defined in YAML files.</p>



<p>For example, let’s say you are building a web application that is hosted in AWS. You can configure a GitHub Actions workflow so that whenever you push code to your repository, it is automatically tested and then deployed to AWS.</p>



<p><em>If you are new to GitHub Actions, we’d recommend reading through <a href="https://docs.github.com/en/actions/writing-workflows/quickstart" target="_blank" rel="noreferrer noopener">some examples</a>.</em></p>



<p><strong><em>Every workflow run generates a GITHUB_TOKEN</em></strong> — a special, automatically generated GitHub App installation token that allows the workflow to interact with the repository. This token’s permissions can be configured in the workflow file, at the repository level, or at the org level, determining what actions it can perform within the repository.</p>



<p>Put simply:</p>



<ul>
<li>GitHub workflows execute on GitHub runners (typically a VM or Docker containers).</li>



<li>GitHub runners need a way to authenticate to GitHub to do stuff the workflows tell them to do.</li>



<li>For that purpose, they use the GITHUB_TOKEN.</li>
</ul>







<h3>What are Workflow Artifacts?</h3>



<p>We found the publicly exposed secret in a <a href="https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/storing-and-sharing-data-from-a-workflow" target="_blank" rel="noreferrer noopener">GitHub Actions workflow artifact</a>.</p>



<p>GitHub Actions workflows can upload workflow “artifacts” to GitHub Actions. Workflow artifacts can be any file and are saved by that workflow for later use. By default, artifacts are publicly accessible to anyone with read access to the repository and are stored for up to 90 days.</p>



<h3>And Finally, What is CodeQL?</h3>



<p><a href="https://codeql.github.com/" target="_blank" rel="noreferrer noopener">CodeQL</a> is GitHub’s Code Analysis Engine. The CodeQL actions perform static code analysis on GitHub repositories to try and identify vulnerabilities. They have found <a href="https://securitylab.github.com/codeql-wall-of-fame/" target="_blank" rel="noreferrer noopener">several hundred CVEs</a> over it’s lifetime, protecting organizations from breaches.</p>



<p>Security tools, like CodeQL, often need access to sensitive systems and data, making them an attractive target to an attacker.</p>



<p>If CodeQL was compromised, one of the most widely used security tools now becomes a backdoor.</p>



<h2>Finding the Token</h2>



<p>After running the Actions Artifact Secrets Scanner for a day, it picked up a token in a <a href="https://github.com/github/codeql-action">github/</a><a href="https://github.com/github/codeql-action" target="_blank" rel="noreferrer noopener">codeql-action</a> repository artifact published by <a href="https://github.com/github/codeql-action/actions/runs/12901573957">this </a><a href="https://github.com/github/codeql-action/actions/runs/12901573957" target="_blank" rel="noreferrer noopener">run</a>. The Actions Artifact Secrets Scanner downloaded the “my-debug-artifacts” zip uploaded by the “<a href="https://github.com/github/codeql-action/blob/f89b8a7d5239ba6d1a0f243ead94ea9ca5775ae1/.github/workflows/debug-artifacts-failure.yml">PR Check – Debug </a><a href="https://github.com/github/codeql-action/blob/f89b8a7d5239ba6d1a0f243ead94ea9ca5775ae1/.github/workflows/debug-artifacts-failure.yml" target="_blank" rel="noreferrer noopener">artifacts</a><a href="https://github.com/github/codeql-action/blob/f89b8a7d5239ba6d1a0f243ead94ea9ca5775ae1/.github/workflows/debug-artifacts-failure.yml"> after failure</a>” workflow, recursively extracted the “my-db-java-partial.zip” file stored inside, and ran Nosey Parker. Within seconds, Nosey Parker flagged a GitHub Token starting with “ghs_” in a crash report.</p>



<figure><picture fetchpriority="high" decoding="async">
<source type="image/webp" data-lazy-srcset="https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.37.56-1024x443.png.webp 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.37.56-300x130.png.webp 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.37.56-768x332.png.webp 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.37.56.png.webp 1072w" sizes="(max-width: 1024px) 100vw, 1024px"/>
<img fetchpriority="high" decoding="async" width="1024" height="443" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20viewBox=&#39;0%200%201024%20443&#39;%3E%3C/svg%3E" alt="Finding the Token" data-lazy-srcset="https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.37.56-1024x443.png 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.37.56-300x130.png 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.37.56-768x332.png 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.37.56.png 1072w" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-src="https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.37.56-1024x443.png"/>
</picture>
</figure>



<p><em>Investigating manually, I confirmed this was a GitHub App token installation token stored in a file containing the environment variables of the GitHub Runner executing the workflow.</em></p>



<h2>Investigating Impact</h2>



<p>Secrets compromise is cool, but what can we do with this token? The impact of a compromised</p>



<p>The easiest way to determine the privileges of a <em>GITHUB_TOKEN</em> is to look at workflow logs. To investigate this, I navigated to the “Setup Job” step of the workflow that uploaded the token.</p>



<figure><picture decoding="async">
<source type="image/webp" data-lazy-srcset="https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.42.13-1024x857.png.webp 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.42.13-300x251.png.webp 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.42.13-768x643.png.webp 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.42.13.png.webp 1364w" sizes="(max-width: 1024px) 100vw, 1024px"/>
<img decoding="async" width="1024" height="857" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20viewBox=&#39;0%200%201024%20857&#39;%3E%3C/svg%3E" alt="Investigating Impact" data-lazy-srcset="https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.42.13-1024x857.png 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.42.13-300x251.png 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.42.13-768x643.png 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.42.13.png 1364w" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-src="https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.42.13-1024x857.png"/>
</picture>
</figure>



<p><em><strong>The GitHub token had full write privileges.</strong></em></p>



<p>We could spend a lot of time talking about <a href="https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/controlling-permissions-for-github_token">each privilege</a>, but let’s focus on the ones that are particularly interesting.</p>



<p>Contents: write – Allows the token to create branches, create tags, and upload release artifacts.</p>



<p>With these privileges, an attacker has a lot of potential for repository tampering, but there is still one issue. These tokens are only valid for the duration of their specific workflow job. That means that once the job is over, the token is useless. Three things needed to happen for an attacker to be able to abuse this token:</p>



<ol>
<li>The token needs to have some sort of write privileges (already confirmed).</li>



<li>The token needs to use V4 of the upload artifact API, as that is the only version that allows you to retrieve an artifact before the job is complete (and after the job is complete, the token is invalid.)</li>



<li>The time between uploading the artifact and completing the job needs to be great enough for us to download, extract, and use the token.</li>
</ol>



<p>If all of these conditions are met, this publicly exposed token could be used to launch a full scale supply chain attack on CodeQL. This was like finding out that the security guard was accidentally leaving their master key in plain sight for a brief moment, over and over again.</p>



<p>We had to determine if the guard left us enough time to steal the key and use it before they returned to their post.</p>



<p>Let’s investigate further. Tick, tock.</p>



<h3>Determining the Artifact Upload Version</h3>



<p>Identifying the artifact upload version is typically straightforward. If a workflow uses</p>



<p>In this case, CodeQL wasn’t using the <a href="https://github.com/actions/upload-artifact" target="_blank" rel="noreferrer noopener">actions/upload-artifact</a> action; they were manually using the upload artifact client in the source code. Code comments indicated it used version 4. That was enough for me to continue.</p>



<p>Now we needed to determine if the job lasted long enough for us to retrieve and use the token.</p>



<h3>Calculating our Execution Time</h3>



<p>Looking at the raw GitHub logs for this workflow, we can see two key timestamps:</p>



<figure><picture decoding="async">
<source type="image/webp" data-lazy-srcset="https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.43.08-1024x221.png.webp 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.43.08-300x65.png.webp 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.43.08-768x166.png.webp 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.43.08.png.webp 1350w" sizes="(max-width: 1024px) 100vw, 1024px"/>
<img decoding="async" width="1024" height="221" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20viewBox=&#39;0%200%201024%20221&#39;%3E%3C/svg%3E" alt="Calculating our Execution Time" data-lazy-srcset="https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.43.08-1024x221.png 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.43.08-300x65.png 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.43.08-768x166.png 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.43.08.png 1350w" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-src="https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.43.08-1024x221.png"/>
</picture>
</figure>



<p>“Finalizing artifact upload” occurred at 17:22:09:888.</p>



<p>The final step in the job, “Cleaning up orphan processes”, happened at 17:22:10:911.</p>



<p>That means we had approximately 1.022 seconds to download the artifact, extract the GitHub token, and use it. I noticed the token stayed valid for about a second after the “Cleaning up orphan processes” step, so we’ll call it two seconds.</p>



<p>The guard was giving us two seconds to steal the key and use it before they returned.</p>



<h2>Start Your Engines</h2>



<p>To test this, I made a Python script <em>artifact_racer.py</em>. Artifact racer performs the following actions.</p>



<ol>
<li>Continuously queries the <em>github/codeql-action</em> GitHub repository until it sees a “PR Check – Debug artifacts after failure” workflow begin.</li>



<li>Monitors the running workflow for artifacts.</li>



<li>Once it sees a “PR Check – Debug artifacts after failure” workflow run, it downloads the artifact and extracts the <em>GITHUB_TOKEN</em>.
<ul>
<li>Shelling out for file operations and downloads was key to increasing the speed, although there are probably ways to make it even faster.</li>
</ul>
</li>



<li>Uses the <em>GITHUB_TOKEN</em> to make a new branch.</li>



<li>Use the <em>GITHUB_TOKEN</em> to push an empty file named <code>poc.txt</code> to that branch.</li>



<li><strong>Makes a new tag</strong> for that commit.</li>
</ol>



<p>If I could make a new branch, add a file, and create a tag for that commit, that would prove an attacker could use the token for nefarious purposes before it expired.</p>



<p>Given that the workflow artifact was only ~21MBs, I thought we had a chance. After successfully executing against a test repository, I moved on to the <a href="https://github.com/github/codeql-action">github/codeql-action</a> repository.</p>



<figure><img decoding="async" width="1024" height="429" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20viewBox=&#39;0%200%201024%20429&#39;%3E%3C/svg%3E" alt="" data-lazy-srcset="https://www.praetorian.com/wp-content/uploads/2025/03/image-11-1024x429.png 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/image-11-300x126.png 300w, https://www.praetorian.com/wp-content/uploads/2025/03/image-11-768x322.png 768w, https://www.praetorian.com/wp-content/uploads/2025/03/image-11-1536x644.png 1536w, https://www.praetorian.com/wp-content/uploads/2025/03/image-11.png 1728w" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-src="https://www.praetorian.com/wp-content/uploads/2025/03/image-11-1024x429.png"/></figure>







<h2>Executing the Proof of Concept</h2>



<p>I ran the racer.</p>



<p>And then I waited.</p>



<p>About two hours later, a “PR Check – Debug artifacts after failure” workflow executed. The racer successfully retrieved the <em>GITHUB_TOKEN</em>, created the branch, pushed the file, and added the tag.</p>



<figure><picture loading="lazy" decoding="async">
<source type="image/webp" data-lazy-srcset="https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.00-1024x586.png.webp 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.00-300x172.png.webp 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.00-768x440.png.webp 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.00.png.webp 1300w" sizes="(max-width: 1024px) 100vw, 1024px"/>
<img decoding="async" width="1024" height="586" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20viewBox=&#39;0%200%201024%20586&#39;%3E%3C/svg%3E" alt="Executing the Proof of Concept" data-lazy-srcset="https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.00-1024x586.png 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.00-300x172.png 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.00-768x440.png 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.00.png 1300w" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-src="https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.00-1024x586.png"/>
</picture>
</figure>



<p>Branch URL: <a href="https://github.com/github/codeql-action/tree/testpoc" target="_blank" rel="noreferrer noopener">https://github.com/github/codeql-action/tree/testpoc</a></p>



<figure><picture loading="lazy" decoding="async">
<source type="image/webp" data-lazy-srcset="https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.20-1024x516.png.webp 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.20-300x151.png.webp 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.20-768x387.png.webp 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.20.png.webp 1414w" sizes="(max-width: 1024px) 100vw, 1024px"/>
<img decoding="async" width="1024" height="516" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20viewBox=&#39;0%200%201024%20516&#39;%3E%3C/svg%3E" alt="New tag created" data-lazy-srcset="https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.20-1024x516.png 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.20-300x151.png 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.20-768x387.png 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.20.png 1414w" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-src="https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.45.20-1024x516.png"/>
</picture>
</figure>



<p><em>The ability to create a tag becomes very important in this attack. Keep that in mind as we go.</em></p>



<p>After confirming the <em>GITHUB_TOKEN</em> could be used within the short time window, we responsibly disclosed this vulnerability to GitHub.</p>



<h2>What if You’re Still Not Impressed?</h2>



<p><strong>Using the GITHUB_TOKEN, an attacker could add malicious code to any unprotected branch</strong>. A covert tactic would be to target feature branches pre-merge, smuggle in a small malicious code change, and wait for it to get merged. This would be especially effective due to how frequently the GitHub Actions bot commits to the CodeQL Actions repository.</p>



<p>They could also add tags that point to specific commits. For example, if they had malicious code on a branch and then added a v3 tag, anyone who manually used codeql-action…@v3 would execute the malicious code. <strong>More on this later</strong>.</p>



<p>Through code execution, you’d be able to compromise any GitHub Actions secret used within that job, as well as exfiltrate the source code of that repository. If their actions were executing on internal infrastructure, which is common with <a href="https://www.praetorian.com/blog/self-hosted-github-runners-are-backdoors/">self-hosted GitHub runners</a>, you’d also have code execution on their internal network or cloud environment.</p>



<p><strong>The impact from this attack would have been very similar to the recent tj-actions/changed-files supply chain attack.</strong></p>



<p><strong>T</strong>his impact is impressive, but it doesn’t quite live up to the claims I made in the beginning. Yes, through these paths, they could launch a supply chain attack against repos manually using the CodeQL actions. However, most organizations don’t include these actions manually. They just go into their repository settings, click “Enable CodeQL”, and go from there.</p>



<p>At first, I assumed that enabling CodeQL in your repository didn’t interact with the github/codeql-action repository at all.</p>



<p><strong><em>I was wrong.</em></strong></p>



<h2>Exponential Impact</h2>



<p>After discussing this issue with some colleagues, I decided to investigate further. What actually happens when you enable CodeQL?</p>



<p><strong>This section is key to understanding the full impact of this vulnerability.</strong> Stick with me.</p>



<p>To investigate, I created my own public repository, “John’s Top Secret Repo”, and enabled CodeQL.</p>



<p>After you enable CodeQL with the default settings, a special GitHub Actions workflow runs in your repository. This CodeQL action won’t show up in your repository workflows, but you can navigate to the workflow logs to see what it is doing.</p>



<figure><picture loading="lazy" decoding="async">
<source type="image/webp" data-lazy-srcset="https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.46.57-1024x422.png.webp 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.46.57-300x124.png.webp 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.46.57-768x317.png.webp 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.46.57.png.webp 1174w" sizes="(max-width: 1024px) 100vw, 1024px"/>
<img decoding="async" width="1024" height="422" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20viewBox=&#39;0%200%201024%20422&#39;%3E%3C/svg%3E" alt="" data-lazy-srcset="https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.46.57-1024x422.png 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.46.57-300x124.png 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.46.57-768x317.png 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.46.57.png 1174w" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-src="https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.46.57-1024x422.png"/>
</picture>
</figure>



<p><em>Enabling CodeQL in your repository settings.</em></p>



<figure><picture loading="lazy" decoding="async">
<source type="image/webp" data-lazy-srcset="https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.12-1024x522.png.webp 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.12-300x153.png.webp 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.12-768x391.png.webp 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.12.png.webp 1378w" sizes="(max-width: 1024px) 100vw, 1024px"/>
<img decoding="async" width="1024" height="522" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20viewBox=&#39;0%200%201024%20522&#39;%3E%3C/svg%3E" alt="CodeQL Setup" data-lazy-srcset="https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.12-1024x522.png 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.12-300x153.png 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.12-768x391.png 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.12.png 1378w" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-src="https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.12-1024x522.png"/>
</picture>
</figure>



<p><em>Observing the CodeQL workflow.</em></p>



<p>Based on my observations, CodeQL:</p>



<ol>
<li>Checks out your repository to the filesystem</li>



<li>Initializes CodeQL</li>



<li>Runs CodeQL scans</li>



<li>Uploads the scan results</li>
</ol>



<figure><picture loading="lazy" decoding="async">
<source type="image/webp" data-lazy-srcset="https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.31-1024x979.png.webp 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.31-300x287.png.webp 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.31-768x735.png.webp 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.31.png.webp 1240w" sizes="(max-width: 1024px) 100vw, 1024px"/>
<img decoding="async" width="1024" height="979" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20viewBox=&#39;0%200%201024%20979&#39;%3E%3C/svg%3E" alt="CodeQL" data-lazy-srcset="https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.31-1024x979.png 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.31-300x287.png 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.31-768x735.png 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.31.png 1240w" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-src="https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.31-1024x979.png"/>
</picture>
</figure>



<p>Let’s take a closer look at step 3.</p>



<figure><picture loading="lazy" decoding="async">
<source type="image/webp" data-lazy-srcset="https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.39-1024x230.png.webp 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.39-300x67.png.webp 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.39-768x173.png.webp 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.39.png.webp 1210w" sizes="(max-width: 1024px) 100vw, 1024px"/>
<img decoding="async" width="1024" height="230" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20viewBox=&#39;0%200%201024%20230&#39;%3E%3C/svg%3E" alt="step 3." data-lazy-srcset="https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.39-1024x230.png 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.39-300x67.png 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.39-768x173.png 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.39.png 1210w" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-src="https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.47.39-1024x230.png"/>
</picture>
</figure>



<p>If this doesn’t shock you, look again. Remember that we have the ability to push tags to the <em>github/codeql-action</em> repository.</p>



<p>CodeQL, under the hood, is executing the actions in the <em>github/codeql-action</em> repository, using the commit referenced by the <em>v3</em> tag. This tag was not immutable, and they were not using <a href="https://docs.github.com/en/actions/security-for-github-actions/security-guides/security-hardening-for-github-actions">workflow pinning</a> (which GitHub recommends), which meant that an attacker could overwrite the v3 tag using the compromised <em>GITHUB_TOKEN</em>. Now, if an attacker removed and then added a v3 tag to their malicious commit, every single repository using the default CodeQL workflow would execute their malicious code.</p>



<figure><picture loading="lazy" decoding="async">
<source type="image/webp" data-lazy-srcset="https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.48.37-1024x237.png.webp 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.48.37-300x69.png.webp 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.48.37-768x178.png.webp 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.48.37.png.webp 1194w" sizes="(max-width: 1024px) 100vw, 1024px"/>
<img decoding="async" width="1024" height="237" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20viewBox=&#39;0%200%201024%20237&#39;%3E%3C/svg%3E" alt="CodeQL" data-lazy-srcset="https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.48.37-1024x237.png 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.48.37-300x69.png 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.48.37-768x178.png 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.48.37.png 1194w" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-src="https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-04-17.48.37-1024x237.png"/>
</picture>
</figure>



<p><em>The Action created when selecting “Advanced CodeQL” also used the reusable github/codeql-action with the v3 tag.</em></p>



<p>The CodeQL actions check out the source code of every repository they run on, which means that a malicious CodeQL action could exfiltrate the source code of any repository using default CodeQL configurations.</p>



<p>This would result in significant disclosure of intellectual property. And if you’ve ever operated on a Red Team, you know how many hardcoded secrets are lying around in private source code repositories.</p>



<h2>But Wait, There’s More</h2>



<p>We’re almost done. But remember, I promised one more thing:</p>



<p><em>4. Compromise GitHub Actions secrets of any workflow using the GitHub Actions Cache within a repo that uses CodeQL</em></p>



<p>When assessing the impact of CI/CD attack paths, I look for ways to compromise GitHub Actions secrets. Usually, those secrets are where the crown jewels live.</p>



<p>If the CodeQL action is executing with write privileges or alongside GitHub Actions secrets, then it’s trivial to use the code execution to exfiltrate those secrets. But the default CodeQL action uses a <em>GITHUB_TOKEN</em> that only has read privileges, so you can’t perform repository write operations, backdoor releases, or use fancy workflow dispatch events to steal secrets, <a href="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/">like what happened with</a><a href="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/" target="_blank" rel="noreferrer noopener"> </a><a href="https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/">PyTorch</a>.</p>



<p>What the default CodeQL action <em>does</em> do is execute in the main branch of the repository. The main branch of any GitHub repository can write cache entries that will be used by the entire repo. This opens up an opportunity to conduct <strong>GitHub Actions cache poisoning</strong>.</p>



<p>GitHub Actions Cache Poisoning is thoroughly explained <a href="https://adnanthekhan.com/2024/05/06/the-monsters-in-your-build-cache-github-actions-cache-poisoning/">in this </a><a href="https://adnanthekhan.com/2024/05/06/the-monsters-in-your-build-cache-github-actions-cache-poisoning/" target="_blank" rel="noreferrer noopener">article</a> by Adnan Khan, which documents the discovery and exploitation of cache poisoning. The easiest way to conduct GitHub Actions cache poisoning is by deploying <a href="https://github.com/AdnaneKhan/Cacheract" target="_blank" rel="noreferrer noopener">Cacheract</a>, malware that persists in a build pipeline through cache poisoning.</p>



<p>If an attacker deployed Cacheract in the CodeQL workflow, it would:</p>



<ol>
<li>Predict cache entries</li>



<li>Overwrite these entries with a malicious action</li>



<li>Gain code execution within any workflow that uses <code>action-cache</code> (the Actions Cache is used by most repositories)</li>



<li><strong>Leverage code execution to compromise GitHub Actions secrets used by those workflows, capture privileged GITHUB_TOKENs, and more</strong></li>
</ol>



<p>Even if someone noticed the malicious CodeQL action and remediated the vulnerability, Cacheract would continue poisoning caches.</p>



<p>I spent ten minutes looking for prominent repos that use CodeQL &amp; actions/cache and identified</p>



<p>Cache poisoning would allow an attacker to leverage this CodeQL supply chain attack to gain write access to repositories and repository secrets.</p>



<h2>Congratulations, You Made It</h2>



<p>We’ve now hit all the impact highlights I mentioned at the beginning:</p>



<ol>
<li>Compromise intellectual property by exfiltrating the source code of all private repositories using CodeQL.</li>



<li>Steal credentials within GitHub Actions secrets of any workflow job using CodeQL, and leverage those secrets to execute further supply chain attacks.</li>



<li>Execute code on internal infrastructure running CodeQL workflows.</li>



<li>Compromise GitHub Actions secrets of any workflow using the GitHub Actions Cache within a repo that uses CodeQL.</li>
</ol>



<figure><picture loading="lazy" decoding="async">
<source type="image/webp" data-lazy-srcset="https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-15-11.23.53-1024x351.png.webp 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-15-11.23.53-300x103.png.webp 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-15-11.23.53-768x263.png.webp 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-15-11.23.53-1536x526.png.webp 1536w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-15-11.23.53-2048x701.png.webp 2048w" sizes="(max-width: 1024px) 100vw, 1024px"/>
<img decoding="async" width="1024" height="351" src="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20viewBox=&#39;0%200%201024%20351&#39;%3E%3C/svg%3E" alt="Congratulations, You Made It" data-lazy-srcset="https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-15-11.23.53-1024x351.png 1024w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-15-11.23.53-300x103.png 300w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-15-11.23.53-768x263.png 768w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-15-11.23.53-1536x526.png 1536w, https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-15-11.23.53-2048x701.png 2048w" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-src="https://www.praetorian.com/wp-content/uploads/2025/03/Box-Notes-Image-2025-02-15-11.23.53-1024x351.png"/>
</picture>
</figure>



<p>Supply chain attacks like these are scary, especially when they start with something as simple as a publicly exposed credential. If this is your first time hearing about abusing GitHub Actions to launch supply chain attacks, I’ll let you in on a secret: <a href="https://www.praetorian.com/blog/tensorflow-supply-chain-compromise-via-self-hosted-runner-attack/">these vulnerabilities</a> <a href="https://www.praetorian.com/blog/compromising-bytedances-rspack-github-actions-vulnerabilities/">occur</a> <a href="https://johnstawinski.com/2024/01/05/worse-than-solarwinds-three-steps-to-hack-blockchains-github-and-ml-through-github-actions/">all </a><a href="https://johnstawinski.com/2024/01/05/worse-than-solarwinds-three-steps-to-hack-blockchains-github-and-ml-through-github-actions/" target="_blank" rel="noreferrer noopener">the</a><a href="https://johnstawinski.com/2024/01/05/worse-than-solarwinds-three-steps-to-hack-blockchains-github-and-ml-through-github-actions/"> time</a>.</p>



<p>GitHub Actions abuse has been around for several years, but it is still one of the highest-impact, least-understood vulnerability classes. That is slowly starting to change (emphasis on ~slowly~). The DevOps and security communities need to commit to learning about these vulnerabilities to protect their organizations from risk. Vulnerabilities like this, and the recent tj-actions/changed-files supply chain attack, are starting to bring these issues to the public spotlight. That is why we invest in research to uncover these vulnerabilities and design solutions to prevent them.</p>



<h2>CVE-2025-24362</h2>



<p>A side-effect of this disclosure was <a href="https://github.com/advisories/GHSA-vqf5-2xx6-9wfm">CVE-2025-24362</a>. The publicly exposed <em>GITHUB_TOKEN</em> was within a debug artifact uploaded by the CodeQL Action after a failed code scanning workflow. The CodeQL Actions repository was intentionally triggering this failure, but other users of CodeQL Actions could have exposed their own secrets as environment variables to the workflow, had their workflows experienced a similar failure.</p>



<p><strong>This issue was fixed in CodeQL Action version 3.28.3.</strong></p>



<p>Even though this disclosure resulted in a CVE, the highest potential impact still lies in exploiting that vulnerability against the CodeQL Actions repository and launching a supply chain attack against CodeQL users.</p>



<h2>Remediation</h2>



<p>GitHub had one of the most rapid and impressive remediation responses we have ever seen.</p>



<p>Jan 22, 2025, 3:13 PM UTC: Report Submitted to GitHub</p>



<p>If you are concerned about you’re own GitHub Actions workflow artifacts, you can take the following steps to limit the risk of secrets exposure:</p>



<ul>
<li>ideally, only upload specific files or directories as workflow artifacts</li>



<li>avoid uploading artifacts containing environment variables, the <code>.git/config</code> file, or any files in the runner’s <code>&lt;path_to_runner_dir&gt;/_work/_temp/</code> directory</li>



<li>limit GITHUB_TOKEN permissions to read-only</li>



<li>scan artifacts for secrets prior to uploading</li>
</ul>



<p>To learn more about this vulnerability, how I discovered it, and how you can detect similar vulnerabilities in your own environment, <a href="https://www.praetorian.com/resources/unpacking-codeqleaked-a-potential-supply-chain-attack-on-github-codeql/">please join me for a webinar</a> on April 10 at 1pm ET.</p>



<h2>How Can Praetorian Help</h2>



<p>Praetorian has been leading the charge in offensive CI/CD security for several years, inventing novel <a href="https://github.com/praetorian-inc/gato" target="_blank" rel="noreferrer noopener">tooling</a> and giving presentations at Black Hat, DEF CON, Schmoocon, and Black Hat Arsenal.</p>



<p>Our <strong><a href="https://www.praetorian.com/continuous-threat-exposure-management/">Continuous Threat Exposure Management (CTEM)</a></strong> platform, Chariot, can identify vulnerabilities like this in your attack surface before the attackers do.</p>



<p>Our CI/CD Security Assessments can take an in-depth look at your internal CI/CD security posture, enumerating attack paths that an attacker would exploit to go from low-privileged access to complete organization compromise.</p>



<p>The next major supply chain attack could start with something as simple as a publicly exposed secret. Help make sure that doesn’t happen by learning about CI/CD vulnerabilities and implementing continuous controls to protect your organization from compromise.</p>



<p><strong>You can <a href="http://future.chariot.praetorian.com/">create a free</a> Chariot account anytime. Alternatively, if you’re interested in our managed Chariot offering, <a href="https://www.praetorian.com/contact-us/">reach out to speak with our team</a>.</strong></p>




				</div>
				</div>
				</div></div>
  </body>
</html>
