<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hoverbear.org/blog/rust-state-machine-pattern/">Original</a>
    <h1>Pretty State Machine Patterns in Rust</h1>
    
    <div id="readability-page-1" class="page"><article>
    <p>Lately I&#39;ve been thinking a lot about the <em>patterns</em> and <em>structures</em> which we program with. It&#39;s really wonderful to start exploring a project and see familiar patterns and styles which you&#39;ve already used before. It makes it easier to understand the project, and empowers you to start working on the project faster.</p>
<p>Sometimes you&#39;re working on a new project and realize that you need to do something in the same way as you did in another project. This <em>thing</em> might not be a functionality or a library, it might not be something which you can encode into some clever macro or small crate. Instead, it may be simply a pattern, or a structural concept which addresses a problem nicely.</p>
<p>One interesting pattern that is commonly applied to problems is that of the &#39;State Machine&#39;. Let&#39;s take some time to consider what exactly we mean when we say that, and why they&#39;re interesting.</p>
<span id="continue-reading"></span>
<blockquote>
<p>Throughout this post you can run all examples in <a rel="noopener" target="_blank" href="https://play.rust-lang.org/">the playground</a>, I typically use &#39;Nightly&#39; out of habit.</p>
</blockquote>
<h2 id="founding-our-concepts"><a href="#founding-our-concepts" aria-label="Anchor link for: founding-our-concepts">Founding Our Concepts</a></h2>
<p>There are a <strong>lot</strong> of resources and topical articles about state machines out there on the internet. Even more so, there are a lot of <strong>implementations</strong> of state machines.</p>
<p>Just to get to this web page you used one. You can model TCP as a state machine. You can model HTTP requests with one too. You can model any <em>regular</em> language, such as a regex, as a state machine. They&#39;re everywhere, hiding inside things we use every day.</p>
<p>So, a State Machine is any <strong>&#39;machine&#39;</strong> which has a set of <strong>&#39;states&#39;</strong> and <strong>&#39;transitions&#39;</strong> defined between them.</p>
<p>When we talk about a machine we&#39;re referring to the abstract concept of something which <em>does something</em>. For example, your &#39;Hello World!&#39; function is a machine. It is started and eventually outputs what we expect it to. Some model which you use to interact with your database is just the same. We&#39;ll regard our most basic machine simply as a <code>struct</code> that can be created and destroyed.</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>struct</span> </span><span><span>Machine</span></span><span>;</span>
</span><span>
</span><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>  <span>let</span> my_machine <span>=</span> Machine<span>;</span> </span></span></span><span><span><span>  </span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>States are a way to reason about <em>where</em> a machine is in its process. For example, we can think about a bottle filling machine as an example. The machine is in a &#39;waiting&#39; state when it is waiting for a new bottle. Once it detects a bottle it moves to the &#39;filling&#39; state. Upon detecting the bottle is filled it enters the &#39;done&#39; state. After the bottle is left the machine we return to the &#39;waiting&#39; state.</p>
<p>A key takeaway here is that none of the states have any information relevant for the other states. The &#39;filling&#39; state doesn&#39;t care how long the &#39;waiting&#39; state waited. The &#39;done&#39; state doesn&#39;t care about what rate the bottle was filled at. Each state has <em>discrete responsibilities and concerns</em>. The natural way to consider these <em>variants</em> is as an <code>enum</code>.</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>enum</span> <span>BottleFillerState</span> <span><span>{</span>
</span></span></span><span><span><span>  Waiting <span><span>{</span> waiting_time<span>:</span> <span>std<span>::</span></span><span>time<span>::</span></span>Duration </span><span><span>}</span></span><span>,</span>
</span></span></span><span><span><span>  Filling <span><span>{</span> rate<span>:</span> <span>usize</span> </span><span><span>}</span></span><span>,</span>
</span></span></span><span><span><span>  Done<span>,</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span>struct</span> </span><span><span>BottleFiller</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>  <span>state</span><span>:</span> BottleFillerState,
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>Using an <code>enum</code> in this way means all the states are mutually exclusive, you can only be in one at a time. Rust&#39;s &#39;fat enums&#39; allow us to have each of these states to carry data with them as well. As far as our current definition is concerned, everything is totally okay.</p>
<p>But there is a bit of a problem here. When we described our bottle filling machine above we described three transitions: <code>Waiting -&gt; Filling</code>, <code>Filling -&gt; Done</code>, and <code>Done -&gt; Waiting</code>. We never described <code>Waiting -&gt; Done</code> or <code>Done -&gt; Filling</code>, those don&#39;t make sense!</p>
<p>This brings us to the idea of transitions. One of the nicest things about a true state machine is we never have to worry about our bottle machine going from <code>Done -&gt; Filling</code>, for example. The state machine pattern should <strong>enforce</strong> that this can never happen. Ideally this would be done before we even start running our machine, at compile time.</p>
<p>Let&#39;s look again at the transitions we described for our bottle filler in a diagram:</p>
<pre><code><span>  +++++++++++   +++++++++++   ++++++++
</span><span>  |         |   |         |   |      |
</span><span>  | Waiting +--&gt;+ Filling +--&gt;+ Done |
</span><span>  |         |   |         |   |      |
</span><span>  ++++-++++-+   +++++++++++   +--+++++
</span><span>       ^                         |
</span><span>       +++++++++++++++++++++++++-+
</span></code></pre>
<p>As we can see here there are a finite number of states, and a finite number of transitions between these states. Now, it is possible to have a valid transition between each state and every other state, but in most cases this is not true.</p>
<p>This means moving between a state such as &#39;Waiting&#39; to a state such as &#39;Filling&#39; should have defined semantics. In our example this can be defined as &#34;There is a bottle in place.&#34; In the case of a TCP stream it might be &#34;We have received a FIN packet&#34; which means we need to finish closing out the stream.</p>
<h2 id="determining-what-we-want"><a href="#determining-what-we-want" aria-label="Anchor link for: determining-what-we-want">Determining What We Want</a></h2>
<p>Now that we know what a state machine is, how do we represent them in Rust? First, let&#39;s think about what we <strong>want</strong> from some pattern.</p>
<p>Ideally, we&#39;d like to see the following characteristics:</p>
<ul>
<li>Can only be in one state at a time.</li>
<li>Each state should have its own associated values if required.</li>
<li>Transitioning between states should have well defined semantics.</li>
<li>It should be possible to have some level of shared state.</li>
<li>Only explicitly defined transitions should be permitted.</li>
<li>Changing from one state to another should <strong>consume</strong> the state so it can no longer be used.</li>
<li>We shouldn&#39;t need to allocate memory for <strong>all</strong> states. No more than largest sized state certainly</li>
<li>Any error messages should be easy to understand.</li>
<li>We shouldn&#39;t need to resort to heap allocations to do this. Everything should be possible on the stack.</li>
<li>The type system should be harnessed to our greatest ability.</li>
<li>As many errors as possible should be at <strong>compile-time</strong>.</li>
</ul>
<p>So if we could have a design pattern which allowed for all these things it&#39;d be truly fantastic. Having a pattern which allowed for most would be pretty good too.</p>
<h2 id="exploring-possible-implementation-options"><a href="#exploring-possible-implementation-options" aria-label="Anchor link for: exploring-possible-implementation-options">Exploring Possible Implementation Options</a></h2>
<p>With a type system as powerful and flexible as Rusts we should be able to represent this. The truth is: there are a number of ways to try, each has valuable characteristics, and each teaches us lessons.</p>
<h3 id="a-second-shot-with-enums"><a href="#a-second-shot-with-enums" aria-label="Anchor link for: a-second-shot-with-enums">A Second Shot with Enums</a></h3>
<p>As we saw above the most natural way to attempt this is an <code>enum</code>, but we noted already that you can&#39;t control which transitions are actually permitted in this case. So can we just wrap it? We sure can! Let&#39;s take a look:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>enum</span> <span>State</span> <span><span>{</span>
</span></span></span><span><span><span>    Waiting <span><span>{</span> waiting_time<span>:</span> <span>std<span>::</span></span><span>time<span>::</span></span>Duration </span><span><span>}</span></span><span>,</span>
</span></span></span><span><span><span>    Filling <span><span>{</span> rate<span>:</span> <span>usize</span> </span><span><span>}</span></span><span>,</span>
</span></span></span><span><span><span>    Done
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span>struct</span> </span><span><span>StateMachine</span> </span><span><span><span>{</span> <span>state</span><span>:</span> State </span><span><span>}</span></span></span>
</span><span>
</span><span><span><span>impl</span> </span><span><span>StateMachine</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span><span>fn</span> </span><span>new</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>Self</span></span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        StateMachine <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            state<span>:</span> <span>State<span>::</span></span>Waiting <span><span>{</span> waiting_time<span>:</span> <span>std<span>::</span></span><span>time<span>::</span></span><span>Duration<span>::</span></span>new<span><span>(</span><span>0</span><span>,</span> <span>0</span></span><span><span>)</span></span> </span><span><span>}</span></span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span>    <span><span><span>fn</span> </span><span>to_filling</span></span><span><span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        <span>self</span><span>.</span>state <span>=</span> <span>match</span> <span>self</span><span>.</span>state <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            </span></span></span></span></span></span><span><span><span><span><span><span>            <span>State<span>::</span></span>Waiting <span><span>{</span> <span>..</span> </span><span><span>}</span></span> <span>=&gt;</span> <span>State<span>::</span></span>Filling <span><span>{</span> rate<span>:</span> <span>1</span> </span><span><span>}</span></span><span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            </span></span></span></span></span></span><span><span><span><span><span><span>            <span>_</span> <span>=&gt;</span> <span>panic!</span><span><span>(</span><span><span>&#34;</span>Invalid state transition!<span>&#34;</span></span></span><span><span>)</span></span><span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span>    </span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>let</span> <span>mut</span> state_machine <span>=</span> <span>StateMachine<span>::</span></span>new<span><span>(</span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    state_machine<span>.</span><span>to_filling</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>At first glance it seems okay. But notice some problems?</p>
<ul>
<li>Invalid transition errors happen at runtime, which is awful!</li>
<li>This only prevents invalid transitions <em>outside</em> of the module, since the private fields can be manipulated freely inside the module. For example, <code>state_machine.state = State::Done</code> is perfectly valid inside the module.</li>
<li>Every function we implement that works with the state has to include a match statement!</li>
</ul>
<p>However this does have some good characteristics:</p>
<ul>
<li>The memory required to represent the state machine is only the size of the largest state. This is because a fat enum is only as big as its biggest variant.</li>
<li>Everything happens on the stack.</li>
<li>Transitioning between states has well defined semantics... It either works or it crashes!</li>
</ul>
<p>Now you might be thinking &#34;Hoverbear you could totally wrap the <code>to_filling()</code> output with a <code>Result&lt;T,E&gt;</code> or have an <code>InvalidState</code> variant!&#34; But let&#39;s face it: That doesn&#39;t make things that much better, if at all. Even if we get rid of the runtime failures we still have to deal with a lot of clumsiness with the match statements and our errors would still only be found at runtime! Ugh! We can do better, I promise.</p>
<p>So let&#39;s keep looking!</p>
<h3 id="structures-with-transitions"><a href="#structures-with-transitions" aria-label="Anchor link for: structures-with-transitions">Structures With Transitions</a></h3>
<p>So what if we just used a set of structs? We could have them all implement traits which all states should share. We could use special functions that transitioned the type into the new type! How would it look?</p>
<pre data-lang="rust"><code data-lang="rust"><span></span><span><span><span>trait</span> <span>SharedFunctionality</span> <span><span>{</span>
</span></span></span><span><span><span>    <span><span><span>fn</span> </span><span>get_shared_value</span></span><span><span><span>(</span><span>&amp;</span><span>self</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>usize</span></span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span>struct</span> </span><span><span>Waiting</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>waiting_time</span><span>:</span> <span>std<span>::</span></span><span>time<span>::</span></span>Duration,
</span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>shared_value</span><span>:</span> <span>usize</span>,
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span><span><span>impl</span> </span><span><span>Waiting</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span><span>fn</span> </span><span>new</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>Self</span></span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        Waiting <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            waiting_time<span>:</span> <span>std<span>::</span></span><span>time<span>::</span></span><span>Duration<span>::</span></span>new<span><span>(</span><span>0</span><span>,</span><span>0</span></span><span><span>)</span></span><span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            shared_value<span>:</span> <span>0</span><span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    <span><span><span>fn</span> </span><span>to_filling</span></span><span><span><span>(</span><span>self</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> Filling</span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        Filling <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            rate<span>:</span> <span>1</span><span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            shared_value<span>:</span> <span>0</span><span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span><span><span>impl</span> </span><span>SharedFunctionality <span>for</span></span><span> <span>Waiting</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span><span>fn</span> </span><span>get_shared_value</span></span><span><span><span>(</span><span>&amp;</span><span>self</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>usize</span></span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        <span>self</span><span>.</span>shared_value
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span>struct</span> </span><span><span>Filling</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>rate</span><span>:</span> <span>usize</span>,
</span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>shared_value</span><span>:</span> <span>usize</span>,
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span><span><span>impl</span> </span><span>SharedFunctionality <span>for</span></span><span> <span>Filling</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span><span>fn</span> </span><span>get_shared_value</span></span><span><span><span>(</span><span>&amp;</span><span>self</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>usize</span></span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        <span>self</span><span>.</span>shared_value
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span></span><span>
</span><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>let</span> in_waiting_state <span>=</span> <span>Waiting<span>::</span></span>new<span><span>(</span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    <span>let</span> in_filling_state <span>=</span> in_waiting_state<span>.</span><span>to_filling</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>Gosh that&#39;s a buncha code! So the idea here was that all states have some common shared values along with their own specialized values. As you can see from the <code>to_filling()</code> function we can consume a given &#39;Waiting&#39; state and transition it into a &#39;Filling&#39; state. Let&#39;s do a little rundown:</p>
<ul>
<li>Transition errors are caught at compile time! For example you can&#39;t even create a <code>Filling</code> state accidentally without first starting with a <code>Waiting</code> state. (You could on purpose, but this is beside the matter.)</li>
<li>Transition enforcement happens everywhere.</li>
<li>When a transition between states is made the old value is <strong>consumed</strong> instead of just modified. We could have done this with the enum example above as well though.</li>
<li>We don&#39;t have to <code>match</code> all the time.</li>
<li>Memory consumption is still lean, at any given time the size is that of the state.</li>
</ul>
<p>There are some downsides though:</p>
<ul>
<li>There is a bunch of code repetition. You have to implement the same functions and traits for multiple structures.</li>
<li>It&#39;s not always clear what values are shared between all states and just one. Updating code later could be a pain due to this.</li>
<li>Since the size of the state is variable we end up needing to wrap this in an <code>enum</code> as above for it to be usable where the state machine is simply one component of a more complex system. Here&#39;s what this could look like:</li>
</ul>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>enum</span> <span>State</span> <span><span>{</span>
</span></span></span><span><span><span>    Waiting<span><span>(</span>Waiting</span><span><span>)</span></span><span>,</span>
</span></span></span><span><span><span>    Filling<span><span>(</span>Filling</span><span><span>)</span></span><span>,</span>
</span></span></span><span><span><span>    Done<span><span>(</span>Done</span><span><span>)</span></span><span>,</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>let</span> in_waiting_state <span>=</span> <span>State<span>::</span></span>Waiting<span><span>(</span><span>Waiting<span>::</span></span>new<span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>let</span> in_filling_state <span>=</span> <span>State<span>::</span></span>Filling<span><span>(</span>in_waiting_state<span>.</span><span>to_filling</span><span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>As you can see, this isn&#39;t very ergonomic. We&#39;re getting closer to what we want though. The idea of moving between distinct types seems to be a good way forward! Before we go try something entirely different though, let&#39;s talk about a simple way to change our example that could enlighten further thinking.</p>
<p>The Rust standard library defines two highly related traits: <a rel="noopener" target="_blank" href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> and <a rel="noopener" target="_blank" href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a> that are extremely useful and worth checking out. An important thing to note is that implementing one of these automatically implements the other. In general implementing <code>From</code> is preferable as it&#39;s a bit more flexible. We can implement them very easily for our above example like so:</p>
<pre data-lang="rust"><code data-lang="rust"><span></span><span><span><span>impl</span> </span><span><span><span>From</span><span>&lt;</span>Waiting<span>&gt;</span></span> <span>for</span></span><span> <span>Filling</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span><span>fn</span> </span><span>from</span></span><span><span><span>(</span><span>val</span><span>:</span> Waiting</span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> Filling</span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        Filling <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            rate<span>:</span> <span>1</span><span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            shared_value<span>:</span> val<span>.</span>shared_value<span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span></span></code></pre>
<p>Not only does this give us a common function for transitioning, but it also is nice to read about in the source code! This reduces mental burden on us and makes it easier for readers to comprehend. <em>Instead of implementing custom functions we&#39;re just using a pattern already existing.</em> Building our pattern on top of already existing patterns is a great way forward.</p>
<p>So this is cool, but how do we deal with all this nasty code repetition and the repeating <code>shared_value</code> stuff? Let&#39;s explore a bit more!</p>
<h3 id="generically-sophistication"><a href="#generically-sophistication" aria-label="Anchor link for: generically-sophistication">Generically Sophistication</a></h3>
<p>In this adventure we&#39;ll combine lessons and ideas from the first two, along with a few new ideas, to get something more satisfying. The core of this is to harness the power of generics. Let&#39;s take a look at a fairly bare structure representing this:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>struct</span> </span><span><span><span>BottleFillingMachine</span><span><span>&lt;</span>S<span>&gt;</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>shared_value</span><span>:</span> <span>usize</span>,
</span></span></span><span><span><span>    <span>state</span><span>:</span> S
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span></span><span>
</span><span><span><span>struct</span> </span><span><span>Waiting</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>waiting_time</span><span>:</span> <span>std<span>::</span></span><span>time<span>::</span></span>Duration,
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span>struct</span> </span><span><span>Filling</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>rate</span><span>:</span> <span>usize</span>,
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span>struct</span> </span><span><span>Done</span></span><span>;</span>
</span></code></pre>
<p>So here we&#39;re actually building the state into the type signature of the <code>BottleFillingMachine</code> itself. A state machine in the &#39;Filling&#39; state is <code>BottleFillingMachine&lt;Filling&gt;</code> which is just <strong>awesome</strong> since it means when we see it as part of an error message or something we know immediately what state the machine is in.</p>
<p>From there we can go ahead and implement <code>From&lt;T&gt;</code> for some of these specific generic variants like so:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>impl</span> </span><span><span><span>From</span><span>&lt;</span><span>BottleFillingMachine<span>&lt;</span>Waiting<span>&gt;</span></span><span>&gt;</span></span> <span>for</span></span><span> <span>BottleFillingMachine</span><span><span>&lt;</span>Filling<span>&gt;</span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span><span>fn</span> </span><span>from</span></span><span><span><span>(</span><span>val</span><span>:</span> <span>BottleFillingMachine<span>&lt;</span>Waiting<span>&gt;</span></span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>BottleFillingMachine<span>&lt;</span>Filling<span>&gt;</span></span></span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        BottleFillingMachine <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            shared_value<span>:</span> val<span>.</span>shared_value<span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            state<span>:</span> Filling <span><span>{</span>
</span></span></span></span></span></span></span><span><span><span><span><span><span><span>                rate<span>:</span> <span>1</span><span>,</span>
</span></span></span></span></span></span></span><span><span><span><span><span><span><span>            </span><span><span>}</span></span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span>impl</span> </span><span><span><span>From</span><span>&lt;</span><span>BottleFillingMachine<span>&lt;</span>Filling<span>&gt;</span></span><span>&gt;</span></span> <span>for</span></span><span> <span>BottleFillingMachine</span><span><span>&lt;</span>Done<span>&gt;</span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span><span>fn</span> </span><span>from</span></span><span><span><span>(</span><span>val</span><span>:</span> <span>BottleFillingMachine<span>&lt;</span>Filling<span>&gt;</span></span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>BottleFillingMachine<span>&lt;</span>Done<span>&gt;</span></span></span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        BottleFillingMachine <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            shared_value<span>:</span> val<span>.</span>shared_value<span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            state<span>:</span> Done<span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>Defining a starting state for the machine looks like this:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>impl</span> </span><span><span>BottleFillingMachine</span><span><span>&lt;</span>Waiting<span>&gt;</span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span><span>fn</span> </span><span>new</span></span><span><span><span>(</span><span>shared_value</span><span>:</span> <span>usize</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>Self</span></span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        BottleFillingMachine <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            shared_value<span>:</span> shared_value<span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            state<span>:</span> Waiting <span><span>{</span>
</span></span></span></span></span></span></span><span><span><span><span><span><span><span>                waiting_time<span>:</span> <span>std<span>::</span></span><span>time<span>::</span></span><span>Duration<span>::</span></span>new<span><span>(</span><span>0</span><span>,</span> <span>0</span></span><span><span>)</span></span><span>,</span>
</span></span></span></span></span></span></span><span><span><span><span><span><span><span>            </span><span><span>}</span></span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>So how does it look to change between two states? Like this:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>let</span> in_waiting <span>=</span> <span>BottleFillingMachine<span>::</span></span><span><span>&lt;</span>Waiting<span>&gt;</span></span><span><span>::</span></span>new<span><span>(</span><span>0</span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    <span>let</span> in_filling <span>=</span> <span>BottleFillingMachine<span>::</span></span><span><span>&lt;</span>Filling<span>&gt;</span></span><span><span>::</span></span>from<span><span>(</span>in_waiting</span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>Alternatively if you&#39;re doing this inside of a function whose type signature restricts the possible outputs it might look like this:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>transition_the_states</span></span><span><span><span>(</span><span>val</span><span>:</span> <span>BottleFillingMachine<span>&lt;</span>Waiting<span>&gt;</span></span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>BottleFillingMachine<span>&lt;</span>Filling<span>&gt;</span></span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    val<span>.</span><span>into</span><span><span>(</span></span><span><span>)</span></span> </span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>What do the <strong>compile time</strong> error messages look like?</p>
<pre><code><span>error[E0277]: the trait bound `BottleFillingMachine&lt;Done&gt;: std::convert::From&lt;BottleFillingMachine&lt;Waiting&gt;&gt;` is not satisfied
</span><span>  --&gt; &lt;anon&gt;:50:22
</span><span>   |
</span><span>50 |     let in_filling = BottleFillingMachine::&lt;Done&gt;::from(in_waiting);
</span><span>   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span>   |
</span><span>   = help: the following implementations were found:
</span><span>   = help:   &lt;BottleFillingMachine&lt;Filling&gt; as std::convert::From&lt;BottleFillingMachine&lt;Waiting&gt;&gt;&gt;
</span><span>   = help:   &lt;BottleFillingMachine&lt;Done&gt; as std::convert::From&lt;BottleFillingMachine&lt;Filling&gt;&gt;&gt;
</span><span>   = note: required by `std::convert::From::from`
</span></code></pre>
<p>It&#39;s pretty clear what&#39;s wrong from that. The error message even hints to us some valid transitions!</p>
<p>So what does this scheme give us?</p>
<ul>
<li>Transitions are ensured to be valid at compile time.</li>
<li>The error messages about invalid transitions are very understandable and even list valid options.</li>
<li>We have a &#39;parent&#39; structure which can have traits and values associated with it that aren&#39;t repeated.</li>
<li>Once a transition is made the old state no longer exists, it is consumed. Indeed, the entire structure is consumed so if there are side effects of the transition on the parent (for example altering the average waiting time) we can&#39;t access stale values.</li>
<li>Memory consumption is lean and everything is on the stack.</li>
</ul>
<p>There are some downsides still:</p>
<ul>
<li>Our <code>From&lt;T&gt;</code> implementations suffer from a fair bit of &#34;type noise&#34;. This is a highly minor concern though.</li>
<li>Each <code>BottleFillingMachine&lt;S&gt;</code> has a different size, with our previous example, so we&#39;ll need to use an enum. Because of our structure though we can do this in a way that doesn&#39;t completely suck.</li>
</ul>
<blockquote>
<p>You can play with this example <a rel="noopener" target="_blank" href="https://is.gd/CyuJlH"><strong>here</strong></a></p>
</blockquote>
<h3 id="getting-messy-with-the-parents"><a href="#getting-messy-with-the-parents" aria-label="Anchor link for: getting-messy-with-the-parents">Getting Messy With the Parents</a></h3>
<p>So how can we have some parent structure hold our state machine without it being a gigantic pain to interact with? Well, this circles us back around to the <code>enum</code> idea we had at first.</p>
<p>If you recall the primary problem with the <code>enum</code> example above was that we had to deal with no ability to enforce transitions, and the only errors we got were at runtime when we did try.</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>enum</span> <span>BottleFillingMachineWrapper</span> <span><span>{</span>
</span></span></span><span><span><span>    Waiting<span><span>(</span><span>BottleFillingMachine<span>&lt;</span>Waiting<span>&gt;</span></span></span><span><span>)</span></span><span>,</span>
</span></span></span><span><span><span>    Filling<span><span>(</span><span>BottleFillingMachine<span>&lt;</span>Filling<span>&gt;</span></span></span><span><span>)</span></span><span>,</span>
</span></span></span><span><span><span>    Done<span><span>(</span><span>BottleFillingMachine<span>&lt;</span>Done<span>&gt;</span></span></span><span><span>)</span></span><span>,</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span><span><span>struct</span> </span><span><span>Factory</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>bottle_filling_machine</span><span>:</span> BottleFillingMachineWrapper,
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span><span><span>impl</span> </span><span><span>Factory</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span><span>fn</span> </span><span>new</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>Self</span></span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        Factory <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            bottle_filling_machine<span>:</span> <span>BottleFillingMachineWrapper<span>::</span></span>Waiting<span><span>(</span><span>BottleFillingMachine<span>::</span></span>new<span><span>(</span><span>0</span></span><span><span>)</span></span></span><span><span>)</span></span><span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>At this point your first reaction is likely &#34;Gosh, Hoverbear, look at that awful and long type signature!&#34; You&#39;re quite right! Frankly it&#39;s rather long, but I picked long, explanatory type names! You&#39;ll be able to use all your favorite arcane abbreviations and type aliases in your own code. Have at!</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>impl</span> </span><span><span>BottleFillingMachineWrapper</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span><span>fn</span> </span><span>step</span></span><span><span><span>(</span><span>mut</span> <span>self</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>Self</span></span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        <span>match</span> <span>self</span> <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            <span>BottleFillingMachineWrapper<span>::</span></span>Waiting<span><span>(</span>val</span><span><span>)</span></span> <span>=&gt;</span> <span>BottleFillingMachineWrapper<span>::</span></span>Filling<span><span>(</span>val<span>.</span><span>into</span><span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span><span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            <span>BottleFillingMachineWrapper<span>::</span></span>Filling<span><span>(</span>val</span><span><span>)</span></span> <span>=&gt;</span> <span>BottleFillingMachineWrapper<span>::</span></span>Done<span><span>(</span>val<span>.</span><span>into</span><span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span><span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            <span>BottleFillingMachineWrapper<span>::</span></span>Done<span><span>(</span>val</span><span><span>)</span></span> <span>=&gt;</span> <span>BottleFillingMachineWrapper<span>::</span></span>Waiting<span><span>(</span>val<span>.</span><span>into</span><span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span><span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>let</span> <span>mut</span> the_factory <span>=</span> <span>Factory<span>::</span></span>new<span><span>(</span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    the_factory<span>.</span>bottle_filling_machine <span>=</span> the_factory<span>.</span>bottle_filling_machine<span>.</span><span>step</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>Again you may notice that this works by <strong>consumption</strong> not mutation. Using <code>match</code> the way we are above <em>moves</em> <code>val</code> so that it can be used with <code>.into()</code> which we&#39;ve already determined should consume the state. If you&#39;d really like to use mutation you can consider having your states <code>#[derive(Clone)]</code> or even <code>Copy</code>, but that&#39;s your call.</p>
<p>Despite this being a bit less ergonomic and pleasant to work with than we might want we still get strongly enforced state transitions and all the guarantees that come with them.</p>
<p>One thing you will notice is this scheme <strong>does</strong> force you to handle all potential states when manipulating the machine, and that makes sense. You are reaching into a structure with a state machine and manipulating it, you need to have defined actions for each state that it is in.</p>
<p>Or you can just <code>panic!()</code> if that&#39;s what you really want. But if you just wanted to <code>panic!()</code> then why didn&#39;t you just use the first attempt?</p>
<blockquote>
<p>You can see a fully worked example of this Factory example <a rel="noopener" target="_blank" href="https://is.gd/s03IaQ"><strong>here</strong></a></p>
</blockquote>
<h2 id="worked-examples"><a href="#worked-examples" aria-label="Anchor link for: worked-examples">Worked Examples</a></h2>
<p>This is the kind of thing it&#39;s always nice to have some examples for. So below I&#39;ve put together a couple worked examples with comments for you to explore.</p>
<h3 id="three-state-two-transitions"><a href="#three-state-two-transitions" aria-label="Anchor link for: three-state-two-transitions">Three State, Two Transitions</a></h3>
<p>This example is very similar to the Bottle Filling Machine above, but instead it <strong>actually</strong> does work, albeit trivial work. It takes a string and returns the number of words in it.</p>
<blockquote>
<p><a rel="noopener" target="_blank" href="https://is.gd/4ITDyV">Playground link</a></p>
</blockquote>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>let</span> in_state_a <span>=</span> <span>StateMachine<span>::</span></span>new<span><span>(</span><span><span>&#34;</span>Blah blah blah<span>&#34;</span></span><span>.</span><span>into</span><span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    in_state_a<span>.</span>some_unrelated_value<span>;</span>
</span></span></span><span><span><span>    <span>println!</span><span><span>(</span></span><span><span><span>&#34;</span>Starting Value: <span>{}</span><span>&#34;</span></span></span><span><span>,</span> in_state_a<span>.</span>state<span>.</span>start_value<span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>let</span> in_state_b <span>=</span> <span>StateMachine<span>::</span></span><span><span>&lt;</span>StateB<span>&gt;</span></span><span><span>::</span></span>from<span><span>(</span>in_state_a</span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>    in_state_b<span>.</span>some_unrelated_value<span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    <span>println!</span><span><span>(</span></span><span><span><span>&#34;</span>Interm Value: <span>{:?}</span><span>&#34;</span></span></span><span><span>,</span> in_state_b<span>.</span>state<span>.</span>interm_value<span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>let</span> in_state_c <span>=</span> <span>StateMachine<span>::</span></span><span><span>&lt;</span>StateC<span>&gt;</span></span><span><span>::</span></span>from<span><span>(</span>in_state_b</span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    </span></span></span><span><span><span>
</span></span></span><span><span><span>    <span>println!</span><span><span>(</span></span><span><span><span>&#34;</span>Final state: <span>{}</span><span>&#34;</span></span></span><span><span>,</span> in_state_c<span>.</span>state<span>.</span>final_value<span>)</span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span></span><span><span><span>struct</span> </span><span><span><span>StateMachine</span><span><span>&lt;</span>S<span>&gt;</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>some_unrelated_value</span><span>:</span> <span>usize</span>,
</span></span></span><span><span><span>    <span>state</span><span>:</span> S,
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span></span><span><span><span>impl</span> </span><span><span>StateMachine</span><span><span>&lt;</span>StateA<span>&gt;</span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span><span>fn</span> </span><span>new</span></span><span><span><span>(</span><span>val</span><span>:</span> String</span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>Self</span></span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        StateMachine <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            some_unrelated_value<span>:</span> <span>0</span><span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            state<span>:</span> <span>StateA<span>::</span></span>new<span><span>(</span>val</span><span><span>)</span></span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span></span><span><span><span>struct</span> </span><span><span>StateA</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>start_value</span><span>:</span> String,
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span><span><span>impl</span> </span><span><span>StateA</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span><span>fn</span> </span><span>new</span></span><span><span><span>(</span><span>start_value</span><span>:</span> String</span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>Self</span></span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        StateA <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            start_value<span>:</span> start_value<span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span></span><span><span><span>struct</span> </span><span><span>StateB</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>interm_value</span><span>:</span> <span><span>Vec</span><span>&lt;</span><span>String</span><span>&gt;</span></span>,
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span><span><span>impl</span> </span><span><span><span>From</span><span>&lt;</span><span>StateMachine<span>&lt;</span>StateA<span>&gt;</span></span><span>&gt;</span></span> <span>for</span></span><span> <span>StateMachine</span><span><span>&lt;</span>StateB<span>&gt;</span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span><span>fn</span> </span><span>from</span></span><span><span><span>(</span><span>val</span><span>:</span> <span>StateMachine<span>&lt;</span>StateA<span>&gt;</span></span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>StateMachine<span>&lt;</span>StateB<span>&gt;</span></span></span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        StateMachine <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            some_unrelated_value<span>:</span> val<span>.</span>some_unrelated_value<span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            state<span>:</span> StateB <span><span>{</span>
</span></span></span></span></span></span></span><span><span><span><span><span><span><span>                interm_value<span>:</span> val<span>.</span>state<span>.</span>start_value<span>.</span><span>split</span><span><span>(</span><span><span>&#34;</span> <span>&#34;</span></span></span><span><span>)</span></span><span>.</span><span>map</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>x</span><span>|</span></span> </span><span>x<span>.</span><span>into</span><span><span>(</span></span><span><span>)</span></span></span></span><span><span>)</span></span><span>.</span><span>collect</span><span><span>(</span></span><span><span>)</span></span><span>,</span>
</span></span></span></span></span></span></span><span><span><span><span><span><span><span>            </span><span><span>}</span></span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span></span><span><span><span>struct</span> </span><span><span>StateC</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>final_value</span><span>:</span> <span>usize</span>,
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span><span><span>impl</span> </span><span><span><span>From</span><span>&lt;</span><span>StateMachine<span>&lt;</span>StateB<span>&gt;</span></span><span>&gt;</span></span> <span>for</span></span><span> <span>StateMachine</span><span><span>&lt;</span>StateC<span>&gt;</span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span><span>fn</span> </span><span>from</span></span><span><span><span>(</span><span>val</span><span>:</span> <span>StateMachine<span>&lt;</span>StateB<span>&gt;</span></span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>StateMachine<span>&lt;</span>StateC<span>&gt;</span></span></span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        StateMachine <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            some_unrelated_value<span>:</span> val<span>.</span>some_unrelated_value<span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            state<span>:</span> StateC <span><span>{</span>
</span></span></span></span></span></span></span><span><span><span><span><span><span><span>                final_value<span>:</span> val<span>.</span>state<span>.</span>interm_value<span>.</span><span>len</span><span><span>(</span></span><span><span>)</span></span><span>,</span>
</span></span></span></span></span></span></span><span><span><span><span><span><span><span>            </span><span><span>}</span></span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<h3 id="a-raft-example"><a href="#a-raft-example" aria-label="Anchor link for: a-raft-example">A Raft Example</a></h3>
<p>If you&#39;ve followed my posts for awhile you may know I rather enjoy thinking about Raft. Raft, and a discussion with <a rel="noopener" target="_blank" href="https://twitter.com/Argorak"><strong>@argorak</strong></a> were the primary motivators behind all of this research.</p>
<p>Raft is a bit more complex than the above examples as it does not just have linear states where <code>A-&gt;B-&gt;C</code>. Here is the transition diagram:</p>
<pre><code><span>++++++++++-+    ++++++++++--+    +++++++--+
</span><span>|          ++++-&gt;           |    |        |
</span><span>| Follower |    | Candidate ++++-&gt; Leader |
</span><span>|          &lt;+++-+           |    |        |
</span><span>+++++++--^-+    ++++++++++--+    +-++++++++
</span><span>         |                         |
</span><span>         +++++++++++++++++++++++++-+
</span></code></pre>
<blockquote>
<p><a rel="noopener" target="_blank" href="https://is.gd/HDZeGR">Playground link</a></p>
</blockquote>
<pre data-lang="rust"><code data-lang="rust"><span></span><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>let</span> is_follower <span>=</span> <span>Raft<span>::</span></span>new<span><span>(</span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>let</span> is_candidate <span>=</span> <span>Raft<span>::</span></span><span><span>&lt;</span>Candidate<span>&gt;</span></span><span><span>::</span></span>from<span><span>(</span>is_follower</span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>let</span> is_leader <span>=</span> <span>Raft<span>::</span></span><span><span>&lt;</span>Leader<span>&gt;</span></span><span><span>::</span></span>from<span><span>(</span>is_candidate</span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>let</span> is_follower_again <span>=</span> <span>Raft<span>::</span></span><span><span>&lt;</span>Follower<span>&gt;</span></span><span><span>::</span></span>from<span><span>(</span>is_leader</span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>let</span> is_candidate_again <span>=</span> <span>Raft<span>::</span></span><span><span>&lt;</span>Candidate<span>&gt;</span></span><span><span>::</span></span>from<span><span>(</span>is_follower_again</span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>let</span> is_follower_another_time <span>=</span> <span>Raft<span>::</span></span><span><span>&lt;</span>Follower<span>&gt;</span></span><span><span>::</span></span>from<span><span>(</span>is_candidate_again</span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span>
</span><span></span><span><span><span>struct</span> </span><span><span><span>Raft</span><span><span>&lt;</span>S<span>&gt;</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span>    <span>state</span><span>:</span> S
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span></span><span>
</span><span></span><span><span><span>struct</span> </span><span><span>Leader</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span></span><span><span><span>struct</span> </span><span><span>Candidate</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span></span><span><span><span>struct</span> </span><span><span>Follower</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    </span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span></span><span><span><span>impl</span> </span><span><span>Raft</span><span><span>&lt;</span>Follower<span>&gt;</span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span><span>fn</span> </span><span>new</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>Self</span></span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        </span></span></span></span></span><span><span><span><span><span>        Raft <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            </span></span></span></span></span></span><span><span><span><span><span><span>            state<span>:</span> Follower <span><span>{</span>  </span><span><span>}</span></span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span></span><span>
</span><span></span><span><span><span>impl</span> </span><span><span><span>From</span><span>&lt;</span><span>Raft<span>&lt;</span>Follower<span>&gt;</span></span><span>&gt;</span></span> <span>for</span></span><span> <span>Raft</span><span><span>&lt;</span>Candidate<span>&gt;</span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span><span>fn</span> </span><span>from</span></span><span><span><span>(</span><span>val</span><span>:</span> <span>Raft<span>&lt;</span>Follower<span>&gt;</span></span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>Raft<span>&lt;</span>Candidate<span>&gt;</span></span></span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        </span></span></span></span></span><span><span><span><span><span>        Raft <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            </span></span></span></span></span></span><span><span><span><span><span><span>            state<span>:</span> Candidate <span><span>{</span>  </span><span><span>}</span></span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span></span><span><span><span>impl</span> </span><span><span><span>From</span><span>&lt;</span><span>Raft<span>&lt;</span>Candidate<span>&gt;</span></span><span>&gt;</span></span> <span>for</span></span><span> <span>Raft</span><span><span>&lt;</span>Follower<span>&gt;</span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span><span>fn</span> </span><span>from</span></span><span><span><span>(</span><span>val</span><span>:</span> <span>Raft<span>&lt;</span>Candidate<span>&gt;</span></span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>Raft<span>&lt;</span>Follower<span>&gt;</span></span></span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        </span></span></span></span></span><span><span><span><span><span>        Raft <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            </span></span></span></span></span></span><span><span><span><span><span><span>            state<span>:</span> Follower <span><span>{</span>  </span><span><span>}</span></span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span></span><span><span><span>impl</span> </span><span><span><span>From</span><span>&lt;</span><span>Raft<span>&lt;</span>Candidate<span>&gt;</span></span><span>&gt;</span></span> <span>for</span></span><span> <span>Raft</span><span><span>&lt;</span>Leader<span>&gt;</span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span><span>fn</span> </span><span>from</span></span><span><span><span>(</span><span>val</span><span>:</span> <span>Raft<span>&lt;</span>Candidate<span>&gt;</span></span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>Raft<span>&lt;</span>Leader<span>&gt;</span></span></span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        </span></span></span></span></span><span><span><span><span><span>        Raft <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            </span></span></span></span></span></span><span><span><span><span><span><span>            state<span>:</span> Leader <span><span>{</span>  </span><span><span>}</span></span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span></span><span><span><span>impl</span> </span><span><span><span>From</span><span>&lt;</span><span>Raft<span>&lt;</span>Leader<span>&gt;</span></span><span>&gt;</span></span> <span>for</span></span><span> <span>Raft</span><span><span>&lt;</span>Follower<span>&gt;</span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span><span>fn</span> </span><span>from</span></span><span><span><span>(</span><span>val</span><span>:</span> <span>Raft<span>&lt;</span>Leader<span>&gt;</span></span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>Raft<span>&lt;</span>Follower<span>&gt;</span></span></span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        </span></span></span></span></span><span><span><span><span><span>        Raft <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            </span></span></span></span></span></span><span><span><span><span><span><span>            state<span>:</span> Follower <span><span>{</span>  </span><span><span>}</span></span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<h2 id="alternatives-from-feedback"><a href="#alternatives-from-feedback" aria-label="Anchor link for: alternatives-from-feedback">Alternatives From Feedback</a></h2>
<p>I saw an interesting comment by <a rel="noopener" target="_blank" href="https://www.reddit.com/r/rust/comments/57ccds/pretty_state_machine_patterns_in_rust/d8rhwq4">I-impv on Reddit</a> showing off <a rel="noopener" target="_blank" href="https://play.rust-lang.org/?gist=ee3e4df093c136ced7b394dc7ffb78e1&amp;version=stable&amp;backtrace=0">this approach based on our examples above</a>. Here&#39;s what they had to say about it:</p>
<blockquote>
<p>I like the way you did it. I am working on a fairly complex FSM myself currently and did it slightly different.</p>
<p>Some things I did different:</p>
<ul>
<li>I also modeled the input for the state machine. That way you can model your transitions as a match over (State, Event) every invalid combination is handled by the &#39;default&#39; pattern</li>
<li>Instead of using panic for invalid transitions I used a Failure state, So every invalid combination transitions to that Failure state</li>
</ul>
</blockquote>
<p>I really like the idea of modeling the input in the transitions!</p>
<h2 id="closing-thoughts"><a href="#closing-thoughts" aria-label="Anchor link for: closing-thoughts">Closing Thoughts</a></h2>
<p>Rust lets us represent State Machines in a fairly good way. In an ideal situation we&#39;d be able to make <code>enum</code>s with restricted transitions between variants, but that&#39;s not the case. Instead, we can harness the power of generics and the ownership system to create something expressive, safe, and understandable.</p>
<p>If you have any feedback or suggestions on this article I&#39;d suggest checking out the footer of this page for contact details. I also hang out on Mozilla&#39;s IRC as Hoverbear.</p>

</article></div>
  </body>
</html>
