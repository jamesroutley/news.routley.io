<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://chadnauseam.com/coding/random/how-side-effects-work-in-fp/">Original</a>
    <h1>How side effects work in FP</h1>
    
    <div id="readability-page-1" class="page"><div><main><p>When you think about functional programming, you might think of banning mutation, or of functions without side effects. But in my opinion, the fundamental idea of FP is <em>equational reasoning</em>. That is, this code:</p><pre><p><span><code>x = foo()
y = bar(x)
z = bar(x)
</code></span></p></pre><p>Should mean the same thing as:</p><pre><p><span><code>y = bar(foo())
z = bar(foo())
</code></span></p></pre><p>Put explicitly: If you write <code>x = foo()</code>, that means you should be able to replace any occurrence of <code>x</code> with <code>foo()</code> without changing the meaning. That you can&#39;t have mutation or side-effects follows from this principle.</p><ol><li><p>If <code>foo()</code> had side effects, then the first example (where we call <code>foo</code> once) would have different behavior than the second (where we call it twice).</p></li><li><p>If <code>bar(x)</code> could mutate <code>x</code>, then changing <code>bar(x)</code> to <code>bar(foo())</code> would change what your program means.</p></li></ol><p>By saying reducing what you can do, we allow a way of reasoning about programs that would otherwise be basically impossible. Math traditionally uses equational reasoning a lot, and not for nothing – it&#39;s really useful!</p><h2>Can we still have effectful programs?</h2><div><div><p>I&#39;m going to be using a Rust-inspired syntax for this post, where you can write something like this to describe an enum with two variants:</p><pre><p><span><code>enum Message {
    Quit,
    Move { x: i32, y: i32 },
}
</code></span></p></pre><p>So you could create a value of type <code>Message</code> by writing <code>Move {x=3, y=5}</code> or something like that.</p><p>Also, you can define anonymous functions with syntax like <code>|x| x + 10</code>. That describes a function that takes a value <code>x</code> and returns <code>x + 10</code>.</p></div></div><p>With the restrictions of functional programming, it&#39;s not obvious how to express programs that, y&#39;know, actually do stuff. But it&#39;s not as hard as it seems. You just have a special variable, called <code>main</code> or something like that, and allow the user to set <code>main</code> to what I&#39;ll call an &#34;action value&#34; that <em>describes</em> the behavior of a program. What could this data structure look like?</p><ol><li><p>Start out with an action value that doesn&#39;t really do anything, like <code>Done</code>.</p><p>If you write <code>main = Done</code>, your program will naturally immediately terminate without doing anything.</p><p>So we&#39;re starting out with:</p><pre><p><span><code>enum ActionValue {
  Done
}
</code></span></p></pre><p>Ideally we would want to be able to write more interesting programs than that!</p></li><li><p>Let&#39;s extend our <code>ActionValue</code> type a little bit:</p><pre><p><span><code>enum ActionValue {
  Done,
  Print {to_print: String, then: ActionValue}
}
</code></span></p></pre><p>Now you can write <code>main = Print {to_print=&#34;Hello world&#34;, then=Done}</code>, and your program will print <code>Hello world</code> and then be done!</p><p>Or you could write:</p><pre><p><span><code>main = Print {
  to_print = &#34;Hello world&#34;,
  then = Print {
    to_print = &#34;Goodnight moon&#34;,
    then = Done
   }
 }
</code></span></p></pre><p>And that would print <code>Hello world</code>, then print <code>Goodnight moon</code>, then be done. Ok, we&#39;re most of the way there, but we still need a way to write programs that take input from the outside world!</p></li><li><p>Let&#39;s extend our type one final time.</p><pre><p><span><code>enum ActionValue {
  Done,
  Print {to_print: String, then: ActionValue},
  Input {then: String -&gt; ActionValue}
}
</code></span></p></pre><p>Now <code>Input</code>&#39;s <code>then</code> parameter takes a function of type <code>String -&gt; ActionValue</code>, instead of a plain action value like <code>Print</code>&#39;s does. Which means we can write something like this:</p><pre><p><span><code>main = Input {
  then = |what_the_user_typed| Print {
    to_print = &#34;Hello, &#34; + what_the_user_typed,
    then = Done
   }
 }
</code></span></p></pre><p>First, the computer sees <code>Input</code>, so it gets a line of input from the user. Then it passes what the user typed to the <code>then</code> parameter, and executes the action value it returns. So the result is the classic program that allows the user to type their name and greets them.</p></li></ol><p>That&#39;s all we need! So why do languages like Haskell have their dreaded &#34;monads&#34;? Turns out all they do is simplify the construction of action values. (They&#39;re useful for other things too, but that&#39;s why they were introduced.) And it turns out with an sufficiently advanced compiler, it&#39;s not even that hard to convert an action value to pretty-efficient imperative code. So we gain equational reasoning without sacrificing any expressive power or even very much performance. Neat!</p><h2>I don&#39;t know why people try to explain monads without explaining this first</h2><p>Monads really are just a convenient way to build up action values. In Haskell, the end result is that you can write code like this:</p><pre><p><span><code>main =
  getline &gt;&gt;= (\what_the_user_typed -&gt;
  print (&#34;Hello, &#34; ++ what_the_user_typed))
</code></span></p></pre><div><div><p><code>&gt;&gt;=</code> is a built-in operator for combining action values, or anything else with a monad structure.</p></div></div><p>Or even</p><pre><p><span><code>main = do
  what_the_user_typed &lt;- getline
  print (&#34;Hello, &#34; ++ what_the_user_typed)
</code></span></p></pre><p>And you&#39;ll get something that&#39;s semantically identical to the above. The <code>&lt;-</code> works like an <code>=</code>, except it signals that equational reasoning <em>doesn&#39;t</em> apply to this value. You can&#39;t replace <code>what_the_user_typed</code> with <code>getline</code> - your program won&#39;t compile. That&#39;s not a design feature that had to be added – it&#39;s inherent to the world of monads!</p></main></div></div>
  </body>
</html>
