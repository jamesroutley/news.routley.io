<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://healeycodes.com/lisp-to-javascript-compiler">Original</a>
    <h1>Lisp to JavaScript Compiler</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>I wrote a compiler that takes Lisp code and turns it into JavaScript. The compiler is a <a href="https://github.com/healeycodes/lisp-to-js">~280 line Rust program</a> that I wrote over a few nights. When I started this project, I thought I understood how Lisp worked  (I didn&#39;t) but I do now.</p><p>The first step of this project involved choosing a Lisp to implement. There are many Lisps. I&#39;m a big fan of Mary Rose Cook&#39;s <a href="https://maryrosecook.com/blog/post/little-lisp-interpreter">Little Lisp</a> blog post so I decided to  implement Little Lisp, plus or minus a few forms.</p><p>In Lisp terminology, a &#34;form&#34; is a fundamental concept referring to any syntactic construct that can be evaluated to produce a result.</p><p>My Lisp has these forms.</p><pre><div><div><p><span>; atoms</span></p><p><span>1 ; f64 numbers</span></p><p><span>a ; symbols</span></p><p><span>; arithmetic expressions</span></p><p><span>(+ 1 2) ; 3</span></p><p><span>(- 1 2) ; -1</span></p><p><span>; control flow expressions</span></p><p><span>(&lt; 1 2) ; true</span></p><p><span>(&gt; 1 2) ; false</span></p><p><span>(if (&lt; 1 2) (+ 10 10) (+ 10 5)) ; 20</span></p><p><span>; lambda expressions</span></p><p><span>(lambda (x) (+ x x)) ; function that doubles</span></p><p><span>; variable definition</span></p><p><span>(let ((a 1)) (print a)) ; prints 1</span></p><p><span>(let ((double (lambda (x) (+ x x))) (double 2))) ; 4</span></p></div></div></pre><p>These are enough forms to write small programs that can do meaningful calculations. Like finding the Nth Fibonacci number, as we&#39;ll see later.</p><h2 id="parsing">Parsing</h2><p>To transform a Lisp program into a JavaScript program, you need to convert it to an intermediate representation. I used an Abstract Syntax Tree (AST) for this purpose.</p><p>During the compile step, I walk over this tree and output each node as JavaScript.</p><p>The AST that&#39;s created for <code>(let ((double (lambda (x) (+ x x))) (double 2)))</code> looks something like this (I drew this manually but would love to have my compiler output this!):</p><pre><div><div><p><span>(let</span></p><p><span>  ├── Bindings</span></p><p><span>  │   └── (double</span></p><p><span>  │       ├── Variable: double</span></p><p><span>  │       └── Expression</span></p><p><span>  │           └── (lambda</span></p><p><span>  │               ├── Parameters</span></p><p><span>  │               │   └── (x)</span></p><p><span>  │               └── Body</span></p><p><span>  │                   └── (+ </span></p><p><span>  │                       ├── Expression: x</span></p><p><span>  │                       └── Expression: x</span></p><p><span>  │                   )</span></p><p><span>  │           )</span></p><p><span>  │       )</span></p><p><span>  └── Body</span></p><p><span>      └── (double 2)</span></p><p><span>          ├── Function: double</span></p><p><span>          └── Expression: 2</span></p><p><span>)</span></p></div></div></pre><p>I used the <a href="https://github.com/J-F-Liu/pom">pom</a> library to define parser combinators that consume Lisp syntax.</p><p>I&#39;ll quote a section from the <a href="https://github.com/J-F-Liu/pom/blob/master/doc/article.md">pom docs</a> that helped all this click for me:</p><blockquote><p>A <em>parser</em> is a function which takes a <em>string</em> (a series of <em>symbols</em>) as input, and returns matching result as <em>output</em>.</p>
<p>A <em>combinator</em> is a higher-order function (a &#34;functional&#34;) which takes zero or more functions (each of the same type) as input and returns a new function of the same type as output.</p><p>A <em>parser combinator</em> is a higher-order function which takes parsers as input and returns a new parser as output.</p></blockquote><p>I previously used this library to write the parser for <a href="https://healeycodes.com/porting-boolrule-to-rust">a boolean expression engine</a> and had a pretty good time with it. Like most of my Rust experience, I spent more time fixing  compile errors — rather than running, testing, and debugging. When it comes to parsers, I find fixing compile errors to be a tighter, and more productive loop, than running-and-fixing code from a more dynamic language.</p><p>In my Lisp, I define a number as:</p><ol start="1"><li>Starts with <code>1-9</code></li><li>Maybe followed by any amount of <code>0-9</code> characters</li><li>Or just a single <code>0</code></li></ol><p>These rules are encoded in a parser combinator function.</p><pre><div><div><p><span>fn</span><span> </span><span>number</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span>(</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Parser</span><span>&lt;</span><span>&#39;a</span><span>,</span><span> </span><span>u8</span><span>,</span><span> </span><span>f64</span><span>&gt;</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>let</span><span> number </span><span>=</span><span> </span><span>one_of</span><span>(</span><span>b&#34;123456789&#34;</span><span>)</span><span> </span><span>-</span><span> </span><span>one_of</span><span>(</span><span>b&#34;0123456789&#34;</span><span>)</span><span>.</span><span>repeat</span><span>(</span><span>0</span><span>..</span><span>)</span><span></span></p><p><span>        </span><span>|</span><span> </span><span>sym</span><span>(</span><span>b&#39;0&#39;</span><span>)</span><span>;</span><span></span></p><p><span>    number</span></p><p><span>        </span><span>.</span><span>collect</span><span>(</span><span>)</span><span></span></p><p><span>        </span><span>.</span><span>convert</span><span>(</span><span>str</span><span>::</span><span>from_utf8</span><span>)</span><span></span></p><p><span>        </span><span>.</span><span>convert</span><span>(</span><span>f64</span><span>::</span><span>from_str</span><span>)</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>This number parser is combined with other parsers to find the atoms in my Lisp programs.</p><pre><div><div><p><span>fn</span><span> </span><span>atom</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span>(</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Parser</span><span>&lt;</span><span>&#39;a</span><span>,</span><span> </span><span>u8</span><span>,</span><span> </span><span>Atom</span><span>&gt;</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>// Starts with optional space characters</span><span></span></p><p><span>    </span><span>space</span><span>(</span><span>)</span><span> </span><span>*</span><span></span></p><p><span>        </span><span>// A number, mapped into my Atom enum</span><span></span></p><p><span>        </span><span>(</span><span>number</span><span>(</span><span>)</span><span>.</span><span>map</span><span>(</span><span>|</span><span>n</span><span>|</span><span> </span><span>Atom</span><span>::</span><span>Number</span><span>(</span><span>n</span><span>)</span><span>)</span><span></span></p><p><span>        </span><span>// Or a symbol</span><span></span></p><p><span>        </span><span>|</span><span> </span><span>symbol</span><span>(</span><span>)</span><span>.</span><span>map</span><span>(</span><span>|</span><span>s</span><span>|</span><span> </span><span>Atom</span><span>::</span><span>Symbol</span><span>(</span><span>s</span><span>)</span><span>)</span><span>)</span><span></span></p><p><span>    </span><span>// Followed by optional space characters</span><span></span></p><p><span>    </span><span>-</span><span> </span><span>space</span><span>(</span><span>)</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>The resulting parser turns source code into the structs and enums that make up the AST. These structures are recursive. A function definition can define another function inside it&#39;s body (and so on).</p><p>Rust only lets you define recursive data structures if you use constructs like Vecs or Boxes which have runtime checks for their memory usage.</p><pre><div><div><p><span>enum</span><span> </span><span>Expression</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>Atom</span><span>(</span><span>Atom</span><span>)</span><span>,</span><span></span></p><p><span>    </span><span>List</span><span>(</span><span>Vec</span><span>&lt;</span><span>Expression</span><span>&gt;</span><span>)</span><span>,</span><span> </span><span>// &lt;--</span><span></span></p><p><span>    </span><span>LetExpression</span><span>(</span><span>LetExpression</span><span>)</span><span>,</span><span></span></p><p><span>    </span><span>LambdaExpression</span><span>(</span><span>LambdaExpression</span><span>)</span><span>,</span><span></span></p><p><span>    </span><span>IfExpression</span><span>(</span><span>Box</span><span>&lt;</span><span>IfExpression</span><span>&gt;</span><span>)</span><span>,</span><span> </span><span>// &lt;--</span><span></span></p><p><span>    </span><span>ArithmeticExpression</span><span>(</span><span>Box</span><span>&lt;</span><span>ArithmeticExpression</span><span>&gt;</span><span>)</span><span>,</span><span> </span><span>// &lt;--</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>struct</span><span> </span><span>LambdaExpression</span><span> </span><span>{</span><span></span></p><p><span>    parameters</span><span>:</span><span> </span><span>Vec</span><span>&lt;</span><span>String</span><span>&gt;</span><span>,</span><span></span></p><p><span>    expressions</span><span>:</span><span> </span><span>Vec</span><span>&lt;</span><span>Expression</span><span>&gt;</span><span>,</span><span> </span><span>// &lt;--</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>For me, the hardest thing about writing a Lisp parser was probably off-by-one errors with the amount of parenthesis each form uses. I also didn&#39;t have a perfect understanding of how Lisp forms combined to produce programs. Largely due to the fact that, before I started this project, I hadn&#39;t written a Lisp program before.</p><h2 id="generating-javascript">Generating JavaScript</h2><p>After the parser runs, we either have a valid AST or we&#39;ve thrown an error that describes how the input failed to parse.</p><p>Being that Lisp programs are made up of expressions and JavaScript has great support for expressions, I didn&#39;t have too hard of a time generating code. In terms of effort, it was 20% learning the basics of Lisp, 70% writing a parser to build the AST and data structures, and then 10% code generation.</p><p>Given the simple forms I chose for my Lisp, they end up mapping fairly one-to-one with JavaScript expressions.</p><pre><div><div><p><span>// (+ 1 2)</span><span></span></p><p><span></span><span>1</span><span> </span><span>+</span><span> </span><span>2</span><span></span></p><p><span></span><span>// (print (+ 1 2))</span><span></span></p><p><span></span><span>console</span><span>.</span><span>log</span><span>(</span><span>1</span><span> </span><span>+</span><span> </span><span>2</span><span>)</span><span></span></p><p><span></span><span>// (let ((double (lambda (x) (+ x x))) (double 2)))</span><span></span></p><p><span></span><span>let</span><span> </span><span>double</span><span> </span><span>=</span><span> </span><span>x</span><span> </span><span>=&gt;</span><span> x </span><span>+</span><span> x</span></p><p><span></span><span>double</span><span>(</span><span>2</span><span>)</span></p></div></div></pre><p>My compiler starts by defining <code>print</code>, and then iterating over the expressions that the parser found.</p><pre><div><div><p><span>fn</span><span> </span><span>compile</span><span>(</span><span>program</span><span>:</span><span> </span><span>Vec</span><span>&lt;</span><span>Expression</span><span>&gt;</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>String</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>// Other built-ins can be manually added here</span><span></span></p><p><span>    </span><span>let</span><span> </span><span>mut</span><span> output </span><span>=</span><span> </span><span>&#34;/* lisp-to-js */</span></p><p><span>let print = console.log;</span></p><p><span>&#34;</span><span></span></p><p><span>    </span><span>.</span><span>to_string</span><span>(</span><span>)</span><span>;</span><span></span></p><p><span>    program</span><span>.</span><span>into_iter</span><span>(</span><span>)</span><span>.</span><span>for_each</span><span>(</span><span>|</span><span>expression</span><span>|</span><span> </span><span>{</span><span></span></p><p><span>            </span><span>// I found it easier to write to a parent variable</span><span></span></p><p><span>            </span><span>// which didn&#39;t feel very Rust-like but it worked for me!</span><span></span></p><p><span>        output</span><span>.</span><span>push_str</span><span>(</span><span>&amp;</span><span>compile_expression</span><span>(</span><span>expression</span><span>)</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>}</span><span>)</span><span>;</span><span></span></p><p><span>    output</span></p><p><span></span><span>}</span></p></div></div></pre><p>The function that handles expressions, <code>compile_expression</code>, is pretty much just a long match expression. When there are sub-expressions (very common) it recursively calls itself, continuously building an output string of JavaScript.</p><p>The code generation logic was a lot of fun to write. I felt much more at home with JavaScript (compared to Lisp) and it was very much a dessert compared to battling types over in parse-land.</p><p>I&#39;ll show a few of my favorite snippets here.</p><p>Like supporting less-than expressions:</p><pre><div><div><p><span>// input: (&lt; 1 2 3)</span><span></span></p><p><span></span><span>// output: 1 &lt; 2 &amp;&amp; 2 &lt; 3</span><span></span></p><p><span></span><span>Op</span><span>::</span><span>LessThan</span><span> </span><span>=&gt;</span><span> ret</span><span>.</span><span>push_str</span><span>(</span><span></span></p><p><span>    </span><span>&amp;</span><span>compiled_expressions</span></p><p><span>        </span><span>.</span><span>windows</span><span>(</span><span>2</span><span>)</span><span> </span><span>// How cool is this std lib function!?</span><span></span></p><p><span>        </span><span>.</span><span>into_iter</span><span>(</span><span>)</span><span></span></p><p><span>        </span><span>.</span><span>map</span><span>(</span><span>|</span><span>expressions</span><span>|</span><span> expressions</span><span>.</span><span>join</span><span>(</span><span>&#34; &lt; &#34;</span><span>)</span><span>)</span><span></span></p><p><span>        </span><span>.</span><span>collect</span><span>::</span><span>&lt;</span><span>Vec</span><span>&lt;</span><span>String</span><span>&gt;&gt;</span><span>(</span><span>)</span><span></span></p><p><span>        </span><span>.</span><span>join</span><span>(</span><span>&#34; &amp;&amp; &#34;</span><span>)</span><span>,</span><span></span></p><p><span></span><span>)</span><span>,</span></p></div></div></pre><p>And here&#39;s what I mean about a one-to-one mapping of structures:</p><pre><div><div><p><span>// input: (if (ex1) (ex2) (ex3))</span><span></span></p><p><span></span><span>// output: ex1 ? ex2 : ex3</span><span></span></p><p><span></span><span>Expression</span><span>::</span><span>IfExpression</span><span>(</span><span>if_expression</span><span>)</span><span> </span><span>=&gt;</span><span> ret</span><span>.</span><span>push_str</span><span>(</span><span>&amp;</span><span>format!</span><span>(</span><span></span></p><p><span>    </span><span>&#34;{} ? {} : {}\n&#34;</span><span>,</span><span></span></p><p><span>    </span><span>compile_expression</span><span>(</span><span>if_expression</span><span>.</span><span>check</span><span>)</span><span>,</span><span></span></p><p><span>    </span><span>compile_expression</span><span>(</span><span>if_expression</span><span>.</span><span>r#</span><span>true</span><span>)</span><span>,</span><span></span></p><p><span>    </span><span>compile_expression</span><span>(</span><span>if_expression</span><span>.</span><span>r#</span><span>false</span><span>)</span><span></span></p><p><span></span><span>)</span><span>)</span><span>,</span></p></div></div></pre><p>The same thing goes for lambda expressions in Lisp. JavaScript has those too (anonymous functions)!</p><pre><div><div><p><span>// input: (lambda (a) a)</span><span></span></p><p><span></span><span>// output: a =&gt; a</span><span></span></p><p><span></span><span>Expression</span><span>::</span><span>LambdaExpression</span><span>(</span><span>lambda_expression</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>let</span><span> params </span><span>=</span><span> lambda_expression</span><span>.</span><span>parameters</span><span>.</span><span>join</span><span>(</span><span>&#34;,&#34;</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>let</span><span> </span><span>mut</span><span> body </span><span>=</span><span> </span><span>&#34;&#34;</span><span>.</span><span>to_string</span><span>(</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>for</span><span> expression </span><span>in</span><span> lambda_expression</span><span>.</span><span>expressions </span><span>{</span><span></span></p><p><span>        body</span><span>.</span><span>push_str</span><span>(</span><span>&amp;</span><span>format!</span><span>(</span><span>&#34;{}\n&#34;</span><span>,</span><span> </span><span>&amp;</span><span>compile_expression</span><span>(</span><span>expression</span><span>)</span><span>)</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>    ret</span><span>.</span><span>push_str</span><span>(</span><span>&amp;</span><span>format!</span><span>(</span><span>&#34; (({}) =&gt; {})\n&#34;</span><span>,</span><span> params</span><span>,</span><span> body</span><span>)</span><span>)</span><span>;</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>Usually, the first program I write with a new interpreter or compiler is a Fibonacci function. It&#39;s a good test for a range of functionality (variable binding, boolean logic, comparison, recursion, and sometimes performance too).</p><p>Here&#39;s my compiler&#39;s output for a Fibonacci function with all the odd spacing and hanging commas that my compiler produces.</p><pre><div><div><p><span>/*</span></p><p><span>(let ((fib (lambda (n)</span></p><p><span>    (if (&lt; n 2)</span></p><p><span>        n</span></p><p><span>        (+ (fib (- n 1)) (fib (- n 2)))))))</span></p><p><span>(print (fib 10)))</span></p><p><span>*/</span><span></span></p><p><span></span><span>let</span><span> print </span><span>=</span><span> </span><span>console</span><span>.</span><span>log</span><span>;</span><span></span></p><p><span></span><span>let</span><span> fib </span><span>=</span><span>  </span><span>(</span><span>(</span><span>n</span><span>)</span><span> </span><span>=&gt;</span><span>  n  </span><span>&lt;</span><span> </span><span>2</span><span> </span><span>?</span><span>  n  </span><span>:</span><span> </span><span>(</span><span> </span><span>fib</span><span> </span><span>(</span><span>(</span><span> n </span><span>-</span><span>1</span><span>)</span><span>,</span><span> </span><span>)</span><span>+</span><span> </span><span>fib</span><span> </span><span>(</span><span>(</span><span> n </span><span>-</span><span>2</span><span>)</span><span>,</span><span> </span><span>)</span><span>)</span><span></span></p><p><span></span><span>)</span><span></span></p><p><span></span><span>;</span><span> </span><span>print</span><span> </span><span>(</span><span> </span><span>fib</span><span> </span><span>(</span><span>10</span><span>,</span><span> </span><span>)</span><span>,</span><span> </span><span>)</span></p></div></div></pre><p>You might think at this point: hm, this kinda thing seems hard to debug at runtime … what happens if you write a Lisp program with valid syntax but that will cause an error?</p><p>Well, the errors end up being quite useful! This is probably due to the fact there&#39;s only so much that can go wrong with such a limited amount of forms.</p><pre><div><div><p><span>(hm 1 2) ; ReferenceError: hm is not defined</span></p><p><span>(+ two 2) ; ReferenceError: two is not defined</span></p><p><span>(let ((a a)) ())</span></p><p><span>; let a =  a ;</span></p><p><span>;          ^</span></p><p><span>; </span></p><p><span>; ReferenceError: Cannot access &#39;a&#39; before initialization</span></p></div></div></pre><h2 id="bonus-compiling-to-native">Bonus: Compiling to Native</h2><p>I&#39;ve been following the development of <a href="https://github.com/CanadaHonk/porffor">Porffor</a> — an ahead-of-time optimizing JavaScript engine. While it&#39;s limited in the kind of JavaScript that it supports at the moment, the subset of JavaScript that <em>my</em> compiler produces is also limited.</p><p>Porffor can take my compiler&#39;s output (JavaScript) and compile it into a C program!</p><pre><div><div><p><span>$ </span><span>npm</span><span> i -g porffor@latest</span></p><p><span></span><span># generate a C file from my compiler&#39;s output</span><span></span></p><p><span>$ porf c fib10.js out.c</span></p><p><span></span><span># compile it for native</span><span></span></p><p><span>$ gcc out.c -o out</span></p><p><span>$ ./out</span></p><p><span></span><span>55</span><span> </span><span># it works!</span></p></div></div></pre></div></div></div>
  </body>
</html>
