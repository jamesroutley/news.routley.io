<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.welivesecurity.com/2023/03/01/blacklotus-uefi-bootkit-myth-confirmed/">Original</a>
    <h1>First in-the-wild UEFI bootkit bypassing UEFI Secure Boot</h1>
    
    <div id="readability-page-1" class="page"><div>
                
                <div>
                    <div>
                        
                        <div>

                            <p>The first in-the-wild UEFI bootkit bypassing UEFI Secure Boot on fully updated UEFI systems is now a reality</p>

                            <p>The number of UEFI vulnerabilities discovered in recent years and the failures in patching them or revoking vulnerable binaries within a reasonable time window hasn’t gone unnoticed by threat actors. As a result, the first publicly known UEFI bootkit bypassing the essential platform security feature – UEFI Secure Boot – is now a reality. In this blogpost we present the first public analysis of this UEFI bootkit, which is capable of running on even fully-up-to-date Windows 11 systems with UEFI Secure Boot enabled. Functionality of the bootkit and its individual features leads us to believe that we are dealing with a bootkit known as <strong>BlackLotus</strong>, <a href="https://www.bleepingcomputer.com/news/security/malware-dev-claims-to-sell-new-blacklotus-windows-uefi-bootkit/" target="_blank" rel="noopener">the UEFI bootkit being sold on hacking forums</a> for $5,000 since at least October 2022.</p>
<p>UEFI bootkits are very powerful threats, having full control over the OS boot process and thus capable of disabling various OS security mechanisms and deploying their own kernel-mode or user-mode payloads in early OS startup stages. This allows them to operate very stealthily and with high privileges. So far, only a few have been discovered in the wild and publicly described (e.g., multiple <a href="https://twitter.com/ESETresearch/status/1275770256389222400?s=20" target="_blank" rel="noopener">malicious EFI samples</a> we discovered in 2020, or fully featured UEFI bootkits such as our discovery last year – the <a href="https://www.welivesecurity.com/2021/10/05/uefi-threats-moving-esp-introducing-especter-bootkit/" target="_blank" rel="noopener">ESPecter bootkit</a> – or the <a href="https://securelist.com/finspy-unseen-findings/104322/" target="_blank" rel="noopener">FinSpy bootkit</a> discovered by researchers from Kaspersky).</p>
<p>UEFI bootkits may lose on stealthiness when compared to firmware implants – such as <a href="https://www.welivesecurity.com/2018/09/27/lojax-first-uefi-rootkit-found-wild-courtesy-sednit-group/">LoJax</a>; the first in-the-wild UEFI firmware implant, discovered by our team in 2018 – as bootkits are located on an easily accessible FAT32 disk partition. However, running as a bootloader gives them almost the same capabilities as firmware implants, but without having to overcome the multilevel SPI flash defenses, such as the BWE, BLE, and PRx protection bits, or the protections provided by hardware (like Intel Boot Guard). Sure, UEFI Secure Boot stands in the way of UEFI bootkits, but there are a non-negligible number of known vulnerabilities that allow bypassing this essential security mechanism. And the worst of this is that some of them are still easily exploitable on up-to-date systems even at the time of this writing – including the one exploited by BlackLotus.</p>
<p>Our investigation started with a few hits on what turned out to be the BlackLotus user-mode component – an HTTP downloader – in our telemetry late in 2022. After an initial assessment, code patterns found in the samples brought us to the discovery of six BlackLotus installers (both on VirusTotal and in our own telemetry). This allowed us to explore the whole execution chain and to realize that what we were dealing with here is not just regular malware.</p>
<p>Following are the key points about BlackLotus and a timeline summarizing the series of events related to it:</p>
<ul>
<li>It’s capable of running on the latest, fully patched Windows 11 systems with UEFI Secure Boot enabled.</li>
<li>It exploits a more than one year old vulnerability (<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-21894" target="_blank" rel="noopener">CVE-2022-21894</a>) to bypass UEFI Secure Boot and set up persistence for the bootkit. This is the first publicly known, in-the-wild abuse of this vulnerability.</li>
<li>Although the vulnerability was fixed in Microsoft’s January 2022 update, its exploitation is still possible as the affected, <strong>validly signed</strong> binaries have still not been added to the <a href="https://uefi.org/revocationlistfile" target="_blank" rel="noopener">UEFI revocation list</a>. BlackLotus takes advantage of this, bringing its own copies of legitimate – but vulnerable – binaries to the system in order to exploit the vulnerability.</li>
<li>It’s capable of disabling OS security mechanisms such as BitLocker, HVCI, and Windows Defender.</li>
<li>Once installed, the bootkit’s main goal is to deploy a kernel driver (which, among other things, protects the bootkit from removal), and an HTTP downloader responsible for communication with the C&amp;C and capable of loading additional user-mode or kernel-mode payloads.</li>
<li>BlackLotus has been advertised and sold on underground forums since at least October 6<sup>th</sup>, 2022. In this blogpost, we present evidence that the bootkit is real, and the advertisement is not merely a scam.</li>
<li>Interestingly, some of the BlackLotus installers we have analyzed do not proceed with bootkit installation if the compromised host uses one of the following locales:
<ul>
<li>Romanian (Moldova), ro-MD</li>
<li>Russian (Moldova), ru-MD</li>
<li>Russian (Russia), ru-RU</li>
<li>Ukrainian (Ukraine) , uk-UA</li>
<li>Belarusian (Belarus), be-BY</li>
<li>Armenian (Armenia), hy-AM</li>
<li>Kazakh (Kazakhstan), kk-KZ</li>
</ul>
</li>
</ul>
<p>The timeline of individual events related to BlackLotus is shown in Figure 1.</p>
<div id="attachment_169940"><p><a href="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-1.-The-timeline-of-individual-events-related-to-BlackLotus-UEFI-bootkit.png"><img src="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-1.-The-timeline-of-individual-events-related-to-BlackLotus-UEFI-bootkit.png" alt="" width="2000" height="1023" srcset="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-1.-The-timeline-of-individual-events-related-to-BlackLotus-UEFI-bootkit.png 2000w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-1.-The-timeline-of-individual-events-related-to-BlackLotus-UEFI-bootkit-300x153.png 300w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-1.-The-timeline-of-individual-events-related-to-BlackLotus-UEFI-bootkit-768x393.png 768w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-1.-The-timeline-of-individual-events-related-to-BlackLotus-UEFI-bootkit-1024x524.png 1024w" sizes="(max-width: 2000px) 100vw, 2000px"/></a></p><p><em>Figure 1. Timeline of major events related to BlackLotus UEFI bootkit</em></p></div>
<p>As already mentioned, the bootkit has been sold on underground forums since at least October 6<sup>th</sup>, 2022. At this point, we have not been able to identify, from our telemetry, the exact distribution channel used to deploy the bootkit to victims. The low number of BlackLotus samples we have been able to obtain, both from public sources and our telemetry, leads us to believe that not many threat actors have started using it yet. But until the revocation of the vulnerable bootloaders that BlackLotus depends on happens, we are concerned that things will change rapidly should this bootkit gets into the hands of the well-known crimeware groups, based on the bootkit’s easy deployment and crimeware groups’ capabilities for spreading malware using their botnets.</p>
<h2><span lang="EN-US">Is this really BlackLotus?</span></h2>
<p>There are several articles or posts summarizing information about BlackLotus (<a href="https://www.theregister.com/2022/10/13/blacklotus_malware_kaspersky/" target="_blank" rel="noopener">here</a>, <a href="https://www.linkedin.com/feed/update/urn:li:share:6986711231885713408/" target="_blank" rel="noopener">here</a> and <a href="https://www.bleepingcomputer.com/news/security/malware-dev-claims-to-sell-new-blacklotus-windows-uefi-bootkit/" target="_blank" rel="noopener">here</a> and many more…), all based on the information provided by the bootkit developer on underground hacking forums. So far, no one has confirmed or disproved these claims.</p>
<p>Here is our summary of the claims from the available publications compared with what we discovered while reverse engineering the bootkit samples:</p>
<ul>
<li><strong>BlackLotus’s advertisement on hacking forums claims that it features integrated Secure Boot bypass</strong><strong>. Adding vulnerable drivers to the UEFI revocation list is currently impossible, as the vulnerability affects hundreds of bootloaders that are still used today. ✅</strong>
<ul>
<li>True: It exploits <a href="https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2022-21894" target="_blank" rel="noopener">CVE-2022-21894</a> in order to break Secure Boot and achieve persistence on UEFI-Secure-Boot-enabled systems. Vulnerable drivers it uses are still not revoked in the latest <a href="https://uefi.org/revocationlistfile" target="_blank" rel="noopener">dbx</a>, at the time of writing.</li>
</ul>
</li>
<li><strong>BlackLotus’s advertisement on hacking forums claims that the bootkit has built-in Ring0/Kernel protection against removal. ✅</strong>
<ul>
<li>True: Its kernel driver protects handles belonging to its files on the EFI System Partition (ESP) against closing. As an additional layer of protection, these handles are continuously monitored and a Blue Screen Of Death (BSOD) triggered if any of these handles are closed, as described in the <em><a href="#protecting-bootkit-files-on-the-ESP-from-removal">Protecting bootkit files on the ESP from removal</a> </em>section.</li>
</ul>
</li>
<li><strong>BlackLotus’s advertisement on hacking forums claims that it comes with anti-virtual-machine (anti-VM), anti-debug, and code obfuscation features to block malware analysis attempts. ✅</strong>
<ul>
<li>True: It contains various anti-VM, anti-debug, and obfuscation techniques to make it harder to replicate or analyze. However, we are definitely not talking about any breakthrough or advanced anti-analysis techniques here, as they can be easily overcome with little effort.</li>
</ul>
</li>
<li><strong>BlackLotus’s advertisement on hacking forums claims that its purpose is to act as an HTTP downloader. ✅</strong>
<ul>
<li>True: Its final component acts as an HTTP downloader, as described in the <em><a href="#http-downloader">HTTP downloader</a> </em>section</li>
</ul>
</li>
<li><strong>BlackLotus’s advertisement on hacking forums claims that the HTTP downloader</strong><strong> runs under the SYSTEM account within a legitimate process. ✅</strong>
<ul>
<li>True: Its HTTP downloader runs within the <span>winlogon.exe</span> process context<strong>.</strong></li>
</ul>
</li>
<li><strong>BlackLotus’s advertisement on hacking forums claims it is</strong><strong> a tiny bootkit with an on-disk size of only 80 kB. ✅</strong>
<ul>
<li>True: Samples we were able to obtain really are around 80 kB.</li>
</ul>
</li>
<li><strong>BlackLotus’s advertisement on hacking forums claims that it can</strong><strong> disable built-in Windows security protections such as HVCI, Bitlocker, Windows Defender, and bypass User Account Control (UAC). ✅</strong>
<ul>
<li>True: It can disable <em><a href="#step-2">HVCI</a></em>, <em><a href="#blacklotus-execution-flow">Windows Defender</a></em>, <em><a href="#step-3">BitLocker</a></em>, and bypass <em><a href="#step-0">UAC</a></em>.</li>
</ul>
</li>
</ul>
<p>Based on these facts, we believe with high confidence that the bootkit we discovered in the wild is the BlackLotus UEFI bootkit.</p>
<h2>Attack overview</h2>
<p>A simplified scheme of the BlackLotus compromise chain is shown in Figure 2. It consists of three main parts:</p>
<ol>
<li>It starts with the execution of an installer (step 1 in Figure 2), which is responsible for deploying the bootkit’s files to the EFI System partition, disabling HVCI and BitLocker, and then rebooting the machine.</li>
<li>After the first reboot, exploitation of CVE-2022-21894 and subsequent enrollment of the attackers’ <a href="https://edk2-docs.gitbook.io/understanding-the-uefi-secure-boot-chain/additional_secure_boot_chain_implementations/machine_owner_key_mok" target="_blank" rel="noopener">Machine Owner Key</a> (MOK) occurs, to achieve persistence even on systems with UEFI Secure Boot enabled. The machine is then rebooted (steps 2–4 in Figure 2) again.</li>
<li>In all subsequent boots, the self-signed UEFI bootkit is executed and deploys both its kernel driver and user-mode payload, the HTTP downloader. Together, these components are able to download and execute additional user-mode and driver components from the C&amp;C server and protect the bootkit against removal (steps 5–9 in Figure 2).</li>
</ol>
<div id="attachment_169941"><p><a href="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-2.-BlackLotus-simplified-execution-overview.png"><img src="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-2.-BlackLotus-simplified-execution-overview.png" alt="" width="1562" height="2000" srcset="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-2.-BlackLotus-simplified-execution-overview.png 1562w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-2.-BlackLotus-simplified-execution-overview-234x300.png 234w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-2.-BlackLotus-simplified-execution-overview-768x983.png 768w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-2.-BlackLotus-simplified-execution-overview-800x1024.png 800w" sizes="(max-width: 1562px) 100vw, 1562px"/></a></p><p><em>Figure 2. BlackLotus simplified execution overview</em></p></div>
<h2>Interesting artifacts</h2>
<p>Even though we believe this is the BlackLotus UEFI bootkit, we did not find any reference to this name in the samples we analyzed. Instead, the code is full of references to the <a href="https://en.wikipedia.org/wiki/Higurashi_When_They_Cry" target="_blank" rel="noopener">Higurashi When They Cry</a> anime series, for example in individual component names, such as <span>higurashi_installer_uac_module.dll</span> and <span>higurashi_kernel.sys</span>, and also in the self-signed certificate used to sign the bootkit binary (shown in Figure 3).</p>
<div id="attachment_170251"><p><a href="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-3.-Self-signed-certificate-used-by-the-BlackLotus-bootkit-1.png"><img src="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-3.-Self-signed-certificate-used-by-the-BlackLotus-bootkit-1.png" alt="" width="1319" height="490" srcset="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-3.-Self-signed-certificate-used-by-the-BlackLotus-bootkit-1.png 1319w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-3.-Self-signed-certificate-used-by-the-BlackLotus-bootkit-1-300x111.png 300w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-3.-Self-signed-certificate-used-by-the-BlackLotus-bootkit-1-768x285.png 768w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-3.-Self-signed-certificate-used-by-the-BlackLotus-bootkit-1-1024x380.png 1024w" sizes="(max-width: 1319px) 100vw, 1319px"/></a></p><p><em>Figure 3. Self-signed certificate used by the BlackLotus bootkit</em></p></div>
<p>Additionally, the code decrypts but never uses various strings containing messages from the BlackLotus author (as shown in Figure 4 – note, that <a href="https://twitter.com/hasherezade" target="_blank" rel="noopener">hasherezade</a> is a well-known researcher and author of various malware-analysis tools), or just some random quotes from various songs, games, or series.</p>
<div id="attachment_169943"><p><a href="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-4.-Example-of-messages-left-in-the-code-by-the-BlackLotus-author.png"><img src="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-4.-Example-of-messages-left-in-the-code-by-the-BlackLotus-author.png" alt="" width="930" height="304" srcset="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-4.-Example-of-messages-left-in-the-code-by-the-BlackLotus-author.png 930w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-4.-Example-of-messages-left-in-the-code-by-the-BlackLotus-author-300x98.png 300w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-4.-Example-of-messages-left-in-the-code-by-the-BlackLotus-author-768x251.png 768w" sizes="(max-width: 930px) 100vw, 930px"/></a></p><p><em>Figure 4. Example of messages left in the code by the BlackLotus author</em></p></div>
<h2>Installation process</h2>
<p>We start with analysis of the BlackLotus installers. The bootkit seems to be distributed in a form of installers that come in two versions – offline and online. The difference between these two is in the way they obtain legitimate (but vulnerable) Windows binaries, later used for bypassing Secure Boot.</p>
<ul>
<li>In offline versions, Windows binaries are embedded in the installer</li>
<li>In online versions, Windows binaries are downloaded directly from the Microsoft symbol store. So far, we’ve seen the following Windows binaries being abused by the BlackLotus bootkit:
<ul>
<li><span>https://msdl.microsoft.com/download/symbols/bootmgfw.efi/7144BCD31C0000/bootmgfw.efi</span></li>
<li><span>https://msdl.microsoft.com/download/symbols/bootmgr.efi/98B063A61BC000/bootmgr.efi</span></li>
<li><span>https://msdl.microsoft.com/download/symbols/hvloader.efi/559F396411D000/hvloader.efi</span></li>
</ul>
</li>
</ul>
<p>The goal of the installer is clear – it’s responsible for disabling Windows security features such as BitLocker disk encryption and HVCI, and for deployment of multiple files, including the malicious bootkit, to the ESP. Once finished, it reboots the compromised machine to let the dropped files do their job – to make sure the self-signed UEFI bootkit will be silently executed on every system start, regardless of UEFI Secure Boot protection status.</p>
<h3><a id="step-0"></a>Step 0 – Initialization and (potential) elevation</h3>
<p>When the installer is executed, it checks whether it has enough privileges (at least admin required) to deploy the rest of the files to the ESP and perform other actions requiring elevated process – like turning off HVCI or disabling BitLocker. If it’s not the case, it tries to elevate by executing the installer again by using the UAC bypass method described in detail here: <a href="https://github.com/hfiref0x/UACME/issues/111" target="_blank" rel="noopener">UAC bypass via Program Compatibility assistant</a>.</p>
<p>With the necessary privileges, it continues, checking the UEFI Secure Boot status by reading the value of the SecureBoot UEFI variable using an available Windows API function, and determining the Windows version by directly accessing the <a href="https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/ntexapi_x/kuser_shared_data/index.htm" target="_blank" rel="noopener">KUSER_SHARED_DATA</a> structure fields <span>NtMajorVersion</span> and <span>NtMinorVersion</span> in memory. It does so to decide whether or not bypassing UEFI Secure Boot is necessary to deploy the bootkit on the victim’s system (since Secure Boot support was first added in Windows 8 and might not be enabled on any given machine).</p>
<p>Before proceeding to the next steps, it renames the legitimate Windows Boot Manager (<span>bootmgfw.efi</span>) binary located in the <span>ESP:\EFI\Microsoft\Boot\</span> directory to <span>winload.efi</span>. This renamed<span> bootmgfw.efi</span> backup is later used by the bootkit to launch the OS, or to recover the original boot chain if the “uninstall” command is received from the C&amp;C server – more in the<em> <a href="#cc-communication">C&amp;C communication</a> </em>section.</p>
<h3>Step 1 – Deploying files</h3>
<p>If UEFI Secure Boot is enabled, the installer proceeds with dropping multiple files into the <span>ESP:/EFI/Microsoft/Boot/</span> and <span>ESP:/system32/</span> directories. While the former is a standard directory used by Windows, the latter is a custom folder created by the installer.</p>
<p>A list of files dropped by the installer with a short explanation of the role of each file in the execution chain is provided in Table 1. We will explain in detail how the execution chain works later; now just note that several legitimate Microsoft-signed files are dropped along with the malicious ones.</p>
<p><em>Table 1. Files deployed by the BlackLotus installer on systems with UEFI Secure Boot enabled</em></p>

<table id="tablepress-1236">
<thead>
<tr>
	<th>Folder</th><th>Filename</th><th>Description</th>
</tr>
</thead>
<tbody>
<tr>
	<td rowspan="5"><span>ESP:\EFI\Microsoft\Boot</span></td><td><span>grubx64.efi</span></td><td>BlackLotus bootkit, malicious self-signed UEFI application.</td>
</tr>
<tr>
	<td><span>bootload.efi</span></td><td>Legitimate Microsoft-signed <span>shim</span> binary (temporary name, later replaces <span>bootmgfw.efi</span> after <a href="https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2022-21894" rel="noopener" target="_blank">CVE-2022-21894</a> exploitation).</td>
</tr>
<tr>
	<td><span>bootmgfw.efi</span></td><td>Legitimate, but vulnerable (<a href="https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2022-21894" rel="noopener" target="_blank">CVE-2022-21894</a>) Windows Boot Manager binary, embedded in the installer or downloaded directly from the Microsoft Symbol Store.</td>
</tr>
<tr>
	<td><span>BCD</span></td><td>Attackers’ custom  <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/boot-options-in-windows" rel="noopener" target="_blank">Boot Configuration Data</a> (BCD) store  used in  <a href="https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2022-21894" rel="noopener" target="_blank">CVE-2022-21894</a>   exploitation chain.</td>
</tr>
<tr>
	<td><span>BCDR</span></td><td>Backup of victim’s original BCD store.</td>
</tr>
<tr>
	<td rowspan="5"><span>ESP:\system32</span></td><td><span>hvloader.efi</span></td><td>Legitimate, but vulnerable (<a href="https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2022-21894" rel="noopener" target="_blank">CVE-2022-21894</a>) Windows Hypervisor Loader binary, embedded inside an installer or downloaded directly from the Microsoft Symbol Store.</td>
</tr>
<tr>
	<td><span>bootmgr.efi</span></td><td>Legitimate, but vulnerable (<a href="https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2022-21894" rel="noopener" target="_blank">CVE-2022-21894</a>) Windows Boot Manager binary, embedded inside an installer or downloaded directly from the Microsoft Symbol Store.</td>
</tr>
<tr>
	<td><span>mcupdate_AuthenticAMD.dll</span></td><td>Malicious self-signed native PE binary. This file is executed by the <span>hvloader.efi</span> after successful CVE-2022-21894 exploitation (on systems using an AMD CPU).</td>
</tr>
<tr>
	<td><span>mcupdate_GenuineIntel.dll</span></td><td>Malicious self-signed native PE binary. This file is executed by the <span>hvloader.efi</span> after successful <a href="https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2022-21894" rel="noopener" target="_blank">CVE-2022-21894 </a>exploitation (on systems using an Intel CPU).</td>
</tr>
<tr>
	<td><span>BCD</span></td><td>Attackers’ custom BCD used in <a href="https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2022-21894" rel="noopener" target="_blank">CVE-2022-21894</a> exploitation chain.</td>
</tr>
</tbody>
</table>

<p>In cases when the victim is running a Windows version not supporting UEFI Secure Boot, or in the case when it’s disabled, the deployment is quite straightforward. The only thing that is needed to deploy the malicious bootkit is to replace the existing Windows Boot Manager (<span>bootmgfw.efi</span>) binary in the <span>ESP:\EFI\Microsoft\Boot\</span> directory, with the attackers’ own self-signed malicious UEFI application. Since UEFI Secure Boot is disabled (and thus no integrity verification is performed during the boot), exploitation is not necessary and the UEFI firmware simply executes the malicious boot manager without causing any security violations.</p>
<h3><a id="step-2"></a>Step 2 – Disabling Hypervisor-protected Code Integrity (HVCI)</h3>
<p>To be able to run custom unsigned kernel code later, the installer has to make sure that <a href="https://learn.microsoft.com/en-us/windows-hardware/design/device-experiences/oem-vbs" target="_blank" rel="noopener">HVCI</a> is disabled on the system. One of our ESET colleagues wrote a very informative blogpost on this topic in 2022 (<a href="https://www.welivesecurity.com/2022/01/11/signed-kernel-drivers-unguarded-gateway-windows-core/" target="_blank" rel="noopener">Signed kernel drivers – Unguarded gateway to Windows’ core</a>):</p>
<p><em>Virtualization-based security (VBS) offers several protection features with the most prominent one being Hypervisor-Protected Code Integrity (HVCI), which also comes as a standalone feature. HVCI enforces code integrity in the kernel and allows only signed code to be executed. It effectively prevents vulnerable drivers from being abused to execute unsigned kernel code or load malicious drivers (regardless of the exploitation method used) and it seems that malware abusing vulnerable drivers to load malicious code was one of the <a href="https://www.microsoft.com/en-us/security/blog/2021/01/11/new-surface-pcs-enable-virtualization-based-security-vbs-by-default-to-empower-customers-to-do-more-securely/" target="_blank" rel="noopener">main motivations behind Microsoft implementing this feature</a>.</em></p>
<p>As shown in Figure 5, to disable this feature, the installer sets the Enabled registry value under the <span>HypervisorEnforcedCodeIntegrity</span> registry key to zero.</p>
<div id="attachment_169944"><p><a href="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-5.-Hex-Rays-decompiled-code-of-BlackLotus-installer-function-responsible-for-disabling-HVCI.png"><img src="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-5.-Hex-Rays-decompiled-code-of-BlackLotus-installer-function-responsible-for-disabling-HVCI.png" alt="" width="1463" height="690" srcset="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-5.-Hex-Rays-decompiled-code-of-BlackLotus-installer-function-responsible-for-disabling-HVCI.png 1463w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-5.-Hex-Rays-decompiled-code-of-BlackLotus-installer-function-responsible-for-disabling-HVCI-300x141.png 300w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-5.-Hex-Rays-decompiled-code-of-BlackLotus-installer-function-responsible-for-disabling-HVCI-768x362.png 768w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-5.-Hex-Rays-decompiled-code-of-BlackLotus-installer-function-responsible-for-disabling-HVCI-1024x483.png 1024w" sizes="(max-width: 1463px) 100vw, 1463px"/></a></p><p><em>Figure 5. Hex-Rays decompiled code of BlackLotus installer function responsible for disabling HVCI</em></p></div>
<h3><a id="step-3"></a>Step 3 – Disabling BitLocker</h3>
<p>The next feature deactivated by the installer is <a href="https://learn.microsoft.com/en-us/windows/security/information-protection/bitlocker/bitlocker-overview" target="_blank" rel="noopener">BitLocker Drive Encryption</a>. The reason for this is that BitLocker can be used in a combination with <a href="https://learn.microsoft.com/en-us/windows/security/information-protection/tpm/trusted-platform-module-overview" target="_blank" rel="noopener">Trusted Platform Module (TPM)</a> to ensure that various boot files and configurations, including Secure Boot, haven’t been tampered with since BitLocker drive encryption was configured on the system. Considering that the installer modifies the Windows boot chain on a compromised machine, keeping BitLocker on for systems with TPM support would lead to a BitLocker recovery screen at the next bootup and would tip the victim off that the system had been compromised.</p>
<p>To disable this protection, the BlackLotus installer:</p>
<ul>
<li>walks through all volumes under the <span>Root\CIMV2\Security\MicrosoftVolumeEncryption</span> WMI namespace and checks their protection status by calling the <span>GetProtectionStatus</span> method of the <span>Win32_EncryptableVolume</span> WMI class</li>
<li>for those protected by BitLocker, it calls the <span>DisableKeyProtectors</span> method with the <span>DisableCount</span> parameter set to zero, meaning that the protection will be suspended until it is manually enabled</li>
</ul>
<p>With the necessary protections disabled and all files deployed, the installer registers itself to be deleted during the next system restart and reboots the machine to proceed to the exploitation of CVE-2022-21894.</p>
<h2>Bypassing Secure Boot and establishing persistence</h2>
<p>In this part, we take a closer look at how BlackLotus achieves persistence on systems with UEFI Secure Boot enabled. As the execution chain we are about to describe is quite complex, we will first explain basic principles and then dig deeper into technical details.</p>
<p>In a nutshell, this process consists of two key steps:</p>
<ol>
<li>Exploiting CVE-2022-21894 to bypass the Secure Boot feature and install the bootkit. This allows arbitrary code execution in early boot phases, where the platform is still owned by firmware and UEFI Boot Services functions are still available. This allows attackers to do many things that they should not be able to do on a machine with UEFI Secure Boot enabled without having physical access to it, such as modifying Boot-services-only NVRAM variables. And this is what attackers take advantage of to set up persistence for the bootkit in the next step. More information about exploitation can be found in the <a href="#exploiting-cve-2022-21894"><em>Exploiting CVE-2022-21894</em></a> section.</li>
<li>Setting persistence by writing its own MOK to the <span>MokList</span>, Boot-services-only NVRAM variable. By doing this, it can use a legitimate Microsoft-signed <span>shim</span> for loading its self-signed (signed by the private key belonging to the key written to <span>MokList</span>) UEFI bootkit instead of exploiting the vulnerability on every boot. More about this in the<em> <a href="#bootkit-persistence">Bootkit persistence</a> </em>section.</li>
</ol>
<p>To make the detailed analysis in the next two sections easier, we will follow the steps shown in the execution diagram, Figure 6.</p>
<div id="attachment_169945"><p><a href="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-6.-Bypassing-Secure-Boot-and-setting-up-persistence-using-MOK.png"><img src="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-6.-Bypassing-Secure-Boot-and-setting-up-persistence-using-MOK.png" alt="" width="1199" height="2000" srcset="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-6.-Bypassing-Secure-Boot-and-setting-up-persistence-using-MOK.png 1199w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-6.-Bypassing-Secure-Boot-and-setting-up-persistence-using-MOK-180x300.png 180w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-6.-Bypassing-Secure-Boot-and-setting-up-persistence-using-MOK-768x1281.png 768w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-6.-Bypassing-Secure-Boot-and-setting-up-persistence-using-MOK-614x1024.png 614w" sizes="(max-width: 1199px) 100vw, 1199px"/></a></p><p><em>Figure 6. Bypassing Secure Boot and setting up persistence using MOK</em></p></div>
<h3><a id="exploiting-cve-2022-21894"></a>Exploiting CVE-2022-21894</h3>
<p>To bypass Secure Boot, BlackLotus uses the <a href="https://github.com/Wack0/CVE-2022-21894" target="_blank" rel="noopener">baton drop (CVE-2022-21894): Secure Boot Security Feature Bypass Vulnerability</a>. Despite its high impact on system security, this vulnerability did not get as much public attention as it deserved. Although the vulnerability was fixed in Microsoft’s January 2022 update, its exploitation is still possible because the affected binaries have still not been added to the <a href="https://uefi.org/revocationlistfile" target="_blank" rel="noopener">UEFI revocation list</a>. As a result, attackers can bring their own copies of vulnerable binaries to their victims’ machines to exploit this vulnerability and bypass Secure Boot on up-to-date UEFI systems.</p>
<p>Moreover, a Proof of Concept (PoC) exploit for this vulnerability has been publicly available since August 2022. Considering the date of the first BlackLotus VirusTotal submission (see Figure 1), the malware developer has likely just adapted the available PoC to their needs without any need of deep understanding of how this exploit works.</p>
<p>Let’s start with a brief introduction to the vulnerability, mostly summarizing key points from the write-up published along with the <a href="https://github.com/Wack0/CVE-2022-21894" target="_blank" rel="noopener">PoC on GitHub</a>:</p>
<ul>
<li>Affected Windows Boot Applications (such as <span>bootmgr.efi</span>, <span>hvloader.efi</span>, <span>winload.efi</span>…) allow removing a serialized Secure Boot policy from memory – before it gets loaded by the application – by using the <span>truncatememory</span> BCD boot option.</li>
<li>This allows attackers to use other dangerous BCD options like <span>bootdebug</span>, <span>testsigning</span>, or <span>nointegritychecks</span>, thus breaking Secure Boot.</li>
<li>There are various ways to exploit this vulnerability – three of them are published in the PoC repository.</li>
<li>As an example, one of the PoCs shows how it can be exploited to make the legitimate <span>hvloader.efi</span> load an arbitrary, self-signed <span>mcupdate_&lt;platform&gt;.dll</span> binary (where <span>&lt;platform&gt;</span> can be <span>GenuineIntel</span> or <span>AuthenticAMD</span>, based on the machine’s CPU.).</li>
</ul>
<p>Now, we continue with describing how BlackLotus exploits this vulnerability (numbers in the list below describe corresponding steps in Figure 6):</p>
<ol>
<li>After the installer reboots the machine, the UEFI firmware proceeds with loading a first boot option. For Windows systems, the first boot option is by default <span>bootmgfw.efi</span> located in the <span>ESP:/EFI/Microsoft/Boot</span> folder on the ESP. This time, instead of executing the original victim’s <span>bootmgfw.efi</span> (which was previously renamed <span>winload.efi</span> by the installer), the firmware executes the vulnerable one – deployed by the installer.</li>
<li>After <span>bootmgfw.efi</span> is executed, it loads the BCD boot options, previously modified by the installer. Figure 7 shows a comparison of the legitimate BCD and the modified one.</li>
<li>As you can see in Figure 7 (path underlined with green), the legitimate Windows Boot Manager would normally load the Windows OS loader (<span>\WINDOWS\system32\winload.efi</span>) as a default boot application. But this time, with the modified BCD, it continues with loading the vulnerable <span>ESP:\system32\bootmgr.efi</span>, with the <span>avoidlowmemory</span> BCD element set to value <span>0x10000000</span> and the <span>custom:22000023</span> BCD element pointing to another attackers’ BCD stored in <span>ESP:\system32\bcd</span>. The explanation of using these elements can be found in the published <a href="https://github.com/Wack0/CVE-2022-21894" target="_blank" rel="noopener">PoC</a>:</li>
</ol>
<p><span><em>The attacker needs to ensure the serialised Secure Boot Policy is allocated above a known physical address.</em></span></p>
<div id="attachment_169946"><p><a href="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-7.-Legitimate-BCD-store-BEFORE-vs-the-one-used-by-the-BlackLotus-installer-AFTER.png"><img src="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-7.-Legitimate-BCD-store-BEFORE-vs-the-one-used-by-the-BlackLotus-installer-AFTER.png" alt="" width="1763" height="813" srcset="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-7.-Legitimate-BCD-store-BEFORE-vs-the-one-used-by-the-BlackLotus-installer-AFTER.png 1763w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-7.-Legitimate-BCD-store-BEFORE-vs-the-one-used-by-the-BlackLotus-installer-AFTER-300x138.png 300w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-7.-Legitimate-BCD-store-BEFORE-vs-the-one-used-by-the-BlackLotus-installer-AFTER-768x354.png 768w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-7.-Legitimate-BCD-store-BEFORE-vs-the-one-used-by-the-BlackLotus-installer-AFTER-1024x472.png 1024w" sizes="(max-width: 1763px) 100vw, 1763px"/></a></p><p><em>Figure 7. Legitimate BCD store (BEFORE) vs the one used by the BlackLotus installer (AFTER)</em></p></div>
<ol start="4">
<li>In the next step, the executed <span>ESP:\system32\bootmgr.efi</span> loads that additional BCD located in <span>ESP:\system32\bcd</span>. Parsed content of this additional BCD is shown in Figure 8.</li>
</ol>
<div id="attachment_169947"><p><a href="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-8.-Second-BCD-dropped-by-the-BlackLotus-installer-–-used-to-exploit-CVE-2022-21894.png"><img src="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-8.-Second-BCD-dropped-by-the-BlackLotus-installer-–-used-to-exploit-CVE-2022-21894.png" alt="" width="917" height="645" srcset="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-8.-Second-BCD-dropped-by-the-BlackLotus-installer-–-used-to-exploit-CVE-2022-21894.png 917w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-8.-Second-BCD-dropped-by-the-BlackLotus-installer-–-used-to-exploit-CVE-2022-21894-300x211.png 300w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-8.-Second-BCD-dropped-by-the-BlackLotus-installer-–-used-to-exploit-CVE-2022-21894-768x540.png 768w" sizes="(max-width: 917px) 100vw, 917px"/></a></p><p><em>Figure 8. Second BCD dropped by the BlackLotus installer – used to exploit CVE-2022-21894</em></p></div>
<ol start="5">
<li>Because of options loaded from the BCD file shown in Figure 8, <span>bootmgr.efi</span> continues with loading another vulnerable Windows Boot Application deployed by the installer – <span>ESP:\system32\hvloader.efi</span> – which is the Windows Hypervisor Loader. More importantly, additional BCD options are specified in the same BCD file (see Figure 8):</li>
</ol>
<p><span>And this is where the magic happens. As the serialized Secure Boot policy should be loaded in physical addresses above <span>0x10000000</span> (because of <span>avoidlowmemory</span> used in previous steps), specifying the <span>truncatememory</span> element will effectively remove it – thus, break the Secure Boot and allow the use of dangerous BCD options like <span>nointegritychecks</span> or <span>testsigning</span>. By using these options, the attackers can make the <span>hvloader.efi</span> execute their own, self-signed code. </span></p>
<ol start="6">
<li>To do this, the same trick as described in the <a href="https://github.com/Wack0/CVE-2022-21894" target="_blank" rel="noopener">PoC</a> is used: during its execution, the legitimate <span>hvloader.efi</span> loads and executes the <span>mcupdate_{GenuineIntel| AuthenticAMD}.dll</span> native binary from the <span>&lt;device&gt;:\&lt;SystemRoot&gt;\system32\</span> directory. Commented Hex-Rays decompiled code of the function from <span>hvloader.efi</span> responsible for loading this mcupdate*.dll binary is shown in Figure 9. Note that <span>hvloader.efi</span> would normally load this legitimate <span>mcupdate*.dll</span> binary from the &lt;OS_partition&gt;<span>:\Windows\system32</span>, but this time the malicious attackers’ self-signed <span>mcupdate*.dll</span> is executed from a custom ESP directory previously created by the installer (<span>ESP:\system32</span>). It’s caused by the BCD options <span>device</span> and <span>systemroot</span> used in the BCD from Figure 8 specifying the current device as <span>boot</span> – meaning the ESP – and also specifying SystemRoot to be the root (<span>\</span>) directory on this device.</li>
</ol>
<div id="attachment_169948"><p><a href="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-9.-Hex-Rays-decompilation-of-the-BtLoadUpdateDll-function-from-the-legitimate-hvloader.efi-responsible-for-loading-mcupdate_.dll_.png"><img src="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-9.-Hex-Rays-decompilation-of-the-BtLoadUpdateDll-function-from-the-legitimate-hvloader.efi-responsible-for-loading-mcupdate_.dll_.png" alt="" width="1114" height="786" srcset="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-9.-Hex-Rays-decompilation-of-the-BtLoadUpdateDll-function-from-the-legitimate-hvloader.efi-responsible-for-loading-mcupdate_.dll_.png 1114w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-9.-Hex-Rays-decompilation-of-the-BtLoadUpdateDll-function-from-the-legitimate-hvloader.efi-responsible-for-loading-mcupdate_.dll_-300x212.png 300w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-9.-Hex-Rays-decompilation-of-the-BtLoadUpdateDll-function-from-the-legitimate-hvloader.efi-responsible-for-loading-mcupdate_.dll_-768x542.png 768w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-9.-Hex-Rays-decompilation-of-the-BtLoadUpdateDll-function-from-the-legitimate-hvloader.efi-responsible-for-loading-mcupdate_.dll_-1024x722.png 1024w" sizes="(max-width: 1114px) 100vw, 1114px"/></a></p><p><em>Figure 9. Hex-Rays decompilation of the </em><span>BtLoadUpdateDll</span> <em>function from the legitimate </em><span>hvloader.efi</span><em>, responsible for loading </em><span>mcupdate_*.dll</span></p></div>
<ol start="7">
<li>Now, as the attackers’ own self-signed <span>mcupdate*.dll</span> is loaded and executed, it continues with executing the final component in this chain – an embedded MokInstaller (UEFI Application) – see Figure 10 for details about how it’s done.</li>
</ol>
<div id="attachment_169949"><p><a href="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-10.-Hex-Rays-decompiled-code-of-the-malicious-self-signed-mcupdate.dll-binary.png"><img src="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-10.-Hex-Rays-decompiled-code-of-the-malicious-self-signed-mcupdate.dll-binary.png" alt="" width="1620" height="1032" srcset="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-10.-Hex-Rays-decompiled-code-of-the-malicious-self-signed-mcupdate.dll-binary.png 1620w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-10.-Hex-Rays-decompiled-code-of-the-malicious-self-signed-mcupdate.dll-binary-300x191.png 300w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-10.-Hex-Rays-decompiled-code-of-the-malicious-self-signed-mcupdate.dll-binary-768x489.png 768w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-10.-Hex-Rays-decompiled-code-of-the-malicious-self-signed-mcupdate.dll-binary-1024x652.png 1024w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-10.-Hex-Rays-decompiled-code-of-the-malicious-self-signed-mcupdate.dll-binary-65x42.png 65w" sizes="(max-width: 1620px) 100vw, 1620px"/></a></p><p><em>Figure 10. Hex-Rays decompiled code of the malicious self-signed </em><span>mcupdate*.dll</span><em> binary</em></p></div>
<h3><a id="bootkit-persistence"></a>Bootkit persistence</h3>
<p>Now, the MokInstaller can proceed with setting up persistence by enrolling the attackers’ MOK into the NVRAM variable and setting up the legitimate Microsoft-signed <span>shim</span> binary as a default bootloader. Before proceeding to details, a little theory about <span>shim</span> and MOK.</p>
<p><span>shim</span> is a first stage UEFI bootloader developed by Linux developers to make various Linux distributions work with UEFI Secure Boot. It’s a simple application and its purpose is to load, verify, and execute another application – in case of Linux systems, it’s usually the GRUB bootloader. It works in a way that Microsoft signs only a <span>shim</span>, and the <span>shim</span> takes care of the rest – it can verify the integrity of a second-stage bootloader by using keys from <span>db</span> UEFI variable, and also embeds its own list of “allowed” or “revoked” keys or hashes to make sure that components trusted by both – platform and shim developer (e.g. Canonical, RedHat, etc.,) – are allowed to be executed. In addition to these lists, <span>shim</span> also allows the use of an external keys database managed by the user, known as the MOK list. Figure 11 nicely illustrates how UEFI Secure Boot with MOK works.</p>
<p>This MOK database is stored in a Boot-only NVRAM variable named <span>MokList</span>. Without exploiting a vulnerability like the one described above, physical access is required to modify it on a system with UEFI Secure Boot enabled (it’s available only during boot, before the OS loader calls the UEFI Boot Services function <span>ExitBootServices</span>). However, by exploiting this vulnerability, attackers are able to bypass UEFI Secure Boot and execute their own self-signed code before a call to <span>ExitBootServices</span>, so they can easily enroll their own key (by modifying the <span>MokList</span> NVRAM variable) to make the shim execute any application – signed by that enrolled key – without causing a security violation.</p>

<ol start="8">
<li>Continuing with describing the flow from Figure 6 – step 8… The MokInstaller UEFI application continues with setting up persistence for the BlackLotus UEFI bootkit and covering the tracks of exploitation by:</li>
<li>In the end, it reboots the machine to make the deployed shim execute the self-signed bootkit dropped to <span>\EFI\Microsoft\Boot\grubx64.efi</span> by the installer (<span>grubx64.efi</span> is usually the default second-stage bootloader executed by a <span>shim</span> on x86-64 systems).</li>
</ol>
<p>Code performing the actions described in the last two steps is shown in Figure 12.</p>
<div id="attachment_169952"><p><a href="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-12.-Hex-Rays-decompiled-code-–-MokInstaller-UEFI-app-setting-up-persistence-for-the-BlackLotus-bootkit.png"><img src="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-12.-Hex-Rays-decompiled-code-–-MokInstaller-UEFI-app-setting-up-persistence-for-the-BlackLotus-bootkit.png" alt="" width="1523" height="660" srcset="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-12.-Hex-Rays-decompiled-code-–-MokInstaller-UEFI-app-setting-up-persistence-for-the-BlackLotus-bootkit.png 1523w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-12.-Hex-Rays-decompiled-code-–-MokInstaller-UEFI-app-setting-up-persistence-for-the-BlackLotus-bootkit-300x130.png 300w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-12.-Hex-Rays-decompiled-code-–-MokInstaller-UEFI-app-setting-up-persistence-for-the-BlackLotus-bootkit-768x333.png 768w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-12.-Hex-Rays-decompiled-code-–-MokInstaller-UEFI-app-setting-up-persistence-for-the-BlackLotus-bootkit-1024x444.png 1024w" sizes="(max-width: 1523px) 100vw, 1523px"/></a></p><p><em>Figure 12. Hex-Rays decompiled code – MokInstaller UEFI app setting up persistence for the BlackLotus bootkit</em></p></div>
<h2>BlackLotus UEFI bootkit</h2>
<p>Once the persistence is configured, the BlackLotus bootkit is executed on every system start. The bootkit’s goal is to deploy a kernel driver and a final user-mode component – the HTTP downloader. During its execution, it tries to disable additional Windows security features – Virtualization-Based Security (VBS) and Windows Defender – to raise the chance of successful deployment and stealthy operation. Before jumping to the details about how that is done, let’s summarize the basics about the kernel driver and HTTP downloader:</p>
<ul>
<li>The kernel driver is responsible for
<ul>
<li>Deploying the next component of the chain – an HTTP downloader.</li>
<li>Keeping the loader alive in case of termination.</li>
<li>Protecting bootkit files from being removed from ESP.</li>
<li>Executing additional kernel payloads, if so instructed by the HTTP downloader.</li>
<li>Uninstalling the bootkit, if so instructed by the HTTP downloader.</li>
</ul>
</li>
<li>The HTTP downloader is responsible for:
<ul>
<li>Communicating with its C&amp;C.</li>
<li>Executing commands received from the C&amp;C.</li>
<li>Downloading and executing payloads received from the C&amp;C (supports both kernel payloads and user-mode payloads).</li>
</ul>
</li>
</ul>
<p>The full execution flow (simplified), from the installer to HTTP downloader, is shown in Figure 13. We describe these individual steps in more detail in the next section.</p>
<div id="attachment_169954"><p><a href="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-13.-Diagram-showing-execution-of-the-BlackLotus-UEFI-bootkit-1.png"><img src="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-13.-Diagram-showing-execution-of-the-BlackLotus-UEFI-bootkit-1.png" alt="" width="1054" height="2000" srcset="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-13.-Diagram-showing-execution-of-the-BlackLotus-UEFI-bootkit-1.png 1054w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-13.-Diagram-showing-execution-of-the-BlackLotus-UEFI-bootkit-1-158x300.png 158w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-13.-Diagram-showing-execution-of-the-BlackLotus-UEFI-bootkit-1-768x1457.png 768w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-13.-Diagram-showing-execution-of-the-BlackLotus-UEFI-bootkit-1-540x1024.png 540w" sizes="(max-width: 1054px) 100vw, 1054px"/></a></p><p><em>Figure 13. Diagram showing execution of the BlackLotus UEFI bootkit</em></p></div>
<h2><a id="blacklotus-execution-flow"></a>BlackLotus execution flow</h2>
<p>Execution steps are as follows (these steps are shown in Figure 13):</p>
<ol>
<li>As a first step, the UEFI firmware executes the default Windows boot option, which is the file usually stored in <span>\EFI\Microsoft\Boot\bootmgfw.efi</span>. As we described earlier (<em><a href="#restoring-the-victim-original-bcd-store">Bootkit persistence section, 8 .a</a></em>), the MokInstaller binary replaced this file with a legitimate signed <span>shim</span>.</li>
<li>When the <span>shim</span> is executed, it reads the <span>MokList</span> NVRAM variable, and uses the certificate previously stored inside by the attackers to verify the second-stage bootloader – the self-signed BlackLotus UEFI bootkit located in <span>\EFI\Microsoft\Boot\grubx64.efi</span>.</li>
<li>When verified, the <span>shim</span> executes the bootkit.</li>
<li>The bootkit starts with creating the Boot-only <span>VbsPolicyDisable</span> NVRAM variable. As described <a href="https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Cyber-Sicherheit/SiSyPHus/Workpackage6_Virtual_Secure_Mode.pdf?__blob=publicationFile&amp;v=1" target="_blank" rel="noopener">here</a>, this variable is evaluated by the Windows OS loader during boot and if defined, the core VBS features, such as HVCI and Credential Guard will not be initialized.</li>
<li>In the following steps (5. a–e), the bootkit continues with a common pattern used by UEFI bootkits. It intercepts the execution of components included in the typical Windows boot flow, such as Windows Boot Manager, Windows OS loader, and Windows OS kernel, and hooks some of their functions in memory. As a bonus, it also attempts to disable Windows Defender by patching some of its drivers. All this to achieve its payload’s execution in the early stages of the OS startup process and to avoid detection. The following functions are hooked or patched:</li>
</ol>
<div id="attachment_169955"><p><a href="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-14.-Hex-Rays-decompiled-code-of-OslArchTransferToKernel-hook-–-patching-Windows-Defender-drivers-and-searching-for-the-disk.sys-entry-point.png"><img src="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-14.-Hex-Rays-decompiled-code-of-OslArchTransferToKernel-hook-–-patching-Windows-Defender-drivers-and-searching-for-the-disk.sys-entry-point.png" alt="" width="1236" height="847" srcset="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-14.-Hex-Rays-decompiled-code-of-OslArchTransferToKernel-hook-–-patching-Windows-Defender-drivers-and-searching-for-the-disk.sys-entry-point.png 1236w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-14.-Hex-Rays-decompiled-code-of-OslArchTransferToKernel-hook-–-patching-Windows-Defender-drivers-and-searching-for-the-disk.sys-entry-point-300x206.png 300w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-14.-Hex-Rays-decompiled-code-of-OslArchTransferToKernel-hook-–-patching-Windows-Defender-drivers-and-searching-for-the-disk.sys-entry-point-768x526.png 768w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-14.-Hex-Rays-decompiled-code-of-OslArchTransferToKernel-hook-–-patching-Windows-Defender-drivers-and-searching-for-the-disk.sys-entry-point-1024x702.png 1024w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-14.-Hex-Rays-decompiled-code-of-OslArchTransferToKernel-hook-–-patching-Windows-Defender-drivers-and-searching-for-the-disk.sys-entry-point-151x103.png 151w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-14.-Hex-Rays-decompiled-code-of-OslArchTransferToKernel-hook-–-patching-Windows-Defender-drivers-and-searching-for-the-disk.sys-entry-point-97x65.png 97w" sizes="(max-width: 1236px) 100vw, 1236px"/></a></p><p><em>Figure 14. Hex-Rays decompiled code of </em><span>OslArchTransferToKernel</span><em> hook – patching Windows Defender drivers and searching for the </em><span>disk.sys</span><em> entry point</em></p></div>
<ol start="6">
<li>Next, when the OS kernel executes the <span>disk.sys</span> driver’s entry point, the installed hook jumps to the malicious kernel driver entry point. The malicious code in turn restores the original <span>disk.sys</span> to allow the system to function properly and waits until the <span>winlogon.exe</span> process starts.</li>
<li>When the malicious driver detects that the <span>winlogon.exe</span> process has started, it injects and executes the final user-mode component – the HTTP downloader – into it.</li>
</ol>
<h3>Kernel driver</h3>
<p>The kernel driver is responsible for four main tasks:</p>
<ul>
<li>Injecting the HTTP downloader into <span>winlogon.exe</span> and reinjecting it in case the thread terminated.</li>
<li>Protecting bootkit files deployed on the ESP from being removed.</li>
<li>Disarming the user-mode Windows Defender process <span>MsMpEngine.exe</span>.</li>
<li>Communicating with the HTTP downloader and if necessary, performing any commands.</li>
</ul>
<p>Let’s look at them one by one.</p>
<h3>HTTP downloader persistence</h3>
<p>The kernel driver is responsible for deployment of the HTTP downloader. When the driver starts, it waits until the process named <span>winlogon.exe</span> starts, before taking any other actions. Once the process has started, the driver decrypts the HTTP downloader binary, injects it into <span>winlogon.exe</span>’s address space, and executes it in a new thread. Then, the driver keeps periodically checking whether the thread is still running, and repeats the injection if necessary. The HTTP downloader won’t be deployed if a kernel debugger is detected by the driver.</p>
<h3><a id="protecting-bootkit-files-on-the-ESP-from-removal"></a>Protecting bootkit files on the ESP from removal</h3>
<p>To protect the bootkit’s files located on the ESP, the kernel driver uses a simple trick. It opens all files it wants to protect, duplicates and saves their handles, and uses the <span>ObSetHandleAttributes</span> kernel function specifying the <span>ProtectFromClose</span> flag inside <span>HandleFlags</span> (<a href="https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/ntobapi/object_handle_flag_information.htm" target="_blank" rel="noopener">OBJECT_HANDLE_FLAG_INFORMATION</a>) parameter to 1 – thus protecting the handles from being closed by any other processes. This will thwart any attempts to remove or modify the protected files. The following files are protected:</p>
<ul>
<li><span>ESP:\EFI\Microsoft\Boot\winload.efi</span></li>
<li><span>ESP:\EFI\Microsoft\Boot\bootmgfw.efi</span></li>
<li><span>ESP:\EFI\Microsoft\Boot\grubx64.efi</span></li>
</ul>
<p>Should a user try to delete these protected files, something like what is shown in Figure 15 will occur.</p>
<div id="attachment_169956"><p><a href="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-15.-An-attempt-to-delete-the-files-protected-by-BlackLotus-driver.png"><img src="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-15.-An-attempt-to-delete-the-files-protected-by-BlackLotus-driver.png" alt="" width="939" height="364" srcset="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-15.-An-attempt-to-delete-the-files-protected-by-BlackLotus-driver.png 939w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-15.-An-attempt-to-delete-the-files-protected-by-BlackLotus-driver-300x116.png 300w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-15.-An-attempt-to-delete-the-files-protected-by-BlackLotus-driver-768x298.png 768w" sizes="(max-width: 939px) 100vw, 939px"/></a></p><p><em>Figure 15. An attempt to delete the files protected by BlackLotus driver</em></p></div>
<p>As another layer of protection, in case the user or security software would be able to unset the protection flag and close the handles, the kernel driver continuously monitors them, and causes a BSOD by calling the <span>KeBugCheck(INVALID_KERNEL_HANDLE)</span> function if any of the handles don’t exist anymore.</p>
<h3>Disarming the main Windows Defender process</h3>
<p>The kernel driver also tries to disarm the main Windows Defender process – <span>MsMpEng.exe</span>. It does so by removing all process’s token privileges by setting the <span>SE_PRIVILEGE_REMOVED</span> attribute to each of them. As a result, the Defender process should not be able to do its job – such as scanning files – properly. However, as this functionality is poorly implemented, it can be made ineffective by restarting the <span>MsMpEng.exe</span> process.</p>
<h3><a id="communication-with-the-http-downloader"></a>Communication with the HTTP downloader</h3>
<p>The kernel driver is capable of communicating with the HTTP downloader by using a named Event and Section. Names of the named objects used are generated based on the victim’s network adapter MAC address (ethernet). If a value of an octet is lower than 16, then 16 is added to it. The format of the generated objects names might vary in different samples. As an example, in one of the samples we analyzed, for the MAC address <span>00-1c-0b-cd-ef-34</span>, the generated names would be:</p>
<ul>
<li><span>\BaseNamedObjects\101c1b</span>: for the named section (only the first three octets of the MAC are used)</li>
<li><span>\BaseNamedObjects\<strong>Z</strong>01c1b</span>: for the named event – same as for the Section, but the first digit of the MAC address is replaced with <span>Z</span></li>
</ul>
<p>In case the HTTP downloader wants to pass some command to the kernel driver, it simply creates a named section, writes a command with associated data inside, and waits for the command to be processed by the driver by creating a named event and waiting until the driver triggers (or signals) it.</p>
<p>The driver supports the following self-explanatory commands:</p>
<ul>
<li>Install kernel driver</li>
<li>Uninstall BlackLotus</li>
</ul>
<p>A careful reader might notice the BlackLotus weak point here – even though the bootkit protects its components against removal, the kernel driver can be tricked to uninstall the bootkit completely by creating the abovementioned named objects and sending the uninstall command to it.</p>
<h2><a id="http-downloader"></a>HTTP downloader</h2>
<p>The final component is responsible for communication with a C&amp;C server and execution of any C&amp;C commands received from it. All payloads we were able to discover contain three commands. These commands are very straightforward and as the section name suggests, it’s mostly about downloading and executing additional payloads using various techniques.</p>
<h3><a id="cc-communication"></a>C&amp;C communication</h3>
<p>To communicate with its C&amp;C, the HTTP loader uses the HTTPS protocol. All information necessary for the communication is embedded directly in the downloader binary – including C&amp;C domains and HTTP resource paths used. The default interval for communication with a C&amp;C server is set to one minute, but can be changed based on the data from the C&amp;C. Each communication session with a C&amp;C starts with sending a beacon HTTP POST message to it. In samples we analyzed, the following HTTP resource paths can be specified in the HTTP POST headers:</p>
<ul>
<li><span>/network/API/hpb_gate[.]php</span></li>
<li><span>/API/hpb_gate[.]php</span></li>
<li><span>/gate[.]php</span></li>
<li><span>/hpb_gate[.]php</span></li>
</ul>
<p>The beacon message data is prepended with a <span>checkin</span>= string, containing basic information about the compromised machine – including a custom machine identifier (referred to as <span>HWID</span>), UEFI Secure Boot status, various hardware information, and a value that seems to be a BlackLotus build number. <span>HWID</span> is generated from the machine MAC address (ethernet) and a system volume serial number. The format of the message before encryption is as seen in Figure 16</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div id="crayon-63ffc76bc3e33525687111" data-settings=" minimize scroll-mouseover">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="hide">
					
				</td>
						<td><div><p><span>{</span></p><p><span>    </span><span>&#34;HWID&#34;</span><span>:</span><span>&#34;%s&#34;</span><span>,</span><span> </span></p><p><span>    </span><span>&#34;Session&#34;</span><span>:</span><span>&#34;%lu&#34;</span><span>,</span><span> </span></p><p><span>    </span><span>&#34;Owner&#34;</span><span>:</span><span>&#34;%s&#34;</span><span>,</span><span> </span></p><p><span>    </span><span>&#34;IP&#34;</span><span>:</span><span>&#34;%s&#34;</span><span>,</span><span> </span></p><p><span>    </span><span>&#34;OS&#34;</span><span>:</span><span>&#34;%s&#34;</span><span>,</span><span> </span></p><p><span>    </span><span>&#34;Edition&#34;</span><span>:</span><span>&#34;%s&#34;</span><span>,</span><span> </span></p><p><span>    </span><span>&#34;CPU&#34;</span><span>:</span><span>&#34;%s&#34;</span><span>,</span><span> </span></p><p><span>    </span><span>&#34;GPU&#34;</span><span>:</span><span>&#34;%s&#34;</span><span>,</span><span> </span></p><p><span>    </span><span>&#34;RAM&#34;</span><span>:</span><span>&#34;%lu&#34;</span><span>,</span><span> </span></p><p><span>    </span><span>&#34;Integrity&#34;</span><span>:</span><span>&#34;%lu&#34;</span><span>,</span><span> </span></p><p><span>    </span><span>&#34;SecureBoot&#34;</span><span>:</span><span>&#34;%i&#34;</span><span>,</span><span> </span></p><p><span>    </span><span>&#34;Build&#34;</span><span>:</span><span>&#34;%lu&#34;</span></p><p><span>}</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->

<p><em>Figure 16. Format of beacon message</em></p>
<p>Before sending the message to the C&amp;C, the data is first encrypted using an embedded RSA key, then URL-safe base64 encoded. During the analysis, we found two different RSA keys being used in the samples. An example of such an HTTP beacon request is shown in Figure 17.</p>
<div id="attachment_169957"><p><a href="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-17.-Example-of-a-beacon-HTTP-POST-message-generated-by-a-sample-from-VirusTotal-–-the-one-with-local-IPs-instead-of-real-CC-addresses.png"><img src="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-17.-Example-of-a-beacon-HTTP-POST-message-generated-by-a-sample-from-VirusTotal-–-the-one-with-local-IPs-instead-of-real-CC-addresses.png" alt="" width="613" height="452" srcset="https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-17.-Example-of-a-beacon-HTTP-POST-message-generated-by-a-sample-from-VirusTotal-–-the-one-with-local-IPs-instead-of-real-CC-addresses.png 613w, https://www.welivesecurity.com/wp-content/uploads/2023/03/Figure-17.-Example-of-a-beacon-HTTP-POST-message-generated-by-a-sample-from-VirusTotal-–-the-one-with-local-IPs-instead-of-real-CC-addresses-300x221.png 300w" sizes="(max-width: 613px) 100vw, 613px"/></a></p><p><em>Figure 17. Example of a beacon HTTP POST message (generated by a sample from VirusTotal – the one with local IPs instead of real C&amp;C addresses)</em></p></div>
<p>Data received from the C&amp;C as a response to the beacon message should start with the two-byte magic value HP; otherwise, the response is not processed further. If the magic value is correct, the data following the magic value is decrypted using 256-bit AES in CBC mode with abovementioned HWID string used as the key.</p>
<p>After decryption, the message is similar to the beacon, a JSON-formatted string, and specifies a command identifier (referred to as <span>Type</span>) and various additional parameters such as:</p>
<ul>
<li>C&amp;C communication interval</li>
<li>Execution method to use</li>
<li>Payload filename</li>
<li>Payload type based on file extension(<span>.sys</span>, <span>.exe</span>, or <span>.dll</span> supported)</li>
<li>Authentication token that is supposed to be used to request download of payload data</li>
<li>AES key used for decrypting the payload data</li>
</ul>
<p>All supported commands and their descriptions are listed in Table 2.</p>
<p><em>Table 2. C&amp;C commands</em></p>

<table id="tablepress-1237">
<thead>
<tr>
	<th>Command Type</th><th>Command Description</th>
</tr>
</thead>
<tbody>
<tr>
	<td>1</td><td>Download and execute a kernel driver, DLL, or a regular executable</td>
</tr>
<tr>
	<td>2</td><td>Download a payload, uninstall the bootkit, and execute the payload – likely used to update the bootkit</td>
</tr>
<tr>
	<td>3</td><td>Uninstall the bootkit and exit</td>
</tr>
</tbody>
</table>

<p>In these commands, the C&amp;C can specify, whether the payload should first be dropped to disk before executing it, or be executed directly in memory. In cases involving dropping the file to disk, the <span>ProgramData</span> folder on the OS volume is used as the destination folder and filename and extension are specified by the C&amp;C server. In the case of executing files directly in memory, <span>svchost.exe</span> is used as an injection target. When the C&amp;C sends a command requiring kernel driver cooperation, or an operator wants to execute code in kernel-mode, the mechanism described in the <a href="#communication-with-the-http-downloader"><em>Communication with the HTTP downloader</em></a> section is used.</p>
<h2>Anti-analysis tricks</h2>
<p>To make detection and analysis of this piece of malware harder, its author tried to limit visibility of standard file artifacts, such as text strings, imports, or other unencrypted embedded data to a minimum. Below is a summary of the techniques used.</p>
<ul>
<li>String and data encryption
<ul>
<li>All strings used within the samples are encrypted using a simple cipher.</li>
<li>All embedded files are encrypted using 256-bit AES in CBC mode.</li>
<li>Encryption keys for individual files can vary from sample to sample.</li>
<li>In addition to AES encryption, some files are also compressed using LZMS.</li>
</ul>
</li>
<li>Runtime-only API resolution
<ul>
<li>In all samples (when applicable), Windows APIs are always resolved exclusively during runtime and function hashes instead of function names are used to find the desired API function addresses in memory.</li>
<li>In some cases, a direct <span>syscall</span> instruction invocation is used to invoke the desired system function.</li>
</ul>
</li>
<li>Network communication
<ul>
<li>Communicates using HTTPS.</li>
<li>All messages sent to the C&amp;C by the HTTP downloader are encrypted using an embedded RSA public key.</li>
<li>All messages sent from the C&amp;C to the HTTP downloader are encrypted using a key derived from the victim’s machine environment or using an AES key provided by the C&amp;C.</li>
</ul>
</li>
<li>Anti-debug and anti-VM tricks – if used, usually placed right at the beginning of the entry point. Only casual sandbox or debugger detection tricks are used.</li>
</ul>
<h2>Mitigations and remediation</h2>
<ul>
<li>First of all, of course, keeping your system and its security product up to date is a must – to raise a chance that a threat will be stopped right at the beginning, before it’s able to achieve pre-OS persistence.</li>
<li>Then, the key step that needs to be taken to prevent usage of known vulnerable UEFI binaries for bypassing UEFI Secure Boot is their revocation in the UEFI revocation database (<span>dbx</span>) – on a Windows systems, <span>dbx</span> updates should be distributed using Windows Updates.</li>
<li>The problem is that revocation of broadly used Windows UEFI binaries can lead to making thousands of outdated systems, recovery images, or backups unbootable – and therefore, revocation often takes too long.</li>
<li>Note that revocation of the Windows applications used by BlackLotus would prevent installation of the bootkit, but as the installer would replace the victim’s bootloader with the revoked one, it could make the system unbootable. To recover in this case, an OS reinstall or just ESP recovery would resolve the issue.</li>
<li>If the revocation would happen after BlackLotus persistence is set, the bootkit would remain functional, as it uses a legitimate shim with custom MOK key for persistence. In this case, the safest mitigation solution would be to reinstall Windows and remove the attackers’ enrolled MOK key by using the <span>mokutil</span> utility (physical presence is required to perform this operation due to necessary user interaction with the MOK Manager during the boot).</li>
</ul>
<h2>Takeaways</h2>
<p>Many critical vulnerabilities affecting security of UEFI systems have been discovered in the last few years. Unfortunately, due the complexity of the whole UEFI ecosystem and related supply-chain problems, many of these vulnerabilities have left many systems vulnerable even a long time after the vulnerabilities have been fixed – or at least after we were told they were fixed. For a better image, here are some examples of the patch or revocation failures allowing UEFI Secure Boot bypasses just from the last year:</p>
<ul>
<li>First of all, of course, CVE-2022-21894 – the vulnerability exploited by BlackLotus. One year since the vulnerability was fixed, vulnerable UEFI binaries are still not revoked, allowing threats such as BlackLotus to stealthily operate on systems with UEFI Secure Boot enabled, thus providing victims a false sense of security.</li>
<li>Early in 2022, we disclosed several UEFI vulnerabilities that allow, among other things, disabling UEFI Secure Boot. Many devices affected are not supported by the OEM anymore, thus not fixed (even though these devices were not so old – like 3-5 years at the time of vulnerability disclosure). Read more in our blogpost: <a href="https://www.welivesecurity.com/2022/04/19/when-secure-isnt-secure-uefi-vulnerabilities-lenovo-consumer-laptops/" target="_blank" rel="noopener">When “secure” isn’t secure at all: High‑impact UEFI vulnerabilities discovered in Lenovo consumer laptops</a></li>
<li>Later in 2022, we discovered a <a href="https://twitter.com/ESETresearch/status/1590279782318878720" target="_blank" rel="noopener">few other UEFI vulnerabilities</a>, whose exploitation would also allow attackers to disable UEFI Secure Boot very easily. As pointed out by fellow researchers from <a href="https://binarly.io/posts/Firmware_Patch_Deep_Dive_Lenovo_Patches_Fail_to_Fix_Underlying_Vulnerabilities" target="_blank" rel="noopener">Binarly</a>, several devices listed in the <a href="https://support.lenovo.com/us/en/product_security/LEN-94952" target="_blank" rel="noopener">advisory</a> were left unpatched, or not patched correctly, even few months after the advisory – leaving the devices vulnerable. Needless to say, similar to the previous case, some devices will stay vulnerable forever, as they have reached their End-Of-Support date.</li>
</ul>
<p>It was just a matter of time before someone would take advantage of these failures and create a UEFI bootkit capable of operating on systems with UEFI Secure Boot enabled. As we suggested last year in our <a href="https://www.rsaconference.com/Library/presentation/USA/2022/ESPecter%20First%20Real-World%20UEFI%20Bootkit%20Persisting%20on%20ESP" target="_blank" rel="noopener">RSA presentation</a>, all of this makes the move to the ESP more feasible for attackers and a possible way forward for UEFI threats – the existence of BlackLotus confirms this.</p>
<p><em>ESET Research offers private APT intelligence reports and data feeds. For any inquiries about this service, visit the <a href="https://www.eset.com/int/business/services/threat-intelligence/?utm_source=welivesecurity.com&amp;utm_medium=referral&amp;utm_campaign=wls-research&amp;utm_content=blacklotus-uefi-bootkit-myth-confirmed" target="_blank" rel="noopener">ESET Threat Intelligence</a> page.</em></p>
<h2>IoCs</h2>
<h3>Files</h3>

<table id="tablepress-1238">
<thead>
<tr>
	<th>SHA-1</th><th>Filename</th><th>Detection</th><th>Description</th>
</tr>
</thead>
<tbody>
<tr>
	<td><span>05846D5B1D37EE2D716140DE4F4F984CF1E631D1</span></td><td>N/A</td><td>Win64/BlackLotus.A</td><td>BlackLotus installer.</td>
</tr>
<tr>
	<td><span>A5A530A91100ED5F07A5D74698B15C646DD44E16</span></td><td>N/A</td><td>Win64/BlackLotus.A</td><td>BlackLotus installer.</td>
</tr>
<tr>
	<td><span>D82539BFC2CC7CB504BE74AC74DF696B13DB486A</span></td><td>N/A</td><td>Win64/BlackLotus.A</td><td>BlackLotus installer.</td>
</tr>
<tr>
	<td><span>16B12CEA54360AA42E1120E82C1E9BC0371CB635</span></td><td>N/A</td><td>Win64/BlackLotus.A</td><td>BlackLotus installer.</td>
</tr>
<tr>
	<td><span>DAE7E7C4EEC2AC0DC7963C44A5A4F47D930C5508</span></td><td>N/A</td><td>Win64/BlackLotus.A</td><td>BlackLotus installer.</td>
</tr>
<tr>
	<td><span>45701A83DEC1DC71A48268C9D6D205F31D9E7FFB</span></td><td>N/A</td><td>Win64/BlackLotus.A</td><td>BlackLotus installer.</td>
</tr>
<tr>
	<td><span>2CE056AE323B0380B0E87225EA0AE087A33CD316</span></td><td>N/A</td><td>EFI/BlackLotus.B</td><td>BlackLotus UEFI bootkit.</td>
</tr>
<tr>
	<td><span>5A0074203ABD5DEB464BA0A79E14B7541A033216</span></td><td>N/A</td><td>EFI/BlackLotus.B</td><td>BlackLotus UEFI bootkit.</td>
</tr>
<tr>
	<td><span>5DC9CBD75ABD830E83641A0265BFFDDD2F602815</span></td><td>N/A</td><td>EFI/BlackLotus.B</td><td>BlackLotus UEFI bootkit.</td>
</tr>
<tr>
	<td><span>97AEC21042DF47D39AC212761729C6BE484D064D</span></td><td>N/A</td><td>EFI/BlackLotus.B</td><td>BlackLotus UEFI bootkit.</td>
</tr>
<tr>
	<td><span>ADCEEC18FF009BED635D168E0B116E72096F18D2</span></td><td>N/A</td><td>EFI/BlackLotus.B</td><td>BlackLotus UEFI bootkit.</td>
</tr>
<tr>
	<td><span>DBC064F757C69EC43517EFF496146B43CBA949D1</span></td><td>N/A</td><td>EFI/BlackLotus.B</td><td>BlackLotus UEFI bootkit.</td>
</tr>
<tr>
	<td><span>06AF3016ACCDB3DFE1C23657BF1BF91C13BAA757</span></td><td>N/A</td><td>Win64/BlackLotus.B</td><td>BlackLotus HTTP downloader.</td>
</tr>
<tr>
	<td><span>0C0E78BF97116E781DDE0E00A1CD0C29E68D623D</span></td><td>N/A</td><td>Win64/BlackLotus.B</td><td>BlackLotus HTTP downloader.</td>
</tr>
<tr>
	<td><span>6D8CEE28DA8BCF25A4D232FEB0810452ACADA11D</span></td><td>N/A</td><td>Win64/BlackLotus.B</td><td>BlackLotus HTTP downloader.</td>
</tr>
<tr>
	<td><span>74FF58FCE8F19083D16DF0109DC91D78C94342FA</span></td><td>N/A</td><td>Win64/BlackLotus.B</td><td>BlackLotus HTTP downloader.</td>
</tr>
<tr>
	<td><span>ACC74217CBE3F2E727A826B34BDE482DCAE15BE6</span></td><td>N/A</td><td>Win64/BlackLotus.B</td><td>BlackLotus HTTP downloader.</td>
</tr>
<tr>
	<td><span>111C4998F3264617A7A9D9BF662D4B1577445B20</span></td><td>N/A</td><td>Win64/BlackLotus.B</td><td>BlackLotus HTTP downloader.</td>
</tr>
<tr>
	<td><span>17FA047C1F979B180644906FE9265F21AF5B0509</span></td><td>N/A</td><td>Win64/BlackLotus.C</td><td>BlackLotus kernel driver.</td>
</tr>
<tr>
	<td><span>1F3799FED3CF43254FE30DCDFDB8DC02D82E662B</span></td><td>N/A</td><td>Win64/BlackLotus.C</td><td>BlackLotus kernel driver.</td>
</tr>
<tr>
	<td><span>4B882748FAF2C6C360884C6812DD5BCBCE75EBFF</span></td><td>N/A</td><td>Win64/BlackLotus.C</td><td>BlackLotus kernel driver.</td>
</tr>
<tr>
	<td><span>91F832F46E4C38ECC9335460D46F6F71352CFFED</span></td><td>N/A</td><td>Win64/BlackLotus.C</td><td>BlackLotus kernel driver.</td>
</tr>
<tr>
	<td><span>994DC79255AEB662A672A1814280DE73D405617A</span></td><td>N/A</td><td>Win64/BlackLotus.C</td><td>BlackLotus kernel driver.</td>
</tr>
<tr>
	<td><span>FFF4F28287677CAABC60C8AB36786C370226588D</span></td><td>N/A</td><td>Win64/BlackLotus.C</td><td>BlackLotus kernel driver.</td>
</tr>
<tr>
	<td><span>71559C3E2F3950D4EE016F24CA54DA17D28B9D82</span></td><td>N/A</td><td>EFI/BlackLotus.C</td><td>BlackLotus Boot Configuration Data (BCD) store dropped by BlackLotus installer.</td>
</tr>
<tr>
	<td><span>D6D3F3151B188A9DA62DEB95EA1D1ABEFF257914</span></td><td>N/A</td><td>EFI/BlackLotus.C</td><td>BlackLotus Boot Configuration Data (BCD) store dropped by BlackLotus installer.</td>
</tr>
<tr>
	<td><span>547FAA2D64B85BF883955B723B07635C0A09326B</span></td><td>N/A</td><td>EFI/BlackLotus.A</td><td>BlackLotus CVE-2022-21894 exploitation payload loader.</td>
</tr>
<tr>
	<td><span>D1BBAA3D408E944C70B3815471EED7FA9AEE6425</span></td><td>N/A</td><td>EFI/BlackLotus.A</td><td>BlackLotus CVE-2022-21894 exploitation payload loader.</td>
</tr>
<tr>
	<td><span>0E6DD7110C38464ECAA55EE4E2FA303ADA0EDEFB</span></td><td>N/A</td><td>EFI/BlackLotus.A</td><td>BlackLotus CVE-2022-21894 exploitation payload – MokInstaller EFI app.</td>
</tr>
<tr>
	<td><span>D6BB89D8734B3E49725362DAE9A868AE681E8BD6</span></td><td>N/A</td><td>EFI/BlackLotus.A</td><td>BlackLotus CVE-2022-21894 exploitation payload – MokInstaller EFI app.</td>
</tr>
<tr>
	<td><span>164BB587109CFB20824303AD1609A65ABB36C3E9</span></td><td>N/A</td><td>Win64/BlackLotus.D</td><td>BlackLotus installer UAC bypass module.</td>
</tr>
</tbody>
</table>

<h3>Certificates</h3>

<table id="tablepress-1239">
<tbody>
<tr>
	<td>Serial number</td><td><span>570B5D22B723B4A442CC6EEEBC2580E8</span></td>
</tr>
<tr>
	<td>Thumbprint</td><td><span>C8E6BF8B6FDA161BBFA5470BCC262B1BDC92A359</span></td>
</tr>
<tr>
	<td>Subject CN</td><td>When They Cry CA</td>
</tr>
<tr>
	<td>Subject O</td><td>N/A</td>
</tr>
<tr>
	<td>Subject L</td><td>N/A</td>
</tr>
<tr>
	<td>Subject S</td><td>N/A</td>
</tr>
<tr>
	<td>Subject C</td><td>N/A</td>
</tr>
<tr>
	<td>Valid from</td><td>2022-08-13 17:48:44</td>
</tr>
<tr>
	<td>Valid to</td><td>2032-08-13 17:58:44</td>
</tr>
</tbody>
</table>

<h3>Network</h3>

<table id="tablepress-1240">
<thead>
<tr>
	<th>IP</th><th>Domain</th><th>Hosting provider</th><th>First seen</th><th>Details</th>
</tr>
</thead>
<tbody>
<tr>
	<td>N/A</td><td><span>xrepositoryx[.]name</span></td><td>N/A</td><td><span>2022‑10‑17</span></td><td>BlackLotus C&amp;C.  <span>https://xrepositoryx[.]name/network/API/hpb_gate.php</span></td>
</tr>
<tr>
	<td>N/A</td><td><span>myrepositoryx[.]com</span></td><td>N/A</td><td><span>2022‑10‑16</span></td><td>BlackLotus C&amp;C.</td>
</tr>
<tr>
	<td><span>104.21.22[.]185</span></td><td><span>erdjknfweklsgwfmewfgref[.]com</span></td><td>Cloudflare, Inc.</td><td><span>2022‑10‑06</span></td><td>BlackLotus C&amp;C.</td>
</tr>
<tr>
	<td><span>164.90.172[.]211</span></td><td><span>harrysucksdick[.]com</span></td><td>DigitalOcean, LLC</td><td><span>2022‑10‑09</span></td><td>BlackLotus C&amp;C.</td>
</tr>
<tr>
	<td><span>185.145.245[.]123</span></td><td><span>heikickgn[.]com</span></td><td>SIA VEESP</td><td><span>2022‑10‑12</span></td><td>BlackLotus C&amp;C.</td>
</tr>
<tr>
	<td><span>185.150.24[.]114</span></td><td><span>myrepository[.]name</span></td><td>SkyLink Data Center BV</td><td><span>2022‑10‑14</span></td><td>BlackLotus C&amp;C.</td>
</tr>
<tr>
	<td><span>190.147.189[.]122</span></td><td><span>egscorp[.]net</span></td><td>Telmex Colombia S.A.</td><td><span>2022‑08‑24</span></td><td>BlackLotus C&amp;C.</td>
</tr>
</tbody>
</table>

<h2>MITRE ATT&amp;CK techniques</h2>
<p><em>This table was built using <a href="https://attack.mitre.org/resources/versions/">version 12</a> of the MITRE ATT&amp;CK framework<strong>.</strong></em></p>

<table id="tablepress-1241">
<thead>
<tr>
	<th>Tactic</th><th>ID</th><th>Name</th><th>Description</th>
</tr>
</thead>
<tbody>
<tr>
	<td rowspan="2">Resource Develpment</td><td><a href="https://attack.mitre.org/versions/v12/techniques/T1587/002/" rel="noopener" target="_blank">T1587.002</a></td><td>Develop Capabilities: Code Signing Certificates</td><td>Some BlackLotus samples are signed with self-signed certificate.</td>
</tr>
<tr>
	<td><a href="https://attack.mitre.org/versions/v12/techniques/T1588/005/" rel="noopener" target="_blank">T1588.005</a></td><td>Obtain Capabilities: Exploits</td><td>BlackLotus used publicly known exploit to bypass UEFI Secure Boot.</td>
</tr>
<tr>
	<td rowspan="4">Execution</td><td><a href="https://attack.mitre.org/versions/v12/techniques/T1203/" rel="noopener" target="_blank">T1203</a></td><td>Exploitation for Client Execution</td><td>BlackLotus installers can exploit CVE-2022-21894 to achieve arbitrary code execution on the systems with UEFI Secure Boot enabled.</td>
</tr>
<tr>
	<td><a href="https://attack.mitre.org/versions/v12/techniques/T1559/" rel="noopener" target="_blank">T1559</a></td><td>Inter-Process Communication</td><td>BlackLotus HTTP downloader uses named section to pass commands to the kernel-mode component.</td>
</tr>
<tr>
	<td><a href="https://attack.mitre.org/versions/v12/techniques/T1106/" rel="noopener" target="_blank">T1106</a></td><td>Native API</td><td>BlackLotus HTTP downloader uses various native Windows APIs to achieve code execution on the compromised machine.</td>
</tr>
<tr>
	<td><a href="https://attack.mitre.org/versions/v12/techniques/T1129/" rel="noopener" target="_blank">T1129</a></td><td>Shared Modules</td><td>BlackLotus HTTP downloader can load and execute DLLs received from the C&amp;C server.</td>
</tr>
<tr>
	<td>Persistence</td><td><a href="https://attack.mitre.org/versions/v12/techniques/T1542/003/" rel="noopener" target="_blank">T1542.003</a></td><td>Pre-OS Boot: Bootkit</td><td>BlackLotus bootkit is deployed on the EFI System Partition and executed during the boot.</td>
</tr>
<tr>
	<td rowspan="2">Privilege Escalation</td><td><a href="https://attack.mitre.org/versions/v12/techniques/T1548/002/" rel="noopener" target="_blank">T1548.002</a></td><td>Abuse Elevation Control Mechanism: Bypass User Account Control</td><td>BlackLotus installer attempts to escalate privileges by bypassing User Account Control.</td>
</tr>
<tr>
	<td><a href="https://attack.mitre.org/versions/v12/techniques/T1134/002/" rel="noopener" target="_blank">T1134.002</a></td><td>Access Token Manipulation: Create Process with Token</td><td>BlackLotus HTTP downloader can use WTSQueryUserToken and CreateProcessAsUserW to execute downloaded payloads within a new process with local system privileges. </td>
</tr>
<tr>
	<td rowspan="15">Defense Evasion   </td><td><a href="https://attack.mitre.org/versions/v12/techniques/T1622/" rel="noopener" target="_blank">T1622</a></td><td>Debugger Evasion</td><td>BlackLotus components use various techniques to detect whether a kernel-mode or user-mode debugger is running on a victim.</td>
</tr>
<tr>
	<td><a href="https://attack.mitre.org/versions/v12/techniques/T1574/" rel="noopener" target="_blank">T1574</a></td><td>Hijack Execution Flow</td><td>BlackLotus bootkit hijacks various components included in the early Windows boot process stages (Windows Boot Manager, Windows OS loader, Windows kernel and specific drivers) to avoid detection by deactivating various Windows security features (VBS, Windows Defender) and stealthily execute its kernel-mode and user-mode components</td>
</tr>
<tr>
	<td><a href="https://attack.mitre.org/versions/v12/techniques/T1562/" rel="noopener" target="_blank">T1562</a></td><td>Impair Defenses</td><td>BlackLotus components can disable BitLocker and Windows Defender to avoid detection.</td>
</tr>
<tr>
	<td><a href="https://attack.mitre.org/versions/v12/techniques/T1070/004/" rel="noopener" target="_blank">T1070.004</a></td><td>Indicator Removal: File Deletion</td><td>BlackLotus installer deletes itself after successfully deploying files to the EFI System partition. Also after successful CVE-2022-21894 exploitation, BlackLotus removes traces of exploitation by deleting all files included in exploitation chain from EFI System Partition.</td>
</tr>
<tr>
	<td><a href="https://attack.mitre.org/versions/v12/techniques/T1070/009/" rel="noopener" target="_blank">T1070.009</a></td><td>Indicator Removal: Clear Persistence</td><td>BlackLotus can uninstall itself by removing all bootkit files from the ESP and restoring original victim’s Windows Boot Manager.</td>
</tr>
<tr>
	<td><a href="https://attack.mitre.org/versions/v12/techniques/T1036/005/" rel="noopener" target="_blank">T1036.005</a></td><td>Masquerading: Match Legitimate Name or Location</td><td>BlackLotus attempts to hide its files deployed on the ESP by using legitimate filenames, such as grubx64.efi (if UEFI Secure Boot is enabled on compromised machine) or bootmgfw.efi (if UEFI Secure Boot is disabled on compromised machine).</td>
</tr>
<tr>
	<td><a href="https://attack.mitre.org/versions/v12/techniques/T1112/" rel="noopener" target="_blank">T1112</a></td><td>Modify Registry</td><td>BlackLotus installer modifies Windows registry to disable Windows HVCI security feature.</td>
</tr>
<tr>
	<td><a href="https://attack.mitre.org/versions/v12/techniques/T1027/" rel="noopener" target="_blank">T1027</a></td><td>Obfuscated Files or Information</td><td>Almost all embedded strings in BlackLotus components are encrypted using a custom combined cipher and decrypted only when needed.</td>
</tr>
<tr>
	<td><a href="https://attack.mitre.org/versions/v12/techniques/T1027/007/" rel="noopener" target="_blank">T1027.007</a></td><td>Obfuscated Files or Information: Dynamic API Resolution</td><td>BlackLotus components use dynamic API resolution while using API names’ hashes instead of names.</td>
</tr>
<tr>
	<td><a href="https://attack.mitre.org/versions/v12/techniques/T1027/009/" rel="noopener" target="_blank">T1027.009</a></td><td>Obfuscated Files or Information: Embedded Payloads</td><td>Almost all embedded files in BlackLotus components are encrypted using AES.</td>
</tr>
<tr>
	<td><a href="https://attack.mitre.org/versions/v12/techniques/T1542/003/" rel="noopener" target="_blank">T1542.003</a></td><td>Pre-OS Boot: Bootkit</td><td>BlackLotus bootkit is deployed on the EFI System Partition and executed during the early OS boot stages, and thus is capable of controlling the OS boot process and evading detection.</td>
</tr>
<tr>
	<td><a href="https://attack.mitre.org/versions/v12/techniques/T1055/012/" rel="noopener" target="_blank">T1055.012</a></td><td>Process Injection: Dynamic-link Library Injection</td><td>BlackLotus HTTP downloader can inject a DLL into a newly created  <span>svchost.exe</span>  process using process hollowing. </td>
</tr>
<tr>
	<td><a href="https://attack.mitre.org/versions/v12/techniques/T1055/002/" rel="noopener" target="_blank">T1055.002</a></td><td>Process Injection: Portable Executable Injection</td><td>BlackLotus driver injects the HTTP downloader portable executable into a  <span>winlogon.exe</span> process.</td>
</tr>
<tr>
	<td><a href="https://attack.mitre.org/versions/v12/techniques/T1014/" rel="noopener" target="_blank">T1014</a></td><td>Rootkit</td><td>BlackLotus kernel driver protects the bootkit files on the ESP from removal.</td>
</tr>
<tr>
	<td><a href="https://attack.mitre.org/versions/v12/techniques/T1497/001/" rel="noopener" target="_blank">T1497.001</a></td><td>Virtualization/Sandbox Evasion: System Checks</td><td>BlackLotus employs various system checks including checking sandbox-specific registry values, to detect and avoid virtualization and analysis environments.</td>
</tr>
<tr>
	<td rowspan="6">Discovery</td><td><a href="https://attack.mitre.org/versions/v12/techniques/T1622/" rel="noopener" target="_blank">T1622</a></td><td>Debugger Evasion</td><td>BlackLotus components use various techniques to detect whether a kernel-mode or user-mode debugger is running on a victim.</td>
</tr>
<tr>
	<td><a href="https://attack.mitre.org/versions/v12/techniques/T1082/" rel="noopener" target="_blank">T1082</a></td><td>System Information Discovery</td><td>BlackLotus collects system information (IP, GPU, CPU, memory, OS version) on a compromised host.</td>
</tr>
<tr>
	<td><a href="https://attack.mitre.org/versions/v12/techniques/T1614/" rel="noopener" target="_blank">T1614</a></td><td>System Location Discovery</td><td>BlackLotus can exit if one of the following system locales is identified on the compromised host:  <span>ro-MD,  ru-MD,  ru-RU,  uk-UA,  be-BY,  hy-AM,  kk-KZ</span>.</td>
</tr>
<tr>
	<td><a href="https://attack.mitre.org/versions/v12/techniques/T1016/" rel="noopener" target="_blank">T1016</a></td><td>System Network Configuration Discovery</td><td>BlackLotus HTTP downloader can determine the public IP of a compromised host by requesting <span>api.ipify[.]org</span> service.</td>
</tr>
<tr>
	<td><a href="https://attack.mitre.org/versions/v12/techniques/T1016/001/" rel="noopener" target="_blank">T1016.001</a></td><td>System Network Configuration Discovery: Internet Connection Discovery</td><td>BlackLotus HTTP downloader checks the internet connection by querying Microsoft’s  <span>www.msftncsi[.]com/ncsi[.]txt</span></td>
</tr>
<tr>
	<td><a href="https://attack.mitre.org/versions/v12/techniques/T1497/001/" rel="noopener" target="_blank">T1497.001</a></td><td>Virtualization/Sandbox Evasion: System Checks</td><td>BlackLotus employs various system checks including checking sandbox-specific registry values, to detect and avoid virtualization and analysis environments.</td>
</tr>
<tr>
	<td rowspan="4">Command and Control</td><td><a href="https://attack.mitre.org/versions/v12/techniques/T1071/001/" rel="noopener" target="_blank">T1071.001</a></td><td>Application Layer Protocol: Web Protocols</td><td>BlackLotus uses HTTPS for communication with its C&amp;C.</td>
</tr>
<tr>
	<td><a href="https://attack.mitre.org/versions/v12/techniques/T1132/001/" rel="noopener" target="_blank">T1132.001</a></td><td>Data Encoding: Standard Encoding</td><td>BlackLotus encodes encrypted data in C&amp;C communication with URL-safe base64.</td>
</tr>
<tr>
	<td><a href="https://attack.mitre.org/versions/v12/techniques/T1573/001/" rel="noopener" target="_blank">T1573.001</a></td><td>Encrypted Channel: Symmetric Cryptography</td><td>BlackLotus uses 256-bit AES in CBC mode to decrypt messages received from its C&amp;C.</td>
</tr>
<tr>
	<td><a href="https://attack.mitre.org/versions/v12/techniques/T1573/002/" rel="noopener" target="_blank">T1573.002</a></td><td>Encrypted Channel: Asymmetric Cryptography</td><td>BlackLotus uses an embedded RSA public key to encrypt messages sent to C&amp;C.</td>
</tr>
</tbody>
</table>

<p><a href="https://www.eset.com/int/business/services/threat-intelligence/?utm_source=welivesecurity.com&amp;utm_medium=referral&amp;utm_campaign=wls-research&amp;utm_content=blacklotus-uefi-bootkit-myth-confirmed" target="_blank" rel="noopener"><img src="https://www.welivesecurity.com/wp-content/uploads/2022/12/eset-threat-intelligence.png" alt="" width="915" height="296" srcset="https://www.welivesecurity.com/wp-content/uploads/2022/12/eset-threat-intelligence.png 915w, https://www.welivesecurity.com/wp-content/uploads/2022/12/eset-threat-intelligence-300x97.png 300w, https://www.welivesecurity.com/wp-content/uploads/2022/12/eset-threat-intelligence-768x248.png 768w" sizes="(max-width: 915px) 100vw, 915px"/></a></p>

                            
                                                            

                                
                            
                                
                                

                                                            
                            
                            
                        </div>
                    </div>
                </div>
            </div></div>
  </body>
</html>
