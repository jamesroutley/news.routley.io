<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sqlite.org/hctree/doc/hctree/doc/hctree/index.html">Original</a>
    <h1>HC-tree is an experimental high-concurrency database back end for SQLite</h1>
    
    <div id="readability-page-1" class="page"><div>



<title> HC-tree </title>

<center>
  <b>Links:</b>
    ...<a href="https://evalapply.org/posts/animate-text-art-javascript/threadtest.wiki">Hctree Test Results</a>
    ...<a href="https://evalapply.org/posts/animate-text-art-javascript/design.wiki">Hctree Design Documentation</a>
    ...<a href="https://evalapply.org/posts/animate-text-art-javascript/fileformat.wiki">Hctree File Format</a>...
</center>



<p>SQLite is sometimes used as the core of a client/server database system.
While it works reliably well in such cases, the database backend module that it
uses to store b-tree structures in its database file was not designed with this
case in mind and can be improved upon in several ways. The HC-tree (hctree)
project is an attempt to develop a new database backend that improves upon
regular SQLite as follows:

</p><ul>
  <li><p><b>Improved concurrency:</b> Stock SQLite is limited to a single
     concurrent writer. 
     </p><p>
     Using the begin-concurrent extension changes this so that multiple 
     writers may run concurrently using optimistic page-level locking. This
     improves concurrency somewhat, but page-level locking can detect
     conflicts between logically independant transactions, and COMMIT
     operations must still be serialized.
     </p><p>
     Hctree uses optimistic row-level locking and is designed to support 
     dozens of concurrent writers running at full-speed. 
     <a href="https://evalapply.org/posts/animate-text-art-javascript/threadtest.wiki">Test results</a> obtained from the prototype
     show that this is possible.

  </p></li><li>  <p><b>Support for replication:</b> Stock SQLite supports the 
     <a href="http://sqlite.org/sessionintro.html">sessions extension</a>, which
     allows the contents of a committed transaction to be serialized for
     tranmission and application to a second database.
     </p><p>
     Hctree builds this into the database backend, and adds support for
     application of such transactions to follower databases in leader-follower
     configurations. In this case, transactions received from a leader database
     can be applied more quickly and with greater concurrency than with
     which they were originally applied to the leader database, because
     no <a href="#concurrency">transaction validation</a> is required.

  </p></li><li>  <p><b>Removal of database size limitations:</b> Stock SQLite uses 32-bit 
     page numbers. Using the default 4KiB page-size, this leads to a maximum
     database size of 2^44 bytes, or 16TiB.
     </p><p>
     Hctree uses 48-bit page numbers, allowing 2^60 byte databases, or 1EiB.
     Roughly one million TiB.
</p></li></ul>

<p>An implicit goal is that hctree must be as fast or faster than stock SQLite
for all single-threaded cases. There is no point in running dozens of
concurrent writers if each of them is an order of magnitude slower than
a single writer writing to a legacy database.

</p><p>Hctree clients (those that use a version of SQLite compiled from this
repository) may read hctree databases and stock SQLite databases.

</p>

<p>This project contains a fork of the SQLite project that has been modified
to include a prototype of the hctree database backend. It may be built and 
used in all the same ways as the stock SQLite library code.

</p><p>The prototype is advanced enough to experiment with and to conduct 
<a href="https://evalapply.org/posts/animate-text-art-javascript/threadtest.wiki">multi-threaded performance tests</a> with, but
is incomplete. The current code has, at least, the following shortcomings:

</p><ol>
  <li><p> <a href="#transactiontypes">&#34;BEGIN EXCLUSIVE&#34;</a> is not implemented
          for hctree databases. It is parsed, but behaves just as a regular
          &#34;BEGIN&#34; does.

  </p></li><li><p> All hctree databases currently use 32-bit page numbers (maximum
          database size of 16TiB with the default 4KiB byte page size).

  </p></li><li><p> The database is always accessed using mmap(). It is not possible
          to fallback to pread()/pwrite().

  </p></li><li><p> Transactions that do not fit entirely in main memory (e.g. large
          CREATE INDEX statements) are not handled efficiently.

  </p></li><li><p> No support for replication is implemented.

  </p></li><li><p> The prototype library only works on POSIX, not win32, systems.

  </p></li><li><p> All clients of an hctree database, read or read/write, must access
          the database from within the same OS process.

  </p></li><li><p> There is no support for recovering from a power failure or operating
          system crash. Such an event may corrupt the database.
</p></li></ol>

<p>

The prototype is on the &#34;hctree&#34; branch (not trunk!) of the fossil repository
at <a href="https://sqlite.org/hctree">https://sqlite.org/hctree</a>. To obtain
the latest development snapshot, download:

</p><ul>
  <li>  <a href="https://www.sqlite.org/hctree/tarball/hctree.tar.gz?r=hctree" download="hctree-latest.tar.gz">
             https://www.sqlite.org/hctree/tarball/hctree.tar.gz?r=hctree</a>
</li></ul><p>

or check the code out using fossil:

</p><pre>    fossil clone https://www.sqlite.org/hctree hctree.fossil
    mkdir hctree
    cd hctree
    fossil open ../hctree.fossil
    fossil up hctree
</pre><p>

The sources may be built and deployed in the same ways as stock SQLite.

</p>

<h2> Creating/Opening Databases </h2>

<p>When opening an existing database, the library determines automatically 
whether or not it is a stock SQLite database or an hctree database. By
default, when creating a new database, the library creates an ordinary
SQLite database. To create a new hctree database, the 
<a href="https://sqlite.org/uri.html">SQLite URI parameter</a> &#34;hctree=1&#34;
must be specified the first time the new database is opened. e.g.

</p><pre>        file://new_hctree_database.db?hctree=1
</pre>

<p>The easiest ways to check if a database really is an hctree database
are:
</p><ul>
  <li><p> To check the first 6 bytes of the database file. For an hctree
  database they are &#34;hctree&#34;, instead of the usual &#34;SQLite&#34; found in the first
  6 bytes of stock SQLite databases.

  </p></li><li><p> Open the database and evaluate an hctree specific pragma command like
  &#34;PRAGMA hct_ncasfail&#34;. If it returns an integer, the database is an hctree
  database. If it returns no rows, a legacy SQLite database.
</p></li></ul>

<p>Each database consists of two files - the database file itself and a second
file name &#34;&lt;database&gt;-pagemap&#34;.

</p><h2 id="concurrency"> Concurrency Model </h2>

<p> Hctree offers similar MVCC based optimistic concurrency to SQLite with the
begin-concurrent extension, except that it validates transactions based on the
keys and logical ranges of keys accessed instead of the set of pages. 

</p><p> As in any MVCC database system, including stock SQLite, both readers and
writers access a consistent snapshot of the database, in which writes committed
after the transaction was opened are never visible. Any writes made within the
transaction are accumulated privately and made visible only to the transaction
itself until they are committed.

</p><p> When a transaction is to be committed in an optimistic concurrency system,
it must first be validated. To validate a transaction is to check that, when
considered in concert with all other past and current transactions, the
transaction might have been committed in a system that serializes all 
transactions without changing the outcome in terms of the final state of the
database or query results returned to any client. In practice, there are two
ways for an hctree transaction to be validated:

</p><ol id="validationcases">
  <li> <p>If no other client has committed a transaction to the database since 
       the writer&#39;s snapshot was opened, the transaction must be valid.

  </p></li><li> <p>If no other client has modified any b-tree (table or index) entry
       or range that the transaction being committed accessed by a range or
       stabbing query, then the transaction is valid.  
</p></li></ol>

<p>For example, considering the following database:

</p><pre>    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT, c TEXT);
    CREATE INDEX i1 ON t1(b);
    INSERT INTO t1 VALUES(1, &#39;a&#39;, &#39;A&#39;);
    INSERT INTO t1 VALUES(2, &#39;b&#39;, &#39;B&#39;);
    INSERT INTO t1 VALUES(3, &#39;x&#39;, &#39;X&#39;);
    INSERT INTO t1 VALUES(4, &#39;c&#39;, &#39;C&#39;);
    INSERT INTO t1 VALUES(5, &#39;d&#39;, &#39;D&#39;);
</pre>

<p>And the following transaction:

</p><pre>    BEGIN CONCURRENT;
      SELECT * FROM t1 WHERE (b BETWEEN &#39;a&#39; AND &#39;c&#39;) AND c!=&#39;B&#39;;
      INSERT INTO t1 VALUES(6, &#39;e&#39;);
    COMMIT;
</pre>

<p>Then during transaction execution, hctree records that the following were
accessed:

</p><ul>
  <li> The range of keys between &#39;a&#39; and &#39;c&#39;, inclusive, within the index
       b-tree.
  </li><li> Keys 1, 2, 4 and 6 of the table b-tree.
</li></ul>

<p>If, when the attempt to commit is made, the hctree client finds that
either the contents of the index b-tree range or one of the table b-tree
keys has been modified since the writer&#39;s snapshot was opened, validation
does not succeed and the transaction is not committed.

</p><p>Note that another client modifying the (2, &#39;b&#39;, &#39;B&#39;) tuple causes 
validation to fail, even though the SELECT query excludes that row. This
is because validation is based on the entries and ranges of entries read
from the b-tree layer, not the subset of those actually used by the database
engine. If there were no index in the database schema, then the example SELECT
query would be implemented using a full-table scan of the table b-tree. In
this case any modification to any row of the table b-tree would cause
transaction validation to fail.

</p><p>All database transactions implicitly read the database schema. So any
transaction that modifies the database schema may only be commited if no
other client has written to the database since the writer&#39;s snapshot
was opened (<a href="#validationcases">case 1 above</a>).

</p><h2 id="transactiontypes"> Transaction Types </h2>

<p>Hctree allows clients to open three different transaction types, as
follows:

</p><ol>
  <li><p> <b>BEGIN;</b> Transactions opened with &#34;BEGIN&#34; do not collect
    validation data. This means that if they write to the database, they
    may only be committed if no other client has written the database
    since the writer&#39;s snapshot was opened 
    (<a href="#validationcases">validation case 1 above</a>).
  </p></li><li><p> <b>BEGIN CONCURRENT;</b> Transactions opened with &#34;BEGIN CONCURRENT&#34;
    do collect validation data as they run. So that if they write to the
    database, upon commit they may, subject to validation, be committed
    even if other transactions have been committed since the snapshot 
    was opened.
  </p></li><li><p> <b>BEGIN EXCLUSIVE;</b> A &#34;BEGIN EXCLUSIVE&#34; command not only opens
    a transaction, but also prevents any new transaction-commit operations
    from starting, and spin-locks until all ongoing commits have finished.
    Any new commit operations started while the BEGIN EXCLUSIVE transaction
    is active also spin-lock until it is finished. Thus a transaction started
    using &#34;BEGIN EXCLUSIVE&#34; always passes validation, since it is always 
    committed against the same snapshot against which it is prepared.
</p></li></ol>

<p>Implicit transactions are handled in the same way as those opened using
&#34;BEGIN&#34;.

</p><p>In general, &#34;BEGIN&#34; should be used for read-only transactions, as it does
not incur the overhead of accumulating data required for validation. &#34;BEGIN
CONCURRENT&#34; should be used for most read/write transactions and &#34;BEGIN
EXCLUSIVE&#34; as a fallback for transactions that are likely to conflict otherwise
(perhaps because they have already been tried and found to conflict several
times already, or perhaps because they contain schema modifications).

</p><p>In all cases above, &#34;spin-lock&#34; actually means invoke the SQLite xBusy
callback if one is registered, or to literally spin-lock otherwise.




</p></div></div>
  </body>
</html>
