<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sophiebits.com/2024/10/30/everyone-is-wrong-about-that-slack-flowchart">Original</a>
    <h1>Everyone is wrong about that Slack flowchart</h1>
    
    <div id="readability-page-1" class="page"><div><p>Building software is hard. Oftentimes things that seem like they should be simple end up being way more complicated when you get into the details. (<a href="http://johnsalvatier.org/blog/2017/reality-has-a-surprising-amount-of-detail" target="_blank" rel="nofollow">OK, maybe this isn’t specific to software.</a>)</p>
<p>As evidence of this, people love to point to this flowchart that Slack’s engineering team <a href="https://slack.engineering/reducing-slacks-memory-footprint/" target="_blank" rel="nofollow">published in March 2017</a> summarizing the logic Slack uses to determine whether to send a given user a notification for a message (author Johnny Rodgers’s <a href="https://x.com/johnnyrodgersis/status/1583540622107226112" target="_blank" rel="nofollow">additional commentary here</a>):</p>
<p><a href="https://sophiebits.com/images/2024-10-30/theirs.png" target="_blank">
  <img src="https://sophiebits.com/images/2024-10-30/theirs.png" alt="Slack&#39;s flowchart titled &#39;Should we send a notification&#39;. It has a few dozen boxes and arrows in different colors, and the lines are intertwined and even circular in some places. Multiple parts of the chart are partially duplicative with other parts."/>
</a></p><p>You’ll hear no argument from me that this flowchart is incredibly complicated! It’s hard to understand the nuances of the logic from glancing quickly at this diagram. There are literally cycles in the graph! However I think it overcomplicates the situation a lot.</p>
<p>The most obvious cause of extra boxes in the diagram is completely splitting the “channel notification preferences” from “global notification preferences” questions, despite the fact that the options are almost perfectly analogous. Another issue is unnecessarily repeated checks for threads and highlight words that each appear a half dozen different times.</p>
<p>If you “refactor” the diagram, you end up with something that looks more like this version I drew:</p>
<p><a href="https://sophiebits.com/images/2024-10-30/mine.svg" target="_blank">
  <img src="https://sophiebits.com/images/2024-10-30/mine.svg" alt="My rendition of the same flowchart. It has only 6 boxes. We check the notification preference in only a single place and the chart overall is nearly linear, with each other check shunting a Yes or No answer towards the final &#39;Send Notification&#39; or &#39;Don&#39;t Notify&#39; outcome, rather than having many parallel paths that the common case goes down."/>
</a></p><p>To me this is <em>way</em> easier to understand.</p>
<p>I know this is not 100% bug-for-bug compatible with the original flowchart. Honestly, that’s a little intentional: for example, if @channel mentions are suppressed then the original says that we’ll never notify for a @channel message, but it seems that if the message contains a user mention or highlight word, we should still notify in that case. Other minor differences too seem as likely to be errors in the original diagram versus mine.</p>
<p>Since the logic is simpler to understand at a glance in my version, I expect it is also easier to verify the correctness of and find bugs in my diagram if someone were to want to.</p>
<p>My diagram combines several things that are split out in the original version. In addition to the mergers I mentioned above, my use of <code>&amp;&amp;</code> and <code>||</code> typically corresponds to different boxes in the original. Similarly, my <code>Nothing (incl. muted)</code> arrow is actually two checks masquerading as one.</p>
<p>Am I unfairly cheating by smooshing these together? I’d argue no. Each box or each arrow might correspond to a few lines of code (or may need to load data from multiple sources), but here we combine things that are conceptually part of the same check into one place, which makes it easier to understand the intent. I also focus on trying to have a single clear path through the chart with offramps, versus the original that has a dozen different “valid” paths. The goal of the chart, at least to me, is to make it easy to understand the high-level story of the decision tree, while still staying accurate to small details. In code, each complex check might be defined as its own function that can be reviewed and tested independently.</p>
<p>I don’t mean to claim that Slack’s notifications logic is simple. Indeed, former Slack employees tell me that it’s one of the most complex pieces of their codebase. I’m sure there is even a fair amount of complexity that is not captured in either diagram. For example, in what cases should a message sender be shown the choice to override do-not-disturb and “Notify anyway”? If a push notification is sent to my phone but then I view it on desktop or the message is deleted, should the notification be rescinded? This is all tricky business.</p>
<p>The point I want to make here is that the way we think about and talk about our systems has a huge impact on how understandable they are. It’s easy to make a complex solution to a complex problem; what’s hard is making a simple solution to a complex problem. With careful attention we can find the right lens to look through so that a tricky problem falls into place and our understanding of it looks more like the second diagram than the first.</p>
<p><em>Thanks to Scott Sandler for helping me understand the original diagram and reviewing mine.</em></p></div></div>
  </body>
</html>
