<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.research.google/2023/12/advancements-in-machine-learning-for.html">Original</a>
    <h1>Advancements in machine learning for machine learning</h1>
    
    <div id="readability-page-1" class="page"><div>
<div id="post-body-6088118107306075362">
<p><span>Posted by Phitchaya Mangpo Phothilimthana, Staff Research Scientist, Google DeepMind, and Bryan Perozzi, Senior Staff Research Scientist, Google Research</span>

</p><p>
With the recent and accelerated advances in machine learning (ML), machines can <a href="https://storage.googleapis.com/deepmind-media/gemini/gemini_1_report.pdf">understand natural language</a>, <a href="https://blog.google/technology/ai/lamda/">engage in conversations</a>, <a href="https://cloud.google.com/vertex-ai/docs/generative-ai/image/overview">draw images</a>, <a href="https://arxiv.org/abs/2210.02303">create videos</a> and more. Modern ML models are programmed and trained using ML programming frameworks, such as <a href="https://www.tensorflow.org/">TensorFlow</a>, <a href="https://github.com/google/jax">JAX</a>, <a href="https://pytorch.org/">PyTorch</a>, among many others. These libraries provide high-level instructions to ML practitioners, such as linear algebra operations (e.g., matrix multiplication, convolution, etc.) and neural network layers (e.g., <a href="https://keras.io/api/layers/convolution_layers/convolution2d/">2D convolution layers</a>, <a href="https://keras.io/api/keras_nlp/modeling_layers/transformer_encoder/">transformer layers</a>). Importantly, practitioners need not worry about how to make their models run efficiently on hardware because an ML framework will automatically optimize the user&#39;s model through an underlying <em>compiler</em>. The efficiency of the ML workload, thus, depends on how good the compiler is. A compiler typically relies on heuristics to solve complex optimization problems, often resulting in suboptimal performance.
</p> <p>
In this blog post, we present exciting advancements in ML for ML. In particular, we show how we use ML to improve efficiency of ML workloads! Prior works, both internal and external, have shown that we can use ML to improve performance of ML programs by selecting better ML compiler decisions. Although there exist a few datasets for program performance prediction, they target small sub-programs, such as basic blocks or kernels. We introduce “<a href="https://arxiv.org/abs/2308.13490">TpuGraphs: A Performance Prediction Dataset on Large Tensor Computational Graphs</a>” (presented at <a href="https://nips.cc/Conferences/2023">NeurIPS 2023</a>), which we recently released to fuel more research in ML for program optimization. We hosted a <a href="https://www.kaggle.com/competitions/predict-ai-model-runtime/overview">Kaggle competition</a> on the dataset, which recently completed with 792 participants on 616 teams from 66 countries. Furthermore, in “<a href="https://arxiv.org/abs/2305.12322">Learning Large Graph Property Prediction via Graph Segment Training</a>”, we cover a novel method to scale <a href="https://arxiv.org/abs/2005.03675">graph neural network</a> (GNN) training to handle large programs represented as graphs. The technique both enables training arbitrarily large graphs on a device with limited memory capacity and improves generalization of the model.
</p>





<h2>ML compilers</h2>


<p>
ML compilers are software routines that convert user-written programs (here, mathematical instructions provided by libraries such as TensorFlow) to executables (instructions to execute on the actual hardware). An ML program can be represented as a computation graph, where a node represents a tensor operation (such as <a href="https://en.wikipedia.org/wiki/Matrix_multiplication">matrix multiplication</a>), and an edge represents a tensor flowing from one node to another. ML compilers have to solve many complex optimization problems, including <em>graph-level </em>and <em>kernel-level</em> optimizations. A graph-level optimization requires the context of the entire graph to make optimal decisions and transforms the entire graph accordingly. A kernel-level optimization transforms one kernel (a fused subgraph) at a time, independently of other kernels.
</p>




<table><tbody><tr><td><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhKHc-UWtoIPsAxdaadumdb1n3K8jz02HYoAbz3CG1BChwyvcNzLUSniYSdRi7HJdPoc2ObwFrs3vSQVN43pVmpUtcnCsSyYU3aypLI-Qyg5AVQRf869uwnP-lNOT2HR3LASYeBGDpWx727a5_mvYe2Oe5F_039pysTR4nKfCDGW9YpklkmYS_lOD_D7k8w/s1999/image6.png"><img data-original-height="465" data-original-width="1999" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhKHc-UWtoIPsAxdaadumdb1n3K8jz02HYoAbz3CG1BChwyvcNzLUSniYSdRi7HJdPoc2ObwFrs3vSQVN43pVmpUtcnCsSyYU3aypLI-Qyg5AVQRf869uwnP-lNOT2HR3LASYeBGDpWx727a5_mvYe2Oe5F_039pysTR4nKfCDGW9YpklkmYS_lOD_D7k8w/s16000/image6.png"/></a></td></tr><tr><td>Important optimizations in ML compilers include graph-level and kernel-level optimizations.</td></tr></tbody></table>


<p>
To provide a concrete example, imagine a <a href="https://en.wikipedia.org/wiki/Matrix_(mathematics)">matrix</a> (2D tensor):
</p>





<p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjCUHoSLc08Cq3T475pnipGS1x1rFt0c8cuRCAIiTLWM70FeQMjHkYprNnnroiH0V4PdhtCM2lU7quJ7vJMUX_113S1RAvKZdSQAFiIvdpxrcr8HvnjQti97F3JE5Sno8UKDyjjirTOB5JrhG4kzz2uUiu0GwZ0p5lG5nmhamEPKgaGq1j5cQ9OU9cXj348/s1999/image4.png"><img data-original-height="290" data-original-width="1999" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjCUHoSLc08Cq3T475pnipGS1x1rFt0c8cuRCAIiTLWM70FeQMjHkYprNnnroiH0V4PdhtCM2lU7quJ7vJMUX_113S1RAvKZdSQAFiIvdpxrcr8HvnjQti97F3JE5Sno8UKDyjjirTOB5JrhG4kzz2uUiu0GwZ0p5lG5nmhamEPKgaGq1j5cQ9OU9cXj348/s16000/image4.png"/></a></p>



<p>
It can be stored in computer memory as [A B C a b c] or [A a B b C c], known as <a href="https://en.wikipedia.org/wiki/Row-_and_column-major_order">row- and column-major memory layout</a>, respectively. One important ML compiler optimization is to assign memory layouts to all intermediate tensors in the program. The figure below shows two different layout configurations for the same program. Let’s assume that on the left-hand side, the assigned layouts (in red) are the most efficient option for each individual operator. However, this layout configuration requires the compiler to insert a <em>copy</em> operation to transform the memory layout between the <em>add</em> and <em>convolution</em> operations. On the other hand, the right-hand side configuration might be less efficient for each individual operator, but it doesn’t require the additional memory transformation. The layout assignment optimization has to trade off between local computation efficiency and layout transformation overhead.
</p>





<table><tbody><tr><td><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg_I4RC-UA10yE2aMURcmyfHSZ5_srJ0mxKGxjrUrS6nvEQVNK2CMAp_k__fjCQW8Y20z6IXqA7Fww44Wz5uUAuo6y9njqYxXUPBHu0HGOWfVHFkZ785QZg2mBslF1mrlEmQVt4L60ICPRwk_cbb293MLIx50FT6EsF75xfWi6oa0bCvPAurBB3Y8Mvp1uo/s1999/image3.png"><img data-original-height="343" data-original-width="1999" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg_I4RC-UA10yE2aMURcmyfHSZ5_srJ0mxKGxjrUrS6nvEQVNK2CMAp_k__fjCQW8Y20z6IXqA7Fww44Wz5uUAuo6y9njqYxXUPBHu0HGOWfVHFkZ785QZg2mBslF1mrlEmQVt4L60ICPRwk_cbb293MLIx50FT6EsF75xfWi6oa0bCvPAurBB3Y8Mvp1uo/s16000/image3.png"/></a></td></tr><tr><td>A node represents a tensor operator, annotated with its output tensor shape [<em>n<sub>0</sub></em>, <em>n<sub>1</sub></em>, ...], where <em>n<sub>i </sub></em>is the size of dimension <em>i</em>. Layout {<em>d<sub>0</sub></em>, <em>d<sub>1</sub></em>, ...} represents minor-to-major ordering in memory. Applied configurations are highlighted in red, and other valid configurations are highlighted in blue. A layout configuration specifies the layouts of inputs and outputs of influential operators (i.e., convolution and reshape). A copy operator is inserted when there is a layout mismatch.</td></tr></tbody></table>



<p>
If the compiler makes optimal choices, significant speedups can be made. For example, we have seen <a href="https://ieeexplore.ieee.org/document/9563030">up to a 32% speedup</a> when choosing an optimal layout configuration over the default compiler’s configuration in the <a href="https://www.tensorflow.org/xla">XLA</a> benchmark suite.
</p>




<h2>TpuGraphs dataset</h2>


<p>
Given the above, we aim to improve ML model efficiency by improving the ML compiler. Specifically, it can be very effective to equip the compiler<strong> </strong>with a <a href="https://arxiv.org/abs/2008.01040">learned cost model</a><strong> </strong>that takes in an input program and compiler configuration and then outputs the predicted runtime of the program. 
</p>
<p>
With this motivation, we <a href="https://arxiv.org/abs/2308.13490">release TpuGraphs</a>, a dataset for learning cost models for programs running on Google’s custom <a href="https://cloud.google.com/tpu/docs/intro-to-tpu">Tensor Processing Units</a> (TPUs). The dataset targets two XLA compiler configurations: <em>layout</em> (generalization of row- and column-major ordering, from matrices, to higher dimension tensors) and <em>tiling</em> (configurations of tile sizes). We provide download instructions and starter code on the <a href="https://github.com/google-research-datasets/tpu_graphs">TpuGraphs GitHub</a>. Each example in the dataset contains a computational graph of an ML workload, a compilation configuration, and the execution time of the graph when compiled with the configuration. The graphs in the dataset are collected from open-source ML programs, featuring popular model architectures, e.g., <a href="https://arxiv.org/abs/1512.03385">ResNet</a>, <a href="https://arxiv.org/abs/1905.11946">EfficientNet</a>, <a href="https://arxiv.org/abs/1703.06870">Mask R-CNN</a>, and <a href="https://arxiv.org/abs/1706.03762">Transformer</a>. The dataset provides 25× more graphs than the largest (earlier) graph property prediction dataset (with comparable graph sizes), and graph size is 770× larger on average compared to existing performance prediction datasets on ML programs. With this greatly expanded scale, for the first time we can explore the graph-level prediction task on large graphs, which is subject to challenges such as scalability, training efficiency, and model quality.
</p>

<table><tbody><tr><td><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgtmmh8CXbMXvAmeBpyjMGMrfq2MEXlxeczYqEOUJvps1oca9G_Xlc34D8-vnwUHTDZDlgIZDYqTfPUVF_qi7AJlPw5fV4Whwz8BOEQs-l1S-7TDLqhIsiCXbQN78SPa8yoTE86438CChMyQVhUFEy3vQRiWhQOFhOKfwH3IbIVbhl5Fe1gDTjBFL2AsDBX/s2868/image18.png"><img data-original-height="1546" data-original-width="2868" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgtmmh8CXbMXvAmeBpyjMGMrfq2MEXlxeczYqEOUJvps1oca9G_Xlc34D8-vnwUHTDZDlgIZDYqTfPUVF_qi7AJlPw5fV4Whwz8BOEQs-l1S-7TDLqhIsiCXbQN78SPa8yoTE86438CChMyQVhUFEy3vQRiWhQOFhOKfwH3IbIVbhl5Fe1gDTjBFL2AsDBX/s16000/image18.png"/></a></td></tr><tr><td>Scale of TpuGraphs compared to other graph property prediction datasets.</td></tr></tbody></table>




<p>
We provide baseline learned cost models with our dataset (architecture shown below). Our baseline models are based on a GNN since the input program is represented as a graph. Node features, shown in blue below, consist of two parts. The first part is an <em>opcode id</em>, the most important information of a node, which indicates the type of tensor operation. Our baseline models, thus, map an opcode id to an <em>opcode embedding</em> via an embedding lookup table. The opcode embedding is then concatenated with the second part, the rest of the node features, as inputs to a GNN. We combine the node embeddings produced by the GNN to create the fixed-size embedding of the graph using a simple graph pooling reduction (i.e., sum and mean). The resulting graph embedding is then linearly transformed into the final scalar output by a feedforward layer.
</p>

<table><tbody><tr><td><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgKH2VD6leBGzfWhjN5LA17iDfKlYLIglznzDDI_A73_Jfs4D-tpZR2gPRe2wpmfrdYv3raxf1Dl2m8YNkW3NcUlUWywpCi8GnJGSnEth8ITn0m387T6Z1Ye-f1SJX81fw_pTfAhgAfQ06NDFK6ahEMPEA6g7vc_jzAb4pHIZHFEUp1rEIH4MrKaGIVhdw3/s2284/image20.png" imageanchor="1"><img data-original-height="1106" data-original-width="2284" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgKH2VD6leBGzfWhjN5LA17iDfKlYLIglznzDDI_A73_Jfs4D-tpZR2gPRe2wpmfrdYv3raxf1Dl2m8YNkW3NcUlUWywpCi8GnJGSnEth8ITn0m387T6Z1Ye-f1SJX81fw_pTfAhgAfQ06NDFK6ahEMPEA6g7vc_jzAb4pHIZHFEUp1rEIH4MrKaGIVhdw3/s16000/image20.png"/></a></td></tr><tr><td>Our baseline learned cost model employs a GNN since programs can be naturally represented as graphs.</td></tr></tbody></table>




<p>
Furthermore we present <a href="https://arxiv.org/abs/2305.12322">Graph Segment Training</a> (GST), a method for scaling GNN training to handle large graphs on a device with limited memory capacity in cases where the prediction task is on the entire-graph (i.e., graph-level prediction). Unlike scaling training for node- or edge-level prediction, scaling for graph-level prediction is understudied but crucial to our domain, as computation graphs can contain hundreds of thousands of nodes. In a typical GNN training (“Full Graph Training”, on the left below), a GNN model is trained using an entire graph, meaning all nodes and edges of the graph are used to compute gradients. For large graphs, this might be computationally infeasible. In GST, each large graph is partitioned into smaller segments, and a random subset of segments is selected to update the model; embeddings for the remaining segments are produced without saving their intermediate activations (to avoid consuming memory). The embeddings of all segments are then combined to generate an embedding for the original large graph, which is then used for prediction. In addition, we introduce the historical embedding table to efficiently obtain graph segments’ embeddings and segment dropout to mitigate the staleness from historical embeddings. Together, our complete method speeds up the end-to-end training time by 3×.
</p>




<table><tbody><tr><td><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgX7cF7Sl6XY3xYwmUp7lqPoXGsXaV3RqVC0YgUG_AQy4XAv7B75eaWpZy_gmbq0UG6VVX0wEjvuOyg2Ce7ALeuVLaUBgKUvEWvAi0RnYsN61d7z3YAm9NEeCpEKQu_YU7ZTAgS71h6mq-bpX6H2HFv73TIHd_W1DsZyastPfjG4hogWf3cy8uf_5DGJjDV/s790/image2.png"><img data-original-height="434" data-original-width="790" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgX7cF7Sl6XY3xYwmUp7lqPoXGsXaV3RqVC0YgUG_AQy4XAv7B75eaWpZy_gmbq0UG6VVX0wEjvuOyg2Ce7ALeuVLaUBgKUvEWvAi0RnYsN61d7z3YAm9NEeCpEKQu_YU7ZTAgS71h6mq-bpX6H2HFv73TIHd_W1DsZyastPfjG4hogWf3cy8uf_5DGJjDV/s16000/image2.png"/></a></td></tr><tr><td>Comparing Full Graph Training (typical method) vs Graph Segment Training (our proposed method).</td></tr></tbody></table>




<h2>Kaggle competition</h2>


<p>
Finally, we ran the “<a href="https://kaggle.com/competitions/predict-ai-model-runtime">Fast or Slow? Predict AI Model Runtime</a>” competition over the TpuGraph dataset. This competition ended with 792 participants on 616 teams. We had 10507 submissions from 66 countries. For 153 users (including 47 in the top 100), this was their first competition. We learned many interesting new techniques employed by the participating teams, such as:
</p>
<ul>

<li><em>Graph pruning / compression</em>: Instead of using the GST method, many teams experimented with different ways to compress large graphs (e.g., keeping only subgraphs that include the configurable nodes and their immediate neighbors).

</li><li><em>Feature padding value</em>: Some teams observed that the default padding value of 0 is problematic because 0 clashes with a valid feature value, so using a padding value of -1 can improve the model accuracy significantly.

</li><li><em>Node features</em>: Some teams observed that additional node features (such as <a href="https://www.tensorflow.org/xla/operation_semantics#dot">dot general’s contracting dimensions</a>) are important. A few teams found that different encodings of node features also matter.

</li><li><em>Cross-configuration attention</em>: A winning team designed a simple layer that allows the model to explicitly &#34;compare&#34; configs against each other. This technique is shown to be much better than letting the model infer for each config individually. 
</li>
</ul>
<p>
We will debrief the competition and preview the winning solutions at the competition session at the <a href="https://mlforsystems.org/">ML for Systems workshop</a> at NeurIPS on December 16, 2023. Finally, congratulations to all the winners and thank you for your contributions to advancing research in ML for systems!
</p>





<h2>NeurIPS expo</h2>


<p>
If you are interested in more research about structured data and artificial intelligence, we hosted the NeurIPS Expo panel <a href="https://nips.cc/Expo/Conferences/2023/talk%20panel/78252">Graph Learning Meets Artificial Intelligence</a> on December 9, which covered advancing learned cost models and more! 
</p>




<h2>Acknowledgements</h2>


<p>
<em>Sami Abu-el-Haija (Google Research) contributed significantly to this work and write-up.   The research in this post describes joint work with many additional collaborators including Mike Burrows, Kaidi Cao, Bahare Fatemi, Jure Leskovec, Charith Mendis, Dustin Zelle, and Yanqi Zhou.</em>
</p>
</div>
</div></div>
  </body>
</html>
