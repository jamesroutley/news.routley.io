<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eli.thegreenplace.net/2022/the-y-combinator-in-go-with-generics/">Original</a>
    <h1>The Y Combinator in Go with generics</h1>
    
    <div id="readability-page-1" class="page"><div>
                
                <p>A few years ago I&#39;ve <a href="https://eli.thegreenplace.net/2016/some-notes-on-the-y-combinator/">written in some detail</a> about
the Y combinator, including implementations in Clojure and Python.</p>
<p>This short post is showing how to implement the Y combinator in Go using
generics; in general, static typing makes the Y combinator somewhat less
appealing, but I figured that generics will at least allow the implementation to
be reasonably reusable. Not that this is useful in any real-world scenario, of
course :-)</p>
<p>I won&#39;t explain how the Y combinator itself
works here (please refer to the <a href="https://eli.thegreenplace.net/2016/some-notes-on-the-y-combinator/">previous post</a> for
that), only the Go specifics. The full, runnable code for this post is available
<a href="https://github.com/eliben/code-for-blog/tree/master/2022/ycombinator-go">on GitHub</a>.</p>
<div><pre><span></span><span>type</span> <span>Func</span><span>[</span><span>T</span><span>,</span> <span>U</span> <span>any</span><span>]</span> <span>func</span><span>(</span><span>T</span><span>)</span> <span>U</span>
<span>type</span> <span>TagFunc</span><span>[</span><span>T</span><span>,</span> <span>U</span> <span>any</span><span>]</span> <span>func</span><span>(</span><span>Func</span><span>[</span><span>T</span><span>,</span> <span>U</span><span>])</span> <span>Func</span><span>[</span><span>T</span><span>,</span> <span>U</span><span>]</span>
<span>type</span> <span>CombinatorFunc</span><span>[</span><span>T</span><span>,</span> <span>U</span> <span>any</span><span>]</span> <span>func</span><span>(</span><span>CombinatorFunc</span><span>[</span><span>T</span><span>,</span> <span>U</span><span>])</span> <span>Func</span><span>[</span><span>T</span><span>,</span> <span>U</span><span>]</span>
</pre></div>
<p>The Y combinator&#39;s definition uses several kinds of anonymous functions. In Go,
we need those to have explicit types. <tt>Func</tt> is the underlying computation
function - it&#39;s what the function type would be if we&#39;d used normal recursion.
It&#39;s parameterized with two generic types: <tt>T</tt> for its parameter type and
<tt>U</tt> for its return type.</p>
<p><tt>FuncTag</tt> is the type of the functions users should write now.
<tt>CombinatorFunc</tt> is only used in the definition of the Y combinator itself:</p>
<div><pre><span></span><span>func</span> <span>Y</span><span>[</span><span>T</span><span>,</span> <span>U</span> <span>any</span><span>](</span><span>f</span> <span>TagFunc</span><span>[</span><span>T</span><span>,</span> <span>U</span><span>])</span> <span>Func</span><span>[</span><span>T</span><span>,</span> <span>U</span><span>]</span> <span>{</span>
  <span>return</span> <span>func</span><span>(</span><span>self</span> <span>CombinatorFunc</span><span>[</span><span>T</span><span>,</span> <span>U</span><span>])</span> <span>Func</span><span>[</span><span>T</span><span>,</span> <span>U</span><span>]</span> <span>{</span>
    <span>return</span> <span>f</span><span>(</span><span>func</span><span>(</span><span>n</span> <span>T</span><span>)</span> <span>U</span> <span>{</span>
      <span>return</span> <span>self</span><span>(</span><span>self</span><span>)(</span><span>n</span><span>)</span>
    <span>})</span>
  <span>}(</span><span>func</span><span>(</span><span>self</span> <span>CombinatorFunc</span><span>[</span><span>T</span><span>,</span> <span>U</span><span>])</span> <span>Func</span><span>[</span><span>T</span><span>,</span> <span>U</span><span>]</span> <span>{</span>
    <span>return</span> <span>f</span><span>(</span><span>func</span><span>(</span><span>n</span> <span>T</span><span>)</span> <span>U</span> <span>{</span>
      <span>return</span> <span>self</span><span>(</span><span>self</span><span>)(</span><span>n</span><span>)</span>
    <span>})</span>
  <span>})</span>
<span>}</span>
</pre></div>
<p>Here&#39;s how to use it. To define a recursive factorial-computing function that
does not refer to itself by name, the user has to create a &#34;tag&#34; function that
takes and returns a <tt>Func</tt>. At this point we also instantiate the <tt>Func</tt>
to have the exact types we need:</p>
<div><pre><span></span><span>var</span> <span>factorial_tag</span> <span>=</span> <span>func</span><span>(</span><span>recurse</span> <span>Func</span><span>[</span><span>int</span><span>,</span> <span>int</span><span>])</span> <span>Func</span><span>[</span><span>int</span><span>,</span> <span>int</span><span>]</span> <span>{</span>
  <span>return</span> <span>func</span><span>(</span><span>n</span> <span>int</span><span>)</span> <span>int</span> <span>{</span>
    <span>if</span> <span>n</span> <span>==</span> <span>0</span> <span>{</span>
      <span>return</span> <span>1</span>
    <span>}</span>
    <span>return</span> <span>n</span> <span>*</span> <span>recurse</span><span>(</span><span>n</span><span>-</span><span>1</span><span>)</span>
  <span>}</span>
<span>}</span>
</pre></div>
<p>And the actual factorial function that users can call is created with:</p>

<p>Now <tt>fac</tt> is function of type <tt>Func</tt>: it computes and returns the factorial
of its parameter, and can be simply invoked as <tt>answer := fac(param)</tt>.</p>
<p>We can also try the other example in my previous post - a function that finds
the sum of values in a binary tree. It demonstrates a slightly more complicated
recursive flow as well as different types for the function&#39;s parameter and
return value:</p>
<div><pre><span></span><span>type</span> <span>Node</span> <span>struct</span> <span>{</span>
  <span>val</span>   <span>int</span>
  <span>left</span>  <span>*</span><span>Node</span>
  <span>right</span> <span>*</span><span>Node</span>
<span>}</span>

<span>var</span> <span>treesum_tag</span> <span>=</span> <span>func</span><span>(</span><span>recurse</span> <span>Func</span><span>[</span><span>*</span><span>Node</span><span>,</span> <span>int</span><span>])</span> <span>Func</span><span>[</span><span>*</span><span>Node</span><span>,</span> <span>int</span><span>]</span> <span>{</span>
  <span>return</span> <span>func</span><span>(</span><span>n</span> <span>*</span><span>Node</span><span>)</span> <span>int</span> <span>{</span>
    <span>if</span> <span>n</span> <span>==</span> <span>nil</span> <span>{</span>
      <span>return</span> <span>0</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>return</span> <span>n</span><span>.</span><span>val</span> <span>+</span> <span>recurse</span><span>(</span><span>n</span><span>.</span><span>left</span><span>)</span> <span>+</span> <span>recurse</span><span>(</span><span>n</span><span>.</span><span>right</span><span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</pre></div>
<p>And once again, the actual usable function is generated by invoking <tt>Y</tt>:</p>
<div><pre><span></span><span>treesum</span> <span>:=</span> <span>Y</span><span>(</span><span>treesum_tag</span><span>)</span>
</pre></div>

            </div></div>
  </body>
</html>
