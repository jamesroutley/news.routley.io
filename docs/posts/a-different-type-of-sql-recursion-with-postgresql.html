<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/vb-consulting/blog/discussions/1">Original</a>
    <h1>A Different Type of SQL Recursion with PostgreSQL</h1>
    
    <div id="readability-page-1" class="page"><div role="presentation" data-paste-markdown-skip="">
    <tbody data-target-translation-id="5635436" data-target-translation-type="discussion">
        <tr>
    <td>
        
<p dir="auto">PostgreSQL offers a powerful procedural programming model out of the box (in addition to the standard SQL).</p>
<p dir="auto">You can combine that with the standard SQL approach to overcome almost any issue and solve any programming task. Sometimes, the good old procedural approach may be a more straightforward way out of the complex data problems than standard SQL.</p>
<p dir="auto">This article will try to demonstrate that approach to a complex problem example.</p>
<h2 dir="auto">The Problem</h2>
<p dir="auto">Let&#39;s say we want to write a function that will return <strong>all related tables</strong> for a table name in a parameter.</p>
<p dir="auto">We will start with a made-up schema:</p>
<div dir="auto" data-snippet-clipboard-copy-content="create table division_status (
    division_status_id int primary key, 
    name text
);

create table department_status (
    department_status_id int primary key, 
    name text
);

create table divisions (
    division_id int primary key, 
    name text, 
    owner_user_id int,
    parent_division_id int,
    division_status_id int
);

create table departments (
    department_id int primary key, 
    name text, 
    owner_user_id int,
    parent_department_id int,
    division_id int,
    department_status_id int
);

create table users (
    user_id int primary key, 
    name text, 
    owner_user_id int, 
    department_id int
);

alter table users add foreign key (department_id) references departments (department_id);
alter table users add foreign key (owner_user_id) references users (user_id);

alter table departments add foreign key (owner_user_id) references users (user_id);
alter table departments add foreign key (parent_department_id) references departments (department_id);
alter table departments add foreign key (division_id) references divisions (division_id);
alter table departments add foreign key (department_status_id) references department_status (department_status_id);

alter table divisions add foreign key (owner_user_id) references users (user_id);
alter table divisions add foreign key (parent_division_id) references divisions (division_id);
alter table divisions add foreign key (division_status_id) references division_status (division_status_id);"><pre><span>create</span> <span>table</span> <span>division_status</span> (
    division_status_id <span>int</span> <span>primary key</span>, 
    name <span>text</span>
);

<span>create</span> <span>table</span> <span>department_status</span> (
    department_status_id <span>int</span> <span>primary key</span>, 
    name <span>text</span>
);

<span>create</span> <span>table</span> <span>divisions</span> (
    division_id <span>int</span> <span>primary key</span>, 
    name <span>text</span>, 
    owner_user_id <span>int</span>,
    parent_division_id <span>int</span>,
    division_status_id <span>int</span>
);

<span>create</span> <span>table</span> <span>departments</span> (
    department_id <span>int</span> <span>primary key</span>, 
    name <span>text</span>, 
    owner_user_id <span>int</span>,
    parent_department_id <span>int</span>,
    division_id <span>int</span>,
    department_status_id <span>int</span>
);

<span>create</span> <span>table</span> <span>users</span> (
    user_id <span>int</span> <span>primary key</span>, 
    name <span>text</span>, 
    owner_user_id <span>int</span>, 
    department_id <span>int</span>
);

<span>alter</span> <span>table</span> users add <span>foreign key</span> (department_id) <span>references</span> departments (department_id);
<span>alter</span> <span>table</span> users add <span>foreign key</span> (owner_user_id) <span>references</span> users (user_id);

<span>alter</span> <span>table</span> departments add <span>foreign key</span> (owner_user_id) <span>references</span> users (user_id);
<span>alter</span> <span>table</span> departments add <span>foreign key</span> (parent_department_id) <span>references</span> departments (department_id);
<span>alter</span> <span>table</span> departments add <span>foreign key</span> (division_id) <span>references</span> divisions (division_id);
<span>alter</span> <span>table</span> departments add <span>foreign key</span> (department_status_id) <span>references</span> department_status (department_status_id);

<span>alter</span> <span>table</span> divisions add <span>foreign key</span> (owner_user_id) <span>references</span> users (user_id);
<span>alter</span> <span>table</span> divisions add <span>foreign key</span> (parent_division_id) <span>references</span> divisions (division_id);
<span>alter</span> <span>table</span> divisions add <span>foreign key</span> (division_status_id) <span>references</span> division_status (division_status_id);</pre></div>
<p dir="auto">As we can see, we have the following tables:</p>
<ul dir="auto">
<li><code>users</code> - references itself (<code>users</code>) and table <code>departments</code></li>
<li><code>departments</code> references itself, table <code>users</code>, table <code>divisions</code>, and table <code>department_status</code>.</li>
<li><code>divisions</code> references itself, table <code>users</code> and table <code>division_status</code>.</li>
</ul>
<p dir="auto">So, what we want to achieve is to have a function that will return all related tables directly and indirectly, together with the level of relation.</p>
<p dir="auto">For example, we want to be able to call a function <code>select_foreign_tables</code>  for table <code>users</code> as a parameter, like this:</p>
<div dir="auto" data-snippet-clipboard-copy-content="select * from select_foreign_tables(&#39;public&#39;, &#39;users&#39;);"><pre><span>select</span> <span>*</span> <span>from</span> select_foreign_tables(<span><span>&#39;</span>public<span>&#39;</span></span>, <span><span>&#39;</span>users<span>&#39;</span></span>);</pre></div>
<p dir="auto">This should return the following result:</p>
<table role="table">
<thead>
<tr>
<th>table_schema</th>
<th>table_name</th>
<th>fk_table_schema</th>
<th>fk_table_name</th>
<th>level</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>users</td>
<td>public</td>
<td>departments</td>
<td>1</td>
</tr>
<tr>
<td>public</td>
<td>users</td>
<td>public</td>
<td>users</td>
<td>1</td>
</tr>
<tr>
<td>public</td>
<td>departments</td>
<td>public</td>
<td>divisions</td>
<td>2</td>
</tr>
<tr>
<td>public</td>
<td>departments</td>
<td>public</td>
<td>department_status</td>
<td>2</td>
</tr>
<tr>
<td>public</td>
<td>departments</td>
<td>public</td>
<td>users</td>
<td>2</td>
</tr>
<tr>
<td>public</td>
<td>departments</td>
<td>public</td>
<td>departments</td>
<td>2</td>
</tr>
<tr>
<td>public</td>
<td>divisions</td>
<td>public</td>
<td>divisions</td>
<td>3</td>
</tr>
<tr>
<td>public</td>
<td>divisions</td>
<td>public</td>
<td>users</td>
<td>3</td>
</tr>
<tr>
<td>public</td>
<td>divisions</td>
<td>public</td>
<td>division_status</td>
<td>3</td>
</tr>
</tbody>
</table>
<p dir="auto">As we can see, each row should also have a level assigned. For example, if table <code>users</code> directly references table <code>departments</code>, that&#39;s level 1. But, <code>department_status</code> is level 2 because <code>users</code> references <code>departments</code> and departments references <code>department_status </code>, and so on...</p>
<p dir="auto">Simple, right? It is just another data-related task. Now, how would we do that?</p>
<p dir="auto">Let&#39;s start with a basic query.</p>
<h2 dir="auto">Basic Query</h2>
<p dir="auto">A basic query is the PostgreSQL system query that will query system tables to fetch information about direct references. It&#39;s a rather complicated query, and I won&#39;t get into it, but for the sake of simplicity, let&#39;s create a view out of it:</p>
<div dir="auto" data-snippet-clipboard-copy-content="create view fk_tables as
select 
    con.schema as table_schema,
    cl2.relname as table_name,
    ns.nspname as fk_table_schema,
    cl.relname as fk_table_name
from
    (select 
        unnest(con1.conkey) as parent, 
        unnest(con1.confkey) as child, 
        con1.confrelid, 
        con1.conrelid,
        con1.contype,
        ns.nspname as schema
    from 
        pg_class cl
        inner join pg_namespace ns on cl.relnamespace = ns.oid
        inner join pg_constraint con1 on con1.conrelid = cl.oid
    ) con
    inner join pg_attribute att on att.attrelid = con.confrelid and att.attnum = con.child
    inner join pg_class cl on cl.oid = con.confrelid
    inner join pg_attribute att2 on att2.attrelid = con.conrelid and att2.attnum = con.parent
    inner join pg_class cl2 on cl2.oid = att2.attrelid
    inner join pg_namespace ns on cl.relnamespace = ns.oid;

comment on view fk_tables is &#39;Retuls list of all tables and join related tables for each table.&#39;;"><pre><span>create</span> <span>view</span> <span>fk_tables</span> <span>as</span>
<span>select</span> 
    <span>con</span>.<span>schema</span> <span>as</span> table_schema,
    <span>cl2</span>.<span>relname</span> <span>as</span> table_name,
    <span>ns</span>.<span>nspname</span> <span>as</span> fk_table_schema,
    <span>cl</span>.<span>relname</span> <span>as</span> fk_table_name
<span>from</span>
    (<span>select</span> 
        unnest(<span>con1</span>.<span>conkey</span>) <span>as</span> parent, 
        unnest(<span>con1</span>.<span>confkey</span>) <span>as</span> child, 
        <span>con1</span>.<span>confrelid</span>, 
        <span>con1</span>.<span>conrelid</span>,
        <span>con1</span>.<span>contype</span>,
        <span>ns</span>.<span>nspname</span> <span>as</span> schema
    <span>from</span> 
        pg_class cl
        <span>inner join</span> pg_namespace ns <span>on</span> <span>cl</span>.<span>relnamespace</span> <span>=</span> <span>ns</span>.<span>oid</span>
        <span>inner join</span> pg_constraint con1 <span>on</span> <span>con1</span>.<span>conrelid</span> <span>=</span> <span>cl</span>.<span>oid</span>
    ) con
    <span>inner join</span> pg_attribute att <span>on</span> <span>att</span>.<span>attrelid</span> <span>=</span> <span>con</span>.<span>confrelid</span> <span>and</span> <span>att</span>.<span>attnum</span> <span>=</span> <span>con</span>.<span>child</span>
    <span>inner join</span> pg_class cl <span>on</span> <span>cl</span>.<span>oid</span> <span>=</span> <span>con</span>.<span>confrelid</span>
    <span>inner join</span> pg_attribute att2 <span>on</span> <span>att2</span>.<span>attrelid</span> <span>=</span> <span>con</span>.<span>conrelid</span> <span>and</span> <span>att2</span>.<span>attnum</span> <span>=</span> <span>con</span>.<span>parent</span>
    <span>inner join</span> pg_class cl2 <span>on</span> <span>cl2</span>.<span>oid</span> <span>=</span> <span>att2</span>.<span>attrelid</span>
    <span>inner join</span> pg_namespace ns <span>on</span> <span>cl</span>.<span>relnamespace</span> <span>=</span> <span>ns</span>.<span>oid</span>;

<span>comment on view fk_tables is </span><span><span>&#39;</span>Retuls list of all tables and join related tables for each table.<span>&#39;</span></span>;</pre></div>
<p dir="auto">Fine, it&#39;s ugly and dirty; don&#39;t even look at it.</p>
<p dir="auto">Use it as a view, for example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="select * from fk_tables where table_schema = &#39;public&#39; and table_name = &#39;users&#39;;"><pre><span>select</span> <span>*</span> <span>from</span> fk_tables <span>where</span> table_schema <span>=</span> <span><span>&#39;</span>public<span>&#39;</span></span> <span>and</span> table_name <span>=</span> <span><span>&#39;</span>users<span>&#39;</span></span>;</pre></div>
<p dir="auto">This will return first-level references for the table <code>users</code>:</p>
<table role="table">
<thead>
<tr>
<th>table_schema</th>
<th>table_name</th>
<th>fk_table_schema</th>
<th>fk_table_name</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>users</td>
<td>public</td>
<td>departments</td>
</tr>
<tr>
<td>public</td>
<td>users</td>
<td>public</td>
<td>users</td>
</tr>
</tbody>
</table>
<p dir="auto">Now, all we have to do is run the same query again for each of these FK tables in this results, and we&#39;re done.</p>
<p dir="auto">That&#39;s why it&#39;s called recursion.</p>
<h2 dir="auto">Solution 1</h2>
<p dir="auto">Luckily for us, PostgreSQL has <a href="https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-RECURSIVE" rel="nofollow">recursive common-table queries</a> as a standard feature, and we can do the first solution with that.</p>
<p dir="auto">For a recursion seed, we can use the filter on our <code>fk_tables </code> view.</p>
<div dir="auto" data-snippet-clipboard-copy-content="select
    t.table_schema,
    t.table_name,
    t.fk_table_schema,
    t.fk_table_name
from
    fk_tables t
where 
    t.table_schema = &#39;public&#39;
    and t.table_name = &#39;users&#39;"><pre><span>select</span>
    <span>t</span>.<span>table_schema</span>,
    <span>t</span>.<span>table_name</span>,
    <span>t</span>.<span>fk_table_schema</span>,
    <span>t</span>.<span>fk_table_name</span>
<span>from</span>
    fk_tables t
<span>where</span> 
    <span>t</span>.<span>table_schema</span> <span>=</span> <span><span>&#39;</span>public<span>&#39;</span></span>
    <span>and</span> <span>t</span>.<span>table_name</span> <span>=</span> <span><span>&#39;</span>users<span>&#39;</span></span></pre></div>
<p dir="auto">In the recursive part, we can return the FK table as the base table and join the  <code>fk_tables </code> view again to get the real FK tables like this:</p>
<div dir="auto" data-snippet-clipboard-copy-content="    select
        rec.fk_table_schema as table_schema,
        rec.fk_table_name as table_name,
        t.fk_table_schema,
        t.fk_table_name
    from
        _recursive_cte rec
        inner join fk_tables t on
            rec.fk_table_schema = t.table_schema 
            and rec.fk_table_name = t.table_name   "><pre>    <span>select</span>
        <span>rec</span>.<span>fk_table_schema</span> <span>as</span> table_schema,
        <span>rec</span>.<span>fk_table_name</span> <span>as</span> table_name,
        <span>t</span>.<span>fk_table_schema</span>,
        <span>t</span>.<span>fk_table_name</span>
    <span>from</span>
        _recursive_cte rec
        <span>inner join</span> fk_tables t <span>on</span>
            <span>rec</span>.<span>fk_table_schema</span> <span>=</span> <span>t</span>.<span>table_schema</span> 
            <span>and</span> <span>rec</span>.<span>fk_table_name</span> <span>=</span> <span>t</span>.<span>table_name</span>   </pre></div>
<p dir="auto">All together, it should look like this:</p>
<div dir="auto" data-snippet-clipboard-copy-content="with recursive _recursive_cte as 
(
    select
        t.table_schema,
        t.table_name,
        t.fk_table_schema,
        t.fk_table_name

    from
        fk_tables t
    where 
        t.table_schema = &#39;public&#39;
        and t.table_name = &#39;users&#39;
    
    union 

    select
        rec.fk_table_schema as table_schema,
        rec.fk_table_name as table_name,
        t.fk_table_schema,
        t.fk_table_name

    from
        _recursive_cte rec
        inner join fk_tables t on
            rec.fk_table_schema = t.table_schema 
            and rec.fk_table_name = t.table_name    
)
select
    table_schema,   
    table_name,
    fk_table_schema, 
    fk_table_name
from
    _recursive_cte"><pre>with recursive _recursive_cte <span>as</span> 
(
    <span>select</span>
        <span>t</span>.<span>table_schema</span>,
        <span>t</span>.<span>table_name</span>,
        <span>t</span>.<span>fk_table_schema</span>,
        <span>t</span>.<span>fk_table_name</span>

    <span>from</span>
        fk_tables t
    <span>where</span> 
        <span>t</span>.<span>table_schema</span> <span>=</span> <span><span>&#39;</span>public<span>&#39;</span></span>
        <span>and</span> <span>t</span>.<span>table_name</span> <span>=</span> <span><span>&#39;</span>users<span>&#39;</span></span>
    
    <span>union</span> 

    <span>select</span>
        <span>rec</span>.<span>fk_table_schema</span> <span>as</span> table_schema,
        <span>rec</span>.<span>fk_table_name</span> <span>as</span> table_name,
        <span>t</span>.<span>fk_table_schema</span>,
        <span>t</span>.<span>fk_table_name</span>

    <span>from</span>
        _recursive_cte rec
        <span>inner join</span> fk_tables t <span>on</span>
            <span>rec</span>.<span>fk_table_schema</span> <span>=</span> <span>t</span>.<span>table_schema</span> 
            <span>and</span> <span>rec</span>.<span>fk_table_name</span> <span>=</span> <span>t</span>.<span>table_name</span>    
)
<span>select</span>
    table_schema,   
    table_name,
    fk_table_schema, 
    fk_table_name
<span>from</span>
    _recursive_cte</pre></div>
<p dir="auto">Confusing? We have yet to start with the confusing part.</p>
<p dir="auto">Anyway, this query will return all FK tables for <code>users</code> at all levels:</p>
<table role="table">
<thead>
<tr>
<th>table_schema</th>
<th>table_name</th>
<th>fk_table_schema</th>
<th>fk_table_name</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>users</td>
<td>public</td>
<td>departments</td>
</tr>
<tr>
<td>public</td>
<td>users</td>
<td>public</td>
<td>users</td>
</tr>
<tr>
<td>public</td>
<td>departments</td>
<td>public</td>
<td>users</td>
</tr>
<tr>
<td>public</td>
<td>departments</td>
<td>public</td>
<td>departments</td>
</tr>
<tr>
<td>public</td>
<td>departments</td>
<td>public</td>
<td>divisions</td>
</tr>
<tr>
<td>public</td>
<td>departments</td>
<td>public</td>
<td>department_status</td>
</tr>
<tr>
<td>public</td>
<td>divisions</td>
<td>public</td>
<td>users</td>
</tr>
<tr>
<td>public</td>
<td>divisions</td>
<td>public</td>
<td>divisions</td>
</tr>
<tr>
<td>public</td>
<td>divisions</td>
<td>public</td>
<td>division_status</td>
</tr>
</tbody>
</table>
<p dir="auto">However, we still need levels. We can count it manually, but we&#39;d rather have instead the database engine do it.</p>
<p dir="auto">First naive try it to add level 1 at recursion seed like this:</p>
<div dir="auto" data-snippet-clipboard-copy-content="select
    t.table_schema,
    t.table_name,
    t.fk_table_schema,
    t.fk_table_name,
    1 as level

from
    fk_tables t
where 
    t.table_schema = &#39;public&#39;
    and t.table_name = &#39;users&#39;"><pre><span>select</span>
    <span>t</span>.<span>table_schema</span>,
    <span>t</span>.<span>table_name</span>,
    <span>t</span>.<span>fk_table_schema</span>,
    <span>t</span>.<span>fk_table_name</span>,
    <span>1</span> <span>as</span> level

<span>from</span>
    fk_tables t
<span>where</span> 
    <span>t</span>.<span>table_schema</span> <span>=</span> <span><span>&#39;</span>public<span>&#39;</span></span>
    <span>and</span> <span>t</span>.<span>table_name</span> <span>=</span> <span><span>&#39;</span>users<span>&#39;</span></span></pre></div>
<p dir="auto">And have it increased by one in each recursion step:</p>
<div dir="auto" data-snippet-clipboard-copy-content="select
    rec.fk_table_schema as table_schema,
    rec.fk_table_name as table_name,
    t.fk_table_schema,
    t.fk_table_name,
    rec.level + 1 as level
from
    _recursive_cte rec
    inner join fk_tables t on
        rec.fk_table_schema = t.table_schema 
        and rec.fk_table_name = t.table_name  "><pre><span>select</span>
    <span>rec</span>.<span>fk_table_schema</span> <span>as</span> table_schema,
    <span>rec</span>.<span>fk_table_name</span> <span>as</span> table_name,
    <span>t</span>.<span>fk_table_schema</span>,
    <span>t</span>.<span>fk_table_name</span>,
    <span>rec</span>.<span>level</span> <span>+</span> <span>1</span> <span>as</span> level
<span>from</span>
    _recursive_cte rec
    <span>inner join</span> fk_tables t <span>on</span>
        <span>rec</span>.<span>fk_table_schema</span> <span>=</span> <span>t</span>.<span>table_schema</span> 
        <span>and</span> <span>rec</span>.<span>fk_table_name</span> <span>=</span> <span>t</span>.<span>table_name</span>  </pre></div>
<p dir="auto">This is very naive. We have a <code>union</code> of seed query and recursion query. The <code>union</code> operator filters out duplicate records by default. From the moment we&#39;ve introduced a level number that is unique, duplicates won&#39;t be filtered out. And since <code>users</code> references <code>departments</code> and  <code>departments</code>  references <code>users</code> again, the query will end up in an infinite loop, which potentially could crash the server.</p>
<p dir="auto">So this is reckless and even dangerous.</p>
<p dir="auto">What we have here is a very well-known data problem - the gap and islands problem.</p>
<p dir="auto">What we want to do is this:</p>
<ul dir="auto">
<li>keep the sort order and</li>
<li>on each change in <code>table_schema</code> and <code>table_name</code> - increase the counter by one.</li>
</ul>
<p dir="auto">To be able to do this, we first need to add two more calculated fields:</p>
<ul dir="auto">
<li>Row number - we will use this just to keep the sort order.</li>
<li>Calculated field that is 1 when the table in a row changed from the previous row. Otherwise, it is 0.</li>
</ul>
<p dir="auto">Here is what it looks like:</p>
<div dir="auto" data-snippet-clipboard-copy-content="select
    table_schema,   
    table_name,
    fk_table_schema, 
    fk_table_name,
    row_number() over(),
    case 
        when lag(table_schema) over() = table_schema and lag(table_name) over() = table_name 
        then 0
        else 1
    end as island_flips
from
    _recursive_cte"><pre><span>select</span>
    table_schema,   
    table_name,
    fk_table_schema, 
    fk_table_name,
    row_number() over(),
    case 
        when lag(table_schema) over() <span>=</span> table_schema <span>and</span> lag(table_name) over() <span>=</span> table_name 
        then <span>0</span>
        else <span>1</span>
    end <span>as</span> island_flips
<span>from</span>
    _recursive_cte</pre></div>
<p dir="auto">We can wrap this into another CTE and do the last calculation in the final query:</p>
<div dir="auto" data-snippet-clipboard-copy-content="select
    table_schema,   
    table_name,
    fk_table_schema, 
    fk_table_name,
    island_flips,
    sum(island_flips) over (order by row_number) as level
from
    _cte
order by 
    row_number"><pre><span>select</span>
    table_schema,   
    table_name,
    fk_table_schema, 
    fk_table_name,
    island_flips,
    <span>sum</span>(island_flips) over (<span>order by</span> row_number) <span>as</span> level
<span>from</span>
    _cte
<span>order by</span> 
    row_number</pre></div>
<p dir="auto">Field <code>island_flips</code> will be one if the previous table is different; otherwise, it is 0. Now, if we do a cumulative sum over those values with <code>sum(island_flips) over (order by row_number) as level</code> - we will get the correct levels.</p>
<p dir="auto">Here is the final version of the plain SQL function:</p>
<div dir="auto" data-snippet-clipboard-copy-content="create or replace function select_foreign_tables(
    _table_schema text,
    _table_name text
)
returns table (
    table_schema text,
    table_name text,
    fk_table_schema text,
    fk_table_name text,
    level int
)
language sql
as 
$$
with recursive _recursive_cte as 
(
    select
        t.table_schema,
        t.table_name,
        t.fk_table_schema,
        t.fk_table_name
    from
        fk_tables t
    where 
        t.table_schema = _table_schema
        and t.table_name = _table_name
    
    union 

    select
        rec.fk_table_schema as table_schema,
        rec.fk_table_name as table_name,
        t.fk_table_schema,
        t.fk_table_name

    from
        _recursive_cte rec
        inner join fk_tables t on
            rec.fk_table_schema = t.table_schema 
            and rec.fk_table_name = t.table_name    
    
), _cte as (
    
    select
        table_schema,   
        table_name,
        fk_table_schema, 
        fk_table_name,
        row_number() over(),
        case 
            when lag(table_schema) over() = table_schema and lag(table_name) over() = table_name 
            then 0
            else 1
        end as island_flips
    from
        _recursive_cte
)
select
    table_schema,   
    table_name,
    fk_table_schema, 
    fk_table_name,
    sum(island_flips) over (order by row_number) as level
from
    _cte
order by 
    row_number
$$;"><pre><span>create or replace</span> <span>function</span> <span>select_foreign_tables</span>(
    _table_schema <span>text</span>,
    _table_name <span>text</span>
)
returns table (
    table_schema <span>text</span>,
    table_name <span>text</span>,
    fk_table_schema <span>text</span>,
    fk_table_name <span>text</span>,
    level <span>int</span>
)
language sql
<span>as</span> 
$$
with recursive _recursive_cte <span>as</span> 
(
    <span>select</span>
        <span>t</span>.<span>table_schema</span>,
        <span>t</span>.<span>table_name</span>,
        <span>t</span>.<span>fk_table_schema</span>,
        <span>t</span>.<span>fk_table_name</span>
    <span>from</span>
        fk_tables t
    <span>where</span> 
        <span>t</span>.<span>table_schema</span> <span>=</span> _table_schema
        <span>and</span> <span>t</span>.<span>table_name</span> <span>=</span> _table_name
    
    <span>union</span> 

    <span>select</span>
        <span>rec</span>.<span>fk_table_schema</span> <span>as</span> table_schema,
        <span>rec</span>.<span>fk_table_name</span> <span>as</span> table_name,
        <span>t</span>.<span>fk_table_schema</span>,
        <span>t</span>.<span>fk_table_name</span>

    <span>from</span>
        _recursive_cte rec
        <span>inner join</span> fk_tables t <span>on</span>
            <span>rec</span>.<span>fk_table_schema</span> <span>=</span> <span>t</span>.<span>table_schema</span> 
            <span>and</span> <span>rec</span>.<span>fk_table_name</span> <span>=</span> <span>t</span>.<span>table_name</span>    
    
), _cte <span>as</span> (
    
    <span>select</span>
        table_schema,   
        table_name,
        fk_table_schema, 
        fk_table_name,
        row_number() over(),
        case 
            when lag(table_schema) over() <span>=</span> table_schema <span>and</span> lag(table_name) over() <span>=</span> table_name 
            then <span>0</span>
            else <span>1</span>
        end <span>as</span> island_flips
    <span>from</span>
        _recursive_cte
)
<span>select</span>
    table_schema,   
    table_name,
    fk_table_schema, 
    fk_table_name,
    <span>sum</span>(island_flips) over (<span>order by</span> row_number) <span>as</span> level
<span>from</span>
    _cte
<span>order by</span> 
    row_number
$$;</pre></div>
<p dir="auto">Do you think this sounds complicated?</p>
<p dir="auto">It sounds complicated because it is.</p>
<p dir="auto">Let&#39;s try to solve this problem with a completely different approach.</p>
<h2 dir="auto">Solution 2</h2>
<p dir="auto">In this approach, we will use an old-school procedural programming approach - instead of using the recursive SQL query - we will use a normal function recursion as you would with any other language.</p>
<p dir="auto">So, instead of creating a function of the <code>sql</code> type - this new function will be of the <code>plpgsql</code> type. This allows us to use procedural extensions like &#34;if branching&#34;, &#34;loops&#34; and so on... Those are the concepts most developers are familiar with.</p>
<p dir="auto">The idea is to create a temporary table that we will insert in recursive calls and return values from that temporary table on the last call.</p>
<p dir="auto">The function skeleton will look like this:</p>
<div dir="auto" data-snippet-clipboard-copy-content="create or replace function select_foreign_tables2(
    _table_schema text,
    _table_name text,
    _level int = 1
)
returns table (
    table_schema text,
    table_name text,
    fk_table_schema text,
    fk_table_name text,
    level int
)
language plpgsql
as 
$$
begin

    create temp table if not exists _result (
        table_schema text,
        table_name text,
        fk_table_schema text,
        fk_table_name text,
        level int
    ) on commit drop;

    if exists(
        select 1 from _result t where t.table_schema = _table_schema and t.table_name = _table_name
    ) then
        return;
    end if;

    -- 
    -- Insert  _result table in a loop with recursive calls here
    --    

    return query 
    select 
        t.table_schema, 
        t.table_name,
        t.fk_table_schema, 
        t.fk_table_name,
        t.level
    from 
        _result t;
end;
$$;"><pre><span>create or replace</span> <span>function</span> <span>select_foreign_tables2</span>(
    _table_schema <span>text</span>,
    _table_name <span>text</span>,
    _level <span>int</span> <span>=</span> <span>1</span>
)
returns table (
    table_schema <span>text</span>,
    table_name <span>text</span>,
    fk_table_schema <span>text</span>,
    fk_table_name <span>text</span>,
    level <span>int</span>
)
language plpgsql
<span>as</span> 
$$
<span>begin</span>

    create temp table if not exists _result (
        table_schema <span>text</span>,
        table_name <span>text</span>,
        fk_table_schema <span>text</span>,
        fk_table_name <span>text</span>,
        level <span>int</span>
    ) <span>on</span> <span>commit</span> drop;

    if exists(
        <span>select</span> <span>1</span> <span>from</span> _result t <span>where</span> <span>t</span>.<span>table_schema</span> <span>=</span> _table_schema <span>and</span> <span>t</span>.<span>table_name</span> <span>=</span> _table_name
    ) then
        return;
    end if;

    <span><span>--</span> </span>
    <span><span>--</span> Insert  _result table in a loop with recursive calls here</span>
    <span><span>--</span>    </span>

    return query 
    <span>select</span> 
        <span>t</span>.<span>table_schema</span>, 
        <span>t</span>.<span>table_name</span>,
        <span>t</span>.<span>fk_table_schema</span>, 
        <span>t</span>.<span>fk_table_name</span>,
        <span>t</span>.<span>level</span>
    <span>from</span> 
        _result t;
end;
$$;</pre></div>
<p dir="auto">What we first need to do is to create a temporary table:</p>
<div dir="auto" data-snippet-clipboard-copy-content="create temp table if not exists _result (
    table_schema text,
    table_name text,
    fk_table_schema text,
    fk_table_name text,
    level int
) on commit drop;"><pre>create temp table if not exists _result (
    table_schema <span>text</span>,
    table_name <span>text</span>,
    fk_table_schema <span>text</span>,
    fk_table_name <span>text</span>,
    level <span>int</span>
) <span>on</span> <span>commit</span> drop;</pre></div>
<p dir="auto">This table will be automatically dropped when transaction commits (or rollbacks). All PostgreSQL functions in procedural language are in transaction by default (notice <code>begin</code> and <code>end</code>).</p>
<p dir="auto">When we call this function again in a recursion - it will still be the same transaction. The new transaction is merged into the existing transaction (PostgreSQL doesn&#39;t support nested transactions, as far as I know).</p>
<p dir="auto">However, since it will be called recursively, that temp table may already exist. That&#39;s why we also need to check if it exists <code>create temp table if not exists</code>.</p>
<p dir="auto">Next, we must check did we went trough this step already. Meaning, have we processed that table from parameters. If we have, exit immediately:</p>
<div dir="auto" data-snippet-clipboard-copy-content="if exists(
    select 1 from _result t where t.table_schema = _table_schema and t.table_name = _table_name
) then
    return;
end if;"><pre>if exists(
    <span>select</span> <span>1</span> <span>from</span> _result t <span>where</span> <span>t</span>.<span>table_schema</span> <span>=</span> _table_schema <span>and</span> <span>t</span>.<span>table_name</span> <span>=</span> _table_name
) then
    return;
end if;</pre></div>
<p dir="auto">And now, we are ready to insert the data:</p>
<ul dir="auto">
<li>Loop through the <code>fk_tables</code> view for table parameters and for each record:</li>
<li>Insert into the result.</li>
<li>Call recursively the same function again but, use <code>fk_table_schema</code> and <code>fk_table_name</code> as parameters and increase one level.</li>
</ul>
<p dir="auto">Here is what that loop looks like:</p>
<div dir="auto" data-snippet-clipboard-copy-content="for _row in (
    select
        t.table_schema,
        t.table_name,
        t.fk_table_schema,
        t.fk_table_name
    from
        fk_tables t
    where 
        t.table_schema = _table_schema
        and t.table_name = _table_name
) loop

    insert into _result
    select 
        _row.table_schema, 
        _row.table_name,
        _row.fk_table_schema, 
        _row.fk_table_name,
        _level;

    perform sys.select_foreign_tables2(
        _row.fk_table_schema, 
        _row.fk_table_name, 
        _level + 1
    );

end loop;"><pre>for _row <span>in</span> (
    <span>select</span>
        <span>t</span>.<span>table_schema</span>,
        <span>t</span>.<span>table_name</span>,
        <span>t</span>.<span>fk_table_schema</span>,
        <span>t</span>.<span>fk_table_name</span>
    <span>from</span>
        fk_tables t
    <span>where</span> 
        <span>t</span>.<span>table_schema</span> <span>=</span> _table_schema
        <span>and</span> <span>t</span>.<span>table_name</span> <span>=</span> _table_name
) loop

    <span>insert into</span> _result
    <span>select</span> 
        <span>_row</span>.<span>table_schema</span>, 
        <span>_row</span>.<span>table_name</span>,
        <span>_row</span>.<span>fk_table_schema</span>, 
        <span>_row</span>.<span>fk_table_name</span>,
        _level;

    perform <span>sys</span>.<span>select_foreign_tables2</span>(
        <span>_row</span>.<span>fk_table_schema</span>, 
        <span>_row</span>.<span>fk_table_name</span>, 
        _level <span>+</span> <span>1</span>
    );

end loop;</pre></div>
<p dir="auto">And finally, the entire function:</p>
<div dir="auto" data-snippet-clipboard-copy-content="create or replace function select_foreign_tables2(
    _table_schema text,
    _table_name text,
    _level int = 1
)
returns table (
    table_schema text,
    table_name text,
    fk_table_schema text,
    fk_table_name text,
    level int
)
language plpgsql
as 
$$
declare 
    _row record;
begin
    create temp table if not exists _result (
        table_schema text,
        table_name text,
        fk_table_schema text,
        fk_table_name text,
        level int
    ) on commit drop;

    if exists(
        select 1 from _result t where t.table_schema = _table_schema and t.table_name = _table_name
    ) then
        return;
    end if;

    for _row in (
        select
            t.table_schema,
            t.table_name,
            t.fk_table_schema,
            t.fk_table_name
        from
            fk_tables t
        where 
            t.table_schema = _table_schema
            and t.table_name = _table_name
    ) loop

        insert into _result
        select 
            _row.table_schema, 
            _row.table_name,
            _row.fk_table_schema, 
            _row.fk_table_name,
            _level;

        perform sys.select_foreign_tables2(
            _row.fk_table_schema, 
            _row.fk_table_name, 
            _level + 1
        );

    end loop;

    return query 
    select 
        t.table_schema, 
        t.table_name,
        t.fk_table_schema, 
        t.fk_table_name,
        t.level
    from 
        _result t;
end;
$$;"><pre><span>create or replace</span> <span>function</span> <span>select_foreign_tables2</span>(
    _table_schema <span>text</span>,
    _table_name <span>text</span>,
    _level <span>int</span> <span>=</span> <span>1</span>
)
returns table (
    table_schema <span>text</span>,
    table_name <span>text</span>,
    fk_table_schema <span>text</span>,
    fk_table_name <span>text</span>,
    level <span>int</span>
)
language plpgsql
<span>as</span> 
$$
declare 
    _row record;
<span>begin</span>
    create temp table if not exists _result (
        table_schema <span>text</span>,
        table_name <span>text</span>,
        fk_table_schema <span>text</span>,
        fk_table_name <span>text</span>,
        level <span>int</span>
    ) <span>on</span> <span>commit</span> drop;

    if exists(
        <span>select</span> <span>1</span> <span>from</span> _result t <span>where</span> <span>t</span>.<span>table_schema</span> <span>=</span> _table_schema <span>and</span> <span>t</span>.<span>table_name</span> <span>=</span> _table_name
    ) then
        return;
    end if;

    for _row <span>in</span> (
        <span>select</span>
            <span>t</span>.<span>table_schema</span>,
            <span>t</span>.<span>table_name</span>,
            <span>t</span>.<span>fk_table_schema</span>,
            <span>t</span>.<span>fk_table_name</span>
        <span>from</span>
            fk_tables t
        <span>where</span> 
            <span>t</span>.<span>table_schema</span> <span>=</span> _table_schema
            <span>and</span> <span>t</span>.<span>table_name</span> <span>=</span> _table_name
    ) loop

        <span>insert into</span> _result
        <span>select</span> 
            <span>_row</span>.<span>table_schema</span>, 
            <span>_row</span>.<span>table_name</span>,
            <span>_row</span>.<span>fk_table_schema</span>, 
            <span>_row</span>.<span>fk_table_name</span>,
            _level;

        perform <span>sys</span>.<span>select_foreign_tables2</span>(
            <span>_row</span>.<span>fk_table_schema</span>, 
            <span>_row</span>.<span>fk_table_name</span>, 
            _level <span>+</span> <span>1</span>
        );

    end loop;

    return query 
    <span>select</span> 
        <span>t</span>.<span>table_schema</span>, 
        <span>t</span>.<span>table_name</span>,
        <span>t</span>.<span>fk_table_schema</span>, 
        <span>t</span>.<span>fk_table_name</span>,
        <span>t</span>.<span>level</span>
    <span>from</span> 
        _result t;
end;
$$;</pre></div>
<h2 dir="auto">Conclusion</h2>
<p dir="auto">Which of these two approaches is better, in your opinion?</p>
<p dir="auto">Recursive CTE queries are powerful but confusing and limiting. This old-school procedural programming approach may be a much better fit for developers untrained with SQL, and that is, in my opinion, the majority. On the other hand, the procedural approach may be something most developers feel comfortable with.</p>
<p dir="auto">Leave comments below.</p>
<hr/>
    </td>
  </tr>

    </tbody>
  </div></div>
  </body>
</html>
