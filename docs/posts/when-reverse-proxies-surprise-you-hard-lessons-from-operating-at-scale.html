<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.infoq.com/articles/scaling-reverse-proxies/">Original</a>
    <h1>When Reverse Proxies Surprise You: Hard Lessons from Operating at Scale</h1>
    
    <div id="readability-page-1" class="page"><div>
							
								<div>
									<h3>Key Takeaways</h3>
									<ul>
	<li>Optimization is contextual. An optimization that speeds up one proxy on sixteen cores may grind to a halt on sixty-four due to lock contention. Always profile on your target hardware for your target workload.</li>
	<li>The mundane kills scale. Outages rarely come from exotic bugs. They come from missed commas, file descriptor limits, and watchdog failures. Test and monitor the boring details relentlessly.</li>
	<li>Keep the common path lean. Don’t let exceptions or abstractions pollute the main flow. Handle edge cases explicitly.</li>
	<li>Trust metrics, not theory. Proxies rarely behave as expected. Instrument the hot path to catch hidden CPU costs and mismeasured dependencies. Profiling is mandatory.</li>
	<li>Prioritize human factors. Outage recovery depends on what operators can see and do under stress. When dashboards fail, clear logs, simple commands, and predictable behavior matter more than complex mechanisms.</li>
</ul>

									
								</div>
							
							
								
								<h2>The Critical Fragility of the Proxy Layer</h2>

<p>Reverse proxies are the unsung workhorses of internet-scale infrastructure. They terminate Transport Layer Security (TLS), defend against denial of service (DoS), balance load, cache responses, and connect rapidly evolving services. Whether you call it a load balancer, edge proxy, API gateway, or Kubernetes ingress controller, this layer is where all traffic converges, and, more often than we would like to admit, where it breaks.</p>

<p>This article is a collection of war stories from running a massive reverse proxy fleet. It explores optimizations that backfired, routine changes that triggered outages, and the hard operational lessons that shaped how we design and run proxies today.</p>

<h2>The Optimization Trap: When Tuning Becomes Toxic</h2>

<p>Optimizations are seductive. They promise free performance, look brilliant in benchmarks, and often work perfectly in small environments.</p>


								
								
									








								
								<p>But once hosts scale past fifty cores and fleets serve millions of QPS across several hundred nodes, the rules change dramatically, and a performance win in one place can quickly become a liability at scale.</p>

<h3>The Freelist Contention Catastrophe</h3>

<p>We scaled out Apache Traffic Server (ATS) by moving from a fleet of smaller-core machines to modern, higher-core hosts. The assumption was simple: More cores should mean proportionally more throughput. On legacy hardware, ATS’s freelist optimization delivered exactly as expected, reducing heap contention and improving allocation speed.</p>

<p>But on 64-core hosts, the same freelist design backfired. ATS relied on a single global lock for freelist access. With dozens of cores hammering it simultaneously, the lock became a hotspot, causing thrashing and wasted CPU cycles. Instead of doubling throughput, tail latencies increased and overall throughput dropped. The proxy spent more time fighting freelist contention than serving traffic.</p>


								
								
									
								
								<p>We were skeptical of our own analysis at first. The freelist was supposed to be a win. But once we <a href="https://docs.trafficserver.apache.org/en/latest/appendices/command-line/traffic_server.en.html#cmdoption-traffic_server-f">disabled</a> it, throughput jumped from roughly 2k to about 6k requests per second, a 3x improvement.</p>

<h3>The Hidden Tax of Lock-Free Design</h3>

<p>We also struggled with <a href="https://en.wikipedia.org/wiki/Read-copy-update">Read-Copy-Update (RCU)</a>, a pattern popular in kernels and high-performance user space for enabling fast, lock-free reads. The trade-off is that every write requires copying the structure, and the original memory can only be reclaimed once all active readers are done.</p>

<p>At large scale, the cost of constant new/delete cycles, even when deferred, ballooned. The proxy fronted hundreds of thousands of hosts. Adding or deleting a single host meant copying large structures, driving measurable memory churn during traffic peaks. The lock-free reads were fast, but deferred memory reclamation became an expensive tax that degraded performance. Surprisingly, switching back to a simple lock-based approach was not only more efficient but also more predictable.</p>

<h3>The DNS Collapse at Scale</h3>

<p>With HAProxy, we once hit a failure that showed how scale exposes math you can ignore at smaller sizes. The built-in <a href="https://github.com/haproxy/haproxy/issues/1185#issuecomment-802281382">DNS resolver used</a> a <a href="https://www.geeksforgeeks.org/dsa/what-does-big-on2-complexity-mean">quadratic-time</a> lookup for some scenarios (meaning the lookup time grows proportional to the square of the number of records or hosts). At small host counts, the extra work was invisible and the system ran smoothly.</p>

<p>But when we enabled this proxy across a much larger fleet, the cost surfaced all at once. What had been a background detail became crippling at hundreds of hosts, driving CPU spikes and crashes across the proxy fleet.</p>

<p>The <a href="https://github.com/haproxy/haproxy/issues/1185">bug</a> was later fixed upstream, but the takeaway stuck with us. Inefficiencies don’t need to change their complexity class to become dangerous. Sometimes scale simply makes the hidden cost impossible to ignore.</p>

<p><strong>Production Lesson</strong>: Code that &#34;works fine&#34; at small scale may still hide <a href="https://en.wikipedia.org/wiki/Big_O_notation">O(N²)</a> or worse behavior. At hundreds or thousands of nodes, those costs stop being theoretical and start breaking production.</p>

<h2>The Mundane Outage: When Defaults and Routine Tasks Bite Back</h2>

<p>The failures that bring down billion-dollar systems are rarely exotic zero-days or esoteric protocol bugs. They’re almost always mundane with misplaced characters, forgotten defaults, or an OS feature doing its job too well.</p>

<h3>The YAML Comma of Death, Revisited</h3>

<p>For certain routing and policy decisions, our proxy fetched runtime metadata from a remote service. Engineers edited this value in a UI, expecting a comma-separated list <code>(a,b,c)</code>. One day, an engineer at LinkedIn <a href="https://www.usenix.org/conference/srecon22emea/presentation/palino">missed a comma</a>, turning the list into a single malformed token. The control service’s validation was minimal and passed the bad payload downstream. Our proxy’s parser was stricter.When the proxy pulled the update and tried to interpret the value as a list, it panicked and crashed.</p>

<p>Because this metadata was core to startup, any instance that restarted immediately crashed again after fetching the same bad value. To make things worse, the UI lived behind the proxy itself, so we couldn’t fix the list until we performed an out-of-band restore.</p>

<h3>The Silent Killers: FDs and Watchdogs</h3>

<p>Basic OS limits can turn into catastrophic failures. In one incident, a system standardization reset the <a href="https://unix.stackexchange.com/questions/625616/what-is-the-historical-reason-for-limits-on-file-descriptors-ulimit-n">maximum File Descriptor (FD) limit to a much lower default</a>, reasonable for most apps, but not for a proxy handling hundreds of thousands of concurrent connections. During peak traffic, the proxy exhausted field descriptors (FDs). New connections and in-flight requests were silently dropped or delayed, causing cascading failures that looked far more complex than they were.</p>

<p>Another outage came from a &#34;routine cleanup.&#34; An engineer spotted processes running under the user <a href="https://en.wikipedia.org/wiki/Nobody_(username)">nobody</a> and assumed they were stray. Many Unix services (including our proxy) deliberately run with <a href="https://docs.trafficserver.apache.org/en/latest/admin-guide/files/records.yaml.en.html#management">nobody</a> for reduced privileges. The cleanup script killed them fleet-wide, instantly taking down a large portion of the site.</p>

<p><strong>Production Lesson</strong>: The most damaging failures aren’t glamorous. They come from defaults, bad inputs, and routine hygiene tasks everyone takes for granted. Always treat remote metadata as untrusted. Validate semantics, not just syntax. Cache and fall back to a last known good value. Decouple the control plane from the data plane, and stage changes behind canaries. When possible, prefer static config over dynamic metadata. Monitor resources well before the cliff, and enforce guardrails around every fleet-wide action.</p>

<h2>Trust But Verify: Measuring the Hot Path</h2>

<p>Assumptions are poison in traffic infrastructure. At scale, the smallest function can quietly consume disproportionate resources.</p>

<h3>The Cached Header That Wasn’t</h3>

<p>Header parsing is expensive in proxies, and much of our policy logic depends on inspecting specific headers. To optimize this, our codebase used a method named extractHeader, which was annotated with a comment that the value would be cached and the header parsed only once. On the surface, the code appeared to work that way, with a Boolean flag indicating whether the result had already been extracted.</p>

<p>When we profiled CPU usage at scale, though, header parsing kept surfacing as a bottleneck. That made no sense, the function name promised caching. After digging in, we found that over the years, the function had accreted new logic. Somewhere along the way, the headerExtracted flag was reset, forcing a full re-parse every time the header was accessed. On a single request, the same header could be reparsed hundreds of times.</p>

<p>Debugging dragged on for weeks because the method’s name created a false sense of trust. It looked like caching, but in practice almost nothing was cached.</p>

<h3>The Random Number Bottleneck</h3>

<p>At first glance, generating a random number looks like pure, stateless compute, a trivial, negligible operation. In practice, the common <code><a href="https://docs.haproxy.org/dev/configuration.html#7.3.2-rand">rand</a>()</code> implementation relied on a global lock to protect its state. At low QPS, the lock contention was invisible. But on high-core machines under sustained load, that global lock turned into a hotspot. Requests piled up waiting for &#34;randomness&#34;, and what should have been one of the cheapest operations in the system became a source of latency and throughput collapse.</p>

<p>The fix was to switch to a lower-cost, thread-safe <a href="https://github.com/haproxy/haproxy/commit/95f40c698d3ef3ad25fded5a7c35e2d108d2b542">random generator</a> designed for concurrency, but the lesson was deeper. Even functions we think of as stateless math can hide synchronization and contention costs that explode at scale.</p>

<p><strong>Production Lesson</strong>: Never assume &#34;simple&#34; library calls are free. Profile them in the hot path, especially under high-core, high-QPS workloads where hidden locks turn trivial functions into bottlenecks.</p>

<h3>The &#34;Naive&#34; Header Check</h3>

<p>Some problems don’t come from incorrect code but from idiomatic code that hides costly side effects.</p>

<p>A developer once wrote a simple check in Go to validate whether an HTTP header was empty:</p>

<pre><code>splitted_headers := strings.Split(header, &#34;:&#34;)
if len(splitted_headers) &gt; 1 { ... }</code></pre>

<p>This was perfectly idiomatic Go: clear, readable, and safe. In unit tests and small-scale runs, it worked flawlessly. But in production, at thousands of requests per second, the overhead of <code><a href="https://pkg.go.dev/strings#Split">strings.Split</a></code> became obvious. Each call allocated a new slice, creating unnecessary churn in the hot path. CPU cycles vanished into allocations, and latency quietly rose.</p>

<p>The fix was embarrassingly simple: Avoid splitting altogether. By scanning for the : character directly, we eliminated allocations and reduced the check to a lightweight operation.</p>

<p><strong>Production Lesson</strong>: Idiomatic code isn’t always code worthy of production. What looks simple or harmless in tests can become a hidden bottleneck at scale. In the hot path, assume nothing is free. Profile relentlessly and trust data over assumptions.</p>

<h2>Exceptions Are Not the Norm: Keeping the Common Path Clean</h2>

<p>In distributed systems, elegance often comes from unification: one rule to cover all cases. But collapsing the normal path and the exceptions into the same bucket makes systems brittle and slow.</p>

<h3>The Hash-Key Contention</h3>

<p>While debugging contention in our load balancer, we noticed every request was paying the cost of a hash lookup, and host updates were stalling. What was even more surprising, the hash table usually contained only a single key.</p>

<p>The root cause was a rare deployment. One upstream team had split the same app across multiple clusters, each mapped to a different shard key. To support that one case, the code was generalized to always expect a structure like:</p>

<pre><code>{ app_name =&gt; { hash_key1 =&gt; host_list1, hash_key2 =&gt; host_list2 } }</code></pre>

<p>But for almost every app, there was just a single host list. The shard-based indirection was an exception, not the norm, yet it became the default for everyone.</p>

<p>We simplified it back to:</p>

<pre><code>{ app_name =&gt; host_list }</code></pre>

<p>This removed unnecessary hash lookups, eliminated update contention, and made the system faster and easier to reason about. The rare shard-based deployments were handled explicitly, outside the common path.</p>

<h3>When Exceptions Drive the Wrong Fix</h3>

<p>During a proxy migration, we initially left most settings at their defaults. Soon after starting the migration, we had a report of failures in a rare use case involving unusually long headers and cookies. The quick fix was obvious: Raise the <a href="https://docs.haproxy.org/dev/configuration.html#3.2-tune.bufsize">limit</a>. The issue disappeared, until it reappeared the next week. We raised the limit again, and then again, each time chasing the same exception.</p>

<p>Only when we benchmarked did the real cost surface: every increase inflated memory usage and reduced overall throughput. By catering to one outlier, we degraded performance for everyone.</p>

<p>The right answer was not to bend the system to that exception. We reverted the limit changes and asked that single use case to remain on the old stack. Once we did, the new stack immediately delivered higher throughput and lower latency. The team eventually fixed the offending cookie and migrated to the new stack at a later point.</p>

<h3>The Experimentation Bloat</h3>

<p>In our proxy, we built support for experimentation, intended for quick A/B tests, feature rollouts, or migrations. The mechanism worked, but it required careful setup and validation. Instead, someone extended it by default: tooling was added to auto-generate experimentation configs for every service.</p>

<p>At first this seemed like a win: less manual work, easier to turn on. In practice, most of those experiments were invalid. They didn’t work as intended but gave the impression that they did, which misled operators. Debugging became painful because failed experiments looked like routing issues, and startup sequences often broke under the extra complexity.</p>

<p>Eventually, we rolled back the changes. We removed the default auto-generation and required experimentation to be added deliberately, case by case. Later the tooling was updated to automatically check from other sources if such experimentation would be required and added only for those scenarios. These updates cut down the number of routing rules dramatically, saved critical CPU cycles, and kept the site stable.</p>

<p><strong>Production Lesson</strong>: Never let exceptions dictate the norm. Handle them explicitly, in isolated paths or tiers, instead of polluting the mainline logic. What looks like &#34;flexibility&#34; is often just deferred fragility waiting to surface at scale.</p>

<h2>Design for the Operator Under Stress</h2>

<p>Machines run the systems, but humans recover them. A proxy might handle millions of requests per second, but when something breaks at the edge, recovery depends on a tired operator staring at a terminal at 3:00 AM.</p>

<h3>When the Dashboards Went Dark</h3>

<p>During a partial power outage, our entire monitoring and alerting pipeline went dark. Dashboards, tracing UIs, and service discovery consoles were offline and we couldn’t even fail out of the affected data center because the failover user interface (UI) and command line interface (CLI) depended on services that were already degraded. What saved us were the basics: <code>ssh</code>, <code>grep</code>, <code>awk</code>, and <code>netstat</code>. With those muscle-memory tools, and eventually a manual override buried in the failout tool, we traced failing flows, isolated the bad tier, and forced the failover. If the team had lost its comfort with fundamentals or if that escape hatch hadn’t existed, we would have been blind.</p>

<p>We also learned the hard way that observability systems must never depend on the very proxy they are meant to monitor. At one point, proxy logs were shipped correctly to a central platform, but the UI to view those logs, and the central visualization server itself, were only accessible through the proxy fleet. When the fleet struggled, operators could no longer reach the dashboards. Logs were still flowing, but we had no way to see them.</p>

<p>The fix was to keep a local log path on every node, always accessible with simple shell tools like <code>grep</code> and <code>awk</code>, even if that meant redundancy. This guaranteed visibility into the system regardless of the proxy’s state.</p>

<h3>The Load-Balancer Knob Maze</h3>

<p>Another pain point was our load-balancing algorithm. It tried to handle everything: connection errors, warm-ups, garbage collection (GC) pauses, traffic spikes, with dozens of knobs such as thresholds, step sizes, starting weights, and decay rates. On paper, it looked powerful; in practice, it was chaos.</p>

<p>When something failed, operators spent hours trial-and-error tuning knobs in the dark, sometimes fixing the issue, sometimes making it worse. Imagine a 3:00 AM pager followed by six hours of guesswork. Eventually, we scrapped the complexity and moved to a simple, time-based warm-up mechanism, similar to <a href="https://cbonte.github.io/haproxy-dconv/2.0/configuration.html#4-slowstart">HAProxy’s slowstart</a>. Recovery became predictable, boring, and fast, the best kind of operational outcome.</p>

<p><strong>Production Lesson</strong>: Operators don’t debug with perfect dashboards in perfect conditions. They debug with the tools that still work when everything else is burning. Design your edge tier so that when rich tooling disappears, the basics, logs, plain text, simple commands, still give operators enough to see and act.</p>

<h2>Conclusion</h2>

<p>Reverse proxies sit at the busiest and most fragile point of modern infrastructure. The lessons here are not about exotic protocols or cutting-edge algorithms, but about the hidden costs, mundane failures, and operator realities that emerge only at scale. By keeping the common path lean, validating every assumption, and designing for humans under stress, we can make this critical layer both resilient and boring, the ideal outcome for any production system.</p>

							
							

							









  
    <div> <!-- main wrapper for authors section -->
        <h2>About the Author</h2> <!-- section title -->

        
            
                
            
            <div data-id="author-Mitendra-Mahto"> <!-- main wrapper for each author -->
                <div>
                    <h4><strong>Mitendra Mahto</strong></h4>
                    <div>
                        
                        <p><span>
                            <span>Show more</span><span>Show less</span>
                        </span>
                    </p></div>
                </div>
            </div>
        
    </div>


                            
                            
						</div></div>
  </body>
</html>
