<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lemire.me/blog/2022/09/14/escaping-strings-faster-with-avx-512/">Original</a>
    <h1>Escaping strings faster with AVX-512</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>When programming, we often have to ‘escape’ strings. A standard way to do it is to insert the backslash character (\) before some characters such as the double quote. For example, the string</p>
<pre><tt>my title is &#34;La vie&#34;</tt></pre>
<p>becomes</p>
<pre><tt>my title is \&#34;La vie\&#34;</tt></pre>
<p>A simple routine in C++ to escape a string might look as follows:</p>
<pre>  <span>for</span> <span>(</span><span>.</span><span>.</span><span>.</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>(</span><span>*</span>in <span>=</span><span>=</span> <span>&#39;\\&#39;</span><span>)</span> <span>|</span><span>|</span> <span>(</span><span>*</span>in <span>=</span><span>=</span> <span>&#39;&#34;&#39;</span><span>)</span><span>)</span> <span>{</span>
      <span>*</span>out<span>+</span><span>+</span> <span>=</span> <span>&#39;\\&#39;</span><span>;</span>
    <span>}</span>
    <span>*</span>out<span>+</span><span>+</span> <span>=</span> <span>*</span>in<span>;</span>
  <span>}</span>
</pre>
<p>Such a character-by-character approach is unlikely to provide the best possible performance on modern hardware.</p>
<p>Recent Intel processors have fast instructions (AVX-512) that are well suited for such problems. I decided to sketch a solution using Intel intrinsic functions. The routine goes as follows:</p>
<ol>
<li>I use two constant registers containing 64 copies of the backslash character and 64 copies of the quote characters.</li>
<li>I start a loop by loading 32 bytes from the input.</li>
<li>I expands these 32 bytes into a 64 byte register, interleaving zero bytes.</li>
<li>I copy these bytes with the quotes and backslash characters.</li>
<li>From the resulting mask, I then construct (by shifting and blending) escaped characters.</li>
<li>I ‘compress’ the result, removing the zero bytes that appear before the unescaped characters.</li>
<li>I advance the output pointer by the number of written bytes and I continue the loop.</li>
</ol>
<p>The C++ code roughly looks like this…</p>
<pre>  __m512i solidus <span>=</span> _mm512_set1_epi8<span>(</span><span>&#39;\\&#39;</span><span>)</span><span>;</span>
  __m512i quote <span>=</span> _mm512_set1_epi8<span>(</span><span>&#39;&#34;&#39;</span><span>)</span><span>;</span>
  <span>for</span> <span>(</span><span>;</span> in <span>+</span> <span>32</span> <span>&lt;</span><span>=</span> finalin<span>;</span> in <span>+</span><span>=</span> <span>32</span><span>)</span> <span>{</span>
    __m256i input <span>=</span> _mm256_loadu_si256<span>(</span>in<span>)</span><span>;</span>
    __m512i input1 <span>=</span> _mm512_cvtepu8_epi16<span>(</span>input<span>)</span><span>;</span>
    __mmask64 is_solidus <span>=</span> _mm512_cmpeq_epi8_mask<span>(</span>input1<span>,</span> solidus<span>)</span><span>;</span>
    __mmask64 is_quote <span>=</span> _mm512_cmpeq_epi8_mask<span>(</span>input1<span>,</span> quote<span>)</span><span>;</span>
    __mmask64 is_quote_or_solidus <span>=</span> _kor_mask64<span>(</span>is_solidus<span>,</span> is_quote<span>)</span><span>;</span>
    __mmask64 to_keep <span>=</span> _kor_mask64<span>(</span>is_quote_or_solidus<span>,</span> <span>0xaaaaaaaaaaaaaaaa</span><span>)</span><span>;</span>
    __m512i shifted_input1 <span>=</span> _mm512_bslli_epi128<span>(</span>input1<span>,</span> <span>1</span><span>)</span><span>;</span>
    __m512i escaped <span>=</span>
        _mm512_mask_blend_epi8<span>(</span>is_quote_or_solidus<span>,</span> shifted_input1<span>,</span> solidus<span>)</span><span>;</span>
    _mm512_mask_compressstoreu_epi8<span>(</span>out<span>,</span> to_keep<span>,</span> escaped<span>)</span><span>;</span>
    out <span>+</span><span>=</span> _mm_popcnt_u64<span>(</span>_cvtmask64_u64<span>(</span>to_keep<span>)</span><span>)</span><span>;</span>
  <span>}</span>
</pre>
<p>This code can be greatly improved. Nevertheless, it is a good first step. What are the results an Intel icelake processor using GCC 11 (Linux) ? A simple benchmark indicates a 5x performance boost compared to a naive implementation:</p>
<table>
<tbody>
<tr>
<td>regular code</td>
<td>0.6 ns/character</td>
</tr>
<tr>
<td>AVX-512 code</td>
<td>0.1 ns/character</td>
</tr>
</tbody>
</table>
<p>It looks quite encouraging ! <a href="https://github.com/lemire/Code-used-on-Daniel-Lemire-s-blog/tree/master/2022/09/14">My source code is available</a>. I require a recent x64 processor with AVX-512 VBMI2 support.</p>
</div></div>
  </body>
</html>
