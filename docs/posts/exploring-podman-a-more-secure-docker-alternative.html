<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://betterstack.com/community/guides/scaling-docker/podman-vs-docker/">Original</a>
    <h1>Exploring Podman: A More Secure Docker Alternative</h1>
    
    <div id="readability-page-1" class="page"><div data-controller="anchors" data-toc-target="content">
<p>Containerization has become an essential tool for developers and system
operators to package and deploy applications on various systems and platforms
efficiently. Many containerization solutions exist today, but without a doubt,
Docker has emerged as the de facto standard. This is largely due to its
excellent tooling, strong community, and vast ecosystem of pre-built images that
can be easily shared and used across different environments.</p><p>Docker has held this position for many years, and it has truly revolutionized
how applications are shipped. At the same time, its wide adoption inspired the
development of many other containerization solutions offering even more features
and capabilities. One such solution is <a rel="" target="_blank" href="https://podman.io/">Podman<span><svg style="--currentColor: currentColor;"><use href="https://betterstack.com/assets/icons/heroicons_v2/mini/arrow-top-right-on-square-d4a4b2dfe559997065a0de05c441ef56d661be449bf96d9ce30eb4e0af2516cf.svg#root"></use></svg></span></a>.</p><p>Podman is an open-source container engine that aims to provide a more secure and
lightweight alternative to Docker. It allows users to run containers without
requiring a daemon, making it easier to manage and deploy containers on a
variety of systems. Additionally, Podman offers better security defaults through
features such as rootless containers (i.e., running containers through non-root
users), user namespaces, and a more careful utilization of kernel capabilities,
all of which can protect the host system from potential vulnerabilities and
security threats.</p><p>With its growing community and close compatibility with Docker images and
commands, Podman has gained significant traction among developers and system
administrators looking for alternative containerization solutions.</p><p>In this article, we&#39;ll explore some of the key features and benefits of using
Podman as a containerization tool. We&#39;ll also discuss how it compares to Docker
and see why it has become a popular alternative choice in the industry.</p><p>Let&#39;s dive right in.</p>
<h2 id="prerequisites">Prerequisites</h2>
<p>Before proceeding with this article, ensure that you meet the following
prerequisites:</p>
<ul>
<li>Good Linux command-line skills.</li>
<li>Prior experience with Docker.</li>
<li>(Optional) A Docker Hub account to follow the private registry setup examples.</li>
</ul>


<h2 id="podman-vs-docker-comparison">Podman vs Docker Comparison</h2>
<p>While both Podman and Docker allow users to run, manage, and deploy containers
in an efficient and scalable manner, there are some key differences between the
two. In this section, we will explore several of these differences:</p>
<h3 id="1-architecture-differences">1. Architecture differences</h3>
<p>One of the main differences between Podman and Docker lies in their
architecture. While Docker relies on a client-server model, Podman employs a
daemonless architecture. With Podman&#39;s approach, users manage containers
directly, eliminating the need for a continuous daemon process in the
background. This direct management often results in Podman containers launching
significantly faster, sometimes up to 50% quicker than Docker, depending on the
image used.</p><p>This architecture also enhances security. In Docker, initiating a container
means sending a request to the Docker daemon via the Docker client which
subsequently launches the container, which means that the container processes
are children of the Docker daemon, not the user session:</p>
<p>As a result, any significant event coming from a container process that&#39;s picked
up by the Linux Audit system (<code>auditd</code>) specifies its audit user ID as <code>unset</code>
rather than the actual ID of the user who started the respective container in
the first place. This makes it extremely difficult to link malicious activity to
a specific user and taints the security of the system.</p>
<p>With Podman, since each container is instantiated directly through a user login
session, the container process data retains this information and <code>auditd</code> can
accurately detect and list the ID of each user who started a specific container
process, maintaining a clear audit trail.</p>
<h3 id="2-container-lifecycle-management">2. Container lifecycle management</h3>
<p>The absence of a daemon in Podman leads to a distinct approach to managing
container lifecycles compared to Docker. On Linux, Podman relies extensively on
<a rel="" target="_blank" href="https://systemd.io/">Systemd<span><svg style="--currentColor: currentColor;"><use href="https://betterstack.com/assets/icons/heroicons_v2/mini/arrow-top-right-on-square-d4a4b2dfe559997065a0de05c441ef56d661be449bf96d9ce30eb4e0af2516cf.svg#root"></use></svg></span></a> for this purpose. For instance, to correctly
enforce restart policies for containers using the <code>--restart always</code> flag,
Podman relies on a <code>systemd</code> service called <code>podman-restart</code>. This service
automatically restarts all designated containers after each system reboot.</p><p>Moreover, Podman exposes a handy command for generating Systemd service files
from running containers. This allows you to bring your containers under
<code>systemd</code> management to start, stop, and inspect the various services running
inside of them more easily. In contrast, Docker handles all these tasks
internally through the daemon itself.</p>
<h3 id="3-container-orchestration">3. Container orchestration</h3>
<p>When developing locally, Docker users normally reach for
<a rel="" target="_blank" href="https://docs.docker.com/compose/">Docker Compose<span><svg style="--currentColor: currentColor;"><use href="https://betterstack.com/assets/icons/heroicons_v2/mini/arrow-top-right-on-square-d4a4b2dfe559997065a0de05c441ef56d661be449bf96d9ce30eb4e0af2516cf.svg#root"></use></svg></span></a> to define and manage
multi-container applications more easily. While Podman doesn&#39;t support Compose
files out of the box, it provides a compatible alternative called
<a rel="" target="_blank" href="https://github.com/containers/podman-compose">Podman Compose<span><svg style="--currentColor: currentColor;"><use href="https://betterstack.com/assets/icons/heroicons_v2/mini/arrow-top-right-on-square-d4a4b2dfe559997065a0de05c441ef56d661be449bf96d9ce30eb4e0af2516cf.svg#root"></use></svg></span></a>, which typically
works seamlessly with existing <code>docker-compose.yml</code> files. For a native
experience, you may also use pods, a concept that Podman borrows from
<a rel="" target="_blank" href="https://kubernetes.io/">Kubernetes<span><svg style="--currentColor: currentColor;"><use href="https://betterstack.com/assets/icons/heroicons_v2/mini/arrow-top-right-on-square-d4a4b2dfe559997065a0de05c441ef56d661be449bf96d9ce30eb4e0af2516cf.svg#root"></use></svg></span></a> and allows users to manage a group of
containers as one uniform unit.</p><p>When it comes to production deployment, Podman lacks a tool like
<a rel="" target="_blank" href="https://docs.docker.com/engine/swarm/">Docker Swarm<span><svg style="--currentColor: currentColor;"><use href="https://betterstack.com/assets/icons/heroicons_v2/mini/arrow-top-right-on-square-d4a4b2dfe559997065a0de05c441ef56d661be449bf96d9ce30eb4e0af2516cf.svg#root"></use></svg></span></a> for orchestrating
multi-container application workloads. The best possible alternative in such
cases is to use an external orchestration system such as Kubernetes, which
offers similar features and integrates well with Podman, although it may require
some additional configuration and setup to ensure that everything works
correctly.</p>
<h3 id="4-security-considerations">4. Security considerations</h3>
<p>Containers aim to isolate applications from the host system securely, minimizing
compatibility issues and enhancing security. A primary security concern is the
risk of container breakout, where an attacker could compromise the host system.
To mitigate such risks, running containers with minimal privileges is essential.</p><p>Podman is designed to help with this by providing stronger default security
settings compared to Docker. Features like
<a rel="" target="_blank" href="https://docs.docker.com/engine/security/rootless/">rootless containers<span><svg style="--currentColor: currentColor;"><use href="https://betterstack.com/assets/icons/heroicons_v2/mini/arrow-top-right-on-square-d4a4b2dfe559997065a0de05c441ef56d661be449bf96d9ce30eb4e0af2516cf.svg#root"></use></svg></span></a>,
<a rel="" target="_blank" href="https://docs.docker.com/engine/security/userns-remap/">user namespaces<span><svg style="--currentColor: currentColor;"><use href="https://betterstack.com/assets/icons/heroicons_v2/mini/arrow-top-right-on-square-d4a4b2dfe559997065a0de05c441ef56d661be449bf96d9ce30eb4e0af2516cf.svg#root"></use></svg></span></a>, and
<a rel="" target="_blank" href="https://docs.docker.com/engine/security/seccomp/">seccomp profiles<span><svg style="--currentColor: currentColor;"><use href="https://betterstack.com/assets/icons/heroicons_v2/mini/arrow-top-right-on-square-d4a4b2dfe559997065a0de05c441ef56d661be449bf96d9ce30eb4e0af2516cf.svg#root"></use></svg></span></a>, while
available in Docker, aren&#39;t enabled by default and often require extra setup.</p><p>Podman&#39;s default setup includes rootless containers running in isolated user
namespaces, limiting the impact of any potential breakout. In contrast, Docker&#39;s
default setting runs container processes as <code>root</code>, posing a higher risk in case
of a breakout.</p><p>Moreover, Podman containers, tied to user sessions, allow audit systems to trace
malicious activities back to specific users, unlike Docker, where tracing to a
user is challenging due to the system-wide daemon.</p><p>Podman and Docker use Linux kernel capabilities and seccomp profiles to control
process permissions. By default, Podman launches containers with a narrower set
of 11 capabilities compared to Docker&#39;s more permissive default setting of 14
capabilities.</p><p>In general, while both Podman and Docker can be configured for robust security,
Podman generally requires less effort to reach a secure configuration.</p><p><strong>Learn More</strong>: <a rel="" target="" href="https://betterstack.com/community/guides/scaling-docker/docker-security-best-practices/">Docker Security: 14 Best Practices You Should
Know</a></p>
<hr/>
<p>To sum it up, both Docker and Podman are capable tools, and knowing the main
differences between the two can help you choose the right one for your specific
needs. Please refer to the table below for some of the major differences between
the two, and you can assume full parity for most other features.</p><div>
  <table>
    <thead>
      <tr>
<th></th>
<th>Podman</th>
<th>Docker</th>
</tr>

    </thead>
    <tbody>
      <tr>
<td>Daemonless architecture</td>
<td>‚úî</td>
<td>‚úò</td>
</tr>
<tr>
<td>Systemd integration</td>
<td>‚úî</td>
<td>‚úò</td>
</tr>
<tr>
<td>Group containers in pods</td>
<td>‚úî</td>
<td>‚úò</td>
</tr>
<tr>
<td>Supports Docker Swarm</td>
<td>‚úò</td>
<td>‚úî</td>
</tr>
<tr>
<td>Supports Kubernetes YAML</td>
<td>‚úî</td>
<td>‚úò</td>
</tr>

    </tbody>
  </table>
</div>
<p>With all of this clarified, let&#39;s go ahead and install Podman locally.</p>
<h2 id="installing-podman">Installing Podman</h2>
<p>Like Docker, Podman can run without a problem on all popular operating systems.
This includes macOS and Windows, as well as all major Linux distributions. The
only significant difference to note is that while Podman can run natively on
Linux, it requires a virtual machine to work on Windows and macOS. This adds a
few extra steps to the installation process on these systems, but other than
that, the core functionality remains the same.</p><p>This tutorial assumes that you are using a Debian-based Linux distribution such
as Ubuntu, Mint, or Debian itself. The installation process for other operating
systems is very similar and can be applied by referring to the official
<a rel="" target="_blank" href="https://podman.io/docs/installation">Podman installation instructions<span><svg style="--currentColor: currentColor;"><use href="https://betterstack.com/assets/icons/heroicons_v2/mini/arrow-top-right-on-square-d4a4b2dfe559997065a0de05c441ef56d661be449bf96d9ce30eb4e0af2516cf.svg#root"></use></svg></span></a>.</p><p>Make sure that you are using a relatively recent version of your preferred
distribution, as PPA repositories on older versions may not have the latest
Podman available for installation. For instance, at the time of this writing,
the latest major version of Podman is <code>4.x</code>, yet the most recent LTS version of
Ubuntu
(<a rel="" target="_blank" href="https://discourse.ubuntu.com/t/jammy-jellyfish-release-notes/24668">Ubuntu 22.04 LTS<span><svg style="--currentColor: currentColor;"><use href="https://betterstack.com/assets/icons/heroicons_v2/mini/arrow-top-right-on-square-d4a4b2dfe559997065a0de05c441ef56d661be449bf96d9ce30eb4e0af2516cf.svg#root"></use></svg></span></a>)
locks you in to Podman <code>3.x</code>. Therefore, this tutorial is based on a newer
non-LTS version
(<a rel="" target="_blank" href="https://discourse.ubuntu.com/t/mantic-minotaur-release-notes/35534">Ubuntu 23.10<span><svg style="--currentColor: currentColor;"><use href="https://betterstack.com/assets/icons/heroicons_v2/mini/arrow-top-right-on-square-d4a4b2dfe559997065a0de05c441ef56d661be449bf96d9ce30eb4e0af2516cf.svg#root"></use></svg></span></a>).</p><p>Start by downloading the latest information from all configured upstream package
sources:</p>

<p>Then run the following command to install Podman:</p>

<p>You will see an output similar to:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
The following additional packages will be installed:
  aardvark-dns buildah catatonit conmon containernetworking-plugins crun fuse-overlayfs golang-github-containers-common golang-github-containers-image libslirp0 libsubid4 libyajl2 netavark slirp4netns uidmap
Suggested packages:
  containers-storage libwasmedge0 docker-compose
The following NEW packages will be installed:
  aardvark-dns buildah catatonit conmon containernetworking-plugins crun fuse-overlayfs golang-github-containers-common golang-github-containers-image libslirp0 libsubid4 libyajl2 netavark podman slirp4netns uidmap
0 upgraded, 16 newly installed, 0 to remove and 37 not upgraded.
Need to get 28.4 MB of archives.
After this operation, 116 MB of additional disk space will be used.
Do you want to continue? [Y/n] Y
</code></pre>
</div>
</div>

<p>Type <code>Y</code> when prompted, then hit <code>Enter</code> to continue.</p><p>After the installation is completed, you can verify that Podman is available by
typing:</p>



<p>The output indicates that version <code>4.3.1</code> was successfully installed locally,
and you can run <code>podman</code> commands. You are now ready to launch your first
container.</p>
<h2 id="running-your-first-container">Running your first container</h2>
<p>Let&#39;s verify that the installation works by running the well-known
<a rel="" target="_blank" href="https://hub.docker.com/_/hello-world">&#34;Hello World!&#34; image<span><svg style="--currentColor: currentColor;"><use href="https://betterstack.com/assets/icons/heroicons_v2/mini/arrow-top-right-on-square-d4a4b2dfe559997065a0de05c441ef56d661be449bf96d9ce30eb4e0af2516cf.svg#root"></use></svg></span></a> from
<a rel="" target="_blank" href="https://hub.docker.com/">Docker Hub<span><svg style="--currentColor: currentColor;"><use href="https://betterstack.com/assets/icons/heroicons_v2/mini/arrow-top-right-on-square-d4a4b2dfe559997065a0de05c441ef56d661be449bf96d9ce30eb4e0af2516cf.svg#root"></use></svg></span></a>:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>podman run --rm hello-world
</code></pre>
</div>
</div>

<p>You will observe an output similar to:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>Resolved &#34;hello-world&#34; as an alias (/etc/containers/registries.conf.d/shortnames.conf)
Trying to pull docker.io/library/hello-world:latest...
Getting image source signatures
Copying blob 719385e32844 done
Copying config 9c7a54a9a4 done
Writing manifest to image destination
Storing signatures

Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the &#34;hello-world&#34; image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/
</code></pre>
</div>
</div>

<p>This output shows something important. Even though the &#34;Hello World!&#34; image was
built with tools from the Docker ecosystem, Podman was still able to run the
container.</p><p>That&#39;s because both Docker and Podman follow the OCI
(<a rel="" target="_blank" href="https://opencontainers.org/">Open Container Initiative<span><svg style="--currentColor: currentColor;"><use href="https://betterstack.com/assets/icons/heroicons_v2/mini/arrow-top-right-on-square-d4a4b2dfe559997065a0de05c441ef56d661be449bf96d9ce30eb4e0af2516cf.svg#root"></use></svg></span></a>) standards. The OCI
defines an
<a rel="" target="_blank" href="https://github.com/opencontainers/image-spec/blob/main/spec.md">image format specification<span><svg style="--currentColor: currentColor;"><use href="https://betterstack.com/assets/icons/heroicons_v2/mini/arrow-top-right-on-square-d4a4b2dfe559997065a0de05c441ef56d661be449bf96d9ce30eb4e0af2516cf.svg#root"></use></svg></span></a>
and a <a rel="" target="_blank" href="https://github.com/opencontainers/runtime-spec">runtime specification<span><svg style="--currentColor: currentColor;"><use href="https://betterstack.com/assets/icons/heroicons_v2/mini/arrow-top-right-on-square-d4a4b2dfe559997065a0de05c441ef56d661be449bf96d9ce30eb4e0af2516cf.svg#root"></use></svg></span></a>
enabling different container runtimes, such as Podman and Docker, to
interoperate.</p><p>As a result, Podman can seamlessly work with most Docker images and containers.
This compatibility allows you to migrate your existing workloads to Podman
easily without having to make any modifications and also to leverage the vast
library of Docker images available on Docker Hub.</p><p>Let&#39;s further break down the output from the command above. The first line says:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>Resolved &#34;hello-world&#34; as an alias (/etc/containers/registries.conf.d/shortnames.conf)
</code></pre>
</div>
</div>

<p>This message indicates that Podman referenced a configuration file to obtain the
fully qualified name of the <code>hello-world</code> image. Unlike Docker, Podman
recommends against using short names to refer to images and does not default to
a specific registry, unless explicitly instructed to do so via its configuration
files. Docker, on the other hand, always uses Docker Hub (<code>docker.io</code>) as its
default registry and tries to locate every image there when a fully qualified
name is not explicitly provided.</p><p>You can further inspect the <code>shortnames.conf</code> file and confirm that the
<code>hello-world</code> alias maps to the image <code>docker.io/library/hello-world</code>:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>grep hello-world /etc/containers/registries.conf.d/shortnames.conf
</code></pre>
</div>
</div>

<div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>&#34;hello-world&#34; = &#34;docker.io/library/hello-world&#34;
</code></pre>
</div>
</div>

<p>The next few lines say:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>Trying to pull docker.io/library/hello-world:latest...
Getting image source signatures
Copying blob 719385e32844 done
Copying config 9c7a54a9a4 done
Writing manifest to image destination
Storing signatures
</code></pre>
</div>
</div>

<p>These messages indicate that the latest version of the <code>hello-world</code> image was
successfully downloaded to your local machine.</p><p>You can verify this by issuing:</p>

<div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>REPOSITORY                     TAG         IMAGE ID      CREATED       SIZE
docker.io/library/hello-world  latest      9c7a54a9a43c  6 months ago  19.9 kB
</code></pre>
</div>
</div>

<p>The remaining output (the &#34;Hello from Docker!&#34; message and all subsequent lines)
display a message that&#39;s hard-coded into the
<a rel="" target="_blank" href="https://github.com/docker-library/hello-world/blob/master/hello.c">hello<span><svg style="--currentColor: currentColor;"><use href="https://betterstack.com/assets/icons/heroicons_v2/mini/arrow-top-right-on-square-d4a4b2dfe559997065a0de05c441ef56d661be449bf96d9ce30eb4e0af2516cf.svg#root"></use></svg></span></a>
binary that ships with the <code>hello-world</code> image. This message could be a little
misleading as it suggests that the Docker engine executed the container when, in
reality, Podman did. It&#39;s important to understand that neither the Docker client
nor the Docker daemon were in any way involved in the process.</p><p>Before you move on further, remove the <code>hello-world</code> image, as it&#39;s no longer
needed:</p>

<p>The output indicates that the image was removed, displaying its tag and ID for
reference:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>Untagged: docker.io/library/hello-world:latest
Deleted: 9c7a54a9a43cca047013b82af109fe963fde787f63f9e016fdc3384500c2823d
</code></pre>
</div>
</div>

<p>Next, let&#39;s examine what happens when you attempt to run an arbitrary image
using only its short name.</p>
<h2 id="using-short-image-names">Using short image names</h2>
<p>As we discussed previously, Podman suggests using fully-qualified names for
container images to avoid ambiguity and ensure that the correct image is always
referenced from a specific registry.</p><p>Let&#39;s try running a container using the
<a rel="" target="_blank" href="https://hub.docker.com/_/caddy">official Caddy image<span><svg style="--currentColor: currentColor;"><use href="https://betterstack.com/assets/icons/heroicons_v2/mini/arrow-top-right-on-square-d4a4b2dfe559997065a0de05c441ef56d661be449bf96d9ce30eb4e0af2516cf.svg#root"></use></svg></span></a> from Docker Hub. If
you&#39;re unfamiliar with <a rel="" target="" href="https://betterstack.com/community/guides/web-servers/caddy/">Caddy</a>, it&#39;s a lightweight web server and reverse
proxy known for its ease of use and fantastic performance. By running Caddy as a
container, you can quickly spin up a local web server for testing purposes.</p><p>Coming from a Docker background, you would typically use the following command
to start the container:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>docker run --rm -p 8080:80 caddy
</code></pre>
</div>
</div>

<p>This translates to the following command in Podman:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>podman run --rm -p 8080:80 caddy
</code></pre>
</div>
</div>

<p>Most of the time, transitioning from Docker to Podman is a matter of changing
<code>docker</code> to <code>podman</code> in your command. In fact, many users add
<code>alias docker=podman</code> to their shell config files and use Podman as an alias for
<code>docker</code> commands.</p><p>The flags are also identical:</p>
<ul>
<li><code>--rm</code> specifies that the container should be automatically removed after it
exits, so it doesn&#39;t clutter up your system.</li>
<li><code>-p 8080:80</code> specifies that port <code>8080</code> on the host machine should map to port
<code>80</code> in the container, so that you can access the web server running inside
the container by typing <code>localhost:8080</code> in your browser.</li>
</ul>
<p>Try running the command. If everything goes well, a container should launch,
allowing you to open <code>localhost:8080</code> in a browser to see the built-in Caddy
test page.</p><p>Contrary to what you might anticipate, the command fails and returns the
following error:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>Error: short-name &#34;caddy&#34; did not resolve to an alias and no unqualified-search registries are defined in &#34;/etc/containers/registries.conf&#34;
</code></pre>
</div>
</div>

<p>The command didn&#39;t work because Podman couldn&#39;t understand where to pull the
<code>caddy</code> image from.</p><p>It first looked up <code>shortnames.conf</code> for an alias named <code>caddy</code> but could not
find one. Try a <code>grep</code> on <code>shortnames.conf</code>, and you will see that it returns no
matches indeed:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>grep caddy /etc/containers/registries.conf.d/shortnames.conf
</code></pre>
</div>
</div>

<p>It then looked up the <code>registries.conf</code> file for a list of so-called unqualified
search registries. An unqualified search registry is the one that Podman tries
to contact whenever a non-fully qualified image name is supplied with the <code>run</code>
command.</p><p>There are three possible solutions to the issue that you encountered. Let&#39;s
explore all of them:</p>
<h3 id="1-specifying-a-fully-qualified-name">1. Specifying a fully-qualified name</h3>
<p>You can specify the fully-qualified name:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>podman run --rm -p 8080:80 docker.io/library/caddy
</code></pre>
</div>
</div>

<p>This works! However, coming from a Docker background, you may find using short
names more ergonomic, because this is the workflow that you&#39;re used to. This is
absolutely possible with Podman, using either aliases or unqualified search
registries which we&#39;ll explore below.</p>
<h3 id="2-defining-an-alias">2. Defining an alias</h3>
<p>You may decide to define an alias for <code>caddy</code> instead. When doing so, keep in
mind that the <code>/etc/containers/registries.conf.d/shortnames.conf</code> file is not
meant to be modified directly, as it is shipped as part of the
<a rel="" target="_blank" href="https://github.com/containers/shortnames">shortnames project<span><svg style="--currentColor: currentColor;"><use href="https://betterstack.com/assets/icons/heroicons_v2/mini/arrow-top-right-on-square-d4a4b2dfe559997065a0de05c441ef56d661be449bf96d9ce30eb4e0af2516cf.svg#root"></use></svg></span></a>. The correct way
to define a new alias is by adding an <code>[aliases]</code> section to your
<code>registries.conf</code> file like this:</p><div data-controller="clipboard">
  <div>
    <p><span>/etc/containers/registries.conf</span></p>
    
    <p>
  <span>Copied!</span>
</p>

  </div>
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>[aliases]
&#34;caddy&#34;=&#34;docker.io/caddy&#34;
</code></pre>
</div>
</div>

<p>The default registry configuration for Podman is located at
<code>/etc/containers/registries.conf</code>, but modifying this file requires root
privileges. This slightly defeats the idea of rootless access that Podman aims
to support. However, Podman offers a mechanism to overcome this limitation. You
can put your configuration into <code>$HOME/.config/containers/registries.conf</code>, and
it will take precedence over <code>/etc/containers/registries.conf</code>. This requires no
root privileges.</p><p>Go ahead and create the <code>$HOME/.config/containers/registries.conf</code> file on your
system:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>mkdir -p $HOME/.config/containers &amp;&amp; touch $HOME/.config/containers/registries.conf
</code></pre>
</div>
</div>

<p>Then add the following line to your file:</p><div data-controller="clipboard">
  <div>
    <p><span>~/.config/containers/registries.conf</span></p>
    
    <p>
  <span>Copied!</span>
</p>

  </div>
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>[aliases]
&#34;caddy&#34;=&#34;docker.io/caddy&#34;
</code></pre>
</div>
</div>

<p>Now re-run:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>podman run --rm -p 8080:80 caddy
</code></pre>
</div>
</div>

<p>You will see the following output indicating that the solution works:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>Resolved &#34;caddy&#34; as an alias (/home/&lt;your_user_name&gt;/.config/containers/registries.conf)
Trying to pull docker.io/library/caddy:latest...
...
</code></pre>
</div>
</div>

<p>While this solution works, adding aliases for every image that you plan on using
will be tedious and time-consuming in the long run. This leads us to the third
possible solution‚Äîconfiguring an unqualified search registry.</p><p>Before you do that, revert the changes that you did so far so you can start with
a clean state.</p><p>Hit <code>Ctrl+C</code> to terminate the Caddy container and return to your terminal. Then
remove the <code>[aliases]</code> configuration from the <code>registries.conf</code> file by
truncating the entire file:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>echo &gt; $HOME/.config/containers/registries.conf
</code></pre>
</div>
</div>

<p>Remove the <code>caddy</code> image that Podman just downloaded:</p>

<p>As expected, the output shows the tag and ID of the image that was removed:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>Untagged: docker.io/library/caddy:latest
Deleted: 70c3913f54e294079c54cc8b651576b08dd4add42a0f4c0bc93d539913ae335d
</code></pre>
</div>
</div>

<p>You are now ready to define an unqualified search registry.</p>
<h3 id="3-defining-an-unqualified-search-registry">3. Defining an unqualified search registry</h3>
<p>Open your <code>$HOME/.config/containers/registries.conf</code> file and paste the
following contents:</p><div data-controller="clipboard">
  <div>
    <p><span>~/.config/containers/registries.conf</span></p>
    
    <p>
  <span>Copied!</span>
</p>

  </div>
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>unqualified-search-registries=[&#34;docker.io&#34;]
</code></pre>
</div>
</div>

<p>Now re-run:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>podman run --rm -p 8080:80 caddy
</code></pre>
</div>
</div>

<p>You will see the following output:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>Resolving &#34;caddy&#34; using unqualified-search registries (/home/&lt;your_user_name&gt;/.config/containers/registries.conf)
Trying to pull docker.io/library/caddy:latest
...
</code></pre>
</div>
</div>

<p>The <code>caddy</code> image was successfully downloaded, a container was launched, and
Caddy is now ready to serve web requests.</p><p>To confirm that everything works, you can navigate to <code>localhost:8080</code>. There,
you should see the Caddy test page:</p>
<p>Using an unqualified search registry is unquestionably a better option than
using aliases, especially if you intend to use Podman as a drop-in replacement
for Docker, because you can continue using short names the way that you are used
to, and they will resolve from Docker Hub by default.</p><p>Before you continue further, go back to your terminal and hit <code>Ctrl+C</code> to stop
the container, then remove the Caddy image:</p>

<div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>Untagged: docker.io/library/caddy:latest
Deleted: 70c3913f54e294079c54cc8b651576b08dd4add42a0f4c0bc93d539913ae335d
</code></pre>
</div>
</div>


<h2 id="using-private-image-registries">Using private image registries</h2>
<p>You are likely used to working with private registries that host your
organization&#39;s proprietary images. Docker can undoubtedly facilitate that, and
so can Podman. The process is very similar for both tools.</p><p>This example assumes that you have a working Docker Hub account. If you don&#39;t
have an account, you can <a rel="" target="_blank" href="https://hub.docker.com/signup">register one for free<span><svg style="--currentColor: currentColor;"><use href="https://betterstack.com/assets/icons/heroicons_v2/mini/arrow-top-right-on-square-d4a4b2dfe559997065a0de05c441ef56d661be449bf96d9ce30eb4e0af2516cf.svg#root"></use></svg></span></a>.
The free tier allows you to maintain one private repository free of charge.</p><p>Log into your Docker Hub account and navigate to
<a rel="" target="_blank" href="https://hub.docker.com/settings/general">Account Settings<span><svg style="--currentColor: currentColor;"><use href="https://betterstack.com/assets/icons/heroicons_v2/mini/arrow-top-right-on-square-d4a4b2dfe559997065a0de05c441ef56d661be449bf96d9ce30eb4e0af2516cf.svg#root"></use></svg></span></a>:</p>
<p>Go to <a rel="" target="_blank" href="https://hub.docker.com/settings/security">Security<span><svg style="--currentColor: currentColor;"><use href="https://betterstack.com/assets/icons/heroicons_v2/mini/arrow-top-right-on-square-d4a4b2dfe559997065a0de05c441ef56d661be449bf96d9ce30eb4e0af2516cf.svg#root"></use></svg></span></a> and click on <strong>New
Access Token</strong>:</p>
<p>Specify <strong>Podman tutorial</strong> as the description and <strong>Read &amp; Write</strong> as the
desired permissions, then click <strong>Generate</strong>:</p>
<p>Copy the generated access token and store it somewhere safe. We will refer to
this token as <code>&lt;your_access_token&gt;</code>:</p>
<p>The token should now be listed under the available access tokens in your Docker
Hub account:</p>
<p>Navigate back to <a rel="" target="_blank" href="https://hub.docker.com/repositories">Repositories<span><svg style="--currentColor: currentColor;"><use href="https://betterstack.com/assets/icons/heroicons_v2/mini/arrow-top-right-on-square-d4a4b2dfe559997065a0de05c441ef56d661be449bf96d9ce30eb4e0af2516cf.svg#root"></use></svg></span></a> and create
a new private repository as follows:</p>
<p>If all goes well, you should see the repository listed in your Docker Hub
account:</p>
<p>Let&#39;s now configure Podman to run with your private repository.</p><p>Type the following command:</p>

<p>Here, <code>docker.io</code> can be omitted if you have listed it as the first
<code>unqualified-search-registries</code> entry in your <code>registries.conf</code> file.
Nevertheless, it&#39;s still considered a good practice to specify the registry
explicitly.</p><p>Otherwise, <code>podman login</code> will fail with the following error:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>Error: no registries found in registries.conf, a registry must be provided
</code></pre>
</div>
</div>

<p>Type in your username and access token when prompted, and you should receive the
following output:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>Username: &lt;your_user_name&gt;
Password: &lt;your_access_token&gt;
Login Succeeded!
</code></pre>
</div>
</div>

<p>Continue by downloading the official <code>hello-world</code> image locally:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>podman pull docker.io/hello-world
</code></pre>
</div>
</div>

<p>A successful output will look like this:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>Trying to pull docker.io/library/hello-world:latest...
Getting image source signatures
Copying blob 719385e32844 done
Copying config 9c7a54a9a4 done
Writing manifest to image destination
Storing signatures
9c7a54a9a43cca047013b82af109fe963fde787f63f9e016fdc3384500c2823d
</code></pre>
</div>
</div>

<p>Now list your local Podman images:</p>

<p>You should see the following output:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>REPOSITORY                     TAG         IMAGE ID      CREATED       SIZE
docker.io/library/hello-world  latest      9c7a54a9a43c  6 months ago  19.9 kB
</code></pre>
</div>
</div>

<p>Go ahead and upload a copy of the <code>hello-world</code> image to your private
repository.</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>podman push docker.io/library/hello-world docker.io/&lt;your_user_name&gt;/hello-private
</code></pre>
</div>
</div>

<p>You will get the following output:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>Getting image source signatures
Copying blob 01bb4fce3eb1 skipped: already exists
Copying config 9c7a54a9a4 done
Writing manifest to image destination
Storing signatures
</code></pre>
</div>
</div>

<p>Navigate back to your private repository on Docker Hub to verify that the image
was successfully uploaded:</p>
<p>You can now remove the public <code>hello-world</code> image from your local machine:</p>

<div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>Untagged: docker.io/library/hello-world:latest
Deleted: 9c7a54a9a43cca047013b82af109fe963fde787f63f9e016fdc3384500c2823d
</code></pre>
</div>
</div>

<p>Now, try running a container using the image from your private repository:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>podman run --rm docker.io/&lt;your_user_name&gt;/hello-private
</code></pre>
</div>
</div>

<p>Podman goes ahead, successfully pulls the private image, and launches a
container using the image:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>Trying to pull docker.io/&lt;your_user_name&gt;/hello-private:latest...
Getting image source signatures
Copying blob 719385e32844 done
Copying config 9c7a54a9a4 done
Writing manifest to image destination
Storing signatures

Hello from Docker!
...
</code></pre>
</div>
</div>

<p>Without valid login credentials, you would have received the following error
instead:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>Trying to pull docker.io/&lt;your_user_name&gt;/hello-private:latest...
Error: initializing source docker://&lt;your_user_name&gt;/hello-private:latest: reading manifest latest in docker.io/&lt;your_user_name&gt;/hello-private: errors:
denied: requested access to the resource is denied
unauthorized: authentication required
</code></pre>
</div>
</div>

<p>As you can see, using Podman with a private registry is almost identical to
using Docker for the same purpose. The only difference is that you prefixed your
commands with <code>podman</code> instead of <code>docker</code>. Just like Docker, you can use Podman
with all popular private registries.</p><p>Before you continue further, make sure to logout:</p>

<div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>Removed login credentials for docker.io
</code></pre>
</div>
</div>

<p>Also, remove the private image from your local machine:</p>

<div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>Untagged: docker.io/&lt;your_user_name&gt;/hello-private:latest
Deleted: 9c7a54a9a43cca047013b82af109fe963fde787f63f9e016fdc3384500c2823d
</code></pre>
</div>
</div>

<p>With this, you can proceed to the next section and learn how to orchestrate
multiple containers with Podman.</p>
<h2 id="orchestrating-multiple-containers">Orchestrating multiple containers</h2>
<p>So far, you have only been launching one container at a time to explore how
Podman works. At some point, you&#39;ll surely find it necessary to run multiple
containers working together as a unit. In this section, you&#39;ll explore one of
the possible ways to do that with
<a rel="" target="_blank" href="https://github.com/containers/podman-compose">Podman Compose<span><svg style="--currentColor: currentColor;"><use href="https://betterstack.com/assets/icons/heroicons_v2/mini/arrow-top-right-on-square-d4a4b2dfe559997065a0de05c441ef56d661be449bf96d9ce30eb4e0af2516cf.svg#root"></use></svg></span></a>.</p><p>Podman offers several options for orchestrating multiple containers, but Podman
Compose is the most similar to what&#39;s used in the Docker world. Other options
are pods and Kubernetes manifests, but both call for a deeper comprehension of
Podman (and Kubernetes), so we&#39;ll leave them out for now.</p><p>In the following example, you&#39;ll use the Docker Compose instructions supplied
with the <a rel="" target="_blank" href="https://hub.docker.com/_/wordpress">official WordPress image<span><svg style="--currentColor: currentColor;"><use href="https://betterstack.com/assets/icons/heroicons_v2/mini/arrow-top-right-on-square-d4a4b2dfe559997065a0de05c441ef56d661be449bf96d9ce30eb4e0af2516cf.svg#root"></use></svg></span></a> on
Docker Hub to launch a simple
<a rel="" target="_blank" href="https://github.com/WordPress/WordPress">WordPress<span><svg style="--currentColor: currentColor;"><use href="https://betterstack.com/assets/icons/heroicons_v2/mini/arrow-top-right-on-square-d4a4b2dfe559997065a0de05c441ef56d661be449bf96d9ce30eb4e0af2516cf.svg#root"></use></svg></span></a> installation backed by a
MySQL database server. If you&#39;re unfamiliar with WordPress, it is a popular
blogging and content management platform written in PHP.</p><p>In the Docker ecosystem, Compose allows you to define and manage multiple
containers through definitions stored inside a <code>docker-compose.yml</code> file. Being
used to working with Docker Compose, you can continue using your existing
<code>docker-compose.yml</code> files with Podman with the help of Podman Compose.</p><p>Podman Compose is a community-driven tool that implements the
<a rel="" target="_blank" href="https://compose-spec.io/">Compose specification<span><svg style="--currentColor: currentColor;"><use href="https://betterstack.com/assets/icons/heroicons_v2/mini/arrow-top-right-on-square-d4a4b2dfe559997065a0de05c441ef56d661be449bf96d9ce30eb4e0af2516cf.svg#root"></use></svg></span></a> and seamlessly integrates with
Podman. It relies on Python 3 to work, and one of the easiest ways to get
started with it is through <a rel="" target="_blank" href="https://pypa.github.io/pipx/">pipx<span><svg style="--currentColor: currentColor;"><use href="https://betterstack.com/assets/icons/heroicons_v2/mini/arrow-top-right-on-square-d4a4b2dfe559997065a0de05c441ef56d661be449bf96d9ce30eb4e0af2516cf.svg#root"></use></svg></span></a>.</p><p>If you don&#39;t already have Python 3 or <code>pipx</code> installed on your system, you can
install them by running:</p>

<p>You can verify that <code>pipx</code> is working by typing:</p>

<p>This will output a version identifier similar to:</p>

<p>The output confirms that version <code>1.2.0</code> is of <code>pipx</code> is installed on your
system, and you&#39;re ready to start using it.</p><p>You can run the following command to install Podman Compose:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>pipx install podman-compose
</code></pre>
</div>
</div>

<p>If everything goes well, you should see:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>installed package podman-compose 1.0.6, installed using Python 3.11.6
These apps are now globally available
  - podman-compose
‚ö†Ô∏è Note: &#39;/home/&lt;your_user_name&gt;/.local/bin&#39; is not on your PATH environment variable. These apps will not be globally accessible until your PATH is updated. Run `pipx ensurepath` to automatically add it, or manually modify your PATH in your shell&#39;s config file (i.e. ~/.bashrc).
done! ‚ú® üåü ‚ú®
</code></pre>
</div>
</div>

<p>The output indicates that <code>pipx</code> was placed in your <code>$HOME/.local/bin</code> folder.
However, that folder is likely not included in your <code>$PATH</code> variable, meaning if
you type <code>podman-compose</code> right now, you will get a similar error:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>Command &#39;podman-compose&#39; not found, but can be installed with:
sudo apt install podman-compose
</code></pre>
</div>
</div>

<p>Don&#39;t be confused by this error. Podman Compose was successfully installed, but
you need to add its installation folder to your <code>$PATH</code>.</p><p>You can address this by running:</p>

<p>This command will ensure that <code>$HOME/.local/bin</code> is appended to your <code>$PATH</code>
through one of your shell&#39;s config files (<code>.profile</code>, <code>.bash_profile</code>,
<code>.bashrc</code>, etc. depending on your specific setup).</p><p>After running the command, you will see the following output:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>/home/&lt;your_user_name&gt;/.local/bin has been added to PATH, but you need to open a new terminal or re-login for this PATH change to take effect.

You will need to open a new terminal or re-login for the PATH changes to take effect.

Otherwise pipx is ready to go! ‚ú® üåü ‚ú®
</code></pre>
</div>
</div>

<p>You can follow the instructions and re-open your terminal session.
Alternatively, if you know precisely which shell config file was modified, you
can source the file for the changes to take immediate effect.</p><p>For example:</p>

<p>To confirm that the <code>$PATH</code> is set correctly, you can run:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>echo $PATH | tr &#39;:&#39; &#39;\n&#39; | grep -F .local
</code></pre>
</div>
</div>

<p>You should see <code>/home/&lt;your_user_name&gt;/.local/bin</code> listed in the output:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>/home/&lt;your_user_name&gt;/.local/bin
</code></pre>
</div>
</div>

<p>Create a new folder and <code>cd</code> into it:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>mkdir podman-tutorial &amp;&amp; cd podman-tutorial
</code></pre>
</div>
</div>

<p>Create an <code>.env</code> file and define the following variables:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>DB_USER=&lt;your_example_username&gt;
DB_PASS=&lt;your_example_password&gt;
DB_NAME=&lt;your_example_database&gt;
</code></pre>
</div>
</div>

<p>Then, create a new <code>docker-compose.yml</code> file and paste the following contents:</p><div data-controller="clipboard">
  <div>
    <p><span>docker-compose.yml</span></p>
    
    <p>
  <span>Copied!</span>
</p>

  </div>
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>version: &#39;3&#39;

services:

  wordpress:
    image: wordpress
    container_name: wordpress
    restart: always
    ports:
      - &#39;8080:80&#39;
    environment:
      WORDPRESS_DB_HOST: db
      WORDPRESS_DB_USER: ${DB_USER}
      WORDPRESS_DB_PASSWORD: ${DB_PASS}
      WORDPRESS_DB_NAME: ${DB_NAME}
    volumes:
      - wordpress:/var/www/html

  db:
    image: mysql:5.7
    container_name: db
    restart: always
    ports:
      - &#39;3306:3306&#39;
    environment:
      MYSQL_DATABASE: ${DB_NAME}
      MYSQL_USER: ${DB_USER}
      MYSQL_PASSWORD: ${DB_PASS}
      MYSQL_RANDOM_ROOT_PASSWORD: &#39;1&#39;
    volumes:
      - db:/var/lib/mysql

volumes:
  wordpress:
  db:
</code></pre>
</div>
</div>

<p>Save the file, then run:</p>

<p>Let&#39;s examine the output segment by segment.</p><p>Initially, <code>podman-compose</code> launches and starts analyzing the
<code>docker-compose.yml</code> file:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>podman-compose version: 1.0.6
[&#39;podman&#39;, &#39;--version&#39;, &#39;&#39;]
using podman version: 4.3.1
** excluding:  set()
[&#39;podman&#39;, &#39;ps&#39;, &#39;--filter&#39;, &#39;label=io.podman.compose.project=podman-tutorial&#39;, &#39;-a&#39;, &#39;--format&#39;, &#39;{{ index .Labels &#34;io.podman.compose.config-hash&#34;}}&#39;]
</code></pre>
</div>
</div>

<p>It detects two services named <code>wordpress</code> and <code>db</code>, and starts processing them
in sequential order.</p><p>First, it finds out that the <code>wordpress</code> service requires an external volume. It
tries to locate the volume by issuing <code>podman volume inspect &lt;volume_name&gt;</code>, but
since it doesn&#39;t exist, it goes ahead and creates one by issuing
<code>podman volume create &lt;volume_name&gt;</code>:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>podman volume inspect podman-tutorial_wordpress || podman volume create podman-tutorial_wordpress
[&#39;podman&#39;, &#39;volume&#39;, &#39;inspect&#39;, &#39;podman-tutorial_wordpress&#39;]
Error: inspecting object: no such volume podman-tutorial_wordpress
[&#39;podman&#39;, &#39;volume&#39;, &#39;create&#39;, &#39;--label&#39;, &#39;io.podman.compose.project=podman-tutorial&#39;, &#39;--label&#39;, &#39;com.docker.compose.project=podman-tutorial&#39;, &#39;podman-tutorial_wordpress&#39;]
[&#39;podman&#39;, &#39;volume&#39;, &#39;inspect&#39;, &#39;podman-tutorial_wordpress&#39;]
</code></pre>
</div>
</div>

<p>Next, it checks whether there is a suitable network for deploying the
<code>wordpress</code> service. It doesn&#39;t find one, so it creates it and then performs
another check to confirm that the network exists:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>[&#39;podman&#39;, &#39;network&#39;, &#39;exists&#39;, &#39;podman-tutorial_default&#39;]
[&#39;podman&#39;, &#39;network&#39;, &#39;create&#39;, &#39;--label&#39;, &#39;io.podman.compose.project=podman-tutorial&#39;, &#39;--label&#39;, &#39;com.docker.compose.project=podman-tutorial&#39;, &#39;podman-tutorial_default&#39;]
[&#39;podman&#39;, &#39;network&#39;, &#39;exists&#39;, &#39;podman-tutorial_default&#39;]
</code></pre>
</div>
</div>

<p>Finally, with a suitable network and an external volume in place, Podman Compose
launches the <code>wordpress</code> container:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>podman run --name=wordpress -d --label io.podman.compose.config-hash=c3e51c9a26e54848a06f92083413698bee90acd721b4aa3054280e110819a68c --label io.podman.compose.project=podman-tutorial --label io.podman.compose.version=1.0.6 --label PODMAN_SYSTEMD_UNIT=podman-compose@podman-tutorial.service --label com.docker.compose.project=podman-tutorial --label com.docker.compose.project.working_dir=/home/&lt;your_user_name&gt;/podman-tutorial --label com.docker.compose.project.config_files=docker-compose.yml --label com.docker.compose.container-number=1 --label com.docker.compose.service=wordpress -e WORDPRESS_DB_HOST=db -e WORDPRESS_DB_USER=testuser -e WORDPRESS_DB_PASSWORD=testpass -e WORDPRESS_DB_NAME=testdb -v podman-tutorial_wordpress:/var/www/html --net podman-tutorial_default --network-alias wordpress -p 8080:80 --restart always wordpress
</code></pre>
</div>
</div>

<p>Since Podman cannot find a <code>wordpress</code> image available locally, it goes ahead
and looks up the unqualified search registry that you configured earlier
(<code>docker.io</code>), then downloads it:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>Resolving &#34;wordpress&#34; using unqualified-search registries (/home/&lt;your_user_name&gt;/.config/containers/registries.conf)
Trying to pull docker.io/library/wordpress:latest...
Getting image source signatures
Copying blob c5d33b602102 done
...
Copying config bc823df9ea done
Writing manifest to image destination
Storing signatures
980f5792fb9c34ea9357ffa290d5d79ac0b48b70701cd4693f5d7e2b4f2312f1
exit code: 0
</code></pre>
</div>
</div>

<p>Next, Podman Compose proceeds with processing the instructions for the <code>db</code>
service.</p><p>First, it creates its external volume:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>podman volume inspect podman-tutorial_db || podman volume create podman-tutorial_db
[&#39;podman&#39;, &#39;volume&#39;, &#39;inspect&#39;, &#39;podman-tutorial_db&#39;]
Error: inspecting object: no such volume podman-tutorial_db
[&#39;podman&#39;, &#39;volume&#39;, &#39;create&#39;, &#39;--label&#39;, &#39;io.podman.compose.project=podman-tutorial&#39;, &#39;--label&#39;, &#39;com.docker.compose.project=podman-tutorial&#39;, &#39;podman-tutorial_db&#39;]
[&#39;podman&#39;, &#39;volume&#39;, &#39;inspect&#39;, &#39;podman-tutorial_db&#39;]
</code></pre>
</div>
</div>

<p>It then ensures that there is a suitable network for its deployment:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>[&#39;podman&#39;, &#39;network&#39;, &#39;exists&#39;, &#39;podman-tutorial_default&#39;]
</code></pre>
</div>
</div>

<p>Finally, it launches the <code>db</code> container:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>podman run --name=db -d --label io.podman.compose.config-hash=c3e51c9a26e54848a06f92083413698bee90acd721b4aa3054280e110819a68c --label io.podman.compose.project=podman-tutorial --label io.podman.compose.version=1.0.6 --label PODMAN_SYSTEMD_UNIT=podman-compose@podman-tutorial.service --label com.docker.compose.project=podman-tutorial --label com.docker.compose.project.working_dir=/home/&lt;your_user_name&gt;/podman-tutorial --label com.docker.compose.project.config_files=docker-compose.yml --label com.docker.compose.container-number=1 --label com.docker.compose.service=db -e MYSQL_DATABASE=testdb -e MYSQL_USER=testuser -e MYSQL_PASSWORD=testpass -e MYSQL_RANDOM_ROOT_PASSWORD=1 -v podman-tutorial_db:/var/lib/mysql --net podman-tutorial_default --network-alias db --restart always mysql:5.7
</code></pre>
</div>
</div>

<p>Just like with the <code>wordpress</code> image, Podman cannot find a <code>mysql:5.7</code> image
locally, so it goes ahead and obtains it from Docker Hub:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>Resolving &#34;mysql&#34; using unqualified-search registries (/home/&lt;your_user_name&gt;/.config/containers/registries.conf)
Trying to pull docker.io/library/mysql:5.7...
Getting image source signatures
Copying blob 62aca7179a54 done
...
Copying config bdba757bc9 done
Writing manifest to image destination
Storing signatures
21615c3d36236f181b94831b5c1eb699153f7cf912fdefcb342732069f99c09d
exit code: 0
</code></pre>
</div>
</div>

<p>At this point, Podman Compose exits successfully, and everything appears to be
launched correctly. Let&#39;s go ahead and verify this.</p><p>First, try to open <code>localhost:8080</code> in a browser. You should see the WordPress
installation page:</p>
<p>Now, go back to your terminal and type in:</p>

<p>Indeed, both the <code>wordpress</code> container and the <code>db</code> container are up and
running:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>CONTAINER ID  IMAGE                               COMMAND               CREATED        STATUS            PORTS                 NAMES
980f5792fb9c  docker.io/library/wordpress:latest  apache2-foregroun...  3 minutes ago  Up 3 minutes ago  0.0.0.0:8080-&gt;80/tcp  wordpress
21615c3d3623  docker.io/library/mysql:5.7         mysqld                2 minutes ago  Up 2 minutes ago                        db
</code></pre>
</div>
</div>

<p>You can also go ahead and explore the list of available images:</p>

<p>The list contains all the necessary images for running MySQL and WordPress:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>REPOSITORY                   TAG         IMAGE ID      CREATED       SIZE
docker.io/library/wordpress  latest      bc823df9ead2  28 hours ago  683 MB
docker.io/library/mysql      5.7         bdba757bc933  4 weeks ago   520 MB
</code></pre>
</div>
</div>

<p>You can further explore the list of available networks:</p>

<p>Two networks show up:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>NETWORK ID    NAME                     DRIVER
2f259bab93aa  podman                   bridge
3f5fa386b31c  podman-tutorial_default  bridge
</code></pre>
</div>
</div>

<p>The <code>podman</code> network is created by default when you install Podman for the first
time. It is used for launching containers when no other network is explicitly
specified. On the other hand, the <code>podman-tutorial_default</code> network is created
by Podman Compose to isolate the containers defined in your <code>docker-compose.yml</code>
from any other containers potentially running on the same system.</p><p>Finally, let&#39;s check the available volumes:</p>

<p>As expected, two external volumes appear:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>DRIVER      VOLUME NAME
local       podman-tutorial_db
local       podman-tutorial_wordpress
</code></pre>
</div>
</div>

<p>You can go ahead and stop the containers:</p>

<p>Podman Compose stops and removes the containers from your system but keeps the
network and volumes:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>podman-compose version: 1.0.6
[&#39;podman&#39;, &#39;--version&#39;, &#39;&#39;]
using podman version: 4.3.1
** excluding:  set()
podman stop -t 10 db
db
exit code: 0
podman stop -t 10 wordpress
wordpress
exit code: 0
podman rm db
db
exit code: 0
podman rm wordpress
wordpress
exit code: 0
</code></pre>
</div>
</div>

<p>You can verify that no containers are running by typing:</p>

<p>The result shows an empty output, which confirms that all of the containers were
stopped and removed.</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>CONTAINER ID  IMAGE       COMMAND     CREATED     STATUS      PORTS       NAMES
</code></pre>
</div>
</div>

<p>If you want to remove the volumes as well, you can type in:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>podman volume rm podman-tutorial_db podman-tutorial_wordpress
</code></pre>
</div>
</div>

<p>To remove the network, type in:</p><div data-controller="clipboard">
  
  <div data-clipboard-target="content" data-controller="code">
  <pre><code>podman network rm podman-tutorial_default
</code></pre>
</div>
</div>

<p>As you can see, the commands are identical to what you would normally use with
Docker and Docker Compose. The only noticeable difference is that instead of
<code>docker</code> and <code>docker-compose</code>, you type in <code>podman</code> and <code>podman-compose</code>.</p>
<h2 id="final-thoughts">Final thoughts</h2>
<p>Podman is a capable containerization technology that offers a viable alternative
to Docker for running container workloads. Whether you choose Podman or Docker
depends entirely on your specific needs and preferences. </p><p>Podman can do most of the things that Docker can do, with the added benefit of 
not requiring a daemon running in the background. On top of that, Podman offers 
some features that Docker does not, such as working with Kubernetes manifest 
files and organizing individual containers into pods.</p><p>The final decision is yours. If you require a more lightweight and secure
container management solution, Podman might be a better choice. However, Docker
may be the way to go if you prioritize a robust ecosystem with extensive
community support. Ultimately, both tools offer powerful containerization
capabilities to meet your requirements.</p><p>To explore Podman further, consider visiting the
<a rel="" target="_blank" href="https://podman.io/">official Podman website<span><svg style="--currentColor: currentColor;"><use href="https://betterstack.com/assets/icons/heroicons_v2/mini/arrow-top-right-on-square-d4a4b2dfe559997065a0de05c441ef56d661be449bf96d9ce30eb4e0af2516cf.svg#root"></use></svg></span></a>, exploring its
<a rel="" target="_blank" href="https://podman.io/docs">documentation<span><svg style="--currentColor: currentColor;"><use href="https://betterstack.com/assets/icons/heroicons_v2/mini/arrow-top-right-on-square-d4a4b2dfe559997065a0de05c441ef56d661be449bf96d9ce30eb4e0af2516cf.svg#root"></use></svg></span></a>, and joining its growing
<a rel="" target="_blank" href="https://podman.io/community">community<span><svg style="--currentColor: currentColor;"><use href="https://betterstack.com/assets/icons/heroicons_v2/mini/arrow-top-right-on-square-d4a4b2dfe559997065a0de05c441ef56d661be449bf96d9ce30eb4e0af2516cf.svg#root"></use></svg></span></a>.</p><p>Thanks for reading!</p>
<div>
<div>
<div>
<p><img width="64" height="64" alt="Author&#39;s avatar" data-src="/assets/articles/authors/marin-0d19fe482115fe2b15c8429a7ee4eb88d803984eaa7c1d8c7309241049f3d402.png" src=""/></p>
<div>
<p>Article by</p>
<p>Marin Bezhanov</p>
</div>

</div>
<p>Marin is a software engineer and architect with a broad range of experience working with Go, Java, PHP, and JS. He is passionate about exploring new technologies and staying up-to-date with the latest industry trends, and he loves sharing his knowledge through technical writing and teaching.</p>
</div>

<div>
<div><p>
Got an article suggestion?
<a href="mailto:hello@betterstack.com?subject=Suggestion%20for%20Exploring%20Podman%3A%20A%20More%20Secure%20Docker%20Alternative&amp;body=">Let us know</a>
</p></div>

</div>

<div>
<p><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="nofollow noopener" target="_blank">
<img alt="Licensed under CC-BY-NC-SA" width="89" height="31" data-src="/assets/articles/cc-by-nc-sa-1fa5a2f7978211f24b8230a7e79097dd1f8a36be35e813693c49348cf1689f42.png" src=""/>
</a></p><p>This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.</p>
</div>
</div>

</div></div>
  </body>
</html>
