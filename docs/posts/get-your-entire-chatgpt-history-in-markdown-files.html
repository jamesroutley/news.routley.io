<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/mohamed-chs/chatgpt-history-export-to-md">Original</a>
    <h1>Show HN: Get your entire ChatGPT history, in Markdown files</h1>
    
    <div id="readability-page-1" class="page"><div>
    <div>
	

<p> Originally posted 2023-09-23</p>
<p> Tagged: <a href="https://www.moderndescartes.com/essays/tags/software_engineering">software_engineering</a></p>
<p> <em>Obligatory disclaimer: all opinions are mine and not of my employer </em></p>
<hr/>

<p>The archetypal unit test looks like this:</p>
<pre><code>arg1 = ...
arg2 = ...
expected_output = ...
actual_output = function_to_test(arg1, arg2)
assertEqual(expected_output, actual_output)</code></pre>
<p>A very common problem is that, over time, objects accumulate fields
and subobjects, until it takes significant effort just to construct an
object. Constructing <code>arg1</code>, <code>arg2</code>, and
<code>expected_output</code> can take hundreds of lines, while the
function call and the assertion are just two lines. These tests are like
cotton candy: a tremendous amount of fluff with a tiny core. Well, at
least cotton candy is tasty. This fluff is tedious to write, tedious to
review, and tedious to scroll through, which leads to less unit testing
than is optimal. It’s like chatting with that overly friendly downstairs
neighbor who takes thirty minutes to tell you that the condo insurance
is up for renewal.</p>
<p>The most common coping mechanism for fluffy constructors is the
singleton: one example object that feeds into every test. Often, this
singleton ends up in the setUp() method shared by all tests. The many
fields of the shared singleton are pinned by various different unit
tests’ assertions, and gradually it becomes impossible to either
customize the object, or to add new unit tests. When the test class
reaches this point, the process starts all over with a new freshly made
singleton object and a new test class. This seems a little bit silly.
But how can we do better?</p>
<h2 id="factory-methods-hide-fluff">Factory methods hide fluff</h2>
<p>The first step towards simplifying fluffy tests is to decide which
details are relevant.</p>
<p>Take this test:</p>
<pre><code>car1 = Vehicle(
    mass_kg=2000,
    location=Location(x_m=0, y_m=0),
    velocity=Velocity(x_m_s=4, y_m_s=3),
    heading=math.atan2(3, 4),
    width_m=1.8,
    length_m=4.0,
    emergency_vehicle=False,
    )
car2 = Vehicle(
    mass_kg=2000,
    location=Location(x_m=4, y_m=-2),
    velocity=Velocity(x_m_s=0, y_m_s=5),
    heading=math.atan2(5, 0),
    width_m=1.8,
    length_m=4.0,
    emergency_vehicle=False,
    )
self.assert(car1.speed_m_s) = 5
self.assert(car2.speed_m_s) = 5
self.assertTrue(willColideWithin5sec(car1, car2))</code></pre>
<p>Many of these fields are irrelevant, so we may as well hide them
behind a factory method.</p>
<pre><code>car1 = make_suv(
    location=Location(x_m=0, y_m=0),
    velocity=Velocity(x_m_s=4, y_m_s=3),
    )
car2 = make_suv(
    location=Location(x_m=4, y_m=-2),
    velocity=Velocity(x_m_s=0, y_m_s=5),
    )
self.assert(car1.speed_m_s) = 5
self.assert(car2.speed_m_s) = 5
self.assertTrue(willColideWithin5sec(car1, car2))</code></pre>
<p>You might object that factory methods just hide the fluff. It’s true
that if you only have one unit test, this new solution is the same
number of lines of code. But as the marginal cost of testing drops,
you’ll get more tests. It’s also easier to manually verify that the unit
test is correct.</p>
<h2 id="dsls-hide-syntactic-fluff">DSLs hide syntactic fluff</h2>
<p>In certain cases, the fluff is due to language syntax itself! You
might think it isn’t possible to eliminate this type of fluff, but
writing your own DSL is a powerful technique to do just that.</p>
<p>Which would you rather see?</p>
<pre><code>go_board = np.array([
    [go.KO,1,1,0,0,0,0,0,0],
    [1,-1,0,0,0,0,0,0,0],
    [-1,0,-1,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0]
    [0,0,0,0,0,0,0,0,0]
    [0,0,0,0,0,0,0,0,0]
    [0,0,0,0,0,0,0,0,0]
    [0,0,0,0,0,0,0,0,0]
    [0,0,0,0,0,0,0,0,0]
    [0,0,0,0,0,0,0,0,0]
])</code></pre>
<p>or</p>
<pre><code>go_board = parse_board(&#39;&#39;&#39;
    *XX......
    XO.......
    O.O......
    .........
    .........
    .........
    .........
    .........
    .........
&#39;&#39;&#39;)</code></pre>
<p>The latter contains far less visual noise, with half the total
characters. It features a sensible null character, flexible whitespace
for convenient embedding of inline data, and monospaced content.
Definitely easier to read and write.</p>
<p>In many cases, you can reuse existing DSLs instead of having to
create your own. This lets you even skip writing the parser - you can
use a library for that. Instead of manually constructing a Pandas
dataframe, why not just embed and parse a .csv? Instead of manually
constructing a giant config object, why not parse YAML? Instead of
manually constructing nodes and an adjacency graph, why not parse <a href="https://en.wikipedia.org/wiki/DOT_(graph_description_language)">DOT</a>?
Possibly the most obscure DSL I’ve ever written is for <a href="https://github.com/open-reaction-database/ord-schema/blob/9c9e852d5e1b5680d6545eafeca1ccf47d87b641/ord_schema/macros/workups.py">organic
chemistry reaction workups</a>!</p>
<h2 id="conclusion">Conclusion</h2>
<p>To defluff is to be human. We describe weather as sunny, cloudy, or
rainy without having to specify temperature, humidity, cloud cover, or
wind conditions. If a concept has been around for more than a decade,
chances are, a very compact DSL already exists for it, and you won’t
have to invent a new one.</p>
<p>Fluffy unit tests are annoying to read and write, but more than that,
they discourage writing more unit tests. By investing in methods to
defluff object constructors, it becomes a lot easier to write
comprehensive unit test suites, and the unit tests become far easier to
manually verify. As a bonus, factory methods and DSLs often end up quite
useful outside of writing test cases, too - they make it easier to write
tutorial notebooks or to construct ad-hoc objects during a debugging
session.</p>


    </div>
</div></div>
  </body>
</html>
