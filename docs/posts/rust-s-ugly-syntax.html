<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://matklad.github.io/2023/01/26/rusts-ugly-syntax.html">Original</a>
    <h1>Rust&#39;s Ugly Syntax</h1>
    
    <div id="readability-page-1" class="page"><div>
  <article>

    
<p>People complain about Rust syntax.
I think that most of the time when people think they have an issue with Rust’s syntax, they actually object to Rust’s semantics.
In this slightly whimsical post, I’ll try to disentangle the two.</p>
<p>Let’s start with an example of an ugly Rust syntax:</p>

<figure>


<pre><code><span>pub</span> <span>fn</span> <span>read</span>&lt;P: <span>AsRef</span>&lt;Path&gt;&gt;(path: P) <span>-&gt;</span> io::<span>Result</span>&lt;<span>Vec</span>&lt;<span>u8</span>&gt;&gt; {</code>
<code>  <span>fn</span> <span>inner</span>(path: &amp;Path) <span>-&gt;</span> io::<span>Result</span>&lt;<span>Vec</span>&lt;<span>u8</span>&gt;&gt; {</code>
<code>    <span>let</span> <span>mut </span><span>file</span> = File::<span>open</span>(path)?;</code>
<code>    <span>let</span> <span>mut </span><span>bytes</span> = <span>Vec</span>::<span>new</span>();</code>
<code>    file.<span>read_to_end</span>(&amp;<span>mut</span> bytes)?;</code>
<code>    <span>Ok</span>(bytes)</code>
<code>  }</code>
<code>  <span>inner</span>(path.<span>as_ref</span>())</code>
<code>}</code></pre>

</figure>
<p>This function reads contents of a given binary file.
This is lifted straight from the standard library, so it is very much not a strawman example.
And, at least to me, it’s definitely not a pretty one!</p>
<p>Let’s try to imagine what this same function would look like if Rust had a better syntax.
Any resemblance to real programming languages, living or dead, is purely coincidental!</p>
<p>Let’s start with Rs++:</p>

<figure>


<pre><code><span>template</span>&lt;std::HasConstReference&lt;std::Path&gt; P&gt;</code>
<code>std::io::outcome&lt;std::vector&lt;<span>uint8_t</span>&gt;&gt;</code>
<code>std::<span>read</span>(P path) {</code>
<code>    <span>return</span> <span>read_</span>(path.<span>as_reference</span>());</code>
<code>}</code>
<code></code>
<code><span>static</span></code>
<code>std::io::outcome&lt;std::vector&lt;<span>uint8_t</span>&gt;&gt;</code>
<code><span>read_</span>(&amp;<span>auto</span> <span>const</span> std::Path path) {</code>
<code>    <span>auto</span> file = <span>try</span> std::File::<span>open</span>(path);</code>
<code>    std::vector bytes;</code>
<code>    <span>try</span> file.<span>read_to_end</span>(&amp;bytes);</code>
<code>    <span>return</span> <span>okey</span>(bytes);</code>
<code>}</code></pre>

</figure>
<p>A Rhodes variant:</p>

<figure>


<pre><code><span>public</span> io.Result&lt;ArrayList&lt;Byte&gt;&gt; read&lt;P <span>extends</span> <span>ReferencingFinal</span>&lt;Path&gt;&gt;(</code>
<code>        P path) {</code>
<code>    <span>return</span> myRead(path.get_final_reference());</code>
<code>}</code>
<code></code>
<code><span>private</span> io.Result&lt;ArrayList&lt;Byte&gt;&gt; <span>myRead</span><span>(</span></code>
<code><span>        <span>final</span> reference lifetime <span>var</span> Path path)</span> {</code>
<code>    <span>var</span> <span>file</span> <span>=</span> <span>try</span> File.open(path);</code>
<code>    ArrayList&lt;Byte&gt; bytes = ArrayList.new();</code>
<code>    <span>try</span> file.readToEnd(borrow bytes);</code>
<code>    <span>return</span> Success(bytes);</code>
<code>}</code></pre>

</figure>
<p>Typical RhodesScript:</p>

<figure>


<pre><code>public <span>function</span> read&lt;P <span>extends</span> <span>IncludingRef</span>&lt;<span>Path</span>&gt;&gt;(</code>
<code>    <span>path</span>: P,</code>
<code>): io.<span>Result</span>&lt;<span>Array</span>&lt;byte&gt;&gt; {</code>
<code>    <span>return</span> <span>myRead</span>(path.<span>included_ref</span>());</code>
<code>}</code>
<code></code>
<code>private <span>function</span> <span>myRead</span>(<span></span></code>
<code><span>    path: &amp;<span>const</span> Path,</span></code>
<code><span></span>): io.<span>Result</span>&lt;<span>Array</span>&lt;byte&gt;&gt; {</code>
<code>    <span>let</span> file = <span>try</span> <span>File</span>.<span>open</span>(path);</code>
<code>    <span>Array</span>&lt;byte&gt; bytes = <span>Array</span>.<span>new</span>()</code>
<code>    <span>try</span> file.<span>readToEnd</span>(&amp;bytes)</code>
<code>    <span>return</span> <span>Ok</span>(bytes);</code>
<code>}</code></pre>

</figure>
<p>Rattlesnake:</p>

<figure>


<pre><code><span>def</span> <span>read</span>[P: Refing[Path]](path: P): io.Result[<span>List</span>[byte]]:</code>
<code>    <span>def</span> <span>inner</span>(<span>path: @Path</span>): io.Result[<span>List</span>[byte]]:</code>
<code>        file := <span>try</span> File.<span>open</span>(path)</code>
<code>        <span>bytes</span> := <span>List</span>.new()</code>
<code>        <span>try</span> file.read_to_end(@: <span>bytes</span>)</code>
<code>        <span>return</span> Ok(<span>bytes</span>)</code>
<code>    <span>return</span> inner(path.ref)</code></pre>

</figure>
<p>And, to conclude, CrabML:</p>

<figure>


<pre><code>read :: &#39;p  ref_of =&gt; &#39;p -&gt; u8 vec io.either.t</code>
<code>let read p =</code>
<code>  let</code>
<code>    inner :: &amp;path -&gt; u8 vec.t io.either.t</code>
<code>    inner p =</code>
<code>      let mut file = try (File.open p) in</code>
<code>      let mut bytes = vec.new () in</code>
<code>      try (file.read_to_end (&amp;mut bytes)); Right bytes</code>
<code>  in</code>
<code>    ref_op p |&gt; inner</code>
<code>;;</code></pre>

</figure>
<p>As a slightly more serious and useful exercise, let’s do the opposite – keep the Rust syntax, but try to simplify semantics until the end result looks presentable.</p>
<p>Here’s our starting point:</p>

<figure>


<pre><code><span>pub</span> <span>fn</span> <span>read</span>&lt;P: <span>AsRef</span>&lt;Path&gt;&gt;(path: P) <span>-&gt;</span> io::<span>Result</span>&lt;<span>Vec</span>&lt;<span>u8</span>&gt;&gt; {</code>
<code>  <span>fn</span> <span>inner</span>(path: &amp;Path) <span>-&gt;</span> io::<span>Result</span>&lt;<span>Vec</span>&lt;<span>u8</span>&gt;&gt; {</code>
<code>    <span>let</span> <span>mut </span><span>file</span> = File::<span>open</span>(path)?;</code>
<code>    <span>let</span> <span>mut </span><span>bytes</span> = <span>Vec</span>::<span>new</span>();</code>
<code>    file.<span>read_to_end</span>(&amp;<span>mut</span> bytes)?;</code>
<code>    <span>Ok</span>(bytes)</code>
<code>  }</code>
<code>  <span>inner</span>(path.<span>as_ref</span>())</code>
<code>}</code></pre>

</figure>
<p>The biggest source of noise here is the nested function.
The motivation for it is somewhat esoteric.
The outer function is generic, while the inner function isn’t.
With the current compilation model, that means that the outer function is compiled together with the user’s code, gets inlined and is optimized down to nothing.
In contrast, the inner function is compiled when the std itself is being compiled, saving time when compiling user’s code.
One way to simplify this (loosing a bit of performance) is to say that generic functions are always separately compiled, but accept an extra runtime argument under the hood which describes the physical dimension of input parameters.</p>
<p>With that, we get</p>

<figure>


<pre><code><span>pub</span> <span>fn</span> <span>read</span>&lt;P: <span>AsRef</span>&lt;Path&gt;&gt;(path: P) <span>-&gt;</span> io::<span>Result</span>&lt;<span>Vec</span>&lt;<span>u8</span>&gt;&gt; {</code>
<code>  <span>let</span> <span>mut </span><span>file</span> = File::<span>open</span>(path.<span>as_ref</span>())?;</code>
<code>  <span>let</span> <span>mut </span><span>bytes</span> = <span>Vec</span>::<span>new</span>();</code>
<code>  file.<span>read_to_end</span>(&amp;<span>mut</span> bytes)?;</code>
<code>  <span>Ok</span>(bytes)</code>
<code>}</code></pre>

</figure>
<p>The next noisy element is the <code>&lt;P: AsRef&lt;Path&gt;&gt;</code> constraint.
It is needed because Rust loves exposing physical layout of bytes in memory as an interface, specifically for cases where that brings performance.
In particular, the meaning of <code>Path</code> is not that it is some abstract representation of a file path, but that it is just literally a bunch of contiguous bytes in memory.
So we need <code>AsRef</code> to make this work with <em>any</em> abstraction which is capable of representing such a slice of bytes.
But if we don’t care about performance, we can require that all interfaces are fairly abstract and mediated via virtual function calls, rather than direct memory access.
Then we won’t need <code>AsRef</code>at all:</p>

<figure>


<pre><code><span>pub</span> <span>fn</span> <span>read</span>(path: &amp;Path) <span>-&gt;</span> io::<span>Result</span>&lt;<span>Vec</span>&lt;<span>u8</span>&gt;&gt; {</code>
<code>  <span>let</span> <span>mut </span><span>file</span> = File::<span>open</span>(path)?;</code>
<code>  <span>let</span> <span>mut </span><span>bytes</span> = <span>Vec</span>::<span>new</span>();</code>
<code>  file.<span>read_to_end</span>(&amp;<span>mut</span> bytes)?;</code>
<code>  <span>Ok</span>(bytes)</code>
<code>}</code></pre>

</figure>
<p>Having done this, we can actually get rid of <code>Vec&lt;u8&gt;</code> as well — we can no longer use generics to express efficient growable array of bytes in the language itself.
We’d have to use some opaque <code>Bytes</code> type provided by the runtime:</p>

<figure>


<pre><code><span>pub</span> <span>fn</span> <span>read</span>(path: &amp;Path) <span>-&gt;</span> io::<span>Result</span>&lt;Bytes&gt; {</code>
<code>  <span>let</span> <span>mut </span><span>file</span> = File::<span>open</span>(path)?;</code>
<code>  <span>let</span> <span>mut </span><span>bytes</span> = Bytes::<span>new</span>();</code>
<code>  file.<span>read_to_end</span>(&amp;<span>mut</span> bytes)?;</code>
<code>  <span>Ok</span>(bytes)</code>
<code>}</code></pre>

</figure>
<p>Technically, we are still carrying ownership and borrowing system with us, but, without direct control over memory layout of types, it no longer brings massive performance benefits.
It still helps to avoid GC, prevent iterator invalidation, and statically check that non-thread-safe code isn’t actually used across threads.
Still, we can easily get rid of those &amp;-pretzels if we just switch to GC.
We don’t even need to worry about concurrency much — as our objects are separately allocated and always behind a pointer, we can hand-wave data races away by noticing that operations with pointer-sized things are atomic on x86 anyway.</p>

<figure>


<pre><code><span>pub</span> <span>fn</span> <span>read</span>(path: Path) <span>-&gt;</span> io::<span>Result</span>&lt;Bytes&gt; {</code>
<code>  <span>let</span> <span>file</span> = File::<span>open</span>(path)?;</code>
<code>  <span>let</span> <span>bytes</span> = Bytes::<span>new</span>();</code>
<code>  file.<span>read_to_end</span>(bytes)?;</code>
<code>  <span>Ok</span>(bytes)</code>
<code>}</code></pre>

</figure>
<p>Finally, we are being overly pedantic with error handling here — not only we mention a possibility of failure in the return type, we even use <code>?</code> to highlight any specific expression that might fail.
It would be much simpler to not think about error handling at all, and let some top-level</p>

<figure>


<pre><code><span>pub</span> <span>fn</span> <span>read</span>(path: Path) <span>-&gt;</span> Bytes {</code>
<code>  <span>let</span> <span>file</span> = File::<span>open</span>(path);</code>
<code>  <span>let</span> <span>bytes</span> = Bytes::<span>new</span>();</code>
<code>  file.<span>read_to_end</span>(bytes);</code>
<code>  bytes</code>
<code>}</code></pre>

</figure>
<p><strong><strong>Much</strong></strong> better now!</p>
</article>
  </div></div>
  </body>
</html>
