<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://xy2i.blogspot.com/2024/11/using-imhexs-pattern-language-to-parse.html">Original</a>
    <h1>Visualizing binary files with ImHex&#39;s DSL, the &#34;pattern language&#34;</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-5336638992688031908" itemprop="description articleBody">
<table>
  <tbody>
    <tr>
      <td>
        <a href="https://blogger.googleusercontent.com/img/a/AVvXsEhr51cqQb0ulfHNJUWA_lkK741iF0iquCSGdRD0m-2gv7Zwn564Te97XSEzggrRSYpLozZCxzS2fg4Kf6DkcwX1ETjpMBdiNi1s2LrweiniFh_mNX5mHg3odxH0NVOpUJxZTdTIWv50wsMtgtLS2OY8abdr2VecSeL9TvBIMoyfZ4TXoDax3GEFWsMIYYv1"><img alt="" data-original-height="1726" data-original-width="3024" height="371" loading="lazy" src="https://blogger.googleusercontent.com/img/a/AVvXsEhr51cqQb0ulfHNJUWA_lkK741iF0iquCSGdRD0m-2gv7Zwn564Te97XSEzggrRSYpLozZCxzS2fg4Kf6DkcwX1ETjpMBdiNi1s2LrweiniFh_mNX5mHg3odxH0NVOpUJxZTdTIWv50wsMtgtLS2OY8abdr2VecSeL9TvBIMoyfZ4TXoDax3GEFWsMIYYv1=w650-h371-rw" width="650"/></a>
      </td>
    </tr>
    <tr>
      <td>
        Viewing my binary file with ImHex. The pattern language pane, on the
        right, provides the highlighting and data on the left.
      </td>
    </tr>
  </tbody>
</table>
<p>
  I&#39;ve got a binary file with a custom made binary format, and a spec for that
  binary format. How do I go into the binary quickly and see the data I want ?
</p>
<p>
  This is a problem I ran into while writing some software that operates on this
  data. Before, my approach would have probably been to write some Python code
  to parse the format, following the spec carefully and see where it
  diverges. 
</p>
<p>
  Recently though, I heard about <a href="https://imhex.werwolv.net/">ImHex</a>,
  an hex editor with advanced features, and decided to give it a go.</p><p>The feature I used the most in ImHex for my case
  was the integrated DSL, the &#34;pattern language&#34;. It lets you define structures
  that ImHex will match on, and decode the data. The syntax is a mix of C++ and Rust, but with unique semantics and a lot of nice affordances.</p><p>Many examples that follow will be my real code for parsing the <a href="https://en.wikipedia.org/wiki/SWF">SWF file format</a>.</p>
<h2>An overview of the pattern language</h2><p>Here&#39;s a pattern which parses a char, followed by the &#34;WS&#34; string in memory, an unsigned byte, and a four byte number after:</p>

<pre><code>import type.magic;

struct Header { 
    char compressionSignature;
    type::Magic&lt;&#34;WS&#34;&gt; signature; 
    u8 swfVersion; 
    u32 bytesSize; 
}; 

Header h @ 0x0;
</code></pre>
<p>In ImHex, there are two steps to patterns:
</p><ul><li>first, you define the variable that you want to place, with a type. This can be one of the many <a href="https://docs.werwolv.net/pattern-language/core-language/data-types">primitive types</a>, like <code>u8</code>, <code>char</code>, an array, or a compound type, like a struct or a bitfield.</li><li>then, you can place that variable somewhere in memory, using the <code>@ address</code> syntax. </li></ul><table><tbody><tr><td><a href="https://blogger.googleusercontent.com/img/a/AVvXsEhQ2NztHxSH1StF8IgMMVq2UnA-ajxPWFsDihaiZutQbQKRFZ9pcxVHXdabCXTjplRV0EkgEmhd0QF1dRaSPtfvmjyzuGkVOuLxa2xiJWWCYhiA91y6sRQJ2R2O1iYsewk6zls9of9TAE7ZQ2669--fHx0NOHMkeQtah1zq-i5JDozAeqonVlTzcCc1T_K3"><img alt="" data-original-height="806" data-original-width="2282" height="144" loading="lazy" src="https://blogger.googleusercontent.com/img/a/AVvXsEhQ2NztHxSH1StF8IgMMVq2UnA-ajxPWFsDihaiZutQbQKRFZ9pcxVHXdabCXTjplRV0EkgEmhd0QF1dRaSPtfvmjyzuGkVOuLxa2xiJWWCYhiA91y6sRQJ2R2O1iYsewk6zls9of9TAE7ZQ2669--fHx0NOHMkeQtah1zq-i5JDozAeqonVlTzcCc1T_K3=w406-h144-rw" width="406"/></a></td></tr><tr><td>Placing the pattern at 0x0 in memory. ImHex fills out the data in the Pattern Data pane, and shows the value in the types you chose.</td></tr></tbody></table><p>Patterns can be made more complex, nesting structs, or if you don&#39;t have a spec of your data and are reverse engineering, you can progressively place things, until you make more sense of it.</p><h3>Logic in patterns</h3><p>A value may exist or not based on a previous value, or even be sized differently based on a prior value that tells you the size. When parsing SWFs, I encountered this case with a bitfield, where the first field decides the size of the remaining fields. </p><p>These cases are easy to write, since in the pattern language, you can reuse previous values, even if it&#39;s declared in the same structure:</p><div><pre><code>bitfield Rect {
    // First field has a size of 5 bits
    nSize : 5;
    // The remaining fields have a size of nSize bits,
    // based on the value of nSize.
    signed xMin : nSize;
    signed xMax : nSize;
    signed yMin : nSize;
    signed yMax : nSize;
};</code></pre><p>You can even put conditionals and other logic constructs inside. Here there are two fields indicating the length of a structure, of different size, and the second one exists only if the first has some magic value:<br/></p><pre><code>bitfield RecordHeaderShort {
    Length: 6;
    Tag Tag: 10;
};

struct RecordHeader {
    // Including a structure inside another one
    RecordHeaderShort short;
    // Defines a variable, that does not show up in the view,
    // but can be accessed like a field
    Tag Tag = short.Tag;
    u32 len = short.Length;
    
    if (short.Length == 0x3f) {
        u32 LongLength;
        len = LongLength;
    }
};</code></pre><p>I defined a variable <code>len</code> that&#39;s present on this structure, but doesn&#39;t show up in the ImHex view. It is accesible however if <code>RecordHeader</code> is nested in another struct, so it&#39;s useful for getting the real length, without duplicating the logic each time.</p><h3>Match statements</h3><p>This feature is neat. First let&#39;s define a enum:</p><div><pre><code>enum Tag: u8 {
    End = 0,
    ShowFrame = 1,
    SetBackgroundColor = 9,
    DoAction = 12,
    FileAttributes = 69,
    Metadata = 77, 
};</code></pre><p><span>Now I can use a Rust like match statement to match on the values extensively, defining values in the struct based on the matched value:<br/></span></p><pre><code>struct TagRecord {
    RecordHeader RecordHeader; // see above
    
    match (RecordHeader.Tag) {
        // To define a field, you can also just declare its type,
        // there is no need to name it. This declares a field
        // of type `SetBackgroundColor`.
        (Tag::SetBackgroundColor): SetBackgroundColor;
        (Tag::DoAction): DoAction;
        (Tag::FileAttributes): FileAttributes;
        (Tag::Metadata): Metadata;
        // The `padding` keyword is treated specially by the language:
        // Creates a padding, with its length set to
        // a field of the RecordHeader structure. This will not show up in 
        // the pattern view, because it&#39;s declared as padding.
        (_): padding[RecordHeader.len];
    } 
// An attribute. In the data pane, this structure&#39;s name will be
// the enum&#39;s name.
} [[name(RecordHeader.Tag)]];</code></pre><h3><span><table><tbody><tr><td><a href="https://blogger.googleusercontent.com/img/a/AVvXsEjRG5gj54H0xPrAa9xhzOjvSJlniu6XPp85hoJKZsSAJuiirC0DrsiK6Cfvj6NdR61RDcz_yjc4yd19wEAJdhvYh9DdN883r053lkMUYqptwfmT2hPfV0rQDtXp7fZQtXyRUDqohVtbdoYvDHyNTgj1i0Zta13A9eJ0zYHN2GuwsblLO47D8DsLA-b0XbqB"><img alt="" data-original-height="412" data-original-width="1690" height="78" loading="lazy" src="https://blogger.googleusercontent.com/img/a/AVvXsEjRG5gj54H0xPrAa9xhzOjvSJlniu6XPp85hoJKZsSAJuiirC0DrsiK6Cfvj6NdR61RDcz_yjc4yd19wEAJdhvYh9DdN883r053lkMUYqptwfmT2hPfV0rQDtXp7fZQtXyRUDqohVtbdoYvDHyNTgj1i0Zta13A9eJ0zYHN2GuwsblLO47D8DsLA-b0XbqB=rw" width="320"/></a></td></tr><tr><td>In the data view, each tag shows up with the enum&#39;s name.</td></tr></tbody></table></span></h3><h3><span><span>Array stop conditions</span></span></h3><p><span><span>An issue I encountered was that my file format is just an array of <code>TagRecords</code>, until the end of the file. This means there is no length: and using a null terminated array doesn&#39;t work, since there are tags with null values. </span></span></p><p><span><span>Thankfully, the pattern language has support for custom stop conditions, using a &#34;<a href="https://docs.werwolv.net/pattern-language/core-language/data-types#loop-sized-array">loop sized array</a>&#34;:</span></span></p><pre><code>struct File {
    Header;
    // This function returns true when
    // the end of the file has been reached
    TagRecord Tags[while(!std::mem::eof())];
};</code></pre><p><span>ImHex also has <a href="https://docs.werwolv.net/pattern-language/core-language/expressions#usd-dollar-operator">a special $ (dollar) operator</a>, which always points to the current offset in the file. This variable is even modifiable inside your pattern to change the position. One good use for this is a loop sized array like this one, that will stop on a 0xFF value:<br/></span></p><pre>u8 string[while(std::mem::read_unsigned($, 1) != 0xFF)];</pre><p><h3><span>Decompressing files inside ImHex directly </span></h3></p><p><span>Most SWF files in the wild come compressed, with a non trivial decompression procedure, which means my pattern can&#39;t be applied directly: I need a decompression step first. In the past I would have reached for a Python script to decompress the file with the custom logic needed.</span></p><p><span><span>But the pattern language also supports this case, and has <a href="https://docs.werwolv.net/pattern-language/libraries/hex/dec.pat#hex-dec-zlib_decompress">built-in decompression functions</a>, as well as a <a href="https://docs.werwolv.net/pattern-language/libraries/hex/core.pat#hex-core-add_virtual_file">virtual file system</a> to store the output file:<br/></span></span></p><pre><code>struct Compressed {
    // Create a section in memory for the decompressed contents. Only contents
    // starting from a certain offset are compressed
    UncompressedHeader h;
    std::mem::Section decompressed = std::mem::create_section(&#34;Zlib decompressed&#34;);
    u8 compressedContents[std::mem::size() - 8] @ 0x8;
    // Do the actual decompression.
    hex::dec::zlib_decompress(compressedContents, decompressed, 15);
    
    // Combine both the uncompressed header and decompressed part to recreated
    // the full decompressed file.
    std::mem::Section full = std::mem::create_section(&#34;Full decompressed SWF&#34;);
    std::mem::copy_value_to_section(h, full, 0x0);
    std::mem::copy_section_to_section(decompressed, 0x0, full, 0x8, h.decompressedSize - 8);
    // Write decompressed flag, so next time we open the pattern knows it&#39;s decompressed
    std::mem::copy_value_to_section(&#34;Z&#34;, full, 0x0);
    
    // Write this file to the virtual file system.
    u8 d[h.bytesSize] @ 0x00 in full;
    builtin::hex::core::add_virtual_file(std::format(&#34;dec-{}&#34;, hex::prv::get_information(&#34;file_name&#34;)), d);
    std::warning(&#34;This SWF is ZLib-compressed, grab the decompressed save from\nthe Virtual Filesystem tab and use this pattern on it.&#34;);
};

struct Main {
    char compressed @ 0x0;
    match (compressed) {
        (&#39;C&#39;): Compressed;
        (&#39;Z&#39;): File;
    }
};</code></pre><div><p><span>By running this pattern once, the resulting file ends up in a new tab, in ImHex&#39;s &#34;virtual filesystem&#34;.</span></p><p><span><table><tbody><tr><td><a href="https://blogger.googleusercontent.com/img/a/AVvXsEjMG3l0cfg1555mOQDA6w1yVRAEwTq98Kz3_fONfh86Rbpf2f3Ts-t3yxSTnJ2Wo48CtaxW_Q6QcEiaa_elZIQA3bakrpT5OJDqIyIJHYc7APtKGhNr65YVn5Zc3-HM94thw_MfWl-zrF7t65zFMSB1L6N4hV06qMs5NhF6VurwxcTrsqgeguL2YDbqq_8M"><img alt="" data-original-height="166" data-original-width="1330" height="40" loading="lazy" src="https://blogger.googleusercontent.com/img/a/AVvXsEjMG3l0cfg1555mOQDA6w1yVRAEwTq98Kz3_fONfh86Rbpf2f3Ts-t3yxSTnJ2Wo48CtaxW_Q6QcEiaa_elZIQA3bakrpT5OJDqIyIJHYc7APtKGhNr65YVn5Zc3-HM94thw_MfWl-zrF7t65zFMSB1L6N4hV06qMs5NhF6VurwxcTrsqgeguL2YDbqq_8M=rw" width="320"/></a></td></tr><tr><td>The decompressed file in the virtual file system</td></tr></tbody></table></span></p><h2><span>Conclusion</span></h2><p><span>Overall I was very impressed by the pattern language. Not only does it make my task much simpler, it also is well thought out for the tasks it sets out to do,, both in its design and in its day to day conveniences.</span></p><p><span>However, currently the language doesn&#39;t have a lot of documentation or tutorials to get started. Thankfully it was easy to get started with some help, the developers on discord are very nice (and thanks again to paxcut for helping debug some issues!) Hopefully this post was interesting even if you&#39;ve never had this problem before :)<br/></span></p><p><span><a href="https://gist.github.com/xy2i/848eadb61288ecc0cdb19cda7eff79ba">You can find my full code here</a>, if you&#39;re curious of what it looks like all put together.</span></p></div></div></div>


</div></div>
  </body>
</html>
