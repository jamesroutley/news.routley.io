<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.adamchalmers.com/nom-bits/">Original</a>
    <h1>Parsing bitstreams with Nom</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Programming languages generally only manipulate bytes (groups of 8 bits). It can be pretty tricky to manipulate single bits. But sometimes you need to -- for example, a <a href="https://datatracker.ietf.org/doc/html/rfc1035#section-4.1.1">DNS header</a> has some 4-bit numbers, and encodes some boolean flags into single bits. So we really need a way to parse binary data without chunking it up into bytes of 8 bits.</p>
<p>Luckily, <a href="https://docs.rs/nom">Nom</a> can do this! In the last blog post, we learned how to <a href="https://blog.adamchalmers.com/nom-chars">parse text files</a> with Nom. The trick is to start with simple parsers that parse a few characters at a time. Then, using combinators, combine those simple parsers into more complex parsers that can deserialize an entire structured file. We can reuse this approach for parsing <em>binary</em> data too. Let&#39;s see how!</p>
<p>Note that all code examples use Nom 7 -- I&#39;ll try to update this if Nom 8 makes breaking changes, but I can&#39;t guarantee anything :)</p>
<h2 id="representing-bitstream-inputs">Representing bitstream inputs</h2>
<p>In the previous post, we saw that Nom parsers are generic over three types:</p>
<ul>
<li><code>I</code>, the input</li>
<li><code>O</code>, the output</li>
<li><code>E</code>, the error type</li>
</ul>
<p>In the last post, we used <code>I = &amp;str</code>, which lets you parse a stream of text. The input type <code>I = &amp;[u8]</code> lets you parse a stream of bytes. But how can we represent a stream of <em>bits</em>? Rust doesn&#39;t have any type to represent a bit! </p>
<p>This question is actually really important, and it&#39;s going to come up several times in this blog post. How do we represent <em>n</em> &lt; 8 bits?</p>
<p>My first answer was &#34;just use bools&#34; -- you were probably thinking this too. Just represent 0 as <code>false</code> and 1 as <code>true</code>. This definitely works, but it&#39;s a bit wasteful. Rust bools actually take up an entire byte. So you could represent a bitstream as <code>&amp;[bool]</code>, but it would take 8x as many bytes as necessary! That&#39;s fine for many applications, but Nom has a more efficient representation.</p>
<p>The solution to representing a bitstream is pretty clever: we use two values. Firstly, a list of bytes, and secondly, a number representing which exact bit of those bytes is next.</p>
<pre><code data-lang="rust"><span>I = (&amp;[</span><span>u8</span><span>], </span><span>usize</span><span>)
</span></code></pre>
<p>This pair represents a bitstream. The first element is a stream of bits, stored one byte at a time (so, in groups of 8 bits). The second element is an offset, showing which bit (not byte!) should be read next.</p>
<p>For example, let&#39;s say we want to parse a sequence of 16 bits like <code>1111 0000 1100 1100</code>. We&#39;ll start by reading from the very first element. This is how I visualize the bitstream and offset:</p>
<pre><code><span>1111000011001100
^
</span></code></pre>
<p>Note the little arrow pointing at the first bit in the input. To represent this using the <code>I = (&amp;[u8], usize)</code> type, we break the bit input into bytes, and note which bit is currently being pointed to. Like this:</p>
<pre><code><span>([0b11110000, 0b11001100], 0)
    ^
</span></code></pre>
<p>Lets say you parsed 3 bits from there. After that, the bitstream would be</p>
<pre><code><span>([0b11110000, 0b11001100], 3)
       ^
</span></code></pre>
<p>After reading another six bits, the input would have advanced past the first byte:</p>
<pre><code><span>([0b11110000, 0b11001100], 9)
                 ^
</span></code></pre>
<p>Because the first byte will never be used again, Nom optimizes by dropping the first byte, adjusting the offset to account for that:</p>
<pre><code><span> ([0b11001100], 1)
      ^
</span></code></pre>
<p>Because this tuple type appears so often, I usually add a type alias for it:</p>
<pre><code data-lang="rust"><span>type </span><span>BitInput&lt;</span><span>&#39;a</span><span>&gt; = (&amp;</span><span>&#39;a </span><span>[</span><span>u8</span><span>], </span><span>usize</span><span>);
</span></code></pre><h2 id="parsing-bitstreams-with-take">Parsing bitstreams with &#34;take&#34;</h2>
<p>We just learned how Nom represents inputs that can address individual bits. Now we&#39;re going to see how to run parsers on that bitstream input. There&#39;s two main bit-level parsers: <code>take</code> and <code>tag</code>. </p>
<p>The <a href="https://docs.rs/nom/7.1.0/nom/bits/complete/fn.take.html"><code>nom::bits::complete::take</code></a> parser is similar to the <a href="https://docs.rs/nom/7.1.0/nom/bytes/complete/fn.take.html"><code>nom::bytes::complete::take</code></a> parser from the previous post. It has a parameter, <code>count</code>, and it takes that number of bits from the input, then returns those <code>count</code> bits as the output. If there&#39;s not enough bits left in the input (i.e. the input&#39;s length in bits is &lt; <code>count</code>) then it panics.</p>
<p>This parser sounds pretty simple, but invoking it takes a little work, because it has a lot of generics  and Rust usually can&#39;t infer the types. So I&#39;ve always just used helper functions that provide specific, concrete types. So, let&#39;s build a parser that parses four bits. A four-bit number is called a <em>nibble</em> (because it&#39;s half a byte... get it... by engineering standards this qualifies as a &#34;joke&#34;). </p>
<p>Obviously its <code>I</code> (generic input type) will be the standard <code>BitInput</code> alias. But what will the <code>O</code> (generic output type) be? After all, Rust doesn&#39;t have a u4 type. How do we store a 4 bit number? </p>
<p>This question is really just the earlier question of &#34;how can we represent bits in Rust&#34; again. See, I told you it&#39;d come up several times in this post.</p>
<p>Well, Nom&#39;s <code>take</code> parser solves this by padding your <em>n</em> bits with leading zeroes, and storing them in some uint type like <code>u8</code>, <code>u16</code> or whichever one you, the programmer, choose. We&#39;ll parse the first 4 bits into a number between 0 and 15, and then just store that number in a u8. This means the 4 most significant bits will always be zero. You can use any uint type, but a <code>u8</code> will do just fine, and wastes less RAM than using a <code>u16</code> or any larger type.</p>
<pre><code data-lang="rust"><span>use </span><span>nom::{bits::complete::take, IResult};
</span><span>type </span><span>BitInput&lt;</span><span>&#39;a</span><span>&gt; = (&amp;</span><span>&#39;a </span><span>[</span><span>u8</span><span>], </span><span>usize</span><span>);

</span><span>/// Take 4 bits from the BitInput.
/// Store the output in a u8, because there&#39;s no u4 type, and u8 is the 
/// closest-available size.
</span><span>fn </span><span>take_nibble</span><span>(</span><span>i</span><span>: BitInput) -&gt; IResult&lt;BitInput, </span><span>u8</span><span>&gt; {
    </span><span>// Have to specify some concrete numeric type, otherwise Rust won&#39;t know which
    // type of number you&#39;re trying to use here. I used usize, but you could use 
    // any uint type.
    </span><span>take</span><span>(</span><span>4</span><span>usize</span><span>)(i)
}
</span><span>// Note that Rust number literals let you put underscores wherever you&#39;d like, to
// enhance readability. E.g. you can help separate commas, by writing 1000000 as 
// 1_000_000. 
// I&#39;ve used them here to visually separate the two u4 values in this u8.
</span><span>let</span><span> input = ([</span><span>0b1010_1111</span><span>].</span><span>as_ref</span><span>(), </span><span>0</span><span>);

</span><span>let </span><span>(_input, actual_nibble) = </span><span>take_nibble</span><span>(input).</span><span>unwrap</span><span>();
</span><span>let</span><span> expected_nibble = </span><span>0b1010</span><span>;
assert_eq!(actual_nibble, expected_nibble);
</span></code></pre><h2 id="parsing-bitstreams-with-tag">Parsing bitstreams with &#34;tag&#34;</h2>
<p>The bitwise <a href="https://docs.rs/nom/7.1.0/nom/bits/complete/fn.tag.html"><code>tag</code></a> parser matches a specific pattern of bits, like &#34;0110&#34;, from the input. Again, it&#39;s a simple idea, but it raises a tricky question: how do we represent a pattern of bits? Yes, this is the <em>third</em> time I&#39;ve asked &#34;how do we represent bits in Rust&#34;. I told you, it&#39;s a pretty fundamental question! And it uses a very similar solution.</p>
<p>Nom represents the bit pattern using two parameters:</p>
<ul>
<li><strong>count</strong>: how many bits long the pattern is</li>
<li><strong>pattern</strong>: The pattern itself, padded with leading zeroes to fit into some uint type.</li>
</ul>
<p>For example:</p>
<ul>
<li>The pattern <code>101</code> is represented as <code>(pattern: 00000_101, count: 3)</code>. </li>
<li>The pattern <code>111000111</code> is represented as <code>(pattern: 0000000_111000111, count: 9)</code>. </li>
</ul>
<p>You, the programmer, will choose which uint types to use for <code>pattern</code> and <code>count</code> -- the parser is generic over various uint types. I personally would just use the smallest uint that fits the value. So, example 1&#39;s pattern fits in a <code>u8</code>, example 2&#39;s fits in a <code>u16</code>, and in both the count fits in a <code>u8</code>. So I&#39;d just use those. I don&#39;t really think it really matters that much.</p>
<p>OK, now that we know how to represent a pattern of bits, the <code>tag</code> parser is easy. You supply a pattern of bits, and Nom compares it, bit-by-bit, with the input bits. Like all Nom parsers, <code>tag</code> returns a Result. If the parser matches the input, it returns OK with a pair: (remaining input, matched output). If there&#39;s no match, it returns Err. So, for example, parsing the pattern <code>101</code> on the bitstream <code>10100</code> will return (<code>00</code>, <code>101</code>). </p>
<p>We&#39;re now ready to look at actual code:</p>
<pre><code data-lang="rust"><span>use </span><span>nom::{bits::complete::tag, IResult};

</span><span>type </span><span>BitInput&lt;</span><span>&#39;a</span><span>&gt; = (&amp;</span><span>&#39;a </span><span>[</span><span>u8</span><span>], </span><span>usize</span><span>);

</span><span>// This is just a simple wrapper around the `tag` parser, but it makes the 
// parameter types concrete instead of generic, so now Rust knows how to actually
// store the pattern.
</span><span>fn </span><span>parser</span><span>(</span><span>pattern</span><span>: </span><span>u8</span><span>, </span><span>count</span><span>: </span><span>u8</span><span>, </span><span>input</span><span>: BitInput) -&gt; IResult&lt;BitInput, </span><span>u8</span><span>&gt; {
    </span><span>tag</span><span>(pattern, num_bits_to_compare)(input)
}

</span><span>// The pattern 1111 matches the stream 1111_1111
</span><span>assert!(</span><span>parser</span><span>(</span><span>0b1111</span><span>, </span><span>4</span><span>, (&amp;[</span><span>0b1111_1111</span><span>], </span><span>0</span><span>)).</span><span>is_ok</span><span>());
</span><span>// The pattern 1 matches the stream too
</span><span>assert!(</span><span>parser</span><span>(</span><span>0b1</span><span>, </span><span>1</span><span>, (&amp;[</span><span>0b1111_1111</span><span>], </span><span>0</span><span>)).</span><span>is_ok</span><span>());
</span><span>// The pattern 01 does _not_ match the stream
</span><span>assert!(</span><span>parser</span><span>(</span><span>0b1</span><span>, </span><span>2</span><span>, (&amp;[</span><span>0b1111_1111</span><span>], </span><span>0</span><span>)).</span><span>is_err</span><span>());
</span><span>// The pattern 1111_1110 doesn&#39;t match the stream either
</span><span>assert!(</span><span>parser</span><span>(</span><span>0b1111_1110</span><span>, </span><span>8</span><span>, (&amp;[</span><span>0b1111_1111</span><span>], </span><span>0</span><span>)).</span><span>is_err</span><span>());
</span></code></pre><h2 id="bitstreams-and-combinators">Bitstreams and combinators</h2>
<p>Remember the whole idea of a parser combinator library is: start with a few small parsers, then combine them with combinator functions. We&#39;ve seen two primitive parsers for bitstreams, <code>tag</code> and <code>take</code>. Here&#39;s how to combine them with e.g. the <a href="https://docs.rs/nom/7.1.0/nom/combinator/fn.map.html"><code>map</code></a> combinator from my last post:</p>
<pre><code data-lang="rust"><span>use </span><span>nom::{bits::complete::take, combinator::map, IResult};
</span><span>type </span><span>BitInput&lt;</span><span>&#39;a</span><span>&gt; = (&amp;</span><span>&#39;a </span><span>[</span><span>u8</span><span>], </span><span>usize</span><span>);

</span><span>/// Takes one bit from the input, returning true for 1 and false for 0.
</span><span>fn </span><span>take_bit</span><span>(</span><span>i</span><span>: BitInput) -&gt; IResult&lt;BitInput, </span><span>bool</span><span>&gt; {
    </span><span>map</span><span>(</span><span>take</span><span>(</span><span>1</span><span>usize</span><span>), |</span><span>bits</span><span>: </span><span>u8</span><span>| bits &gt; </span><span>0</span><span>)(i)
}

</span><span>let</span><span> input = ([</span><span>0b10101010</span><span>].</span><span>as_ref</span><span>(), </span><span>0</span><span>);
</span><span>let </span><span>(input, first_bit) = </span><span>take_bit</span><span>(input).</span><span>unwrap</span><span>();
assert!(first_bit); </span><span>// First bit is 1
</span><span>let </span><span>(_input, second_bit) = </span><span>take_bit</span><span>(input).</span><span>unwrap</span><span>();
assert!(!second_bit); </span><span>// Second bit is 0
</span></code></pre><h2 id="converting-bytestreams-to-bitstreams-and-back">Converting bytestreams to bitstreams and back</h2>
<p>So far we&#39;ve learned how to make simple bit parsers, and combine them into complex ones. We&#39;ve even learned how Nom represents bitstreams. The last question is: where do these bitstreams come from, anyway? After all, most Rust functions represent binary data in bytes (e.g. as <code>Vec&lt;u8&gt;</code> or using the <a href="https://docs.rs/bytes/latest/bytes/">bytes crate</a>). If you&#39;re reading binary data from disk, or RAM, or the network, it&#39;s almost definitely going to be stored in bytes. So we need a way to turn a bytestream into a bitstream. </p>
<p>Luckily the function <a href="https://docs.rs/nom/latest/nom/bits/fn.bits.html"><code>nom::bits::bits</code></a> does exactly that. The docs say it &#34;converts a byte-level input to a bit-level input, for consumption by a parser that uses bits.&#34; Perfect!</p>
<p>Again, this function uses a lot of generics which can be confusing, so here&#39;s an example showing how it works.</p>
<pre><code data-lang="rust"><span>use </span><span>nom::IResult;
</span><span>use </span><span>nom::multi::many0;
</span><span>use </span><span>nom::number::complete::be_u16;

</span><span>type </span><span>BitInput&lt;</span><span>&#39;a</span><span>&gt; = (&amp;</span><span>&#39;a </span><span>[</span><span>u8</span><span>], </span><span>usize</span><span>);

</span><span>/// Stub example type. Imagine this has to be parsed from individual bits.
</span><span>struct </span><span>BitwiseHeader;

</span><span>/// A bit-level parser
</span><span>fn </span><span>parse_header</span><span>(</span><span>i</span><span>: BitInput) -&gt; IResult&lt;BitInput, BitwiseHeader&gt; {
    todo!()
}

</span><span>/// Stub example type. 
/// The header has to be parsed from bits, but the body can be parsed from bytes.
</span><span>struct </span><span>Message {
    </span><span>header</span><span>: BitwiseHeader,
    </span><span>body</span><span>: Vec&lt;</span><span>u16</span><span>&gt;,
}

</span><span>/// A byte-level parser that calls a bit-level parser
</span><span>fn </span><span>parse_msg</span><span>(</span><span>i</span><span>: &amp;[</span><span>u8</span><span>]) -&gt; IResult&lt;&amp;[</span><span>u8</span><span>], Message&gt; {
    </span><span>/// The header has to be parsed from bits
    </span><span>let </span><span>(i, header) = nom::bits::bits(parse_header)(i)?;
    </span><span>/// But the rest of the message can be parsed from bytes.
    </span><span>let </span><span>(i, body) = </span><span>many0</span><span>(be_u16)(i)?;
    Ok((i, Message { header, body }))
}
</span></code></pre>
<p>I got curious about these bitwise parsers because of <a href="https://adventofcode.com/2021/day/16">Advent of Code 2021, day 16</a>. A few weeks later, I wanted to <a href="https://github.com/adamchalmers/dingo/blob/d1a34e37b2c743dcd63bfe8612fd1d7c63ce9d63/src/message.rs#L239">build a DNS client</a>, and realized that parsing the u4s or single-bit flags is easy with Nom. In my next blog post, we&#39;ll look at how to parse a real-world example with bitstreams: DNS message headers.</p>

</div></div>
  </body>
</html>
