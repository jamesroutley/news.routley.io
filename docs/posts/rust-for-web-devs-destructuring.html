<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://paulbutler.org/2022/rust-for-web-devs-destructuring/">Original</a>
    <h1>Rust for web devs: Destructuring</h1>
    
    <div id="readability-page-1" class="page"><div><p><em>This is the first of an unbounded and weakly-ordered series of posts aimed at developers coming to Rust from a JavaScript/TypeScript background. It’s “for web devs” because my imagined reader is a web develop<strong>er</strong>, but it’s not about web develop<strong>ment</strong>. Nor is it meant to be a comprehensive introduction to Rust, just a series of essays on the parts I find interesting. If you’re brand new to Rust, you might want to start with <a href="https://doc.rust-lang.org/book/">The Book</a> or <a href="https://www.rustinaction.com/">Rust in Action</a>.</em></p>
<h2 id="destructuring-assignment-in-javascript">Destructuring Assignment in JavaScript</h2>
<p>One of the most universal tasks in programming is putting data into and taking data out of composite data types. <em>Composite data types</em> is just a fancy way of saying data types that can contain other data types (like lists and objects), in contrast to <em>primitive types</em> which are the “atoms” (like numbers and booleans) that can’t be broken down.</p>
<p>In JavaScript, we could say something like:</p>
<div><pre tabindex="0"><code data-lang="javascript"><span>let</span> <span>user</span> <span>=</span> <span>new</span> Object();
<span>user</span>.<span>name</span> <span>=</span> <span>&#34;Tim&#34;</span>;
<span>user</span>.<span>city</span> <span>=</span> <span>&#34;Ottawa, ON&#34;</span>;
<span>user</span>.<span>country</span> <span>=</span> <span>&#34;Canada&#34;</span>;
</code></pre></div><p><em>(aside: <a href="http://localhost:1313/2022/what-does-it-mean-to-listen-on-a-port/">we met Tim</a> last week. Thanks to an  <a href="https://news.ycombinator.com/item?id=30329590">encouraging reader</a> for the character development assist.)</em></p>
<p>This gets a bit tedious, though, so usually we write an object literal:</p>
<div><pre tabindex="0"><code data-lang="javascript"><span>let</span> <span>user</span> <span>=</span> {
    <span>name</span><span>:</span> <span>&#34;Tim&#34;</span>,
    <span>city</span><span>:</span> <span>&#34;Ottawa, ON&#34;</span>,
    <span>country</span><span>:</span> <span>&#34;Canada&#34;</span>
}
</code></pre></div><p>The same applies in reverse. We could pull fields out of <code>user</code> like this:</p>
<div><pre tabindex="0"><code data-lang="javascript"><span>let</span> <span>name</span> <span>=</span> <span>user</span>.<span>name</span>;
<span>let</span> <span>city</span> <span>=</span> <span>user</span>.<span>city</span>;
<span>let</span> <span>country</span> <span>=</span> <span>user</span>.<span>country</span>;
</code></pre></div><p>In modern JavaScript, it’s more common to see a version that mirrors the object literal construction:</p>
<div><pre tabindex="0"><code data-lang="javascript"><span>let</span> {<span>name</span>, <span>city</span>, <span>country</span>} <span>=</span> <span>user</span>;
</code></pre></div><p>This hasn’t always been the case; JavaScript hasn’t always had destructuring assignment. If we dial back the TypeScript compiler to target a prehistoric version of JavaScript (ES3), it converts the code above into this:</p>
<div><pre tabindex="0"><code data-lang="javascript"><span>var</span> <span>name</span> <span>=</span> <span>user</span>.<span>name</span>, <span>city</span> <span>=</span> <span>user</span>.<span>city</span>, <span>country</span> <span>=</span> <span>user</span>.<span>country</span>;
</code></pre></div><p>I say all this just to make the point clear: there’s nothing magical about destructuring. It’s <a href="https://en.wikipedia.org/wiki/Syntactic_sugar">syntactic sugar</a>: a language feature that saves keystrokes for you, the programmer, and makes your code more readable. It doesn’t fundamentally make the language more capable, but it’s a nice quality-of-life improvement.</p>
<p>In JavaScript, destructuring also works with the <code>Array</code> type. One place you tend to see this is React hooks like <a href="https://reactjs.org/docs/hooks-state.html"><code>useState</code></a> that return multiple values. In theory, you <em>could</em> use it like this:</p>
<div><pre tabindex="0"><code data-lang="javascript"><span>var</span> <span>myStatePair</span> <span>=</span> <span>React</span>.<span>useState</span>(<span>null</span>);
<span>myStatePair</span>[<span>1</span>](<span>&#34;my new value&#34;</span>);
</code></pre></div><p>But nobody does that, because it’s bonkers. Instead, you typically see:</p>
<div><pre tabindex="0"><code data-lang="javascript"><span>var</span> [<span>myState</span>, <span>setMyState</span>] <span>=</span> <span>React</span>.<span>useState</span>(<span>null</span>);
<span>setMyState</span>(<span>&#34;my new value&#34;</span>);
</code></pre></div><p>React uses an <code>Array</code> here because JavaScript doesn’t have a “tuple” type, but it uses an array like a tuple to return a fixed number (two) of things with different types, rather than a variable-length list.</p>
<h2 id="destructuring-assignment-in-rust">Destructuring Assignment in Rust</h2>
<p>Destructuring assignment in Rust is conceptually similar to JavaScript. That is to say: there are cases where there is syntax sugar for extracting elements from a data structure that mirrors the syntax for creating that same data structure.</p>
<p>We can see this in action by destructuring a tuple.</p>
<div><pre tabindex="0"><code data-lang="rust"><span>fn</span> <span>my_function</span>(data: <span>&amp;</span>(<span>u32</span>, <span>&amp;</span><span>str</span>)) {
    <span>let</span> (my_num, my_str) <span>=</span> data;
    println<span>!</span>(<span>&#34;my_num: {}, my_str: {}&#34;</span>, my_num, my_str);
}

<span>fn</span> <span>main</span>() {
    <span>let</span> data <span>=</span> (<span>4</span>, <span>&#34;ok&#34;</span>);
    my_function(<span>&amp;</span>data);
}
</code></pre></div><p>As you might expect, this prints: (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=f01c48144dd226910e44a5d7a7b7a9fe">see for yourself</a>)</p>
<pre><code>my_num: 4, my_str: ok
</code></pre><p>We can also destructure types we define ourself. Here’s an example similar to the object example we saw in JavaScript above. (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=91813f8fdf509e997bb5d45a28fa9fd6">try it</a>)</p>
<div><pre tabindex="0"><code data-lang="rust"><span>struct</span> <span>User</span> {
    name: String,
    city: String,
    country: String,
}

<span>fn</span> <span>print_user</span>(user: <span>&amp;</span><span>User</span>) {
    <span>let</span> User {
        name, city, country
    } <span>=</span> user;
    println<span>!</span>(<span>&#34;User {} is from {}, {}&#34;</span>, name, city, country);
}

<span>fn</span> <span>main</span>() {
    <span>let</span> user <span>=</span> User {
        name: <span>&#34;Tim&#34;</span>.to_string(),
        city: <span>&#34;Ottawa, ON&#34;</span>.to_string(),
        country: <span>&#34;Canada&#34;</span>.to_string(),
    };
    print_user(<span>&amp;</span>user);
}
</code></pre></div><p>Sometimes, we don’t need all the fields. Let’s <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=4b5286e3961b820d5bc12c8fe1cd551a">see what happens</a> if we omit one:</p>
<div><pre tabindex="0"><code data-lang="rust"><span>struct</span> <span>User</span> {
    name: String,
    city: String,
    country: String,
}

<span>fn</span> <span>city_name</span>(user: <span>&amp;</span><span>User</span>) -&gt; String {
    <span>let</span> User {city, country} <span>=</span> user;
    format<span>!</span>(<span>&#34;{}, {}&#34;</span>, city, country)
}
</code></pre></div><p>In JavaScript, or even TypeScript, this wouldn’t be a problem. We help ourselves to the fields we need and ignore the rest. But not Rust, which spits back at us:</p>
<pre><code>   Compiling playground v0.0.1 (/playground)
error[E0027]: pattern does not mention field `name`
 --&gt; src/lib.rs:8:9
  |
8 |     let User {city, country} = user;
  |         ^^^^^^^^^^^^^^^^^^^^ missing field `name`
</code></pre><p>The apparent solution is to add <code>name</code>, like this:</p>
<div><pre tabindex="0"><code data-lang="rust"><span>fn</span> <span>city_name</span>(user: <span>&amp;</span><span>User</span>) -&gt; String {
    <span>let</span> User {city, country, name} <span>=</span> user;
    format<span>!</span>(<span>&#34;{}, {}&#34;</span>, city, country)
}
</code></pre></div><p>The compiler accepts this, but begrudgingly. It compiles our code, but complains:</p>
<pre><code>warning: unused variable: `name`
 --&gt; src/lib.rs:8:30
  |
8 |     let User {city, country, name} = user;
  |                              ^^^^ help: try ignoring the field: `name: _`
  |
  = note: `#[warn(unused_variables)]` on by default
</code></pre><p>Helpfully, it tells us how to fix it: we can explicitly ignore the name field:</p>
<div><pre tabindex="0"><code data-lang="rust"><span>fn</span> <span>city_name</span>(user: <span>&amp;</span><span>User</span>) -&gt; String {
    <span>let</span> User {city, country, name: <span>_</span>} <span>=</span> user;
    format<span>!</span>(<span>&#34;{}, {}&#34;</span>, city, country)
}
</code></pre></div><p>To understand how this works, it helps to understand that each field in the destructuring expression serves two purposes. It tells the compiler the name of the field from <code>User</code> you want to extract from <code>user</code>, <em>and</em> it tells the compiler the local name you want to assign it to.</p>
<p>It happens to be good programming practice to use names consistently, so it’s often a good default to use the field names as local variables. Naming things is one of the <a href="https://martinfowler.com/bliki/TwoHardThings.html">two hard problems</a> in computer science, and here we get to outsource our variable naming to whomever wrote the data structure we’re using.</p>
<p>But it’s important to know that there’s nothing stopping us from renaming fields as part of the destructuring assignment, we just have to be a bit more explicit about it:</p>
<div><pre tabindex="0"><code data-lang="rust"><span>fn</span> <span>print_user</span>(user: <span>&amp;</span><span>User</span>) {
    <span>let</span> User {
        name: <span>fullname</span>, city: <span>metro</span>, country: <span>nation</span>
    } <span>=</span> user;
    println<span>!</span>(<span>&#34;User {} is from {}, {}&#34;</span>, fullname, metro, nation);
}
</code></pre></div><p>This works in TypeScript and modern JavaScript, too, by the way. It even happens to use the same syntax.</p>
<p>Returning to the compiler warning above, Rust complained about the unused <code>name</code> for the same reason it would complain about the unused variable <code>name</code> in this code:</p>
<div><pre tabindex="0"><code data-lang="rust"><span>fn</span> <span>main</span>() {
    <span>let</span> name <span>=</span> <span>&#34;Tim&#34;</span>;
}
</code></pre></div><p>If we instead assign the value to <code>_</code>, it doesn’t complain, even though the assignment is equally pointless:</p>
<div><pre tabindex="0"><code data-lang="rust"><span>fn</span> <span>main</span>() {
    <span>let</span> _ <span>=</span> <span>&#34;Tim&#34;</span>;
}
</code></pre></div><p>When destructuring, <code>_</code> acts as a sort of black hole. We can match it to any value, and we can’t get the value back. Another place we see this is destructuring tuples where we only care about some of the values:</p>
<div><pre tabindex="0"><code data-lang="rust"><span>fn</span> <span>main</span>() {
    <span>let</span> my_tuple <span>=</span> (<span>4</span>, <span>&#34;foo&#34;</span>, <span>false</span>);
    
    <span>let</span> (num, _, truthy) <span>=</span> my_tuple;
    
    println<span>!</span>(<span>&#34;{} {}&#34;</span>, num, truthy);
}
</code></pre></div><p>You often see something similar in idiomatic JavaScript, something like this:</p>
<div><pre tabindex="0"><code data-lang="javascript"><span>let</span> [<span>_</span>, <span>triggerRerender</span>] <span>=</span> <span>React</span>.<span>useState</span>();
</code></pre></div><p>The intention that the programmer is signaling to the reader of their code is the same, but in JavaScript the <code>_</code> is actually just a variable name that programmers <em>treat</em> like a black hole. You could read the value assigned to it if you wanted to (though build-time tools may give it special meaning and complain if you try reading it). In Rust, <code>_</code> is part of the language, not a variable. If you assign a value to it, it really does nothing.</p>
<p>So to return to our code, when we say this:</p>
<div><pre tabindex="0"><code data-lang="rust"><span>fn</span> <span>city_name</span>(user: <span>&amp;</span><span>User</span>) -&gt; String {
    <span>let</span> User {city, country, name: <span>_</span>} <span>=</span> user;
    format<span>!</span>(<span>&#34;{}, {}&#34;</span>, city, country)
}
</code></pre></div><p>What we mean is “assign <code>user.city</code> to the variable <code>city</code>, assign <code>user.country</code> to the variable <code>country</code>, and do nothing with <code>user.name</code>”.</p>
<p>I took a detour here because I wanted to show you <code>_</code>, which is a fundamental concept that will come up again in a future post when we look at pattern matching. But in the case of destructuring fields, there’s actually a better way. In fact, if we had read the full compiler error (which I snipped above), it would have helpfully guided us in the right direction:</p>
<pre><code>   Compiling playground v0.0.1 (/playground)
error[E0027]: pattern does not mention field `name`
 --&gt; src/lib.rs:8:9
  |
8 |     let User {city, country} = user;
  |         ^^^^^^^^^^^^^^^^^^^^ missing field `name`
  |
help: include the missing field in the pattern
  |
8 |     let User {city, country, name } = user;
  |                            ~~~~~~~~
help: if you don&#39;t care about this missing field, you can explicitly ignore it
  |
8 |     let User {city, country, .. } = user;
  |                            ~~~~~~

For more information about this error, try `rustc --explain E0027`.
error: could not compile `playground` due to previous error
</code></pre><p>“help: if you don’t care about this missing field” - that sure sounds like us. Let’s try it:</p>
<div><pre tabindex="0"><code data-lang="rust"><span>struct</span> <span>User</span> {
    name: String,
    city: String,
    country: String,
}

<span>fn</span> <span>city_name</span>(user: <span>&amp;</span><span>User</span>) -&gt; String {
    <span>let</span> User {city, country, ..} <span>=</span> user;
    format<span>!</span>(<span>&#34;{}, {}&#34;</span>, city, country)
}
</code></pre></div><h2 id="rusts-philosophy">Rust’s philosophy</h2>
<p>So, it turns out the compiler was fussing over a couple missing dots!</p>
<p>This may seem tedious. In the same situation, JavaScript knew what we meant. Even TypeScript, which is basically JavaScript plus nitpicking, doesn’t nitpick it. The Rust compiler was smart enough to suggest a change that would fix the problem, why does it choose instead to berate us?</p>
<p>This question hits on the general character of Rust. Anyone who sets out to create a programming language has to make decisions between assuming intent and requiring explicit, disambiguous instructions from the programmer. Rust’s general approach is to err on the side of requiring explicitness. This means that beginner Rust developers will spend a fair bit time trying to appease the compiler in ways they’re not used to, regardless of how smart or experienced they are in other languages.</p>
<p>By forcing you to be explicit, Rust forces you to be deliberate and thoughtful in your code. Treat it like a posture training device: instead of resenting it, use it to develop good habits until the nags become infrequent. Over time, I think you’ll find that it makes you a more thoughtful programmer, even when you’re using languages other than Rust.</p>
</div></div>
  </body>
</html>
