<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://verse.systems/blog/post/2024-03-09-using-llms-to-generate-fuzz-generators/">Original</a>
    <h1>Using LLMs to Generate Fuzzers</h1>
    
    <div id="readability-page-1" class="page"><div role="main"><div><div><article role="main"><p>LLMs seem surprisingly good at many things. So much so that not a week
goes by without someone coming up with yet another use-case for this
technology, often to solve tasks quickly that traditionally took a non-trivial
amount of human work to complete.</p><p>Today’s example was <a href="https://engineering.nyu.edu/faculty/brendan-dolan-gavitt">Brendan Dolan-Gavitt</a>’s remarkable <a href="https://twitter.com/moyix/status/1765967602982027550">experiment</a>
using <a href="https://claude.ai">Claude</a> to generate a <a href="https://en.wikipedia.org/wiki/Fuzzing">fuzzer</a> for some GIF parsing code. The entire
thread is worth a read if you’re curious; however, Brendan gives Claude the
C code for the GIF parser and asks Claude to
generate the Python implementation for a fuzzer to generate GIF-like input
to fuzz the given GIF parser. Claude dutifully complies and the
resulting fuzzer finds a range of vulnerabilities. Brendan since <a href="https://twitter.com/moyix/status/1766225423841550381">repeated</a>
that success with a less well-known format, VRML files.</p><p>This success is at first glance very pleasing: writing a good fuzzer for a
non-trivial input format is time-consuming. Being able to automate this
process is therefore super appealing. Brendan’s success here might even
seem surprising. It certainly was to me when I first saw his tweet. Having
thought about it, with the benefit of hindsight, I’ve started to understand
why Brendan might have expected it to work in the first place.</p><h2 id="why-might-this-work">Why Might This Work?</h2><p>The reason I found Brendan’s success surprising is because I hold the
opinion that LLMs are not a great way to do precise reasoning about code.
Indeed, many people have tried using LLMs to find bugs directly in code,
by crafting a prompt with instructions telling the LLM what to do and
including the code within the prompt.
In asking an LLM to look at a piece of code and spot
bugs in it, one is essentially asking the LLM to perform <a href="https://en.wikipedia.org/wiki/Static_program_analysis">static analysis</a>.</p><p>I hold the opinion that we shouldn’t expect LLMs to be very good at static analysis. After
all, they are stochastic machines trained to produce the output that
is statistically most likely to come next given the LLM’s training data.
In other words, to generate output statistically “close to” the expected
output. This is why they are of course known to be imprecise, or to
<a href="https://en.wikipedia.org/wiki/Hallucination_(artificial_intelligence)">hallucinate</a> and so on. But effective static analysis requires <em>precision</em> above
all else: if the static analyser tells you there is a bug in the code,
it has to be very sure the bug is real. Otherwise, developer time drowns in
a sea of <a href="https://owasp.org/www-community/controls/Static_Code_Analysis#:~:text=Limitations-,False%20Positives,application%20from%20input%20to%20output.">false bug reports</a>.</p><p>But, in contrast to static analysis, fuzzing is very different. Fuzzing
is an inherently stochastic process. Quoting from <a href="https://en.wikipedia.org/wiki/Fuzzing">Wikipedia</a>:</p><blockquote><p>An effective fuzzer generates semi-valid inputs that are “valid enough”
in that they are not directly rejected by the parser, but do create
unexpected behaviors deeper in the program and are “invalid enough”
to expose corner cases that have not been properly dealt with.</p></blockquote><p>In other words, a fuzzer should generate inputs that are “close to” what is
expected by the program. Therefore, we might expect LLMs to be a better fit
at generating a “close enough” fuzzer for a given program.</p><h2 id="fuzzing-an-unknown-input-format">Fuzzing an Unknown Input Format</h2><p>One thing (to quote Carrie Bradshaw) I couldn’t help but wonder, however,
about Brendan’s experiments was to what degree Claude performed well because
both GIF and VRML are known input formats. We should expect the LLM to
“know” about both formats, given that its training data likely contained
much text about each input format, as well as lots of parsing and serialisation
code for both formats, too (although considerably more for GIF than VRML).</p><p>I therefore decided to test Claude on an unknown input format. Fortunately
for me I had one lying around. 8 years ago, in 2016, when I first started
<a href="https://blog.plover.com/2016-07-18-software-engineering-teaching/">teaching</a> at Melbourne, I set my students an assignment in which I created
a fictitious input format and asked them to write fuzzers for this input
format.</p><p>To make the assignment challenging, the input format was protected by a
<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC32</a> checksum.
Specifically, each input is a <em>packet</em>, whose structure looks like the
following and includes a (useless) sequence number, a two-byte length
field, and a data payload (whose maximum size is 4096 bytes):</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>/** Raw packet format:
</span></span></span><span><span><span> *
</span></span></span><span><span><span> *        +---------+----------+-----+-------------------+
</span></span></span><span><span><span> *        |  crc32  | seq_num  | len |       data        |
</span></span></span><span><span><span> *        +---------+----------+-----+-------------------+
</span></span></span><span><span><span> * bytes  0  ...  3  4  ...  7  8  9  10   ...   len+10  
</span></span></span><span><span><span> */</span>
</span></span></code></pre></div><p>The data payload consisted of a sequence of instructions (each one byte
in size) for a simple
arithmetic <a href="https://en.wikipedia.org/wiki/Stack_machine">stack machine</a> that operated over a stack of signed integers (a bit like
the venerable <a href="https://en.wikipedia.org/wiki/Dc_(computer_program)">UNIX <code>dc</code> utility</a>. The machine instructions
included ones to push small integers (in the range [0,9]) onto the stack;
to pop the stack; to <code>ADD</code>, <code>SUBTRACT</code>, <code>MULTIPLY</code> or <code>DIVIDE</code> the two items on
the top of the stack, popping them from the stack and pushing the result;
as well as operations to <code>READ</code> and <code>WRITE</code> to arbitrary
positions in the stack (identified using the top-of-stack operand as an offset
downwards from the top of the stack).</p><p>I wrote a parser for the input format and an interpreter for the stack
machine language.
The <a href="https://www.dropbox.com/scl/fi/f4ixkhypnm0g9e0n42nfz/for_brendan.tar.gz?rlkey=0730l3mkoosn6cwo67vzazbz8&amp;dl=0">C code</a> that implements this functionality is under 400 <a href="https://en.wikipedia.org/wiki/Source_lines_of_code">SLOC</a>.
I seeded a range of vulnerabilities in this code, namely:</p><ul><li>A <a href="https://en.wikipedia.org/wiki/Heartbleed">Heartbleed</a> style out-of-bounds
<code>memcpy</code> in the parsing code (blindly trusting the input data’s length field to use as the
length to pass to <code>memcpy</code>, even though the source and destination buffers’ sizes are both 4096 bytes while the maximum 2-byte length value is 65535);</li><li>Unchecked division-by-zero when the second argument to the <code>DIVIDE</code>
instruction was zero;</li><li>Unchecked signed overflow when stack operands grow too large due to
repeated application of arithmetic operations;</li><li>Out-of-bounds read due to unchecked offset in the implementation of the
<code>READ</code> instruction;</li><li>Out-of-bounds write similarly in the <code>WRITE</code> instruction.</li></ul><p>I <a href="https://gist.github.com/tobycmurray/195dc742a82c9bea8e02928229b4692f">asked</a> Claude Sonnet (the default, free Claude model) to generate a Python fuzzer
for the C code. The prompt I crafted gave Claude some hints about the
code structure, telling it that there was an outer parser implemented by
the <code>parse_packet</code> function, followed by an interpreter implemented by the
<code>execute</code> function. My prompt (linked above) included the relevant bits of
the code along with these explanations and the request to the model to
generate the Python fuzzer.</p><p>Claude generated a pretty useful fuzzer, although I had to ask it to fix
a type error in the code it generated (which it did first try after I gave
it the error message).</p><p>The resulting Python fuzzer code is below:</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>import</span> <span>random</span>
</span></span><span><span><span>import</span> <span>struct</span>
</span></span><span><span><span>import</span> <span>sys</span>
</span></span><span><span><span>import</span> <span>binascii</span>
</span></span><span><span>
</span></span><span><span><span># Constants</span>
</span></span><span><span><span>MAX_DATA_LEN</span> <span>=</span> <span>0xfff</span>
</span></span><span><span><span>PACKET_LEN</span> <span>=</span> <span>MAX_DATA_LEN</span> <span>+</span> <span>10</span>
</span></span><span><span><span>CRC_OFFSET</span> <span>=</span> <span>0</span>
</span></span><span><span><span>SEQ_NUM_OFFSET</span> <span>=</span> <span>4</span>
</span></span><span><span><span>LEN_OFFSET</span> <span>=</span> <span>8</span>
</span></span><span><span><span>DATA_OFFSET</span> <span>=</span> <span>10</span>
</span></span><span><span>
</span></span><span><span><span># Instructions</span>
</span></span><span><span><span>INSTRUCTION_ADD</span> <span>=</span> <span>ord</span>(<span>&#39;a&#39;</span>)
</span></span><span><span><span>INSTRUCTION_SUBTRACT</span> <span>=</span> <span>ord</span>(<span>&#39;s&#39;</span>)
</span></span><span><span><span>INSTRUCTION_READ</span> <span>=</span> <span>ord</span>(<span>&#39;r&#39;</span>)
</span></span><span><span><span>INSTRUCTION_MULT</span> <span>=</span> <span>ord</span>(<span>&#39;m&#39;</span>)
</span></span><span><span><span>INSTRUCTION_DIVIDE</span> <span>=</span> <span>ord</span>(<span>&#39;d&#39;</span>)
</span></span><span><span><span>INSTRUCTION_POP</span> <span>=</span> <span>ord</span>(<span>&#39;p&#39;</span>)
</span></span><span><span><span>INSTRUCTION_WRITE</span> <span>=</span> <span>ord</span>(<span>&#39;w&#39;</span>)
</span></span><span><span><span>INSTRUCTIONS</span> <span>=</span> [<span>INSTRUCTION_ADD</span>, <span>INSTRUCTION_SUBTRACT</span>, <span>INSTRUCTION_READ</span>, 
</span></span><span><span><span>INSTRUCTION_MULT</span>,
</span></span><span><span>                <span>INSTRUCTION_DIVIDE</span>, <span>INSTRUCTION_POP</span>, <span>INSTRUCTION_WRITE</span>]
</span></span><span><span>
</span></span><span><span><span># Generate packets</span>
</span></span><span><span><span>for</span> <span>_</span> <span>in</span> <span>range</span>(<span>10000</span>):
</span></span><span><span>    <span># Generate packet data</span>
</span></span><span><span>    <span>data_len</span> <span>=</span> <span>random</span><span>.</span><span>randint</span>(<span>0</span>, <span>MAX_DATA_LEN</span>)
</span></span><span><span>    <span>data</span> <span>=</span> <span>bytearray</span>(<span>random</span><span>.</span><span>randrange</span>(<span>256</span>) <span>for</span> <span>_</span> <span>in</span> <span>range</span>(<span>data_len</span>))
</span></span><span><span>    <span>padding</span> <span>=</span> [<span>random</span><span>.</span><span>choice</span>(<span>INSTRUCTIONS</span> <span>+</span> <span>list</span>(<span>range</span>(<span>ord</span>(<span>&#39;0&#39;</span>), <span>ord</span>(<span>&#39;9&#39;</span>) <span>+</span> <span>1</span>))) <span>for</span> <span>_</span> <span>in</span> <span>range</span>(<span>MAX_DATA_LEN</span> <span>-</span> <span>data_len</span>)]
</span></span><span><span>    <span>data</span> <span>+=</span> <span>bytes</span>(<span>padding</span>)
</span></span><span><span>
</span></span><span><span>    <span># Generate sequence number</span>
</span></span><span><span>    <span>seq_num</span> <span>=</span> <span>random</span><span>.</span><span>getrandbits</span>(<span>32</span>)
</span></span><span><span>
</span></span><span><span>    <span># Construct packet</span>
</span></span><span><span>    <span>packet</span> <span>=</span> <span>bytearray</span>(<span>PACKET_LEN</span>)
</span></span><span><span>    <span>struct</span><span>.</span><span>pack_into</span>(<span>&#34;&gt;I&#34;</span>, <span>packet</span>, <span>CRC_OFFSET</span>, <span>0</span>)  <span># Placeholder for CRC32</span>
</span></span><span><span>    <span>struct</span><span>.</span><span>pack_into</span>(<span>&#34;&gt;I&#34;</span>, <span>packet</span>, <span>SEQ_NUM_OFFSET</span>, <span>seq_num</span>)
</span></span><span><span>    <span>struct</span><span>.</span><span>pack_into</span>(<span>&#34;&gt;H&#34;</span>, <span>packet</span>, <span>LEN_OFFSET</span>, <span>data_len</span>)
</span></span><span><span>    <span>packet</span>[<span>DATA_OFFSET</span>:] <span>=</span> <span>data</span>
</span></span><span><span>
</span></span><span><span>    <span># Calculate CRC32 and update packet</span>
</span></span><span><span>    <span>crc32</span> <span>=</span> <span>binascii</span><span>.</span><span>crc32</span>(<span>packet</span>[<span>4</span>:])
</span></span><span><span>    <span>struct</span><span>.</span><span>pack_into</span>(<span>&#34;&gt;I&#34;</span>, <span>packet</span>, <span>CRC_OFFSET</span>, <span>crc32</span>)
</span></span><span><span>
</span></span><span><span>    <span># Write packet to stdout</span>
</span></span><span><span>    <span>sys</span><span>.</span><span>stdout</span><span>.</span><span>buffer</span><span>.</span><span>write</span>(<span>packet</span>)
</span></span></code></pre></div><p>I compiled the C program with Clang’s <a href="https://clang.llvm.org/docs/AddressSanitizer.html">Address Sanitizer</a> and <a href="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html">Undefined Behaviour Sanitizer</a> turned on.
Running the Python code to produce inputs for the C program, and running
the compiled C program against the inputs produced, I found that Claude’s
fuzzer is able to trigger the out-of-bounds read and write bugs only.</p><p>However, the fuzzer is unable to trigger the other bugs. I shared this
code with Brendan who also played with it and got <a href="https://twitter.com/moyix/status/1766311605413818826">similar results</a>.</p><p>What should we make of this?</p><h2 id="understanding-the-results">Understanding the Results</h2><p>Why is Claude’s fuzzer unable to find the other bugs? If we look at the
fuzzing code, the answer is pretty clear. Here is the relevant snippet:</p><div><pre tabindex="0"><code data-lang="python"><span><span>    <span># Generate packet data</span>
</span></span><span><span>    <span>data_len</span> <span>=</span> <span>random</span><span>.</span><span>randint</span>(<span>0</span>, <span>MAX_DATA_LEN</span>)
</span></span><span><span>    <span>data</span> <span>=</span> <span>bytearray</span>(<span>random</span><span>.</span><span>randrange</span>(<span>256</span>) <span>for</span> <span>_</span> <span>in</span> <span>range</span>(<span>data_len</span>))
</span></span><span><span>    <span>padding</span> <span>=</span> [<span>random</span><span>.</span><span>choice</span>(<span>INSTRUCTIONS</span> <span>+</span> <span>list</span>(<span>range</span>(<span>ord</span>(<span>&#39;0&#39;</span>), <span>ord</span>(<span>&#39;9&#39;</span>) <span>+</span> <span>1</span>))) <span>for</span> <span>_</span> <span>in</span> <span>range</span>(<span>MAX_DATA_LEN</span> <span>-</span> <span>data_len</span>)]
</span></span><span><span>    <span>data</span> <span>+=</span> <span>bytes</span>(<span>padding</span>)
</span></span></code></pre></div><p>Notice how the packet data it generates is totally random bytes. It then
generates what it calls <code>padding</code> which contains entirely valid instructions.
So of course the correctly-formatted
instruction data is hidden behind a mass of noise.</p><p>Instead the data and padding should be calculated e.g. like this:</p><div><pre tabindex="0"><code data-lang="python"><span><span>    <span>data</span> <span>=</span> [<span>random</span><span>.</span><span>choice</span>(<span>INSTRUCTIONS</span> <span>+</span> <span>list</span>(<span>range</span>(<span>ord</span>(<span>&#39;0&#39;</span>), <span>ord</span>(<span>&#39;9&#39;</span>) <span>+</span> <span>1</span>))) <span>for</span> <span>_</span> <span>in</span> <span>range</span>(<span>data_len</span>)]
</span></span><span><span>    <span>padding</span> <span>=</span> <span>bytearray</span>(<span>random</span><span>.</span><span>randrange</span>(<span>256</span>) <span>for</span> <span>_</span> <span>in</span> <span>range</span>(<span>MAX_DATA_LEN</span> <span>-</span> <span>data_len</span>))
</span></span></code></pre></div><p>(With this change, the fuzzer can trigger the division-by-zero. However,
the other bugs remain out of reach because the out-of-bounds read and write
are far too easy to trigger, making the odds of being able to trigger the
others without triggering one of those incredibly small. This is not
the fuzzer’s fault, per se. Although is an inherent limitation with fuzzing
in this manner.)</p><p>Also, Claude’s fuzzer always correctly reports the packet length in the
<code>len</code> field:</p><div><pre tabindex="0"><code data-lang="python"><span><span>    <span>struct</span><span>.</span><span>pack_into</span>(<span>&#34;&gt;H&#34;</span>, <span>packet</span>, <span>LEN_OFFSET</span>, <span>data_len</span>)
</span></span></code></pre></div><p>This means the Heartbleed style vulnerability in the parser can never
be triggered (and also means the correctly formatted instruction data
is ignored by the interpreter, meaning that that correctly formatted
input has no ability to trigger bugs in the code).</p><h2 id="so-what-about-static-analysis">So What About Static Analysis?</h2><p>Of course, like me I’m sure you’re wondering by now whether we might’ve
been better off asking Claude to look for vulnerabilities directly in the
code (i.e., to perform the kind of static analysis I referred to above).</p><p>Note: doing so isn’t very scientific. We are comparing a method
(fuzzing) in which false alarms are impossible (and therefore all alerts
are useful information) to another (static analysis by LLM) in which
it is very difficult to trust the generated bug alerts. So we are hardly
comparing apples with apples. But let’s proceed
anyway.</p><p>When I asked Claude to look for vulnerabilities in this code it found:</p><ul><li>The Heartbleed-style buffer overflow in the parsing code;</li><li>The division-by-zero in the <code>DIVIDE</code> instruction</li><li>Out-of-bounds memory read in the <code>READ</code> instruction (due to arithmetic</li><li>Uninitialised stack in the instruction execution function <code>execute</code></li></ul><p>So it found 3 out of 5 vulnerabilities and one additional one. Whether
you consider the uninitialised stack a real vulnerability is debatable.
It matters only in the presence of the out-of-bounds read vulnerability
(because without that, the uninitialised portions of the stack can never
be accessed). On balance I therefore consider the uninitialised stack
a false positive.</p><p>Claude also coached me on how I should fix these vulnerabilities.</p><h2 id="updated-sun-10-mar-2024-141551-aedt-a-promising-way-forward">[Updated: Sun 10 Mar 2024 14:15:51 AEDT] A Promising Way Forward?</h2><p>A little over 12 hours after I wrote this post, it’s worth asking: what did we learn?</p><ol><li>LLMs seem interestingly good at being able to analyse code and write a
fuzzer to generate “close enough” inputs to exercise that code and find
bugs. Though they have some limitations.</li><li>LLMs can do static analysis but suffer from false positives and so on.</li></ol><p>This <a href="https://twitter.com/thuanpv_/status/1766593960959476182">suggests</a>, as
my colleague <a href="https://thuanpv.github.io/">Thuan Pham</a> notes, that perhaps
we should consider combining the two approaches.</p><p>Specifically, we could consider performing the following steps:</p><ol><li>Ask the LLM to identify vulnerabilities in the code (i.e., to
statically analyse it)</li><li>For each vulnerability the LLM identifies, ask it to generate a
<a href="https://mboehme.github.io/paper/CCS17.pdf">directed</a> fuzzer that
generates inputs to try to trigger (just) that vulnerability.</li></ol><p>A quick experiment with Claude suggests this approach could be promising
(with some prompting, Claude was able to generate a program to generate an
input to trigger the Heartbleed-style vulnerability mentioned above).
But of course further work is needed to validate this approach and work out what
challenges need to be overcome to make it practical (if indeed it can be
made practical).</p><p>That’s certainly more work than can be squeezed into the odd free moment on
a heatwave weekend.</p><h2 id="conclusion">Conclusion</h2><p>What are we to make of this, above any other unscientific experiment with
an LLM?</p><p>In terms of fuzzing,
LLMs have been used to generate <a href="https://arxiv.org/abs/2307.12469">fuzz drivers</a> and there is much interest in that topic at present (which is distinct
from using them to generate stand-alone fuzzers, the topic of this blog post).
Indeed, <a href="https://www.darpa.mil/">DARPA</a> sees so much potential in using LLMs for vulnerability discovery,
exploitation and patching that last year
it decided to <a href="https://aicyberchallenge.com/">revisit</a> its 2016 Cyber Grand Challenge, launching the AIxCC competition, to understand the impact of LLM-related technology for these tasks.</p><p>With all this in mind, I’m curious to see whether any of the AIxCC
competitors attempt to automate vulnerability discovery by fuzz generator
generation (i.e., the topic of this post), <strong>[Updated: Sun 10 Mar 2024 14:15:51 AEDT to add]</strong> whether directed or not.
We should certainly expect many to try fuzz-driver generation
and static-analysis via LLM.</p><p>Like so many other experiments with LLMs, this one served to simultaneously
surprise and disappoint, <strong>[Updated: Sun 10 Mar 2024 14:15:51 AEDT to add]</strong> though I remain optimistic about the value of exploring this approach further.</p><p>I’d love to hear your thoughts.</p><p>In the meantime, much thanks of course
to Brendan whose work inspired this post.</p></article></div></div></div></div>
  </body>
</html>
