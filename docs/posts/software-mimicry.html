<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.hillelwayne.com/post/software-mimicry/">Original</a>
    <h1>Software Mimicry</h1>
    
    <div id="readability-page-1" class="page"><article lang="en">
    

    
    

    <div>
  

<p><strong>Mimicry</strong> is when software X reimplements at a higher level a core feature of software Y. The produced <em>facsimile</em> has some, but not all, of the same properties, enough to “look like” it’s the same thing but missing many of the nuances. This exists in every kind of software. One language can mimic another, a library can mimic a language, a database engine can mimic a product, etc.</p>

<h3 id="example">Example</h3>

<p><em>Design Patterns</em> introduces the strategy pattern to apply multiple algorithms to the same call:</p>

<blockquote>
<p>INTENT: Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.  […] a Strategy object encapsulates an algorithm.</p>
</blockquote>

<p>In <a href="https://norvig.com/design-patterns/">Design Patterns in Dynamic Programming</a>, Peter Norvig notes that strategies are just trivially replacable with higher-order functions (HOFs). Compare the algorithm “select for all of the even numbers of a list” for a “<abbr title="Gang of Four (the authors of Design Patterns)">GoF</abbr>
 language”, as compared to how you’d do with HOFs:</p>

<pre><code>// GoF pseudocode

abstract class Strategy[T, U] {
  public execute(t: T): U;
}

class IsEven inherits Strategy[Int, Bool] {
  public execute(i: Int): Bool {return i % 2;}
}

def filter(pred: Strategy[T, Bool], l: List[T]): List[T] {
  // ...
}

filter(IsEven(), [1,2,3]) -&gt; 2
</code></pre>

<pre><code>// JavaScript
[1,2, 3].filter((x) =&gt; x % 2 == 0) 
</code></pre>

<p>For this reason, design patterns are often (erroneously) called “missing language features”. I think it’s more interesting to think of the GoF-language as <em>mimicking</em> HOFs with the strategy pattern <em>facsimile</em>. The strategy pattern reimplements HOFs as a code-level idiom.</p>

<h3 id="benefits-and-drawbacks">Benefits and Drawbacks</h3>

<p>The obvious drawback is that the facsimile is considerably more verbose; in our case, a hundred characters to fifteen. It’s also fragile, as it only works for unary functions. If we wanted to pass in a function with two inputs, like <code>Add</code>, we’d need to define a new strategy.</p>

<p>The biggest drawback is that the facsimile doesn’t “fit” with the rest of the language. Program features are supposed to complement each other. In the JavaScript example, I used an HOF along with an anonymous function. The two features work together and with the broader language ecosystem. In contrast, our strategy facsimile is a custom class. It won’t synergize with anything else in the language, and it won’t be understood by third party tooling.</p>

<p>Surprisingly, there are also a couple of advantages to mimicry. There are many possible ways to design a feature. JavaScript, Haskell, and F# all do HOFs in slightly different ways, and using those languages fixes the way you use HOFs. Mimicking a feature at a user level lets us use several different designs in the same program. For example, in addition to <code>Strategy</code>, I might define <code>StrategyWithSetup</code>:</p>

<pre><code>class StrategyWithSetup inherits Strategy[T, U] {
  public do(t: T): U {
    setup();
    execute(t);
    teardown();
  }

  private setup, teardown; // blah blah blah
}
</code></pre>

<p>The biggest advantage is that you still have the <em>rest</em> of the mimicking language. If the GoF language does 99% of what you need, and you just want HOFs for one specific case, it’s better to create a facsimile than to switch everything over to Haskell. So mimicry can be a pragmatic choice to make a tool more “right for the job”.</p>

<h2 id="mimicry-in-the-wild">Mimicry in the Wild</h2>

<p>The most famous and notorious case of mimicry is Lisp macros. Lisp macros can extend the language with new constructs, so any language feature can be reimplemented as a lisp macro. This is why Paul Graham <a href="http://www.paulgraham.com/avg.html">calls Lisp the most powerful language</a>:</p>

<blockquote>
<p>By induction, the only programmers in a position to see all the differences in power between the various languages are those who understand the most powerful one. (This is probably what Eric Raymond meant about Lisp making you a better programmer.) You can’t trust the opinions of the others, because of the Blub paradox: they’re satisfied with whatever language they happen to use, because it dictates the way they think about programs.</p>

<p>The five languages that Eric Raymond recommends to hackers fall at various points on the power continuum. […] I think Lisp is at the top. And to support this claim I’ll tell you about one of the things I find missing when I look at the other four languages. How can you get anything done in them, I think, without macros?</p>
</blockquote>

<p>This also leads to the <a href="http://www.winestockwebdesign.com/Essays/Lisp_Curse.html">Lisp Curse</a>: since everybody can make their own facsimile of a given feature, there’s no agreement in the broader community of which facsimile to get behind, so no way to target tooling or build an ecosystem.</p>

<p>Mimicry appears in other languages, too: static-typed languages can mimic dynamic languages with a <code>Dyn</code> type, leading to the (misleading) meme <a href="https://existentialtype.wordpress.com/2011/03/19/dynamic-languages-are-static-languages/">“dynamic languages have just one type”</a>. Before Go added generics, people would mimic generics with <code>interface{}</code>, code generators, and <a href="https://www.reddit.com/r/rust/comments/5penft/comment/dcsq64p/?context=3">unicode trickery</a>. JML creates a facsimile of language-level contracts with structured comments.  <a href="http://www.appliedscience.studio/articles/array-programming-for-clojurists.html">This Clojure article</a> implements facsimiles of several APL features without understanding <a href="https://twitter.com/hillelogram/status/1343984109241167873">how they actually work</a>. And, of course, there’s <a href="https://en.wikipedia.org/wiki/Greenspun%27s_tenth_rule">Greenspun’s Tenth Rule</a>.</p>

<p>Mimicry also appears in higher-level software. Most IDEs have a “vim mode” which mimics most of vim’s normal commands and some configuration, but doesn’t support things like first-class macros. People use Postgres json fields to mimic NoSQL paradigms. Whenever I change email software I have to make facsimiles of all the features the new software has that the old one doesn’t.</p>

<h2 id="similar-ideas">Similar Ideas</h2>

<p>“Representation” is similar to mimicry, except it’s about encoding a data structure in primitives that aren’t well-suited to it. Examples would be representing a tree in SQL tables, representing a matrix with nested arrays, or representing a graph in json.</p>

<p>The opposite of mimicry would be “reification”, where you turn an idiom into a software feature. My favorite example is units of measure. Lots of languages have libraries or comment annotations to represent units of measure, but only two languages, F# and <a href="https://www.hillelwayne.com/post/frink/">Frink</a>, turn it into an actual language feature. Another example: Rust reifies the borrow checker, which <a href="https://news.ycombinator.com/item?id=15715524">was inspired</a> by <a href="https://www.cs.umd.edu/~mwh/papers/ismm.pdf">Cyclone</a>, a dialect of C.</p>

<h2 id="miscellaneous-thoughts">Miscellaneous Thoughts</h2>

<p>So some other things this made me think about, but haven’t fully developed:</p>

<ul>
<li>Often people will use mimicry to call something uninteresting: “what’s the big deal about loops? That’s just <code>if</code> and <code>goto</code>.“. This is rightly called out when it’s someone else doing it to us. Mimicry often involves facsimiling the most obvious features of a language but not the nuances. Which ties back to the idea that languages are holistic, as are mimics.</li>
<li>On the other hand, lots of people try Haskell because they got a taste of pure typed FP from language facsimiles. Mimicry can be a form of idea diffusion.</li>
<li>Facsimiles can be <em>exported</em>: Someone who knows X reimplements a feature in language Y. They can also be <em>imported</em>: Someone who knows Y implements a feature they saw in language X. The difference is that in the former case, they’re most familiar with the thing they’re mimicking, while in the latter case they’re most familiar with the mimicking context. Do these lead to observably different facsimiles?</li>
<li>I regularly mimic relational databases in Excel spreadsheets and feel no shame whatsoever.</li>
</ul>

<hr/>

<p>Admittedly half the point of this post was to try out this format for sharing terms of I have. I often come up with terms for things I see a lot that I think might be useful for other people to have, too. Overall I think this particular format worked out, so I’ll probably do more terms in the future.</p>

<p><em>Thanks to <a href="https://twitter.com/PredragGruevski">Predrag Gruevski</a>, <a href="https://twitter.com/wilton_quinn">Quinn Wilton</a>, and <a href="https://lars.hupel.info/">Lars Hupel</a> for feedback.</em></p>

<p><em>I shared an early version of this post on my <a href="https://buttondown.email/hillelwayne/">weekly newsletter</a> where I announce new blog posts and write additional essays. If you enjoyed this, <a href="https://buttondown.email/hillelwayne/">why not subscribe</a>?</em></p>

</div>

    



  </article></div>
  </body>
</html>
