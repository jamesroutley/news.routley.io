<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://skills.sh">Original</a>
    <h1>Show HN: Agent Skills Leaderboard</h1>
    
    <div id="readability-page-1" class="page"><p>DISCLOSURE: If you buy through affiliate links, I may earn a small commission. <a href="https://hamy.xyz/blog/disclosures">(disclosures)</a></p><div><p>I went into my batch at <a href="https://www.recurse.com/scout/click?t=afef2b4f097974aa990e8c4e8ae42a60">Recurse Center</a> wanting to <a href="https://hamy.xyz/blog/2026-01_recurse-center-statement">learn how to build video games</a>. So it&#39;s probably not a big surprise that my first big project is... a video game.</p>
<p>I built a simple clicker game in C# using Raylib and in the rest of this post will walk through what it is and how it&#39;s built.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/4fgjCxQ-ZKw?si=xcFbizaARIkXaMWC" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
<h2 id="simple-clicker-game">Simple Clicker Game</h2>
<p><a href="https://github.com/SIRHAMY/simple-clicker-game-raylib-cs">Simple Clicker Game</a> is a simple clicker game. My goal was to learn the basics of game loops, rendering, and publishing a game. So its feature set is intentionally minimal so I could focus on the core systems without getting caught up in feature complexity / polish.</p>
<p>Features:</p>
<ul>
<li><a href="#clicker-game">Clicker</a> - You click, number goes up</li>
<li><a href="#upgrades">Upgrades</a> - Click power, passive income, multipliers</li>
<li><a href="#save-games">Save games</a> - Saves progress as you go</li>
<li><a href="#cross-platform-execution">Runs across platform</a> - verified on Fedora Linux and Mac ARM but theoretically works on Windows and Intel Macs</li>
</ul>
<p>You can see a demo of the game in the video embedded above or play it yourself / look at the code at the <a href="https://github.com/SIRHAMY/simple-clicker-game-raylib-cs">GitHub repo</a>. (There will be links to various code implementations scattered in the following sections).</p>
<h2 id="game-engine-why-raylib">Game Engine - Why Raylib?</h2>
<p>I&#39;ve had a few false starts into game development before - typically choosing something heavyweight like Unity, Godot, and Unreal. Those all led me to rabbitholing on 3D and their specific flavor of doing things - models, lighting, collisions, automation, etc.</p>
<p>During my time at Recurse Center I&#39;m trying to <a href="https://hamy.xyz/blog/2026-01_recurse-center-statement">learn rapidly across several interests</a> so figured a bunch of small projects would suit me better than one big project which may never see the light of day. This also aligns with my principles around <a href="https://hamy.xyz/notes/small-batches">atomic bets / batches</a> so feels better for me.</p>
<p>I ended up narrowing my engine selection to those that were lightweight, well supported, and in a language I was excited to use - mostly C# and TS. This led me to a few good options - Raylib, Phaser, and Monogame.</p>
<p>I ended up choosing Raylib as it was very lightweight and seemed like it would do what I wanted while getting out of the way. Plus there are bindings for it in a number of languages so felt like these skills / context would be transferable if I wanted to try another language.</p>
<h2 id="clicker-game">Clicker Game</h2>
<p>The <a href="https://github.com/SIRHAMY/simple-clicker-game-raylib-cs/blob/8f6c9623e21a55286c5221afd66b1d60f1dc0409/SimpleClickerGame/Program.cs#L82">main game loop is simple</a> (and I&#39;m told you should strive to keep it simple even for large games):</p>
<ul>
<li><strong>Inputs</strong> - Gather inputs from all sources</li>
<li><strong>Update</strong> - Update the game state</li>
<li><strong>Draw</strong> - Render everything to the screen</li>
</ul>
<p>We do clicking by reading mouse / key presses each frame, update the calculations based on those presses (and passive income), then draw all elements to the screen (I believe this is called immediate mode rendering).</p>
<h2 id="upgrades">Upgrades</h2>
<p>I added upgrades to spice things up a bit - I figured clicking a button forever and just seeing the number go up would be boring. Past clicker games I&#39;ve played all have upgrades and that&#39;s really the driving force behind it - a vast tree of possible upgrades to unlock.</p>
<p>Adding these was a bit harder - mostly because we have to deal with timing (passive income is added each second) and we have to build menu items.</p>
<p>We store the <a href="https://github.com/SIRHAMY/simple-clicker-game-raylib-cs/blob/8f6c9623e21a55286c5221afd66b1d60f1dc0409/SimpleClickerGame/GameState.cs#L37">full game state on a global object</a> and keep track of the upgrades the player has. Then we grab the inputs, <a href="https://github.com/SIRHAMY/simple-clicker-game-raylib-cs/blob/8f6c9623e21a55286c5221afd66b1d60f1dc0409/SimpleClickerGame/UpgradeCalculator.cs#L3">calculate the amount the upgrades provide</a>, and use that to update the game state.</p>
<h2 id="save-games">Save Games</h2>
<p>Save games seem pretty advanced in game dev but an endless clicker like this would be frustrating if you lost all your progress so I added auto save functionality.</p>
<p>Saves happen:</p>
<ul>
<li><a href="https://github.com/SIRHAMY/simple-clicker-game-raylib-cs/blob/8f6c9623e21a55286c5221afd66b1d60f1dc0409/SimpleClickerGame/Program.cs#L462">Every 10s</a></li>
<li><a href="https://github.com/SIRHAMY/simple-clicker-game-raylib-cs/blob/8f6c9623e21a55286c5221afd66b1d60f1dc0409/SimpleClickerGame/Program.cs#L88">When you exit the game</a></li>
</ul>
<p>We dump the current game state to a JSON file in the same folder as the executable. <a href="https://github.com/SIRHAMY/simple-clicker-game-raylib-cs/blob/8f6c9623e21a55286c5221afd66b1d60f1dc0409/SimpleClickerGame/Program.cs#L61">On startup</a>, we look for such a file and try to load it.</p>
<h2 id="cross-platform-execution">Cross Platform Execution</h2>
<p>I wanted the game to work cross platform - mostly because I&#39;m building this on Fedora and basically no one uses Fedora that I&#39;d share this with so if it wasn&#39;t cross platform no one would be able to play it.</p>
<p>I thought this would be tough to do but it seems Raylib and dotnet have good cross platform support so it was pretty easy to enable cross platform, single-file executables. I then setup automated builds so that whenever I push a new version of the game, those executables will be available for people to download.</p>
<p>You can find these releases on the <a href="https://github.com/SIRHAMY/simple-clicker-game-raylib-cs/releases">release page</a>.</p>
<h2 id="vibe-engineering">Vibe Engineering</h2>
<p>Another area I&#39;m exploring while at Recurse is applied AI - using the new models to streamline my workflows and systems.</p>
<p>Even though I&#39;d never used Raylib before, I was able to build this in a few hours over the course of a couple days by <a href="https://hamy.xyz/blog/2025-07_stop-vibe-coding">vibe engineering</a>. I had a general sense of what I wanted to do and how it should go together but had never tried to build specifics like menu items or particle effects in Raylib - which themselves likely would&#39;ve taken a few hours to get the hang of.</p>
<p>I found <a href="https://hamy.xyz/blog/2026-01_ai-engineering-best-practices">spec-driven development</a> to be extremely helpful here in aligning on the goals for the project before moving to implementation. I especially found a new step useful where the AI interviews me about any and all clarifications to the spec. Through this interview (40 questions!) we got clear on a lot of items I had in my head but had left out of its prompt context - like how the UI should be formatted, how should we display upgrade information, what coding styles we should use, etc.</p>
<p>AIs do better when you provide them a lot of relevant context but I&#39;m realizing that even when I do large context dumps, I&#39;m still leaving some relevant things out that I have in my head.</p>
<h2 id="next">Next</h2>
<p>This game is playable but not really &#34;complete&#34; but in the spirit of <a href="https://www.recurse.com/self-directives">learning generously</a> I&#39;m sharing how it&#39;s built early so people can take a look under the hood.</p>
<p>Please take a look at the game and lmk if you have any feedback! Also if you have any resources you like about game dev please send them my way - I&#39;m new to this and would love to learn more ab it!</p>
<p>If you liked this post you might also like:</p>
<ul>
<li><a href="https://hamy.xyz/blog/2026-01_ai-engineering-best-practices">5 AI Coding Best Practices from a Google AI Director (That Actually Work)</a></li>
<li><a href="https://hamy.xyz/blog/2025-12_software-engineers-ai">If AI can code, what will Software Engineers do?</a></li>
<li><a href="https://hamy.xyz/blog/2026-01_recurse-center-statement">What I Plan to Build at Recurse Center - A 12 Week Programmer&#39;s Retreat</a></li>
</ul>
</div></div>
  </body>
</html>
