<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.alexandervolkmann.com/2022/01/05/conversion-rate-A-B-testing.html">Original</a>
    <h1>A/B test improved your website&#39;s conversion rate? Not so fast</h1>
    
    <div id="readability-page-1" class="page"><div>
  <h2 id="testing-conversion-rate-improvements">Testing conversion rate improvements</h2>

<p>Many internet companies use A/B testing to evaluate the performance of website changes they
want to make. A typical metric in such scenarios is the conversion rate (CVR) of a user, i.e. the probability
that a user converts (e.g. makes a purchase) on the website.
A typical A/B test setup in such a situation would randomize users into to (equally sized) groups:
the test group that would be exposed to the new experience and the control group that would
be exposed to the status quo version of the website.</p>

<p>An analyst would do a power calculation based on the expected effect size from the test,
the variation of the CVR metric, the desired type I and type II error bounds in order to
determine the duration of the test.
After the test the analyst might perform <a href="https://en.wikipedia.org/wiki/Fisher%27s_exact_test">Fisher&#39;s exact test</a>
to determine whether or not to accept the new website version.</p>

<h3 id="larrys-analysis">Larry&#39;s analysis</h3>
<p>Let us consider the following fictitious example
in which Larry the analyst of the internet company Nozama runs a 1-week-long A/B test.
His data shows the following</p>

<table>
  <thead>
    <tr>
      <th>Â </th>
      <th>control</th>
      <th>test</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>users</td>
      <td>35000</td>
      <td>35000</td>
    </tr>
    <tr>
      <td>conversions</td>
      <td>1394</td>
      <td>1666</td>
    </tr>
  </tbody>
</table>

<p>Larry uses python to compute the p-value of the Fisher exact statistic</p>

<div><div><pre><code><span>from</span> <span>scipy</span> <span>import</span> <span>stats</span>

<span>data</span> <span>=</span> <span>[[</span><span>1394</span><span>,</span> <span>1666</span><span>],</span> <span>[</span><span>35000</span> <span>-</span> <span>1394</span><span>,</span> <span>35000</span> <span>-</span> <span>1666</span><span>]]</span>
<span>pval</span> <span>=</span> <span>stats</span><span>.</span><span>fisher_exact</span><span>(</span><span>data</span><span>)[</span><span>1</span><span>]</span>
<span>print</span><span>(</span><span>pval</span><span>)</span>
</code></pre></div></div>
<p>The result is 5.4e-07 which is &#34;statistically significant&#34; w.r.t. to Larry&#39;s predefined 5%
significance level.</p>

<p>Larry can&#39;t believe it, the new version improved the user conversion by 19.5%!</p>

<p><strong>But has it really ?</strong></p>

<p>Larry just blindly applied some statistical test to his data without thinking about the data
generating process.</p>

<p><em>So what exactly are the assumptions that Larry implicitly used in his analysis ?</em></p>

<p>For the Fisher exact test we need to assume that we have independent, identically distributed conversion events. More
precisely, we need to assume that (for each group) \(Conversions \sim Bin(users, p)\) for some probability \(p\), i.e. that
the number of conversions in each group are drawn from a Binomial distribution with \(n=\)number of users and some fixed
probability \(p\) (the conversion rate).</p>

<h3 id="a-smarter-approach">A smarter approach</h3>
<p>Using domain knowledge about how people on the website behave we know users that land on the website don&#39;t all
necessarily convert on the same day but sometimes purchase with some time lag after the initial visit. With this
knowledge at hand we take a new (Bayesian) approach to analysing the test results.</p>

<p>We make the following model assumptions:</p>

<ul>
  <li>\(p\) = probability of conversion</li>
  <li>\(X\) = lag in days between user website visit and conversion, where \(X=\infty\) corresponds to no conversion</li>
  <li>Conditional on a conversion, we assume that the lag variable \(X\) is distributed according to a zero-inflated
geometric distribution.</li>
</ul>

<p>We can write the pmf and cdf (for \(k&lt;\infty\)) of \(X\) as follows:</p><p>

\[P(X=k) = (1-p)\cdot \mathbb{1}_{\{\infty\}}(k) + p\cdot (\pi\cdot \mathbb{1}_{\{0\}}(k) + (1-\pi)\cdot\lambda \cdot(1-\lambda)^k\cdot \mathbb{1}_{\{\geq 0\}}(k))\]

\[F(k) = P(X \leq k) = 
p(1 -(1-\pi)(1-\lambda)^{k+1}).\]

</p><p>Before we can fit the model to our data there is one more problem that we encounter. Users in our data set for which we
didn&#39;t observe a conversion could either be <em>truly</em> non-converting or we haven&#39;t been able to observe their conversion
<em>yet</em>, since we are only considering 1 week of data. Users that entered our experiment on the first day for which we
haven&#39;t observed a conversion will have a smaller probability to still convert since we know that they didn&#39;t do a
purchase in one of the following 6 days. On other other hand, users that entered our experiment on the 7th day will have
a relatively larger probability to still convert on one of the following days.
We are faced with a so called <a href="https://en.wikipedia.org/wiki/Censoring_(statistics)">censored data problem</a>.</p>

<p>A subsample of our data looks as follows:</p>

<table>
  <thead>
    <tr>
      <th>visit_date</th>
      <th>conversion_date</th>
      <th>users</th>
      <th>is_control</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>2021-12-01</td>
      <td>2021-12-01</td>
      <td>84</td>
      <td>1</td>
    </tr>
    <tr>
      <td>2021-12-01</td>
      <td>None</td>
      <td>4750</td>
      <td>1</td>
    </tr>
    <tr>
      <td>2021-12-02</td>
      <td>2021-12-04</td>
      <td>33</td>
      <td>1</td>
    </tr>
    <tr>
      <td>2021-12-02</td>
      <td>None</td>
      <td>4785</td>
      <td>1</td>
    </tr>
    <tr>
      <td>2021-12-01</td>
      <td>2021-12-05</td>
      <td>2</td>
      <td>0</td>
    </tr>
    <tr>
      <td>2021-12-01</td>
      <td>None</td>
      <td>4756</td>
      <td>0</td>
    </tr>
    <tr>
      <td>2021-12-02</td>
      <td>2021-12-02</td>
      <td>199</td>
      <td>0</td>
    </tr>
    <tr>
      <td>2021-12-02</td>
      <td>None</td>
      <td>4762</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p><img src="https://blog.alexandervolkmann.com/images/censored_data.png" alt="visualization of censored data"/>
<em>visualization of censored data</em></p>

<p>We can write a Stan program in order to fit a model on the test and control data separately. We use Stan&#39;s custom
distribution functions capability (see <a href="https://link.springer.com/article/10.3758/s13428-016-0746-9">here</a> for a
tutorial) to code the pmf, cdf, inverse cdf and ccdf of our model as follows:</p>

<pre><code>functions{
    real uncensored_lpmf(int y, real pi, real p, real lambda){
        if (y == 0) 
            return log(p) + log(pi + (1 - pi) * lambda);
        else
            return log(p) + log(1 - pi) + log(lambda) + y * log(1 - lambda);
        }

    real censoredccdf(real y, real pi, real p, real lambda){
        return log(1 - p + p * (1 - pi) * pow(1 - lambda, y + 1));
        }
        
     real invcdf(real u, real pi, real p, real lambda){
         if (u &gt; p)
             return -1;
         else
             return ceil(log( (p - u) / (p * (1 - pi)) ) / log(1 - lambda) - 1);
     }
    
     real uncensored_rng(real pi, real p, real lambda) {
         real u;
         u = uniform_rng(0, 1);
         return invcdf(u, pi, p, lambda);
     }
}
</code></pre>
<p>Because we know that the typical conversion rate of our website is around 5% and unlikely to be larger than 10% we put a
\(Beta(2, 38)\)-prior on the \(p\)-parameter. 
We also know that there are disproportionally many users that convert on the day of their first visit which is why we
assume a non-negative value of \(\pi\) but with slightly more weight towards \(0\) which leads us to specify the prior
\(\pi\sim Beta(1,2)\). Finally, we put a non-informative uniform prior on the &#34;success&#34;-probability \(\lambda\).
Note, that values \(\max\{-1, \frac{-(1-\lambda)}{\lambda}\} \leq \pi &lt; 1\) would still give a well-defined model,
and would allow for a zero-<em>deflated</em> geometric distribution as well.</p>

<p>You can find our complete Stan model <a href="https://github.com/volkale/convpybayes/blob/main/src/stan/disconvpy.stan">here</a>.</p>

<p>Fitting the model to the data above we obtain the following posterior distributions for \(p\) for the test and control
groups, respectively.</p>

<p><img src="https://blog.alexandervolkmann.com/images/posteriorCVR.png" alt="posterior distribution of $$p$$"/>
<em>posterior distribution of \(p\)</em></p>

<p>As we can clearly see from the plot we are almost 100% certain (given the model and the data) that our control version
has a higher conversion rate \(p\) than the new test variant. So we should definitively not accept the new website
variant.</p>

<p><strong>How is this possible ?</strong></p>

<p>By inspecting all the posterior parameters of the model (not just the conversion rate \(p\)) we see that the new website
increased the parameters \(\pi\) and \(\lambda\) of our zero-inflated geometric distribution of the time-to-conversion
(aka lag) variable \(X\), i.e. although users convert less frequently under the new website version, the ones that do, do
so with a smaller time lag from their initial website visit.</p>

<p>Looking at what the new website version does, this seems plausible: the new website version implemented urgency features
that gave the users the impression that the product they were considering for purchase would soon be unavailable or
would drastically increase in price. This lead to the fact that some users were annoyed by this alarmist messaging and
design, and now didn&#39;t convert anymore even though they might have under the old version, and the ones that still did,
now did so without letting too much time go by.</p>

<p><img src="https://blog.alexandervolkmann.com/images/vc_date.png" alt="visit vs. conversion date frequencies"/>
<em>visit vs. conversion date frequencies</em></p>

<p>Of course, at this point this can only be a hypothesis that is based on domain knowledge about how users typically react
to certain changes and that fits with the data observed in this experiment. This cannot be so easily proven.
A necessary condition for this explanation to be correct would be that we have treatment effect heterogeneity, i.e.
that some users are affected differently by the change than others. We will leave a discussion about treatment effect
heterogeneity for another blog post in the future.</p>

<h2 id="conclusions">Conclusions</h2>
<ul>
  <li>Assumptions matter for correct decision making; think about the data generating process; domain knowledge is important</li>
  <li>Be careful when using lagged response variables in A/B testing</li>
  <li>Bayesian stats and Stan are awesome ;)</li>
</ul>

<h2 id="references--further-reading">References / further reading</h2>
<ul>
  <li>Our model was inspired by the continuous (frequentist) conversion model that was proposed in the <a href="https://doi.org/10.1145/2623330.2623634">2014 KDD paper</a>
&#34;Modeling delayed feedback in display advertising&#34; by Olivier Chapelle.</li>
  <li>Check out the <a href="https://mc-stan.org/docs/2_28/stan-users-guide/censored-data.html#censored-data">Stan manual</a> on
estimating censored values.</li>
</ul>

</div></div>
  </body>
</html>
