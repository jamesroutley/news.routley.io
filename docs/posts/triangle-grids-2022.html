<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kvachev.com/blog/posts/triangular-grid/">Original</a>
    <h1>Triangle Grids (2022)</h1>
    
    <div id="readability-page-1" class="page"><div><p>Grids are great for tactical gameplay of turn-based games because they allow discrete movement steps. That means that you can bind positioning to other resources such as movement points, action points, food, etc. Grids divide the infinite variety of movement options into a few specific ones, which can be considered separately by the player’s tactical mind. The most popular grid types are hexes and squares. But what about triangles?</p>
 
<video width="100%" autoplay="" loop="" playsmuted="" [muted]="&#39;muted&#39;" autoplay="autoplay" loop="loop">
    <source src="../videos/triangle-0.mp4" type="video/mp4"/>
    Your browser does not support the video tag.  
</video>

<h2 id="types-of-grids-comparison">Types of Grids: Comparison</h2>
<p>We are perfectly familiar with square and hex grids, as most turn-based games use one of them. Both have upsides and downsides. I will go through each of these and include the triangle grid in comparison.</p>
<p>
<img loading="lazy" src="https://kvachev.com/blog/posts/triangular-grid/triangle-1.jpg" type="" alt=""/></p>
<h3 id="visuals">Visuals</h3>
<p><strong>Square grids</strong> will contribute to visuals for non-natural environments, such as towns, dungeons, streets, and building interiors.</p>
<p><strong>Hex grids</strong> look nice with natural environments instead, improving the realism of curvy things, such as islands, mountains, small roads, etc.</p>
<p>In the case with looks, triangle grids lie in between: like squares, they allow straight lines and walls without half-tiles, and like hexes, they allow more curvy environments. In fact, triangle grids contain both in itself! You can even have rhombus (huge) and hex (colossal) creatures on top of the triangle grid, like this:</p>
<p>
<img loading="lazy" src="https://kvachev.com/blog/posts/triangular-grid/triangle-2.jpg" type="" alt="image"/></p>
<p>On top of that, it has a bonus: like the square grid, it can contain bigger and smaller grids in itself.</p>
<p>The only visual downside before the square grid is that it can’t express rectangle buildings. In this case, the same cheat from the hex grid can be used: use half tiles. A blocking object (wall) goes through half of the tile and the tile is blocked completely.</p>
<p>
<img loading="lazy" src="https://kvachev.com/blog/posts/triangular-grid/triangle-6.jpg" type="" alt=""/></p>
<p>There are also two special cases that make triangles shine. The first is <strong>line formations</strong>. When the second row of spearmen/riflemen stays between the first, like on the picture above, they can attack enemy formation too without a friend obstructing the view.</p>
<p>So it’s possible to directly represent lines of soldiers on triangular grids; formations will also have the ability to rotate in 6 directions. But this point applies to hex grids too, it’s just that the second row will be further away from enemies, and with triangles, enemies in front of the formations are diagonally-adjacent to the second row. I’ll tell you more about diagonals and diagonal distances in a minute.</p>
<p>
<img loading="lazy" src="https://kvachev.com/blog/posts/triangular-grid/triangle-5.jpg" type="" alt=""/></p>
<p>Another thing is <strong>citadels/bastions</strong>. These angles allow more convenient defenses, and fortifications were often built this way throughout history. In <a href="http://colossalcitadels.com/">Colossal Citadels</a> I made walls and houses follow the triangular grid and I love how these procedurally-generated castles turned out:</p>
<p>
<img loading="lazy" src="https://kvachev.com/blog/posts/triangular-grid/triangle-4.jpg" type="" alt=""/></p>
<h3 id="directions-and-adjacent-tiles">Directions and Adjacent Tiles</h3>
<p>The number of tactical options (movements, attacks, ranged straight-line attacks) depends on the type of grid. It also depends on whether or not you allow diagonal directions. Let’s count how many non-diagonal directions each grid type allows:</p>
<p>
<img loading="lazy" src="https://kvachev.com/blog/posts/triangular-grid/triangle-0.png" type="" alt=""/></p>
<ul>
<li><strong>Square grid:</strong> 4 adjacent tiles, 4 directions</li>
<li><strong>Hex grid:</strong> 6 adjacent tiles, 6 directions</li>
<li><strong>Triangle grid:</strong> 3 adjacent tiles, 6 directions</li>
</ul>
<p>Restricting the number of options would make sense in a tight puzzle-like tactics game, and in bigger strategy games you might want to increase the variety of options to depend less on micro tactics on movement.</p>
<h3 id="directions-and-adjacent-tiles-diagonals">Directions And Adjacent Tiles: Diagonals</h3>
<p>Some games increase these numbers by allowing diagonal tiles and directions. This is where triangle grids overcome other variants!</p>
<p>
<img loading="lazy" src="https://kvachev.com/blog/posts/triangular-grid/triangle-6.png" type="" alt=""/></p>
<ul>
<li><strong>Square grid:</strong> 8 adjacent tiles, 8 directions</li>
<li><strong>Hex grid:</strong> 6 adjacent tiles, 6 directions</li>
<li><strong>Triangle grid:</strong> 12 adjacent tiles, 12 directions</li>
</ul>
<p>So, if you want to have more options, triangle grids with diagonals are a good choice. Ranged “line” attacks also look slightly better because they’re not alternating as with the hex grids; be sure to highlight the lines in 6 straight diagonals, or it will look not so good.</p>
<h3 id="distances">Distances</h3>
<p>
<img loading="lazy" src="https://kvachev.com/blog/posts/triangular-grid/triangle-2.png" type="" alt=""/></p>
<ul>
<li><strong>Hex grids</strong> are very good at estimating the closest path - you can naturally see the closest point.</li>
<li><strong>Square grids</strong> without diagonals are not so convenient, but distances are always easy to calculate.</li>
<li><strong>Triangle grids</strong> without diagonals are fine, but there is an issue when you have an opposing triangle: it takes 3 steps to move to it. This might look weird and unnatural. We can fix this by introducing diagonals: allow jumping to the opposing triangle at the cost of 2 instead of three. Then, triangular grid becomes convenient to use and more realistic:</li>
</ul>
<p>
<img loading="lazy" src="https://kvachev.com/blog/posts/triangular-grid/triangle-3.png" type="" alt=""/></p>
<p>You can find calculating functions for all distances (and explanations) in the end of this article. <em>By the way, I believe I was the first to mention this and the next kind of triangle diagonal distances in the internet <a href="https://www.reddit.com/r/gamedev/comments/nji0sf/how_to_use_triangle_grids/">here</a> - it links to another cool article by BorisTheBrave. But these grids are simple stuff in my opinion, and most possibly, board game developers who explored triangle grids already have considered it long ago.</em></p>
<p>So, this way of calculating distance is quite fine for movements, but for less edgy shapes (for example, buildings), you might want to have something even simpler: full diagonal distances. Treat all tiles that touch the current triangle with one of the vertices as a distance of 1.</p>
<p>
<img loading="lazy" src="https://kvachev.com/blog/posts/triangular-grid/triangle-4.png" type="" alt=""/></p>
<p>Unfortunately, this approach is not a panacea: it’s not that beautiful for movement, because a moving unit can cheat a little bit and cover up to two times more tiles than in previous distance measures! Can you figure out how? But this type of distance is very good for ranged attacks and zones! So, I would suggest using either the previous formula, or both: full diagonals for ranges and diagonal shortcut for movements.</p>
<h3 id="heightmap-terrains">Heightmap Terrains</h3>
<p>This is not a gameplay point, but it’s still worth mentioning. There is a way of drawing terrain meshes with triangles instead of quads. This way can save some percentage of triangle count and fixes <a href="https://catlikecoding.com/unity/tutorials/procedural-meshes/triangle-grid">some other issues</a> automatically. If terrain tiles are tied to gameplay, this is going to look interesting. I’ve not seen a triangular grid voxel minecraft-like game yet!</p>
<p>
<img loading="lazy" src="https://kvachev.com/blog/posts/triangular-grid/triangle-3.jpg" type="" alt=""/></p>
<h2 id="how-to-use-triangular-grid">How To Use Triangular Grid</h2>
<p><a href="https://www.redblobgames.com/grids/triangles/">Red Blob Games’s article</a> provides a lot of thoughts on representations of triangle grid, but I’ll just use the best one and supply it with a lot of common useful operations on it.</p>
<h3 id="coordinate-representation">Coordinate Representation</h3>
<p>The most convenient option is to represent it as square grid coordinates PLUS a number that means half-square - 0 or 1.</p>
<div><pre tabindex="0"><code data-lang="c++"><span>struct</span> <span>Pos</span> 
<span>{</span>
    <span>int</span> <span>x</span><span>,</span> <span>y</span><span>,</span> <span>s</span><span>;</span>
<span>};</span>
</code></pre></div><h3 id="conversions">Conversions</h3>
<p>Conversions between index, coordinates, and 2D world coordinates are going to be the most common operations.</p>
<h4 id="index---coordinates">Index &lt;-&gt; Coordinates</h4>
<div><pre tabindex="0"><code data-lang="c++"><span>int</span> <span>toIndex</span><span>(</span><span>const</span> <span>Pos</span><span>&amp;</span> <span>pos</span><span>,</span> <span>int</span> <span>gridWidth</span><span>)</span>
<span>{</span>
    <span>return</span> <span>pos</span><span>.</span><span>x</span> <span>*</span> <span>2</span> <span>+</span> <span>pos</span><span>.</span><span>y</span> <span>*</span> <span>gridWidth</span> <span>*</span> <span>2</span> <span>+</span> <span>pos</span><span>.</span><span>s</span><span>;</span>
<span>}</span>

<span>Pos</span> <span>fromIndex</span><span>(</span><span>int</span> <span>i</span><span>,</span> <span>int</span> <span>gridWidth</span><span>)</span>
<span>{</span>
    <span>return</span> <span>Pos</span><span>{(</span><span>i</span> <span>/</span> <span>2</span><span>)</span> <span>%</span> <span>gridWidth</span><span>,</span> <span>(</span><span>i</span> <span>/</span> <span>2</span><span>)</span> <span>/</span> <span>gridWidth</span><span>,</span> <span>i</span> <span>%</span> <span>2</span><span>};</span>
<span>}</span>
</code></pre></div><h4 id="world---coordinates">World &lt;-&gt; Coordinates</h4>
<div><pre tabindex="0"><code data-lang="c++"><span>struct</span> <span>Vec2</span> 
<span>{</span>
    <span>float</span> <span>x</span><span>,</span> <span>y</span><span>;</span>
<span>};</span>
</code></pre></div><p>We will need some constants for representing tile size in world space. I use these:</p>
<div><pre tabindex="0"><code data-lang="c++"><span>namespace</span> <span>TriangleConstants</span>
<span>{</span>
    <span>const</span> <span>float</span> <span>Height</span> <span>=</span> <span>150.f</span><span>;</span>
    <span>const</span> <span>float</span> <span>Side</span> <span>=</span> <span>173.20508075689f</span><span>;</span>
<span>}</span>
</code></pre></div><div><pre tabindex="0"><code data-lang="c++"><span>Vec2</span> <span>gridToWorld</span><span>(</span>
    <span>const</span> <span>Pos</span><span>&amp;</span> <span>pos</span><span>,</span>
    <span>float</span> <span>worldspaceTriangleSide</span><span>,</span>
    <span>float</span> <span>worldspaceTriangleHeight</span><span>)</span>
<span>{</span>
    <span>return</span> <span>Vec2</span><span>{</span>
        <span>pos</span><span>.</span><span>x</span> <span>*</span> <span>worldspaceTriangleSide</span> <span>+</span> <span>pos</span><span>.</span><span>y</span> <span>*</span> <span>worldspaceTriangleSide</span> <span>/</span> <span>2.f</span><span>,</span>
        <span>pos</span><span>.</span><span>y</span> <span>*</span> <span>worldspaceTriangleHeight</span>
    <span>};</span>
<span>}</span>

<span>Pos</span> <span>worldToGrid</span><span>(</span><span>const</span> <span>Vec2</span><span>&amp;</span> <span>pos</span><span>)</span>
<span>{</span>
    <span>float</span> <span>y</span> <span>=</span> <span>std</span><span>::</span><span>get</span><span>&lt;</span><span>1</span><span>&gt;</span><span>(</span><span>pos</span><span>)</span> <span>/</span> <span>TriangleConstants</span><span>::</span><span>Height</span><span>;</span>
    <span>float</span> <span>x</span> <span>=</span> <span>std</span><span>::</span><span>get</span><span>&lt;</span><span>0</span><span>&gt;</span><span>(</span><span>pos</span><span>)</span> <span>/</span> <span>TriangleConstants</span><span>::</span><span>Side</span> <span>-</span> <span>y</span> <span>/</span> <span>2.f</span><span>;</span>
    <span>bool</span> <span>s</span> <span>=</span> <span>(</span><span>x</span> <span>-</span> <span>floorf</span><span>(</span><span>x</span><span>)</span> <span>+</span> <span>y</span> <span>-</span> <span>floorf</span><span>(</span><span>y</span><span>))</span> <span>&gt;</span> <span>1.f</span><span>;</span>
    <span>return</span> <span>Pos</span><span>{</span><span>int</span><span>(</span><span>x</span><span>),</span> <span>int</span><span>(</span><span>y</span><span>),</span> <span>int</span><span>(</span><span>s</span><span>)};</span>
<span>}</span>
</code></pre></div><h4 id="trianglular-grid---square-grid">Trianglular Grid &lt;-&gt; Square Grid</h4>
<p>It’s just as simple as taking <code>x</code> and <code>y</code> components and adding or removing third coordinate from them.</p>
<h3 id="triangle-tile-distance">Triangle Tile Distance</h3>
<p>To calculate simple tile distance you can use Manhattan distance with addition of third component difference.</p>
<div><pre tabindex="0"><code data-lang="c++"><span>int</span> <span>distance</span><span>(</span><span>const</span> <span>Pos</span><span>&amp;</span> <span>a</span><span>,</span> <span>const</span> <span>Pos</span><span>&amp;</span> <span>b</span><span>)</span>
<span>{</span>
    <span>auto</span> <span>dx</span> <span>=</span> <span>a</span><span>.</span><span>x</span> <span>-</span> <span>b</span><span>.</span><span>x</span><span>;</span>
    <span>auto</span> <span>dy</span> <span>=</span> <span>a</span><span>.</span><span>y</span> <span>-</span> <span>b</span><span>.</span><span>y</span><span>;</span>
    <span>auto</span> <span>ds</span> <span>=</span> <span>a</span><span>.</span><span>s</span> <span>-</span> <span>b</span><span>.</span><span>s</span><span>;</span>
    <span>return</span> <span>abs</span><span>(</span><span>dx</span><span>)</span> <span>+</span> <span>abs</span><span>(</span><span>dy</span><span>)</span> <span>+</span> <span>abs</span><span>(</span><span>dx</span> <span>+</span> <span>dy</span> <span>+</span> <span>ds</span><span>);</span>
<span>}</span>
</code></pre></div><p>The logic behind this formula is that first you need to convert your coordinates to intermediate representation (<code>adx</code>, <code>adx</code>, <code>adz</code>), that reflects distances from initial point on three axes, each one parallel to one side of a triangle. Since it is just a taxicab distance, you need to just sum three components up.</p>
<p>Convenient distance functions are a bit more complex:</p>
<h3 id="diagonal-triangle-tile-distance-shortcuts">Diagonal Triangle Tile Distance (Shortcuts)</h3>
<p>To allow movement through diagonal, you have to subtract the minimum of three distance components from the previous formula. Why is that and how did I find this? That information is lost… Probably, I just noticed it from staring at triangular grid for too long.</p>
<div><pre tabindex="0"><code data-lang="c++"><span>int</span> <span>triangleDistanceDiagonal</span><span>(</span><span>const</span> <span>TilePosition</span><span>&amp;</span> <span>a</span><span>,</span> <span>const</span> <span>TilePosition</span><span>&amp;</span> <span>b</span><span>)</span>
<span>{</span>
    <span>auto</span> <span>dx</span> <span>=</span> <span>a</span><span>.</span><span>x</span> <span>-</span> <span>b</span><span>.</span><span>x</span><span>;</span>
    <span>auto</span> <span>dy</span> <span>=</span> <span>a</span><span>.</span><span>y</span> <span>-</span> <span>b</span><span>.</span><span>y</span><span>;</span>
    <span>auto</span> <span>ds</span> <span>=</span> <span>a</span><span>.</span><span>s</span> <span>-</span> <span>b</span><span>.</span><span>s</span><span>;</span>
    <span>auto</span> <span>adx</span> <span>=</span> <span>abs</span><span>(</span><span>dx</span><span>);</span>
    <span>auto</span> <span>ady</span> <span>=</span> <span>abs</span><span>(</span><span>dy</span><span>);</span>
    <span>auto</span> <span>adz</span> <span>=</span> <span>abs</span><span>(</span><span>dx</span> <span>+</span> <span>dy</span> <span>+</span> <span>ds</span><span>);</span>
    <span>auto</span> <span>m</span> <span>=</span> <span>std</span><span>::</span><span>min</span><span>({</span><span>adx</span><span>,</span> <span>ady</span><span>,</span> <span>adz</span><span>});</span>
    <span>return</span> <span>adx</span> <span>+</span> <span>ady</span> <span>+</span> <span>adz</span> <span>-</span> <span>m</span><span>;</span>
<span>}</span>

</code></pre></div><h3 id="diagonal-triangle-tile-distance-full">Diagonal Triangle Tile Distance (Full)</h3>
<p>This is much simpler. To treat all diagonal tiles as distance one, you have to find maximum of all three components instead:</p>
<div><pre tabindex="0"><code data-lang="c++"><span>int</span> <span>triangleDistanceFullDiagonal</span><span>(</span><span>const</span> <span>TilePosition</span><span>&amp;</span> <span>a</span><span>,</span> <span>const</span> <span>TilePosition</span><span>&amp;</span> <span>b</span><span>)</span>
<span>{</span>
    <span>auto</span> <span>dx</span> <span>=</span> <span>a</span><span>.</span><span>x</span> <span>-</span> <span>b</span><span>.</span><span>x</span><span>;</span>
    <span>auto</span> <span>dy</span> <span>=</span> <span>a</span><span>.</span><span>y</span> <span>-</span> <span>b</span><span>.</span><span>y</span><span>;</span>
    <span>auto</span> <span>ds</span> <span>=</span> <span>a</span><span>.</span><span>s</span> <span>-</span> <span>b</span><span>.</span><span>s</span><span>;</span>
    <span>auto</span> <span>adx</span> <span>=</span> <span>abs</span><span>(</span><span>dx</span><span>);</span>
    <span>auto</span> <span>ady</span> <span>=</span> <span>abs</span><span>(</span><span>dy</span><span>);</span>
    <span>auto</span> <span>adz</span> <span>=</span> <span>abs</span><span>(</span><span>dx</span> <span>+</span> <span>dy</span> <span>+</span> <span>ds</span><span>);</span>
    <span>return</span> <span>std</span><span>::</span><span>max</span><span>({</span><span>adx</span><span>,</span> <span>ady</span><span>,</span> <span>adz</span><span>});</span>
<span>}</span>
</code></pre></div><h2 id="source-code">Source Code</h2>
<p>All these functions plus some lesser ones, for example, calculating adjacent coordinate with or without diagonals, are included in my <a href="https://github.com/Rasie1/triangle">tiny header library</a>. Feel free to use it, it’s published under CC0.</p>

 
<video width="100%" autoplay="" loop="" playsmuted="" [muted]="&#39;muted&#39;" autoplay="autoplay" loop="loop">
    <source src="../videos/triangle-1.mp4" type="video/mp4"/>
    Your browser does not support the video tag.  
</video>

<h2 id="conclusion">Conclusion</h2>
<p>Triangular grids are a fantastic option too. As far as I know, there are no released games that make use of triangle grids yet. Maybe <a href="https://store.steampowered.com/app/1854570/Colossal_Citadels/">my project</a> (from the screenshots above) will be the first? There are some board games - someone even tried to play <a href="http://xahlee.info/math/go_board_variations.html">Go on triangular grids</a>.</p>
<p>However, the design of my game doesn’t need precise movement controls. You still play with grids with abilities and town-building, but the positioning of creatures is automatic. So, the space for classic turn-based tactics on triangle grids will be still open.</p>
<p>There are also other bizarre and irregular grid types. I can see some interesting gameplay ideas coming out from these, e.g. buildings can only go on big tiles, or smaller tiles are for “upgrades” that apply to big tiles, and so on.</p>
<p>
<img loading="lazy" src="https://kvachev.com/blog/posts/triangular-grid/grids.jpg" type="" alt=""/></p>

  </div></div>
  </body>
</html>
