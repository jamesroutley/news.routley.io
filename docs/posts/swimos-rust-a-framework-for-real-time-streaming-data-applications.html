<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/swimos/swim-rust">Original</a>
    <h1>Show HN: SwimOS Rust â€“ A framework for real-time streaming data applications</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text"><p dir="auto"><a href="https://www.swimos.org" rel="nofollow"><img src="https://camo.githubusercontent.com/6a6d5868d57cf027232063d7ac5761a97512e22bc6ef7ce633feb9afe868a12d/68747470733a2f2f646f63732e7377696d6f732e6f72672f726561646d652f6d61726c696e2d626c75652e737667" data-canonical-src="https://docs.swimos.org/readme/marlin-blue.svg"/></a>
</p>
<p dir="auto">The Swim Rust SDK contains software framework for building stateful applications that can be interacted
with via multiplexed streaming APIs. It is built on top of the <a href="https://tokio.rs/" rel="nofollow">Tokio asynchronous runtime</a>
and a Tokio runtime is required for any Swim application.</p>
<p dir="auto">Each application consists of some number of stateful agents, each of which runs as a separate Tokio task
and can be individually addressed by a URI. An agent may have both public and private state which can either
be held solely in memory or, optionally, in persistent storage. The public state of the agent consists of a
number of lanes, analogous to a field in a record. There are multiple kinds of lanes that, for example, lanes
containing single values and those containing a map of key-value pairs.</p>
<p dir="auto">The state of any lane can be observed by establishing a link to it (either from another agent instance or a
dedicated client). A established link will push all updates to the state of that lane to the subscriber and
will also allow the subscriber to request changes to the state (for lane kinds that support this). Links
operate over a web-socket connection and are multiplexed, meaning that links to multiple lanes on the same
host can share a single web-socket connection.</p>
<p dir="auto"><a href="https://crates.io/crates/swimos" rel="nofollow"><img src="https://camo.githubusercontent.com/2d14e42f141688246b014b57ca8a155f18408e2dc9783ceeae638ddd7cbc0924/68747470733a2f2f696d672e736869656c64732e696f2f6372617465732f762f7377696d6f733f6c6162656c3d7377696d6f73" alt="SwimOS Crates.io Version" data-canonical-src="https://img.shields.io/crates/v/swimos?label=swimos"/></a>
<a href="https://crates.io/crates/swimos_client" rel="nofollow"><img src="https://camo.githubusercontent.com/fd3ffbf4c7dc29faeb2d60314d0ed289ed28b933ca778644df23773c75aead70/68747470733a2f2f696d672e736869656c64732e696f2f6372617465732f762f7377696d6f733f6c6162656c3d7377696d6f735f636c69656e74" alt="SwimOS Client Crates.io Version" data-canonical-src="https://img.shields.io/crates/v/swimos?label=swimos_client"/></a>
<a href="https://crates.io/crates/swimos_form" rel="nofollow"><img src="https://camo.githubusercontent.com/90d034ecc7b64d8f2cc5613a0083ed07273c991844ebdb2cf4bafc8f5fbcbbd5/68747470733a2f2f696d672e736869656c64732e696f2f6372617465732f762f7377696d6f733f6c6162656c3d7377696d6f735f666f726d" alt="SwimOS Form Crates.io Version" data-canonical-src="https://img.shields.io/crates/v/swimos?label=swimos_form"/></a></p>
<p dir="auto"><a href="https://swimos.org/" rel="nofollow">Website</a> | <a href="https://www.swimos.org/server/rust/developer-guide/" rel="nofollow">Developer Guide</a> | <a href="https://docs.rs/swimos/latest/swimos/" rel="nofollow">Server API Docs</a> | <a href="https://docs.rs/swimos_client/latest/swimos_client/" rel="nofollow">Client API Docs</a></p>

<p dir="auto"><a href="https://github.com/swimos/swim-rust/blob/main/docs/agent.md">Implementing Swim Agents in Rust</a></p>
<p dir="auto"><a href="https://github.com/swimos/swim-rust/blob/main/docs/server.md">Building a Swim Server Application</a></p>
<p dir="auto"><a href="https://www.swimos.org/server/rust/" rel="nofollow">Reference Documentation</a></p>

<p dir="auto">The following example application runs a SwimOS server that hosts a single agent route where each agent instance
has single lane, called <code>lane</code>. Each time a changes is made to the lane, it will be printed on the console by the
server.</p>
<div dir="auto" data-snippet-clipboard-copy-content="[dependencies]
swimos = { version = &#34;0.1.0&#34;, features = [&#34;server&#34;, &#34;agent&#34;] }"><pre>[<span>dependencies</span>]
<span>swimos</span> = { <span>version</span> = <span><span>&#34;</span>0.1.0<span>&#34;</span></span>, <span>features</span> = [<span><span>&#34;</span>server<span>&#34;</span></span>, <span><span>&#34;</span>agent<span>&#34;</span></span>] }</pre></div>
<div dir="auto" data-snippet-clipboard-copy-content="use swimos::{
    agent::{
        agent_lifecycle::HandlerContext,
        agent_model::AgentModel,
        event_handler::{EventHandler, HandlerActionExt},
        lanes::ValueLane,
        lifecycle, AgentLaneModel,
    },
    route::RoutePattern,
    server::{until_termination, Server, ServerBuilder},
};

#[tokio::main]
pub async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // An agent route consists of the agent definition and a lifecycle.
    let model = AgentModel::new(ExampleAgent::default, ExampleLifecycle.into_lifecycle());

    let server = ServerBuilder::with_plane_name(&#34;Example Plane&#34;)
        .set_bind_addr(&#34;127.0.0.1:8080&#34;.parse()?) // Bind the server to this address.
        .add_route(RoutePattern::parse_str(&#34;/examples/{id}&#34;)?, model) // Register the agent we have defined.
        .build()
        .await?;

    // Run the server until we terminate it with Ctrl-C.
    let (task, handle) = server.run();
    let (ctrl_c_result, server_result) = tokio::join!(until_termination(handle, None), task);

    ctrl_c_result?;
    server_result?;
    Ok(())
}

// Deriving the `AgentLaneModel` trait makes this type into an agent.
#[derive(AgentLaneModel)]
struct ExampleAgent {
    lane: ValueLane&lt;i32&gt;,
}

// Any agent type can have any number of lifecycles defined for it. A lifecycle describes
// how the agent will react to events that occur as it executes.
#[derive(Default, Clone, Copy)]
struct ExampleLifecycle;

// The `lifecycle` macro creates an method called `into_lifecycle` for the type, using the
// annotated event handlers methods in the block.
#[lifecycle(ExampleAgent)]
impl ExampleLifecycle {
    #[on_event(lane)]
    fn lane_event(
        &amp;self,
        context: HandlerContext&lt;ExampleAgent&gt;,
        value: &amp;i32,
    ) -&gt; impl EventHandler&lt;ExampleAgent&gt; {
        let n = *value;
        context.get_agent_uri().and_then(move |uri| {
            context.effect(move || {
                println!(&#34;Received value: {} for &#39;lane&#39; on agent at URI: {}.&#34;, n, uri);
            })
        })
    }
}"><pre><span>use</span> swimos<span>::</span><span>{</span>
    agent<span>::</span><span>{</span>
        agent_lifecycle<span>::</span><span>HandlerContext</span><span>,</span>
        agent_model<span>::</span><span>AgentModel</span><span>,</span>
        event_handler<span>::</span><span>{</span><span>EventHandler</span><span>,</span> <span>HandlerActionExt</span><span>}</span><span>,</span>
        lanes<span>::</span><span>ValueLane</span><span>,</span>
        lifecycle<span>,</span> <span>AgentLaneModel</span><span>,</span>
    <span>}</span><span>,</span>
    route<span>::</span><span>RoutePattern</span><span>,</span>
    server<span>::</span><span>{</span>until_termination<span>,</span> <span>Server</span><span>,</span> <span>ServerBuilder</span><span>}</span><span>,</span>
<span>}</span><span>;</span>

<span>#<span>[</span>tokio<span>::</span>main<span>]</span></span>
<span>pub</span> <span>async</span> <span>fn</span> <span>main</span><span>(</span><span>)</span> -&gt; <span>Result</span><span>&lt;</span><span>(</span><span>)</span><span>,</span> <span>Box</span><span>&lt;</span><span>dyn</span> std<span>::</span>error<span>::</span><span>Error</span><span>&gt;</span><span>&gt;</span> <span>{</span>
    <span>// An agent route consists of the agent definition and a lifecycle.</span>
    <span>let</span> model = <span>AgentModel</span><span>::</span><span>new</span><span>(</span><span>ExampleAgent</span><span>::</span>default<span>,</span> <span>ExampleLifecycle</span><span>.</span><span>into_lifecycle</span><span>(</span><span>)</span><span>)</span><span>;</span>

    <span>let</span> server = <span>ServerBuilder</span><span>::</span><span>with_plane_name</span><span>(</span><span>&#34;Example Plane&#34;</span><span>)</span>
        <span>.</span><span>set_bind_addr</span><span>(</span><span>&#34;127.0.0.1:8080&#34;</span><span>.</span><span>parse</span><span>(</span><span>)</span>?<span>)</span> <span>// Bind the server to this address.</span>
        <span>.</span><span>add_route</span><span>(</span><span>RoutePattern</span><span>::</span><span>parse_str</span><span>(</span><span>&#34;/examples/{id}&#34;</span><span>)</span>?<span>,</span> model<span>)</span> <span>// Register the agent we have defined.</span>
        <span>.</span><span>build</span><span>(</span><span>)</span>
        <span>.</span><span>await</span>?<span>;</span>

    <span>// Run the server until we terminate it with Ctrl-C.</span>
    <span>let</span> <span>(</span>task<span>,</span> handle<span>)</span> = server<span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>
    <span>let</span> <span>(</span>ctrl_c_result<span>,</span> server_result<span>)</span> = tokio<span>::</span>join!<span>(</span>until_termination<span>(</span>handle, <span>None</span><span>)</span>, task<span>)</span><span>;</span>

    ctrl_c_result?<span>;</span>
    server_result?<span>;</span>
    <span>Ok</span><span>(</span><span>(</span><span>)</span><span>)</span>
<span>}</span>

<span>// Deriving the `AgentLaneModel` trait makes this type into an agent.</span>
<span>#<span>[</span>derive<span>(</span><span>AgentLaneModel</span><span>)</span><span>]</span></span>
<span>struct</span> <span>ExampleAgent</span> <span>{</span>
    <span>lane</span><span>:</span> <span>ValueLane</span><span>&lt;</span><span>i32</span><span>&gt;</span><span>,</span>
<span>}</span>

<span>// Any agent type can have any number of lifecycles defined for it. A lifecycle describes</span>
<span>// how the agent will react to events that occur as it executes.</span>
<span>#<span>[</span>derive<span>(</span><span>Default</span><span>,</span> <span>Clone</span><span>,</span> <span>Copy</span><span>)</span><span>]</span></span>
<span>struct</span> <span>ExampleLifecycle</span><span>;</span>

<span>// The `lifecycle` macro creates an method called `into_lifecycle` for the type, using the</span>
<span>// annotated event handlers methods in the block.</span>
<span>#<span>[</span>lifecycle<span>(</span><span>ExampleAgent</span><span>)</span><span>]</span></span>
<span>impl</span> <span>ExampleLifecycle</span> <span>{</span>
    <span>#<span>[</span>on_event<span>(</span>lane<span>)</span><span>]</span></span>
    <span>fn</span> <span>lane_event</span><span>(</span>
        <span>&amp;</span><span>self</span><span>,</span>
        <span>context</span><span>:</span> <span>HandlerContext</span><span>&lt;</span><span>ExampleAgent</span><span>&gt;</span><span>,</span>
        <span>value</span><span>:</span> <span>&amp;</span><span>i32</span><span>,</span>
    <span>)</span> -&gt; <span>impl</span> <span>EventHandler</span><span>&lt;</span><span>ExampleAgent</span><span>&gt;</span> <span>{</span>
        <span>let</span> n = <span>*</span>value<span>;</span>
        context<span>.</span><span>get_agent_uri</span><span>(</span><span>)</span><span>.</span><span>and_then</span><span>(</span><span>move</span> |uri| <span>{</span>
            context<span>.</span><span>effect</span><span>(</span><span>move</span> || <span>{</span>
                <span>println</span><span>!</span><span>(</span><span>&#34;Received value: {} for &#39;lane&#39; on agent at URI: {}.&#34;</span>, n, uri<span>)</span><span>;</span>
            <span>}</span><span>)</span>
        <span>}</span><span>)</span>
    <span>}</span>
<span>}</span></pre></div>
<p dir="auto">For example, if a Swim client sends an update, with the value <code>5</code>, to the agent at the URI <code>/examples/name</code> for the
lane <code>lane</code>, an instance of <code>ExampleAgent</code>, using <code>ExampleLifecycle</code>, will be started by the server. The value of the
lane will then be set to <code>5</code> and the following will be printed on the console:</p>
<div data-snippet-clipboard-copy-content="Received value: 5 for &#39;lane&#39; on agent at URI: /examples/name."><pre><code>Received value: 5 for &#39;lane&#39; on agent at URI: /examples/name.
</code></pre></div>
<p dir="auto">A number of example applications are available in the <a href="https://github.com/swimos/swim-rust/blob/main/example_apps">example_apps</a> directory which demonstrate
individual features as well as more comprehensive applications.</p>

<p dir="auto">See the <a href="https://github.com/swimos/swim-rust/blob/main/DEVELOPMENT.md">development guide</a>.</p>

<p dir="auto">This project is licensed under the <a href="https://github.com/swimos/swim-rust/blob/main/LICENSE">Apache 2.0 License</a>.</p>
</article></div></div>
  </body>
</html>
