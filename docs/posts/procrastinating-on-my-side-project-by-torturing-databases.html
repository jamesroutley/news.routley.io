<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ntietz.com/blog/procrastinating-on-my-side-project-by-torturing-databases/?utm_source=atom&amp;utm_medium=feed">Original</a>
    <h1>Procrastinating on my side project by torturing databases</h1>
    
    <div id="readability-page-1" class="page"><div><p>One of my most insidious procrastination mechanisms is doing things that <em>feel like work</em> but are just a fun diversion.
I ran into that recently for a side project I&#39;m working on.
It wasn&#39;t <em>really</em> necessary to test database options semi-rigorously, but here we are.</p>
<p>This project is one that I really want to use myself, and I think other people will want it, too.
I&#39;m not ready to talk about the overall project much yet, but the constraints here are interesting:</p>
<ul>
<li><strong>Needs to text blobs of &#34;reasonable&#34; size.</strong> These won&#39;t be massive, 10-100 kB seems like the highest I&#39;d reasonably run into. Most will be 1-10 kB. I&#39;ve been bitten by things getting over 8 kB in PostgreSQL and going to slower disk-based storage.</li>
<li><strong>Pageloads must be fast.</strong> I&#39;m building this using HTMX and server-side templates, so for interactions to feel really snappy, I&#39;m aiming for p99 load times to be 50ms. (I may relax this to 100ms.)</li>
<li><strong>I want to minimize ops work.</strong> While I <em>can</em> do ops work, I really don&#39;t want to, so I&#39;m looking for something that achieves these goals with as little fiddling about as possible.</li>
</ul>
<p>Together, these rule out one of the common suggestions of using blob storage for the documents.
For ease of usage, I want to keep things all in the same database if I can.
To make sure I don&#39;t code myself into a corner and have to switch DBs down the road, it looks like we&#39;re going to have a good old database drag race.</p>

<p>Like any good competition, we have a few contenders.
The primary contenders were three relational databases: SQLite, PostgreSQL, and MariaDB.
Here&#39;s why I was looking at these three:</p>
<ul>
<li>SQLite is embedded, so seems like the lightest ops budget for me. I can back it up easily, and streaming replication allows read replicas down the road if I need that.</li>
<li>PostgreSQL is what I&#39;m familiar with and there are good hosted offerings for it. I dunno, it&#39;s the default option for most people it feels like.</li>
<li>MariaDB is what I hear about in the context of needing better-than-PostgreSQL performance.</li>
</ul>
<p>And also the fact that the ORM I&#39;m using supports these three, so it was easy to test comparably across these three!</p>

<p>To test the databases, I subjected them to a variety of synthetic workloads and then tortured them by depriving them of RAM while asking them to fetch the data please-and-thank-you.
This would force them into showing me what their disk-based performance looked like so that I could get an idea of the worst case performance.</p>
<p>The synthetic workload generated 3 GB of rows using random data sized 1 kB, 8 kB, 64 kB, 512 kB, 4 MB, and 32 MB.
This data was generated from a uniform random distribution, so it&#39;s unlikely that compression reduced its size significantly.
I loaded this data into the database with sequential ids, then randomly retrieved rows from it, measuring the average time per row retrieval.</p>
<p>To run this, I put CPU and memory limits on the database containers.
I gave them 1 GB and 2 cores, simulating fairly the amount of RAM I&#39;d have on a particular DB host.
This also requires that not all the data could be held in memory at the same time.</p>
<p>It was around this point that I also gave up on testing MariaDB.
In writing the tests, I had to tweak some things to make the migrations work correctly, and it was going to require some tweaking to get the larger rows to insert and retrieve without hitting payload limits.
It failed on the &#34;minimize ops work&#34; criterion, so toss it out!</p>
<p>The full code for the experiment <a href="https://git.kittencollective.com/nicole/pique/src/branch/main/_experiments/2024-03-02-database-benchmark">is available</a> for those who want to peek under the hood at how I used <a href="https://docs.rs/criterion/latest/criterion/">criterion</a> and <a href="https://www.sea-ql.org/SeaORM/docs/index/">SeaORM</a> for it.</p>
<p>Once the test worked, I just ran it for a while, then got some charts out of it!</p>

<p>SQLite is the database of choice for this project!
It outperformed PostgreSQL with about 10x faster queries once data sizes got reasonable.
This wasn&#39;t due to network latency, since the DB was on the same host as the test.</p>
<p>Here&#39;s what the data looked like for 64 kB documents.
With PostgreSQL and 64 kB documents, we see a mean response time of about 80 ms.</p>
<p><img src="https://www.afterbabel.com/images/dbs/postgres-64kb.svg" alt="Chart showing a mean response time of about 80ms for PostgreSQL."/></p>
<p>With SQLite and 64 kB documents, we see a mean response time of about 0.95 ms.</p>
<p><img src="https://www.afterbabel.com/images/dbs/sqlite-64kb.svg" alt="Chart showing a mean response time of about 0.95ms for SQLite."/></p>
<p>It became pretty clear to me that I&#39;d want to set an upper bound on data sizes, and also that I can be much more generous with that limit in SQLite while still achieving the performance goals I have for this project.</p>
<p>One interesting thing the data showed for SQLite is a bimodal distribution in some of the larger documents.
I&#39;m not sure why this is, so if someone has an idea, I&#39;d love to find out!</p>

<p>While I said I was procrastinating, I was also doing something legitimately useful here: figuring out what could support the performance requirements I have here.
Now I have data to support my decision to use SQLite!</p>
<p>This is how you should make decisions about major underlying technologies when you are able to.
Don&#39;t just read some docs and read some blog posts: go out and test <em>your</em> workload with the tech, in a realistic environment, and see how it will behave for you!
Then you can move forward knowing you&#39;ve found more of the problems at the outset than as surprises down the road.</p>
<p>And now for me?
I guess it&#39;s time to go work on the actual features this is supposed to support.</p>
<hr/>


</div><p>
    If this post was enjoyable or useful for you, <strong>please share it!</strong>
    If you have comments, questions, or feedback, you can email <a href="mailto:me@ntietz.com">my personal email</a>.
    To get new posts and support my work, subscribe to the <a href="https://www.afterbabel.com/newsletter/">newsletter</a>. There is also an <a href="https://www.afterbabel.com/atom.xml">RSS feed</a>.
  </p></div>
  </body>
</html>
