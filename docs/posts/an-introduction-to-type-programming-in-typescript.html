<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.zhenghao.io/posts/type-programming">Original</a>
    <h1>An introduction to type programming in TypeScript</h1>
    
    <div id="readability-page-1" class="page"><div><article><div><p><small>#typescript</small></p><p><time datetime="2022-01-31">31 January, 2022</time></p><p>Learn to write types using the type language and leverage your existing javascript knowledge to master TypeScript quicker</p></div><h2 id="types-are-a-complex-language-of-their-own">Types are a complex language of their own<a href="https://www.zhenghao.io/posts/type-programming#types-are-a-complex-language-of-their-own">#</a></h2>
<p>I used to think of TypeScript as just JavaScript with type annotations sprinkled on top of it. With that mindset, I often found writing correct types tricky and daunting, to a point they got in the way of building the actual applications I wanted to build, and frequently, it led me to reach for <code>any</code>. And with <code>any</code>, I lose all type safety.</p>
<p>Indeed, types can get really complicated if you let them. After writing TypeScript for a while, it occurred to me that the TypeScript language actually consists of two sub-languages - one is JavaScript, and the other is the type language. For the JavaScript language, the world is made of JavaScript values; for the type language, the world is made of types. When we write TypeScript code, we are constantly dancing between these two worlds: we create types in our type world and &#34;summon&#34; them in our JavaScript world using type annotations; we can go in the other direction too: use the <a href="https://www.typescriptlang.org/docs/handbook/2/typeof-types.html#the-typeof-type-operator" target="_blank" rel="noopener noreferrer">typeof operator</a> on JavaScript variables/properties to retrieve the corresponding types.</p>
<p><img src="https://www.zhenghao.io/art/blog/type-programming/twoworlds.png" alt="alt" layout="fill"/></p>
<p>The JavaScript language is very expressive, so is the type language - in fact, the type language is so expressive that it has been proven to be Turing complete.</p>
<p>Here I don&#39;t make any value judgment of whether being Turing complete is good or bad, nor do I know if it is even by design or by accident (in fact, often times, Turing-completeness was achieved <a href="http://beza1e1.tuxen.de/articles/accidentally_turing_complete.html" target="_blank" rel="noopener noreferrer">by accident</a>). My point is the type language itself, as innocuous as it seems, is certainly powerful, highly capable and can perform arbitrary computation at compile time.</p>
<p>When I started to think of the type language in TypeScript as a full-fledged programming language, I realized it even has a few characteristics of a functional programming language:</p>
<ol>
<li>use recursion instead of iteration
<ol>
<li>in <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-5/#tailrec-conditional" target="_blank" rel="noopener noreferrer">TypeScript 4.5</a> we have tail call optimized recursion to some extent</li>
</ol>
</li>
<li>types (data) are immutable</li>
</ol>
<p>In this post, we will learn the type language in TypeScript by comparing it with JavaScript so that you can leverage your existing JavaScript knowledge to master TypeScript quicker.</p>
<blockquote>
<p>This post assumes that readers have some familiarity with JavaScript and TypeScript. And if you want to learn TypeScript from scratch properly, you should start with <a href="https://www.typescriptlang.org/docs/handbook/intro.html" target="_blank" rel="noopener noreferrer">The TypeScript Handbook</a>. I am not here to compete with the docs.</p>
</blockquote>
<h2 id="variable-declaration">Variable declaration<a href="https://www.zhenghao.io/posts/type-programming#variable-declaration">#</a></h2>
<p>In JavaScript, the world is made of JavaScript values, and we declare variables to refer to values using keywords <code>var</code>, <code>const</code> and <code>let</code>. For example:</p>

<p>In the type language, the world is made of types, and we declare type variables using keywords <code>type</code> and <code>interface</code>. For example:</p>

<blockquote>
<p>The idea of &#34;type variables&#34; is a made-up concept - a type variable is an alias of a type, analogous to how a JavaScript variable references a value. I found drawing this analogy makes explaining concepts of the type language much easier.</p>
</blockquote>
<p>Types and values are very related. A type, at its core, represents the set of possible values. Sometimes the set is finite, e.g., <code>type Name = &#39;foo&#39; | &#39;bar&#39;</code>, a lot of times the set is infinite, e.g., <code>type Age = number</code>. In TypeScript we integrate types and values and make them work together to ensure that the runtime values match the compile-time types.</p>
<h3 id="local-variable-declaration">Local variable declaration<a href="https://www.zhenghao.io/posts/type-programming#local-variable-declaration">#</a></h3>
<p>We talked about how you can create type variables in the type language. However, the type variables have a global scope by default. To create a local type variable, we can use the <code>infer</code> keyword in our type language.</p>

<p>Although this particular way of creating scoped variables might seem strange to JavaScript developers, it actually finds its roots in some pure functional programming languages. For example, in Haskell, we can use the <code>let</code> keyword with <code>in</code> to perform scoped assignments as in <code>let {assignments} in {expression}</code>:</p>

<h2 id="equality-comparisons-and-conditional-branching">Equality comparisons and conditional branching<a href="https://www.zhenghao.io/posts/type-programming#equality-comparisons-and-conditional-branching">#</a></h2>
<p>In JavaScript. we can use <code>===</code>/<code>==</code> with if statement or the conditional (ternary) operator <code>?</code> to perform equality check and conditional branching.</p>
<p>In the type language, on the other hand, we use the <code>extends</code> keyword for &#34;equality check&#34;, and the conditional (ternary) operator <code>?</code> for conditional branching too as in:</p>

<p>If <code>TypeA</code> is assignable or substitutable to <code>TypeB</code>, then we enter the first branch and get the type from <code>TrueExpression</code> and assign that to <code>TypeC</code> ; otherwise we get the type from <code>FalseExpression</code> as a result to <code>TypeC</code>.</p>
<blockquote>
<p>The concept of assignability/substitutability is one of the core concepts in TypeScript that deserves a separate post - I wrote <a href="https://www.zhenghao.io/posts/type-hierarchy-tree">one covering that in detail</a>.</p>
</blockquote>
<p>A concrete example in JavaScript:</p>

<p>Translate it into the type language:</p>

<p>The <code>extends</code> keyword is versatile. It can also apply constraints to generic type parameters. For example:</p>

<p>By adding the generic constraints, <code>&lt;T extends {name: string}&gt;</code> we ensure the parameter our function takes always consist of a <code>name</code> property of the type <code>string</code>.</p>
<h2 id="retrieve-types-of-properties-by-indexing-into-object-types">Retrieve types of properties by indexing into object types<a href="https://www.zhenghao.io/posts/type-programming#retrieve-types-of-properties-by-indexing-into-object-types">#</a></h2>
<p>In JavaScript we can access object properties with square brackets e.g. <code>obj[&#39;prop&#39;]</code> or the dot operator e.g., <code>obj.prop</code>.</p>
<p>In the type language, we can extract property types with square brackets as well.</p>

<p>This works not just with object types, we can also index the type with tuples and arrays.</p>

<h2 id="functions">Functions<a href="https://www.zhenghao.io/posts/type-programming#functions">#</a></h2>
<p>Functions are the main reusable “building blocks” of any JavaScript program. They take some input (some JavaScript values) and return an output (also some JavaScript values).
In the type language, we have generics. Generics <strong>parameterize</strong> types like functions <strong>parameterize</strong> value. Therefore, a generic is conceptually similar to a function in JavaScript.</p>
<p>For example, in JavaScript:</p>

<p>For our type language, we have:</p>

<blockquote>
<p>However, generics are by no means a perfect analogy for functions. For one, unlike functions in JavaScript, Generics are not first-class citizens in the type language. That means we cannot pass a generic to another generic like we pass a function to another function as TypeScript doesn&#39;t allow <a href="https://github.com/microsoft/TypeScript/issues/1213" target="_blank" rel="noopener noreferrer">generics as type parameters</a>.</p>
</blockquote>
<h3 id="map-and-filter">Map and filter<a href="https://www.zhenghao.io/posts/type-programming#map-and-filter">#</a></h3>
<p>In our type language, types are immutable. If we want to modify a part of a type, we have to transform the existing ones into <strong>new types</strong>. In the type language, the details of iterating over a data structure (i.e. an object type) and applying transformations evenly are abstracted away by <a href="https://www.typescriptlang.org/docs/handbook/2/mapped-types.html" target="_blank" rel="noopener noreferrer">Mapped Types</a>. We can use it to implement operations that are conceptually similar to the map and filter array methods in JavaScript.</p>
<p>In JavaScript, let&#39;s say we want to transform an object&#39;s properties from numbers to strings:</p>

<p>In the type langauge, the mapping is done using this syntax <code>[K in keyof T]</code> where the <code>keyof</code> operator gives us property names as a string union type.</p>

<p>In JavaScript, we can filter out the properties of an object based on some critiria. For example, we can filter out all non-string properties:</p>

<p>In our type language, this can be achieved with the <code>as</code> operator and the <code>never</code> type:</p>

<p>There are a bunch of builtin <a href="https://www.typescriptlang.org/docs/handbook/utility-types.html" target="_blank" rel="noopener noreferrer">utility “functions”</a> (generics) for transforming types in TypeScript so often times you don&#39;t have to re-invent the wheels.</p>
<h2 id="pattern-matching">Pattern matching<a href="https://www.zhenghao.io/posts/type-programming#pattern-matching">#</a></h2>
<p>We can also use the <code>infer</code> keyword to perform pattern matching in the type language.</p>
<p>For example, in a JavaScript program, we can use regex to extract a part of a string:</p>

<p>The equivalence in our type language:</p>

<h2 id="recursion-instead-of-iteration">Recursion, instead of iteration<a href="https://www.zhenghao.io/posts/type-programming#recursion-instead-of-iteration">#</a></h2>
<p>Just like many pure functional programming languages out there, in our type language, there is no syntactical construct for for loop to iterate over a list of data. Recursion take the place of loops.</p>
<p>Let&#39;s say in JavaScript, we want to write a function to return an array with same item repeated multiple times. Here is one possible way you can do that:</p>

<p>The recurisve solution would be:</p>

<p>How do we write out the equivalence in our type language? Here are logical steps to arrive at one solution:</p>
<ol>
<li>create a generic type called <code>FillArray</code> (remember we talked about that generics in our type language are just like functions?)
<ul>
<li><code>FillArray&lt;Item, N extends number, Array extends Item[] = []&gt;</code></li>
</ul>
</li>
<li>Inside the &#34;function body&#34;, we need to check if the <code>length</code> property on <code>Array</code> is already <code>N</code> using the <code>extends</code> keyword.
<ul>
<li>if it has reached to <code>N</code> (the base case), then we simply return <code>Array</code></li>
<li>if it hasn&#39;t reached to <code>N</code>, it recurses and added one more <code>Item</code> into <code>Array</code></li>
</ul>
</li>
</ol>
<p>Putting these together, we have:</p>

<h3 id="limits-for-recursion-depth">Limits for recursion depth<a href="https://www.zhenghao.io/posts/type-programming#limits-for-recursion-depth">#</a></h3>
<p>Before TypeScript 4.5, the max recursion depth is <a href="https://www.typescriptlang.org/play?ts=4.4.4&amp;ssl=3&amp;ssc=10&amp;pln=3&amp;pc=17#code/C4TwDgpgBAShkENgDkA8BJYEC2AaKyUEAHlgHYAmAzlGQK7YBGEATvgCp1gA20J51KAjIgA2gF0oAXigSAfNKiceEUQHJeZAObAAFmsn8IlGoQD8SrrygAuWPAhI0mHPmT5RAOm-Le+F9jicgDcAFCgkFAAQopwiCioagCMavgALACsCuHg0ACCsQ5OiSnpAGwKAPSVUFTACADGANZQAPYAbqwAZtytAO5AA" target="_blank" rel="noopener noreferrer">45</a>. In TypeScript 4.5, we have tail call optimization, and the limit increased to <a href="https://www.typescriptlang.org/play?ts=4.5.4#code/C4TwDgpgBAShkENgDkA8BJYEC2AaKyUEAHlgHYAmAzlGQK7YBGEATvgCp1gA20J51KAjIgA2gF0oAXigSAfNKiceEUQHJeZAObAAFmsn8IlGoQD8SrrygAuWPAhI0mHPmT5RAOm-Le+F9jicgDcAFChoJBQAIKKcIgoqGoAjGr4AJyZchHg0ABCcQ5OSan4yQAMlQoA9NVQVMAIAMYA1lAA9gBurABm3O0A7qFAA" target="_blank" rel="noopener noreferrer">999</a>.</p>
<h2 id="avoid-type-gymnastics-in-production-code">Avoid type gymnastics in production code<a href="https://www.zhenghao.io/posts/type-programming#avoid-type-gymnastics-in-production-code">#</a></h2>
<p>Sometimes type programming is jokingly referred to as “type gymnastics” when it gets really complex, fancy and far more sophisticated than it needs to be in a typical application.
For example:</p>
<ol>
<li><a href="https://github.com/chinese-chess-everywhere/type-chess" target="_blank" rel="noopener noreferrer">simulating a Chinese chess (象棋)</a></li>
<li><a href="https://blog.joshuakgoldberg.com/type-system-game-engines/" target="_blank" rel="noopener noreferrer">simulating a Tic Tac Toe game</a></li>
<li><a href="https://itnext.io/implementing-arithmetic-within-typescripts-type-system-a1ef140a6f6f" target="_blank" rel="noopener noreferrer">implementing arithmetic</a></li>
</ol>
<p>They are more like academic exercises, not suitable for production applications because:</p>
<ol>
<li>they are hard to comprehend, especially with esoteric TypeScript features.</li>
<li>they are hard to debug due to incredibly long and cryptic compiler error messages.</li>
<li>they are slow to compile.</li>
</ol>
<blockquote>
<p>Just like we have Leetcode for practicing your core programming skills, we have <a href="https://github.com/type-challenges/type-challenges" target="_blank" rel="noopener noreferrer">type-challenges</a> for practicing your type programming skills.</p>
</blockquote>
<h2 id="closing-thoughts">Closing thoughts<a href="https://www.zhenghao.io/posts/type-programming#closing-thoughts">#</a></h2>
<p>We have covered a lot in this blog post. The point of this post is not to really teach you TypeScript, rather than to reintroduce the &#34;hidden&#34; type language you might have overlooked ever since you started learning TypeScript.</p>
<p>Type programming is a niche and underdiscussed topic in the TypeScript community, and I don&#39;t think there is anything wrong with that - because ultimately adding types is just a means to an end, the end being writing more dependable web applications in JavaScript. Therefore, to me it is totally understandable that people don&#39;t often take the time to &#34;properly&#34; study the type language as they would for JavaScript or other programming languages.</p>
<h2 id="further-reading">Further Reading<a href="https://www.zhenghao.io/posts/type-programming#further-reading">#</a></h2>
<ul>
<li><a href="https://gist.github.com/hediet/63f4844acf5ac330804801084f87a6d4" target="_blank" rel="noopener noreferrer">Proof that TypeScript&#39;s Type System is Turing Complete</a></li>
<li><a href="https://itnext.io/typescript-and-turing-completeness-ba8ded8f3de3" target="_blank" rel="noopener noreferrer">TypeScript and Turing Completeness</a></li>
</ul></article></div></div>
  </body>
</html>
