<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.storj.io/blog/lensm">Original</a>
    <h1>Lensm, a tool for viewing disassembly</h1>
    
    <div id="readability-page-1" class="page"><div><p>I couldn‚Äôt find a great tool for viewing disassembly, so I <a href="https://github.com/loov/lensm">wrote it myself over the weekend</a>.</p><p>At Storj, we are constantly looking for ways to accelerate our team‚Äôs efficiency, and one of those is building the tools we need.</p><p>One of the major things you will rub against when you delve into performance optimization is viewing the assembly that the compiler generates. It&#39;s usually not efficient to write assembly yourself, and it&#39;s better to try to coerce the compiler to produce the assembly you want. Here&#39;s my story of writing a little tool for viewing disassembly.</p><p>My story starts on a weekend when I was doing a bunch of tiny optimizations to the <a href="https://gioui.org/">Gio UI</a> project. There are ways to view the assembly; one is to use <strong>go tool objdump -s funcname</strong> from the command line. However, it&#39;s rather difficult to see how the source code and assembly are related.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/602eda09fc78af5a419706be/62d55cb12919477d388915cc_t8ODK_OCt9V0GN9lHO1jcjyu9RUAPpIP9cEvOgvmPiucYhk_aMd-UloDUGJJkcEA1oesZN22AuBJTFu__jToyjt6-GIE7cmVmh76yTpzEEBA2AP5-qIqdz_5B5D444i8BtXaRnM-rc_nGXo9NGE.png" alt=""/></p></figure><p>There is an excellent online tool for writing code and seeing the output <a href="https://go.godbolt.org/">https://go.godbolt.org</a>. The visuals are much clearer.</p><p>The corresponding lines of code have the same color. When you hover over the specific lines of code, the corresponding assembly is also highlighted.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/602eda09fc78af5a419706be/62d55cc602e1d3ed86d1b95e_DMf8jw43xXtFI9VfW3Hj17WssFpJzHrR5lDCejh-3X7phoUaeKtkl3lAHFPvBcgT-gPKgSSj6nCPFXPhi2purUPZsCrZ2SiTZursoz4K6kEUt6Zw1tUzFA3J-hjCQFtqtkrw7MkfPMXuW7X3RQM.png" alt=""/></p></figure><p>Compiler Explorer has many other nice features as well: sharing the result, compiling with different versions, diffing output from different compilers, and description of assembly instructions. The amount of different languages and compilers is staggering.</p><p>Despite how nice Compiler Explorer is, it&#39;s still an online tool, and you need to copy-paste your relevant code to the explorer.</p><p>After trying many times, my annoyance finally kicked in:</p><p><em>&#34;Someone should&#39;ve written this tool already‚Äìit shouldn&#39;t be too difficult.&#34;</em></p><p>Over the years of developing, I&#39;ve found that getting annoyed is a rather excellent way to start a new project.</p><p>The first step in the project was to have access to the disassembly. It would be wasteful to start a disassembler from scratch. I knew that <strong>go tool objdump</strong> could already do it, so maybe they have some library they are using.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/602eda09fc78af5a419706be/62d55cc668b49010e1da87a0_9ZumolrPy31nqggaq6bmyW8SM52RXE8nu1UPccpx8b2swsXLZgCsZ2Zk9RPHOs_b1tfTRiyktO4-ICAZjlVFoujbwMHEvT1RBLPk7ozIchhTGEjpOrvJx8K5MUSLUkIKvku1kPOx89EZ6c0RI2Q.png" alt=""/></p></figure><p>Indeed, they are using a library, but it&#39;s internal to the compiler. The internal library looks pretty nice to use as well. I guess I need to extract it for my own needs. Copying the relevant code and adjusting the import paths was grunt work, but I got it extracted. Luckily the license for the Go code is open-source.</p><p>I needed to expose a little bit more information from the API to access the <a href="https://github.com/loov/lensm/commit/5bb596225accd3d6c0b4dbc13c4e6189c558c879#diff-1596bd8ceb74246828aacab827b39a33075c86baa627fbbeb7491bd31eef1169">necessary details</a>, but I got it working. Here&#39;s the debug print from the initial output:</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/602eda09fc78af5a419706be/62d55cc6a3af67247e7df4fb_qb8O0Gzs-OGv1nnBklsfecHlKD6x7JpTrPfCW_N7KKQi9rcC95pGDTMootqeXThAIVxyViremLEKkBZljKxOEEqROCnD89s3VYdyU6rV9lJQyXQgLK2UtNrEjtmjuBBWJL8QFAcpdAACqhQZOkU.png" alt=""/></p></figure><p>Of course, extracting the internals means needing to keep it manually updated. I&#39;m sure there was a tool to rewrite the paths and keep them automatically updated. Alternatively, maybe the Go project would accept a patch that exposes the information in some JSON format so the visualizer can call the appropriate Go compiler. But all of that is a project for another day.</p><h2>Extracting Source Code</h2><p>The first important step was to figure out the relevant source code that needed to be loaded. This seems a relatively easy thing in concept. It&#39;s mainly &#34;Collect the list of lines per source file&#34;. However, the gotcha is how to represent the data, and similarly, you probably don&#39;t want just the lines but also some of the surrounding code.</p><p>This is the basic structure for representing source:</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/602eda09fc78af5a419706be/62d55d48d4896058b5eb6965_BJUkF2Uiv10IYKczczPkzefpWBzNt4QzGDlC7cJU9OA670QO25JLlNpojNqynyJHwMk3aFuRN1fytiEEvlIeuRcw9qu88diNKMX8g4QtY08nAWBKf_JaELPFRpRNgh0REC_767Sbbp75D6cVPlQ.png" alt=""/></p></figure><p>Every assembly function can have multiple associated <strong>Source</strong> files due to inlining. Similarly, the code needed from different files isn&#39;t contiguous, and you wouldn&#39;t want to show more than is required.</p><p>Most of the data munging is: collect all the source lines, convert them into ranges, expand the ranges (for the surrounding context). We also need to do it in reverse: figure out which lines in disassembly correspond to the source code. Note that each source line can correspond to multiple disassembly lines, and they might not be contiguous.</p><p>Once I got it working, I did a debug print of the relevant source lines:</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/602eda09fc78af5a419706be/62d55cc768b4902b80da87ec_EpbrIxhdW9F6YPsgVzttahc-6E1a9K4K3NuhkZoQbBRHcAf10iM2AHwdNnmF4aOyvtj0Atj7TuihVvPExnRym8JaB2o5G-AnfxKhg7OA8YBGNVQBSSWUncArrpf05OjKJt0dD4K0Iu804GtrXvo.png" alt=""/></p></figure><p>I was trying to optimize the code for <a href="https://gioui.org/">Gio UI</a>, so of course, it was a natural choice for building a tool such as this. It has pretty lovely drawing capabilities that I&#39;ll need.</p><p>The question was then, how should it be visualized. Compiler Explorer visualization is a great starting point. However, it&#39;s not as clear as I would like it to be. When starting the project, I already had a design in mind. There are many source diffing tools that offer visualizing related lines. For example, here is what Meld tool looks like:</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/602eda09fc78af5a419706be/62d55cc66767e74611aa360e_m0noVeRrYWM5IJkJhVOzigPqft8IKGueEubr3DLK4Ai0nzTPHXWvg70UdRclyZruohGiEnLkhU04GSTV1WOprOcoQzvROVf8qVqLKzKNhgny7_nKuK4nPERBTSUy_fE6cmaCb5lL18Sq6Z0qhDI.png" alt=""/></p></figure><p>There are other tools such as Kompare, CodeCompare, Oxygen Compare that offer similar visualization. I really like how it shows how one side is related to the other. To draw the shape, we can use the following idea:</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/602eda09fc78af5a419706be/62d55cc7382d3335e050c095_usrJMIUtSESOyvB0GzlSs6yR1x0Uh6OUe9Sd_KaA12uAdnqSbL3ETP46qLbYAvNS1-OV2o9xAceE1QXyHa2hr911wUwVNm5FXYXhm9yr5WvmNWnCR0sPH77iB1t0IGr0Wjs2nl1Tk3xVd5nozLo.png" alt=""/></p></figure><p><em>The purple lines show the final relation shape. The orange arrows show bezier curve handles.</em></p><p>Drawing the visuals seemed then straightforward:</p><ol role="list"><li>figure out the location of each line of the source and assembly;</li><li>draw the relation shape for each line of source and related assembly lines;</li><li>draw the text on top of the relation shapes.</li></ol><p>One difficult thing people encounter with such projects is: how to choose a random color such that they are distinct, visually pleasing, and code is easy to write. One nice trick I&#39;ve picked up over time is this formula:</p><p><em>¬†¬†¬†¬†¬†¬†¬†hue: index * phi * 2 * PI, saturation: 60%, lightness: 60%</em></p><p>You can adjust the saturation and lightness between 50% to 90% to get different lightness and saturation. If you want a more pastel color look, you would use a lower saturation and higher lightness. For dark mode, you would use lightness below 30%. (The color selection assumes that hue is defined with the range 0 .. 2*PI). There are a few variations of the hue selection:</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/602eda09fc78af5a419706be/62d55cc6291947aee6891f09_jDepN774WglSl6bMQnycbS9HX-BDsvx5RS_fY1vEsyZmiaviZOl2BUvMeBf2_tPJ2Obil58YigtEhxVa2nzz7m2zP6BAOo6YariH3C9_nwyw_bWW-vLphnx9vJFfTvpab7StlD0F1XdDVgIrKts.png" alt=""/></p></figure><p>As you can see, the ùúë = 1.618033988749‚Ä¶ constant allows selecting values on a hue circle such that sequential numbers are different and won&#39;t repeat. If you want a smoother transition, then using i √ó 1/ùúë works a treat. If you want more contrast, then i √ó ùúë √ó 2ùúã is nicer.</p><p>Once you put all these ideas together, you get the first output:</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/602eda09fc78af5a419706be/62d55cc792d7842017b7cca1_vj_GRqrXEcs_dWwyk7qZ-cbU6QwULj0sNybAArPdZn4QX0f5N8GoKcmkw0IxCgwc8NKetA5QXiC_qSa9BRWNqqZuaD5uuhpJpPBIPZu6BuN8h8I1w-WD8zKr8IltoyiPjfp28-ULlCUXv6wGOfM.png" alt=""/></p></figure><p>I also added a small interaction ‚Äì when you hover the mouse over a line of code, it highlights the relation shape.</p><h2>Drawing Jumps</h2><p>The next thing I wanted to visualize was drawing jumps in the code. They are important from a performance perspective. It&#39;s relatively common for disassemblers to draw an arrow from the jump location to the destination. This brings up two problems, detecting the jumps, and figuring out how to draw the lines.</p><p>Unfortunately, the objfile library disassembler doesn&#39;t expose the information whether the instruction is a jump and when it jumps, then where to. I didn&#39;t want to dig too deep into this, so I reached for the usual tool for this ‚Äì regular expression matching. It seemed that all the jumps ended with a hex number, such as <strong>JMP 0x123</strong>... of course, that approach broke. On arm processors, they look like <strong>BLS 38(PC)</strong>. I added a special case for it for now, but it&#39;ll probably break again on some other platform.</p><p>To draw the jumps initially, I just drew them like a stack. In other words, push the jump line to the sidebar when you encounter one and then pop it when it ends. Of course, that didn&#39;t look great due to overlapping lines:</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/602eda09fc78af5a419706be/62d55cc7382d33da3a50c09c__vBqyuDL7Iwp3ZxyvZRiUyK-FoWL5JpH8PR7-UgVOr1Iw2vE6RFeM6syPPmhbeDfPLzoEWFEPzZYnA3k-X_6400rJYVj8BYQbIT66K-ITM3p9O61nnlzBK-LDwT-_z9Bs_HDhByCaFBuytRNe7s.png" alt=""/></p></figure><p>In some cases it even caused the lines to be on top of each other. I searched for a nice algorithm for drawing them; however, I came up empty. Finally, I decided to go with the following approach, sort all the jump ranges based on their starting and ending point. If multiple ranges start from the same location, the larger range is sorted first. Then divide the sidebar into lanes; every new range picks the first lane that is free ‚Äì starting from the left. This ends up minimizing crossings.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/602eda09fc78af5a419706be/62d55cc733365697a909185c_PGA8v7YrP_F3LQKUIGUH9PZ8XpRfsEHP_Qyc6sKvZNavb-xgdPOWrquHLk1oaLEDEx00aBkwdrCLdm152__r96IX9HTiUqEfExezajtIZV_oVZNVu6fM89Xdu4JcG8w64ueUPFl30ILIdZQlQJ4.png" alt=""/></p></figure><p>It&#39;s by no means ideal. It can still draw the jump line too far from the code.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/602eda09fc78af5a419706be/62d55cc7557a628d36655417_cOlVg7oIrOA5VJ-IPJujha90ug3CYdF9ENhcbtkQekQhn-RhI-3ry2gMUo9HZBMPfmOLTgZjcJK2zbCrucMUf1IYYU9cZDdQzQmRBHkSjkIJzxEWsuKNuC16mzuS_FGweaQK0Q7jAl_53bio3S4.png" alt=""/></p></figure><p>Or do this thing here:</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/602eda09fc78af5a419706be/62d55cc74d138d629ee5bd63_oFJWLa1Kq1CQiIR9t4Uw0VRB4VJ5M1DAzUGp5fsxky3zNkmb0EM6LERZ_eZJSC01cV_ar1JVESdMP4PSZY2n6k946gE2jSVlWUU-JYSQqiLTFNVhlt2s0y3ujeqBhRhDPECjMJL6b2N5MS5yVl4.png" alt=""/></p></figure><p>But, these are things someone will fix some other day.</p><p>After a few days of work, I have a nice tool for viewing disassembly. </p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/602eda09fc78af5a419706be/62d55cc724fc82ab5179a8e9_nn9EQG2KhJKrJqL0g9OwAKDzdb5-N9OcWcWKsKNbFs3GoOlsqPdbEEvGWPE5Ncnq0qd1og8yMFVgTvmx2QkKwo7suFvnHJCXVEx1iTAmGddNDUumhTB-ugVIZfbT9nuJWka92IvIp6MQFT3x5jU.png" alt=""/></p></figure><p>Choosing a name was also a struggle. I wanted it to be easily recognizable and searchable. I asked in Gophers #performance channel and Jan Mercl suggested &#34;lensm,&#34; which is &#34;lens&#34; and &#34;asm&#34; smushed together.</p><p>When you look at the code and think: &#34;For a performance-conscious project, it doesn&#39;t look very efficient ‚Äì allocations and suboptimal algorithms everywhere. Also, the code looks very messy.&#34;</p><p>That&#39;s all true, but the goal was to get it done quickly. And, if I do need to optimize, then I have an extra tool in my toolbelt to optimize it.</p><p>I&#39;ll still have a few things I want to add before I can call it sufficiently complete. Nevertheless, it&#39;s already functional, so give it a test run at <a href="https://github.com/loov/lensm">https://github.com/loov/lensm</a>. If you feel like something is missing, then come along for the ride and submit a patch; there have already been a few contributors.</p></div></div>
  </body>
</html>
