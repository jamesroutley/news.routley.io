<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://numba.pydata.org/">Original</a>
    <h1>Numba: A High Performance Python Compiler</h1>
    
    <div id="readability-page-1" class="page"><div>

        <div>
          <div>
            <h2>Accelerate Python Functions</h2>
            <p>Numba translates Python functions to optimized machine code at runtime using the
              industry-standard <a href="https://llvm.org/">LLVM</a> compiler library. Numba-compiled numerical algorithms in Python can approach the speeds of C or FORTRAN.</p>
            <p>You don&#39;t need to replace the Python interpreter, run a separate compilation step, or even
              have a C/C++ compiler installed. Just apply one of the Numba decorators to your Python function, and Numba does the rest.
            </p>
            <p><a href="https://numba.readthedocs.io/en/stable/user/jit.html" role="button">Learn More »</a>
            <a href="https://mybinder.org/v2/gh/numba/numba-examples/master?filepath=notebooks%2Fbasics.ipynb" role="button">Try Now »</a>
          </p></div>

          <div>
            <pre><code>from numba import njit
import random

@njit
def monte_carlo_pi(nsamples):
    acc = 0
    for i in range(nsamples):
        x = random.random()
        y = random.random()
        if (x ** 2 + y ** 2) &lt; 1.0:
            acc += 1
    return 4.0 * acc / nsamples</code></pre>
          </div>
        </div>

        <hr/>

        <div>
          <div>
            <h2>Built for Scientific Computing</h2>
            <p>Numba is designed to be used with NumPy arrays and functions.  Numba generates specialized code for
              different array data types and layouts to optimize performance.  Special decorators can create <a href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html">universal functions</a> that broadcast over NumPy arrays just like NumPy functions do.</p>
            <p>Numba also works great with Jupyter notebooks for interactive computing, and with distributed execution frameworks, like Dask and Spark.</p>
            <p><a href="https://numba.readthedocs.io/en/stable/reference/numpysupported.html" role="button">Learn More »</a>
            <a href="https://mybinder.org/v2/gh/numba/numba-examples/master?filepath=notebooks%2Fnumpy.ipynb" role="button">Try Now »</a>
          </p></div>

          <div>
            <pre><code>@njit(parallel=True)
def logistic_regression(Y, X, w, iterations):
    for i in range(iterations):
        w -= np.dot(((1.0 /
              (1.0 + np.exp(-Y * np.dot(X, w)))
              - 1.0) * Y), X)
    return w</code></pre>
          </div>
        </div>

        <hr/>

        <div>
        <h2>Parallelize Your Algorithms</h2>
        <p>Numba offers a range of options for parallelizing your code for CPUs and GPUs, often with only minor code changes.</p>
        <div>

          <div>
            <h2>Simplified Threading</h2>
            <pre><code>@njit( parallel=True)
def simulator(out):
    # iterate loop in parallel
    for i in prange(out.shape[0]):
        out[i] = run_sim()</code></pre>
            <p>Numba can automatically execute NumPy array expressions on multiple CPU cores and makes it easy to write parallel loops.</p>
            <p>
              <a href="https://numba.readthedocs.io/en/stable/user/parallel.html" role="button">Learn More »</a>
              <a href="https://mybinder.org/v2/gh/numba/numba-examples/master?filepath=notebooks%2Fthreads.ipynb" role="button">Try Now »</a>
            </p>
          </div><!-- /.col-lg-4 -->
          <div>
            <h2>SIMD Vectorization</h2>
            <pre><code>LBB0_8:
    vmovups (%rax,%rdx,4), %ymm0
    vmovups (%rcx,%rdx,4), %ymm1
    vsubps  %ymm1, %ymm0, %ymm2
    vaddps  %ymm2, %ymm2, %ymm2</code></pre>
            <p>Numba can automatically translate some loops into vector instructions for 2-4x speed improvements.  Numba adapts to your CPU capabilities, whether your CPU supports SSE, AVX, or AVX-512.</p>
            <p>
              <a href="https://numba.readthedocs.io/en/stable/user/performance-tips.html" role="button">Learn More »</a>
              <a href="https://mybinder.org/v2/gh/numba/numba-examples/master?filepath=notebooks%2Fsimd.ipynb" role="button">Try Now »</a>
            </p>
          </div><!-- /.col-lg-4 -->
          <div>
            <h2>GPU Acceleration</h2>
            <p><img src="https://numba.pydata.org/_static/nvidia_cuda.jpg" alt="NVIDIA CUDA logo"/></p><p>With support for NVIDIA CUDA, Numba lets you write parallel GPU algorithms entirely from Python.</p>
            <p>
              <a href="https://numba.readthedocs.io/en/stable/cuda/index.html" role="button">Numba CUDA »</a>
            </p>
          </div><!-- /.col-lg-4 -->
        </div><!-- /.row -->
        </div>

        <hr/>

        <div>
          <div>
            <h2>Portable Compilation</h2>
            <p>Ship high performance Python applications without the headache of binary compilation and packaging.  Your source code remains pure Python while Numba handles the compilation at runtime.  We test Numba continuously in more than 200 different platform configurations.</p>
            <p>Numba supports Intel and AMD x86, POWER8/9, and ARM CPUs (including Apple M1), NVIDIA GPUs, Python 3.7-3.10, as well as Windows/macOS/Linux.  Precompiled Numba binaries for most systems are available as conda packages and pip-installable wheels.</p>
            <p><a href="https://numba.readthedocs.io/en/stable/user/installing.html" role="button">Learn More »</a>
          </p></div>
        </div>
      </div></div>
  </body>
</html>
