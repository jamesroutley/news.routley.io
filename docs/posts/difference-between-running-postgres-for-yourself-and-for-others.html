<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.ubicloud.com/blog/difference-between-running-postgres-for-yourself-and-for-others">Original</a>
    <h1>Difference between running Postgres for yourself and for others</h1>
    
    <div id="readability-page-1" class="page"><div id="w-node-decdb48f-56e8-4c35-c577-932285e9b439-26cb5815"><p>July 22, 2024 · 8 min read</p><div><p><img src="https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669a6467d686c690fa7e7ac6_Burak.jpg" loading="lazy" sizes="40px" srcset="https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669a6467d686c690fa7e7ac6_Burak-p-500.jpg 500w, https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669a6467d686c690fa7e7ac6_Burak.jpg 512w" alt=""/></p><div><p>Burak Yucesoy</p><p>Principal Software Engineer</p></div></div><p>Over the past ten years, we collaborated with many PostgreSQL users. From users who run their own Postgres deployments, we often hear the question, “I can put Postgres in a container and deploy it. Could you help me with taking backups and HA?&#34;</p><div id="sign-up-and-sign-in"><h3>Managed PostgreSQL Features</h3><p>When you’re running PostgreSQL yourself, you’re primarily concerned about backups and HA. Users who’ve been running Postgres for a few years also think about version upgrades.</p></div><p><img src="https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669e7f704fa1c0c633ac0e50_managedPG.png" loading="lazy" sizes="(max-width: 479px) 93vw, (max-width: 767px) 92vw, (max-width: 991px) 94vw, (max-width: 1439px) 58vw, 748.796875px" srcset="https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669e7f704fa1c0c633ac0e50_managedPG-p-500.png 500w, https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669e7f704fa1c0c633ac0e50_managedPG-p-800.png 800w, https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669e7f704fa1c0c633ac0e50_managedPG-p-1080.png 1080w, https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669e7f704fa1c0c633ac0e50_managedPG.png 1860w" alt=""/></p><p>First, you need to start with provisioning a database. Then you need to introduce DNS, certificates, backup / restore, internal APIs, UI, security, and so forth. These features are also all interconnected. For example, in order to have a highly available PostgreSQL database, you first need to have monitoring and you need to orchestrate failovers. Or, to have read replicas, first, you need to build backups.</p><div id="sign-up-and-sign-in"><h3>On-Demand Provisioning</h3><p><img src="https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669e7f09a8531bd5323a1c52_on-demand3.png" loading="lazy" sizes="(max-width: 479px) 93vw, (max-width: 767px) 92vw, (max-width: 991px) 94vw, (max-width: 1439px) 58vw, 748.796875px" srcset="https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669e7f09a8531bd5323a1c52_on-demand3-p-500.png 500w, https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669e7f09a8531bd5323a1c52_on-demand3-p-800.png 800w, https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669e7f09a8531bd5323a1c52_on-demand3-p-1080.png 1080w, https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669e7f09a8531bd5323a1c52_on-demand3-p-1600.png 1600w, https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669e7f09a8531bd5323a1c52_on-demand3.png 2128w" alt=""/></p><p>When you’re managing your own Postgres deployments, provisioning looks easy. You provision a VM, install the PostgreSQL binaries, and you give the connection string back to your users.</p></div><div id="sign-up-and-sign-in"><p><img src="https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669e7f09019599de26fc1142_on-demand2.png" loading="lazy" sizes="(max-width: 479px) 93vw, (max-width: 767px) 92vw, (max-width: 991px) 94vw, (max-width: 1439px) 58vw, 748.796875px" srcset="https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669e7f09019599de26fc1142_on-demand2-p-500.png 500w, https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669e7f09019599de26fc1142_on-demand2-p-800.png 800w, https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669e7f09019599de26fc1142_on-demand2-p-1080.png 1080w, https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669e7f09019599de26fc1142_on-demand2-p-1600.png 1600w, https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669e7f09019599de26fc1142_on-demand2.png 2070w" alt=""/></p><p>Finally, you also need to create DNS records. This way, the connection string doesn’t have an IP address but a more memorable DNS name. DNS record’s benefit isn’t just representation. In some cases you would need to perform a failover (for example if HA is enabled and the primary node is down). It is crucial for users to be able to continue the same connection string even if the underlying VM changes. Otherwise, failovers would require action from the user and this would defeat the purpose of managed PostgreSQL service.</p><ul role="list"><li>Provisioning the VM</li><li>Creating the server certificate</li><li>Configuring PostgreSQL settings</li><li>Creating DNS records</li></ul><p>None of the other steps depend on certificate creation, so we can separate out the certificate creation and run it in parallel with the other steps. Once the parallel steps complete, we can return the connection string back to the user. This reduces the database provisioning time to 2-2.5 minutes.</p></div><div id="sign-up-and-sign-in"><h3>Backup/Restore</h3><p>Our goal here is being able to restore the database to any minute in the past. For this, you need to take a full backup of your database <em>and</em> record incremental changes happening in your database. This feature is called point-in-time-restore (PITR) and comes in handy when you want to have other features, such as forking your Postgres database.</p></div><div id="sign-up-and-sign-in"><p><img src="https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669e7f092f3b5f32f579cc19_backup%26restore.png" loading="lazy" sizes="(max-width: 479px) 93vw, (max-width: 767px) 92vw, (max-width: 991px) 94vw, (max-width: 1439px) 58vw, 748.796875px" srcset="https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669e7f092f3b5f32f579cc19_backup%26restore-p-500.png 500w, https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669e7f092f3b5f32f579cc19_backup%26restore-p-800.png 800w, https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669e7f092f3b5f32f579cc19_backup%26restore-p-1080.png 1080w, https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669e7f092f3b5f32f579cc19_backup%26restore.png 2071w" alt=""/></p><p>This works well on paper, but comes with two problems in PostgreSQL. </p></div><div id="create-vm"><h3>High Availability</h3><p><img src="https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669e7f093c0957f11301d6e6_HA.png" loading="lazy" sizes="(max-width: 479px) 93vw, (max-width: 767px) 92vw, (max-width: 991px) 94vw, (max-width: 1439px) 58vw, 748.796875px" srcset="https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669e7f093c0957f11301d6e6_HA-p-500.png 500w, https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669e7f093c0957f11301d6e6_HA-p-800.png 800w, https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669e7f093c0957f11301d6e6_HA-p-1080.png 1080w, https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669e7f093c0957f11301d6e6_HA-p-1600.png 1600w, https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669e7f093c0957f11301d6e6_HA.png 2109w" alt=""/></p></div><p>HA has a simple workflow. You provision a primary and standby database and then run regular health checks on both databases. At Ubicloud, we use a simple <span>SELECT 1;</span> to reason about the database’s health; and then trigger a failover if we deem the database to be unhealthy.</p><p><img src="https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669e7f098b5b735fa140a32c_HA-failover.png" loading="lazy" sizes="(max-width: 479px) 93vw, (max-width: 767px) 92vw, (max-width: 991px) 94vw, (max-width: 1439px) 58vw, 748.796875px" srcset="https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669e7f098b5b735fa140a32c_HA-failover-p-500.png 500w, https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669e7f098b5b735fa140a32c_HA-failover-p-800.png 800w, https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669e7f098b5b735fa140a32c_HA-failover-p-1080.png 1080w, https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669e7f098b5b735fa140a32c_HA-failover-p-1600.png 1600w, https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669e7f098b5b735fa140a32c_HA-failover.png 2109w" alt=""/></p><p>Further, since we can’t failover before fencing the primary, any second we spend here directly affects the down time, so we need to be fast. For this reason, we apply all fencing solutions in parallel. First, if the server is accessible, we kill the PostgreSQL database and ensure that it can’t come back up. Second, we detach the network interface, so no new connections can arrive to or exit from the VM. Third, we deprovision the VM entirely.</p><h3>Security</h3><p>Did you know that with one simple trick you can drop to the OS from PostgreSQL and managed service providers hate that? The trick is <span>COPY table_name from COMMAND</span>. <span>COPY</span> is a useful Postgres command to copy data between files and tables. However, <span>COPY</span> also has the option to run COMMAND. So, you can run OS commands like the following.</p><p><img src="https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669a5edda8e5f0da474244e3_table%20command.png" loading="lazy" sizes="100vw" srcset="https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669a5edda8e5f0da474244e3_table%20command-p-500.png 500w, https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669a5edda8e5f0da474244e3_table%20command-p-800.png 800w, https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669a5edda8e5f0da474244e3_table%20command-p-1080.png 1080w, https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669a5edda8e5f0da474244e3_table%20command-p-1600.png 1600w, https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669a5edda8e5f0da474244e3_table%20command-p-2000.png 2000w, https://cdn.prod.website-files.com/64f9d9b4e737e7b37d4e39a4/669a5edda8e5f0da474244e3_table%20command.png 2432w" alt=""/></p><div><div><div><pre><code>
postgres=# CREATE TABLE command_results(r text);
CREATE TABLE
postgres=# COPY command_results FROM PROGRAM &#39;ls&#39;;
COPY 25
postgres=# SELECT * FROM command_results LIMIT 10;
        r
------------------
 PG_VERSION
 base
 current_logfiles
 global
 pg_commit_ts
 pg_dynshmem
 pg_log
 pg_logical
 pg_multixact
 pg_notify
(10 rows)

postgres=#
   </code>
</pre></div></div></div><p>With these commands, you’re basically seeing the files in your Postgres directory. If the PostgreSQL user isn’t isolated enough, you could run COPY and read the files that you shouldn’t have access to or install binaries on the OS.</p><h3>Conclusion</h3><p>Our team built managed PostgreSQL solutions in different companies over the past ten years. In that time, we observed that there were important differences between running PostgreSQL for yourself and managing it for others. In this blog post, we described some of those differences.</p></div></div>
  </body>
</html>
