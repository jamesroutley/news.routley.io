<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.fponzi.me/2024-05-30-distributed-snapshots.html">Original</a>
    <h1>Distributed Snapshots: Chandy-Lamport Protocol</h1>
    
    <div id="readability-page-1" class="page"><article>
        
        <p>Published on 2024-05-30 | Last update: 2024-06-01 | 10 min read</p>
        <details open="">
            <summary>Table of Contents</summary>
            
        </details>
        <p>Some <em>forms</em> of distributed snapshots were around for a while already when Chandy-Lamport&#39;s distributed snapshots paper was first published in 1985. Lamport <a href="http://lamport.azurewebsites.net/pubs/pubs.html#chandy">considers this protocol</a> a straightforward application of the basic ideas from <a href="https://blog.fponzi.me/2024-02-02-lamport-clocks.html">Lamport clocks</a>. Other than reviewing the paper, in this post I&#39;ll also present some examples of real world implementations and a TLA+ specification of the protocol.</p>
<h2 id="what-problem-is-it-trying-to-solve">What problem is it trying to solve?</h2>
<p>You need to record the global state of a program. Why? Because, for example, you have some complex computation ongoing, and you want to know which step has reached. Or you have a long-running computation, and you want to take a snapshot as a backup to allow restarting the computation again from the checkpoint rather than from the beginning in case any machine fails.</p>
<p>For the state of the program, we refer to the local variables and in general to the history of states that the program went through.</p>
<p>Why is taking snapshots hard? Well, first of all, the snapshotting algorithm should not interfere with the running computation.</p>
<p>Secondly, if your program is a single process on a single machine, this is straightforward! You could create an api to say &#34;record the snapshot in 5 seconds&#34; or &#34;every 2 hours&#34;. For a multi-thread/multiprocess program running on a single machine, you can create a similar api.</p>
<p>In a distributed system, this api won&#39;t work because there is no global shared clock. You could end up with out-of-sync snapshots providing an inconsistent view of the system. Other than the state of the process itself, we could also have inflight messages that should be included in the snapshot. As an example of inconsistent snapshot, a process B could record that it received a message from A and A&#39;s snapshot does not include that the message was sent over to B.</p>
<p>The paper has a good visual representation: imagining you wanted to take a picture of a sky filled with migrating birds. One photo is not enough, you will need to take multiple pictures and stitch them together in a way that provides a consistent view of the landscape. This is the challenge that this paper is trying to solve.</p>
<p><img src="https://blog.fponzi.me/2024-05-30-distributed-snapshots/distributed-snapshots-flocks-of-swallows.jpg" alt=""/></p>
<h2 id="what-can-we-use-it-for">What can we use it for?</h2>
<p>More generally, we can use such a global-state detection algorithm to verify <strong>stability properties</strong>. Stability properties are monotonic in a way that if they hold now, they will keep holding forever. For example, properties like &#34;has the computation reached the n-th step&#34; or &#34;is there a deadlock&#34;.</p>
<p>A more formal description of stability properties is the following. Given a property $y$, a state $S$ and any state $S&#39;$ reachable from $S$, $y$ is a <strong>stability property</strong> iff $y(S) -&gt; y(S&#39;)$.</p>
<h2 id="system-model">System model</h2>
<p>The system is composed of a set of processes which communicate between each other using channels—any process has a &#34;logical&#34; channel to every other process.</p>
<p>Channels are assumed to:</p>
<ul>
<li>
<p>have infinite buffers,</p>
</li>
<li>
<p>be error-free,</p>
</li>
<li>
<p>have finite delivery delay,</p>
</li>
<li>
<p>deliver messages in the order sent (FIFO order).</p>
</li>
</ul>
<p>While the state of the channel is the sequence of messages sent along the channel, the process is defined by a set of states, an initial state and a set of events. Each event is atomically changing the state of the process p and the state of at most one channel c incident of p.</p>
<p>This way of describing a process using a state machine and a set of actions that change its state is common in Lamport&#39;s writing. In the paper, there is a reference to <a href="https://blog.fponzi.me/2024-02-02-lamport-clocks.html">Lamport clocks</a> which also has a similar approach to describe processes and actions. As a funny insight, the paper also references &#34;<code>LAMPORT, L., AND CHANDY, K. M. On partially-ordered event models of distributed computations. Submitted for publication.</code>&#34; which according to Lamport <a href="http://lamport.azurewebsites.net/pubs/pubs.html#chandy">himself</a>:</p>
<blockquote>
<p>In 2012, a reader noticed that the paper&#39;s reference list includes a paper by Chandy and me titled <em>On Partially-Ordered Event Models of Distributed Computations</em>, claiming it had been submitted for publication.  Several times I have made the mistake of referencing a paper of mine &#34;to appear&#34; that never appeared.  But I can&#39;t imagine that I would have claimed that a nonexistent paper had been submitted for publication.  However, neither Chandy nor I have any memory of that paper or the reference.  My guess is that we inserted the reference in a preliminary version when we expected to write and submit the other paper, and then we forgot to remove it.</p>
</blockquote>
<blockquote>
</blockquote>
<p>I think it&#39;s easier to think channels as being unidirectional - process  $P_i$ can send a message to process $P_j$ by using channel $C_{ij}$ . Every process is connected with a unidirectional channel to every other process.</p>
<p><a href="https://mermaid.live/edit#pako:eNpFjzELwjAQhf9KuLlZHDO46KhQdJMsR3PVC01S0osgpf_d1Cq-6d7H4_Fuhi45AgOToNCR8Z4x6OfORlXlOFMnnKI6XTbSstJ6r1qvjDqw_0K_QV6hZ2ggUA7IrvbOa8SCPCiQBVNPRz2WQSzYuNQoFknXV-zASC7UQBndf8kPjhhvKVXb4zBVT44l5fM2_fPB8ga7JECH"><img src="https://mermaid.ink/img/pako:eNpFjzELwjAQhf9KuLlZHDO46KhQdJMsR3PVC01S0osgpf_d1Cq-6d7H4_Fuhi45AgOToNCR8Z4x6OfORlXlOFMnnKI6XTbSstJ6r1qvjDqw_0K_QV6hZ2ggUA7IrvbOa8SCPCiQBVNPRz2WQSzYuNQoFknXV-zASC7UQBndf8kPjhhvKVXb4zBVT44l5fM2_fPB8ga7JECH?type=png" alt=""/></a></p>
<h2 id="globalstatedetection-algorithm">Global-State-Detection Algorithm</h2>
<p>The execution is decentralized, i.e., there is no &#34;master&#34; process coordinating the snapshot and can be initiated by any process. It&#39;s also important to notice that the algorithm is correct even if two processes start the snapshot protocol around the same time unbeknownst to each other.</p>
<p>The provided solution is designed to solve this problem only once (take one single snapshot)—extending it to multiple runs should be trivial.</p>
<p>The algorithm works by sending special messages called &#34;marker message&#34; through the channels. Processes will behave differently depending on if they ever received a marker message before. These marker messages are part of the algorithm and not part of the underlying computation - they won&#39;t appear in the snapshot itself. Essentially, when a process $P_i$ receives a first marker message through a channel, it will record its own state and start recording incoming messages from all the channels. It will stop recording incoming messages from a channel as soon as it receives a marker message through there. Let&#39;s see the rules in more detail.</p>
<p><strong>Marker sending rule for Process $P_i$</strong>:</p>
<p>In this case, <strong>$P_i$</strong> decides to start the snapshot algorithm.</p>
<pre><code>P_i records its state
for each outgoing channel C_ij:
	P_i sends marker message over C_ij
	P_i starts recording incoming messages over C_ij
</code></pre>
<p><strong>Marker receiver rule for process</strong> $P_i$<strong>:</strong></p>
<p>Given processes $P_i$, $P_j$ and a channel $C_{ij}$, when $P_i$ receives a <em>marker</em> message from $P_j$ through $C_{ij}$:</p>
<pre><code>if it is the first marker ever received:
	records its state
	records the state of C_ij as the empty set
	sends a marker message over all its outgoing channels 
	starts recording messages coming from other channels
else
	records the state of C_ij as the set of messages received over C_ij 
		since it started recording
</code></pre>
<h2 id="what-makes-a-snapshot-consistent-or-valid">What makes a snapshot consistent (or valid)?</h2>
<p>On one hand, a global state is consistent if for all &#34;received message x&#34; event implies that our snapshot also includes the correspondent &#34;sent message x&#34; event. It would be weird if one process claimed to have received a message and the sender doesn&#39;t seem to know about it.</p>
<p>On the other hand, our snapshot should not include messages that are sent by a process <em>after</em> it has recorded its own state.</p>
<p>These two consistency properties define what should be included and what should be excluded from the snapshot to have a consistent global state.</p>
<p>More formally, a global state GS is defined as the union of all local states LS and channel states SC:</p>
<p>$$GS={\bigcup_{i}LS_i, \bigcup_{i}SC_{ij}}$$</p>
<p>and GS is a consistent global state if the two properties are satisfied:</p>
<ul>
<li>
<p>Property C1: $send(m_{ij}) \in LS_i =&gt; m_{ij} \in SC_{ij} \oplus rec(m_{ij}) \in LS_j$</p>
</li>
<li>
<p>Property C2: $send(m_{ij}) \notin LS_i =&gt; m_{ij} \notin SC_{ij} \land rec(m_{ij}) \notin LS_j$</p>
</li>
</ul>
<h2 id="how-to-collect-the-snapshots">How to collect the snapshots?</h2>
<p>The algorithm only solves the problem of taking the consistent snapshot, but doesn&#39;t provide a way to collect them. In the paper, they offer a simple solution to this problem:</p>
<blockquote>
<p>A simple algorithm for collecting information in a system whose topology is strongly connected is for each process to send the information it records along all outgoing channels, and for each process receiving information for the first time to copy it and propagate it along all of its outgoing channels.</p>
</blockquote>
<blockquote>
<p>All the recorded information will then get to all the processes in finite time, allowing all processes to determine the recorded global state.</p>
</blockquote>
<h2 id="systems-implementing-this-algorithm">Systems implementing this algorithm</h2>
<p>These are the systems that have implemented distributed snapshots and use it in their operations.</p>
<p><strong>Hazelcast Jet</strong>, a distributed stream processor, uses Distributed Snapshots to achieve fault tolerance for distributed computations.</p>
<blockquote>
<p>At regular intervals, Jet raises a global flag that says &#34;it&#39;s time for another snapshot&#34;. All processors belonging to source vertices observe the flag, save their state, emit a barrier item to the downstream processors and resume processing.</p>
</blockquote>
<blockquote>
</blockquote>
<p>Source: <a href="https://web.archive.org/web/20230316115201/https://jet-start.sh/docs/architecture/fault-tolerance">Official docs</a>, <a href="https://arxiv.org/pdf/2103.10169">Paper</a>.</p>
<p><strong>Apache Flink</strong>, a stream processing framework, uses distributed snapshots in two ways:</p>
<blockquote>
<p>First, it is used as a checkpointing for the regular backup of the global state. When applications fail, it is used for recovery. Second, it is used for deadlock detection. The current program continues to run after it is snapshot. Then, the snapshot is analyzed to see if a deadlock state exists in the application. If so, the corresponding processing will be carried out.</p>
</blockquote>
<p>In Flink, at the end of the snapshot protocol, the snapshot collector (Central Server) starts collecting snapshots to form global consistency snapshots.</p>
<p>Source: <a href="https://www.alibabacloud.com/blog/flink-course-series-4-fault-tolerance-in-flink_597985">Flink Course Series (4): Fault Tolerance in Flink—On AlibabaCloud blog</a>.</p>
<p>Let me know if you have other examples, and I will add them here!</p>
<h2 id="tla-specification">TLA+ specification</h2>
<p>I&#39;ve written the specification of this protocol using TLA+ and Pluscal. I will quickly highlight some interesting parts, and you can check the rest on <a href="https://github.com/FedericoPonzi/tla-plus-specs/">GitHub</a>.</p>
<p>Let&#39;s talk about channels. Initially I decided to model them as an array of arrays, where <code>channel[i][j]</code> would contain messages to process <code>i</code> from process <code>j</code>. This was very verbose to work with, eventually I&#39;ve refactored them to be an array of messages, with messages using the format &#34;<code>[sender, content]</code>&#34;. This also allows for just using head to get the next message and work with one message at a time.</p>
<p>I&#39;ve decided to model a fictional computation. Other than snapshot related actions, a process can:</p>
<ul>
<li>
<p>increase a local &#34;computation&#34; counter</p>
</li>
<li>
<p>send a message with the local computation counter to all the other processes. This is just to create some &#34;noise&#34; in the channels.</p>
</li>
</ul>
<p>This local counter will act as a logical clock which I&#39;ve used to help verify the consistency properties C1 and C2.</p>
<p>For condition C1:</p>
<pre><code>\* Any message that is sent by a process before recording its snapshot, 
\* must be recorded in the global snapshot
ConsistentGlobalStateCondition1 == \A proc \in DOMAIN snapshot:
                                       \A receiver \in DOMAIN snapshot[proc][&#34;chans&#34;]:
                                            \A recordedMessage \in DOMAIN snapshot[proc][&#34;chans&#34;][receiver]:
                                                snapshot[proc][&#34;chans&#34;][receiver][recordedMessage] &lt; snapshot[proc][&#34;computation&#34;]
</code></pre>
<p>Essentially, this is checking that all the messages sent by this process as recorded by all the other processes, should have a timestamp less than the process&#39; recorded timestamp.</p>
<p>It&#39;s also interesting to note that TLA+ doesn&#39;t allow to use the format $\forall\ i \in [1,2,3]$. However, because sequences are just functions, we can use <code>DOMAIN</code> to get the domain of that function as a set and use it to iterate on the list. The domain of the sequence is effectively a set that contains the indexes <code>1..n</code>.</p>
<p>The condition C2:</p>
<pre><code>\* Any message that is sent by a process after recording its snapshot,
\* must not be recorded in the global snapshot
ConsistentGlobalStateCondition2 == \A procSnapshot \in DOMAIN snapshot:
                                        snapshot[procSnapshot][&#34;computation&#34;] # Null =&gt; \A proc \in DOMAIN channels:
                                            \A msg \in DOMAIN channels[proc]:                                        
                                                channels[proc][msg][&#34;sender&#34;] = procSnapshot =&gt; 
                                                    \/ channels[proc][msg][&#34;content&#34;] = Marker
                                                    \/ snapshot[procSnapshot][&#34;computation&#34;] &lt; channels[proc][msg][&#34;content&#34;]
</code></pre>
<p>This ensures that after the snapshot is taken, any message flowing through the channels has a greater timestamp than the recorded computation.</p>
<p>And finally, the property to satisfy is:</p>
<pre><code>ConsistentGlobalState == /\ ConsistentGlobalStateCondition1 
                         /\ ConsistentGlobalStateCondition2
</code></pre>
<p>I&#39;ve also reused the trick I&#39;ve learnt from the Lamport Clock spec to bound the model size.</p>
<pre><code>\* State constraint to keep the model bounded
MaxCompMessagesConstraint == \A proc \in Processes: compMsgSent[proc] &lt; MaxCompMessages
MaxCompStateConstraint == \A proc \in Processes: computation[proc] &lt; MaxCompState
</code></pre>
<p>This will put an end to the otherwise infinite computation.</p>
<p>I&#39;ve also decided to model a Termination property to ensure the protocol eventually ends:</p>
<pre><code>\* If snapshot is taken anywhere, eventually every state is recorded and every channel is recorded up to the first Marker msg.
Snapshot == &lt;&gt;[] \E proc \in DOMAIN snapshot: 
                snapshot[proc][&#34;computation&#34;] # Null =&gt; /\ EveryStateIsRecorded 
                                                        /\ EveryChannelIsRecorded
</code></pre>
<hr/>
<p>I think the most challenging part was trying to come up with a way to verify that the global snapshot is consistent.</p>
<p>Regrettably, also for this spec I did not use the refinement process to write it, but maybe in the future I&#39;ll try to add that as a constraint. The protocol is presented in progressive refinement in Prof. Chandy&#39;s book referenced in the Resources section.</p>
<h2 id="conclusion">Conclusion</h2>
<p>In this post, I&#39;ve reviewed the <strong>Chandy-Lamport distributed snapshot protocol paper</strong> and presented a TLA+ specification I&#39;ve written for it. This paper generalizes more specific algorithms written to solve specific instances like termination detection. Stability properties generalize properties like &#34;has this computation terminated&#34; or &#34;is this computation in deadlock state&#34;.</p>
<p>Taking a global snapshot in a distributed system is hard because of the lacking of a shared clock and metaphorically, it&#39;s like trying to stitch multiple pictures of a sky in a consistent way.</p>
<p>After briefly presenting the protocol, I&#39;ve mentioned real world systems that use it in their operations. If you know more systems that use it, please reach out and I&#39;ll include them.</p>
<p>Finally, I presented a TLA+ specification of the protocol. As always, when I sit down and try to actually model the spec is when I realize I might not fully understand it yet. TLA+ is beneficial to grok algorithms.</p>
<h2 id="references">References</h2>
<ul>
<li>
<p>The paper: <a href="https://lamport.azurewebsites.net/pubs/chandy.pdf">Distributed Snapshots: Determining Global States of Distributed Systems</a></p>
</li>
<li>
<p><a href="https://decomposition.al/blog/2019/04/26/an-example-run-of-the-chandy-lamport-snapshot-algorithm/">An example run of the Chandy-Lamport snapshot algorithm</a> and <a href="https://www.youtube.com/watch?v=x1BCZ351dJk">CSE138 (Distributed Systems) L8: Chandy-Lamport snapshot algorithm </a> both by Prof. Lindsey Kuper.</p>
</li>
<li>
<p>Dr. TLA+ Series - Global Snapshot with Rusti Leno: <a href="https://www.youtube.com/watch?v=ao58xine3jM"></a>.</p>
</li>
<li>
<p>Chapter 10 from &#34;Parallel Programs Design: a foundation&#34; book by Prof. Chandy, a good recommendation by Leno in the talk above.</p>
</li>
<li>
<p>An introduction to snapshot algorithms in distributed computing: <a href="https://ics.uci.edu/~cs237/reading/files/An%20introduction%20to%20snapshot%20algorithms%20in%20distributed%20computing.pdf">https://ics.uci.edu/~cs237/reading/files/An introduction to snapshot algorithms in distributed computing.pdf</a>.</p>
</li>
<li>
<p>The Distributed Snapshot of K. M. Chandy and L. Lamport by E.W. Dijkistra: <a href="https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD864a.html">https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD864a.html</a>.</p>
</li>
</ul>

    </article></div>
  </body>
</html>
