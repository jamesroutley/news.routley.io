<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://imapenguin.com/2023/11/a-gentle-introduction-to-twos-complement/">Original</a>
    <h1>A gentle introduction to two&#39;s complement</h1>
    
    <div id="readability-page-1" class="page"><div>
        <p>I was recently on a video call with a friend, throwing around some ideas for a new product. I mentioned adding large signed numbers in assembly and using two’s complement. He asked me what two’s complement was. I was a little surprised that he didn’t know. He’s been a Java programmer for more than 30 years. Java and Python programmers (and others like <strong>gasp</strong> Commodore / MicroSoft BASIC) don’t have a native unsigned integer type. The language takes care of the details for you.</p>
<p>This is all fine, but the computer you’re running works with these integers internally in a simple way. It’s good to know how it works.</p>
<p>Plus, it’s science.</p>
<p>Let’s dive into it.</p>

<p>Two’s complement is a system for representing signed integers that allows for straightforward binary arithmetic. To find the two’s complement of a binary number, you invert all the bits (changing 0s to 1s and 1s to 0s) and then add one to the result. This representation simplifies computer design by enabling addition and subtraction with the same circuitry, as subtracting a number is equivalent to adding its two’s complement. Additionally, it <strong>efficiently</strong> handles sign changes and zero values, which is why it’s still widely used in computing today.</p>

<p><strong>Note:</strong> I assume you already know how binary works. If not, <a href="https://www.mathsisfun.com/binary-number-system.html">here’s a good primer</a>. Also, bitwise operations are a prerequisite for this article. If you need to get more familiar with them, <a href="https://youtu.be/igIjGxF2J-w?si=b-6MZ7ZdqeyQPCRi">here’s a good primer</a>.</p>
<p>Let’s start with a simple example. We’ll use 8-bit integers because they’re easy to work with.</p>
<p><code>5</code> in binary is <code>00000101</code></p>
<p>How do we represent <code>-5</code> in binary? Two’s complement uses the high bit (the one on the far left) as the sign bit. If the high bit is zero, the number is positive. If the high bit is one, the number is negative.</p>
<p>To find the two’s complement of 5, we invert all the bits (changing 0s to 1s and 1s to 0s) and then add one to the result.</p>
<p>Inverting all the bits of <code>00000101</code> gives us <code>11111010</code></p>
<p>Adding one to <code>11111010</code> gives us <code>11111011</code></p>
<p><code>11111011</code> is the two’s complement of <code>00000101</code></p>
<p>The decimal value of <code>11111011</code> is <code>-5</code></p>
<p>Let’s do another just to make sure we’ve got it.</p>
<p><code>100</code> in binary is <code>01100100</code></p>
<p>Inverting all the bits of <code>01100100</code> gives us <code>10011011</code></p>
<p>Adding one to <code>10011011</code> gives us <code>10011100</code></p>
<p><code>10011100</code> is the two’s complement of <code>01100100</code></p>
<p>The decimal value of <code>10011100</code> is <code>-100</code></p>
<p>Notice the high bit (the one on the far left) is zero for positive numbers and one for negative numbers. This is the sign bit.</p>
<p><em>Easy right?</em></p>
<p>By using the high bit as the sign bit, we can only represent 8-bit numbers from -128 to 127. This is because the high bit is the 128s place. If it’s zero, the number is positive.</p>
<p><strong>Update 2023-11-23</strong> User <a href="https://news.ycombinator.com/user?id=dperrin">dperrin</a> on Hacker News thinks of it like this which you might find helpful:</p>
<p>“When I first learned two’s complement I sort of accepted it as something to memorise for a test and didn’t really understand (or care) why it worked.</p>
<p>What really made it click for me was thinking of it as modular arithmetic. If you consider 8-bit integers, they range from 0-255 and you’re actually working modulo 256. So you can think of 0-127 as your non-negative numbers. The numbers from 128-255 behave as negatives modulo 256 (e.g. -1 mod 256 = 255).”</p>
<h2 id="a-circuit-that-does-this">A circuit that does this</h2>
<p>One common way to implement two’s complement is with a circuit that takes an 8-bit input and outputs its two’s complement. This circuit is composed of two parts: an inverter and an adder. The inverter takes the input and inverts all the bits, changing 0s to 1s and 1s to 0s. The adder adds one to the result, equivalent to adding the two’s complement of the input.</p>
<p>We can use some off-the-shelf logic gates to do this. If we want to invert a bit, using an XOR gate is the easiest way to do that. The <a href="https://www.ti.com/lit/ds/symlink/sn54s86.pdf">74LS86</a> chips each have 4 XOR gates. We can use two of them to invert the bits.</p>
<p>By the way, if you just read the bits off the gates of the 74LS86s, you’d have the one’s complement of the input. <a href="#side-quest---ones-complement">See below for more on that</a>.</p>
<p>In addition, we’ll use two <a href="https://www.ti.com/lit/ds/symlink/sn74ls283.pdf">74LS283</a> 4-bit adders. We need to connect the first adder’s carry-out to the second adder’s carry-in.</p>
<p><img src="https://imapenguin.com/images/2023/11/circuitand16c.webp" alt="Two’s complement Circuit"/></p>
<p>I used a red LED to differentiate the high bit as the sign bit.</p>
<p>Here’s a video of it in action, showing the two’s complement of 5 and 100 with a calculator to verify the results:</p>

<p>
  <iframe src="https://player.vimeo.com/video/886923024" title="vimeo video" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen=""></iframe>
</p>

<h2 id="side-quest---ones-complement">Side quest - one’s complement?</h2>
<p>One’s complement is a system for representing signed integers similar to two’s, but it has some key differences. To find the one’s complement of a binary number, you invert all the bits (changing 0s to 1s and 1s to 0s).</p>
<p>Famously used in the <a href="https://www.youtube.com/watch?v=xx7Lfh5SKUQ">Apollo Guidance Computer</a>, the one’s complement system was used in early computers because it requires less hardware than two’s complement. Looking at our circuit, we can eliminate the adder and its associated wiring and use the XOR gates to invert the bits. This is the one’s complement of the input.</p>
<p><img src="https://imapenguin.com/images/2023/11/logisimboth.webp" alt="Logisim Circuit"/></p>
<p>However, there is a serious drawback to this system. There are two representations of zero, +0 and -0. This can lead to errors in arithmetic operations. For example, if you add +0 and -0, you get -0. Brain hurt yet?</p>
<p>This is not the case with two’s complement, where there is only one representation of zero.</p>
<p>The advantage of one’s complement (besides programmer torture) is that it’s straightforward to implement in hardware. You just invert the bits.</p>
<p>On our little breadboard here, you can eliminate the two chips on the right and all those wires connecting the XOR chips to the adders. Read the bits off of the XOR chips and you have the one’s complement of the input.</p>
<p><img src="https://imapenguin.com/images/2023/11/crossedout.webp" alt="One’s Complement Circuit"/></p>

<p>For the most part, your language takes care of this for you. The representation is internal. Some languages, like C/C++, Rust, or Swift, have signed and unsigned types, and some, like Java, Ruby, and Python, don’t.</p>

<p>When using low-level languages with both unsigned and signed types, you may not know that you’re doing two’s complement; the concept is familiar even if you don’t know what is happening inside the processor.</p>
<h2 id="c">C</h2>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>#include</span> <span>&lt;stdio.h&gt;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;stdint.h&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>int</span> <span>main</span>() {
</span></span><span><span>    <span>// 8-bit unsigned integer
</span></span></span><span><span><span></span>    <span>uint8_t</span> unsignedEightBit <span>=</span> <span>255</span>; <span>// Maximum value for 8-bit unsigned
</span></span></span><span><span><span></span>    <span>printf</span>(<span>&#34;Unsigned 8-bit value: %u</span><span>\n</span><span>&#34;</span>, unsignedEightBit);
</span></span><span><span>
</span></span><span><span>    <span>// 8-bit signed integer
</span></span></span><span><span><span></span>    <span>int8_t</span> signedEightBit <span>=</span> <span>127</span>; <span>// Maximum value for 8-bit signed
</span></span></span><span><span><span></span>    <span>printf</span>(<span>&#34;Signed 8-bit value: %d</span><span>\n</span><span>&#34;</span>, signedEightBit);
</span></span><span><span>
</span></span><span><span>    <span>// Showing overflow behavior
</span></span></span><span><span><span></span>    unsignedEightBit <span>=</span> <span>256</span>; <span>// This will overflow
</span></span></span><span><span><span></span>    <span>printf</span>(<span>&#34;Overflowed Unsigned 8-bit value: %u</span><span>\n</span><span>&#34;</span>, unsignedEightBit);
</span></span><span><span>
</span></span><span><span>    signedEightBit <span>=</span> <span>128</span>; <span>// This will overflow
</span></span></span><span><span><span></span>    <span>printf</span>(<span>&#34;Overflowed Signed 8-bit value: %d</span><span>\n</span><span>&#34;</span>, signedEightBit);
</span></span><span><span>
</span></span><span><span>    <span>return</span> <span>0</span>;
</span></span><span><span>}
</span></span></code></pre></div><ul>
<li><code>uint8_t</code> is used for the 8-bit unsigned integer. It can hold values from 0 to 255.</li>
<li><code>int8_t</code> is used for the 8-bit signed integer. It can hold values from -128 to 127.</li>
</ul>
<p>It is helpful to demonstrate an overflow condition here. When you assign a value too large for the type, it overflows. This overflow wraps around to zero for unsigned types, while for signed types, the behavior is technically undefined in C but often wraps similarly.</p>
<h2 id="rust">Rust</h2>
<p>In Rust, you can use <code>u8</code> for an 8-bit unsigned integer and <code>i8</code> for an 8-bit signed integer. Rust provides a rich type system and safety features, including checks for integer overflow in debug builds. Here’s an example demonstrating both types in Rust:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>main</span>() {
</span></span><span><span>    <span>// 8-bit unsigned integer
</span></span></span><span><span><span></span>    <span>let</span> unsigned_eight_bit: <span>u8</span> <span>=</span> <span>255</span>; <span>// Maximum value for 8-bit unsigned
</span></span></span><span><span><span></span>    println!(<span>&#34;Unsigned 8-bit value: </span><span>{}</span><span>&#34;</span>, unsigned_eight_bit);
</span></span><span><span>
</span></span><span><span>    <span>// 8-bit signed integer
</span></span></span><span><span><span></span>    <span>let</span> signed_eight_bit: <span>i8</span> <span>=</span> <span>127</span>; <span>// Maximum value for 8-bit signed
</span></span></span><span><span><span></span>    println!(<span>&#34;Signed 8-bit value: </span><span>{}</span><span>&#34;</span>, signed_eight_bit);
</span></span><span><span>
</span></span><span><span>    <span>// Demonstrating overflow behavior
</span></span></span><span><span><span></span>    <span>// Note: Rust will panic in debug mode if overflow occurs.
</span></span></span><span><span><span></span>    <span>// To handle overflow, you can use wrapping_add, saturating_add, etc.
</span></span></span><span><span><span></span>    <span>let</span> overflowed_unsigned <span>=</span> unsigned_eight_bit.wrapping_add(<span>1</span>);
</span></span><span><span>    println!(<span>&#34;Overflowed Unsigned 8-bit value: </span><span>{}</span><span>&#34;</span>, overflowed_unsigned);
</span></span><span><span>
</span></span><span><span>    <span>let</span> overflowed_signed <span>=</span> signed_eight_bit.wrapping_add(<span>1</span>);
</span></span><span><span>    println!(<span>&#34;Overflowed Signed 8-bit value: </span><span>{}</span><span>&#34;</span>, overflowed_signed);
</span></span><span><span>}
</span></span></code></pre></div><p>In this example:</p>
<ul>
<li><code>u8</code> is used for the 8-bit unsigned integer, which can hold values from 0 to 255.</li>
<li><code>i8</code> is used for the 8-bit signed integer, which can hold values from -128 to 127.</li>
</ul>
<p>The overflow behavior in Rust differs from C. By default, Rust checks for overflow in debug builds and will panic if an overflow is detected. Overflow checks are not included for performance reasons for release builds, and the behavior is similar to C (wrapping around). However, Rust provides methods like <code>wrapping_add</code> and <code>saturating_add</code> to handle overflows explicitly and safely.</p>

<p>I still like to teach 6502 assembly as a first assembly language. It’s simple and a great way to learn about how computers work. It’s also a great way to learn about two’s complement because we’re limited to 8-bit values inside the processor. So, we can embrace this constraint to grasp the concept.</p>
<p>Plus, you’re on this site. What were you expecting?</p>
<h2 id="6502-assembly">6502 Assembly</h2>
<p>In 6502 assembly language, the concept of signed and unsigned integers is not explicitly defined by the data types, as in higher-level languages. Instead, it’s more about how you interpret and manipulate the data in your assembly code. The 6502 processor works with 8-bit data and 16-bit addresses.</p>
<p>Here’s a basic example to illustrate handling signed and unsigned 8-bit values in 6502 assembly:</p>
<pre tabindex="0"><code data-lang="assembly">    LDA #$FF       ; Load the accumulator with an 8-bit value (255 in decimal, or -1 if interpreted as signed)
    STA $0200      ; Store the value in memory location $0200

    LDA #$7F       ; Load the accumulator with 127 (the maximum positive value for a signed 8-bit number)
    STA $0201      ; Store the value in memory location $0201
</code></pre><ul>
<li>The <code>LDA #$FF</code> instruction loads the accumulator with <code>0xFF</code> (255 in decimal). If you interpret this as an unsigned byte, it’s 255. If you interpret it as a signed byte (using two’s complement), it’s -1.</li>
<li>The <code>LDA #$7F</code> instruction loads the accumulator with <code>0x7F</code> (127 in decimal), which is the maximum value for a signed 8-bit integer in two’s complement representation.</li>
</ul>
<p><strong>The 6502 processor doesn’t distinguish between signed and unsigned numbers. It’s up to the programmer to use the appropriate instructions for the intended interpretation.</strong></p>
<p>For example, the <code>BPL</code> (Branch if PLus) and <code>BMI</code> (Branch if MInus) instructions can be used to branch based on whether the most recent operation resulted in a positive or negative signed number, while other instructions like <code>BCS</code> (Branch if Carry Set) and <code>BCC</code> (Branch if Carry Clear) are used for unsigned comparisons.</p>
<p>It is like driving a manual transmission car. The car doesn’t care if you’re going forward or backward; using the right gear is up to you. And if you use the right gear, you will have a good time. But those who drive manual transmissions know it’s worth it. Sometimes.</p>
<p>If you don’t have access to a 6502 based computer you can use an emulator or an online assembler. I like <a href="https://skilldrick.github.io/easy6502/">this one</a>.</p>

<p>Commodore BASIC handles signed and unsigned integers for you. But I can’t have an article on this site without a vintage computer, can I?</p>
<p><em>THINK OF THE CHILDREN!!</em></p>
<p>Here on the Commodore 128 (this should work on many early 80s dialects of BASIC), we can see how this works:</p>
<div><pre tabindex="0"><code data-lang="basic"><span><span>
</span></span><span><span>2 PRINTCHR$(<span>147</span>)
</span></span><span><span>3 <span>PRINT</span><span>&#34;TWOS COMPLEMENT CHART FOR 8 BIT VALUES&#34;</span>
</span></span><span><span>4 <span>PRINT</span><span>&#34;----------------------------------------&#34;</span>
</span></span><span><span>5 <span>PRINT</span><span>&#34;POSITIVE  NEGATIVE   UNSIGNED BINARY&#34;</span>
</span></span><span><span>10 <span>FOR</span> N<span>=</span><span>0</span>TO127
</span></span><span><span>30 T<span>=</span><span>0</span>
</span></span><span><span>40 <span>FOR</span> I<span>=</span><span>0</span> <span>TO</span> <span>7</span>
</span></span><span><span>50 B<span>=</span><span>2</span><span>^</span>I
</span></span><span><span>60 <span>IF</span> (N <span>AND</span> B) <span>=</span> B <span>THEN</span> GOTO80
</span></span><span><span>70 T<span>=</span>T<span>+</span>B
</span></span><span><span>80 <span>NEXT</span> I
</span></span><span><span>90 T<span>=</span>(T<span>+</span><span>1</span>) <span>AND</span> <span>255</span>
</span></span><span><span>100 <span>PRINT</span> N,<span>-</span>N,T,
</span></span><span><span>120 <span>FOR</span> I<span>=</span><span>7</span> <span>TO</span> <span>0</span> <span>STEP</span> <span>-1</span>
</span></span><span><span>130 B<span>=</span><span>2</span><span>^</span>I
</span></span><span><span>140 <span>IF</span> (T <span>AND</span> B) <span>=</span> B <span>THEN</span> <span>PRINT</span> <span>&#34;1&#34;</span>;<span>:</span><span>GOTO</span> 150
</span></span><span><span>145 <span>PRINT</span> <span>&#34;0&#34;</span>;
</span></span><span><span>150 <span>NEXT</span> I
</span></span><span><span>160 <span>PRINT</span>
</span></span><span><span>170 <span>NEXT</span>
</span></span></code></pre></div>
<p>
  <iframe src="https://player.vimeo.com/video/886585256" title="vimeo video" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen=""></iframe>
</p>

<p>Interestingly, the Commodore documentation for AND calls it a logical AND. But you can use it to check if bits are set, so it IS bitwise AND in the right hands.</p>
<p><img src="https://imapenguin.com/images/2023/11/128logical.webp" alt="Logical AND vs Bitwise AND"/></p>

<p>No breadboard, no problem. Just grab your pocket FPGA, and you’re good to go.</p>
<p>You do have an FPGA in your pocket, don’t you?</p>
<p>It’s easy to implement two’s complement in an FPGA. Here’s an example of a module that takes an 8-bit input and outputs its two’s complement:</p>
<div><pre tabindex="0"><code data-lang="verilog"><span><span><span>module</span> TwosComplement(
</span></span><span><span>    <span>input</span> [<span>7</span><span>:</span><span>0</span>] in,   <span>// 8-bit input
</span></span></span><span><span><span></span>    <span>output</span> [<span>7</span><span>:</span><span>0</span>] out  <span>// 8-bit output representing the two&#39;s complement
</span></span></span><span><span><span></span>);
</span></span><span><span>
</span></span><span><span><span>// Inverting all bits of the input, equivalent to our 74LS86 XOR gates
</span></span></span><span><span><span></span><span>wire</span> [<span>7</span><span>:</span><span>0</span>] inverted;
</span></span><span><span><span>assign</span> inverted <span>=</span> <span>~</span>in;
</span></span><span><span>
</span></span><span><span><span>// Adding 1 to the inverted input, equivalent to our 74LS283 adders
</span></span></span><span><span><span></span><span>assign</span> out <span>=</span> inverted <span>+</span> <span>1</span>;
</span></span><span><span>
</span></span><span><span><span>endmodule</span>
</span></span></code></pre></div><p>Since the registers are 8-bit wide, these will wrap around and work for all 8-bit integers. Like assembly, the FPGA doesn’t care if it’s signed or unsigned; it’s up to you to use the correct interpretation—vroom vroom.</p>
<p>You can also just grab that inverted signal if you wanted to try working with one’s complement.</p>

<p><img src="https://imapenguin.com/images/2023/11/16c.webp" alt="HP-16C"/></p>
<p>The HP-16C programmable calculator supports one’s and two’s complements. It’s weird and quirky, but <a href="https://imapenguin.com/2022/03/simple-exponents-on-an-hp-16c/">I love it</a>.</p>
<p>There is a <a href="https://archive.org/details/hp-16c_handbook/page/n31/mode/2up">great chart from the HP-16C manual</a> that shows the one’s and two’s complements of all of the 4-bit integers. I found it very helpful when I was learning about this years ago.</p>
<p><img src="https://imapenguin.com/images/2023/11/hp16cchart.webp" alt="HP-16C User Manual Chart"/></p>

<p>Two’s complement is a system for representing signed integers that allows for straightforward binary arithmetic. To find the two’s complement of a binary number, you invert all the bits (changing 0s to 1s and 1s to 0s) and then add one to the result. This representation simplifies computer design by enabling addition and subtraction with the same circuitry, as subtracting a number is equivalent to adding its two’s complement. Additionally, it <strong>efficiently</strong> handles sign changes and zero values, which is why it’s still widely used in computing today.</p>
<p>Was this gentle? I hope so. If you have questions, please let me know.</p>

<ul>
<li><a href="https://en.wikipedia.org/wiki/Two%27s_complement">Two’s complement - Wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Ones%27_complement">One’s complement - Wikipedia</a></li>
<li><a href="https://www.youtube.com/watch?v=lKTsv6iVxV4">Two’s Complement - Computerphile</a></li>
</ul>
<ul>
  
   <li>
     <a href="https://imapenguin.com/tags/c64/">C64</a>
   </li>
  
   <li>
     <a href="https://imapenguin.com/tags/code/">code</a>
   </li>
  
   <li>
     <a href="https://imapenguin.com/tags/commodore/">Commodore</a>
   </li>
  
   <li>
     <a href="https://imapenguin.com/tags/getting-started/">Getting Started</a>
   </li>
  
   <li>
     <a href="https://imapenguin.com/tags/how-to/">How-To</a>
   </li>
  
   <li>
     <a href="https://imapenguin.com/tags/retro/">retro</a>
   </li>
  
   <li>
     <a href="https://imapenguin.com/tags/first-principles/">first principles</a>
   </li>
  
   <li>
     <a href="https://imapenguin.com/tags/assembly/">assembly</a>
   </li>
  
   <li>
     <a href="https://imapenguin.com/tags/rust/">rust</a>
   </li>
  
   <li>
     <a href="https://imapenguin.com/tags/c/">c</a>
   </li>
  
   <li>
     <a href="https://imapenguin.com/tags/fpga/">fpga</a>
   </li>
  
   <li>
     <a href="https://imapenguin.com/tags/6502/">6502</a>
   </li>
  
   <li>
     <a href="https://imapenguin.com/tags/verilog/">verilog</a>
   </li>
  
   <li>
     <a href="https://imapenguin.com/tags/python/">python</a>
   </li>
  
   <li>
     <a href="https://imapenguin.com/tags/java/">java</a>
   </li>
  
   <li>
     <a href="https://imapenguin.com/tags/ruby/">ruby</a>
   </li>
  
   <li>
     <a href="https://imapenguin.com/tags/swift/">swift</a>
   </li>
  
   <li>
     <a href="https://imapenguin.com/tags/c++/">c++</a>
   </li>
  
   <li>
     <a href="https://imapenguin.com/tags/c#/">c#</a>
   </li>
  
   <li>
     <a href="https://imapenguin.com/tags/javascript/">javascript</a>
   </li>
  
   <li>
     <a href="https://imapenguin.com/tags/basic/">basic</a>
   </li>
  
   <li>
     <a href="https://imapenguin.com/tags/commodore-basic/">commodore basic</a>
   </li>
  
   <li>
     <a href="https://imapenguin.com/tags/hp-16c/">hp-16c</a>
   </li>
  
   <li>
     <a href="https://imapenguin.com/tags/calculator/">calculator</a>
   </li>
  
   <li>
     <a href="https://imapenguin.com/tags/math/">math</a>
   </li>
  
   <li>
     <a href="https://imapenguin.com/tags/science/">science</a>
   </li>
  
   <li>
     <a href="https://imapenguin.com/tags/logic/">logic</a>
   </li>
  
   <li>
     <a href="https://imapenguin.com/tags/logic-gates/">logic gates</a>
   </li>
  
   <li>
     <a href="https://imapenguin.com/tags/logic-circuits/">logic circuits</a>
   </li>
  
   <li>
     <a href="https://imapenguin.com/tags/logic-design/">logic design</a>
   </li>
  
</ul>

    </div></div>
  </body>
</html>
