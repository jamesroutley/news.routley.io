<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://medium.com/capital-one-tech/bashing-the-bash-replacing-shell-scripts-with-python-d8d201bc0989">Original</a>
    <h1>Bashing the Bash – Replacing Shell Scripts with Python (2017)</h1>
    
    <div id="readability-page-1" class="page"><div><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/1*wAj_WWL97jnLh_beffmIEQ.png" width="700" height="467" role="presentation"/></p></div></figure><blockquote><p id="dc52">Can we talk about that old hoodie you’re wearing? Yes, it’s got an obscure logo with a complex, personally significant story. Yes, it keeps the sun off your head. Holding the pockets together with duct tape doesn’t really seem to be optimal though. And there’s that hole in the elbow. And what’s that stain. If you were to wash it, would anything be left…</p></blockquote><p id="3201">Let’s admit it, an application that looks like a free hoodie from a defunct web site doesn’t create a lot of confidence. How the application looks is important, just like with clothes. So lots of software offers a glitzy, fancy experience but we all know there’s more to software than what meets the eye. Under that exterior there are layers of processing the users don’t see. There are all manner of buttons, zippers, belts, and suspenders making sure things are holding together.</p><p id="b04e">For instance, the technical operations folk (TechOps) have to start the server, confirm that it’s running, stop the server, maybe backup the data, maybe export or import data. In addition to operations, the development (DevOps) folks have a suite of tools for integration and deployment. This DevOps tooling is often sewn together with shell scripts to make sure that a merged branch in GitHub is turned into a deployable artifact.</p><blockquote><p id="7c9e">That nice-looking outfit sure is held together from many separate parts.</p></blockquote><p id="19ed">Now, your hoodie may be the universal cover-up — you can wear it everywhere — in the same way that the shell is what holds a lot of software tools together. While it’s universal, it’s also one of the recurring DevOps/TechOps problems. It’s a problem because we often abuse the shell and treat it like a programming language.</p><p id="acf1">Here are some concerns:</p><ul><li id="a2e6">The syntax can be obscure. We all get used to it, but that doesn’t make it good.</li><li id="d5a8">It’s slow. While the speed of a shell script rarely matters, trying to use the shell like a programming language will waste system resources.</li><li id="b1f4">We can often omit crucial features of a script. Checking the status of programs using<strong><em> $?</em></strong> can be accidentally left off, leading to inconsistent behavior.</li><li id="0a13">The shell language’s only data structure is the string. There are ways of decomposing strings into words. The <strong><em>expr</em></strong> program can convert strings to numbers to do arithmetic. The <strong><em>date</em></strong> program allows some date manipulations, but the rules can be obscure.</li><li id="563b">Unit testing isn’t easy. There are some packages like <a href="https://github.com/sstephenson/bats" rel="noopener ugc nofollow" target="_blank">Bats</a> that can help with unit testing. A language like Python has a much more robust unit testing capability.</li></ul><p id="13d4"><em>It’s not that the shell is broken. The shell isn’t a complete programming language. It doesn’t do everything we need.</em></p><h2 id="1af8">Which Brings Us to Bash-Bashing</h2><p id="f089">The point of bash-bashing is to reduce use of the shell. Without much real work, it’s easy to replace shell scripts with Python code. The revised code is easier to read and maintain, runs a little faster, and can have a proper unit test suite.</p><p id="c178">Because shell code is so common, I’ll provide some detailed examples of how to translate legacy shell scripts into Python. I’ll assume a little familiarity with Python. The examples will be in Python 3.6 and include features like <strong><em>pathlib </em></strong>and f-strings. If you want to follow along, consider creating a virtual environment or using <a href="https://conda.io/docs/intro.html" rel="noopener ugc nofollow" target="_blank">conda</a>.</p><p id="4d9a">The shell script examples are pure bash, and will run anywhere that bash runs. The design patterns apply to Windows; of course the syntax will be dramatically different.</p><h2 id="789e">It’s A Big World</h2><p id="9802">Before I dive into code, I want to put some boundaries on the example. It’s tempting to provide examples of <a href="https://git-scm.com/book/gr/v2/Customizing-Git-Git-Hooks" rel="noopener ugc nofollow" target="_blank">Git hooks</a>, or <a href="https://jenkins.io/" rel="noopener ugc nofollow" target="_blank">Jenkins jobs</a>, or UrbanCode Deploy.</p><p id="78be">I think these kinds of examples are little too specific; I want to look a little more broadly at shell scripting in general. I’d like to make the distinction between generic sportswear and the specific gear we might wear to go rock climbing. My code example is not tailored for a particular DevOps tool chain.</p><p id="9c65">The shell can be used for a wide variety of things. I’m going to use an example that has a few common kinds of OS-level resource manipulations in it:</p><ul><li id="1566">Reading configuration files</li><li id="b727">Killing (and creating) processes</li><li id="eee4">Doing date arithmetic</li><li id="a215">Creating (and deleting) directories</li><li id="ec0a">Running applications</li><li id="7eb1">Managing files</li></ul><p id="fc61">There are also some higher-level considerations than managing OS resources. These considerations include conditional processing and iterating over objects. I’ll show an example of iterating over files, but scripts also iterate over processes or even lines in a file.</p><p id="f30d">Shell scripts often manage network resources. This means accessing remote resources via <strong><em>curl</em></strong> and <strong><em>wget</em></strong>. Using these programs makes managing network resources look a lot like running applications and managing local files. Because of this, I won’t treat network resources as a distinct class of objects.</p><h2 id="020c">A Representative Script</h2><p id="dd8e">I have a little shell script with some examples of different resource operations. This script manipulates some OS resources, and runs an external application. <em>(Yes, the application is secretly in Python.)</em></p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/1*tPZ3HhLwwC3V8iQQQIw2DA.png" width="700" height="742" role="presentation"/></p></div></figure><p id="05c5">This script seems to have four important steps:</p><ol><li id="334a">It kills a process. This involves reading a file to get a process id, then executing the <strong><em>ps</em></strong> and <strong><em>kill</em></strong> commands. The <strong><em>example.pid</em></strong> file was created by some other process and read by this script.If the file doesn’t have any content, there’s a logic path to handle that. What if the file doesn’t even exist?</li><li id="f159">It creates a directory with a name based on the current date. This directory is used in subsequent steps.If the directory already exists, there’s an annoying message. Is this masking a problem?</li><li id="4dd5">It runs an analytic app. There’s a confusing <strong><em>for</em></strong> loop that processes only one file from a sorted list of file names. I’ll dig into the nuances of that construct below. I’ve included it as representative of algorithms that can be simplified when using Python.</li><li id="a76a">Finally, it copies the output file to a second location, named <strong><em>current.txt</em></strong>. The copy operation is qualified by an if statement which checks to see if one file is newer before replacing another file.</li></ol><p id="d7a8">I emphasize the phrase “seems to have” because shell scripts can have hard-to-discern side-effects. This specific example is explicit about the files and directories it creates and the process it kills. Generally, the original idea behind the shell is to make resource management abundantly clear. However, this ideal isn’t always met in practice.</p><blockquote><p id="bcf6">You may like your hoodie. But it has duct tape holding it together.</p></blockquote><p id="5d03">An example of a shell obscurity is the way the current working directory is set. The <strong><em>cd</em></strong> command is clear enough, but in the presence of sub-shells using <strong><em>()</em></strong>, can make it difficult to discern a stack of nested shell invocations and how the working directory changes when the sub-shells exit.</p><p id="8211">Let’s rewrite this example into something that can be unit tested. I’ll start from the top and work my way down into the details.</p><h2 id="9d74">Start at the Top</h2><p id="6b39">By “top” I mean the high-level summary of what the script does. This script appears to have four steps. Here’s some Python code that reflects the overall synopsis:</p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/1*qB-xB_EFOmw3WPWD0GraUA.png" width="700" height="412" role="presentation"/></p></div></figure><p id="137a">I’ve idealized the four steps as separate functions. This leaves a space to implement each function. I’ve tried to avoid making too many assumptions. As a practical matter, we often have a clearer picture of what a shell script does; this allows us to define the functions in a way that better fits the script’s intent.</p><h2 id="e3a1">From Configuration File to Process Management</h2><p id="0229">One of the shell’s ickier features is that variables tend to be global. There are some exceptions and caveats, however, that lead to shell scripts that are broken or behave inconsistently. This means that environment variables like <strong><em>PID_FILE</em></strong> and <strong><em>PID</em></strong> are <em>potential</em> outputs from a step and <em>potential</em> inputs to a later step. It’s rarely clear.</p><p id="0e5b">Part of a rewrite means identifying the global variables which are used in other parts of a script. This can be difficult in complex scripts. In this example, it’s easy to check the code to be sure that these two variables are effectively local.</p><p id="66f0">Another part of a rewrite means identifying things which are more like configuration parameters than simple variables. Things like literal directory and file names are obvious candidates for being treated as configuration parameters. There are other configurable items like search strings and wild-card patterns which may also need to be treated as part of an external configuration. I suggest taking it slow with the parameterization pass.</p><p id="2215">My advice is to get things to work first. Generalize them later.</p><p id="4d43">Here’s an implementation of the <strong><em>kill_process()</em></strong> function:</p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/1*oAFb79OKkUTa3xaSFg_tMA.png" width="700" height="343" role="presentation"/></p></div></figure><p id="1125">I’ve replaced the shell’s idiom of read <strong><em>PID &lt;$PID_FILE</em></strong> with code based on the Pythonic idiom of <strong><em>pid = pidfile_path.read_text()</em></strong>. The original shell script doesn’t have any documentation for the format of the file; we haven’t added documentation to the Python. A summary of the file content is an important addition.</p><p id="a606">Here’s another change between the shell and Python: the shell works with strings, but the Python <strong><em>psutil</em></strong> library uses integers for the process ID’s. This leads to converting the string to an integer using the <strong><em>int()</em></strong> function. This also means the script needs to do something useful when the file doesn’t contain a valid number for a PID.</p><p id="5832">The original shell script will silently do obscure and difficult-to-predict things if the file has an invalid PID. Try running <strong><em>ps what</em></strong> or <strong><em>ps ick</em></strong> to see some of this less-than-obvious behavior yourself.</p><p id="e565">Similarly, the <strong><em>kill</em></strong> command will write a message if a process can’t be found. When the process can’t be found, the script does not stop; it quietly ignores the problem. Maybe this situation is not really a problem. It’s hard to tell what the original intent was. Was this an omission? Or was it intentional?</p><p id="29a6">Both the <strong><em>ps</em></strong> and <strong><em>kill</em></strong> programs set a status code in <strong><em>$?</em></strong> to a value of one to indicate that the program failed. Omitting a check of the value of <strong><em>$?</em></strong> means that the success or failure of these programs was being ignored.</p><p id="402b">Unlike the shell, Python consistently raises an exception when programs don’t complete with a status code of zero. Our Python script must handle this exception to make it explicit that the various kinds of failures doesn’t matter in general. In example, the Python code writes a warning message and continues processing. The <strong><em>pass</em></strong> statement can be used instead of a <strong><em>print </em></strong>functions to silence the exceptions.</p><p id="dd4b">Note, the <strong><em>psutil</em></strong> package is not part of the standard library. You’ll need to install this separately.</p><h2 id="64d5">Creating Directories</h2><p id="e726">Here’s the implementation of the <strong><em>make_output()</em></strong> function to create the output directory:</p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/1*MPDDQOBrg-LRTVkPq2WvAw.png" width="700" height="239" role="presentation"/></p></div></figure><p id="5ee5">The shell’s <strong><em>date</em></strong> program does a lot of things with relatively cryptic syntax. I’ve written a simple function that emulates one feature of the <strong><em>date</em></strong> program. It’s easy to expand this to include the date ± offset feature, also.</p><p id="2767">I’ve included a type hint on the <strong><em>make_output_dir() </em></strong>definition. This summarizes the return value produced by this function. If you haven’t seen Python 3 type hints before, I need to emphasize the “hint” aspect. They don’t change the run-time behavior at all. There’s a separate quality check via the <strong><em>mypy </em></strong>program (<a href="http://mypy-lang.org/" rel="noopener ugc nofollow" target="_blank">http://mypy-lang.org/</a>) to confirm that the type hints are all used consistently.</p><p id="bdfa">This function leverages the Python 3 <strong><em>pathlib</em></strong> library. The <strong><em>output_dir</em></strong> variable is called a “pure” path — a potential path that <em>could</em> exist. It’s built from a <strong><em>Path</em></strong> object and a string. The / operator builds complex paths from a base <strong><em>Path</em></strong> object.</p><p id="e8f6">After the pure path is built, the <strong><em>.mkdir()</em></strong> method creates an actual path from the pure path. Using the <strong><em>exist_ok</em></strong> option silences the <strong><em>FileExistsError</em></strong> exception raised if the directory already exists.</p><p id="4d45">In the case where the directory already existed, the legacy shell script wrote an error message. In contrast to this, the Python code is silent. The Python code can be modified to emulate the error message behavior, if it’s important. Omit the <strong><em>exist_ok=True </em></strong>and handle the <strong><em>FileExistsError </em></strong>exception by printing a <strong><em>f”{output_dir}</em></strong>: File exists” message</p><p id="73e0">A search of the source shows that the value of the <strong><em>output_dir</em></strong> variable is used elsewhere in the script. Because of this, I’ve returned the value as an explicit result of this function.</p><p id="eb3e">If you’re new to Python, it’s easy for a function to return multiple values. In the rare case that a step of a shell script sets multiple variables that need to be returned, just list all of them on the return statement.</p><h2 id="fd18">Propagating the Change</h2><p id="5fa5">When I first sketched the script, the signature of the <strong><em>make_output_dir() </em></strong>had no arguments or return values. As I dug into the details, I found that the output directory was used by <strong><em>run_analytics()</em></strong> and <strong><em>copy_to_current()</em></strong>.The discovery process for return values and parameters can be challenging. In many cases, it involves unit tests failing because a variable is missing.</p><p id="eaf3">Changing the <strong>make_output_dir()</strong> function means I need to also change the overall script. Here’s a version that reflects all the variables that are needed by each step:</p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/1*EP5G7d8BBvf8aNKVmNhnqg.png" width="700" height="130" role="presentation"/></p></div></figure><p id="5609">The contrived example doesn’t involve many environment variables being used to pass values around. Don’t be surprised by lots of shared variables in real-world scripts. In some cases, copy-and-paste programming may mean that a variable name is reused in separate steps.</p><p id="3621">If you look back at the <strong><em>copy_to_current()</em></strong> block of code, it has two global variables: <strong><em>output_dir</em></strong> and <strong><em>name</em></strong>. However, these are used to build one result path: <strong><em>“${output_dir}/summary_${name}.txt”</em></strong>. Rather than provide two variables, I’ve made a tiny redesign to return the entire path from the <strong><em>run_analytics()</em></strong> function.</p><h2 id="e9c5">Sorting and Searching</h2><p id="525d">The next big step, the <strong><em>run_analytics()</em></strong> function executes an external program for a particular input file. Here’s the overall code. We’ll look at sorting filenames first, then we’ll look at the <strong><em>check_call()</em></strong> function to run a program.</p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/1*-7u4ElwZ57sC3YUVCRh1IQ.png" width="700" height="302" role="presentation"/></p></div></figure><p id="d8df">The <strong><em>glob()</em></strong> method of a <strong><em>Path</em></strong> object enumerates all of the files in that directory. This is like using <strong><em>* </em></strong>outside of any quotes in the shell. Except that it’s explicit.</p><p id="3dc6">I’ve preserved the original shell design in this code. There’s a loop that includes a break. It’s not clear why this loop exists in the first place. But, I’m following my strategy to get things to work first and generalize them later. Once we have unit tests in place, we can rewrite this to optimize it.</p><p id="938b">This code contains an example of some processing that is inefficient in the shell.</p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/1*JzXyGZBttbGlYZ_RVpKd1Q.png" width="700" height="53" role="presentation"/></p></div></figure><p id="b26e">The syntax is terse, but it involves a sub-shell with a pipeline. The pipeline involves running two separate programs and piping the output of one to the input of the other. While Linux does this quickly, it involves overheads that are avoidable.</p><p id="2331">In Python, we can use the following:</p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/1*clryccfcJfa9XDAY8Wp1Mg.png" width="700" height="47" role="presentation"/></p></div></figure><p id="9375">While the Python code is more efficient, it has another gigantic advantage. In Python, it’s very simple to handle sophisticated sort keys.</p><p id="d80e">In the shell, we’ll often have contrived sort pipelines like this:</p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/1*XE581LGRycxPyOwThtNKlA.png" width="700" height="45" role="presentation"/></p></div></figure><p id="c321">The first <strong><em>sed</em></strong> step extracts some numeric value from the filename so that it can be used for sorting. The last sed step removes the decoration after the sorting is complete. Sometimes this is done with <strong><em>awk</em></strong>. Either way, it’s clutter.</p><p id="3848">In Python, we can more simply provide a key function to the <strong><em>sorted()</em></strong> function.</p><p id="284d">For example, we might have files with names like <strong><em>prefix_yyyymmdd.ext</em></strong> and we want to sort by the date after the<strong><em> _, </em></strong>not the prefix. We can write a sort key function that looks like this:</p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/1*ZlFdR8NP6I9F9owcVdHECg.png" width="700" height="104" role="presentation"/></p></div></figure><p id="f8a1">This function will extract the stem of the file’s name, partition it, and return just the<strong><em> yyyymmdd </em></strong>portion of the name. This will be the sort key. We can, of course, do any kind of string or numeric calculation here in the unlikely case we have very complex sorting rules.</p><p id="9490">We can use this key function as follows:</p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/1*fTnE48-HEl6SXj-AjEBjWA.png" width="700" height="48" role="presentation"/></p></div></figure><p id="b07c">This applies the object-to-key transformation function to create sort keys from each object to be sorted.</p><p id="6938">The optimization? We can replace the for/break construct with this:</p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/1*rVuxKrRF5nnMVUSEjr4RcA.png" width="700" height="59" role="presentation"/></p></div></figure><p id="bda0">This will take the one item from the sorted sequence of file names.</p><p id="eef9">Here’s an example of how this kind of thing looks, using some fake-ish data. I’ll use strings instead of fabricating <strong><em>Path</em></strong> objects.</p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/1*C2hXSsKNH-cqU8t1U77bEA.png" width="700" height="195" role="presentation"/></p></div></figure><p id="7632">The suffix strings were stripped off the file names; these strings are used for key comparison when sorting. Here’s how it might look to take the next step.</p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/1*Y_yO2I677pXcj06LIJcZbw.png" width="700" height="73" role="presentation"/></p></div></figure><p id="2012">These are sorted into ascending order, including <strong><em>reversed=True</em></strong> will switch the sense of the key comparisons.</p><h2 id="596e">Running A Program</h2><p id="f6f2">One gigantic difference between Python and the shell is the way the shell runs programs implicitly. If the first word on the line is not a built-in feature of the shell, the name is found on the OS <strong><em>$PATH</em></strong> and executed as a program. In Python, the subprocess module is used to run programs. The <strong><em>check_call()</em></strong> function is what I used here. There are some other choices, depending on the precise behavior required.</p><p id="a943">The transformation from the original shell command to Python involves replacing three shell parsing features:</p><ul><li id="9600">A line of shell code is parsed as words based on whitespace and quotes. Quoted strings are treated as a single word. The shell provides two kinds of quotes to provide some control over the process. For Python, I’ve parsed the command into a list of words at design time. We don’t have to use complex quoting rules. Instead we provide the list of words. There’s a static list in the <strong><em>APP_NAME </em></strong>variable. A filename is appended to this list of words.</li><li id="b371">Each line of shell code is processed to “glob” filenames. Any<strong><em> *</em></strong> is used as a wild-card file specification. To defeat this feature, we must provide<strong><em> *</em></strong> in quotes. In Python, I’ve replaced the shell’s implied globbing with an explicit call to the <strong><em>glob()</em></strong> method of a <strong><em>Path</em></strong> object. <a href="https://docs.python.org/3.6/library/pathlib.html#pathlib.Path.glob" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3.6/library/pathlib.html#pathlib.Path.glob</a></li><li id="9b98">In the shell, the <strong><em>&gt; </em></strong>and <strong><em>&lt; </em></strong>redirection operators are used to connect open files to the program to be executed. In Python, I opened the files explicitly. I can then pass the open file connections to the <strong><em>check_call() </em></strong>function to be mapped to the child process stdout.</li></ul><p id="b149">This transformation turns the terse shell command of <strong><em>$APP $filename &gt;”${output_dir}/summary_${name}.txt”</em></strong> into something like this in Python:</p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/1*K-GQK50td_x-k-5tIPyOvQ.png" width="700" height="101" role="presentation"/></p></div></figure><p id="44ae">First, I’ve build the target filename using a <strong><em>Path</em></strong> and the<strong><em> / </em></strong>operator. Then, I’ve build the command as a list words from <strong><em>APP_NAME </em></strong>and the path to be processed. After opening the target file, I’ve run the resulting command with the standard output directed to the open file.</p><p id="bf0f"><em>“Hey, wait a minute,”</em> you might say. “<em>You’re just running a Python program from another Python script.”</em></p><p id="8a23">Good point. You’ve identified the next level of script rewriting. We can probably merge these steps into a composite application that imports the original <strong><em>module_design_analytics</em></strong> application. It may also be sensible to use the <strong><em>runpy</em></strong> module to run the application from inside this script. These are important potential optimizations.</p><h2 id="8a54">Checking Modification Times and Copying Files</h2><p id="4d58">The final step will copy a file if it’s newer than some target file.</p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/1*VhpZ_QNKlCtiQPFLiy-ILw.png" width="700" height="165" role="presentation"/></p></div></figure><p id="5afb">The shell uses the <strong><em>[ file -nt file ]</em></strong> to compare modification times of two files. I’ve replaced this with a very explicit operation to get the <strong><em>os.stat()</em></strong> structure for each file. Then I compared the modification time, called <strong><em>st_mtime</em></strong> within each OS status structure.</p><p id="0317">The file copy is done with the <strong><em>shutil </em></strong>module. This has a <strong><em>copy2() </em></strong>function to copy the data as well as the metadata. There are alternatives to this in the <strong><em>shutil</em></strong> module that provide more control over how the metadata is handled.</p><h2 id="ca2c">The Imports</h2><p id="a3fc">Here’s the list of the modules imported by this script:</p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/1*H1wSJHe7gpVmCR2H-edtPQ.png" width="700" height="146" role="presentation"/></p></div></figure><p id="d159">In some cases (i.e., <strong><em>datetime</em></strong>, <strong><em>shutil</em></strong>), I’ve used the entire module. In other cases (i.e., <strong><em>pathlib</em></strong>, <strong><em>subprocess</em></strong>), I’ve imported only the specific class, function, or exception that was necessary. I’ve done this to show both styles. When a function like <strong><em>check_call()</em></strong> is imported, then the name doesn’t require any qualification. When a module like shutil is imported then the function requires the module as an explicit namespace qualification: shutil.copy2(). There are good reasons for each style.</p><p id="3e23">psutil is not part of the standard library. It will have to be installed separately.</p><h2 id="79a1">Testing</h2><p id="bf13">Once there’s some — allegedly — working code, the next step is to create unit tests. It’s a good practice to have testing drive development. Ideally, we’d write unit tests for the four high-level function steps in the shell script. That ideal is difficult to achieve when we’re not sure we know everything a given step does that’s relevant for subsequent steps. There’s a lot of global, shared state that needs to be understood.</p><p id="dfab">If we’re using Python instead of the shell, then we have the advantage of starting from scratch. We can use test-first development techniques.</p><p id="b51d">In either case, it’s essential to mock the OS-level resources that our Python applications will be touching. For this, I used the <strong><em>unittest.mock</em></strong> library. To build proper mock objects, it helps to look at the code. Some testing experts call this “white box” testing because I’m tailoring the mock objects to the software under test.</p><p id="bba3">Here’s a representative test for one of our script’s functions. This will test the <strong><em>copy_to_current()</em></strong> function for one relationship of modification times:</p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/1*d3rZgKEk_2LN1K5slYVpqA.png" width="700" height="295" role="presentation"/></p></div></figure><p id="f958">The test imports the script to be tested; it has the unimaginative name of <strong><em>script.py</em></strong>. I’ve applied two patches to the namespace in which the script executes.</p><ul><li id="8411">The import of <strong><em>shutil</em></strong> is replaced by a <strong><em>Mock</em></strong> object.</li><li id="7559">The import of <strong><em>pathlib.Path</em></strong> is replaced by a <strong><em>Mock</em></strong> object, also.</li></ul><p id="9302">Both of these mock objects become arguments to the test function so I can use them. When there are more than one <strong><em>@patch</em></strong> decorators, note the inner-to-outer ordering of the parameter names. This is a consequence of Python’s rules for applying decorators.</p><p id="5d3c">I’ve also created a mock for the <strong><em>result_path</em></strong> argument, and assigned it to the variable <strong><em>mock_result_path</em></strong>. In this case, I’m not patching an imported name, I’m providing an argument to a function.</p><p id="0944">The function under test uses code like this</p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/1*ELSnRPYd1jt9pK_FyLD8Bw.png" width="700" height="53" role="presentation"/></p></div></figure><p id="8e3a">To be sure this will work, I created a <strong><em>stat</em></strong> attribute. It’s a <strong><em>Mock</em></strong> with a <strong><em>return_value</em></strong>. The returned value is a <strong><em>Mock </em></strong>with a <strong><em>st_mtime</em></strong> attribute. I’ve mocked the behavior that is used by the code under test.</p><p id="1a2e">The <strong><em>mock_path </em></strong>argument is a stand-in for the <strong><em>Path</em></strong> class definition. The function under test will use code like this:</p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/1*ut-VyuiU6LrameyQRYRddQ.png" width="700" height="71" role="presentation"/></p></div></figure><p id="d068">We expect that the mock <strong><em>Path</em></strong> will be evaluated once to create a <strong><em>Path</em></strong> object. The default behavior of a function call is to create a <strong><em>Mock</em></strong> object. A test can reference that created mock with <strong><em>mock_path.return_value</em></strong>. Based on the code under test, the returned <strong><em>Mock</em></strong> object must have a <strong><em>stat() </em></strong>function, and the result of that function must have a <strong><em>st_mtime</em></strong> attribute.</p><p id="09b7">When evaluating <strong><em>script.copy_to_current()</em></strong> in this test context, I have a bunch of expectations. The most important one is that <strong><em>shutil.copy2</em></strong> will be called. I formalized this expectation as follows:</p><figure><div role="button" tabindex="0"><p><img alt="" src="https://miro.medium.com/max/1400/1*H6Hdm-QjnfW4wJiCkVQAeQ.png" width="700" height="69" role="presentation"/></p></div></figure><p id="1a80">I’m also be interested in confirming the <strong><em>stat()</em></strong> method was called for each argument. I can add this as an assertion.</p><p id="18a4">The whole point here is to add tests with different time stamp relationships to test other behaviors. The <strong><em>py.test</em></strong> package can find and run these tests because they have a consistent name pattern.</p><h2 id="845f">Next Steps</h2><p id="95e2">We’re not done, of course. I haven’t really addressed logging or configuration. Does this script use external environment variables? A configuration file? Command-line arguments?</p><p id="41d7">Some shell scripts use the <strong><em>getopt</em></strong> command to parse options. Other shell scripts use <strong><em>$0</em></strong>, <strong><em>$1</em></strong>, etc., to gather positional arguments. A lot of these features can be buried inside a script, making it difficult to discover what the script really does and how it’s expected to be used.</p><p id="3e36">Further, there’s another round of optimization possible. As noted above, this script runs a Python program. It may be appropriate to combine the application and the script into a composite application.</p><h2 id="c6f8">Conclusion</h2><blockquote><p id="9c39">The shell is a primitive programming environment. It works well, but it’s not a very sophisticated language. I think of it as a 1970’s leisure suit, maybe made of double-knit polyester, with contrasting top-stitching. You know — dated. And definitely inappropriate for rock climbing or a day at the beach.</p></blockquote><p id="8749">The two biggest problems are the paucity of useful data structures and the difficulty of unit testing.</p><p id="16cb">We don’t need to eliminate all use of the shell. But we can benefit from reducing the use of the shell to the few things that it’s particularly good at. I’m a fan of relegating shell scripts to a few lines of code that set environment variables, establish the current working directory, and run a target program.</p><p id="9211">What we want to do is replace <em>complex</em> shell scripts with code written in a programming language that offers us a family of rich data structures. In many cases, we can find big blocks of shell code that are doing computations that are a simple, built-in feature of a programming language like Python.</p><p id="0cdb">Moving to Python means we can leverage smarter data structures. We can work with numbers and dates in a way that’s free from string-handling cruft. The best part? We can write unit tests. A small change to a shell script doesn’t break things. Instead, it gets tested like the rest of the application. We can put it into production with a lot of confidence that it will really work.</p></div><div><p id="1a7c"><strong><em>STATEMENT: These opinions are those of the author. Unless noted otherwise in this post, Capital One is not affiliated with, nor is it endorsed by, any of the companies mentioned. All trademarks and other intellectual property used or displayed are the ownership of their respective owners. This article is © 2017 Capital One.</em></strong></p><ul><li id="b95f"><a rel="noopener" href="https://medium.com/capital-one-developers/automating-nosql-database-builds-a-python-to-the-rescue-story-that-never-gets-old-1d9adbcf6792">Automating NoSQL Database Builds</a></li><li id="1426"><a rel="noopener" href="https://medium.com/capital-one-developers/nosql-database-doesnt-mean-no-schema-a824d591034e">NoSQL Database Doesn’t Mean No Schema</a></li></ul></div></div>
  </body>
</html>
