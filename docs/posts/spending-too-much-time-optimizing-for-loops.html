<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://octavelarose.github.io/2024/05/29/to-do-inlining.html">Original</a>
    <h1>Spending too much time optimizing for loops</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>This is part of a series of blog posts relating my experience pushing the performance of programming language interpreters written in Rust.</p>

<h2 id="what-also-who">what? also, who?</h2>

<p>My PhD is on the runtime performance of AST interpreters: my job is to try to make things go fast. Last year, we published the paper “<a href="https://stefan-marr.de/downloads/oopsla23-larose-et-al-ast-vs-bytecode-interpreters-in-the-age-of-meta-compilation.pdf">AST vs Bytecode: Interpreters in the Age of Meta-Compilation</a>”, where we compared AST and bytecode interpreters written on top of two different meta-compilation systems: GraalVM (a partial evaluation approach, relying on the Java language) and RPython (meta-tracing approach, in RPython, a Python subset). We concluded that AST interpreters performed surprisingly well, despite the widespread opinion that bytecode is the superior approach to interpreter design.</p>

<p>Though one question we received a lot was: are AST interpreters only good on meta-compilation systems that rely on higher-level languages, and not REAL PROGRAMMING LANGUAGES like C or Rust where I can do all my fancy optimizations?</p>

<p>So I’m trying, with Rust specifically, to get interpreters to perform as well as our existing ones - maybe better??? As part of his MsC here at the University of Kent, <a href="https://polomack.eu/">Nicolas Polomack</a> wrote the <a href="https://github.com/hirevo/som-rs">som-rs interpreters</a>, one being AST-based and the other BC-based, and he honestly did a tremendous job. However, the focus wasn’t so much on performance, and there’s a lot of effort needed to push it further. How much exactly? Well, here’s how much I improved the performance of the AST and BC interpreters after a few months of implementing various optimizations and fixing performance bugs:</p>

<p><img src="https://octavelarose.github.io/assets/2024-05-29-to-do-inlining/speedup_compared_to_main_repo.png" alt="speedup compared to base project"/></p>

<p>How to read the graph: each grey dot is one of our benchmarks, and lower is better. A 0.5x median speedup means we’re twice as fast, as we can see here, so not bad. (small disclaimer: only showing results on our micro benchmarks for my own convenience, but results are extremely similar on our macro benchmarks).</p>

<p>And this is where we’re currently at, compared to the interpreters we used in our paper (<a href="https://github.com/SOM-st/TruffleSOM/">TruffleSOM</a> and <a href="https://github.com/som-st/PySOM">PySOM</a>):</p>

<p><img src="https://octavelarose.github.io/assets/2024-05-29-to-do-inlining/comparing_every_interp.png" alt="compare-all-interps"/></p>

<p>A long ways to go still… The BC one is getting there, progress with the AST one is slower for various reasons, including Rust limitations - there’s some interesting stuff to talk about there, maybe in a future blog post.</p>

<p>As a disclaimer, I’m not a <em>real</em> Rust dev, and I’m in fact a disgusting poser and a sham. My experience with the language before this consists of small personal projects, and were mostly about me getting my bearings with the many foreign concepts introduced by Rust. Having suffered with C for years <sup id="fnref:stockholm-syndrome" role="doc-noteref"><a href="#fn:stockholm-syndrome" rel="footnote">1</a></sup>, I tend to assume other programming languages will always be smooth to use and learn by comparison, but Rust feels like a different beast.</p>

<p>I have been loving my time as a Rust dev, though! It’s a great language and really pleasant to work with. At other times unpleasant to work with when you want to get high performance and ownership rules get in your way… More on that at some point.</p>

<h2 id="what-happened-this-week">what happened this week?</h2>

<p>We’re working with interpreters for the SOM language, a minimal Smalltalk designed for research and teaching. It being based on Smalltalk means that everything under the sun is an object, and so that method calls on said objects are absolutely everywhere. Say your code has a loop:</p>

<p><code>[ iter &gt; 0 ] whileTrue: [ iter := iter - 1. ]</code></p>

<p>…spoilers, it’s in fact a method called on the <code>Block</code> class (the condition block) that takes in another block (the loop body) as an argument. Its code looks like this:</p>

<div><div><pre><code><span>whileTrue</span><span>:</span> <span>block</span> <span>=</span> <span>(</span>
    <span>self</span> <span>value</span> <span>ifFalse</span><span>:</span> <span>[</span> <span>^</span><span>nil</span> <span>].</span>
    <span>block</span> <span>value</span><span>.</span>
    <span>self</span> <span>restart</span>
<span>)</span>
</code></pre></div></div>

<p>I won’t describe this code in detail. What matters is that in SOM, a loop is a method call, and that method calls need dispatching and are therefore not the fastest. It may sound like a counter-intuitive language design choice, but that’s the beauty of Smalltalk: you can re-implement every method yourself and fundamentally change the behavior of your system, like by making every loop invest in random cryptocurrencies to spice up both your VM <em>and</em> your life (please don’t do this).</p>

<h3 id="can-we-speed-that-up">can we speed that up?</h3>

<p>That’s a cool feature, but 99.999999% of the time we want loops to be regular loops, so we should hard-code somehow to be treated as such to gain performance. This is typically the kind of stuff you can <em>lower</em> (handle at e.g. the bytecode-level or in the interpreter directly: anything to not interpret the code normally) to get better performance, and in fact we already do for <code>whileTrue:</code> (in the bytecode interpreter). I implemented some <code>JUMP</code> bytecodes, I inline the condition and body blocks into the method scope, and jump around to their starts and ends depending on what I want. Looks something like this:</p>

<div><div><pre><code><span>0</span> <span>|</span> <span>PUSH_LOCAL</span> <span>0</span><span>,</span> <span>0</span>
<span>1</span> <span>|</span> <span>PUSH_0</span>
<span>2</span> <span>|</span> <span>SEND_2</span> <span>1</span> <span>(</span><span>calling</span> <span>#</span><span>&gt;</span><span>)</span>
<span>3</span> <span>|</span> <span>JUMP_ON_FALSE_POP</span> <span>5</span> <span>(</span><span>jump</span> <span>to</span> <span>idx</span> <span>8</span><span>)</span>
<span>4</span> <span>|</span> <span>PUSH_LOCAL</span> <span>0</span><span>,</span> <span>0</span>
<span>5</span> <span>|</span> <span>DEC</span>
<span>6</span> <span>|</span> <span>POP_LOCAL</span> <span>0</span><span>,</span> <span>0</span>
<span>7</span> <span>|</span> <span>JUMP_BACKWARD</span> <span>7</span> <span>(</span><span>jump</span> <span>to</span> <span>idx</span> <span>0</span><span>)</span>
<span>8</span> <span>|</span> <span>...</span>
</code></pre></div></div>

<p>Once again, the details don’t matter here. The big idea is that we jump past the body block when we’re done, and we jump to the condition block after we execute the body block. It’s pretty classic stuff, was surprisingly time-consuming to implement, but provided an unsurprisingly large amount of performance. Make every loop faster, and you speed up every program by a lot.</p>

<h3 id="the-todo-method">the <code>to:do:</code> method</h3>

<p>But currently, we don’t handle every loop that way: a common way of looping is to call the <code>Integer&gt;&gt;#to:do:</code> method, invoked like <code>1 to: 50 do: [ ... ]</code> . In case anyone’s curious, here’s its code (no need to look at it that closely):</p>

<div><div><pre><code><span>to</span><span>:</span> <span>limit</span> <span>do</span><span>:</span> <span>block</span> <span>=</span> <span>(</span>
    <span>self</span> <span>to</span><span>:</span> <span>limit</span> <span>by</span><span>:</span> <span>1</span> <span>do</span><span>:</span> <span>block</span>
<span>)</span>

<span>to</span><span>:</span> <span>limit</span> <span>by</span><span>:</span> <span>step</span> <span>do</span><span>:</span> <span>block</span> <span>=</span> <span>(</span>
    <span>|</span> <span>i</span> <span>|</span>
    <span>i</span> <span>:</span><span>=</span> <span>self</span><span>.</span>
    <span>[</span> <span>i</span> <span>&lt;=</span> <span>limit</span> <span>]</span> <span>whileTrue</span><span>:</span> <span>[</span> <span>block</span> <span>value</span><span>:</span> <span>i</span><span>. i</span> <span>:</span><span>=</span> <span>i</span> <span>+</span> <span>step</span> <span>]</span>
<span>)</span>
</code></pre></div></div>

<p><code>to:do:</code> is essentially a <code>for</code> loop and is consequently used very frequently, but it <em>doesn’t</em> get turned to specialized bytecode right now because I’ve only got so much time. Let’s finally speed it up!</p>

<p>Now, inlining calls and blocks at the bytecode level is nice, but another way of lowering code is to implement some function as a <em>primitive</em>: i.e. handling it as its own special case in the interpreter. Primitives are everywhere and unavoidable in PL implementation: just ask yourself how you would allow a program to perform a system call like <code>time</code> , and you’ll find making a primitive for it is a very sensible solution.</p>

<p>In this case, I’m confident that specialized bytecode would be faster, but I figured a primitive would be a quick and easy solution so I could move on to trying to squeeze (hopefully major) performance wins elsewhere. Especially since there’s <code>Integer&gt;&gt;#to:do:</code> but also <code>Integer&gt;&gt;#to:by:do:</code> and <code>Integer&gt;&gt;#downTo:do:</code> and <code>Integer&gt;&gt;#downTo:by:do:</code> and they all have different behaviors and I am lazy. I’d rather make them primitives with nearly identical code than wrap my head around how bytecode should be generated for each - we want an easy, in and out, 20 minute adventure (spoilers: I have forgotten <a href="https://en.wikipedia.org/wiki/Hofstadter%27s_law">Hofstadter’s law</a> yet again)</p>

<p>So here’s our <code>to:do:</code> primitive:</p>

<div><div><pre><code><span>fn</span> <span>to_do</span><span>(</span><span>interpreter</span><span>:</span> <span>&amp;</span><span>mut</span> <span>Interpreter</span><span>,</span> <span>_</span><span>:</span> <span>&amp;</span><span>mut</span> <span>Universe</span><span>)</span> <span>{</span>
    <span>const</span> <span>SIGNATURE</span><span>:</span> <span>&amp;</span><span>str</span> <span>=</span> <span>&#34;Integer&gt;&gt;to:do:&#34;</span><span>;</span>

    <span>expect_args!</span><span>(</span><span>SIGNATURE</span><span>,</span> <span>interpreter</span><span>,</span> <span>[</span>
        <span>Value</span><span>::</span><span>Integer</span><span>(</span><span>start</span><span>)</span> <span>=&gt;</span> <span>start</span><span>,</span>
        <span>Value</span><span>::</span><span>Integer</span><span>(</span><span>end</span><span>)</span> <span>=&gt;</span> <span>end</span><span>,</span>
        <span>Value</span><span>::</span><span>Block</span><span>(</span><span>blk</span><span>)</span> <span>=&gt;</span> <span>blk</span><span>,</span>
    <span>]);</span>

    <span>for</span> <span>i</span> <span>in</span> <span>start</span><span>..=</span><span>end</span> <span>{</span>
        <span>todo!</span><span>(</span><span>&#34;execute the block every time&#34;</span><span>);</span>
    <span>}</span>

    <span>interpreter</span><span>.stack</span><span>.push</span><span>(</span><span>Value</span><span>::</span><span>Integer</span><span>(</span><span>start</span><span>));</span>
<span>}</span>
</code></pre></div></div>

<p><code>expect_args!</code> is a macro that pops arguments from the stack (because this is a stack-based bytecode interpreter, by the way) and checks their types. In this case, we expect three: if we’re calling <code>1 to: 50 do: [ ... ]</code> , we expect <code>start</code> to be 1, <code>end</code> to be 50 and <code>blk</code> to be the body block.</p>

<p>Then from 1 to 50 (using Rust’s nice <code>..=</code> inclusive range syntax), we’ll execute the body block somehow. Then every method returns its caller (<code>self</code>) when there’s no explicit return, which in this case is <code>start</code> (remember this is a method defined ON an integer class, which means <code>self</code> is an Integer with a value of 1!), so we put <code>start</code> back on the stack.</p>

<p>Neat. It’s missing a critical part though…</p>

<h3 id="how-do-we-execute-that-block">how do we execute that block?</h3>

<p>The bytecode loop for som-rs is a big <code>run</code> method invoked once at the start of the program and which continues until execution ends. There’s a call stack of method/block frames that gets added onto throughout execution depending on what calls are made, and getting the current bytecode is just a matter of accessing the current frame (the last on the frames stack) and reading the bytecode from it that corresponds to the current bytecode index.</p>

<p>If the bytecode says you need to return from a function, you pop from the frames stack and so the current frame switches back to the previous one. To call a new function/block, you push a new function/block frame and it becomes the current frame.</p>

<p>So with that in mind, this primitive should just be a matter of pushing… 50 new block frames. Which doesn’t sound like the best way to go about it, but I can’t think of a better way to do it with of our bytecode interpreter design. Easy:</p>

<div><div><pre><code><span>for</span> <span>i</span> <span>in</span> <span>(</span><span>start</span><span>..=</span><span>end</span><span>)</span><span>.rev</span><span>()</span> <span>{</span>
    <span>interpreter</span><span>.push_block_frame</span><span>(</span><span>Rc</span><span>::</span><span>clone</span><span>(</span><span>&amp;</span><span>blk</span><span>),</span> <span>vec!</span><span>[</span><span>Value</span><span>::</span><span>Block</span><span>(</span><span>Rc</span><span>::</span><span>clone</span><span>(</span><span>&amp;</span><span>blk</span><span>)),</span> <span>Value</span><span>::</span><span>Integer</span><span>(</span><span>i</span><span>)]);</span>
<span>}</span>
</code></pre></div></div>

<p><code>push_block_frame</code> needs two arguments: the block to make a frame out of, and a vector containing the arguments it should be executed with. The first argument of a block is always itself, and <code>to:do:</code> semantics are that the block takes in the range index as an argument, so that’s why <code>Value::Integer(i)</code> is there.</p>

<p>Since a stack is last-in-first-out, we call <code>rev()</code> on the range so that we add the “50” block first on the frame stack and the “1” block last, such that we execute the “1” frame first, then the “2” frame, etc., all the way to “50”.</p>

<p>Job’s done, so we can just run it with a random benchmark and -</p>

<div><div><pre><code><span>Starting</span> <span>QuickSort</span> <span>benchmark</span><span>.
thread</span> <span>&#39;main</span><span>&#39;</span> <span>panicked</span> <span>at</span> <span>som</span><span>-</span><span>interpreter</span><span>-</span><span>bc</span><span>/</span><span>src</span><span>/</span><span>universe</span><span>.rs</span><span>:</span><span>527</span><span>:</span><span>9</span><span>:</span>
<span>does</span> <span>not</span> <span>understand</span><span>:</span> <span>&#34;verifyResult:&#34;</span>
<span>note</span><span>:</span> <span>run</span> <span>with</span> <span>`</span><span>RUST_BACKTRACE</span><span>=</span><span>1</span><span>`</span> <span>environment</span> <span>variable</span> <span>to</span> <span>display</span> <span>a</span> <span>backtrace</span>
</code></pre></div></div>

<ul>
  <li>and we broke the interpreter somehow. Why?</li>
</ul>

<p>This kind of error really just means “the stack got messed up and that caused the interpreter to panic somewhere down the line afterwards”. <code>verifyResult:</code> exists, it was just called on the wrong class because the stack didn’t contain the right values in the right order.</p>

<p>And that gives us a hint as to why it broke. Earlier I mentioned “every method returns its caller (<code>self</code>) when there’s no explicit return”: every single method or block returns something, which gets put on the stack. But in this case, we really don’t care about whatever the block returns, and the real <code>to:do:</code> pops it off the stack after each execution.</p>

<p>So we need to call POP after each block. The issue is that with our current interpreter design, there’s no easy way to inform the interpreter to do that. TruffleSOM and PySOM (our two best interpreters) don’t have a single big <code>run</code> bytecode loop, and in fact call the bytecode loop function for each method individually, so it’s pretty easy to say “invoke this method and then discard its results” - just call <code>run_bytecode_loop(method)</code>. No such luxury here.</p>

<h3 id="selling-my-soul-for-performance">selling my soul for performance</h3>

<p>OK, here’s a fix: add an <code>am_i_ugly</code> flag to every frame, set it to <code>true</code> only for these specific <code>to:do:</code> frames, and whenever we pop a frame (i.e. we return from a block/function) if the frame had that flag, we pop a value off the stack to ignore its output. And that works pretty damn well: look at that speedup!</p>

<p><img src="https://octavelarose.github.io/assets/2024-05-29-to-do-inlining/ugly_changes_1.png" alt="after ugly changes"/></p>

<p>But I’ve got two major issues:</p>

<ul>
  <li>A) this is ugly code and I hate it very much</li>
  <li>B) this is a slowdown in some odd cases - up to 15%. I assume that making <em>every</em> frame have a bigger/different layout prevents some compiler optimizations, or slows down accesses to frame info. I don’t know what’s happening specifically, but I’m sure of what caused it: this extra argument.</li>
</ul>

<p>It’s a working solution though, so I went ahead and implemented the other variations like <code>to:by:do:</code> and <code>downTo:do:</code> and whatnot, to see what the total speedup was like. Which would be this:</p>

<p><img src="https://octavelarose.github.io/assets/2024-05-29-to-do-inlining/ugly_changes_2.png" alt="after ugly changes 2"/></p>

<p>Looks reaaal good. A 100% speedup on one of our benchmarks even (one whose runtime is extremely dominated by a <code>to:by:do:</code> call)! The code sucks, but we’re at least on the right track.</p>

<p>So we’re back to the drawing board when it comes to informing the interpreter to clean up after some blocks. I guess we could also store some sort of state in the interpreter instead of in each frame, which would likely be faster and wouldn’t prevent compiler optimizations, but it’d be a pretty unclean solution and not as straightforward as one might think (we can’t just tell it: “do a POP after the next 50 frames”, because those <code>to:do:</code> frames may invoke nested blocks of their own, so it still needs to track info on a frame-by-frame basis).</p>

<h3 id="a-better-solution">a better solution</h3>

<p>I’ve got a better idea: instead of executing the block as is, we execute a <em>modified</em> version of the block that cleans up after itself.</p>

<p>Say we’ve got this block:</p>

<div><div><pre><code>PUSH_ARG 1, 1   # stack: [arg1-1]
PUSH_ARG 0, 1   # stack: [arg1-1, arg0-1]
SEND_2 0        # stack: [send-return-value]
RETURN_LOCAL    # stack: [send-return-value]
</code></pre></div></div>

<p>I’ve described the stack state next to each bytecode. Any <code>PUSH</code> bytecode is naturally going to push something onto the stack; a <code>SEND</code> will consume arguments to emit a single return value; and a <code>RETURN_LOCAL</code> won’t touch the stack, it just pops a frame.</p>

<p>We want an empty stack, so we want to generate this new block right there instead:</p>

<div><div><pre><code><span>PUSH_ARG</span> <span>1</span><span>,</span> <span>1</span>   <span>#</span> <span>stack</span><span>:</span> <span>[</span><span>arg1</span><span>-</span><span>1</span><span>]</span>
<span>PUSH_ARG</span> <span>0</span><span>,</span> <span>1</span>   <span>#</span> <span>stack</span><span>:</span> <span>[</span><span>arg1</span><span>-</span><span>1</span><span>,</span> <span>arg0</span><span>-</span><span>1</span><span>]</span>
<span>SEND_2</span> <span>0</span>        <span>#</span> <span>stack</span><span>:</span> <span>[</span><span>send</span><span>-</span><span>return</span><span>-</span><span>value</span><span>]</span>
<span>POP</span>             <span>#</span> <span>stack</span><span>:</span> <span>[]</span>
<span>RETURN_LOCAL</span>    <span>#</span> <span>stack</span><span>:</span> <span>[]</span>
</code></pre></div></div>

<p>So what we do is that instead of invoking the block, calling <code>to:do:</code> first creates a new block based on the existing one with a POP added before every RETURN, and we execute that instead! It’s kind of annoying since creating that block means checking which <code>JUMP</code> bytecodes need to be adjusted, since if we’ve got a <code>JUMP 10</code> bytecode (meaning “jump to 10 instructions further”) and there’s a RETURN in the middle which we prepended with a <code>POP</code> , it now has to become a <code>JUMP 11</code> to account for the new instruction.</p>

<p>Way more annoyingly, there is such a thing as a <code>RETURN_NON_LOCAL</code> in our bytecode set. I don’t have time to go into non-local returns (this article is long enough as is), but we want to actually <em>keep</em> whatever return value is associated with a non-local return on the stack, while making sure to remove the SECOND TO LAST value on the stack which corresponds to the <code>self</code> value that we <em>want</em> to clean up. So my supervisor suggested I add a <code>POP2</code> bytecode which pops the second to last value off the stack, to easily do just that - and I did, and it worked.</p>

<p>This was confusing, hard to discover and understand, needed amending the goddamn bytecode set itself, and cost me many hours of my life that I’m never getting back :(</p>

<p>So the <code>to:do:</code> code is now:</p>

<div><div><pre><code><span>let</span> <span>new_block_rc</span> <span>=</span> <span>blk</span><span>.make_equivalent_with_no_return</span><span>();</span>
<span>for</span> <span>i</span> <span>in</span> <span>(</span><span>start</span><span>..=</span><span>end</span><span>)</span><span>.rev</span><span>()</span> <span>{</span>
    <span>interpreter</span><span>.push_block_frame</span><span>(</span><span>Rc</span><span>::</span><span>clone</span><span>(</span><span>&amp;</span><span>new_block_rc</span><span>),</span> <span>vec!</span><span>[</span><span>Value</span><span>::</span><span>Block</span><span>(</span><span>Rc</span><span>::</span><span>clone</span><span>(</span><span>&amp;</span><span>new_block_rc</span><span>)),</span> <span>Value</span><span>::</span><span>Integer</span><span>(</span><span>i</span><span>)]);</span>
<span>}</span>
</code></pre></div></div>

<p>We could do even better: generating the block at compile-time instead of parse-time. When handling messages (function calls), if its name is <code>to:do:</code> or one of its friends, we would simply replace its block argument with our new, optimized one. Something pretty much like this:</p>

<div><div><pre><code><span>if</span> <span>[</span><span>&#34;to:do:&#34;</span><span>,</span> <span>&#34;to:by:do:&#34;</span><span>,</span> <span>&#34;downTo:do:&#34;</span><span>,</span> <span>&#34;downTo:by:do:&#34;</span><span>,</span> <span>&#34;timesRepeat:&#34;</span><span>]</span><span>.iter</span><span>()</span><span>.any</span><span>(|</span><span>s</span><span>|</span> <span>*</span><span>s</span> <span>==</span> <span>message</span><span>.signature</span><span>)</span> <span>{</span>
    <span>match</span> <span>ctxt</span><span>.get_instructions</span><span>()</span><span>.last</span><span>()</span><span>.unwrap</span><span>()</span> <span>{</span>
        <span>Bytecode</span><span>::</span><span>PushBlock</span><span>(</span><span>idx</span><span>)</span> <span>=&gt;</span> <span>{</span>
            <span>// find block from index &#34;idx&#34;</span>
            <span>// call our new `make_equivalent_with_no_return()`;</span>
            <span>// replace the block</span>
        <span>},</span>
        <span>_</span> <span>=&gt;</span> <span>{</span> <span>todo!</span><span>(</span><span>&#34;uh... what&#39;s this case?&#34;</span><span>)</span> <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>…except it’s not that simple, and this <code>todo!(&#34;...&#34;)</code> case highlights why. If the block is the result of a <code>PushArgument</code> or <code>PushLocal</code> or whatnot, we can only get access to it during the runtime. So this sadly isn’t an easily available option, which is a shame since it would net us up a median speedup of 8% or so. <sup id="fnref:better-block-solution" role="doc-noteref"><a href="#fn:better-block-solution" rel="footnote">2</a></sup></p>

<p>So we keep our previous solution of creating modified blocks at runtime. OK, final results:</p>

<p><img src="https://octavelarose.github.io/assets/2024-05-29-to-do-inlining/final_results.png" alt="final results"/></p>

<p>Massive speedups! It’s a very minor slowdown on one of our microbenchmarks and I’m not sure why - <a href="https://stefan-marr.de/2020/07/is-this-noise-or-does-this-mean-something-benchmarking/">maybe it’s just noise</a>.</p>

<h2 id="so-what-have-we-learned">so what have we learned?</h2>

<ul>
  <li>being mindful of the design of the interpreter itself matters, unsurprisingly. Choosing to have a single execution of a massive bytecode loop function, as opposed to designing the interpreter such that the bytecode loop function is invoked for each method call, makes things <em>much</em> harder in this context.
    <ul>
      <li>It doesn’t sound like a bad design decision to me, but is it? It’s hard for me to tell since I’m lacking experience. Let me know more about why that’s a bad idea if you know!</li>
      <li>If not enough people point out to me that it is in fact a bad idea, I’d be interested to rebuild the bytecode interpreter to fix that design decision, and see if it’s faster. But I’d need to push the performance a lot more first.</li>
    </ul>
  </li>
  <li>There’s a lot of performance to be gained from optimizing loop operations. It’s fairly obvious, but a solid chunk of the runtime will be spent in long-running loops: if you can make them all a bit smoother, you make runtime a lot faster.</li>
  <li>Aaaand the quick and easy solution is rarely quick or easy. This was never meant to be so arduous - this whole “let’s make a primitive function” idea was meant to take an hour tops to avoid spending a couple hours implementing it at the bytecode level, but it ended up taking much longer! I don’t think I could have easily predicted this seemingly easy change would be so hard: this requires a lot of knowledge about the system you’re working with and about interpreter design, yet I’m but a humble PhD student. We’re getting there though.</li>
</ul>

<p>That’s about it. Thanks to <a href="https://stefan-marr.de/">Stefan Marr</a> (my PhD supervisor) for the feedback and the help. I’ll post more stuff in the future. xoxo</p>

<hr/>



  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
