<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ahgamut.github.io/2022/07/27/ape-rust-example/">Original</a>
    <h1>Rust Is Actually Portable</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
<article>
<blockquote>
<p>aka “Rust is Actually Portable”, after <a href="https://ahgamut.github.io/2021/02/27/ape-cosmo/">Lua</a> and <a href="https://ahgamut.github.io/2021/07/13/ape-python/">Python</a></p>
</blockquote>
<p>I just built a <a href="https://rust-lang.org">Rust</a> executable that runs on six operating systems
(Linux, Windows, MacOS, FreeBSD, NetBSD, OpenBSD). If you’d like to build it
yourself, clone <a href="https://github.com/ahgamut/rust-ape-example">this repo</a> and follow the README – you’ll need a recent
<code>gcc</code>, <code>ld.bfd</code>, <code>objcopy</code>, <code>bash</code>, and the latest (nightly) versions of
<code>cargo</code>, <code>rustc</code>, and friends.</p>
<p>I’ve been recently getting into Rust, and it seems pretty cool! I’ve also gotten
a bunch of software to run on <a href="https://github.com/jart/cosmopolitan">Cosmopolitan Libc</a> over the last
year<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>, so in June I thought combining Rust with Cosmopolitan Libc would
be interesting. Here’s how I got to a <code>hello world!</code> Actually Portable
Executable with Rust.</p>
<h2 id="a-minimal-executable">A minimal executable</h2>
<p>A good thing about Rust was, unlike Python or Lua, no messing around with C
headers. Just find a way to tell <code>cargo</code> to link with <code>cosmopolitan.a</code> at the
very end, and you get an APE. I looked up the <a href="https://docs.rust-embedded.org/embedonomicon/preface.html">Rust
Embedonomicon</a> and
built a <code>no_std</code> example, but it wasn’t that useful – the executable just
crashed and I didn’t know if it was on purpose. But the Embedonomicon also
described how I could create a <a href="https://docs.rust-embedded.org/embedonomicon/custom-target.html">custom target for
Rust</a>, based on
the available targets. Jackpot!</p>
<p>I created a custom target called <code>cosmo.json</code>, based on the existing
<code>x86_64-linux-unknown-gnu</code> and <code>x86_64-linux-unknown-musl</code>. It took some trial
and error (I set up my own <code>panic</code> handler, but then it clashed with
<code>panic_abort</code>, but then it didn’t when I changed the flags to cargo), but
eventually I got this simple example below to compile (I took it from some
online Rust discussion about the <code>libc</code> crate, I think the code was written by
<a href="https://github.com/steveklabnik"><code>steveklabnik</code></a>).</p>
<div><pre tabindex="0"><code data-lang="rust"><span>#![no_main]</span><span>
</span><span></span><span>#![no_std]</span><span>
</span><span></span><span>#![feature(rustc_private)]</span><span>
</span><span></span><span>extern</span><span> </span><span>crate</span><span> </span><span>libc</span><span>;</span><span>
</span><span>
</span><span></span><span>#[no_mangle]</span><span>
</span><span></span><span>pub</span><span> </span><span>extern</span><span> </span><span>&#34;C&#34;</span><span> </span><span>fn</span> <span>main</span><span>(</span><span>_argc</span>: <span>isize</span><span>,</span><span> </span><span>_argv</span>: <span>*</span><span>const</span><span> </span><span>*</span><span>const</span><span> </span><span>u8</span><span>)</span><span> </span>-&gt; <span>isize</span> <span>{</span><span>
</span><span>    </span><span>const</span><span> </span><span>HELLO</span>: <span>&amp;</span><span>&#39;</span><span>static</span> <span>str</span> <span>=</span><span> </span><span>&#34;Hello, world! %d + %d = %d\n\0&#34;</span><span>;</span><span>
</span><span>    </span><span>let</span><span> </span><span>x</span>: <span>i32</span> <span>=</span><span> </span><span>1</span><span>;</span><span>
</span><span>    </span><span>let</span><span> </span><span>y</span>: <span>i32</span> <span>=</span><span> </span><span>2</span><span>;</span><span>
</span><span>    </span><span>unsafe</span><span> </span><span>{</span><span>
</span><span>        </span><span>libc</span>::<span>printf</span><span>(</span><span>HELLO</span><span>.</span><span>as_ptr</span><span>()</span><span> </span><span>as</span><span> </span><span>*</span><span>const</span><span> </span><span>_</span><span>,</span><span> </span><span>x</span><span>,</span><span> </span><span>y</span><span>,</span><span> </span><span>x</span><span>+</span><span>y</span><span>);</span><span>
</span><span>    </span><span>}</span><span>
</span><span>    </span><span>0</span><span>
</span><span></span><span>}</span><span>
</span><span>
</span><span></span><span>#[panic_handler]</span><span>
</span><span></span><span>fn</span> <span>my_panic</span><span>(</span><span>_info</span>: <span>&amp;</span><span>core</span>::<span>panic</span>::<span>PanicInfo</span><span>)</span><span> </span>-&gt; <span>!</span><span> </span><span>{</span><span>
</span><span>    </span><span>loop</span><span> </span><span>{}</span><span>
</span><span></span><span>}</span><span>
</span></code></pre></div><p>Once I got the <code>libc</code> crate to work, I could do a lot of things. I took a bunch
of simple C programs, rewrote them in unsafe Rust with the <code>libc</code> crate, and
generally checked if the build process was okay.</p>
<h2 id="building-the-std-crate">Building the <code>std</code> crate</h2>
<p>Now I had some simple Rust APEs, but I felt that saying “Rust is Actually
Portable” and then showing a bunch of C-like programs with unsafe wouldn’t cut
it, so I went on another round of debugging to get the <code>std</code> crate to build.</p>
<p>The <code>std</code> crate pulls in a lot of different crates! There’s <code>core</code>, <code>libc</code>, and
<code>alloc</code>, which I used for the above example, <code>panic_abort</code>, <code>panic_unwind</code>,
<code>backtrace</code>, and <code>proc_macro</code>, and subcomponents of <code>std</code> itself. I got a tour
of the code in the <code>std</code> crate by writing an incomplete target <code>cosmo.json</code>: I’d
change a configuration flag, some part of <code>std</code> would break because my flag was
wrong, and I’d learn something new about Rust and how <code>std</code> worked.</p>
<p>Once I figured out the right flags in the target <code>cosmo.json</code>, most of the bugs
with <code>std</code> went away. The few that remained deserve special mention because it
took me a while to fix them.</p>
<h2 id="weird-bugs-and-their-workarounds">Weird bugs and their workarounds</h2>
<p>One of the weird bugs was internet-related code of <code>std</code> which called the <code>libc</code>
crate (like <code>struct hostent</code> or something). I went through Cosmopolitan Libc
source code, and everything seemed fine, so the mistake was elsewhere. I
modified the <code>std</code> crate trying to figure out what was going on. After a bunch
of different compiler errors and searching on the internet, I found the issue
was with <em>the filename of my target JSON</em>. So some part of the code or build
process uses the filename of the JSON, which was <code>cosmo.json</code> at that time, but
it specifically needs a target name like <code>x86_64-linux-unknown-cosmo</code>, otherwise
some <del>ifdef</del> <code>cfg_if</code> falls through and breaks a bunch of things. Why does the
name of the JSON matter? I don’t know, but I’m happy that this bug doesn’t
bother me anymore.</p>
<p>The next “bug” is more a comment about <code>cargo</code>, and is probably because I’m
still new to Rust. <code>cargo</code> is a wonderful package manager, and building
projects is pretty smooth. But once it comes to building the <code>std</code> crate, some
of the convenience disappears, and I’d like a bit more flexibility in specifying
what I want cargo to do. I’m building a static executable, and I’d like to say,
“okay <code>cargo</code> forget about linking <code>-lunwind</code> or <code>-lm</code> or whatever, just listen
to me, <code>cosmopolitan.a</code> has everything you need for this”, but I couldn’t find
any combination of flags to communicate this. Eventually I gave up and wrote a
<code>bash</code> script which just filtered out all the linker arguments I didn’t want
before calling <code>gcc</code>.</p>
<p>The last set of bugs were at the link stage – I had every crate compiling
without error, but when linking the executable, I found that I was missing a few
symbols. Some were easy to add, like <code>stat64</code> and <code>__xpg_strerror_r</code>, but the
<code>std</code> crate required the pthreads key API (<code>pthread_key_create</code> etc.) to be
implemented, which was weird because I thought I had specified single-threaded
in <code>cosmo.json</code>. Another dependency of the <code>std</code> crate was
<a href="https://github.com/rust-lang/backtrace-rs"><code>backtrace</code></a>, which requires
<a href="https://github.com/libunwind/libunwind"><code>libunwind</code></a> in the default linux
builds even though there is a <code>noop</code> crate that can be used for <code>std</code>. I
couldn’t figure out the right flags to avoid these linker errors, so I wrote
<a href="https://github.com/ahgamut/rust-ape-example/blob/f6ae82160c39814fcc99e2301aa266357e082bb1/libcosmo/stubs.c">some dumb
stubs</a>
to just get by the linker. A couple of days later, <a href="https://github.com/jart">Justine
Tunney</a> implemented the pthreads key API in
Cosmopolitan Libc, and I asked Justine to add the <code>libunwind</code> stubs as well so
<code>backtrace</code> wouldn’t complain. I think there should be a <code>cargo</code> flag or
something to choose using the <code>noop</code> crate in <code>backtrace</code> when compiling <code>std</code>.</p>
<p>Anyway, once I got through these linker errors, I downloaded the latest
<code>cosmopolitan.zip</code> amalgamation from
<a href="https://justine.lol/cosmopolitan/cosmopolitan.zip">here</a>, and now I could build
some Actually Portable Executables with Rust.</p>
<h2 id="hello-world-and-a-few-examples"><code>Hello World!</code> and a few examples</h2>
<p>Rust is Actually Portable: here’s the hello world program that uses Rust and
Cosmopolitan Libc:</p>
<div><pre tabindex="0"><code data-lang="rust"><span>fn</span> <span>main</span><span>()</span><span> </span><span>{</span><span>
</span><span>    </span><span>println!</span><span>(</span><span>&#34;Hello World! This is an APE built with Rust.&#34;</span><span>);</span><span>
</span><span></span><span>}</span><span>
</span></code></pre></div><p>That’s it. No unsafe, no changes to the Rust <code>std</code> source code. You just need to
provide the right flags to <code>cargo</code>, and done. I also picked the first few
examples from <a href="https://doc.rust-lang.org/rust-by-example/">Rust By Example</a> to
build and try, and they all worked as expected. I’ve not tried a lot of things,
so there’s room for experimentation and submitting PRs with Rust code (like with
<code>backtrace</code>) and to Cosmopolitan Libc (implementing the <code>libunwind</code> stubs or
filling out the pthreads API).</p>
<h2 id="closing-notes">Closing Notes</h2>
<p>I feel the package manager and documentation of Rust are big reasons why it is
so popular. Being new to Rust, I was able to learn about safe vs unsafe, the
<code>libc</code> crate, <code>cargo</code>, the <code>std</code> crate, <code>backtrace</code>, <code>panic</code>, <code>rustc</code>, and what
Rust-generated assembly looked like, all over maybe a couple of weekend
afternoons. Cosmopolitan Libc provided a unique angle to tour Rust, and it was a
<em>lot of fun</em> to discover all of this.</p>
<p>Last March, Lua was the first language to be ported to Cosmopolitan Libc. At
that time, parts of the libc API were still missing; when porting Python I
submitted PRs for <code>getnameinfo</code>, <code>struct servent</code> etc. so Python’s <code>socket</code>
library would work. But since that time a lot of work has been put into
Cosmopolitan Libc, so that software built on it can be fun to develop and fast.
The almost-complete libc API has made it so much easier to port software – Rust
just needed a JSON file and some flags to <code>cargo</code>! I’m pretty sure a lot of
software can be built with Cosmopolitan Libc, it’s just a matter of convincing
the build system. If someone figures out a way to even partially automate this
(say like <a href="https://www.freebsd.org/ports/">FreeBSD’s ports</a>), that would be
amazing.</p>

</article>
</div></div>
  </body>
</html>
