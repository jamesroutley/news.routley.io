<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://30fps.net/pages/perceptual-pico8-pixel-mapping/">Original</a>
    <h1>Mapping to the PICO-8 palette, perceptually</h1>
    
    <div id="readability-page-1" class="page"><div id="text">

<p>Given a palette and an image, how would you map each pixel to a color in the palette?
In this article we’ll investigate how an advanced perceptual color space (CAM16-UCS) compares to simpler alternatives.</p>
<p>For this experiment I chose a somewhat strange cropped still from the <a href="https://peach.blender.org/">Big Buck Bunny short</a> and the <a href="https://www.lexaloffle.com/pico-8.php">PICO-8</a> fantasy console’s 16-color palette:</p>
<p><img src="https://30fps.net/pages/perceptual-pico8-pixel-mapping/input_and_palette.png"/></p>
<p>A simple way to map pixels to palette colors is to compute the Euclidean distance between each pixel and palette color, and choose the one with the shortest distance.
Note that this method completely discards any structure in the image, which puts a limit on how good the results can look.
We can’t for example allocate more shades to smooth regions to avoid banding.
But this is the simplest way.</p>
<p>If done in regular sRGB, the results are interesting but not really faithful, but by weighting the RGB channels by their luminance contribution and increasing contrast a bit (<a href="https://github.com/ImageOptim/libimagequant/">libimagequant’s</a> color space), sRGB looks decent:</p>
<p><img src="https://30fps.net/pages/perceptual-pico8-pixel-mapping/srgb_result.png"/></p>
<p>We don’t need to limit ourselves to sRGB-derived spaces.
The <a href="https://en.wikipedia.org/wiki/Color_appearance_model#CAM16">CAM16 color appearance model</a> includes a “UCS”, <em>Uniform Color Space</em>, in which Euclidean distances should correspond more accurately to perceived color distances.
So is it better for this task?
Well it’s hard to say if “CAM16-UCS” really looks better below when compared to <a href="https://en.wikipedia.org/wiki/Oklab_color_space">Oklab</a> or <a href="https://30fps.net/pages/hyab-kmeans/">CIELAB with 3x luminance weight and HyAB distance</a>:</p>
<figure>
<img src="https://30fps.net/pages/perceptual-pico8-pixel-mapping/input_cam16-ucs_oklab_cielab-hyab.png" alt="Pixel mapping results in CAM-16 UCS, Oklab, and weighted CIELAB color spaces."/>
<figcaption aria-hidden="true">Pixel mapping results in CAM-16 UCS, Oklab, and weighted CIELAB color spaces.</figcaption>
</figure>
<p>Perhaps this problem is so ill-defined that no color space can help us in a setting where image’s spatial structure is not taken into account.
Another factor is that the CAM16-UCS space depends on “viewing conditions”, which are assumptions of the viewer’s eyes physical state that depend on environment lighting and the time there’s been to adapt to the visual stimuli.</p>
<p>In the <a href="https://colour.readthedocs.io/en/develop/generated/colour.XYZ_to_CAM16UCS.html"><strong>colour</strong> Python library’s API</a>, we can easily toggle between “average”, “dim”, or “dark” viewing conditions, apparently defined in the earlier <a href="https://en.wikipedia.org/wiki/CIECAM02">CIECAM02 color appearance model</a>:</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span># Convert sRGB to XYZ color space</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>srgb_u8 <span>=</span> np.array(img)[...,:<span>3</span>]</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>xyz <span>=</span> colour.sRGB_to_XYZ(srgb_u8<span>/</span><span>255.0</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span># UCS-16 in dim viewing conditions</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>dim_surround <span>=</span> colour.VIEWING_CONDITIONS_CAM16[<span>&#34;Dim&#34;</span>]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>ucs16_dim <span>=</span> colour.XYZ_to_CAM16UCS(xyz, surround<span>=</span>dim_surround)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span># UCS-16 in well-lit viewing conditions</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>avg_surround <span>=</span> colour.VIEWING_CONDITIONS_CAM16[<span>&#34;Average&#34;</span>]</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>ucs16 <span>=</span> colour.XYZ_to_CAM16UCS(xyz, surround<span>=</span>avg_surround)</span></code></pre></div>
<p><img src="https://30fps.net/pages/perceptual-pico8-pixel-mapping/dim_vs_average.png"/></p>
<p>There definitely is a difference between the two but neither looks like the Oklab result.
Interestingly, <a href="https://bottosson.github.io/posts/oklab/#motivation-and-derivation-of-oklab">the original blog post</a> where Oklab was introduced says it “should assume normal well lit viewing conditions.”</p>
<p>So, in conclusion, CAM16-UCS didn’t look better than Oklab or weighted CIELAB.
All three beat luma-weighted sRGB, though.
CAM16-UCS results were also surprisingly far from Oklab, which I can’t explain.
For acceptable quality, I suppose in this task you have to look at the actual image, not just its colors.</p>
<hr/>
<p>Just for fun, I tried pumping the luminance weight so high that we’ll be effectively reproducing a greyscale image with the PICO-8 palette:</p>
<figure>
<img src="https://30fps.net/pages/perceptual-pico8-pixel-mapping/oklab_L_only.png" alt="Color distance from lightness alone, ignoring chromaticities."/>
<figcaption aria-hidden="true">Color distance from lightness alone, ignoring chromaticities.</figcaption>
</figure>
<p>Unfortunately that doesn’t work either because the reds and greens <em>really</em> stick out.
I think this is <a href="https://en.wikipedia.org/wiki/Helmholtz%E2%80%93Kohlrausch_effect">the Helmholtz-Kohlrausch effect</a> in action, not taken into account by Oklab’s luminance formula.</p>
<p><em>I’m writing a book on computer graphics. <a href="https://30fps.net/book">Sign up here</a> if you’re interested.</em></p>
<h2 id="appendix-a-more-result-images">Appendix A: More result images</h2>
<p>For reference, here are all the result images from my experiment in a single plot.
CIELAB on its own looked so poor I took the weighted HyAB version in earlier comparisons.</p>
<ul>
<li><a href="https://30fps.net/pages/perceptual-pico8-pixel-mapping/all_results.png">all_results.png</a> (1.8 MiB)</li>
</ul>
<h2 id="appendix-b-source-code">Appendix B: Source code</h2>
<p>Here are the functions I used for pixel mapping.
Like said earlier, I used the <a href="https://colour.readthedocs.io/en/develop/"><strong>colour</strong></a> library for conversions.</p>
<details>
<summary>
NumPy Python code
</summary>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span># The PICO-8 palette</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>palette_srgb_u8 <span>=</span> np.array([</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    (<span>0x00</span>, <span>0x00</span>, <span>0x00</span>),</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    (<span>0x1d</span>, <span>0x2b</span>, <span>0x53</span>),</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    (<span>0x7e</span>, <span>0x25</span>, <span>0x53</span>),</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    (<span>0x00</span>, <span>0x87</span>, <span>0x51</span>),</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    (<span>0xab</span>, <span>0x52</span>, <span>0x36</span>),</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    (<span>0x5f</span>, <span>0x57</span>, <span>0x4f</span>),</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    (<span>0xc2</span>, <span>0xc3</span>, <span>0xc7</span>),</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    (<span>0xff</span>, <span>0xf1</span>, <span>0xe8</span>),</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    (<span>0xff</span>, <span>0x00</span>, <span>0x4d</span>),</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    (<span>0xff</span>, <span>0xa3</span>, <span>0x00</span>),</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    (<span>0xff</span>, <span>0xec</span>, <span>0x27</span>),</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    (<span>0x00</span>, <span>0xe4</span>, <span>0x36</span>),</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    (<span>0x29</span>, <span>0xad</span>, <span>0xff</span>),</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    (<span>0x83</span>, <span>0x76</span>, <span>0x9c</span>),</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    (<span>0xff</span>, <span>0x77</span>, <span>0xa8</span>),</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    (<span>0xff</span>, <span>0xcc</span>, <span>0xaa</span>),</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    <span># (0x29, 0x18, 0x14), # the secret palette begins here :)</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    <span># (0x11, 0x1d, 0x35),</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    <span># (0x42, 0x21, 0x36),</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    <span># (0x12, 0x53, 0x59),</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>    <span># (0x74, 0x2f, 0x29),</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    <span># (0x49, 0x33, 0x3b),</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>    <span># (0xa2, 0x88, 0x79),</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    <span># (0xf3, 0xef, 0x7d),</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>    <span># (0xbe, 0x12, 0x50),</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>    <span># (0xff, 0x6c, 0x24),</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>    <span># (0xa8, 0xe7, 0x2e),</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>    <span># (0x00, 0xb5, 0x43),</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>    <span># (0x06, 0x5a, 0xb5),</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>    <span># (0x75, 0x46, 0x65),</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>    <span># (0xff, 0x6e, 0x59),</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>    <span># (0xff, 0x9d, 0x81),</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>], dtype<span>=</span>np.uint8)</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a><span>def</span> euclidean_distance(a, b):</span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>    delta <span>=</span> a <span>-</span> b</span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>    <span>return</span> np.sqrt(np.<span>sum</span>(delta<span>**</span><span>2</span>, axis<span>=-</span><span>1</span>))</span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a><span>def</span> weighted_rgb_distance(a, b):</span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>    <span># Weighting and internal gamma chosen to match libimagequant</span></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>    <span># See https://github.com/ImageOptim/libimagequant/blob/6aad8f20b28185823813b8bd6823171711480dca/src/pal.rs#L12C1-L19C38</span></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>    <span># Convert from sRGB to internal 1.754 gamma, giving more weight to bright colors.</span></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>    <span># Equal to 0.57/0.4545 = 0.57 / (1/2.2)</span></span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>    <span># </span><span>NOTE</span><span>: Does not match libimagequant&#39;s behavior exactly, just my best attempt</span></span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>    power <span>=</span> <span>2.2</span><span>/</span><span>1.754</span></span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>    channel_weights <span>=</span> np.array([[[<span>0.5</span>, <span>1.00</span>, <span>0.45</span>]]])</span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>    aw <span>=</span> a <span>*</span> channel_weights</span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>    bw <span>=</span> b <span>*</span> channel_weights</span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a>    delta <span>=</span> aw<span>**</span>power <span>-</span> bw<span>**</span>power</span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>    <span>return</span> np.sqrt(np.<span>sum</span>(delta<span>**</span><span>2</span>, axis<span>=-</span><span>1</span>))</span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a><span>def</span> hyab_distance(a, b):</span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a>    delta <span>=</span> a <span>-</span> b</span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a>    dL <span>=</span> np.<span>sum</span>(np.<span>abs</span>(delta[..., <span>0</span>:<span>1</span>]), axis<span>=-</span><span>1</span>)</span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a>    dab <span>=</span> np.sqrt(np.<span>sum</span>(delta[..., <span>1</span>:<span>3</span>]<span>**</span><span>2</span>, axis<span>=-</span><span>1</span>))</span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a>    <span>return</span> dL <span>+</span> dab</span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a><span>def</span> L_weighted_hyab_distance(a, b):</span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a>    delta <span>=</span> a <span>-</span> b</span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a>    dL <span>=</span> np.<span>sum</span>(np.<span>abs</span>(delta[..., <span>0</span>:<span>1</span>]), axis<span>=-</span><span>1</span>)</span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a>    dab <span>=</span> np.sqrt(np.<span>sum</span>(delta[..., <span>1</span>:<span>3</span>]<span>**</span><span>2</span>, axis<span>=-</span><span>1</span>))</span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>3</span> <span>*</span> dL <span>+</span> dab</span>
<span id="cb2-67"><a href="#cb2-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-68"><a href="#cb2-68" aria-hidden="true" tabindex="-1"></a><span>def</span> L_15_weighted_hyab_distance(a, b):</span>
<span id="cb2-69"><a href="#cb2-69" aria-hidden="true" tabindex="-1"></a>    delta <span>=</span> a <span>-</span> b</span>
<span id="cb2-70"><a href="#cb2-70" aria-hidden="true" tabindex="-1"></a>    dL <span>=</span> np.<span>sum</span>(np.<span>abs</span>(delta[..., <span>0</span>:<span>1</span>]), axis<span>=-</span><span>1</span>)</span>
<span id="cb2-71"><a href="#cb2-71" aria-hidden="true" tabindex="-1"></a>    dab <span>=</span> np.sqrt(np.<span>sum</span>(delta[..., <span>1</span>:<span>3</span>]<span>**</span><span>2</span>, axis<span>=-</span><span>1</span>))</span>
<span id="cb2-72"><a href="#cb2-72" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>1.5</span> <span>*</span> dL <span>+</span> dab</span>
<span id="cb2-73"><a href="#cb2-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-74"><a href="#cb2-74" aria-hidden="true" tabindex="-1"></a><span>def</span> L_distance(a, b):</span>
<span id="cb2-75"><a href="#cb2-75" aria-hidden="true" tabindex="-1"></a>    delta <span>=</span> a <span>-</span> b</span>
<span id="cb2-76"><a href="#cb2-76" aria-hidden="true" tabindex="-1"></a>    dL <span>=</span> np.<span>sum</span>(delta[..., <span>0</span>:<span>1</span>]<span>**</span><span>2</span>, axis<span>=-</span><span>1</span>)</span>
<span id="cb2-77"><a href="#cb2-77" aria-hidden="true" tabindex="-1"></a>    <span>return</span> dL</span>
<span id="cb2-78"><a href="#cb2-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-79"><a href="#cb2-79" aria-hidden="true" tabindex="-1"></a><span>def</span> map_pixels_to_palette(img, palette, func<span>=</span>euclidean_distance):</span>
<span id="cb2-80"><a href="#cb2-80" aria-hidden="true" tabindex="-1"></a>    <span>&#34;&#34;&#34;</span></span>
<span id="cb2-81"><a href="#cb2-81" aria-hidden="true" tabindex="-1"></a><span>    Find the index of a palette color closest to each input image pixel color.</span></span>
<span id="cb2-82"><a href="#cb2-82" aria-hidden="true" tabindex="-1"></a><span>    &#34;&#34;&#34;</span></span>
<span id="cb2-83"><a href="#cb2-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-84"><a href="#cb2-84" aria-hidden="true" tabindex="-1"></a>    a <span>=</span> img.reshape(<span>-</span><span>1</span>, <span>1</span>, <span>3</span>)</span>
<span id="cb2-85"><a href="#cb2-85" aria-hidden="true" tabindex="-1"></a>    b <span>=</span> palette.reshape(<span>1</span>, <span>-</span><span>1</span>, <span>3</span>).astype(np.float32)</span>
<span id="cb2-86"><a href="#cb2-86" aria-hidden="true" tabindex="-1"></a>    dist <span>=</span> func(a, b)</span>
<span id="cb2-87"><a href="#cb2-87" aria-hidden="true" tabindex="-1"></a>    inds <span>=</span> np.argmin(dist, axis<span>=-</span><span>1</span>)</span>
<span id="cb2-88"><a href="#cb2-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-89"><a href="#cb2-89" aria-hidden="true" tabindex="-1"></a>    H, W, _ <span>=</span> img.shape</span>
<span id="cb2-90"><a href="#cb2-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-91"><a href="#cb2-91" aria-hidden="true" tabindex="-1"></a>    <span>return</span> inds.reshape(H, W)</span>
<span id="cb2-92"><a href="#cb2-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-93"><a href="#cb2-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-94"><a href="#cb2-94" aria-hidden="true" tabindex="-1"></a><span>&#34;&#34;&#34;</span></span>
<span id="cb2-95"><a href="#cb2-95" aria-hidden="true" tabindex="-1"></a><span># Usage example:</span></span>
<span id="cb2-96"><a href="#cb2-96" aria-hidden="true" tabindex="-1"></a><span>inds = map_pixels_to_palette(srgb_u8, palette_srgb_u8)</span></span>
<span id="cb2-97"><a href="#cb2-97" aria-hidden="true" tabindex="-1"></a><span>y = np.take(palette_srgb_u8, inds.reshape(-1), axis=0).reshape(H, W, 3)</span></span>
<span id="cb2-98"><a href="#cb2-98" aria-hidden="true" tabindex="-1"></a><span>&#34;&#34;&#34;</span></span></code></pre></div>
</details>



</div></div>
  </body>
</html>
