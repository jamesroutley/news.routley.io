<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.yossarian.net/2025/01/10/Be-aware-of-the-Makefile-effect">Original</a>
    <h1>Be Aware of the Makefile Effect</h1>
    
    <div id="readability-page-1" class="page">


<h2><em>Programming, philosophy, pedaling.</em></h2>

<ul>
    <li><a href="https://blog.yossarian.net/">Home</a></li>
    <li><a href="https://blog.yossarian.net/tags">Tags</a></li>
    <li><a href="https://blog.yossarian.net/series">Series</a></li>
    <li><a href="https://blog.yossarian.net/favorites">Favorites</a></li>
    <li><a href="https://blog.yossarian.net/archive">Archive</a></li>
    
    <li><a href="https://yossarian.net">Main Site</a></li>
    <li><a href="https://yossarian.net/til">TILs</a></li>
    
</ul>

<hr/>



<h2>
  <p>
    <span><em>Jan 10, 2025</em></span>

       

    
      <span>
        Tags:
        
        
          <a href="https://blog.yossarian.net/tags#programming">programming</a>
        
      </span>
    

       

    
  </p>
</h2>






<hr/>


<p>I’m not aware of a <em>perfect</em><sup id="fnref:perfect" role="doc-noteref"><a href="#fn:perfect" rel="footnote">1</a></sup> term for this, so I’m making one up:
the Makefile effect<sup id="fnref:aware" role="doc-noteref"><a href="#fn:aware" rel="footnote">2</a></sup>.</p>

<p>The Makefile effect boils down to this:</p>

<blockquote>
  <p>Tools of a certain complexity or routine unfamiliarity are not run <em>de novo</em>,
but are instead copy-pasted and tweaked from previous known-good examples.</p>
</blockquote>

<p>You see this effect frequently with engineers of all stripes and skill/experience
levels, with <a href="https://en.wikipedia.org/wiki/Make_(software)">Make</a> being a common example<sup id="fnref:example" role="doc-noteref"><a href="#fn:example" rel="footnote">3</a></sup>:</p>

<ol>
  <li>A task (one of a common shape) needs completing. A very similar (or even
identical) task has been done before.</li>
  <li><a href="https://en.wikipedia.org/wiki/Make_(software)">Make</a> (or another tool susceptible to this effect) is the correct or
“best” (given expedience, path dependencies, whatever) tool for the task.</li>
  <li>Instead of writing a <code>Makefile</code>, the engineer copies a previous (sometimes
very large and complicated<sup id="fnref:large" role="doc-noteref"><a href="#fn:large" rel="footnote">4</a></sup>) <code>Makefile</code> from a previous instance of the task
and tweaks it until it works in the new context.</li>
</ol>

<p>On one level, this is a perfectly good (even ideal) <em>engineering</em> response
at the <em>point of solution</em>: applying a working example is often the parsimonious
thing to do, and runs a lesser (in theory) risk of introducing bugs, since
most of the work is unchanged.</p>

<p>However, at the <em>point of design</em>, this suggests a tool design (or tool <em>application</em><sup id="fnref:application" role="doc-noteref"><a href="#fn:application" rel="footnote">5</a></sup>)
that is <em>flawed</em>: the tool (or system) is too complicated (or annoying) to use from scratch. Instead
of using it to solve a problem from scratch, users repeatedly copy a known-good solution
and accrete changes over time.</p>

<p>Once you notice it, you start to see this pattern all over the place.
Beyond Make:</p>

<ul>
  <li>CI/CD configurations like GitHub Actions and GitLab CI/CD, where users
copy their YAML spaghetti from the <em>last</em> working setup and tweak it
(often with repeated re-runs) until it works again;</li>
  <li>Linter and formatter configurations, where a basic set of rules gets
copied between projects and strengthened/loosened as needed for local
conditions;</li>
  <li>Build systems themselves, where everything non-trivial begins to resemble
the previous build system.</li>
</ul>

<h2 id="does-this-matter">Does this matter?</h2>

<p>In many cases, perhaps not. However, I think it’s worth thinking about, especially
when designing tools and systems:</p>

<ul>
  <li>
    <p>Tools and systems that enable this pattern often have less-than-ideal
diagnostics or debugging support: the user has to run the tool repeatedly,
often with long delays, to get back relatively small amounts of information.
Think about CI/CD setups, where users diagnose their copy-pasted
CI/CD by doing print-style debugging <em>over the network with a layer
of intermediating VM orchestration.</em> Ridiculous!</p>
  </li>
  <li>
    <p>Tools that enable this pattern often <em>discourage broad learning</em>:
a few mavens know the tool well enough to configure it, and others
copy it with <em>just</em> enough knowledge to do targeted tweaks.
This is sometimes inevitable, but often not: dependency graphs
are an inherent complexity of build systems, but remembering the difference
between <code>$&lt;</code> and <code>$^</code> in Make is not.</p>
  </li>
  <li>
    <p>Tools that enable this pattern are <em>harder to use securely</em>: security
actions typically require deep knowledge of the <em>why</em> behind a piece of
behavior. Systems that are subject to the Makefile effect are also often ones
that enable confusion between code and data (or any kind of
<a href="https://en.wikipedia.org/wiki/In-band_signaling">in-band signalling</a> more generally), in large part because functional
solutions are not always secure ones. Consider, for example, about
<a href="https://woodruffw.github.io/zizmor/audits/#template-injection">template injection</a> in GitHub Actions.</p>
  </li>
</ul>

<p>In general, I think well-designed tools (and systems) should aim to minimize
this effect. This can be hard to do in a fully general manner, but some
things I think about when designing a new tool:</p>

<ul>
  <li>Does it <em>need</em> to be configurable?</li>
  <li>Does it <em>need</em> syntax of its own?
    <ul>
      <li>As a corollary: can it <em>reuse</em> familiar syntax or idioms from other tools/CLIs?</li>
    </ul>
  </li>
  <li>Do <em>I</em> end up copy-pasting my use of it around? If so, are <em>others</em> likely to do the same?</li>
</ul>

<hr/>




<hr/>




  






</div>
  </body>
</html>
