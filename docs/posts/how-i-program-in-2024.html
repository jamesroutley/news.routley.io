<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://akkartik.name/post/programming-2024">Original</a>
    <h1>How I Program in 2024</h1>
    
    <div id="readability-page-1" class="page"><div>
  <p>Jul 31, 2024</p>
<p><b>How I program in 2024</b></p><p>
I talk a lot here about <a href="https://akkartik.name/freewheeling">using computers freely</a>, how to select programs to use, how to decide if a program is trustworthy infrastructure one can safely depend on in the long term. I also spend my time building such infrastructure, because there isn&#39;t a lot of it out there. As I do so, I&#39;m always acutely aware that <em>I&#39;m just not very good at it.</em> At best I can claim I try to compensate for limited means with good, transparent intentions.

</p><p>
I just spent <a href="https://akkartik.name/post/2024-06-05-devlog">a month</a> of my free time, off and on, <a href="https://akkartik.name/post/2024-07-22-devlog">rewriting the core</a> of a program I&#39;ve been using and incrementally modifying for 2 years. I&#39;ve been becalmed since. Partly this is the regular cadence of my subconscious reflecting on what just happened, what I learned from it, taking some time to decide where to go next. But I&#39;m also growing aware this time of a broader arc in my life:

<!-- more -->

</p><ul>

<li> Back in 2015 I was suspicious of abstractions and big on tests and version control. Code seemed awash in bad abstractions, while tests and versions seemed like the key advances of the 2000s. I thought our troubles stemmed from bad incentives, using abstractions too much, and not using tests and versions enough. <a href="https://github.com/akkartik/mu1">Mu1</a> was an attempt at designing a platform with tests and <a href="https://akkartik.name/post/wart-layers">layers</a> (more like versions, less like abstractions) as foundational constraints influencing everything else.

</li><li> In 2017 I started reworking Mu1 into the current <a href="https://github.com/akkartik/mu">Mu</a>. <a href="https://github.com/akkartik/mu/tree/main/linux/bootstrap#readme">At the start</a> I used all my new ideas for tests and layers. But over time I stopped using them. Mu today has tons of tests, but they are conventional tests, and I never got around to porting over my infrastructure for layers.

</li><li> In 2022 I started working on <a href="https://akkartik.name/freewheeling-apps">Freewheeling Apps</a>. I started out with no tests, got frustrated at some point and wrote thorough tests for a core piece, the text editor. But I struggled to find ways to test the rest, and also found I was getting by fine anyway.

</li><li> Now it&#39;s 2024, and a month ago I deleted all my tests. I also started radically reworking my text editor, in a way that would have made me worried about merge conflicts with other Freewheeling Apps. In effect I stopped thinking about version control. Giving up tests and versions, I ended up with a much better program. The cognitive dissonance is now impossible to ignore.

</li></ul>

<p>
After mulling it over for a few days, I think my current synthesis on <a href="https://akkartik.name/freewheeling">programming durable things</a> is:

</p><ol>

<li> Building durably for lots of people is too hard, just don&#39;t even try. Be ruled by what you know well, who you know well and <a href="https://en.wikipedia.org/wiki/Dunbar%27s_number">Dunbar&#39;s number</a>.
</li><li> Most software out there is incurably infected by incentives to serve lots of people in the short term. Focus as far as possible on software without lots of logos on the website, stuff that is easy to build, has few dependencies, definitely doesn&#39;t auto-update. Once you filter by these restrictions, the amount of durable software humanity has created so far is tiny.
</li><li> Small changes in context (people/places/features you want to support) often radically change how well a program fits its context. Our dominant milieu of short-termism doesn&#39;t prepare us for this fact.
</li><li> Given this tiny body of past work and low coverage per program, any new program you decide to build is quite likely striking out into the unknown in some way or other. You often won&#39;t know <em>quite</em> what you&#39;re doing in some direction or other. (In my example above, I was trying to insert special &#34;drawing lines&#34; in a text editor. Questions that raised: can the cursor lie on a drawing? Can I try to draw in one line while the cursor is on another? Drawings are taller than text lines. Can a drawing be partially visible at top of screen? Can I draw on a partially visible drawing? My answers to these questions were sub-optimal for a long time, leading to hacks piled on hacks.)
</li><li> Types, abstractions, tests, versions, state machines, immutability, formal analysis, all these are tools available to us in unfamiliar terrain. Use them to taste.
</li><li> You&#39;ll inevitably end up over-using some of these tools, the ones you gravitate towards. The ideal quantity to use these tools is tiny, much more miniscule than any of us is trained to think by our dominant milieu of short-termism. The excess is <em>tech debt.</em> It keeps us from noticing that a program is unnecessarily complex, less durable than it could be, harder to change when the context shifts.
</li><li> When your understanding of the context stabilizes, there&#39;s value in throwing away vast swathes of a program, and redoing it from scratch.
</li><li> Before you set out to rewrite, you have to spend some time importing everything into your brain at once. Everything you want from the program, all the scenarios the program has to cater to. This is hard. The goal is to get to a point where you can build everything all at once.
</li><li> Build everything all at once.

</li></ol>

<p>
In my case, tests and versions actively hindered getting to the end of this evolution. Tests let me forget concerns. Version control kept me attached to the past. Both were counter-productive. It took a major reorientation to let go of them.

</p><p>
All the software I&#39;ve written in my life — and all my Freewheeling Apps so far — are at level 6 in this trajectory. Only <a href="https://akkartik.name/post/2024-07-22-devlog">the output of the past month</a> feels like it might have gotten to level 9. We&#39;ll see.

</p><p>
It seems likely that a program can grow so complex it becomes impossible to import into memory in level 8. That seems to describe most software so far, certainly most software written by more than a couple of people. Even my text editor, small as it is, was daunting enough I spent much of the month girding myself to face the terror.

</p><p>
Not all software necessarily <em>needs</em> to get to level 9. I think many of my Freewheeling Apps are simple enough and evolve slowly enough that they would stabilize to a bug-free state with just a handful of people using them, regardless of my initial design choices. Particularly now that I know how to streamline one complex piece at their core. Still, it&#39;s good to be aware of how things <em>might</em> be improved, if it becomes worthwhile.

</p><p>
One thing that feels definitely useful in getting to level 9 is <a href="https://www.youtube.com/watch?v=rX0ItVEVjHc">data-oriented design</a>. It&#39;s not a tool you can blindly apply but a way of thinking you have to grow into, to look past immediate data structure choices at the big picture of how your program accesses data. Just don&#39;t let tools like <a href="https://en.wikipedia.org/wiki/Entity_component_system">ECS</a> blind you to the essential intellectual activity.

</p><p>
These levels are probably not quite right. I&#39;m probably under-estimating tools I have less experience with.

</p><p>
I wonder what levels lie beyond these.

</p><p>
(I last wrote some thoughts on how I program <a href="https://akkartik.name/post/four-repos">back in 2019</a>. It&#39;s nice to see signs of evolution.)


  </p><p>
  <em>Comments gratefully appreciated. Please send them to me
  <a href="http://akkartik.name/contact">by any method of your choice</a> and I&#39;ll include them
  here.</em>
</p></div></div>
  </body>
</html>
