<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://parsiya.net/blog/2021-12-20-rce-in-visual-studio-codes-remote-wsl-for-fun-and-negative-profit/">Original</a>
    <h1>RCE in Visual Studio Code&#39;s Remote WSL for Fun and Negative Profit</h1>
    
    <div id="readability-page-1" class="page"><div>
<nav id="TableOfContents">
<ul>
<li><a href="#summary">Summary</a></li>
<li><a href="#what-are-we-gonna-learn-here-today">What Are We Gonna Learn Here Today?</a></li>
<li><a href="#pre-requisites">Pre-Requisites</a>
<ul>
<li><a href="#note-about-source-code">Note About Source Code</a></li>
</ul>
</li>
<li><a href="#intro">Intro</a>
<ul>
<li><a href="#chasing-the-firewall-dialog">Chasing the Firewall Dialog</a></li>
<li><a href="#why-is-it-listening-on-all-interfaces">Why is it Listening on All Interfaces?</a></li>
<li><a href="#the-local-websocket-server">The Local WebSocket Server</a>
<ul>
<li><a href="#but-the-same-origin-policy">But the Same-Origin Policy!</a></li>
<li><a href="#testing-local-websocket-servers">Testing Local WebSocket Servers</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#reverse-engineering-the-protocol">Reverse Engineering the Protocol</a>
<ul>
<li><a href="#help-from-the-future">Help From the Future</a></li>
<li><a href="#the-protocol-handshake">The Protocol Handshake</a>
<ul>
<li><a href="#your-editor-has-drm">Your Editor has DRM</a></li>
<li><a href="#light-drm-reversing">Light DRM Reversing</a></li>
<li><a href="#the-finishing-move">The Finishing Move</a></li>
<li><a href="#what-else-can-we-do">What Else Can We Do?</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#exploitation">Exploitation</a>
<ul>
<li><a href="#the-node-inspector-instance">The Node Inspector Instance</a>
<ul>
<li><a href="#what-is-node-inspector">What is Node Inspector?</a></li>
</ul>
</li>
<li><a href="#emulate-the-code-client">Emulate the Code Client</a></li>
</ul>
</li>
<li><a href="#recap">Recap</a>
<ul>
<li><a href="#limitations">Limitations</a></li>
<li><a href="#so-how-do-we-fix-this">So How Do We Fix This?</a></li>
<li><a href="#what-was-actually-fixed">What Was Actually Fixed?</a></li>
<li><a href="#remediation-timeline">Remediation Timeline</a></li>
</ul>
</li>
<li><a href="#what-i-tried-and-didnt-work">What I Tried and Didn&#39;t Work</a>
<ul>
<li><a href="#injecting-environment-variables">Injecting Environment Variables</a></li>
<li><a href="#command-injection">Command Injection</a></li>
<li><a href="#the-local-web-server">The Local Web Server</a></li>
<li><a href="#the-vscode-protocol-handler">The vscode Protocol Handler</a></li>
</ul>
</li>
</ul>
</nav>
<p>The Visual Studio Code server in Windows Subsystem for Linux uses a local
WebSocket WebSocket connection to communicate with the <code>Remote WSL</code> extension.
JavaScript in websites can connect to this server and execute arbitrary commands
on the target system. Assigned <a href="https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2021-43907" target="_blank" rel="noreferrer noopener">CVE-2021-43907</a> and -5 USD bounty (the cost
of the EC2 machine to host the proof-of-concept).</p>
<p>It&#39;s really funny that PlayStation paid 15K USD for <a href="https://hackerone.com/reports/873614" target="_blank" rel="noreferrer noopener">almost the same
bug</a> with 2.2 million subscribers (it was out of scope in their
program, too), but MSFT doesn&#39;t pay for an official extension with more than 10
million installs (obviously, not every install is unique) for one of their most
popular products. But you are not here to listen to my rants. So, read on.</p>
<p>These bugs can be chained:</p>
<ol>
<li>The local WebSocket server is listening on all interfaces. If allowed through
the Windows firewall, outside applications may connect to this server.</li>
<li>The local WebSocket server does not check the <code>Origin</code> header in the
WebSocket handshakes or have any mode of authentication. The JavaScript in
the browser can connect to this server. This is true even if the server is
listening on localhost.</li>
<li>We can spawn a Node inspector instance on a specific
port. It&#39;s also listening on all interfaces. External applications can
connect to it.</li>
<li>If an outside app or a local website can connect to either of these servers,
they can run arbitrary code on the target machine.</li>
</ol>
<p>Here&#39;s a funky proof-of-concept.</p>
<p><span>
<img src="https://parsiya.net/blog/2021-12-20-rce-in-visual-studio-codes-remote-wsl-for-fun-and-negative-profit/09-poc1.gif" title="Popping calc from a website" alt="Popping calc from a website"/>
<span>Popping calc from a website</span>
</span></p><p>See the <a href="#limitations" title="Limitations">Limitations</a>
section for assumptions in this proof of concept.</p>
<p>This helps you decide if you want to spend time reading this blog or just stop
after the summary.</p>
<ol>
<li>Yet another open local WebSocket server.</li>
<li>What VS Code Server is.
<ol>
<li>How <code>Remote WSL</code> works.</li>
</ol>
</li>
<li>The difference between Visual Studio Code and <code>Code - OSS</code>.
<ol>
<li>VS Code DRM.</li>
</ol>
</li>
<li>Reverse Engineering a custom binary protocol with source code access.
<ol>
<li>Navigating a TypeScript code base with Visual Studio Code.</li>
</ol>
</li>
<li>Exploiting exposed Node Inspector instances.</li>
<li>Exploiting Node processes by injecting environment variables.</li>
<li>The <code>vscode</code> protocol handler.</li>
<li><a href="http://web.archive.org/web/20110324044023/http://trailofbits.com/2009/03/22/no-more-free-bugs/" target="_blank" rel="noreferrer noopener">No More Free Bugs</a><sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>.</li>
</ol>
<p>The blog assumes you</p>
<ol>
<li>can read some JavaScript and TypeScript.</li>
<li>are familiar with concepts like Same-Origin Policy (SOP), WebSockets and have
some knowledge about the browser security model.</li>
<li>are somewhat familiar with the <a href="https://docs.microsoft.com/en-us/windows/wsl/about" target="_blank" rel="noreferrer noopener">Windows Subsystem for Linux or WSL</a>.</li>
</ol>
<h2 id="note-about-source-code">Note About Source Code
<a href="#note-about-source-code"><svg height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a>
</h2><p>The Visual Studio Code repository is constantly updated. I will use a specific commit
(<code>b3318bc0524af3d74034b8bb8a64df0ccf35549a</code>).</p>
<p>To follow along:</p>
<pre tabindex="0"><code>$ git clone https://github.com/microsoft/vscode
$ git reset --hard b3318bc0524af3d74034b8bb8a64df0ccf35549a
</code></pre><p>We can use Code (lol) to navigate the source code. In fact, I created the
proof-of-concept for this vulnerability in WSL with the same extension.</p>
<p>We won&#39;t look at the extension code in this blog. The extension is not open
source, but you can extract the <code>vsix</code> file and access the minified and
transpiled JavaScript code.</p>
<p>The <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-wsl" target="_blank" rel="noreferrer noopener">Remote WSL</a> extension is magic. You can use it to
develop in &#34;Linux&#34; (WSL) from Windows without using a Virtual Machine. At the
time of writing it has been installed 10.5 million times.</p>
<p>Visual Studio Code (<code>Code</code> moving forward) runs in server mode inside WSL and
talks to a Code instance on Windows (I am calling it the <code>Code client</code>). This
allows us to edit files and run applications in WSL without running everything
there.</p>
<p><span>
<img src="https://parsiya.net/blog/2021-12-20-rce-in-visual-studio-codes-remote-wsl-for-fun-and-negative-profit/00-architecture.png" title="Remote Development Architecture - Credit: https://code.visualstudio.com/docs/remote/faq " alt="Remote Development Architecture - Credit: https://code.visualstudio.com/docs/remote/faq "/>
<span>Remote Development Architecture - Credit: https://code.visualstudio.com/docs/remote/faq </span>
</span></p><p>It&#39;s possible to do remote development on remote machines via <a href="https://code.visualstudio.com/docs/remote/ssh" target="_blank" rel="noreferrer noopener">SSH</a>
and in <a href="https://code.visualstudio.com/docs/remote/containers" target="_blank" rel="noreferrer noopener">containers</a>. <a href="https://docs.github.com/en/codespaces" target="_blank" rel="noreferrer noopener">GitHub Codespaces</a> uses the
same technology (most likely via containers).</p>
<p>How to use it on Windows:</p>
<ol>
<li>Open a WSL terminal instance. You should have the <code>Remote WSL</code> extension in
Code on Windows.</li>
<li>Run <code>code /path/to/something</code> in WSL.</li>
<li>If the Code server is not installed (or is outdated) it&#39;s downloaded.</li>
<li>VS Code on Windows runs.</li>
<li>You might get a Windows Firewall popup for an executable like this:</li>
</ol>
<pre tabindex="0"><code>C:\users\parsia\appdata\local\packages\
canonicalgrouplimited.ubuntu18.04onwindows_79rhkp1fndgsc\
localstate\rootfs\home\parsia\.vscode-server\bin\b3318bc0524af3d74034b8bb8a64df0ccf35549a\node
</code></pre>
<p><span>
<img src="https://parsiya.net/blog/2021-12-20-rce-in-visual-studio-codes-remote-wsl-for-fun-and-negative-profit/01-server-firewall-dialog.png" title="Server&#39;s firewall dialog" alt="Server&#39;s firewall dialog"/>
<span>Server&#39;s firewall dialog</span>
</span></p><p>See how it works:
<a href="https://code.visualstudio.com/docs/remote/faq#_how-do-the-remote-development-extensions-work" target="_blank" rel="noreferrer noopener">https://code.visualstudio.com/docs/remote/faq#_how-do-the-remote-development-extensions-work</a>.</p>
<h2 id="chasing-the-firewall-dialog">Chasing the Firewall Dialog
<a href="#chasing-the-firewall-dialog"><svg height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a>
</h2><p>This firewall dialog was the reason why I went down the rabbit hole. The
dialog appears because VS Code server wants to listen on all interfaces (bound do <code>0.0.0.0</code>).</p>
<p>I started with my trusty Process Monitor:</p>
<ol>
<li>Ran process monitor.</li>
<li>Ran <code>code .</code> in WSL.</li>
<li><code>Tools &gt; Process Tree</code>.</li>
<li><code>Add process and children to Include filter</code> under the terminal instance where I
ran code (e.g., <code>Windows Terminal.exe</code>).</li>
</ol>
<p><span>
<img src="https://parsiya.net/blog/2021-12-20-rce-in-visual-studio-codes-remote-wsl-for-fun-and-negative-profit/02-procmon-tree.png" title="Procmon&#39;s process tree" alt="Procmon&#39;s process tree"/>
<span>Procmon&#39;s process tree</span>
</span></p><p>This gave me some info, but not a lot. After some digging, I found out about the
<code>VSCODE_WSL_DEBUG_INFO</code> environment variable. I simply added
<code>export VSCODE_WSL_DEBUG_INFO=true</code> to <code>~/.profile</code> in WSL. We get extra info
after running the server.</p>
<p><span>
<img src="https://parsiya.net/blog/2021-12-20-rce-in-visual-studio-codes-remote-wsl-for-fun-and-negative-profit/03-vscode-debug.png" title="VSCODE_WSL_DEBUG_INFO=true" alt="VSCODE_WSL_DEBUG_INFO=true"/>
<span>VSCODE_WSL_DEBUG_INFO=true</span>
</span></p><p>The output is cleaned up and the comments are mine.</p>
<div><pre tabindex="0"><code data-lang="bash">$ code
+ <span>IN_WSL</span><span>=</span><span>true</span>
<span># Converts a WSL path to its Windows equivalent</span>
<span># Note: This is not pure text processing, if the path does not exist we will get an error</span>
+ wslpath -m /mnt/c/Program Files/Microsoft VS Code/resources/app/out/cli.js
+ <span>CLI</span><span>=</span>C:/Program Files/Microsoft VS Code/resources/app/out/cli.js
<span># Extension ID</span>
+ <span>WSL_EXT_ID</span><span>=</span>ms-vscode-remote.remote-wsl
<span># Run code</span>
+ <span>ELECTRON_RUN_AS_NODE</span><span>=</span><span>1</span> /mnt/c/Program Files/Microsoft VS Code/Code.exe
   C:/Program Files/Microsoft VS Code/resources/app/out/cli.js --locate-extension ms-vscode-remote.remote-wsl
<span># Run wslCode</span>
+ /mnt/c/Users/Parsia/.vscode/extensions/ms-vscode-remote.remote-wsl-0.58.5/scripts/wslCode.sh
   b3318bc0524af3d74034b8bb8a64df0ccf35549a stable /mnt/c/Program Files/Microsoft VS Code/Code.exe code .vscode
<span># Check for updates</span>
+ /mnt/c/Users/Parsia/.vscode/extensions/ms-vscode-remote.remote-wsl-0.58.5/scripts/wslDownload.sh
   b3318bc0524af3d74034b8bb8a64df0ccf35549a stable /home/parsia/.vscode-server/bin
<span># Run the server</span>
+ <span>VSCODE_CLIENT_COMMAND</span><span>=</span>/mnt/c/Program Files/Microsoft VS Code/Code.exe
   <span>VSCODE_CLIENT_COMMAND_CWD</span><span>=</span>/mnt/c/Users/Parsia/.vscode/extensions/ms-vscode-remote.remote-wsl-0.58.5/scripts
   <span>VSCODE_CLI_AUTHORITY</span><span>=</span>wsl+Ubuntu-18.04 <span>VSCODE_CLI_REMOTE_ENV</span><span>=</span>/tmp/vscode-distro-env.v7syDw
   <span>VSCODE_STDIN_FILE_PATH</span><span>=</span> <span>VSCODE_AGENT_FOLDER</span><span>=</span>/home/parsia/.vscode-server
   <span>WSLENV</span><span>=</span>VSCODE_CLI_REMOTE_ENV/w:ELECTRON_RUN_AS_NODE/w:WT_SESSION::WT_PROFILE_ID
   /home/parsia/.vscode-server/bin/b3318bc0524af3d74034b8bb8a64df0ccf35549a/bin/code
+ <span>exit</span> <span>0</span>
</code></pre></div><p>Checking the command-line parameters.</p>
<pre tabindex="0"><code># cleaned up
$ ps -aux | more

sh /home/parsia/.vscode-server/bin/b3318bc0524af3d74034b8bb8a64df0ccf35549a/server.sh
   --port=0 --use-host-proxy --without-browser-env-var --disable-websocket-compression
   --print-ip-address --enable-remote-auto-shutdown --disable-telemetry

/home/parsia/.vscode-server/bin/b3318bc0524af3d74034b8bb8a64df0ccf35549a/node
   /home/parsia/.vscode-server/bin/b3318bc0524af3d74034b8bb8a64df0ccf35549a/out/vs/server/main.js
   --port=0 --use-host-proxy --without-browser-env-var --disable-websocket-compression
   --print-ip-address --enable-remote-auto-shutdown --disable-telemetry
</code></pre><p>I saw the magic word <code>WebSocket</code> and was suddenly interested.</p>
<p>Ran Wireshark and captured the traffic on the loopback interface. Then I ran
Code in WSL again. I could see two WebSocket handshakes.</p>
<p><span>
<img src="https://parsiya.net/blog/2021-12-20-rce-in-visual-studio-codes-remote-wsl-for-fun-and-negative-profit/05-websocket-wireshark.png" title="WebSocket connections captured in Wireshark" alt="WebSocket connections captured in Wireshark"/>
<span>WebSocket connections captured in Wireshark</span>
</span></p><p>The server port in that run was <code>63574</code>. We can also see this in the logs. Open
the command palette (<code>ctrl+shift+p</code>) in the Code client on Windows and run
<code>&gt; Remote-WSL: Show Log</code>.</p>
<p><span>
<img src="https://parsiya.net/blog/2021-12-20-rce-in-visual-studio-codes-remote-wsl-for-fun-and-negative-profit/06-remote-wsl-log.png" title="Remote-WSL: Show Log" alt="Remote-WSL: Show Log"/>
<span>Remote-WSL: Show Log</span>
</span></p><p>The last line has the port: <code>open a local browser on http://127.0.0.1:63574/version</code>.
We can also see the two separate WebSocket connections from the Code client on
Windows to the server.</p>
<pre tabindex="0"><code>C:\&gt; netstat -an | findstr &#34;63574&#34;
  TCP    0.0.0.0:63574          0.0.0.0:0              LISTENING
  TCP    127.0.0.1:49782        127.0.0.1:63574        ESTABLISHED
  TCP    127.0.0.1:63574        127.0.0.1:49782        ESTABLISHED
  TCP    127.0.0.1:63574        127.0.0.1:64725        ESTABLISHED
  TCP    127.0.0.1:64725        127.0.0.1:63574        ESTABLISHED
  TCP    [::]:63574             [::]:0                 LISTENING
</code></pre>
<h2 id="why-is-it-listening-on-all-interfaces">Why is it Listening on All Interfaces?
<a href="#why-is-it-listening-on-all-interfaces"><svg height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a>
</h2><p>The server is an instance of <code>RemoteExtensionHostAgentServer</code> at
<a href="https://github.com/microsoft/vscode/blob/b3318bc0524af3d74034b8bb8a64df0ccf35549a/src/vs/server/remoteExtensionHostAgentServer.ts#L207" target="_blank" rel="noreferrer noopener">/src/vs/server/remoteExtensionHostAgentServer.ts#L207</a>.</p>
<p>It&#39;s used by <code>createServer</code> (in the same file). We can use Code (lol) to find
its references and trace it to <a href="https://github.com/microsoft/vscode/blob/b3318bc0524af3d74034b8bb8a64df0ccf35549a/src/vs/server/remoteExtensionHostAgent.ts#L62" target="_blank" rel="noreferrer noopener">remoteExtensionHostAgent.ts</a> (same
directory).</p>
<div><pre tabindex="0"><code data-lang="ts"><span>// /src/vs/server/remoteExtensionHostAgent.ts
</span><span></span><span>import</span> { createServer <span>as</span> doCreateServer, IServerAPI }
   <span>from</span> <span>&#39;vs/server/remoteExtensionHostAgentServer&#39;</span>;

<span>// ...
</span><span></span>
<span>/**
</span><span> * invoked by vs/server/main.js
</span><span> */</span>
<span>export</span> <span>function</span> createServer(address: <span>string</span> <span>|</span> net.AddressInfo <span>|</span> <span>null</span>)<span>:</span> Promise&lt;<span>IServerAPI</span>&gt; {
   <span>return</span> doCreateServer(address, args, REMOTE_DATA_FOLDER);
}
</code></pre></div><p>The comment tells us to look inside <a href="https://github.com/microsoft/vscode/blob/b3318bc0524af3d74034b8bb8a64df0ccf35549a/src/vs/server/main.js#L66" target="_blank" rel="noreferrer noopener">main.js</a> (same path, again).</p>
<div><pre tabindex="0"><code data-lang="ts"><span>// /src/vs/server/main.js
</span><span></span><span>/** @type {string | import(&#39;net&#39;).AddressInfo | null} */</span>
<span>let</span> address <span>=</span> <span>null</span>;
<span>const</span> server <span>=</span> http.createServer(<span>async</span> (req, res) <span>=&gt;</span> {  <span>// [Parsia]: &lt;--- SEE
</span><span></span>    <span>if</span> (firstRequest) {
        firstRequest <span>=</span> <span>false</span>;
        perf.mark(<span>&#39;code/server/firstRequest&#39;</span>);
    }
    <span>const</span> remoteExtensionHostAgentServer <span>=</span> <span>await</span> getRemoteExtensionHostAgentServer();
    <span>return</span> remoteExtensionHostAgentServer.handleRequest(req, res);
});
</code></pre></div><p>Further down in the same file, we see the server can get the <code>host</code> and <code>port</code>
from parameters passed to <code>main.js</code>.</p>
<div><pre tabindex="0"><code data-lang="ts"><span>// /src/vs/server/main.js
</span><span>// ...
</span><span></span>
<span>const</span> nodeListenOptions <span>=</span> (
    parsedArgs[<span>&#39;socket-path&#39;</span>]
        <span>?</span> { path: <span>parsedArgs</span>[<span>&#39;socket-path&#39;</span>] }
         <span>// [Parsia]: Get `host` and `port` from command-line parameters.
</span><span></span>        <span>:</span> { host: <span>parsedArgs</span>[<span>&#39;host&#39;</span>], port: <span>parsePort</span>(parsedArgs[<span>&#39;port&#39;</span>]) }
);

<span>// [Parsia]: Pass nodeListenOptions to the server.
</span><span></span>server.listen(nodeListenOptions, <span>async</span> () <span>=&gt;</span> {
    <span>const</span> serverGreeting <span>=</span> product.serverGreeting.join(<span>&#39;\n&#39;</span>);
    <span>let</span> output <span>=</span> serverGreeting <span>?</span> <span>`</span>\<span>n</span>\<span>n</span><span>${</span>serverGreeting<span>}</span>\<span>n</span>\<span>n`</span> <span>:</span> <span>``</span>;

    <span>if</span> (<span>typeof</span> nodeListenOptions.port <span>===</span> <span>&#39;number&#39;</span> <span>&amp;&amp;</span> parsedArgs[<span>&#39;print-ip-address&#39;</span>]) {
        <span>const</span> ifaces <span>=</span> os.networkInterfaces();
        <span>Object</span>.keys(ifaces).forEach(<span>function</span> (ifname) {
            ifaces[ifname].forEach(<span>function</span> (iface) {
                <span>if</span> (<span>!</span>iface.internal <span>&amp;&amp;</span> iface.family <span>===</span> <span>&#39;IPv4&#39;</span>) {
                    output <span>+=</span> <span>`IP Address: </span><span>${</span>iface.address<span>}</span>\<span>n`</span>;
                }
            });
        });
    }
    <span>// ...
</span></code></pre></div><p><code>main.js</code> is invoked by <code>server.sh</code>:</p>
<pre tabindex="0"><code>sh /home/parsia/.vscode-server/bin/b3318bc0524af3d74034b8bb8a64df0ccf35549a/server.sh
   --port=0 --use-host-proxy --without-browser-env-var --disable-websocket-compression
   --print-ip-address --enable-remote-auto-shutdown --disable-telemetry

/home/parsia/.vscode-server/bin/b3318bc0524af3d74034b8bb8a64df0ccf35549a/node
   /home/parsia/.vscode-server/bin/b3318bc0524af3d74034b8bb8a64df0ccf35549a/out/vs/server/main.js
   --port=0 --use-host-proxy --without-browser-env-var --disable-websocket-compression
   --print-ip-address --enable-remote-auto-shutdown --disable-telemetry
</code></pre><p>There is no IP address passed to the scripts which I think is why the server
listening on all interesting. <code>port=0</code> probably tells the server to use an
ephemeral port. if you are curious, this info comes from <code>wslServer.sh</code> in the
same directory.</p>
<h2 id="the-local-websocket-server">The Local WebSocket Server
<a href="#the-local-websocket-server"><svg height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a>
</h2><p>Every time you see a local WebSocket server, you should check <strong>WHO</strong> can
connect to it.</p>
<blockquote>
<p>WebSocket connections are not bound by the Same-Origin Policy and JavaScript
in the browser can connect to local servers.</p>

</blockquote>
<p>WebSockets start with a handshake. It is always a &#34;<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests" target="_blank" rel="noreferrer noopener">simple</a>&#34; (in
the context of Cross-Origin Resource Sharing or CORS) GET request so the browser
sends it without a preflight request.</p>
<h3 id="but-the-same-origin-policy">But the Same-Origin Policy!
<a href="#but-the-same-origin-policy"><svg height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a>
</h3><p>&#34;But the request cannot see the response without the
<code>Access-Control-Allow-Origin</code> header.&#34; YES! Your JavaScript is not sending the
GET handshake request. The browser does and can see the response.
<code>HTTP/1.1 101 Switching Protocols</code> in the response tells the browser to continue.</p>
<p>I have learned most of what I know in this niche from Tavis and Eric and you
should, too.</p>
<ul>
<li>[Tavis Ormandy] has found <a href="https://bugs.chromium.org/p/project-zero/issues/list?q=owner%3Ataviso%40google.com%20localhost&amp;can=1" target="_blank" rel="noreferrer noopener">many similar bugs</a>.</li>
<li><a href="https://twitter.com/ericlaw" target="_blank" rel="noreferrer noopener">Eric Lawrence</a> has a great overview of browser to desktop communications.
<ul>
<li><a href="https://textslashplain.com/2019/08/28/browser-architecture-web-to-app-communication-overview/" target="_blank" rel="noreferrer noopener">Browser Architecture: Web-to-App Communication Overview</a></li>
</ul>
</li>
</ul>
<p>But wait, there&#39;s more! Yours truly has also created content!</p>
<ul>
<li><a href="https://hackerone.com/reports/873614" target="_blank" rel="noreferrer noopener">Websites Can Run Arbitrary Code on Machines Running the &#39;PlayStation Now&#39; Application</a>
<ul>
<li>Similar bug in <code>PlayStation Now</code>.</li>
</ul>
</li>
<li>
<a href="https://parsiya.net/blog/2020-08-13-localghost-escaping-the-browser-sandbox-without-0-days/" title="localghost: Escaping the Browser Sandbox Without 0-Days" rel="nofollow" target="_blank">localghost: Escaping the Browser Sandbox Without 0-Days</a>
<ul>
<li>My 2020 presentation about similar bugs. The PlayStation Now bug was not
disclosed at that time, but I discuss other bugs.</li>
</ul>
</li>
<li>
<a href="https://parsiya.net/blog/2021-04-30-testing-extensions-in-chromium-browsers-nordpass/#the-old-new-thing---yet-another-local-websocket-server" title="Nordpass password manager desktop app has a local WebSocket server" rel="nofollow" target="_blank">Nordpass password manager desktop app has a local WebSocket server</a></li>
</ul>
<h3 id="testing-local-websocket-servers">Testing Local WebSocket Servers
<a href="#testing-local-websocket-servers"><svg height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a>
</h3><p>Testing for this issue is very quick. Create a test page that tries to connect
to a local WebSocket server on a specific port. Host it somewhere remote (e.g.,
S3 bucket) and open it on the machine. If the connection is successful we are in
business.</p>
<p>I also check in Burp. Create the WebSocket handshake in Burp Repeater. Modify
the <code>Origin</code> header to <code>https://example.net</code>. If the response has
<code>HTTP/1.1 101 Switching Protocols</code>, you are good to go!</p>
<p><span>
<img src="https://parsiya.net/blog/2021-12-20-rce-in-visual-studio-codes-remote-wsl-for-fun-and-negative-profit/07-local-websocket.png" title="Testing in Burp" alt="Testing in Burp"/>
<span>Testing in Burp</span>
</span></p><p><strong>Note:</strong> This only matters for localhost servers. The server here is also
externally exposed (it&#39;s bound to <code>0.0.0.0</code>). Attackers are not bound by the
browser. They can connect directly to the server and supply any <code>Origin</code> header.</p>
<p>The next item on the agenda is looking at the traffic in Wireshark. Right-click
on one of the WebSocket handshake <code>GET</code> requests from before and select
<code>Follow &gt; TCP Stream</code>. This will show us a screen with some readable text. Close
it and see only the packets for this stream. This allows us to just follow this
stream.</p>
<p>You might ask why I closed the popup that contains only the content of the
messages. This is not useful here. By <a href="https://datatracker.ietf.org/doc/html/rfc6455#page-33" target="_blank" rel="noreferrer noopener">RFC6455</a> the messages from
the client to server must be masked. It means they are XOR-ed with a 4-byte key
(that is also supplied with the message). Wireshark unmasks each packet when
selected but the payloads appear as masked in the initial stream popup. So we
will see server messages in plaintext while client messages are masked and
gibberish. Wireshark unmasks the payload if you click on individual messages,
but it would be awesome if we could view all of them here and search in
messages, too.</p>
<h2 id="help-from-the-future">Help From the Future
<a href="#help-from-the-future"><svg height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a>
</h2><p>I spent a few days reverse engineering the protocol. Later, I realized I can
just see the protocol&#39;s source code in
<a href="https://github.com/microsoft/vscode/blob/b3318bc0524af3d74034b8bb8a64df0ccf35549a/src/vs/base/parts/ipc/common/ipc.net.ts#L387" target="_blank" rel="noreferrer noopener">/src/vs/base/parts/ipc/common/ipc.net.ts</a>.</p>
<div><pre tabindex="0"><code data-lang="ts"><span>/**
</span><span> * A message has the following format:
</span><span> * ```
</span><span> *     /-------------------------------|------\
</span><span> *     |             HEADER            |      |
</span><span> *     |-------------------------------| DATA |
</span><span> *     | TYPE | ID | ACK | DATA_LENGTH |      |
</span><span> *     \-------------------------------|------/
</span><span> * ```
</span><span> * The header is 9 bytes and consists of:
</span><span> *  - TYPE is 1 byte (ProtocolMessageType) - the message type
</span><span> *  - ID is 4 bytes (u32be) - the message id (can be 0 to indicate to be ignored)
</span><span> *  - ACK is 4 bytes (u32be) - the acknowledged message id (can be 0 to indicate to be ignored)
</span><span> *  - DATA_LENGTH is 4 bytes (u32be) - the length in bytes of DATA
</span><span> *
</span><span> * Only Regular messages are counted, other messages are not counted, nor acknowledged.
</span><span> */</span>
</code></pre></div>
<h2 id="the-protocol-handshake">The Protocol Handshake
<a href="#the-protocol-handshake"><svg height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a>
</h2><p>The first message from the server is a <code>KeepAlive</code> message.</p>
<pre tabindex="0"><code>00000000  04 00 00 00 00 00 00 00 00 00 00 00 00           |.............|
</code></pre><p>In the <a href="https://github.com/microsoft/vscode/blob/b3318bc0524af3d74034b8bb8a64df0ccf35549a/src/vs/base/parts/ipc/common/ipc.net.ts#L387" target="_blank" rel="noreferrer noopener">protocol definition</a> we can see the different message types.</p>
<div><pre tabindex="0"><code data-lang="ts"><span>const</span> <span>enum</span> ProtocolMessageType {
   None <span>=</span> <span>0</span>,
   Regular <span>=</span> <span>1</span>,
   Control <span>=</span> <span>2</span>,
   Ack <span>=</span> <span>3</span>,
   KeepAlive <span>=</span> <span>4</span>,
   Disconnect <span>=</span> <span>5</span>,
   ReplayRequest <span>=</span> <span>6</span>
}
</code></pre></div><p>In
<a href="https://github.com/microsoft/vscode/blob/b3318bc0524af3d74034b8bb8a64df0ccf35549a/src/vs/platform/remote/common/remoteAgentConnection.ts#L64" target="_blank" rel="noreferrer noopener">/src/vs/platform/remote/common/remoteAgentConnection.ts</a>,
it&#39;s called an <code>OKMessage</code> and heartbeat in other parts of the code.</p>
<div><pre tabindex="0"><code data-lang="ts"><span>export</span> <span>interface</span> OKMessage {
   <span>type</span><span>:</span> <span>&#39;ok&#39;</span>;
}
</code></pre></div><p>The client handles this in <code>connectToRemoteExtensionHostAgent</code> in
<a href="https://github.com/microsoft/vscode/blob/b3318bc0524af3d74034b8bb8a64df0ccf35549a/src/vs/platform/remote/common/remoteAgentConnection.ts#L227" target="_blank" rel="noreferrer noopener">/src/vs/platform/remote/common/remoteAgentConnection.ts</a>.
We are looking at the code connecting to the server here.</p>
<p>The client (Code on Windows) sends this packet which is a KeepAlive and a
separate <code>auth</code> message.</p>
<pre tabindex="0"><code># OK
0000   04 00 00 00 00 00 00 00 00 00 00 00 00

# new message
# type 02,                       length 2d
0000  02 00 00 00 00 00 00 00 00 00 00 00 63 7b 22 74  |............c{&#34;t|
0010  79 70 65 22 3a 22 61 75 74 68 22 2c 22 61 75 74  |ype&#34;:&#34;auth&#34;,&#34;aut|
0020  68 22 3a 22 30 30 30 30 30 30 30 30 30 30 30 30  |h&#34;:&#34;000000000000|
0030  30 30 30 30 30 30 30 30 22 2c 22 64 61 74 61 22  |00000000&#34;,&#34;data&#34;|
0040  3a 22 68 75 45 6d 37 2b 4d 34 49 2f 56 42 75 76  |:&#34;huEm7+M4I/VBuv|
0050  67 6d 77 79 70 54 4b 59 4f 7a 62 62 33 32 48 73  |gmwypTKYOzbb32Hs|
0060  42 68 4d 50 68 74 6f 77 41 4a 35 63 51 3d 22 7d  |BhMPhtowAJ5cQ=&#34;}|
</code></pre><p>Initially, I thought the length field is 12 bytes instead of 4 because the rest
of the bytes were always empty. Then I realized only <code>Regular Messages</code> use the
message ID and ACK fields and I have only seen handshake messages which are not
regular.</p>
<div><pre tabindex="0"><code data-lang="json">{
    <span>&#34;type&#34;</span>: <span>&#34;auth&#34;</span>,
    <span>&#34;auth&#34;</span>: <span>&#34;00000000000000000000&#34;</span>,
    <span>&#34;data&#34;</span>: <span>&#34;huEm7+M4I/VBuvgmwypTKYOzbb32HsBhMPhtowAJ5cQ=&#34;</span>
}
</code></pre></div><p>Before the fix, this was not checked.</p>
<div><pre tabindex="0"><code data-lang="ts"><span>// [Parsia]: The client sending the auth request.
</span><span></span><span>const</span> authRequest: <span>AuthRequest</span> <span>=</span> {
   <span>type</span><span>:</span> <span>&#39;auth&#39;</span>,
   auth: <span>options.connectionToken</span> <span>||</span> <span>&#39;00000000000000000000&#39;</span>,
   data: <span>message.data</span>
};
protocol.sendControl(VSBuffer.fromString(JSON.stringify(authRequest)));
</code></pre></div><p><strong>Note:</strong> Before the 2021-11-09 update (commit
<code>b3318bc0524af3d74034b8bb8a64df0ccf35549a</code>) the client did not send the <code>data</code>.
However, using this commit we can still send a message without this key and it
would work. This is something we give the server to sign to check that we are
connecting to the correct server (this is DRM, it has its own section).</p>
<p>The server responds with a <code>sign</code> request.</p>
<pre tabindex="0"><code>0000  02 00 00 00 00 00 00 00 00 00 00 00 79 7b 22 74  |............y{&#34;t|
0010  79 70 65 22 3a 22 73 69 67 6e 22 2c 22 64 61 74  |ype&#34;:&#34;sign&#34;,&#34;dat|
0020  61 22 3a 22 36 32 61 72 35 4e 66 45 6b 30 6b 71  |a&#34;:&#34;62ar5NfEk0kq|
0030  38 6f 51 6e 33 56 71 56 4d 63 48 74 6e 36 50 49  |8oQn3VqVMcHtn6PI|
0040  6a 37 51 4a 37 35 65 42 39 4c 67 6d 63 6c 73 3d  |j7QJ75eB9Lgmcls=|
0050  22 2c 22 73 69 67 6e 65 64 44 61 74 61 22 3a 22  |&#34;,&#34;signedData&#34;:&#34;|
0060  31 36 34 62 62 37 31 38 2d 62 33 66 64 2d 34 61  |164bb718-b3fd-4a|
0070  30 63 2d 61 36 66 61 2d 39 61 36 61 63 38 36 35  |0c-a6fa-9a6ac865|
0080  36 66 37 63 22 7d                                |6f7c&#34;}|
</code></pre><p>Another JSON object:</p>
<div><pre tabindex="0"><code data-lang="json">{
    <span>&#34;type&#34;</span>: <span>&#34;sign&#34;</span>,
    <span>&#34;data&#34;</span>: <span>&#34;62ar5NfEk0kq8oQn3VqVMcHtn6PIj7QJ75eB9Lgmcls=&#34;</span>,
    <span>&#34;signedData&#34;</span>: <span>&#34;164bb718-b3fd-4a0c-a6fa-9a6ac8656f7c&#34;</span>
}
</code></pre></div><p>The server has <code>signed</code> the data that we sent in the previous message and has
responded with its own <code>data</code> request.</p>
<p>The client <code>validates</code> the signed data to check if it&#39;s a supported server. We
can simply skip this when we create our client.</p>
<div><pre tabindex="0"><code data-lang="ts"><span>// [Parsia]: Client reads the server&#39;s message.
</span><span></span><span>const</span> msg <span>=</span> awaitreadOneControlMessage&lt;<span>HandshakeMessage</span>&gt;(
   protocol,
   combineTimeoutCancellation(timeoutCancellationToken, createTimeoutCancellation(<span>10000</span>))
   );

<span>// [Parsia]: Don&#39;t continue if the message type is not `sign` or it&#39;s not a string.
</span><span></span><span>if</span> (msg.<span>type</span> <span>!==</span> <span>&#39;sign&#39;</span> <span>||</span> <span>typeof</span> msg.data <span>!==</span> <span>&#39;string&#39;</span>) {
   <span>const</span> error: <span>any</span> <span>=</span> <span>new</span> <span>Error</span>(<span>&#39;Unexpected handshake message&#39;</span>);
   error.code <span>=</span> <span>&#39;VSCODE_CONNECTION_ERROR&#39;</span>;
   <span>throw</span> error;
}

options.logService.trace(<span>`</span><span>${</span>logPrefix<span>}</span><span> 4/6. received SignRequest control message.`</span>);

<span>// [Parsia]: Validate `signedData` from the server.
</span><span></span><span>const</span> isValid <span>=</span> <span>await</span> raceWithTimeoutCancellation(
      options.signService.validate(message, msg.signedData),
      timeoutCancellationToken
   );

<span>if</span> (<span>!</span>isValid) {
   <span>const</span> error: <span>any</span> <span>=</span> <span>new</span> <span>Error</span>(<span>&#39;Refused to connect to unsupported server&#39;</span>);
   error.code <span>=</span> <span>&#39;VSCODE_CONNECTION_ERROR&#39;</span>;
   <span>throw</span> error;
}
</code></pre></div><p>There&#39;s some funky validation going on here. Signing and stuff usually means
DRM. I know, I work with videogames!</p>
<h3 id="your-editor-has-drm">Your Editor has DRM
<a href="#your-editor-has-drm"><svg height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a>
</h3><p>I chased the <code>options.signService.validate</code> method in the code for an hour and
I got to <a href="https://github.com/microsoft/vscode/blob/b3318bc0524af3d74034b8bb8a64df0ccf35549a/src/vs/platform/sign/node/signService.ts" target="_blank" rel="noreferrer noopener">/src/vs/platform/sign/node/signService.ts</a>.</p>
<div><pre tabindex="0"><code data-lang="ts"><span>export</span> <span>class</span> SignService <span>implements</span> ISignService {
   <span>declare</span> <span>readonly</span> _serviceBrand: <span>undefined</span>;

   <span>private</span> <span>static</span> _nextId <span>=</span> <span>1</span>;
   <span>private</span> <span>readonly</span> validators <span>=</span> <span>new</span> Map&lt;<span>string</span>, vsda.validator&gt;();

   <span>private</span> vsda()<span>:</span> Promise&lt;<span>typeof</span> vsda&gt; {
      <span>// [Parsia]: vsda
</span><span></span>      <span>return</span> <span>new</span> Promise((resolve, reject) <span>=&gt;</span> <span>require</span>([<span>&#39;vsda&#39;</span>], resolve, reject));
   }
   <span>// [Parsia]: Removed.
</span></code></pre></div><p><code>vsda</code> is a Node native addon written in C++. Think of
<a href="https://nodejs.org/api/addons.html" target="_blank" rel="noreferrer noopener">Node native addons</a> as a shared library or DLL. This addon is in
a private repository at <a href="https://github.com/microsoft/vsda" target="_blank" rel="noreferrer noopener">https://github.com/microsoft/vsda</a> and was an NPM package
until around 2019 according to <a href="https://libraries.io/npm/vsda/" target="_blank" rel="noreferrer noopener">https://libraries.io/npm/vsda/</a>.</p>
<p>It&#39;s bundled with VS Code client and server:</p>
<ul>
<li>Windows: <code>C:\Program Files\Microsoft VS Code\resources\app\node_modules.asar.unpacked\vsda\build\Release\vsda.node</code>.</li>
<li>Server (WSL): <code>~/.vscode-server/bin/{commit}/node_modules/vsda/build/Release/vsda.node</code>.
<ul>
<li>As of today (2021-11-09)<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup> the Linux version has symbols and it&#39;s pretty
small. Should be a quick reversing exercise.</li>
</ul>
</li>
</ul>
<p>So, what is it? It&#39;s DRM<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>. But yeah your editor has DRM!</p>
<p><code>Code OSS</code> (open source), and the build from Microsoft are different according to
<a href="https://github.com/microsoft/vscode/wiki/Differences-between-the-repository-and-Visual-Studio-Code" target="_blank" rel="noreferrer noopener">https://github.com/microsoft/vscode/wiki/Differences-between-the-repository-and-Visual-Studio-Code</a>.</p>
<blockquote>
<p>Why?</p>
<p>Portions of the Remote Development extensions are used in developer services
that are run under a proprietary license. While these extensions do not require
these services to work, there is enough code reuse that the extensions are also
under a proprietary license. While the bulk of the code is in the extensions and
in the Code - OSS repository, a handful of small changes are in the Visual
Studio Code distribution.</p>
<p>How?</p>
<p>Parts of the code to negotiate a connection to the Visual Studio Code server are
proprietary.</p>


</blockquote>
<p>I found <a href="https://github.com/kieferrm/vsda-example" target="_blank" rel="noreferrer noopener">https://github.com/kieferrm/vsda-example</a> and figured out
how to use it to create and sign messages after some experiments.</p>
<ol>
<li>Create a new message with <code>msg1 = validator.createNewMessage(&#34;1234&#34;)</code>. The
input needs to be at least 4 characters.</li>
<li>Sign it with <code>signed1 = signer.sign(msg1)</code>.</li>
<li>Validate it with <code>validator.validate(signed1)</code> and the response
is <code>&#34;ok&#34;</code>.</li>
</ol>
<p>There&#39;s a big caveat. If you create a new message, you cannot validate old
messages anymore. In the source code, each message has its own validator.</p>
<div><pre tabindex="0"><code data-lang="js"><span>// In a Node REPL.
</span><span>// `vsda.node` for your OS is in the current directory or in the path.
</span><span></span>
<span>&gt;</span> <span>const</span> vsda <span>=</span> require(<span>&#39;vsda&#39;</span>);
<span>undefined</span>
<span>// Get a validator and a signer.
</span><span></span><span>&gt;</span> v1 <span>=</span> vsda.validator();
validator {}
<span>&gt;</span> s1 <span>=</span> vsda.signer();
signer {}

<span>// Create a message.
</span><span></span><span>&gt;</span> msg1 <span>=</span> v1.createNewMessage(<span>&#34;1234&#34;</span>);
<span>&#39;Q389dpb1xZwOq5UMQ3lc0CCl4HVBBI6cPMt9+w8vrBc=&#39;</span>

<span>// Sign it.
</span><span></span><span>&gt;</span> signed1 <span>=</span> s1.sign(msg1);
<span>&#39;089S7BKxd2LYtVy++3NHD4yw+j1+XjV4An0o18nVw5TDNY=&#39;</span>

<span>// Validate the signature.
</span><span></span><span>&gt;</span> v1.validate(signed1);
<span>&#39;ok&#39;</span>

<span>// Create a new message.
</span><span></span><span>&gt;</span> msg2 <span>=</span> v1.createNewMessage(<span>&#34;1234&#34;</span>);
<span>&#39;9JM7f2uljcBV/g9iZpVYRMuzFfkBum89g6l6xswOP6k=&#39;</span>

<span>// Now, we cannot validate the previous signature because we have created a new message.
</span><span></span><span>&gt;</span> v1.validate(signed1);
<span>&#39;error&#39;</span>

<span>// But we can sign and validate the most recent message.
</span><span></span><span>&gt;</span> signed2 <span>=</span> s1.sign(msg2);
<span>&#39;171vO+IQAKGwt4eRKQFC6e32r9PkgtwSXpmEFDhVehS5jA=&#39;</span>
<span>&gt;</span> v1.validate(signed2);
<span>&#39;ok&#39;</span>
</code></pre></div>
<h3 id="light-drm-reversing">Light DRM Reversing
<a href="#light-drm-reversing"><svg height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a>
</h3><p>The Linux version has symbols and is around 40 KBs. Drop it into IDA/Ghidra and
you should be good to go.</p>
<p>I spent some time on it and came up with this pseudo-code. <strong>This is probably not correct</strong>
but gives you the general idea of how this <code>signing</code> works.</p>
<ol>
<li>Initialize <code>srand</code> with the current time + 2*(msg[0]).
<ol>
<li>It will only create random numbers between 0 and 9 (inclusive).</li>
</ol>
</li>
<li>Append two random chars from the license array.</li>
<li>Append one random char from the salt array.</li>
<li>SHA256.</li>
<li>Base64.</li>
<li>???</li>
<li>Profit</li>
</ol>
<div><pre tabindex="0"><code data-lang="cs"><span>// assume
</span><span></span>msg = input_string;

<span>// Check if input is more than 4 characters.
</span><span></span><span>if</span> strlen(msg) &lt;= <span>3</span> <span>return</span>;

<span>// Initial srand with time and the first character of the message.
</span><span></span>t = time(NULL);
srand(t + msg[<span>0</span>] + msg[<span>0</span>]);

<span>do</span> twice {
   idx = rand() % <span>10</span>;  <span>// random number between 0 and 9.
</span><span></span>   license_char = license_array[idx]; <span>// get a char from the license array - see below
</span><span></span>   msg = append(msg, license_char);
}

<span>// Append one character from a different array named salt.
</span><span></span>idx2 = rand() % <span>10</span>;  <span>// random number between 0 and 9.
</span><span></span>salt_char = Handshake::CHandshakeImpl::s_saltArray[idx2];
msg = append(msg, salt_char);

<span>// SHA256 and Base64 and return.
</span><span></span><span>return</span> Base64(SHA256(msg););
</code></pre></div><p>Only characters from the first 10 positions are chosen from the license array.
It&#39;s always <code>rand() % 10</code> but doubled for the salt array.</p>
<p>The license array is this string:</p>
<pre tabindex="0"><code>You may only use the C/C++ Extension for Visual Studio Code with Visual Studio
Code, Visual Studio or Visual Studio for Mac software to help you develop and
test your applications.
</code></pre><p>The first 32 bytes of the salt array (look for <code>Handshake::CHandshakeImpl::s_saltArray</code>) are:</p>
<pre tabindex="0"><code>00000000  56 2b 79 2c 28 48 60 76 26 41 5c 40 78 2b 3b 34  |V+y,(H`v&amp;A\@x+;4|
00000010  47 75 4b 3c 24 7a 5d 2e 2e 3f 38 23 77 56 5a 6e  |GuK&lt;$z]..?8#wVZn|
</code></pre><p>I never actually checked if my analysis is correct or not. It&#39;s probably not.
But I did not need to know that. I knew how to sign messages using the addon and
that was enough.</p>
<h3 id="the-finishing-move">The Finishing Move
<a href="#the-finishing-move"><svg height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a>
</h3><p>Next, the client needs to <code>sign</code> the <code>data</code> from the server and send it back to show that it&#39;s a &#34;legit&#34; Code client.</p>
<div><pre tabindex="0"><code data-lang="ts"><span>// [Parsia]: Client code.
</span><span>// [Parsia]: sign the data sent by server.
</span><span></span><span>const</span> signed <span>=</span> <span>await</span> raceWithTimeoutCancellation(options.signService.sign(msg.data), timeoutCancellationToken);

<span>// [Parsia]: Send a message to the server.
</span><span></span><span>const</span> connTypeRequest: <span>ConnectionTypeRequest</span> <span>=</span> {
   <span>type</span><span>:</span> <span>&#39;connectionType&#39;</span>,
   commit: <span>options.commit</span>,
   signedData: <span>signed</span>,
   desiredConnectionType: <span>connectionType</span>
};
<span>if</span> (args) {
   connTypeRequest.args <span>=</span> args;
}
</code></pre></div><p>The server responds with</p>
<p>The client sends this very very interesting message:</p>
<div><pre tabindex="0"><code data-lang="json">{
    <span>&#34;type&#34;</span>: <span>&#34;connectionType&#34;</span>,
    <span>&#34;commit&#34;</span>: <span>&#34;b3318bc0524af3d74034b8bb8a64df0ccf35549a&#34;</span>,
    <span>&#34;signedData&#34;</span>: <span>&#34;997N934vpN7zWC1lGN88DC4p3B9N+L5GlNoVb5t//y/Iy8=&#34;</span>,
    <span>&#34;desiredConnectionType&#34;</span>: <span>2</span>,
    <span>&#34;args&#34;</span>: {
        <span>&#34;language&#34;</span>: <span>&#34;en&#34;</span>,
        <span>&#34;break&#34;</span>: <span>true</span>,
        <span>&#34;port&#34;</span>: <span>55000</span>,
        <span>&#34;env&#34;</span>: {
            <span>&#34;env-var-1&#34;</span>: <span>&#34;value-1&#34;</span>,
            <span>&#34;SHLVL&#34;</span>: <span>&#34;1&#34;</span>,
            <span>// ...
</span><span></span>        }
    }
}
</code></pre></div><p><code>commit</code> should match the server&#39;s commit hash. This is not a secret. It&#39;s
probably the last stable release commit (or one of the last few). This just
checks if the client and server are on the same version. It&#39;s also available at
<code>http://localhost:{port}/version</code>. Your browser JavaScript might not be able to
see it (muh SOP), but external clients have no such restrictions.</p>
<p><code>signedData</code> is the result of signing the data we got from the server in the
previous message.</p>
<p><code>args</code> is the most important part of this message. It can tell the server to
start a Node Inspector instance on a specific port.</p>
<ul>
<li><code>break</code>: Break after starting the Inspector instance.</li>
<li><code>port</code>: The port for the inspector instance.</li>
<li><code>env</code>: A list of environment variables and their values that are passed to
the inspector instance process.</li>
</ul>
<p>A <a href="https://nodejs.org/en/docs/guides/debugging-getting-started/" target="_blank" rel="noreferrer noopener">Node Inspector</a> instance can be used to debug the Node
application. If an attacker can connect to such an instance on your machine then
it&#39;s game over. In 2019, Tavis found
<a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1944" target="_blank" rel="noreferrer noopener">VS Code enabled the remote debugger by default</a>.</p>
<p>This is pretty nifty, neh?!</p>
<h3 id="what-else-can-we-do">What Else Can We Do?
<a href="#what-else-can-we-do"><svg height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a>
</h3><p>Before we get excited about this Node Inspector instance, let&#39;s take a step back
and discover other possibilities. Think about the use case. This whole setup is
designed to allow the Code client on Windows to develop remotely in WSL,
containers, or on GitHub Codespaces. This means it can do everything it wants on
the remote machine.</p>
<p>So, if a website can connect to your local WebSocket server and bypass the DRM
(which is not a secret), it can emulate a Code client. It has remote code
execution on your system and doesn&#39;t need the Node Inspector instance.</p>
<p>So far we have found two ways to exploit the system:</p>
<ol>
<li>Spawn and connect to the Node Inspector instance.</li>
<li>Emulate the Code client and interact with the remote machine using the custom
protocol.</li>
</ol>
<h2 id="the-node-inspector-instance">The Node Inspector Instance
<a href="#the-node-inspector-instance"><svg height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a>
</h2><p>Let&#39;s look at the <code>args</code> from the previous message.
<a href="https://github.com/microsoft/vscode/blob/b3318bc0524af3d74034b8bb8a64df0ccf35549a/src/vs/server/remoteExtensionHostAgentServer.ts#L726" target="_blank" rel="noreferrer noopener">/src/vs/server/remoteExtensionHostAgentServer.ts</a> processes them on
the server.</p>
<div><pre tabindex="0"><code data-lang="ts">} <span>else</span> <span>if</span> (msg.desiredConnectionType <span>===</span> ConnectionType.ExtensionHost) {

   <span>// This should become an extension host connection
</span><span></span>
   <span>// [Parsia]: msg.args is the value of args from the client.
</span><span></span>   <span>// [Parsia]: Default value if args is not provided.
</span><span></span>   <span>const</span> startParams0 <span>=</span> &lt;<span>IRemoteExtensionHostStartParams</span>&gt;msg.args <span>||</span> { language<span>:</span> <span>&#39;en&#39;</span> };

   <span>// [Parsia]: Choose a free debug port.
</span><span></span>   <span>const</span> startParams <span>=</span> <span>await</span> <span>this</span>._updateWithFreeDebugPort(startParams0);
</code></pre></div><p>The <code>IRemoteExtensionHostStartParams</code> interface is similar to the JSON object we
saw before:</p>
<div><pre tabindex="0"><code data-lang="ts"><span>export</span> <span>interface</span> IRemoteExtensionHostStartParams {
   language: <span>string</span>;
   debugId?: <span>string</span>;
   <span>break</span><span>?:</span> <span>boolean</span>;
   port?: <span>number</span> <span>|</span> <span>null</span>;
   env<span>?:</span> { [key: <span>string</span>]<span>:</span> <span>string</span> <span>|</span> <span>null</span> };
}
</code></pre></div><p><code>_updateWithFreeDebugPort</code> checks if the <code>port</code> is free. If not, it will try the
next 10 ports. The final free port is stored in <code>startParams.port</code>.</p>
<div><pre tabindex="0"><code data-lang="ts"><span>private</span> _updateWithFreeDebugPort(startParams: <span>IRemoteExtensionHostStartParams</span>)<span>:</span> Thenable&lt;<span>IRemoteExtensionHostStartParams</span>&gt; {
   <span>if</span> (<span>typeof</span> startParams.port <span>===</span> <span>&#39;number&#39;</span>) {
      <span>return</span> findFreePort(startParams.port, <span>10</span> <span>/* try 10 ports */</span>, <span>5000</span> <span>/* try up to 5 seconds */</span>).then(freePort <span>=&gt;</span> {
         startParams.port <span>=</span> freePort;
         <span>return</span> startParams;
      });
   }
   <span>// No port clear debug configuration.
</span><span></span>   startParams.debugId <span>=</span> <span>undefined</span>;
   startParams.port <span>=</span> <span>undefined</span>;
   startParams.<span>break</span> <span>=</span> <span>undefined</span>;
   <span>return</span> Promise.resolve(startParams);
}
</code></pre></div><p>The chosen port is sent back to the client so we know where to go:</p>
<div><pre tabindex="0"><code data-lang="ts"><span>// [Parsia]: The line that sends back the debug port.
</span><span></span>protocol.sendControl(
   VSBuffer.fromString(JSON.stringify(startParams.port <span>?</span> {debugPort: <span>startParams.port</span>} <span>:</span> {}))
);

<span>// [Parsia]: What the response looks like.
</span><span></span>{ debugPort: <span>55001</span> }
</code></pre></div><p>And finally, it calls <code>con.start(startParams);</code> in
<a href="https://github.com/microsoft/vscode/blob/b3318bc0524af3d74034b8bb8a64df0ccf35549a/src/vs/server/extensionHostConnection.ts#L187" target="_blank" rel="noreferrer noopener">/src/vs/server/extensionHostConnection.ts</a>.</p>
<div><pre tabindex="0"><code data-lang="ts"><span>public</span> <span>async</span> start(startParams: <span>IRemoteExtensionHostStartParams</span>)<span>:</span> Promise&lt;<span>void</span>&gt; {
   <span>try</span> {
      <span>let</span> execArgv: <span>string</span>[] <span>=</span> [];
      <span>if</span> (startParams.port <span>&amp;&amp;</span> <span>!</span>(&lt;<span>any</span>&gt;process).pkg) {
         <span>// [Parsia]: Listen on `0.0.0.0:debugPort`.
</span><span></span>         execArgv <span>=</span> [<span>`--inspect</span><span>${</span>startParams.<span>break</span> <span>?</span> <span>&#39;-brk&#39;</span> <span>:</span> <span>&#39;&#39;</span><span>}</span><span>=0.0.0.0:</span><span>${</span>startParams.port<span>}</span><span>`</span>];
      }

      <span>// [Parsia]: Add the environment variables.
</span><span></span>      <span>const</span> env <span>=</span>
         <span>await</span> buildUserEnvironment(
            startParams.env, startParams.language, <span>!!</span>startParams.debugId, <span>this</span>._environmentService, <span>this</span>._logService
         );
      <span>// [Parsia]: This is not a security filter.
</span><span></span>      removeDangerousEnvVariables(env);

      <span>const</span> opts <span>=</span> {
         env,
         execArgv,
         silent: <span>true</span>
      };

      <span>// Run Extension Host as fork of current process
</span><span></span>      <span>const</span> args <span>=</span> [<span>&#39;--type=extensionHost&#39;</span>, <span>`--uriTransformerPath=</span><span>${</span>uriTransformerPath<span>}</span><span>`</span>];
      <span>const</span> useHostProxy <span>=</span> <span>this</span>._environmentService.args[<span>&#39;use-host-proxy&#39;</span>];
      <span>if</span> (useHostProxy <span>!==</span> <span>undefined</span>) {
         args.push(<span>`--useHostProxy=</span><span>${</span>useHostProxy<span>}</span><span>`</span>);
      }
      <span>// [Parsia]: Fork it, Potato!
</span><span></span>      <span>this</span>._extensionHostProcess <span>=</span> cp.fork(FileAccess.asFileUri(<span>&#39;bootstrap-fork&#39;</span>, <span>require</span>).fsPath, args, opts);
      <span>const</span> pid <span>=</span> <span>this</span>._extensionHostProcess.pid;
      <span>this</span>._log(<span>`&lt;</span><span>${</span>pid<span>}</span><span>&gt; Launched Extension Host Process.`</span>);

     <span>// [Parsia]: Removed.
</span><span></span>}
</code></pre></div><p>This looks complicated. Let&#39;s break it down:</p>
<ol>
<li>The Node Inspector instance will listen on <code>0.0.0.0:debugPort</code>.
<ol>
<li>This is bad. If the user accepts the Windows firewall dialog, it will be
externally available.</li>
</ol>
</li>
<li>We can also inject into the Inspector&#39;s environment variables.</li>
<li>The <a href="https://github.com/microsoft/vscode/blob/b3318bc0524af3d74034b8bb8a64df0ccf35549a/src/vs/base/node/processes.ts#L90" target="_blank" rel="noreferrer noopener">removeDangerousEnvVariables</a> method is not a security filter
and just removes <code>DEBUG</code>, <code>DYLD_LIBRARY_PATH</code>, and <code>LD_PRELOAD</code> environment
variables if they exist to prevent crashes.</li>
</ol>
<h3 id="what-is-node-inspector">What is Node Inspector?
<a href="#what-is-node-inspector"><svg height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a>
</h3><p>It can be used to debug Node processes. There are clients and libraries that
support this but usually, I use Chromium&#39;s built-in
<code>dedicated DevTools for Node</code> (<code>chrome|edge://inspect</code>).</p>
<p>After connecting to the Inspector instance we can open up the console and run
<code>require(&#39;child_process&#39;).exec(&#39;calc.exe&#39;);</code>. It works although we are
in WSL.</p>
<p>The JavaScript in the browser cannot connect to the Inspector instance. The
client talks to the instance with another WebSocket connection. However, we need
to know the debugger session ID. It is available at
<code>http://localhost:{debugPort}/json/list</code>.</p>
<p><span>
<img src="https://parsiya.net/blog/2021-12-20-rce-in-visual-studio-codes-remote-wsl-for-fun-and-negative-profit/08-json-list.png" title="/json/list" alt="/json/list"/>
<span>/json/list</span>
</span></p><p>The JavaScript in the browser can send this GET request but cannot see the
response because of the SOP (the response doesn&#39;t have the
<code>Access-Control-Allow-Origin</code> header). Other clients do not have this
limitation and because the inspector is available externally, we can connect to
it from outside.</p>
<p>I created a simple proof-of-concept:</p>
<ol>
<li>Open a website and enter the port (we can scan for it but it&#39;s faster to enter it manually).</li>
<li>The JavaScript in the website completes the handshake.
<ol>
<li>I created a Node app (in WSL with Code, lol) with a <code>/sign</code> API to use
the <code>vsda</code> addon.</li>
</ol>
</li>
<li>As soon as the Node Inspector instance is spawned, a second API was called
with the <code>debugPort</code>.</li>
<li>A Node app using the <a href="https://github.com/cyrus-and/chrome-remote-interface" target="_blank" rel="noreferrer noopener">chrome-remote-interface</a> library connects to
the Inspector instance and runs calc.</li>
</ol>
<p>You can see the source code at:</p>
<p><a href="https://github.com/parsiya/code-wsl-rce" target="_blank" rel="noreferrer noopener">https://github.com/parsiya/code-wsl-rce</a>
<a href="https://github.com/parsiya/Parsia-Code/tree/master/code-wsl-rce" target="_blank" rel="noreferrer noopener">https://github.com/parsiya/Parsia-Code/tree/master/code-wsl-rce</a></p>
<h2 id="emulate-the-code-client">Emulate the Code Client
<a href="#emulate-the-code-client"><svg height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a>
</h2><p>I did not go this route but I spent some time looking at the traffic. It uses
the same protocol that we saw in the handshake messages. It&#39;s completely
possible to do everything if you can figure out the correct messages and their
formats.</p>
<p>The code to create a client and connect to the server with the protocol is in
the VS Code GitHub repository. It&#39;s going to be a lot of copy/paste and
resolving. I did not spend more than a few hours on it.</p>
<p>Let&#39;s do a recap. We can:</p>
<ol>
<li>Connect to the local WebSocket server from a web page or externally.</li>
<li>Complete the handshake and tell the server to start a Node inspector instance
on a specific port.</li>
<li>The VS Code server creates the instance and listens on all interfaces (again).</li>
<li>The VS Code server returns the port for the inspector instance.</li>
<li>If the machine is accessible we can connect to the Node inspector service
from outside.</li>
<li>???</li>
<li>Remote code execution.</li>
</ol>
<p>I created a quick proof-of-concept in ironically WSL remote (lol) using Node.
This makes some assumptions:</p>
<ol>
<li>We have found the local WebSocket port.</li>
<li>We can connect to the Node inspector instance from outside.</li>
</ol>
<p>It&#39;s also possible to do initial steps but mimic the Code client and do whatever
we want.</p>
<h2 id="limitations">Limitations
<a href="#limitations"><svg height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a>
</h2><p>Finding the local WebSocket port is not hard. It just takes a while. Scanning
for local servers from the browser is not a novel thing. The server is also
available externally so we&#39;re not bound by the browser there.</p>
<p><a href="https://snyk.io/blog/visual-studio-code-extension-security-vulnerabilities-deep-dive/" target="_blank" rel="noreferrer noopener">Deep dive into Visual Studio Code extension security vulnerabilities</a>
is a good resource that talks about similar bugs in VS Code extensions.</p>
<p>It talks about scanning local WebSocket ports. Chrome throttling has no effect
because the WebSocket server needs a webserver to handle the handshake. I am
also curious if the WebSocket throttling is a Chrome specific protection or is
part of Chromium (e.g., does Edge have it?).</p>
<blockquote>
<p>Interestingly, Chrome browser has a protection mechanism which prevents a
malicious actor from brute forcing WebSocket ports — it starts throttling
after the 10th attempt. Unfortunately, this protection can be easily bypassed
because both the HTTP and WebSocket servers of the extension are started on
the same port. This can be used to brute force all possible local ports by
checking the presence of a picture on a specific localhost port by adding an
<code>onload</code> handler to an <code>img</code> tag.</p>
</blockquote>
<p>That said, this is a development environment and the user is probably developing
in the WSL all day and never closes their browser tabs so chances are we can
find it if they open our website.</p>
<p>Connecting to the Node inspector instance is another matter. We cannot do it
from the browser so we need the victim&#39;s machine to be accessible to our server.
It&#39;s probably behind a NAT. But if it&#39;s done on a development server we might
have a better chance.</p>
<p>The second exploitation method (emulating the Code client) has none of these
limitations because the browser can talk to the local server and perform all
actions. It just needs us to reverse engineer the protocol and figure out the
correct messages to send.</p>
<h2 id="so-how-do-we-fix-this">So How Do We Fix This?
<a href="#so-how-do-we-fix-this"><svg height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a>
</h2><p>I have Security Engineer in my title so I should know how to fix this! RIGHT?!</p>
<ol>
<li>Don&#39;t listen on <code>0.0.0.0</code>!</li>
<li>When you get a WebSocket upgrade request, check the <code>Origin</code> header against
an allowlist. The Code client sends <code>vscode-file://vscode-app</code> in that header
so we can use this to get started.</li>
</ol>
<p>Fixing one without the other will not work. Well, kinda!</p>
<p>Fixing #2 will prevent websites from connecting to the WebSocket server because
browsers set the <code>Origin</code> header on every cross-origin request (at least they
should, if they do not you should nod disappointingly at the Chromium team).
But, if the server is exposed externally, then it fixes nothing.</p>
<p>If you fix #1 and not #2, it&#39;s better. But websites can still connect to the
server and mess with the dev environment. Chances are we can do RCE through the
environment variables.</p>
<h2 id="what-was-actually-fixed">What Was Actually Fixed?
<a href="#what-was-actually-fixed"><svg height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a>
</h2><p>My suggestions were to modify the VS Code Server. Honestly, I think they are
better suggestions.</p>
<p>Instead, the <code>Remote WSL</code> extension was modified. Now we cannot send a bunch of
zeros in the <code>auth</code> request and we need to have a connection token. I did not
dig a lot but seems like now the <code>wslDaemon.js</code> file in the extension creates a
random int and passes it as the connection token.</p>
<p><code>const p = String(a.randomInt(0xffffffffff))</code>.</p>
<ol>
<li>Does it fix the issues? Yes.</li>
<li>Do I think there are other security issues here and we can bypass this? Also,
yes.</li>
<li>Do I want to spend more time doing free work for a company with a 2.5
TRILLION market cap? Hell, no.</li>
</ol>
<p>Case in point, the default <code>connection-token</code> for the web browser mode in remote
server is <code>00000</code>. See <a href="https://github.com/microsoft/vscode/blob/807bf598bea406dcb272a9fced54697986e87768/resources/server/bin-dev/code-web.js#L64" target="_blank" rel="noreferrer noopener">/resources/server/bin-dev</a>.</p>
<div><pre tabindex="0"><code data-lang="ts"><span>// Connection Token
</span><span></span>serverArgs.push(<span>&#39;--connection-token&#39;</span>, <span>&#39;00000&#39;</span>);
</code></pre></div><p>If you see a VS Code server talking to a web browser and listening on port
<code>9888</code> try this connection token. See the
<a href="#the-local-web-server" title="The Local Web Server">The Local Web Server</a>
section below to see how to use it with the <code>/vscode-remote-resource</code> route to
read local resources.</p>
<p>I sat on this bug for a month because I wanted to reverse engineer the protocol
completely. Now I am glad I did not.</p>
<table>
<thead>
<tr>
<th>2021-11-22</th>
<th>Reported to MSRC</th>
</tr>
</thead>
<tbody>
<tr>
<td>2021-12-1</td>
<td>Case created</td>
</tr>
<tr>
<td>2021-12-10</td>
<td>Triaged</td>
</tr>
<tr>
<td>2021-12-13</td>
<td>Out-of-scope for bounty notification</td>
</tr>
<tr>
<td>2021-12-15</td>
<td>Fix released. CVE-2021-43907 assigned</td>
</tr>
</tbody>
</table>
<p>I think this is a good section to have. We learn by failing and these methods
might work in other situations. I can also add any extra information that did
not make it to the main sections.</p>
<h2 id="injecting-environment-variables">Injecting Environment Variables
<a href="#injecting-environment-variables"><svg height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a>
</h2><p>I could inject environment variables (abbreviated to <code>env var</code> in the rest of this
section) in the Node Inspector process. I tried to get RCE that way.</p>
<p>I found <a href="https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/" target="_blank" rel="noreferrer noopener">this awesome writeup</a> by Michał Bentkowski or
<a href="https://twitter.com/SecurityMB" target="_blank" rel="noreferrer noopener">@SecurityMB</a> about CVE-2019-7609. He could inject env vars into
a Node process through prototype pollution.</p>
<p>A Node process looks up the value of the <code>NODE_OPTIONS</code> env var. By passing
<code>--require ./file.js</code> to this env var, the Node process executes the file if
it&#39;s valid JavaScript. But that means we have to write to a file on the remote machine.</p>
<p>On Linux, the processes&#39; env vars can be accessed with <code>/proc/self/environ</code> or
<code>/proc/{pid}/environ</code>. Everything is a file! He created two env vars:</p>
<ol>
<li><code>AAA</code>: <code>console.log(123)//</code>.</li>
<li><code>NODE_OPTIONS</code>: <code>--require /proc/self/environ</code>.</li>
</ol>
<p><code>AAA</code> went to the top of the <code>environ</code> file and made it valid JavaScript. So the
process executed it. This is a big limitation. Our injected env var must be at
the top of that file otherwise the file is not valid JavaScript.</p>
<p>I went this route but it did not work. I would get an error that says
<code>USER=parsia</code> is not valid. Turns out my injected env vars are added to the end.
The culprits are these lines in <a href="https://github.com/microsoft/vscode/blob/b3318bc0524af3d74034b8bb8a64df0ccf35549a/src/vs/server/extensionHostConnection.ts#L45" target="_blank" rel="noreferrer noopener">buildUserEnvironment</a> inside
<code>/src/vs/server/extensionHostConnection.ts</code>:</p>
<div><pre tabindex="0"><code data-lang="ts">   <span>const</span> env: <span>IProcessEnvironment</span> <span>=</span> {
      ...processEnv,
      ...userShellEnv,
      ...{
         VSCODE_LOG_NATIVE: <span>String</span>(isDebug),
         VSCODE_AMD_ENTRYPOINT<span>:</span> <span>&#39;vs/server/remoteExtensionHostProcess&#39;</span>,
         VSCODE_PIPE_LOGGING<span>:</span> <span>&#39;true&#39;</span>,
         VSCODE_VERBOSE_LOGGING<span>:</span> <span>&#39;true&#39;</span>,
         VSCODE_EXTHOST_WILL_SEND_SOCKET<span>:</span> <span>&#39;true&#39;</span>,
         VSCODE_HANDLES_UNCAUGHT_ERRORS<span>:</span> <span>&#39;true&#39;</span>,
         VSCODE_LOG_STACK<span>:</span> <span>&#39;false&#39;</span>,
         VSCODE_NLS_CONFIG: <span>JSON.stringify</span>(nlsConfig, <span>undefined</span>, <span>0</span>)
      },
      ...startParamsEnv
   };
</code></pre></div><p><code>startParamsEnv</code> are our injected env vars. The first var is our WSL
username.</p>
<pre tabindex="0"><code>$ xargs --null --max-args=1 echo &lt; /proc/3935/environ
USER=parsia
VSCODE_WSL_EXT_LOCATION=/mnt/c/Users/Parsia/.vscode/extensions/ms-vscode-remote.remote-wsl-0.58.5
SHLVL=2
</code></pre><p>I also searched for <code>VSCODE_</code> in the source code to see if I could use any other
env vars for RCE. Some of these looked promising but ultimately none worked:</p>
<ul>
<li><code>NODE_PATH</code></li>
<li><code>VSCODE_WSL_EXT_LOCATION</code></li>
<li><code>VSCODE_CLIENT_COMMAND</code>: This is set to the WSL path of <code>code.exe</code> on the
Windows side.</li>
<li><code>VSCODE_DEV</code>: I think it spawns a Code process with fewer security features
but I could not use anything there.</li>
<li><code>VSCODE_BROWSER</code></li>
</ul>
<p>You might have a better chance.</p>
<h2 id="command-injection">Command Injection
<a href="#command-injection"><svg height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a>
</h2><p>I tried injecting commands in the <code>execArgv</code> variable. I control
<code>startParams.break</code> and startParams.port`.</p>
<div><pre tabindex="0"><code data-lang="ts"><span>let</span> execArgv: <span>string</span>[] <span>=</span> [];
<span>if</span> (startParams.port <span>&amp;&amp;</span> <span>!</span>(&lt;<span>any</span>&gt;process).pkg) {
   <span>// [Parsia]: Listen on `0.0.0.0:debugPort`.
</span><span></span>   execArgv <span>=</span> [<span>`--inspect</span><span>${</span>startParams.<span>break</span> <span>?</span> <span>&#39;-brk&#39;</span> <span>:</span> <span>&#39;&#39;</span><span>}</span><span>=0.0.0.0:</span><span>${</span>startParams.port<span>}</span><span>`</span>];
}
</code></pre></div><p>Unfortunately, type checking in TypeScript did not let me do it. <code>startParams0</code>
is of type <code>IRemoteExtensionHostStartParams</code> and the conversion would not
convert strings in those values because they are boolean and number
respectively.</p>
<div><pre tabindex="0"><code data-lang="ts"><span>export</span> <span>interface</span> IRemoteExtensionHostStartParams {
   language: <span>string</span>;
   debugId?: <span>string</span>;
   <span>break</span><span>?:</span> <span>boolean</span>;
   port?: <span>number</span> <span>|</span> <span>null</span>;
   env<span>?:</span> { [key: <span>string</span>]<span>:</span> <span>string</span> <span>|</span> <span>null</span> };
}
</code></pre></div><p>Server code doing the conversion:</p>
<div><pre tabindex="0"><code data-lang="ts">} <span>else</span> <span>if</span> (msg.desiredConnectionType <span>===</span> ConnectionType.ExtensionHost) {

    <span>// This should become an extension host connection
</span><span></span>    <span>const</span> startParams0 <span>=</span> &lt;<span>IRemoteExtensionHostStartParams</span>&gt;msg.args <span>||</span> { language<span>:</span> <span>&#39;en&#39;</span> };
    <span>const</span> startParams <span>=</span> <span>await</span> <span>this</span>._updateWithFreeDebugPort(startParams0);

    <span>if</span> (startParams.port) {
        <span>this</span>._logService.trace(<span>`</span><span>${</span>logPrefix<span>}</span><span> - startParams debug port </span><span>${</span>startParams.port<span>}</span><span>`</span>);
    }
</code></pre></div>
<h2 id="the-local-web-server">The Local Web Server
<a href="#the-local-web-server"><svg height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a>
</h2><p>The Code server runs a local web server that manages the WebSocket handshake.
This server has some routes:</p>
<p><code>vscode/src/vs/server/remoteExtensionHostAgentServer.ts</code> has a method named
<code>handleRequest</code>.</p>
<p>Supports only <code>GET</code>. While we may not be able to see the response, these GET
requests are &#34;simple&#34; and sent anyways.</p>
<ul>
<li><code>/version</code> returns the commit hash.</li>
<li><code>/delay-shutdown</code> supposedly delays a shutdown?! Can we delay the server
shutdown by sending a request to this endpoint?</li>
<li><code>/vscode-remote-resource</code>: Need the connection token to see local resources.
<ul>
<li>needs two params <code>path</code> and <code>tkn</code>.</li>
<li><code>tkn</code> should match the connection token otherwise this does not work.</li>
<li><code>path</code> is the local resource path.</li>
</ul>
</li>
</ul>
<div><pre tabindex="0"><code data-lang="ts"><span>// /vscode-remote-resource
</span><span></span><span>if</span> (pathname <span>===</span> <span>&#39;/vscode-remote-resource&#39;</span>) {
    <span>// Handle HTTP requests for resources rendered in the rich client (images, fonts, etc.)
</span><span></span>    <span>// These resources could be files shipped with extensions or even workspace files.
</span><span></span>    <span>if</span> (parsedUrl.query[<span>&#39;tkn&#39;</span>] <span>!==</span> <span>this</span>._connectionToken) {
        <span>return</span> serveError(req, res, <span>403</span>, <span>`Forbidden.`</span>);
    }

    <span>const</span> desiredPath <span>=</span> parsedUrl.query[<span>&#39;path&#39;</span>];
    <span>if</span> (<span>typeof</span> desiredPath <span>!==</span> <span>&#39;string&#39;</span>) {
        <span>return</span> serveError(req, res, <span>400</span>, <span>`Bad request.`</span>);
    }
</code></pre></div><p>We might be able to delay the shutdown of the server and keep it alive by
sending GET requests to <code>http://locahost:port/delay-shutdown</code>. We cannot see the
response but they are sent anyways.</p>
<p>This server is also externally available so we don&#39;t care about CORS. However,
we need to know the connection token to get local resources. Try <code>00000</code> as
token. It might work 😏.</p>
<h2 id="the-vscode-protocol-handler">The vscode Protocol Handler
<a href="#the-vscode-protocol-handler"><svg height="22" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg></a>
</h2><p>VS Code also has a protocol handler: <code>vscode://</code>. It &#34;lets other applications
send URIs to specific extensions.&#34; See <a href="https://code.visualstudio.com/updates/v1_23#_protocol-handler-api" target="_blank" rel="noreferrer noopener">Protocol Handler API</a>.</p>
<p>This means we can do things like <code>vscode://vscode.git/clone?url=foobar</code> to talk
to the <code>vscode.git</code> extension. This has been used to get RCE in the <code>Remote SSH</code>
extension. See <a href="https://www.shielder.it/advisories/remote-command-execution-in-visual-studio-code-remote-development-extension/" target="_blank" rel="noreferrer noopener">CVE-2020-17148</a>.</p>
<p>If someone is not currently running WSL we might be able to run the extension
directly through the protocol handler? I did not look inside the extension code
to see what can be done. The protocol handler must look like
<code>vscode://ms-vscode-remote.remote-wsl/path?param=value</code>.</p>
<p>Thanks for reading and happy holidays! If you have any feedback you know where
to find me!</p>

</div></div>
  </body>
</html>
