<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://osor.io/text">Original</a>
    <h1>Rendering Crispy Text on the GPU</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    

<p>It’s not the first time I’ve fallen down the rabbit-hole of rendering text in real time. Every time I’ve looked into it an inkling of dissatisfaction always remained, either aliasing, large textures, slow build times, minification/magnification, smooth movement, etc.</p>

<p>Last time I landed on a solution using <a href="https://github.com/Chlumsky/msdfgen">Multi-Channel Signed Distance Fields (SDFs)</a> which was working well. However there was still a few things that bothered me and I just needed a little excuse to jump back into the topic.</p>

<p>That excuse came in the form of getting a new monitor of all things. One of those new OLEDs that look so nice, but that have fringing issues because of their non-standard subpixel structure. I got involved in a <a href="https://github.com/microsoft/PowerToys/issues/25595">GitHub issue</a> discussing this and of course posted my <a href="https://github.com/microsoft/PowerToys/issues/25595#issuecomment-1870511297">unrequested take</a> on how to go about it. This was the last straw I needed to go try and implement glyph rendering again, this time with subpixel anti-aliasing.</p>

<p>Just to start things off, here is a test with a bunch of fonts, trying to test the most common styles, rounded, sharp, very thin lines, etc.</p>

<p><img src="https://osor.io/text/lorem_ipsum_high_res.png" alt=""/>
<em>This one is higher resolution, recommended to open in a new tab and visualize at native 100% zoom if possible</em></p>

<p>And a cheeky menu to show it in movement, along with a console and the previously show demo text.</p>



<p>An important <strong>disclaimer</strong> about showing images and videos in this post is that artifacts might show due to minification/magnification, pixel alignment, and even <a href="https://geometrian.com/resources/subpixelzoo/">subpixel structure</a>.</p>



<p>There was a few things that were bothering me about using SDFs, the main ones being:</p>

<h2 id="quality">Quality</h2>

<p>Certain fonts would struggle to render nicely, especially ones with thin features or lots of detail. SDFs represent “blobby” glyphs nicely, and even simple sharp glyphs if you go the multi-channel route. But at some point you need to increase resolution to get rid of the artifacts.</p>

<p>Here you can see an example of Miama switching between SDF and the new method, note how the thin features were often getting lost, as well as how the “f” was struggling due to its size.</p>



<h2 id="atlas-size">Atlas size</h2>

<p>The SDFs are generated offline then stored to an atlas. Even though SDFs require way less resolution for good output quality, you still need something. Especially for fonts with <strong>a lot</strong> of glyphs this was adding up. I even tried some fonts for Japanese and Chinese which I couldn’t realistically bake to a single atlas due to how big they would have been.</p>

<p>Here you can see the atlas for Miama, which even as a font for only Latin languages without that many special characters comes to a resolution of $4096\times1152$ with each glyph taking a $64\times64$ region.</p>

<p><img src="https://osor.io/text/msdf_atlas_example_no_alpha.png" alt=""/></p>

<p>Having multiple fonts available at runtime was adding a significant memory cost and getting them in and out was some significant streaming bandwidth. And the more fonts the bigger the issue.</p>

<h2 id="flexibility">Flexibility</h2>

<p>In general, I found it fiddly to get around issues like minification or implementing new ideas like the subpixel anti-aliasing that kickstarted all this. For a while I also wanted to work with potentially any vector image, which would have required baking, so couldn’t be generated or edited at runtime.</p>

<h2 id="simplicity">Simplicity</h2>

<p>Working with intermediate steps that transform the source data is a raw increase in complexity of the whole system, even if some of that complexity is hidden by some library that could take the glyphs and bake them, it’s still there.</p>

<p>A solution that more directly takes the raw input in the form of the bezier curves that the glyph creator made would be conceptually simpler. Over time I’ve come to appreciate solutions that have less moving parts and where the flow from source data to the desired result is as simple and understandable as possible.</p>



<p><img src="https://osor.io/text/what_now.png" alt=""/></p>

<p>The idea is fairly simple, instead of baking anything to textures, grab the curves that define the <strong>currently visible</strong> glyphs themselves, send them to the GPU and <em>somehow</em> rasterize them. In a way you can see this as moving the necessary rasterization step that previously was offline to be done at runtime.</p>

<p>This would take much less storage compared to the cost per-glyph of a cell in an atlas, it would allow for them to look good at any resolution since we’re rendering the vector representation directly and it would play nice with things like subpixel anti-aliasing, where instead of computing coverage for a single pixel, we’d do it for each of the subpixel elements.</p>

<p>As a very short summary, the solution consist of loading the glyph curve data directly, rasterize them at runtime to an atlas and sample said atlas as required to render the visible glyphs.</p>

<p>The sauce here is keeping glyphs in the atlas as long as they keep being used in subsequent frames. This allows to accumulate and refine the rasterization results, to the extent of getting very high quality sub-pixel anti-aliasing.</p>

<p>I’ll give an overview of the whole pipeline here in execution order. From loading the raw font until they end up on the screen.</p>

<h2 id="processing-the-quadratic-bezier-curves">Processing the Quadratic Bezier Curves</h2>

<p>I’m using <a href="https://freetype.org/">FreeType</a> in an offline tool as an intermediary way to load any of the font formats they support. Then I traverse the curves of each glyph and store them in my asset format that will get passed to the GPU.</p>

<p>The glyphs may contain either <strong>lines</strong>, <strong>quadratic beziers</strong> (3 points) or <strong>cubic beziers</strong> (4 points). To allow for a simpler shader I convert all of these to quadratic beziers.</p>

<p>To transform a <strong>line</strong> to a quadratic bezier is fairly obvious, just create a new control point exactly in the middle of the two existing ones:</p>

<pre><code>// Given the two points for the line
p0 := /*...*/;
p1 := /*...*/;

// Create a new control point in the middle
m := lerp(p0, p1, 0.5);

// And create a quadratic bezier with those
new_curve(p0,m,p1);
</code></pre>

<p>Transforming a <strong>cubic bezier</strong> curve to a quadratic one implies lowering it’s order, which is necessarily a lossy process. In this case I’m choosing to always split the cubic bezier into two quadratics, which works well in all the fonts I’ve tried:</p>

<pre><code>// Given these cubic bezier points
p0 := /*...*/;
p1 := /*...*/;
p2 := /*...*/;
p3 := /*...*/;

// Calculate these extra control points
c0 := lerp(p0, p1, 0.75);
c1 := lerp(p3, p2, 0.75);
m  := lerp(c0, c1, 0.5);

// And create two quadratic bezier curves
new_curve(p0,c0,m);
new_curve(m,c1,p3);
</code></pre>

<p>Here you have a <a href="https://www.desmos.com/calculator/oxeoovjjwk">desmos graph</a> where you can move the points around and see the input cubic bezier and the resulting two quadratic ones.</p>




<p>There’s much more interesting ways to do this split that would reduce the error further, but this works fairly well for the majority of cubic beziers found in the fonts I’ve tried. It’s also possible to use offline tools to do a higher quality transformation into a format that only has quadratic beziers like TrueType (.ttf) which would avoid this transformation altogether.</p>

<p>Here’s some of the points after being loaded, the blue points being the ones that define the beginning and end of the bezier curve (or <em>on</em> points) and the red ones being the middle point of each bezier, defining how it curves (or <em>off</em> points).</p>



<h2 id="calculating-coverage">Calculating Coverage</h2>

<p>Here I’m not doing anything particularly interesting or different than what you might find elsewhere. A ray is shot horizontally, left-to-right on a per-pixel basis, testing against the curves for intersections and accumulating a winding number to see if it’s considered outside (zero) or inside (non-zero). At the end of the day is “just” solving a quadratic equation.</p>

<p>My favorite explanation of the math behind this, with some extra neat diagrams, is in the <a href="https://github.com/GreenLightning/gpu-font-rendering#method">read-me of this GitHub repository by GreenLightning</a> explaining his GPU Font Rendering approach. It would also be a <strong>crime</strong> not to link to <a href="https://www.youtube.com/watch?v=SO83KQuuZvg">Sebastian Lague’s Rendering Text video</a> where he covers the principles behind glyph rasterization and his adventures making his solution better. If you’re interested in the source code as well, both of these links can sort you out.</p>

<p>Something worth mentioning is that there can be issues in this step due to inaccuracies on the intersection computation, as the links above already mention. Since I knew I would be accumulating hundreds of samples over time I chose not to do anything explicitly about that at this stage and this has proven to be the right decision so far.</p>

<p>Most of these inaccuracies happen when the samples are at a very specific height and these <em>can</em> still happen in my implementation. That said, maybe one or two samples out of a few hundreds can have incorrect coverage in the worst case but after averaging these are not visible.</p>

<p>At the time of writing I’m accumulating up to 512 samples per-glyph if it stays on screen. If a single sample goes wrong, that means that the pixel is outputting $1/512=0.00195$ or $511/512=0.99804$ instead of $0$ and $1$ respectively which is imperceptible in practice. Furthermore, you could have a threshold where you clamp to the extremes if the coverage is close, making these $0.002$ and $0.998$ be evaluated as $0$ and $1$ respectively.</p>

<p>For completeness, here’s the code to compute the coverage. It iterates over a bitset to access the relevant curves of the glyph and computes a winding number to then transform it to a coverage value. For a reference about how to compute the winding number I refer you again to <a href="https://github.com/GreenLightning/gpu-font-rendering#method">GreenLightning’s repository</a> who explains it wonderfully and provides sample code.</p>

<div><div><pre><code><span>u32</span> <span>words</span><span>[</span><span>GLYPH_CURVE_WORD_COUNT</span><span>]</span> <span>=</span> <span>/* . . . */</span> <span>// Bitset marking which curves are relevant for this texel</span>

<span>uint4</span> <span>addend</span> <span>=</span> <span>0</span><span>;</span>
<span>for</span> <span>(</span><span>int</span> <span>tick_offset</span> <span>=</span> <span>0</span><span>;</span> <span>tick_offset</span> <span>&lt;</span> <span>parameters</span><span>.</span><span>tick_increment</span><span>;</span> <span>++</span><span>tick_offset</span><span>)</span>
<span>{</span>
    <span>float2</span> <span>subpixel_offset</span> <span>=</span> <span>quasirandom_float2</span><span>(</span><span>parameters</span><span>.</span><span>tick</span> <span>+</span> <span>tick_offset</span><span>);</span>
    <span>float2</span> <span>pixel_offset_r</span> <span>=</span> <span>lerp</span><span>(</span><span>per_frame</span><span>.</span><span>subpixel_layout</span><span>.</span><span>r_min</span><span>,</span> <span>per_frame</span><span>.</span><span>subpixel_layout</span><span>.</span><span>r_max</span><span>,</span> <span>subpixel_offset</span><span>);</span>
    <span>float2</span> <span>pixel_offset_g</span> <span>=</span> <span>lerp</span><span>(</span><span>per_frame</span><span>.</span><span>subpixel_layout</span><span>.</span><span>g_min</span><span>,</span> <span>per_frame</span><span>.</span><span>subpixel_layout</span><span>.</span><span>g_max</span><span>,</span> <span>subpixel_offset</span><span>);</span>
    <span>float2</span> <span>pixel_offset_b</span> <span>=</span> <span>lerp</span><span>(</span><span>per_frame</span><span>.</span><span>subpixel_layout</span><span>.</span><span>b_min</span><span>,</span> <span>per_frame</span><span>.</span><span>subpixel_layout</span><span>.</span><span>b_max</span><span>,</span> <span>subpixel_offset</span><span>);</span>

    <span>float2</span> <span>uv_r</span> <span>=</span> <span>(</span><span>local_texel_coordinates_subpixel</span> <span>+</span> <span>pixel_offset_r</span><span>)</span> <span>/</span> <span>parameters</span><span>.</span><span>size_in_pixels</span><span>;</span>
    <span>float2</span> <span>uv_g</span> <span>=</span> <span>(</span><span>local_texel_coordinates_subpixel</span> <span>+</span> <span>pixel_offset_g</span><span>)</span> <span>/</span> <span>parameters</span><span>.</span><span>size_in_pixels</span><span>;</span>
    <span>float2</span> <span>uv_b</span> <span>=</span> <span>(</span><span>local_texel_coordinates_subpixel</span> <span>+</span> <span>pixel_offset_b</span><span>)</span> <span>/</span> <span>parameters</span><span>.</span><span>size_in_pixels</span><span>;</span>

    <span>float2</span> <span>em_r</span> <span>=</span> <span>lerp</span><span>(</span><span>glyph</span><span>.</span><span>bbox_em_top_left</span><span>,</span> <span>glyph</span><span>.</span><span>bbox_em_bottom_right</span><span>,</span> <span>uv_r</span><span>);</span>
    <span>float2</span> <span>em_g</span> <span>=</span> <span>lerp</span><span>(</span><span>glyph</span><span>.</span><span>bbox_em_top_left</span><span>,</span> <span>glyph</span><span>.</span><span>bbox_em_bottom_right</span><span>,</span> <span>uv_g</span><span>);</span>
    <span>float2</span> <span>em_b</span> <span>=</span> <span>lerp</span><span>(</span><span>glyph</span><span>.</span><span>bbox_em_top_left</span><span>,</span> <span>glyph</span><span>.</span><span>bbox_em_bottom_right</span><span>,</span> <span>uv_b</span><span>);</span>

    <span>float3</span> <span>winding_number</span> <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> <span>word_index</span> <span>=</span> <span>0</span><span>;</span> <span>word_index</span> <span>&lt;</span> <span>GLYPH_CURVE_WORD_COUNT</span><span>;</span> <span>++</span><span>word_index</span><span>)</span>
    <span>{</span>
        <span>u32</span> <span>remaining_bits</span> <span>=</span> <span>words</span><span>[</span><span>word_index</span><span>];</span>
        <span>while</span> <span>(</span><span>remaining_bits</span><span>)</span>
        <span>{</span>
            <span>int</span> <span>bit_index</span> <span>=</span> <span>firstbitlow</span><span>(</span><span>remaining_bits</span><span>);</span>
            <span>int</span> <span>local_curve_index</span> <span>=</span> <span>(</span><span>word_index</span> <span>*</span> <span>32</span><span>)</span> <span>+</span> <span>bit_index</span><span>;</span>
            <span>remaining_bits</span> <span>^=</span> <span>(</span><span>1u</span> <span>&lt;&lt;</span> <span>bit_index</span><span>);</span>
            <span>int</span> <span>global_curve_index</span> <span>=</span> <span>glyph</span><span>.</span><span>curve_offset</span> <span>+</span> <span>local_curve_index</span><span>;</span>
            <span>int</span> <span>first_point_index</span> <span>=</span> <span>global_curve_index</span> <span>*</span> <span>2</span><span>;</span>
            <span>{</span>
                <span>float2</span> <span>p0</span> <span>=</span> <span>point_buffer</span><span>[</span><span>first_point_index</span><span>];</span>
                <span>float2</span> <span>p1</span> <span>=</span> <span>point_buffer</span><span>[</span><span>first_point_index</span> <span>+</span> <span>1</span><span>];</span>
                <span>float2</span> <span>p2</span> <span>=</span> <span>point_buffer</span><span>[</span><span>first_point_index</span> <span>+</span> <span>2</span><span>];</span>
                <span>winding_number</span><span>.</span><span>r</span> <span>+=</span> <span>compute_winding_number</span><span>(</span><span>p0</span><span>,</span> <span>p1</span><span>,</span> <span>p2</span><span>,</span> <span>em_r</span><span>);</span>
                <span>winding_number</span><span>.</span><span>g</span> <span>+=</span> <span>compute_winding_number</span><span>(</span><span>p0</span><span>,</span> <span>p1</span><span>,</span> <span>p2</span><span>,</span> <span>em_g</span><span>);</span>
                <span>winding_number</span><span>.</span><span>b</span> <span>+=</span> <span>compute_winding_number</span><span>(</span><span>p0</span><span>,</span> <span>p1</span><span>,</span> <span>p2</span><span>,</span> <span>em_b</span><span>);</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>float3</span> <span>coverage</span> <span>=</span> <span>saturate</span><span>(</span><span>winding_number</span><span>);</span>
    <span>addend</span> <span>+=</span> <span>uint4</span><span>(</span><span>coverage</span><span>,</span> <span>1</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>This <code><span>addend</span></code> simply gets added to the previous value on for that texel on the atlas, which will be explained later.</p>

<p>For the <code><span>quasirandom_float2</span></code> I’m using the fantastic <a href="https://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">$R_2$ sequence presented in by Martin Roberts</a>. In <a href="https://www.shadertoy.com/view/4dtBWH">this shadertoy</a> you can see how it distributes the sample points to provide some very good coverage over time.</p>

<h2 id="accelerating-curve-access">Accelerating Curve Access</h2>

<p>A good optimization to make here is to split the glyph in some horizontal bands and store which curves of the glyph touch each band. The rasterization code is tracing only horizontally, so with this we can massively reduce the set of curves that each texel will have to test against. To do this I have a bunch of bits per-band per-glyph that represent which local curves to the glyph are present in the band.</p>

<p>Here is a visualization of which curves are on the different bands, highlighted in yellow. You can imagine how a ray traced from left to right of the glyph can just intersect the relevant curves.</p>



<p>You get some great wins by having each texel loop over the curves relevant for that band. However, this can be made faster by accessing bands uniformly per-wave, meaning that all the code that handles iterating over curves can be scalarized, and so are the curve reads (meaning they can happen once per-wave and not once per-thread on the wave). That would look something like this:</p>

<div><div><pre><code><span>int</span> <span>this_thread_band_index</span> <span>=</span> <span>clamp</span><span>(</span><span>int</span><span>(</span><span>floor</span><span>(</span><span>uv_y</span> <span>*</span> <span>BAND_COUNT</span><span>)),</span> <span>0</span><span>,</span> <span>BAND_COUNT</span><span>-</span><span>1</span><span>);</span>
<span>min_band_index</span> <span>=</span> <span>WaveActiveMin</span><span>(</span><span>this_thread_band_index</span><span>);</span>
<span>max_band_index</span> <span>=</span> <span>WaveActiveMax</span><span>(</span><span>this_thread_band_index</span><span>);</span>
<span>for</span> <span>(</span><span>int</span> <span>band_index</span> <span>=</span> <span>min_band_index</span><span>;</span> <span>band_index</span> <span>&lt;=</span> <span>max_band_index</span><span>;</span> <span>++</span><span>band_index</span><span>)</span>
<span>{</span>
    <span>/* . . . Add the curves for this band to be intersected against . . . */</span>
<span>}</span>
</code></pre></div></div>

<p>And since I’m rasterizing this in compute into an atlas, I can decide which texel each thread is writing to, so I reorganize the threads to be packed horizontally, in row-major order, so the range of bands that each wave touches is minimized compared to other indexing methods like “classic” quads or Morton codes. Here is an example of how the threads are distributed. Using a $9\times11$ glyph and 16-thread waves for simplicity:</p>

<p><img src="https://osor.io/text/wave_distribution.png" alt=""/></p>

<p>To distribute the threads like this would be as simple as:</p>

<div><div><pre><code><span>int2</span> <span>total_texel_size</span> <span>=</span> <span>parameters</span><span>.</span><span>texel_bottom_right</span> <span>-</span> <span>parameters</span><span>.</span><span>texel_top_left</span><span>;</span>
<span>int2</span> <span>local_texel_coordinates_raw</span> <span>=</span> <span>int2</span><span>(</span><span>thread_id</span> <span>%</span> <span>total_texel_size</span><span>.</span><span>x</span><span>,</span> <span>thread_id</span> <span>/</span> <span>total_texel_size</span><span>.</span><span>x</span><span>);</span>
<span>if</span> <span>(</span><span>any</span><span>(</span><span>local_texel_coordinates_raw</span> <span>&gt;</span> <span>total_texel_size</span><span>))</span>
<span>{</span>
    <span>return</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<h2 id="atlas-packing">Atlas Packing</h2>

<p>I started by rasterizing to the screen directly, however computing high quality anti-aliasing every frame as they were being output to the final target was a significant cost.</p>

<p>Thinking about how to get around this it also became obvious that most rendered text stays on screen for many frames, with the same size and position, even as you’re reading this you’re probably not scaling the text, or smoothly scrolling.</p>

<p>Besides this, the same glyph will often appear more than once on screen at the exact same size (just look at how many “e”s there are in this sentence alone). So why bother rendering it multiple times? (Subpixel positioning is a thing and we’ll go back to that later)</p>

<p>So I grabbed the two most well-worn tools in the graphics tool belt, <em>atlases</em> and <em>temporal accumulation</em>.</p>



<p>The idea here is to have an atlas that packs the glyphs reasonably well, if a glyph we want is not on the atlas, we allocate a chunk of it and start rasterizing into it, if a glyph we want is already there, we just use it. At some point in the frame we go over al the glyphs in the atlas and decide whether we keep it (and maybe refine it with more samples) or if it’s not being used and we should free that space.</p>

<p>The atlas will keep in-use glyphs resident all the time, so if text on the screen hasn’t changed for a while, we have nothing to compute there, all the glyphs are ready and we just slap them onto the screen later. There is a cost of adding new glyphs, but we can spread this cost over many frames as we’ll discuss later.</p>

<p>Some notes about this, the inputs to the atlas do have to take a couple things into account that might not be immediately obvious. At the time of writing, if we equate this atlas to a hash-map, the “key” is the following:</p>

<pre><code>Glyph_Key :: struct
{
    font : Font;
    glyph_index : int;

    // u24.8 fixed point
    quantized_size_in_pixels_x : u32;
    quantized_size_in_pixels_y : u32;

    // u0.8 fixed point
    quantized_subpixel_offset_x : u8;
    quantized_subpixel_offset_y : u8;
}
</code></pre>

<p>The font, index of the glyph inside the font and the size are somewhat expected. We also need the subpixel offset though, which is the fractional of the pixel position (as in <code><span>frac</span><span>(</span><span>pixel_position</span><span>)</span></code>). You might want to place the glyph at any position on the screen, not necessarily aligned with the pixel grid, or you might want to smoothly move text (e.g. scrolling). If we didn’t take this into account, then all the anti-aliasing we’re doing would only be valid for a single subpixel position.</p>

<p>Note the usage of fixed point too. This helps collapsing nearby fractional positions and sizes to the same values. Using floating point directly would often generate different values bit-wise, even if mathematically they should have been the same. Using 8 bits for the fractional part offers more than enough resolution for smooth positions and sizes. If moving a single of this $1/256$ increments within the pixel changed the resulting value it would often be displayed in 8 bits per-component render targets or monitor outputs.</p>

<p>That said, you <em>could</em> decide that this is a trade-off you’re willing to make and say that all of your glyphs should be positioned on a pixel boundary. In my experience, slowly moving text looks awful this way since you see it jump from integer pixel boundary to pixel boundary. I wanted to use this as my solution for all text so it’s not something I went for.</p>

<p>Here you can see a comparison between subpixel positioning, aligned to the pixel grid and aligned to a half-resolution pixel grid to simulate seeing this in a monitor that’s half the resolution than the one you’re using.</p>



<p>Zooming into the 1-pixel aligned word makes the stepping even more obvious.</p>



<p>Where if we let the glyphs fall in subpixel positions the movement is dramatically smoother.</p>



<p>That said, it’s still possible to optimize for cases where you know you will do a lot of static text, for example, if you’re doing a text editor and want to use a monospaced font you can force the spacing between characters to be rounded to pixel boundaries. This way every glyph will have the same subpixel offset and always hit the atlas cache for the same glyph.</p>

<p>If also aligning the line breaks to the output pixel grid you get even better reuse, since the same glyphs in a monospaced font in different lines will also hit the same entry on the atlas. See how only new glyphs in the block of text allocate a new entry.</p>



<h3 id="z-order">Z-Order</h3>

<p>A great way I found to place the glyphs somewhat nicely packed at runtime was to use Z-Order Packing and a bitset for free cells within the atlas.</p>

<p>Z-Order curves (via Morton codes) allows you to think of the cells as a long 1D array, allocating a contiguous slice of this 1D array will give you a square in the resulting 2D atlas as long as you’re allocating a power of two number of cells.</p>

<p>A free bit in the bitset represents a free cell, in this case a $16\times16$ texel cell.</p>

<p>When a glyph wants to find a spot, it rounds up its size to the next power of two, so a glyph that needs a $25\times29$ will end up allocating a chunk that’s $32\times32$. This would require 4 $16\times16$ cells, so it’ll look for 4 contiguous free bits and set them, then return the 2D location of that first free cell using Morton codes to go from 1D to 2D.</p>

<p>Note that these contiguous bits also have to be aligned to the number of bits, that is, if looking for 4 free bits, those could start in index 0, 4, 8, 12, etc. If the free bits went from bit 3 to bit 6, when looking at those 4 cells they wouldn’t form a contiguous square.</p>

<p>The code would look something like this:</p>

<pre><code>size := /*...*/

max_size_dimension := max(size.x, size.y);
aligned_size := max(BASE_SLOT_SIZE, align_to_next_power_of_2(max(max_size_dimension, 0)));
slot_size := aligned_size / BASE_SLOT_SIZE;
bits_needed := slot_size * slot_size;
assert(is_power_of_2(bits_needed));

index := find_free_contiguous_bits_aligned(bitset, bits_needed);

base_slot_coordinates := decode_morton2_16(xx index);
top_left_texel_coordinates := base_slot_coordinates * BASE_SLOT_SIZE;
</code></pre>

<p>And here there’s a visualization of the order the glyphs go in as well as what happens when some of they get removed and those free cells get reused for future glyphs if they fit.</p>



<h3 id="transposing-z-order">Transposing Z-Order</h3>

<p>The eagle eyed among you that have worked with Z-Order in 2D before might have noticed that this is packing in a transposed Z-Order (so… mirrored N-Order?).</p>

<p>This is because most long and thin glyphs that use the Latin alphabet are vertical, and transposing Z-Order allows to allocate two cells together to form a vertical rectangular section. This makes glyphs for stuff like “l”, “j”, “i” or “1” take half the space.</p>

<p>That said, in cases where most long and thin glyphs are horizontal, for example most of the Arabic languages, the standard Z-Order is more suited.</p>

<p>To do this the code above would be modified to not just use the maximum size of each dimension when calculating the <code><span>bits_needed</span></code>.</p>

<pre><code>aligned_size := ixy(max(cast(s32)BASE_SLOT_SIZE, align_to_next_power_of_2(max(size.x, 0))),
                    max(cast(s32)BASE_SLOT_SIZE, align_to_next_power_of_2(max(size.y, 0))));
slot_size := aligned_size / BASE_SLOT_SIZE;
slot_size.y = max(slot_size.x, slot_size.y);
slot_size.x = max(slot_size.x, slot_size.y / 2);
bits_needed := slot_size.x * slot_size.y;
assert(is_power_of_2(bits_needed));
</code></pre>

<p>And transposing the final coordinates is simply swapping the result.</p>

<pre><code>base_slot_coordinates := decode_morton2_16(xx index);
base_slot_coordinates.x, base_slot_coordinates.y = base_slot_coordinates.y, base_slot_coordinates.x;
top_left_texel_coordinates := base_slot_coordinates * BASE_SLOT_SIZE;
</code></pre>

<p>Here you can see the same demo but allocating glyphs that are double the height.</p>



<h2 id="temporal-accumulation">Temporal Accumulation</h2>

<p>Glyphs staying in the atlas allows to keep throwing samples at them and refine the results further. This way the final result can have very high quality anti-aliasing without having to cast a significant amount of samples when the glyph just appears.</p>

<p>Let’s look at the intro video slowed down and with a full black background to better visualize the glyph output. Also using the Nacelle typeface on its ultra-light variant, to better show thin features.</p>



<p>Even in this slowed-down case it’s hard to see the glyphs visibly refining as you’re reading the text since the results are already fairly high quality. The trick here is that every glyph that first appears gets 8 samples-per-pixel on that first frame, then 4 samples next frame, then 2 and finally 1 every frame afterwards until it reaches a total of 512 samples.</p>

<p>This guarantees a pretty good quality when a glyph first shows up, which is important on smoothly moving or resizing glyphs. Since they do the equivalent of getting initialized every frame.</p>

<p>Another factor that makes this looks better is subpixel anti-aliasing, which will be touched upon in a further section.</p>

<p>When disabling this and just doing a single sample per-pixel every frame, with no subpixel anti-aliasing the slowed down results are as follows.</p>



<p>It’s more obvious how samples keep getting added. Also very interesting how the glyphs appear to shift in positioning. That’s because the initial samples are not at the center of the pixel. That’s fixed by placing the initial samples optimizing for this case, but that’d defeat part of the point of this visualization.</p>

<p>Even in this case, with a single sample and the shifting text it’s still not as dramatically visible as I would have imagined, showcasing how well the refinement idea and temporal accumulation works in principle.</p>

<p>Zooming in on a word in particular demonstrates how on the first frame the glyph has no anti-aliasing at all and the results are either black or white, then it keeps refining and shifting position until getting to a better final result with a few dozen samples.</p>



<p>And for completeness, with all the quality optimizations on, starting with 8 samples and with subpixel anti-aliasing that word looks like this.</p>



<p>This system is also easily tunable to achieve the required levels of quality and performance. Some of the knobs to twist would be:</p>

<ul>
  <li>How many samples/rays to add every frame.</li>
  <li>Increase samples on the first few frames of a glyph or not.</li>
  <li>Having a cap of “total samples” allowed per-frame to keep cost bounded.</li>
  <li>Time-slice the update of existing glyphs, that is, adding samples every few frames instead of every frame.</li>
</ul>

<p>Another note is that the cost of casting a ray scales linearly with the amount of curves it’s going to have to intersect for a given glyph. So for more precise cost-gating it might be worth to use that as a metric instead. Meaning that you’d allow to do a certain number of intersected curves per-frame.</p>

<p>It’s worth mentioning that performance hasn’t been a concern in my experience with this system so far. The full-screen of text of the intro peaks at about 0.1 milliseconds in my 9070 at 4k. And that cost quickly tapers down to zero when glyphs have reached the max number of samples (set at the time of writing to 512 but can be easily lowered).</p>

<p>Overall this system works <em>shockingly</em> well. Most text presented to users often stays on screen completely static, which lets it converge to high quality. Even as it shows up, the speed at which we look at words and read them is orders of magnitude slower that the time it takes a glyph to look very good. In general, I’ve found it imperceptible that the text is converging over time while at the same time it always looks nicely anti-aliased.</p>

<h2 id="subpixel-anti-aliasing-and-fringing">Subpixel Anti-Aliasing and Fringing</h2>

<p>The gist of subpixel anti-aliasing is start thinking of the individual red, green and blue subpixel elements that for your monitor pixel as individual sample points, or rather, sample areas. Roughly you can consider the subpixel elements to be the actual “pixels” you want to render into.</p>

<p>In a traditional RGB LCD layout like the following, your horizontal resolution effectively triples. In traditional 4k you’d go from $3840\times2160$ to $3840\times6480$.</p>

<p><img src="https://osor.io/text/subpixel_zoo_rgb_structure.png" alt=""/>
<em>Image from <a href="https://geometrian.com/resources/subpixelzoo/">Subpixel Zoo</a></em></p>

<p>Getting all this effective resolution is great! And since the light is getting mixed from neighboring pixels, there’s no reason to get bad color fringing.</p>

<p>As I’ve already hinted at though, the monitor I’m using is far from this 3 vertical stripes of red, green and blue, and looks like this instead.</p>

<p><img src="https://osor.io/text/rtings_subpixel_layout_oled_g9.jpg" alt=""/>
<em>Image from <a href="https://www.rtings.com/monitor/reviews/samsung/odyssey-oled-g9-g95sc-s49cg95">RTings Review of Oled G9</a></em></p>

<p>Which causes problematic fringing. And this is far from being the worst case out there, with monitors having wild arrangements like some of the ones you can see in <a href="https://geometrian.com/resources/subpixelzoo/">Subpixel Zoo</a>. A notorious recent one is <a href="https://github.com/microsoft/PowerToys/issues/25595#issuecomment-1512405626">LG WOLED having a red-white-blue-green</a> structure, so it has an extra white-only subpixel and has the green and blue ones swapped from the standard order.</p>

<p>To show a more direct comparison on my current monitor. A default red-green-blue subpixel structure made of equal vertical rectangles would look like this. With very visible green fringing on top and magenta at the bottom.</p>

<p><img src="https://osor.io/text/text_with_fringing.png" alt=""/></p>

<p>Whereas if I set the subpixel structure on the solution presented in this article to match the one on my monitor it looks like this. Where even with subpixel anti-aliasing on there’s next to no fringing while keeping a very smooth result.</p>

<p><img src="https://osor.io/text/text_without_fringing.png" alt=""/></p>

<p>The big payoff! Finally rendering good looking text with subpixel anti-aliasing and no color fringing.</p>

<p>To achieve this I’ve set up a little editor where I could play with the subpixel elements position, the inner white square is the pixel, and each of the colored quads represent where I’m sampling the results of each subpixel element. Note that it’s going out of bounds of the pixel, which I’ll touch on in the next section.</p>

<p><img src="https://osor.io/text/subpixel_antialiasing_oled.png" alt=""/></p>

<p>If zooming in you can see how most of those pixels we’re sending to the monitor are not white, in fact there’s very few that are $RGB(1,1,1)$.</p>

<p><img src="https://osor.io/text/subpixel_antialiasing_zoomed.png" alt=""/></p>

<p>But when they’re outputting on the monitor, light from all the subpixels blends in such a way that the result is a smooth white output. Getting the desired anti-aliasing effect and better representing the intended shape of the glyph.</p>

<p><img src="https://osor.io/text/subpixel_antialiasing_zoomed_monitor_picture.png" alt=""/></p>

<p>Note that a lot of these features are only one to one-and-a-half pixels wide. They also often fall in-between pixel cells since I’m not doing any <a href="https://learn.microsoft.com/en-us/typography/truetype/hinting">hinting</a>. This is picked on purpose as a hard example for the renderer to handle and to show the effectiveness of good subpixel anti-aliasing.</p>

<h3 id="overlapping-subpixels">Overlapping Subpixels</h3>

<p>As I was trying to match my subpixel structure I’ve found that overlapping the subpixel elements would give more accurate results. Which intuitively makes sense since light naturally mixes and diffuses slightly from the subpixel elements, so the sampled area for a given subpixel will be larger than the subpixel itself physically is. Almost behaving like a tiny point light.</p>

<p>So naturally you might expect a setup like this.</p>

<p><img src="https://osor.io/text/subpixel_antialiasing_rgb.png" alt=""/></p>

<p>However letting the subpixel elements overlap each other gives better results. Also here you can see two examples of a “classic” LCD subpixel arrangement. If you’re seeing this on a screen with this arrangement it’s probably the best quality anti-aliasing you’d see in this whole article. Because all the other captures have been done with my monitor’s subpixel structure arrangement.</p>

<p><img src="https://osor.io/text/subpixel_antialiasing_rgb_expanded.png" alt=""/></p>

<p>Note that the areas also should bleed outside the pixel itself because they are surrounded by (normally) identical pixels with identical subpixel elements. Light is not only bleeding and mixing with the light from a single pixel, but also with the neighboring subpixels.</p>

<p>As I was writing this article I found the <a href="https://medium.com/@evanwallace/easy-scalable-text-rendering-on-the-gpu-c3f4d782c5ac">Easy Scalable Text Rendering article by Evan Wallace</a> which suggests needing to blur horizontally after rendering with subpixel anti-aliasing. Interestingly this is effectively the same thing as considering the subpixel elements themselves to be bigger and overlapping.</p>



<p>I <em>really</em> wish that having access to arbitrary subpixel structures of monitors was possible, perhaps given via the common display protocols. This would enhance subpixel anti-aliasing in general and text specifically, even in monitors that have “standard” orders, since you can be more fine-grained for the specific hardware.</p>

<p>This would also give freedom to display manufacturers to not have to fear trying an otherwise better subpixel structure because of issues with text rendering. Samsung changed their subpixel structure on QD-OLED to try to minimize issues like this from G8 to G9. And still on LG’s WOLED and Samsung’s QD-OLED fringing is commonly cited as one of the most notorious problems on monitors that use them.</p>

<p>It’s is just software, we can fix this, they shouldn’t be forced to change hardware to account for the failures of software.</p>



<p>Good user interfaces and especially great text is a soft spot of mine. It has the potential to carry the perceived quality of a product to an degree that’s sometimes underrated. A prime example of this is the fantastic work that Atlus consistently puts out in the <a href="https://www.youtube.com/watch?v=4d6x1CIgLSc">Persona</a> series or more recently <a href="https://www.youtube.com/watch?v=L4ypdFi8zo8">Metaphor: ReFantazio</a>. I also have to mention <a href="https://www.youtube.com/watch?v=BhNoX5F81iw">Nier: Automata</a> as a personal favorite.</p>

<p>And it makes sense! Games will often present you with text that’s meant to grab your attention. When a text box, a menu, a title, an announcement or anything in-between shows up in a game there’s an implied focus point put on it. It looking sub-par can impact the experience as much as a badly rendered 3D scene would. So it follows that this aspect of the presentation should get their fair share of love as well.</p>

<p>I hope you’ve found this useful! I’d love to see more attempts to make glyph rendering in real time better and in this fashion I wish this comes across as a good motivator for more people to go tackle this.</p>

<p>As always, if you have any comments or there’s any questions please reach out! You can find me in most places as some variation of “osor_io” or “osor-io” as well as with the links at the bottom of the page.</p>

<p>Cheers! 🍻</p>

<!-- # References -->

<!--

Useful ffmpeg commands to turn a bunch of frames into a video

- General when recorded at 60fps:
    ffmpeg -framerate 60 -i "swapchain_copy_%d.png" -pix_fmt yuv420p -crf 1 video_crf_1.mp4

- To crop and zoom:
    ffmpeg -framerate 3 -start_number 112 -i "swapchain_copy_%03d.png" -vf "crop=98:30:185:175,scale=iw*8:ih*8:flags=neighbor" -pix_fmt yuv420p -crf 1 video_crf_1.mp4

-->

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
