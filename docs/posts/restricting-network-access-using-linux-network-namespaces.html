<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.sigma-star.at/post/2023/05/sandbox-netns/">Original</a>
    <h1>Restricting network access using Linux Network Namespaces</h1>
    
    <div id="readability-page-1" class="page"><div>
      
<div>
  


  <main class="page" data-page-type="md">
    <article>

    
    <p>07.05.2023</p>

    
<p>Our <a href="https://blog.sigma-star.at/post/2023/03/sandbox-mountns/" title="Restricting file system access using Linux Mount Namespaces">last blog post</a> explored ways to restrict access to the file system using Linux mount namespaces. In this post, we’ll show you how to restrict access to the network using Linux’s network namespaces. That’s basically a new instance of the Linux network stack. By default a new network namespace contains no network interfaces except a new instance of the loopback interface.
The main use cases are Linux containers: Network namespaces allow a container having its own network configuration without the risk of compromising the host.</p>
<h2 id="the-baseline">The Baseline</h2>
<p>Consider a requirement where an application needs to ensure that it can no longer access the network or establish new connections. One way to achieve this is by creating a new network namespace.</p>
<p>When the application creates a new network namespace, it can no longer access the network nor the host itself. Access is not denied by the namespace mechanisms themselves, but by the way networking works. There is no network interface to the outside world; all the namespace has is a loopback interface. To connect the network namespace to the outside world the application either has to set up a virtual ethernet connection or move a physical network interface into the namespace. This is usually done by container engines and is a privileged operation. By not doing so, the application is network-wise isolated.</p>
<h2 id="network-namespaces">Network Namespaces</h2>
<p><img src="https://blog.sigma-star.at/post/2023/05/sandbox-netns/ns.png" alt="An example of multiple network namespaces" title="An example of multiple network namespaces"/></p>
<p>Similar to mount namespaces, creating a network namespace requires the <code>CAP_SYS_ADMIN</code> capability. Therefore, an unprivileged application must first create a new user namespace to be able to create a network namespace.  For simple unprivileged applications, utilizing the <code>unshare()</code> system call is good enough to create a new user and network namespace to disassociate itself from the network. Thus, a call like <code>unshare(CLONE_NEWNET | CLONE_NEWUSER)</code> is sufficient for unprivileged applications to isolate itself from the network. While the application has all capabilities in the freshly created user namespace and can alter the new network namespaces as it wishes, it has no way to establish a virtual network connection to the parent namespace, nor can it re-enter the parent namespace.
This is because it has no capabilities on the host side (the parent namespaces in this case).</p>
<p>If the application is privileged (i.e., it has <code>CAP_SYS_ADMIN</code> and <code>CAP_NET_ADMIN</code>) then it is crucial to drop privileges inside the new user namespace to avoid escape.
Dropping capabilities is usually something you would do with the help of libcap or libcap-ng.
Here, we’re using libcap-ng.</p>
<p>The following lines of code outline the needed steps to create a new network namespace and drop privileges.</p>
<div><pre><code data-lang="C"><span>assert</span><span>(</span><span>unshare</span><span>(</span><span>CLONE_NEWUSER</span> <span>|</span> <span>CLONE_NEWNET</span><span>)</span> <span>==</span> <span>0</span><span>);</span>

<span>assert</span><span>(</span><span>capng_lock</span><span>()</span> <span>==</span> <span>0</span><span>);</span>
<span>capng_clear</span><span>(</span><span>CAPNG_SELECT_BOTH</span><span>);</span>
<span>assert</span><span>(</span><span>capng_apply</span><span>(</span><span>CAPNG_SELECT_BOTH</span><span>)</span> <span>==</span> <span>0</span><span>);</span>
<span>assert</span><span>(</span><span>prctl</span><span>(</span><span>PR_SET_NO_NEW_PRIVS</span><span>,</span> <span>1</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>)</span> <span>==</span> <span>0</span><span>);</span>
</code></pre></div><h2 id="pitfall-loopback-interface">Pitfall: Loopback Interface</h2>
<p>Network namespaces come with one pitfall: By default the loopback interface is set to down state. If your new network namespace will contain applications that communicate via loopback, don’t forget to bring up the loopback interface. Otherwise, you may observe strange failures because most applications blindly assume loopback.</p>
<p>You can try this yourself using the <code>unshare</code> tool in your favorite shell:</p>
<pre><code data-lang="console">$ unshare -Unr
$ ping localhost
connect: Cannot assign requested address
$ ip link set up dev lo
$ ping localhost
PING localhost(localhost (::1)) 56 data bytes
64 bytes from localhost (::1): icmp_seq=1 ttl=64 time=0.055 ms
</code></pre><h2 id="inherited-sockets">Inherited Sockets</h2>
<p>Please note that network namespaces, actually Linux namespaces in general, have no influence on existing file handles. Therefore, if your application possesses a file handle to a socket from another network namespace, it can use it in the new network namespace smoothly.</p>
<p>This is a useful feature as it allows creating network servers that can serve a listening socket but are disconnected from the outside world. If an attacker manages to overtake the application, they are unable to create a new socket to reach destinations outside the sandbox.
<a href="https://blog.sigma-star.at/post/2023/05/sandbox-netns/nonetsrv.c">Here</a> you can find a sample application that outlines the idea.</p>
<h2 id="summary">Summary</h2>
<p>Namespace are not only useful for building containers, but they can also be utilized to restrict access. In this case, we used network namespaces to deny access to the network.
For more details on namespaces, see <a href="https://man7.org/linux/man-pages/man7/namespaces.7.html">namespaces(7)</a>.</p>


    
    
  </article>
  </main>

  


</div>

    </div></div>
  </body>
</html>
