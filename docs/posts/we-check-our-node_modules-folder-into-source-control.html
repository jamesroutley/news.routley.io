<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.jackfranklin.co.uk/blog/check-in-your-node-dependencies/">Original</a>
    <h1>We check our node_modules folder into source control</h1>
    
    <div id="readability-page-1" class="page"><section><time value="">December 6, 2021</time><p>On every team at every company I&#39;ve been at prior to my current role, the advice was simple: don&#39;t check your <code>node_modules</code> folder into your version control system (which I&#39;ll refer to as “Git” for the rest of this article…). This seemed like solid advice for multiple reasons:</p><ul><li>The code within <code>node_modules</code> isn&#39;t authored by the team directly.</li><li>The code within <code>node_modules</code> is often quite large and would cause a lot of noise in git diffs and pull requests.</li><li>The code within <code>node_modules</code> can easily be replicated with an <code>npm</code> install.</li></ul><p>I currently work at Google on the Chrome DevTools team and we check our <code>node_modules</code> folder into source control. At first this struck me as unusual, but I&#39;ve come to believe that there are some major benefits to this approach that I think more people should consider.</p><h2>No need for npm installs</h2><p>Once you check your <code>node_modules</code> in, there&#39;s no need to run an install step before you can get up and running on the codebase. This isn&#39;t just useful for developers locally, but a big boost for any bots you might have running on a Continuous Integration platform (e.g. CircleCI, GitHub Actions, and so on). That&#39;s now a step that the bots can miss out entirely. I&#39;ve seen projects easily need at least 1-2 minutes to run a complete <code>npm install</code> from scratch - and on bots that could be even longer. If you think that a bot runs on every pull request and deploy, you could easily have 50+ bots run each day. That&#39;s a lot of minutes (and bandwidth!) saved.</p><h2>Guaranteed replicated builds</h2><p>Having your <code>node_modules</code> checked in guarantees that two developers running the code are running the exact same code with the exact same set of dependencies. Yes, this can be managed by a package-lock.json file, or other tools, but I&#39;ve seen all of them slip up rarely or allow a slight variation in a minor version number that causes issues. Once the dependencies are in git, you cannot possibly run with anything other than those and each developer will be running the exact codebase.</p><h2>Better awareness of the code you&#39;re shipping</h2><p>I&#39;ve been surprised at how more aware I am of adding dependencies when the git diff shows me the entirety of the code that is being added to the project. This has lead us to make contributions to tools to help reduce their file size on disk and have a better awareness of the impact a dependency will have on our bundle size.</p><h2>More consideration to adding a dependency because it&#39;s not invisible</h2><p>I mentioned earlier that people see the noise in a git diff as a downside to adding dependencies to version control, and I do acknowledge that it can be a downside to this approach, but I&#39;ve found that noise to often be a useful signal. Adding that one extra dependency because I don&#39;t want to write a few lines of code myself is something I used to do frequently - but now I&#39;m much more considered because I can see the code that&#39;s being added and can reflect on if it&#39;s worth it.</p><p><em>Note: this doesn&#39;t mean that we don&#39;t have dependencies!</em> There are times where it is worth it to add a dependency - but seeing the code in version control has made me more considered about doing it - the cost is no longer invisible.</p><h2>You can manage the large diffs</h2><p>There is no shying away from the fact that if a developer works on a change that adds a new dependency, there could be a lot of noise in the diff. One of our dependencies that we check in is TypeScript, and every time we update that, the git diff is huge and frankly not worth looking at (beyond the CHANGELOG). We&#39;ve come up with a rule that helps us here: a change that updates <code>node_modules</code> may not touch any other code in the codebase. So if I update <code>node_modules/typescript</code> with its latest version, I will be warned by our tooling if any other folder outside of <code>node_modules</code> is changed.</p><p>This rule serves us well the majority of the time, because any work that relies on a new or updated dependency can be split into two changes:</p><ol><li>Update the dependency</li><li>Use the dependency in the code</li></ol><p>There are times where this doesn&#39;t work; updating TypeScript may require us to update some code to fix errors that the new version of TypeScript is now detecting. In that case we have the ability to override the rule.</p><blockquote><p>As with anything in software engineering, most &#34;rules&#34; are guidelines, and we&#39;re able to side-step them when required.</p></blockquote><h2>Protection from another left pad</h2><p>The <a href="https://qz.com/646467/how-one-programmer-broke-the-internet-by-deleting-a-tiny-piece-of-code/">now infamous left_pad incident</a>, where a popular npm package was removed from the repository all of a sudden, causing builds everywhere to break, would not have impacted a team who checked all their dependencies into git. They would still have to deal with the long term impact of &#34;what do we do with this now unsupported dependency&#34;, but in the short term their builds wouldn&#39;t break and they wouldn&#39;t be blocked on shipping new features.</p><h2>Conclusion</h2><p>If I was starting a new codebase this week, or joining a small start-up just getting their first version off the ground, I would advocate strongly for checking <code>node_modules</code> into version control. It absolutely takes some getting used to, but in my experience over the last two years of working this way the benefits I&#39;ve listed above strongly outweigh the additional git noise and slight overhead.</p></section></div>
  </body>
</html>
