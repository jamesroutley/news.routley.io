<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nolanlawson.com/2022/05/21/the-balance-has-shifted-away-from-spas/">Original</a>
    <h1>The balance has shifted away from SPAs</h1>
    
    <div id="readability-page-1" class="page"><div>
				<p>There’s a feeling in the air. A zeitgeist. <abbr title="Single-Page Apps">SPAs</abbr> are no longer the cool kids they once were 10 years ago.</p>
<p>Hip new frameworks like <a href="https://astro.build/">Astro</a>, <a href="https://qwik.builder.io/docs/overview">Qwik</a>, and <a href="https://elderguide.com/tech/elderjs/">Elder.js</a> are touting their <abbr title="Multi-Page App">MPA</abbr> capabilities with “0kB JavaScript by default.” Blog posts are making the rounds listing <a href="https://dev.to/tigt/routing-im-not-smart-enough-for-a-spa-5hki">all the challenges</a> with SPAs: history, focus management, scroll restoration, Cmd/Ctrl-click, memory leaks, etc. <a href="https://williamkennedy.ninja/javascript/2022/05/03/in-defence-of-the-single-page-application/">Gleeful potshots</a> are being taken against SPAs.</p>
<p>I think what’s less discussed, though, is how the context has changed in recent years to give MPAs more of an upper hand against SPAs. In particular:</p>
<ol>
<li>Chrome implemented <a href="https://developer.chrome.com/blog/paint-holding/">paint holding</a> – no more “flash of white” when navigating between MPA pages. (<a href="https://twitter.com/xeenon/status/1125981836591620097">Safari already did this.</a>)</li>
<li>Chrome implemented <a href="https://web.dev/bfcache/">back-forward caching</a> – now all major browsers have this optimization, which makes navigating back and forth in an MPA almost instant.</li>
<li>Service Workers – once experimental, now effectively <a href="https://caniuse.com/serviceworkers">100% available</a> for those of us targeting modern browsers – allow for offline navigation without needing to implement a client-side router (and all the complexity therein).</li>
<li><a href="https://github.com/WICG/shared-element-transitions/">Shared Element Transitions</a>, if accepted and implemented across browsers, would also give us a way to animate between MPA navigations – something previously only possible (although difficult) with SPAs.</li>
</ol>
<p>This is not to say that SPAs don’t have their place. Rich Harris has <a href="https://www.youtube.com/watch?v=860d8usGC0o">a great talk</a> on “transitional apps,” which outlines some reasons you may still want to go with an SPA. For instance, you might want an omnipresent element that survives page navigations, such as an audio/video player or a chat widget. Or you may have an infinite-loading list that, on pressing the back button, returns to the previous position in the list.</p>
<p>Even teams that are not explicitly using these features may still choose to go with an SPA, just because of the “unknown” factor. “What if we want to implement navigation animations some day?” “What if we want to add an omnipresent video player?” “What if there’s some customization we want that’s not supported by existing browser APIs?” Choosing an MPA is a big architectural decision that may effectively cut off the future possibility of taking control of the page in cases where the browser APIs are not quite up to snuff. At the end of the day, an SPA gives you full control, and many teams are hesitant to give that up.</p>
<p>That said, we’ve seen a similar scenario play out before. For a long time, jQuery provided APIs that the browser didn’t, and teams that wanted to sleep soundly at night chose jQuery. Eventually browsers caught up, giving us APIs like <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector"><code>querySelector</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/fetch"><code>fetch</code></a>, and jQuery started to seem like unnecessary baggage.</p>
<p>I suspect a similar story may play out with SPAs. To illustrate, let’s consider Rich’s examples of things you’d “need” an SPA for:</p>
<ul>
<li><strong>Omnipresent chat widget:</strong> use Shared Element Transitions to keep the widget painted during MPA navigations.</li>
<li><strong>Infinite list that restores scroll position on back button:</strong> use <a href="https://web.dev/content-visibility/"><code>content-visibility</code></a> and maybe store the state in the Service Worker if necessary.</li>
<li><strong>Omnipresent audio/video player that keeps playing during navigations:</strong> not possible today in an MPA, but who knows? Maybe the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Picture-in-Picture_API">Picture-in-Picture API</a> will support this someday.</li>
</ul>
<p>To be clear, though, I don’t think SPAs are going to go away entirely. I’m not sure how you could reasonably implement something like Photoshop or Figma as an MPA. But if new browser APIs and features keep landing that slowly chip away at SPAs’ advantages, then more and more teams in the future will probably choose to build MPAs.</p>
<p>Personally I think it’s exciting that we have so many options available to us (and they’re all so much better than they were 10 years ago!). I hope folks keep an open mind, and keep pushing both SPAs and MPAs (and “transitional apps,” or whatever we’re going to call the next thing) to be better in the future.</p>
							</div></div>
  </body>
</html>
