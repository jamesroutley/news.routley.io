<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dmitry.gr/?r=05.Projects&amp;proj=36.%208pinLinux">Original</a>
    <h1>An interactive-speed Linux computer made of only 3 8-pin chips</h1>
    
    <div id="readability-page-1" class="page"><div><div>






<p><span>8-pin Linux</span></p><h2>An interactive-speed Linux computer on a tiny board you can easily build with only 3 8-pin chips</h2>


<h3>TL;DR</h3>
<p>I&#39;ve long been experimenting with minimal computers that can run Linux. I&#39;ve flirted with the <a href="https://dmitry.gr/?r=05.Projects&amp;proj=35. Linux4004">extreme</a> <a href="https://dmitry.gr/?r=05.Projects&amp;proj=07. Linux on 8bit">low-end</a> and with <a href="https://dmitry.gr/?r=05.Projects&amp;proj=33. LinuxCard">fun form factors</a>. I felt like there was a place for another fun experiment: a simple-to-build kit computer using only 8-pin chips.
</p>

<h2>Table of Contents</h2>
<ol type="1"><li><a href="#_TOC_b1abf8867cf3eb2fc456d0c19b151805">A minimal computer</a><ol type="a"><li><a href="#_TOC_7ee4079a39b0cfcb828325af6aa657e0">Initial Thoughts</a></li><li><a href="#_TOC_06464451a9c02b78d03fb676f86a8f36">Parts Selection</a></li></ol></li><li><a href="#_TOC_c6f3b6e6a3434c9bdd98a2f51f3dc28e">Designing the hardware</a><ol type="a"><li><a href="#_TOC_e4f7809d0d0a71f1f6d8a954f6ed011b">The Console</a></li><li><a href="#_TOC_e53619c1fe611a51eeeb8d148ba6e532">RAM</a></li><li><a href="#_TOC_e23710bba70063c2e153d50ddbe4a51c">SD Card</a></li><li><a href="#_TOC_1b2533effd5575e1311cced4f74fc960">The Console again</a></li></ol></li><li><a href="#_TOC_5155aa5dfb2fe88f797740f4f6f727d0">The software story</a><ol type="a"><li><a href="#_TOC_7d3cc518576c20f54b019226f0c1a48b">The Emulator</a></li><li><a href="#_TOC_64e3c3a38c17a25e09f9a35508bd0c33">The Bootloader</a></li><li><a href="#_TOC_d7971aa9bff90d1366346a39300de032">Card partitioning and the boot process</a></li></ol></li><li><a href="#_TOC_9446a98ad14416153cc4d45ab8b531bf">Performance</a></li><li><a href="#_TOC_d75c45e11c8aeb13494dba59a388a164">Assembly</a><ol type="a"><li><a href="#_TOC_7a077d612f50226cff67a767f4b8af00">Acquisition</a></li><li><a href="#_TOC_72f8f911032f231b298d7c3dbf0b5c12">Initial assembly</a></li><li><a href="#_TOC_7cb66862ec997c9a56b23473d86a4946">Secondary assembly</a></li><li><a href="#_TOC_733b0a78ec8199f1da8ffd706e0f50ad">Flashing the main firmware and first boot</a></li></ol></li><li><a href="#_TOC_d8747f437e1055c19ed3de01c4738fa7">Downloads and Use</a><ol type="a"><li><a href="#_TOC_622b64f462255c7ad3f38a49caf841b9">The files</a></li><li><a href="#_TOC_94ac065c88f34ecf9e22bc842877d194">Using it</a></li></ol></li><li><a href="#_TOC_7e1e75c32bc9b275daf70df8cba8efb5">Comments...</a></li></ol>







<h2>A minimal computer</h2>
<p><a href="https://dmitry.gr/images/8plAssembled.jpg"><img alt="An empty 8-pin Linux PCB" src="https://dmitry.gr/images/8plAssembledSmall.jpg"/></a>

<a name="_TOC_7ee4079a39b0cfcb828325af6aa657e0"></a></p><h3>Initial Thoughts</h3>
<p>There was a time when one could order a kit and assemble a computer at home. It would do just about what a contemporary store-bought computer could do. This time is long gone. Modern computers are made of hundreds of huge complex chips, with no public datasheets, with many hundreds of watts of power supplied to them over complex power delivery topologies. It does not help that modern operating systems require gigabytes of RAM, terabytes of storage, and always-on internet connectivity to properly spy on you. But, what if one tried to fit a modern computer into a kit that one could easily assemble at home?
</p>
<p>What is the minimum to be considered a &#34;modern computer&#34;? I would say being able to run Debian Linux, <span>vi</span>, <span>gcc</span>, and <span>make</span> is close enough, so that became the goal. Thanks to my previous exploits, I knew that this could be accomplished in 8MB of RAM and with 1 MIPS of CPU. Storage is easy: SD cards easily provide storage of any size. A serial port is still the de-facto method for easily interfacing with an embedded system, but as computers no longer have serial ports, USB-serial takes its place. Thus, I had the target: at least 8MB of RAM, at least 1 MIPS of CPU, SD card, USB.
</p>
<p>On the hardware front, I wanted to design something that could be assembled by someone with little-to-no soldering experience and a RadioShack 45W soldering iron, something small, cute, and cheap. Chips with fewer pins are easier to solder, so I settled on using <b>only chips with 8 pins</b>, as a fun challenge. Since all chips need at least a power supply and a ground pin, this limits each chip to no more than 6 useful pins. This decision turned out to inform a lot of the design&#39;s features and limitations. Physically, I decided to make it a small circular board, with a board-edge USB-C connector on top, as you can see on the image here. That is the final working design, assembled using the directions below, by me, actually using a RadioShack 45W soldering iron.
</p>
<h3>Parts Selection</h3>
<p>There really are not too many 8-pin chips that can speak USB. One and a half options exist. The first was the very cute <a href="https://prolificusa.com/wp-content/uploads/2019/06/DS-23181002_PL2303GL.pdf">PL2303GL</a>, which is a USB-to-serial bridge that requires <em>NO external components at all</em>, and even provides 100mA of 3.3V regulated output. Super convenient! It works precisely as promised. I am a fan! Prolific even have drivers for all major and minor operating systems available easily. Sadly, on macOS, they <a href="https://apps.apple.com/us/app/pl2303-serial/id1624835354?mt=12
">need to be installed from the AppStore</a>, but it is a simple process. It should be noted that its predecessor, the PL2303SA could also be considered, but it is EOL, and thus not worth mentioning. So, what is meant by &#34;half a chip&#34;? Well, thanks to <a href="https://www.obdev.at/products/vusb/index.html">V-USB</a>, The <a href="https://www.microchip.com/en-us/product/attiny85">ATTINYx5</a> series chips can also speak USB. It is only USB low-speed, and uses a lot of CPU time, but it works. The problem is that all existing USB-serial protocols require bulk endpoints, and USB low-speed is prohibited by the USB spec from using BULK endpoints. To stay spec-compliant this would then require designing my own comms protocol using interrupt endpoints and writing drivers for all major OSs. No fun. Luckily, <em>ALL</em> major OSs do not enforce this no-bulk-EPs-on-USB-low-speed thing. It <em>just works</em>, and implementing ACM to act as a serial port works. So, there they are - the two options for USB interfacing.
</p>
<p>There were not really any questions with regards to the RAM to use. SOIC-8 PSRAMs are the solution. <a href="https://www.issi.com/us/product-cellular-ram.shtml#jump1">ISSI</a>, <a href="https://www.apmemory.com/products/psram-iot-ram/">APMEMORY</a>, and <a href="https://www.vilsion.com/VTI7064MSM.shtml">Vilsion</a> make them. All of them have been promising 16MB chips for a year now, and none have delivered, so it is probably fair to assume that they are all bullshitting. However, 8MB parts are easily available for a few bucks at the usual retailers, so it was decided to make it work with 8MB of RAM.
</p>
<p>The last question was: which microcontroller to use? <a href="https://www.mouser.com/c/semiconductors/embedded-processors-controllers/microcontrollers-mcu/?number%20of%20i%2Fos=2%20I%2FO~~6%20I%2FO&amp;package%20%2F%20case=DFN-8~~DIP-8%7C~MSOP-8%7C~PDIP-8%7C~QFN-8~~SO8N-8%7C~SOIC-8~~SO-N-8%7C~SOT-23-8~~SOT-8%7C~TSSOP-8~~UDFN-8%7C~USON-8%7C~WDFN-8%7C~WSON-8&amp;rp=semiconductors%2Fembedded-processors-controllers%2Fmicrocontrollers-mcu%7C~Number%20of%20I%2FOs%7C~Package%20%2F%20Case">A parametric search</a> presented a few families of options:
</p>
<ul>
<li>PIC16F is a messy old 8-bit architecture that can really only be programmed well in assembly. There is a C compiler, but it produces shit code (not its fault - the architecture is not well suited for C). These clock up to 32MHz, but as they take 4 cycles per instruction, the real performance is 8MIPS at 8 bits per op at best. The fact that this is an accumulator-based arch means that most things take more instructions. Overall, not a performant option. The largest code space available is 8192 instructions&#39; worth (14KB), and the largest RAM available is 1KB.</li>
<li>Renesas R5F series is a weird little 16-bit core they call RL78. There is a passable GCC port for it too. The instructions <a href="https://www.renesas.com/en/document/mah/rl78-family-users-manual-software-rev230">take a variable number of cycles between 1 and 6</a>. For typical code it&#39;ll average an IPC of 0.55, and at 16MHz at most. They do not overclock well either. At least these cores are 16 bits wide, so they can do more per cycle than the PIC. In the 8-pin package, the largest possible flash size is 8KB. RAM? 1KB. As instructions are all <em>at least</em> 2 bytes, this option is limited to 4096 instructions at best, possibly less. It would be fair to expect 8MIPS at 16 bits per op.</li>
<li>PSoC1 series uses a core Infineon (n√©e Cypress) calls <a href="https://www.infineon.com/dgdl/Infineon-PSoC_CY8C20x24_CY8C20x34_Technical_Reference_Manual_(TRM)-AdditionalTechnicalInformation-v08_00-EN.pdf?fileId=8ac78c8c7d0d8da4017d0f904c2b7cc0">M8C</a>. Instruction encoding is pretty dense, with many instructions being only a byte long. Sadly, the performance is not there. No instruction takes fewer than 4 cycles, and some take over 10 cycles, including function calls. The maximum clock rate is 24MHz, with overclocks of 28MHz possible. But at an average of 6 cycles per instruction in a typical program, this only nets ~4.7MIPS at 8 bits per op. Not great. The maximum flash size is 4KB, and RAM is only 256 bytes. This is ... not great.</li>
<li>Somehow, ZiLOG still exists, and they sell 8-pin microcontrollers based on the core they call <a href="https://www.mouser.com/datasheet/2/240/PS0243-2584610.pdf">eZ8</a>. In the 8-pin package, the maximum flash size is 8KB, and RAM is 1KB. The core seems to use variable-length instructions, but they are quite slow. Most seem to take 2-4 cycles to fetch and then 3 or more to execute. Jumps take a lot more. Overall, expecting this core to get an IPC of over 0.2 is probably asking for too much. The maximum clock rate for these microcontrollers is 20Hz, so that should be about 4 MIPS at 8 bits per op. A new low.</li>
<li>NXP&#39;s <a href="https://www.mouser.com/datasheet/2/302/MC9S08QG8-3139058.pdf">S08CPUv2</a> core makes an appearance in a few chips here. It is an 8-bit accumulator-based architecture that clocks up to 40MHz. The maximum flash is 8KB, RAM size is 512 bytes - tight. Instructions are 1-4 bytes long. While some of them execute in 1 cycle, most take 2 or more. My guess at this thing&#39;s IPC in typical scenarios would be 0.6 or so. It is 8-bits wide. Expected perf is thus around 24MIPS at 8 bits per op.</li>
<li><a href="https://www.st.com/resource/en/programming_manual/pm0044-stm8-cpu-programming-manual-stmicroelectronics.pdf">STM8</a>-based chips are an option. They are 8-bits-wide, run at 16MHz, have a pretty compact instruction encoding, and feature very high IPCs near 0.8, if you are lucky and keep the prefetch queue full. There is a C compiler available for these, too. In the 8-pin package, the maximum amount of flash is 8KB, and 1.5KB of RAM. Expected perf is around 13MIPS at 8 bits per op.</li>
<li>MSP430 (aka: the 2000s&#39; PDP11) is represented in the search results too. Sadly, with only 2KB of flash and 128bytes of RAM, none of these chips are of much use for this project - they are simply too tiny.</li>
<li>There is, of course, AVR: 20MHz at 1.0 IPC, overclockable to around 25MHz easily, 8KB of flash and 512 bytes of RAM in the ATTINY85. There is an active GCC port, and the instructions are designed in the modern day and age, producing very compact and efficient code, none of that &#34;move things into accumulator, now move them out of the accumulator&#34; nonsense. This is the best option so far. As an extra bonus, if used for USB, then the entire board could be just two chips: the AVR for USB and CPU, and the RAM chip for RAM. Tempting. However, as V-USB needs about 1.5KB of flash and a hundred bytes of RAM, that leaves rather little to the emulator. It likely would not easily fit.</li>
<li>My old friend, the <a href="https://dmitry.gr/?r=05.Projects&amp;proj=23.%20PSoC4">PSoC4</a> is also represented in the results. A 16MHz ARM Cortex-M0 core basically obliterates all of the above options on performance trivially. It will execute most instructions in a single cycle (but branches take 3) and it is 32-bits wide. Flash size is 8KB officially, but, as I <a href="https://dmitry.gr/?r=05.Projects&amp;proj=24. PSoC4 confidential">had documented</a>, really there is 16KB. RAM really is just 2KB in size. The major downfall of this option is that it uses three pins for supplying power to the chip, leaving only 5 pins available for I/O. Being already short on pins, giving one up is a lot to ask!</li>
<li>TI&#39;s new <a href="https://www.ti.com/microcontrollers-mcus-processors/arm-based-microcontrollers/arm-cortex-m0-mcus/overview.html">MSPM0C series</a> is a possibility. The Cortex-M0+ core is even faster than a Cortex-M0 by virtue of taking one cycle fewer to branch. In an emulator this matters! 16KB of flash, 1KB of RAM, and all 6 pins usable as I/O. What&#39;s not to like? Well, one pin is open-drain only, which sucks. This makes the pin unsuitable for fast output. The speed is 24MHz, with a little bit of overclockability available. However, without a PLL, this chip cannot overclock far. Still, this is now the best option, easily outperforming the AVR.
</li>
<li>The last option (as using STM&#39;s chips should always be the last option due to their habit of not publishing accurate and complete errata sheets) is the STM32G0 series. The STM32G030 is immediately discarded as an option, since one of the pins is a permanent RESET input, leaving only 5 I/Os. The <a href="https://www.mouser.com/ProductDetail/511-STM32G031J4M6">STM32G031J4M6</a> seems like a possibility. It is a relatively recent chip, so there is hope that STM got their shit together and fixed some of the usual myriad of issues their chips contain. Then again, as the plan called for minimal use of on-chip peripherals, maybe it&#39;ll be fine? 32KB of flash, 8KB of RAM! Those are serious numbers, completely obliterating the previous contestants. The Cortex-M0+ core makes it a tie for the best so far. Officially, this chip clocks at 64MHz. With effort, it&#39;ll overclock to 80MHz. With more effort (see below), it&#39;ll run at 150MHz. Assuming one can avoid the errata, this seems like the clear winner by far, as much as I hate it. Maybe one day there&#39;ll be an RP2354 in an SOIC-8 package with 6 PIO pins?</li>
</ul>

<h2>Designing the hardware</h2>
<p><a href="https://dmitry.gr/images/8plSchematic.png"><img alt="An empty 8-pin Linux PCB" src="https://dmitry.gr/images/8plSchematicSmall.png"/></a>
<a name="_TOC_e4f7809d0d0a71f1f6d8a954f6ed011b"></a></p><h3>The Console</h3>
<p>The UART pins cannot be combined with anything. Any attempts to combine UART RX with something would create the possibility of missing some incoming data while the &#34;something&#34; is going on. Combining UART TX with something, no matter how fast that &#34;something&#34; is, is problematic as well. Any low pulse would be seen as a character by the PC. For brief lows it would be seen as a <span>0xFF</span> byte. In theory, parity could be enabled and used to hide this, but this is not surefire. Plus, who uses parity in 2024? Really, UART pins, lacking a higher-level protocol, chip select, or a separate clock are basically un-combinable with anything else. There go two of the 6 pins. Oh well...
</p>
<h3>RAM</h3>
<p>All the SPI PSRAMS support QSPI mode for speed. Sadly, QSPI requires 6 pins and only 4 are left. OK, most of them also support dual-SPI, wherein <span>MISO</span> and <span>MOSI</span> are used concurrently to send two bits of data per clock unidirectionally. This is twice the speed of normal SPI, just as you&#39;d imagine. As an extra credit, it does not require any more pins than normal SPI and is compatible with sharing the SPI bus with other devices, since they would not expect to read <span>MOSI</span> or drive <span>MISO</span> when deselected.
</p>
<p>STM32G031 does not support dual-SPI. It could be bit-banged, of course. But, could it be done fast enough to beat the hardware SPI unit? The hardware SPI unit can run at one-half of the CPU clock and mate to the DMA unit for nonstop transmission/reception. To match this via CPU, would require bit-banging dual-SPI using no more than 4 cycles per clock. This is barely possible, given a few preparatory steps. Doing it any faster than that is impossible. Since the best that can be done is to match the hardware SPI unit, why bother? RAM will be accessed using garden-variety SPI. That uses four of the remaining four pins. Damn...
</p>
<h3>SD Card</h3>
<p>So, here was the situation: no pins left and still an SD card to attach. SD cards speak SPI, so one more pin to give it a chip select signal would be enough, but there were no pins left. A few options were considered. The simplest idea was to include an inverter on the RAM&#39;s <span>nCS</span> and use that as the SD card&#39;s <span>nCS</span>. This was prototyped and it worked somewhat well. The issue with this approach is two-fold. First of all, some cards did not like being selected and deselected with no data bytes being sent to them, but that is precisely what two RAM accesses would look like to them. Not many cards had this issue, so it is not a showstopper. The second issue is that the inverter is either an extra IC or an extra transistor. The more components the board has, the harder it is for a novice to assemble. This solution was put aside, labeled &#34;worst case&#34;. A search of a better one went on.
</p>
<p>This device will not produce data very quickly, so it is safe to run the <span>UART</span> super slowly. So, then the UART TX pin can be low-pass-filtered on the way to the USB-to-serial chip. That same pin can then be used for SD card&#39;s <span>nCS</span>, as long as the commands are short and the clock rate is high enough that the selection time is below what the low-pass filter will permit through. This solution is workable but fragile. Once the math is worked out for the baudrate necessary to permit card initialization as per spec, it gets sadder. The UART would need to be run at a 300 bps rate or slower to make this work. And even then, it is fragile if the card decides to be slow, since the SD spec&#39;s SPI chapter does not technically allow deselecting the card while waiting for it to read data. No, this was even worse than the first option.
</p>
<p>Before surrendering to the first option, there was a crazier yet option to consider. Would the SPI RAM at all mind being selected and then deselected with no commands or data in between? Experimentation provides the answer: no. This test passed on all the SPI RAM chips. Why? Well, besides SPI, SD cards also speak the SDIO protocol. Instead of using four unidirectional wires, this protocol uses one unidirectional <span>CLK</span> signal and two bidirectional signals: <span>CMD</span> and <span>DAT</span>. The four-bit-wide version uses three more data pins, but that does not matter here. Unlike SPI, this protocol is not quite documented in the public SD documentation, but it is not too hard to figure out. Using one fewer pins is nice, but there were <em>no</em> free pins, and this approach would have needed three, so this was not immediately useful. Before trying to make it <em>useful</em>, it had to first be make to work at all. After some time, this was done and a working implementation of SDIO 1-bit protocol was produced. It successfully initialized and accessed all SD cards tried. Cool.
</p>
<p>So, which pins could be combined with SDIO&#39;s three? After much thinking, the solution is obvious. RAM&#39;s <span>nCS</span> can be the SD card&#39;s <span>CLK</span>. RAM&#39;s <span>CLK</span> can be the SD card&#39;s <span>CMD</span>. RAM&#39;s <span>MOSI</span> can be the SD card&#39;s <span>DAT</span>. Try and figure out all the possible interactions with each device and what that would look like to the other, to convince yourself that it will work safely. When the RAM is selected, the SD card will see its <span>CLK</span> go down, when RAM is deselected, the SD card will see its <span>CLK</span> go up. The RAM&#39;s SPI is configured for mode 3, which means that its <span>CLK</span> idles high. This, in turn, means that every RAM access, no matter how short, is seen by the SD card as a single bit sent to it, a <span>1</span> bit. This is the idle state of the SDIO&#39;s <span>CMD</span> line between commands, and this is safe. SD cards do not drive or read the <span>DAT</span> line between commands so the movement of the RAM&#39;s <span>MOSI</span> will be ignored. Good so far. Accessing the SD card requires toggling its <span>CLK</span> line, while reading or writing its <span>CMD</span> and <span>DAT</span> lines. To the RAM, this will look like it is being selected and deselected with nothing in between happening. This is safe. Cool!
</p>
<p>It should be noted that this will only work if the entire SD transaction is done to completion at a time without any intervening RAM accesses. This means that multi-block reads or writes cannot be used. This is acceptable given the pin deficit. Well, there it is, a potentially working solution! Experimental verification followed. Success! Of course, the STM32G031 does not have the proper pinout to use any hardware unit for this, so the SD accesses are entirely bit-banged. This is acceptable, and my assembly code to do this achieved about 14 CPU cycles per bit throughput. Overall, not too bad.
</p>
<h3>The Console again</h3>
<p>Now that it was clearly established that all the I/O could, at least in theory, fit into 6 pins, it was time to assign things to pins. Some of that was trivial: the RAM needs real SPI so those are the pins. The SD card shares the RAM&#39;s pins so that&#39;s clear too. Left over were pins 7 and 8. These pins make up the SWD interface, which was convenient for early debugging. Also, by process of elimination, they needed to be the serial port. Pin 8, as <span>A14</span> can act as <span>USART2.TX</span>, and with USART&#39;s &#34;pin swap&#34; functionality enabled, this can be turned into <span>USART2.RX</span>. This is good, since UART receive is a pain to do without hardware assistance. That leaves pin 7 as my <span>TX</span> pin. This pin has no alternate functions related to any USART at all. Well, luckily, it is not too hard to bit-bang UART transmission. This is ironic - an earlier approach called for an as-slow-as-possible UART baudrate. Bit-banging UART calls for an as-fast-as-possible baudrate since the entire world needs to stop while the transmission is going on. Sending every character at 115,200bps will take 87 microseconds. In theory, a very slow baudrate could be used, with timer-driven interrupts use to send bits of each character, but the jitter in interrupt timing could cause issues. Anyways, most of the time the board is not outputting anything, so it is OK as is. Bit-banging UART transmit works well. Pins are assigned. Time to get to the software.
</p>
<p>But, you might say, what about initial flashing? Surely STM&#39;s bootloader will not support using these weird pins for initial flashing? Indeed, that is the case. This is why the board has four solder bridges that configure the wiring for the serial port. In one configuration, the bootloader will work but RAM and SD card will not and cannot work, in the other, the ROM bootloader is no longer useful but the project will boot. Luckily, this project includes its own bootloader, so the ROM bootloader is not needed after the initial flashing.
</p>

<h2>The software story</h2>
<h3>The Emulator</h3>
<p><a href="https://dmitry.gr/images/8plConsole.png"><img alt="An empty 8-pin Linux PCB" src="https://dmitry.gr/images/8plConsoleSmall.png"/></a></p><p>I <a href="https://dmitry.gr/?r=05.Projects&amp;proj=33.%20LinuxCard">did already have</a> a MIPS emulator that could boot Linux, written in ARMv6M assembly. Reusing this would be trivial. In search of more speed, I actually wrote a MIPS-to-ARMv6M JIT, which worked well. The tragedy is that it was too big (compiling to 46KB of code) and did not produce that much speed gain with only 6KB of translation cache to be of use on this project. It was shelved, until another time.
</p>
<p>The 32KB of flash in the STM32G31 was split into an 8KB area for the bootloader and a 24KB area for the main code. The rest was simply polish. The main emulator code remains as it was before.
</p>
<h3>The Bootloader</h3>
<p>Why was there a need for a bootloader? Well, there were no pins left for debugging, there was a need to find a way to update the firmware to fix bugs or add features. The simplest solution would be a bootloader that can use the SD card, understand FAT filesystem, and apply an update from it if it finds it. That is precisely the solution chosen. The reason that the bootloader is a whopping 8KB in size (well, actually 6.5KB, but flash blocks are 2KB so it gets rounded up) is that it must include a full SDIO driver, FAT filesystem driver, flash writing code, and lots of logging to help debug any issues that come up. Of course, it also includes a copy of the bit-banged UART transmit code. The word at offset 16 in the application image is considered a version number and an update will only be applied if its version is higher than the current application&#39;s version and it passes some basic checks. The byte at offset 8 in the bootloader is the bootloader version. This is not used for any way other than displaying in the main app&#39;s boot text. The firmware update is applied if it passes all tests and is called <span>FIRMWARE.BIN</span>.
</p>
<p>The bootloader itself runs after the chip is reset, so it runs at 16MHz. The main application can run at various CPU speeds, to allow everyone to experiment with overclocking. However, there needs to be a failsafe way to change the speed, and manually recompiling the image each time seemed like too much of a drag. This is solved  easily. The bootloader already mounts the FAT filesystem on the card to look for firmware updates. While doing that, it also looks for any file or directory whose name begins with <span>CLOCK</span>. If found, the numbers following the name are used the clock rate for the main application. If the number is out sane range (32-200MHz), or no such file is found, 132 MHz is used. Yes, 132MHz. More on that later.
</p>
<h3>Card partitioning and the boot process</h3>
<p>Same as in my previous MIPS-emulating projects, the boot process is reminiscent of the PC boot process. The first sector of the card is read into the first bytes of RAM and jumped to. It may then load the next stage. It does so by looking for a partition with type <span>0xBB</span> and loading it into ram at address <span>0x80001000</span> and then jumping to it. There, lives the second-stage bootloader. It is large enough to contain logging and console output. It will look for a partition marked as active, attempt to mount it as <span>FAT16</span>, and find a file there called <span>VMLINUX</span>. If it is found, it is loaded as an ELF file and its entry point is jumped to. If this is a valid Linux kernel, it will then boot. The commandline passed to the kernel is embedded in the bootloader since it is not expected to change. It instructs the kernel to mount <span>/dev/pvd3</span> as root and use <span>/sbin/uMIPSinit</span> as init. It will try to mount <span>/dev/pvd1</span> as <span>/boot</span>
</p>
<p>A careful read of the above paragraph would show that while the rootfs needs to be the third partition, no other order is specified or matters. This is on purpose. For this project, the FAT partition is first, the bootloader partition second, and rootfs third. Why? When an SD card with multiple partitions is inserted, Windows and macOS will mount the first partition. Linux will mount them all. This means that (1) the FAT partition can be used to easily get files in and out of this machine as they are also visible to the booted Linux in <span>/boot</span> and (2) clock speed changing/overclocking is easy from the host machine <em>and/or</em> from the booted Linux itself.
</p>
<p>The first thing the bootloader does is simply wait six seconds without doing anything. This is done before reconfiguring the pins. The delay allows for some time to attach an SWD debugger, if so desired (the board has a 4-pin header for that). After this delay, the pins are reconfigured and there are no more pins assigned to SWD, and thus a debugger cannot be attached anymore. As a secondary backup, the bootloader configures the option bytes to allow forcing the chip to boot from ROM by raising the <span>BOOT0</span> pin (pin 8). It also programs the option bytes to disable the reset pin (it is being used as a GPIO) and to disable the BOR (it is of no use here). Then it will try to initialize comms with the SD card and check for updates, then it will boot.
</p>

<h2>Performance</h2>
<p>STM32G031 is specified to run at 64MHz, so why all this talk about running it at 150MHz? Well, with the proper application of dark magic, STM32G031 overclocks quite well. The CPU core runs from an internal regulator whose voltage is adjusted using the <span>PWR-&gt;CR1</span> register. STM documents two settings: <span>VOS2</span> (corresponding to <span>Vcore</span> of 1.0V) where the chip can only be run up to 16MHz and <span>VOS1</span> (corresponding to <span>Vcore</span> of 1.2V) where the chip can only be run up to 64MHz. Indeed, at <span>VOS1</span>, the chip will not run well past about 75MHz. A respectable overclock, but not that exciting. However.... older documentation (and documentation of similar chips) also mentions <span>VOS0</span>, corresponding to <span>Vcore</span> of 1.35V. What if one tries? Well, what do you know? It works, and the chip gets a <em>LOT</em> more overclockable. Now, most instances of the chip run well at 136MHz, and some get to 180MHz. You do need to manage the flash wait states correctly, since the flash memory will not magically get any faster. The extra wait states do eat into the speed gains, but it is still worth it.
</p>
<p>At 148MHz host CPU speed, the emulated MIPS CPU is approximately equivalent to a 1.65MHz MIPS R3000 with FPU disabled. It is not a speed beast, but it does boot in about a minute, and things like <span>vi</span>, <span>make</span>, <span>objdump</span>, and <span>gcc</span> work. This is a full Debian system, so you can bring in <span>.deb</span> packages via <span>/boot</span> and install them even. It all works.
</p>

<h2>Assembly</h2>
<p><a href="https://dmitry.gr/images/8plNakedBoard.png"><img alt="An empty 8-pin Linux PCB" src="https://dmitry.gr/images/8plNakedBoard.png"/></a>
<a name="_TOC_7a077d612f50226cff67a767f4b8af00"></a></p><h3>Acquisition</h3>
<p>You can buy the parts yourself and get a board made by your favourite board house (all the things you need are in the downloads below), or (I hope) you&#39;ll be able to buy a kit soon. I am looking for a company that wants to sell the kit. <a href="mailto:contact@dmitry.gr">Contact me</a> if you have a lead on this. They would make great gifts!
</p>
<h3>Initial assembly</h3>
<p>The part you came here for: how to build your own. Here you see the board you are likely holding in your hands. It is pretty easy to assemble, and this is by design. The first thing you solder in should be the SD card socket. Line it up carefully in the box and solder the pins one at a time, then solder the four corner pads that hold it to the board. These take a bit more heat so be patient. Next, solder in all the capacitors. There are four and they are all the same value so it is easy. They go into slots labeled <span>C1</span> through <span>C4</span>. Next up, solder in all the resistors. They are also all the same value for ease of assembly. They go into places labeled <span>R2</span> through <span>R7</span> (there is no R4). Do not fill in slots <span>R101</span>, <span>R102</span>, <span>R201</span>, and <span>R202</span> yet.
</p>
<p>Next up, solder in the microcontroller (STM32G031J6). It goes into the place labeled <span>U1</span>. Direction matters here. On these, the first pin is labeled by a little image of the STM logo. On the board, pin 1 is labeled using a small circle inside the outline as well as outside of it. Rotate the chip correctly and solder it in. Next, solder in the USB-to-serial chip (PL2303GL). It goes into the slot labeled <span>U3</span>. On this chip, pin one is indicated by a little dimple in the corner on top of the chip. Line that up with the board&#39;s pin 1 marker and solder it in.
</p>
<h3>Secondary assembly</h3>
<p>At this point in time, you must program the bootloader into the microcontroller. To do this, use STM&#39;s &#34;flasher&#34; utility. You&#39;ll need a USB-C cable. To connect the proper pins to the serial port, you&#39;ll need to use two pieces of wire (or just solder) to bridge the places labeled <span>R101</span> and <span>R201</span> on the board. Make sure you do <em>not</em> have an SD card inserted into the onboard socket and you did not yet solder-in the RAM chip. Then, plug the cable into your computer and insert the board carefully <em>into</em> the USB-C end of the cable. The PC should detect a virtual serial port and install drivers automatically. Now you&#39;ll need the flasher utility. You may get it <a href="https://www.st.com/en/development-tools/flasher-stm32.html">here</a> for windows. There is an open-source alternative with other platform support <a href="https://sourceforge.net/projects/stm32flash/">here</a>. If you build that tool, the process is the usual one: <span>./configure &amp;&amp; make</span>. Using it is easy too: <span>./stm32flash -w BOOTLOADER.BIN -v /dev/ttyUSB0</span>, assuming those names and paths are correct for your use case. If you have an SWD debugger you may instead use it to program the bootloader into the chip. From the download package, grab &#34;BOOTLOADER.BIN&#34; and have that programmed into the chip.
</p>
<p>At this point, remove the solder bridges or wires you used to bridge <span>R101</span> and <span>R201</span> and instead bridge <span>R102</span> and <span>R202</span>. This is the proper final configuration for the serial port pins. Solder in the RAM chip now (APS6408 or VTI7064), marked <span>U2</span>. Pin 1 on this chip is also marked with a small dimple. Match that up with the small circle on the board and solder the chip in. This concludes the hardware assembly.
</p>
<h3>Flashing the main firmware and first boot</h3>
<p>Use a disk imaging tool (<a href="https://win32diskimager.org/">WIN32 DISK IMAGER</a> for windows, built-in &#34;Disk Utility&#34; for macOS, dd for Linux) to write the provided disk image unto an SD card of at least 1GB in size. This image includes the first-stage MIPS bootloader, the second-stage MIPS bootloader, a partition with the Linux kernel and a copy of the firmware, and a debian rootfs. After the card is written, eject it and reinsert it. Your PC should now recognize the FAT filesystem and mount it. Drop the main firmware into it from the download package, named FIRMWARE.BIN. This will allow the bootloader to pick it up and self-flash it on first boot. This step is not necessary if you did not rebuild it, as the provided image already contains that file there. It is, however, safe to do it anyways. You&#39;re done!
</p>
<p>Insert the SD card, connect the cable to the PC again, open your favourite serial terminal, and configure it for 115,200 bps, 8N1. After a few seconds you&#39;ll see text appear as the various stages of bootloaders run. The very first time, STM32&#39;s fuses will be programmed and you may need to unplug and replug the USB-C cable to continue the boot process. This will only need to happen once since the fuses are nonvolatile. After about 20 seconds, the Linux kernel boot messages will start. The boot process will take about a minute. At the end you&#39;ll end up at a shall prompt. As there is only 8MB of RAM, making <span>swapon /swapfile</span> your first command is strongly suggested. This will take a few dozen seconds to complete, but after it you&#39;ll have swap and ability to run a lot more things. Play around. Enjoy!
</p>


<h2>Downloads and Use</h2>
<h3>The files</h3>
<p>The main download is [<a href="https://dmitry.gr/images/uMIPS.8PL.zip">here</a>]. That is an archive that contains everything you need. The <span>schematics</span> directory contains the schematics, <span>gerbers</span> contains the gerbers you&#39;d need to have boards made, and <span>srcs</span> contains the sources of the emulator and the bootloader. In the <span>binaries</span> directory you&#39;ll find the SD card image (<span>SD.img</span>) that you&#39;ll want to write directory to your card, <span>BOOTLOADER.BIN</span> is the bootloader you&#39;ll write to the chip in the middle of assembling the project, and <span>FIRMWARE.BIN</span> is a pre-built firmware image (a copy of which is already in <span>SD.img</span>&#39;s first partition). 
</p>
<h3>Using it</h3>
<p>The device boots to a shell prompt using <span>sh</span>. You may start bash if you wish - it works. To not run out of RAM, as mentioned above, it is advisable to enable swap. A pre-made swapfile is in the image, simply run <span>swapon /swapfile</span> as one of your first commands. The effective CPU speed is about 1.5MHz assuming you&#39;re running the MCU at 120MHz, so go keep in mind that commands will take time. Compiling a simple program with gcc will take a few minutes, but it will work. Provided examples include two Mandelbrot set generators (floating point and fixed point), compiled and binary both.
</p>
<p>The usual tools are installed: <span>vim</span>, <span>make</span>, and <span>gcc</span>. All the usual debian packages are there too, and you can load more things using the shared FAT16 partition on the SD card. Under Linux it is mounted under <span>/boot</span>
</p>



<!--- We do not show this to the user, but ToC system will index this and we'll get a link to comments in the ToC -->






					
					</div></div></div>
  </body>
</html>
