<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ntietz.com/blog/bitmaps-speed-up-by-sorting/">Original</a>
    <h1>Speeding up queries 1000x by sorting my bitmaps</h1>
    
    <div id="readability-page-1" class="page"><article>
    

    <p><strong>Monday, January 23, 2023</strong></p>

    <p>I&#39;m working on a database system that stores and queries chess games and positions.
Right now, it contains 240 million unique positions from 3.8 million games.
One of the things it needs to do is quickly find all the games where a particular position occurs.
I&#39;d also like it to do things like find games where this position occurs and it ends in a draw.</p>
<p>Bitmaps are really useful here, and with some care they can achieve unbelievable efficiency.
They can also be really slow if you&#39;re not careful.
It&#39;s a journey.</p>
<p>We&#39;ll start by looking at how my bitmaps are implemented, and then we&#39;ll see how an assumption punished me severely and how I fixed it to make things a lot faster.</p>

<p>A bitmap is a sequence of bits which indicate a boolean condition across a range of items.
You can use them to store a true/false condition for any collection which you can assign sequential integer IDs to.</p>
<p>For example, if you have 8 cats, you could store for each one whether it is cute or not.
The simple approach is to store a list of booleans, each which indicates this condition.
This is wasteful:
Each of those booleans takes at least one byte of memory, but you&#39;re only really using one bit from that byte!
You would allocate 64 bits to use 8.</p>
<p>Instead, you could store their cuteness in a bitmap: each cat would have a 1 if it is cute and a 0 if it is not.
This would use just 8 bits total, or 1 byte.</p>
<p>Here are two hypothetical bitmaps containing eight values:</p>
<p><img src="https://www.openculture.com/images/bitmaps/diagram1.svg" alt="Image of two bitmaps in a hand-drawn style. The first one is &#34;11000000&#34;, and the second one is &#34;10011100&#34;."/></p>
<p>These bitmaps are stored in a dense form.
Each bit physically exists!
This makes a lot of things easy, and it&#39;s a nice mental model for bitmaps.
But it&#39;s not very space efficient, since it makes absolutely no attempt at compressing the data down.
If we&#39;re storing mostly the same value, like almost all 1s or almost all 0s, then we can store this a lot more efficiently!</p>
<p>There&#39;s a common encoding call <a href="https://en.wikipedia.org/wiki/Run-length_encoding">run-length encoding</a>.
Instead of storing each item, you instead store the item and how many times it is repeated.
This is really useful for times when you have the same value multiple times!</p>
<p>Here&#39;s one way we could store these same bitmaps with run-length encoding:</p>
<p><img src="https://www.openculture.com/images/bitmaps/diagram2.svg" alt="Image of two bitmaps in a hand-drawn style, encoded with run-length-encoding. The first one is &#34;(1,2) (0,6)&#34;, and the second one is &#34;(1,1) (0,2) (1,3) (0,2)&#34;."/></p>
<p>The first bitmap was <code>11000000</code> as a dense bitmap, and is now represented as two pairs: <code>(1,2)</code> saying we start with two 1s, and <code>(0,6)</code>, saying we then have six 0s.
The second bitmap is represented the same way. It&#39;s <code>10011100</code>, which is represented as <code>(1,1)</code> for one 1, <code>(0,2)</code> for two 0s, <code>(1,3)</code> for three 1s, and <code>(0,2)</code> for the final two 0s.</p>
<p>This gives us a nice reduction in space for large bitmaps with lots of long runs!
But we can still do better.</p>
<p>One trick we can use is to observe that we don&#39;t need to store the value, since it alternates.
This lets us save some space, but ends up complicating bitwise operations.
Instead, we can store pairs of <code>(position, count)</code> for just 1s, and let all 0s be implicit.</p>
<p><img src="https://www.openculture.com/images/bitmaps/diagram3.svg" alt="Image of two bitmaps in a hand-drawn style, encoded with a form of run-length-encoding. The first one is &#34;(0,2)&#34;, and the second one is &#34;(0,1) (3,3)&#34;."/></p>
<p>This lets us remove half the space needed!
The first example says that there are two 1s at position 0; all the other bits are 0.
The second example says that there is one 1 at position 0, three 1s at position 3, and the rest are 0.
It ends up exactly equivalent to the earlier ones, with the added benefit of bitwise operations being <strong>much easier to implement</strong>.</p>

<p>Bitmaps are usually used to say that something is true for given elements in a collection.
By itself, this is fine.
They let you get quick counts for how many things are true, or quickly find elements where the thing it true.
But they become much more powerful when you use logical operations on them.</p>
<p>The usual bitwise logical operators (bitwise-and, -or, and -not) are useful here!
With these, you can take bitmaps and combine them for more complex conditions, and then get the specific items or a count of matching items.</p>
<p><img src="https://www.openculture.com/images/bitmaps/diagram4.svg" alt="Image of bitmaps in a hand-drawn style, showing logical operations being performed."/></p>

<p>In my particular case, I have a collection of chess games and the corresponding positions that occur in those games.
We assume that we can give an id to each game, and we want to know for any given position, how many games it has occurred in.
Further, we want to know how many of those games were wins, losses, or draws for a given color.
This is an ideal problem for bitmaps.</p>
<p>First, we form what&#39;s essentially <strong>a sparse matrix of the data</strong>.
The columns correspond to games, and the rows correspond to positions.
For a position, you look at its row to find all the games which it occurred in.
For a game, you look at the column to see all the positions which occurred during the game.
<strong>We store one bitmap per position</strong>.</p>
<p><img src="https://www.openculture.com/images/bitmaps/diagram5.svg" alt="Image of bitmaps in a hand-drawn style, with each bitmap representing the row of a sparse matrix."/></p>
<p>They&#39;re drawn here as dense bitmaps, but they&#39;d actually be sparse bitmaps; it&#39;s just easier to draw the dense form!</p>
<p>We also have <strong>a bitmap for each possible game result</strong>: white wins, black wins, draw, or other (game was aborted, unknown outcome, etc.).
For these, we have one column for each game (just like a position bitmap), which indicates if the game had that particular result.
So if white won game 3, then that bitmap would have a 1 in position 3, and all the other bitmaps would have a 0 there.</p>
<p>Using these, we can compute nice things like how many games from a given position end in each result: you take the position&#39;s bitmap and then do a logical-and with each of the position results, and count the number of bits set.</p>

<p>I implemented this with sparse bitmaps, and it worked!</p>
<p>...slowly.</p>
<p><strong>A pageload took about 300ms.</strong>
This was doing the counts for about 15 moves, each with 4 bitmap operations, so each bitmap operation was taking about 5 ms.
This seemed much slower than it needed to be, so I poked around at the data.</p>
<p>The position bitmaps seemed reasonable, but fairly large.
Each one had hundreds of runs in the sparse bitmap, but we can deal with that.
The problem was the game results bitmaps:
The white/black in bitmaps had <strong>half a million runs</strong> each.
Churning through those was super expensive, at least for my hand-rolled possibly-naive bitmap implementation.</p>
<p>Making major improvements turned out to be fairly easy once a key insight was found.
<strong>The problem is because of excessive <em>runs</em></strong>, so if we can reduce the number of runs, we&#39;ll speed things up.</p>
<p>The games database was initially sorted in no particular order, just whatever order I pulled them out of the games archive (roughly chronological, but not exactly), because I didn&#39;t think the order would matter initially.
What if we sort that data?</p>
<p>I decided to sort by a key composed of both the game result (with an arbitrary ordering) and the first <code>n</code> moves of the game (initially 5 ply, but I&#39;ll extend it further).
The particular ordering isn&#39;t what matters so much as grouping like elements together in the bitmaps.</p>
<p>Before sorting, the positions index was 17 MB on the disk and contained about 500k runs bitmaps in the bitmaps for win/loss (not sure what draws looked like).
After sorting? This bitmap is now <strong>96 bytes on the disk</strong>. Since we put all the results where white wins together, we have <strong>one run</strong>, which it takes just a few 64-bit ints to represent. Same for all the others, so each bitmap ends up as 24 bytes, and we have 4 of them.</p>
<p>That&#39;s a <strong>177,000x space savings</strong>, which... damn.</p>
<p>The position bitmaps benefited from compression as well, but not as significantly:
The <strong>positions index went from 7.8GB to 7.6GB, saving 200 MB</strong>.
There was less gain to be had since most positions are unique and occur in only one game, so there were often no runs to collapse.
Most of the benefit came from compressing moves in the early opening.</p>
<p>We were concerned mostly with speed, not space.
Fortunately, the speed also improved dramatically.
Before, <strong>page loads were 300ms and now they&#39;re about 300 microseconds</strong>.
A 1000x improvement in computation time!
Once you get beyond the first 5 moves that we sorted by, things drop to only a 100x improvement, as times rise to ~3ms until you get back into more unique positions (thus why I&#39;m going to do a deeper sort later).</p>

<p>I originally thought the order of my database didn&#39;t matter and that there wasn&#39;t a natural ordering for it.
That was wrong! The ordering matters tremendously.</p>
<p>The correct ordering isn&#39;t obvious, because it depends on what you want to do with the data!
In general, for bitmaps, you&#39;ll get a lot of benefit if you can sort the data in a way that reduces the number of runs in your bitmaps.</p>
<p>The sorting was also pretty computationally expensive and slow.
This is pushing me into parallelizing the data loading sooner than I would have otherwise prioritized it.
There&#39;s a clear trade-off here between time spent processing the data for the index vs. time spent using the index in a query, and it&#39;s cool to be able to turn that knob to speed up queries!</p>
<hr/>





  </article><p>
    If this post was enjoyable or useful for you, <strong>please share it!</strong>
    If you have comments, questions, or feedback, please email <a href="mailto:~ntietz/public-inbox@lists.sr.ht">my public inbox</a> or <a href="mailto:me@ntietz.com">my personal email</a>.
    To get new posts, please use my <a href="https://ntietz.com/atom.xml">RSS feed</a>.
  </p></div>
  </body>
</html>
