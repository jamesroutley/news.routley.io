<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.lelanthran.com/chap13/content.html">Original</a>
    <h1>Parse, Don&#39;t Validate (For C)</h1>
    
    <div id="readability-page-1" class="page">

<blockquote>
<p>“A good programmer is someone who looks both ways before crossing a one-way street.” – Doug Linder</p>
</blockquote>

<hr/>

<p>
Posted by Lelanthran
</p>

<p>
2025-03-27
</p>

<p>If you’ve read the original post on <a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/"><em>“Parse, Don’t Validate”</em></a> you may have noticed that it focuses primarily on conceptual correctness. Here, I’ll build on that by showing how this technique can be used outside of niche academic languages by demonstrating it in a language that is as practical as it is dangerous - C.</p>
<blockquote>
<p>In this blog post you will see three techniques of reducing the risk of exploitable errors in C.</p>
</blockquote>

<p>The basic idea is this:</p>
<ol type="1">
<li><strong>Data Comes Into Your System.</strong></li>
<li><strong>Your System Processes It.</strong></li>
</ol>
<p>Your first instinct, when your system receives as input an email address (for example), is to perform <code>validateEmail(untrustedInput)</code> and then pass the validated string further into the depths of the system for usage.</p>
<p>The problem is that other code deep within the rest of the system is going to <strong>also</strong> do some sort of validation on the string they just got. Every single function deep within the bowels of the system will <strong>still</strong> need to validate the input before processing it.</p>
<p>I’ll bet good money that the processing functions will attempt to validate their input. Because they’re logically far away from the boundary, they’ll either do it a different way or fail to do it altogether.</p>
<p>So instead of this:</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span>// Pseudocode</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span>if</span> (validateEmail(untrustedInput) != true) {</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>   <span>return</span> error;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>}</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span>// Rest of system uses `untrustedInput`</span></span></code></pre></div>
<p>Rather do this instead:</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span>// Pseudocode</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>email_t theEmail = parseEmail(untrustedInput);</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span>if</span> (theEmail == PARSE_ERROR) {</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>   <span>return</span> error;</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>}</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a><span>// Rest of system uses `theEmail`</span></span></code></pre></div>
<p>This removes any opportunity for errors to creep in within the rest of the system, such as some other code using a different <code>validateEmail</code> function on the <code>untrustedInput</code>, for example.</p>

<p>What does this have to do with C strings? Good question.</p>
<p>Much to the surprise of, well, everybody, C <em>actually has</em> type safety. Sure, it isn’t as enforceable as (for example) Rust… and, sure, if you are willing to do extra work you can bypass it, but, at the end of the day, the compiler <em>will still warn you</em> if you try to add a number to a string and assign the result to a function.</p>
<p>With some exceptions, when you mismatch types, the compiler <strong>will</strong> tell you about it.</p>
<p>The problem isn’t that C lacks type safety (it clearly enforces most types in most expressions), it’s that raw pointers do not encode semantics (e.g., a <code>char *</code> doesn’t tell you if it’s an email, a name, or a filename).</p>
<p>This is pretty much the same in every language; if you have a function <code>store_user()</code> which accepts two strings, an email and a user name, then no type safety in the world is going to save you if you accidentally swap the arguments around when calling the function.</p>
<p>But, you still have options – even in C – by creating new string types; one for email and another for user name.</p>
<p>When writing in C, instead of passing <code>char *</code> around as strings, or (safer, but not by much) using an existing string library that stores length + buffer… rather create an opaque type for it.</p>
<p>You parse the input into the correct type <strong>once</strong>, and then functions which accept that type will produce a compile error if you mix things up.</p>
<p>To create opaque types, <a href="http://www.lelanthran.com/chap9/content.html">read this post</a>.</p>
<p>When you create the correct types for <strong>data entering the system</strong>, you can then do this:</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span>// C code, not pseudocode</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>email_t *email = parse_email(untrusted_input);</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a><span>if</span> (!email) {</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>   <span>// Handle error</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>}</span></code></pre></div>
<p>In addition to the safey from using opaque types there’s even more levels of safety here too, starting with:</p>
<blockquote>
<p>You remove all occurrences of <code>char *</code> values in your system. You force the only occurrences of <code>char *</code> values to be at the boundary of your system, where <strong>all input is untrusted anyway!</strong></p>
</blockquote>
<p>This is not only for <code>char *</code> types though; you can do it to <strong>all</strong> values entering your system.You parse them once into the correct data type, and then code deep in the belly of the system <strong>cannot</strong> be compromised with malicious input, because the <strong>only</strong> data that the rest of the system will see is data that has been parsed into specific types.</p>
<p>When your functions never accept <code>char *</code> parameters your risk of pwnage is reduced. By leveraging the typing guarantees in C, you can ensure that the system won’t compile <em>even if</em> some heretic decides that they want to pass a <code>char *</code> to a function expecting an <code>email_t</code>.</p>
<p>Only the functions on the boundary of the system, interfacing to the outside world, should parse input. Everything else should accept <em>only</em> type-checkable parameters.</p>
<p>That alone is a big reason to use this approach, but I’ll point out two more opportunities to reduce the attack surface of your system using an actual compilable example consisting of separate compilation units. The untrusted input <code>email</code> and <code>name</code> come from outside the system.</p>
<p>First, the header declaring your custom types:</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span>// callee.h</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span>typedef</span> <span>struct</span> email_t email_t;</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a><span>typedef</span> <span>struct</span> name_t name_t;</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a><span>#ifdef __cplusplus</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a><span>extern</span> <span>&#34;C&#34;</span> {</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a><span>#endif</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>   email_t *email_parse (<span>const</span> <span>char</span> *untrusted);</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>   name_t *name_parse (<span>const</span> <span>char</span> *untrusted);</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a>   <span>// Additional tip: letting the callee set the callers pointer to NULL</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a>   <span>// when the value is freed prevents double-frees</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a>   <span>void</span> email_del (email_t **email);</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a>   <span>void</span> name_del (name_t **name);</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a><span>#ifdef __cplusplus</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a>};</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a><span>#endif</span></span></code></pre></div>
<p>Then, the implementation:</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span>// callee.c</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span>#include </span><span>&lt;string.h&gt;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a><span>#include </span><span>&lt;stdlib.h&gt;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a><span>#include </span><span>&#34;callee.h&#34;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a><span>struct</span> email_t {</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>   <span>// In a real program, you might want to store the two components</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>   <span>// of the email address (before and after the `@`) separately.</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a>   <span>// This example simply copies the input.</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a>   <span>char</span> *email;</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>};</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true"></a><span>struct</span> name_t {</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true"></a>   <span>char</span> *name;</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true"></a>};</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true"></a></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true"></a>email_t *email_parse (<span>const</span> <span>char</span> *untrusted)</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true"></a>{</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true"></a>   <span>if</span> (!untrusted)</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true"></a>      <span>return</span> NULL;</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true"></a></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true"></a>   email_t *ret = malloc (<span>sizeof</span> *ret);</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true"></a>   <span>if</span> (!ret)</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true"></a>      <span>return</span> NULL;</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true"></a></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true"></a>   <span>// In a real program, you&#39;ll parse this correctly</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true"></a>   <span>if</span> (!(ret-&gt;email = strdup (untrusted))) {</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true"></a>      free (ret);</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true"></a>      ret = NULL;</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true"></a>   }</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true"></a></span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true"></a>   <span>return</span> ret;</span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true"></a>}</span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true"></a></span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true"></a>name_t *name_parse (<span>const</span> <span>char</span> *untrusted)</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true"></a>{</span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true"></a>   <span>if</span> (!untrusted)</span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true"></a>      <span>return</span> NULL;</span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true"></a></span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true"></a>   name_t *ret = malloc (<span>sizeof</span> *ret);</span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true"></a>   <span>if</span> (!ret)</span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true"></a>      <span>return</span> NULL;</span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true"></a></span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true"></a>   <span>if</span> (!(ret-&gt;name = strdup (untrusted))) {</span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true"></a>      free (ret);</span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true"></a>      ret = NULL;</span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true"></a>   }</span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true"></a></span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true"></a>   <span>return</span> ret;</span>
<span id="cb5-52"><a href="#cb5-52" aria-hidden="true"></a>}</span>
<span id="cb5-53"><a href="#cb5-53" aria-hidden="true"></a></span>
<span id="cb5-54"><a href="#cb5-54" aria-hidden="true"></a><span>void</span> email_del (email_t **email)</span>
<span id="cb5-55"><a href="#cb5-55" aria-hidden="true"></a>{</span>
<span id="cb5-56"><a href="#cb5-56" aria-hidden="true"></a>   <span>if</span> (email &amp;&amp; *email) {</span>
<span id="cb5-57"><a href="#cb5-57" aria-hidden="true"></a>      free ((*email)-&gt;email);</span>
<span id="cb5-58"><a href="#cb5-58" aria-hidden="true"></a>      free (*email);</span>
<span id="cb5-59"><a href="#cb5-59" aria-hidden="true"></a>      *email = NULL;</span>
<span id="cb5-60"><a href="#cb5-60" aria-hidden="true"></a>   }</span>
<span id="cb5-61"><a href="#cb5-61" aria-hidden="true"></a>}</span>
<span id="cb5-62"><a href="#cb5-62" aria-hidden="true"></a></span>
<span id="cb5-63"><a href="#cb5-63" aria-hidden="true"></a><span>void</span> name_del (name_t **name)</span>
<span id="cb5-64"><a href="#cb5-64" aria-hidden="true"></a>{</span>
<span id="cb5-65"><a href="#cb5-65" aria-hidden="true"></a>   <span>if</span> (name &amp;&amp; *name) {</span>
<span id="cb5-66"><a href="#cb5-66" aria-hidden="true"></a>      free ((*name)-&gt;name);</span>
<span id="cb5-67"><a href="#cb5-67" aria-hidden="true"></a>      free (*name);</span>
<span id="cb5-68"><a href="#cb5-68" aria-hidden="true"></a>      *name = NULL;</span>
<span id="cb5-69"><a href="#cb5-69" aria-hidden="true"></a>   }</span>
<span id="cb5-70"><a href="#cb5-70" aria-hidden="true"></a>}</span></code></pre></div>
<p>And, of course, the caller:</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span>#include </span><span>&lt;stdio.h&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span>#include </span><span>&lt;stdbool.h&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span>#include </span><span>&lt;stdlib.h&gt;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a><span>#include </span><span>&#34;callee.h&#34;</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a><span>void</span> store_record_old (<span>char</span> *email, <span>char</span> *name)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>{</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>   <span>// Do something with the parameters here</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>   (<span>void</span>)email;</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>   (<span>void</span>)name;</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a>}</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a><span>void</span> store_record_new (email_t *email, name_t *name)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true"></a>{</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true"></a>   <span>// Do something with the parameters here</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true"></a>   (<span>void</span>)email;</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true"></a>   (<span>void</span>)name;</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true"></a>}</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true"></a></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true"></a><span>bool</span> rx_untrusted_input (<span>char</span> *untrusted_name, <span>char</span> *untrusted_email)</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true"></a>{</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true"></a>   email_t *email = email_parse (untrusted_email);</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true"></a>   name_t *name = name_parse (untrusted_name);</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true"></a>   <span>if</span> (!email || !name) {</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true"></a>      email_del (&amp;email);</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true"></a>      name_del (&amp;name);</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true"></a>      <span>return</span> false;</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true"></a>   }</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true"></a>   <span>// Whoops - we accidentally specified the parameters in the wrong order!</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true"></a>   <span>// Compiler cannot tell that this is a mistake!</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true"></a>   store_record_old (untrusted_name, untrusted_email);</span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true"></a></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true"></a>   <span>// Same mistake with opaque types, but now the compiler catches it!</span></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true"></a>   <span>// error: incompatible pointer types passing &#39;name_t *&#39; to parameter of type &#39;email_t *&#39;</span></span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true"></a>   store_record_new (name, email);</span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true"></a>   <span>return</span> true;</span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true"></a>}</span></code></pre></div>
<p>There is now <strong>literally no way</strong> for any non-boundary code in your system to accidentally use an <code>email</code> value in place of a <code>name</code> value.</p>

<p>This is a practical way of hardening your system to attacks: <em>Parse, Don’t Validate</em>.</p>
<p>Another one is shown in the code snippet above - your “destructor” functions which free a value should always be written to take the address of a pointer to that value.</p>
<p>Why, you ask? It’s because then the destructor function can set the pointer at the callers location to NULL, so even if a caller accidentally calls the <code>email_del()</code> destructor function twice, nothing will happen on the second time around.</p>
<p>And finally, the last upside: with different type names for different types, there will never be a situation where a caller might accidentally switch around the parameters in a call.</p>
<p>With <em>Parse, Don’t Validate</em>, you will <strong>never</strong> run into the situation of accidentally swapping parameters around in a function call, because the compiler will error out <em>even though those two types are identical under the hood!</em></p>

<p>By applying Parse, Don’t Validate, you gain three benefits:</p>
<p><strong>encapsulation &amp; safety</strong></p>
<blockquote>
<ol type="1">
<li>Raw char * strings are only handled at system boundaries, preventing misuse.</li>
<li>Strong types (email_t, name_t, etc.) ensure data is structured correctly from the start.</li>
</ol>
</blockquote>
<p><strong>reduced attack surface</strong></p>
<blockquote>
<ol type="1">
<li>Untrusted input is immediately transformed into safe, structured data.</li>
<li>Functions deep in the system never deal with unvalidated input, reducing risk.</li>
</ol>
</blockquote>
<p><strong>compiler-enforced type safety</strong></p>
<blockquote>
<ol type="1">
<li>Accidentally swapping parameters (e.g., passing name instead of email) becomes a compile-time error rather than a runtime bug.</li>
<li>Functions expect well-defined types, preventing unexpected behavior.</li>
</ol>
</blockquote>
<p>By leveraging the typing guarantees we eliminate entire classes of bugs while making the code more robust and maintainable. Instead of just checking values for correctness, we parse it once and then the compiler enforces <em>some</em> typing guarantees for us.</p>

<hr/>

<p>
Posted by Lelanthran
</p>

<p>
2025-03-27
</p>


</div>
  </body>
</html>
