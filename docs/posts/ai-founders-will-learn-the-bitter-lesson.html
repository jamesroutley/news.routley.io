<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lukaspetersson.com/blog/2025/bitter-vertical/">Original</a>
    <h1>AI founders will learn the bitter lesson</h1>
    
    <div id="readability-page-1" class="page"><article> <div id="markdown-content"> <p><em>tl;dr:</em></p> <ul> <li>Historically, general approaches always win in AI.</li> <li>Founders in AI application space now repeat the mistakes AI researchers made in the past.</li> <li>Better AI models will enable general purpose AI applications. At the same time, the added value of the software around the AI model will diminish.</li> </ul> <p>Recent AI progress has enabled new <code>products</code> that solve a broad range of <code>problems</code>. I saw this firsthand watching over 100 pitches during YC alumni Demo Day. These problems share a common thread - they’re simple enough to be solved with <code>constrained</code> AI. Yet the real power of AI lies in its <code>flexibility</code>. While <code>products</code> with fewer constraints generally work better, current AI <code>models</code> aren’t reliable enough to build such products at scale. We’ve been here before with AI, many times. Each time, the winning move has been the same. AI founders need to learn this history, or I fear they’ll discover these lessons the hard way.</p> <p>In 2019, Richard Sutton started his famous essay “The Bitter Lesson” with:</p> <p>“The biggest lesson that can be read from 70 years of AI research is that general methods that leverage computation are ultimately the most effective, and by a large margin”.</p> <p>He points out that throughout AI’s history, researchers have repeatedly tried to improve systems by building in human domain knowledge. The “bitter” part of the title comes from what happens next: systems that simply use more computing power end up outperforming these carefully crafted solutions. We’ve seen this pattern in speech recognition, computer chess, and computer vision. If Sutton wrote his essay today, he’d likely add generative AI to that list. And he warns us: this pattern isn’t finished playing out.</p> <p>“As a field, we still have not thoroughly learned it, as we are continuing to make the same kind of mistakes (…). We have to learn the bitter lesson that building in how we think we think does not work in the long run. The bitter lesson is based on the historical observations that 1) AI researchers have often tried to build knowledge into their agents, 2) this always helps in the short term, and is personally satisfying to the researcher, but 3) in the long run it plateaus and even inhibits further progress, and 4) breakthrough progress eventually arrives by an opposing approach based on scaling computation”</p> <p>From an AI research perspective, the Bitter Lesson deals with clear definitions of “better.” In computer chess, it’s your win rate; in speech recognition, it’s word accuracy. But this post looks at AI <code>products</code> in the application layer (see Figure 1), where “better” means both <code>performance</code> and <code>adoption</code> in the market. We’ll cover adoption in Chapter 2. For now, let’s focus on product performance - the amount of economically valuable work a product can replace. Better performance means handling more complex problems, which unlocks more value.</p> <p><img src="https://lukaspetersson.com/assets/img/stack.png" alt="stack"/></p> <p><em>Figure 1, illustration of different types of AI products. In this post, we talk about the application layer.</em></p> <p>AI <code>products</code> are typically an AI <code>model</code> wrapped in some <code>packaging software</code>. You can improve their performance in two ways:</p> <ol> <li>Through engineering effort: using domain knowledge to build constraints into the packaging software</li> <li>Through better models: waiting for AI labs to release more capable models</li> </ol> <p>You can pursue both paths, but here’s the crucial insight: as models improve, the value of engineering effort diminishes. Right now, there are huge gains to be made in building better packaging software, but only because current models make many mistakes. As models become more reliable, this will change. Eventually, you’ll just need to connect a model to a computer to solve most problems - no complex engineering required.</p> <p><img src="https://lukaspetersson.com/assets/img/perf-vs-effort.png" alt="perf-vs-effort"/></p> <p><em>Figure 2, illustration of the diminishing returns of engineering effort when building AI products in the application layer. The value diminishes both as more engineering effort is made and as better models are released.</em></p> <p>The graph above shows how engineering effort becomes less valuable as models improve. Current models have significant limitations, which means companies can still gain a lot from engineering work. I saw this at YC alumni Demo Day, where companies were finding success. The landscape splits into two groups: those with products in production at scale (solving simple problems) - a small group for now - and those targeting slightly more complex problems. This second group is doing well because their proof-of-concepts suggest their goals are achievable with enough engineering effort.</p> <p>But here’s the key question these companies face: will the next model release make all that engineering work obsolete, destroying their competitive advantage? The launch of OpenAI’s o1 model illustrates this risk. I spoke with many founders in the AI application layer who were worried because they’d invested heavily in perfecting prompts to boost performance. But with o1, prompt engineering matters less. As Figure 2 shows, o1 is smarter, but this means there’s less value in the engineering work these companies did.</p> <p>At its core, this engineering effort aims to constrain AI and reduce its mistakes. From observing many solutions, I’ve identified two main types of constraints:</p> <ul> <li> <code>Specificity</code>: This represents how focused a solution is. A <code>vertical</code> solution has packaging software built for one specific problem. A <code>horizontal</code> product, in contrast, can handle many different types of problems.</li> <li> <code>Autonomy</code>: This measures how independently the AI can operate. Following Anthropic’s terminology, we have <code>workflows</code> - systems where LLMs and tools follow predefined code paths - and <code>agents</code> - systems where LLMs control their own processes and tool usage, deciding how to complete tasks.</li> </ul> <p>These two types of constraints create a framework for categorizing AI products:</p> <table> <thead> <tr> <th> </th> <th><strong>Vertical</strong></th> <th><strong>Horizontal</strong></th> </tr> </thead> <tbody> <tr> <td><strong>Workflow</strong></td> <td>Harvey</td> <td>ChatGPT</td> </tr> <tr> <td><strong>Agent</strong></td> <td>Devin</td> <td>Claude computer-use</td> </tr> </tbody> </table> <p><em>Table 1: Classification of famous AI products. Note that ChatGPT likely follows a predefined code path for each message, making it a workflow rather than an agent.</em></p> <p>Let’s explore how each category might be implemented for the same task: a business analyst creating investment pitch slides. Here’s one possible approach for each:</p> <ul> <li> <code>Vertical</code> <code>workflow</code>: A fixed sequence of steps: First, makes a RAG query on a company database, passes this to a small LLM for summarization, then to a more capable LLM that extracts key numbers and uses a calculator tool. The LLM checks if these numbers make sense before writing slide content. Finally, a slide generator creates the presentation. This exact sequence runs every time.</li> <li> <code>Vertical</code> <code>agent</code>: An LLM runs in a loop, using its output from one iteration as input for the next. It has access to the same tools as the workflow version but decides for itself when to use them. The loop continues until the agent determines the results meet its quality threshold.</li> <li> <code>Horizontal</code> <code>workflow</code>: ChatGPT and similar tools could assist with parts of the task, but can’t complete it end-to-end. They lack both the specialization and autonomy needed for the full job.</li> <li> <code>Horizontal</code> <code>agent</code>: Claude computer-use gets access to standard company software. The analyst provides instructions in natural language, and the agent operates the computer like a human would, adapting its approach as needed.</li> </ul> <p>Almost all products at Demo Day fell into the vertical workflow category. This makes sense - current models aren’t reliable enough for other approaches. As a result, even problems too complex for vertical workflows are being forced into this mold since it’s the only way to get close to acceptable performance with current model capabilities. While engineering can improve these solutions, there’s an upper limit to what it can achieve. For problems that are out of reach with current models, the better strategy would be to wait for more capable models that can handle them with minimal engineering. As Leopold Aschenbrenner argues in “Situational Awareness,” for many problems, the engineering work will take longer than the wait for better models:</p> <p>“It seems plausible that the schlep will take longer than the unhobbling, that is, by the time the drop-in remote worker is able to automate a large number of jobs, intermediate models won’t yet have been fully harnessed and integrated”</p> <p>This pattern should sound familiar. Let’s return to the Bitter Lesson. AI researchers repeatedly tried to engineer their way to “acceptable performance,” only to be overtaken by more general solutions that simply used more compute. The parallel to how today’s AI products are built is striking. And we can make this connection even clearer by examining how the Bitter Lesson applies to our two types of constraints:</p> <table> <thead> <tr> <th>Bitter Lesson Observation</th> <th>Autonomy</th> <th>Specificity</th> </tr> </thead> <tbody> <tr> <td>1) AI researchers have often tried to build knowledge into their agents</td> <td>The developer experiments with an autonomous agent but finds it unreliable. Instead, they hardcode the execution steps to follow the workflow that they would go through themselves when solving the task.</td> <td>The developer starts building a general document analysis system but finds it unreliable. Instead, they constrain it to just analyze financial statements, hardcoding specific metrics and validation rules.</td> </tr> <tr> <td>2) This always helps in the short term and is personally satisfying to the researcher</td> <td>The developer finds that this increases reliability.</td> <td>The developer finds that specialization improves accuracy since the model only needs to handle a narrow set of documents and metrics.</td> </tr> <tr> <td>3) In the long run, it plateaus and even inhibits further progress</td> <td>The constrained workflow sometimes does not give the correct output when faced with novel situations that weren’t considered in the hardcoded steps.</td> <td>The specialized system can’t handle related tasks like analyzing merger documents or earnings calls, requiring separate specialized systems for each type of analysis.</td> </tr> <tr> <td>4) Breakthrough progress eventually arrives by an opposing approach based on scaling computation</td> <td>New model releases enable reliable agents that can figure out the right approach dynamically, backtracking and correcting mistakes as needed.</td> <td>New model releases can understand any business document holistically, extracting relevant information regardless of format or type, making specialized systems unnecessary.</td> </tr> </tbody> </table> <p>For problems with unclear solution paths, products with more autonomy will achieve better performance. Similarly, when dealing with large, complex input spaces, less specific products will perform better.</p> <p>This is the first in a four-part series examining the role of startups in AI. We’ve observed a historical pattern: AI models that leverage domain knowledge consistently get overtaken by those that leverage compute. Today’s AI products show striking parallels to this pattern.</p> <p>Though I’ve tried to focus on observations rather than opinions in this first part, my view likely shows through. Building software to compensate for current model limitations seems like fighting a losing battle, especially given how rapidly models are advancing. As Jarred, partner at YC, noted in the Lightcone podcast: “that first wave of LLM apps [vertical workflows] mostly did get crushed by the next wave of GPTs.”</p> <p>Sam Altman has repeatedly advocated for building startups that make you excited for releases of better models, rather than scared of them. Many of the founders in the AI application layer I speak to are excited about model releases, but for the sake of their startup, I don’t think they should be. They might be missing the insight from Figure 2; better models might actually reduce your edge, not enhance it. Of course, this is from the point of view of product performance - building something that can solve harder problems more effectively. In the next part, we’ll explore a different dimension: market adoption. After all, having better performance doesn’t guarantee winning the market.</p> <h3 id="appendix-a-statistical-view-of-the-bitter-lesson"><strong>Appendix A: Statistical View of The Bitter Lesson</strong></h3> <p>There’s another way to understand the Bitter Lesson using basic statistics. When building models, you typically face a tradeoff. You can either make a model that’s very precise in how it approaches problems (high bias) or one that’s more flexible but less predictable (high variance). The Bitter Lesson suggests choosing the flexible approach.</p> <p>Why? Because with more compute power and data, you can make flexible models more reliable. It’s like having more practice shots in basketball - eventually, you’ll become consistent even with a less rigid shooting form. The reverse isn’t true - a overly rigid approach will always be limited by its built-in assumptions.</p> <p>This maps directly to our discussion of AI products. Vertical workflows and specific constraints are like adding rigid rules - they make the AI more reliable now but limit how good it can eventually become. In contrast, letting AI operate more freely might seem risky today, but it allows the AI to find better solutions as models improve. As we’ve seen throughout this essay, betting against flexibility has historically been a losing strategy.</p> <h3 id="appendix-b-end-to-end-vs-feature-engineering"><strong>Appendix B: End-to-end vs Feature Engineering</strong></h3> <p><img src="https://lukaspetersson.com/assets/img/e2e.png" alt="e2e"/></p> <p><em>Figure 1: Comparison of traditional machine learning, which requires manual feature engineering, with deep learning’s end-to-end approach. The traditional approach needs humans to define what’s important in the data, while deep learning figures this out by itself.</em></p> <p>Traditional machine learning requires humans to decide what’s important in the data. You take raw input, like an image, and manually extract meaningful patterns or “features” - like counting specific shapes or measuring certain properties. Deep learning, in contrast, learns these patterns automatically.</p> <p><img src="https://lukaspetersson.com/assets/img/car-features.png" alt="car-features"/></p> <p><em>Figure 2: Self-driving car visualization showing feature extraction in action. The system identifies and tracks specific objects like cars, pedestrians, and lane markings. This represents the traditional approach of breaking down a complex problem into smaller, defined pieces.</em></p> <p>Let’s use self-driving cars as an example. You could build it two ways:</p> <ol> <li>Feature engineering: Break down what the car sees into specific pieces - where are the other cars, where are the lanes, how fast is that pedestrian moving?</li> <li>End-to-end: Feed raw video directly into a neural network and let it figure out how to drive.</li> </ol> <p>The feature engineering approach feels safer and more controlled. That’s why it dominated early AI. But as George Hotz observed: “if anything about the history of AI has taught us anything, it’s that feature engineering approaches will always be replaced and loose to end-to-end.”</p> <p><img src="https://lukaspetersson.com/assets/img/sholto.png" alt="sholto"/></p> <p><em>Figure 3: Tweet from Sholto Douglas</em></p> <p>This connects directly to our discussion of AI products. Building vertical-specific tools is like feature engineering - you’re deciding what information matters ahead of time. When you constrain a model’s autonomy, you’re doing the same thing. While this might work better today, history suggests betting on end-to-end approaches will win in the long run.</p> <p>Follow me on <a href="https://x.com/lukaspet" rel="external nofollow noopener" target="_blank">X</a> to stay updated.</p> </div> </article></div>
  </body>
</html>
