<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://karmanivero.us/projects/entity-manager/evolving-a-nosql-db-schema/">Original</a>
    <h1>Evolving a NoSQL Database Schema</h1>
    
    <div id="readability-page-1" class="page"><section itemprop="text">
        
          
        
        <figure>
    <img src="https://karmanivero.us/assets/collections/entity-manager/evolving-a-nosql-db-schema-square.jpg"/>
</figure>

<p><strong>Entity Manager</strong> works by interpreting your configured database schema in a very particular, very opinionated way.</p>

<p>By way of example, this section will start with a simple data model, evolve a database schema, and show you what <strong>Entity Manager</strong> would do with it.</p>

<p><a href="https://en.wikipedia.org/wiki/NoSQL">NoSQL</a> databases do not offer the <a href="https://karmanivero.us/projects/entity-manager/sql-vs-nosql">schema &amp; query abstractions</a> enjoyed by <a href="https://en.wikipedia.org/wiki/Relational_database">RDBMS</a> developers, so any NoSQL database schema will be intrinsically platform-specific. <strong>This example will evolve a database schema for the <a href="https://aws.amazon.com/dynamodb/">DynamoDB</a> platform</strong>, but the presented design <em>process</em> should work equally well against any NoSQL database platform.</p>

<p><strong>Entity Manager is still under construction!</strong> I’m wrapping up the Typescript refactor &amp; writing the demo &amp; documentation, so we should be ready for production in a few weeks. Meanwhile, please feel free to <a href="https://github.com/karmaniverous/entity-manager/discussions/">reach out</a> with any questions or feedback!</p>

<h2 id="a-microservices-application">A Microservices Application</h2>

<p>Imagine an application that tracks the credit card transactions of its users.</p>

<p>When a <strong>User</strong> performs a <strong>Credit Card</strong> or online shopping cart <strong>Transaction</strong>, the application rounds the Transaction amount to the nearest dollar and credits that amount to a <strong>Beneficiary</strong> chosen by the User. Online shopping cart Transactions can be related to the User by Credit Card and <strong>Email</strong>, so each User can have more than one Email, which must be unique in the system. Users also sign up with an Email, so there’s a particularly close relationship between Users and Emails.</p>

<p>FYI this example is actually a small slice of the real <a href="https://veterancrowd.com">VeteranCrowd</a> application, which uses <strong>Entity Manager</strong>’s previous JS version in production!</p>

<p>Here’s a breakdown of the entities &amp; relationships in the system. We’re building a microservices back end, so each entity will live on a specific service as indicated:</p>

<figure><img src="https://karmanivero.us/assets/diagrams/entity-manager-evolving-a-nosql-db-schema-services.png" alt=""/><figcaption>
      <em>Entity &amp; service relationships.</em>

    </figcaption></figure>

<p>For this example, we’re going to focus on the requirements of the User service.</p>

<h2 id="user-service-data-model">User Service Data Model</h2>

<p>Let’s focus narrowly on the User service data model. We need to account for:</p>

<ul>
  <li>the User and Email entities and their properties, and</li>
  <li>cases when either entity is the <em>many</em> side of a one-to-many relationship.</li>
</ul>

<p>Every entity has to have a unique identifier that doesn’t change. If there isn’t a natural fit with an existing entity property, we’ll use a <a href="https://github.com/ai/nanoid">nanoid</a>.</p>

<p>Here’s the resulting data model (see the entity notes below for more info):</p>

<figure><img src="https://karmanivero.us/assets/diagrams/entity-manager-evolving-a-nosql-db-schema-data-model.png" alt=""/><figcaption>
      <em>User service data model.</em>

    </figcaption></figure>

<h3 id="user-entity">User Entity</h3>

<table>
  <thead>
    <tr>
      <th>Property</th>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>beneficiaryId</code></td>
      <td><code>string</code></td>
      <td>The unique id of the Beneficiary related to the User. <em>This value is required but might change.</em></td>
    </tr>
    <tr>
      <td><code>created</code></td>
      <td><code>number</code></td>
      <td>Timestamp of record creation. <em>This value never changes!</em></td>
    </tr>
    <tr>
      <td><code>firstName</code></td>
      <td><code>string</code></td>
      <td>User first name.</td>
    </tr>
    <tr>
      <td><code>firstNameCanonical</code></td>
      <td><code>string</code></td>
      <td>User first name canonicalized for search.</td>
    </tr>
    <tr>
      <td><code>lastName</code></td>
      <td><code>string</code></td>
      <td>User last name.</td>
    </tr>
    <tr>
      <td><code>lastNameCanonical</code></td>
      <td><code>string</code></td>
      <td>User last name canonicalized for search.</td>
    </tr>
    <tr>
      <td><code>[phone]</code></td>
      <td><code>string</code></td>
      <td>Internationalized User phone.</td>
    </tr>
    <tr>
      <td><code>userId</code></td>
      <td><code>string</code></td>
      <td>Unique id of User. <em>This value never changes!</em></td>
    </tr>
    <tr>
      <td><code>updated</code></td>
      <td><code>number</code></td>
      <td>Timestamp of last record update.</td>
    </tr>
  </tbody>
</table>

<p><code>firstNameCanonical</code> and <code>lastNameCanonical</code> are provided to support searching for Users by name. Canonicalizing a name converts it to a consistent case and removes diacritical marks and non-word characters. So <em>Gómez-Juárez-Álvarez</em> becomes <em>gomezjuarezalvarez</em>.</p>

<p><strong><em>Why doesn’t Entity Manager perform canonicalization internally?</em></strong> All <strong>Entity Manager</strong> data transformations are <em>reversible</em> to support safe data migration. Canonicalization throws away data, so your application should perform any canonicalization <em>before</em> sending data to <strong>Entity Manager</strong>.</p>

<h3 id="email-entity">Email Entity</h3>

<table>
  <thead>
    <tr>
      <th>Property</th>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>created</code></td>
      <td><code>number</code></td>
      <td>Timestamp of record creation.</td>
    </tr>
    <tr>
      <td><code>email</code></td>
      <td><code>string</code></td>
      <td>Email address. <em>Unique by definition and never changes, so we can use this value as the record’s unique id.</em></td>
    </tr>
    <tr>
      <td><code>userId</code></td>
      <td><code>string</code></td>
      <td>Unique id of related User.</td>
    </tr>
  </tbody>
</table>

<p>An Email record has no <code>updated</code> property because no property on the Email record is subject to change.</p>

<h2 id="single-table-design">Single Table Design</h2>

<p>The primary job of a table in a relational database is to support <a href="https://karmanivero.us/projects/entity-manager/sql-vs-nosql">schema &amp; query abstraction</a>. Tables are intended to map cleanly to data entities, and <strong>it is the database engine’s job to organize the physical distribution of data</strong> to support efficient query operations.</p>

<blockquote>
  <p>To be highly available, data must be in one physical location.</p>
</blockquote>

<p>In a DynamoDB database (as with any NoSQL database) there is no such abstraction layer. Consequently, <strong>it is the developer’s job to organize the physical distribution of data</strong> to support efficient query operations.</p>

<p>In order to be physically “close” to one another in any meaningful sense, related DynamoDB records <em>must</em> be stored in the same table. This is the origin of the <a href="https://aws.amazon.com/blogs/compute/creating-a-single-table-design-with-amazon-dynamodb/">single-table design pattern</a>.</p>

<p>Entity Manager takes a highly opinionated approach to this pattern. We’ll start from the assumption that all User and Email entities <em>must</em> live on the same table, and the following sections will explain the design constraints at work in DynamoDB and how to implement a table design that Entity Manager can support.</p>

<h3 id="keys-indexes--queries">Keys, Indexes &amp; Queries</h3>

<p>A record in a DynamoDB table is uniquely identified by its <em>primary key</em>. This can take one of two forms, chosen at design time:</p>

<ul>
  <li>
    <p>a <strong>simple primary key</strong> is a single property that uniquely identifies the record. In DynamoDB-land, this is called the <em>partition key</em>. In more general NoSQL terms, this is a <em>hash key</em>.</p>
  </li>
  <li>
    <p>a <strong>composite primary key</strong> is a combination of two properties that uniquely identify the record. In DynamoDB-land, these are the <em>partition key</em> and the <em>sort key</em>. In more general NoSQL terms, these are respectively a <em>hash key</em> and a <em>range key</em>.</p>
  </li>
</ul>

<p>For reasons that will become clear below, <strong>Entity Manager requires a composite primary key for all data entities</strong>. To keep this discussion as general as possible, we’ll refer to its components as the <em>hash key</em> and the <em>range key</em>.</p>

<p>All high-performance NoSQL databases (including DynamoDB) make a clear distinction between two very different kinds of data retrieval operations:</p>

<ul>
  <li>
    <p><strong>Scan</strong> operations read <em>every</em> record in a table. At scale, finding an individual record with a scan is <em>very</em> slow and <em>very</em> expensive. <em>Scans are to be avoided whenever possible.</em></p>
  </li>
  <li>
    <p><strong>Query</strong> operations read <em>an ordered subset</em> of records in a table. At scale, finding an individual record with a query is <em>very</em> fast and <em>very</em> cheap. <em>Queries are the preferred way to access data in a NoSQL database.</em></p>
  </li>
</ul>

<p>In DynamoDB and other NoSQL databases, whatever else may be true, queries obey one hard rule: <strong>a query can only be performed on records with the same hash key!</strong></p>

<p>A query is performed on an <strong>index</strong> of the table. An index is a copy of the original table, in which:</p>

<ul>
  <li>
    <p>records are <em>partitioned</em> by their hash key values, and</p>
  </li>
  <li>
    <p>within each hash key partition, records are <em>sorted</em> by their range key values, and</p>
  </li>
  <li>
    <p>record properties not relevant to the index are left out.</p>
  </li>
</ul>

<p>We will discuss <a href="#secondary-indexes">secondary indexes</a> in the next section, but for now understand that a table’s most fundamental index is the table itself: its hash and sort keys are defined at table creation, and new records are added to the table in hash and range key order.</p>

<p>In a query:</p>

<ul>
  <li>
    <p>The hash key is <em>fixed</em>, so the return set is limited to records with a hash key value equal to the query’s hash key parameter.</p>
  </li>
  <li>
    <p>Within the constraints set by the hash key parameter, records are quickly compared to range key constraints to find records with range key values that are equal to, greater than, less than, or between the query’s range key parameters.</p>
  </li>
</ul>

<p>The most fundamental kind of query retrieves a single record of a given entity type by its unique identifier. Our table design must support this kind of query, therefore:</p>

<ul>
  <li>
    <p>A record’s <em>hash key</em> must identify its entity type, and</p>
  </li>
  <li>
    <p>A record’s <em>range key</em> must contain its unique identifier.</p>
  </li>
</ul>

<p>If you examine the User and Email entities in our <a href="#user-service-data-model">data model</a>, you’ll see that there is no property on either that identifies the entity type. We will need to create this property.</p>

<p>Also, while each entity has a unique identifier, these exist on <em>different</em> properties. DynamoDB expects to find a range key on the <em>same</em> property of every record. We will therefore need to create a new property for the range key as well.</p>

<p>Leaving out other properties, here’s what two such records might look like. The gear icon indicates a <em>generated property</em>:</p>

<table>
  <thead>
    <tr>
      <th>⚙️</th>
      <th>Property</th>
      <th>User Record</th>
      <th>Email Record</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td> </td>
      <td><code>email</code></td>
      <td> </td>
      <td><code>&#39;me@karmanivero.us&#39;</code></td>
    </tr>
    <tr>
      <td>⚙️</td>
      <td><code>hashKey</code></td>
      <td><code>&#39;user&#39;</code></td>
      <td><code>&#39;email&#39;</code></td>
    </tr>
    <tr>
      <td>⚙️</td>
      <td><code>rangeKey</code></td>
      <td><code>&#39;userId#wf5yU_5f63gqauSOLpP5O&#39;</code></td>
      <td><code>&#39;email#me@karmanivero.us&#39;</code></td>
    </tr>
    <tr>
      <td> </td>
      <td><code>userId</code></td>
      <td><code>&#39;wf5yU_5f63gqauSOLpP5O&#39;</code></td>
      <td><code>&#39;wf5yU_5f63gqauSOLpP5O&#39;</code></td>
    </tr>
  </tbody>
</table>

<p>Note that the generated <code>rangeKey</code> property value contains the unique property <em>name</em> as well as its value! This is an important <strong>Entity Manager</strong> feature that enables the safe construction of composite keys and super-efficient query at scale. More on this to come!</p>

<h3 id="secondary-indexes">Secondary Indexes</h3>

<p>In the previous section we constructed a table model with a built-in index that allows us to query the User service table for a single User or Email record by its unique identifier.</p>

<p>This is a good start, but here are a few other obvious cases we might need to support:</p>

<ul>
  <li>Find all User records created in the last 30 days.</li>
  <li>Find all User record whose first name starts with “J”.</li>
  <li>Find all Email records for a given User.</li>
  <li>Find all User records for a given Beneficiary.</li>
</ul>

<p>Remember that DynamoDB has <em>physically organized</em> our User service table data according to our primary key design. If we want to write a query that uses a different property as its hash or range key, we need to create a <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/SecondaryIndexes.html">secondary index</a>.</p>

<p>The technical details of secondary indexes are beyond the scope of this document but are easily accessible for your data platform. The sections below will focus on the relevant record properties and how Entity Manager interacts with them.</p>

<h4 id="simple-range-key-index">Simple Range Key Index</h4>

<p>A secondary index can be thought of as an automatically-maintained copy of its parent table that uses a different property for its hash key, its range key, or both.</p>

<p>If we’d like to find a list of Users created in the past 30 days, then we need an index that can:</p>

<ul>
  <li>differentiate by entity type, and</li>
  <li>sort by creation date.</li>
</ul>

<p>We could use the same argument to find users whose records were recently updated. And while we’re at it, we’d also like to be able to find a User by a piece of his phone number!</p>

<p>Here’s what the required indexes might look like:</p>

<table>
  <thead>
    <tr>
      <th>Index</th>
      <th>Entities</th>
      <th>Index Component</th>
      <th>Record Property</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>created</code></td>
      <td>Email &amp; User</td>
      <td>Hash Key</td>
      <td><code>hashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>created</code></td>
    </tr>
    <tr>
      <td><code>phone</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>hashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>phone</code></td>
    </tr>
    <tr>
      <td><code>updated</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>hashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>updated</code></td>
    </tr>
  </tbody>
</table>

<p>These indexes require us to generate no new properties beyond what we created above, and have the added advantage of allowing us to find Email records by creation date as well (remember, the Email entity has no <code>phone</code> or <code>updated</code> properties).</p>

<h4 id="composite-range-key-index">Composite Range Key Index</h4>

<p>Our next task is to create an index that lets us query User records by the first letter of <code>firstName</code>. This is a bit more complex.</p>

<p>Recall that every query implicitly includes a <em>sort</em> as well. How would we like our result set to be sorted?</p>

<p>Naively, we might consider an index like this:</p>

<table>
  <thead>
    <tr>
      <th>Index</th>
      <th>Entities</th>
      <th>Index Component</th>
      <th>Record Property</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>firstName</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>hashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>firstNameCanonical</code></td>
    </tr>
  </tbody>
</table>

<p>The problem with this approach is that, while the result set <em>will</em> be sorted by first name, all of the “John” records will appear in an effectively random order. Intuitively, we’d like those to appear in a useful order as well, say by <code>lastNameCanonical</code>.</p>

<p>To achieve this, we need to create a new property that combines <code>firstNameCanonical</code> and <code>lastNameCanonical</code> in a way that allows us to query by <code>firstNameCanonical</code> and sort by <code>lastNameCanonical</code>. Also, while we are at it, it probably makes sense to be able to do the same thing on the basis of <code>lastNameCanonical</code>.</p>

<p>Finally, as our system scales into millions of users, we will probably have more than one “John Smith” in the database. In these cases, it still makes sense to have some kind of rational sort, even if we won’t be likely to <em>search</em> on it. So let’s sort by <code>created</code> or <code>updated</code> in case of a tie.</p>

<p>Here are our sample records from above, with the relevant properties added:</p>

<table>
  <thead>
    <tr>
      <th>⚙️</th>
      <th>Property</th>
      <th>User Record</th>
      <th>Email Record</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td> </td>
      <td><code>created</code></td>
      <td><code>1726880933</code></td>
      <td><code>1726880947</code></td>
    </tr>
    <tr>
      <td> </td>
      <td><code>email</code></td>
      <td> </td>
      <td><code>&#39;me@karmanivero.us&#39;</code></td>
    </tr>
    <tr>
      <td> </td>
      <td><code>firstName</code></td>
      <td><code>&#39;Jason&#39;</code></td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td><code>firstNameCanonical</code></td>
      <td><code>&#39;jason&#39;</code></td>
      <td> </td>
    </tr>
    <tr>
      <td>⚙️</td>
      <td><code>firstNameRangeKey</code></td>
      <td><code>&#39;firstNameCanonical#jason       | lastNameCanonical#williscroft | created#1726880933&#39;</code></td>
      <td> </td>
    </tr>
    <tr>
      <td>⚙️</td>
      <td><code>hashKey</code></td>
      <td><code>&#39;user&#39;</code></td>
      <td><code>&#39;email&#39;</code></td>
    </tr>
    <tr>
      <td> </td>
      <td><code>lastName</code></td>
      <td><code>&#39;Williscroft&#39;</code></td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td><code>lastNameCanonical</code></td>
      <td><code>&#39;williscroft&#39;</code></td>
      <td> </td>
    </tr>
    <tr>
      <td>⚙️</td>
      <td><code>lastNameRangeKey</code></td>
      <td><code>&#39;lastNameCanonical#williscroft  | firstNameCanonical#jason      | created#1726880933&#39;</code></td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td><code>[phone]</code></td>
      <td><code>&#39;17739999999&#39;</code></td>
      <td> </td>
    </tr>
    <tr>
      <td>⚙️</td>
      <td><code>rangeKey</code></td>
      <td><code>&#39;userId#wf5yU_5f63gqauSOLpP5O&#39;</code></td>
      <td><code>&#39;email#me@karmanivero.us&#39;</code></td>
    </tr>
    <tr>
      <td> </td>
      <td><code>userId</code></td>
      <td><code>&#39;wf5yU_5f63gqauSOLpP5O&#39;</code></td>
      <td><code>&#39;wf5yU_5f63gqauSOLpP5O&#39;</code></td>
    </tr>
    <tr>
      <td> </td>
      <td><code>updated</code></td>
      <td><code>1726880933</code></td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>A couple of key points:</p>

<ul>
  <li>
    <p>I added some spacing in the range key values above to make them a little easier to read. In practice, <strong>Entity Manager</strong> concatenates these values without spaces!</p>
  </li>
  <li>
    <p>While the <code>created</code> property is a number, the generated <code>firstNameRangeKey</code> and <code>lastNameRangeKey</code> properties are necessarily strings! <strong>Entity Manager configures all generated properties as strings</strong>, but configures their non-string components so they sort correctly within the composite value. More on this in another section!</p>
  </li>
</ul>

<p>Here’s the full set of indexes our table now supports:</p>

<table>
  <thead>
    <tr>
      <th>Index</th>
      <th>Entities</th>
      <th>Index Component</th>
      <th>Record Property</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>created</code></td>
      <td>Email &amp; User</td>
      <td>Hash Key</td>
      <td><code>hashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>created</code></td>
    </tr>
    <tr>
      <td><code>firstName</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>hashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>firstNameRangeKey</code></td>
    </tr>
    <tr>
      <td><code>lastName</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>hashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>lastNameRangeKey</code></td>
    </tr>
    <tr>
      <td><code>phone</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>hashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>phone</code></td>
    </tr>
    <tr>
      <td><code>updated</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>hashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>updated</code></td>
    </tr>
  </tbody>
</table>

<h4 id="alternate-hash-key-index">Alternate Hash Key Index</h4>

<p>To find all email records for a given User, we have a couple of choices. Here’s one:</p>

<table>
  <thead>
    <tr>
      <th>Index</th>
      <th>Entities</th>
      <th>Index Component</th>
      <th>Record Property</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>user</code></td>
      <td>Email</td>
      <td>Hash Key</td>
      <td><code>hashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>userId</code></td>
    </tr>
  </tbody>
</table>

<p>If my query specifies a hash key of <code>email</code> a range constraint of <code>equal to &#39;wf5yU_5f63gqauSOLpP5O&#39;</code>, then my query will indeed return all email records for the User with <code>userId</code> equal to <code>&#39;wf5yU_5f63gqauSOLpP5O&#39;</code>. But there are a couple of problems with this approach:</p>

<ul>
  <li>
    <p>The range key values are a <a href="https://github.com/ai/nanoid">nanoid</a>: effectively a random string. This will allow me to find a match, but the resulting sort order is not likely to be useful.</p>
  </li>
  <li>
    <p>The range key constraint is operating against <em>all emails in the system</em>. A different choice of hash key would narrow this down and give us better performance.</p>
  </li>
</ul>

<p>Instead, let’s try this:</p>

<table>
  <thead>
    <tr>
      <th>Index</th>
      <th>Entities</th>
      <th>Index Component</th>
      <th>Record Property</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>userCreated</code></td>
      <td>Email</td>
      <td>Hash Key</td>
      <td><code>userId</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>created</code></td>
    </tr>
  </tbody>
</table>

<p>Setting these index hash keys to <code>userId</code> has <em>significantly</em> limited the record set any range key constraint is applied against. In fact, to satisfy the our test case (finding the Emails of a given User), we don’t need a range key constraint at all! The indexes will simply sort our records in a useful way, meaning by the Email record’s <code>created</code> timestamp.</p>

<p><em>Why didn’t we create a <code>userUpdated</code> index as well?</em> Because, since there is nothing to change on an Email record, we didn’t give it a <code>updated</code> property. So the index would be useless!</p>

<p>Note that we didn’t need to create any new generated properties to support this case.</p>

<h4 id="external-hash-key-index">External Hash Key Index</h4>

<p>Our final case was to find all User records for a given Beneficiary, sorted either by <code>created</code> or <code>updated</code>.</p>

<p>On one hand, this is interesting because <code>beneficiaryId</code> is a property of the Beneficiary entity, which lives on <a href="#a-microservices-application">another service</a>.</p>

<p>On the other hand, this should feel familiar: just as with <code>userId</code> above, we can use the hash keys on our new indexes to constrain the result sets down to just the User records we’re interested in.</p>

<p>Here’s the index:</p>

<table>
  <thead>
    <tr>
      <th>Index</th>
      <th>Entities</th>
      <th>Index Component</th>
      <th>Record Property</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>beneficiaryCreated</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>beneficiaryId</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>created</code></td>
    </tr>
    <tr>
      <td><code>beneficiaryUpdated</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>beneficiaryId</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>updated</code></td>
    </tr>
  </tbody>
</table>

<p>This indexes support:</p>

<ul>
  <li>
    <p>Finding the oldest or most- or least-recently created or updated User records for a given Beneficiary.</p>
  </li>
  <li>
    <p>Displaying a Beneficiary’s Users in the order they were created or updated.</p>
  </li>
</ul>

<p>While we’re at it, though, consider that a Beneficiary Manager will likely also want to sort and search related Users by name, and perhaps locate them by phone number. So let’s add these indexes as well:</p>

<table>
  <thead>
    <tr>
      <th>Index</th>
      <th>Entities</th>
      <th>Index Component</th>
      <th>Record Property</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>beneficiaryFirstName</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>beneficiaryId</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>firstNameRangeKey</code></td>
    </tr>
    <tr>
      <td><code>beneficiaryLastName</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>beneficiaryId</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>lastNameRangeKey</code></td>
    </tr>
    <tr>
      <td><code>beneficiaryPhone</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>beneficiaryId</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>phone</code></td>
    </tr>
  </tbody>
</table>

<h4 id="rounding-out-index-requirements">Rounding Out Index Requirements</h4>

<p>Here’s a recap of our table structure so far with generated properties:</p>

<table>
  <thead>
    <tr>
      <th>⚙️</th>
      <th>Property</th>
      <th>User Record</th>
      <th>Email Record</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td> </td>
      <td><code>beneficiaryId</code></td>
      <td><code>&#39;JCcwi4vyqwMJdaBwbjLG3&#39;</code></td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td><code>created</code></td>
      <td><code>1726880933</code></td>
      <td><code>1726880947</code></td>
    </tr>
    <tr>
      <td> </td>
      <td><code>email</code></td>
      <td> </td>
      <td><code>&#39;me@karmanivero.us&#39;</code></td>
    </tr>
    <tr>
      <td> </td>
      <td><code>firstName</code></td>
      <td><code>&#39;Jason&#39;</code></td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td><code>firstNameCanonical</code></td>
      <td><code>jason</code></td>
      <td> </td>
    </tr>
    <tr>
      <td>⚙️</td>
      <td><code>firstNameRangeKey</code></td>
      <td><code>&#39;firstNameCanonical#jason       | lastNameCanonical#williscroft | created#1726880933&#39;</code></td>
      <td> </td>
    </tr>
    <tr>
      <td>⚙️</td>
      <td><code>hashKey</code></td>
      <td><code>&#39;user&#39;</code></td>
      <td><code>&#39;email&#39;</code></td>
    </tr>
    <tr>
      <td> </td>
      <td><code>lastName</code></td>
      <td><code>&#39;Williscroft&#39;</code></td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td><code>lastNameCanonical</code></td>
      <td><code>&#39;williscroft&#39;</code></td>
      <td> </td>
    </tr>
    <tr>
      <td>⚙️</td>
      <td><code>lastNameRangeKey</code></td>
      <td><code>&#39;lastNameCanonical#williscroft  | firstNameCanonical#jason      | created#1726880933&#39;</code></td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td><code>[phone]</code></td>
      <td><code>&#39;17739999999&#39;</code></td>
      <td> </td>
    </tr>
    <tr>
      <td>⚙️</td>
      <td><code>rangeKey</code></td>
      <td><code>&#39;userId#wf5yU_5f63gqauSOLpP5O&#39;</code></td>
      <td><code>&#39;email#me@karmanivero.us&#39;</code></td>
    </tr>
    <tr>
      <td> </td>
      <td><code>updated</code></td>
      <td><code>1726880933</code></td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td><code>userId</code></td>
      <td><code>&#39;wf5yU_5f63gqauSOLpP5O&#39;</code></td>
      <td><code>&#39;wf5yU_5f63gqauSOLpP5O&#39;</code></td>
    </tr>
  </tbody>
</table>

<p>Here’s a consolidated list of the resulting indexes:</p>

<table>
  <thead>
    <tr>
      <th>Index</th>
      <th>Entities</th>
      <th>Index Component</th>
      <th>Record Property</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>beneficiaryCreated</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>beneficiaryId</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>created</code></td>
    </tr>
    <tr>
      <td><code>beneficiaryFirstName</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>beneficiaryId</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>firstNameRangeKey</code></td>
    </tr>
    <tr>
      <td><code>beneficiaryLastName</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>beneficiaryId</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>lastNameRangeKey</code></td>
    </tr>
    <tr>
      <td><code>beneficiaryPhone</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>beneficiaryId</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>phone</code></td>
    </tr>
    <tr>
      <td><code>beneficiaryUpdated</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>beneficiaryId</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>updated</code></td>
    </tr>
    <tr>
      <td><code>created</code></td>
      <td>Email &amp; User</td>
      <td>Hash Key</td>
      <td><code>hashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>created</code></td>
    </tr>
    <tr>
      <td><code>firstName</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>hashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>firstNameRangeKey</code></td>
    </tr>
    <tr>
      <td><code>lastName</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>hashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>lastNameRangeKey</code></td>
    </tr>
    <tr>
      <td><code>phone</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>hashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>lastNameRangeKey</code></td>
    </tr>
    <tr>
      <td><code>updated</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>hashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>updated</code></td>
    </tr>
    <tr>
      <td><code>userCreated</code></td>
      <td>Email</td>
      <td>Hash Key</td>
      <td><code>userId</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>created</code></td>
    </tr>
  </tbody>
</table>

<p>One thing we haven’t discussed yet is <a href="https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Projection.html"><em>projection</em></a>. Once your query has applied hash &amp; range key constraints, you may wish to filter the result set by additional properties. These properties will need to be included in the index.</p>

<p>We’ll address this in a later section.</p>

<h3 id="partition-limits">Partition Limits</h3>

<p>So far we have ignored a major issue related to scale.</p>

<p>In <a href="#keys-indexes--queries">Keys, Indexes &amp; Queries</a> above we observed that a NoSQL table or index always partitions data by its hash key value. We also pointed out that any query is always constrained to a single hash key value, also known as a <em>data partition</em>. These observations drove the index design process above.</p>

<p>Here’s the issue: <strong>in a real-world NoSQL database, there is a limit to the maximum size of a data partition!</strong></p>

<p>In DynamoDB, the maximum size of a data partition is 10 GB. <a href="https://repost.aws/questions/QUx0mIILjaR5GjwYllYNpbKA/in-dynamodb-what-s-partition-size-limitation-of-a-table-without-lsi">In the presence of a Local Secondary Index</a> (LSI), this imposes a hard limit on the amount of data that can be indexed by a single hash key value. Without an LSI, hash key values can cross partition lines, but you will still pay a performance penalty for doing so.</p>

<blockquote>
  <p>Even if your specific database design theoretically permits infinite partition size, it’s a good practice to keep partition sizes under control.</p>
</blockquote>

<p>Here’s a breakdown of the storage requirements so far for our example User record:</p>

<table>
  <thead>
    <tr>
      <th>⚙️</th>
      <th>Property</th>
      <th>User Record</th>
      <th>Bytes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td> </td>
      <td><code>beneficiaryId</code></td>
      <td><code>&#39;JCcwi4vyqwMJdaBwbjLG3&#39;</code></td>
      <td>21</td>
    </tr>
    <tr>
      <td> </td>
      <td><code>created</code></td>
      <td><code>1726880933</code></td>
      <td>8</td>
    </tr>
    <tr>
      <td> </td>
      <td><code>firstName</code></td>
      <td><code>&#39;Jason&#39;</code></td>
      <td>5</td>
    </tr>
    <tr>
      <td> </td>
      <td><code>firstNameCanonical</code></td>
      <td><code>&#39;jason&#39;</code></td>
      <td>5</td>
    </tr>
    <tr>
      <td>⚙️</td>
      <td><code>firstNameRangeKey</code></td>
      <td><code>&#39;firstNameCanonical#jason       | lastNameCanonical#williscroft | created#1726880933&#39;</code></td>
      <td>49</td>
    </tr>
    <tr>
      <td>⚙️</td>
      <td><code>hashKey</code></td>
      <td><code>&#39;user&#39;</code></td>
      <td>4</td>
    </tr>
    <tr>
      <td> </td>
      <td><code>lastName</code></td>
      <td><code>&#39;Williscroft&#39;</code></td>
      <td>11</td>
    </tr>
    <tr>
      <td> </td>
      <td><code>lastNameCanonical</code></td>
      <td><code>&#39;williscroft&#39;</code></td>
      <td>11</td>
    </tr>
    <tr>
      <td>⚙️</td>
      <td><code>lastNameRangeKey</code></td>
      <td><code>&#39;lastNameCanonical#williscroft  |      firstNameCanonical#jason | created#1726880933&#39;</code></td>
      <td>49</td>
    </tr>
    <tr>
      <td>⚙️</td>
      <td><code>rangeKey</code></td>
      <td><code>&#39;userId#wf5yU_5f63gqauSOLpP5O&#39;</code></td>
      <td>28</td>
    </tr>
    <tr>
      <td> </td>
      <td><code>phone</code></td>
      <td><code>&#39;17739999999&#39;</code></td>
      <td>11</td>
    </tr>
    <tr>
      <td> </td>
      <td><code>updated</code></td>
      <td><code>1726880933</code></td>
      <td>8</td>
    </tr>
    <tr>
      <td> </td>
      <td><code>userId</code></td>
      <td><code>&#39;wf5yU_5f63gqauSOLpP5O&#39;</code></td>
      <td>21</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td><strong>Total</strong></td>
      <td><strong>231</strong></td>
    </tr>
  </tbody>
</table>

<p>Let’s nearly double this to 512 bytes (0.5 KB) per record, to account for name &amp; phone variations and the addition of a few new User properties and indexes. With this record size, we can fit 20 million User records into the single partition defined by a <code>hashKey</code> value of <code>user</code>.</p>

<p><strong>Keep in mind that our sample User record is very small!</strong> The maximum size of a DynamoDB record is 400 KB. If your records approach this size, you only have room for 25,000 records in each data partition!</p>

<p>By contrast, <strong>Facebook has around 3 <em>billion</em> users!</strong> So if Facebook were implemented on DynamoDB with a similar User record size, it would need at least 150 partitions to store all of its User records!</p>

<p>How would this work?</p>

<p>The answer: create a <strong>shard key</strong>.</p>

<h3 id="shard-keys">Shard Keys</h3>

<p>We’ve already established that a <em>data partition</em> is defined by a unique hash key value on a table or an index. To <em>shard</em> the hash key means to give it a slightly different value on different records.</p>

<p>For example:</p>

<table>
  <thead>
    <tr>
      <th>⚙️</th>
      <th>Property</th>
      <th>User Record 1</th>
      <th>User Record 2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>⚙️</td>
      <td><code>hashKey</code></td>
      <td><code>&#39;user!1&#39;</code></td>
      <td><code>&#39;user!2&#39;</code></td>
    </tr>
  </tbody>
</table>

<p>Now, as long as we are careful about assigning shard keys <code>&#39;1&#39;</code> and <code>&#39;2&#39;</code> to the underlying hash key, we can have as many User records as we like without exceeding the partition size limit!</p>

<p>Unfortunately, we’ve also introduced some new problems:</p>

<ul>
  <li>
    <p>How do we know which shard key to assign to a given User record?</p>
  </li>
  <li>
    <p>How do we apply the shard key to alternate hash keys?</p>
  </li>
  <li>
    <p>We can only query a single sharded hash key at a time. So how can our application efficiently search User records across <em>all</em> shard keys?</p>
  </li>
</ul>

<h4 id="deterministic-sharding">Deterministic Sharding</h4>

<p>As presented above, the shard key is really a component of the hash key. And the value of a record’s hash key is <em>fixed:</em> it must be present at record creation, and it can’t change over the life of the record!</p>

<p>So the shard key must be determined at the time of record creation. It must also be drawn from a limited set of possible values, since each unique shard key value produces an additional data partition that must be queried in parallel to search across all partitions.</p>

<p><strong>Entity Manager</strong> solves this problem by applying a <a href="https://en.wikipedia.org/wiki/Hash_function">hash function</a> to the record’s unique identifier (in this case <code>userId</code> or <code>email</code>), and constraining the output to a limited set of possible values.</p>

<p>So in this example, given an appropriate <strong>Entity Manager</strong> configuration, a <code>userId</code> value of <code>&#39;wf5yU_5f63gqauSOLpP5O&#39;</code> will <em>always</em> produce a <code>hashKey</code> value of <code>&#39;user!1&#39;</code>, and a <code>userId</code> value of <code>&#39;SUv7FfJDUsWOmfQg2wp7o&#39;</code> will <em>always</em> produce a <code>hashKey</code> value of <code>&#39;user!2&#39;</code>.</p>

<p>More on this in a later section!</p>

<h4 id="alternate-hash-keys">Alternate Hash Keys</h4>

<p>In <a href="#secondary-indexes">Secondary Indexes</a> above we created the following indexes that use an alternate User property (marked with 👈) as the index hash key:</p>

<table>
  <thead>
    <tr>
      <th>Index</th>
      <th>Entities</th>
      <th>Index Component</th>
      <th>Record Property</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>beneficiaryCreated</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>beneficiaryId</code> 👈</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>created</code></td>
    </tr>
    <tr>
      <td><code>beneficiaryFirstName</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>beneficiaryId</code> 👈</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>firstNameRangeKey</code></td>
    </tr>
    <tr>
      <td><code>beneficiaryLastName</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>beneficiaryId</code> 👈</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>lastNameRangeKey</code></td>
    </tr>
    <tr>
      <td><code>beneficiaryPhone</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>beneficiaryId</code> 👈</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>phone</code></td>
    </tr>
    <tr>
      <td><code>beneficiaryUpdated</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>beneficiaryId</code> 👈</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>updated</code></td>
    </tr>
    <tr>
      <td><code>userCreated</code></td>
      <td>Email</td>
      <td>Hash Key</td>
      <td><code>userId</code> 👈</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>created</code></td>
    </tr>
  </tbody>
</table>

<p>But since the records in these indexes have approximately the same cardinality as the User table itself, they <em>also</em> need to be sharded!</p>

<p>Every indexed record contains a copy of the record’s primary key, so even an index like <code>beneficiaryCreated</code> that does not reference <code>userId</code> directly will still contain that property and can be sharded on the basis of its value.</p>

<p>We can therefore update our generated fields and index definitions to account for sharding across of all indexes on the User service table.</p>

<p>Here’s the updated set of User service table properties. I’ve marked the new and updated hash key properties with a 👉:</p>

<table>
  <thead>
    <tr>
      <th>⚙️</th>
      <th>Property</th>
      <th>User Record</th>
      <th>Email Record</th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td> </td>
      <td><code>beneficiaryId</code></td>
      <td><code>&#39;JCcwi4vyqwMJdaBwbjLG3&#39;</code></td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td><code>created</code></td>
      <td><code>1726880933</code></td>
      <td><code>1726880947</code></td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td><code>email</code></td>
      <td> </td>
      <td><code>&#39;me@karmanivero.us&#39;</code></td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td><code>firstName</code></td>
      <td><code>&#39;Jason&#39;</code></td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td><code>firstNameCanonical</code></td>
      <td><code>jason</code></td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>⚙️</td>
      <td><code>firstNameRangeKey</code></td>
      <td><code>&#39;firstNameCanonical#jason       | lastNameCanonical#williscroft         | created#1726880933&#39;</code></td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>⚙️</td>
      <td><code>hashKey</code></td>
      <td><code>&#39;user!1&#39;</code></td>
      <td><code>&#39;email!&#39;</code></td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td><code>lastName</code></td>
      <td><code>&#39;Williscroft&#39;</code></td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td><code>lastNameCanonical</code></td>
      <td><code>&#39;williscroft&#39;</code></td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>⚙️</td>
      <td><code>lastNameRangeKey</code></td>
      <td><code>&#39;lastNameCanonical#williscroft  | firstNameCanonical#jason              | created#1726880933&#39;</code></td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td><code>[phone]</code></td>
      <td><code>&#39;17739999999&#39;</code></td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>⚙️</td>
      <td><code>rangeKey</code></td>
      <td><code>&#39;userId#wf5yU_5f63gqauSOLpP5O&#39;</code></td>
      <td><code>&#39;email#me@karmanivero.us&#39;</code></td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td><code>updated</code></td>
      <td><code>1726880933</code></td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>⚙️</td>
      <td><code>userBeneficiaryHashKey</code></td>
      <td><code>&#39;user!1                         | beneficiaryId#JCcwi4vyqwMJdaBwbjLG3&#39;</code></td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td><code>userId</code></td>
      <td><code>&#39;wf5yU_5f63gqauSOLpP5O&#39;</code></td>
      <td><code>&#39;wf5yU_5f63gqauSOLpP5O&#39;</code></td>
      <td> </td>
    </tr>
    <tr>
      <td>⚙️</td>
      <td><code>userHashKey</code></td>
      <td><code>&#39;user!1                         | userId#wf5yU_5f63gqauSOLpP5O&#39;</code></td>
      <td><code>&#39;user!1             | userId#wf5yU_5f63gqauSOLpP5O&#39;</code></td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>Note the new value of <code>hashKey</code> for the Email record: <code>&#39;email!&#39;</code>.</p>

<p>So far we’ve addressed sharding on the <em>User</em> entity. Since an Email record is so much smaller, we can fit a <em>lot</em> more Email records into an individual partition. So for now we are assuming that Email records are <em>unsharded</em>, resulting in an empty shard key.</p>

<p>This illustrates an important <strong>Entity Manager</strong> feature: <strong>entities in your Entity Manager configuration can be sharded <em>independently</em></strong>, even though they occupy the same database table!</p>

<p>Here are the resulting User service table indexes, adjusted for the presence of the new alternate hash key. I marked the changes with a 👈:</p>

<table>
  <thead>
    <tr>
      <th>Index</th>
      <th>Entities</th>
      <th>Index Component</th>
      <th>Record Property</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>created</code></td>
      <td>Email &amp; User</td>
      <td>Hash Key</td>
      <td><code>hashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>created</code></td>
    </tr>
    <tr>
      <td><code>firstName</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>hashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>firstNameRangeKey</code></td>
    </tr>
    <tr>
      <td><code>lastName</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>hashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>lastNameRangeKey</code></td>
    </tr>
    <tr>
      <td><code>phone</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>hashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>phone</code></td>
    </tr>
    <tr>
      <td><code>updated</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>hashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>updated</code></td>
    </tr>
    <tr>
      <td><code>userBeneficiaryCreated</code> 👈</td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>userBeneficiaryHashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>created</code></td>
    </tr>
    <tr>
      <td><code>userBeneficiaryFirstName</code> 👈</td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>userBeneficiaryHashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>firstNameRangeKey</code></td>
    </tr>
    <tr>
      <td><code>userBeneficiaryLastName</code> 👈</td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>userBeneficiaryHashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>lastNameRangeKey</code></td>
    </tr>
    <tr>
      <td><code>userBeneficiaryPhone</code> 👈</td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>userBeneficiaryHashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>phone</code></td>
    </tr>
    <tr>
      <td><code>userBeneficiaryUpdated</code> 👈</td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>userBeneficiaryHashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>updated</code></td>
    </tr>
    <tr>
      <td><code>userCreated</code> 👈</td>
      <td>Email</td>
      <td>Hash Key</td>
      <td><code>userHashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>created</code></td>
    </tr>
  </tbody>
</table>

<p>Note the absence of a <code>userPhone</code> index. We would only want this if we needed to:</p>

<ul>
  <li>search for user emails directly by user phone number, or</li>
  <li>sort user emails by user phone number.</li>
</ul>

<p>Both of these cases feel like a step too far, so we won’t bother.</p>

<h4 id="cross-shard-querying">Cross-Shard Querying</h4>

<p>We still have one significant problem left to solve: if we’ve scaled like Facebook to 150 User service table partitions, and we can only query a single partition at a time, <strong>how can we efficiently search across all partitions?</strong></p>

<p>The bad news is: <strong><em>we CAN’T!</em></strong></p>

<p>On a NoSQL platform like DynamoDB, a query is <em>always</em> constrained to a single data partition. So if we want to search across 150 partitions, we’re just going to have to run a similar-but-different query on every… single… one.</p>

<p><strong>In practice, the problem is even worse!</strong> DynamoDB queries are <em>paged</em>, meaning that a single query returns only a limited number of records, along with a <em>page key</em> indicating where along the result set (which is sorted by range key) to start the next query.</p>

<p>So a search across 150 partitions is really a <em>paged</em> search across 150 partitions, where each result set is only sorted within its own partition and returns its own, independent page key.</p>

<p>For the sake of efficiency, you might also want to search across multiple <em>indexes</em>. For example, say you want to match a User record to a fragment of a name. Best to search across both the <code>firstName</code> and <code>lastName</code> indexes, eliminate any duplicates, and combine the results!</p>

<blockquote>
  <p><strong>Entity Manager</strong> reduces this problem to formulating a simple query on a single shard against a single index.</p>
</blockquote>

<p>Consequently, after conducting this massive parallel query, involving 150 partitions and two indexes, the developer must:</p>

<ul>
  <li>
    <p>dedupe &amp; sort the result set, and</p>
  </li>
  <li>
    <p>pass the entire set of page keys to the calling process, and</p>
  </li>
  <li>
    <p>pass the same page keys to the <em>next</em> query to retrieve the next page of results.</p>
  </li>
</ul>

<p>Here’s the good news: <strong><em>Entity Manager CAN!</em></strong></p>

<p>With <strong>Entity Manager</strong> in place, a developer need only focus on formulating a <em>simple</em> query on a <em>single</em> shard against a <em>single</em> index.</p>

<p><strong>Entity Manager</strong> will:</p>

<ul>
  <li>
    <p>construct and execute throttled, parallel queries against all relevant indexes across the entire effective shard key space, and</p>
  </li>
  <li>
    <p>dedupe &amp; sort the result set, and</p>
  </li>
  <li>
    <p>return the result set along with a <em>page key map</em> (a highly-compressed string representation of all the page keys) that can easily be passed back to Entity Manager to retrieve the next page of results.</p>
  </li>
</ul>

<h2 id="recap">Recap</h2>

<p>We started with a two-entity data model including both internal and external relationships.</p>

<p>We then applied the <a href="https://aws.amazon.com/blogs/compute/creating-a-single-table-design-with-amazon-dynamodb/">single table design pattern</a> to evolve a table and index structure that supports:</p>

<ul>
  <li>all necessary queries on User and Email records, and</li>
  <li>the ability to shard User and Email records independently across multiple partitions, and</li>
  <li>the ability to search across all partitions and indexes in a single query.</li>
  <li>automated generation of all necessary properties to support the above.</li>
</ul>

<p>Upcoming pages will dig deeply into how <strong>Entity Manager</strong> can be configured to support this model. For now, the following sections recap our design.</p>

<h3 id="data-model">Data Model</h3>

<figure><img src="https://karmanivero.us/assets/diagrams/entity-manager-evolving-a-nosql-db-schema-data-model.png" alt=""/><figcaption>
      <em>User service data model.</em>

    </figcaption></figure>

<h3 id="table-properties">Table Properties</h3>

<table>
  <thead>
    <tr>
      <th>⚙️</th>
      <th>Property</th>
      <th>User Record</th>
      <th>Email Record</th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td> </td>
      <td><code>beneficiaryId</code></td>
      <td><code>&#39;JCcwi4vyqwMJdaBwbjLG3&#39;</code></td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td><code>created</code></td>
      <td><code>1726880933</code></td>
      <td><code>1726880947</code></td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td><code>email</code></td>
      <td> </td>
      <td><code>&#39;me@karmanivero.us&#39;</code></td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td><code>firstName</code></td>
      <td><code>&#39;Jason&#39;</code></td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td><code>firstNameCanonical</code></td>
      <td><code>&#39;jason&#39;</code></td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>⚙️</td>
      <td><code>firstNameRangeKey</code></td>
      <td><code>&#39;firstNameCanonical#jason       | lastNameCanonical#williscroft         | created#1726880933&#39;</code></td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>⚙️</td>
      <td><code>hashKey</code></td>
      <td><code>&#39;user!1&#39;</code></td>
      <td><code>&#39;email!&#39;</code></td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td><code>lastName</code></td>
      <td><code>&#39;Williscroft&#39;</code></td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td><code>lastNameCanonical</code></td>
      <td><code>&#39;williscroft&#39;</code></td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>⚙️</td>
      <td><code>lastNameRangeKey</code></td>
      <td><code>&#39;lastNameCanonical#williscroft  | firstNameCanonical#jason              | created#1726880933&#39;</code></td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td><code>[phone]</code></td>
      <td><code>&#39;17739999999&#39;</code></td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>⚙️</td>
      <td><code>rangeKey</code></td>
      <td><code>&#39;userId#wf5yU_5f63gqauSOLpP5O&#39;</code></td>
      <td><code>&#39;email#me@karmanivero.us&#39;</code></td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td><code>updated</code></td>
      <td><code>1726880933</code></td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>⚙️</td>
      <td><code>userBeneficiaryHashKey</code></td>
      <td><code>&#39;user!1                         | beneficiaryId#JCcwi4vyqwMJdaBwbjLG3&#39;</code></td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td><code>userId</code></td>
      <td><code>&#39;wf5yU_5f63gqauSOLpP5O&#39;</code></td>
      <td><code>&#39;wf5yU_5f63gqauSOLpP5O&#39;</code></td>
      <td> </td>
    </tr>
    <tr>
      <td>⚙️</td>
      <td><code>userHashKey</code></td>
      <td><code>&#39;user!1                         | userId#wf5yU_5f63gqauSOLpP5O&#39;</code></td>
      <td><code>&#39;user!1             | userId#wf5yU_5f63gqauSOLpP5O&#39;</code></td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h3 id="indexes">Indexes</h3>

<p>We will make one final adjustment here.</p>

<p>Recall that this database schema specifically addresses the DynamoDB platform, and that an important reason why the Entity Manager configuration supports index definition is to support the dehydration &amp; rehydration of page keys generated by searches on those indexes.</p>

<p>In DynamoDB, a page key <em>always</em> includes the hash and range keys of the record, even if the search was performed along an index that includes neither. To support a DynamoDB implementation, therefore, the Entity Manager configuration should always include both the hash and range keys of the record in the index definition.</p>

<p>We will add these below where they are missing.</p>

<table>
  <thead>
    <tr>
      <th>Index</th>
      <th>Entities</th>
      <th>Index Component</th>
      <th>Record Property</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>created</code></td>
      <td>Email &amp; User</td>
      <td>Hash Key</td>
      <td><code>hashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>created</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Page Key</td>
      <td><code>rangeKey</code></td>
    </tr>
    <tr>
      <td><code>firstName</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>hashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>firstNameRangeKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Page Key</td>
      <td><code>rangeKey</code></td>
    </tr>
    <tr>
      <td><code>lastName</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>hashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>lastNameRangeKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Page Key</td>
      <td><code>rangeKey</code></td>
    </tr>
    <tr>
      <td><code>phone</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>hashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>phone</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Page Key</td>
      <td><code>rangeKey</code></td>
    </tr>
    <tr>
      <td><code>updated</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>hashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>updated</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Page Key</td>
      <td><code>rangeKey</code></td>
    </tr>
    <tr>
      <td><code>userBeneficiaryCreated</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>userBeneficiaryHashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>created</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Page Key</td>
      <td><code>hashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Page Key</td>
      <td><code>rangeKey</code></td>
    </tr>
    <tr>
      <td><code>userBeneficiaryFirstName</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>userBeneficiaryHashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>firstNameRangeKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Page Key</td>
      <td><code>hashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Page Key</td>
      <td><code>rangeKey</code></td>
    </tr>
    <tr>
      <td><code>userBeneficiaryLastName</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>userBeneficiaryHashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>lastNameRangeKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Page Key</td>
      <td><code>hashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Page Key</td>
      <td><code>rangeKey</code></td>
    </tr>
    <tr>
      <td><code>userBeneficiaryPhone</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>userBeneficiaryHashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>phone</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Page Key</td>
      <td><code>hashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Page Key</td>
      <td><code>rangeKey</code></td>
    </tr>
    <tr>
      <td><code>userBeneficiaryUpdated</code></td>
      <td>User</td>
      <td>Hash Key</td>
      <td><code>userBeneficiaryHashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>updated</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Page Key</td>
      <td><code>hashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Page Key</td>
      <td><code>rangeKey</code></td>
    </tr>
    <tr>
      <td><code>userCreated</code></td>
      <td>Email</td>
      <td>Hash Key</td>
      <td><code>userHashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Range Key</td>
      <td><code>created</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Page Key</td>
      <td><code>hashKey</code></td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>Page Key</td>
      <td><code>rangeKey</code></td>
    </tr>
  </tbody>
</table>

        
      </section></div>
  </body>
</html>
