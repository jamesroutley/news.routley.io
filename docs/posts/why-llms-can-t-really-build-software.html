<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zed.dev/blog/why-llms-cant-build-software">Original</a>
    <h1>Why LLMs can&#39;t really build software</h1>
    
    <div id="readability-page-1" class="page"><article><p>One of the things I have spent a lot of time doing is interviewing software engineers. This is obviously a hard task, and I don’t claim to have a magic solution; but it’s given me some time to reflect on what effective software engineers actually do.</p>
<h2 id="the-software-engineering-loop"><a href="#the-software-engineering-loop" aria-label="Copy heading link"><span><svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" x2="20" y1="9" y2="9"></line><line x1="4" x2="20" y1="15" y2="15"></line><line x1="10" x2="8" y1="3" y2="21"></line><line x1="16" x2="14" y1="3" y2="21"></line></svg></span><span>The Software Engineering Loop</span></a></h2>
<p>When you watch someone who knows what they are doing, you&#39;ll see them looping over the following steps:</p>
<ol>
<li>Build a mental model of the requirements</li>
<li>Write code that (hopefully?!) does that</li>
<li>Build a mental model of what the code actually does</li>
<li>Identify the differences, and update the code (or the requirements).</li>
</ol>
<p>There are lots of different ways to do these things, but the distinguishing factor of effective engineers is their ability to build and maintain clear mental models.</p>
<h2 id="how-about-llms"><a href="#how-about-llms" aria-label="Copy heading link"><span><svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" x2="20" y1="9" y2="9"></line><line x1="4" x2="20" y1="15" y2="15"></line><line x1="10" x2="8" y1="3" y2="21"></line><line x1="16" x2="14" y1="3" y2="21"></line></svg></span><span>How about LLMs?</span></a></h2>
<p>To be fair, LLMs are quite good at writing code. They&#39;re also reasonably good at updating code when you identify the problem to fix. They can also do all the things that real software engineers do: read the code, write and run tests, add logging, and (presumably) use a debugger.</p>
<p>But what they cannot do is maintain clear mental models.</p>
<p>LLMs get endlessly confused: they assume the code they wrote actually works; when test fail, they are left guessing as to whether to fix the code or the tests; and when it gets frustrating, they just delete the whole lot and start over.</p>
<p>This is exactly the opposite of what I am looking for.</p>
<p>Software engineers test their work as they go. When tests fail, they can check in with their mental model to decide whether to fix the code or the tests, or just to gather more data before making a decision. When they get frustrated, they can reach for help by talking things through. And although sometimes they do delete it all and start over, they do so with a clearer understanding of the problem.</p>
<h2 id="but-soon-right"><a href="#but-soon-right" aria-label="Copy heading link"><span><svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" x2="20" y1="9" y2="9"></line><line x1="4" x2="20" y1="15" y2="15"></line><line x1="10" x2="8" y1="3" y2="21"></line><line x1="16" x2="14" y1="3" y2="21"></line></svg></span><span>But soon, right?</span></a></h2>
<p>Will this change as models become more capable? Perhaps?? But I think it&#39;s going to require a change in how models are built and optimized. Software engineering requires models that can do more than just generate code.</p>
<p>When a person runs into a problem, they are able to temporarily stash the full context, focus on resolving the issue, and then pop their mental stack to get back to the problem in hand. They are also able to zoom out and focus on the big picture, allowing the details to temporarily disappear, diving into small pieces as necessary. We don&#39;t just keep adding more words to our context window, because it would drive us mad.</p>
<p>Even if it wasn&#39;t just too much context to deal with, we know that current generative models suffer from several issues that directly impact their ability to maintain clear mental models:</p>
<ul>
<li><strong>Context omission</strong>: <a href="https://xinjie-shen.com/post/llmfail2acquirecontext/">Models are bad at finding omitted context</a>.</li>
<li><strong>Recency bias</strong>: <a href="https://arxiv.org/html/2405.20612v1">They suffer a strong recency bias</a> in the context window.</li>
<li><strong>Hallucination</strong>: <a href="https://arxiv.org/abs/2401.11817">They commonly hallucinate</a> details that should not be there.</li>
</ul>
<p>These are hopefully not insurmountable problems, and work is being done on adding <a href="https://research.ibm.com/blog/memory-augmented-LLMs">memory</a> to let them perform similar mental tricks to us.
Unfortunately, for now, they cannot (<a href="https://machinelearning.apple.com/research/illusion-of-thinking">beyond a certain complexity</a>) actually understand what is going on.</p>
<p>They cannot build software because they cannot maintain two similar &#34;mental models&#34;, identify the differences, and figure out whether or not to update the code or the requirements.</p>
<h2 id="so-what-now"><a href="#so-what-now" aria-label="Copy heading link"><span><svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" x2="20" y1="9" y2="9"></line><line x1="4" x2="20" y1="15" y2="15"></line><line x1="10" x2="8" y1="3" y2="21"></line><line x1="16" x2="14" y1="3" y2="21"></line></svg></span><span>So, what now?</span></a></h2>
<p>Clearly LLMs are useful to software engineers. They can quickly generate code, and they are excellent at synthesizing requirements and documentation. For some tasks this is enough: the requirements are clear enough, and the problems are simple enough, that they can one-shot the whole thing.</p>
<p>That said, for anything non-trivial, they are not capable of maintaining enough context accurately enough to iterate to a working solution. You, the software engineer, are responsible for ensuring that the requirements are clear, and that the code actually does what it purports to do.</p>
<p>At Zed we believe in a world where people and agents can collaborate together to build software. But, we firmly believe that (at least for now) you are in the drivers seat, and the LLM is just another tool to reach for.</p><hr/></article></div>
  </body>
</html>
