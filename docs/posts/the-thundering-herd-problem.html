<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://encore.dev/blog/thundering-herd-problem">Original</a>
    <h1>The Thundering Herd Problem</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><p>Let me take you all the way back to April 2018. I was working at a startup that was about to ship a heavily requested new feature. We&#39;d captured interest in the feature by building a waitlist but we were being pretty secretive about the launch date (mainly because we didn&#39;t know when development would be finished).</p><p>After shipping the last features to make it MVP complete, we did some very light testing to ensure all of the user journeys worked as we expected. Things were looking good and after discussing it with our product manager, we made the decision to enable it for all customers. The excitement of shipping our first big feature in a while got the better of the entire company and before we knew it, push notifications had been sent to all customers and the entire waitlist had been enabled.</p><p>We did not expect the influx of traffic that we started to receive, and we were soon seeing alerts for services crashing, due to an unhandled panic we had not covered. After fixing, we redeployed it and for a brief moment, all our alerts were resolved and we could relax. This relaxation did not last though, as 5 minutes later a whole different set of alerts started firing (high latency, high CPU usage).  It was time to enter incident mode again.</p><h2 id="the-thundering-herd-problem"><a href="#the-thundering-herd-problem">The Thundering Herd Problem</a></h2><p>Unfortunately, we had just experienced the thundering herd problem first hand.</p><p>A thundering herd incident for an API typically occurs when a large number of clients or services simultaneously send requests to an API after a period of unavailability or delay. This could be caused by either services that you own or third party services retrying requests after a period of downtime or instability.</p><p><img src="https://encore.dev/assets/blog/thundering-herd.jpg" title="Thundering Herd Problem"/></p><p>These requests are often not malicious and are caused by engineers trying to do the right thing; one of the first lessons we get taught when working on distributed systems is that networks are not reliable and we should assume that they are going to fail. This is good advice, but how we handle that failure is important.</p><p>To resolve the immediate incident, we need to either reduce the number of requests, or scale the amount of requests our API can handle (or preferably both). To do this you can:</p><ul><li><p><strong>Scale your API horizontally:</strong> Be sure to keep your eye on your Database health if you choose this option, especially if you have not scaled your API as horizontally in the past. If you are not splitting read and write requests or connection pooling, you might find you end up with a database incident too!</p></li><li><p><strong>Scale your API vertically:</strong> This might not always work, but there is typically some relationship between CPU, memory and the amount of request your application can process. </p></li><li><p><strong>Scale down less critical workloads:</strong> It might be that there are some customer journeys we can consciously impact in the short term whilst we get ourselves back to a more stable place. For example, you might decide not allowing new customers to sign up in this period is a good approach. For other companies, this might be the worst thing imaginable and sign ups are the critical journey we must ensure continues to happen. Be sure to have these discussions at your company if you have not had them.</p></li></ul><h2 id="ensuring-it-doesnt-happen-again"><a href="#ensuring-it-doesnt-happen-again">Ensuring it Doesn&#39;t Happen Again</a></h2><p>We scaled our API up, we scaled other services down, and now we are back to a place where we are operating in a business as usual mode. The stress has not gone completely though, as we know this could happen again at any time.  What can we do to prevent that? We need to tackle it from a couple of angles. Let&#39;s step through them, starting with changes necessary to the API.</p><h3 id="rate-limiting"><a href="#rate-limiting">Rate-Limiting</a></h3><p>Firstly, we should consider adding per client rate-limits. You may do this at the infrastructure layer (many load balancers or reverse proxies support this) or you may choose to do it in your application. Either way, giving clients an allowance of how many requests they can make per minute is a useful way to protect your API. Deciding per application rate-limits is an imperfect science and will require some experimentation. I recommend that your API returns the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After" rel="nofollow" target="_blank">Retry-After</a> header and clients can use this to determine how long to &#34;back-off&#34; for. The nice thing about this approach is that you can encourage exponential-back off behavior for clients.</p><h3 id="caching"><a href="#caching">Caching</a></h3><p>There may be an opportunity for you to <a href="https://encore.dev/docs/primitives/caching">implement caching</a> in your API to prevent it having to do expensive DB lookups or calculations. This won&#39;t be suitable for all APIs, and there is a saying that &#34;if you solve a problem with caching you now have one problem&#34; which is always worth keeping in mind whenever you reach for it as a solution. AWS has a great article on this called <a href="https://aws.amazon.com/builders-library/caching-challenges-and-strategies/#:~:text=Some%20of%20the%20most%20challenging,an%20item%20in%20the%20cache." rel="nofollow" target="_blank">&#34;the ecstasy and agony of caching</a>&#34; which I highly recommend reading. </p><h3 id="circuit-breaking"><a href="#circuit-breaking">Circuit-Breaking</a></h3><p>You could consider adding a circuit breaker to your API so that once you start to see a surge in requests, you open the circuit and prevent more requests being handled. For Go specifically, there are some open-source libraries you can use here such as <a href="https://github.com/sony/gobreaker" rel="nofollow" target="_blank">sony/gobreaker</a> or the one provided by <a href="https://pkg.go.dev/github.com/go-kit/kit/circuitbreaker" rel="nofollow" target="_blank">go-kit</a>.</p><h3 id="alerts"><a href="#alerts">Alerts</a></h3><p>In the instance we described above, we actually did have alerts setup which allowed us to catch the issue, but the damage was already done. Having earlier visibility into problems occurring could have led to taking action to scale vertically or horizontally to prevent it becoming an issue. Even better if we could use those early warning signs as a signal to begin scaling and auto-resolve an incident before it happens!</p><h3 id="client-changes"><a href="#client-changes">Client Changes</a></h3><p>For the clients calling your API, you will need to work with them to ensure they respond to your rate limit successfully. Furthermore, in the event that they receive a failure response (something in the <strong>5xx</strong> range), you may want to consider asking them to implement exponential backoff with a little bit of jitter, to ensure that retried requests are &#34;spread out&#34; in the event of a downtime. Sam Rose has made an <a href="https://encore.dev/blog/retries">excellent visualization of retry patterns</a> which should help you see the impact that different strategies might have on your API.</p><p>As with the API, caching could be something to consider here. Does the client need the freshest information? Could storing some of the API responses locally reduce load to the API and improve customer experience? </p><h3 id="infrastructure-changes"><a href="#infrastructure-changes">Infrastructure Changes</a></h3><p>You could take some of the lessons learned from this incident and look to make changes to your infrastructure to protect other services from suffering the same fate. You could consider implementing rate limits and load shedding on your API Gateway. I particularly like <a href="https://stripe.com/blog/rate-limiters#:~:text=This%20is%20called%20load%20shedding,who%20is%20making%20the%20request." rel="nofollow" target="_blank">this blog post from Stripe</a> which talks about how they handle this. As aforementioned, you could also implement rate-limiting at a higher level. Circuit-breaking is another pattern to consider applying at the infrastructure layer too.</p><h2 id="wrapping-up"><a href="#wrapping-up">Wrapping Up</a></h2><p>The thundering herd problem is a tough one to deal with if you have not got any strategies in place to handle it at the time of the event. As with all distributed system issues, foresight is your friend. If you have not had discussions about which customer journeys are the most important, you should have those now.</p><p>Furthermore, ensuring your API has the ability to impose rate-limits and that clients are using some form of exponential back off will set you up for success if you do ever find yourself in a position where your API is overwhelmed.</p><p>I hope you found this blog post useful and it helps you tame your herd!</p><p><em>Matthew Boyle is an experienced technical leader in the field of distributed systems, specializing in using Go.</em></p><p><em>He has worked at huge companies such as Cloudflare and General Electric, as well as exciting high-growth startups such as Curve and Crowdcube.</em></p><p><em>Matt has been writing Go for production since 2018 and often shares blog posts and fun trivia about Go over on <a href="https://twitter.com/MattJamesBoyle" rel="nofollow" target="_blank">Twitter</a>.</em></p><p><em>He&#39;s currently working on a course to help Go Engineers become masters at debugging. You can find more details of that <a href="https://www.bytesizego.com/the-ultimate-guide-to-debugging-with-go" rel="nofollow" target="_blank">here</a>.</em></p></div></div></div></div>
  </body>
</html>
