<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/mitchellh/libxev">Original</a>
    <h1>libxev: A cross-platform, high-performance event loop</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">libxev is a cross-platform event loop. libxev provides a unified event loop
abstraction for non-blocking IO, timers, signals, events, and more that
works on macOS, Windows, Linux, and WebAssembly (browser and WASI). It is
written in <a href="https://ziglang.org/" rel="nofollow">Zig</a> but exports a C-compatible API (which
further makes it compatible with any language out there that can communicate
with C APIs).</p>
<p dir="auto"><strong>Project Status: üê≤ Unstable, alpha-ish quality.</strong> The feature list is quite
good across multiple platforms, but there are plenty of missing features.
The project hasn&#39;t been well tested in real-world environments and there
are lots of low-hanging fruit for performance optimization. I&#39;m not promising
any API compatibility at this point, either. If you want a production ready,
high quality, generalized event loop implementation check out
<a href="https://libuv.org/" rel="nofollow">libuv</a>, libev, etc.</p>
<p dir="auto"><strong>Why a new event loop library?</strong> A few reasons. One, I think Zig lacks
a generalized event loop comparable to libuv in features (&#34;generalized&#34;
being a key word here). Two, I wanted to build a library like this around
the design patterns of <a href="https://unixism.net/loti/what_is_io_uring.html" rel="nofollow">io_uring</a>,
even mimicking its style on top of other OS primitives (
<a href="https://tigerbeetle.com/blog/a-friendly-abstraction-over-iouring-and-kqueue/" rel="nofollow">credit to this awesome blog post</a>).
Three, I wanted an event loop library that could build to WebAssembly
(both WASI and freestanding) and that didn&#39;t really fit well
into the goals of API style of existing libraries without bringing in
something super heavy like Emscripten. The motivation for this library
primarily though is scratching my own itch!</p>

<p dir="auto"><strong>Cross-platform.</strong> Linux (<code>io_uring</code> and <code>epoll</code>), macOS (<code>kqueue</code>),
WebAssembly + WASI (<code>poll_oneoff</code>, threaded and non-threaded runtimes).
(Windows support is planned and coming soon)</p>
<p dir="auto"><strong><a href="https://en.wikipedia.org/wiki/Proactor_pattern" rel="nofollow">Proactor API</a>.</strong> Work
is submitted to the libxev event loop and the caller is notified of
work <em>completion</em>, as opposed to work <em>readiness</em>.</p>
<p dir="auto"><strong>Zero runtime allocations.</strong> This helps make runtime performance more
predictable and makes libxev well suited for embedded environments.</p>
<p dir="auto"><strong>Timers, TCP, UDP, Files, Processes.</strong> High-level platform-agnostic APIs for
interacting with timers, TCP/UDP sockets, files, processes, and more. For
platforms that don&#39;t support async IO, the file operations are automatically
scheduled to a thread pool.</p>
<p dir="auto"><strong>Generic Thread Pool (Optional).</strong> You can create a generic thread pool,
configure its resource utilization, and use this to perform custom background
tasks. The thread pool is used by some backends to do non-blocking tasks that
don&#39;t have reliable non-blocking APIs (such as local file operations with
<code>kqueue</code>). The thread pool can be shared across multiple threads and event
loops to optimize resource utilization.</p>
<p dir="auto"><strong>Low-level and High-Level API.</strong> The high-level API is platform-agnostic
but has some  opinionated behavior and limited flexibility. The high-level
API is recommended but the low-level API is always an available escape hatch.
The low-level API is platform-specific and provides a mechanism for libxev
users to squeeze out maximum performance. The low-level API is <em>just enough
abstraction</em> above the OS interface to make it easier to use without
sacrificing noticable performance.</p>
<p dir="auto"><strong>Tree Shaking (Zig).</strong> This is a feature of Zig, but substantially benefits
libraries such as libxev. Zig will only include function calls and features
that you actually use. If you don&#39;t use a particular kind of high-level
watcher (such as UDP sockets), then the functionality related to that
abstraction is not compiled into your final binary at all. This lets libxev
support optional &#34;nice-to-have&#34; functionality that may be considered
&#34;bloat&#34; in some cases, but the end user doesn&#39;t have to pay for it.</p>
<p dir="auto"><strong>Dependency-free.</strong> libxev has no dependencies other than the built-in
OS APIs at runtime. The C library depends on libc. This makes it very
easy to cross-compile.</p>

<p dir="auto">There are plenty of missing features that I still want to add:</p>
<ul dir="auto">
<li>Pipe high-level API</li>
<li>Signal handlers</li>
<li>Filesystem events</li>
<li>Windows backend</li>
<li>Freestanding WebAssembly support via an external event loop (i.e. the browser)</li>
</ul>
<p dir="auto">And more...</p>

<p dir="auto">There is plenty of room for performance improvements, and I want to be
fully clear that I haven&#39;t done a lot of optimization work. Still,
performance is looking good. I&#39;ve tried to port many of
<a href="https://github.com/libuv/libuv">libuv benchmarks</a> to use the libxev
API.</p>
<p dir="auto">I won&#39;t post specific benchmark results until I have a better
environment to run them in. As a <em>very broad generalization</em>,
you shouldn&#39;t notice a slowdown using libxev compared to other
major event loops. This may differ on a feature-by-feature basis, and
if you can show really poor performance in an issue I&#39;m interested
in resolving it!</p>

<p dir="auto">The example below shows an identical program written in Zig and in C
that uses libxev to run a single 5s timer. This is almost silly how
simple it is but is meant to just convey the overall feel of the library
rather than a practical use case.</p>
<table>
<tbody><tr>
<td> Zig </td> <td> C </td>
</tr>
<tr>
<td>
<div dir="auto" data-snippet-clipboard-copy-content="const xev = @import(&#34;xev&#34;);

pub fn main() !void {
    var loop = try xev.Loop.init(.{});
    defer loop.deinit();

    const w = try xev.Timer.init();
    defer w.deinit();

    // 5s timer
    var c: xev.Completion = undefined;
    w.run(&amp;loop, &amp;c, 5000, void, null, &amp;timerCallback);

    try loop.run(.until_done);
}

fn timerCallback(
    userdata: ?*void,
    loop: *xev.Loop,
    c: *xev.Completion,
    result: xev.Timer.RunError!void,
) xev.CallbackAction {
   _ = userdata;
   _ = loop;
   _ = c;
   _ = result catch unreachable;
   return .disarm;
}"><pre><span>const</span> <span>xev</span> <span>=</span> <span>@import</span>(<span>&#34;xev&#34;</span>);

<span>pub</span> <span>fn</span> <span>main</span>() <span>!</span><span>void</span> {
    <span>var</span> <span>loop</span> <span>=</span> <span>try</span> <span>xev</span>.<span>Loop</span>.<span>init</span>(.{});
    <span>defer</span> <span>loop</span>.<span>deinit</span>();

    <span>const</span> <span>w</span> <span>=</span> <span>try</span> <span>xev</span>.<span>Timer</span>.<span>init</span>();
    <span>defer</span> <span>w</span>.<span>deinit</span>();

    <span>// 5s timer</span>
    <span>var</span> <span>c</span>: <span>xev.Completion</span> <span>=</span> <span>undefined</span>;
    <span>w</span>.<span>run</span>(<span>&amp;</span><span>loop</span>, <span>&amp;</span><span>c</span>, <span>5000</span>, <span>void</span>, <span>null</span>, <span>&amp;</span><span>timerCallback</span>);

    <span>try</span> <span>loop</span>.<span>run</span>(<span>.until_done</span>);
}

<span>fn</span> <span>timerCallback</span>(
    <span>userdata</span>: <span>?</span><span>*</span><span>void</span>,
    <span>loop</span>: <span>*</span><span>xev.Loop</span>,
    <span>c</span>: <span>*</span><span>xev.Completion</span>,
    <span>result</span>: <span>xev</span>.<span>Timer</span>.<span>RunError</span><span>!</span><span>void</span>,
) <span>xev.CallbackAction</span> {
   <span>_</span> <span>=</span> <span>userdata</span>;
   <span>_</span> <span>=</span> <span>loop</span>;
   <span>_</span> <span>=</span> <span>c</span>;
   <span>_</span> <span>=</span> <span>result</span> <span>catch</span> <span>unreachable</span>;
   <span>return</span> <span>.disarm</span>;
}</pre></div>
</td>
<td>
<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;stddef.h&gt;
#include &lt;stdio.h&gt;
#include &lt;xev.h&gt;

xev_cb_action timerCallback(xev_loop* loop, xev_completion* c, int result, void *userdata) {
    return XEV_DISARM;
}

int main(void) {
    xev_loop loop;
    if (xev_loop_init(&amp;loop) != 0) {
        printf(&#34;xev_loop_init failure\n&#34;);
        return 1;
    }

    xev_watcher w;
    if (xev_timer_init(&amp;w) != 0) {
        printf(&#34;xev_timer_init failure\n&#34;);
        return 1;
    }

    xev_completion c;
    xev_timer_run(&amp;w, &amp;loop, &amp;c, 5000, NULL, &amp;timerCallback);

    xev_loop_run(&amp;loop, XEV_RUN_UNTIL_DONE);

    xev_timer_deinit(&amp;w);
    xev_loop_deinit(&amp;loop);
    return 0;
}"><pre>#<span>include</span> <span>&lt;</span><span>stddef</span>.<span>h</span><span>&gt;</span>
#<span>include</span> <span>&lt;</span><span>stdio</span>.<span>h</span><span>&gt;</span>
#<span>include</span> <span>&lt;</span><span>xev</span>.<span>h</span><span>&gt;</span>

<span>xev_cb_action</span> <span>timerCallback</span>(<span>xev_loop</span><span>*</span> <span>loop</span>, <span>xev_completion</span><span>*</span> <span>c</span>, <span>int</span> <span>result</span>, <span>void</span> <span>*</span><span>userdata</span>) {
    <span>return</span> <span>XEV_DISARM</span>;
}

<span>int</span> <span>main</span>(<span>void</span>) {
    <span>xev_loop</span> <span>loop</span>;
    <span>if</span> (<span>xev_loop_init</span>(<span>&amp;</span><span>loop</span>) <span>!=</span> <span>0</span>) {
        <span>printf</span>(<span>&#34;xev_loop_init failure<span>\n</span>&#34;</span>);
        <span>return</span> <span>1</span>;
    }

    <span>xev_watcher</span> <span>w</span>;
    <span>if</span> (<span>xev_timer_init</span>(<span>&amp;</span><span>w</span>) <span>!=</span> <span>0</span>) {
        <span>printf</span>(<span>&#34;xev_timer_init failure<span>\n</span>&#34;</span>);
        <span>return</span> <span>1</span>;
    }

    <span>xev_completion</span> <span>c</span>;
    <span>xev_timer_run</span>(<span>&amp;</span><span>w</span>, <span>&amp;</span><span>loop</span>, <span>&amp;</span><span>c</span>, <span>5000</span>, <span>NULL</span>, <span>&amp;</span><span>timerCallback</span>);

    <span>xev_loop_run</span>(<span>&amp;</span><span>loop</span>, <span>XEV_RUN_UNTIL_DONE</span>);

    <span>xev_timer_deinit</span>(<span>&amp;</span><span>w</span>);
    <span>xev_loop_deinit</span>(<span>&amp;</span><span>loop</span>);
    <span>return</span> <span>0</span>;
}</pre></div>
</td>
</tr>
</tbody></table>

<p dir="auto"><strong>These instructions are for Zig downstream users only.</strong> If you are
using the C API to libxev, see the &#34;Build&#34; section.</p>
<p dir="auto">This package works with the Zig package manager introduced in Zig 0.11.
Create a <code>build.zig.zon</code> file like this:</p>
<div dir="auto" data-snippet-clipboard-copy-content=".{
    .name = &#34;my-project&#34;,
    .version = &#34;0.0.0&#34;,
    .dependencies = .{
        .libxev = .{
            .url = &#34;https://github.com/mitchellh/libxev/archive/&lt;git-ref-here&gt;.tar.gz&#34;,
            .hash = &#34;12208070233b17de6be05e32af096a6760682b48598323234824def41789e993432c&#34;,
        },
    },
}"><pre>.{
    .<span>name</span> <span>=</span> <span>&#34;my-project&#34;</span>,
    .<span>version</span> <span>=</span> <span>&#34;0.0.0&#34;</span>,
    .<span>dependencies</span> <span>=</span> .{
        .<span>libxev</span> <span>=</span> .{
            .<span>url</span> <span>=</span> <span>&#34;https://github.com/mitchellh/libxev/archive/&lt;git-ref-here&gt;.tar.gz&#34;</span>,
            .<span>hash</span> <span>=</span> <span>&#34;12208070233b17de6be05e32af096a6760682b48598323234824def41789e993432c&#34;</span>,
        },
    },
}</pre></div>
<p dir="auto">And in your <code>build.zig</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="const xev = b.dependency(&#34;libxev&#34;, .{ .target = target, .optimize = optimize });
exe.addModule(&#34;xev&#34;, xev.module(&#34;xev&#34;));"><pre><span>const</span> <span>xev</span> <span>=</span> <span>b</span>.<span>dependency</span>(<span>&#34;libxev&#34;</span>, .{ .<span>target</span> <span>=</span> <span>target</span>, .<span>optimize</span> <span>=</span> <span>optimize</span> });
<span>exe</span>.<span>addModule</span>(<span>&#34;xev&#34;</span>, <span>xev</span>.<span>module</span>(<span>&#34;xev&#34;</span>));</pre></div>

<p dir="auto">üöß Documentation is a work-in-progress. üöß</p>
<p dir="auto">Currently, documentation is available in three forms: <strong>man pages</strong>,
<strong>examples</strong>, and <strong>code comments.</strong> In the future, I plan on writing detailed
guides and API documentation in website form, but that isn&#39;t currently
available.</p>

<p dir="auto">The man pages are relatively detailed! <code>xev(7)</code> will
give you a good overview of the entire library. <code>xev-zig(7)</code> and
<code>xev-c(7)</code> will provide overviews of the Zig and C API, respectively.
From there, API-specifc man pages such as <code>xev_loop_init(3)</code> are
available. This is the best documentation currently.</p>
<p dir="auto">There are multiple ways to browse the man pages. The most immediately friendly
is to just browse the raw man page sources in the <code>docs/</code> directory in
your web browser. The man page source is a <em>markdown-like</em> syntax so it
renders <em>okay</em> in your browser via GitHub.</p>
<p dir="auto">Another approach is to run <code>zig build -Dman-pages</code> and the man pages
will be available in <code>zig-out</code>. This requires
<a href="https://git.sr.ht/~sircmpwn/scdoc" rel="nofollow">scdoc</a>
to be installed (this is available in most package managers).
Once you&#39;ve built the man pages, you can render them by path:</p>
<div data-snippet-clipboard-copy-content="$ man zig-out/share/man/man7/xev.7"><pre><code>$ man zig-out/share/man/man7/xev.7
</code></pre></div>
<p dir="auto">And the final approach is to install libxev via your favorite package
manager (if and when available), which should hopefully put your man pages
into your man path, so you can just do <code>man 7 xev</code>.</p>

<p dir="auto">There are examples available in the <code>examples/</code> folder. The examples are
available in both C and Zig, and you can tell which one is which using
the file extension.</p>
<p dir="auto">To build an example, use the following:</p>
<div data-snippet-clipboard-copy-content="$ zig build -Dexample-name=_basic.zig
...
$ zig-out/bin/example-basic
..."><pre><code>$ zig build -Dexample-name=_basic.zig
...
$ zig-out/bin/example-basic
...
</code></pre></div>
<p dir="auto">The <code>-Dexample-name</code> value should be the filename including the extension.</p>

<p dir="auto">The Zig code is well commented. If you&#39;re comfortable reading code comments
you can find a lot of insight within them. The source is in the <code>src/</code>
directory.</p>

<p dir="auto">Build requires the installation of the latest <a href="https://ziglang.org/download/" rel="nofollow">Zig nightly</a>.
<strong>libxev has no other build dependencies.</strong></p>
<p dir="auto">Once installed, <code>zig build install</code> on its own will build the full library and output
a <a href="https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard" rel="nofollow">FHS-compatible</a>
directory in <code>zig-out</code>. You can customize the output directory with the
<code>--prefix</code> flag.</p>

<p dir="auto">libxev has a large and growing test suite. To run the tests for the current
platform:</p>

<p dir="auto">This will run all the tests for all the supported features for the current
host platform. For example, on Linux this will run both the full io_uring
and epoll test suite.</p>
<p dir="auto"><strong>You can build and run tests for other platforms</strong> by cross-compiling the
test executable, copying it to a target machine and executing it. For example,
the below shows how to cross-compile and build the tests for macOS from Linux:</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ zig build -Dtarget=aarch64-macos -Dinstall-tests
...

$ file zig-out/bin/xev-test
zig-out/bin/xev-test: Mach-O 64-bit arm64 executable"><pre>$ zig build -Dtarget=aarch64-macos -Dinstall-tests
...

$ file zig-out/bin/xev-test
zig-out/bin/xev-test: Mach-O 64-bit arm64 executable</pre></div>
<p dir="auto"><strong>WASI is a special-case.</strong> You can run tests for WASI if you have
<a href="https://wasmtime.dev/" rel="nofollow">wasmtime</a> installed:</p>
<div data-snippet-clipboard-copy-content="$ zig build test -Dtarget=wasm32-wasi -Dwasmtime
..."><pre><code>$ zig build test -Dtarget=wasm32-wasi -Dwasmtime
...
</code></pre></div>
</article></div></div>
  </body>
</html>
