<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tailscale.com/blog/tailnet-lock/">Original</a>
    <h1>Tailnet Lock</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p>Users sometimes ask us, “How can I trust Tailscale?” From the beginning, we’ve tried to make it so you don’t have to, by <a href="https://tailscale.com/blog/how-tailscale-works/">architecting our infrastructure</a> with security and privacy in mind. When you use Tailscale, your data is end-to-end encrypted. Tailscale doesn’t have the private key, so we can’t see your traffic. While Tailscale can’t observe the data transiting your tailnet, we <em>are</em> responsible for managing the control plane, where our coordination server distributes public keys and settings for your tailnet.</p>
<p>Which brings us to one glaring issue that has remained with our architecture: You have still needed to trust our coordination server. What if we were malicious, and stealthily inserted new nodes into your network? Tailscale could hypothetically use a secretly-added node to send or receive traffic to your existing nodes — meaning it wouldn’t matter that the traffic is encrypted because the peer itself would be malicious.</p>
<p>You should decide who to trust when it comes to your tailnet’s coordination server and how nodes are added to your tailnet. We don’t want you to have to trust us to get it right. <strong>So today, we’re taking the first steps with <a href="https://tailscale.com/kb/1226/tailnet-lock">tailnet lock</a>, a security feature where your nodes verify the public keys distributed by the coordination server before trusting them for network connectivity.</strong></p>
<h3 id="lock-out-untrusted-nodes">Lock out untrusted nodes</h3>
<p>When you install Tailscale and authenticate a device, <a href="https://tailscale.com/blog/tailscale-key-management/#node-keys">a node keypair</a> is automatically generated — that’s the static keypair used as part of the <a href="https://www.wireguard.com/papers/wireguard.pdf">WireGuard® protocol</a>. The private key stays on the device, and the public key is shared with the Tailscale coordination server. The coordination server then distributes that public key to other existing nodes in your tailnet <a href="https://tailscale.com/kb/1087/device-visibility/#which-devices-can-i-see-which-devices-can-see-my-device">the new device is allowed to connect to</a>, based on ACLs.</p>

    
    

<figure>
        <img src="https://tailscale.com/blog/tailnet-lock/without-lock.svg" alt="Without tailnet lock, when a new node is added to the tailnet, its public key is distributed to peer nodes by the coordination server."/>
    
    <figcaption>
        <p>Without tailnet lock, when a new node is added to the tailnet, its public key is distributed to peer nodes by the coordination server.</p>
    </figcaption>
</figure>

<p>With tailnet lock enabled, we add an extra step. Existing nodes still receive new nodes’ public keys from the coordination server, but don’t immediately trust them — the new node is <em>locked out</em>. New nodes added to your tailnet must be signed by a trusted tailnet lock key before they are allowed to connect to other nodes, and you decide which tailnet lock keys your tailnet’s existing nodes will trust. (In nerd-speak, we can say that your Tailscale nodes will only trust a node public key from Tailscale’s coordination server if it is endorsed by a cryptographic signature using tailnet-controlled tailnet lock keys.) The coordination server doesn’t generate, store, or see the tailnet lock key material, so even if the coordination server were compromised, it couldn’t sign a new node and have it participate in your tailnet.</p>

    
    

<figure>
        <img src="https://tailscale.com/blog/tailnet-lock/with-lock.svg" alt="With tailnet lock, when a new node is added to the tailnet, it is signed by a trusted tailnet lock key, then distributed to peer nodes, which can verify the signature before allowing connections."/>
    
    <figcaption>
        <p>With tailnet lock, when a new node is added to the tailnet, it is signed by a trusted tailnet lock key, then distributed to peer nodes, which can verify the signature before allowing connections.</p>
    </figcaption>
</figure>

<p>As with any security technology, the devil is in the details. A crypto-scheme based on endorsing one set of key material (WireGuard node keys) with another (tailnet lock keys) introduces a new problem, as nodes now need some way to track which tailnet lock keys are trusted. So how do nodes decide which tailnet lock keys to trust?</p>

<p>To determine which tailnet lock keys to trust, nodes implement a new subsystem, the <em>tailnet key authority</em>, to track and update the set of tailnet lock keys that can be used to sign node keys.</p>

    
    

<figure>
        <img src="https://tailscale.com/blog/tailnet-lock/new-lock-key.svg" alt="Before a new trusted tailnet lock key is added, it must be signed by an existing trusted tailnet lock key. The coordination server distributes the new key to all nodes in the tailnet, which can verify the signature before trusting it."/>
    
    <figcaption>
        <p>Before a new trusted tailnet lock key is added, it must be signed by an existing trusted tailnet lock key. The coordination server distributes the new key to all nodes in the tailnet, which can verify the signature before trusting it.</p>
    </figcaption>
</figure>

<p>Tailnet lock keys are automatically generated by every node in your tailnet — but you select which ones to trust. (For now, these keys are stored on disk in each node, but in the future we hope to support more secure storage mediums, such as TPMs and FIDO2 keys.)</p>
<p>When tailnet lock is first enabled, you specify an initial set of tailnet lock keys to sign all node keys within the tailnet. This set of trusted tailnet lock keys is also distributed to the existing nodes. From that moment on, your tailnet is locked, and all new node keys must be endorsed using an existing tailnet lock key.</p>
<p>Changing the set of trusted tailnet lock keys to add or remove a key is done by encoding and signing the change with an existing tailnet lock key, which is then published across the tailnet.</p>
<h3 id="enable-tailnet-lock">Enable tailnet lock</h3>
<p>To get started with tailnet lock, request access from the <a href="https://login.tailscale.com/admin/settings/features">Feature Previews</a> page of the admin console.</p>
<p>Update nodes in your tailnet to Tailscale v1.34 or later.</p>
<p>For the nodes whose tailnet lock keys you want to trust, get the public key on each node by running:</p>
<pre tabindex="0"><code>tailscale lock status
</code></pre><p>We recommend setting up tailnet lock with multiple trusted nodes.</p>
<p>Next, decide the number of disablement secrets you wish to use. Disablement secrets are used to disable tailnet lock. We recommend you use at least two, and store these securely, such as in a password manager or secret vault. You can optionally generate an extra disablement secret that is automatically passed to Tailscale support, so we can disable tailnet lock in case of an issue with how we’ve implemented it.</p>
<p>Then, on any node in your tailnet, enable tailnet lock, specifying the X trusted tailnet lock keys, and the desired number of disablement secrets N:</p>
<pre tabindex="0"><code>tailscale lock init --gen-disablements=N [--gen-disablement-for-support] tlpub:$trusted-tailnet-lock-key-1 … tlpub:$trusted-tailnet-lock-key-X
</code></pre><p>The disablement secrets are printed out, all existing nodes in the tailnet are signed by the trusted tailnet lock keys, and tailnet lock is enabled.</p>
<p>Learn more about how to set up tailnet lock for your tailnet in the <a href="https://tailscale.com/kb/1226/tailnet-lock/">documentation</a>.</p>
<figure>
  <iframe width="100%" height="360" src="https://www.youtube.com/embed/N3vZrgrSz6g" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
</figure>
<h3 id="the-a-in-alpha-is-for-almost">The A in Alpha is for Almost</h3>
<p>We’re excited to share tailnet lock with the world, but like all other security features, it’s important to us to get it right.</p>
<p>We’d like to further improve the user experience of tailnet lock. Right now, all operations are done via the command line. And there are still some complications that our current implementation of tailnet lock doesn’t address, such as signing <a href="https://tailscale.com/kb/1084/sharing/">shared nodes</a>. We have plans to address these issues but haven’t yet implemented them. As a result, we’re not making tailnet lock available to everyone just yet. If you’d like to test it out, request access for your tailnet from the <a href="https://login.tailscale.com/admin/settings/features">Feature Previews</a> page of the admin console. We’ll open it up to a few tailnets at a time, so that we can address any issues you hit or feedback you have.</p>
<p>We’re also publishing a more detailed white paper explaining how tailnet lock works, including cryptographic details on the key generation and signing used, the tailnet key authority, unlocking the tailnet, achieving consensus, and recovering from a tailnet lock key compromise. Interested parties can read up on the gory details in our <a href="https://tailscale.com/kb/1230/tailnet-lock-whitepaper/">Tailnet lock white paper</a>. <a href="mailto:info@tailscale.com">Email us</a> to share any feedback you have.</p>
    </div></div>
  </body>
</html>
