<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://interjectedfuture.com/visual-programming-should-start-in-the-debugger/">Original</a>
    <h1>Visual programming should start in the debugger</h1>
    
    <div id="readability-page-1" class="page"><div id="site-main">
<article>

    <header>

        

        


        

            <figure>
                <img srcset="/content/images/size/w300/2024/07/DALL-E-2024-07-01-12.15.54---A-dream-like-blog-post-header-for-a-topic-on-visual-programming-and-debugging--enhanced-with-additional-visual-programming-elements.-The-design-featur.jpeg 300w,
                            /content/images/size/w600/2024/07/DALL-E-2024-07-01-12.15.54---A-dream-like-blog-post-header-for-a-topic-on-visual-programming-and-debugging--enhanced-with-additional-visual-programming-elements.-The-design-featur.jpeg 600w,
                            /content/images/size/w1000/2024/07/DALL-E-2024-07-01-12.15.54---A-dream-like-blog-post-header-for-a-topic-on-visual-programming-and-debugging--enhanced-with-additional-visual-programming-elements.-The-design-featur.jpeg 1000w,
                            /content/images/size/w2000/2024/07/DALL-E-2024-07-01-12.15.54---A-dream-like-blog-post-header-for-a-topic-on-visual-programming-and-debugging--enhanced-with-additional-visual-programming-elements.-The-design-featur.jpeg 2000w" sizes="(min-width: 1400px) 1400px, 92vw" src="https://interjectedfuture.com/content/images/size/w2000/2024/07/DALL-E-2024-07-01-12.15.54---A-dream-like-blog-post-header-for-a-topic-on-visual-programming-and-debugging--enhanced-with-additional-visual-programming-elements.-The-design-featur.jpeg" alt="Visual Programming Should Start in the Debugger"/>
            </figure>

    </header>

    <section>
        <p>Just like CAD didn&#39;t make everyone an industrial designer, visual programming isn&#39;t going to make everyone a programmer. Whether textual or visual, there&#39;d still be a lot of underlying concepts (and how they are composed) to learn. But still, I think it&#39;s underexplored.</p><figure><img src="https://api.typefully.com/media-p/8312030b-9b2a-471f-8e69-5a93b62ec951/" alt="" loading="lazy"/></figure><p>Most visual programming paradigms focus on coding--the instruction of the computer. This can be helpful for beginners, but it&#39;s of limited value to working programmers. Once syntax and API are learned, current visual tools don&#39;t help solve problems that working programmers have.</p><figure><img src="https://interjectedfuture.com/content/images/2024/07/image.png" alt="" loading="lazy" width="1024" height="580" srcset="https://interjectedfuture.com/content/images/size/w600/2024/07/image.png 600w, https://interjectedfuture.com/content/images/size/w1000/2024/07/image.png 1000w, https://interjectedfuture.com/content/images/2024/07/image.png 1024w" sizes="(min-width: 720px) 720px"/><figcaption>Block based visual programming</figcaption></figure><figure><img src="https://interjectedfuture.com/content/images/2024/07/image-1.png" alt="" loading="lazy" width="1478" height="1024" srcset="https://interjectedfuture.com/content/images/size/w600/2024/07/image-1.png 600w, https://interjectedfuture.com/content/images/size/w1000/2024/07/image-1.png 1000w, https://interjectedfuture.com/content/images/2024/07/image-1.png 1478w" sizes="(min-width: 720px) 720px"/><figcaption>Node-based visual programming</figcaption></figure><p>As &#34;bicycles for the mind&#34;, computers should leverage our visual-spatial reasoning. It&#39;s a powerful aspect of our minds underutilized in modern programming toolchains and stacks. We all know this on some level, hence the gravity of the visual programming tarpit.</p><p>This is what debuggers are suppose to help with, but they don&#39;t have a good affordance. You can overstep the bug and need to restart. You have to manually track variables for your bug. And you certainly don&#39;t get a visual rep of your data structure and its changes over time.</p><figure><img src="https://api.typefully.com/media-p/584e43da-5464-4ad4-8580-f284602b7e73/" alt="" loading="lazy"/><figcaption>Visualizing a Hash Mapped Array Trie</figcaption></figure><p>Visual-spatial reasoning has a great affordance for illustrating states over time. Visual elements, like data, are inert and declarative. They describe things, not behavior. Hence, I think visualization should start with state and data, rather than code and behavior.</p><!--kg-card-begin: html--><!--kg-card-end: html--><p>That&#39;s why I think visualization efforts should start with replacing the debugger, not the text editor. If you insist on the text editor, at least start with visually augmenting the text editor. </p><p>We have lang servers for IDEs; why not production statistics servers? Highlight a section of code with previous security breaches. Show the number of bugs with this section of code. Highlight hot paths in production. Show sample production data that flows through this code.</p><p>But that&#39;s just a side path. I think debuggers are the beachhead for visual programming. It&#39;s there that we can learn to visually express state for common data structures. And then learn how to visually express this state over time to express change.</p><p>Like check out the Hovenia Editor that visualizes trees. It&#39;s a good start to exploring visualizations of state in a debugger.</p><figure><a href="https://x.com/tiyecirru/status/1529052140463095809"><img src="https://interjectedfuture.com/content/images/2024/07/image-2.png" alt="" loading="lazy" width="2000" height="1299" srcset="https://interjectedfuture.com/content/images/size/w600/2024/07/image-2.png 600w, https://interjectedfuture.com/content/images/size/w1000/2024/07/image-2.png 1000w, https://interjectedfuture.com/content/images/size/w1600/2024/07/image-2.png 1600w, https://interjectedfuture.com/content/images/2024/07/image-2.png 2260w" sizes="(min-width: 720px) 720px"/></a><figcaption>https://github.com/Cirru/hovenia-editor</figcaption></figure><p>That said, compiler and language writers currently don&#39;t have this goal in mind, so the API of a compiler doesn&#39;t make it easy. So if you&#39;re going to write a new compiler for a new language, I&#39;d make it easy to access the program state for visualization. Traditionally, it&#39;s was also difficult to find legible visual representations of state that adjusts to the problem at hand. A dict doesn&#39;t always want to be a key/value store. Sometimes they&#39;re histograms. Sometimes, they&#39;re a set. Perhaps LLMs or Edward Tufte can help. Once we have a visual language for illustrating state over time, I think we can utilize that visual language to back into visual programming. But until then, we&#39;re shoehorning current paradigms that don&#39;t have the right affordances to leverage our visual-spatial reasoning. </p><p>Visual programming might just look completely different than textual programming. Textual programming takes its cues from step-by-step (imperative), transformations (functional), inferences (logical) reasoning, all analytical traditions. It&#39;s rare to see visual programming take its cues from logic programming even though they have the same affordances. Declare a beginning and end state, and have the computer infer everything that needs to happen in between. Perhaps we visually express two states, a before and after, visual programming infers the programming instructions needed to take it from one state to another. Like drawing keyframes, and offloading the in-betweens to the computer.</p><p>But I don&#39;t think this is the only path forward. Most visual programming thinks from the top-down--from the affordances to humans down to the computer. There&#39;s a different way. How about instead of linear memory, we start with spatial memory at the bottom, and work our way up?</p><figure><img src="https://interjectedfuture.com/content/images/2024/07/image-3.png" alt="" loading="lazy" width="2000" height="1081" srcset="https://interjectedfuture.com/content/images/size/w600/2024/07/image-3.png 600w, https://interjectedfuture.com/content/images/size/w1000/2024/07/image-3.png 1000w, https://interjectedfuture.com/content/images/size/w1600/2024/07/image-3.png 1600w, https://interjectedfuture.com/content/images/2024/07/image-3.png 2224w" sizes="(min-width: 720px) 720px"/><figcaption>CellPond</figcaption></figure><!--kg-card-begin: html--><!--kg-card-end: html-->
    </section>


</article>
</div></div>
  </body>
</html>
