<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://www.charlespetzold.com/blog/2022/09/The-Changes-for-the-2nd-Edition-of-Code.html">Original</a>
    <h1>The Changes for the 2nd Edition of “Code”</h1>
    
    <div id="readability-page-1" class="page"><article>
            <header>
                <h2>
                    <a href="http://www.charlespetzold.com/blog/2022/09/The-Changes-for-the-2nd-Edition-of-Code.html">The Changes for the 2nd Edition of “Code”</a>
                </h2>

                <p>September 5, 2022</p>
            </header>

            
            <p>
            Whenever a 2nd edition of a book is published, people ask “I already have the 1st edition. Do I need to get the 2nd?” It’s a legitimate question and I’ve asked it myself. Reading a 2nd edition after the 1st is not trivial: It’s a commitment of both additional money and additional time.
            </p>
            <p>
            Sometimes a 2nd edition has mostly small changes: correcting a few mistakes, adding some more up-to-date information. But other times a 2nd edition involves some major upheavals. Perhaps the author had become dissatisfied with certain aspects of the 1st edition and wanted to fix them.
            </p>
            <p>
            The 2nd edition of <i>Code: The Hidden Language of Computer Hardware and Software</i> falls into that second category.
            </p>
            <p>
            Ever since the 1st edition of <i>Code</i> was published in 1999, I’ve had plenty of time to contemplate that book’s strengths and deficiencies. Even before it was published, I thought the book was too long. I originally wanted to write a friendly 300-page book rather than a scary 400-page book. Perhaps in a 2nd edition, I could streamline the prose and cut out a bunch of the more complex stuff towards the end.
            </p>
            <p>
            But I was also dissatisfied with my description of how a computer’s Central Processing Unit (CPU) worked. I was fairly happy with the first 17 chapters of the 1st edition, but then the book seemed to <a href="https://idioms.thefreedictionary.com/punk+out">punk out</a>. It went from describing how codes stored in memory could control hardware in Chapter 17 to a history of computing in Chapter 18 and then to a laborious dissection of the instruction sets of two mid-1970s CPUs in Chapter 19. This progression required too much blind faith on the part of the reader to imagine how the simple codes shown in Chapter 17 were essentially the same as the much more complex codes described in Chapter 19.
            </p>
            <p>
            I didn’t like that, and the solution was to plunge much deeply into the construction of a CPU.
            </p>
            <p>
            I realized that this second goal wasn’t quite compatible with the first goal of making the book shorter. The second goal won out and the 2nd edition of <i>Code</i> is 68 pages longer than the 1st edition.
            </p>
            <p>
            If you begin comparing the Tables of Contents of the two editions, they look very similar at first, and it is true that much of the early part of the book has undergone minimal changes. The first five chapters are basically the same. Page counts are in parentheses:
            </p>
            
            <table>
            <tbody>
            <tr><th>1st Edition</th><th>2nd Edition</th></tr>
            <tr><td>1. Best Friends (6)</td><td>1. Best Friends (6)</td></tr>
            <tr><td>2. Code and Combinations (6)</td><td>2. Codes and Combinations (6)</td></tr>
            <tr><td>3. Braille and Binary Codes (7)</td><td>3. Braille and Binary Codes (7)</td></tr>
            <tr><td>4. Anatomy of a Flashlight (10)</td><td>4. Anatomy of a Flashlight (9)</td></tr>
            <tr><td>5. Seeing Around Corners (8)</td><td>5. Communicating Around Corners (9)</td></tr>
            </tbody>
            </table>
            <p>
            Any changes were mostly minor. For example, one of the tech reviewers suggested that the picture of electrons spinning around the nucleus of an atom in Chapter 4 was “pretty obsolete” and I agreed and removed it. I changed the title of Chapter 5 for slightly more accuracy.
            </p>
            <p>
            When I was first writing <i>Code</i> I was hoping that all the chapters would be as short as these early chapters, but it soon became obvious that this noble goal was impossible!
            </p>
            <p>
            I reordered the next six chapters with some title changes:
            </p>
            <table>
            <tbody>
            <tr><th>1st Edition</th><th>2nd Edition</th></tr>
            <tr><td>6. Telegraphs and Relays (7)</td><td>6. Logic with Switches (16)</td></tr>
            <tr><td>7. Our Ten Digits (7)</td><td>7. Telegraphs and Relays (7)</td></tr>
            <tr><td>8. Alternatives to Ten (15)</td><td>8. Relays and Gates (26)</td></tr>
            <tr><td>9. Bit by Bit by Bit (17)	</td><td>9 Our Ten Digits (7)</td></tr>
            <tr><td>10. Logic and Switches (16)</td><td>10. Alternative 10s (18)</td></tr>
            <tr><td>11. Gates (Not Bill) (29)</td><td>11. Bit by Bit by Bit (22)</td></tr>
            </tbody>
            </table>
            <p>
            Chapter 6 became Chapter 7, Chapter 10 became Chapter 6, and Chapter 11 became Chapter 8. The group of Chapters 7, 8, and 9 in the 1st edition became Chapters 9, 10, and 11.
            </p>
            <p>
            It might seem strange that chapters could be reordered in this way, but this group of chapters must do several things that should ultimately come together in the chapters that follow. Here’s what these chapters must do. I’ve ordered them as in the 2nd edition:
            </p>
            <p>
            1. Introduce the concepts of AND and OR and show how you can perform these logical operations with switches in series and parallel: “Logic with Switches”
            </p>
            <p>
            2. Introduce the hardware of the telegraph relay: “Telegraphs and Relays”
            </p>
            <p>
            3. Show how telegraph relays can be wired to perform AND and OR and well as NAND and NOR: “Relays and Gates”
            </p>
            <p>
            4. Explore how numbers work, ultimately revealing binary numbers and bits: “Our Ten Digits,” “Alternative 10s,” and “Bit by Bit by Bit”
            </p>
            <p>
            Although the “Relays and Gates” chapter is dependent on both the “Logic with Switches” and “Telegraphs and Relays” chapter, that’s the only dependency among these three chapters. That’s why they can be ordered differently. But there are other considerations: For the 1st edition, I was unhappy that the reader had to remember relays from Chapter 6 to see how gates are built in Chapter 11. Also, there was little justification for jumping from relays to number systems. Moreover, Chapter 10 in the 1st edition didn’t require any of the previous chapters in this group.
            </p>
            <p>
            But reordering these chapters created another problem: The 1st edition went straight from introducing logic gates in Chapter 11 to the application of binary addition in Chapter 12. That was nice! The 2nd edition however, delays application of the logic gates by the interposition of the three chapters on number bases.
            </p>
            <p>
            However, I kind of fixed that with Chapter 10 (“Alternative 10s”), in which the reader is reminded of the logic gates introduced two chapters earlier with two new circuits at the end to encode and decode octal numbers.
            </p>
            <p>
            Another change to the “Alternative 10s” chapter is that I got rid of all the subscripts indicating the number bases. This is dangerous, of course, and I fervently struggled to make everything clear with a minimum of (pardon the technical math term) hair.
            </p>
            <p>
            In this group of chapters, “Bit by Bit by Bit” underwent the most revisions. This chapter is intended to show some examples of bits in common life. The 1st edition version of this chapter was sometimes ridiculed because it began with a 1973 song by Tony Orlando and Dawn. (I won’t mention the title because it will implant an annoying earworm in your head.) I kept the song reference in the 2nd edition but prefaced it with a more interesting historical background.
            </p>
            <p>
            One of the examples of bits in the 1st edition involved markings on rolls of 35-millimeter camera film that indicate the film’s ASA ratings. Few people have seen rolls of 35-millimeter film in recent years, so I removed that in Chapter 11 of the 2nd Edition.
            </p>
            <p>
            I kept the description of UPC codes from the 1st edition. The example of the 10¾ ounce can of Campbell’s Chicken Noodle Soup was still valid. It hadn’t changed in 25 years!
            </p>
            <p>
            I also added a couple other examples: One is the bit encoding of the parachute of the <i>Perseverance</i> rover when it landed on Mars on February 18, 2021, just 7 weeks after I started work on the 2nd edition. The other example is an analysis of the QR code for the website for this book, stopping short of the complex error correction.
            </p>
            <p>
            But there was a slight problem with the QR code: It uses ASCII character codes, and I hadn’t introduced ASCII yet. I kind of glossed over that in Chapter 11 but I thought I should correct it quickly with this pair of chapters:
            </p>
            <table>
            <tbody>
            <tr><th>1st Edition</th><th>2nd Edition</th></tr>
            <tr><td></td><td>12. Bytes and Hexadecimal (10)</td></tr>
            <tr><td></td><td>13. From ASCII to Unicode (19)</td></tr>
            </tbody>
            </table>
            <p>
            The equivalents of these two chapters in the 1st edition are 15 (“Bytes and Hex”) and 20 (“ASCII and a Cast of Characters”). I sometimes bragged that the 1st edition of <i>Code</i> was unlike other “how computers work” books because the word “byte” was mentioned until page 180! But now it’s introduced on page 140. Big deal. I found that introducing bytes and hexadecimal earlier made things easier in subsequent chapters.
            </p>
            <p>
            The chapter about character encoding in the 1st edition had only 4 paragraphs on Unicode. That had to be fixed, and the 2nd edition devotes 5 pages to Unicode, including an extensive discussion of Unicode Transformation Formats with a particular emphasis (3 pages) on UTF-8, including a discussion of rendering errors when the correct character set isn’t indicated.
            </p>
            <p>
            At this point, the chapters sync up, more or less:
            </p>
            <table>
            <tbody>
            <tr><th>1st Edition</th><th>2nd Edition</th></tr>
            <tr><td>12. A Binary Adding Machine (12)</td><td>14. Adding with Logic Gates (14)</td></tr>
            <tr><td></td><td>15. Is This for Real? (14)</td></tr>
            <tr><td>13. But What About Subtraction? (12)</td><td>16. But What About Subtraction? (15)</td></tr>
            </tbody>
            </table>
            <p>
            The chapters on addition and subtraction are pretty much the same in the two editions. The new chapter “Is This for Real?” draws from Chapter 18 (“From Abaci to Chips”) in the 1st edition to provide a little historical background and demonstrates that using transistors to add is essentially the same as using relays to add.
            </p>
            <p>
            Towards the end of the “Is This for Real?” chapter mention is made that real-life digital adders use techniques such as lookahead-carry to speed up the addition. As a bonus, I discuss and demonstrate how lookahead-carry logic works on the website. (Did I mention the website? It’s <a href="https://www.codehiddenlanguage.com">CodeHiddenLanguage.com</a>.)
            </p>
            <p>
            The next sequence of chapters is also similar:
            </p>
            <table>
            <tbody>
            <tr><th>1st Edition</th><th>2nd Edition</th></tr>
            <tr><td>14. Feedback and Flip-Flops (25)</td><td>17. Feedback and Flip-Flops (28)</td></tr>
            <tr><td></td><td>18. Let’s Build a Clock! (26)</td></tr>
            <tr><td>15. Bytes and Hex (10)</td><td></td></tr>
            <tr><td>16. An Assemblage of Memory (16)</td><td>19. An Assemblage of Memory (22)</td></tr>
            <tr><td>17. Automation (32)</td><td>20. Automating Arithmetic (25)</td></tr>
            </tbody>
            </table>
            <p>
            I’m a clock nut and perhaps some of my readers are clock nuts as well. I had lots of fun building the Binary Coded Decimal (BCD) clock in Chapter 18 and showing various types of numeric outputs. These are all replicated as animated graphics on the website. You should check it out. The dot matrix display was really tough to get the timing right. Lots of loud swearing was involved. My wife thought I was battling monsters. But it does give a sense of how refreshing works, and it looks very cool.
            </p>
            <p>
            At this point, the 1st edition (as I said earlier) punked out:
            </p>
            <table>
            <tbody>
            <tr><th>1st Edition</th><th>2nd Edition</th></tr>
            <tr><td>18. From Abaci to Chips (22)</td><td></td></tr>
            <tr><td>19. Two Classic Microprocessors (26)</td><td></td></tr>
            </tbody>
            </table>
            <p>
            As I mentioned, I incorporated some of the background history in the 1st edition’s Chapter 18 into the 2nd edition’s Chapter 15 (“Is This for Real?”), but I then decided to go in a totally different direction. I decided to build a CPU that implemented a subset (more than half) of the instruction codes in one of the most historically important microprocessors, the Intel 8080:
            </p>
            <table>
            <tbody>
            <tr><th>1st Edition</th><th>2nd Edition</th></tr>
            <tr><td></td><td>21. The Arithmetic Logic Unit (19)</td></tr>
            <tr><td></td><td>22. Registers and Busses (19)</td></tr>
            <tr><td></td><td>23. CPU Control Signals (24)</td></tr>
            <tr><td></td><td>24. Loops, Jumps, and Calls (24)</td></tr>
            </tbody>
            </table>
            <p>
            These chapters are all new, and they were hard to write, but I got to the point where this imaginary CPU implements conditional jumps and hence is <a href=" https://en.wikipedia.org/wiki/Turing_completeness">Turing complete</a>. Chapter 24 discusses calls and returns, and the convenience of bit shifting operations, but does not implement them.
            </p>
            <p>
            If you read and enjoyed the 1st edition of <i>Code</i>, and you’d like some additional stuff along the same lines, these four chapters are perhaps the most compelling reason to pick up the 2nd edition. If the prospect of assimilating these four chapters frightens you, perhaps it’s best to avoid them.
            </p>
            <p>
            In both editions, we now have a CPU. <i>Code</i> needs to discuss what else you need for a complete computer. This is roughly equivalent in both editions:
            </p>
            <table>
            <tbody>
            <tr><th>1st Edition</th><th>2nd Edition</th></tr>
            <tr><td>20. ASCII and a Cast of Characters (15)</td><td></td></tr>
            <tr><td>21. Get on the Bus (19)</td><td>25. Peripherals (10)</td></tr>
            <tr><td>22. The Operating System (15)</td><td>26. The Operating System (12)</td></tr>
            <tr><td>23. Fixed Point, Floating Point (14)</td><td></td></tr>
            <tr><td>24. Languages High and Low (15)</td><td>27. Coding (21)</td></tr>
            <tr><td>25. The Graphical Revolution (19)</td><td></td></tr>
            <tr><td></td><td>28. The World Brain (13)</td></tr>
            </tbody>
            </table>
            <p>
            Although this table shows some chapters in the 1st and 2nd editions side by side, the contents of the chapters were radically changed. Much of the “Get on the Bus” chapter seemed like oldie-moldies to me (was a discussion of the S-100 bus really necessary?) and instead in the “Peripherals” chapter I focused on video displays and more modern components such as touch screens and the pervasive analog-to-digitial converter (ADC) and digital-to-analog converter (DAC).
            </p>
            <p>
            The original Chapter 25 (“The Graphical Revolution”) discussed graphical user interfaces (GUIs) such as the Mac and Windows. At the time I was writing the 1st edition, Mac users were using a GUI for over a decade, but Windows 3.1 had only been introduced in 1992. Nowadays, of course, a UI is a GUI, so whatever was useful from this chapter I integrated into the new “Operating System” chapter.
            </p>
            <p>
            Chapter 14 (“Fixed Point, Floating Point”) discussed how numbers are stored in memory. I integrated that into the new “Coding” chapter.
            </p>
            <p>
            In the original “Languages High and Low” chapter, I chose to highlight an extremely influential high-level programming language. This was ALGOL, which (of course) has the drawback that it hasn’t been used for many years except possibly by a few retrocomputing fanatics.
            </p>
            <p>
            For the “Coding” chapter of the new edition, I wanted a programming language that readers could actually experiment with, but without the hassle of downloading something. I wished dearly that the Mac and Windows came with built-in BASIC environments. If that were the case, the language I would have discussed in this chapter would have been BASIC.
            </p>
            <p>
            But I didn’t have that freedom. My hands were tied. There was only one real choice. My free will meant nothing, and I was forced into JavaScript.
            </p>
            <p>
            So it goes. The only consolation is that I’m not the only person in the world forced into using JavaScript. There are literally millions.
            </p>
            <p>
            Which brings us to the last chapter. Over the years, whenever someone asked me if there would be a 2nd edition of <i>Code</i>, I’d ask “What would you like to see in a 2nd edition?” and the answer would invariably be “The internet.”
            </p>
            <p>
            I wasn’t happy with that answer because I realized that any kind of reasonably detailed technical discussion of how the internet worked would require a great many pages. To me, the main thrust and focus of <i>Code</i> is how simple switching devices (relays or transistors) can build entire computers, and this didn’t seem quite in line with that.
            </p>
            <p>
            The final chapter of the 2nd edition of <i>Code</i> is entitled “The World Brain,” and it begins with a discussion of anticipations of the internet by H.G. Wells (who published a book called “World Brain”), Vannevar Bush (Memex), and Ted Nelson. Then I discuss how bits flow through long wires through modulation, and how a web browser uses HTTP to get files, and (if necessary) execute some JavaScript, which I fortunately discussed in the previous chapter.
            </p>
            <p>
            I don’t know if this chapter will satisfy anyone, but one of my big hopes is that someday someone will write a book much like <i>Code</i> but about the Internet. I’m not going to do it. But if you do a good job, I will certainly buy a copy.
            </p>


        </article></div>
  </body>
</html>
