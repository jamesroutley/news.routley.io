<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.sctheblog.com/blog/hair-software-rasterize/">Original</a>
    <h1>Software Rasterizing Hair</h1>
    
    <div id="readability-page-1" class="page"><div><p>In the last few years, we have seen more rendering systems that lean on software rasterization. It’s an optimal choice for small triangles (~1 px wide) or thin triangles that span many pixels (especially diagonals). Two of the most known examples are <a href="https://advances.realtimerendering.com/s2021/Karis_Nanite_SIGGRAPH_Advances_2021_final.pdf#page=81">UE5’s Nanite</a> (which I’ve reimplemented in <a href="https://github.com/Scthe/nanite-webgpu">Nanite WebGPU</a>) and <a href="https://www.youtube.com/watch?v=ool2E8SQPGU">Frostbite’s hair system</a> (which I’ve reimplemented in <a href="https://github.com/Scthe/frostbitten-hair-webgpu">Frostbitten hair WebGPU</a>). Basic software rasterization for triangles has been described countless times e.g.:</p>
<ul>
<li><a href="https://fgiesen.wordpress.com/2013/02/06/the-barycentric-conspirac/">“The barycentric conspiracy”</a> and <a href="https://fgiesen.wordpress.com/2013/02/10/optimizing-the-basic-rasterizer/">“Optimizing the basic rasterizer”</a> by Fabian “ryg” Giesen.</li>
<li><a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/rasterization-stage.html">“Rasterization”</a> by Scratchapixel.</li>
<li><a href="https://jtsorlinis.github.io/rendering-tutorial/">“Rasterising a triangle”</a> by Jason Tsorlinis.</li>
</ul>
<p>In this article, we will see the rasterization algorithm for hair. Starting from a file that contains strand points in 3D space and ending on pixel attributes inside a quad. First, we will see the required 3D transformations to produce projected vertices. Then we will go over triangle rasterization basics, and see the same function applied to quads. We will also need coordinates inside each rasterized hair segment to compute attributes. For each section I will also link code from my “Frostbitten hair WebGPU” so you can see how this works in practice.</p>
<figure><div data-rmiz-wrap="visible"><p><img src="https://ntietz.com/static/402e405d42e2e7801c1fcfb3be88bf7a/fbb82/frostbitten-hair-static-img.jpg" srcset="/static/402e405d42e2e7801c1fcfb3be88bf7a/06087/frostbitten-hair-static-img.jpg 320w,
/static/402e405d42e2e7801c1fcfb3be88bf7a/0a033/frostbitten-hair-static-img.jpg 640w,
/static/402e405d42e2e7801c1fcfb3be88bf7a/fbb82/frostbitten-hair-static-img.jpg 1280w" sizes="(min-width: 1280px) 1280px, 100vw" alt="A character with beautifully rendered hair." decoding="async" loading="lazy" width="1280" height="720"/></p></div><figcaption><p>Software-rasterized hair with analytical anti-aliasing and order-independent transparency. Screen from my <a href="https://github.com/Scthe/frostbitten-hair-webgpu">Frostbitten hair WebGPU</a>.</p></figcaption></figure>
<h2 id="basic-terminology">Basic terminology<a aria-hidden="true" href="#basic-terminology" tabindex="-1">§</a></h2>
<p>Let’s go over some terminology:</p>
<ul>
<li><strong>Hair strand</strong>. Each single hair strand is created from connected points. It anchors to the head at the <strong>root</strong> point and ends at the <strong>tip</strong> point.</li>
<li><strong>Points</strong>. Each strand contains the same number of points. The first point is the root, last is the tip.</li>
<li><strong>Segment</strong>. Fragment of the strand between 2 consecutive points. If the strand has N points, it has N-1 segments.</li>
<li><strong>Tangent</strong>. A normalized vector from <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>o</mi><mi>i</mi><mi>n</mi><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">Point_i</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>P</span><span>o</span><span>in</span><span><span>t</span><span><span><span><span><span><span></span><span><span>i</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span> to <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>o</mi><mi>i</mi><mi>n</mi><msub><mi>t</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">Point_{i+1}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>P</span><span>o</span><span>in</span><span><span>t</span><span><span><span><span><span><span></span><span><span><span>i</span><span>+</span><span>1</span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span>. The last point for each strand (tip) has the same tangent as its predecessor. Tangents are always precalculated in a separate GPU buffer.</li>
</ul>
<figure><div data-rmiz-wrap="visible"><p><img src="https://ntietz.com/static/d6c436c2df7433f8c6dc9f74e0335899/9066d/basic-terminology.jpg" srcset="/static/d6c436c2df7433f8c6dc9f74e0335899/4a5ed/basic-terminology.jpg 300w,
/static/d6c436c2df7433f8c6dc9f74e0335899/9a098/basic-terminology.jpg 600w,
/static/d6c436c2df7433f8c6dc9f74e0335899/9066d/basic-terminology.jpg 1200w" sizes="(min-width: 1200px) 1200px, 100vw" alt="Hair segments between points growing from character head mesh." decoding="async" loading="lazy" width="1200" height="1000"/></p></div><figcaption><p>Single hair strand. The root is the first point in the strand, tip is the last. If there are 4 points, there are 3 hair segments. Each point has a tangent vector.</p></figcaption></figure>
<h2 id="projecting-spline-points">Projecting spline points<a aria-hidden="true" href="#projecting-spline-points" tabindex="-1">§</a></h2>
<p>In Blender, the hair particle system is a collection of splines. Splines have control points. Everyone has seen the smoothness of bezier curves, etc. Real-time representations usually quantize each strand into discrete points - I do it in <a href="https://github.com/Scthe/frostbitten-hair-webgpu/blob/master/scripts/tfx_exporter.py">my Blender exporter</a>. The <strong>number of points per strand</strong> is customizable and depends on the hairstyle. Short hair can get away with as little as 3 points. For example, my <a href="https://scthe.github.io/frostbitten-hair-webgpu">Frostbitten hair WebGPU</a> uses 16 points per strand. Increasing the number of points provides a smoother look at the cost of complexity. The rendering performance hit depends on the selected technique. As I’ve discovered, in Frostbite’s tech, the cost evaluation is quite complicated. While you have to process more segments in the tile pass, the fine pass often reaches enough pixel/tile “opaqueness” to return early during the processing. This optimization happens regardless of strand count.</p>
<p>The question now stands: “How to turn connected points into pixel coordinates?“. We will be using billboards that have width controlled by <code>fiberRadius</code> parameter. Increasing <code>fiberRadius</code> makes each strand wider.</p>
<h3 id="projecting-hair-as-billboards">Projecting hair as billboards<a aria-hidden="true" href="#projecting-hair-as-billboards" tabindex="-1">§</a></h3>
<p>Billboard always faces the player. It’s a plane whose normal points toward the camera. We can calculate the vertex coordinates inside the shader. For each hair point, we have a tangent vector that points toward the next point. From the definition of the <a href="https://en.wikipedia.org/wiki/Cross_product">cross product</a>, we can find a vector perpendicular to both the tangent and the toward-camera vector. The coordinates for 2 vertices are given by moving along this vector. The first point is moved by <code>fiberRadius</code>, the other by <code>-fiberRadius</code>. Lastly, we multiply by the view-projection matrix.</p>
<figure><div data-rmiz-wrap="visible"><p><img src="https://ntietz.com/static/e077e8a5a875bf5ebb7b29d4b9649301/6039a/hair-strips-explanation.png" srcset="/static/e077e8a5a875bf5ebb7b29d4b9649301/085ec/hair-strips-explanation.png 400w,
/static/e077e8a5a875bf5ebb7b29d4b9649301/aba13/hair-strips-explanation.png 800w,
/static/e077e8a5a875bf5ebb7b29d4b9649301/6039a/hair-strips-explanation.png 1600w" sizes="(min-width: 1600px) 1600px, 100vw" alt="Vectors that create a mesh in billboard renderer." decoding="async" loading="lazy" width="1600" height="1049"/></p></div><figcaption><p>Algorithm for hair billboard renderer. <strong>Tangent</strong> - vector toward the next point (unless it’s a tip/last point). <strong>Bitangent</strong> - a vector at a right angle to both tangent and to-camera vector. Each mesh’s vertex is created by moving <code>fiberRadius</code> along the bitangent (with either positive or negative magnitude). An alternative way to visualize this is to imagine a plane created from tangent and to-camera vectors. Bitangent is the normal vector of this plane.</p></figcaption></figure>
<div><pre><p><span>struct</span><span> </span><span>ProjectedStrandPoint</span><span> </span><span>{</span><span></span></p><p><span>  v0</span><span>:</span><span> vec2f</span><span>,</span><span> </span><span></span></p><p><span>  v1</span><span>:</span><span> vec2f</span><span>,</span><span> </span><span></span></p><p><span>  depth0</span><span>:</span><span> </span><span>f32</span><span>,</span><span></span></p><p><span>  depth1</span><span>:</span><span> </span><span>f32</span><span>,</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>let</span><span> segmentStartPoint </span><span>=</span><span> </span><span>projectHairPoint</span><span>(</span><span>strandIdx</span><span>,</span><span> pointIdx</span><span>)</span><span>;</span><span></span></p><p><span></span><span>let</span><span> segmentEndPoint   </span><span>=</span><span> </span><span>projectHairPoint</span><span>(</span><span>strandIdx</span><span>,</span><span> pointIdx </span><span>+</span><span> </span><span>1</span><span>)</span><span>;</span><span></span></p><p><span></span><span>fn</span><span> </span><span>projectHairPoint</span><span>(</span><span>strandIdx</span><span>:</span><span> </span><span>u32</span><span>,</span><span> pointIdx</span><span>:</span><span> </span><span>u32</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>ProjectedStrandPoint</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>let</span><span> p_OBJ </span><span>=</span><span> </span><span>_getHairPointPosition</span><span>(</span><span>_pointsPerStrand</span><span>,</span><span> strandIdx</span><span>,</span><span> pointIdx</span><span>)</span><span>.</span><span>xyz</span><span>;</span><span></span></p><p><span>  </span><span>let</span><span> p_WS</span><span>:</span><span> vec4f </span><span>=</span><span> _modelMat </span><span>*</span><span> </span><span>vec4f</span><span>(</span><span>p_OBJ</span><span>,</span><span> </span><span>1.0</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>let</span><span> t_OBJ </span><span>=</span><span> </span><span>_getHairTangent</span><span>(</span><span>_pointsPerStrand</span><span>,</span><span> strandIdx</span><span>,</span><span> pointIdx</span><span>)</span><span>.</span><span>xyz</span></p><p><span>  </span><span>let</span><span> t_WS</span><span>:</span><span> vec4f </span><span>=</span><span> _modelMat </span><span>*</span><span> </span><span>vec4f</span><span>(</span><span>t_OBJ</span><span>,</span><span> </span><span>1.0</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>let</span><span> towardsCamera</span><span>:</span><span> vec3f </span><span>=</span><span> </span><span>normalize</span><span>(</span><span>_cameraPositionWS</span><span>.</span><span>xyz </span><span>-</span><span> p_WS</span><span>.</span><span>xyz</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>let</span><span> right</span><span>:</span><span> vec3f </span><span>=</span><span> </span><span>normalize</span><span>(</span><span>cross</span><span>(</span><span>t_WS</span><span>.</span><span>xyz</span><span>,</span><span> towardsCamera</span><span>)</span><span>)</span><span>.</span><span>xyz </span><span>*</span><span> _fiberRadius</span><span>;</span><span></span></p><p><span>  </span><span>let</span><span> v0_WS </span><span>=</span><span> </span><span>vec4f</span><span>(</span><span>p_WS</span><span>.</span><span>xyz </span><span>-</span><span> right</span><span>,</span><span> </span><span>1.0</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>let</span><span> v1_WS </span><span>=</span><span> </span><span>vec4f</span><span>(</span><span>p_WS</span><span>.</span><span>xyz </span><span>+</span><span> right</span><span>,</span><span> </span><span>1.0</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>let</span><span> v0_NDC</span><span>:</span><span> vec3f </span><span>=</span><span> </span><span>projectVertex</span><span>(</span><span>_viewProjMat</span><span>,</span><span> v0_WS</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>let</span><span> v1_NDC</span><span>:</span><span> vec3f </span><span>=</span><span> </span><span>projectVertex</span><span>(</span><span>_viewProjMat</span><span>,</span><span> v1_WS</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>return</span><span> </span><span>ProjectedStrandPoint</span><span>(</span><span></span></p><p><span>    </span><span>ndc2viewportPx</span><span>(</span><span>_viewportSize</span><span>.</span><span>xy</span><span>,</span><span> v0_NDC</span><span>)</span><span>,</span><span></span></p><p><span>    </span><span>ndc2viewportPx</span><span>(</span><span>_viewportSize</span><span>.</span><span>xy</span><span>,</span><span> v1_NDC</span><span>)</span><span>,</span><span></span></p><p><span>    v0_NDC</span><span>.</span><span>z</span><span>,</span><span></span></p><p><span>    v1_NDC</span><span>.</span><span>z</span></p><p><span>  </span><span>)</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>fn</span><span> </span><span>projectVertex</span><span>(</span><span>mvpMat</span><span>:</span><span> mat4x4f</span><span>,</span><span> pos</span><span>:</span><span> vec4f</span><span>)</span><span> </span><span>-&gt;</span><span> vec3f </span><span>{</span><span></span></p><p><span>  </span><span>let</span><span> posClip </span><span>=</span><span> mvpMat </span><span>*</span><span> pos</span><span>;</span><span></span></p><p><span>  </span><span>let</span><span> posNDC </span><span>=</span><span> posClip </span><span>/</span><span> posClip</span><span>.</span><span>w</span><span>;</span><span></span></p><p><span>  </span><span>return</span><span> posNDC</span><span>.</span><span>xyz</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>fn</span><span> </span><span>ndc2viewportPx</span><span>(</span><span>viewportSize</span><span>:</span><span> vec2f</span><span>,</span><span> pos</span><span>:</span><span> vec3f</span><span>)</span><span> </span><span>-&gt;</span><span> vec2f </span><span>{</span><span></span></p><p><span>  </span><span>let</span><span> pos_0_1 </span><span>=</span><span> pos</span><span>.</span><span>xy </span><span>*</span><span> </span><span>0.5</span><span> </span><span>+</span><span> </span><span>0.5</span><span>;</span><span> </span><span></span></p><p><span>  </span><span>return</span><span> pos_0_1 </span><span>*</span><span> viewportSize</span><span>.</span><span>xy</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div>
<blockquote>
<p>Link to “Frostbitten hair WebGPU”: <a href="https://github.com/Scthe/frostbitten-hair-webgpu/blob/501f01969b4bc65cb7df3b901c1ced4e2da0c84b/src/passes/swHair/shaderImpl/swRasterizeHair.wgsl.ts#L39">swRasterizeHair.wgsl.ts # projectHairSegment()</a>.</p>
</blockquote>
<p>You might be considering calculating the <code>right</code> vector in view space with <code>let towardsCamera = vec3f(0, 0, 1)</code>. It will not work. Half of the strands will render with <code>towardsCamera.z = 1</code>, the rest with <code>towardsCamera = -1</code>. I’m not sure why (view space is weird), so I switched to world space calculations.</p>
<p>For each segment (consisting of start and end points) we now have 4 projected points. Use them as vertices in quad rasterization.</p>
<h2 id="software-rasterization">Software rasterization<a aria-hidden="true" href="#software-rasterization" tabindex="-1">§</a></h2>
<p>First, we will find a way to check on which side of a line the point lies. With 3 lines this function allows to rasterize a triangle. With 4 lines we get quad.</p>
<h3 id="edge-function">Edge function<a aria-hidden="true" href="#edge-function" tabindex="-1">§</a></h3>
<p>We start with a line <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">y=1</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>y</span><span></span><span>=</span><span></span></span><span><span></span><span>1</span></span></span></span></span> and a point <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>=</mo><mo stretchy="false">(</mo><mn>4</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P=(4, 3)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>P</span><span></span><span>=</span><span></span></span><span><span></span><span>(</span><span>4</span><span>,</span><span></span><span>3</span><span>)</span></span></span></span></span>. Our goal is to check on which side of the line the point lies. Let’s mark 2 points on this line: <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A=(0,1)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span><span></span><span>=</span><span></span></span><span><span></span><span>(</span><span>0</span><span>,</span><span></span><span>1</span><span>)</span></span></span></span></span>, <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><mo stretchy="false">(</mo><mn>4</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">B=(4,1)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>B</span><span></span><span>=</span><span></span></span><span><span></span><span>(</span><span>4</span><span>,</span><span></span><span>1</span><span>)</span></span></span></span></span> and calculate the area of triangle <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo separator="true">,</mo><mi>P</mi></mrow><annotation encoding="application/x-tex">A, B, P</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span><span>,</span><span></span><span>B</span><span>,</span><span></span><span>P</span></span></span></span></span> using the <a href="https://en.wikipedia.org/wiki/Shoelace_formula">Shoelace formula</a>:</p>
<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>⋅</mo><mo stretchy="false">[</mo><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>B</mi></msub><mo>−</mo><msub><mi>x</mi><mi>A</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>y</mi><mi>P</mi></msub><mo>−</mo><msub><mi>y</mi><mi>A</mi></msub><mo stretchy="false">)</mo><mo>−</mo><mo stretchy="false">(</mo><msub><mi>y</mi><mi>B</mi></msub><mo>−</mo><msub><mi>y</mi><mi>A</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mi>P</mi></msub><mo>−</mo><msub><mi>x</mi><mi>A</mi></msub><mo stretchy="false">)</mo></mrow><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A = \frac{1}{2} \cdot [{(x_B - x_A)(y_P-y_A) - (y_B-y_A)(x_P-x_A)}]</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span><span></span><span>=</span><span></span></span><span><span></span><span><span></span><span><span><span><span><span><span></span><span><span>2</span></span></span><span><span></span><span></span></span><span><span></span><span><span>1</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span></span></span><span></span><span>⋅</span><span></span></span><span><span></span><span>[</span><span><span>(</span><span><span>x</span><span><span><span><span><span><span></span><span><span>B</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>−</span><span></span><span><span>x</span><span><span><span><span><span><span></span><span><span>A</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>)</span><span>(</span><span><span>y</span><span><span><span><span><span><span></span><span><span>P</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>−</span><span></span><span><span>y</span><span><span><span><span><span><span></span><span><span>A</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>)</span><span></span><span>−</span><span></span><span>(</span><span><span>y</span><span><span><span><span><span><span></span><span><span>B</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>−</span><span></span><span><span>y</span><span><span><span><span><span><span></span><span><span>A</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>)</span><span>(</span><span><span>x</span><span><span><span><span><span><span></span><span><span>P</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>−</span><span></span><span><span>x</span><span><span><span><span><span><span></span><span><span>A</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>)</span></span><span>]</span></span></span></span></span></p>
<figure><div data-rmiz-wrap="visible"><p><img src="https://ntietz.com/static/b25a2f3050c2c9ac96c671da02d835ef/bd57c/edge-fn-triangle-1.png" srcset="/static/b25a2f3050c2c9ac96c671da02d835ef/36a1c/edge-fn-triangle-1.png 284w,
/static/b25a2f3050c2c9ac96c671da02d835ef/0ab2d/edge-fn-triangle-1.png 569w,
/static/b25a2f3050c2c9ac96c671da02d835ef/bd57c/edge-fn-triangle-1.png 1137w" sizes="(min-width: 1137px) 1137px, 100vw" alt="Triangle with points: A=(0, 1), B=(4, 1), P=(4, 3)." decoding="async" loading="lazy" width="1137" height="862"/></p></div><figcaption><p>Triangle with points: A=(0, 1), B=(4, 1), P=(4, 3). Notice the direction of vector AB and the relative position of point P.</p></figcaption></figure>
<p>Plugging the values:</p>
<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>⋅</mo><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mn>4</mn><mo>−</mo><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>3</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>−</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>4</mn><mo>−</mo><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A_1 = \frac{1}{2} \cdot [(4-0)(3-1) - (1-1)(4-0)]</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>A</span><span><span><span><span><span><span></span><span><span>1</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>=</span><span></span></span><span><span></span><span><span></span><span><span><span><span><span><span></span><span><span>2</span></span></span><span><span></span><span></span></span><span><span></span><span><span>1</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span></span></span><span></span><span>⋅</span><span></span></span><span><span></span><span>[(</span><span>4</span><span></span><span>−</span><span></span></span><span><span></span><span>0</span><span>)</span><span>(</span><span>3</span><span></span><span>−</span><span></span></span><span><span></span><span>1</span><span>)</span><span></span><span>−</span><span></span></span><span><span></span><span>(</span><span>1</span><span></span><span>−</span><span></span></span><span><span></span><span>1</span><span>)</span><span>(</span><span>4</span><span></span><span>−</span><span></span></span><span><span></span><span>0</span><span>)]</span></span></span></span></span></p>
<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>⋅</mo><mo stretchy="false">[</mo><mn>4</mn><mo>⋅</mo><mn>2</mn><mo>−</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">A_1 = \frac{1}{2} \cdot [4 \cdot 2 - 0] = 4</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>A</span><span><span><span><span><span><span></span><span><span>1</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>=</span><span></span></span><span><span></span><span><span></span><span><span><span><span><span><span></span><span><span>2</span></span></span><span><span></span><span></span></span><span><span></span><span><span>1</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span></span></span><span></span><span>⋅</span><span></span></span><span><span></span><span>[</span><span>4</span><span></span><span>⋅</span><span></span></span><span><span></span><span>2</span><span></span><span>−</span><span></span></span><span><span></span><span>0</span><span>]</span><span></span><span>=</span><span></span></span><span><span></span><span>4</span></span></span></span></span></p>
<p>Let’s try swapping coordinates for points <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span></span></span></span></span> and <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>B</span></span></span></span></span>:</p>
<figure><div data-rmiz-wrap="visible"><p><img src="https://ntietz.com/static/fc18aed204042fe6547e15e374130403/bd57c/edge-fn-triangle-2.png" srcset="/static/fc18aed204042fe6547e15e374130403/36a1c/edge-fn-triangle-2.png 284w,
/static/fc18aed204042fe6547e15e374130403/0ab2d/edge-fn-triangle-2.png 569w,
/static/fc18aed204042fe6547e15e374130403/bd57c/edge-fn-triangle-2.png 1137w" sizes="(min-width: 1137px) 1137px, 100vw" alt="Triangle with points: A=(4, 1), B=(0, 1), P=(4, 3)." decoding="async" loading="lazy" width="1137" height="862"/></p></div><figcaption><p>The same triangle after we swapped points A and B. Notice the direction of vector AB and the relative position of point P.</p></figcaption></figure>
<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>A</mi><mn>2</mn></msub><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>⋅</mo><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mn>0</mn><mo>−</mo><mn>4</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>3</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>−</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>4</mn><mo>−</mo><mn>4</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A_2 = \frac{1}{2} \cdot [(0 - 4)(3 - 1) - (1 - 1)(4 - 4)]</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>A</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>=</span><span></span></span><span><span></span><span><span></span><span><span><span><span><span><span></span><span><span>2</span></span></span><span><span></span><span></span></span><span><span></span><span><span>1</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span></span></span><span></span><span>⋅</span><span></span></span><span><span></span><span>[(</span><span>0</span><span></span><span>−</span><span></span></span><span><span></span><span>4</span><span>)</span><span>(</span><span>3</span><span></span><span>−</span><span></span></span><span><span></span><span>1</span><span>)</span><span></span><span>−</span><span></span></span><span><span></span><span>(</span><span>1</span><span></span><span>−</span><span></span></span><span><span></span><span>1</span><span>)</span><span>(</span><span>4</span><span></span><span>−</span><span></span></span><span><span></span><span>4</span><span>)]</span></span></span></span></span></p>
<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>A</mi><mn>2</mn></msub><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>⋅</mo><mo stretchy="false">[</mo><mo>−</mo><mn>4</mn><mo>⋅</mo><mn>2</mn><mo>−</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mo>−</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">A_2 = \frac{1}{2} \cdot [-4 \cdot 2 - 0] = -4</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>A</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>=</span><span></span></span><span><span></span><span><span></span><span><span><span><span><span><span></span><span><span>2</span></span></span><span><span></span><span></span></span><span><span></span><span><span>1</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span></span></span><span></span><span>⋅</span><span></span></span><span><span></span><span>[</span><span>−</span><span>4</span><span></span><span>⋅</span><span></span></span><span><span></span><span>2</span><span></span><span>−</span><span></span></span><span><span></span><span>0</span><span>]</span><span></span><span>=</span><span></span></span><span><span></span><span>−</span><span>4</span></span></span></span></span></p>
<p>Wait, how can an area of a triangle be negative? Well, you should take the absolute value here. But that was not our goal. We are only interested in why the sign switched.</p>
<p>Let’s now consider the relative positions of the 3 points. In the first example, imagine you are standing on point <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span></span></span></span></span> and looking toward point <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>B</span></span></span></span></span> (along the green arrow). Then, the point <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>P</span></span></span></span></span> is on your left side. Repeat this after swapping positions of points <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span></span></span></span></span>, and <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>B</span></span></span></span></span> (again, look at the green arrow). The point <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>P</span></span></span></span></span> is now on the right side. Generalizing this observation, the <strong>edge function</strong> results in one of 3 outcomes:</p>
<ul>
<li>If the value is <strong>negative</strong>, the point lies <strong>on one side</strong> of the line.</li>
<li>If the value is <strong>positive</strong>, the point lies <strong>on the other side</strong> of the line.</li>
<li>If the value is 0, the point lies on the line.</li>
</ul>
<blockquote>
<p>You might also notice that the result depends on the clockwise/counterclockwise order of vertices. This is useful for triangle culling. We will not use this property for hair.</p>
</blockquote>
<h3 id="using-edge-function-to-rasterize-triangles">Using edge function to rasterize triangles<a aria-hidden="true" href="#using-edge-function-to-rasterize-triangles" tabindex="-1">§</a></h3>
<p>Now we can check which “side” of the line a point (or a pixel) lies. If we have 3 lines, there will be an area that lies on the same side of each line.</p>
<figure><div data-rmiz-wrap="visible"><p><img src="https://ntietz.com/static/e3ec64b5c69650f4159ab5c9cc013a74/1f46f/sw-raster-triangle.png" srcset="/static/e3ec64b5c69650f4159ab5c9cc013a74/a3cb9/sw-raster-triangle.png 200w,
/static/e3ec64b5c69650f4159ab5c9cc013a74/5ec02/sw-raster-triangle.png 400w,
/static/e3ec64b5c69650f4159ab5c9cc013a74/1f46f/sw-raster-triangle.png 800w" sizes="(min-width: 800px) 800px, 100vw" alt="Area within 3 lines is a triangle." decoding="async" loading="lazy" width="800" height="589"/></p></div><figcaption><p>The area within 3 lines is a triangle.</p></figcaption></figure>
<p>This is how the simplest triangle rasterization works. For each pixel in the canvas, calculate the value for all 3 edge functions and check if <strong>all</strong> are negative (or positive depending on vertex winding). You can optimize this by calculating triangle bounds. For triangle that spans on vertices <code>v0</code>, <code>v1</code>, <code>v2</code> write following rasterization code:</p>
<div><pre><p><span>var boundRectMin </span><span>=</span><span> </span><span>floor</span><span>(</span><span>min</span><span>(</span><span>min</span><span>(</span><span>v0</span><span>,</span><span> v1</span><span>)</span><span>,</span><span> v2</span><span>)</span><span>)</span><span>;</span><span></span></p><p><span>var boundRectMax </span><span>=</span><span> </span><span>ceil</span><span> </span><span>(</span><span>max</span><span>(</span><span>max</span><span>(</span><span>v0</span><span>,</span><span> v1</span><span>)</span><span>,</span><span> v2</span><span>)</span><span>)</span><span>;</span><span></span></p><p><span>boundRectMin </span><span>=</span><span> </span><span>max</span><span>(</span><span>boundRectMin</span><span>,</span><span> </span><span>vec2</span><span>(</span><span>0</span><span>)</span><span>)</span><span>;</span><span></span></p><p><span>boundRectMax </span><span>=</span><span> </span><span>min</span><span>(</span><span>boundRectMax</span><span>,</span><span> _viewportSize</span><span>.</span><span>xy</span><span>)</span><span>;</span><span></span></p><p><span></span><span>for</span><span> </span><span>(</span><span>var y </span><span>=</span><span> boundRectMin</span><span>.</span><span>y</span><span>;</span><span> y </span><span>&lt;</span><span> boundRectMax</span><span>.</span><span>y</span><span>;</span><span> y </span><span>+=</span><span> </span><span>1</span><span>)</span><span> </span><span>{</span><span></span></p><p><span></span><span>for</span><span> </span><span>(</span><span>var x </span><span>=</span><span> boundRectMin</span><span>.</span><span>x</span><span>;</span><span> x </span><span>&lt;</span><span> boundRectMax</span><span>.</span><span>x</span><span>;</span><span> x </span><span>+=</span><span> </span><span>1</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>let</span><span> p </span><span>=</span><span> </span><span>vec2f</span><span>(</span><span>x</span><span>,</span><span> y</span><span>)</span><span>;</span><span> </span><span></span></p><p><span>  </span><span>let</span><span> </span><span>C0</span><span> </span><span>=</span><span> </span><span>edgeFunction</span><span>(</span><span>v2</span><span>,</span><span> v1</span><span>,</span><span> p</span><span>)</span><span>;</span><span> </span><span></span></p><p><span>  </span><span>let</span><span> </span><span>C1</span><span> </span><span>=</span><span> </span><span>edgeFunction</span><span>(</span><span>v0</span><span>,</span><span> v2</span><span>,</span><span> p</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>let</span><span> </span><span>C2</span><span> </span><span>=</span><span> </span><span>edgeFunction</span><span>(</span><span>v1</span><span>,</span><span> v0</span><span>,</span><span> p</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>if</span><span> </span><span>(</span><span>C0</span><span> </span><span>&gt;=</span><span> </span><span>0</span><span> </span><span>&amp;&amp;</span><span> </span><span>C1</span><span> </span><span>&gt;=</span><span> </span><span>0</span><span> </span><span>&amp;&amp;</span><span> </span><span>C2</span><span> </span><span>&gt;=</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>putPixel</span><span>(</span><span>p</span><span>,</span><span> </span><span>COLOR_BLUE</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>}</span><span></span></p><p><span></span><span>}</span><span>}</span><span></span></p><p><span></span><span>fn</span><span> </span><span>edgeFunction</span><span>(</span><span>v0</span><span>:</span><span> vec2f</span><span>,</span><span> v1</span><span>:</span><span> vec2f</span><span>,</span><span> p</span><span>:</span><span> vec2f</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>f32</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>return</span><span> </span><span>(</span><span>p</span><span>.</span><span>x </span><span>-</span><span> v0</span><span>.</span><span>x</span><span>)</span><span> </span><span>*</span><span> </span><span>(</span><span>v1</span><span>.</span><span>y </span><span>-</span><span> v0</span><span>.</span><span>y</span><span>)</span><span> </span><span>-</span><span> </span><span>(</span><span>p</span><span>.</span><span>y </span><span>-</span><span> v0</span><span>.</span><span>y</span><span>)</span><span> </span><span>*</span><span> </span><span>(</span><span>v1</span><span>.</span><span>x </span><span>-</span><span> v0</span><span>.</span><span>x</span><span>)</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div>
<p>Often you would also use the result of <code>edgeFunction()</code> to compute barycentric coordinates. This article focuses on hair (rendered as quads), and we will not use this property.</p>
<h3 id="half-of-the-pixel-offset">Half of the pixel offset<a aria-hidden="true" href="#half-of-the-pixel-offset" tabindex="-1">§</a></h3>
<p>Another issue is sampling. If you take a single sample per pixel, you should offset <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>p</span></span></span></span></span> by <code>vec2f(0.5, 0.5)</code> to sample in the center of the pixel. With multisampling, you should apply an appropriate offset to each sample. Read the specification for your graphic API to get exact values. Some APIs allow you to provide custom sampling patterns e.g. <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_sample_locations.html">VK_EXT_sample_locations()</a>. This is important if you are mixing hardware and software rasterization, e.g. by using a depth buffer.</p>
<blockquote>
<p>While at it, you should also check the exact <a href="https://learn.microsoft.com/en-us/windows/win32/direct3d11/d3d10-graphics-programming-guide-rasterizer-stage-rules#triangle-rasterization-rules-without-multisampling">triangle rasterization rules</a> (e.g. top-left rule, etc.).</p>
</blockquote>
<figure><div data-rmiz-wrap="visible"><p><img src="https://ntietz.com/static/7d0d787279f5ce70c6e97578151cb091/27a65/webgpu-rasterization-rules.png" srcset="/static/7d0d787279f5ce70c6e97578151cb091/4ae47/webgpu-rasterization-rules.png 215w,
/static/7d0d787279f5ce70c6e97578151cb091/55418/webgpu-rasterization-rules.png 429w,
/static/7d0d787279f5ce70c6e97578151cb091/27a65/webgpu-rasterization-rules.png 858w" sizes="(min-width: 858px) 858px, 100vw" alt="Excerpt from rasterization rules for WebGPU." decoding="async" loading="lazy" width="858" height="615"/></p></div><figcaption><p>Excerpt from <a href="https://www.w3.org/TR/webgpu/#rasterization">rasterization rules for WebGPU</a>.</p></figcaption></figure>
<h3 id="using-edge-function-to-rasterize-quads">Using edge function to rasterize quads<a aria-hidden="true" href="#using-edge-function-to-rasterize-quads" tabindex="-1">§</a></h3>
<p>Rasterizing quads is much more complicated. You have to call <code>edgeFunction()</code> 4 times.</p>
<figure><div data-rmiz-wrap="visible"><p><img src="https://ntietz.com/static/9896134379d72af28e340d8aabc5b5d6/ab4a4/sw-raster-quad.png" srcset="/static/9896134379d72af28e340d8aabc5b5d6/657e3/sw-raster-quad.png 200w,
/static/9896134379d72af28e340d8aabc5b5d6/593ad/sw-raster-quad.png 400w,
/static/9896134379d72af28e340d8aabc5b5d6/ab4a4/sw-raster-quad.png 800w" sizes="(min-width: 800px) 800px, 100vw" alt="Area within 4 lines is a quad." decoding="async" loading="lazy" width="800" height="618"/></p></div><figcaption><p>The area within 4 lines is a quad.</p></figcaption></figure>
<div><pre><p><span>var boundRectMin </span><span>=</span><span> </span><span>floor</span><span>(</span><span>min</span><span>(</span><span>min</span><span>(</span><span>v00</span><span>,</span><span> v01</span><span>)</span><span>,</span><span> </span><span>min</span><span>(</span><span>v10</span><span>,</span><span> v11</span><span>)</span><span>)</span><span>)</span><span>;</span><span></span></p><p><span>var boundRectMax </span><span>=</span><span> </span><span>ceil</span><span> </span><span>(</span><span>max</span><span>(</span><span>max</span><span>(</span><span>v00</span><span>,</span><span> v01</span><span>)</span><span>,</span><span> </span><span>max</span><span>(</span><span>v10</span><span>,</span><span> v11</span><span>)</span><span>)</span><span>)</span><span>;</span><span></span></p><p><span>boundRectMin </span><span>=</span><span> </span><span>max</span><span>(</span><span>boundRectMin</span><span>,</span><span> </span><span>vec2</span><span>(</span><span>0</span><span>)</span><span>)</span><span>;</span><span></span></p><p><span>boundRectMax </span><span>=</span><span> </span><span>min</span><span>(</span><span>boundRectMax</span><span>,</span><span> viewportSize</span><span>.</span><span>xy</span><span>)</span><span>;</span><span></span></p><p><span></span><span>for</span><span> </span><span>(</span><span>var y </span><span>=</span><span> boundRectMin</span><span>.</span><span>y</span><span>;</span><span> y </span><span>&lt;</span><span> boundRectMax</span><span>.</span><span>y</span><span>;</span><span> y </span><span>+=</span><span> </span><span>1</span><span>)</span><span> </span><span>{</span><span></span></p><p><span></span><span>for</span><span> </span><span>(</span><span>var x </span><span>=</span><span> boundRectMin</span><span>.</span><span>x</span><span>;</span><span> x </span><span>&lt;</span><span> boundRectMax</span><span>.</span><span>x</span><span>;</span><span> x </span><span>+=</span><span> </span><span>1</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>let</span><span> p </span><span>=</span><span> </span><span>vec2f</span><span>(</span><span>x</span><span>,</span><span> y</span><span>)</span><span>;</span><span> </span><span></span></p><p><span>  </span><span>let</span><span> </span><span>C0</span><span> </span><span>=</span><span> </span><span>edgeFunction</span><span>(</span><span>v01</span><span>,</span><span> v00</span><span>,</span><span> p</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>let</span><span> </span><span>C1</span><span> </span><span>=</span><span> </span><span>edgeFunction</span><span>(</span><span>v11</span><span>,</span><span> v01</span><span>,</span><span> p</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>let</span><span> </span><span>C2</span><span> </span><span>=</span><span> </span><span>edgeFunction</span><span>(</span><span>v10</span><span>,</span><span> v11</span><span>,</span><span> p</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>let</span><span> </span><span>C3</span><span> </span><span>=</span><span> </span><span>edgeFunction</span><span>(</span><span>v00</span><span>,</span><span> v10</span><span>,</span><span> p</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>if</span><span> </span><span>(</span><span>C0</span><span> </span><span>&gt;=</span><span> </span><span>0</span><span> </span><span>&amp;&amp;</span><span> </span><span>C1</span><span> </span><span>&gt;=</span><span> </span><span>0</span><span> </span><span>&amp;&amp;</span><span> </span><span>C2</span><span> </span><span>&gt;=</span><span> </span><span>0</span><span> </span><span>&amp;&amp;</span><span> </span><span>C3</span><span> </span><span>&gt;=</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>putPixel</span><span>(</span><span>p</span><span>,</span><span> </span><span>COLOR_LIGHT_PURPLE</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>}</span><span></span></p><p><span></span><span>}</span><span>}</span><span></span></p></pre></div>
<blockquote>
<p>The notation for <code>v0-</code> and <code>v1-</code> is relative to the hair segment. <code>v0-</code> denotes vertices near the start point. <code>v1-</code> denotes vertices near the end point.</p>
</blockquote>
<p>Given what’s written till this point, you should be able to software rasterize hair based on imported strand points.</p>
<blockquote>
<p>Link to “Frostbitten hair WebGPU”: <a href="https://github.com/Scthe/frostbitten-hair-webgpu/blob/501f01969b4bc65cb7df3b901c1ced4e2da0c84b/src/passes/swHair/hairTilesPass.wgsl.ts#L172">hairTilesPass.wgsl.ts</a>.</p>
</blockquote>
<h3 id="optimization-or-not">Optimization (or not)<a aria-hidden="true" href="#optimization-or-not" tabindex="-1">§</a></h3>
<p>Let’s look at the edge function again:</p>
<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mi>b</mi></msub><mo>−</mo><msub><mi>x</mi><mi>a</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>y</mi><mi>p</mi></msub><mo>−</mo><msub><mi>y</mi><mi>a</mi></msub><mo stretchy="false">)</mo><mo>−</mo><mo stretchy="false">(</mo><msub><mi>y</mi><mi>b</mi></msub><mo>−</mo><msub><mi>y</mi><mi>a</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mi>p</mi></msub><mo>−</mo><msub><mi>x</mi><mi>a</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f = (x_b - x_a)(y_p-y_a) - (y_b-y_a)(x_p-x_a)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>f</span><span></span><span>=</span><span></span></span><span><span></span><span>(</span><span><span>x</span><span><span><span><span><span><span></span><span><span>b</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>−</span><span></span></span><span><span></span><span><span>x</span><span><span><span><span><span><span></span><span><span>a</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>)</span><span>(</span><span><span>y</span><span><span><span><span><span><span></span><span><span>p</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>−</span><span></span></span><span><span></span><span><span>y</span><span><span><span><span><span><span></span><span><span>a</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>)</span><span></span><span>−</span><span></span></span><span><span></span><span>(</span><span><span>y</span><span><span><span><span><span><span></span><span><span>b</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>−</span><span></span></span><span><span></span><span><span>y</span><span><span><span><span><span><span></span><span><span>a</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>)</span><span>(</span><span><span>x</span><span><span><span><span><span><span></span><span><span>p</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>−</span><span></span></span><span><span></span><span><span>x</span><span><span><span><span><span><span></span><span><span>a</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>)</span></span></span></span></span></p>
<p>We are then iterating over <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mi>p</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>p</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p=(x_p, y_p)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>p</span><span></span><span>=</span><span></span></span><span><span></span><span>(</span><span><span>x</span><span><span><span><span><span><span></span><span><span>p</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>,</span><span></span><span><span>y</span><span><span><span><span><span><span></span><span><span>p</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>)</span></span></span></span></span>. A common optimization is to write the edge function in a form that matches <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>=</mo><mi>A</mi><mo>⋅</mo><msub><mi>x</mi><mi>p</mi></msub><mo>+</mo><mi>B</mi><mo>⋅</mo><msub><mi>y</mi><mi>p</mi></msub><mo>+</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">f = A \cdot x_p + B \cdot y_p + C</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>f</span><span></span><span>=</span><span></span></span><span><span></span><span>A</span><span></span><span>⋅</span><span></span></span><span><span></span><span><span>x</span><span><span><span><span><span><span></span><span><span>p</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>+</span><span></span></span><span><span></span><span>B</span><span></span><span>⋅</span><span></span></span><span><span></span><span><span>y</span><span><span><span><span><span><span></span><span><span>p</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>+</span><span></span></span><span><span></span><span>C</span></span></span></span></span>. This way, when we iterate over successive pixels in a row (only <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">x_p</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>x</span><span><span><span><span><span><span></span><span><span>p</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span> changes) we can just add <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span></span></span></span></span>. The <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>⋅</mo><msub><mi>y</mi><mi>p</mi></msub><mo>+</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">B \cdot y_p + C</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>B</span><span></span><span>⋅</span><span></span></span><span><span></span><span><span>y</span><span><span><span><span><span><span></span><span><span>p</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>+</span><span></span></span><span><span></span><span>C</span></span></span></span></span> part does not change. No reason to re-evaluate the whole edge function. Similar when switching to the next row. The code below might be helpful at this point.</p>
<p>In a triangle, there are 3 edges. So we precompute 3 different values of A, B, C (9 floats). Given 2 vertices that create an edge, we have the following formulas:</p>
<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mo>=</mo><msub><mi>y</mi><mi>a</mi></msub><mo>−</mo><msub><mi>y</mi><mi>b</mi></msub></mrow><annotation encoding="application/x-tex">A = y_a - y_b</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span><span></span><span>=</span><span></span></span><span><span></span><span><span>y</span><span><span><span><span><span><span></span><span><span>a</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>−</span><span></span></span><span><span></span><span><span>y</span><span><span><span><span><span><span></span><span><span>b</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></p>
<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>B</mi><mo>=</mo><msub><mi>x</mi><mi>b</mi></msub><mo>−</mo><msub><mi>x</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">B = x_b - x_a</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>B</span><span></span><span>=</span><span></span></span><span><span></span><span><span>x</span><span><span><span><span><span><span></span><span><span>b</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>−</span><span></span></span><span><span></span><span><span>x</span><span><span><span><span><span><span></span><span><span>a</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></p>
<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>C</mi><mo>=</mo><msub><mi>x</mi><mi>a</mi></msub><mo>⋅</mo><msub><mi>y</mi><mi>b</mi></msub><mo>−</mo><msub><mi>y</mi><mi>a</mi></msub><mo>⋅</mo><msub><mi>x</mi><mi>b</mi></msub></mrow><annotation encoding="application/x-tex">C = x_a \cdot y_b - y_a \cdot x_b</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>C</span><span></span><span>=</span><span></span></span><span><span></span><span><span>x</span><span><span><span><span><span><span></span><span><span>a</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>⋅</span><span></span></span><span><span></span><span><span>y</span><span><span><span><span><span><span></span><span><span>b</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>−</span><span></span></span><span><span></span><span><span>y</span><span><span><span><span><span><span></span><span><span>a</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span></span><span>⋅</span><span></span></span><span><span></span><span><span>x</span><span><span><span><span><span><span></span><span><span>b</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></p>
<blockquote>
<p>Invert the signs for clockwise/counterclockwise conversion.</p>
</blockquote>
<p>For triangles, this is around 7% faster. Measured in one of the test scenes in <a href="https://github.com/Scthe/nanite-webgpu">Nanite WebGPU</a>.</p>
<p>Since quad has 4 edges, we precompute 4 sets of A, B, C. Unfortunately, this is quite a lot of registers. In “Frostbitten hair WebGPU”, <a href="https://github.com/Scthe/frostbitten-hair-webgpu/blob/d6306a69ab1cde4ef1321fc98c2040fd64ccac37/src/passes/swHair/shaderImpl/processHairSegment.wgsl.ts#L39">HairFinePass</a> uses this optimization, while <a href="https://github.com/Scthe/frostbitten-hair-webgpu/blob/501f01969b4bc65cb7df3b901c1ced4e2da0c84b/src/passes/swHair/hairTilesPass.wgsl.ts#L153">HairTilesPass</a> does not.</p>
<p>Quad rasterization if you use this optimization:</p>
<div><pre><p><span>let</span><span> </span><span>CC0</span><span> </span><span>=</span><span> </span><span>edgeC</span><span>(</span><span>v01</span><span>,</span><span> v00</span><span>)</span><span>;</span><span></span></p><p><span></span><span>let</span><span> </span><span>CC1</span><span> </span><span>=</span><span> </span><span>edgeC</span><span>(</span><span>v11</span><span>,</span><span> v01</span><span>)</span><span>;</span><span></span></p><p><span></span><span>let</span><span> </span><span>CC2</span><span> </span><span>=</span><span> </span><span>edgeC</span><span>(</span><span>v10</span><span>,</span><span> v11</span><span>)</span><span>;</span><span></span></p><p><span></span><span>let</span><span> </span><span>CC3</span><span> </span><span>=</span><span> </span><span>edgeC</span><span>(</span><span>v00</span><span>,</span><span> v10</span><span>)</span><span>;</span><span></span></p><p><span>var </span><span>CY0</span><span> </span><span>=</span><span> boundRectMin</span><span>.</span><span>x </span><span>*</span><span> </span><span>CC0</span><span>.</span><span>A</span><span> </span><span>+</span><span> boundRectMin</span><span>.</span><span>y </span><span>*</span><span> </span><span>CC0</span><span>.</span><span>B</span><span> </span><span>+</span><span> </span><span>CC0</span><span>.</span><span>C</span><span>;</span><span></span></p><p><span>var </span><span>CY1</span><span> </span><span>=</span><span> boundRectMin</span><span>.</span><span>x </span><span>*</span><span> </span><span>CC1</span><span>.</span><span>A</span><span> </span><span>+</span><span> boundRectMin</span><span>.</span><span>y </span><span>*</span><span> </span><span>CC1</span><span>.</span><span>B</span><span> </span><span>+</span><span> </span><span>CC1</span><span>.</span><span>C</span><span>;</span><span></span></p><p><span>var </span><span>CY2</span><span> </span><span>=</span><span> boundRectMin</span><span>.</span><span>x </span><span>*</span><span> </span><span>CC2</span><span>.</span><span>A</span><span> </span><span>+</span><span> boundRectMin</span><span>.</span><span>y </span><span>*</span><span> </span><span>CC2</span><span>.</span><span>B</span><span> </span><span>+</span><span> </span><span>CC2</span><span>.</span><span>C</span><span>;</span><span></span></p><p><span>var </span><span>CY3</span><span> </span><span>=</span><span> boundRectMin</span><span>.</span><span>x </span><span>*</span><span> </span><span>CC3</span><span>.</span><span>A</span><span> </span><span>+</span><span> boundRectMin</span><span>.</span><span>y </span><span>*</span><span> </span><span>CC3</span><span>.</span><span>B</span><span> </span><span>+</span><span> </span><span>CC3</span><span>.</span><span>C</span><span>;</span><span></span></p><p><span></span><span>for</span><span> </span><span>(</span><span>var y</span><span>:</span><span> </span><span>f32</span><span> </span><span>=</span><span> boundRectMin</span><span>.</span><span>y</span><span>;</span><span> y </span><span>&lt;</span><span> boundRectMax</span><span>.</span><span>y</span><span>;</span><span> y </span><span>+=</span><span> </span><span>1.0</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  var </span><span>CX0</span><span> </span><span>=</span><span> </span><span>CY0</span><span>;</span><span></span></p><p><span>  var </span><span>CX1</span><span> </span><span>=</span><span> </span><span>CY1</span><span>;</span><span></span></p><p><span>  var </span><span>CX2</span><span> </span><span>=</span><span> </span><span>CY2</span><span>;</span><span></span></p><p><span>  var </span><span>CX3</span><span> </span><span>=</span><span> </span><span>CY3</span><span>;</span><span></span></p><p><span>  </span><span>for</span><span> </span><span>(</span><span>var x</span><span>:</span><span> </span><span>f32</span><span> </span><span>=</span><span> boundRectMin</span><span>.</span><span>x</span><span>;</span><span> x </span><span>&lt;</span><span> boundRectMax</span><span>.</span><span>x</span><span>;</span><span> x </span><span>+=</span><span> </span><span>1.0</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>if</span><span> </span><span>(</span><span>CX0</span><span> </span><span>&gt;=</span><span> </span><span>0</span><span> </span><span>||</span><span> </span><span>CX1</span><span> </span><span>&gt;=</span><span> </span><span>0</span><span> </span><span>||</span><span> </span><span>CX2</span><span> </span><span>&gt;=</span><span> </span><span>0</span><span> </span><span>||</span><span> </span><span>CX3</span><span> </span><span>&gt;=</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>      </span><span>putPixel</span><span>(</span><span>p</span><span>,</span><span> </span><span>COLOR_IRIS</span><span>)</span><span>;</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>    </span><span>CX0</span><span> </span><span>+=</span><span> </span><span>CC0</span><span>.</span><span>A</span><span>;</span><span></span></p><p><span>    </span><span>CX1</span><span> </span><span>+=</span><span> </span><span>CC1</span><span>.</span><span>A</span><span>;</span><span></span></p><p><span>    </span><span>CX2</span><span> </span><span>+=</span><span> </span><span>CC2</span><span>.</span><span>A</span><span>;</span><span></span></p><p><span>    </span><span>CX3</span><span> </span><span>+=</span><span> </span><span>CC3</span><span>.</span><span>A</span><span>;</span><span></span></p><p><span>  </span><span>}</span><span></span></p><p><span>  </span><span>CY0</span><span> </span><span>+=</span><span> </span><span>CC0</span><span>.</span><span>B</span><span>;</span><span></span></p><p><span>  </span><span>CY1</span><span> </span><span>+=</span><span> </span><span>CC1</span><span>.</span><span>B</span><span>;</span><span></span></p><p><span>  </span><span>CY2</span><span> </span><span>+=</span><span> </span><span>CC2</span><span>.</span><span>B</span><span>;</span><span></span></p><p><span>  </span><span>CY3</span><span> </span><span>+=</span><span> </span><span>CC3</span><span>.</span><span>B</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>struct</span><span> </span><span>EdgeC</span><span>{</span><span> </span><span>A</span><span>:</span><span> </span><span>f32</span><span>,</span><span> </span><span>B</span><span>:</span><span> </span><span>f32</span><span>,</span><span> </span><span>C</span><span>:</span><span> </span><span>f32</span><span> </span><span>}</span><span></span></p><p><span></span><span>fn</span><span> </span><span>edgeC</span><span>(</span><span>v0</span><span>:</span><span> vec2f</span><span>,</span><span> v1</span><span>:</span><span> vec2f</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>EdgeC</span><span>{</span><span></span></p><p><span>  var result</span><span>:</span><span> </span><span>EdgeC</span><span>;</span><span></span></p><p><span>  result</span><span>.</span><span>A</span><span> </span><span>=</span><span> v1</span><span>.</span><span>y </span><span>-</span><span> v0</span><span>.</span><span>y</span><span>;</span><span> </span><span></span></p><p><span>  result</span><span>.</span><span>B</span><span> </span><span>=</span><span> </span><span>-</span><span>v1</span><span>.</span><span>x </span><span>+</span><span> v0</span><span>.</span><span>x</span><span>;</span><span> </span><span></span></p><p><span>  result</span><span>.</span><span>C</span><span> </span><span>=</span><span> </span><span>-</span><span>v0</span><span>.</span><span>x </span><span>*</span><span> v1</span><span>.</span><span>y </span><span>+</span><span> v0</span><span>.</span><span>y </span><span>*</span><span> v1</span><span>.</span><span>x</span><span>;</span><span> </span><span></span></p><p><span>  </span><span>return</span><span> result</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div>
<blockquote>
<p>Link to “Frostbitten hair WebGPU”: <a href="https://github.com/Scthe/frostbitten-hair-webgpu/blob/501f01969b4bc65cb7df3b901c1ced4e2da0c84b/src/passes/swHair/shaderImpl/processHairSegment.wgsl.ts#L39">processHairSegment.wgsl.ts</a> (part of <a href="https://github.com/Scthe/frostbitten-hair-webgpu/blob/501f01969b4bc65cb7df3b901c1ced4e2da0c84b/src/passes/swHair/hairFinePass.wgsl.ts">HairFinePass</a>). My project has 2 different passess that use software rasterization. <code>HairTilesPass</code> is faster without an optimization.</p>
</blockquote>
<h2 id="segment-space-coordinates">Segment-space coordinates<a aria-hidden="true" href="#segment-space-coordinates" tabindex="-1">§</a></h2>
<p>This leaves us with the last question: “How to calculate barycentric coordinates for pixels inside the quad?“. Well, we don’t. For hair, we need coordinates in “segment space”, according to 2 axes. I’m not sure if there is some industry-standard algorithm for this, so I’ve used my own. I will highlight where it has some issues, but you can always check the demo page for <a href="https://scthe.github.io/frostbitten-hair-webgpu">Frostbitten hair WebGPU</a> to see how big of a problem it is in practice. A lot of value is in realizing what problem we are trying to solve. You can find the complete code at the end.</p>
<blockquote>
<p>There are algorithms to calculate barycentric coordinates in a quad. I spend 2 hours trying to get them to work. This was one of the first days of writing “Frostbitten hair WebGPU”. Since I still had the whole app to write, I decided to use something good enough. I did not change it later and it is present in the final version.</p>
</blockquote>
<figure><div data-rmiz-wrap="visible"><p><img src="https://ntietz.com/static/39ae01480a872ac5781445ebf0b5c114/72840/co-strand-space.png" srcset="/static/39ae01480a872ac5781445ebf0b5c114/ab566/co-strand-space.png 143w,
/static/39ae01480a872ac5781445ebf0b5c114/a65fd/co-strand-space.png 285w,
/static/39ae01480a872ac5781445ebf0b5c114/72840/co-strand-space.png 570w" sizes="(min-width: 570px) 570px, 100vw" alt="Hair segment on pixel grid." decoding="async" loading="lazy" width="570" height="800"/></p></div><figcaption><p>Hair segment on a <strong>pixel grid</strong>. Calculating segment space coordinates for pixel <code>px0</code>. <code>v</code> is the coordinate along the long axis, and <code>u</code> is the coordinate along the short axis. The picture also contains marked <code>1 - v</code> and <code>1 - u</code>. Tangents marked in blue, bitangents in green. Points <code>v00</code>, <code>v01</code>, <code>v10</code>, <code>v11</code> are the vertices we calculated in the previous section.</p></figcaption></figure>
<h3 id="calculation-for-long-axis">Calculation for long axis<a aria-hidden="true" href="#calculation-for-long-axis" tabindex="-1">§</a></h3>
<ol>
<li>Calculate a line that goes through the start and end points of the segment.</li>
<li>Project the pixel onto the line.</li>
<li>Calculate the distance from the segment start point to the projected pixel.</li>
<li>Divide this distance by segment length. Saturate the result so that it is between 0 and 1.</li>
</ol>
<figure><div data-rmiz-wrap="visible"><p><img src="https://ntietz.com/static/a1b2aa964a8d0c939a3711d3edf81d96/72840/co-long-axis.png" srcset="/static/a1b2aa964a8d0c939a3711d3edf81d96/ab566/co-long-axis.png 143w,
/static/a1b2aa964a8d0c939a3711d3edf81d96/a65fd/co-long-axis.png 285w,
/static/a1b2aa964a8d0c939a3711d3edf81d96/72840/co-long-axis.png 570w" sizes="(min-width: 570px) 570px, 100vw" alt="Calculation of pixels projecteted onto segment axis." decoding="async" loading="lazy" width="570" height="800"/></p></div><figcaption><p>Calculating long axis coordinates for pixels <code>px0</code>, <code>px1</code>, and <code>px2</code> by projecting onto p0-p1 line (marked in yellow).</p></figcaption></figure>
<p>Looking at the image, there are obvious flaws. Pixel <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>x</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">px1</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>p</span><span>x</span><span>1</span></span></span></span></span> is projected beyond the end segment. It requires the call to <code>saturate()</code>. The value for <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>x</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">px2</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>p</span><span>x</span><span>2</span></span></span></span></span> is also incorrect. The perceived error depends on the hair width and angle between subsequent tangents. It’s not noticeable as the hair is thin and most rendering techniques provide anti-aliasing with transparency.</p>
<blockquote>
<p>If you look at the image and think there is an obvious better algorithm, then I guess I’ve made damn good illustrations.</p>
</blockquote>
<h3 id="calculation-for-short-axis">Calculation for short axis<a aria-hidden="true" href="#calculation-for-short-axis" tabindex="-1">§</a></h3>
<p>Given the value for the long axis, it’s easier to get the second coordinate. Notice that the segment’s end width depends on the tangent of the next segment. Only the last segment (near the strand’s tip) has the same width near both points.</p>
<figure><div data-rmiz-wrap="visible"><p><img src="https://ntietz.com/static/917b456f5cc4e45b235b7975522d8581/72840/co-short-axis.png" srcset="/static/917b456f5cc4e45b235b7975522d8581/ab566/co-short-axis.png 143w,
/static/917b456f5cc4e45b235b7975522d8581/a65fd/co-short-axis.png 285w,
/static/917b456f5cc4e45b235b7975522d8581/72840/co-short-axis.png 570w" sizes="(min-width: 570px) 570px, 100vw" alt="Calculation of pixel projecteted onto edge." decoding="async" loading="lazy" width="570" height="800"/></p></div><figcaption><p>Calculating short axis coordinates for pixel <code>px0</code> by projecting it onto the side edge.</p></figcaption></figure>
<ol>
<li>Calculate the <code>width near the segment&#39;s start</code>.</li>
<li>Calculate the projected <code>width near the segment&#39;s end</code> using <a href="https://en.wikipedia.org/wiki/Scalar_projection">scalar projection</a> (dot product).</li>
<li>Strand <code>width near the pixel</code> is a linear interpolation of start and end width using the coordinate for the long axis.</li>
<li>Project the pixel onto one of the side edges of the segment.</li>
<li>Calculate the distance from the pixel to the projected pixel.</li>
<li>Divide this distance by segment <code>width near the pixel</code>. Saturate the result so that it is between 0 and 1.</li>
</ol>
<p>Alternatively, you could find points on both side edges: <code>e0 = mix(v00, v10, v)</code>, <code>e1 = mix(v01, v11, v)</code>. Then <code>u = distance(pixel - e0) / distance(e0 - e1)</code>.</p>
<blockquote>
<p>Link to “Frostbitten hair WebGPU”: <a href="https://github.com/Scthe/frostbitten-hair-webgpu/blob/501f01969b4bc65cb7df3b901c1ced4e2da0c84b/src/passes/swHair/shaderImpl/swRasterizeHair.wgsl.ts#L170">swRasterizeHair.wgsl.ts</a>.</p>
</blockquote>
<h3 id="code">Code<a aria-hidden="true" href="#code" tabindex="-1">§</a></h3>
<div><pre><p><span>struct</span><span> </span><span>ProjectedSegment</span><span> </span><span>{</span><span></span></p><p><span>  v00</span><span>:</span><span> vec2f</span><span>,</span><span></span></p><p><span>  v01</span><span>:</span><span> vec2f</span><span>,</span><span></span></p><p><span>  v10</span><span>:</span><span> vec2f</span><span>,</span><span></span></p><p><span>  v11</span><span>:</span><span> vec2f</span><span>,</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>fn</span><span> </span><span>interpolateHairQuad</span><span>(</span><span>projSeg</span><span>:</span><span> </span><span>ProjectedSegment</span><span>,</span><span> pxPos</span><span>:</span><span> vec2f</span><span>)</span><span> </span><span>-&gt;</span><span> vec2f </span><span>{</span><span></span></p><p><span>  </span><span>let</span><span> startEdgeMidpoint </span><span>=</span><span> </span><span>(</span><span>projSeg</span><span>.</span><span>v00 </span><span>+</span><span> projSeg</span><span>.</span><span>v01</span><span>)</span><span> </span><span>/</span><span> </span><span>2.0</span><span>;</span><span></span></p><p><span>  </span><span>let</span><span> endEdgeMidpoint </span><span>=</span><span> </span><span>(</span><span>projSeg</span><span>.</span><span>v10 </span><span>+</span><span> projSeg</span><span>.</span><span>v11</span><span>)</span><span> </span><span>/</span><span> </span><span>2.0</span><span>;</span><span></span></p><p><span>  </span><span>let</span><span> cProjected </span><span>=</span><span> </span><span>projectPointToLine</span><span>(</span><span>startEdgeMidpoint</span><span>,</span><span> endEdgeMidpoint</span><span>,</span><span> pxPos</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>let</span><span> d1 </span><span>=</span><span> </span><span>length</span><span>(</span><span>cProjected </span><span>-</span><span> startEdgeMidpoint</span><span>)</span><span> </span><span>/</span><span></span></p><p><span>           </span><span>length</span><span>(</span><span>endEdgeMidpoint </span><span>-</span><span> startEdgeMidpoint</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>let</span><span> widthStart </span><span>=</span><span> </span><span>length</span><span>(</span><span>projSeg</span><span>.</span><span>v00 </span><span>-</span><span> projSeg</span><span>.</span><span>v01</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>let</span><span> widthEnd </span><span>=</span><span> widthStart </span><span>*</span><span> </span><span>dot</span><span>(</span><span></span></p><p><span>    </span><span>normalize</span><span>(</span><span>projSeg</span><span>.</span><span>v00 </span><span>-</span><span> projSeg</span><span>.</span><span>v01</span><span>)</span><span>,</span><span></span></p><p><span>    </span><span>normalize</span><span>(</span><span>projSeg</span><span>.</span><span>v10 </span><span>-</span><span> projSeg</span><span>.</span><span>v11</span><span>)</span><span></span></p><p><span>  </span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>let</span><span> expectedWidth </span><span>=</span><span> </span><span>mix</span><span>(</span><span>widthStart</span><span>,</span><span> widthEnd</span><span>,</span><span> d1</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>let</span><span> e1 </span><span>=</span><span> </span><span>projectPointToLine</span><span>(</span><span>projSeg</span><span>.</span><span>v00</span><span>,</span><span> projSeg</span><span>.</span><span>v10</span><span>,</span><span> pxPos</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>let</span><span> d0 </span><span>=</span><span>  </span><span>saturate</span><span>(</span><span>length</span><span>(</span><span>pxPos </span><span>-</span><span> e1</span><span>)</span><span> </span><span>/</span><span> expectedWidth</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>return</span><span> </span><span>vec2f</span><span>(</span><span>d0</span><span>,</span><span> </span><span>staturate</span><span>(</span><span>d1</span><span>)</span><span>)</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>fn</span><span> </span><span>projectPointToLine</span><span>(</span><span>l1</span><span>:</span><span> vec2f</span><span>,</span><span> l2</span><span>:</span><span> vec2f</span><span>,</span><span> p</span><span>:</span><span> vec2f</span><span>)</span><span> </span><span>-&gt;</span><span> vec2f </span><span>{</span><span></span></p><p><span>  </span><span>let</span><span> ab </span><span>=</span><span> l2 </span><span>-</span><span> l1</span><span>;</span><span></span></p><p><span>  </span><span>let</span><span> ac </span><span>=</span><span> p </span><span>-</span><span> l1</span><span>;</span><span></span></p><p><span>  </span><span>let</span><span> ad </span><span>=</span><span> ab </span><span>*</span><span> </span><span>dot</span><span>(</span><span>ab</span><span>,</span><span> ac</span><span>)</span><span> </span><span>/</span><span> </span><span>dot</span><span>(</span><span>ab</span><span>,</span><span> ab</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>let</span><span> d </span><span>=</span><span> l1 </span><span>+</span><span> ad</span><span>;</span><span></span></p><p><span>  </span><span>return</span><span> d</span><span>;</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div>
<h2 id="summary">Summary<a aria-hidden="true" href="#summary" tabindex="-1">§</a></h2>
<p>In this article, we have seen how to turn hair splines into real-time rendered pixels. The techniques are not complicated, but their application is rarely discussed. Given the recent spotlight on software rasterization, many companies will move in this direction. Due to inherent complexity, hair rendering is always implemented as a separate subsystem. The knowledge from this article should be enough to start implementing techniques from Robin Taillandier and Jon Valdes’s <a href="https://www.youtube.com/watch?v=ool2E8SQPGU">“Every Strand Counts: Physics and Rendering Behind Frostbite’s Hair”</a>. After watching the presentation you can move straight into the codebase of my <a href="https://github.com/Scthe/frostbitten-hair-webgpu">Frostbitten hair WebGPU</a>.</p></div></div>
  </body>
</html>
