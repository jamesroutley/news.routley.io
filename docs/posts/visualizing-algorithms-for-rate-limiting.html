<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://smudge.ai/blog/ratelimit-algorithms">Original</a>
    <h1>Visualizing algorithms for rate limiting</h1>
    
    <div id="readability-page-1" class="page"><div><main><div><p><time>May 15, 2024</time></p><h2 id="why-rate-limit">Why rate limit?</h2><p>Imagine a Twitch chat with many active participants and just one spammer. Without rate limiting, the sole spammer can easily dominate the entire conversation. With rate limiting, each user has a fair chance to participate.</p><astro-island client="only" component-export="RatelimitChatDemo" component-url="/_astro/_RatelimitChatDemo.tadYQS-W.js" opts="{&#34;name&#34;:&#34;RatelimitChatDemo&#34;,&#34;value&#34;:&#34;solid-js&#34;}" props="{}" renderer-url="/_astro/client._0k3YFAT.js" ssr="" uid="7Oez3"></astro-island><p>A rate limiter lets you control the rate of traffic that your service processes by blocking requests that exceed a set limit during a period of time. This is useful beyond just throttling spam in a chat. For instance, rate limiting a login form can deter brute force attacks while still allowing a small burst of incorrect guesses.</p><p>API endpoints are also frequently rate-limited to prevent any single user from monopolizing resources. Imagine that you want users to only be able to hit an expensive endpoint 100 times per minute. You could track hits with a counter that resets every minute. Any request after the 100th within that minute gets blocked. This is one of the simplest rate-limiting algorithms, called a <strong>fixed window limiter</strong>, and is a common way to control traffic to a service.</p><p>But it’s not always that simple.</p><p>When does each one-minute window begin and end? If I begin a burst of requests near the end of a window, can I exceed the limit? Is a window’s capacity restored one request at a time, or all at once?</p><p>In this post, we’ll explore the three most common algorithms to answer each of these questions.</p><ol><li><a href="#fixed-windows">Fixed windows</a></li><li><a href="#sliding-windows">Sliding windows</a></li><li><a href="#token-buckets">Token buckets</a></li></ol><h2 id="fixed-windows">Fixed windows</h2><p>A set number of requests can be made within a predefined time window. Requests increment a counter that’s reset to zero at the start of each window.</p><div><p><em>Allow 6 requests per day (24-hour windows)</em></p><astro-island client="only" component-export="FixedLimitVisualization" component-url="/_astro/_RatelimitVisualization.DcnAx07u.js" opts="{&#34;name&#34;:&#34;FixedLimitVisualization&#34;,&#34;value&#34;:&#34;solid-js&#34;}" props="{&#34;hideUi&#34;:[0,false],&#34;showMidnight&#34;:[0,true],&#34;limit&#34;:[0,6]}" renderer-url="/_astro/client._0k3YFAT.js" ssr="" uid="Z1V8y0p"></astro-island></div><blockquote>Each green dot  represents an allowed request while  is a request blocked by the rate limiter. You can add more requests with the <kbd>Hit</kbd> button, which pauses the automatic stream.</blockquote><ul><li>Pros<ul><li>Simple to implement and understand</li><li>Predictable for users</li></ul></li><li>Cons<ul><li>Allows bursts up to 2x the <code>limit</code> when requests begin near the end of a window</li></ul></li><li>Real-world example<ul><li>GitHub’s API uses a fixed window rate limiter with <code>limit = 5000</code>, <code>windowDuration = 1h</code>, and <code>windowStart</code> set to the start of each wall clock hour, allowing users 5,000 requests per hour.</li></ul></li></ul><details><summary><strong>A brief tangent on 24-hour fixed windows</strong></summary><div><p>There is a subtle issue with the 24-hour limiter above. Its windows reset every day at midnight—but midnight according to <em>what time zone</em>? A standard fixed window might reset its counter according to your server’s midnight or a standard timezone offset such as UTC. A user in a different timezone who just ran out of requests might retry just after midnight and be surprised if the limit hasn’t been lifted—since to them, it is a new calendar day.</p><p>For these applications, you need to offset your window starts according to the user’s time zone, which has some potential for abuse as users can manually adjust their timezone once they’ve run out of requests to gain up to 1 full window of additional requests. Worse yet, users traveling West to East might incorrectly have more requests limited while those traveling East to West might incorrectly have more requests allowed as they effectively extend their day. If a rate limit resets based on local midnight and a user moves to an earlier time zone, they encounter earlier local midnights. This can effectively allow them to reset their request count sooner by being in a new “day” earlier than expected, thus potentially increasing their total allowable requests within a 24-hour period as measured by real time. Yikes. And we still haven’t dealt with DST.</p><p>This use case is already a bit of a tangent, so for now I’ll leave it at this: handling time zones correctly, accounting for users relocating as well as daylight savings, is difficult to get right—so if you’re considering going down that painful path, I’ll just <a href="https://stackoverflow.com/questions/2532729/daylight-saving-time-and-time-zone-best-practices/3269325#3269325">point</a> <a href="https://www.creativedeletion.com/2015/01/28/falsehoods-programmers-date-time-zones.html">you</a> <a href="https://www.youtube.com/watch?v=-5wpm-gesOY">to</a> <a href="https://2ality.com/2021/06/temporal-api.html#time-zones-vs.-time-offsets">these</a> <a href="https://tech.bluesmoon.info/2013/08/dont-guess-at-timezones-in-javascript.html">resources</a> instead. If you can sidestep this problem by using any other approach at all, you should!</p></div></details><h4 id="fixed-window-with-user-defined-start">Fixed window with user-defined start</h4><p>Instead of fixing the start times to a set interval, each window can be created at the time of the user’s first request within that window.</p><p>With this approach, it’s especially important to show users the time remaining until the next window once they’re limited since there’s no set time that aligns each window.</p><h2 id="sliding-windows">Sliding windows</h2><p>Instead of refreshing the capacity all at once, sliding windows refill one request at a time.</p><astro-island client="only" component-export="SlidingWindowVisualization" component-url="/_astro/_RatelimitVisualization.DcnAx07u.js" opts="{&#34;name&#34;:&#34;SlidingWindowVisualization&#34;,&#34;value&#34;:&#34;solid-js&#34;}" props="{&#34;limit&#34;:[0,6]}" renderer-url="/_astro/client._0k3YFAT.js" ssr="" uid="oY7AT"></astro-island><ul><li>Pros<ul><li>Smooths the distribution of request traffic</li><li>Well-suited for high loads</li></ul></li><li>Cons<ul><li>Less predictable for users than fixed windows</li><li>Storing timestamps for each request is resource-intensive</li></ul></li></ul><p>Because sliding windows tend to be most useful in high-traffic scenarios, the fact that the naive algorithm is resource-intensive is counterproductive. Shouldn’t a high-traffic rate limiter use an efficient algorithm? For this reason, most real-world sliding window rate limiters, such as those provided by <a href="https://upstash.com/docs/oss/sdks/ts/ratelimit/algorithms#sliding-window">Upstash</a> or <a href="https://www.cloudflare.com/application-services/products/rate-limiting/">Cloudflare</a>, use an approximation, often called a floating window. Using this approximation, we have all the same pros but can remove the “resource-intensive” point from the cons. Here’s how it works:</p><ol><li>Count the number of allowed requests in the previous fixed window.</li><li>Count the number of allowed requests in the current fixed window.</li><li>Weight the previous window’s allowed requests proportional to that window’s overlap with a floating window ending at the current time.</li><li>Add the weighted requests from (3) to the unweighted requests from (2).</li></ol><p>In other words, this is the computation:</p><div><figure><pre data-language="plaintext"><code><div><p><span>approximation = (prevWindowCount * prevWindowWeight) + currentWindowCount</span></p></div></code></pre></figure></div></div></main></div></div>
  </body>
</html>
