<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://chipsandcheese.com/2022/09/01/hot-chips-34-teslas-dojo-microarchitecture/">Original</a>
    <h1>Tesla’s Dojo Microarchitecture</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>To say Tesla is merely interested in machine learning is an understatement. The electric car maker built an in-house supercomputer named Dojo, optimized for training its machine learning models. Unlike many other supercomputers, Dojo isn’t using off-the-shelf CPUs and GPUs, such as from AMD, Intel, or Nvidia. Instead, Tesla designed their own microarchitecture tailored to their needs, letting them make tradeoffs that more general architectures can’t make. In this article, we’re going to take a look at that architecture, based on Tesla’s presentations at Hot Chips. The architecture doesn’t have a separate name, so for simplicity, whenever we mention Dojo further down we’re talking about the architecture.</p>
<h2>Block Diagram</h2>
<p>At a high level, Dojo is an eight wide core with four way SMT, running at a conservative 2 GHz. It features a CPU-style pipeline, making it more tolerant of different algorithms and branchy code than something like a GPU. Dojo’s instruction set resembles RISC-V on the scalar side, but Tesla’s engineers have added a custom set of vector instructions focused on accelerating machine learning. </p>
<div>
<figure><a href="https://chipsandcheese.com/?attachment_id=9124"><img data-attachment-id="9124" data-permalink="https://chipsandcheese.com/2022/09/01/hot-chips-34-teslas-dojo-microarchitecture/tesla_dojo-drawio/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/tesla_dojo.drawio.png?fit=821%2C605&amp;ssl=1" data-orig-size="821,605" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="tesla_dojo.drawio" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/tesla_dojo.drawio.png?fit=821%2C605&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/tesla_dojo.drawio.png?fit=688%2C507&amp;ssl=1" width="688" height="507" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/tesla_dojo.drawio.png?resize=688%2C507&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/tesla_dojo.drawio.png?w=821&amp;ssl=1 821w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/tesla_dojo.drawio.png?resize=768%2C566&amp;ssl=1 768w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/tesla_dojo.drawio.png?resize=688%2C507&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a><figcaption>A simplified block diagram of Tesla’s Dojo core</figcaption></figure></div>
<p>Tesla describes Dojo as a “high throughput, general purpose CPU”. There’s certainly some truth to that from a performance perspective. But to increase compute density, Tesla made sacrifices that would make Dojo cores extremely difficult to use compared to the CPUs we’re familiar with in our desktops, laptops, and smartphones. In some ways, a Dojo core handles more like an SPE in IBM’s Cell than a conventional general purpose CPU core.</p>
<h2>Like a Cell SPE?</h2>
<p>In the mid 2000s, IBM’s Cell processor featured eight “Synergistic Processing Elements”, or SPEs, controlled by a fully featured CPU core (“Power Processing Element”, or PPE). At first glance, Dojo shares a lot of similarities with the SPEs. Both Dojo and SPEs are optimized for vector processing, and rely on separate host processors for work assignment. Code running on Dojo or an SPE cannot directly access system memory. Instead, applications are expected to work mainly out of a small pool of local SRAM. This local SRAM is managed by software, and doesn’t work as a cache. If data from main memory is needed, it has to be brought in using DMA operations. Finally, Dojo and Cell’s SPEs both lack virtual memory support. We’ll go more into what that means later, but in short, it makes multitasking very difficult.</p>
<div>
<figure><a href="https://chipsandcheese.com/?attachment_id=9132"><img data-attachment-id="9132" data-permalink="https://chipsandcheese.com/2022/09/01/hot-chips-34-teslas-dojo-microarchitecture/dojo_and_spe/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/dojo_and_spe.png?fit=915%2C915&amp;ssl=1" data-orig-size="915,915" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="dojo_and_spe" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/dojo_and_spe.png?fit=915%2C915&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/dojo_and_spe.png?fit=688%2C688&amp;ssl=1" width="688" height="688" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/dojo_and_spe.png?resize=688%2C688&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/dojo_and_spe.png?w=915&amp;ssl=1 915w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/dojo_and_spe.png?resize=768%2C768&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/dojo_and_spe.png?resize=800%2C800&amp;ssl=1 800w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/dojo_and_spe.png?resize=400%2C400&amp;ssl=1 400w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/dojo_and_spe.png?resize=200%2C200&amp;ssl=1 200w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/dojo_and_spe.png?resize=688%2C688&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a><figcaption>Very simplified comparison between Tesla Dojo and an IBM Cell SPE</figcaption></figure></div>
<p>Dojo is different in several important ways. Since Dojo is not designed with small-scale deployments in mind, the host processors reside on separate host systems. These host systems have PCIe cards with interface processors, which then connect to Dojo chips over a high-speed network link. In contrast, Cell’s host processor resides on the same die. That makes it possible to deploy a single Cell chip by itself – something not possible with Dojo. Dojo’s 1.25 MB local block is SRAM is much larger and has higher bandwidth than a Cell SPE, which only has 256 KB of SRAM. Cell’s 256 KB SRAM only has a single port capable of delivering 128B per cycle. Dojo’s SRAM has five 64B ports. And of course, architecture goals are very different. Dojo is wide and low clocked, while Cell SPEs feature narrow, deep pipelines designed for high clocks. But it’s funny that Cell’s high-level design concept is still relevant today.</p>
<h2>Frontend: CPU Comforts and More</h2>
<p>Let’s take a brief trip through Dojo’s pipeline, starting at the front end. There’s a branch predictor of some sort, as Tesla’s diagram shows a BTB (branch target buffer). Its prediction capabilities probably won’t approach what we see on AMD, ARM, and Intel’s high performance cores, as Dojo needs to prioritize spending die area on vector execution. But even a basic branch predictor is a huge step up from no predictor at all, and Dojo’s branch prediction capability should give it far better performance than a GPU when handling branchy code, or larger instruction footprints.</p>
<p>Once the branch predictor has generated the next instruction fetch pointers, Dojo can pull 32 bytes per cycle from a “small” instruction cache into per-thread fetch buffers. This instruction cache probably serves to reduce instruction bandwidth pressure on the local SRAM, making sure the data side can access the SRAM with as little contention as possible. Also, the instruction cache isn’t coherent. If new code is loaded into local SRAM, the instruction cache has to be flushed before branching to that new code.</p>
<div>
<figure><a href="https://chipsandcheese.com/?attachment_id=9130"><img data-attachment-id="9130" data-permalink="https://chipsandcheese.com/2022/09/01/hot-chips-34-teslas-dojo-microarchitecture/image-4-17/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-4.jpg?fit=1257%2C683&amp;ssl=1" data-orig-size="1257,683" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-4" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-4.jpg?fit=1257%2C683&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-4.jpg?fit=688%2C374&amp;ssl=1" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-4.jpg?resize=640%2C347&amp;ssl=1" alt="" width="640" height="347" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-4.jpg?w=1257&amp;ssl=1 1257w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-4.jpg?resize=768%2C417&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-4.jpg?resize=1200%2C652&amp;ssl=1 1200w" data-lazy-sizes="(max-width: 640px) 100vw, 640px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-4.jpg?resize=640%2C347&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a><figcaption>From Tesla’s Hot Chips presentation</figcaption></figure></div>
<p>From the fetch buffers, Dojo’s decoder can handle eight instructions per cycle, from two threads. I’m a bit confused by what “two threads per cycle” means, since CPUs with SMT typically have fetch and decode handle one thread per cycle and switch between threads on cycle boundaries. Perhaps Dojo splits the decoder into two clusters and selects two threads to feed them every cycle. That may reduce decode throughput loss from taken branches.</p>
<p>At decode, certain instructions like branches, predicated operations, and immediate loads (“list parsing”) can be executed within the front end and dropped from the pipeline. It’s a bit like newer x86 CPUs eliminating register-to-register copies in the renamer. But you heard that right – Dojo is not tracking “eliminated” instructions through the pipeline to maintain in-order retirement. Other processors track everything to retirement so that they can stop at any instruction boundary, and maintain all the state necessary to resume execution. This capability is called “precise exceptions”, and is used by modern operating systems to deliver all kinds of goodies like paging to disk, or telling you exactly where you screwed up in your code.</p>
<p>Tesla does not care about delivering precise exceptions. Dojo does feature a debug mode where more instructions go through the pipeline to give “more precise” exceptions, but there is no in-order retirement logic like on normal out-of-order CPUs.</p>
<h2>Dojo’s Execution Engine</h2>
<p>After seeing a wide front end, it might be a bit weird to see a 4-wide integer execution engine with just two ALUs and two AGUs. But this funnel-shaped pipeline makes sense because some instructions are executed and dropped within the front end. Dojo also isn’t going into client systems, where scalar integer performance is important. So, the integer side provides just enough throughput to crunch through control flow and address generation in order to keep the vector and matrix units fed. </p>
<p>Dojo’s vector and matrix execution side is placed after the scalar execution engine in the core’s pipeline and has two execution pipes. Two pipes might not sound like much, but Dojo has very wide execution units behind those pipes. One pipe can do 512-bit vector execution, while the other does 8x8x4 matrix multiplication. So, Dojo is capable of very high throughput as long as instructions expose enough explicit parallelism – especially if the matrix unit is used. Tesla claims a die with 354 Dojo cores can hit 362 BF16 TFLOPS at 2 GHz, indicating that each core can do 512 BF16 FLOPS per cycle.</p>
<p>We’re not sure whether Dojo can do full out-of-order execution. But Tesla did say the integer side could run very far ahead of the vector side, suggesting that it can execute past stalled instructions until one of the schedulers fills. Lack of in-order retirement also points to out-of-order execution capability.</p>
<p>Normally, implementing out-of-order execution introduces a lot of complexity. That’s because the CPU has to appear to execute instructions in-order. AMD, ARM, and Intel’s high-performance CPUs track instructions with large reorder buffers (and other structures) so that their results can be committed in program order. That means if a program does something stupid like divide by zero, those cores can show exactly which instruction was at fault. And, they can show CPU state that reflects actions from all instructions before the faulting one, but none after. That means you can fix whatever made the instruction fault, and resume execution. Dojo gives up this capability. In exchange, Dojo can avoid the power and area overhead associated with tracking every instruction through its pipeline to make sure results are committed in program order.</p>
<h2>SRAM Access</h2>
<p>Normally, we would talk about caching here. But Dojo cannot directly access system memory, so we’ll talk about that 1.25 MB block of SRAM. It can handle two 512-bit loads per cycle, making its per-cycle bandwidth a match for Intel’s CPUs with AVX-512 support. Tesla says the SRAM has five 512-bit ports (2x load, 1x store, and two to the mesh stop). But the scalar side only has two AGUs, which likely means the core can’t sustain two 512-bit loads and a 512-bit store every cycle.</p>
<p>Because Dojo’s local block of SRAM is not a cache, it doesn’t need tags and state bits stored alongside the data. There’s also no L1D cache in front of the SRAM, so it has to be fast enough to handle all load and store instructions without causing bottlenecks, even though its size is closer to that of a L2 cache. Not implementing the SRAM as cache is probably how Tesla keeps latency low. If we look back at AMD’s Hammer architecture from long ago, we can see that accessing the 1 MB L2 takes eight cycles after an L1D miss is detected (for 12 cycles of total latency). Three stages can probably be dropped if that 1 MB of SRAM was directly addressed instead of being used as a cache, bringing latency down to 5 cycles:</p>
<div>
<figure><a href="https://chipsandcheese.com/?attachment_id=9160"><img data-attachment-id="9160" data-permalink="https://chipsandcheese.com/2022/09/01/hot-chips-34-teslas-dojo-microarchitecture/l2_pipeline_hammer-1/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/l2_pipeline_hammer-1.png?fit=688%2C496&amp;ssl=1" data-orig-size="688,496" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="l2_pipeline_hammer-1" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/l2_pipeline_hammer-1.png?fit=688%2C496&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/l2_pipeline_hammer-1.png?fit=688%2C496&amp;ssl=1" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/l2_pipeline_hammer-1.png?resize=640%2C461&amp;ssl=1" alt="" width="640" height="461" data-recalc-dims="1" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/l2_pipeline_hammer-1.png?resize=640%2C461&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a><figcaption>A slide from an older Hot Chips presentation, showing the pipeline stages involved in a L2 cache access. Stages that could be skipped if the L2 wasn’t a cache are marked in red.</figcaption></figure></div>
<p>Factor in a couple decades worth of process node improvements and even lower clock speed targets than Athlon’s, and it’s easy to see how Tesla could access a L2-sized block of SRAM with L1-like latency. Skipping a level of cache of course saves area and power.</p>
<p>To further cut down on latency, area and core complexity, Dojo has no virtual memory support. So, it has no TLBs or page walk mechanisms. Modern operating systems take advantage of virtual memory to give each process its own view of memory. Instead of directly accessing physical memory addresses, memory addresses used by the program are translated by the CPU to physical addresses, using paging structures set up by the operating system. That’s how modern operating systems keep programs isolated from each other, and prevent one misbehaving application from bringing down the entire system.</p>
<p>Virtual memory is also how you can run more programs than you have physical memory for. When you run out of real memory, the operating system unmaps a page, writes it to disk, and gives your program the memory it asked for. When that other poor program tries to access that memory, the CPU tries to translate the virtual address to a physical one, but finds that the translation isn’t present. The CPU throws a page fault exception, which the OS handles by reading the evicted page back into physical memory and filling out the page table entry. </p>
<p>None of that is doable on Dojo. The core’s 4-way SMT capability is more for a single application to expose explicit parallelism, instead of boosting multi-tasking performance. For example, one thread could perform vector compute, while another asynchronously loads data from system memory into SRAM (via DMA).</p>
<p>To further simplify the design, Dojo could address the SRAM with only 21 address bits, which could simplify Dojo’s AGUs and addressing buses. These tradeoffs probably let Tesla access that SRAM with low enough latency to avoid implementing a separate L1 data cache in front of it.</p>
<h2>DRAM Access</h2>
<p>Speaking of system memory, Dojo chips don’t directly connect to memory. Instead, they connect to interface processors, which are equipped with HBM. These interface processors are also responsible for communicating with host systems.</p>
<div>
<figure><a href="https://chipsandcheese.com/?attachment_id=9143"><img data-attachment-id="9143" data-permalink="https://chipsandcheese.com/2022/09/01/hot-chips-34-teslas-dojo-microarchitecture/image-4-1/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-4-1.jpg?fit=1407%2C781&amp;ssl=1" data-orig-size="1407,781" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-4-1" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-4-1.jpg?fit=1407%2C781&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-4-1.jpg?fit=688%2C382&amp;ssl=1" width="688" height="382" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-4-1.jpg?resize=688%2C382&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-4-1.jpg?w=1407&amp;ssl=1 1407w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-4-1.jpg?resize=768%2C426&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-4-1.jpg?resize=1200%2C666&amp;ssl=1 1200w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-4-1.jpg?resize=1320%2C733&amp;ssl=1 1320w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-4-1.jpg?resize=688%2C382&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a></figure></div>
<p>A Dojo tile with 25 individual chips has access to 160 GB of HBM memory. Tesla says they can transfer 900 GB/s out of each die edge across tile boundaries, which means the interface processors and their HBM can be accessed with 4.5 TB/s of link bandwidth. Because accessing HBM involves going through a separate chip, access latency is likely very high.</p>
<h2>It’s Tiny. How?</h2>
<p>Dojo is an 8-wide core with at least some OoO execution capability, decent vector throughput, and a matrix multiplication unit. But even with 1.25 MB of local SRAM, it ends up being a very small core. For comparison, Fujitsu’s A64FX occupies more than twice the area on the same process node.</p>
<p>Processor design is all about making the right tradeoffs. Tesla wants to maximize throughput for machine learning by packing tons of cores onto the die, so individual cores have to be small. To achieve its area efficiency, Dojo uses some familiar techniques. It runs at a conservative 2 GHz. Lower clocking circuits tend to take less area. It probably has a basic branch predictor, and a small instruction cache. That sacrifices some performance if programs have a large code footprint or lots of branches. </p>
<p>But Tesla also goes a lot further to minimize power and area usage by chopping features that aren’t necessary for running internal workloads. They don’t do data-side caching, don’t support virtual memory, and don’t support precise exceptions.</p>
<div>
<figure><a href="https://chipsandcheese.com/comp/"><img data-attachment-id="9147" data-permalink="https://chipsandcheese.com/comp/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/comp.png?fit=546%2C585&amp;ssl=1" data-orig-size="546,585" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="comp" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/comp.png?fit=546%2C585&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/comp.png?fit=546%2C585&amp;ssl=1" width="546" height="585" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/comp.png?resize=546%2C585&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/comp.png?resize=546%2C585&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a></figure></div>
<p>The result is a processor core that delivers the performance flexibility of a modern CPU core, while in many ways being less user and programmer friendly than an Intel 8086. Beyond the core, Tesla also saves die area by designing Dojo chips specifically for deployment at a large scale.</p>
<h2>Physical Implementation</h2>
<p>Zooming out, Dojo cores are implemented on a very large 645 mm<sup>2</sup> die, called D1. Unlike other chips we’re familiar with, a single Dojo die isn’t self-sufficient. It doesn’t have DDR or PCIe controllers. There are IO interfaces around the die edge, which let the die communicate with neighboring dies, with a latency of about 100 ns.</p>
<figure><table><tbody><tr><td></td><td>Tesla Dojo D1 Chip</td><td>Fujitsu A64FX</td><td>AMD RX 6900 XT</td><td>IBM Cell</td></tr><tr><td>Area (die)</td><td>645 mm<sup>2</sup></td><td>~400 mm<sup>2</sup></td><td>520 mm<sup>2</sup></td><td>~235 mm<sup>2</sup></td></tr><tr><td>Process Node</td><td>TSMC 7 nm</td><td>TSMC 7 nm</td><td>TSMC 7 nm</td><td>IBM 90 nm SOI, later shrink to 65nm</td></tr><tr><td>Core area, approx</td><td>1.1 mm<sup>2</sup></td><td>3.08 mm<sup>2</sup></td><td></td><td>14.8 mm<sup>2</sup></td></tr><tr><td>Core Count</td><td>354</td><td>48+4</td><td>40 WGPs</td><td>8 SPE + 1 PPE</td></tr><tr><td>Core Clock Speed</td><td>2 GHz</td><td>2 to 2.2 GHz</td><td>&gt; 2.5 GHz Boost</td><td>3.2 to 4 GHz</td></tr><tr><td>Management Cores</td><td>Separate host systems connected via interface processor (DIP), possibly over the hills and far away</td><td>Identical uarch, one per 12 core cluster (CMG)</td><td>CPU, connected via PCIe</td><td>1 PPC, on-die</td></tr><tr><td>Power Draw, 1 die</td><td>&lt; 600W</td><td><a href="https://youtu.be/Sf51s9kr0Ls?t=861">&lt; 200W?</a></td><td>&lt; 300W</td><td><a href="http://www.blachford.info/computer/Cell/Cell1_v2.html">60-80 W</a> (65 nm)</td></tr><tr><td>Network On Chip</td><td>Mesh, 2x64B links in each direction</td><td>Ring Between CMGs</td><td>Giant buses and crossbars of doom</td><td>Ring, 4x16B</td></tr><tr><td>Memory</td><td>HBM connected via DIP (800 GB/s per DIP, 5 DIPs connected to a tile) </td><td>Directly connected HBM2, 1024 GB/s</td><td>Directly connected GDDR6</td><td>Directly connected Rambus XDR, 25.6 GB/s</td></tr><tr><td>Vector FP32 Throughput</td><td>22 TFLOPS</td><td>6.758 TFLOPS (not including management cores)</td><td>25.6 TFLOPS</td><td>0.256 TFLOPS (SPEs only, 4 GHz)</td></tr><tr><td>FP16 or BF16 Throughput</td><td>362 TFLOPS</td><td>13.516 TFLOPS</td><td>51.2 TFLOPS</td><td>N/A</td></tr></tbody></table><figcaption>It’s funny to see IBM Cell here</figcaption></figure>
<p>To get to system memory, a Dojo D1 die has to communicate with an interface processor, which has onboard HBM. That interface processor is in turn connected to host systems via PCIe (the interface processors are mounted on PCIe cards). Theoretically, the smallest functional Dojo deployment would involve a Dojo die, an interface processor card, and a host system. But Tesla deploys Dojo dies in modules containing 25 dies each, to give a sense of scale. Dojo D1 dies are designed specifically to be building blocks for a supercomputer, and nothing else.</p>
<div>
<figure><a href="https://chipsandcheese.com/?attachment_id=9173"><img data-attachment-id="9173" data-permalink="https://chipsandcheese.com/2022/09/01/hot-chips-34-teslas-dojo-microarchitecture/image-7-16/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-7.jpg?fit=1253%2C705&amp;ssl=1" data-orig-size="1253,705" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-7" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-7.jpg?fit=1253%2C705&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-7.jpg?fit=688%2C387&amp;ssl=1" width="688" height="387" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-7.jpg?resize=688%2C387&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-7.jpg?w=1253&amp;ssl=1 1253w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-7.jpg?resize=768%2C432&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-7.jpg?resize=1200%2C675&amp;ssl=1 1200w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-7.jpg?resize=688%2C387&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a></figure></div>
<p>This specialization allows more die area savings. Dojo D1 doesn’t spend area on DDR and PCIe controllers. Most of the die is occupied by a sea of Dojo cores, except for custom IO connectors around the outside designed to interface with neighboring dies.</p>
<div>
<figure><a href="https://chipsandcheese.com/?attachment_id=9175"><img data-attachment-id="9175" data-permalink="https://chipsandcheese.com/2022/09/01/hot-chips-34-teslas-dojo-microarchitecture/image-7-1/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-7-1.jpg?fit=1256%2C705&amp;ssl=1" data-orig-size="1256,705" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-7-1" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-7-1.jpg?fit=1256%2C705&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-7-1.jpg?fit=688%2C386&amp;ssl=1" width="688" height="386" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-7-1.jpg?resize=688%2C386&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-7-1.jpg?w=1256&amp;ssl=1 1256w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-7-1.jpg?resize=768%2C431&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-7-1.jpg?resize=1200%2C674&amp;ssl=1 1200w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-7-1.jpg?resize=688%2C386&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a></figure></div>
<p>In comparison, chips designed with more deployment flexibility in mind spend a ton of area on IO. AMD’s Zen 1 “Zeppelin” die is a great showcase of this. Zeppelin can directly connect to DDR4 memory, PCIe devices, SATA drives, and USB devices – perfect for meeting client requirements. In servers, IFOP interfaces let it communicate with neighboring dies. Large blocks of SRAM positioned near IFOPs are likely snoop filters that help efficiently maintain cache coherency across high core count setups. Dojo doesn’t try to maintain cache coherency across cores, and doesn’t use any SRAM for snoop filters.</p>
<div>
<figure><a href="https://chipsandcheese.com/?attachment_id=9177"><img data-attachment-id="9177" data-permalink="https://chipsandcheese.com/2022/09/01/hot-chips-34-teslas-dojo-microarchitecture/image-7-2-2/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-7-2.jpg?fit=992%2C485&amp;ssl=1" data-orig-size="992,485" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-7-2" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-7-2.jpg?fit=992%2C485&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-7-2.jpg?fit=688%2C336&amp;ssl=1" width="688" height="336" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-7-2.jpg?resize=688%2C336&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-7-2.jpg?w=992&amp;ssl=1 992w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-7-2.jpg?resize=768%2C375&amp;ssl=1 768w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-7-2.jpg?resize=688%2C336&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a><figcaption>From AMD’s presentation on chiplets at ISSCC 2021</figcaption></figure></div>
<p>AMD pays for this flexibility by spending about 44% of “Zeppelin” die area on logic other than cores and cache. Dojo only spends 28.9% of die area on things other than SRAM and cores.</p>
<h2>Final Words</h2>
<p>The microarchitecture behind Tesla’s Dojo supercomputer shows how it’s possible to achieve very high compute density, while still maintaining a CPU’s ability to perform well with branchy code. To get there, you give up most of the comforts that define our modern computing experience. If you could hypothetically build your desktop around a Dojo core, the experience would probably feel familiar to anyone who has used MS-DOS. You can’t run several applications simultaneously. A single misbehaving application can force you to reboot the system. If you don’t have enough RAM to run a certain program, you can forget about running it at all (no paging to disk). </p>
<p>But these tradeoffs make perfect sense in Tesla’s supercomputer. Tesla doesn’t need Dojo cores to handle several running applications at once, and Dojo only has to run internal, trusted code. So, Tesla doesn’t care about virtual memory support. Similarly, machine learning programs running on Dojo will be written with that specific system in mind. You won’t have a batch of arbitrary programs possibly asking for more memory than is available. That means you don’t need precise exceptions (and virtual memory) to allow techniques like overcommitting memory, memory compression, or swapping memory pages to and from disk. Precise exceptions are also useful for debugging, but Tesla makes debugging possible in a cheaper way with a separate debug mode. That way, after the code has been written and debugged, Dojo can focus on running it without doing the bookkeeping necessary to commit instruction results in-order.</p>
<div>
<figure><a href="https://chipsandcheese.com/?attachment_id=9240"><img data-attachment-id="9240" data-permalink="https://chipsandcheese.com/2022/09/01/hot-chips-34-teslas-dojo-microarchitecture/image-7-3-2/" data-orig-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-7-3.jpg?fit=1313%2C739&amp;ssl=1" data-orig-size="1313,739" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-7-3" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-7-3.jpg?fit=1313%2C739&amp;ssl=1" data-large-file="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-7-3.jpg?fit=688%2C387&amp;ssl=1" width="688" height="387" src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-7-3.jpg?resize=688%2C387&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-7-3.jpg?w=1313&amp;ssl=1 1313w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-7-3.jpg?resize=1280%2C720&amp;ssl=1 1280w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-7-3.jpg?resize=768%2C432&amp;ssl=1 768w, https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-7-3.jpg?resize=1200%2C675&amp;ssl=1 1200w" data-lazy-sizes="(max-width: 688px) 100vw, 688px" data-lazy-src="https://i0.wp.com/chipsandcheese.com/wp-content/uploads/2022/08/image-7-3.jpg?resize=688%2C387&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></a></figure></div>
<p>For sure, the tradeoffs employed by Tesla to get high compute density aren’t possible in a consumer or server CPU. But they’re very interesting to see in action, and we have to thank Tesla for taking the time to present at Hot Chips. For the past two decades, process node improvements have been slowing down, resulting in slower advances in single-threaded performance. For the past half-decade, power supply and cooling limitations have been slowing down multithreaded performance. But the appetite for more computing power is not slowing down, so companies are turning to more specialized hardware to keep pace. The architecture in Tesla’s Dojo supercomputer is an excellent example of how tradeoffs can be made to increase compute density, and how current trends favor introducing specialized hardware for throughput bound applications.</p>
<p>If you like our articles and journalism and you want to support us in our endeavors then consider heading over to our <a href="https://www.patreon.com/ChipsandCheese">Patreon</a> or our <a href="https://www.paypal.com/donate/?hosted_button_id=4EMPH66SBGVSQ">PayPal</a> if you want to toss a few bucks our way or if you would like to talk with the Chips and Cheese staff and the people behind the scenes then consider joining our <a href="https://discord.gg/TwVnRhxgY2">Discord</a>.</p>
<div>

<ul>
<li>
<p><img alt="" src="https://secure.gravatar.com/avatar/83de286347cdfc84e1bb10146350467e?s=80&amp;d=identicon&amp;r=g" height="80" width="80" data-lazy-srcset="https://secure.gravatar.com/avatar/83de286347cdfc84e1bb10146350467e?s=160&amp;d=identicon&amp;r=g 2x" data-lazy-src="https://secure.gravatar.com/avatar/83de286347cdfc84e1bb10146350467e?s=80&amp;is-pending-load=1#038;d=identicon&amp;r=g" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/>
</p>

</li>
</ul>
</div>



</div></div>
  </body>
</html>
