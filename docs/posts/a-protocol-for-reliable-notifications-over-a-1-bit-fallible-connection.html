<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://paper.wf/binarycat/a-protocol-for-reliable-notifications-over-a-1-bit-fallible-connection">Original</a>
    <h1>A protocol for reliable notifications over a 1 bit fallible connection</h1>
    
    <div id="readability-page-1" class="page"><article id="post-body"><h2 id="title">a protocol for reliable notifications over a 1 bit fallible connection.</h2><time datetime="2024-10-04T03:20:45Z" pubdate="" itemprop="datePublished" content="2024-10-04 03:20:45 +0000 UTC">October 4, 2024</time><div><h2 id="what" id="what">What</h2>

<p>imagine you have two devices, a client and a server, connected in a peculiar way:</p>
<ol><li>the server cannot send messages to the client without the client asking for them</li>
<li>there are two channels, a request on one channel can only be responded to on the same channel</li>
<li>the first channel has infinite bandwith and is perfectly reliable, but each message is obscenely expensive.</li>
<li>the second channel is free, but can only send messages with a single payload bit, and the message has a 50% chance of being dropped</li></ol>

<p>You&#39;ve just been tasked with building a layer on top of this so that the server can send messages to the client, what do you do?</p>

<h2 id="how" id="how">How</h2>

<h3 id="informal" id="informal">Informal</h3>

<p>the client sends 1-bit tokens.  when the server receives that token, if it has generated new messages since it last sent that token, it responds with the boolean negation of that token.</p>

<p>the client always sends the last token it received.  when it receives a token that is different from the one it sent, it retrieves a message from the side channel.</p>

<h3 id="formal" id="formal">Formal</h3>

<p>When the system start up, the devices initialize themselves to the following state:
1. the client sets it&#39;s <code>client_token</code> variable to <code>false</code>.
2. the server has an empty message queue
3. the server sets its <code>server_token</code> to false, and <code>new_messages</code> to false.</p>

<p>the client periodically sends its <code>client_token</code> value along the unreliable channel.</p>

<p>when the server receives <code>client_token</code>, it performs the following operation:</p>

<pre><code>if client_token = server_token then
  set new_messages false
end if
</code></pre>

<p>it then responds with <code>server_token</code>.</p>

<p>whenever the server generates a new message, it performs the following operation:</p>

<pre><code>if not new_messages then
  set server_token (not server_token)
  set new_messages true
end if
</code></pre>

<p>when the client receives <code>server_token</code>, it performs the following operation:</p>

<pre><code>if server_token â‰  client_token then
  pull messages
  set client_token server_token
</code></pre>

<h2 id="why" id="why">Why</h2>

<p>turns out this absurd hypothetical isn&#39;t actually that far off of how TCP+TLS and UDP behave, especially in the context of mobile and embedded devices.</p>

<p>this system also has the nice property that the 1-bit messages don&#39;t depend on the side-channel messages, useful if there are actually multiple clients, and perhaps multiple secure servers the client wants to be able to receive messages from, and the presence of new messages is multiplexed through a single unsecured server.</p>

<hr/>

<p><a href="https://paper.wf/binarycat/tag:networking" rel="nofollow"><span>#</span><span>networking</span></a> <a href="https://paper.wf/binarycat/tag:programming" rel="nofollow"><span>#</span><span>programming</span></a></p>
</div></article></div>
  </body>
</html>
