<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.catmonad.xyz/blog/nibbles_02.html">Original</a>
    <h1>Nibbles of Rust – Restructuring Patterns</h1>
    
    <div id="readability-page-1" class="page"><div id="wrapper">
                        

<p>In Rust, there is this feature known as “pattern matching”, whereby you can take apart a piece of structured data by writing out patterns which bind to parts of it. This process is known as “destructuring”, because you’re breaking a structure into parts.</p>
<p>But there’s this old feature which I’ve unilaterally decided to call “restructuring patterns”:</p>

<p>See that <code>ref</code> keyword? It <em>adds</em> structure to the value <code>inner</code> when taking it out of <code>x</code>. Instead of moving an <code>i32</code> out of <code>x</code>, we’re taking a reference to inside it!</p>
<p>Two keywords are valid in that position: <code>ref</code> and <code>mut</code>, and they do different things. <code>mut</code> marks a binding as mutable, and can be used in combination with <code>ref</code>, as <code>ref mut</code>, to introduce a <code>&amp;mut</code> to the structure of the binding they’re next to instead of a <code>&amp;</code>.</p>
<p>This is distinct from using <code>&amp;</code> and <code>&amp;mut</code> themselves in a pattern, as these do the normal work of destructuring, working as dereference operators in that position:</p>

<p>Basically, using a <em>type</em> in a pattern lets you rip apart that type, like <code>&amp;x</code>, <code>&amp;mut x</code>, <code>Json(x)</code>, etc., and the super special <code>ref</code> keyword does the opposite.</p>
<h3 id="match-ergonomics-and-binding-modes">Match Ergonomics and Binding Modes</h3>
<p>Now, that mental model is good enough that you can pretty much run with it and it won’t steer you wrong. But it’s not the <em>whole</em> story.</p>
<p>The modern approach to matching on things with references involved is covered well by the <a href="https://github.com/rust-lang/rfcs/blob/master/text/2005-match-ergonomics.md">Match Ergonomics RFC</a>. It defines a notion of “binding mode”, which is the actual thing we’re controlling when we use the <code>ref</code> keyword, and that fact in turn is why we can’t use <code>ref ref inner</code> as a pattern. (Not that I’d ever thought to write that particular pattern before working on this post.)</p>
<p>So, when you’re <code>match</code>ing on something, Rust examines the type of the value being matched on, and decides on a default binding mode from one of these:</p>
<ul>
<li><code>move</code>, which takes ownership of the value being pattern matched</li>
<li><code>ref</code>, which takes a shared borrow from the value being matched</li>
<li><code>ref mut</code>, which takes a unique borrow from the value being matched</li>
</ul>
<p>This is chosen based on whether the type of the value being matched has an outer layer of <code>&amp;mut</code>, which pushes toward a default binding mode of <code>ref mut</code>, or a <code>&amp;</code>, which forces the default binding mode to be <code>ref</code>. If neither reference type is present, the default binding mode will be <code>move</code>.</p>
<p>This default binding mode is used if, and only if, you don’t write a reference as the outer layer of your pattern. This used to be a compiler error, but now it’s what we basically always do!</p>
<p>With that in mind, the <code>ref</code> keyword is really a tool to change the binding mode from a default of <code>move</code> to use <code>ref</code> / <code>ref mut</code> instead. In this model, it really doesn’t make sense to nest it in the fashion of <code>ref ref inner</code>, since it’s a switch with only two or three states where it’s used.</p>
<h3 id="but-wait">But wait…</h3>
<p>With all that said, wouldn’t it be neat if “restructuring patterns” were actually a first-class feature? I don’t have an idea off the top of my head what that’d be good for, but the lang-dev in me says we should investigate. If not for Rust, maybe some hypothetical other language?</p>

<p>
I was motivated to write this post by a writing group we formed in the RPLCS Discord. Other posts by our group are listed here: <a href="https://www.catmonad.xyz/writing_group/">https://www.catmonad.xyz/writing_group/</a>.
</p>
          </div></div>
  </body>
</html>
