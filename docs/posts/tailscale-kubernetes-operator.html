<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tailscale.com/kb/1236/kubernetes-operator/">Original</a>
    <h1>Tailscale Kubernetes Operator</h1>
    
    <div id="readability-page-1" class="page"><div><p>The <a href="https://github.com/tailscale/tailscale/blob/main/cmd/k8s-operator/manifests/operator.yaml">Tailscale Kubernetes operator</a> allows you to:</p>
<ul>
<li>Expose <a href="https://kubernetes.io/docs/concepts/services-networking/service/">services</a> in your
Kubernetes cluster to your Tailscale network</li>
<li>Securely connect to the <a href="https://kubernetes.io/docs/concepts/overview/components/#kube-apiserver">Kubernetes control plane (kube-apiserver)</a> via an API server proxy, with or without authentication</li>
<li>Egress from a Kubernetes cluster to an external service on your Tailscale network</li>
</ul>


<p>
    Kubernetes operator is currently
    <a href="https://tailscale.com/kb/1167/release-stages/#alpha">in private alpha</a>. Therefore, this topic is currently hidden.
    
    To try it, follow the steps below to enable it for your network using Tailscale v1.37.40 or
    later.
  </p>

<h3 id="setting-up-the-kubernetes-operator">
  <a href="#setting-up-the-kubernetes-operator">
    Setting up the Kubernetes operator
    <span aria-hidden="true"></span>
  </a>
</h3>

<ol>
<li>
<p>In your <a href="https://tailscale.com/kb/1018/acls/">tailnet policy file</a>, create the <a href="https://tailscale.com/kb/1068/acl-tags/">ACL
tags</a> <code>tag:k8s-operator</code> and <code>tag:k8s</code>, and make <code>tag:k8s-operator</code>
an owner of <code>tag:k8s</code>. If you want your services to be exposed with tags
other than the default <code>tag:k8s</code>, create those as well and make
<code>tag:k8s-operator</code> an owner.</p>
<div><pre tabindex="0"><code data-lang="json"><span><span><span>&#34;tagOwners&#34;</span><span>:</span> <span>{</span>
</span></span><span><span>   <span>&#34;tag:k8s-operator&#34;</span><span>:</span> <span>[],</span>
</span></span><span><span>   <span>&#34;tag:k8s&#34;</span><span>:</span> <span>[</span><span>&#34;tag:k8s-operator&#34;</span><span>],</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div></li>
<li>
<p><a href="https://tailscale.com/kb/1215/oauth-clients/#setting-up-an-oauth-client">Create an OAuth client</a> in the <a href="https://login.tailscale.com/admin/settings/oauth"><strong>OAuth clients</strong></a>
page of the admin console. Create the client with <code>Devices</code> write scope and
the tag <code>tag:k8s-operator</code>.</p>
</li>
<li>
<p>Download the Tailscale Kubernetes operator <a href="https://github.com/tailscale/tailscale/blob/main/cmd/k8s-operator/manifests/operator.yaml">manifest file</a>
from the <a href="https://github.com/tailscale/tailscale">tailscale/tailscale</a> repo.</p>
</li>
<li>
<p>Edit your version of the manifest file:</p>
<ol>
<li>Find <code># SET CLIENT ID HERE</code> and replace it with your OAuth client ID.</li>
<li>Find <code># SET CLIENT SECRET HERE</code> and replace it with your OAuth client secret.</li>
</ol>
<p>For both the client ID and secret, quote the value, to avoid any potential yaml misinterpretation of
unquoted strings. For example, use:</p>
<div><pre tabindex="0"><code data-lang="yaml"><span><span><span>client_id</span><span>:</span><span> </span><span>&#34;k123456CNTRL&#34;</span><span>
</span></span></span><span><span><span></span><span>client_secret</span><span>:</span><span> </span><span>&#34;tskey-client-k123456CNTRL-abcdef&#34;</span><span>
</span></span></span></code></pre></div><p>instead of:</p>
<div><pre tabindex="0"><code data-lang="yaml"><span><span><span>client_id</span><span>:</span><span> </span><span>k123456CNTRL</span><span>
</span></span></span><span><span><span></span><span>client_secret</span><span>:</span><span> </span><span>tskey-client-k123456CNTRL-abcdef</span><span>
</span></span></span></code></pre></div></li>
<li>
<p>Apply the edited file to your Kubernetes cluster:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>kubectl apply -f manifest.yaml
</span></span></code></pre></div><p>This creates the “tailscale” namespace in your cluster, and deploys the
Tailscale operator within it.</p>
</li>
<li>
<p>Verify that the Tailscale operator has joined your tailnet. Open the
<a href="https://login.tailscale.com/admin/machines"><strong>Machines</strong></a> page of the admin console and look for a node
named <strong>tailscale-operator</strong>, tagged with the <code>tag:k8s-operator</code> tag. It may
take a minute or two for the operator to join your tailnet, due to the time
required to download and start the container image in Kubernetes.</p>
</li>
</ol>
<h3 id="cluster-ingress">
  <a href="#cluster-ingress">
    Exposing a service to your tailnet (cluster ingress)
    <span aria-hidden="true"></span>
  </a>
</h3>

<p>You can use the Tailscale Kubernetes operator to expose a Kubernetes service to your Tailscale network in three ways: by making it a <code>LoadBalancer</code> type with the <code>tailscale</code> <code>loadBalancerClass</code>, by annotating an existing service, or by creating an ingress resource fronting a service.</p>
<h4 id="exposing-a-service-using-loadbalancerclass">
  <a href="#exposing-a-service-using-loadbalancerclass">
    Exposing a service using <code>loadBalancerClass</code>
    <span aria-hidden="true"></span>
  </a>
</h4>

<p>Edit the service you want to expose and make it a load balancer:</p>
<ol>
<li>Set <code>spec.type</code> to <code>LoadBalancer</code>.</li>
<li>Set <code>spec.loadBalancerClass</code> to <code>tailscale</code>.</li>
</ol>
<p>Once provisioning is complete, the service’s status will show the
<a href="https://tailscale.com/kb/1081/magicdns/">fully-qualified domain name</a> of the service in your tailnet. You can view the
service’s status by running <code>kubectl get service &lt;service name&gt;</code>.</p>
<p>You should also see a new node with that name appear in the
<a href="https://login.tailscale.com/admin/machines"><strong>Machines</strong></a> page of the admin console.</p>
<h4 id="exposing-a-service-using-annotations">
  <a href="#exposing-a-service-using-annotations">
    Exposing a service using annotations
    <span aria-hidden="true"></span>
  </a>
</h4>

<p>If the service you want to expose already exists, you can
expose it to Tailscale using <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/">object annotations</a>.</p>
<p>Edit the service and under <code>metadata.annotations</code>, add the annotation
<code>tailscale.com/expose</code> with the value <code>&#34;true&#34;</code>. Note that <code>&#34;true&#34;</code> is quoted
because annotation values are strings, and an unquoted <code>true</code> will be
incorrectly interpreted as a boolean.</p>
<p>In this mode, Kubernetes doesn’t tell you the Tailscale machine name. You can look
up the node in the <a href="https://login.tailscale.com/admin/machines"><strong>Machines</strong></a> of the admin console to learn
its machine name. By default, the machine name of an exposed service is
<code>&lt;k8s-namespace&gt;-&lt;k8s-servicename&gt;</code>.</p>
<h5 id="using-a-custom-machine-name">
  <a href="#using-a-custom-machine-name">
    Using a custom machine name
    <span aria-hidden="true"></span>
  </a>
</h5>

<p>If you want the service to have a machine name other than the default
<code>&lt;k8s-namespace&gt;-&lt;k8s-servicename&gt;</code>, you can provide your own machine name by
setting the <code>tailscale.com/hostname</code> annotation on the service, with your
desired machine name as the value.</p>
<p>Machine names are subject to the constraints of DNS: they can be up to 63 characters
long, must start and end with a letter, and consist of only letters, numbers,
and <code>-</code>.</p>
<h5 id="customizing-acl-tags">
  <a href="#customizing-acl-tags">
    Customizing ACL tags
    <span aria-hidden="true"></span>
  </a>
</h5>

<p>By default, services join your tailnet tagged with the <a href="https://tailscale.com/kb/1068/acl-tags/">ACL tag</a> <code>tag:k8s</code>. You can use a
different tag or tags by setting the <code>tailscale.com/tags</code> annotation on the
service, with a comma-separated list of the desired tags.</p>
<p>For example, setting <code>tailscale.com/tags = tag:foo,tag:bar</code> will result in the
tailnet node having the tags <code>tag:foo</code> and <code>tag:bar</code>.</p>
<p>The Tailscale operator must be a <a href="https://tailscale.com/kb/1018/acls/#tag-owners">tag owner</a> of all the specified tags: if you want
to expose a service with <code>tag:foo,tag:bar</code>, the <code>tagOwners</code> section of the
<a href="https://tailscale.com/kb/1018/acls/">tailnet policy file</a> must list <code>tag:k8s-operator</code> as one
of the owners of both <code>tag:foo</code> and <code>tag:bar</code>.</p>
<h4 id="exposing-a-service-using-ingress">
  <a href="#exposing-a-service-using-ingress">
    Exposing a service using ingress
    <span aria-hidden="true"></span>
  </a>
</h4>

<p>You can use the Tailscale Kubernetes operator to expose an ingress resource in your Kubernetes cluster to your tailnet.</p>
<p>Ingress resources only support TLS, and are only exposed over HTTPS. You must <a href="https://tailscale.com/kb/1153/enabling-https/">enable HTTPS</a> on your tailnet.</p>
<p>Edit the ingress resource you want to expose to use the ingress class <code>tailscale</code>:</p>
<ol>
<li>Set <code>spec.ingressClassName</code> to <code>tailscale</code>.</li>
<li>Set <code>tls.hosts</code> to the desired host name of the Tailscale node. Only the first label is used.</li>
</ol>
<p>For example, to expose an ingress resource <code>nginx</code> to your tailnet:</p>
<div><pre tabindex="0"><code data-lang="yaml"><span><span><span>apiVersion</span><span>:</span><span> </span><span>networking.k8s.io/v1</span><span>
</span></span></span><span><span><span></span><span>kind</span><span>:</span><span> </span><span>Ingress</span><span>
</span></span></span><span><span><span></span><span>metadata</span><span>:</span><span>
</span></span></span><span><span><span>  </span><span>name</span><span>:</span><span> </span><span>nginx</span><span>
</span></span></span><span><span><span></span><span>spec</span><span>:</span><span>
</span></span></span><span><span><span>  </span><span>defaultBackend</span><span>:</span><span>
</span></span></span><span><span><span>    </span><span>service</span><span>:</span><span>
</span></span></span><span><span><span>      </span><span>name</span><span>:</span><span> </span><span>nginx</span><span>
</span></span></span><span><span><span>      </span><span>port</span><span>:</span><span>
</span></span></span><span><span><span>        </span><span>number</span><span>:</span><span> </span><span>80</span><span>
</span></span></span><span><span><span>  </span><span>ingressClassName</span><span>:</span><span> </span><span>tailscale</span><span>
</span></span></span><span><span><span>  </span><span>tls</span><span>:</span><span>
</span></span></span><span><span><span>  </span>- <span>hosts</span><span>:</span><span>
</span></span></span><span><span><span>    </span>- <span>nginx</span><span>
</span></span></span></code></pre></div><p>The backend is HTTP by default. To use HTTPS on the backend, either set the port name to <code>https</code> or the port number to <code>443</code>:</p>
<div><pre tabindex="0"><code data-lang="yaml"><span><span><span>apiVersion</span><span>:</span><span> </span><span>networking.k8s.io/v1</span><span>
</span></span></span><span><span><span></span><span>kind</span><span>:</span><span> </span><span>Ingress</span><span>
</span></span></span><span><span><span></span><span>metadata</span><span>:</span><span>
</span></span></span><span><span><span>  </span><span>name</span><span>:</span><span> </span><span>nginx</span><span>
</span></span></span><span><span><span></span><span>spec</span><span>:</span><span>
</span></span></span><span><span><span>  </span><span>defaultBackend</span><span>:</span><span>
</span></span></span><span><span><span>    </span><span>service</span><span>:</span><span>
</span></span></span><span><span><span>      </span><span>name</span><span>:</span><span> </span><span>nginx</span><span>
</span></span></span><span><span><span>      </span><span>port</span><span>:</span><span>
</span></span></span><span><span><span>        </span><span>name</span><span>:</span><span> </span><span>https</span><span>
</span></span></span><span><span><span>  </span><span>ingressClassName</span><span>:</span><span> </span><span>tailscale</span><span>
</span></span></span><span><span><span></span><span>---</span><span>
</span></span></span><span><span><span></span><span>apiVersion</span><span>:</span><span> </span><span>v1</span><span>
</span></span></span><span><span><span></span><span>kind</span><span>:</span><span> </span><span>Service</span><span>
</span></span></span><span><span><span></span><span>metadata</span><span>:</span><span>
</span></span></span><span><span><span>  </span><span>name</span><span>:</span><span> </span><span>nginx</span><span>
</span></span></span><span><span><span></span><span>spec</span><span>:</span><span>
</span></span></span><span><span><span>  </span><span>ports</span><span>:</span><span>
</span></span></span><span><span><span>    </span><span>name</span><span>:</span><span> </span><span>https</span><span>
</span></span></span><span><span><span>    </span><span>port</span><span>:</span><span> </span><span>443</span><span>
</span></span></span><span><span><span>    </span><span>targetPort</span><span>:</span><span> </span><span>443</span><span>
</span></span></span><span><span><span>  </span><span>type</span><span>:</span><span> </span><span>ClusterIP</span><span>
</span></span></span></code></pre></div><p>A single ingress resource can be used to front multiple backend services:</p>
<div><pre tabindex="0"><code data-lang="yaml"><span><span><span>apiVersion</span><span>:</span><span> </span><span>networking.k8s.io/v1</span><span>
</span></span></span><span><span><span></span><span>kind</span><span>:</span><span> </span><span>Ingress</span><span>
</span></span></span><span><span><span></span><span>metadata</span><span>:</span><span>
</span></span></span><span><span><span>  </span><span>name</span><span>:</span><span> </span><span>ingress</span><span>
</span></span></span><span><span><span></span><span>spec</span><span>:</span><span>
</span></span></span><span><span><span>  </span><span>ingressClassName</span><span>:</span><span> </span><span>tailscale</span><span>
</span></span></span><span><span><span>  </span><span>rules</span><span>:</span><span>
</span></span></span><span><span><span>  </span>- <span>http</span><span>:</span><span>
</span></span></span><span><span><span>      </span><span>paths</span><span>:</span><span>
</span></span></span><span><span><span>      </span>- <span>path</span><span>:</span><span> </span><span>/</span><span>
</span></span></span><span><span><span>        </span><span>pathType</span><span>:</span><span> </span><span>Prefix</span><span>
</span></span></span><span><span><span>        </span><span>backend</span><span>:</span><span>
</span></span></span><span><span><span>          </span><span>service</span><span>:</span><span>
</span></span></span><span><span><span>            </span><span>name</span><span>:</span><span> </span><span>ui-svc</span><span>
</span></span></span><span><span><span>            </span><span>port</span><span>:</span><span>
</span></span></span><span><span><span>              </span><span>number</span><span>:</span><span> </span><span>80</span><span>
</span></span></span><span><span><span>      </span>- <span>path</span><span>:</span><span> </span><span>/api</span><span>
</span></span></span><span><span><span>        </span><span>pathType</span><span>:</span><span> </span><span>Prefix</span><span>
</span></span></span><span><span><span>        </span><span>backend</span><span>:</span><span>
</span></span></span><span><span><span>          </span><span>service</span><span>:</span><span>
</span></span></span><span><span><span>            </span><span>name</span><span>:</span><span> </span><span>api-svc</span><span>
</span></span></span><span><span><span>            </span><span>port</span><span>:</span><span>
</span></span></span><span><span><span>              </span><span>number</span><span>:</span><span> </span><span>80</span><span>
</span></span></span></code></pre></div><h5 id="exposing-a-service-to-the-public-internet-using-ingress-and-tailscale-funnel">
  <a href="#exposing-a-service-to-the-public-internet-using-ingress-and-tailscale-funnel">
    Exposing a service to the public internet using ingress and Tailscale Funnel
    <span aria-hidden="true"></span>
  </a>
</h5>

<p>You can also use the Tailscale Kubernetes operator to expose an ingress resource in your Kubernetes cluster to the public internet using <a href="https://tailscale.com/kb/1223/tailscale-funnel/">Taiscale Funnel</a>. To do so, add a <code> tailscale.com/funnel: &#34;true&#34;</code> annotation:</p>
<div><pre tabindex="0"><code data-lang="yaml"><span><span><span>apiVersion</span><span>:</span><span> </span><span>networking.k8s.io/v1</span><span>
</span></span></span><span><span><span></span><span>kind</span><span>:</span><span> </span><span>Ingress</span><span>
</span></span></span><span><span><span></span><span>metadata</span><span>:</span><span>
</span></span></span><span><span><span>  </span><span>name</span><span>:</span><span> </span><span>funnel</span><span>
</span></span></span><span><span><span>  </span><span>annotations</span><span>:</span><span>
</span></span></span><span><span><span>    </span><span>tailscale.com/funnel</span><span>:</span><span> </span><span>&#34;true&#34;</span><span>
</span></span></span><span><span><span></span><span>spec</span><span>:</span><span>
</span></span></span><span><span><span>  </span><span>defaultBackend</span><span>:</span><span>
</span></span></span><span><span><span>    </span><span>service</span><span>:</span><span>
</span></span></span><span><span><span>      </span><span>name</span><span>:</span><span> </span><span>funnel</span><span>
</span></span></span><span><span><span>      </span><span>port</span><span>:</span><span>
</span></span></span><span><span><span>        </span><span>number</span><span>:</span><span> </span><span>80</span><span>
</span></span></span><span><span><span>  </span><span>ingressClassName</span><span>:</span><span> </span><span>tailscale</span><span>
</span></span></span><span><span><span>  </span><span>tls</span><span>:</span><span>
</span></span></span><span><span><span>  </span>- <span>hosts</span><span>:</span><span>
</span></span></span><span><span><span>    </span>- <span>funnel</span><span>
</span></span></span></code></pre></div><h4 id="removing-a-service">
  <a href="#removing-a-service">
    Removing a service
    <span aria-hidden="true"></span>
  </a>
</h4>

<p>Any of the following actions remove a Kubernetes service you exposed from your tailnet:</p>
<ul>
<li>Delete the service entirely.</li>
<li>If you are using <code>type=LoadBalancer</code>, remove <code>loadBalancerClass=tailscale</code> or set <code>type</code> to <code>ClusterIP</code>.</li>
<li>If you are using the <code>tailscale.com/expose</code> annotation, remove the annotation.</li>
<li>If you are using an ingress resource, remove the ingress resource or remove the service from the ingress resource.</li>
</ul>
<p>Deleting a service’s Tailscale node
in the <a href="https://login.tailscale.com/admin/machines">admin console</a> does not clean up the Kubernetes state
associated with that service.</p>

<h3 id="accessing-the-kubernetes-control-plane-using-an-api-server-proxy">
  <a href="#accessing-the-kubernetes-control-plane-using-an-api-server-proxy">
    Accessing the Kubernetes control plane using an API server proxy
    <span aria-hidden="true"></span>
  </a>
</h3>

<p>You can use the Tailscale Kubernetes operator to expose and access the Kubernetes control plane (kube-apiserver) over Tailscale.</p>
<p>You can use the API server proxy with or without authentication headers. With authentication headers, when a user tries to access the Kubernetes control plane over Tailscale using an API server proxy, they will hit the kube-apiserver with the same user identity that they have in Tailscale. This is done by injecting an authentication header in the request. For example, <code>alice@example.com</code> will have the user <code>alice@example.com</code> in an API server proxy.</p>
<p>If you do not want to use Tailscale for authentication, but use an existing authentication mechanism instead, you can disable the use of authentication headers. This allows you to access the Kubernetes control plane over Tailscale, without using Tailscale for authentication.</p>
<h4 id="configuring-the-api-server-proxy">
  <a href="#configuring-the-api-server-proxy">
    Configuring the API server proxy
    <span aria-hidden="true"></span>
  </a>
</h4>

<p>To use a Tailscale Kubernetes API server proxy, you need to <a href="https://tailscale.com/kb/1153/enabling-https/#configure-https">enable HTTPS</a> for your tailnet.</p>
<p>To configure the API server proxy:</p>
<p>1. In your Tailscale Kubernetes operator’s <a href="https://github.com/tailscale/tailscale/blob/main/cmd/k8s-operator/manifests/operator.yaml">manifest file</a>, add the following lines to the <code>env</code> section:</p>
<div><pre tabindex="0"><code data-lang="yaml"><span><span><span>name</span><span>:</span><span> </span><span>APISERVER_PROXY</span><span>
</span></span></span><span><span><span></span><span>value</span><span>:</span><span> </span><span>&#34;true&#34;</span><span>
</span></span></span></code></pre></div><p>The kube-apiserver is automatically discovered by the operator.</p>
<p>2. Apply the changes from the example to your operator’s manifest file.</p>
<div><pre tabindex="0"><code data-lang="yaml"><span><span><span>apiVersion</span><span>:</span><span> </span><span>rbac.authorization.k8s.io/v1</span><span>
</span></span></span><span><span><span></span><span>kind</span><span>:</span><span> </span><span>ClusterRole</span><span>
</span></span></span><span><span><span></span><span>metadata</span><span>:</span><span>
</span></span></span><span><span><span>  </span><span>name</span><span>:</span><span> </span><span>tailscale-auth-proxy</span><span>
</span></span></span><span><span><span></span><span>rules</span><span>:</span><span>
</span></span></span><span><span><span></span>- <span>apiGroups</span><span>:</span><span> </span><span>[</span><span>&#34;&#34;</span><span>]</span><span>
</span></span></span><span><span><span>  </span><span>resources</span><span>:</span><span> </span><span>[</span><span>&#34;users&#34;</span><span>]</span><span>
</span></span></span><span><span><span>  </span><span>verbs</span><span>:</span><span> </span><span>[</span><span>&#34;impersonate&#34;</span><span>]</span><span>
</span></span></span><span><span><span></span><span>---</span><span>
</span></span></span><span><span><span></span><span>apiVersion</span><span>:</span><span> </span><span>rbac.authorization.k8s.io/v1</span><span>
</span></span></span><span><span><span></span><span>kind</span><span>:</span><span> </span><span>ClusterRoleBinding</span><span>
</span></span></span><span><span><span></span><span>metadata</span><span>:</span><span>
</span></span></span><span><span><span>  </span><span>name</span><span>:</span><span> </span><span>tailscale-auth-proxy</span><span>
</span></span></span><span><span><span></span><span>subjects</span><span>:</span><span>
</span></span></span><span><span><span></span>- <span>kind</span><span>:</span><span> </span><span>ServiceAccount</span><span>
</span></span></span><span><span><span>  </span><span>name</span><span>:</span><span> </span><span>operator</span><span>
</span></span></span><span><span><span>  </span><span>namespace</span><span>:</span><span> </span><span>tailscale</span><span>
</span></span></span><span><span><span></span><span>roleRef</span><span>:</span><span>
</span></span></span><span><span><span>  </span><span>kind</span><span>:</span><span> </span><span>ClusterRole</span><span>
</span></span></span><span><span><span>  </span><span>name</span><span>:</span><span> </span><span>tailscale-auth-proxy</span><span>
</span></span></span><span><span><span>  </span><span>apiGroup</span><span>:</span><span> </span><span>rbac.authorization.k8s.io</span><span>
</span></span></span></code></pre></div><p>3. Add an <a href="https://tailscale.com/kb/1018/acls/">access rule</a> in your tailnet’s policy file to grant access to the API server proxy over Tailscale.</p>
<p>4. Run the following command to grant a user the <a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/#user-facing-roles">Kubernetes cluster-admin role</a> in your cluster.</p>
<pre tabindex="0"><code>kubectl create clusterrolebinding --clusterrole cluster-admin --user alice@example alice@example
</code></pre><p>5. Use the <code>tailscale configure kubeconfig &lt;hostname-or-fqdn&gt;</code> <a href="https://tailscale.com/kb/1080/cli/#configure-alpha">CLI</a> command to configure your local <code>kubeconfig</code> file to manage how to authenticate to kubectl as the Tailscale Kubernetes API server proxy.</p>
<p>To validate that API server proxy allows you to access the kube-apiserver over Tailscale:</p>
<p>6. Run <code>kubectl config current-context</code> to verify that kubectl commands will
now use Tailscale context.</p>
<p>7. Run the <code>kubectl get pods -A</code> command to run a test and verify that you have authorization.</p>
<pre tabindex="0"><code>NAMESPACE     NAME                               READY   STATUS    RESTARTS      AGE
kube-system   cilium-6b2x8                       1/1     Running   0             28d
kube-system   cilium-operator-759999b555-qbsrk   1/1     Running   3 (21d ago)   29d
kube-system   coredns-7697897646-4vh2l           1/1     Running   0             29d
kube-system   coredns-7697897646-rshwm           1/1     Running   0             29d
kube-system   cpc-bridge-proxy-xksns             1/1     Running   0             29d
kube-system   csi-do-node-k5snn                  2/2     Running   0             29d
kube-system   do-node-agent-n8nrr                1/1     Running   0             29d
kube-system   konnectivity-agent-k846g           1/1     Running   0             29d
kube-system   kube-proxy-lgzr9                   1/1     Running   0             29d
tailscale     operator-6b94c54478-n6tmc          1/1     Running   0             14d
</code></pre><h5 id="enabling-tagged-nodes-to-authenticate-using-the-api-server-proxy">
  <a href="#enabling-tagged-nodes-to-authenticate-using-the-api-server-proxy">
    Enabling tagged nodes to authenticate using the API server proxy
    <span aria-hidden="true"></span>
  </a>
</h5>

<p>The API server proxy allows users to use their Tailscale identities to authenticate to the Kubernetes control plane.</p>
<p>Tagged nodes authenticate as the node name instead of the user who created the node.</p>

<p>To enable tagged nodes to authenticate to the Kubernetes control plane, create a Kubernetes RoleBinding for a group, and give the group cluster access.</p>
<p>For example, create a RoleBinding for the group <code>tag:ci</code>:</p>
<div><pre tabindex="0"><code data-lang="yaml"><span><span><span>subjects</span><span>:</span><span>
</span></span></span><span><span><span></span>- <span>kind</span><span>:</span><span> </span><span>Group</span><span>
</span></span></span><span><span><span>  </span><span>name</span><span>:</span><span> </span><span>&#34;tag:ci&#34;</span><span>
</span></span></span><span><span><span>  </span><span>apiGroup</span><span>:</span><span> </span><span>rbac.authorization.k8s.io</span><span>
</span></span></span></code></pre></div><p>Then, grant the group <code>tag:ci</code> a <code>ClusterRole</code> using a Kubernetes ClusterRoleBinding:</p>
<div><pre tabindex="0"><code data-lang="sh"><span><span>kubectl create clusterrolebinding --clusterrole cluster-admin --group <span>&#34;tag:ci&#34;</span> tag-ci
</span></span></code></pre></div>

<p>To use the API server proxy without authentication headers, in the <code>env</code> section of your Kubernetes operator.yml file, set the value <code>&#34;noauth&#34;</code> for the <code>APISERVER_PROXY</code>:</p>
<div><pre tabindex="0"><code data-lang="yaml"><span><span><span>   </span><span>name</span><span>:</span><span> </span><span>APISERVER_PROXY</span><span>
</span></span></span><span><span><span>   </span><span>value</span><span>:</span><span> </span><span>&#34;noauth&#34;</span><span> </span><span># instead of true</span><span>
</span></span></span></code></pre></div><h3 id="cluster-egress">
  <a href="#cluster-egress">
    Exposing a service to your cluster (cluster egress)
    <span aria-hidden="true"></span>
  </a>
</h3>

<p>You can use the Tailscale Kubernetes operator to advertise a service external to your cluster which is on your Tailscale network.</p>
<p>This is done by deploying a proxy in the cluster, setting the service’s <code>spec.externalName</code> to point to the proxy, and setting iptables rules for the proxy to direct incoming traffic to the DNS entry for the tailnet service. When a cluster workload attempts to reach the service, it is first directed to the proxy, which then redirects the traffic to the external service.</p>
<h4 id="exposing-a-tailnet-service-using-annotations">
  <a href="#exposing-a-tailnet-service-using-annotations">
    Exposing a tailnet service using annotations
    <span aria-hidden="true"></span>
  </a>
</h4>

<p>You can expose a tailnet service to your cluster workloads using annotations and an <a href="https://kubernetes.io/docs/concepts/services-networking/service/#externalname">external name</a>. You can currently only expose tailnet services that use HTTP.</p>
<p>To expose a tailnet service to your cluster workloads:</p>
<ol>
<li>Create a Kubernetes Service of type <a href="https://kubernetes.io/docs/concepts/services-networking/service/#externalname">ExternalName</a> annotated with the Tailscale IP address of the service you want to make available:</li>
</ol>
<div><pre tabindex="0"><code data-lang="yaml"><span><span><span>apiVersion</span><span>:</span><span> </span><span>v1</span><span>
</span></span></span><span><span><span></span><span>kind</span><span>:</span><span> </span><span>Service</span><span>
</span></span></span><span><span><span></span><span>metadata</span><span>:</span><span>
</span></span></span><span><span><span>  </span><span>annotations</span><span>:</span><span>
</span></span></span><span><span><span>    </span><span>tailscale.com/tailnet-ip</span><span>:</span><span> </span><span>100.68.29.93</span><span> </span><span>// Tailscale IP address</span><span>
</span></span></span><span><span><span>  </span><span>name</span><span>:</span><span> </span><span>nginx // service name</span><span>
</span></span></span><span><span><span></span><span>spec</span><span>:</span><span>
</span></span></span><span><span><span>  </span><span>externalName</span><span>:</span><span> </span><span>unused // any value - will be overwritten by operator</span><span>
</span></span></span></code></pre></div><p>Under <code>metadata.annotations</code>, add the annotation
<code>tailscale.com/tailnet-ip</code> with the Tailscale IP address for the tailnet service.
This can be either an IPv4 or IPv6 address, for either a Tailscale node or a route in a Tailscale subnet. This does not support IP ranges or Tailscale node names.</p>
<p>Under <code>spec.externalName</code>, add any value. This needs to be set to pass Kubernetes validation, but can hold any placeholder value. It will be overwritten by the Tailscale Kubernetes operator with a DNS name that cluster workloads can use to reach the proxy.</p>
<ol start="2">
<li>Wait for the Tailscale Kubernetes operator to deploy the proxy in the <code>tailscale</code> namespace, and to update the <code>spec.externalName</code> of the Kubernetes Service. It will get set to the DNS name of the egress proxy that Tailscale operator creates.</li>
</ol>
<p>Any cluster workload can now access the exposed Tailscale service using the annotated Kubernetes Service — calls to it will be routed to the proxy and forwarded to the right Tailscale node.</p>
<h5 id="validate-the-proxy-is-properly-deployed">
  <a href="#validate-the-proxy-is-properly-deployed">
    Validate the proxy is properly deployed
    <span aria-hidden="true"></span>
  </a>
</h5>

<p>The proxy pod is deployed in the <code>tailscale</code> namespace, and will have a name of the form <code>ts-&lt;annotated-service-name&gt;-&lt;random-string&gt;</code>.</p>
<p>If there are issues reaching the external service, verify the proxy pod is properly deployed:</p>
<ul>
<li>Review the logs of the proxy pod.</li>
<li>Review the logs of the operator. You can do this by running <code>kubectl logs deploy/operator --namespace tailscale</code>. The log level can be configured using the <code>OPERATOR_LOGGING</code> environment variable in the operator’s <a href="https://github.com/tailscale/tailscale/blob/main/cmd/k8s-operator/manifests/operator.yaml">manifest file</a>.</li>
<li>Verify that the cluster workload is able to send traffic to the proxy pod in the <code>tailscale</code> namespace.</li>
</ul>
<h3 id="exposing-a-service-in-one-cluster-to-another-cluster-cross-cluster-connectivity">
  <a href="#exposing-a-service-in-one-cluster-to-another-cluster-cross-cluster-connectivity">
    Exposing a service in one cluster to another cluster (cross-cluster connectivity)
    <span aria-hidden="true"></span>
  </a>
</h3>

<p>You can use the Tailscale Kubernetes operator to expose a service in one cluster to another cluster. This is done by exposing the service on destination cluster A to the tailnet (<a href="#cluster-ingress">cluster ingress</a>), and connecting from a source service in cluster B to the tailnet (<a href="#cluster-egress">cluster egress</a>) in order to access the service running in cluster A.</p>
<p>This will need to be configured for each ingress and egress pair of services. To set this up for access via ingress to a service in cluster A and routing via egrees from a service in cluster B:</p>
<ol>
<li>Set up <a href="#exposing-a-service-using-ingress">ingress</a> in cluster A for the service you wish to access.</li>
<li>Expose the external service (running in cluster A) using its Tailscale IP address in cluster B with an <a href="#exposing-an-external-service-using-annotations">annotation on the external service</a></li>
</ol>
<h3 id="limitations">
  <a href="#limitations">
    Limitations
    <span aria-hidden="true"></span>
  </a>
</h3>

<ul>
<li>Only development (“unstable”) builds are usable for now, as the operator
depends on some changes that happened after the release of Tailscale v1.36.</li>
<li>There are no deployment options other than applying the
<a href="https://github.com/tailscale/tailscale/blob/main/cmd/k8s-operator/manifests/operator.yaml">manifest file</a>.</li>
<li>There are no automated updates. The operator and proxy pods will not update
automatically to newer Tailscale releases as they become available.</li>
<li>There are no dashboards or metrics.</li>
</ul>
<p>Cluster ingress</p>
<ul>
<li>Tags are only considered during initial provisioning. That is, editing
<code>tailscale.com/tags</code> on an already exposed service doesn’t update the tags
until you clean up and re-expose the service.</li>
<li>The requested machine name is only considered during initial provisioning. That
is, editing <code>tailscale.com/hostname</code> on an already exposed service doesn’t
update the machine name until you clean up and re-expose the service.</li>
<li>Ingress to cluster services currently only supports hosts where netfilter can be configured via iptables.</li>
</ul>
<p>API server proxy</p>
<ul>
<li>The API server proxy runs inside of the cluster. If your cluster is non-functional or is unable to schedule pods, you may lose access to the API server proxy.</li>
</ul>
<p>Cluster egress</p>
<ul>
<li>When exposing a service to your cluster, any associated MagicDNS name will not resolve in-cluster. Instead, the name of the ExternalName service should be used to connect to the resource. As a result of this, if you use Tailscale to provision certificates you may see certificate name mismatch errors. <em>We are working on this.</em></li>
<li>Egress to external services supports using an IPv4 or IPv6 address for a single route in the <code>tailscale.com/tailnet-ip</code> annotation, but not IP ranges or node names.</li>
<li>Egress to external services currently only supports hosts where netfilter can be configured via iptables.</li>
<li>Egress to external services currently only supports clusters where privileged pods are permitted (i.e., GKE Autopilot is not supported).</li>
</ul>
</div></div>
  </body>
</html>
