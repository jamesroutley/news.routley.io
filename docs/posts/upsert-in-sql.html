<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://antonz.org/sql-upsert/">Original</a>
    <h1>Upsert in SQL</h1>
    
    <div id="readability-page-1" class="page"><div><div><article><div><div><header></header><p><em>Upsert</em> is an operation that ➊ inserts new records into the database and ➋ updates existing ones. Let&#39;s see how it works in different DBMS. The examples are interactive, so you can read and practice.</p><p>We will use the toy <code>employees</code> table:</p><pre tabindex="0"><code>┌────┬───────┬────────┬────────────┬────────┐
│ id │ name  │  city  │ department │ salary │
├────┼───────┼────────┼────────────┼────────┤
│ 11 │ Diane │ London │ hr         │ 70     │
│ 12 │ Bob   │ London │ hr         │ 78     │
│ 21 │ Emma  │ London │ it         │ 84     │
│ 22 │ Grace │ Berlin │ it         │ 90     │
│ 23 │ Henry │ London │ it         │ 104    │
│ 24 │ Irene │ Berlin │ it         │ 104    │
│ 31 │ Cindy │ Berlin │ sales      │ 96     │
│ 32 │ Dave  │ London │ sales      │ 96     │
└────┴───────┴────────┴────────────┴────────┘
</code></pre><p>Let&#39;s say we are adding two new employees:</p><pre tabindex="0"><code>(25, &#39;Frank&#39;, &#39;Berlin&#39;, &#39;it&#39;, 120)
(33, &#39;Alice&#39;, &#39;Berlin&#39;, &#39;sales&#39;, 100)
</code></pre><p>Hello, Frank. Hello, Alice.</p><p>And updating the other two:</p><pre tabindex="0"><code>- (11, &#39;Diane&#39;, &#39;London&#39;, &#39;hr&#39;, 70)
+ (11, &#39;Diane&#39;, &#39;Berlin&#39;, &#39;hr&#39;, 70)

- (21, &#39;Emma&#39;, &#39;London&#39;, &#39;it&#39;, 84)
+ (21, &#39;Emma&#39;, &#39;London&#39;, &#39;it&#39;, 95)
</code></pre><p>Diane is moving to Berlin, while Emma&#39;s salary is increasing to 95.</p><p>You can read this article from start to finish, or you can skip to a section about the specific database engine:</p><p><a href="#mysql-replace">MySQL/MariaDB</a> •
<a href="#sqlite-insert-or">SQLite</a> •
<a href="#postgresql-inserton-conflict">PostgreSQL</a> •
<a href="#sql-standard-merge">SQL Server</a> •
<a href="#sql-standard-merge">Oracle</a> •
<a href="#other-database-engines">Others</a></p><h2 id="insert">INSERT</h2><p>Let&#39;s try the easy way:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>insert</span> <span>into</span> <span>employees</span>
</span></span><span><span>(<span>id</span>, <span>name</span>, <span>city</span>, <span>department</span>, <span>salary</span>)
</span></span><span><span><span>values</span>
</span></span><span><span>(<span>11</span>, <span>&#39;Diane&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;hr&#39;</span>, <span>70</span>),
</span></span><span><span>(<span>21</span>, <span>&#39;Emma&#39;</span>, <span>&#39;London&#39;</span>, <span>&#39;it&#39;</span>, <span>95</span>),
</span></span><span><span>(<span>25</span>, <span>&#39;Frank&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;it&#39;</span>, <span>120</span>),
</span></span><span><span>(<span>33</span>, <span>&#39;Alice&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;sales&#39;</span>, <span>100</span>);
</span></span></code></pre></div><codapi-snippet sandbox="sqlite" editor="basic" template="sample.sqlite.sql"></codapi-snippet><p>The first table is &#34;before insert&#34;, the second is &#34;after insert&#34;. We&#39;ll use this notation for all examples.</p><p>As expected, it fails for Diane and Emma: the employee ID is a primary key, so we can&#39;t have two employees with the same ID. We&#39;ll have to try something else.</p><h2 id="mysql-replace">MySQL: REPLACE</h2><p>MySQL&#39;s <code>replace into</code> inserts records with new primary/unique keys (in our case, employee IDs) and replaces the ones with existing keys:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>replace</span> <span>into</span> <span>employees</span>
</span></span><span><span>(<span>id</span>, <span>name</span>, <span>city</span>, <span>department</span>, <span>salary</span>)
</span></span><span><span><span>values</span>
</span></span><span><span>(<span>11</span>, <span>&#39;Diane&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;hr&#39;</span>, <span>70</span>),
</span></span><span><span>(<span>21</span>, <span>&#39;Emma&#39;</span>, <span>&#39;London&#39;</span>, <span>&#39;it&#39;</span>, <span>95</span>),
</span></span><span><span>(<span>25</span>, <span>&#39;Frank&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;it&#39;</span>, <span>120</span>),
</span></span><span><span>(<span>33</span>, <span>&#39;Alice&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;sales&#39;</span>, <span>100</span>);
</span></span></code></pre></div><codapi-snippet sandbox="mysql" editor="basic" template="sample.sql"></codapi-snippet><p>Added Frank and Alice, replaced Diane and Emma.</p><p>The bad thing about <code>replace</code> is that it does an actual <code>delete</code> followed by <code>insert</code>, which has some unexpected <a href="https://stackoverflow.com/a/548570">side effects</a> like firing <code>on delete</code> triggers.</p><p>Also, you can&#39;t reference the old values when replacing the record. For example, you can&#39;t set <code>city</code> = <code>Berlin (prev. London)</code> for Diane.</p><p>→ <a href="https://dev.mysql.com/doc/refman/8.0/en/replace.html">Documentation</a></p><p>To ignore the duplicates and only perform inserts, you can use <code>insert ignore</code>:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>insert</span> <span>ignore</span> <span>into</span> <span>employees</span>
</span></span><span><span>(<span>id</span>, <span>name</span>, <span>city</span>, <span>department</span>, <span>salary</span>)
</span></span><span><span><span>values</span>
</span></span><span><span>(<span>11</span>, <span>&#39;Diane&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;hr&#39;</span>, <span>70</span>),
</span></span><span><span>(<span>21</span>, <span>&#39;Emma&#39;</span>, <span>&#39;London&#39;</span>, <span>&#39;it&#39;</span>, <span>95</span>),
</span></span><span><span>(<span>25</span>, <span>&#39;Frank&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;it&#39;</span>, <span>120</span>),
</span></span><span><span>(<span>33</span>, <span>&#39;Alice&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;sales&#39;</span>, <span>100</span>);
</span></span></code></pre></div><codapi-snippet sandbox="mysql" editor="basic" template="sample.sql"></codapi-snippet><p>Added Frank and Alice, ignored Diane and Emma.</p><p>→ <a href="https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html#ignore-effect-on-execution">Documentation</a></p><p><code>replace</code> is probably not the best way to do upserts in MySQL. There is a better alternative ↓</p><h2 id="mysql-inserton-duplicate-key-update">MySQL: INSERT...ON DUPLICATE KEY UPDATE</h2><p>MySQL&#39;s <code>on duplicate key update</code> inserts records with new primary/unique keys (in our case, employee IDs) and updates the ones with existing keys:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>insert</span> <span>into</span> <span>employees</span>
</span></span><span><span>(<span>id</span>, <span>name</span>, <span>city</span>, <span>department</span>, <span>salary</span>)
</span></span><span><span><span>values</span>
</span></span><span><span>  (<span>11</span>, <span>&#39;Diane&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;hr&#39;</span>, <span>70</span>),
</span></span><span><span>  (<span>21</span>, <span>&#39;Emma&#39;</span>, <span>&#39;London&#39;</span>, <span>&#39;it&#39;</span>, <span>95</span>),
</span></span><span><span>  (<span>25</span>, <span>&#39;Frank&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;it&#39;</span>, <span>120</span>),
</span></span><span><span>  (<span>33</span>, <span>&#39;Alice&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;sales&#39;</span>, <span>100</span>)
</span></span><span><span><span>on</span> <span>duplicate</span> <span>key</span> <span>update</span>
</span></span><span><span>  <span>city</span> <span>=</span> <span>values</span>(<span>city</span>),
</span></span><span><span>  <span>salary</span> <span>=</span> <span>values</span>(<span>salary</span>);
</span></span></code></pre></div><codapi-snippet sandbox="mysql" editor="basic" template="sample.sql"></codapi-snippet><p>Added Frank and Alice, updated Diane and Emma.</p><p>When updating a record, you can reference the old value by column name (<code>city</code>) and the new value with the <code>values()</code> function (<code>values(city)</code>). Now we can actually update a value, not just replace it:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>insert</span> <span>into</span> <span>employees</span>
</span></span><span><span>(<span>id</span>, <span>name</span>, <span>city</span>, <span>department</span>, <span>salary</span>)
</span></span><span><span><span>values</span>
</span></span><span><span>  (<span>11</span>, <span>&#39;Diane&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;hr&#39;</span>, <span>70</span>)
</span></span><span><span><span>on</span> <span>duplicate</span> <span>key</span> <span>update</span>
</span></span><span><span>  <span>city</span> <span>=</span> <span>concat</span>(<span>values</span>(<span>city</span>), <span>&#39; (prev. &#39;</span>, <span>city</span>, <span>&#39;)&#39;</span>);
</span></span></code></pre></div><codapi-snippet sandbox="mysql" editor="basic" template="sample.sql"></codapi-snippet><p>Updated the city for Diane and kept the old value for reference.</p><p>Starting with MySQL 8.0, you can alias the new values and not use the ugly <code>values()</code> function:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>insert</span> <span>into</span> <span>employees</span>
</span></span><span><span>(<span>id</span>, <span>name</span>, <span>city</span>, <span>department</span>, <span>salary</span>)
</span></span><span><span><span>values</span>
</span></span><span><span>  (<span>11</span>, <span>&#39;Diane&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;hr&#39;</span>, <span>70</span>),
</span></span><span><span>  (<span>21</span>, <span>&#39;Emma&#39;</span>, <span>&#39;London&#39;</span>, <span>&#39;it&#39;</span>, <span>95</span>),
</span></span><span><span>  (<span>25</span>, <span>&#39;Frank&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;it&#39;</span>, <span>120</span>),
</span></span><span><span>  (<span>33</span>, <span>&#39;Alice&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;sales&#39;</span>, <span>100</span>)
</span></span><span><span>  <span>as</span> <span>new</span>
</span></span><span><span><span>on</span> <span>duplicate</span> <span>key</span> <span>update</span>
</span></span><span><span>  <span>city</span> <span>=</span> <span>new</span>.<span>city</span>,
</span></span><span><span>  <span>salary</span> <span>=</span> <span>new</span>.<span>salary</span>;
</span></span></code></pre></div><codapi-snippet sandbox="mysql" editor="basic" template="sample.sql"></codapi-snippet><p>Using the <code>new</code> alias for new records.</p><p>→ <a href="https://dev.mysql.com/doc/refman/8.0/en/insert-on-duplicate.html">Documentation</a></p><h2 id="sqlite-insert-or">SQLite: INSERT OR...</h2><p>SQLite&#39;s <code>insert or replace</code> inserts records with new primary/unique keys (in our case, employee IDs) and replaces the ones with existing keys:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>insert</span> <span>or</span> <span>replace</span> <span>into</span> <span>employees</span>
</span></span><span><span>(<span>id</span>, <span>name</span>, <span>city</span>, <span>department</span>, <span>salary</span>)
</span></span><span><span><span>values</span>
</span></span><span><span>(<span>25</span>, <span>&#39;Frank&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;it&#39;</span>, <span>120</span>),
</span></span><span><span>(<span>33</span>, <span>&#39;Alice&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;sales&#39;</span>, <span>100</span>),
</span></span><span><span>(<span>11</span>, <span>&#39;Diane&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;hr&#39;</span>, <span>70</span>),
</span></span><span><span>(<span>21</span>, <span>&#39;Emma&#39;</span>, <span>&#39;London&#39;</span>, <span>&#39;it&#39;</span>, <span>95</span>);
</span></span></code></pre></div><codapi-snippet sandbox="sqlite" editor="basic" template="sample.sqlite.sql"></codapi-snippet><p>Added Frank and Alice, replaced Diane and Emma.</p><p>Like MySQL&#39;s <code>replace</code>, SQLite&#39;s <code>or replace</code> deletes existing duplicate records before inserting the new ones. It fires delete triggers in some cases and does not allow references to old values.</p><p>SQLite provides a number of alternative strategies instead of <code>replace</code>:</p><ul><li><code>ignore</code>: skips the duplicate records (similar to MySQL&#39;s <code>ignore</code>).</li><li><code>rollback</code>: aborts the current statement and rolls back the entire transaction.</li><li><code>abort</code>: aborts the current statement and reverts any changes made by it, but does not roll back the transaction.</li><li><code>fail</code>: aborts the current statement, but does not revert any changes already made by it, and does not roll back the transaction.</li></ul><div><pre tabindex="0"><code data-lang="sql"><span><span><span>insert</span> <span>or</span> <span>abort</span> <span>into</span> <span>employees</span>
</span></span><span><span>(<span>id</span>, <span>name</span>, <span>city</span>, <span>department</span>, <span>salary</span>)
</span></span><span><span><span>values</span>
</span></span><span><span>(<span>11</span>, <span>&#39;Diane&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;hr&#39;</span>, <span>70</span>),
</span></span><span><span>(<span>21</span>, <span>&#39;Emma&#39;</span>, <span>&#39;London&#39;</span>, <span>&#39;it&#39;</span>, <span>95</span>),
</span></span><span><span>(<span>25</span>, <span>&#39;Frank&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;it&#39;</span>, <span>120</span>),
</span></span><span><span>(<span>33</span>, <span>&#39;Alice&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;sales&#39;</span>, <span>100</span>);
</span></span></code></pre></div><codapi-snippet sandbox="sqlite" editor="basic" template="sample.sqlite.sql"></codapi-snippet><p>Since there are conflicts, <code>abort</code> reverts all changes. The table remains as it was.</p><p>→ <a href="https://sqlite.org/lang_conflict.html">Documentation</a></p><p><code>insert or replace</code> is probably not the best way to do upserts in SQLite. There is a better alternative ↓</p><h2 id="sqlite-inserton-conflict">SQLite: INSERT...ON CONFLICT</h2><p>SQLite&#39;s <code>on conflict do update</code> inserts records with new primary/unique keys (in our case, employee IDs) and updates the ones with existing keys:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>insert</span> <span>into</span> <span>employees</span>
</span></span><span><span>(<span>id</span>, <span>name</span>, <span>city</span>, <span>department</span>, <span>salary</span>)
</span></span><span><span><span>values</span>
</span></span><span><span>  (<span>11</span>, <span>&#39;Diane&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;hr&#39;</span>, <span>70</span>),
</span></span><span><span>  (<span>21</span>, <span>&#39;Emma&#39;</span>, <span>&#39;London&#39;</span>, <span>&#39;it&#39;</span>, <span>95</span>),
</span></span><span><span>  (<span>25</span>, <span>&#39;Frank&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;it&#39;</span>, <span>120</span>),
</span></span><span><span>  (<span>33</span>, <span>&#39;Alice&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;sales&#39;</span>, <span>100</span>)
</span></span><span><span><span>on</span> <span>conflict</span> <span>do</span> <span>update</span> <span>set</span>
</span></span><span><span>  <span>city</span> <span>=</span> <span>excluded</span>.<span>city</span>,
</span></span><span><span>  <span>salary</span> <span>=</span> <span>excluded</span>.<span>salary</span>;
</span></span></code></pre></div><codapi-snippet sandbox="sqlite" editor="basic" template="sample.sqlite.sql"></codapi-snippet><p>Added Frank and Alice, updated Diane and Emma.</p><p>When updating a record, you can reference the old value by column name (<code>city</code>) and the new value with the <code>excluded</code> prefix (<code>excluded.city</code>).</p><p>You can optionally disable some updates using the <code>where</code> clause:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>insert</span> <span>into</span> <span>employees</span>
</span></span><span><span>(<span>id</span>, <span>name</span>, <span>city</span>, <span>department</span>, <span>salary</span>)
</span></span><span><span><span>values</span>
</span></span><span><span>  (<span>21</span>, <span>&#39;Emma&#39;</span>, <span>&#39;London&#39;</span>, <span>&#39;it&#39;</span>, <span>95</span>),
</span></span><span><span>  (<span>22</span>, <span>&#39;Grace&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;it&#39;</span>, <span>105</span>)
</span></span><span><span><span>on</span> <span>conflict</span> <span>do</span> <span>update</span> <span>set</span>
</span></span><span><span>  <span>salary</span> <span>=</span> <span>excluded</span>.<span>salary</span> <span>where</span> <span>excluded</span>.<span>salary</span> <span>&lt;</span> <span>100</span>;
</span></span></code></pre></div><codapi-snippet sandbox="sqlite" editor="basic" template="emma-grace.sqlite.sql"></codapi-snippet><p>We only allow salaries under 100, so Emma gets updated but Grace does not.</p><p>Besides <code>do update</code>, there is also <code>do nothing</code>, which ignores conflicts and only inserts new records:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>insert</span> <span>into</span> <span>employees</span>
</span></span><span><span>(<span>id</span>, <span>name</span>, <span>city</span>, <span>department</span>, <span>salary</span>)
</span></span><span><span><span>values</span>
</span></span><span><span>  (<span>11</span>, <span>&#39;Diane&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;hr&#39;</span>, <span>70</span>),
</span></span><span><span>  (<span>21</span>, <span>&#39;Emma&#39;</span>, <span>&#39;London&#39;</span>, <span>&#39;it&#39;</span>, <span>95</span>),
</span></span><span><span>  (<span>25</span>, <span>&#39;Frank&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;it&#39;</span>, <span>120</span>),
</span></span><span><span>  (<span>33</span>, <span>&#39;Alice&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;sales&#39;</span>, <span>100</span>)
</span></span><span><span><span>on</span> <span>conflict</span> <span>do</span> <span>nothing</span>;
</span></span></code></pre></div><codapi-snippet sandbox="sqlite" editor="basic" template="sample.sqlite.sql"></codapi-snippet><p>Added Frank and Alice, ignored Diane and Emma.</p><p><code>on conflict</code> even allows you to specify different rules for different uniqueness constraints:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>create</span> <span>unique</span> <span>index</span> <span>idx_employees_name</span> <span>on</span> <span>employees</span>(<span>name</span>);
</span></span><span><span>
</span></span><span><span><span>insert</span> <span>into</span> <span>employees</span>
</span></span><span><span>(<span>id</span>, <span>name</span>, <span>city</span>, <span>department</span>, <span>salary</span>)
</span></span><span><span><span>values</span>
</span></span><span><span>  <span>-- increase Emma&#39;s salary to 95
</span></span></span><span><span><span></span>  (<span>21</span>, <span>&#39;Emma&#39;</span>, <span>&#39;London&#39;</span>, <span>&#39;it&#39;</span>, <span>95</span>),
</span></span><span><span>  <span>-- change Grace&#39;s name to Diane
</span></span></span><span><span><span></span>  (<span>22</span>, <span>&#39;Diane&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;it&#39;</span>, <span>90</span>)
</span></span><span><span><span>on</span> <span>conflict</span> (<span>id</span>) <span>do</span> <span>update</span> <span>set</span>
</span></span><span><span>  <span>city</span> <span>=</span> <span>excluded</span>.<span>city</span>,
</span></span><span><span>  <span>salary</span> <span>=</span> <span>excluded</span>.<span>salary</span>
</span></span><span><span><span>on</span> <span>conflict</span> (<span>name</span>) <span>do</span> <span>nothing</span>;
</span></span></code></pre></div><codapi-snippet sandbox="sqlite" editor="basic" template="emma-grace.sqlite.sql"></codapi-snippet><p>We only allow unique names (stupid, I know), and &#34;Diane&#34; is already taken. So Emma&#39;s salary is updated, but Grace&#39;s name is not.</p><p>→ <a href="https://sqlite.org/lang_upsert.html">Documentation</a></p><div><h3><img src="https://antonz.org/assets/codapi.svg"/> Code playgrounds</h3><p>Interactive examples in this post are powered by <a href="https://codapi.org/"><strong>codapi</strong></a> — the platform I&#39;m building. Use it to embed code playgrounds into your online course, documentation, or blog.</p></div><h2 id="postgresql-inserton-conflict">PostgreSQL: INSERT...ON CONFLICT</h2><p>PostgreSQL&#39;s <code>on conflict do update</code> is very similar to SQLite&#39;s (in fact, SQLite&#39;s implementation was inspired by PostgreSQL&#39;s). It inserts records with new primary/unique keys (in our case, employee IDs) and updates the ones with existing keys:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>insert</span> <span>into</span> <span>employees</span>
</span></span><span><span>(<span>id</span>, <span>name</span>, <span>city</span>, <span>department</span>, <span>salary</span>)
</span></span><span><span><span>values</span>
</span></span><span><span>  (<span>11</span>, <span>&#39;Diane&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;hr&#39;</span>, <span>70</span>),
</span></span><span><span>  (<span>21</span>, <span>&#39;Emma&#39;</span>, <span>&#39;London&#39;</span>, <span>&#39;it&#39;</span>, <span>95</span>),
</span></span><span><span>  (<span>25</span>, <span>&#39;Frank&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;it&#39;</span>, <span>120</span>),
</span></span><span><span>  (<span>33</span>, <span>&#39;Alice&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;sales&#39;</span>, <span>100</span>)
</span></span><span><span><span>on</span> <span>conflict</span> (<span>id</span>) <span>do</span> <span>update</span> <span>set</span>
</span></span><span><span>  <span>city</span> <span>=</span> <span>excluded</span>.<span>city</span>,
</span></span><span><span>  <span>salary</span> <span>=</span> <span>excluded</span>.<span>salary</span>;
</span></span></code></pre></div><codapi-snippet sandbox="postgres" editor="basic" template="sample.pg.sql"></codapi-snippet><p>Added Frank and Alice, updated Diane and Emma.</p><p>When updating a record, you can reference the old value by column name (<code>city</code>) and the new value with the <code>excluded</code> prefix (<code>excluded.city</code>).</p><p>Note that the constraint reference after <code>on conflict</code> (it is called <em>conflict target</em> — <code>id</code> in our case) is required. You can also specify a constraint name:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>alter</span> <span>table</span> <span>employees</span> <span>add</span> <span>constraint</span> <span>uniq_employees_name</span> <span>unique</span> (<span>name</span>);
</span></span><span><span>
</span></span><span><span><span>insert</span> <span>into</span> <span>employees</span>
</span></span><span><span>(<span>id</span>, <span>name</span>, <span>city</span>, <span>department</span>, <span>salary</span>)
</span></span><span><span><span>values</span>
</span></span><span><span>  <span>-- change Grace&#39;s name to Diane
</span></span></span><span><span><span></span>  (<span>22</span>, <span>&#39;Diane&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;it&#39;</span>, <span>90</span>)
</span></span><span><span><span>on</span> <span>conflict</span> <span>on</span> <span>constraint</span> <span>uniq_employees_name</span> <span>do</span> <span>nothing</span>;
</span></span></code></pre></div><codapi-snippet sandbox="postgres" editor="basic" template="emma-grace.pg.sql"></codapi-snippet><p>We only allow unique names, and &#34;Diane&#34; is already taken. Grace&#39;s name remains unchanged.</p><p>As you can see from the example above, PostgreSQL supports <code>do nothing</code> just like SQLite. It also supports the <code>where</code> clause:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>insert</span> <span>into</span> <span>employees</span>
</span></span><span><span>(<span>id</span>, <span>name</span>, <span>city</span>, <span>department</span>, <span>salary</span>)
</span></span><span><span><span>values</span>
</span></span><span><span>  (<span>21</span>, <span>&#39;Emma&#39;</span>, <span>&#39;London&#39;</span>, <span>&#39;it&#39;</span>, <span>95</span>),
</span></span><span><span>  (<span>22</span>, <span>&#39;Grace&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;it&#39;</span>, <span>105</span>)
</span></span><span><span><span>on</span> <span>conflict</span> (<span>id</span>) <span>do</span> <span>update</span> <span>set</span>
</span></span><span><span>  <span>salary</span> <span>=</span> <span>excluded</span>.<span>salary</span> <span>where</span> <span>excluded</span>.<span>salary</span> <span>&lt;</span> <span>100</span>;
</span></span></code></pre></div><codapi-snippet sandbox="postgres" editor="basic" template="emma-grace.pg.sql"></codapi-snippet><p>We only allow salaries under 100, so Emma gets updated but Grace does not.</p><p>Unlike SQLite, PostgreSQL does not allow multiple <code>on conflict</code> clauses:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>create</span> <span>unique</span> <span>index</span> <span>idx_employees_name</span> <span>on</span> <span>employees</span>(<span>name</span>);
</span></span><span><span>
</span></span><span><span><span>insert</span> <span>into</span> <span>employees</span>
</span></span><span><span>(<span>id</span>, <span>name</span>, <span>city</span>, <span>department</span>, <span>salary</span>)
</span></span><span><span><span>values</span>
</span></span><span><span>  (<span>21</span>, <span>&#39;Emma&#39;</span>, <span>&#39;London&#39;</span>, <span>&#39;it&#39;</span>, <span>95</span>),
</span></span><span><span>  (<span>22</span>, <span>&#39;Diane&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;it&#39;</span>, <span>90</span>)
</span></span><span><span><span>on</span> <span>conflict</span> (<span>id</span>) <span>do</span> <span>update</span> <span>set</span>
</span></span><span><span>  <span>city</span> <span>=</span> <span>excluded</span>.<span>city</span>,
</span></span><span><span>  <span>salary</span> <span>=</span> <span>excluded</span>.<span>salary</span>
</span></span><span><span><span>on</span> <span>conflict</span> (<span>name</span>) <span>do</span> <span>nothing</span>;
</span></span></code></pre></div><codapi-snippet sandbox="postgres" editor="basic" template="emma-grace.pg.sql"></codapi-snippet><p>This is an error: only one <code>on conflict</code> is allowed.</p><p>→ <a href="https://www.postgresql.org/docs/current/sql-insert.html#SQL-ON-CONFLICT">Documentation</a></p><p><code>insert...on conflict</code> is a fine way to do upserts on older PostgreSQL versions. For modern ones (15+) there is a better alternative ↓</p><h2 id="sql-standard-merge">SQL Standard: MERGE</h2><p>Now that we&#39;ve seen all the creative ways vendors have implemented upsert in their systems, let&#39;s look at the <em>standard</em> way — the <code>merge</code> statement:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>merge</span> <span>into</span> <span>employees</span>
</span></span><span><span><span>using</span> (
</span></span><span><span>  <span>values</span>
</span></span><span><span>  (<span>11</span>, <span>&#39;Diane&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;hr&#39;</span>, <span>70</span>),
</span></span><span><span>  (<span>21</span>, <span>&#39;Emma&#39;</span>, <span>&#39;London&#39;</span>, <span>&#39;it&#39;</span>, <span>95</span>),
</span></span><span><span>  (<span>25</span>, <span>&#39;Frank&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;it&#39;</span>, <span>120</span>),
</span></span><span><span>  (<span>33</span>, <span>&#39;Alice&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;sales&#39;</span>, <span>100</span>)
</span></span><span><span>) <span>as</span> <span>new</span> (<span>id</span>, <span>name</span>, <span>city</span>, <span>department</span>, <span>salary</span>)
</span></span><span><span><span>on</span> <span>employees</span>.<span>id</span> <span>=</span> <span>new</span>.<span>id</span>
</span></span><span><span><span>when</span> <span>matched</span> <span>then</span> <span>update</span> <span>set</span>
</span></span><span><span>  <span>city</span> <span>=</span> <span>new</span>.<span>city</span>,
</span></span><span><span>  <span>salary</span> <span>=</span> <span>new</span>.<span>salary</span>
</span></span><span><span><span>when</span> <span>not</span> <span>matched</span> <span>then</span> <span>insert</span>
</span></span><span><span>  <span>values</span> (<span>id</span>, <span>name</span>, <span>city</span>, <span>department</span>, <span>salary</span>);
</span></span></code></pre></div><codapi-snippet sandbox="postgres" editor="basic" template="sample.pg.sql"></codapi-snippet><p>Added Frank and Alice, updated Diane and Emma.</p><p>Here is what happened:</p><ul><li>We specified the merge source in the <code>using</code> clause (here we use the <code>values</code> as the source, but <code>using</code> also accepts tables, views and subqueries).</li><li>We gave the merge source an alias (<code>new</code>) for future reference.</li><li>We defined the match criteria between the merge source (our <code>new</code> values) and the merge target (the <code>employees</code> table) using the <code>on</code> clause (<code>employees.id = new.id</code>).</li><li>We set the action to take when the merge source and merge target <em>match</em> by the given criteria (update <code>city</code> and <code>salary</code> with new values).</li><li>We set the action to take when the merge source and merge target <em>don&#39;t match</em> (i.e., there are new records in the source, so we should insert them).</li></ul><p>Whew. That&#39;s a lot to process. But the <code>merge</code> statement can do much more. For example, you can change the inserted values:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>merge</span> <span>into</span> <span>employees</span>
</span></span><span><span><span>using</span> (
</span></span><span><span>  <span>values</span>
</span></span><span><span>  (<span>11</span>, <span>&#39;Diane&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;hr&#39;</span>, <span>70</span>),
</span></span><span><span>  (<span>21</span>, <span>&#39;Emma&#39;</span>, <span>&#39;London&#39;</span>, <span>&#39;it&#39;</span>, <span>95</span>),
</span></span><span><span>  (<span>25</span>, <span>&#39;Frank&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;it&#39;</span>, <span>120</span>),
</span></span><span><span>  (<span>33</span>, <span>&#39;Alice&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;sales&#39;</span>, <span>100</span>)
</span></span><span><span>) <span>as</span> <span>new</span> (<span>id</span>, <span>name</span>, <span>city</span>, <span>department</span>, <span>salary</span>)
</span></span><span><span><span>on</span> <span>employees</span>.<span>id</span> <span>=</span> <span>new</span>.<span>id</span>
</span></span><span><span><span>when</span> <span>matched</span> <span>then</span> <span>update</span> <span>set</span>
</span></span><span><span>  <span>city</span> <span>=</span> <span>new</span>.<span>city</span>,
</span></span><span><span>  <span>salary</span> <span>=</span> <span>new</span>.<span>salary</span>
</span></span><span><span><span>when</span> <span>not</span> <span>matched</span> <span>then</span> <span>insert</span>
</span></span><span><span>  <span>values</span> (<span>id</span>, <span>name</span> <span>||</span> <span>&#39; (new!)&#39;</span>, <span>city</span>, <span>department</span>, <span>salary</span>);
</span></span></code></pre></div><codapi-snippet sandbox="postgres" editor="basic" template="sample.pg.sql"></codapi-snippet><p>We still update Diane and Emma, but we also change Frank and Alice&#39;s names on insert.</p><p>Or even delete the matching records:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>merge</span> <span>into</span> <span>employees</span>
</span></span><span><span><span>using</span> (
</span></span><span><span>  <span>values</span>
</span></span><span><span>  (<span>11</span>, <span>&#39;Diane&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;hr&#39;</span>, <span>70</span>),
</span></span><span><span>  (<span>21</span>, <span>&#39;Emma&#39;</span>, <span>&#39;London&#39;</span>, <span>&#39;it&#39;</span>, <span>95</span>),
</span></span><span><span>  (<span>25</span>, <span>&#39;Frank&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;it&#39;</span>, <span>120</span>),
</span></span><span><span>  (<span>33</span>, <span>&#39;Alice&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;sales&#39;</span>, <span>100</span>)
</span></span><span><span>) <span>as</span> <span>new</span> (<span>id</span>, <span>name</span>, <span>city</span>, <span>department</span>, <span>salary</span>)
</span></span><span><span><span>on</span> <span>employees</span>.<span>id</span> <span>=</span> <span>new</span>.<span>id</span>
</span></span><span><span><span>when</span> <span>matched</span> <span>then</span> <span>delete</span>
</span></span><span><span><span>when</span> <span>not</span> <span>matched</span> <span>then</span> <span>insert</span>
</span></span><span><span>  <span>values</span> (<span>id</span>, <span>name</span>, <span>city</span>, <span>department</span>, <span>salary</span>);
</span></span></code></pre></div><codapi-snippet sandbox="postgres" editor="basic" template="sample.pg.sql"></codapi-snippet><p>Added Frank and Alice, deleted Diane and Emma.</p><p>Or ignore new records altogether by omitting the <code>when not matched</code>:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>merge</span> <span>into</span> <span>employees</span>
</span></span><span><span><span>using</span> (
</span></span><span><span>  <span>values</span>
</span></span><span><span>  (<span>11</span>, <span>&#39;Diane&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;hr&#39;</span>, <span>70</span>),
</span></span><span><span>  (<span>21</span>, <span>&#39;Emma&#39;</span>, <span>&#39;London&#39;</span>, <span>&#39;it&#39;</span>, <span>95</span>),
</span></span><span><span>  (<span>25</span>, <span>&#39;Frank&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;it&#39;</span>, <span>120</span>),
</span></span><span><span>  (<span>33</span>, <span>&#39;Alice&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;sales&#39;</span>, <span>100</span>)
</span></span><span><span>) <span>as</span> <span>new</span> (<span>id</span>, <span>name</span>, <span>city</span>, <span>department</span>, <span>salary</span>)
</span></span><span><span><span>on</span> <span>employees</span>.<span>id</span> <span>=</span> <span>new</span>.<span>id</span>
</span></span><span><span><span>when</span> <span>matched</span> <span>then</span> <span>update</span> <span>set</span>
</span></span><span><span>  <span>city</span> <span>=</span> <span>new</span>.<span>city</span>,
</span></span><span><span>  <span>salary</span> <span>=</span> <span>new</span>.<span>salary</span>;
</span></span></code></pre></div><codapi-snippet sandbox="postgres" editor="basic" template="sample.pg.sql"></codapi-snippet><p>Updated Diane and Emma, ignored Frank and Alice.</p><p>You can perform conditional inserts, updates and deletes using <code>when...and</code> clause:</p><div><pre tabindex="0"><code data-lang="sql"><span><span><span>merge</span> <span>into</span> <span>employees</span>
</span></span><span><span><span>using</span> (
</span></span><span><span>  <span>values</span>
</span></span><span><span>  (<span>21</span>, <span>&#39;Emma&#39;</span>, <span>&#39;London&#39;</span>, <span>&#39;it&#39;</span>, <span>95</span>),
</span></span><span><span>  (<span>22</span>, <span>&#39;Grace&#39;</span>, <span>&#39;Berlin&#39;</span>, <span>&#39;it&#39;</span>, <span>105</span>)
</span></span><span><span>) <span>as</span> <span>new</span> (<span>id</span>, <span>name</span>, <span>city</span>, <span>department</span>, <span>salary</span>)
</span></span><span><span><span>on</span> <span>employees</span>.<span>id</span> <span>=</span> <span>new</span>.<span>id</span>
</span></span><span><span><span>when</span> <span>matched</span> <span>and</span> <span>new</span>.<span>salary</span> <span>&lt;</span> <span>100</span> <span>then</span> <span>update</span> <span>set</span>
</span></span><span><span>  <span>city</span> <span>=</span> <span>new</span>.<span>city</span>,
</span></span><span><span>  <span>salary</span> <span>=</span> <span>new</span>.<span>salary</span>;
</span></span></code></pre></div><codapi-snippet sandbox="postgres" editor="basic" template="emma-grace.pg.sql"></codapi-snippet><p>We only allow salaries under 100, so Emma gets updated but Grace does not.</p><p><code>merge</code> is supported in PostgreSQL (15+), SQL Server (2008+) and Oracle (11+). Of course, each of them has its own quirks. For example, PostgreSQL adds the non-standard <code>do nothing</code> action, while SQL Server supports different <code>when not matched</code> actions depending on where the value is missing — in a source or target dataset.</p><p>→ Documentation:
<a href="https://modern-sql.com/caniuse/merge">Standard</a> •
<a href="https://www.postgresql.org/docs/current/sql-merge.html">PostgreSQL</a> •
<a href="https://learn.microsoft.com/en-us/sql/t-sql/statements/merge-transact-sql">SQL Server</a> •
<a href="https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/MERGE.html">Oracle</a></p><h2 id="other-database-engines">Other database engines</h2><p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/dml-syntax#merge_statement">BigQuery</a>, <a href="https://www.h2database.com/html/commands.html#merge_using">H2</a>, <a href="https://docs.snowflake.com/en/sql-reference/sql/merge">Snowflake</a>, <a href="https://www.ibm.com/docs/en/db2/11.5?topic=statements-merge">DB2</a> — all support <code>merge</code> (each to some extent).</p><p>MariaDB supports <a href="https://mariadb.com/kb/en/replace/"><code>replace</code></a> and <a href="https://mariadb.com/kb/en/insert-on-duplicate-key-update/"><code>on duplicate key update</code></a>, just like MySQL.</p><p>Clickhouse does not have upsert SQL statements, but it does provide a <a href="https://clickhouse.com/docs/en/guides/developer/deduplication#using-replacingmergetree-for-upserts">ReplacingMergeTree</a> table engine that automatically performs a replace-style upsert on insert.</p><p>Cockroachdb supports <a href="https://www.cockroachlabs.com/docs/v23.1/insert#on-conflict-clause"><code>insert...on conflict</code></a> (like PostgreSQL), but with an optional conflict target. It also provides an <a href="https://www.cockroachlabs.com/docs/v23.1/upsert"><code>upsert</code></a> statement (ta-da!) that works like an automatic <code>on conflict do update</code>.</p><p>DuckDB supports <a href="https://duckdb.org/docs/sql/statements/insert.html"><code>insert or replace</code></a> and <code>insert or ignore</code> (like SQLite) as well as <a href="https://duckdb.org/docs/sql/statements/insert.html#on-conflict-clause"><code>insert...on conflict</code></a> (also like SQLite), but without multiple clauses.</p><h2 id="summary">Summary</h2><p>We&#39;ve reviewed ways to do upserts in each of the major databases:</p><ul><li><code>replace</code> or <code>on duplicate key update</code> in MySQL (MariaDB).</li><li><code>insert or replace</code> and <code>on conflict do</code> in SQLite.</li><li><code>on conflict do</code> in older PostgreSQL versions.</li><li><code>merge</code> in modern PostgreSQL, SQL Server and Oracle.</li></ul><p>It&#39;s funny that (almost) no DBMS has actually named the statement <code>upsert</code>, despite the popularity of the name.</p><p>──</p><p>P.S. Interested in mastering advanced SQL? Check out my book — <a href="https://antonz.org/sql-window-functions-book">SQL Window Functions Explained</a></p><p><em><a href="https://antonz.org/subscribe/"><i></i> <strong>Subscribe</strong></a>
to keep up with new posts.</em></p></div></div></article></div></div></div>
  </body>
</html>
