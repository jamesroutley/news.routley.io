<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://scattered-thoughts.net/log/0032/">Original</a>
    <h1>0032: undroppable tombstones, forest fuzzer, manifest race, hash_log, zig coercions, zig pointer hops, zig object notation, domain knowledge, built from broken, database internals, papers</h1>
    
    <div id="readability-page-1" class="page"><article>
  <ul>
<li>at <a href="https://tigerbeetle.com/">tigerbeetle</a>
<ul>
<li>undroppable tombstones</li>
<li>forest fuzzer</li>
<li>manifest race</li>
<li>hash_log</li>
</ul>
</li>
<li>musing
<ul>
<li>zig coercions</li>
<li>zig pointer hops</li>
<li>zig object notation</li>
<li>domain knowledge</li>
</ul>
</li>
<li>reading
<ul>
<li>built from broken</li>
<li>database internals</li>
<li>papers...</li>
</ul>
</li>
</ul>
<p>I restarted my habit of reading a paper every morning and I&#39;m just lazily dumping all my notes into the end of each devlog. My reading queue is already running low, so I&#39;d love it if people sent me their favourite systems papers :)</p>
<h2 id="undroppable-tombstones">undroppable tombstones</h2>
<p>I noticed when writing up my notes last month that tombstones shouldn&#39;t have been able to accumulate anyway, because in that test there was only one level in the tree.</p>
<p>So I read the code that decides whether or not to drop tombstones and found that due to a <a href="https://github.com/tigerbeetledb/tigerbeetle/pull/373/files">one character thinko</a> it always returns false. I printed out the return value in the fuzzer to be sure, but it felt pretty fun to catch a bug just by reading.</p>
<p>I tried in <a href="https://github.com/tigerbeetledb/tigerbeetle/pull/396#issuecomment-1382566354">#396</a> to add some asserts to catch tombstones that make it to the bottom of the tree, but it&#39;s surprisingly hard to get right. The tree <em>is</em> allowed to have tombstones in the bottom level, if they were written there when it wasn&#39;t the bottom level and then later the tree shrank. I tried tracking the maximum size of the tree but preserving this across crashes and restarts was more effort than it was worth.</p>
<h2 id="forest-fuzzer">forest fuzzer</h2>
<p>DJ did some work last month to allow testing different configs. In particular, using smaller table sizes in fuzzers makes it much easier to exercise compaction and resizing logic across all the levels of tree.</p>
<p>The forest fuzzer immediately started crashing, but the surface issues were all bugs in the fuzzer itself.</p>
<p>The first was forgetting to prefetch accounts before modifying them (<a href="https://github.com/tigerbeetledb/tigerbeetle/pull/370/files#diff-b3d58cbc7044eb17a665c94405868876c74dd1a6a9e5a5b5b4e3dd6cafcd5a17R265-R266">#370</a>). Space is reserved in <code>prefetch</code> and then used in <code>put</code>, so without <code>prefetch</code> the forest complains that there isn&#39;t enough space available in <code>put</code>.</p>
<p>The second was mutating fields of the account that are not allowed to be mutated (<a href="https://github.com/tigerbeetledb/tigerbeetle/pull/391/files#diff-b3d58cbc7044eb17a665c94405868876c74dd1a6a9e5a5b5b4e3dd6cafcd5a17R362">#391</a>). The error for this one was less helpful. The in-memory buffers for the lsm have enough capacity allocated for all the ways they could be used by the accounting state machine. Since the state machine can&#39;t mutate some fields of accounts it doesn&#39;t allocate enough capacity for tombstones in the secondary indexes for those fields. But it took me a while when working backwards from the capacity error and double-checking the capacity calculations to realize what was going on. In (<a href="https://github.com/tigerbeetledb/tigerbeetle/pull/410">#410</a>) I added some extra asserts that would catch this bug every time, instead of only when enough unique keys are in the workload.</p>
<h2 id="manifest-race">manifest race</h2>
<p>With the fuzzer working again we found an actual bug (<a href="https://github.com/tigerbeetledb/tigerbeetle/issues/390">#390</a>). </p>
<p>Each tree has a manifest - a list of all the tables in that tree, what level each table is on and where it&#39;s index block is stored on disk. The manifests themselves are stored in memory for efficient lookups, but they also have to be written to disk for crash recovery. </p>
<p>The on-disk storage is just a log. Changes are appended at the head and the tail is lazily garbage collected. The garbage collector reads a block from the tail and checks each of the entries in that block against the in-memory manifest to check if that entry has been overwritten by a more recent entry. If so the entry is thrown away, otherwise it&#39;s added back to the head of the log.</p>
<p>Rather than each tree having it&#39;s own in-memory manifest, they all share a single hashtable. Which is fine because it&#39;s keyed by index block address and two trees can&#39;t be using the same index block address (picture a dark cloud ominously covering the sun as I say this).</p>
<p>The crash is happening during garbage collection. The garbage collector finds a entry and looks up the index block address in the in-memory manifest to see if this entry is the latest version, but finds that index block address isn&#39;t in the manifest at all.</p>
<pre><code><span>thread 11595 panic: attempt to use null value
</span><span>/home/jamie/tigerbeetle/src/vsr/superblock_manifest.zig:0:0: 0x3128e8 in vsr.superblock_manifest.Manifest.remove_table_extent (fuzz_lsm_forest)
</span></code></pre>
<p>(The function is called <code>remove_table_extent</code> but the garbage collector actually removes the value from the in-memory manifest iff it&#39;s the latest version. It&#39;s a weird api. But that&#39;s not really relevant to the story.)</p>
<p>The fuzzer runs in release mode so that it can check more seeds, so the first thing I do with a fuzzer crash is run the same seed in debug mode to get a proper stack trace. But in debug mode it doesn&#39;t crash. I test both release and debug a few more times just to verify that it isn&#39;t non-deterministic - it always crashes in release mode and never crashes in debug mode.</p>
<p>So this is going to suck.</p>
<p>I want to figure out where release and debug first diverge, so I enable logging in both and diff the logs. The first difference is really early on - line 1677 out of ~50m. Way earlier than the actual crash, so this might be two separate bugs.</p>
<p>Rather than jumping right into debugging I try to bisect the git history. This is kind of a pain because a) I have to backport all the fuzzer fixes above and b) changes to config or io scheduling change which seeds crash, so I have to run lots of seeds at each commit. </p>
<p>After a whole day I bisect it as far back as DJs config changes. Backporting those would be way too much work so I&#39;m stuck there. All I know is that the bug has existed for a while but wasn&#39;t caught until the improvements to fuzzer coverage, which is not super helpful.</p>
<p>So println debugging on the release build seems like the next best option. I spend a lot of time reading to code to learn all the things I explained above and then start printing out all the modifications to the in-memory manifest for index block address 28704 (the one that is missing at the time of the crash).</p>
<pre><code><span>...
</span><span>update(258985583951513099105654245986647289974, 28704, 29035, 37)
</span><span>update(258985583951513099105654245986647289974, 28704, 34187, 14)
</span><span>update(258985583951513099105654245986647289974, 28704, 34187, 18)
</span><span>remove(258985583951513099105654245986647289974, 28704, 29035, 37)
</span><span>update(43895868926173851389892452333004948983, 28704, 24175, 30)
</span><span>update(43895868926173851389892452333004948983, 28704, 24175, 44)
</span><span>update(43895868926173851389892452333004948983, 28704, 24175, 47)
</span><span>remove(43895868926173851389892452333004948983, 28704, 24175, 30)
</span><span>remove(43895868926173851389892452333004948983, 28704, 24175, 44)
</span><span>remove(43895868926173851389892452333004948983, 28704, 24175, 47)
</span><span>remove(258985583951513099105654245986647289974, 28704, 34187, 14)
</span></code></pre>
<p>The above is <code>operation(tree_hash, index_block_address, manifest_address, entry_index)</code>. If we group these by tree it&#39;s clearer what&#39;s happening:</p>
<pre><code><span>update(treeA, 28704, 24175, 30)
</span><span>update(treeA, 28704, 24175, 44)
</span><span>update(treeA, 28704, 24175, 47)
</span><span>remove(treeA, 28704, 24175, 30)
</span><span>remove(treeA, 28704, 24175, 44)
</span><span>remove(treeA, 28704, 24175, 47)
</span><span>
</span><span>update(treeB, 28704, 29035, 37)
</span><span>update(treeB, 28704, 34187, 14)
</span><span>update(treeB, 28704, 34187, 18)
</span><span>remove(treeB, 28704, 29035, 37)
</span><span>remove(treeB, 28704, 34187, 14)
</span></code></pre>
<p>For each tree you see some updates, later followed by removes for the same manifest_address/entry_index pairs as garbage collection catches up. But the original ordering is messed up:</p>
<ul>
<li>Tree B inserts 28704 into the manifest, uses it for a while and then releases it. </li>
<li>The grid garbage collects 28704 and reuses the address in tree A. </li>
<li>Tree A inserts 28704 into the manifest, uses it for a while and then releases it.</li>
<li>Tree A garbage collects the old log entry for 28704 and removes it from the manifest.</li>
<li>Tree B garbage collects the old log entry for 28704 and tries to remove it from the manifest, but it&#39;s already been removed.</li>
</ul>
<p>The problem is that garbage collection of the logs is very lazy, and can lag behind address reuse in the grid.</p>
<p>I came up with a couple of ways to fix this, but in the end the least invasive was to change the manifest key from <code>index_block_address</code> to <code>(tree_hash, index_block_address)</code> (in <a href="https://github.com/tigerbeetledb/tigerbeetle/pull/407">#407</a>). I&#39;m still not super happy about the whole flow here but it&#39;s not on the top of my list of things to refactor.</p>
<h2 id="hash-log">hash_log</h2>
<p>This still doesn&#39;t explain why the same seed doesn&#39;t crash in debug mode. The fuzzer is single-threaded, doesn&#39;t do any io and use fixed seeds for all random decisions. There are a few places in the code where we do different things depending on the build mode, but none of them are reachable from this test. So the most likely candidates are undefined behavior or miscompilation, neither of which I want to leave uninvestigated.</p>
<p>Tracking down the exact point where release and debug behavior diverges seems hard. I can&#39;t just compare coredumps because they&#39;ll have different pointers returned from allocation, and the compiler is allowed to change the order of memory writes as long as it isn&#39;t observable by the code itself.</p>
<p>So first I hope to just get lucky and find the bug by searching for likely candidates:</p>
<ul>
<li>I don&#39;t find any code that iterates over a hashtable (order could be non-deterministic due to random hash seed).</li>
<li>I don&#39;t find any code that compares or sorts anything containing pointers or functions (order could be non-deterministic due to virtual memory mappings from the os or aslr when loading code into memory)</li>
<li>The latency in test/storage is decided randomly using some floating point math. For a while I think that this differs between builds, but it turns out to be caused by different order of calls to the rng.</li>
<li>Pending reads/writes in test/storage are queued in a <code>std.PriorityQueue</code> instead of our own priority queue which backports some fixes from zig master. But fixing this does not change the scheduling.</li>
<li>The manifest log briefly exposes uninitialized grid blocks, but they doesn&#39;t seem to be read and hiding them does not change anything.</li>
</ul>
<p>So my hope-to-get-lucky search results in a bunch of <a href="https://github.com/tigerbeetledb/tigerbeetle/pull/401">miscellaneous improvements</a>, but does not fix my bug.</p>
<p>The only approach I have left is grinding. I&#39;ve already used logging to find an upper bound on the divergence point, so I try adding more logging to bisect the time dimension. </p>
<p>Doing this diffing by hand is kind of tedious and repetitive though, so after a few hours I decide to automate it. I wrote a tool called <code>hash_log</code> that allows emitting hashes anywhere in the code, and depending on the setting either write those hashes to a log, or asserts that they match the hashes in an existing log. So I record the hashes in release mode and check them in debug mode, or vice verse. This lets me crash both builds at the first point that the hashes diverge so I compare the state in gdb.</p>
<p>To begin with I emit hashes of every read/write start/completion, including the grid block and all the arguments. This gives me a really early divergence point in <code>grid.write_block</code> during compaction.</p>
<pre><code><span># release
</span><span>&gt;&gt;&gt; p zone
</span><span>$2 = grid
</span><span>&gt;&gt;&gt; p offset_in_zone
</span><span>$3 = 32768
</span><span>&gt;&gt;&gt; p buffer
</span><span>$1 = {
</span><span>  ptr = 0x7f2451bc4000 &#34;\266\035T\353Ai\301B9\222qa\225\314ک\005\356\bF\300\205\341\247\031F\&#34;\326\fJ\fb&#34;,
</span><span>  len = 4096
</span><span>}
</span><span>
</span><span># debug
</span><span>&gt;&gt;&gt; p zone
</span><span>$2 = grid
</span><span>&gt;&gt;&gt; p offset_in_zone
</span><span>$3 = 32768
</span><span>&gt;&gt;&gt; p buffer
</span><span>$1 = {
</span><span>  ptr = 0x7f9ce5101000 &#34;?\267C\003|\211{\333&amp;\032c\301\204$\340\216\204\260b\351Hy\341ӵ\337\351\255A7\304l&#34;,
</span><span>  len = 4096
</span><span>}
</span></code></pre>
<p>Both are writing to the same address, but the data they are writing differs.</p>
<p>I print out all the compaction and merge iterator state and both match exactly. So the compacted data in the buffer should match.</p>
<p>Printing out the block type tells us that this is a bloom filter block. According to the docs the layout of the buffer should look like this:</p>
<pre><code><span>/// Filter block schema:
</span><span>/// │ vsr.Header │ operation=BlockType.filter
</span><span>/// │ […]u8      │ A split-block Bloom filter, &#34;containing&#34; every key from as many as
</span><span>/// │            │   `filter_data_block_count_max` data blocks.
</span></code></pre>
<p>After much googling I manage to get the cast syntax correct in gdb and print out the headers:</p>
<pre><code><span># release
</span><span>&gt;&gt;&gt; p (struct &#39;vsr.Header&#39;) *buffer.ptr
</span><span>$17 = {
</span><span>  checksum = 225775601449524079601983905606000713142,
</span><span>  checksum_body = 130328153064544020489453123034442952197,
</span><span>  parent = 0,
</span><span>  client = 0,
</span><span>  context = 0,
</span><span>  request = 0,
</span><span>  cluster = 32,
</span><span>  epoch = 0,
</span><span>  view = 0,
</span><span>  op = 9,
</span><span>  commit = 0,
</span><span>  timestamp = 0,
</span><span>  size = 4096,
</span><span>  replica = 0 &#39;\000&#39;,
</span><span>  command = block,
</span><span>  operation = (root | register),
</span><span>  version = 0 &#39;\000&#39;
</span><span>}
</span><span>
</span><span># debug
</span><span>&gt;&gt;&gt; p (struct &#39;vsr.Header&#39;) *buffer.ptr
</span><span>$6 = {
</span><span>  checksum = 189914190582483452734140919832484493119,
</span><span>  checksum_body = 144575434465226147614775280795209871492,
</span><span>  parent = 0,
</span><span>  client = 0,
</span><span>  context = 0,
</span><span>  request = 0,
</span><span>  cluster = 32,
</span><span>  epoch = 0,
</span><span>  view = 0,
</span><span>  op = 9,
</span><span>  commit = 0,
</span><span>  timestamp = 0,
</span><span>  size = 4096,
</span><span>  replica = 0 &#39;\000&#39;,
</span><span>  command = block,
</span><span>  operation = (root | register),
</span><span>  version = 0 &#39;\000&#39;
</span><span>}
</span></code></pre>
<p>Differing checksums, but the rest of the header matches. The checksums are set right before writing and I don&#39;t see how that code could be wrong, so the problem is probably the data itself.</p>
<pre><code><span># release
</span><span>&gt;&gt;&gt; p (char [1024]) *(buffer.ptr + sizeof(struct &#39;vsr.Header&#39;))
</span><span>$19 = &#39;\252&#39; &lt;repeats 15 times&gt;, &#34;\256\252\256\252\252\252\252\252\252\252\252\252\272\252\252\252\252\252\252\256&#34;, &#39;\252&#39; &lt;repeats 11 times&gt;, &#34;ꪪ\252\252\252\252\256&#34;, &#39;\252&#39; &lt;repeats 47 times&gt;, &#34;\272\252\252\252\252\252\252\253\252\252\252\252\253\252\252\272\252\252\252\252\252\252\272\252\252\252\256&#34;, &#39;\252&#39; &lt;repeats 420 times&gt;...
</span><span>
</span><span># debug
</span><span>&gt;&gt;&gt; p (char [1024]) *(buffer.ptr + sizeof(struct &#39;vsr.Header&#39;))
</span><span>$7 = &#34; \000\000\000\200\000\000\000\000\002\000\000\000\000\000\004\000\004\000\000\000\000 \000\000\000\000\020\000\000\002\000 \000\004\000 \000\200\000\202\000\000\000\000\000@\002\240\000\000\000\000\004\000\200\000\002\b\000\000\000\202&#34;, &#39;\000&#39; &lt;repeats 34 times&gt;, &#34;\b\000\000\000\020\000\000\000\000\000\002\001\000\000\000\000\001\000\000\020\000\000\000\000\000\000\020\000\000\000\004&#34;, &#39;\000&#39; &lt;repeats 417 times&gt;...
</span></code></pre>
<p>The debug data is what I expect from a low-occupancy bloom filter - mostly zeros with some bits set. The release data looks like junk.</p>
<p>So I look at the code that creates these bloom filter blocks and I can see where it sets the bits, but not where it initializes the block to 0.</p>
<p>I did recently make the grid initialize blocks before handing them to writers, but only during tests.</p>
<pre data-lang="zig"><code data-lang="zig"><span>if </span><span>(constants.verify) {
</span><span>    std.mem.</span><span>set</span><span>(u8</span><span>,</span><span> completed_write.block</span><span>.*</span><span>, </span><span>undefined</span><span>)</span><span>;
</span><span>}
</span></code></pre>
<p>Usually in debug and release-safe builds setting a variable to undefined writes <code>0xcc</code> to all the bytes of that variable, which is rarely a valid value of anything and leads to crashes quickly if you try to use an undefined value. But it seems like my usage here with <code>mem.set</code> gets optimized out in release builds. Replacing <code>undefined</code> with <code>0</code> immediately fixes the divergence.</p>
<p>So the bug was:</p>
<ul>
<li>In release mode, the grid does not initialize blocks before handing them to writers.</li>
<li>For most block types we overwrite the entire block, but for filter blocks we weren&#39;t initializing the filter or writing padding afterwards.</li>
<li>This meant that filter blocks in release mode contained too many set bits, leading to more false positives, which changes the number of reads required in tree lookups, which disturbs all the downstream io scheduling.</li>
</ul>
<p>This is a dangerous and hard-to-catch bug, so rather than fix just the filters I decided to systematically zero-initialize all blocks on init and at every point of reuse, even in production builds. This costs a lot of memory bandwidth in a zero-copy system, but luckily we&#39;re still io-bound at the moment so there wasn&#39;t a noticeable perf impact. If I ever have to undo this I&#39;ll probably replace the zero-init with some kind of type wrapper that forces overwriting the entire block before allowing reading from the block.</p>
<p>In <a href="https://github.com/tigerbeetledb/tigerbeetle/pull/412">#412</a> I also added a hash_log test of release vs debug to CI, to catch any similar bugs in future, and added a lot more state asserts to compaction to double-check that it wasn&#39;t ever reusing blocks without going through the grid&#39;s zero-init.</p>
<p>I&#39;m pleasantly surprised by how well the combination of hash_log and gdb worked out. I expected this bug to be a lot harder to solve.</p>
<h2 id="zig-coercions">zig coercions</h2>
<p>Zig has lots of implicit coercions, especially from anonymous literals to named types. Eg in the following code we coerce from the anonymous literal <code>.foo</code> to the <code>FooBar</code> type.</p>
<pre data-lang="zig"><code data-lang="zig"><span>fn </span><span>foo_bar</span><span>(</span><span>b</span><span>: </span><span>bool</span><span>) </span><span>FooBar </span><span>{
</span><span>    </span><span>if </span><span>(b)
</span><span>        </span><span>return</span><span> .foo
</span><span>    </span><span>else
</span><span>        </span><span>return</span><span> .{ .bar </span><span>= </span><span>0 </span><span>}</span><span>;
</span><span>}
</span></code></pre>
<p>But what if we changed the return type of <code>foo_bar</code> to <code>!FooBar</code> (either a <code>FooBar</code> or an error). We can coerce <code>.foo</code> to <code>FooBar</code> and <code>FooBar</code> to <code>!FooBar</code>, but these coercions can&#39;t be chained.</p>
<pre data-lang="zig"><code data-lang="zig"><span>.</span><span>/</span><span>test</span><span>.zig</span><span>:</span><span>7</span><span>:</span><span>39</span><span>: </span><span>error</span><span>: type </span><span>&#39;@typeInfo(@typeInfo(@TypeOf(foo_bar)).Fn.return_type.?).ErrorUnion.error_set!?FooBar&#39;</span><span> does not support </span><span>struct</span><span> initialization </span><span>syntax
</span><span>        </span><span>return</span><span> .{ .bar </span><span>= </span><span>0 </span><span>}</span><span>;
</span><span>                  </span><span>^
</span></code></pre>
<p>To make this compile in zig 0.9 we&#39;d have to switch to the fully explicit syntax.</p>
<pre><code><span>fn foo_bar(b: bool) FooBar {
</span><span>    if (b)
</span><span>        return FooBar{ .foo = {} }
</span><span>    else
</span><span>        return FooBar{ .bar = 0 };
</span><span>}
</span></code></pre>
<p>A ton of these coercion papercuts were fixed in zig master in the last few weeks (<a href="https://github.com/ziglang/zig/pull/10925/files#diff-e88bfbf758018704fbee1f67030cab3ba987e51e7c1516fe2cbf5bccf0dbfbf5R1203">eg</a>).</p>
<h2 id="zig-pointer-hops">zig pointer hops</h2>
<p>If you see <code>a.b</code> in zig, the equivalent in c could be either <code>a.b</code> or <code>a-&gt;b</code>.</p>
<p>For high-performance code I&#39;m finding that I prefer the c notation. When I see <code>a.b.c.d</code> in zig, I don&#39;t know if that&#39;s 1 addition (&lt;1ns) or 3 cache misses (300ns?).</p>
<h2 id="zig-object-notation">zig object notation</h2>
<p>In <a href="https://github.com/ziglang/zig/issues/14290">#14390</a> the zig devs decided to use a subset of zig syntax as notation for config files.</p>
<p>This is the kind of brain-saving notation I was talking about in <a href="https://www.scattered-thoughts.net/writing/the-shape-of-data">the shape of data</a>. When you&#39;re editing Zig Object Notation you can use the same editor mode, same shortcuts, same string escaping, same number notations etc as zig. They might also support reading it at comptime using <code>@import(&#34;data.zon&#34;)</code>, in which case working with the config data will feel exactly like working with native structs and enums - no need to learn a separate api.</p>
<h2 id="domain-knowledge">domain knowledge</h2>
<p>This has been on my mind a lot lately.</p>
<p><a href="https://mastodon.social/@danluu/109641478157726177">https://mastodon.social/@danluu/109641478157726177</a></p>
<blockquote>
<p>...having a respect for domain knowledge, domain complexity, meticulously looking at data, etc., is a much more reliable way to find wins as an outsider than being super smart and reasoning from little to no knowledge.</p>
</blockquote>
<h2 id="built-from-broken"><a href="https://www.goodreads.com/book/show/59121046-built-from-broken">built from broken</a></h2>
<p>Many people start suffering from joint pain in their middle age and are told it&#39;s due to ageing or just general wear and tear.</p>
<p>The author points out that:</p>
<ul>
<li>Joint injuries are anti-correlated with exercise volume in the general population.</li>
<li>In atheletes, injuries are strongly predicted by the ratio of chronic workload (eg last 4 weeks) to acute workload (eg last week). </li>
<li>Non-industrialized populations (eg <a href="https://en.wikipedia.org/wiki/Hadza_people">Hadza</a>) don&#39;t suffer from degenerative joint injuries in middle age despite spending <a href="http://raichlen.arizona.edu/DavePDF/RaichlenEtAl2017.pdf">many hours per day</a> on their feet as late as 80yo.</li>
<li>In healthy animals, tendons are much stronger than muscles and so tendon injuries are very rare.</li>
</ul>
<p>The understanding of tendinopathy has also changed in the last decade or so:</p>
<ul>
<li>While muscles get stronger from a wide range of workloads, tendons only respond well to high, repetitive, long-duration loads.</li>
<li>The <a href="https://en.wikipedia.org/wiki/Supercompensation">supercompensation curve</a> for muscles peaks at 1-2 days, but for tendons peaks might be as long as 3-4 days.</li>
<li>When tendons repair, the collagen fibers measure mechanical stress to know which way to align. No stress = poorly repaired tendons.</li>
<li>Synovial fluid soaks into surrounding tissues over time and is forced back into the joint my mechanical stress. No stress = unlubricated joints.</li>
<li>Continually overloading tendons leads to degenerative tendinopathy. Cells die and holes form.</li>
</ul>
<p>This suggests a different picture than &#39;wear and tear&#39;. Combining a mostly sedentary lifestyle with a few weekly bouts of high-intensity exercise leads to long-term tendon degeneration. Eventually (ie in your 30s and 40s) tendons are weaker than muscles and start to tear. </p>
<p>The author recommends:</p>
<ul>
<li>Don&#39;t go more than an hour during the day without moving and stretching.</li>
<li>Aim for at minimum a few hours of low intensity movement (eg walking) per day.</li>
<li>Use strength and mobility exercises to correct postural problems caused by too much sitting.</li>
<li>Use <a href="https://www.physio-pedia.com/Tendinopathy_Rehabilitation">heavy slow resistance training</a> to build tendon strength.</li>
<li>Use high-rep endurance training to prevent injuries due to postural collapse when exhausted.</li>
</ul>
<p>I couldn&#39;t find citations for all of the claims but as far as I can tell the actually recommendations are very much in line with the current consensus in sports science. </p>
<p>There&#39;s a set of workout plans at the end of the book whic we&#39;ve been following for a few weeks. We also gave away our sofa, chairs and dining table in favor of a large foam mat and (eventually) some low folding tables.</p>
<p>It&#39;s too early to know how well the strength exercises will work, but just eliminating chairs for a month has already lead to a surprising reduction in knee and shoulder pain and a noticable increase in hip flexion. </p>
<h2 id="database-internals"><a href="https://www.databass.dev/">database internals</a></h2>
<p>I finally finished.</p>
<p>It feels more useful as a survey rather than a textbook. Whenever I hit a topic I didn&#39;t know about, I didn&#39;t feel like the chapter actually helped me understand it. But having a rough map of research and options is useful for starting a reading list.</p>
<h2 id="viewstamped-replication-revisited"><a href="https://pmg.csail.mit.edu/papers/vr-revisited.pdf">Viewstamped Replication Revisited</a></h2>
<p>For such a short paper this was a very long read. </p>
<p>Papers about consensus algorithms are traditionally impractical and full of bugs. This paper is better than most. I&#39;ve been told of two bugs - one in replica recovery and client recovery (unfortunately no citations for either). But the core algorithms have stood up to a lot of fuzzing so far.</p>
<p>Normal processing is basically 2PC (assuming that replicas are processing log entries only after commit) but the leader can reply to the client after the 1st phase.</p>
<p>Dueling leaders are avoided in a neat way. The leader is determined by <code>view_number % replica_count</code>. If two replicas on the same view both initiate a view change they will agree who the new leader is. If two replicas on diferent views both initiate a view change, the later view will win. On the downside, there is no guarantee that the new leader is up, so we may have to keep initiating view changes until the number increments to a working node.</p>
<p>The replica recovery process requires transferring either the state or the logs. There is a throwaway mention that this optimized by recovering from disk or via out-of-band backups if the state is too large. The recovery process as described also can&#39;t handle a whole-cluster shutdown. Handling both of these turns out to be very subtle in practice, especially in the presence of disk errors (<a href="https://github.com/tigerbeetledb/tigerbeetle/pull/426">eg</a>). </p>
<p>Reconfiguration is handled by a special log entry that, when executed, switches to the new configuration. There is some debate within tigerbeetle whether this is the best solution, most of which I haven&#39;t read yet.</p>
<h2 id="a-generalised-solution-to-distributed-consensus"><a href="https://arxiv.org/abs/1902.06776">A Generalised Solution to Distributed Consensus</a></h2>
<p>Recasts consensus as an append-only algorithm summarized by a lattice. The main contribution here is actually allowing the acceptable quorums to vary per round to produce various new and existing variations of paxos.</p>
<p>The lattice part seems under-used. Suggests some ideas that I&#39;ll explore in the next few months.</p>
<h2 id="dissecting-designing-and-optimizing-lsm-based-data-stores"><a href="https://www.youtube.com/watch?v=Al3krW4Sh3Q">Dissecting, Designing, and Optimizing LSM-based Data Stores</a></h2>
<p>Very thorough introduction. Too dense to summarize.</p>
<h2 id="constructing-and-analyzing-the-lsm-compaction-design-space"><a href="https://arxiv.org/pdf/2202.04522.pdf">Constructing and Analyzing the LSM Compaction Design Space</a></h2>
<p>Breaks compaction policies down on 4 independent axes. Shows that these choices hugely impact throughput and latency, and that there isn&#39;t a single best choice across all workloads.</p>
<p>Tiering has particularly poor tail latency.</p>
<h2 id="silk-preventing-latency-spikes-in-log-structured-merge-key-value-stores"><a href="https://www.usenix.org/conference/atc19/presentation/balmau">SILK: Preventing Latency Spikes in Log-Structured Merge Key-Value Stores</a></h2>
<p>Demonstrates that lsms have high tail latency when memory buffers fill up and the flush gets queued behind other compaction work.</p>
<p>Prioritizing flushes and level 0 compactions in the io scheduler massively reduces tail latency and increases how long they can survive workload spikes without producing latency spikes.</p>
<h2 id="don-t-stack-your-log-on-my-log"><a href="https://www.usenix.org/system/files/conference/inflow14/inflow14-yang.pdf">Don&#39;t stack your Log on my Log</a></h2>
<p>Many databases are log-structured. Many filesystems are log-structured. SSDs internally are log-structured (to hide the fact that they can&#39;t erase individual blocks). These logs interact poorly. </p>
<p>Garbage in a higher log still looks like valid data to a lower log, so eg your ssd garbage collection might waste time moving data that your filesystem is waiting to throw away.</p>
<p>Garbage collection requires some space to be reserved for moving. If each layer is reserving eg 50% overhead then the total overhead is 238% (1.5 ^ 3 = 3.375).</p>
<p>If the block sizes for two logs don&#39;t match this leads to fragmentation in the lower log, causing space amplification and write amplification.</p>
<p>The desired benefit of log-structured systems is sequential writes. But if the level below is also log-structured it might scatter those writes into available open blocks.</p>
<p>Apart from matching the block size there isn&#39;t much we can do as database developers until richer device interfaces appear - the core problem is that ssds are pretending to be 4kb block devices for backwards compatibility. But getting consensus on new standards will take a long time.</p>
<h2 id="an-analysis-of-data-corruption-in-the-storage-stack-and-an-analysis-of-latent-sector-errors-in-disk-drives"><a href="https://www.cs.toronto.edu/%7Ebianca/papers/fast08.pdf">An Analysis of Data Corruption in the Storage Stack</a> and <a href="https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=32d23ce43877aa8cd385a8e01f366329dd015a5c">An Analysis of Latent Sector Errors in Disk Drives</a></h2>
<p>Two studies of disk errors in a 1.5m disk deployment. These are disks that are inspected and tested before deployment, so presumably better than average.</p>
<p>Checksum mismatches affected 0.042% of enterprise disks per year. Latent sector errors affected 1.4%.</p>
<p>Errors can be permanent or transient.</p>
<p>Errors show high temporal and spatial locality. This implies that when storing multiple copies of an important data-structure, the writes should be spread out in space and time to avoid all being eaten by the same error.</p>
<blockquote>
<p>We are aware of actual cases when the disk firmware replied successfully to a write that was never written to stable media.</p>
</blockquote>
<p>These are studies of non-ssd, non-nvme disks. I have some more recent studies queued up.</p>
<h2 id="redundancy-does-not-imply-fault-tolerance"><a href="https://www.usenix.org/system/files/conference/fast17/fast17-ganesan.pdf">Redundancy Does Not Imply Fault Tolerance</a></h2>
<p>Distributed data systems store many redundant copies of data. So if there is a fault on one drive, the system should be able to recover the data from other nodes. Right?</p>
<p>Right?</p>
<p>The authors test many systems and find that in most of them a single disk error in the right place can cause data loss or whole-cluster crashes.</p>
<p>Redis doesn&#39;t checksum data at all. If there is an error on the leader it will be replicated to followers rather than repaired. Since corruption in metadata can lead to crashes, replicated corruption can cause all replicas to crash.</p>
<p>ZooKeeper detects most corruptions and responds by crashing and repairing from the new leader. But some corruptions can cause a partial crash in the leader - the cluster stays up but never accepts new writes.</p>
<p>Cassandra only detects corruptions if compression is enabled. Corrupted data can be replicated to other nodes. Corruption can cause a variety of crashes and silent errors.</p>
<p>Kafka leaders incorrectly truncate corrupted logs. Their followers try to do the same, but hit an assertion and die.</p>
<p>RethinkDB sometimes silently returns corrupted data and will never recover it.</p>
<p>MongoDB detects corruption and crashes but doesn&#39;t always attempt to repair. In one weird edge case it returns incorrect query results.</p>
<p>LogCabin detects corruption, crashes and repairs from the new leader.</p>
<p>CockroachDB mostly detects corruption and crashes, but doesn&#39;t attempt to repair. But sometimes corruptions cause data loss, incorrect query results, whole-cluster crashes etc. &#39;Overall, we found that CockroachDB has many problems in error handling&#39;.</p>
<p>The lesson: you have to <a href="https://github.com/tigerbeetledb/tigerbeetle/blob/00c413e007e368f7a52e36fcd5cb0d402b977563/src/testing/storage.zig#L68-L76">test disk faults</a>. You will not get it right by just sprinkling some checksums and hoping for the best.</p>
<h2 id="protocol-aware-recovery-for-consensus-based-storage"><a href="https://www.usenix.org/system/files/conference/fast18/fast18-alagappan.pdf">Protocol-Aware Recovery for Consensus-Based Storage</a></h2>
<p>A nice counterpart to the above. Demonstrates how to write a replicated state machine which recover from disk errors gracefully.</p>
<p>Separates persistent state into:</p>
<ul>
<li>Log (operations for state machine)</li>
<li>Snapshots (of state machine state)</li>
<li>Metainfo (data unique to this node)</li>
</ul>
<p>Errors in each are handled differently:</p>
<ul>
<li>Metainfo - small enough to just store multiple copies on the node.</li>
<li>Snapshots - store hashes elsewhere, repair corruption by asking other nodes.</li>
<li>Logs - store small entries that are checksummed and also point to full entries elsewhere.</li>
</ul>
<p>Errors in the log are tricky. A mismatched checksum could mean that the entry was corrupted, or that the node crashed while writing it. These two case can be distinguished because the small entries fit in a single block (no torn writes). </p>
<p>Corrupted entries are trickier yet. If the entry was committed, we must recover it. But this can be slow - quorum intersection guarantees that at least one node has the entry, but that node might be us and we corrupted it! If the entry was not commited, we would prefer to discard it. So there are three cases:</p>
<ul>
<li>We hear from one node that has the uncorrupted entry -&gt; repair.</li>
<li>We hear from a quorum that have not seen that entry, not even corrupted -&gt; discard.</li>
<li>We hear from all nodes and neither of the above is satisfied -&gt; cluster down.</li>
</ul>
<p>Snapshots are synchronized in a similar way to VSR reconfiguration. Old snapshot chunks are eventually garbage-collected, so in the worse case recovery requires transferring an entire snapshot.</p>
<p>The algorithm was tested with both fuzzing and several model-checker implementations.</p>
<h2 id="simple-testing-can-prevent-most-critical-failures"><a href="https://www.usenix.org/system/files/conference/osdi14/osdi14-paper-yuan.pdf">Simple Testing Can Prevent Most Critical Failures</a></h2>
<p>Sampled 198 failures from Cassandra, HBaase, HDFS, MapReduce and Redis. Classified 48 of them as catastrophic. Of those 48:</p>
<ul>
<li>92% were caused by incorrect error-handling</li>
<li>58% would have been caught by full statement coverage</li>
<li>35% were caused by error handlers that did nothing, aborted the entire process or contained comments like &#39;TODO&#39; or &#39;FIXME&#34;</li>
</ul>
<p>Also 43% could be reproduced on one node, 86% on two nodes and 98% on three nodes. 74% were deterministic.</p>
<p>I think much of this can be explained by the fact that developers are typically trained on ephemeral, mostly stateless, single threaded systems which may crash in response to external faults. Moving to long-lived, stateful, distributed systems which are expected to tolerate faults requires very different techniques. But these are becoming more widely known - I expect that an analysis of bugs for eg foundationdb would not find the same pattern.</p>
<h2 id="xft-practical-fault-tolerance-beyond-crashes"><a href="https://www.usenix.org/system/files/conference/osdi16/osdi16-liu.pdf">XFT: Practical Fault Tolerance Beyond Crashes</a></h2>
<p>Crash Fault Tolerant systems assume that disks, memory and the network never corrupt data. Byzantine Fault Tolerant systems handle data corruption but also arbitrary adversarial control of the network, and as a result are too expensive to operate. </p>
<p>Cross Fault Tolerance requires safety and liveness so long as a quorum of nodes are non-byzantine and synchronous. Strictly stronger than CFT. Neither weaker nor stronger than BFT.</p>
<p>Their XFT Paxos implementation has the each member of the quorum independently calculate the new log head during view change, rather than trusting the leader.</p>
<p>They don&#39;t mention fuzzing or model-checking, so I assume it&#39;s incorrect.</p>
<h2 id="practical-hardening-of-crash-tolerant-systems"><a href="https://www.usenix.org/system/files/conference/atc12/atc12-final190.pdf">Practical Hardening of Crash-Tolerant Systems</a></h2>
<p>Data corruption in the control plane can be very dangerous - often propagated instead of detected.</p>
<p>Mentions that ECC errors are higher than previously expected, but from a brief read their citations (<a href="https://storage.googleapis.com/pub-tools-public-publication-data/pdf/35162.pdf">1</a>, <a href="https://www.usenix.org/legacy/event/atc10/tech/full_papers/Li.pdf">2</a>) suggest that these errors are almost always detected and so don&#39;t contribute to non-crash failures.</p>
<p>Their wrapper library protects against memory errors by storing two copies of all in-memory data, executing every operation at least twice and inserting additional checks of control-flow integrity. This seems wildly expensive and also wouldn&#39;t protect against most of the example failures they use as motivation, which are largely operator error and disk failures.</p>
<h2 id="can-applications-recover-from-fsync-failures"><a href="https://www.usenix.org/system/files/atc20-rebello.pdf">Can Applications Recover from fsync Failures?</a></h2>
<p>TLDR no.</p>
<p>Most filesystems respond to fsync failures by marking dirty pages in the os cache as clean, even though they may not have been written to disk.</p>
<p>Filesystem behavior differs. Depending on the filesystem:</p>
<ul>
<li>The fsync call which raises an error might not be the one that failed (ext4 in data mode).</li>
<li>The data you wrote may be thrown away or may persist in the cache.</li>
<li>Files may be left with holes, which may or may not be detectable by fsck.</li>
</ul>
<p>Naturally, none of the databases tested can handle this menagarie. Redis, ever my favorite, doesn&#39;t even check the fsync return code.</p>
<p>Crashing and restarting is not a sufficient fix because on restart you&#39;re still reading from the cache, which may not reflect the actual contents of the disk. May be sufficient if combined with using direct io for everything, on top of a filesystem that handles errors well.</p>
<p>Given the choice, btrfs is the most well-behaved of the filesystems tested. Ext4 in data mode should be avoided. </p>
<p>Published in 2020, so details may have changed since.</p>
<h2 id="the-case-for-determinism-in-database-systems"><a href="https://www.cs.umd.edu/%7Eabadi/papers/determinism-vldb10.pdf">The Case for Determinism in Database Systems</a></h2>
<p>Typically in a replicated database, the leader executes a transaction and ships the resulting changes to the database to the followers. These changes can be significantly larger than the transaction itself. </p>
<p>If your transactions were deterministic then you could just ship the transaction itself to the followers and have them all execute it independently. This is easy if you just single-thread everything, but then you lose the benefits of concurrent execution (eg tolerating long-running transactions without blocking the whole database).</p>
<p>The authors propose a scheme for concurrent execution that is deterministic - every node will commit transactions in the same order.</p>
<p>The benchmarks compare against their own implementation of 2pc and there is no single-threaded baseline.</p>
<h2 id="evolution-of-financial-exchange-architectures"><a href="https://www.youtube.com/watch?v=qDhTjE0XmkE">Evolution of Financial Exchange Architectures</a></h2>
<p>New architecture - deterministic state machine, replicated by some consensus algorithm. </p>
<p>Tuned for low p100 latency and high throughput. Custom data-structures. Binary codecs, readable in place, zero-copy. </p>
<p>Spectre and meltdown mitigations make syscalls, page faults and context switches much more expensive. NVME SSDs and io_uring help. Other new hardware improves latency but not bandwidth, so need much more batching and concurrency.</p>
<h2 id="how-i-learned-to-stop-worrying-and-trust-the-database"><a href="https://www.youtube.com/watch?v=OJb8A6h9jQQ">How I Learned to Stop Worrying and Trust the Database</a></h2>
<p>Testing FoundationDB. </p>
<p>Deterministic code. No threading. Network and disk can be mocked. Fuzzer schedules network/disk from rng with fixed seed. So any crashing seed can be reproduced on any developers machine.</p>
<p>Good for safety bugs. Hard to catch performance or availability bugs this way - rely on chaos testing instead.</p>
<p>See also <a href="https://transactional.blog/simulation/buggify">buggify</a> - bias fuzzing towards the scary part of the state space by occasionally throwing away safety margins, injecting recoverable errors, adding extra latency, randomizing config etc.</p>
<h2 id="kangaroo-theory-and-practice-of-caching-billions-of-tiny-objects-on-flash"><a href="https://dl.acm.org/doi/full/10.1145/3542928">Kangaroo: Theory and Practice of Caching Billions of Tiny Objects on Flash</a></h2>
<p>Facebook wants to cache lots of small objects (100s-1000s bytes) on flash because it&#39;s much cheaper than dram.</p>
<p>Bitcask-style logs use too much dram for the index. Set-associative caches have too high write amplification.</p>
<p>Put a small log in front of a large set-associative cache to act as a write buffer.</p>
<p>On evicting from the log, evict all keys that match the same set and write them all at once. If there aren&#39;t enough keys to make it worth writing to the set, either reinsert into the log or just throw the key away.</p>
<p>Use a clock cache within each set to avoid having to store eviction metadata in dram.</p>
<p>The log itself is segmented to amortize pointer size. The dram index for the log exploits deliberate hash collisions to efficiently retrieve all keys of the same set.</p>
<p>The result has strictly better miss ratio and write amplification than existing designs, especially when the ratio of dram to flash is low - facebooks hardware is moving in this direction.</p>

</article></div>
  </body>
</html>
