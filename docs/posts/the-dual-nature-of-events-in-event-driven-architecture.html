<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.reactivesystems.eu/2024/10/31/the-dual-nature-of-events-in-eda.html">Original</a>
    <h1>The Dual Nature of Events in Event-Driven Architecture</h1>
    
    <div id="readability-page-1" class="page"><section>
                        <p><em>Given that events play such a central role in event-driven architecture, there’s an astonishing lack of agreement on what should be contained in an event. This may be rooted in the fact that, depending on your perspective, events fulfill different purposes.</em></p>

<p>In a system that follows event-driven architecture in its contemporary style, microservices collaborate by emitting and subscribing to events.     </p>

<p>In these event-driven systems, events that travel between services have a dual role: They <strong><em>trigger actions</em></strong> and <strong><em>carry data</em></strong>.</p>

<p>In principle events emitted from a service can be anywhere on the spectrum shown in the picture below.</p>

<figure>
  <img height="250" src="https://www.reactivesystems.eu/images/post0080/spectrum.svg" alt="Events are usually both trigger and data carrier - varying in the amount of data included."/>
  <figcaption><i>Events are usually both trigger and carrier of data - varying in the amount of data included.</i></figcaption>
</figure>

<p>The left end would be “pure trigger”, where all the information is contained in the event type alone. On the right end of the spectrum, all properties of the changed entity/aggregate would be included in the event.</p>

<p><em>By the way, not only is there no consensus on how much data should usually be included in an event - it’s not even clear what to call the data-heavy events on the right end of the spectrum. Having been taught this term by a colleague of mine, I call them <strong>wide events</strong>.</em></p>

<h3 id="the-software-engineerarchitect-with-ddd-background-view">The “software engineer/architect with DDD background” view</h3>

<p>As a developer working on event-driven microservices, the primary concern is implementing a business process as an event flow.</p>

<p>You think of events as triggers, and you want to have different types of events for different triggers. This allows you to look at a sequence of events and understand what’s going on.</p>

<p>Having different types of events also matches design processes such as event storming. The stickies contain what happened (the type of event), you don’t write the data on them.</p>

<p>Using different, properly named types for events means applying the ubiquitous language. Looking at the technical events, even a business person understands what’s going on.</p>

<p>The processes you implement are stories, and events are the smallest unit of a story.</p>

<p>If you had only one type of event, e.g. <code>BookingUpdated</code>, you’d have to figure out what’s going on by looking at what data has changed. Guesswork.</p>

<p>Let’s say your process is buying a cinema ticket. If you look at the sequence of events, what do you want to see?</p>

<ol>
  <li><code>SeatSelected → PaymentReceived → TicketIssued</code> or</li>
  <li><code>BookingUpdated → BookingUpdated → BookingUpdated</code></li>
</ol>

<p>After all, it’s about collaboration between services - event-driven is not data replication.</p>

<p>Taking this perspective, for any entity you emit different types of events, with the event type clearly indicating what has happened. In terms of data contained in the event, it would be only the properties related to the event (the ones that have changed in the context of the event).</p>

<p>If you use <a href="https://kafka.apache.org/">Kafka</a>, you publish all the different events relating to the same class of entity to one topic. <em>(To read the events relating to the same entity in order, they must be on the same partition. Being on the same topic is a prerequisite for being on the same partition.)</em> If you use a schema registry, you use the <a href="https://developer.confluent.io/courses/schema-registry/schema-subjects/#recordnamestrategy">RecordNameStrategy</a> or the <a href="https://developer.confluent.io/courses/schema-registry/schema-subjects/#topicrecordnamestrategy">TopicRecordNameStrategy</a>.</p>

<p>This is totally legitimate and will work. But there’s a different perspective you should also consider.</p>

<h3 id="the-data-engineer-view">The “data engineer” view</h3>

<p>As a data engineer, it’s just data. Instead of in a table, it’s in a stream, but in the end, it represents the state of things.</p>

<p>Having data in too small units just creates more work for the data team to eventually create usable tables to represent the state of the represented entities.</p>

<p>That works best if you have just one type of event in the stream, so all events on a topic share the same schema. This gives you the “table-stream duality”. Also, it makes it easy to ingest the stream into a database, or into some headless data format (such as <a href="https://iceberg.apache.org/">Iceberg</a>).</p>

<p>From a data point of view, if you could query the stream like a DB, you’d be happy with a stream that just retains the latest state forever. In fact, instead of having both a streaming infrastructure and a database, you’d actually prefer to just have one.</p>

<p>If you use Kafka, you publish only one type of event per topic. If you use a schema registry, you use the <a href="https://developer.confluent.io/courses/schema-registry/schema-subjects/#topicnamestrategy">TopicNameStrategy</a>.</p>

<h3 id="so-what-to-do">So what to do?</h3>

<p>If you focus on only one of these purposes in the design of your events and neglect the other, you might make your life harder down the line.</p>

<p>If you only follow the data perspective, you’ll lose vital information about the reason for the event. Don’t reduce event collaboration to data replication.</p>

<p>Having said that, you’ll probably come across cases where it really <em>is</em> just data replication, and where you want wide events. This includes</p>

<ul>
  <li>Using events to populate your data warehouse or data lake.</li>
  <li>Bootstrapping new services that are added to your system later, that need the full event history to start off with the up-to-date data.</li>
  <li>Cases where other services hold a local projection of the data that needs to be updated (but the update itself doesn’t trigger an action).</li>
</ul>

<p>If you focus only on the triggering nature of events, and these use cases come up later in your product’s lifecycle, you might have to introduce wide events as additional events. That adds effort you can avoid if you have the data aspect in mind early on.</p>

<h3 id="so-based-on-all-this-what-should-be-in-an-event">So, based on all this, what should be in an event?</h3>

<p>My take is:</p>

<ul>
  <li>It’s an absolute must that the event contains its reason, i.e. the business event that it represents.</li>
  <li>It must contain at least the data that was changed in this event.</li>
  <li>A fair amount of additional data doesn’t hurt. If your entity can be serialized into an event that’s still small enough, include a complete snapshot of its state and make your (and your data’s consumers) life easier.</li>
</ul>

<p>“Include a <em>complete</em> snapshot” requires further qualification. Still be mindful of the data you include of your events. Not only because, from a technical perspective, events should be small, so they can be replicated quickly e.g. between the multiple nodes of your distributed message broker. But even more importantly: Your event stream is an API. You need to design the events just as carefully as you would design JSON objects for a RESTful HTTP API. What goes in there is hard to remove, and you want to be able to change your domain model internally to some extent without affecting the event payload.</p>

<p>So my standard approach is to <strong>use carefully designed, wide events and include the reason in the event</strong> (or alternatively as a header). While I want to see the reasons, and get the story from looking at the sequence of events, it doesn’t necessarily have to be encoded as the event type.</p>

<p>A sequence would then be something like</p>

<p><code>BookingUpdated(Reason: SeatSelected) → BookingUpdated(Reason: PaymentReceived) → BookingUpdated(Reason: TicketIssued)</code></p>

<p>To me this embraces the dual nature, it’s a “best of both worlds” practice for me. What’s your approach? Let me know what you think in the comments.</p>

                    </section></div>
  </body>
</html>
