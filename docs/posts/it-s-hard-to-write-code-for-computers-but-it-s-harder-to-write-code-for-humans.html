<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://erikbern.com/2024/09/27/its-hard-to-write-code-for-humans.html">Original</a>
    <h1>It&#39;s hard to write code for computers, but it&#39;s harder to write code for humans</h1>
    
    <div id="readability-page-1" class="page"><article>
  
  <time datetime="2024-09-27T00:00:00Z">2024-09-27</time>
  <p>Writing code for a computer is hard enough.
You take something big and fuzzy, some large vague business outcome you want to achive.
Then you break it down recursively and think about all the cases until you have clear logical statements a computer can follow.
Computers are very good at following logical statements.</p>
<p>Now, let&#39;s crank it up a notch.
Let&#39;s try to write code for <em>humans</em>!</p>
<p>I need to clarify what I mean.
I&#39;m talking about code that other humans will interact with.
More specifically, I&#39;m talking about the art of crafting joyful frameworks, libraries, APIs, SDKs, DSLs, embedded DSLs, or maybe even programming languages.</p>
<p>Writing this code is much harder, because you&#39;re not just telling a computer what to do, you&#39;re also grappling with another user&#39;s mental model of <em>your</em> code.
Now it&#39;s equal part computer science and psychology of reasoning, or something.
How do you get that person to understand <em>your</em> code?</p>
<p>Feynman famously said: <em>Imagine how much harder physics would be if electrons had feelings.</em> about something very different, but in a funny way I think this describes programming for humans a bit.
The person interpreting <em>your</em> code actually has feelings!</p>
<p>Let&#39;s talk about some ways we can make it easier.</p>
<h2 id="getting-started-_is_-the-product">Getting started <em>is</em> the product</h2>
<p>It&#39;s obviously great to listen to your users and take their feedback into account.
As it turns out, most of that feedback will come from power users who use your product all the time!</p>
<p>How does that affect the distribution of the feedback you&#39;re getting?
Will it be skewed?
And what does this picture of an airplane have to do with it?</p>
<p><img src="https://erikbern.com/assets/dev-tools/survivorship-bias.png" alt="survivorship bias"/></p>
<p>Of course, there&#39;s a <a href="https://en.wikipedia.org/wiki/Survivorship_bias">survivorship bias</a> going on here.
There are users who don&#39;t use your tool because they never get started.
You will typically never hear their feedback!</p>
<p>Consumer products have had growth hackers for many years optimizing every part of the onboarding funnel.
Dev tools should do the same.
Getting started shouldn&#39;t be an afterthought after you built the product.
Getting started <em>is</em> the product!</p>
<p>And I mean this to the point where I think it&#39;s worth restructuring your entire product to enable fast onboarding.
Get rid of mandatory config.
Make it absurdly easy to set up API tokens.
Remove all the friction.
Make it possible for users to <em>use your product</em> on their laptop in a couple of minutes, tops.</p>
<p>You might dismiss this as, I don&#39;t know, “who cares about lazy users”.
Then let me lean back on my bean bag chair, open a bag of Doritos, and explain something:</p>
<p>There&#39;s currently 7,000,000,000 dev tools out there.
Users don&#39;t have a ton of energy or patience to go deep and try to understand what&#39;s different about your LRU cache NPM package or whatever.
Sorry!</p>
<h2 id="humans-learn-from-examples-not-from-core-concepts">Humans learn from examples, not from “core concepts”</h2>
<p>Humans are amazing pattern matching machines, in contrast to computers who obey Boolean logic and follow strict instructions.
It&#39;s common to see documentation for dev tools structured like a computer program.
It starts with defines a core data model and the relations and the atoms.
It starts with “core concepts” and how to configure and how to run things.</p>
<p>Humans don&#39;t learn about things this way.</p>
<p>Two seconds after writing the above paragraph, I ran into this on Twitter which basically captures what I&#39;m trying to say:</p>
<blockquote><p lang="en" dir="ltr">Too many programming books and tutorials are like “let’s build a house starting from scratch, brick by brick” when what I want to “here is a functioning house, let’s learn about it by changing something and then seeing what happens”</p>— Chris Albon (@chrisalbon) <a href="https://twitter.com/chrisalbon/status/1831497223076770217?ref_src=twsrc%5Etfw">September 5, 2024</a></blockquote>



<p>Instead of writing an 5,000 word “core concepts” chronicle, may I suggest putting together a dozen examples instead.
This has a few benefits:</p>
<ul>
<li>Humans will look at the examples and learn how your tool works from that. This is how humans learn!</li>
<li>A person with a problem in mind will look for a starting point that&#39;s <em>close enough</em>.
The more potential starting points, the more likely they are to have something that&#39;s closer to what they need.</li>
</ul>
<h2 id="falling-into-the-pit-of-success">Falling into the pit of success</h2>
<p>The sad but true part of programming is, the default mode is that you&#39;re fixing an error of some sort.
This means that users are going to spend the majority of the time with your tool trying to figure out what&#39;s not working.
Which is why pushing them back into success is so core.</p>
<p>A succinct list:</p>
<ol>
<li>Developers getting to success faster are happy developers.
They will like your tool.</li>
<li>Developers banging their heads against errors are sad developers.
They will blame your tool.</li>
</ol>
<p>Think about every error as an opportunity to nudge a user towards the happy path.
Put code snippets in the exceptions.
Emit helpful warnings when users are likely to do something weird.
Do what you got to do to make the user succeed.</p>
<h2 id="avoid-conceptual-overload">Avoid conceptual overload</h2>
<p>Every new conceptual <em>thing</em> you have to understand before using the tool makes is a new friction point. If it&#39;s 2-3 <em>things</em>, that&#39;s fine. But no one is going to bother learning 8 new concepts.</p>
<p><img src="https://erikbern.com/assets/dev-tools/kubernetes.png" alt="kubernetes"/></p>
<p>This example (Kubernetes) isn&#39;t even particularly egregious. You can get started just knowing a few of these. I mean you can find worse ones out there</p>
<p><img src="https://erikbern.com/assets/dev-tools/databricks-terraform.png" alt="databricks terraform"/></p>
<p>It&#39;s probably true you don&#39;t need the vast majority to get started.
But still, my head hurts when I have to learn new <em>things</em>.
Too many <em>things</em>!</p>
<p>There&#39;s something elegant about a framework with just 3-5 <em>things</em> that manages to be incredibly powerful.
I remember the feeling when I tried React the first time and got over the conceptual hump after an hour or two.
Just a few fairly simple building blocks that lets you build a whole cathedral. Magic stuff ✨.</p>
<p>To be clear, the challenge isn&#39;t to reduce concepts.
It&#39;s to <em>retain the possible set of things you can build</em> while reducing concepts.
Or at least reducing the former less than the latter.
I&#39;m mentioning this because I picture some sort of a “dumb dev tools simplification doom loop” that goes something like this:</p>
<p><img src="https://erikbern.com/assets/dev-tools/doomloop.png" alt="doom loop"/></p>
<p>I don&#39;t know if this is a thing, but my point here is that there&#39;s a level of futility of “bad” simplification.
You ultimately want to push the frontier describing the tradeoff between “complexity” (what you need to know) and “ability” (what you can build).
Amazing tools are able to reduce complexity by 90% while keeping the ability the same,
But I&#39;ll also take a tool that reduces the former by 90% and reduces the latter by 10%.
That&#39;s still not bad!</p>
<h2 id="conceptual-duck-principle">Conceptual duck principle</h2>
<p>Somewhat related to the previous point, let&#39;s say in your framework you introduce a thing that takes some values and evalutes to a new values. What do you call it? A compute node? A valuator? A frobniscator?</p>
<p>No! You call it a <em>function</em>!</p>
<p><img src="https://erikbern.com/assets/dev-tools/duck.jpg" alt="duck"/></p>
<p>If it walks like a duck, and it quacks like a duck, it probably <em>is</em> a duck.</p>
<p>Maybe it isn&#39;t exactly like a function in some subtle ways. Maybe the values are cached for instance. But that&#39;s close enough!</p>
<p>Calling it a <em>function</em> means you latch onto a users pre-existing mental model of what a function does. Which will save you like, 90% of the explanation of how to think about this object.</p>
<h2 id="programmability">Programmability</h2>
<p>People will do crazy things with your codebase.
They will take your things and put it inside a for-loop inside a function inside something else.
People are creative!</p>
<p>You want almost everything in your framework to be “programmable” for this reason.</p>
<p>This is a whole class of issues that are related in subtle ways.
Letting users call things directly in code rather than going through a CLI.
Avoiding config and making things directly part of an SDK or an API.
Making things easily to parametrize so you can create <em>n</em> things not just 1.</p>
<p>One weird benefit of this is it often lets users discover new use cases for you.
Harness people&#39;s desire to “hack” on top of your framework.
There will be some mild bloodshed coming from those users, but don&#39;t chastise them!
They might be on the verge of discovering something unexpected.</p>
<h2 id="be-extra-judicious-about-magic-defaults-and-syntactic-sugar">Be extra judicious about magic, defaults, and syntactic sugar</h2>
<p>Let&#39;s say you&#39;re building a tool that executes a Jupyter notebook in the cloud.
So you have a function <code>run_notebook</code> that takes a list of cells (with computer code) or something.</p>
<p>How does the user specify which container image they should use?
You have a few different options:</p>
<ol>
<li>An argument <code>image=...</code> that <em>always</em> has to be provided.</li>
<li>An argument <code>image=...</code> that defaults to some base image with “most” data science libraries pre-installed, but that they user can override.</li>
<li>You inspect the code in the cells and pick an image in a “magic” way based on what dependencies are needed.</li>
<li>Same as above, but you also let users optionally specify a specific image.</li>
</ol>
<p>What should you use? If you want to minimize the amount of typing for users, while supporting the widest possible set of use cases, go for the last option.
But here are some issues with all options except the first one:</p>
<ul>
<li>Let&#39;s be real — the magic will break in some % of situations.</li>
<li>Users reading code that relies on defaults will not realize that things are customizeable.</li>
</ul>
<p>Unless defaults apply in 97%+ of the time, and unless magic applies 99% of the time, be careful about introducing it.
These are not exact numbers obviously, but my point is, you need to be very very judicious.</p>
<p>It&#39;s tempting to think that job as a tool provider is to minimize the amount of code a user has to write.
But coding isn&#39;t golf!</p>
<p>I think about this a bit about how I think about Perl vs Python.
Perl tried very hard to optimize for shortest code until every program looked like a strong of special characters and nothing else.
Then Python came and it&#39;s code was 50% longer.
It never tried to be the shortest!
But it turned out Python code was super readable and thus much more understandable.
And people read code 10x more times than they write it.</p>
<p>Syntactic sugar belongs in a similar category.
It&#39;s tempting to introduce a special syntax for the most common use cases.
But it often obscures the consistency and makes it less clear how to customize code.
For similar reasons, unless the syntactic sugar applies 99%+ of the time, it&#39;s probably not a good idea to introduce it.</p>

<p>We are coming to an end, but there are so many more things I could keep going on about:</p>
<ul>
<li>Most things (but not everything) should be immutable</li>
<li>Avoid “scaffolding” (code generation)</li>
<li>Make the feedback loops incredibly fast</li>
<li>Make deprecations easy for users to deal with</li>
<li>Use automated testing for code snippets in docs and examples</li>
</ul>
<p>Probably a lot more.
Those are maybe things for a future blog post!
Including what I think is maybe the most fascinating thing: why large companies are generally incapable of delivering great developer experiences.</p>
<p>I sometimes think the challenge of designing for the 1st time user is similar to making a pop song. The producer will listen to the song a thousand times. But still the 999th time they hear it, they need to <em>imagine what it sounds like to a person that hears it the first time,</em> which seems… super hard.</p>
<p>This is probably why I ended up building dev tools rather than producing pop songs.</p>


  
<strong>

    Tagged with: 
    <a href="https://erikbern.com/tags/software">software</a>, <a href="https://erikbern.com/tags/programming">programming</a>
</strong>

</article></div>
  </body>
</html>
