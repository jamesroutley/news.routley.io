<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.brakmic.com/keycloak-with-postgresql-on-kubernetes/">Original</a>
    <h1>Keycloak with PostgreSQL on Kubernetes</h1>
    
    <div id="readability-page-1" class="page"><article id="post-2202">
      <div>
    <section>
            <div>
        

<p>12 minutes read</p>
				
				
				
				
			
				
				
<p>In this article we will learn how to deploy <a href="https://www.keycloak.org/" target="_blank" rel="noopener">Keycloak</a> with <a href="https://www.postgresql.org/" target="_blank" rel="noopener">PostgreSQL</a> on Kubernetes. We will first do everything manually with separate YAMLs and then later with <a href="https://helm.sh/" target="_blank" rel="noopener">Helm</a>. Our k8s environment will run in <a href="https://kind.sigs.k8s.io/" target="_blank" rel="noopener">Kind</a>, which is an easy to use k8s variant for local expermentation. The sources are located <a href="https://github.com/brakmic/Keycloak_on_Kubernetes" target="_blank" rel="noopener">here</a>.</p>
<h4>Keycloak</h4>
<p>Keycloak is one of the most popular open-source <em>Identity and Access Management</em> providers. It can run in various environments, from small shops up to giant data centers. Although this article isn‚Äôt about IAM‚Äôs in general and how to use them, let‚Äôs provide a simple definition just to make sure we‚Äôre all on the same page.</p>
<p>An IAM is needed when there is a need to define and regulate identities and access rights within an organization. That is, when there are <em>different parties</em> with <em>different interests</em> and <em>certain resources</em> that should or shouldn‚Äôt be used by <em>certain parties</em> in <em>certain ways</em>. And to regulate this is almost always a really complex task, because you need a mechanism that defines groups, roles, memberships, access rights, authorization flows, and so on. But you also need a mechanism that can delegate access rights based on user rights. For example, you want to be able to allow a mobile app to access some data on a resource that you can already access directly. As the app in question isn‚Äôt you personally, you‚Äôd like to somehow ‚Äúdelegate‚Äù your access rights to it, so that it can work with your data on <em>your behalf</em>.</p>
<p>Simply spoken: in situations like these you have to deal with problems related to <strong>authentication</strong> (who you are), <strong>access rights</strong> (what you can do), and <strong>authorization</strong> (what can be done in your name). These questions are the reason why Keycloak and similar systems exist. They offer us an easy to use graphical interface where we can configure everything that‚Äôs needed to provide secure access to resources. But not only this. You can also extend Keycloak to match your individual security settings. By writing extensions you can inject pieces of logic into Keycloak that will be executed each time a certain security feature is accessed. But we won‚Äôt cover writing extensions here, so I‚Äôll leave it for a potential future article. üòâ</p>
<p>Our Keycloak instance will be running in k8s and will be using a PostgreSQL database which will run in k8s as well. This is not mandatory as we could also provide a DB that is running outside of k8s, but here I wanted to show how we can use <em>PersistentVolumes</em> and <em>PersistentVolumeClaims</em> to create durable storage solutions. But before we run any script in that direction, we need a proper k8s environment first. Here we will be using <em>Kind</em>.</p>
<h4>Kind</h4>
<p>Kind is one of the popular ‚Äúlocal kubernetes‚Äù environments. You might have heard about <em>minikube</em>, <em>k3s</em>, <em>k3d</em> and similar solutions as well. Kind runs inside Docker and therefore we must have it installed and running before we fire up Kind. The easiest way is just to install <a href="https://www.docker.com/products/docker-desktop/" target="_blank" rel="noopener">Docker Desktop</a> for your OS.</p>
<p>Depending on your OS you will use <a href="https://kind.sigs.k8s.io/docs/user/quick-start/#installation" target="_blank" rel="noopener">one of the options</a> described in the official Kind docs. After the installation we will setup a new cluster that will run our Keycloak environment. Unless you have a specific requirements I‚Äôd recommend to use the <em>config.yml</em> from the ‚Äúkind‚Äù subdirectory in the github repo. Also take into account that this <em>config.yml</em> contains patches needed to make the deployment accessible from outside. Please read the <a href="https://kind.sigs.k8s.io/docs/user/ingress/" target="_blank" rel="noopener">official docs</a> from Kind.</p>
<pre>kind create cluster hbr-cluster --config=config.yml</pre>
<figure id="attachment_2204" aria-describedby="caption-attachment-2204"><a href="https://blog.brakmic.com/wp-content/uploads/2023/04/create_cluster.gif" data-lb-type="grouped-post"><img decoding="async" loading="lazy" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://blog.brakmic.com/wp-content/uploads/2023/04/create_cluster.gif" alt="cluster creation with kind" width="870" height="467"/></a><figcaption id="caption-attachment-2204">After the setup has completed check the properties of your new cluster with <em>kubectl</em>.</figcaption></figure>
<pre>kubectl cluster-info --context kind-hbr-cluster</pre>
<p><a href="https://blog.brakmic.com/wp-content/uploads/2023/04/get_cluster_info.png" data-lb-type="grouped-post"><img decoding="async" loading="lazy" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://blog.brakmic.com/wp-content/uploads/2023/04/get_cluster_info.png" alt="" width="880" height="83" data-srcset="https://blog.brakmic.com/wp-content/uploads/2023/04/get_cluster_info.png 880w, https://blog.brakmic.com/wp-content/uploads/2023/04/get_cluster_info-300x28.png 300w, https://blog.brakmic.com/wp-content/uploads/2023/04/get_cluster_info-768x72.png 768w, https://blog.brakmic.com/wp-content/uploads/2023/04/get_cluster_info-570x54.png 570w" data-sizes="(max-width: 880px) 100vw, 880px"/></a></p>
<p>If you see an output like the one shown above then everything was successful so far. The last step is the installation of an IngressController, in this case it will be NGINX-Ingress.</p>
<pre>kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/kind/deploy.yaml</pre>
<p>Further info on the <a href="https://kind.sigs.k8s.io/docs/user/ingress/#using-ingress" target="_blank" rel="noopener">general usage of Ingresses</a> can be found in Kind‚Äôs docs as well. But for now, we‚Äôre all set and can start with our manual deployment.</p>
<h4>Manual deployments with YAML</h4>
<p>In professional k8s environments you will be mostly using tools like <a href="https://helm.sh/" target="_blank" rel="noopener">Helm</a>, <a href="https://kustomize.io/" target="_blank" rel="noopener">Kustomize</a> and similar to deploy and configure deployments. However, for local demos or learning purposes the manual application of YAMLs files is still recommended. Kubernetes is complex and it is therefore recommended to learn a few basics first. There are a plenty of very good docs out there and <a href="https://kubernetes.io/docs/home/" target="_blank" rel="noopener">the official one</a> is going into great lengths to explain every aspect of k8s. You should definitely read it on a daily basis. I prefer to enter some term that interests me and then let the official docs guide me through various options.</p>
<p>Out setup contains the following components that will be configured with their respective YAMLs:</p>
<ul>
<li><a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/" target="_blank" rel="noopener">Namespace</a></li>
<li><a href="https://kubernetes.io/docs/concepts/configuration/secret/" target="_blank" rel="noopener">Secrets</a></li>
<li><a href="https://kubernetes.io/docs/concepts/storage/" target="_blank" rel="noopener">Storage</a></li>
<li>PostgreSQL</li>
<li>Keycloak</li>
<li><a href="https://kubernetes.io/docs/concepts/services-networking/ingress/" target="_blank" rel="noopener">Ingress</a></li>
</ul>



<p>This is how the YAMLs look like in the folder structure:</p>
<p><a href="https://blog.brakmic.com/wp-content/uploads/2023/04/manual_folder.png" data-lb-type="grouped-post"><img decoding="async" loading="lazy" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://blog.brakmic.com/wp-content/uploads/2023/04/manual_folder.png" alt="" width="209" height="183"/></a></p>
<h5>Namespaces</h5>
<p>As we want to keep these parts of our system grouped together we create a new <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/" target="_blank" rel="noopener">Namespace</a> first.</p>
<pre>kubectl apply -f 01_namespace.yml</pre>







<h5>Secrets</h5>
<p>We will define several <a href="https://kubernetes.io/docs/concepts/configuration/secret/" target="_blank" rel="noopener">Secrets</a> to maintain passwords and certficates that are needed to access our database, admin console of Keycloak, and deliver TLS certificates via Ingress. For this we apply the second YAML in a row:</p>
<pre>kubectl apply -f 02_secrets.yml</pre>







<h5>Storage</h5>
<p>Our Postgres instance will save its data <a href="https://kubernetes.io/docs/concepts/storage/volumes/" target="_blank" rel="noopener">somewhere</a> in the k8s cluster. And because k8s treats everything as ephemeral (that is, <em>forgettable in a millisecond</em>) we want our data to be persistent so that it remains even after a deployment got destroyed or recreated. For this task we will use two new k8s classes: the physical storage itself, <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/" target="_blank" rel="noopener">PersistentVolume</a>, and a request of a piece of storage, <em>PersistentVolumeClaim</em>. Just like a <a href="https://kubernetes.io/docs/concepts/workloads/pods/" target="_blank" rel="noopener">Pod</a> requests a piece of a Node‚Äôs resources the PersistentVolumeClaim requests a piece of storage from a PersistentVolume. This way we separate handling of (<em>virtual or physical</em>) hardware from the actual usage. If you can‚Äôt grasp this concept immediately, don‚Äôt worry, as it usually takes some time. Try to think about it the same way you think about Pods. Just like a Pod is a <em>unit of computing</em>, so is a PersistentVolumeClaim a <em>unit of storage</em>. Just like you can run a Node whose computing resources can be split up between many Pods, so you can have a PersistentVolume whose storage capacity can be split up by between many PersistentVolumeClaims.</p>
<pre>kubectl apply -f 03_storage.yml</pre>







<h5>PostgresSQL</h5>
<p>The next in line is the installation of the database. We have already defined the storage parameters so that our database can access the needed capacities. And to make it accessible from outside we will define a <a href="https://kubernetes.io/docs/concepts/services-networking/service/" target="_blank" rel="noopener">Service</a> that provides a <a href="https://kubernetes.io/docs/concepts/services-networking/cluster-ip-allocation/" target="_blank" rel="noopener">ClusterIP</a>. Later we will see how we can use this Service to talk directly to the database.</p>
<pre>kubectl apply -f 04_postgres.yml</pre>







<h5>Keycloak</h5>
<p>Now it‚Äôs time to install Keycloak itself. This deployment is a bit more complex than others because it not only configures Keycloak but also connects with the database and executes <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/" target="_blank" rel="noopener">readiness and liveness</a> probes.</p>
<pre>kubectl apply -f 05_keycloak.yml</pre>







<h5>Ingress</h5>
<p>And because we want our Keycloak to be accessible from outside we need a proper <a href="https://kubernetes.io/docs/concepts/services-networking/ingress/" target="_blank" rel="noopener">Ingress</a>. Here we‚Äôre using NGINX-Ingress, but you can replace it with any other that supports HTTP.</p>
<pre>kubectl apply -f 06_ingress.yml</pre>







<h4>Kubernetes Dashboard</h4>
<p>It is recommended to install Kubernetes Dashboard as it provides a nice web-based UI for managing k8s instances. This repo contains scripts located in ‚Äúkube_dashboard‚Äù folder that will install deployments and setup <a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/" target="_blank" rel="noopener">ClusterRoleBindings</a> and <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/" target="_blank" rel="noopener">ServiceAccounts</a>.</p>











<p>You only need to execute <em>kubectl proxy </em>in a separate shell afterwards to make it accessible from outside.</p>
<p><a href="https://blog.brakmic.com/wp-content/uploads/2023/04/kube_proxy.png" data-lb-type="grouped-post"><img decoding="async" loading="lazy" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://blog.brakmic.com/wp-content/uploads/2023/04/kube_proxy.png" alt="" width="555" height="205" data-srcset="https://blog.brakmic.com/wp-content/uploads/2023/04/kube_proxy.png 555w, https://blog.brakmic.com/wp-content/uploads/2023/04/kube_proxy-300x111.png 300w" data-sizes="(max-width: 555px) 100vw, 555px"/></a></p>
<p>To login into the UI you‚Äôd need a valid token. Use the script <em>get_token.sh</em> from the same folder to generate one, then copy/paste in into the web form as shown below.</p>
<p><a href="https://blog.brakmic.com/wp-content/uploads/2023/04/dashboard_login.png" data-lb-type="grouped-post"><img decoding="async" loading="lazy" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://blog.brakmic.com/wp-content/uploads/2023/04/dashboard_login.png" alt="" width="1436" height="875" data-srcset="https://blog.brakmic.com/wp-content/uploads/2023/04/dashboard_login.png 1436w, https://blog.brakmic.com/wp-content/uploads/2023/04/dashboard_login-300x183.png 300w, https://blog.brakmic.com/wp-content/uploads/2023/04/dashboard_login-1024x624.png 1024w, https://blog.brakmic.com/wp-content/uploads/2023/04/dashboard_login-768x468.png 768w, https://blog.brakmic.com/wp-content/uploads/2023/04/dashboard_login-570x347.png 570w" data-sizes="(max-width: 1436px) 100vw, 1436px"/></a></p>
<p>You‚Äôll then be able to display and configure k8s.</p>
<p><a href="https://blog.brakmic.com/wp-content/uploads/2023/04/dashboard_deployments.png" data-lb-type="grouped-post"><img decoding="async" loading="lazy" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://blog.brakmic.com/wp-content/uploads/2023/04/dashboard_deployments.png" alt="" width="1439" height="559" data-srcset="https://blog.brakmic.com/wp-content/uploads/2023/04/dashboard_deployments.png 1439w, https://blog.brakmic.com/wp-content/uploads/2023/04/dashboard_deployments-300x117.png 300w, https://blog.brakmic.com/wp-content/uploads/2023/04/dashboard_deployments-1024x398.png 1024w, https://blog.brakmic.com/wp-content/uploads/2023/04/dashboard_deployments-768x298.png 768w, https://blog.brakmic.com/wp-content/uploads/2023/04/dashboard_deployments-570x221.png 570w" data-sizes="(max-width: 1439px) 100vw, 1439px"/></a></p>



<h4>Automatic deployment with Helm</h4>
<p>A more comfortable and better configurable option is doing all of the above with <a href="https://helm.sh/" target="_blank" rel="noopener">Helm</a>, with just a single command. As this is not a Helm tutorial I won‚Äôt be explaining it in detail. Helm is a tool for managing k8s installations. Think of it as some kind of ‚Äúnpm for k8s‚Äù. Just like you can use npm to install any NodeJS package for Node the same you are able to do with Helm for Kubernetes. And just like npm packages are organized in a certain way so are Helm‚Äôs ‚Äúcharts‚Äù too. A chart contains rules and settings that control how k8s deployments are executed. And just like any other package management tool Helm too can reference other charts to deploy them all in one go. There is some minimal configuration that must be present in every Helm chart, but apart from that you are free to configure charts as you like.</p>
<p>Any Helm chart contains a <em>Chart.yaml</em> file that defines it.</p>







<p>It also contains a folder ‚Äútemplates‚Äù that contains various YAMLs that will be used to apply changes to the k8s system. The only file that we keep from default chart definition is <em>_helpers.tpl</em>. All other files are our own.</p>
<p><a href="https://blog.brakmic.com/wp-content/uploads/2023/04/helm_templates.png" data-lb-type="grouped-post"><img decoding="async" loading="lazy" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://blog.brakmic.com/wp-content/uploads/2023/04/helm_templates.png" alt="" width="245" height="240"/></a></p>
<p>To create a new chart we use: <em>helm create CHART_NAME </em></p>
<p><em>However, as we already have a preconfigured chart in our repo there is no need to do that. Just in case you are about to create a completely new chart you‚Äôll then need to execute the above command.</em></p>
<p>There is also a YAML called <em>values.yaml</em> that contains variables that will be inserted into YAMLs from ‚Äútemplates‚Äù folder. Instead of putting hard-coded values into every YAML, like I did in the manual variant, we use <em>values.yaml</em> to define variables that then will be referenced throughout the installation of the deployment. This is an example of <em>01_namespace.yml</em> from the Helm chart:</p>







<p>The value for key <em>name</em> is referencing <em>.Values.namespace</em>. This is how we insert values into template YAMLs. The double curly braces are mandatory and you should keep in mind that numerical values should never be quoted unless you want to present them as strings. In the above example we‚Äôre referencing a string so the quotes are fine. If this was a numerical value we‚Äôd be writing it without quotes. There are other ways to deal with data types which you can find in the <a href="https://helm.sh/docs/chart_best_practices/conventions/" target="_blank" rel="noopener">Best Practices section in the official Helm docs</a>.</p>
<p>Below is the content of our <em>values.yaml </em>where we define values to be used in our various YAMLs. We are free to define any kind of variable, but it is recommended to group them according to their class and context. Also try to be consistent with naming. So, if you have ‚Äúsecrets.postgres.name‚Äù then you should also have ‚Äúsecrets.keycloak.name‚Äù etc.</p>







<p>Before we try to install our chart let‚Äôs do a <em>dry-run</em> first, shall we? Just to see if everything‚Äôs OK.</p>
<pre>helm template keycloak-k8s-local keycloak-k8s-local</pre>
<p>You should get an output like this.</p>
<p><a href="https://blog.brakmic.com/wp-content/uploads/2023/04/helm_template_run_command.gif" data-lb-type="grouped-post"><img decoding="async" loading="lazy" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://blog.brakmic.com/wp-content/uploads/2023/04/helm_template_run_command.gif" alt="" width="886" height="427"/></a></p>



<p>If there is nothing for Helm to complain about the result will be a YAML file that contains all elements from separate YAMLs.</p>
<p>Now it‚Äôs time to deploy the system! For this we invoke the <em>install</em> command by referencing the chart name and giving the name of the deployment.</p>
<pre>helm install keycloak-k8s-local keycloak-k8s-local</pre>
<p><a href="https://blog.brakmic.com/wp-content/uploads/2023/04/helm_install_command.gif" data-lb-type="grouped-post"><img decoding="async" loading="lazy" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://blog.brakmic.com/wp-content/uploads/2023/04/helm_install_command.gif" alt="" width="885" height="427"/></a></p>
<p>That‚Äôs it. That‚Äôs all it takes for Helm to deploy everything we did manually before. To uninstall the system you‚Äôd just need to issue an uninstall command referencing the name of the Helm deployment.</p>
<pre>helm uninstall keycloak-k8s-local</pre>
<p><a href="https://blog.brakmic.com/wp-content/uploads/2023/04/helm_uninstall.gif" data-lb-type="grouped-post"><img decoding="async" loading="lazy" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://blog.brakmic.com/wp-content/uploads/2023/04/helm_uninstall.gif" alt="" width="888" height="232"/></a></p>



<p>And as promised, here‚Äôs how you can connect with the Postgres database inside your k8s environment. First, you need to query the name of the Pod that runs the database.</p>
<div>
<pre>kubectl get pods -n hbr-keycloak</pre>

</div>
<p><a href="https://blog.brakmic.com/wp-content/uploads/2023/04/get_pods.png" data-lb-type="grouped-post"><img decoding="async" loading="lazy" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://blog.brakmic.com/wp-content/uploads/2023/04/get_pods.png" alt="" width="442" height="66" data-srcset="https://blog.brakmic.com/wp-content/uploads/2023/04/get_pods.png 442w, https://blog.brakmic.com/wp-content/uploads/2023/04/get_pods-300x45.png 300w" data-sizes="(max-width: 442px) 100vw, 442px"/></a></p>

<p>Copy the full name of the Pod whose name starts with ‚Äúpostgres‚Äù. Then use it as argument when executing this command:</p>

<div>
<div>
<pre>kubectl exec -it $POD_NAME -n hbr-keycloak -- psql -h localhost -U postgres --password -p 5432 keycloak</pre>
</div>
</div>

<p>You will then have to enter the password of your postgres. Ultimately, you should be able to enter the <em>psql</em> shell.</p>

<p><a href="https://blog.brakmic.com/wp-content/uploads/2023/04/psql_connect.gif" data-lb-type="grouped-post"><img decoding="async" loading="lazy" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://blog.brakmic.com/wp-content/uploads/2023/04/psql_connect.gif" alt="" width="1197" height="429"/></a></p>

<p>The subfolder <a href="https://github.com/brakmic/Keycloak_on_Kubernetes/tree/main/db" target="_blank" rel="noopener">db</a> contains a simple shell script that can be used to connect with the database.</p>



<h4>Keycloak Admin Console</h4>
<p>Finally, we have arrived at a complete Keycloak system. Our deployment can be accessed by opening the https://localhost URL. The potential certificate warning can be ignored as we deployed a self-signed certificate in our Secrets object. To logon use ‚Äúadmin‚Äù as both user name and password.</p>
<p><a href="https://blog.brakmic.com/wp-content/uploads/2023/04/keycloak_postgres_on_k8s-1.gif" data-lb-type="grouped-post"><img decoding="async" loading="lazy" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://blog.brakmic.com/wp-content/uploads/2023/04/keycloak_postgres_on_k8s-1.gif" alt="" width="1437" height="764"/></a></p>



<p><strong>That‚Äôs it for now!</strong> In the upcoming article we‚Äôll be talking about <a href="https://knative.dev/docs/" target="_blank" rel="noopener">Knative</a> and how to make k8s easier to use.</p>


      </div>
      
    </section><!-- .entry-content -->
  </div><!-- .post-entry -->
  </article></div>
  </body>
</html>
