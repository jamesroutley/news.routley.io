<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://scottlocklin.wordpress.com/2024/11/19/lush-my-favorite-small-programming-language/">Original</a>
    <h1>Lush: My favorite small programming language</h1>
    
    <div id="readability-page-1" class="page"><div>
		<p>I meant to write about this when I started my blog in 2009. Eventually <a href="https://lush.sourceforge.net/">Lush</a> kind of faded out of my consciousness, as it was a lot easier to get work doing stuff in R or Matlab or whatever. The guy who was maintaining the code moved on to other things. The guys who wrote most of the code were getting famous because of the<a href="https://github.com/hparik11/German-Traffic-Sign-Recognition"> German Traffic Sign</a> results. I moved on to other things.  I had a thought bubble the other day that I’d try to compile it and see what happened. Binutils guys have been busy for the last decade and changed all manner of things: I couldn’t even find documentation of the old binutils the last version of Lush2 was linked against. Then I noticed poking around the old <a href="https://lush.sourceforge.net/">sourceforge site</a> that Leon Bottou had done some recent check ins fixing (more effectively than me) the same problems in the Lush1 branch. I stuck the subversion repo with history so you can marvel at it on <a href="https://github.com/locklin/lush-code">github</a>. I may try to revive a few of the demos I remember as being cool.</p>
<p>I call it a small language; compared to contemporary Python or R it is quite small, and had a small number of developers. The developers were basically <a href="https://yann.lecun.com/">Yann LeCun</a> and <a href="https://leon.bottou.org/">Leon Bottou</a>  and some of their students (there are other names in the source like <a href="https://yoshuabengio.org/">Yoshua Bengio</a>). This tool is where they developed <a href="https://en.wikipedia.org/wiki/LeNet">what became</a> Deep Learning –<a href="https://github.com/locklin/lush-code/blob/master/lush1/trunk/packages/gblearn2/demos/lenet5.lsh">lenet5</a>; the first version of <a href="https://github.com/locklin/lush-code/tree/master/lush1/trunk/packages/torch">Torch</a> was in here (as I recall it was more oriented to HMMs at the time). Since it’s a lisp, it’s easy to add macros and such to make it do your bidding and fit your needs. Unlike anything else I’ve ever used, Lush is a real <em>ergonomic</em> fit for the programmer. It has a self-documenting feature which is incredibly useful: sort of like what R does, it takes comments in code and makes them into documentation. Unlike R documentation there is a way of viewing it in a <a href="https://github.com/locklin/lush-code/blob/master/lush1/trunk/lsh/libogre/helptool.lsh">nice gui</a> and linking it to other documentation. So you have a nice manual for the system and whatever you built in it, almost automagically. Remember “literate coding?” It was always a sort of aspiration: this is a real <a href="https://github.com/locklin/lush-code/blob/master/lush1/trunk/lsh/libstd/ldoc.lsh">implementation</a> of it, and it’s so easy to use, you’d have to be actively malicious or in a pretty big hurry not to do it. Here’s a screen I made for myself so I could remember how to use some code I built 15 years ago (it still works BTW). You can update it at the CLI, just like everything else in a Lisp.</p>
<p><a href="https://scottlocklin.wordpress.com/wp-content/uploads/2024/11/lush.png"><img data-attachment-id="7503" data-permalink="https://scottlocklin.wordpress.com/2024/11/19/lush-my-favorite-small-programming-language/lush/" data-orig-file="https://scottlocklin.wordpress.com/wp-content/uploads/2024/11/lush.png" data-orig-size="1036,617" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="lush" data-image-description="" data-image-caption="" data-medium-file="https://scottlocklin.wordpress.com/wp-content/uploads/2024/11/lush.png?w=300" data-large-file="https://scottlocklin.wordpress.com/wp-content/uploads/2024/11/lush.png?w=720" src="https://scottlocklin.wordpress.com/wp-content/uploads/2024/11/lush.png?w=720" alt="" width="720" height="429" srcset="https://scottlocklin.wordpress.com/wp-content/uploads/2024/11/lush.png?w=720 720w, https://scottlocklin.wordpress.com/wp-content/uploads/2024/11/lush.png?w=150 150w, https://scottlocklin.wordpress.com/wp-content/uploads/2024/11/lush.png?w=300 300w, https://scottlocklin.wordpress.com/wp-content/uploads/2024/11/lush.png?w=768 768w, https://scottlocklin.wordpress.com/wp-content/uploads/2024/11/lush.png?w=1024 1024w, https://scottlocklin.wordpress.com/wp-content/uploads/2024/11/lush.png 1036w" sizes="(max-width: 720px) 100vw, 720px"/></a></p>
<p>As a Lisp, you have access to macros which allows you to do magic things that make <a href="https://x.com/paulg/status/1853046165467508977">Paul Graham</a> happy.  I am smooth brain: only wrote a couple of them: I’ve written considerably more C macros than Lisp macros and plan on keeping it that way. The Lush authors also don’t use them very often; mostly in the <a href="https://github.com/locklin/lush-code/tree/master/lush1/trunk/lsh/compiler">compiler</a>, which is how it should be.  <em>“A word to the wise: don’t get carried away with macros.”</em>  as Peter Norvig told us in PAIP. There is a nice object system, and a very useful set of GUI tooling. Not just the help gizmo; there’s a full fledged GUI (<a href="https://github.com/locklin/lush-code/blob/master/lush1/trunk/lsh/libogre/ogre.lsh">ogre</a>). Imagine that; something to develop old fashioned graphical user interfaces without importing two gigabytes of Electron and javascript baloney. The <a href="https://github.com/locklin/lush-code/blob/master/lush1/trunk/lsh/libogre/helptool.lsh">helptool</a> uses this; it is not an HTML browser. The documentation format looks a bit like markdown with a few quirks; I never had to look at a manual to write the stuff. Essentially it looks like the standard two sentence comments you put to remind yourself what a complicated function does. It has a nice object system the GUI thing is written in; I assume it’s something like <a href="https://en.wikipedia.org/wiki/Common_Lisp_Object_System">CLOS</a>: whatever it is, there are no surprises and anyone who knows about namespaces and objects can use it. I found it particularly useful for its encapsulation of raw FFI pointers and other tooling which is best trapped in a namespace where it can’t hurt anything.</p>
<p>Since it is oriented around developing 80s-90s era cutting edge machine learning, one of the core types is the array. The arrays are real APL style arrays: rank 0 to rank 4, which is probably one rank higher than most sane people use (most people use rank 2, aka matrices). It looks like it had up to rank-7 at one point: I have no idea what you’d do with that. APLs such as J often have rank-whatever, so someone somewhere has probably done something with such structures. Lush2 had an interesting APL like sublanguage for operating on the arrays, which looked pretty handy, but which I never quite got into (most of my work was in Lush1).</p>
<p>All this is cool, but I suppose <a href="https://www.red-lang.org/">other</a> small programming languages promise things like this. The really cool thing about it is the layers. You get a high level interpreted Lisp. You also have a compilable subset of Lisp; mostly oriented around numerics things, just as one would expect in a domain specific language one might develop early convolutional net/deep learning algorithms in. Even better than this, if you want to call some C, including calling libraries, you can enclose your C in a Lisp macro and compile it right into the interpreter. Most of the interesting and useful code in the world still sits behind a C API. With a tool like this: suddenly you have a useful interpreter where you can vacuum in all the DLLs you want, and they’ll be available at the command line.</p>
<p><a href="https://scottlocklin.wordpress.com/wp-content/uploads/2024/11/autoencoder.png"><img data-attachment-id="7506" data-permalink="https://scottlocklin.wordpress.com/2024/11/19/lush-my-favorite-small-programming-language/autoencoder/" data-orig-file="https://scottlocklin.wordpress.com/wp-content/uploads/2024/11/autoencoder.png" data-orig-size="1147,1001" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="autoencoder" data-image-description="" data-image-caption="" data-medium-file="https://scottlocklin.wordpress.com/wp-content/uploads/2024/11/autoencoder.png?w=300" data-large-file="https://scottlocklin.wordpress.com/wp-content/uploads/2024/11/autoencoder.png?w=720" src="https://scottlocklin.wordpress.com/wp-content/uploads/2024/11/autoencoder.png?w=720" alt="" width="720" height="628" srcset="https://scottlocklin.wordpress.com/wp-content/uploads/2024/11/autoencoder.png?w=720 720w, https://scottlocklin.wordpress.com/wp-content/uploads/2024/11/autoencoder.png?w=150 150w, https://scottlocklin.wordpress.com/wp-content/uploads/2024/11/autoencoder.png?w=300 300w, https://scottlocklin.wordpress.com/wp-content/uploads/2024/11/autoencoder.png?w=768 768w, https://scottlocklin.wordpress.com/wp-content/uploads/2024/11/autoencoder.png?w=1024 1024w, https://scottlocklin.wordpress.com/wp-content/uploads/2024/11/autoencoder.png 1147w" sizes="(max-width: 720px) 100vw, 720px"/></a></p>
<p>Most interpreters have some FFI facility for doing this; none to my knowledge are this easy to use or powerfully agglomerative. The memory management happens for free, more or less. In, say, R’s repl, you can do something called dyn.load on libraries with R compatible types. If it’s more complex than that you might have to write significant wrapper code, and this is a hack: it might just leak memory all over the place. You have to work pretty hard to encapsulate C libraries in a proper R package, compiling against the R sources. J, same story; you can use the <a href="https://code.jsoftware.com/wiki/Guides/DLLs/Calling_DLLs">15!:0 foreign</a> to load a dll and wrap up J structures to send, with some tooling to deallocate or copy memory locations (very carefully). In Lush, you call the C functions directly, in C, on C’s terms (or C++ ). You can write a couple of lines C wrapper, a couple of pages; whatever: it’s all a part of the Lush source. If you look at examples of well-wrapped dlls in R on CRAN, you’ll see they’re festooned with all manner of ugly R structure casts, mysterious R #defines and all kinds of badness and quasi-memory management you’d have to read a 300 page manual to make sense of what’s going on. Having done this a few times, I’m exaggerating a tiny bit, but it is tedious and fiddly and takes a fair amount of work; a couple days if you’ve never done it before, versus a couple minutes. In Lush you just stick a dollar sign in front of variables you allocated in Lush in your C function calls, and after it’s been compiled into the interpreter (which happens if you “libload” the file), you call them, variables appear where they’re supposed to. No memory leaks. Usually doesn’t take down the interpreter when something goes wrong, though of course if you send something weird to a raw pointer it will probably segfault and die. Here’s an image grab of a simple method for instantiating a KD-tree using <a href="https://www.cs.umd.edu/~mount/ANN/">LibANN</a> (a bleeding edge nearest neighbor library of circa 2009):</p>
<div data-shortcode="caption" id="attachment_7508"><p><a href="https://scottlocklin.wordpress.com/wp-content/uploads/2024/11/c-magic.png"><img aria-describedby="caption-attachment-7508" data-attachment-id="7508" data-permalink="https://scottlocklin.wordpress.com/2024/11/19/lush-my-favorite-small-programming-language/c-magic/" data-orig-file="https://scottlocklin.wordpress.com/wp-content/uploads/2024/11/c-magic.png" data-orig-size="596,607" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="C-magic" data-image-description="" data-image-caption="" data-medium-file="https://scottlocklin.wordpress.com/wp-content/uploads/2024/11/c-magic.png?w=295" data-large-file="https://scottlocklin.wordpress.com/wp-content/uploads/2024/11/c-magic.png?w=596" src="https://scottlocklin.wordpress.com/wp-content/uploads/2024/11/c-magic.png" alt="" width="596" height="607" srcset="https://scottlocklin.wordpress.com/wp-content/uploads/2024/11/c-magic.png 596w, https://scottlocklin.wordpress.com/wp-content/uploads/2024/11/c-magic.png?w=147&amp;h=150 147w, https://scottlocklin.wordpress.com/wp-content/uploads/2024/11/c-magic.png?w=295&amp;h=300 295w" sizes="(max-width: 596px) 100vw, 596px"/></a></p><p id="caption-attachment-7508">First lines are the documentation; inside the defmethod we try to make a new kdtree; the stuff between #{ and }# is normal C++. You can see the $ in front of $out, this tells the Lush compiler to pull the result back into the interpreter. This method gets compiled and loaded and accessed like any other method in Lush. idx2 is a matrix type, the other stuff does what you think it does.</p></div>
<p>Lush dates from <em><strong>1987</strong></em>: I don’t even remember what kind of computers people used back then. I assume something like a 68020 Sun Workstation or a VAX. Even when I was using it in 2009, a “multicore” system might have two cores, so it wasn’t really designed with that sort of thing in mind either (though you could link to blas which do this in most numerics cases and it has tooling to use it on a <a href="https://github.com/locklin/lush-code/blob/master/lush1/trunk/lsh/libstd/cluster.lsh">cluster</a>). Some of the intestines of the thing probably reflect this. I’m sure Lush1 is nowhere near 64 bit clean (trying to allocate a big array: when I was using it in 2009 it was 32 bit binaries only, which was fine as nobody had 256g of ram back then. Other stuff which will seem unfamiliar to contemporary people: it’s for talking to local libraries. There is no provision for a package manager over the interbutts, or much other network stuff I noticed beyond sockets. No JSON (didn’t exist), sql interfaces (was exotic pay-for technology) and none of the stuff modern code sloppers are used to having. It was mostly a tool for developing more Lush code which links to locally installed libraries: this is what R&amp;D on machine learning algorithms had to be back then. As a tool for building your own little universe of new numerics oriented algorithms it is almost incomparably cozy and nice. You get the high level stuff to move bits around in style. You get the typedefed sublanguage to compile hot chunks to the metal, and you get C/C++ APIs or adding new functions written in C/C++ as a natural part of the system. Extremely cozy system to use. While it’s not the Lisp machine enthusiasts like <a href="https://www.loper-os.org/">Stas</a> are always telling us about, it’s probably about as close as you’re going to get to that experience using a contemporary operating system and hardware. Yes you have to deal with the C API: I’m sorry about that, but it’s just current year reality. Nobody is going to rewrite BLAS  in Haskell or CMU-CL to make you happy. Purity is folly.</p>
<p>As a tool, if I had to fault it for anything, it’s a few small things which I could probably fix. For example, in Kubuntu anyway, you can’t copy/paste examples from the helptool. This is probably something that could be repaired if I dig down into whatever X library the ogre package calls to do this. It’s no big deal; not a very wordy language anyway, and I should be reading the docs and typing code I’m about to run in emacs rather than copypasta. Another slightly annoying thing is a lack of built in pretty-print for results. Many languages have this problem: in Lush it’s easy to write one and I have one around somewhere. Some of the packages aren’t well documented and some don’t work because of various forms of bitrot: this is to be expected in something this old. Other than that, no faults. Very cozy programming language. The coziest.</p>
<p><img src="https://i.imgur.com/ldiuNCD.gif" width="498" height="381"/></p>
<p>The <a href="https://github.com/locklin/lush-code/tree/master/lush1/trunk/src">C insides</a> are fairly understandable, modulo the glowing crystal <a href="https://github.com/locklin/lush-code/blob/master/lush1/trunk/src/dldbfd.c">dldbfd.c</a> gizmo at the center that does the binutils incantations that make the dynamic linking magic happen. Even that looks like it could be understood if you were familiar with binutils. Lush1 there are a number of odd pieces that were planned to be sawed off which you can sort of infer by their absence in <a href="https://github.com/locklin/lush-code/tree/master/lush2">Lush2</a>, which had a redesigned VM. However, Lush1 compiles and runs the old code, and Lush2 doesn’t.</p>
<p>While this programming language could (and really should) be revived, even in its present state it can be marveled at. Both for its historical importance in developing machine learning algorithms, and for its wonderful “programmer first” utility. I don’t know what exigencies caused them to move the Torch neural net library to Lua; probably whiny wimps who were intimidated by parenthesis. I can guess why it ended up in Python (the Visual Basic of current year). It’s one of those things where, had things worked out a little differently, machine learning people would be typing lots of parenthesis in <em>vastly more futuristic</em> Lush instead of drearily plodding along with spaghetti in Jupyter. It represents a very clear vision of how software development should work. No bureaucracies or committees were involved in its design: just people who needed a good tool to invent the future. I suspect the committees and social pressures involved in larger programming languages is why they’re often so awful. Lush is all designed and built by <em>makers</em>, not bureaucrats and “product managers.” It feels purposeful. It also feels incomplete, which is as it should be, as these guys were too talented to maintain programming languages. Like an unfinished <a href="https://en.wikipedia.org/wiki/Saint_Jerome_in_the_Wilderness_%28Leonardo%29#/media/File:Saint_Jerome_Leonardo_-_image_only_(Q972196).jpg">DaVinci painting</a>; you can see the grandeur of the artist’s vision.</p>
<p>I’ve always been fans of these guys; as I pointed out in my article on <a href="https://scottlocklin.wordpress.com/2023/05/31/djvu-and-its-connection-to-deep-learning/">DjVu</a>, there is much to admire beyond their good taste in algorithms and dogged determination to continue working on them at a time when only eccentrics were interested in neural nets. All the cool kids of the era were doing <a href="https://github.com/locklin/lush-code/blob/master/lush2/packages/svm/lasvm.lsh">SVMs</a> …. because …. researchers are mostly trend following rather than thinking. Hopefully I don’t cheese them off too much by bringing it up, though as an American it is arguably a sovereign duty to piss off the French. For myself, I have a shitload of work to do in coming months. I sort of hope I can find an excuse to fiddle around with it some more, or maybe even use it in production in some small way. If I do, I’ll write about it. I  encourage others to give it a try and ponder how cool 2024 would have been if we used this tool instead of trashfire Python slop you’re all doomed to use in your day job.</p>
	</div></div>
  </body>
</html>
