<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://stackoverflow.blog/2022/06/15/c-ienumerable-yield-return-and-lazy-evaluation/">Original</a>
    <h1>C#: IEnumerable, yield return, and lazy evaluation</h1>
    
    <div id="readability-page-1" class="page"><div>
    
<p>Let’s talk about one of my favorite .NET features: <code>IEnumerable</code>. </p>



<p>This  interface enables iterating over a collection. In other words, if something is an <code>IEnumerable</code>, you can mostly think of it like an array or a list. You can use a <code>foreach</code> statement to loop through it, you can use <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/">LINQ</a> to map or reduce it in a hundred different ways, or you can explicitly cast it to an array with <code>.ToArray()</code> and access elements by index. But there are a few things that make <code>IEnumerable</code> special—and a few things that make it tricky.</p>



<p><code>IEnumerable</code> is the return type from an <em>iterator</em>. An iterator is a method that uses the <code>yield return</code> keywords. <code>yield return</code> is different from a normal <code>return</code> statement because, while it does return a value from the function, it doesn’t “close the book” on that function. The next time a value is expected, the function will continue executing statements <em>after</em> the <code>yield return</code> until it hits another <code>yield return</code> (or a <code>yield break</code>, or the end of the function block). In other words, you could write an iterator that looks like this:</p>



<pre><code>IEnumerable&lt;int&gt; GetOneTwoThree() {
  yield return 1;
  yield return 2;
  yield return 3;
  // We could put &#34;yield break;&#34; here but there&#39;s no need, the end of the function signals the same thing.
}
</code></pre>



<p>When you call <code>GetOneTwoThree()</code> it will return an <code>IEnumerable&lt;int&gt;</code>. As mentioned above, there are a few things you can do with this:</p>



<pre><code>var numbers = GetOneTwoThree();

foreach (var number in numbers) {
  Console.WriteLine(number);
  // Output:
  // 1
  // 2
  // 3
}

var doubledNumbers = numbers.Select(num =&gt; num * 2);

foreach (var number in doubledNumbers) {
  Console.WriteLine(number);
  // Output:
  // 2
  // 4
  // 6
}

var numberArray = numbers.ToArray();
Console.WriteLine(numberArray[0]); // Output: 1
</code></pre>



<p>You may notice that we’re iterating over <code>numbers</code> multiple times. For a simple iterator like the one I’ve written, that’s technically okay to do. Every time we iterate over <code>numbers</code>, it will start over at the beginning of the iterator method and yield all the same values over again. (You can’t expect this from every iterator; more on that later.)</p>



<p><em>Lazy evaluation</em> (the opposite of <em>eager evaluation</em>) is when we wait to execute a piece of code until we absolutely, positively have to. When you call <code>GetOneTwoThree()</code>, you’ll get a return value despite the fact that <em>none of the code in the function has actually been executed yet!</em> To prove it, run the following code in LINQPad.</p>



<p>(If you’re not familiar with <a href="https://www.linqpad.net/">LINQPad</a>, you should check it out—it’s a powerful, portable C# playground. But the only thing you need to know about it here is that it provides the magic <code>.Dump()</code> method, which outputs any value to the <strong>Results</strong> pane.)</p>



<pre><code>bool didTheCodeRun = false;

void Main() {
  var results = RunTheCode();
  didTheCodeRun.Dump();
}

IEnumerable&lt;bool&gt; RunTheCode() {
  didTheCodeRun = true;
  yield return true;
}
</code></pre>



<p>The output of running <code>Main()</code> in the above snippet is <code>false</code>. That’s right, after we run <code>RunTheCode()</code>, which explicitly sets <code>didTheCodeRun</code> to <code>true</code>, the value of <code>didTheCodeRun</code> is still <code>false</code>. None of the code in our iterator runs until we start iterating through the <code>IEnumerable</code>. It’s lazily evaluated!</p>



<p>This may seem counterintuitive, but in a lot of cases it’s a good thing. What if you never end up iterating through the <code>IEnumerable</code> at all? Well, that’s a bunch of code the computer didn’t have to execute. Or what if you’re using a LINQ method like <code>.First()</code> to try to find a specific item in the collection? You may not need to run <em>all</em> the code in the iterator to get the value you’re looking for–and you won’t. Once <code>.First()</code> finds a value that matches the predicate, it will stop iterating. If you’re working with an <code>IEnumerable</code> that potentially has thousands of values (or more), you can save a lot of CPU cycles by only iterating as far as you need to.</p>



<p>Of course, it’s all up to you. You can iterate as much or as little as you want. Let’s take a look at some of the ways to do that.</p>



<pre><code>// Here&#39;s a variable to track execution of code in an iterator
int lastYielded = -1;

// Here&#39;s an iterator for us to play with
IEnumerable&lt;int&gt; GetOneToTen() {
  for (var num = 1; num &lt;= 10; num++) {
    lastYielded = num;
    yield return num;
  }
}

void Main() {
  var numbers = GetOneToTen();
  lastYielded.Dump(); // Output: -1

  // This gives us an &#39;instance&#39; of the iteration
  var enumerator = numbers.GetEnumerator();

  // This executes the iterator until the first yield return is reached
  enumerator.MoveNext();

  // This gives us the current (most recently yielded) value of the iterator
  enumerator.Current.Dump(); // Output: 1
  lastYielded.Dump(); // Output: 1

  // This will iterate from 1 to 4, then stop
  foreach (var num in numbers) {
    if (num &gt;= 4) {
      break;
    }
  }

  lastYielded.Dump(); // Output: 4

  // This will not execute any code in the iterator.
  //  LINQ methods are lazily evaluated as well
  var numbersTimesTwo = numbers.Select(num =&gt; num * 2);
  lastYielded.Dump(); // Output: 4

  // This will force the entire iterator to run, yielding all values
  var arr = numbers.ToArray();
  lastYielded.Dump(); // Output: 10
}
</code></pre>



<p>It’s important to point out that many iterators are not as simple as the ones we’ve been using here. An iterator could query a database, for example—including the unfortunate possibility that it might alter data, or that iterating through it twice might yield completely different results! Some tools (like <a href="https://www.jetbrains.com/resharper/">ReSharper</a>) will warn you against multiple enumeration for this reason. An iterator is, from one perspective, nothing more than a synchronous method that may not execute its code right away (or at all). And to muddy the waters just a little, not all iterators are synchronous; there’s also an <code>IAsyncEnumerable</code> interface (you can loop through it with <code>await foreach</code>).</p>



<p>Most of the time none of this is a problem. Almost all the time you can treat an <code>IEnumerable</code> like a list. But I’ve learned the hard way not to rely on this—I once used <code>.Select()</code> to transform a collection while using an external variable to track a small piece of state on each iteration, then got very confused when the external variable wasn’t updated later in the method. In the end, I fixed the problem by forcing the iteration to complete with <code>.ToArray()</code>. (There are multiple ways to approach something like this, depending on the expected size of the collection and what you’re trying to track.)</p>



<p>Hopefully this overview helps you avoid running into issues when you create or consume <code>IEnumerable</code> in your own code (which is extremely likely, as they’re everywhere in C#). Here are a couple of rules to remember:</p>



<ol><li>Try to avoid side effects when writing an iterator method. Anyone who uses the method should be able to treat it as though it synchronously returns an array. If an iterator changes or executes anything outside of itself, the caller may end up confused. This applies to functions passed to LINQ methods as well, since many of them return <code>IEnumerable</code> and are lazily evaluated.</li><li>You should avoid iterating over the same <code>IEnumerable</code> multiple times. If you know you’re going to access every value—for example, if you’re iterating it using a <code>foreach</code> with no <code>break</code> or <code>return</code>—enumerate it sooner rather than later by coercing the <code>IEnumerable</code> to a list or array type. Then use that list or array for all future operations.</li></ol><p>
    Tags: <a href="https://stackoverflow.blog/tag/net/" rel="tag">.net</a>, <a href="https://stackoverflow.blog/tag/c-3/" rel="tag">C#</a>, <a href="https://stackoverflow.blog/tag/ienumerable/" rel="tag">IEnumerable</a>  </p></div></div>
  </body>
</html>
