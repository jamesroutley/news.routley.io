<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/gusmanb/logicanalyzer">Original</a>
    <h1>Raspberry Pico-based 100-Msps logic analyzer</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<hr/>
<h2 dir="auto"><a id="user-content-description" aria-hidden="true" href="#description"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Description</h2>
<p dir="auto">Cheap 24 channel logic analyzer with 100Msps, 32k samples deep, edge triggers and pattern triggers.</p>
<hr/>
<h2 dir="auto"><a id="user-content-overview" aria-hidden="true" href="#overview"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Overview</h2>
<p dir="auto">LogicAnalyzer is a very cheap analyzer based in a Raspberry Pico. The analyzer offers up to 24 digital channels, pre and post trigger sampling, edge trigger and pattern trigger up to 16 bits.</p>
<p dir="auto">The most basic version is purely a Pico as-is, you only need to short GPIO0 and GPIO1, upload the firmware and you&#39;re good to go.
Of course this has some limitations as the Pico only supports 3.3v, if you want to use it to diagnose 5v signals I also have designed a fast level shifter board.</p>
<p dir="auto">Additionally to the hardware the logic analyzer also includes a powerful software (Windows only for now) where you can visualize the captured data, export captures, use protocol analyzers, etc.</p>
<h2 dir="auto"><a id="user-content-about-logic-analyzers-and-triggers" aria-hidden="true" href="#about-logic-analyzers-and-triggers"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>About logic analyzers and triggers</h2>
<p dir="auto">A logic analyzer only cares about logic states of lines, so without thinking much about it you may think that any microcontroller using DMA channels that read GPIO values would be more than enough, but that is the &#34;easy&#34; part of a logic analyzer, the problem comes when you need to trigger the captures based in GPIO states and you want also to have data captured previously and after the trigger happens.</p>
<p dir="auto">For that, you need to compare the read values from the GPIOs check if the pin or pins values match the requested trigger and you must do it as fast as you want to capture, so for example, the most basic comparison will at least consume 3 or 4 instructions, if each instruction is 1 to 4 cycles (more or less, I&#39;m thinking in ARM processors) then you will use up to 16 cycles to read a sample, so you would need a 1.6Ghz CPU to sample at 100Msps.</p>
<p dir="auto">So, how the heck the pico is able to achieve this? Well, the key are the PIO units, these units are a wonder, they are coprocessors explicitly designed to handle IO, it uses a very restricted and deterministic assembler (only nine instructions that each take a single cycle to execute) but extremely efficient, so efficient that with only two instructions is possible to create a loop that captures GPIO data up to 30 bits and redirects the program flow based in the status of one of these GPIOs.</p>
<p dir="auto">Of course there are some limitations, that two-instruction loop can only change the execution flow based on a GPIO pin, it can&#39;t branch based on a pattern (using only two instructions) but as we have more than one unit (each pico has two units and each unit has four state machines, so you can run in parallel up to 8 programs) we can abuse a bit the system and create a separate trigger program that notifies the capture program using a pin, that&#39;s why GPIO0 and GPIO1 are shorted.</p>
<p dir="auto">The analyzer described here has three trigger modes: edge trigger, fast pattern trigger and complex pattern trigger.</p>
<p dir="auto">The edge trigger uses a single program, that&#39;s the basic version that uses only two instructions, runs up to 100Msps and the triggering is synchronized with the captures.</p>
<p dir="auto">The complex triggers is the first that uses two programs, one to capture and other for the trigger. The complex trigger supports patterns up to 16 bits matched from consecutive channels in the first 16 ones.
Having two programs is key to keep sampling up to 100Msps, the trigger program uses three instructions so its speed is limited to 66Msps, but the sampling can run at full speed using two instructions. Of course this presents some inconveniences, there is latency between the trigger signal and the reported trigger, also if the trigger pattern lasts less than one cycle at 66Mhz the trigger can be lost, and finally as the trigger always runs at maximum speed on lower speeds there may happen a &#34;glitch&#34;, the trigger is raised because the pattern was found but the sampling program does not register this as it runs at a lower speed.</p>
<p dir="auto">Finally we have the fast trigger, this uses a very clever &#34;hack&#34; (thanks to alastairpatrick from the Raspberry forums for the idea) that abuses the limitations of the PIO units. Each PIO unit can handle only 32 instructions, so the program counter of a state machine rolls to 0 if it&#39;s overflown, also the PIO assembler has an instruction to MOVe data from the IN pins to the program counter, and finally the PIO assembler allows to modify pin values on each instruction without using any extra cycle. So, said that, the trick consists on create a full 32 instruction program that moves the values from the GPIO to the PC and the instructions that are allocated in indexes that match the required pattern block the execution and sets a GPIO to 1.
Of course this limits the possibilities for the pattern, we can use up to 5 channels for this trigger but the trigger will run at full speed (it can work even faster, up to 200Msp).</p>
<p dir="auto">If you want more info about the triggers check the PIO code in the source as there is more explanation on how this works.</p>
<h2 dir="auto"><a id="user-content-schematic" aria-hidden="true" href="#schematic"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Schematic</h2>
<p dir="auto">The base schematic is only the Pico with a short between GPIO0 and GPIO1 but I have designed a PCB for convenience, it has been designed to maintain trace lengths so no glitch may happen because propagation delays (at 100Mhz it should not be a problem, but in marginal cases if there is a noticeable trace length difference some picoseconds of delay can be introduced and change the analyzed values).</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/gusmanb/logicanalyzer/blob/master/Schematic1.jpg?raw=true"><img src="https://github.com/gusmanb/logicanalyzer/raw/master/Schematic1.jpg?raw=true" alt="Schematic picture" title="Basic schematic"/></a></p>
<p dir="auto">Also, as the Pico only supports 3.3v I have designed a level shifter board, it uses very fast transceivers (TXU0104) which met the 100Msps specifications.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/gusmanb/logicanalyzer/blob/master/Schematic2.jpg?raw=true"><img src="https://github.com/gusmanb/logicanalyzer/raw/master/Schematic2.jpg?raw=true" alt="Schematic picture" title="Shifter schematic"/></a></p>
<p dir="auto">ATTENTION! I&#39;m in the process of receiving the PCBs so they are not tested, I will update this document after testing it.</p>
<h2 dir="auto"><a id="user-content-pcb" aria-hidden="true" href="#pcb"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>PCB</h2>
<p dir="auto">There are two PCBs, one for the analyzer and other for the level shifter.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/gusmanb/logicanalyzer/blob/master/PCB1.jpg?raw=true"><img src="https://github.com/gusmanb/logicanalyzer/raw/master/PCB1.jpg?raw=true" alt="PCB picture" title="Analyzer PCB"/></a></p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/gusmanb/logicanalyzer/blob/master/PCB2.jpg?raw=true"><img src="https://github.com/gusmanb/logicanalyzer/raw/master/PCB2.jpg?raw=true" alt="PCB picture" title="Shifter PCB"/></a></p>
<h2 dir="auto"><a id="user-content-building-the-firmware" aria-hidden="true" href="#building-the-firmware"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Building the firmware</h2>
<p dir="auto">To build the firmware you need to have an environment configured for Pico development, but if you don&#39;t have it don&#39;t worry, the releases include the UF2 file, so you only need to start the Pico in program mode, drop the UF2 file to the Pico drive and that&#39;s it, you have a Logic Analyzer ready to be used.</p>
<h2 dir="auto"><a id="user-content-the-software" aria-hidden="true" href="#the-software"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>The software</h2>
<p dir="auto">Before designing my own analyzer I have used some cheap Chinese analyzers and all use the same software, OLS, OpenBench Logic Analyzer, and to be honest, I don&#39;t like it. So, I have implemented my own binary protocol (more info in the firmware code) and visualization software.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/gusmanb/logicanalyzer/blob/master/Software1.jpg?raw=true"><img src="https://github.com/gusmanb/logicanalyzer/raw/master/Software1.jpg?raw=true" alt="Software picture" title="Software main screen"/></a></p>
<p dir="auto">This is a .net desktop program for Windows (if I have enough requests I may plan to create a .net MAUI version that runs in Windows/MacOS/Linux) which allows you to visualize the capture data, highlight sampling ranges, name channels extremely fast, export the captured data preserving the capture settings and ranges, implements protocol analyzers (and a very easy system to include your own ones) and so on.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/gusmanb/logicanalyzer/blob/master/Software2.jpg?raw=true"><img src="https://github.com/gusmanb/logicanalyzer/raw/master/Software2.jpg?raw=true" alt="Software picture" title="SPI analysis"/></a></p>
<p dir="auto">For now I have already implemented a SPI protocol analyzer but I plan to implement also I2C, RS-232 and system bus analyzers (for old computers, 16 address bits and 8 data bits). In any case, with little knowledge of C# you can add your own protocol, which makes the program capable of analyze proprietary protocols.</p>
<p dir="auto">The capture interface is straight and self-explanatory, and the software preserves your last settings, can import settings from exported captures and allows you to re-issue a capture without having to go through the configuration process.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/gusmanb/logicanalyzer/blob/master/Software3.jpg?raw=true"><img src="https://github.com/gusmanb/logicanalyzer/raw/master/Software3.jpg?raw=true" alt="Software picture" title="Capture interface"/></a></p>
<h2 dir="auto"><a id="user-content-using-the-device" aria-hidden="true" href="#using-the-device"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Using the device</h2>
<p dir="auto">The device once connected to your PC will be detected as a serial port, no drivers are needed. Once you open the software you will have a list of serial ports and you must choose the correct one, once selected if you &#34;Open&#34; the device it will show the firmware version in the top section and will enable the capture buttons.</p>
<p dir="auto">To use the analyzer connect the required channels to the signals you want to analyze, also connect at least one ground pin from the Pico to the analyzed device, press the &#34;Capture&#34; button, configure your settings and start the capture. The Pico will start flashing until the trigger condition is met and the capture will run.</p>
<p dir="auto">Once the capture has finished you will see the channels, a range of up to 100 samples and the trigger event will be right at the left side of the sample area.</p>
<p dir="auto">To name your channels you have a grey box under each one, these are textboxes where you can set whatever you want, and if you export your capture they will be preserved.</p>
<p dir="auto">To create an highlighted region press over the numeric top bar and drag to select how many samples are highlighted.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/gusmanb/logicanalyzer/blob/master/Highlight1.jpg?raw=true"><img src="https://github.com/gusmanb/logicanalyzer/raw/master/Highlight1.jpg?raw=true" alt="Region picture" title="Highlight creation"/></a></p>
<p dir="auto">This will open the region creation dialog where you can choose a name for your region, the color and the opacity of the highlight.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/gusmanb/logicanalyzer/blob/master/Highlight2.jpg?raw=true"><img src="https://github.com/gusmanb/logicanalyzer/raw/master/Highlight2.jpg?raw=true" alt="Region picture" title="Highlight creation"/></a></p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/gusmanb/logicanalyzer/blob/master/Highlight3.jpg?raw=true"><img src="https://github.com/gusmanb/logicanalyzer/raw/master/Highlight3.jpg?raw=true" alt="Region picture" title="Highlight"/></a></p>
<p dir="auto">If you want to delete a region press on the numeric bar over a highlighted region and it will be deleted. Regions are also exported with captures.</p>
<h2 dir="auto"><a id="user-content-adding-custom-protocol-analyzers" aria-hidden="true" href="#adding-custom-protocol-analyzers"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Adding custom protocol analyzers</h2>
<p dir="auto">To add a new protocol analyzer you need to create a .net 6.0 assembly that references the LogicAnalyzer assembly and implements at least one class based in &#34;ProtocolAnalyzerBase&#34;. Basically you will provide a list of settings to present to the user and then you will implement an analysis function that returns analyzed channels.</p>
<p dir="auto">Each analyzed channel will specify a list of segments where data is overlayed (to present data to the user) and also it may provide a custom renderer for the data segments. You can create your own custom renderers or just provide an instance of the already included &#34;SimpleSegmentRenderer&#34;.</p>
<hr/>
<h2 dir="auto"><a id="user-content-about-sigrok-and-the-custom-app" aria-hidden="true" href="#about-sigrok-and-the-custom-app"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>About Sigrok and the custom app</h2>
<p dir="auto">I have been reading some comments about why create my own application and why not use Sigrok as it would have been developed faster. First of all, the full project including firmware, PCB&#39;s and Windows client took me less than a week of development, I have been creating Windows apps for more than 20 years and it takes me less time to implement a rendering system, plugins and so on than implementing a third-party driver :)
In any case, my main reason to not consider to use sigrok is because I tried to use it with some cheapo analyzers and on my machines it simply would not run, I&#39;m not sure if some component that I use for development is incompatible with it but on my three machines it crashed, in one machine it does not open at all and on the other two I had random crashes when I tried to capture data.</p>
<p dir="auto">In any case, I will try to get it running in one of my development machines and if it works I will check how complex would be to create a driver for it.</p>
<hr/>
<p dir="auto">Have fun!</p>
</article>
          </div></div>
  </body>
</html>
