<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://danielchasehooper.com/posts/why-swift-is-slow/">Original</a>
    <h1>The Swift compiler is slow due to how types are inferred</h1>
    
    <div id="readability-page-1" class="page"><div><p>The Swift compiler is notoriously slow due to how types are inferred<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>. Every June I hope that Apple will announce that they fixed it; sadly this is not that year.</p><p>Here’s an explanation by the creator of Swift, Chris Lattner (From his <a href="https://www.youtube.com/watch?v=9ag0fPMmYPQ&amp;t=373s" target="_blank" rel="noopener">Mojo talk</a>):</p><blockquote><p>My experience with Swift is we tried to make a really fancy bi-directional Hindley-Milner type checker and it’s really great because you can have very beautiful minimal syntax but the problem is that A) compile times are really bad (particularly if you have complicated expressions) and B) the error messages are awful because now you have global constraint systems and when something goes wrong you have to infer what happened and the user can’t know that something over there made it so something over here can’t type check. In my experience it sounds great but it doesn’t work super well.</p></blockquote><p>Let me explain what he means with an example:</p><div><pre tabindex="0"><code data-lang="swift"><span><span><span>enum</span> <span>ThreatLevel</span> <span>{</span>
</span></span><span><span>    <span>case</span> <span>red</span>
</span></span><span><span>    <span>case</span> <span>midnight</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>enum</span> <span>KeyTime</span> <span>{</span>
</span></span><span><span>    <span>case</span> <span>midnight</span>
</span></span><span><span>    <span>case</span> <span>midday</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>setThreatLevel</span><span>(</span><span>_</span> <span>level</span><span>:</span> <span>ThreatLevel</span><span>)</span> <span>{...}</span>
</span></span><span><span>
</span></span><span><span><span>setThreatLevel</span><span>(.</span><span>midnight</span><span>)</span>
</span></span></code></pre></div><p>The <code>.midnight</code> on the last line could represent <code>ThreatLevel.midnight</code> or <code>KeyTime.midnight</code>. The Swift compiler has to use the surrounding context of <code>setThreatLevel()</code>, which has the type <code>(ThreatLevel)-&gt;Void</code>, to infer that we mean <code>ThreatLevel.midnight</code>. After the Swift compiler parses code into an abstract syntax tree, child nodes influence their parent’s type <em>and</em> parent nodes influence their children’s types (that’s what Chris means by “bi-directional”). Compare this to the Zig language, in which types are determined without looking at the surrounding code.</p><p>This approach becomes a problem when expressions contain many elements that each need their types inferred, with each affecting the others. This often occurs due to Swift’s operator overloading, and the <a href="https://developer.apple.com/documentation/swift/initialization-with-literals" target="_blank" rel="noopener">ExpressibleBy protocols</a>. Every literal (string, number, boolean, dictionary, array) and every operator (* / + - etc) multiply the combinations the type checker must consider.</p><p>Here’s an example:</p><div><pre tabindex="0"><code data-lang="swift"><span><span><span>let</span> <span>address</span> <span>=</span> <span>&#34;127.0.0.1&#34;</span>
</span></span><span><span><span>let</span> <span>username</span> <span>=</span> <span>&#34;steve&#34;</span>
</span></span><span><span><span>let</span> <span>password</span> <span>=</span> <span>&#34;1234&#34;</span>
</span></span><span><span><span>let</span> <span>channel</span> <span>=</span> <span>11</span>
</span></span><span><span>
</span></span><span><span><span>let</span> <span>url</span> <span>=</span> <span>&#34;http://&#34;</span> <span>+</span> <span>username</span> 
</span></span><span><span>            <span>+</span> <span>&#34;:&#34;</span> <span>+</span> <span>password</span> 
</span></span><span><span>            <span>+</span> <span>&#34;@&#34;</span> <span>+</span> <span>address</span> 
</span></span><span><span>            <span>+</span> <span>&#34;/api/&#34;</span> <span>+</span> <span>channel</span> 
</span></span><span><span>            <span>+</span> <span>&#34;/picture&#34;</span>
</span></span><span><span>
</span></span><span><span><span>print</span><span>(</span><span>url</span><span>)</span>
</span></span></code></pre></div><p><code>swiftc</code> spends 42 seconds on these 12 lines on an M1 Pro<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>, only to spit out the notorious <code>error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions</code>. In the same amount of time, clang can perform a clean build of my 59,000 line C project <em>38 times</em>.</p><p>The issue is caused by using the <code>+</code> operator with the <code>channel</code> Int and a String literal. Thanks to the standard library’s 17 overloads of <code>+</code> and 9 types adopting the <code>ExpressibleByStringLiteral</code> Protocol, the swift compiler can’t rule out that there <em>might</em> be a combination of types and operators that make the expression valid, so it has to try them all. Just considering that the five string literals could be one of the possible nine types results in 59,049 combinations, but I suspect that’s a lower bound, since it doesn’t consider the many overloads of <code>+</code>. It gives up before getting through them all.</p><p>You can fix the code by converting <code>channel</code> to String:</p><div><pre tabindex="0"><code data-lang="swift"><span><span><span>let</span> <span>url</span> <span>=</span> <span>&#34;http://&#34;</span> <span>+</span> <span>username</span> 
</span></span><span><span>            <span>+</span> <span>&#34;:&#34;</span> <span>+</span> <span>password</span> 
</span></span><span><span>            <span>+</span> <span>&#34;@&#34;</span> <span>+</span> <span>address</span> 
</span></span><span><span>            <span>+</span> <span>&#34;/api/&#34;</span> <span>+</span> <span>String</span><span>(</span><span>channel</span><span>)</span> 
</span></span><span><span>            <span>+</span> <span>&#34;/picture&#34;</span>
</span></span></code></pre></div><p>This now successfully compiles in 0.19 seconds!</p><p>Maybe you think strings are complicated or something, so here’s an example that is just math:</p><div><pre tabindex="0"><code data-lang="swift"><span><span><span>let</span> <span>offset</span><span>:</span> <span>Double</span> <span>=</span> <span>5.0</span><span>;</span>
</span></span><span><span><span>let</span> <span>index</span><span>:</span> <span>Int</span> <span>=</span> <span>10</span><span>;</span>
</span></span><span><span><span>let</span> <span>angle</span> <span>=</span> <span>(</span><span>180.0</span> <span>-</span> <span>offset</span> <span>+</span> <span>index</span> <span>*</span> <span>5.0</span><span>)</span> <span>*</span> <span>.</span><span>pi</span> <span>/</span> <span>180</span><span>;</span>
</span></span></code></pre></div><p>Again, we get <code>error: the compiler is unable to type-check this expression in reasonable time; try breaking up the expression into distinct sub-expressions</code>, this time after “only” 8 seconds. The problem is due to <code>index * 5.0</code>, i.e. an int multiplied by a double. Even <a href="https://youtu.be/-eCwBwTbjAI?si=rQ5tHNcBRkmaFV8-&amp;t=1000" target="_blank" rel="noopener">toy compilers</a> handle equivalent code quickly, thanks to a context-free type system.</p><p>Both examples are slow because they’re invalid swift and the type checker falls out of the fast path in order to confirm all possible type combinations are invalid. You might think it’s ok for invalid code to take a long time to compile. For me, 42 seconds to produce an “I give up” message is unacceptable. However, there are valid lines of swift that take a long time to compile too. Send me your slow lines (found using <code>-Xfrontend -debug-time-function-bodies</code>) and I’ll add it to this post.</p><p>Swift has come a long way from version 1, but on its 10th birthday it can still be slow. Unfortunately this can’t be completely fixed by optimizing the current approach. It requires a different approach.</p><p>Here’s what I’d do:</p><ol><li>Add a flag to <code>swiftc</code> that makes it infer types using only an expression’s child AST nodes while ignoring the parent AST node. The flag would also disable the <code>ExpressibleBy</code> protocols, which by definition get their type from their context.</li><li>Make a feature that adds type annotations, casts, and enum names to existing code where necessary to compile with the new type checker</li><li>Update all sample code to compile with the flag</li></ol><p>This might be a reasonable stopping point: teams that care about compile times and good error messages could use the flag, and everyone else doesn’t have to. It could go further though:</p><ol start="4"><li>Enable the flag by default for new Xcode projects</li><li>Deprecate the old type inference approach</li></ol><p>With this new approach, you’d have to add type annotations in some places. I’m ok with that. As a result, we’d get faster compilation times and clearer error messages, but the extra verbosity might be too much for the swift community to swallow.</p><p>Discuss on <a href="https://x.com/DanielcHooper/status/1800948752754335753" target="_blank" rel="noopener">Twitter</a></p></div></div>
  </body>
</html>
