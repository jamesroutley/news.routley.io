<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pikuma.com/blog/understanding-computer-cache">Original</a>
    <h1>Exploring How Cache Memory Works</h1>
    
    <div id="readability-page-1" class="page"><p>Even though we often hear terms like L1, L2, cache block, etc., most programmers have a limited idea of what cache really is and what it does. In this article, we&#39;ll briefly explain what cache is, how it can be implemented, and the need for cache in the first place.</p><div>
                        <p>If there&#39;s one thing that is essential to my programming knowledge arsenal, that is the CPU cache. Cache is a double-edged sword that can make the life of a programmer who understands how to deal with it much easier and the life of the one who doesn&#39;t extremely more difficult.</p>
                        
                        <p>Before we discuss cache, we first need to understand RAM (random access memory). RAM is a famous type of memory that is temporary; power off the computer and its contents are lost. We usually think of it as a long array of <i>zeros</i> and <i>ones</i>, but in reality RAM operates quite differently! A better way to think about it is by using a table analogy.</p>
                        <p><img src="https://pikuma.com/images/blog/understanding-computer-cache/ram-table-8bit-data.png" alt="ram memory table"/></p><p>Tabular memory layout using blocks</p>
                        <p>This &#34;table&#34; memory layout makes it easier for the cache to access memory. The cache can load N memory blocks inside. Cache blocks can be of various sizes, and the number of blocks in a cache is usually a power of 2.</p>
                        <p>From now on, we&#39;ll refer to these memory blocks as &#34;<strong>cache lines</strong>.&#34; When a cache line is stored into the cache, we also store its memory location.</p>
                        <p><img src="https://pikuma.com/images/blog/understanding-computer-cache/cache-line.png" alt="cache line"/></p><p>We can store N cache lines (a.k.a. memory blocks) inside the CPU cache</p>
                        <p>When we successfully store and fetch a cache line we call it a <strong>cache hit</strong>, otherwise it is a <strong>cache miss</strong>. As cache-aware programmers, we should try to increase cache hits and avoid cache misses.</p>
                        <p>Keep in mind that different processor microarchitectures specify different sizes for their <i>cache lines</i>. For example, the laptop I am using is a MacBook Pro running on top of an Apple Silicon <a href="https://en.wikipedia.org/wiki/Apple_M2#M2_Pro" target="_blank">M2 Pro</a> chip. I can use the <strong>sysctl</strong> terminal command on macOS to check what is the cache line size for this architecture:</p>
                        <p><img src="https://pikuma.com/images/blog/understanding-computer-cache/sysctl-cachelinesize-m2.png" alt="cache line size MacbookPro M2"/></p>
                        <p>When I run the same command in my older MacBook Pro running an Intel <a href="https://en.wikipedia.org/wiki/Intel_Core#Core_i3/i5/i7/i9" target="_blank">Core i9</a> I get a different cache line size value:</p>
                        <p><img src="https://pikuma.com/images/blog/understanding-computer-cache/sysctl-cachelinesize-i9.png" alt="cache line size MacbookPro i9"/></p>
                        <p>My older Intel laptop has a cache line size of 64 bytes while the newer M2 Pro laptop has a cache line size of 128 bytes. This <strong>cache line size</strong> (or cache block size) is the unit of data transferred to and from the main memory. It significantly impacts how effectively the CPU interacts with the memory subsystem. With larger cache lines, you can exploit the spatial locality (proximity) of your data more effectively.</p>
                        <p><img src="https://pikuma.com/images/blog/understanding-computer-cache/cache-line-64kb.png" alt="cache memory layout"/></p><p>A machine with 16 GB of main RAM and 256 KB of total cache, where each cache line is 64 bytes long.</p>

                        <h3>Cache: What is it good for?</h3>
                        <p>The difference of speed between CPU and RAM was minimal in early computers. For example, the early PCs (up to and including 80386) had no cache at all. All memory operations would go from the CPU out to main memory and then back again. As the speed of the CPU increased in comparison to RAM speeds, there was a need to somehow reduce that disparity. The answer was cache memory.</p>
                        <p>This new approach consisted in a temporary data storage located on the processor, which is used to increase the processing efficiency of the CPU by holding small and often-requested bits of data ready to be accessed at high speed.</p>

                        <h3>Cache is faster than RAM</h3>
                        <p>Since our cache is located inside the CPU, it is much faster for the other parts of the processor to read and write to it.</p>
                        <p>Most modern CPU cache memory is comprised of different <i>levels of storage</i>. These levels are commonly referred to as L1, L2, L3, and ocasionally L4. They vary in location, speed, and size; most machines have at least 2 levels of cache: L1 and L2.</p>
                        <p>L1 is low capacity but extremely fast. L2 is slower but has more storage space. L3 is the slowest of the three but also usually has the biggest storage capacity.</p>
                        <p><img src="https://pikuma.com/images/blog/understanding-computer-cache/l1-l2-ram.png" alt="cache l1 l2 ram"/></p><p>L1 (fast &amp; small storage), L2 (slower &amp; bigger storage), and RAM (slowest &amp; large storage)</p>
                        <div>
                            <p><strong>How fast is L1 cache?</strong></p>
                            <p>When I say L1 is faster, I <i>really</i> mean faster! To put things into perspective, consider that accessing L1 cache can take ~3 CPU cycles, L2 takes ~10 cycles, and normal RAM takes massive ~250 cycles to complete.</p>
                        </div>

                        <h3>Where is Cache Located?</h3>
                        <p>Starting with the launch of the Intel 486DX in 1989, Intel added a very small cache within the CPU itself. The small cache embedded in the 486 chip was 8 KB in size, and in later generations it would be called &#34;Level 1&#34; cache. As manufacturers started to adopt the 486 CPU, they also began to include a secondary cache on the motherboard. This external cache was called &#34;Level 2&#34; cache and would often use SRAM chips with access times of around 15 or 20 nanoseconds (rather than 70 nanoseconds that was used by normal main memory). Below is an image of the motherboard of a 486SX with two levels of cache: L1 inside the CPU die and L2 cache located externally on the motherboard.</p>
                        <p><img src="https://pikuma.com/images/blog/understanding-computer-cache/486-cache.png" alt="486 motherboard cache"/></p><p>The original <a href="https://en.wikipedia.org/wiki/Pentium_(original)" target="_blank">Pentium</a> used a split level 1 cache where each level was 8 KB in size; 8 KB for data cache and 8 KB for instruction cache.</p>
                        <p>The <a href="https://en.wikipedia.org/wiki/Pentium_Pro" target="_blank">Pentium Pro</a> chip introduced the <a href="https://en.wikipedia.org/wiki/P6_(microarchitecture)" target="_blank">P6 x86 microarchitecture</a> in 1995 and was famous for having an on board cache. This could be either 256 KB, 512 KB, or 1 MB in size.</p>
                        <p><img src="https://pikuma.com/images/blog/understanding-computer-cache/pentium-pro.png" alt="cache l1 l2 ram"/></p><p>Uncapped Pentium Pro chip with two dies: one die for CPU and L1 cache &amp; another die for 256 KB of L2 cache.</p>
                        <p>More modern architectures are smarter in terms of cache placement and account for multiple CPU cores.</p>
                        <p><img src="https://pikuma.com/images/blog/understanding-computer-cache/l1-l2-l3-cores.png" alt="L1 L2 L3 cache multiple CPU cores"/></p><p>L1, L2, and shared L3 location inside a modern CPU die with multiple cores</p>
                        <p>Below you can see an example of a multi-core CPU architecture that contains L1, L2, and a shared L3 cache. The <a href="https://en.wikipedia.org/wiki/Nehalem_(microarchitecture)" target="_blank">Nehalem microarchitecture</a> was used in the first generation of Intel Core <a href="https://en.wikipedia.org/wiki/Intel_Core#Core_i3/i5/i7/i9" target="_blank">i5</a> and <a href="https://en.wikipedia.org/wiki/Intel_Core#Core_i3/i5/i7/i9" target="_blank">i7</a> processors.</p>
                        <p><img src="https://pikuma.com/images/blog/understanding-computer-cache/nehalem-die.png" alt="nehalem chip die cache"/></p><p>The Nehalem microarchitecture is used by the Intel Core i5 and i7 processors</p>
                        
                        <h3>Data Cache &amp; Instruction Cache</h3>
                        <p>Another aspect that we must mention is that most computers have a dedicated cache for <strong>instructions</strong> (i-cache) and another cache for <strong>data</strong> (d-cache). As one would expect, instruction cache constains program instructions, while data cache contains data. Instruction cache will store the assembly/opcode instructions and data cache will store the data accessed from main memory.</p>
                        <p>The reason for this separation has to do with the nature of <i>what</i> we are accessing and <i>how</i> we expect the data to be accessed. For example, fetching program instructions can be done in chunks with the assumption that the computer will run through many instructions in a row. Therefore, instruction fetches can be more efficient as we assume they will be sequential.</p><p> On the other hand, data coming from main memory cannot be assumed to be sequential and the data cache implementation will try to only fetch the data that was asked for.</p>
                        <div>
                            <p>Just to add some context, if you took Gustavo&#39;s <a href="https://pikuma.com/courses/ps1-programming-mips-assembly-language" target="_blank">PlayStation Programming</a> course, you know that the PS1 had only 4 KB of <i>instruction cache</i> and it did <strong>not</strong> have a proper <i>data cache.</i> Writing PS1 code that efficiently takes advantage of the i-cache was a challenge but it was often required to make games run smoothly.</p>
                            <p><a href="https://pikuma.com/courses/ps1-programming-mips-assembly-language" target="_blank"><img src="https://pikuma.com/images/blog/understanding-computer-cache/playstation-programming-tutorial.png" alt="playstation programming tutorial"/></a></p>
                        </div>
                        <p><strong>The Scratchpad</strong>: Most MIPS processors have a data cache, but the PlayStation did not implement a proper d-cache. Instead, Sony assigned 1 KB of fast-SRAM that most developers refer to as the &#34;<a href="https://psx-spx.consoledev.net/memorymap/#scratchpad" target="_blank">Scratchpad</a>.&#34; On the PS1, the Scratchpad is mapped to a fixed address in memory and its purpose is to have a more flexible &#34;cache system&#34; available to the programmer.</p>
                        <p>Modern architectures also have separate caches for instruction &amp; data. Most <a href="https://en.wikipedia.org/wiki/ARM_architecture_family" target="_blank">ARM</a> CPUs have a separate I and D cache inside L1, but are combined inside L2.</p>
                        <p>Even Apple Silicon M1 and M2 chips have separate instruction &amp; data caches. The M2 high-performance cores have 192 KB of L1 instruction cache, 128 KB of L1 data cache, and share a 16 MB L2 cache, while the energy-efficient cores have a 128 KB L1 instruction cache, 64 KB L1 data cache, and a shared 4 MB L2 cache.</p>
                        <p><img src="https://pikuma.com/images/blog/understanding-computer-cache/m2-chip.jpg" alt="apple m2 chip"/></p><p>Apple Silicon M2 Pro</p>
                        
                        <p>Invoking the <strong>sysctl</strong> command again in my laptop running on top of an Apple Silicon M2 Pro, we can see the values of L1 and L2 cache sizes:</p>
                        <p><img src="https://pikuma.com/images/blog/understanding-computer-cache/sysctl-m2.png" alt="cache size MacbookPro M2"/></p>
                        <p>Executing the same command in my older MacBook Pro running on an Intel Core i9, I get different values for L1, L2, and L3 cache sizes:</p>
                        <p><img src="https://pikuma.com/images/blog/understanding-computer-cache/sysctl-i9.png" alt="cache size MacbookPro Intel"/></p>
                        <p>Do you see how we have different sizes for instruction and data cache in L1&#39;s <i>icachesize</i> and <i>dcachesize?</i></p>

                        <h3>Where to put data in cache?</h3>
                        <p>There are many <a href="https://en.wikipedia.org/wiki/Cache_placement_policies" target="_blank">cache placement policies</a>. Some popular examples of popular placement policies are <a href="https://en.wikipedia.org/wiki/Cache_placement_policies#Direct-mapped_cache" target="_blank">direct-mapped cache</a>, <a href="https://en.wikipedia.org/wiki/Cache_placement_policies#Fully_associative_cache" target="_blank">fully associative cache</a>, <a href="https://en.wikipedia.org/wiki/Cache_placement_policies#Set-associative_cache" target="_blank">set associative cache</a>, <a href="https://en.wikipedia.org/wiki/Cache_placement_policies#Two-way_skewed_associative_cache" target="_blank">two-way skewed associative cache</a>, and <a href="https://en.wikipedia.org/wiki/Cache_placement_policies#Pseudo-associative_cache" target="_blank">pseudo-associative cache</a>.</p>
                        <p>A <strong>direct-mapped cache</strong> is the simplest approach, where each memory address maps to exactly one cache block. The cache is organized into multiple sets with a single cache line per set.</p>
                        <p>Since this aims to be a beginner-friendly article, let&#39;s simplify things and only cover direct-mapped cache. Below is a very simple example of a 16-byte memory and a 4-byte cache (four 1-byte blocks).</p>
                        <p><img src="https://pikuma.com/images/blog/understanding-computer-cache/direct-mapped-cache.png" alt="direct mapped cache"/></p><p>Direct-mapped placement using a 4-byte cache (four 1-byte blocks)</p>
                        <ul>
                            <li>Memory locations <span>0</span>, <span>4</span>, <span>8</span>, and <span>12</span> all map to cache block <span>0</span>.</li>
                            <li>Memory locations <span>1</span>, <span>5</span>, <span>9</span>, and <span>13</span> all map to cache block <span>1</span>.</li>
                            <li>Memory locations <span>2</span>, <span>6</span>, <span>10</span>, and <span>14</span> all map to cache block <span>2</span>.</li>
                            <li>Memory locations <span>3</span>, <span>7</span>, <span>11</span>, and <span>15</span> all map to cache block <span>3</span>.</li>
                        </ul>
                        
                        <h5>How do we compute this mapping?</h5>
                        <p>One way of finding out which cache block a particular memory address should go is by using the <i>remainder</i> operator. If the cache contains <span>\(2^k\)</span> blocks, then the data at memory address <strong>i</strong> would go to cache block index:</p>
                        <p>\(i\ mod\ 2^2 = 2\)</p>
                        <p>For example, using a 4-block cache, memory address <span>14</span> would map to cache block <span>2</span>.</p>
                        <p>\(14\ mod\ 4 = 2\)</p>
                        <p>This mod operation is easy to do with a computer, as it is equivalent to masking at the <i>least significant</i> bits of the memory location. Given that our cache is 4 bytes long, we look at the last significant <span>\(k\)</span> bits of the address.</p>
                        <p><img src="https://pikuma.com/images/blog/understanding-computer-cache/direct-mapped-cache-where.png" alt="direct mapped cache placement"/></p><p>The least significant <i>k</i> bits of our memory addresses are the block index of the placement.</p>

                        <h5>How do we find data in cache?</h5>
                        <p>I hope it&#39;s clear that our cache block index <span>1</span> could contain data from addresses <span>1</span>, <span>5</span>, <span>9</span> or <span>13</span>. Of course, this logic holds true for all other cache blocks, so the question really becomes <i>&#34;how can we distinguish between these potential addresses that all map to the same cache block index?&#34;</i></p>
                        <p>One approach to solve this is to add <strong>tags</strong> to the cache. These tags supply the <i>rest of the address</i> bits to let us distinguish between different memory locations that map to the same cache block.</p>
                        <p><img src="https://pikuma.com/images/blog/understanding-computer-cache/direct-mapped-cache-tags.png" alt="direct mapped cache tags"/></p><p>The block index <i>i</i> and the <i>tag</i> tell us the address of the data that is inside the cache.</p>
                        <p><strong>Valid Bit</strong>: One final information that we also store in cache is a <i>valid bit</i>. As we start, the cache is empty and all valid bits are set to zero. When data is loaded into a particular cache block, the corresponding valid bit flag is set to 1.</p>
                        <p>I also hope it&#39;s clear to everyone by now that the cache does not contain just raw copies of data in memory; it also holds metadata and extra bits to help us find data within the cache and verify its validity.</p>

                        <h3>Coding with cache in mind</h3>
                        <p>As programmers, it is important that we write code that is <i>cache-friendly</i>. Properly using the cache of our computer or game console can really affect the performance of our software. Especially in modern machines that were designed with multiple cores and large cache sizes.</p>
                        <p>Let&#39;s look at a couple of extremely simple examples and try to understand what is going on in terms of cache access.</p>
                        
                        <h5>Example 1: Cache locality</h5>
                        <p>We should keep most of our data in contiguous memory locations. That way, when our code sends the first access request, most of the data that will be used will get cached. This is closely related to our choices of data structures.</p>                        
                        <p>We are trying to keep:</p>
                        <ul>
                            <li><i>Good temporal locality:</i> aim for repeated references.</li>
                            <li><i>Good spacial locality:</i> aim for stride-1 references.</li>
                        </ul>
                        <p>As an example, think of two functions that loop all entries of a matrix summing the elements. A cache-friendly code should respect the stride-1 pattern of the matrix.</p>
                        <p>Our first function loops all rows and iterates all nested columns of that row one by one:</p>
<pre><code>int sum_matrix_rows(int mat[M][N]) {
  int sum = 0;
  for (int i = 0; i &lt; M; i++) {
    for (int j = 0; j &lt; N; j++) {
      sum += mat[i][j];
    }
  }
  return sum;
}</code></pre>
                        <p>The second function flips the access, looping all the columns of the matrix first and nesting the loop of rows inside:</p>
<pre><code>int sum_matrix_rows(int mat[M][N]) {
  int sum = 0;
  for (int j = 0; j &lt; N; j++) {
    for (int i = 0; i &lt; M; i++) {
      sum += mat[i][j];
    }
  }
  return sum;
}</code></pre>
                        <p>To understand why the first function is better from the perspective of data locality, we must recall that C arrays are allocated in <a href="https://en.wikipedia.org/wiki/Row-_and_column-major_order" target="_blank">row-major order</a>. In other words, each row is contiguous in memory.</p>
                        <p><img src="https://pikuma.com/images/blog/understanding-computer-cache/row-major.png" alt="c array row major order"/></p><p>C arrays are allocated in row-major order.</p>

                        <p>If we consider a small-enough cache size, we&#39;ll have considerably more cache hits with the first function.</p>
                        <div>
                            <p><strong>Linked lists</strong>: The <i>data locality</i> argument is also why <a href="https://en.wikipedia.org/wiki/Linked_list" target="_blank">linked lists</a> have a bad reputation nowadays. Looking at them from a <a href="https://en.wikipedia.org/wiki/Data-oriented_design" target="_blank">data-oriented-design</a> perspective, linked items can be all over the memory and that is an invitation for cache misses.</p>
                            <p><img src="https://pikuma.com/images/blog/understanding-computer-cache/linked-list.png" alt="C linked list"/>
                        </p></div>
                        
                        <h5>Example 2: Avoid complex loops</h5>
                        <p>Let&#39;s consider a simple code that allocates three arrays dynamically and initialize their elements:</p>
<pre><code>/* Allocate three arrays of 16 elements of 16-bits each */
  uint32_t data_length = 16;
  uint16_t *data_a = malloc(data_length * sizeof(uint16_t));
  uint16_t *data_b = malloc(data_length * sizeof(uint16_t));
  uint16_t *data_c = malloc(data_length * sizeof(uint16_t));

  /* Initialize all elements of the array */
  for (int i = 0; i &lt; data_length; i++) {
    data_a[i] = i;
    data_b[i] = i;
    data_c[i] = i;
  }</code></pre>
                        <p>Pretty straight forward! Each array has 16 elements and each array element is an integer of 16 bits. For the sake of keeping things simple, let&#39;s imagine that our cache can hold <i>exactly</i> 256 bytes.</p>
                        <p><img src="https://pikuma.com/images/blog/understanding-computer-cache/arrays-16.png" alt="c array"/></p><p>An array with 64 elements of 16 bits each, totalling 1024 bytes.</p>
                        <p>Now, let&#39;s write a simple loop that sums all the elements of these three arrays:</p>
<pre><code>uint32_t data_sum = 0;
for (int i = 0; i &lt; data_length; i++) {
  data_sum += data_a[i];
  data_sum += data_b[i];
  data_sum += data_c[i];
}</code></pre>
                        <p>Since our cache size is only 256 bytes, it can only handle sixteen 16-bit integers at a time. That&#39;s bad news for us! As we are looping and accessing the entries of the three arrays, the elements cached at the beginning of the loop will be dropped out of the cache by the end of the iteration. In this scenario, keeping in mind the 256-byte size of our cache, we&#39;ll have <i>cache misses.</i></p>
                        <p>One useful visualization of this problem would be a waiter being called by three tables at the same time. If each table has a list of multiple order items, how should our waiter tackle this task?</p>
                        <p><img src="https://pikuma.com/images/blog/understanding-computer-cache/waiter.png" alt="waiter tables"/></p><p>Requesting elements from three arrays is similar to a waiter serving three tables at the same time.</p>
                        <p>One approach would be for the waiter to ask the first table for their first order, then the second table for their first order, then the third table for their first order. The waiter then proceeds to ask the first table for their second order, then the second table for their second order, and then the third table for their second order. And that repeats until all the orders are written down.</p>
                        <p>Wouldn&#39;t it be better if the waiter completes the entire order for the first table before it proceeds to ask the second and third tables for their orders?</p>
                        <p>So a better solution to this specific case is writing separate for loops. <i>Gasp!</i> Yes, this <i>sounds</i> like the code would perform worse (and it <i>will</i> if we do this unnecessarily). But in this case, to avoid so many cache misses, it is better to break our loop into smaller ones.</p>
<pre><code>uint32_t data_sum = 0;
for (int i = 0; i &lt; data_length; i++) {
  data_sum += data_a[i];
}
for (int i = 0; i &lt; data_length; i++) {
  data_sum += data_b[i];
}
for (int i = 0; i &lt; data_length; i++) {
  data_sum += data_c[i];
}</code></pre>

                        <h5>Example 3: Struct alignment</h5>
                        <p>Structs in C are a very useful way of packing variables into one big chunk of memory, but they have their own special way of allocating memory. If you&#39;re new to C, you&#39;d be surprised to know that we can be &#34;wasting&#34; memory when we declare our structs.</p>
                        <p>In C and C++, every data type has a size; it may be 8 bits, 16 bits, etc. So, if structs are agglomerations of these data types, you may deduce that structs will have the size of all the its types added up, and that is surprisingly incorrect if your struct has has different types inside.</p>
                        <p>The reason for that is because structs have a natural <i>alignment</i>, which is the size of their largest member. Therefore, if you have a struct that has two members: a 32-bit one and a 8-bit one, the alignment will be the size of the greatest value: 32 bits. In this case, the total memory consumed by this struct is 64 bits!</p>
<pre><code>struct {
  uint32_t a;
  uint8_t b;
}</code></pre>
                        <p><img src="https://pikuma.com/images/blog/understanding-computer-cache/struct-alignment.png" alt="C struct alignment"/></p><p>Let&#39;s look at another example where our struct has more than two members:</p>
<pre><code>struct {
  uint16_t a;
  uint32_t b;
  uint16_t c;
}</code></pre>
                        <p>Since the largest member is 32 bits, we know that the alignment of our struct is 32 bits. Observe how this alignment plays a direct role in the size of the struct in memory:</p>
                        <p><img src="https://pikuma.com/images/blog/understanding-computer-cache/struct-alignment-2.png" alt="C struct alignment"/></p><p>Pay attention to how the struct&#39;s alignment required a padding between the first and the second members and another padding at the end (to fill the alignment).</p>
                        <p>We could improve things by re-ordering our struct members. Look at what happens if we change the order of the second and third members:</p>
<pre><code>struct {
  uint16_t a;
  uint16_t b;
  uint32_t c;
}</code></pre>
                        <p><img src="https://pikuma.com/images/blog/understanding-computer-cache/struct-alignment-3.png" alt="C struct alignment"/></p><p>We reduced the size of our struct just by playing with the alignment and the order of members. The take here is that making things occupy less space in memory can help us better fit data in our cache lines and, by doing so, reduce cache misses.</p>

                        <p>You&#39;ll see some programmers also solving this by simply dividing the data. To avoid memory leaks and cache misses if the data gets larger, we can store these as separate values instead of bundling them inside a single struct. So if we want to have multiple instances of a struct, we just treat them as two separate arrays of the same size.</p>
<pre><code>int size = 100;
uint8_t *a = malloc(size * sizeof(uint8_t));
uint8_t *b = malloc(size * sizeof(uint8_t));</code></pre>
                        <p>This way we use 40-bits per pair of these values instead of 64.</p>

                        <h5>Example 4: Compiler flags</h5>
                        <p>Compilers are super smart nowadays, so we can help them by setting the correct compiler flags for our project. Some examples of compiler optimizations include unrolling loops, optimizing function calls, vectorization, and padding data structures.</p>

                        <h3>Wrapping things up</h3>
                        <p>With our new knowledge of how computer memory works and how it works along with the CPU, I wish you most of luck to dive deeper in cache manipulation.</p>
                        <p>As I mentioned, these are extremely simple examples but the ideas that they demonstrate underpin the basics of how cache works.</p>
                        <h5>Where to go from here?</h5>
                        <p>You can start with the basics, like coding simple programs and try to benchmark them; organize the structs and do them the best as you can! You can also refactor your code to make it faster. It&#39;s all evolution from here!</p>
                        <p>If you liked this blog post, you can follow me on X/Twitter <a href="https://x.com/lemmtopia" target="_blank">@lemmtopia</a>. :)</p>
                        <p>Have fun!</p>

                        <hr/>
                        <div><p><a href="https://pikuma.com/blog">Back to Blog</a></p></div>
                    </div></div>
  </body>
</html>
