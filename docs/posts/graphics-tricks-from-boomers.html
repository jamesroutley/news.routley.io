<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://arnaud-carre.github.io/2024-09-08-4ktribute/">Original</a>
    <h1>Graphics Tricks from Boomers</h1>
    
    <div id="readability-page-1" class="page"><article role="main">
        <p>Recently I released a 4096 bytes Atari intro, featuring some bandwidth impossible sprites drawing in fullscreen. I hope technical inner details could please any graphics enthusiasts, and not only boomers :)</p>



<p>This post is made for anyone interested in oldskool graphics, but also for all retro computers technical details lovers. I will talk about STE blitter, and also how the ATARI famous “fullscreen mode” is working. Some assembly language concepts may be required for the last parts.</p>



<p>I’ll try to split the post into several dedicated parts, so you can pick-up your favourite one!</p>

<ol>
  <li>Atari STE specifications and memory bandwidth limit</li>
  <li>How the high level algorithm work</li>
  <li>Atari famous “Fullscreen”</li>
  <li>Using blitter in Fullscreen</li>
  <li>Final words</li>
</ol>


<p>Atari STE is a 8Mhz Motorola 68000 powered machine from the very end of the 80’. It features a 320x200 resolution. It can display up to 16 colors simultaneously. So the frame buffer is exactly 32000 bytes, or 31.25KiB.  ( 4bits per pixel, using a weird bit-plane layout ). Most Atari come with 1MiB of RAM. (that’s not a typo, 1MiB RAM was luxury back in time)</p>

<p>In computer graphics during the 1990s, a common term was “sprite.” A sprite is a 2D bitmap that can be drawn anywhere on the screen. Typically, the term “sprite” refers to a “hardware sprite,” which is a bitmap displayed on the screen without being stored in the frame buffer memory. This approach is very fast because it eliminates the need to read from or write to the frame buffer. However, the Atari does not support hardware sprites. To move small bitmaps around the screen on an Atari, you need to “blit” them into the frame buffer. This means copying the bitmap into the frame buffer, erasing it in the next frame, and then blitting it again at a new position.</p>

<p>These types of graphics are known as “bobs,” short for “Blittable Objects.”</p>

<h2 id="speed-of-light">Speed of light</h2>

<p>To understand the speed of an Atari machine, let’s examine some fast Atari blitter sprite code. In terms of 16-color bobs, the fastest example I know is a demo by Anima, which shows 24 bobs of 32x32 pixels each, running at 50Hz. Our bob is 64x64 pixels, which has four times the area of a 32x32 bob. This generally means it would be about four times slower (though the exact calculation is more complex, this is a reasonable approximation). So, the maximum speed for 64x64 bobs would be 24/4 = 6 bobs on screen. However, our intro displays 16 of them, and in fullscreen! Here is the video of our 4096 bytes demo:</p>

<p><a href="https://youtu.be/d6hCFlM-RUM?t=17"><img src="https://arnaud-carre.github.io/assets/img/4ktribute/vid_4ktribute.jpg" alt="4k Tribute"/></a></p>

<p><a href="https://www.pouet.net/prod.php?which=97530" target="_blank">( You can download the 4KiB intro here )</a></p>

<p>Given the memory bandwidth, this should be impossible! That’s exactly the reaction any demo coder wants from the audience: “How is that even possible?”</p>

<p>Like everything in the demoscene, there is a trick to it…</p>



<h2 id="history">History</h2>

<p>If you’re not from 90 you can’t imagine the amount of bitmap tricks used by pioneers. One of them is the stroboscopic effect. Just loop over 4 or more screens (you just change the frame buffer address) and you can get complex animation on screen for free. Of course the small amount of memory makes the animation loop pretty quick.</p>

<p>Here is an example of stroboscopic effect: All moving Atari logos in this video don’t cost anything. It’s a 8 frames looping animation. You get the feeling logos are scrolling smoothly. (Syntax Terror by Delta Force)</p>

<p><a href="https://youtu.be/dkXabJG0RLw?t=5980"><img src="https://arnaud-carre.github.io/assets/img/4ktribute/vid_syntax.jpg" alt="Syntax Terror"/></a></p>

<h2 id="unlimited-bobs">Unlimited Bobs</h2>
<p>Relying on this stroboscopic effect, some Amiga freaks invented the so-called “unlimited bobs” technique. Just loop 4 or more screens. Each frame, draw a single bob. Don’t even clear it. In the next frame, draw another one, one step ahead.</p>

<p>When looking at the demo you have the feeling of an infinite amount of bobs drawn on screen. Obviously there is just a single one drawn each frame. Even if it’s a funny demo effect, <strong>it doesn’t fool the audience for long</strong>. After a while you’ll notice the screen has been filled with the same bob and the stroboscopic effect starts to kill your eyes.</p>

<p>Here is an exemple of unlimited bobs (Dark Side of the Spoon by ULM, Atari)</p>

<p><a href="https://youtu.be/nqHK4IQhtVo?t=4109"><img src="https://arnaud-carre.github.io/assets/img/4ktribute/vid_ulm.jpg" alt="Dark Side of the Spoon"/></a></p>

<h2 id="the-trick-limited-bobs">The trick: Limited Bobs</h2>

<p>Now let’s say I want 4 bobs on screen. Let’s use the unlimited bobs technique. (ie just display a single bob per frame, and use stroboscopic fx for movement illusion).</p>

<p>After 4 frames we have 4 bobs on screen. And now what if I can erase the oldest bob? It’s not as easy as it sounds because the erasing shape could be anything. The oldest bob is “under” all the others, so we have to erase the underlying part only. Let’s hand draw something to see what we should achieve</p>

<p><img src="https://arnaud-carre.github.io/assets/img/4ktribute/anm5.gif" alt=" Alt Text"/></p>

<p>How to only clear the visible part of the very last bob? (The one under all the others)</p>

<p>Here is the trick:</p>

<p>In a off-screen buffer:</p>

<ol>
  <li>Clear the area of the oldest bob in the offscreen buffer</li>
  <li>For N limited bob demo, draw the N-1 other bobs in this offscreen buffer, using OR</li>
  <li>Now the oldest bob offscreen area is a 1 color “mask”!</li>
  <li>You can apply this mask to the real screen, at the oldest bob location</li>
  <li>Compute the next coord of the new bob for the new frame</li>
  <li>Draw this new bob as a classic masked 16 colors bob</li>
</ol>

<p>Here is outstanding quality hand drawing of the algorithm:</p>

<p><img src="https://arnaud-carre.github.io/assets/img/4ktribute/clearmask.gif" alt=" Alt Text"/></p>

<p>Then you just use this 1 color mask to clear the oldest bob on the screen by just applying a AND blit.</p>

<h2 id="why-is-it-faster-bitplans">Why is it faster? Bitplans!</h2>

<p>At the end we draw N bobs! ( N-1 at stage 2, and 1 at stage 6 ). So why the hell is it faster than just drawing N bobs?</p>

<p>Atari is a 16 colors, paletted machine. It means pixels are just indices in a palette ( exactly like 256 colors PNG file, or GIF file). You need 4 bits to encode a 16 colors  index. Atari engineers could have encoded 2 pixels in a byte. But they choose the “bitplan” encoding scheme. If you’re not used to it, it’s quite confusing at first.</p>

<p>Each bitplan is a memory area that contains a single bit of the pixel index. Like, bitplan 0 contains all bits “0” of all the pixel indices. Bitplan 1 contains all bits 1, etc. As an exemple, the very first 2 bytes (16 bits) of bitplan 0 contain the bits “0” of the 16 first pixels of the screen.</p>

<p>When blitting a 16 colors bob, you have to run 4 complete blit operations. ( 1 per bitplan ).
If you want to blit a 8 colors bob, you just need to 3 blit operations ( 8 colors means 3bits per pixel, so 3 bitplans only to fill)</p>

<p>Here is the trick: As the N-1 bobs are drawn in the offscreen buffer to create a 1 color mask, you only need a single blit operation! So the (N-1) single color bob OR drawing in offscreen buffer is 4 times faster than drawing 4bitplans bobs!</p>



<p>Back in time you can connect your Atari or Amiga to any CRT TV. And various TVs had various image position &amp; scale setup. To guarantee graphics are visible, the 320x200 Atari image is in the middle of a very large “border”. You can notice the large white border all around:</p>

<p><img src="https://arnaud-carre.github.io/assets/img/4ktribute/st_screen.jpg" alt="Alt Text"/></p>

<p>The Atari video chip, in charge of generating the video signal, is called “Shifter”. It supports only 3 screen resolutions:</p>

<ol>
  <li>Low re: 320x200, 16 colors</li>
  <li>Medium res: 640x200, 4 colors</li>
  <li>High res: 640x400, monochrome (need a specific 70hz monitor)</li>
</ol>

<p>And two refresh rates:</p>

<ol>
  <li>50hz ( Europe )</li>
  <li>60hz ( U.S )</li>
</ol>

<p>The Shifter is quite basic and not programmable. There is <strong>no way</strong> to display graphics bitmap into this large safety border. It’s just <strong>not possible</strong>. Even Atari hardware engineers that created the video chip didn’t even think about it.</p>

<p>If something is not possible you can imagine freaks from the demoscene will try to break the limits :) In late 80, some pioneer demo crews like Level16, Sync, ST-Connexion and others did the impossible! They displayed bitmap graphics in the safety zone! How the hell does it work?</p>

<h2 id="fooling-the-hardware-with-smart-software">Fooling the hardware with smart software</h2>

<p>A classic scanline signal is made of 3 parts:</p>

<ol>
  <li>Start of the left safety border, no bitmap graphics is displayed</li>
  <li>Few cycles later, start of actual screen bitmap graphics decoding and display image</li>
  <li>When 320 pixels are displayed, stop bitmap decoding, and start of the right safety border</li>
</ol>

<p>Depending on the screen resolution and refresh rate, the shifter doesn’t build the exact same video signal. For instance, a low res 50Hz scanline is 512 cycles long, but a 60hz is 508 cycles. In high res, a scanline takes 224 cycles only.</p>

<p>To build the video signal each frame, the Shifter video chip is running a state machine. While generating the video signal, this state machine will tell the chip when to display the safety border, when to start to decode graphics, and when to stop to decode graphics.</p>

<p>Obviously this internal state machine isn’t documented. But thanks to the reverse engineering work or many people in the 90’ ( Alien, Troed, LjBK and others ) I can show you a high level view of the internal state machine of the video chip hardware:</p>

<div><div><pre><code><span>If</span> <span>res</span><span>=</span><span>high</span> <span>and</span> <span>time</span><span>=</span><span>0</span> <span>then</span> <span>start</span> <span>bitmap</span> <span>decoding</span>
<span>If</span> <span>rate</span><span>=</span><span>60</span> <span>and</span> <span>time</span><span>=</span><span>52</span> <span>then</span> <span>start</span> <span>bitmap</span> <span>decoding</span>
<span>If</span> <span>rate</span><span>=</span><span>50</span> <span>and</span> <span>time</span><span>=</span><span>56</span> <span>then</span> <span>start</span> <span>bitmap</span> <span>decoding</span>
<span>If</span> <span>res</span><span>=</span><span>high</span> <span>and</span> <span>time</span><span>=</span><span>160</span> <span>then</span> <span>stop</span> <span>bitmap</span> <span>decoding</span>
<span>If</span> <span>rate</span><span>=</span><span>60</span> <span>and</span> <span>time</span><span>=</span><span>372</span> <span>then</span> <span>stop</span> <span>bitmap</span> <span>decoding</span>
<span>If</span> <span>rate</span><span>=</span><span>50</span> <span>and</span> <span>time</span><span>=</span><span>376</span> <span>then</span> <span>stop</span> <span>bitmap</span> <span>decoding</span>
</code></pre></div></div>

<p><strong>Note:</strong> “time” here is the cycle position within a scanline (so modulo 512 cycles). When the video signal goes to the next scanline, the “time” var used here goes back to 0</p>

<p>This state machine is hardcoded in the chip, you can’t change it at all. But what if you can change the video rate and resolution like a maniac at very specific points during each scanline?</p>

<p>Look at the internal state machine that is ending a standard low res 50hz line:</p>
<div><div><pre><code><span>If</span> <span>rate</span><span>=</span><span>50</span> <span>and</span> <span>time</span><span>=</span><span>376</span> <span>then</span> <span>stop</span> <span>bitmap</span> <span>decoding</span>
</code></pre></div></div>

<p>What if at the exact cycle 376 position you force the rate to 60Hz? The hardware will “skip” the “if” statement, and continue to decode the bitmap graphics! As you skipped the state where the chip stops to decode the graphics line, you just opened the right safe zone border! Of course, you have to go back to 50hz as soon as you can to avoid distorting the signal too much.</p>

<p>Now what if you set the resolution to high at cycle 0? The internal state machine will start the graphics decoding. Your monitor is unable to display a high res image? No problem, just go back to low res at the next cycle and you’re good!</p>

<p>So here is a 68000 assembly code that is fooling the shifter hardware to get rid of left and right safety borders, just for one rasterline</p>

<div><div><pre><code>	<span>move</span><span>.</span><span>w</span>	<span>a4</span><span>,(</span><span>a4</span><span>)</span>		<span>// cycle 0: set the chip res to high to fool state machine!</span>
	<span>nop</span>
	<span>move</span><span>.</span><span>b</span>	<span>d6</span><span>,(</span><span>a4</span><span>)</span>		<span>// cycle 12: go back to low res to avoid any image distortion</span>
	<span>nop</span>
	<span>nop</span>
	<span>...</span>
	<span>...</span>		<span>// wait during exactly 364 cycles (until cycle 376)</span>

	<span>...</span>
	<span>nop</span>
	<span>nop</span>
	<span>move</span><span>.</span><span>b</span>	<span>d6</span><span>,(</span><span>a5</span><span>)</span>		<span>// cycle 376: set the rate to 60hz to fool state machine!</span>
	<span>move</span><span>.</span><span>w</span>	<span>a5</span><span>,(</span><span>a5</span><span>)</span>		<span>// cycle 384: get back to 50hz to avoid distortion</span>
	<span>nop</span>
	<span>...</span>					<span>// wait during exactly 112 cycles (for next scanline)</span>
	<span>nop</span>
</code></pre></div></div>
<p><em>Note: registers a4,d6 and a5 are pre-loaded with Atari specific address and values to change resolution and refresh rate</em></p>

<p>Of course you have to repeat this code snippet for every scanline you want to remove left and right border!</p>

<p><strong>Note:</strong> Same kind of trick allows you to get rid of the top and bottom safety empty borders. At the end, you get a new screen resolution of about 416x274 visible pixels instead of the classic 320x200!</p>

<p>To get an idea of the new resolution here is a picture of a fullscreen demo. A white rectangle has been drawn to show approximately a standard Atari 320x200 resolution.</p>

<p><img src="https://arnaud-carre.github.io/assets/img/4ktribute/st_full.jpg" alt="Alt Text"/></p>

<p><strong>Note:</strong> As the CPU should stay in sync with the video decoding, it’s often called “racing the beam” technique. (reference to old CRT monitors where an electron beam was really moving from left to right during each scanline). When you repeat the code snippet above 274 times, almost <strong>all</strong> your time frame is wasted to fool the video chip. If you want to run your own code, you have to put it within all the “nops” instructions.</p>

<h2 id="how-to-render-bobs-in-the-middle-of-that-mess">How to render bobs in the middle of that mess?</h2>

<p>Any atari fullscreen fx should execute this code for each of 274 visible scanlines! Without missing a single cycle! For your own demo code, you only have two free slices of 364 and 112 cycles per scanline! You have to cut and divide your work into plenty of 364 and 112 cycle pieces! Your code should take the same time (no dynamic branch). If one single cycle is missing, the complete screen display is fucked up!</p>

<p>Regarding the extended fullscreen resolution, the screen buffer size is now 60KiB! Around twice bigger than normal. If you want to animate stuff on screen, it means you have to move twice as much memory!</p>

<p>That’s why doing a demo in fullscreen on Atari is <strong>really challenging!</strong></p>



<p>Atari STE has a custom chip called “Blitter”. This chip can do in hardware what the “bit blit” algorithm from the 70s does. Common use is to move or combine bitmap graphics. Basically it can operate bitmap graphics from rectangular areas. It can also do bit shifting, and various bit operations (or, and, xor, not, etc.). Atari STE blitter is much simpler than Amiga blitter (1 source instead of 3, not line drawing, no xor filling ) but still efficient. In the early days, people considered STE blitter almost useless. The amount of registers to set up before blitting is huge, so it wasn’t very efficient for small bitmaps. ( setup time was longer than proper blit operation).</p>

<p>Anyway STE Blitter can be a very efficient friend when used properly. Let’s see how a STE blitter 16 colors masked bob classic code works.</p>

<h2 id="drawing-a-bob">Drawing a Bob</h2>

<p>A blitter only operates on words of 16 bits. Bitplan layout makes everything aligned to 16 pixels. As we want to draw bobs at any horizontal position (and not only 16 pixels aligned) we could use the blitter “shift”. And because of that we should also use one additional 16 pixels column. The final bob screen area will be 80x64 pixels</p>

<p><img src="https://arnaud-carre.github.io/assets/img/4ktribute/5words.gif" alt=" Alt Text"/></p>

<h2 id="blitter-cost">Blitter cost</h2>

<p>What’s the cost of a blit OR operation on an 80x64 and 1 bitplan area? Let’s count the amount of 16bits words in the bob single bitplan mask: 5*64=320 words. Atari memory access timing is very easy: each word read or write is 4 cycles.</p>

<p>As we use a OR operation, the blitter have to do 3 memory access per bob bitmap word:</p>
<ol>
  <li>Read the bob source data word from memory to internal register</li>
  <li>Read the background data word from memory and OR it into internal register</li>
  <li>Write the result back to the destination memory</li>
</ol>

<p>Those 3 access takes 3*4=12 cycles. So the total cost is 5*64*12=3840 cycles. As a comparison, the electron beam takes 512 cycles to scan a line. So this 1 bitplan bob OR on screen is taking 7.5 scanlines of time. (Back in time we used to count timing in “scanlines”).</p>

<h2 id="blitter-and-fullscreen">Blitter and fullscreen</h2>

<p>Earlier we saw that we should slice all our code into small pieces of <strong>364</strong> and <strong>112</strong> cycles. When Atari blitter is running, the CPU is halted ( they don’t run in parallel ). So we have to “slice” the bob drawing into several small blitter commands. We could slice the bob in Y lines. The 1 bitplan OR takes 12*5=60 cycles for a 5 words bob line. The minimal blitter setup and run code is taking 28 cycles:</p>

<div><div><pre><code>	<span>move</span><span>.</span><span>w</span>	<span>#</span><span>n</span><span>,(</span><span>a2</span><span>)</span>	  <span>// set n number of lines to blit ( 12 cycles )</span>
	<span>move</span><span>.</span><span>w</span>	<span>d7</span><span>,(</span><span>a3</span><span>)</span>		<span>// start the blit operation ( 16 cycles )</span>
</code></pre></div></div>
<p>How many bob lines can we blit in the longest slice of 364 cycles?</p>

<p>(364-28)/60 = 5.6 lines. As you can only blit an integer number of lines, we can run the blitter for 5 bob lines. It will cost 5*60+28=328 cycles over our 364 cycles slice.</p>

<p>Applying the same for the second slice of 112 cycles we got</p>

<p>(112-28)/60 = 1.4 so 1 single bob line. We can use this fullscreen code block to blit 6 lines of the 1 bitplan bob during one scanline.</p>

<div><div><pre><code>	<span>move</span><span>.</span><span>w</span>	<span>a4</span><span>,(</span><span>a4</span><span>)</span>		<span>// open left border</span>
	<span>nop</span>
	<span>move</span><span>.</span><span>b</span>	<span>d6</span><span>,(</span><span>a4</span><span>)</span>		<span>// back to low res</span>
	<span>move</span><span>.</span><span>w</span>	<span>#</span><span>5</span><span>,(</span><span>a2</span><span>)</span>		<span>// blitter line count set to 5 (80x5 pixels)</span>
	<span>move</span><span>.</span><span>w</span>	<span>d7</span><span>,(</span><span>a3</span><span>)</span>		<span>// run the blitter </span>
	<span>nop</span>					<span>// 9 nops (wait for 36 cycles)</span>
	<span>nop</span>
	<span>nop</span>
	<span>nop</span>
	<span>nop</span>
	<span>nop</span>
	<span>nop</span>
	<span>nop</span>
	<span>nop</span>
	<span>move</span><span>.</span><span>b</span>	<span>d6</span><span>,(</span><span>a5</span><span>)</span>		<span>// cycle 376: open right border</span>
	<span>move</span><span>.</span><span>w</span>	<span>a5</span><span>,(</span><span>a5</span><span>)</span>		<span>// back to 50hz</span>
	<span>move</span><span>.</span><span>w</span>	<span>#</span><span>1</span><span>,(</span><span>a2</span><span>)</span>		<span>// set next blitter line count (for 80x5 pixels)</span>
	<span>move</span><span>.</span><span>w</span>	<span>d7</span><span>,(</span><span>a3</span><span>)</span>		<span>// run the blitter </span>
	<span>nop</span>					<span>// 6 nops (wait 24 cycles)</span>
	<span>nop</span>
	<span>nop</span>
	<span>nop</span>
	<span>nop</span>
	<span>nop</span>
</code></pre></div></div>

<p>To draw our 64 lines height bob, we need to repeat this fullscreen code block 11 times. 10 first are drawing 60 lines of the bob, and the last code block should just set up blitter to draw the 4 last bob lines. So the real amount of time we spent to draw the bob is 11 scanlines of 512 cycles each = 5636 cycles.</p>

<h2 id="optimise-use-the-vertical-blitter">Optimise, use the vertical blitter!</h2>

<p>So we need 11 raster lines of time to draw the 64 lines bob in 1 bitplan. Can we do better? Yes! The first idea is to restart the blitter as soon as the previous work is done. Like, after drawing 5 lines, we could start the blitter to start “half of a bob line” maybe, to fill the time slice more efficiently? Unfortunately you can’t do that. Blitting a “part of the bob line” would imply you to set up tons of different blitter registers, such as line width, source line stride, dest line stride. It’s not worth it.</p>

<p>Around 2015 I did a lot of blitter in fullscreen <a href="https://www.pouet.net/prod.php?which=66702" target="_blank">for the -We Were @- demo</a>. And I figured out an efficient technique to better fill the fullscreen time slices with the blitter. I called this technique “vertical blitter”. The idea is to draw the bob using vertical blocks of 16*N pixels. By doing this, the granularity of a blitter command will be 12 cycles (instead of 60 cycles for a complete bob line of 5 words).</p>

<p>The bob is drawn on screen using various size of vertical 16xN pixels strips:</p>

<p><img src="https://arnaud-carre.github.io/assets/img/4ktribute/vertical_blit.gif" alt=" Alt Text"/></p>

<p>Let’s rewrite the code using this technique. Now the blitter is setup to run on blocks of 16xN pixels, vertically</p>

<div><div><pre><code>	<span>move</span><span>.</span><span>w</span>	<span>a4</span><span>,(</span><span>a4</span><span>)</span>		<span>// open left border</span>
	<span>nop</span>
	<span>move</span><span>.</span><span>b</span>	<span>d6</span><span>,(</span><span>a4</span><span>)</span>		<span>// back to low res</span>
	<span>move</span><span>.</span><span>w</span>	<span>#</span><span>28</span><span>,(</span><span>a2</span><span>)</span>	<span>// blitter line count set to 28 (16x28 pixels)</span>
	<span>move</span><span>.</span><span>w</span>	<span>d7</span><span>,(</span><span>a3</span><span>)</span>		<span>// run the blitter </span>
	<span>move</span><span>.</span><span>b</span>	<span>d6</span><span>,(</span><span>a5</span><span>)</span>		<span>// cycle 376: open right border</span>
	<span>move</span><span>.</span><span>w</span>	<span>a5</span><span>,(</span><span>a5</span><span>)</span>		<span>// back to 50hz</span>
	<span>move</span><span>.</span><span>w</span>	<span>#</span><span>7</span><span>,(</span><span>a2</span><span>)</span>		<span>// set next blitter line count (for 16x7 pixels)</span>
	<span>move</span><span>.</span><span>w</span>	<span>d7</span><span>,(</span><span>a3</span><span>)</span>		<span>// run the blitter </span>
</code></pre></div></div>

<p>In one raster line of time we draw a vertical bob column of 16*(28+7) pixels.</p>

<p>Devil is in details, once we have drawn a 16*64 pixels bob we have to reset the blitter destination address to proceed to the next bob column. So we need few instructions in between, and it will mess up the fullscreen timing a bit. Writing that kind of code manually is painful</p>

<h2 id="generating-code">Generating code!</h2>

<p>If you look at my 4KiB intro, there is also a colourful background. It’s done by changing the background color every 3 scanlines. Again, it means you have to add an instruction every 3 scanlines to change the background color. And it will change all other blitter commands. Last but not least, the high level algorithm requires to change the blitter setup during the frame ( to clear the oldest mask bob, then to draw 1 bitplan bob, then to apply the mask into a 4 bitplans background. Then draw the final fully masked 4 bitplan bob)</p>

<p>To do this, I did a C program to generate a 68000 assembly code, doing all the nasty timing computation for me. It generates a 4000 lines assembly source file with the right blitter commands, at the right place in between the fullscreen resolution &amp; refresh rate change. Here are just a few lines of the generated source code so you can get how every cycle is counted. Also how the fullscreen hardware fooling code should explicitly fall at 0 and 376 cycle. If only one is missing, you won’t see anything on screen but garbage.</p>

<div><div><pre><code>	<span>move</span><span>.</span><span>w</span>	<span>#</span><span>7</span><span>,(</span><span>a2</span><span>)</span>	<span>// set blitter line count to 7	// [12 cycle]</span>
	<span>move</span><span>.</span><span>w</span>	<span>d7</span><span>,(</span><span>a3</span><span>)</span>	<span>// run blitter	// [100 cycle]</span>
<span>// Raster line 42 [0]</span>
	<span>move</span><span>.</span><span>w</span>	<span>a4</span><span>,(</span><span>a4</span><span>)</span>	<span>// cycle 0: set high res, open left border	// [8 cycle]</span>
	<span>nop</span>	<span>// [4 cycle]</span>
	<span>move</span><span>.</span><span>b</span>	<span>d6</span><span>,(</span><span>a4</span><span>)</span>	<span>// back to low res	// [8 cycle]</span>
	<span>move</span><span>.</span><span>w</span>	<span>#</span><span>28</span><span>,(</span><span>a2</span><span>)</span>	<span>// set blitter line count to 28	// [12 cycle]</span>
	<span>move</span><span>.</span><span>w</span>	<span>d7</span><span>,(</span><span>a3</span><span>)</span>	<span>// run blitter	// [352 cycle]</span>
	<span>move</span><span>.</span><span>b</span>	<span>d6</span><span>,(</span><span>a5</span><span>)</span>	<span>// cycle 376, set 60hz to open right border	// [8 cycle]</span>
	<span>move</span><span>.</span><span>w</span>	<span>a5</span><span>,(</span><span>a5</span><span>)</span>	<span>// back to 50hz	// [8 cycle]</span>
	<span>move</span><span>.</span><span>w</span>	<span>#</span><span>5</span><span>,(</span><span>a2</span><span>)</span>	<span>// set blitter line count to 5	// [12 cycle]</span>
	<span>move</span><span>.</span><span>w</span>	<span>d7</span><span>,(</span><span>a3</span><span>)</span>	<span>// run blitter	// [76 cycle]</span>
	<span>nop</span>	<span>// [4 cycle]</span>
	<span>nop</span>	<span>// [4 cycle]</span>
	<span>move</span><span>.</span><span>w</span>	<span>(</span><span>a1</span><span>)</span><span>+</span><span>,</span><span>$</span><span>ffff8240</span><span>.</span><span>w</span>	<span>// change background color	// [16 cycle]</span>
<span>// Raster line 43 [0]</span>
	<span>move</span><span>.</span><span>w</span>	<span>a4</span><span>,(</span><span>a4</span><span>)</span>	<span>// cycle 0: set high res, open left border	// [8 cycle]</span>
	<span>nop</span>	<span>// [4 cycle]</span>
	<span>move</span><span>.</span><span>b</span>	<span>d6</span><span>,(</span><span>a4</span><span>)</span>	<span>// back to low res	// [8 cycle]</span>
	<span>move</span><span>.</span><span>w</span>	<span>#</span><span>23</span><span>,(</span><span>a2</span><span>)</span>	<span>// set blitter line count to 23	// [12 cycle]</span>
	<span>move</span><span>.</span><span>w</span>	<span>d7</span><span>,(</span><span>a3</span><span>)</span>	<span>// run blitter	// [292 cycle]</span>
	<span>move</span><span>.</span><span>w</span>	<span>(</span><span>a0</span><span>)</span><span>+</span><span>,</span><span>d1</span>		<span>// dst	// [8 cycle]</span>
	<span>move</span><span>.</span><span>w</span>	<span>(</span><span>a0</span><span>)</span><span>+</span><span>,</span><span>d0</span>		<span>// src	// [8 cycle]</span>
	<span>// bitplan #0</span>
	<span>move</span><span>.</span><span>w</span>	<span>d0</span><span>,</span><span>$</span><span>ffff8a26</span><span>.</span><span>w</span>	<span>// [12 cycle]</span>
	<span>move</span><span>.</span><span>w</span>	<span>d1</span><span>,</span><span>$</span><span>ffff8a34</span><span>.</span><span>w</span>	<span>// [12 cycle]</span>
	<span>move</span><span>.</span><span>w</span>	<span>#</span><span>8</span><span>,(</span><span>a2</span><span>)</span>	<span>// set blitter line count to 8	// [12 cycle]</span>
	<span>nop</span>	<span>// [4 cycle]</span>
	<span>nop</span>	<span>// [4 cycle]</span>
	<span>move</span><span>.</span><span>b</span>	<span>d6</span><span>,(</span><span>a5</span><span>)</span>	<span>// cycle 376, set 60hz to open right border	// [8 cycle]</span>
	<span>move</span><span>.</span><span>w</span>	<span>a5</span><span>,(</span><span>a5</span><span>)</span>	<span>// back to 50hz	// [8 cycle]</span>
</code></pre></div></div>

<p>This is just a small part. If you’re curious, the complete assembly source code for blitter rendering this 4KiB intro can be seen here:</p>

<p><a href="https://github.com/arnaud-carre/arnaud-carre.github.io/blob/main/assets/img/4ktribute/fullscreenCode.asm" target="_blank">Have a look at the generated 4000 lines fullscreen blitter code</a></p>



<p>This post is long enough to stop here. I hope you enjoyed reading it, and maybe learned something as a bonus!</p>

<p>I may do a second post to talk about</p>
<ul>
  <li>How to fit the 2 minutes music into the 4KiB intro</li>
  <li>How to fit the code (esp the 4000 lines assembly source) in 4KiB</li>
  <li>Some words about best practice to please your face exe packer</li>
</ul>

<p>Knowing good tricks on old machines sometimes could inspire you to invent some new techniques on modern hardware!</p>

<p><a href="https://twitter.com/leonard_coder" target="_blank">Follow me on Twitter</a></p>

      </article></div>
  </body>
</html>
