<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.unix.dog/~yosh/blog/c-habits-for-me.html">Original</a>
    <h1>Some C habits I employ for the modern day</h1>
    
    <div id="readability-page-1" class="page"><div>


<p>posted <time>2026-01-17T21:02:00Z</time></p><p>modified <time>2026-01-17T23:20:00Z</time></p>
<p>Despite it being the first “proper” programming language I learned–by reading K&amp;R front-to-back no less–I don’t write C too terribly often nowadays. Playing <a href="https://resonite.com">resonite</a> has gotten me into writing a load of C# for modding the game, and most of what I do day-to-day is automating the tedium on my computer, which gets delegated to shell or python because of all the existing infrastructure.</p>
<p>Alas, every now and then, something arises where I have to or just want to write some C (or C++). Sometimes it’s when <a href="https://git.unix.dog/yosh/bc7enc_rdo_ffi/src/branch/master/ffi.cpp">I need to make some bindings for a library</a>; sometimes it’s <a href="https://git.unix.dog/yosh/blsm">to fill a niche of a language/architecture gap</a>. It also remains as my favorite language to prototype stuff in, though I’m not quite sure why.</p>
<p>In any case, C is an interesting language without much standardization on the whole “style” or “practices” part. Most other languages have very clear “this is the best way to use X” messages, either subtly embedded in the syntax itself or through “official” documentation channels. C doesn’t have an official documentation channel, nor does it have syntax or standard library constructs that encourage one particular way of doing things. From this, there’s a bunch of inconsistencies in how people do things, and–especially in the early days of the language and standard library–the landscape and general practice is quite error prone. As such, I’ve developed my own habits when writing C, usually picked up from blog posts, writing C# or rust, or just out of perfectionist brain.</p>
<p>I’m not saying you should write stuff this way, nor am I claiming it is the best way to write C all the time. I break some of these practices when working with embedded systems or when I’m writing things to be as fast as they can possibly be. But it is the baseline I tend to start with for most projects, and if I don’t write it down, I’ll never be consistent with it.</p>
<section id="the-basics">
<h2>the basics</h2>
<p>I usually use C23 for my new C projects. When contributing to other projects, I of course use their revision, but C23 enables a fair amount of the things possible in this post, so it’s what I stick with for projects that aren’t trying to target absolute maximum portability or embedded architectures (i.e. I’d only care about GCC, clang, and <em>maybe</em> MSVC). almost every platform, including any POSIX-compliant one, <a href="https://en.wikipedia.org/wiki/C_data_types#Main_types">has <code>CHAR_BIT</code> set to <code>8</code></a>, so I like to make it explicitly clear that this is what the project is for by putting this in there:</p>
<pre><code>#if CHAR_BIT != 8
	#error &#34;CHAR_BIT != 8&#34;
#endif
</code></pre>
<p>Something very small that I liked a <em>lot</em> when learning rust was its short way of referring to fixed-length types. Combine that with <a href="https://nullprogram.com/blog/2023/10/08/">chris wellon’s other typedefs</a> and I end up having all these <code>typedef</code>s in my projects:</p>
<pre><code>typedef uint8_t   u8;
typedef int8_t    i8;
typedef int16_t   i16;
typedef uint16_t  u16;
typedef int32_t   i32;
typedef uint32_t  u32;
typedef uint64_t  u64;
typedef float     f32;
typedef double    f64;
typedef uintptr_t uptr;
typedef ptrdiff_t isize;
typedef size_t    usize;
</code></pre>
<p>You may notice that the <code>byte</code> and <code>b32</code> from wellon’s post are missing here. As said before, when employing this style, I don’t care for systems where char isn’t 8 bit, so the distinction between <code>u8</code> and <code>char</code> doesn’t mean anything to me here. Additionally, the intent of whether the buffer is used as “raw” memory chunks versus a meaningful <code>u8</code> is pretty clear from the code that it gets used in, so I’m not worried about confusing intent with it.</p>
<p><code>b32</code> is missing because I just use the C23 <code>bool</code> type. If I’m working with &gt;=C99, I use <code>stdbool.h</code> and <code>bool</code>. Its semantics are familiar to me already, and it just feels more right to use for, well, booleans.</p>
<p>I’ve long been employing the length+data string struct. If there was one thing I could go back and time to change about the C language, it would be removal of the null-terminated string. Alas, we do not live in the perfect world, so I work with this for now:</p>
<pre><code>typedef struct {
	// includes null terminator (for bad functions)
	u8 *data;
	// excludes null terminator (for copying memory)
	isize len;
} String;
</code></pre>
<p>Along with some functions to initialize from an existing cstr or buffer, copy the string safely, etc.</p>
</section>
<section id="parsing-not-validating">
<h2>parsing, not validating</h2>
<p>I think one of the most eye-opening blog posts I read when getting into programming initially was the evergreen <a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/">parse, don’t validate</a> post. If you haven’t read it yourself, I highly encourage you to do so. The TL;DR of it is to work with your language’s type system to the fullest extent, making function signatures take very strict types that can only really be created through trusted interfaces that you provide. In doing so, you get to have an incredibly robust API with very clear, usually compile-time indications when something goes wrong.</p>
<p>I was thinking about how to apply this sort of philosophy to C for a bit–I knew that the most flexible and strong part of C’s comparatively weak type system is the humble <code>struct</code>–but I didn’t know how to go about the whole “can only really be created through trusted interfaces” bit and promptly put it out of my mind when working with C. A few years later, I saw someone link it again on the web, and curiously looked up to see if anyone else tried applying it to C. This took me to <a href="https://www.lelanthran.com/chap13/content.html">lelanthran’s blog post</a> that talks about it, where I learned that you <em>can</em> in fact <a href="https://www.lelanthran.com/chap9/content.html">create arbitrary opaque types</a> and thus properly employ this style.</p>
<p>I was going to embed an in-progress rewrite I’m doing of <a href="https://git.unix.dog/yosh/blsm">blsm</a> that employs this principle, but I accidentally overwrote most of the code via a mishap with syncthing. Oops. So, you’ll just have to trust me when I say that I actually do this nowadays for non-playground projects :)</p>
</section>
<section id="tuples">
<h2>tuples!</h2>
<p>One of the more exciting changes of C23 is the explicit standardization that tagged types (<code>struct</code>, <code>union</code>, <code>enum</code>) with the same name and contents <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3037.pdf">are completely compatible with one another</a>. Oftentimes, I wish to return multiple values from a function, but feel as if there’s not much semantic need to assign explicit names to the structure or the members within. Enter the humble tuple:</p>
<pre><code>#define Tuple2(T1, T2)           \
	struct Tuple2_##T1##_##T2 {  \
		T1 a;                    \
		T2 b;                    \
	}
</code></pre>
<p>Others may use different names for the members–I’ve seen <code>_0</code>, <code>_1</code>, etc. To roughly mirror rust’s semantics, but I find that a little awkward. The english alphabet is more than familiar to me, so it’s what I’ve stuck to.</p>
<p>Unfortunately, as one might have noticed, this cool feature gets severely limited by the fact that this does <em>not</em> apply to <em>anonymous</em> tagged types (I’d personally consider “untagged” tagged types with the same content to be compatible, but I guess WG13 disagrees). As such, every instance of this feature requires an actual name to be bound to the type. This means that pointers will throw a wrench into it:</p>
<pre><code>$ cc kmp.c
In file included from kmp.c:5:
kmp.c: In function &#39;main&#39;:
kmp.c:29:20: error: pasting &#34;*&#34; and &#34;_&#34; does not give a valid preprocessing token
   29 |         Tuple2(char*, int) buffer;
      |                    ^
../common/tuple.h:5:25: note: in definition of macro &#39;Tuple2&#39;
    5 |         struct Tuple2_##T1##_##T2 {  \
      |                         ^~
</code></pre>
<p>This can be worked around by either making a <code>typedef</code> for the pointer or by <a href="https://old.reddit.com/r/C_Programming/comments/1cmqqgw/c23_makes_errors_awesome/l34lutg/?context=3#l34lutg">having the user provide an explicit name for the struct</a>. Neither are exactly the most ergonomic, so I don’t find myself using this feature as much as I wish.</p>
<p>In any case, for tuples specifically, I’m usually not storing a pointer in them. When it gets to that point, I probably want an actual struct with semantic meaning instead.</p>
</section>
<section id="returning-results">
<h2>returning results</h2>
<p>With the idea of trying to encode as much as possible in the type system itself, I’m a pretty big fan of <a href="https://en.wikipedia.org/wiki/Tagged_union">sum types</a> when it makes sense for the language to have them. Naturally, I try to employ using them in C.</p>
<p>In the absence of proper language support, “sum types” are just structs with discipline. These structs will usually be used for public-facing apis and/or have semantic meaning in their own right, so I’m more comfortable making them a typedef as opposed to trying to fuddle in a “result” type into this whole equation. Maybe if C ever allows anonymous tagged types to be compatible will this change, but for now it’s what I have to work with.</p>
<p>The structures generally follow this pattern:</p>
<pre><code>typedef enum {
	...
} ErrorCode;

typedef struct {
	char *val;
} SafeBuffer;

typedef struct {
	bool ok;
	union {
		SafeBuffer *val;
		ErrorCode err;
	};
} MaybeBuffer;
</code></pre>
<p>Along with functions to handle printing error messages/etc. For the various error codes that can be returned. The idea is for the caller to always check the <code>ok</code> upon return. You could probably add on a “match” function to specifically handle this without the ability to actually introspect on the struct like before, but that’s incredibly verbose and poor ergonomically in my opinion–this is all compensation for the lack of proper sum types anyway.</p>
<p>When these result types are combined with the previous “parse, don’t validate” approach, I find that I don’t actually dread handling errors in C. If I encounter a function that I know “parses” something, I know it’s going to return a <code>Maybe</code> struct and check <code>ok</code>. If I’m implementing a function that <em>uses</em> one of those <code>SafeBuffer</code> types, I know that there are certain invariants that I can assume to be true, since that type could have only been created through the parsing function.</p>
<p>It sacrifies a bit of verbosity (since C lacks all the nice functional syntax sugar that makes this concise) for much nicer flowing (and safer!) programs</p>
</section>
<section id="on-dynamic-memory-management">
<h2>on dynamic memory management</h2>
<p>I don’t personally do things that require dynamic memory management in C often, so I don’t have many practices for it. I know that wellons &amp; co. Have been really liking the arena, and I’d probably like it too if I actually used the heap often. But I don’t, so I have nothing to say.</p>
<p>If I find myself needing a bunch of dynamic memory allocations and lifetime management, I will simply start using another language–usually rust or C#. But I also don’t find myself programming that kind of stuff often <em>in general</em>, so it’s really just something I need to explore more as a whole.</p>
</section>
<section id="anything-else">
<h2>anything else?</h2>
<p>A few smaller things:</p>
<ul>
<li>
I tend to avoid the <code>string.h</code> functions most of the time, only employing the <code>mem</code> family when I want to, well, mess with memory.
</li>
<li>
other than that, I only use the standard library <em>in general</em> when I need to do OS functions–I find that a lot of the apis are <a href="https://youtu.be/Sg4U4r_AgJU?t=150">less than ideal to work with</a> and usually prefer to just reimplement needed ones.
</li>
</ul>
<p>There isn’t much else that I really feel the need to mention. I check the documentation for any external functions I use–because there’s always a wrench that can hide in <code>man</code>–and <em>try</em> to check any nontrivial accesses or funky stuff that might need to be done. Maybe I’ll try to go about making a sort of “slice” type to make that stuff safer, but for now, nothing’s bitten me just yet.</p>
<p>I hope this can get anyone to try thinking about their own C style. I love this language a lot of times yet hate it many other times. At least the limitations can make for some fun problems to solve and safeguards to create :)</p>
</section>
<p><a href="https://www.unix.dog/~yosh/blog/index.html">back</a></p>
</div></div>
  </body>
</html>
