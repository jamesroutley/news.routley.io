<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.amplifypartners.com/blog-posts/why-tigerbeetle-is-the-most-interesting-database-in-the-world">Original</a>
    <h1>TigerBeetle is a most interesting database</h1>
    
    <div id="readability-page-1" class="page"><div><p>By many measures it’s safe to say that TigerBeetle is the most interesting database in the world. Like Costanza in Seinfeld, they seem to do the <em>opposite</em> of everyone else:</p><ul role="list"><li>Most teams write code fast. TigerBeetle tries to <strong>write code slow</strong>.</li><li>Most teams treat testing as a necessary evil. TigerBeetle is <strong>built entirely on Deterministic Simulation Testing (DST)</strong>.</li><li>Most teams build their software on top of loads of other software. TigerBeetle <strong>has zero dependencies</strong>.</li></ul><p>There’s even more. TigerBeetle enforces static memory allocation. They keep assertions enabled in production. They chose Viewstamped Replication over Raft, and even Zig instead of Rust!</p><p>This read is going to go behind the scenes of how TigerBeetle came to be, the incredibly novel software they’ve built, and all of the wacky, wonderful things that make them so special. Based on extensive interviews with the TigerBeetle team, we’re going to cover a few topics in technical detail:</p><ul role="list"><li>Why transactional databases should think in debits and credits, not SQL</li><li>An (actually) modern database: distributed by default, handling storage faults, and why TigerBeetle uses Zig</li><li>VOPR, TigerBeetle’s Deterministic Simulation Testing cluster</li><li>TigerStyle, and why you should use assertions</li></ul><p>Click on any section to jump straight there, if you’re curious.  </p><h2><strong>Why we need a database that thinks in debits and credits</strong></h2><p>TigerBeetle’s website calls it “The Financial Transactions Database.” Its primitives are <strong>debits and credits</strong>, which are things you may be familiar with from your accounting requirement in college. And if you’re not a bank, you’re probably thinking this whole thing isn’t really for you. But Joran (TigerBeetle’s creator) would tell you otherwise: financial transactions, i.e. debits and credits, are actually <em>exactly</em> what transactional SQL was originally designed for. </p><p>Way back in 1985, Jim Gray (who would later win a Turing Award) wrote a seminal paper on transactions, titled <a href="https://jimgray.azurewebsites.net/papers/AMeasureOfTransactionProcessingPower.pdf">A Measure of Transaction Processing Power</a>. If you’ve heard of it before, it’s because in it, Gray defined a metric that 40 years later is <em>still</em> the most important measure for a database: <strong>TPS</strong>, or transactions per second. This would end up leading to such a fervent benchmark war among databases that an objective <em>council</em> – <a href="https://www.tpc.org/information/about/history5.asp">the TPC</a> – needed to be formed to moderate.</p><figure><p><img src="https://cdn.prod.website-files.com/67ebc022dbceaf64bee0f5c6/68daca1c7780ffd190f23346_3d394e75.png" loading="lazy" alt=""/></p><figcaption><em>The TPC in action, deciding on whether a young database had gone to the Dark Side (Oracle).</em> </figcaption></figure><p>But what does the “T” in TPS actually mean? What is a transaction?</p><p>Your first guess might be a SQL transaction, but that’s not it. Gray actually defined it as a <strong>business transaction</strong> derived from the real world. Which is the reason databases were invented in the first place: to power businesses. And indeed, <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2005/04/tr-2005-39.doc">20 years later</a>, Gray continued to see the standard measure of transaction processing as a “DebitCredit:”</p><blockquote><em>“A database system to debit a bank account, do the standard double-entry bookkeeping and then reply to the terminal.”</em></blockquote><p>Mind you, SQL had already been around since the 70s at this point. And yet the luminary Gray still chose the debit/credit model – because it was the <em>canonical example</em> of an everyday transaction. Debit/credit is the lingua franca of <a href="https://www.youtube.com/watch?v=lGyMiW6PnKI&amp;ab_channel=TuringAwardeeClips"><strong>what it means to transact</strong></a>. It is <em>not</em> just for accounting and banks. It’s the reason for a database to provide guarantees like ACID in the first place.</p><p>And yet, if you want to use a SQL database to implement debits and credits today, you are probably going to have a bad time. To handle one debit/credit, a typical system – like the <a href="https://mojaloop.io/">central bank switch</a> that Joran consulted on in 2020 – needs to query account balances, lock those rows, wait for decisions in code, then write back and record the debit/credit. All in all, you’re looking at <strong>10-20 SQL queries</strong> back and forth, while holding row locks across the network roundtrip time, <em>for each transaction</em>. This gets even worse when you consider the problem of hot rows, where many transactions often need to touch the same set of “house accounts”. </p><p>All the while (for better or worse), the world is moving faster and faster towards an “everything is a transaction” model. Countries like India and Brazil are doing billions of transactions per month in instant payments. With <a href="https://www.frbservices.org/financial-services/fednow">FedNow</a> in the U.S., we’re not far away from that reality either. Meanwhile, other sectors like energy, gaming, and cloud are all moving towards real-time billing. In less than a decade, the world has become at least three orders of magnitude more transactional. And yet the SQL databases we still use to power this are 20-30 years old. Can they hold up?</p><p><strong>This is where TigerBeetle comes in</strong>. They designed a state-of-the-art database, from the ground up, to power the next era of transactions. In TigerBeetle, a debit/credit is a first class primitive and 8,190 of them can pack into a single 1MiB query via a one solitary roundtrip to the database. They call it <a href="https://www.youtube.com/watch?v=yKgfk8lTQuE">“The 1000x Performance Idea,”</a> but in Joran’s words it’s “nothing special”.</p><p>They say databases take a decade to build. But TigerBeetle is complete and pretty much <a href="https://jepsen.io/analyses/tigerbeetle-0.16.11">Jepsen-proof</a> after just 3 and a half years. In June 2025, Kyle Kingsbury showed he was unable to break TigerBeetle’s foundations (he found 1 correctness bug in the read query engine, not affecting durability), even while corrupting the whole thing on every machine in various places. </p><p>The obvious question here – <strong>how</strong>? How did TigerBeetle ship a production-ready, Jepsen-passing consensus and storage engine in 3.5 years when it typically takes a decade or more?</p><h2><strong>An (actually) modern database: distributed by default, why TigerBeetle uses Zig, and handling storage faults</strong></h2><p>Imagine you wake up today and wisely decide to build a database from scratch. Instead of investing in the technology of 30 years ago – when the most popular relational databases today were built – you can pick <em>any</em> advancements in architecture, hardware, language, or research since then to implement. How would you build it? What would you utilize?</p><h3><strong>Distributed by default</strong></h3><p>One thing you’d probably start with is the deployment model. </p><p>When Postgres and MySQL were built, in a world of big iron (on-prem hardware), the dominant paradigm was <strong>single node</strong>. Now, in a world of shared cloud hardware, it’s <strong>distributed</strong>. It’s not safe enough to store your transactions only on a single disk or server. A modern database needs to replicate your transactions, with strict serializability, across machines, for redundancy, fault tolerance and high availability. And yet some of the most popular OLTP databases in the world today are still highly dependent on a single node architecture. Automated failover, at least with zero data loss in the cut over, is not always baked in by default.</p><p>So TigerBeetle built their database to be distributed by default. Doing that comes with some of the obvious things you need to do, like consensus. But the developer experience for running TigerBeetle distributed is very simple: you just install the binary on however many machines you want in the cluster. No async replication, no Zookeeper, etc. To make this possible, TigerBeetle invested heavily in their consensus protocol implementation, adopting the pioneering <a href="https://pmg.csail.mit.edu/papers/vr.pdf">Viewstamped Replication</a> from MIT. This is part of why TigerBeetle has zero dependencies, apart from the Zig toolchain — they literally invested in all their core dependencies.</p><h3><strong>Clock fault tolerance</strong></h3><p>Distributed by default also shows up in some unlikely places. For example: have you ever thought of a clock fault model? </p><p>Though it’s not technically required or advised for consensus – which uses logical clocks and not physical clocks – remember that TigerBeetle is a <em>transactions</em> database. The physical timestamps of transactions need to be accurate and comparable across different financial systems for auditing and compliance.</p><p>And here, readers will note that Linux has several clocks: <code>CLOCK_MONOTONIC_RAW</code>, <code>CLOCK_MONOTONIC</code> and <code>CLOCK_BOOTTIME</code>. All have slight but important differences. Which is the best monotonic clock to use? (clue: It doesn’t say <code>MONOTONIC</code> on the tin)</p><p>The challenge is that physical imperfections in hardware clocks cause clocks to tick at different speeds, so that time passes faster or slower than it should. These kinds of “drift” errors eventually add up to significant “skew” errors within a short space of time. Most of the time, Network Time Protocol (NTP) would correct for these errors. But if NTP silently stops working because of a partial network outage, then a highly available consensus cluster might otherwise be running blind, in the dark.</p><p>But even this is something TigerBeetle thought about. They combine <em>the majority of clocks</em> in the cluster to construct a fault-tolerant clock called “cluster time”. This cluster time then gets used to bring a server’s system time back into line if necessary, or shut down safely if TigerBeetle detects that there are too many faulty clocks (e.g. TigerBeetle can actually detect when something like Chrony, PTP, or NTP have stopped working and alert the operator). </p><p>They do this by tracking offset clock times between different TigerBeetle servers, sampling them, and passing them through <a href="https://en.wikipedia.org/wiki/Marzullo%27s_algorithm">Marzullo’s algorithm</a> to estimate the most accurate possible interval (again, just to get a sense of whether clocks are being synced by the underlying clock sync protocol correctly).</p><p>Small things like this are exactly why distributed by default is hard, and doesn’t work as an add-on for older database models. You can read more about this in TigerBeetle&#39;s <a href="https://tigerbeetle.com/blog/2021-08-30-three-clocks-are-better-than-one/">3 clocks are better than one</a> blog post.</p><p>‍</p><h3><strong>Handling storage faults</strong></h3><p>Another piece of “distributed by default” that deserves its own header is how TigerBeetle handles <strong>storage faults</strong> (or even the fact it handles them at all). Traditional databases assume that if disks fail, they do so predictably with a nice error message. For example, even <a href="https://www.sqlite.org/atomiccommit.html">SQLite’s docs</a> are clear that:</p><blockquote><em>SQLite does not add any redundancy to the database file for the purpose of detecting corruption or I/O errors. SQLite assumes that the data it reads is exactly the same data that it previously wrote.</em></blockquote><p>In reality, there are many more sinister possibilities: disks can silently return corrupt data, misdirect I/O (on the read or write path), or just suddenly get really slow (called <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2017/06/paper-1.pdf">gray failure</a> in the research), all without returning error codes. </p><p>TigerBeetle is built to be storage fault tolerant:</p><ul role="list"><li>TigerBeetle uses <a href="https://www.usenix.org/conference/fast18/presentation/alagappan">Protocol Aware Recovery</a> to remain available unless all copies of a piece of data get corrupted on every single replica.</li><li>All data in TigerBeetle is immutable, checksummed, and hash-chained, providing a strong guarantee that no corruption or tampering happened.</li><li>TigerBeetle puts as little software as possible between itself and the disk, including a custom page cache, writing data to disk with O_DIRECT, and even running on a raw block device directly (no filesystem necessary — to sidestep filesystem bugs <a href="https://news.ycombinator.com/item?id=36113828">which do tend to happen</a> from time to time).</li><li>They built their own implementation of LSM instead of using an off-the-shelf one – they call it an <a href="https://www.youtube.com/watch?v=yBBpUMR8dHw">LSM Forest</a>, which is something like 20 different LSM trees.</li></ul><p>As far as I’m aware TigerBeetle is the only distributed database that not only claims to be storage fault tolerant, but was also tested pretty hard and validated by Jepsen to be. If you have a local machine failure where even just a disk sector fails, then that storage engine is connected to the global consensus, and it can use the cluster to self heal. This is also a great example of why the modern database having access to modern research matters: <a href="https://www.usenix.org/conference/fast18/presentation/alagappan">Protocol-Aware Recovery</a>, which enables TigerBeetle to survive disk failures like this, is fairly recent (2018) research.</p><figure><p><img src="https://cdn.prod.website-files.com/67ebc022dbceaf64bee0f5c6/68daca1c7780ffd190f23349_629bea61.png" loading="lazy" alt=""/></p></figure><h3><strong>TigerBeetle in Zig</strong></h3><p>Another thing you’d think about when building a modern database from scratch is your choice of <strong>programming language</strong>. Postgres is written in C (c. 1970s), MySQL in C and C++ (1979), and MSSQL as well in C and C++. But programming languages have come a long way in the past 40 years. If you had your choice, what would you build a database in today?</p><p>The answer would probably be Rust or Zig. And indeed, TigerBeetle is built 100% in Zig: </p><ul role="list"><li>You get the whole C ecosystem available to you, extended with a phenomenal toolchain and compiler.</li><li>It’s easy to write, and especially easy to read, in some cases as easy as TypeScript (just a lot faster).</li><li>Zig lets you statically allocate memory, which is a core principle of TigerBeetle.</li><li>Zig has a great developer experience and you can learn it quickly (which ergo means you can get into the TigerBeetle src quickly).</li></ul><p>Of course, as new systems languages, Zig and Rust are related, and some of the early Rust team now work at TigerBeetle, including <a href="https://matklad.github.io/">Matklad</a> (creator of <a href="https://rust-analyzer.github.io/">Rust Analyzer</a>) and <a href="https://brson.github.io/">Brian Anderson</a> (co-creator of Rust with Graydon). They’ve <a href="https://matklad.github.io/2023/03/26/zig-and-rust.html">written extensively</a> about these languages and why Joran chose Zig in particular for TigerBeetle, given their design goals.</p><p>And here, of course, TigerBeetle is fanatical about static memory allocation, which I’ll talk more about in the next section. Not using dynamic memory allocation is “hard mode” in Rust (as matklad wrote about <a href="https://matklad.github.io/2022/10/06/hard-mode-rust.html">here</a>), but a breeze in Zig.</p><p>‍</p><h2><strong>Deterministic Simulation Testing and the VOPR</strong></h2><p>Sometimes, Deterministic Simulation Testing (DST) feels like the most transformational technology that the fewest developers know about. It’s a <a href="https://notes.eatonphil.com/2024-08-20-deterministic-simulation-testing.html">novel testing technique</a> made popular by the <a href="https://www.foundationdb.org/">FoundationDB</a> team (which now belongs to Apple); they used it to develop a more secure, bug-free distributed database in a shorter time span than arguably anyone had done before. </p><p>The <a href="https://www.youtube.com/watch?v=cHA8vyZvkCs">fundamentals of DST</a> go something like this. In distributed systems, there are essentially infinite combinations of concurrency issues: anything from lost messages to unpredictable thread execution order. You simply cannot use old-school unit and integration tests, or your system will suck. Formal verification, a more academic discipline that works on formulaic proofs that a program runs as intended, is too expensive and slow. So what are you to do?</p><p>The answer is a simulator that deterministically runs almost every possible scenario your system will face on a specific chronological timeline. The simulator accounts for external factors too, like issues with the OS, network, or disk, or simply different latencies. All in all, DST can give you the equivalent of years’ worth of testing in a very short time period (because time itself becomes deterministic—a while true loop); and DST is particularly well suited towards databases (I/O intensive, not compute intensive). If you’re familiar with Jepsen testing, think of it as <a href="https://antithesis.com/blog/is_something_bugging_you/">a subset of what DST can do</a>. </p><p>TigerBeetle is one of the most pioneering startups on the planet when it comes to DST. They’ve developed their own testing cluster – it’s nicknamed VOPR, short for Viewstamped Operation Replicator (<a href="https://www.youtube.com/watch?v=iRsycWRQrc8">after the WOPR simulator in the movie WarGames</a>). The VOPR constantly (and tirelessly) tests TigerBeetle under countless different conditions, covering everything from how nodes elect a leader to individual states and network faults. But it can simulate a whole distributed cluster virtually, all on a single thread.</p><p>As far as your author is aware, TigerBeetle’s VOPR is the single largest DST cluster on the planet. <a href="https://us13.campaign-archive.com/?u=32cd932058e988b44c838f7bc&amp;id=0c749f7b07">It runs on</a> 1,000 CPU cores, a number so unusually large that Hetzner sent them a special email asking if they were sure they wanted that many cores. The so-called VOPR-1000 is running 24x7x365, to catch rare conditions as far as possible before production. With time abstracted deterministically, and accelerated in the simulator by a factor of (roughly) 700x, this adds up to nearly 2 millennia of simulated runtime per day.</p><p>‍</p><h3><strong>But what if DST was fun?</strong></h3><p>Yea, distributed systems are cool. But you know what’s even cooler? Video games.</p><p>TigerBeetle turned DST into a game that lets you play through different failure scenarios in how the system reacts. You can play it <a href="https://sim.tigerbeetle.com/">here</a>.</p><figure><p><img src="https://cdn.prod.website-files.com/67ebc022dbceaf64bee0f5c6/68daca1c7780ffd190f2334c_13e94615.png" loading="lazy" alt=""/></p></figure><p>What’s perhaps even cooler is that this game is running an actual instance of the VOPR, simulating TigerBeetle…in your browser. It’s compiled to WebAssembly, and then TigerBeetle’s own engineers built a gaming frontend on top to visualize the real system</p><p>You can read more about how and why TigerBeetle built the simulator in <a href="https://tigerbeetle.com/blog/2023-07-11-we-put-a-distributed-database-in-the-browser/">this blog post</a>.</p><p>‍</p><h2><strong>TigerStyle and The Power of Ten</strong></h2><p>As you will continue to see with TigerBeetle, it is often not just the <em>what</em> they’ve built that catches the eye but also the <em>how</em>. There’s no better example than <strong>TigerStyle</strong>.</p><p><a href="https://github.com/tigerbeetle/tigerbeetle/blob/main/docs/TIGER_STYLE.md">TigerStyle</a> is TigerBeetle’s engineering methodology, public on GitHub for all to see. Here’s how they describe it:</p><blockquote><em>“TigerBeetle&#39;s coding style is evolving. A collective give-and-take at the intersection of engineering and art. Numbers and human intuition. Reason and experience. First principles and knowledge. Precision and poetry. Just like music. A tight beat. A rare groove. Words that rhyme and rhymes that break. Biodigital jazz. This is what we&#39;ve learned along the way. The best is yet to come.”</em></blockquote><p>Biodigital jazz is a term from <a href="https://en.wikipedia.org/wiki/Tron:_Legacy">Tron: Legacy</a>. In the context of the film, it represents the intertwining of human and digital elements, the chaotic yet structured nature of the “Grid” (the digital world), and the improvisational spirit of human potential within the confines of technology (I copied this from AI). For TigerBeetle, it’s an ethos of code; remembering to infuse everything they do with not just science, but art too.</p><p>More practically, TigerStyle lays out engineering and code principles for TigerBeetle, many derived from the original <a href="https://spinroot.com/gerard/pdf/P10.pdf">Power of Ten</a>, NASA’s tenets for writing foolproof code. TigerStyle spans from the thematic, like simplicity and elegance, to the applied, like how to name things. It’s even starting to impact other companies like Resonate and Turso; and <a href="https://youtu.be/tNZnLkRBYA8?t=11167">TigerStyle has even been discussed on Lex Fridman</a>. Here are a few highlights.</p><h3><strong>Using assertions, and the Power of Ten</strong></h3><p>Speaking of the Power of Ten…one of them (Rule 5) is about <strong>assertions</strong>. The idea is simple: explicitly encode your expectations of code behavior <em>while</em> you are writing it, not after the fact. You write them simply in a single line as booleans: assert(a &gt; b). TigerStyle calls for:</p><ul role="list"><li>Asserting all function arguments, return values, preconditions, and invariants. On average there should be at least 2 assertions per function.</li><li>Using assertions <em>instead</em> of comments when the assertion is both important and surprising.</li><li>Asserting the relationships between compile-time constants, so you can check a program’s design integrity before it even runs.</li><li>Not just assert what <em>should</em> happen, but also the negative space that you don’t expect – where interesting bugs can show up.</li></ul><p><a href="https://spinroot.com/gerard/pdf/P10.pdf">The Power of Ten</a> is an amazing artifact that covers so much more than just assertions…it’s a great resource for any modern programmer (and maybe we should train some LLMs on it too).</p><h3><strong>Thinking about performance</strong></h3><p>Much of TigerStyle centers around the idea that <em>writing</em> code is not the most important part of the cycle; instead, it’s <strong>reasoning about</strong> and <strong>designing</strong> the code. When it comes to performance, TigerStyle implores you to think about it from the start: </p><blockquote><em>“The best time to solve performance, to get the huge 1000x wins, is in the design phase, which is precisely when we can&#39;t measure or profile.”</em></blockquote><p>You should be doing basic napkin math on what TigerStyle calls “the four primary colors” – network, storage, memory, CPU – and how they’ll perform with respect to (“the two textures” — art!) bandwidth and latency. Then, there are a few more tactical tips, like distinguishing between the control plane and data plane, batching accesses, and extracting hot loops into stand-alone functions to reduce dependence on the compiler. </p><p>For more about TigerStyle, watch <a href="https://www.youtube.com/watch?v=w3WYdYyjek4&amp;t=5s&amp;ab_channel=TigerBeetle">Joran’s talk at Systems Distributed</a>.</p><h2>Try it out for yourself</h2><p>So is TigerBeetle a database? Yes. But it’s not much like any other database I’ve seen. They’ve taken modern research and applied it to an age-old form, giving their database unprecedented performance and stability guarantees. They’ve developed an art form around systems and storage engineering, and they haven’t forgotten to have fun along the way. And thanks to their clever use of DST, they were able to build this thing to Jepsen standards in only a few years. </p><p>You can get started with TigerBeetle <a href="https://tigerbeetle.com/#install">here</a> using a simple curl command. </p></div></div>
  </body>
</html>
