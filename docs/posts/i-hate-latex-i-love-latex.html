<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://commutative.xyz/~miguelmurca/blog/x/illihl.html">Original</a>
    <h1>I hate LaTeX. I love LaTeX.</h1>
    
    <div id="readability-page-1" class="page">
  
  <p>Everyone who knows me IRL (and, I suppose, who follows me
  online for long enough), knows that I have a… <em>special</em>
  relationship with LaTeX. I think it has something to do with its
  obscurity, when it wasn’t specifically made to be obtuse, and
  then being so <em>good</em> at what it does — which is typeset
  documents. It doesn’t help that people consistently <a href="https://www.overleaf.com/learn/how-to/Writing_Markdown_in_LaTeX_Documents">
  make impressive things with it</a>, thus showing that it’s not
  just theoretically Turing-complete, but really something you can
  bend to your will, provided you’re willing to grapple with books
  from the 70s and obscure PDFs scattered online, in lieu of some
  modern documentation.</p>
  <p>This is to say, I set out to write a document and then
  suddenly 5 hours have passed and I’m reading about glue and
  fragile commands. In the end, it’s rarely worth it, but the giddy
  feeling of having mastered the weird machine lingers, and so the
  cycle repeats when the following report (or presentation) is due.
  As an example of this, let me share with you my recent venture
  into statefulness via auxiliary files with LaTeX.</p>
  <p>The goal was simple: fully decouple metadata input from a
  title page, in terms of order and redundancy. I wanted to be able
  to do something like this:</p>
  <div>
    <pre><code><span>\author</span><span>{</span>James A. First<span>}</span>
<span>\affiliation</span><span>{</span>Reduandant Affiliation<span>}</span>
<span>\affiliation</span><span>{</span>The Institute<span>}</span>

<span>\author</span><span>{</span>John B. Deux<span>}</span>
<span>\affiliation</span><span>{</span>Reduandant Affiliation<span>}</span>
<span>\affiliation</span><span>{</span>The Other Institute<span>}</span>

<span>\maketitle</span>
</code></pre>
  </div>
  <p>and get something like this:</p>
  <pre><code>James A. First¹²    John B. Deux¹³
    ¹ Redundant Affiliation
    ² The Institute
    ³ The Other Institute
</code></pre>
  <h2 id="warm-up">Warm-up</h2>
  <p>This turned out to be a slightly more complex variant of
  something that I’d previously managed: creating a Table of
  Contents. In this version of the problem, we aim to define two
  commands, <code>\topic{Title}</code> and
  <code>\maketopics</code>, such that we can get with the latter a
  list of all titles defined with the former.</p>
  <p>If we were promised that all <code>\topic</code> commands
  preceded <code>\maketopics</code>, then this would be fairly
  easy  :</p>
  <div>
    <pre><code><span>\makeatletter</span>
<span>\newcommand</span><span>{</span><span>\@</span>topics<span>}{}</span>
<span>\newcommand</span><span>{</span><span>\topic</span><span>}</span>[1]<span>{</span><span>%</span>
    <span>\edef\@</span>topics<span>{</span><span>\@</span>topics <span>\par</span> #1<span>}}</span>
<span>\newcommand</span><span>{</span><span>\maketopics</span><span>}{</span><span>%</span>
    <span>\@</span>topics<span>}</span>
<span>\makeatother</span>
</code></pre>
  </div>
  <p>However, a TOC typically comes <em>before</em> all of the
  content, so this approach won’t work. If we knew exactly how many
  <code>\topic</code>s were going to be defined, maybe we could
  make-do with an obscene amount of <code>\expandafter</code>s, but
  that’s not going to cut it either. Then how can we get around the
  fact that LaTeX macros are expanded in the order of
  appearance?</p>
  <p>(Now is a good time to pause reading and figure it out.)</p>
  <h2 id="file-io-in-latex">File IO in LaTeX</h2>
  <p>LaTeX has built in file IO, via the following commands:
  <code>\newwrite</code>, <code>\openin</code>,
  <code>\openout</code> (and the counterparts
  <code>\closein</code>, <code>\closeout</code>),
  <code>\read</code>, and <code>\write</code>.
  Respectively, they do the following:</p>
  <ul>
    <li><code>\newwrite</code> gets you an unused file descriptor
    (a number), which LaTeX requires to do file related operations.
    Note that this descriptor does not uniquely match a file; you
    simply point a descriptor at a file path;</li>
    <li><code>\openin</code> and <code>\openout</code> do precisely
    this; they bind a descriptor to a file.</li>
    <li><code>\read</code> reads a line from the file descriptor
    and into a macro, with (the fun) syntax <code>\read\filedesc
    to\myline</code>.</li>
    <li><code>\write</code> does what it says on the tin:
    <code>\write\filedesc{contents}</code>. Importantly,
    <code>contents</code> is expanded before the write.</li>
    <li><code>\closein</code> and <code>\closeout</code> just close
    the file access.</li>
  </ul>
  <p>Most of these operations require a preceding
  <code>\immediate</code>, otherwise nothing will happen until the
  current page is flushed.</p>
  <p>Armed with this knowledge, and ready to do some damage, we can
  go back to the TOC problem: if we’re allowed to compile the
  <code>tex</code> file more than once we can do the
  following:</p>
  <ol>
    <li>On the first pass, don’t do anything with
    <code>\maketopics</code>, but have each <code>\topic</code>
    command write a line into a <code>topics.aux</code> file.</li>
    <li>On the second pass, define <code>\maketopics</code> simply
    to read and echo the contents of <code>topics.aux</code>.</li>
  </ol>
  <p>The catch here is that we don’t necessarily know, at the time
  of macro expansion, what’s the current pass; for the sake of
  simplicity let’s assume that we always clean the auxiliary files
  before compiling, so the difference between the first and second
  pass is that our <code>topics.aux</code> files only exists during
  the second pass.</p>
  <p>Then, we need to define a macro that tells us whether a file
  exists:</p>
  <div>
    <pre><code><span>\makeatletter</span>
<span>\newwrite\@</span>existsbuf
<span>\newif\if</span>@fileexists
<span>\newcommand</span><span>{</span><span>\fileexists</span><span>}</span>[1]<span>{</span> <span>%</span>
    <span>\immediate\openin\@</span>existsbuf=#1 <span>%</span>
    <span>\ifeof\@</span>existsbuf <span>%</span>
        <span>\@</span>fileexistsfalse <span>%</span>
    <span>\else</span> <span>%</span>
        <span>\@</span>fileexiststrue <span>%</span>
    <span>\fi</span> <span>%</span>
    <span>\immediate\closein\@</span>existsbuf <span>%</span>
    <span>\if</span>@fileexists<span>}</span>
<span>\makeatother</span>
</code></pre>
  </div>
  <p>Above I’ve used <code>\ifeof</code>, which is true if we’re at
  the End Of the opened File (i.e., we’ve already read everything
  in the file), or if the file never existed in the first place. We
  can use this as follows:</p>
  <div>
    <pre><code><span>\fileexists</span><span>{</span>file.aux<span>}</span>
    file.aux exists.
<span>\else</span>
    file.aux does not exist.
<span>\fi</span>
</code></pre>
  </div>
  <p>Now, and from the description before, our definition of
  <code>\topics</code> and <code>\maketopics</code> follow easily —
  if with one caveat: we need all the writes to occur between a
  single <code>\openout</code>/<code>\closeout</code> pair, since
  opening a file will truncate any preexisting contents. Luckily,
  LaTeX has us covered with <code>\AtEndDocument</code>, which
  inserts its argument (you guessed it) at the end of the
  document.</p>
  <div>
    <pre><code><span>\makeatletter</span>
<span>\let\@</span>buftopics<span>\@</span>empty
<span>\newcommand</span><span>{</span><span>\topics</span><span>}</span>[1]<span>{</span> <span>%</span>
    <span>\ifx\@</span>empty<span>\@</span>buftopics <span>%</span>
        <span>\relax</span> <span>% \@buftopics wasn&#39;t defined,</span>
           <span>% so we&#39;re not writing on this pass.</span>
    <span>\else</span> <span>%</span>
        <span>\immediate\write\@</span>buftopics<span>{</span>#1 <span>\par</span><span>}</span> <span>%</span>
    <span>\fi</span><span>}</span>
<span>\newcommand</span><span>{</span><span>\maketopics</span><span>}{</span><span>%</span>
    <span>\fileexists</span><span>{</span>topics.aux<span>}</span> <span>%</span>
        <span>% Second pass! Just read the file here</span>
    <span>\input</span><span>{</span>topics.aux<span>}</span> <span>%</span>
    <span>\else</span> <span>%</span>
        <span>% First pass; do nothing.</span>
    <span>\fi</span><span>}</span>    

<span>\fileexists\relax\else</span> <span>% If file does not exist:</span>
    <span>% Open the file for writing.</span>
    <span>% We need to only do this if we don&#39;t plan to</span>
    <span>%  read from the file! Otherwise we&#39;ll truncate it.</span>
    <span>\newwrite\@</span>buftopics
    <span>\immediate\openout\@</span>buftopics=topics.aux <span>\relax</span>
    <span>\AtEndDocument</span><span>{</span><span>\immediate\closeout\@</span>buftopics<span>}</span>
<span>\fi</span>
<span>\makeatother</span>
</code></pre>
  </div>
  <h2 id="now-make-it-harder">Now Make it Harder</h2>
  <p>With the previous example under our belt, let’s again tackle
  the original problem: we can use the same technique to store the
  different affiliations in an auxiliary file in a first pass, and
  then produce the correct symbols and text during a second pass,
  by reading from this file. The complications will come from
  having to interpret LaTeX as simple text, and vice-versa. For
  convenience, I’ll be using below the <code>catchfile</code> and
  <code>etoolbox</code> packages, to get, respectively, the
  <code>IfFileExists</code> and
  <code>CatchFileDef</code> commands, and the
  <code>ifdeflstrequal</code> command. These are more robust
  versions of what you’d get with TeX primitives, which allows us
  not to have to deal with some annoyances: for example, while you
  could compare two strings stored to macros <code>\a</code> and
  <code>\b</code> with <code>\ifx\a\b</code>, if any of these
  requires more than one expansion to get to the actual string, the
  comparison may incorrectly fail. On the other hand,
  <code>\ifdeflstrequal{\a}{\b}</code> will just work.</p>
  <p>I’m running out of steam writing this blog-post, because, as
  is usual with LaTeX, there are so many tiny details justified by
  complex reasons; one very good example is the <a href="https://tex.stackexchange.com/questions/4736/what-is-the-difference-between-fragile-and-robust-commands-when-and-why-do-we-n">
  use of <code>\<span data-cfemail="f9898b968d9c9a8d9c9db99c9d9c9f">[email protected]</span></code> rather than just
  <code>\edef</code></a>. Instead, I now present my final solution
  to the proposed problem, with no further comment; figuring it out
  is left as an exercise to the persistent reader, which can email
  me at <code>miguelmurca æt cumperativa.xyz</code>, or tweet me
  <a href="https://twitter.com/mikeevmm/">@mikeevmm</a>. You can
  also check out the <a href="https://github.com/mikeevmm/beamleeto">nerd snipe/Beamer
  hate-letter</a> that inspired this post.</p>
  <div>
    <pre><code><span>\makeatletter</span>
<span>\let\@</span>authors<span>\@</span>empty
<span>\renewcommand</span><span>{</span><span>\author</span><span>}</span>[1]<span>{</span><span>%</span>
    <span>\ifx\@</span>empty<span>\@</span>authors<span>%</span>
        <span>% Author list empty</span>
        <span>\global\def\@</span>authors<span>{</span>#1<span>}</span><span>%</span>
    <span>\else</span><span>%</span>
        <span>% Other authors already present</span>
        <span>\global\protected</span>@edef<span>\@</span>authors<span>{</span><span>\@</span>authors, #1<span>}</span><span>%</span>
    <span>\fi</span><span>}</span>
<span>\makeatother</span>

<span>\makeatletter</span>
<span>\newcounter</span><span>{</span>@affilcounter<span>}</span>
<span>\newwrite\@</span>bufaffils
<span>\DeclareRobustCommand</span><span>{</span><span>\affiliation</span><span>}</span>[1]<span>{</span> <span>%</span>
    <span>\def\affilarg</span><span>{</span>#1<span>\relax</span><span>}</span> <span>%</span>
    <span>\protected</span>@edef<span>\affilarg</span><span>{</span> <span>%</span>
        <span>\detokenize\expandafter</span><span>{</span><span>\affilarg</span><span>}}</span> <span>%</span>
    <span>% Calculate the footnotemark:</span>
    <span>\setcounter</span><span>{</span>@affilcounter<span>}{</span>0<span>}</span> <span>%</span>
    <span>% Try to match \affilarg to one of the lines of the aux file</span>
    <span>\immediate\openin\@</span>bufaffils=affils.aux<span>\relax</span> <span>%</span>
    <span>\IfFileExists</span><span>{</span>affils.aux<span>}{</span> <span>%</span>
        <span>\newif\ifmatched</span> <span>%</span>
        <span>\matchedfalse</span> <span>%</span>
        <span>% Here I&#39;m using the \unless extension for e-TeX, which</span>
        <span>% comes for free in pdfLaTeX. It&#39;s basically \if...\relax\else.</span>
        <span>\loop\unless\ifeof\@</span>bufaffils <span>%</span>
            <span>% Read a line from the file...</span>
            <span>\immediate\read\@</span>bufaffils to<span>\affilline</span> <span>%</span>
            <span>\ifeof\@</span>bufaffils<span>\relax\else</span> <span>%</span>
                <span>% ...and the empty line that follows.</span>
                <span>{</span><span>\immediate\read\@</span>bufaffils to<span>\relax</span><span>}</span> <span>%</span>
            <span>\fi</span> <span>%</span>
            <span>\stepcounter</span><span>{</span>@affilcounter<span>}</span> <span>%</span>
            <span>% Comparing \affilline with \affilarg</span>
            <span>\ifdefstrequal</span><span>{</span><span>\affilline</span><span>}{</span><span>\affilarg</span><span>}{</span> <span>%</span>
                <span>% Matched, at position \<a href="https://commutative.xyz/cdn-cgi/l/email-protection" data-cfemail="5125393411303737383d323e243f253423">[email protected]</a>!</span>
                <span>\global\matchedtrue</span> <span>%</span>
            <span>}{</span><span>% else</span>
                <span>% Found no match</span>
                <span>\ifeof\@</span>bufaffils <span>%</span>
                    <span>% Also, exhausted the possible matches.</span>
                    <span>\global\setcounter</span><span>{</span>@affilcounter<span>}{</span>0<span>}</span> <span>%</span>
                <span>\fi</span> <span>%</span>
            <span>}</span> <span>%</span>
            <span>% Break the loop.</span>
            <span>% See this TeXExchange answer for an explanation:</span>
            <span>% https://tex.stackexchange.com/a/12490</span>
            <span>\ifmatched\let\iterate\relax\fi</span> <span>%</span>
        <span>\repeat</span><span>}{}</span> <span>%</span>
    <span>% Finished matching.</span>
    <span>\immediate\closein\@</span>bufaffils <span>%</span>
    <span>%</span>
    <span>\ifnum\value</span><span>{</span>@affilcounter<span>}</span>=0 <span>%</span>
        <span>% The affiliation was not found in the file.</span>
        <span>% Write/append it to the auxilliary file.</span>
        <span>% We do this by reading the file into a macro, appending</span>
        <span>%  our new line, and writing it all back.</span>
        <span>% Read the existing contents:</span>
        <span>\IfFileExists</span><span>{</span>affils.aux<span>}{</span> <span>%</span>
            <span>\CatchFileDef</span> <span>%</span>
                <span>{</span><span>\@</span>affilswrite<span>}</span> <span>%</span>
                <span>{</span>affils.aux<span>}</span> <span>%</span>
                <span>{</span><span>\endlinechar</span>=`<span>^^</span>J<span>}</span><span>% Preserve EOLs in the file.</span>
                                   <span>% Note that ^^J is TeX-speak for escaped newline.</span>
            <span>}{</span><span>\let\@</span>affilswrite<span>\@</span>empty<span>}</span> <span>%</span>
        <span>% Open the file:</span>
        <span>\immediate\openout\@</span>bufaffils=affils.aux<span>\relax</span> <span>%</span>
        <span>% Write everything:</span>
        <span>% (Just writing will guarantee a trailing newline.)</span>
        <span>\unless\ifx\@</span>empty<span>\@</span>affilswrite <span>%</span>
            <span>\protected</span>@edef<span>\@</span>affilswrite<span>{</span> <span>%</span>
                <span>\detokenize\expandafter</span><span>{</span><span>\@</span>affilswrite<span>}}</span> <span>%</span>
            <span>\immediate\write\@</span>bufaffils<span>{</span><span>\@</span>affilswrite<span>}</span> <span>%</span>
        <span>\fi</span> <span>%</span>
        <span>\immediate\write\@</span>bufaffils<span>{</span><span>\affilarg</span><span>}</span> <span>%</span>
        <span>\immediate\closeout\@</span>bufaffils <span>%</span>
        <span>%</span>
    <span>\else</span> <span>%</span>
        <span>\def\affilsymb</span><span>{</span><span>\fnsymbol</span><span>{</span>@affilcounter<span>}}</span> <span>%</span>
        <span>\global\protected</span>@edef<span>\@</span>authors<span>{</span><span>\@</span>authors<span>$</span><span>{}^</span><span>\affilsymb</span><span>$</span><span>}</span> <span>%</span>
    <span>\fi</span><span>}</span>
<span>\makeatother</span>

<span>\makeatletter</span>
<span>\renewcommand</span><span>{</span><span>\maketitle</span><span>}{</span> <span>%</span>
    <span>\let\@</span>affils<span>\@</span>empty <span>%</span>
    <span>% Load the affiliations:</span>
    <span>\IfFileExists</span><span>{</span>affils.aux<span>}{</span> <span>%</span>
        <span>\setcounter</span><span>{</span>@affilcounter<span>}{</span>0<span>}</span> <span>%</span>
        <span>\immediate\openin\@</span>bufaffils=affils.aux<span>\relax</span> <span>%</span>
        <span>\loop\unless\ifeof\@</span>bufaffils <span>%</span>
            <span>\immediate\read\@</span>bufaffils to<span>\lineaffil</span> <span>%</span>
            <span>{</span><span>\unless\ifeof\@</span>bufaffils<span>\immediate\read\@</span>bufaffils to<span>\relax\fi</span><span>}</span> <span>%</span>
            <span>\stepcounter</span><span>{</span>@affilcounter<span>}</span> <span>%</span>
            <span>\global\def\affilsymb</span><span>{</span><span>\fnsymbol</span><span>{</span>@affilcounter<span>}}</span> <span>%</span>
            <span>\ifx\@</span>empty<span>\@</span>affils <span>%</span>
                <span>\global\protected</span>@edef<span>\@</span>affils<span>{</span><span>$</span><span>{}^</span><span>\affilsymb</span><span>$</span><span>\lineaffil</span><span>}</span> <span>%</span>
            <span>\else</span> <span>%</span>
                <span>\global\protected</span>@edef<span>\@</span>affils<span>{</span> <span>%</span>
                    <span>\@</span>affils, <span>$</span><span>{}^</span><span>\affilsymb</span><span>$</span><span>\lineaffil</span><span>}</span> <span>%</span>
            <span>\fi</span> <span>%</span>
        <span>\repeat</span> <span>%</span>
        <span>\immediate\closein\@</span>bufaffils <span>%</span>
    <span>}{}</span> <span>% else nothing</span>
    <span>%</span>
    <span>% Typeset the authors and affiliations:</span>
    <span>\begin</span><span>{</span>center<span>}</span> <span>%</span>
    <span>\@</span>authors <span>\par</span> <span>%</span>
    <span>\ifx\@</span>empty<span>\@</span>affils <span>%</span>
        <span>\relax</span><span>% No affiliations</span>
    <span>\else</span><span>%</span>
        <span>\textsc</span><span>{</span><span>\@</span>affils<span>}}</span> <span>\par</span>
    <span>\fi</span><span>%</span>
    <span>\end</span><span>{</span>center<span>}}</span>
<span>\makeatother</span>
</code></pre>
  </div>
  <p>Fine, maybe <em>some</em> comments. The main thing here is
  that we’re trying to match each affiliation to a line in
  <code>affils.aux</code>, and appending the affiliation to the
  file if it’s not there. If it <em>is</em> there, we convert the
  line index (which we counted with a counter) into a symbol with
  <code>\fnsymbol</code>. This lets us independently print the
  authors with the correct affiliation symbols, and then the
  different affiliations with their respective symbol.</p>
  <p>Each write in LaTeX forcibly ends with an empty new-line, and
  this causes some trouble parsing back the <code>affils.aux</code>
  file. I worked around this by always writing a lines in pairs: an
  affiliation followed by an empty line. Then, parsing back the
  file, I assumed this structure and discarded lines accordingly.
  This worked well, but I am almost positive that I could have a
  more elegant solution by going over the file’s lines in a
  <code>do..while</code>-style loop, rather than the current
  <code>for</code>-style loop. Speaking of which, in case you’re
  not familiar, TeX’s loop syntax is a little weird: it’s
  <code>\loop &lt;content&gt; \if &lt;condition&gt; &lt;true
  action&gt; \repeat</code>, but the most common pattern is using
  it as <code>\loop\if&lt;condition&gt; &lt;actions&gt;
  \repeat</code> as a sort of <code>while</code> loop. But <a href="https://en.wikibooks.org/wiki/LaTeX/Plain_TeX#Loops">you already
  knew that</a>.</p>
  <p>Another thing, which you might already have noticed, is all
  the <code>%</code>s. LaTeX isn’t actually insensitive to
  newlines, and it’s not always clear when it’s safe to break a
  line. It also doesn’t help that LaTeX’s error reporting is
  cryptic, so to be safe, and not spend mental bandwidth with it, I
  just end lines that I’m wrapping for source code reasons with
  <code>%</code>.</p>
  <p>Finally, I also want to comment this pattern:</p>
  <div>
    <pre><code><span>\protected</span>@edef<span>\x</span><span>{</span> <span>%</span>
    <span>\detokenize\expandafter</span><span>{</span><span>\x</span><span>}}</span>
</code></pre>
  </div>
  <p>What we’re doing here is redefining <code>\x</code> to be the
  <em>string</em> of its current definition. This is more or less
  straightforward to do with <code>\detokenize</code>, since what
  this command does is convert its argument to simple text, but
  here we have the added complication that we need to
  <em>expand</em> the argument of <code>\detokenize</code>, before
  actually converting it to simple text. The
  <code>\expandafter</code> is interrupting LaTeX’s parsing of
  <code>{</code> (which indicates the start of
  <code>\detokenize</code>’s argument), and expanding whatever
  follows immediately after; in this case <code>\x</code>. The
  detokenization then proceeds normally. <a href="https://www.overleaf.com/learn/latex/Articles/How_does_%5Cexpandafter_work%3A_A_detailed_study_of_consecutive_%5Cexpandafter_commands">
  See here for a more careful explanation.</a></p>
  <p>OK, that’s actually everything. Do send me emails with
  suggestions or questions, I love to hear from the internet. But
  also remember I’m just a kid writing a blog post, and am
  therefore at the top of the Dunning-Krugger peak. Be kind,
  please.</p>
  <p>
  Discuss this post on HackerNews</p>
  
  


</div>
  </body>
</html>
