<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.geoffchappell.com/notes/windows/archive/aard/drdos/index.htm">Original</a>
    <h1>The AARD Code and DR DOS (2021)</h1>
    
    <div id="readability-page-1" class="page"><div>
  <p>WORK IN PROGRESS - PREVIEW ONLY </p>
  
  <p>In this long article, I, being as far as I know the first outside Microsoft 
    to have learnt how the AARD code works, explain that I condemn its form but 
    broadly sympathise with its function. </p>
  <p>For roughly a year after I noticed on 17th April 1992 that the HIMEM.SYS driver 
  from a Microsoft Windows 3.1 beta contained what eventually became known as the
  <a href="https://www.geoffchappell.com/notes/windows/archive/aard/index.htm">AARD Code</a>, I had no idea which non-standard DOS had 
  been affected. Whichever DOS it was, since the code was in WIN.COM too, its users 
  will have been warned of an obscurely numbered “Non-fatal error” and been asked 
  to “contact Windows 3.1 beta support” just from having tried to start this Windows 
  on this DOS. Surely this had already happened to someone somewhere in the months 
  before I had got this pre-release HIMEM.SYS to study. </p>
  <p>But I could, at the time, only suppose. I was not a Windows 3.1 beta tester 
  nor a user of any operating system other than MS-DOS. My reading of computer magazines 
  never was more than occasional, even back then. Though I was actively participating 
  in an online conferencing system in Britain, it would be nearly two years before 
  I subscribed to Compuserve. Even more then than now, I was not at all plugged 
  in to computer news. If real-world observation of the “Non-fatal error” had been 
  reported publicly, I didn’t know of it and I wouldn’t have expected to. I had 
  seen the error message for myself, of course, but only on my own computer—by installing 
  my own device driver that made MS-DOS 5.00 fail the AARD code’s encrypted test.
  </p>
  <p>Not until 30th May 1993 did I learn that the error message had hit DR DOS specifically. 
  This was from Andrew Schulman, who had himself learnt only weeks before: see
  <a href="http://www.chicagotribune.com/news/ct-xpm-1993-05-10-9305100149-story.html">
  FTC MOVES TO FOCUS MICROSOFT ANTITRUST CASE</a> by Wendy Goldman Rohm from the
  <span>Chicago Tribune</span> on 10th May 1993. There then came 
  quickly Andrew’s article
  <a href="https://web.archhttps://web.archive.org/web/19991128084349/http://www.ddj.com/articles/1993/9309/9309d/9309d.htm">
  Examining the Windows AARD Detection Code</a> in <span>Dr. Dobb’s 
  Journal</span>, September 1993, and repeated discussion in
  <span>Undocumented DOS, Second Edition</span>, ISBN 0-201-63287-X, 
  co-authored by Andrew for Addison-Wesley in 1994. </p>
  <p>By the late 1990s, the AARD code had no small role in a court case,
  <span>Caldera, Inc. v. Microsoft Corp., 72 F. Supp.2d.1295 (D. 
  Utah 1999)</span>, which Caldera, who was by then the owner of DR DOS after Digital 
  Research and Novell, brought against Microsoft “for damages and injunctive relief 
  under the antitrust laws of the United States, and for damages in tort”. The AARD 
  code has ever since been for many some sort of pin-up for anti-competitive practices 
  by Microsoft. </p>
  <h2>Sympathy </h2>
  <p>I, for the record, have tended to side with Microsoft on this: not on the general 
  question of anti-competitive practices, for which Microsoft deserves far greater 
  condemnation than the computer industry and various governments have allowed it 
  to escape with, but on the AARD code specifically; and not then for the disingenuous 
  error message and the code’s obfuscation, which I always thought childish and 
  quickly also regarded as despicable, but for Microsoft’s general disposition to 
  DR DOS. </p>
  <p>To clear all doubt about my attitude to the AARD code and DR DOS:
  <span>had the AARD tests been coded without disguise, with failure 
  warning frankly that Microsoft Windows is written for execution on MS-DOS, even 
  if adding that other execution is at the user’s own risk and voids support from 
  Microsoft, then I would not agree that Microsoft had wronged anyone.</span>
  </p>
  <p>To Microsoft, by my reckoning, DR DOS was an imitator of MS-DOS. In assessing 
  Microsoft’s reaction to DR DOS, I must think what would be own reaction if I had 
  designed and implemented something, and someone copied my design into a distinct 
  implementation of their own. I would have to accept that copyright law gives me 
  no protection and I might console myself with the proverb about imitation being 
  flattery, but I would think it outrageously unjust if some law would somehow have 
  me owe anything to the imitator. </p>
  <p>This broad sympathy is, of course, strained by many complications, both in 
  Microsoft’s overall disposition to DR DOS and in how Microsoft expressed this 
  specifically through the AARD code. </p>
  <h2>Markets </h2>
  <p>Most important among the complications—and so obvious that it barely needs 
  mention—is that no amount of regarding DR DOS as an imitator denies that DR DOS 
  was legitimately a competitor of MS-DOS in a market of operating systems for micro-computers 
  whose processors derive from the Intel 8086, which more or less quickly specialised 
  to computers whose peripheral support derives from that of the IBM Personal Computer 
  (PC).<a name="FtnRef_PlatformArchitecture" href="#Ftn_PlatformArchitecture">1</a> 
  In this market, Microsoft enjoyed monopoly power through MS-DOS and Microsoft 
  properly had responsibilities for fair competition, including with DR DOS. </p>
  <p>But this market in PC-compatible operating systems is not the only—or even 
  the main—operating-system market that DR DOS was in. DR DOS had copied the MS-DOS 
  interfaces as if to compete with MS-DOS in a market of operating systems that 
  are compatible with software that’s written to run on MS-DOS. This is the “DOS 
  market” that features in Caldera’s court filings when talking of the AARD code 
  as unlawfully anti-competitive. </p>
  <p>To Microsoft this “DOS market” never was a market. There was just MS-DOS itself 
  and a handful of mostly very slight adaptations by one or another Original Equipment 
  Manufacturer (OEM) to whom Microsoft licensed the source code.<a name="FtnRef_OEM" href="#Ftn_OEM">2</a> 
  Later came a few specialised variants that Microsoft created (itself or jointly) 
  for its newer operating systems—notably OS/2 and, years later, Windows NT—so they 
  could offer some sort of compatibility box with limited support for MS-DOS applications. 
  All were under Microsoft’s control, at least initially, by the historical accident 
  of Microsoft’s being the designer and first implementer. </p>
  <p>That this collection of MS-DOS and licensed variants amounted to any sort of 
  DOS market with DR DOS as a participant in competition with MS-DOS was only from 
  Digital Research copying the MS-DOS design into DR DOS and declaring that this 
  copy was good enough that programs written for MS-DOS should work on DR DOS too. 
  What Digital Research, and later Novell and Caldera, seem never to have explained 
  is how or why this say-so is supposed to bind any writers of MS-DOS programs to 
  anticipate execution on DR DOS, let alone to bear any costs from their programs 
  turning out not to work on DR DOS too. </p>
  <p>This is not to say that copying the MS-DOS interfaces and any amount of supporting 
  architecture to make DR DOS was in any way wrong or unlawful. The usual protections 
  of intellectual property in software, i.e., copyright, patents and trade secrets, 
  seem not to have been available to Microsoft for MS-DOS. Inasmuch as the copying 
  into DR DOS was only of the design, not of any expression, there was no copyright 
  infringement. There were apparently no applicable patents. Even the functions 
  that Microsoft falsely documented as “Not used” in the first version and later 
  as “Used internally” can’t sensibly have been regarded as trade secrets: if nothing 
  else, Microsoft itself distributed with MS-DOS a program named DEBUG that put 
  the workings of undocumented functions in plain sight. </p>
  <h3>Common Ancestry </h3>
  <p>There is anyway the complication that Microsoft had copied too. Caldera makes 
  quite a lot of this in a
  <a href="https://www.digitalresearch.biz/DR/Info/fullstory/factstat.html">Consolidated 
  Statement of Facts</a> in April 1999 for its law suit. MS-DOS is there said to 
  be variously a copy or clone of an operating system named CP/M which had been 
  developed long before by none other than Digital Research. I perhaps misunderstand 
  Caldera’s point but what I detect is a suggestion that DR DOS was a legitimate 
  competitor of MS-DOS in a DOS market because of common ancestry. </p>
  <p>A problem with this is that whatever may have been Microsoft’s grubby business 
  dealings in the early 1980s on the way to birthing MS-DOS, the first MS-DOS was 
  much more distant from CP/M than DR DOS ever was from MS-DOS, and its design relative 
  to CP/M had much more distinct a purpose than DR DOS ever had relative to MS-DOS.
  </p>
  <h4>Distance </h4>
  <p>CP/M had been written for an 8-bit processor, MS-DOS for a 16-bit processor. 
  Both processors were made by Intel and the one was very much a successor of the 
  other but without binary compatibility. MS-DOS never could have run programs that 
  were written for CP/M. DR DOS, in contrast, aimed from the start to run programs 
  that had been (or would yet be) written for MS-DOS. </p>
  <p>What certainly was intended for MS-DOS is that programs written for CP/M could 
  be more or less easily rewritten as MS-DOS programs. In the jargon, they could 
  be <span>ported</span> to the 16-bit processor for execution 
  by MS-DOS. Intel had greatly helped by designing the new processor’s Instruction 
  set to allow for mechanical translation from the old as some sort of source-code 
  compatibility, but this did not of itself attend to a program’s interface with 
  a possibly very different operating system. To ease this part of the porting, 
  so that it too was reduced to something approaching a mechanical rebuild, MS-DOS 
  re-implemented the CP/M interface and enough of the CP/M architecture for the 
  interface to work. Thus does MS-DOS have such features as the function numbers 
  from CP/M, the File Control Block (FCB) structure that is used for input and output 
  to many of those functions, the $-terminated strings that are expected for another 
  of those functions, the particular CP/M mechanism of calling through known addresses, 
  and the CP/M architecture of loading .COM programs at a particular offset above 
  a base structure which has those known addresses.<a name="FtnRef_PSP" href="#Ftn_PSP">3</a>
  </p>
  <h4>Purpose </h4>
  <p>That MS-DOS copied from the CP/M programming interface and architecture is 
  therefore undeniable, but MS-DOS also had a new interface of its own and a significantly 
  extended architecture.<a name="FtnRef_SystemArchitecture" href="#Ftn_SystemArchitecture">4</a> 
  This was because MS-DOS had the larger purpose of supporting something new: MS-DOS 
  programs. </p>
  <p>To ease the writing of new code by programmers who were used to CP/M, and to 
  support more careful porting of old code to get new efficiency from the new operating 
  system, the new interrupt-based interface in MS-DOS includes the CP/M functions. 
  But make no mistake that this was anything but a crutch to help programmers make 
  the transition. It was the new interface that was the more substantial, notably 
  for having new functions. It was the new interface that was greatly preferred 
  for new programming. The <span>Disk Operating System</span> manual 
  for PC-DOS 1.0 documented the call-based mechanism of the CP/M interface only 
  as an “additional mechanism provided for pre-existing programs that were written 
  with different calling conventions”. See especially that the new functions of 
  the new interrupt-based interface were not available through the old call-based 
  interface. </p>
  <p>A line was thus drawn at wherever CP/M had yet reached on its old processor. 
  The future of MS-DOS lay entirely with its new interface and new processor. Of 
  the CP/M functions that were carried into the new interface, those that work with 
  the FCB structure were deprecated for new programming as soon as MS-DOS 2.00. 
  This second version is a world apart from the first. Putting this distance firmly 
  on the public record is presumably the internal reason that Microsoft published 
  source code for versions 1.25 and 2.11 in 2014 at the
  <a href="https://computerhistory.org/blog/microsoft-ms-dos-early-source-code/">
  Computer History Museum</a> and in 2018 on
  <a href="https://github.com/microsoft/ms-dos">GitHub</a>.<a name="FtnRef_SourceCode" href="#Ftn_SourceCode">5</a>
  </p>
  <p>That MS-DOS could run old programs that had been written for CP/M but could 
  now be rewritten for MS-DOS was more than incidental and may even have been important 
  for a time, but MS-DOS was never pitched at being a better CP/M for running CP/M 
  programs even after porting. Right from its birth, MS-DOS was a new operating 
  system aimed at having its own ecology of new programs. </p>
  <p>Nothing even vaguely like this can sensibly be claimed for DR DOS. Running 
  old and new programs that were written for MS-DOS, unchanged, was the one reason 
  for existence that DR DOS ever had. For its claim to distinction among PC-compatible 
  operating systems, DR DOS was presented first and foremost as better than MS-DOS 
  for running MS-DOS programs. </p>
  <p>That anyone other than Digital Research itself might write programs specifically 
  for DR DOS was at best secondary. It surely did happen—the DR DOS interface does 
  have its own functionality in excess of what it reproduces from MS-DOS—but it 
  seems not to have been much intended. Digital Research did not encourage programmers 
  to write new DR DOS programs in anything like the way that MS-DOS extended the 
  legacy CP/M interface to provide for writing new MS-DOS programs. </p>
  <p><span>WRITING IN PROGRESS</span> </p>
  <h2>A Simple Incompatibility </h2>
  <p>None of this attitude of mine to DR DOS, its place in any market and especially 
  about its claimed compatibility with MS-DOS programs is new. For instance, I am 
  the “technical reviewer” who is quoted in <span>Undocumented 
  DOS, Second Edition</span> (on page 182) as </p>
  <blockquote>
    Angrily rejecting DR DOS’s claims to MS-DOS compatibility, one reviewer (no, 
    not a Microsoft employee) dismissed the idea of anyone “actually checking for 
    the presence of this rather imperfect clone” and bluntly told us, “I see no 
    reason why journalists should cooperate with DR’s desire to have programmers 
    share their development and marketing costs.”
  </blockquote>
  <p>Though I don’t agree I was angry, exactly, the email (dated 19th January 1993) 
  that I’m quoted from certainly did have me as “extremely uneasy about
  <span>special</span> adaptation of code so that it also runs 
  under DR-DOS” (with “special” between underscores in the plain-text email). I 
  very much disagree that my unease “reflects a general feeling that DR DOS is Brand 
  X and pretty much irrelevant.” However wide may have been the perception that 
  DR DOS and MS-DOS are different brands of some generic DOS, with DR DOS yet to 
  gain relevance by competing successfully on price, quality or whatever, I was 
  nowhere near it. To me, DOS meant MS-DOS and its licensed variants such as PC 
  DOS. DR DOS was no more a brand of these than juices pressed from soy beans, almonds 
  or cashews are brands of milk. This is not to say they have no merit—some of those 
  juices are more enjoyable than is most American milk—but they’re not different 
  brands of the same thing. To me, DR DOS could not even be a candidate for consideration 
  as another brand if it would always, as seemed likely, need special accommodation 
  in anyone’s DOS programming. </p>
  <p>The occasion for this particular expression of unease about special coding 
  for DR DOS was that a draft of the book’s CRITSECT.C (on page 585) had got itself 
  into some bother about learning the true DOS version rather than a possibly false 
  version from <a href="https://www.geoffchappell.com/notes/dos/interrupts/21h/30h/index.htm">
  <span>int 21h</span> function 30h</a> (which is subject to 
  the SETVER tool). For exactly this purpose, MS-DOS 5.00 had introduced
  <span>int 21h</span> function 3306h. Earlier versions fail 
  this function. But how does a program learn that this function has failed? The 
  answer is different in MS-DOS and DR DOS—which, of course, I couldn’t resist pointing 
  out even though it was at best tangential to the larger work of the CRITSECT.C 
  code. </p>
  <p>To MS-DOS since version 3.00 or 3.10 (depending on the OEM),
  <span>int 21h</span> function 33h is one of a handful that 
  the kernel handles entirely on the caller’s stack without enabling interrupts 
  and, as best as possible, without producing side-effects. Notably, these functions 
  change no kernel data that isn’t explicitly related to the function and they especially 
  do not check for Ctrl-Break in the <span>break=on</span> configuration.<a name="FtnRef_2133" href="#Ftn_2133">6</a> 
  All versions 2.00 and higher handle unknown subfunctions of
  <span>int 21h</span> function 33h by setting
  <span>al</span> to FFh and preserving all other registers (including 
  the <span>flags</span>). Earlier versions don’t have function 
  33h at all, and fail it similarly but with <span>al</span> cleared 
  to zero. These are the MS-DOS indicators that <span>int 21h</span> 
  function 33h fails. </p>
  <p>DR DOS 6.0, if not also its earlier versions, handles
  <span>int 21h</span> function 33h differently—on the caller’s 
  stack, as does MS-DOS, but as a function whose failure produces an error code 
  and has the side-effect of setting extended error information. An unknown subfunction 
  returns with a set carry flag and with <span>ax</span> set to 
  0001h (this being the error code for an invalid function). This is the DR DOS 
  indicator that <span>int 21h</span> function 33h fails.
  </p>
  <p>Does the difference matter? Not by itself perhaps. There are easy ways around 
  it. Even the side-effect of setting extended error information looks like it can 
  matter only with contrivance, e.g., if for some Terminate and Stay Resident (TSR) 
  program’s reactivation to make DOS calls, the TSR calls
  <span>int 21h</span> function 3306h before saving extended 
  error information or after restoring it. </p>
  <p>Against dismissing this difference as having no consequence in real-world use 
  is the wonder that it exists at all: <span>int 21h</span> 
  function 33h is very nearly as simple as can be. Only functions 50h, 51h, 62h 
  and 64h have simpler implementations (in MS-DOS). These five are the first functions 
  that would be checked in any systematic examination of an
  <span>int 21h</span> implementation whether by reading binary 
  code or source code, whether the purpose is to reproduce the interface or to assess 
  two implementations for compatibility. DR DOS has clearly gone its own way with 
  these functions. The intention may have been to improve them—and others, as with 
  adding functions 25h, 35h and 59h to those that MS-DOS processes on the caller’s 
  stack—but one outcome, presumably unintended, is that defensive programming that 
  would check for a function’s failure is put to differentiating MS-DOS and DR DOS 
  (or devising a work-around). </p>
  <p>Given this difference even for the simplest elements of the interface, it would 
  be extraordinarily naïve to hope that special coding isn’t required for deeper 
  issues too. On how many points, large or small, well-intended or not, need the 
  DR DOS implementation of the <span>int 21h</span> interface 
  differ from that of MS-DOS before the practical need for special coding invalidates 
  the imitator’s claims of compatibility? </p>
  <h2>Blinkers </h2>
  <p>The preceding question seems to have got conflicted in the early 1990s—and 
  may be still in the apparently growing community of retro-computing enthusiasts, 
  some of whom are vigorously revising history, at least as recorded by Wikipedia, 
  to favour DR DOS. The conflict I mean is that celebration of DR DOS as a compatible 
  alternative to MS-DOS for running MS-DOS programs often coincided with requests 
  that MS-DOS programmers should keep in mind what different writing may be needed 
  for DR DOS. </p>
  <p>The 1990s had opened with MS-DOS in a period of stagnation. Its version 4.00 
  from 1988 and its slight update as version 4.01 in 1989 were not without innovation, 
  but the new features (such as installable file system drivers) were wanted by 
  hardly anyone. What might have got a broad welcome (as with a menu-driven shell) 
  was unattractive to look at and awkward to use. Totally neglected were features 
  (notably, of using RAM from outside the 1MB address space of the 8086) that were 
  regarded as necessary by the sorts of users and programmers whom we might nowadays 
  call early adopters or influencers. To these users especially, the release of 
  DR DOS 5.0 in 1990 may have felt like fresh air. DR DOS 5.0 and again DR DOS 6.0 
  in 1991 had features that these users wanted badly but which were many months 
  (even more than a year) from being offered in the next MS-DOS. These were golden 
  years for DR DOS. But with success came increased attention and in its turn closer 
  inspection. </p>
  <p>The programming literature inevitably started collecting incompatibilities. 
  For some measure of this, consider the development of <span>Undocumented 
  DOS, Second Edition</span> in 1994 from the original <span>Undocumented 
  DOS</span>, ISBN 0-201-57064-5, also co-authored by Andrew for Addison-Wesley 
  but in 1990. </p>
  <p>Though the original had its first printing in October 1990, it may have been 
  prepared before the release of DR DOS 5.0 in August 1990. It talks only of version 
  3.40 and only then briefly (on pages 24 and 25). An immediate practical point 
  for readers was the reassurance that most of the book’s techniques and samples 
  for using undocumented functions work on DR DOS too. A good general point is that 
  what the book termed “simulated DOS environments” (conspicuously not operating 
  systems) “can only support an undocumented DOS function call or data structure 
  if someone consciously <span>put</span> it there.” But this looks 
  to have been the extent of the authors’ expressed interest. The very large appendix 
  of <span>Undocumented DOS Functions</span>, extracted from the 
  online <a href="https://www.cs.cmu.edu/~ralf/files.html">Interrupt List</a>, made 
  no special cases for DR DOS. </p>
  <p>To this baseline, I add—presuming that private communication in email adds 
  useful background for this point without giving away anything secret—that by February 
  1992, Andrew noted to me that “Several readers have asked for more coverage of 
  DR-DOS” and by July 1992 this had grown to “<span>many</span> 
  readers have asked for coverage of it” (with “many” between asterisks in the plain-text 
  email). </p>
  <p>Sometimes, what readers ask for is what readers get. By 1994,
  <span>Undocumented DOS, Second Edition</span> lists Novell DOS 
  on the cover to show what the book has been “expanded to include”. Inside, a chapter 
  on <span>Other DOSs</span> runs to nearly 50 pages, not quite 
  half for DR DOS (which is now referrred to very much as an operating system). 
  The updated appendix now lists <span>int 21h</span> functions 
  that DR DOS adds to the MS-DOS interface, along with some variations from MS-DOS, 
  especially in structures such as those exposed by <span>int 
  21h</span> function 52h. Sometimes, the appendix hints at differences of behaviour, 
  as for instance when noting of <span>int 21h</span> function 
  60h that “for DOS 3.30-6.0, the input and output buffers may be the same”, apparently 
  leaving the reader to speculate whether something they might otherwise have taken 
  as natural is mentioned because it wasn’t true for earlier MS-DOS versions or 
  is not true for some different DOS.<a name="FtnRef_2160" href="#Ftn_2160">7</a> 
  The full Interrupt List on the book’s diskette clarifies that the DR DOS 6.0 implementation 
  of this function did not have this stated capability even for an update in April 
  1992. Indeed, this full Interrupt List, dated 1st August 1993, makes very many 
  special cases for the DR DOS implementations—including, by the way, to note the 
  DR DOS handling of <span>int 21h</span> function 3306h (see 
  above) and to classify it as a bug. </p>
  <p>Plainly, by mid-1993, it was an open secret that DR DOS and MS-DOS had notably 
  different behaviour in terms of their supposedly common programming interface. 
  That some, even many, still talked of DR DOS as fully compatible can no longer 
  have been wishful thinking in advance of information. </p>
  <p><span>WRITING IN PROGRESS</span> </p>
  
  
</div></div>
  </body>
</html>
