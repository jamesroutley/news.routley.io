<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://adamobeng.com/wddbfs-mount-a-sqlite-database-as-a-filesystem/">Original</a>
    <h1>Wddbfs – Mount a SQLite database as a filesystem</h1>
    
    <div id="readability-page-1" class="page"><div>
<article>
<header>

<time datetime="2024-02-17 00:00:00 -0800" pubdate=""> 17 Feb 2024 </time>
|
<span>
Categories:
hacks
</span>
</header>
<p>Often when I’m prototyping a project, I hesitate to use a sqlite database despite their <a href="https://sqlite.org/appfileformat.html">many adavantages</a>. It seems much easier to just dump a bunch of files in a directory and to rely on the universal support for the filesystem API to read/delete/update records. Part of this is avoiding the overhead of figuring out a relational schema, but an equal amount of friction comes from the fact that .sqlite files are just slightly more difficult to inspect: the SQL syntax for selecting a few records is much more verbose than <code>head -n</code> or <code>tail -n</code>, there are special commands (which don’t work in some environments/versions) for listing tables, and neither my text editor nor my shell has autocompletion for database queries.</p>
<p>To try to get the best of both worlds, I have put together a little utility called <em>wddbfs</em>, which exposes a sqlite database as a (WebDAV<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" rel="footnote">1</a></sup>) filesystem, accessible to anything which can work with a filesystem, including terminals, file managers, and text editors.</p>
<p>Here’s how it works. If you install it with:</p>
<p><code>pip install git+https://github.com/adamobeng/wddbfs</code></p>
<p>You can mount a database with:</p>
<div><div><pre><code>wddbfs --anonymous --db-path=/path/to/an/example/database/like/Chinook_Sqlite.sqlite
</code></pre></div></div>
<p>Which will be available at localhost:8080 with no username or password required. <sup id="fnref:3" role="doc-noteref"><a href="#fn:3" rel="footnote">2</a></sup></p>
<p>Once you’ve <a href="https://support.apple.com/guide/mac-help/connect-disconnect-a-webdav-server-mac-mchlp1546/mac">mounted</a> this WebDAV filesystem at, for example <code>/Volumes/127.0.0.1/</code>, you can see all the databases you specified with <code>--db-path</code>.<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">3</a></sup></p>
<div><div><pre><code>$ ls /Volumes/127.0.0.1/
Chinook_Sqlite.sqlite
$ ls /Volumes/127.0.0.1/Chinook_Sqlite.sqlite
Album.csv           Customer.tsv        Invoice.jsonl       Playlist.json
Album.json          Employee.csv        Invoice.tsv         Playlist.jsonl
Album.jsonl         Employee.json       InvoiceLine.csv     Playlist.tsv
Album.tsv           Employee.jsonl      InvoiceLine.json    PlaylistTrack.csv
Artist.csv          Employee.tsv        InvoiceLine.jsonl   PlaylistTrack.json
Artist.json         Genre.csv           InvoiceLine.tsv     PlaylistTrack.jsonl
Artist.jsonl        Genre.json          MediaType.csv       PlaylistTrack.tsv
Artist.tsv          Genre.jsonl         MediaType.json      Track.csv
Customer.csv        Genre.tsv           MediaType.jsonl     Track.json
Customer.json       Invoice.csv         MediaType.tsv       Track.jsonl
Customer.jsonl      Invoice.json        Playlist.csv        Track.tsv
</code></pre></div></div>
<p>By default, all the tables can be read as CSV, TSV, json and line-delimited json (“.jsonl”)</p>
<p>These files can be manipulated with tools that work with a standard filesystem:</p>
<div><div><pre><code>$ tail -n 3 Chinook_Sqlite.sqlite/Album.tsv
345     Monteverdi: L&#39;Orfeo     273
346     Mozart: Chamber Music   274
347     Koyaanisqatsi (Soundtrack from the Motion Picture)      275
$ grep &#34;Mahler&#34; Chinook_Sqlite.sqlite/Artist.jsonl 
{&#34;ArtistId&#34;: 240, &#34;Name&#34;: &#34;Gustav Mahler&#34;}
</code></pre></div></div>
<p>Although for now, the whole table gets read into memory for every read so this won’t work well for very large database files. There’s also no write support… yet.</p>

</article>

</div></div>
  </body>
</html>
