<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cliffle.com/blog/who-killed-the-network-switch/">Original</a>
    <h1>Who killed the network switch? A Hubris Bug Story</h1>
    
    <div id="readability-page-1" class="page"><div>
            
<div>
  <header>
    
    <p>A Hubris Bug Story</p>
  </header>
  
  <p><span>2024-03-24</span></p><ul>
    
      <li><a href="https://cliffle.com/blog/who-killed-the-network-switch/#what-s-a-hubris">What’s a Hubris?</a>
        
        </li>
    
      <li><a href="https://cliffle.com/blog/who-killed-the-network-switch/#the-scene-of-the-crime">The scene of the crime</a>
        
        </li>
    
      <li><a href="https://cliffle.com/blog/who-killed-the-network-switch/#squeezing-more-out-of-limited-ram">Squeezing more out of limited RAM</a>
        
        </li>
    
      <li><a href="https://cliffle.com/blog/who-killed-the-network-switch/#the-smoking-gun">The smoking gun</a>
        
        </li>
    
      <li><a href="https://cliffle.com/blog/who-killed-the-network-switch/#extending-rust-borrows-across-tasks-in-hubris-ipc">Extending Rust borrows across tasks in Hubris IPC</a>
        
        </li>
    
      <li><a href="https://cliffle.com/blog/who-killed-the-network-switch/#when-features-attack">When features attack</a>
        
        </li>
    
      <li><a href="https://cliffle.com/blog/who-killed-the-network-switch/#how-two-innocent-features-conspired-to-kill-the-network-switch">How two innocent features conspired to kill the network switch</a>
        
        </li>
    
      <li><a href="https://cliffle.com/blog/who-killed-the-network-switch/#the-call-is-coming-from-inside-the-house">The call is coming from inside the house!</a>
        
        </li>
    
      <li><a href="https://cliffle.com/blog/who-killed-the-network-switch/#failing-with-hubris">Failing with Hubris</a>
        
        </li>
    
  </ul>
  
  <p>We found a neat bug in <a href="https://hubris.oxide.computer/">Hubris</a> this week. Like many bugs, it wasn’t a bug when
it was originally written — correct code <em>became</em> a bug as other things
changed around it.</p>
<p>I thought the bug itself, and the process of finding and fixing it, provided an
interesting window into our development process around Hubris. It’s very rare
for us to find a bug in the Hubris kernel, mostly because it’s so small. So I
jumped at the opportunity to write this one down.</p>
<p>This is a tale of how two features, each useful on its own, can combine to
become a bug. Read on for details.</p>
<h2 id="what-s-a-hubris">What’s a Hubris?</h2>
<p>Hubris is an operating system designed for deeply embedded systems — all the
computers that you don’t think of as “computers,” like the one inside a
keyboard. We wrote it to handle all the tasks required to start up the <em>big</em>
processors — the part you <em>do</em> think of as “computers” — in the Oxide Rack.</p>
<p>Hubris is pretty weird. I’ll explain the bits of that are relevant to this story
below. If you’d like more background, I recommend reading either</p>
<ul>
<li><a href="https://hubris.oxide.computer/reference/">The reference manual</a>, which is intended to be accessible to folks
without previous Hubris experience, or</li>
<li><a href="https://cliffle.com/blog/on-hubris-and-humility/">My presentation that announced it</a>.</li>
</ul>
<h2 id="the-scene-of-the-crime">The scene of the crime</h2>
<p>Like any good murder mystery, let’s start with the victim.</p>
<p>My colleague Arjen Roodselaar is largely responsible for the firmware that runs
on our network switches at Oxide. He was testing a change he’d made to power
sequencing and clock configuration — the very important bits that are
responsible for turning everything else on. After a seemingly innocuous change,
suddenly, the switch wouldn’t power on.</p>
<p>Curiously, <em>parts of the firmware</em> would respond to inquiries, but the really
important part — the power supply sequencer — seemed to be dead in its
tracks. Without power, the network switch was just a rather large, very heavy
paperweight.</p>
<p>Messing up power sequencing can literally fry the hardware. Was the switch dead
or merely unresponsive? And how did an apparently unrelated code change, to a
different part of the system, kill power sequencing?</p>
<p>A mystery!</p>
<p>Alright, with that stage set, let’s flash-back to talk about a couple of Hubris
design details.</p>
<h2 id="squeezing-more-out-of-limited-ram">Squeezing more out of limited RAM</h2>
<p>On the relatively inexpensive microcontrollers we use with Hubris, one of the
challenges is that RAM (and flash, for storing code) is quite limited. For
instance, we have an internal board that serves as a useful I2C debugging probe
and has 8 kiB of RAM and 32 kiB of flash. The system you’re reading this on,
even if it’s an inexpensive phone, might have a million times that.</p>
<p>Hubris faces this challenge a bit more than other operating systems in our
niche, because firmware using Hubris is built out of many separately-compiled
programs called <em>tasks.</em> Each task gets its own copy of everything it needs,
including common standard library code. This means our systems tend to have
somewhat higher resource requirements than others (though not by as much as
you might expect — this will be the topic of another post).</p>
<p>We isolate tasks from each other using the hardware memory protection unit,
which keeps them from crashing or corrupting each other. This adds some pressure
on our RAM and flash requirements, though. In the ARM microcontrollers that we
mostly use to run Hubris — the older members of the Cortex-M family, aka the 
ARMv7-M architecture — any protected region of memory has to be a <em>power of
two</em> in size, and aligned according to its size. This means if you have a region
that is currently 1024 bytes, and you need one more byte, you can’t just grow it
to 1025 — it is now 2048 bytes whether you like it or not.</p>
<p>Originally, Hubris used one memory protection region for a task’s RAM, and one
for its flash. Simple, but wasteful. This encouraged <a href="https://en.wikipedia.org/wiki/Fragmentation_(computing)">fragmentation</a>, which in
practice meant that there was often unused RAM and flash left between tasks that
didn’t quite line up. That unused memory was basically wasted. This is really
frustrating when you don’t have enough of it to begin with!</p>
<p>My colleague <a href="https://www.mattkeeter.com/blog/">Matt Keeter</a> fixed this recently by making the system smarter: it
now attempts to pack tasks using multiple power-of-two regions where possible.
(“Where possible” is important, because the hardware limits each task to no more
than eight regions, total.) In some of our firmware images, this recovered 30%
of RAM! Our smallest devices went from being so crammed full that I regularly
had to make optimization passes over the code, to having free space to spare.</p>
<p>This is incredibly awesome. But how is it relevant? I’ll explain in a bit. But
first:</p>
<h2 id="the-smoking-gun">The smoking gun</h2>
<p>Arjen reached for Humility, our debugger for Hubris, and gently probed the
failed network switch. The service processor responsible for power sequencing
appeared to be alive and running, so a hardware problem was unlikely.</p>
<p>One of the first commands we tend to reach for to learn about the state of a
running Hubris system is <code>humility tasks</code>. This prints a list of tasks running
on the processor, as well as information about their status. When Arjen ran
<code>humility tasks</code>, one line in particular jumped out: the <code>sequencer</code> task, which
is the component responsible for power sequencing, had the following status:</p>
<pre><code><span>mem fault (precise: 0x801bffd) in syscall (was: wait: reply from i2c_driver/gen0)
</span></code></pre>
<p>The task also indicated that it had been restarted 115 times. Since we pretty
much only restart tasks in response to crashes, that suggested that this fault
— whatever it was! — was occurring every time the sequencer tried to power
the system on.</p>
<p>So the task was getting killed. But who pulled the trigger?</p>
<p>The answer involves an important aspect of Hubris IPC.</p>
<h2 id="extending-rust-borrows-across-tasks-in-hubris-ipc">Extending Rust borrows across tasks in Hubris IPC</h2>
<p>Hubris tasks can communicate with each other using <em>messages</em> in an
Inter-Process Communication scheme, or IPC. Each message looks and behaves very
much like a function call: the task sending the message stops, the task
receiving it takes control of the CPU, and eventually returns some result that
causes the sender to wake back up.</p>
<p>We chose this scheme for a bunch of reasons — there are, after all, many other
options! — but one of the most useful ones is that it plays nicely with Rust’s
resources ownership model. Just as a function can loan some memory it controls
to a function it calls, and reliably get ownership back when the function
returns, a task on Hubris can loan some of its memory to another task along with
an IPC message.</p>
<p>This feature is very widely used in Hubris-based firmware. For example, tasks
that want to interact with an I2C device loan sections of their memory to the
I2C bus driver, which then reads and/or writes them in-place. This keeps the bus
driver itself from needing to have a buffer pool or similar resource internally,
and reduces the number of copies needed to move data from place to place.</p>
<p>It’s also a potential security hole if implemented incorrectly. Much of Hubris’s
reliability comes from the <em>isolation</em> of tasks; tasks don’t share any memory,
so one task can do arbitrarily silly things in its own space without hurting any
other tasks. So it’s very important that loaning memory via IPC doesn’t let
tasks break out of their isolated containers.</p>
<p>And so, attempting to loan memory that you don’t actually <em>own</em> is bad.
Specifically, it’s forbidden by the Hubris kernel.</p>
<p>If a caller attempts to loan memory it can’t access to a server, once this is
discovered, the server is handed an apologetic error code by the kernel, while
the client receives a fault. To the server, this is never fatal; to the client,
it is <em>always fatal.</em> We assume that the access violation indicates a bug,
corruption, or exploit in the sending task, so we immediately shut it down
without giving it an opportunity to respond.</p>
<p>When the kernel does this, it records information about the triggering event,
which (when formatted for human consumption) produces a status like the one
Arjen found on the sequencer task. Let’s take it apart:</p>
<pre><code><span>mem fault (precise: 0x801bffd) in syscall (was: wait: reply from i2c_driver/gen0)
</span></code></pre>
<p>This says:</p>
<ul>
<li><code>mem fault</code>, because the task was faulted for incorrect handling of memory;</li>
<li><code>precise</code>, because we can tell the specific address that was handled
incorrectly;</li>
<li><code>in syscall</code>, because the task wasn’t actually <em>running</em> when the fault
occurred; and</li>
<li><code>was: wait: reply from i2c_driver/gen0</code>, because at the time the fault
occurred, instead of running, the task was waiting for a reply from a message
it sent to the I2C driver. We always try to record the task state <em>just
before</em> the fault happened to help with debugging.</li>
</ul>
<p>(If you’re curious, the <code>gen0</code> means the <code>i2c_driver</code> is on generation 0, which
means it hasn’t ever crashed. <code>sequencer</code> was on generation 115!)</p>
<p>The kernel distinguishes between <em>real</em> and <em>synthetic</em> faults. A real fault
happens when a task does something simple and wrong, such as dereferencing a
null pointer, or trying to write to its code region. Real faults are generated
by the hardware (in this case, the memory protection unit) in response to
actions performed by a task. As a result, they can only happen when the task is
actually running and doing something wrong.</p>
<p>Rather than <em>hardware</em> rules, synthetic faults represent violations of
<em>software</em> rules. The processor has no concept of “IPC” or “loaning memory
across tasks,” those are ideas that Hubris added to the system. They have their
own rules, and if a task violates them, we treat it just like a null pointer
dereference or other “real” hardware fault — just with a different set of
fault information that marks it as synthetic.</p>
<p>So, from this rather dense status report, we have learned the following:</p>
<ul>
<li>The <code>sequencer</code> task broke the kernel’s rules for memory access.</li>
<li>It did so at the address <code>0x801bffd</code>, which is an unusual but valid address in
flash for the processor.</li>
<li>It did so as part of an IPC sent to the I2C driver.</li>
</ul>
<p>This seems really bad! Memory access violations usually indicate a very serious
program bug or data corruption. The fact that one was happening in the sequencer
task, despite that task not having changed much recently, suggested that we had
some kind of long-hidden data corruption bug!</p>
<p>This would be very unusual — since our firmware is almost entirely safe Rust,
data corruption bugs are incredibly rare in our systems. But all signs point to
data corruption here.</p>
<p>…or do they?</p>
<h2 id="when-features-attack">When features attack</h2>
<p>The address reported for the memory violation was <code>0x801bffd</code>.</p>
<p>When Arjen called me in for assistance, this immediately looked weird. It’s a
valid flash address, sure, but it’s three bytes below a power of two boundary.
We knew this wasn’t a result of an accidental integer overflow in an address
computation, because Hubris systems enable runtime integer overflow checks —
the task would have crashed and reported the problem.</p>
<p>And that’s when I remembered Matt’s packing change.</p>
<p>Recall that the MPU on our processor requires memory regions to be power-of-two
sized and aligned. I used <code>humility mem</code> to print the image’s memory layout, and
sure enough, there was a region ending at <code>0x801c000</code>, and another one starting
at the same address.</p>
<p>And they both belonged to the <em>same task.</em></p>
<pre><code><span>LOW         HIGH           SIZE ATTR   ID TASK
</span><span>0x08018000 - 0x0801bfff   16kiB r-x--- 17 sequencer
</span><span>0x0801c000 - 0x0801dfff    8kiB r-x--- 17 sequencer
</span></code></pre>
<p>This is perfectly fine, except when it’s not.</p>
<p>The memory access permission checking code is one of the most security-critical
parts of the Hubris kernel. We try to keep the most important code as simple as
possible. As I mentioned above, early in Hubris’s life — which was when I
wrote this part of the kernel — tasks had a single region for RAM and a single
region for Flash, and that’s that.</p>
<p>And I simplified the kernel checking code to reflect that. It was:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>self</span><span>.</span><span>region_table</span><span><span>(</span></span><span><span>)</span></span><span>.</span><span>iter</span><span><span>(</span></span><span><span>)</span></span><span>.</span><span>any</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>region</span><span>|</span></span> </span><span><span><span>{</span>
</span></span></span></span><span><span><span><span>    region<span>.</span><span>covers</span><span><span>(</span>slice</span><span><span>)</span></span>
</span></span></span></span><span><span><span><span>        <span>&amp;&amp;</span> region<span>.</span>attributes<span>.</span><span>contains</span><span><span>(</span>desired</span><span><span>)</span></span>
</span></span></span></span><span><span><span><span>        <span>&amp;&amp;</span> <span>!</span>region<span>.</span>attributes<span>.</span><span>intersects</span><span><span>(</span>forbidden</span><span><span>)</span></span>
</span></span></span></span><span><span><span><span></span><span><span>}</span></span></span></span><span><span>)</span></span>
</span></code></pre>
<p>An access was permitted if, and only if, there was any single region in the
task’s region table that</p>
<ol>
<li>Completely covered the slice of memory being loaned,</li>
<li>Had all the required attributes (e.g. it was writable if the IPC said it
should be writable), and</li>
<li>Did not have any “forbidden” attributes, like containing memory-mapped
registers or being used for hardware DMA. (Such memory cannot currently be
loaned, for subtle reasons that are out of scope for this post.)</li>
</ol>
<p>At the time that code was written, it was correct, but it embodied the
assumption that any loaned memory would fit into <em>one</em> region.</p>
<p>That assumption became obsolete the moment that Matt implemented task packing,
but we didn’t notice. This code, which was still simple and easy to read, was
now also <em>wrong.</em></p>
<p>Critically, this code is only used to check loaned memory. Normal accesses from
a running program are checked by the hardware memory protection unit directly,
and the hardware doesn’t have this bug. This means the task probably had no
trouble at all accessing memory across this region boundary… until it tried to
loan it out.</p>
<h2 id="how-two-innocent-features-conspired-to-kill-the-network-switch">How two innocent features conspired to kill the network switch</h2>
<p>Task packing in our build system operates <em>opportunistically.</em> Because the MPU
hardware limits each task to no more than 8 regions, and because many tasks
represent hardware drivers that have various memory-mapped registers accessible
through some of those regions, we don’t always have enough region slots left
over in the 8-region table to be clever about task layout.</p>
<p>But whenever we <em>can</em>, we attempt to pack the tasks using multiple regions.</p>
<p>The net effect of this is that region boundaries are now being introduced in the
middle of task flash and RAM regions. Critically, they’re appearing at places
that are <em>very difficult for the author of the task itself to predict.</em> The
layout of tasks in memory, and the places where those boundaries fall, depend on
the size required for each task.</p>
<p>This means an apparently innocuous change in task A, if it changes task A’s size
very slightly, can now move the positions of MPU region boundaries in unrelated
task B.</p>
<p>It was now pretty clear that this behavior was bad. Apparently random crashes
that go away when you add some debugging code are the <em>worst kind</em> of crash, but
that was the situation we were in — since adding any code to the system would
shift the allocation decisions and the region boundaries, potentially angering
the kernel.</p>
<p>Matt immediately switched off the task packing feature in the build system,
which let Arjen build a working firmware image and continue with his network
switch hacking. Meanwhile, I <a href="https://github.com/oxidecomputer/hubris/issues/1672">started writing up my analysis on a bug
report</a>, and prepared to face this murderer I had accidentally created
four years earlier.</p>
<h2 id="the-call-is-coming-from-inside-the-house">The call is coming from inside the house!</h2>
<p>Since the kernel was now killing tasks in a misguided attempt to enforce memory
protection, the memory protection algorithm needed to change. A previously
appealing <em>simplification</em> was now an <em>over-simplification.</em></p>
<p>The basic <em>intent</em> of the algorithm remained the same as when I originally wrote
it in 2020:</p>
<ol>
<li>
<p>Let tasks specify sections of memory they want to loan with a message.</p>
</li>
<li>
<p>Require that the task <em>actually has</em> the access to that memory that it claims.
For instance, if it’s attempting to loan some memory writable, it had better
be able to write the memory itself! Otherwise, the mechanism could let tasks
gain powers they aren’t supposed to have.</p>
</li>
</ol>
<p>The only thing that’s different is that we now need to tolerate the loaned
memory crossing MPU regions, as long as those regions are exactly adjacent.</p>
<p>The <a href="https://github.com/oxidecomputer/hubris/blob/b44e677fb39cde8be5b10bbf78a9f26c000f6ad6/sys/kerncore/src/lib.rs#L103">replacement algorithm</a> is significantly more complex than the
original, because it’s taking pains to perform a single pass over the region
table. We try really hard in Hubris to not expose operations that have
<em>task-controlled time complexity.</em> We’re not perfect at it, but we try. So it
was important to me that the algorithm’s performance depend only on the size of
the <em>region table</em> — fixed at 8 — rather than the amount of memory being
loaned. It’s possible to do this in a single pass if you know in advance that
the table is in sorted address order; I altered the build system to ensure that
this was always true. You can read <a href="https://github.com/oxidecomputer/hubris/commit/b44e677fb39cde8be5b10bbf78a9f26c000f6ad6#diff-0270185909262248f95c960a9fdd6074669172623c61f59781ee47b50ddc9c69R156">the commit</a> if you want the
gritty details, but the important bit was:</p>
<pre data-lang="rust"><code data-lang="rust"><span></span><span>
</span><span></span><span></span><span></span><span></span><span>regions<span>.</span><span>sort_by_key</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>i</span><span>|</span></span> </span><span>region_table<span>.</span><span>get_index</span><span><span>(</span><span>*</span>i</span><span><span>)</span></span><span>.</span><span>unwrap</span><span><span>(</span></span><span><span>)</span></span><span>.</span><span>1.</span>base</span></span><span><span>)</span></span><span>;</span>
</span></code></pre>
<p>…added to the kernel’s <code>build.rs</code> file.</p>
<p>Because the new algorithm is much more complex, my colleague <a href="https://elizas.website/">Eliza
Weissman</a> nudged me into factoring it out of the core Hubris kernel, and
into a <a href="https://github.com/oxidecomputer/hubris/tree/b44e677fb39cde8be5b10bbf78a9f26c000f6ad6/sys/kerncore">more portable crate</a> where it can be more easily unit-tested.
It currently has unit tests for the corner cases we’re most concerned about; we
plan to add a few more, in the words of Kent Beck, “until fear turns to
boredom.”</p>
<p>When I say the code is “much more complex,” I mean relative to Hubris’s original
code that performed the same function; it’s still much simpler than the
equivalent code in most operating systems. Here’s all of it, with the comments
from the original. (Note that <code>slice</code> here is not a Rust slice in the kernel,
but a struct representing a <em>task-proposed slice</em> by address and size.)</p>
<pre data-lang="rust"><code data-lang="rust"><span></span><span></span><span></span><span><span>let</span> <span>mut</span> scan_addr <span>=</span> slice<span>.</span><span>base_addr</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</span><span><span>let</span> end_addr <span>=</span> slice<span>.</span><span>end_addr</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</span><span>
</span><span><span>for</span> region <span>in</span> table <span><span>{</span>
</span></span><span><span>    <span>if</span> region<span>.</span><span>contains</span><span><span>(</span>scan_addr</span><span><span>)</span></span> <span><span>{</span>
</span></span></span><span><span><span>        </span></span></span><span><span><span>        <span>if</span> <span>!</span><span>region_ok</span><span><span>(</span>region</span><span><span>)</span></span> <span><span>{</span>
</span></span></span></span><span><span><span><span>            </span></span></span></span><span><span><span><span>            <span>break</span><span>;</span>
</span></span></span></span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>        <span>if</span> end_addr <span>&lt;=</span> region<span>.</span><span>end_addr</span><span><span>(</span></span><span><span>)</span></span> <span><span>{</span>
</span></span></span></span><span><span><span><span>            </span></span></span></span><span><span><span><span>            </span></span></span></span><span><span><span><span>            <span>return</span> <span>true</span><span>;</span>
</span></span></span></span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>        </span></span></span><span><span><span>        scan_addr <span>=</span> region<span>.</span><span>end_addr</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    </span><span><span>}</span></span> <span>else</span> <span>if</span> region<span>.</span><span>base_addr</span><span><span>(</span></span><span><span>)</span></span> <span>&gt;</span> scan_addr <span><span>{</span>
</span></span></span><span><span><span>        </span></span></span><span><span><span>        </span></span></span><span><span><span>        <span>break</span><span>;</span>
</span></span></span><span><span><span>    </span><span><span>}</span></span>
</span></span><span><span></span><span><span>}</span></span>
</span><span>
</span><span></span><span></span><span><span>false</span>
</span></code></pre>
<p>With this new code, we can turn task packing back on without handing task
developers a ticking time-bomb.</p>
<p>In all, about three hours had passed from the time Arjen noticed the network
switch malfunctioning, until the kernel bug was fixed. I hacked on the unit
tests the next morning.</p>
<h2 id="failing-with-hubris">Failing with Hubris</h2>
<p>For me, the interesting thing about this story is all the stuff that didn’t
happen. Or more specifically, the way the system failed, and the ways in which
it didn’t.</p>
<p>We went from “network switch won’t turn on with new firmware,” to two engineers
3,000 miles apart separately analyzing snapshots of the failure, to having the
kernel bug fixed, in about three hours. I’ve easily spent longer than that
chasing a <em>single</em> memory corruption bug in other firmware. I think the
difference comes down to the following things.</p>

<p><strong>Fault isolation.</strong> We had a crash during power sequencing on a <em>very</em> complex
piece of hardware. But only part of the system crashed. The network switch
firmware consists of 23 isolated components (tasks). Some of them have
dependencies on power sequencing at various points in their lifecycle, of course
— power sequencing is very important! — but for the most part they kept
working through the <em>one hundred and fifteen crash and restart attempts.</em> This
includes:</p>
<ul>
<li>The in-system firmware update system.</li>
<li>The IP network stack providing the management and control interface.</li>
<li>Several network services, from a basic <code>echo</code> protocol implementation up
through our rack control plane interface.</li>
<li>I2C, SMBus, and PMBus to all the sensors, fans, and miscellanea monitoring the
system’s resource usage and physical health.</li>
<li>Drivers for 32 QSFP 100-gigabit transceivers across the front of the switch.</li>
</ul>
<p>…and more. They kept working because of the fault isolation that Hubris
provides, which manifested here in two ways. First, the sequencer task was able
to crash without disrupting state in any other task, hardware peripheral, or the
kernel. Second, the Hubris IPC mechanism is specifically designed under the
assumption that other tasks may fail, and allows operations marked “idempotent”
to be transparently retried, letting clients decouple themselves from crashing
servers.</p>
<p><strong>Failing toward safety.</strong> In Hubris, both the implementation and the APIs try
to maintain <em>one-sided error</em> — preventing some correct programs, rather than
allowing some incorrect programs. The original memory access check algorithm was
blocking accesses by a correct program, <em>not</em> admitting invalid accesses by a
wrong or malicious program. This means it’s a rare case of a kernel memory
access check bug that had no security implications. We’ve tried to maintain this
throughout the stack, by comprehensively parsing all input as untrusted and
making any undefined usage a fault. As a result, when the system fails, it tends
to fail in non-exploitable ways.</p>
<p><strong>Safer shared memory.</strong> Because of how we designed the IPC memory loan
mechanism, even though the sequencer task and the I2C driver were effectively
sharing memory at the time the sequencer crashed, the I2C driver was at no risk
of corruption, and could go on with its business. (It never did restart, in the
end.) This is because we assumed that a task acting as a server (like the I2C
driver, here) will typically serve more than one client, and so needs to be made
as robust as possible to arbitrary mistakes by clients. Including, in this case,
(apparent) memory access violations.</p>
<p><strong>Kernel-debugger codesign.</strong> My colleague Bryan Cantrill wrote the code that
became Humility, our debugger, at the same time that I was writing the code that
would become the Hubris kernel. The two programs have grown and changed
together, and I wouldn’t have it any other way. Thanks to Humility, Arjen was
able to identify the crashing code (down to the line number) within the first
few minutes, and take a self-contained snapshot of the service processor, which
he posted in a chat channel for Matt and I to pore over.</p>
<p><strong>Firmware crash dumps are really great.</strong> I never had physical access to the
crashing network switch, and in fact I’m not actually sure where in the country
it’s located. It doesn’t really matter; Humility can dump a consistent snapshot
of our embedded systems when <em>at least one person</em> has physical access, and
Hubris itself records compressed coredumps of crashing tasks into
RAM where we can retrieve them over the network. This means we can still
get crash dumps despite not having writable persistent storage, such as flash.</p>


<p><strong>Simplicity of design and implementation.</strong> The concepts provided by the Hubris
kernel are simple — so simple, in fact, that I was initially concerned that
they couldn’t be used to make useful production firmware. (Thankfully I was
wrong!) The IPC mechanism has only three operations and no optional or fancy
parts, so when a fault points to IPC, there are not a lot of places you might
need to hunt for the problem.</p>
<p>But if you <em>did</em> have to hunt in a lot of places for the problem, the
architecture-independent part of the Hubris kernel is currently 1,789 lines of
code. That’s about four copies of this post. In a pinch, a single person
could read through the entire kernel in search of a bug.</p>
<p>We haven’t had to do that yet, but it’s nice to know that we could if we had to!</p>

<p><strong>Tight nonhierarchical integration of the team.</strong> This isn’t a Hubris feature,
but it’s hard to separate Hubris from the team that built it. Oxide’s
engineering team has essentially no internal silos. Our culture rewards
openness, curiosity, and communication, and discourages defensiveness,
empire-building, and gatekeeping. We’ve worked hard to create and defend this
culture, and I think it shows in the way we organized horizontally, across the
borders of what other organizations would call teams, to solve this mystery.</p>
<p>If I hadn’t been in the office that day, somebody else would have found and
fixed the bug in my place — if not me it would have been Matt, or Laura
Abbott, or Eliza, or Arjen, or Bryan, or any of several other people. This is
really important to me. They would have done so without fear of reprisal; at
most, they might have done it slightly slower, since I wrote the original buggy
code and knew where the bodies were buried — but not dramatically slower.
There is a real benefit to keeping critical code simple, well-commented, easy to
reason about, and accessible — and there’s a real benefit to maintaining a
team culture where <em>everyone</em> can take advantage of that.</p>
<p>Incidentally, we could use more help; at the time of this writing, we’re hiring
more software folk. For details, <a href="https://oxide.computer/careers/software-engineer">see the job description on our site</a>.</p>

  
    <p><span>
      
        <a href="https://cliffle.com/tags/api-design/">#api-design</a>
      
        <a href="https://cliffle.com/tags/dayjob/">#dayjob</a>
      
        <a href="https://cliffle.com/tags/embedded/">#embedded</a>
      
        <a href="https://cliffle.com/tags/rust/">#rust</a>
      
        <a href="https://cliffle.com/tags/security/">#security</a>
      
    </span>
  
</p></div>

        </div></div>
  </body>
</html>
