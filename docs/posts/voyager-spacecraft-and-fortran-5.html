<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://www.geonius.com/writing/other/voyager.html">Original</a>
    <h1>Voyager Spacecraft and Fortran 5</h1>
    
    <div id="readability-page-1" class="page">

<!-- $Id: writing_header.txt,v 1.1 2022/09/09 02:31:38 alex Exp alex $ -->




<h3>2024</h3>

<p>
<span>The Voyager spacecraft,
<i><a href="https://en.wikipedia.org/wiki/Voyager_1">Voyager 1</a></i> and
<i><a href="https://en.wikipedia.org/wiki/Voyager_2">Voyager 2</a></i>, were
<strong><em>not</em></strong> programmed in Fortran 5.</span>  Or in any
Fortran for that matter.  This widely accepted misbelief can be traced back
to a widely misunderstood statement in a single magazine article.
</p>



<div>
<p>
    This is a personal project of mine.  Everywhere I turned the past few
    years, someone was saying that the Voyager spacecraft were programmed
    in Fortran 5.  I didn&#39;t believe it.  I gathered a few links here and
    there, but, in early 2024, I sat down and did some serious online
    research.  Well, kind of serious and not particularly systematic.
    This is what I found.  It&#39;s wordy, it rambles, and the writing is
    somewhat uneven, but I hope you&#39;ll find the information useful or
    at least follow the links in your own explorations.  There are many
    fascinating aspects of the Voyager project that one normally might
    not think of and only learn of by accident.  I think you&#39;ll find
    that even casual browsing can yield rich rewards!
</p>
<p>
    You&#39;ll find phrases like &#34;apparently&#34;, &#34;perhaps&#34;, &#34;it seems&#34;, and
    &#34;it suggests&#34; throughout the text.  They mean I can&#39;t definitively
    assert what the sentence is about to say.  For example, a great deal
    of my discussion of sequencing and simulation is based on McEvoy&#39;s
    Viking Orbiter paper.  There is no comparable Voyager paper that
    provides his level of detail, so I can&#39;t with certainty say that
    some thing done on Viking is done in the same way on Voyager—it
    just seems likely!  These uncertainties do not affect the
    fact — and central thrust of this piece — that
    the Voyager onboard computers were <em>not</em> programmed in Fortran.
</p>
<p>
    My background: I&#39;m a retired software developer.  In the 1980s, I worked
    on the image processing ground system for NASA&#39;s LANDSAT 4 and 5 remote
    sensing satellites; we used VAX/VMS Fortran-77.  In the late 1980s and
    early 1990s, I worked on a configurable, Unix workstation-based, control
    center for NASA&#39;s Goddard Space Flight Center, mostly written in C.  In
    the late 1990s through the mid-2000s, I worked on a similar system in C++
    for commercial satellite fleets.  (The latter was originally based on the
    former thanks to NASA&#39;s generosity in sharing technology with industry.)
    My brother got interested in ham radio when we were in junior high school
    and I picked up a rudimentary knowledge of electronics and radio through
    osmosis.
</p>
<p>
    The title of this piece is constructed from the titles of two songs by
    <a href="https://en.wikipedia.org/wiki/I_Start_Counting_(band)#As_Fortran_5">Fortran
    5</a> (Wikipedia) released on their 1991 album, <cite>Blues</cite>:
    &#34;<a href="https://www.youtube.com/watch?v=rw94U_OlXMo">Crazy Earth</a>&#34;
    (YouTube) and
    &#34;<a href="https://www.youtube.com/watch?v=Hygiztbx7MQ">Look To The
    Future</a>&#34; (YouTube)!
</p>
</div>


<h2 id="Introduction">1.  Introduction</h2>

<p>
The Voyager program took advantage of a rare planetary alignment to send
two spacecraft on a tour of the solar system&#39;s gas giants: Jupiter, Saturn,
Uranus, and Neptune.  In addition to the cameras and scientific instruments,
each Voyager has 3 computers (plus their backups, for a total of 6):
</p>

<ul>
<li><p>
    <i>Computer Command Subsystem</i> (CCS) - is the basically the master
    controller of the spacecraft.  As such, it &#34;provides sequencing and
    control functions.  The CCS contains fixed routines such as command
    decoding and fault detection and corrective routines, antenna pointing
    information, and spacecraft sequencing information.&#34;
    (<a href="https://voyager.jpl.nasa.gov/mission/spacecraft/">Voyager: The
    Spacecraft</a>, JPL)  The CCS CPU is the same as used on the Mars
    <a href="https://en.wikipedia.org/wiki/Viking_program#Control_systems">Viking</a>
    Orbiters.
</p></li>
<li><p>
    <i>Attitude and Articulation Control Subsystem</i> (AACS) - &#34;controls
    spacecraft orientation, maintains the pointing of the high gain antenna
    towards Earth, controls attitude maneuvers, and positions the scan
    platform.&#34;  The cameras and a couple of other instruments are mounted
    on the scan platform, hence adjusting their orientation must be done
    in conjunction with the spacecraft&#39;s orientation.
    (<a href="https://voyager.jpl.nasa.gov/mission/spacecraft/">Voyager: The
    Spacecraft</a>, JPL)  The AACS computer is <em>not</em> the at-the-time
    experimental HYPACE computer.  This turned out to be an unexpected rabbit
    hole, so see &#34;<a href="#AACS">AACS, HYPACE, and HYBIC</a>&#34; below for more
    details.
</p></li>
<li><p>
    <i>Flight Data Subsystem</i> (FDS) - &#34;controls the science instruments and
    formats all science and engineering data for telemetering to Earth.&#34;
    (pre-launch
    <a href="http://planetary.s3.amazonaws.com/assets/presskit/voyager-launch.pdf">Voyager
    Press Kit</a>, August 4, 1977, p. 22, PDF)  The FDS used a custom-designed
    CPU.
</p></li>
</ul>

<div>
<p>
    Dr. James E. Tomayko&#39;s
    <cite><a href="https://web.archive.org/web/20231203155757/https://history.nasa.gov/computers/Compspace.html">Computers
    in Spaceflight: The NASA Experience</a></cite> (1988) is an oft-cited,
    authoritative (and eminently readable) source of information about
    computing systems in space up until the date of the report.
    <a href="https://web.archive.org/web/20231123211500/https://history.nasa.gov/computers/Ch6-2.html">Chapter
    Six, Section 2</a> gives the history of and details about the three Voyager
    computers.  (Since the CCS computer was borrowed from Viking, also see the
    more detailed description of the Viking Orbiter CCS in
    <a href="https://web.archive.org/web/20231123211500/https://history.nasa.gov/computers/Ch5-6.html">Chapter
    Five, Section 6</a>.)
</p>
<p>
    The links above take you to an archived copy of the HTML version of
    the study.  Sometime in December 2023 or January 2024, NASA removed
    the HTML version and redirected all links to this
    <a href="https://ntrs.nasa.gov/citations/19880069935">download page</a>
    for a PDF version.  At first, it was a 500-MB PDF!  After a query from
    me, they replaced it with an optimized 36-MB PDF.  The text is not as
    crisp, but it&#39;s readable.  (The higher-quality 500-MB PDF is still
    available for online reading or download at the
    <a href="https://archive.org/details/nasa_techdoc_19880069935">Internet
    Archive</a>.)
</p>
</div>

<p>
And, expanding our vocabulary:
</p>

<ul>
<li><p>
    <i>Flight Computers</i> - are the computers onboard a spacecraft, like
    the three above.
</p></li>
<li><p>
    <i>Flight Software</i> - is the collection of programs and routines that
    run on the flight computers.  Like any computer program, the flight
    software is composed of low-level <i>CPU instructions</i> such as
    &#34;Load CPU register A with the value at memory address 1234&#34;.  <i>Flight
    software engineers</i> write and maintain these programs.
</p></li>
<li><p>
    <i>Spacecraft Commands</i> - are binary commands that perform operations
    on the spacecraft.  Uplinked to the spacecraft by mission control, they
    are <em>not</em> CPU instructions.  In a spacecraft without computers,
    the commands are fed to a hardware decoder that effects the desired
    operations.  In a spacecraft with computers, the software interprets
    the commands and runs the sometimes complex code needed to perform
    the operations.  (Think of the Unix <i>bash</i> shell, where the
    &#34;flight software&#34; is the <i>bash</i> executable and the &#34;spacecraft
    commands&#34; are the command-line commands: <i>cd</i>, <i>ls</i>, etc.)
</p></li>
<li><p>
    <i>Command Sequences</i> - are sequences of spacecraft commands uplinked
    to the spacecraft as a singular bundle.  A given sequence may be executed
    immediately, executed at a scheduled time, or executed only when the
    spacecraft&#39;s hardware or software detects some condition.  <i>Sequence
    engineers</i> design and develop command sequences.  (A simplified
    definition of sequences; see
    <a href="#SequencesAndSimulators">Sequences and Simulators</a> below
    for more details.)
</p></li>
</ul>

<p>
In the <i>telemetry</i> data radioed back to Earth:
</p>

<ul>
<li><p>
    <i>Engineering Data</i> - has to do with the health and operation
    of the spacecraft; e.g., temperatures, power levels, spacecraft
    attitude, and readouts of flight computer memory for debug purposes!
</p></li>
<li><p>
    <i>Science Data</i> - is that returned from the scientific instruments.
    The prime example is the image data from the cameras.
</p></li>
</ul>

<div>
    <p><a href="http://www.geonius.com/writing/other/voyager-1-interstellar.jpg"><img alt="Voyager 1 Enters Interstellar Space" src="http://www.geonius.com/writing/other/voyager-1-interstellar.jpg"/></a></p><p>
        &#34;This artist&#39;s concept shows plasma flows around NASA&#39;s Voyager 1
        spacecraft as it approaches interstellar space.&#34;</p>
</div>

<p>
A brief Voyager timeline (the fly-by dates are actually years of closest
encounters):
</p>

<pre>    1977 - <i>Voyager 2</i> and then <i>Voyager 1</i> launched.
    1979 - Both Voyagers fly by Jupiter.
    1980 - <i>Voyager 1</i> flies by Saturn.
    1981 - <i>Voyager 2</i> flies by Saturn.
    1986 - <i>Voyager 2</i> flies by Uranus.
    1989 - <i>Voyager 2</i> flies by Neptune.
    2004 - <i>Voyager 1</i> crosses the termination shock.
    2007 - <i>Voyager 2</i> crosses the <a href="https://www.scientificamerican.com/article/voyagers-to-the-end/">termination shock</a>.
    2012 - <i>Voyager 1</i> enters interstellar space.
    2018 - <i>Voyager 2</i> enters interstellar space.
</pre>

<p>
After the 1980 encounter with Saturn, <cite>Voyager 1</cite> angled north
from the ecliptic (planetary) plane at about 35°.  After the 1989
encounter with Neptune, <cite>Voyager 2</cite> angled south of the ecliptic
plane at about -48°.
(<a href="https://voyager.jpl.nasa.gov/frequently-asked-questions/fact-sheet/">Voyager
Fact Sheet</a>, JPL)
</p>

<p>
Entering interstellar space means the Voyagers have emerged from the
<a href="https://en.wikipedia.org/wiki/Heliosphere">heliosphere</a>,
the region in which solar winds predominate.  The spacecraft have
not yet escaped the Solar System, as the Sun&#39;s gravity still holds
sway.  That will take another 30,000 years until the spacecraft
cross the outer edge of the hypothetical
<a href="https://en.wikipedia.org/wiki/Oort_cloud">Oort Cloud</a>!
</p>

<p id="Distance">
For a real treat, see the real-time
<a href="https://voyager.jpl.nasa.gov/mission/status/">Voyager Mission
Status</a>!  I noticed that <cite>Voyager 1</cite>&#39;s distance from Earth
was rapidly <em>decreasing</em> (!) while <cite>Voyager 2</cite>&#39;s was
slowly increasing.  At the same time, both spacecraft&#39;s distances from
the Sun were increasing at a constant rate as expected, both at about
10 miles every second.  I eventually figured this out.  (Completely
missing, like an idiot, the &#34;Distance from Earth&#34; link that pops up
an explanation!)  Earth is traveling around the Sun at nearly twice
the speed of the Voyager spacecraft.  For half of its orbit, Earth
will be moving towards, for example, <cite>Voyager 1</cite> and is
thus &#34;catching up&#34; to the spacecraft.  (That&#39;s a rough, simplified
explanation.  Given the Earth&#39;s and <cite>Voyager 1</cite>&#39;s full 3-D
velocities, you must separate out the components along the changing
Earth-<cite>Voyager 1</cite> axis.  When the Earth&#39;s speed along that
axis exceeds <cite>Voyager 1</cite>&#39;s, the distance will decrease.
So the distance will decrease on only a portion of that half-year
half-orbit.)
</p>

<p>
And the <a href="https://eyes.nasa.gov/dsn/dsn.html">DSN Now</a> page shows
the real-time status of the Deep Space Network antennas and which spacecraft
they are talking to, <code>VGR1</code> and <code>VGR2</code> being the Voyager
spacecraft.
</p>




<h2 id="HowItStarted">2.  How It Started</h2>

<h3><cite>Wired</cite></h3>

<p>
In 2013, <cite>Wired</cite> published an article based on an interview with
Suzanne Dodd, Voyager project manager at the time and, currently, also
Director of the Jet Propulsion&#39;s Interplanetary Network Directorate.  In
the article, the author, Adam Mann, wrote (his words, not a direct quote
from Dodd):
</p>

<blockquote>
<p>
    The spacecrafts&#39; original control and analysis software was written in
    Fortran 5 (later ported to Fortran 77).  Some of the software is still
    in Fortran, though other pieces have now been ported to the somewhat
    more modern C.
</p>
<p>
    —Adam Mann,
    &#34;<a href="https://www.wired.com/2013/09/vintage-voyager-probes/">Interstellar
    8-Track: How Voyager&#39;s Vintage Tech Keeps Running</a>&#34;, <cite>Wired</cite>,
    September 2013.
</p>
</blockquote>

<p>
My impression upon first reading this was that the ground-system mission
control and science data analysis software was written in Fortran and parts
were later ported to Fortran 77 and C.  (I now think Dodd was referring to
mission control-related analysis instead of science data analysis.)  I&#39;d
never heard of &#34;Fortran 5&#34;, but the rest was unremarkable and tracked with
my own experience.  In the early 1980s, I worked on the image processing
side of the LANDSAT-4/5 ground system, programming in Fortran 77 on VAX/VMS
minicomputers.  The mission-control developers on the other half of our
cubicle farm at NASA&#39;s Goddard Spaceflight Center programmed in Fortran
on DEC-2060 mainframe computers.  And, in the late 1980s, I was part of
a small team developing a generic, UNIX workstation-based ground system,
TPOCC, for Goddard — programmed in C, of course!
</p>

<p>
So, aside from the &#34;Fortran 5&#34; oddity, Mann&#39;s article was spot-on and
provided an excellent update for me on the Voyager project.  Others,
however, inferred more from the quote and, shortened to one sentence
with the &#34;control and analysis&#34; phrase dropped, a misleading form of
the quote spread in the popular press and in numerous hardware and
software forums.  The inference or &#34;meme&#34;, easily identified by the
&#34;Fortran 5&#34;, is that the Voyagers&#39; <em>onboard computers</em> were
programmed in Fortran, etc., etc., as shown here:
</p>

<blockquote>
<p>
    The initial software program was Fortran 5, then they were reprogrammed
    during flight to Fortran 77, and finally C.
</p>
<p>
    —<a href="https://www.sfsa.org.au/">South Australian Doctor Who
    Fan Club Inc.</a> (SFSA), &#34;Voyagers disco party!&#34;,
    <cite>The Wall of Lies</cite>, No. 169, Nov-Dec 2017, p. 2.
    (<a href="https://efanzines.com/WOL/WOL169.pdf">4-page newsletter</a>,
    PDF)
</p>
</blockquote>

<p>
(I&#39;m not dumping on the fan club.  For my example, the juxtaposition of
Doctor Who and disco practically screamed, &#34;Choose me!  Choose me!&#34;)
</p>

<h3><cite>Popular Mechanics</cite></h3>

<p>
I originally dismissed the following 2015 article in <cite>Popular
Mechanics</cite> as just another knock-off of the <cite>Wired</cite> article.
However, I was wrong and, upon rereading it more closely, I have to say
it is a superb article.  Based on the author&#39;s own phone interview with
Suzanne Dodd, the article is about the Voyager project seeking a new
software developer to replace the soon-to-retire
<a href="#LarryZottarelli">Larry Zottarelli</a>, &#34;the last original Voyager
[software] engineer&#34;.  From other information I gleaned from the web, it
appears he was one of the original flight software engineers, joining the
project pre-launch in the early-to-mid 1970s.  Don&#39;t judge the article by
this isolated quote (again, the author&#39;s words, not Dodd&#39;s):
</p>

<blockquote>
<p>
    Know Cobol?  Can you breeze through Fortran?  Remember your Algol?  Those
    fancy new languages from the late 1950s?  Then you might be the person for
    the job.
</p>
<p>
    —John Wenz,
    &#34;<a href="https://www.popularmechanics.com/space/a17991/voyager-1-voyager-2-retiring-engineer/">Why
    NASA Needs a Programmer Fluent in 60-Year-Old Languages</a>&#34;,
    <cite>Popular Mechanics</cite>, October 29, 2015.
</p>
</blockquote>

<p>
Between <cite>Wired</cite> and <cite>Popular Mechanics</cite>, I&#39;m starting
to wish Suzanne Dodd had been a bit clearer in these interviews about what
the programming languages were used for.  On the other hand, in her defense,
Dodd has spent decades having to and trying to convey scientific and technical
information in a meaningful way to the public and non-tech-oriented journalists
(in general; I don&#39;t mean Wenz).
</p>

<p>
In this particular case, I expect that knowledge of Fortran <em>is</em>
needed for some of the support software, but not for actually programming
the onboard computers.  (Keep in mind that Fortran is not hieroglyphs!
Moderately experienced programmers should be able to pick it up fairly
easily.)
</p>

<p>
    Aside: Algol?  Really?!  I have long taken some small measure of pride
    in the fact that I am one of the few people in the U.S. who have actually
    programmed in Algol!  When I first caught the computer bug in 1977, I read
    one of <a href="https://en.wikipedia.org/wiki/Daniel_D._McCracken">Daniel
    McCracken</a>&#39;s Fortran books and his Algol book ... before I even took my
    first computer class and got access to a computer.  In two classes where
    the other students used Fortran, I used Algol because I wanted to try it
    out — I liked it.  This was the
    <a href="http://www.softwarepreservation.net/projects/ALGOL/algol60impl/#UNIVAC_1107">Norwegian
    University (NU) Algol</a> 60 compiler on a Univac 1100-something mainframe.
</p>

<p>
    Unrelated aside: In the <cite>Popular Mechanics</cite> article, Wenz
    contrasts the Voyagers&#39; programmability with that of other spacecraft
    with fixed-hardware operation sequencers, such as ISEE-3.  The generic,
    UNIX workstation-based, misson control system I worked on at Goddard,
    TPOCC (mentioned above), was used to replace ISEE-3&#39;s Xerox Sigma-based
    (if I remember correctly) control system in the early 1990s!  Launched
    in 1978, ISEE-3 was repurposed in 1982 as the
    <a href="https://en.wikipedia.org/wiki/International_Cometary_Explorer">International
    Cometary Explorer</a> (ICE) and underwent a complex set of maneuvers
    leading to a rendevouz with Comet Giacobini-Zinner in 1985.  (See this
    <a href="http://hyperphysics.phy-astr.gsu.edu/hbase/Solar/GZ.html">cool
    graphic</a> of the maneuvers.)  (The mission control system was called
    the ICE/IMP control center, so it was controlling two spacecraft, the
    second probably being the
    <a href="https://en.wikipedia.org/wiki/Explorer_50">Interplanetary
    Monitoring Platform</a>, IMP-8.)
</p>


<h2 id="WhatIsFortran5">3.  What is Fortran 5?</h2>

<p>
A distinct detail in every replication of this meme is &#34;Fortran 5&#34;.  I haven&#39;t
used Fortran since the 1980s, but the unknown-to-me Fortran 5 was an immediate
red flag.  In all the online discussions of this subject that I&#39;ve seen,
no one questions &#34;Fortran 5&#34;.  Even in a
<a href="https://fortran-lang.discourse.group/t/a-patch-was-sent-to-voyager-2-yesterday/6670">Fortran
Discourse thread</a> where the users are very knowledgeable about Fortran.
It can&#39;t just be me ... please!
</p>

<p>
On Wikipedia&#39;s Fortran page, Fortran 5 is called an
<a href="https://en.wikipedia.org/wiki/Fortran#Obsolete_variants">obsolete
variant</a> (i.e., non-standard version) of Fortran:
</p>

<blockquote>
    Fortran 5 was marketed by
    <a href="https://en.wikipedia.org/wiki/Data_General">Data General
    Corporation</a> from the early 1970s to the early 1980s, for the
    <a href="https://en.wikipedia.org/wiki/Data_General_Nova">Nova</a>,
    <a href="https://en.wikipedia.org/wiki/Data_General_Eclipse">Eclipse</a>,
    and
    <a href="https://en.wikipedia.org/wiki/Data_General_Eclipse_MV/8000">MV</a>
    line of computers.  It had an optimizing compiler that was quite good for
    minicomputers of its time.  The language most closely resembles FORTRAN 66.
</blockquote>

<p>
Data General&#39;s Nova
<a href="https://en.wikipedia.org/wiki/Data_General_Nova#840">840</a>
minicomputer was introduced in 1973; a contemporary DG brochure,
&#34;<a href="https://www.computerhistory.org/collections/catalog/102646255">840:
The Loaded Nova</a>&#34;, touts the Fortran 5 compiler in its feature list:
</p>

<blockquote>
    Fortran 5, an extremely thorough, multipass compiler that produces
    globally optimized code that&#39;s nearly as efficient as assembly
    language code
</blockquote>

<p>
And Data General advertised Fortran 5 with
&#34;<a href="https://fortran-lang.discourse.group/t/data-general-fortran-5-is-a-real-pig/5616">It&#39;s
a Real Pig</a>&#34;: &#34;Pigs are the Smartest Animals in the Barnyard&#34;!  The
Fortran 5 compiler was slow because it was taking the time to produce
smaller and faster executables.
(<a href="https://www.flickr.com/photos/77767209@N00/6814253048">Flickr
image</a>)
</p>

<p>
Data General&#39;s 1978
<a href="http://www.novasareforever.org/dgdocs/index.php">Fortran
5 Reference Manual</a>
(<a href="http://www.novasareforever.org/archive/public/docs/dg/sw/lang/fortran5/093-000085-04__FORTRAN_5_Reference_Manual__1978.pdf">PDF</a>)
lists 1972 as the first copyright date, incidentally the year the Voyager
project officially began.
</p>





<h2 id="FortranV">4.  Fortran V?</h2>

<p>
I&#39;ve seen no mention of Data General computers in connection with the Voyager
project in my research, so the use of Fortran 5 on the project seems highly
unlikely.
</p>

<p>
My guess is that, when speaking to <cite>Wired</cite>&#39;s Adam Mann, Suzanne
Dodd said &#34;Fortran <em>Five</em>&#34;, meaning &#34;Fortran Roman Numeral Five&#34;,
or Fortran V.  This is consistent with Fortran II being known as &#34;Fortran Two&#34;
and Fortran IV as &#34;Fortran Four&#34;.
(<a href="https://en.wikipedia.org/wiki/Fortran#FORTRAN_III">Fortran III</a>,
in case you&#39;re interested, was an unreleased, internal IBM compiler dating
to 1958.)
</p>

<p>
Fortran V, like Fortran 5, is one of Wikipedia&#39;s non-standard,
<a href="https://en.wikipedia.org/wiki/Fortran#Obsolete_variants">obsolete
variants</a> of Fortran:
</p>

<blockquote>
    <i>[In addition to Control Data Corporation,]</i> Univac also offered
    a compiler for the 1100 series known as FORTRAN V.  A spinoff of Univac
    Fortran V was Athena FORTRAN.
</blockquote>

<p>
Now things fall into place.  Remember that Suzanne Dodd spoke of &#34;control
and analysis&#34; software.  She joined the Voyager team in 1984 as a <i>sequence
engineer</i> in the lead-up to <cite>Voyager 2</cite>&#39;s January 1986 fly-by
of Uranus.  These engineers designed/developed sequences of spacecraft
commands for upload to the Voyagers ... work done on one or more Univac
1100-series mainframe computers.  From an interview:
</p>

<blockquote>
<p>
    DODD: When I first started, I started on a— I don&#39;t even remember
    the name of it, but I do recall it had an eight-inch floppy drive.
    That was our command medium, an 8-inch floppy drive.  Not a memory
    stick, not even a CD.  When we did these designs and plots that
    showed—there was a program that you could design an observation,
    like you want to make a mosaic over Uranus, and you could lay out the
    observation, and then it would tell you what the commands you need
    to do it are.  That was done on a <strong>UNIVAC</strong> computer,
    so kind of more of a mainframe refrigerator-size computer.
</p>
<details>
<summary>
    David Zierler,
    &#34;<a href="https://heritageproject.caltech.edu/interviews-updates/suzy-dodd">Suzy
    Dodd (BS &#39;84), Engineer and Deep Space Pioneer</a>&#34;
</summary>
    Caltech Heritage Project, June 9, 2023.
</details>
</blockquote>

<p>
I found more specific information about JPL&#39;s mission control computing
facilities in a pre-launch press kit
(<a href="http://planetary.s3.amazonaws.com/assets/presskit/voyager-launch.pdf">Voyager
Press Kit</a>, August 4, 1977, pp. 106-107, PDF):
</p>

<ul>
<li><p>
    <i>Mission Control and Computing Facility</i> (MCCF) - three IBM 360-75
    mainframes used for the day-to-day operations of the spacecraft,
    including command uploads and tracking.
</p></li>
<li><p>
    <i>General Purpose Computing Facility</i> (GPCF) - three Univac 1108
    mainframes used for &#34;navigation and mission sequence systems ... [and]
    prediction programs and detailed spacecraft engineering performance
    analysis&#34;.  These are the systems that Suzanne Dodd would have used.
    (Assuming JPL hadn&#39;t upgraded the 1108s to newer models in the
    intervening 7 years.)
</p></li>
<li><p>
    <i>Mission Test and Computing Facility</i> (MTCF) - &#34;three strings of
    UNIVAC and Modcomp computers to receive, record, process and display&#34;
    the engineering and science data downloaded from the spacecraft.
    (The Univac computers here were minicomputers such as the
    <a href="https://en.wikipedia.org/wiki/UNIVAC_1230">UNIVAC 1230</a>.  The
    <a href="https://en.wikipedia.org/wiki/Modcomp">Modcomp minicomputers</a>
    included the MODCOMP II and MODCOMP IV; for some reason,
    <a href="#Tomayko">Tomayko</a> [Chapter 8, Section 3, p. 265] calls them
    the ModComp 2 and 4, respectively, though everyone else on the web uses
    the Roman numerals!)
</p></li>
</ul>

<p>
Sun Kang Matsumoto is a CCS flight software engineer who joined the Voyager
program in 1985, also, like Dodd, in the ramp-up for the Uranus fly-by.  In
a 2016 paper about the Voyager Interstellar Mission (VIM), she gives some more
details about the evolution of Dodd&#39;s &#34;control and analysis&#34; software from
Univac to Unix (and thus from Fortran to C, presumably):
</p>

<blockquote>
<p>
    During the prime mission and early VIM, Voyager had been using the
    JPL-developed software programs called SEQTRAN (to generate sequences)
    and COMSIM (to simulate sequences and CCS FSW changes).  They ran on
    now-antiquated UNIVAC mainframe computers.  Shortly after the start
    of VIM <i>[in 1990]</i>, these programs were converted over to more
    modern UNIX-based SEQTRAN and High Speed Simulator (HSSIM).  They
    were rewritten to maintain the same functionality of the old SEQTRAN
    and COMSIM, and tailored for VIM.  Rewriting and testing required
    significant effort from the developers and the project personnel;
    however, the end result is much improved speed and efficiency.
</p>
<details>
<summary>
    Sun Kang Matsumoto,
    &#34;<a href="https://arc.aiaa.org/doi/pdf/10.2514/6.2016-2415">Voyager
    Interstellar Mission: Challenges of Flying a Very Old Spacecraft on
    a Very Long Mission</a>&#34; (PDF)
</summary>
    p. 4, 2016 SpaceOps Conference, Daejeon, Korea.
</details>
</blockquote>

<p>
SEQTRAN and COMSIM/HSSSIM are programs Dodd would have used as a sequence
engineer.  As a connoisseur of good program names, I can&#39;t fail to mention
Matsumoto&#39;s mention of two new programs: VAMPIRE (Voyager Alarm Monitor
Processor Including Remote Examination) and MARVEL (Monitor/Analyzer of
Real-time Voyager Engineering Link)!  Matsumoto&#39;s paper is well-worth
reading not only for the technical information, but because she provides
a valuable portrayal of how the Voyager team has managed to overcome,
by hook and by software crook, the very real problems of aging hardware
at a great distance.  And have done so despite steep technological and
budgetary challenges.
</p>

<p>
I think (or hope) it is clear by now that, in the 2013 <cite>Wired</cite>
article, Suzanne Dodd was referring to the ground system software and not
the software running on the flight computers in space.
</p>

<p>
Okay, Univac and Fortran.  But what about Fortran V?  I could only find
one instance of &#34;Fortran V&#34; being explicitly mentioned in connection with
a Voyager mission operations program.  (I do not include academic papers
whose authors used Fortran V programs to analyze the Voyagers&#39; science data
at institutions outside of JPL; e.g., universities.)
</p>

<p>
The scarcity of &#34;Fortran V&#34; <em>and</em> &#34;Voyager&#34; on the web is not
surprising.  Most programming languages maintain backwards compatibility
between versions, so, for example, a Fortran IV program usually can be
recompiled with a Fortran V compiler without error and with identical
functionality.  Consequently, programmers do not in general specify versions
when speaking about languages.  A C programmer doesn&#39;t say, &#34;I wrote this
program in C89 and later ported it to C99.&#34;  Instead, it&#39;s just an unadorned
&#34;C program&#34;.  (This is not a slight on the Dodd-Mann remark.)
</p>

<p>
Also, Univac&#39;s Fortran V compiler was available as early as
<a href="https://www.computerhistory.org/collections/catalog/102799051">1966</a>,
so it probably would have been the default Fortran compiler on Univac mainframes
throughout the 1970s.  Many Fortran users may therefore have been unaware that
the specific version they were using was Fortran V.  (The documentation that I
could find online showed that a generic <code>@FOR</code> invoked the Fortran V
compiler and <code>@FTN</code> invoked the ASCII Fortran compiler discussed in
the second aside below.)
</p>

<p>
    Aside: I anticipate eventually having to eat my pontificating words on
    programming language versions!  In the meantime ...  I couldn&#39;t find an
    online copy of Univac&#39;s Fortran V manual, but the 1970
    <cite><a href="#1108SystemDescription">UNIVAC 1108 System
    Description</a></cite> (Section 10, p. 7) had this to say: &#34;FORTRAN V,
    being an outgrowth of the earlier FORTRAN languages (in particular,
    UNIVAC 1107 FORTRAN IV and IBM FORTRAN IV as announced in IBM form
    C-28-6274-1), accepts these languages as compatible although the
    reverse is not necessarily true.&#34;
</p>

<p>
    Aside: The transition to Fortran 77 on a Univac mainframe would have
    been non-trivial.  Univac&#39;s Fortran 77 compiler, ASCII FORTRAN, largely
    accepted Fortran V source code with a few, documented, mostly
    Univac-specific exceptions.  The big problem, I think, would have been
    character sets.  Univac&#39;s 36-bit mainframes used 6-bit
    <a href="https://en.wikipedia.org/wiki/Fieldata">FIELDATA</a>
    characters stored 6 per 36-bit word.  The ASCII FORTRAN compiler used
    the incompatible 7-bit ASCII character set.  (On the Univac 1108
    computer I worked on c. 1980, ASCII characters were stored as 9-bit
    quantities, 4 per word.)  Vanilla character strings in the source code
    would just be converted to ASCII without complaint by the compiler,
    but programs that depended on specific characteristics of FIELDATA
    characters would require changes.  That includes programs that must
    read or write FIELDATA-compatible tapes.  (I have no experience with
    ASCII FORTRAN, so these are just my thoughts from perusing the
    <cite><a href="https://bitsavers.org/pdf/univac/1100/fortran/">ASCII
    FORTRAN Reference Manual</a></cite>; Appendix A addresses the differences
    between FORTRAN V and ASCII FORTRAN.)
</p>

<p>
    Unrelated aside: Circa 1980, I overheard a graduate student remark that
    the shell pipe, <code>|</code>, was Unix&#39;s gift to mankind and
    <code>@ADD</code> was Univac&#39;s gift to mankind.  He was right!
</p>

<p>
The Voyager ground-system software I found that was explicitly stated to
have been written in Fortran V is the Orbit Determinaton Program (ODP),
which was also used on other missions.  The mathematics in the following
1983 paper is way beyond me, but it establishes the ODP&#39;s host system:
</p>

<blockquote>
<p>
    To give an idea of the computational burden that is involved, consider a
    typical radiometric SRIF/SRIS solution with 67 state variables (Table I).
    This model contains only 4 process noise states (line-of-sight acceleration
    and 3 camera pointing errors); there are 3500 data points and 132 time
    propagation steps.  The problem run on a UNIVAC 1110, in double precision,
    used 275 CPU s[econds] for filtering; smoothed solutions and covariance
    computation used 265 CPU s[econds].  The entire run scenario including
    trajectory variational equation integration, observable partials
    generation, solution mapping, and generation of smoothed residuals used
    4320 CPU s[econds].
</p>
<p>
    ...
</p>
<p>
    We note in closing this factorization algorithm discussion that the SRIF
    and <i>U-D</i> algorithms that were used in this application have been
    refined and generalized, and are commercially available in the form of
    portable Fortran subroutines.
</p>
<p>
    —James K. Campbell, Stephen P. Synnott, and Gerald J. Bierman;
    &#34;<a href="http://users.cecs.anu.edu.au/~Jonghyuk.Kim/teaching/KF%20Voyager.pdf">Voyager
    Orbit Determination at Jupiter</a>&#34; (PDF), <cite>IEEE Transactions on
    Automatic Control</cite>, Vol. AC-28, No. 3, March 1983, pp. 259-261.
</p>
</blockquote>

<p>
For those not mathematically inclined, the paper is still worth skimming
just for the enumeration of some of the esoteric details of the Voyager
spacecraft that they had to account for in the calculations.  We learn
what language was used in a 2008 presentation by Lincoln J. Wood of JPL:
</p>

<blockquote>
<p>
    The mainframe computers used include the IBM 7090, IBM 7094,
    UNIVAC 1108, and UNIVAC 1100/81.  During the 1980s the ODP was
    transported to minicomputers, with the software maintained in
    both mainframe and minicomputer operating environments to
    fulfill the desires of various flight projects.  The ODP
    consisted of 300,000 lines of code as of 1979, with FORTRAN V
    being the primary language.
</p>
<p>
    —Lincoln J. Wood,
    <a href="https://descanso.jpl.nasa.gov/evolution/AAS_08-051.pdf">The
    Evolution of Deep Space Navigation: 1962-1989</a>&#34; (PDF), p. 6,
    31<sup><small>st</small></sup> Annual AAS Guidance and Control Conference,
    2008, Breckenridge, Colorado.
</p>
</blockquote>

<p>
Shortly after writing the above, I came across this entry in NASA&#39;s long-gone,
COSMIC software catalog:
</p>

<blockquote>
<p>
    <SPAN size="+1"><b>Calculating Trajectories and Orbits</b></SPAN>
</p>
<p>
    The Double Precision Trajectory Analysis Program, DPTRAJ, and the
    Orbit Determination Program, ODP, have been developed and improved
    over the years to provide the NASA Jet Propulsion Laboratory with
    a highly reliable and accurate navigation capability for their deep
    space missions like the Voyager.  DPTRAJ and ODP are each collections
    of programs that work together to provide the desired computational
    results.  DPTRAJ, ODP, and their supporting utility programs are
    capable of handling the massive amounts of data and performing the
    various numerical calculations required for solving the navigation
    problems associated with planetary fly-by and lander missions.
    They were used extensively in support of NASA&#39;s Voyager project.
</p>
<p>
...
</p>
<p>
    DPTRAJ-ODP is available in two machine versions.  The UNIVAC version
    (NPO-15586) is written in FORTRAN V, SFTRAN, and ASSEMBLER.  (A processor
    is supplied for SFTRAN, a structured FORTRAN.) DPTRAJ and ODP have been
    implemented on a UNIVAC 1100-series computer.  The VAX/VMS version
    (NPO-17201) is written in FORTRAN V, SFTRAN, PL/1 and ASSEMBLER.  It was
    developed to run on all models of DEC VAX computers under VMS and has a
    central-memory requirement of 3.4 Mb.  The UNIVAC version was last updated
    in 1980.  The VAX/VMS version was developed in 1987.
</p>
<p>
    —<cite>NASA Tech Briefs</cite>, September 1989,
    <a href="https://books.google.com/books?id=TeKWdD4nHCYC&amp;pg=PA33&amp;lpg=PA33#v=onepage&amp;q&amp;f=false">p. 33</a>.
</p>
</blockquote>

<p>
A whopping 3.4 MiB of memory required for a lousy 300,000-line program?
Software hogs like that were the reason why we couldn&#39;t have nice things
back then ...
</p>




<h2 id="SoWhatLanguage">5.  So What Language was Used?</h2>

<p>
Let&#39;s ask an actual Voyager flight software engineer what language was and
is used to program the onboard computers.  Perhaps the <i>Voyager Fault
Protection and CCS Flight Software Systems Engineer</i> who&#39;s worked on
Voyager since 1985:
</p>

<blockquote>
<p>
    Both the AACS and FDS use assembly language.  The CCS uses assembly
    language and Voyager-unique pseudo code (interpreter).  As a result,
    it is difficult to attract younger programmers to join the project.
</p>
<details>
<summary>
    Sun Kang Matsumoto,
    &#34;<a href="https://arc.aiaa.org/doi/pdf/10.2514/6.2016-2415">Voyager
    Interstellar Mission: Challenges of Flying a Very Old Spacecraft on
    a Very Long Mission</a>&#34; (PDF)
</summary>
    p. 6, 2016 SpaceOps Conference, Daejeon, Korea.
</details>
</blockquote>

<p>
In the acknowledgements at the end of the paper, Matsumoto thanks fellow
flight software engineer <a href="http://www.geonius.com/writing/other/LarryZottarelli">Larry Zottarelli</a>,
now retired, and Suzanne Dodd, among others, for reviewing the paper.
I assume Zottarelli, Dodd, or one of the others would have spoken up
if they took issue with the above paragraph.
</p>

<p>
That would be two or three assembly languages: one for the CCS CPU,
possibly a variant for AACS&#39;s modified CCS CPU, and definitely another
for the completely different FDS CPU.
</p>

<p>
The phrase &#34;pseudo code (interpreter)&#34; makes me think of an embedded
scripting language, but Matsumoto is probably referring to executing
uplinked spacecraft commands and sequences.  The CCS also must process
internally generated <i>power codes</i> received from the AACS computer:
</p>

<blockquote>
<p>
    A &#34;power code&#34; is a 6 bit message sent to the CCS computer, which may be
    only informational or may cause a power command to switch power to an AACS
    component.  Such power switching commands are usually the means by which
    redundant elements are exchanged.  These power codes are an important part
    of the fault protection logic, allowing the CCS computer to issue commands
    in response to a fault condition.  These commands may be a simple power
    command (A gyro on) or a command sequence which will turn the spacecraft in
    a pattern designed to re-oriented the spacecraft towards the sun from an
    entirely random attitude.  Some serious faults result in an OMEN power
    code, which causes CCS to save the next three power codes (normally lost)
    for later analysis.
</p>
<details>
<summary>
    <cite>Assessment of Autonomous Options for the DSCS III Satellite
    System</cite>
</summary>
    Prepared for the U.S. Air Force by JPL personnel (Donna L. S. Pivirotto
    and Michael Marcucci?),
    &#34;<a href="https://apps.dtic.mil/sti/tr/pdf/ADA106064.pdf">Volume III:
    Options for Increasing the Autonomy of the DSCS III Satellite</a>&#34; (PDF),
    p. 179, Aug. 6, 1981.
</details>
</blockquote>

<p>
In her paper, Matsumoto discusses a problem with the &#34;power decoder relay
matrix&#34;:
</p>

<blockquote>
<p>
    The power decoder relay matrix problem that first manifested in 1998 makes
    commanding of the spacecraft extremely difficult.  Basically, the faulty
    decoder may cause an issuance of extraneous power commands in addition to
    the intended command.
</p>
<details>
<summary>
    Sun Kang Matsumoto,
    &#34;<a href="https://arc.aiaa.org/doi/pdf/10.2514/6.2016-2415">Voyager
    Interstellar Mission: Challenges of Flying a Very Old Spacecraft on
    a Very Long Mission</a>&#34; (PDF)
</summary>
    p. 8, 2016 SpaceOps Conference, Daejeon, Korea.
</details>
</blockquote>

<p>
I wonder if this is the interface used to convey the power codes from the AACS
to the CCS.  Later, she describes a patch for this error made to
<code>AACSIN</code>, the CCS routine that she notes receives and processes
power codes, but the specific description of the patch again uses the term,
&#34;power commands&#34;.
</p>




<h2>6.  Why Assembly?</h2>

<p>
Since so many commenters in discussion forums had no problem with &#34;Fortran 5&#34;,
it might be valuable to examine some possible reasons why the flight software
was written in assembly language.
</p>

<h4 id="TheCPUs">The CPUs</h4>

<p>
There is not much information available specifically about the Voyager
<u>CCS computer</u>, borrowed from the Viking Orbiter.  Fortunately,
Tomayko <em>does</em> provide details about the Viking CCS:
</p>

<blockquote>
<p>
    In general, the design of the processor was exceedingly simple, yet fairly
    powerful, as indicated by the use of direct addressing, a minimal set of
    registers, and a reasonably rich set of 64 instructions.  The key is that
    the design placed relatively light demands on spacecraft resources while
    replacing both the programmable sequencer and the command decoder used
    in the Mariners.  The fact that the processor was later adopted by the
    Voyager project as its Command Computer and modified for use as the
    attitude control computer is not only a statement of JPL&#39;s frugality
    but also a testament to the versatility of the design.
    <i>(p. 157)</i>
</p>
<p>
    ...
</p>
<p>
    [On the Viking Orbiter, the] Command Computer&#39;s central processor contained
    the registers, data path control and instruction interpreter.  The machine
    was serial in operation, thus reducing complexity, weight, and power
    requirements.  It had 18-bit words and used the least significant 6 bits
    for operation codes and the most significant 12 for addresses, as numbered
    from right to left.  This permitted 64 instructions and 4K of direct
    addressing, both of which were fully utilized.  Data were stored in signed
    two&#39;s complement form, yielding an integer range from -131,072 to +131,071.
    Average instruction cycle time came to 88 microseconds.  Thirteen registers
    were in the Command Computer, mostly obvious types such as an 18-bit
    accumulator, 12-bit program counter, 12-bit link register that pointed to
    the next address to be read, and a 4-bit condition code register that
    stored the overflow, minus, odd parity, and nonzero flags.
    <i>(Box 5-3, p. 159)</i>
</p>
<details>
<summary>
    James E. Tomayko,
    <cite>Computers in Spaceflight: The NASA Experience</cite>, 1988
</summary>
    <a href="https://web.archive.org/web/20230506223908/https://history.nasa.gov/computers/Ch5-6.html">Chapter
    Five, Section 6</a>.
</details>
</blockquote>

<p>
Note the 12-bit addresses, giving an addressing range of 0..4095.  And note,
in the following, that the Viking CCS flight software engineers masked most
interrupts in routines, thus simplifying code (which reduced memory usage)
and increasing performance:
</p>

<blockquote>
<p>
    Viking Orbiter software had to be written in an assembler, which
    fortunately had relocatable addresses, simplifying the maintenance task.
    The 64 instructions were mostly common to other computers, but there was no
    multiply or divide.  There were two sets of loads, stores, increments, and
    subroutine calls: one used during independent operation and one aimed at
    dual operation, so that the two memories could be kept equivalent.  Even
    though many interrupts were available, most routines as coded had all but
    the internal error and counting interrupts disabled.  Many routines were
    free to run out without being interrupted, in contrast to the highly
    interrupted Apollo and shuttle software.  Programmers avoided the memory
    and processing time overhead required to preserve the current accumulator
    and register contents during an interrupt.
</p>
<details>
<summary>
    James E. Tomayko,
    <cite>Computers in Spaceflight: The NASA Experience</cite>, 1988
</summary>
    <a href="https://web.archive.org/web/20230506223908/https://history.nasa.gov/computers/Ch5-6.html">Chapter
    Five, Section 6</a>, Box 5-4, p. 162.
</details>
</blockquote>

<p>
The Voyager <u>AACS computer</u> uses a modified CCS CPU (e.g., with the added
index register), so most of the CCS details above apply as well to the AACS.
(In Box 6-1, p. 179, Tomayko uses &#34;HYPACE&#34; to refer to the AACS despite
pointing out two paragraphs earlier that the term is a misnomer.)
</p>

<p>
The <u>FDS CPU</u> was developed especially to meet the high-rate data handling
requirements of the Voyager spacecraft.  Designed by Jack L. Wooddell,
the CPU, in the form of a breadboard prototype, evolved in a collaboration
between Wooddell and flight software engineer Richard J. Rice.  For some
reason, I picture Wooddell seated in front of a really large breadboard
with a soldering iron in one hand and a wirewrap tool in the other.  Rice
is standing beside him with an open laptop in the crook of his left arm,
his right hand is typing on the keyboard, and the changing flight software
is downloaded via wi-fi to the breadboard computer for testing.  Wrong era,
I realize, and Rice may well have been left-handed!
</p>

<blockquote>
<p>
    Voyager&#39;s data computer is different from most small general-purpose
    computers in several ways.  Its special registers are kept in memory,
    permitting a large number (128) of them.  Wooddell also wrote more powerful
    shift and rotate instructions because of data-handling requirements.
    Despite its I/O rate, the arithmetic rate is quite slow, mostly due to
    byte-serial operation.  This meant 4-bit bytes are operated on in sequence.
    Since the word size of the machine is 16 bits, it takes six cycles to do an
    add, including housekeeping cycles.  If all the arithmetic, logic and
    shifting were not done in the general registers, the machine would have
    been even slower.  Reflecting its role, in addition to the usual ADD, SUB,
    AND, OR, and XOR instructions found on most computers, the data computer
    has many incrementing, decrementing, and branching instructions among the
    36 defined for the flight version of the machine.
</p>
<p>
    Overall, the Flight Data System requires 14 watts of power and weighs 16.3
    kilograms.  Its computer needs just one third of a watt and 10 volts, less
    than the power required for a temperature sensor!  At first the estimated
    throughput required was 20,000 16-bit words per second.  By flight time,
    the instruction execution rate was 80,000 per second, with data rates of
    115,000 bits per second, much higher than previous Flight Data Systems.
</p>
<details>
<summary>
    James E. Tomayko,
    <cite>Computers in Spaceflight: The NASA Experience</cite>, 1988
</summary>
    <a href="https://web.archive.org/web/20231123211500/https://history.nasa.gov/computers/Ch6-2.html">Chapter
    Six, Section 2</a>, Box 6-2, p. 184.
</details>
</blockquote>

<p>
Note that Tomayko uses the term <i>byte-serial</i> for non-8-bit &#34;bytes&#34;, in
this case, when describing how the FDS CPU&#39;s arithmetic logic unit processes
16-bit operands 4 bits at a time.  The last two sentences about throughput,
while not wrong, seem to ask the reader to compare apples and oranges.
</p>

<p>
The breadboard prototype began with the same 4K-by-18 plated wire memory
as the CCS computer.  I don&#39;t know if this means the CPU was originally
designed as a 18-bit processor, but, in any case, it ended up as a 16-bit
processor with 8K-by-16 CMOS memory.  From Tomayko&#39;s description on p. 183
of Chapter 6, Section 2, my impression is that the CPU used the same
12-bit addresses as the CCS, but two, independent-of-each-other address
lines were added that effectively provided a 13-bit (8K) address range
for instruction fetches and a 13-bit (8K) address range for data accesses.
I don&#39;t know if these extra address bits were incorporated into the CPU&#39;s
instruction set or if they had to be explicitly set/reset in a separate
operation by the programmer.
</p>

<p>
Don&#39;t be dismayed by the CCS and AACS CPUs&#39; lack of multiply and divide
instructions and the FDS CPU&#39;s slow arithmetic operations.  Spacecraft
computers don&#39;t crunch numbers.  (Out of necessity, in my ground-software
experience up to the mid-2000s.  More modern flight computers with more
powerful processors and abundant RAM may have changed this dynamic.)
Sensors and detectors return unit-less raw counts.  If these readings
are needed in real-time for autonomous spacecraft operations, it is
faster and more memory-efficient for command sequences or flight software
to work with these counts directly.  Otherwise, the ground system can apply
its sizeable CPU, RAM, and disk resources to perform what are called
<i>engineering unit conversions</i>; e.g., the conversion of a hypothetical
temperature sensor&#39;s raw 0-255 count to degrees Celsius.  The FDS computer
is focused on assembling and formatting science and engineering data for
transmission back to Earth, so fast bit and byte manipulation is more
important than fast arithmetic operations.
</p>


<h4 id="MemoryConstraints">Memory Constraints</h4>

<p>
Wise words:
</p>

<blockquote>
<p>
    The Voyager flight software design was very heavily impacted by the
    limited memory space.  Extensive effort and ingenuity was required
    to perform the necessary functions in the available space.  The
    flight software was written in assembly code.
</p>
<details>
<summary>
    <cite>Assessment of Autonomous Options for the DSCS III Satellite
    System</cite>
</summary>
    Prepared for the U.S. Air Force by JPL personnel (Donna L. S. Pivirotto
    and Michael Marcucci?),
    &#34;<a href="https://apps.dtic.mil/sti/tr/pdf/ADA106064.pdf">Volume III:
    Options for Increasing the Autonomy of the DSCS III Satellite</a>&#34; (PDF),
    p. 179, Aug. 6, 1981.
</details>
</blockquote>

<p>
Words that annoy me:
</p>

<blockquote>
<p>
    The computers aboard the Voyager probes each have 69.63 kilobytes of
    memory, total.
</p>
<p>
    —Adam Mann,
    &#34;<a href="https://www.wired.com/2013/09/vintage-voyager-probes/">Interstellar
    8-Track: How Voyager&#39;s Vintage Tech Keeps Running</a>&#34;, <cite>Wired</cite>,
    September 2013.
</p>
</blockquote>

<p>
An otherwise good article, but ...  First, I&#39;m old-school, so the use of
&#34;kilobytes&#34; in the modern 1,000 sense annoys me.  Second, the pointless
(and truncated) precision of 69.63 is annoying.  Third, the sentence is
wrong because of the confusing wording.  The computers don&#39;t <em>each</em>
have that much memory.  The sum total of memory for all 3 computers and
their 3 backups is 69,632 bytes:
</p>

<pre>     CCS - 4,096 18-bit words =  73,728 bits =  9,216 bytes
    AACS - 4,096 18-bit words =  73,728 bits =  9,216 bytes
     FDS - 8,192 16-bit words = 131,072 bits = 16,384 bytes
                                               ------
                                               34,816 bytes
                                              x     2 for the backup computers
                                               ------
                   Total for all 6 computers:  69,632 bytes
</pre>

<p>
When examining the memory limitations from a programming standpoint, expressing
the memory size in bytes can be misleading.  The CCS computer, for example,
has 9,216 bytes of RAM.  Readers may mistakenly infer from that figure
that there are 9,216 addressable code/data units when, in fact, there are
only 4,096 addressable code/data units, a significantly lower number that
more accurately reflects the limits in which the programmers had to work.
</p>

<p>
For example, if you want a variable that counts from 1 to 10, you can&#39;t use a
memory-efficient single byte and must instead use 2¼ bytes (18 bits).
Yes, you can pack multiple data items into an 18-bit word and I&#39;m sure the
Voyager assembly language programmers did just this, but doing so incurs
added memory/performance costs for packing and unpacking the individual data
items.  And, yes, clever coding can reduce those costs and or even avoid the
need for packing/unpacking altogether.  Which makes a strong case for using
assembly language rather than a higher-level language like Fortran 5!
</p>

<p>
A given computer&#39;s memory holds the flight software code (CPU instructions),
the software&#39;s dynamic variables, and uplinked data (tables, command sequences,
and such).  Regarding the AACS, Dr. Tomayko wrote (emphasis added by me):
</p>

<blockquote>
<p>
    The programmers must have done an outstanding job, considering the slow
    processor and limited memory.  <em>At launch, only two words of free space
    remained in the 4K of plated wire.</em>  Tight memory is now a problem
    because the scan platform actuators on Voyager 2 are nearly worn out,
    and software has to compensate for this during Uranus and Neptune
    encounter periods.
</p>
<details>
<summary>
    James E. Tomayko,
    <cite>Computers in Spaceflight: The NASA Experience</cite>, 1988
</summary>
    <a href="https://web.archive.org/web/20231123211500/https://history.nasa.gov/computers/Ch6-2.html">Chapter
    Six, Section 2</a>, p. 178.
</details>
</blockquote>

<p>
(Interestingly, Tomayko&#39;s 1988 report was published after the Uranus encounter
and before the Neptune encounter!  He was writing not a history of the distant
past, but an account of a still very much active and prominent project.)
</p>

<p>
A big chunk of <cite>Voyager 2</cite>&#39;s CCS memory is consumed by the
<i>Backup Memory Load</i> (BML), identified by name in Matsumoto&#39;s paper
and described by Tomayko as follows:
</p>

<blockquote>
<p>
    As pioneered on Mariner X, a disaster backup sequence was stored in the
    Voyager 2 CCS memory for the Uranus encounter, and later for the Neptune
    encounter.  Required because of the loss of redundancy after the primary
    radio receiver developed an internal short, the backup sequence will
    execute minimum experiment sequences and transmit data to earth; it
    occupies 20% of the 4K memory.
</p>
<details>
<summary>
    James E. Tomayko,
    <cite>Computers in Spaceflight: The NASA Experience</cite>, 1988
</summary>
    <a href="https://web.archive.org/web/20231123211500/https://history.nasa.gov/computers/Ch6-2.html">Chapter
    Six, Section 2</a>, p. 176.
</details>
</blockquote>

<p>
In other words, if <cite>Voyager 2</cite> loses the ability to receive
commands from the ground, the BML ensures that, on its own, the spacecraft
will continue to perform science operations and to downlink science and
engineering data.
</p>

<p>
Fault protection is very important in a remote unmanned spacecraft and is,
incidentally, one of Sun Kang Matsumoto&#39;s areas of expertise.  In the 1981
<cite>Assessment of Autonomous Options for the DSCS III Satellite
System</cite>, <a href="#Autonomous">Volume III</a>, we learn that 8 CCS
fault routines take up 26.5% of the CCS memory (Table B-3, p. 176) and
9-plus AACS fault routines take up 19.4% of the AACS memory (Table B-4,
p. 180).  This suggests that <u>nearly half</u> of <cite>Voyager 2</cite>&#39;s
CCS memory was devoted to the <u>fault routines</u> (26.5%) and the
<u>BML</u> (20%), <u>leaving only</u> a little more than half of the
memory, <u>about 2,200 words</u>, for other CCS functions such as
command sequence storage and processing:
</p>

<div>
<pre><span>  Fault S/W  </span><span>   BML   </span><span>     Everything Else!     </span>
</pre>
</div>

<p>
(That&#39;s a graph, not a diagram of the memory layout.)  This seems hard to
believe and the sizes could well have changed up or down over the decades
since this 1981 study and Tomayko&#39;s 1988 report.
</p>

<p>
A couple of weeks after I wrote the above, I came across a 1987 paper by the
Voyager Flight Operations Manager, published between the Uranus and Neptune
encounters.  This paper seems to indicate that, on <cite>Voyager 2</cite>,
there was even less memory available for sequence storage and processing,
about 1,250 words:
</p>

<blockquote>
<p>
    Out of the total CCS memory, the fault recovery routines, other fixed
    routines, and flight reserve leave only about 2,500 words available for
    sequencing of preplanned activities.  These activities involve spacecraft
    maneuvers, scan platform movements, data mode changes, data recording or
    playback, scientific observations, etc.
</p>
<p>
    ... <i>skip one paragraph</i> ...
</p>
<p>
    Since the failure of one of the Voyager 2 command receivers in 1978, that
    spacecraft has had a back-up sequence stored in its CCS that occupies
    approximately one-half of the available sequencing space.  In the event of
    a failure of the remaining receiver, this back-up sequence will execute
    until late in 1989, allowing for limited mission return including
    data-taking during the Neptune encounter.
</p>
<details>
<summary>
    Terrence P. Adamski,
    &#34;<a href="https://arc.aiaa.org/doi/10.2514/6.1987-501">Command and Control
    of the Voyager Spacecraft</a>&#34; (abstract)
</summary>
    p. 3, American Institute of Aeronautics and Astronautics (AIAA),
    25th AIAA Aerospace Sciences Meeting, March 24-26, 1987, Reno, Nevada.
</details>
</blockquote>

<p>
(And a couple of more weeks later, I found the exact number: 1,239 words
per CCS computer!  See <a href="#Morris">Morris</a>&#39;s 1986 paper, p. 173.)
</p>

<p>
The &#34;fixed routines&#34; would probably have included the core software such
as the executive discussed below, interrupt handlers, communications with
the AACS and FDS computers, ground communications, etc.  At the beginning
of the Voyager Interstellar Mission in 1990, a BML was installed on
<cite>Voyager 1</cite> too (see Matsumoto&#39;s paper, p. 3).  It and probably
an updated <cite>Voyager 2</cite> BML would have been tailored to the
post-planetary-encounter, interstellar mission.  (I suspect that
<cite>Voyager 2</cite>&#39;s original BML, intended for the Uranus and Neptune
encounters, could have been reduced in scope and size afterwards.)
</p>


<h4 id="PerformanceConstraints">Performance Constraints</h4>

<p>
I couldn&#39;t find much detailed information about the actual flight software.
Both Tomayko and the <cite>Autonomous</cite> study describe the
<a href="https://en.wikipedia.org/wiki/Cyclic_executive">cyclic executive</a>
used on the AACS computer to schedule routines (functions) in regularly-spaced
time slots:
</p>

<blockquote>
<p>
    A flow chart of the AACS flight software is shown in Figure 4-14 in
    the main body of this report.  Normal program execution occurs in
    three different rate groups having periods of 10 ms, 60 ms, and 240 ms.
    The fourth rate group shown (20 ms) was used only for the Propulsion
    Module operation.  Functions requiring high rates such as thruster
    activation and scan platform stepper motor operations are performed
    by the 10 ms logic.  The bulk of the attitude control functions, such
    as attitude sensor &#39;reads&#39; and control law algorithms, are accomplished
    by the 60 ms logic.  The 240 ms logic performs a variety of tasks that
    do not require the higher execution rates, such as decoding CCS commands
    from the input buffer, fault monitor and correction, and &#34;power code&#34;
    processing.
</p>
<details>
<summary>
    <cite>Assessment of Autonomous Options for the DSCS III Satellite
    System</cite>
</summary>
    Prepared for the U.S. Air Force by JPL personnel (Donna L. S. Pivirotto
    and Michael Marcucci?),
    &#34;<a href="https://apps.dtic.mil/sti/tr/pdf/ADA106064.pdf">Volume III:
    Options for Increasing the Autonomy of the DSCS III Satellite</a>&#34; (PDF),
    p. 179, Aug. 6, 1981.
</details>
</blockquote>

<p>
In a more visual form, here are the 10-ms time slots and the 60- and 240-ms
intervals:
</p>

<pre>     .-- 10 ms
     v
    |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |
    |   &lt;- 60 ms -&gt;   |                 |                 |                 |
    |                              &lt;- 240 ms -&gt;                             |
</pre>

<p>
Difficult-to-update, hand-drawn flowcharts are a thankfully retired relic
of the 1970s software industry and I provide here a pseudocode version of
the scheduling algorithm on the AACS.  It is not apparent from the
<cite>Autonomous</cite> study&#39;s flowchart, but I do make an assumption
that the 60-ms routines, for example, are not all run in a single 10-ms
time slot every 60 ms.  Instead, the per-slot load is lessened by
distributing them over the six 10-ms time slots in the interval.  So,
given 60-ms routines <code>ABC</code> and <code>DEF</code>, then
<code>ABC</code> might be run in the 10-ms slots 2, 8, 14, 20, 26, ... and
<code>DEF</code> might be run in slots 5, 11, 17, 23, 29, etc.
</p>

<pre>    Offset60 = 0
    Offset240 = 0
    EVERY 10 ms DO {
        Run all of the 10-ms routines.
        Run any 60-ms routines scheduled for time slot Offset60.
        Increment Offset60.  If 6 then reset Offset60 to 0.
        Run any 240-ms routines scheduled for time slot Offset240.
        Increment Offset240.  If 24 then reset Offset240 to 0.
    }
</pre>

<p>
Within a time slot, all the scheduled routines must be sure to finish before
the start of the next time slot.  The programmers must quantify beforehand
the worst-case execution times for each of the routines and ensure that the
sum does not exceed 10 ms.  The programmers probably are counting instruction
cycles for the assembly statements in each routine.  (I use the present tense
because this would have been done for the routines prior to the 1977 launch
and still needs to be done for routines updated/uploaded nearly 50 years
later.)  If the time exceeds 10 ms and offloading some 60-ms and 240-ms
routines to other time slots is not a possibility, the programmers must
speed up the routines.  This is most easily done working directly with the
assembly language.  It would be awkward to do this in a higher-level language
because the quanitification still has to be done at the assembly language
level.
</p>

<p>
Both Tomayko and <cite>Autonomous</cite> also mention the FDS computer&#39;s
<i>P periods</i>, with Tomayko providing a little more detail.  With 2.5-ms
time slots, the execution constraints were even more stringent than those
on the AACS.  There is no indication of whether or not the FDS had multiple
levels of intervals like the AACS.  And apparently the CCS software was also
built on a cyclic executive?
</p>

<blockquote>
<p>
    Like the command computer, the data computer has a simple executive.  Time
    is divided into twenty-four 2.5-millisecond intervals, called &#34;P periods.&#34;
    Each 24 P periods represent one imaging system scan line.  Eight hundred of
    those lines is a frame.  At the beginning of each P period, the software
    automatically returns to memory location 0000, where it executes a routine
    that determines what functions to perform during that P period.  Care is
    taken that the software completes all pending processes in the
    2.5-millisecond period, a job made easier by the standardization of
    execution times once the direct memory access cycle was added.
</p>
<details>
<summary>
    James E. Tomayko,
    <cite>Computers in Spaceflight: The NASA Experience</cite>, 1988
</summary>
    <a href="https://web.archive.org/web/20231123211500/https://history.nasa.gov/computers/Ch6-2.html">Chapter
    Six, Section 2</a>, Box 6-3, p. 185.
</details>
</blockquote>

<p>
Unrelated to performance concerns, the use of an executive proves the truth
in Richard Rice&#39;s wry quip:
</p>

<blockquote>
<p>
    Rice characterized the unique nature of the data computer software
    this way: &#34;We didn&#39;t worry about top-down or structured; we just
    defined functions.&#34;
</p>
<details>
<summary>
    James E. Tomayko,
    <cite>Computers in Spaceflight: The NASA Experience</cite>, 1988
</summary>
    <a href="https://web.archive.org/web/20231123211500/https://history.nasa.gov/computers/Ch6-2.html">Chapter
    Six, Section 2</a>, pp. 183-184.
</details>
</blockquote>

<p>
The executive provided the top-level structure, so the programmers really
<em>were</em> just writing functions to be called when their time slot came up!
</p>

<div>
    <p><img alt="Voyager Team Celebrating" src="http://www.geonius.com/writing/other/voyager-1-celebrate.jpg"/>
    </p>
    <p><em>The Voyager team celebrates the successful
        resumption of intelligible data transmissions from <cite>Voyager
        1</cite>!  In November 2023, the spacecraft began sending jumbled
        data.  The problem was eventually traced to a failed section of
        FDS memory.  The flight software team relocated the code in the
        failed section elsewhere and were relieved and excited when
        <cite>Voyager 1</cite> resumed sending good data on April 20, 2024.
        I can identify three people from the
        <cite><a href="#ItsQuieterInTheTwilight">It&#39;s Quieter in the
        Twilight</a></cite> movie: Todd Barber, Suzanne Dodd, and Sun
        Matsumoto.  The man with both arms upraised might be Enrique
        Medina and the woman to his left, at the table, might be Lu
        Yang — I&#39;m not sure.  (Source:
        &#34;<a href="https://www.jpl.nasa.gov/news/nasas-voyager-1-resumes-sending-engineering-updates-to-earth">NASA&#39;s
        Voyager 1 Resumes Sending Engineering Updates to Earth</a>&#34;,
        April 2024, JPL.)</em>
    </p>
</div>

<hr id="SimulatorsOtherRandomThoughts"/>



<h2>Simulators &amp; Other Random Thoughts</h2>

<blockquote id="MikePellatt">
<p>
    I&#39;m sure you&#39;d just love the reputation of being the guy who lost 2 deep
    space probes that had gone the furthest of any manmade object and had been
    doing just fine for decades.  Through your bright idea for how Things Could
    Be Done Better.
</p>
<p>
    —Mike Pellatt,
    <a href="https://forums.theregister.com/forum/all/2015/10/31/brush_up_on_your_fortran/#c_2683386">comment</a>
    on <cite>The Register</cite> forum, October 31, 2015, for
    &#34;<a href="https://www.theregister.com/2015/10/31/brush_up_on_your_fortran/">Think
    Fortran, assembly language programming is boring and useless?  Tell that
    to the NASA Voyager team</a>&#34; (based on John Wenz&#39;s <cite>Popular
    Mechanics</cite> article).
</p>
</blockquote>

<p>
In the comments on an <cite>Ars Technica</cite> article,
<a href="https://arstechnica.com/space/2024/02/humanitys-most-distant-space-probe-jeopardized-by-computer-glitch/">Humanity&#39;s
Most Distant Space Probe Jeopardized by Computer Glitch</a>&#34;
(February 6, 2024), there was an interesting subthread about the lack of
simulators for the flight computers.  (Actually just for the AACS and FDS
computers?  Matsumoto mentioned the COMSIM/HSSIM simulator for command
&#34;sequences and CCS FSW changes&#34;.)  I wanted to address some of the issues
raised in this section, but then I decided to get into some of the more
general issues; hence the &#34;&amp; Other Random Thoughts&#34; in the title.
</p>

<p>
In every online discussion of anything touching on the Voyager computers,
there are always a number of questions such as &#34;Why didn&#39;t they do
<i>this</i>?&#34; and &#34;Why don&#39;t they do <i>that</i>?&#34;  The answer to the
first question is more than likely, &#34;Well, you had to have been there.&#34;
The second question is ably answered by Mike Pellatt above.
</p>

<hr id="ShoestringSpaceExploration"/>

<h3>Shoestring Space Exploration</h3>

<p>
The Voyager spacecraft had more than fulfilled their nominal missions after
<cite>Voyager 2</cite> flew by Neptune, so they&#39;ve been living on borrowed
time ever since.  However, NASA had long been keeping a close eye on budget
concerns after being raked over the coals by Congress in 1974 for Viking
cost overruns.  (See <cite><a href="#VikingProjectHearings">Viking project
hearings</a></cite> in the bibliography.)
</p>

<p>
Suzanne Dodd spoke of a <i>bathtub</i> effect in personnel levels between
the Saturn and Uranus flybys:
</p>

<blockquote>
<p>
    DODD: Now, Voyager went through Jupiter and Saturn, and then it had a
    bathtub, because it had five years to get out to Uranus.  So a lot of
    people left.  Because Jupiter and Saturn were like 18— maybe two
    years apart, 18 months to two years apart in encounters.  Then there
    was this lull, so they had to cut— a lot of people left, and/or
    they just needed to trim staffing.  A bathtub in staffing, because
    there was such a long duration.
</p>
<details>
<summary>
    David Zierler,
    &#34;<a href="https://heritageproject.caltech.edu/interviews-updates/suzy-dodd">Suzy
    Dodd (BS &#39;84), Engineer and Deep Space Pioneer</a>&#34;
</summary>
    Caltech Heritage Project, June 9, 2023.
</details>
</blockquote>

<p>
(<a href="http://www.geonius.com/writing/other/McLaughlinAndWolff">McLaughlin and Wolff</a> also refer to the
bathtub effect and describe how JPL tried to reduce the effect between
Uranus and Neptune by spreading the expected work out more evenly in the
interval.)
</p>

<p>
The &#34;bathtub&#34; after Neptune would be endless and the Voyager team was very
small in the succeeding decades.  For those of us interested in the software
side of things, keep in mind that programming would only have been one of
the areas of engineering expertise needed on the team.  And the 10-12
full-time employee equivalency means that some, if not many, of the team
were and are working only part-time on Voyager.  As knowledgeable people
retired, the remaining members by necessity assumed multiple roles.
</p>

<p>
The Voyager program was almost cut off completely in the 2000s:
</p>

<blockquote>
<p>
    NASA officials said the possibility of cutting Voyager and several other
    long-running missions in the Earth-Sun Exploration Division arose in
    February, when the Bush administration proposed slashing the division&#39;s
    2006 budget by nearly one-third — from $75 million to $53
    million.
</p>
<p>
    —Guy Gugliotta,
    &#34;<a href="https://www.washingtonpost.com/archive/politics/2005/04/04/historic-voyager-mission-may-lose-its-funding/ef2451c9-8b38-49ca-a0be-745b78cb06e2/">Historic
    Voyager Mission May Lose Its Funding</a>&#34;,
    <cite>The Washington Post</cite>, April 4, 2005.
</p>
</blockquote>

<p>
(Voyager&#39;s share of the $75 million was $4.2 million.)  Thankfully, this
didn&#39;t happen, but program leaders like Dodd (who returned to Voyager in
2010) have probably had to fight for funding every year.
</p>

<p>
Between the lack of personnel, the part-time nature of the work, and the
sword-of-Damocles-like budget cut-off hanging over the project, the time
and money resources available for writing new simulators, rewriting the
flight software in C++ or Python, etc. were scarce.  And both would run
up against an insurmountable obstacle: &#34;If it ain&#39;t broke, don&#39;t fix it!&#34;
We&#39;ve got a very tenuous connection with two spacecraft, one 15 billion
miles away and the other 12 billion, and you want to do what?!  Paging
<a href="#MikePellatt">Mike Pellatt</a> ...
</p>

<p>
    • • •
</p>

<p>
Finally, a few more words about spacecraft operations.  The constraints
on flight operations range from the mundane to out-of-this-world.  Examples
of the mundane are staffing levels.  <a href="#Adamski">Adamski</a> (p. 4)
notes that during the long, hopefully uneventful, <i>cruise</i> intervals
between planets, operations were limited to daytime hours since the control
center was not manned around the clock; this was a contraint taken into
consideration in the design of a sequence.
</p>

<p>
Skipping in-this-world concerns such as earthquakes (see
<a href="#Kohlhase">Kohlhase</a>, p. 120) and going straight to
out-of-this-world constraints, everyone seems to know that the Voyager
spacecraft are very far away and that it takes about 40 hours to send a
command and receive a response back.  (This is called the <i>Round Trip
Light Time</i>, or RTLT.)  However, I sometimes wonder if people also
understand that the Voyager team is not in constant contact with the two
spacecraft.  You can&#39;t just make a change to the flight software, recompile
it, and uplink it to the spacecraft.
</p>

<p>
    I use 40 hours as a nice round number for RTLT.  More specific values
    in 2024 are about 45 hours for <cite>Voyager 1</cite> and about 38 hours
    for <cite>Voyager 2</cite>.  If you need even more accuracy, the real-time
    <a href="https://voyager.jpl.nasa.gov/mission/status/">Voyager Mission
    Status</a> page has the hours, minutes, and seconds of the one-way light
    times.  As I noted in the &#34;<a href="#Distance">Introduction</a>&#34;, the
    distance of each spacecraft goes up and down depending on whether the
    Earth in its orbit is falling behind or catching up with the spacecraft.
    As the distance changes, so does the transmission time.
</p>

<p>
Communications with the Voyager spacecraft are handled by NASA&#39;s Deep Space
Network (DSN), which consists of three tracking stations spaced about
120° of longitude apart in
<a href="https://www.gdscc.nasa.gov/">Goldstone</a> (California),
<a href="https://www.mdscc.nasa.gov/index.php/en/start/">Madrid</a> (Spain),
and <a href="https://www.cdscc.nasa.gov/">Canberra</a> (Australia).  Each
station has a 70-meter dish antenna, multiple 34-meter antennas, and others.
According to <a href="#Matsumoto">Matsumoto</a>&#39;s predictions (p. 6), by
now (2024), a 70-m antenna is required to send commands to either Voyager
spacecraft and a 70-m antenna or two 34-m antennas are required to receive
engineering and science data.
</p>

<p>
    Aside: A 70-meter dish antenna is 230 feet in diameter, ¾ of
    the length of an American football field, as you can see in this fanciful
    picture of the Goldstone 70-m antenna placed in Pasadena&#39;s Rose Bowl
    stadium!  (Pasadena is also home to JPL.  Source:
    <cite><a href="#Kohlhase">The Voyager Neptune Travel Guide</a></cite>,
    p. 28.)
</p>

<p><img src="http://www.geonius.com/writing/other/voyager-rose-bowl.jpg" alt="70-m antenna in Rose Bowl!"/>
</p>

<p>
The Voyagers are not the only spacecraft using the DSN, so the Voyager
team must request and compete for transmitting and receiving time on
the DSN.  (At <a href="https://eyes.nasa.gov/dsn/dsn.html">DSN Now</a>,
you can see in real-time which antennas are talking to which spacecraft.)
When scheduling time, the team must take into account the 40-hour round
trip light time.  Depending on a variety of factors, it is possible that
they might have to settle for time slots more than 40 hours apart, in which
case the team must ensure they can still verify the results of an operation.
Matsumoto gives an example:
</p>

<blockquote>
<p>
    Command Loss (CMDLOS) timer, the timer that triggers CMDLOS FPA entry when
    it reaches to the pre-set value, is set for six weeks.  It is still
    desirable to send the command to reset the timer every week but it is a
    best effort approach based on the DSN resources, usually without downlink
    coverage for command receipt verification.  (The receipt of a command is
    verified indirectly by the CCS hourly status data when the telemetry is
    available.)
</p>
<details>
<summary>
    Sun Kang Matsumoto,
    &#34;<a href="https://arc.aiaa.org/doi/pdf/10.2514/6.2016-2415">Voyager
    Interstellar Mission: Challenges of Flying a Very Old Spacecraft on
    a Very Long Mission</a>&#34; (PDF)
</summary>
    p. 5, 2016 SpaceOps Conference, Daejeon, Korea.
</details>
</blockquote>

<p>
After passing Saturn, <cite>Voyager 1</cite> angled north of the ecliptic
(planetary) plane as it headed out into space.  After passing Neptune,
<cite>Voyager 2</cite> angled <em>south</em>.  Consequently, communications
with <cite>Voyager 2</cite> are only possible via the Canberra DSN station.
This became a problem in 2020 when Canberra&#39;s 70-m dish was taken offline
for 11 months for upgrades.  <cite>Voyager 2</cite> continued transmitting
data to the smaller dish antennas, but commands could not be sent to the
spacecraft.  Contact was successfully reestablished in early 2021 when the
70-m dish came back online.  (The prior preparation and the actual downtime
are featured in the 2022 film,
<cite><a href="#ItsQuieterInTheTwilight">It&#39;s Quieter in the
Twilight</a></cite>, about the Voyager team.)
</p>

<p>
The DSN stations send commands to the Voyagers at a radio frequence of about
2.1 gigahertz.  Because of the Earth&#39;s rotation (as well as the revolution
of the Earth around the Sun and other factors), a dish antenna as a whole
moves around in space.  As a result, the relative motions of the antenna
and the spacecraft (which is also moving) cause a continuously varying
<a href="https://en.wikipedia.org/wiki/Doppler_effect">Doppler shift</a>
in the radio signal&#39;s frequency as seen by the spacecraft.
(<a href="#Kobele">Kobele</a>, p. 13, says that the Doppler shift can be
up to 3 kilohertz during a DSN pass.)  The Voyager&#39;s receivers were designed
with this in mind and use a <i>phase-lock loop</i> (PLL) circuit to detect,
lock onto, and maintain the lock on a varying frequency signal within a
100-kilohertz range.
</p>

<p>
In 1978, less than a year after launch, ground control forgot to reset
<cite>Voyager 2</cite>&#39;s Command Loss timer and the aforementioned CMDLOS
function was tested for real when the timer expired.  The CCS computer thought
the primary receiver was no longer working, so it switched to the backup
receiver.  Unfortunately, the backup receiver&#39;s PLL circuit had failed
partially prior to this switchover and the receiver could not lock onto the
command signal.  After 12 hours, the CMDLOS function switched back to the
primary receiver and contact was reestablished.  &#34;Phew!&#34;, as Wordle likes
to say.  A half-hour later, the primary receiver failed <em>completely</em>.
Back again, <em>a week later</em>, to the backup receiver that couldn&#39;t
receive.  (The CMDLOS timeout value was 1 week for the primary receiver
and 12 hours for the backup receiver.)
</p>

<p>
(Note that human error <em>triggered</em> these two problems, it didn&#39;t
cause them.  The partial failure of the backup receiver&#39;s PLL circuit had
already happened and the complete failure of the primary receiver was just
waiting to happen.  The project was actually fortunate that this occurred
early on and not later, for example, in the middle of flying by Jupiter.)
</p>

<p>
I don&#39;t know how they did it, but somehow the engineers figured out that
the backup&#39;s PLL circuit was limited to a single, nominal frequency with
a tolerance of only 100 Hz — that&#39;s 100 cycles-per-second in a
2.1 billion cycles-per-second radio frequency.  Wow!  Since
<cite>Voyager 2</cite>&#39;s receiver could no longer compensate for the Doppler
shift (up to 3 kHz during a pass), the DSN transmitter had to compensate by
sending a varying frequency signal that canceled out the pre-calculated,
expected Doppler shifts, thus delivering a constant-frequency signal to
the spacecraft.
</p>

<p>
    Note: The 100 kHz and 100 Hz figures are from
    <a href="#LudwigAndTaylor">Ludwig and Taylor</a>, p. 39-40;
    other sources have slightly different values.
</p>

<p>
Would that things were so simple!  The frequency at which the backup receiver
is listening for commands is called the <i>best-lock frequency</i> (BLF).
The BLF is extremely sensitive to the temperature of the receiver and small
changes in temperature cause shifts in BLF exceeding the 100-Hz range.  Many
activities on the spacecraft cause these temperature changes.  To cope with
this added difficulty, the ground system must <i>(1)</i> limit uplinks to
no-activity periods when the receiver&#39;s temperature is stable and <i>(2)</i>
regularly recalibrate the BLF.  The former is accomplished by following a
period of activity with an uplink-free, 24- to 72-hour <i>command
moratorium</i> that gives the temperature time to stabilize.  The latter
is done with a scatter-shot approach, sending something (probably a test
command of some kind) at multiple frequencies and seeing which one actually
gets through.  (<a href="#McLaughlinAndWolff">McLaughlin and Wolff</a>, p. 5,
describe using the scatter-shot approach to uplink emergency or time-sensitive
commands during <em>active</em> periods: send the same command at multiple
frequencies in hopes that one will get through.  This technique may have been
used in planetary fly-bys to upload onboard sequence updates.)
</p>

<p>
Amazingly, all this was made to work and <cite>Voyager 2</cite> successfully
flew by Jupiter, Saturn, Uranus, and Neptune and returned valuable images
and science data under these operational constraints.  And continues to do so.
(The 2020 MAG-roll-gone-awry in <cite><a href="#ItsQuieterInTheTwilight">It&#39;s
Quieter in the Twilight</a></cite> was probably followed by a command
moratorium.)
</p>

<p>
    Addendum: Various sources attribute the crippling of the backup receiver
    to the failure of a tracking-loop capacitor in the PLL.
    <a href="#Kobele">Kobele</a>, 1989, p. 14, was more specific: &#34;a resistive
    short in the tracking loop capacitor due to particle migration through the
    dielectric material&#34;.  This necessitated a periodic maintenance operation
    to prevent complete failure: &#34;It has been demonstrated that particles
    which have not yet completed their migration can be destroyed when the
    capacitor charge is maximized by periodically pulling the uplink signal
    to the extremes of the loop bandwidth.&#34;  (I have not seen this mentioned
    elsewhere.)
</p>

<hr id="SequencesAndSimulators"/>

<h3>Sequences and Simulators</h3>

<p>
Regarding simulators, you&#39;ll find comments such as, &#34;Give me the CPU details
and I&#39;ll whip up a simulator over the weekend.&#34;  These comments and the earlier
questions are not bad and I admit to often having similar thoughts myself.
However, as software developers, we of all people should have —
but don&#39;t have — an instinctual reaction that nothing is
<em>ever</em> as simple as it first seems.
</p>

<p>
In this case, simulating the CPU may be the least complicated part of a
flight computer simulator, itself part of a larger system.  It turns out
that, much to my amazement, the engineers back in the 1970s —
without JavaScript and Rust, without gigabytes of RAM, and without
<a href="https://tonsky.me/blog/js-bloat/">55-MB web pages</a> —
somehow managed to write sophisticated and complex programs!
</p>

<p>
The following discussion is largely based on the papers by
<a href="#McEvoy">McEvoy</a> (1975) and <a href="#Adamski">Adamski</a> (1987)
about the Viking and Voyager simulators, respectively.  The descriptions here
are <em>my</em> understanding of the systems, which may likely be imperfect.
The intended takeaway is that the systems were complex and I think that
will be made clear in spite of any errors.  (<a href="#LinickAndWeld">Linick
and Weld</a>&#39;s 1992 paper examines the streamlining of the prior sequencing
process, as described in Adamski, for the Voyager Interstellar Mission,
an effort that successfully met two goals, among others, of moving off the
Univac mainframes and operating with greatly reduced personnel in the long
term.  The paper provides a somewhat managerial evaluation of the changes and
doesn&#39;t provide the new hardware and software details I would have liked.)
</p>

<p>
Note something that I completely missed in my initial readings.  The
Viking Orbiter had <em>only one computer</em> (and its backup), the CCS.
Its Attitude Control Subsystem (ACS) and its Flight Data Subsystem (FDS)
did not have their own computers.  The Viking FDS <em>did</em> have a
1K-by-8-bit plated-wire memory:
</p>

<blockquote>
<p>
    The FDS memories were required to perform a number of essential tasks
    and were additionally used to accomplish a variety of FDS housekeeping
    functions, including reading engineering identifiers for the flexible
    formats; buffering MAWDS, VIS, and IRTMS (A/PW) science data; storing
    and updating VO time; storing PN sequences for the VIS and science
    formats; executing memory-alteration commands from CCS; performing
    most of the science format multiplexing; and counting TV pictures
    taken and controlling related FDS logic.
</p>
<p>
    —Neil A. Holmberg, Robert P. Faust, and H. Milton Holt,
    <cite><a href="https://ntrs.nasa.gov/citations/19810001593">Viking &#39;75
    Spacecraft Design and Test Summary, Volume II: Orbiter Design</a></cite>
    (NASA Reference Publication 1027), p. 61, November 1980.
</p>
</blockquote>

<p>
Because of signal transmission delays, the Viking and Voyager spacecraft were
designed to function autonomously, a form of operation that depends heavily on
stored command sequences as opposed to single, separate, &#34;real-time&#34; commands.
Consequently, simulation is especially geared towards the testing of command
sequences.
</p>

<p>
In the introduction, I defined a command sequence as a sequence of commands,
but they are much more than that.  A sequence is composed of <i>blocks</i>,
each of which consists of:
</p>

<ul>
<li><p>
    <i>Events</i> - are actions (?) that may or may not be associated with
    <i>spacecraft commands</i>.  In McEvoy&#39;s sample Viking Orbiter block
    (Figure 9, p. 414), events with CCS spacecraft commands are actions
    targeted to the external subsystems such as the ACS and FDS.  In one
    entry, the CCS instructs the ACS: &#34;Inertial mode; stop roll turn;
    stop yaw turn; negative turn direction&#34;.  Events without CCS commands
    are actions taken internally by the CCS, as in this CCS event: &#34;Disable
    the ACS accelerometer calibration within the CCS&#34;.
</p></li>
<li><p>
    <i>Data</i> - any data required by the block; e.g., tables.
</p></li>
<li><p>
    <i>Flight software</i> - is the non-core software needed to support the
    commands/events in the block.
</p></li>
</ul>

<p>
In developing a sequence, engineers such as Suzanne Dodd could draw on
previously defined blocks in the <i>block dictionary</i> for subtasks, much
like programmers use functions from libraries.  Blocks used in such a manner
are customized via <i>block options</i> and pull in their own required flight
software.  A Viking block&#39;s flight software was stored as OSTRAN macros
(McEvoy, p. 415); OSTRAN was the Viking counterpart to Voyager&#39;s SEQTRAN.
The output of OSTRAN is assembly source code that is passed on to an
assembler and linker, ultimately resulting in the memory load (containing
sequence, data, and flight software) that will be uplinked to the spacecraft.
It appears that the flight software resident in memory consists of <i>(i)</i>
the core software that is always present (executive, sequence processing,
fault protection, etc.) and <i>(ii)</i> only the non-core software needed
to support the currently loaded sequences.
</p>

<p>
Throughout the development and simulation of sequences, there are automated
and human checks for physical and operational constraint violations.  When
a violation is detected, engineers determine how serious the violation is
and, if necessary, go back to the drawing board to remedy the problem.
The engineers also need to verify that a sequence actually does what it
is supposed to do; e.g., take a picture of Neptune.  Consequently, the
design-develop-test cycle for sequences is an iterative process.
</p>

<p>
A block diagram for the Voyager simulator (COMSIM) would look similar to that
of the Viking Orbiter simulator (OCOMSM) below.  (I think — I
haven&#39;t been able to find detailed information about Voyager&#39;s simulator.
Incidentally, the Viking Lander simulator was called LCOMSM.)  Note that
the nested CCS and FDS simulators are <em>subsystem</em> simulators.  I&#39;m
puzzled by the absence of an ACS simulator.  The Viking Data Storage
Subsystem, DSS, handled the Digital Tape Recorder (DTR), a function taken
over by Voyager&#39;s FDS.
</p>

<div>
<p>
    <a href="http://www.geonius.com/writing/other/viking-orbiter-simulator.png"><img alt="Viking Orbiter Simulator" src="http://www.geonius.com/writing/other/viking-orbiter-simulator.png"/></a>
</p>
<p>
    Viking Orbiter Simulator Functional Block Diagram
    (click image to enlarge) (<a href="#McEvoy">McEvoy</a>, Figure 11, p. 417)
</p>
</div>

<p>
The simulator outputs on the right side of the diagram are very important
and provide:
</p>

<ul>
<li><p>Visibility into the internal sequence processing to the sequence
    and flight software engineers.
</p></li>
<li><p>A step-by-step timeline for the flight controllers to follow (after
    the fact because of the time delay!) as the sequences are actually
    executed on the spacecraft.
</p></li>
</ul>

<p>
The step-by-step timeline is called the <i>Sequence of Events</i> (SOE) on
Voyager:
</p>

<blockquote>
<p>
    In addition to the blocks of load commands, the sequence generation process
    provides other products that are used in the command and control of the
    spacecraft.  A Sequence of Events (SOE) is produced that is a printed,
    time-ordered listing of the activities contained in the CCS sequence.
    Performance predictions are generated for power usage, scan platform
    pointing, and other spacecraft functions.  Additional uplink commands may
    also be generated along with the main sequence.  These commands are held
    for subsequent transmission at pre-identified points in the sequence in
    order to perform discrete functions or enable checkpointed events.
</p>
<details>
<summary>
    Terrence P. Adamski,
    &#34;<a href="https://arc.aiaa.org/doi/10.2514/6.1987-501">Command and Control
    of the Voyager Spacecraft</a>&#34; (abstract)
</summary>
    p. 5, American Institute of Aeronautics and Astronautics (AIAA),
    25th AIAA Aerospace Sciences Meeting, March 24-26, 1987, Reno, Nevada.
</details>
</blockquote>

<p>
A spacecraft is more than just its flight software and simulators must also
simulate the hardware.  McEvoy suggested
<a href="https://en.wikipedia.org/wiki/APL_(programming_language)">APL</a>
for both describing and simulating hardware, although he didn&#39;t come right
out and say they used APL.  I wasn&#39;t aware of APL&#39;s role in the hardware
realm, but it&#39;s a real thing.  (I do question the widely asserted notion
that APL was originally a hardware description language.  That doesn&#39;t seem
to agree with Kenneth Iverson&#39;s contemporary writings and later recountings
of APL&#39;s history, but it is a Fortran 5-like rabbit hole that I&#39;ll leave to
someone else to explore!)
</p>

<blockquote>
<p>
    One difficulty in modeling digital hardware is the different languages
    used in the hardware and software disciplines.  Hardware description
    languages that describe hardware at the logic-gate bit-time
    register-transfer level provide a commonly understandable detailed
    definition that can bridge the gap.  The APL language itself provides
    an excellent basis for describing digital hardware.  Power-on-reset
    states and hardware idiosyncracies, that could affect a sequence,
    must be considered in the modeling stage.  Any of these that could
    affect operation of the hardware, software, timing, or other subsystems
    should be modeled.
</p>
<details>
<summary>
    Maurice B. McEvoy,
    &#34;<a href="https://informs-sim.org/wsc75papers/1975_0054.pdf">Viking
    Orbiter Uplink Command Generation and Validation via Simulation</a>&#34;
    (PDF)
</summary>
    p. 417, The Institute for Operations Research and the Management Sciences
    (INFORMS)
    <cite><a href="https://informs-sim.org/wsc75papers/prog75sim.html">Winter
    Simulation Conference 1975 Conference Proceedings</a></cite>.
</details>
</blockquote>

<p>
Voyager&#39;s CCS <em>subsystem</em> simulator would also have looked similar
to Viking&#39;s:
</p>

<div>
<p>
    <a href="http://www.geonius.com/writing/other/viking-ccs-simulator.png"><img alt="Viking CCS Simulator" src="http://www.geonius.com/writing/other/viking-ccs-simulator.png"/></a>
</p>
<p>
    Viking Orbiter CCS Simulator
    (click image to enlarge) (<a href="#McEvoy">McEvoy</a>, Figure 12, p. 418)
</p>
</div>

<p>
Each of the CCS, AACS, and FDS subsystem simulators would have had to simulate:
</p>

<ul>
<li>the two CPUs,
</li>
<li>the internal elements of the subsystem (e.g., memory banks),
</li>
<li>interfaces with elements external to the subsystem (including
    interfaces with the other computer subsystems),
</li>
<li>cross-strapping (switching) between primary/redundant elements both
    internal and external,
</li>
<li>and the <i>timing</i> of everything.
</li>
</ul>

<p>
The two CCS CPUs could also work independently of each other and not in a
strict primary/backup relationship.  Despite my listing of the simulation
&#34;requirements&#34; above, there is a lot I don&#39;t know about the simulators:
</p>

<ul>
<li><p>
Were CPUs simulated in software or were actual hardware spares used?
</p></li>
<li><p>
For CPUs simulated in software, was the simulation at the instruction-set
level or was it a simulation of the CPUs&#39; actual electronic circuits
(e.g., using APL)?
</p></li>
<li><p>
And similar questions about interfaces with the various non-CPU elements:
Was an interface simulated at a logical level or as an electronic circuit?
Or was a real interface with a hardware spare used?
</p></li>
<li><p>
What elements could be cross-strapped?  And was cross-strapping simulated?
</p></li>
</ul>

<p>
In other words, my ideas about the simulators are largely guesswork.  McEvoy
does provide a few more details about the CCS simulator, although some of my
questions are still unanswered:
</p>

<blockquote>
<p>
    <u>The Computer Command Subsystem (CCS)</u> simulator (Fig. 12) accurately
    models the Block redundant CCS processors, output units, and memories at
    the instruction and register transfer level.  The accuracy with which
    software programs (in the memories) are simulated is dependent primarily
    on the accuracy with which the bit-time clocks can be calibrated during
    flight and timing accuracies of the 32 priority interrupts and 24 level
    indicators.  Output simulation consisting of discrete commands (relay
    closures), coded commands, and telemetry data can be routed through
    either or both output units.  A hardware and software self-test must
    be satisfied before access can be obtained to an output unit.
    <i>(p. 418)</i>
</p>
<p>
    ...
</p>
<p>
    The large amount of time used to simulate uplink command decoding is
    due primarily to the CCS hardware and software self-test activity,
    which in turn is affected by the FDS engineering telemetry rate and
    format. <i>(p. 419)</i>
</p>
<details>
<summary>
    Maurice B. McEvoy,
    &#34;<a href="https://informs-sim.org/wsc75papers/1975_0054.pdf">Viking
    Orbiter Uplink Command Generation and Validation via Simulation</a>&#34;
    (PDF)
</summary>
    The Institute for Operations Research and the Management Sciences (INFORMS)
    <cite><a href="https://informs-sim.org/wsc75papers/prog75sim.html">Winter
    Simulation Conference 1975 Conference Proceedings</a></cite>.
</details>
</blockquote>

<p>
(I don&#39;t understand the purpose of the &#34;hardware and software self-test&#34;
in the last sentence of the first paragraph.  Was this done on the actual
spacecraft?  The later sentence seems to indicate &#34;Yes&#34;.  I can understand
self-tests performed repeatedly in the background or prior to a set of
operations, but I am perhaps overestimating the frequency of the self-tests.)
</p>

So, spacecraft simulators are complex systems.  What did the Voyager simulator
look like?

<blockquote>
<p>
    The validation end of the software development process was handled by the
    Capability Demonstration Laboratory (CDL).  Completed after the initial
    software was produced, it was a collection of either breadboard or flight
    surplus computer and science hardware, and its interfaces interconnected in
    the same way as those on the actual spacecraft.  Its function is identical
    to that of the Shuttle Avionics Integration Laboratory (SAIL), in which
    both software and hardware changes could be tested to see if they
    functioned successfully.
</p>
<details>
<summary>
    James E. Tomayko,
    <cite>Computers in Spaceflight: The NASA Experience</cite>, 1988
</summary>
    <a href="https://web.archive.org/web/20231123211500/https://history.nasa.gov/computers/Ch6-2.html">Chapter
    Six, Section 2</a>, p. 175.
</details>
</blockquote>

<p>
And the CDL lapsed into disrepair:
</p>

<blockquote>
<p>
    In addition, the [Voyager flight team] also has to work around a lack
    of a hardware test bed, the limited memory of on-board computers, and
    antiquated programming languages.
</p>
<p>
    The Capability Demonstration Lab (CDL), the testbed used during the prime
    mission, could not be maintained and had to be abandoned at the start of
    VIM.  The failures of the testbed were too often, even in pre-VIM, due to
    aging hardware and disappearing repair expertise.  The project had to move
    to a new location in early VIM and the CDL did not survive the move.  There
    are no simulators for the AACS or FDS and only the CCS has a simulator,
    i.e., HSSIM.  As a result, any FSW changes other than something very simple
    have to be done in the CCS.
</p>
<details>
<summary>
    Sun Kang Matsumoto,
    &#34;<a href="https://arc.aiaa.org/doi/pdf/10.2514/6.2016-2415">Voyager
    Interstellar Mission: Challenges of Flying a Very Old Spacecraft on
    a Very Long Mission</a>&#34; (PDF)
</summary>
    p. 6, 2016 SpaceOps Conference, Daejeon, Korea.
</details>
</blockquote>

<p>
The last sentence above suggests to me that a non-trivial change to the AACS
or FDS flight software is considered risky and that, if possible, it is
better to leave the existing AACS/FDS software as-is and have the CCS take
over responsibility for the changed functionality.  That&#39;s my impression
at least; given the lack of rigorous simulation capabilities, I think it&#39;s
a sensible decision.
</p>

<p>
Oddly, searching on Google for JPL&#39;s &#34;Capability Demonstration Lab&#34;, mentioned
by both Tomayko and Matsumoto, only brings up a couple of references to
Matsumoto&#39;s paper; on Bing, you get a single result ... for JPL&#39;s Cyber
Defense Laboratory!  By a strange coincidence, a couple of hours after
reading the previous sentence, I was reading McLauglin&#39;s &amp; Wolff&#39;s paper
about the preparations for <cite>Voyager 2</cite>&#39;s Uranus fly-by and I came
across the most detailed description of the CDL yet.  Which is not saying much,
but the passage below does give a good picture of a flight software engineer&#39;s
life!
</p>

<p>
The physical actions and movements in the Digital Tape Recorder (DTR)
produce &#34;equal and opposite reactions&#34; in the spacecraft and thus affect
the spacecraft&#39;s attitude.  After the Saturn encounter, a routine, DSSCAN,
was added to simultaneously fire attitude control thrusters when performing
high-rate tape operations, thereby greatly reducing the time it takes for
the spacecraft attitude&#39;s rate-of-change to slow enough to begin the next
science operation.  (A savings of over 3 minutes in the case of the
end-of-track turnaround, valuable time during the all too brief hours of
closest approach.)  That&#39;s my understanding; it&#39;s not clear which computer
DSSCAN was added to, AACS or CCS.
</p>

<p>
Note how <cite>Voyager 1</cite>, its mission already completed, was used
as a test bed for the <cite>Voyager 2</cite> FSW modifications.  Note also
that the AACS and CCS programs were <em>not</em> reassembled, but instead
patched, a practice that had been ongoing since launch.  What a nightmare
the onboard software must have become!  I don&#39;t know how long the practice
continued, but it makes the VIM team&#39;s reluctance to modify the AACS software,
per Matsumoto, even more understandable.
</p>

<blockquote>
<p>
    The DTR is mounted on the spacecraft such that its angular momentum is
    introduced into the yaw and pitch axes of the spacecraft with almost none
    going into the roll axis.  DSSCAN was first programmed to introduce
    cancelling momentum in the yaw axis only.  The modification to the AACS and
    CCS software took place in an environment of a scarcity of available memory
    so that, from a programming point of view, it had to be carefully fit in.
    The &#34;patch&#34; was carefully tested in the Voyager Capability Demonstration
    Laboratory (CDL) before loading onboard Voyager 1.  (The AACS and CCS
    programs were modified without being reassembled as is the case with all
    AACS and CCS changes since launch.) The CDL is a digital/analog simulation
    of many of the spacecraft capabilities.  Modifications or tests of any
    degree of complexity are done first, whenever possible, on Voyager 1 before
    implementation on Voyager 2, a reflection of the fact that Voyager 2 still
    has two planetary encounters scheduled while Voyager 1 has none.
</p>
<p>
    Once onboard the spacecraft, DSSCAN was tested during periods of DTR
    operation to determine empirically how many thruster pulses should be used
    to counteract a DTR event.  For example, tests on Voyager 1 in March of
    1984 showed that five thruster pulses were the optimum number.  These
    pulses each have an electronic-activation length of 10 ms, and a single
    pulse will change the drift rate about the spacecraft yaw axis by
    approximately 11 µr/s.  See Fig. 12.
</p>
<p>
    Now that the effect of DSSCAN on yaw-axis momentum introduced by DTR events
    is known, the subroutine is being modified to incorporate momentum (near)
    cancellation in the pitch axis.  Although the modification is, in
    principle, straightforward in view of the yaw axis experience, in practice
    this is not the case.  The relative complexity arises from the tight
    programming that must be done because of the shortage of AACS and CCS words
    and existing programs that have already been heavily modified; with
    resultant complexity of code.  Add to this the potentially serious
    consequences that could arise from any mistake in modifying the control law
    of the spacecraft, and one appreciates the fact that even seemingly simple
    changes can require extensive time for testing and experienced personnel
    for safe implementation.  <i>(pp. 11-12)</i>
</p>
<p>
    ...
</p>
<p>
    During implementation of the sequence, certain critical or complex
    subsequences may be checked for validity by running them through a
    sophisticated analog/digital simulation of extensive portions of the
    spacecraft: the Voyager Capability Demonstration Laboratory (CDL).
    The CDL contains, for example, duplicate versions of CCS, AACS, FDS,
    scan platform actuators, and the DTR.  <i>(p. 17)</i>
</p>
<p>
    —W.I. McLaughlin and D.M. Wolff,
    &#34;<a href="https://arc.aiaa.org/doi/abs/10.2514/6.1985-287">Voyager Flight
    Engineering: Preparing for Uranus</a>&#34; (abstract), pp. 11-12, American
    Institute of Aeronautics and Astronautics (AIAA), 23rd Aerospace Sciences
    Meeting, January 1985, Reno, NV.
</p>
</blockquote>

<p>
    Aside:  I&#39;m not sure how to square the &#34;patching-only&#34; of the CCS code
    (or if it even needs to be squared) with McEvoy&#39;s description of assembly
    source code being pulled from the sequencing block dictionary, code that
    would be assembled and placed in a sequence&#39;s uplink memory load.
</p>

<p>
The <i>High Speed Simulator</i> (HSSIM) is a flexible spacecraft simulator
developed at JPL in the 1990s and written in C++.  Spacecraft components are
represented by C++ objects and a component/object may have one or more
interfaces.  Interfaces are strongly typed and connections between components
can only be made over compatible interfaces.  For example, you can connect a
CPU&#39;s data bus to a memory bank&#39;s data bus, but not to the memory bank&#39;s
address bus.  The link, at the C++ level, between two interfaces is called
a <i>splice</i>.  Each component has its own
<a href="https://en.wikipedia.org/wiki/Tcl">Tcl</a> interpreter that allows
scriptable behavior in addition to other functions:
</p>

<blockquote>
<p>
    C++ was chosen as the implementation language for simulation components,
    because of its run time efficiency and its support for object-oriented
    programming.  A processor component, for example, may emulate a hardware
    instruction set and the code which implements this must be sufficiently
    fast to meet the performance objectives of the simulator.
</p>
<p>
    Most components contain a<i>[n]</i> embedded interpreter which
    recognizes the language Tcl.  Tcl is a freely available embeddable
    language and concrete interpreter implementation developed at the
    University of California, Berkeley.  Tcl was augmented to make it
    multi-thread (&#34;MT&#34;) safe and to add additional features, in particular,
    a C++ class wrapper and a fast &#34;remote procedure call&#34; that can execute
    commands remotely on named interpreters (many of the components within
    HSS contain named interpreters, which are used to manipulate the
    component) and return the result of the execution to the local interpreter.
    The HSS Tcl subsystem is used for many things, including model state
    examination and alteration, establishment of model interconnections, and
    model state monitoring and display (using Tk, a toolkit based on Tcl
    which can quickly create Graphical User Interfaces).  As a general rule,
    Tcl is used unless other performance or robustness concerns dictate the
    use of splices.
</p>
<p>
    —K. Patel, W. Reinholtz, and W. Robison,
    &#34;<a href="https://adsabs.harvard.edu/full/1996ESASP.394..749P">High
    Speed Simulator — A Simulator for All Seasons</a>&#34;
    (<a href="https://articles.adsabs.harvard.edu/cgi-bin/nph-iarticle_query?1996ESASP.394..749P&amp;defaultprint=YES&amp;filetype=.pdf">PDF</a>),
    p. 751, <cite>SpaceOps 1996, Proceedings of the Fourth International
    Symposium</cite>, Munich, Germany.
</p>
</blockquote>

<p>
HSSIM supports multiple implementations of a given spacecraft component/object,
with the choice of which implementation to use being made at the time of a
simulator run.  Depending on their need, an engineer can choose between,
for example, a slower, <i>bit-level</i> (logic-gate) simulation of a component
or a faster, <i>functional-level</i> simulation.  HSSIM was successfully used
in various roles for the Jupiter orbiter,
<cite><a href="https://en.wikipedia.org/wiki/Galileo_project">Galileo</a></cite>,
beginning some time after the spacecraft&#39;s high-gain antenna failed to fully
deploy in 1991.  According to the paper, versions for the Saturn orbiter,
<a href="https://en.wikipedia.org/wiki/Cassini%E2%80%93Huygens"><i>Cassini</i></a>
(to be launched in 1997), and Voyager were to be delivered &#34;later this year&#34;
(1996?).
</p>

<p>
As a software developer, I admire and respect the design of HSSIM.  And my
knowledge of the capabilities and implementation of the earlier COMSIM and
CDL is almost entirely inferred from McEvoy&#39;s description of the Viking
simulator; i.e., I could be way off-base.  Keeping this in mind, I suspect
that the HSSIM delivered to and used on Voyager is a bare-bones CCS simulator.
Building a software-based simulator for a specific spacecraft is a
labor-intensive task, with or without HSSIM.   You need people knowledgeable
about the spacecraft and buy-in from a management willing to invest in the
effort.  The nearly 20-year-old Voyager spacecraft had already fulfilled
their primary missions and the program lacked some key requirements for
building a simulator:
</p>

<ul>
<li>Many people with intimate knowledge of the spacecraft hardware and
    flight software had moved on or retired.
</li>
<li>JPL as an organization was probably losing interest in the program as
    newer — much newer — programs vied for attention.
</li>
<li>Machine-readable documentation (e.g., hardware specifications) was
    probably non-existent.
</li>
<li>HSSIM developers themselves were probably none too eager to work
    on technology from the ancient past!
</li>
</ul>

<p>
Knowing C++ and Tcl would have been helpful.  The HSSIM paper did mention
automatic code generation using an expert system and, under &#34;Future
Direction&#34;, proposed other means of automatically building parts of the
simulator.  Those would lessen the need for C++/Tcl software expertise,
but there&#39;s still the laborious task of assembling and manually entering
all the information needed as inputs to the expert system and to the other
proposed mechanisms.
</p>

<p>
So, no AACS or FDS simulators.  Only a bare-bones CCS simulator.
(Again, that is my impression from my readings and I hope I am wrong.)
</p>

<hr id="AACS"/>

<h2>AACS, HYPACE, and HYBIC</h2>

<p>
<em>NOTE</em> that the AACS computer is <em>not</em> the at-the-time
experimental HYPACE (Hybrid Programmable Attitude Control Electronics)
computer.  For budgetary reasons, Voyager instead used a CCS computer
running at a higher clock rate and with an added index register found
useful on HYPACE.  Dr. Tomayko wrote:
</p>

<blockquote>
<p>
    Documentation for the system still refers to the attitude control
    computer as HYPACE, even though its heart was the [CCS] command computer.
</p>
<details>
<summary>
    James E. Tomayko,
    <cite>Computers in Spaceflight: The NASA Experience</cite>, 1988
</summary>
    <a href="https://web.archive.org/web/20231123211500/https://history.nasa.gov/computers/Ch6-2.html">Chapter
    Six, Section 2</a>, p. 178.
</details>
</blockquote>

<p>
(General Electric made both the CCS and HYPACE computers.)  With respect
to HYPACE, Dr. Tomayko wrote:
</p>

<blockquote>
<p>
    Index registering meant that the same block of code could be used for all
    three axes, reducing memory requirements.
</p>
<details>
<summary>
    James E. Tomayko,
    <cite>Computers in Spaceflight: The NASA Experience</cite>, 1988
</summary>
    <a href="https://web.archive.org/web/20231123211500/https://history.nasa.gov/computers/Ch6-2.html">Chapter
    Six, Section 2</a>, p. 177.
</details>
</blockquote>

<p>
This sounds like the typical use of an index register: add the value in the
index register to addresses when accessing memory.  By changing the value
in the index register, a program can switch between each axis&#39;s set of
variables prior to calling a common subroutine.
</p>

<p>
I suspected a simple way of implementing an index register so as to avoid
changing the CPU&#39;s instruction set would have been to place a
memory-addressable chip or electronic circuit between the CPU and memory
to hold the index value.  The following description of the AACS computer
found elsewhere gives a name to a circuit that may or may not be such an
implementation:
</p>

<blockquote>
    <p>
    The Attitude and Articulation Control Subsystem used an augmented version
    of the CCS computer that inserted a unit (the Hybrid Buffer Interface
    Circuit (HYBIC)) between the CPU and RAM, which intercepted instructions to
    add indexed addressing capability (at the expense of other instructions),
    and accelerated instructions that used idle cycles.
    </p>
    <p>
    —John Culver,
    &#34;<a href="https://www.cpushack.com/space-craft-cpu.html">The CPUs of
    Spacecraft Computers in Space</a>&#34;, The CPU Shack.
    </p>
</blockquote>

<p>
Unlike other (incorrect) descriptions, Culver&#39;s doesn&#39;t conflate the AACS
with HYPACE, so I think he knows what he&#39;s talking about.  His description
does seem to indicate that changes <em>were</em> made to the CCS CPU and
its instruction set for the AACS.  Strangely, Tomayko&#39;s report doesn&#39;t
mention HYBIC at all.
</p>

<p>
In her 2016 paper, Matsumoto describes a problem in a decidedly more complex
HYBIC:
</p>

<blockquote>
<p>
    The Hybrid Buffer Interface Circuits (HYBIC) on V1 was switched to the
    backup unit in 2002 due to a failing component inside the HYBIC Analog
    to Digital (A/D) converter.  The star tracker on the original HYBIC was
    performing well at the time of the switch but each HYBIC has a unit
    (A/D converter, sun sensor, and star tracker) dedicated to the HYBIC.
    The star tracker on the current HYBIC is degrading rather rapidly and
    closely monitored; it is quite likely that a HYBIC switch back to the
    original is needed before the end of the mission
</p>
<details>
<summary>
    Sun Kang Matsumoto,
    &#34;<a href="https://arc.aiaa.org/doi/pdf/10.2514/6.2016-2415">Voyager
    Interstellar Mission: Challenges of Flying a Very Old Spacecraft on
    a Very Long Mission</a>&#34; (PDF)
</summary>
    p. 3, 2016 SpaceOps Conference, Daejeon, Korea.
</details>
</blockquote>

<p>
Okay, HYBIC is a lot more than just an index register or registers.  (See
the picture of the
<a href="https://airandspace.si.edu/collection-objects/hybic-logic-subassembly-voyager-spacecraft/nasm_A19990061000">HYBIC
Logic Subassembly</a> at the Smithsonian.)  A 2006 JPL presentation about the
<cite>Voyager 2</cite> HYBIC problems included a functional block diagram of
the AACS (click image to enlarge):
</p>

<p>
    <a href="http://www.geonius.com/writing/other/voyager-aacs-block-diagram.jpg"><img alt="AACS Block Diagram" src="http://www.geonius.com/writing/other/voyager-aacs-block-diagram.jpg"/></a>
</p>

<p>
The diagram doesn&#39;t show an interface between the HYBIC and its associated
memory bank.  However, a 1981 U.S. Air Force study,
<cite><a href="#Autonomous">Assessment of Autonomous Options for the DSCS III
Satellite System</a></cite>, has a similar diagram (Figure B-3, p. 178) that
adds a 6th arrow between the HYBIC and RAM.  And, interestingly, has a dashed
box labeled &#34;HYPACE&#34; around the upper portion of the diagram!
</p>

<p>
The role of HYBIC in the AACS is up in the air for me.  Online information
about HYBIC is extremely scarce and what little I could find is basically
a rehash in one form or another of the information above.
</p>

<hr id="MiscellaneousInfo"/>

<h2 id="MiscellaneousInfo">Miscellaneous Information</h2>

<div>
    <p><img alt="Voyager Team Relaxing" src="http://www.geonius.com/writing/other/voyager-team.jpg"/>
    </p>
    <p><em>The Voyager team takes a break from worrying
        about bit flips and decreasing RTG power!  Left to right: Lu Yang,
        Todd Barber, Sun Matsumoto, Enrique Medina, and Jefferson Hall.
        The picture is from the movie,
        <cite><a href="#ItsQuieterInTheTwilight">It&#39;s Quieter in the
        Twilight</a></cite>, about 45-50 minutes in, right after the camera
        panned away from Chris Jones and Roger Ludwig on the right side of
        the table.  (Source: JPL&#39;s internal newsletter,
        <cite><a href="https://www.jpl.nasa.gov/who-we-are/universe">Universe</a></cite>,
        June 2023,
        <a href="https://d2pn8kiwq2w21t.cloudfront.net/documents/Universe_-_June_2023.pdf">PDF</a>)</em>
    </p>
</div>




<h3 id="BenHur">Ben-Hur Rides Again!</h3>

<p>
Eat your heart out,
<a href="https://en.wikipedia.org/wiki/Lew_Wallace">Lew Wallace</a>, author
of <cite>Ben-Hur</cite>!  I don&#39;t recall ever seeing the whole movie, but
I did read the novel.  My memory is that the chariot scene was even more
exciting in the book than in the movie, but neither hold a candle to
<cite>Voyager 2</cite>&#39;s launch troubles!
</p>

<p>
Based on Tomayko&#39;s telling (Box 6-1, p. 179-180, in <cite>Computers in
Spaceflight</cite>), my understanding is that the <cite>Voyager 2</cite>
spacecraft had separated from the launch vehicle and was in the process
of extending the booms while at the same time trying to correct its
whopperjawed attitude.  Things began to go wrong, but I&#39;ll let Rasmussen
and Litty tell the story:
</p>

<blockquote>
<p>
    The first launch provided more excitement with little delay.  An
    unbelievable combination of events shortly after injection initiated a
    chain reaction that ultimately triggered nearly every single fault routine
    in the AACS repertoire.  Briefly, the sequence happended as follows.
</p>
<p>
    The spark to the fuse was a partially latched boom, resulting in high
    tip-off rates at propulsion module separation.  Meanwhile, reconfiguration
    activities and a precautionary restoration of isolation value states had
    temporarily disabled attitude control.  While thrusters were waiting to
    fire, the tip-off effects were accumulating, so that by the time the
    isovalve power requests reached the top of the queue, a large angular
    offset existed.  By coincidence, thruster control was re-enabled just
    before sequence activation of thruster fault detection.  This quickly
    responded to the large error by again disabling thruster firing in
    preparation for a switch to backup thrusters.  More isovalve activity
    ensued causing further delays, three more repetitions of the error
    reponse, and finally a self-inflicted heartbeat failure, all within
    sixteen seconds of separation!
</p>
<p>
    This last action was pivotal in resolving the situation.  The new system,
    with no memory of past difficulties, including the large error, quickly
    brought the rates under control.  Finding the sun nowhere in sight, this
    system then proceeded automatically to search for and acquire celestial
    references, achieving success less than three hours after launch.  Ground
    operations spent the next several days recovering.
</p>
<p>
    —R.D. Rasmussen and E.C. Litty,
    &#34;<a href="https://arc.aiaa.org/doi/10.2514/6.1981-1812">A Voyager Attitude
    Control Perspective on Fault Tolerant Systems</a>&#34; (abstract), p. 246,
    American Institute of Aeronautics and Astronautics (AIAA)
    <cite>Guidance and Control Conference</cite>, August 19-21, 1981,
    Albuquerque, New Mexico.
</p>
</blockquote>

<p>
That last exquisite sentence is priceless!
</p>


<hr/>

<h3 id="SuzanneDodd">Suzanne Dodd: Early Voyager Years</h3>

<p>
A couple of additional paragraphs from the Caltech Heritage Project article:
</p>

<blockquote>
<p>
    DODD: It was quite a bit different.  But, you come in, and it was a fairly
    routine thing.  You would be working on a sequence, and it would take six
    weeks to develop that sequence, and then there was different steps, and
    different software programs, and different reviews.  That process then
    repeats itself every six weeks.  From a work standpoint, you&#39;re doing a
    fair amount of the same thing, although you sometimes had special events.
    You sometimes worked with a particular science team on a special
    calibration they wanted to do.  What I do remember is the Voyager team,
    the sequence area had a lot of pranksters in it.  They would like fill
    a person&#39;s drawer with water and put fish in there, and so when they came
    in the next day, the water would splash and they&#39;d have these goldfish
    swimming around in their desk.  [laughs] It&#39;s that kind of a team
    camaraderie.  Most people would eat lunch together, too.  You just
    really were cohesive as a team.
</p>
<p>
    ZIERLER: What areas did you have real responsibility, even in the early
    years?
</p>
<p>
    DODD: I hired in when four other people hired in.  Now, Voyager went
    through Jupiter and Saturn, and then it had a bathtub, because it had five
    years to get out to Uranus.  So a lot of people left.  Because Jupiter and
    Saturn were like 18— maybe two years apart, 18 months to two years
    apart in encounters.  Then there was this lull, so they had to cut—
    a lot of people left, and/or they just needed to trim staffing.  A bathtub
    in staffing, because there was such a long duration.  So, I was part of
    the crew that came back in, new group of crew that came back in during
    Uranus.  There were four of us that hired in all at the same time, to do
    basically the same job, which was sequencing.  It was basically a very
    junior job on Voyager, sequencing engineer, but a super exciting mission.
    Really gets you going for liking this type of work.  Then, when it came
    to Neptune, I got to be the lead sequence engineer.  So, of the four of
    us that were doing it, I got the closest approach sequence.
</p>
<details>
<summary>
    David Zierler,
    &#34;<a href="https://heritageproject.caltech.edu/interviews-updates/suzy-dodd">Suzy
    Dodd (BS &#39;84), Engineer and Deep Space Pioneer</a>&#34;
</summary>
    Caltech Heritage Project, June 9, 2023.
</details>
</blockquote>


<hr/>

<h3 id="LarryZottarelli">Larry Zottarelli</h3>

<p>
In an article about astrophysicists debating whether or not
<cite>Voyager 1</cite> actually had entered interstellar space, the following
encapsulation of a CNN report on Larry Zottarelli appeared:
</p>

<blockquote>
<p>
    [Determining if Voyager 1 has really entered interstellar space] will
    also be just a little bit harder than it was last week, because the last
    original member of the Voyager team has retired.  Larry Zottarelli,
    aged 80, left NASA&#39;s employ this week after 55 years on the job.
    Zottarelli helped to develop Voyager&#39;s on-board computers and has
    worked on the mission since 1975.  CNN reports that he was sent on
    his way with a handshake from actress Nichelle Nicholls, Star Trek&#39;s
    Lt. Uhura.  NASA is reportedly seeking a replacement fluent in FORTRAN,
    Algol and assembly language for the Voyagers&#39; 250 KHz General Electric
    18-bit TTL CPUs, complete with single register accumulator and bit-serial
    access to 4096-word plated-wire RAM.
</p>
<p>
    —Simon Sharwood,
    &#34;<a href="https://www.theregister.com/2015/10/30/has_voyager_1_escaped_the_sun_yet_yes_but_also_no_say_boffins/">Has
    Voyager 1 escaped the Sun yet? Yes, but also no, say boffins</a>&#34;,
    <cite>The Register</cite>, October 30, 2015.
</p>
</blockquote>

<p>
<i>Boffin</i> is British slang for a scientist or engineer!  And the original
<a href="https://money.cnn.com/2015/10/27/technology/voyager-nasa/">CNN
report</a> has pictures, especially of Zottarelli with Nichelle Nichols
AKA Lt. Uhura!  (<cite>The Register</cite> gets it wrong, however.  The
picture with Nichols is from the Voyager 30th anniversary celebration
in 2007, not Zottarelli&#39;s retirement.)
</p>

<p>
The following is from an (unpublished?) article about the Voyager team:
</p>

<blockquote>
<p>
    The quiet voice, that&#39;s Larry Zottarelli, the programmer and &#34;computer
    whisperer&#34;, understanding his machines like no one better does.
</p>
<p>
    —Joachim J. Kehr,
    Editor <cite>SpaceOps News</cite> of the
    <cite>Journal of Space Operations &amp; Communicator</cite>;
    April 2016,
    &#34;<a href="https://www.opsjournal.org/DocumentLibrary/Uploads/TheRightStaff_VoagerOps_JK_comments_final.pdf">Voyager —
    The Right Staff</a>&#34; (PDF), p. 4.
</p>
</blockquote>

<p>
I wasn&#39;t fortunate enough, but I think I would have liked working with him!
(The Kehr article includes an interview with Suzanne Dodd.)
</p>

<p>
I don&#39;t quote it here, but this widely cited, 2017 article in the <cite>New
York Times</cite> leads with a picture of and story about Larry Zottarelli:
&#34;<a href="https://www.nytimes.com/2017/08/03/magazine/the-loyal-engineers-steering-nasas-voyager-probes-across-the-universe.html">The
Loyal Engineers Steering NASA&#39;s Voyager Probes Across the Universe</a>&#34;,
by Kim Tingley, <cite>New York Times</cite>, Aug. 3, 2017.
</p>


<hr/>

<h3 id="RealProgrammers">Real Programmers Don&#39;t Use Pascal</h3>

<blockquote>
<p>
    Some of the most awesome Real Programmers work at the Jet Propulsion
    Laboratory in California.  Many of them know the entire operating system
    of the Pioneer and Voyager spacecraft by heart.  With a combination of
    large ground-based FORTRAN programs and small spacecraft-based assembly
    language programs, they can do incredible feats of navigation and
    improvisation, such as hitting 10-kilometer wide windows at Saturn
    after six years in space, and repairing or bypassing damaged sensor
    platforms, radios, and batteries.  Allegedly, one Real Programmer
    managed to tuck a pattern-matching program into a few hundred bytes
    of unused memory in a Voyager spacecraft that searched for, located,
    and photographed a new moon of Jupiter.
</p>
<p>
    —Ed Post,
    &#34;<a href="https://www.ecb.torontomu.ca/~elf/hack/realmen.html">Real
    Programmers Don&#39;t Use Pascal</a>&#34;, <cite>Datamation</cite>, July 1983,
    &#34;READERS&#39; FORUM&#34;, pp. 263-265.
    (HTML version; the
    <a href="http://www.bitsavers.org/magazines/Datamation/198307.pdf">full
    magazine issue</a> is available as a large PDF.)
</p>
</blockquote>


<hr/>

<h3 id="ClashOfVikings">Clash of Viking Mainframes</h3>

<p>
This section is not related to Voyager.  While searching for information
about the Voyager flight computers, I landed on Herb Johnson&#39;s web page,
&#34;<a href="https://www.retrotechnology.com/memship/1802_spacecraft.html">COSMAC
1802: history of microprocessors in space</a>&#34;, and his accompanying
<a href="https://www.retrotechnology.com/memship/viking_software.txt">notes</a>
about the Viking flight computers.  The notes rely mostly on
<a href="#Tomayko">Tomayko</a>&#39;s report and a Martin Marietta Corporation
report, <cite><a href="#MartinMarietta">Viking Software Data</a></cite>.
(The links to the report in Johnson&#39;s notes don&#39;t work anymore.)
</p>

<p>
Preceding the Voyager program by several years, the
<a href="https://en.wikipedia.org/wiki/Viking_program">Viking</a> mission to
Mars began in 1968.  Two identical pairs of spacecraft were launched in 1975
and arrived at Mars in 1976.  Each pair consisted of <i>(i)</i> an
<a href="https://en.wikipedia.org/wiki/Viking_program#Viking_orbiters">Orbiter</a>
which went into orbit around Mars and <i>(ii)</i> a
<a href="https://en.wikipedia.org/wiki/Viking_program#Viking_landers">Lander</a>
which landed on Mars.
</p>

<p>
JPL was responsible for the Orbiter.  Martin Marietta designed and developed
the Viking Lander and its flight software.  They also developed the
ground-based, mission operations (mission control) software for the Lander.
Afterwards, Martin Marietta wrote an evaluation of the software development
process for the U.S. Air Force, the document used by Herb Johnson above.
</p>

<p>
<cite>Viking Software Data</cite> turned out to be very interesting reading.
After the introductory material, the document consists of individual
evaluations of different <i>techniques</i> used in the development and testing
process.  Each evaluation is structured as follows: name, summary, application
considerations, recommendation, history, description, qualitative results,
and quantitative impact.
</p>

<p>
I was motivated to write &#34;Clash of Viking Mainframes&#34; upon being taken aback
by the description of the second technique, &#34;DIFFERENT DEVELOPMENT/INTEGRATION
SITES&#34;.  Martin Marietta developed and tested the mission operations software
on Control Data Corporation (CDC) mainframes at their Denver, Colorado
facility (denoted MMC) and then <em>converted</em> the <em>source</em> code
to be compiled and tested again on the target Univac and IBM mainframes at
JPL&#39;s Pasadena, California Viking mission control center!  This is somewhat
akin to developing a native Windows application under Linux because you only
had a Linux PC; though possible, it would be unthinkable today.  However, as
you&#39;ll see, there were some very good reasons for this approach —
some known beforehand and some uncovered during the process — and
I can&#39;t fault Martin Marietta or JPL for taking this approach.
</p>

<p>
NASA management feared JPL overextending itself, so it assigned the Orbiter
to JPL and the Lander to Martin Marietta.  However, the Lander integration
and test and the actual operations would still take place at JPL.  So:
</p>

<blockquote>
<p>
    Martin-Marietta Corporation, the Viking Lander contractors, had to do some
    dangerously unique software development when NASA decided to move control
    of the Lander from Langley to JPL.  Since Orbiter software development and
    giving support to other missions tied up JPL&#39;s computers, Martin took the
    chance of developing the Lander software in a &#34;minimal higher order
    language,&#34; specifically a hopefully transportable subset of FORTRAN.
    Martin&#39;s solution reflected its recent migration to IBM 370 series and
    Control Data 6500 series computers at its Denver plant.  These were
    technologically more advanced than the JPL computers and could not be
    trusted to produce directly transportable software.  The idea worked, but
    Martin admitted that the requirement for delivering mission support
    software 10 months before the flight provided strong motivation.
</p>
<details>
<summary>
    James E. Tomayko,
    <cite>Computers in Spaceflight: The NASA Experience</cite>, 1988
</summary>
    <a href="https://web.archive.org/web/20210920045456/https://history.nasa.gov/computers/Ch8-3.html">Chapter
    Eight, Section 3</a> (Unmanned mission control computers), p. 267.
</details>
</blockquote>

<p>
And getting into the &#34;DIFFERENT DEVELOPMENT/INTEGRATION SITES&#34;:
</p>

<blockquote>
<p>
    APPLICATION CONSIDERATIONS: The forecasts for the loads on the computer
    sets at JPL indicated that the MMC portions of the Viking operational
    software system could not be developed on them.  The MMC facility contained
    CDC 6400, CDC 6500 and IBM 360/75 computer sets, whereas the JPL facility
    contained UNIVAC 1108 and IBM 360/75 computer sets.  The operating systems
    of the IBM computers at the two facilities were different.  No equipment
    similar to the JPL UNIVAC 1108 system was available in the Denver area.
    Pathfinder studies indicated software could be developed on non-target
    computers without creating any serious conversion problems.  <i>(p. 30)</i>
</p>
<p>
    HISTORY: One of the problems which faced the management of the Viking
    mission operations lander software development was that the development
    computers differed from the operational computers.  The Martin Marietta
    facility consisted of CDC 6400 and CDC 6500 and IBM 360/75 whereas the JPL
    computer facility consisted of IBM 360/75s and UNIVAC 1108s.  Thus the
    software conversion task became a management concern very early in the
    software development activities.  <i>(p. 31)</i>
</p>
<details>
<summary>
    Martin Marietta Corporation,
    <cite><a href="https://apps.dtic.mil/sti/pdfs/ADA040770.pdf">Viking
    Software Data: Final Technical Report</a></cite> (15MB PDF)</summary>

    May 1977, RADC-TR-77-168.
</details>
</blockquote>

<p>
Keep in mind that lacking the target Univac mainframe could not be remedied
by running down to the local computer store, picking a computer off the rack,
and then shoving it in a spare closet with an ethernet cord back at the office.
A mainframe computer and its peripherals were very expensive and you had to
commit to sizeable initial and long-term investments in real estate (new or
existing housing for the installation), utilities (power, etc.), supplies
(drums, disks, tapes, punch cards, etc., etc.), and especially all the
support personnel needed to manage and run the whole thing.
</p>

<p>
    I should note that my only experience with mainframes was with a
    Univac 1100-series mainframe in the University of Maryland&#39;s Computer
    Science department in the late 1970s.  (They had two 1100s, but I only
    ever used one of them.)  Supporting hundreds if not thousands of students,
    faculty, and staff meant that the department&#39;s mainframe installation fit
    my perhaps overbroad characterization above, but I realize that smaller
    groups or companies could have much leaner installations.
</p>

<p>
The CDC 6500 had two 6400 CPUs; the separate 6400 computer was apparently
not used for Viking development.  I don&#39;t know why the report says here that
Denver had an IBM 360/75 when elsewhere it speaks of a 370, specifically
a 370/155 on p. 260.  The computers from the three companies had widely
differing CPU architectures:
</p>





<p>
<i>Pathfinder</i> studies showed the feasibility of developing the software
on the CDC mainframes and converting it for the IBM and Univac mainframes,
as well as providing guidance and recommendations on practices and techniques.
I think two particular practices contributed to the ultimate success of the
development process: <i>(i)</i> determining a minimal subset of Fortran that,
if adhered to, would significantly reduce the level of manual effort in the
conversion process and <i>(ii)</i> educating the programmers in the
<i>why</i>s of the minimal subset, in the 3 different architectures,
and in the importance of writing portable code.
</p>

<p>
The conversion process was successful, but not without a number of serious
problems.  The minimal subset of Fortran couldn&#39;t encompass some of the
different but needed operating-system-specific capabilities.  Assembly
language code was required in some cases for performance reasons or to
stay within memory limitations.  IBM assembly code could be assembled and
tested to some extent on MMC&#39;s IBM 370, but the Univac assembly code could
only be developed and tested on JPL&#39;s 1108.  Fortran programs tested and
changed at JPL had to have the changes back-ported to the CDC source code,
an annoying and error-prone task.
</p>

<p>
I was very surprised at how difficult the IBM computers made everything,
and not just in the conversion process.  JPL had an unhappy history with
IBM 360s according to <a href="#Tomayko">Tomayko</a> (Chapter 8, Section 3,
p. 265).  In late 1969 and early 1970, JPL received two hand-me-down 360s
from two other NASA centers; JPL later purchased a third, brand-new 360.
The one previously used on the Apollo program had a bespoke, real-time
operating system from IBM.  At the time of Mariner 9&#39;s launch in May 1971,
the ground software failed every 5 hours.  By the time Mariner 9 reached
Mars in November, the failure rate had thankfully dropped to <em>only</em>
every 20 hours!  (I am reminded of a colleague in the 1980s who went to work
at an IBM facility in Maryland for a low-earth-orbiting satellite.  Per his
telling, the ground system would usually crash once during a 20-minute
satellite pass, but the system rebooted fast enough to keep the pass from
being a total waste.  Again, this was in the 1980s and I don&#39;t remember if
the system used an IBM or non-IBM minicomputer.)
</p>

<p>
Some mistakes were self-inflicted, although I would not count among those
good-faith decisions that just didn&#39;t turn out as planned.  All the logic
and reason in the world can&#39;t foresee, for example, a faulty IBM Fortran
compiler on JPL&#39;s 360.  However, Martin Marietta should have foreseen the
major hit the Viking effort would take from switching the CDC 6500&#39;s
operating systems from CDC&#39;s unofficial MACE OS to its official SCOPE OS
in the middle of development.  Viking would not have been the only project
supported by the CDC mainframe and perhaps MMC calculated that the benefits
to other projects which needed SCOPE would outweigh the cost to Viking and
other ongoing projects.
</p>

<p>
Despite MMC not having a Univac 1108, the development, conversion, and testing
of the 1108 software was much smoother than for the IBM software.  Being able
to compile and test the Univac programs at JPL anytime <em>day</em> or night
was probably a significant factor in this.
</p>

<blockquote>
<p>
    QUALITATIVE RESULTS: ...  This occurred in the IBM 360 conversion effort.
    Due to the operational procedures at JPL, in order to receive the necessary
    turnaround time to do program conversion and testing, blocks of computer
    time had to be scheduled.  These blocks of time were usually 4 to 6 hours
    in duration during the week starting at 9:00 PM to 4:00 AM, and up to 48
    hours duration on the weekends.  The pressures of trying to make as many
    runs as possible and meet delivery schedules forced many extra errors into
    the software.  Instead of doing a detailed analysis of the code and the
    dump of the program the programmer or engineer would shot-gun many runs to
    try to fix errors.  During longer block-time stretches many engineers and
    programmers would work until they introduced new errors due to physical and
    mental exhaustion.  This altering of normal work habits did not occur on
    the 1108 conversion effort.  The turnaround was excellent and the machine
    was available for use during normal working hours.  <i>(p. 34)</i>
</p>
<p>
    ...  The JPL version of OS was a real-time system with standard OS features
    but was a different release than the MMC&#39;s IBM OS.  This caused problems in
    the conversion effort.  In one instance the difference in FORTRAN compilers
    between MMC IBM and JPL IBM caused schedule slippages due to errors in the
    target compiler that were not discovered until the conversion process
    began.  This problem happened early in the conversion process and two steps
    were taken to help solve the problems: 1) the release of the compiler JPL
    had was installed at MMC for use by the software still in development and
    2) the release of the MMC compiler was installed at JPL for use when
    needed.  <i>(pp. 34-35)</i>
</p>
<p>
    ...  The operating system [on MMC&#39;s CDC computers] was changed from MACE to
    SCOPE during the period in which the software was being developed.  This
    change caused many schedule impacts in the Viking software development.
    Much time was spent by the development programmers changing their job
    control cards, their file naming conventions, their file structures, and
    in learning how the system worked.  This coupled with extra down time and
    running of two operating systems caused much confusion.
    <i>(p. 35)</i>
</p>
<p>
    QUANTITATIVE IMPACT: ...  The conversion process represented approximately
    five percent of the development effort for 1108 programs, and approximately
    ten percent of the development effort for 360 programs.  <i>(p. 36)</i>
</p>
<details>
<summary>
    Martin Marietta Corporation,
    <cite><a href="https://apps.dtic.mil/sti/pdfs/ADA040770.pdf">Viking
    Software Data: Final Technical Report</a></cite> (15MB PDF)</summary>

    May 1977, RADC-TR-77-168.
</details>
</blockquote>

<p>
I haven&#39;t read Martin Marietta&#39;s report from cover to cover, but I have read
substantial amounts in the operations software and flight software sections.
The prose is not dry and Martin Marietta was honest about what techniques
and practices worked and which didn&#39;t and why.  Again, another
sort-of-Voyager-related-but-not-really document you can dive into
on any page and enjoy.
</p>

<p>
I was unable to find an online copy of 1973&#39;s
&#34;<a href="https://ntrs.nasa.gov/citations/19730000322">Characteristics of
FORTRAN</a>&#34; (download page for brief-description PDF) by W.R. Garner of
Martin Marietta, which detailed the differences between Fortran on the
IBM 360, Univac 1108, and CDC 6000s.  Nor was I able to find a copy of
Martin Marietta&#39;s <cite>Viking Flight Operations Programmer Guide</cite>
(mentioned in the <cite>Viking Software Data</cite> report), which
described the minimal subset of Fortran to be used at MMC.
</p>

<p>
However, I did came across another, slightly later instance of Martin
Marietta converting a Fortran program developed on the CDC 6500 to run
on a Univac 1108.  In this case, the program implemented a contamination
model for the ESA
<a href="https://en.wikipedia.org/wiki/Spacelab">Spacelab</a> flown on
multiple Space Shuttle missions.  The target 1108 was located at NASA&#39;s
Marshall Space Flight Center in Huntsville, AL.  This 1976 requirements
study detailed the differences between FORTRAN IV on the CDC 6500 and
FORTRAN V on the Univac 1108:
</p>

<blockquote>
<p>
    This study was performed in order to determine the modifications necessary
    to convert the Martin Marietta Aerospace (MMA) Spacelab Contamination
    Computer Model, written for a CDC 6500 computer, for use on a Marshall
    Space Flight Center (MSFC) computer ...
</p>
<p>
    Major differences between the CDC 6500 and UNIVAC 1108 are memory capacity,
    word length, and various specific functional capabilities.  The CDC 6500
    uses Fortran IV whereas, the UNIVAC 1108 uses Fortran V control language.
    None of the differences are such as to create any great difficulties in
    program conversion and a good programmer, familiar with the contamination
    program, should be able to process the necessary changes with minimum
    difficulty, knowing the differences.
</p>
<p>
    —L.E. Bareiss, V.W. Hooper, E.B. Ress, and D.A. Strange,
    &#34;<a href="https://ntrs.nasa.gov/citations/19760026161">Payload/Orbiter
    Contamination Control Requirement Study - Computer Interface Study</a>&#34;,
    Final Report, p. ii, September 30, 1976.
</p>
</blockquote>

<hr id="Bibliography"/>



<h2>Bibliography</h2>

<h3 id="EssentialReading">Essential Reading</h3>

<div>
<p>
    I recommend reading Tomayko&#39;s <cite>Computers in Spaceflight</cite>,
    Chapter 6-2 first as knowledge of the Voyager flight computing hardware
    will help when reading the other texts.  Then, Matsumoto&#39;s paper provides
    an excellent overview and details about the current (as of 2016) state
    of the spacecraft and the full range of efforts needed to extend the
    life of the spacecraft as long as possible.
</p>
<p>
    Following those two, I recommend McEvoy&#39;s paper for its detailed
    description of spacecraft command sequencing and CCS simulation for
    the Viking Orbiter.  Adamski&#39;s paper, under &#34;<a href="#OtherSources">Other
    Sources</a>&#34;, covers similar territory for Voyager, with a slightly
    differing focus.  McEvoy&#39;s paper gets down into some of the software
    details, but they&#39;re
    both very interesting, so read both!
</p>
</div>

<div>

<p id="Tomayko">
    Tomayko, James E.
    <cite><a href="https://ntrs.nasa.gov/citations/19880069935">Computers
    in Spaceflight: The NASA Experience</a></cite> (36MB PDF; higher quality
    <a href="https://archive.org/details/nasa_techdoc_19880069935">500MB PDF</a>),
    1988.  The archived, easier-to-navigate HTML version:
</p>
<ul>
<li><a href="https://web.archive.org/web/20230320180456/https://history.nasa.gov/computers/Compspace.html">Title
    Page</a>
</li>
<li><a href="https://web.archive.org/web/20230320180447/https://history.nasa.gov/computers/contents.html">Table
    of Contents</a>
</li>
<li><a href="https://web.archive.org/web/20231123211500/https://history.nasa.gov/computers/Ch5-6.html">Chapter
    Five, Section 6</a>, &#34;Viking computer systems&#34; (details the Orbiter CCS
    computer used for Voyager&#39;s CCS and AACS computers)
</li>
<li><a href="https://web.archive.org/web/20231123211500/https://history.nasa.gov/computers/Ch6-2.html">Chapter
    Six, Section 2</a>, &#34;Voyager - The flying computer center&#34;
</li>
<li><a href="https://web.archive.org/web/20210920045456/https://history.nasa.gov/computers/Ch8-3.html">Chapter
    Eight, Section 3</a>, &#34;Unmanned mission control computers&#34;
</li>
</ul>

<p id="Matsumoto">
    Matsumoto, Sun Kang.
    &#34;<a href="https://arc.aiaa.org/doi/pdf/10.2514/6.2016-2415">Voyager
    Interstellar Mission: Challenges of Flying a Very Old Spacecraft on
    a Very Long Mission</a>&#34; (PDF),
    2016 SpaceOps Conference, Daejeon, Korea.
</p>
<blockquote>
    Matsumoto&#39;s paper was a pleasure to read the first time, but it wasn&#39;t
    until the second read for the purposes of this page that I realized how
    packed it is with information about the Voyager hardware, software, and
    operations.  Aside from the treasure trove of information, the paper
    also gives you a good idea of the kinds of real problems the Voyager
    team has had to deal with over the decades and the many constraints
    under which they diagnose and solve problems.  Some other papers I
    discovered later provide similar insights into the Voyager environment
    in the pre-VIM era (1970s and 1980s): <a href="#Brooks">Brooks</a>;
    <a href="#McLaughlinAndWolff">McLaughlin and Wolff</a>; and
    <a href="#Morris">Morris</a>.  But Matsumoto remains essential reading.
    (<a href="https://voyager.jpl.nasa.gov/share/#group-13">Matsumoto</a>
    is the Voyager Fault Protection and CCS Flight Software Systems Engineer.)
</blockquote>

<p id="McEvoy">
    McEvoy, Maurice B.
    &#34;<a href="https://informs-sim.org/wsc75papers/1975_0054.pdf">Viking
    Orbiter Uplink Command Generation and Validation via Simulation</a>&#34;
    (PDF), The Institute for Operations Research and the Management
    Sciences (INFORMS)
    <cite><a href="https://informs-sim.org/wsc75papers/prog75sim.html">Winter
    Simulation Conference 1975 Conference Proceedings</a></cite>.
</p>
<blockquote>
    McEvoy&#39;s paper was in an important source for me as it supplied much
    needed details about sequencing that I hadn&#39;t found in earlier reading.
    Written and published before the Viking launches, the paper presents a
    refined, sophisticated, mature sequence development and simulation process,
    or so it seemed to me.  I assumed that the Viking experience and many of
    the associated software tools could have been reused on the Voyager project.
    After writing most of this web page, I discovered
    <a href="#Brooks">Brooks</a>&#39;s paper in which he described the somewhat
    chaotic, rough and tumble evolution of Voyager sequencing, both before
    and continuing <em>after</em> launch.  I began to wonder if McEvoy was
    perhaps giving us a distinctly rose-colored view of Viking sequencing.
    Be that as it may, the details about sequences and simulation are no less
    useful.
</blockquote>

</div>


<h3 id="SequencesAndSoftware">Command Sequences &amp; Flight Software</h3>

<div>
<p>
    In addition to Matsumoto&#39;s and McEvoy&#39;s papers immediately above ...
</p>
<p>
    The full texts of papers annotated as &#34;(abstract)&#34; can be found online
    with some effort.
</p>
</div>

<div>

<p id="Adamski">
    Adamski, Terrence P.
    &#34;<a href="https://arc.aiaa.org/doi/10.2514/6.1987-501">Command and Control
    of the Voyager Spacecraft</a>&#34; (abstract),
    American Institute of Aeronautics and Astronautics (AIAA),
    25th AIAA Aerospace Sciences Meeting, March 24-26, 1987, Reno, Nevada.
</p>
<blockquote>
    Adamski&#39;s paper is similar to <a href="#McEvoy">McEvoy</a>&#39;s above.
    Whereas McEvoy gets down into some of the computing details of
    sequencing (e.g., SEQGEN and OSTRAN), Adamski provides a fuller
    overview of the entire sequencing process from initial science
    proposals to the final review and uplink approval of a sequence.
    This bureaucracy, vitally important for the planetary encounters,
    was streamlined and downsized for the interstellar mission, as
    described in <a href="#LinickAndWeld">Linick and Weld</a> below.
    (Adamski was the Voyager Flight Operations Manager.)
</blockquote>

<p id="Brooks">
    Brooks, Robert N., Jr.
    &#34;<a href="https://arc.aiaa.org/doi/10.2514/6.1988-550">The Evolution
    of the Voyager Mission Sequence Software and Trends for Future Mission
    Sequence Software Systems</a>&#34; (abstract), American Institute of
    Aeronautics and Astronautics (AIAA), 26th Aerospace Sciences Meeting,
    January 1988, Reno, NV.
</p>
<blockquote>
    This was a late addition to my reading, unfortunately, tracked down via
    a citation in another paper.  As the title suggests, Brooks recounts
    the pre- and post-launch evolution of the Voyager sequencing process.
    The process presented here is very rough around the edges, in contrast
    to <a href="#McEvoy">McEvoy</a>&#39;s smoothly functioning, Viking Orbiter
    sequencing process.  Brooks does go into considerable detail about the
    Univac-based sequencing software.  I was delighted to discover that the
    sequence engineers, like any good engineers, wrote unofficial programs
    to assist in their analysis and design of sequences — in
    BASIC!  Being interpreted, these programs were convenient to use and
    modify and, equally importantly, they were invisible to the POISON
    program!  POISON scanned the computer, looking for unofficial programs
    in an attempt to ensure that only officially sanctioned software was
    used to produce uplink loads.  The penultimate section in the paper
    discusses JPL&#39;s research into a role for AI in sequence design and
    development, something that would not be out of place in the 2020s!
    (And was not out of place in the 1980s either.)
</blockquote>

<p id="LinickAndWeld">
    Linick, Susan H. and Weld, Kathryn R.
    &#34;<a href="https://ntrs.nasa.gov/citations/19940019397">Voyager Uplink
    Planning in the Interstellar Mission Era</a>&#34;, <cite>SpaceOps 1992:
    Proceedings of the Second International Symposium on Ground Data Systems
    for Space Mission Operations</cite>, March 1, 1993.
    (<a href="https://ntrs.nasa.gov/api/citations/19940019397/downloads/19940019397.pdf">PDF</a>)
</p>
<blockquote>
    Although over 30 years old now, this paper provides a more modern look
    at Voyager sequencing, especially the move off of the Univac mainframes
    onto PCs and, because of the reduced workforce, the streamlining of the
    sequencing process.  Linick and Weld do get into some of the details of
    the technical challenges and constraints, but the paper strikes me as
    mostly a management view of the redesign that, understandably because
    it&#39;s not the focus of the paper, lacks the hardware and software details
    I would have liked.
</blockquote>

<p id="McLaughlinAndWolff">
    McLaughlin, W.I. and Wolff, D.M.
    &#34;<a href="https://arc.aiaa.org/doi/abs/10.2514/6.1985-287">Voyager Flight
    Engineering: Preparing for Uranus</a>&#34; (abstract), American Institute of
    Aeronautics and Astronautics (AIAA), 23rd Aerospace Sciences Meeting,
    January 1985, Reno, NV.
</p>
<blockquote>
    This paper explores some of the flight software and sequencing changes
    planned for <cite>Voyager 2</cite>&#39;s 1986 Uranus fly-by.  Other papers
    describe sequencing in fairly general terms, but McLaughlin and Wolff
    examine actual, concrete problems and proposed solutions in detail.
    The paper covers a number of areas, but a few stood out for me:
    (1) working around the reliance on <cite>Voyager 2</cite>&#39;s partially
    failed backup radio receiver; (2) offloading image compression duties
    to the backup FDS computer; (3) figuring out how usable the scan
    platform&#39;s crippled actuator was; and (4) preventing image smear
    during the long exposure times required for Uranus and Neptune.
    Another item of interest to me: flight software was written to
    alleviate the CCS computer&#39;s limited memory by storing not-yet-needed
    sequences in the FDS memory.  Since this paper was written pre-encounter,
    I can&#39;t tell if this capability was ever uploaded and used.
</blockquote>

<p id="Morris">
    Morris, Ray B.
    &#34;<a href="https://arc.aiaa.org/doi/10.2514/6.1986-2111">Sequencing
    Voyager II for the Uranus Encounter</a>&#34; (abstract),
    American Institute of Aeronautics and Astronautics (AIAA),
    Astrodynamics Conference, August 1986, Williamsburg, VA.
</p>
<blockquote>
    Like the others, Morris&#39;s paper also describes the sequencing and
    simulation process.  Where Morris really comes into his own is when
    he delves into the operational limitations of sequences and how the
    Voyager team worked around them.  A very important example is that
    the pre-planned, planetary encounter sequences must be uplinked
    before the flyby, but must be able to be updated as observations
    closer to the planet provide more accurate information and reveal
    needed changes.  This requirement was met by the introduction of
    <i>movable blocks</i> for the observations and <i>late stored
    updates</i>.  I&#39;m not sure I understand them completely, but you
    get the idea.  (Morris was the Voyager Flight Engineering Office
    Sequence Team Chief.)
</blockquote>

</div>


<h3 id="OtherSources">Other Sources</h3>

<div>
<p>
    I encountered a lot of articles online that were reworkings either of
    Mann&#39;s 2013 <cite>Wired</cite> article or of Wenz&#39;s 2015 <cite>Popular
    Mechanics</cite> article.  I haven&#39;t included them here unless I
    specifically reference them in this piece.
</p>
<p>
    The full texts of papers annotated as &#34;(abstract)&#34; can be found online
    with some effort.
</p>
</div>

<div>

<p id="Autonomous">
    <cite>Assessment of Autonomous Options for the DSCS III Satellite
    System</cite>, Prepared for the U.S. Air Force by JPL personnel
    (Donna L. S. Pivirotto and Michael Marcucci?),
    &#34;<a href="https://apps.dtic.mil/sti/tr/pdf/ADA106064.pdf">Volume III:
    Options for Increasing the Autonomy of the DSCS III Satellite</a>&#34;
    (8MB PDF), August 6, 1981.
</p>

<p id="Bareiss">
    Bareiss, L.E.; Hooper, V.W.; Ress, E.B.; and Strange, D.A.
    &#34;<a href="https://ntrs.nasa.gov/citations/19760026161">Payload/Orbiter
    Contamination Control Requirement Study - Computer Interface Study</a>&#34;,
    Final Report, September 30, 1976.
</p>
<blockquote>
    Not Voyager-related; quoted in <a href="#ClashOfVikings">Clash of
    Viking Mainframes</a>.
</blockquote>

<p id="Campbell">
    Campbell, James K.; Synnott, Stephen P.; and Bierman, Gerald J.
    &#34;<a href="http://users.cecs.anu.edu.au/~Jonghyuk.Kim/teaching/KF%20Voyager.pdf">Voyager
    Orbit Determination at Jupiter</a>&#34; (PDF), <cite>IEEE Transactions on
    Automatic Control</cite>, Vol. AC-28, No. 3, March 1983.
</p>

<p id="Culver">
    Culver, John.
    &#34;<a href="https://www.cpushack.com/space-craft-cpu.html">The CPUs of
    Spacecraft Computers in Space</a>&#34;, The CPU Shack.
</p>

<p>
    Data General
    <a href="http://www.novasareforever.org/dgdocs/index.php">Fortran 5
    Documentation</a>, including the
    <cite><a href="http://www.novasareforever.org/archive/public/docs/dg/sw/lang/fortran5/093-000085-04__FORTRAN_5_Reference_Manual__1978.pdf">Fortran 5
    Reference Manual</a><cite> (10MB PDF).
</cite></cite></p>

<p id="Eickhoff">
    Eickhoff, Jens.  <cite>Onboard Computers, Onboard Software and Satellite
    Operations</cite>, 2012.  Chapter 3.2.2, &#34;Transistor based OBCs with
    CMOS Memory: The Voyager 1/2 Missions&#34;, pp. 35-37.
</p>

<p id="Gugliotta">
    Gugliotta, Guy.
    &#34;<a href="https://www.washingtonpost.com/archive/politics/2005/04/04/historic-voyager-mission-may-lose-its-funding/ef2451c9-8b38-49ca-a0be-745b78cb06e2/">Historic
    Voyager Mission May Lose Its Funding</a>&#34;, <cite>The Washington Post</cite>,
    April 3, 2005.
</p>

<p id="Heacock">
    Heacock, Raymond L.
    &#34;<a href="https://journals.sagepub.com/doi/10.1243/PIME_PROC_1980_194_026_02">The
    Voyager Spacecraft</a>&#34; (abstract),
    <cite>Proceedings of the Institution of Mechanical Engineers</cite>,
    Vol. 194, June 1980.
</p>
<blockquote>
    Heacock&#39;s paper is widely cited because it provides a concise, readable,
    detailed description of the components on the spacecraft, excluding the
    science instruments.  He includes some history of the mission and the
    reasoning behind some of the component/configuration designs.
</blockquote>

<p id="HolmbergFaustAndHolt">
    Holmberg, Neil A.; Faust, Robert P.; and Holt, H. Milton.
    <cite><a href="https://ntrs.nasa.gov/citations/19810001593">Viking &#39;75
    Spacecraft Design and Test Summary, Volume II: Orbiter Design</a></cite>
    (NASA Reference Publication 1027), November 1980.  (Download page for
    13MB PDF)
</p>

<p id="Kehr">
    Kehr, Joachim J.
    &#34;<a href="https://www.opsjournal.org/DocumentLibrary/Uploads/TheRightStaff_VoagerOps_JK_comments_final.pdf">Voyager —
    The Right Staff</a>&#34; (PDF), April 2016.  Kehr was the editor of
    <cite>SpaceOps News</cite>, of the <cite>Journal of Space Operations
    &amp; Communicator</cite>; this article was apparently not published.
</p>

<p id="Kobele">
    Kobele, P.
    &#34;<a href="https://arc.aiaa.org/doi/abs/10.2514/6.1989-5070">Maintainability
    of Unmanned Planetary Spacecraft: A JPL Perspective</a>&#34; (abstract),
    American Institute of Aeronautics and Astronautics (AIAA)/NASA
    Maintainability of Aerospace Systems Symposium, July 1989, Anaheim, CA.
</p>
<blockquote>
<p>
    Kobele examines how anomalous conditions are/were handled in the Mars
    Viking Orbiter, Voyager, and the Jupiter
    <a href="https://en.wikipedia.org/wiki/Galileo_project">Galileo</a>
    Orbiter.  (<cite>Galileo</cite> hadn&#39;t been launched yet at the time
    of publication.)  Whereas the continuation of science observations has
    been a priority for Voyager when an anomaly occurs, the philosophy
    on <cite>Galileo</cite> was to put the spacecraft in a stable
    configuration (&#34;safe hold&#34;) and await instructions from the ground.
    Since <cite>Galileo</cite> was an orbiter, it made sense to postpone
    science observations to later orbits and instead protect the health
    of the spacecraft.
</p>
<p>
    Kobele describes notable Viking and Voyager anomalies, but, again,
    <cite>Galileo</cite> had yet to be launched and anomalies like the
    failed deployment of the high-gain antenna were still in the future.
    The paper finishes up with an in-depth look at &#34;lessons learned&#34;,
    which is quite good.
</p></blockquote>

<p id="Kohlhase">
    Kohlhase, Charles.
    <cite><a href="https://ntrs.nasa.gov/citations/19900004096">The Voyager
    Neptune Travel Guide</a></cite>, 1989.  (Download page for 116MB PDF)
</p>
<blockquote>
<p>
    A late addition ...  This is a beautiful 290-page book, even in its
    black-and-white PDF form, written in an easy-going, engaging style.
    The purpose of the book is to get the reader excited about <i>(i)</i>
    the wonders of space and <i>(ii)</i> the wonders of the technology
    used to explore space.  It&#39;s aimed at the educated layperson.  Some
    familiarity with space and spacecraft probably helps, but I think a
    neophyte could just accept what they don&#39;t understand and still revel
    in the wonder of it all.  I&#39;ve only read the first 40 pages and I
    learned a lot; for example, one of the reasons the scan platform is
    mounted on a boom is so that, post-encounter, the cameras can look
    back at a receding planet without their view being blocked by the
    high-gain antenna.  Fascinating!
</p>
<p>
    The hard-copy version of the book features a flip-book animation of the
    Neptune/Triton encounter.  Someone with patience could snip the
    approximately 130 graphics from the PDF and produce an animated GIF.
    (<a href="https://voyager.jpl.nasa.gov/share/#group-8">Kohlhase</a>
    was Manager of Voyager Mission Analysis and Engineering.)
</p>
</blockquote>

<p id="Laeser">
    Laeser, Richard P.
    &#34;<a href="https://www.sciencedirect.com/science/article/abs/pii/0094576586901207">Voyager —
    Uranus at Our Doorstep</a>&#34; (abstract),
    <cite>Acta Astronautica</cite>, Volume 14, 1986.
</p>
<blockquote>
    This paper turned out to not be pertinent to my Fortran 5 inquiry,
    but it is nevertheless a very interesting read.  Laeser goes into good
    detail about two serious <cite>Voyager 2</cite> problems with the
    spacecraft&#39;s radio receivers and the scan platform, describing how
    the engineers figured out what the problems were and how to work
    around them.  (Laeser also wrote a similar, somewhat complementary paper,
    &#34;<a href="https://www.sciencedirect.com/science/article/abs/pii/0094576587900968">Engineering
    the Voyager Uranus Mission</a>&#34;.)
</blockquote>

<p id="LudwigAndTaylor">
    <a href="https://descanso.jpl.nasa.gov/biography/ludwig.html">Ludwig,
    Roger</a> and
    <a href="https://descanso.jpl.nasa.gov/biography/taylor.html">Taylor,
    Jim</a>.
    &#34;<a href="https://descanso.jpl.nasa.gov/DPSummary/Descanso4--Voyager_new.pdf">Voyager
    Telecommunications</a>&#34; (3MB PDF), Article 4, March 2002, of
    <cite><a href="https://descanso.jpl.nasa.gov/DPSummary/summary.html">JPL DESCANSO Design &amp; Performance
    Summary Series</a></cite>.
</p>
<blockquote>
    A number of other sources also describe <cite>Voyager 2</cite>&#39;s receiver
    problem, but this paper about Voyager radio communications provides more
    radio- and electronics-focused details (pp. 39-40).  Other sources also
    give slightly different numbers for the 100-KHz and 100-Hz PLL ranges,
    but they all round off to Ludwig&#39;s and Taylor&#39;s values, so I use the
    latter in the text of my web page.  Telecommunications-specific actions
    in the Backup Mission Load (BML) are detailed on p. 41.
</blockquote>

<p id="Magnin">
    Magnin, Vincent.
    &#34;<a href="https://fortran-lang.discourse.group/t/a-patch-was-sent-to-voyager-2-yesterday/6670">A
    patch was sent to Voyager 2 yesterday</a>&#34;, <cite>Fortran Discourse</cite>,
    October 2023.
</p>
<blockquote>
    Throughout this discussion on a Fortran forum, Magnin provided useful
    commentary and links to sources, some in common with mine and others new
    to me.  <em>Aside:</em> Browsing the
    <cite><a href="https://fortran-lang.discourse.group/">Fortran
    Discourse</a></cite> forum was very enlightening for me.  I had read about
    Fortran 90 when its standard was released over 30 years ago, but I had no
    occasion to use it and I haven&#39;t kept up with subsequent versions.  It&#39;s
    changed!  My hat&#39;s off to modern-day Fortran developers.  (Although we
    were no slouches back in the heady days of VAX/VMS Fortran-77.)
</blockquote>

<p id="Mann">
    Mann, Adam.
    &#34;<a href="https://www.wired.com/2013/09/vintage-voyager-probes/">Interstellar
    8-Track: How Voyager&#39;s Vintage Tech Keeps Running</a>&#34;, <cite>Wired</cite>,
    September 2013.
</p>

<p id="MartinMarietta">
    Martin Marietta Corporation.
    <cite><a href="https://apps.dtic.mil/sti/pdfs/ADA040770.pdf">Viking
    Software Data: Final Technical Report</a></cite> (15MB PDF), May 1977,
    RADC-TR-77-168.  Of interest: &#34;Mission Operations Software Techniques&#34;
    (ground system), pp. 4-101 and &#34;Flight Software Techniques&#34; (Lander only),
    pp. 102-159.
</p>
<blockquote>
    Not Voyager-related; inspiration for <a href="#ClashOfVikings">Clash of
    Viking Mainframes</a>.
</blockquote>

<p id="COSMIC-ODP">
    NASA.
    &#34;<a href="https://books.google.com/books?id=TeKWdD4nHCYC&amp;pg=PA33&amp;lpg=PA33#v=onepage&amp;q&amp;f=false">Calculating
    Trajectories and Orbits</a>&#34;, <cite>NASA Tech Briefs</cite>, September 1989,
    p. 33.  (COSMIC catalog entry for the Orbit Determination Program.)
</p>

<p id="VoyagerPressKit">
    NASA.
    <cite><a href="http://planetary.s3.amazonaws.com/assets/presskit/voyager-launch.pdf">Voyager
    Press Kit</a></cite> (6MB PDF), August 4, 1977.  (Pre-launch)
</p>

<p id="PatelReinholtzAndRobison">Patel, K.; Reinholtz, W.; and Robison, W.
    &#34;<a href="https://adsabs.harvard.edu/full/1996ESASP.394..749P">High
    Speed Simulator — A Simulator for All Seasons</a>&#34;
    (<a href="https://articles.adsabs.harvard.edu/cgi-bin/nph-iarticle_query?1996ESASP.394..749P&amp;defaultprint=YES&amp;filetype=.pdf">PDF</a>),
    <cite>SpaceOps 1996, Proceedings of the Fourth International
    Symposium</cite>, Munich, Germany.
</p>

<p id="RealProgrammers">
    Post, Ed.
    &#34;<a href="https://www.ecb.torontomu.ca/~elf/hack/realmen.html">Real
    Programmers Don&#39;t Use Pascal</a>&#34;, <cite>Datamation</cite>, July 1983,
    &#34;READERS&#39; FORUM&#34;, pp. 263-265.
    (HTML version; the
    <a href="http://www.bitsavers.org/magazines/Datamation/198307.pdf">full
    magazine issue</a> is available as a 51MB PDF.)
</p>

<p id="RasmussenAndLitty">
    Rasmussen, R.D. and E.C. Litty.
    &#34;<a href="https://arc.aiaa.org/doi/10.2514/6.1981-1812">A Voyager Attitude
    Control Perspective on Fault Tolerant Systems</a>&#34; (abstract),
    American Institute of Aeronautics and Astronautics (AIAA)
    <cite>Guidance and Control Conference</cite>, August 19-21, 1981,
    Albuquerque, New Mexico.
</p>
<blockquote>
    The above is a very interesting paper about fault detection, isolation,
    and management on the Voyager spacecraft, with a special focus on the
    AACS.  It does get into some of the details about cross-strapping,
    about which I posed questions in
    &#34;<a href="#SequencesAndSimulators">Sequences and Simulators</a>&#34; above.
</blockquote>

<p id="Sharwood">
    Sharwood, Simon.
    &#34;<a href="https://www.theregister.com/2015/10/30/has_voyager_1_escaped_the_sun_yet_yes_but_also_no_say_boffins/">Has
    Voyager 1 escaped the Sun yet? Yes, but also no, say boffins</a>&#34;,
    <cite>The Register</cite>, October 30, 2015.
</p>

<p id="SFSA">
    <a href="https://www.sfsa.org.au/">South Australian Doctor Who
    Fan Club Inc.</a> (SFSA), &#34;Voyagers disco party!&#34;,
    <cite>The Wall of Lies</cite>, No. 169, Nov-Dec 2017, p. 2.
    (<a href="https://efanzines.com/WOL/WOL169.pdf">4-page newsletter</a>,
    PDF)
</p>

<p id="Tingley">
    Tingley, Kim.
    &#34;<a href="https://www.nytimes.com/2017/08/03/magazine/the-loyal-engineers-steering-nasas-voyager-probes-across-the-universe.html">The
    Loyal Engineers Steering NASA&#39;s Voyager Probes Across the Universe</a>&#34;,
    <cite>New York Times</cite>, August 3, 2017.
</p>

<p id="1108SystemDescription">
    <cite><a href="https://bitsavers.org/pdf/univac/1100/1108/UP-4046r3_UNIVAC_1108_System_Description_1970.pdf">UNIVAC
    1108 System Description</a></cite> (14MB PDF), 1970.  (FORTRAN V
    description in Section 10, pp. 7-12.)
</p>

<p>
    <cite>UNIVAC 1108 FORTRAN V Programmer&#39;s Reference Manual</cite>, 1966,
    <a href="https://www.computerhistory.org/collections/catalog/102799051">Artifact
    Details</a> (not the actual manual) at the Computer History Museum.
</p>

<p>
    Univac <cite><a href="https://bitsavers.org/pdf/univac/1100/fortran/">ASCII
    FORTRAN Reference Manual</a></cite> (download page for 65MB PDF).
</p>

<p id="VikingProjectHearings">
    <cite>Viking project hearings before the Subcommittee on Space Science
    and Applications</cite> &#34;of the Committee on Science and Astronautics,
    U.S. House of Representatives, Ninety-third Congress, second session,
    November 21, 22, 1974 [i.e. 1975]&#34;,
    &#34;<a href="https://babel.hathitrust.org/cgi/pt?id=mdp.39015081145552&amp;seq=183">Flight
    Software Technical Problems</a>&#34;.
</p>
<blockquote>
    The link above takes you to the beginning of a set of slides about the
    flight software, which is how I discovered this hearing.  Don&#39;t limit
    yourself to that brief presentation — random browsing in the
    document will land you on interesting testimony by NASA personnel and
    exchanges with congressmen.
</blockquote>

<p id="Wenz">
    Wenz, John.
    &#34;<a href="https://www.popularmechanics.com/space/a17991/voyager-1-voyager-2-retiring-engineer/">Why
    NASA Needs a Programmer Fluent in 60-Year-Old Languages</a>&#34;,
    <cite>Popular Mechanics</cite>, October 29, 2015.
</p>

<p id="Wood">
    Wood, Lincoln J.
    <a href="https://descanso.jpl.nasa.gov/evolution/AAS_08-051.pdf">The
    Evolution of Deep Space Navigation: 1962-1989</a>&#34; (PDF),
    31<sup><small>st</small></sup> Annual AAS Guidance and Control Conference,
    2008, Breckenridge, Colorado.
</p>

<p id="Zierler">
    Zierler, David.
    &#34;<a href="https://heritageproject.caltech.edu/interviews-updates/suzy-dodd">Suzy
    Dodd (BS &#39;84), Engineer and Deep Space Pioneer</a>&#34;,
    Caltech Heritage Project, June 9, 2023.
</p>

<p>
    Wikipedia (abridged list).  There is actually a whole forest of Wikipedia
    pages I used, following links here and there, but these are a few of the
    main ones:
</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Data_General">Data General</a>
    and <a href="https://en.wikipedia.org/wiki/Data_General_Nova">DG Nova</a>
</li>
<li><a href="https://en.wikipedia.org/wiki/Fortran">Fortran</a>
</li>
<li><a href="https://en.wikipedia.org/wiki/Viking_program">Viking program</a>
</li>
<li><a href="https://en.wikipedia.org/wiki/Voyager_program">Voyager program</a>
</li>
<li><i><a href="https://en.wikipedia.org/wiki/Voyager_1">Voyager 1</a></i>
</li>
<li><i><a href="https://en.wikipedia.org/wiki/Voyager_2">Voyager 2</a></i>
</li>
</ul>

<ul>
<li><a href="https://en.wikipedia.org/wiki/Control_Data_Corporation">Control
    Data Corporation</a>,
    <a href="https://en.wikipedia.org/wiki/CDC_6000_series">CDC 6000 series</a>,
    and <a href="https://en.wikipedia.org/wiki/CDC_display_code">CDC
    display code</a>
</li>
<li><a href="https://en.wikipedia.org/wiki/IBM">IBM</a>,
    <a href="https://en.wikipedia.org/wiki/IBM_System/360">360</a>,
    <a href="https://en.wikipedia.org/wiki/IBM_System/370">370</a>,
    and <a href="https://en.wikipedia.org/wiki/EBCDIC">EBCDIC</a>
</li>
<li><a href="https://en.wikipedia.org/wiki/UNIVAC">UNIVAC</a>,
    <a href="https://en.wikipedia.org/wiki/UNIVAC_1100/2200_series">1100/2200 series</a>,
    and <a href="https://en.wikipedia.org/wiki/Fieldata#UNIVAC">FIELDATA</a>
</li>
</ul>

</div>


<h3 id="Multimedia">Multimedia!</h3>

<p>
    I believe Aaron Cummings&#39;s YouTube video showed up in search results
    when I was looking up information about the Voyager computers.  I
    learned about the two movies (and lots of other information) from
    the <cite>Ars Technica</cite> community.
</p>

<div>

<p id="Cummings">
    Cummings, Aaron.
    &#34;<a href="https://www.youtube.com/watch?v=H62hZJVqs2o">Uptime 15,364
    days - The Computers of Voyager</a>&#34; (YouTube), Strange Loop Conference,
    September 14, 2019.
</p>
<blockquote>
    A video of a 30-minute presentation followed by a 10-minute Q&amp;A
    session.  A great speaker and my only complaint is that the presentation
    wasn&#39;t longer.  I didn&#39;t really find out anything new about the computers
    since Cummings drew from many of the same sources as me, but there was a
    lot of information about the mission history, hardware, and communications
    that I found very interesting.  He noted the lack of information about the
    flight software.  Also, people had told him the flight software was in
    Fortran, but he didn&#39;t buy it (at 17:21 in the videos).  His
    <a href="https://github.com/aaroncummings/strange-loop-2019/blob/master/references.md">reference
    list</a> has additional links to a variety of information about the
    spacecraft and mission.
</blockquote>

<p id="Farthest">
    <cite><a href="https://www.tangledbankstudios.org/our-films/farthest">The
    Farthest</a></cite>
    (<a href="https://www.imdb.com/title/tt6223974/">IMDB</a>), 2017.
    (<a href="https://www.pbs.org/the-farthest/">Watch on PBS</a>)
</p>
<blockquote>
    A 90-minute documentary film about the Voyager program.  In contrast
    to the present-day focus of <cite>It&#39;s Quieter in the Twilight</cite>,
    this movie documents the early years of the program and the four
    planetary encounters: Jupiter, Saturn, Uranus, and Neptune.  (The
    film does take a brief look at the interstellar mission towards the
    end.)  There&#39;s a lot of contemporary news and science footage and
    a lot of looking-back commentary from people who&#39;d been with the
    project since the beginning.  This movie documents the science and
    technology of Voyager, whereas <cite>It&#39;s Quieter in the Twilight</cite>
    is a lower-key recording of the everyday life of the current Voyager team.
    The former gives the big picture and the latter provides some insight into
    the unglamorous world of maintaining two spacecraft more than 10 billion
    miles away.  Watch both!
</blockquote>

<p id="ItsQuieterInTheTwilight">
    <cite><a href="https://www.itsquieterfilm.com/">It&#39;s Quieter
    in the Twilight</a></cite>
    (<a href="https://www.imdb.com/title/tt17658964/">IMDB</a>), 2022.
</p>
<blockquote>
<p>
    An 80-minute documentary film about the Voyager team prior to and into
    the 2020 COVID-19 pandemic.  They worked in a garden-office complex next
    to a McDonald&#39;s, about a mile from the JPL campus.  (And had been doing
    so for a couple of decades?)  During the pandemic, their offices were
    moved back to JPL.
</p>
<p>
    After the Neptune encounter, <cite>Voyager 2</cite> angled south of the
    ecliptic (planetary) plane as it headed out into space.  As a result,
    the spacecraft can only be &#34;seen&#34; from the Australian Deep Space Network
    (DSN) station and commands can only be sent to <cite>Voyager 2</cite>
    using that station&#39;s 70-meter dish antenna.  An
    <a href="https://www.space.com/voyager-2-on-its-own-nasa-deep-space-network-upgrades.html">11-month-long,
    major upgrade</a> to the aging antenna was scheduled to begin in
    February 2020.  During the upgrade, commands could not be sent to
    <cite>Voyager 2</cite>, but smaller antennas were available for
    receiving engineering and science data from the spacecraft.
    A good part of the film revolves around the preparations of
    <cite>Voyager 2</cite> for this downtime and then the downtime
    itself.  Some unexpected and unwanted drama occurred right before
    the upgrade when a
    <a href="https://www.centauri-dreams.org/2020/01/30/voyager-2-recovers/">routine
    &#34;MAG roll&#34; went awry</a>.  NASA admirably delayed the upgrade until March
    so the Voyager team could figure out what had happened and successfully
    finish preparing <cite>Voyager 2</cite> for 11 months of command-less
    travel.  A
    <a href="https://www.centauri-dreams.org/2020/11/05/voyager-2-back-in-two-way-communication/">test
    transmission</a> or transaction of some kind was made in October 2020
    prior to the 70-m dish returning to
    <a href="https://www.theregister.com/2021/02/15/voyager_2_executes_commands_again/">full
    operational status</a> in February 2021.
</p>
</blockquote>

</div>

<!-- $Id: trailer.txt,v 1.2 2011/05/21 11:55:11 alex Exp $ -->





</div>
  </body>
</html>
