<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://johnj.com/posts/l1/">Original</a>
    <h1>(Yet Another) Lisp in Go</h1>
    
    <div id="readability-page-1" class="page"><div>





<p>

<a href="http://johnj.com/tags/code"><span>code</span></a>

<a href="http://johnj.com/tags/lisp"><span>lisp</span></a>

<a href="http://johnj.com/tags/clojure"><span>clojure</span></a>

  ..... <em><time datetime="2022-03-27T00:00:00Z">
      March 27, 2022
    </time></em>
</p>



<p>




<a href="http://johnj.com/l1.jpg"><img src="http://johnj.com/l1_huf7f11b13a3e48adcf8255b6a4ba1e0f5_1592483_700x0_resize_q75_box.jpg"/></a>

</p>
<p>
For the past month I&#39;ve been spending some free time writing another
Lisp implementation, this time in Go.  <a href="http://johnj.com/posts/scheme-in-python/">My previous attempt</a> was a
subset of Scheme made in preparation for a class on the classic
<a href="https://mitpress.mit.edu/sites/default/files/sicp/index.html">Structure and Interpretation of Computer Programs</a>.  That project
was great fun and I learned a lot.</p>
<p>
I started learning Go late last year and began thinking about writing
another Lisp.  Go has garbage collection, a feature that has long
been an essential part of most Lisps.
Getting GC essentially for free would save a lot of time and effort.</p>
<p>
Go is also extremely fast. For applications where startup performance is
not an issue, I&#39;m pretty happy with Clojure most of the time.  But
working with Common Lisp in recent years, and Go more recently, has
spoiled me and made me hungry for more performance, especially for
short-running command-line utilities.</p>
<p>
There are obviously other Lisps written in Go already, including
<a href="https://github.com/candid82/joker">Joker</a>, a Clojure interpreter and linter.  But I wasn&#39;t particularly
interested with implementing a particular Lisp dialect; rather, I
wanted to try to implement a language core that one could extend in a
variety of different directions, including <a href="http://www.paulgraham.com/rootsoflisp.html">implementing the language
in itself</a>.  Other possible directions include graphics programming,
text-based games, and scripting. The working name of this Lisp is <code>l1</code>
(&#34;el-one&#34;), hinting at a possible series of small, experimental Lisps.</p>
<div id="outline-container-headline-1">
<h2 id="headline-1">
Features
</h2>
<div id="outline-text-headline-1">
<p>
Here is a summary of what&#39;s implemented &amp; planned:</p>
<table>
<thead>
<tr>
<th>l1 has</th>
<th>doesn&#39;t have</th>
<th>will have</th>
<th>might get</th>
</tr>
</thead>
<tbody>
<tr>
<td>integers (<a href="https://stackoverflow.com/questions/17564335/golang-math-big-what-is-the-max-value-of-big-int">essentially unlimited size</a>)</td>
<td>keywords</td>
<td>macros</td>
<td>curses</td>
</tr>
<tr>
<td>comments (<code>;; ....</code>)</td>
<td>maps</td>
<td>syntax quote</td>
<td>graphics</td>
</tr>
<tr>
<td>atoms</td>
<td>strings</td>
<td>reader macros (`, &#39;, …)</td>
<td>subprocess / shells</td>
</tr>
<tr>
<td>lists</td>
<td>namespaces</td>
<td>REPL / editor integration</td>
<td>big floats</td>
</tr>
<tr>
<td>4 special forms: <code>cond</code>, <code>def</code>, <code>lambda</code>, <code>quote</code></td>
<td>exceptions</td>
<td><code>let</code> (as a macro)</td>
<td><code>error</code> equiv.</td>
</tr>
<tr>
<td>16 built-in functions</td>
<td>loops</td>
<td><code>defun</code> / <code>defn</code> (as a macro)</td>
<td>tail call optimization</td>
</tr>
<tr>
<td>recursion</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>closures</td>
<td></td>
<td></td>
<td>byte code compilation/interpretation</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-headline-2">
<h2 id="headline-2">
Performance
</h2>
<div id="outline-text-headline-2">
<p>
The <a href="https://github.com/eigenhombre/l1/">current implementation is on GitHub</a>.  Its speed surprises me a bit.</p>
<p>
Consider the following program in <code>l1</code>, which computes a factorial:</p>
<div>
<div><pre tabindex="0"><code data-lang="text">;; fact.l1: Return the factorial of `n`:
(def fact
     (lambda (n)
       (cond ((eq 0 n) 1)
             (t (* n (fact (- n 1)))))))

(print (fact 100))</code></pre></div>
</div>
<p>outputting</p>
<div>
<div><pre tabindex="0"><code data-lang="text">933262154439441526816992388562667004907159682643816214685929638
952175999932299156089414639761565182862536979208272237582511852
10916864000000000000000000000000</code></pre></div>
</div>
<p>
Its equivalent in Clojure (or its nimble alternative implementations,
Babashka or Joker) can be written as follows:</p>
<div>
<div><pre tabindex="0"><code data-lang="text">;; fact.clj: Return the factorial of `n`:
(def fact
  (fn [n]
    (cond (= 0 n) 1
          :else (*&#39; n (fact (- n 1))))))

(println (fact 100))</code></pre></div>
</div>
<p>… and in my Python Scheme implementation as</p>
<div>
<div><pre tabindex="0"><code data-lang="text">;; fact.scm
(define (fact n)
  (if (= n 1)
      1
      (* n (fact (- n 1)))))

(display (fact 100))</code></pre></div>
</div>
<p>
The execution times break down thusly:</p>
<table>
<thead>
<tr>
<th>Language</th>
<th>Running It</th>
<th>Execution Time (ms)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Clojure</td>
<td><code>clojure -M fact.clj</code></td>
<td>1729</td>
</tr>
<tr>
<td>Babashka</td>
<td><code>bb fact.clj</code></td>
<td>200</td>
</tr>
<tr>
<td><code>smallscheme</code></td>
<td><code>scheme.py fact.scm</code></td>
<td>120</td>
</tr>
<tr>
<td>Joker</td>
<td><code>joker fact.clj</code></td>
<td>59</td>
</tr>
<tr>
<td><code>l1</code></td>
<td><code>l1 fact.l1</code></td>
<td>8</td>
</tr>
</tbody>
</table>
<p>
Note that <code>l1</code> is a tree-walking interpreter; I wonder what the speed
might be possible if implemented with a byte code interpreter.</p>
</div>
</div>
<div id="outline-container-headline-3">
<h2 id="headline-3">
Lexing
</h2>
<p>
I started the journey by writing the lexer.  A post on Hacker News led me
to <a href="https://www.youtube.com/watch?v=HxaD_trXwRE">this video</a> where Rob Pike, of the core Go language team, describes
an elegant design for a lexer used in the Go templating library.  I
was able to extract the relevant bits into a fairly <a href="https://github.com/eigenhombre/lexutil/">general-purpose
library</a> that I then used for this Lisp with <a href="https://github.com/eigenhombre/l1/blob/master/lex.go">relatively little code</a> (of
course, one shouldn&#39;t expect too much code when lexing a Lisp, since
there is not much syntax).</p>
</div>
<div id="outline-container-headline-4">
<h2 id="headline-4">
Fun With Atoms and Lists
</h2>
<div id="outline-text-headline-4">
<p>
You may have noticed the lack of character strings in the feature
table, above.  <a href="https://github.com/norvig/paip-lisp">Many interesting Lisp programs</a> don&#39;t use traditional
strings (arrays of characters encoded as bytes), and I am curious to
see what can be done strictly without them, though I could see adding
them at some point.</p>
<p>
Without strings, one will probably want to manipulate atoms in various
ways.  As a start, <code>l1</code> introduces the notion of &#34;splitting&#34; (creating
a list from an atom or number) and &#34;fusing&#34; (joining such a list back
together again):</p>
<div>
<div><pre tabindex="0"><code data-lang="text">&gt; (split (quote greenspun))
(g r e e n s p u n)
&gt; (split 1395871)
(1 3 9 5 8 7 1)
&gt; (fuse (quote (1 2 3 4 5)))
12345
&gt; (randigits 10)
(6 1 5 4 4 8 8 3 0 1)
&gt; (randigits 10)
(2 7 5 4 7 9 1 6 6 1)
&gt; (fuse (randigits 1000))
797522288353215977146173184650097900747324790200919947108552266
896559408664559755127840959435738695979408193086120089317097735
733247509700258597497415541421859295990446300938230591278544826
160148998280910399112793807480556810085222871423786728939605143
312291343715625109027024093962060686621901049553518883581864852
832439160531395519838325036388642484613231265974048363263732041
737675913066537856875008449087672272329301144164887429770199070
521721230755123684155760268379043481645391533460833091119801604
531684362848585264816725347753593965869286499060052823295397069
598147167103689429912992818647290966641807288375144076084638850
885562168375457674623070776900707693203757775691854059277861315
130019383408298242102129643369889134587749005021251080452606062
217504938911721968545635428643266561957454859338694605115003758
001930119736513921576952435852918640253473323143920762789645830
700672642264667728965761815048634636071828415705273836146286590
4892309215088593977646507232497245814663081971549675531
&gt;</code></pre></div>
</div>
</div>
</div>
<div id="outline-container-headline-5">
<h2 id="headline-5">
Testing
</h2>
<div id="outline-text-headline-5">
<p>
As with previous Lisps I&#39;ve worked on, most of the tests were
represented in Go code as strings containing <a href="https://github.com/eigenhombre/l1/blob/master/eval_test.go">Lisp code and the
expressions they evaluate to</a>.  Here are some examples, taken more or
less at random.</p>
<div>
<div><pre tabindex="0"><code data-lang="text">        ...
        // `split` function
        {Cases(S(&#34;(split)&#34;, &#34;&#34;, &#34;expects a single argument&#34;))},
        {Cases(S(&#34;(split 1)&#34;, &#34;(1)&#34;, OK))},
        {Cases(S(&#34;(split -1)&#34;, &#34;(-1)&#34;, OK))},
        {Cases(S(&#34;(split -321)&#34;, &#34;(-3 2 1)&#34;, OK))},
        {Cases(S(&#34;(split (quote a))&#34;, &#34;(a)&#34;, OK))},
        {Cases(S(&#34;(split (quote (a b c)))&#34;, &#34;&#34;, &#34;expects an atom or a number&#34;))},
        {ECases(S(&#34;(split (quote greenspun))&#34;, &#34;(g r e e n s p u n)&#34;, OK))},
        {ECases(S(&#34;(split (* 12345 67890))&#34;, &#34;(8 3 8 1 0 2 0 5 0)&#34;, OK))},
        {ECases(S(&#34;(len (split (* 99999 99999 99999)))&#34;, &#34;15&#34;, OK))},
        {ECases(S(&#34;(split (quote greenspun))&#34;, &#34;(g r e e n s p u n)&#34;, OK))},
        {ECases(S(&#34;(split (* 12345 67890))&#34;, &#34;(8 3 8 1 0 2 0 5 0)&#34;, OK))},
        {Cases(S(&#34;(fuse (quote (1 2)))&#34;, &#34;12&#34;, OK))},
        {ECases(S(&#34;(+ 2 (fuse (quote (1 2 3))))&#34;, &#34;125&#34;, OK))},
        {ECases(S(&#34;(fuse (split 1295807125987))&#34;, &#34;1295807125987&#34;, OK))},
        {ECases(S(&#34;(len (randigits 10))&#34;, &#34;10&#34;, OK))},
        {ECases(S(&#34;((lambda (x) (+ 1 x)) 1)&#34;, &#34;2&#34;, OK))},
        {ECases(
                S(&#34;(def incrementer (lambda (n) (lambda (x) (+ x n))))&#34;, &#34;&lt;lambda(n)&gt;&#34;, OK),
                S(&#34;(def inc (incrementer 1))&#34;, &#34;&lt;lambda(x)&gt;&#34;, OK),
                S(&#34;(inc 5)&#34;, &#34;6&#34;, OK),
                S(&#34;(def add2 (incrementer 2))&#34;, &#34;&lt;lambda(x)&gt;&#34;, OK),
                S(&#34;(add2 5)&#34;, &#34;7&#34;, OK),
        )},
        ...</code></pre></div>
</div>
<p>
Here <code>Cases</code> is a utility function that create a local environment (a
possibly nested set of variable bindings) and evaluates one or more
expressions in that environment; <code>ECases</code> (<code>E</code> for Exemplary) is the
same, but saves its test cases in an <a href="https://github.com/eigenhombre/l1/blob/master/examples.txt"><code>examples.txt</code></a> file which stores
a reduced set of illustrative cases, e.g. for adding to the README.
<code>S</code> is a function which takes an expression to evaluate, the result
that should obtain, or an error message fragment which is expected if
the expression should fail.</p>
<p>
This seems to be a good way to test a new language
implementation, though I plan to implement some generative / &#34;fuzzing&#34;
tests as well, since I doubt all the bugs have been found yet.</p>
</div>
</div>
<div id="outline-container-headline-6">
<h2 id="headline-6">
Further Work
</h2>
<p>
Macros are next.  I&#39;m pretty sure I know how I want to do them, and
for me the power of macros is the whole point of Lisp, or at least a
big part of the point.</p>
</div>
<div id="outline-container-headline-7">
<h2 id="headline-7">
A Final Note on Performance, and Conclusion
</h2>
<div id="outline-text-headline-7">
<p>
To return to the performance discussion, above: a reasonable person
might object that <code>l1</code> is so lean on features, that it&#39;s not at all
surprising that it starts fast.  Clojure, on the other hand, leverages
the JVM, which has been tuned for decades for speed in long-running
processes, and also provides a thoughtful and comprehensive language
design that does many things no hobby language could easily support.</p>
<p>
That being said, one thing I am excited about with this project is
this: pretty much anything I can do in Go (which is very many things)
can be added to my Lisp without <em>too</em> much effort.  Conversely, to add
features to a Common Lisp or Clojure implementation would be very
difficult indeed.  Building a small language core that you can extend
in a variety of directions is a fun, if not necessarily entirely
practical, way to go.</p>
</div>
</div>




</div></div>
  </body>
</html>
