<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://thevaluable.dev/vim-regular-expressions-in-depth/">Original</a>
    <h1>Diving Deeper in Vim Regular Expressions</h1>
    
    <div id="readability-page-1" class="page"><div role="main"><article><section><picture>
<source srcset="https://thevaluable.dev/images/2022/regex_advanced/very_magic_nomagic.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2022/regex_advanced/very_magic_nomagic.jpg" alt="A deep dive in Vim regular expression"/></picture><p>This is the second article of a series about regular expressions in Vim:</p><p>We’ve seen, in the first article, general metacharacters we can use in our Vim regexes, as well as equivalent Perl-style regexes we can use with other tools (like <a href="https://themouseless.dev/posts/grep-basics-mouseless/" target="_blank" rel="noopener">GNU grep</a>). This time, we’ll dive deeper in Vim’s regex engine by looking at more metacharacters we can use in our favorite editor.</p><p>As a reminder, I don’t advise writing 32908309 regexes in your codebases, but instead using regexes with Vim (or other tools) for one-off tasks. A codebase is often a system in constant evolution, and regexes can ramp up in complexity fairly quickly.</p><p>We’ll see, in this article:</p><ul><li>How to do some substitutions in Vim using Perl-style regexes.</li><li>What is the “level of magic” of a regex in Vim, and what “level of magic” to choose.</li><li>Some characters class shorthands relying on Vim options.</li><li>What are lookaround assertions in Vim and Perl-style regex engines, and how to use them.</li><li>How to match a pattern on multiple lines.</li><li>How to match a pattern in a visual selection.</li></ul><p>I recommend you to actively follow along by trying the different regexes directly in Vim. There are also many exercises throughout the article; you can try to solve them using this <a href="https://github.com/Phantas0s/the_valuable_dev_companion/blob/main/vim-regular-expression-in-depth/example.html" target="_blank" rel="noopener">example file</a>. Only trying will help you understand and memorize the different metacharacters, even if you don’t try very hard!</p><p>Are you ready to dive into the depths of Vim’s regular expressions?</p><h2 id="vim-and-perl-regex-engines">Vim and Perl Regex Engines</h2><p>We’ve seen, <a href="https://thevaluable.dev/regular-expression-basics-vim-grep/">in the first article of this series</a>, some differences between Vim’s regex engine and a Perl-style regex engine (using the PCRE implementation of GNU grep). We can also look at Vim’s help to see the differences between both engines at a glance; to do so, simply run <code>:help perl-patterns</code>.</p><p>That’s not all: we can also use Perl’s regex engine directly in Vim, thanks to the <code>:perldo</code> command. It can be useful if you really don’t want to deal with the quirks of Vim’s regexes in your substitutions.</p><p>For example, if you want to substitute “regex” with “replacement”, you can run:</p><pre><code>:perldo s/regex/replacement/g
</code></pre><p>You’ll need to have Perl installed on your system for this command to work. If you use Neovim, you’ll also need to install the Perl provider. You can run <code>:checkhealth provider</code> to make sure the provider is indeed available.</p><div><div><ul><li><code>:help perl-patterns</code></li><li><code>:help :perldo</code></li></ul></div></div><h2 id="its-a-kind-of-magic">It’s a Kind of Magic</h2><p>The first article of this series left an elephant in the room : the “level of magic” for Vim regexes. Let’s address now this oddity.</p><p>I was recommending prefixing our Vim regexes with <code>\v</code> (making the regex “very magic”) to be able to use every metacharacter available. What does this “very magic” means? What mechanism is used here?</p><p>First, a little reminder: some characters can act as metacharacter in a regex pattern. For example, the character full stop (or dot) <code>.</code> can be interpreted by our regex engine as a <em>literal character</em>; in that case, it will match a dot in your text. It can also be interpreted as a <em>metacharacter</em>; in that case, the full stop means “any character”.</p><p>Depending on the “level of magic” of the regex, we might need to escape some literal characters to use them as metacharacters, or to escape some metacharacters to use them as literal characters. To escape characters, you simply need to add a backslash in front of it (i.e. <code>\.</code>).</p><p>As a rule, I always try to avoid escaping any character (literal or metacharacters) in my regexes. Backslashes make the pattern more difficult to read and understand. As a result, I often change the “level of magic” of my regexes depending on what I need: do I want to match more literal characters, or do I want to use mostly metacharacters?</p><p>From there, we can ask ourselves many questions:</p><ol><li>What “levels of magic” forces us to escape characters to use their metacharacter counterparts?</li><li>What “levels of magic” forces us to escape metacharacters to use their literal character counterparts?</li><li>Do we have to escape all characters (or metacharacters), or only some of them?</li><li>How do we change this level of magic for a specific regex?</li></ol><p>We can already answer the last question: we need to add a prefix to a regex in order to change its “level of magic”. The following table tries to answer the other questions:</p><table><tbody><tr><th>Level of magic</th><th>Prefix</th><th>Description</th></tr><tr><td>Very magic</td><td>\v</td><td>All possible metacharacters are available without escaping them.</td></tr><tr><td>Magic</td><td>\m</td><td>Only some metacharacters are available without escaping them. The others need to be escaped.</td></tr><tr><td>Nomagic</td><td>\M</td><td>Only some literal characters are available without escaping them. The others need to be escaped.</td></tr><tr><td>Very nomagic</td><td>\V</td><td>All possible literal characters are available without escaping them.</td></tr></tbody></table><p>By default, if we don’t add any of these prefixes to our regexes, they’re considered “magic”. That’s a shame, because I think that “magic” and “nomagic” are quite confusing: for the first, you need to escape <em>some</em> (but not all) metacharacters to match the literal ones, and for the second it’s the contrary. It’s not consistent, because not all metacharacters (or literal characters) need to be escaped; only some of them, and you need to learn them by heart.</p><p>As a result, I try to avoid “magic” and “nomagic” as much as possible; I always try to add the prefix <code>\v</code> (for “very magic”) or <code>\V</code> (for “very nomagic”) to my regexes.</p><p>For “very magic” patterns, most characters are considered as metacharacters by the regex engine, without the need to escape anything. It’s useful when you need to use many metacharacters in your regex. The downside: you’ll need to escape every literal character you want to match.</p><p>If you want to mostly match literal characters instead of relying on metacharacters, you can use “very nomagic”. This time, most characters will be interpreted as literal characters by the regex engine, without the need to escape anything. The downside: you have to escape any metacharacter you want to use.</p><p>To drive the point home, here are some equivalent regexes using different “level of magic”: “magic”, “very magic”, and “very nomagic”. The first regex tries to match a year with four digits, and the second one tries to match a literal string <code>{ Mouseless }</code>.</p><table><tbody><tr><th>Magic</th><th>Very magic</th><th>Very nomagic</th></tr><tr><td><code>/[0-9]\{4}</code></td><td><code>/\v[0-9]{4}</code></td><td><code>/\V\[0-9]\{4}</code></td></tr><tr><td><code>/{ Mouseless }</code></td><td><code>/\v\{ Mouseless \}</code></td><td><code>/\V{ Mouseless }</code></td></tr></tbody></table><p>Let’s solidify our understanding with an exercise: using Vim’s search in our <a href="https://github.com/Phantas0s/the_valuable_dev_companion/blob/main/vim-regular-expression-in-depth/example.html" target="_blank" rel="noopener">example file</a>, how would you match all HTML attributes <code>rel</code>, their values, and the quotes surrounding them? Would you use a “very magic” or a “very nomagic” pattern?</p><div id="toggle-1"><p><label for="toggle-input-1">Click to see the solution</label>
</p><div><p>We first need to match the name of the attribute <code>rel</code> followed by the literal character equal <code>=</code>. Then, we need to use metacharacters to match one or more character (using the full stop <code>.</code>) between the literal double quotes <code>&#34;</code>.</p><p>Here’s the “very magic” pattern:</p><pre><code>/\vrel\=&#34;.*&#34;
</code></pre><p>Here’s the “very nomagic” equivalent:</p><pre><code>/\Vrel=&#34;\.\*&#34;
</code></pre><p>We match a literal character which could be interpreted as metacharacters (the equal character <code>=</code>), and we need to use two metacharacters to match any character between the two double quotes <code>&#34;</code>. As a result, we have more metacharacters than literal characters; the “very magic” pattern is arguably more readable, because we escape fewer characters.</p><p>This regex won’t work for every HTML file, however. For example, if there is anything after the <code>rel</code> attribute, it will be matched too, because we use the greedy quantifiers <code>+</code>. Here’s the equivalent using non-greedy ones:</p><pre><code>/\vrel\=&#34;.{-}&#34;
</code></pre><p>Here’s the “very nomagic” equivalent:</p><pre><code>/\Vrel=&#34;\.\{-\}&#34;
</code></pre><p>You can read more about greedy and non-greedy quantifiers in the <a href="https://thevaluable.dev/regular-expression-basics-vim-grep/">previous article</a>.</p><p>All the regexes here work well enough for the task at hand. That’s what we should aim for, instead of trying to craft the best regex which could work on any HTML file. If you want to systematically parse HTML, you should use an HTML parser. Again, I think regexes are best used in one-off tasks.</p></div></div><p>Here’s another exercise: how would you match any text surrounded by literal stars <code>*</code>? Would you use “very magic” or “very nomagic”?</p><div id="toggle-2"><p><label for="toggle-input-2">Click to see the solution</label>
</p><div><p>Using “very magic”:</p><pre><code>/\v\*.+\*
</code></pre><p>Using “very nomagic”:</p><pre><code>/\V*\.\+*
</code></pre><p>In both cases, we want to match two literal characters which could be interpreted as metacharacters (the two surrounding stars), and two metacharacters which could be interpreted as literal characters (the full stop <code>.</code> and the quantifier <code>+</code>). Whatever level of magic you use, you’ll have to escape the same number of characters; it’s a draw!</p><p>That said, I still prefer using “very magic” when I use any metacharacter, to stay consistent. When I look at one of my regexes, I know that the characters escaped are literal characters I want to match; I don’t need to think about it.</p></div></div><h2 id="character-classe-shorthands-and-vim-options">Character Classe Shorthands and Vim Options</h2><p>We’ve already seen some shorthands for character classes in the <a href="https://thevaluable.dev/regular-expression-basics-vim-grep/#shorthand-classes">last article</a>. There are more available, specific to Vim; the characters they include depend on the value of some Vim options:</p><table><tbody><tr><th>Character class</th><th>Description</th><th>Option</th></tr><tr><td><code>\f</code></td><td>Filename characters</td><td><code>isfname</code></td></tr><tr><td><code>\i</code></td><td>Identifier characters</td><td><code>isident</code></td></tr><tr><td><code>\k</code></td><td>Keyword character</td><td><code>iskeyword</code></td></tr><tr><td><code>\p</code></td><td>Printable character</td><td><code>isprint</code></td></tr></tbody></table><p>If you look at the value of these options, you might see weird ranges of number. For example, if I run <code>:set isfname?</code>, I’ll get <code>@,48-57,/,.,-,_,+,,,#,$,%,~,=</code>. The range <code>48-57</code> means that the ASCII characters from 48 to 57 are included (the digits 0 to 9). The characters separated by commas <code>,</code> are also included in the character class.</p><p>You can learn more about Vim options in this <a href="https://thevaluable.dev/vim-commands-beginner/#vims-options">other article I wrote</a>. Another tip: you can have access to a fancy ASCII table by running <code>man ascii</code> in your terminal.</p><p>I’ll finish this short section with a word of caution: these options are sometimes used by other commands or plugins, and changing their values can have unforeseen consequences. For example, the keystroke <code>gf</code> use the option <code>isfname</code> under the hood.</p><h2 id="lookaround-assertions">Lookaround Assertions</h2><p>What if we want to match a pattern only if it’s before (or after) another pattern? It’s where <em>lookaround assertions</em> enter the chat.</p><p>There are two sorts of these assertions:</p><ol><li>Positive lookaround: the pattern you want to match needs to be before (or after) another pattern.</li><li>Negative lookaround: the pattern you want to match shouldn’t be before (or after) another pattern.</li></ol><p>We’ll first look at the handiest metacharacters we can use for positive lookaround assertions; then, we’ll talk about other metacharacters for both positive and negative lookaround.</p><h3 id="start-and-end-of-the-matched-pattern">Start and End of the Matched Pattern</h3><p>We can use two different atoms to mark the beginning or the end of the pattern we want to match:</p><table><tbody><tr><th>Metacharacter</th><th>Description</th></tr><tr><td><code>\zs</code></td><td>Set the start of the match after <code>\zs</code>; the pattern before it will need to be in the text, but won’t be matched.</td></tr><tr><td><code>\ze</code></td><td>Set the start of the match before <code>\ze</code>; the pattern after it will need to be in the text, but won’t be matched.</td></tr></tbody></table><p>Here’s an exercise: using Vim’s search and our <a href="https://github.com/Phantas0s/the_valuable_dev_companion/blob/main/vim-regular-expression-in-depth/example.html" target="_blank" rel="noopener">example file</a> (as always), how would you match all non-empty strings surrounded by double quotes <code>&#34;</code> and beginning by the string <code>application\</code>? We don’t want to match <code>application\</code> however, just what’s after.</p><p>For example, for the attribute <code>type=&#34;application/ld+json&#34;</code>, we want to match <code>ld+json</code>.</p><div id="toggle-3"><p><label for="toggle-input-3">Click to see the solution</label>
</p><div><pre><code>/\v&#34;application\/\zs.{-1,}&#34;
</code></pre><p>Let’s decompose the pattern:</p><ol><li><code>zs</code> - Everything after <code>zs</code> will be matched, but not what’s before (<code>&#34;application\/</code>)</li><li><code>\/</code> - Since we use “very magic”, we need to escape the slash <code>/</code> to match it (it’s a literal character in that case).</li><li><code>{.{-1,}}</code> - We want to match 1 or more character between the literal slash <code>/</code> and the closing double quotes <code>&#34;</code> in a non-greedy way; <code>{-1,}</code> is the non-greedy equivalent of the quantifier <code>+</code>.</li></ol></div></div><h3 id="lookahead-and-lookbehind">Lookahead and Lookbehind</h3><p>There are other atoms we can use in Vim to look around (ahead or behind) the pattern we want to match. Here’s the complete list (assuming, as always, that you’re in “very magic” mode):</p><table><tbody><tr><th>Metacharacters</th><th>Type</th><th>Description</th></tr><tr><td>(<code>&lt;pattern&gt;</code>)@&lt;=<code>&lt;match&gt;</code></td><td>Positive lookbehind</td><td>The pattern <code>&lt;match&gt;</code> will be matched only if the pattern <code>&lt;pattern&gt;</code> precedes it.</td></tr><tr><td><code>&lt;match&gt;</code>(<code>&lt;pattern&gt;</code>)@=</td><td>Positive lookahead</td><td>The pattern <code>&lt;match&gt;</code> will be matched only if the pattern <code>&lt;pattern&gt;</code> follows it.</td></tr><tr><td>(<code>&lt;pattern&gt;</code>)@&lt;!<code>&lt;match&gt;</code></td><td>Negative lookbehind</td><td>The pattern <code>&lt;match&gt;</code> will be matched only if the pattern <code>&lt;pattern&gt;</code> doesn’t precede it.</td></tr><tr><td><code>&lt;match&gt;</code>(<code>&lt;pattern&gt;</code>)@!</td><td>Negative lookahead</td><td>The pattern <code>&lt;match&gt;</code> will be matched only if the pattern <code>&lt;pattern&gt;</code> doesn’t follow it.</td></tr></tbody></table><p>The two strings <code>&lt;pattern&gt;</code> and <code>&lt;match&gt;</code> are just placeholders here, you should replace them by what you want.</p><p>It’s time for another exercise! Still using the <a href="https://github.com/Phantas0s/the_valuable_dev_companion/blob/main/vim-regular-expression-in-depth/example.html" target="_blank" rel="noopener">example file</a>, Vim’s search, and the lookaround and lookbehind assertion described above, how would you match every pattern <code>tag</code> followed by the pattern <code>small</code> (the characters <code>small</code> prefixed with a space)? Another constraint: the match should <strong>not</strong> be after the pattern <code>article:</code>.</p><p>For example, <code>section:tag small</code> should match, or even <code>tag small</code>, but not <code>article:tag small</code>.</p><div id="toggle-4"><p><label for="toggle-input-4">Click to see the solution</label>
</p><div><pre><code>/\v(article:)@&lt;!tag(\ssmall)@=
</code></pre><p>Some explanations:</p><ol><li><code>(article:)@&lt;!</code> - We use the negative lookbehind <code>@&lt;!</code> to ensure that the pattern in parenthesises is not before the pattern <code>tag</code> we want to match.</li><li><code>(\ssmall)@=</code> - We use <code>@=</code> to assert that the pattern <code>\ssmall</code> (the litteral characters <code>small</code> preceded by a space, <code>\s</code>) need to be after the pattern <code>tag</code> we want to match.</li></ol></div></div><h3 id="equivalent-perl-style-metacharacters">Equivalent Perl-style Metacharacters</h3><p>Lookahead and lookbehind assertions are not unique to Vim: you can also use them in Perl-style regexes, like PCRE.</p><p>Here’s a table summarizing the equivalent syntaxes:</p><table><tbody><tr><th>Vim syntax</th><th>PCRE syntax</th></tr><tr><td>(<code>&lt;pattern&gt;</code>)@&lt;=<code>&lt;match&gt;</code></td><td>(?&lt;=<code>&lt;pattern&gt;</code>)<code>&lt;match&gt;</code></td></tr><tr><td><code>&lt;match&gt;</code>(<code>&lt;pattern&gt;</code>)@=</td><td><code>&lt;match&gt;</code>(?=<code>&lt;pattern&gt;</code>)</td></tr><tr><td>(<code>&lt;pattern&gt;</code>)@&lt;!<code>&lt;match&gt;</code></td><td>(?&lt;!<code>&lt;pattern&gt;</code>)<code>&lt;match&gt;</code></td></tr><tr><td><code>&lt;match&gt;</code>(<code>&lt;pattern&gt;</code>)@!</td><td><code>&lt;match&gt;</code>(?!<code>&lt;pattern&gt;</code>)</td></tr></tbody></table><p>As you can see, the two syntaxes have some similarities; learning one can help to memorize the other.</p><p>Let’s practice with this exercise: using GNU grep with the PCRE engine (using the option <code>-P</code>), how would you solve the previous exercise above?</p><div id="toggle-"><p><label for="toggle-input-">Click to see the solution</label>
</p><div><pre><code>grep -P &#39;(?!article:)tag(?=\ssmall)&#39; example.html
</code></pre><p>Here’s the Vim version:</p><pre><code>/\v(article:)@&lt;!tag(\ssmall)@=
</code></pre><p>You can also substitute the match using <code>:perldo</code> with a Perl-style regex, as we’ve seen at the beginning of this article. For example:</p><pre><code>:perldo s/(?!article:)tag(?=\ssmall)/another-thing/
</code></pre></div></div><h2 id="matching-on-multiple-lines">Matching On Multiple Lines</h2><p>Until now, every regex we’ve written are limited to line. We can match the same pattern on different lines, but we can’t yet create a pattern which match multiple lines.</p><p>There are other metacharacters we can use in Vim for that purpose. Many of them are similar to the metachacters operating on a single line, except that they’re prefixed with <code>\_</code>. It means that these metacharacters will also match end-of-lines:</p><table><tbody><tr><th>Metacharacter</th><th>Description</th><th><code>%^</code></th><th>Match the beginning of the file.</th></tr><tr><td><code>%$</code></td><td>Match the end of the file.</td></tr><tr><td><code>\n</code></td><td>Match an end-of-line. It can be used in a character class.</td></tr><tr><td><code>\_.</code></td><td>Match any character (including end-of-lines).</td></tr><tr><td><code>\_[]</code></td><td>Match a character class as well as end-of-lines.</td></tr><tr><td><code>\_^</code></td><td>Match any start-of-line; not only for the current line, but any other line included in the match.</td></tr><tr><td><code>\_$</code></td><td>Match any end-of-line; not only for the current line, but any other line included in the match.</td></tr></tbody></table><p>We can also prefix character class shorthands with <code>\_</code>. For example, if you want the character class <code>\s</code> (for whitespaces) to match multiple lines (that is, it includes also end-of-lines), you can use <code>\_s</code>.</p><p>Let’s try to solve some exercises, shall we? Using Vim’s search in our <a href="https://github.com/Phantas0s/the_valuable_dev_companion/blob/main/vim-regular-expression-in-depth/example.html" target="_blank" rel="noopener">example file</a>, how would you select the opening and closing HTML tag <code>&lt;head&gt;</code>, as well as every line in between?</p><div id="toggle-5"><p><label for="toggle-input-5">Click to see the solution</label>
</p><div><pre><code>/\v\&lt;head\&gt;\_.*\&lt;\/head\&gt;
</code></pre><p>The atom <code>\_.</code> matches any character, including end-of-lines. Said differently, it will match any character (exactly like the full stop <code>.</code>) but on multiple lines.</p></div></div><p>Another exercise: how would you match HTML link tags <code>a</code> and their possible attributes, but only when they don’t have any inner HTML? That is, there is nothing except possible spaces, tabs, or newlines between the opening tag and the closing one.</p><div id="toggle-6"><p><label for="toggle-input-6">Click to see the solution</label>
</p><div><pre><code>/\v\&lt;a.*\&gt;\_s+\&lt;\/a\&gt;
</code></pre><p>We use <code>\_s</code> here because it includes spaces, tabs, and end-of-lines; if we would had used <code>\s</code>, it would have only matched spaces and tabs on the same line.</p></div></div><p>If you’re not tired of exercises yet, here’s another one: what about matching list tags <code>li</code>? More precisely, we want to match the opening tag (and its possible attributes), the closing tag, and everything else in between. Let’s add more constraints: we don’t want anything else on the line of the opening tag, and we don’t want to match list tags which are only on one line.</p><p>For example, this is a valid match:</p><pre><code>&lt;li class=&#34;nav-opened&#34; role=&#34;presentation&#34;&gt;
    &lt;a href=&#34;https://thevaluable.dev/tags/fundamentals&#34;&gt;Fundamentals&lt;/a&gt;
&lt;/li&gt;
</code></pre><p>This is not a valid match, because the opening tag is not alone on its line (there’s also the string “Some content on the same line”).</p><pre><code>&lt;li class=&#34;nav-opened&#34; role=&#34;other&#34;&gt;Some content on the same line
    &lt;a href=&#34;https://thevaluable.dev/tags/others&#34;&gt;Others&lt;/a&gt;
&lt;/li&gt;
</code></pre><div id="toggle-7"><p><label for="toggle-input-7">Click to see the solution</label>
</p><div><pre><code>/\v\&lt;li [^&lt;]+\&gt;\_$\_.{-}\&lt;\/li\&gt;
</code></pre><p>Some explanations:</p><ul><li><code>[^&lt;]</code> - Ensure that we don’t have any other opening tag on the line. It’s basically saying “I want to match any characters except <code>&lt;</code>”.</li><li><code>\_$</code> - Ensure that the list tag is at the end of the line. Contrary to <code>\$</code>, <code>\_$</code> allows us to continue our match on the lines below (it includes end-of-lines).</li><li><code>{-}</code> - This is the non-greedy equivalent of <code>*</code>, otherwise the match would continue until the end of the file, and then backtrack to the first closing list tag the engine can find. It would be too much match!</li></ul></div></div><p>A last exercise: how would you match the first opening HTML link tag <code>a</code> and its possible attributes in our <a href="https://github.com/Phantas0s/the_valuable_dev_companion/blob/main/vim-regular-expression-in-depth/example.html" target="_blank" rel="noopener">example file</a>?</p><div id="toggle-8"><p><label for="toggle-input-8">Click to see the solution</label>
</p><div><pre><code>/\v%^\_.{-}\zs\&lt;a.{-}\&gt;
</code></pre><p>The usual explanations:</p><ol><li><code>%^</code> - We want to search from the beginning of the file, to be sure we match the first link tag. Note that we need to escape this atom if we’re not in “very magic” mode (<code>\%^</code>).</li><li><code>\_.{-}</code> - We match all characters on multiple lines, using a non-greedy quantifier.</li><li><code>\zs\&lt;a</code> - We don’t want to match everything from the beginning of the file until the first tag, that’s why we only begin the match when we see the first link tag.</li><li><code>.{-}\&gt;</code> - Ensure that we also match the possible attributes of the link tag.</li></ol></div></div><div><div><ul><li><code>:help \%^</code></li><li><code>:help \%$</code></li><li><code>:help \_</code></li></ul></div></div><h2 id="matching-the-visual-selection">Matching the Visual Selection</h2><p>What about matching a pattern, but only if it’s visually selected? Here’s what you need:</p><table><tbody><tr><th>Metacharacter</th><th>Description</th></tr><tr><td><code>%V</code></td><td>Match inside the VISUAL mode selection (or the previous one if you’ve nothing selected).</td></tr></tbody></table><p>Let’s look at a real-life example: when I try to rename a file in my shell (Zsh), I often end up with this kind of command:</p><pre><code>mv my-file-name.jpg my-file-name.jpg
</code></pre><p>I simply type <code>mv</code> in the shell, and then I use Zsh completion to get the filename I want to rename. I have it two times to modify the second filename, instead of typing it entirely. I then use a keystroke to directly edit this command in Vim.</p><p>The goal here is to rename the second string <code>my-file-name.jpg</code> to <code>my_file_name.jpg</code>, replacing the hyphen <code>-</code> with underscores <code>_</code>. I could do that manually, but I think using a substitution is easier and less prone to errors.</p><p>Here’s what I tried at the beginning:</p><ol><li>Switch to VISUAL mode.</li><li>Select the second <code>my-file-name.jpg</code>.</li><li>Run the following:</li></ol><pre><code>:&#39;&lt;,&#39;&gt;s/\V-/_/g
</code></pre><p>Too bad: it doesn’t work. This substitution will replace every hyphen on the line because of the <code>g</code> flag. It doesn’t matter what’s selected: the substitution command will always operate on the whole line (if no other range is specified). If I don’t use the <code>g</code> flag, it will only substitute the first hyphen.</p><p>It’s where <code>%V</code> can be useful:</p><pre><code>:&#39;&lt;,&#39;&gt;s/\v%V-/_/g
</code></pre><p>It works as expected: the pattern only match what I’ve selected in VISUAL mode, thanks to the atom <code>%V</code>.</p><p>Here’s the last exercise: on line 74 of the <a href="https://github.com/Phantas0s/the_valuable_dev_companion/blob/main/vim-regular-expression-in-depth/example.html" target="_blank" rel="noopener">example file</a>, how would you substitute <code>nav-and-other</code> with <code>nav_and_other</code>, without modifying any other attribute in the <code>h3</code> tag?</p><div id="toggle-9"><p><label for="toggle-input-9">Click to see the solution</label>
</p><div><p>First, we need to switch to VISUAL mode and select <code>nav-and-other</code>. We can then switch to COMMAND-LINE mode and run the following:</p><pre><code>:&#39;&lt;,&#39;&gt;s/\v%V-/_/g
</code></pre><p>Note that you need to escape the atom <code>%V</code> if you’re not in “very magic” mode. For example:</p><pre><code>:&#39;&lt;,&#39;&gt;s/\%V-/_/g
</code></pre></div></div><h2 id="ready-for-the-regexes">Ready for the Regexes?</h2><p>We’ve seen, throughout this series, the most important metacharacters we can use in our Vim regexes, from the basics to the more complicated ones. Now, instead of writing a script to parse some plain text files, you can directly open them in Vim and use some good regexes! You’ll also be able to use tools using a Perl-style regex engine; it’s not that different, in principle, than the Vim regexes!</p><p>So, what did we see in this article?</p><ul><li>We can make some substitutions using Perl-style regexes directly in Vim, thanks to the Ex command <code>:perldo</code>. Handy if you’re allergic to Vim’s regex engine.</li><li>A Vim regex can have different levels of magic: “very magic” (using the prefix <code>\v</code>) gives you all metacharacters without the need to escape anything, “very nomagic” gives you all literal characters without the need to escape anything.</li><li>There are a couple of Vim character class shorthands which depends on the value of some Vim options.</li><li>We can try to match a pattern if another pattern is just before or after. To do so, we can use <code>\zs</code> (before the <code>s</code>tart of the pattern for a lookbehind assertion) or <code>\ze</code> (after the <code>e</code>nd of the pattern for a lookahead assertion).</li><li>Lookaround assertions are not exclusive to Vim: we can use some similar syntax with a Perl-style regex engine, like PCRE.</li><li>Vim introduced, in Vim 6, the possibility to match a pattern on multiple lines. Most of these new atoms begins with <code>\_</code>.</li><li>We can try to match our regexes in a visual selection only, using the atom <code>%V</code> (<code>\%V</code> if we’re not in “very magic” mode).</li></ul><p>I’m curious: what are the most useful regexes you’re often using in Vim? Don’t hesitate to share with the community in the comment section just below! You know, sharing is caring.</p></section></article></div></div>
  </body>
</html>
