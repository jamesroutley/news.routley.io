<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.jfo.click/an-unnamed-static-site-generator">Original</a>
    <h1>An Unnamed Static Site Generator</h1>
    
    <div id="readability-page-1" class="page"><div><p>I wrote a static site generator; to dispense with the &#34;why.&#34;</p>
<p>This blog has been, in order, wordpress, middleman, jekyll, and hugo. Each time
I become comfortable with one, inevitably they will become too slow for my
needs (jekyll) or introduce subtle, minute breaking changes into some version
or another, offering me an opportunity to jump ship (middleman and hugo) or
just be not fit for purpose / total overkill (wordpress). I am tired of
migrating every few years to get a random feature or please the platform. So
I&#39;ll write my own. How hard can it be? Not that hard, really, as it turned out.</p>
<p>This post is about the most basic iteration with which this blog is currently
being deployed. There are no bells and whistles, and though I might add some
conveniences as I go along, it&#39;s current form is more than adequate for my
needs at the moment, so I count that as a win. I spent part of the <a href="https://blog.jfo.click/week-two-point-one">first week
of my batch</a> fiddling around with it, so I also gave a
short presentation that first friday about it, which was recorded.</p>
<iframe width="720" height="405" src="https://www.youtube.com/embed/2Xk66ftq1oM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>


<p><em>Configurability</em>. I will no longer need to appease changelogs driven by someone(s)
else&#39;s priorities, whatever they are. I can include the features I need or want
and not the ones that I don&#39;t. You can&#39;t get much more configurable than &#34;roll
your own&#34; after all.</p>
<p><em>Stability</em>. The generator will change when I want it to. I&#39;ll have to keep up
with platform changes, like version bumps in the runtime, but that happens with
much more pomp and circumstance and more infrequently than package updates.</p>
<p><em>The learns</em>. As always.</p>
<p>Let&#39;s get started, then.</p>

<p>A static site generator is <em>basically</em> a compiler, right? We take an input (the
source) transform it somehow and output it in some other form. This is a loose
usage of &#34;compile&#34; but I&#39;ll stand by the general idea. Usually this is markdown -&gt; html.</p>
<p>I love markdown, <a href="https://blog.codinghorror.com/standard-markdown-is-now-common-markdown/">in spite of its troubled
past</a>.
It&#39;s easy to read and write in its raw form, and as long as you don&#39;t expect it
to do everything html can do seamlessly and can live with the occasional
weirdness, it&#39;s fine.</p>
<p>You could sit down and write a whole post directly in html, but there are some
pretty obvious downsides to that.</p>

<ol>
<li><p><strong>It sucks.</strong> It&#39;s hard to do, error prone, and adds extra work. Writing is
already a lot of work.  I don&#39;t want to be farting around with mysteriously
unclosed <code>div</code>s.</p>
</li>
<li><p><strong>It&#39;s not flexible.</strong> Markdown is a type of (semi)-standardized source, and
it can thus be <a href="https://pandoc.org/MANUAL.html">turned into differently formatted
targets</a>.  Sure, so can html, but we&#39;ve
established that writing in html sucks, so why not use markdown?</p>
</li>
<li><p><strong>I&#39;m used to it.</strong> YMMV.</p>
</li>
</ol>
<p>So start with this: I want a program that takes <em>as input</em> some markdown and
<em>outputs</em> some html.</p>
<p>What am I going to write it in? I&#39;ve been wanting to try Deno out for a few
years, so <a href="https://deno.land/">I&#39;m going to try something new.</a></p>

<pre><code><span>import</span> { <span>Marked</span> } <span>from</span> <span>&#34;https://deno.land/x/<a href="https://blog.jfo.click/cdn-cgi/l/email-protection" data-cfemail="e18c80938a858e968fa197d3cfd1cfd1">[email protected]</a>/mod.ts&#34;</span>;

<span>const</span> sourcetext = <span>&#34;This is a string of markdown.&#34;</span>;
<span>const</span> output = <span>Marked</span>.<span>parse</span>(sourcetext);

<span>console</span>.<span>log</span>(output);

</code></pre>
<p>So here is a program that takes in a source and outputs markdown. I am pulling
my only dependency directly from <code>https://deno.land/x</code>. This is an officially
hosted site for third party packages, of which there are quite a few high
quality ones already, many but not all of them being ports of npm packeges.</p>
<p>You&#39;ll notice that the <code>output</code> turns out to be an object with the expected
<code>content</code>, but what is <code>meta</code>? It turns out this is quite useful for a blog
generator, as out of the box this markdown implementation supports parsing YAML
frontmatter.</p>
<p>I ran this from the CLI by using <code>deno run filename.js</code>.</p>

<pre><code><span>import</span> { <span>Marked</span> } <span>from</span> <span>&#34;https://deno.land/x/<a href="https://blog.jfo.click/cdn-cgi/l/email-protection" data-cfemail="c7aaa6b5aca3a8b0a987b1f5e9f7e9f7">[email protected]</a>/mod.ts&#34;</span>;

<span>const</span> sourcetext = <span>`
---
title: &#39;This is a title&#39;
---

This is a string of markdown.
`</span>;
<span>const</span> output = <span>Marked</span>.<span>parse</span>(sourcetext);

<span>console</span>.<span>log</span>(output);




</code></pre>
<p>Frontmatter is at this point a pretty standard method for getting metadata
attached to source markdown files in a static generator, all the way back to at
least <a href="https://jekyllrb.com/">Jekyll</a>. This obviates any need to keep some kind
of index or central database of that metadata, and since it&#39;s completely
arbitrary what I put in there, this will offer a lot of flexibility when it comes
time to add f.ex tagging or syndication etc.</p>
<p>Next step is fairly obvious, I&#39;d like to read in a file and apply this parsing
to it. Let&#39;s pretend that file contains the string in <code>sourcetext</code>, above.</p>

<pre><code><span>import</span> { <span>Marked</span> } <span>from</span> <span>&#34;https://deno.land/x/<a href="https://blog.jfo.click/cdn-cgi/l/email-protection" data-cfemail="95f8f4e7fef1fae2fbd5e3a7bba5bba5">[email protected]</a>/mod.ts&#34;</span>;

<span>const</span> input = <span>Deno</span>.<span>readTextFileSync</span>(<span>&#39;./sourcetext.md&#39;</span>);
<span>const</span> output = <span>Marked</span>.<span>parse</span>(input);

<span>console</span>.<span>log</span>(output);
</code></pre>
<p>This breaks.</p>

<pre><code>error: Uncaught PermissionDenied: Requires read access to &#34;./sourcetext.md&#34;, run again with the --allow-read flag
const input = Deno.readTextFileSync(&#34;./sourcetext.md&#34;);
                   ^
    at deno:core/01_core.js:106:46
    at unwrapOpResult (deno:core/01_core.js:126:13)
    at Object.opSync (deno:core/01_core.js:140:12)
    at openSync (deno:runtime/js/40_files.js:37:22)
    at Object.readTextFileSync (deno:runtime/js/40_read_file.js:30:18)
</code></pre>
<p>Deno is <a href="https://deno.land/manual/getting_started/permissions">&#34;secure by default&#34;</a>. It takes a
sandbox model of security in the same way that browser runtimes do, so if you
want to give it access to your filesystem, you have to do so explicitly.</p>

<pre><code>deno run --allow-read filename.js
</code></pre>
<p>This works.</p>
<p>I&#39;m using the <code>sync</code> version of the file reading function here, for simplicity.
I&#39;m used to Node, where for scripting it&#39;s easiest to just use synchronous I/O
for smaller scripts. I&#39;ll come back to this later to discuss top level-awaits,
which are genuinely exciting to me.</p>
<p>Of course, I don&#39;t just want to print the output to the console, I want to
produce some html from the source.</p>

<pre><code><span>import</span> { <span>Marked</span> } <span>from</span> <span>&#34;https://deno.land/x/<a href="https://blog.jfo.click/cdn-cgi/l/email-protection" data-cfemail="3a575b48515e554d547a4c08140a140a">[email protected]</a>/mod.ts&#34;</span>;
<span>import</span> { paramCase } <span>from</span> <span>&#34;https://deno.land/x/case/mod.ts&#34;</span>;

<span>const</span> input = <span>Deno</span>.<span>readTextFileSync</span>(<span>&#34;./sourcetext.md&#34;</span>);
<span>const</span> output = <span>Marked</span>.<span>parse</span>(input);

<span>Deno</span>.<span>writeTextFileSync</span>(
  <span>`./<span>${paramCase(output.meta.title)}</span>.html`</span>,
  output.<span>content</span>
);
</code></pre>
<p>Notice again I&#39;m importing a helper module, this time to do some case
manipulation so that I can produce a url ready filename from the metadata.</p>
<p>This also breaks. I need explicit write access, too, and it is separate.</p>

<pre><code>deno run --allow-read --allow-write filename.js
</code></pre>
<p>This works.</p>
<p>If you&#39;re thinking that we&#39;re already frighteningly close to a full-fledged
static site generator, well then you&#39;d be mostly right.</p>

<pre><code><span>import</span> {
  ensureDirSync,
  expandGlobSync,
} <span>from</span> <span>&#34;https://deno.land/<a href="https://blog.jfo.click/cdn-cgi/l/email-protection" data-cfemail="2053544460100e19110e10">[email protected]</a>/fs/mod.ts&#34;</span>;
<span>import</span> { paramCase } <span>from</span> <span>&#34;https://deno.land/x/case/mod.ts&#34;</span>;
<span>import</span> { <span>Marked</span> } <span>from</span> <span>&#34;https://deno.land/x/<a href="https://blog.jfo.click/cdn-cgi/l/email-protection" data-cfemail="98f5f9eaf3fcf7eff6d8eeaab6a8b6a8">[email protected]</a>/mod.ts&#34;</span>;


<span>ensureDirSync</span>(<span>&#34;./build&#34;</span>);

<span>const</span> inputFiles = <span>expandGlobSync</span>(<span>&#34;**/*.md&#34;</span>);
<span>for</span> (<span>const</span> file <span>of</span> inputFiles) {
  <span>const</span> input = <span>Deno</span>.<span>readTextFileSync</span>(file.<span>path</span>);

  
  <span>const</span> markup = <span>Marked</span>.<span>parse</span>(input);
  <span>Deno</span>.<span>writeTextFileSync</span>(
    <span>`./build/<span>${paramCase(markup.meta.title)}</span>.html`</span>,
    markup.<span>content</span>,
  );
}
</code></pre>
<p>This script (which is basically all it is at this point) will grab all of the
markdown files in the directory it is run in and create a <code>build</code> folder with
the processed output of each one in its corresponding <code>html</code> file. For a pretty
stripped down idea of what a static site generator is, this ~20 line script
basically fits the bill. Pretty neat! Let me add one more thing.</p>

<pre><code><span>import</span> {
  ensureDirSync,
  expandGlobSync,
} <span>from</span> <span>&#34;https://deno.land/<a href="https://blog.jfo.click/cdn-cgi/l/email-protection" data-cfemail="a5d6d1c1e5958b9c948b95">[email protected]</a>/fs/mod.ts&#34;</span>;
<span>import</span> { paramCase } <span>from</span> <span>&#34;https://deno.land/x/case/mod.ts&#34;</span>;
<span>import</span> { <span>Marked</span> } <span>from</span> <span>&#34;https://deno.land/x/<a href="https://blog.jfo.click/cdn-cgi/l/email-protection" data-cfemail="3d505c4f5659524a537d4b0f130d130d">[email protected]</a>/mod.ts&#34;</span>;
<span>import</span> { render } <span>from</span> <span>&#34;https://deno.land/x/mustache_ts/mustache.ts&#34;</span>;


<span>ensureDirSync</span>(<span>&#34;./build&#34;</span>);

<span>const</span> inputFiles = <span>expandGlobSync</span>(<span>&#34;**/*.md&#34;</span>);
<span>for</span> (<span>const</span> file <span>of</span> inputFiles) {
  <span>const</span> input = <span>Deno</span>.<span>readTextFileSync</span>(file.<span>path</span>);

  
  <span>const</span> markup = <span>Marked</span>.<span>parse</span>(input);
  <span>const</span> renderedContent = <span>render</span>(markup.<span>content</span>, {
     <span>img</span>: <span>() =&gt;</span> <span>(<span>text</span>) =&gt;</span> <span>`&lt;image src=&#34;/<span>${text}</span>&#34; /&gt;`</span>,
  });

  <span>Deno</span>.<span>writeTextFileSync</span>(
    <span>`./b/<span>${paramCase(markup.meta.title)}</span>.html`</span>,
      <span>render</span>(<span>Deno</span>.<span>readTextFileSync</span>(<span>&#34;./templates/post.mustache&#34;</span>), {
        <span>content</span>: renderedContent,
        <span>title</span>: markup.<span>meta</span>.<span>title</span>,
        <span>date</span>: markup.<span>meta</span>.<span>date</span>,
      }),
  );
}
</code></pre>
<p>I&#39;m introducing a <a href="https://mustache.github.io/">mustache</a> rendering pass here,
where <code>./templates/post.mustache</code> maybe looks, oversimplified, something like:</p>

<pre><code><span>&lt;!DOCTYPE <span>html</span>&gt;</span>
<span>&lt;<span>html</span>&gt;</span>
  <span>&lt;<span>head</span>&gt;</span>
    <span>&lt;<span>title</span>&gt;</span>{{title}}<span>&lt;/<span>title</span>&gt;</span>
  <span>&lt;/<span>head</span>&gt;</span>

  <span>&lt;<span>body</span>&gt;</span>
   <span>&lt;<span>article</span>&gt;</span>
     <span>&lt;<span>h1</span>&gt;</span>{{title}}<span>&lt;/<span>h1</span>&gt;</span>
     <span>&lt;<span>sub</span>&gt;</span>{{date}}<span>&lt;/<span>sub</span>&gt;</span>
     <span>&lt;<span>div</span>&gt;</span>{{content}}<span>&lt;/<span>div</span>&gt;</span>
   <span>&lt;/<span>article</span>&gt;</span>
  <span>&lt;/<span>body</span>&gt;</span>
<span>&lt;/<span>html</span>&gt;</span>
</code></pre>
<p>Mustache lets me pass in variables that can be in scope during rendering, which
allows each post to define its own title and date and any other metadata I want
to interpolate in the yaml frontmatter. I can also do neat things like the
<code>img</code> helper lambda passed into the first pass render above:</p>

<pre><code><span>const</span> renderedContent = <span>render</span>(markup.<span>content</span>, {
  <span>img</span>: <span>() =&gt;</span> <span>(<span>text</span>) =&gt;</span> <span>`&lt;image src=&#34;/<span>${text}</span>&#34; /&gt;`</span>,
});
</code></pre>
<p>Inside a post, now I can use this like a function like so:</p>

<pre><code>{{#img}}name-of-file.jpg{{/img}}
</code></pre>
<p>I hope you can see how flexible and easy this could be for extending things!</p>
<p>This is basically all it does. The code I&#39;ve ended up with has a couple more steps
that flow straightforwardly from what I&#39;ve already shown above... I render an archive
page, and an RSS feed, and shuffle the logic around a bit to be more modular
and also have a set of options that can be passed in. <a href="https://github.com/jfo/ssgd/blob/b293b737c308ebe5c5e7c75625ce063171adb17b/lib/index.js">You can see the current
source
here.</a></p>

<p>I&#39;m using libraries that fit my use case really well. If I had to start from
&#34;write a markdown parser/generator&#34; this would be a longer first post. The fact
that it supports <em>frontmatter</em> out of the box like that even is quite the
stroke of luck.</p>
<p>Deno is <em>much more</em> &#34;batteries included&#34; than node ever was. <code>ensureDirSync</code>
and <code>expandGlobSync</code> are just part of the standard library in deno. In node,
the former requires a tiny bit of ceremony, but the latter necessitates a
<a href="https://www.npmjs.com/package/recursive-readdir">whole-ass library</a>. Classic
node. I am not 100 sold on Deno but it&#39;s quite pleasant to work with on such a
low stakes project.</p>
<p>I may add more features to this generator and/or write more about it in the
future but I hope this has demonstrated how easy it was to cobble something
together that genuinely does fulfill my modest needs and provides me with a lot
of benefit in terms of writing comfortably.</p>
</div></div>
  </body>
</html>
