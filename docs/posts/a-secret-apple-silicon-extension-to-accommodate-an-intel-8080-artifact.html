<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bytecellar.com/2022/11/16/a-secret-apple-silicon-extension-to-accommodate-an-intel-8080-artifact/">Original</a>
    <h1>A secret Apple Silicon extension to accommodate an Intel 8080 artifact</h1>
    
    <div id="readability-page-1" class="page"><div id="post-7260">
					

					<!-- .entry-meta -->

					<div>
						
<p>Lately I’ve been spending time on <a href="https://en.wikipedia.org/wiki/Mastodon_(software)">Mastodon</a> for … reasons. Here’s my link: <a href="https://oldbytes.space/@blakespot">https://oldbytes.space/@blakespot</a>. In my recently active time on the platform, I have found quite a few excellent retrocomputing posts by creative members of the community. One such post, by <a href="https://mastodon.social/@dougall">Dougall</a>, links to his blog post entitled “<a href="https://dougallj.wordpress.com/2022/11/09/why-is-rosetta-2-fast/">Why is Rosetta 2 fast?</a>“. </p>


<div>
<figure><img src="https://bytecellar.com/wp-content/uploads/2022/11/M1max_die.jpg" alt="Apple M1 Max die" width="326" height="355" srcset="https://bytecellar.com/wp-content/uploads/2022/11/M1max_die.jpg 628w, https://bytecellar.com/wp-content/uploads/2022/11/M1max_die-275x300.jpg 275w" sizes="(max-width: 326px) 100vw, 326px"/></figure></div>


<p><a href="https://en.wikipedia.org/wiki/Rosetta_(software)#Rosetta_2">Rosetta 2</a> is the <a href="https://en.wikipedia.org/wiki/Ahead-of-time_compilation">ahead-of-time</a> compile translator that’s part of macOS Big Sur (and later) that, upon launch of an x64 Intel binary, translates it to 64-bit ARM code for execution on ARM-based Apple Silicon processors before execution. It is <em>not</em> a real-time emulator. It translates the entire binary — once — at launch time, making best-guess choices along the way. Dougall delves into various aspects of Rosetta 2 in an effort to explain why it is so performant; in many instances the translated binary runs faster on Apple Silicon than on the fastest Intel machines that Apple has ever released. It’s impressive. </p>



<p> It’s a fascinating read for a tech nerd like me that has a particular interest in OS technology. But one detail of the post really grabbed my attention. </p>



<blockquote><p><strong>Apple’s secret extension</strong></p></blockquote>



<p>Intrigued by mention of this “secret extension,” I reached out to the author and asked if he could expand on what Apple has done here. And, he obliged. As he explained in <a href="https://oldbytes.space/@blakespot/109321173740133064">his multi-part Mastodon response</a>:</p>



<blockquote><p>So, both the “adjust flag” (AF) and the “parity flag” (PF) come from the <a href="https://en.wikipedia.org/wiki/Intel_8080">8080-family CPUs</a> from the 1970s. Today they’re almost completely unused. The parity flag is set if, in the last eight bits of the result, the number of set-bits is odd. Otherwise, it’s cleared. The adjust flag is set if there’s a “carry out” from the low four-bits of the addition (and otherwise cleared). This was used for binary-coded decimal – that flag would indicate a carry from one 4-bit digit to the next.</p></blockquote>



<p>This fascinated me. While almost no modern applications read these AF and PF bits, Apple — who make their own CPUs and can control the entire process — put in place a hardware step to increase performance when running translated x64 code on their own processors. I love it. Apple’s move here demonstrates the benefits of their position in controlling all aspects of the systems. A generic Snapdragon ARM SoC, say,  would deliver notably less performance in this specific scenario that is critically important to Mac users.</p>



<p>I quite relish such minor details as this in the engineering of next generation hardware and wanted to share them with readers who might find a similar appreciation. </p>



<p>Dougall Johnson, who provided this insight into the M1 and family, is driving an effort to reverse engineer and document the Apple G13 GPU architecture (used by the M1) as well as to document the Apple Firestorm/Icestorm CPU microarchitecture. His work towards these ends can be found on GitHub at these respective links: <a href="https://github.com/dougallj/applegpu">Apple GPU</a>, <a href="https://github.com/dougallj/applecpu">Apple CPU</a>.</p>
											</div><!-- .entry-content -->


					<div><p>
						This entry was posted in <a href="https://bytecellar.com/category/macintosh/" rel="category tag">Macintosh</a>, <a href="https://bytecellar.com/category/os/" rel="category tag">OS</a> and tagged <a href="https://bytecellar.com/tag/m2/" rel="tag">M2</a>. Bookmark the <a href="https://bytecellar.com/2022/11/16/a-secret-apple-silicon-extension-to-accommodate-an-intel-8080-artifact/" title="Permalink to A Secret Apple Silicon Extension to Accommodate an Intel 8080 Artifact" rel="bookmark">permalink</a>.											</p></div><!-- .entry-utility -->
				</div></div>
  </body>
</html>
