<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://silent-tower.net/projects/visual-overview-malloc">Original</a>
    <h1>Visual overview of a custom malloc() implementation</h1>
    
    <div id="readability-page-1" class="page"><article>

<p>C programmers will undoubtedly recognize the standard function <code>malloc()</code>, the language&#39;s <a href="https://en.wikipedia.org/wiki/C_dynamic_memory_allocation">memory allocator</a> and close confident of everyone&#39;s favorite segfaults. <code>malloc()</code> is the mechanism through which programs obtain memory at runtime, and it often ends up being the primary way in which objects are created and managed. Considering this central status, I&#39;m surprised that most programmers treat it as a black box. This post is a bit of an excuse to tell you more about what happens under-the-hood and look at one possible implementation.</p>
<p>In a typical use case, memory is allocated by calling <code>malloc()</code> with a requested number of bytes as parameter. <code>malloc()</code> returns a pointer through which the memory can be used before being returned to the system by calling <code>free()</code> :</p>
<div><table><tbody><tr><td></td><td><div><pre><span></span><code><span>/* Allocate memory for a structure of type [struct article] */</span>
<span>struct</span><span> </span><span>article</span><span> </span><span>*</span><span>my_article</span><span> </span><span>=</span><span> </span><span>malloc</span><span>(</span><span>sizeof</span><span> </span><span>*</span><span>my_article</span><span>);</span>

<span>if</span><span>(</span><span>my_article</span><span> </span><span>!=</span><span> </span><span>NULL</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>/* ... use *my_article ... */</span>
<span>    </span><span>free</span><span>(</span><span>my_article</span><span>);</span>
<span>}</span>
</code></pre></div></td></tr></tbody></table></div>

<p>This simple piece of code raises at least three important questions:</p>
<ul>
<li>Where does the memory actually come from?</li>
<li>How are we able to allocate variables of any type without even telling <code>malloc()</code> the type that we want?</li>
<li>How does <code>malloc()</code> keep track of the address and size of everything we allocated?</li>
</ul>
<p>Let&#39;s go on a little adventure to answer all of these.</p>
<p><em>TL;DR for avid readers: it&#39;s a segregated best-fit with 16 classes, single-threaded, very standard.</em></p>

<hr/>
<h2 id="the-heap-originates-from-the-system">The heap originates from the system<a href="#the-heap-originates-from-the-system" title="Link to this section">#</a></h2>
<p>The first question <em>“Where does the memory actually come from?”</em> leads us into system land, since the short answer that you might expect is <em>the operating system is providing it</em>. That&#39;s fine and all, but how do we get from that abstract concept to an actual pointer that we can write to?</p>
<h3 id="in-a-classical-userspace">In a classical userspace<a href="#in-a-classical-userspace" title="Link to this section">#</a></h3>
<p>On classical operating systems, each userspace process lives in its own <a href="https://en.wikipedia.org/wiki/Virtual_address_space"><em>address space</em></a>, where its code, libraries, and data are all loaded. Having separate address spaces for each processes is a key design feature for operating systems, and I&#39;d get lost if I talked about why this is. The TL;DR is that it avoids processes reading or writing each other&#39;s memory (which nowadays is mostly for security) and that it&#39;s managed in hardware by an <a href="https://en.wikipedia.org/wiki/Memory_management_unit">MMU</a>.</p>
<p>The exact layout of the address space depends on the operating system. It can be anything; frankly you could make one up for breakfast and be fine.<sup id="fnref:2-ASLR"><a href="#fn:2-ASLR">(1)</a></sup> A simple example might look something like this (we&#39;ll go over the contents in a minute):</p>
<figure>
  <img src="https://silent-tower.net/static/malloc-memory-map.png"/>
  <figcaption>Typical process address space (arbitrary addresses for illustration).</figcaption>
</figure>

<p>Such an address space is called a <em>virtual address space</em> because it doesn&#39;t actually own any memory. The real memory in the computer (the RAM chip) exists as a big block<sup id="fnref:2-FragmentedMemoryMap"><a href="#fn:2-FragmentedMemoryMap">(2)</a></sup> in the so-called <em>physical address space;</em> but of course any process with full access to the entire RAM would be cybergod, so only the <a href="https://en.wikipedia.org/wiki/Kernel_(operating_system)">kernel</a> is allowed to use it. Normal processes get access to memory when the kernel lends them some by <em>mapping</em> it to their virtual address space:</p>
<figure>
  <img src="https://silent-tower.net/static/malloc-paging.png"/>
  <figcaption>Mapping of virtual pages to physical pages by the kernel.</figcaption>
</figure>

<p>This process is called <a href="https://en.wikipedia.org/wiki/Memory_paging"><em>paging</em></a>. Essentially, both the virtual and physical address spaces are divided into <em>pages</em> (of varying size but most commonly 4 kB) and the kernel decides which pages of virtual memory should be mapped to which pages of physical memory. When the program makes a memory access, the CPU checks if the accessed pointer falls into a mapped page. If so, then the associated physical page is accessed. Otherwise, the access is streng verboten and the program crashes with a segfault.<sup id="fnref:2-Segfault"><a href="#fn:2-Segfault">(3)</a></sup> This gives the kernel complete control over what memory processes can read and write, and thus achieves the separation goals I mentioned earlier.</p>
<p>So let&#39;s go back to the layout from earlier. In it, we find:</p>
<ul>
<li><strong>Program code</strong>: This is loaded straight from the program&#39;s executable file.</li>
<li><strong>Libraries</strong>: Dynamic libraries loaded at startup, basically the same as code.</li>
<li><strong>Static data segment</strong>: This segment contains global and static variables.</li>
<li><strong>The stack</strong>: This is where functions&#39; local variables are stored.</li>
<li><strong>The heap</strong>: This is the memory managed by <code>malloc()</code>.</li>
</ul>
<p>Since code is read-only and the data segment is static (meaning its size is fixed before running the program), the only two regions that can grow during execution are the stack and heap. The stack itself is quite small; on Linux, <code>ulimit -s</code> will tell you its maximum size, which is typically 8 MB. It also comes with very strict lifetime limits, since any object created there is destroyed when the function creating it returns. This leaves the heap. On your personal computer or phone, heap data accounts for a vast majority of memory used by programs. When your web browser hogs 5 GB of memory then it&#39;s basically 5 GB of heap.<sup id="fnref:2-Mmap"><a href="#fn:2-Mmap">(4)</a></sup></p>
<p>Like everything in the virtual address space, heap is created when the kernel maps pages of physical memory at a suitable virtual address. So the answer to the question <em>“where does the memory come from?”</em> is <em>“the kernel maps new pages into the address space”</em>. The process requests this by invoking the syscall <a href="https://www.man7.org/linux/man-pages/man2/sbrk.2.html"><code>sbrk(2)</code></a>, and if the kernel allows it then new pages are mapped and pointers to the pages become valid. You can see this in action in pretty much any Linux-supporting allocator. For example, the glibc allocator implements this “get more memory” primitive in <a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/morecore.c;h=0660c759d0b323f8eb828f0a92e6edac5e7949dd;hb=HEAD"><code>morecore.c</code></a> and the call boils down to an indirect invocation of <code>sbrk(2)</code>.</p>
<p>So, to sum up: <code>malloc()</code> gets memory by asking the kernel with <code>sbrk(2)</code> and the kernel provides it by mapping entire pages (of 4 kB or more). Then, <code>malloc()</code>&#39;s job is to split up these pages into blocks of user-requested size while keeping track of what&#39;s used and what&#39;s free.</p>
<h3 id="in-embedded-systems">In embedded systems<a href="#in-embedded-systems" title="Link to this section">#</a></h3>
<p>Of course, not all systems run a full-fledged kernel with paging-based virtual memory. There are plenty of other options, but the core mechanics remain the same. On many embedded systems, a fixed region of memory is provided for the heap; in that case <code>malloc()</code> just cannot expand. Allocators are pretty good at dealing with fixed-, variable- and pineapple-shaped memory so they don&#39;t really care. The core of the design is really how they split and manage the memory they get.</p>
<h2 id="making-variables-out-of-raw-memory-using-maximal-alignment">Making variables out of raw memory using “maximal alignment”<a href="#making-variables-out-of-raw-memory-using-maximal-alignment" title="Link to this section">#</a></h2>
<p>So far, I&#39;ve only talked about memory as raw data — sequences of bytes arranged in pages that the program can read and write. But what we want from <code>malloc()</code> is really to create variables. The C language constantly insists on having us declare the type of variables, so how are we able to create them with <code>malloc()</code> from just a size?</p>
<div><table><tbody><tr><td></td><td><div><pre><span></span><code><span>/* Local variable requires a type... */</span>
<span>int</span><span> </span><span>i</span><span>;</span>
<span>/* ... but somehow malloc() doesn&#39;t? */</span>
<span>int</span><span> </span><span>*</span><span>j</span><span> </span><span>=</span><span> </span><span>malloc</span><span>(</span><span>4</span><span>);</span>
</code></pre></div></td></tr></tbody></table></div>

<p>You might think that I did declare the type for the allocation by writing <code>int *j</code>, but that&#39;s not the case. In terms of typing the second definition really has two steps: <em>first</em> the compiler types <code>malloc(4)</code>, on its own without any context, <em>then</em> it checks that the assignment is legal, ie. that the type of <code>malloc(4)</code> is convertible to <code>int *</code>. This is an important property of C: expressions are always typed out of context, independently from what you do with it. C++ programmers may be more familiar with this concept as “return types do not contribute to overload resolution”.<sup id="fnref:2-BottomUpTyping"><a href="#fn:2-BottomUpTyping">(5)</a></sup></p>
<p>What&#39;s happening here is that <code>malloc(4)</code> is of type <code>void *</code>, i.e. a universal pointer, which is convertible to any non-function pointer type. No information related to the type of <code>j</code> is communicated to <code>malloc()</code>. So the question remains: how is <code>malloc()</code> able to allocate suitable memory without knowing the desired type?</p>
<p>It turns out that <em>suitable memory</em> really boils down to two things. In order to contain a variable of type <code>T</code>, a region of memory must:</p>
<ol>
<li>Have a size at least <code>sizeof(T)</code>;</li>
<li>Have an alignment greater than or equal to the alignment of <code>T</code>.</li>
</ol>
<p><a href="https://en.wikipedia.org/wiki/Data_structure_alignment">Alignment</a> refers to the highest power of two which divides an address. For architectural reasons values of certain basic types are constrained to be stored on aligned boundaries. Typically, primitive values occupying <code>N</code> bytes (with <code>N</code> a power of two) will be stored exclusively at addresses that are multiples of <code>N</code>. So a 1-byte <code>char</code> can be stored at any address, but a 2-byte <code>short</code> only on even addresses, a 4-byte <code>int</code> on addresses that are multiples of 4 (called “4-aligned”), etc.</p>
<figure>
  <img src="https://silent-tower.net/static/malloc-alignment.png"/>
  <figcaption>All possible ways to store suitably-aligned values.</figcaption>
</figure>

<p>Only basic types (integers, floating-point numbers and pointers) have architectural alignment requirements, so if you work out the layout of structures, unions and other composite types, you will find that every type ends up with the alignment requirement of a basic type.<sup id="fnref:2-Overalignment"><a href="#fn:2-Overalignment">(6)</a></sup> This means that the largest alignment requirement of any basic type (<a href="https://en.cppreference.com/w/c/types/max_align_t"><code>max_align_t</code> in C++</a>, usually 4 bytes for 32-bit architectures and 8 bytes for 64-bit architectures) is suitable for <em>every single type in the language</em>.</p>
<p>The existence of a universal alignment solves our mystery, since <code>malloc()</code> can simply return maximally-aligned pointers in order to accommodate any data type. Unsurprisingly, this is exactly what good ol&#39; C99 explicitly requires it to do [<a href="#ref-ISOC99" id="cite-ISOC99">ISOC99</a> §7.20.3.1]:</p>
<blockquote>
<p>The order and contiguity of storage allocated by successive calls to the <code>calloc</code>, <code>malloc</code>, and <code>realloc</code> functions is unspecified. The pointer returned if the allocation succeeds is suitably aligned so that it may be assigned to a pointer to any type of object and then used to access such an object or an array of such objects in the space allocated (until the space is explicitly deallocated).</p>
</blockquote>
<p>Most implementations of <code>malloc()</code> are parametrized by this alignment. In my case, I&#39;m working on a 32-bit architecture so the highest alignment I have to work with is 4. As you will see shortly, this bleeds onto block and header sizes, which are going to be multiples of 4.</p>
<h2 id="tour-of-a-segregated-best-fit-implementation">Tour of a segregated best-fit implementation<a href="#tour-of-a-segregated-best-fit-implementation" title="Link to this section">#</a></h2>
<p>Ok, so an implementation of <code>malloc()</code> essentially has to:</p>
<ul>
<li>Manage an area of memory which is either fixed or extended by mapping new pages with <code>sbrk()</code>;</li>
<li>Carve out maximally-aligned blocks to respond to allocations;</li>
<li>Keep track of enough information to make sure no two live blocks ever intersect.</li>
</ul>
<p>The third point is where all the variety in implementation comes from. There&#39;s about a million designs for memory allocation strategies, data structures, not to mention garbage collectors, and I&#39;d by lying if I pretended I could give you a visual overview of <i>that</i>. You can find a general introduction in the fantastic paper <em>Dynamic storage allocation: A survey and critical review</em> [<a href="#ref-Wilson1995" id="cite-Wilson1995">Wilson1995</a>].</p>
<p>And that&#39;s about all the generalities I have for you. The rest of this article will go through an implementation of the segregated best-fit algorithm that I wrote for gint. You can find the original code in <a href="https://silent-tower.net/projects/gint">gint</a>&#39;s repository at <a href="https://gitea.planet-casio.com/Lephenixnoir/gint/src/commit/70dccc29dad46b5480ea601aec79134de60cf0c4/src/kmalloc/arena_gint.c"><code>src/kmalloc/arena_gint.c</code></a>; here I&#39;ll start from intuitions and work my way up to (hopefully) understandable versions of <code>malloc()</code> and <code>free()</code> by alternating visuals and C code.</p>
<p>Note that the code is meant to be readable without context but isn&#39;t quite complete (some initialization is missing mostly).</p>
<h3 id="block-structure-and-navigating-the-sequence">Block structure and navigating the sequence<a href="#block-structure-and-navigating-the-sequence" title="Link to this section">#</a></h3>
<p>As is typical with general-purpose allocators, I keep track of the metadata for each allocation in a short header before the allocated space itself. Which means that the heap region is made of blocks of the following shape:</p>
<figure>
  <img src="https://silent-tower.net/static/malloc-block-structure.png"/>
  <figcaption>Block structure depending on use status and size.</figcaption>
</figure>

<p>The simplest type of block is used blocks: they consist of a 4-byte header followed by user data represented by the hashed region. <code>malloc()</code> returns a pointer to the user data and that&#39;s all you ever see from the outside. The header records the size of the block and information that&#39;s useful for navigating the heap to find other blocks. This is the corresponding structure definition:</p>
<div><table><tbody><tr><td></td><td><div><pre><span></span><code><span>typedef</span><span> </span><span>struct</span><span> </span><span>{</span>
<span>    </span><span>uint</span><span>            </span><span>:</span><span>5</span><span>;</span>
<span>    </span><span>uint</span><span> </span><span>last</span><span>       </span><span>:</span><span>1</span><span>;</span><span>     </span><span>/* Marks the last block in the sequence */</span>
<span>    </span><span>uint</span><span> </span><span>used</span><span>       </span><span>:</span><span>1</span><span>;</span><span>     </span><span>/* Whether the block is used */</span>
<span>    </span><span>uint</span><span> </span><span>prev_used</span><span>  </span><span>:</span><span>1</span><span>;</span><span>     </span><span>/* Whether the previous block is used (boundary tag) */</span>
<span>    </span><span>uint</span><span> </span><span>size</span><span>       </span><span>:</span><span>24</span><span>;</span><span>    </span><span>/* Block size in bytes (&lt; 16 MB) */</span>
<span>}</span><span> </span><span>block_t</span><span>;</span>
</code></pre></div></td></tr></tbody></table></div>

<p>Free blocks have the same 4-byte header, but they also contain extra data in their footers. That&#39;s the nice thing about free blocks: no data is being stored, so we might as well use the space to maintain the data structure. <code>prev_link</code> and <code>next_link</code> are used to connect some linked lists; I&#39;ll discuss that in a minute. All we need to know for now is that these are pointers to other blocks.</p>
<p>Blocks are stored immediately next to each other with no spacing, forming a long sequence that covers the entire heap region (the <em>arena</em>), apart from a small index structure placed at the start:</p>
<figure>
  <img src="https://silent-tower.net/static/malloc-sequence.png"/>
  <figcaption>Arrangement of blocks in heap memory.</figcaption>
</figure>

<p>The two non-trivial flags in the <code>block_t</code> header are both related to this sequence: <code>last</code> marks the last block, and <code>prev_used</code> is a copy of the previous block&#39;s <code>used</code> flag, which has the following (quite tasty!) use.</p>
<p>Notice how we can pretty easily navigate the sequence forwards: from a pointer to the start of a block we can find a pointer to its end (ie. to the start of the next block) because the block&#39;s size is indicated in the header.</p>
<figure>
  <img src="https://silent-tower.net/static/malloc-next-block.png"/>
  <figcaption>Forward navigation in the block sequence.</figcaption>
</figure>

<p>The code is as straightforward as you&#39;d expect:</p>
<div><table><tbody><tr><td></td><td><div><pre><span></span><code><span>block_t</span><span> </span><span>*</span><span>next_block</span><span>(</span><span>block_t</span><span> </span><span>*</span><span>b</span><span>)</span>
<span>{</span>
<span>    </span><span>if</span><span>(</span><span>b</span><span>-&gt;</span><span>last</span><span>)</span>
<span>        </span><span>return</span><span> </span><span>NULL</span><span>;</span>
<span>    </span><span>return</span><span> </span><span>(</span><span>void</span><span> </span><span>*</span><span>)</span><span>b</span><span> </span><span>+</span><span> </span><span>sizeof</span><span>(</span><span>block_t</span><span>)</span><span> </span><span>+</span><span> </span><span>b</span><span>-&gt;</span><span>size</span><span>;</span>
<span>}</span>
</code></pre></div></td></tr></tbody></table></div>

<p>Well, it turns out that free blocks are set up so that you can also do the opposite and find the start of a free block from its end. This boils down to determining the size from the footer, which is indeed possible:</p>
<ul>
<li>Free blocks of size ≥ 12 simply store their size at offset -12 from the end.</li>
<li>Free blocks of size 8 appear completely filled by <code>prev_link</code> and <code>next_link</code>, but if we look closely it turns out that there are actually 4 bits available. This is because <code>prev_link</code> and <code>next_link</code> are pointers to other blocks, thus multiples of 4 (since blocks are 4-aligned). Therefore, the 2 low-order bits of both pointers are always 0, and I can steal one of them to store a flag that identifies 8-byte blocks.</li>
</ul>
<p>So now, when we have a pointer to the end of a free block, we can look up the low-order bit of <code>next_link</code>; if it&#39;s 1 the block is of size 8, otherwise we can read the size from offset -12. In both cases we can recover a pointer to the start of the block:</p>
<figure>
  <img src="https://silent-tower.net/static/malloc-prev-block.png"/>
  <figcaption>Backwards navigation through free blocks in the block sequence.</figcaption>
</figure>

<p>Of course, in order to use this for reliable backwards navigation we need to know whether the previous block is in fact free or not. This is the purpose of the <code>prev_used</code> flag in the block header, and the technique as a whole is known as the <em>boundary tag optimization</em> — paying a single bit for the luxury of navigating back through empty blocks.</p>
<div><table><tbody><tr><td></td><td><div><pre><span></span><code><span>block_t</span><span> </span><span>*</span><span>previous_block_if_free</span><span>(</span><span>block_t</span><span> </span><span>*</span><span>b</span><span>)</span>
<span>{</span>
<span>    </span><span>if</span><span>(</span><span>b</span><span>-&gt;</span><span>prev_used</span><span>)</span>
<span>        </span><span>return</span><span> </span><span>NULL</span><span>;</span>
<span>    </span><span>uint32_t</span><span> </span><span>*</span><span>footer</span><span> </span><span>=</span><span> </span><span>(</span><span>void</span><span> </span><span>*</span><span>)</span><span>b</span><span>;</span>
<span>    </span><span>uint32_t</span><span> </span><span>previous_size</span><span> </span><span>=</span><span> </span><span>(</span><span>footer</span><span>[</span><span>-1</span><span>]</span><span> </span><span>&amp;</span><span> </span><span>1</span><span>)</span><span> </span><span>?</span><span> </span><span>8</span><span> </span><span>:</span><span> </span><span>footer</span><span>[</span><span>-3</span><span>];</span>
<span>    </span><span>return</span><span> </span><span>(</span><span>void</span><span> </span><span>*</span><span>)</span><span>b</span><span> </span><span>-</span><span> </span><span>previous_size</span><span> </span><span>-</span><span> </span><span>sizeof</span><span>(</span><span>block_t</span><span>);</span>
<span>}</span>
</code></pre></div></td></tr></tbody></table></div>

<p>The benefit of this little operation should be clear by the next section, but if you&#39;re curious you can already try to figure it out.</p>
<p>Quick aside. Tightly packing blocks is an obvious choice when considering memory usage and the need to not waste any space. It also makes writing out-of-bounds of dynamically-allocated arrays quite lethal, as that immediately corrupts the next block, basically guaranteeing a crash at the next <code>malloc()</code> or <code>free()</code>. This might seem like a problem but it&#39;s actually a good thing: it makes out-of-bounds writes more visible which leads to empirically faster bug resolutions (in fact, introducing this new allocator in gint led to a mini-wave of new crashes that all turned out to be application bugs).</p>
<h3 id="merging-and-splitting-in-the-sequence">Merging and splitting in the sequence<a href="#merging-and-splitting-in-the-sequence" title="Link to this section">#</a></h3>
<p>As this point you might be wondering how we get from an empty, freshly-initialized heap to the mess of a sequence that I&#39;ve pictured previously, with data spread around instead of being nicely arranged on one end with a nice, large block of free memory on the other end.</p>
<p>The short answer is you can&#39;t avoid the mess. The user is completely in control of allocated blocks, and in particular they can <em>free them in any order</em>, creating holes at any moments. Since we don&#39;t know how long blocks will live when they are allocated (... the user might not either!) it&#39;s hard to plan ahead.</p>
<p>There&#39;s one thing we can do to keep the sequence as tidy as possible, though: we can merge adjacent free blocks to make larger blocks. This increases the chance that we can answer large <code>malloc()</code> requests and ensures that if the user were to free every block we&#39;d recover one large empty block spanning the entire heap.</p>
<p>With this simple idea in mind, we can now work out what <code>malloc()</code> and <code>free()</code> will have to do. We&#39;ll stick to a general procedure for now and go over the actual code at the end.</p>
<p><i><code>malloc(N)</code>:</i></p>

<ol>
<li>Search for <code>b</code>, the smallest free block of size ≥ <code>N</code> in the sequence.</li>
<li>If none is found, we&#39;re out of memory, return <code>NULL</code> (... or use <code>sbrk()</code> to get more and retry).</li>
<li>If the size of <code>b</code> is strictly larger than <code>N</code>+4, split <code>b</code> in two to keep some free memory.</li>
<li>Mark <code>b</code> as used and return it.</li>
</ol>
<p>Step 1 is what makes this algorithm a <em>best-fit</em>, as it finds the “best” block for the allocation (the one that&#39;s as close as possible to the requested size). Confusingly this isn&#39;t necessarily the best choice<sup id="fnref:2-BestFitFragmentation"><a href="#fn:2-BestFitFragmentation">(7)</a></sup>, and there are many other strategies. Anyway, the interesting part for now is that if we decide on a block that&#39;s larger than needed, we split it off so we don&#39;t waste any memory:</p>
<figure>
  <img src="https://silent-tower.net/static/malloc-split.png"/>
  <figcaption>Splitting allocated blocks when they&#39;re larger than needed.</figcaption>
</figure>

<p>The function to do that is pretty straightforward, the only subtlety being the maintenance of <code>prev_used</code> flags in nearby blocks.</p>
<div><table><tbody><tr><td><div><pre><span> 1</span>
<span> 2</span>
<span> 3</span>
<span> 4</span>
<span> 5</span>
<span> 6</span>
<span> 7</span>
<span> 8</span>
<span> 9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span></pre></div></td><td><div><pre><span></span><code><span>block_t</span><span> </span><span>*</span><span>split</span><span>(</span><span>block_t</span><span> </span><span>*</span><span>b</span><span>,</span><span> </span><span>int</span><span> </span><span>N</span><span>)</span>
<span>{</span>
<span>    </span><span>size_t</span><span> </span><span>extra_size</span><span> </span><span>=</span><span> </span><span>b</span><span>-&gt;</span><span>size</span><span> </span><span>-</span><span> </span><span>N</span><span>;</span>
<span>    </span><span>/* Only split if there is enough room left for a new block */</span>
<span>    </span><span>if</span><span>(</span><span>extra_size</span><span> </span><span>&lt;</span><span> </span><span>sizeof</span><span>(</span><span>block_t</span><span>)</span><span> </span><span>+</span><span> </span><span>8</span><span>)</span>
<span>        </span><span>return</span><span> </span><span>NULL</span><span>;</span>

<span>    </span><span>block_t</span><span> </span><span>*</span><span>second</span><span> </span><span>=</span><span> </span><span>(</span><span>void</span><span> </span><span>*</span><span>)</span><span>b</span><span> </span><span>+</span><span> </span><span>sizeof</span><span>(</span><span>block_t</span><span>)</span><span> </span><span>+</span><span> </span><span>N</span><span>;</span>
<span>    </span><span>second</span><span>-&gt;</span><span>last</span><span> </span><span>=</span><span> </span><span>b</span><span>-&gt;</span><span>last</span><span>;</span>
<span>    </span><span>second</span><span>-&gt;</span><span>used</span><span> </span><span>=</span><span> </span><span>false</span><span>;</span>
<span>    </span><span>second</span><span>-&gt;</span><span>prev_used</span><span> </span><span>=</span><span> </span><span>b</span><span>-&gt;</span><span>used</span><span>;</span>
<span>    </span><span>second</span><span>-&gt;</span><span>size</span><span> </span><span>=</span><span> </span><span>extra_size</span><span> </span><span>-</span><span> </span><span>sizeof</span><span>(</span><span>block_t</span><span>);</span>

<span>    </span><span>block_t</span><span> </span><span>*</span><span>third</span><span> </span><span>=</span><span> </span><span>next_block</span><span>(</span><span>second</span><span>);</span>
<span>    </span><span>if</span><span>(</span><span>third</span><span>)</span>
<span>        </span><span>third</span><span>-&gt;</span><span>prev_used</span><span> </span><span>=</span><span> </span><span>second</span><span>-&gt;</span><span>used</span><span>;</span>

<span>    </span><span>b</span><span>-&gt;</span><span>last</span><span> </span><span>=</span><span> </span><span>false</span><span>;</span>
<span>    </span><span>b</span><span>-&gt;</span><span>size</span><span> </span><span>=</span><span> </span><span>N</span><span>;</span>
<span>    </span><span>return</span><span> </span><span>second</span><span>;</span>
<span>}</span>
</code></pre></div></td></tr></tbody></table></div>

<p>Of course we want this splitting to be as temporary as possible; if at any point in the future both blocks are free again, we need them merged back. Fortunately this is fairly easy to track down; all cases of adjacent free blocks are caused by a <code>free()</code>, and we can catch &#39;em all if we simply merge newly-freed blocks with their neighbors.</p>
<p><i><code>free(ptr)</code>:</i></p>

<ol>
<li>Find the associated block <code>b = ptr-4</code>.</li>
<li>Mark <code>b</code> as free.</li>
<li>If the successor of <code>b</code> exists and is free, merge it into <code>b</code>.</li>
<li>If the predecessor of <code>b</code> exists and is free, merge <code>b</code> into it.</li>
</ol>
<p>In the best case where both neighbors are free, the operation looks like this:</p>
<figure>
  <img src="https://silent-tower.net/static/malloc-merge.png"/>
  <figcaption>Merging newly-freed blocks with their free neighbors.</figcaption>
</figure>

<p>Merging is even simpler since we erase headers instead of adding them:</p>
<div><table><tbody><tr><td><div><pre><span> 1</span>
<span> 2</span>
<span> 3</span>
<span> 4</span>
<span> 5</span>
<span> 6</span>
<span> 7</span>
<span> 8</span>
<span> 9</span>
<span>10</span>
<span>11</span>
<span>12</span></pre></div></td><td><div><pre><span></span><code><span>void</span><span> </span><span>merge</span><span>(</span><span>block_t</span><span> </span><span>*</span><span>left</span><span>,</span><span> </span><span>block_t</span><span> </span><span>*</span><span>right</span><span>)</span>
<span>{</span>
<span>  </span><span>size_t</span><span> </span><span>extra_size</span><span> </span><span>=</span><span> </span><span>sizeof</span><span>(</span><span>block_t</span><span>)</span><span> </span><span>+</span><span> </span><span>right</span><span>-&gt;</span><span>size</span><span>;</span>
<span>  </span><span>left</span><span>-&gt;</span><span>last</span><span> </span><span>=</span><span> </span><span>right</span><span>-&gt;</span><span>last</span><span>;</span>
<span>  </span><span>left</span><span>-&gt;</span><span>size</span><span> </span><span>+=</span><span> </span><span>extra_size</span><span>;</span>

<span>  </span><span>/* Footer is updated separately */</span>

<span>  </span><span>block_t</span><span> </span><span>*</span><span>next</span><span> </span><span>=</span><span> </span><span>next_block</span><span>(</span><span>left</span><span>);</span>
<span>  </span><span>if</span><span>(</span><span>next</span><span>)</span>
<span>      </span><span>next</span><span>-&gt;</span><span>prev_used</span><span> </span><span>=</span><span> </span><span>left</span><span>-&gt;</span><span>used</span><span>;</span>
<span>}</span>
</code></pre></div></td></tr></tbody></table></div>

<p>And this is why the boundary tag optimization is useful: it lets us find the previous block if it&#39;s free and merge it, even when we are dropped in the middle of the sequence by the user-provided <code>ptr</code>.</p>
<h3 id="segregated-linked-lists">Segregated linked lists<a href="#segregated-linked-lists" title="Link to this section">#</a></h3>
<p>Now you could go ahead and implement step #1 of the <code>malloc()</code> algorithm (find the smallest block of size ≥ <code>N</code>) naively, by checking every block in the sequence in order. You&#39;d get a working and standard best-fit allocator, which honestly is very much viable for small embedded systems. However, if you have a large heap (say, 1 MB) you&#39;ll end up checking <em>a lot</em> of blocks and programs that allocate frequently will be bottlenecked by the allocator.</p>
<p>Now is the time were you can go on deep, fascinating studies about the allocation patterns of various programs, where you can treat blocks with different lifetimes separately, design better APIs where more information is communicated to enable better memory planning, and otherwise grind the response time down to absolute perfection.</p>
<p>I&#39;m just going to make the easy assumption that the amount of work being done with a block is correlated to its size. So small block means little work means <code>malloc()</code> needs to answer quickly to not be the bottleneck. Large blocks means a lot of work so it&#39;s acceptable to be slower. This is undeniably an approximation, but still generally true.</p>
<p>To speed up the response time for small blocks (which also happen to be the most common), I&#39;m going to partition free blocks into linked lists of related sizes:</p>
<figure>
  <img src="https://silent-tower.net/static/malloc-linked-lists.png"/>
  <figcaption>Segregated linked lists relative to block sequence.</figcaption>
</figure>

<p>These are standard doubly-linked lists using the <code>prev_link</code> and <code>next_link</code> attributes stored in free blocks&#39; footers. Unlike what the figure suggests, blocks in each linked list do <em>not</em> have to sorted by increasing address, it&#39;s just way more readable when represented this way.</p>
<p>The implementation has 16 lists holding blocks of the following sizes, which are easily classified by a small function.</p>
<ul>
<li>Small blocks (14 lists): 8 bytes, 12 bytes, ..., 60 bytes</li>
<li>Medium blocks: 64 — 252 bytes</li>
<li>Large blocks: ≥ 256 bytes</li>
</ul>
<div><table><tbody><tr><td></td><td><div><pre><span></span><code><span>int</span><span> </span><span>size_class</span><span>(</span><span>size_t</span><span> </span><span>size</span><span>)</span>
<span>{</span>
<span>    </span><span>if</span><span>(</span><span>size</span><span> </span><span>&lt;</span><span> </span><span>64</span><span>)</span>
<span>        </span><span>return</span><span> </span><span>(</span><span>size</span><span> </span><span>-</span><span> </span><span>8</span><span>)</span><span> </span><span>&gt;&gt;</span><span> </span><span>2</span><span>;</span>
<span>    </span><span>if</span><span>(</span><span>size</span><span> </span><span>&lt;</span><span> </span><span>256</span><span>)</span>
<span>        </span><span>return</span><span> </span><span>14</span><span>;</span>
<span>    </span><span>return</span><span> </span><span>15</span><span>;</span>
<span>}</span>
</code></pre></div></td></tr></tbody></table></div>

<p>Holding pointers to these lists is the purpose of the <em>index structure</em> I mentioned earlier. It also keeps track of heap statistics, which I&#39;ve left out of this presentation for simplicity.</p>
<div><table><tbody><tr><td></td><td><div><pre><span></span><code><span>typedef</span><span> </span><span>struct</span><span> </span><span>{</span>
<span>    </span><span>block_t</span><span> </span><span>*</span><span>classes</span><span>[</span><span>16</span><span>];</span><span>   </span><span>/* Entry points of segregated linked lists */</span>
<span>    </span><span>stats_t</span><span> </span><span>*</span><span>stats</span><span>;</span><span>         </span><span>/* Statistics (not addressed in this article)  */</span>
<span>}</span><span> </span><span>index_t</span><span>;</span>
</code></pre></div></td></tr></tbody></table></div>

<p>The big idea here is that <em>small requests are generally served in constant time</em> because the first 14 lists with small blocks never need to be traversed. All the blocks in there are interchangeable, so we can always just take the first. Only the last two lists need to go through an actual best-fit search, and we only use them to answer small requests if every suitable small list is empty.</p>
<p>I&#39;ll spare you the code for manipulating the linked lists since it&#39;s very standard. Let&#39;s just say that <code>remove_link()</code> removes a free block from its associated list and <code>prepend_link()</code> adds it back at the start. <code>best_fit(list, N)</code> looks for the smallest block of size ≥ <code>N</code> in a list.</p>
<div><table><tbody><tr><td></td><td><div><pre><span></span><code><span>/* Remove b from its associated linked list */</span>
<span>void</span><span> </span><span>remove_link</span><span>(</span><span>block_t</span><span> </span><span>*</span><span>b</span><span>,</span><span> </span><span>index_t</span><span> </span><span>*</span><span>index</span><span>);</span>
<span>/* Add b to the start of its associated linked list */</span>
<span>void</span><span> </span><span>prepend_link</span><span>(</span><span>block_t</span><span> </span><span>*</span><span>b</span><span>,</span><span> </span><span>index_t</span><span> </span><span>*</span><span>index</span><span>);</span>
<span>/* Find the smallest block of size ≥ N in the list */</span>
<span>block_t</span><span> </span><span>*</span><span>best_fit</span><span>(</span><span>block_t</span><span> </span><span>*</span><span>list</span><span>,</span><span> </span><span>size_t</span><span> </span><span>N</span><span>);</span>
</code></pre></div></td></tr></tbody></table></div>

<p>You&#39;ve probably figured it out by now but this is where the name <em>“segregated best-fit”</em> comes from, as blocks of different sizes are partitioned (segregated) into appropriate doubly-linked lists.</p>
<h3 id="final-implementation-of-malloc-and-free">Final implementation of <code>malloc()</code> and <code>free()</code><a href="#final-implementation-of-malloc-and-free" title="Link to this section">#</a></h3>
<p>We can now write the entire <code>malloc()</code> and <code>free()</code> functions. In <code>malloc()</code>, we round the request size up and then look for a free block in the associated linked list. If the list is empty, we go up to the next list until we either find a large block that can be split, or realize that we&#39;re completely out of memory.</p>
<div><table><tbody><tr><td><div><pre><span> 1</span>
<span> 2</span>
<span> 3</span>
<span> 4</span>
<span> 5</span>
<span> 6</span>
<span> 7</span>
<span> 8</span>
<span> 9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span></pre></div></td><td><div><pre><span></span><code><span>index_t</span><span> </span><span>*</span><span>index</span><span> </span><span>=</span><span> </span><span>/* ... */</span><span>;</span>

<span>void</span><span> </span><span>*</span><span>malloc</span><span>(</span><span>size_t</span><span> </span><span>size</span><span>)</span>
<span>{</span>
<span>    </span><span>/* Round request up to a multiple of 4 that is at least 8 */</span>
<span>    </span><span>size</span><span> </span><span>=</span><span> </span><span>(</span><span>size</span><span> </span><span>&lt;</span><span> </span><span>8</span><span>)</span><span> </span><span>?</span><span> </span><span>8</span><span> </span><span>:</span><span> </span><span>((</span><span>size</span><span> </span><span>+</span><span> </span><span>3</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>~</span><span>3</span><span>);</span>

<span>    </span><span>/* Try to find a class that has a free block available */</span>
<span>    </span><span>block_t</span><span> </span><span>*</span><span>alloc</span><span> </span><span>=</span><span> </span><span>NULL</span><span>;</span>
<span>    </span><span>for</span><span>(</span><span>int</span><span> </span><span>c</span><span> </span><span>=</span><span> </span><span>size_class</span><span>(</span><span>size</span><span>);</span><span> </span><span>c</span><span> </span><span>&lt;=</span><span> </span><span>15</span><span> </span><span>&amp;&amp;</span><span> </span><span>!</span><span>alloc</span><span>;</span><span> </span><span>c</span><span>++</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>block_t</span><span> </span><span>*</span><span>list</span><span> </span><span>=</span><span> </span><span>index</span><span>-&gt;</span><span>classes</span><span>[</span><span>c</span><span>];</span>
<span>        </span><span>/* For the 14 small classes any block is fine, take the first */</span>
<span>        </span><span>alloc</span><span> </span><span>=</span><span> </span><span>(</span><span>c</span><span> </span><span>&lt;</span><span> </span><span>14</span><span>)</span><span> </span><span>?</span><span> </span><span>list</span><span> </span><span>:</span><span> </span><span>best_fit</span><span>(</span><span>list</span><span>,</span><span> </span><span>size</span><span>);</span>
<span>    </span><span>}</span>
<span>    </span><span>if</span><span>(</span><span>!</span><span>alloc</span><span>)</span>
<span>        </span><span>return</span><span> </span><span>NULL</span><span>;</span>

<span>    </span><span>/* Remove the chosen block from the index */</span>
<span>    </span><span>remove_link</span><span>(</span><span>alloc</span><span>,</span><span> </span><span>index</span><span>);</span>

<span>    </span><span>/* If it&#39;s larger than needed, split it and reinsert the leftover */</span>
<span>    </span><span>block_t</span><span> </span><span>*</span><span>rest</span><span> </span><span>=</span><span> </span><span>split</span><span>(</span><span>alloc</span><span>,</span><span> </span><span>size</span><span>);</span>
<span>    </span><span>if</span><span>(</span><span>rest</span><span>)</span>
<span>        </span><span>prepend_link</span><span>(</span><span>rest</span><span>,</span><span> </span><span>index</span><span>);</span>

<span>    </span><span>/* Mark the block as used and return a pointer to its data */</span>
<span>    </span><span>block_t</span><span> </span><span>*</span><span>next</span><span> </span><span>=</span><span> </span><span>next_block</span><span>(</span><span>alloc</span><span>);</span>
<span>    </span><span>alloc</span><span>-&gt;</span><span>used</span><span> </span><span>=</span><span> </span><span>true</span><span>;</span>
<span>    </span><span>if</span><span>(</span><span>next</span><span>)</span>
<span>        </span><span>next</span><span>-&gt;</span><span>prev_used</span><span> </span><span>=</span><span> </span><span>true</span><span>;</span>
<span>    </span><span>return</span><span> </span><span>(</span><span>void</span><span> </span><span>*</span><span>)</span><span>alloc</span><span> </span><span>+</span><span> </span><span>sizeof</span><span>(</span><span>block_t</span><span>);</span>
<span>}</span>
</code></pre></div></td></tr></tbody></table></div>

<p>In <code>free()</code>, we mark the block as free, merge it with its free neighbors (after removing them from their own linked lists) and finally insert the resulting block back into the index.</p>
<div><table><tbody><tr><td><div><pre><span> 1</span>
<span> 2</span>
<span> 3</span>
<span> 4</span>
<span> 5</span>
<span> 6</span>
<span> 7</span>
<span> 8</span>
<span> 9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span></pre></div></td><td><div><pre><span></span><code><span>void</span><span> </span><span>free</span><span>(</span><span>void</span><span> </span><span>*</span><span>ptr</span><span>)</span>
<span>{</span>
<span>    </span><span>block_t</span><span> </span><span>*</span><span>b</span><span> </span><span>=</span><span> </span><span>ptr</span><span> </span><span>-</span><span> </span><span>sizeof</span><span>(</span><span>block_t</span><span>);</span>
<span>    </span><span>block_t</span><span> </span><span>*</span><span>prev</span><span> </span><span>=</span><span> </span><span>previous_block_if_free</span><span>(</span><span>b</span><span>);</span>
<span>    </span><span>block_t</span><span> </span><span>*</span><span>next</span><span> </span><span>=</span><span> </span><span>next_block</span><span>(</span><span>b</span><span>);</span>

<span>    </span><span>/* Mark the block as free */</span>
<span>    </span><span>b</span><span>-&gt;</span><span>used</span><span> </span><span>=</span><span> </span><span>false</span><span>;</span>
<span>    </span><span>if</span><span>(</span><span>next</span><span>)</span>
<span>        </span><span>next</span><span>-&gt;</span><span>prev_used</span><span> </span><span>=</span><span> </span><span>false</span><span>;</span>

<span>    </span><span>/* Merge with the next block if free */</span>
<span>    </span><span>if</span><span>(</span><span>next</span><span> </span><span>&amp;&amp;</span><span> </span><span>!</span><span>next</span><span>-&gt;</span><span>used</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>remove_link</span><span>(</span><span>next</span><span>,</span><span> </span><span>index</span><span>);</span>
<span>        </span><span>merge</span><span>(</span><span>b</span><span>,</span><span> </span><span>next</span><span>);</span>
<span>    </span><span>}</span>
<span>    </span><span>/* Merge with the previous block if free */</span>
<span>    </span><span>if</span><span>(</span><span>prev</span><span>)</span><span> </span><span>{</span>
<span>        </span><span>remove_link</span><span>(</span><span>prev</span><span>,</span><span> </span><span>index</span><span>);</span>
<span>        </span><span>merge</span><span>(</span><span>prev</span><span>,</span><span> </span><span>b</span><span>);</span>
<span>        </span><span>b</span><span> </span><span>=</span><span> </span><span>prev</span><span>;</span>
<span>    </span><span>}</span>

<span>    </span><span>prepend_link</span><span>(</span><span>b</span><span>,</span><span> </span><span>index</span><span>);</span>
<span>}</span>
</code></pre></div></td></tr></tbody></table></div>

<p>Segregated fits are not particularly fancy allocation algorithms, but as you can see they&#39;re simple and compact enough to be explained in an Internet article (... if I&#39;ve done my job right that is!). These are still non-trivial allocators and I think that&#39;s notable for a feature that&#39;s usually only presented as a mysterious black box.</p>

<h3 id="performance">Performance<a href="#performance" title="Link to this section">#</a></h3>
<p>I don&#39;t have much to offer in the way of performance evaluation. To be honest, this algorithm doesn&#39;t have any particularly good qualities despite responding fast in general for small requests. In terms of fragmentation (breaking up the heap region in too many small pieces that waste memory), best-fit doesn&#39;t really shine in general, but few gint applications actually put enough pressure on the heap to fill it and run out of memory. Maybe another time!</p>
<h3 id="realloc-and-extensions"><code>realloc()</code> and extensions<a href="#realloc-and-extensions" title="Link to this section">#</a></h3>
<p>If you look at <a href="https://gitea.planet-casio.com/Lephenixnoir/gint/src/commit/70dccc29dad46b5480ea601aec79134de60cf0c4/src/kmalloc/arena_gint.c"><code>src/kmalloc/arena_gint.c</code></a> you will find a bunch of functions that I haven&#39;t mentioned here. For the sake of completeness, we have:</p>
<ul>
<li><code>realloc()</code>, the other standard function for extending a block. It generalizes both <code>malloc()</code> and <code>free()</code> but it doesn&#39;t add any new difficulty in the implementation.</li>
<li><code>malloc_max()</code>, a gint-specific function that allocates the largest block possible. This is useful once in a while when you want to allocate data but you don&#39;t know the size in advance and you don&#39;t want to fake-generate it first, like in <code>asprintf()</code>. (<code>realloc()</code> can shrink the block once it&#39;s filled.)</li>
<li>A bunch of <code>kmallocdbg_*()</code> functions that check structural invariants. These are useful for finding bugs, but also for forcing the programmer to write down the laws that allocator functions must follow.</li>
</ul>
<h3 id="managing-multiple-arenas">Managing multiple arenas<a href="#managing-multiple-arenas" title="Link to this section">#</a></h3>
<p>As a unikernel, gint doesn&#39;t provide <code>sbrk()</code> and instead the heap region (the <em>arena</em>) is of a fixed size. However there are quite a few non-adjacent areas of memory that gint applications use, so the implementation makes sure to support multiple arenas so that independent heaps can be created. Extensions with custom allocators are also possible.</p>
<p>If you look at <code>gint_malloc()</code> and <code>gint_free()</code> you will see this extra parameter <code>void *data</code>; that&#39;s a generic user pointer passed by the arena manager to each implementation. I used it to access the index structure.</p>
<h3 id="conclusion">Conclusion<a href="#conclusion" title="Link to this section">#</a></h3>
<p>Well, that&#39;s it for this time. I hope this article leaves you with good intuitions about memory management and a sense of understanding for what <code>malloc()</code> actually does in general.</p>
<p>For this article, I wanted to experiment with a mixed visuals-code approach with TikZ. It takes a long time to write up, but I like how it turned out, so I might come back to it.</p>
<h2 id="references">References<a href="#references" title="Link to this section">#</a></h2>
<div>
<table>
<tbody>
<tr id="ref-Dunfield2021">
<td>Dunfield2021</td>
<td>
<p>Jana Dunfield and Neel Krishnaswami. 2021. Bidirectional Typing. ACM Comput. Surv. 54, 5, Article 98 (June 2022), 38 pages. <a href="https://doi.org/10.1145/3450952">https://doi.org/10.1145/3450952</a> </p>
</td>
</tr>
<tr id="ref-ISOC11">
<td>ISOC11</td>
<td>
<p>ISO/IEC 9899:2011: Information technology — Programming languages — C. International Organization for Standardization, Geneva, Switzerland. <a href="https://www.iso.org/standard/57853.html">https://www.iso.org/standard/57853.html</a> (open draft at <a href="https://open-std.org/JTC1/SC22/WG14/www/projects#9899">open-std.org</a>). </p>
</td>
</tr>
<tr id="ref-ISOC99">
<td>ISOC99</td>
<td>
<p>ISO/IEC 9899:1999: Information technology — Programming languages — C. International Organization for Standardization, Geneva, Switzerland. <a href="https://www.iso.org/standard/29237.html">https://www.iso.org/standard/29237.html</a> (open draft at <a href="https://open-std.org/JTC1/SC22/WG14/www/projects#9899">open-std.org</a>). </p>
</td>
</tr>
<tr id="ref-Wilson1995">
<td>Wilson1995</td>
<td>
<p>Wilson, P.R., Johnstone, M.S., Neely, M., Boles, D. (1995). Dynamic storage allocation: A survey and critical review. In: Baler, H.G. (eds) Memory Management. IWMM 1995. Lecture Notes in Computer Science, vol 986. Springer, Berlin, Heidelberg. <a href="https://doi.org/10.1007/3-540-60368-9_19">https://doi.org/10.1007/3-540-60368-9_19</a> </p>
</td>
</tr>
</tbody>
</table>
</div>

</article></div>
  </body>
</html>
