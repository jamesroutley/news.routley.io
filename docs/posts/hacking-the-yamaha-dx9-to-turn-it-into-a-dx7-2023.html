<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ajxs.me/blog/Hacking_the_Yamaha_DX9_To_Turn_It_Into_a_DX7.html">Original</a>
    <h1>Hacking the Yamaha DX9 to Turn It into a DX7 (2023)</h1>
    
    <div id="readability-page-1" class="page"><div>
		<p><span>TL;DR:</span>
	I created a new firmware ROM for the Yamaha DX9,
	which restores many of the synth&#39;s missing features, 
	making the synth able to load and play DX7 patches.
	The new firmware ROM&#39;s source code is freely available
	<a href="https://github.com/ajxs/yamaha_dx97" target="_blank">here</a>.
</p>

<h2 id="updates">Updates <a href="#updates">#</a></h2>
<p>
	In light of reaching the milestone of releasing 
	<a href="https://github.com/ajxs/yamaha_dx97/releases/tag/v1.0.0" target="_blank"> Version 1.0</a>
	of the DX9/7 firmware,
	I&#39;ve made a few updates to this article.
	The most significant update is the addition is about some interesting
	<a href="#leftover_data">leftover data</a>
	found in the Yamaha DX9 ROM.
	Also, a big thanks to the amazing <a href="https://yehar.com" target="_blank">Olli Niemitalo</a>
	for correcting an error in how I was calculating the DX7/9&#39;s voice update frequency!
</p>

<h2 id="foreword">Foreword <a href="#foreword">#</a></h2>
<p>
	Like many vintage synth enthusiasts,
	I keep a keen eye on the local classified sites for the odd bargain that might pop up.
	Late last year, amidst the usual sea of second-hand Roland grooveboxes,
	and Korg Volca synths was something I&#39;d never seen before: <em>A Yamaha DX9</em>.
</p>
<p>
	After my 2021 project creating a detailed
	<a href="https://ajxs.me/blog/Yamaha_DX7_Technical_Analysis.html" target="_blank">technical analysis</a>
	of the DX7, and my subsequent
	<a href="https://ajxs.me/blog/Yamaha_DX7_Firmware_ROM_Disassembly.html" target="_blank">disassembly</a>
	of its firmware,
	I figured there wasn&#39;t too much more I needed to know about the inside of the DX7...
	Seeing the DX9 —advertised at half the price of a DX7, no less—
	an interesting thought crossed my mind:
	<em>Could the DX9 firmware be hacked to restore its missing features?</em>
</p>

<h2 id="background">Background <a href="#background">#</a></h2>
<p>
	In 1983, Yamaha released the groundbreaking DX7 synthesiser.
	It featured a revolutionary new sound generation technology which would change the course of popular music, 
	and help define the signature sound of the 80s: <em>Frequency Modulation synthesis</em>.
	Simultaneously, Yamaha launched the 
	<a href="http://retrosynthads.blogspot.com/2012/06/yamaha-dx9-performance-is-about-to.html" target="_blank">DX9</a>:
	A more affordable alternative featuring the same FM synth engine,
	but substantially more limited features than its more popular sibling.
</p>
<p>
	Despite being built around the same FM sound chips<sup><a href="#footnote_1" id="footnote_1_link">1</a></sup>,
	and sharing the DX7&#39;s famously rugged metal chassis,
	the DX9 possessed considerably less functionality than its iconic sibling.
	It featured only four operators
	—two less than the DX7&#39;s six—
	greatly limiting the range of sounds it could create.
	Its keyboard was not velocity-sensitive, or aftertouch capable, and
	the DX7&#39;s pitch envelope generator had been removed.
	Its patch storage had also been greatly reduced, 
	with internal patch memory cut down from 32 patches to only 20,
	and the cartridge system swapped out for a
	<a href="https://ajxs.me/blog/How_the_Yamaha_FM_Synth_Cassette_Interface_Works.html" target="_blank">cassette tape interface</a>.
</p>

<h2 id="reverse_engineering">Reverse-Engineering the DX9 <a href="#reverse_engineering">#</a></h2>
<p>
	A common misconception exists that under the hood the DX9&#39;s hardware is identical to the DX7.
	While the DX9 <i>does</i> use the same FM voice chips, and CPU as the DX7,
	that&#39;s about where the similarities end.
	This misunderstanding seems to have been exacerbated by an incomplete copy of the DX7/9 service manual
	without the DX9 board schematics having circulated widely online,
	leading people to assume that without having its own schematics the two synths must be identical inside.
	It was this very misconception that led me to purchase one and see for myself...
</p>
<p>
	A single look inside the DX9 told me that simply dropping the DX7 firmware in wasn&#39;t going to cut it.
	My first step to hacking the DX9 would then have to be disassembling its firmware.
</p>

<p>
	At a glance, the structure of the DX9&#39;s ROM seemed very different from the DX7 firmware that I was familiar with.
	The designs are so distinct that there&#39;s no way they were written by the same team.
	The two synths share very little code in common:
	Only the code for working with the serial interface,
	and a few common utility routines.
	I tried to look for a common ancestor that both synths might have inherited this code from,
	but the DX7/9 appear to be Yamaha&#39;s first devices to use the 6303 CPU architecture<sup><a href="#footnote_2" id="footnote_2_link">2</a></sup>.
</p>
<p>
	The DX9 has only 4 kilobytes of RAM compared to the DX7&#39;s 6.
	To save space, the DX9 uses as a different, abridged patch format to that of the DX7.
	Reduced in size from 128, to only 64 bytes.
	To accommodate this, the DX9 uses a simplified keyboard scaling implementation,
	and removes patch names.
</p>
<p>
	Interestingly, the DX9 sends and receives patches over SysEx in a DX7-compatible format,
	translating patches between the two formats as they&#39;re read and written.
	Patches written to tape via the cassette interface however are serialised as-is in the DX9&#39;s native format.
</p>

<p>
	Fortunately, despite all of the differences between the two ROMs,
	there were enough little commonalities that I was able to hit the ground running...
</p>

<h3>MIDI</h3>
<p>
	A great place to start reverse-engineering any synthesiser&#39;s firmware is to track down the code for handling incoming MIDI messages.
	From here you can identify a broad cross-section of internal functionality
	—such as note on/off handlers, parameter changes, and patch functions—
	by tracing how the software handles the associated MIDI status messages.
</p>
<p>
	Interestingly, the DX series actually allow one synth to remotely trigger keypresses on another via SysEx messages<sup><a href="#footnote_3" id="footnote_3_link">3</a></sup>.
	Analysing how these messages were processed was how I
	<a href="https://ajxs.me/blog/Yamaha_DX7_Firmware_ROM_Disassembly.html" target="_blank">reverse-engineered</a>
	the DX7&#39;s UI logic.
</p>
<p>
	MIDI data is always sent and received over a
	<a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter" target="_blank">serial interface</a>.
	Finding code that uses a chip&#39;s serial interface is usually fairly straightforward,
	even on relatively more complicated modern hardware.
	In the case of the Hitachi 63B03 CPU used by the DX7/9,
	the serial interface is configured via a standard control register,
	and a function pointer to an interrupt routine to handle I/O is placed at a standard location in the ROM.
	The interrupt handler in the DX9 uses two ring buffers to store incoming and outgoing MIDI data,
	before processing incoming data in a sub-routine of the firmware&#39;s main loop.
</p>
<p>
	The main MIDI processing routine in any synth is always going to be implemented as a state-machine:
	After receiving a MIDI status byte,
	the synth then processes each incoming data byte until all the required data for this particular message type is received.
	Receiving a new status byte when a data byte is expected resets this state.
</p>
<p>
	Since the DX7 and DX9 were both released prior to MIDI&#39;s standardisation in 1985,
	early versions of the DX7 firmware prior to V1.5 had an incomplete, non-standard MIDI implementation.
	<i>DX7 Service Notes Bulletin No. E-325</i> from November 1984 describes this update in full detail.
	The TX7 owner&#39;s manual implies the existence of a firmware update for the DX9 that addressed these issues,
	however I&#39;ve never seen any actual proof of its existence.
</p>

<h3>Keyboard</h3>
<p>
	While the DX9 does use the same Hitachi HD63B03RP microprocessor as its main CPU,
	it doesn&#39;t share the DX7&#39;s 6805S &#39;sub-CPU&#39; for interfacing with its analog peripherals.
	Instead it uses a
	<a href="https://electronics.stackexchange.com/questions/379892/using-3-state-buffers-for-multiplexing" target="_blank">multiplexing</a>
	circuit wired into the CPU&#39;s address bus,
	through which the synth&#39;s analog peripherals are polled for updates in the firmware&#39;s main loop.
</p>
<p>
	The code interfacing with what the service manual calls the
	<i>&#39;KBD/SW Scan Driver&#39;</i>
	was by far the most difficult code in the ROM to parse.
	This code is responsible for reading the front-panel switch line signals,
	and converting them into the internal representation used by the user-interface routines.
	To make the work of understanding this great tangled mess of assembly easier on myself,
	I wrote a
	<a href="https://github.com/mamedev/mame/blob/master/src/mame/yamaha/ymdx9.cpp" target="_blank">DX9 driver</a>
	for MAME so that I could step through the firmware&#39;s code instruction by instruction in MAME&#39;s debugger.
	I got this idea from David Viens from Plogue&#39;s fantastic video
	<a href="https://youtu.be/XJ97iXQrqzw" target="_blank">Emulating the DX7 the HARD way</a>.
</p>
<p>
	Unlike the DX7,
	rather than keyboard events triggering note events directly they set a global variable which is tested by Note On/Off event handling routines called later in the main loop.
	A similar approach is used for loading patch data,
	with a global flag being used to trigger reloading patch data to the voice chips after parameters are edited via the
	front-panel.
</p>

<h3>String Fragments</h3>
<p>
	Yamaha employed an interesting programming technique in the DX9 firmware to preserve ROM space<sup><a href="#footnote_4" id="footnote_4_link">4</a></sup>:
	The LCD string copy routine treats any byte it encounters with a value of &#39;128&#39; or above to be an index into a table
	of commonly repeated &#39;string fragments&#39;.
	When encountered, the copy routine will recursively call itself with the table offset as a source string pointer.
	This will copy the &#39;string fragment&#39; to the destination, then return to print the remainder of the original string.
	This technique was not used in the DX7 ROM, however it appears in the firmware of many subsequent Yamaha synths,
	such as the DX100, and TX81Z.
</p>
<p>
	For more specific technical documentation on this technique,
	refer to the implementation in the Yamaha DX9/7 firmware
	<a href="https://github.com/ajxs/yamaha_dx97/blob/master/src/lcd.asm#L269" target="_blank">here</a>,
	as well as the accompanying string table documentation
	<a href="https://github.com/ajxs/yamaha_dx97/blob/master/src/string.asm#L231" target="_blank">here</a>.
</p>

<h2 id="new_firmware">Creating the New Firmware <a href="#new_firmware">#</a></h2>
<div><p>
	The full task of reverse-engineering the original firmware and writing the new one was too large to exhaustively detail in writing here.
	I&#39;ll use this section to cover a few small areas that I think are meaningful and interesting.</p></div>

<p>
	Unfortunately, hacking the DX9 to restore the use of all six operators wasn&#39;t going to be as straightforward as just changing a &#39;4&#39; to a &#39;6&#39; in a few crucial places.
	Ambitious as ever,
	I figured I could dispense entirely with the DX9 firmware&#39;s eccentricities and just write a new ROM from scratch with the full range of features I wanted.
</p>
<p>
	Creating a &#39;vertical slice&#39; of the ROMs functionality turned out to be more involved than I&#39;d anticipated:
	Unsurprisingly, getting from zero to handling to MIDI events and assigning notes to voices requires a considerable amount of code,
	leaving plenty of surface area for things to go wrong... 
	And go wrong they did.
</p>
<p>
	My initial attempt at writing the firmware from scratch was not exactly a roaring success.
	However, for what it was worth,
	I did manage to squeeze some <em>never before heard</em> sounds from the poor EGS and OPS chips as my buggy code hammered the pitch-modulation registers with invalid data.
	You can hear the machine crying out in pain for yourself <a href="https://ajxs.me/static/articles/dx97/yamaha_dx9_egs_glitch.mp3" target="_blank">here</a><sup><a href="#footnote_5" id="footnote_5_link">5</a></sup>.
</p>
<p>
	Around this point I decided to rethink my strategy.
</p>
<p>
	My first step hacking the <i>existing</i> DX9 firmware to restore the missing functionality was to change the patch initialisation,
	and loading routines.
	Importing the code from the DX7 ROM used to serialise,
	and deserialise stored patches was pretty straightforward.
	This completed one goal of the project: 
	To restore the DX7&#39;s rate scaling implementation.
</p>
<p>
	I took the opportunity to rewrite the synth&#39;s keyboard event handlers,
	simplifying how key events were scanned and processed. 
	The original implementation had different handlers for <i>Note On</i>, and
	<i> Note Off</i> events. 
	It was straightforward to combine these into a single, more efficient routine.
</p>

<h3>Portamento and Pitch EG</h3>
<p>
	The synth&#39;s portamento processing routine is run as part of the system&#39;s periodic interrupt handler.
	This routine is responsible for &#39;transitioning&#39; the frequency of each voice<sup><a href="#footnote_6" id="footnote_6_link">6</a></sup> 
	from its <i>current</i> frequency towards its final <i>target</i> frequency.
	The updated voice frequency is then written to the EGS chip.
	The routine alternates between updating voices 1-8, and 9-16 with each interrupt, 
	updating each voice&#39;s pitch at a rate of roughly 187Hz<sup><a href="#footnote_7" id="footnote_7_link">7</a></sup>.
	Similarly, the DX7&#39;s pitch EG is updated once every two periodic interrupts.
</p>
<p>
	The YM21290 EGS chip inside the synth is responsible for handling all note events and setting their pitch.
	It uses a logarithmic representation of note frequencies, with 4096 &#39;units&#39; per octave.
	In the DX7 and DX9&#39;s firmware, 
	Yamaha used a 
	<a href="https://github.com/ajxs/yamaha_dx97/blob/master/src/voice/voice.asm#L106" target="_blank">novel method</a>
	for transforming the &#39;key codes&#39; used by incoming MIDI messages and keyboard events into this format.
	On the DX7, the key transpose offset is added to the key code before this transformation is performed.
	The final logarithmic frequency value written to the EGS is calculated 
	by combining the logarithmic value of the played note together with the current level of the pitch EG 
	(A +-4 octave range in the same representation).
	The constant 0x1BA8 is then added,
	which probably represents the logarithmic value of the note A0.
</p>
<p>
	The DX9 uses a different process to calculate the final frequency value in the portamento routine:
	It calculates the logarithmic frequency of the key transpose offset ahead of time, 
	and adds this value to the frequency of each new note.
	Since the DX9 doesn&#39;t feature a pitch EG, it compensates by adjusting the constants added to the final frequency,
	and in the calculation of the &#39;Key Transpose Base Frequency&#39; described above.
</p>
<p>
	After some trial and error,
	I decided it was much easier to port the DX7&#39;s portamento processing code to the new firmware rather than amending the existing implementation to support the pitch EG.
	As a result, the new firmware ended up featuring the DX7&#39;s &#39;glissando&#39; functionality,
	which was a nice bonus.
</p>

<h3>MIDI and Note Handling</h3>
<p>
	I decided to rewrite the synth&#39;s MIDI processing routine and individual MIDI event handlers.
	This gave me the opportunity to store the incoming MIDI velocity,
	which is used to calculate the final operator volumes when adding an individual note.
</p>
<p>
	As mentioned earlier, the DX9 firmware predates the finalisation of the first MIDI standard,
	so certain MIDI features needed to be re-implemented from scratch,
	such as the &#39;Active Sensing&#39; functionality.
	I completely rewrote the SysEx parameter change code to be compliant with the implementation in the DX7&#39;s v1.8 ROM.
	This was essential to ensure the DX7&#39;s many patch editors would support the firmware.
</p>
<p>
	I also ported the routine used for adding individual new notes from the DX7.
	When a new note is triggered, this function is responsible for initialising the voice&#39;s pitch EG;
	calculating the volume of each individual operator according to the note&#39;s velocity;
	and calculating the note&#39;s initial frequency according to the synth&#39;s polyphony, and portamento settings.
	Porting this code over also restored the &#39;Follow&#39; portamento mode setting missing from the DX9.
	While there isn&#39;t any way to restore the keyboard&#39;s missing velocity sensitivity,
	this restored the synth&#39;s sensitivity to the velocity of incoming MIDI notes.
</p>

<h2 id="current_status">Current Status <a href="#current_status">#</a></h2>
<p>
	The new ROM binary, and full source code can be found here:
	<a href="https://github.com/ajxs/yamaha_dx97" target="_blank">https://github.com/ajxs/yamaha_dx97</a>
</p>
<p>
	The main new features added are as follows:
	</p><ul>
		<li>Makes the DX9 able to load and play DX7 patches.</li>
		<li>Restores the use of all six operators.</li>
		<li>The synth is now sensitive to the velocity of incoming MIDI notes.</li>
		<li>Implements the DX7&#39;s pitch EG.</li>
		<li>Implements DX7 style operator scaling.</li>
		<li>Implements DX7 style portamento/glissando.</li>
	</ul>


<h2 id="afterword">Afterword <a href="#afterword">#</a></h2>
<p>
	Since releasing the project online, 
	I&#39;ve been extremely fortunate to receive a positive response from not only the synth hacking community,
	but DX9 owners keen to try it for themselves.
	I&#39;ve also been lucky enough to receive positive coverage from 
	<a href="https://www.musicradar.com/news/yamaha-dx9-dx7-firmware" target="_blank">several</a>
	<a href="https://www.matrixsynth.com/2023/03/alternative-firmware-rom-for-yamaha-dx9.html" target="_blank">online</a>
	<a href="https://www.synthtopia.com/content/2023/03/20/yamaha-dx9-alternate-firmware-makes-it-a-6-op-dx7-compatible-synth/" target="_blank">publications</a>.
</p>
<p>
	One 
	<a href="https://www.synthtopia.com/content/2023/03/20/yamaha-dx9-alternate-firmware-makes-it-a-6-op-dx7-compatible-synth/#comment-1469747" target="_blank">response</a>
	in particular on Synthopia gave me a good laugh:
</p>
<blockquote>
	Awesome. This is a dream come true for somewhere between 2 to 3 people all over the world.
</blockquote>
<p>
	It&#39;s true. I fully admit that this is an extremely niche project.
	Despite this, the project was a labour of love.
	I really enjoyed the experience of hacking vintage synth hardware,
	and being able to squeeze a little bit of extra value out of the
	<a href="https://yamahadx9.com/DX9Worst.html" target="_blank"><i>&#39;Worst Ever&#39;</i></a>
	FM synth.
</p>
<p>
	In spite of its narrow appeal, 
	I feel very fortunate to have had the opportunity to create something other people can enjoy,
	even if only for a very small audience.
</p>

<p>
	As for the DX9 itself, it&#39;s hard to imagine exactly what kind of success Yamaha expected.
	As <a href="https://yamahadx9.com/DX9Origins.html" target="_blank">yamahadx9.com</a> so eloquently notes:
	<i>
		&#39;...the DX9 couldn&#39;t be described in terms of what it offered;
		it was defined by what it lacked compared to the DX7&#39;
	</i><sup><a href="#footnote_8" id="footnote_8_link">8</a></sup>.
	With an intimidating price tag of USD$1395 at its launch,
	the DX9 was more affordable than its bigger brother, but not by much.
	For an investment of just $600 more, a prospective buyer could have it all<sup><a href="#footnote_9" id="footnote_9_link">9</a></sup>.
	For some added perspective,
	at the time of its release in 1984 the now iconic 
	<a href="http://www.muzines.co.uk/articles/roland-106-vs-yamaha-dx9/3313" target="_blank">Roland Juno 106</a>
	was retailing for only USD$1,095.
	Particularly amusing in light of the intimidating prices commanded by the 106 today,
	and the staggering divergence of their prices in the polar opposite directions.
</p>
<p>
	My personal theory about the DX9&#39;s design is that developing the FM sound chips incurred such a high up-front cost that 
	Yamaha needed to get them moving off shelves by any means necessary<sup><a href="#footnote_10" id="footnote_10_link">10</a></sup>.
	Maybe a budget FM synth was always part of Yamaha&#39;s plan,
	but high manufacturing costs limited what kind of discount they could offer?
	Whatever the case, the DX9 couldn&#39;t match the breakaway success of the DX7,
	and was out of production by mid-1985.
	By this point Yamaha evidently weren&#39;t too concerned with their first-generation FM chips,
	having since moved on to producing a new line of 4-operator synths built on an entirely new technological
	foundation.
</p>
<p>
	Yamaha had bet the house on their new chip manufacturing technology.
	A bold gamble that 
	—In spite of the DX9&#39;s lack of success—
	had paid off spectacularly,
	catapulting Yamaha to the head of the pack for years to come.
</p>

<h2 id="leftover_data">Appendix: Leftover Development Artifacts in the DX9 ROM <a href="#leftover_data">#</a></h2>
<p>
	During my work reverse-engineering the DX9 ROM binary,
	I noticed something unusual:
	The DX9 mask ROM contains several blocks of unused data:
	A large block of orphaned 6303 code located at offset <code>0xC84D</code>, 
	and two fragments of strange ASCII data,
	located at <code>0xEE7E</code>, and <code>0xFF85</code>.
</p>

<p>
	The block of orphaned, unreferenced code at <code>0xC84D</code> definitely doesn&#39;t belong to the DX9.
	All of the DX9&#39;s functionality is accounted for in the <em>reachable</em> ROM code,
	and this unknown code references addresses in the <code>0x4000 - 0x6000</code> range,
	which is outside of the DX9&#39;s physical address space.
	As far as I can tell, 
	none of the other Yamaha devices with a 6800-series processor have an address space with low enough addresses for this code either.
</p>

<p>
	The two fragments of ASCII data appear in conspicuous places, 
	one at the end of the ROM&#39;s main string table,
	and the other between the end of the code and the start of the vector table,
	located at the end of the binary.
	The data seemed to consist of a series of strings,
	with each entry starting with a &#39;`&#39; character (ASCII 0x60, backtick),
	followed by a six character string of valid ASCII, 
	two non-ASCII bytes, and a terminating &#39;0&#39;<sup><a href="#footnote_11" id="footnote_11_link">11</a></sup>.
</p>
<p>
	At first I didn&#39;t think much of the data.
	My initial suspicion was that the unprintable characters were part of an alternate character encoding,
	possibly to render Kanji (The DX9 predating Unicode by several years).
	I dismissed it as being a remnant of the development system and moved on.
	I had plenty of work left to do on the DX9/7 ROM, after all.
	Much later, I was doing a cleanup of my disassembly, 
	and I noticed something funny about those unprintable characters... 
	Suddenly it dawned on me that the two trailing non-ASCII bytes weren&#39;t part of the string at all...
	My disassembler had been rendering each block as a single garbled, null-terminated string,
	but the two trailing bytes were actually an offset into the ROM&#39;s address space,
	and the preceding 6 character strings actually described what they pointed to...</p>
<figure>
	<a href="https://ajxs.me/static/articles/dx97/symbol_table.png" target="_blank">
		<img src="https://ajxs.me/static/articles/dx97/symbol_table_thumbnail.jpg" alt="An image of the symbol table fragment located at 0xEE7E in the DX9 ROM"/>
	</a>
	<figcaption>
		The symbol table fragment located at <code>0xEE7E</code>, as seen in Ghidra.</figcaption>
</figure>
<p>
	How did this get here?
	These fragments of the symbol table give us a little bit of insight into the synth&#39;s development.
	Potentially even a clue as to what tools the developers used.
	It&#39;s no coincidence that all the symbol names are 6 characters in length.
	The 
	<a href="http://www.bitsavers.org/components/hitachi/_dataBooks/U24_Hitachi_6301_6801_Assembler_Text_Editor_Users_Manual.pdf" target="_blank">
		<i>6301/6801 Assembler Text Editor User&#39;s Manual</i>
	</a>
	states that labels are limited to 6 characters.
</p>
<p>
	The Hitachi cross-assemblers used various different formats for serialising binary data to 
	<a href="https://en.wikipedia.org/wiki/Punched_tape" target="_blank">punched tape</a>,
	such as 
	<a href="https://en.wikipedia.org/wiki/Intel_HEX" target="_blank">Intel HEX</a>, 
	<a href="https://en.wikipedia.org/wiki/SREC_(file_format)" target="_blank">Motorola SREC</a>,
	and the Intel 
	<a href="https://web.archive.org/web/20170627062910/http://www.nj7p.org/Manuals/PDFs/Intel/9800183B.pdf" target="_blank">Absolute Object Module Format</a>,
	among others.
	This data doesn&#39;t match any of these, or any other format I&#39;m aware of.
</p>
<p>
	The <a href="http://bitsavers.org/components/motorola/6800/exorciser/M68MASR_Macro_Assemblers_Reference_6800_6801_6805_6809_Sep1979.pdf" target="_blank">
		Motorola M68MASR Macro Assemblers Reference Manual
	</a>
	mentions ten byte symbol table entries:
</p>
<blockquote>
	&#39;Each unique label, undefined symbol, and external reference symbol in a program
	is allocated a ten-byte block in the symbol table. In addition, a ten-byte
	block is allocated for every four references to a symbol, if the cross reference
	option (paragraph 4,20) is in effect.&#39;
	<cite>
		Motorola M68MASR Macro Assemblers Reference Manual, 2-2
	</cite>
</blockquote>
<p>
	The entries in this mysterious DX9 symbol table are also ten bytes.
	This <em>could</em> just be a coincidence.
	After all, it&#39;s unlikely that Yamaha used this exact cross-assembler.
	However whatever they did use could very well be built on the same codebase?
	I&#39;d love to check for myself,
	but I wouldn&#39;t even know where to start looking for this software.
</p>
<p>
	I&#39;ve checked the ROM of pretty much every other Yamaha device that uses the 6303 looking for a similar leftover symbol table,
	but as far as I&#39;m aware this is the only device where this has happened.
</p>
<p>
	My guess is that the orphaned 6303 code and this symbol table were in the working memory of whatever development system Yamaha were using,
	and somehow ended up mixed in with the actual code before being sent off to create the mask ROM.
	It&#39;s anyone&#39;s guess how something like this would happen.
	It&#39;s clear that the DX9 binary was written <em>over</em> this data,
	so maybe it was just what happened to be in the development system&#39;s memory before?
	Maybe they took a snapshot of the whole memory space of their development system after running their final tests?
</p>
<p>
	If you have any ideas, 
	or have any insight to share about what tools Yamaha might have used, 
	please reach out! I&#39;d love to hear any theories you might have.
</p>

<hr/>

	</div></div>
  </body>
</html>
