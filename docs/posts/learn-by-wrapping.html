<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mikerourke.dev/blog/learn-by-wrapping/">Original</a>
    <h1>Learn by Wrapping</h1>
    
    <div id="readability-page-1" class="page"><div>
    <article>
  <header>
    
    
    <small>January 30, 2022</small>
  </header>
  <hr/>
  <p>
TLDR: I enjoy writing wrappers because they eliminate one of the major challenges I face when learning a new technology: figuring out something useful to build.
</p>
<p>Learning a new library, tool, or technology has always been a pain in the ass for me.
I don&#39;t have the attention span to read through the documentation.
I learn by building something that solves a specific problem or scratches an itch.
For example, at a prior job, I built a tool with the following requirements:</p>
<ul>
<li>Ships as a single executable that can run on older versions of Windows</li>
<li>Can be cross-compiled from macOS</li>
<li>Able to use Windows APIs via dynamic libraries</li>
<li>Easy to set up a WebSocket server</li>
</ul>
<p>Rust (sort of) fits the bill, but I chose Go because the learning curve was lower
(sorry Rustaceans, I haven&#39;t worked up the patience to tussle with the borrow checker just yet).
I was able to learn Go quickly because I was focused on solving the problem, not on learning the language.</p>
<p>Did I have a comprehensive and deep understanding of Go by the time I was done?
Hell no, but I enjoyed the experience and still learned a great deal.
I probably wouldn&#39;t have gotten very far with Go if I was just building a to-do app or a CLI tool that prints <code>Hello World!</code>.</p>
<p>But what if I want to learn an API or command line tool?
Maybe it&#39;s something I&#39;m curious about or need to know at some point for my job.
As I already mentioned, just reading through the documentation is like pulling teeth.</p>
<p>Here&#39;s my usual thought process when I encounter this situation:</p>
<p>I need to learn something new. <em>Duh, use it to fix a problem.</em></p>
<p>Cool, I&#39;ll think of a problem. <em>But you don&#39;t have a useful project idea.</em></p>
<p>What can I do then? <em>Write a wrapper, ya dingus!</em></p>
<p>Over the years, I have written several wrappers around various tools and APIs.
I built a <a href="https://github.com/mikerourke/trello-for-wolves">Node.js wrapper around the Trello API</a>.
I&#39;ve wrapped the Toggl and Clockify APIs for the <a href="https://github.com/mikerourke/transfermyti.me">web app I built to transfer time entries</a>.
And most recently, I switched gears and wrote a <a href="https://github.com/mikerourke/go-devcon">Go wrapper</a> around the <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/devtest/devcon">devcon CLI tool</a> (it&#39;s super niche).</p>
<p>My most ambitious undertaking is a wrapper around <a href="https://www.qemu.org/">QEMU</a> (I&#39;m a sucker for punishment).
I have always found QEMU to be incredibly interesting, ever since I was introduced to it back in 2018.
I no longer use it in a professional capacity, but I like to tinker with it for hobby projects.</p>
<p>If you&#39;ve ever used QEMU, you know it has a <a href="https://www.qemu.org/docs/master/system/invocation.html">batshit amount of command line options</a>.
Here&#39;s a little snippet of how you&#39;d boot an image with some custom settings, a port forwarding rule, and a mounted ISO:</p>
<pre><code>qemu-system-x86_64 -m 3G -smp <span>2</span> <span>\</span>
  -netdev user,id<span>=</span>n,hostfwd<span>=</span>tcp:127.0.0.1:9000-:445 <span>\</span>
  -device e1000,netdev<span>=</span>n <span>\</span>
  -usb <span>\</span>
  -device usb-tablet <span>\</span>
  -k en-us <span>\</span>
  -drive <span>file</span><span>=</span>some-file.qcow2,media<span>=</span>disk,format<span>=</span>qcow2 <span>\</span>
  -cdrom some-iso.iso
</code></pre>
<dl>
<dt>Note</dt>
<dd>
I know there&#39;s more terse ways to achieve the same result above.
Please just bear with me.
</dd>
</dl>
<p>Believe it or not, that&#39;s a fairly simple invocation.
Shit starts getting real when you need to define NUMA nodes:</p>
<pre><code>qemu-system-x86_64 -machine <span>hmat</span><span>=</span>on <span>\</span>
  -m 2G <span>\</span>
  -object memory-backend-ram,size<span>=</span>1G,id<span>=</span>m0 <span>\</span>
  -object memory-backend-ram,size<span>=</span>1G,id<span>=</span>m1 <span>\</span>
  -smp <span>2</span>,sockets<span>=</span><span>2</span>,maxcpus<span>=</span><span>2</span> <span>\</span>
  -numa node,nodeid<span>=</span><span>0</span>,memdev<span>=</span>m0 <span>\</span>
  -numa node,nodeid<span>=</span><span>1</span>,memdev<span>=</span>m1,initiator<span>=</span><span>0</span> <span>\</span>
  -numa cpu,node-id<span>=</span><span>0</span>,socket-id<span>=</span><span>0</span> <span>\</span>
  -numa cpu,node-id<span>=</span><span>0</span>,socket-id<span>=</span><span>1</span> <span>\</span>
  -numa hmat-lb,initiator<span>=</span><span>0</span>,target<span>=</span><span>0</span>,hierarchy<span>=</span>memory,data-type<span>=</span>access-latency,latency<span>=</span><span>5</span> <span>\</span>
  -numa hmat-lb,initiator<span>=</span><span>0</span>,target<span>=</span><span>0</span>,hierarchy<span>=</span>memory,data-type<span>=</span>access-bandwidth,bandwidth<span>=</span>200M <span>\</span>
  -numa hmat-lb,initiator<span>=</span><span>0</span>,target<span>=</span><span>1</span>,hierarchy<span>=</span>memory,data-type<span>=</span>access-latency,latency<span>=</span><span>10</span> <span>\</span>
  -numa hmat-lb,initiator<span>=</span><span>0</span>,target<span>=</span><span>1</span>,hierarchy<span>=</span>memory,data-type<span>=</span>access-bandwidth,bandwidth<span>=</span>100M <span>\</span>
  -numa hmat-cache,node-id<span>=</span><span>0</span>,size<span>=</span>10K,level<span>=</span><span>1</span>,associativity<span>=</span>direct,policy<span>=</span>write-back,line<span>=</span><span>8</span> <span>\</span>
  -numa hmat-cache,node-id<span>=</span><span>1</span>,size<span>=</span>10K,level<span>=</span><span>1</span>,associativity<span>=</span>direct,policy<span>=</span>write-back,line<span>=</span><span>8</span>
</code></pre>
<dl>
<dt>Note</dt>
<dd>
The above invocation was taken directly from the QEMU site, so you can stop bearing with me.
</dd>
</dl>
<p>I got sick of passing all the options into <code>exec.Command</code> in Go, so I started building <a href="https://github.com/mikerourke/queso">Queso</a>.
Queso is what I call a <em>spicy command builder</em>. To get the same command as the first invocation example I gave, your code would look like this:</p>
<pre><code>q <span>:=</span> qemu<span>.</span><span>New</span><span>(</span><span>&#34;qemu-system-x86_64&#34;</span><span>)</span>

q<span>.</span><span>SetOptions</span><span>(</span>
    qemu<span>.</span><span>Memory</span><span>(</span><span>&#34;3G&#34;</span><span>)</span><span>,</span>
    qemu<span>.</span><span>SMP</span><span>(</span>qemu<span>.</span><span>WithCPUCount</span><span>(</span><span>2</span><span>)</span><span>)</span><span>,</span>

    
    network<span>.</span><span>UserBackend</span><span>(</span><span>&#34;n&#34;</span><span>,</span>
        network<span>.</span><span>WithForwardRule</span><span>(</span>
            network<span>.</span><span>NewHostForwardRule</span><span>(</span>network<span>.</span>PortTypeTCP<span>,</span>
                <span>9000</span><span>,</span> <span>445</span><span>)</span><span>.</span><span>WithHostIP</span><span>(</span><span>&#34;127.0.0.1&#34;</span><span>)</span><span>)</span><span>)</span><span>,</span>
    device<span>.</span><span>Device</span><span>(</span><span>&#34;e1000&#34;</span><span>,</span> device<span>.</span><span>NewProperty</span><span>(</span><span>&#34;netdev&#34;</span><span>,</span> <span>&#34;n&#34;</span><span>)</span><span>)</span><span>,</span>

    
    qemu<span>.</span><span>EnableUSB</span><span>(</span><span>)</span><span>,</span>
    qemu<span>.</span><span>USBDevice</span><span>(</span>qemu<span>.</span>USBDeviceTablet<span>)</span><span>,</span>

    
    blockdev<span>.</span><span>Drive</span><span>(</span>
        blockdev<span>.</span><span>WithDiskImageFile</span><span>(</span><span>&#34;some-file.qcow2&#34;</span><span>)</span><span>,</span>
        blockdev<span>.</span><span>WithDiskImageFormat</span><span>(</span>diskimage<span>.</span>FileFormatQCOW2<span>)</span><span>,</span>
        blockdev<span>.</span><span>WithDriveMedia</span><span>(</span>blockdev<span>.</span>DriveMediaDisk<span>)</span><span>)</span><span>,</span>
    blockdev<span>.</span><span>DiskDrive</span><span>(</span>blockdev<span>.</span>CDROM<span>,</span> <span>&#34;some-iso.iso&#34;</span><span>)</span><span>)</span>

<span>if</span> err <span>:=</span> q<span>.</span><span>Cmd</span><span>(</span><span>)</span><span>.</span><span>Run</span><span>(</span><span>)</span><span>;</span> err <span>!=</span> <span>nil</span> <span>{</span>
    log<span>.</span><span>Println</span><span>(</span>err<span>)</span>
<span>}</span>
</code></pre>
<p>Is this better than a Bash script? That&#39;s up for debate.
It is nice if you&#39;re running QEMU cross-platform, as you don&#39;t have to maintain two different script files.</p>
<dl>
<dt>Disclaimer</dt>
<dd>
I promise this post isn&#39;t just a shameless plug for some code I wrote.
In fact, as of this writing, I wouldn&#39;t recommend using Queso (at least not in production).
It&#39;s still undergoing changes.
</dd>
</dl>
<p>Remember how I mentioned &#34;staying engaged with the documentation&#34;?
As I was writing Queso, I went through each invocation option in the QEMU documentation and tried to come up with a corresponding wrapping mechanism.
I also included the documentation alongside each option, so hovering over <code>qemu.Memory</code> in Goland gives you this:</p>
<figure>
<img src="https://mikerourke.dev/images/posts/queso-intellisense.png" alt="Description of the Memory method in an IDE documentation window" title="Description of the Memory method in an IDE documentation window"/>
</figure>
<p>Pretty nifty, eh?</p>
<p>I learned a great deal about QEMU because I wasn&#39;t just skimming the docs, I had to understand what each option meant.
I spent long stretches of time reading and re-reading certain sections to make sure I got it right.
I gained a much deeper understanding of QEMU&#39;s functionality, as well as some gotchas and features I probably wouldn&#39;t
have come across in a Google search (mainly because I wouldn&#39;t really know what search term to use).</p>
<p>Wrapping is also great for learning a new language.
Pick a command line tool or API you&#39;re already familiar with (or not!) and build a library in the language you&#39;re trying to learn.
Some command line tools will write something meaningful to stdout that you can parse and convert to data structures (I did a lot of this in go-devcon).
APIs provide an opportunity to wrap endpoints in functions with return values parsed from the corresponding payloads.</p>
<p>Reading through the documentation and writing functions that wrap commands or endpoints can be very zen.
There are no ambiguous requirements, and you can wrap as much or as little as you like.
You can focus entirely on what you&#39;re wrapping (or what you&#39;re wrapping it with) without the cognitive overhead of ideation.</p>
<p>Everyone learns differently, so this approach may not work for you.
But next time you&#39;re tasked with learning a new tool, try whipping up a wrapper and see if it helps.
You may end up retaining more knowledge than you expect.</p>

</article>
  </div></div>
  </body>
</html>
