<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://world-playground-deceit.net/blog/2024/10/tcl-closures.html">Original</a>
    <h1>Closures in Tcl</h1>
    
    <div id="readability-page-1" class="page"><div id="content"><div id="content-body"><hr/><p>While closely following the discussions spawned from the recent Tcl/Tk 9.0 release, I&#39;ve
noticed a point that keeps coming up: the absence of closures. Usually the cue for every Tcl hacker
in the world (a very large mob, let me tell you) to start showcasing various contraptions to emulate
them. So here&#39;s my turn.</p><h2>What kind of closures <a href="#h2-0" id="h2-0">§</a></h2><p>But first, let me explain that what I think of when I read the word &#34;closure&#34;. You see, most
C++ers would say that this is a closure:</p><pre><span>#include</span> <span>&lt;cstdio&gt;</span>

<span>auto</span> <span>make_counter</span>(<span>int</span> <span>x</span> = 0)
{
    <span>return</span> [x]() <span>mutable</span> {<span>return</span> ++x;};
}

<span>int</span> <span>main</span>(<span>void</span>)
{
    <span>auto</span> <span>counter</span> = make_counter();
    printf(<span>&#34;counter: %d\n&#34;</span>, counter());     printf(<span>&#34;counter: %d\n&#34;</span>, counter()); }
</pre><p>But the environment isn&#39;t closed over here, it&#39;s simply copied and this copy is then allowed to
be mutated. You could capture <code>x</code> by reference, but then it&#39;d become a dangling
reference outside its scope (thus lifetime, for stack variables)… Let&#39;s see how Python works in
comparison:</p><pre><span>def</span> <span>make_counter</span>(x<span>=</span>0):
    <span>def</span> <span>counter</span>():
        <span>nonlocal</span> x
        <span>x</span> <span>+=</span> 1
        <span>return</span> x
    counter()
    <span>print</span>(f<span>&#39;x: </span>{x}<span>&#39;</span>)     <span>return</span> counter

<span>counter</span> <span>=</span> make_counter()
<span>print</span>(f<span>&#39;counter: </span>{counter()}<span>&#39;</span>) <span>print</span>(f<span>&#39;counter: </span>{counter()}<span>&#39;</span>) </pre><p>As you can see here, the closed over variable is truly captured, not just its value, but the
closure stays valid outside its scope. In C++, this could be achieved if all local variables were
in fact <code>std::shared_ptr</code> captured by value.</p><p>You might wonder why you&#39;d ever need such a strange behaviour, right? Well, I&#39;ve encountered
this use case a few times in Lisp:</p><pre>(<span>defun</span> <span>tree-walk</span> (tree callback)
  ...)

(<span>defun</span> <span>find-integer-nodes</span> (tree)
  (<span>let</span> ((result))
    (tree-walk tree (<span>lambda</span> (node)
                      (<span>if</span> (integerp node)
                          (push node result))))
    result))</pre><p>where a callback is used to collect various items. Again, this specific case would work using
capture-by-reference in C++, but it&#39;s nice to know these closures also work outside their scope
because variable lifetime is tied to their binding.</p><p>If you have some mental energy to spare, I strongly recommend this <a href="https://www.tfeb.org/fragments/2023/02/22/how-to-understand-closures-in-common-lisp/">fantastic article</a> about the nitty-gritty of closures (actually, binding scope and lifetime) in ANSI Common Lisp
to better understand the subtleties at play.</p><h2>In Tcl <a href="#h2-1" id="h2-1">§</a></h2><p>Tcl being a very small language, it doesn&#39;t have lambdas or closures builtin, but we did get <a href="https://www.tcl-lang.org/man/tcl9.0/TclCmd/apply.html"><code>apply</code></a> with 8.5! A dead simple wrapper later, and we have our lambdas and even partial application as
a one-liner bonus:</p><pre><span>proc</span> <span>lambda</span> {args <span>body</span> {ns <span>&#34;&#34;</span>}} {
    <span>if</span> {$<span>ns</span> eq <span>&#34;&#34;</span>} {
        <span>set</span> <span>ns</span> [<span>uplevel</span> 1 <span>namespace</span> current]
    }
    <span>list</span> apply [<span>list</span> $<span>args</span> $<span>body</span> $<span>ns</span>]
}

<span>set</span> <span>l</span> [lambda args {<span>puts</span> $<span>args</span>}]
{*}$<span>l</span> c <span>&#34;d e&#34;</span>; 

<span>proc</span> <span>papply</span> {callable args} {
    <span>concat</span> $<span>callable</span> $<span>args</span>
}</pre><p>But for <a href="https://wiki.tcl-lang.org/page/Closures">closures</a>, the task does seem
a little harder… because while values are reference counted, variable bindings disappear once their
stack frame is destroyed. The only way to keep those variables alive is by storing them in a
namespace or maybe in the top-level stack frame.</p><p>Since TclOO (the builtin object system) is a clean way to instantiate uniquely named
namespaces, that&#39;s what I went with:</p><pre> <span>namespace</span> <span>eval</span> closure {
    <span>proc</span> <span>new</span> {vars args <span>body</span> {ns <span>&#34;&#34;</span>}} {
        <span>if</span> {$<span>ns</span> eq <span>&#34;&#34;</span>} {
            <span>set</span> <span>ns</span> [<span>uplevel</span> 1 <span>namespace</span> current]
        }
        <span>list</span> [closure_class new $<span>vars</span> $<span>args</span> $<span>body</span> $<span>ns</span>] apply
    }
        <span>proc</span> <span>destroy</span> {closure} {[<span>lindex</span> $<span>closure</span> 0] destroy}
    <span>proc</span> <span>lexenv</span> {closure args} {[<span>lindex</span> $<span>closure</span> 0] lexenv {*}$<span>args</span>}

    oo::class create closure_class {
        <span>constructor</span> {vars args <span>body</span> ns} {
            <span>variable</span> fun [<span>list</span> $<span>args</span> [<span>string</span> map [<span>list</span> @ [<span>list</span> $<span>body</span>]] {
                <span>upvar</span> 1 lexenv lexenv
                dict with lexenv @
            }] $<span>ns</span>]
            <span>variable</span> lexenv [dict create]
            <span>foreach</span> var $<span>vars</span> {
                <span>if</span> {[<span>llength</span> $<span>var</span>] == 2} {
                    dict <span>set</span> <span>lexenv</span> {*}$<span>var</span>
                } <span>else</span> {
                    dict <span>set</span> <span>lexenv</span> $<span>var</span> [<span>uplevel</span> 2 <span>set</span> $<span>var</span>]
                }
            }
        }

        <span>method</span> <span>apply</span> args {
            my <span>variable</span> fun lexenv
            apply $<span>fun</span> {*}$<span>args</span>
        }

        <span>method</span> <span>lexenv</span> {{var <span>&#34;&#34;</span>}} {
            my <span>variable</span> lexenv
            <span>if</span> {$<span>var</span> ne <span>&#34;&#34;</span>} {
                dict get $<span>lexenv</span> $<span>var</span>
            } <span>else</span> {
                <span>set</span> <span>lexenv</span>
            }
        }
    }

    <span>namespace</span> <span>export</span> new lexenv destroy
    <span>namespace</span> <span>ensemble</span> create
}

<span>set</span> <span>i</span> 0
<span>set</span> <span>counter</span> [closure new {i} {} {<span>incr</span> i}]
<span>puts</span> <span>&#34;counter: [{*}$counter]&#34;</span>; <span>puts</span> <span>&#34;counter: [{*}$counter]&#34;</span>; <span>puts</span> <span>&#34;lexenv: [closure lexenv $counter]&#34;</span>; <span>puts</span> <span>&#34;lexenv: [closure lexenv $counter i]&#34;</span>; closure destroy $<span>counter</span>; </pre><p>In the end, I had the same limitations as the C++ version (environment being copied), but
being able to access the stored environment via that <code>lexenv</code> method does make the
aforementioned gathering trick possible, even if a bit different in appearance.</p><p>The <code>destroy</code> method call being necessary until <a href="https://core.tcl-lang.org/tips/doc/trunk/tip/550.md">TIP 550</a> is implemented is a
bit of a pain, but that&#39;s how it is.</p><p>In the craziest parts of my mind, I did imagine an environment writeback after each <code>apply</code> method call together with a way to disable that once leaving the stack frame
where the closure was created (via an uplevel&#39;d <a href="https://core.tcl-lang.org/tcllib/doc/trunk/embedded/md/tcllib/files/modules/defer/defer.md"><code>defer</code></a>) but I&#39;ll let the idea sit for a while.</p></div></div></div>
  </body>
</html>
