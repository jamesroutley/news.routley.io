<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://notes.eatonphil.com/errors-and-zig.html">Original</a>
    <h1>Errors and Zig</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div>
        <p>At TigerBeetle these last few weeks I&#39;ve been doing a mix of
documenting client libraries, writing sample code for client
libraries, and writing integration tests against the sample code.</p>
<p>The client library documentation is generated with a Zig script. The
sample code is integration tested with a Zig script. A bunch of Zig
scripts.</p>
<p>It&#39;s not the same
<a href="https://github.com/tigerbeetledb/tigerbeetle/blob/main/docs/TIGER_STYLE.md">rigorous</a>
sort of Zig as the main database. (We&#39;re generally more lax about
scripts and test code.)</p>
<p><em>And I&#39;m specifically writing this post on my personal blog since my
script code is not under incredible scrutiny.</em></p>
<p>Furthermore, I&#39;m still new to Zig. Since I&#39;m still learning, there
have been a few things that tripped me up.</p>
<p>And now that I&#39;ve written this out, I realize most of my stumbling was
related to errors.</p>
<h3 id="failure">Failure</h3><p>Lots of things in programs allocate memory. This sounds dumb and
obvious but before programming Zig I really did not appreciate how
many operations I&#39;m used to allocate memory. I&#39;ve previously only
programmed in GC languages that do the allocations behind the scenes.</p>
<p>Furthermore, memory allocation can fail. Zig makes allocation failures
explicit. So lots of things in Zig code need to handle failure.</p>
<p>This ends up meaning lots of code like:</p>
<pre><code>fn do_stuff(
  alloc: std.mem.Allocator, // Let&#39;s assume this is an arena allocator so I don&#39;t care about freeing.
  stuff: Stuff,
) !void {
  var x = std.ArrayList([]const u8).init(alloc);
  try x.appendSlice(&amp;[_][]const u8{
    &#34;first of something&#34;,
    &#34;one more&#34;,
  });
  try x.append(stuff.thing);
  try x.append(try std.fmt.allocPrint(alloc, &#34;build some string {s}.\n&#34;, .{stuff.athing}));

  var other_stuff = try std.fmt.allocPrint(alloc, &#34;things... {s}&#34;, .{blah});

  try do_other_stuff(x.items, other_stuff);
}
</code></pre>
<p>You have <code>try</code>-es all over the place.</p>
<h3 id="limits-of-&lt;code&gt;try&lt;/code&gt;">Limits of <code>try</code></h3><p>Now I don&#39;t have a problem with acknowledging that allocations can
fail. At least not in non-scripts. In scripts like I&#39;ve been writing
though I don&#39;t really care.</p>
<p>Having all of those <code>try</code>-es is just extra typing all over the place.</p>
<p>It would be nice if I could have instead done:</p>
<pre><code>fn do_stuff(
  alloc: std.mem.Allocator, // Let&#39;s assume this is an arena allocator so I don&#39;t care about freeing.
  stuff: Stuff,
) !void {
  var x = std.ArrayList([]const u8).init(alloc);
  try {
      x.appendSlice(&amp;[_][]const u8{
      &#34;first of something&#34;,
      &#34;one more&#34;,
    });
    x.append(stuff.thing);
    x.append(std.fmt.allocPrint(alloc, &#34;build some string {s}.\n&#34;, .{stuff.athing}));

    var other_stuff = std.fmt.allocPrint(alloc, &#34;things... {s}&#34;, .{blah});

    do_other_stuff(x.items, other_stuff);
  }
}
</code></pre>
<p>But Zig&#39;s <code>try</code> doesn&#39;t work like that. I&#39;m not sure why not. But the
Zig developers are sensible so I&#39;m sure there&#39;s a good reason.</p>
<p>Still, are there other options?</p>
<h3 id="&lt;code&gt;catch-unreachable&lt;/code&gt;"><code>catch unreachable</code></h3><p>So the problem isn&#39;t just that you have to acknowledge memory
allocation failures but that these failures within every helper
function need to be acknowledged by the caller of the helper
function. Failures infiltrate the entire call tree.</p>
<p>You can avoid this by instead of <code>try</code>-ing everything, mark error
conditions as <code>unreachable</code>.</p>
<pre><code>fn do_stuff(
  alloc: std.mem.Allocator, // Let&#39;s assume this is an arena allocator so I don&#39;t care about freeing.
  stuff: Stuff,
) void {
  var x = std.ArrayList([]const u8).init(alloc);
  x.appendSlice(&amp;[_][]const u8{
    &#34;first of something&#34;,
    &#34;one more&#34;,
  }) catch unreachable;
  x.append(stuff.thing) catch unreachable;
  x.append(std.fmt.allocPrint(alloc, &#34;build some string {s}.\n&#34;, .{stuff.athing}) catch unreachable) catch unreachable;

  var other_stuff = std.fmt.allocPrint(alloc, &#34;things... {s}&#34;, .{blah}) catch unreachable;

  do_other_stuff(x.items, other_stuff) catch unreachable;
}
</code></pre>
<p>As you can see from the function signature, this function no longer
returns any error at all. But it could possibly panic.</p>
<p>Now in scripts, for things like memory allocations that can fail, I
actually think it&#39;s reasonable to mark allocation failures as
unreachable.</p>
<p>But I took it a bit further. Using <code>@panic</code> or <code>unreachable</code> in
general failure conditions.</p>
<pre><code>fn run(alloc: std.mem.Allocator, cmds: []const u8) void {
  var res = try std.ChildProcess.exec(.{
      .allocator = self.allocator,
      .argv = cmd,
  });
  switch (res.term) {
      .Exited =&gt; |code| {
          if (code != 0) {
              @panic(&#34;Expected command to succeed.&#34;);
          }
      },

      else =&gt; unreachable,
  }
}
</code></pre>
<h3 id="handling-panics">Handling panics</h3><p>But there are some things that will fail quite frequently (like
running subprocesses or interacting with the filesystem in general).</p>
<p>Panicing (like what happens if <code>@panic()</code> or <code>unreachable</code> is hit) in
these situations is all good until you have things that you want to
get cleaned up.</p>
<p>Panics don&#39;t trigger <code>defer</code> or <code>errdefer</code> statements. So if you have
a script that starts a background process or creates a temporary
directory, and if you panic in that script, the script won&#39;t be able
to run <code>defer</code> steps to stop the background process or delete the
temporary directory.</p>
<p>There are panic handlers in Zig (not yet documented, Ctrl-f for &#34;TODO:
pub fn panic&#34; in the <a href="https://ziglang.org/documentation/master/">Zig
docs</a>. But I&#39;d just be
getting further from useful if I went in that direction.</p>
<h3 id="zig-errors">Zig errors</h3><p>So I stopped panic-ing everywhere and switched to using real Zig
errors, like:</p>
<pre><code>fn run(alloc: std.mem.Allocator, cmds: []const u8) !void {
  var res = try std.ChildProcess.exec(.{
    .allocator = self.allocator,
    .argv = cmd,
  });
  switch (res.term) {
    .Exited =&gt; |code| {
      if (code != 0) {
        std.debug.print(&#34;Expected command to succeed.\n&#34;, .{});
        return error.RunCommandFailed;
      }
    },

    else =&gt; unreachable,
  }
}
</code></pre>
<p>It&#39;s pretty sweet. You get to make up a new <code>error</code> enum wherever
you&#39;d like.</p>
<p>It is unfortunate you can&#39;t (currently) include a payload with the
error return value. There&#39;s an <a href="https://github.com/ziglang/zig/issues/2647">active issue discussing
it</a>.</p>
<p>But so far I&#39;ve been able to work around that, as seen in that example
above, by logging before returning an error. Since most of the time
the payload you want to return is detailed information to provide
context.</p>
<p>This logging is fine in a CLI application but probably not everything
you&#39;d want in a library. I&#39;m not sure.</p>
<h3 id="handling-errors-with-&lt;code&gt;if&lt;/code&gt;">Handling errors with <code>if</code></h3><p>Ok so now that I&#39;m fully bought into Zig errors there were still a few
more things that tripped me up.</p>
<p>First is that you can handle errors a few ways. You already saw the
first one with just <code>try</code>.</p>
<pre><code>  var x = try thingThatCouldFail();
</code></pre>
<p>This will cause the function the statement is inside to short-circuit,
returning immediately, if <code>thingThatCouldFail</code> has an error result.</p>
<p>But then I wanted to retry a function that could fail in a loop after
handling the error.</p>
<pre><code>  var x: SomeType = somedefault;
  while (tries &gt; 0) {
    if (thingThatCouldFail()) |good_value| {
      x = good_value;
      break;
    }

    // do something that should fix it for the next time
    tries -= 1;
  }
</code></pre>
<p>But that isn&#39;t a real syntax. The Zig docs show an example of how you
can use <code>if</code> with an <code>error</code> function:</p>
<pre><code>fn doAThing(str: []u8) void {
    if (parseU64(str, 10)) |number| {
        doSomethingWithNumber(number);
    } else |err| switch (err) {
        error.Overflow =&gt; {
            // handle overflow...
        },
        // we promise that InvalidChar won&#39;t happen (or crash in debug mode if it does)
        error.InvalidChar =&gt; unreachable,
    }
}
</code></pre>
<p>But I don&#39;t care about the error at this moment (maybe I should, but I
don&#39;t right now).</p>
<p>So I tried:</p>
<pre><code>  var x: SomeType = somedefault;
  while (tries &gt; 0) {
    if (thingThatCouldFail()) |good_value| {
      x = good_value;
      break;
    } else {
      // do something that should fix it for the next time
      tries -= 1;
    }
  }
</code></pre>
<p>But that gives me an obscure type error.</p>
<p>I was stumped here for a while until I decided to try the whole syntax
in that example. And it turns out that at least the capture part is
necessary at the parser layer:</p>
<pre><code>  var x: SomeType = somedefault;
  while (tries &gt; 0) {
    if (thingThatCouldFail()) |good_value| {
      x = good_value;
      break;
    } else |err| switch (err) {
      .else =&gt; {
        // do something that should fix it for the next time
        tries -= 1;
      },
    }
  }
</code></pre>
<p>And eventually I guessed an unnamed error variable might also work
without the switch, and that was correct:</p>
<pre><code>  var x: SomeType = somedefault;
  while (tries &gt; 0) {
    if (thingThatCouldFail()) |good_value| {
      x = good_value;
      break;
    } else |_| {
      // do something that should fix it for the next time
      tries -= 1;
    }
  }
</code></pre>
<p>Nice!</p>
<h3 id="&lt;code&gt;catch&lt;/code&gt;-blocks"><code>catch</code> blocks</h3><p>One last thing that I was stumbling around with was that when you use
<code>catch</code> with a function that returns an error or some non-void value,
the catch must return a value of the same type as the function.</p>
<p>The Zig docs show a simple example:</p>
<pre><code>const number = parseU64(str, 10) catch 13;
</code></pre>
<p>But I also use <code>catch</code> with blocks sometimes:</p>
<pre><code>const number = parseU64(str, 10) catch {
  // do some more complex stuff, maybe log, who knows
};
</code></pre>
<p>But that won&#39;t compile. So the &#34;trick&#34; is to combine Zig&#39;s <a href="https://ziglang.org/documentation/master/#Blocks">named
blocks</a> with
<code>catch</code>.</p>
<pre><code>const number = parseU64(str, 10) catch blk: {
  // do some more complex stuff, maybe log, who knows

  // and then &#34;return&#34; a result
  break :blk 13;
};
</code></pre>
<h3 id="contributing-to-zig-docs">Contributing to Zig docs</h3><p>I didn&#39;t want to write this post without offering some of my examples
to the docs. While there&#39;s a dedicated effort around autodoc, the tool
that builds docs for the standard library, I haven&#39;t yet stumbled on
docs for contributing the main Zig docs.</p>
<p>So I grepped in the Zig repo <code>git grep &#39;Blocks are expressions.&#39;</code> for
a phrase that showed up in the HTML docs and found
<code>doc/langref.html.in</code>.</p>
<p>Through someone on the <a href="https://discord.gg/gxsFFjE">Zig Programming Language
Discord</a> I was then pointed at running
<code>zig build docs</code> in the repo root to generate the HTML.</p>
<p>And now I&#39;ve got a <a href="https://github.com/ziglang/zig/pull/15042">PR up</a>!
We&#39;ll see what folks think.</p>
<blockquote><p lang="en" dir="ltr">I wrote a new post about error-handling and Zig, as I&#39;ve been doing a bunch of scripting with Zig recently.</p>— Phil Eaton (@eatonphil) <a href="https://twitter.com/eatonphil/status/1638350047887622145?ref_src=twsrc%5Etfw">March 22, 2023</a></blockquote> 

	<div>
	  <h4>Feedback</h4>
	  <p><small>As always,
	      please <a href="mailto:phil@eatonphil.com">email</a>
	      or <a href="https://twitter.com/eatonphil">tweet me</a>
	      with questions, corrections, or ideas!</small></p>

	</div>
      </div>
    </div></div>
  </body>
</html>
