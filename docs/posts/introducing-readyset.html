<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.readyset.io/posts/introducing-readyset">Original</a>
    <h1>Introducing ReadySet</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>Today, we’re excited to launch ReadySet. Our mission is to help developers build
faster applications without writing extra code.</p>
<p>To accomplish this, we&#39;re building a high-performance <strong>SQL caching engine</strong> and
<strong>performance monitoring solution</strong> that pairs with your existing database to
help ensure that query response latencies are always sub-millisecond. ReadySet
makes it easy for developers to <strong>retrofit scalability and performance onto
existing applications without code changes</strong>. It also enables developers to
build new applications from the ground up without having to worry about
performance from day zero.</p>
<h2>Why We Built This</h2>
<blockquote>
<p>“The data access layer of a million-dollar idea starts out as a single-server   relational database. You’re hardly worried about scale issues – you have an application to write! However, if your million-dollar idea ends up being worth even $100K, you’ll likely find your database struggling to keep up with the scale.” — <a href="https://medium.com/box-tech-blog/cache-is-the-root-of-all-evil-e64ebd7cbd3b">Vova Galenchenko</a></p>
</blockquote>
<p>Performance has arguably never been more important. Today we&#39;re dealing with larger and larger datasets, more complex queries, fundamentally higher request volumes. The Internet is a much bigger place than it used to be. In a sea of competing apps, being snappy and performant isn&#39;t an advantage anymore; it&#39;s table stakes. Laggy page load times have been shown to <a href="https://blog.hubspot.com/marketing/page-load-time-conversion-rates">tank key business metrics</a> like conversion rates, so our web apps need to be fast at any scale.</p>
<p>But how do you actually make a fast web app? There&#39;s an entire world of performance optimization on the frontend, from bundlers to lazy loading and even offloading complex interactivity to WebAssembly. But the biggest bottleneck in your app’s performance is probably the same as everyone else’s: it’s your database. Your app is only as fast as your slowest query, and as you scale up things inevitably get harder.</p>
<h2>Current standards for scaling out databases</h2>
<p>Outside of adding indexes for improving performance on specific queries, when confronted with database read performance regressions, there are a few common approaches:</p>
<ol>
<li>
<p><strong>Build <a href="https://medium.com/box-tech-blog/cache-is-the-root-of-all-evil-e64ebd7cbd3b">custom caching layers</a> on top of key-value stores like Memcached or Redis.</strong> This approach requires developers to write code to maintain the cache, ensuring that results are fresh, and also to rewrite the application to communicate with the new caching layer. Since homegrown caching layers tend not to be SQL-native, the application-cache communication code cannot rely on SQL-compatible tooling like ORMs.</p>
</li>
<li>
<p><strong>Provision <a href="https://medium.com/box-tech-blog/how-we-learned-to-stop-worrying-and-read-from-replicas-58cc43973638">database read replicas</a> and load balance between them.</strong> These read replicas are expensive, prone to replication lag, and since they still compute query results from scratch, often fail to meet latency requirements for the application.</p>
</li>
</ol>
<p>Many workloads require both caches and read replicas, and the resulting tightly-coupled, Frankenstein data layers take significant engineering effort to build and maintain. Moreover, they introduce application and operational complexity that make them <a href="https://danluu.com/cache-incidents/">prone to failures and outages.</a></p>
<h2>Introducing ReadySet</h2>
<blockquote>
<p>There are only two hard things in Computer Science: cache invalidation and naming things. — Phil Karlton</p>
</blockquote>
<p>After speaking to countless developers about their pain points around database read scaling, my PhD labmate <a href="https://twitter.com/jonhoo">Jon Gjengset</a> and I decided to start ReadySet to tackle this problem head on. ReadySet expands upon and commercializes the ideas introduced by the popular open-source research project database <a href="https://github.com/mit-pdos/noria">Noria</a>, which was built over our time at MIT.</p>
<p>At ReadySet, we believe there is a better way. Today, we’re excited to introduce our namesake SQL caching engine that <strong>fully automates cache maintenance</strong> and can be used <strong>without code or database changes</strong>.</p>
<p><img src="https://blog.readyset.io/assets/blog/introducing-readyset/readyset-architecture.png" alt=""/></p>
<p>Sounds too good to be true? Here’s a little more about how this actually works:</p>
<p><strong>ReadySet supports sub-ms query latencies at scale.</strong> Under the hood, ReadySet  incrementally maintains SQL query result sets over time as the underlying data in your database changes due to writes. Rather than writing code to trigger a cache eviction once some staleness criteria is met, ReadySet automatically repairs existing cached results to reflect data changes due to writes. For example, if you’re caching a <code>COUNT</code>, and there’s an additional row that gets written that adds to that count, rather than recomputing the result from scratch, ReadySet updates the prior <code>COUNT</code> result by incrementing it by 1. You can read more about ReadySet’s internals (<strong>sneak peek:</strong> partially-stateful, streaming dataflow) <a href="https://docs.readyset.io/concepts/overview">here</a>.</p>
<p><strong>ReadySet horizontally scales read throughput for cached queries.</strong> ReadySet cache nodes can be sharded, replicated, and geo-distributed around the world. There is no inter-worker communication between these cache nodes on reads, so throughput scales linearly with the number of cores.</p>
<p><strong>ReadySet provides developers with the straightforward experience of a single-node relational database.</strong> ReadySet is wire-compatible with MySQL and Postgres and can be integrated into existing applications by simply changing a connection string.</p>
<h2>What’s Next</h2>
<p>ReadySet’s mission is to help developers build faster applications with little or no effort required. Our first product helps speed up existing databases with a basic caching layer built on incrementally updating views of result sets, but there’s a lot more we’re excited about.  Imagine a SQL-oriented CDN that intelligently caches query results around the world based on user access patterns, and automates compliance to data locality regulations introduced by legislation like GDPR with the goal of enabling companies to serve global user bases without re-engineering their data layer. We’re excited for a faster future.</p>
<p>Fueled by $28M from top VCs (read more about our funding <a href="https://techcrunch.com/2022/04/05/readyset-raises-29m-to-expedite-access-to-enterprise-scale-app-data/">here</a>), we’ve grown the team to 19 people strong over the past year, and have partnered with a few early design partners to build out a strong product foundation. We’re actively hiring across tons of roles – check out our careers page for more information!</p>
<p>In the meantime, you can learn more about ReadySet by watching our <a href="http://readyset.io">demo</a> and reading our <a href="http://docs.readyset.io">docs</a>. If you’re interested in getting early access to ReadySet, you can sign up for our waitlist <a href="https://readysettech.typeform.com/to/ig8uZ4DS?typeform-source=readyset.io">here</a>. If you have questions or comments, feel free to reach out at <a href="mailto:info@readyset.io">info@readyset.io</a>.</p>
</div></div></div>
  </body>
</html>
