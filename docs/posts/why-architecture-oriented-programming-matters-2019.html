<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.metaobject.com/2019/02/why-architecture-oriented-programming.html">Original</a>
    <h1>Why Architecture Oriented Programming Matters (2019)</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-7202157563903024913" itemprop="description articleBody"><p>
On re-reading John Hughes influential <a href="http://www.cse.chalmers.se/~rjmh/Papers/whyfp.pdf">Why Functional Programming Matters</a>, two things stood out for me.</p><p>

The first was the claim that, &#34;...a functional programmer is an order of magnitude more productive than his or her conventional counterpart, because functional programs are an order of magnitude shorter.&#34;   That&#39;s a bold claim,
though he cleverly attributes this claim not to himself but to unspecified others: &#34;Functional programmers argue that...&#34;.</p><p>

If there is evidence for this 10x claim, I&#39;d like to see it.  The only somewhat systematic assessment of
&#34;language productivity&#34; is the Caper Jones language-level evaluation, which is computed on the lines of
code needed to achieve a function point worth of software.  In this <a href="http://www.cs.bsu.edu/homepages/dmz/cs697/langtbl.htm">evaluation</a>, Haskell achieved a level
of 7.5, whereas Smalltalk was rated 15, so twice as productive.  While I don&#39;t see this is conclusive,
it certainly doesn&#39;t <em>support</em> a claim of vastly superior productivity.</p><p>

That little niggle out of way, I think he does make some very insightful and important points in the
second section.  Talking about <em>structured programming</em> he concludes that:

</p><blockquote>
With the benefit of hindsight, it’s clear that these properties of structured programs, although helpful, do not go to the heart of the matter. The most important difference between structured and unstructured programs is that structured programs are designed in a modular way. Modular design brings with it great productivity improvements. First of all, small modules can be coded quickly and easily. Second, general-purpose modules can be reused, leading to faster development of subsequent programs. Third, the modules of a program can be tested independently, helping to reduce the time spent debugging.
</blockquote><p>

He goes on:

</p><blockquote>
However, there is a very important point that is often missed. When writing a modular program to solve a problem, one first divides the problem into subproblems, then solves the subproblems, and finally combines the solutions. 
</blockquote><p>


And then comes the zinger:

</p><blockquote>
<b>
The ways in which one can divide up the original problem depend directly on the ways in which one can glue solutions together. Therefore, to increase one’s ability to modularize a problem conceptually, one must provide new kinds of glue in the programming language. 
</b>
</blockquote><p>

Yes, I put that in bold.  I&#39;d also put a &lt;blink&gt;-tag on it, but fortunately for everyone involved that tag 
is obsolete.  Anyway, he then
makes some partly good, partly debatable points about the benefits of the two kinds of glue he says FP
provides:  function composition and lazy evaluation.</p><p>

For me, the key point here is not those specific benefits, but the number 2.  He just made the important point
that &#34;<em>one must provide new kinds of glue</em>&#34; and then the amount of &#34;new kinds of glue&#34; is the smallest number
that actually justifies using the plural. That seems a bit on the low side, particularly because the number also
seems to be fixed.</p><p>

I&#39;d venture to say that we need a <em>lot</em> more different kinds of glue, and we need our kinds of glue
to be extensible, to be user-defined.  But first, what is this &#34;glue&#34;?  Do we have some other term for it?
Maybe Alan Kay can help?


</p><blockquote>
The Japanese have a small word -- ma -- for &#34;that which
is in between&#34; -- perhaps the nearest English equivalent is &#34;interstitial&#34;.
The key in making great and growable systems is much more to design how its
modules communicate rather than what their internal properties and
behaviors should be. Think of the internet -- to live, it (a) has to allow
many different kinds of ideas and realizations that are beyond any single
standard and (b) to allow varying degrees of safe interoperability between
these ideas.
</blockquote><p><cite>Alan Kay: <a href="http://lists.squeakfoundation.org/pipermail/squeak-dev/1998-October/017019.html">prototypes vs classes was: Re: Sun&#39;s HotSpot</a></cite></p><p>

OK, that&#39;s an additional insight along the same lines, but doesn&#39;t really help us.  Fortunately
the Software Architecture community has something for us, the idea of a <em>Connector</em>.


</p><blockquote>
Connectors are the locus of relations among components.  They mediate interactions but are not “things” to be hooked up (they are, rather, the hookers-up).
</blockquote><p><cite>Mary Shaw: <a href="https://resources.sei.cmu.edu/library/asset-view.cfm?assetid=12137">Procedure Calls Are the Assembly Language of Software Interconnection: Connectors Deserve First-Class Status</a></cite></p><p>

The subtitle of that paper by Mary Shaw is the solution:  connectors deserve first-class-status. 
Connectors are the &#34;ma&#34; that goes in-between, the glue that we need &#34;lots more&#34; of (&#34;lots&#34; &gt; 2);
and when we give them first class status, we can create more, put them in libraries,
and adapt them to our needs.</p><p>

That&#39;s why I think Architecture Oriented Programming matters, and why I am creating <a href="http://objective.st">Objective-Smalltalk</a>.</p>
</div></div>
  </body>
</html>
