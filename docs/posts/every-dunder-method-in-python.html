<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.pythonmorsels.com/every-dunder-method/">Original</a>
    <h1>Every Dunder Method in Python</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>You&#39;ve just made a class.
You made a <code>__init__</code> method.
Now what?</p>
<p>Python includes <em>tons</em> of <a href="https://www.pythonmorsels.com/what-are-dunder-methods/" target="_blank">dunder methods</a> (&#34;double underscore&#34; methods) which allow us to deeply customize how our custom classes interact with Python&#39;s many features.
What dunder methods could you add to your class to make it friendly for other Python programmers who use it?</p>
<p>Let&#39;s take a look at <strong>every dunder method in Python</strong>, with a focus on when each method is useful.</p>
<p>Note that the Python documentation refers to these as <a href="https://docs.python.org/3/glossary.html#term-special-method" target="_blank">special methods</a> and notes the synonym &#34;magic method&#34; but <em>very</em> <a href="https://docs.python.org/3/reference/lexical_analysis.html#reserved-classes-of-identifiers" target="_blank">rarely</a> uses the term &#34;dunder method&#34;.
However, &#34;dunder method&#34; is a fairly common Python colloquialism, as noted in my <a href="https://www.pythonmorsels.com/terms/" target="_blank">unofficial Python glossary</a>.</p>
<p>You can use the links scattered throughout this page for more details on any particular dunder method.
For a list of all of them, see the cheat sheet in the final section.</p>

<h2 id="the-3-essential-dunder-methods">The 3 essential dunder methods üîë</h2>
<p>There are 3 dunder methods that <em>most</em> classes should have: <a href="https://www.pythonmorsels.com/what-is-init/" target="_blank"><code>__init__</code></a>, <a href="https://www.pythonmorsels.com/customizing-string-representation-your-objects/" target="_blank"><code>__repr__</code></a>, and <a href="https://www.pythonmorsels.com/overloading-equality-in-python/" target="_blank"><code>__eq__</code></a>.</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Dunder Method Call</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>T(a, b=3)</code></td>
<td><code>T.__init__(x, a, b=3)</code></td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>repr(x)</code></td>
<td><code>x.__repr__()</code></td>
<td><code>str</code></td>
</tr>
<tr>
<td><code>x == y</code></td>
<td><code>x.__eq__(y)</code></td>
<td>Typically <code>bool</code></td>
</tr>
</tbody>
</table>
<p>The <a href="https://www.pythonmorsels.com/what-is-init/" target="_blank"><code>__init__</code></a> method is the <strong>initializer</strong> (not to be confused with the <a href="#construction-and-finalizing" target="_blank">constructor</a>), the <a href="https://www.pythonmorsels.com/customizing-string-representation-your-objects/" target="_blank"><code>__repr__</code></a> method customizes an object&#39;s string representation, and the <a href="https://www.pythonmorsels.com/overloading-equality-in-python/" target="_blank"><code>__eq__</code></a> method customizes what it means for objects to be <em>equal</em> to one another.</p>
<p>The <code>__repr__</code> method is particularly helpful at the <a href="https://www.pythonmorsels.com/using-the-python-repl/" target="_blank">the Python REPL</a> and when debugging.</p>
<h2 id="equality-and-hashability">Equality and hashability üü∞</h2>
<p>In addition to the <code>__eq__</code> method, Python has 2 other dunder methods for determining the &#34;value&#34; of an object in relation to other objects.</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Dunder Method Call</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x == y</code></td>
<td><code>x.__eq__(y)</code></td>
<td>Typically <code>bool</code></td>
</tr>
<tr>
<td><code>x != y</code></td>
<td><code>x.__ne__(y)</code></td>
<td>Typically <code>bool</code></td>
</tr>
<tr>
<td><code>hash(x)</code></td>
<td><code>x.__hash__()</code></td>
<td><code>int</code></td>
</tr>
</tbody>
</table>
<p>Python&#39;s <code>__eq__</code> method typically returns <code>True</code>, <code>False</code>, or <a href="https://www.pythonmorsels.com/when-to-use-notimplemented/" target="_blank"><code>NotImplemented</code></a> (if objects can&#39;t be compared).
The default <code>__eq__</code> implementation relies on the <code>is</code> operator, which checks for <strong><a href="https://www.pythonmorsels.com/equality-vs-identity/" target="_blank">identity</a></strong>.</p>
<p>The default implementation of <code>__ne__</code> calls <code>__eq__</code> and negates any boolean return value given (or returns <code>NotImplemented</code> if <code>__eq__</code> did).
This default behavior is usually &#34;good enough&#34;, so <strong>you&#39;ll almost never see <code>__ne__</code> implemented</strong>.</p>
<p>Hashable objects can be used as keys in dictionaries or values in sets.
All objects in Python are <a href="https://www.pythonmorsels.com/what-are-hashable-objects/" target="_blank">hashable</a> by default, but if you&#39;ve written a custom <code>__eq__</code> method then your objects <em>won&#39;t</em> be hashable without a custom <code>__hash__</code> method.
But <strong>the hash value of an object must never change</strong> or <a href="https://pym.dev/p/2ysgz/" target="_blank">bad things will happen</a> so <strong>typically only <em>immutable</em> objects implement <code>__hash__</code></strong>.</p>
<p>For implementing equality checks, see <a href="https://www.pythonmorsels.com/overloading-equality-in-python/" target="_blank"><code>__eq__</code> in Python</a>.
For implementing hashability, see <a href="https://www.pythonmorsels.com/making-hashable-objects/" target="_blank">making hashable objects in Python</a>.</p>
<h2 id="orderability">Orderability ‚öñÔ∏è</h2>
<p>Python&#39;s comparison operators (<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>) can all be overloaded with dunder methods as well.
The comparison operators also power functions that rely on the relative ordering of objects, like <code>sorted</code>, <code>min</code>, and <code>max</code>.</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Dunder Method Call</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;</code></td>
<td><code>__lt__</code></td>
<td>Typically <code>bool</code></td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td><code>__gt__</code></td>
<td>Typically <code>bool</code></td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td><code>__le__</code></td>
<td>Typically <code>bool</code></td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td><code>__ge__</code></td>
<td>Typically <code>bool</code></td>
</tr>
</tbody>
</table>
<p>If you plan to implement all of these operators in the <em>typical</em> way (where <code>x &lt; y</code> would be the same as asking <code>y &gt; x</code>) then the <a href="https://docs.python.org/3/library/functools.html#functools.total_ordering" target="_blank"><code>total_ordering</code> decorator</a> from Python&#39;s <code>functools</code> module will come in handy.</p>
<h2 id="type-conversions-and-string-formatting">Type conversions and string formatting ‚öóÔ∏è</h2>
<p>Python has a number of dunder methods for converting objects to a different type.</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Dunder Method Call</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>str(x)</code></td>
<td><code>x.__str__()</code></td>
<td><code>str</code></td>
</tr>
<tr>
<td><code>bool(x)</code></td>
<td><code>x.__bool__()</code></td>
<td><code>bool</code></td>
</tr>
<tr>
<td><code>int(x)</code></td>
<td><code>x.__int__()</code></td>
<td><code>int</code></td>
</tr>
<tr>
<td><code>float(x)</code></td>
<td><code>x.__float__()</code></td>
<td><code>float</code></td>
</tr>
<tr>
<td><code>bytes(x)</code></td>
<td><code>x.__bytes__()</code></td>
<td><a href="https://pym.dev/p/2ysgz/" target="_blank"><code>bytes</code></a></td>
</tr>
<tr>
<td><code>complex(x)</code></td>
<td><code>x.__complex__()</code></td>
<td><a href="https://docs.python.org/3/glossary.html#term-complex-number" target="_blank"><code>complex</code></a></td>
</tr>
<tr>
<td><code>f&#34;{x:s}&#34;</code></td>
<td><code>x.__format__(s)</code></td>
<td><code>str</code></td>
</tr>
<tr>
<td><code>repr(x)</code></td>
<td><code>x.__repr__()</code></td>
<td><code>str</code></td>
</tr>
</tbody>
</table>
<p>The <code>__bool__</code> function is used for <a href="https://www.pythonmorsels.com/truthiness/" target="_blank">truthiness</a> checks, though <code>__len__</code> is used as a fallback.</p>
<p>If you needed to make an object that acts like a number (like <a href="https://docs.python.org/3/library/decimal.html" target="_blank"><code>decimal.Decimal</code></a> or <a href="https://docs.python.org/3/library/fractions.html" target="_blank"><code>fractions.Fraction</code></a>), you&#39;ll want to implement <code>__int__</code>, <code>__float__</code>, and <code>__complex__</code> so your objects can be converted to other numbers.
If you wanted to make an object that could be used in a <code>memoryview</code> or could otherwise be converted to <code>bytes</code>, you&#39;ll want a <code>__bytes__</code> method.</p>
<p>The <code>__format__</code> and <code>__repr__</code> methods are different string conversion flavors.
Most string conversions rely the <code>__str__</code> method, but the default <code>__str__</code> implementation simply calls <code>__repr__</code>.</p>
<p>The <code>__format__</code> method is used by all <a href="https://www.pythonmorsels.com/string-formatting/" target="_blank">f-string conversions</a>, by the <code>str</code> class&#39;s <code>format</code> method, and by the (rarely used) built-in <code>format</code> function.
This method allows <code>datetime</code> objects to <a href="https://www.pythonmorsels.com/string-formatting/#formatting-datetime-objects" target="_blank">support custom format specifiers</a>.</p>
<h2 id="context-managers">Context managers üö™</h2>
<p>A context manager is an object that can be used in a <code>with</code> block.</p>
<table>
<thead>
<tr>
<th>Use</th>
<th>Dunder Method Call</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>with</code> block enter</td>
<td><code>x.__enter__()</code></td>
<td>A value given to <code>as</code></td>
</tr>
<tr>
<td><code>with</code> block exit</td>
<td><code>x.__exit__(exc_type, exc, traceback)</code></td>
<td>Truthy/falsey value</td>
</tr>
</tbody>
</table>
<p>For more on context managers see, <a href="https://www.pythonmorsels.com/what-is-a-context-manager/" target="_blank">what is a context manager</a> and <a href="https://www.pythonmorsels.com/creating-a-context-manager/" target="_blank">creating a context manager</a>.</p>
<h2 id="containers-and-collections">Containers and collections üóÉÔ∏è</h2>
<p>Collections (a.k.a. containers) are essentially data structures or objects that act like data stuctures.
Lists, dictionaries, sets, strings, and tuples are all examples of collections.</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Dunder Method Call</th>
<th>Return Type</th>
<th>Implemented</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>len(x)</code></td>
<td><code>x.__len__()</code></td>
<td>integer</td>
<td>Very common</td>
</tr>
<tr>
<td><code>iter(x)</code></td>
<td><code>x.__iter__()</code></td>
<td>iterator</td>
<td>Very common</td>
</tr>
<tr>
<td><code>for item in x: ...</code></td>
<td><code>x.__iter__()</code></td>
<td>iterator</td>
<td>Very common</td>
</tr>
<tr>
<td><code>x[a]</code></td>
<td><code>x.__getitem__(a)</code></td>
<td>any object</td>
<td>Common</td>
</tr>
<tr>
<td><code>x[a] = b</code></td>
<td><code>x.__setitem__(a, b)</code></td>
<td>None</td>
<td>Common</td>
</tr>
<tr>
<td><code>del x[a]</code></td>
<td><code>x.__delitem__(a)</code></td>
<td>None</td>
<td>Common</td>
</tr>
<tr>
<td><code>a in x</code></td>
<td><code>x.__contains__(a)</code></td>
<td>bool</td>
<td>Common</td>
</tr>
<tr>
<td><code>reversed(x)</code></td>
<td><code>x.__reversed__()</code></td>
<td>iterator</td>
<td>Common</td>
</tr>
<tr>
<td><code>next(x)</code></td>
<td><code>x.__next__()</code></td>
<td>any object</td>
<td>Uncommon</td>
</tr>
<tr>
<td><code>x[a]</code></td>
<td><code>x.__missing__(a)</code></td>
<td>any object</td>
<td>Uncommon</td>
</tr>
<tr>
<td><code>operator.length_hint(x)</code></td>
<td><code>x.__length_hint__()</code></td>
<td>integer</td>
<td>Uncommon</td>
</tr>
</tbody>
</table>
<p>The <code>__iter__</code> method is used by the <code>iter</code> function <em>and</em> for all forms of iteration: <a href="https://www.pythonmorsels.com/writing-a-for-loop/" target="_blank"><code>for</code> loops</a>, <a href="https://www.pythonmorsels.com/what-are-list-comprehensions/" target="_blank">comprehensions</a>, <a href="https://www.pythonmorsels.com/tuple-unpacking/" target="_blank">tuple unpacking</a>, and <a href="https://www.pythonmorsels.com/unpacking-iterables-iterables/" target="_blank">using <code>*</code> for iterable unpacking</a>.</p>
<p>While the <code>__iter__</code> method is necessary for creating a custom iterable, the <code>__next__</code> method is necessary for creating a custom iterator (which is much less common).
The <code>__missing__</code> method is only ever called by the <code>dict</code> class on itself, unless another class decides to implement <code>__missing__</code>.
The <code>__length_hint__</code> method supplies a length guess for structures which do not support <code>__len__</code> so that lists or other structures can be pre-sized more efficiently.</p>
<p>Also see: <a href="https://www.pythonmorsels.com/iterator-protocol/" target="_blank">the iterator protocol</a>, <a href="https://www.pythonmorsels.com/making-the-len-function-work-on-your-python-objects/" target="_blank">implementing <code>__len__</code></a>, and <a href="https://www.pythonmorsels.com/supporting-index-and-key-lookups/" target="_blank">implementing <code>__getitem__</code></a>.</p>
<h2 id="callability">Callability ‚òéÔ∏è</h2>
<p>Functions, classes, and all other <a href="https://www.pythonmorsels.com/callables/" target="_blank">callable objects</a> rely on the <code>__call__</code> method.</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Dunder Method Call</th>
<th>Return Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x(a, b=c)</code></td>
<td><code>x.__call__(a, b=c)</code></td>
<td>any object</td>
</tr>
</tbody>
</table>
<p>When a class is called, its <a href="https://docs.python.org/3/glossary.html#term-metaclass" target="_blank">metaclass</a>&#39;s <code>__call__</code> method is used.
When a class <em>instance</em> is called, the class&#39;s <code>__call__</code> method is used.</p>
<p>For more on callability, see <a href="https://www.pythonmorsels.com/class-function-and-callable/" target="_blank">Callables: Python&#39;s &#34;functions&#34; are sometimes classes</a>.</p>
<h2 id="arithmetic-operators">Arithmetic operators ‚ûó</h2>
<p>Python&#39;s dunder methods are often described as a tool for &#34;operator overloading&#34;.
Most of this &#34;operator overloading&#34; comes in the form of Python&#39;s various arithmetic operators.</p>
<p>There are two ways to break down the arithmetic operators:</p>
<ul>
<li>Mathematical (e.g. <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>) versus bitwise (e.g. <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&gt;&gt;</code>, <code>~</code>)</li>
<li>Binary (between 2 values, like <code>x + y</code>) versus unary (before 1 value, like <code>+x</code>)</li>
</ul>
<p>The mathematical operators are much more common than the bitwise ones and the binary ones are a bit more common than the unary ones.</p>
<p>These are the binary mathematical arithmetic operators:</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Left-Hand Method</th>
<th>Right-Hand Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x + y</code></td>
<td><code>__add__</code></td>
<td><code>__radd__</code></td>
<td>Add / Concatenate</td>
</tr>
<tr>
<td><code>x - y</code></td>
<td><code>__sub__</code></td>
<td><code>__rsub__</code></td>
<td>Subtract</td>
</tr>
<tr>
<td><code>x * y</code></td>
<td><code>__mul__</code></td>
<td><code>__rmul__</code></td>
<td>Multiply</td>
</tr>
<tr>
<td><code>x / y</code></td>
<td><code>__truediv__</code></td>
<td><code>__rtruediv__</code></td>
<td>Divide</td>
</tr>
<tr>
<td><code>%</code></td>
<td><code>__mod__</code></td>
<td><code>__rmod__</code></td>
<td>Modulo</td>
</tr>
<tr>
<td><code>x // y</code></td>
<td><code>__floordiv__</code></td>
<td><code>__rfloordiv__</code></td>
<td><a href="https://www.pythonmorsels.com/integer-division/" target="_blank">Integer division</a></td>
</tr>
<tr>
<td><code>**</code></td>
<td><code>__pow__</code></td>
<td><code>__rpow__</code></td>
<td>Exponentiate</td>
</tr>
<tr>
<td><code>x @ y</code></td>
<td><code>__matmul__</code></td>
<td><code>__rmatmul__</code></td>
<td>Matrix multiply</td>
</tr>
</tbody>
</table>
<p>Each of these operators includes left-hand and right-hand methods.
If <code>x.__add__(y)</code> returns <a href="https://www.pythonmorsels.com/when-to-use-notimplemented/" target="_blank"><code>NotImplemented</code></a>, then <code>y.__radd__(x)</code> will be attempted.
See <a href="https://www.pythonmorsels.com/arithmetic-dunder-methods/" target="_blank">arithmetic dunder methods</a> for more.</p>
<p>These are the binary bitwise arithmetic operators:</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Left-Hand Method</th>
<th>Right-Hand Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x &amp; y</code></td>
<td><code>__and__</code></td>
<td><code>__rand__</code></td>
<td>AND</td>
</tr>
<tr>
<td><code>x | y</code></td>
<td><code>__or__</code></td>
<td><code>__ror__</code></td>
<td>OR</td>
</tr>
<tr>
<td><code>x ^ y</code></td>
<td><code>__xor__</code></td>
<td><code>__rxor__</code></td>
<td>XOR</td>
</tr>
<tr>
<td><code>x &gt;&gt; y</code></td>
<td><code>__rshift__</code></td>
<td><code>__rrshift__</code></td>
<td>Right-shift</td>
</tr>
<tr>
<td><code>x &lt;&lt; y</code></td>
<td><code>__lshift__</code></td>
<td><code>__rlshift__</code></td>
<td>Left-shift</td>
</tr>
</tbody>
</table>
<p>These are Python&#39;s unary arithmetic operators:</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Dunder Method</th>
<th>Variety</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-x</code></td>
<td><code>__neg__</code></td>
<td>Mathematical</td>
<td>Negate</td>
</tr>
<tr>
<td><code>+x</code></td>
<td><code>__pos__</code></td>
<td>Bitwise</td>
<td>Affirm</td>
</tr>
<tr>
<td><code>~x</code></td>
<td><code>__invert__</code></td>
<td>Bitwise</td>
<td>Invert</td>
</tr>
</tbody>
</table>
<p>The unary <code>+</code> operator typically <a href="https://stackoverflow.com/questions/16819023/whats-the-purpose-of-the-pos-unary-operator-in-python" target="_blank">has no effect</a>, though some objects use it for a specific operation.
For example <a href="https://www.pythonmorsels.com/using-counter/#removing-negative-counts" target="_blank">using <code>+</code> on <code>collections.Counter</code> objects</a> will remove non-positive values.</p>
<p>Python&#39;s arithmetic operators are often used for non-arithmetic ends: <a href="https://www.pythonmorsels.com/sequence/" target="_blank">sequences</a> use <code>+</code> to concatenate and <code>*</code> to self-concatenate and <a href="https://www.pythonmorsels.com/practical-uses-of-sets/" target="_blank">sets</a> use <code>&amp;</code> for intersection, <code>|</code> for union, <code>-</code> for asymmetric difference, and <code>^</code> for symmetric difference.
Arithmetic operators are sometimes overloaded for more creative uses too.
For example, <code>pathlib.Path</code> objects <a href="https://docs.python.org/3/library/pathlib.html#operators" target="_blank">use <code>/</code> to create child paths</a>.</p>
<h2 id="in-place-arithmetic-operations">In-place arithmetic operations ‚ôªÔ∏è</h2>
<p>Python includes many dunder methods for <strong>in-place</strong> operations.
If you&#39;re making a <a href="https://www.pythonmorsels.com/terms/#mutable" target="_blank">mutable</a> object that supports any of the arithmetic operations, you&#39;ll want to implement the related in-place dunder method(s) as well.</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Dunder Method Call</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x += y</code></td>
<td><code>x.__iadd__(y)</code></td>
<td>Typically <code>self</code></td>
</tr>
<tr>
<td><code>x -= y</code></td>
<td><code>x.__isub__(y)</code></td>
<td>Typically <code>self</code></td>
</tr>
<tr>
<td><code>x *= y</code></td>
<td><code>x.__imul__(y)</code></td>
<td>Typically <code>self</code></td>
</tr>
<tr>
<td><code>x /= y</code></td>
<td><code>x.__itruediv__(y)</code></td>
<td>Typically <code>self</code></td>
</tr>
<tr>
<td><code>x %= y</code></td>
<td><code>x.__imod__(y)</code></td>
<td>Typically <code>self</code></td>
</tr>
<tr>
<td><code>x //= y</code></td>
<td><code>x.__ifloordiv__(y)</code></td>
<td>Typically <code>self</code></td>
</tr>
<tr>
<td><code>x **= y</code></td>
<td><code>x.__ipow__(y)</code></td>
<td>Typically <code>self</code></td>
</tr>
<tr>
<td><code>x @= y</code></td>
<td><code>x.__imatmul__(y)</code></td>
<td>Typically <code>self</code></td>
</tr>
<tr>
<td><code>x &amp;= y</code></td>
<td><code>x.__iand__(y)</code></td>
<td>Typically <code>self</code></td>
</tr>
<tr>
<td><code>x |= y</code></td>
<td><code>x.__ior__(y)</code></td>
<td>Typically <code>self</code></td>
</tr>
<tr>
<td><code>x ^= y</code></td>
<td><code>x.__ixor__(y)</code></td>
<td>Typically <code>self</code></td>
</tr>
<tr>
<td><code>x &gt;&gt;= y</code></td>
<td><code>x.__irshift__(y)</code></td>
<td>Typically <code>self</code></td>
</tr>
<tr>
<td><code>x &lt;&lt;= y</code></td>
<td><code>x.__ilshift__(y)</code></td>
<td>Typically <code>self</code></td>
</tr>
</tbody>
</table>
<p>All of Python&#39;s binary arithmetic operators work in <strong>augmented assignment statements</strong>, which involve using an operator followed by the <code>=</code> sign to assign to an object while performing an operation on it.</p>
<p>Augmented assignments on <strong>mutable objects</strong> are <a href="https://www.pythonmorsels.com/augmented-assignments-mutate/" target="_blank">expected to mutate the original object</a>, thanks to the mutable object implementing the appropriate dunder method for in-place arithmetic.</p>
<p>When no dunder method is found for an in-place operation, Python performs the operation followed by an assignment.
<strong>Immutable objects typically do <em>not</em> implement dunder methods for in-place operations</strong>, since they should return a new object instead of changing the original.</p>
<h2 id="built-in-math-functions">Built-in math functions üßÆ</h2>
<p>Python also includes dunder methods for many math-related functions, both <a href="https://www.pythonmorsels.com/built-in-functions-in-python/#type" target="_blank">built-in functions</a> and some functions in the <code>math</code> library.</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Dunder Method Call</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>divmod(x, y)</code></td>
<td><code>x.__divmod__(y)</code></td>
<td>2-item tuple</td>
</tr>
<tr>
<td><code>divmod(x, y)</code></td>
<td><code>y.__rdivmod__(x)</code></td>
<td>2-item tuple</td>
</tr>
<tr>
<td><code>abs(x)</code></td>
<td><code>x.__abs__()</code></td>
<td><code>float</code></td>
</tr>
<tr>
<td><code>sequence[x]</code></td>
<td><code>x.__index__()</code></td>
<td><code>int</code></td>
</tr>
<tr>
<td><code>round(x)</code></td>
<td><code>x.__round__()</code></td>
<td>Number</td>
</tr>
<tr>
<td><code>math.trunc(x)</code></td>
<td><code>x.__trunc__()</code></td>
<td>Number</td>
</tr>
<tr>
<td><code>math.floor(x)</code></td>
<td><code>x.__floor__()</code></td>
<td>Number</td>
</tr>
<tr>
<td><code>math.ceil(x)</code></td>
<td><code>x.__ceil__()</code></td>
<td>Number</td>
</tr>
</tbody>
</table>
<p>Python&#39;s <code>divmod</code> function performs <a href="https://www.pythonmorsels.com/integer-division/" target="_blank">integer division</a> (<code>//</code>) and a modulo operation (<code>%</code>) at the same time.
Note that, just like the many binary arithmetic operators, <code>divmod</code> will also check for an <code>__rvidmod__</code> method if it needs to ask the <em>second</em> argument to handle the operation.</p>
<p>The <code>__index__</code> method is for making integer-like objects.
This method losslessly converts to an integer, unlike <code>__int__</code> which may perform a &#34;lossy&#34; integer conversion (e.g. from <code>float</code> to <code>int</code>).
It&#39;s used by operations that require <em>true</em> integers, such as <a href="https://www.pythonmorsels.com/slicing/" target="_blank">slicing</a>, indexing, and <code>bin</code>, <code>hex</code>, and <code>oct</code> functions (<a href="https://pym.dev/p/2k9zt/" target="_blank">example</a>).</p>
<h2 id="attribute-access">Attribute access üìú</h2>
<p>Python even includes dunder methods for controlling what happens when you access, delete, or assign any attribute on an object!</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Dunder Method Call</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x.missing</code></td>
<td><code>x.__getattr__(&#34;missing&#34;)</code></td>
<td>Attribute value</td>
</tr>
<tr>
<td><code>x.anything</code></td>
<td><code>x.__getattribute__(&#34;anything&#34;)</code></td>
<td>Attribute value</td>
</tr>
<tr>
<td><code>x.thing = value</code></td>
<td><code>x.__setattr__(&#34;thing&#34;, value)</code></td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>del x.thing</code></td>
<td><code>x.__delattr__(&#34;thing&#34;)</code></td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>dir(x)</code></td>
<td><code>x.__dir__()</code></td>
<td>List of strings</td>
</tr>
</tbody>
</table>
<p>The <code>__getattribute__</code> method is called for <em>every</em> attribute access, while the <code>__getattr__</code> method is only called after Python <em>fails</em> to find a given attribute.
All method calls and attribute accesses call <code>__getattribute__</code> so implementing it correctly is challenging (due to accidental <a href="https://www.pythonmorsels.com/what-is-recursion/" target="_blank">recursion</a>).</p>
<p>The <code>__dir__</code> method should return an iterable of attribute names (as strings).
When <a href="https://www.pythonmorsels.com/built-in-functions-in-python/#dir" target="_blank">the <code>dir</code> function</a> calls <code>__dir__</code>, it converts the returned iterable into a sorted list (like <a href="https://www.pythonmorsels.com/sorting-in-python/" target="_blank"><code>sorted</code></a> does).</p>
<p>The built-in <code>getattr</code>, <a href="https://www.pythonmorsels.com/python-setattr/" target="_blank"><code>setattr</code></a>, and <code>delattr</code> functions correspond to the dunder methods of the same name, but they&#39;re only intended for dynamic attribute access (not <em>all</em> attribute accesses).</p>

<p>Now we&#39;re getting into the really unusual dunder methods.
Python includes many dunder methods for metaprogramming-related features.</p>
<table>
<thead>
<tr>
<th>Implemented on</th>
<th>Operation</th>
<th>Dunder Method Call</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td>Metaclasses</td>
<td><code>class T: ...</code></td>
<td><code>type(base).__prepare__()</code></td>
<td>mapping</td>
</tr>
<tr>
<td>Metaclasses</td>
<td><code>isinstance(x, T)</code></td>
<td><code>T.__instancecheck__(x)</code></td>
<td><code>bool</code></td>
</tr>
<tr>
<td>Metaclasses</td>
<td><code>issubclass(U, T)</code></td>
<td><code>T.__subclasscheck__(U)</code></td>
<td><code>bool</code></td>
</tr>
<tr>
<td>Any class</td>
<td><code>class U(T): ...</code></td>
<td><code>T.__init_subclass__(U)</code></td>
<td><code>None</code></td>
</tr>
<tr>
<td>Any class</td>
<td>(Called manually)</td>
<td><code>T.__subclasses__()</code></td>
<td><code>list</code></td>
</tr>
<tr>
<td>Any class</td>
<td><code>class U(x): ...</code></td>
<td><code>x.__mro_entries__([x])</code></td>
<td><code>tuple</code></td>
</tr>
<tr>
<td>Any class</td>
<td><code>T[y]</code></td>
<td><code>T.__class_getitem__(y)</code></td>
<td>an item</td>
</tr>
</tbody>
</table>
<p>The <code>__prepare__</code> method customizes the dictionary that&#39;s used for a class&#39;s initial namespace.
This is used to pre-populate dictionary values or customize the dictionary type (<a href="https://pym.dev/p/23wfv/" target="_blank">silly example</a>).</p>
<p>The <code>__instancecheck__</code> and <code>__subclasscheck__</code> methods override the functionality of <code>isinstance</code> and <code>issubclass</code>.
Python&#39;s ABCs use these to practice <a href="https://www.pythonmorsels.com/goose-typing/" target="_blank">goose typing</a> (<a href="https://www.pythonmorsels.com/duck-typing/" target="_blank">duck typing</a> <em>while</em> type checking).</p>
<p>The <code>__init_subclass__</code> method allows classes to hook into subclass initialization (<a href="https://pym.dev/p/246z6/" target="_blank">example</a>).
Classes <em>also</em> have a <code>__subclasses__</code> method (on their <a href="https://docs.python.org/3/glossary.html#term-metaclass" target="_blank">metaclass</a>) but it&#39;s not typically overridden.</p>
<p>Python calls <code>__mro_entries__</code> during <a href="https://www.pythonmorsels.com/inheriting-one-class-another/" target="_blank">class inheritance</a> for any base classes that are not <em>actually</em> classes.
The <a href="https://docs.python.org/3/library/typing.html#typing.NamedTuple" target="_blank"><code>typing.NamedTuple</code></a> function uses this to pretend it&#39;s a class (<a href="https://pym.dev/p/2qgzd/" target="_blank">see here</a>).</p>
<p>The <code>__class_getitem__</code> method allows a class to be subscriptable (<em>without</em> its metaclass needing a <code>__getitem__</code> method).
This is typically used for enabling fancy type annotations (e.g. <code>list[int]</code>).</p>
<h2 id="descriptors">Descriptors üè∑Ô∏è</h2>
<p><a href="https://docs.python.org/3/glossary.html#term-descriptor" target="_blank">Descriptors</a> are objects that, when attached to a class, can hook into the access of the attribute name they&#39;re attached to on that class.</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Dunder Method Call</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>class T: x = U()</code></td>
<td><code>T.x.__set_name__(T, &#39;x&#39;)</code></td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>t.x</code></td>
<td><code>T.x.__get__(t, T)</code></td>
<td>The value</td>
</tr>
<tr>
<td><code>t.x = y</code></td>
<td><code>T.x.__set__(t, y)</code></td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>del t.x</code></td>
<td><code>T.x.__delete__(t)</code></td>
<td><code>None</code></td>
</tr>
</tbody>
</table>
<p>The descriptor protocol is <em>mostly</em> a feature that exists to make Python&#39;s <code>property</code> decorator work, though it is also used by a number of third-party libraries.</p>
<h2 id="buffers">Buffers üíæ</h2>
<p>Implementing a low-level memory array?
You need Python&#39;s <a href="https://docs.python.org/3/reference/datamodel.html#emulating-buffer-types" target="_blank">buffer protocol</a>.</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Dunder Method Call</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>memoryview(x)</code></td>
<td><code>x.__buffer__(flags)</code></td>
<td><code>memoryview</code></td>
</tr>
<tr>
<td><code>del memoryview(x)</code></td>
<td><code>x.__release_buffer__(m)</code></td>
<td><code>None</code></td>
</tr>
</tbody>
</table>
<p>The <code>__release_buffer__</code> method is called when the buffer that&#39;s returned from <code>__buffer__</code> is deleted.</p>
<p>Python&#39;s buffer protocol is typically implemented in C, since it&#39;s meant for low level objects.</p>
<h2 id="asynchronous-operations">Asynchronous operations ü§π</h2>
<p>Want to implement an asynchronous context manager?
You need these dunder methods:</p>
<ul>
<li><code>__aenter__</code>: just like <code>__enter__</code>, but it returns an awaitable object</li>
<li><code>__aexit__</code>: just like <code>__exit__</code>, but it returns an awaitable object</li>
</ul>
<p>Need to support asynchronous iteration?
You need these dunder methods:</p>
<ul>
<li><code>__aiter__</code>: must return an asynchronous iterator</li>
<li><code>__anext__</code>: like <code>__next__</code> or non-async iterators, but this must return an awaitable object and this should raise <code>StopAsyncIteration</code> instead of <code>StopIteration</code></li>
</ul>
<p>Need to make your own awaitable object?
You need this dunder method:</p>
<ul>
<li><code>__await__</code>: returns an iterator</li>
</ul>
<p>I have little experience with custom asynchronous objects, so look elsewhere for more details.</p>
<h2 id="construction-and-finalizing">Construction and finalizing üè≠</h2>
<p>The last few dunder methods are related to object creation and destruction.</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Dunder Method Call</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>T(a, b=3)</code></td>
<td><code>T.__new__(T, a, b=3)</code></td>
<td>New instance (<code>x</code>)</td>
</tr>
<tr>
<td><code>T(a, b=3)</code></td>
<td><code>T.__init__(x, a, b=3)</code></td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>del x</code></td>
<td><code>x.__del__()</code></td>
<td><code>None</code></td>
</tr>
</tbody>
</table>
<p>Calling a class returns a new class instance thanks to the <code>__new__</code> method.
The <code>__new__</code> method is Python&#39;s <strong>constructor method</strong>, though unlike constructors in many programming languages, you should almost <em>never</em> define your own <code>__new__</code> method.
To control object creation, prefer the initializer (<code>__init__</code>), not the constructor (<code>__new__</code>).
<a href="https://pym.dev/p/28r9m/" target="_blank">Here&#39;s an odd <code>__new__</code> example</a>.</p>
<p>You could think of <code>__del__</code> as a &#34;destructor&#34; method, though it&#39;s actually called the <strong>finalizer method</strong>.
Just before an object is deleted, its <code>__del__</code> method is called (<a href="https://pym.dev/p/2hexg/" target="_blank">example</a>).
Files implement a <code>__del__</code> method that closes the file and any binary file buffer that it may be linked to.</p>
<h2 id="library-specific-dunder-methods">Library-specific dunder methods üß∞</h2>
<p>Some standard library modules define custom dunder methods that aren&#39;t used anywhere else:</p>
<ul>
<li><a href="https://www.pythonmorsels.com/dataclasses/" target="_blank">dataclasses</a> support a <code>__post_init__</code> method</li>
<li><code>abc.ABC</code> classes have a <code>__subclasshook__</code> method which <code>abc.ABCMeta</code> calls in its <code>__subclasscheck__</code> method (more in <a href="https://www.pythonmorsels.com/goose-typing/" target="_blank">goose typing</a>)</li>
<li>Path-like objects have a <code>__fspath__</code> method, which returns the file path as a string</li>
<li>Python&#39;s <code>copy</code> module will use the <code>__copy__</code> and <code>__deepcopy__</code> methods if present</li>
<li>Pickling relies on <code>__getnewargs_ex__</code> or <code>__getargs__</code>, though <code>__getstate__</code> and <code>__setstate__</code> can customize further and <code>__reduce__</code> or <code>__reduce_ex__</code> are even lower-level</li>
<li><code>sys.getsizeof</code> relies on the <code>__sizeof__</code> method to get an object&#39;s size (in bytes)</li>
</ul>
<h2 id="dunder-attributes">Dunder attributes üìá</h2>
<p>In addition to dunder methods, Python has many non-method <strong>dunder attributes</strong>.</p>
<p>Here are some of the more common dunder attributes you&#39;ll see:</p>
<ul>
<li><code>__name__</code>: name of a function, classes, or module</li>
<li><code>__module__</code>: module name for a function or class</li>
<li><code>__doc__</code>: <a href="https://www.pythonmorsels.com/docstrings/" target="_blank">docstring</a> for a function, class, or module</li>
<li><code>__class__</code>: an object&#39;s class (call <a href="https://www.pythonmorsels.com/built-in-functions-in-python/#type" target="_blank">Python&#39;s <code>type</code> function</a> instead)</li>
<li><code>__dict__</code>: most objects store their attributes here (see <a href="https://www.pythonmorsels.com/where-are-attributes-stored/" target="_blank">where are attributes stored?</a>)</li>
<li><code>__slots__</code>: classes using this are more memory efficient than classes using <code>__dict__</code></li>
<li><code>__match_args__</code>: classes can define a tuple noting the significance of positional attributes when the class is used in structural pattern matching (<code>match</code>-<code>case</code>)</li>
<li><code>__mro__</code>: a class&#39;s method resolution order used when for attribute lookups and <code>super()</code> calls</li>
<li><code>__bases__</code>: the direct parent classes of a class</li>
<li><code>__file__</code>: the file that defined the module object (though not always present!)</li>
<li><code>__wrapped__</code>: functions decorated with <a href="https://docs.python.org/3/library/functools.html#functools.wraps" target="_blank"><code>functools.wraps</code></a> use this to point to the original function</li>
<li><code>__version__</code>: commonly used for noting the version of a package</li>
<li><code>__all__</code>: modules can use this to customize the behavior of <code>from my_module import *</code></li>
<li><code>__debug__</code>: running Python with <code>-O</code> sets this to <code>False</code> and disables Python&#39;s <code>assert</code> statements</li>
</ul>
<p>Those are only the more commonly seen dunder attributes.
Here are some more:</p>
<ul>
<li>Functions have <code>__defaults__</code>, <code>__kwdefaults__</code>, <code>__code__</code>, <code>__globals__</code>, and <code>__closure__</code></li>
<li>Both functions and classes have <code>__qualname__</code>, <code>__annotations__</code>, and <code>__type_params__</code></li>
<li>Instance methods have <code>__func__</code> and <code>__self__</code></li>
<li>Modules may also have <code>__loader__</code>, <code>__package__</code>, <code>__spec__</code>, and <code>__cached__</code> attributes</li>
<li>Packages have a <code>__path__</code> attribute</li>
<li>Exceptions have <code>__traceback__</code>, <code>__notes__</code>, <code>__context__</code>, <code>__cause__</code>, and <code>__suppress_context__</code></li>
<li>Descriptors use <code>__objclass__</code></li>
<li>Metaclasses use <code>__classcell__</code></li>
<li>Python&#39;s <code>weakref</code> module uses <code>__weakref__</code></li>
<li><a href="https://docs.python.org/3/library/stdtypes.html#type-annotation-types-generic-alias-union" target="_blank">Generic aliases</a> have <code>__origin__</code>, <code>__args__</code>, <code>__parameters__</code>, and <code>__unpacked__</code></li>
<li>The <code>sys</code> module has <code>__stdout__</code> and <code>__stderr__</code> which point to the original <code>stdout</code> and <code>stderr</code> versions</li>
</ul>
<p>Additionally, these dunder attributes are used by various standard library modules: <code>__covariant__</code>, <code>__contravariant__</code>, <code>__infer_variance__</code>, <code>__bound__</code>, <code>__constraints__</code>.
And Python includes a built-in <code>__import__</code> function which you&#39;re not supposed to use (<code>importlib.import_module</code> is preferred) and CPython has a <code>__builtins__</code> variable that points to the <code>builtins</code> module (but this is an implementation detail and <code>builtins</code> should be explicitly imported when needed instead).
Also importing from the <code>__future__</code> module can enable specific Python feature flags and Python will look for a <code>__main__</code> module within packages to make them runnable as CLI scripts.</p>
<p>And that&#39;s just <em>most</em> of the dunder attribute names you&#39;ll find floating around in Python. üòµ</p>
<h2 id="cheat-sheet">Every dunder method: a cheat sheet ‚≠ê</h2>
<p>This is every Python dunder method organized in categories and ordered very roughly by the <strong>most commonly seen</strong> methods first.
Some caveats are noted below.</p>
<table>
<thead>
<tr>
<th>Category</th>
<th>Operation</th>
<th>Dunder Method Call</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td>Object Creation</td>
<td><code>x = T(a, b)</code></td>
<td><code>x.__init__(a, b)</code></td>
<td><code>None</code></td>
</tr>
<tr>
<td>Object Creation</td>
<td><code>x = T(a, b)</code></td>
<td><code>T.__new__(T, a, b)</code></td>
<td>New instance (<code>x</code>)</td>
</tr>
<tr>
<td>Finalizer</td>
<td><code>del x</code> (ish)</td>
<td><code>x.__del__()</code></td>
<td><code>None</code></td>
</tr>
<tr>
<td>Comparisons</td>
<td><code>x == y</code></td>
<td><code>x.__eq__(y)</code></td>
<td>Typically <code>bool</code></td>
</tr>
<tr>
<td>Comparisons</td>
<td><code>x != y</code></td>
<td><code>x.__ne__(y)</code></td>
<td>Typically <code>bool</code></td>
</tr>
<tr>
<td>Comparisons</td>
<td><code>x &lt; y</code></td>
<td><code>x.__lt__(y)</code></td>
<td>Typically <code>bool</code></td>
</tr>
<tr>
<td>Comparisons</td>
<td><code>x &gt; y</code></td>
<td><code>x.__rt__(y)</code></td>
<td>Typically <code>bool</code></td>
</tr>
<tr>
<td>Comparisons</td>
<td><code>x &lt;= y</code></td>
<td><code>x.__le__(y)</code></td>
<td>Typically <code>bool</code></td>
</tr>
<tr>
<td>Comparisons</td>
<td><code>x &gt;= y</code></td>
<td><code>x.__ge__(y)</code></td>
<td>Typically <code>bool</code></td>
</tr>
<tr>
<td>Hashability</td>
<td><code>hash(x)</code></td>
<td><code>x.__hash__()</code></td>
<td><code>int</code></td>
</tr>
<tr>
<td>Conversions</td>
<td><code>repr(x)</code></td>
<td><code>x.__repr__()</code></td>
<td>Always <code>str</code></td>
</tr>
<tr>
<td>Conversions</td>
<td><code>str(x)</code></td>
<td><code>x.__str__()</code></td>
<td>Always <code>str</code></td>
</tr>
<tr>
<td>Conversions</td>
<td><code>bool(x)</code></td>
<td><code>x.__bool__()</code></td>
<td>Always <code>bool</code></td>
</tr>
<tr>
<td>Conversions</td>
<td><code>int(x)</code></td>
<td><code>x.__int__()</code></td>
<td>Always <code>int</code></td>
</tr>
<tr>
<td>Conversions</td>
<td><code>float(x)</code></td>
<td><code>x.__float__()</code></td>
<td>Always <code>float</code></td>
</tr>
<tr>
<td>Conversions</td>
<td><code>bytes(x)</code></td>
<td><code>x.__bytes__()</code></td>
<td>Always <code>bytes</code></td>
</tr>
<tr>
<td>Conversions</td>
<td><code>complex(x)</code></td>
<td><code>x.__complex__()</code></td>
<td>Always <code>complex</code></td>
</tr>
<tr>
<td>Conversions</td>
<td><code>format(x, s)</code></td>
<td><code>x.__format__(s)</code></td>
<td>Always <code>str</code></td>
</tr>
<tr>
<td>Context Managers</td>
<td><code>with x as c:</code></td>
<td><code>x.__enter__()</code></td>
<td>The <code>c</code> object</td>
</tr>
<tr>
<td>Context Managers</td>
<td><code>with x as c:</code></td>
<td><code>x.__exit__()</code></td>
<td>Truthy/falsey value</td>
</tr>
<tr>
<td>Collections</td>
<td><code>len(x)</code></td>
<td><code>x.__len__()</code></td>
<td><code>int</code></td>
</tr>
<tr>
<td>Collections</td>
<td><code>iter(x)</code></td>
<td><code>x.__iter__()</code></td>
<td>An iterator</td>
</tr>
<tr>
<td>Collections</td>
<td><code>x[a]</code></td>
<td><code>x.__getitem__(a)</code></td>
<td></td>
</tr>
<tr>
<td>Collections</td>
<td><code>x[a] = b</code></td>
<td><code>x.__setitem__(a, b)</code></td>
<td><code>None</code></td>
</tr>
<tr>
<td>Collections</td>
<td><code>del x[a]</code></td>
<td><code>x.__delitem__(a)</code></td>
<td><code>None</code></td>
</tr>
<tr>
<td>Collections</td>
<td><code>a in x</code></td>
<td><code>x.__contains__(a)</code></td>
<td><code>bool</code></td>
</tr>
<tr>
<td>Collections</td>
<td><code>reversed(x)</code></td>
<td><code>x.__reversed__()</code></td>
<td>An iterator</td>
</tr>
<tr>
<td>Collections</td>
<td><code>next(x)</code></td>
<td><code>x.__next__()</code></td>
<td>Next iterator item</td>
</tr>
<tr>
<td>Collections</td>
<td><code>x[a]</code></td>
<td><code>x.__missing__(a)</code></td>
<td></td>
</tr>
<tr>
<td>Collections</td>
<td></td>
<td><code>x.__length_hint__()</code></td>
<td><code>int</code></td>
</tr>
<tr>
<td>Arithmetic</td>
<td><code>x + y</code></td>
<td><code>x.__add__(y)</code></td>
<td></td>
</tr>
<tr>
<td>Arithmetic</td>
<td><code>x + y</code></td>
<td><code>y.__radd__(x)</code></td>
<td></td>
</tr>
<tr>
<td>Arithmetic</td>
<td><code>x - y</code></td>
<td><code>x.__sub__(y)</code></td>
<td></td>
</tr>
<tr>
<td>Arithmetic</td>
<td><code>x - y</code></td>
<td><code>y.__rsub__(x)</code></td>
<td></td>
</tr>
<tr>
<td>Arithmetic</td>
<td><code>x * y</code></td>
<td><code>x.__mul__(y)</code></td>
<td></td>
</tr>
<tr>
<td>Arithmetic</td>
<td><code>x * y</code></td>
<td><code>y.__rmul__(x)</code></td>
<td></td>
</tr>
<tr>
<td>Arithmetic</td>
<td><code>x / y</code></td>
<td><code>x.__truediv__(y)</code></td>
<td></td>
</tr>
<tr>
<td>Arithmetic</td>
<td><code>x / y</code></td>
<td><code>y.__rtruediv__(x)</code></td>
<td></td>
</tr>
<tr>
<td>Arithmetic</td>
<td><code>x % y</code></td>
<td><code>x.__mod__(y)</code></td>
<td></td>
</tr>
<tr>
<td>Arithmetic</td>
<td><code>x % y</code></td>
<td><code>y.__rmod__(x)</code></td>
<td></td>
</tr>
<tr>
<td>Arithmetic</td>
<td><code>x // y</code></td>
<td><code>x.__floordiv__(y)</code></td>
<td></td>
</tr>
<tr>
<td>Arithmetic</td>
<td><code>x // y</code></td>
<td><code>y.__rfloordiv__(x)</code></td>
<td></td>
</tr>
<tr>
<td>Arithmetic</td>
<td><code>x ** y</code></td>
<td><code>x.__pow__(y)</code></td>
<td></td>
</tr>
<tr>
<td>Arithmetic</td>
<td><code>x ** y</code></td>
<td><code>y.__rpow__(x)</code></td>
<td></td>
</tr>
<tr>
<td>Arithmetic</td>
<td><code>x @ y</code></td>
<td><code>x.__matmul__(y)</code></td>
<td></td>
</tr>
<tr>
<td>Arithmetic</td>
<td><code>x @ y</code></td>
<td><code>y.__rmatmul__(x)</code></td>
<td></td>
</tr>
<tr>
<td>Arithmetic</td>
<td><code>x &amp; y</code></td>
<td><code>x.__and__(y)</code></td>
<td></td>
</tr>
<tr>
<td>Arithmetic</td>
<td><code>x &amp; y</code></td>
<td><code>y.__rand__(x)</code></td>
<td></td>
</tr>
<tr>
<td>Arithmetic</td>
<td><code>x | y</code></td>
<td><code>x.__or__(y)</code></td>
<td></td>
</tr>
<tr>
<td>Arithmetic</td>
<td><code>x | y</code></td>
<td><code>y.__ror__(x)</code></td>
<td></td>
</tr>
<tr>
<td>Arithmetic</td>
<td><code>x ^ y</code></td>
<td><code>x.__xor__(y)</code></td>
<td></td>
</tr>
<tr>
<td>Arithmetic</td>
<td><code>x ^ y</code></td>
<td><code>y.__rxor__(x)</code></td>
<td></td>
</tr>
<tr>
<td>Arithmetic</td>
<td><code>x &gt;&gt; y</code></td>
<td><code>x.__rshift__(y)</code></td>
<td></td>
</tr>
<tr>
<td>Arithmetic</td>
<td><code>x &gt;&gt; y</code></td>
<td><code>y.__rrshift__(x)</code></td>
<td></td>
</tr>
<tr>
<td>Arithmetic</td>
<td><code>x &lt;&lt; y</code></td>
<td><code>x.__lshift__(y)</code></td>
<td></td>
</tr>
<tr>
<td>Arithmetic</td>
<td><code>x &lt;&lt; y</code></td>
<td><code>y.__rlshift__(x)</code></td>
<td></td>
</tr>
<tr>
<td>Arithmetic</td>
<td><code>-x</code></td>
<td><code>x.__neg__()</code></td>
<td></td>
</tr>
<tr>
<td>Arithmetic</td>
<td><code>+x</code></td>
<td><code>x.__pos__()</code></td>
<td></td>
</tr>
<tr>
<td>Arithmetic</td>
<td><code>~x</code></td>
<td><code>x.__invert__()</code></td>
<td></td>
</tr>
<tr>
<td>Math functions</td>
<td><code>divmod(x, y)</code></td>
<td><code>x.__divmod__(y)</code></td>
<td>2-item tuple</td>
</tr>
<tr>
<td>Math functions</td>
<td><code>abs(x)</code></td>
<td><code>x.__abs__()</code></td>
<td><code>float</code></td>
</tr>
<tr>
<td>Math functions</td>
<td></td>
<td><code>x.__index__()</code></td>
<td><code>int</code></td>
</tr>
<tr>
<td>Math functions</td>
<td><code>round(x)</code></td>
<td><code>x.__round__()</code></td>
<td>Number</td>
</tr>
<tr>
<td>Math functions</td>
<td><code>math.trunc(x)</code></td>
<td><code>x.__trunc__()</code></td>
<td>Number</td>
</tr>
<tr>
<td>Math functions</td>
<td><code>math.floor(x)</code></td>
<td><code>x.__floor__()</code></td>
<td>Number</td>
</tr>
<tr>
<td>Math functions</td>
<td><code>math.ceil(x)</code></td>
<td><code>x.__ceil__()</code></td>
<td>Number</td>
</tr>
<tr>
<td>Assignment</td>
<td><code>x += y</code></td>
<td><code>x.__iadd__(y)</code></td>
<td>Typically <code>self</code></td>
</tr>
<tr>
<td>Assignment</td>
<td><code>x -= y</code></td>
<td><code>x.__isub__(y)</code></td>
<td>Typically <code>self</code></td>
</tr>
<tr>
<td>Assignment</td>
<td><code>x *= y</code></td>
<td><code>x.__imul__(y)</code></td>
<td>Typically <code>self</code></td>
</tr>
<tr>
<td>Assignment</td>
<td><code>x /= y</code></td>
<td><code>x.__itruediv__(y)</code></td>
<td>Typically <code>self</code></td>
</tr>
<tr>
<td>Assignment</td>
<td><code>x %= y</code></td>
<td><code>x.__imod__(y)</code></td>
<td>Typically <code>self</code></td>
</tr>
<tr>
<td>Assignment</td>
<td><code>x //= y</code></td>
<td><code>x.__ifloordiv__(y)</code></td>
<td>Typically <code>self</code></td>
</tr>
<tr>
<td>Assignment</td>
<td><code>x **= y</code></td>
<td><code>x.__ipow__(y)</code></td>
<td>Typically <code>self</code></td>
</tr>
<tr>
<td>Assignment</td>
<td><code>x @= y</code></td>
<td><code>x.__imatmul__(y)</code></td>
<td>Typically <code>self</code></td>
</tr>
<tr>
<td>Assignment</td>
<td><code>x &amp;= y</code></td>
<td><code>x.__iand__(y)</code></td>
<td>Typically <code>self</code></td>
</tr>
<tr>
<td>Assignment</td>
<td><code>x |= y</code></td>
<td><code>x.__ior__(y)</code></td>
<td>Typically <code>self</code></td>
</tr>
<tr>
<td>Assignment</td>
<td><code>x ^= y</code></td>
<td><code>x.__ixor__(y)</code></td>
<td>Typically <code>self</code></td>
</tr>
<tr>
<td>Assignment</td>
<td><code>x &gt;&gt;= y</code></td>
<td><code>x.__irshift__(y)</code></td>
<td>Typically <code>self</code></td>
</tr>
<tr>
<td>Assignment</td>
<td><code>x &lt;&lt;= y</code></td>
<td><code>x.__ilshift__(y)</code></td>
<td>Typically <code>self</code></td>
</tr>
<tr>
<td>Attributes</td>
<td><code>x.y</code></td>
<td><code>x.__getattribute__(&#39;y&#39;)</code></td>
<td></td>
</tr>
<tr>
<td>Attributes</td>
<td><code>x.y</code></td>
<td><code>x.__getattr__(&#39;y&#39;)</code></td>
<td></td>
</tr>
<tr>
<td>Attributes</td>
<td><code>x.y = z</code></td>
<td><code>x.__setattr__(&#39;y&#39;, z)</code></td>
<td><code>None</code></td>
</tr>
<tr>
<td>Attributes</td>
<td><code>del x.y</code></td>
<td><code>x.__delattr__(&#39;y&#39;)</code></td>
<td><code>None</code></td>
</tr>
<tr>
<td>Attributes</td>
<td><code>dir(x)</code></td>
<td><code>x.__dir__()</code></td>
<td>An iterable</td>
</tr>
<tr>
<td>Descriptors</td>
<td><code>class T: x = U()</code></td>
<td><code>T.x.__set_name__(T, &#39;x&#39;)</code></td>
<td><code>None</code></td>
</tr>
<tr>
<td>Descriptors</td>
<td><code>t.x</code></td>
<td><code>T.x.__get__(t, T)</code></td>
<td></td>
</tr>
<tr>
<td>Descriptors</td>
<td><code>t.x = y</code></td>
<td><code>T.x.__set__(t, y)</code></td>
<td><code>None</code></td>
</tr>
<tr>
<td>Descriptors</td>
<td><code>del t.x</code></td>
<td><code>T.x.__delete__(t)</code></td>
<td><code>None</code></td>
</tr>
<tr>
<td>Class stuff</td>
<td><code>class U(T): ...</code></td>
<td><code>T.__init_subclass__(U)</code></td>
<td><code>None</code></td>
</tr>
<tr>
<td>Class stuff</td>
<td><code>class U(x): ...</code></td>
<td><code>x.__mro_entries__([x])</code></td>
<td><code>tuple</code></td>
</tr>
<tr>
<td>Class stuff</td>
<td><code>T[y]</code></td>
<td><code>T.__class_getitem__(y)</code></td>
<td></td>
</tr>
<tr>
<td>Metaclasses</td>
<td><code>class T: ...</code></td>
<td><code>type(base).__prepare__()</code></td>
<td><code>dict</code>/mapping</td>
</tr>
<tr>
<td>Metaclasses</td>
<td><code>isinstance(x, T)</code></td>
<td><code>T.__instancecheck__(x)</code></td>
<td><code>bool</code></td>
</tr>
<tr>
<td>Metaclasses</td>
<td><code>issubclass(U, T)</code></td>
<td><code>T.__subclasscheck__(U)</code></td>
<td><code>bool</code></td>
</tr>
<tr>
<td>Async</td>
<td><code>await x</code> (ish)</td>
<td><code>x.__await__()</code></td>
<td>An iterator</td>
</tr>
<tr>
<td>Async</td>
<td><code>async with x:</code></td>
<td><code>x.__aenter__()</code></td>
<td>An awaitable</td>
</tr>
<tr>
<td>Async</td>
<td><code>async with x:</code></td>
<td><code>x.__aexit__()</code></td>
<td>An awaitable</td>
</tr>
<tr>
<td>Async</td>
<td><code>async for a in x:</code></td>
<td><code>x.__aiter__()</code></td>
<td>An awaitable</td>
</tr>
<tr>
<td>Async</td>
<td><code>async for a in x:</code></td>
<td><code>x.__anext__()</code></td>
<td>An awaitable</td>
</tr>
<tr>
<td>Buffers</td>
<td><code>memoryview(x)</code></td>
<td><code>x.__buffer__(flags)</code></td>
<td><code>memoryview</code></td>
</tr>
<tr>
<td>Buffers</td>
<td><code>del memoryview(x)</code></td>
<td><code>x.__release_buffer__(m)</code></td>
<td><code>None</code></td>
</tr>
</tbody>
</table>
<p>The above table has a slight but consistent <em>untruth</em>.
Most of these dunder methods are not <em>actually</em> called on an object directly but are instead called on the <em>type</em> of that object: <code>type(x).__add__(x, y)</code> instead of <code>x.__add__(y)</code>.
This distinction mostly matters with metaclass methods.</p>
<p>I&#39;ve also purposely excluded library-specific dunder methods (like <code>__post_init__</code>) and dunder methods you&#39;re unlikely to ever define (like <code>__subclasses__</code>).
See those below.</p>
<table>
<thead>
<tr>
<th>Category</th>
<th>Operation</th>
<th>Dunder Method Call</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td>Dataclasses</td>
<td><code>x = T(a, b)</code></td>
<td><code>T.__post_init__(a, b)</code></td>
<td><code>None</code></td>
</tr>
<tr>
<td>Copying</td>
<td><code>copy.copy(x)</code></td>
<td><code>x.__copy__()</code></td>
<td>New object</td>
</tr>
<tr>
<td>Copying</td>
<td><code>copy.deepcopy(x)</code></td>
<td><code>x.__deepcopy__(memo)</code></td>
<td>New object</td>
</tr>
<tr>
<td><a href="https://docs.python.org/3/library/pickle.html#pickling-class-instances" target="_blank">Pickling</a></td>
<td><code>pickle.dumps(x)</code></td>
<td><code>x.__getnewargs__()</code></td>
<td>A 2-item tuple</td>
</tr>
<tr>
<td>Pickling</td>
<td><code>pickle.dumps(x)</code></td>
<td><code>x.__getnewargs_ex__()</code></td>
<td>A 2-item tuple</td>
</tr>
<tr>
<td>Pickling</td>
<td><code>pickle.dumps(x)</code></td>
<td><code>x.__getstate__()</code></td>
<td>A meaningful state</td>
</tr>
<tr>
<td>Pickling</td>
<td><code>pickle.dumps(x)</code></td>
<td><code>x.__reduce__()</code></td>
<td>A 2-6 item tuple</td>
</tr>
<tr>
<td>Pickling</td>
<td><code>pickle.dumps(x)</code></td>
<td><code>x.__reduce_ex__(4)</code></td>
<td>A 2-6 item tuple</td>
</tr>
<tr>
<td>Pickling</td>
<td><code>pickle.loads(b)</code></td>
<td><code>x.__setstate__(state)</code></td>
<td><code>None</code></td>
</tr>
<tr>
<td>pathlib</td>
<td><a href="https://docs.python.org/3/library/os.html#os.fspath" target="_blank"><code>os.fspath(x)</code></a></td>
<td><code>p.__fspath__()</code></td>
<td><code>str</code> or <code>bytes</code></td>
</tr>
<tr>
<td>sys</td>
<td><code>sys.getsizeof(x)</code></td>
<td><code>x.__sizeof__()</code></td>
<td><code>int</code> (size in bytes)</td>
</tr>
<tr>
<td>Class stuff</td>
<td>None?</td>
<td><code>x.__subclasses__()</code></td>
<td>Subclasses iterable</td>
</tr>
<tr>
<td>ABCs</td>
<td><code>issubclass(U, T)</code></td>
<td><code>T.__subclasshook__(U)</code></td>
<td><code>bool</code></td>
</tr>
</tbody>
</table>
<p>So, Python includes 103 &#34;normal&#34; dunder methods, 12 library-specific dunder methods, and at least 52 other dunder attributes of various types.
That&#39;s over 150 unique <code>__dunder__</code> names!
I <strong>do not recommend</strong> memorizing these: let Python do its job and look up the dunder method or attribute that you need to implement/find whenever you need it.</p>
<p>Keep in mind that <strong>you&#39;re not meant to invent your own dunder methods</strong>.
Sometimes you&#39;ll see third-party libraries that <em>do</em> invent their own dunder method, but this isn&#39;t encouraged and it can be quite confusing for users who run across such methods and assume they&#39;re &#34;<em>real</em>&#34; dunder methods.</p>
</div></div>
  </body>
</html>
