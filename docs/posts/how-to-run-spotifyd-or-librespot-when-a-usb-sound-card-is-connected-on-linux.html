<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://capnfabs.net/posts/udev-systemd-spotify-usb-audio/">Original</a>
    <h1>How to: Run spotifyd or librespot when a USB sound card is connected (on Linux)</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody" id="content"><p>Ok, this blog post has a <em>really</em> specific title, but I‚Äôm sure a lot of it generalises to other devices and other software. üòÖ</p><hr/><p>I bought a stereo system recently! I don‚Äôt own any physical music media anymore ‚Äì I left all my CDs behind when I moved to Germany seven years ago, and mostly just use Spotify now. So I needed a way to get Spotify on the stereo.</p><p>There are amps that support streaming services, but I didn‚Äôt want an all-in-one solution ‚Äì the HiFi scene is one of the last places where everything is modular and (relatively) repairable, and I <em>like</em> that about it. Amplifiers feel much less temporal than streaming services (I‚Äôm pretty sure my Dad‚Äôs got an amp that‚Äôs older than me!), and my long-term plan anyway is to eventually finish this <a href="https://capnfabs.net/posts/why-is-this-floppy-disk-drive-clicking-incessantly/">Raspberry Pi-powered floppy disk Spotify player</a> and have that as the primary interface for the speakers.</p><p>I ended up with a <a href="https://www.daytonaudio.com/product/1937/hta100-integrated-stereo-hybrid-tube-amplifier-100-watts">Dayton Audio HTA100</a>, which doesn‚Äôt support Spotify streaming. But it does support:</p><ul><li><p><strong>Bluetooth</strong>: I could stream Spotify from my phone over Bluetooth, but Bluetooth is fiddly and annoying, and there‚Äôs some mysterious source of 2.4GHz radiation in my apartment that causes audio dropouts.</p></li><li><p><strong>Aux cable</strong>: I <em>could</em> take the Raspberry Pi from that floppy disk project, install <a href="https://github.com/librespot-org/librespot">librespot</a> so that it works as a <a href="https://connect.spotify.com/">Spotify Connect</a> client, and connect it via aux cable to the amp. But the 3.5mm audio out on the old Raspberry Pi 3 that I‚Äôve got always sounded kinda garbage to me<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> and so that doesn‚Äôt seem like a great idea.</p></li></ul><ul><li><strong>USB Audio</strong>: the HTA100‚Äôs got a USB port, and can act as a USB soundcard! Maybe I can connect it to the Raspberry Pi using that?</li></ul><figure><img srcset="/posts/udev-systemd-spotify-usb-audio/hta100_hu40ae59cf5ee182b723f8d0828c421fdb_1323181_652x652_fit_q95_box.jpg,
/posts/udev-systemd-spotify-usb-audio/hta100_hu40ae59cf5ee182b723f8d0828c421fdb_1323181_1304x1304_fit_q95_box.jpg 2x" src="https://www.salon.com/posts/udev-systemd-spotify-usb-audio/hta100_hu40ae59cf5ee182b723f8d0828c421fdb_1323181_652x652_fit_q95_box.jpg" alt="A photo of an HTA100 hybrid / tube amplifier on a bookshelf"/><figcaption><p>I like that it glows</p></figcaption></figure><p>The more I got thinking about the USB Audio approach, the more I liked the idea.</p><h2 id="what-makes-it-complex">What makes it complex?</h2><p>The thing that makes it hard is: the amp only appears on USB if you‚Äôve explicitly chosen USB-Audio as the audio source by pressing a physical button. Once you switch the amp off or switch it over to a different input, the Raspberry Pi notices that the USB-Audio has gone missing, and switches back to using a different audio output.</p><p>I wanted to ensure that we‚Äôre only ever playing music to the USB Audio output. And the spotify server program I‚Äôm using will <em>crash</em> if that output channel isn‚Äôt available.</p><p>This means that the Raspberry Pi needs to:</p><ul><li>Detect when the USB Audio interface is connected and start the Spotify Connect service</li><li>Detect when the USB Audio interface is disconnected / off and shutdown the Spotify Connect service.</li></ul><p>But! Having Spotify on / off based on the amplifier state has some nice properties! It means:</p><ul><li><p>the current track / podcast pauses the moment the amp switches off, so that I can pick it up again in the same place later.</p></li><li><p>if the amp isn‚Äôt switched to the USB source, it‚Äôs not available as a Spotify target at all, and so I won‚Äôt end up in situations where (hours later) my phone is still trying to play using the amp even though I‚Äôm in a different room trying to play audio via a different speaker.</p></li><li><p>When I eventually reintroduce that scrolling LED display from the aforementioned <a href="https://capnfabs.net/posts/why-is-this-floppy-disk-drive-clicking-incessantly/#early-prototype">floppy-disk prototype</a>, I can have the display switch off automatically when the amp‚Äôs using a different audio source.</p></li></ul><p>So the <em>technical</em> problem is then: how do we start running a program on the Raspberry Pi when the USB device is connected? And keep running it until the USB device is disconnected?</p><h2 id="introducing-udev--systemd">Introducing udev + systemd</h2><p>We‚Äôre going to use two pieces of pretty fundamental Linux systems software to get this set up:</p><ul><li><code>udev</code> is a system for programmatically executing rules when devices connected to the system change<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>. We‚Äôll use this for noticing when the USB sound card is connected / disconnected.</li><li><code>systemd</code> is a system for keeping all the background processes running on a Linux machine.</li></ul><p>These tools are both really powerful, but also pretty tricky to configure correctly, so the general approach we‚Äôll take today is to get each piece running individually, and then tie them all together at the end.</p><h2 id="step-0-figure-out-which-software-we-want-to-run-on-device-connection">Step 0: Figure out which software we want to run on device connection</h2><p>I spent a bunch of time playing around with <a href="https://github.com/librespot-org/librespot">librespot</a>, and was pretty happy with using it for Spotify Connect. It‚Äôs got command-line options to (among other things) always send output to a specific sound-card, which I ended up using in my config. Note that you‚Äôll need to compile / install it <a href="https://crates.io/crates/librespot">via crates.io</a>.</p><h2 id="step-1-create-a-systemd-service">Step 1: Create a systemd service</h2><p>I used the <a href="https://docs.spotifyd.rs/installation/Raspberry-Pi.html#systemd-daemon-file">docs for <code>spotifyd</code></a> for a template for how to do this, but essentially:</p><ol><li><p>Create a file named <code>~/.config/systemd/user/librespot.service</code>.</p></li><li><p>Add the following content to it:</p></li></ol><div><pre tabindex="0"><code data-lang="ini"><span><span><span>[Unit]</span>
</span></span><span><span><span>Description</span><span>=</span><span>Spotify Connect</span>
</span></span><span><span><span>Documentation</span><span>=</span><span>https://github.com/librespot/librespot</span>
</span></span><span><span><span>Wants</span><span>=</span><span>sound.target</span>
</span></span><span><span><span>After</span><span>=</span><span>sound.target</span>
</span></span><span><span><span>Wants</span><span>=</span><span>network-online.target</span>
</span></span><span><span><span>After</span><span>=</span><span>network-online.target</span>
</span></span><span><span>
</span></span><span><span><span>[Service]</span>
</span></span><span><span><span># this is the command that we chose in Step 0</span>
</span></span><span><span><span># &#39;Hotdog&#39; is the device name that will show up in the Spotify UI</span>
</span></span><span><span><span>ExecStart</span><span>=</span><span>librespot --device=hw:CARD=HTA100 --name=Hotdog --device-type=avr</span>
</span></span><span><span><span># this makes the service restart after 5 seconds if it crashes</span>
</span></span><span><span><span>Restart</span><span>=</span><span>always</span>
</span></span><span><span><span>RestartSec</span><span>=</span><span>5</span>
</span></span></code></pre></div><ol><li>Run <code>systemctl --user daemon-reload</code> to reload info.</li></ol><p>Now, you can start/stop the service using <code>systemctl --user start librespot.service</code> and <code>systemctl --user start librespot.service</code>. Check now that it works! Verify that it plays music while the service is running! You can also check the logs for the service with <code>journalctl --user -f -b -u librespot.service</code>.</p><p>Once that‚Äôs working, it‚Äôs time to get <code>udev</code> setup to automatically start / stop the service when the audio device is connected. ‚ú®</p><h2 id="step-2-configure-udev">Step 2: Configure udev</h2><p><code>udev</code> is a tool that allows you to configure your system to respond to hardware changes. The approach here is pretty straightforward <em>in theory</em>:</p><ul><li>When the correct soundcard is connected, tell systemd to start the Spotify Connect service.</li><li>When that soundcard is disconnected, tell systemd to stop the service.</li></ul><p>First, we need a way of telling the computer that we‚Äôre talking about a specific device ‚Äì the USB Audio interface ‚Äì so we need to hunt for some details that we can use to identify it.</p><h3 id="identify-the-device">Identify the device</h3><p>The easiest way to identify the right device is to get <code>udev</code> to print info about all the devices being connected / disconnected, and then‚Ä¶ connect and disconnect the device.</p><p>So: I run <code>udevadm monitor --property</code>, connect the device, wait for the logs to stablise, then press enter in the terminal a few times to create some visual separation, then disconnect the device.</p><p>The logs look something like this:</p><pre tabindex="0"><code>KERNEL[245.105148] add      /devices/platform/soc/3f980000.usb/usb1/1-1/1-1.1/1-1.1.3/1-1.1.3:1.0/sound/card2 (sound)
ACTION=add
DEVPATH=/devices/platform/soc/3f980000.usb/usb1/1-1/1-1.1/1-1.1.3/1-1.1.3:1.0/sound/card2
SUBSYSTEM=sound
SEQNUM=1608

KERNEL[245.105327] add      /devices/platform/soc/3f980000.usb/usb1/1-1/1-1.1/1-1.1.3/1-1.1.3:1.0/sound/card2/pcmC2D0p (sound)
ACTION=add
DEVPATH=/devices/platform/soc/3f980000.usb/usb1/1-1/1-1.1/1-1.1.3/1-1.1.3:1.0/sound/card2/pcmC2D0p
SUBSYSTEM=sound
DEVNAME=/dev/snd/pcmC2D0p
DEVTYPE=pcm
SEQNUM=1609
MAJOR=116
MINOR=80

...
</code></pre><p>It just keeps <em>spewing</em> for a while. But! We‚Äôve now got the device path of the sound card that we connected:</p><pre tabindex="0"><code>/devices/platform/soc/3f980000.usb/usb1/1-1/1-1.1/1-1.1.3/1-1.1.3:1.0/sound/card2
</code></pre><p>‚Ä¶ and we can ask <code>udev</code> for more info about it. Let‚Äôs run <code>udevadm info -a --path [device_path]</code> (make sure to reconnect the device first!).</p><p>In response we get a helpful paragraph about how to compose rules! And then more spew:</p><pre tabindex="0"><code>$ udevadm info -a --path /devices/platform/soc/3f980000.usb/usb1/1-1/1-1.1/1-1.1.3/1-1.1.3:1.0/sound/card2

Udevadm info starts with the device specified by the devpath and then
walks up the chain of parent devices. It prints for every device
found, all possible attributes in the udev rules key format.
A rule to match, can be composed by the attributes of the device
and the attributes from one single parent device.

  looking at device &#39;/devices/platform/soc/3f980000.usb/usb1/1-1/1-1.1/1-1.1.3/1-1.1.3:1.0/sound/card2&#39;:
    KERNEL==&#34;card2&#34;
    SUBSYSTEM==&#34;sound&#34;
    DRIVER==&#34;&#34;
    ATTR{id}==&#34;HTA100&#34;
    ATTR{number}==&#34;2&#34;
    ATTR{power/control}==&#34;auto&#34;
    ATTR{power/runtime_active_time}==&#34;0&#34;
    ATTR{power/runtime_status}==&#34;unsupported&#34;
    ATTR{power/runtime_suspended_time}==&#34;0&#34;

    ...
</code></pre><p>That‚Äôs probably enough info to write a rule! We can (hopefully?) just say ‚Äústart the service whenever there‚Äôs a device that matches <code>SUBSYSTEM==&#34;sound&#34;</code> and <code>ATTR{id}==&#34;HTA100&#34;</code>.</p><h3 id="write-and-test-the-rule">Write and test the rule</h3><p><a href="https://opensource.com/article/18/11/udev">That article I linked earlier</a> had an <em>incredibly invaluable tip</em>: whenever you‚Äôre messing with udev rules, figure out a clean way to check that the rules are working.</p><p>To do this, I added a pair of scripts which will log the time and whether a device was added or removed to a temporary log file:</p><div><pre tabindex="0"><code data-lang="sh"><span><span><span>#!/usr/bin/bash
</span></span></span><span><span><span></span><span># this file is /usr/local/bin/test_add.sh</span>
</span></span><span><span><span>echo</span> <span>&#34;</span><span>$(</span>/usr/bin/date<span>)</span><span> add&#34;</span> &gt;&gt; /tmp/udev.log
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="sh"><span><span><span>#!/usr/bin/bash
</span></span></span><span><span><span></span><span># this file is /usr/local/bin/test_remove.sh</span>
</span></span><span><span><span>echo</span> <span>&#34;</span><span>$(</span>/usr/bin/date<span>)</span><span> remove&#34;</span> &gt;&gt; /tmp/udev.log
</span></span></code></pre></div><p>Make them both executable:</p><div><pre tabindex="0"><code data-lang="sh"><span><span>sudo chmod a+x /usr/local/bin/test_<span>{</span>add,remove<span>}</span>.sh
</span></span></code></pre></div><p>Now it‚Äôs time to add the udev rules.</p><p>Make a file named <code>/etc/udev/rules.d/10-spotify.rules</code>, and give it the following contents:</p><pre tabindex="0"><code>SUBSYSTEM==&#34;sound&#34;, ATTRS{id}==&#34;HTA100&#34;, ACTION==&#34;add&#34;, RUN+=&#34;/usr/local/bin/test_add.sh&#34;
SUBSYSTEM==&#34;sound&#34;, ENV{ID_MODEL}==&#34;HTA100&#34;, ACTION==&#34;remove&#34;, RUN+=&#34;/usr/local/bin/test_remove.sh&#34;
</code></pre><p>These are the final rules that I used, but I spent <em>hours</em> trying to figure out the issues. There‚Äôs a bunch of syntax oddities here that caught me out, which is why I‚Äôm admonishing you, dear Reader, to test methodically and without skipping steps! The syntax gotchas that I tripped up on were:</p><ul><li><p>Remember to use a double equal (<code>==</code>) instead of single equal (<code>=</code>) for each filter</p></li><li><p>The output of <code>udevadm info</code> returns <code>ATTR{id}</code>, but the correct format to use for the rules is <code>ATTRS{id}</code> (note the extra <code>S</code>)</p></li><li><p>For the <code>remove</code> action, you apparently can‚Äôt rely on <code>ATTRS</code> but have to rely upon <code>ENV</code> entries instead, as <a href="https://unix.stackexchange.com/questions/178341/udev-rule-action-add-is-working-but-action-remove-isnt-working">per this StackExchange answer</a>.</p></li></ul><p>As far as I can tell, there‚Äôs <a href="https://unix.stackexchange.com/questions/200194/how-to-debug-an-udev-rule-in-etc-udev-rules-d">no straightforward way to debug <code>udev</code> rules</a> ‚Äì I would‚Äôve loved if they were e.g. validated on reload.</p><p>With that out of the way: reload the udev config:</p><div><pre tabindex="0"><code data-lang="sh"><span><span>sudo udevadm control --reload
</span></span></code></pre></div><p>‚Ä¶and then plug and unplug the device. Then run:</p><p>If everything worked, you should get something like this:</p><pre tabindex="0"><code>Sat Nov  4 11:07:57 CET 2023 add
Sat Nov  4 11:07:57 CET 2023 add
Sat Nov  4 11:07:57 CET 2023 add
Sat Nov  4 11:08:00 CET 2023 remove
Sat Nov  4 11:08:00 CET 2023 remove
</code></pre><p>Ok, so: something in this configuration is causing the ‚Äúadd‚Äù to match three times, but the remove to only match twice. That‚Äôs‚Ä¶ annoying, but not something we need to debug here, because we‚Äôre going to make these rules start / stop <code>systemd</code> services, and if the service is already running, then starting it again won‚Äôt do anything! ü•≥</p><p>I think if we were really committed, we could fix it with more precise rules (<code>udevadm monitor</code> showed us before that there were multiple devices matching this pattern). But it‚Äôs so <em>annoying</em> to troubleshoot udev rules that I didn‚Äôt want to spend any more time messing with it.</p><h2 id="step-3-connect-it-all-together">Step 3: Connect it all together</h2><p>Now that we‚Äôve got some ~reasonably working udev rules and a working systemd service, we just need to connect the two.</p><p>Modify the <code>/etc/udev/rules.d/10-spotify.rules</code> that we were using before to match this:</p><pre tabindex="0"><code>SUBSYSTEM==&#34;sound&#34;, ATTRS{id}==&#34;HTA100&#34;, ACTION==&#34;add&#34;, RUN+=&#34;/usr/bin/su flopbox -c &#39;systemctl --user start librespot.service&#39;&#34;
SUBSYSTEM==&#34;sound&#34;, ENV{ID_MODEL}==&#34;HTA100&#34;, ACTION==&#34;remove&#34;, RUN+=&#34;/usr/bin/su flopbox -c &#39;systemctl --user stop librespot.service&#39;&#34;
</code></pre><p>What we‚Äôre doing here is:</p><ul><li>changing from <code>root</code> to the lower-permissioned user that owns the librespot service (on my machine it‚Äôs called <code>flopbox</code>)</li><li>starting that service.</li></ul><p>Reload the udev rules again:</p><div><pre tabindex="0"><code data-lang="sh"><span><span>sudo udevadm control --reload
</span></span></code></pre></div><p>‚Ä¶.and try it out! It should work! I hope!</p><h2 id="phew-linux-is-wildly-inscrutable-sometimes">Phew, Linux is wildly inscrutable sometimes</h2><p>While I was putting this together, I ran across a number of other sources that had alternate ways of setting this up:</p><ul><li><p>Apparently there‚Äôs a way of <a href="https://github.com/liquidctl/liquidctl/blob/main/docs/linux/making-systemd-units-wait-for-devices.md">specifying the device as a direct dependency of the systemd service</a>, which feels‚Ä¶ maybe vaguely cleaner? But you still have to write udev rules <em>and</em> a systemd service, so there‚Äôs no advantage to me changing it at this point.</p></li><li><p>There‚Äôs an <a href="https://unix.stackexchange.com/questions/550279/udev-rule-to-trigger-systemd-service">alternative approach using <code>ENV{SYSTEMD_WANTS}</code> / <code>ENV{SYSTEMD_USER_WANTS}</code></a> which theoretically should do the trick, but which I couldn‚Äôt get working.</p></li><li><p><a href="https://unix.stackexchange.com/questions/550279/udev-rule-to-trigger-systemd-service#comment1021586_550281">Some people suggest using <code>--no-block</code></a> if you‚Äôre invoking the service with <code>systemd start</code>, but omitting that hasn‚Äôt caused any problems for me yet.</p></li></ul><p>I have no idea if these methods are better, or even what the tradeoffs of using these other approaches would be. I‚Äôm pretty frustrated at how difficult it is to get things working on linux sometimes ‚Äì I wish there was more investment in making the system fundamentals easy to understand, configure and debug.</p><p>But! It works, and I‚Äôm grateful that it‚Äôs possible to build things like this at all. ‚ú®</p><figure><img src="https://www.salon.com/posts/udev-systemd-spotify-usb-audio/spotify-connect-2.png" alt="A screenshot of the Spotify UI showing an attached network device named &#39;Hotdog&#39;"/><figcaption><p>Now playing on HOTDOG</p></figcaption></figure></div></div>
  </body>
</html>
