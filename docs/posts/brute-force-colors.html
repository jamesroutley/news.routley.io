<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://arnaud-carre.github.io/2022-12-30-amiga-ham/">Original</a>
    <h1>Brute Force Colors</h1>
    
    <div id="readability-page-1" class="page"><article role="main">
        <p>I want to share some of my recent findings when having fun with a very old and not really known graphics mode from 80 called “HAM”. Everything started when I wanted to add HAM support in my bitmap converter tool that I use to create my oldskool demos.</p>

<h2 id="the-challenge">The challenge</h2>
<p>Nowadays you don’t even notice when looking at photos in your web browser. But back in time, displaying a “realistic” image on screen was really a challenge. So let’s say you want to display this nice 16 million colors picture (24bits) on your old Amiga 500 computer.</p>

<p><em>Original: No palette, 24bits depth</em>
<img src="https://arnaud-carre.github.io/assets/img/ham/perso1_24.png" width="100%"/>
<em>Image courtesy of Farfar/lns</em></p>

<p>Basic Amiga could only use 32 colors, chosen from a 12bits depth palette only (4096 colors). So if you convert this picture to 32 colors using any PC tool you’ll probably get that:</p>

<p><em>32 colors palette, 12bits depth</em>
<img src="https://arnaud-carre.github.io/assets/img/ham/perso1_12_32c.png" width="100%"/></p>

<p>This doesn’t look great right? A palette of 32 colors is just not enough to display this kind of colorfull image.</p>

<h2 id="what-is-ham">What is HAM?</h2>
<p>HAM stands for “Hold And Modify” and is a really tricky video mode introduced by Commodore on their famous Amiga machine. Amiga engineers were ahead of time when they designed this mode. Standard video mode is palette indexed only. That is, a pixel is a 5bits index over a 32color palette. 
On Amiga, a pixel index could be up to 6 bits. Commodore could have said “ok let’s add another classic 64 colors mode using our 6bits pixel index”. But they took the more challenging path by introducing the HAM mode.
In HAM mode, each pixel needs 6 bits of data. From these 6 bits, 2 of them represent a HAM Code (0 to 3), and 4 a palette index (0 to 15). And here is the magic:</p>

<table>
  <thead>
    <tr>
      <th>HAM code</th>
      <th>Meaning during image decoding</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>00</td>
      <td>Use following 4bits to index the 16 colors palette (as a classic mode)</td>
    </tr>
    <tr>
      <td>01</td>
      <td>Use following 4bits to replace the Blue component of current color</td>
    </tr>
    <tr>
      <td>10</td>
      <td>Use following 4bits to replace the Red component of current color</td>
    </tr>
    <tr>
      <td>11</td>
      <td>Use following 4bits to replace the Green component of current color</td>
    </tr>
  </tbody>
</table>

<p>The magic (and also very tricky) is that it’s “almost” a no palette mode. Of course you can’t set any pixel to any RGB color in one go, but you can change any color component of the next pixel. ( R, G or B )</p>

<h2 id="color-distance">Color Distance</h2>

<p>Everything in the converter will rely on a “color distance” function, that should tell us how close a color is from the original pixel. In the converter, the input image has already been converted to 12bits ( RGB444 ), using Sierra dithering during this quantization process. So we need that kind of function:</p>

<div><div><pre><code><span>int</span>	<span>ColorDistance</span><span>(</span><span>Color444</span> <span>colorA</span><span>,</span> <span>Color444</span> <span>colorB</span><span>)</span>
<span>{</span>
	<span>int</span> <span>dr</span> <span>=</span> <span>abs</span><span>(</span><span>colorA</span><span>.</span><span>GetR</span><span>()</span> <span>-</span> <span>colorB</span><span>.</span><span>GetR</span><span>());</span>
	<span>int</span> <span>dg</span> <span>=</span> <span>abs</span><span>(</span><span>colorA</span><span>.</span><span>GetG</span><span>()</span> <span>-</span> <span>colorB</span><span>.</span><span>GetG</span><span>());</span>
	<span>int</span> <span>db</span> <span>=</span> <span>abs</span><span>(</span><span>colorA</span><span>.</span><span>GetB</span><span>()</span> <span>-</span> <span>colorB</span><span>.</span><span>GetB</span><span>());</span>
	<span>dr</span> <span>*=</span> <span>dr</span><span>;</span>
	<span>dg</span> <span>*=</span> <span>dg</span><span>;</span>
	<span>db</span> <span>*=</span> <span>db</span><span>;</span>
	<span>// empirical &#34;perceptual&#34; ratio</span>
	<span>return</span> <span>dr</span> <span>*</span> <span>3</span> <span>+</span> <span>dg</span> <span>*</span> <span>4</span> <span>+</span> <span>db</span> <span>*</span> <span>2</span><span>;</span>  	<span>// avoid final square root, as is doesn&#39;t change the compare order</span>
<span>}</span>
</code></pre></div></div>

<p>There is tons of literature about “perceptual” colors calculation (1). The problem is that everything you can find on the internet is dealing with 24bits or more colors. In our low end 12bits field, with only 16 levels of shade, it’s even hard to talk about sRGB or linear color space. I did plenty of tests, and the best empirical results are with 3,4,2 ratio for RGB.</p>

<h2 id="first-fast-version-of-the-ham-converter">First fast version of the HAM converter</h2>
<p>So I wanted to give it a try and convert some images to this mode. My naive converter just used this algorithm. At the start of each line, I set current_color to black. Then, for each pixel of the line, I try all 16 possible values of R, all 16 values of G and 16 values of B. That is 48 iterations only ( because HAM can only change one component at a time, R, G or B ). For these 48 possibilities, I keep the closest one to the original pixel color. ( using a color distance function, some talk about that at the end).
So far so good, it runs immediately on modern PC and produced that kind of awesome image:</p>

<p><em>HAM 12bits, no palette use</em>
<img src="https://arnaud-carre.github.io/assets/img/ham/perso1_ham_nopal.png" width="100%"/></p>

<p>With almost no effort we can display that kind of colorful image on a 1985 computer. Isn’t that impressive? HAM engineers had a wonderful idea back in time.</p>

<h2 id="color-artefacts">Color artefacts</h2>

<p>But our HAM journey isn’t over. If you look closely at the image, there are plenty of color artefacts.</p>

<p><img src="https://arnaud-carre.github.io/assets/img/ham/perso1_artefact.png" width="100%"/></p>

<p>This HAM image doesn’t use the 16 entries palette at all ( all palette is black ). It’s only using the ability to change R, G or B per pixel. If you look closely, the image is full of bad color artefacts. Looks like an old VHS on a NTSC monitor :) These artefacts are easy to understand.</p>

<table>
  <tbody>
    <tr>
      <td>original</td>
      <td>black(000)</td>
      <td>black(000)</td>
      <td>white(111)</td>
      <td>white(111)</td>
      <td>white(111)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>HAM code</td>
      <td> </td>
      <td> </td>
      <td>Set R</td>
      <td>Set G</td>
      <td>Set B</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>output</td>
      <td>black(000)</td>
      <td>black(000)</td>
      <td><strong>Red(100)</strong></td>
      <td><strong>Yellow(110)</strong></td>
      <td>white(111)</td>
      <td>white(111)</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>You will see some colourful artefacts when some drastic RGB change are required</p>

<p>Instead of having these pixels
<img src="https://arnaud-carre.github.io/assets/img/ham/line.png" width="100%"/></p>

<p>You got that…
<img src="https://arnaud-carre.github.io/assets/img/ham/line_ham.png" width="100%"/></p>

<h2 id="problem-to-solve">Problem to solve</h2>

<p>That’s why HAM also has a fixed 16 colors palette. If I had “white” in this small palette, I could use it to immediately switch from black (0,0,0) to white (1,1,1), and avoid the wrong red and yellow pixel of the previous exemple.</p>

<table>
  <tbody>
    <tr>
      <td>original</td>
      <td>black(000)</td>
      <td>black(000)</td>
      <td>white(111)</td>
      <td>white(111)</td>
      <td>white(111)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>HAM code</td>
      <td> </td>
      <td> </td>
      <td>use color index 1</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>output</td>
      <td>black(000)</td>
      <td>black(000)</td>
      <td>white(111)</td>
      <td>white(111)</td>
      <td>white(111)</td>
      <td>white(111)</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>So the idea is simple: if we want to get rid of color artefacts, we have to carefully select 16 colors in our palette to minimise the artefacts on the final image. But how to do that?</p>

<p>So let’s say I have a 16 colors palette. I can change my “find best HAM scanline” code adding 16 more iterations. First, I keep testing all 16 possible R changes, G and B. And then, I try to find an even better solution using the current palette. (it’s important to test in that order, because if two solutions have the same error, better take the HAM one, to not waste a precious palette entry)</p>

<p>Basically I could have one simple function like this:</p>

<div><div><pre><code><span>int</span> <span>ComputeHAMError</span><span>(</span> <span>const</span> <span>Bitmap</span><span>&amp;</span> <span>original</span><span>,</span> <span>const</span> <span>Color</span> <span>palette</span><span>[</span><span>16</span><span>]</span> <span>)</span>
</code></pre></div></div>

<p>So you can compute the overall error on the image when HAM encoding using a given palette. But how to create the optimal palette to have the smallest possible error?</p>

<h2 id="brute-force-is-sometimes-magic">Brute force is sometimes magic</h2>

<p>I’m supposed to be the optimizer guy. And I’m talking about brute force, you might laugh. Sometimes brute force has magic properties: as it walks the entire solution field, you may get the optimal solution of your problem. Obviously this is only valid if you can browse the entire solution field in a reasonable time. And for this specific problem, I don’t care about the processing time as it’s an offline process. Once the HAM data is generated, I can display it on the Amiga for free.</p>

<p>Amiga has 12bits color depth so any entry in the palette is a 12bits number (4096 possible values). What if we try all possible values for each palette entry? As palette entries are independent (you can swap entries without changing the result) there aren’t so many possibilities. And we have powerful PC to produce data for very low end Amiga right?</p>

<p>So the main brute force loop looks like this pseudo code:</p>

<div><div><pre><code>	<span>Color444</span> <span>palette</span><span>[</span><span>16</span><span>];</span>
	<span>// Loop through the 16 entries of the palette to build, one by one</span>
	<span>for</span> <span>(</span><span>int</span> <span>palIndex</span> <span>=</span> <span>0</span><span>;</span> <span>palIndex</span> <span>&lt;</span> <span>16</span><span>;</span> <span>palIndex</span><span>++</span><span>)</span>
	<span>{</span>
		<span>int</span> <span>bestError</span> <span>=</span> <span>MAX_ERROR</span><span>;</span>
		<span>Color444</span> <span>bestColor</span> <span>=</span> <span>0</span><span>;</span>
		<span>// then for each entry, try ALL possible Amiga colors, and compute a global image error when using this temporary palette</span>
		<span>for</span> <span>(</span><span>Color444</span> <span>bruteColor</span> <span>=</span> <span>0</span><span>;</span> <span>bruteColor</span> <span>&lt;</span> <span>4096</span><span>;</span> <span>bruteColor</span><span>++</span><span>)</span>
		<span>{</span>
			<span>palette</span><span>[</span><span>palIndex</span><span>]</span> <span>=</span> <span>bruteColor</span><span>;</span>
			<span>int</span> <span>err</span> <span>=</span> <span>ComputeHAMError</span><span>(</span><span>bitmap</span><span>,</span> <span>palette</span><span>);</span>	<span>// Compute a global image error with current palette</span>
			<span>if</span> <span>(</span><span>err</span> <span>&lt;</span> <span>bestError</span><span>)</span>
			<span>{</span>
				<span>bestColor</span> <span>=</span> <span>bruteColor</span><span>;</span>		<span>// keep tracking the best color for the current palette entry</span>
				<span>bestError</span> <span>=</span> <span>err</span><span>;</span>
			<span>}</span>
		<span>}</span>
		<span>// store the best color for this palette entry, and then continue with the next entry</span>
		<span>palette</span><span>[</span><span>palIndex</span><span>]</span> <span>=</span> <span>bestColor</span><span>;</span>  <span>// write final best color for this pal entry</span>
	<span>}</span>
</code></pre></div></div>

<p>ComputeHAMError function is calculating the best HAM image, using a palette as input. It also returns a error score that we try to minimize. So this function was immediate when we called it a single time, but now we have to call it 16*4096 times, so our tool will just run 65536 times slower!</p>

<p>Let’s see how it runs. Palette entries are walked one by one, and you can see how the overall image quality increases when adding colors to the HAM palette.</p>

<p><em>note: this is animated PNG file, I hope your browser supports it</em>
<img src="https://arnaud-carre.github.io/assets/img/ham/ham_palette.png" width="100%"/></p>

<p>So to compare results, here is an animation with the original 24bits image, then a temp unlimited colors but 12bits depth image, with dithering. And finally the HAM version of it, that could be displayed on a 1985 Amiga machine! Not so bad heh?</p>

<p><em>Final comparaison: 24bits original, 12bits convert with dithering, and HAM version compatible with 1985 Amiga</em>
<img src="https://arnaud-carre.github.io/assets/img/ham/final_compare.png" width="100%"/></p>

<p><em>Same three images compare with another picture</em>
<img src="https://arnaud-carre.github.io/assets/img/ham/final_compare2.png" width="100%"/></p>

<h2 id="optimization">Optimization</h2>

<p>I’m doing my tests on a AMD Ryzen 7 2700X, 8 cores (16 threads ). And the first version is producing a 320*256 pixels Amiga HAM image in…. <strong>8 minutes and 37 seconds</strong>. Wow. I’m sure you know plenty of faster HAM converters, but they probably don’t scan the complete solution field.
However, 8m to proceed with a low res image on modern hardware is not really satisfying (even if we scan the entire solution field). to me the real fun part of the job starts now: optimizing!</p>

<p>Basically, the outer loop is 65536 iterations ( 16 palette entries to fill, with 4096 possible colors each ). Then we call FindBestPixel for each of the 320*256 pixels of the picture. Finally, in FindBestPixel, we’re computing 64 color distances ( 16 possibilities to change R, 16 for G, 16 for B and finally 16 possibilities to index into the HAM palette )</p>

<p>As I knew this ColorDistance function will be called <strong>a lot</strong>, I already optimize it a bit using small lookup tables. So 8m37s version is already using that kind of function:</p>

<div><div><pre><code><span>ColorError_t</span>	<span>Distance</span><span>(</span><span>const</span> <span>Color444</span><span>&amp;</span> <span>rv</span><span>)</span> <span>const</span>
<span>{</span>
	<span>const</span> <span>int</span> <span>idxR</span> <span>=</span> <span>(</span><span>GetR</span><span>()</span> <span>&lt;&lt;</span> <span>4</span><span>)</span> <span>|</span> <span>rv</span><span>.</span><span>GetR</span><span>();</span>
	<span>const</span> <span>int</span> <span>idxG</span> <span>=</span> <span>(</span><span>GetG</span><span>()</span> <span>&lt;&lt;</span> <span>4</span><span>)</span> <span>|</span> <span>rv</span><span>.</span><span>GetG</span><span>();</span>
	<span>const</span> <span>int</span> <span>idxB</span> <span>=</span> <span>(</span><span>GetB</span><span>()</span> <span>&lt;&lt;</span> <span>4</span><span>)</span> <span>|</span> <span>rv</span><span>.</span><span>GetB</span><span>();</span>
	<span>return</span> <span>LazyTables</span><span>::</span><span>distR</span><span>[</span><span>idxR</span><span>]</span> <span>+</span> <span>LazyTables</span><span>::</span><span>distG</span><span>[</span><span>idxG</span><span>]</span> <span>+</span> <span>LazyTables</span><span>::</span><span>distB</span><span>[</span><span>idxB</span><span>];</span>
<span>}</span>
</code></pre></div></div>
<p>Pretty simple, I have three small lookup tables of 256 entries each that contains proper weighted distance between any two 4bits shade values. ( one table for R, G and B )</p>

<p>And the main “per pixel” function is looking like this:</p>

<figure><pre><code data-lang="cpp"><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td><pre><span>Color444</span>	<span>BruteForceHam</span><span>::</span><span>findBestPixel</span><span>(</span><span>const</span> <span>Color444</span><span>&amp;</span> <span>original</span><span>,</span> <span>const</span> <span>Color444</span><span>&amp;</span> <span>previous</span><span>,</span> <span>ColorError_t</span><span>&amp;</span> <span>errOut</span><span>,</span> <span>const</span> <span>AmigaColor</span><span>*</span> <span>pal</span><span>,</span> <span>int</span> <span>palSize</span><span>,</span> <span>HamPixelState</span><span>&amp;</span> <span>state</span><span>)</span> <span>const</span>
<span>{</span>
	<span>ColorError_t</span> <span>err</span> <span>=</span> <span>kColorErrorMax</span><span>;</span>
	<span>Color444</span> <span>newPixel</span><span>;</span>
	<span>Color444</span> <span>sc</span><span>;</span>
	<span>// brute force all R</span>
	<span>for</span> <span>(</span><span>int</span> <span>v</span> <span>=</span> <span>0</span><span>;</span> <span>v</span> <span>&lt;</span> <span>16</span><span>;</span> <span>v</span><span>++</span><span>)</span>
	<span>{</span>
		<span>sc</span> <span>=</span> <span>previous</span><span>;</span>
		<span>sc</span><span>.</span><span>SetR4</span><span>(</span><span>v</span><span>);</span>
		<span>ColorError_t</span> <span>d</span> <span>=</span> <span>original</span><span>.</span><span>Distance</span><span>(</span><span>sc</span><span>);</span>
		<span>if</span> <span>(</span><span>d</span> <span>&lt;</span> <span>err</span><span>)</span>
		<span>{</span>
			<span>state</span><span>.</span><span>hamCode</span> <span>=</span> <span>2</span><span>;</span>		<span>// R ham code is 10</span>
			<span>state</span><span>.</span><span>hamIndex</span> <span>=</span> <span>v</span><span>;</span>
			<span>newPixel</span> <span>=</span> <span>sc</span><span>;</span>
			<span>err</span> <span>=</span> <span>d</span><span>;</span>
		<span>}</span>
	<span>}</span>
	<span>// same 16 iterations loop for G</span>
	<span>// same 16 iterations loop for B</span>
	<span>// same 16 iterations loop for palette search</span>
	<span>errOut</span> <span>=</span> <span>err</span><span>;</span>
	<span>return</span> <span>newPixel</span><span>;</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>At line 10 and 11 that we overwrite the R component with our searching value, and then we compute the distance with the original pixel. The Distance function is supposed to be fast, but it still doing a lot of things: Extract RGB component of two Color444, and then read from 3 lookup tables.
Here is a simple improvement: When we’re trying all possibilities for R, the G and B color distances are constant! So why first computing the G and B distance outside of the loop, and then only fetch the R lookup table? Let’s try, the new version looks like that:</p>

<figure><pre><code data-lang="cpp"><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td><pre><span>// brute force all R</span>
<span>{</span>
	<span>ColorError_t</span> <span>distGB</span> <span>=</span> <span>Color444</span><span>::</span><span>DistanceG</span><span>(</span><span>original</span><span>.</span><span>GetG</span><span>(),</span> <span>previous</span><span>.</span><span>GetG</span><span>())</span> <span>+</span> <span>Color444</span><span>::</span><span>DistanceB</span><span>(</span><span>original</span><span>.</span><span>GetB</span><span>(),</span> <span>previous</span><span>.</span><span>GetB</span><span>());</span>
	<span>for</span> <span>(</span><span>int</span> <span>v</span> <span>=</span> <span>0</span><span>;</span> <span>v</span> <span>&lt;</span> <span>16</span><span>;</span> <span>v</span><span>++</span><span>)</span>
	<span>{</span>
		<span>ColorError_t</span> <span>d</span> <span>=</span> <span>distGB</span> <span>+</span> <span>Color444</span><span>::</span><span>DistanceR</span><span>(</span><span>original</span><span>.</span><span>GetR</span><span>(),</span> <span>v</span><span>);</span>
		<span>if</span> <span>(</span><span>d</span> <span>&lt;</span> <span>err</span><span>)</span>
		<span>{</span>
			<span>state</span><span>.</span><span>hamCode</span> <span>=</span> <span>2</span><span>;</span>		<span>// R ham code is 10</span>
			<span>state</span><span>.</span><span>hamIndex</span> <span>=</span> <span>v</span><span>;</span>
			<span>newPixel</span> <span>=</span> <span>previous</span><span>;</span>
			<span>newPixel</span><span>.</span><span>SetR4</span><span>(</span><span>v</span><span>);</span>
			<span>err</span> <span>=</span> <span>d</span><span>;</span>
		<span>}</span>
	<span>}</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p><em>Note: at line 6 we’re calling DistanceR, that is only fetching from 1 lookup table. Also we now only call SetR4 in case of a better pixel</em></p>

<p>New score: <strong>4 minutes and 36 sec</strong>! Almost two times faster, nice</p>

<p>What could we improve now? there are 64 conditional branches executed per pixel ( if (d &lt; err) ). Modern CPU use really smart branch predictors (3) but maybe we could improve things by removing the branch. 
What if we could use a conditional mov? ( cmov ). Right now, if the branch is not taken, we have to set state.hamCode, state.hamIndex and newPixel. If we could compute newPixel at the very end of the function, using the hamCode, we may use a conditional move by storing the hamcode <strong>in</strong> the distance! Like, let’s say we put the hamcode in the lowest 6bits of err. We could try to make the compiler generate a conditional mov by using that kind of C:</p>

<figure><pre><code data-lang="cpp"><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
</pre></td><td><pre><span>int</span> <span>distGB</span> <span>=</span> <span>Color444</span><span>::</span><span>DistanceG</span><span>(</span><span>original</span><span>.</span><span>GetG</span><span>(),</span> <span>previous</span><span>.</span><span>GetG</span><span>())</span> <span>+</span> <span>Color444</span><span>::</span><span>DistanceB</span><span>(</span><span>original</span><span>.</span><span>GetB</span><span>(),</span> <span>previous</span><span>.</span><span>GetB</span><span>());</span>
<span>const</span> <span>int</span><span>*</span> <span>tabR</span> <span>=</span> <span>LazyTables</span><span>::</span><span>distR</span> <span>+</span> <span>(</span><span>original</span><span>.</span><span>GetR</span><span>()</span> <span>&lt;&lt;</span> <span>4</span><span>);</span>
<span>for</span> <span>(</span><span>int</span> <span>v</span> <span>=</span> <span>0</span><span>;</span> <span>v</span> <span>&lt;</span> <span>16</span><span>;</span> <span>v</span><span>++</span><span>)</span>
<span>{</span>
	<span>unsigned</span> <span>int</span> <span>d</span> <span>=</span> <span>distGB</span> <span>+</span> <span>*</span><span>tabR</span><span>++</span><span>;</span>
	<span>d</span> <span>=</span> <span>(</span><span>d</span><span>&lt;&lt;</span><span>6</span><span>)</span> <span>|</span> <span>((</span><span>2</span> <span>&lt;&lt;</span> <span>4</span><span>)</span> <span>|</span> <span>v</span><span>);</span>	<span>// R ham code is 10</span>
	<span>err</span> <span>=</span> <span>(</span><span>d</span> <span>&lt;</span> <span>err</span><span>)</span> <span>?</span> <span>d</span> <span>:</span> <span>err</span><span>;</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>_Note: Line 7 should generate a conditional mov instruction now instead of a branch</p>

<p>Woow what a surprise! The code is now running in <strong>2 minutes and 47 seconds</strong>! Let’s check the assembly code if the compiler properly generated conditional mov instead of conditional branch:</p>

<figure><pre><code data-lang="asm"><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td><pre>00007FF755953C10:
		movdqu      xmm1,xmmword ptr [r10]  
		lea         eax,[rcx+4]  
		movd        xmm0,ecx  
		lea         r10,[r10+20h]  
		paddd       xmm1,xmm4  
		pshufd      xmm0,xmm0,0  
		pslld       xmm1,xmm6  
		paddd       xmm0,xmm5  
		add         ecx,r15d  
		por         xmm1,xmm0  
		movd        xmm0,eax  
		pshufd      xmm0,xmm0,0  
		por         xmm1,xmm7  
		pminud      xmm2,xmm1  
		paddd       xmm0,xmm5  
		movdqu      xmm1,xmmword ptr [r10-10h]  
		paddd       xmm1,xmm4  
		pslld       xmm1,xmm6  
		por         xmm1,xmm0  
		por         xmm1,xmm7  
		pminud      xmm3,xmm1  
		cmp         ecx,10h  
		jl          BruteForceHam::findBestPixel+0E0h (07FF755953C10h)  
</pre></td></tr></tbody></table></code></pre></figure>

<p>Wow it’s WAY better than I was expecting at first! Removing the conditional branch also triggered the compiler auto-vectorization!</p>

<p>Look at that beauty: The original 16 iterations loop is now a 2 times unrolled loop, testing 4 colors at a time using 128bits SIMD register (keeping the lowest value thanks to pminud line 15 and 22). This code is looping 2 times ( ecx goes from 0 to 16 with increment by 8 in r15d line 10)</p>

<p>To be honest, auto-vectorizing this small C loop is really a beauty. (see how it reads 4 consecutive values in DistanceR lookup table line 2 and 17)</p>

<h2 id="multi-threading">Multi Threading</h2>

<p>Now we went from <strong>8m37s</strong> to <strong>2m47s</strong> ( 3 times faster ) just by modifying few lines of C, why not using all my CPU cores?</p>

<p>As a rule of thumb when you try to optimize something, <strong>always</strong> profile your code (even a simple time print at the end is enough to try several optimizations). And please, do <strong>not</strong> start multi-threading before you’re pretty happy with your single thread version.</p>

<p>Also, a good advice is to keep an easy way to switch back to the single thread version. (make things easier to debug, to test new ideas, etc)</p>

<p>So our HAM brute force algorithm is suited for multi-threading. High level code loop is:</p>

<div><div><pre><code><span>for</span> <span>(</span><span>int</span> <span>palEntry</span><span>=</span><span>0</span><span>;</span><span>palEntry</span><span>&lt;</span><span>16</span><span>;</span><span>palEntry</span><span>++</span><span>)</span>
  <span>for</span> <span>(</span><span>int</span> <span>bruteColor</span><span>=</span><span>0</span><span>;</span><span>bruteColor</span><span>&lt;</span><span>4096</span><span>;</span><span>bruteColor</span><span>++</span><span>)</span>
    <span>palette</span><span>[</span><span>palEntry</span><span>]</span> <span>=</span> <span>bruteColor</span><span>;</span>
    <span>Err</span> <span>=</span> <span>ComputeHAMErrorOnWholeImage</span><span>(</span> <span>palette</span> <span>)</span>
</code></pre></div></div>

<p>The palette entries should be searched one by one. ( when we’re brute forcing palette entry 6, palette entries 0,1,2,3,4 and 5 are supposed to have been already brute forced, and fixed )
So basically the high level loop of MT version will look like:</p>

<div><div><pre><code><span>void</span> <span>threadMain</span><span>(</span><span>Color444</span><span>*</span> <span>palette</span><span>,</span> <span>int</span> <span>palEntry</span><span>,</span> <span>int</span> <span>bruteStart</span><span>,</span> <span>int</span> <span>bruteStop</span><span>)</span>
<span>{</span>
  <span>for</span> <span>(</span><span>int</span> <span>bruteColor</span><span>=</span><span>bruteStart</span><span>;</span><span>bruteColor</span><span>&lt;</span><span>bruteStop</span><span>;</span><span>bruteColor</span><span>++</span><span>)</span>
    <span>palette</span><span>[</span><span>palEntry</span><span>]</span> <span>=</span> <span>bruteColor</span><span>;</span>
    <span>Err</span> <span>=</span> <span>ComputeHAMErrorOnWholeImage</span><span>(</span> <span>palette</span> <span>)</span>
<span>}</span>

<span>for</span> <span>(</span><span>int</span> <span>palEntry</span><span>=</span><span>0</span><span>;</span><span>palEntry</span><span>&lt;</span><span>16</span><span>;</span><span>palEntry</span><span>++</span><span>)</span>
  <span>Setup</span> <span>a</span> <span>bruteColor</span> <span>start</span> <span>and</span> <span>end</span> <span>per</span> <span>thread</span>
  <span>Run</span> <span>N</span> <span>threads</span><span>,</span> <span>each</span> <span>one</span> <span>with</span> <span>its</span> <span>own</span> <span>start</span><span>/</span><span>stop</span> <span>bruteColor</span>
  <span>wait</span> <span>for</span> <span>all</span> <span>threads</span> <span>to</span> <span>finish</span>
  <span>walk</span> <span>N</span> <span>thread</span> <span>results</span> <span>to</span> <span>keep</span> <span>the</span> <span>best</span> <span>one</span>
  <span>go</span> <span>to</span> <span>next</span> <span>palette</span> <span>entry</span>
</code></pre></div></div>

<p>And the result on my 8cores, 16 threads AMD CPU is… <strong>17 seconds</strong>!</p>

<h2 id="conclusion">Conclusion</h2>

<p>Having fun doing some old skool stuff often ends in digging into modern optimization. We had fun looking at colourful pixels, and also went from <strong>8m37s</strong> to <strong>17s</strong></p>

<p>Is there anything we could improve? Sure! I didn’t spend so much time on optimising the code so there is a high chance some great optimizations are still missing.</p>

<p>Also regarding the HAM final quality. We use brute force so we’re supposed to have the best possible result. But keep in mind everything just relies on the ColorDistance function. And this function is not perfect. Like, maybe we could do all calculations in linear space, maybe we should use a proper (but slower) distance function such as CIELAB. Plenty of things to explore!</p>

<p>This code is part of my abc2 tool ( AmigAtari Bitmap Converter ). I will soon release it on github so you guys could have fun with it and improve.</p>

<h2 id="links">Links</h2>

<p>(1) <a href="">https://en.wikipedia.org/wiki/Color_difference</a></p>

<p>(2) <a href="">https://scientificgems.wordpress.com/stuff/neuquant-fast-high-quality-image-quantization/</a></p>

<p>(3) <a href="">https://danluu.com/branch-prediction/</a></p>

      </article></div>
  </body>
</html>
