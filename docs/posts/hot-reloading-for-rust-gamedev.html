<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rygoldstein.com/posts/hot-reloading-rust.html">Original</a>
    <h1>Hot Reloading for Rust Gamedev</h1>
    
    <div id="readability-page-1" class="page"><article>
            <h2>An Idea</h2>
<p>I used to think hot reloading was something only “managed” languages could do, not “compiled” languages. When I change a React component it can update on the page; when I change a line of code in a Rust daemon I have to kill the program and bring it back up. This makes writing games in the “compiled” languages somewhat painful. Games tend to be highly stateful; if a bit of behavior only triggers in a particular state, it can be annoying to return to that state after relaunching the game. For example, if you’re tweaking font size in a dialogue system, you’ll need to re-initiate a dialogue each time you change the code.</p>
<p>Last year I had a realization while working on my hobby programming language (called Felt). Felt compiles to WebAssembly (WASM); in WASM the code for your application is entirely separate from its linear memory. It’s really easy to replace the code and keep the memory the same. As long as your program can still interpret that memory the same way, this gives you hot reloading for free. I made a demo in Felt where a single keystroke recompiled the game and reloaded it live, allowing you to change all the rendering or game logic without having to relaunch or replay anything.</p>
<p>This year I’ve been working on Felt a lot less. Instead I’m currently making a small game in Rust. Pretty early on I ran into some font layout bugs in my new game engine, and wanted seamless code reloading. Is such a thing possible?</p>
<p>It is, if we take advantage of dynamic libraries. There are two ways to link binary blobs of code together: static linking (where we concatenate the binaries into one final product) and dynamic linking (where the libraries are found on-disk each time the program launches). By default Rust statically links crates together, which means we can’t easily load in a new version of our game’s logic. But if we dynamically link the crates, we can reload the dynamic library.</p>
<h2>The “Easy” Way</h2>
<p>At first I tried the <a href="https://docs.rs/hot-lib-reloader/latest/hot_lib_reloader/"><code>hot-lib-reloader</code> crate</a>. It seemed promising, and has a nice API; take this example from their docs:</p>
<pre><code><span>#[hot_lib_reloader::hot_module(dylib = <span>&#34;lib&#34;</span>)]</span>
<span>mod</span> <span>hot_lib</span> <span>{</span>
    
    
    
    <span>hot_functions_from_file!</span><span>(</span><span>&#34;lib/src/lib.rs&#34;</span><span>)</span><span>;</span>

    
    
    <span>pub</span> <span>use</span> <span>lib<span>::</span></span><span>State</span><span>;</span>
<span>}</span>

<span>fn</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
    <span>let</span> <span>mut</span> state <span>=</span> <span>hot_lib<span>::</span></span><span>State</span> <span>{</span> counter<span>:</span> <span>0</span> <span>}</span><span>;</span>
    
    <span>loop</span> <span>{</span>
        <span>hot_lib<span>::</span></span><span>step</span><span>(</span><span>&amp;</span><span>mut</span> state<span>)</span><span>;</span>
        <span>std<span>::</span>thread<span>::</span></span><span>sleep</span><span>(</span><span>std<span>::</span>time<span>::</span></span><span>Duration</span><span>::</span><span>from_secs</span><span>(</span><span>1</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span></code></pre>
<p>That macro automatically handles a bunch of binding work for us. Unfortunately, it also doesn’t work. Rust 2024 requires that the <code>#[no_mangle]</code> attribute be decorated as <code>unsafe</code> (because it allows a bunch of link-time badness), so it now looks like <code>#[unsafe(no_mangle)]</code>. <code>hot-lib-reloader</code> doesn’t understand this syntax. There are some open PRs to add support, but I don’t really want to get that far into the weeds. Instead I think it’s best if we cut through the magic and do the bindings ourselves.</p>
<h2>The Simple Way</h2>
<p>I have my game’s logic defines in a separate crate called <code>game-core</code>, with the following stanza in its <code>Cargo.toml</code> to make it a dynamic library:</p>
<pre><code><span>[</span><span>lib</span><span>]</span>
<span>crate-type</span> <span>=</span> <span>[</span><span>&#34;rlib&#34;</span><span>,</span> <span>&#34;dylib&#34;</span><span>]</span></code></pre>
<p>The lib exports some functions that look like this:</p>
<pre><code><span>use</span> <span>async_ffi<span>::</span></span><span>LocalFfiFuture</span><span>;</span>

<span>struct</span> <span>GameState</span> <span>{</span>
  
<span>}</span>

<span>#[unsafe(no_mangle)]</span>
<span>pub</span> <span>fn</span> <span>init</span><span>(</span>venus<span>:</span> <span>&amp;</span><span>&#39;static</span> <span>mut</span> <span>Venus</span><span>)</span> <span>-&gt;</span> <span>LocalFfiFuture</span><span>&lt;</span><span>Box</span><span>&lt;</span><span>GameState</span><span>&gt;&gt;</span> <span>{</span>
  
<span>}</span>

<span>#[unsafe(no_mangle)]</span>
<span>pub</span> <span>fn</span> <span>tick</span><span>(</span>venus<span>:</span> <span>&amp;</span><span>mut</span> <span>Venus</span><span>,</span> game_state<span>:</span> <span>&amp;</span><span>mut</span> <span>GameState</span><span>)</span> <span>-&gt;</span> <span>bool</span> <span>{</span>
  
<span>}</span></code></pre>
<p>We have a function to load everything and initialize our game state (boxed so that the caller doesn’t need to know its size), and then a function that advances our game by a frame.</p>
<p>Then the dev executable looks like this:</p>
<pre><code><span>use</span> <span>async_ffi<span>::</span></span><span>LocalFfiFuture</span><span>;</span>
<span>use</span> <span>libloading<span>::</span></span><span>{</span><span>Library</span><span>,</span> library_filename<span>}</span><span>;</span>
<span>use</span> <span>venus<span>::</span></span><span>{</span><span>Color</span><span>,</span> <span>Venus</span><span>}</span><span>;</span>

<span>struct</span> <span>GameState</span><span>;</span>

<span>type</span> <span>Init</span> <span>=</span> <span>unsafe</span> <span>extern</span> <span>&#34;C&#34;</span> <span>fn</span><span>(</span>venus<span>:</span> <span>&amp;</span><span>mut</span> <span>Venus</span><span>)</span> <span>-&gt;</span> <span>LocalFfiFuture</span><span>&lt;</span><span>Box</span><span>&lt;</span><span>GameState</span><span>&gt;&gt;</span><span>;</span>

<span>type</span> <span>Tick</span> <span>=</span> <span>unsafe</span> <span>extern</span> <span>&#34;C&#34;</span> <span>fn</span><span>(</span>venus<span>:</span> <span>&amp;</span><span>mut</span> <span>Venus</span><span>,</span> game_state<span>:</span> <span>&amp;</span><span>mut</span> <span>GameState</span><span>)</span> <span>-&gt;</span> <span>bool</span><span>;</span>

<span>fn</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
    <span>Venus</span><span>::</span><span>run</span><span>(</span>
        <span>async</span> <span>|</span>venus<span>|</span> <span>game</span><span>(</span>venus<span>)</span><span>.</span><span>await</span><span>.</span><span>unwrap</span><span>(</span><span>)</span><span>,</span>
        <span>venus<span>::</span></span><span>Settings</span><span>::</span><span>default</span><span>(</span><span>)</span><span>,</span>
    <span>)</span><span>;</span>
<span>}</span>

<span>async</span> <span>fn</span> <span>game</span><span>(</span><span>mut</span> venus<span>:</span> <span>Venus</span><span>)</span> <span>-&gt;</span> <span>anyhow<span>::</span></span><span>Result</span><span>&lt;</span><span>(</span><span>)</span><span>&gt;</span> <span>{</span>
    <span>let</span> filename <span>=</span> <span>library_filename</span><span>(</span><span>&#34;game_core&#34;</span><span>)</span><span>.</span><span>to_owned</span><span>(</span><span>)</span><span>;</span>
    <span>let</span> filename <span>=</span> filename<span>.</span><span>to_str</span><span>(</span><span>)</span><span>.</span><span>unwrap</span><span>(</span><span>)</span><span>;</span>
    <span>cargo</span><span>(</span><span>&amp;</span><span>[</span><span>&#34;build&#34;</span><span>,</span> <span>&#34;-p&#34;</span><span>,</span> <span>&#34;game-core&#34;</span><span>]</span><span>)</span><span>?</span><span>;</span>
    <span>let</span> path <span>=</span> <span>format!</span><span>(</span><span>&#34;target/debug/{filename}&#34;</span><span>)</span><span>;</span>
    <span>let</span> <span>mut</span> lib <span>=</span> <span>unsafe</span> <span>{</span> <span>Library</span><span>::</span><span>new</span><span>(</span><span>&amp;</span>path<span>)</span><span>?</span> <span>}</span><span>;</span>
    <span>let</span> <span>mut</span> init<span>:</span> <span>libloading<span>::</span></span><span>Symbol</span><span>&lt;</span><span>Init</span><span>&gt;</span> <span>=</span> <span>unsafe</span> <span>{</span> lib<span>.</span><span>get</span><span>(</span><span>b&#34;init&#34;</span><span>)</span><span>?</span> <span>}</span><span>;</span>
    <span>let</span> <span>mut</span> tick<span>:</span> <span>libloading<span>::</span></span><span>Symbol</span><span>&lt;</span><span>Tick</span><span>&gt;</span> <span>=</span> <span>unsafe</span> <span>{</span> lib<span>.</span><span>get</span><span>(</span><span>b&#34;tick&#34;</span><span>)</span><span>?</span> <span>}</span><span>;</span>

    <span>let</span> <span>mut</span> game_state <span>=</span> <span>unsafe</span> <span>{</span> <span>init</span><span>(</span><span>&amp;</span><span>mut</span> venus<span>)</span><span>.</span><span>await</span> <span>}</span><span>;</span>

    <span>loop</span> <span>{</span>
        <span>unsafe</span> <span>{</span>
            <span>if</span> <span>!</span><span>tick</span><span>(</span><span>&amp;</span><span>mut</span> venus<span>,</span> <span>&amp;</span><span>mut</span> game_state<span>)</span> <span>{</span>
                <span>break</span> <span>Ok</span><span>(</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>

        <span>if</span> venus<span>.</span><span>is_key_pressed</span><span>(</span><span>venus<span>::</span></span><span>Key</span><span>::</span><span>F5</span><span>)</span> <span>{</span>
            venus<span>.</span><span>clear</span><span>(</span><span>Color</span><span>::</span><span>WHITE</span><span>)</span><span>;</span>
            venus<span>.</span><span>end_frame</span><span>(</span><span>)</span><span>.</span><span>await</span><span>;</span>
            <span>cargo</span><span>(</span><span>&amp;</span><span>[</span><span>&#34;build&#34;</span><span>,</span> <span>&#34;-p&#34;</span><span>,</span> <span>&#34;game-core&#34;</span><span>]</span><span>)</span><span>?</span><span>;</span>
            lib <span>=</span> <span>unsafe</span> <span>{</span> <span>Library</span><span>::</span><span>new</span><span>(</span><span>&amp;</span>path<span>)</span><span>?</span> <span>}</span><span>;</span>
            init <span>=</span> <span>unsafe</span> <span>{</span> lib<span>.</span><span>get</span><span>(</span><span>b&#34;init&#34;</span><span>)</span><span>?</span> <span>}</span><span>;</span>
            tick <span>=</span> <span>unsafe</span> <span>{</span> lib<span>.</span><span>get</span><span>(</span><span>b&#34;tick&#34;</span><span>)</span><span>?</span> <span>}</span><span>;</span>
        <span>}</span>

        <span>if</span> venus<span>.</span><span>is_key_pressed</span><span>(</span><span>venus<span>::</span></span><span>Key</span><span>::</span><span>F6</span><span>)</span> <span>{</span>
            game_state <span>=</span> <span>unsafe</span> <span>{</span> <span>init</span><span>(</span><span>&amp;</span><span>mut</span> venus<span>)</span><span>.</span><span>await</span> <span>}</span><span>;</span>
        <span>}</span>

        venus<span>.</span><span>end_frame</span><span>(</span><span>)</span><span>.</span><span>await</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>fn</span> <span>cargo</span><span>(</span>args<span>:</span> <span>&amp;</span><span>[</span><span>&amp;</span><span>str</span><span>]</span><span>)</span> <span>-&gt;</span> <span>anyhow<span>::</span></span><span>Result</span><span>&lt;</span><span>(</span><span>)</span><span>&gt;</span> <span>{</span>
    <span>println!</span><span>(</span><span>&#34;Building project...&#34;</span><span>)</span><span>;</span>
    <span>let</span> exit_status <span>=</span> <span>Command</span><span>::</span><span>new</span><span>(</span><span>&#34;cargo&#34;</span><span>)</span><span>.</span><span>args</span><span>(</span>args<span>)</span><span>.</span><span>spawn</span><span>(</span><span>)</span><span>?</span><span>.</span><span>wait</span><span>(</span><span>)</span><span>?</span><span>;</span>
    <span>if</span> exit_status<span>.</span><span>success</span><span>(</span><span>)</span> <span>{</span>
        <span>Ok</span><span>(</span><span>(</span><span>)</span><span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>anyhow<span>::</span></span><span>bail!</span><span>(</span><span>&#34;Failed to compile project&#34;</span><span>)</span>
    <span>}</span>
<span>}</span></code></pre>
<p>If you press F5, the screen clears out white and the game is re-compiled and then reloaded. If you press F6, the game restarts. I was pretty surprised at how simple and easy this was! At first I was thinking about setting up a watcher to re-compile the game lib, but compilation is fast enough (~0.5-2 seconds) that it’s worth doing the simple thing and compiling each time we reload. That way I know we’re always running the most up-to-date version.</p>
<p>There are caveats, the major one being that any kind of static state in the <code>game-core</code> lib won’t persist between reloads. This rules out using a library like <a href="https://macroquad.rs/"><code>macroquad</code></a> which has a lot of implicit global state. I happen to be crotchety and prone to writing my own game engines regardless, so that doesn’t bother me. It also breaks font rendering in my game, for reasons I haven’t yet debugged (when you reload, characters that haven’t been rasterized and cached yet render as a square instead). Otherwise it’s been a nice experience to program a game with decent hot-reloading built in, without needing to add a second scripting language to my project.</p>
<p>This isn’t a Rust specific trick, by-the-by. The basic principles here are just as applicable to languages like C, C++, Zig, or Hare: essentially any language that compiles to native libraries can do much the same thing.</p>



        </article></div>
  </body>
</html>
