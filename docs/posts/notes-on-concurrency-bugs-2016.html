<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://danluu.com/concurrency-bugs/">Original</a>
    <h1>Notes on Concurrency Bugs (2016)</h1>
    
    <div id="readability-page-1" class="page"><strong>Notes on concurrency bugs</strong> <p>Do concurrency bugs matter? From the literature, we know that <a href="http://danluu.com/postmortem-lessons/">most reported bugs in distributed systems</a> have really simple causes and can be caught by trivial tests, even when we only look at bugs that cause really bad failures, like loss of a cluster or data corruption. The filesystem literature echos this result -- <a href="http://danluu.com/file-consistency/">a simple checker that looks for totally unimplemented error handling can find hundreds of serious data corruption bugs</a>. Most bugs are simple, at least if you measure by bug count. But if you measure by debugging time, the story is a bit different.</p> <p>Just from personal experience, I&#39;ve spent more time debugging complex non-deterministic failures than all other types of bugs combined. In fact, I&#39;ve spent more time debugging some individual non-deterministic bugs (weeks or months) than on all other bug types combined. Non-deterministic bugs are rare, but they can be extremely hard to debug and they&#39;re a productivity killer. Bad non-deterministic bugs take so long to debug that relatively large investments in tools and prevention can be worth it.</p> <p>Let&#39;s see what the academic literature has to say on non-deterministic bugs. There&#39;s a lot of literature out there, so let&#39;s narrow things down by looking at one relatively well studied area: concurrency bugs. We&#39;ll start with the literature on single-machine concurrency bugs and then look at distributed concurrency bugs.</p> <h3 id="fonseca-et-al-dsn-10-http-concurrency-mpi-sws-org-dsn2010-concurrencybugs-pdf"><a href="http://concurrency.mpi-sws.org/dsn2010-concurrencybugs.pdf">Fonseca et al. DSN &#39;10</a></h3> <p>They studied MySQL concurrency bugs from 2003 to 2009 and found the following:</p> <h4 id="more-non-deadlock-bugs-63-than-deadlock-https-en-wikipedia-org-wiki-deadlock-bugs-40">More non-deadlock bugs (63%) than <a href="https://en.wikipedia.org/wiki/Deadlock">deadlock</a> bugs (40%)</h4> <p>Note that these numbers sum to more than 100% because some bugs are tagged with multiple causes. This is roughly in line with the Lu et al. ASPLOS &#39;08 paper (which we&#39;ll look at later), which found that 30% of the bugs they examined were deadlock bugs.</p> <h4 id="15-of-examined-failures-were-semantic">15% of examined failures were semantic</h4> <p>The paper defines a semantic failure as one &#34;where the application provides the user with a result that violates the intended semantics of the application&#34;. The authors also find that &#34;the vast majority of semantic bugs (92%) generated subtle violations of application semantics&#34;. By their nature, these failures are likely to be undercounted -- it&#39;s pretty hard to miss a deadlock, but it&#39;s easy to miss subtle data corruption.</p> <h4 id="15-of-examined-failures-were-latent">15% of examined failures were latent</h4> <p>The paper defines latent as bugs that &#34;do not become immediately visible to users.&#34;. Unsurprisingly, the paper finds that latent failures are closely related to semantic failures; 92% of latent failures are semantic and vice versa. The 92% number makes this finding sound more precise than it really is -- it&#39;s just that 11 out of the 12 semantic failures are latent and vice versa. That could have easily been 11 out of 11 (100%) or 10 out of 12 (83%).</p> <p>That&#39;s interesting, but it&#39;s hard to tell from that if the results generalize to projects that aren&#39;t databases, or even projects that aren&#39;t MySQL.</p> <h3 id="lu-et-al-asplos-08-http-web1-cs-columbia-edu-junfeng-10fa-e6998-papers-concurrency-bugs-pdf"><a href="http://web1.cs.columbia.edu/~junfeng/10fa-e6998/papers/concurrency-bugs.pdf">Lu et al. ASPLOS &#39;08</a></h3> <p>They looked at concurrency bugs in MySQL, Firefox, OpenOffice, and Apache. Some of their findings are:</p> <h4 id="97-of-examined-non-deadlock-bugs-were-atomicity-violation-or-order-violation-bugs">97% of examined non-deadlock bugs were atomicity-violation or order-violation bugs</h4> <p>Of the 74 non-deadlock bugs studied, 51 were atomicity bugs, 24 were ordering bugs, and 2 were categorized as &#34;other&#34;.</p> <p>An example of an atomicity violation is this bug from MySQL:</p> <p>Thread 1:</p> <pre><code>if (thd-&gt;proc_info)
  fputs(thd-&gt;proc_info, ...)
</code></pre> <p>Thread 2:</p> <pre><code>thd-&gt;proc_info = NULL;
</code></pre> <p>For anyone who isn&#39;t used to C or C++, <code>thd</code> is a pointer, and <code>-&gt;</code> is the operator to access a field through a pointer. The first line in thread 1 checks if the field is null. The second line calls <code>fputs</code>, which writes the field. The intent is to only call <code>fputs</code> if and only if <code>proc_info</code> isn&#39;t <code>NULL</code>, but there&#39;s nothing preventing another thread from setting <code>proc_info</code> to <code>NULL</code> &#34;between&#34; the first and second lines of thread 1.</p> <p>Like most bugs, this bug is obvious in retrospect, but if we look at the original bug report, <a href="http://bugs.mysql.com/bug.php?id=3596">we can see that it wasn&#39;t obvious at the time</a>:</p> <blockquote> <p>Description: I&#39;ve just noticed with the latest bk tree than MySQL regularly crashes in InnoDB code ... How to repeat: I&#39;ve still no clues on why this crash occurs.</p> </blockquote> <p>As is common with large codebases, fixing the bug once it was diagnosed was more complicated than it first seemed. This bug was partially fixed in 2004, <a href="https://bugs.mysql.com/bug.php?id=38883">resurfaced again and was fixed in 2008</a>. <a href="https://bugs.mysql.com/bug.php?id=38816">A fix for another bug caused a regression in 2009</a>, which was also fixed in 2009. That fix introduced <a href="https://bugs.mysql.com/bug.php?id=60682">a deadlock that was found in 2011</a>.</p> <p>An example ordering bug is the following bug from Firefox:</p> <p>Thread 1:</p> <pre><code>mThread=PR_CreateThread(mMain, ...);
</code></pre> <p>Thread 2:</p> <pre><code>void mMain(...) {
  mState = mThread-&gt;State;
  }
</code></pre> <p><code>Thread 1</code> launches <code>Thread 2</code> with <code>PR_CreateThread</code>. <code>Thread 2</code> assumes that, because the line that launched it assigned to <code>mThread</code>, <code>mThread</code> is valid. But <code>Thread 2</code> can start executing before <code>Thread 1</code> has assigned to <code>mThread</code>! The authors note that they call this an ordering bug and not an atomicity bug even though the bug could have been prevented if the line in thread 1 were atomic because their &#34;bug pattern categorization is based on root cause, regardless of possible fix strategies&#34;.</p> <p>An example of an &#34;other&#34; bug, one of only two studied, is this bug in MySQL:</p> <p>Threads 1...n:</p> <pre><code>rw_lock(&amp;lock);
</code></pre> <p>Watchdog thread:</p> <pre><code>if (lock_wait_time[i] &gt; fatal_timeout)
  assert(0);
</code></pre> <p>This can cause a spurious crash when there&#39;s more than the expected amount of work. Note that the study doesn&#39;t look at performance bugs, so a bug where lock contention causes things to slow to a crawl but a watchdog doesn&#39;t kill the program wouldn&#39;t be considered.</p> <p>An aside that&#39;s probably a topic for another post is that hardware often has deadlock or livelock detection built in, and that when a lock condition is detected, hardware will often try to push things into a state where normal execution can continue. After detecting and breaking deadlock/livelock, an error will typically be logged in a way that it will be noticed if it&#39;s caught in lab, but that external customers won&#39;t see. For some reason, that strategy seems rare in the software world, although it seems like it should be easier in software than in hardware.</p> <p><a href="https://en.wikipedia.org/wiki/Deadlock">Deadlock occurs if and only if the following four conditions are true</a>:</p> <ol> <li>Mutual exclusion: at least one resource must be held in a non-shareable mode. Only one process can use the resource at any given instant of time.</li> <li>Hold and wait or resource holding: a process is currently holding at least one resource and requesting additional resources which are being held by other processes.</li> <li>No preemption: a resource can be released only voluntarily by the process holding it.</li> <li>Circular wait: a process must be waiting for a resource which is being held by another process, which in turn is waiting for the first process to release the resource.</li> </ol> <p>There&#39;s nothing about these conditions that are unique to either hardware or software, and it&#39;s easier to build mechanisms that can back off and replay to relax (2) in software than in hardware. Anyway, back to the study findings.</p> <h4 id="96-of-examined-concurrency-bugs-could-be-reproduced-by-fixing-the-relative-order-of-2-specific-threads">96% of examined concurrency bugs could be reproduced by fixing the relative order of 2 specific threads</h4> <p>This sounds like great news for testing. Testing only orderings between thread pairs is much more tractable than testing all orderings between all threads. Similarly, 92% of examined bugs could be reproduced by fixing the order of four (or fewer) memory accesses. However, there&#39;s a kind of sampling bias here -- only bugs that could be reproduced could be analyzed for a root cause, and bugs that only require ordering between two threads or only a few memory accesses are easier to reproduce.</p> <h4 id="97-of-examined-deadlock-bugs-were-caused-by-two-threads-waiting-for-at-most-two-resources">97% of examined deadlock bugs were caused by two threads waiting for at most two resources</h4> <p>Moreover, 22% of examined deadlock bugs were caused by a thread acquiring a resource held by the thread itself. The authors state that pairwise testing of acquisition and release sequences should be able to catch most deadlock bugs, and that pairwise testing of thread orderings should be able to catch most non-deadlock bugs. The claim seems plausibly true when read as written; the implication seems to be that virtually all bugs can be caught through some kind of pairwise testing, but I&#39;m a bit skeptical of that due to the sample bias of the bugs studied.</p> <p>I&#39;ve seen bugs with many moving parts take months to track down. The worst bug I&#39;ve seen consumed nearly a person-year&#39;s worth of time. Bugs like that mostly don&#39;t make it into studies like this because it&#39;s rare that a job allows someone the time to chase bugs that elusive. How many bugs like that are out there is still an open question.</p> <h4 id="caveats">Caveats</h4> <p>Note that all of the programs studied were written in C or C++, and that this study predates C++11. Moving to C++11 and using atomics and scoped locks would probably change the numbers substantially, not to mention moving to an entirely different concurrency model. There&#39;s some academic work on how different concurrency models affect bug rates, but it&#39;s not really clear how that work generalizes to codebases as large and mature as the ones studied, and by their nature, large and mature codebases are hard to do randomized trials on when the trial involves changing the fundamental primitives used. The authors note that 39% of examined bugs could have been prevented by using transactional memory, but it&#39;s not clear how many other bugs might have been introduced if transactional memory were used.</p> <h3 id="tools">Tools</h3> <p>There are other papers on characterizing single-machine concurrency bugs, but in the interest of space, I&#39;m going to skip those. There are also papers on distributed concurrency bugs, but before we get to that, let&#39;s look at some of the tooling for finding single-machine concurrency bugs that&#39;s in the literature. I find the papers to be pretty interesting, especially the model checking work, but realistically, I&#39;m probably not going to build a tool from scratch if something is available, so let&#39;s look at what&#39;s out there.</p> <h4 id="hapset">HapSet</h4> <p>Uses run-time coverage to generate interleavings that haven&#39;t been covered yet. This is out of NEC labs; googling <code>NEC labs HapSet</code> returns the paper, <a href="https://www.google.com/patents/US20120089873">some patent listings</a>, but no obvious download for the tool.</p> <h4 id="chess-https-chesstool-codeplex-com"><a href="https://chesstool.codeplex.com/">CHESS</a></h4> <p>Generates unique interleavings of threads for each run. They claim that, by not tracking state, the checker is much simpler than it would otherwise be, and that they&#39;re able to avoid many of the disadvantages of tracking state via a detail that can&#39;t properly be described in this tiny little paragraph; read the paper if you&#39;re interested! Supports C# and C++. The page claims that it requires Visual Studio 2010 and that it&#39;s only been tested with 32-bit code. I haven&#39;t tried to run this on a modern *nix compiler, but IME requiring Visual Studio 2010 means that it would be a moderate effort to get it running on a modern version of Visual Studio, and a substantial effort to get it running on a modern version of gcc or clang. A quick Google search indicates that this might be patent encumbered.</p> <h4 id="maple-https-github-com-jieyu-maple"><a href="https://github.com/jieyu/maple">Maple</a></h4> <p>Uses coverage to generate interleavings that haven&#39;t been covered yet. Instruments pthreads. The source is up on GitHub. It&#39;s possible this tool is still usable, and I&#39;ll probably give it a shot at some point, but it depends on at least one old, apparently unmaintained tool (PIN, a binary instrumentation tool from Intel). Googling (Binging?) for either Maple or PIN gives a number of results where people can&#39;t even get the tool to compile, let alone use the tool.</p> <h4 id="pacer">PACER</h4> <p>Samples using the FastTrack algorithm in order to keep overhead low enough &#34;to consider in production software&#34;. Ironically, this was implemented on top of the Jikes RVM, which is unlikely to be used in actual production software. The only reference I could find for an actually downloadable tool is <a href="https://github.com/pangloss/pacer">a completely different pacer</a>.</p> <h4 id="conlock-magiclock-magicfuzzer">ConLock / MagicLock / MagicFuzzer</h4> <p>There&#39;s a series of tools that are from one group which claims to get good results using various techniques, but AFAICT the source isn&#39;t available for any of the tools. There&#39;s a page that claims there&#39;s a version of MagicFuzzer available, but it&#39;s a link to a binary that doesn&#39;t specify what platform the binary is for and the link 404s.</p> <h4 id="omen-wolf">OMEN / WOLF</h4> <p>I couldn&#39;t find a page for these tools (other than their papers), let alone a download link.</p> <h4 id="sherlock-atomchase-racageddon">SherLock / AtomChase / Racageddon</h4> <p>Another series of tools that aren&#39;t obviously available.</p> <h3 id="tools-you-can-actually-easily-use">Tools you can actually easily use</h3> <h4 id="valgrind-drd-helgrind">Valgrind / DRD / Helgrind</h4> <p>Instruments pthreads and easy to use -- just run valgrind with the appropriate options (<code>-drd</code> or <code>-helgrind</code>) on the binary. May require <a href="http://valgrind.org/docs/manual/drd-manual.html#drd-manual.C++11">a couple tweaks</a> if using C++11 threading.</p> <h4 id="clang-thread-sanitizer-http-clang-llvm-org-docs-threadsanitizer-html-tsan"><a href="http://clang.llvm.org/docs/ThreadSanitizer.html">clang thread sanitizer</a> (TSan)</h4> <p>Can find data races. Flags when <a href="http://stackoverflow.com/questions/11970428/how-to-understand-happens-before-consistent">happens-before</a> is violated. Works with pthreads and C++11 threads. Easy to use (just pass a <code>-fsanitize=thread</code> to clang).</p> <p>A side effect of being so easy to use and actually available is that <a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43217.pdf">tsan has had a very large impact in the real world</a>:</p> <blockquote> <p>One interesting incident occurred in the open source Chrome browser. Up to 15% of known crashes were attributed to just one bug [5], which proved difficult to understand - the Chrome engineers spent over 6 months tracking this bug without success. On the other hand, the TSAN V1 team found the reason for this bug in a 30 minute run, without even knowing about these crashes. The crashes were caused by data races on a couple of reference counters. Once this reason was found, a relatively trivial fix was quickly made and patched in, and subsequently the bug was closed.</p> </blockquote> <h4 id="clang-wthread-safety">clang <code>-Wthread-safety</code></h4> <p>Static analysis that uses annotations on shared state to determine if state wasn&#39;t correctly guarded.</p> <h4 id="findbugs-https-en-wikipedia-org-wiki-findbugs"><a href="https://en.wikipedia.org/wiki/FindBugs">FindBugs</a></h4> <p>General static analysis for Java with many features. Has <code>@GuardedBy</code> annotations, similar to <code>-Wthread-safety</code>.</p> <h4 id="checkerframework-http-types-cs-washington-edu-checker-framework"><a href="http://types.cs.washington.edu/checker-framework/">CheckerFramework</a></h4> <p>Java framework for writing checkers. Has many different checkers. For concurrency in particular, uses <code>@GuardedBy</code>, like FindBugs.</p> <h4 id="rr-http-rr-project-org"><a href="http://rr-project.org/">rr</a></h4> <p>Deterministic replay for debugging. Easy to get and use, and appears to be actively maintained. Adds support for time-travel debugging in gdb.</p> <h4 id="drdebug-https-software-intel-com-en-us-articles-pintool-drdebug-pinplay-https-sites-google-com-site-pinplaypldi2016tutorial"><a href="https://software.intel.com/en-us/articles/pintool-drdebug">DrDebug</a>/<a href="https://sites.google.com/site/pinplaypldi2016tutorial/">PinPlay</a></h4> <p>General toolkit that can give you deterministic replay for debugging. Also gives you &#34;dynamic slicing&#34;, which is watchpoint-like: it can tell you what statements affected a variable, as well as what statements are affected by a variable. Currently Linux only; claims Windows and Android support coming soon.</p> <h3 id="other-tools">Other tools</h3> <p>This isn&#39;t an exhaustive list -- there&#39;s a ton of literature on this, and this is an area where, frankly, I&#39;m pretty unlikely to have the time to implement a tool myself, so there&#39;s not much value for me in reading more papers to find out about techniques that I&#39;d have to implement myself. However, I&#39;d be interested in hearing about other tools that are usable.</p> <p>One thing I find interesting about this is that almost all of the papers for the academic tools claim to do something novel that lets them find bugs not found by other tools. They then run their tool on some codebase and show that the tool is capable of finding new bugs. But since almost no one goes and runs the older tools on any codebase, you&#39;d never know if one of the newer tools only found a subset of the bugs that one of the older tools could catch.</p> <p>Furthermore, you see cycles (livelock?) in how papers claim to be novel. Paper I will claim that it does X. Paper II will claim that it&#39;s novel because it doesn&#39;t need to do X, unlike Paper I. Then Paper III will claim that it&#39;s novel because, unlike Paper II, it does X.</p> <h3 id="distributed-systems">Distributed systems</h3> <p>Now that we&#39;ve looked at some of the literature on single-machine concurrency bugs, what about distributed concurrency bugs?</p> <h3 id="leesatapornwongsa-et-al-asplos-2016-http-ucare-cs-uchicago-edu-pdf-asplos16-taxdc-pdf"><a href="http://ucare.cs.uchicago.edu/pdf/asplos16-TaxDC.pdf">Leesatapornwongsa et al. ASPLOS 2016</a></h3> <p>They looked at 104 bugs in Cassandra, MapReduce, HBase, and Zookeeper. Let&#39;s look at some example bugs, which will clarify the terminology used in the study and make it easier to understanding the main findings.</p> <h4 id="message-message-race">Message-message race</h4> <p><a href="http://hadoop.apache.org/docs/current/hadoop-yarn/hadoop-yarn-site/YARN.html">This diagram</a> is just for reference, so that we have a high-level idea of how different parts fit together in MapReduce:</p> <p><img src="https://danluu.com/images/concurrency-bugs/mapreduce_block_diagram.gif" alt="Block diagram of MapReduce"/></p> <p><a href="https://issues.apache.org/jira/browse/MAPREDUCE-3274">In MapReduce bug #3274</a>, a resource manager sends a task-init message to a node manager. Shortly afterwards, an application master sends a task-kill preemption to the same node manager. The intent is for the task-kill message to kill the task that was started with the task-init message, but the task-kill can win the race and arrive before the task-init. This example happens to be a case where two messages from different nodes are racing to get to a single node.</p> <p>For example, in <a href="https://issues.apache.org/jira/browse/MAPREDUCE-5358">MapReduce bug #5358</a>, an application master sends a kill message to node manager running a speculative task because another copy of the task finished. However, before the message is received by the node manager, the node manager&#39;s task completes, causing a complete message to be sent to the application master, causing an exception because a <code>complete</code> message was received after the task had completed.</p> <h4 id="message-compute-race">Message-compute race</h4> <p>One example is <a href="https://issues.apache.org/jira/browse/MAPREDUCE-4157">MapReduce bug# 4157</a>, where the application master unregisters with the resource manager. The application master then cleans up, but that clean-up races against the resource manager sending kill messages to the application&#39;s containers via node managers, causing the application master to get killed. Note that this is classified as a race and not an atomicity bug, which we&#39;ll get to shortly.</p> <p>Compute-compute races can happen, but they&#39;re outside the scope of this study since this study only looks at distributed concurrency bugs.</p> <h4 id="atomicity-violation">Atomicity violation</h4> <p>For the purposes of this study, atomicity bugs are defined as &#34;whenever a message comes in the middle of a set of events, which is a local computation or global communication, but not when the message comes either before or after the events&#34;. According to this definition, the message-compute race we looked at above isn&#39;t a atomicity bug because it would still be a bug if the message came in before the &#34;computation&#34; started. This definition also means that hardware failures that occur inside a block that must be atomic are not considered atomicity bugs.</p> <p>I can see why you&#39;d want to define those bugs as separate types of bugs, but I find this to be a bit counterintuitive, since I consider all of these to be different kinds of atomicity bugs because they&#39;re different bugs that are caused by breaking up something that needs to be atomic.</p> <p>In any case, by the definition of this study, <a href="https://issues.apache.org/jira/browse/MAPREDUCE-5009">MapReduce bug #5009</a> is an atomicty bug. A node manager is in the process of committing data to HDFS. The resource manager kills the task, which doesn&#39;t cause the commit state to change. Any time the node tries to rerun the commit task, the task is killed by the application manager because a commit is believed to already be in process.</p> <h4 id="fault-timing">Fault timing</h4> <p>A fault is defined to be a &#34;component failure&#34;, such as a crash, timeout, or unexpected latency. At one point, the paper refers to &#34;hardware faults such as machine crashes&#34;, which seems to indicate that some faults that could be considered software faults are defined as hardware faults for the purposes of this study.</p> <p>Anyway, for the purposes of this study, an example of a fault-timing issue is <a href="https://issues.apache.org/jira/browse/MAPREDUCE-3858">MapReduce bug #3858</a>. A node manager crashes while committing results. When the task is re-run, later attempts to commit all fail.</p> <h4 id="reboot-timing">Reboot timing</h4> <p>In this study, reboots are classified separately from other faults. <a href="https://issues.apache.org/jira/browse/MAPREDUCE-3186">MapReduce bug #3186</a> illustrates a reboot bug.</p> <p>A resource manager sends a job to an application master. If the resource manager is rebooted before the application master sends a commit message back to the resource manager, the resource manager loses its state and throws an exception because it&#39;s getting an unexpected complete message.</p> <p>Some of their main findings are:</p> <h4 id="47-of-examined-bugs-led-to-latent-failures">47% of examined bugs led to latent failures</h4> <p>That&#39;s a pretty large difference when compared to the DSN&#39; 10 paper that found that 15% of examined multithreading bugs were latent failures. It&#39;s plausible that this is a real difference and not just something due to a confounding variable, but it&#39;s hard to tell from the data.</p>  <p>This is a large difference from what studies on &#34;local&#34; concurrency bugs found. I wonder how much of that is just because <a href="http://danluu.com/file-consistency/#error-frequency">people mostly don&#39;t even bother filing and fixing bugs on hardware faults in non-distributed software</a>.</p> <h4 id="64-of-examined-bugs-were-triggered-by-a-single-message-s-timing">64% of examined bugs were triggered by a single message&#39;s timing</h4> <p>44% were ordering violations, and 20% were atomicity violations. Furthermore, &gt; 90% of bugs involved three messages (or fewer).</p> <p>32% of examined bugs were due to fault or reboot timing. Note that, for the purposes of the study, a hardware fault or a reboot that breaks up a block that needed to be atomic isn&#39;t considered an atomicity bug -- here, atomicity bugs are bugs where a message arrives in the middle of a computation that needs to be atomic.</p> <h4 id="70-of-bugs-had-simple-fixes">70% of bugs had simple fixes</h4> <p>30% were fixed by ignoring the badly timed message and 40% were fixed by delaying or ignoring the message.</p> <h4 id="bug-causes">Bug causes?</h4> <p>After reviewing the bugs, the authors propose common fallacies that lead to bugs:</p> <ol> <li>One hop is faster than two hops</li> <li>Zero hops are faster than one hop</li> <li>Atomic blocks can&#39;t be broken</li> </ol> <p>On (3), the authors note that it&#39;s not just hardware faults or reboots that break up atomic blocks -- systems can send kill or pre-emption messages that break up an atomic block. A fallacy which I&#39;ve commonly seen in post-mortems that&#39;s not listed here, goes something like &#34;<a href="https://en.wikipedia.org/wiki/Byzantine_fault_tolerance">bad nodes are obviously bad</a>&#34;. A classic example of this is when a system starts &#34;handling&#34; queries by dropping them quickly, causing a load balancer to shift traffic the bad node because it&#39;s handling traffic so quickly.</p> <p>One of my favorite bugs in this class from an actual system was in a ring-based storage system where nodes could do health checks on their neighbors and declare that their neighbors should be dropped if the health check fails. One node went bad, dropped all of its storage, and started reporting its neighbors as bad nodes. Its neighbors noticed that the bad node was bad, but because the bad node had dropped all of its storage, it was super fast and was able to report its good neighbors before the good neighbors could report the bad node. After ejecting its immediate neighbors, the bad node got new neighbors and raced the new neighbors, winning again for the same reason. This was repeated until the entire cluster died.</p> <h3 id="tools-1">Tools</h3> <h4 id="mace">Mace</h4> <p>A set of language extensions (on C++) that helps you build distributed systems. Mace has a model checker that can check all possible event orderings of messages, interleaved with crashes, reboots, and timeouts. The Mace model checker is actually available, but AFAICT it requires using the Mace framework, and most distributed systems aren&#39;t written in Mace.</p> <h4 id="modist">Modist</h4> <p>Another model checker that checks different orderings. Runs only one interleaving of independent actions (partial order reduction) to avoid checking redundant states. Also interleaves timeouts. Unlike Mace, doesn&#39;t inject reboots. Doesn&#39;t appear to be available.</p> <h4 id="demeter">Demeter</h4> <p>Like Modist, in that it&#39;s a model checker that injects the same types of faults. Uses a different technique to reduce the state space, which I don&#39;t know how to summarize succinctly. See paper for details. Doesn&#39;t appear to be available. Googling for Demeter returns some software used to model X-ray absorption?</p> <h4 id="samc">SAMC</h4> <p>Another model checker. Can inject multiple crashes and reboots. Uses some understanding of the system to avoid redundant re-orderings (e.g., if a series of messages is invariant to when a reboot is injected, the system tries to avoid injecting the reboot between each message). Doesn&#39;t appear to be available.</p> <h4 id="jepsen">Jepsen</h4> <p>As was the case for non-distributed concurrency bugs, there&#39;s a vast literature on academic tools, most of which appear to be grad-student code that hasn&#39;t been made available.</p> <p>And of course there&#39;s Jepsen, which doesn&#39;t have any attached academic papers, but has probably had more real-world impact than any of the other tools because <a href="https://github.com/aphyr/jepsen">it&#39;s actually available and maintained</a>. There&#39;s also <a href="https://github.com/Netflix/SimianArmy/wiki/Chaos-Monkey">chaos monkey</a>, but if I&#39;m understanding it correctly, unlike the other tools listed, it doesn&#39;t attempt to create reproducible failures.</p> <h3 id="conclusion">Conclusion</h3> <p>Is this where you&#39;re supposed to have a conclusion? I don&#39;t have a conclusion. We&#39;ve looked at some literature and found out some information about bugs that&#39;s interesting, but not necessarily actionable. We&#39;ve read about tools that are interesting, but not actually available. And then there are some tools based on old techniques that are available and useful.</p> <p>For example, the idea inside clang&#39;s TSan, using &#34;happens-before&#34; to find data races, goes back ages. There&#39;s <a href="http://www.cs.columbia.edu/~junfeng/10fa-e6998/papers/hybrid.pdf">a 2003 paper</a> that discusses &#34;combining two previously known race detection techniques -- lockset-based detection and happens-before-based detection -- to obtain fewer false positives than lockset-based detection alone&#34;. That&#39;s actually what TSan v1 did, but with TSan v2 they realized the tool would be more impactful if they only used happens-before because that avoids false positives, which means that people will actually use the tool. That&#39;s not something that&#39;s likely to turn into a paper that gets cited zillions of times, though. For anyone who&#39;s looked at how <a href="http://lcamtuf.coredump.cx/afl/README.txt">afl</a> works, this story should sound familiar. AFL is emintently practical and has had a very large impact in the real world, mostly by eschewing fancy techniques from the recent literature.</p> <p>If you must have a conclusion, maybe the conclusion is that individuals like Kyle Kingsbury or Michal Zalewski have had an outsized impact on industry, and that you too can probably pick an underserved area in testing and have a curiously large impact on an entire industry.</p>  <p><a href="https://github.com/rose">Rose Ames</a> asked me to tell more &#34;big company&#34; stories, so here&#39;s a set of stories that explains why I haven&#39;t put a blog post up for a while. The proximal cause is that my VP has been getting negative comments about my writing. But the reasons for that are a bit of a long story. Part of it is the usual thing, where the comments I receive personally skew very heavily positive, but the comments my manager gets run the other way because it&#39;s weird to email someone&#39;s manager because you like their writing, but you might send an email if their writing really strikes a nerve.</p> <p>That explains why someone in my management chain was getting emailed about my writing, but it doesn&#39;t explain why the emails went to my VP. That&#39;s because I switched teams a few months ago, and the org that I was going to switch into overhired and didn&#39;t have any headcount. I&#39;ve heard conflicting numbers about how much they overhired, from 10 or 20 people to 10% or 20% (the org is quite large, and 10% would be much more than 20), as well as conflicting stories about why it happened (honest mistake vs. some group realizing that there was a hiring crunch coming and hiring as much as possible to take all of the reqs from the rest of the org). Anyway, for some reason, the org I would have worked in hired more than it was allowed to by at least one person and instituted a hiring freeze. Since my new manager couldn&#39;t hire me into that org, he transferred into an org that had spare headcount and hired me into the new org. The new org happens to be a sales org, which means that I technically work in sales now; this has some impact on my day-to-day life since there are some resources and tech talks that are only accessible by people in product groups, but that&#39;s another story. Anyway, for reasons that I don&#39;t fully understand, I got hired into the org before my new manager, and during the months it took for the org chart to get updated I was shown as being parked under my VP, which meant that anyone who wanted to fire off an email to my manager would look me up in the directory and accidentally email my VP instead.</p> <p>It didn&#39;t seem like any individual email was a big deal, but since I don&#39;t have much interaction with my VP and I don&#39;t want to only be known as that guy who writes stuff which generates pushback from inside the company, I paused blogging for a while. I don&#39;t exactly want to be known that way to my manager either, but I interact with my manager frequently enough that at least I won&#39;t only be known for that.</p> <p>I also wonder if these emails to my manager/VP are more likely at my current employer than at previous employers. I&#39;ve never had this happen (that I know of) at another employer, but the total number of times it&#39;s happened here is low enough that it might just be coincidence.</p> <p>Then again, I was just reading the archives of a really insightful internal blog and ran across a note that mentioned that the series of blog posts was being published internally because the author got static from <a href="https://news.ycombinator.com/item?id=11761437">Sinofsky</a> about publishing posts that contradicted the party line, which eventually resulted in the author agreeing to email Sinofsky comments related to anything under Sinofsky&#39;s purview instead of publishing the comments publicly. But now that Sinofsky has moved on, the author wanted to share emails that would have otherwise been posts internally.</p> <p>That kind of thing doesn&#39;t seem to be a freak occurance around here. At the same time I saw that thing about Sinofsky, I ran across a discussion on whether or not a PM was within their rights to tell someone to take down a negative review from the app store. Apparently, a PM found out that someone had written a negative rating on the PM&#39;s product in some app store and emailed the rater, telling them that they had to take the review down. It&#39;s not clear how the PM found out that the rater worked for us (do they search the internal directory for every negative rating they find?), but they somehow found out and then issued their demand. Most people thought that the PM was out of line, but there were a non-zero number of people (in addition to the PM) who thought that employees should not say anything that could be construed as negative about the company in public.</p> <p>I feel like I see more of this kind of thing now than I have at other companies, but the company&#39;s really too big to tell if anyone&#39;s personal experience generalizes. Anyway, I&#39;ll probably start blogging again now that the org chart shows that I report to my actual manager, and maybe my manager will get some emails about that. Or maybe not.</p> <p><em>Thanks to Leah Hanson, David Turner, Justin Mason, Joe Wilder, Matt Dziubinski, Alex Blewitt, Bruno Kim Medeiros Cesar, Luke Gilliam, Ben Karas, Julia Evans, Michael Ernst, and Stephen Tu for comments/corrections.</em></p>   </div>
  </body>
</html>
